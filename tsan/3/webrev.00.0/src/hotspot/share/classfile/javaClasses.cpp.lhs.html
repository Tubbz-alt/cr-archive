<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/share/classfile/javaClasses.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
    <script type="text/javascript" src="../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
<a name="1" id="anc1"></a><span class="line-modified">   2  * Copyright (c) 1997, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include &quot;precompiled.hpp&quot;
  26 #include &quot;classfile/altHashing.hpp&quot;
  27 #include &quot;classfile/classLoaderData.inline.hpp&quot;
  28 #include &quot;classfile/javaClasses.inline.hpp&quot;
  29 #include &quot;classfile/moduleEntry.hpp&quot;
  30 #include &quot;classfile/stringTable.hpp&quot;
<a name="2" id="anc2"></a>
  31 #include &quot;classfile/vmSymbols.hpp&quot;
  32 #include &quot;code/debugInfo.hpp&quot;
  33 #include &quot;code/dependencyContext.hpp&quot;
  34 #include &quot;code/pcDesc.hpp&quot;
  35 #include &quot;interpreter/interpreter.hpp&quot;
  36 #include &quot;interpreter/linkResolver.hpp&quot;
  37 #include &quot;logging/log.hpp&quot;
  38 #include &quot;logging/logStream.hpp&quot;
  39 #include &quot;memory/heapShared.inline.hpp&quot;
  40 #include &quot;memory/metaspaceShared.hpp&quot;
  41 #include &quot;memory/oopFactory.hpp&quot;
  42 #include &quot;memory/resourceArea.hpp&quot;
  43 #include &quot;memory/universe.hpp&quot;
<a name="3" id="anc3"></a><span class="line-modified">  44 #include &quot;oops/fieldStreams.hpp&quot;</span>
  45 #include &quot;oops/instanceKlass.hpp&quot;
  46 #include &quot;oops/instanceMirrorKlass.hpp&quot;
  47 #include &quot;oops/klass.hpp&quot;
  48 #include &quot;oops/method.inline.hpp&quot;
  49 #include &quot;oops/objArrayOop.inline.hpp&quot;
  50 #include &quot;oops/oop.inline.hpp&quot;
  51 #include &quot;oops/symbol.hpp&quot;
<a name="4" id="anc4"></a>
  52 #include &quot;oops/typeArrayOop.inline.hpp&quot;
  53 #include &quot;prims/jvmtiExport.hpp&quot;
  54 #include &quot;prims/resolvedMethodTable.hpp&quot;
  55 #include &quot;runtime/fieldDescriptor.inline.hpp&quot;
  56 #include &quot;runtime/frame.inline.hpp&quot;
  57 #include &quot;runtime/handles.inline.hpp&quot;
<a name="5" id="anc5"></a>
  58 #include &quot;runtime/interfaceSupport.inline.hpp&quot;
  59 #include &quot;runtime/java.hpp&quot;
  60 #include &quot;runtime/javaCalls.hpp&quot;
  61 #include &quot;runtime/jniHandles.inline.hpp&quot;
  62 #include &quot;runtime/safepoint.hpp&quot;
  63 #include &quot;runtime/safepointVerifiers.hpp&quot;
  64 #include &quot;runtime/thread.inline.hpp&quot;
  65 #include &quot;runtime/vframe.inline.hpp&quot;
<a name="6" id="anc6"></a>
  66 #include &quot;utilities/align.hpp&quot;
  67 #include &quot;utilities/preserveException.hpp&quot;
<a name="7" id="anc7"></a>
  68 #if INCLUDE_JVMCI
  69 #include &quot;jvmci/jvmciJavaClasses.hpp&quot;
  70 #endif
  71 
  72 #define INJECTED_FIELD_COMPUTE_OFFSET(klass, name, signature, may_be_java)    \
  73   klass::_##name##_offset = JavaClasses::compute_injected_offset(JavaClasses::klass##_##name##_enum);
  74 
  75 #if INCLUDE_CDS
  76 #define INJECTED_FIELD_SERIALIZE_OFFSET(klass, name, signature, may_be_java) \
  77   f-&gt;do_u4((u4*)&amp;_##name##_offset);
  78 #endif
  79 
  80 #define DECLARE_INJECTED_FIELD(klass, name, signature, may_be_java)           \
  81   { SystemDictionary::WK_KLASS_ENUM_NAME(klass), vmSymbols::VM_SYMBOL_ENUM_NAME(name##_name), vmSymbols::VM_SYMBOL_ENUM_NAME(signature), may_be_java },
  82 
  83 InjectedField JavaClasses::_injected_fields[] = {
  84   ALL_INJECTED_FIELDS(DECLARE_INJECTED_FIELD)
  85 };
  86 
<a name="8" id="anc8"></a>














  87 int JavaClasses::compute_injected_offset(InjectedFieldID id) {
  88   return _injected_fields[id].compute_offset();
  89 }
  90 
  91 InjectedField* JavaClasses::get_injected(Symbol* class_name, int* field_count) {
  92   *field_count = 0;
  93 
  94   vmSymbols::SID sid = vmSymbols::find_sid(class_name);
  95   if (sid == vmSymbols::NO_SID) {
  96     // Only well known classes can inject fields
  97     return NULL;
  98   }
  99 
 100   int count = 0;
 101   int start = -1;
 102 
 103 #define LOOKUP_INJECTED_FIELD(klass, name, signature, may_be_java) \
 104   if (sid == vmSymbols::VM_SYMBOL_ENUM_NAME(klass)) {              \
 105     count++;                                                       \
 106     if (start == -1) start = klass##_##name##_enum;                \
 107   }
 108   ALL_INJECTED_FIELDS(LOOKUP_INJECTED_FIELD);
 109 #undef LOOKUP_INJECTED_FIELD
 110 
 111   if (start != -1) {
 112     *field_count = count;
 113     return _injected_fields + start;
 114   }
 115   return NULL;
 116 }
 117 
 118 
 119 // Helpful routine for computing field offsets at run time rather than hardcoding them
 120 // Finds local fields only, including static fields.  Static field offsets are from the
 121 // beginning of the mirror.
 122 static void compute_offset(int &amp;dest_offset,
 123                            InstanceKlass* ik, Symbol* name_symbol, Symbol* signature_symbol,
 124                            bool is_static = false) {
 125   fieldDescriptor fd;
 126   if (ik == NULL) {
 127     ResourceMark rm;
 128     log_error(class)(&quot;Mismatch JDK version for field: %s type: %s&quot;, name_symbol-&gt;as_C_string(), signature_symbol-&gt;as_C_string());
 129     vm_exit_during_initialization(&quot;Invalid layout of well-known class&quot;);
 130   }
 131 
 132   if (!ik-&gt;find_local_field(name_symbol, signature_symbol, &amp;fd) || fd.is_static() != is_static) {
 133     ResourceMark rm;
 134     log_error(class)(&quot;Invalid layout of %s field: %s type: %s&quot;, ik-&gt;external_name(),
 135                      name_symbol-&gt;as_C_string(), signature_symbol-&gt;as_C_string());
 136 #ifndef PRODUCT
 137     // Prints all fields and offsets
 138     Log(class) lt;
 139     LogStream ls(lt.error());
 140     ik-&gt;print_on(&amp;ls);
 141 #endif //PRODUCT
 142     vm_exit_during_initialization(&quot;Invalid layout of well-known class: use -Xlog:class+load=info to see the origin of the problem class&quot;);
 143   }
 144   dest_offset = fd.offset();
 145 }
 146 
 147 // Overloading to pass name as a string.
 148 static void compute_offset(int&amp; dest_offset, InstanceKlass* ik,
 149                            const char* name_string, Symbol* signature_symbol,
 150                            bool is_static = false) {
 151   TempNewSymbol name = SymbolTable::probe(name_string, (int)strlen(name_string));
 152   if (name == NULL) {
 153     ResourceMark rm;
 154     log_error(class)(&quot;Name %s should be in the SymbolTable since its class is loaded&quot;, name_string);
 155     vm_exit_during_initialization(&quot;Invalid layout of well-known class&quot;, ik-&gt;external_name());
 156   }
 157   compute_offset(dest_offset, ik, name, signature_symbol, is_static);
 158 }
 159 
 160 int java_lang_String::value_offset  = 0;
 161 int java_lang_String::hash_offset   = 0;
<a name="9" id="anc9"></a>
 162 int java_lang_String::coder_offset  = 0;
 163 
 164 bool java_lang_String::initialized  = false;
 165 
 166 bool java_lang_String::is_instance(oop obj) {
 167   return is_instance_inlined(obj);
 168 }
 169 
 170 #if INCLUDE_CDS
 171 #define FIELD_SERIALIZE_OFFSET(offset, klass, name, signature, is_static) \
 172   f-&gt;do_u4((u4*)&amp;offset)
 173 #endif
 174 
 175 #define FIELD_COMPUTE_OFFSET(offset, klass, name, signature, is_static) \
 176   compute_offset(offset, klass, name, vmSymbols::signature(), is_static)
 177 
 178 #define STRING_FIELDS_DO(macro) \
 179   macro(value_offset, k, vmSymbols::value_name(), byte_array_signature, false); \
 180   macro(hash_offset,  k, &quot;hash&quot;,                  int_signature,        false); \
<a name="10" id="anc10"></a><span class="line-modified"> 181   macro(coder_offset, k, &quot;coder&quot;,                 byte_signature,       false)</span>

 182 
 183 void java_lang_String::compute_offsets() {
 184   if (initialized) {
 185     return;
 186   }
 187 
 188   InstanceKlass* k = SystemDictionary::String_klass();
 189   STRING_FIELDS_DO(FIELD_COMPUTE_OFFSET);
 190 
 191   initialized = true;
 192 }
 193 
 194 #if INCLUDE_CDS
 195 void java_lang_String::serialize_offsets(SerializeClosure* f) {
 196   STRING_FIELDS_DO(FIELD_SERIALIZE_OFFSET);
<a name="11" id="anc11"></a><span class="line-modified"> 197   f-&gt;do_u4((u4*)&amp;initialized);</span>
 198 }
 199 #endif
 200 
 201 class CompactStringsFixup : public FieldClosure {
 202 private:
 203   bool _value;
 204 
 205 public:
 206   CompactStringsFixup(bool value) : _value(value) {}
 207 
 208   void do_field(fieldDescriptor* fd) {
 209     if (fd-&gt;name() == vmSymbols::compact_strings_name()) {
 210       oop mirror = fd-&gt;field_holder()-&gt;java_mirror();
 211       assert(fd-&gt;field_holder() == SystemDictionary::String_klass(), &quot;Should be String&quot;);
 212       assert(mirror != NULL, &quot;String must have mirror already&quot;);
 213       mirror-&gt;bool_field_put(fd-&gt;offset(), _value);
 214     }
 215   }
 216 };
 217 
 218 void java_lang_String::set_compact_strings(bool value) {
 219   CompactStringsFixup fix(value);
<a name="12" id="anc12"></a><span class="line-modified"> 220   InstanceKlass::cast(SystemDictionary::String_klass())-&gt;do_local_static_fields(&amp;fix);</span>
 221 }
 222 
 223 Handle java_lang_String::basic_create(int length, bool is_latin1, TRAPS) {
 224   assert(initialized, &quot;Must be initialized&quot;);
 225   assert(CompactStrings || !is_latin1, &quot;Must be UTF16 without CompactStrings&quot;);
 226 
 227   // Create the String object first, so there&#39;s a chance that the String
 228   // and the char array it points to end up in the same cache line.
 229   oop obj;
 230   obj = SystemDictionary::String_klass()-&gt;allocate_instance(CHECK_NH);
 231 
 232   // Create the char array.  The String object must be handlized here
 233   // because GC can happen as a result of the allocation attempt.
 234   Handle h_obj(THREAD, obj);
 235   int arr_length = is_latin1 ? length : length &lt;&lt; 1; // 2 bytes per UTF16.
 236   typeArrayOop buffer = oopFactory::new_byteArray(arr_length, CHECK_NH);;
 237 
 238   // Point the String at the char array
 239   obj = h_obj();
 240   set_value(obj, buffer);
 241   // No need to zero the offset, allocation zero&#39;ed the entire String object
 242   set_coder(obj, is_latin1 ? CODER_LATIN1 : CODER_UTF16);
 243   return h_obj;
 244 }
 245 
 246 Handle java_lang_String::create_from_unicode(const jchar* unicode, int length, TRAPS) {
 247   bool is_latin1 = CompactStrings &amp;&amp; UNICODE::is_latin1(unicode, length);
 248   Handle h_obj = basic_create(length, is_latin1, CHECK_NH);
 249   typeArrayOop buffer = value(h_obj());
 250   assert(TypeArrayKlass::cast(buffer-&gt;klass())-&gt;element_type() == T_BYTE, &quot;only byte[]&quot;);
 251   if (is_latin1) {
 252     for (int index = 0; index &lt; length; index++) {
 253       buffer-&gt;byte_at_put(index, (jbyte)unicode[index]);
 254     }
 255   } else {
 256     for (int index = 0; index &lt; length; index++) {
 257       buffer-&gt;char_at_put(index, unicode[index]);
 258     }
 259   }
 260 
 261 #ifdef ASSERT
 262   {
 263     ResourceMark rm;
 264     char* expected = UNICODE::as_utf8(unicode, length);
 265     char* actual = as_utf8_string(h_obj());
 266     if (strcmp(expected, actual) != 0) {
 267       tty-&gt;print_cr(&quot;Unicode conversion failure: %s --&gt; %s&quot;, expected, actual);
 268       ShouldNotReachHere();
 269     }
 270   }
 271 #endif
 272 
 273   return h_obj;
 274 }
 275 
 276 oop java_lang_String::create_oop_from_unicode(const jchar* unicode, int length, TRAPS) {
 277   Handle h_obj = create_from_unicode(unicode, length, CHECK_0);
 278   return h_obj();
 279 }
 280 
 281 Handle java_lang_String::create_from_str(const char* utf8_str, TRAPS) {
 282   if (utf8_str == NULL) {
 283     return Handle();
 284   }
 285   bool has_multibyte, is_latin1;
 286   int length = UTF8::unicode_length(utf8_str, is_latin1, has_multibyte);
 287   if (!CompactStrings) {
 288     has_multibyte = true;
 289     is_latin1 = false;
 290   }
 291 
 292   Handle h_obj = basic_create(length, is_latin1, CHECK_NH);
 293   if (length &gt; 0) {
 294     if (!has_multibyte) {
 295       const jbyte* src = reinterpret_cast&lt;const jbyte*&gt;(utf8_str);
 296       ArrayAccess&lt;&gt;::arraycopy_from_native(src, value(h_obj()), typeArrayOopDesc::element_offset&lt;jbyte&gt;(0), length);
 297     } else if (is_latin1) {
 298       UTF8::convert_to_unicode(utf8_str, value(h_obj())-&gt;byte_at_addr(0), length);
 299     } else {
 300       UTF8::convert_to_unicode(utf8_str, value(h_obj())-&gt;char_at_addr(0), length);
 301     }
 302   }
 303 
 304 #ifdef ASSERT
 305   // This check is too strict because the input string is not necessarily valid UTF8.
 306   // For example, it may be created with arbitrary content via jni_NewStringUTF.
 307   /*
 308   {
 309     ResourceMark rm;
 310     const char* expected = utf8_str;
 311     char* actual = as_utf8_string(h_obj());
 312     if (strcmp(expected, actual) != 0) {
 313       tty-&gt;print_cr(&quot;String conversion failure: %s --&gt; %s&quot;, expected, actual);
 314       ShouldNotReachHere();
 315     }
 316   }
 317   */
 318 #endif
 319 
 320   return h_obj;
 321 }
 322 
 323 oop java_lang_String::create_oop_from_str(const char* utf8_str, TRAPS) {
 324   Handle h_obj = create_from_str(utf8_str, CHECK_0);
 325   return h_obj();
 326 }
 327 
 328 Handle java_lang_String::create_from_symbol(Symbol* symbol, TRAPS) {
 329   const char* utf8_str = (char*)symbol-&gt;bytes();
 330   int utf8_len = symbol-&gt;utf8_length();
 331 
 332   bool has_multibyte, is_latin1;
 333   int length = UTF8::unicode_length(utf8_str, utf8_len, is_latin1, has_multibyte);
 334   if (!CompactStrings) {
 335     has_multibyte = true;
 336     is_latin1 = false;
 337   }
 338 
 339   Handle h_obj = basic_create(length, is_latin1, CHECK_NH);
 340   if (length &gt; 0) {
 341     if (!has_multibyte) {
 342       const jbyte* src = reinterpret_cast&lt;const jbyte*&gt;(utf8_str);
 343       ArrayAccess&lt;&gt;::arraycopy_from_native(src, value(h_obj()), typeArrayOopDesc::element_offset&lt;jbyte&gt;(0), length);
 344     } else if (is_latin1) {
 345       UTF8::convert_to_unicode(utf8_str, value(h_obj())-&gt;byte_at_addr(0), length);
 346     } else {
 347       UTF8::convert_to_unicode(utf8_str, value(h_obj())-&gt;char_at_addr(0), length);
 348     }
 349   }
 350 
 351 #ifdef ASSERT
 352   {
 353     ResourceMark rm;
 354     const char* expected = symbol-&gt;as_utf8();
 355     char* actual = as_utf8_string(h_obj());
 356     if (strncmp(expected, actual, utf8_len) != 0) {
 357       tty-&gt;print_cr(&quot;Symbol conversion failure: %s --&gt; %s&quot;, expected, actual);
 358       ShouldNotReachHere();
 359     }
 360   }
 361 #endif
 362 
 363   return h_obj;
 364 }
 365 
 366 // Converts a C string to a Java String based on current encoding
 367 Handle java_lang_String::create_from_platform_dependent_str(const char* str, TRAPS) {
 368   assert(str != NULL, &quot;bad arguments&quot;);
 369 
<a name="13" id="anc13"></a><span class="line-modified"> 370   typedef jstring (*to_java_string_fn_t)(JNIEnv*, const char *);</span>
 371   static to_java_string_fn_t _to_java_string_fn = NULL;
 372 
 373   if (_to_java_string_fn == NULL) {
 374     void *lib_handle = os::native_java_library();
<a name="14" id="anc14"></a><span class="line-modified"> 375     _to_java_string_fn = CAST_TO_FN_PTR(to_java_string_fn_t, os::dll_lookup(lib_handle, &quot;NewStringPlatform&quot;));</span>






 376     if (_to_java_string_fn == NULL) {
<a name="15" id="anc15"></a><span class="line-modified"> 377       fatal(&quot;NewStringPlatform missing&quot;);</span>
 378     }
 379   }
 380 
 381   jstring js = NULL;
<a name="16" id="anc16"></a><span class="line-modified"> 382   { JavaThread* thread = (JavaThread*)THREAD;</span>
<span class="line-modified"> 383     assert(thread-&gt;is_Java_thread(), &quot;must be java thread&quot;);</span>

 384     HandleMark hm(thread);
 385     ThreadToNativeFromVM ttn(thread);
 386     js = (_to_java_string_fn)(thread-&gt;jni_environment(), str);
 387   }
<a name="17" id="anc17"></a><span class="line-modified"> 388   return Handle(THREAD, JNIHandles::resolve(js));</span>



 389 }
 390 
 391 // Converts a Java String to a native C string that can be used for
 392 // native OS calls.
 393 char* java_lang_String::as_platform_dependent_str(Handle java_string, TRAPS) {
 394   typedef char* (*to_platform_string_fn_t)(JNIEnv*, jstring, bool*);
 395   static to_platform_string_fn_t _to_platform_string_fn = NULL;
 396 
 397   if (_to_platform_string_fn == NULL) {
 398     void *lib_handle = os::native_java_library();
 399     _to_platform_string_fn = CAST_TO_FN_PTR(to_platform_string_fn_t, os::dll_lookup(lib_handle, &quot;GetStringPlatformChars&quot;));
 400     if (_to_platform_string_fn == NULL) {
 401       fatal(&quot;GetStringPlatformChars missing&quot;);
 402     }
 403   }
 404 
 405   char *native_platform_string;
 406   { JavaThread* thread = (JavaThread*)THREAD;
 407     assert(thread-&gt;is_Java_thread(), &quot;must be java thread&quot;);
 408     JNIEnv *env = thread-&gt;jni_environment();
 409     jstring js = (jstring) JNIHandles::make_local(env, java_string());
 410     bool is_copy;
 411     HandleMark hm(thread);
 412     ThreadToNativeFromVM ttn(thread);
 413     native_platform_string = (_to_platform_string_fn)(env, js, &amp;is_copy);
 414     assert(is_copy == JNI_TRUE, &quot;is_copy value changed&quot;);
 415     JNIHandles::destroy_local(js);
 416   }
 417   return native_platform_string;
 418 }
 419 
 420 Handle java_lang_String::char_converter(Handle java_string, jchar from_char, jchar to_char, TRAPS) {
 421   oop          obj    = java_string();
 422   // Typical usage is to convert all &#39;/&#39; to &#39;.&#39; in string.
 423   typeArrayOop value  = java_lang_String::value(obj);
 424   int          length = java_lang_String::length(obj, value);
 425   bool      is_latin1 = java_lang_String::is_latin1(obj);
 426 
 427   // First check if any from_char exist
 428   int index; // Declared outside, used later
 429   for (index = 0; index &lt; length; index++) {
 430     jchar c = !is_latin1 ? value-&gt;char_at(index) :
 431                   ((jchar) value-&gt;byte_at(index)) &amp; 0xff;
 432     if (c == from_char) {
 433       break;
 434     }
 435   }
 436   if (index == length) {
 437     // No from_char, so do not copy.
 438     return java_string;
 439   }
 440 
 441   // Check if result string will be latin1
 442   bool to_is_latin1 = false;
 443 
 444   // Replacement char must be latin1
 445   if (CompactStrings &amp;&amp; UNICODE::is_latin1(to_char)) {
 446     if (is_latin1) {
 447       // Source string is latin1 as well
 448       to_is_latin1 = true;
 449     } else if (!UNICODE::is_latin1(from_char)) {
 450       // We are replacing an UTF16 char. Scan string to
 451       // check if result can be latin1 encoded.
 452       to_is_latin1 = true;
 453       for (index = 0; index &lt; length; index++) {
 454         jchar c = value-&gt;char_at(index);
 455         if (c != from_char &amp;&amp; !UNICODE::is_latin1(c)) {
 456           to_is_latin1 = false;
 457           break;
 458         }
 459       }
 460     }
 461   }
 462 
 463   // Create new UNICODE (or byte) buffer. Must handlize value because GC
 464   // may happen during String and char array creation.
 465   typeArrayHandle h_value(THREAD, value);
 466   Handle string = basic_create(length, to_is_latin1, CHECK_NH);
 467   typeArrayOop from_buffer = h_value();
 468   typeArrayOop to_buffer = java_lang_String::value(string());
 469 
 470   // Copy contents
 471   for (index = 0; index &lt; length; index++) {
 472     jchar c = (!is_latin1) ? from_buffer-&gt;char_at(index) :
 473                     ((jchar) from_buffer-&gt;byte_at(index)) &amp; 0xff;
 474     if (c == from_char) {
 475       c = to_char;
 476     }
 477     if (!to_is_latin1) {
 478       to_buffer-&gt;char_at_put(index, c);
 479     } else {
 480       to_buffer-&gt;byte_at_put(index, (jbyte) c);
 481     }
 482   }
 483   return string;
 484 }
 485 
 486 jchar* java_lang_String::as_unicode_string(oop java_string, int&amp; length, TRAPS) {
 487   typeArrayOop value  = java_lang_String::value(java_string);
 488                length = java_lang_String::length(java_string, value);
 489   bool      is_latin1 = java_lang_String::is_latin1(java_string);
 490 
 491   jchar* result = NEW_RESOURCE_ARRAY_RETURN_NULL(jchar, length);
 492   if (result != NULL) {
 493     if (!is_latin1) {
 494       for (int index = 0; index &lt; length; index++) {
 495         result[index] = value-&gt;char_at(index);
 496       }
 497     } else {
 498       for (int index = 0; index &lt; length; index++) {
 499         result[index] = ((jchar) value-&gt;byte_at(index)) &amp; 0xff;
 500       }
 501     }
 502   } else {
 503     THROW_MSG_0(vmSymbols::java_lang_OutOfMemoryError(), &quot;could not allocate Unicode string&quot;);
 504   }
 505   return result;
 506 }
 507 
 508 unsigned int java_lang_String::hash_code(oop java_string) {
<a name="18" id="anc18"></a><span class="line-modified"> 509   typeArrayOop value  = java_lang_String::value(java_string);</span>
<span class="line-modified"> 510   int          length = java_lang_String::length(java_string, value);</span>
<span class="line-modified"> 511   // Zero length string will hash to zero with String.hashCode() function.</span>
<span class="line-modified"> 512   if (length == 0) return 0;</span>








 513 
<a name="19" id="anc19"></a><span class="line-modified"> 514   bool      is_latin1 = java_lang_String::is_latin1(java_string);</span>


 515 
<a name="20" id="anc20"></a><span class="line-modified"> 516   if (is_latin1) {</span>
<span class="line-modified"> 517     return java_lang_String::hash_code(value-&gt;byte_at_addr(0), length);</span>









 518   } else {
<a name="21" id="anc21"></a><span class="line-modified"> 519     return java_lang_String::hash_code(value-&gt;char_at_addr(0), length);</span>
 520   }
<a name="22" id="anc22"></a>
 521 }
 522 
 523 char* java_lang_String::as_quoted_ascii(oop java_string) {
 524   typeArrayOop value  = java_lang_String::value(java_string);
 525   int          length = java_lang_String::length(java_string, value);
 526   bool      is_latin1 = java_lang_String::is_latin1(java_string);
 527 
 528   if (length == 0) return NULL;
 529 
 530   char* result;
 531   int result_length;
 532   if (!is_latin1) {
 533     jchar* base = value-&gt;char_at_addr(0);
 534     result_length = UNICODE::quoted_ascii_length(base, length) + 1;
 535     result = NEW_RESOURCE_ARRAY(char, result_length);
 536     UNICODE::as_quoted_ascii(base, length, result, result_length);
 537   } else {
 538     jbyte* base = value-&gt;byte_at_addr(0);
 539     result_length = UNICODE::quoted_ascii_length(base, length) + 1;
 540     result = NEW_RESOURCE_ARRAY(char, result_length);
 541     UNICODE::as_quoted_ascii(base, length, result, result_length);
 542   }
 543   assert(result_length &gt;= length + 1, &quot;must not be shorter&quot;);
 544   assert(result_length == (int)strlen(result) + 1, &quot;must match&quot;);
 545   return result;
 546 }
 547 
<a name="23" id="anc23"></a><span class="line-modified"> 548 Symbol* java_lang_String::as_symbol(oop java_string, TRAPS) {</span>
 549   typeArrayOop value  = java_lang_String::value(java_string);
 550   int          length = java_lang_String::length(java_string, value);
 551   bool      is_latin1 = java_lang_String::is_latin1(java_string);
 552   if (!is_latin1) {
 553     jchar* base = (length == 0) ? NULL : value-&gt;char_at_addr(0);
<a name="24" id="anc24"></a><span class="line-modified"> 554     Symbol* sym = SymbolTable::lookup_unicode(base, length, THREAD);</span>
 555     return sym;
 556   } else {
 557     ResourceMark rm;
 558     jbyte* position = (length == 0) ? NULL : value-&gt;byte_at_addr(0);
 559     const char* base = UNICODE::as_utf8(position, length);
<a name="25" id="anc25"></a><span class="line-modified"> 560     Symbol* sym = SymbolTable::lookup(base, length, THREAD);</span>
 561     return sym;
 562   }
 563 }
 564 
 565 Symbol* java_lang_String::as_symbol_or_null(oop java_string) {
 566   typeArrayOop value  = java_lang_String::value(java_string);
 567   int          length = java_lang_String::length(java_string, value);
 568   bool      is_latin1 = java_lang_String::is_latin1(java_string);
 569   if (!is_latin1) {
 570     jchar* base = (length == 0) ? NULL : value-&gt;char_at_addr(0);
 571     return SymbolTable::probe_unicode(base, length);
 572   } else {
 573     ResourceMark rm;
 574     jbyte* position = (length == 0) ? NULL : value-&gt;byte_at_addr(0);
 575     const char* base = UNICODE::as_utf8(position, length);
 576     return SymbolTable::probe(base, length);
 577   }
 578 }
 579 
 580 int java_lang_String::utf8_length(oop java_string, typeArrayOop value) {
 581   assert(value_equals(value, java_lang_String::value(java_string)),
 582          &quot;value must be same as java_lang_String::value(java_string)&quot;);
 583   int length = java_lang_String::length(java_string, value);
 584   if (length == 0) {
 585     return 0;
 586   }
 587   if (!java_lang_String::is_latin1(java_string)) {
 588     return UNICODE::utf8_length(value-&gt;char_at_addr(0), length);
 589   } else {
 590     return UNICODE::utf8_length(value-&gt;byte_at_addr(0), length);
 591   }
 592 }
 593 
 594 int java_lang_String::utf8_length(oop java_string) {
 595   typeArrayOop value = java_lang_String::value(java_string);
 596   return utf8_length(java_string, value);
 597 }
 598 
 599 char* java_lang_String::as_utf8_string(oop java_string) {
 600   typeArrayOop value  = java_lang_String::value(java_string);
 601   int          length = java_lang_String::length(java_string, value);
 602   bool      is_latin1 = java_lang_String::is_latin1(java_string);
 603   if (!is_latin1) {
 604     jchar* position = (length == 0) ? NULL : value-&gt;char_at_addr(0);
 605     return UNICODE::as_utf8(position, length);
 606   } else {
 607     jbyte* position = (length == 0) ? NULL : value-&gt;byte_at_addr(0);
 608     return UNICODE::as_utf8(position, length);
 609   }
 610 }
 611 
 612 char* java_lang_String::as_utf8_string(oop java_string, typeArrayOop value, char* buf, int buflen) {
 613   assert(value_equals(value, java_lang_String::value(java_string)),
 614          &quot;value must be same as java_lang_String::value(java_string)&quot;);
 615   int     length = java_lang_String::length(java_string, value);
 616   bool is_latin1 = java_lang_String::is_latin1(java_string);
 617   if (!is_latin1) {
 618     jchar* position = (length == 0) ? NULL : value-&gt;char_at_addr(0);
 619     return UNICODE::as_utf8(position, length, buf, buflen);
 620   } else {
 621     jbyte* position = (length == 0) ? NULL : value-&gt;byte_at_addr(0);
 622     return UNICODE::as_utf8(position, length, buf, buflen);
 623   }
 624 }
 625 
 626 char* java_lang_String::as_utf8_string(oop java_string, char* buf, int buflen) {
 627   typeArrayOop value = java_lang_String::value(java_string);
 628   return as_utf8_string(java_string, value, buf, buflen);
 629 }
 630 
 631 char* java_lang_String::as_utf8_string(oop java_string, int start, int len) {
 632   typeArrayOop value  = java_lang_String::value(java_string);
 633   bool      is_latin1 = java_lang_String::is_latin1(java_string);
 634   assert(start + len &lt;= java_lang_String::length(java_string), &quot;just checking&quot;);
 635   if (!is_latin1) {
 636     jchar* position = value-&gt;char_at_addr(start);
 637     return UNICODE::as_utf8(position, len);
 638   } else {
 639     jbyte* position = value-&gt;byte_at_addr(start);
 640     return UNICODE::as_utf8(position, len);
 641   }
 642 }
 643 
 644 char* java_lang_String::as_utf8_string(oop java_string, typeArrayOop value, int start, int len, char* buf, int buflen) {
 645   assert(value_equals(value, java_lang_String::value(java_string)),
 646          &quot;value must be same as java_lang_String::value(java_string)&quot;);
 647   assert(start + len &lt;= java_lang_String::length(java_string), &quot;just checking&quot;);
 648   bool is_latin1 = java_lang_String::is_latin1(java_string);
 649   if (!is_latin1) {
 650     jchar* position = value-&gt;char_at_addr(start);
 651     return UNICODE::as_utf8(position, len, buf, buflen);
 652   } else {
 653     jbyte* position = value-&gt;byte_at_addr(start);
 654     return UNICODE::as_utf8(position, len, buf, buflen);
 655   }
 656 }
 657 
 658 bool java_lang_String::equals(oop java_string, const jchar* chars, int len) {
 659   assert(java_string-&gt;klass() == SystemDictionary::String_klass(),
 660          &quot;must be java_string&quot;);
 661   typeArrayOop value = java_lang_String::value_no_keepalive(java_string);
 662   int length = java_lang_String::length(java_string, value);
 663   if (length != len) {
 664     return false;
 665   }
 666   bool is_latin1 = java_lang_String::is_latin1(java_string);
 667   if (!is_latin1) {
 668     for (int i = 0; i &lt; len; i++) {
 669       if (value-&gt;char_at(i) != chars[i]) {
 670         return false;
 671       }
 672     }
 673   } else {
 674     for (int i = 0; i &lt; len; i++) {
 675       if ((((jchar) value-&gt;byte_at(i)) &amp; 0xff) != chars[i]) {
 676         return false;
 677       }
 678     }
 679   }
 680   return true;
 681 }
 682 
 683 bool java_lang_String::equals(oop str1, oop str2) {
 684   assert(str1-&gt;klass() == SystemDictionary::String_klass(),
 685          &quot;must be java String&quot;);
 686   assert(str2-&gt;klass() == SystemDictionary::String_klass(),
 687          &quot;must be java String&quot;);
 688   typeArrayOop value1    = java_lang_String::value_no_keepalive(str1);
 689   bool         is_latin1 = java_lang_String::is_latin1(str1);
 690   typeArrayOop value2    = java_lang_String::value_no_keepalive(str2);
 691   bool         is_latin2 = java_lang_String::is_latin1(str2);
 692 
 693   if (is_latin1 != is_latin2) {
 694     // Strings with different coders are never equal.
 695     return false;
 696   }
 697   return value_equals(value1, value2);
 698 }
 699 
 700 void java_lang_String::print(oop java_string, outputStream* st) {
 701   assert(java_string-&gt;klass() == SystemDictionary::String_klass(), &quot;must be java_string&quot;);
 702   typeArrayOop value  = java_lang_String::value_no_keepalive(java_string);
 703 
 704   if (value == NULL) {
 705     // This can happen if, e.g., printing a String
 706     // object before its initializer has been called
 707     st-&gt;print(&quot;NULL&quot;);
 708     return;
 709   }
 710 
 711   int length = java_lang_String::length(java_string, value);
 712   bool is_latin1 = java_lang_String::is_latin1(java_string);
 713 
 714   st-&gt;print(&quot;\&quot;&quot;);
 715   for (int index = 0; index &lt; length; index++) {
 716     st-&gt;print(&quot;%c&quot;, (!is_latin1) ?  value-&gt;char_at(index) :
 717                            ((jchar) value-&gt;byte_at(index)) &amp; 0xff );
 718   }
 719   st-&gt;print(&quot;\&quot;&quot;);
 720 }
 721 
 722 
 723 static void initialize_static_field(fieldDescriptor* fd, Handle mirror, TRAPS) {
 724   assert(mirror.not_null() &amp;&amp; fd-&gt;is_static(), &quot;just checking&quot;);
 725   if (fd-&gt;has_initial_value()) {
 726     BasicType t = fd-&gt;field_type();
 727     switch (t) {
 728       case T_BYTE:
 729         mirror()-&gt;byte_field_put(fd-&gt;offset(), fd-&gt;int_initial_value());
 730               break;
 731       case T_BOOLEAN:
 732         mirror()-&gt;bool_field_put(fd-&gt;offset(), fd-&gt;int_initial_value());
 733               break;
 734       case T_CHAR:
 735         mirror()-&gt;char_field_put(fd-&gt;offset(), fd-&gt;int_initial_value());
 736               break;
 737       case T_SHORT:
 738         mirror()-&gt;short_field_put(fd-&gt;offset(), fd-&gt;int_initial_value());
 739               break;
 740       case T_INT:
 741         mirror()-&gt;int_field_put(fd-&gt;offset(), fd-&gt;int_initial_value());
 742         break;
 743       case T_FLOAT:
 744         mirror()-&gt;float_field_put(fd-&gt;offset(), fd-&gt;float_initial_value());
 745         break;
 746       case T_DOUBLE:
 747         mirror()-&gt;double_field_put(fd-&gt;offset(), fd-&gt;double_initial_value());
 748         break;
 749       case T_LONG:
 750         mirror()-&gt;long_field_put(fd-&gt;offset(), fd-&gt;long_initial_value());
 751         break;
 752       case T_OBJECT:
 753         {
 754           assert(fd-&gt;signature() == vmSymbols::string_signature(),
 755                  &quot;just checking&quot;);
 756           if (DumpSharedSpaces &amp;&amp; HeapShared::is_archived_object(mirror())) {
 757             // Archive the String field and update the pointer.
 758             oop s = mirror()-&gt;obj_field(fd-&gt;offset());
 759             oop archived_s = StringTable::create_archived_string(s, CHECK);
 760             mirror()-&gt;obj_field_put(fd-&gt;offset(), archived_s);
 761           } else {
 762             oop string = fd-&gt;string_initial_value(CHECK);
 763             mirror()-&gt;obj_field_put(fd-&gt;offset(), string);
 764           }
 765         }
 766         break;
 767       default:
 768         THROW_MSG(vmSymbols::java_lang_ClassFormatError(),
 769                   &quot;Illegal ConstantValue attribute in class file&quot;);
 770     }
 771   }
 772 }
 773 
 774 
 775 void java_lang_Class::fixup_mirror(Klass* k, TRAPS) {
 776   assert(InstanceMirrorKlass::offset_of_static_fields() != 0, &quot;must have been computed already&quot;);
 777 
 778   // If the offset was read from the shared archive, it was fixed up already
 779   if (!k-&gt;is_shared()) {
 780     if (k-&gt;is_instance_klass()) {
 781       // During bootstrap, java.lang.Class wasn&#39;t loaded so static field
 782       // offsets were computed without the size added it.  Go back and
 783       // update all the static field offsets to included the size.
 784       for (JavaFieldStream fs(InstanceKlass::cast(k)); !fs.done(); fs.next()) {
 785         if (fs.access_flags().is_static()) {
 786           int real_offset = fs.offset() + InstanceMirrorKlass::offset_of_static_fields();
 787           fs.set_offset(real_offset);
 788         }
 789       }
 790     }
 791   }
 792 
 793   if (k-&gt;is_shared() &amp;&amp; k-&gt;has_raw_archived_mirror()) {
 794     if (HeapShared::open_archive_heap_region_mapped()) {
 795       bool present = restore_archived_mirror(k, Handle(), Handle(), Handle(), CHECK);
 796       assert(present, &quot;Missing archived mirror for %s&quot;, k-&gt;external_name());
 797       return;
 798     } else {
 799       k-&gt;set_java_mirror_handle(NULL);
 800       k-&gt;clear_has_raw_archived_mirror();
 801     }
 802   }
 803   create_mirror(k, Handle(), Handle(), Handle(), CHECK);
 804 }
 805 
 806 void java_lang_Class::initialize_mirror_fields(Klass* k,
 807                                                Handle mirror,
 808                                                Handle protection_domain,
 809                                                TRAPS) {
 810   // Allocate a simple java object for a lock.
 811   // This needs to be a java object because during class initialization
 812   // it can be held across a java call.
 813   typeArrayOop r = oopFactory::new_typeArray(T_INT, 0, CHECK);
 814   set_init_lock(mirror(), r);
 815 
 816   // Set protection domain also
 817   set_protection_domain(mirror(), protection_domain());
 818 
 819   // Initialize static fields
 820   InstanceKlass::cast(k)-&gt;do_local_static_fields(&amp;initialize_static_field, mirror, CHECK);
 821 }
 822 
 823 // Set the java.lang.Module module field in the java_lang_Class mirror
 824 void java_lang_Class::set_mirror_module_field(Klass* k, Handle mirror, Handle module, TRAPS) {
 825   if (module.is_null()) {
 826     // During startup, the module may be NULL only if java.base has not been defined yet.
 827     // Put the class on the fixup_module_list to patch later when the java.lang.Module
 828     // for java.base is known. But note that since we captured the NULL module another
 829     // thread may have completed that initialization.
 830 
 831     bool javabase_was_defined = false;
 832     {
<a name="26" id="anc26"></a><span class="line-modified"> 833       MutexLocker m1(Module_lock, THREAD);</span>
 834       // Keep list of classes needing java.base module fixup
 835       if (!ModuleEntryTable::javabase_defined()) {
 836         assert(k-&gt;java_mirror() != NULL, &quot;Class&#39;s mirror is null&quot;);
 837         k-&gt;class_loader_data()-&gt;inc_keep_alive();
 838         assert(fixup_module_field_list() != NULL, &quot;fixup_module_field_list not initialized&quot;);
 839         fixup_module_field_list()-&gt;push(k);
 840       } else {
 841         javabase_was_defined = true;
 842       }
 843     }
 844 
 845     // If java.base was already defined then patch this particular class with java.base.
 846     if (javabase_was_defined) {
 847       ModuleEntry *javabase_entry = ModuleEntryTable::javabase_moduleEntry();
 848       assert(javabase_entry != NULL &amp;&amp; javabase_entry-&gt;module() != NULL,
 849              &quot;Setting class module field, &quot; JAVA_BASE_NAME &quot; should be defined&quot;);
 850       Handle javabase_handle(THREAD, javabase_entry-&gt;module());
 851       set_module(mirror(), javabase_handle());
 852     }
 853   } else {
 854     assert(Universe::is_module_initialized() ||
 855            (ModuleEntryTable::javabase_defined() &amp;&amp;
<a name="27" id="anc27"></a><span class="line-modified"> 856             (oopDesc::equals(module(), ModuleEntryTable::javabase_moduleEntry()-&gt;module()))),</span>
 857            &quot;Incorrect java.lang.Module specification while creating mirror&quot;);
 858     set_module(mirror(), module());
 859   }
 860 }
 861 
 862 // Statically allocate fixup lists because they always get created.
 863 void java_lang_Class::allocate_fixup_lists() {
 864   GrowableArray&lt;Klass*&gt;* mirror_list =
 865     new (ResourceObj::C_HEAP, mtClass) GrowableArray&lt;Klass*&gt;(40, true);
 866   set_fixup_mirror_list(mirror_list);
 867 
 868   GrowableArray&lt;Klass*&gt;* module_list =
 869     new (ResourceObj::C_HEAP, mtModule) GrowableArray&lt;Klass*&gt;(500, true);
 870   set_fixup_module_field_list(module_list);
 871 }
 872 
 873 void java_lang_Class::create_mirror(Klass* k, Handle class_loader,
 874                                     Handle module, Handle protection_domain, TRAPS) {
 875   assert(k != NULL, &quot;Use create_basic_type_mirror for primitive types&quot;);
 876   assert(k-&gt;java_mirror() == NULL, &quot;should only assign mirror once&quot;);
 877 
 878   // Use this moment of initialization to cache modifier_flags also,
 879   // to support Class.getModifiers().  Instance classes recalculate
 880   // the cached flags after the class file is parsed, but before the
 881   // class is put into the system dictionary.
 882   int computed_modifiers = k-&gt;compute_modifier_flags(CHECK);
 883   k-&gt;set_modifier_flags(computed_modifiers);
 884   // Class_klass has to be loaded because it is used to allocate
 885   // the mirror.
 886   if (SystemDictionary::Class_klass_loaded()) {
 887     // Allocate mirror (java.lang.Class instance)
 888     oop mirror_oop = InstanceMirrorKlass::cast(SystemDictionary::Class_klass())-&gt;allocate_instance(k, CHECK);
 889     Handle mirror(THREAD, mirror_oop);
 890     Handle comp_mirror;
 891 
 892     // Setup indirection from mirror-&gt;klass
 893     java_lang_Class::set_klass(mirror(), k);
 894 
 895     InstanceMirrorKlass* mk = InstanceMirrorKlass::cast(mirror-&gt;klass());
 896     assert(oop_size(mirror()) == mk-&gt;instance_size(k), &quot;should have been set&quot;);
 897 
 898     java_lang_Class::set_static_oop_field_count(mirror(), mk-&gt;compute_static_oop_field_count(mirror()));
 899 
 900     // It might also have a component mirror.  This mirror must already exist.
 901     if (k-&gt;is_array_klass()) {
 902       if (k-&gt;is_typeArray_klass()) {
 903         BasicType type = TypeArrayKlass::cast(k)-&gt;element_type();
 904         comp_mirror = Handle(THREAD, Universe::java_mirror(type));
 905       } else {
 906         assert(k-&gt;is_objArray_klass(), &quot;Must be&quot;);
 907         Klass* element_klass = ObjArrayKlass::cast(k)-&gt;element_klass();
 908         assert(element_klass != NULL, &quot;Must have an element klass&quot;);
 909         comp_mirror = Handle(THREAD, element_klass-&gt;java_mirror());
 910       }
 911       assert(comp_mirror() != NULL, &quot;must have a mirror&quot;);
 912 
 913       // Two-way link between the array klass and its component mirror:
 914       // (array_klass) k -&gt; mirror -&gt; component_mirror -&gt; array_klass -&gt; k
 915       set_component_mirror(mirror(), comp_mirror());
 916       // See below for ordering dependencies between field array_klass in component mirror
 917       // and java_mirror in this klass.
 918     } else {
 919       assert(k-&gt;is_instance_klass(), &quot;Must be&quot;);
 920 
 921       initialize_mirror_fields(k, mirror, protection_domain, THREAD);
 922       if (HAS_PENDING_EXCEPTION) {
 923         // If any of the fields throws an exception like OOM remove the klass field
 924         // from the mirror so GC doesn&#39;t follow it after the klass has been deallocated.
 925         // This mirror looks like a primitive type, which logically it is because it
 926         // it represents no class.
 927         java_lang_Class::set_klass(mirror(), NULL);
 928         return;
 929       }
 930     }
 931 
 932     // set the classLoader field in the java_lang_Class instance
<a name="28" id="anc28"></a><span class="line-modified"> 933     assert(oopDesc::equals(class_loader(), k-&gt;class_loader()), &quot;should be same&quot;);</span>
 934     set_class_loader(mirror(), class_loader());
 935 
 936     // Setup indirection from klass-&gt;mirror
 937     // after any exceptions can happen during allocations.
 938     k-&gt;set_java_mirror(mirror);
 939 
 940     // Set the module field in the java_lang_Class instance.  This must be done
 941     // after the mirror is set.
 942     set_mirror_module_field(k, mirror, module, THREAD);
 943 
 944     if (comp_mirror() != NULL) {
 945       // Set after k-&gt;java_mirror() is published, because compiled code running
 946       // concurrently doesn&#39;t expect a k to have a null java_mirror.
 947       release_set_array_klass(comp_mirror(), k);
 948     }
 949   } else {
 950     assert(fixup_mirror_list() != NULL, &quot;fixup_mirror_list not initialized&quot;);
 951     fixup_mirror_list()-&gt;push(k);
 952   }
 953 }
 954 
 955 #if INCLUDE_CDS_JAVA_HEAP
 956 // Clears mirror fields. Static final fields with initial values are reloaded
 957 // from constant pool. The object identity hash is in the object header and is
 958 // not affected.
 959 class ResetMirrorField: public FieldClosure {
 960  private:
 961   Handle _m;
 962 
 963  public:
 964   ResetMirrorField(Handle mirror) : _m(mirror) {}
 965 
 966   void do_field(fieldDescriptor* fd) {
 967     assert(DumpSharedSpaces, &quot;dump time only&quot;);
 968     assert(_m.not_null(), &quot;Mirror cannot be NULL&quot;);
 969 
 970     if (fd-&gt;is_static() &amp;&amp; fd-&gt;has_initial_value()) {
 971       initialize_static_field(fd, _m, Thread::current());
 972       return;
 973     }
 974 
 975     BasicType ft = fd-&gt;field_type();
 976     switch (ft) {
 977       case T_BYTE:
 978         _m()-&gt;byte_field_put(fd-&gt;offset(), 0);
 979         break;
 980       case T_CHAR:
 981         _m()-&gt;char_field_put(fd-&gt;offset(), 0);
 982         break;
 983       case T_DOUBLE:
 984         _m()-&gt;double_field_put(fd-&gt;offset(), 0);
 985         break;
 986       case T_FLOAT:
 987         _m()-&gt;float_field_put(fd-&gt;offset(), 0);
 988         break;
 989       case T_INT:
 990         _m()-&gt;int_field_put(fd-&gt;offset(), 0);
 991         break;
 992       case T_LONG:
 993         _m()-&gt;long_field_put(fd-&gt;offset(), 0);
 994         break;
 995       case T_SHORT:
 996         _m()-&gt;short_field_put(fd-&gt;offset(), 0);
 997         break;
 998       case T_BOOLEAN:
 999         _m()-&gt;bool_field_put(fd-&gt;offset(), false);
1000         break;
1001       case T_ARRAY:
1002       case T_OBJECT: {
1003         // It might be useful to cache the String field, but
1004         // for now just clear out any reference field
1005         oop o = _m()-&gt;obj_field(fd-&gt;offset());
1006         _m()-&gt;obj_field_put(fd-&gt;offset(), NULL);
1007         break;
1008       }
1009       default:
1010         ShouldNotReachHere();
1011         break;
1012      }
1013   }
1014 };
1015 
1016 void java_lang_Class::archive_basic_type_mirrors(TRAPS) {
1017   assert(HeapShared::is_heap_object_archiving_allowed(),
1018          &quot;HeapShared::is_heap_object_archiving_allowed() must be true&quot;);
1019 
1020   for (int t = 0; t &lt;= T_VOID; t++) {
1021     oop m = Universe::_mirrors[t];
1022     if (m != NULL) {
1023       // Update the field at _array_klass_offset to point to the relocated array klass.
1024       oop archived_m = HeapShared::archive_heap_object(m, THREAD);
1025       assert(archived_m != NULL, &quot;sanity&quot;);
1026       Klass *ak = (Klass*)(archived_m-&gt;metadata_field(_array_klass_offset));
1027       assert(ak != NULL || t == T_VOID, &quot;should not be NULL&quot;);
1028       if (ak != NULL) {
<a name="29" id="anc29"></a><span class="line-modified">1029         Klass *reloc_ak = MetaspaceShared::get_relocated_klass(ak);</span>
1030         archived_m-&gt;metadata_field_put(_array_klass_offset, reloc_ak);
1031       }
1032 
1033       // Clear the fields. Just to be safe
1034       Klass *k = m-&gt;klass();
1035       Handle archived_mirror_h(THREAD, archived_m);
1036       ResetMirrorField reset(archived_mirror_h);
1037       InstanceKlass::cast(k)-&gt;do_nonstatic_fields(&amp;reset);
1038 
1039       log_trace(cds, heap, mirror)(
1040         &quot;Archived %s mirror object from &quot; PTR_FORMAT &quot; ==&gt; &quot; PTR_FORMAT,
1041         type2name((BasicType)t), p2i(Universe::_mirrors[t]), p2i(archived_m));
1042 
1043       Universe::_mirrors[t] = archived_m;
1044     }
1045   }
1046 
1047   assert(Universe::_mirrors[T_INT] != NULL &amp;&amp;
1048          Universe::_mirrors[T_FLOAT] != NULL &amp;&amp;
1049          Universe::_mirrors[T_DOUBLE] != NULL &amp;&amp;
1050          Universe::_mirrors[T_BYTE] != NULL &amp;&amp;
1051          Universe::_mirrors[T_BOOLEAN] != NULL &amp;&amp;
1052          Universe::_mirrors[T_CHAR] != NULL &amp;&amp;
1053          Universe::_mirrors[T_LONG] != NULL &amp;&amp;
1054          Universe::_mirrors[T_SHORT] != NULL &amp;&amp;
1055          Universe::_mirrors[T_VOID] != NULL, &quot;sanity&quot;);
1056 
1057   Universe::set_int_mirror(Universe::_mirrors[T_INT]);
1058   Universe::set_float_mirror(Universe::_mirrors[T_FLOAT]);
1059   Universe::set_double_mirror(Universe::_mirrors[T_DOUBLE]);
1060   Universe::set_byte_mirror(Universe::_mirrors[T_BYTE]);
1061   Universe::set_bool_mirror(Universe::_mirrors[T_BOOLEAN]);
1062   Universe::set_char_mirror(Universe::_mirrors[T_CHAR]);
1063   Universe::set_long_mirror(Universe::_mirrors[T_LONG]);
1064   Universe::set_short_mirror(Universe::_mirrors[T_SHORT]);
1065   Universe::set_void_mirror(Universe::_mirrors[T_VOID]);
1066 }
1067 
1068 //
1069 // After the mirror object is successfully archived, the archived
1070 // klass is set with _has_archived_raw_mirror flag.
1071 //
1072 // The _has_archived_raw_mirror flag is cleared at runtime when the
1073 // archived mirror is restored. If archived java heap data cannot
1074 // be used at runtime, new mirror object is created for the shared
1075 // class. The _has_archived_raw_mirror is cleared also during the process.
1076 oop java_lang_Class::archive_mirror(Klass* k, TRAPS) {
1077   assert(HeapShared::is_heap_object_archiving_allowed(),
1078          &quot;HeapShared::is_heap_object_archiving_allowed() must be true&quot;);
1079 
1080   // Mirror is already archived
1081   if (k-&gt;has_raw_archived_mirror()) {
1082     assert(k-&gt;archived_java_mirror_raw() != NULL, &quot;no archived mirror&quot;);
1083     return k-&gt;archived_java_mirror_raw();
1084   }
1085 
1086   // No mirror
1087   oop mirror = k-&gt;java_mirror();
1088   if (mirror == NULL) {
1089     return NULL;
1090   }
1091 
1092   if (k-&gt;is_instance_klass()) {
1093     InstanceKlass *ik = InstanceKlass::cast(k);
1094     assert(ik-&gt;signers() == NULL, &quot;class with signer should have been excluded&quot;);
1095 
1096     if (!(ik-&gt;is_shared_boot_class() || ik-&gt;is_shared_platform_class() ||
1097           ik-&gt;is_shared_app_class())) {
1098       // Archiving mirror for classes from non-builtin loaders is not
1099       // supported. Clear the _java_mirror within the archived class.
1100       k-&gt;set_java_mirror_handle(NULL);
1101       return NULL;
1102     }
1103   }
1104 
1105   // Now start archiving the mirror object
1106   oop archived_mirror = HeapShared::archive_heap_object(mirror, THREAD);
1107   if (archived_mirror == NULL) {
1108     return NULL;
1109   }
1110 
1111   archived_mirror = process_archived_mirror(k, mirror, archived_mirror, THREAD);
1112   if (archived_mirror == NULL) {
1113     return NULL;
1114   }
1115 
1116   k-&gt;set_archived_java_mirror_raw(archived_mirror);
1117 
1118   k-&gt;set_has_raw_archived_mirror();
1119 
1120   ResourceMark rm;
1121   log_trace(cds, heap, mirror)(
1122     &quot;Archived %s mirror object from &quot; PTR_FORMAT &quot; ==&gt; &quot; PTR_FORMAT,
1123     k-&gt;external_name(), p2i(mirror), p2i(archived_mirror));
1124 
1125   return archived_mirror;
1126 }
1127 
1128 // The process is based on create_mirror().
1129 oop java_lang_Class::process_archived_mirror(Klass* k, oop mirror,
1130                                              oop archived_mirror,
1131                                              Thread *THREAD) {
1132   // Clear nonstatic fields in archived mirror. Some of the fields will be set
1133   // to archived metadata and objects below.
1134   Klass *c = archived_mirror-&gt;klass();
1135   Handle archived_mirror_h(THREAD, archived_mirror);
1136   ResetMirrorField reset(archived_mirror_h);
1137   InstanceKlass::cast(c)-&gt;do_nonstatic_fields(&amp;reset);
1138 
1139   if (k-&gt;is_array_klass()) {
1140     oop archived_comp_mirror;
1141     if (k-&gt;is_typeArray_klass()) {
1142       // The primitive type mirrors are already archived. Get the archived mirror.
1143       oop comp_mirror = java_lang_Class::component_mirror(mirror);
1144       archived_comp_mirror = HeapShared::find_archived_heap_object(comp_mirror);
1145       assert(archived_comp_mirror != NULL, &quot;Must be&quot;);
1146     } else {
1147       assert(k-&gt;is_objArray_klass(), &quot;Must be&quot;);
1148       Klass* element_klass = ObjArrayKlass::cast(k)-&gt;element_klass();
1149       assert(element_klass != NULL, &quot;Must have an element klass&quot;);
1150       archived_comp_mirror = archive_mirror(element_klass, THREAD);
1151       if (archived_comp_mirror == NULL) {
1152         return NULL;
1153       }
1154     }
1155     java_lang_Class::set_component_mirror(archived_mirror, archived_comp_mirror);
1156   } else {
1157     assert(k-&gt;is_instance_klass(), &quot;Must be&quot;);
1158 
1159     // Reset local static fields in the mirror
1160     InstanceKlass::cast(k)-&gt;do_local_static_fields(&amp;reset);
1161 
1162     java_lang_Class:set_init_lock(archived_mirror, NULL);
1163 
1164     set_protection_domain(archived_mirror, NULL);
1165   }
1166 
1167   // clear class loader and mirror_module_field
1168   set_class_loader(archived_mirror, NULL);
1169   set_module(archived_mirror, NULL);
1170 
1171   // The archived mirror&#39;s field at _klass_offset is still pointing to the original
1172   // klass. Updated the field in the archived mirror to point to the relocated
1173   // klass in the archive.
<a name="30" id="anc30"></a><span class="line-modified">1174   Klass *reloc_k = MetaspaceShared::get_relocated_klass(as_Klass(mirror));</span>
1175   log_debug(cds, heap, mirror)(
1176     &quot;Relocate mirror metadata field at _klass_offset from &quot; PTR_FORMAT &quot; ==&gt; &quot; PTR_FORMAT,
1177     p2i(as_Klass(mirror)), p2i(reloc_k));
1178   archived_mirror-&gt;metadata_field_put(_klass_offset, reloc_k);
1179 
1180   // The field at _array_klass_offset is pointing to the original one dimension
1181   // higher array klass if exists. Relocate the pointer.
1182   Klass *arr = array_klass_acquire(mirror);
1183   if (arr != NULL) {
<a name="31" id="anc31"></a><span class="line-modified">1184     Klass *reloc_arr = MetaspaceShared::get_relocated_klass(arr);</span>
1185     log_debug(cds, heap, mirror)(
1186       &quot;Relocate mirror metadata field at _array_klass_offset from &quot; PTR_FORMAT &quot; ==&gt; &quot; PTR_FORMAT,
1187       p2i(arr), p2i(reloc_arr));
1188     archived_mirror-&gt;metadata_field_put(_array_klass_offset, reloc_arr);
1189   }
1190   return archived_mirror;
1191 }
1192 
<a name="32" id="anc32"></a>


























1193 // Returns true if the mirror is updated, false if no archived mirror
1194 // data is present. After the archived mirror object is restored, the
1195 // shared klass&#39; _has_raw_archived_mirror flag is cleared.
1196 bool java_lang_Class::restore_archived_mirror(Klass *k,
1197                                               Handle class_loader, Handle module,
1198                                               Handle protection_domain, TRAPS) {
1199   // Postpone restoring archived mirror until java.lang.Class is loaded. Please
1200   // see more details in SystemDictionary::resolve_well_known_classes().
1201   if (!SystemDictionary::Class_klass_loaded()) {
1202     assert(fixup_mirror_list() != NULL, &quot;fixup_mirror_list not initialized&quot;);
1203     fixup_mirror_list()-&gt;push(k);
1204     return true;
1205   }
1206 
1207   oop m = HeapShared::materialize_archived_object(k-&gt;archived_java_mirror_raw_narrow());
<a name="33" id="anc33"></a><span class="line-removed">1208 </span>
1209   if (m == NULL) {
1210     return false;
1211   }
1212 
<a name="34" id="anc34"></a><span class="line-modified">1213   log_debug(cds, mirror)(&quot;Archived mirror is: &quot; PTR_FORMAT, p2i(m));</span>
<span class="line-removed">1214 </span>
1215   // mirror is archived, restore
1216   assert(HeapShared::is_archived_object(m), &quot;must be archived mirror object&quot;);
<a name="35" id="anc35"></a>

1217   Handle mirror(THREAD, m);
1218 
1219   if (!k-&gt;is_array_klass()) {
1220     // - local static final fields with initial values were initialized at dump time
1221 
1222     // create the init_lock
1223     typeArrayOop r = oopFactory::new_typeArray(T_INT, 0, CHECK_(false));
1224     set_init_lock(mirror(), r);
1225 
1226     if (protection_domain.not_null()) {
1227       set_protection_domain(mirror(), protection_domain());
1228     }
1229   }
1230 
1231   assert(class_loader() == k-&gt;class_loader(), &quot;should be same&quot;);
1232   if (class_loader.not_null()) {
1233     set_class_loader(mirror(), class_loader());
1234   }
1235 
1236   k-&gt;set_java_mirror(mirror);
1237   k-&gt;clear_has_raw_archived_mirror();
1238 
1239   set_mirror_module_field(k, mirror, module, THREAD);
1240 
<a name="36" id="anc36"></a><span class="line-modified">1241   ResourceMark rm;</span>
<span class="line-modified">1242   log_trace(cds, heap, mirror)(</span>
<span class="line-modified">1243     &quot;Restored %s archived mirror &quot; PTR_FORMAT, k-&gt;external_name(), p2i(mirror()));</span>


1244 
1245   return true;
1246 }
1247 #endif // INCLUDE_CDS_JAVA_HEAP
1248 
1249 void java_lang_Class::fixup_module_field(Klass* k, Handle module) {
1250   assert(_module_offset != 0, &quot;must have been computed already&quot;);
1251   java_lang_Class::set_module(k-&gt;java_mirror(), module());
1252 }
1253 
1254 int  java_lang_Class::oop_size(oop java_class) {
1255   assert(_oop_size_offset != 0, &quot;must be set&quot;);
1256   int size = java_class-&gt;int_field(_oop_size_offset);
1257   assert(size &gt; 0, &quot;Oop size must be greater than zero, not %d&quot;, size);
1258   return size;
1259 }
1260 
1261 
1262 void java_lang_Class::set_oop_size(HeapWord* java_class, int size) {
1263   assert(_oop_size_offset != 0, &quot;must be set&quot;);
1264   assert(size &gt; 0, &quot;Oop size must be greater than zero, not %d&quot;, size);
1265   *(int*)(((char*)java_class) + _oop_size_offset) = size;
1266 }
1267 
1268 int  java_lang_Class::static_oop_field_count(oop java_class) {
1269   assert(_static_oop_field_count_offset != 0, &quot;must be set&quot;);
1270   return java_class-&gt;int_field(_static_oop_field_count_offset);
1271 }
1272 
1273 int  java_lang_Class::static_oop_field_count_raw(oop java_class) {
1274   assert(_static_oop_field_count_offset != 0, &quot;must be set&quot;);
1275   return java_class-&gt;int_field_raw(_static_oop_field_count_offset);
1276 }
1277 
1278 void java_lang_Class::set_static_oop_field_count(oop java_class, int size) {
1279   assert(_static_oop_field_count_offset != 0, &quot;must be set&quot;);
1280   java_class-&gt;int_field_put(_static_oop_field_count_offset, size);
1281 }
1282 
1283 oop java_lang_Class::protection_domain(oop java_class) {
1284   assert(_protection_domain_offset != 0, &quot;must be set&quot;);
1285   return java_class-&gt;obj_field(_protection_domain_offset);
1286 }
1287 void java_lang_Class::set_protection_domain(oop java_class, oop pd) {
1288   assert(_protection_domain_offset != 0, &quot;must be set&quot;);
1289   java_class-&gt;obj_field_put(_protection_domain_offset, pd);
1290 }
1291 
1292 void java_lang_Class::set_component_mirror(oop java_class, oop comp_mirror) {
1293   assert(_component_mirror_offset != 0, &quot;must be set&quot;);
1294     java_class-&gt;obj_field_put(_component_mirror_offset, comp_mirror);
1295   }
1296 oop java_lang_Class::component_mirror(oop java_class) {
1297   assert(_component_mirror_offset != 0, &quot;must be set&quot;);
1298   return java_class-&gt;obj_field(_component_mirror_offset);
1299 }
1300 
1301 oop java_lang_Class::init_lock(oop java_class) {
1302   assert(_init_lock_offset != 0, &quot;must be set&quot;);
1303   return java_class-&gt;obj_field(_init_lock_offset);
1304 }
1305 
1306 #if INCLUDE_TSAN
1307 oop* java_lang_Class::init_lock_addr(oop java_class) {
1308   assert(_init_lock_offset != 0, &quot;must be set&quot;);
1309   return java_class-&gt;obj_field_addr_raw&lt;oop&gt;(_init_lock_offset);
1310 }
1311 #endif  // INCLUDE_TSAN
1312 
1313 void java_lang_Class::set_init_lock(oop java_class, oop init_lock) {
1314   assert(_init_lock_offset != 0, &quot;must be set&quot;);
1315   java_class-&gt;obj_field_put(_init_lock_offset, init_lock);
1316 }
1317 
1318 objArrayOop java_lang_Class::signers(oop java_class) {
1319   assert(_signers_offset != 0, &quot;must be set&quot;);
1320   return (objArrayOop)java_class-&gt;obj_field(_signers_offset);
1321 }
1322 void java_lang_Class::set_signers(oop java_class, objArrayOop signers) {
1323   assert(_signers_offset != 0, &quot;must be set&quot;);
1324   java_class-&gt;obj_field_put(_signers_offset, (oop)signers);
1325 }
1326 
1327 
1328 void java_lang_Class::set_class_loader(oop java_class, oop loader) {
<a name="37" id="anc37"></a><span class="line-modified">1329   // jdk7 runs Queens in bootstrapping and jdk8-9 has no coordinated pushes yet.</span>
<span class="line-modified">1330   if (_class_loader_offset != 0) {</span>
<span class="line-removed">1331     java_class-&gt;obj_field_put(_class_loader_offset, loader);</span>
<span class="line-removed">1332   }</span>
1333 }
1334 
1335 oop java_lang_Class::class_loader(oop java_class) {
1336   assert(_class_loader_offset != 0, &quot;must be set&quot;);
1337   return java_class-&gt;obj_field(_class_loader_offset);
1338 }
1339 
1340 oop java_lang_Class::module(oop java_class) {
1341   assert(_module_offset != 0, &quot;must be set&quot;);
1342   return java_class-&gt;obj_field(_module_offset);
1343 }
1344 
1345 void java_lang_Class::set_module(oop java_class, oop module) {
1346   assert(_module_offset != 0, &quot;must be set&quot;);
1347   java_class-&gt;obj_field_put(_module_offset, module);
1348 }
1349 
1350 oop java_lang_Class::name(Handle java_class, TRAPS) {
1351   assert(_name_offset != 0, &quot;must be set&quot;);
1352   oop o = java_class-&gt;obj_field(_name_offset);
1353   if (o == NULL) {
1354     o = StringTable::intern(java_lang_Class::as_external_name(java_class()), THREAD);
1355     java_class-&gt;obj_field_put(_name_offset, o);
1356   }
1357   return o;
1358 }
1359 
1360 oop java_lang_Class::source_file(oop java_class) {
1361   assert(_source_file_offset != 0, &quot;must be set&quot;);
1362   return java_class-&gt;obj_field(_source_file_offset);
1363 }
1364 
1365 void java_lang_Class::set_source_file(oop java_class, oop source_file) {
1366   assert(_source_file_offset != 0, &quot;must be set&quot;);
1367   java_class-&gt;obj_field_put(_source_file_offset, source_file);
1368 }
1369 
1370 oop java_lang_Class::create_basic_type_mirror(const char* basic_type_name, BasicType type, TRAPS) {
1371   // This should be improved by adding a field at the Java level or by
1372   // introducing a new VM klass (see comment in ClassFileParser)
1373   oop java_class = InstanceMirrorKlass::cast(SystemDictionary::Class_klass())-&gt;allocate_instance(NULL, CHECK_0);
1374   if (type != T_VOID) {
1375     Klass* aklass = Universe::typeArrayKlassObj(type);
1376     assert(aklass != NULL, &quot;correct bootstrap&quot;);
1377     release_set_array_klass(java_class, aklass);
1378   }
1379 #ifdef ASSERT
1380   InstanceMirrorKlass* mk = InstanceMirrorKlass::cast(SystemDictionary::Class_klass());
1381   assert(java_lang_Class::static_oop_field_count(java_class) == 0, &quot;should have been zeroed by allocation&quot;);
1382 #endif
1383   return java_class;
1384 }
1385 
1386 
1387 Klass* java_lang_Class::as_Klass(oop java_class) {
1388   //%note memory_2
1389   assert(java_lang_Class::is_instance(java_class), &quot;must be a Class object&quot;);
1390   Klass* k = ((Klass*)java_class-&gt;metadata_field(_klass_offset));
1391   assert(k == NULL || k-&gt;is_klass(), &quot;type check&quot;);
1392   return k;
1393 }
1394 
1395 Klass* java_lang_Class::as_Klass_raw(oop java_class) {
1396   //%note memory_2
1397   assert(java_lang_Class::is_instance(java_class), &quot;must be a Class object&quot;);
1398   Klass* k = ((Klass*)java_class-&gt;metadata_field_raw(_klass_offset));
1399   assert(k == NULL || k-&gt;is_klass(), &quot;type check&quot;);
1400   return k;
1401 }
1402 
1403 
1404 void java_lang_Class::set_klass(oop java_class, Klass* klass) {
1405   assert(java_lang_Class::is_instance(java_class), &quot;must be a Class object&quot;);
1406   java_class-&gt;metadata_field_put(_klass_offset, klass);
1407 }
1408 
1409 
1410 void java_lang_Class::print_signature(oop java_class, outputStream* st) {
1411   assert(java_lang_Class::is_instance(java_class), &quot;must be a Class object&quot;);
1412   Symbol* name = NULL;
1413   bool is_instance = false;
1414   if (is_primitive(java_class)) {
1415     name = vmSymbols::type_signature(primitive_type(java_class));
1416   } else {
1417     Klass* k = as_Klass(java_class);
1418     is_instance = k-&gt;is_instance_klass();
1419     name = k-&gt;name();
1420   }
1421   if (name == NULL) {
1422     st-&gt;print(&quot;&lt;null&gt;&quot;);
1423     return;
1424   }
1425   if (is_instance)  st-&gt;print(&quot;L&quot;);
1426   st-&gt;write((char*) name-&gt;base(), (int) name-&gt;utf8_length());
1427   if (is_instance)  st-&gt;print(&quot;;&quot;);
1428 }
1429 
<a name="38" id="anc38"></a><span class="line-modified">1430 Symbol* java_lang_Class::as_signature(oop java_class, bool intern_if_not_found, TRAPS) {</span>
1431   assert(java_lang_Class::is_instance(java_class), &quot;must be a Class object&quot;);
1432   Symbol* name;
1433   if (is_primitive(java_class)) {
1434     name = vmSymbols::type_signature(primitive_type(java_class));
1435     // Because this can create a new symbol, the caller has to decrement
1436     // the refcount, so make adjustment here and below for symbols returned
1437     // that are not created or incremented due to a successful lookup.
1438     name-&gt;increment_refcount();
1439   } else {
1440     Klass* k = as_Klass(java_class);
1441     if (!k-&gt;is_instance_klass()) {
1442       name = k-&gt;name();
1443       name-&gt;increment_refcount();
1444     } else {
1445       ResourceMark rm;
1446       const char* sigstr = k-&gt;signature_name();
1447       int         siglen = (int) strlen(sigstr);
1448       if (!intern_if_not_found) {
1449         name = SymbolTable::probe(sigstr, siglen);
1450       } else {
<a name="39" id="anc39"></a><span class="line-modified">1451         name = SymbolTable::new_symbol(sigstr, siglen, THREAD);</span>
1452       }
1453     }
1454   }
1455   return name;
1456 }
1457 
1458 // Returns the Java name for this Java mirror (Resource allocated)
1459 // See Klass::external_name().
1460 // For primitive type Java mirrors, its type name is returned.
1461 const char* java_lang_Class::as_external_name(oop java_class) {
1462   assert(java_lang_Class::is_instance(java_class), &quot;must be a Class object&quot;);
1463   const char* name = NULL;
1464   if (is_primitive(java_class)) {
1465     name = type2name(primitive_type(java_class));
1466   } else {
1467     name = as_Klass(java_class)-&gt;external_name();
1468   }
1469   if (name == NULL) {
1470     name = &quot;&lt;null&gt;&quot;;
1471   }
1472   return name;
1473 }
1474 
1475 Klass* java_lang_Class::array_klass_acquire(oop java_class) {
1476   Klass* k = ((Klass*)java_class-&gt;metadata_field_acquire(_array_klass_offset));
1477   assert(k == NULL || k-&gt;is_klass() &amp;&amp; k-&gt;is_array_klass(), &quot;should be array klass&quot;);
1478   return k;
1479 }
1480 
1481 
1482 void java_lang_Class::release_set_array_klass(oop java_class, Klass* klass) {
1483   assert(klass-&gt;is_klass() &amp;&amp; klass-&gt;is_array_klass(), &quot;should be array klass&quot;);
1484   java_class-&gt;release_metadata_field_put(_array_klass_offset, klass);
1485 }
1486 
1487 
1488 BasicType java_lang_Class::primitive_type(oop java_class) {
1489   assert(java_lang_Class::is_primitive(java_class), &quot;just checking&quot;);
1490   Klass* ak = ((Klass*)java_class-&gt;metadata_field(_array_klass_offset));
1491   BasicType type = T_VOID;
1492   if (ak != NULL) {
1493     // Note: create_basic_type_mirror above initializes ak to a non-null value.
1494     type = ArrayKlass::cast(ak)-&gt;element_type();
1495   } else {
<a name="40" id="anc40"></a><span class="line-modified">1496     assert(oopDesc::equals(java_class, Universe::void_mirror()), &quot;only valid non-array primitive&quot;);</span>
1497   }
<a name="41" id="anc41"></a><span class="line-modified">1498   assert(oopDesc::equals(Universe::java_mirror(type), java_class), &quot;must be consistent&quot;);</span>
1499   return type;
1500 }
1501 
1502 BasicType java_lang_Class::as_BasicType(oop java_class, Klass** reference_klass) {
1503   assert(java_lang_Class::is_instance(java_class), &quot;must be a Class object&quot;);
1504   if (is_primitive(java_class)) {
1505     if (reference_klass != NULL)
1506       (*reference_klass) = NULL;
1507     return primitive_type(java_class);
1508   } else {
1509     if (reference_klass != NULL)
1510       (*reference_klass) = as_Klass(java_class);
1511     return T_OBJECT;
1512   }
1513 }
1514 
1515 
1516 oop java_lang_Class::primitive_mirror(BasicType t) {
1517   oop mirror = Universe::java_mirror(t);
1518   assert(mirror != NULL &amp;&amp; mirror-&gt;is_a(SystemDictionary::Class_klass()), &quot;must be a Class&quot;);
1519   assert(java_lang_Class::is_primitive(mirror), &quot;must be primitive&quot;);
1520   return mirror;
1521 }
1522 
1523 bool java_lang_Class::offsets_computed = false;
1524 int  java_lang_Class::classRedefinedCount_offset = -1;
1525 
1526 #define CLASS_FIELDS_DO(macro) \
<a name="42" id="anc42"></a><span class="line-modified">1527   macro(classRedefinedCount_offset, k, &quot;classRedefinedCount&quot;, int_signature,         false) ; \</span>
1528   macro(_class_loader_offset,       k, &quot;classLoader&quot;,         classloader_signature, false); \
1529   macro(_component_mirror_offset,   k, &quot;componentType&quot;,       class_signature,       false); \
1530   macro(_module_offset,             k, &quot;module&quot;,              module_signature,      false); \
1531   macro(_name_offset,               k, &quot;name&quot;,                string_signature,      false); \
1532 
1533 void java_lang_Class::compute_offsets() {
1534   if (offsets_computed) {
1535     return;
1536   }
1537 
1538   offsets_computed = true;
1539 
1540   InstanceKlass* k = SystemDictionary::Class_klass();
1541   CLASS_FIELDS_DO(FIELD_COMPUTE_OFFSET);
1542 
1543   // Init lock is a C union with component_mirror.  Only instanceKlass mirrors have
1544   // init_lock and only ArrayKlass mirrors have component_mirror.  Since both are oops
1545   // GC treats them the same.
1546   _init_lock_offset = _component_mirror_offset;
1547 
1548   CLASS_INJECTED_FIELDS(INJECTED_FIELD_COMPUTE_OFFSET);
1549 }
1550 
1551 #if INCLUDE_CDS
1552 void java_lang_Class::serialize_offsets(SerializeClosure* f) {
<a name="43" id="anc43"></a><span class="line-modified">1553   f-&gt;do_u4((u4*)&amp;offsets_computed);</span>
1554   f-&gt;do_u4((u4*)&amp;_init_lock_offset);
1555 
1556   CLASS_FIELDS_DO(FIELD_SERIALIZE_OFFSET);
1557 
1558   CLASS_INJECTED_FIELDS(INJECTED_FIELD_SERIALIZE_OFFSET);
1559 }
1560 #endif
1561 
1562 int java_lang_Class::classRedefinedCount(oop the_class_mirror) {
<a name="44" id="anc44"></a><span class="line-modified">1563   if (classRedefinedCount_offset == -1) {</span>
<span class="line-removed">1564     // If we don&#39;t have an offset for it then just return -1 as a marker.</span>
<span class="line-removed">1565     return -1;</span>
<span class="line-removed">1566   }</span>
<span class="line-removed">1567 </span>
1568   return the_class_mirror-&gt;int_field(classRedefinedCount_offset);
1569 }
1570 
1571 void java_lang_Class::set_classRedefinedCount(oop the_class_mirror, int value) {
<a name="45" id="anc45"></a><span class="line-modified">1572   if (classRedefinedCount_offset == -1) {</span>
<span class="line-removed">1573     // If we don&#39;t have an offset for it then nothing to set.</span>
<span class="line-removed">1574     return;</span>
<span class="line-removed">1575   }</span>
<span class="line-removed">1576 </span>
1577   the_class_mirror-&gt;int_field_put(classRedefinedCount_offset, value);
1578 }
1579 
1580 
1581 // Note: JDK1.1 and before had a privateInfo_offset field which was used for the
1582 //       platform thread structure, and a eetop offset which was used for thread
1583 //       local storage (and unused by the HotSpot VM). In JDK1.2 the two structures
1584 //       merged, so in the HotSpot VM we just use the eetop field for the thread
1585 //       instead of the privateInfo_offset.
1586 //
1587 // Note: The stackSize field is only present starting in 1.4.
1588 
1589 int java_lang_Thread::_name_offset = 0;
1590 int java_lang_Thread::_group_offset = 0;
1591 int java_lang_Thread::_contextClassLoader_offset = 0;
1592 int java_lang_Thread::_inheritedAccessControlContext_offset = 0;
1593 int java_lang_Thread::_priority_offset = 0;
1594 int java_lang_Thread::_eetop_offset = 0;
<a name="46" id="anc46"></a>
1595 int java_lang_Thread::_daemon_offset = 0;
1596 int java_lang_Thread::_stillborn_offset = 0;
1597 int java_lang_Thread::_stackSize_offset = 0;
1598 int java_lang_Thread::_tid_offset = 0;
1599 int java_lang_Thread::_thread_status_offset = 0;
1600 int java_lang_Thread::_park_blocker_offset = 0;
<a name="47" id="anc47"></a><span class="line-removed">1601 int java_lang_Thread::_park_event_offset = 0 ;</span>
1602 
1603 #define THREAD_FIELDS_DO(macro) \
1604   macro(_name_offset,          k, vmSymbols::name_name(), string_signature, false); \
1605   macro(_group_offset,         k, vmSymbols::group_name(), threadgroup_signature, false); \
1606   macro(_contextClassLoader_offset, k, vmSymbols::contextClassLoader_name(), classloader_signature, false); \
1607   macro(_inheritedAccessControlContext_offset, k, vmSymbols::inheritedAccessControlContext_name(), accesscontrolcontext_signature, false); \
1608   macro(_priority_offset,      k, vmSymbols::priority_name(), int_signature, false); \
1609   macro(_daemon_offset,        k, vmSymbols::daemon_name(), bool_signature, false); \
1610   macro(_eetop_offset,         k, &quot;eetop&quot;, long_signature, false); \
<a name="48" id="anc48"></a>
1611   macro(_stillborn_offset,     k, &quot;stillborn&quot;, bool_signature, false); \
1612   macro(_stackSize_offset,     k, &quot;stackSize&quot;, long_signature, false); \
1613   macro(_tid_offset,           k, &quot;tid&quot;, long_signature, false); \
1614   macro(_thread_status_offset, k, &quot;threadStatus&quot;, int_signature, false); \
<a name="49" id="anc49"></a><span class="line-modified">1615   macro(_park_blocker_offset,  k, &quot;parkBlocker&quot;, object_signature, false); \</span>
<span class="line-removed">1616   macro(_park_event_offset,    k, &quot;nativeParkEventPointer&quot;, long_signature, false)</span>
1617 
1618 void java_lang_Thread::compute_offsets() {
1619   assert(_group_offset == 0, &quot;offsets should be initialized only once&quot;);
1620 
1621   InstanceKlass* k = SystemDictionary::Thread_klass();
1622   THREAD_FIELDS_DO(FIELD_COMPUTE_OFFSET);
1623 }
1624 
1625 #if INCLUDE_CDS
1626 void java_lang_Thread::serialize_offsets(SerializeClosure* f) {
1627   THREAD_FIELDS_DO(FIELD_SERIALIZE_OFFSET);
1628 }
1629 #endif
1630 
1631 JavaThread* java_lang_Thread::thread(oop java_thread) {
1632   return (JavaThread*)java_thread-&gt;address_field(_eetop_offset);
1633 }
1634 
1635 
1636 void java_lang_Thread::set_thread(oop java_thread, JavaThread* thread) {
1637   java_thread-&gt;address_field_put(_eetop_offset, (address)thread);
1638 }
1639 
<a name="50" id="anc50"></a>

















1640 
1641 oop java_lang_Thread::name(oop java_thread) {
1642   return java_thread-&gt;obj_field(_name_offset);
1643 }
1644 
1645 
1646 void java_lang_Thread::set_name(oop java_thread, oop name) {
1647   java_thread-&gt;obj_field_put(_name_offset, name);
1648 }
1649 
1650 
1651 ThreadPriority java_lang_Thread::priority(oop java_thread) {
1652   return (ThreadPriority)java_thread-&gt;int_field(_priority_offset);
1653 }
1654 
1655 
1656 void java_lang_Thread::set_priority(oop java_thread, ThreadPriority priority) {
1657   java_thread-&gt;int_field_put(_priority_offset, priority);
1658 }
1659 
1660 
1661 oop java_lang_Thread::threadGroup(oop java_thread) {
1662   return java_thread-&gt;obj_field(_group_offset);
1663 }
1664 
1665 
1666 bool java_lang_Thread::is_stillborn(oop java_thread) {
1667   return java_thread-&gt;bool_field(_stillborn_offset) != 0;
1668 }
1669 
1670 
1671 // We never have reason to turn the stillborn bit off
1672 void java_lang_Thread::set_stillborn(oop java_thread) {
1673   java_thread-&gt;bool_field_put(_stillborn_offset, true);
1674 }
1675 
1676 
1677 bool java_lang_Thread::is_alive(oop java_thread) {
1678   JavaThread* thr = java_lang_Thread::thread(java_thread);
1679   return (thr != NULL);
1680 }
1681 
1682 
1683 bool java_lang_Thread::is_daemon(oop java_thread) {
1684   return java_thread-&gt;bool_field(_daemon_offset) != 0;
1685 }
1686 
1687 
1688 void java_lang_Thread::set_daemon(oop java_thread) {
1689   java_thread-&gt;bool_field_put(_daemon_offset, true);
1690 }
1691 
1692 oop java_lang_Thread::context_class_loader(oop java_thread) {
1693   return java_thread-&gt;obj_field(_contextClassLoader_offset);
1694 }
1695 
1696 oop java_lang_Thread::inherited_access_control_context(oop java_thread) {
1697   return java_thread-&gt;obj_field(_inheritedAccessControlContext_offset);
1698 }
1699 
1700 
1701 jlong java_lang_Thread::stackSize(oop java_thread) {
<a name="51" id="anc51"></a><span class="line-modified">1702   if (_stackSize_offset &gt; 0) {</span>
<span class="line-removed">1703     return java_thread-&gt;long_field(_stackSize_offset);</span>
<span class="line-removed">1704   } else {</span>
<span class="line-removed">1705     return 0;</span>
<span class="line-removed">1706   }</span>
1707 }
1708 
1709 // Write the thread status value to threadStatus field in java.lang.Thread java class.
1710 void java_lang_Thread::set_thread_status(oop java_thread,
1711                                          java_lang_Thread::ThreadStatus status) {
<a name="52" id="anc52"></a><span class="line-modified">1712   // The threadStatus is only present starting in 1.5</span>
<span class="line-removed">1713   if (_thread_status_offset &gt; 0) {</span>
<span class="line-removed">1714     java_thread-&gt;int_field_put(_thread_status_offset, status);</span>
<span class="line-removed">1715   }</span>
1716 }
1717 
1718 // Read thread status value from threadStatus field in java.lang.Thread java class.
1719 java_lang_Thread::ThreadStatus java_lang_Thread::get_thread_status(oop java_thread) {
1720   // Make sure the caller is operating on behalf of the VM or is
1721   // running VM code (state == _thread_in_vm).
1722   assert(Threads_lock-&gt;owned_by_self() || Thread::current()-&gt;is_VM_thread() ||
1723          JavaThread::current()-&gt;thread_state() == _thread_in_vm,
1724          &quot;Java Thread is not running in vm&quot;);
<a name="53" id="anc53"></a><span class="line-modified">1725   // The threadStatus is only present starting in 1.5</span>
<span class="line-removed">1726   if (_thread_status_offset &gt; 0) {</span>
<span class="line-removed">1727     return (java_lang_Thread::ThreadStatus)java_thread-&gt;int_field(_thread_status_offset);</span>
<span class="line-removed">1728   } else {</span>
<span class="line-removed">1729     // All we can easily figure out is if it is alive, but that is</span>
<span class="line-removed">1730     // enough info for a valid unknown status.</span>
<span class="line-removed">1731     // These aren&#39;t restricted to valid set ThreadStatus values, so</span>
<span class="line-removed">1732     // use JVMTI values and cast.</span>
<span class="line-removed">1733     JavaThread* thr = java_lang_Thread::thread(java_thread);</span>
<span class="line-removed">1734     if (thr == NULL) {</span>
<span class="line-removed">1735       // the thread hasn&#39;t run yet or is in the process of exiting</span>
<span class="line-removed">1736       return NEW;</span>
<span class="line-removed">1737     }</span>
<span class="line-removed">1738     return (java_lang_Thread::ThreadStatus)JVMTI_THREAD_STATE_ALIVE;</span>
<span class="line-removed">1739   }</span>
1740 }
1741 
1742 
1743 jlong java_lang_Thread::thread_id(oop java_thread) {
<a name="54" id="anc54"></a><span class="line-modified">1744   // The thread ID field is only present starting in 1.5</span>
<span class="line-removed">1745   if (_tid_offset &gt; 0) {</span>
<span class="line-removed">1746     return java_thread-&gt;long_field(_tid_offset);</span>
<span class="line-removed">1747   } else {</span>
<span class="line-removed">1748     return 0;</span>
<span class="line-removed">1749   }</span>
1750 }
1751 
1752 oop java_lang_Thread::park_blocker(oop java_thread) {
<a name="55" id="anc55"></a><span class="line-modified">1753   assert(JDK_Version::current().supports_thread_park_blocker() &amp;&amp;</span>
<span class="line-removed">1754          _park_blocker_offset != 0, &quot;Must support parkBlocker field&quot;);</span>
<span class="line-removed">1755 </span>
<span class="line-removed">1756   if (_park_blocker_offset &gt; 0) {</span>
<span class="line-removed">1757     return java_thread-&gt;obj_field(_park_blocker_offset);</span>
<span class="line-removed">1758   }</span>
<span class="line-removed">1759 </span>
<span class="line-removed">1760   return NULL;</span>
<span class="line-removed">1761 }</span>
<span class="line-removed">1762 </span>
<span class="line-removed">1763 jlong java_lang_Thread::park_event(oop java_thread) {</span>
<span class="line-removed">1764   if (_park_event_offset &gt; 0) {</span>
<span class="line-removed">1765     return java_thread-&gt;long_field(_park_event_offset);</span>
<span class="line-removed">1766   }</span>
<span class="line-removed">1767   return 0;</span>
1768 }
1769 
<a name="56" id="anc56"></a><span class="line-removed">1770 bool java_lang_Thread::set_park_event(oop java_thread, jlong ptr) {</span>
<span class="line-removed">1771   if (_park_event_offset &gt; 0) {</span>
<span class="line-removed">1772     java_thread-&gt;long_field_put(_park_event_offset, ptr);</span>
<span class="line-removed">1773     return true;</span>
<span class="line-removed">1774   }</span>
<span class="line-removed">1775   return false;</span>
<span class="line-removed">1776 }</span>
<span class="line-removed">1777 </span>
<span class="line-removed">1778 </span>
<span class="line-removed">1779 const char* java_lang_Thread::thread_status_name(oop java_thread) {</span>
1780   assert(_thread_status_offset != 0, &quot;Must have thread status&quot;);
1781   ThreadStatus status = (java_lang_Thread::ThreadStatus)java_thread-&gt;int_field(_thread_status_offset);
1782   switch (status) {
1783     case NEW                      : return &quot;NEW&quot;;
1784     case RUNNABLE                 : return &quot;RUNNABLE&quot;;
1785     case SLEEPING                 : return &quot;TIMED_WAITING (sleeping)&quot;;
1786     case IN_OBJECT_WAIT           : return &quot;WAITING (on object monitor)&quot;;
1787     case IN_OBJECT_WAIT_TIMED     : return &quot;TIMED_WAITING (on object monitor)&quot;;
1788     case PARKED                   : return &quot;WAITING (parking)&quot;;
1789     case PARKED_TIMED             : return &quot;TIMED_WAITING (parking)&quot;;
1790     case BLOCKED_ON_MONITOR_ENTER : return &quot;BLOCKED (on object monitor)&quot;;
1791     case TERMINATED               : return &quot;TERMINATED&quot;;
1792     default                       : return &quot;UNKNOWN&quot;;
1793   };
1794 }
1795 int java_lang_ThreadGroup::_parent_offset = 0;
1796 int java_lang_ThreadGroup::_name_offset = 0;
1797 int java_lang_ThreadGroup::_threads_offset = 0;
1798 int java_lang_ThreadGroup::_groups_offset = 0;
1799 int java_lang_ThreadGroup::_maxPriority_offset = 0;
1800 int java_lang_ThreadGroup::_destroyed_offset = 0;
1801 int java_lang_ThreadGroup::_daemon_offset = 0;
1802 int java_lang_ThreadGroup::_nthreads_offset = 0;
1803 int java_lang_ThreadGroup::_ngroups_offset = 0;
1804 
1805 oop  java_lang_ThreadGroup::parent(oop java_thread_group) {
1806   assert(oopDesc::is_oop(java_thread_group), &quot;thread group must be oop&quot;);
1807   return java_thread_group-&gt;obj_field(_parent_offset);
1808 }
1809 
1810 // (&quot;name as oop&quot; accessor is not necessary)
1811 
1812 const char* java_lang_ThreadGroup::name(oop java_thread_group) {
1813   oop name = java_thread_group-&gt;obj_field(_name_offset);
1814   // ThreadGroup.name can be null
1815   if (name != NULL) {
1816     return java_lang_String::as_utf8_string(name);
1817   }
1818   return NULL;
1819 }
1820 
1821 int java_lang_ThreadGroup::nthreads(oop java_thread_group) {
1822   assert(oopDesc::is_oop(java_thread_group), &quot;thread group must be oop&quot;);
1823   return java_thread_group-&gt;int_field(_nthreads_offset);
1824 }
1825 
1826 objArrayOop java_lang_ThreadGroup::threads(oop java_thread_group) {
1827   oop threads = java_thread_group-&gt;obj_field(_threads_offset);
1828   assert(threads != NULL, &quot;threadgroups should have threads&quot;);
1829   assert(threads-&gt;is_objArray(), &quot;just checking&quot;); // Todo: Add better type checking code
1830   return objArrayOop(threads);
1831 }
1832 
1833 int java_lang_ThreadGroup::ngroups(oop java_thread_group) {
1834   assert(oopDesc::is_oop(java_thread_group), &quot;thread group must be oop&quot;);
1835   return java_thread_group-&gt;int_field(_ngroups_offset);
1836 }
1837 
1838 objArrayOop java_lang_ThreadGroup::groups(oop java_thread_group) {
1839   oop groups = java_thread_group-&gt;obj_field(_groups_offset);
1840   assert(groups == NULL || groups-&gt;is_objArray(), &quot;just checking&quot;); // Todo: Add better type checking code
1841   return objArrayOop(groups);
1842 }
1843 
1844 ThreadPriority java_lang_ThreadGroup::maxPriority(oop java_thread_group) {
1845   assert(oopDesc::is_oop(java_thread_group), &quot;thread group must be oop&quot;);
1846   return (ThreadPriority) java_thread_group-&gt;int_field(_maxPriority_offset);
1847 }
1848 
1849 bool java_lang_ThreadGroup::is_destroyed(oop java_thread_group) {
1850   assert(oopDesc::is_oop(java_thread_group), &quot;thread group must be oop&quot;);
1851   return java_thread_group-&gt;bool_field(_destroyed_offset) != 0;
1852 }
1853 
1854 bool java_lang_ThreadGroup::is_daemon(oop java_thread_group) {
1855   assert(oopDesc::is_oop(java_thread_group), &quot;thread group must be oop&quot;);
1856   return java_thread_group-&gt;bool_field(_daemon_offset) != 0;
1857 }
1858 
1859 #define THREADGROUP_FIELDS_DO(macro) \
1860   macro(_parent_offset,      k, vmSymbols::parent_name(),      threadgroup_signature,       false); \
1861   macro(_name_offset,        k, vmSymbols::name_name(),        string_signature,            false); \
1862   macro(_threads_offset,     k, vmSymbols::threads_name(),     thread_array_signature,      false); \
1863   macro(_groups_offset,      k, vmSymbols::groups_name(),      threadgroup_array_signature, false); \
1864   macro(_maxPriority_offset, k, vmSymbols::maxPriority_name(), int_signature,               false); \
1865   macro(_destroyed_offset,   k, vmSymbols::destroyed_name(),   bool_signature,              false); \
1866   macro(_daemon_offset,      k, vmSymbols::daemon_name(),      bool_signature,              false); \
1867   macro(_nthreads_offset,    k, vmSymbols::nthreads_name(),    int_signature,               false); \
1868   macro(_ngroups_offset,     k, vmSymbols::ngroups_name(),     int_signature,               false)
1869 
1870 void java_lang_ThreadGroup::compute_offsets() {
1871   assert(_parent_offset == 0, &quot;offsets should be initialized only once&quot;);
1872 
1873   InstanceKlass* k = SystemDictionary::ThreadGroup_klass();
1874   THREADGROUP_FIELDS_DO(FIELD_COMPUTE_OFFSET);
1875 }
1876 
1877 #if INCLUDE_CDS
1878 void java_lang_ThreadGroup::serialize_offsets(SerializeClosure* f) {
1879   THREADGROUP_FIELDS_DO(FIELD_SERIALIZE_OFFSET);
1880 }
1881 #endif
1882 
1883 #define THROWABLE_FIELDS_DO(macro) \
1884   macro(backtrace_offset,     k, &quot;backtrace&quot;,     object_signature,                  false); \
1885   macro(detailMessage_offset, k, &quot;detailMessage&quot;, string_signature,                  false); \
1886   macro(stackTrace_offset,    k, &quot;stackTrace&quot;,    java_lang_StackTraceElement_array, false); \
1887   macro(depth_offset,         k, &quot;depth&quot;,         int_signature,                     false); \
1888   macro(static_unassigned_stacktrace_offset, k, &quot;UNASSIGNED_STACK&quot;, java_lang_StackTraceElement_array, true)
1889 
1890 void java_lang_Throwable::compute_offsets() {
1891   InstanceKlass* k = SystemDictionary::Throwable_klass();
1892   THROWABLE_FIELDS_DO(FIELD_COMPUTE_OFFSET);
1893 }
1894 
1895 #if INCLUDE_CDS
1896 void java_lang_Throwable::serialize_offsets(SerializeClosure* f) {
1897   THROWABLE_FIELDS_DO(FIELD_SERIALIZE_OFFSET);
1898 }
1899 #endif
1900 
1901 oop java_lang_Throwable::unassigned_stacktrace() {
1902   InstanceKlass* ik = SystemDictionary::Throwable_klass();
1903   oop base = ik-&gt;static_field_base_raw();
1904   return base-&gt;obj_field(static_unassigned_stacktrace_offset);
1905 }
1906 
1907 oop java_lang_Throwable::backtrace(oop throwable) {
1908   return throwable-&gt;obj_field_acquire(backtrace_offset);
1909 }
1910 
1911 
1912 void java_lang_Throwable::set_backtrace(oop throwable, oop value) {
1913   throwable-&gt;release_obj_field_put(backtrace_offset, value);
1914 }
1915 
1916 int java_lang_Throwable::depth(oop throwable) {
1917   return throwable-&gt;int_field(depth_offset);
1918 }
1919 
1920 void java_lang_Throwable::set_depth(oop throwable, int value) {
1921   throwable-&gt;int_field_put(depth_offset, value);
1922 }
1923 
1924 oop java_lang_Throwable::message(oop throwable) {
1925   return throwable-&gt;obj_field(detailMessage_offset);
1926 }
1927 
1928 
1929 // Return Symbol for detailed_message or NULL
1930 Symbol* java_lang_Throwable::detail_message(oop throwable) {
1931   PRESERVE_EXCEPTION_MARK;  // Keep original exception
1932   oop detailed_message = java_lang_Throwable::message(throwable);
1933   if (detailed_message != NULL) {
<a name="57" id="anc57"></a><span class="line-modified">1934     return java_lang_String::as_symbol(detailed_message, THREAD);</span>
1935   }
1936   return NULL;
1937 }
1938 
1939 void java_lang_Throwable::set_message(oop throwable, oop value) {
1940   throwable-&gt;obj_field_put(detailMessage_offset, value);
1941 }
1942 
1943 
1944 void java_lang_Throwable::set_stacktrace(oop throwable, oop st_element_array) {
1945   throwable-&gt;obj_field_put(stackTrace_offset, st_element_array);
1946 }
1947 
1948 void java_lang_Throwable::clear_stacktrace(oop throwable) {
1949   set_stacktrace(throwable, NULL);
1950 }
1951 
1952 
1953 void java_lang_Throwable::print(oop throwable, outputStream* st) {
1954   ResourceMark rm;
1955   Klass* k = throwable-&gt;klass();
1956   assert(k != NULL, &quot;just checking&quot;);
1957   st-&gt;print(&quot;%s&quot;, k-&gt;external_name());
1958   oop msg = message(throwable);
1959   if (msg != NULL) {
1960     st-&gt;print(&quot;: %s&quot;, java_lang_String::as_utf8_string(msg));
1961   }
1962 }
1963 
1964 // After this many redefines, the stack trace is unreliable.
1965 const int MAX_VERSION = USHRT_MAX;
1966 
1967 static inline bool version_matches(Method* method, int version) {
1968   assert(version &lt; MAX_VERSION, &quot;version is too big&quot;);
1969   return method != NULL &amp;&amp; (method-&gt;constants()-&gt;version() == version);
1970 }
1971 
<a name="58" id="anc58"></a><span class="line-removed">1972 </span>
1973 // This class provides a simple wrapper over the internal structure of
1974 // exception backtrace to insulate users of the backtrace from needing
1975 // to know what it looks like.
<a name="59" id="anc59"></a>

1976 class BacktraceBuilder: public StackObj {
1977  friend class BacktraceIterator;
1978  private:
1979   Handle          _backtrace;
1980   objArrayOop     _head;
1981   typeArrayOop    _methods;
1982   typeArrayOop    _bcis;
1983   objArrayOop     _mirrors;
<a name="60" id="anc60"></a><span class="line-modified">1984   typeArrayOop    _names; // needed to insulate method name against redefinition</span>




1985   int             _index;
1986   NoSafepointVerifier _nsv;
1987 
1988   enum {
1989     trace_methods_offset = java_lang_Throwable::trace_methods_offset,
1990     trace_bcis_offset    = java_lang_Throwable::trace_bcis_offset,
1991     trace_mirrors_offset = java_lang_Throwable::trace_mirrors_offset,
1992     trace_names_offset   = java_lang_Throwable::trace_names_offset,
1993     trace_next_offset    = java_lang_Throwable::trace_next_offset,
<a name="61" id="anc61"></a>
1994     trace_size           = java_lang_Throwable::trace_size,
1995     trace_chunk_size     = java_lang_Throwable::trace_chunk_size
1996   };
1997 
1998   // get info out of chunks
1999   static typeArrayOop get_methods(objArrayHandle chunk) {
2000     typeArrayOop methods = typeArrayOop(chunk-&gt;obj_at(trace_methods_offset));
2001     assert(methods != NULL, &quot;method array should be initialized in backtrace&quot;);
2002     return methods;
2003   }
2004   static typeArrayOop get_bcis(objArrayHandle chunk) {
2005     typeArrayOop bcis = typeArrayOop(chunk-&gt;obj_at(trace_bcis_offset));
2006     assert(bcis != NULL, &quot;bci array should be initialized in backtrace&quot;);
2007     return bcis;
2008   }
2009   static objArrayOop get_mirrors(objArrayHandle chunk) {
2010     objArrayOop mirrors = objArrayOop(chunk-&gt;obj_at(trace_mirrors_offset));
2011     assert(mirrors != NULL, &quot;mirror array should be initialized in backtrace&quot;);
2012     return mirrors;
2013   }
2014   static typeArrayOop get_names(objArrayHandle chunk) {
2015     typeArrayOop names = typeArrayOop(chunk-&gt;obj_at(trace_names_offset));
2016     assert(names != NULL, &quot;names array should be initialized in backtrace&quot;);
2017     return names;
2018   }
<a name="62" id="anc62"></a>



2019 
2020  public:
2021 
2022   // constructor for new backtrace
<a name="63" id="anc63"></a><span class="line-modified">2023   BacktraceBuilder(TRAPS): _head(NULL), _methods(NULL), _bcis(NULL), _mirrors(NULL), _names(NULL) {</span>
2024     expand(CHECK);
2025     _backtrace = Handle(THREAD, _head);
2026     _index = 0;
2027   }
2028 
2029   BacktraceBuilder(Thread* thread, objArrayHandle backtrace) {
2030     _methods = get_methods(backtrace);
2031     _bcis = get_bcis(backtrace);
2032     _mirrors = get_mirrors(backtrace);
2033     _names = get_names(backtrace);
<a name="64" id="anc64"></a>
2034     assert(_methods-&gt;length() == _bcis-&gt;length() &amp;&amp;
2035            _methods-&gt;length() == _mirrors-&gt;length() &amp;&amp;
2036            _mirrors-&gt;length() == _names-&gt;length(),
2037            &quot;method and source information arrays should match&quot;);
2038 
2039     // head is the preallocated backtrace
2040     _head = backtrace();
2041     _backtrace = Handle(thread, _head);
2042     _index = 0;
2043   }
2044 
2045   void expand(TRAPS) {
2046     objArrayHandle old_head(THREAD, _head);
2047     PauseNoSafepointVerifier pnsv(&amp;_nsv);
2048 
2049     objArrayOop head = oopFactory::new_objectArray(trace_size, CHECK);
2050     objArrayHandle new_head(THREAD, head);
2051 
2052     typeArrayOop methods = oopFactory::new_shortArray(trace_chunk_size, CHECK);
2053     typeArrayHandle new_methods(THREAD, methods);
2054 
2055     typeArrayOop bcis = oopFactory::new_intArray(trace_chunk_size, CHECK);
2056     typeArrayHandle new_bcis(THREAD, bcis);
2057 
2058     objArrayOop mirrors = oopFactory::new_objectArray(trace_chunk_size, CHECK);
2059     objArrayHandle new_mirrors(THREAD, mirrors);
2060 
2061     typeArrayOop names = oopFactory::new_symbolArray(trace_chunk_size, CHECK);
2062     typeArrayHandle new_names(THREAD, names);
2063 
2064     if (!old_head.is_null()) {
2065       old_head-&gt;obj_at_put(trace_next_offset, new_head());
2066     }
2067     new_head-&gt;obj_at_put(trace_methods_offset, new_methods());
2068     new_head-&gt;obj_at_put(trace_bcis_offset, new_bcis());
2069     new_head-&gt;obj_at_put(trace_mirrors_offset, new_mirrors());
2070     new_head-&gt;obj_at_put(trace_names_offset, new_names());
<a name="65" id="anc65"></a>
2071 
2072     _head    = new_head();
2073     _methods = new_methods();
2074     _bcis = new_bcis();
2075     _mirrors = new_mirrors();
2076     _names  = new_names();
2077     _index = 0;
2078   }
2079 
2080   oop backtrace() {
2081     return _backtrace();
2082   }
2083 
2084   inline void push(Method* method, int bci, TRAPS) {
2085     // Smear the -1 bci to 0 since the array only holds unsigned
2086     // shorts.  The later line number lookup would just smear the -1
2087     // to a 0 even if it could be recorded.
2088     if (bci == SynchronizationEntryBCI) bci = 0;
2089 
2090     if (_index &gt;= trace_chunk_size) {
2091       methodHandle mhandle(THREAD, method);
2092       expand(CHECK);
2093       method = mhandle();
2094     }
2095 
2096     _methods-&gt;ushort_at_put(_index, method-&gt;orig_method_idnum());
2097     _bcis-&gt;int_at_put(_index, Backtrace::merge_bci_and_version(bci, method-&gt;constants()-&gt;version()));
2098 
2099     // Note:this doesn&#39;t leak symbols because the mirror in the backtrace keeps the
2100     // klass owning the symbols alive so their refcounts aren&#39;t decremented.
2101     Symbol* name = method-&gt;name();
2102     _names-&gt;symbol_at_put(_index, name);
2103 
2104     // We need to save the mirrors in the backtrace to keep the class
2105     // from being unloaded while we still have this stack trace.
2106     assert(method-&gt;method_holder()-&gt;java_mirror() != NULL, &quot;never push null for mirror&quot;);
2107     _mirrors-&gt;obj_at_put(_index, method-&gt;method_holder()-&gt;java_mirror());
2108     _index++;
2109   }
2110 
<a name="66" id="anc66"></a>













2111 };
2112 
2113 struct BacktraceElement : public StackObj {
2114   int _method_id;
2115   int _bci;
2116   int _version;
2117   Symbol* _name;
2118   Handle _mirror;
2119   BacktraceElement(Handle mirror, int mid, int version, int bci, Symbol* name) :
2120                    _method_id(mid), _bci(bci), _version(version), _name(name), _mirror(mirror) {}
2121 };
2122 
2123 class BacktraceIterator : public StackObj {
2124   int _index;
2125   objArrayHandle  _result;
2126   objArrayHandle  _mirrors;
2127   typeArrayHandle _methods;
2128   typeArrayHandle _bcis;
2129   typeArrayHandle _names;
2130 
2131   void init(objArrayHandle result, Thread* thread) {
2132     // Get method id, bci, version and mirror from chunk
2133     _result = result;
2134     if (_result.not_null()) {
2135       _methods = typeArrayHandle(thread, BacktraceBuilder::get_methods(_result));
2136       _bcis = typeArrayHandle(thread, BacktraceBuilder::get_bcis(_result));
2137       _mirrors = objArrayHandle(thread, BacktraceBuilder::get_mirrors(_result));
2138       _names = typeArrayHandle(thread, BacktraceBuilder::get_names(_result));
2139       _index = 0;
2140     }
2141   }
2142  public:
2143   BacktraceIterator(objArrayHandle result, Thread* thread) {
2144     init(result, thread);
2145     assert(_methods.is_null() || _methods-&gt;length() == java_lang_Throwable::trace_chunk_size, &quot;lengths don&#39;t match&quot;);
2146   }
2147 
2148   BacktraceElement next(Thread* thread) {
2149     BacktraceElement e (Handle(thread, _mirrors-&gt;obj_at(_index)),
2150                         _methods-&gt;ushort_at(_index),
2151                         Backtrace::version_at(_bcis-&gt;int_at(_index)),
2152                         Backtrace::bci_at(_bcis-&gt;int_at(_index)),
2153                         _names-&gt;symbol_at(_index));
2154     _index++;
2155 
2156     if (_index &gt;= java_lang_Throwable::trace_chunk_size) {
2157       int next_offset = java_lang_Throwable::trace_next_offset;
2158       // Get next chunk
2159       objArrayHandle result (thread, objArrayOop(_result-&gt;obj_at(next_offset)));
2160       init(result, thread);
2161     }
2162     return e;
2163   }
2164 
2165   bool repeat() {
2166     return _result.not_null() &amp;&amp; _mirrors-&gt;obj_at(_index) != NULL;
2167   }
2168 };
2169 
2170 
2171 // Print stack trace element to resource allocated buffer
2172 static void print_stack_element_to_stream(outputStream* st, Handle mirror, int method_id,
2173                                           int version, int bci, Symbol* name) {
2174   ResourceMark rm;
2175 
2176   // Get strings and string lengths
2177   InstanceKlass* holder = InstanceKlass::cast(java_lang_Class::as_Klass(mirror()));
2178   const char* klass_name  = holder-&gt;external_name();
2179   int buf_len = (int)strlen(klass_name);
2180 
2181   char* method_name = name-&gt;as_C_string();
2182   buf_len += (int)strlen(method_name);
2183 
2184   char* source_file_name = NULL;
2185   Symbol* source = Backtrace::get_source_file_name(holder, version);
2186   if (source != NULL) {
2187     source_file_name = source-&gt;as_C_string();
2188     buf_len += (int)strlen(source_file_name);
2189   }
2190 
2191   char *module_name = NULL, *module_version = NULL;
2192   ModuleEntry* module = holder-&gt;module();
2193   if (module-&gt;is_named()) {
2194     module_name = module-&gt;name()-&gt;as_C_string();
2195     buf_len += (int)strlen(module_name);
2196     if (module-&gt;version() != NULL) {
2197       module_version = module-&gt;version()-&gt;as_C_string();
2198       buf_len += (int)strlen(module_version);
2199     }
2200   }
2201 
2202   // Allocate temporary buffer with extra space for formatting and line number
2203   char* buf = NEW_RESOURCE_ARRAY(char, buf_len + 64);
2204 
2205   // Print stack trace line in buffer
2206   sprintf(buf, &quot;\tat %s.%s(&quot;, klass_name, method_name);
2207 
2208   // Print module information
2209   if (module_name != NULL) {
2210     if (module_version != NULL) {
2211       sprintf(buf + (int)strlen(buf), &quot;%s@%s/&quot;, module_name, module_version);
2212     } else {
2213       sprintf(buf + (int)strlen(buf), &quot;%s/&quot;, module_name);
2214     }
2215   }
2216 
2217   // The method can be NULL if the requested class version is gone
2218   Method* method = holder-&gt;method_with_orig_idnum(method_id, version);
2219   if (!version_matches(method, version)) {
2220     strcat(buf, &quot;Redefined)&quot;);
2221   } else {
2222     int line_number = Backtrace::get_line_number(method, bci);
2223     if (line_number == -2) {
2224       strcat(buf, &quot;Native Method)&quot;);
2225     } else {
2226       if (source_file_name != NULL &amp;&amp; (line_number != -1)) {
2227         // Sourcename and linenumber
2228         sprintf(buf + (int)strlen(buf), &quot;%s:%d)&quot;, source_file_name, line_number);
2229       } else if (source_file_name != NULL) {
2230         // Just sourcename
2231         sprintf(buf + (int)strlen(buf), &quot;%s)&quot;, source_file_name);
2232       } else {
2233         // Neither sourcename nor linenumber
2234         sprintf(buf + (int)strlen(buf), &quot;Unknown Source)&quot;);
2235       }
2236       CompiledMethod* nm = method-&gt;code();
2237       if (WizardMode &amp;&amp; nm != NULL) {
2238         sprintf(buf + (int)strlen(buf), &quot;(nmethod &quot; INTPTR_FORMAT &quot;)&quot;, (intptr_t)nm);
2239       }
2240     }
2241   }
2242 
2243   st-&gt;print_cr(&quot;%s&quot;, buf);
2244 }
2245 
<a name="67" id="anc67"></a><span class="line-modified">2246 void java_lang_Throwable::print_stack_element(outputStream *st, const methodHandle&amp; method, int bci) {</span>
2247   Handle mirror (Thread::current(),  method-&gt;method_holder()-&gt;java_mirror());
2248   int method_id = method-&gt;orig_method_idnum();
2249   int version = method-&gt;constants()-&gt;version();
2250   print_stack_element_to_stream(st, mirror, method_id, version, bci, method-&gt;name());
2251 }
2252 
2253 /**
2254  * Print the throwable message and its stack trace plus all causes by walking the
2255  * cause chain.  The output looks the same as of Throwable.printStackTrace().
2256  */
2257 void java_lang_Throwable::print_stack_trace(Handle throwable, outputStream* st) {
2258   // First, print the message.
2259   print(throwable(), st);
2260   st-&gt;cr();
2261 
2262   // Now print the stack trace.
2263   Thread* THREAD = Thread::current();
2264   while (throwable.not_null()) {
2265     objArrayHandle result (THREAD, objArrayOop(backtrace(throwable())));
2266     if (result.is_null()) {
2267       st-&gt;print_raw_cr(&quot;\t&lt;&lt;no stack trace available&gt;&gt;&quot;);
2268       return;
2269     }
2270     BacktraceIterator iter(result, THREAD);
2271 
2272     while (iter.repeat()) {
2273       BacktraceElement bte = iter.next(THREAD);
2274       print_stack_element_to_stream(st, bte._mirror, bte._method_id, bte._version, bte._bci, bte._name);
2275     }
2276     {
2277       // Call getCause() which doesn&#39;t necessarily return the _cause field.
2278       EXCEPTION_MARK;
2279       JavaValue cause(T_OBJECT);
2280       JavaCalls::call_virtual(&amp;cause,
2281                               throwable,
2282                               throwable-&gt;klass(),
2283                               vmSymbols::getCause_name(),
2284                               vmSymbols::void_throwable_signature(),
2285                               THREAD);
2286       // Ignore any exceptions. we are in the middle of exception handling. Same as classic VM.
2287       if (HAS_PENDING_EXCEPTION) {
2288         CLEAR_PENDING_EXCEPTION;
2289         throwable = Handle();
2290       } else {
2291         throwable = Handle(THREAD, (oop) cause.get_jobject());
2292         if (throwable.not_null()) {
2293           st-&gt;print(&quot;Caused by: &quot;);
2294           print(throwable(), st);
2295           st-&gt;cr();
2296         }
2297       }
2298     }
2299   }
2300 }
2301 
2302 /**
2303  * Print the throwable stack trace by calling the Java method java.lang.Throwable.printStackTrace().
2304  */
2305 void java_lang_Throwable::java_printStackTrace(Handle throwable, TRAPS) {
2306   assert(throwable-&gt;is_a(SystemDictionary::Throwable_klass()), &quot;Throwable instance expected&quot;);
2307   JavaValue result(T_VOID);
2308   JavaCalls::call_virtual(&amp;result,
2309                           throwable,
2310                           SystemDictionary::Throwable_klass(),
2311                           vmSymbols::printStackTrace_name(),
2312                           vmSymbols::void_method_signature(),
2313                           THREAD);
2314 }
2315 
2316 void java_lang_Throwable::fill_in_stack_trace(Handle throwable, const methodHandle&amp; method, TRAPS) {
2317   if (!StackTraceInThrowable) return;
2318   ResourceMark rm(THREAD);
2319 
2320   // Start out by clearing the backtrace for this object, in case the VM
2321   // runs out of memory while allocating the stack trace
2322   set_backtrace(throwable(), NULL);
2323   // Clear lazily constructed Java level stacktrace if refilling occurs
2324   // This is unnecessary in 1.7+ but harmless
2325   clear_stacktrace(throwable());
2326 
2327   int max_depth = MaxJavaStackTraceDepth;
2328   JavaThread* thread = (JavaThread*)THREAD;
2329 
2330   BacktraceBuilder bt(CHECK);
2331 
2332   // If there is no Java frame just return the method that was being called
2333   // with bci 0
2334   if (!thread-&gt;has_last_Java_frame()) {
2335     if (max_depth &gt;= 1 &amp;&amp; method() != NULL) {
2336       bt.push(method(), 0, CHECK);
2337       log_info(stacktrace)(&quot;%s, %d&quot;, throwable-&gt;klass()-&gt;external_name(), 1);
2338       set_depth(throwable(), 1);
2339       set_backtrace(throwable(), bt.backtrace());
2340     }
2341     return;
2342   }
2343 
2344   // Instead of using vframe directly, this version of fill_in_stack_trace
2345   // basically handles everything by hand. This significantly improved the
2346   // speed of this method call up to 28.5% on Solaris sparc. 27.1% on Windows.
2347   // See bug 6333838 for  more details.
2348   // The &quot;ASSERT&quot; here is to verify this method generates the exactly same stack
2349   // trace as utilizing vframe.
2350 #ifdef ASSERT
2351   vframeStream st(thread);
<a name="68" id="anc68"></a><span class="line-removed">2352   methodHandle st_method(THREAD, st.method());</span>
2353 #endif
2354   int total_count = 0;
2355   RegisterMap map(thread, false);
2356   int decode_offset = 0;
2357   CompiledMethod* nm = NULL;
2358   bool skip_fillInStackTrace_check = false;
2359   bool skip_throwableInit_check = false;
2360   bool skip_hidden = !ShowHiddenFrames;
2361 
2362   for (frame fr = thread-&gt;last_frame(); max_depth == 0 || max_depth != total_count;) {
2363     Method* method = NULL;
2364     int bci = 0;
2365 
2366     // Compiled java method case.
2367     if (decode_offset != 0) {
2368       DebugInfoReadStream stream(nm, decode_offset);
2369       decode_offset = stream.read_int();
2370       method = (Method*)nm-&gt;metadata_at(stream.read_int());
2371       bci = stream.read_bci();
2372     } else {
2373       if (fr.is_first_frame()) break;
2374       address pc = fr.pc();
2375       if (fr.is_interpreted_frame()) {
2376         address bcp = fr.interpreter_frame_bcp();
2377         method = fr.interpreter_frame_method();
2378         bci =  method-&gt;bci_from(bcp);
2379         fr = fr.sender(&amp;map);
2380       } else {
2381         CodeBlob* cb = fr.cb();
2382         // HMMM QQQ might be nice to have frame return nm as NULL if cb is non-NULL
2383         // but non nmethod
2384         fr = fr.sender(&amp;map);
2385         if (cb == NULL || !cb-&gt;is_compiled()) {
2386           continue;
2387         }
2388         nm = cb-&gt;as_compiled_method();
2389         if (nm-&gt;method()-&gt;is_native()) {
2390           method = nm-&gt;method();
2391           bci = 0;
2392         } else {
2393           PcDesc* pd = nm-&gt;pc_desc_at(pc);
2394           decode_offset = pd-&gt;scope_decode_offset();
2395           // if decode_offset is not equal to 0, it will execute the
2396           // &quot;compiled java method case&quot; at the beginning of the loop.
2397           continue;
2398         }
2399       }
2400     }
2401 #ifdef ASSERT
<a name="69" id="anc69"></a><span class="line-modified">2402     assert(st_method() == method &amp;&amp; st.bci() == bci,</span>
2403            &quot;Wrong stack trace&quot;);
2404     st.next();
<a name="70" id="anc70"></a><span class="line-removed">2405     // vframeStream::method isn&#39;t GC-safe so store off a copy</span>
<span class="line-removed">2406     // of the Method* in case we GC.</span>
<span class="line-removed">2407     if (!st.at_end()) {</span>
<span class="line-removed">2408       st_method = st.method();</span>
<span class="line-removed">2409     }</span>
2410 #endif
2411 
2412     // the format of the stacktrace will be:
2413     // - 1 or more fillInStackTrace frames for the exception class (skipped)
2414     // - 0 or more &lt;init&gt; methods for the exception class (skipped)
2415     // - rest of the stack
2416 
2417     if (!skip_fillInStackTrace_check) {
2418       if (method-&gt;name() == vmSymbols::fillInStackTrace_name() &amp;&amp;
2419           throwable-&gt;is_a(method-&gt;method_holder())) {
2420         continue;
2421       }
2422       else {
2423         skip_fillInStackTrace_check = true; // gone past them all
2424       }
2425     }
2426     if (!skip_throwableInit_check) {
2427       assert(skip_fillInStackTrace_check, &quot;logic error in backtrace filtering&quot;);
2428 
2429       // skip &lt;init&gt; methods of the exception class and superclasses
2430       // This is simlar to classic VM.
2431       if (method-&gt;name() == vmSymbols::object_initializer_name() &amp;&amp;
2432           throwable-&gt;is_a(method-&gt;method_holder())) {
2433         continue;
2434       } else {
2435         // there are none or we&#39;ve seen them all - either way stop checking
2436         skip_throwableInit_check = true;
2437       }
2438     }
2439     if (method-&gt;is_hidden()) {
<a name="71" id="anc71"></a><span class="line-modified">2440       if (skip_hidden)  continue;</span>






2441     }
2442     bt.push(method, bci, CHECK);
2443     total_count++;
2444   }
2445 
2446   log_info(stacktrace)(&quot;%s, %d&quot;, throwable-&gt;klass()-&gt;external_name(), total_count);
2447 
2448   // Put completed stack trace into throwable object
2449   set_backtrace(throwable(), bt.backtrace());
2450   set_depth(throwable(), total_count);
2451 }
2452 
2453 void java_lang_Throwable::fill_in_stack_trace(Handle throwable, const methodHandle&amp; method) {
2454   // No-op if stack trace is disabled
2455   if (!StackTraceInThrowable) {
2456     return;
2457   }
2458 
2459   // Disable stack traces for some preallocated out of memory errors
2460   if (!Universe::should_fill_in_stack_trace(throwable)) {
2461     return;
2462   }
2463 
2464   PRESERVE_EXCEPTION_MARK;
2465 
2466   JavaThread* thread = JavaThread::active();
2467   fill_in_stack_trace(throwable, method, thread);
2468   // ignore exceptions thrown during stack trace filling
2469   CLEAR_PENDING_EXCEPTION;
2470 }
2471 
2472 void java_lang_Throwable::allocate_backtrace(Handle throwable, TRAPS) {
2473   // Allocate stack trace - backtrace is created but not filled in
2474 
2475   // No-op if stack trace is disabled
2476   if (!StackTraceInThrowable) return;
2477   BacktraceBuilder bt(CHECK);   // creates a backtrace
2478   set_backtrace(throwable(), bt.backtrace());
2479 }
2480 
2481 
2482 void java_lang_Throwable::fill_in_stack_trace_of_preallocated_backtrace(Handle throwable) {
2483   // Fill in stack trace into preallocated backtrace (no GC)
2484 
2485   // No-op if stack trace is disabled
2486   if (!StackTraceInThrowable) return;
2487 
2488   assert(throwable-&gt;is_a(SystemDictionary::Throwable_klass()), &quot;sanity check&quot;);
2489 
2490   JavaThread* THREAD = JavaThread::current();
2491 
2492   objArrayHandle backtrace (THREAD, (objArrayOop)java_lang_Throwable::backtrace(throwable()));
2493   assert(backtrace.not_null(), &quot;backtrace should have been preallocated&quot;);
2494 
2495   ResourceMark rm(THREAD);
2496   vframeStream st(THREAD);
2497 
2498   BacktraceBuilder bt(THREAD, backtrace);
2499 
2500   // Unlike fill_in_stack_trace we do not skip fillInStackTrace or throwable init
2501   // methods as preallocated errors aren&#39;t created by &quot;java&quot; code.
2502 
2503   // fill in as much stack trace as possible
2504   int chunk_count = 0;
2505   for (;!st.at_end(); st.next()) {
2506     bt.push(st.method(), st.bci(), CHECK);
2507     chunk_count++;
2508 
2509     // Bail-out for deep stacks
2510     if (chunk_count &gt;= trace_chunk_size) break;
2511   }
2512   set_depth(throwable(), chunk_count);
2513   log_info(stacktrace)(&quot;%s, %d&quot;, throwable-&gt;klass()-&gt;external_name(), chunk_count);
2514 
2515   // We support the Throwable immutability protocol defined for Java 7.
2516   java_lang_Throwable::set_stacktrace(throwable(), java_lang_Throwable::unassigned_stacktrace());
2517   assert(java_lang_Throwable::unassigned_stacktrace() != NULL, &quot;not initialized&quot;);
2518 }
2519 
2520 void java_lang_Throwable::get_stack_trace_elements(Handle throwable,
2521                                                    objArrayHandle stack_trace_array_h, TRAPS) {
2522 
2523   if (throwable.is_null() || stack_trace_array_h.is_null()) {
2524     THROW(vmSymbols::java_lang_NullPointerException());
2525   }
2526 
2527   assert(stack_trace_array_h-&gt;is_objArray(), &quot;Stack trace array should be an array of StackTraceElenent&quot;);
2528 
2529   if (stack_trace_array_h-&gt;length() != depth(throwable())) {
2530     THROW(vmSymbols::java_lang_IndexOutOfBoundsException());
2531   }
2532 
2533   objArrayHandle result(THREAD, objArrayOop(backtrace(throwable())));
2534   BacktraceIterator iter(result, THREAD);
2535 
2536   int index = 0;
2537   while (iter.repeat()) {
2538     BacktraceElement bte = iter.next(THREAD);
2539 
2540     Handle stack_trace_element(THREAD, stack_trace_array_h-&gt;obj_at(index++));
2541 
2542     if (stack_trace_element.is_null()) {
2543       THROW(vmSymbols::java_lang_NullPointerException());
2544     }
2545 
2546     InstanceKlass* holder = InstanceKlass::cast(java_lang_Class::as_Klass(bte._mirror()));
2547     methodHandle method (THREAD, holder-&gt;method_with_orig_idnum(bte._method_id, bte._version));
2548 
2549     java_lang_StackTraceElement::fill_in(stack_trace_element, holder,
2550                                          method,
2551                                          bte._version,
2552                                          bte._bci,
2553                                          bte._name, CHECK);
2554   }
2555 }
2556 
<a name="72" id="anc72"></a>






























2557 oop java_lang_StackTraceElement::create(const methodHandle&amp; method, int bci, TRAPS) {
2558   // Allocate java.lang.StackTraceElement instance
2559   InstanceKlass* k = SystemDictionary::StackTraceElement_klass();
2560   assert(k != NULL, &quot;must be loaded in 1.4+&quot;);
2561   if (k-&gt;should_be_initialized()) {
2562     k-&gt;initialize(CHECK_0);
2563   }
2564 
2565   Handle element = k-&gt;allocate_instance_handle(CHECK_0);
2566 
2567   int version = method-&gt;constants()-&gt;version();
2568   fill_in(element, method-&gt;method_holder(), method, version, bci, method-&gt;name(), CHECK_0);
2569   return element();
2570 }
2571 
2572 void java_lang_StackTraceElement::fill_in(Handle element,
2573                                           InstanceKlass* holder, const methodHandle&amp; method,
2574                                           int version, int bci, Symbol* name, TRAPS) {
2575   assert(element-&gt;is_a(SystemDictionary::StackTraceElement_klass()), &quot;sanity check&quot;);
2576 
2577   ResourceMark rm(THREAD);
2578   HandleMark hm(THREAD);
2579 
2580   // Fill in class name
2581   Handle java_class(THREAD, holder-&gt;java_mirror());
2582   oop classname = java_lang_Class::name(java_class, CHECK);
2583   java_lang_StackTraceElement::set_declaringClass(element(), classname);
2584   java_lang_StackTraceElement::set_declaringClassObject(element(), java_class());
2585 
2586   oop loader = holder-&gt;class_loader();
2587   if (loader != NULL) {
2588     oop loader_name = java_lang_ClassLoader::name(loader);
2589     if (loader_name != NULL)
2590       java_lang_StackTraceElement::set_classLoaderName(element(), loader_name);
2591   }
2592 
2593   // Fill in method name
2594   oop methodname = StringTable::intern(name, CHECK);
2595   java_lang_StackTraceElement::set_methodName(element(), methodname);
2596 
2597   // Fill in module name and version
2598   ModuleEntry* module = holder-&gt;module();
2599   if (module-&gt;is_named()) {
2600     oop module_name = StringTable::intern(module-&gt;name(), CHECK);
2601     java_lang_StackTraceElement::set_moduleName(element(), module_name);
2602     oop module_version;
2603     if (module-&gt;version() != NULL) {
2604       module_version = StringTable::intern(module-&gt;version(), CHECK);
2605     } else {
2606       module_version = NULL;
2607     }
2608     java_lang_StackTraceElement::set_moduleVersion(element(), module_version);
2609   }
2610 
2611   if (method() == NULL || !version_matches(method(), version)) {
2612     // The method was redefined, accurate line number information isn&#39;t available
2613     java_lang_StackTraceElement::set_fileName(element(), NULL);
2614     java_lang_StackTraceElement::set_lineNumber(element(), -1);
2615   } else {
<a name="73" id="anc73"></a><span class="line-modified">2616     // Fill in source file name and line number.</span>
<span class="line-modified">2617     Symbol* source = Backtrace::get_source_file_name(holder, version);</span>
<span class="line-modified">2618     oop source_file = java_lang_Class::source_file(java_class());</span>
<span class="line-modified">2619     if (source != NULL) {</span>
<span class="line-removed">2620       // Class was not redefined. We can trust its cache if set,</span>
<span class="line-removed">2621       // else we have to initialize it.</span>
<span class="line-removed">2622       if (source_file == NULL) {</span>
<span class="line-removed">2623         source_file = StringTable::intern(source, CHECK);</span>
<span class="line-removed">2624         java_lang_Class::set_source_file(java_class(), source_file);</span>
<span class="line-removed">2625       }</span>
<span class="line-removed">2626     } else {</span>
<span class="line-removed">2627       // Class was redefined. Dump the cache if it was set.</span>
<span class="line-removed">2628       if (source_file != NULL) {</span>
<span class="line-removed">2629         source_file = NULL;</span>
<span class="line-removed">2630         java_lang_Class::set_source_file(java_class(), source_file);</span>
<span class="line-removed">2631       }</span>
<span class="line-removed">2632       if (ShowHiddenFrames) {</span>
<span class="line-removed">2633         source = vmSymbols::unknown_class_name();</span>
<span class="line-removed">2634         source_file = StringTable::intern(source, CHECK);</span>
<span class="line-removed">2635       }</span>
<span class="line-removed">2636     }</span>
<span class="line-removed">2637     java_lang_StackTraceElement::set_fileName(element(), source_file);</span>
2638 
<a name="74" id="anc74"></a><span class="line-modified">2639     int line_number = Backtrace::get_line_number(method, bci);</span>
2640     java_lang_StackTraceElement::set_lineNumber(element(), line_number);
2641   }
2642 }
2643 
<a name="75" id="anc75"></a>












































2644 Method* java_lang_StackFrameInfo::get_method(Handle stackFrame, InstanceKlass* holder, TRAPS) {
2645   HandleMark hm(THREAD);
2646   Handle mname(THREAD, stackFrame-&gt;obj_field(_memberName_offset));
2647   Method* method = (Method*)java_lang_invoke_MemberName::vmtarget(mname());
2648   // we should expand MemberName::name when Throwable uses StackTrace
2649   // MethodHandles::expand_MemberName(mname, MethodHandles::_suppress_defc|MethodHandles::_suppress_type, CHECK_NULL);
2650   return method;
2651 }
2652 
2653 void java_lang_StackFrameInfo::set_method_and_bci(Handle stackFrame, const methodHandle&amp; method, int bci, TRAPS) {
2654   // set Method* or mid/cpref
2655   HandleMark hm(THREAD);
2656   Handle mname(Thread::current(), stackFrame-&gt;obj_field(_memberName_offset));
2657   InstanceKlass* ik = method-&gt;method_holder();
2658   CallInfo info(method(), ik, CHECK);
2659   MethodHandles::init_method_MemberName(mname, info);
2660   // set bci
2661   java_lang_StackFrameInfo::set_bci(stackFrame(), bci);
2662   // method may be redefined; store the version
2663   int version = method-&gt;constants()-&gt;version();
2664   assert((jushort)version == version, &quot;version should be short&quot;);
2665   java_lang_StackFrameInfo::set_version(stackFrame(), (short)version);
2666 }
2667 
2668 void java_lang_StackFrameInfo::to_stack_trace_element(Handle stackFrame, Handle stack_trace_element, TRAPS) {
2669   ResourceMark rm(THREAD);
2670   HandleMark hm(THREAD);
2671   Handle mname(THREAD, stackFrame-&gt;obj_field(java_lang_StackFrameInfo::_memberName_offset));
2672   Klass* clazz = java_lang_Class::as_Klass(java_lang_invoke_MemberName::clazz(mname()));
2673   InstanceKlass* holder = InstanceKlass::cast(clazz);
2674   Method* method = java_lang_StackFrameInfo::get_method(stackFrame, holder, CHECK);
2675 
2676   short version = stackFrame-&gt;short_field(_version_offset);
<a name="76" id="anc76"></a><span class="line-modified">2677   short bci = stackFrame-&gt;short_field(_bci_offset);</span>
2678   Symbol* name = method-&gt;name();
<a name="77" id="anc77"></a><span class="line-modified">2679   java_lang_StackTraceElement::fill_in(stack_trace_element, holder, method, version, bci, name, CHECK);</span>

2680 }
2681 
2682 #define STACKFRAMEINFO_FIELDS_DO(macro) \
2683   macro(_memberName_offset,     k, &quot;memberName&quot;,  object_signature, false); \
<a name="78" id="anc78"></a><span class="line-modified">2684   macro(_bci_offset,            k, &quot;bci&quot;,         short_signature,  false)</span>
2685 
2686 void java_lang_StackFrameInfo::compute_offsets() {
2687   InstanceKlass* k = SystemDictionary::StackFrameInfo_klass();
2688   STACKFRAMEINFO_FIELDS_DO(FIELD_COMPUTE_OFFSET);
2689   STACKFRAMEINFO_INJECTED_FIELDS(INJECTED_FIELD_COMPUTE_OFFSET);
2690 }
2691 
2692 #if INCLUDE_CDS
2693 void java_lang_StackFrameInfo::serialize_offsets(SerializeClosure* f) {
2694   STACKFRAMEINFO_FIELDS_DO(FIELD_SERIALIZE_OFFSET);
2695   STACKFRAMEINFO_INJECTED_FIELDS(INJECTED_FIELD_SERIALIZE_OFFSET);
2696 }
2697 #endif
2698 
2699 #define LIVESTACKFRAMEINFO_FIELDS_DO(macro) \
2700   macro(_monitors_offset,   k, &quot;monitors&quot;,    object_array_signature, false); \
2701   macro(_locals_offset,     k, &quot;locals&quot;,      object_array_signature, false); \
2702   macro(_operands_offset,   k, &quot;operands&quot;,    object_array_signature, false); \
2703   macro(_mode_offset,       k, &quot;mode&quot;,        int_signature,          false)
2704 
2705 void java_lang_LiveStackFrameInfo::compute_offsets() {
2706   InstanceKlass* k = SystemDictionary::LiveStackFrameInfo_klass();
2707   LIVESTACKFRAMEINFO_FIELDS_DO(FIELD_COMPUTE_OFFSET);
2708 }
2709 
2710 #if INCLUDE_CDS
2711 void java_lang_LiveStackFrameInfo::serialize_offsets(SerializeClosure* f) {
2712   LIVESTACKFRAMEINFO_FIELDS_DO(FIELD_SERIALIZE_OFFSET);
2713 }
2714 #endif
2715 
2716 #define ACCESSIBLEOBJECT_FIELDS_DO(macro) \
2717   macro(override_offset, k, &quot;override&quot;, bool_signature, false)
2718 
2719 void java_lang_reflect_AccessibleObject::compute_offsets() {
2720   InstanceKlass* k = SystemDictionary::reflect_AccessibleObject_klass();
2721   ACCESSIBLEOBJECT_FIELDS_DO(FIELD_COMPUTE_OFFSET);
2722 }
2723 
2724 #if INCLUDE_CDS
2725 void java_lang_reflect_AccessibleObject::serialize_offsets(SerializeClosure* f) {
2726   ACCESSIBLEOBJECT_FIELDS_DO(FIELD_SERIALIZE_OFFSET);
2727 }
2728 #endif
2729 
2730 jboolean java_lang_reflect_AccessibleObject::override(oop reflect) {
2731   assert(Universe::is_fully_initialized(), &quot;Need to find another solution to the reflection problem&quot;);
2732   return (jboolean) reflect-&gt;bool_field(override_offset);
2733 }
2734 
2735 void java_lang_reflect_AccessibleObject::set_override(oop reflect, jboolean value) {
2736   assert(Universe::is_fully_initialized(), &quot;Need to find another solution to the reflection problem&quot;);
2737   reflect-&gt;bool_field_put(override_offset, (int) value);
2738 }
2739 
2740 #define METHOD_FIELDS_DO(macro) \
2741   macro(clazz_offset,          k, vmSymbols::clazz_name(),          class_signature,       false); \
2742   macro(name_offset,           k, vmSymbols::name_name(),           string_signature,      false); \
2743   macro(returnType_offset,     k, vmSymbols::returnType_name(),     class_signature,       false); \
2744   macro(parameterTypes_offset, k, vmSymbols::parameterTypes_name(), class_array_signature, false); \
2745   macro(exceptionTypes_offset, k, vmSymbols::exceptionTypes_name(), class_array_signature, false); \
2746   macro(slot_offset,           k, vmSymbols::slot_name(),           int_signature,         false); \
2747   macro(modifiers_offset,      k, vmSymbols::modifiers_name(),      int_signature,         false); \
2748   macro(signature_offset,             k, vmSymbols::signature_name(),             string_signature,     false); \
2749   macro(annotations_offset,           k, vmSymbols::annotations_name(),           byte_array_signature, false); \
2750   macro(parameter_annotations_offset, k, vmSymbols::parameter_annotations_name(), byte_array_signature, false); \
2751   macro(annotation_default_offset,    k, vmSymbols::annotation_default_name(),    byte_array_signature, false);
2752 
2753 void java_lang_reflect_Method::compute_offsets() {
2754   InstanceKlass* k = SystemDictionary::reflect_Method_klass();
2755   METHOD_FIELDS_DO(FIELD_COMPUTE_OFFSET);
2756 }
2757 
2758 #if INCLUDE_CDS
2759 void java_lang_reflect_Method::serialize_offsets(SerializeClosure* f) {
2760   METHOD_FIELDS_DO(FIELD_SERIALIZE_OFFSET);
2761 }
2762 #endif
2763 
2764 Handle java_lang_reflect_Method::create(TRAPS) {
2765   assert(Universe::is_fully_initialized(), &quot;Need to find another solution to the reflection problem&quot;);
2766   Klass* klass = SystemDictionary::reflect_Method_klass();
2767   // This class is eagerly initialized during VM initialization, since we keep a refence
2768   // to one of the methods
2769   assert(InstanceKlass::cast(klass)-&gt;is_initialized(), &quot;must be initialized&quot;);
2770   return InstanceKlass::cast(klass)-&gt;allocate_instance_handle(THREAD);
2771 }
2772 
2773 oop java_lang_reflect_Method::clazz(oop reflect) {
2774   assert(Universe::is_fully_initialized(), &quot;Need to find another solution to the reflection problem&quot;);
2775   return reflect-&gt;obj_field(clazz_offset);
2776 }
2777 
2778 void java_lang_reflect_Method::set_clazz(oop reflect, oop value) {
2779   assert(Universe::is_fully_initialized(), &quot;Need to find another solution to the reflection problem&quot;);
2780    reflect-&gt;obj_field_put(clazz_offset, value);
2781 }
2782 
2783 int java_lang_reflect_Method::slot(oop reflect) {
2784   assert(Universe::is_fully_initialized(), &quot;Need to find another solution to the reflection problem&quot;);
2785   return reflect-&gt;int_field(slot_offset);
2786 }
2787 
2788 void java_lang_reflect_Method::set_slot(oop reflect, int value) {
2789   assert(Universe::is_fully_initialized(), &quot;Need to find another solution to the reflection problem&quot;);
2790   reflect-&gt;int_field_put(slot_offset, value);
2791 }
2792 
2793 void java_lang_reflect_Method::set_name(oop method, oop value) {
2794   assert(Universe::is_fully_initialized(), &quot;Need to find another solution to the reflection problem&quot;);
2795   method-&gt;obj_field_put(name_offset, value);
2796 }
2797 
2798 oop java_lang_reflect_Method::return_type(oop method) {
2799   assert(Universe::is_fully_initialized(), &quot;Need to find another solution to the reflection problem&quot;);
2800   return method-&gt;obj_field(returnType_offset);
2801 }
2802 
2803 void java_lang_reflect_Method::set_return_type(oop method, oop value) {
2804   assert(Universe::is_fully_initialized(), &quot;Need to find another solution to the reflection problem&quot;);
2805   method-&gt;obj_field_put(returnType_offset, value);
2806 }
2807 
2808 oop java_lang_reflect_Method::parameter_types(oop method) {
2809   assert(Universe::is_fully_initialized(), &quot;Need to find another solution to the reflection problem&quot;);
2810   return method-&gt;obj_field(parameterTypes_offset);
2811 }
2812 
2813 void java_lang_reflect_Method::set_parameter_types(oop method, oop value) {
2814   assert(Universe::is_fully_initialized(), &quot;Need to find another solution to the reflection problem&quot;);
2815   method-&gt;obj_field_put(parameterTypes_offset, value);
2816 }
2817 
2818 void java_lang_reflect_Method::set_exception_types(oop method, oop value) {
2819   assert(Universe::is_fully_initialized(), &quot;Need to find another solution to the reflection problem&quot;);
2820   method-&gt;obj_field_put(exceptionTypes_offset, value);
2821 }
2822 
2823 void java_lang_reflect_Method::set_modifiers(oop method, int value) {
2824   assert(Universe::is_fully_initialized(), &quot;Need to find another solution to the reflection problem&quot;);
2825   method-&gt;int_field_put(modifiers_offset, value);
2826 }
2827 
2828 void java_lang_reflect_Method::set_signature(oop method, oop value) {
2829   assert(Universe::is_fully_initialized(), &quot;Need to find another solution to the reflection problem&quot;);
2830   method-&gt;obj_field_put(signature_offset, value);
2831 }
2832 
2833 void java_lang_reflect_Method::set_annotations(oop method, oop value) {
2834   assert(Universe::is_fully_initialized(), &quot;Need to find another solution to the reflection problem&quot;);
2835   method-&gt;obj_field_put(annotations_offset, value);
2836 }
2837 
2838 void java_lang_reflect_Method::set_parameter_annotations(oop method, oop value) {
2839   assert(Universe::is_fully_initialized(), &quot;Need to find another solution to the reflection problem&quot;);
2840   method-&gt;obj_field_put(parameter_annotations_offset, value);
2841 }
2842 
2843 void java_lang_reflect_Method::set_annotation_default(oop method, oop value) {
2844   assert(Universe::is_fully_initialized(), &quot;Need to find another solution to the reflection problem&quot;);
2845   method-&gt;obj_field_put(annotation_default_offset, value);
2846 }
2847 
2848 #define CONSTRUCTOR_FIELDS_DO(macro) \
2849   macro(clazz_offset,          k, vmSymbols::clazz_name(),          class_signature,       false); \
2850   macro(parameterTypes_offset, k, vmSymbols::parameterTypes_name(), class_array_signature, false); \
2851   macro(exceptionTypes_offset, k, vmSymbols::exceptionTypes_name(), class_array_signature, false); \
2852   macro(slot_offset,           k, vmSymbols::slot_name(),           int_signature,         false); \
2853   macro(modifiers_offset,      k, vmSymbols::modifiers_name(),      int_signature,         false); \
2854   macro(signature_offset,             k, vmSymbols::signature_name(),             string_signature,     false); \
2855   macro(annotations_offset,           k, vmSymbols::annotations_name(),           byte_array_signature, false); \
2856   macro(parameter_annotations_offset, k, vmSymbols::parameter_annotations_name(), byte_array_signature, false);
2857 
2858 void java_lang_reflect_Constructor::compute_offsets() {
2859   InstanceKlass* k = SystemDictionary::reflect_Constructor_klass();
2860   CONSTRUCTOR_FIELDS_DO(FIELD_COMPUTE_OFFSET);
2861 }
2862 
2863 #if INCLUDE_CDS
2864 void java_lang_reflect_Constructor::serialize_offsets(SerializeClosure* f) {
2865   CONSTRUCTOR_FIELDS_DO(FIELD_SERIALIZE_OFFSET);
2866 }
2867 #endif
2868 
2869 Handle java_lang_reflect_Constructor::create(TRAPS) {
2870   assert(Universe::is_fully_initialized(), &quot;Need to find another solution to the reflection problem&quot;);
2871   Symbol* name = vmSymbols::java_lang_reflect_Constructor();
2872   Klass* k = SystemDictionary::resolve_or_fail(name, true, CHECK_NH);
2873   InstanceKlass* ik = InstanceKlass::cast(k);
2874   // Ensure it is initialized
2875   ik-&gt;initialize(CHECK_NH);
2876   return ik-&gt;allocate_instance_handle(THREAD);
2877 }
2878 
2879 oop java_lang_reflect_Constructor::clazz(oop reflect) {
2880   assert(Universe::is_fully_initialized(), &quot;Need to find another solution to the reflection problem&quot;);
2881   return reflect-&gt;obj_field(clazz_offset);
2882 }
2883 
2884 void java_lang_reflect_Constructor::set_clazz(oop reflect, oop value) {
2885   assert(Universe::is_fully_initialized(), &quot;Need to find another solution to the reflection problem&quot;);
2886    reflect-&gt;obj_field_put(clazz_offset, value);
2887 }
2888 
2889 oop java_lang_reflect_Constructor::parameter_types(oop constructor) {
2890   assert(Universe::is_fully_initialized(), &quot;Need to find another solution to the reflection problem&quot;);
2891   return constructor-&gt;obj_field(parameterTypes_offset);
2892 }
2893 
2894 void java_lang_reflect_Constructor::set_parameter_types(oop constructor, oop value) {
2895   assert(Universe::is_fully_initialized(), &quot;Need to find another solution to the reflection problem&quot;);
2896   constructor-&gt;obj_field_put(parameterTypes_offset, value);
2897 }
2898 
2899 void java_lang_reflect_Constructor::set_exception_types(oop constructor, oop value) {
2900   assert(Universe::is_fully_initialized(), &quot;Need to find another solution to the reflection problem&quot;);
2901   constructor-&gt;obj_field_put(exceptionTypes_offset, value);
2902 }
2903 
2904 int java_lang_reflect_Constructor::slot(oop reflect) {
2905   assert(Universe::is_fully_initialized(), &quot;Need to find another solution to the reflection problem&quot;);
2906   return reflect-&gt;int_field(slot_offset);
2907 }
2908 
2909 void java_lang_reflect_Constructor::set_slot(oop reflect, int value) {
2910   assert(Universe::is_fully_initialized(), &quot;Need to find another solution to the reflection problem&quot;);
2911   reflect-&gt;int_field_put(slot_offset, value);
2912 }
2913 
2914 void java_lang_reflect_Constructor::set_modifiers(oop constructor, int value) {
2915   assert(Universe::is_fully_initialized(), &quot;Need to find another solution to the reflection problem&quot;);
2916   constructor-&gt;int_field_put(modifiers_offset, value);
2917 }
2918 
2919 void java_lang_reflect_Constructor::set_signature(oop constructor, oop value) {
2920   assert(Universe::is_fully_initialized(), &quot;Need to find another solution to the reflection problem&quot;);
2921   constructor-&gt;obj_field_put(signature_offset, value);
2922 }
2923 
2924 void java_lang_reflect_Constructor::set_annotations(oop constructor, oop value) {
2925   assert(Universe::is_fully_initialized(), &quot;Need to find another solution to the reflection problem&quot;);
2926   constructor-&gt;obj_field_put(annotations_offset, value);
2927 }
2928 
2929 void java_lang_reflect_Constructor::set_parameter_annotations(oop method, oop value) {
2930   assert(Universe::is_fully_initialized(), &quot;Need to find another solution to the reflection problem&quot;);
2931   method-&gt;obj_field_put(parameter_annotations_offset, value);
2932 }
2933 
2934 #define FIELD_FIELDS_DO(macro) \
2935   macro(clazz_offset,     k, vmSymbols::clazz_name(),     class_signature,  false); \
2936   macro(name_offset,      k, vmSymbols::name_name(),      string_signature, false); \
2937   macro(type_offset,      k, vmSymbols::type_name(),      class_signature,  false); \
2938   macro(slot_offset,      k, vmSymbols::slot_name(),      int_signature,    false); \
2939   macro(modifiers_offset, k, vmSymbols::modifiers_name(), int_signature,    false); \
2940   macro(signature_offset,        k, vmSymbols::signature_name(),        string_signature,     false); \
2941   macro(annotations_offset,      k, vmSymbols::annotations_name(),      byte_array_signature, false);
2942 
2943 void java_lang_reflect_Field::compute_offsets() {
2944   InstanceKlass* k = SystemDictionary::reflect_Field_klass();
2945   FIELD_FIELDS_DO(FIELD_COMPUTE_OFFSET);
2946 }
2947 
2948 #if INCLUDE_CDS
2949 void java_lang_reflect_Field::serialize_offsets(SerializeClosure* f) {
2950   FIELD_FIELDS_DO(FIELD_SERIALIZE_OFFSET);
2951 }
2952 #endif
2953 
2954 Handle java_lang_reflect_Field::create(TRAPS) {
2955   assert(Universe::is_fully_initialized(), &quot;Need to find another solution to the reflection problem&quot;);
2956   Symbol* name = vmSymbols::java_lang_reflect_Field();
2957   Klass* k = SystemDictionary::resolve_or_fail(name, true, CHECK_NH);
2958   InstanceKlass* ik = InstanceKlass::cast(k);
2959   // Ensure it is initialized
2960   ik-&gt;initialize(CHECK_NH);
2961   return ik-&gt;allocate_instance_handle(THREAD);
2962 }
2963 
2964 oop java_lang_reflect_Field::clazz(oop reflect) {
2965   assert(Universe::is_fully_initialized(), &quot;Need to find another solution to the reflection problem&quot;);
2966   return reflect-&gt;obj_field(clazz_offset);
2967 }
2968 
2969 void java_lang_reflect_Field::set_clazz(oop reflect, oop value) {
2970   assert(Universe::is_fully_initialized(), &quot;Need to find another solution to the reflection problem&quot;);
2971    reflect-&gt;obj_field_put(clazz_offset, value);
2972 }
2973 
2974 oop java_lang_reflect_Field::name(oop field) {
2975   assert(Universe::is_fully_initialized(), &quot;Need to find another solution to the reflection problem&quot;);
2976   return field-&gt;obj_field(name_offset);
2977 }
2978 
2979 void java_lang_reflect_Field::set_name(oop field, oop value) {
2980   assert(Universe::is_fully_initialized(), &quot;Need to find another solution to the reflection problem&quot;);
2981   field-&gt;obj_field_put(name_offset, value);
2982 }
2983 
2984 oop java_lang_reflect_Field::type(oop field) {
2985   assert(Universe::is_fully_initialized(), &quot;Need to find another solution to the reflection problem&quot;);
2986   return field-&gt;obj_field(type_offset);
2987 }
2988 
2989 void java_lang_reflect_Field::set_type(oop field, oop value) {
2990   assert(Universe::is_fully_initialized(), &quot;Need to find another solution to the reflection problem&quot;);
2991   field-&gt;obj_field_put(type_offset, value);
2992 }
2993 
2994 int java_lang_reflect_Field::slot(oop reflect) {
2995   assert(Universe::is_fully_initialized(), &quot;Need to find another solution to the reflection problem&quot;);
2996   return reflect-&gt;int_field(slot_offset);
2997 }
2998 
2999 void java_lang_reflect_Field::set_slot(oop reflect, int value) {
3000   assert(Universe::is_fully_initialized(), &quot;Need to find another solution to the reflection problem&quot;);
3001   reflect-&gt;int_field_put(slot_offset, value);
3002 }
3003 
3004 int java_lang_reflect_Field::modifiers(oop field) {
3005   assert(Universe::is_fully_initialized(), &quot;Need to find another solution to the reflection problem&quot;);
3006   return field-&gt;int_field(modifiers_offset);
3007 }
3008 
3009 void java_lang_reflect_Field::set_modifiers(oop field, int value) {
3010   assert(Universe::is_fully_initialized(), &quot;Need to find another solution to the reflection problem&quot;);
3011   field-&gt;int_field_put(modifiers_offset, value);
3012 }
3013 
3014 void java_lang_reflect_Field::set_signature(oop field, oop value) {
3015   assert(Universe::is_fully_initialized(), &quot;Need to find another solution to the reflection problem&quot;);
3016   field-&gt;obj_field_put(signature_offset, value);
3017 }
3018 
3019 void java_lang_reflect_Field::set_annotations(oop field, oop value) {
3020   assert(Universe::is_fully_initialized(), &quot;Need to find another solution to the reflection problem&quot;);
3021   field-&gt;obj_field_put(annotations_offset, value);
3022 }
3023 
<a name="79" id="anc79"></a>

























































3024 #define CONSTANTPOOL_FIELDS_DO(macro) \
3025   macro(_oop_offset, k, &quot;constantPoolOop&quot;, object_signature, false)
3026 
3027 void reflect_ConstantPool::compute_offsets() {
3028   InstanceKlass* k = SystemDictionary::reflect_ConstantPool_klass();
3029   // The field is called ConstantPool* in the sun.reflect.ConstantPool class.
3030   CONSTANTPOOL_FIELDS_DO(FIELD_COMPUTE_OFFSET);
3031 }
3032 
3033 #if INCLUDE_CDS
3034 void reflect_ConstantPool::serialize_offsets(SerializeClosure* f) {
3035   CONSTANTPOOL_FIELDS_DO(FIELD_SERIALIZE_OFFSET);
3036 }
3037 #endif
3038 
3039 #define PARAMETER_FIELDS_DO(macro) \
3040   macro(name_offset,        k, vmSymbols::name_name(),        string_signature, false); \
3041   macro(modifiers_offset,   k, vmSymbols::modifiers_name(),   int_signature,    false); \
3042   macro(index_offset,       k, vmSymbols::index_name(),       int_signature,    false); \
3043   macro(executable_offset,  k, vmSymbols::executable_name(),  executable_signature, false)
3044 
3045 void java_lang_reflect_Parameter::compute_offsets() {
3046   InstanceKlass* k = SystemDictionary::reflect_Parameter_klass();
3047   PARAMETER_FIELDS_DO(FIELD_COMPUTE_OFFSET);
3048 }
3049 
3050 #if INCLUDE_CDS
3051 void java_lang_reflect_Parameter::serialize_offsets(SerializeClosure* f) {
3052   PARAMETER_FIELDS_DO(FIELD_SERIALIZE_OFFSET);
3053 }
3054 #endif
3055 
3056 Handle java_lang_reflect_Parameter::create(TRAPS) {
3057   assert(Universe::is_fully_initialized(), &quot;Need to find another solution to the reflection problem&quot;);
3058   Symbol* name = vmSymbols::java_lang_reflect_Parameter();
3059   Klass* k = SystemDictionary::resolve_or_fail(name, true, CHECK_NH);
3060   InstanceKlass* ik = InstanceKlass::cast(k);
3061   // Ensure it is initialized
3062   ik-&gt;initialize(CHECK_NH);
3063   return ik-&gt;allocate_instance_handle(THREAD);
3064 }
3065 
3066 oop java_lang_reflect_Parameter::name(oop param) {
3067   assert(Universe::is_fully_initialized(), &quot;Need to find another solution to the reflection problem&quot;);
3068   return param-&gt;obj_field(name_offset);
3069 }
3070 
3071 void java_lang_reflect_Parameter::set_name(oop param, oop value) {
3072   assert(Universe::is_fully_initialized(), &quot;Need to find another solution to the reflection problem&quot;);
3073   param-&gt;obj_field_put(name_offset, value);
3074 }
3075 
3076 int java_lang_reflect_Parameter::modifiers(oop param) {
3077   assert(Universe::is_fully_initialized(), &quot;Need to find another solution to the reflection problem&quot;);
3078   return param-&gt;int_field(modifiers_offset);
3079 }
3080 
3081 void java_lang_reflect_Parameter::set_modifiers(oop param, int value) {
3082   assert(Universe::is_fully_initialized(), &quot;Need to find another solution to the reflection problem&quot;);
3083   param-&gt;int_field_put(modifiers_offset, value);
3084 }
3085 
3086 int java_lang_reflect_Parameter::index(oop param) {
3087   assert(Universe::is_fully_initialized(), &quot;Need to find another solution to the reflection problem&quot;);
3088   return param-&gt;int_field(index_offset);
3089 }
3090 
3091 void java_lang_reflect_Parameter::set_index(oop param, int value) {
3092   assert(Universe::is_fully_initialized(), &quot;Need to find another solution to the reflection problem&quot;);
3093   param-&gt;int_field_put(index_offset, value);
3094 }
3095 
3096 oop java_lang_reflect_Parameter::executable(oop param) {
3097   assert(Universe::is_fully_initialized(), &quot;Need to find another solution to the reflection problem&quot;);
3098   return param-&gt;obj_field(executable_offset);
3099 }
3100 
3101 void java_lang_reflect_Parameter::set_executable(oop param, oop value) {
3102   assert(Universe::is_fully_initialized(), &quot;Need to find another solution to the reflection problem&quot;);
3103   param-&gt;obj_field_put(executable_offset, value);
3104 }
3105 
3106 
3107 int java_lang_Module::loader_offset;
3108 int java_lang_Module::name_offset;
3109 int java_lang_Module::_module_entry_offset = -1;
3110 
3111 Handle java_lang_Module::create(Handle loader, Handle module_name, TRAPS) {
3112   assert(Universe::is_fully_initialized(), &quot;Need to find another solution to the reflection problem&quot;);
3113   return JavaCalls::construct_new_instance(SystemDictionary::Module_klass(),
3114                           vmSymbols::java_lang_module_init_signature(),
3115                           loader, module_name, CHECK_NH);
3116 }
3117 
3118 #define MODULE_FIELDS_DO(macro) \
3119   macro(loader_offset,  k, vmSymbols::loader_name(),  classloader_signature, false); \
3120   macro(name_offset,    k, vmSymbols::name_name(),    string_signature,      false)
3121 
3122 void java_lang_Module::compute_offsets() {
3123   InstanceKlass* k = SystemDictionary::Module_klass();
3124   MODULE_FIELDS_DO(FIELD_COMPUTE_OFFSET);
3125   MODULE_INJECTED_FIELDS(INJECTED_FIELD_COMPUTE_OFFSET);
3126 }
3127 
3128 #if INCLUDE_CDS
3129 void java_lang_Module::serialize_offsets(SerializeClosure* f) {
3130   MODULE_FIELDS_DO(FIELD_SERIALIZE_OFFSET);
3131   MODULE_INJECTED_FIELDS(INJECTED_FIELD_SERIALIZE_OFFSET);
3132 }
3133 #endif
3134 
3135 oop java_lang_Module::loader(oop module) {
3136   assert(Universe::is_fully_initialized(), &quot;Need to find another solution to the reflection problem&quot;);
3137   return module-&gt;obj_field(loader_offset);
3138 }
3139 
3140 void java_lang_Module::set_loader(oop module, oop value) {
3141   assert(Universe::is_fully_initialized(), &quot;Need to find another solution to the reflection problem&quot;);
3142   module-&gt;obj_field_put(loader_offset, value);
3143 }
3144 
3145 oop java_lang_Module::name(oop module) {
3146   assert(Universe::is_fully_initialized(), &quot;Need to find another solution to the reflection problem&quot;);
3147   return module-&gt;obj_field(name_offset);
3148 }
3149 
3150 void java_lang_Module::set_name(oop module, oop value) {
3151   assert(Universe::is_fully_initialized(), &quot;Need to find another solution to the reflection problem&quot;);
3152   module-&gt;obj_field_put(name_offset, value);
3153 }
3154 
3155 ModuleEntry* java_lang_Module::module_entry(oop module) {
3156   assert(_module_entry_offset != -1, &quot;Uninitialized module_entry_offset&quot;);
3157   assert(module != NULL, &quot;module can&#39;t be null&quot;);
3158   assert(oopDesc::is_oop(module), &quot;module must be oop&quot;);
3159 
3160   ModuleEntry* module_entry = (ModuleEntry*)module-&gt;address_field(_module_entry_offset);
3161   if (module_entry == NULL) {
3162     // If the inject field containing the ModuleEntry* is null then return the
3163     // class loader&#39;s unnamed module.
3164     oop loader = java_lang_Module::loader(module);
3165     Handle h_loader = Handle(Thread::current(), loader);
3166     ClassLoaderData* loader_cld = SystemDictionary::register_loader(h_loader);
3167     return loader_cld-&gt;unnamed_module();
3168   }
3169   return module_entry;
3170 }
3171 
3172 void java_lang_Module::set_module_entry(oop module, ModuleEntry* module_entry) {
3173   assert(_module_entry_offset != -1, &quot;Uninitialized module_entry_offset&quot;);
3174   assert(module != NULL, &quot;module can&#39;t be null&quot;);
3175   assert(oopDesc::is_oop(module), &quot;module must be oop&quot;);
3176   module-&gt;address_field_put(_module_entry_offset, (address)module_entry);
3177 }
3178 
3179 Handle reflect_ConstantPool::create(TRAPS) {
3180   assert(Universe::is_fully_initialized(), &quot;Need to find another solution to the reflection problem&quot;);
3181   InstanceKlass* k = SystemDictionary::reflect_ConstantPool_klass();
3182   // Ensure it is initialized
3183   k-&gt;initialize(CHECK_NH);
3184   return k-&gt;allocate_instance_handle(THREAD);
3185 }
3186 
3187 
3188 void reflect_ConstantPool::set_cp(oop reflect, ConstantPool* value) {
3189   assert(Universe::is_fully_initialized(), &quot;Need to find another solution to the reflection problem&quot;);
3190   oop mirror = value-&gt;pool_holder()-&gt;java_mirror();
3191   // Save the mirror to get back the constant pool.
3192   reflect-&gt;obj_field_put(_oop_offset, mirror);
3193 }
3194 
3195 ConstantPool* reflect_ConstantPool::get_cp(oop reflect) {
3196   assert(Universe::is_fully_initialized(), &quot;Need to find another solution to the reflection problem&quot;);
3197 
3198   oop mirror = reflect-&gt;obj_field(_oop_offset);
3199   Klass* k = java_lang_Class::as_Klass(mirror);
3200   assert(k-&gt;is_instance_klass(), &quot;Must be&quot;);
3201 
3202   // Get the constant pool back from the klass.  Since class redefinition
3203   // merges the new constant pool into the old, this is essentially the
3204   // same constant pool as the original.  If constant pool merging is
3205   // no longer done in the future, this will have to change to save
3206   // the original.
3207   return InstanceKlass::cast(k)-&gt;constants();
3208 }
3209 
3210 #define UNSAFESTATICFIELDACCESSORIMPL_FIELDS_DO(macro) \
3211   macro(_base_offset, k, &quot;base&quot;, object_signature, false)
3212 
3213 void reflect_UnsafeStaticFieldAccessorImpl::compute_offsets() {
3214   InstanceKlass* k = SystemDictionary::reflect_UnsafeStaticFieldAccessorImpl_klass();
3215   UNSAFESTATICFIELDACCESSORIMPL_FIELDS_DO(FIELD_COMPUTE_OFFSET);
3216 }
3217 
3218 #if INCLUDE_CDS
3219 void reflect_UnsafeStaticFieldAccessorImpl::serialize_offsets(SerializeClosure* f) {
3220   UNSAFESTATICFIELDACCESSORIMPL_FIELDS_DO(FIELD_SERIALIZE_OFFSET);
3221 }
3222 #endif
3223 
3224 oop java_lang_boxing_object::initialize_and_allocate(BasicType type, TRAPS) {
3225   Klass* k = SystemDictionary::box_klass(type);
3226   if (k == NULL)  return NULL;
3227   InstanceKlass* ik = InstanceKlass::cast(k);
3228   if (!ik-&gt;is_initialized())  ik-&gt;initialize(CHECK_0);
3229   return ik-&gt;allocate_instance(THREAD);
3230 }
3231 
3232 
3233 oop java_lang_boxing_object::create(BasicType type, jvalue* value, TRAPS) {
3234   oop box = initialize_and_allocate(type, CHECK_0);
3235   if (box == NULL)  return NULL;
3236   switch (type) {
3237     case T_BOOLEAN:
3238       box-&gt;bool_field_put(value_offset, value-&gt;z);
3239       break;
3240     case T_CHAR:
3241       box-&gt;char_field_put(value_offset, value-&gt;c);
3242       break;
3243     case T_FLOAT:
3244       box-&gt;float_field_put(value_offset, value-&gt;f);
3245       break;
3246     case T_DOUBLE:
3247       box-&gt;double_field_put(long_value_offset, value-&gt;d);
3248       break;
3249     case T_BYTE:
3250       box-&gt;byte_field_put(value_offset, value-&gt;b);
3251       break;
3252     case T_SHORT:
3253       box-&gt;short_field_put(value_offset, value-&gt;s);
3254       break;
3255     case T_INT:
3256       box-&gt;int_field_put(value_offset, value-&gt;i);
3257       break;
3258     case T_LONG:
3259       box-&gt;long_field_put(long_value_offset, value-&gt;j);
3260       break;
3261     default:
3262       return NULL;
3263   }
3264   return box;
3265 }
3266 
3267 
3268 BasicType java_lang_boxing_object::basic_type(oop box) {
3269   if (box == NULL)  return T_ILLEGAL;
3270   BasicType type = SystemDictionary::box_klass_type(box-&gt;klass());
3271   if (type == T_OBJECT)         // &#39;unknown&#39; value returned by SD::bkt
3272     return T_ILLEGAL;
3273   return type;
3274 }
3275 
3276 
3277 BasicType java_lang_boxing_object::get_value(oop box, jvalue* value) {
3278   BasicType type = SystemDictionary::box_klass_type(box-&gt;klass());
3279   switch (type) {
3280   case T_BOOLEAN:
3281     value-&gt;z = box-&gt;bool_field(value_offset);
3282     break;
3283   case T_CHAR:
3284     value-&gt;c = box-&gt;char_field(value_offset);
3285     break;
3286   case T_FLOAT:
3287     value-&gt;f = box-&gt;float_field(value_offset);
3288     break;
3289   case T_DOUBLE:
3290     value-&gt;d = box-&gt;double_field(long_value_offset);
3291     break;
3292   case T_BYTE:
3293     value-&gt;b = box-&gt;byte_field(value_offset);
3294     break;
3295   case T_SHORT:
3296     value-&gt;s = box-&gt;short_field(value_offset);
3297     break;
3298   case T_INT:
3299     value-&gt;i = box-&gt;int_field(value_offset);
3300     break;
3301   case T_LONG:
3302     value-&gt;j = box-&gt;long_field(long_value_offset);
3303     break;
3304   default:
3305     return T_ILLEGAL;
3306   } // end switch
3307   return type;
3308 }
3309 
3310 
3311 BasicType java_lang_boxing_object::set_value(oop box, jvalue* value) {
3312   BasicType type = SystemDictionary::box_klass_type(box-&gt;klass());
3313   switch (type) {
3314   case T_BOOLEAN:
3315     box-&gt;bool_field_put(value_offset, value-&gt;z);
3316     break;
3317   case T_CHAR:
3318     box-&gt;char_field_put(value_offset, value-&gt;c);
3319     break;
3320   case T_FLOAT:
3321     box-&gt;float_field_put(value_offset, value-&gt;f);
3322     break;
3323   case T_DOUBLE:
3324     box-&gt;double_field_put(long_value_offset, value-&gt;d);
3325     break;
3326   case T_BYTE:
3327     box-&gt;byte_field_put(value_offset, value-&gt;b);
3328     break;
3329   case T_SHORT:
3330     box-&gt;short_field_put(value_offset, value-&gt;s);
3331     break;
3332   case T_INT:
3333     box-&gt;int_field_put(value_offset, value-&gt;i);
3334     break;
3335   case T_LONG:
3336     box-&gt;long_field_put(long_value_offset, value-&gt;j);
3337     break;
3338   default:
3339     return T_ILLEGAL;
3340   } // end switch
3341   return type;
3342 }
3343 
3344 
3345 void java_lang_boxing_object::print(BasicType type, jvalue* value, outputStream* st) {
3346   switch (type) {
3347   case T_BOOLEAN:   st-&gt;print(&quot;%s&quot;, value-&gt;z ? &quot;true&quot; : &quot;false&quot;);   break;
3348   case T_CHAR:      st-&gt;print(&quot;%d&quot;, value-&gt;c);                      break;
3349   case T_BYTE:      st-&gt;print(&quot;%d&quot;, value-&gt;b);                      break;
3350   case T_SHORT:     st-&gt;print(&quot;%d&quot;, value-&gt;s);                      break;
3351   case T_INT:       st-&gt;print(&quot;%d&quot;, value-&gt;i);                      break;
3352   case T_LONG:      st-&gt;print(JLONG_FORMAT, value-&gt;j);              break;
3353   case T_FLOAT:     st-&gt;print(&quot;%f&quot;, value-&gt;f);                      break;
3354   case T_DOUBLE:    st-&gt;print(&quot;%lf&quot;, value-&gt;d);                     break;
3355   default:          st-&gt;print(&quot;type %d?&quot;, type);                    break;
3356   }
3357 }
3358 
3359 // Support for java_lang_ref_Reference
3360 
3361 bool java_lang_ref_Reference::is_referent_field(oop obj, ptrdiff_t offset) {
3362   assert(obj != NULL, &quot;sanity&quot;);
3363   if (offset != java_lang_ref_Reference::referent_offset) {
3364     return false;
3365   }
3366 
3367   Klass* k = obj-&gt;klass();
3368   if (!k-&gt;is_instance_klass()) {
3369     return false;
3370   }
3371 
3372   InstanceKlass* ik = InstanceKlass::cast(obj-&gt;klass());
3373   bool is_reference = ik-&gt;reference_type() != REF_NONE;
3374   assert(!is_reference || ik-&gt;is_subclass_of(SystemDictionary::Reference_klass()), &quot;sanity&quot;);
3375   return is_reference;
3376 }
3377 
3378 // Support for java_lang_ref_SoftReference
3379 //
3380 
3381 #define SOFTREFERENCE_FIELDS_DO(macro) \
3382   macro(timestamp_offset,    k, &quot;timestamp&quot;, long_signature, false); \
3383   macro(static_clock_offset, k, &quot;clock&quot;,     long_signature, true)
3384 
3385 void java_lang_ref_SoftReference::compute_offsets() {
3386   InstanceKlass* k = SystemDictionary::SoftReference_klass();
3387   SOFTREFERENCE_FIELDS_DO(FIELD_COMPUTE_OFFSET);
3388 }
3389 
3390 #if INCLUDE_CDS
3391 void java_lang_ref_SoftReference::serialize_offsets(SerializeClosure* f) {
3392   SOFTREFERENCE_FIELDS_DO(FIELD_SERIALIZE_OFFSET);
3393 }
3394 #endif
3395 
3396 jlong java_lang_ref_SoftReference::timestamp(oop ref) {
3397   return ref-&gt;long_field(timestamp_offset);
3398 }
3399 
3400 jlong java_lang_ref_SoftReference::clock() {
3401   InstanceKlass* ik = SystemDictionary::SoftReference_klass();
3402   oop base = ik-&gt;static_field_base_raw();
3403   return base-&gt;long_field(static_clock_offset);
3404 }
3405 
3406 void java_lang_ref_SoftReference::set_clock(jlong value) {
3407   InstanceKlass* ik = SystemDictionary::SoftReference_klass();
3408   oop base = ik-&gt;static_field_base_raw();
3409   base-&gt;long_field_put(static_clock_offset, value);
3410 }
3411 
3412 // Support for java_lang_invoke_DirectMethodHandle
3413 
3414 int java_lang_invoke_DirectMethodHandle::_member_offset;
3415 
3416 oop java_lang_invoke_DirectMethodHandle::member(oop dmh) {
3417   oop member_name = NULL;
3418   assert(oopDesc::is_oop(dmh) &amp;&amp; java_lang_invoke_DirectMethodHandle::is_instance(dmh),
3419          &quot;a DirectMethodHandle oop is expected&quot;);
3420   return dmh-&gt;obj_field(member_offset_in_bytes());
3421 }
3422 
3423 #define DIRECTMETHODHANDLE_FIELDS_DO(macro) \
3424   macro(_member_offset, k, &quot;member&quot;, java_lang_invoke_MemberName_signature, false)
3425 
3426 void java_lang_invoke_DirectMethodHandle::compute_offsets() {
3427   InstanceKlass* k = SystemDictionary::DirectMethodHandle_klass();
3428   DIRECTMETHODHANDLE_FIELDS_DO(FIELD_COMPUTE_OFFSET);
3429 }
3430 
3431 #if INCLUDE_CDS
3432 void java_lang_invoke_DirectMethodHandle::serialize_offsets(SerializeClosure* f) {
3433   DIRECTMETHODHANDLE_FIELDS_DO(FIELD_SERIALIZE_OFFSET);
3434 }
3435 #endif
3436 
3437 // Support for java_lang_invoke_MethodHandle
3438 
3439 int java_lang_invoke_MethodHandle::_type_offset;
3440 int java_lang_invoke_MethodHandle::_form_offset;
3441 
3442 int java_lang_invoke_MemberName::_clazz_offset;
3443 int java_lang_invoke_MemberName::_name_offset;
3444 int java_lang_invoke_MemberName::_type_offset;
3445 int java_lang_invoke_MemberName::_flags_offset;
3446 int java_lang_invoke_MemberName::_method_offset;
3447 int java_lang_invoke_MemberName::_vmindex_offset;
3448 
3449 int java_lang_invoke_ResolvedMethodName::_vmtarget_offset;
3450 int java_lang_invoke_ResolvedMethodName::_vmholder_offset;
3451 
3452 int java_lang_invoke_LambdaForm::_vmentry_offset;
3453 
3454 #define METHODHANDLE_FIELDS_DO(macro) \
3455   macro(_type_offset, k, vmSymbols::type_name(), java_lang_invoke_MethodType_signature, false); \
3456   macro(_form_offset, k, &quot;form&quot;,                 java_lang_invoke_LambdaForm_signature, false)
3457 
3458 void java_lang_invoke_MethodHandle::compute_offsets() {
3459   InstanceKlass* k = SystemDictionary::MethodHandle_klass();
3460   METHODHANDLE_FIELDS_DO(FIELD_COMPUTE_OFFSET);
3461 }
3462 
3463 #if INCLUDE_CDS
3464 void java_lang_invoke_MethodHandle::serialize_offsets(SerializeClosure* f) {
3465   METHODHANDLE_FIELDS_DO(FIELD_SERIALIZE_OFFSET);
3466 }
3467 #endif
3468 
3469 #define MEMBERNAME_FIELDS_DO(macro) \
3470   macro(_clazz_offset,   k, vmSymbols::clazz_name(),   class_signature,  false); \
3471   macro(_name_offset,    k, vmSymbols::name_name(),    string_signature, false); \
3472   macro(_type_offset,    k, vmSymbols::type_name(),    object_signature, false); \
3473   macro(_flags_offset,   k, vmSymbols::flags_name(),   int_signature,    false); \
3474   macro(_method_offset,  k, vmSymbols::method_name(),  java_lang_invoke_ResolvedMethodName_signature, false)
3475 
3476 void java_lang_invoke_MemberName::compute_offsets() {
3477   InstanceKlass* k = SystemDictionary::MemberName_klass();
3478   MEMBERNAME_FIELDS_DO(FIELD_COMPUTE_OFFSET);
3479   MEMBERNAME_INJECTED_FIELDS(INJECTED_FIELD_COMPUTE_OFFSET);
3480 }
3481 
3482 #if INCLUDE_CDS
3483 void java_lang_invoke_MemberName::serialize_offsets(SerializeClosure* f) {
3484   MEMBERNAME_FIELDS_DO(FIELD_SERIALIZE_OFFSET);
3485   MEMBERNAME_INJECTED_FIELDS(INJECTED_FIELD_SERIALIZE_OFFSET);
3486 }
3487 #endif
3488 
3489 void java_lang_invoke_ResolvedMethodName::compute_offsets() {
3490   InstanceKlass* k = SystemDictionary::ResolvedMethodName_klass();
3491   assert(k != NULL, &quot;jdk mismatch&quot;);
3492   RESOLVEDMETHOD_INJECTED_FIELDS(INJECTED_FIELD_COMPUTE_OFFSET);
3493 }
3494 
3495 #if INCLUDE_CDS
3496 void java_lang_invoke_ResolvedMethodName::serialize_offsets(SerializeClosure* f) {
3497   RESOLVEDMETHOD_INJECTED_FIELDS(INJECTED_FIELD_SERIALIZE_OFFSET);
3498 }
3499 #endif
3500 
3501 #define LAMBDAFORM_FIELDS_DO(macro) \
3502   macro(_vmentry_offset, k, &quot;vmentry&quot;, java_lang_invoke_MemberName_signature, false)
3503 
3504 void java_lang_invoke_LambdaForm::compute_offsets() {
3505   InstanceKlass* k = SystemDictionary::LambdaForm_klass();
3506   assert (k != NULL, &quot;jdk mismatch&quot;);
3507   LAMBDAFORM_FIELDS_DO(FIELD_COMPUTE_OFFSET);
3508 }
3509 
3510 #if INCLUDE_CDS
3511 void java_lang_invoke_LambdaForm::serialize_offsets(SerializeClosure* f) {
3512   LAMBDAFORM_FIELDS_DO(FIELD_SERIALIZE_OFFSET);
3513 }
3514 #endif
3515 
3516 bool java_lang_invoke_LambdaForm::is_instance(oop obj) {
3517   return obj != NULL &amp;&amp; is_subclass(obj-&gt;klass());
3518 }
3519 
3520 
3521 oop java_lang_invoke_MethodHandle::type(oop mh) {
3522   return mh-&gt;obj_field(_type_offset);
3523 }
3524 
3525 void java_lang_invoke_MethodHandle::set_type(oop mh, oop mtype) {
3526   mh-&gt;obj_field_put(_type_offset, mtype);
3527 }
3528 
3529 oop java_lang_invoke_MethodHandle::form(oop mh) {
3530   assert(_form_offset != 0, &quot;&quot;);
3531   return mh-&gt;obj_field(_form_offset);
3532 }
3533 
3534 void java_lang_invoke_MethodHandle::set_form(oop mh, oop lform) {
3535   assert(_form_offset != 0, &quot;&quot;);
3536   mh-&gt;obj_field_put(_form_offset, lform);
3537 }
3538 
3539 /// MemberName accessors
3540 
3541 oop java_lang_invoke_MemberName::clazz(oop mname) {
3542   assert(is_instance(mname), &quot;wrong type&quot;);
3543   return mname-&gt;obj_field(_clazz_offset);
3544 }
3545 
3546 void java_lang_invoke_MemberName::set_clazz(oop mname, oop clazz) {
3547   assert(is_instance(mname), &quot;wrong type&quot;);
3548   mname-&gt;obj_field_put(_clazz_offset, clazz);
3549 }
3550 
3551 oop java_lang_invoke_MemberName::name(oop mname) {
3552   assert(is_instance(mname), &quot;wrong type&quot;);
3553   return mname-&gt;obj_field(_name_offset);
3554 }
3555 
3556 void java_lang_invoke_MemberName::set_name(oop mname, oop name) {
3557   assert(is_instance(mname), &quot;wrong type&quot;);
3558   mname-&gt;obj_field_put(_name_offset, name);
3559 }
3560 
3561 oop java_lang_invoke_MemberName::type(oop mname) {
3562   assert(is_instance(mname), &quot;wrong type&quot;);
3563   return mname-&gt;obj_field(_type_offset);
3564 }
3565 
3566 void java_lang_invoke_MemberName::set_type(oop mname, oop type) {
3567   assert(is_instance(mname), &quot;wrong type&quot;);
3568   mname-&gt;obj_field_put(_type_offset, type);
3569 }
3570 
3571 int java_lang_invoke_MemberName::flags(oop mname) {
3572   assert(is_instance(mname), &quot;wrong type&quot;);
3573   return mname-&gt;int_field(_flags_offset);
3574 }
3575 
3576 void java_lang_invoke_MemberName::set_flags(oop mname, int flags) {
3577   assert(is_instance(mname), &quot;wrong type&quot;);
3578   mname-&gt;int_field_put(_flags_offset, flags);
3579 }
3580 
3581 
3582 // Return vmtarget from ResolvedMethodName method field through indirection
3583 Method* java_lang_invoke_MemberName::vmtarget(oop mname) {
3584   assert(is_instance(mname), &quot;wrong type&quot;);
3585   oop method = mname-&gt;obj_field(_method_offset);
3586   return method == NULL ? NULL : java_lang_invoke_ResolvedMethodName::vmtarget(method);
3587 }
3588 
3589 bool java_lang_invoke_MemberName::is_method(oop mname) {
3590   assert(is_instance(mname), &quot;must be MemberName&quot;);
3591   return (flags(mname) &amp; (MN_IS_METHOD | MN_IS_CONSTRUCTOR)) &gt; 0;
3592 }
3593 
3594 void java_lang_invoke_MemberName::set_method(oop mname, oop resolved_method) {
3595   assert(is_instance(mname), &quot;wrong type&quot;);
3596   mname-&gt;obj_field_put(_method_offset, resolved_method);
3597 }
3598 
3599 intptr_t java_lang_invoke_MemberName::vmindex(oop mname) {
3600   assert(is_instance(mname), &quot;wrong type&quot;);
3601   return (intptr_t) mname-&gt;address_field(_vmindex_offset);
3602 }
3603 
3604 void java_lang_invoke_MemberName::set_vmindex(oop mname, intptr_t index) {
3605   assert(is_instance(mname), &quot;wrong type&quot;);
3606   mname-&gt;address_field_put(_vmindex_offset, (address) index);
3607 }
3608 
3609 
3610 Method* java_lang_invoke_ResolvedMethodName::vmtarget(oop resolved_method) {
3611   assert(is_instance(resolved_method), &quot;wrong type&quot;);
3612   Method* m = (Method*)resolved_method-&gt;address_field(_vmtarget_offset);
3613   assert(m-&gt;is_method(), &quot;must be&quot;);
3614   return m;
3615 }
3616 
3617 // Used by redefinition to change Method* to new Method* with same hash (name, signature)
3618 void java_lang_invoke_ResolvedMethodName::set_vmtarget(oop resolved_method, Method* m) {
3619   assert(is_instance(resolved_method), &quot;wrong type&quot;);
3620   resolved_method-&gt;address_field_put(_vmtarget_offset, (address)m);
3621 }
3622 
<a name="80" id="anc80"></a>




3623 oop java_lang_invoke_ResolvedMethodName::find_resolved_method(const methodHandle&amp; m, TRAPS) {
<a name="81" id="anc81"></a>

3624   // lookup ResolvedMethod oop in the table, or create a new one and intern it
<a name="82" id="anc82"></a><span class="line-modified">3625   oop resolved_method = ResolvedMethodTable::find_method(m());</span>
<span class="line-modified">3626   if (resolved_method == NULL) {</span>
<span class="line-modified">3627     InstanceKlass* k = SystemDictionary::ResolvedMethodName_klass();</span>
<span class="line-removed">3628     if (!k-&gt;is_initialized()) {</span>
<span class="line-removed">3629       k-&gt;initialize(CHECK_NULL);</span>
<span class="line-removed">3630     }</span>
<span class="line-removed">3631     oop new_resolved_method = k-&gt;allocate_instance(CHECK_NULL);</span>
<span class="line-removed">3632     new_resolved_method-&gt;address_field_put(_vmtarget_offset, (address)m());</span>
<span class="line-removed">3633     // Add a reference to the loader (actually mirror because unsafe anonymous classes will not have</span>
<span class="line-removed">3634     // distinct loaders) to ensure the metadata is kept alive.</span>
<span class="line-removed">3635     // This mirror may be different than the one in clazz field.</span>
<span class="line-removed">3636     new_resolved_method-&gt;obj_field_put(_vmholder_offset, m-&gt;method_holder()-&gt;java_mirror());</span>
<span class="line-removed">3637     resolved_method = ResolvedMethodTable::add_method(m, Handle(THREAD, new_resolved_method));</span>
3638   }
<a name="83" id="anc83"></a><span class="line-modified">3639   return resolved_method;</span>




























3640 }
3641 
3642 oop java_lang_invoke_LambdaForm::vmentry(oop lform) {
3643   assert(is_instance(lform), &quot;wrong type&quot;);
3644   return lform-&gt;obj_field(_vmentry_offset);
3645 }
3646 
3647 
3648 // Support for java_lang_invoke_MethodType
3649 
3650 int java_lang_invoke_MethodType::_rtype_offset;
3651 int java_lang_invoke_MethodType::_ptypes_offset;
3652 
3653 #define METHODTYPE_FIELDS_DO(macro) \
3654   macro(_rtype_offset,  k, &quot;rtype&quot;,  class_signature,       false); \
3655   macro(_ptypes_offset, k, &quot;ptypes&quot;, class_array_signature, false)
3656 
3657 void java_lang_invoke_MethodType::compute_offsets() {
3658   InstanceKlass* k = SystemDictionary::MethodType_klass();
3659   METHODTYPE_FIELDS_DO(FIELD_COMPUTE_OFFSET);
3660 }
3661 
3662 #if INCLUDE_CDS
3663 void java_lang_invoke_MethodType::serialize_offsets(SerializeClosure* f) {
3664   METHODTYPE_FIELDS_DO(FIELD_SERIALIZE_OFFSET);
3665 }
3666 #endif
3667 
3668 void java_lang_invoke_MethodType::print_signature(oop mt, outputStream* st) {
3669   st-&gt;print(&quot;(&quot;);
3670   objArrayOop pts = ptypes(mt);
3671   for (int i = 0, limit = pts-&gt;length(); i &lt; limit; i++) {
3672     java_lang_Class::print_signature(pts-&gt;obj_at(i), st);
3673   }
3674   st-&gt;print(&quot;)&quot;);
3675   java_lang_Class::print_signature(rtype(mt), st);
3676 }
3677 
<a name="84" id="anc84"></a><span class="line-modified">3678 Symbol* java_lang_invoke_MethodType::as_signature(oop mt, bool intern_if_not_found, TRAPS) {</span>
3679   ResourceMark rm;
3680   stringStream buffer(128);
3681   print_signature(mt, &amp;buffer);
3682   const char* sigstr =       buffer.base();
3683   int         siglen = (int) buffer.size();
3684   Symbol *name;
3685   if (!intern_if_not_found) {
3686     name = SymbolTable::probe(sigstr, siglen);
3687   } else {
<a name="85" id="anc85"></a><span class="line-modified">3688     name = SymbolTable::new_symbol(sigstr, siglen, THREAD);</span>
3689   }
3690   return name;
3691 }
3692 
3693 bool java_lang_invoke_MethodType::equals(oop mt1, oop mt2) {
<a name="86" id="anc86"></a><span class="line-modified">3694   if (oopDesc::equals(mt1, mt2))</span>
3695     return true;
<a name="87" id="anc87"></a><span class="line-modified">3696   if (!oopDesc::equals(rtype(mt1), rtype(mt2)))</span>
3697     return false;
3698   if (ptype_count(mt1) != ptype_count(mt2))
3699     return false;
3700   for (int i = ptype_count(mt1) - 1; i &gt;= 0; i--) {
<a name="88" id="anc88"></a><span class="line-modified">3701     if (!oopDesc::equals(ptype(mt1, i), ptype(mt2, i)))</span>
3702       return false;
3703   }
3704   return true;
3705 }
3706 
3707 oop java_lang_invoke_MethodType::rtype(oop mt) {
3708   assert(is_instance(mt), &quot;must be a MethodType&quot;);
3709   return mt-&gt;obj_field(_rtype_offset);
3710 }
3711 
3712 objArrayOop java_lang_invoke_MethodType::ptypes(oop mt) {
3713   assert(is_instance(mt), &quot;must be a MethodType&quot;);
3714   return (objArrayOop) mt-&gt;obj_field(_ptypes_offset);
3715 }
3716 
3717 oop java_lang_invoke_MethodType::ptype(oop mt, int idx) {
3718   return ptypes(mt)-&gt;obj_at(idx);
3719 }
3720 
3721 int java_lang_invoke_MethodType::ptype_count(oop mt) {
3722   return ptypes(mt)-&gt;length();
3723 }
3724 
3725 int java_lang_invoke_MethodType::ptype_slot_count(oop mt) {
3726   objArrayOop pts = ptypes(mt);
3727   int count = pts-&gt;length();
3728   int slots = 0;
3729   for (int i = 0; i &lt; count; i++) {
3730     BasicType bt = java_lang_Class::as_BasicType(pts-&gt;obj_at(i));
3731     slots += type2size[bt];
3732   }
3733   return slots;
3734 }
3735 
3736 int java_lang_invoke_MethodType::rtype_slot_count(oop mt) {
3737   BasicType bt = java_lang_Class::as_BasicType(rtype(mt));
3738   return type2size[bt];
3739 }
3740 
3741 
3742 // Support for java_lang_invoke_CallSite
3743 
3744 int java_lang_invoke_CallSite::_target_offset;
3745 int java_lang_invoke_CallSite::_context_offset;
3746 
3747 #define CALLSITE_FIELDS_DO(macro) \
3748   macro(_target_offset,  k, &quot;target&quot;, java_lang_invoke_MethodHandle_signature, false); \
3749   macro(_context_offset, k, &quot;context&quot;, java_lang_invoke_MethodHandleNatives_CallSiteContext_signature, false)
3750 
3751 void java_lang_invoke_CallSite::compute_offsets() {
3752   InstanceKlass* k = SystemDictionary::CallSite_klass();
3753   CALLSITE_FIELDS_DO(FIELD_COMPUTE_OFFSET);
3754 }
3755 
3756 #if INCLUDE_CDS
3757 void java_lang_invoke_CallSite::serialize_offsets(SerializeClosure* f) {
3758   CALLSITE_FIELDS_DO(FIELD_SERIALIZE_OFFSET);
3759 }
3760 #endif
3761 
3762 oop java_lang_invoke_CallSite::context_no_keepalive(oop call_site) {
3763   assert(java_lang_invoke_CallSite::is_instance(call_site), &quot;&quot;);
3764 
3765   oop dep_oop = call_site-&gt;obj_field_access&lt;AS_NO_KEEPALIVE&gt;(_context_offset);
3766   return dep_oop;
3767 }
3768 
<a name="89" id="anc89"></a>

















3769 // Support for java_lang_invoke_MethodHandleNatives_CallSiteContext
3770 
3771 int java_lang_invoke_MethodHandleNatives_CallSiteContext::_vmdependencies_offset;
3772 int java_lang_invoke_MethodHandleNatives_CallSiteContext::_last_cleanup_offset;
3773 
3774 void java_lang_invoke_MethodHandleNatives_CallSiteContext::compute_offsets() {
3775   InstanceKlass* k = SystemDictionary::Context_klass();
3776   CALLSITECONTEXT_INJECTED_FIELDS(INJECTED_FIELD_COMPUTE_OFFSET);
3777 }
3778 
3779 #if INCLUDE_CDS
3780 void java_lang_invoke_MethodHandleNatives_CallSiteContext::serialize_offsets(SerializeClosure* f) {
3781   CALLSITECONTEXT_INJECTED_FIELDS(INJECTED_FIELD_SERIALIZE_OFFSET);
3782 }
3783 #endif
3784 
3785 DependencyContext java_lang_invoke_MethodHandleNatives_CallSiteContext::vmdependencies(oop call_site) {
3786   assert(java_lang_invoke_MethodHandleNatives_CallSiteContext::is_instance(call_site), &quot;&quot;);
3787   nmethodBucket* volatile* vmdeps_addr = (nmethodBucket* volatile*)call_site-&gt;field_addr(_vmdependencies_offset);
3788   volatile uint64_t* last_cleanup_addr = (volatile uint64_t*)call_site-&gt;field_addr(_last_cleanup_offset);
3789   DependencyContext dep_ctx(vmdeps_addr, last_cleanup_addr);
3790   return dep_ctx;
3791 }
3792 
3793 // Support for java_security_AccessControlContext
3794 
3795 int java_security_AccessControlContext::_context_offset = 0;
3796 int java_security_AccessControlContext::_privilegedContext_offset = 0;
3797 int java_security_AccessControlContext::_isPrivileged_offset = 0;
3798 int java_security_AccessControlContext::_isAuthorized_offset = -1;
3799 
3800 #define ACCESSCONTROLCONTEXT_FIELDS_DO(macro) \
3801   macro(_context_offset,           k, &quot;context&quot;,      protectiondomain_signature, false); \
3802   macro(_privilegedContext_offset, k, &quot;privilegedContext&quot;, accesscontrolcontext_signature, false); \
3803   macro(_isPrivileged_offset,      k, &quot;isPrivileged&quot;, bool_signature, false); \
3804   macro(_isAuthorized_offset,      k, &quot;isAuthorized&quot;, bool_signature, false)
3805 
3806 void java_security_AccessControlContext::compute_offsets() {
3807   assert(_isPrivileged_offset == 0, &quot;offsets should be initialized only once&quot;);
3808   InstanceKlass* k = SystemDictionary::AccessControlContext_klass();
3809   ACCESSCONTROLCONTEXT_FIELDS_DO(FIELD_COMPUTE_OFFSET);
3810 }
3811 
3812 #if INCLUDE_CDS
3813 void java_security_AccessControlContext::serialize_offsets(SerializeClosure* f) {
3814   ACCESSCONTROLCONTEXT_FIELDS_DO(FIELD_SERIALIZE_OFFSET);
3815 }
3816 #endif
3817 
3818 oop java_security_AccessControlContext::create(objArrayHandle context, bool isPrivileged, Handle privileged_context, TRAPS) {
3819   assert(_isPrivileged_offset != 0, &quot;offsets should have been initialized&quot;);
<a name="90" id="anc90"></a>
3820   // Ensure klass is initialized
3821   SystemDictionary::AccessControlContext_klass()-&gt;initialize(CHECK_0);
3822   // Allocate result
3823   oop result = SystemDictionary::AccessControlContext_klass()-&gt;allocate_instance(CHECK_0);
3824   // Fill in values
3825   result-&gt;obj_field_put(_context_offset, context());
3826   result-&gt;obj_field_put(_privilegedContext_offset, privileged_context());
3827   result-&gt;bool_field_put(_isPrivileged_offset, isPrivileged);
<a name="91" id="anc91"></a><span class="line-modified">3828   // whitelist AccessControlContexts created by the JVM if present</span>
<span class="line-modified">3829   if (_isAuthorized_offset != -1) {</span>
<span class="line-removed">3830     result-&gt;bool_field_put(_isAuthorized_offset, true);</span>
<span class="line-removed">3831   }</span>
3832   return result;
3833 }
3834 
3835 
3836 // Support for java_lang_ClassLoader
3837 
3838 bool java_lang_ClassLoader::offsets_computed = false;
3839 int  java_lang_ClassLoader::_loader_data_offset = -1;
3840 int  java_lang_ClassLoader::parallelCapable_offset = -1;
3841 int  java_lang_ClassLoader::name_offset = -1;
3842 int  java_lang_ClassLoader::nameAndId_offset = -1;
3843 int  java_lang_ClassLoader::unnamedModule_offset = -1;
3844 
3845 ClassLoaderData* java_lang_ClassLoader::loader_data_acquire(oop loader) {
<a name="92" id="anc92"></a><span class="line-modified">3846   assert(loader != NULL &amp;&amp; oopDesc::is_oop(loader), &quot;loader must be oop&quot;);</span>

3847   return HeapAccess&lt;MO_ACQUIRE&gt;::load_at(loader, _loader_data_offset);
3848 }
3849 
3850 ClassLoaderData* java_lang_ClassLoader::loader_data_raw(oop loader) {
<a name="93" id="anc93"></a><span class="line-modified">3851   assert(loader != NULL &amp;&amp; oopDesc::is_oop(loader), &quot;loader must be oop&quot;);</span>

3852   return RawAccess&lt;&gt;::load_at(loader, _loader_data_offset);
3853 }
3854 
3855 void java_lang_ClassLoader::release_set_loader_data(oop loader, ClassLoaderData* new_data) {
<a name="94" id="anc94"></a><span class="line-modified">3856   assert(loader != NULL &amp;&amp; oopDesc::is_oop(loader), &quot;loader must be oop&quot;);</span>

3857   HeapAccess&lt;MO_RELEASE&gt;::store_at(loader, _loader_data_offset, new_data);
3858 }
3859 
3860 #define CLASSLOADER_FIELDS_DO(macro) \
3861   macro(parallelCapable_offset, k1, &quot;parallelLockMap&quot;,      concurrenthashmap_signature, false); \
3862   macro(name_offset,            k1, vmSymbols::name_name(), string_signature, false); \
3863   macro(nameAndId_offset,       k1, &quot;nameAndId&quot;,            string_signature, false); \
3864   macro(unnamedModule_offset,   k1, &quot;unnamedModule&quot;,        module_signature, false); \
3865   macro(parent_offset,          k1, &quot;parent&quot;,               classloader_signature, false)
3866 
3867 void java_lang_ClassLoader::compute_offsets() {
3868   assert(!offsets_computed, &quot;offsets should be initialized only once&quot;);
3869   offsets_computed = true;
3870 
3871   InstanceKlass* k1 = SystemDictionary::ClassLoader_klass();
3872   CLASSLOADER_FIELDS_DO(FIELD_COMPUTE_OFFSET);
3873 
3874   CLASSLOADER_INJECTED_FIELDS(INJECTED_FIELD_COMPUTE_OFFSET);
3875 }
3876 
3877 #if INCLUDE_CDS
3878 void java_lang_ClassLoader::serialize_offsets(SerializeClosure* f) {
3879   CLASSLOADER_FIELDS_DO(FIELD_SERIALIZE_OFFSET);
3880   CLASSLOADER_INJECTED_FIELDS(INJECTED_FIELD_SERIALIZE_OFFSET);
3881 }
3882 #endif
3883 
3884 oop java_lang_ClassLoader::parent(oop loader) {
3885   assert(is_instance(loader), &quot;loader must be oop&quot;);
3886   return loader-&gt;obj_field(parent_offset);
3887 }
3888 
3889 // Returns the name field of this class loader.  If the name field has not
3890 // been set, null will be returned.
3891 oop java_lang_ClassLoader::name(oop loader) {
3892   assert(is_instance(loader), &quot;loader must be oop&quot;);
3893   return loader-&gt;obj_field(name_offset);
3894 }
3895 
3896 // Returns the nameAndId field of this class loader. The format is
3897 // as follows:
3898 //   If the defining loader has a name explicitly set then &#39;&lt;loader-name&gt;&#39; @&lt;id&gt;
3899 //   If the defining loader has no name then &lt;qualified-class-name&gt; @&lt;id&gt;
3900 //   If built-in loader, then omit &#39;@&lt;id&gt;&#39; as there is only one instance.
3901 // Use ClassLoader::loader_name_id() to obtain this String as a char*.
3902 oop java_lang_ClassLoader::nameAndId(oop loader) {
3903   assert(is_instance(loader), &quot;loader must be oop&quot;);
3904   return loader-&gt;obj_field(nameAndId_offset);
3905 }
3906 
3907 bool java_lang_ClassLoader::isAncestor(oop loader, oop cl) {
3908   assert(is_instance(loader), &quot;loader must be oop&quot;);
3909   assert(cl == NULL || is_instance(cl), &quot;cl argument must be oop&quot;);
3910   oop acl = loader;
3911   debug_only(jint loop_count = 0);
3912   // This loop taken verbatim from ClassLoader.java:
3913   do {
3914     acl = parent(acl);
<a name="95" id="anc95"></a><span class="line-modified">3915     if (oopDesc::equals(cl, acl)) {</span>
3916       return true;
3917     }
3918     assert(++loop_count &gt; 0, &quot;loop_count overflow&quot;);
3919   } while (acl != NULL);
3920   return false;
3921 }
3922 
3923 bool java_lang_ClassLoader::is_instance(oop obj) {
3924   return obj != NULL &amp;&amp; is_subclass(obj-&gt;klass());
3925 }
3926 
3927 
3928 // For class loader classes, parallelCapable defined
3929 // based on non-null field
3930 // Written to by java.lang.ClassLoader, vm only reads this field, doesn&#39;t set it
3931 bool java_lang_ClassLoader::parallelCapable(oop class_loader) {
<a name="96" id="anc96"></a><span class="line-modified">3932   if (parallelCapable_offset == -1) {</span>
<span class="line-removed">3933      // Default for backward compatibility is false</span>
<span class="line-removed">3934      return false;</span>
<span class="line-removed">3935   }</span>
3936   return (class_loader-&gt;obj_field(parallelCapable_offset) != NULL);
3937 }
3938 
3939 bool java_lang_ClassLoader::is_trusted_loader(oop loader) {
3940   // Fix for 4474172; see evaluation for more details
3941   loader = non_reflection_class_loader(loader);
3942 
3943   oop cl = SystemDictionary::java_system_loader();
3944   while(cl != NULL) {
<a name="97" id="anc97"></a><span class="line-modified">3945     if (oopDesc::equals(cl, loader)) return true;</span>
3946     cl = parent(cl);
3947   }
3948   return false;
3949 }
3950 
3951 // Return true if this is one of the class loaders associated with
3952 // the generated bytecodes for reflection.
3953 bool java_lang_ClassLoader::is_reflection_class_loader(oop loader) {
3954   if (loader != NULL) {
3955     Klass* delegating_cl_class = SystemDictionary::reflect_DelegatingClassLoader_klass();
3956     // This might be null in non-1.4 JDKs
3957     return (delegating_cl_class != NULL &amp;&amp; loader-&gt;is_a(delegating_cl_class));
3958   }
3959   return false;
3960 }
3961 
3962 oop java_lang_ClassLoader::non_reflection_class_loader(oop loader) {
3963   // See whether this is one of the class loaders associated with
3964   // the generated bytecodes for reflection, and if so, &quot;magically&quot;
3965   // delegate to its parent to prevent class loading from occurring
3966   // in places where applications using reflection didn&#39;t expect it.
3967   if (is_reflection_class_loader(loader)) {
3968     return parent(loader);
3969   }
3970   return loader;
3971 }
3972 
3973 oop java_lang_ClassLoader::unnamedModule(oop loader) {
3974   assert(is_instance(loader), &quot;loader must be oop&quot;);
3975   return loader-&gt;obj_field(unnamedModule_offset);
3976 }
3977 
3978 // Support for java_lang_System
3979 //
3980 #define SYSTEM_FIELDS_DO(macro) \
3981   macro(static_in_offset,  k, &quot;in&quot;,  input_stream_signature, true); \
3982   macro(static_out_offset, k, &quot;out&quot;, print_stream_signature, true); \
3983   macro(static_err_offset, k, &quot;err&quot;, print_stream_signature, true); \
3984   macro(static_security_offset, k, &quot;security&quot;, security_manager_signature, true)
3985 
3986 void java_lang_System::compute_offsets() {
3987   InstanceKlass* k = SystemDictionary::System_klass();
3988   SYSTEM_FIELDS_DO(FIELD_COMPUTE_OFFSET);
3989 }
3990 
3991 #if INCLUDE_CDS
3992 void java_lang_System::serialize_offsets(SerializeClosure* f) {
3993    SYSTEM_FIELDS_DO(FIELD_SERIALIZE_OFFSET);
3994 }
3995 #endif
3996 
3997 int java_lang_System::in_offset_in_bytes() { return static_in_offset; }
3998 int java_lang_System::out_offset_in_bytes() { return static_out_offset; }
3999 int java_lang_System::err_offset_in_bytes() { return static_err_offset; }
4000 
<a name="98" id="anc98"></a>













































4001 int java_lang_Class::_klass_offset;
4002 int java_lang_Class::_array_klass_offset;
4003 int java_lang_Class::_oop_size_offset;
4004 int java_lang_Class::_static_oop_field_count_offset;
4005 int java_lang_Class::_class_loader_offset;
4006 int java_lang_Class::_module_offset;
4007 int java_lang_Class::_protection_domain_offset;
4008 int java_lang_Class::_component_mirror_offset;
4009 int java_lang_Class::_init_lock_offset;
4010 int java_lang_Class::_signers_offset;
4011 int java_lang_Class::_name_offset;
4012 int java_lang_Class::_source_file_offset;
4013 GrowableArray&lt;Klass*&gt;* java_lang_Class::_fixup_mirror_list = NULL;
4014 GrowableArray&lt;Klass*&gt;* java_lang_Class::_fixup_module_field_list = NULL;
4015 int java_lang_Throwable::backtrace_offset;
4016 int java_lang_Throwable::detailMessage_offset;
4017 int java_lang_Throwable::stackTrace_offset;
4018 int java_lang_Throwable::depth_offset;
4019 int java_lang_Throwable::static_unassigned_stacktrace_offset;
4020 int java_lang_reflect_AccessibleObject::override_offset;
4021 int java_lang_reflect_Method::clazz_offset;
4022 int java_lang_reflect_Method::name_offset;
4023 int java_lang_reflect_Method::returnType_offset;
4024 int java_lang_reflect_Method::parameterTypes_offset;
4025 int java_lang_reflect_Method::exceptionTypes_offset;
4026 int java_lang_reflect_Method::slot_offset;
4027 int java_lang_reflect_Method::modifiers_offset;
4028 int java_lang_reflect_Method::signature_offset;
4029 int java_lang_reflect_Method::annotations_offset;
4030 int java_lang_reflect_Method::parameter_annotations_offset;
4031 int java_lang_reflect_Method::annotation_default_offset;
4032 int java_lang_reflect_Constructor::clazz_offset;
4033 int java_lang_reflect_Constructor::parameterTypes_offset;
4034 int java_lang_reflect_Constructor::exceptionTypes_offset;
4035 int java_lang_reflect_Constructor::slot_offset;
4036 int java_lang_reflect_Constructor::modifiers_offset;
4037 int java_lang_reflect_Constructor::signature_offset;
4038 int java_lang_reflect_Constructor::annotations_offset;
4039 int java_lang_reflect_Constructor::parameter_annotations_offset;
4040 int java_lang_reflect_Field::clazz_offset;
4041 int java_lang_reflect_Field::name_offset;
4042 int java_lang_reflect_Field::type_offset;
4043 int java_lang_reflect_Field::slot_offset;
4044 int java_lang_reflect_Field::modifiers_offset;
4045 int java_lang_reflect_Field::signature_offset;
4046 int java_lang_reflect_Field::annotations_offset;
4047 int java_lang_reflect_Parameter::name_offset;
4048 int java_lang_reflect_Parameter::modifiers_offset;
4049 int java_lang_reflect_Parameter::index_offset;
4050 int java_lang_reflect_Parameter::executable_offset;
4051 int java_lang_boxing_object::value_offset;
4052 int java_lang_boxing_object::long_value_offset;
4053 int java_lang_ref_Reference::referent_offset;
4054 int java_lang_ref_Reference::queue_offset;
4055 int java_lang_ref_Reference::next_offset;
4056 int java_lang_ref_Reference::discovered_offset;
4057 int java_lang_ref_SoftReference::timestamp_offset;
4058 int java_lang_ref_SoftReference::static_clock_offset;
4059 int java_lang_ClassLoader::parent_offset;
4060 int java_lang_System::static_in_offset;
4061 int java_lang_System::static_out_offset;
4062 int java_lang_System::static_err_offset;
4063 int java_lang_System::static_security_offset;
4064 int java_lang_StackTraceElement::methodName_offset;
4065 int java_lang_StackTraceElement::fileName_offset;
4066 int java_lang_StackTraceElement::lineNumber_offset;
4067 int java_lang_StackTraceElement::moduleName_offset;
4068 int java_lang_StackTraceElement::moduleVersion_offset;
4069 int java_lang_StackTraceElement::classLoaderName_offset;
4070 int java_lang_StackTraceElement::declaringClass_offset;
4071 int java_lang_StackTraceElement::declaringClassObject_offset;
4072 int java_lang_StackFrameInfo::_memberName_offset;
4073 int java_lang_StackFrameInfo::_bci_offset;
4074 int java_lang_StackFrameInfo::_version_offset;
4075 int java_lang_LiveStackFrameInfo::_monitors_offset;
4076 int java_lang_LiveStackFrameInfo::_locals_offset;
4077 int java_lang_LiveStackFrameInfo::_operands_offset;
4078 int java_lang_LiveStackFrameInfo::_mode_offset;
4079 int java_lang_AssertionStatusDirectives::classes_offset;
4080 int java_lang_AssertionStatusDirectives::classEnabled_offset;
4081 int java_lang_AssertionStatusDirectives::packages_offset;
4082 int java_lang_AssertionStatusDirectives::packageEnabled_offset;
4083 int java_lang_AssertionStatusDirectives::deflt_offset;
4084 int java_nio_Buffer::_limit_offset;
4085 int java_util_concurrent_locks_AbstractOwnableSynchronizer::_owner_offset;
4086 int reflect_ConstantPool::_oop_offset;
4087 int reflect_UnsafeStaticFieldAccessorImpl::_base_offset;
<a name="99" id="anc99"></a>














4088 
4089 
4090 #define STACKTRACEELEMENT_FIELDS_DO(macro) \
4091   macro(declaringClassObject_offset,  k, &quot;declaringClassObject&quot;, class_signature, false); \
4092   macro(classLoaderName_offset, k, &quot;classLoaderName&quot;, string_signature, false); \
4093   macro(moduleName_offset,      k, &quot;moduleName&quot;,      string_signature, false); \
4094   macro(moduleVersion_offset,   k, &quot;moduleVersion&quot;,   string_signature, false); \
4095   macro(declaringClass_offset,  k, &quot;declaringClass&quot;,  string_signature, false); \
4096   macro(methodName_offset,      k, &quot;methodName&quot;,      string_signature, false); \
4097   macro(fileName_offset,        k, &quot;fileName&quot;,        string_signature, false); \
4098   macro(lineNumber_offset,      k, &quot;lineNumber&quot;,      int_signature,    false)
4099 
4100 // Support for java_lang_StackTraceElement
4101 void java_lang_StackTraceElement::compute_offsets() {
4102   InstanceKlass* k = SystemDictionary::StackTraceElement_klass();
4103   STACKTRACEELEMENT_FIELDS_DO(FIELD_COMPUTE_OFFSET);
4104 }
4105 
4106 #if INCLUDE_CDS
4107 void java_lang_StackTraceElement::serialize_offsets(SerializeClosure* f) {
4108   STACKTRACEELEMENT_FIELDS_DO(FIELD_SERIALIZE_OFFSET);
4109 }
4110 #endif
4111 
4112 void java_lang_StackTraceElement::set_fileName(oop element, oop value) {
4113   element-&gt;obj_field_put(fileName_offset, value);
4114 }
4115 
4116 void java_lang_StackTraceElement::set_declaringClass(oop element, oop value) {
4117   element-&gt;obj_field_put(declaringClass_offset, value);
4118 }
4119 
4120 void java_lang_StackTraceElement::set_methodName(oop element, oop value) {
4121   element-&gt;obj_field_put(methodName_offset, value);
4122 }
4123 
4124 void java_lang_StackTraceElement::set_lineNumber(oop element, int value) {
4125   element-&gt;int_field_put(lineNumber_offset, value);
4126 }
4127 
4128 void java_lang_StackTraceElement::set_moduleName(oop element, oop value) {
4129   element-&gt;obj_field_put(moduleName_offset, value);
4130 }
4131 
4132 void java_lang_StackTraceElement::set_moduleVersion(oop element, oop value) {
4133   element-&gt;obj_field_put(moduleVersion_offset, value);
4134 }
4135 
4136 void java_lang_StackTraceElement::set_classLoaderName(oop element, oop value) {
4137   element-&gt;obj_field_put(classLoaderName_offset, value);
4138 }
4139 
4140 void java_lang_StackTraceElement::set_declaringClassObject(oop element, oop value) {
4141   element-&gt;obj_field_put(declaringClassObject_offset, value);
4142 }
4143 
4144 void java_lang_StackFrameInfo::set_version(oop element, short value) {
4145   element-&gt;short_field_put(_version_offset, value);
4146 }
4147 
4148 void java_lang_StackFrameInfo::set_bci(oop element, int value) {
<a name="100" id="anc100"></a>
4149   element-&gt;int_field_put(_bci_offset, value);
4150 }
4151 
4152 void java_lang_LiveStackFrameInfo::set_monitors(oop element, oop value) {
4153   element-&gt;obj_field_put(_monitors_offset, value);
4154 }
4155 
4156 void java_lang_LiveStackFrameInfo::set_locals(oop element, oop value) {
4157   element-&gt;obj_field_put(_locals_offset, value);
4158 }
4159 
4160 void java_lang_LiveStackFrameInfo::set_operands(oop element, oop value) {
4161   element-&gt;obj_field_put(_operands_offset, value);
4162 }
4163 
4164 void java_lang_LiveStackFrameInfo::set_mode(oop element, int value) {
4165   element-&gt;int_field_put(_mode_offset, value);
4166 }
4167 
4168 // Support for java Assertions - java_lang_AssertionStatusDirectives.
4169 #define ASSERTIONSTATUSDIRECTIVES_FIELDS_DO(macro) \
4170   macro(classes_offset,        k, &quot;classes&quot;,        string_array_signature, false); \
4171   macro(classEnabled_offset,   k, &quot;classEnabled&quot;,   bool_array_signature, false); \
4172   macro(packages_offset,       k, &quot;packages&quot;,       string_array_signature, false); \
4173   macro(packageEnabled_offset, k, &quot;packageEnabled&quot;, bool_array_signature,   false); \
4174   macro(deflt_offset,          k, &quot;deflt&quot;,          bool_signature,         false)
4175 
4176 void java_lang_AssertionStatusDirectives::compute_offsets() {
4177   InstanceKlass* k = SystemDictionary::AssertionStatusDirectives_klass();
4178   ASSERTIONSTATUSDIRECTIVES_FIELDS_DO(FIELD_COMPUTE_OFFSET);
4179 }
4180 
4181 #if INCLUDE_CDS
4182 void java_lang_AssertionStatusDirectives::serialize_offsets(SerializeClosure* f) {
4183   ASSERTIONSTATUSDIRECTIVES_FIELDS_DO(FIELD_SERIALIZE_OFFSET);
4184 }
4185 #endif
4186 
4187 void java_lang_AssertionStatusDirectives::set_classes(oop o, oop val) {
4188   o-&gt;obj_field_put(classes_offset, val);
4189 }
4190 
4191 void java_lang_AssertionStatusDirectives::set_classEnabled(oop o, oop val) {
4192   o-&gt;obj_field_put(classEnabled_offset, val);
4193 }
4194 
4195 void java_lang_AssertionStatusDirectives::set_packages(oop o, oop val) {
4196   o-&gt;obj_field_put(packages_offset, val);
4197 }
4198 
4199 void java_lang_AssertionStatusDirectives::set_packageEnabled(oop o, oop val) {
4200   o-&gt;obj_field_put(packageEnabled_offset, val);
4201 }
4202 
4203 void java_lang_AssertionStatusDirectives::set_deflt(oop o, bool val) {
4204   o-&gt;bool_field_put(deflt_offset, val);
4205 }
4206 
4207 
4208 // Support for intrinsification of java.nio.Buffer.checkIndex
4209 int java_nio_Buffer::limit_offset() {
4210   return _limit_offset;
4211 }
4212 
4213 #define BUFFER_FIELDS_DO(macro) \
4214   macro(_limit_offset, k, &quot;limit&quot;, int_signature, false)
4215 
4216 void java_nio_Buffer::compute_offsets() {
4217   InstanceKlass* k = SystemDictionary::nio_Buffer_klass();
4218   assert(k != NULL, &quot;must be loaded in 1.4+&quot;);
4219   BUFFER_FIELDS_DO(FIELD_COMPUTE_OFFSET);
4220 }
4221 
4222 #if INCLUDE_CDS
4223 void java_nio_Buffer::serialize_offsets(SerializeClosure* f) {
4224   BUFFER_FIELDS_DO(FIELD_SERIALIZE_OFFSET);
4225 }
4226 #endif
4227 
4228 #define AOS_FIELDS_DO(macro) \
4229   macro(_owner_offset, k, &quot;exclusiveOwnerThread&quot;, thread_signature, false)
4230 
4231 void java_util_concurrent_locks_AbstractOwnableSynchronizer::compute_offsets() {
4232   InstanceKlass* k = SystemDictionary::java_util_concurrent_locks_AbstractOwnableSynchronizer_klass();
4233   AOS_FIELDS_DO(FIELD_COMPUTE_OFFSET);
4234 }
4235 
4236 oop java_util_concurrent_locks_AbstractOwnableSynchronizer::get_owner_threadObj(oop obj) {
4237   assert(_owner_offset != 0, &quot;Must be initialized&quot;);
4238   return obj-&gt;obj_field(_owner_offset);
4239 }
4240 
4241 #if INCLUDE_CDS
4242 void java_util_concurrent_locks_AbstractOwnableSynchronizer::serialize_offsets(SerializeClosure* f) {
4243   AOS_FIELDS_DO(FIELD_SERIALIZE_OFFSET);
4244 }
4245 #endif
4246 
<a name="101" id="anc101"></a>

























































































































































































4247 static int member_offset(int hardcoded_offset) {
4248   return (hardcoded_offset * heapOopSize) + instanceOopDesc::base_offset_in_bytes();
4249 }
4250 
<a name="102" id="anc102"></a>
















































4251 // Compute hard-coded offsets
4252 // Invoked before SystemDictionary::initialize, so pre-loaded classes
4253 // are not available to determine the offset_of_static_fields.
4254 void JavaClasses::compute_hard_coded_offsets() {
4255 
4256   // java_lang_boxing_object
4257   java_lang_boxing_object::value_offset      = member_offset(java_lang_boxing_object::hc_value_offset);
4258   java_lang_boxing_object::long_value_offset = align_up(member_offset(java_lang_boxing_object::hc_value_offset), BytesPerLong);
4259 
4260   // java_lang_ref_Reference
4261   java_lang_ref_Reference::referent_offset    = member_offset(java_lang_ref_Reference::hc_referent_offset);
4262   java_lang_ref_Reference::queue_offset       = member_offset(java_lang_ref_Reference::hc_queue_offset);
4263   java_lang_ref_Reference::next_offset        = member_offset(java_lang_ref_Reference::hc_next_offset);
4264   java_lang_ref_Reference::discovered_offset  = member_offset(java_lang_ref_Reference::hc_discovered_offset);
4265 }
4266 
4267 #define DO_COMPUTE_OFFSETS(k) k::compute_offsets();
4268 
4269 // Compute non-hard-coded field offsets of all the classes in this file
4270 void JavaClasses::compute_offsets() {
4271   if (UseSharedSpaces) {
4272     assert(JvmtiExport::is_early_phase() &amp;&amp; !(JvmtiExport::should_post_class_file_load_hook() &amp;&amp;
4273                                               JvmtiExport::has_early_class_hook_env()),
4274            &quot;JavaClasses::compute_offsets() must be called in early JVMTI phase.&quot;);
4275     // None of the classes used by the rest of this function can be replaced by
4276     // JMVTI ClassFileLoadHook.
4277     // We are safe to use the archived offsets, which have already been restored
4278     // by JavaClasses::serialize_offsets, without computing the offsets again.
4279     return;
4280   }
4281 
4282   // We have already called the compute_offsets() of the
4283   // BASIC_JAVA_CLASSES_DO_PART1 classes (java_lang_String and java_lang_Class)
4284   // earlier inside SystemDictionary::resolve_well_known_classes()
4285   BASIC_JAVA_CLASSES_DO_PART2(DO_COMPUTE_OFFSETS);
<a name="103" id="anc103"></a><span class="line-removed">4286 </span>
<span class="line-removed">4287   // generated interpreter code wants to know about the offsets we just computed:</span>
<span class="line-removed">4288   AbstractAssembler::update_delayed_values();</span>
4289 }
4290 
4291 #if INCLUDE_CDS
4292 #define DO_SERIALIZE_OFFSETS(k) k::serialize_offsets(soc);
4293 
4294 void JavaClasses::serialize_offsets(SerializeClosure* soc) {
4295   BASIC_JAVA_CLASSES_DO(DO_SERIALIZE_OFFSETS);
4296 }
4297 #endif
4298 
<a name="104" id="anc104"></a>





















4299 
4300 #ifndef PRODUCT
4301 
4302 // These functions exist to assert the validity of hard-coded field offsets to guard
4303 // against changes in the class files
4304 
4305 bool JavaClasses::check_offset(const char *klass_name, int hardcoded_offset, const char *field_name, const char* field_sig) {
4306   EXCEPTION_MARK;
4307   fieldDescriptor fd;
<a name="105" id="anc105"></a><span class="line-modified">4308   TempNewSymbol klass_sym = SymbolTable::new_symbol(klass_name, CATCH);</span>
4309   Klass* k = SystemDictionary::resolve_or_fail(klass_sym, true, CATCH);
4310   InstanceKlass* ik = InstanceKlass::cast(k);
<a name="106" id="anc106"></a><span class="line-modified">4311   TempNewSymbol f_name = SymbolTable::new_symbol(field_name, CATCH);</span>
<span class="line-modified">4312   TempNewSymbol f_sig  = SymbolTable::new_symbol(field_sig, CATCH);</span>
4313   if (!ik-&gt;find_local_field(f_name, f_sig, &amp;fd)) {
4314     tty-&gt;print_cr(&quot;Nonstatic field %s.%s not found&quot;, klass_name, field_name);
4315     return false;
4316   }
4317   if (fd.is_static()) {
4318     tty-&gt;print_cr(&quot;Nonstatic field %s.%s appears to be static&quot;, klass_name, field_name);
4319     return false;
4320   }
4321   if (fd.offset() == hardcoded_offset ) {
4322     return true;
4323   } else {
4324     tty-&gt;print_cr(&quot;Offset of nonstatic field %s.%s is hardcoded as %d but should really be %d.&quot;,
4325                   klass_name, field_name, hardcoded_offset, fd.offset());
4326     return false;
4327   }
4328 }
4329 
4330 // Check the hard-coded field offsets of all the classes in this file
4331 
4332 void JavaClasses::check_offsets() {
4333   bool valid = true;
4334 
4335 #define CHECK_OFFSET(klass_name, cpp_klass_name, field_name, field_sig) \
4336   valid &amp;= check_offset(klass_name, cpp_klass_name :: field_name ## _offset, #field_name, field_sig)
4337 
4338 #define CHECK_LONG_OFFSET(klass_name, cpp_klass_name, field_name, field_sig) \
4339   valid &amp;= check_offset(klass_name, cpp_klass_name :: long_ ## field_name ## _offset, #field_name, field_sig)
4340 
4341   // Boxed primitive objects (java_lang_boxing_object)
4342 
4343   CHECK_OFFSET(&quot;java/lang/Boolean&quot;,   java_lang_boxing_object, value, &quot;Z&quot;);
4344   CHECK_OFFSET(&quot;java/lang/Character&quot;, java_lang_boxing_object, value, &quot;C&quot;);
4345   CHECK_OFFSET(&quot;java/lang/Float&quot;,     java_lang_boxing_object, value, &quot;F&quot;);
4346   CHECK_LONG_OFFSET(&quot;java/lang/Double&quot;, java_lang_boxing_object, value, &quot;D&quot;);
4347   CHECK_OFFSET(&quot;java/lang/Byte&quot;,      java_lang_boxing_object, value, &quot;B&quot;);
4348   CHECK_OFFSET(&quot;java/lang/Short&quot;,     java_lang_boxing_object, value, &quot;S&quot;);
4349   CHECK_OFFSET(&quot;java/lang/Integer&quot;,   java_lang_boxing_object, value, &quot;I&quot;);
4350   CHECK_LONG_OFFSET(&quot;java/lang/Long&quot;, java_lang_boxing_object, value, &quot;J&quot;);
4351 
4352   // java.lang.ref.Reference
4353 
4354   CHECK_OFFSET(&quot;java/lang/ref/Reference&quot;, java_lang_ref_Reference, referent, &quot;Ljava/lang/Object;&quot;);
4355   CHECK_OFFSET(&quot;java/lang/ref/Reference&quot;, java_lang_ref_Reference, queue, &quot;Ljava/lang/ref/ReferenceQueue;&quot;);
4356   CHECK_OFFSET(&quot;java/lang/ref/Reference&quot;, java_lang_ref_Reference, next, &quot;Ljava/lang/ref/Reference;&quot;);
4357   // Fake field
4358   //CHECK_OFFSET(&quot;java/lang/ref/Reference&quot;, java_lang_ref_Reference, discovered, &quot;Ljava/lang/ref/Reference;&quot;);
4359 
4360   if (!valid) vm_exit_during_initialization(&quot;Hard-coded field offset verification failed&quot;);
4361 }
4362 
4363 #endif // PRODUCT
4364 
4365 int InjectedField::compute_offset() {
4366   InstanceKlass* ik = InstanceKlass::cast(klass());
4367   for (AllFieldStream fs(ik); !fs.done(); fs.next()) {
4368     if (!may_be_java &amp;&amp; !fs.access_flags().is_internal()) {
4369       // Only look at injected fields
4370       continue;
4371     }
4372     if (fs.name() == name() &amp;&amp; fs.signature() == signature()) {
4373       return fs.offset();
4374     }
4375   }
4376   ResourceMark rm;
4377   tty-&gt;print_cr(&quot;Invalid layout of %s at %s/%s%s&quot;, ik-&gt;external_name(), name()-&gt;as_C_string(), signature()-&gt;as_C_string(), may_be_java ? &quot; (may_be_java)&quot; : &quot;&quot;);
4378 #ifndef PRODUCT
4379   ik-&gt;print();
4380   tty-&gt;print_cr(&quot;all fields:&quot;);
4381   for (AllFieldStream fs(ik); !fs.done(); fs.next()) {
4382     tty-&gt;print_cr(&quot;  name: %s, sig: %s, flags: %08x&quot;, fs.name()-&gt;as_C_string(), fs.signature()-&gt;as_C_string(), fs.access_flags().as_int());
4383   }
4384 #endif //PRODUCT
4385   vm_exit_during_initialization(&quot;Invalid layout of well-known class: use -Xlog:class+load=info to see the origin of the problem class&quot;);
4386   return -1;
4387 }
4388 
4389 void javaClasses_init() {
4390   JavaClasses::compute_offsets();
4391   JavaClasses::check_offsets();
4392   FilteredFieldsMap::initialize();  // must be done after computing offsets.
4393 }
<a name="107" id="anc107"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="107" type="hidden" />
</body>
</html>
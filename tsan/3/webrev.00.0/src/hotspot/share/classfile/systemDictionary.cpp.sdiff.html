<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/classfile/systemDictionary.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="javaClasses.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="tsanIgnoreList.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/classfile/systemDictionary.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 1997, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include &quot;precompiled.hpp&quot;
  26 #include &quot;jvm.h&quot;
  27 #include &quot;aot/aotLoader.hpp&quot;
  28 #include &quot;classfile/classFileParser.hpp&quot;
  29 #include &quot;classfile/classFileStream.hpp&quot;
  30 #include &quot;classfile/classLoader.hpp&quot;
  31 #include &quot;classfile/classLoaderData.inline.hpp&quot;
  32 #include &quot;classfile/classLoaderDataGraph.inline.hpp&quot;
  33 #include &quot;classfile/classLoaderExt.hpp&quot;
  34 #include &quot;classfile/dictionary.hpp&quot;
  35 #include &quot;classfile/javaClasses.inline.hpp&quot;
  36 #include &quot;classfile/klassFactory.hpp&quot;
  37 #include &quot;classfile/loaderConstraints.hpp&quot;
  38 #include &quot;classfile/packageEntry.hpp&quot;
  39 #include &quot;classfile/placeholders.hpp&quot;
  40 #include &quot;classfile/protectionDomainCache.hpp&quot;
  41 #include &quot;classfile/resolutionErrors.hpp&quot;
  42 #include &quot;classfile/stringTable.hpp&quot;

  43 #include &quot;classfile/systemDictionary.hpp&quot;
  44 #include &quot;classfile/vmSymbols.hpp&quot;
  45 #include &quot;code/codeCache.hpp&quot;
  46 #include &quot;compiler/compileBroker.hpp&quot;
  47 #include &quot;gc/shared/gcTraceTime.inline.hpp&quot;
  48 #include &quot;gc/shared/oopStorage.inline.hpp&quot;

  49 #include &quot;interpreter/bytecodeStream.hpp&quot;
  50 #include &quot;interpreter/interpreter.hpp&quot;
  51 #include &quot;jfr/jfrEvents.hpp&quot;
  52 #include &quot;logging/log.hpp&quot;
  53 #include &quot;logging/logStream.hpp&quot;
  54 #include &quot;memory/filemap.hpp&quot;
  55 #include &quot;memory/heapShared.hpp&quot;
  56 #include &quot;memory/metaspaceClosure.hpp&quot;
  57 #include &quot;memory/oopFactory.hpp&quot;
  58 #include &quot;memory/resourceArea.hpp&quot;

  59 #include &quot;oops/access.inline.hpp&quot;
  60 #include &quot;oops/instanceKlass.hpp&quot;
  61 #include &quot;oops/instanceRefKlass.hpp&quot;
  62 #include &quot;oops/klass.inline.hpp&quot;
  63 #include &quot;oops/method.inline.hpp&quot;
  64 #include &quot;oops/methodData.hpp&quot;
  65 #include &quot;oops/objArrayKlass.hpp&quot;
  66 #include &quot;oops/objArrayOop.inline.hpp&quot;
  67 #include &quot;oops/oop.inline.hpp&quot;
  68 #include &quot;oops/symbol.hpp&quot;
  69 #include &quot;oops/typeArrayKlass.hpp&quot;
  70 #include &quot;prims/jvmtiExport.hpp&quot;
<span class="line-removed">  71 #include &quot;prims/resolvedMethodTable.hpp&quot;</span>
  72 #include &quot;prims/methodHandles.hpp&quot;
  73 #include &quot;runtime/arguments.hpp&quot;
  74 #include &quot;runtime/biasedLocking.hpp&quot;
<span class="line-removed">  75 #include &quot;runtime/fieldType.hpp&quot;</span>
  76 #include &quot;runtime/handles.inline.hpp&quot;
  77 #include &quot;runtime/java.hpp&quot;
  78 #include &quot;runtime/javaCalls.hpp&quot;
  79 #include &quot;runtime/mutexLocker.hpp&quot;
<span class="line-removed">  80 #include &quot;runtime/orderAccess.hpp&quot;</span>
  81 #include &quot;runtime/sharedRuntime.hpp&quot;
  82 #include &quot;runtime/signature.hpp&quot;
  83 #include &quot;services/classLoadingService.hpp&quot;
  84 #include &quot;services/diagnosticCommand.hpp&quot;
  85 #include &quot;services/threadService.hpp&quot;
  86 #include &quot;utilities/macros.hpp&quot;
  87 #if INCLUDE_CDS
  88 #include &quot;classfile/systemDictionaryShared.hpp&quot;
  89 #endif
<span class="line-removed">  90 #if INCLUDE_JVMCI</span>
<span class="line-removed">  91 #include &quot;jvmci/jvmciRuntime.hpp&quot;</span>
<span class="line-removed">  92 #endif</span>
  93 #if INCLUDE_JFR
  94 #include &quot;jfr/jfr.hpp&quot;
  95 #endif
  96 
  97 PlaceholderTable*      SystemDictionary::_placeholders        = NULL;
  98 LoaderConstraintTable* SystemDictionary::_loader_constraints  = NULL;
  99 ResolutionErrorTable*  SystemDictionary::_resolution_errors   = NULL;
 100 SymbolPropertyTable*   SystemDictionary::_invoke_method_table = NULL;
 101 ProtectionDomainCacheTable*   SystemDictionary::_pd_cache_table = NULL;
 102 
<span class="line-removed"> 103 int         SystemDictionary::_number_of_modifications = 0;</span>
 104 oop         SystemDictionary::_system_loader_lock_obj     =  NULL;
 105 
 106 InstanceKlass*      SystemDictionary::_well_known_klasses[SystemDictionary::WKID_LIMIT]
 107                                                           =  { NULL /*, NULL...*/ };
 108 
 109 InstanceKlass*      SystemDictionary::_box_klasses[T_VOID+1]      =  { NULL /*, NULL...*/ };
 110 
 111 oop         SystemDictionary::_java_system_loader         =  NULL;
 112 oop         SystemDictionary::_java_platform_loader       =  NULL;
 113 
<span class="line-removed"> 114 bool        SystemDictionary::_has_checkPackageAccess     =  false;</span>
<span class="line-removed"> 115 </span>
 116 // Default ProtectionDomainCacheSize value
 117 
 118 const int defaultProtectionDomainCacheSize = 1009;
 119 
<span class="line-removed"> 120 OopStorage* SystemDictionary::_vm_weak_oop_storage = NULL;</span>
<span class="line-removed"> 121 </span>
<span class="line-removed"> 122 </span>
 123 // ----------------------------------------------------------------------------
 124 // Java-level SystemLoader and PlatformLoader
 125 
 126 oop SystemDictionary::java_system_loader() {
 127   return _java_system_loader;
 128 }
 129 
 130 oop SystemDictionary::java_platform_loader() {
 131   return _java_platform_loader;
 132 }
 133 
 134 void SystemDictionary::compute_java_loaders(TRAPS) {
 135   JavaValue result(T_OBJECT);
 136   InstanceKlass* class_loader_klass = SystemDictionary::ClassLoader_klass();
 137   JavaCalls::call_static(&amp;result,
 138                          class_loader_klass,
 139                          vmSymbols::getSystemClassLoader_name(),
 140                          vmSymbols::void_classloader_signature(),
 141                          CHECK);
 142 
</pre>
<hr />
<pre>
 165   return java_lang_ClassLoader::parallelCapable(class_loader());
 166 }
 167 // ----------------------------------------------------------------------------
 168 // ParallelDefineClass flag does not apply to bootclass loader
 169 bool SystemDictionary::is_parallelDefine(Handle class_loader) {
 170    if (class_loader.is_null()) return false;
 171    if (AllowParallelDefineClass &amp;&amp; java_lang_ClassLoader::parallelCapable(class_loader())) {
 172      return true;
 173    }
 174    return false;
 175 }
 176 
 177 // Returns true if the passed class loader is the builtin application class loader
 178 // or a custom system class loader. A customer system class loader can be
 179 // specified via -Djava.system.class.loader.
 180 bool SystemDictionary::is_system_class_loader(oop class_loader) {
 181   if (class_loader == NULL) {
 182     return false;
 183   }
 184   return (class_loader-&gt;klass() == SystemDictionary::jdk_internal_loader_ClassLoaders_AppClassLoader_klass() ||
<span class="line-modified"> 185          oopDesc::equals(class_loader, _java_system_loader));</span>
 186 }
 187 
 188 // Returns true if the passed class loader is the platform class loader.
 189 bool SystemDictionary::is_platform_class_loader(oop class_loader) {
 190   if (class_loader == NULL) {
 191     return false;
 192   }
 193   return (class_loader-&gt;klass() == SystemDictionary::jdk_internal_loader_ClassLoaders_PlatformClassLoader_klass());
 194 }
 195 
 196 // ----------------------------------------------------------------------------
 197 // Resolving of classes
 198 
 199 // Forwards to resolve_or_null
 200 
 201 Klass* SystemDictionary::resolve_or_fail(Symbol* class_name, Handle class_loader, Handle protection_domain, bool throw_error, TRAPS) {
 202   Klass* klass = resolve_or_null(class_name, class_loader, protection_domain, THREAD);
 203   if (HAS_PENDING_EXCEPTION || klass == NULL) {
 204     // can return a null klass
 205     klass = handle_resolution_exception(class_name, throw_error, klass, THREAD);
</pre>
<hr />
<pre>
 231     if (throw_error) {
 232       THROW_MSG_NULL(vmSymbols::java_lang_NoClassDefFoundError(), class_name-&gt;as_C_string());
 233     } else {
 234       THROW_MSG_NULL(vmSymbols::java_lang_ClassNotFoundException(), class_name-&gt;as_C_string());
 235     }
 236   }
 237   return klass;
 238 }
 239 
 240 
 241 Klass* SystemDictionary::resolve_or_fail(Symbol* class_name,
 242                                            bool throw_error, TRAPS)
 243 {
 244   return resolve_or_fail(class_name, Handle(), Handle(), throw_error, THREAD);
 245 }
 246 
 247 
 248 // Forwards to resolve_array_class_or_null or resolve_instance_class_or_null
 249 
 250 Klass* SystemDictionary::resolve_or_null(Symbol* class_name, Handle class_loader, Handle protection_domain, TRAPS) {
<span class="line-modified"> 251   if (FieldType::is_array(class_name)) {</span>
 252     return resolve_array_class_or_null(class_name, class_loader, protection_domain, THREAD);
 253   } else {
 254     return resolve_instance_class_or_null_helper(class_name, class_loader, protection_domain, THREAD);
 255   }
 256 }
 257 
 258 // name may be in the form of &quot;java/lang/Object&quot; or &quot;Ljava/lang/Object;&quot;
 259 InstanceKlass* SystemDictionary::resolve_instance_class_or_null_helper(Symbol* class_name,
 260                                                                        Handle class_loader,
 261                                                                        Handle protection_domain,
 262                                                                        TRAPS) {
<span class="line-modified"> 263   assert(class_name != NULL &amp;&amp; !FieldType::is_array(class_name), &quot;must be&quot;);</span>
<span class="line-modified"> 264   if (FieldType::is_obj(class_name)) {</span>
 265     ResourceMark rm(THREAD);
 266     // Ignore wrapping L and ;.
 267     TempNewSymbol name = SymbolTable::new_symbol(class_name-&gt;as_C_string() + 1,
<span class="line-modified"> 268                                    class_name-&gt;utf8_length() - 2, CHECK_NULL);</span>
 269     return resolve_instance_class_or_null(name, class_loader, protection_domain, THREAD);
 270   } else {
 271     return resolve_instance_class_or_null(class_name, class_loader, protection_domain, THREAD);
 272   }
 273 }
 274 
 275 Klass* SystemDictionary::resolve_or_null(Symbol* class_name, TRAPS) {
 276   return resolve_or_null(class_name, Handle(), Handle(), THREAD);
 277 }
 278 
 279 // Forwards to resolve_instance_class_or_null
 280 
 281 Klass* SystemDictionary::resolve_array_class_or_null(Symbol* class_name,
 282                                                      Handle class_loader,
 283                                                      Handle protection_domain,
 284                                                      TRAPS) {
<span class="line-modified"> 285   assert(FieldType::is_array(class_name), &quot;must be array&quot;);</span>



 286   Klass* k = NULL;
<span class="line-modified"> 287   FieldArrayInfo fd;</span>
<span class="line-modified"> 288   // dimension and object_key in FieldArrayInfo are assigned as a side-effect</span>
<span class="line-modified"> 289   // of this call</span>
<span class="line-modified"> 290   BasicType t = FieldType::get_array_info(class_name, fd, CHECK_NULL);</span>
<span class="line-removed"> 291   if (t == T_OBJECT) {</span>
<span class="line-removed"> 292     // naked oop &quot;k&quot; is OK here -- we assign back into it</span>
<span class="line-removed"> 293     k = SystemDictionary::resolve_instance_class_or_null(fd.object_key(),</span>
 294                                                          class_loader,
 295                                                          protection_domain,
 296                                                          CHECK_NULL);
 297     if (k != NULL) {
<span class="line-modified"> 298       k = k-&gt;array_klass(fd.dimension(), CHECK_NULL);</span>
 299     }
 300   } else {
 301     k = Universe::typeArrayKlassObj(t);
<span class="line-modified"> 302     k = TypeArrayKlass::cast(k)-&gt;array_klass(fd.dimension(), CHECK_NULL);</span>
 303   }
 304   return k;
 305 }
 306 
 307 
 308 // Must be called for any super-class or super-interface resolution
 309 // during class definition to allow class circularity checking
 310 // super-interface callers:
 311 //    parse_interfaces - for defineClass &amp; jvmtiRedefineClasses
 312 // super-class callers:
 313 //   ClassFileParser - for defineClass &amp; jvmtiRedefineClasses
 314 //   load_shared_class - while loading a class from shared archive
 315 //   resolve_instance_class_or_null:
 316 //     via: handle_parallel_super_load
 317 //      when resolving a class that has an existing placeholder with
 318 //      a saved superclass [i.e. a defineClass is currently in progress]
 319 //      if another thread is trying to resolve the class, it must do
 320 //      super-class checks on its own thread to catch class circularity
 321 // This last call is critical in class circularity checking for cases
 322 // where classloading is delegated to different threads and the
</pre>
<hr />
<pre>
 333 //      3.4 calls resolve_super_or_fail Base
 334 //      3.5 finds T1,Base -&gt; throws class circularity
 335 //OR 4. If T2 tries to resolve Super via defineClass Super ...
 336 //      4.1 resolve_super_or_fail creates placeholder: T2, Super (super Base)
 337 //      4.2 resolve_instance_class_or_null Base, finds placeholder for Base (super Super)
 338 //      4.3 calls resolve_super_or_fail Super in parallel on own thread T2
 339 //      4.4 finds T2, Super -&gt; throws class circularity
 340 // Must be called, even if superclass is null, since this is
 341 // where the placeholder entry is created which claims this
 342 // thread is loading this class/classloader.
 343 // Be careful when modifying this code: once you have run
 344 // placeholders()-&gt;find_and_add(PlaceholderTable::LOAD_SUPER),
 345 // you need to find_and_remove it before returning.
 346 // So be careful to not exit with a CHECK_ macro betweeen these calls.
 347 InstanceKlass* SystemDictionary::resolve_super_or_fail(Symbol* child_name,
 348                                                        Symbol* super_name,
 349                                                        Handle class_loader,
 350                                                        Handle protection_domain,
 351                                                        bool is_superclass,
 352                                                        TRAPS) {
<span class="line-modified"> 353   assert(!FieldType::is_array(super_name), &quot;invalid super class name&quot;);</span>
 354 #if INCLUDE_CDS
 355   if (DumpSharedSpaces) {
 356     // Special processing for handling UNREGISTERED shared classes.
 357     InstanceKlass* k = SystemDictionaryShared::dump_time_resolve_super_or_fail(child_name,
 358         super_name, class_loader, protection_domain, is_superclass, CHECK_NULL);
 359     if (k) {
 360       return k;
 361     }
 362   }
 363 #endif // INCLUDE_CDS
 364 
 365   // Double-check, if child class is already loaded, just return super-class,interface
 366   // Don&#39;t add a placedholder if already loaded, i.e. already in appropriate class loader
 367   // dictionary.
 368   // Make sure there&#39;s a placeholder for the *child* before resolving.
 369   // Used as a claim that this thread is currently loading superclass/classloader
 370   // Used here for ClassCircularity checks and also for heap verification
 371   // (every InstanceKlass needs to be in its class loader dictionary or have a placeholder).
 372   // Must check ClassCircularity before checking if super class is already loaded.
 373   //
 374   // We might not already have a placeholder if this child_name was
 375   // first seen via resolve_from_stream (jni_DefineClass or JVM_DefineClass);
 376   // the name of the class might not be known until the stream is actually
 377   // parsed.
 378   // Bugs 4643874, 4715493
 379 
 380   ClassLoaderData* loader_data = class_loader_data(class_loader);
 381   Dictionary* dictionary = loader_data-&gt;dictionary();
 382   unsigned int d_hash = dictionary-&gt;compute_hash(child_name);
 383   unsigned int p_hash = placeholders()-&gt;compute_hash(child_name);
 384   int p_index = placeholders()-&gt;hash_to_index(p_hash);
 385   // can&#39;t throw error holding a lock
 386   bool child_already_loaded = false;
 387   bool throw_circularity_error = false;
 388   {
<span class="line-modified"> 389     MutexLocker mu(SystemDictionary_lock, THREAD);</span>
 390     InstanceKlass* childk = find_class(d_hash, child_name, dictionary);
 391     InstanceKlass* quicksuperk;
 392     // to support // loading: if child done loading, just return superclass
 393     // if super_name, &amp; class_loader don&#39;t match:
 394     // if initial define, SD update will give LinkageError
 395     // if redefine: compare_class_versions will give HIERARCHY_CHANGED
 396     // so we don&#39;t throw an exception here.
 397     // see: nsk redefclass014 &amp; java.lang.instrument Instrument032
 398     if ((childk != NULL ) &amp;&amp; (is_superclass) &amp;&amp;
 399         ((quicksuperk = childk-&gt;java_super()) != NULL) &amp;&amp;
 400          ((quicksuperk-&gt;name() == super_name) &amp;&amp;
<span class="line-modified"> 401             (oopDesc::equals(quicksuperk-&gt;class_loader(), class_loader())))) {</span>
 402            return quicksuperk;
 403     } else {
 404       PlaceholderEntry* probe = placeholders()-&gt;get_entry(p_index, p_hash, child_name, loader_data);
 405       if (probe &amp;&amp; probe-&gt;check_seen_thread(THREAD, PlaceholderTable::LOAD_SUPER)) {
 406           throw_circularity_error = true;
 407       }
 408     }
 409     if (!throw_circularity_error) {
 410       // Be careful not to exit resolve_super
 411       PlaceholderEntry* newprobe = placeholders()-&gt;find_and_add(p_index, p_hash, child_name, loader_data, PlaceholderTable::LOAD_SUPER, super_name, THREAD);
 412     }
 413   }
 414   if (throw_circularity_error) {
 415       ResourceMark rm(THREAD);
 416       THROW_MSG_NULL(vmSymbols::java_lang_ClassCircularityError(), child_name-&gt;as_C_string());
 417   }
 418 
 419 // java.lang.Object should have been found above
 420   assert(super_name != NULL, &quot;null super class for resolving&quot;);
 421   // Resolve the super class or interface, check results on return
 422   InstanceKlass* superk =
 423     SystemDictionary::resolve_instance_class_or_null_helper(super_name,
 424                                                             class_loader,
 425                                                             protection_domain,
 426                                                             THREAD);
 427 
 428   // Clean up of placeholders moved so that each classloadAction registrar self-cleans up
 429   // It is no longer necessary to keep the placeholder table alive until update_dictionary
 430   // or error. GC used to walk the placeholder table as strong roots.
 431   // The instanceKlass is kept alive because the class loader is on the stack,
 432   // which keeps the loader_data alive, as well as all instanceKlasses in
 433   // the loader_data. parseClassFile adds the instanceKlass to loader_data.
 434   {
<span class="line-modified"> 435     MutexLocker mu(SystemDictionary_lock, THREAD);</span>
 436     placeholders()-&gt;find_and_remove(p_index, p_hash, child_name, loader_data, PlaceholderTable::LOAD_SUPER, THREAD);
 437     SystemDictionary_lock-&gt;notify_all();
 438   }
 439   if (HAS_PENDING_EXCEPTION || superk == NULL) {
 440     // can null superk
 441     Klass* k = handle_resolution_exception(super_name, true, superk, THREAD);
 442     assert(k == NULL || k == superk, &quot;must be&quot;);
 443     if (k == NULL) {
 444       superk = NULL;
 445     }
 446   }
 447 
 448   return superk;
 449 }
 450 
 451 void SystemDictionary::validate_protection_domain(InstanceKlass* klass,
 452                                                   Handle class_loader,
 453                                                   Handle protection_domain,
 454                                                   TRAPS) {
<span class="line-removed"> 455   if(!has_checkPackageAccess()) return;</span>
<span class="line-removed"> 456 </span>
 457   // Now we have to call back to java to check if the initating class has access
 458   JavaValue result(T_VOID);
 459   LogTarget(Debug, protectiondomain) lt;
 460   if (lt.is_enabled()) {
<span class="line-modified"> 461     ResourceMark rm;</span>
 462     // Print out trace information
 463     LogStream ls(lt);
 464     ls.print_cr(&quot;Checking package access&quot;);
 465     if (class_loader() != NULL) {
 466       ls.print(&quot;class loader: &quot;);
 467       class_loader()-&gt;print_value_on(&amp;ls);
 468     } else {
 469       ls.print_cr(&quot;class loader: NULL&quot;);
 470     }
 471     if (protection_domain() != NULL) {
 472       ls.print(&quot; protection domain: &quot;);
 473       protection_domain()-&gt;print_value_on(&amp;ls);
 474     } else {
 475       ls.print_cr(&quot; protection domain: NULL&quot;);
 476     }
 477     ls.print(&quot; loading: &quot;); klass-&gt;print_value_on(&amp;ls);
 478     ls.cr();
 479   }
 480 
 481   // This handle and the class_loader handle passed in keeps this class from
</pre>
<hr />
<pre>
 493                          protection_domain,
 494                          THREAD);
 495 
 496   if (HAS_PENDING_EXCEPTION) {
 497     log_debug(protectiondomain)(&quot;DENIED !!!!!!!!!!!!!!!!!!!!!&quot;);
 498   } else {
 499    log_debug(protectiondomain)(&quot;granted&quot;);
 500   }
 501 
 502   if (HAS_PENDING_EXCEPTION) return;
 503 
 504   // If no exception has been thrown, we have validated the protection domain
 505   // Insert the protection domain of the initiating class into the set.
 506   {
 507     ClassLoaderData* loader_data = class_loader_data(class_loader);
 508     Dictionary* dictionary = loader_data-&gt;dictionary();
 509 
 510     Symbol*  kn = klass-&gt;name();
 511     unsigned int d_hash = dictionary-&gt;compute_hash(kn);
 512 
<span class="line-modified"> 513     MutexLocker mu(SystemDictionary_lock, THREAD);</span>
 514     int d_index = dictionary-&gt;hash_to_index(d_hash);
 515     dictionary-&gt;add_protection_domain(d_index, d_hash, klass,
 516                                       protection_domain, THREAD);
 517   }
 518 }
 519 
 520 // We only get here if this thread finds that another thread
 521 // has already claimed the placeholder token for the current operation,
 522 // but that other thread either never owned or gave up the
 523 // object lock
 524 // Waits on SystemDictionary_lock to indicate placeholder table updated
 525 // On return, caller must recheck placeholder table state
 526 //
 527 // We only get here if
 528 //  1) custom classLoader, i.e. not bootstrap classloader
 529 //  2) custom classLoader has broken the class loader objectLock
 530 //     so another thread got here in parallel
 531 //
 532 // lockObject must be held.
 533 // Complicated dance due to lock ordering:
 534 // Must first release the classloader object lock to
 535 // allow initial definer to complete the class definition
 536 // and to avoid deadlock
 537 // Reclaim classloader lock object with same original recursion count
 538 // Must release SystemDictionary_lock after notify, since
 539 // class loader lock must be claimed before SystemDictionary_lock
 540 // to prevent deadlocks
 541 //
 542 // The notify allows applications that did an untimed wait() on
 543 // the classloader object lock to not hang.
 544 void SystemDictionary::double_lock_wait(Handle lockObject, TRAPS) {
 545   assert_lock_strong(SystemDictionary_lock);
 546 
 547   bool calledholdinglock
 548       = ObjectSynchronizer::current_thread_holds_lock((JavaThread*)THREAD, lockObject);
 549   assert(calledholdinglock,&quot;must hold lock for notify&quot;);
<span class="line-modified"> 550   assert((!oopDesc::equals(lockObject(), _system_loader_lock_obj) &amp;&amp; !is_parallelCapable(lockObject)), &quot;unexpected double_lock_wait&quot;);</span>
 551   ObjectSynchronizer::notifyall(lockObject, THREAD);
 552 
 553   TSAN_ONLY(int tsan_rec = 0;)
 554   TSAN_RUNTIME_ONLY(
 555     tsan_rec = SharedRuntime::tsan_oop_rec_unlock(THREAD, lockObject());
 556     assert(tsan_rec &gt; 0, &quot;tsan: unlocking unlocked mutex&quot;);
 557   );
<span class="line-modified"> 558   intptr_t recursions =  ObjectSynchronizer::complete_exit(lockObject, THREAD);</span>
 559   SystemDictionary_lock-&gt;wait();
 560   SystemDictionary_lock-&gt;unlock();
 561   ObjectSynchronizer::reenter(lockObject, recursions, THREAD);
 562   TSAN_RUNTIME_ONLY(SharedRuntime::tsan_oop_rec_lock(THREAD, lockObject(), tsan_rec));
 563   SystemDictionary_lock-&gt;lock();
 564 }
 565 
 566 // If the class in is in the placeholder table, class loading is in progress
 567 // For cases where the application changes threads to load classes, it
 568 // is critical to ClassCircularity detection that we try loading
 569 // the superclass on the same thread internally, so we do parallel
 570 // super class loading here.
 571 // This also is critical in cases where the original thread gets stalled
 572 // even in non-circularity situations.
 573 // Note: must call resolve_super_or_fail even if null super -
 574 // to force placeholder entry creation for this class for circularity detection
 575 // Caller must check for pending exception
 576 // Returns non-null Klass* if other thread has completed load
 577 // and we are done,
 578 // If return null Klass* and no pending exception, the caller must load the class
</pre>
<hr />
<pre>
 587   int p_index = placeholders()-&gt;hash_to_index(p_hash);
 588 
 589   // superk is not used, resolve_super called for circularity check only
 590   // This code is reached in two situations. One if this thread
 591   // is loading the same class twice (e.g. ClassCircularity, or
 592   // java.lang.instrument).
 593   // The second is if another thread started the resolve_super first
 594   // and has not yet finished.
 595   // In both cases the original caller will clean up the placeholder
 596   // entry on error.
 597   Klass* superk = SystemDictionary::resolve_super_or_fail(name,
 598                                                           superclassname,
 599                                                           class_loader,
 600                                                           protection_domain,
 601                                                           true,
 602                                                           CHECK_NULL);
 603 
 604   // parallelCapable class loaders do NOT wait for parallel superclass loads to complete
 605   // Serial class loaders and bootstrap classloader do wait for superclass loads
 606  if (!class_loader.is_null() &amp;&amp; is_parallelCapable(class_loader)) {
<span class="line-modified"> 607     MutexLocker mu(SystemDictionary_lock, THREAD);</span>
 608     // Check if classloading completed while we were loading superclass or waiting
 609     return find_class(d_hash, name, dictionary);
 610   }
 611 
 612   // must loop to both handle other placeholder updates
 613   // and spurious notifications
 614   bool super_load_in_progress = true;
 615   PlaceholderEntry* placeholder;
 616   while (super_load_in_progress) {
<span class="line-modified"> 617     MutexLocker mu(SystemDictionary_lock, THREAD);</span>
 618     // Check if classloading completed while we were loading superclass or waiting
 619     InstanceKlass* check = find_class(d_hash, name, dictionary);
 620     if (check != NULL) {
 621       // Klass is already loaded, so just return it
 622       return check;
 623     } else {
 624       placeholder = placeholders()-&gt;get_entry(p_index, p_hash, name, loader_data);
 625       if (placeholder &amp;&amp; placeholder-&gt;super_load_in_progress() ){
 626         // We only get here if the application has released the
 627         // classloader lock when another thread was in the middle of loading a
 628         // superclass/superinterface for this class, and now
 629         // this thread is also trying to load this class.
 630         // To minimize surprises, the first thread that started to
 631         // load a class should be the one to complete the loading
 632         // with the classfile it initially expected.
 633         // This logic has the current thread wait once it has done
 634         // all the superclass/superinterface loading it can, until
 635         // the original thread completes the class loading or fails
 636         // If it completes we will use the resulting InstanceKlass
 637         // which we will find below in the systemDictionary.
</pre>
<hr />
<pre>
 654   assert(event != NULL, &quot;invariant&quot;);
 655   assert(k != NULL, &quot;invariant&quot;);
 656   assert(event-&gt;should_commit(), &quot;invariant&quot;);
 657   event-&gt;set_loadedClass(k);
 658   event-&gt;set_definingClassLoader(k-&gt;class_loader_data());
 659   event-&gt;set_initiatingClassLoader(init_cld);
 660   event-&gt;commit();
 661 }
 662 
 663 
 664 // Be careful when modifying this code: once you have run
 665 // placeholders()-&gt;find_and_add(PlaceholderTable::LOAD_INSTANCE),
 666 // you need to find_and_remove it before returning.
 667 // So be careful to not exit with a CHECK_ macro betweeen these calls.
 668 //
 669 // name must be in the form of &quot;java/lang/Object&quot; -- cannot be &quot;Ljava/lang/Object;&quot;
 670 InstanceKlass* SystemDictionary::resolve_instance_class_or_null(Symbol* name,
 671                                                                 Handle class_loader,
 672                                                                 Handle protection_domain,
 673                                                                 TRAPS) {
<span class="line-modified"> 674   assert(name != NULL &amp;&amp; !FieldType::is_array(name) &amp;&amp;</span>
<span class="line-modified"> 675          !FieldType::is_obj(name), &quot;invalid class name&quot;);</span>
 676 
 677   EventClassLoad class_load_start_event;
 678 
 679   HandleMark hm(THREAD);
 680 
 681   // Fix for 4474172; see evaluation for more details
 682   class_loader = Handle(THREAD, java_lang_ClassLoader::non_reflection_class_loader(class_loader()));
 683   ClassLoaderData* loader_data = register_loader(class_loader);
 684   Dictionary* dictionary = loader_data-&gt;dictionary();
 685   unsigned int d_hash = dictionary-&gt;compute_hash(name);
 686 
 687   // Do lookup to see if class already exist and the protection domain
 688   // has the right access
 689   // This call uses find which checks protection domain already matches
 690   // All subsequent calls use find_class, and set has_loaded_class so that
 691   // before we return a result we call out to java to check for valid protection domain
 692   // to allow returning the Klass* and add it to the pd_set if it is valid
 693   {
 694     InstanceKlass* probe = dictionary-&gt;find(d_hash, name, protection_domain);
 695     if (probe != NULL) return probe;
</pre>
<hr />
<pre>
 714 
 715   // Class is not in SystemDictionary so we have to do loading.
 716   // Make sure we are synchronized on the class loader before we proceed
 717   Handle lockObject = compute_loader_lock_object(class_loader, THREAD);
 718   check_loader_lock_contention(lockObject, THREAD);
 719   ObjectLocker ol(lockObject, THREAD, DoObjectLock);
 720 
 721   // Check again (after locking) if class already exist in SystemDictionary
 722   bool class_has_been_loaded   = false;
 723   bool super_load_in_progress  = false;
 724   bool havesupername = false;
 725   InstanceKlass* k = NULL;
 726   PlaceholderEntry* placeholder;
 727   Symbol* superclassname = NULL;
 728 
 729   assert(THREAD-&gt;can_call_java(),
 730          &quot;can not load classes with compiler thread: class=%s, classloader=%s&quot;,
 731          name-&gt;as_C_string(),
 732          class_loader.is_null() ? &quot;null&quot; : class_loader-&gt;klass()-&gt;name()-&gt;as_C_string());
 733   {
<span class="line-modified"> 734     MutexLocker mu(SystemDictionary_lock, THREAD);</span>
 735     InstanceKlass* check = find_class(d_hash, name, dictionary);
 736     if (check != NULL) {
 737       // InstanceKlass is already loaded, so just return it
 738       class_has_been_loaded = true;
 739       k = check;
 740     } else {
 741       placeholder = placeholders()-&gt;get_entry(p_index, p_hash, name, loader_data);
 742       if (placeholder &amp;&amp; placeholder-&gt;super_load_in_progress()) {
 743          super_load_in_progress = true;
 744          if (placeholder-&gt;havesupername() == true) {
 745            superclassname = placeholder-&gt;supername();
 746            havesupername = true;
 747          }
 748       }
 749     }
 750   }
 751 
 752   // If the class is in the placeholder table, class loading is in progress
 753   if (super_load_in_progress &amp;&amp; havesupername==true) {
 754     k = handle_parallel_super_load(name,
</pre>
<hr />
<pre>
 774     // in parallel with a classload of same classname
 775     // Redefineclasses uses existence of the placeholder for the duration
 776     // of the class load to prevent concurrent redefinition of not completely
 777     // defined classes.
 778     // case 1. traditional classloaders that rely on the classloader object lock
 779     //   - no other need for LOAD_INSTANCE
 780     // case 2. traditional classloaders that break the classloader object lock
 781     //    as a deadlock workaround. Detection of this case requires that
 782     //    this check is done while holding the classloader object lock,
 783     //    and that lock is still held when calling classloader&#39;s loadClass.
 784     //    For these classloaders, we ensure that the first requestor
 785     //    completes the load and other requestors wait for completion.
 786     // case 3. Bootstrap classloader - don&#39;t own objectLocker
 787     //    This classloader supports parallelism at the classloader level,
 788     //    but only allows a single load of a class/classloader pair.
 789     //    No performance benefit and no deadlock issues.
 790     // case 4. parallelCapable user level classloaders - without objectLocker
 791     //    Allow parallel classloading of a class/classloader pair
 792 
 793     {
<span class="line-modified"> 794       MutexLocker mu(SystemDictionary_lock, THREAD);</span>
 795       if (class_loader.is_null() || !is_parallelCapable(class_loader)) {
 796         PlaceholderEntry* oldprobe = placeholders()-&gt;get_entry(p_index, p_hash, name, loader_data);
 797         if (oldprobe) {
 798           // only need check_seen_thread once, not on each loop
 799           // 6341374 java/lang/Instrument with -Xcomp
 800           if (oldprobe-&gt;check_seen_thread(THREAD, PlaceholderTable::LOAD_INSTANCE)) {
 801             throw_circularity_error = true;
 802           } else {
 803             // case 1: traditional: should never see load_in_progress.
 804             while (!class_has_been_loaded &amp;&amp; oldprobe &amp;&amp; oldprobe-&gt;instance_load_in_progress()) {
 805 
 806               // case 3: bootstrap classloader: prevent futile classloading,
 807               // wait on first requestor
 808               if (class_loader.is_null()) {
 809                 SystemDictionary_lock-&gt;wait();
 810               } else {
 811               // case 2: traditional with broken classloader lock. wait on first
 812               // requestor.
 813                 double_lock_wait(lockObject, THREAD);
 814               }
</pre>
<hr />
<pre>
 845           class_has_been_loaded = true;
 846         }
 847       }
 848     }
 849 
 850     // must throw error outside of owning lock
 851     if (throw_circularity_error) {
 852       assert(!HAS_PENDING_EXCEPTION &amp;&amp; load_instance_added == false,&quot;circularity error cleanup&quot;);
 853       ResourceMark rm(THREAD);
 854       THROW_MSG_NULL(vmSymbols::java_lang_ClassCircularityError(), name-&gt;as_C_string());
 855     }
 856 
 857     if (!class_has_been_loaded) {
 858 
 859       // Do actual loading
 860       k = load_instance_class(name, class_loader, THREAD);
 861 
 862       // If everything was OK (no exceptions, no null return value), and
 863       // class_loader is NOT the defining loader, do a little more bookkeeping.
 864       if (!HAS_PENDING_EXCEPTION &amp;&amp; k != NULL &amp;&amp;
<span class="line-modified"> 865         !oopDesc::equals(k-&gt;class_loader(), class_loader())) {</span>
 866 
 867         check_constraints(d_hash, k, class_loader, false, THREAD);
 868 
 869         // Need to check for a PENDING_EXCEPTION again; check_constraints
 870         // can throw but we may have to remove entry from the placeholder table below.
 871         if (!HAS_PENDING_EXCEPTION) {
 872           // Record dependency for non-parent delegation.
 873           // This recording keeps the defining class loader of the klass (k) found
 874           // from being unloaded while the initiating class loader is loaded
 875           // even if the reference to the defining class loader is dropped
 876           // before references to the initiating class loader.
 877           loader_data-&gt;record_dependency(k);
 878 
 879           { // Grabbing the Compile_lock prevents systemDictionary updates
 880             // during compilations.
<span class="line-modified"> 881             MutexLocker mu(Compile_lock, THREAD);</span>
 882             update_dictionary(d_hash, p_index, p_hash,
 883               k, class_loader, THREAD);
 884           }
 885 
 886           if (JvmtiExport::should_post_class_load()) {
 887             Thread *thread = THREAD;
 888             assert(thread-&gt;is_Java_thread(), &quot;thread-&gt;is_Java_thread()&quot;);
 889             JvmtiExport::post_class_load((JavaThread *) thread, k);
 890           }
 891         }
 892       }
 893     } // load_instance_class
 894 
 895     if (load_instance_added == true) {
 896       // clean up placeholder entries for LOAD_INSTANCE success or error
 897       // This brackets the SystemDictionary updates for both defining
 898       // and initiating loaders
<span class="line-modified"> 899       MutexLocker mu(SystemDictionary_lock, THREAD);</span>
 900       placeholders()-&gt;find_and_remove(p_index, p_hash, name, loader_data, PlaceholderTable::LOAD_INSTANCE, THREAD);
 901       SystemDictionary_lock-&gt;notify_all();
 902     }
 903   }
 904 
 905   if (HAS_PENDING_EXCEPTION || k == NULL) {
 906     return NULL;
 907   }
 908   if (class_load_start_event.should_commit()) {
 909     post_class_load_event(&amp;class_load_start_event, k, loader_data);
 910   }
 911 #ifdef ASSERT
 912   {
 913     ClassLoaderData* loader_data = k-&gt;class_loader_data();
<span class="line-modified"> 914     MutexLocker mu(SystemDictionary_lock, THREAD);</span>
 915     InstanceKlass* kk = find_class(name, loader_data);
 916     assert(kk == k, &quot;should be present in dictionary&quot;);
 917   }
 918 #endif
 919 
 920   // return if the protection domain in NULL
 921   if (protection_domain() == NULL) return k;
 922 
 923   // Check the protection domain has the right access
 924   if (dictionary-&gt;is_valid_protection_domain(d_hash, name,
 925                                              protection_domain)) {
 926     return k;
 927   }
 928 
 929   // Verify protection domain. If it fails an exception is thrown
 930   validate_protection_domain(k, class_loader, protection_domain, CHECK_NULL);
 931 
 932   return k;
 933 }
 934 
</pre>
<hr />
<pre>
 960     // then the class loader has no entries in the dictionary.
 961     return NULL;
 962   }
 963 
 964   Dictionary* dictionary = loader_data-&gt;dictionary();
 965   unsigned int d_hash = dictionary-&gt;compute_hash(class_name);
 966   return dictionary-&gt;find(d_hash, class_name,
 967                           protection_domain);
 968 }
 969 
 970 
 971 // Look for a loaded instance or array klass by name.  Do not do any loading.
 972 // return NULL in case of error.
 973 Klass* SystemDictionary::find_instance_or_array_klass(Symbol* class_name,
 974                                                       Handle class_loader,
 975                                                       Handle protection_domain,
 976                                                       TRAPS) {
 977   Klass* k = NULL;
 978   assert(class_name != NULL, &quot;class name must be non NULL&quot;);
 979 
<span class="line-modified"> 980   if (FieldType::is_array(class_name)) {</span>
 981     // The name refers to an array.  Parse the name.
 982     // dimension and object_key in FieldArrayInfo are assigned as a
 983     // side-effect of this call
<span class="line-modified"> 984     FieldArrayInfo fd;</span>
<span class="line-modified"> 985     BasicType t = FieldType::get_array_info(class_name, fd, CHECK_(NULL));</span>

 986     if (t != T_OBJECT) {
 987       k = Universe::typeArrayKlassObj(t);
 988     } else {
<span class="line-modified"> 989       k = SystemDictionary::find(fd.object_key(), class_loader, protection_domain, THREAD);</span>

 990     }
 991     if (k != NULL) {
<span class="line-modified"> 992       k = k-&gt;array_klass_or_null(fd.dimension());</span>
 993     }
 994   } else {
 995     k = find(class_name, class_loader, protection_domain, THREAD);
 996   }
 997   return k;
 998 }
 999 
1000 // Note: this method is much like resolve_from_stream, but
1001 // does not publish the classes via the SystemDictionary.
1002 // Handles unsafe_DefineAnonymousClass and redefineclasses
1003 // RedefinedClasses do not add to the class hierarchy
1004 InstanceKlass* SystemDictionary::parse_stream(Symbol* class_name,
1005                                               Handle class_loader,
1006                                               Handle protection_domain,
1007                                               ClassFileStream* st,
1008                                               const InstanceKlass* unsafe_anonymous_host,
1009                                               GrowableArray&lt;Handle&gt;* cp_patches,
1010                                               TRAPS) {
1011 
1012   EventClassLoad class_load_start_event;
1013 
1014   ClassLoaderData* loader_data;
1015   if (unsafe_anonymous_host != NULL) {
1016     // Create a new CLD for an unsafe anonymous class, that uses the same class loader
1017     // as the unsafe_anonymous_host
<span class="line-modified">1018     guarantee(oopDesc::equals(unsafe_anonymous_host-&gt;class_loader(), class_loader()), &quot;should be the same&quot;);</span>
1019     loader_data = ClassLoaderData::unsafe_anonymous_class_loader_data(class_loader);
1020   } else {
1021     loader_data = ClassLoaderData::class_loader_data(class_loader());
1022   }
1023 
1024   assert(st != NULL, &quot;invariant&quot;);
1025   assert(st-&gt;need_verify(), &quot;invariant&quot;);
1026 
1027   // Parse stream and create a klass.
1028   // Note that we do this even though this klass might
1029   // already be present in the SystemDictionary, otherwise we would not
1030   // throw potential ClassFormatErrors.
1031 
1032   InstanceKlass* k = KlassFactory::create_from_stream(st,
1033                                                       class_name,
1034                                                       loader_data,
1035                                                       protection_domain,
1036                                                       unsafe_anonymous_host,
1037                                                       cp_patches,
1038                                                       CHECK_NULL);
1039 
1040   if (unsafe_anonymous_host != NULL &amp;&amp; k != NULL) {
1041     // Unsafe anonymous classes must update ClassLoaderData holder (was unsafe_anonymous_host loader)
1042     // so that they can be unloaded when the mirror is no longer referenced.
1043     k-&gt;class_loader_data()-&gt;initialize_holder(Handle(THREAD, k-&gt;java_mirror()));
1044 
1045     {
<span class="line-modified">1046       MutexLocker mu_r(Compile_lock, THREAD);</span>
1047 
1048       // Add to class hierarchy, initialize vtables, and do possible
1049       // deoptimizations.
1050       add_to_hierarchy(k, CHECK_NULL); // No exception, but can block
<span class="line-removed">1051 </span>
<span class="line-removed">1052       // But, do not add to dictionary.</span>
<span class="line-removed">1053 </span>
<span class="line-removed">1054       // compiled code dependencies need to be validated anyway</span>
1055       notice_modification();
1056     }
1057 
1058     // Rewrite and patch constant pool here.
1059     k-&gt;link_class(CHECK_NULL);
1060     if (cp_patches != NULL) {
1061       k-&gt;constants()-&gt;patch_resolved_references(cp_patches);
1062     }
1063 
1064     // If it&#39;s anonymous, initialize it now, since nobody else will.
1065     k-&gt;eager_initialize(CHECK_NULL);
1066 
1067     // notify jvmti
1068     if (JvmtiExport::should_post_class_load()) {
1069         assert(THREAD-&gt;is_Java_thread(), &quot;thread-&gt;is_Java_thread()&quot;);
1070         JvmtiExport::post_class_load((JavaThread *) THREAD, k);
1071     }
1072     if (class_load_start_event.should_commit()) {
1073       post_class_load_event(&amp;class_load_start_event, k, loader_data);
1074     }
</pre>
<hr />
<pre>
1148     InstanceKlass* defined_k = find_or_define_instance_class(h_name, class_loader, k, THREAD);
1149     if (!HAS_PENDING_EXCEPTION &amp;&amp; defined_k != k) {
1150       // If a parallel capable class loader already defined this class, register &#39;k&#39; for cleanup.
1151       assert(defined_k != NULL, &quot;Should have a klass if there&#39;s no exception&quot;);
1152       loader_data-&gt;add_to_deallocate_list(k);
1153       k = defined_k;
1154     }
1155   } else {
1156     define_instance_class(k, THREAD);
1157   }
1158 
1159   // If defining the class throws an exception register &#39;k&#39; for cleanup.
1160   if (HAS_PENDING_EXCEPTION) {
1161     assert(k != NULL, &quot;Must have an instance klass here!&quot;);
1162     loader_data-&gt;add_to_deallocate_list(k);
1163     return NULL;
1164   }
1165 
1166   // Make sure we have an entry in the SystemDictionary on success
1167   debug_only( {
<span class="line-modified">1168     MutexLocker mu(SystemDictionary_lock, THREAD);</span>
1169 
1170     Klass* check = find_class(h_name, k-&gt;class_loader_data());
1171     assert(check == k, &quot;should be present in the dictionary&quot;);
1172   } );
1173 
1174   return k;
1175 }
1176 
1177 #if INCLUDE_CDS
1178 // Load a class for boot loader from the shared spaces. This also
1179 // forces the super class and all interfaces to be loaded.
1180 InstanceKlass* SystemDictionary::load_shared_boot_class(Symbol* class_name,
1181                                                         TRAPS) {
1182   InstanceKlass* ik = SystemDictionaryShared::find_builtin_class(class_name);
1183   if (ik != NULL &amp;&amp; ik-&gt;is_shared_boot_class()) {
1184     return load_shared_class(ik, Handle(), Handle(), NULL, THREAD);
1185   }
1186   return NULL;
1187 }
1188 
1189 // Check if a shared class can be loaded by the specific classloader:
1190 //
1191 // NULL classloader:
1192 //   - Module class from &quot;modules&quot; jimage. ModuleEntry must be defined in the classloader.
1193 //   - Class from -Xbootclasspath/a. The class has no defined PackageEntry, or must
1194 //     be defined in an unnamed module.
1195 bool SystemDictionary::is_shared_class_visible(Symbol* class_name,
1196                                                InstanceKlass* ik,
1197                                                Handle class_loader, TRAPS) {
1198   assert(!ModuleEntryTable::javabase_moduleEntry()-&gt;is_patched(),
1199          &quot;Cannot use sharing if java.base is patched&quot;);
<span class="line-modified">1200   ResourceMark rm;</span>
1201   int path_index = ik-&gt;shared_classpath_index();
1202   ClassLoaderData* loader_data = class_loader_data(class_loader);
1203   if (path_index &lt; 0) {
1204     // path_index &lt; 0 indicates that the class is intended for a custom loader
1205     // and should not be loaded by boot/platform/app loaders
1206     if (loader_data-&gt;is_builtin_class_loader_data()) {
1207       return false;
1208     } else {
1209       return true;
1210     }
1211   }
1212   SharedClassPathEntry* ent =
1213             (SharedClassPathEntry*)FileMapInfo::shared_path(path_index);
1214   if (!Universe::is_module_initialized()) {
1215     assert(ent != NULL &amp;&amp; ent-&gt;is_modules_image(),
1216            &quot;Loading non-bootstrap classes before the module system is initialized&quot;);
1217     assert(class_loader.is_null(), &quot;sanity&quot;);
1218     return true;
1219   }
1220   // Get the pkg_entry from the classloader
1221   TempNewSymbol pkg_name = NULL;
1222   PackageEntry* pkg_entry = NULL;
1223   ModuleEntry* mod_entry = NULL;
<span class="line-removed">1224   const char* pkg_string = NULL;</span>
1225   pkg_name = InstanceKlass::package_from_name(class_name, CHECK_false);
1226   if (pkg_name != NULL) {
<span class="line-removed">1227     pkg_string = pkg_name-&gt;as_C_string();</span>
1228     if (loader_data != NULL) {
1229       pkg_entry = loader_data-&gt;packages()-&gt;lookup_only(pkg_name);
1230     }
1231     if (pkg_entry != NULL) {
1232       mod_entry = pkg_entry-&gt;module();
1233     }
1234   }
1235 
1236   // If the archived class is from a module that has been patched at runtime,
1237   // the class cannot be loaded from the archive.
1238   if (mod_entry != NULL &amp;&amp; mod_entry-&gt;is_patched()) {
1239     return false;
1240   }
1241 
1242   if (class_loader.is_null()) {
1243     assert(ent != NULL, &quot;Shared class for NULL classloader must have valid SharedClassPathEntry&quot;);
1244     // The NULL classloader can load archived class originated from the
1245     // &quot;modules&quot; jimage and the -Xbootclasspath/a. For class from the
1246     // &quot;modules&quot; jimage, the PackageEntry/ModuleEntry must be defined
1247     // by the NULL classloader.
1248     if (mod_entry != NULL) {
1249       // PackageEntry/ModuleEntry is found in the classloader. Check if the
1250       // ModuleEntry&#39;s location agrees with the archived class&#39; origination.
1251       if (ent-&gt;is_modules_image() &amp;&amp; mod_entry-&gt;location()-&gt;starts_with(&quot;jrt:&quot;)) {
1252         return true; // Module class from the &quot;module&quot; jimage
1253       }
1254     }
1255 
1256     // If the archived class is not from the &quot;module&quot; jimage, the class can be
1257     // loaded by the NULL classloader if
1258     //
1259     // 1. the class is from the unamed package
1260     // 2. or, the class is not from a module defined in the NULL classloader
1261     // 3. or, the class is from an unamed module
1262     if (!ent-&gt;is_modules_image() &amp;&amp; ik-&gt;is_shared_boot_class()) {
1263       // the class is from the -Xbootclasspath/a
<span class="line-modified">1264       if (pkg_string == NULL ||</span>
1265           pkg_entry == NULL ||
1266           pkg_entry-&gt;in_unnamed_module()) {
1267         assert(mod_entry == NULL ||
1268                mod_entry == loader_data-&gt;unnamed_module(),
1269                &quot;the unnamed module is not defined in the classloader&quot;);
1270         return true;
1271       }
1272     }
1273     return false;
1274   } else {
1275     bool res = SystemDictionaryShared::is_shared_class_visible_for_classloader(
<span class="line-modified">1276               ik, class_loader, pkg_string, pkg_name,</span>
<span class="line-removed">1277               pkg_entry, mod_entry, CHECK_(false));</span>
1278     return res;
1279   }
1280 }
1281 
1282 InstanceKlass* SystemDictionary::load_shared_class(InstanceKlass* ik,
1283                                                    Handle class_loader,
1284                                                    Handle protection_domain,
1285                                                    const ClassFileStream *cfs,
1286                                                    TRAPS) {



1287 
<span class="line-modified">1288   if (ik != NULL) {</span>
<span class="line-modified">1289     Symbol* class_name = ik-&gt;name();</span>



1290 
<span class="line-modified">1291     bool visible = is_shared_class_visible(</span>
<span class="line-modified">1292                             class_name, ik, class_loader, CHECK_NULL);</span>
<span class="line-modified">1293     if (!visible) {</span>











1294       return NULL;


1295     }

1296 
<span class="line-modified">1297     // Resolve the superclass and interfaces. They must be the same</span>
<span class="line-modified">1298     // as in dump time, because the layout of &lt;ik&gt; depends on</span>
<span class="line-modified">1299     // the specific layout of ik-&gt;super() and ik-&gt;local_interfaces().</span>
<span class="line-modified">1300     //</span>
<span class="line-modified">1301     // If unexpected superclass or interfaces are found, we cannot</span>
<span class="line-modified">1302     // load &lt;ik&gt; from the shared archive.</span>
<span class="line-modified">1303 </span>
<span class="line-modified">1304     if (ik-&gt;super() != NULL) {</span>
<span class="line-modified">1305       Symbol*  cn = ik-&gt;super()-&gt;name();</span>
<span class="line-modified">1306       Klass *s = resolve_super_or_fail(class_name, cn,</span>
<span class="line-modified">1307                                        class_loader, protection_domain, true, CHECK_NULL);</span>
<span class="line-modified">1308       if (s != ik-&gt;super()) {</span>
<span class="line-removed">1309         // The dynamically resolved super class is not the same as the one we used during dump time,</span>
<span class="line-removed">1310         // so we cannot use ik.</span>
<span class="line-removed">1311         return NULL;</span>
<span class="line-removed">1312       } else {</span>
<span class="line-removed">1313         assert(s-&gt;is_shared(), &quot;must be&quot;);</span>
<span class="line-removed">1314       }</span>
<span class="line-removed">1315     }</span>
<span class="line-removed">1316 </span>
<span class="line-removed">1317     Array&lt;InstanceKlass*&gt;* interfaces = ik-&gt;local_interfaces();</span>
<span class="line-removed">1318     int num_interfaces = interfaces-&gt;length();</span>
<span class="line-removed">1319     for (int index = 0; index &lt; num_interfaces; index++) {</span>
<span class="line-removed">1320       InstanceKlass* k = interfaces-&gt;at(index);</span>
<span class="line-removed">1321       Symbol* name  = k-&gt;name();</span>
<span class="line-removed">1322       Klass* i = resolve_super_or_fail(class_name, name, class_loader, protection_domain, false, CHECK_NULL);</span>
<span class="line-removed">1323       if (k != i) {</span>
<span class="line-removed">1324         // The dynamically resolved interface class is not the same as the one we used during dump time,</span>
<span class="line-removed">1325         // so we cannot use ik.</span>
<span class="line-removed">1326         return NULL;</span>
<span class="line-removed">1327       } else {</span>
<span class="line-removed">1328         assert(i-&gt;is_shared(), &quot;must be&quot;);</span>
<span class="line-removed">1329       }</span>
1330     }

1331 
<span class="line-modified">1332     InstanceKlass* new_ik = KlassFactory::check_shared_class_file_load_hook(</span>
<span class="line-modified">1333         ik, class_name, class_loader, protection_domain, cfs, CHECK_NULL);</span>
<span class="line-modified">1334     if (new_ik != NULL) {</span>
<span class="line-modified">1335       // The class is changed by CFLH. Return the new class. The shared class is</span>
<span class="line-modified">1336       // not used.</span>
<span class="line-modified">1337       return new_ik;</span>
<span class="line-modified">1338     }</span>
1339 
<span class="line-modified">1340     // Adjust methods to recover missing data.  They need addresses for</span>
<span class="line-modified">1341     // interpreter entry points and their default native method address</span>
<span class="line-modified">1342     // must be reset.</span>
1343 
<span class="line-modified">1344     // Updating methods must be done under a lock so multiple</span>
<span class="line-modified">1345     // threads don&#39;t update these in parallel</span>
<span class="line-modified">1346     //</span>
<span class="line-modified">1347     // Shared classes are all currently loaded by either the bootstrap or</span>
<span class="line-modified">1348     // internal parallel class loaders, so this will never cause a deadlock</span>
<span class="line-modified">1349     // on a custom class loader lock.</span>
1350 
<span class="line-modified">1351     ClassLoaderData* loader_data = ClassLoaderData::class_loader_data(class_loader());</span>
<span class="line-modified">1352     {</span>
<span class="line-modified">1353       HandleMark hm(THREAD);</span>
<span class="line-modified">1354       Handle lockObject = compute_loader_lock_object(class_loader, THREAD);</span>
<span class="line-modified">1355       check_loader_lock_contention(lockObject, THREAD);</span>
<span class="line-modified">1356       ObjectLocker ol(lockObject, THREAD, true);</span>
<span class="line-modified">1357       // prohibited package check assumes all classes loaded from archive call</span>
<span class="line-modified">1358       // restore_unshareable_info which calls ik-&gt;set_package()</span>
<span class="line-modified">1359       ik-&gt;restore_unshareable_info(loader_data, protection_domain, CHECK_NULL);</span>
<span class="line-modified">1360     }</span>
1361 
<span class="line-modified">1362     ik-&gt;print_class_load_logging(loader_data, NULL, NULL);</span>
1363 
<span class="line-modified">1364     // For boot loader, ensure that GetSystemPackage knows that a class in this</span>
<span class="line-modified">1365     // package was loaded.</span>
<span class="line-modified">1366     if (class_loader.is_null()) {</span>
<span class="line-modified">1367       int path_index = ik-&gt;shared_classpath_index();</span>
<span class="line-modified">1368       ResourceMark rm;</span>
<span class="line-modified">1369       ClassLoader::add_package(ik-&gt;name()-&gt;as_C_string(), path_index, THREAD);</span>
<span class="line-modified">1370     }</span>
1371 
<span class="line-modified">1372     if (DumpLoadedClassList != NULL &amp;&amp; classlist_file-&gt;is_open()) {</span>
<span class="line-modified">1373       // Only dump the classes that can be stored into CDS archive</span>
<span class="line-modified">1374       if (SystemDictionaryShared::is_sharing_possible(loader_data)) {</span>
<span class="line-modified">1375         ResourceMark rm(THREAD);</span>
<span class="line-modified">1376         classlist_file-&gt;print_cr(&quot;%s&quot;, ik-&gt;name()-&gt;as_C_string());</span>
<span class="line-modified">1377         classlist_file-&gt;flush();</span>
<span class="line-removed">1378       }</span>
1379     }

1380 
<span class="line-modified">1381     // notify a class loaded from shared object</span>
<span class="line-modified">1382     ClassLoadingService::notify_class_loaded(ik, true /* shared class */);</span>
1383 
<span class="line-modified">1384     ik-&gt;set_has_passed_fingerprint_check(false);</span>
<span class="line-modified">1385     if (UseAOT &amp;&amp; ik-&gt;supers_have_passed_fingerprint_checks()) {</span>
<span class="line-modified">1386       uint64_t aot_fp = AOTLoader::get_saved_fingerprint(ik);</span>
<span class="line-modified">1387       uint64_t cds_fp = ik-&gt;get_stored_fingerprint();</span>
<span class="line-modified">1388       if (aot_fp != 0 &amp;&amp; aot_fp == cds_fp) {</span>
<span class="line-modified">1389         // This class matches with a class saved in an AOT library</span>
<span class="line-modified">1390         ik-&gt;set_has_passed_fingerprint_check(true);</span>
<span class="line-modified">1391       } else {</span>
<span class="line-modified">1392         ResourceMark rm;</span>

1393         log_info(class, fingerprint)(&quot;%s :  expected = &quot; PTR64_FORMAT &quot; actual = &quot; PTR64_FORMAT, ik-&gt;external_name(), aot_fp, cds_fp);
1394       }
1395     }
1396   }

1397   return ik;
1398 }
1399 #endif // INCLUDE_CDS
1400 
1401 InstanceKlass* SystemDictionary::load_instance_class(Symbol* class_name, Handle class_loader, TRAPS) {
1402 
1403   if (class_loader.is_null()) {
<span class="line-modified">1404     ResourceMark rm;</span>
1405     PackageEntry* pkg_entry = NULL;
1406     bool search_only_bootloader_append = false;
1407     ClassLoaderData *loader_data = class_loader_data(class_loader);
1408 
1409     // Find the package in the boot loader&#39;s package entry table.
1410     TempNewSymbol pkg_name = InstanceKlass::package_from_name(class_name, CHECK_NULL);
1411     if (pkg_name != NULL) {
1412       pkg_entry = loader_data-&gt;packages()-&gt;lookup_only(pkg_name);
1413     }
1414 
1415     // Prior to attempting to load the class, enforce the boot loader&#39;s
1416     // visibility boundaries.
1417     if (!Universe::is_module_initialized()) {
1418       // During bootstrapping, prior to module initialization, any
1419       // class attempting to be loaded must be checked against the
1420       // java.base packages in the boot loader&#39;s PackageEntryTable.
1421       // No class outside of java.base is allowed to be loaded during
1422       // this bootstrapping window.
1423       if (pkg_entry == NULL || pkg_entry-&gt;in_unnamed_module()) {
1424         // Class is either in the unnamed package or in
</pre>
<hr />
<pre>
1431         if (ModuleEntryTable::javabase_defined()) {
1432           return NULL;
1433         }
1434       } else {
1435         // Check that the class&#39; package is defined within java.base.
1436         ModuleEntry* mod_entry = pkg_entry-&gt;module();
1437         Symbol* mod_entry_name = mod_entry-&gt;name();
1438         if (mod_entry_name-&gt;fast_compare(vmSymbols::java_base()) != 0) {
1439           return NULL;
1440         }
1441       }
1442     } else {
1443       // After the module system has been initialized, check if the class&#39;
1444       // package is in a module defined to the boot loader.
1445       if (pkg_name == NULL || pkg_entry == NULL || pkg_entry-&gt;in_unnamed_module()) {
1446         // Class is either in the unnamed package, in a named package
1447         // within a module not defined to the boot loader or in a
1448         // a named package within the unnamed module.  In all cases,
1449         // limit visibility to search for the class only in the boot
1450         // loader&#39;s append path.





1451         search_only_bootloader_append = true;
1452       }
1453     }
1454 
1455     // Prior to bootstrapping&#39;s module initialization, never load a class outside
1456     // of the boot loader&#39;s module path
1457     assert(Universe::is_module_initialized() ||
1458            !search_only_bootloader_append,
1459            &quot;Attempt to load a class outside of boot loader&#39;s module path&quot;);
1460 
1461     // Search for classes in the CDS archive.
1462     InstanceKlass* k = NULL;
1463     {
1464 #if INCLUDE_CDS
1465       PerfTraceTime vmtimer(ClassLoader::perf_shared_classload_time());
1466       k = load_shared_boot_class(class_name, THREAD);
1467 #endif
1468     }
1469 
1470     if (k == NULL) {
</pre>
<hr />
<pre>
1564  if (!class_loader_h.is_null() &amp;&amp; !is_parallelCapable(class_loader_h)) {
1565     assert(ObjectSynchronizer::current_thread_holds_lock((JavaThread*)THREAD,
1566          compute_loader_lock_object(class_loader_h, THREAD)),
1567          &quot;define called without lock&quot;);
1568   }
1569 
1570   // Check class-loading constraints. Throw exception if violation is detected.
1571   // Grabs and releases SystemDictionary_lock
1572   // The check_constraints/find_class call and update_dictionary sequence
1573   // must be &quot;atomic&quot; for a specific class/classloader pair so we never
1574   // define two different instanceKlasses for that class/classloader pair.
1575   // Existing classloaders will call define_instance_class with the
1576   // classloader lock held
1577   // Parallel classloaders will call find_or_define_instance_class
1578   // which will require a token to perform the define class
1579   Symbol*  name_h = k-&gt;name();
1580   Dictionary* dictionary = loader_data-&gt;dictionary();
1581   unsigned int d_hash = dictionary-&gt;compute_hash(name_h);
1582   check_constraints(d_hash, k, class_loader_h, true, CHECK);
1583 
<span class="line-modified">1584   // Register class just loaded with class loader (placed in Vector)</span>
1585   // Note we do this before updating the dictionary, as this can
1586   // fail with an OutOfMemoryError (if it does, we will *not* put this
1587   // class in the dictionary and will not update the class hierarchy).
1588   // JVMTI FollowReferences needs to find the classes this way.
1589   if (k-&gt;class_loader() != NULL) {
1590     methodHandle m(THREAD, Universe::loader_addClass_method());
1591     JavaValue result(T_VOID);
1592     JavaCallArguments args(class_loader_h);
1593     args.push_oop(Handle(THREAD, k-&gt;java_mirror()));
1594     JavaCalls::call(&amp;result, m, &amp;args, CHECK);
1595   }
1596 
1597   // Add the new class. We need recompile lock during update of CHA.
1598   {
1599     unsigned int p_hash = placeholders()-&gt;compute_hash(name_h);
1600     int p_index = placeholders()-&gt;hash_to_index(p_hash);
1601 
<span class="line-modified">1602     MutexLocker mu_r(Compile_lock, THREAD);</span>
1603 
1604     // Add to class hierarchy, initialize vtables, and do possible
1605     // deoptimizations.
1606     add_to_hierarchy(k, CHECK); // No exception, but can block
1607 
1608     // Add to systemDictionary - so other classes can see it.
1609     // Grabs and releases SystemDictionary_lock
1610     update_dictionary(d_hash, p_index, p_hash,
1611                       k, class_loader_h, THREAD);
1612   }
1613   k-&gt;eager_initialize(THREAD);
1614 
1615   // notify jvmti
1616   if (JvmtiExport::should_post_class_load()) {
1617       assert(THREAD-&gt;is_Java_thread(), &quot;thread-&gt;is_Java_thread()&quot;);
1618       JvmtiExport::post_class_load((JavaThread *) THREAD, k);
1619 
1620   }
1621   post_class_define_event(k, loader_data);
1622 }
</pre>
<hr />
<pre>
1639 // Note: VM callers should ensure consistency of k/class_name,class_loader
1640 // Be careful when modifying this code: once you have run
1641 // placeholders()-&gt;find_and_add(PlaceholderTable::DEFINE_CLASS),
1642 // you need to find_and_remove it before returning.
1643 // So be careful to not exit with a CHECK_ macro betweeen these calls.
1644 InstanceKlass* SystemDictionary::find_or_define_instance_class(Symbol* class_name, Handle class_loader,
1645                                                                InstanceKlass* k, TRAPS) {
1646 
1647   Symbol*  name_h = k-&gt;name(); // passed in class_name may be null
1648   ClassLoaderData* loader_data = class_loader_data(class_loader);
1649   Dictionary* dictionary = loader_data-&gt;dictionary();
1650 
1651   unsigned int d_hash = dictionary-&gt;compute_hash(name_h);
1652 
1653   // Hold SD lock around find_class and placeholder creation for DEFINE_CLASS
1654   unsigned int p_hash = placeholders()-&gt;compute_hash(name_h);
1655   int p_index = placeholders()-&gt;hash_to_index(p_hash);
1656   PlaceholderEntry* probe;
1657 
1658   {
<span class="line-modified">1659     MutexLocker mu(SystemDictionary_lock, THREAD);</span>
1660     // First check if class already defined
1661     if (is_parallelDefine(class_loader)) {
1662       InstanceKlass* check = find_class(d_hash, name_h, dictionary);
1663       if (check != NULL) {
1664         return check;
1665       }
1666     }
1667 
1668     // Acquire define token for this class/classloader
1669     probe = placeholders()-&gt;find_and_add(p_index, p_hash, name_h, loader_data, PlaceholderTable::DEFINE_CLASS, NULL, THREAD);
1670     // Wait if another thread defining in parallel
1671     // All threads wait - even those that will throw duplicate class: otherwise
1672     // caller is surprised by LinkageError: duplicate, but findLoadedClass fails
1673     // if other thread has not finished updating dictionary
1674     while (probe-&gt;definer() != NULL) {
1675       SystemDictionary_lock-&gt;wait();
1676     }
1677     // Only special cases allow parallel defines and can use other thread&#39;s results
1678     // Other cases fall through, and may run into duplicate defines
1679     // caught by finding an entry in the SystemDictionary
1680     if (is_parallelDefine(class_loader) &amp;&amp; (probe-&gt;instance_klass() != NULL)) {
1681         placeholders()-&gt;find_and_remove(p_index, p_hash, name_h, loader_data, PlaceholderTable::DEFINE_CLASS, THREAD);
1682         SystemDictionary_lock-&gt;notify_all();
1683 #ifdef ASSERT
1684         InstanceKlass* check = find_class(d_hash, name_h, dictionary);
1685         assert(check != NULL, &quot;definer missed recording success&quot;);
1686 #endif
1687         return probe-&gt;instance_klass();
1688     } else {
1689       // This thread will define the class (even if earlier thread tried and had an error)
1690       probe-&gt;set_definer(THREAD);
1691     }
1692   }
1693 
1694   define_instance_class(k, THREAD);
1695 
1696   Handle linkage_exception = Handle(); // null handle
1697 
1698   // definer must notify any waiting threads
1699   {
<span class="line-modified">1700     MutexLocker mu(SystemDictionary_lock, THREAD);</span>
1701     PlaceholderEntry* probe = placeholders()-&gt;get_entry(p_index, p_hash, name_h, loader_data);
1702     assert(probe != NULL, &quot;DEFINE_CLASS placeholder lost?&quot;);
1703     if (probe != NULL) {
1704       if (HAS_PENDING_EXCEPTION) {
1705         linkage_exception = Handle(THREAD,PENDING_EXCEPTION);
1706         CLEAR_PENDING_EXCEPTION;
1707       } else {
1708         probe-&gt;set_instance_klass(k);
1709       }
1710       probe-&gt;set_definer(NULL);
1711       placeholders()-&gt;find_and_remove(p_index, p_hash, name_h, loader_data, PlaceholderTable::DEFINE_CLASS, THREAD);
1712       SystemDictionary_lock-&gt;notify_all();
1713     }
1714   }
1715 
1716   // Can&#39;t throw exception while holding lock due to rank ordering
1717   if (linkage_exception() != NULL) {
1718     THROW_OOP_(linkage_exception(), NULL); // throws exception and returns
1719   }
1720 
</pre>
<hr />
<pre>
1728   } else {
1729     return class_loader;
1730   }
1731 }
1732 
1733 // This method is added to check how often we have to wait to grab loader
1734 // lock. The results are being recorded in the performance counters defined in
1735 // ClassLoader::_sync_systemLoaderLockContentionRate and
1736 // ClassLoader::_sync_nonSystemLoaderLockConteionRate.
1737 void SystemDictionary::check_loader_lock_contention(Handle loader_lock, TRAPS) {
1738   if (!UsePerfData) {
1739     return;
1740   }
1741 
1742   assert(!loader_lock.is_null(), &quot;NULL lock object&quot;);
1743 
1744   if (ObjectSynchronizer::query_lock_ownership((JavaThread*)THREAD, loader_lock)
1745       == ObjectSynchronizer::owner_other) {
1746     // contention will likely happen, so increment the corresponding
1747     // contention counter.
<span class="line-modified">1748     if (oopDesc::equals(loader_lock(), _system_loader_lock_obj)) {</span>
1749       ClassLoader::sync_systemLoaderLockContentionRate()-&gt;inc();
1750     } else {
1751       ClassLoader::sync_nonSystemLoaderLockContentionRate()-&gt;inc();
1752     }
1753   }
1754 }
1755 
1756 // ----------------------------------------------------------------------------
1757 // Lookup
1758 
1759 InstanceKlass* SystemDictionary::find_class(unsigned int hash,
1760                                             Symbol* class_name,
1761                                             Dictionary* dictionary) {
1762   assert_locked_or_safepoint(SystemDictionary_lock);
1763   int index = dictionary-&gt;hash_to_index(hash);
1764   return dictionary-&gt;find_class(index, hash, class_name);
1765 }
1766 
1767 
1768 // Basic find on classes in the midst of being loaded
</pre>
<hr />
<pre>
1815   // Now flush all code that depended on old class hierarchy.
1816   // Note: must be done *after* linking k into the hierarchy (was bug 12/9/97)
1817   CodeCache::flush_dependents_on(k);
1818 }
1819 
1820 // ----------------------------------------------------------------------------
1821 // GC support
1822 
1823 // Assumes classes in the SystemDictionary are only unloaded at a safepoint
1824 // Note: anonymous classes are not in the SD.
1825 bool SystemDictionary::do_unloading(GCTimer* gc_timer) {
1826 
1827   bool unloading_occurred;
1828   bool is_concurrent = !SafepointSynchronize::is_at_safepoint();
1829   {
1830     GCTraceTime(Debug, gc, phases) t(&quot;ClassLoaderData&quot;, gc_timer);
1831     assert_locked_or_safepoint(ClassLoaderDataGraph_lock);  // caller locks.
1832     // First, mark for unload all ClassLoaderData referencing a dead class loader.
1833     unloading_occurred = ClassLoaderDataGraph::do_unloading();
1834     if (unloading_occurred) {
<span class="line-modified">1835       MutexLockerEx ml2(is_concurrent ? Module_lock : NULL);</span>
1836       JFR_ONLY(Jfr::on_unloading_classes();)
1837 
<span class="line-modified">1838       MutexLockerEx ml1(is_concurrent ? SystemDictionary_lock : NULL);</span>
1839       ClassLoaderDataGraph::clean_module_and_package_info();
1840       constraints()-&gt;purge_loader_constraints();
1841       resolution_errors()-&gt;purge_resolution_errors();
1842     }
1843   }
1844 
1845   GCTraceTime(Debug, gc, phases) t(&quot;Trigger cleanups&quot;, gc_timer);
<span class="line-removed">1846   // Trigger cleaning the ResolvedMethodTable even if no unloading occurred.</span>
<span class="line-removed">1847   ResolvedMethodTable::trigger_cleanup();</span>
1848 
1849   if (unloading_occurred) {
1850     SymbolTable::trigger_cleanup();
1851 
1852     // Oops referenced by the protection domain cache table may get unreachable independently
1853     // of the class loader (eg. cached protection domain oops). So we need to
1854     // explicitly unlink them here.
1855     // All protection domain oops are linked to the caller class, so if nothing
1856     // unloads, this is not needed.
1857     _pd_cache_table-&gt;trigger_cleanup();
1858   }
1859 
1860   return unloading_occurred;
1861 }
1862 
<span class="line-modified">1863 void SystemDictionary::oops_do(OopClosure* f) {</span>
1864   f-&gt;do_oop(&amp;_java_system_loader);
1865   f-&gt;do_oop(&amp;_java_platform_loader);
1866   f-&gt;do_oop(&amp;_system_loader_lock_obj);
1867   CDS_ONLY(SystemDictionaryShared::oops_do(f);)
1868 
1869   // Visit extra methods
1870   invoke_method_table()-&gt;oops_do(f);




1871 }
1872 
1873 // CDS: scan and relocate all classes referenced by _well_known_klasses[].
1874 void SystemDictionary::well_known_klasses_do(MetaspaceClosure* it) {
1875   for (int id = FIRST_WKID; id &lt; WKID_LIMIT; id++) {
1876     it-&gt;push(well_known_klass_addr((WKID)id));
1877   }
1878 }
1879 
1880 void SystemDictionary::methods_do(void f(Method*)) {
1881   // Walk methods in loaded classes
1882   MutexLocker ml(ClassLoaderDataGraph_lock);
1883   ClassLoaderDataGraph::methods_do(f);
1884   // Walk method handle intrinsics
1885   invoke_method_table()-&gt;methods_do(f);
1886 }
1887 
1888 // ----------------------------------------------------------------------------
1889 // Initialization
1890 
1891 void SystemDictionary::initialize(TRAPS) {
1892   // Allocate arrays
1893   _placeholders        = new PlaceholderTable(_placeholder_table_size);
<span class="line-removed">1894   _number_of_modifications = 0;</span>
1895   _loader_constraints  = new LoaderConstraintTable(_loader_constraint_size);
1896   _resolution_errors   = new ResolutionErrorTable(_resolution_error_size);
1897   _invoke_method_table = new SymbolPropertyTable(_invoke_method_size);
1898   _pd_cache_table = new ProtectionDomainCacheTable(defaultProtectionDomainCacheSize);
1899 
1900   // Allocate private object used as system class loader lock
1901   _system_loader_lock_obj = oopFactory::new_intArray(0, CHECK);
1902   // Initialize basic classes
1903   resolve_well_known_classes(CHECK);
1904 }
1905 
1906 // Compact table of directions on the initialization of klasses:
1907 static const short wk_init_info[] = {
1908   #define WK_KLASS_INIT_INFO(name, symbol) \
1909     ((short)vmSymbols::VM_SYMBOL_ENUM_NAME(symbol)),
1910 
1911   WK_KLASSES_DO(WK_KLASS_INIT_INFO)
1912   #undef WK_KLASS_INIT_INFO
1913   0
1914 };
1915 
1916 #ifdef ASSERT
1917 bool SystemDictionary::is_well_known_klass(Symbol* class_name) {
1918   int sid;
1919   for (int i = 0; (sid = wk_init_info[i]) != 0; i++) {
1920     Symbol* symbol = vmSymbols::symbol_at((vmSymbols::SID)sid);
1921     if (class_name == symbol) {
1922       return true;
1923     }
1924   }
1925   return false;
1926 }
1927 #endif
1928 
1929 bool SystemDictionary::resolve_wk_klass(WKID id, TRAPS) {
1930   assert(id &gt;= (int)FIRST_WKID &amp;&amp; id &lt; (int)WKID_LIMIT, &quot;oob&quot;);
1931   int sid = wk_init_info[id - FIRST_WKID];
1932   Symbol* symbol = vmSymbols::symbol_at((vmSymbols::SID)sid);
1933   InstanceKlass** klassp = &amp;_well_known_klasses[id];
1934 
<span class="line-removed">1935 </span>
<span class="line-removed">1936 #if INCLUDE_JVMCI</span>
<span class="line-removed">1937   if (id &gt;= FIRST_JVMCI_WKID) {</span>
<span class="line-removed">1938     assert(EnableJVMCI, &quot;resolve JVMCI classes only when EnableJVMCI is true&quot;);</span>
<span class="line-removed">1939   }</span>
<span class="line-removed">1940 #endif</span>
<span class="line-removed">1941 </span>
1942   if ((*klassp) == NULL) {
1943     Klass* k = resolve_or_fail(symbol, true, CHECK_0);
1944     (*klassp) = InstanceKlass::cast(k);
1945   }
1946   return ((*klassp) != NULL);
1947 }
1948 
1949 void SystemDictionary::resolve_wk_klasses_until(WKID limit_id, WKID &amp;start_id, TRAPS) {
1950   assert((int)start_id &lt;= (int)limit_id, &quot;IDs are out of order!&quot;);
1951   for (int id = (int)start_id; id &lt; (int)limit_id; id++) {
1952     assert(id &gt;= (int)FIRST_WKID &amp;&amp; id &lt; (int)WKID_LIMIT, &quot;oob&quot;);
1953     resolve_wk_klass((WKID)id, CHECK);
1954   }
1955 
1956   // move the starting value forward to the limit:
1957   start_id = limit_id;
1958 }
1959 
1960 void SystemDictionary::resolve_well_known_classes(TRAPS) {
1961   assert(WK_KLASS(Object_klass) == NULL, &quot;well-known classes should only be initialized once&quot;);
</pre>
<hr />
<pre>
1979     // resolved_references array object).
1980     //
1981     // HeapShared::fixup_mapped_heap_regions() fills the empty
1982     // spaces in the archived heap regions and may use
1983     // SystemDictionary::Object_klass(), so we can do this only after
1984     // Object_klass is resolved. See the above resolve_wk_klasses_through()
1985     // call. No mirror objects are accessed/restored in the above call.
1986     // Mirrors are restored after java.lang.Class is loaded.
1987     HeapShared::fixup_mapped_heap_regions();
1988 
1989     // Initialize the constant pool for the Object_class
1990     assert(Object_klass()-&gt;is_shared(), &quot;must be&quot;);
1991     Object_klass()-&gt;constants()-&gt;restore_unshareable_info(CHECK);
1992     resolve_wk_klasses_through(WK_KLASS_ENUM_NAME(Class_klass), scan, CHECK);
1993   } else
1994 #endif
1995   {
1996     resolve_wk_klasses_through(WK_KLASS_ENUM_NAME(Class_klass), scan, CHECK);
1997   }
1998 




1999   // Calculate offsets for String and Class classes since they are loaded and
2000   // can be used after this point.
2001   java_lang_String::compute_offsets();
2002   java_lang_Class::compute_offsets();
2003 
2004   // Fixup mirrors for classes loaded before java.lang.Class.
2005   // These calls iterate over the objects currently in the perm gen
2006   // so calling them at this point is matters (not before when there
2007   // are fewer objects and not later after there are more objects
2008   // in the perm gen.
2009   Universe::initialize_basic_type_mirrors(CHECK);
2010   Universe::fixup_mirrors(CHECK);
2011 
2012   // do a bunch more:
2013   resolve_wk_klasses_through(WK_KLASS_ENUM_NAME(Reference_klass), scan, CHECK);
2014 
2015   // Preload ref klasses and set reference types
<span class="line-modified">2016   InstanceKlass::cast(WK_KLASS(Reference_klass))-&gt;set_reference_type(REF_OTHER);</span>
2017   InstanceRefKlass::update_nonstatic_oop_maps(WK_KLASS(Reference_klass));
2018 
2019   resolve_wk_klasses_through(WK_KLASS_ENUM_NAME(PhantomReference_klass), scan, CHECK);
<span class="line-modified">2020   InstanceKlass::cast(WK_KLASS(SoftReference_klass))-&gt;set_reference_type(REF_SOFT);</span>
<span class="line-modified">2021   InstanceKlass::cast(WK_KLASS(WeakReference_klass))-&gt;set_reference_type(REF_WEAK);</span>
<span class="line-modified">2022   InstanceKlass::cast(WK_KLASS(FinalReference_klass))-&gt;set_reference_type(REF_FINAL);</span>
<span class="line-modified">2023   InstanceKlass::cast(WK_KLASS(PhantomReference_klass))-&gt;set_reference_type(REF_PHANTOM);</span>
2024 
2025   // JSR 292 classes
2026   WKID jsr292_group_start = WK_KLASS_ENUM_NAME(MethodHandle_klass);
2027   WKID jsr292_group_end   = WK_KLASS_ENUM_NAME(VolatileCallSite_klass);
2028   resolve_wk_klasses_until(jsr292_group_start, scan, CHECK);
2029   resolve_wk_klasses_through(jsr292_group_end, scan, CHECK);
<span class="line-modified">2030   WKID last = NOT_JVMCI(WKID_LIMIT) JVMCI_ONLY(FIRST_JVMCI_WKID);</span>
2031   resolve_wk_klasses_until(last, scan, CHECK);
2032 
2033   _box_klasses[T_BOOLEAN] = WK_KLASS(Boolean_klass);
2034   _box_klasses[T_CHAR]    = WK_KLASS(Character_klass);
2035   _box_klasses[T_FLOAT]   = WK_KLASS(Float_klass);
2036   _box_klasses[T_DOUBLE]  = WK_KLASS(Double_klass);
2037   _box_klasses[T_BYTE]    = WK_KLASS(Byte_klass);
2038   _box_klasses[T_SHORT]   = WK_KLASS(Short_klass);
2039   _box_klasses[T_INT]     = WK_KLASS(Integer_klass);
2040   _box_klasses[T_LONG]    = WK_KLASS(Long_klass);
2041   //_box_klasses[T_OBJECT]  = WK_KLASS(object_klass);
2042   //_box_klasses[T_ARRAY]   = WK_KLASS(object_klass);
2043 
<span class="line-removed">2044   { // Compute whether we should use checkPackageAccess or NOT</span>
<span class="line-removed">2045     Method* method = InstanceKlass::cast(ClassLoader_klass())-&gt;find_method(vmSymbols::checkPackageAccess_name(), vmSymbols::class_protectiondomain_signature());</span>
<span class="line-removed">2046     _has_checkPackageAccess = (method != NULL);</span>
<span class="line-removed">2047   }</span>
<span class="line-removed">2048 </span>
2049 #ifdef ASSERT
2050   if (UseSharedSpaces) {
2051     assert(JvmtiExport::is_early_phase(),
2052            &quot;All well known classes must be resolved in JVMTI early phase&quot;);
2053     for (int i = FIRST_WKID; i &lt; last; i++) {
2054       InstanceKlass* k = _well_known_klasses[i];
2055       assert(k-&gt;is_shared(), &quot;must not be replaced by JVMTI class file load hook&quot;);
2056     }
2057   }
2058 #endif
2059 }
2060 
2061 // Tells if a given klass is a box (wrapper class, such as java.lang.Integer).
2062 // If so, returns the basic type it holds.  If not, returns T_OBJECT.
2063 BasicType SystemDictionary::box_klass_type(Klass* k) {
2064   assert(k != NULL, &quot;&quot;);
2065   for (int i = T_BOOLEAN; i &lt; T_VOID+1; i++) {
2066     if (_box_klasses[i] == k)
2067       return (BasicType)i;
2068   }
</pre>
<hr />
<pre>
2073 // found in the OOPSLA&#39;98 paper &quot;Dynamic Class Loading in the Java
2074 // Virtual Machine&quot; by Sheng Liang and Gilad Bracha.  The basic idea is
2075 // that the dictionary needs to maintain a set of contraints that
2076 // must be satisfied by all classes in the dictionary.
2077 // if defining is true, then LinkageError if already in dictionary
2078 // if initiating loader, then ok if InstanceKlass matches existing entry
2079 
2080 void SystemDictionary::check_constraints(unsigned int d_hash,
2081                                          InstanceKlass* k,
2082                                          Handle class_loader,
2083                                          bool defining,
2084                                          TRAPS) {
2085   ResourceMark rm(THREAD);
2086   stringStream ss;
2087   bool throwException = false;
2088 
2089   {
2090     Symbol *name = k-&gt;name();
2091     ClassLoaderData *loader_data = class_loader_data(class_loader);
2092 
<span class="line-modified">2093     MutexLocker mu(SystemDictionary_lock, THREAD);</span>
2094 
2095     InstanceKlass* check = find_class(d_hash, name, loader_data-&gt;dictionary());
2096     if (check != NULL) {
2097       // If different InstanceKlass - duplicate class definition,
2098       // else - ok, class loaded by a different thread in parallel.
2099       // We should only have found it if it was done loading and ok to use.
2100       // The dictionary only holds instance classes, placeholders
2101       // also hold array classes.
2102 
2103       assert(check-&gt;is_instance_klass(), &quot;noninstance in systemdictionary&quot;);
2104       if ((defining == true) || (k != check)) {
2105         throwException = true;
2106         ss.print(&quot;loader %s&quot;, loader_data-&gt;loader_name_and_id());
2107         ss.print(&quot; attempted duplicate %s definition for %s. (%s)&quot;,
2108                  k-&gt;external_kind(), k-&gt;external_name(), k-&gt;class_in_module_of_loader(false, true));
2109       } else {
2110         return;
2111       }
2112     }
2113 
</pre>
<hr />
<pre>
2138   // Throw error now if needed (cannot throw while holding
2139   // SystemDictionary_lock because of rank ordering)
2140   if (throwException == true) {
2141     THROW_MSG(vmSymbols::java_lang_LinkageError(), ss.as_string());
2142   }
2143 }
2144 
2145 // Update class loader data dictionary - done after check_constraint and add_to_hierachy
2146 // have been called.
2147 void SystemDictionary::update_dictionary(unsigned int d_hash,
2148                                          int p_index, unsigned int p_hash,
2149                                          InstanceKlass* k,
2150                                          Handle class_loader,
2151                                          TRAPS) {
2152   // Compile_lock prevents systemDictionary updates during compilations
2153   assert_locked_or_safepoint(Compile_lock);
2154   Symbol*  name  = k-&gt;name();
2155   ClassLoaderData *loader_data = class_loader_data(class_loader);
2156 
2157   {
<span class="line-modified">2158     MutexLocker mu1(SystemDictionary_lock, THREAD);</span>
<span class="line-removed">2159 </span>
<span class="line-removed">2160     // See whether biased locking is enabled and if so set it for this</span>
<span class="line-removed">2161     // klass.</span>
<span class="line-removed">2162     // Note that this must be done past the last potential blocking</span>
<span class="line-removed">2163     // point / safepoint. We enable biased locking lazily using a</span>
<span class="line-removed">2164     // VM_Operation to iterate the SystemDictionary and installing the</span>
<span class="line-removed">2165     // biasable mark word into each InstanceKlass&#39;s prototype header.</span>
<span class="line-removed">2166     // To avoid race conditions where we accidentally miss enabling the</span>
<span class="line-removed">2167     // optimization for one class in the process of being added to the</span>
<span class="line-removed">2168     // dictionary, we must not safepoint after the test of</span>
<span class="line-removed">2169     // BiasedLocking::enabled().</span>
<span class="line-removed">2170     if (UseBiasedLocking &amp;&amp; BiasedLocking::enabled()) {</span>
<span class="line-removed">2171       // Set biased locking bit for all loaded classes; it will be</span>
<span class="line-removed">2172       // cleared if revocation occurs too often for this type</span>
<span class="line-removed">2173       // NOTE that we must only do this when the class is initally</span>
<span class="line-removed">2174       // defined, not each time it is referenced from a new class loader</span>
<span class="line-removed">2175       if (oopDesc::equals(k-&gt;class_loader(), class_loader())) {</span>
<span class="line-removed">2176         k-&gt;set_prototype_header(markOopDesc::biased_locking_prototype());</span>
<span class="line-removed">2177       }</span>
<span class="line-removed">2178     }</span>
2179 
2180     // Make a new dictionary entry.
2181     Dictionary* dictionary = loader_data-&gt;dictionary();
2182     InstanceKlass* sd_check = find_class(d_hash, name, dictionary);
2183     if (sd_check == NULL) {
2184       dictionary-&gt;add_klass(d_hash, name, k);
<span class="line-removed">2185 </span>
<span class="line-removed">2186       notice_modification();</span>
2187     }
2188   #ifdef ASSERT
2189     sd_check = find_class(d_hash, name, dictionary);
2190     assert (sd_check != NULL, &quot;should have entry in dictionary&quot;);
2191     // Note: there may be a placeholder entry: for circularity testing
2192     // or for parallel defines
2193   #endif
2194     SystemDictionary_lock-&gt;notify_all();
2195   }
2196 }
2197 
2198 
2199 // Try to find a class name using the loader constraints.  The
2200 // loader constraints might know about a class that isn&#39;t fully loaded
2201 // yet and these will be ignored.
2202 Klass* SystemDictionary::find_constrained_instance_or_array_klass(
2203                     Symbol* class_name, Handle class_loader, TRAPS) {
2204 
2205   // First see if it has been loaded directly.
2206   // Force the protection domain to be null.  (This removes protection checks.)
2207   Handle no_protection_domain;
2208   Klass* klass = find_instance_or_array_klass(class_name, class_loader,
2209                                               no_protection_domain, CHECK_NULL);
2210   if (klass != NULL)
2211     return klass;
2212 
2213   // Now look to see if it has been loaded elsewhere, and is subject to
2214   // a loader constraint that would require this loader to return the
2215   // klass that is already loaded.
<span class="line-modified">2216   if (FieldType::is_array(class_name)) {</span>
2217     // For array classes, their Klass*s are not kept in the
2218     // constraint table. The element Klass*s are.
<span class="line-modified">2219     FieldArrayInfo fd;</span>
<span class="line-modified">2220     BasicType t = FieldType::get_array_info(class_name, fd, CHECK_(NULL));</span>

2221     if (t != T_OBJECT) {
2222       klass = Universe::typeArrayKlassObj(t);
2223     } else {
<span class="line-modified">2224       MutexLocker mu(SystemDictionary_lock, THREAD);</span>
<span class="line-modified">2225       klass = constraints()-&gt;find_constrained_klass(fd.object_key(), class_loader);</span>
2226     }
2227     // If element class already loaded, allocate array klass
2228     if (klass != NULL) {
<span class="line-modified">2229       klass = klass-&gt;array_klass_or_null(fd.dimension());</span>
2230     }
2231   } else {
<span class="line-modified">2232     MutexLocker mu(SystemDictionary_lock, THREAD);</span>
2233     // Non-array classes are easy: simply check the constraint table.
2234     klass = constraints()-&gt;find_constrained_klass(class_name, class_loader);
2235   }
2236 
2237   return klass;
2238 }
2239 
2240 
2241 bool SystemDictionary::add_loader_constraint(Symbol* class_name,
2242                                              Handle class_loader1,
2243                                              Handle class_loader2,
2244                                              Thread* THREAD) {
2245   ClassLoaderData* loader_data1 = class_loader_data(class_loader1);
2246   ClassLoaderData* loader_data2 = class_loader_data(class_loader2);
2247 
2248   Symbol* constraint_name = NULL;
<span class="line-modified">2249   // Needs to be in same scope as constraint_name in case a Symbol is created and</span>
<span class="line-modified">2250   // assigned to constraint_name.</span>
<span class="line-removed">2251   FieldArrayInfo fd;</span>
<span class="line-removed">2252   if (!FieldType::is_array(class_name)) {</span>
2253     constraint_name = class_name;
2254   } else {
2255     // For array classes, their Klass*s are not kept in the
2256     // constraint table. The element classes are.
<span class="line-modified">2257     BasicType t = FieldType::get_array_info(class_name, fd, CHECK_(false));</span>
<span class="line-modified">2258     // primitive types always pass</span>
<span class="line-modified">2259     if (t != T_OBJECT) {</span>
<span class="line-modified">2260       return true;</span>
<span class="line-removed">2261     } else {</span>
<span class="line-removed">2262       constraint_name = fd.object_key();</span>
2263     }





2264   }
2265 
2266   Dictionary* dictionary1 = loader_data1-&gt;dictionary();
2267   unsigned int d_hash1 = dictionary1-&gt;compute_hash(constraint_name);
2268 
2269   Dictionary* dictionary2 = loader_data2-&gt;dictionary();
2270   unsigned int d_hash2 = dictionary2-&gt;compute_hash(constraint_name);
2271 
2272   {
<span class="line-modified">2273     MutexLocker mu_s(SystemDictionary_lock, THREAD);</span>
2274     InstanceKlass* klass1 = find_class(d_hash1, constraint_name, dictionary1);
2275     InstanceKlass* klass2 = find_class(d_hash2, constraint_name, dictionary2);
<span class="line-modified">2276     return constraints()-&gt;add_entry(constraint_name, klass1, class_loader1,</span>
<span class="line-modified">2277                                     klass2, class_loader2);</span>




2278   }
2279 }
2280 
2281 // Add entry to resolution error table to record the error when the first
2282 // attempt to resolve a reference to a class has failed.
2283 void SystemDictionary::add_resolution_error(const constantPoolHandle&amp; pool, int which,
2284                                             Symbol* error, Symbol* message) {
2285   unsigned int hash = resolution_errors()-&gt;compute_hash(pool, which);
2286   int index = resolution_errors()-&gt;hash_to_index(hash);
2287   {
<span class="line-modified">2288     MutexLocker ml(SystemDictionary_lock, Thread::current());</span>
2289     resolution_errors()-&gt;add_entry(index, hash, pool, which, error, message);
2290   }
2291 }
2292 
2293 // Delete a resolution error for RedefineClasses for a constant pool is going away
2294 void SystemDictionary::delete_resolution_error(ConstantPool* pool) {
2295   resolution_errors()-&gt;delete_entry(pool);
2296 }
2297 
2298 // Lookup resolution error table. Returns error if found, otherwise NULL.
2299 Symbol* SystemDictionary::find_resolution_error(const constantPoolHandle&amp; pool, int which,
2300                                                 Symbol** message) {
2301   unsigned int hash = resolution_errors()-&gt;compute_hash(pool, which);
2302   int index = resolution_errors()-&gt;hash_to_index(hash);
2303   {
<span class="line-modified">2304     MutexLocker ml(SystemDictionary_lock, Thread::current());</span>
2305     ResolutionErrorEntry* entry = resolution_errors()-&gt;find_entry(index, hash, pool, which);
2306     if (entry != NULL) {
2307       *message = entry-&gt;message();
2308       return entry-&gt;error();
2309     } else {
2310       return NULL;
2311     }
2312   }
2313 }
2314 
2315 
2316 // Signature constraints ensure that callers and callees agree about
2317 // the meaning of type names in their signatures.  This routine is the
2318 // intake for constraints.  It collects them from several places:
2319 //
2320 //  * LinkResolver::resolve_method (if check_access is true) requires
2321 //    that the resolving class (the caller) and the defining class of
2322 //    the resolved method (the callee) agree on each type in the
2323 //    method&#39;s signature.
2324 //
</pre>
<hr />
<pre>
2350 // constraints are placed as if the supertype were the caller to the
2351 // overriding method.  (This works well, since callers to the
2352 // supertype have already established agreement between themselves and
2353 // the supertype.)  As a result of all this, a class can disagree with
2354 // its supertype about the meaning of a type name, as long as that
2355 // class neither calls a relevant method of the supertype, nor is
2356 // called (perhaps via an override) from the supertype.
2357 //
2358 //
2359 // SystemDictionary::check_signature_loaders(sig, l1, l2)
2360 //
2361 // Make sure all class components (including arrays) in the given
2362 // signature will be resolved to the same class in both loaders.
2363 // Returns the name of the type that failed a loader constraint check, or
2364 // NULL if no constraint failed.  No exception except OOME is thrown.
2365 // Arrays are not added to the loader constraint table, their elements are.
2366 Symbol* SystemDictionary::check_signature_loaders(Symbol* signature,
2367                                                Handle loader1, Handle loader2,
2368                                                bool is_method, TRAPS)  {
2369   // Nothing to do if loaders are the same.
<span class="line-modified">2370   if (oopDesc::equals(loader1(), loader2())) {</span>
2371     return NULL;
2372   }
2373 
<span class="line-modified">2374   SignatureStream sig_strm(signature, is_method);</span>
<span class="line-modified">2375   while (!sig_strm.is_done()) {</span>
<span class="line-modified">2376     if (sig_strm.is_object()) {</span>
<span class="line-modified">2377       Symbol* sig = sig_strm.as_symbol(CHECK_NULL);</span>


2378       if (!add_loader_constraint(sig, loader1, loader2, THREAD)) {
2379         return sig;
2380       }
2381     }
<span class="line-removed">2382     sig_strm.next();</span>
2383   }
2384   return NULL;
2385 }
2386 
2387 
<span class="line-modified">2388 methodHandle SystemDictionary::find_method_handle_intrinsic(vmIntrinsics::ID iid,</span>
<span class="line-modified">2389                                                             Symbol* signature,</span>
<span class="line-modified">2390                                                             TRAPS) {</span>
2391   methodHandle empty;
2392   assert(MethodHandles::is_signature_polymorphic(iid) &amp;&amp;
2393          MethodHandles::is_signature_polymorphic_intrinsic(iid) &amp;&amp;
2394          iid != vmIntrinsics::_invokeGeneric,
2395          &quot;must be a known MH intrinsic iid=%d: %s&quot;, iid, vmIntrinsics::name_at(iid));
2396 
2397   unsigned int hash  = invoke_method_table()-&gt;compute_hash(signature, iid);
2398   int          index = invoke_method_table()-&gt;hash_to_index(hash);
2399   SymbolPropertyEntry* spe = invoke_method_table()-&gt;find_entry(index, hash, signature, iid);
2400   methodHandle m;
2401   if (spe == NULL || spe-&gt;method() == NULL) {
2402     spe = NULL;
2403     // Must create lots of stuff here, but outside of the SystemDictionary lock.
<span class="line-modified">2404     m = Method::make_method_handle_intrinsic(iid, signature, CHECK_(empty));</span>
2405     if (!Arguments::is_interpreter_only()) {
2406       // Generate a compiled form of the MH intrinsic.
2407       AdapterHandlerLibrary::create_native_wrapper(m);
2408       // Check if have the compiled code.
2409       if (!m-&gt;has_compiled_code()) {
<span class="line-modified">2410         THROW_MSG_(vmSymbols::java_lang_VirtualMachineError(),</span>
<span class="line-modified">2411                    &quot;Out of space in CodeCache for method handle intrinsic&quot;, empty);</span>
2412       }
2413     }
2414     // Now grab the lock.  We might have to throw away the new method,
2415     // if a racing thread has managed to install one at the same time.
2416     {
<span class="line-modified">2417       MutexLocker ml(SystemDictionary_lock, THREAD);</span>
2418       spe = invoke_method_table()-&gt;find_entry(index, hash, signature, iid);
2419       if (spe == NULL)
2420         spe = invoke_method_table()-&gt;add_entry(index, hash, signature, iid);
2421       if (spe-&gt;method() == NULL)
2422         spe-&gt;set_method(m());
2423     }
2424   }
2425 
2426   assert(spe != NULL &amp;&amp; spe-&gt;method() != NULL, &quot;&quot;);
2427   assert(Arguments::is_interpreter_only() || (spe-&gt;method()-&gt;has_compiled_code() &amp;&amp;
2428          spe-&gt;method()-&gt;code()-&gt;entry_point() == spe-&gt;method()-&gt;from_compiled_entry()),
2429          &quot;MH intrinsic invariant&quot;);
2430   return spe-&gt;method();
2431 }
2432 
2433 // Helper for unpacking the return value from linkMethod and linkCallSite.
<span class="line-modified">2434 static methodHandle unpack_method_and_appendix(Handle mname,</span>
<span class="line-modified">2435                                                Klass* accessing_klass,</span>
<span class="line-modified">2436                                                objArrayHandle appendix_box,</span>
<span class="line-modified">2437                                                Handle* appendix_result,</span>
<span class="line-modified">2438                                                TRAPS) {</span>
<span class="line-removed">2439   methodHandle empty;</span>
2440   if (mname.not_null()) {
2441     Method* m = java_lang_invoke_MemberName::vmtarget(mname());
2442     if (m != NULL) {
2443       oop appendix = appendix_box-&gt;obj_at(0);
2444       if (TraceMethodHandles) {
2445     #ifndef PRODUCT
2446         ttyLocker ttyl;
2447         tty-&gt;print(&quot;Linked method=&quot; INTPTR_FORMAT &quot;: &quot;, p2i(m));
2448         m-&gt;print();
2449         if (appendix != NULL) { tty-&gt;print(&quot;appendix = &quot;); appendix-&gt;print(); }
2450         tty-&gt;cr();
2451     #endif //PRODUCT
2452       }
2453       (*appendix_result) = Handle(THREAD, appendix);
2454       // the target is stored in the cpCache and if a reference to this
2455       // MemberName is dropped we need a way to make sure the
2456       // class_loader containing this method is kept alive.

2457       ClassLoaderData* this_key = accessing_klass-&gt;class_loader_data();
2458       this_key-&gt;record_dependency(m-&gt;method_holder());
<span class="line-modified">2459       return methodHandle(THREAD, m);</span>
2460     }
2461   }
<span class="line-modified">2462   THROW_MSG_(vmSymbols::java_lang_LinkageError(), &quot;bad value from MethodHandleNatives&quot;, empty);</span>
<span class="line-removed">2463   return empty;</span>
2464 }
2465 
<span class="line-modified">2466 methodHandle SystemDictionary::find_method_handle_invoker(Klass* klass,</span>
<span class="line-modified">2467                                                           Symbol* name,</span>
<span class="line-modified">2468                                                           Symbol* signature,</span>
2469                                                           Klass* accessing_klass,
2470                                                           Handle *appendix_result,
2471                                                           TRAPS) {
<span class="line-removed">2472   methodHandle empty;</span>
2473   assert(THREAD-&gt;can_call_java() ,&quot;&quot;);
2474   Handle method_type =
<span class="line-modified">2475     SystemDictionary::find_method_handle_type(signature, accessing_klass, CHECK_(empty));</span>
2476 
2477   int ref_kind = JVM_REF_invokeVirtual;
<span class="line-modified">2478   oop name_oop = StringTable::intern(name, CHECK_(empty));</span>
2479   Handle name_str (THREAD, name_oop);
<span class="line-modified">2480   objArrayHandle appendix_box = oopFactory::new_objArray_handle(SystemDictionary::Object_klass(), 1, CHECK_(empty));</span>
2481   assert(appendix_box-&gt;obj_at(0) == NULL, &quot;&quot;);
2482 
2483   // This should not happen.  JDK code should take care of that.
2484   if (accessing_klass == NULL || method_type.is_null()) {
<span class="line-modified">2485     THROW_MSG_(vmSymbols::java_lang_InternalError(), &quot;bad invokehandle&quot;, empty);</span>
2486   }
2487 
2488   // call java.lang.invoke.MethodHandleNatives::linkMethod(... String, MethodType) -&gt; MemberName
2489   JavaCallArguments args;
2490   args.push_oop(Handle(THREAD, accessing_klass-&gt;java_mirror()));
2491   args.push_int(ref_kind);
2492   args.push_oop(Handle(THREAD, klass-&gt;java_mirror()));
2493   args.push_oop(name_str);
2494   args.push_oop(method_type);
2495   args.push_oop(appendix_box);
2496   JavaValue result(T_OBJECT);
2497   JavaCalls::call_static(&amp;result,
2498                          SystemDictionary::MethodHandleNatives_klass(),
2499                          vmSymbols::linkMethod_name(),
2500                          vmSymbols::linkMethod_signature(),
<span class="line-modified">2501                          &amp;args, CHECK_(empty));</span>
2502   Handle mname(THREAD, (oop) result.get_jobject());
2503   return unpack_method_and_appendix(mname, accessing_klass, appendix_box, appendix_result, THREAD);
2504 }
2505 
2506 // Decide if we can globally cache a lookup of this class, to be returned to any client that asks.
2507 // We must ensure that all class loaders everywhere will reach this class, for any client.
2508 // This is a safe bet for public classes in java.lang, such as Object and String.
2509 // We also include public classes in java.lang.invoke, because they appear frequently in system-level method types.
2510 // Out of an abundance of caution, we do not include any other classes, not even for packages like java.util.
2511 static bool is_always_visible_class(oop mirror) {
2512   Klass* klass = java_lang_Class::as_Klass(mirror);
2513   if (klass-&gt;is_objArray_klass()) {
2514     klass = ObjArrayKlass::cast(klass)-&gt;bottom_klass(); // check element type
2515   }
2516   if (klass-&gt;is_typeArray_klass()) {
2517     return true; // primitive array
2518   }
2519   assert(klass-&gt;is_instance_klass(), &quot;%s&quot;, klass-&gt;external_name());
2520   return klass-&gt;is_public() &amp;&amp;
2521          (InstanceKlass::cast(klass)-&gt;is_same_class_package(SystemDictionary::Object_klass()) ||       // java.lang
2522           InstanceKlass::cast(klass)-&gt;is_same_class_package(SystemDictionary::MethodHandle_klass()));  // java.lang.invoke
2523 }
2524 
<span class="line-removed">2525 </span>
<span class="line-removed">2526 // Return the Java mirror (java.lang.Class instance) for a single-character</span>
<span class="line-removed">2527 // descriptor.  This result, when available, is the same as produced by the</span>
<span class="line-removed">2528 // heavier API point of the same name that takes a Symbol.</span>
<span class="line-removed">2529 oop SystemDictionary::find_java_mirror_for_type(char signature_char) {</span>
<span class="line-removed">2530   return java_lang_Class::primitive_mirror(char2type(signature_char));</span>
<span class="line-removed">2531 }</span>
<span class="line-removed">2532 </span>
2533 // Find or construct the Java mirror (java.lang.Class instance) for a
2534 // for the given field type signature, as interpreted relative to the
2535 // given class loader.  Handles primitives, void, references, arrays,
2536 // and all other reflectable types, except method types.
2537 // N.B.  Code in reflection should use this entry point.
2538 Handle SystemDictionary::find_java_mirror_for_type(Symbol* signature,
2539                                                    Klass* accessing_klass,
2540                                                    Handle class_loader,
2541                                                    Handle protection_domain,
2542                                                    SignatureStream::FailureMode failure_mode,
2543                                                    TRAPS) {
2544   Handle empty;
2545 
2546   assert(accessing_klass == NULL || (class_loader.is_null() &amp;&amp; protection_domain.is_null()),
2547          &quot;one or the other, or perhaps neither&quot;);
2548 
<span class="line-modified">2549   Symbol* type = signature;</span>
2550 
2551   // What we have here must be a valid field descriptor,
2552   // and all valid field descriptors are supported.
2553   // Produce the same java.lang.Class that reflection reports.
<span class="line-modified">2554   if (type-&gt;utf8_length() == 1) {</span>
2555 
2556     // It&#39;s a primitive.  (Void has a primitive mirror too.)
<span class="line-modified">2557     char ch = type-&gt;char_at(0);</span>
<span class="line-removed">2558     assert(is_java_primitive(char2type(ch)) || ch == &#39;V&#39;, &quot;&quot;);</span>
<span class="line-removed">2559     return Handle(THREAD, find_java_mirror_for_type(ch));</span>
2560 
<span class="line-modified">2561   } else if (FieldType::is_obj(type) || FieldType::is_array(type)) {</span>
2562 
2563     // It&#39;s a reference type.
2564     if (accessing_klass != NULL) {
2565       class_loader      = Handle(THREAD, accessing_klass-&gt;class_loader());
2566       protection_domain = Handle(THREAD, accessing_klass-&gt;protection_domain());
2567     }
2568     Klass* constant_type_klass;
2569     if (failure_mode == SignatureStream::ReturnNull) {
<span class="line-modified">2570       constant_type_klass = resolve_or_null(type, class_loader, protection_domain,</span>
2571                                             CHECK_(empty));
2572     } else {
2573       bool throw_error = (failure_mode == SignatureStream::NCDFError);
<span class="line-modified">2574       constant_type_klass = resolve_or_fail(type, class_loader, protection_domain,</span>
2575                                             throw_error, CHECK_(empty));
2576     }
2577     if (constant_type_klass == NULL) {
2578       return Handle();  // report failure this way
2579     }
2580     Handle mirror(THREAD, constant_type_klass-&gt;java_mirror());
2581 
2582     // Check accessibility, emulating ConstantPool::verify_constant_pool_resolve.
2583     if (accessing_klass != NULL) {
2584       Klass* sel_klass = constant_type_klass;
2585       bool fold_type_to_class = true;
2586       LinkResolver::check_klass_accessability(accessing_klass, sel_klass,
2587                                               fold_type_to_class, CHECK_(empty));
2588     }
2589 
2590     return mirror;
2591 
2592   }
2593 
2594   // Fall through to an error.
</pre>
<hr />
<pre>
2617     return Handle();  // do not attempt from within compiler, unless it was cached
2618   }
2619 
2620   Handle class_loader, protection_domain;
2621   if (accessing_klass != NULL) {
2622     class_loader      = Handle(THREAD, accessing_klass-&gt;class_loader());
2623     protection_domain = Handle(THREAD, accessing_klass-&gt;protection_domain());
2624   }
2625   bool can_be_cached = true;
2626   int npts = ArgumentCount(signature).size();
2627   objArrayHandle pts = oopFactory::new_objArray_handle(SystemDictionary::Class_klass(), npts, CHECK_(empty));
2628   int arg = 0;
2629   Handle rt; // the return type from the signature
2630   ResourceMark rm(THREAD);
2631   for (SignatureStream ss(signature); !ss.is_done(); ss.next()) {
2632     oop mirror = NULL;
2633     if (can_be_cached) {
2634       // Use neutral class loader to lookup candidate classes to be placed in the cache.
2635       mirror = ss.as_java_mirror(Handle(), Handle(),
2636                                  SignatureStream::ReturnNull, CHECK_(empty));
<span class="line-modified">2637       if (mirror == NULL || (ss.is_object() &amp;&amp; !is_always_visible_class(mirror))) {</span>
2638         // Fall back to accessing_klass context.
2639         can_be_cached = false;
2640       }
2641     }
2642     if (!can_be_cached) {
2643       // Resolve, throwing a real error if it doesn&#39;t work.
2644       mirror = ss.as_java_mirror(class_loader, protection_domain,
2645                                  SignatureStream::NCDFError, CHECK_(empty));
2646     }
<span class="line-modified">2647     assert(mirror != NULL, &quot;%s&quot;, ss.as_symbol(THREAD)-&gt;as_C_string());</span>
2648     if (ss.at_return_type())
2649       rt = Handle(THREAD, mirror);
2650     else
2651       pts-&gt;obj_at_put(arg++, mirror);
2652 
2653     // Check accessibility.
2654     if (!java_lang_Class::is_primitive(mirror) &amp;&amp; accessing_klass != NULL) {
2655       Klass* sel_klass = java_lang_Class::as_Klass(mirror);
2656       mirror = NULL;  // safety
2657       // Emulate ConstantPool::verify_constant_pool_resolve.
2658       bool fold_type_to_class = true;
2659       LinkResolver::check_klass_accessability(accessing_klass, sel_klass,
2660                                               fold_type_to_class, CHECK_(empty));
2661     }
2662   }
2663   assert(arg == npts, &quot;&quot;);
2664 
2665   // call java.lang.invoke.MethodHandleNatives::findMethodHandleType(Class rt, Class[] pts) -&gt; MethodType
2666   JavaCallArguments args(Handle(THREAD, rt()));
2667   args.push_oop(pts);
2668   JavaValue result(T_OBJECT);
2669   JavaCalls::call_static(&amp;result,
2670                          SystemDictionary::MethodHandleNatives_klass(),
2671                          vmSymbols::findMethodHandleType_name(),
2672                          vmSymbols::findMethodHandleType_signature(),
2673                          &amp;args, CHECK_(empty));
2674   Handle method_type(THREAD, (oop) result.get_jobject());
2675 
2676   if (can_be_cached) {
2677     // We can cache this MethodType inside the JVM.
<span class="line-modified">2678     MutexLocker ml(SystemDictionary_lock, THREAD);</span>
2679     spe = invoke_method_table()-&gt;find_entry(index, hash, signature, null_iid);
2680     if (spe == NULL)
2681       spe = invoke_method_table()-&gt;add_entry(index, hash, signature, null_iid);
2682     if (spe-&gt;method_type() == NULL) {
2683       spe-&gt;set_method_type(method_type());
2684     }
2685   }
2686 
2687   // report back to the caller with the MethodType
2688   return method_type;
2689 }
2690 
2691 Handle SystemDictionary::find_field_handle_type(Symbol* signature,
2692                                                 Klass* accessing_klass,
2693                                                 TRAPS) {
2694   Handle empty;
2695   ResourceMark rm(THREAD);
2696   SignatureStream ss(signature, /*is_method=*/ false);
2697   if (!ss.is_done()) {
2698     Handle class_loader, protection_domain;
</pre>
<hr />
<pre>
2743 
2744   // After method/field resolution succeeded, it&#39;s safe to resolve MH signature as well.
2745   Handle type = MethodHandles::resolve_MemberName_type(mname, caller, CHECK_(empty));
2746 
2747   // call java.lang.invoke.MethodHandleNatives::linkMethodHandleConstant(Class caller, int refKind, Class callee, String name, Object type) -&gt; MethodHandle
2748   JavaCallArguments args;
2749   args.push_oop(Handle(THREAD, caller-&gt;java_mirror()));  // the referring class
2750   args.push_int(ref_kind);
2751   args.push_oop(Handle(THREAD, callee-&gt;java_mirror()));  // the target class
2752   args.push_oop(name_str);
2753   args.push_oop(type);
2754   JavaValue result(T_OBJECT);
2755   JavaCalls::call_static(&amp;result,
2756                          SystemDictionary::MethodHandleNatives_klass(),
2757                          vmSymbols::linkMethodHandleConstant_name(),
2758                          vmSymbols::linkMethodHandleConstant_signature(),
2759                          &amp;args, CHECK_(empty));
2760   return Handle(THREAD, (oop) result.get_jobject());
2761 }
2762 
<span class="line-modified">2763 // Ask Java to compute a constant by invoking a BSM given a Dynamic_info CP entry</span>
<span class="line-modified">2764 Handle SystemDictionary::link_dynamic_constant(Klass* caller,</span>
<span class="line-modified">2765                                                int condy_index,</span>
<span class="line-modified">2766                                                Handle bootstrap_specifier,</span>
<span class="line-modified">2767                                                Symbol* name,</span>
<span class="line-modified">2768                                                Symbol* type,</span>
<span class="line-removed">2769                                                TRAPS) {</span>
<span class="line-removed">2770   Handle empty;</span>
<span class="line-removed">2771   Handle bsm, info;</span>
<span class="line-removed">2772   if (java_lang_invoke_MethodHandle::is_instance(bootstrap_specifier())) {</span>
<span class="line-removed">2773     bsm = bootstrap_specifier;</span>
<span class="line-removed">2774   } else {</span>
<span class="line-removed">2775     assert(bootstrap_specifier-&gt;is_objArray(), &quot;&quot;);</span>
<span class="line-removed">2776     objArrayOop args = (objArrayOop) bootstrap_specifier();</span>
<span class="line-removed">2777     assert(args-&gt;length() == 2, &quot;&quot;);</span>
<span class="line-removed">2778     bsm  = Handle(THREAD, args-&gt;obj_at(0));</span>
<span class="line-removed">2779     info = Handle(THREAD, args-&gt;obj_at(1));</span>
<span class="line-removed">2780   }</span>
<span class="line-removed">2781   guarantee(java_lang_invoke_MethodHandle::is_instance(bsm()),</span>
<span class="line-removed">2782             &quot;caller must supply a valid BSM&quot;);</span>
2783 
2784   // This should not happen.  JDK code should take care of that.
<span class="line-modified">2785   if (caller == NULL) {</span>
<span class="line-modified">2786     THROW_MSG_(vmSymbols::java_lang_InternalError(), &quot;bad dynamic constant&quot;, empty);</span>
2787   }
2788 
<span class="line-modified">2789   Handle constant_name = java_lang_String::create_from_symbol(name, CHECK_(empty));</span>
<span class="line-modified">2790 </span>
<span class="line-modified">2791   // Resolve the constant type in the context of the caller class</span>
<span class="line-modified">2792   Handle type_mirror = find_java_mirror_for_type(type, caller, SignatureStream::NCDFError,</span>
<span class="line-modified">2793                                                  CHECK_(empty));</span>


2794 
<span class="line-modified">2795   // call java.lang.invoke.MethodHandleNatives::linkConstantDyanmic(caller, condy_index, bsm, type, info)</span>

2796   JavaCallArguments args;
<span class="line-modified">2797   args.push_oop(Handle(THREAD, caller-&gt;java_mirror()));</span>
<span class="line-modified">2798   args.push_int(condy_index);</span>
<span class="line-modified">2799   args.push_oop(bsm);</span>
<span class="line-modified">2800   args.push_oop(constant_name);</span>
<span class="line-modified">2801   args.push_oop(type_mirror);</span>
<span class="line-modified">2802   args.push_oop(info);</span>



2803   JavaValue result(T_OBJECT);
2804   JavaCalls::call_static(&amp;result,
2805                          SystemDictionary::MethodHandleNatives_klass(),
<span class="line-modified">2806                          vmSymbols::linkDynamicConstant_name(),</span>
<span class="line-modified">2807                          vmSymbols::linkDynamicConstant_signature(),</span>
<span class="line-modified">2808                          &amp;args, CHECK_(empty));</span>
<span class="line-modified">2809 </span>
<span class="line-modified">2810   return Handle(THREAD, (oop) result.get_jobject());</span>
<span class="line-modified">2811 }</span>
<span class="line-modified">2812 </span>
<span class="line-modified">2813 // Ask Java code to find or construct a java.lang.invoke.CallSite for the given</span>
<span class="line-modified">2814 // name and signature, as interpreted relative to the given class loader.</span>
<span class="line-modified">2815 methodHandle SystemDictionary::find_dynamic_call_site_invoker(Klass* caller,</span>
<span class="line-modified">2816                                                               int indy_index,</span>
<span class="line-modified">2817                                                               Handle bootstrap_specifier,</span>
<span class="line-modified">2818                                                               Symbol* name,</span>
<span class="line-removed">2819                                                               Symbol* type,</span>
<span class="line-removed">2820                                                               Handle *appendix_result,</span>
<span class="line-removed">2821                                                               TRAPS) {</span>
<span class="line-removed">2822   methodHandle empty;</span>
<span class="line-removed">2823   Handle bsm, info;</span>
<span class="line-removed">2824   if (java_lang_invoke_MethodHandle::is_instance(bootstrap_specifier())) {</span>
<span class="line-removed">2825     bsm = bootstrap_specifier;</span>
2826   } else {
<span class="line-modified">2827     objArrayOop args = (objArrayOop) bootstrap_specifier();</span>
<span class="line-removed">2828     assert(args-&gt;length() == 2, &quot;&quot;);</span>
<span class="line-removed">2829     bsm  = Handle(THREAD, args-&gt;obj_at(0));</span>
<span class="line-removed">2830     info = Handle(THREAD, args-&gt;obj_at(1));</span>
<span class="line-removed">2831   }</span>
<span class="line-removed">2832   guarantee(java_lang_invoke_MethodHandle::is_instance(bsm()),</span>
<span class="line-removed">2833             &quot;caller must supply a valid BSM&quot;);</span>
<span class="line-removed">2834 </span>
<span class="line-removed">2835   Handle method_name = java_lang_String::create_from_symbol(name, CHECK_(empty));</span>
<span class="line-removed">2836   Handle method_type = find_method_handle_type(type, caller, CHECK_(empty));</span>
<span class="line-removed">2837 </span>
<span class="line-removed">2838   // This should not happen.  JDK code should take care of that.</span>
<span class="line-removed">2839   if (caller == NULL || method_type.is_null()) {</span>
<span class="line-removed">2840     THROW_MSG_(vmSymbols::java_lang_InternalError(), &quot;bad invokedynamic&quot;, empty);</span>
2841   }
2842 
<span class="line-modified">2843   objArrayHandle appendix_box = oopFactory::new_objArray_handle(SystemDictionary::Object_klass(), 1, CHECK_(empty));</span>
<span class="line-modified">2844   assert(appendix_box-&gt;obj_at(0) == NULL, &quot;&quot;);</span>
<span class="line-modified">2845 </span>
<span class="line-modified">2846   // call java.lang.invoke.MethodHandleNatives::linkCallSite(caller, indy_index, bsm, name, mtype, info, &amp;appendix)</span>
<span class="line-removed">2847   JavaCallArguments args;</span>
<span class="line-removed">2848   args.push_oop(Handle(THREAD, caller-&gt;java_mirror()));</span>
<span class="line-removed">2849   args.push_int(indy_index);</span>
<span class="line-removed">2850   args.push_oop(bsm);</span>
<span class="line-removed">2851   args.push_oop(method_name);</span>
<span class="line-removed">2852   args.push_oop(method_type);</span>
<span class="line-removed">2853   args.push_oop(info);</span>
<span class="line-removed">2854   args.push_oop(appendix_box);</span>
<span class="line-removed">2855   JavaValue result(T_OBJECT);</span>
<span class="line-removed">2856   JavaCalls::call_static(&amp;result,</span>
<span class="line-removed">2857                          SystemDictionary::MethodHandleNatives_klass(),</span>
<span class="line-removed">2858                          vmSymbols::linkCallSite_name(),</span>
<span class="line-removed">2859                          vmSymbols::linkCallSite_signature(),</span>
<span class="line-removed">2860                          &amp;args, CHECK_(empty));</span>
<span class="line-removed">2861   Handle mname(THREAD, (oop) result.get_jobject());</span>
<span class="line-removed">2862   return unpack_method_and_appendix(mname, caller, appendix_box, appendix_result, THREAD);</span>
2863 }
2864 
2865 // Protection domain cache table handling
2866 
2867 ProtectionDomainCacheEntry* SystemDictionary::cache_get(Handle protection_domain) {
2868   return _pd_cache_table-&gt;get(protection_domain);
2869 }
2870 
2871 // ----------------------------------------------------------------------------
2872 
2873 void SystemDictionary::print_on(outputStream *st) {
2874   CDS_ONLY(SystemDictionaryShared::print_on(st));
2875   GCMutexLocker mu(SystemDictionary_lock);
2876 
2877   ClassLoaderDataGraph::print_dictionary(st);
2878 
2879   // Placeholders
2880   placeholders()-&gt;print_on(st);
2881   st-&gt;cr();
2882 
2883   // loader constraints - print under SD_lock
2884   constraints()-&gt;print_on(st);
2885   st-&gt;cr();
2886 
2887   _pd_cache_table-&gt;print_on(st);
2888   st-&gt;cr();
2889 }
2890 


2891 void SystemDictionary::verify() {
2892   guarantee(constraints() != NULL,
2893             &quot;Verify of loader constraints failed&quot;);
2894   guarantee(placeholders()-&gt;number_of_entries() &gt;= 0,
2895             &quot;Verify of placeholders failed&quot;);
2896 
2897   GCMutexLocker mu(SystemDictionary_lock);
2898 
2899   // Verify dictionary
2900   ClassLoaderDataGraph::verify_dictionary();
2901 
2902   placeholders()-&gt;verify();
2903 
2904   // Verify constraint table
2905   guarantee(constraints() != NULL, &quot;Verify of loader constraints failed&quot;);
2906   constraints()-&gt;verify(placeholders());
2907 
2908   _pd_cache_table-&gt;verify();
2909 }
2910 
2911 void SystemDictionary::dump(outputStream *st, bool verbose) {
2912   assert_locked_or_safepoint(SystemDictionary_lock);
2913   if (verbose) {
2914     print_on(st);
2915   } else {
2916     CDS_ONLY(SystemDictionaryShared::print_table_statistics(st));
<span class="line-modified">2917     ClassLoaderDataGraph::print_dictionary_statistics(st);</span>
2918     placeholders()-&gt;print_table_statistics(st, &quot;Placeholder Table&quot;);
2919     constraints()-&gt;print_table_statistics(st, &quot;LoaderConstraints Table&quot;);
<span class="line-modified">2920     _pd_cache_table-&gt;print_table_statistics(st, &quot;ProtectionDomainCache Table&quot;);</span>
2921   }
2922 }
2923 















2924 // Utility for dumping dictionaries.
2925 SystemDictionaryDCmd::SystemDictionaryDCmd(outputStream* output, bool heap) :
2926                                  DCmdWithParser(output, heap),
2927   _verbose(&quot;-verbose&quot;, &quot;Dump the content of each dictionary entry for all class loaders&quot;,
2928            &quot;BOOLEAN&quot;, false, &quot;false&quot;) {
2929   _dcmdparser.add_dcmd_option(&amp;_verbose);
2930 }
2931 
2932 void SystemDictionaryDCmd::execute(DCmdSource source, TRAPS) {
2933   VM_DumpHashtable dumper(output(), VM_DumpHashtable::DumpSysDict,
2934                          _verbose.value());
2935   VMThread::execute(&amp;dumper);
2936 }
2937 
2938 int SystemDictionaryDCmd::num_arguments() {
2939   ResourceMark rm;
2940   SystemDictionaryDCmd* dcmd = new SystemDictionaryDCmd(NULL, false);
2941   if (dcmd != NULL) {
2942     DCmdMark mark(dcmd);
2943     return dcmd-&gt;_dcmdparser.num_arguments();
2944   } else {
2945     return 0;
2946   }
2947 }
<span class="line-removed">2948 </span>
<span class="line-removed">2949 void SystemDictionary::initialize_oop_storage() {</span>
<span class="line-removed">2950   _vm_weak_oop_storage =</span>
<span class="line-removed">2951     new OopStorage(&quot;VM Weak Oop Handles&quot;,</span>
<span class="line-removed">2952                    VMWeakAlloc_lock,</span>
<span class="line-removed">2953                    VMWeakActive_lock);</span>
<span class="line-removed">2954 }</span>
<span class="line-removed">2955 </span>
<span class="line-removed">2956 OopStorage* SystemDictionary::vm_weak_oop_storage() {</span>
<span class="line-removed">2957   assert(_vm_weak_oop_storage != NULL, &quot;Uninitialized&quot;);</span>
<span class="line-removed">2958   return _vm_weak_oop_storage;</span>
<span class="line-removed">2959 }</span>
</pre>
</td>
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 1997, 2020, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include &quot;precompiled.hpp&quot;
  26 #include &quot;jvm.h&quot;
  27 #include &quot;aot/aotLoader.hpp&quot;
  28 #include &quot;classfile/classFileParser.hpp&quot;
  29 #include &quot;classfile/classFileStream.hpp&quot;
  30 #include &quot;classfile/classLoader.hpp&quot;
  31 #include &quot;classfile/classLoaderData.inline.hpp&quot;
  32 #include &quot;classfile/classLoaderDataGraph.inline.hpp&quot;
  33 #include &quot;classfile/classLoaderExt.hpp&quot;
  34 #include &quot;classfile/dictionary.hpp&quot;
  35 #include &quot;classfile/javaClasses.inline.hpp&quot;
  36 #include &quot;classfile/klassFactory.hpp&quot;
  37 #include &quot;classfile/loaderConstraints.hpp&quot;
  38 #include &quot;classfile/packageEntry.hpp&quot;
  39 #include &quot;classfile/placeholders.hpp&quot;
  40 #include &quot;classfile/protectionDomainCache.hpp&quot;
  41 #include &quot;classfile/resolutionErrors.hpp&quot;
  42 #include &quot;classfile/stringTable.hpp&quot;
<span class="line-added">  43 #include &quot;classfile/symbolTable.hpp&quot;</span>
  44 #include &quot;classfile/systemDictionary.hpp&quot;
  45 #include &quot;classfile/vmSymbols.hpp&quot;
  46 #include &quot;code/codeCache.hpp&quot;
  47 #include &quot;compiler/compileBroker.hpp&quot;
  48 #include &quot;gc/shared/gcTraceTime.inline.hpp&quot;
  49 #include &quot;gc/shared/oopStorage.inline.hpp&quot;
<span class="line-added">  50 #include &quot;gc/shared/oopStorageSet.hpp&quot;</span>
  51 #include &quot;interpreter/bytecodeStream.hpp&quot;
  52 #include &quot;interpreter/interpreter.hpp&quot;
  53 #include &quot;jfr/jfrEvents.hpp&quot;
  54 #include &quot;logging/log.hpp&quot;
  55 #include &quot;logging/logStream.hpp&quot;
  56 #include &quot;memory/filemap.hpp&quot;
  57 #include &quot;memory/heapShared.hpp&quot;
  58 #include &quot;memory/metaspaceClosure.hpp&quot;
  59 #include &quot;memory/oopFactory.hpp&quot;
  60 #include &quot;memory/resourceArea.hpp&quot;
<span class="line-added">  61 #include &quot;memory/universe.hpp&quot;</span>
  62 #include &quot;oops/access.inline.hpp&quot;
  63 #include &quot;oops/instanceKlass.hpp&quot;
  64 #include &quot;oops/instanceRefKlass.hpp&quot;
  65 #include &quot;oops/klass.inline.hpp&quot;
  66 #include &quot;oops/method.inline.hpp&quot;
  67 #include &quot;oops/methodData.hpp&quot;
  68 #include &quot;oops/objArrayKlass.hpp&quot;
  69 #include &quot;oops/objArrayOop.inline.hpp&quot;
  70 #include &quot;oops/oop.inline.hpp&quot;
  71 #include &quot;oops/symbol.hpp&quot;
  72 #include &quot;oops/typeArrayKlass.hpp&quot;
  73 #include &quot;prims/jvmtiExport.hpp&quot;

  74 #include &quot;prims/methodHandles.hpp&quot;
  75 #include &quot;runtime/arguments.hpp&quot;
  76 #include &quot;runtime/biasedLocking.hpp&quot;

  77 #include &quot;runtime/handles.inline.hpp&quot;
  78 #include &quot;runtime/java.hpp&quot;
  79 #include &quot;runtime/javaCalls.hpp&quot;
  80 #include &quot;runtime/mutexLocker.hpp&quot;

  81 #include &quot;runtime/sharedRuntime.hpp&quot;
  82 #include &quot;runtime/signature.hpp&quot;
  83 #include &quot;services/classLoadingService.hpp&quot;
  84 #include &quot;services/diagnosticCommand.hpp&quot;
  85 #include &quot;services/threadService.hpp&quot;
  86 #include &quot;utilities/macros.hpp&quot;
  87 #if INCLUDE_CDS
  88 #include &quot;classfile/systemDictionaryShared.hpp&quot;
  89 #endif



  90 #if INCLUDE_JFR
  91 #include &quot;jfr/jfr.hpp&quot;
  92 #endif
  93 
  94 PlaceholderTable*      SystemDictionary::_placeholders        = NULL;
  95 LoaderConstraintTable* SystemDictionary::_loader_constraints  = NULL;
  96 ResolutionErrorTable*  SystemDictionary::_resolution_errors   = NULL;
  97 SymbolPropertyTable*   SystemDictionary::_invoke_method_table = NULL;
  98 ProtectionDomainCacheTable*   SystemDictionary::_pd_cache_table = NULL;
  99 

 100 oop         SystemDictionary::_system_loader_lock_obj     =  NULL;
 101 
 102 InstanceKlass*      SystemDictionary::_well_known_klasses[SystemDictionary::WKID_LIMIT]
 103                                                           =  { NULL /*, NULL...*/ };
 104 
 105 InstanceKlass*      SystemDictionary::_box_klasses[T_VOID+1]      =  { NULL /*, NULL...*/ };
 106 
 107 oop         SystemDictionary::_java_system_loader         =  NULL;
 108 oop         SystemDictionary::_java_platform_loader       =  NULL;
 109 


 110 // Default ProtectionDomainCacheSize value
 111 
 112 const int defaultProtectionDomainCacheSize = 1009;
 113 



 114 // ----------------------------------------------------------------------------
 115 // Java-level SystemLoader and PlatformLoader
 116 
 117 oop SystemDictionary::java_system_loader() {
 118   return _java_system_loader;
 119 }
 120 
 121 oop SystemDictionary::java_platform_loader() {
 122   return _java_platform_loader;
 123 }
 124 
 125 void SystemDictionary::compute_java_loaders(TRAPS) {
 126   JavaValue result(T_OBJECT);
 127   InstanceKlass* class_loader_klass = SystemDictionary::ClassLoader_klass();
 128   JavaCalls::call_static(&amp;result,
 129                          class_loader_klass,
 130                          vmSymbols::getSystemClassLoader_name(),
 131                          vmSymbols::void_classloader_signature(),
 132                          CHECK);
 133 
</pre>
<hr />
<pre>
 156   return java_lang_ClassLoader::parallelCapable(class_loader());
 157 }
 158 // ----------------------------------------------------------------------------
 159 // ParallelDefineClass flag does not apply to bootclass loader
 160 bool SystemDictionary::is_parallelDefine(Handle class_loader) {
 161    if (class_loader.is_null()) return false;
 162    if (AllowParallelDefineClass &amp;&amp; java_lang_ClassLoader::parallelCapable(class_loader())) {
 163      return true;
 164    }
 165    return false;
 166 }
 167 
 168 // Returns true if the passed class loader is the builtin application class loader
 169 // or a custom system class loader. A customer system class loader can be
 170 // specified via -Djava.system.class.loader.
 171 bool SystemDictionary::is_system_class_loader(oop class_loader) {
 172   if (class_loader == NULL) {
 173     return false;
 174   }
 175   return (class_loader-&gt;klass() == SystemDictionary::jdk_internal_loader_ClassLoaders_AppClassLoader_klass() ||
<span class="line-modified"> 176          class_loader == _java_system_loader);</span>
 177 }
 178 
 179 // Returns true if the passed class loader is the platform class loader.
 180 bool SystemDictionary::is_platform_class_loader(oop class_loader) {
 181   if (class_loader == NULL) {
 182     return false;
 183   }
 184   return (class_loader-&gt;klass() == SystemDictionary::jdk_internal_loader_ClassLoaders_PlatformClassLoader_klass());
 185 }
 186 
 187 // ----------------------------------------------------------------------------
 188 // Resolving of classes
 189 
 190 // Forwards to resolve_or_null
 191 
 192 Klass* SystemDictionary::resolve_or_fail(Symbol* class_name, Handle class_loader, Handle protection_domain, bool throw_error, TRAPS) {
 193   Klass* klass = resolve_or_null(class_name, class_loader, protection_domain, THREAD);
 194   if (HAS_PENDING_EXCEPTION || klass == NULL) {
 195     // can return a null klass
 196     klass = handle_resolution_exception(class_name, throw_error, klass, THREAD);
</pre>
<hr />
<pre>
 222     if (throw_error) {
 223       THROW_MSG_NULL(vmSymbols::java_lang_NoClassDefFoundError(), class_name-&gt;as_C_string());
 224     } else {
 225       THROW_MSG_NULL(vmSymbols::java_lang_ClassNotFoundException(), class_name-&gt;as_C_string());
 226     }
 227   }
 228   return klass;
 229 }
 230 
 231 
 232 Klass* SystemDictionary::resolve_or_fail(Symbol* class_name,
 233                                            bool throw_error, TRAPS)
 234 {
 235   return resolve_or_fail(class_name, Handle(), Handle(), throw_error, THREAD);
 236 }
 237 
 238 
 239 // Forwards to resolve_array_class_or_null or resolve_instance_class_or_null
 240 
 241 Klass* SystemDictionary::resolve_or_null(Symbol* class_name, Handle class_loader, Handle protection_domain, TRAPS) {
<span class="line-modified"> 242   if (Signature::is_array(class_name)) {</span>
 243     return resolve_array_class_or_null(class_name, class_loader, protection_domain, THREAD);
 244   } else {
 245     return resolve_instance_class_or_null_helper(class_name, class_loader, protection_domain, THREAD);
 246   }
 247 }
 248 
 249 // name may be in the form of &quot;java/lang/Object&quot; or &quot;Ljava/lang/Object;&quot;
 250 InstanceKlass* SystemDictionary::resolve_instance_class_or_null_helper(Symbol* class_name,
 251                                                                        Handle class_loader,
 252                                                                        Handle protection_domain,
 253                                                                        TRAPS) {
<span class="line-modified"> 254   assert(class_name != NULL &amp;&amp; !Signature::is_array(class_name), &quot;must be&quot;);</span>
<span class="line-modified"> 255   if (Signature::has_envelope(class_name)) {</span>
 256     ResourceMark rm(THREAD);
 257     // Ignore wrapping L and ;.
 258     TempNewSymbol name = SymbolTable::new_symbol(class_name-&gt;as_C_string() + 1,
<span class="line-modified"> 259                                                  class_name-&gt;utf8_length() - 2);</span>
 260     return resolve_instance_class_or_null(name, class_loader, protection_domain, THREAD);
 261   } else {
 262     return resolve_instance_class_or_null(class_name, class_loader, protection_domain, THREAD);
 263   }
 264 }
 265 
 266 Klass* SystemDictionary::resolve_or_null(Symbol* class_name, TRAPS) {
 267   return resolve_or_null(class_name, Handle(), Handle(), THREAD);
 268 }
 269 
 270 // Forwards to resolve_instance_class_or_null
 271 
 272 Klass* SystemDictionary::resolve_array_class_or_null(Symbol* class_name,
 273                                                      Handle class_loader,
 274                                                      Handle protection_domain,
 275                                                      TRAPS) {
<span class="line-modified"> 276   assert(Signature::is_array(class_name), &quot;must be array&quot;);</span>
<span class="line-added"> 277   ResourceMark rm(THREAD);</span>
<span class="line-added"> 278   SignatureStream ss(class_name, false);</span>
<span class="line-added"> 279   int ndims = ss.skip_array_prefix();  // skip all &#39;[&#39;s</span>
 280   Klass* k = NULL;
<span class="line-modified"> 281   BasicType t = ss.type();</span>
<span class="line-modified"> 282   if (ss.has_envelope()) {</span>
<span class="line-modified"> 283     Symbol* obj_class = ss.as_symbol();</span>
<span class="line-modified"> 284     k = SystemDictionary::resolve_instance_class_or_null(obj_class,</span>



 285                                                          class_loader,
 286                                                          protection_domain,
 287                                                          CHECK_NULL);
 288     if (k != NULL) {
<span class="line-modified"> 289       k = k-&gt;array_klass(ndims, CHECK_NULL);</span>
 290     }
 291   } else {
 292     k = Universe::typeArrayKlassObj(t);
<span class="line-modified"> 293     k = TypeArrayKlass::cast(k)-&gt;array_klass(ndims, CHECK_NULL);</span>
 294   }
 295   return k;
 296 }
 297 
 298 
 299 // Must be called for any super-class or super-interface resolution
 300 // during class definition to allow class circularity checking
 301 // super-interface callers:
 302 //    parse_interfaces - for defineClass &amp; jvmtiRedefineClasses
 303 // super-class callers:
 304 //   ClassFileParser - for defineClass &amp; jvmtiRedefineClasses
 305 //   load_shared_class - while loading a class from shared archive
 306 //   resolve_instance_class_or_null:
 307 //     via: handle_parallel_super_load
 308 //      when resolving a class that has an existing placeholder with
 309 //      a saved superclass [i.e. a defineClass is currently in progress]
 310 //      if another thread is trying to resolve the class, it must do
 311 //      super-class checks on its own thread to catch class circularity
 312 // This last call is critical in class circularity checking for cases
 313 // where classloading is delegated to different threads and the
</pre>
<hr />
<pre>
 324 //      3.4 calls resolve_super_or_fail Base
 325 //      3.5 finds T1,Base -&gt; throws class circularity
 326 //OR 4. If T2 tries to resolve Super via defineClass Super ...
 327 //      4.1 resolve_super_or_fail creates placeholder: T2, Super (super Base)
 328 //      4.2 resolve_instance_class_or_null Base, finds placeholder for Base (super Super)
 329 //      4.3 calls resolve_super_or_fail Super in parallel on own thread T2
 330 //      4.4 finds T2, Super -&gt; throws class circularity
 331 // Must be called, even if superclass is null, since this is
 332 // where the placeholder entry is created which claims this
 333 // thread is loading this class/classloader.
 334 // Be careful when modifying this code: once you have run
 335 // placeholders()-&gt;find_and_add(PlaceholderTable::LOAD_SUPER),
 336 // you need to find_and_remove it before returning.
 337 // So be careful to not exit with a CHECK_ macro betweeen these calls.
 338 InstanceKlass* SystemDictionary::resolve_super_or_fail(Symbol* child_name,
 339                                                        Symbol* super_name,
 340                                                        Handle class_loader,
 341                                                        Handle protection_domain,
 342                                                        bool is_superclass,
 343                                                        TRAPS) {
<span class="line-modified"> 344   assert(!Signature::is_array(super_name), &quot;invalid super class name&quot;);</span>
 345 #if INCLUDE_CDS
 346   if (DumpSharedSpaces) {
 347     // Special processing for handling UNREGISTERED shared classes.
 348     InstanceKlass* k = SystemDictionaryShared::dump_time_resolve_super_or_fail(child_name,
 349         super_name, class_loader, protection_domain, is_superclass, CHECK_NULL);
 350     if (k) {
 351       return k;
 352     }
 353   }
 354 #endif // INCLUDE_CDS
 355 
 356   // Double-check, if child class is already loaded, just return super-class,interface
 357   // Don&#39;t add a placedholder if already loaded, i.e. already in appropriate class loader
 358   // dictionary.
 359   // Make sure there&#39;s a placeholder for the *child* before resolving.
 360   // Used as a claim that this thread is currently loading superclass/classloader
 361   // Used here for ClassCircularity checks and also for heap verification
 362   // (every InstanceKlass needs to be in its class loader dictionary or have a placeholder).
 363   // Must check ClassCircularity before checking if super class is already loaded.
 364   //
 365   // We might not already have a placeholder if this child_name was
 366   // first seen via resolve_from_stream (jni_DefineClass or JVM_DefineClass);
 367   // the name of the class might not be known until the stream is actually
 368   // parsed.
 369   // Bugs 4643874, 4715493
 370 
 371   ClassLoaderData* loader_data = class_loader_data(class_loader);
 372   Dictionary* dictionary = loader_data-&gt;dictionary();
 373   unsigned int d_hash = dictionary-&gt;compute_hash(child_name);
 374   unsigned int p_hash = placeholders()-&gt;compute_hash(child_name);
 375   int p_index = placeholders()-&gt;hash_to_index(p_hash);
 376   // can&#39;t throw error holding a lock
 377   bool child_already_loaded = false;
 378   bool throw_circularity_error = false;
 379   {
<span class="line-modified"> 380     MutexLocker mu(THREAD, SystemDictionary_lock);</span>
 381     InstanceKlass* childk = find_class(d_hash, child_name, dictionary);
 382     InstanceKlass* quicksuperk;
 383     // to support // loading: if child done loading, just return superclass
 384     // if super_name, &amp; class_loader don&#39;t match:
 385     // if initial define, SD update will give LinkageError
 386     // if redefine: compare_class_versions will give HIERARCHY_CHANGED
 387     // so we don&#39;t throw an exception here.
 388     // see: nsk redefclass014 &amp; java.lang.instrument Instrument032
 389     if ((childk != NULL ) &amp;&amp; (is_superclass) &amp;&amp;
 390         ((quicksuperk = childk-&gt;java_super()) != NULL) &amp;&amp;
 391          ((quicksuperk-&gt;name() == super_name) &amp;&amp;
<span class="line-modified"> 392             (quicksuperk-&gt;class_loader() == class_loader()))) {</span>
 393            return quicksuperk;
 394     } else {
 395       PlaceholderEntry* probe = placeholders()-&gt;get_entry(p_index, p_hash, child_name, loader_data);
 396       if (probe &amp;&amp; probe-&gt;check_seen_thread(THREAD, PlaceholderTable::LOAD_SUPER)) {
 397           throw_circularity_error = true;
 398       }
 399     }
 400     if (!throw_circularity_error) {
 401       // Be careful not to exit resolve_super
 402       PlaceholderEntry* newprobe = placeholders()-&gt;find_and_add(p_index, p_hash, child_name, loader_data, PlaceholderTable::LOAD_SUPER, super_name, THREAD);
 403     }
 404   }
 405   if (throw_circularity_error) {
 406       ResourceMark rm(THREAD);
 407       THROW_MSG_NULL(vmSymbols::java_lang_ClassCircularityError(), child_name-&gt;as_C_string());
 408   }
 409 
 410 // java.lang.Object should have been found above
 411   assert(super_name != NULL, &quot;null super class for resolving&quot;);
 412   // Resolve the super class or interface, check results on return
 413   InstanceKlass* superk =
 414     SystemDictionary::resolve_instance_class_or_null_helper(super_name,
 415                                                             class_loader,
 416                                                             protection_domain,
 417                                                             THREAD);
 418 
 419   // Clean up of placeholders moved so that each classloadAction registrar self-cleans up
 420   // It is no longer necessary to keep the placeholder table alive until update_dictionary
 421   // or error. GC used to walk the placeholder table as strong roots.
 422   // The instanceKlass is kept alive because the class loader is on the stack,
 423   // which keeps the loader_data alive, as well as all instanceKlasses in
 424   // the loader_data. parseClassFile adds the instanceKlass to loader_data.
 425   {
<span class="line-modified"> 426     MutexLocker mu(THREAD, SystemDictionary_lock);</span>
 427     placeholders()-&gt;find_and_remove(p_index, p_hash, child_name, loader_data, PlaceholderTable::LOAD_SUPER, THREAD);
 428     SystemDictionary_lock-&gt;notify_all();
 429   }
 430   if (HAS_PENDING_EXCEPTION || superk == NULL) {
 431     // can null superk
 432     Klass* k = handle_resolution_exception(super_name, true, superk, THREAD);
 433     assert(k == NULL || k == superk, &quot;must be&quot;);
 434     if (k == NULL) {
 435       superk = NULL;
 436     }
 437   }
 438 
 439   return superk;
 440 }
 441 
 442 void SystemDictionary::validate_protection_domain(InstanceKlass* klass,
 443                                                   Handle class_loader,
 444                                                   Handle protection_domain,
 445                                                   TRAPS) {


 446   // Now we have to call back to java to check if the initating class has access
 447   JavaValue result(T_VOID);
 448   LogTarget(Debug, protectiondomain) lt;
 449   if (lt.is_enabled()) {
<span class="line-modified"> 450     ResourceMark rm(THREAD);</span>
 451     // Print out trace information
 452     LogStream ls(lt);
 453     ls.print_cr(&quot;Checking package access&quot;);
 454     if (class_loader() != NULL) {
 455       ls.print(&quot;class loader: &quot;);
 456       class_loader()-&gt;print_value_on(&amp;ls);
 457     } else {
 458       ls.print_cr(&quot;class loader: NULL&quot;);
 459     }
 460     if (protection_domain() != NULL) {
 461       ls.print(&quot; protection domain: &quot;);
 462       protection_domain()-&gt;print_value_on(&amp;ls);
 463     } else {
 464       ls.print_cr(&quot; protection domain: NULL&quot;);
 465     }
 466     ls.print(&quot; loading: &quot;); klass-&gt;print_value_on(&amp;ls);
 467     ls.cr();
 468   }
 469 
 470   // This handle and the class_loader handle passed in keeps this class from
</pre>
<hr />
<pre>
 482                          protection_domain,
 483                          THREAD);
 484 
 485   if (HAS_PENDING_EXCEPTION) {
 486     log_debug(protectiondomain)(&quot;DENIED !!!!!!!!!!!!!!!!!!!!!&quot;);
 487   } else {
 488    log_debug(protectiondomain)(&quot;granted&quot;);
 489   }
 490 
 491   if (HAS_PENDING_EXCEPTION) return;
 492 
 493   // If no exception has been thrown, we have validated the protection domain
 494   // Insert the protection domain of the initiating class into the set.
 495   {
 496     ClassLoaderData* loader_data = class_loader_data(class_loader);
 497     Dictionary* dictionary = loader_data-&gt;dictionary();
 498 
 499     Symbol*  kn = klass-&gt;name();
 500     unsigned int d_hash = dictionary-&gt;compute_hash(kn);
 501 
<span class="line-modified"> 502     MutexLocker mu(THREAD, SystemDictionary_lock);</span>
 503     int d_index = dictionary-&gt;hash_to_index(d_hash);
 504     dictionary-&gt;add_protection_domain(d_index, d_hash, klass,
 505                                       protection_domain, THREAD);
 506   }
 507 }
 508 
 509 // We only get here if this thread finds that another thread
 510 // has already claimed the placeholder token for the current operation,
 511 // but that other thread either never owned or gave up the
 512 // object lock
 513 // Waits on SystemDictionary_lock to indicate placeholder table updated
 514 // On return, caller must recheck placeholder table state
 515 //
 516 // We only get here if
 517 //  1) custom classLoader, i.e. not bootstrap classloader
 518 //  2) custom classLoader has broken the class loader objectLock
 519 //     so another thread got here in parallel
 520 //
 521 // lockObject must be held.
 522 // Complicated dance due to lock ordering:
 523 // Must first release the classloader object lock to
 524 // allow initial definer to complete the class definition
 525 // and to avoid deadlock
 526 // Reclaim classloader lock object with same original recursion count
 527 // Must release SystemDictionary_lock after notify, since
 528 // class loader lock must be claimed before SystemDictionary_lock
 529 // to prevent deadlocks
 530 //
 531 // The notify allows applications that did an untimed wait() on
 532 // the classloader object lock to not hang.
 533 void SystemDictionary::double_lock_wait(Handle lockObject, TRAPS) {
 534   assert_lock_strong(SystemDictionary_lock);
 535 
 536   bool calledholdinglock
 537       = ObjectSynchronizer::current_thread_holds_lock((JavaThread*)THREAD, lockObject);
 538   assert(calledholdinglock,&quot;must hold lock for notify&quot;);
<span class="line-modified"> 539   assert((lockObject() != _system_loader_lock_obj &amp;&amp; !is_parallelCapable(lockObject)), &quot;unexpected double_lock_wait&quot;);</span>
 540   ObjectSynchronizer::notifyall(lockObject, THREAD);
 541 
 542   TSAN_ONLY(int tsan_rec = 0;)
 543   TSAN_RUNTIME_ONLY(
 544     tsan_rec = SharedRuntime::tsan_oop_rec_unlock(THREAD, lockObject());
 545     assert(tsan_rec &gt; 0, &quot;tsan: unlocking unlocked mutex&quot;);
 546   );
<span class="line-modified"> 547   intx recursions =  ObjectSynchronizer::complete_exit(lockObject, THREAD);</span>
 548   SystemDictionary_lock-&gt;wait();
 549   SystemDictionary_lock-&gt;unlock();
 550   ObjectSynchronizer::reenter(lockObject, recursions, THREAD);
 551   TSAN_RUNTIME_ONLY(SharedRuntime::tsan_oop_rec_lock(THREAD, lockObject(), tsan_rec));
 552   SystemDictionary_lock-&gt;lock();
 553 }
 554 
 555 // If the class in is in the placeholder table, class loading is in progress
 556 // For cases where the application changes threads to load classes, it
 557 // is critical to ClassCircularity detection that we try loading
 558 // the superclass on the same thread internally, so we do parallel
 559 // super class loading here.
 560 // This also is critical in cases where the original thread gets stalled
 561 // even in non-circularity situations.
 562 // Note: must call resolve_super_or_fail even if null super -
 563 // to force placeholder entry creation for this class for circularity detection
 564 // Caller must check for pending exception
 565 // Returns non-null Klass* if other thread has completed load
 566 // and we are done,
 567 // If return null Klass* and no pending exception, the caller must load the class
</pre>
<hr />
<pre>
 576   int p_index = placeholders()-&gt;hash_to_index(p_hash);
 577 
 578   // superk is not used, resolve_super called for circularity check only
 579   // This code is reached in two situations. One if this thread
 580   // is loading the same class twice (e.g. ClassCircularity, or
 581   // java.lang.instrument).
 582   // The second is if another thread started the resolve_super first
 583   // and has not yet finished.
 584   // In both cases the original caller will clean up the placeholder
 585   // entry on error.
 586   Klass* superk = SystemDictionary::resolve_super_or_fail(name,
 587                                                           superclassname,
 588                                                           class_loader,
 589                                                           protection_domain,
 590                                                           true,
 591                                                           CHECK_NULL);
 592 
 593   // parallelCapable class loaders do NOT wait for parallel superclass loads to complete
 594   // Serial class loaders and bootstrap classloader do wait for superclass loads
 595  if (!class_loader.is_null() &amp;&amp; is_parallelCapable(class_loader)) {
<span class="line-modified"> 596     MutexLocker mu(THREAD, SystemDictionary_lock);</span>
 597     // Check if classloading completed while we were loading superclass or waiting
 598     return find_class(d_hash, name, dictionary);
 599   }
 600 
 601   // must loop to both handle other placeholder updates
 602   // and spurious notifications
 603   bool super_load_in_progress = true;
 604   PlaceholderEntry* placeholder;
 605   while (super_load_in_progress) {
<span class="line-modified"> 606     MutexLocker mu(THREAD, SystemDictionary_lock);</span>
 607     // Check if classloading completed while we were loading superclass or waiting
 608     InstanceKlass* check = find_class(d_hash, name, dictionary);
 609     if (check != NULL) {
 610       // Klass is already loaded, so just return it
 611       return check;
 612     } else {
 613       placeholder = placeholders()-&gt;get_entry(p_index, p_hash, name, loader_data);
 614       if (placeholder &amp;&amp; placeholder-&gt;super_load_in_progress() ){
 615         // We only get here if the application has released the
 616         // classloader lock when another thread was in the middle of loading a
 617         // superclass/superinterface for this class, and now
 618         // this thread is also trying to load this class.
 619         // To minimize surprises, the first thread that started to
 620         // load a class should be the one to complete the loading
 621         // with the classfile it initially expected.
 622         // This logic has the current thread wait once it has done
 623         // all the superclass/superinterface loading it can, until
 624         // the original thread completes the class loading or fails
 625         // If it completes we will use the resulting InstanceKlass
 626         // which we will find below in the systemDictionary.
</pre>
<hr />
<pre>
 643   assert(event != NULL, &quot;invariant&quot;);
 644   assert(k != NULL, &quot;invariant&quot;);
 645   assert(event-&gt;should_commit(), &quot;invariant&quot;);
 646   event-&gt;set_loadedClass(k);
 647   event-&gt;set_definingClassLoader(k-&gt;class_loader_data());
 648   event-&gt;set_initiatingClassLoader(init_cld);
 649   event-&gt;commit();
 650 }
 651 
 652 
 653 // Be careful when modifying this code: once you have run
 654 // placeholders()-&gt;find_and_add(PlaceholderTable::LOAD_INSTANCE),
 655 // you need to find_and_remove it before returning.
 656 // So be careful to not exit with a CHECK_ macro betweeen these calls.
 657 //
 658 // name must be in the form of &quot;java/lang/Object&quot; -- cannot be &quot;Ljava/lang/Object;&quot;
 659 InstanceKlass* SystemDictionary::resolve_instance_class_or_null(Symbol* name,
 660                                                                 Handle class_loader,
 661                                                                 Handle protection_domain,
 662                                                                 TRAPS) {
<span class="line-modified"> 663   assert(name != NULL &amp;&amp; !Signature::is_array(name) &amp;&amp;</span>
<span class="line-modified"> 664          !Signature::has_envelope(name), &quot;invalid class name&quot;);</span>
 665 
 666   EventClassLoad class_load_start_event;
 667 
 668   HandleMark hm(THREAD);
 669 
 670   // Fix for 4474172; see evaluation for more details
 671   class_loader = Handle(THREAD, java_lang_ClassLoader::non_reflection_class_loader(class_loader()));
 672   ClassLoaderData* loader_data = register_loader(class_loader);
 673   Dictionary* dictionary = loader_data-&gt;dictionary();
 674   unsigned int d_hash = dictionary-&gt;compute_hash(name);
 675 
 676   // Do lookup to see if class already exist and the protection domain
 677   // has the right access
 678   // This call uses find which checks protection domain already matches
 679   // All subsequent calls use find_class, and set has_loaded_class so that
 680   // before we return a result we call out to java to check for valid protection domain
 681   // to allow returning the Klass* and add it to the pd_set if it is valid
 682   {
 683     InstanceKlass* probe = dictionary-&gt;find(d_hash, name, protection_domain);
 684     if (probe != NULL) return probe;
</pre>
<hr />
<pre>
 703 
 704   // Class is not in SystemDictionary so we have to do loading.
 705   // Make sure we are synchronized on the class loader before we proceed
 706   Handle lockObject = compute_loader_lock_object(class_loader, THREAD);
 707   check_loader_lock_contention(lockObject, THREAD);
 708   ObjectLocker ol(lockObject, THREAD, DoObjectLock);
 709 
 710   // Check again (after locking) if class already exist in SystemDictionary
 711   bool class_has_been_loaded   = false;
 712   bool super_load_in_progress  = false;
 713   bool havesupername = false;
 714   InstanceKlass* k = NULL;
 715   PlaceholderEntry* placeholder;
 716   Symbol* superclassname = NULL;
 717 
 718   assert(THREAD-&gt;can_call_java(),
 719          &quot;can not load classes with compiler thread: class=%s, classloader=%s&quot;,
 720          name-&gt;as_C_string(),
 721          class_loader.is_null() ? &quot;null&quot; : class_loader-&gt;klass()-&gt;name()-&gt;as_C_string());
 722   {
<span class="line-modified"> 723     MutexLocker mu(THREAD, SystemDictionary_lock);</span>
 724     InstanceKlass* check = find_class(d_hash, name, dictionary);
 725     if (check != NULL) {
 726       // InstanceKlass is already loaded, so just return it
 727       class_has_been_loaded = true;
 728       k = check;
 729     } else {
 730       placeholder = placeholders()-&gt;get_entry(p_index, p_hash, name, loader_data);
 731       if (placeholder &amp;&amp; placeholder-&gt;super_load_in_progress()) {
 732          super_load_in_progress = true;
 733          if (placeholder-&gt;havesupername() == true) {
 734            superclassname = placeholder-&gt;supername();
 735            havesupername = true;
 736          }
 737       }
 738     }
 739   }
 740 
 741   // If the class is in the placeholder table, class loading is in progress
 742   if (super_load_in_progress &amp;&amp; havesupername==true) {
 743     k = handle_parallel_super_load(name,
</pre>
<hr />
<pre>
 763     // in parallel with a classload of same classname
 764     // Redefineclasses uses existence of the placeholder for the duration
 765     // of the class load to prevent concurrent redefinition of not completely
 766     // defined classes.
 767     // case 1. traditional classloaders that rely on the classloader object lock
 768     //   - no other need for LOAD_INSTANCE
 769     // case 2. traditional classloaders that break the classloader object lock
 770     //    as a deadlock workaround. Detection of this case requires that
 771     //    this check is done while holding the classloader object lock,
 772     //    and that lock is still held when calling classloader&#39;s loadClass.
 773     //    For these classloaders, we ensure that the first requestor
 774     //    completes the load and other requestors wait for completion.
 775     // case 3. Bootstrap classloader - don&#39;t own objectLocker
 776     //    This classloader supports parallelism at the classloader level,
 777     //    but only allows a single load of a class/classloader pair.
 778     //    No performance benefit and no deadlock issues.
 779     // case 4. parallelCapable user level classloaders - without objectLocker
 780     //    Allow parallel classloading of a class/classloader pair
 781 
 782     {
<span class="line-modified"> 783       MutexLocker mu(THREAD, SystemDictionary_lock);</span>
 784       if (class_loader.is_null() || !is_parallelCapable(class_loader)) {
 785         PlaceholderEntry* oldprobe = placeholders()-&gt;get_entry(p_index, p_hash, name, loader_data);
 786         if (oldprobe) {
 787           // only need check_seen_thread once, not on each loop
 788           // 6341374 java/lang/Instrument with -Xcomp
 789           if (oldprobe-&gt;check_seen_thread(THREAD, PlaceholderTable::LOAD_INSTANCE)) {
 790             throw_circularity_error = true;
 791           } else {
 792             // case 1: traditional: should never see load_in_progress.
 793             while (!class_has_been_loaded &amp;&amp; oldprobe &amp;&amp; oldprobe-&gt;instance_load_in_progress()) {
 794 
 795               // case 3: bootstrap classloader: prevent futile classloading,
 796               // wait on first requestor
 797               if (class_loader.is_null()) {
 798                 SystemDictionary_lock-&gt;wait();
 799               } else {
 800               // case 2: traditional with broken classloader lock. wait on first
 801               // requestor.
 802                 double_lock_wait(lockObject, THREAD);
 803               }
</pre>
<hr />
<pre>
 834           class_has_been_loaded = true;
 835         }
 836       }
 837     }
 838 
 839     // must throw error outside of owning lock
 840     if (throw_circularity_error) {
 841       assert(!HAS_PENDING_EXCEPTION &amp;&amp; load_instance_added == false,&quot;circularity error cleanup&quot;);
 842       ResourceMark rm(THREAD);
 843       THROW_MSG_NULL(vmSymbols::java_lang_ClassCircularityError(), name-&gt;as_C_string());
 844     }
 845 
 846     if (!class_has_been_loaded) {
 847 
 848       // Do actual loading
 849       k = load_instance_class(name, class_loader, THREAD);
 850 
 851       // If everything was OK (no exceptions, no null return value), and
 852       // class_loader is NOT the defining loader, do a little more bookkeeping.
 853       if (!HAS_PENDING_EXCEPTION &amp;&amp; k != NULL &amp;&amp;
<span class="line-modified"> 854         k-&gt;class_loader() != class_loader()) {</span>
 855 
 856         check_constraints(d_hash, k, class_loader, false, THREAD);
 857 
 858         // Need to check for a PENDING_EXCEPTION again; check_constraints
 859         // can throw but we may have to remove entry from the placeholder table below.
 860         if (!HAS_PENDING_EXCEPTION) {
 861           // Record dependency for non-parent delegation.
 862           // This recording keeps the defining class loader of the klass (k) found
 863           // from being unloaded while the initiating class loader is loaded
 864           // even if the reference to the defining class loader is dropped
 865           // before references to the initiating class loader.
 866           loader_data-&gt;record_dependency(k);
 867 
 868           { // Grabbing the Compile_lock prevents systemDictionary updates
 869             // during compilations.
<span class="line-modified"> 870             MutexLocker mu(THREAD, Compile_lock);</span>
 871             update_dictionary(d_hash, p_index, p_hash,
 872               k, class_loader, THREAD);
 873           }
 874 
 875           if (JvmtiExport::should_post_class_load()) {
 876             Thread *thread = THREAD;
 877             assert(thread-&gt;is_Java_thread(), &quot;thread-&gt;is_Java_thread()&quot;);
 878             JvmtiExport::post_class_load((JavaThread *) thread, k);
 879           }
 880         }
 881       }
 882     } // load_instance_class
 883 
 884     if (load_instance_added == true) {
 885       // clean up placeholder entries for LOAD_INSTANCE success or error
 886       // This brackets the SystemDictionary updates for both defining
 887       // and initiating loaders
<span class="line-modified"> 888       MutexLocker mu(THREAD, SystemDictionary_lock);</span>
 889       placeholders()-&gt;find_and_remove(p_index, p_hash, name, loader_data, PlaceholderTable::LOAD_INSTANCE, THREAD);
 890       SystemDictionary_lock-&gt;notify_all();
 891     }
 892   }
 893 
 894   if (HAS_PENDING_EXCEPTION || k == NULL) {
 895     return NULL;
 896   }
 897   if (class_load_start_event.should_commit()) {
 898     post_class_load_event(&amp;class_load_start_event, k, loader_data);
 899   }
 900 #ifdef ASSERT
 901   {
 902     ClassLoaderData* loader_data = k-&gt;class_loader_data();
<span class="line-modified"> 903     MutexLocker mu(THREAD, SystemDictionary_lock);</span>
 904     InstanceKlass* kk = find_class(name, loader_data);
 905     assert(kk == k, &quot;should be present in dictionary&quot;);
 906   }
 907 #endif
 908 
 909   // return if the protection domain in NULL
 910   if (protection_domain() == NULL) return k;
 911 
 912   // Check the protection domain has the right access
 913   if (dictionary-&gt;is_valid_protection_domain(d_hash, name,
 914                                              protection_domain)) {
 915     return k;
 916   }
 917 
 918   // Verify protection domain. If it fails an exception is thrown
 919   validate_protection_domain(k, class_loader, protection_domain, CHECK_NULL);
 920 
 921   return k;
 922 }
 923 
</pre>
<hr />
<pre>
 949     // then the class loader has no entries in the dictionary.
 950     return NULL;
 951   }
 952 
 953   Dictionary* dictionary = loader_data-&gt;dictionary();
 954   unsigned int d_hash = dictionary-&gt;compute_hash(class_name);
 955   return dictionary-&gt;find(d_hash, class_name,
 956                           protection_domain);
 957 }
 958 
 959 
 960 // Look for a loaded instance or array klass by name.  Do not do any loading.
 961 // return NULL in case of error.
 962 Klass* SystemDictionary::find_instance_or_array_klass(Symbol* class_name,
 963                                                       Handle class_loader,
 964                                                       Handle protection_domain,
 965                                                       TRAPS) {
 966   Klass* k = NULL;
 967   assert(class_name != NULL, &quot;class name must be non NULL&quot;);
 968 
<span class="line-modified"> 969   if (Signature::is_array(class_name)) {</span>
 970     // The name refers to an array.  Parse the name.
 971     // dimension and object_key in FieldArrayInfo are assigned as a
 972     // side-effect of this call
<span class="line-modified"> 973     SignatureStream ss(class_name, false);</span>
<span class="line-modified"> 974     int ndims = ss.skip_array_prefix();  // skip all &#39;[&#39;s</span>
<span class="line-added"> 975     BasicType t = ss.type();</span>
 976     if (t != T_OBJECT) {
 977       k = Universe::typeArrayKlassObj(t);
 978     } else {
<span class="line-modified"> 979       Symbol* obj_class = ss.as_symbol();</span>
<span class="line-added"> 980       k = SystemDictionary::find(obj_class, class_loader, protection_domain, THREAD);</span>
 981     }
 982     if (k != NULL) {
<span class="line-modified"> 983       k = k-&gt;array_klass_or_null(ndims);</span>
 984     }
 985   } else {
 986     k = find(class_name, class_loader, protection_domain, THREAD);
 987   }
 988   return k;
 989 }
 990 
 991 // Note: this method is much like resolve_from_stream, but
 992 // does not publish the classes via the SystemDictionary.
 993 // Handles unsafe_DefineAnonymousClass and redefineclasses
 994 // RedefinedClasses do not add to the class hierarchy
 995 InstanceKlass* SystemDictionary::parse_stream(Symbol* class_name,
 996                                               Handle class_loader,
 997                                               Handle protection_domain,
 998                                               ClassFileStream* st,
 999                                               const InstanceKlass* unsafe_anonymous_host,
1000                                               GrowableArray&lt;Handle&gt;* cp_patches,
1001                                               TRAPS) {
1002 
1003   EventClassLoad class_load_start_event;
1004 
1005   ClassLoaderData* loader_data;
1006   if (unsafe_anonymous_host != NULL) {
1007     // Create a new CLD for an unsafe anonymous class, that uses the same class loader
1008     // as the unsafe_anonymous_host
<span class="line-modified">1009     guarantee(unsafe_anonymous_host-&gt;class_loader() == class_loader(), &quot;should be the same&quot;);</span>
1010     loader_data = ClassLoaderData::unsafe_anonymous_class_loader_data(class_loader);
1011   } else {
1012     loader_data = ClassLoaderData::class_loader_data(class_loader());
1013   }
1014 
1015   assert(st != NULL, &quot;invariant&quot;);
1016   assert(st-&gt;need_verify(), &quot;invariant&quot;);
1017 
1018   // Parse stream and create a klass.
1019   // Note that we do this even though this klass might
1020   // already be present in the SystemDictionary, otherwise we would not
1021   // throw potential ClassFormatErrors.
1022 
1023   InstanceKlass* k = KlassFactory::create_from_stream(st,
1024                                                       class_name,
1025                                                       loader_data,
1026                                                       protection_domain,
1027                                                       unsafe_anonymous_host,
1028                                                       cp_patches,
1029                                                       CHECK_NULL);
1030 
1031   if (unsafe_anonymous_host != NULL &amp;&amp; k != NULL) {
1032     // Unsafe anonymous classes must update ClassLoaderData holder (was unsafe_anonymous_host loader)
1033     // so that they can be unloaded when the mirror is no longer referenced.
1034     k-&gt;class_loader_data()-&gt;initialize_holder(Handle(THREAD, k-&gt;java_mirror()));
1035 
1036     {
<span class="line-modified">1037       MutexLocker mu_r(THREAD, Compile_lock);</span>
1038 
1039       // Add to class hierarchy, initialize vtables, and do possible
1040       // deoptimizations.
1041       add_to_hierarchy(k, CHECK_NULL); // No exception, but can block




1042       // But, do not add to dictionary.
1043     }
1044 
1045     // Rewrite and patch constant pool here.
1046     k-&gt;link_class(CHECK_NULL);
1047     if (cp_patches != NULL) {
1048       k-&gt;constants()-&gt;patch_resolved_references(cp_patches);
1049     }
1050 
1051     // If it&#39;s anonymous, initialize it now, since nobody else will.
1052     k-&gt;eager_initialize(CHECK_NULL);
1053 
1054     // notify jvmti
1055     if (JvmtiExport::should_post_class_load()) {
1056         assert(THREAD-&gt;is_Java_thread(), &quot;thread-&gt;is_Java_thread()&quot;);
1057         JvmtiExport::post_class_load((JavaThread *) THREAD, k);
1058     }
1059     if (class_load_start_event.should_commit()) {
1060       post_class_load_event(&amp;class_load_start_event, k, loader_data);
1061     }
</pre>
<hr />
<pre>
1135     InstanceKlass* defined_k = find_or_define_instance_class(h_name, class_loader, k, THREAD);
1136     if (!HAS_PENDING_EXCEPTION &amp;&amp; defined_k != k) {
1137       // If a parallel capable class loader already defined this class, register &#39;k&#39; for cleanup.
1138       assert(defined_k != NULL, &quot;Should have a klass if there&#39;s no exception&quot;);
1139       loader_data-&gt;add_to_deallocate_list(k);
1140       k = defined_k;
1141     }
1142   } else {
1143     define_instance_class(k, THREAD);
1144   }
1145 
1146   // If defining the class throws an exception register &#39;k&#39; for cleanup.
1147   if (HAS_PENDING_EXCEPTION) {
1148     assert(k != NULL, &quot;Must have an instance klass here!&quot;);
1149     loader_data-&gt;add_to_deallocate_list(k);
1150     return NULL;
1151   }
1152 
1153   // Make sure we have an entry in the SystemDictionary on success
1154   debug_only( {
<span class="line-modified">1155     MutexLocker mu(THREAD, SystemDictionary_lock);</span>
1156 
1157     Klass* check = find_class(h_name, k-&gt;class_loader_data());
1158     assert(check == k, &quot;should be present in the dictionary&quot;);
1159   } );
1160 
1161   return k;
1162 }
1163 
1164 #if INCLUDE_CDS
1165 // Load a class for boot loader from the shared spaces. This also
1166 // forces the super class and all interfaces to be loaded.
1167 InstanceKlass* SystemDictionary::load_shared_boot_class(Symbol* class_name,
1168                                                         TRAPS) {
1169   InstanceKlass* ik = SystemDictionaryShared::find_builtin_class(class_name);
1170   if (ik != NULL &amp;&amp; ik-&gt;is_shared_boot_class()) {
1171     return load_shared_class(ik, Handle(), Handle(), NULL, THREAD);
1172   }
1173   return NULL;
1174 }
1175 
1176 // Check if a shared class can be loaded by the specific classloader:
1177 //
1178 // NULL classloader:
1179 //   - Module class from &quot;modules&quot; jimage. ModuleEntry must be defined in the classloader.
1180 //   - Class from -Xbootclasspath/a. The class has no defined PackageEntry, or must
1181 //     be defined in an unnamed module.
1182 bool SystemDictionary::is_shared_class_visible(Symbol* class_name,
1183                                                InstanceKlass* ik,
1184                                                Handle class_loader, TRAPS) {
1185   assert(!ModuleEntryTable::javabase_moduleEntry()-&gt;is_patched(),
1186          &quot;Cannot use sharing if java.base is patched&quot;);
<span class="line-modified">1187   ResourceMark rm(THREAD);</span>
1188   int path_index = ik-&gt;shared_classpath_index();
1189   ClassLoaderData* loader_data = class_loader_data(class_loader);
1190   if (path_index &lt; 0) {
1191     // path_index &lt; 0 indicates that the class is intended for a custom loader
1192     // and should not be loaded by boot/platform/app loaders
1193     if (loader_data-&gt;is_builtin_class_loader_data()) {
1194       return false;
1195     } else {
1196       return true;
1197     }
1198   }
1199   SharedClassPathEntry* ent =
1200             (SharedClassPathEntry*)FileMapInfo::shared_path(path_index);
1201   if (!Universe::is_module_initialized()) {
1202     assert(ent != NULL &amp;&amp; ent-&gt;is_modules_image(),
1203            &quot;Loading non-bootstrap classes before the module system is initialized&quot;);
1204     assert(class_loader.is_null(), &quot;sanity&quot;);
1205     return true;
1206   }
1207   // Get the pkg_entry from the classloader
1208   TempNewSymbol pkg_name = NULL;
1209   PackageEntry* pkg_entry = NULL;
1210   ModuleEntry* mod_entry = NULL;

1211   pkg_name = InstanceKlass::package_from_name(class_name, CHECK_false);
1212   if (pkg_name != NULL) {

1213     if (loader_data != NULL) {
1214       pkg_entry = loader_data-&gt;packages()-&gt;lookup_only(pkg_name);
1215     }
1216     if (pkg_entry != NULL) {
1217       mod_entry = pkg_entry-&gt;module();
1218     }
1219   }
1220 
1221   // If the archived class is from a module that has been patched at runtime,
1222   // the class cannot be loaded from the archive.
1223   if (mod_entry != NULL &amp;&amp; mod_entry-&gt;is_patched()) {
1224     return false;
1225   }
1226 
1227   if (class_loader.is_null()) {
1228     assert(ent != NULL, &quot;Shared class for NULL classloader must have valid SharedClassPathEntry&quot;);
1229     // The NULL classloader can load archived class originated from the
1230     // &quot;modules&quot; jimage and the -Xbootclasspath/a. For class from the
1231     // &quot;modules&quot; jimage, the PackageEntry/ModuleEntry must be defined
1232     // by the NULL classloader.
1233     if (mod_entry != NULL) {
1234       // PackageEntry/ModuleEntry is found in the classloader. Check if the
1235       // ModuleEntry&#39;s location agrees with the archived class&#39; origination.
1236       if (ent-&gt;is_modules_image() &amp;&amp; mod_entry-&gt;location()-&gt;starts_with(&quot;jrt:&quot;)) {
1237         return true; // Module class from the &quot;module&quot; jimage
1238       }
1239     }
1240 
1241     // If the archived class is not from the &quot;module&quot; jimage, the class can be
1242     // loaded by the NULL classloader if
1243     //
1244     // 1. the class is from the unamed package
1245     // 2. or, the class is not from a module defined in the NULL classloader
1246     // 3. or, the class is from an unamed module
1247     if (!ent-&gt;is_modules_image() &amp;&amp; ik-&gt;is_shared_boot_class()) {
1248       // the class is from the -Xbootclasspath/a
<span class="line-modified">1249       if (pkg_name == NULL ||</span>
1250           pkg_entry == NULL ||
1251           pkg_entry-&gt;in_unnamed_module()) {
1252         assert(mod_entry == NULL ||
1253                mod_entry == loader_data-&gt;unnamed_module(),
1254                &quot;the unnamed module is not defined in the classloader&quot;);
1255         return true;
1256       }
1257     }
1258     return false;
1259   } else {
1260     bool res = SystemDictionaryShared::is_shared_class_visible_for_classloader(
<span class="line-modified">1261               ik, class_loader, pkg_name, pkg_entry, mod_entry, CHECK_(false));</span>

1262     return res;
1263   }
1264 }
1265 
1266 InstanceKlass* SystemDictionary::load_shared_class(InstanceKlass* ik,
1267                                                    Handle class_loader,
1268                                                    Handle protection_domain,
1269                                                    const ClassFileStream *cfs,
1270                                                    TRAPS) {
<span class="line-added">1271   assert(ik != NULL, &quot;sanity&quot;);</span>
<span class="line-added">1272   assert(!ik-&gt;is_unshareable_info_restored(), &quot;shared class can be loaded only once&quot;);</span>
<span class="line-added">1273   Symbol* class_name = ik-&gt;name();</span>
1274 
<span class="line-modified">1275   bool visible = is_shared_class_visible(</span>
<span class="line-modified">1276                           class_name, ik, class_loader, CHECK_NULL);</span>
<span class="line-added">1277   if (!visible) {</span>
<span class="line-added">1278     return NULL;</span>
<span class="line-added">1279   }</span>
1280 
<span class="line-modified">1281   // Resolve the superclass and interfaces. They must be the same</span>
<span class="line-modified">1282   // as in dump time, because the layout of &lt;ik&gt; depends on</span>
<span class="line-modified">1283   // the specific layout of ik-&gt;super() and ik-&gt;local_interfaces().</span>
<span class="line-added">1284   //</span>
<span class="line-added">1285   // If unexpected superclass or interfaces are found, we cannot</span>
<span class="line-added">1286   // load &lt;ik&gt; from the shared archive.</span>
<span class="line-added">1287 </span>
<span class="line-added">1288   if (ik-&gt;super() != NULL) {</span>
<span class="line-added">1289     Symbol*  cn = ik-&gt;super()-&gt;name();</span>
<span class="line-added">1290     Klass *s = resolve_super_or_fail(class_name, cn,</span>
<span class="line-added">1291                                      class_loader, protection_domain, true, CHECK_NULL);</span>
<span class="line-added">1292     if (s != ik-&gt;super()) {</span>
<span class="line-added">1293       // The dynamically resolved super class is not the same as the one we used during dump time,</span>
<span class="line-added">1294       // so we cannot use ik.</span>
1295       return NULL;
<span class="line-added">1296     } else {</span>
<span class="line-added">1297       assert(s-&gt;is_shared(), &quot;must be&quot;);</span>
1298     }
<span class="line-added">1299   }</span>
1300 
<span class="line-modified">1301   Array&lt;InstanceKlass*&gt;* interfaces = ik-&gt;local_interfaces();</span>
<span class="line-modified">1302   int num_interfaces = interfaces-&gt;length();</span>
<span class="line-modified">1303   for (int index = 0; index &lt; num_interfaces; index++) {</span>
<span class="line-modified">1304     InstanceKlass* k = interfaces-&gt;at(index);</span>
<span class="line-modified">1305     Symbol* name  = k-&gt;name();</span>
<span class="line-modified">1306     Klass* i = resolve_super_or_fail(class_name, name, class_loader, protection_domain, false, CHECK_NULL);</span>
<span class="line-modified">1307     if (k != i) {</span>
<span class="line-modified">1308       // The dynamically resolved interface class is not the same as the one we used during dump time,</span>
<span class="line-modified">1309       // so we cannot use ik.</span>
<span class="line-modified">1310       return NULL;</span>
<span class="line-modified">1311     } else {</span>
<span class="line-modified">1312       assert(i-&gt;is_shared(), &quot;must be&quot;);</span>





















1313     }
<span class="line-added">1314   }</span>
1315 
<span class="line-modified">1316   InstanceKlass* new_ik = KlassFactory::check_shared_class_file_load_hook(</span>
<span class="line-modified">1317       ik, class_name, class_loader, protection_domain, cfs, CHECK_NULL);</span>
<span class="line-modified">1318   if (new_ik != NULL) {</span>
<span class="line-modified">1319     // The class is changed by CFLH. Return the new class. The shared class is</span>
<span class="line-modified">1320     // not used.</span>
<span class="line-modified">1321     return new_ik;</span>
<span class="line-modified">1322   }</span>
1323 
<span class="line-modified">1324   // Adjust methods to recover missing data.  They need addresses for</span>
<span class="line-modified">1325   // interpreter entry points and their default native method address</span>
<span class="line-modified">1326   // must be reset.</span>
1327 
<span class="line-modified">1328   // Updating methods must be done under a lock so multiple</span>
<span class="line-modified">1329   // threads don&#39;t update these in parallel</span>
<span class="line-modified">1330   //</span>
<span class="line-modified">1331   // Shared classes are all currently loaded by either the bootstrap or</span>
<span class="line-modified">1332   // internal parallel class loaders, so this will never cause a deadlock</span>
<span class="line-modified">1333   // on a custom class loader lock.</span>
1334 
<span class="line-modified">1335   ClassLoaderData* loader_data = ClassLoaderData::class_loader_data(class_loader());</span>
<span class="line-modified">1336   {</span>
<span class="line-modified">1337     HandleMark hm(THREAD);</span>
<span class="line-modified">1338     Handle lockObject = compute_loader_lock_object(class_loader, THREAD);</span>
<span class="line-modified">1339     check_loader_lock_contention(lockObject, THREAD);</span>
<span class="line-modified">1340     ObjectLocker ol(lockObject, THREAD, true);</span>
<span class="line-modified">1341     // prohibited package check assumes all classes loaded from archive call</span>
<span class="line-modified">1342     // restore_unshareable_info which calls ik-&gt;set_package()</span>
<span class="line-modified">1343     ik-&gt;restore_unshareable_info(loader_data, protection_domain, CHECK_NULL);</span>
<span class="line-modified">1344   }</span>
1345 
<span class="line-modified">1346   ik-&gt;print_class_load_logging(loader_data, NULL, NULL);</span>
1347 
<span class="line-modified">1348   // For boot loader, ensure that GetSystemPackage knows that a class in this</span>
<span class="line-modified">1349   // package was loaded.</span>
<span class="line-modified">1350   if (class_loader.is_null()) {</span>
<span class="line-modified">1351     int path_index = ik-&gt;shared_classpath_index();</span>
<span class="line-modified">1352     ResourceMark rm(THREAD);</span>
<span class="line-modified">1353     ClassLoader::add_package(ik-&gt;name()-&gt;as_C_string(), path_index, THREAD);</span>
<span class="line-modified">1354   }</span>
1355 
<span class="line-modified">1356   if (DumpLoadedClassList != NULL &amp;&amp; classlist_file-&gt;is_open()) {</span>
<span class="line-modified">1357     // Only dump the classes that can be stored into CDS archive</span>
<span class="line-modified">1358     if (SystemDictionaryShared::is_sharing_possible(loader_data)) {</span>
<span class="line-modified">1359       ResourceMark rm(THREAD);</span>
<span class="line-modified">1360       classlist_file-&gt;print_cr(&quot;%s&quot;, ik-&gt;name()-&gt;as_C_string());</span>
<span class="line-modified">1361       classlist_file-&gt;flush();</span>

1362     }
<span class="line-added">1363   }</span>
1364 
<span class="line-modified">1365   // notify a class loaded from shared object</span>
<span class="line-modified">1366   ClassLoadingService::notify_class_loaded(ik, true /* shared class */);</span>
1367 
<span class="line-modified">1368   ik-&gt;set_has_passed_fingerprint_check(false);</span>
<span class="line-modified">1369   if (UseAOT &amp;&amp; ik-&gt;supers_have_passed_fingerprint_checks()) {</span>
<span class="line-modified">1370     uint64_t aot_fp = AOTLoader::get_saved_fingerprint(ik);</span>
<span class="line-modified">1371     uint64_t cds_fp = ik-&gt;get_stored_fingerprint();</span>
<span class="line-modified">1372     if (aot_fp != 0 &amp;&amp; aot_fp == cds_fp) {</span>
<span class="line-modified">1373       // This class matches with a class saved in an AOT library</span>
<span class="line-modified">1374       ik-&gt;set_has_passed_fingerprint_check(true);</span>
<span class="line-modified">1375     } else {</span>
<span class="line-modified">1376       if (log_is_enabled(Info, class, fingerprint)) {</span>
<span class="line-added">1377         ResourceMark rm(THREAD);</span>
1378         log_info(class, fingerprint)(&quot;%s :  expected = &quot; PTR64_FORMAT &quot; actual = &quot; PTR64_FORMAT, ik-&gt;external_name(), aot_fp, cds_fp);
1379       }
1380     }
1381   }
<span class="line-added">1382 </span>
1383   return ik;
1384 }
1385 #endif // INCLUDE_CDS
1386 
1387 InstanceKlass* SystemDictionary::load_instance_class(Symbol* class_name, Handle class_loader, TRAPS) {
1388 
1389   if (class_loader.is_null()) {
<span class="line-modified">1390     ResourceMark rm(THREAD);</span>
1391     PackageEntry* pkg_entry = NULL;
1392     bool search_only_bootloader_append = false;
1393     ClassLoaderData *loader_data = class_loader_data(class_loader);
1394 
1395     // Find the package in the boot loader&#39;s package entry table.
1396     TempNewSymbol pkg_name = InstanceKlass::package_from_name(class_name, CHECK_NULL);
1397     if (pkg_name != NULL) {
1398       pkg_entry = loader_data-&gt;packages()-&gt;lookup_only(pkg_name);
1399     }
1400 
1401     // Prior to attempting to load the class, enforce the boot loader&#39;s
1402     // visibility boundaries.
1403     if (!Universe::is_module_initialized()) {
1404       // During bootstrapping, prior to module initialization, any
1405       // class attempting to be loaded must be checked against the
1406       // java.base packages in the boot loader&#39;s PackageEntryTable.
1407       // No class outside of java.base is allowed to be loaded during
1408       // this bootstrapping window.
1409       if (pkg_entry == NULL || pkg_entry-&gt;in_unnamed_module()) {
1410         // Class is either in the unnamed package or in
</pre>
<hr />
<pre>
1417         if (ModuleEntryTable::javabase_defined()) {
1418           return NULL;
1419         }
1420       } else {
1421         // Check that the class&#39; package is defined within java.base.
1422         ModuleEntry* mod_entry = pkg_entry-&gt;module();
1423         Symbol* mod_entry_name = mod_entry-&gt;name();
1424         if (mod_entry_name-&gt;fast_compare(vmSymbols::java_base()) != 0) {
1425           return NULL;
1426         }
1427       }
1428     } else {
1429       // After the module system has been initialized, check if the class&#39;
1430       // package is in a module defined to the boot loader.
1431       if (pkg_name == NULL || pkg_entry == NULL || pkg_entry-&gt;in_unnamed_module()) {
1432         // Class is either in the unnamed package, in a named package
1433         // within a module not defined to the boot loader or in a
1434         // a named package within the unnamed module.  In all cases,
1435         // limit visibility to search for the class only in the boot
1436         // loader&#39;s append path.
<span class="line-added">1437         if (!ClassLoader::has_bootclasspath_append()) {</span>
<span class="line-added">1438            // If there is no bootclasspath append entry, no need to continue</span>
<span class="line-added">1439            // searching.</span>
<span class="line-added">1440            return NULL;</span>
<span class="line-added">1441         }</span>
1442         search_only_bootloader_append = true;
1443       }
1444     }
1445 
1446     // Prior to bootstrapping&#39;s module initialization, never load a class outside
1447     // of the boot loader&#39;s module path
1448     assert(Universe::is_module_initialized() ||
1449            !search_only_bootloader_append,
1450            &quot;Attempt to load a class outside of boot loader&#39;s module path&quot;);
1451 
1452     // Search for classes in the CDS archive.
1453     InstanceKlass* k = NULL;
1454     {
1455 #if INCLUDE_CDS
1456       PerfTraceTime vmtimer(ClassLoader::perf_shared_classload_time());
1457       k = load_shared_boot_class(class_name, THREAD);
1458 #endif
1459     }
1460 
1461     if (k == NULL) {
</pre>
<hr />
<pre>
1555  if (!class_loader_h.is_null() &amp;&amp; !is_parallelCapable(class_loader_h)) {
1556     assert(ObjectSynchronizer::current_thread_holds_lock((JavaThread*)THREAD,
1557          compute_loader_lock_object(class_loader_h, THREAD)),
1558          &quot;define called without lock&quot;);
1559   }
1560 
1561   // Check class-loading constraints. Throw exception if violation is detected.
1562   // Grabs and releases SystemDictionary_lock
1563   // The check_constraints/find_class call and update_dictionary sequence
1564   // must be &quot;atomic&quot; for a specific class/classloader pair so we never
1565   // define two different instanceKlasses for that class/classloader pair.
1566   // Existing classloaders will call define_instance_class with the
1567   // classloader lock held
1568   // Parallel classloaders will call find_or_define_instance_class
1569   // which will require a token to perform the define class
1570   Symbol*  name_h = k-&gt;name();
1571   Dictionary* dictionary = loader_data-&gt;dictionary();
1572   unsigned int d_hash = dictionary-&gt;compute_hash(name_h);
1573   check_constraints(d_hash, k, class_loader_h, true, CHECK);
1574 
<span class="line-modified">1575   // Register class just loaded with class loader (placed in ArrayList)</span>
1576   // Note we do this before updating the dictionary, as this can
1577   // fail with an OutOfMemoryError (if it does, we will *not* put this
1578   // class in the dictionary and will not update the class hierarchy).
1579   // JVMTI FollowReferences needs to find the classes this way.
1580   if (k-&gt;class_loader() != NULL) {
1581     methodHandle m(THREAD, Universe::loader_addClass_method());
1582     JavaValue result(T_VOID);
1583     JavaCallArguments args(class_loader_h);
1584     args.push_oop(Handle(THREAD, k-&gt;java_mirror()));
1585     JavaCalls::call(&amp;result, m, &amp;args, CHECK);
1586   }
1587 
1588   // Add the new class. We need recompile lock during update of CHA.
1589   {
1590     unsigned int p_hash = placeholders()-&gt;compute_hash(name_h);
1591     int p_index = placeholders()-&gt;hash_to_index(p_hash);
1592 
<span class="line-modified">1593     MutexLocker mu_r(THREAD, Compile_lock);</span>
1594 
1595     // Add to class hierarchy, initialize vtables, and do possible
1596     // deoptimizations.
1597     add_to_hierarchy(k, CHECK); // No exception, but can block
1598 
1599     // Add to systemDictionary - so other classes can see it.
1600     // Grabs and releases SystemDictionary_lock
1601     update_dictionary(d_hash, p_index, p_hash,
1602                       k, class_loader_h, THREAD);
1603   }
1604   k-&gt;eager_initialize(THREAD);
1605 
1606   // notify jvmti
1607   if (JvmtiExport::should_post_class_load()) {
1608       assert(THREAD-&gt;is_Java_thread(), &quot;thread-&gt;is_Java_thread()&quot;);
1609       JvmtiExport::post_class_load((JavaThread *) THREAD, k);
1610 
1611   }
1612   post_class_define_event(k, loader_data);
1613 }
</pre>
<hr />
<pre>
1630 // Note: VM callers should ensure consistency of k/class_name,class_loader
1631 // Be careful when modifying this code: once you have run
1632 // placeholders()-&gt;find_and_add(PlaceholderTable::DEFINE_CLASS),
1633 // you need to find_and_remove it before returning.
1634 // So be careful to not exit with a CHECK_ macro betweeen these calls.
1635 InstanceKlass* SystemDictionary::find_or_define_instance_class(Symbol* class_name, Handle class_loader,
1636                                                                InstanceKlass* k, TRAPS) {
1637 
1638   Symbol*  name_h = k-&gt;name(); // passed in class_name may be null
1639   ClassLoaderData* loader_data = class_loader_data(class_loader);
1640   Dictionary* dictionary = loader_data-&gt;dictionary();
1641 
1642   unsigned int d_hash = dictionary-&gt;compute_hash(name_h);
1643 
1644   // Hold SD lock around find_class and placeholder creation for DEFINE_CLASS
1645   unsigned int p_hash = placeholders()-&gt;compute_hash(name_h);
1646   int p_index = placeholders()-&gt;hash_to_index(p_hash);
1647   PlaceholderEntry* probe;
1648 
1649   {
<span class="line-modified">1650     MutexLocker mu(THREAD, SystemDictionary_lock);</span>
1651     // First check if class already defined
1652     if (is_parallelDefine(class_loader)) {
1653       InstanceKlass* check = find_class(d_hash, name_h, dictionary);
1654       if (check != NULL) {
1655         return check;
1656       }
1657     }
1658 
1659     // Acquire define token for this class/classloader
1660     probe = placeholders()-&gt;find_and_add(p_index, p_hash, name_h, loader_data, PlaceholderTable::DEFINE_CLASS, NULL, THREAD);
1661     // Wait if another thread defining in parallel
1662     // All threads wait - even those that will throw duplicate class: otherwise
1663     // caller is surprised by LinkageError: duplicate, but findLoadedClass fails
1664     // if other thread has not finished updating dictionary
1665     while (probe-&gt;definer() != NULL) {
1666       SystemDictionary_lock-&gt;wait();
1667     }
1668     // Only special cases allow parallel defines and can use other thread&#39;s results
1669     // Other cases fall through, and may run into duplicate defines
1670     // caught by finding an entry in the SystemDictionary
1671     if (is_parallelDefine(class_loader) &amp;&amp; (probe-&gt;instance_klass() != NULL)) {
1672         placeholders()-&gt;find_and_remove(p_index, p_hash, name_h, loader_data, PlaceholderTable::DEFINE_CLASS, THREAD);
1673         SystemDictionary_lock-&gt;notify_all();
1674 #ifdef ASSERT
1675         InstanceKlass* check = find_class(d_hash, name_h, dictionary);
1676         assert(check != NULL, &quot;definer missed recording success&quot;);
1677 #endif
1678         return probe-&gt;instance_klass();
1679     } else {
1680       // This thread will define the class (even if earlier thread tried and had an error)
1681       probe-&gt;set_definer(THREAD);
1682     }
1683   }
1684 
1685   define_instance_class(k, THREAD);
1686 
1687   Handle linkage_exception = Handle(); // null handle
1688 
1689   // definer must notify any waiting threads
1690   {
<span class="line-modified">1691     MutexLocker mu(THREAD, SystemDictionary_lock);</span>
1692     PlaceholderEntry* probe = placeholders()-&gt;get_entry(p_index, p_hash, name_h, loader_data);
1693     assert(probe != NULL, &quot;DEFINE_CLASS placeholder lost?&quot;);
1694     if (probe != NULL) {
1695       if (HAS_PENDING_EXCEPTION) {
1696         linkage_exception = Handle(THREAD,PENDING_EXCEPTION);
1697         CLEAR_PENDING_EXCEPTION;
1698       } else {
1699         probe-&gt;set_instance_klass(k);
1700       }
1701       probe-&gt;set_definer(NULL);
1702       placeholders()-&gt;find_and_remove(p_index, p_hash, name_h, loader_data, PlaceholderTable::DEFINE_CLASS, THREAD);
1703       SystemDictionary_lock-&gt;notify_all();
1704     }
1705   }
1706 
1707   // Can&#39;t throw exception while holding lock due to rank ordering
1708   if (linkage_exception() != NULL) {
1709     THROW_OOP_(linkage_exception(), NULL); // throws exception and returns
1710   }
1711 
</pre>
<hr />
<pre>
1719   } else {
1720     return class_loader;
1721   }
1722 }
1723 
1724 // This method is added to check how often we have to wait to grab loader
1725 // lock. The results are being recorded in the performance counters defined in
1726 // ClassLoader::_sync_systemLoaderLockContentionRate and
1727 // ClassLoader::_sync_nonSystemLoaderLockConteionRate.
1728 void SystemDictionary::check_loader_lock_contention(Handle loader_lock, TRAPS) {
1729   if (!UsePerfData) {
1730     return;
1731   }
1732 
1733   assert(!loader_lock.is_null(), &quot;NULL lock object&quot;);
1734 
1735   if (ObjectSynchronizer::query_lock_ownership((JavaThread*)THREAD, loader_lock)
1736       == ObjectSynchronizer::owner_other) {
1737     // contention will likely happen, so increment the corresponding
1738     // contention counter.
<span class="line-modified">1739     if (loader_lock() == _system_loader_lock_obj) {</span>
1740       ClassLoader::sync_systemLoaderLockContentionRate()-&gt;inc();
1741     } else {
1742       ClassLoader::sync_nonSystemLoaderLockContentionRate()-&gt;inc();
1743     }
1744   }
1745 }
1746 
1747 // ----------------------------------------------------------------------------
1748 // Lookup
1749 
1750 InstanceKlass* SystemDictionary::find_class(unsigned int hash,
1751                                             Symbol* class_name,
1752                                             Dictionary* dictionary) {
1753   assert_locked_or_safepoint(SystemDictionary_lock);
1754   int index = dictionary-&gt;hash_to_index(hash);
1755   return dictionary-&gt;find_class(index, hash, class_name);
1756 }
1757 
1758 
1759 // Basic find on classes in the midst of being loaded
</pre>
<hr />
<pre>
1806   // Now flush all code that depended on old class hierarchy.
1807   // Note: must be done *after* linking k into the hierarchy (was bug 12/9/97)
1808   CodeCache::flush_dependents_on(k);
1809 }
1810 
1811 // ----------------------------------------------------------------------------
1812 // GC support
1813 
1814 // Assumes classes in the SystemDictionary are only unloaded at a safepoint
1815 // Note: anonymous classes are not in the SD.
1816 bool SystemDictionary::do_unloading(GCTimer* gc_timer) {
1817 
1818   bool unloading_occurred;
1819   bool is_concurrent = !SafepointSynchronize::is_at_safepoint();
1820   {
1821     GCTraceTime(Debug, gc, phases) t(&quot;ClassLoaderData&quot;, gc_timer);
1822     assert_locked_or_safepoint(ClassLoaderDataGraph_lock);  // caller locks.
1823     // First, mark for unload all ClassLoaderData referencing a dead class loader.
1824     unloading_occurred = ClassLoaderDataGraph::do_unloading();
1825     if (unloading_occurred) {
<span class="line-modified">1826       MutexLocker ml2(is_concurrent ? Module_lock : NULL);</span>
1827       JFR_ONLY(Jfr::on_unloading_classes();)
1828 
<span class="line-modified">1829       MutexLocker ml1(is_concurrent ? SystemDictionary_lock : NULL);</span>
1830       ClassLoaderDataGraph::clean_module_and_package_info();
1831       constraints()-&gt;purge_loader_constraints();
1832       resolution_errors()-&gt;purge_resolution_errors();
1833     }
1834   }
1835 
1836   GCTraceTime(Debug, gc, phases) t(&quot;Trigger cleanups&quot;, gc_timer);


1837 
1838   if (unloading_occurred) {
1839     SymbolTable::trigger_cleanup();
1840 
1841     // Oops referenced by the protection domain cache table may get unreachable independently
1842     // of the class loader (eg. cached protection domain oops). So we need to
1843     // explicitly unlink them here.
1844     // All protection domain oops are linked to the caller class, so if nothing
1845     // unloads, this is not needed.
1846     _pd_cache_table-&gt;trigger_cleanup();
1847   }
1848 
1849   return unloading_occurred;
1850 }
1851 
<span class="line-modified">1852 void SystemDictionary::oops_do(OopClosure* f, bool include_handles) {</span>
1853   f-&gt;do_oop(&amp;_java_system_loader);
1854   f-&gt;do_oop(&amp;_java_platform_loader);
1855   f-&gt;do_oop(&amp;_system_loader_lock_obj);
1856   CDS_ONLY(SystemDictionaryShared::oops_do(f);)
1857 
1858   // Visit extra methods
1859   invoke_method_table()-&gt;oops_do(f);
<span class="line-added">1860 </span>
<span class="line-added">1861   if (include_handles) {</span>
<span class="line-added">1862     OopStorageSet::vm_global()-&gt;oops_do(f);</span>
<span class="line-added">1863   }</span>
1864 }
1865 
1866 // CDS: scan and relocate all classes referenced by _well_known_klasses[].
1867 void SystemDictionary::well_known_klasses_do(MetaspaceClosure* it) {
1868   for (int id = FIRST_WKID; id &lt; WKID_LIMIT; id++) {
1869     it-&gt;push(well_known_klass_addr((WKID)id));
1870   }
1871 }
1872 
1873 void SystemDictionary::methods_do(void f(Method*)) {
1874   // Walk methods in loaded classes
1875   MutexLocker ml(ClassLoaderDataGraph_lock);
1876   ClassLoaderDataGraph::methods_do(f);
1877   // Walk method handle intrinsics
1878   invoke_method_table()-&gt;methods_do(f);
1879 }
1880 
1881 // ----------------------------------------------------------------------------
1882 // Initialization
1883 
1884 void SystemDictionary::initialize(TRAPS) {
1885   // Allocate arrays
1886   _placeholders        = new PlaceholderTable(_placeholder_table_size);

1887   _loader_constraints  = new LoaderConstraintTable(_loader_constraint_size);
1888   _resolution_errors   = new ResolutionErrorTable(_resolution_error_size);
1889   _invoke_method_table = new SymbolPropertyTable(_invoke_method_size);
1890   _pd_cache_table = new ProtectionDomainCacheTable(defaultProtectionDomainCacheSize);
1891 
1892   // Allocate private object used as system class loader lock
1893   _system_loader_lock_obj = oopFactory::new_intArray(0, CHECK);
1894   // Initialize basic classes
1895   resolve_well_known_classes(CHECK);
1896 }
1897 
1898 // Compact table of directions on the initialization of klasses:
1899 static const short wk_init_info[] = {
1900   #define WK_KLASS_INIT_INFO(name, symbol) \
1901     ((short)vmSymbols::VM_SYMBOL_ENUM_NAME(symbol)),
1902 
1903   WK_KLASSES_DO(WK_KLASS_INIT_INFO)
1904   #undef WK_KLASS_INIT_INFO
1905   0
1906 };
1907 
1908 #ifdef ASSERT
1909 bool SystemDictionary::is_well_known_klass(Symbol* class_name) {
1910   int sid;
1911   for (int i = 0; (sid = wk_init_info[i]) != 0; i++) {
1912     Symbol* symbol = vmSymbols::symbol_at((vmSymbols::SID)sid);
1913     if (class_name == symbol) {
1914       return true;
1915     }
1916   }
1917   return false;
1918 }
1919 #endif
1920 
1921 bool SystemDictionary::resolve_wk_klass(WKID id, TRAPS) {
1922   assert(id &gt;= (int)FIRST_WKID &amp;&amp; id &lt; (int)WKID_LIMIT, &quot;oob&quot;);
1923   int sid = wk_init_info[id - FIRST_WKID];
1924   Symbol* symbol = vmSymbols::symbol_at((vmSymbols::SID)sid);
1925   InstanceKlass** klassp = &amp;_well_known_klasses[id];
1926 







1927   if ((*klassp) == NULL) {
1928     Klass* k = resolve_or_fail(symbol, true, CHECK_0);
1929     (*klassp) = InstanceKlass::cast(k);
1930   }
1931   return ((*klassp) != NULL);
1932 }
1933 
1934 void SystemDictionary::resolve_wk_klasses_until(WKID limit_id, WKID &amp;start_id, TRAPS) {
1935   assert((int)start_id &lt;= (int)limit_id, &quot;IDs are out of order!&quot;);
1936   for (int id = (int)start_id; id &lt; (int)limit_id; id++) {
1937     assert(id &gt;= (int)FIRST_WKID &amp;&amp; id &lt; (int)WKID_LIMIT, &quot;oob&quot;);
1938     resolve_wk_klass((WKID)id, CHECK);
1939   }
1940 
1941   // move the starting value forward to the limit:
1942   start_id = limit_id;
1943 }
1944 
1945 void SystemDictionary::resolve_well_known_classes(TRAPS) {
1946   assert(WK_KLASS(Object_klass) == NULL, &quot;well-known classes should only be initialized once&quot;);
</pre>
<hr />
<pre>
1964     // resolved_references array object).
1965     //
1966     // HeapShared::fixup_mapped_heap_regions() fills the empty
1967     // spaces in the archived heap regions and may use
1968     // SystemDictionary::Object_klass(), so we can do this only after
1969     // Object_klass is resolved. See the above resolve_wk_klasses_through()
1970     // call. No mirror objects are accessed/restored in the above call.
1971     // Mirrors are restored after java.lang.Class is loaded.
1972     HeapShared::fixup_mapped_heap_regions();
1973 
1974     // Initialize the constant pool for the Object_class
1975     assert(Object_klass()-&gt;is_shared(), &quot;must be&quot;);
1976     Object_klass()-&gt;constants()-&gt;restore_unshareable_info(CHECK);
1977     resolve_wk_klasses_through(WK_KLASS_ENUM_NAME(Class_klass), scan, CHECK);
1978   } else
1979 #endif
1980   {
1981     resolve_wk_klasses_through(WK_KLASS_ENUM_NAME(Class_klass), scan, CHECK);
1982   }
1983 
<span class="line-added">1984   assert(WK_KLASS(Object_klass) != NULL, &quot;well-known classes should now be initialized&quot;);</span>
<span class="line-added">1985 </span>
<span class="line-added">1986   java_lang_Object::register_natives(CHECK);</span>
<span class="line-added">1987 </span>
1988   // Calculate offsets for String and Class classes since they are loaded and
1989   // can be used after this point.
1990   java_lang_String::compute_offsets();
1991   java_lang_Class::compute_offsets();
1992 
1993   // Fixup mirrors for classes loaded before java.lang.Class.
1994   // These calls iterate over the objects currently in the perm gen
1995   // so calling them at this point is matters (not before when there
1996   // are fewer objects and not later after there are more objects
1997   // in the perm gen.
1998   Universe::initialize_basic_type_mirrors(CHECK);
1999   Universe::fixup_mirrors(CHECK);
2000 
2001   // do a bunch more:
2002   resolve_wk_klasses_through(WK_KLASS_ENUM_NAME(Reference_klass), scan, CHECK);
2003 
2004   // Preload ref klasses and set reference types
<span class="line-modified">2005   WK_KLASS(Reference_klass)-&gt;set_reference_type(REF_OTHER);</span>
2006   InstanceRefKlass::update_nonstatic_oop_maps(WK_KLASS(Reference_klass));
2007 
2008   resolve_wk_klasses_through(WK_KLASS_ENUM_NAME(PhantomReference_klass), scan, CHECK);
<span class="line-modified">2009   WK_KLASS(SoftReference_klass)-&gt;set_reference_type(REF_SOFT);</span>
<span class="line-modified">2010   WK_KLASS(WeakReference_klass)-&gt;set_reference_type(REF_WEAK);</span>
<span class="line-modified">2011   WK_KLASS(FinalReference_klass)-&gt;set_reference_type(REF_FINAL);</span>
<span class="line-modified">2012   WK_KLASS(PhantomReference_klass)-&gt;set_reference_type(REF_PHANTOM);</span>
2013 
2014   // JSR 292 classes
2015   WKID jsr292_group_start = WK_KLASS_ENUM_NAME(MethodHandle_klass);
2016   WKID jsr292_group_end   = WK_KLASS_ENUM_NAME(VolatileCallSite_klass);
2017   resolve_wk_klasses_until(jsr292_group_start, scan, CHECK);
2018   resolve_wk_klasses_through(jsr292_group_end, scan, CHECK);
<span class="line-modified">2019   WKID last = WKID_LIMIT;</span>
2020   resolve_wk_klasses_until(last, scan, CHECK);
2021 
2022   _box_klasses[T_BOOLEAN] = WK_KLASS(Boolean_klass);
2023   _box_klasses[T_CHAR]    = WK_KLASS(Character_klass);
2024   _box_klasses[T_FLOAT]   = WK_KLASS(Float_klass);
2025   _box_klasses[T_DOUBLE]  = WK_KLASS(Double_klass);
2026   _box_klasses[T_BYTE]    = WK_KLASS(Byte_klass);
2027   _box_klasses[T_SHORT]   = WK_KLASS(Short_klass);
2028   _box_klasses[T_INT]     = WK_KLASS(Integer_klass);
2029   _box_klasses[T_LONG]    = WK_KLASS(Long_klass);
2030   //_box_klasses[T_OBJECT]  = WK_KLASS(object_klass);
2031   //_box_klasses[T_ARRAY]   = WK_KLASS(object_klass);
2032 





2033 #ifdef ASSERT
2034   if (UseSharedSpaces) {
2035     assert(JvmtiExport::is_early_phase(),
2036            &quot;All well known classes must be resolved in JVMTI early phase&quot;);
2037     for (int i = FIRST_WKID; i &lt; last; i++) {
2038       InstanceKlass* k = _well_known_klasses[i];
2039       assert(k-&gt;is_shared(), &quot;must not be replaced by JVMTI class file load hook&quot;);
2040     }
2041   }
2042 #endif
2043 }
2044 
2045 // Tells if a given klass is a box (wrapper class, such as java.lang.Integer).
2046 // If so, returns the basic type it holds.  If not, returns T_OBJECT.
2047 BasicType SystemDictionary::box_klass_type(Klass* k) {
2048   assert(k != NULL, &quot;&quot;);
2049   for (int i = T_BOOLEAN; i &lt; T_VOID+1; i++) {
2050     if (_box_klasses[i] == k)
2051       return (BasicType)i;
2052   }
</pre>
<hr />
<pre>
2057 // found in the OOPSLA&#39;98 paper &quot;Dynamic Class Loading in the Java
2058 // Virtual Machine&quot; by Sheng Liang and Gilad Bracha.  The basic idea is
2059 // that the dictionary needs to maintain a set of contraints that
2060 // must be satisfied by all classes in the dictionary.
2061 // if defining is true, then LinkageError if already in dictionary
2062 // if initiating loader, then ok if InstanceKlass matches existing entry
2063 
2064 void SystemDictionary::check_constraints(unsigned int d_hash,
2065                                          InstanceKlass* k,
2066                                          Handle class_loader,
2067                                          bool defining,
2068                                          TRAPS) {
2069   ResourceMark rm(THREAD);
2070   stringStream ss;
2071   bool throwException = false;
2072 
2073   {
2074     Symbol *name = k-&gt;name();
2075     ClassLoaderData *loader_data = class_loader_data(class_loader);
2076 
<span class="line-modified">2077     MutexLocker mu(THREAD, SystemDictionary_lock);</span>
2078 
2079     InstanceKlass* check = find_class(d_hash, name, loader_data-&gt;dictionary());
2080     if (check != NULL) {
2081       // If different InstanceKlass - duplicate class definition,
2082       // else - ok, class loaded by a different thread in parallel.
2083       // We should only have found it if it was done loading and ok to use.
2084       // The dictionary only holds instance classes, placeholders
2085       // also hold array classes.
2086 
2087       assert(check-&gt;is_instance_klass(), &quot;noninstance in systemdictionary&quot;);
2088       if ((defining == true) || (k != check)) {
2089         throwException = true;
2090         ss.print(&quot;loader %s&quot;, loader_data-&gt;loader_name_and_id());
2091         ss.print(&quot; attempted duplicate %s definition for %s. (%s)&quot;,
2092                  k-&gt;external_kind(), k-&gt;external_name(), k-&gt;class_in_module_of_loader(false, true));
2093       } else {
2094         return;
2095       }
2096     }
2097 
</pre>
<hr />
<pre>
2122   // Throw error now if needed (cannot throw while holding
2123   // SystemDictionary_lock because of rank ordering)
2124   if (throwException == true) {
2125     THROW_MSG(vmSymbols::java_lang_LinkageError(), ss.as_string());
2126   }
2127 }
2128 
2129 // Update class loader data dictionary - done after check_constraint and add_to_hierachy
2130 // have been called.
2131 void SystemDictionary::update_dictionary(unsigned int d_hash,
2132                                          int p_index, unsigned int p_hash,
2133                                          InstanceKlass* k,
2134                                          Handle class_loader,
2135                                          TRAPS) {
2136   // Compile_lock prevents systemDictionary updates during compilations
2137   assert_locked_or_safepoint(Compile_lock);
2138   Symbol*  name  = k-&gt;name();
2139   ClassLoaderData *loader_data = class_loader_data(class_loader);
2140 
2141   {
<span class="line-modified">2142     MutexLocker mu1(THREAD, SystemDictionary_lock);</span>




















2143 
2144     // Make a new dictionary entry.
2145     Dictionary* dictionary = loader_data-&gt;dictionary();
2146     InstanceKlass* sd_check = find_class(d_hash, name, dictionary);
2147     if (sd_check == NULL) {
2148       dictionary-&gt;add_klass(d_hash, name, k);


2149     }
2150   #ifdef ASSERT
2151     sd_check = find_class(d_hash, name, dictionary);
2152     assert (sd_check != NULL, &quot;should have entry in dictionary&quot;);
2153     // Note: there may be a placeholder entry: for circularity testing
2154     // or for parallel defines
2155   #endif
2156     SystemDictionary_lock-&gt;notify_all();
2157   }
2158 }
2159 
2160 
2161 // Try to find a class name using the loader constraints.  The
2162 // loader constraints might know about a class that isn&#39;t fully loaded
2163 // yet and these will be ignored.
2164 Klass* SystemDictionary::find_constrained_instance_or_array_klass(
2165                     Symbol* class_name, Handle class_loader, TRAPS) {
2166 
2167   // First see if it has been loaded directly.
2168   // Force the protection domain to be null.  (This removes protection checks.)
2169   Handle no_protection_domain;
2170   Klass* klass = find_instance_or_array_klass(class_name, class_loader,
2171                                               no_protection_domain, CHECK_NULL);
2172   if (klass != NULL)
2173     return klass;
2174 
2175   // Now look to see if it has been loaded elsewhere, and is subject to
2176   // a loader constraint that would require this loader to return the
2177   // klass that is already loaded.
<span class="line-modified">2178   if (Signature::is_array(class_name)) {</span>
2179     // For array classes, their Klass*s are not kept in the
2180     // constraint table. The element Klass*s are.
<span class="line-modified">2181     SignatureStream ss(class_name, false);</span>
<span class="line-modified">2182     int ndims = ss.skip_array_prefix();  // skip all &#39;[&#39;s</span>
<span class="line-added">2183     BasicType t = ss.type();</span>
2184     if (t != T_OBJECT) {
2185       klass = Universe::typeArrayKlassObj(t);
2186     } else {
<span class="line-modified">2187       MutexLocker mu(THREAD, SystemDictionary_lock);</span>
<span class="line-modified">2188       klass = constraints()-&gt;find_constrained_klass(ss.as_symbol(), class_loader);</span>
2189     }
2190     // If element class already loaded, allocate array klass
2191     if (klass != NULL) {
<span class="line-modified">2192       klass = klass-&gt;array_klass_or_null(ndims);</span>
2193     }
2194   } else {
<span class="line-modified">2195     MutexLocker mu(THREAD, SystemDictionary_lock);</span>
2196     // Non-array classes are easy: simply check the constraint table.
2197     klass = constraints()-&gt;find_constrained_klass(class_name, class_loader);
2198   }
2199 
2200   return klass;
2201 }
2202 
2203 
2204 bool SystemDictionary::add_loader_constraint(Symbol* class_name,
2205                                              Handle class_loader1,
2206                                              Handle class_loader2,
2207                                              Thread* THREAD) {
2208   ClassLoaderData* loader_data1 = class_loader_data(class_loader1);
2209   ClassLoaderData* loader_data2 = class_loader_data(class_loader2);
2210 
2211   Symbol* constraint_name = NULL;
<span class="line-modified">2212 </span>
<span class="line-modified">2213   if (!Signature::is_array(class_name)) {</span>


2214     constraint_name = class_name;
2215   } else {
2216     // For array classes, their Klass*s are not kept in the
2217     // constraint table. The element classes are.
<span class="line-modified">2218     SignatureStream ss(class_name, false);</span>
<span class="line-modified">2219     ss.skip_array_prefix();  // skip all &#39;[&#39;s</span>
<span class="line-modified">2220     if (!ss.has_envelope()) {</span>
<span class="line-modified">2221       return true;     // primitive types always pass</span>


2222     }
<span class="line-added">2223     constraint_name = ss.as_symbol();</span>
<span class="line-added">2224     // Increment refcount to keep constraint_name alive after</span>
<span class="line-added">2225     // SignatureStream is destructed. It will be decremented below</span>
<span class="line-added">2226     // before returning.</span>
<span class="line-added">2227     constraint_name-&gt;increment_refcount();</span>
2228   }
2229 
2230   Dictionary* dictionary1 = loader_data1-&gt;dictionary();
2231   unsigned int d_hash1 = dictionary1-&gt;compute_hash(constraint_name);
2232 
2233   Dictionary* dictionary2 = loader_data2-&gt;dictionary();
2234   unsigned int d_hash2 = dictionary2-&gt;compute_hash(constraint_name);
2235 
2236   {
<span class="line-modified">2237     MutexLocker mu_s(THREAD, SystemDictionary_lock);</span>
2238     InstanceKlass* klass1 = find_class(d_hash1, constraint_name, dictionary1);
2239     InstanceKlass* klass2 = find_class(d_hash2, constraint_name, dictionary2);
<span class="line-modified">2240     bool result = constraints()-&gt;add_entry(constraint_name, klass1, class_loader1,</span>
<span class="line-modified">2241                                            klass2, class_loader2);</span>
<span class="line-added">2242     if (Signature::is_array(class_name)) {</span>
<span class="line-added">2243       constraint_name-&gt;decrement_refcount();</span>
<span class="line-added">2244     }</span>
<span class="line-added">2245     return result;</span>
2246   }
2247 }
2248 
2249 // Add entry to resolution error table to record the error when the first
2250 // attempt to resolve a reference to a class has failed.
2251 void SystemDictionary::add_resolution_error(const constantPoolHandle&amp; pool, int which,
2252                                             Symbol* error, Symbol* message) {
2253   unsigned int hash = resolution_errors()-&gt;compute_hash(pool, which);
2254   int index = resolution_errors()-&gt;hash_to_index(hash);
2255   {
<span class="line-modified">2256     MutexLocker ml(Thread::current(), SystemDictionary_lock);</span>
2257     resolution_errors()-&gt;add_entry(index, hash, pool, which, error, message);
2258   }
2259 }
2260 
2261 // Delete a resolution error for RedefineClasses for a constant pool is going away
2262 void SystemDictionary::delete_resolution_error(ConstantPool* pool) {
2263   resolution_errors()-&gt;delete_entry(pool);
2264 }
2265 
2266 // Lookup resolution error table. Returns error if found, otherwise NULL.
2267 Symbol* SystemDictionary::find_resolution_error(const constantPoolHandle&amp; pool, int which,
2268                                                 Symbol** message) {
2269   unsigned int hash = resolution_errors()-&gt;compute_hash(pool, which);
2270   int index = resolution_errors()-&gt;hash_to_index(hash);
2271   {
<span class="line-modified">2272     MutexLocker ml(Thread::current(), SystemDictionary_lock);</span>
2273     ResolutionErrorEntry* entry = resolution_errors()-&gt;find_entry(index, hash, pool, which);
2274     if (entry != NULL) {
2275       *message = entry-&gt;message();
2276       return entry-&gt;error();
2277     } else {
2278       return NULL;
2279     }
2280   }
2281 }
2282 
2283 
2284 // Signature constraints ensure that callers and callees agree about
2285 // the meaning of type names in their signatures.  This routine is the
2286 // intake for constraints.  It collects them from several places:
2287 //
2288 //  * LinkResolver::resolve_method (if check_access is true) requires
2289 //    that the resolving class (the caller) and the defining class of
2290 //    the resolved method (the callee) agree on each type in the
2291 //    method&#39;s signature.
2292 //
</pre>
<hr />
<pre>
2318 // constraints are placed as if the supertype were the caller to the
2319 // overriding method.  (This works well, since callers to the
2320 // supertype have already established agreement between themselves and
2321 // the supertype.)  As a result of all this, a class can disagree with
2322 // its supertype about the meaning of a type name, as long as that
2323 // class neither calls a relevant method of the supertype, nor is
2324 // called (perhaps via an override) from the supertype.
2325 //
2326 //
2327 // SystemDictionary::check_signature_loaders(sig, l1, l2)
2328 //
2329 // Make sure all class components (including arrays) in the given
2330 // signature will be resolved to the same class in both loaders.
2331 // Returns the name of the type that failed a loader constraint check, or
2332 // NULL if no constraint failed.  No exception except OOME is thrown.
2333 // Arrays are not added to the loader constraint table, their elements are.
2334 Symbol* SystemDictionary::check_signature_loaders(Symbol* signature,
2335                                                Handle loader1, Handle loader2,
2336                                                bool is_method, TRAPS)  {
2337   // Nothing to do if loaders are the same.
<span class="line-modified">2338   if (loader1() == loader2()) {</span>
2339     return NULL;
2340   }
2341 
<span class="line-modified">2342   for (SignatureStream ss(signature, is_method); !ss.is_done(); ss.next()) {</span>
<span class="line-modified">2343     if (ss.is_reference()) {</span>
<span class="line-modified">2344       Symbol* sig = ss.as_symbol();</span>
<span class="line-modified">2345       // Note: In the future, if template-like types can take</span>
<span class="line-added">2346       // arguments, we will want to recognize them and dig out class</span>
<span class="line-added">2347       // names hiding inside the argument lists.</span>
2348       if (!add_loader_constraint(sig, loader1, loader2, THREAD)) {
2349         return sig;
2350       }
2351     }

2352   }
2353   return NULL;
2354 }
2355 
2356 
<span class="line-modified">2357 Method* SystemDictionary::find_method_handle_intrinsic(vmIntrinsics::ID iid,</span>
<span class="line-modified">2358                                                        Symbol* signature,</span>
<span class="line-modified">2359                                                        TRAPS) {</span>
2360   methodHandle empty;
2361   assert(MethodHandles::is_signature_polymorphic(iid) &amp;&amp;
2362          MethodHandles::is_signature_polymorphic_intrinsic(iid) &amp;&amp;
2363          iid != vmIntrinsics::_invokeGeneric,
2364          &quot;must be a known MH intrinsic iid=%d: %s&quot;, iid, vmIntrinsics::name_at(iid));
2365 
2366   unsigned int hash  = invoke_method_table()-&gt;compute_hash(signature, iid);
2367   int          index = invoke_method_table()-&gt;hash_to_index(hash);
2368   SymbolPropertyEntry* spe = invoke_method_table()-&gt;find_entry(index, hash, signature, iid);
2369   methodHandle m;
2370   if (spe == NULL || spe-&gt;method() == NULL) {
2371     spe = NULL;
2372     // Must create lots of stuff here, but outside of the SystemDictionary lock.
<span class="line-modified">2373     m = Method::make_method_handle_intrinsic(iid, signature, CHECK_NULL);</span>
2374     if (!Arguments::is_interpreter_only()) {
2375       // Generate a compiled form of the MH intrinsic.
2376       AdapterHandlerLibrary::create_native_wrapper(m);
2377       // Check if have the compiled code.
2378       if (!m-&gt;has_compiled_code()) {
<span class="line-modified">2379         THROW_MSG_NULL(vmSymbols::java_lang_VirtualMachineError(),</span>
<span class="line-modified">2380                        &quot;Out of space in CodeCache for method handle intrinsic&quot;);</span>
2381       }
2382     }
2383     // Now grab the lock.  We might have to throw away the new method,
2384     // if a racing thread has managed to install one at the same time.
2385     {
<span class="line-modified">2386       MutexLocker ml(THREAD, SystemDictionary_lock);</span>
2387       spe = invoke_method_table()-&gt;find_entry(index, hash, signature, iid);
2388       if (spe == NULL)
2389         spe = invoke_method_table()-&gt;add_entry(index, hash, signature, iid);
2390       if (spe-&gt;method() == NULL)
2391         spe-&gt;set_method(m());
2392     }
2393   }
2394 
2395   assert(spe != NULL &amp;&amp; spe-&gt;method() != NULL, &quot;&quot;);
2396   assert(Arguments::is_interpreter_only() || (spe-&gt;method()-&gt;has_compiled_code() &amp;&amp;
2397          spe-&gt;method()-&gt;code()-&gt;entry_point() == spe-&gt;method()-&gt;from_compiled_entry()),
2398          &quot;MH intrinsic invariant&quot;);
2399   return spe-&gt;method();
2400 }
2401 
2402 // Helper for unpacking the return value from linkMethod and linkCallSite.
<span class="line-modified">2403 static Method* unpack_method_and_appendix(Handle mname,</span>
<span class="line-modified">2404                                           Klass* accessing_klass,</span>
<span class="line-modified">2405                                           objArrayHandle appendix_box,</span>
<span class="line-modified">2406                                           Handle* appendix_result,</span>
<span class="line-modified">2407                                           TRAPS) {</span>

2408   if (mname.not_null()) {
2409     Method* m = java_lang_invoke_MemberName::vmtarget(mname());
2410     if (m != NULL) {
2411       oop appendix = appendix_box-&gt;obj_at(0);
2412       if (TraceMethodHandles) {
2413     #ifndef PRODUCT
2414         ttyLocker ttyl;
2415         tty-&gt;print(&quot;Linked method=&quot; INTPTR_FORMAT &quot;: &quot;, p2i(m));
2416         m-&gt;print();
2417         if (appendix != NULL) { tty-&gt;print(&quot;appendix = &quot;); appendix-&gt;print(); }
2418         tty-&gt;cr();
2419     #endif //PRODUCT
2420       }
2421       (*appendix_result) = Handle(THREAD, appendix);
2422       // the target is stored in the cpCache and if a reference to this
2423       // MemberName is dropped we need a way to make sure the
2424       // class_loader containing this method is kept alive.
<span class="line-added">2425       methodHandle mh(THREAD, m); // record_dependency can safepoint.</span>
2426       ClassLoaderData* this_key = accessing_klass-&gt;class_loader_data();
2427       this_key-&gt;record_dependency(m-&gt;method_holder());
<span class="line-modified">2428       return mh();</span>
2429     }
2430   }
<span class="line-modified">2431   THROW_MSG_NULL(vmSymbols::java_lang_LinkageError(), &quot;bad value from MethodHandleNatives&quot;);</span>

2432 }
2433 
<span class="line-modified">2434 Method* SystemDictionary::find_method_handle_invoker(Klass* klass,</span>
<span class="line-modified">2435                                                      Symbol* name,</span>
<span class="line-modified">2436                                                      Symbol* signature,</span>
2437                                                           Klass* accessing_klass,
2438                                                           Handle *appendix_result,
2439                                                           TRAPS) {

2440   assert(THREAD-&gt;can_call_java() ,&quot;&quot;);
2441   Handle method_type =
<span class="line-modified">2442     SystemDictionary::find_method_handle_type(signature, accessing_klass, CHECK_NULL);</span>
2443 
2444   int ref_kind = JVM_REF_invokeVirtual;
<span class="line-modified">2445   oop name_oop = StringTable::intern(name, CHECK_NULL);</span>
2446   Handle name_str (THREAD, name_oop);
<span class="line-modified">2447   objArrayHandle appendix_box = oopFactory::new_objArray_handle(SystemDictionary::Object_klass(), 1, CHECK_NULL);</span>
2448   assert(appendix_box-&gt;obj_at(0) == NULL, &quot;&quot;);
2449 
2450   // This should not happen.  JDK code should take care of that.
2451   if (accessing_klass == NULL || method_type.is_null()) {
<span class="line-modified">2452     THROW_MSG_NULL(vmSymbols::java_lang_InternalError(), &quot;bad invokehandle&quot;);</span>
2453   }
2454 
2455   // call java.lang.invoke.MethodHandleNatives::linkMethod(... String, MethodType) -&gt; MemberName
2456   JavaCallArguments args;
2457   args.push_oop(Handle(THREAD, accessing_klass-&gt;java_mirror()));
2458   args.push_int(ref_kind);
2459   args.push_oop(Handle(THREAD, klass-&gt;java_mirror()));
2460   args.push_oop(name_str);
2461   args.push_oop(method_type);
2462   args.push_oop(appendix_box);
2463   JavaValue result(T_OBJECT);
2464   JavaCalls::call_static(&amp;result,
2465                          SystemDictionary::MethodHandleNatives_klass(),
2466                          vmSymbols::linkMethod_name(),
2467                          vmSymbols::linkMethod_signature(),
<span class="line-modified">2468                          &amp;args, CHECK_NULL);</span>
2469   Handle mname(THREAD, (oop) result.get_jobject());
2470   return unpack_method_and_appendix(mname, accessing_klass, appendix_box, appendix_result, THREAD);
2471 }
2472 
2473 // Decide if we can globally cache a lookup of this class, to be returned to any client that asks.
2474 // We must ensure that all class loaders everywhere will reach this class, for any client.
2475 // This is a safe bet for public classes in java.lang, such as Object and String.
2476 // We also include public classes in java.lang.invoke, because they appear frequently in system-level method types.
2477 // Out of an abundance of caution, we do not include any other classes, not even for packages like java.util.
2478 static bool is_always_visible_class(oop mirror) {
2479   Klass* klass = java_lang_Class::as_Klass(mirror);
2480   if (klass-&gt;is_objArray_klass()) {
2481     klass = ObjArrayKlass::cast(klass)-&gt;bottom_klass(); // check element type
2482   }
2483   if (klass-&gt;is_typeArray_klass()) {
2484     return true; // primitive array
2485   }
2486   assert(klass-&gt;is_instance_klass(), &quot;%s&quot;, klass-&gt;external_name());
2487   return klass-&gt;is_public() &amp;&amp;
2488          (InstanceKlass::cast(klass)-&gt;is_same_class_package(SystemDictionary::Object_klass()) ||       // java.lang
2489           InstanceKlass::cast(klass)-&gt;is_same_class_package(SystemDictionary::MethodHandle_klass()));  // java.lang.invoke
2490 }
2491 








2492 // Find or construct the Java mirror (java.lang.Class instance) for a
2493 // for the given field type signature, as interpreted relative to the
2494 // given class loader.  Handles primitives, void, references, arrays,
2495 // and all other reflectable types, except method types.
2496 // N.B.  Code in reflection should use this entry point.
2497 Handle SystemDictionary::find_java_mirror_for_type(Symbol* signature,
2498                                                    Klass* accessing_klass,
2499                                                    Handle class_loader,
2500                                                    Handle protection_domain,
2501                                                    SignatureStream::FailureMode failure_mode,
2502                                                    TRAPS) {
2503   Handle empty;
2504 
2505   assert(accessing_klass == NULL || (class_loader.is_null() &amp;&amp; protection_domain.is_null()),
2506          &quot;one or the other, or perhaps neither&quot;);
2507 
<span class="line-modified">2508   SignatureStream ss(signature, false);</span>
2509 
2510   // What we have here must be a valid field descriptor,
2511   // and all valid field descriptors are supported.
2512   // Produce the same java.lang.Class that reflection reports.
<span class="line-modified">2513   if (ss.is_primitive() || (ss.type() == T_VOID)) {</span>
2514 
2515     // It&#39;s a primitive.  (Void has a primitive mirror too.)
<span class="line-modified">2516     return Handle(THREAD, java_lang_Class::primitive_mirror(ss.type()));</span>


2517 
<span class="line-modified">2518   } else if (ss.is_reference()) {</span>
2519 
2520     // It&#39;s a reference type.
2521     if (accessing_klass != NULL) {
2522       class_loader      = Handle(THREAD, accessing_klass-&gt;class_loader());
2523       protection_domain = Handle(THREAD, accessing_klass-&gt;protection_domain());
2524     }
2525     Klass* constant_type_klass;
2526     if (failure_mode == SignatureStream::ReturnNull) {
<span class="line-modified">2527       constant_type_klass = resolve_or_null(signature, class_loader, protection_domain,</span>
2528                                             CHECK_(empty));
2529     } else {
2530       bool throw_error = (failure_mode == SignatureStream::NCDFError);
<span class="line-modified">2531       constant_type_klass = resolve_or_fail(signature, class_loader, protection_domain,</span>
2532                                             throw_error, CHECK_(empty));
2533     }
2534     if (constant_type_klass == NULL) {
2535       return Handle();  // report failure this way
2536     }
2537     Handle mirror(THREAD, constant_type_klass-&gt;java_mirror());
2538 
2539     // Check accessibility, emulating ConstantPool::verify_constant_pool_resolve.
2540     if (accessing_klass != NULL) {
2541       Klass* sel_klass = constant_type_klass;
2542       bool fold_type_to_class = true;
2543       LinkResolver::check_klass_accessability(accessing_klass, sel_klass,
2544                                               fold_type_to_class, CHECK_(empty));
2545     }
2546 
2547     return mirror;
2548 
2549   }
2550 
2551   // Fall through to an error.
</pre>
<hr />
<pre>
2574     return Handle();  // do not attempt from within compiler, unless it was cached
2575   }
2576 
2577   Handle class_loader, protection_domain;
2578   if (accessing_klass != NULL) {
2579     class_loader      = Handle(THREAD, accessing_klass-&gt;class_loader());
2580     protection_domain = Handle(THREAD, accessing_klass-&gt;protection_domain());
2581   }
2582   bool can_be_cached = true;
2583   int npts = ArgumentCount(signature).size();
2584   objArrayHandle pts = oopFactory::new_objArray_handle(SystemDictionary::Class_klass(), npts, CHECK_(empty));
2585   int arg = 0;
2586   Handle rt; // the return type from the signature
2587   ResourceMark rm(THREAD);
2588   for (SignatureStream ss(signature); !ss.is_done(); ss.next()) {
2589     oop mirror = NULL;
2590     if (can_be_cached) {
2591       // Use neutral class loader to lookup candidate classes to be placed in the cache.
2592       mirror = ss.as_java_mirror(Handle(), Handle(),
2593                                  SignatureStream::ReturnNull, CHECK_(empty));
<span class="line-modified">2594       if (mirror == NULL || (ss.is_reference() &amp;&amp; !is_always_visible_class(mirror))) {</span>
2595         // Fall back to accessing_klass context.
2596         can_be_cached = false;
2597       }
2598     }
2599     if (!can_be_cached) {
2600       // Resolve, throwing a real error if it doesn&#39;t work.
2601       mirror = ss.as_java_mirror(class_loader, protection_domain,
2602                                  SignatureStream::NCDFError, CHECK_(empty));
2603     }
<span class="line-modified">2604     assert(mirror != NULL, &quot;%s&quot;, ss.as_symbol()-&gt;as_C_string());</span>
2605     if (ss.at_return_type())
2606       rt = Handle(THREAD, mirror);
2607     else
2608       pts-&gt;obj_at_put(arg++, mirror);
2609 
2610     // Check accessibility.
2611     if (!java_lang_Class::is_primitive(mirror) &amp;&amp; accessing_klass != NULL) {
2612       Klass* sel_klass = java_lang_Class::as_Klass(mirror);
2613       mirror = NULL;  // safety
2614       // Emulate ConstantPool::verify_constant_pool_resolve.
2615       bool fold_type_to_class = true;
2616       LinkResolver::check_klass_accessability(accessing_klass, sel_klass,
2617                                               fold_type_to_class, CHECK_(empty));
2618     }
2619   }
2620   assert(arg == npts, &quot;&quot;);
2621 
2622   // call java.lang.invoke.MethodHandleNatives::findMethodHandleType(Class rt, Class[] pts) -&gt; MethodType
2623   JavaCallArguments args(Handle(THREAD, rt()));
2624   args.push_oop(pts);
2625   JavaValue result(T_OBJECT);
2626   JavaCalls::call_static(&amp;result,
2627                          SystemDictionary::MethodHandleNatives_klass(),
2628                          vmSymbols::findMethodHandleType_name(),
2629                          vmSymbols::findMethodHandleType_signature(),
2630                          &amp;args, CHECK_(empty));
2631   Handle method_type(THREAD, (oop) result.get_jobject());
2632 
2633   if (can_be_cached) {
2634     // We can cache this MethodType inside the JVM.
<span class="line-modified">2635     MutexLocker ml(THREAD, SystemDictionary_lock);</span>
2636     spe = invoke_method_table()-&gt;find_entry(index, hash, signature, null_iid);
2637     if (spe == NULL)
2638       spe = invoke_method_table()-&gt;add_entry(index, hash, signature, null_iid);
2639     if (spe-&gt;method_type() == NULL) {
2640       spe-&gt;set_method_type(method_type());
2641     }
2642   }
2643 
2644   // report back to the caller with the MethodType
2645   return method_type;
2646 }
2647 
2648 Handle SystemDictionary::find_field_handle_type(Symbol* signature,
2649                                                 Klass* accessing_klass,
2650                                                 TRAPS) {
2651   Handle empty;
2652   ResourceMark rm(THREAD);
2653   SignatureStream ss(signature, /*is_method=*/ false);
2654   if (!ss.is_done()) {
2655     Handle class_loader, protection_domain;
</pre>
<hr />
<pre>
2700 
2701   // After method/field resolution succeeded, it&#39;s safe to resolve MH signature as well.
2702   Handle type = MethodHandles::resolve_MemberName_type(mname, caller, CHECK_(empty));
2703 
2704   // call java.lang.invoke.MethodHandleNatives::linkMethodHandleConstant(Class caller, int refKind, Class callee, String name, Object type) -&gt; MethodHandle
2705   JavaCallArguments args;
2706   args.push_oop(Handle(THREAD, caller-&gt;java_mirror()));  // the referring class
2707   args.push_int(ref_kind);
2708   args.push_oop(Handle(THREAD, callee-&gt;java_mirror()));  // the target class
2709   args.push_oop(name_str);
2710   args.push_oop(type);
2711   JavaValue result(T_OBJECT);
2712   JavaCalls::call_static(&amp;result,
2713                          SystemDictionary::MethodHandleNatives_klass(),
2714                          vmSymbols::linkMethodHandleConstant_name(),
2715                          vmSymbols::linkMethodHandleConstant_signature(),
2716                          &amp;args, CHECK_(empty));
2717   return Handle(THREAD, (oop) result.get_jobject());
2718 }
2719 
<span class="line-modified">2720 // Ask Java to run a bootstrap method, in order to create a dynamic call site</span>
<span class="line-modified">2721 // while linking an invokedynamic op, or compute a constant for Dynamic_info CP entry</span>
<span class="line-modified">2722 // with linkage results being stored back into the bootstrap specifier.</span>
<span class="line-modified">2723 void SystemDictionary::invoke_bootstrap_method(BootstrapInfo&amp; bootstrap_specifier, TRAPS) {</span>
<span class="line-modified">2724   // Resolve the bootstrap specifier, its name, type, and static arguments</span>
<span class="line-modified">2725   bootstrap_specifier.resolve_bsm(CHECK);</span>














2726 
2727   // This should not happen.  JDK code should take care of that.
<span class="line-modified">2728   if (bootstrap_specifier.caller() == NULL || bootstrap_specifier.type_arg().is_null()) {</span>
<span class="line-modified">2729     THROW_MSG(vmSymbols::java_lang_InternalError(), &quot;Invalid bootstrap method invocation with no caller or type argument&quot;);</span>
2730   }
2731 
<span class="line-modified">2732   bool is_indy = bootstrap_specifier.is_method_call();</span>
<span class="line-modified">2733   objArrayHandle appendix_box;</span>
<span class="line-modified">2734   if (is_indy) {</span>
<span class="line-modified">2735     // Some method calls may require an appendix argument.  Arrange to receive it.</span>
<span class="line-modified">2736     appendix_box = oopFactory::new_objArray_handle(SystemDictionary::Object_klass(), 1, CHECK);</span>
<span class="line-added">2737     assert(appendix_box-&gt;obj_at(0) == NULL, &quot;&quot;);</span>
<span class="line-added">2738   }</span>
2739 
<span class="line-modified">2740   // call condy: java.lang.invoke.MethodHandleNatives::linkDynamicConstant(caller, condy_index, bsm, type, info)</span>
<span class="line-added">2741   //       indy: java.lang.invoke.MethodHandleNatives::linkCallSite(caller, indy_index, bsm, name, mtype, info, &amp;appendix)</span>
2742   JavaCallArguments args;
<span class="line-modified">2743   args.push_oop(Handle(THREAD, bootstrap_specifier.caller_mirror()));</span>
<span class="line-modified">2744   args.push_int(bootstrap_specifier.bss_index());</span>
<span class="line-modified">2745   args.push_oop(bootstrap_specifier.bsm());</span>
<span class="line-modified">2746   args.push_oop(bootstrap_specifier.name_arg());</span>
<span class="line-modified">2747   args.push_oop(bootstrap_specifier.type_arg());</span>
<span class="line-modified">2748   args.push_oop(bootstrap_specifier.arg_values());</span>
<span class="line-added">2749   if (is_indy) {</span>
<span class="line-added">2750     args.push_oop(appendix_box);</span>
<span class="line-added">2751   }</span>
2752   JavaValue result(T_OBJECT);
2753   JavaCalls::call_static(&amp;result,
2754                          SystemDictionary::MethodHandleNatives_klass(),
<span class="line-modified">2755                          is_indy ? vmSymbols::linkCallSite_name() : vmSymbols::linkDynamicConstant_name(),</span>
<span class="line-modified">2756                          is_indy ? vmSymbols::linkCallSite_signature() : vmSymbols::linkDynamicConstant_signature(),</span>
<span class="line-modified">2757                          &amp;args, CHECK);</span>
<span class="line-modified">2758 </span>
<span class="line-modified">2759   Handle value(THREAD, (oop) result.get_jobject());</span>
<span class="line-modified">2760   if (is_indy) {</span>
<span class="line-modified">2761     Handle appendix;</span>
<span class="line-modified">2762     Method* method = unpack_method_and_appendix(value,</span>
<span class="line-modified">2763                                                 bootstrap_specifier.caller(),</span>
<span class="line-modified">2764                                                 appendix_box,</span>
<span class="line-modified">2765                                                 &amp;appendix, CHECK);</span>
<span class="line-modified">2766     methodHandle mh(THREAD, method);</span>
<span class="line-modified">2767     bootstrap_specifier.set_resolved_method(mh, appendix);</span>







2768   } else {
<span class="line-modified">2769     bootstrap_specifier.set_resolved_value(value);</span>













2770   }
2771 
<span class="line-modified">2772   // sanity check</span>
<span class="line-modified">2773   assert(bootstrap_specifier.is_resolved() ||</span>
<span class="line-modified">2774          (bootstrap_specifier.is_method_call() &amp;&amp;</span>
<span class="line-modified">2775           bootstrap_specifier.resolved_method().not_null()), &quot;bootstrap method call failed&quot;);</span>
















2776 }
2777 
2778 // Protection domain cache table handling
2779 
2780 ProtectionDomainCacheEntry* SystemDictionary::cache_get(Handle protection_domain) {
2781   return _pd_cache_table-&gt;get(protection_domain);
2782 }
2783 
2784 // ----------------------------------------------------------------------------
2785 
2786 void SystemDictionary::print_on(outputStream *st) {
2787   CDS_ONLY(SystemDictionaryShared::print_on(st));
2788   GCMutexLocker mu(SystemDictionary_lock);
2789 
2790   ClassLoaderDataGraph::print_dictionary(st);
2791 
2792   // Placeholders
2793   placeholders()-&gt;print_on(st);
2794   st-&gt;cr();
2795 
2796   // loader constraints - print under SD_lock
2797   constraints()-&gt;print_on(st);
2798   st-&gt;cr();
2799 
2800   _pd_cache_table-&gt;print_on(st);
2801   st-&gt;cr();
2802 }
2803 
<span class="line-added">2804 void SystemDictionary::print() { print_on(tty); }</span>
<span class="line-added">2805 </span>
2806 void SystemDictionary::verify() {
2807   guarantee(constraints() != NULL,
2808             &quot;Verify of loader constraints failed&quot;);
2809   guarantee(placeholders()-&gt;number_of_entries() &gt;= 0,
2810             &quot;Verify of placeholders failed&quot;);
2811 
2812   GCMutexLocker mu(SystemDictionary_lock);
2813 
2814   // Verify dictionary
2815   ClassLoaderDataGraph::verify_dictionary();
2816 
2817   placeholders()-&gt;verify();
2818 
2819   // Verify constraint table
2820   guarantee(constraints() != NULL, &quot;Verify of loader constraints failed&quot;);
2821   constraints()-&gt;verify(placeholders());
2822 
2823   _pd_cache_table-&gt;verify();
2824 }
2825 
2826 void SystemDictionary::dump(outputStream *st, bool verbose) {
2827   assert_locked_or_safepoint(SystemDictionary_lock);
2828   if (verbose) {
2829     print_on(st);
2830   } else {
2831     CDS_ONLY(SystemDictionaryShared::print_table_statistics(st));
<span class="line-modified">2832     ClassLoaderDataGraph::print_table_statistics(st);</span>
2833     placeholders()-&gt;print_table_statistics(st, &quot;Placeholder Table&quot;);
2834     constraints()-&gt;print_table_statistics(st, &quot;LoaderConstraints Table&quot;);
<span class="line-modified">2835     pd_cache_table()-&gt;print_table_statistics(st, &quot;ProtectionDomainCache Table&quot;);</span>
2836   }
2837 }
2838 
<span class="line-added">2839 TableStatistics SystemDictionary::placeholders_statistics() {</span>
<span class="line-added">2840   MutexLocker ml(SystemDictionary_lock);</span>
<span class="line-added">2841   return placeholders()-&gt;statistics_calculate();</span>
<span class="line-added">2842 }</span>
<span class="line-added">2843 </span>
<span class="line-added">2844 TableStatistics SystemDictionary::loader_constraints_statistics() {</span>
<span class="line-added">2845   MutexLocker ml(SystemDictionary_lock);</span>
<span class="line-added">2846   return constraints()-&gt;statistics_calculate();</span>
<span class="line-added">2847 }</span>
<span class="line-added">2848 </span>
<span class="line-added">2849 TableStatistics SystemDictionary::protection_domain_cache_statistics() {</span>
<span class="line-added">2850   MutexLocker ml(SystemDictionary_lock);</span>
<span class="line-added">2851   return pd_cache_table()-&gt;statistics_calculate();</span>
<span class="line-added">2852 }</span>
<span class="line-added">2853 </span>
2854 // Utility for dumping dictionaries.
2855 SystemDictionaryDCmd::SystemDictionaryDCmd(outputStream* output, bool heap) :
2856                                  DCmdWithParser(output, heap),
2857   _verbose(&quot;-verbose&quot;, &quot;Dump the content of each dictionary entry for all class loaders&quot;,
2858            &quot;BOOLEAN&quot;, false, &quot;false&quot;) {
2859   _dcmdparser.add_dcmd_option(&amp;_verbose);
2860 }
2861 
2862 void SystemDictionaryDCmd::execute(DCmdSource source, TRAPS) {
2863   VM_DumpHashtable dumper(output(), VM_DumpHashtable::DumpSysDict,
2864                          _verbose.value());
2865   VMThread::execute(&amp;dumper);
2866 }
2867 
2868 int SystemDictionaryDCmd::num_arguments() {
2869   ResourceMark rm;
2870   SystemDictionaryDCmd* dcmd = new SystemDictionaryDCmd(NULL, false);
2871   if (dcmd != NULL) {
2872     DCmdMark mark(dcmd);
2873     return dcmd-&gt;_dcmdparser.num_arguments();
2874   } else {
2875     return 0;
2876   }
2877 }












</pre>
</td>
</tr>
</table>
<center><a href="javaClasses.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="tsanIgnoreList.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
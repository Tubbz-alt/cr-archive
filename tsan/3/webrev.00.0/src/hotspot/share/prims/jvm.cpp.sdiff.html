<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/prims/jvm.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="../oops/instanceKlass.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="jvmtiEnv.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/prims/jvm.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 1997, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include &quot;precompiled.hpp&quot;
  26 #include &quot;jvm.h&quot;
  27 #include &quot;classfile/classFileStream.hpp&quot;
  28 #include &quot;classfile/classLoader.hpp&quot;
  29 #include &quot;classfile/classLoaderData.inline.hpp&quot;
  30 #include &quot;classfile/javaAssertions.hpp&quot;
  31 #include &quot;classfile/javaClasses.inline.hpp&quot;
  32 #include &quot;classfile/moduleEntry.hpp&quot;
  33 #include &quot;classfile/modules.hpp&quot;
  34 #include &quot;classfile/packageEntry.hpp&quot;
  35 #include &quot;classfile/stringTable.hpp&quot;

  36 #include &quot;classfile/systemDictionary.hpp&quot;
  37 #include &quot;classfile/vmSymbols.hpp&quot;
  38 #include &quot;gc/shared/collectedHeap.inline.hpp&quot;
  39 #include &quot;interpreter/bytecode.hpp&quot;

  40 #include &quot;jfr/jfrEvents.hpp&quot;
  41 #include &quot;logging/log.hpp&quot;
  42 #include &quot;memory/heapShared.hpp&quot;
  43 #include &quot;memory/oopFactory.hpp&quot;
  44 #include &quot;memory/referenceType.hpp&quot;
  45 #include &quot;memory/resourceArea.hpp&quot;
  46 #include &quot;memory/universe.hpp&quot;
  47 #include &quot;oops/access.inline.hpp&quot;
  48 #include &quot;oops/constantPool.hpp&quot;
<span class="line-modified">  49 #include &quot;oops/fieldStreams.hpp&quot;</span>
  50 #include &quot;oops/instanceKlass.hpp&quot;
  51 #include &quot;oops/method.hpp&quot;

  52 #include &quot;oops/objArrayKlass.hpp&quot;
  53 #include &quot;oops/objArrayOop.inline.hpp&quot;
  54 #include &quot;oops/oop.inline.hpp&quot;
  55 #include &quot;prims/jvm_misc.hpp&quot;
  56 #include &quot;prims/jvmtiExport.hpp&quot;
  57 #include &quot;prims/jvmtiThreadState.hpp&quot;
  58 #include &quot;prims/nativeLookup.hpp&quot;
  59 #include &quot;prims/stackwalk.hpp&quot;
  60 #include &quot;runtime/arguments.hpp&quot;
  61 #include &quot;runtime/atomic.hpp&quot;
  62 #include &quot;runtime/handles.inline.hpp&quot;
  63 #include &quot;runtime/init.hpp&quot;
  64 #include &quot;runtime/interfaceSupport.inline.hpp&quot;
  65 #include &quot;runtime/deoptimization.hpp&quot;

  66 #include &quot;runtime/java.hpp&quot;
  67 #include &quot;runtime/javaCalls.hpp&quot;
  68 #include &quot;runtime/jfieldIDWorkaround.hpp&quot;
  69 #include &quot;runtime/jniHandles.inline.hpp&quot;
<span class="line-removed">  70 #include &quot;runtime/orderAccess.hpp&quot;</span>
  71 #include &quot;runtime/os.inline.hpp&quot;
  72 #include &quot;runtime/perfData.hpp&quot;
  73 #include &quot;runtime/reflection.hpp&quot;
  74 #include &quot;runtime/thread.inline.hpp&quot;
  75 #include &quot;runtime/threadSMR.hpp&quot;
  76 #include &quot;runtime/vframe.inline.hpp&quot;
  77 #include &quot;runtime/vmOperations.hpp&quot;
  78 #include &quot;runtime/vm_version.hpp&quot;
  79 #include &quot;services/attachListener.hpp&quot;
  80 #include &quot;services/management.hpp&quot;
  81 #include &quot;services/threadService.hpp&quot;
  82 #if INCLUDE_TSAN
  83 #include &quot;tsan/tsan.hpp&quot;
  84 #endif  // INCLUDE_TSAN
  85 #include &quot;utilities/copy.hpp&quot;
  86 #include &quot;utilities/defaultStream.hpp&quot;
  87 #include &quot;utilities/dtrace.hpp&quot;
  88 #include &quot;utilities/events.hpp&quot;
  89 #include &quot;utilities/histogram.hpp&quot;
  90 #include &quot;utilities/macros.hpp&quot;
</pre>
<hr />
<pre>
 123 
 124 
 125   The solution is to keep the oop declaration BELOW the ctor or function
 126   call that might cause a GC, do another resolve to reassign the oop, or
 127   consider use of a Handle instead of an oop so there is immunity from object
 128   motion. But note that the &quot;QUICK&quot; entries below do not have a handlemark
 129   and thus can only support use of handles passed in.
 130 */
 131 
 132 static void trace_class_resolution_impl(Klass* to_class, TRAPS) {
 133   ResourceMark rm;
 134   int line_number = -1;
 135   const char * source_file = NULL;
 136   const char * trace = &quot;explicit&quot;;
 137   InstanceKlass* caller = NULL;
 138   JavaThread* jthread = JavaThread::current();
 139   if (jthread-&gt;has_last_Java_frame()) {
 140     vframeStream vfst(jthread);
 141 
 142     // scan up the stack skipping ClassLoader, AccessController and PrivilegedAction frames
<span class="line-modified"> 143     TempNewSymbol access_controller = SymbolTable::new_symbol(&quot;java/security/AccessController&quot;, CHECK);</span>
 144     Klass* access_controller_klass = SystemDictionary::resolve_or_fail(access_controller, false, CHECK);
<span class="line-modified"> 145     TempNewSymbol privileged_action = SymbolTable::new_symbol(&quot;java/security/PrivilegedAction&quot;, CHECK);</span>
 146     Klass* privileged_action_klass = SystemDictionary::resolve_or_fail(privileged_action, false, CHECK);
 147 
 148     Method* last_caller = NULL;
 149 
 150     while (!vfst.at_end()) {
 151       Method* m = vfst.method();
 152       if (!vfst.method()-&gt;method_holder()-&gt;is_subclass_of(SystemDictionary::ClassLoader_klass())&amp;&amp;
 153           !vfst.method()-&gt;method_holder()-&gt;is_subclass_of(access_controller_klass) &amp;&amp;
 154           !vfst.method()-&gt;method_holder()-&gt;is_subclass_of(privileged_action_klass)) {
 155         break;
 156       }
 157       last_caller = m;
 158       vfst.next();
 159     }
 160     // if this is called from Class.forName0 and that is called from Class.forName,
 161     // then print the caller of Class.forName.  If this is Class.loadClass, then print
 162     // that caller, otherwise keep quiet since this should be picked up elsewhere.
 163     bool found_it = false;
 164     if (!vfst.at_end() &amp;&amp;
 165         vfst.method()-&gt;method_holder()-&gt;name() == vmSymbols::java_lang_Class() &amp;&amp;
</pre>
<hr />
<pre>
 216   if (HAS_PENDING_EXCEPTION) {
 217     CLEAR_PENDING_EXCEPTION;
 218   }
 219 }
 220 
 221 // Wrapper to trace JVM functions
 222 
 223 #ifdef ASSERT
 224   Histogram* JVMHistogram;
 225   volatile int JVMHistogram_lock = 0;
 226 
 227   class JVMHistogramElement : public HistogramElement {
 228     public:
 229      JVMHistogramElement(const char* name);
 230   };
 231 
 232   JVMHistogramElement::JVMHistogramElement(const char* elementName) {
 233     _name = elementName;
 234     uintx count = 0;
 235 
<span class="line-modified"> 236     while (Atomic::cmpxchg(1, &amp;JVMHistogram_lock, 0) != 0) {</span>
<span class="line-modified"> 237       while (OrderAccess::load_acquire(&amp;JVMHistogram_lock) != 0) {</span>
 238         count +=1;
 239         if ( (WarnOnStalledSpinLock &gt; 0)
 240           &amp;&amp; (count % WarnOnStalledSpinLock == 0)) {
 241           warning(&quot;JVMHistogram_lock seems to be stalled&quot;);
 242         }
 243       }
 244      }
 245 
 246     if(JVMHistogram == NULL)
 247       JVMHistogram = new Histogram(&quot;JVM Call Counts&quot;,100);
 248 
 249     JVMHistogram-&gt;add_element(this);
 250     Atomic::dec(&amp;JVMHistogram_lock);
 251   }
 252 
 253   #define JVMCountWrapper(arg) \
 254       static JVMHistogramElement* e = new JVMHistogramElement(arg); \
 255       if (e != NULL) e-&gt;increment_count();  // Due to bug in VC++, we need a NULL check here eventhough it should never happen!
 256 
 257   #define JVMWrapper(arg) JVMCountWrapper(arg);
</pre>
<hr />
<pre>
 494   JVMWrapper(&quot;JVM_MaxObjectInspectionAge&quot;);
 495   return Universe::heap()-&gt;millis_since_last_gc();
 496 JVM_END
 497 
 498 
 499 static inline jlong convert_size_t_to_jlong(size_t val) {
 500   // In the 64-bit vm, a size_t can overflow a jlong (which is signed).
 501   NOT_LP64 (return (jlong)val;)
 502   LP64_ONLY(return (jlong)MIN2(val, (size_t)max_jlong);)
 503 }
 504 
 505 JVM_ENTRY_NO_ENV(jlong, JVM_TotalMemory(void))
 506   JVMWrapper(&quot;JVM_TotalMemory&quot;);
 507   size_t n = Universe::heap()-&gt;capacity();
 508   return convert_size_t_to_jlong(n);
 509 JVM_END
 510 
 511 
 512 JVM_ENTRY_NO_ENV(jlong, JVM_FreeMemory(void))
 513   JVMWrapper(&quot;JVM_FreeMemory&quot;);
<span class="line-modified"> 514   CollectedHeap* ch = Universe::heap();</span>
<span class="line-removed"> 515   size_t n;</span>
<span class="line-removed"> 516   {</span>
<span class="line-removed"> 517      MutexLocker x(Heap_lock);</span>
<span class="line-removed"> 518      n = ch-&gt;capacity() - ch-&gt;used();</span>
<span class="line-removed"> 519   }</span>
 520   return convert_size_t_to_jlong(n);
 521 JVM_END
 522 
 523 
 524 JVM_ENTRY_NO_ENV(jlong, JVM_MaxMemory(void))
 525   JVMWrapper(&quot;JVM_MaxMemory&quot;);
 526   size_t n = Universe::heap()-&gt;max_capacity();
 527   return convert_size_t_to_jlong(n);
 528 JVM_END
 529 
 530 
 531 JVM_ENTRY_NO_ENV(jint, JVM_ActiveProcessorCount(void))
 532   JVMWrapper(&quot;JVM_ActiveProcessorCount&quot;);
 533   return os::active_processor_count();
 534 JVM_END
 535 
 536 
 537 
 538 // java.lang.Throwable //////////////////////////////////////////////////////
 539 
<span class="line-removed"> 540 </span>
 541 JVM_ENTRY(void, JVM_FillInStackTrace(JNIEnv *env, jobject receiver))
 542   JVMWrapper(&quot;JVM_FillInStackTrace&quot;);
 543   Handle exception(thread, JNIHandles::resolve_non_null(receiver));
 544   java_lang_Throwable::fill_in_stack_trace(exception);
 545 JVM_END
 546 

























 547 
 548 // java.lang.StackTraceElement //////////////////////////////////////////////
 549 
 550 
 551 JVM_ENTRY(void, JVM_InitStackTraceElementArray(JNIEnv *env, jobjectArray elements, jobject throwable))
 552   JVMWrapper(&quot;JVM_InitStackTraceElementArray&quot;);
 553   Handle exception(THREAD, JNIHandles::resolve(throwable));
 554   objArrayOop st = objArrayOop(JNIHandles::resolve(elements));
 555   objArrayHandle stack_trace(THREAD, st);
 556   // Fill in the allocated stack trace
 557   java_lang_Throwable::get_stack_trace_elements(exception, stack_trace, CHECK);
 558 JVM_END
 559 
 560 
 561 JVM_ENTRY(void, JVM_InitStackTraceElement(JNIEnv* env, jobject element, jobject stackFrameInfo))
 562   JVMWrapper(&quot;JVM_InitStackTraceElement&quot;);
 563   Handle stack_frame_info(THREAD, JNIHandles::resolve_non_null(stackFrameInfo));
 564   Handle stack_trace_element(THREAD, JNIHandles::resolve_non_null(element));
 565   java_lang_StackFrameInfo::to_stack_trace_element(stack_frame_info, stack_trace_element, THREAD);
 566 JVM_END
</pre>
<hr />
<pre>
 751       if (!m-&gt;caller_sensitive()) {
 752         THROW_MSG_NULL(vmSymbols::java_lang_InternalError(), err_msg(&quot;CallerSensitive annotation expected at frame %d&quot;, n));
 753       }
 754       break;
 755     default:
 756       if (!m-&gt;is_ignored_by_security_stack_walk()) {
 757         // We have reached the desired frame; return the holder class.
 758         return (jclass) JNIHandles::make_local(env, m-&gt;method_holder()-&gt;java_mirror());
 759       }
 760       break;
 761     }
 762   }
 763   return NULL;
 764 JVM_END
 765 
 766 
 767 JVM_ENTRY(jclass, JVM_FindPrimitiveClass(JNIEnv* env, const char* utf))
 768   JVMWrapper(&quot;JVM_FindPrimitiveClass&quot;);
 769   oop mirror = NULL;
 770   BasicType t = name2type(utf);
<span class="line-modified"> 771   if (t != T_ILLEGAL &amp;&amp; t != T_OBJECT &amp;&amp; t != T_ARRAY) {</span>
 772     mirror = Universe::java_mirror(t);
 773   }
 774   if (mirror == NULL) {
 775     THROW_MSG_0(vmSymbols::java_lang_ClassNotFoundException(), (char*) utf);
 776   } else {
 777     return (jclass) JNIHandles::make_local(env, mirror);
 778   }
 779 JVM_END
 780 
 781 
 782 // Returns a class loaded by the bootstrap class loader; or null
 783 // if not found.  ClassNotFoundException is not thrown.
 784 // FindClassFromBootLoader is exported to the launcher for windows.
 785 JVM_ENTRY(jclass, JVM_FindClassFromBootLoader(JNIEnv* env,
 786                                               const char* name))
 787   JVMWrapper(&quot;JVM_FindClassFromBootLoader&quot;);
 788 
 789   // Java libraries should ensure that name is never null...
 790   if (name == NULL || (int)strlen(name) &gt; Symbol::max_length()) {
 791     // It&#39;s impossible to create this class;  the name cannot fit
 792     // into the constant pool.
 793     return NULL;
 794   }
 795 
<span class="line-modified"> 796   TempNewSymbol h_name = SymbolTable::new_symbol(name, CHECK_NULL);</span>
 797   Klass* k = SystemDictionary::resolve_or_null(h_name, CHECK_NULL);
 798   if (k == NULL) {
 799     return NULL;
 800   }
 801 
 802   if (log_is_enabled(Debug, class, resolve)) {
 803     trace_class_resolution(k);
 804   }
 805   return (jclass) JNIHandles::make_local(env, k-&gt;java_mirror());
 806 JVM_END
 807 
 808 // Find a class with this name in this loader, using the caller&#39;s protection domain.
 809 JVM_ENTRY(jclass, JVM_FindClassFromCaller(JNIEnv* env, const char* name,
 810                                           jboolean init, jobject loader,
 811                                           jclass caller))
 812   JVMWrapper(&quot;JVM_FindClassFromCaller throws ClassNotFoundException&quot;);
 813   // Java libraries should ensure that name is never null...
 814   if (name == NULL || (int)strlen(name) &gt; Symbol::max_length()) {
 815     // It&#39;s impossible to create this class;  the name cannot fit
 816     // into the constant pool.
 817     THROW_MSG_0(vmSymbols::java_lang_ClassNotFoundException(), name);
 818   }
 819 
<span class="line-modified"> 820   TempNewSymbol h_name = SymbolTable::new_symbol(name, CHECK_NULL);</span>
 821 
 822   oop loader_oop = JNIHandles::resolve(loader);
 823   oop from_class = JNIHandles::resolve(caller);
 824   oop protection_domain = NULL;
 825   // If loader is null, shouldn&#39;t call ClassLoader.checkPackageAccess; otherwise get
 826   // NPE. Put it in another way, the bootstrap class loader has all permission and
 827   // thus no checkPackageAccess equivalence in the VM class loader.
 828   // The caller is also passed as NULL by the java code if there is no security
 829   // manager to avoid the performance cost of getting the calling class.
 830   if (from_class != NULL &amp;&amp; loader_oop != NULL) {
 831     protection_domain = java_lang_Class::as_Klass(from_class)-&gt;protection_domain();
 832   }
 833 
 834   Handle h_loader(THREAD, loader_oop);
 835   Handle h_prot(THREAD, protection_domain);
 836   jclass result = find_class_from_class_loader(env, h_name, init, h_loader,
 837                                                h_prot, false, THREAD);
 838 
 839   if (log_is_enabled(Debug, class, resolve) &amp;&amp; result != NULL) {
 840     trace_class_resolution(java_lang_Class::as_Klass(JNIHandles::resolve_non_null(result)));
</pre>
<hr />
<pre>
 842   return result;
 843 JVM_END
 844 
 845 // Currently only called from the old verifier.
 846 JVM_ENTRY(jclass, JVM_FindClassFromClass(JNIEnv *env, const char *name,
 847                                          jboolean init, jclass from))
 848   JVMWrapper(&quot;JVM_FindClassFromClass&quot;);
 849   if (name == NULL) {
 850     THROW_MSG_0(vmSymbols::java_lang_NoClassDefFoundError(), &quot;No class name given&quot;);
 851   }
 852   if ((int)strlen(name) &gt; Symbol::max_length()) {
 853     // It&#39;s impossible to create this class;  the name cannot fit
 854     // into the constant pool.
 855     Exceptions::fthrow(THREAD_AND_LOCATION,
 856                        vmSymbols::java_lang_NoClassDefFoundError(),
 857                        &quot;Class name exceeds maximum length of %d: %s&quot;,
 858                        Symbol::max_length(),
 859                        name);
 860     return 0;
 861   }
<span class="line-modified"> 862   TempNewSymbol h_name = SymbolTable::new_symbol(name, CHECK_NULL);</span>
 863   oop from_class_oop = JNIHandles::resolve(from);
 864   Klass* from_class = (from_class_oop == NULL)
 865                            ? (Klass*)NULL
 866                            : java_lang_Class::as_Klass(from_class_oop);
 867   oop class_loader = NULL;
 868   oop protection_domain = NULL;
 869   if (from_class != NULL) {
 870     class_loader = from_class-&gt;class_loader();
 871     protection_domain = from_class-&gt;protection_domain();
 872   }
 873   Handle h_loader(THREAD, class_loader);
 874   Handle h_prot  (THREAD, protection_domain);
 875   jclass result = find_class_from_class_loader(env, h_name, init, h_loader,
 876                                                h_prot, true, thread);
 877 
 878   if (log_is_enabled(Debug, class, resolve) &amp;&amp; result != NULL) {
 879     // this function is generally only used for class loading during verification.
 880     ResourceMark rm;
 881     oop from_mirror = JNIHandles::resolve_non_null(from);
 882     Klass* from_class = java_lang_Class::as_Klass(from_mirror);
</pre>
<hr />
<pre>
 923 
 924   if (UsePerfData) {
 925     ClassLoader::perf_app_classfile_bytes_read()-&gt;inc(len);
 926   }
 927 
 928   // Since exceptions can be thrown, class initialization can take place
 929   // if name is NULL no check for class name in .class stream has to be made.
 930   TempNewSymbol class_name = NULL;
 931   if (name != NULL) {
 932     const int str_len = (int)strlen(name);
 933     if (str_len &gt; Symbol::max_length()) {
 934       // It&#39;s impossible to create this class;  the name cannot fit
 935       // into the constant pool.
 936       Exceptions::fthrow(THREAD_AND_LOCATION,
 937                          vmSymbols::java_lang_NoClassDefFoundError(),
 938                          &quot;Class name exceeds maximum length of %d: %s&quot;,
 939                          Symbol::max_length(),
 940                          name);
 941       return 0;
 942     }
<span class="line-modified"> 943     class_name = SymbolTable::new_symbol(name, str_len, CHECK_NULL);</span>
 944   }
 945 
 946   ResourceMark rm(THREAD);
 947   ClassFileStream st((u1*)buf, len, source, ClassFileStream::verify);
 948   Handle class_loader (THREAD, JNIHandles::resolve(loader));
 949   if (UsePerfData) {
 950     is_lock_held_by_thread(class_loader,
 951                            ClassLoader::sync_JVMDefineClassLockFreeCounter(),
 952                            THREAD);
 953   }
 954   Handle protection_domain (THREAD, JNIHandles::resolve(pd));
 955   Klass* k = SystemDictionary::resolve_from_stream(class_name,
 956                                                    class_loader,
 957                                                    protection_domain,
 958                                                    &amp;st,
 959                                                    CHECK_NULL);
 960 
 961   if (log_is_enabled(Debug, class, resolve) &amp;&amp; k != NULL) {
 962     trace_class_resolution(k);
 963   }
</pre>
<hr />
<pre>
 967 
 968 
 969 JVM_ENTRY(jclass, JVM_DefineClass(JNIEnv *env, const char *name, jobject loader, const jbyte *buf, jsize len, jobject pd))
 970   JVMWrapper(&quot;JVM_DefineClass&quot;);
 971 
 972   return jvm_define_class_common(env, name, loader, buf, len, pd, NULL, THREAD);
 973 JVM_END
 974 
 975 
 976 JVM_ENTRY(jclass, JVM_DefineClassWithSource(JNIEnv *env, const char *name, jobject loader, const jbyte *buf, jsize len, jobject pd, const char *source))
 977   JVMWrapper(&quot;JVM_DefineClassWithSource&quot;);
 978 
 979   return jvm_define_class_common(env, name, loader, buf, len, pd, source, THREAD);
 980 JVM_END
 981 
 982 JVM_ENTRY(jclass, JVM_FindLoadedClass(JNIEnv *env, jobject loader, jstring name))
 983   JVMWrapper(&quot;JVM_FindLoadedClass&quot;);
 984   ResourceMark rm(THREAD);
 985 
 986   Handle h_name (THREAD, JNIHandles::resolve_non_null(name));
<span class="line-modified"> 987   Handle string = java_lang_String::internalize_classname(h_name, CHECK_NULL);</span>
 988 
<span class="line-removed"> 989   const char* str   = java_lang_String::as_utf8_string(string());</span>
 990   // Sanity check, don&#39;t expect null
 991   if (str == NULL) return NULL;
 992 
<span class="line-modified"> 993   const int str_len = (int)strlen(str);</span>









 994   if (str_len &gt; Symbol::max_length()) {
 995     // It&#39;s impossible to create this class;  the name cannot fit
 996     // into the constant pool.
 997     return NULL;
 998   }
<span class="line-modified"> 999   TempNewSymbol klass_name = SymbolTable::new_symbol(str, str_len, CHECK_NULL);</span>
1000 
1001   // Security Note:
1002   //   The Java level wrapper will perform the necessary security check allowing
1003   //   us to pass the NULL as the initiating class loader.
1004   Handle h_loader(THREAD, JNIHandles::resolve(loader));
1005   if (UsePerfData) {
1006     is_lock_held_by_thread(h_loader,
1007                            ClassLoader::sync_JVMFindLoadedClassLockFreeCounter(),
1008                            THREAD);
1009   }
1010 
1011   Klass* k = SystemDictionary::find_instance_or_array_klass(klass_name,
1012                                                               h_loader,
1013                                                               Handle(),
1014                                                               CHECK_NULL);
1015 #if INCLUDE_CDS
1016   if (k == NULL) {
1017     // If the class is not already loaded, try to see if it&#39;s in the shared
1018     // archive for the current classloader (h_loader).
1019     k = SystemDictionaryShared::find_or_load_shared_class(klass_name, h_loader, CHECK_NULL);
</pre>
<hr />
<pre>
1094 
1095   // Allocate result array
1096   objArrayOop r = oopFactory::new_objArray(SystemDictionary::Class_klass(), size, CHECK_NULL);
1097   objArrayHandle result (THREAD, r);
1098   // Fill in result
1099   if (klass-&gt;is_instance_klass()) {
1100     // Regular instance klass, fill in all local interfaces
1101     for (int index = 0; index &lt; size; index++) {
1102       Klass* k = InstanceKlass::cast(klass)-&gt;local_interfaces()-&gt;at(index);
1103       result-&gt;obj_at_put(index, k-&gt;java_mirror());
1104     }
1105   } else {
1106     // All arrays implement java.lang.Cloneable and java.io.Serializable
1107     result-&gt;obj_at_put(0, SystemDictionary::Cloneable_klass()-&gt;java_mirror());
1108     result-&gt;obj_at_put(1, SystemDictionary::Serializable_klass()-&gt;java_mirror());
1109   }
1110   return (jobjectArray) JNIHandles::make_local(env, result());
1111 JVM_END
1112 
1113 
<span class="line-modified">1114 JVM_QUICK_ENTRY(jboolean, JVM_IsInterface(JNIEnv *env, jclass cls))</span>
1115   JVMWrapper(&quot;JVM_IsInterface&quot;);
1116   oop mirror = JNIHandles::resolve_non_null(cls);
1117   if (java_lang_Class::is_primitive(mirror)) {
1118     return JNI_FALSE;
1119   }
1120   Klass* k = java_lang_Class::as_Klass(mirror);
1121   jboolean result = k-&gt;is_interface();
1122   assert(!result || k-&gt;is_instance_klass(),
1123          &quot;all interfaces are instance types&quot;);
1124   // The compiler intrinsic for isInterface tests the
1125   // Klass::_access_flags bits in the same way.
1126   return result;
1127 JVM_END
1128 
1129 
1130 JVM_ENTRY(jobjectArray, JVM_GetClassSigners(JNIEnv *env, jclass cls))
1131   JVMWrapper(&quot;JVM_GetClassSigners&quot;);
1132   JvmtiVMObjectAllocEventCollector oam;
1133   if (java_lang_Class::is_primitive(JNIHandles::resolve_non_null(cls))) {
1134     // There are no signers for primitive types
</pre>
<hr />
<pre>
1234     {
1235       // this frame is privileged
1236       is_privileged = true;
1237 
1238       javaVFrame *priv = vfst.asJavaVFrame();       // executePrivileged
1239 
1240       StackValueCollection* locals = priv-&gt;locals();
1241       StackValue* ctx_sv = locals-&gt;at(1); // AccessControlContext context
1242       StackValue* clr_sv = locals-&gt;at(2); // Class&lt;?&gt; caller
1243       assert(!ctx_sv-&gt;obj_is_scalar_replaced(), &quot;found scalar-replaced object&quot;);
1244       assert(!clr_sv-&gt;obj_is_scalar_replaced(), &quot;found scalar-replaced object&quot;);
1245       privileged_context    = ctx_sv-&gt;get_obj();
1246       Handle caller         = clr_sv-&gt;get_obj();
1247 
1248       Klass *caller_klass = java_lang_Class::as_Klass(caller());
1249       protection_domain  = caller_klass-&gt;protection_domain();
1250     } else {
1251       protection_domain = method-&gt;method_holder()-&gt;protection_domain();
1252     }
1253 
<span class="line-modified">1254     if ((!oopDesc::equals(previous_protection_domain, protection_domain)) &amp;&amp; (protection_domain != NULL)) {</span>
1255       local_array-&gt;push(protection_domain);
1256       previous_protection_domain = protection_domain;
1257     }
1258 
1259     if (is_privileged) break;
1260   }
1261 
1262 
1263   // either all the domains on the stack were system domains, or
1264   // we had a privileged system domain
1265   if (local_array-&gt;is_empty()) {
1266     if (is_privileged &amp;&amp; privileged_context.is_null()) return NULL;
1267 
1268     oop result = java_security_AccessControlContext::create(objArrayHandle(), is_privileged, privileged_context, CHECK_NULL);
1269     return JNIHandles::make_local(env, result);
1270   }
1271 
1272   // the resource area must be registered in case of a gc
1273   RegisterArrayForGC ragc(thread, local_array);
1274   objArrayOop context = oopFactory::new_objArray(SystemDictionary::ProtectionDomain_klass(),
1275                                                  local_array-&gt;length(), CHECK_NULL);
1276   objArrayHandle h_context(thread, context);
1277   for (int index = 0; index &lt; local_array-&gt;length(); index++) {
1278     h_context-&gt;obj_at_put(index, local_array-&gt;at(index));
1279   }
1280 
1281   oop result = java_security_AccessControlContext::create(h_context, is_privileged, privileged_context, CHECK_NULL);
1282 
1283   return JNIHandles::make_local(env, result);
1284 JVM_END
1285 
1286 
<span class="line-modified">1287 JVM_QUICK_ENTRY(jboolean, JVM_IsArrayClass(JNIEnv *env, jclass cls))</span>
1288   JVMWrapper(&quot;JVM_IsArrayClass&quot;);
1289   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(cls));
1290   return (k != NULL) &amp;&amp; k-&gt;is_array_klass() ? true : false;
1291 JVM_END
1292 
1293 
<span class="line-modified">1294 JVM_QUICK_ENTRY(jboolean, JVM_IsPrimitiveClass(JNIEnv *env, jclass cls))</span>
1295   JVMWrapper(&quot;JVM_IsPrimitiveClass&quot;);
1296   oop mirror = JNIHandles::resolve_non_null(cls);
1297   return (jboolean) java_lang_Class::is_primitive(mirror);
1298 JVM_END
1299 
1300 
1301 JVM_ENTRY(jint, JVM_GetClassModifiers(JNIEnv *env, jclass cls))
1302   JVMWrapper(&quot;JVM_GetClassModifiers&quot;);
1303   if (java_lang_Class::is_primitive(JNIHandles::resolve_non_null(cls))) {
1304     // Primitive type
1305     return JVM_ACC_ABSTRACT | JVM_ACC_FINAL | JVM_ACC_PUBLIC;
1306   }
1307 
1308   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(cls));
1309   debug_only(int computed_modifiers = k-&gt;compute_modifier_flags(CHECK_0));
1310   assert(k-&gt;modifier_flags() == computed_modifiers, &quot;modifiers cache is OK&quot;);
1311   return k-&gt;modifier_flags();
1312 JVM_END
1313 
1314 
</pre>
<hr />
<pre>
1571   Method* method_ptr = jvm_get_method_common(method);
1572   methodHandle mh (THREAD, method_ptr);
1573   Handle reflected_method (THREAD, JNIHandles::resolve_non_null(method));
1574   const int num_params = mh-&gt;method_parameters_length();
1575 
1576   if (num_params &lt; 0) {
1577     // A -1 return value from method_parameters_length means there is no
1578     // parameter data.  Return null to indicate this to the reflection
1579     // API.
1580     assert(num_params == -1, &quot;num_params should be -1 if it is less than zero&quot;);
1581     return (jobjectArray)NULL;
1582   } else {
1583     // Otherwise, we return something up to reflection, even if it is
1584     // a zero-length array.  Why?  Because in some cases this can
1585     // trigger a MalformedParametersException.
1586 
1587     // make sure all the symbols are properly formatted
1588     for (int i = 0; i &lt; num_params; i++) {
1589       MethodParametersElement* params = mh-&gt;method_parameters_start();
1590       int index = params[i].name_cp_index;
<span class="line-modified">1591       bounds_check(mh-&gt;constants(), index, CHECK_NULL);</span>

1592 
1593       if (0 != index &amp;&amp; !mh-&gt;constants()-&gt;tag_at(index).is_utf8()) {
1594         THROW_MSG_0(vmSymbols::java_lang_IllegalArgumentException(),
1595                     &quot;Wrong type at constant pool index&quot;);
1596       }
1597 
1598     }
1599 
1600     objArrayOop result_oop = oopFactory::new_objArray(SystemDictionary::reflect_Parameter_klass(), num_params, CHECK_NULL);
1601     objArrayHandle result (THREAD, result_oop);
1602 
1603     for (int i = 0; i &lt; num_params; i++) {
1604       MethodParametersElement* params = mh-&gt;method_parameters_start();
1605       // For a 0 index, give a NULL symbol
1606       Symbol* sym = 0 != params[i].name_cp_index ?
1607         mh-&gt;constants()-&gt;symbol_at(params[i].name_cp_index) : NULL;
1608       int flags = params[i].flags;
1609       oop param = Reflection::new_parameter(reflected_method, i, sym,
1610                                             flags, CHECK_NULL);
1611       result-&gt;obj_at_put(i, param);
</pre>
<hr />
<pre>
1649   }
1650 
1651   objArrayOop r = oopFactory::new_objArray(SystemDictionary::reflect_Field_klass(), num_fields, CHECK_NULL);
1652   objArrayHandle result (THREAD, r);
1653 
1654   int out_idx = 0;
1655   fieldDescriptor fd;
1656   for (JavaFieldStream fs(k); !fs.done(); fs.next()) {
1657     if (!publicOnly || fs.access_flags().is_public()) {
1658       fd.reinitialize(k, fs.index());
1659       oop field = Reflection::new_field(&amp;fd, CHECK_NULL);
1660       result-&gt;obj_at_put(out_idx, field);
1661       ++out_idx;
1662     }
1663   }
1664   assert(out_idx == num_fields, &quot;just checking&quot;);
1665   return (jobjectArray) JNIHandles::make_local(env, result());
1666 }
1667 JVM_END
1668 
















































1669 static bool select_method(const methodHandle&amp; method, bool want_constructor) {
1670   if (want_constructor) {
1671     return (method-&gt;is_initializer() &amp;&amp; !method-&gt;is_static());
1672   } else {
1673     return  (!method-&gt;is_initializer() &amp;&amp; !method-&gt;is_overpass());
1674   }
1675 }
1676 
1677 static jobjectArray get_class_declared_methods_helper(
1678                                   JNIEnv *env,
1679                                   jclass ofClass, jboolean publicOnly,
1680                                   bool want_constructor,
1681                                   Klass* klass, TRAPS) {
1682 
1683   JvmtiVMObjectAllocEventCollector oam;
1684 
1685   // Exclude primitive types and array types
1686   if (java_lang_Class::is_primitive(JNIHandles::resolve_non_null(ofClass))
1687       || java_lang_Class::as_Klass(JNIHandles::resolve_non_null(ofClass))-&gt;is_array_klass()) {
1688     // Return empty array
</pre>
<hr />
<pre>
2242 // Verification ////////////////////////////////////////////////////////////////////////////////
2243 
2244 // Reflection for the verifier /////////////////////////////////////////////////////////////////
2245 
2246 // RedefineClasses support: bug 6214132 caused verification to fail.
2247 // All functions from this section should call the jvmtiThreadSate function:
2248 //   Klass* class_to_verify_considering_redefinition(Klass* klass).
2249 // The function returns a Klass* of the _scratch_class if the verifier
2250 // was invoked in the middle of the class redefinition.
2251 // Otherwise it returns its argument value which is the _the_class Klass*.
2252 // Please, refer to the description in the jvmtiThreadSate.hpp.
2253 
2254 JVM_ENTRY(const char*, JVM_GetClassNameUTF(JNIEnv *env, jclass cls))
2255   JVMWrapper(&quot;JVM_GetClassNameUTF&quot;);
2256   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(cls));
2257   k = JvmtiThreadState::class_to_verify_considering_redefinition(k, thread);
2258   return k-&gt;name()-&gt;as_utf8();
2259 JVM_END
2260 
2261 
<span class="line-modified">2262 JVM_QUICK_ENTRY(void, JVM_GetClassCPTypes(JNIEnv *env, jclass cls, unsigned char *types))</span>
2263   JVMWrapper(&quot;JVM_GetClassCPTypes&quot;);
2264   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(cls));
2265   k = JvmtiThreadState::class_to_verify_considering_redefinition(k, thread);
2266   // types will have length zero if this is not an InstanceKlass
2267   // (length is determined by call to JVM_GetClassCPEntriesCount)
2268   if (k-&gt;is_instance_klass()) {
2269     ConstantPool* cp = InstanceKlass::cast(k)-&gt;constants();
2270     for (int index = cp-&gt;length() - 1; index &gt;= 0; index--) {
2271       constantTag tag = cp-&gt;tag_at(index);
<span class="line-modified">2272       types[index] = (tag.is_unresolved_klass()) ? JVM_CONSTANT_Class : tag.value();</span>
2273     }
2274   }
2275 JVM_END
2276 
2277 
<span class="line-modified">2278 JVM_QUICK_ENTRY(jint, JVM_GetClassCPEntriesCount(JNIEnv *env, jclass cls))</span>
2279   JVMWrapper(&quot;JVM_GetClassCPEntriesCount&quot;);
2280   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(cls));
2281   k = JvmtiThreadState::class_to_verify_considering_redefinition(k, thread);
2282   return (!k-&gt;is_instance_klass()) ? 0 : InstanceKlass::cast(k)-&gt;constants()-&gt;length();
2283 JVM_END
2284 
2285 
<span class="line-modified">2286 JVM_QUICK_ENTRY(jint, JVM_GetClassFieldsCount(JNIEnv *env, jclass cls))</span>
2287   JVMWrapper(&quot;JVM_GetClassFieldsCount&quot;);
2288   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(cls));
2289   k = JvmtiThreadState::class_to_verify_considering_redefinition(k, thread);
2290   return (!k-&gt;is_instance_klass()) ? 0 : InstanceKlass::cast(k)-&gt;java_fields_count();
2291 JVM_END
2292 
2293 
<span class="line-modified">2294 JVM_QUICK_ENTRY(jint, JVM_GetClassMethodsCount(JNIEnv *env, jclass cls))</span>
2295   JVMWrapper(&quot;JVM_GetClassMethodsCount&quot;);
2296   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(cls));
2297   k = JvmtiThreadState::class_to_verify_considering_redefinition(k, thread);
2298   return (!k-&gt;is_instance_klass()) ? 0 : InstanceKlass::cast(k)-&gt;methods()-&gt;length();
2299 JVM_END
2300 
2301 
2302 // The following methods, used for the verifier, are never called with
2303 // array klasses, so a direct cast to InstanceKlass is safe.
2304 // Typically, these methods are called in a loop with bounds determined
2305 // by the results of JVM_GetClass{Fields,Methods}Count, which return
2306 // zero for arrays.
<span class="line-modified">2307 JVM_QUICK_ENTRY(void, JVM_GetMethodIxExceptionIndexes(JNIEnv *env, jclass cls, jint method_index, unsigned short *exceptions))</span>
2308   JVMWrapper(&quot;JVM_GetMethodIxExceptionIndexes&quot;);
2309   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(cls));
2310   k = JvmtiThreadState::class_to_verify_considering_redefinition(k, thread);
2311   Method* method = InstanceKlass::cast(k)-&gt;methods()-&gt;at(method_index);
2312   int length = method-&gt;checked_exceptions_length();
2313   if (length &gt; 0) {
2314     CheckedExceptionElement* table= method-&gt;checked_exceptions_start();
2315     for (int i = 0; i &lt; length; i++) {
2316       exceptions[i] = table[i].class_cp_index;
2317     }
2318   }
2319 JVM_END
2320 
2321 
<span class="line-modified">2322 JVM_QUICK_ENTRY(jint, JVM_GetMethodIxExceptionsCount(JNIEnv *env, jclass cls, jint method_index))</span>
2323   JVMWrapper(&quot;JVM_GetMethodIxExceptionsCount&quot;);
2324   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(cls));
2325   k = JvmtiThreadState::class_to_verify_considering_redefinition(k, thread);
2326   Method* method = InstanceKlass::cast(k)-&gt;methods()-&gt;at(method_index);
2327   return method-&gt;checked_exceptions_length();
2328 JVM_END
2329 
2330 
<span class="line-modified">2331 JVM_QUICK_ENTRY(void, JVM_GetMethodIxByteCode(JNIEnv *env, jclass cls, jint method_index, unsigned char *code))</span>
2332   JVMWrapper(&quot;JVM_GetMethodIxByteCode&quot;);
2333   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(cls));
2334   k = JvmtiThreadState::class_to_verify_considering_redefinition(k, thread);
2335   Method* method = InstanceKlass::cast(k)-&gt;methods()-&gt;at(method_index);
2336   memcpy(code, method-&gt;code_base(), method-&gt;code_size());
2337 JVM_END
2338 
2339 
<span class="line-modified">2340 JVM_QUICK_ENTRY(jint, JVM_GetMethodIxByteCodeLength(JNIEnv *env, jclass cls, jint method_index))</span>
2341   JVMWrapper(&quot;JVM_GetMethodIxByteCodeLength&quot;);
2342   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(cls));
2343   k = JvmtiThreadState::class_to_verify_considering_redefinition(k, thread);
2344   Method* method = InstanceKlass::cast(k)-&gt;methods()-&gt;at(method_index);
2345   return method-&gt;code_size();
2346 JVM_END
2347 
2348 
<span class="line-modified">2349 JVM_QUICK_ENTRY(void, JVM_GetMethodIxExceptionTableEntry(JNIEnv *env, jclass cls, jint method_index, jint entry_index, JVM_ExceptionTableEntryType *entry))</span>
2350   JVMWrapper(&quot;JVM_GetMethodIxExceptionTableEntry&quot;);
2351   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(cls));
2352   k = JvmtiThreadState::class_to_verify_considering_redefinition(k, thread);
2353   Method* method = InstanceKlass::cast(k)-&gt;methods()-&gt;at(method_index);
2354   ExceptionTable extable(method);
2355   entry-&gt;start_pc   = extable.start_pc(entry_index);
2356   entry-&gt;end_pc     = extable.end_pc(entry_index);
2357   entry-&gt;handler_pc = extable.handler_pc(entry_index);
2358   entry-&gt;catchType  = extable.catch_type_index(entry_index);
2359 JVM_END
2360 
2361 
<span class="line-modified">2362 JVM_QUICK_ENTRY(jint, JVM_GetMethodIxExceptionTableLength(JNIEnv *env, jclass cls, int method_index))</span>
2363   JVMWrapper(&quot;JVM_GetMethodIxExceptionTableLength&quot;);
2364   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(cls));
2365   k = JvmtiThreadState::class_to_verify_considering_redefinition(k, thread);
2366   Method* method = InstanceKlass::cast(k)-&gt;methods()-&gt;at(method_index);
2367   return method-&gt;exception_table_length();
2368 JVM_END
2369 
2370 
<span class="line-modified">2371 JVM_QUICK_ENTRY(jint, JVM_GetMethodIxModifiers(JNIEnv *env, jclass cls, int method_index))</span>
2372   JVMWrapper(&quot;JVM_GetMethodIxModifiers&quot;);
2373   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(cls));
2374   k = JvmtiThreadState::class_to_verify_considering_redefinition(k, thread);
2375   Method* method = InstanceKlass::cast(k)-&gt;methods()-&gt;at(method_index);
2376   return method-&gt;access_flags().as_int() &amp; JVM_RECOGNIZED_METHOD_MODIFIERS;
2377 JVM_END
2378 
2379 
<span class="line-modified">2380 JVM_QUICK_ENTRY(jint, JVM_GetFieldIxModifiers(JNIEnv *env, jclass cls, int field_index))</span>
2381   JVMWrapper(&quot;JVM_GetFieldIxModifiers&quot;);
2382   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(cls));
2383   k = JvmtiThreadState::class_to_verify_considering_redefinition(k, thread);
2384   return InstanceKlass::cast(k)-&gt;field_access_flags(field_index) &amp; JVM_RECOGNIZED_FIELD_MODIFIERS;
2385 JVM_END
2386 
2387 
<span class="line-modified">2388 JVM_QUICK_ENTRY(jint, JVM_GetMethodIxLocalsCount(JNIEnv *env, jclass cls, int method_index))</span>
2389   JVMWrapper(&quot;JVM_GetMethodIxLocalsCount&quot;);
2390   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(cls));
2391   k = JvmtiThreadState::class_to_verify_considering_redefinition(k, thread);
2392   Method* method = InstanceKlass::cast(k)-&gt;methods()-&gt;at(method_index);
2393   return method-&gt;max_locals();
2394 JVM_END
2395 
2396 
<span class="line-modified">2397 JVM_QUICK_ENTRY(jint, JVM_GetMethodIxArgsSize(JNIEnv *env, jclass cls, int method_index))</span>
2398   JVMWrapper(&quot;JVM_GetMethodIxArgsSize&quot;);
2399   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(cls));
2400   k = JvmtiThreadState::class_to_verify_considering_redefinition(k, thread);
2401   Method* method = InstanceKlass::cast(k)-&gt;methods()-&gt;at(method_index);
2402   return method-&gt;size_of_parameters();
2403 JVM_END
2404 
2405 
<span class="line-modified">2406 JVM_QUICK_ENTRY(jint, JVM_GetMethodIxMaxStack(JNIEnv *env, jclass cls, int method_index))</span>
2407   JVMWrapper(&quot;JVM_GetMethodIxMaxStack&quot;);
2408   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(cls));
2409   k = JvmtiThreadState::class_to_verify_considering_redefinition(k, thread);
2410   Method* method = InstanceKlass::cast(k)-&gt;methods()-&gt;at(method_index);
2411   return method-&gt;verifier_max_stack();
2412 JVM_END
2413 
2414 
<span class="line-modified">2415 JVM_QUICK_ENTRY(jboolean, JVM_IsConstructorIx(JNIEnv *env, jclass cls, int method_index))</span>
2416   JVMWrapper(&quot;JVM_IsConstructorIx&quot;);
2417   ResourceMark rm(THREAD);
2418   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(cls));
2419   k = JvmtiThreadState::class_to_verify_considering_redefinition(k, thread);
2420   Method* method = InstanceKlass::cast(k)-&gt;methods()-&gt;at(method_index);
2421   return method-&gt;name() == vmSymbols::object_initializer_name();
2422 JVM_END
2423 
2424 
<span class="line-modified">2425 JVM_QUICK_ENTRY(jboolean, JVM_IsVMGeneratedMethodIx(JNIEnv *env, jclass cls, int method_index))</span>
2426   JVMWrapper(&quot;JVM_IsVMGeneratedMethodIx&quot;);
2427   ResourceMark rm(THREAD);
2428   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(cls));
2429   k = JvmtiThreadState::class_to_verify_considering_redefinition(k, thread);
2430   Method* method = InstanceKlass::cast(k)-&gt;methods()-&gt;at(method_index);
2431   return method-&gt;is_overpass();
2432 JVM_END
2433 
2434 JVM_ENTRY(const char*, JVM_GetMethodIxNameUTF(JNIEnv *env, jclass cls, jint method_index))
2435   JVMWrapper(&quot;JVM_GetMethodIxIxUTF&quot;);
2436   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(cls));
2437   k = JvmtiThreadState::class_to_verify_considering_redefinition(k, thread);
2438   Method* method = InstanceKlass::cast(k)-&gt;methods()-&gt;at(method_index);
2439   return method-&gt;name()-&gt;as_utf8();
2440 JVM_END
2441 
2442 
2443 JVM_ENTRY(const char*, JVM_GetMethodIxSignatureUTF(JNIEnv *env, jclass cls, jint method_index))
2444   JVMWrapper(&quot;JVM_GetMethodIxSignatureUTF&quot;);
2445   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(cls));
</pre>
<hr />
<pre>
2582   switch (cp-&gt;tag_at(cp_index).value()) {
2583     case JVM_CONSTANT_Fieldref: {
2584       Symbol* name      = cp-&gt;uncached_name_ref_at(cp_index);
2585       Symbol* signature = cp-&gt;uncached_signature_ref_at(cp_index);
2586       InstanceKlass* ik = InstanceKlass::cast(k_called);
2587       for (JavaFieldStream fs(ik); !fs.done(); fs.next()) {
2588         if (fs.name() == name &amp;&amp; fs.signature() == signature) {
2589           return fs.access_flags().as_short() &amp; JVM_RECOGNIZED_FIELD_MODIFIERS;
2590         }
2591       }
2592       return -1;
2593     }
2594     default:
2595       fatal(&quot;JVM_GetCPFieldModifiers: illegal constant&quot;);
2596   }
2597   ShouldNotReachHere();
2598   return 0;
2599 JVM_END
2600 
2601 
<span class="line-modified">2602 JVM_QUICK_ENTRY(jint, JVM_GetCPMethodModifiers(JNIEnv *env, jclass cls, int cp_index, jclass called_cls))</span>
2603   JVMWrapper(&quot;JVM_GetCPMethodModifiers&quot;);
2604   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(cls));
2605   Klass* k_called = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(called_cls));
2606   k        = JvmtiThreadState::class_to_verify_considering_redefinition(k, thread);
2607   k_called = JvmtiThreadState::class_to_verify_considering_redefinition(k_called, thread);
2608   ConstantPool* cp = InstanceKlass::cast(k)-&gt;constants();
2609   switch (cp-&gt;tag_at(cp_index).value()) {
2610     case JVM_CONSTANT_Methodref:
2611     case JVM_CONSTANT_InterfaceMethodref: {
2612       Symbol* name      = cp-&gt;uncached_name_ref_at(cp_index);
2613       Symbol* signature = cp-&gt;uncached_signature_ref_at(cp_index);
2614       Array&lt;Method*&gt;* methods = InstanceKlass::cast(k_called)-&gt;methods();
2615       int methods_count = methods-&gt;length();
2616       for (int i = 0; i &lt; methods_count; i++) {
2617         Method* method = methods-&gt;at(i);
2618         if (method-&gt;name() == name &amp;&amp; method-&gt;signature() == signature) {
2619             return method-&gt;access_flags().as_int() &amp; JVM_RECOGNIZED_METHOD_MODIFIERS;
2620         }
2621       }
2622       return -1;
</pre>
<hr />
<pre>
2690     return vfprintf(f, fmt, args);
2691   }
2692 }
2693 
2694 ATTRIBUTE_PRINTF(1, 2)
2695 JNIEXPORT int jio_printf(const char *fmt, ...) {
2696   int len;
2697   va_list args;
2698   va_start(args, fmt);
2699   len = jio_vfprintf(defaultStream::output_stream(), fmt, args);
2700   va_end(args);
2701   return len;
2702 }
2703 
2704 // HotSpot specific jio method
2705 void jio_print(const char* s, size_t len) {
2706   // Try to make this function as atomic as possible.
2707   if (Arguments::vfprintf_hook() != NULL) {
2708     jio_fprintf(defaultStream::output_stream(), &quot;%.*s&quot;, (int)len, s);
2709   } else {
<span class="line-modified">2710     // Make an unused local variable to avoid warning from gcc 4.x compiler.</span>
2711     size_t count = ::write(defaultStream::output_fd(), s, (int)len);
2712   }
2713 }
2714 
2715 } // Extern C
2716 
2717 // java.lang.Thread //////////////////////////////////////////////////////////////////////////////
2718 
2719 // In most of the JVM thread support functions we need to access the
2720 // thread through a ThreadsListHandle to prevent it from exiting and
2721 // being reclaimed while we try to operate on it. The exceptions to this
2722 // rule are when operating on the current thread, or if the monitor of
2723 // the target java.lang.Thread is locked at the Java level - in both
2724 // cases the target cannot exit.
2725 
2726 static void thread_entry(JavaThread* thread, TRAPS) {
2727   HandleMark hm(THREAD);
2728   Handle obj(THREAD, thread-&gt;threadObj());
2729   JavaValue result(T_VOID);
2730   JavaCalls::call_virtual(&amp;result,
</pre>
<hr />
<pre>
2813 
2814 // JVM_Stop is implemented using a VM_Operation, so threads are forced to safepoints
2815 // before the quasi-asynchronous exception is delivered.  This is a little obtrusive,
2816 // but is thought to be reliable and simple. In the case, where the receiver is the
2817 // same thread as the sender, no VM_Operation is needed.
2818 JVM_ENTRY(void, JVM_StopThread(JNIEnv* env, jobject jthread, jobject throwable))
2819   JVMWrapper(&quot;JVM_StopThread&quot;);
2820 
2821   // A nested ThreadsListHandle will grab the Threads_lock so create
2822   // tlh before we resolve throwable.
2823   ThreadsListHandle tlh(thread);
2824   oop java_throwable = JNIHandles::resolve(throwable);
2825   if (java_throwable == NULL) {
2826     THROW(vmSymbols::java_lang_NullPointerException());
2827   }
2828   oop java_thread = NULL;
2829   JavaThread* receiver = NULL;
2830   bool is_alive = tlh.cv_internal_thread_to_JavaThread(jthread, &amp;receiver, &amp;java_thread);
2831   Events::log_exception(thread,
2832                         &quot;JVM_StopThread thread JavaThread &quot; INTPTR_FORMAT &quot; as oop &quot; INTPTR_FORMAT &quot; [exception &quot; INTPTR_FORMAT &quot;]&quot;,
<span class="line-modified">2833                         p2i(receiver), p2i((address)java_thread), p2i(throwable));</span>
2834 
2835   if (is_alive) {
2836     // jthread refers to a live JavaThread.
2837     if (thread == receiver) {
2838       // Exception is getting thrown at self so no VM_Operation needed.
2839       THROW_OOP(java_throwable);
2840     } else {
2841       // Use a VM_Operation to throw the exception.
2842       Thread::send_async_exception(java_thread, java_throwable);
2843     }
2844   } else {
2845     // Either:
2846     // - target thread has not been started before being stopped, or
2847     // - target thread already terminated
2848     // We could read the threadStatus to determine which case it is
2849     // but that is overkill as it doesn&#39;t matter. We must set the
2850     // stillborn flag for the first case, and if the thread has already
2851     // exited setting this flag has no effect.
2852     java_lang_Thread::set_stillborn(java_thread);
2853   }
2854 JVM_END
2855 
2856 
2857 JVM_ENTRY(jboolean, JVM_IsThreadAlive(JNIEnv* env, jobject jthread))
2858   JVMWrapper(&quot;JVM_IsThreadAlive&quot;);
2859 
2860   oop thread_oop = JNIHandles::resolve_non_null(jthread);
2861   return java_lang_Thread::is_alive(thread_oop);
2862 JVM_END
2863 
2864 
2865 JVM_ENTRY(void, JVM_SuspendThread(JNIEnv* env, jobject jthread))
2866   JVMWrapper(&quot;JVM_SuspendThread&quot;);
2867 
2868   ThreadsListHandle tlh(thread);
2869   JavaThread* receiver = NULL;
2870   bool is_alive = tlh.cv_internal_thread_to_JavaThread(jthread, &amp;receiver, NULL);
2871   if (is_alive) {
2872     // jthread refers to a live JavaThread.
2873     {
<span class="line-modified">2874       MutexLockerEx ml(receiver-&gt;SR_lock(), Mutex::_no_safepoint_check_flag);</span>
2875       if (receiver-&gt;is_external_suspend()) {
2876         // Don&#39;t allow nested external suspend requests. We can&#39;t return
2877         // an error from this interface so just ignore the problem.
2878         return;
2879       }
2880       if (receiver-&gt;is_exiting()) { // thread is in the process of exiting
2881         return;
2882       }
2883       receiver-&gt;set_external_suspend();
2884     }
2885 
2886     // java_suspend() will catch threads in the process of exiting
2887     // and will ignore them.
2888     receiver-&gt;java_suspend();
2889 
2890     // It would be nice to have the following assertion in all the
2891     // time, but it is possible for a racing resume request to have
2892     // resumed this thread right after we suspended it. Temporarily
2893     // enable this assertion if you are chasing a different kind of
2894     // bug.
</pre>
<hr />
<pre>
2951   JVMWrapper(&quot;JVM_Yield&quot;);
2952   if (os::dont_yield()) return;
2953   HOTSPOT_THREAD_YIELD();
2954   os::naked_yield();
2955 JVM_END
2956 
2957 static void post_thread_sleep_event(EventThreadSleep* event, jlong millis) {
2958   assert(event != NULL, &quot;invariant&quot;);
2959   assert(event-&gt;should_commit(), &quot;invariant&quot;);
2960   event-&gt;set_time(millis);
2961   event-&gt;commit();
2962 }
2963 
2964 JVM_ENTRY(void, JVM_Sleep(JNIEnv* env, jclass threadClass, jlong millis))
2965   JVMWrapper(&quot;JVM_Sleep&quot;);
2966 
2967   if (millis &lt; 0) {
2968     THROW_MSG(vmSymbols::java_lang_IllegalArgumentException(), &quot;timeout value is negative&quot;);
2969   }
2970 
<span class="line-modified">2971   if (Thread::is_interrupted (THREAD, true) &amp;&amp; !HAS_PENDING_EXCEPTION) {</span>
2972     THROW_MSG(vmSymbols::java_lang_InterruptedException(), &quot;sleep interrupted&quot;);
2973   }
2974 
2975   // Save current thread state and restore it at the end of this block.
2976   // And set new thread state to SLEEPING.
2977   JavaThreadSleepState jtss(thread);
2978 
2979   HOTSPOT_THREAD_SLEEP_BEGIN(millis);
2980   EventThreadSleep event;
2981 
2982   if (millis == 0) {
2983     os::naked_yield();
2984   } else {
2985     ThreadState old_state = thread-&gt;osthread()-&gt;get_state();
2986     thread-&gt;osthread()-&gt;set_state(SLEEPING);
<span class="line-modified">2987     if (os::sleep(thread, millis, true) == OS_INTRPT) {</span>
2988       // An asynchronous exception (e.g., ThreadDeathException) could have been thrown on
2989       // us while we were sleeping. We do not overwrite those.
2990       if (!HAS_PENDING_EXCEPTION) {
2991         if (event.should_commit()) {
2992           post_thread_sleep_event(&amp;event, millis);
2993         }
2994         HOTSPOT_THREAD_SLEEP_END(1);
2995 
2996         // TODO-FIXME: THROW_MSG returns which means we will not call set_state()
2997         // to properly restore the thread state.  That&#39;s likely wrong.
2998         THROW_MSG(vmSymbols::java_lang_InterruptedException(), &quot;sleep interrupted&quot;);
2999       }
3000     }
3001     thread-&gt;osthread()-&gt;set_state(old_state);
3002   }
3003   if (event.should_commit()) {
3004     post_thread_sleep_event(&amp;event, millis);
3005   }
3006   HOTSPOT_THREAD_SLEEP_END(0);
3007 JVM_END
3008 
3009 JVM_ENTRY(jobject, JVM_CurrentThread(JNIEnv* env, jclass threadClass))
3010   JVMWrapper(&quot;JVM_CurrentThread&quot;);
3011   oop jthread = thread-&gt;threadObj();
3012   assert (thread != NULL, &quot;no current thread!&quot;);
3013   return JNIHandles::make_local(env, jthread);
3014 JVM_END
3015 
<span class="line-removed">3016 </span>
<span class="line-removed">3017 JVM_ENTRY(jint, JVM_CountStackFrames(JNIEnv* env, jobject jthread))</span>
<span class="line-removed">3018   JVMWrapper(&quot;JVM_CountStackFrames&quot;);</span>
<span class="line-removed">3019 </span>
<span class="line-removed">3020   uint32_t debug_bits = 0;</span>
<span class="line-removed">3021   ThreadsListHandle tlh(thread);</span>
<span class="line-removed">3022   JavaThread* receiver = NULL;</span>
<span class="line-removed">3023   bool is_alive = tlh.cv_internal_thread_to_JavaThread(jthread, &amp;receiver, NULL);</span>
<span class="line-removed">3024   int count = 0;</span>
<span class="line-removed">3025   if (is_alive) {</span>
<span class="line-removed">3026     // jthread refers to a live JavaThread.</span>
<span class="line-removed">3027     if (receiver-&gt;is_thread_fully_suspended(true /* wait for suspend completion */, &amp;debug_bits)) {</span>
<span class="line-removed">3028       // Count all java activation, i.e., number of vframes.</span>
<span class="line-removed">3029       for (vframeStream vfst(receiver); !vfst.at_end(); vfst.next()) {</span>
<span class="line-removed">3030         // Native frames are not counted.</span>
<span class="line-removed">3031         if (!vfst.method()-&gt;is_native()) count++;</span>
<span class="line-removed">3032       }</span>
<span class="line-removed">3033     } else {</span>
<span class="line-removed">3034       THROW_MSG_0(vmSymbols::java_lang_IllegalThreadStateException(),</span>
<span class="line-removed">3035                   &quot;this thread is not suspended&quot;);</span>
<span class="line-removed">3036     }</span>
<span class="line-removed">3037   }</span>
<span class="line-removed">3038   // Implied else: if JavaThread is not alive simply return a count of 0.</span>
<span class="line-removed">3039 </span>
<span class="line-removed">3040   return count;</span>
<span class="line-removed">3041 JVM_END</span>
<span class="line-removed">3042 </span>
<span class="line-removed">3043 </span>
3044 JVM_ENTRY(void, JVM_Interrupt(JNIEnv* env, jobject jthread))
3045   JVMWrapper(&quot;JVM_Interrupt&quot;);
3046 
3047   ThreadsListHandle tlh(thread);
3048   JavaThread* receiver = NULL;
3049   bool is_alive = tlh.cv_internal_thread_to_JavaThread(jthread, &amp;receiver, NULL);
3050   if (is_alive) {
3051     // jthread refers to a live JavaThread.
<span class="line-modified">3052     Thread::interrupt(receiver);</span>
<span class="line-removed">3053   }</span>
<span class="line-removed">3054 JVM_END</span>
<span class="line-removed">3055 </span>
<span class="line-removed">3056 </span>
<span class="line-removed">3057 JVM_QUICK_ENTRY(jboolean, JVM_IsInterrupted(JNIEnv* env, jobject jthread, jboolean clear_interrupted))</span>
<span class="line-removed">3058   JVMWrapper(&quot;JVM_IsInterrupted&quot;);</span>
<span class="line-removed">3059 </span>
<span class="line-removed">3060   ThreadsListHandle tlh(thread);</span>
<span class="line-removed">3061   JavaThread* receiver = NULL;</span>
<span class="line-removed">3062   bool is_alive = tlh.cv_internal_thread_to_JavaThread(jthread, &amp;receiver, NULL);</span>
<span class="line-removed">3063   if (is_alive) {</span>
<span class="line-removed">3064     // jthread refers to a live JavaThread.</span>
<span class="line-removed">3065     return (jboolean) Thread::is_interrupted(receiver, clear_interrupted != 0);</span>
<span class="line-removed">3066   } else {</span>
<span class="line-removed">3067     return JNI_FALSE;</span>
3068   }
3069 JVM_END
3070 
3071 
3072 // Return true iff the current thread has locked the object passed in
3073 
3074 JVM_ENTRY(jboolean, JVM_HoldsLock(JNIEnv* env, jclass threadClass, jobject obj))
3075   JVMWrapper(&quot;JVM_HoldsLock&quot;);
3076   assert(THREAD-&gt;is_Java_thread(), &quot;sanity check&quot;);
3077   if (obj == NULL) {
3078     THROW_(vmSymbols::java_lang_NullPointerException(), JNI_FALSE);
3079   }
3080   Handle h_obj(THREAD, JNIHandles::resolve(obj));
3081   return ObjectSynchronizer::current_thread_holds_lock((JavaThread*)THREAD, h_obj);
3082 JVM_END
3083 
3084 
3085 JVM_ENTRY(void, JVM_DumpAllStacks(JNIEnv* env, jclass))
3086   JVMWrapper(&quot;JVM_DumpAllStacks&quot;);
3087   VM_PrintThreads op;
</pre>
<hr />
<pre>
3168   objArrayOop result = ClassLoader::get_system_packages(CHECK_NULL);
3169   return (jobjectArray) JNIHandles::make_local(result);
3170 JVM_END
3171 
3172 
3173 // java.lang.ref.Finalizer ///////////////////////////////////////////////////////////////
3174 
3175 JVM_ENTRY(jboolean, JVM_GetTsanEnabled(JNIEnv *env))
3176   JVMWrapper(&quot;JVM_GetTsanEnabled&quot;);
3177   TSAN_ONLY(return ThreadSanitizer;)
3178   NOT_TSAN(return JNI_FALSE;)
3179 JVM_END
3180 
3181 
3182 // java.lang.ref.Reference ///////////////////////////////////////////////////////////////
3183 
3184 
3185 JVM_ENTRY(jobject, JVM_GetAndClearReferencePendingList(JNIEnv* env))
3186   JVMWrapper(&quot;JVM_GetAndClearReferencePendingList&quot;);
3187 
<span class="line-modified">3188   MonitorLockerEx ml(Heap_lock);</span>
3189   oop ref = Universe::reference_pending_list();
3190   if (ref != NULL) {
3191     Universe::set_reference_pending_list(NULL);
3192   }
3193   return JNIHandles::make_local(env, ref);
3194 JVM_END
3195 
3196 JVM_ENTRY(jboolean, JVM_HasReferencePendingList(JNIEnv* env))
3197   JVMWrapper(&quot;JVM_HasReferencePendingList&quot;);
<span class="line-modified">3198   MonitorLockerEx ml(Heap_lock);</span>
3199   return Universe::has_reference_pending_list();
3200 JVM_END
3201 
3202 JVM_ENTRY(void, JVM_WaitForReferencePendingList(JNIEnv* env))
3203   JVMWrapper(&quot;JVM_WaitForReferencePendingList&quot;);
<span class="line-modified">3204   MonitorLockerEx ml(Heap_lock);</span>
3205   while (!Universe::has_reference_pending_list()) {
3206     ml.wait();
3207   }
3208 JVM_END
3209 
3210 
3211 // ObjectInputStream ///////////////////////////////////////////////////////////////
3212 
3213 // Return the first user-defined class loader up the execution stack, or null
3214 // if only code from the bootstrap or platform class loader is on the stack.
3215 
3216 JVM_ENTRY(jobject, JVM_LatestUserDefinedLoader(JNIEnv *env))
3217   for (vframeStream vfst(thread); !vfst.at_end(); vfst.next()) {
3218     vfst.skip_reflection_related_frames(); // Only needed for 1.4 reflection
3219     oop loader = vfst.method()-&gt;method_holder()-&gt;class_loader();
3220     if (loader != NULL &amp;&amp; !SystemDictionary::is_platform_class_loader(loader)) {
3221       return JNIHandles::make_local(env, loader);
3222     }
3223   }
3224   return NULL;
</pre>
<hr />
<pre>
3330   char ebuf[1024];
3331   void *load_result;
3332   {
3333     ThreadToNativeFromVM ttnfvm(thread);
3334     load_result = os::dll_load(name, ebuf, sizeof ebuf);
3335   }
3336   if (load_result == NULL) {
3337     char msg[1024];
3338     jio_snprintf(msg, sizeof msg, &quot;%s: %s&quot;, name, ebuf);
3339     // Since &#39;ebuf&#39; may contain a string encoded using
3340     // platform encoding scheme, we need to pass
3341     // Exceptions::unsafe_to_utf8 to the new_exception method
3342     // as the last argument. See bug 6367357.
3343     Handle h_exception =
3344       Exceptions::new_exception(thread,
3345                                 vmSymbols::java_lang_UnsatisfiedLinkError(),
3346                                 msg, Exceptions::unsafe_to_utf8);
3347 
3348     THROW_HANDLE_0(h_exception);
3349   }

3350   return load_result;
3351 JVM_END
3352 
3353 
3354 JVM_LEAF(void, JVM_UnloadLibrary(void* handle))
3355   JVMWrapper(&quot;JVM_UnloadLibrary&quot;);
3356   os::dll_unload(handle);

3357 JVM_END
3358 
3359 
3360 JVM_LEAF(void*, JVM_FindLibraryEntry(void* handle, const char* name))
3361   JVMWrapper(&quot;JVM_FindLibraryEntry&quot;);
<span class="line-modified">3362   return os::dll_lookup(handle, name);</span>




3363 JVM_END
3364 
3365 
3366 // JNI version ///////////////////////////////////////////////////////////////////////////////
3367 
3368 JVM_LEAF(jboolean, JVM_IsSupportedJNIVersion(jint version))
3369   JVMWrapper(&quot;JVM_IsSupportedJNIVersion&quot;);
3370   return Threads::is_supported_jni_version_including_1_1(version);
3371 JVM_END
3372 
3373 
3374 // String support ///////////////////////////////////////////////////////////////////////////
3375 
3376 JVM_ENTRY(jstring, JVM_InternString(JNIEnv *env, jstring str))
3377   JVMWrapper(&quot;JVM_InternString&quot;);
3378   JvmtiVMObjectAllocEventCollector oam;
3379   if (str == NULL) return NULL;
3380   oop string = JNIHandles::resolve_non_null(str);
3381   oop result = StringTable::intern(string, CHECK_NULL);
3382   return (jstring) JNIHandles::make_local(env, result);
3383 JVM_END
3384 
3385 
<span class="line-modified">3386 // Raw monitor support //////////////////////////////////////////////////////////////////////</span>
3387 
<span class="line-modified">3388 // The lock routine below calls lock_without_safepoint_check in order to get a raw lock</span>
<span class="line-modified">3389 // without interfering with the safepoint mechanism. The routines are not JVM_LEAF because</span>
<span class="line-modified">3390 // they might be called by non-java threads. The JVM_LEAF installs a NoHandleMark check</span>
<span class="line-modified">3391 // that only works with java threads.</span>

3392 
3393 
3394 JNIEXPORT void* JNICALL JVM_RawMonitorCreate(void) {
3395   VM_Exit::block_if_vm_exited();
3396   JVMWrapper(&quot;JVM_RawMonitorCreate&quot;);
<span class="line-modified">3397   void *mon = new Mutex(Mutex::native, &quot;JVM_RawMonitorCreate&quot;);</span>
3398   TSAN_RUNTIME_ONLY(TSAN_RAW_LOCK_CREATE(mon));
3399   return mon;
3400 }
3401 
3402 
3403 JNIEXPORT void JNICALL  JVM_RawMonitorDestroy(void *mon) {
3404   VM_Exit::block_if_vm_exited();
3405   JVMWrapper(&quot;JVM_RawMonitorDestroy&quot;);
3406   TSAN_RUNTIME_ONLY(TSAN_RAW_LOCK_DESTROY(mon));
<span class="line-modified">3407   delete ((Mutex*) mon);</span>
3408 }
3409 
3410 
3411 JNIEXPORT jint JNICALL JVM_RawMonitorEnter(void *mon) {
3412   VM_Exit::block_if_vm_exited();
3413   JVMWrapper(&quot;JVM_RawMonitorEnter&quot;);
<span class="line-modified">3414   ((Mutex*) mon)-&gt;jvm_raw_lock();</span>
3415   TSAN_RUNTIME_ONLY(TSAN_RAW_LOCK_ACQUIRED(mon));
3416   return 0;
3417 }
3418 
3419 
3420 JNIEXPORT void JNICALL JVM_RawMonitorExit(void *mon) {
3421   VM_Exit::block_if_vm_exited();
3422   JVMWrapper(&quot;JVM_RawMonitorExit&quot;);
3423   TSAN_RUNTIME_ONLY(TSAN_RAW_LOCK_RELEASED(mon));
<span class="line-modified">3424   ((Mutex*) mon)-&gt;jvm_raw_unlock();</span>
3425 }
3426 
3427 
3428 // Shared JNI/JVM entry points //////////////////////////////////////////////////////////////
3429 
3430 jclass find_class_from_class_loader(JNIEnv* env, Symbol* name, jboolean init,
3431                                     Handle loader, Handle protection_domain,
3432                                     jboolean throwError, TRAPS) {
3433   // Security Note:
3434   //   The Java level wrapper will perform the necessary security check allowing
3435   //   us to pass the NULL as the initiating class loader.  The VM is responsible for
3436   //   the checkPackageAccess relative to the initiating class loader via the
3437   //   protection_domain. The protection_domain is passed as NULL by the java code
3438   //   if there is no security manager in 3-arg Class.forName().
3439   Klass* klass = SystemDictionary::resolve_or_fail(name, loader, protection_domain, throwError != 0, CHECK_NULL);
3440 
3441   // Check if we should initialize the class
3442   if (init &amp;&amp; klass-&gt;is_instance_klass()) {
3443     klass-&gt;initialize(CHECK_NULL);
3444   }
</pre>
<hr />
<pre>
3608   objArrayHandle dest(THREAD, dest_o);
3609   Klass* enc_k = ik-&gt;constants()-&gt;klass_at(encl_method_class_idx, CHECK_NULL);
3610   dest-&gt;obj_at_put(0, enc_k-&gt;java_mirror());
3611   int encl_method_method_idx = ik-&gt;enclosing_method_method_index();
3612   if (encl_method_method_idx != 0) {
3613     Symbol* sym = ik-&gt;constants()-&gt;symbol_at(
3614                         extract_low_short_from_int(
3615                           ik-&gt;constants()-&gt;name_and_type_at(encl_method_method_idx)));
3616     Handle str = java_lang_String::create_from_symbol(sym, CHECK_NULL);
3617     dest-&gt;obj_at_put(1, str());
3618     sym = ik-&gt;constants()-&gt;symbol_at(
3619               extract_high_short_from_int(
3620                 ik-&gt;constants()-&gt;name_and_type_at(encl_method_method_idx)));
3621     str = java_lang_String::create_from_symbol(sym, CHECK_NULL);
3622     dest-&gt;obj_at_put(2, str());
3623   }
3624   return (jobjectArray) JNIHandles::make_local(dest());
3625 }
3626 JVM_END
3627 
<span class="line-removed">3628 JVM_ENTRY(void, JVM_GetVersionInfo(JNIEnv* env, jvm_version_info* info, size_t info_size))</span>
<span class="line-removed">3629 {</span>
<span class="line-removed">3630   memset(info, 0, info_size);</span>
<span class="line-removed">3631 </span>
<span class="line-removed">3632   info-&gt;jvm_version = VM_Version::jvm_version();</span>
<span class="line-removed">3633   info-&gt;patch_version = VM_Version::vm_patch_version();</span>
<span class="line-removed">3634 </span>
<span class="line-removed">3635   // when we add a new capability in the jvm_version_info struct, we should also</span>
<span class="line-removed">3636   // consider to expose this new capability in the sun.rt.jvmCapabilities jvmstat</span>
<span class="line-removed">3637   // counter defined in runtimeService.cpp.</span>
<span class="line-removed">3638   info-&gt;is_attach_supported = AttachListener::is_attach_supported();</span>
<span class="line-removed">3639 }</span>
<span class="line-removed">3640 JVM_END</span>
<span class="line-removed">3641 </span>
3642 // Returns an array of java.lang.String objects containing the input arguments to the VM.
3643 JVM_ENTRY(jobjectArray, JVM_GetVmArguments(JNIEnv *env))
3644   ResourceMark rm(THREAD);
3645 
3646   if (Arguments::num_jvm_args() == 0 &amp;&amp; Arguments::num_jvm_flags() == 0) {
3647     return NULL;
3648   }
3649 
3650   char** vm_flags = Arguments::jvm_flags_array();
3651   char** vm_args = Arguments::jvm_args_array();
3652   int num_flags = Arguments::num_jvm_flags();
3653   int num_args = Arguments::num_jvm_args();
3654 
3655   InstanceKlass* ik = SystemDictionary::String_klass();
3656   objArrayOop r = oopFactory::new_objArray(ik, num_args + num_flags, CHECK_NULL);
3657   objArrayHandle result_h(THREAD, r);
3658 
3659   int index = 0;
3660   for (int j = 0; j &lt; num_flags; j++, index++) {
3661     Handle h = java_lang_String::create_from_platform_dependent_str(vm_flags[j], CHECK_NULL);
</pre>
</td>
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 1997, 2020, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include &quot;precompiled.hpp&quot;
  26 #include &quot;jvm.h&quot;
  27 #include &quot;classfile/classFileStream.hpp&quot;
  28 #include &quot;classfile/classLoader.hpp&quot;
  29 #include &quot;classfile/classLoaderData.inline.hpp&quot;
  30 #include &quot;classfile/javaAssertions.hpp&quot;
  31 #include &quot;classfile/javaClasses.inline.hpp&quot;
  32 #include &quot;classfile/moduleEntry.hpp&quot;
  33 #include &quot;classfile/modules.hpp&quot;
  34 #include &quot;classfile/packageEntry.hpp&quot;
  35 #include &quot;classfile/stringTable.hpp&quot;
<span class="line-added">  36 #include &quot;classfile/symbolTable.hpp&quot;</span>
  37 #include &quot;classfile/systemDictionary.hpp&quot;
  38 #include &quot;classfile/vmSymbols.hpp&quot;
  39 #include &quot;gc/shared/collectedHeap.inline.hpp&quot;
  40 #include &quot;interpreter/bytecode.hpp&quot;
<span class="line-added">  41 #include &quot;interpreter/bytecodeUtils.hpp&quot;</span>
  42 #include &quot;jfr/jfrEvents.hpp&quot;
  43 #include &quot;logging/log.hpp&quot;
  44 #include &quot;memory/heapShared.hpp&quot;
  45 #include &quot;memory/oopFactory.hpp&quot;
  46 #include &quot;memory/referenceType.hpp&quot;
  47 #include &quot;memory/resourceArea.hpp&quot;
  48 #include &quot;memory/universe.hpp&quot;
  49 #include &quot;oops/access.inline.hpp&quot;
  50 #include &quot;oops/constantPool.hpp&quot;
<span class="line-modified">  51 #include &quot;oops/fieldStreams.inline.hpp&quot;</span>
  52 #include &quot;oops/instanceKlass.hpp&quot;
  53 #include &quot;oops/method.hpp&quot;
<span class="line-added">  54 #include &quot;oops/recordComponent.hpp&quot;</span>
  55 #include &quot;oops/objArrayKlass.hpp&quot;
  56 #include &quot;oops/objArrayOop.inline.hpp&quot;
  57 #include &quot;oops/oop.inline.hpp&quot;
  58 #include &quot;prims/jvm_misc.hpp&quot;
  59 #include &quot;prims/jvmtiExport.hpp&quot;
  60 #include &quot;prims/jvmtiThreadState.hpp&quot;
  61 #include &quot;prims/nativeLookup.hpp&quot;
  62 #include &quot;prims/stackwalk.hpp&quot;
  63 #include &quot;runtime/arguments.hpp&quot;
  64 #include &quot;runtime/atomic.hpp&quot;
  65 #include &quot;runtime/handles.inline.hpp&quot;
  66 #include &quot;runtime/init.hpp&quot;
  67 #include &quot;runtime/interfaceSupport.inline.hpp&quot;
  68 #include &quot;runtime/deoptimization.hpp&quot;
<span class="line-added">  69 #include &quot;runtime/handshake.hpp&quot;</span>
  70 #include &quot;runtime/java.hpp&quot;
  71 #include &quot;runtime/javaCalls.hpp&quot;
  72 #include &quot;runtime/jfieldIDWorkaround.hpp&quot;
  73 #include &quot;runtime/jniHandles.inline.hpp&quot;

  74 #include &quot;runtime/os.inline.hpp&quot;
  75 #include &quot;runtime/perfData.hpp&quot;
  76 #include &quot;runtime/reflection.hpp&quot;
  77 #include &quot;runtime/thread.inline.hpp&quot;
  78 #include &quot;runtime/threadSMR.hpp&quot;
  79 #include &quot;runtime/vframe.inline.hpp&quot;
  80 #include &quot;runtime/vmOperations.hpp&quot;
  81 #include &quot;runtime/vm_version.hpp&quot;
  82 #include &quot;services/attachListener.hpp&quot;
  83 #include &quot;services/management.hpp&quot;
  84 #include &quot;services/threadService.hpp&quot;
  85 #if INCLUDE_TSAN
  86 #include &quot;tsan/tsan.hpp&quot;
  87 #endif  // INCLUDE_TSAN
  88 #include &quot;utilities/copy.hpp&quot;
  89 #include &quot;utilities/defaultStream.hpp&quot;
  90 #include &quot;utilities/dtrace.hpp&quot;
  91 #include &quot;utilities/events.hpp&quot;
  92 #include &quot;utilities/histogram.hpp&quot;
  93 #include &quot;utilities/macros.hpp&quot;
</pre>
<hr />
<pre>
 126 
 127 
 128   The solution is to keep the oop declaration BELOW the ctor or function
 129   call that might cause a GC, do another resolve to reassign the oop, or
 130   consider use of a Handle instead of an oop so there is immunity from object
 131   motion. But note that the &quot;QUICK&quot; entries below do not have a handlemark
 132   and thus can only support use of handles passed in.
 133 */
 134 
 135 static void trace_class_resolution_impl(Klass* to_class, TRAPS) {
 136   ResourceMark rm;
 137   int line_number = -1;
 138   const char * source_file = NULL;
 139   const char * trace = &quot;explicit&quot;;
 140   InstanceKlass* caller = NULL;
 141   JavaThread* jthread = JavaThread::current();
 142   if (jthread-&gt;has_last_Java_frame()) {
 143     vframeStream vfst(jthread);
 144 
 145     // scan up the stack skipping ClassLoader, AccessController and PrivilegedAction frames
<span class="line-modified"> 146     TempNewSymbol access_controller = SymbolTable::new_symbol(&quot;java/security/AccessController&quot;);</span>
 147     Klass* access_controller_klass = SystemDictionary::resolve_or_fail(access_controller, false, CHECK);
<span class="line-modified"> 148     TempNewSymbol privileged_action = SymbolTable::new_symbol(&quot;java/security/PrivilegedAction&quot;);</span>
 149     Klass* privileged_action_klass = SystemDictionary::resolve_or_fail(privileged_action, false, CHECK);
 150 
 151     Method* last_caller = NULL;
 152 
 153     while (!vfst.at_end()) {
 154       Method* m = vfst.method();
 155       if (!vfst.method()-&gt;method_holder()-&gt;is_subclass_of(SystemDictionary::ClassLoader_klass())&amp;&amp;
 156           !vfst.method()-&gt;method_holder()-&gt;is_subclass_of(access_controller_klass) &amp;&amp;
 157           !vfst.method()-&gt;method_holder()-&gt;is_subclass_of(privileged_action_klass)) {
 158         break;
 159       }
 160       last_caller = m;
 161       vfst.next();
 162     }
 163     // if this is called from Class.forName0 and that is called from Class.forName,
 164     // then print the caller of Class.forName.  If this is Class.loadClass, then print
 165     // that caller, otherwise keep quiet since this should be picked up elsewhere.
 166     bool found_it = false;
 167     if (!vfst.at_end() &amp;&amp;
 168         vfst.method()-&gt;method_holder()-&gt;name() == vmSymbols::java_lang_Class() &amp;&amp;
</pre>
<hr />
<pre>
 219   if (HAS_PENDING_EXCEPTION) {
 220     CLEAR_PENDING_EXCEPTION;
 221   }
 222 }
 223 
 224 // Wrapper to trace JVM functions
 225 
 226 #ifdef ASSERT
 227   Histogram* JVMHistogram;
 228   volatile int JVMHistogram_lock = 0;
 229 
 230   class JVMHistogramElement : public HistogramElement {
 231     public:
 232      JVMHistogramElement(const char* name);
 233   };
 234 
 235   JVMHistogramElement::JVMHistogramElement(const char* elementName) {
 236     _name = elementName;
 237     uintx count = 0;
 238 
<span class="line-modified"> 239     while (Atomic::cmpxchg(&amp;JVMHistogram_lock, 0, 1) != 0) {</span>
<span class="line-modified"> 240       while (Atomic::load_acquire(&amp;JVMHistogram_lock) != 0) {</span>
 241         count +=1;
 242         if ( (WarnOnStalledSpinLock &gt; 0)
 243           &amp;&amp; (count % WarnOnStalledSpinLock == 0)) {
 244           warning(&quot;JVMHistogram_lock seems to be stalled&quot;);
 245         }
 246       }
 247      }
 248 
 249     if(JVMHistogram == NULL)
 250       JVMHistogram = new Histogram(&quot;JVM Call Counts&quot;,100);
 251 
 252     JVMHistogram-&gt;add_element(this);
 253     Atomic::dec(&amp;JVMHistogram_lock);
 254   }
 255 
 256   #define JVMCountWrapper(arg) \
 257       static JVMHistogramElement* e = new JVMHistogramElement(arg); \
 258       if (e != NULL) e-&gt;increment_count();  // Due to bug in VC++, we need a NULL check here eventhough it should never happen!
 259 
 260   #define JVMWrapper(arg) JVMCountWrapper(arg);
</pre>
<hr />
<pre>
 497   JVMWrapper(&quot;JVM_MaxObjectInspectionAge&quot;);
 498   return Universe::heap()-&gt;millis_since_last_gc();
 499 JVM_END
 500 
 501 
 502 static inline jlong convert_size_t_to_jlong(size_t val) {
 503   // In the 64-bit vm, a size_t can overflow a jlong (which is signed).
 504   NOT_LP64 (return (jlong)val;)
 505   LP64_ONLY(return (jlong)MIN2(val, (size_t)max_jlong);)
 506 }
 507 
 508 JVM_ENTRY_NO_ENV(jlong, JVM_TotalMemory(void))
 509   JVMWrapper(&quot;JVM_TotalMemory&quot;);
 510   size_t n = Universe::heap()-&gt;capacity();
 511   return convert_size_t_to_jlong(n);
 512 JVM_END
 513 
 514 
 515 JVM_ENTRY_NO_ENV(jlong, JVM_FreeMemory(void))
 516   JVMWrapper(&quot;JVM_FreeMemory&quot;);
<span class="line-modified"> 517   size_t n = Universe::heap()-&gt;unused();</span>





 518   return convert_size_t_to_jlong(n);
 519 JVM_END
 520 
 521 
 522 JVM_ENTRY_NO_ENV(jlong, JVM_MaxMemory(void))
 523   JVMWrapper(&quot;JVM_MaxMemory&quot;);
 524   size_t n = Universe::heap()-&gt;max_capacity();
 525   return convert_size_t_to_jlong(n);
 526 JVM_END
 527 
 528 
 529 JVM_ENTRY_NO_ENV(jint, JVM_ActiveProcessorCount(void))
 530   JVMWrapper(&quot;JVM_ActiveProcessorCount&quot;);
 531   return os::active_processor_count();
 532 JVM_END
 533 
 534 
 535 
 536 // java.lang.Throwable //////////////////////////////////////////////////////
 537 

 538 JVM_ENTRY(void, JVM_FillInStackTrace(JNIEnv *env, jobject receiver))
 539   JVMWrapper(&quot;JVM_FillInStackTrace&quot;);
 540   Handle exception(thread, JNIHandles::resolve_non_null(receiver));
 541   java_lang_Throwable::fill_in_stack_trace(exception);
 542 JVM_END
 543 
<span class="line-added"> 544 // java.lang.NullPointerException ///////////////////////////////////////////</span>
<span class="line-added"> 545 </span>
<span class="line-added"> 546 JVM_ENTRY(jstring, JVM_GetExtendedNPEMessage(JNIEnv *env, jthrowable throwable))</span>
<span class="line-added"> 547   if (!ShowCodeDetailsInExceptionMessages) return NULL;</span>
<span class="line-added"> 548 </span>
<span class="line-added"> 549   oop exc = JNIHandles::resolve_non_null(throwable);</span>
<span class="line-added"> 550 </span>
<span class="line-added"> 551   Method* method;</span>
<span class="line-added"> 552   int bci;</span>
<span class="line-added"> 553   if (!java_lang_Throwable::get_top_method_and_bci(exc, &amp;method, &amp;bci)) {</span>
<span class="line-added"> 554     return NULL;</span>
<span class="line-added"> 555   }</span>
<span class="line-added"> 556   if (method-&gt;is_native()) {</span>
<span class="line-added"> 557     return NULL;</span>
<span class="line-added"> 558   }</span>
<span class="line-added"> 559 </span>
<span class="line-added"> 560   stringStream ss;</span>
<span class="line-added"> 561   bool ok = BytecodeUtils::get_NPE_message_at(&amp;ss, method, bci);</span>
<span class="line-added"> 562   if (ok) {</span>
<span class="line-added"> 563     oop result = java_lang_String::create_oop_from_str(ss.base(), CHECK_0);</span>
<span class="line-added"> 564     return (jstring) JNIHandles::make_local(env, result);</span>
<span class="line-added"> 565   } else {</span>
<span class="line-added"> 566     return NULL;</span>
<span class="line-added"> 567   }</span>
<span class="line-added"> 568 JVM_END</span>
 569 
 570 // java.lang.StackTraceElement //////////////////////////////////////////////
 571 
 572 
 573 JVM_ENTRY(void, JVM_InitStackTraceElementArray(JNIEnv *env, jobjectArray elements, jobject throwable))
 574   JVMWrapper(&quot;JVM_InitStackTraceElementArray&quot;);
 575   Handle exception(THREAD, JNIHandles::resolve(throwable));
 576   objArrayOop st = objArrayOop(JNIHandles::resolve(elements));
 577   objArrayHandle stack_trace(THREAD, st);
 578   // Fill in the allocated stack trace
 579   java_lang_Throwable::get_stack_trace_elements(exception, stack_trace, CHECK);
 580 JVM_END
 581 
 582 
 583 JVM_ENTRY(void, JVM_InitStackTraceElement(JNIEnv* env, jobject element, jobject stackFrameInfo))
 584   JVMWrapper(&quot;JVM_InitStackTraceElement&quot;);
 585   Handle stack_frame_info(THREAD, JNIHandles::resolve_non_null(stackFrameInfo));
 586   Handle stack_trace_element(THREAD, JNIHandles::resolve_non_null(element));
 587   java_lang_StackFrameInfo::to_stack_trace_element(stack_frame_info, stack_trace_element, THREAD);
 588 JVM_END
</pre>
<hr />
<pre>
 773       if (!m-&gt;caller_sensitive()) {
 774         THROW_MSG_NULL(vmSymbols::java_lang_InternalError(), err_msg(&quot;CallerSensitive annotation expected at frame %d&quot;, n));
 775       }
 776       break;
 777     default:
 778       if (!m-&gt;is_ignored_by_security_stack_walk()) {
 779         // We have reached the desired frame; return the holder class.
 780         return (jclass) JNIHandles::make_local(env, m-&gt;method_holder()-&gt;java_mirror());
 781       }
 782       break;
 783     }
 784   }
 785   return NULL;
 786 JVM_END
 787 
 788 
 789 JVM_ENTRY(jclass, JVM_FindPrimitiveClass(JNIEnv* env, const char* utf))
 790   JVMWrapper(&quot;JVM_FindPrimitiveClass&quot;);
 791   oop mirror = NULL;
 792   BasicType t = name2type(utf);
<span class="line-modified"> 793   if (t != T_ILLEGAL &amp;&amp; !is_reference_type(t)) {</span>
 794     mirror = Universe::java_mirror(t);
 795   }
 796   if (mirror == NULL) {
 797     THROW_MSG_0(vmSymbols::java_lang_ClassNotFoundException(), (char*) utf);
 798   } else {
 799     return (jclass) JNIHandles::make_local(env, mirror);
 800   }
 801 JVM_END
 802 
 803 
 804 // Returns a class loaded by the bootstrap class loader; or null
 805 // if not found.  ClassNotFoundException is not thrown.
 806 // FindClassFromBootLoader is exported to the launcher for windows.
 807 JVM_ENTRY(jclass, JVM_FindClassFromBootLoader(JNIEnv* env,
 808                                               const char* name))
 809   JVMWrapper(&quot;JVM_FindClassFromBootLoader&quot;);
 810 
 811   // Java libraries should ensure that name is never null...
 812   if (name == NULL || (int)strlen(name) &gt; Symbol::max_length()) {
 813     // It&#39;s impossible to create this class;  the name cannot fit
 814     // into the constant pool.
 815     return NULL;
 816   }
 817 
<span class="line-modified"> 818   TempNewSymbol h_name = SymbolTable::new_symbol(name);</span>
 819   Klass* k = SystemDictionary::resolve_or_null(h_name, CHECK_NULL);
 820   if (k == NULL) {
 821     return NULL;
 822   }
 823 
 824   if (log_is_enabled(Debug, class, resolve)) {
 825     trace_class_resolution(k);
 826   }
 827   return (jclass) JNIHandles::make_local(env, k-&gt;java_mirror());
 828 JVM_END
 829 
 830 // Find a class with this name in this loader, using the caller&#39;s protection domain.
 831 JVM_ENTRY(jclass, JVM_FindClassFromCaller(JNIEnv* env, const char* name,
 832                                           jboolean init, jobject loader,
 833                                           jclass caller))
 834   JVMWrapper(&quot;JVM_FindClassFromCaller throws ClassNotFoundException&quot;);
 835   // Java libraries should ensure that name is never null...
 836   if (name == NULL || (int)strlen(name) &gt; Symbol::max_length()) {
 837     // It&#39;s impossible to create this class;  the name cannot fit
 838     // into the constant pool.
 839     THROW_MSG_0(vmSymbols::java_lang_ClassNotFoundException(), name);
 840   }
 841 
<span class="line-modified"> 842   TempNewSymbol h_name = SymbolTable::new_symbol(name);</span>
 843 
 844   oop loader_oop = JNIHandles::resolve(loader);
 845   oop from_class = JNIHandles::resolve(caller);
 846   oop protection_domain = NULL;
 847   // If loader is null, shouldn&#39;t call ClassLoader.checkPackageAccess; otherwise get
 848   // NPE. Put it in another way, the bootstrap class loader has all permission and
 849   // thus no checkPackageAccess equivalence in the VM class loader.
 850   // The caller is also passed as NULL by the java code if there is no security
 851   // manager to avoid the performance cost of getting the calling class.
 852   if (from_class != NULL &amp;&amp; loader_oop != NULL) {
 853     protection_domain = java_lang_Class::as_Klass(from_class)-&gt;protection_domain();
 854   }
 855 
 856   Handle h_loader(THREAD, loader_oop);
 857   Handle h_prot(THREAD, protection_domain);
 858   jclass result = find_class_from_class_loader(env, h_name, init, h_loader,
 859                                                h_prot, false, THREAD);
 860 
 861   if (log_is_enabled(Debug, class, resolve) &amp;&amp; result != NULL) {
 862     trace_class_resolution(java_lang_Class::as_Klass(JNIHandles::resolve_non_null(result)));
</pre>
<hr />
<pre>
 864   return result;
 865 JVM_END
 866 
 867 // Currently only called from the old verifier.
 868 JVM_ENTRY(jclass, JVM_FindClassFromClass(JNIEnv *env, const char *name,
 869                                          jboolean init, jclass from))
 870   JVMWrapper(&quot;JVM_FindClassFromClass&quot;);
 871   if (name == NULL) {
 872     THROW_MSG_0(vmSymbols::java_lang_NoClassDefFoundError(), &quot;No class name given&quot;);
 873   }
 874   if ((int)strlen(name) &gt; Symbol::max_length()) {
 875     // It&#39;s impossible to create this class;  the name cannot fit
 876     // into the constant pool.
 877     Exceptions::fthrow(THREAD_AND_LOCATION,
 878                        vmSymbols::java_lang_NoClassDefFoundError(),
 879                        &quot;Class name exceeds maximum length of %d: %s&quot;,
 880                        Symbol::max_length(),
 881                        name);
 882     return 0;
 883   }
<span class="line-modified"> 884   TempNewSymbol h_name = SymbolTable::new_symbol(name);</span>
 885   oop from_class_oop = JNIHandles::resolve(from);
 886   Klass* from_class = (from_class_oop == NULL)
 887                            ? (Klass*)NULL
 888                            : java_lang_Class::as_Klass(from_class_oop);
 889   oop class_loader = NULL;
 890   oop protection_domain = NULL;
 891   if (from_class != NULL) {
 892     class_loader = from_class-&gt;class_loader();
 893     protection_domain = from_class-&gt;protection_domain();
 894   }
 895   Handle h_loader(THREAD, class_loader);
 896   Handle h_prot  (THREAD, protection_domain);
 897   jclass result = find_class_from_class_loader(env, h_name, init, h_loader,
 898                                                h_prot, true, thread);
 899 
 900   if (log_is_enabled(Debug, class, resolve) &amp;&amp; result != NULL) {
 901     // this function is generally only used for class loading during verification.
 902     ResourceMark rm;
 903     oop from_mirror = JNIHandles::resolve_non_null(from);
 904     Klass* from_class = java_lang_Class::as_Klass(from_mirror);
</pre>
<hr />
<pre>
 945 
 946   if (UsePerfData) {
 947     ClassLoader::perf_app_classfile_bytes_read()-&gt;inc(len);
 948   }
 949 
 950   // Since exceptions can be thrown, class initialization can take place
 951   // if name is NULL no check for class name in .class stream has to be made.
 952   TempNewSymbol class_name = NULL;
 953   if (name != NULL) {
 954     const int str_len = (int)strlen(name);
 955     if (str_len &gt; Symbol::max_length()) {
 956       // It&#39;s impossible to create this class;  the name cannot fit
 957       // into the constant pool.
 958       Exceptions::fthrow(THREAD_AND_LOCATION,
 959                          vmSymbols::java_lang_NoClassDefFoundError(),
 960                          &quot;Class name exceeds maximum length of %d: %s&quot;,
 961                          Symbol::max_length(),
 962                          name);
 963       return 0;
 964     }
<span class="line-modified"> 965     class_name = SymbolTable::new_symbol(name, str_len);</span>
 966   }
 967 
 968   ResourceMark rm(THREAD);
 969   ClassFileStream st((u1*)buf, len, source, ClassFileStream::verify);
 970   Handle class_loader (THREAD, JNIHandles::resolve(loader));
 971   if (UsePerfData) {
 972     is_lock_held_by_thread(class_loader,
 973                            ClassLoader::sync_JVMDefineClassLockFreeCounter(),
 974                            THREAD);
 975   }
 976   Handle protection_domain (THREAD, JNIHandles::resolve(pd));
 977   Klass* k = SystemDictionary::resolve_from_stream(class_name,
 978                                                    class_loader,
 979                                                    protection_domain,
 980                                                    &amp;st,
 981                                                    CHECK_NULL);
 982 
 983   if (log_is_enabled(Debug, class, resolve) &amp;&amp; k != NULL) {
 984     trace_class_resolution(k);
 985   }
</pre>
<hr />
<pre>
 989 
 990 
 991 JVM_ENTRY(jclass, JVM_DefineClass(JNIEnv *env, const char *name, jobject loader, const jbyte *buf, jsize len, jobject pd))
 992   JVMWrapper(&quot;JVM_DefineClass&quot;);
 993 
 994   return jvm_define_class_common(env, name, loader, buf, len, pd, NULL, THREAD);
 995 JVM_END
 996 
 997 
 998 JVM_ENTRY(jclass, JVM_DefineClassWithSource(JNIEnv *env, const char *name, jobject loader, const jbyte *buf, jsize len, jobject pd, const char *source))
 999   JVMWrapper(&quot;JVM_DefineClassWithSource&quot;);
1000 
1001   return jvm_define_class_common(env, name, loader, buf, len, pd, source, THREAD);
1002 JVM_END
1003 
1004 JVM_ENTRY(jclass, JVM_FindLoadedClass(JNIEnv *env, jobject loader, jstring name))
1005   JVMWrapper(&quot;JVM_FindLoadedClass&quot;);
1006   ResourceMark rm(THREAD);
1007 
1008   Handle h_name (THREAD, JNIHandles::resolve_non_null(name));
<span class="line-modified">1009   char* str = java_lang_String::as_utf8_string(h_name());</span>
1010 

1011   // Sanity check, don&#39;t expect null
1012   if (str == NULL) return NULL;
1013 
<span class="line-modified">1014   // Internalize the string, converting &#39;.&#39; to &#39;/&#39; in string.</span>
<span class="line-added">1015   char* p = (char*)str;</span>
<span class="line-added">1016   while (*p != &#39;\0&#39;) {</span>
<span class="line-added">1017       if (*p == &#39;.&#39;) {</span>
<span class="line-added">1018           *p = &#39;/&#39;;</span>
<span class="line-added">1019       }</span>
<span class="line-added">1020       p++;</span>
<span class="line-added">1021   }</span>
<span class="line-added">1022 </span>
<span class="line-added">1023   const int str_len = (int)(p - str);</span>
1024   if (str_len &gt; Symbol::max_length()) {
1025     // It&#39;s impossible to create this class;  the name cannot fit
1026     // into the constant pool.
1027     return NULL;
1028   }
<span class="line-modified">1029   TempNewSymbol klass_name = SymbolTable::new_symbol(str, str_len);</span>
1030 
1031   // Security Note:
1032   //   The Java level wrapper will perform the necessary security check allowing
1033   //   us to pass the NULL as the initiating class loader.
1034   Handle h_loader(THREAD, JNIHandles::resolve(loader));
1035   if (UsePerfData) {
1036     is_lock_held_by_thread(h_loader,
1037                            ClassLoader::sync_JVMFindLoadedClassLockFreeCounter(),
1038                            THREAD);
1039   }
1040 
1041   Klass* k = SystemDictionary::find_instance_or_array_klass(klass_name,
1042                                                               h_loader,
1043                                                               Handle(),
1044                                                               CHECK_NULL);
1045 #if INCLUDE_CDS
1046   if (k == NULL) {
1047     // If the class is not already loaded, try to see if it&#39;s in the shared
1048     // archive for the current classloader (h_loader).
1049     k = SystemDictionaryShared::find_or_load_shared_class(klass_name, h_loader, CHECK_NULL);
</pre>
<hr />
<pre>
1124 
1125   // Allocate result array
1126   objArrayOop r = oopFactory::new_objArray(SystemDictionary::Class_klass(), size, CHECK_NULL);
1127   objArrayHandle result (THREAD, r);
1128   // Fill in result
1129   if (klass-&gt;is_instance_klass()) {
1130     // Regular instance klass, fill in all local interfaces
1131     for (int index = 0; index &lt; size; index++) {
1132       Klass* k = InstanceKlass::cast(klass)-&gt;local_interfaces()-&gt;at(index);
1133       result-&gt;obj_at_put(index, k-&gt;java_mirror());
1134     }
1135   } else {
1136     // All arrays implement java.lang.Cloneable and java.io.Serializable
1137     result-&gt;obj_at_put(0, SystemDictionary::Cloneable_klass()-&gt;java_mirror());
1138     result-&gt;obj_at_put(1, SystemDictionary::Serializable_klass()-&gt;java_mirror());
1139   }
1140   return (jobjectArray) JNIHandles::make_local(env, result());
1141 JVM_END
1142 
1143 
<span class="line-modified">1144 JVM_ENTRY(jboolean, JVM_IsInterface(JNIEnv *env, jclass cls))</span>
1145   JVMWrapper(&quot;JVM_IsInterface&quot;);
1146   oop mirror = JNIHandles::resolve_non_null(cls);
1147   if (java_lang_Class::is_primitive(mirror)) {
1148     return JNI_FALSE;
1149   }
1150   Klass* k = java_lang_Class::as_Klass(mirror);
1151   jboolean result = k-&gt;is_interface();
1152   assert(!result || k-&gt;is_instance_klass(),
1153          &quot;all interfaces are instance types&quot;);
1154   // The compiler intrinsic for isInterface tests the
1155   // Klass::_access_flags bits in the same way.
1156   return result;
1157 JVM_END
1158 
1159 
1160 JVM_ENTRY(jobjectArray, JVM_GetClassSigners(JNIEnv *env, jclass cls))
1161   JVMWrapper(&quot;JVM_GetClassSigners&quot;);
1162   JvmtiVMObjectAllocEventCollector oam;
1163   if (java_lang_Class::is_primitive(JNIHandles::resolve_non_null(cls))) {
1164     // There are no signers for primitive types
</pre>
<hr />
<pre>
1264     {
1265       // this frame is privileged
1266       is_privileged = true;
1267 
1268       javaVFrame *priv = vfst.asJavaVFrame();       // executePrivileged
1269 
1270       StackValueCollection* locals = priv-&gt;locals();
1271       StackValue* ctx_sv = locals-&gt;at(1); // AccessControlContext context
1272       StackValue* clr_sv = locals-&gt;at(2); // Class&lt;?&gt; caller
1273       assert(!ctx_sv-&gt;obj_is_scalar_replaced(), &quot;found scalar-replaced object&quot;);
1274       assert(!clr_sv-&gt;obj_is_scalar_replaced(), &quot;found scalar-replaced object&quot;);
1275       privileged_context    = ctx_sv-&gt;get_obj();
1276       Handle caller         = clr_sv-&gt;get_obj();
1277 
1278       Klass *caller_klass = java_lang_Class::as_Klass(caller());
1279       protection_domain  = caller_klass-&gt;protection_domain();
1280     } else {
1281       protection_domain = method-&gt;method_holder()-&gt;protection_domain();
1282     }
1283 
<span class="line-modified">1284     if ((previous_protection_domain != protection_domain) &amp;&amp; (protection_domain != NULL)) {</span>
1285       local_array-&gt;push(protection_domain);
1286       previous_protection_domain = protection_domain;
1287     }
1288 
1289     if (is_privileged) break;
1290   }
1291 
1292 
1293   // either all the domains on the stack were system domains, or
1294   // we had a privileged system domain
1295   if (local_array-&gt;is_empty()) {
1296     if (is_privileged &amp;&amp; privileged_context.is_null()) return NULL;
1297 
1298     oop result = java_security_AccessControlContext::create(objArrayHandle(), is_privileged, privileged_context, CHECK_NULL);
1299     return JNIHandles::make_local(env, result);
1300   }
1301 
1302   // the resource area must be registered in case of a gc
1303   RegisterArrayForGC ragc(thread, local_array);
1304   objArrayOop context = oopFactory::new_objArray(SystemDictionary::ProtectionDomain_klass(),
1305                                                  local_array-&gt;length(), CHECK_NULL);
1306   objArrayHandle h_context(thread, context);
1307   for (int index = 0; index &lt; local_array-&gt;length(); index++) {
1308     h_context-&gt;obj_at_put(index, local_array-&gt;at(index));
1309   }
1310 
1311   oop result = java_security_AccessControlContext::create(h_context, is_privileged, privileged_context, CHECK_NULL);
1312 
1313   return JNIHandles::make_local(env, result);
1314 JVM_END
1315 
1316 
<span class="line-modified">1317 JVM_ENTRY(jboolean, JVM_IsArrayClass(JNIEnv *env, jclass cls))</span>
1318   JVMWrapper(&quot;JVM_IsArrayClass&quot;);
1319   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(cls));
1320   return (k != NULL) &amp;&amp; k-&gt;is_array_klass() ? true : false;
1321 JVM_END
1322 
1323 
<span class="line-modified">1324 JVM_ENTRY(jboolean, JVM_IsPrimitiveClass(JNIEnv *env, jclass cls))</span>
1325   JVMWrapper(&quot;JVM_IsPrimitiveClass&quot;);
1326   oop mirror = JNIHandles::resolve_non_null(cls);
1327   return (jboolean) java_lang_Class::is_primitive(mirror);
1328 JVM_END
1329 
1330 
1331 JVM_ENTRY(jint, JVM_GetClassModifiers(JNIEnv *env, jclass cls))
1332   JVMWrapper(&quot;JVM_GetClassModifiers&quot;);
1333   if (java_lang_Class::is_primitive(JNIHandles::resolve_non_null(cls))) {
1334     // Primitive type
1335     return JVM_ACC_ABSTRACT | JVM_ACC_FINAL | JVM_ACC_PUBLIC;
1336   }
1337 
1338   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(cls));
1339   debug_only(int computed_modifiers = k-&gt;compute_modifier_flags(CHECK_0));
1340   assert(k-&gt;modifier_flags() == computed_modifiers, &quot;modifiers cache is OK&quot;);
1341   return k-&gt;modifier_flags();
1342 JVM_END
1343 
1344 
</pre>
<hr />
<pre>
1601   Method* method_ptr = jvm_get_method_common(method);
1602   methodHandle mh (THREAD, method_ptr);
1603   Handle reflected_method (THREAD, JNIHandles::resolve_non_null(method));
1604   const int num_params = mh-&gt;method_parameters_length();
1605 
1606   if (num_params &lt; 0) {
1607     // A -1 return value from method_parameters_length means there is no
1608     // parameter data.  Return null to indicate this to the reflection
1609     // API.
1610     assert(num_params == -1, &quot;num_params should be -1 if it is less than zero&quot;);
1611     return (jobjectArray)NULL;
1612   } else {
1613     // Otherwise, we return something up to reflection, even if it is
1614     // a zero-length array.  Why?  Because in some cases this can
1615     // trigger a MalformedParametersException.
1616 
1617     // make sure all the symbols are properly formatted
1618     for (int i = 0; i &lt; num_params; i++) {
1619       MethodParametersElement* params = mh-&gt;method_parameters_start();
1620       int index = params[i].name_cp_index;
<span class="line-modified">1621       constantPoolHandle cp(THREAD, mh-&gt;constants());</span>
<span class="line-added">1622       bounds_check(cp, index, CHECK_NULL);</span>
1623 
1624       if (0 != index &amp;&amp; !mh-&gt;constants()-&gt;tag_at(index).is_utf8()) {
1625         THROW_MSG_0(vmSymbols::java_lang_IllegalArgumentException(),
1626                     &quot;Wrong type at constant pool index&quot;);
1627       }
1628 
1629     }
1630 
1631     objArrayOop result_oop = oopFactory::new_objArray(SystemDictionary::reflect_Parameter_klass(), num_params, CHECK_NULL);
1632     objArrayHandle result (THREAD, result_oop);
1633 
1634     for (int i = 0; i &lt; num_params; i++) {
1635       MethodParametersElement* params = mh-&gt;method_parameters_start();
1636       // For a 0 index, give a NULL symbol
1637       Symbol* sym = 0 != params[i].name_cp_index ?
1638         mh-&gt;constants()-&gt;symbol_at(params[i].name_cp_index) : NULL;
1639       int flags = params[i].flags;
1640       oop param = Reflection::new_parameter(reflected_method, i, sym,
1641                                             flags, CHECK_NULL);
1642       result-&gt;obj_at_put(i, param);
</pre>
<hr />
<pre>
1680   }
1681 
1682   objArrayOop r = oopFactory::new_objArray(SystemDictionary::reflect_Field_klass(), num_fields, CHECK_NULL);
1683   objArrayHandle result (THREAD, r);
1684 
1685   int out_idx = 0;
1686   fieldDescriptor fd;
1687   for (JavaFieldStream fs(k); !fs.done(); fs.next()) {
1688     if (!publicOnly || fs.access_flags().is_public()) {
1689       fd.reinitialize(k, fs.index());
1690       oop field = Reflection::new_field(&amp;fd, CHECK_NULL);
1691       result-&gt;obj_at_put(out_idx, field);
1692       ++out_idx;
1693     }
1694   }
1695   assert(out_idx == num_fields, &quot;just checking&quot;);
1696   return (jobjectArray) JNIHandles::make_local(env, result());
1697 }
1698 JVM_END
1699 
<span class="line-added">1700 JVM_ENTRY(jboolean, JVM_IsRecord(JNIEnv *env, jclass cls))</span>
<span class="line-added">1701 {</span>
<span class="line-added">1702   JVMWrapper(&quot;JVM_IsRecord&quot;);</span>
<span class="line-added">1703   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(cls));</span>
<span class="line-added">1704   if (k != NULL &amp;&amp; k-&gt;is_instance_klass()) {</span>
<span class="line-added">1705     InstanceKlass* ik = InstanceKlass::cast(k);</span>
<span class="line-added">1706     return ik-&gt;is_record();</span>
<span class="line-added">1707   } else {</span>
<span class="line-added">1708     return false;</span>
<span class="line-added">1709   }</span>
<span class="line-added">1710 }</span>
<span class="line-added">1711 JVM_END</span>
<span class="line-added">1712 </span>
<span class="line-added">1713 JVM_ENTRY(jobjectArray, JVM_GetRecordComponents(JNIEnv* env, jclass ofClass))</span>
<span class="line-added">1714 {</span>
<span class="line-added">1715   JVMWrapper(&quot;JVM_GetRecordComponents&quot;);</span>
<span class="line-added">1716   Klass* c = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(ofClass));</span>
<span class="line-added">1717   assert(c-&gt;is_instance_klass(), &quot;must be&quot;);</span>
<span class="line-added">1718   InstanceKlass* ik = InstanceKlass::cast(c);</span>
<span class="line-added">1719 </span>
<span class="line-added">1720   if (ik-&gt;is_record()) {</span>
<span class="line-added">1721     Array&lt;RecordComponent*&gt;* components = ik-&gt;record_components();</span>
<span class="line-added">1722     assert(components != NULL, &quot;components should not be NULL&quot;);</span>
<span class="line-added">1723     {</span>
<span class="line-added">1724       JvmtiVMObjectAllocEventCollector oam;</span>
<span class="line-added">1725       constantPoolHandle cp(THREAD, ik-&gt;constants());</span>
<span class="line-added">1726       int length = components-&gt;length();</span>
<span class="line-added">1727       assert(length &gt;= 0, &quot;unexpected record_components length&quot;);</span>
<span class="line-added">1728       objArrayOop record_components =</span>
<span class="line-added">1729         oopFactory::new_objArray(SystemDictionary::RecordComponent_klass(), length, CHECK_NULL);</span>
<span class="line-added">1730       objArrayHandle components_h (THREAD, record_components);</span>
<span class="line-added">1731 </span>
<span class="line-added">1732       for (int x = 0; x &lt; length; x++) {</span>
<span class="line-added">1733         RecordComponent* component = components-&gt;at(x);</span>
<span class="line-added">1734         assert(component != NULL, &quot;unexpected NULL record component&quot;);</span>
<span class="line-added">1735         oop component_oop = java_lang_reflect_RecordComponent::create(ik, component, CHECK_NULL);</span>
<span class="line-added">1736         components_h-&gt;obj_at_put(x, component_oop);</span>
<span class="line-added">1737       }</span>
<span class="line-added">1738       return (jobjectArray)JNIHandles::make_local(components_h());</span>
<span class="line-added">1739     }</span>
<span class="line-added">1740   }</span>
<span class="line-added">1741 </span>
<span class="line-added">1742   // Return empty array if ofClass is not a record.</span>
<span class="line-added">1743   objArrayOop result = oopFactory::new_objArray(SystemDictionary::RecordComponent_klass(), 0, CHECK_NULL);</span>
<span class="line-added">1744   return (jobjectArray)JNIHandles::make_local(env, result);</span>
<span class="line-added">1745 }</span>
<span class="line-added">1746 JVM_END</span>
<span class="line-added">1747 </span>
1748 static bool select_method(const methodHandle&amp; method, bool want_constructor) {
1749   if (want_constructor) {
1750     return (method-&gt;is_initializer() &amp;&amp; !method-&gt;is_static());
1751   } else {
1752     return  (!method-&gt;is_initializer() &amp;&amp; !method-&gt;is_overpass());
1753   }
1754 }
1755 
1756 static jobjectArray get_class_declared_methods_helper(
1757                                   JNIEnv *env,
1758                                   jclass ofClass, jboolean publicOnly,
1759                                   bool want_constructor,
1760                                   Klass* klass, TRAPS) {
1761 
1762   JvmtiVMObjectAllocEventCollector oam;
1763 
1764   // Exclude primitive types and array types
1765   if (java_lang_Class::is_primitive(JNIHandles::resolve_non_null(ofClass))
1766       || java_lang_Class::as_Klass(JNIHandles::resolve_non_null(ofClass))-&gt;is_array_klass()) {
1767     // Return empty array
</pre>
<hr />
<pre>
2321 // Verification ////////////////////////////////////////////////////////////////////////////////
2322 
2323 // Reflection for the verifier /////////////////////////////////////////////////////////////////
2324 
2325 // RedefineClasses support: bug 6214132 caused verification to fail.
2326 // All functions from this section should call the jvmtiThreadSate function:
2327 //   Klass* class_to_verify_considering_redefinition(Klass* klass).
2328 // The function returns a Klass* of the _scratch_class if the verifier
2329 // was invoked in the middle of the class redefinition.
2330 // Otherwise it returns its argument value which is the _the_class Klass*.
2331 // Please, refer to the description in the jvmtiThreadSate.hpp.
2332 
2333 JVM_ENTRY(const char*, JVM_GetClassNameUTF(JNIEnv *env, jclass cls))
2334   JVMWrapper(&quot;JVM_GetClassNameUTF&quot;);
2335   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(cls));
2336   k = JvmtiThreadState::class_to_verify_considering_redefinition(k, thread);
2337   return k-&gt;name()-&gt;as_utf8();
2338 JVM_END
2339 
2340 
<span class="line-modified">2341 JVM_ENTRY(void, JVM_GetClassCPTypes(JNIEnv *env, jclass cls, unsigned char *types))</span>
2342   JVMWrapper(&quot;JVM_GetClassCPTypes&quot;);
2343   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(cls));
2344   k = JvmtiThreadState::class_to_verify_considering_redefinition(k, thread);
2345   // types will have length zero if this is not an InstanceKlass
2346   // (length is determined by call to JVM_GetClassCPEntriesCount)
2347   if (k-&gt;is_instance_klass()) {
2348     ConstantPool* cp = InstanceKlass::cast(k)-&gt;constants();
2349     for (int index = cp-&gt;length() - 1; index &gt;= 0; index--) {
2350       constantTag tag = cp-&gt;tag_at(index);
<span class="line-modified">2351       types[index] = (tag.is_unresolved_klass()) ? (unsigned char) JVM_CONSTANT_Class : tag.value();</span>
2352     }
2353   }
2354 JVM_END
2355 
2356 
<span class="line-modified">2357 JVM_ENTRY(jint, JVM_GetClassCPEntriesCount(JNIEnv *env, jclass cls))</span>
2358   JVMWrapper(&quot;JVM_GetClassCPEntriesCount&quot;);
2359   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(cls));
2360   k = JvmtiThreadState::class_to_verify_considering_redefinition(k, thread);
2361   return (!k-&gt;is_instance_klass()) ? 0 : InstanceKlass::cast(k)-&gt;constants()-&gt;length();
2362 JVM_END
2363 
2364 
<span class="line-modified">2365 JVM_ENTRY(jint, JVM_GetClassFieldsCount(JNIEnv *env, jclass cls))</span>
2366   JVMWrapper(&quot;JVM_GetClassFieldsCount&quot;);
2367   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(cls));
2368   k = JvmtiThreadState::class_to_verify_considering_redefinition(k, thread);
2369   return (!k-&gt;is_instance_klass()) ? 0 : InstanceKlass::cast(k)-&gt;java_fields_count();
2370 JVM_END
2371 
2372 
<span class="line-modified">2373 JVM_ENTRY(jint, JVM_GetClassMethodsCount(JNIEnv *env, jclass cls))</span>
2374   JVMWrapper(&quot;JVM_GetClassMethodsCount&quot;);
2375   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(cls));
2376   k = JvmtiThreadState::class_to_verify_considering_redefinition(k, thread);
2377   return (!k-&gt;is_instance_klass()) ? 0 : InstanceKlass::cast(k)-&gt;methods()-&gt;length();
2378 JVM_END
2379 
2380 
2381 // The following methods, used for the verifier, are never called with
2382 // array klasses, so a direct cast to InstanceKlass is safe.
2383 // Typically, these methods are called in a loop with bounds determined
2384 // by the results of JVM_GetClass{Fields,Methods}Count, which return
2385 // zero for arrays.
<span class="line-modified">2386 JVM_ENTRY(void, JVM_GetMethodIxExceptionIndexes(JNIEnv *env, jclass cls, jint method_index, unsigned short *exceptions))</span>
2387   JVMWrapper(&quot;JVM_GetMethodIxExceptionIndexes&quot;);
2388   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(cls));
2389   k = JvmtiThreadState::class_to_verify_considering_redefinition(k, thread);
2390   Method* method = InstanceKlass::cast(k)-&gt;methods()-&gt;at(method_index);
2391   int length = method-&gt;checked_exceptions_length();
2392   if (length &gt; 0) {
2393     CheckedExceptionElement* table= method-&gt;checked_exceptions_start();
2394     for (int i = 0; i &lt; length; i++) {
2395       exceptions[i] = table[i].class_cp_index;
2396     }
2397   }
2398 JVM_END
2399 
2400 
<span class="line-modified">2401 JVM_ENTRY(jint, JVM_GetMethodIxExceptionsCount(JNIEnv *env, jclass cls, jint method_index))</span>
2402   JVMWrapper(&quot;JVM_GetMethodIxExceptionsCount&quot;);
2403   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(cls));
2404   k = JvmtiThreadState::class_to_verify_considering_redefinition(k, thread);
2405   Method* method = InstanceKlass::cast(k)-&gt;methods()-&gt;at(method_index);
2406   return method-&gt;checked_exceptions_length();
2407 JVM_END
2408 
2409 
<span class="line-modified">2410 JVM_ENTRY(void, JVM_GetMethodIxByteCode(JNIEnv *env, jclass cls, jint method_index, unsigned char *code))</span>
2411   JVMWrapper(&quot;JVM_GetMethodIxByteCode&quot;);
2412   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(cls));
2413   k = JvmtiThreadState::class_to_verify_considering_redefinition(k, thread);
2414   Method* method = InstanceKlass::cast(k)-&gt;methods()-&gt;at(method_index);
2415   memcpy(code, method-&gt;code_base(), method-&gt;code_size());
2416 JVM_END
2417 
2418 
<span class="line-modified">2419 JVM_ENTRY(jint, JVM_GetMethodIxByteCodeLength(JNIEnv *env, jclass cls, jint method_index))</span>
2420   JVMWrapper(&quot;JVM_GetMethodIxByteCodeLength&quot;);
2421   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(cls));
2422   k = JvmtiThreadState::class_to_verify_considering_redefinition(k, thread);
2423   Method* method = InstanceKlass::cast(k)-&gt;methods()-&gt;at(method_index);
2424   return method-&gt;code_size();
2425 JVM_END
2426 
2427 
<span class="line-modified">2428 JVM_ENTRY(void, JVM_GetMethodIxExceptionTableEntry(JNIEnv *env, jclass cls, jint method_index, jint entry_index, JVM_ExceptionTableEntryType *entry))</span>
2429   JVMWrapper(&quot;JVM_GetMethodIxExceptionTableEntry&quot;);
2430   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(cls));
2431   k = JvmtiThreadState::class_to_verify_considering_redefinition(k, thread);
2432   Method* method = InstanceKlass::cast(k)-&gt;methods()-&gt;at(method_index);
2433   ExceptionTable extable(method);
2434   entry-&gt;start_pc   = extable.start_pc(entry_index);
2435   entry-&gt;end_pc     = extable.end_pc(entry_index);
2436   entry-&gt;handler_pc = extable.handler_pc(entry_index);
2437   entry-&gt;catchType  = extable.catch_type_index(entry_index);
2438 JVM_END
2439 
2440 
<span class="line-modified">2441 JVM_ENTRY(jint, JVM_GetMethodIxExceptionTableLength(JNIEnv *env, jclass cls, int method_index))</span>
2442   JVMWrapper(&quot;JVM_GetMethodIxExceptionTableLength&quot;);
2443   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(cls));
2444   k = JvmtiThreadState::class_to_verify_considering_redefinition(k, thread);
2445   Method* method = InstanceKlass::cast(k)-&gt;methods()-&gt;at(method_index);
2446   return method-&gt;exception_table_length();
2447 JVM_END
2448 
2449 
<span class="line-modified">2450 JVM_ENTRY(jint, JVM_GetMethodIxModifiers(JNIEnv *env, jclass cls, int method_index))</span>
2451   JVMWrapper(&quot;JVM_GetMethodIxModifiers&quot;);
2452   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(cls));
2453   k = JvmtiThreadState::class_to_verify_considering_redefinition(k, thread);
2454   Method* method = InstanceKlass::cast(k)-&gt;methods()-&gt;at(method_index);
2455   return method-&gt;access_flags().as_int() &amp; JVM_RECOGNIZED_METHOD_MODIFIERS;
2456 JVM_END
2457 
2458 
<span class="line-modified">2459 JVM_ENTRY(jint, JVM_GetFieldIxModifiers(JNIEnv *env, jclass cls, int field_index))</span>
2460   JVMWrapper(&quot;JVM_GetFieldIxModifiers&quot;);
2461   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(cls));
2462   k = JvmtiThreadState::class_to_verify_considering_redefinition(k, thread);
2463   return InstanceKlass::cast(k)-&gt;field_access_flags(field_index) &amp; JVM_RECOGNIZED_FIELD_MODIFIERS;
2464 JVM_END
2465 
2466 
<span class="line-modified">2467 JVM_ENTRY(jint, JVM_GetMethodIxLocalsCount(JNIEnv *env, jclass cls, int method_index))</span>
2468   JVMWrapper(&quot;JVM_GetMethodIxLocalsCount&quot;);
2469   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(cls));
2470   k = JvmtiThreadState::class_to_verify_considering_redefinition(k, thread);
2471   Method* method = InstanceKlass::cast(k)-&gt;methods()-&gt;at(method_index);
2472   return method-&gt;max_locals();
2473 JVM_END
2474 
2475 
<span class="line-modified">2476 JVM_ENTRY(jint, JVM_GetMethodIxArgsSize(JNIEnv *env, jclass cls, int method_index))</span>
2477   JVMWrapper(&quot;JVM_GetMethodIxArgsSize&quot;);
2478   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(cls));
2479   k = JvmtiThreadState::class_to_verify_considering_redefinition(k, thread);
2480   Method* method = InstanceKlass::cast(k)-&gt;methods()-&gt;at(method_index);
2481   return method-&gt;size_of_parameters();
2482 JVM_END
2483 
2484 
<span class="line-modified">2485 JVM_ENTRY(jint, JVM_GetMethodIxMaxStack(JNIEnv *env, jclass cls, int method_index))</span>
2486   JVMWrapper(&quot;JVM_GetMethodIxMaxStack&quot;);
2487   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(cls));
2488   k = JvmtiThreadState::class_to_verify_considering_redefinition(k, thread);
2489   Method* method = InstanceKlass::cast(k)-&gt;methods()-&gt;at(method_index);
2490   return method-&gt;verifier_max_stack();
2491 JVM_END
2492 
2493 
<span class="line-modified">2494 JVM_ENTRY(jboolean, JVM_IsConstructorIx(JNIEnv *env, jclass cls, int method_index))</span>
2495   JVMWrapper(&quot;JVM_IsConstructorIx&quot;);
2496   ResourceMark rm(THREAD);
2497   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(cls));
2498   k = JvmtiThreadState::class_to_verify_considering_redefinition(k, thread);
2499   Method* method = InstanceKlass::cast(k)-&gt;methods()-&gt;at(method_index);
2500   return method-&gt;name() == vmSymbols::object_initializer_name();
2501 JVM_END
2502 
2503 
<span class="line-modified">2504 JVM_ENTRY(jboolean, JVM_IsVMGeneratedMethodIx(JNIEnv *env, jclass cls, int method_index))</span>
2505   JVMWrapper(&quot;JVM_IsVMGeneratedMethodIx&quot;);
2506   ResourceMark rm(THREAD);
2507   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(cls));
2508   k = JvmtiThreadState::class_to_verify_considering_redefinition(k, thread);
2509   Method* method = InstanceKlass::cast(k)-&gt;methods()-&gt;at(method_index);
2510   return method-&gt;is_overpass();
2511 JVM_END
2512 
2513 JVM_ENTRY(const char*, JVM_GetMethodIxNameUTF(JNIEnv *env, jclass cls, jint method_index))
2514   JVMWrapper(&quot;JVM_GetMethodIxIxUTF&quot;);
2515   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(cls));
2516   k = JvmtiThreadState::class_to_verify_considering_redefinition(k, thread);
2517   Method* method = InstanceKlass::cast(k)-&gt;methods()-&gt;at(method_index);
2518   return method-&gt;name()-&gt;as_utf8();
2519 JVM_END
2520 
2521 
2522 JVM_ENTRY(const char*, JVM_GetMethodIxSignatureUTF(JNIEnv *env, jclass cls, jint method_index))
2523   JVMWrapper(&quot;JVM_GetMethodIxSignatureUTF&quot;);
2524   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(cls));
</pre>
<hr />
<pre>
2661   switch (cp-&gt;tag_at(cp_index).value()) {
2662     case JVM_CONSTANT_Fieldref: {
2663       Symbol* name      = cp-&gt;uncached_name_ref_at(cp_index);
2664       Symbol* signature = cp-&gt;uncached_signature_ref_at(cp_index);
2665       InstanceKlass* ik = InstanceKlass::cast(k_called);
2666       for (JavaFieldStream fs(ik); !fs.done(); fs.next()) {
2667         if (fs.name() == name &amp;&amp; fs.signature() == signature) {
2668           return fs.access_flags().as_short() &amp; JVM_RECOGNIZED_FIELD_MODIFIERS;
2669         }
2670       }
2671       return -1;
2672     }
2673     default:
2674       fatal(&quot;JVM_GetCPFieldModifiers: illegal constant&quot;);
2675   }
2676   ShouldNotReachHere();
2677   return 0;
2678 JVM_END
2679 
2680 
<span class="line-modified">2681 JVM_ENTRY(jint, JVM_GetCPMethodModifiers(JNIEnv *env, jclass cls, int cp_index, jclass called_cls))</span>
2682   JVMWrapper(&quot;JVM_GetCPMethodModifiers&quot;);
2683   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(cls));
2684   Klass* k_called = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(called_cls));
2685   k        = JvmtiThreadState::class_to_verify_considering_redefinition(k, thread);
2686   k_called = JvmtiThreadState::class_to_verify_considering_redefinition(k_called, thread);
2687   ConstantPool* cp = InstanceKlass::cast(k)-&gt;constants();
2688   switch (cp-&gt;tag_at(cp_index).value()) {
2689     case JVM_CONSTANT_Methodref:
2690     case JVM_CONSTANT_InterfaceMethodref: {
2691       Symbol* name      = cp-&gt;uncached_name_ref_at(cp_index);
2692       Symbol* signature = cp-&gt;uncached_signature_ref_at(cp_index);
2693       Array&lt;Method*&gt;* methods = InstanceKlass::cast(k_called)-&gt;methods();
2694       int methods_count = methods-&gt;length();
2695       for (int i = 0; i &lt; methods_count; i++) {
2696         Method* method = methods-&gt;at(i);
2697         if (method-&gt;name() == name &amp;&amp; method-&gt;signature() == signature) {
2698             return method-&gt;access_flags().as_int() &amp; JVM_RECOGNIZED_METHOD_MODIFIERS;
2699         }
2700       }
2701       return -1;
</pre>
<hr />
<pre>
2769     return vfprintf(f, fmt, args);
2770   }
2771 }
2772 
2773 ATTRIBUTE_PRINTF(1, 2)
2774 JNIEXPORT int jio_printf(const char *fmt, ...) {
2775   int len;
2776   va_list args;
2777   va_start(args, fmt);
2778   len = jio_vfprintf(defaultStream::output_stream(), fmt, args);
2779   va_end(args);
2780   return len;
2781 }
2782 
2783 // HotSpot specific jio method
2784 void jio_print(const char* s, size_t len) {
2785   // Try to make this function as atomic as possible.
2786   if (Arguments::vfprintf_hook() != NULL) {
2787     jio_fprintf(defaultStream::output_stream(), &quot;%.*s&quot;, (int)len, s);
2788   } else {
<span class="line-modified">2789     // Make an unused local variable to avoid warning from gcc compiler.</span>
2790     size_t count = ::write(defaultStream::output_fd(), s, (int)len);
2791   }
2792 }
2793 
2794 } // Extern C
2795 
2796 // java.lang.Thread //////////////////////////////////////////////////////////////////////////////
2797 
2798 // In most of the JVM thread support functions we need to access the
2799 // thread through a ThreadsListHandle to prevent it from exiting and
2800 // being reclaimed while we try to operate on it. The exceptions to this
2801 // rule are when operating on the current thread, or if the monitor of
2802 // the target java.lang.Thread is locked at the Java level - in both
2803 // cases the target cannot exit.
2804 
2805 static void thread_entry(JavaThread* thread, TRAPS) {
2806   HandleMark hm(THREAD);
2807   Handle obj(THREAD, thread-&gt;threadObj());
2808   JavaValue result(T_VOID);
2809   JavaCalls::call_virtual(&amp;result,
</pre>
<hr />
<pre>
2892 
2893 // JVM_Stop is implemented using a VM_Operation, so threads are forced to safepoints
2894 // before the quasi-asynchronous exception is delivered.  This is a little obtrusive,
2895 // but is thought to be reliable and simple. In the case, where the receiver is the
2896 // same thread as the sender, no VM_Operation is needed.
2897 JVM_ENTRY(void, JVM_StopThread(JNIEnv* env, jobject jthread, jobject throwable))
2898   JVMWrapper(&quot;JVM_StopThread&quot;);
2899 
2900   // A nested ThreadsListHandle will grab the Threads_lock so create
2901   // tlh before we resolve throwable.
2902   ThreadsListHandle tlh(thread);
2903   oop java_throwable = JNIHandles::resolve(throwable);
2904   if (java_throwable == NULL) {
2905     THROW(vmSymbols::java_lang_NullPointerException());
2906   }
2907   oop java_thread = NULL;
2908   JavaThread* receiver = NULL;
2909   bool is_alive = tlh.cv_internal_thread_to_JavaThread(jthread, &amp;receiver, &amp;java_thread);
2910   Events::log_exception(thread,
2911                         &quot;JVM_StopThread thread JavaThread &quot; INTPTR_FORMAT &quot; as oop &quot; INTPTR_FORMAT &quot; [exception &quot; INTPTR_FORMAT &quot;]&quot;,
<span class="line-modified">2912                         p2i(receiver), p2i(java_thread), p2i(throwable));</span>
2913 
2914   if (is_alive) {
2915     // jthread refers to a live JavaThread.
2916     if (thread == receiver) {
2917       // Exception is getting thrown at self so no VM_Operation needed.
2918       THROW_OOP(java_throwable);
2919     } else {
2920       // Use a VM_Operation to throw the exception.
2921       Thread::send_async_exception(java_thread, java_throwable);
2922     }
2923   } else {
2924     // Either:
2925     // - target thread has not been started before being stopped, or
2926     // - target thread already terminated
2927     // We could read the threadStatus to determine which case it is
2928     // but that is overkill as it doesn&#39;t matter. We must set the
2929     // stillborn flag for the first case, and if the thread has already
2930     // exited setting this flag has no effect.
2931     java_lang_Thread::set_stillborn(java_thread);
2932   }
2933 JVM_END
2934 
2935 
2936 JVM_ENTRY(jboolean, JVM_IsThreadAlive(JNIEnv* env, jobject jthread))
2937   JVMWrapper(&quot;JVM_IsThreadAlive&quot;);
2938 
2939   oop thread_oop = JNIHandles::resolve_non_null(jthread);
2940   return java_lang_Thread::is_alive(thread_oop);
2941 JVM_END
2942 
2943 
2944 JVM_ENTRY(void, JVM_SuspendThread(JNIEnv* env, jobject jthread))
2945   JVMWrapper(&quot;JVM_SuspendThread&quot;);
2946 
2947   ThreadsListHandle tlh(thread);
2948   JavaThread* receiver = NULL;
2949   bool is_alive = tlh.cv_internal_thread_to_JavaThread(jthread, &amp;receiver, NULL);
2950   if (is_alive) {
2951     // jthread refers to a live JavaThread.
2952     {
<span class="line-modified">2953       MutexLocker ml(receiver-&gt;SR_lock(), Mutex::_no_safepoint_check_flag);</span>
2954       if (receiver-&gt;is_external_suspend()) {
2955         // Don&#39;t allow nested external suspend requests. We can&#39;t return
2956         // an error from this interface so just ignore the problem.
2957         return;
2958       }
2959       if (receiver-&gt;is_exiting()) { // thread is in the process of exiting
2960         return;
2961       }
2962       receiver-&gt;set_external_suspend();
2963     }
2964 
2965     // java_suspend() will catch threads in the process of exiting
2966     // and will ignore them.
2967     receiver-&gt;java_suspend();
2968 
2969     // It would be nice to have the following assertion in all the
2970     // time, but it is possible for a racing resume request to have
2971     // resumed this thread right after we suspended it. Temporarily
2972     // enable this assertion if you are chasing a different kind of
2973     // bug.
</pre>
<hr />
<pre>
3030   JVMWrapper(&quot;JVM_Yield&quot;);
3031   if (os::dont_yield()) return;
3032   HOTSPOT_THREAD_YIELD();
3033   os::naked_yield();
3034 JVM_END
3035 
3036 static void post_thread_sleep_event(EventThreadSleep* event, jlong millis) {
3037   assert(event != NULL, &quot;invariant&quot;);
3038   assert(event-&gt;should_commit(), &quot;invariant&quot;);
3039   event-&gt;set_time(millis);
3040   event-&gt;commit();
3041 }
3042 
3043 JVM_ENTRY(void, JVM_Sleep(JNIEnv* env, jclass threadClass, jlong millis))
3044   JVMWrapper(&quot;JVM_Sleep&quot;);
3045 
3046   if (millis &lt; 0) {
3047     THROW_MSG(vmSymbols::java_lang_IllegalArgumentException(), &quot;timeout value is negative&quot;);
3048   }
3049 
<span class="line-modified">3050   if (thread-&gt;is_interrupted(true) &amp;&amp; !HAS_PENDING_EXCEPTION) {</span>
3051     THROW_MSG(vmSymbols::java_lang_InterruptedException(), &quot;sleep interrupted&quot;);
3052   }
3053 
3054   // Save current thread state and restore it at the end of this block.
3055   // And set new thread state to SLEEPING.
3056   JavaThreadSleepState jtss(thread);
3057 
3058   HOTSPOT_THREAD_SLEEP_BEGIN(millis);
3059   EventThreadSleep event;
3060 
3061   if (millis == 0) {
3062     os::naked_yield();
3063   } else {
3064     ThreadState old_state = thread-&gt;osthread()-&gt;get_state();
3065     thread-&gt;osthread()-&gt;set_state(SLEEPING);
<span class="line-modified">3066     if (!thread-&gt;sleep(millis)) { // interrupted</span>
3067       // An asynchronous exception (e.g., ThreadDeathException) could have been thrown on
3068       // us while we were sleeping. We do not overwrite those.
3069       if (!HAS_PENDING_EXCEPTION) {
3070         if (event.should_commit()) {
3071           post_thread_sleep_event(&amp;event, millis);
3072         }
3073         HOTSPOT_THREAD_SLEEP_END(1);
3074 
3075         // TODO-FIXME: THROW_MSG returns which means we will not call set_state()
3076         // to properly restore the thread state.  That&#39;s likely wrong.
3077         THROW_MSG(vmSymbols::java_lang_InterruptedException(), &quot;sleep interrupted&quot;);
3078       }
3079     }
3080     thread-&gt;osthread()-&gt;set_state(old_state);
3081   }
3082   if (event.should_commit()) {
3083     post_thread_sleep_event(&amp;event, millis);
3084   }
3085   HOTSPOT_THREAD_SLEEP_END(0);
3086 JVM_END
3087 
3088 JVM_ENTRY(jobject, JVM_CurrentThread(JNIEnv* env, jclass threadClass))
3089   JVMWrapper(&quot;JVM_CurrentThread&quot;);
3090   oop jthread = thread-&gt;threadObj();
3091   assert (thread != NULL, &quot;no current thread!&quot;);
3092   return JNIHandles::make_local(env, jthread);
3093 JVM_END
3094 




























3095 JVM_ENTRY(void, JVM_Interrupt(JNIEnv* env, jobject jthread))
3096   JVMWrapper(&quot;JVM_Interrupt&quot;);
3097 
3098   ThreadsListHandle tlh(thread);
3099   JavaThread* receiver = NULL;
3100   bool is_alive = tlh.cv_internal_thread_to_JavaThread(jthread, &amp;receiver, NULL);
3101   if (is_alive) {
3102     // jthread refers to a live JavaThread.
<span class="line-modified">3103     receiver-&gt;interrupt();</span>















3104   }
3105 JVM_END
3106 
3107 
3108 // Return true iff the current thread has locked the object passed in
3109 
3110 JVM_ENTRY(jboolean, JVM_HoldsLock(JNIEnv* env, jclass threadClass, jobject obj))
3111   JVMWrapper(&quot;JVM_HoldsLock&quot;);
3112   assert(THREAD-&gt;is_Java_thread(), &quot;sanity check&quot;);
3113   if (obj == NULL) {
3114     THROW_(vmSymbols::java_lang_NullPointerException(), JNI_FALSE);
3115   }
3116   Handle h_obj(THREAD, JNIHandles::resolve(obj));
3117   return ObjectSynchronizer::current_thread_holds_lock((JavaThread*)THREAD, h_obj);
3118 JVM_END
3119 
3120 
3121 JVM_ENTRY(void, JVM_DumpAllStacks(JNIEnv* env, jclass))
3122   JVMWrapper(&quot;JVM_DumpAllStacks&quot;);
3123   VM_PrintThreads op;
</pre>
<hr />
<pre>
3204   objArrayOop result = ClassLoader::get_system_packages(CHECK_NULL);
3205   return (jobjectArray) JNIHandles::make_local(result);
3206 JVM_END
3207 
3208 
3209 // java.lang.ref.Finalizer ///////////////////////////////////////////////////////////////
3210 
3211 JVM_ENTRY(jboolean, JVM_GetTsanEnabled(JNIEnv *env))
3212   JVMWrapper(&quot;JVM_GetTsanEnabled&quot;);
3213   TSAN_ONLY(return ThreadSanitizer;)
3214   NOT_TSAN(return JNI_FALSE;)
3215 JVM_END
3216 
3217 
3218 // java.lang.ref.Reference ///////////////////////////////////////////////////////////////
3219 
3220 
3221 JVM_ENTRY(jobject, JVM_GetAndClearReferencePendingList(JNIEnv* env))
3222   JVMWrapper(&quot;JVM_GetAndClearReferencePendingList&quot;);
3223 
<span class="line-modified">3224   MonitorLocker ml(Heap_lock);</span>
3225   oop ref = Universe::reference_pending_list();
3226   if (ref != NULL) {
3227     Universe::set_reference_pending_list(NULL);
3228   }
3229   return JNIHandles::make_local(env, ref);
3230 JVM_END
3231 
3232 JVM_ENTRY(jboolean, JVM_HasReferencePendingList(JNIEnv* env))
3233   JVMWrapper(&quot;JVM_HasReferencePendingList&quot;);
<span class="line-modified">3234   MonitorLocker ml(Heap_lock);</span>
3235   return Universe::has_reference_pending_list();
3236 JVM_END
3237 
3238 JVM_ENTRY(void, JVM_WaitForReferencePendingList(JNIEnv* env))
3239   JVMWrapper(&quot;JVM_WaitForReferencePendingList&quot;);
<span class="line-modified">3240   MonitorLocker ml(Heap_lock);</span>
3241   while (!Universe::has_reference_pending_list()) {
3242     ml.wait();
3243   }
3244 JVM_END
3245 
3246 
3247 // ObjectInputStream ///////////////////////////////////////////////////////////////
3248 
3249 // Return the first user-defined class loader up the execution stack, or null
3250 // if only code from the bootstrap or platform class loader is on the stack.
3251 
3252 JVM_ENTRY(jobject, JVM_LatestUserDefinedLoader(JNIEnv *env))
3253   for (vframeStream vfst(thread); !vfst.at_end(); vfst.next()) {
3254     vfst.skip_reflection_related_frames(); // Only needed for 1.4 reflection
3255     oop loader = vfst.method()-&gt;method_holder()-&gt;class_loader();
3256     if (loader != NULL &amp;&amp; !SystemDictionary::is_platform_class_loader(loader)) {
3257       return JNIHandles::make_local(env, loader);
3258     }
3259   }
3260   return NULL;
</pre>
<hr />
<pre>
3366   char ebuf[1024];
3367   void *load_result;
3368   {
3369     ThreadToNativeFromVM ttnfvm(thread);
3370     load_result = os::dll_load(name, ebuf, sizeof ebuf);
3371   }
3372   if (load_result == NULL) {
3373     char msg[1024];
3374     jio_snprintf(msg, sizeof msg, &quot;%s: %s&quot;, name, ebuf);
3375     // Since &#39;ebuf&#39; may contain a string encoded using
3376     // platform encoding scheme, we need to pass
3377     // Exceptions::unsafe_to_utf8 to the new_exception method
3378     // as the last argument. See bug 6367357.
3379     Handle h_exception =
3380       Exceptions::new_exception(thread,
3381                                 vmSymbols::java_lang_UnsatisfiedLinkError(),
3382                                 msg, Exceptions::unsafe_to_utf8);
3383 
3384     THROW_HANDLE_0(h_exception);
3385   }
<span class="line-added">3386   log_info(library)(&quot;Loaded library %s, handle &quot; INTPTR_FORMAT, name, p2i(load_result));</span>
3387   return load_result;
3388 JVM_END
3389 
3390 
3391 JVM_LEAF(void, JVM_UnloadLibrary(void* handle))
3392   JVMWrapper(&quot;JVM_UnloadLibrary&quot;);
3393   os::dll_unload(handle);
<span class="line-added">3394   log_info(library)(&quot;Unloaded library with handle &quot; INTPTR_FORMAT, p2i(handle));</span>
3395 JVM_END
3396 
3397 
3398 JVM_LEAF(void*, JVM_FindLibraryEntry(void* handle, const char* name))
3399   JVMWrapper(&quot;JVM_FindLibraryEntry&quot;);
<span class="line-modified">3400   void* find_result = os::dll_lookup(handle, name);</span>
<span class="line-added">3401   log_info(library)(&quot;%s %s in library with handle &quot; INTPTR_FORMAT,</span>
<span class="line-added">3402                     find_result != NULL ? &quot;Found&quot; : &quot;Failed to find&quot;,</span>
<span class="line-added">3403                     name, p2i(handle));</span>
<span class="line-added">3404   return find_result;</span>
3405 JVM_END
3406 
3407 
3408 // JNI version ///////////////////////////////////////////////////////////////////////////////
3409 
3410 JVM_LEAF(jboolean, JVM_IsSupportedJNIVersion(jint version))
3411   JVMWrapper(&quot;JVM_IsSupportedJNIVersion&quot;);
3412   return Threads::is_supported_jni_version_including_1_1(version);
3413 JVM_END
3414 
3415 
3416 // String support ///////////////////////////////////////////////////////////////////////////
3417 
3418 JVM_ENTRY(jstring, JVM_InternString(JNIEnv *env, jstring str))
3419   JVMWrapper(&quot;JVM_InternString&quot;);
3420   JvmtiVMObjectAllocEventCollector oam;
3421   if (str == NULL) return NULL;
3422   oop string = JNIHandles::resolve_non_null(str);
3423   oop result = StringTable::intern(string, CHECK_NULL);
3424   return (jstring) JNIHandles::make_local(env, result);
3425 JVM_END
3426 
3427 
<span class="line-modified">3428 // VM Raw monitor support //////////////////////////////////////////////////////////////////////</span>
3429 
<span class="line-modified">3430 // VM Raw monitors (not to be confused with JvmtiRawMonitors) are a simple mutual exclusion</span>
<span class="line-modified">3431 // lock (not actually monitors: no wait/notify) that is exported by the VM for use by JDK</span>
<span class="line-modified">3432 // library code. They may be used by JavaThreads and non-JavaThreads and do not participate</span>
<span class="line-modified">3433 // in the safepoint protocol, thread suspension, thread interruption, or anything of that</span>
<span class="line-added">3434 // nature. JavaThreads will be &quot;in native&quot; when using this API from JDK code.</span>
3435 
3436 
3437 JNIEXPORT void* JNICALL JVM_RawMonitorCreate(void) {
3438   VM_Exit::block_if_vm_exited();
3439   JVMWrapper(&quot;JVM_RawMonitorCreate&quot;);
<span class="line-modified">3440   void *mon = new os::PlatformMutex();</span>
3441   TSAN_RUNTIME_ONLY(TSAN_RAW_LOCK_CREATE(mon));
3442   return mon;
3443 }
3444 
3445 
3446 JNIEXPORT void JNICALL  JVM_RawMonitorDestroy(void *mon) {
3447   VM_Exit::block_if_vm_exited();
3448   JVMWrapper(&quot;JVM_RawMonitorDestroy&quot;);
3449   TSAN_RUNTIME_ONLY(TSAN_RAW_LOCK_DESTROY(mon));
<span class="line-modified">3450   delete ((os::PlatformMutex*) mon);</span>
3451 }
3452 
3453 
3454 JNIEXPORT jint JNICALL JVM_RawMonitorEnter(void *mon) {
3455   VM_Exit::block_if_vm_exited();
3456   JVMWrapper(&quot;JVM_RawMonitorEnter&quot;);
<span class="line-modified">3457   ((os::PlatformMutex*) mon)-&gt;lock();</span>
3458   TSAN_RUNTIME_ONLY(TSAN_RAW_LOCK_ACQUIRED(mon));
3459   return 0;
3460 }
3461 
3462 
3463 JNIEXPORT void JNICALL JVM_RawMonitorExit(void *mon) {
3464   VM_Exit::block_if_vm_exited();
3465   JVMWrapper(&quot;JVM_RawMonitorExit&quot;);
3466   TSAN_RUNTIME_ONLY(TSAN_RAW_LOCK_RELEASED(mon));
<span class="line-modified">3467   ((os::PlatformMutex*) mon)-&gt;unlock();</span>
3468 }
3469 
3470 
3471 // Shared JNI/JVM entry points //////////////////////////////////////////////////////////////
3472 
3473 jclass find_class_from_class_loader(JNIEnv* env, Symbol* name, jboolean init,
3474                                     Handle loader, Handle protection_domain,
3475                                     jboolean throwError, TRAPS) {
3476   // Security Note:
3477   //   The Java level wrapper will perform the necessary security check allowing
3478   //   us to pass the NULL as the initiating class loader.  The VM is responsible for
3479   //   the checkPackageAccess relative to the initiating class loader via the
3480   //   protection_domain. The protection_domain is passed as NULL by the java code
3481   //   if there is no security manager in 3-arg Class.forName().
3482   Klass* klass = SystemDictionary::resolve_or_fail(name, loader, protection_domain, throwError != 0, CHECK_NULL);
3483 
3484   // Check if we should initialize the class
3485   if (init &amp;&amp; klass-&gt;is_instance_klass()) {
3486     klass-&gt;initialize(CHECK_NULL);
3487   }
</pre>
<hr />
<pre>
3651   objArrayHandle dest(THREAD, dest_o);
3652   Klass* enc_k = ik-&gt;constants()-&gt;klass_at(encl_method_class_idx, CHECK_NULL);
3653   dest-&gt;obj_at_put(0, enc_k-&gt;java_mirror());
3654   int encl_method_method_idx = ik-&gt;enclosing_method_method_index();
3655   if (encl_method_method_idx != 0) {
3656     Symbol* sym = ik-&gt;constants()-&gt;symbol_at(
3657                         extract_low_short_from_int(
3658                           ik-&gt;constants()-&gt;name_and_type_at(encl_method_method_idx)));
3659     Handle str = java_lang_String::create_from_symbol(sym, CHECK_NULL);
3660     dest-&gt;obj_at_put(1, str());
3661     sym = ik-&gt;constants()-&gt;symbol_at(
3662               extract_high_short_from_int(
3663                 ik-&gt;constants()-&gt;name_and_type_at(encl_method_method_idx)));
3664     str = java_lang_String::create_from_symbol(sym, CHECK_NULL);
3665     dest-&gt;obj_at_put(2, str());
3666   }
3667   return (jobjectArray) JNIHandles::make_local(dest());
3668 }
3669 JVM_END
3670 














3671 // Returns an array of java.lang.String objects containing the input arguments to the VM.
3672 JVM_ENTRY(jobjectArray, JVM_GetVmArguments(JNIEnv *env))
3673   ResourceMark rm(THREAD);
3674 
3675   if (Arguments::num_jvm_args() == 0 &amp;&amp; Arguments::num_jvm_flags() == 0) {
3676     return NULL;
3677   }
3678 
3679   char** vm_flags = Arguments::jvm_flags_array();
3680   char** vm_args = Arguments::jvm_args_array();
3681   int num_flags = Arguments::num_jvm_flags();
3682   int num_args = Arguments::num_jvm_args();
3683 
3684   InstanceKlass* ik = SystemDictionary::String_klass();
3685   objArrayOop r = oopFactory::new_objArray(ik, num_args + num_flags, CHECK_NULL);
3686   objArrayHandle result_h(THREAD, r);
3687 
3688   int index = 0;
3689   for (int j = 0; j &lt; num_flags; j++, index++) {
3690     Handle h = java_lang_String::create_from_platform_dependent_str(vm_flags[j], CHECK_NULL);
</pre>
</td>
</tr>
</table>
<center><a href="../oops/instanceKlass.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="jvmtiEnv.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
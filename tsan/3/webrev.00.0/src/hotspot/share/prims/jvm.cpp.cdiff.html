<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/hotspot/share/prims/jvm.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="../oops/instanceKlass.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="jvmtiEnv.cpp.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/prims/jvm.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 1,7 ***</span>
  /*
<span class="line-modified">!  * Copyright (c) 1997, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.
<span class="line-new-header">--- 1,7 ---</span>
  /*
<span class="line-modified">!  * Copyright (c) 1997, 2020, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 31,26 ***</span>
  #include &quot;classfile/javaClasses.inline.hpp&quot;
  #include &quot;classfile/moduleEntry.hpp&quot;
  #include &quot;classfile/modules.hpp&quot;
  #include &quot;classfile/packageEntry.hpp&quot;
  #include &quot;classfile/stringTable.hpp&quot;
  #include &quot;classfile/systemDictionary.hpp&quot;
  #include &quot;classfile/vmSymbols.hpp&quot;
  #include &quot;gc/shared/collectedHeap.inline.hpp&quot;
  #include &quot;interpreter/bytecode.hpp&quot;
  #include &quot;jfr/jfrEvents.hpp&quot;
  #include &quot;logging/log.hpp&quot;
  #include &quot;memory/heapShared.hpp&quot;
  #include &quot;memory/oopFactory.hpp&quot;
  #include &quot;memory/referenceType.hpp&quot;
  #include &quot;memory/resourceArea.hpp&quot;
  #include &quot;memory/universe.hpp&quot;
  #include &quot;oops/access.inline.hpp&quot;
  #include &quot;oops/constantPool.hpp&quot;
<span class="line-modified">! #include &quot;oops/fieldStreams.hpp&quot;</span>
  #include &quot;oops/instanceKlass.hpp&quot;
  #include &quot;oops/method.hpp&quot;
  #include &quot;oops/objArrayKlass.hpp&quot;
  #include &quot;oops/objArrayOop.inline.hpp&quot;
  #include &quot;oops/oop.inline.hpp&quot;
  #include &quot;prims/jvm_misc.hpp&quot;
  #include &quot;prims/jvmtiExport.hpp&quot;
<span class="line-new-header">--- 31,29 ---</span>
  #include &quot;classfile/javaClasses.inline.hpp&quot;
  #include &quot;classfile/moduleEntry.hpp&quot;
  #include &quot;classfile/modules.hpp&quot;
  #include &quot;classfile/packageEntry.hpp&quot;
  #include &quot;classfile/stringTable.hpp&quot;
<span class="line-added">+ #include &quot;classfile/symbolTable.hpp&quot;</span>
  #include &quot;classfile/systemDictionary.hpp&quot;
  #include &quot;classfile/vmSymbols.hpp&quot;
  #include &quot;gc/shared/collectedHeap.inline.hpp&quot;
  #include &quot;interpreter/bytecode.hpp&quot;
<span class="line-added">+ #include &quot;interpreter/bytecodeUtils.hpp&quot;</span>
  #include &quot;jfr/jfrEvents.hpp&quot;
  #include &quot;logging/log.hpp&quot;
  #include &quot;memory/heapShared.hpp&quot;
  #include &quot;memory/oopFactory.hpp&quot;
  #include &quot;memory/referenceType.hpp&quot;
  #include &quot;memory/resourceArea.hpp&quot;
  #include &quot;memory/universe.hpp&quot;
  #include &quot;oops/access.inline.hpp&quot;
  #include &quot;oops/constantPool.hpp&quot;
<span class="line-modified">! #include &quot;oops/fieldStreams.inline.hpp&quot;</span>
  #include &quot;oops/instanceKlass.hpp&quot;
  #include &quot;oops/method.hpp&quot;
<span class="line-added">+ #include &quot;oops/recordComponent.hpp&quot;</span>
  #include &quot;oops/objArrayKlass.hpp&quot;
  #include &quot;oops/objArrayOop.inline.hpp&quot;
  #include &quot;oops/oop.inline.hpp&quot;
  #include &quot;prims/jvm_misc.hpp&quot;
  #include &quot;prims/jvmtiExport.hpp&quot;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 61,15 ***</span>
  #include &quot;runtime/atomic.hpp&quot;
  #include &quot;runtime/handles.inline.hpp&quot;
  #include &quot;runtime/init.hpp&quot;
  #include &quot;runtime/interfaceSupport.inline.hpp&quot;
  #include &quot;runtime/deoptimization.hpp&quot;
  #include &quot;runtime/java.hpp&quot;
  #include &quot;runtime/javaCalls.hpp&quot;
  #include &quot;runtime/jfieldIDWorkaround.hpp&quot;
  #include &quot;runtime/jniHandles.inline.hpp&quot;
<span class="line-removed">- #include &quot;runtime/orderAccess.hpp&quot;</span>
  #include &quot;runtime/os.inline.hpp&quot;
  #include &quot;runtime/perfData.hpp&quot;
  #include &quot;runtime/reflection.hpp&quot;
  #include &quot;runtime/thread.inline.hpp&quot;
  #include &quot;runtime/threadSMR.hpp&quot;
<span class="line-new-header">--- 64,15 ---</span>
  #include &quot;runtime/atomic.hpp&quot;
  #include &quot;runtime/handles.inline.hpp&quot;
  #include &quot;runtime/init.hpp&quot;
  #include &quot;runtime/interfaceSupport.inline.hpp&quot;
  #include &quot;runtime/deoptimization.hpp&quot;
<span class="line-added">+ #include &quot;runtime/handshake.hpp&quot;</span>
  #include &quot;runtime/java.hpp&quot;
  #include &quot;runtime/javaCalls.hpp&quot;
  #include &quot;runtime/jfieldIDWorkaround.hpp&quot;
  #include &quot;runtime/jniHandles.inline.hpp&quot;
  #include &quot;runtime/os.inline.hpp&quot;
  #include &quot;runtime/perfData.hpp&quot;
  #include &quot;runtime/reflection.hpp&quot;
  #include &quot;runtime/thread.inline.hpp&quot;
  #include &quot;runtime/threadSMR.hpp&quot;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 138,13 ***</span>
    JavaThread* jthread = JavaThread::current();
    if (jthread-&gt;has_last_Java_frame()) {
      vframeStream vfst(jthread);
  
      // scan up the stack skipping ClassLoader, AccessController and PrivilegedAction frames
<span class="line-modified">!     TempNewSymbol access_controller = SymbolTable::new_symbol(&quot;java/security/AccessController&quot;, CHECK);</span>
      Klass* access_controller_klass = SystemDictionary::resolve_or_fail(access_controller, false, CHECK);
<span class="line-modified">!     TempNewSymbol privileged_action = SymbolTable::new_symbol(&quot;java/security/PrivilegedAction&quot;, CHECK);</span>
      Klass* privileged_action_klass = SystemDictionary::resolve_or_fail(privileged_action, false, CHECK);
  
      Method* last_caller = NULL;
  
      while (!vfst.at_end()) {
<span class="line-new-header">--- 141,13 ---</span>
    JavaThread* jthread = JavaThread::current();
    if (jthread-&gt;has_last_Java_frame()) {
      vframeStream vfst(jthread);
  
      // scan up the stack skipping ClassLoader, AccessController and PrivilegedAction frames
<span class="line-modified">!     TempNewSymbol access_controller = SymbolTable::new_symbol(&quot;java/security/AccessController&quot;);</span>
      Klass* access_controller_klass = SystemDictionary::resolve_or_fail(access_controller, false, CHECK);
<span class="line-modified">!     TempNewSymbol privileged_action = SymbolTable::new_symbol(&quot;java/security/PrivilegedAction&quot;);</span>
      Klass* privileged_action_klass = SystemDictionary::resolve_or_fail(privileged_action, false, CHECK);
  
      Method* last_caller = NULL;
  
      while (!vfst.at_end()) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 231,12 ***</span>
  
    JVMHistogramElement::JVMHistogramElement(const char* elementName) {
      _name = elementName;
      uintx count = 0;
  
<span class="line-modified">!     while (Atomic::cmpxchg(1, &amp;JVMHistogram_lock, 0) != 0) {</span>
<span class="line-modified">!       while (OrderAccess::load_acquire(&amp;JVMHistogram_lock) != 0) {</span>
          count +=1;
          if ( (WarnOnStalledSpinLock &gt; 0)
            &amp;&amp; (count % WarnOnStalledSpinLock == 0)) {
            warning(&quot;JVMHistogram_lock seems to be stalled&quot;);
          }
<span class="line-new-header">--- 234,12 ---</span>
  
    JVMHistogramElement::JVMHistogramElement(const char* elementName) {
      _name = elementName;
      uintx count = 0;
  
<span class="line-modified">!     while (Atomic::cmpxchg(&amp;JVMHistogram_lock, 0, 1) != 0) {</span>
<span class="line-modified">!       while (Atomic::load_acquire(&amp;JVMHistogram_lock) != 0) {</span>
          count +=1;
          if ( (WarnOnStalledSpinLock &gt; 0)
            &amp;&amp; (count % WarnOnStalledSpinLock == 0)) {
            warning(&quot;JVMHistogram_lock seems to be stalled&quot;);
          }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 509,16 ***</span>
  JVM_END
  
  
  JVM_ENTRY_NO_ENV(jlong, JVM_FreeMemory(void))
    JVMWrapper(&quot;JVM_FreeMemory&quot;);
<span class="line-modified">!   CollectedHeap* ch = Universe::heap();</span>
<span class="line-removed">-   size_t n;</span>
<span class="line-removed">-   {</span>
<span class="line-removed">-      MutexLocker x(Heap_lock);</span>
<span class="line-removed">-      n = ch-&gt;capacity() - ch-&gt;used();</span>
<span class="line-removed">-   }</span>
    return convert_size_t_to_jlong(n);
  JVM_END
  
  
  JVM_ENTRY_NO_ENV(jlong, JVM_MaxMemory(void))
<span class="line-new-header">--- 512,11 ---</span>
  JVM_END
  
  
  JVM_ENTRY_NO_ENV(jlong, JVM_FreeMemory(void))
    JVMWrapper(&quot;JVM_FreeMemory&quot;);
<span class="line-modified">!   size_t n = Universe::heap()-&gt;unused();</span>
    return convert_size_t_to_jlong(n);
  JVM_END
  
  
  JVM_ENTRY_NO_ENV(jlong, JVM_MaxMemory(void))
</pre>
<hr />
<pre>
<span class="line-old-header">*** 535,17 ***</span>
  
  
  
  // java.lang.Throwable //////////////////////////////////////////////////////
  
<span class="line-removed">- </span>
  JVM_ENTRY(void, JVM_FillInStackTrace(JNIEnv *env, jobject receiver))
    JVMWrapper(&quot;JVM_FillInStackTrace&quot;);
    Handle exception(thread, JNIHandles::resolve_non_null(receiver));
    java_lang_Throwable::fill_in_stack_trace(exception);
  JVM_END
  
  
  // java.lang.StackTraceElement //////////////////////////////////////////////
  
  
  JVM_ENTRY(void, JVM_InitStackTraceElementArray(JNIEnv *env, jobjectArray elements, jobject throwable))
<span class="line-new-header">--- 533,41 ---</span>
  
  
  
  // java.lang.Throwable //////////////////////////////////////////////////////
  
  JVM_ENTRY(void, JVM_FillInStackTrace(JNIEnv *env, jobject receiver))
    JVMWrapper(&quot;JVM_FillInStackTrace&quot;);
    Handle exception(thread, JNIHandles::resolve_non_null(receiver));
    java_lang_Throwable::fill_in_stack_trace(exception);
  JVM_END
  
<span class="line-added">+ // java.lang.NullPointerException ///////////////////////////////////////////</span>
<span class="line-added">+ </span>
<span class="line-added">+ JVM_ENTRY(jstring, JVM_GetExtendedNPEMessage(JNIEnv *env, jthrowable throwable))</span>
<span class="line-added">+   if (!ShowCodeDetailsInExceptionMessages) return NULL;</span>
<span class="line-added">+ </span>
<span class="line-added">+   oop exc = JNIHandles::resolve_non_null(throwable);</span>
<span class="line-added">+ </span>
<span class="line-added">+   Method* method;</span>
<span class="line-added">+   int bci;</span>
<span class="line-added">+   if (!java_lang_Throwable::get_top_method_and_bci(exc, &amp;method, &amp;bci)) {</span>
<span class="line-added">+     return NULL;</span>
<span class="line-added">+   }</span>
<span class="line-added">+   if (method-&gt;is_native()) {</span>
<span class="line-added">+     return NULL;</span>
<span class="line-added">+   }</span>
<span class="line-added">+ </span>
<span class="line-added">+   stringStream ss;</span>
<span class="line-added">+   bool ok = BytecodeUtils::get_NPE_message_at(&amp;ss, method, bci);</span>
<span class="line-added">+   if (ok) {</span>
<span class="line-added">+     oop result = java_lang_String::create_oop_from_str(ss.base(), CHECK_0);</span>
<span class="line-added">+     return (jstring) JNIHandles::make_local(env, result);</span>
<span class="line-added">+   } else {</span>
<span class="line-added">+     return NULL;</span>
<span class="line-added">+   }</span>
<span class="line-added">+ JVM_END</span>
  
  // java.lang.StackTraceElement //////////////////////////////////////////////
  
  
  JVM_ENTRY(void, JVM_InitStackTraceElementArray(JNIEnv *env, jobjectArray elements, jobject throwable))
</pre>
<hr />
<pre>
<span class="line-old-header">*** 766,11 ***</span>
  
  JVM_ENTRY(jclass, JVM_FindPrimitiveClass(JNIEnv* env, const char* utf))
    JVMWrapper(&quot;JVM_FindPrimitiveClass&quot;);
    oop mirror = NULL;
    BasicType t = name2type(utf);
<span class="line-modified">!   if (t != T_ILLEGAL &amp;&amp; t != T_OBJECT &amp;&amp; t != T_ARRAY) {</span>
      mirror = Universe::java_mirror(t);
    }
    if (mirror == NULL) {
      THROW_MSG_0(vmSymbols::java_lang_ClassNotFoundException(), (char*) utf);
    } else {
<span class="line-new-header">--- 788,11 ---</span>
  
  JVM_ENTRY(jclass, JVM_FindPrimitiveClass(JNIEnv* env, const char* utf))
    JVMWrapper(&quot;JVM_FindPrimitiveClass&quot;);
    oop mirror = NULL;
    BasicType t = name2type(utf);
<span class="line-modified">!   if (t != T_ILLEGAL &amp;&amp; !is_reference_type(t)) {</span>
      mirror = Universe::java_mirror(t);
    }
    if (mirror == NULL) {
      THROW_MSG_0(vmSymbols::java_lang_ClassNotFoundException(), (char*) utf);
    } else {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 791,11 ***</span>
      // It&#39;s impossible to create this class;  the name cannot fit
      // into the constant pool.
      return NULL;
    }
  
<span class="line-modified">!   TempNewSymbol h_name = SymbolTable::new_symbol(name, CHECK_NULL);</span>
    Klass* k = SystemDictionary::resolve_or_null(h_name, CHECK_NULL);
    if (k == NULL) {
      return NULL;
    }
  
<span class="line-new-header">--- 813,11 ---</span>
      // It&#39;s impossible to create this class;  the name cannot fit
      // into the constant pool.
      return NULL;
    }
  
<span class="line-modified">!   TempNewSymbol h_name = SymbolTable::new_symbol(name);</span>
    Klass* k = SystemDictionary::resolve_or_null(h_name, CHECK_NULL);
    if (k == NULL) {
      return NULL;
    }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 815,11 ***</span>
      // It&#39;s impossible to create this class;  the name cannot fit
      // into the constant pool.
      THROW_MSG_0(vmSymbols::java_lang_ClassNotFoundException(), name);
    }
  
<span class="line-modified">!   TempNewSymbol h_name = SymbolTable::new_symbol(name, CHECK_NULL);</span>
  
    oop loader_oop = JNIHandles::resolve(loader);
    oop from_class = JNIHandles::resolve(caller);
    oop protection_domain = NULL;
    // If loader is null, shouldn&#39;t call ClassLoader.checkPackageAccess; otherwise get
<span class="line-new-header">--- 837,11 ---</span>
      // It&#39;s impossible to create this class;  the name cannot fit
      // into the constant pool.
      THROW_MSG_0(vmSymbols::java_lang_ClassNotFoundException(), name);
    }
  
<span class="line-modified">!   TempNewSymbol h_name = SymbolTable::new_symbol(name);</span>
  
    oop loader_oop = JNIHandles::resolve(loader);
    oop from_class = JNIHandles::resolve(caller);
    oop protection_domain = NULL;
    // If loader is null, shouldn&#39;t call ClassLoader.checkPackageAccess; otherwise get
</pre>
<hr />
<pre>
<span class="line-old-header">*** 857,11 ***</span>
                         &quot;Class name exceeds maximum length of %d: %s&quot;,
                         Symbol::max_length(),
                         name);
      return 0;
    }
<span class="line-modified">!   TempNewSymbol h_name = SymbolTable::new_symbol(name, CHECK_NULL);</span>
    oop from_class_oop = JNIHandles::resolve(from);
    Klass* from_class = (from_class_oop == NULL)
                             ? (Klass*)NULL
                             : java_lang_Class::as_Klass(from_class_oop);
    oop class_loader = NULL;
<span class="line-new-header">--- 879,11 ---</span>
                         &quot;Class name exceeds maximum length of %d: %s&quot;,
                         Symbol::max_length(),
                         name);
      return 0;
    }
<span class="line-modified">!   TempNewSymbol h_name = SymbolTable::new_symbol(name);</span>
    oop from_class_oop = JNIHandles::resolve(from);
    Klass* from_class = (from_class_oop == NULL)
                             ? (Klass*)NULL
                             : java_lang_Class::as_Klass(from_class_oop);
    oop class_loader = NULL;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 938,11 ***</span>
                           &quot;Class name exceeds maximum length of %d: %s&quot;,
                           Symbol::max_length(),
                           name);
        return 0;
      }
<span class="line-modified">!     class_name = SymbolTable::new_symbol(name, str_len, CHECK_NULL);</span>
    }
  
    ResourceMark rm(THREAD);
    ClassFileStream st((u1*)buf, len, source, ClassFileStream::verify);
    Handle class_loader (THREAD, JNIHandles::resolve(loader));
<span class="line-new-header">--- 960,11 ---</span>
                           &quot;Class name exceeds maximum length of %d: %s&quot;,
                           Symbol::max_length(),
                           name);
        return 0;
      }
<span class="line-modified">!     class_name = SymbolTable::new_symbol(name, str_len);</span>
    }
  
    ResourceMark rm(THREAD);
    ClassFileStream st((u1*)buf, len, source, ClassFileStream::verify);
    Handle class_loader (THREAD, JNIHandles::resolve(loader));
</pre>
<hr />
<pre>
<span class="line-old-header">*** 982,23 ***</span>
  JVM_ENTRY(jclass, JVM_FindLoadedClass(JNIEnv *env, jobject loader, jstring name))
    JVMWrapper(&quot;JVM_FindLoadedClass&quot;);
    ResourceMark rm(THREAD);
  
    Handle h_name (THREAD, JNIHandles::resolve_non_null(name));
<span class="line-modified">!   Handle string = java_lang_String::internalize_classname(h_name, CHECK_NULL);</span>
  
<span class="line-removed">-   const char* str   = java_lang_String::as_utf8_string(string());</span>
    // Sanity check, don&#39;t expect null
    if (str == NULL) return NULL;
  
<span class="line-modified">!   const int str_len = (int)strlen(str);</span>
    if (str_len &gt; Symbol::max_length()) {
      // It&#39;s impossible to create this class;  the name cannot fit
      // into the constant pool.
      return NULL;
    }
<span class="line-modified">!   TempNewSymbol klass_name = SymbolTable::new_symbol(str, str_len, CHECK_NULL);</span>
  
    // Security Note:
    //   The Java level wrapper will perform the necessary security check allowing
    //   us to pass the NULL as the initiating class loader.
    Handle h_loader(THREAD, JNIHandles::resolve(loader));
<span class="line-new-header">--- 1004,31 ---</span>
  JVM_ENTRY(jclass, JVM_FindLoadedClass(JNIEnv *env, jobject loader, jstring name))
    JVMWrapper(&quot;JVM_FindLoadedClass&quot;);
    ResourceMark rm(THREAD);
  
    Handle h_name (THREAD, JNIHandles::resolve_non_null(name));
<span class="line-modified">!   char* str = java_lang_String::as_utf8_string(h_name());</span>
  
    // Sanity check, don&#39;t expect null
    if (str == NULL) return NULL;
  
<span class="line-modified">!   // Internalize the string, converting &#39;.&#39; to &#39;/&#39; in string.</span>
<span class="line-added">+   char* p = (char*)str;</span>
<span class="line-added">+   while (*p != &#39;\0&#39;) {</span>
<span class="line-added">+       if (*p == &#39;.&#39;) {</span>
<span class="line-added">+           *p = &#39;/&#39;;</span>
<span class="line-added">+       }</span>
<span class="line-added">+       p++;</span>
<span class="line-added">+   }</span>
<span class="line-added">+ </span>
<span class="line-added">+   const int str_len = (int)(p - str);</span>
    if (str_len &gt; Symbol::max_length()) {
      // It&#39;s impossible to create this class;  the name cannot fit
      // into the constant pool.
      return NULL;
    }
<span class="line-modified">!   TempNewSymbol klass_name = SymbolTable::new_symbol(str, str_len);</span>
  
    // Security Note:
    //   The Java level wrapper will perform the necessary security check allowing
    //   us to pass the NULL as the initiating class loader.
    Handle h_loader(THREAD, JNIHandles::resolve(loader));
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1109,11 ***</span>
    }
    return (jobjectArray) JNIHandles::make_local(env, result());
  JVM_END
  
  
<span class="line-modified">! JVM_QUICK_ENTRY(jboolean, JVM_IsInterface(JNIEnv *env, jclass cls))</span>
    JVMWrapper(&quot;JVM_IsInterface&quot;);
    oop mirror = JNIHandles::resolve_non_null(cls);
    if (java_lang_Class::is_primitive(mirror)) {
      return JNI_FALSE;
    }
<span class="line-new-header">--- 1139,11 ---</span>
    }
    return (jobjectArray) JNIHandles::make_local(env, result());
  JVM_END
  
  
<span class="line-modified">! JVM_ENTRY(jboolean, JVM_IsInterface(JNIEnv *env, jclass cls))</span>
    JVMWrapper(&quot;JVM_IsInterface&quot;);
    oop mirror = JNIHandles::resolve_non_null(cls);
    if (java_lang_Class::is_primitive(mirror)) {
      return JNI_FALSE;
    }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1249,11 ***</span>
        protection_domain  = caller_klass-&gt;protection_domain();
      } else {
        protection_domain = method-&gt;method_holder()-&gt;protection_domain();
      }
  
<span class="line-modified">!     if ((!oopDesc::equals(previous_protection_domain, protection_domain)) &amp;&amp; (protection_domain != NULL)) {</span>
        local_array-&gt;push(protection_domain);
        previous_protection_domain = protection_domain;
      }
  
      if (is_privileged) break;
<span class="line-new-header">--- 1279,11 ---</span>
        protection_domain  = caller_klass-&gt;protection_domain();
      } else {
        protection_domain = method-&gt;method_holder()-&gt;protection_domain();
      }
  
<span class="line-modified">!     if ((previous_protection_domain != protection_domain) &amp;&amp; (protection_domain != NULL)) {</span>
        local_array-&gt;push(protection_domain);
        previous_protection_domain = protection_domain;
      }
  
      if (is_privileged) break;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1282,18 ***</span>
  
    return JNIHandles::make_local(env, result);
  JVM_END
  
  
<span class="line-modified">! JVM_QUICK_ENTRY(jboolean, JVM_IsArrayClass(JNIEnv *env, jclass cls))</span>
    JVMWrapper(&quot;JVM_IsArrayClass&quot;);
    Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(cls));
    return (k != NULL) &amp;&amp; k-&gt;is_array_klass() ? true : false;
  JVM_END
  
  
<span class="line-modified">! JVM_QUICK_ENTRY(jboolean, JVM_IsPrimitiveClass(JNIEnv *env, jclass cls))</span>
    JVMWrapper(&quot;JVM_IsPrimitiveClass&quot;);
    oop mirror = JNIHandles::resolve_non_null(cls);
    return (jboolean) java_lang_Class::is_primitive(mirror);
  JVM_END
  
<span class="line-new-header">--- 1312,18 ---</span>
  
    return JNIHandles::make_local(env, result);
  JVM_END
  
  
<span class="line-modified">! JVM_ENTRY(jboolean, JVM_IsArrayClass(JNIEnv *env, jclass cls))</span>
    JVMWrapper(&quot;JVM_IsArrayClass&quot;);
    Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(cls));
    return (k != NULL) &amp;&amp; k-&gt;is_array_klass() ? true : false;
  JVM_END
  
  
<span class="line-modified">! JVM_ENTRY(jboolean, JVM_IsPrimitiveClass(JNIEnv *env, jclass cls))</span>
    JVMWrapper(&quot;JVM_IsPrimitiveClass&quot;);
    oop mirror = JNIHandles::resolve_non_null(cls);
    return (jboolean) java_lang_Class::is_primitive(mirror);
  JVM_END
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1586,11 ***</span>
  
      // make sure all the symbols are properly formatted
      for (int i = 0; i &lt; num_params; i++) {
        MethodParametersElement* params = mh-&gt;method_parameters_start();
        int index = params[i].name_cp_index;
<span class="line-modified">!       bounds_check(mh-&gt;constants(), index, CHECK_NULL);</span>
  
        if (0 != index &amp;&amp; !mh-&gt;constants()-&gt;tag_at(index).is_utf8()) {
          THROW_MSG_0(vmSymbols::java_lang_IllegalArgumentException(),
                      &quot;Wrong type at constant pool index&quot;);
        }
<span class="line-new-header">--- 1616,12 ---</span>
  
      // make sure all the symbols are properly formatted
      for (int i = 0; i &lt; num_params; i++) {
        MethodParametersElement* params = mh-&gt;method_parameters_start();
        int index = params[i].name_cp_index;
<span class="line-modified">!       constantPoolHandle cp(THREAD, mh-&gt;constants());</span>
<span class="line-added">+       bounds_check(cp, index, CHECK_NULL);</span>
  
        if (0 != index &amp;&amp; !mh-&gt;constants()-&gt;tag_at(index).is_utf8()) {
          THROW_MSG_0(vmSymbols::java_lang_IllegalArgumentException(),
                      &quot;Wrong type at constant pool index&quot;);
        }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1664,10 ***</span>
<span class="line-new-header">--- 1695,58 ---</span>
    assert(out_idx == num_fields, &quot;just checking&quot;);
    return (jobjectArray) JNIHandles::make_local(env, result());
  }
  JVM_END
  
<span class="line-added">+ JVM_ENTRY(jboolean, JVM_IsRecord(JNIEnv *env, jclass cls))</span>
<span class="line-added">+ {</span>
<span class="line-added">+   JVMWrapper(&quot;JVM_IsRecord&quot;);</span>
<span class="line-added">+   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(cls));</span>
<span class="line-added">+   if (k != NULL &amp;&amp; k-&gt;is_instance_klass()) {</span>
<span class="line-added">+     InstanceKlass* ik = InstanceKlass::cast(k);</span>
<span class="line-added">+     return ik-&gt;is_record();</span>
<span class="line-added">+   } else {</span>
<span class="line-added">+     return false;</span>
<span class="line-added">+   }</span>
<span class="line-added">+ }</span>
<span class="line-added">+ JVM_END</span>
<span class="line-added">+ </span>
<span class="line-added">+ JVM_ENTRY(jobjectArray, JVM_GetRecordComponents(JNIEnv* env, jclass ofClass))</span>
<span class="line-added">+ {</span>
<span class="line-added">+   JVMWrapper(&quot;JVM_GetRecordComponents&quot;);</span>
<span class="line-added">+   Klass* c = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(ofClass));</span>
<span class="line-added">+   assert(c-&gt;is_instance_klass(), &quot;must be&quot;);</span>
<span class="line-added">+   InstanceKlass* ik = InstanceKlass::cast(c);</span>
<span class="line-added">+ </span>
<span class="line-added">+   if (ik-&gt;is_record()) {</span>
<span class="line-added">+     Array&lt;RecordComponent*&gt;* components = ik-&gt;record_components();</span>
<span class="line-added">+     assert(components != NULL, &quot;components should not be NULL&quot;);</span>
<span class="line-added">+     {</span>
<span class="line-added">+       JvmtiVMObjectAllocEventCollector oam;</span>
<span class="line-added">+       constantPoolHandle cp(THREAD, ik-&gt;constants());</span>
<span class="line-added">+       int length = components-&gt;length();</span>
<span class="line-added">+       assert(length &gt;= 0, &quot;unexpected record_components length&quot;);</span>
<span class="line-added">+       objArrayOop record_components =</span>
<span class="line-added">+         oopFactory::new_objArray(SystemDictionary::RecordComponent_klass(), length, CHECK_NULL);</span>
<span class="line-added">+       objArrayHandle components_h (THREAD, record_components);</span>
<span class="line-added">+ </span>
<span class="line-added">+       for (int x = 0; x &lt; length; x++) {</span>
<span class="line-added">+         RecordComponent* component = components-&gt;at(x);</span>
<span class="line-added">+         assert(component != NULL, &quot;unexpected NULL record component&quot;);</span>
<span class="line-added">+         oop component_oop = java_lang_reflect_RecordComponent::create(ik, component, CHECK_NULL);</span>
<span class="line-added">+         components_h-&gt;obj_at_put(x, component_oop);</span>
<span class="line-added">+       }</span>
<span class="line-added">+       return (jobjectArray)JNIHandles::make_local(components_h());</span>
<span class="line-added">+     }</span>
<span class="line-added">+   }</span>
<span class="line-added">+ </span>
<span class="line-added">+   // Return empty array if ofClass is not a record.</span>
<span class="line-added">+   objArrayOop result = oopFactory::new_objArray(SystemDictionary::RecordComponent_klass(), 0, CHECK_NULL);</span>
<span class="line-added">+   return (jobjectArray)JNIHandles::make_local(env, result);</span>
<span class="line-added">+ }</span>
<span class="line-added">+ JVM_END</span>
<span class="line-added">+ </span>
  static bool select_method(const methodHandle&amp; method, bool want_constructor) {
    if (want_constructor) {
      return (method-&gt;is_initializer() &amp;&amp; !method-&gt;is_static());
    } else {
      return  (!method-&gt;is_initializer() &amp;&amp; !method-&gt;is_overpass());
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2257,43 ***</span>
    k = JvmtiThreadState::class_to_verify_considering_redefinition(k, thread);
    return k-&gt;name()-&gt;as_utf8();
  JVM_END
  
  
<span class="line-modified">! JVM_QUICK_ENTRY(void, JVM_GetClassCPTypes(JNIEnv *env, jclass cls, unsigned char *types))</span>
    JVMWrapper(&quot;JVM_GetClassCPTypes&quot;);
    Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(cls));
    k = JvmtiThreadState::class_to_verify_considering_redefinition(k, thread);
    // types will have length zero if this is not an InstanceKlass
    // (length is determined by call to JVM_GetClassCPEntriesCount)
    if (k-&gt;is_instance_klass()) {
      ConstantPool* cp = InstanceKlass::cast(k)-&gt;constants();
      for (int index = cp-&gt;length() - 1; index &gt;= 0; index--) {
        constantTag tag = cp-&gt;tag_at(index);
<span class="line-modified">!       types[index] = (tag.is_unresolved_klass()) ? JVM_CONSTANT_Class : tag.value();</span>
      }
    }
  JVM_END
  
  
<span class="line-modified">! JVM_QUICK_ENTRY(jint, JVM_GetClassCPEntriesCount(JNIEnv *env, jclass cls))</span>
    JVMWrapper(&quot;JVM_GetClassCPEntriesCount&quot;);
    Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(cls));
    k = JvmtiThreadState::class_to_verify_considering_redefinition(k, thread);
    return (!k-&gt;is_instance_klass()) ? 0 : InstanceKlass::cast(k)-&gt;constants()-&gt;length();
  JVM_END
  
  
<span class="line-modified">! JVM_QUICK_ENTRY(jint, JVM_GetClassFieldsCount(JNIEnv *env, jclass cls))</span>
    JVMWrapper(&quot;JVM_GetClassFieldsCount&quot;);
    Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(cls));
    k = JvmtiThreadState::class_to_verify_considering_redefinition(k, thread);
    return (!k-&gt;is_instance_klass()) ? 0 : InstanceKlass::cast(k)-&gt;java_fields_count();
  JVM_END
  
  
<span class="line-modified">! JVM_QUICK_ENTRY(jint, JVM_GetClassMethodsCount(JNIEnv *env, jclass cls))</span>
    JVMWrapper(&quot;JVM_GetClassMethodsCount&quot;);
    Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(cls));
    k = JvmtiThreadState::class_to_verify_considering_redefinition(k, thread);
    return (!k-&gt;is_instance_klass()) ? 0 : InstanceKlass::cast(k)-&gt;methods()-&gt;length();
  JVM_END
<span class="line-new-header">--- 2336,43 ---</span>
    k = JvmtiThreadState::class_to_verify_considering_redefinition(k, thread);
    return k-&gt;name()-&gt;as_utf8();
  JVM_END
  
  
<span class="line-modified">! JVM_ENTRY(void, JVM_GetClassCPTypes(JNIEnv *env, jclass cls, unsigned char *types))</span>
    JVMWrapper(&quot;JVM_GetClassCPTypes&quot;);
    Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(cls));
    k = JvmtiThreadState::class_to_verify_considering_redefinition(k, thread);
    // types will have length zero if this is not an InstanceKlass
    // (length is determined by call to JVM_GetClassCPEntriesCount)
    if (k-&gt;is_instance_klass()) {
      ConstantPool* cp = InstanceKlass::cast(k)-&gt;constants();
      for (int index = cp-&gt;length() - 1; index &gt;= 0; index--) {
        constantTag tag = cp-&gt;tag_at(index);
<span class="line-modified">!       types[index] = (tag.is_unresolved_klass()) ? (unsigned char) JVM_CONSTANT_Class : tag.value();</span>
      }
    }
  JVM_END
  
  
<span class="line-modified">! JVM_ENTRY(jint, JVM_GetClassCPEntriesCount(JNIEnv *env, jclass cls))</span>
    JVMWrapper(&quot;JVM_GetClassCPEntriesCount&quot;);
    Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(cls));
    k = JvmtiThreadState::class_to_verify_considering_redefinition(k, thread);
    return (!k-&gt;is_instance_klass()) ? 0 : InstanceKlass::cast(k)-&gt;constants()-&gt;length();
  JVM_END
  
  
<span class="line-modified">! JVM_ENTRY(jint, JVM_GetClassFieldsCount(JNIEnv *env, jclass cls))</span>
    JVMWrapper(&quot;JVM_GetClassFieldsCount&quot;);
    Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(cls));
    k = JvmtiThreadState::class_to_verify_considering_redefinition(k, thread);
    return (!k-&gt;is_instance_klass()) ? 0 : InstanceKlass::cast(k)-&gt;java_fields_count();
  JVM_END
  
  
<span class="line-modified">! JVM_ENTRY(jint, JVM_GetClassMethodsCount(JNIEnv *env, jclass cls))</span>
    JVMWrapper(&quot;JVM_GetClassMethodsCount&quot;);
    Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(cls));
    k = JvmtiThreadState::class_to_verify_considering_redefinition(k, thread);
    return (!k-&gt;is_instance_klass()) ? 0 : InstanceKlass::cast(k)-&gt;methods()-&gt;length();
  JVM_END
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2302,11 ***</span>
  // The following methods, used for the verifier, are never called with
  // array klasses, so a direct cast to InstanceKlass is safe.
  // Typically, these methods are called in a loop with bounds determined
  // by the results of JVM_GetClass{Fields,Methods}Count, which return
  // zero for arrays.
<span class="line-modified">! JVM_QUICK_ENTRY(void, JVM_GetMethodIxExceptionIndexes(JNIEnv *env, jclass cls, jint method_index, unsigned short *exceptions))</span>
    JVMWrapper(&quot;JVM_GetMethodIxExceptionIndexes&quot;);
    Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(cls));
    k = JvmtiThreadState::class_to_verify_considering_redefinition(k, thread);
    Method* method = InstanceKlass::cast(k)-&gt;methods()-&gt;at(method_index);
    int length = method-&gt;checked_exceptions_length();
<span class="line-new-header">--- 2381,11 ---</span>
  // The following methods, used for the verifier, are never called with
  // array klasses, so a direct cast to InstanceKlass is safe.
  // Typically, these methods are called in a loop with bounds determined
  // by the results of JVM_GetClass{Fields,Methods}Count, which return
  // zero for arrays.
<span class="line-modified">! JVM_ENTRY(void, JVM_GetMethodIxExceptionIndexes(JNIEnv *env, jclass cls, jint method_index, unsigned short *exceptions))</span>
    JVMWrapper(&quot;JVM_GetMethodIxExceptionIndexes&quot;);
    Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(cls));
    k = JvmtiThreadState::class_to_verify_considering_redefinition(k, thread);
    Method* method = InstanceKlass::cast(k)-&gt;methods()-&gt;at(method_index);
    int length = method-&gt;checked_exceptions_length();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2317,38 ***</span>
      }
    }
  JVM_END
  
  
<span class="line-modified">! JVM_QUICK_ENTRY(jint, JVM_GetMethodIxExceptionsCount(JNIEnv *env, jclass cls, jint method_index))</span>
    JVMWrapper(&quot;JVM_GetMethodIxExceptionsCount&quot;);
    Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(cls));
    k = JvmtiThreadState::class_to_verify_considering_redefinition(k, thread);
    Method* method = InstanceKlass::cast(k)-&gt;methods()-&gt;at(method_index);
    return method-&gt;checked_exceptions_length();
  JVM_END
  
  
<span class="line-modified">! JVM_QUICK_ENTRY(void, JVM_GetMethodIxByteCode(JNIEnv *env, jclass cls, jint method_index, unsigned char *code))</span>
    JVMWrapper(&quot;JVM_GetMethodIxByteCode&quot;);
    Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(cls));
    k = JvmtiThreadState::class_to_verify_considering_redefinition(k, thread);
    Method* method = InstanceKlass::cast(k)-&gt;methods()-&gt;at(method_index);
    memcpy(code, method-&gt;code_base(), method-&gt;code_size());
  JVM_END
  
  
<span class="line-modified">! JVM_QUICK_ENTRY(jint, JVM_GetMethodIxByteCodeLength(JNIEnv *env, jclass cls, jint method_index))</span>
    JVMWrapper(&quot;JVM_GetMethodIxByteCodeLength&quot;);
    Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(cls));
    k = JvmtiThreadState::class_to_verify_considering_redefinition(k, thread);
    Method* method = InstanceKlass::cast(k)-&gt;methods()-&gt;at(method_index);
    return method-&gt;code_size();
  JVM_END
  
  
<span class="line-modified">! JVM_QUICK_ENTRY(void, JVM_GetMethodIxExceptionTableEntry(JNIEnv *env, jclass cls, jint method_index, jint entry_index, JVM_ExceptionTableEntryType *entry))</span>
    JVMWrapper(&quot;JVM_GetMethodIxExceptionTableEntry&quot;);
    Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(cls));
    k = JvmtiThreadState::class_to_verify_considering_redefinition(k, thread);
    Method* method = InstanceKlass::cast(k)-&gt;methods()-&gt;at(method_index);
    ExceptionTable extable(method);
<span class="line-new-header">--- 2396,38 ---</span>
      }
    }
  JVM_END
  
  
<span class="line-modified">! JVM_ENTRY(jint, JVM_GetMethodIxExceptionsCount(JNIEnv *env, jclass cls, jint method_index))</span>
    JVMWrapper(&quot;JVM_GetMethodIxExceptionsCount&quot;);
    Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(cls));
    k = JvmtiThreadState::class_to_verify_considering_redefinition(k, thread);
    Method* method = InstanceKlass::cast(k)-&gt;methods()-&gt;at(method_index);
    return method-&gt;checked_exceptions_length();
  JVM_END
  
  
<span class="line-modified">! JVM_ENTRY(void, JVM_GetMethodIxByteCode(JNIEnv *env, jclass cls, jint method_index, unsigned char *code))</span>
    JVMWrapper(&quot;JVM_GetMethodIxByteCode&quot;);
    Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(cls));
    k = JvmtiThreadState::class_to_verify_considering_redefinition(k, thread);
    Method* method = InstanceKlass::cast(k)-&gt;methods()-&gt;at(method_index);
    memcpy(code, method-&gt;code_base(), method-&gt;code_size());
  JVM_END
  
  
<span class="line-modified">! JVM_ENTRY(jint, JVM_GetMethodIxByteCodeLength(JNIEnv *env, jclass cls, jint method_index))</span>
    JVMWrapper(&quot;JVM_GetMethodIxByteCodeLength&quot;);
    Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(cls));
    k = JvmtiThreadState::class_to_verify_considering_redefinition(k, thread);
    Method* method = InstanceKlass::cast(k)-&gt;methods()-&gt;at(method_index);
    return method-&gt;code_size();
  JVM_END
  
  
<span class="line-modified">! JVM_ENTRY(void, JVM_GetMethodIxExceptionTableEntry(JNIEnv *env, jclass cls, jint method_index, jint entry_index, JVM_ExceptionTableEntryType *entry))</span>
    JVMWrapper(&quot;JVM_GetMethodIxExceptionTableEntry&quot;);
    Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(cls));
    k = JvmtiThreadState::class_to_verify_considering_redefinition(k, thread);
    Method* method = InstanceKlass::cast(k)-&gt;methods()-&gt;at(method_index);
    ExceptionTable extable(method);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2357,74 ***</span>
    entry-&gt;handler_pc = extable.handler_pc(entry_index);
    entry-&gt;catchType  = extable.catch_type_index(entry_index);
  JVM_END
  
  
<span class="line-modified">! JVM_QUICK_ENTRY(jint, JVM_GetMethodIxExceptionTableLength(JNIEnv *env, jclass cls, int method_index))</span>
    JVMWrapper(&quot;JVM_GetMethodIxExceptionTableLength&quot;);
    Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(cls));
    k = JvmtiThreadState::class_to_verify_considering_redefinition(k, thread);
    Method* method = InstanceKlass::cast(k)-&gt;methods()-&gt;at(method_index);
    return method-&gt;exception_table_length();
  JVM_END
  
  
<span class="line-modified">! JVM_QUICK_ENTRY(jint, JVM_GetMethodIxModifiers(JNIEnv *env, jclass cls, int method_index))</span>
    JVMWrapper(&quot;JVM_GetMethodIxModifiers&quot;);
    Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(cls));
    k = JvmtiThreadState::class_to_verify_considering_redefinition(k, thread);
    Method* method = InstanceKlass::cast(k)-&gt;methods()-&gt;at(method_index);
    return method-&gt;access_flags().as_int() &amp; JVM_RECOGNIZED_METHOD_MODIFIERS;
  JVM_END
  
  
<span class="line-modified">! JVM_QUICK_ENTRY(jint, JVM_GetFieldIxModifiers(JNIEnv *env, jclass cls, int field_index))</span>
    JVMWrapper(&quot;JVM_GetFieldIxModifiers&quot;);
    Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(cls));
    k = JvmtiThreadState::class_to_verify_considering_redefinition(k, thread);
    return InstanceKlass::cast(k)-&gt;field_access_flags(field_index) &amp; JVM_RECOGNIZED_FIELD_MODIFIERS;
  JVM_END
  
  
<span class="line-modified">! JVM_QUICK_ENTRY(jint, JVM_GetMethodIxLocalsCount(JNIEnv *env, jclass cls, int method_index))</span>
    JVMWrapper(&quot;JVM_GetMethodIxLocalsCount&quot;);
    Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(cls));
    k = JvmtiThreadState::class_to_verify_considering_redefinition(k, thread);
    Method* method = InstanceKlass::cast(k)-&gt;methods()-&gt;at(method_index);
    return method-&gt;max_locals();
  JVM_END
  
  
<span class="line-modified">! JVM_QUICK_ENTRY(jint, JVM_GetMethodIxArgsSize(JNIEnv *env, jclass cls, int method_index))</span>
    JVMWrapper(&quot;JVM_GetMethodIxArgsSize&quot;);
    Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(cls));
    k = JvmtiThreadState::class_to_verify_considering_redefinition(k, thread);
    Method* method = InstanceKlass::cast(k)-&gt;methods()-&gt;at(method_index);
    return method-&gt;size_of_parameters();
  JVM_END
  
  
<span class="line-modified">! JVM_QUICK_ENTRY(jint, JVM_GetMethodIxMaxStack(JNIEnv *env, jclass cls, int method_index))</span>
    JVMWrapper(&quot;JVM_GetMethodIxMaxStack&quot;);
    Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(cls));
    k = JvmtiThreadState::class_to_verify_considering_redefinition(k, thread);
    Method* method = InstanceKlass::cast(k)-&gt;methods()-&gt;at(method_index);
    return method-&gt;verifier_max_stack();
  JVM_END
  
  
<span class="line-modified">! JVM_QUICK_ENTRY(jboolean, JVM_IsConstructorIx(JNIEnv *env, jclass cls, int method_index))</span>
    JVMWrapper(&quot;JVM_IsConstructorIx&quot;);
    ResourceMark rm(THREAD);
    Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(cls));
    k = JvmtiThreadState::class_to_verify_considering_redefinition(k, thread);
    Method* method = InstanceKlass::cast(k)-&gt;methods()-&gt;at(method_index);
    return method-&gt;name() == vmSymbols::object_initializer_name();
  JVM_END
  
  
<span class="line-modified">! JVM_QUICK_ENTRY(jboolean, JVM_IsVMGeneratedMethodIx(JNIEnv *env, jclass cls, int method_index))</span>
    JVMWrapper(&quot;JVM_IsVMGeneratedMethodIx&quot;);
    ResourceMark rm(THREAD);
    Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(cls));
    k = JvmtiThreadState::class_to_verify_considering_redefinition(k, thread);
    Method* method = InstanceKlass::cast(k)-&gt;methods()-&gt;at(method_index);
<span class="line-new-header">--- 2436,74 ---</span>
    entry-&gt;handler_pc = extable.handler_pc(entry_index);
    entry-&gt;catchType  = extable.catch_type_index(entry_index);
  JVM_END
  
  
<span class="line-modified">! JVM_ENTRY(jint, JVM_GetMethodIxExceptionTableLength(JNIEnv *env, jclass cls, int method_index))</span>
    JVMWrapper(&quot;JVM_GetMethodIxExceptionTableLength&quot;);
    Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(cls));
    k = JvmtiThreadState::class_to_verify_considering_redefinition(k, thread);
    Method* method = InstanceKlass::cast(k)-&gt;methods()-&gt;at(method_index);
    return method-&gt;exception_table_length();
  JVM_END
  
  
<span class="line-modified">! JVM_ENTRY(jint, JVM_GetMethodIxModifiers(JNIEnv *env, jclass cls, int method_index))</span>
    JVMWrapper(&quot;JVM_GetMethodIxModifiers&quot;);
    Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(cls));
    k = JvmtiThreadState::class_to_verify_considering_redefinition(k, thread);
    Method* method = InstanceKlass::cast(k)-&gt;methods()-&gt;at(method_index);
    return method-&gt;access_flags().as_int() &amp; JVM_RECOGNIZED_METHOD_MODIFIERS;
  JVM_END
  
  
<span class="line-modified">! JVM_ENTRY(jint, JVM_GetFieldIxModifiers(JNIEnv *env, jclass cls, int field_index))</span>
    JVMWrapper(&quot;JVM_GetFieldIxModifiers&quot;);
    Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(cls));
    k = JvmtiThreadState::class_to_verify_considering_redefinition(k, thread);
    return InstanceKlass::cast(k)-&gt;field_access_flags(field_index) &amp; JVM_RECOGNIZED_FIELD_MODIFIERS;
  JVM_END
  
  
<span class="line-modified">! JVM_ENTRY(jint, JVM_GetMethodIxLocalsCount(JNIEnv *env, jclass cls, int method_index))</span>
    JVMWrapper(&quot;JVM_GetMethodIxLocalsCount&quot;);
    Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(cls));
    k = JvmtiThreadState::class_to_verify_considering_redefinition(k, thread);
    Method* method = InstanceKlass::cast(k)-&gt;methods()-&gt;at(method_index);
    return method-&gt;max_locals();
  JVM_END
  
  
<span class="line-modified">! JVM_ENTRY(jint, JVM_GetMethodIxArgsSize(JNIEnv *env, jclass cls, int method_index))</span>
    JVMWrapper(&quot;JVM_GetMethodIxArgsSize&quot;);
    Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(cls));
    k = JvmtiThreadState::class_to_verify_considering_redefinition(k, thread);
    Method* method = InstanceKlass::cast(k)-&gt;methods()-&gt;at(method_index);
    return method-&gt;size_of_parameters();
  JVM_END
  
  
<span class="line-modified">! JVM_ENTRY(jint, JVM_GetMethodIxMaxStack(JNIEnv *env, jclass cls, int method_index))</span>
    JVMWrapper(&quot;JVM_GetMethodIxMaxStack&quot;);
    Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(cls));
    k = JvmtiThreadState::class_to_verify_considering_redefinition(k, thread);
    Method* method = InstanceKlass::cast(k)-&gt;methods()-&gt;at(method_index);
    return method-&gt;verifier_max_stack();
  JVM_END
  
  
<span class="line-modified">! JVM_ENTRY(jboolean, JVM_IsConstructorIx(JNIEnv *env, jclass cls, int method_index))</span>
    JVMWrapper(&quot;JVM_IsConstructorIx&quot;);
    ResourceMark rm(THREAD);
    Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(cls));
    k = JvmtiThreadState::class_to_verify_considering_redefinition(k, thread);
    Method* method = InstanceKlass::cast(k)-&gt;methods()-&gt;at(method_index);
    return method-&gt;name() == vmSymbols::object_initializer_name();
  JVM_END
  
  
<span class="line-modified">! JVM_ENTRY(jboolean, JVM_IsVMGeneratedMethodIx(JNIEnv *env, jclass cls, int method_index))</span>
    JVMWrapper(&quot;JVM_IsVMGeneratedMethodIx&quot;);
    ResourceMark rm(THREAD);
    Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(cls));
    k = JvmtiThreadState::class_to_verify_considering_redefinition(k, thread);
    Method* method = InstanceKlass::cast(k)-&gt;methods()-&gt;at(method_index);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2597,11 ***</span>
    ShouldNotReachHere();
    return 0;
  JVM_END
  
  
<span class="line-modified">! JVM_QUICK_ENTRY(jint, JVM_GetCPMethodModifiers(JNIEnv *env, jclass cls, int cp_index, jclass called_cls))</span>
    JVMWrapper(&quot;JVM_GetCPMethodModifiers&quot;);
    Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(cls));
    Klass* k_called = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(called_cls));
    k        = JvmtiThreadState::class_to_verify_considering_redefinition(k, thread);
    k_called = JvmtiThreadState::class_to_verify_considering_redefinition(k_called, thread);
<span class="line-new-header">--- 2676,11 ---</span>
    ShouldNotReachHere();
    return 0;
  JVM_END
  
  
<span class="line-modified">! JVM_ENTRY(jint, JVM_GetCPMethodModifiers(JNIEnv *env, jclass cls, int cp_index, jclass called_cls))</span>
    JVMWrapper(&quot;JVM_GetCPMethodModifiers&quot;);
    Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(cls));
    Klass* k_called = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(called_cls));
    k        = JvmtiThreadState::class_to_verify_considering_redefinition(k, thread);
    k_called = JvmtiThreadState::class_to_verify_considering_redefinition(k_called, thread);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2705,11 ***</span>
  void jio_print(const char* s, size_t len) {
    // Try to make this function as atomic as possible.
    if (Arguments::vfprintf_hook() != NULL) {
      jio_fprintf(defaultStream::output_stream(), &quot;%.*s&quot;, (int)len, s);
    } else {
<span class="line-modified">!     // Make an unused local variable to avoid warning from gcc 4.x compiler.</span>
      size_t count = ::write(defaultStream::output_fd(), s, (int)len);
    }
  }
  
  } // Extern C
<span class="line-new-header">--- 2784,11 ---</span>
  void jio_print(const char* s, size_t len) {
    // Try to make this function as atomic as possible.
    if (Arguments::vfprintf_hook() != NULL) {
      jio_fprintf(defaultStream::output_stream(), &quot;%.*s&quot;, (int)len, s);
    } else {
<span class="line-modified">!     // Make an unused local variable to avoid warning from gcc compiler.</span>
      size_t count = ::write(defaultStream::output_fd(), s, (int)len);
    }
  }
  
  } // Extern C
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2828,11 ***</span>
    oop java_thread = NULL;
    JavaThread* receiver = NULL;
    bool is_alive = tlh.cv_internal_thread_to_JavaThread(jthread, &amp;receiver, &amp;java_thread);
    Events::log_exception(thread,
                          &quot;JVM_StopThread thread JavaThread &quot; INTPTR_FORMAT &quot; as oop &quot; INTPTR_FORMAT &quot; [exception &quot; INTPTR_FORMAT &quot;]&quot;,
<span class="line-modified">!                         p2i(receiver), p2i((address)java_thread), p2i(throwable));</span>
  
    if (is_alive) {
      // jthread refers to a live JavaThread.
      if (thread == receiver) {
        // Exception is getting thrown at self so no VM_Operation needed.
<span class="line-new-header">--- 2907,11 ---</span>
    oop java_thread = NULL;
    JavaThread* receiver = NULL;
    bool is_alive = tlh.cv_internal_thread_to_JavaThread(jthread, &amp;receiver, &amp;java_thread);
    Events::log_exception(thread,
                          &quot;JVM_StopThread thread JavaThread &quot; INTPTR_FORMAT &quot; as oop &quot; INTPTR_FORMAT &quot; [exception &quot; INTPTR_FORMAT &quot;]&quot;,
<span class="line-modified">!                         p2i(receiver), p2i(java_thread), p2i(throwable));</span>
  
    if (is_alive) {
      // jthread refers to a live JavaThread.
      if (thread == receiver) {
        // Exception is getting thrown at self so no VM_Operation needed.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2869,11 ***</span>
    JavaThread* receiver = NULL;
    bool is_alive = tlh.cv_internal_thread_to_JavaThread(jthread, &amp;receiver, NULL);
    if (is_alive) {
      // jthread refers to a live JavaThread.
      {
<span class="line-modified">!       MutexLockerEx ml(receiver-&gt;SR_lock(), Mutex::_no_safepoint_check_flag);</span>
        if (receiver-&gt;is_external_suspend()) {
          // Don&#39;t allow nested external suspend requests. We can&#39;t return
          // an error from this interface so just ignore the problem.
          return;
        }
<span class="line-new-header">--- 2948,11 ---</span>
    JavaThread* receiver = NULL;
    bool is_alive = tlh.cv_internal_thread_to_JavaThread(jthread, &amp;receiver, NULL);
    if (is_alive) {
      // jthread refers to a live JavaThread.
      {
<span class="line-modified">!       MutexLocker ml(receiver-&gt;SR_lock(), Mutex::_no_safepoint_check_flag);</span>
        if (receiver-&gt;is_external_suspend()) {
          // Don&#39;t allow nested external suspend requests. We can&#39;t return
          // an error from this interface so just ignore the problem.
          return;
        }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2966,11 ***</span>
  
    if (millis &lt; 0) {
      THROW_MSG(vmSymbols::java_lang_IllegalArgumentException(), &quot;timeout value is negative&quot;);
    }
  
<span class="line-modified">!   if (Thread::is_interrupted (THREAD, true) &amp;&amp; !HAS_PENDING_EXCEPTION) {</span>
      THROW_MSG(vmSymbols::java_lang_InterruptedException(), &quot;sleep interrupted&quot;);
    }
  
    // Save current thread state and restore it at the end of this block.
    // And set new thread state to SLEEPING.
<span class="line-new-header">--- 3045,11 ---</span>
  
    if (millis &lt; 0) {
      THROW_MSG(vmSymbols::java_lang_IllegalArgumentException(), &quot;timeout value is negative&quot;);
    }
  
<span class="line-modified">!   if (thread-&gt;is_interrupted(true) &amp;&amp; !HAS_PENDING_EXCEPTION) {</span>
      THROW_MSG(vmSymbols::java_lang_InterruptedException(), &quot;sleep interrupted&quot;);
    }
  
    // Save current thread state and restore it at the end of this block.
    // And set new thread state to SLEEPING.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2982,11 ***</span>
    if (millis == 0) {
      os::naked_yield();
    } else {
      ThreadState old_state = thread-&gt;osthread()-&gt;get_state();
      thread-&gt;osthread()-&gt;set_state(SLEEPING);
<span class="line-modified">!     if (os::sleep(thread, millis, true) == OS_INTRPT) {</span>
        // An asynchronous exception (e.g., ThreadDeathException) could have been thrown on
        // us while we were sleeping. We do not overwrite those.
        if (!HAS_PENDING_EXCEPTION) {
          if (event.should_commit()) {
            post_thread_sleep_event(&amp;event, millis);
<span class="line-new-header">--- 3061,11 ---</span>
    if (millis == 0) {
      os::naked_yield();
    } else {
      ThreadState old_state = thread-&gt;osthread()-&gt;get_state();
      thread-&gt;osthread()-&gt;set_state(SLEEPING);
<span class="line-modified">!     if (!thread-&gt;sleep(millis)) { // interrupted</span>
        // An asynchronous exception (e.g., ThreadDeathException) could have been thrown on
        // us while we were sleeping. We do not overwrite those.
        if (!HAS_PENDING_EXCEPTION) {
          if (event.should_commit()) {
            post_thread_sleep_event(&amp;event, millis);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3011,62 ***</span>
    oop jthread = thread-&gt;threadObj();
    assert (thread != NULL, &quot;no current thread!&quot;);
    return JNIHandles::make_local(env, jthread);
  JVM_END
  
<span class="line-removed">- </span>
<span class="line-removed">- JVM_ENTRY(jint, JVM_CountStackFrames(JNIEnv* env, jobject jthread))</span>
<span class="line-removed">-   JVMWrapper(&quot;JVM_CountStackFrames&quot;);</span>
<span class="line-removed">- </span>
<span class="line-removed">-   uint32_t debug_bits = 0;</span>
<span class="line-removed">-   ThreadsListHandle tlh(thread);</span>
<span class="line-removed">-   JavaThread* receiver = NULL;</span>
<span class="line-removed">-   bool is_alive = tlh.cv_internal_thread_to_JavaThread(jthread, &amp;receiver, NULL);</span>
<span class="line-removed">-   int count = 0;</span>
<span class="line-removed">-   if (is_alive) {</span>
<span class="line-removed">-     // jthread refers to a live JavaThread.</span>
<span class="line-removed">-     if (receiver-&gt;is_thread_fully_suspended(true /* wait for suspend completion */, &amp;debug_bits)) {</span>
<span class="line-removed">-       // Count all java activation, i.e., number of vframes.</span>
<span class="line-removed">-       for (vframeStream vfst(receiver); !vfst.at_end(); vfst.next()) {</span>
<span class="line-removed">-         // Native frames are not counted.</span>
<span class="line-removed">-         if (!vfst.method()-&gt;is_native()) count++;</span>
<span class="line-removed">-       }</span>
<span class="line-removed">-     } else {</span>
<span class="line-removed">-       THROW_MSG_0(vmSymbols::java_lang_IllegalThreadStateException(),</span>
<span class="line-removed">-                   &quot;this thread is not suspended&quot;);</span>
<span class="line-removed">-     }</span>
<span class="line-removed">-   }</span>
<span class="line-removed">-   // Implied else: if JavaThread is not alive simply return a count of 0.</span>
<span class="line-removed">- </span>
<span class="line-removed">-   return count;</span>
<span class="line-removed">- JVM_END</span>
<span class="line-removed">- </span>
<span class="line-removed">- </span>
  JVM_ENTRY(void, JVM_Interrupt(JNIEnv* env, jobject jthread))
    JVMWrapper(&quot;JVM_Interrupt&quot;);
  
    ThreadsListHandle tlh(thread);
    JavaThread* receiver = NULL;
    bool is_alive = tlh.cv_internal_thread_to_JavaThread(jthread, &amp;receiver, NULL);
    if (is_alive) {
      // jthread refers to a live JavaThread.
<span class="line-modified">!     Thread::interrupt(receiver);</span>
<span class="line-removed">-   }</span>
<span class="line-removed">- JVM_END</span>
<span class="line-removed">- </span>
<span class="line-removed">- </span>
<span class="line-removed">- JVM_QUICK_ENTRY(jboolean, JVM_IsInterrupted(JNIEnv* env, jobject jthread, jboolean clear_interrupted))</span>
<span class="line-removed">-   JVMWrapper(&quot;JVM_IsInterrupted&quot;);</span>
<span class="line-removed">- </span>
<span class="line-removed">-   ThreadsListHandle tlh(thread);</span>
<span class="line-removed">-   JavaThread* receiver = NULL;</span>
<span class="line-removed">-   bool is_alive = tlh.cv_internal_thread_to_JavaThread(jthread, &amp;receiver, NULL);</span>
<span class="line-removed">-   if (is_alive) {</span>
<span class="line-removed">-     // jthread refers to a live JavaThread.</span>
<span class="line-removed">-     return (jboolean) Thread::is_interrupted(receiver, clear_interrupted != 0);</span>
<span class="line-removed">-   } else {</span>
<span class="line-removed">-     return JNI_FALSE;</span>
    }
  JVM_END
  
  
  // Return true iff the current thread has locked the object passed in
<span class="line-new-header">--- 3090,19 ---</span>
    oop jthread = thread-&gt;threadObj();
    assert (thread != NULL, &quot;no current thread!&quot;);
    return JNIHandles::make_local(env, jthread);
  JVM_END
  
  JVM_ENTRY(void, JVM_Interrupt(JNIEnv* env, jobject jthread))
    JVMWrapper(&quot;JVM_Interrupt&quot;);
  
    ThreadsListHandle tlh(thread);
    JavaThread* receiver = NULL;
    bool is_alive = tlh.cv_internal_thread_to_JavaThread(jthread, &amp;receiver, NULL);
    if (is_alive) {
      // jthread refers to a live JavaThread.
<span class="line-modified">!     receiver-&gt;interrupt();</span>
    }
  JVM_END
  
  
  // Return true iff the current thread has locked the object passed in
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3183,27 ***</span>
  
  
  JVM_ENTRY(jobject, JVM_GetAndClearReferencePendingList(JNIEnv* env))
    JVMWrapper(&quot;JVM_GetAndClearReferencePendingList&quot;);
  
<span class="line-modified">!   MonitorLockerEx ml(Heap_lock);</span>
    oop ref = Universe::reference_pending_list();
    if (ref != NULL) {
      Universe::set_reference_pending_list(NULL);
    }
    return JNIHandles::make_local(env, ref);
  JVM_END
  
  JVM_ENTRY(jboolean, JVM_HasReferencePendingList(JNIEnv* env))
    JVMWrapper(&quot;JVM_HasReferencePendingList&quot;);
<span class="line-modified">!   MonitorLockerEx ml(Heap_lock);</span>
    return Universe::has_reference_pending_list();
  JVM_END
  
  JVM_ENTRY(void, JVM_WaitForReferencePendingList(JNIEnv* env))
    JVMWrapper(&quot;JVM_WaitForReferencePendingList&quot;);
<span class="line-modified">!   MonitorLockerEx ml(Heap_lock);</span>
    while (!Universe::has_reference_pending_list()) {
      ml.wait();
    }
  JVM_END
  
<span class="line-new-header">--- 3219,27 ---</span>
  
  
  JVM_ENTRY(jobject, JVM_GetAndClearReferencePendingList(JNIEnv* env))
    JVMWrapper(&quot;JVM_GetAndClearReferencePendingList&quot;);
  
<span class="line-modified">!   MonitorLocker ml(Heap_lock);</span>
    oop ref = Universe::reference_pending_list();
    if (ref != NULL) {
      Universe::set_reference_pending_list(NULL);
    }
    return JNIHandles::make_local(env, ref);
  JVM_END
  
  JVM_ENTRY(jboolean, JVM_HasReferencePendingList(JNIEnv* env))
    JVMWrapper(&quot;JVM_HasReferencePendingList&quot;);
<span class="line-modified">!   MonitorLocker ml(Heap_lock);</span>
    return Universe::has_reference_pending_list();
  JVM_END
  
  JVM_ENTRY(void, JVM_WaitForReferencePendingList(JNIEnv* env))
    JVMWrapper(&quot;JVM_WaitForReferencePendingList&quot;);
<span class="line-modified">!   MonitorLocker ml(Heap_lock);</span>
    while (!Universe::has_reference_pending_list()) {
      ml.wait();
    }
  JVM_END
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3345,23 ***</span>
                                  vmSymbols::java_lang_UnsatisfiedLinkError(),
                                  msg, Exceptions::unsafe_to_utf8);
  
      THROW_HANDLE_0(h_exception);
    }
    return load_result;
  JVM_END
  
  
  JVM_LEAF(void, JVM_UnloadLibrary(void* handle))
    JVMWrapper(&quot;JVM_UnloadLibrary&quot;);
    os::dll_unload(handle);
  JVM_END
  
  
  JVM_LEAF(void*, JVM_FindLibraryEntry(void* handle, const char* name))
    JVMWrapper(&quot;JVM_FindLibraryEntry&quot;);
<span class="line-modified">!   return os::dll_lookup(handle, name);</span>
  JVM_END
  
  
  // JNI version ///////////////////////////////////////////////////////////////////////////////
  
<span class="line-new-header">--- 3381,29 ---</span>
                                  vmSymbols::java_lang_UnsatisfiedLinkError(),
                                  msg, Exceptions::unsafe_to_utf8);
  
      THROW_HANDLE_0(h_exception);
    }
<span class="line-added">+   log_info(library)(&quot;Loaded library %s, handle &quot; INTPTR_FORMAT, name, p2i(load_result));</span>
    return load_result;
  JVM_END
  
  
  JVM_LEAF(void, JVM_UnloadLibrary(void* handle))
    JVMWrapper(&quot;JVM_UnloadLibrary&quot;);
    os::dll_unload(handle);
<span class="line-added">+   log_info(library)(&quot;Unloaded library with handle &quot; INTPTR_FORMAT, p2i(handle));</span>
  JVM_END
  
  
  JVM_LEAF(void*, JVM_FindLibraryEntry(void* handle, const char* name))
    JVMWrapper(&quot;JVM_FindLibraryEntry&quot;);
<span class="line-modified">!   void* find_result = os::dll_lookup(handle, name);</span>
<span class="line-added">+   log_info(library)(&quot;%s %s in library with handle &quot; INTPTR_FORMAT,</span>
<span class="line-added">+                     find_result != NULL ? &quot;Found&quot; : &quot;Failed to find&quot;,</span>
<span class="line-added">+                     name, p2i(handle));</span>
<span class="line-added">+   return find_result;</span>
  JVM_END
  
  
  // JNI version ///////////////////////////////////////////////////////////////////////////////
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3381,49 ***</span>
    oop result = StringTable::intern(string, CHECK_NULL);
    return (jstring) JNIHandles::make_local(env, result);
  JVM_END
  
  
<span class="line-modified">! // Raw monitor support //////////////////////////////////////////////////////////////////////</span>
  
<span class="line-modified">! // The lock routine below calls lock_without_safepoint_check in order to get a raw lock</span>
<span class="line-modified">! // without interfering with the safepoint mechanism. The routines are not JVM_LEAF because</span>
<span class="line-modified">! // they might be called by non-java threads. The JVM_LEAF installs a NoHandleMark check</span>
<span class="line-modified">! // that only works with java threads.</span>
  
  
  JNIEXPORT void* JNICALL JVM_RawMonitorCreate(void) {
    VM_Exit::block_if_vm_exited();
    JVMWrapper(&quot;JVM_RawMonitorCreate&quot;);
<span class="line-modified">!   void *mon = new Mutex(Mutex::native, &quot;JVM_RawMonitorCreate&quot;);</span>
    TSAN_RUNTIME_ONLY(TSAN_RAW_LOCK_CREATE(mon));
    return mon;
  }
  
  
  JNIEXPORT void JNICALL  JVM_RawMonitorDestroy(void *mon) {
    VM_Exit::block_if_vm_exited();
    JVMWrapper(&quot;JVM_RawMonitorDestroy&quot;);
    TSAN_RUNTIME_ONLY(TSAN_RAW_LOCK_DESTROY(mon));
<span class="line-modified">!   delete ((Mutex*) mon);</span>
  }
  
  
  JNIEXPORT jint JNICALL JVM_RawMonitorEnter(void *mon) {
    VM_Exit::block_if_vm_exited();
    JVMWrapper(&quot;JVM_RawMonitorEnter&quot;);
<span class="line-modified">!   ((Mutex*) mon)-&gt;jvm_raw_lock();</span>
    TSAN_RUNTIME_ONLY(TSAN_RAW_LOCK_ACQUIRED(mon));
    return 0;
  }
  
  
  JNIEXPORT void JNICALL JVM_RawMonitorExit(void *mon) {
    VM_Exit::block_if_vm_exited();
    JVMWrapper(&quot;JVM_RawMonitorExit&quot;);
    TSAN_RUNTIME_ONLY(TSAN_RAW_LOCK_RELEASED(mon));
<span class="line-modified">!   ((Mutex*) mon)-&gt;jvm_raw_unlock();</span>
  }
  
  
  // Shared JNI/JVM entry points //////////////////////////////////////////////////////////////
  
<span class="line-new-header">--- 3423,50 ---</span>
    oop result = StringTable::intern(string, CHECK_NULL);
    return (jstring) JNIHandles::make_local(env, result);
  JVM_END
  
  
<span class="line-modified">! // VM Raw monitor support //////////////////////////////////////////////////////////////////////</span>
  
<span class="line-modified">! // VM Raw monitors (not to be confused with JvmtiRawMonitors) are a simple mutual exclusion</span>
<span class="line-modified">! // lock (not actually monitors: no wait/notify) that is exported by the VM for use by JDK</span>
<span class="line-modified">! // library code. They may be used by JavaThreads and non-JavaThreads and do not participate</span>
<span class="line-modified">! // in the safepoint protocol, thread suspension, thread interruption, or anything of that</span>
<span class="line-added">+ // nature. JavaThreads will be &quot;in native&quot; when using this API from JDK code.</span>
  
  
  JNIEXPORT void* JNICALL JVM_RawMonitorCreate(void) {
    VM_Exit::block_if_vm_exited();
    JVMWrapper(&quot;JVM_RawMonitorCreate&quot;);
<span class="line-modified">!   void *mon = new os::PlatformMutex();</span>
    TSAN_RUNTIME_ONLY(TSAN_RAW_LOCK_CREATE(mon));
    return mon;
  }
  
  
  JNIEXPORT void JNICALL  JVM_RawMonitorDestroy(void *mon) {
    VM_Exit::block_if_vm_exited();
    JVMWrapper(&quot;JVM_RawMonitorDestroy&quot;);
    TSAN_RUNTIME_ONLY(TSAN_RAW_LOCK_DESTROY(mon));
<span class="line-modified">!   delete ((os::PlatformMutex*) mon);</span>
  }
  
  
  JNIEXPORT jint JNICALL JVM_RawMonitorEnter(void *mon) {
    VM_Exit::block_if_vm_exited();
    JVMWrapper(&quot;JVM_RawMonitorEnter&quot;);
<span class="line-modified">!   ((os::PlatformMutex*) mon)-&gt;lock();</span>
    TSAN_RUNTIME_ONLY(TSAN_RAW_LOCK_ACQUIRED(mon));
    return 0;
  }
  
  
  JNIEXPORT void JNICALL JVM_RawMonitorExit(void *mon) {
    VM_Exit::block_if_vm_exited();
    JVMWrapper(&quot;JVM_RawMonitorExit&quot;);
    TSAN_RUNTIME_ONLY(TSAN_RAW_LOCK_RELEASED(mon));
<span class="line-modified">!   ((os::PlatformMutex*) mon)-&gt;unlock();</span>
  }
  
  
  // Shared JNI/JVM entry points //////////////////////////////////////////////////////////////
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3623,24 ***</span>
    }
    return (jobjectArray) JNIHandles::make_local(dest());
  }
  JVM_END
  
<span class="line-removed">- JVM_ENTRY(void, JVM_GetVersionInfo(JNIEnv* env, jvm_version_info* info, size_t info_size))</span>
<span class="line-removed">- {</span>
<span class="line-removed">-   memset(info, 0, info_size);</span>
<span class="line-removed">- </span>
<span class="line-removed">-   info-&gt;jvm_version = VM_Version::jvm_version();</span>
<span class="line-removed">-   info-&gt;patch_version = VM_Version::vm_patch_version();</span>
<span class="line-removed">- </span>
<span class="line-removed">-   // when we add a new capability in the jvm_version_info struct, we should also</span>
<span class="line-removed">-   // consider to expose this new capability in the sun.rt.jvmCapabilities jvmstat</span>
<span class="line-removed">-   // counter defined in runtimeService.cpp.</span>
<span class="line-removed">-   info-&gt;is_attach_supported = AttachListener::is_attach_supported();</span>
<span class="line-removed">- }</span>
<span class="line-removed">- JVM_END</span>
<span class="line-removed">- </span>
  // Returns an array of java.lang.String objects containing the input arguments to the VM.
  JVM_ENTRY(jobjectArray, JVM_GetVmArguments(JNIEnv *env))
    ResourceMark rm(THREAD);
  
    if (Arguments::num_jvm_args() == 0 &amp;&amp; Arguments::num_jvm_flags() == 0) {
<span class="line-new-header">--- 3666,10 ---</span>
</pre>
<center><a href="../oops/instanceKlass.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="jvmtiEnv.cpp.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
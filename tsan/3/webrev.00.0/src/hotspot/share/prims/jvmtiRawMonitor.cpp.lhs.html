<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/share/prims/jvmtiRawMonitor.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
    <script type="text/javascript" src="../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
<a name="1" id="anc1"></a><span class="line-modified">  2  * Copyright (c) 2003, 2018, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #include &quot;precompiled.hpp&quot;
 26 #include &quot;memory/allocation.inline.hpp&quot;
 27 #include &quot;prims/jvmtiRawMonitor.hpp&quot;
 28 #include &quot;runtime/atomic.hpp&quot;
 29 #include &quot;runtime/interfaceSupport.inline.hpp&quot;
 30 #include &quot;runtime/orderAccess.hpp&quot;
 31 #include &quot;runtime/thread.inline.hpp&quot;
 32 #if INCLUDE_TSAN
 33 #include &quot;tsan/tsan.hpp&quot;
 34 #endif  // INCLUDE_TSAN
 35 
<a name="2" id="anc2"></a><span class="line-modified"> 36 GrowableArray&lt;JvmtiRawMonitor*&gt; *JvmtiPendingMonitors::_monitors = new (ResourceObj::C_HEAP, mtInternal) GrowableArray&lt;JvmtiRawMonitor*&gt;(1,true);</span>






 37 
 38 void JvmtiPendingMonitors::transition_raw_monitors() {
 39   assert((Threads::number_of_threads()==1),
<a name="3" id="anc3"></a><span class="line-modified"> 40          &quot;Java thread has not created yet or more than one java thread \</span>
<span class="line-modified"> 41 is running. Raw monitor transition will not work&quot;);</span>
<span class="line-modified"> 42   JavaThread *current_java_thread = JavaThread::current();</span>
 43   assert(current_java_thread-&gt;thread_state() == _thread_in_vm, &quot;Must be in vm&quot;);
<a name="4" id="anc4"></a><span class="line-modified"> 44   {</span>
<span class="line-modified"> 45     ThreadBlockInVM __tbivm(current_java_thread);</span>
<span class="line-modified"> 46     for(int i=0; i&lt; count(); i++) {</span>
<span class="line-modified"> 47       JvmtiRawMonitor *rmonitor = monitors()-&gt;at(i);</span>
<span class="line-removed"> 48       int r = rmonitor-&gt;raw_enter(current_java_thread);</span>
<span class="line-removed"> 49       assert(r == ObjectMonitor::OM_OK, &quot;raw_enter should have worked&quot;);</span>
<span class="line-removed"> 50       TSAN_RUNTIME_ONLY(TSAN_RAW_LOCK_ACQUIRED(rmonitor));</span>
<span class="line-removed"> 51     }</span>
 52   }
 53   // pending monitors are converted to real monitor so delete them all.
 54   dispose();
 55 }
 56 
 57 //
 58 // class JvmtiRawMonitor
 59 //
 60 
<a name="5" id="anc5"></a><span class="line-modified"> 61 JvmtiRawMonitor::JvmtiRawMonitor(const char *name) {</span>






 62 #ifdef ASSERT
 63   _name = strcpy(NEW_C_HEAP_ARRAY(char, strlen(name) + 1, mtInternal), name);
<a name="6" id="anc6"></a><span class="line-removed"> 64 #else</span>
<span class="line-removed"> 65   _name = NULL;</span>
<span class="line-removed"> 66 #endif</span>
 67   _magic = JVMTI_RM_MAGIC;
 68 }
 69 
 70 JvmtiRawMonitor::~JvmtiRawMonitor() {
 71 #ifdef ASSERT
 72   FreeHeap(_name);
 73 #endif
 74   _magic = 0;
 75 }
 76 
 77 
 78 bool
 79 JvmtiRawMonitor::is_valid() {
 80   int value = 0;
 81 
 82   // This object might not be a JvmtiRawMonitor so we can&#39;t assume
 83   // the _magic field is properly aligned. Get the value in a safe
 84   // way and then check against JVMTI_RM_MAGIC.
 85 
 86   switch (sizeof(_magic)) {
 87   case 2:
 88     value = Bytes::get_native_u2((address)&amp;_magic);
 89     break;
 90 
 91   case 4:
 92     value = Bytes::get_native_u4((address)&amp;_magic);
 93     break;
 94 
 95   case 8:
 96     value = Bytes::get_native_u8((address)&amp;_magic);
 97     break;
 98 
 99   default:
100     guarantee(false, &quot;_magic field is an unexpected size&quot;);
101   }
102 
103   return value == JVMTI_RM_MAGIC;
104 }
105 
106 // -------------------------------------------------------------------------
<a name="7" id="anc7"></a><span class="line-modified">107 // The raw monitor subsystem is entirely distinct from normal</span>
<span class="line-modified">108 // java-synchronization or jni-synchronization.  raw monitors are not</span>
109 // associated with objects.  They can be implemented in any manner
110 // that makes sense.  The original implementors decided to piggy-back
<a name="8" id="anc8"></a><span class="line-modified">111 // the raw-monitor implementation on the existing Java objectMonitor mechanism.</span>
<span class="line-modified">112 // This flaw needs to fixed.  We should reimplement raw monitors as sui-generis.</span>
<span class="line-removed">113 // Specifically, we should not implement raw monitors via java monitors.</span>
<span class="line-removed">114 // Time permitting, we should disentangle and deconvolve the two implementations</span>
<span class="line-removed">115 // and move the resulting raw monitor implementation over to the JVMTI directories.</span>
<span class="line-removed">116 // Ideally, the raw monitor implementation would be built on top of</span>
<span class="line-removed">117 // park-unpark and nothing else.</span>
<span class="line-removed">118 //</span>
<span class="line-removed">119 // raw monitors are used mainly by JVMTI</span>
<span class="line-removed">120 // The raw monitor implementation borrows the ObjectMonitor structure,</span>
<span class="line-removed">121 // but the operators are degenerate and extremely simple.</span>
<span class="line-removed">122 //</span>
<span class="line-removed">123 // Mixed use of a single objectMonitor instance -- as both a raw monitor</span>
<span class="line-removed">124 // and a normal java monitor -- is not permissible.</span>
125 //
126 // Note that we use the single RawMonitor_lock to protect queue operations for
127 // _all_ raw monitors.  This is a scalability impediment, but since raw monitor usage
<a name="9" id="anc9"></a><span class="line-modified">128 // is deprecated and rare, this is not of concern.  The RawMonitor_lock can not</span>
129 // be held indefinitely.  The critical sections must be short and bounded.
130 //
131 // -------------------------------------------------------------------------
132 
<a name="10" id="anc10"></a><span class="line-modified">133 int JvmtiRawMonitor::SimpleEnter (Thread * Self) {</span>
134   for (;;) {
<a name="11" id="anc11"></a><span class="line-modified">135     if (Atomic::replace_if_null(Self, &amp;_owner)) {</span>
<span class="line-modified">136        return OS_OK ;</span>
137     }
138 
<a name="12" id="anc12"></a><span class="line-modified">139     ObjectWaiter Node (Self) ;</span>
<span class="line-modified">140     Self-&gt;_ParkEvent-&gt;reset() ;     // strictly optional</span>
<span class="line-modified">141     Node.TState = ObjectWaiter::TS_ENTER ;</span>
<span class="line-modified">142 </span>
<span class="line-modified">143     RawMonitor_lock-&gt;lock_without_safepoint_check() ;</span>
<span class="line-modified">144     Node._next  = _EntryList ;</span>
<span class="line-modified">145     _EntryList  = &amp;Node ;</span>
<span class="line-modified">146     OrderAccess::fence() ;</span>
<span class="line-modified">147     if (_owner == NULL &amp;&amp; Atomic::replace_if_null(Self, &amp;_owner)) {</span>
<span class="line-modified">148         _EntryList = Node._next ;</span>
<span class="line-modified">149         RawMonitor_lock-&gt;unlock() ;</span>
<span class="line-modified">150         return OS_OK ;</span>
151     }
<a name="13" id="anc13"></a><span class="line-modified">152     RawMonitor_lock-&gt;unlock() ;</span>
<span class="line-modified">153     while (Node.TState == ObjectWaiter::TS_ENTER) {</span>
<span class="line-modified">154        Self-&gt;_ParkEvent-&gt;park() ;</span>
155     }
156   }
157 }
158 
<a name="14" id="anc14"></a><span class="line-modified">159 int JvmtiRawMonitor::SimpleExit (Thread * Self) {</span>
<span class="line-modified">160   guarantee (_owner == Self, &quot;invariant&quot;) ;</span>
<span class="line-modified">161   OrderAccess::release_store(&amp;_owner, (void*)NULL) ;</span>
<span class="line-modified">162   OrderAccess::fence() ;</span>
<span class="line-modified">163   if (_EntryList == NULL) return OS_OK ;</span>
<span class="line-modified">164   ObjectWaiter * w ;</span>

165 
<a name="15" id="anc15"></a><span class="line-modified">166   RawMonitor_lock-&gt;lock_without_safepoint_check() ;</span>
<span class="line-modified">167   w = _EntryList ;</span>
168   if (w != NULL) {
<a name="16" id="anc16"></a><span class="line-modified">169       _EntryList = w-&gt;_next ;</span>
170   }
<a name="17" id="anc17"></a><span class="line-modified">171   RawMonitor_lock-&gt;unlock() ;</span>
172   if (w != NULL) {
<a name="18" id="anc18"></a><span class="line-modified">173       guarantee (w -&gt;TState == ObjectWaiter::TS_ENTER, &quot;invariant&quot;) ;</span>
<span class="line-modified">174       ParkEvent * ev = w-&gt;_event ;</span>
<span class="line-modified">175       w-&gt;TState = ObjectWaiter::TS_RUN ;</span>
<span class="line-modified">176       OrderAccess::fence() ;</span>
<span class="line-modified">177       ev-&gt;unpark() ;</span>





178   }
<a name="19" id="anc19"></a><span class="line-modified">179   return OS_OK ;</span>
180 }
181 
<a name="20" id="anc20"></a><span class="line-modified">182 int JvmtiRawMonitor::SimpleWait (Thread * Self, jlong millis) {</span>
<span class="line-modified">183   guarantee (_owner == Self  , &quot;invariant&quot;) ;</span>
<span class="line-modified">184   guarantee (_recursions == 0, &quot;invariant&quot;) ;</span>
<span class="line-modified">185 </span>
<span class="line-modified">186   ObjectWaiter Node (Self) ;</span>
<span class="line-modified">187   Node._notified = 0 ;</span>
<span class="line-modified">188   Node.TState    = ObjectWaiter::TS_WAIT ;</span>
<span class="line-modified">189 </span>
<span class="line-removed">190   RawMonitor_lock-&gt;lock_without_safepoint_check() ;</span>
<span class="line-removed">191   Node._next     = _WaitSet ;</span>
<span class="line-removed">192   _WaitSet       = &amp;Node ;</span>
<span class="line-removed">193   RawMonitor_lock-&gt;unlock() ;</span>
<span class="line-removed">194 </span>
<span class="line-removed">195   SimpleExit (Self) ;</span>
<span class="line-removed">196   guarantee (_owner != Self, &quot;invariant&quot;) ;</span>
<span class="line-removed">197 </span>
<span class="line-removed">198   int ret = OS_OK ;</span>
<span class="line-removed">199   if (millis &lt;= 0) {</span>
<span class="line-removed">200     Self-&gt;_ParkEvent-&gt;park();</span>
<span class="line-removed">201   } else {</span>
<span class="line-removed">202     ret = Self-&gt;_ParkEvent-&gt;park(millis);</span>
<span class="line-removed">203   }</span>
204 
<a name="21" id="anc21"></a>
205   // If thread still resides on the waitset then unlink it.
206   // Double-checked locking -- the usage is safe in this context
<a name="22" id="anc22"></a><span class="line-modified">207   // as we TState is volatile and the lock-unlock operators are</span>
208   // serializing (barrier-equivalent).
209 
<a name="23" id="anc23"></a><span class="line-modified">210   if (Node.TState == ObjectWaiter::TS_WAIT) {</span>
<span class="line-modified">211     RawMonitor_lock-&gt;lock_without_safepoint_check() ;</span>
<span class="line-modified">212     if (Node.TState == ObjectWaiter::TS_WAIT) {</span>
213       // Simple O(n) unlink, but performance isn&#39;t critical here.
<a name="24" id="anc24"></a><span class="line-modified">214       ObjectWaiter * p ;</span>
<span class="line-modified">215       ObjectWaiter * q = NULL ;</span>
<span class="line-modified">216       for (p = _WaitSet ; p != &amp;Node; p = p-&gt;_next) {</span>
<span class="line-modified">217          q = p ;</span>
218       }
<a name="25" id="anc25"></a><span class="line-modified">219       guarantee (p == &amp;Node, &quot;invariant&quot;) ;</span>
220       if (q == NULL) {
<a name="26" id="anc26"></a><span class="line-modified">221         guarantee (p == _WaitSet, &quot;invariant&quot;) ;</span>
<span class="line-modified">222         _WaitSet = p-&gt;_next ;</span>
223       } else {
<a name="27" id="anc27"></a><span class="line-modified">224         guarantee (p == q-&gt;_next, &quot;invariant&quot;) ;</span>
<span class="line-modified">225         q-&gt;_next = p-&gt;_next ;</span>
226       }
<a name="28" id="anc28"></a><span class="line-modified">227       Node.TState = ObjectWaiter::TS_RUN ;</span>
228     }
<a name="29" id="anc29"></a><span class="line-modified">229     RawMonitor_lock-&gt;unlock() ;</span>
230   }
231 
<a name="30" id="anc30"></a><span class="line-modified">232   guarantee (Node.TState == ObjectWaiter::TS_RUN, &quot;invariant&quot;) ;</span>
<span class="line-modified">233   SimpleEnter (Self) ;</span>














































234 
<a name="31" id="anc31"></a><span class="line-modified">235   guarantee (_owner == Self, &quot;invariant&quot;) ;</span>
<span class="line-modified">236   guarantee (_recursions == 0, &quot;invariant&quot;) ;</span>
<span class="line-modified">237   return ret ;</span>




238 }
239 
<a name="32" id="anc32"></a><span class="line-modified">240 int JvmtiRawMonitor::SimpleNotify (Thread * Self, bool All) {</span>
<span class="line-modified">241   guarantee (_owner == Self, &quot;invariant&quot;) ;</span>
<span class="line-modified">242   if (_WaitSet == NULL) return OS_OK ;</span>


243 
244   // We have two options:
<a name="33" id="anc33"></a><span class="line-modified">245   // A. Transfer the threads from the WaitSet to the EntryList</span>
<span class="line-modified">246   // B. Remove the thread from the WaitSet and unpark() it.</span>
247   //
248   // We use (B), which is crude and results in lots of futile
249   // context switching.  In particular (B) induces lots of contention.
250 
<a name="34" id="anc34"></a><span class="line-modified">251   ParkEvent * ev = NULL ;       // consider using a small auto array ...</span>
<span class="line-modified">252   RawMonitor_lock-&gt;lock_without_safepoint_check() ;</span>
253   for (;;) {
<a name="35" id="anc35"></a><span class="line-modified">254       ObjectWaiter * w = _WaitSet ;</span>
<span class="line-modified">255       if (w == NULL) break ;</span>
<span class="line-modified">256       _WaitSet = w-&gt;_next ;</span>
<span class="line-modified">257       if (ev != NULL) { ev-&gt;unpark(); ev = NULL; }</span>
<span class="line-modified">258       ev = w-&gt;_event ;</span>
<span class="line-modified">259       OrderAccess::loadstore() ;</span>
<span class="line-modified">260       w-&gt;TState = ObjectWaiter::TS_RUN ;</span>
<span class="line-modified">261       OrderAccess::storeload();</span>
<span class="line-modified">262       if (!All) break ;</span>





263   }
<a name="36" id="anc36"></a><span class="line-modified">264   RawMonitor_lock-&gt;unlock() ;</span>
<span class="line-modified">265   if (ev != NULL) ev-&gt;unpark();</span>
<span class="line-modified">266   return OS_OK ;</span>


267 }
268 
269 // Any JavaThread will enter here with state _thread_blocked
<a name="37" id="anc37"></a><span class="line-modified">270 int JvmtiRawMonitor::raw_enter(TRAPS) {</span>
<span class="line-modified">271   void * Contended ;</span>
<span class="line-modified">272 </span>
273   // don&#39;t enter raw monitor if thread is being externally suspended, it will
274   // surprise the suspender if a &quot;suspended&quot; thread can still enter monitor
<a name="38" id="anc38"></a><span class="line-modified">275   JavaThread * jt = (JavaThread *)THREAD;</span>
<span class="line-modified">276   if (THREAD-&gt;is_Java_thread()) {</span>
277     jt-&gt;SR_lock()-&gt;lock_without_safepoint_check();
278     while (jt-&gt;is_external_suspend()) {
279       jt-&gt;SR_lock()-&gt;unlock();
280       jt-&gt;java_suspend_self();
281       jt-&gt;SR_lock()-&gt;lock_without_safepoint_check();
282     }
283     // guarded by SR_lock to avoid racing with new external suspend requests.
<a name="39" id="anc39"></a><span class="line-modified">284     Contended = Atomic::cmpxchg(THREAD, &amp;_owner, (void*)NULL);</span>
285     jt-&gt;SR_lock()-&gt;unlock();
286   } else {
<a name="40" id="anc40"></a><span class="line-modified">287     Contended = Atomic::cmpxchg(THREAD, &amp;_owner, (void*)NULL);</span>
288   }
289 
<a name="41" id="anc41"></a><span class="line-modified">290   if (Contended == THREAD) {</span>
<span class="line-modified">291      _recursions ++ ;</span>
<span class="line-modified">292      return OM_OK ;</span>
293   }
294 
<a name="42" id="anc42"></a><span class="line-modified">295   if (Contended == NULL) {</span>
<span class="line-modified">296      guarantee (_owner == THREAD, &quot;invariant&quot;) ;</span>
<span class="line-modified">297      guarantee (_recursions == 0, &quot;invariant&quot;) ;</span>
<span class="line-modified">298      return OM_OK ;</span>
299   }
300 
<a name="43" id="anc43"></a><span class="line-modified">301   THREAD-&gt;set_current_pending_monitor(this);</span>
<span class="line-modified">302 </span>
<span class="line-modified">303   if (!THREAD-&gt;is_Java_thread()) {</span>
<span class="line-modified">304      // No other non-Java threads besides VM thread would acquire</span>
<span class="line-modified">305      // a raw monitor.</span>
<span class="line-modified">306      assert(THREAD-&gt;is_VM_thread(), &quot;must be VM thread&quot;);</span>
<span class="line-modified">307      SimpleEnter (THREAD) ;</span>
<span class="line-modified">308    } else {</span>
<span class="line-modified">309      guarantee (jt-&gt;thread_state() == _thread_blocked, &quot;invariant&quot;) ;</span>
<span class="line-modified">310      for (;;) {</span>
<span class="line-modified">311        jt-&gt;set_suspend_equivalent();</span>
<span class="line-modified">312        // cleared by handle_special_suspend_equivalent_condition() or</span>
<span class="line-modified">313        // java_suspend_self()</span>
<span class="line-modified">314        SimpleEnter (THREAD) ;</span>
<span class="line-modified">315 </span>
<span class="line-modified">316        // were we externally suspended while we were waiting?</span>
<span class="line-modified">317        if (!jt-&gt;handle_special_suspend_equivalent_condition()) break ;</span>
<span class="line-modified">318 </span>
<span class="line-modified">319        // This thread was externally suspended</span>
<span class="line-modified">320        //</span>
<span class="line-modified">321        // This logic isn&#39;t needed for JVMTI raw monitors,</span>
<span class="line-modified">322        // but doesn&#39;t hurt just in case the suspend rules change. This</span>
<span class="line-modified">323            // logic is needed for the JvmtiRawMonitor.wait() reentry phase.</span>
<span class="line-modified">324            // We have reentered the contended monitor, but while we were</span>
<span class="line-modified">325            // waiting another thread suspended us. We don&#39;t want to reenter</span>
<span class="line-modified">326            // the monitor while suspended because that would surprise the</span>
<span class="line-modified">327            // thread that suspended us.</span>
<span class="line-modified">328            //</span>
<span class="line-removed">329            // Drop the lock -</span>
<span class="line-removed">330        SimpleExit (THREAD) ;</span>
<span class="line-removed">331 </span>
<span class="line-removed">332            jt-&gt;java_suspend_self();</span>
<span class="line-removed">333          }</span>
<span class="line-removed">334 </span>
<span class="line-removed">335      assert(_owner == THREAD, &quot;Fatal error with monitor owner!&quot;);</span>
<span class="line-removed">336      assert(_recursions == 0, &quot;Fatal error with monitor recursions!&quot;);</span>
337   }
338 
<a name="44" id="anc44"></a><span class="line-modified">339   THREAD-&gt;set_current_pending_monitor(NULL);</span>
<span class="line-modified">340   guarantee (_recursions == 0, &quot;invariant&quot;) ;</span>
<span class="line-modified">341   return OM_OK;</span>

342 }
343 
<a name="45" id="anc45"></a><span class="line-modified">344 // Used mainly for JVMTI raw monitor implementation</span>
<span class="line-modified">345 // Also used for JvmtiRawMonitor::wait().</span>
<span class="line-modified">346 int JvmtiRawMonitor::raw_exit(TRAPS) {</span>
<span class="line-removed">347   if (THREAD != _owner) {</span>
<span class="line-removed">348     return OM_ILLEGAL_MONITOR_STATE;</span>
349   }
350   if (_recursions &gt; 0) {
<a name="46" id="anc46"></a><span class="line-modified">351     --_recursions ;</span>
<span class="line-modified">352     return OM_OK ;</span>

353   }
354 
<a name="47" id="anc47"></a><span class="line-modified">355   void * List = _EntryList ;</span>
<span class="line-removed">356   SimpleExit (THREAD) ;</span>
<span class="line-removed">357 </span>
<span class="line-removed">358   return OM_OK;</span>
359 }
360 
<a name="48" id="anc48"></a><span class="line-modified">361 // Used for JVMTI raw monitor implementation.</span>
<span class="line-modified">362 // All JavaThreads will enter here with state _thread_blocked</span>
<span class="line-modified">363 </span>
<span class="line-removed">364 int JvmtiRawMonitor::raw_wait(jlong millis, bool interruptible, TRAPS) {</span>
<span class="line-removed">365   if (THREAD != _owner) {</span>
<span class="line-removed">366     return OM_ILLEGAL_MONITOR_STATE;</span>
367   }
368 
<a name="49" id="anc49"></a><span class="line-modified">369   // To avoid spurious wakeups we reset the parkevent -- This is strictly optional.</span>
<span class="line-removed">370   // The caller must be able to tolerate spurious returns from raw_wait().</span>
<span class="line-removed">371   THREAD-&gt;_ParkEvent-&gt;reset() ;</span>
<span class="line-removed">372   OrderAccess::fence() ;</span>
<span class="line-removed">373 </span>
<span class="line-removed">374   // check interrupt event</span>
<span class="line-removed">375   if (interruptible &amp;&amp; Thread::is_interrupted(THREAD, true)) {</span>
<span class="line-removed">376     return OM_INTERRUPTED;</span>
<span class="line-removed">377   }</span>
378 
<a name="50" id="anc50"></a><span class="line-modified">379   intptr_t save = _recursions ;</span>
<span class="line-modified">380   _recursions = 0 ;</span>
<span class="line-modified">381   _waiters ++ ;</span>
<span class="line-modified">382   if (THREAD-&gt;is_Java_thread()) {</span>
<span class="line-modified">383     guarantee (((JavaThread *) THREAD)-&gt;thread_state() == _thread_blocked, &quot;invariant&quot;) ;</span>
<span class="line-modified">384     ((JavaThread *)THREAD)-&gt;set_suspend_equivalent();</span>
<span class="line-modified">385   }</span>
<span class="line-modified">386   int rv = SimpleWait (THREAD, millis) ;</span>
<span class="line-modified">387   _recursions = save ;</span>
<span class="line-modified">388   _waiters -- ;</span>
<span class="line-modified">389 </span>
<span class="line-modified">390   guarantee (THREAD == _owner, &quot;invariant&quot;) ;</span>
<span class="line-modified">391   if (THREAD-&gt;is_Java_thread()) {</span>
<span class="line-modified">392      JavaThread * jSelf = (JavaThread *) THREAD ;</span>
<span class="line-modified">393      for (;;) {</span>
<span class="line-modified">394         if (!jSelf-&gt;handle_special_suspend_equivalent_condition()) break ;</span>
<span class="line-modified">395         SimpleExit (THREAD) ;</span>
<span class="line-modified">396         jSelf-&gt;java_suspend_self();</span>
<span class="line-modified">397         SimpleEnter (THREAD) ;</span>
<span class="line-modified">398         jSelf-&gt;set_suspend_equivalent() ;</span>
<span class="line-modified">399      }</span>






















400   }
<a name="51" id="anc51"></a><span class="line-modified">401   guarantee (THREAD == _owner, &quot;invariant&quot;) ;</span>
<span class="line-removed">402 </span>
<span class="line-removed">403   if (interruptible &amp;&amp; Thread::is_interrupted(THREAD, true)) {</span>
<span class="line-removed">404     return OM_INTERRUPTED;</span>
<span class="line-removed">405   }</span>
406   return OM_OK ;
407 }
408 
<a name="52" id="anc52"></a><span class="line-modified">409 int JvmtiRawMonitor::raw_notify(TRAPS) {</span>
<span class="line-modified">410   if (THREAD != _owner) {</span>
<span class="line-modified">411     return OM_ILLEGAL_MONITOR_STATE;</span>
412   }
<a name="53" id="anc53"></a><span class="line-modified">413   SimpleNotify (THREAD, false) ;</span>
<span class="line-modified">414   return OM_OK;</span>
415 }
416 
<a name="54" id="anc54"></a><span class="line-modified">417 int JvmtiRawMonitor::raw_notifyAll(TRAPS) {</span>
<span class="line-modified">418   if (THREAD != _owner) {</span>
<span class="line-modified">419     return OM_ILLEGAL_MONITOR_STATE;</span>
420   }
<a name="55" id="anc55"></a><span class="line-modified">421   SimpleNotify (THREAD, true) ;</span>
<span class="line-modified">422   return OM_OK;</span>
423 }
<a name="56" id="anc56"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="56" type="hidden" />
</body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/share/prims/jvmtiRawMonitor.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
    <script type="text/javascript" src="../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
<a name="1" id="anc1"></a><span class="line-modified">  2  * Copyright (c) 2003, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #include &quot;precompiled.hpp&quot;
 26 #include &quot;memory/allocation.inline.hpp&quot;
 27 #include &quot;prims/jvmtiRawMonitor.hpp&quot;
 28 #include &quot;runtime/atomic.hpp&quot;
 29 #include &quot;runtime/interfaceSupport.inline.hpp&quot;
 30 #include &quot;runtime/orderAccess.hpp&quot;
 31 #include &quot;runtime/thread.inline.hpp&quot;
 32 #if INCLUDE_TSAN
 33 #include &quot;tsan/tsan.hpp&quot;
 34 #endif  // INCLUDE_TSAN
 35 
<a name="2" id="anc2"></a><span class="line-modified"> 36 JvmtiRawMonitor::QNode::QNode(Thread* thread) : _next(NULL), _prev(NULL),</span>
<span class="line-added"> 37                                                 _event(thread-&gt;_ParkEvent),</span>
<span class="line-added"> 38                                                 _notified(0), _t_state(TS_RUN) {</span>
<span class="line-added"> 39 }</span>
<span class="line-added"> 40 </span>
<span class="line-added"> 41 GrowableArray&lt;JvmtiRawMonitor*&gt;* JvmtiPendingMonitors::_monitors =</span>
<span class="line-added"> 42   new (ResourceObj::C_HEAP, mtInternal) GrowableArray&lt;JvmtiRawMonitor*&gt;(1, true);</span>
 43 
 44 void JvmtiPendingMonitors::transition_raw_monitors() {
 45   assert((Threads::number_of_threads()==1),
<a name="3" id="anc3"></a><span class="line-modified"> 46          &quot;Java thread has not been created yet or more than one java thread &quot;</span>
<span class="line-modified"> 47          &quot;is running. Raw monitor transition will not work&quot;);</span>
<span class="line-modified"> 48   JavaThread* current_java_thread = JavaThread::current();</span>
 49   assert(current_java_thread-&gt;thread_state() == _thread_in_vm, &quot;Must be in vm&quot;);
<a name="4" id="anc4"></a><span class="line-modified"> 50   for (int i = 0; i &lt; count(); i++) {</span>
<span class="line-modified"> 51     JvmtiRawMonitor* rmonitor = monitors()-&gt;at(i);</span>
<span class="line-modified"> 52     rmonitor-&gt;raw_enter(current_java_thread);</span>
<span class="line-modified"> 53     TSAN_RUNTIME_ONLY(TSAN_RAW_LOCK_ACQUIRED(rmonitor));</span>




 54   }
 55   // pending monitors are converted to real monitor so delete them all.
 56   dispose();
 57 }
 58 
 59 //
 60 // class JvmtiRawMonitor
 61 //
 62 
<a name="5" id="anc5"></a><span class="line-modified"> 63 JvmtiRawMonitor::JvmtiRawMonitor(const char* name) : _owner(NULL),</span>
<span class="line-added"> 64                                                      _recursions(0),</span>
<span class="line-added"> 65                                                      _entry_list(NULL),</span>
<span class="line-added"> 66                                                      _wait_set(NULL),</span>
<span class="line-added"> 67                                                      _waiters(0),</span>
<span class="line-added"> 68                                                      _magic(JVMTI_RM_MAGIC),</span>
<span class="line-added"> 69                                                      _name(NULL) {</span>
 70 #ifdef ASSERT
 71   _name = strcpy(NEW_C_HEAP_ARRAY(char, strlen(name) + 1, mtInternal), name);
<a name="6" id="anc6"></a>


 72 #endif
 73 }
 74 
 75 JvmtiRawMonitor::~JvmtiRawMonitor() {
 76 #ifdef ASSERT
 77   FreeHeap(_name);
 78 #endif
 79   _magic = 0;
 80 }
 81 
 82 
 83 bool
 84 JvmtiRawMonitor::is_valid() {
 85   int value = 0;
 86 
 87   // This object might not be a JvmtiRawMonitor so we can&#39;t assume
 88   // the _magic field is properly aligned. Get the value in a safe
 89   // way and then check against JVMTI_RM_MAGIC.
 90 
 91   switch (sizeof(_magic)) {
 92   case 2:
 93     value = Bytes::get_native_u2((address)&amp;_magic);
 94     break;
 95 
 96   case 4:
 97     value = Bytes::get_native_u4((address)&amp;_magic);
 98     break;
 99 
100   case 8:
101     value = Bytes::get_native_u8((address)&amp;_magic);
102     break;
103 
104   default:
105     guarantee(false, &quot;_magic field is an unexpected size&quot;);
106   }
107 
108   return value == JVMTI_RM_MAGIC;
109 }
110 
111 // -------------------------------------------------------------------------
<a name="7" id="anc7"></a><span class="line-modified">112 // The JVMTI raw monitor subsystem is entirely distinct from normal</span>
<span class="line-modified">113 // java-synchronization or jni-synchronization.  JVMTI raw monitors are not</span>
114 // associated with objects.  They can be implemented in any manner
115 // that makes sense.  The original implementors decided to piggy-back
<a name="8" id="anc8"></a><span class="line-modified">116 // the raw-monitor implementation on the existing Java ObjectMonitor mechanism.</span>
<span class="line-modified">117 // Now we just use a simplified form of that ObjectMonitor code.</span>












118 //
119 // Note that we use the single RawMonitor_lock to protect queue operations for
120 // _all_ raw monitors.  This is a scalability impediment, but since raw monitor usage
<a name="9" id="anc9"></a><span class="line-modified">121 // is fairly rare, this is not of concern.  The RawMonitor_lock can not</span>
122 // be held indefinitely.  The critical sections must be short and bounded.
123 //
124 // -------------------------------------------------------------------------
125 
<a name="10" id="anc10"></a><span class="line-modified">126 void JvmtiRawMonitor::simple_enter(Thread* self) {</span>
127   for (;;) {
<a name="11" id="anc11"></a><span class="line-modified">128     if (Atomic::replace_if_null(&amp;_owner, self)) {</span>
<span class="line-modified">129       return;</span>
130     }
131 
<a name="12" id="anc12"></a><span class="line-modified">132     QNode node(self);</span>
<span class="line-modified">133     self-&gt;_ParkEvent-&gt;reset();     // strictly optional</span>
<span class="line-modified">134     node._t_state = QNode::TS_ENTER;</span>
<span class="line-modified">135 </span>
<span class="line-modified">136     RawMonitor_lock-&gt;lock_without_safepoint_check();</span>
<span class="line-modified">137     node._next = _entry_list;</span>
<span class="line-modified">138     _entry_list = &amp;node;</span>
<span class="line-modified">139     OrderAccess::fence();</span>
<span class="line-modified">140     if (_owner == NULL &amp;&amp; Atomic::replace_if_null(&amp;_owner, self)) {</span>
<span class="line-modified">141       _entry_list = node._next;</span>
<span class="line-modified">142       RawMonitor_lock-&gt;unlock();</span>
<span class="line-modified">143       return;</span>
144     }
<a name="13" id="anc13"></a><span class="line-modified">145     RawMonitor_lock-&gt;unlock();</span>
<span class="line-modified">146     while (node._t_state == QNode::TS_ENTER) {</span>
<span class="line-modified">147       self-&gt;_ParkEvent-&gt;park();</span>
148     }
149   }
150 }
151 
<a name="14" id="anc14"></a><span class="line-modified">152 void JvmtiRawMonitor::simple_exit(Thread* self) {</span>
<span class="line-modified">153   guarantee(_owner == self, &quot;invariant&quot;);</span>
<span class="line-modified">154   Atomic::release_store(&amp;_owner, (Thread*)NULL);</span>
<span class="line-modified">155   OrderAccess::fence();</span>
<span class="line-modified">156   if (_entry_list == NULL) {</span>
<span class="line-modified">157     return;</span>
<span class="line-added">158   }</span>
159 
<a name="15" id="anc15"></a><span class="line-modified">160   RawMonitor_lock-&gt;lock_without_safepoint_check();</span>
<span class="line-modified">161   QNode* w = _entry_list;</span>
162   if (w != NULL) {
<a name="16" id="anc16"></a><span class="line-modified">163     _entry_list = w-&gt;_next;</span>
164   }
<a name="17" id="anc17"></a><span class="line-modified">165   RawMonitor_lock-&gt;unlock();</span>
166   if (w != NULL) {
<a name="18" id="anc18"></a><span class="line-modified">167     guarantee(w -&gt;_t_state == QNode::TS_ENTER, &quot;invariant&quot;);</span>
<span class="line-modified">168     // Once we set _t_state to TS_RUN the waiting thread can complete</span>
<span class="line-modified">169     // simple_enter and &#39;w&#39; is pointing into random stack space. So we have</span>
<span class="line-modified">170     // to ensure we extract the ParkEvent (which is in type-stable memory)</span>
<span class="line-modified">171     // before we set the state, and then don&#39;t access &#39;w&#39;.</span>
<span class="line-added">172     ParkEvent* ev = w-&gt;_event;</span>
<span class="line-added">173     OrderAccess::loadstore();</span>
<span class="line-added">174     w-&gt;_t_state = QNode::TS_RUN;</span>
<span class="line-added">175     OrderAccess::fence();</span>
<span class="line-added">176     ev-&gt;unpark();</span>
177   }
<a name="19" id="anc19"></a><span class="line-modified">178   return;</span>
179 }
180 
<a name="20" id="anc20"></a><span class="line-modified">181 inline void JvmtiRawMonitor::enqueue_waiter(QNode&amp; node) {</span>
<span class="line-modified">182   node._notified = 0;</span>
<span class="line-modified">183   node._t_state = QNode::TS_WAIT;</span>
<span class="line-modified">184   RawMonitor_lock-&gt;lock_without_safepoint_check();</span>
<span class="line-modified">185   node._next = _wait_set;</span>
<span class="line-modified">186   _wait_set = &amp;node;</span>
<span class="line-modified">187   RawMonitor_lock-&gt;unlock();</span>
<span class="line-modified">188 }</span>














189 
<a name="21" id="anc21"></a><span class="line-added">190 inline void JvmtiRawMonitor::dequeue_waiter(QNode&amp; node) {</span>
191   // If thread still resides on the waitset then unlink it.
192   // Double-checked locking -- the usage is safe in this context
<a name="22" id="anc22"></a><span class="line-modified">193   // as _t_state is volatile and the lock-unlock operators are</span>
194   // serializing (barrier-equivalent).
195 
<a name="23" id="anc23"></a><span class="line-modified">196   if (node._t_state == QNode::TS_WAIT) {</span>
<span class="line-modified">197     RawMonitor_lock-&gt;lock_without_safepoint_check();</span>
<span class="line-modified">198     if (node._t_state == QNode::TS_WAIT) {</span>
199       // Simple O(n) unlink, but performance isn&#39;t critical here.
<a name="24" id="anc24"></a><span class="line-modified">200       QNode* p;</span>
<span class="line-modified">201       QNode* q = NULL;</span>
<span class="line-modified">202       for (p = _wait_set; p != &amp;node; p = p-&gt;_next) {</span>
<span class="line-modified">203         q = p;</span>
204       }
<a name="25" id="anc25"></a><span class="line-modified">205       guarantee(p == &amp;node, &quot;invariant&quot;);</span>
206       if (q == NULL) {
<a name="26" id="anc26"></a><span class="line-modified">207         guarantee (p == _wait_set, &quot;invariant&quot;);</span>
<span class="line-modified">208         _wait_set = p-&gt;_next;</span>
209       } else {
<a name="27" id="anc27"></a><span class="line-modified">210         guarantee(p == q-&gt;_next, &quot;invariant&quot;);</span>
<span class="line-modified">211         q-&gt;_next = p-&gt;_next;</span>
212       }
<a name="28" id="anc28"></a><span class="line-modified">213       node._t_state = QNode::TS_RUN;</span>
214     }
<a name="29" id="anc29"></a><span class="line-modified">215     RawMonitor_lock-&gt;unlock();</span>
216   }
217 
<a name="30" id="anc30"></a><span class="line-modified">218   guarantee(node._t_state == QNode::TS_RUN, &quot;invariant&quot;);</span>
<span class="line-modified">219 }</span>
<span class="line-added">220 </span>
<span class="line-added">221 // simple_wait is not quite so simple as we have to deal with the interaction</span>
<span class="line-added">222 // with the Thread interrupt state, which resides in the java.lang.Thread object.</span>
<span class="line-added">223 // That state must only be accessed while _thread_in_vm and requires proper thread-state</span>
<span class="line-added">224 // transitions. However, we cannot perform such transitions whilst we hold the RawMonitor,</span>
<span class="line-added">225 // else we can deadlock with the VMThread (which may also use RawMonitors as part of</span>
<span class="line-added">226 // executing various callbacks).</span>
<span class="line-added">227 // Returns M_OK usually, but M_INTERRUPTED if the thread is a JavaThread and was</span>
<span class="line-added">228 // interrupted.</span>
<span class="line-added">229 int JvmtiRawMonitor::simple_wait(Thread* self, jlong millis) {</span>
<span class="line-added">230   guarantee(_owner == self  , &quot;invariant&quot;);</span>
<span class="line-added">231   guarantee(_recursions == 0, &quot;invariant&quot;);</span>
<span class="line-added">232 </span>
<span class="line-added">233   QNode node(self);</span>
<span class="line-added">234   enqueue_waiter(node);</span>
<span class="line-added">235 </span>
<span class="line-added">236   simple_exit(self);</span>
<span class="line-added">237   guarantee(_owner != self, &quot;invariant&quot;);</span>
<span class="line-added">238 </span>
<span class="line-added">239   int ret = M_OK;</span>
<span class="line-added">240   if (self-&gt;is_Java_thread()) {</span>
<span class="line-added">241     JavaThread* jt = (JavaThread*) self;</span>
<span class="line-added">242     // Transition to VM so we can check interrupt state</span>
<span class="line-added">243     ThreadInVMfromNative tivm(jt);</span>
<span class="line-added">244     if (jt-&gt;is_interrupted(true)) {</span>
<span class="line-added">245         ret = M_INTERRUPTED;</span>
<span class="line-added">246     } else {</span>
<span class="line-added">247       ThreadBlockInVM tbivm(jt);</span>
<span class="line-added">248       jt-&gt;set_suspend_equivalent();</span>
<span class="line-added">249       if (millis &lt;= 0) {</span>
<span class="line-added">250         self-&gt;_ParkEvent-&gt;park();</span>
<span class="line-added">251       } else {</span>
<span class="line-added">252         self-&gt;_ParkEvent-&gt;park(millis);</span>
<span class="line-added">253       }</span>
<span class="line-added">254       // Return to VM before post-check of interrupt state</span>
<span class="line-added">255     }</span>
<span class="line-added">256     if (jt-&gt;is_interrupted(true)) {</span>
<span class="line-added">257       ret = M_INTERRUPTED;</span>
<span class="line-added">258     }</span>
<span class="line-added">259   } else {</span>
<span class="line-added">260     if (millis &lt;= 0) {</span>
<span class="line-added">261       self-&gt;_ParkEvent-&gt;park();</span>
<span class="line-added">262     } else {</span>
<span class="line-added">263       self-&gt;_ParkEvent-&gt;park(millis);</span>
<span class="line-added">264     }</span>
<span class="line-added">265   }</span>
266 
<a name="31" id="anc31"></a><span class="line-modified">267   dequeue_waiter(node);</span>
<span class="line-modified">268 </span>
<span class="line-modified">269   simple_enter(self);</span>
<span class="line-added">270   guarantee(_owner == self, &quot;invariant&quot;);</span>
<span class="line-added">271   guarantee(_recursions == 0, &quot;invariant&quot;);</span>
<span class="line-added">272 </span>
<span class="line-added">273   return ret;</span>
274 }
275 
<a name="32" id="anc32"></a><span class="line-modified">276 void JvmtiRawMonitor::simple_notify(Thread* self, bool all) {</span>
<span class="line-modified">277   guarantee(_owner == self, &quot;invariant&quot;);</span>
<span class="line-modified">278   if (_wait_set == NULL) {</span>
<span class="line-added">279     return;</span>
<span class="line-added">280   }</span>
281 
282   // We have two options:
<a name="33" id="anc33"></a><span class="line-modified">283   // A. Transfer the threads from the _wait_set to the _entry_list</span>
<span class="line-modified">284   // B. Remove the thread from the _wait_set and unpark() it.</span>
285   //
286   // We use (B), which is crude and results in lots of futile
287   // context switching.  In particular (B) induces lots of contention.
288 
<a name="34" id="anc34"></a><span class="line-modified">289   ParkEvent* ev = NULL;       // consider using a small auto array ...</span>
<span class="line-modified">290   RawMonitor_lock-&gt;lock_without_safepoint_check();</span>
291   for (;;) {
<a name="35" id="anc35"></a><span class="line-modified">292     QNode* w = _wait_set;</span>
<span class="line-modified">293     if (w == NULL) break;</span>
<span class="line-modified">294     _wait_set = w-&gt;_next;</span>
<span class="line-modified">295     if (ev != NULL) {</span>
<span class="line-modified">296       ev-&gt;unpark();</span>
<span class="line-modified">297       ev = NULL;</span>
<span class="line-modified">298     }</span>
<span class="line-modified">299     ev = w-&gt;_event;</span>
<span class="line-modified">300     OrderAccess::loadstore();</span>
<span class="line-added">301     w-&gt;_t_state = QNode::TS_RUN;</span>
<span class="line-added">302     OrderAccess::storeload();</span>
<span class="line-added">303     if (!all) {</span>
<span class="line-added">304       break;</span>
<span class="line-added">305     }</span>
306   }
<a name="36" id="anc36"></a><span class="line-modified">307   RawMonitor_lock-&gt;unlock();</span>
<span class="line-modified">308   if (ev != NULL) {</span>
<span class="line-modified">309     ev-&gt;unpark();</span>
<span class="line-added">310   }</span>
<span class="line-added">311   return;</span>
312 }
313 
314 // Any JavaThread will enter here with state _thread_blocked
<a name="37" id="anc37"></a><span class="line-modified">315 void JvmtiRawMonitor::raw_enter(Thread* self) {</span>
<span class="line-modified">316   void* contended;</span>
<span class="line-modified">317   JavaThread* jt = NULL;</span>
318   // don&#39;t enter raw monitor if thread is being externally suspended, it will
319   // surprise the suspender if a &quot;suspended&quot; thread can still enter monitor
<a name="38" id="anc38"></a><span class="line-modified">320   if (self-&gt;is_Java_thread()) {</span>
<span class="line-modified">321     jt = (JavaThread*)self;</span>
322     jt-&gt;SR_lock()-&gt;lock_without_safepoint_check();
323     while (jt-&gt;is_external_suspend()) {
324       jt-&gt;SR_lock()-&gt;unlock();
325       jt-&gt;java_suspend_self();
326       jt-&gt;SR_lock()-&gt;lock_without_safepoint_check();
327     }
328     // guarded by SR_lock to avoid racing with new external suspend requests.
<a name="39" id="anc39"></a><span class="line-modified">329     contended = Atomic::cmpxchg(&amp;_owner, (Thread*)NULL, jt);</span>
330     jt-&gt;SR_lock()-&gt;unlock();
331   } else {
<a name="40" id="anc40"></a><span class="line-modified">332     contended = Atomic::cmpxchg(&amp;_owner, (Thread*)NULL, self);</span>
333   }
334 
<a name="41" id="anc41"></a><span class="line-modified">335   if (contended == self) {</span>
<span class="line-modified">336     _recursions++;</span>
<span class="line-modified">337     return;</span>
338   }
339 
<a name="42" id="anc42"></a><span class="line-modified">340   if (contended == NULL) {</span>
<span class="line-modified">341     guarantee(_owner == self, &quot;invariant&quot;);</span>
<span class="line-modified">342     guarantee(_recursions == 0, &quot;invariant&quot;);</span>
<span class="line-modified">343     return;</span>
344   }
345 
<a name="43" id="anc43"></a><span class="line-modified">346   self-&gt;set_current_pending_raw_monitor(this);</span>
<span class="line-modified">347 </span>
<span class="line-modified">348   if (!self-&gt;is_Java_thread()) {</span>
<span class="line-modified">349     simple_enter(self);</span>
<span class="line-modified">350   } else {</span>
<span class="line-modified">351     guarantee(jt-&gt;thread_state() == _thread_blocked, &quot;invariant&quot;);</span>
<span class="line-modified">352     for (;;) {</span>
<span class="line-modified">353       jt-&gt;set_suspend_equivalent();</span>
<span class="line-modified">354       // cleared by handle_special_suspend_equivalent_condition() or</span>
<span class="line-modified">355       // java_suspend_self()</span>
<span class="line-modified">356       simple_enter(jt);</span>
<span class="line-modified">357 </span>
<span class="line-modified">358       // were we externally suspended while we were waiting?</span>
<span class="line-modified">359       if (!jt-&gt;handle_special_suspend_equivalent_condition()) {</span>
<span class="line-modified">360         break;</span>
<span class="line-modified">361       }</span>
<span class="line-modified">362 </span>
<span class="line-modified">363       // This thread was externally suspended</span>
<span class="line-modified">364       // We have reentered the contended monitor, but while we were</span>
<span class="line-modified">365       // waiting another thread suspended us. We don&#39;t want to reenter</span>
<span class="line-modified">366       // the monitor while suspended because that would surprise the</span>
<span class="line-modified">367       // thread that suspended us.</span>
<span class="line-modified">368       //</span>
<span class="line-modified">369       // Drop the lock</span>
<span class="line-modified">370       simple_exit(jt);</span>
<span class="line-modified">371 </span>
<span class="line-modified">372       jt-&gt;java_suspend_self();</span>
<span class="line-modified">373     }</span>








374   }
375 
<a name="44" id="anc44"></a><span class="line-modified">376   self-&gt;set_current_pending_raw_monitor(NULL);</span>
<span class="line-modified">377 </span>
<span class="line-modified">378   guarantee(_owner == self, &quot;invariant&quot;);</span>
<span class="line-added">379   guarantee(_recursions == 0, &quot;invariant&quot;);</span>
380 }
381 
<a name="45" id="anc45"></a><span class="line-modified">382 int JvmtiRawMonitor::raw_exit(Thread* self) {</span>
<span class="line-modified">383   if (self != _owner) {</span>
<span class="line-modified">384     return M_ILLEGAL_MONITOR_STATE;</span>


385   }
386   if (_recursions &gt; 0) {
<a name="46" id="anc46"></a><span class="line-modified">387     _recursions--;</span>
<span class="line-modified">388   } else {</span>
<span class="line-added">389     simple_exit(self);</span>
390   }
391 
<a name="47" id="anc47"></a><span class="line-modified">392   return M_OK;</span>



393 }
394 
<a name="48" id="anc48"></a><span class="line-modified">395 int JvmtiRawMonitor::raw_wait(jlong millis, Thread* self) {</span>
<span class="line-modified">396   if (self != _owner) {</span>
<span class="line-modified">397     return M_ILLEGAL_MONITOR_STATE;</span>



398   }
399 
<a name="49" id="anc49"></a><span class="line-modified">400   int ret = M_OK;</span>








401 
<a name="50" id="anc50"></a><span class="line-modified">402   // To avoid spurious wakeups we reset the parkevent. This is strictly optional.</span>
<span class="line-modified">403   // The caller must be able to tolerate spurious returns from raw_wait().</span>
<span class="line-modified">404   self-&gt;_ParkEvent-&gt;reset();</span>
<span class="line-modified">405   OrderAccess::fence();</span>
<span class="line-modified">406 </span>
<span class="line-modified">407   intptr_t save = _recursions;</span>
<span class="line-modified">408   _recursions = 0;</span>
<span class="line-modified">409   _waiters++;</span>
<span class="line-modified">410   ret = simple_wait(self, millis);</span>
<span class="line-modified">411   _recursions = save;</span>
<span class="line-modified">412   _waiters--;</span>
<span class="line-modified">413 </span>
<span class="line-modified">414   guarantee(self == _owner, &quot;invariant&quot;);</span>
<span class="line-modified">415 </span>
<span class="line-modified">416   if (self-&gt;is_Java_thread()) {</span>
<span class="line-modified">417     JavaThread* jt = (JavaThread*)self;</span>
<span class="line-modified">418     for (;;) {</span>
<span class="line-modified">419       jt-&gt;set_suspend_equivalent();</span>
<span class="line-modified">420       if (!jt-&gt;handle_special_suspend_equivalent_condition()) {</span>
<span class="line-modified">421         break;</span>
<span class="line-modified">422       } else {</span>
<span class="line-added">423         // We&#39;ve been suspended whilst waiting and so we have to</span>
<span class="line-added">424         // relinquish the raw monitor until we are resumed. Of course</span>
<span class="line-added">425         // after reacquiring we have to re-check for suspension again.</span>
<span class="line-added">426         // Suspension requires we are _thread_blocked, and we also have to</span>
<span class="line-added">427         // recheck for being interrupted.</span>
<span class="line-added">428         simple_exit(jt);</span>
<span class="line-added">429         {</span>
<span class="line-added">430           ThreadInVMfromNative tivm(jt);</span>
<span class="line-added">431           {</span>
<span class="line-added">432             ThreadBlockInVM tbivm(jt);</span>
<span class="line-added">433             jt-&gt;java_suspend_self();</span>
<span class="line-added">434           }</span>
<span class="line-added">435           if (jt-&gt;is_interrupted(true)) {</span>
<span class="line-added">436             ret = M_INTERRUPTED;</span>
<span class="line-added">437           }</span>
<span class="line-added">438         }</span>
<span class="line-added">439         simple_enter(jt);</span>
<span class="line-added">440       }</span>
<span class="line-added">441     }</span>
<span class="line-added">442     guarantee(jt == _owner, &quot;invariant&quot;);</span>
<span class="line-added">443   } else {</span>
<span class="line-added">444     assert(ret != M_INTERRUPTED, &quot;Only JavaThreads can be interrupted&quot;);</span>
445   }
<a name="51" id="anc51"></a><span class="line-modified">446 </span>




447   return ret;
448 }
449 
<a name="52" id="anc52"></a><span class="line-modified">450 int JvmtiRawMonitor::raw_notify(Thread* self) {</span>
<span class="line-modified">451   if (self != _owner) {</span>
<span class="line-modified">452     return M_ILLEGAL_MONITOR_STATE;</span>
453   }
<a name="53" id="anc53"></a><span class="line-modified">454   simple_notify(self, false);</span>
<span class="line-modified">455   return M_OK;</span>
456 }
457 
<a name="54" id="anc54"></a><span class="line-modified">458 int JvmtiRawMonitor::raw_notifyAll(Thread* self) {</span>
<span class="line-modified">459   if (self != _owner) {</span>
<span class="line-modified">460     return M_ILLEGAL_MONITOR_STATE;</span>
461   }
<a name="55" id="anc55"></a><span class="line-modified">462   simple_notify(self, true);</span>
<span class="line-modified">463   return M_OK;</span>
464 }
<a name="56" id="anc56"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="56" type="hidden" />
</body>
</html>
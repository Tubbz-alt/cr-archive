<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/prims/unsafe.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="jvmtiTagMap.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="../runtime/arguments.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/prims/unsafe.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 2000, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include &quot;precompiled.hpp&quot;
  26 #include &quot;jni.h&quot;
  27 #include &quot;jvm.h&quot;
  28 #include &quot;classfile/classFileStream.hpp&quot;

  29 #include &quot;classfile/vmSymbols.hpp&quot;
  30 #include &quot;jfr/jfrEvents.hpp&quot;
  31 #include &quot;memory/allocation.inline.hpp&quot;
  32 #include &quot;memory/resourceArea.hpp&quot;
  33 #include &quot;oops/access.inline.hpp&quot;
<span class="line-modified">  34 #include &quot;oops/fieldStreams.hpp&quot;</span>
  35 #include &quot;oops/objArrayOop.inline.hpp&quot;
  36 #include &quot;oops/oop.inline.hpp&quot;
  37 #include &quot;oops/typeArrayOop.inline.hpp&quot;
  38 #include &quot;prims/unsafe.hpp&quot;
<span class="line-removed">  39 #include &quot;runtime/atomic.hpp&quot;</span>
  40 #include &quot;runtime/globals.hpp&quot;
  41 #include &quot;runtime/handles.inline.hpp&quot;
  42 #include &quot;runtime/interfaceSupport.inline.hpp&quot;
  43 #include &quot;runtime/jniHandles.inline.hpp&quot;
  44 #include &quot;runtime/orderAccess.hpp&quot;
  45 #include &quot;runtime/reflection.hpp&quot;

  46 #include &quot;runtime/thread.hpp&quot;
  47 #include &quot;runtime/threadSMR.hpp&quot;
  48 #include &quot;runtime/vm_version.hpp&quot;
  49 #include &quot;services/threadService.hpp&quot;
  50 #include &quot;utilities/align.hpp&quot;
  51 #include &quot;utilities/copy.hpp&quot;
  52 #include &quot;utilities/dtrace.hpp&quot;
  53 #include &quot;utilities/macros.hpp&quot;
  54 #if INCLUDE_TSAN
<span class="line-removed">  55 #include &quot;runtime/sharedRuntime.hpp&quot;</span>
  56 #include &quot;tsan/tsanExternalDecls.hpp&quot;
  57 #endif
  58 
  59 /**
  60  * Implementation of the jdk.internal.misc.Unsafe class
  61  */
  62 
  63 
  64 #define MAX_OBJECT_SIZE \
  65   ( arrayOopDesc::header_size(T_DOUBLE) * HeapWordSize \
  66     + ((julong)max_jint * sizeof(double)) )
  67 
  68 
  69 #define UNSAFE_ENTRY(result_type, header) \
  70   JVM_ENTRY(static result_type, header)
  71 
  72 #define UNSAFE_LEAF(result_type, header) \
  73   JVM_LEAF(static result_type, header)
  74 
  75 #define UNSAFE_END JVM_END
</pre>
<hr />
<pre>
  97 // through the Unsafe API are opaque cookies that just happen to be byte
  98 // offsets.  We represent this state of affairs by passing the cookies
  99 // through conversion functions when going between the VM and the Unsafe API.
 100 // The conversion functions just happen to be no-ops at present.
 101 
 102 static inline jlong field_offset_to_byte_offset(jlong field_offset) {
 103   return field_offset;
 104 }
 105 
 106 static inline jlong field_offset_from_byte_offset(jlong byte_offset) {
 107   return byte_offset;
 108 }
 109 
 110 static inline void assert_field_offset_sane(oop p, jlong field_offset) {
 111 #ifdef ASSERT
 112   jlong byte_offset = field_offset_to_byte_offset(field_offset);
 113 
 114   if (p != NULL) {
 115     assert(byte_offset &gt;= 0 &amp;&amp; byte_offset &lt;= (jlong)MAX_OBJECT_SIZE, &quot;sane offset&quot;);
 116     if (byte_offset == (jint)byte_offset) {
<span class="line-modified"> 117       void* ptr_plus_disp = (address)p + byte_offset;</span>
 118       assert(p-&gt;field_addr_raw((jint)byte_offset) == ptr_plus_disp,
 119              &quot;raw [ptr+disp] must be consistent with oop::field_addr_raw&quot;);
 120     }
 121     jlong p_size = HeapWordSize * (jlong)(p-&gt;size());
 122     assert(byte_offset &lt; p_size, &quot;Unsafe access: offset &quot; INT64_FORMAT &quot; &gt; object&#39;s size &quot; INT64_FORMAT, (int64_t)byte_offset, (int64_t)p_size);
 123   }
 124 #endif
 125 }
 126 
 127 static inline void* index_oop_from_field_offset_long(oop p, jlong field_offset) {
 128   assert_field_offset_sane(p, field_offset);
 129   jlong byte_offset = field_offset_to_byte_offset(field_offset);
 130 
 131   if (p != NULL) {
 132     p = Access&lt;&gt;::resolve(p);
 133   }
 134 
 135   if (sizeof(char*) == sizeof(jint)) {   // (this constant folds!)
<span class="line-modified"> 136     return (address)p + (jint) byte_offset;</span>
 137   } else {
<span class="line-modified"> 138     return (address)p +        byte_offset;</span>
 139   }
 140 }
 141 
 142 // Externally callable versions:
 143 // (Use these in compiler intrinsics which emulate unsafe primitives.)
 144 jlong Unsafe_field_offset_to_byte_offset(jlong field_offset) {
 145   return field_offset;
 146 }
 147 jlong Unsafe_field_offset_from_byte_offset(jlong byte_offset) {
 148   return byte_offset;
 149 }
 150 
 151 
 152 ///// Data read/writes on the Java heap and in native (off-heap) memory
 153 



















 154 /**
 155  * Helper class for accessing memory.
 156  *
 157  * Normalizes values and wraps accesses in
 158  * JavaThread::doing_unsafe_access() if needed.
 159  */
 160 template &lt;typename T&gt;
 161 class MemoryAccess : StackObj {
 162   JavaThread* _thread;
 163   oop _obj;
 164   ptrdiff_t _offset;
 165 
 166   // Resolves and returns the address of the memory access.
 167   // This raw memory access may fault, so we make sure it happens within the
 168   // guarded scope by making the access volatile at least. Since the store
 169   // of Thread::set_doing_unsafe_access() is also volatile, these accesses
 170   // can not be reordered by the compiler. Therefore, if the access triggers
 171   // a fault, we will know that Thread::doing_unsafe_access() returns true.
 172   volatile T* addr() {
 173     void* addr = index_oop_from_field_offset_long(_obj, _offset);
</pre>
<hr />
<pre>
 175   }
 176 
 177   template &lt;typename U&gt;
 178   U normalize_for_write(U x) {
 179     return x;
 180   }
 181 
 182   jboolean normalize_for_write(jboolean x) {
 183     return x &amp; 1;
 184   }
 185 
 186   template &lt;typename U&gt;
 187   U normalize_for_read(U x) {
 188     return x;
 189   }
 190 
 191   jboolean normalize_for_read(jboolean x) {
 192     return x != 0;
 193   }
 194 
<span class="line-removed"> 195   /**</span>
<span class="line-removed"> 196    * Helper class to wrap memory accesses in JavaThread::doing_unsafe_access()</span>
<span class="line-removed"> 197    */</span>
<span class="line-removed"> 198   class GuardUnsafeAccess {</span>
<span class="line-removed"> 199     JavaThread* _thread;</span>
<span class="line-removed"> 200 </span>
<span class="line-removed"> 201   public:</span>
<span class="line-removed"> 202     GuardUnsafeAccess(JavaThread* thread) : _thread(thread) {</span>
<span class="line-removed"> 203       // native/off-heap access which may raise SIGBUS if accessing</span>
<span class="line-removed"> 204       // memory mapped file data in a region of the file which has</span>
<span class="line-removed"> 205       // been truncated and is now invalid</span>
<span class="line-removed"> 206       _thread-&gt;set_doing_unsafe_access(true);</span>
<span class="line-removed"> 207     }</span>
<span class="line-removed"> 208 </span>
<span class="line-removed"> 209     ~GuardUnsafeAccess() {</span>
<span class="line-removed"> 210       _thread-&gt;set_doing_unsafe_access(false);</span>
<span class="line-removed"> 211     }</span>
<span class="line-removed"> 212   };</span>
<span class="line-removed"> 213 </span>
 214 public:
 215   MemoryAccess(JavaThread* thread, jobject obj, jlong offset)
 216     : _thread(thread), _obj(JNIHandles::resolve(obj)), _offset((ptrdiff_t)offset) {
 217     assert_field_offset_sane(_obj, offset);
 218   }
 219 
 220   T get() {
 221     if (_obj == NULL) {
 222       GuardUnsafeAccess guard(_thread);
 223       T ret = RawAccess&lt;&gt;::load(addr());
 224       return normalize_for_read(ret);
 225     } else {
 226       T ret = HeapAccess&lt;&gt;::load_at(_obj, _offset);
 227       return normalize_for_read(ret);
 228     }
 229   }
 230 
 231   void put(T x) {
 232     if (_obj == NULL) {
 233       GuardUnsafeAccess guard(_thread);
</pre>
<hr />
<pre>
 302   );
 303   return JNIHandles::make_local(env, v);
 304 } UNSAFE_END
 305 
 306 UNSAFE_ENTRY(void, Unsafe_PutReferenceVolatile(JNIEnv *env, jobject unsafe, jobject obj, jlong offset, jobject x_h)) {
 307   oop x = JNIHandles::resolve(x_h);
 308   oop p = JNIHandles::resolve(obj);
 309   assert_field_offset_sane(p, offset);
 310   TSAN_RUNTIME_ONLY(
 311     void* addr = index_oop_from_field_offset_long(p, offset);
 312     __tsan_java_release(addr);
 313   );
 314   HeapAccess&lt;MO_SEQ_CST | ON_UNKNOWN_OOP_REF&gt;::oop_store_at(p, offset, x);
 315 } UNSAFE_END
 316 
 317 UNSAFE_ENTRY(jobject, Unsafe_GetUncompressedObject(JNIEnv *env, jobject unsafe, jlong addr)) {
 318   oop v = *(oop*) (address) addr;
 319   return JNIHandles::make_local(env, v);
 320 } UNSAFE_END
 321 
<span class="line-removed"> 322 UNSAFE_LEAF(jboolean, Unsafe_isBigEndian0(JNIEnv *env, jobject unsafe)) {</span>
<span class="line-removed"> 323 #ifdef VM_LITTLE_ENDIAN</span>
<span class="line-removed"> 324   return false;</span>
<span class="line-removed"> 325 #else</span>
<span class="line-removed"> 326   return true;</span>
<span class="line-removed"> 327 #endif</span>
<span class="line-removed"> 328 } UNSAFE_END</span>
<span class="line-removed"> 329 </span>
<span class="line-removed"> 330 UNSAFE_LEAF(jint, Unsafe_unalignedAccess0(JNIEnv *env, jobject unsafe)) {</span>
<span class="line-removed"> 331   return UseUnalignedAccesses;</span>
<span class="line-removed"> 332 } UNSAFE_END</span>
<span class="line-removed"> 333 </span>
 334 #define DEFINE_GETSETOOP(java_type, Type, size) \
 335  \
 336 UNSAFE_ENTRY(java_type, Unsafe_Get##Type(JNIEnv *env, jobject unsafe, jobject obj, jlong offset)) { \
 337   java_type ret = MemoryAccess&lt;java_type&gt;(thread, obj, offset).get(); \
 338   TSAN_RUNTIME_ONLY( \
 339     void* addr = index_oop_from_field_offset_long(JNIHandles::resolve(obj), offset); \
 340     __tsan_read##size##_pc(addr, SharedRuntime::tsan_code_location(0, 0)); \
 341   ); \
 342   return ret; \
 343 } UNSAFE_END \
 344  \
 345 UNSAFE_ENTRY(void, Unsafe_Put##Type(JNIEnv *env, jobject unsafe, jobject obj, jlong offset, java_type x)) { \
 346   TSAN_RUNTIME_ONLY( \
 347     void* addr = index_oop_from_field_offset_long(JNIHandles::resolve(obj), offset); \
 348     __tsan_write##size##_pc(addr, SharedRuntime::tsan_code_location(0, 0)); \
 349   ); \
 350   MemoryAccess&lt;java_type&gt;(thread, obj, offset).put(x); \
 351 } UNSAFE_END \
 352  \
 353 // END DEFINE_GETSETOOP.
</pre>
<hr />
<pre>
 400 } UNSAFE_END
 401 
 402 UNSAFE_LEAF(void, Unsafe_StoreFence(JNIEnv *env, jobject unsafe)) {
 403   OrderAccess::release();
 404 } UNSAFE_END
 405 
 406 UNSAFE_LEAF(void, Unsafe_FullFence(JNIEnv *env, jobject unsafe)) {
 407   OrderAccess::fence();
 408 } UNSAFE_END
 409 
 410 ////// Allocation requests
 411 
 412 UNSAFE_ENTRY(jobject, Unsafe_AllocateInstance(JNIEnv *env, jobject unsafe, jclass cls)) {
 413   ThreadToNativeFromVM ttnfv(thread);
 414   return env-&gt;AllocObject(cls);
 415 } UNSAFE_END
 416 
 417 UNSAFE_ENTRY(jlong, Unsafe_AllocateMemory0(JNIEnv *env, jobject unsafe, jlong size)) {
 418   size_t sz = (size_t)size;
 419 
<span class="line-modified"> 420   sz = align_up(sz, HeapWordSize);</span>

 421   void* x = os::malloc(sz, mtOther);
 422 
 423   return addr_to_java(x);
 424 } UNSAFE_END
 425 
 426 UNSAFE_ENTRY(jlong, Unsafe_ReallocateMemory0(JNIEnv *env, jobject unsafe, jlong addr, jlong size)) {
 427   void* p = addr_from_java(addr);
 428   size_t sz = (size_t)size;
<span class="line-modified"> 429   sz = align_up(sz, HeapWordSize);</span>

 430 
 431   void* x = os::realloc(p, sz, mtOther);
 432 
 433   return addr_to_java(x);
 434 } UNSAFE_END
 435 
 436 UNSAFE_ENTRY(void, Unsafe_FreeMemory0(JNIEnv *env, jobject unsafe, jlong addr)) {
 437   void* p = addr_from_java(addr);
 438 
 439   os::free(p);
 440 } UNSAFE_END
 441 
 442 UNSAFE_ENTRY(void, Unsafe_SetMemory0(JNIEnv *env, jobject unsafe, jobject obj, jlong offset, jlong size, jbyte value)) {
 443   size_t sz = (size_t)size;
 444 
 445   oop base = JNIHandles::resolve(obj);
 446   void* p = index_oop_from_field_offset_long(base, offset);
 447 
 448   Copy::fill_to_memory_atomic(p, sz, value);
 449 } UNSAFE_END
 450 
 451 UNSAFE_ENTRY(void, Unsafe_CopyMemory0(JNIEnv *env, jobject unsafe, jobject srcObj, jlong srcOffset, jobject dstObj, jlong dstOffset, jlong size)) {
 452   size_t sz = (size_t)size;
 453 
 454   oop srcp = JNIHandles::resolve(srcObj);
 455   oop dstp = JNIHandles::resolve(dstObj);
 456 
 457   void* src = index_oop_from_field_offset_long(srcp, srcOffset);
 458   void* dst = index_oop_from_field_offset_long(dstp, dstOffset);
<span class="line-modified"> 459 </span>
<span class="line-modified"> 460   Copy::conjoint_memory_atomic(src, dst, sz);</span>






 461 } UNSAFE_END
 462 
 463 // This function is a leaf since if the source and destination are both in native memory
 464 // the copy may potentially be very large, and we don&#39;t want to disable GC if we can avoid it.
 465 // If either source or destination (or both) are on the heap, the function will enter VM using
 466 // JVM_ENTRY_FROM_LEAF
 467 UNSAFE_LEAF(void, Unsafe_CopySwapMemory0(JNIEnv *env, jobject unsafe, jobject srcObj, jlong srcOffset, jobject dstObj, jlong dstOffset, jlong size, jlong elemSize)) {
 468   size_t sz = (size_t)size;
 469   size_t esz = (size_t)elemSize;
 470 
 471   if (srcObj == NULL &amp;&amp; dstObj == NULL) {
 472     // Both src &amp; dst are in native memory
 473     address src = (address)srcOffset;
 474     address dst = (address)dstOffset;
 475 
<span class="line-modified"> 476     Copy::conjoint_swap(src, dst, sz, esz);</span>




 477   } else {
 478     // At least one of src/dst are on heap, transition to VM to access raw pointers
 479 
 480     JVM_ENTRY_FROM_LEAF(env, void, Unsafe_CopySwapMemory0) {
 481       oop srcp = JNIHandles::resolve(srcObj);
 482       oop dstp = JNIHandles::resolve(dstObj);
 483 
 484       address src = (address)index_oop_from_field_offset_long(srcp, srcOffset);
 485       address dst = (address)index_oop_from_field_offset_long(dstp, dstOffset);
 486 
<span class="line-modified"> 487       Copy::conjoint_swap(src, dst, sz, esz);</span>



 488     } JVM_END
 489   }
 490 } UNSAFE_END
 491 
<span class="line-modified"> 492 ////// Random queries</span>






 493 
<span class="line-modified"> 494 UNSAFE_LEAF(jint, Unsafe_AddressSize0(JNIEnv *env, jobject unsafe)) {</span>
<span class="line-modified"> 495   return sizeof(void*);</span>
 496 } UNSAFE_END
 497 
<span class="line-modified"> 498 UNSAFE_LEAF(jint, Unsafe_PageSize()) {</span>
<span class="line-modified"> 499   return os::vm_page_size();</span>
























 500 } UNSAFE_END
 501 


 502 static jlong find_field_offset(jclass clazz, jstring name, TRAPS) {
 503   assert(clazz != NULL, &quot;clazz must not be NULL&quot;);
 504   assert(name != NULL, &quot;name must not be NULL&quot;);
 505 
 506   ResourceMark rm(THREAD);
 507   char *utf_name = java_lang_String::as_utf8_string(JNIHandles::resolve_non_null(name));
 508 
 509   InstanceKlass* k = InstanceKlass::cast(java_lang_Class::as_Klass(JNIHandles::resolve_non_null(clazz)));
 510 
 511   jint offset = -1;
 512   for (JavaFieldStream fs(k); !fs.done(); fs.next()) {
 513     Symbol *name = fs.name();
 514     if (name-&gt;equals(utf_name)) {
 515       offset = fs.offset();
 516       break;
 517     }
 518   }
 519   if (offset &lt; 0) {
 520     THROW_0(vmSymbols::java_lang_InternalError());
 521   }
</pre>
<hr />
<pre>
 663   }
 664 
 665   env-&gt;ThrowNew(cls, NULL);
 666 }
 667 
 668 static jclass Unsafe_DefineClass_impl(JNIEnv *env, jstring name, jbyteArray data, int offset, int length, jobject loader, jobject pd) {
 669   // Code lifted from JDK 1.3 ClassLoader.c
 670 
 671   jbyte *body;
 672   char *utfName = NULL;
 673   jclass result = 0;
 674   char buf[128];
 675 
 676   assert(data != NULL, &quot;Class bytes must not be NULL&quot;);
 677   assert(length &gt;= 0, &quot;length must not be negative: %d&quot;, length);
 678 
 679   if (UsePerfData) {
 680     ClassLoader::unsafe_defineClassCallCounter()-&gt;inc();
 681   }
 682 
<span class="line-modified"> 683   body = NEW_C_HEAP_ARRAY(jbyte, length, mtInternal);</span>
 684   if (body == NULL) {
 685     throw_new(env, &quot;java/lang/OutOfMemoryError&quot;);
 686     return 0;
 687   }
 688 
 689   env-&gt;GetByteArrayRegion(data, offset, length, body);
 690   if (env-&gt;ExceptionOccurred()) {
 691     goto free_body;
 692   }
 693 
 694   if (name != NULL) {
 695     uint len = env-&gt;GetStringUTFLength(name);
 696     int unicode_len = env-&gt;GetStringLength(name);
 697 
 698     if (len &gt;= sizeof(buf)) {
<span class="line-modified"> 699       utfName = NEW_C_HEAP_ARRAY(char, len + 1, mtInternal);</span>
 700       if (utfName == NULL) {
 701         throw_new(env, &quot;java/lang/OutOfMemoryError&quot;);
 702         goto free_body;
 703       }
 704     } else {
 705       utfName = buf;
 706     }
 707 
 708     env-&gt;GetStringUTFRegion(name, 0, unicode_len, utfName);
 709 
 710     for (uint i = 0; i &lt; len; i++) {
 711       if (utfName[i] == &#39;.&#39;)   utfName[i] = &#39;/&#39;;
 712     }
 713   }
 714 
 715   result = JVM_DefineClass(env, utfName, loader, body, length, pd);
 716 
 717   if (utfName &amp;&amp; utfName != buf) {
 718     FREE_C_HEAP_ARRAY(char, utfName);
 719   }
</pre>
<hr />
<pre>
 784 // not just a literal string.  For such ldc instructions, the verifier uses the
 785 // type Object instead of String, if the loaded constant is not in fact a String.
 786 
 787 static InstanceKlass*
 788 Unsafe_DefineAnonymousClass_impl(JNIEnv *env,
 789                                  jclass host_class, jbyteArray data, jobjectArray cp_patches_jh,
 790                                  u1** temp_alloc,
 791                                  TRAPS) {
 792   assert(host_class != NULL, &quot;host_class must not be NULL&quot;);
 793   assert(data != NULL, &quot;data must not be NULL&quot;);
 794 
 795   if (UsePerfData) {
 796     ClassLoader::unsafe_defineClassCallCounter()-&gt;inc();
 797   }
 798 
 799   jint length = typeArrayOop(JNIHandles::resolve_non_null(data))-&gt;length();
 800   assert(length &gt;= 0, &quot;class_bytes_length must not be negative: %d&quot;, length);
 801 
 802   int class_bytes_length = (int) length;
 803 
<span class="line-modified"> 804   u1* class_bytes = NEW_C_HEAP_ARRAY(u1, length, mtInternal);</span>
 805   if (class_bytes == NULL) {
 806     THROW_0(vmSymbols::java_lang_OutOfMemoryError());
 807   }
 808 
 809   // caller responsible to free it:
 810   *temp_alloc = class_bytes;
 811 
 812   ArrayAccess&lt;&gt;::arraycopy_to_native(arrayOop(JNIHandles::resolve_non_null(data)), typeArrayOopDesc::element_offset&lt;jbyte&gt;(0),
 813                                      reinterpret_cast&lt;jbyte*&gt;(class_bytes), length);
 814 
 815   objArrayHandle cp_patches_h;
 816   if (cp_patches_jh != NULL) {
 817     oop p = JNIHandles::resolve_non_null(cp_patches_jh);
 818     assert(p-&gt;is_objArray(), &quot;cp_patches must be an object[]&quot;);
 819     cp_patches_h = objArrayHandle(THREAD, (objArrayOop)p);
 820   }
 821 
 822   const Klass* host_klass = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(host_class));
 823 
 824   // Make sure it&#39;s the real host class, not another anonymous class.
</pre>
<hr />
<pre>
 869                                                 CHECK_NULL);
 870   if (anonk == NULL) {
 871     return NULL;
 872   }
 873 
 874   return InstanceKlass::cast(anonk);
 875 }
 876 
 877 UNSAFE_ENTRY(jclass, Unsafe_DefineAnonymousClass0(JNIEnv *env, jobject unsafe, jclass host_class, jbyteArray data, jobjectArray cp_patches_jh)) {
 878   ResourceMark rm(THREAD);
 879 
 880   jobject res_jh = NULL;
 881   u1* temp_alloc = NULL;
 882 
 883   InstanceKlass* anon_klass = Unsafe_DefineAnonymousClass_impl(env, host_class, data, cp_patches_jh, &amp;temp_alloc, THREAD);
 884   if (anon_klass != NULL) {
 885     res_jh = JNIHandles::make_local(env, anon_klass-&gt;java_mirror());
 886   }
 887 
 888   // try/finally clause:
<span class="line-modified"> 889   if (temp_alloc != NULL) {</span>
<span class="line-removed"> 890     FREE_C_HEAP_ARRAY(u1, temp_alloc);</span>
<span class="line-removed"> 891   }</span>
 892 
 893   // The anonymous class loader data has been artificially been kept alive to
 894   // this point.   The mirror and any instances of this class have to keep
 895   // it alive afterwards.
 896   if (anon_klass != NULL) {
 897     anon_klass-&gt;class_loader_data()-&gt;dec_keep_alive();
 898   }
 899 
 900   // let caller initialize it as needed...
 901 
 902   return (jclass) res_jh;
 903 } UNSAFE_END
 904 
 905 
 906 
 907 UNSAFE_ENTRY(void, Unsafe_ThrowException(JNIEnv *env, jobject unsafe, jthrowable thr)) {
 908   ThreadToNativeFromVM ttnfv(thread);
 909   env-&gt;Throw(thr);
 910 } UNSAFE_END
 911 
</pre>
<hr />
<pre>
 924   }
 925 
 926   ScopedReleaseAcquire(oop obj, jlong offset) {
 927     TSAN_RUNTIME_ONLY(
 928       _addr = index_oop_from_field_offset_long(obj, offset);
 929       __tsan_java_release(_addr);
 930     );
 931   }
 932 
 933   ~ScopedReleaseAcquire() {
 934     TSAN_RUNTIME_ONLY(__tsan_java_acquire(_addr));
 935   }
 936 };
 937 
 938 UNSAFE_ENTRY(jobject, Unsafe_CompareAndExchangeReference(JNIEnv *env, jobject unsafe, jobject obj, jlong offset, jobject e_h, jobject x_h)) {
 939   oop x = JNIHandles::resolve(x_h);
 940   oop e = JNIHandles::resolve(e_h);
 941   oop p = JNIHandles::resolve(obj);
 942   assert_field_offset_sane(p, offset);
 943   ScopedReleaseAcquire releaseAcquire(p, offset);
<span class="line-modified"> 944   oop res = HeapAccess&lt;ON_UNKNOWN_OOP_REF&gt;::oop_atomic_cmpxchg_at(x, p, (ptrdiff_t)offset, e);</span>
 945   return JNIHandles::make_local(env, res);
 946 } UNSAFE_END
 947 
 948 UNSAFE_ENTRY(jint, Unsafe_CompareAndExchangeInt(JNIEnv *env, jobject unsafe, jobject obj, jlong offset, jint e, jint x)) {
 949   oop p = JNIHandles::resolve(obj);
 950   if (p == NULL) {
 951     volatile jint* addr = (volatile jint*)index_oop_from_field_offset_long(p, offset);
 952     ScopedReleaseAcquire releaseAcquire(addr);
<span class="line-modified"> 953     return RawAccess&lt;&gt;::atomic_cmpxchg(x, addr, e);</span>
 954   } else {
 955     assert_field_offset_sane(p, offset);
 956     ScopedReleaseAcquire releaseAcquire(p, offset);
<span class="line-modified"> 957     return HeapAccess&lt;&gt;::atomic_cmpxchg_at(x, p, (ptrdiff_t)offset, e);</span>
 958   }
 959 } UNSAFE_END
 960 
 961 UNSAFE_ENTRY(jlong, Unsafe_CompareAndExchangeLong(JNIEnv *env, jobject unsafe, jobject obj, jlong offset, jlong e, jlong x)) {
 962   oop p = JNIHandles::resolve(obj);
 963   if (p == NULL) {
 964     volatile jlong* addr = (volatile jlong*)index_oop_from_field_offset_long(p, offset);
 965     ScopedReleaseAcquire releaseAcquire(addr);
<span class="line-modified"> 966     return RawAccess&lt;&gt;::atomic_cmpxchg(x, addr, e);</span>
 967   } else {
 968     assert_field_offset_sane(p, offset);
 969     ScopedReleaseAcquire releaseAcquire(p, offset);
<span class="line-modified"> 970     return HeapAccess&lt;&gt;::atomic_cmpxchg_at(x, p, (ptrdiff_t)offset, e);</span>
 971   }
 972 } UNSAFE_END
 973 
 974 UNSAFE_ENTRY(jboolean, Unsafe_CompareAndSetReference(JNIEnv *env, jobject unsafe, jobject obj, jlong offset, jobject e_h, jobject x_h)) {
 975   oop x = JNIHandles::resolve(x_h);
 976   oop e = JNIHandles::resolve(e_h);
 977   oop p = JNIHandles::resolve(obj);
 978   assert_field_offset_sane(p, offset);
 979   ScopedReleaseAcquire releaseAcquire(p, offset);
<span class="line-modified"> 980   oop ret = HeapAccess&lt;ON_UNKNOWN_OOP_REF&gt;::oop_atomic_cmpxchg_at(x, p, (ptrdiff_t)offset, e);</span>
<span class="line-modified"> 981   return oopDesc::equals(ret, e);</span>
 982 } UNSAFE_END
 983 
 984 UNSAFE_ENTRY(jboolean, Unsafe_CompareAndSetInt(JNIEnv *env, jobject unsafe, jobject obj, jlong offset, jint e, jint x)) {
 985   oop p = JNIHandles::resolve(obj);
 986   if (p == NULL) {
 987     volatile jint* addr = (volatile jint*)index_oop_from_field_offset_long(p, offset);
 988     ScopedReleaseAcquire releaseAcquire(addr);
<span class="line-modified"> 989     return RawAccess&lt;&gt;::atomic_cmpxchg(x, addr, e) == e;</span>
 990   } else {
 991     assert_field_offset_sane(p, offset);
 992     ScopedReleaseAcquire releaseAcquire(p, offset);
<span class="line-modified"> 993     return HeapAccess&lt;&gt;::atomic_cmpxchg_at(x, p, (ptrdiff_t)offset, e) == e;</span>
 994   }
 995 } UNSAFE_END
 996 
 997 UNSAFE_ENTRY(jboolean, Unsafe_CompareAndSetLong(JNIEnv *env, jobject unsafe, jobject obj, jlong offset, jlong e, jlong x)) {
 998   oop p = JNIHandles::resolve(obj);
 999   if (p == NULL) {
1000     volatile jlong* addr = (volatile jlong*)index_oop_from_field_offset_long(p, offset);
1001     ScopedReleaseAcquire releaseAcquire(addr);
<span class="line-modified">1002     return RawAccess&lt;&gt;::atomic_cmpxchg(x, addr, e) == e;</span>
1003   } else {
1004     assert_field_offset_sane(p, offset);
1005     ScopedReleaseAcquire releaseAcquire(p, offset);
<span class="line-modified">1006     return HeapAccess&lt;&gt;::atomic_cmpxchg_at(x, p, (ptrdiff_t)offset, e) == e;</span>
1007   }
1008 } UNSAFE_END
1009 
1010 static void post_thread_park_event(EventThreadPark* event, const oop obj, jlong timeout_nanos, jlong until_epoch_millis) {
1011   assert(event != NULL, &quot;invariant&quot;);
1012   assert(event-&gt;should_commit(), &quot;invariant&quot;);
1013   event-&gt;set_parkedClass((obj != NULL) ? obj-&gt;klass() : NULL);
1014   event-&gt;set_timeout(timeout_nanos);
1015   event-&gt;set_until(until_epoch_millis);
1016   event-&gt;set_address((obj != NULL) ? (u8)cast_from_oop&lt;uintptr_t&gt;(obj) : 0);
1017   event-&gt;commit();
1018 }
1019 
1020 UNSAFE_ENTRY(void, Unsafe_Park(JNIEnv *env, jobject unsafe, jboolean isAbsolute, jlong time)) {
1021   HOTSPOT_THREAD_PARK_BEGIN((uintptr_t) thread-&gt;parker(), (int) isAbsolute, time);
1022   EventThreadPark event;
1023 
1024   JavaThreadParkedState jtps(thread, time != 0);
1025   thread-&gt;parker()-&gt;park(isAbsolute != 0, time);
1026   if (event.should_commit()) {
</pre>
<hr />
<pre>
1031       if (isAbsolute != 0) {
1032         post_thread_park_event(&amp;event, obj, min_jlong, time);
1033       } else {
1034         post_thread_park_event(&amp;event, obj, time, min_jlong);
1035       }
1036     }
1037   }
1038   HOTSPOT_THREAD_PARK_END((uintptr_t) thread-&gt;parker());
1039 } UNSAFE_END
1040 
1041 UNSAFE_ENTRY(void, Unsafe_Unpark(JNIEnv *env, jobject unsafe, jobject jthread)) {
1042   Parker* p = NULL;
1043 
1044   if (jthread != NULL) {
1045     ThreadsListHandle tlh;
1046     JavaThread* thr = NULL;
1047     oop java_thread = NULL;
1048     (void) tlh.cv_internal_thread_to_JavaThread(jthread, &amp;thr, &amp;java_thread);
1049     if (java_thread != NULL) {
1050       // This is a valid oop.
<span class="line-modified">1051       jlong lp = java_lang_Thread::park_event(java_thread);</span>
<span class="line-modified">1052       if (lp != 0) {</span>
<span class="line-modified">1053         // This cast is OK even though the jlong might have been read</span>
<span class="line-removed">1054         // non-atomically on 32bit systems, since there, one word will</span>
<span class="line-removed">1055         // always be zero anyway and the value set is always the same</span>
<span class="line-removed">1056         p = (Parker*)addr_from_java(lp);</span>
<span class="line-removed">1057       } else {</span>
<span class="line-removed">1058         // Not cached in the java.lang.Thread oop yet (could be an</span>
<span class="line-removed">1059         // older version of library).</span>
<span class="line-removed">1060         if (thr != NULL) {</span>
<span class="line-removed">1061           // The JavaThread is alive.</span>
<span class="line-removed">1062           p = thr-&gt;parker();</span>
<span class="line-removed">1063           if (p != NULL) {</span>
<span class="line-removed">1064             // Cache the Parker in the java.lang.Thread oop for next time.</span>
<span class="line-removed">1065             java_lang_Thread::set_park_event(java_thread, addr_to_java(p));</span>
<span class="line-removed">1066           }</span>
<span class="line-removed">1067         }</span>
1068       }
1069     }
1070   } // ThreadsListHandle is destroyed here.
1071 



1072   if (p != NULL) {
1073     HOTSPOT_THREAD_UNPARK((uintptr_t) p);
1074     p-&gt;unpark();
1075   }
1076 } UNSAFE_END
1077 
1078 UNSAFE_ENTRY(jint, Unsafe_GetLoadAverage0(JNIEnv *env, jobject unsafe, jdoubleArray loadavg, jint nelem)) {
1079   const int max_nelem = 3;
1080   double la[max_nelem];
1081   jint ret;
1082 
1083   typeArrayOop a = typeArrayOop(JNIHandles::resolve_non_null(loadavg));
1084   assert(a-&gt;is_typeArray(), &quot;must be type array&quot;);
1085 
1086   ret = os::loadavg(la, nelem);
1087   if (ret == -1) {
1088     return -1;
1089   }
1090 
1091   // if successful, ret is the number of samples actually retrieved.
</pre>
<hr />
<pre>
1135     DECLARE_GETPUTOOP(Boolean, Z),
1136     DECLARE_GETPUTOOP(Byte, B),
1137     DECLARE_GETPUTOOP(Short, S),
1138     DECLARE_GETPUTOOP(Char, C),
1139     DECLARE_GETPUTOOP(Int, I),
1140     DECLARE_GETPUTOOP(Long, J),
1141     DECLARE_GETPUTOOP(Float, F),
1142     DECLARE_GETPUTOOP(Double, D),
1143 
1144     {CC &quot;allocateMemory0&quot;,    CC &quot;(J)&quot; ADR,              FN_PTR(Unsafe_AllocateMemory0)},
1145     {CC &quot;reallocateMemory0&quot;,  CC &quot;(&quot; ADR &quot;J)&quot; ADR,       FN_PTR(Unsafe_ReallocateMemory0)},
1146     {CC &quot;freeMemory0&quot;,        CC &quot;(&quot; ADR &quot;)V&quot;,           FN_PTR(Unsafe_FreeMemory0)},
1147 
1148     {CC &quot;objectFieldOffset0&quot;, CC &quot;(&quot; FLD &quot;)J&quot;,           FN_PTR(Unsafe_ObjectFieldOffset0)},
1149     {CC &quot;objectFieldOffset1&quot;, CC &quot;(&quot; CLS LANG &quot;String;)J&quot;, FN_PTR(Unsafe_ObjectFieldOffset1)},
1150     {CC &quot;staticFieldOffset0&quot;, CC &quot;(&quot; FLD &quot;)J&quot;,           FN_PTR(Unsafe_StaticFieldOffset0)},
1151     {CC &quot;staticFieldBase0&quot;,   CC &quot;(&quot; FLD &quot;)&quot; OBJ,        FN_PTR(Unsafe_StaticFieldBase0)},
1152     {CC &quot;ensureClassInitialized0&quot;, CC &quot;(&quot; CLS &quot;)V&quot;,      FN_PTR(Unsafe_EnsureClassInitialized0)},
1153     {CC &quot;arrayBaseOffset0&quot;,   CC &quot;(&quot; CLS &quot;)I&quot;,           FN_PTR(Unsafe_ArrayBaseOffset0)},
1154     {CC &quot;arrayIndexScale0&quot;,   CC &quot;(&quot; CLS &quot;)I&quot;,           FN_PTR(Unsafe_ArrayIndexScale0)},
<span class="line-removed">1155     {CC &quot;addressSize0&quot;,       CC &quot;()I&quot;,                  FN_PTR(Unsafe_AddressSize0)},</span>
<span class="line-removed">1156     {CC &quot;pageSize&quot;,           CC &quot;()I&quot;,                  FN_PTR(Unsafe_PageSize)},</span>
1157 
1158     {CC &quot;defineClass0&quot;,       CC &quot;(&quot; DC_Args &quot;)&quot; CLS,    FN_PTR(Unsafe_DefineClass0)},
1159     {CC &quot;allocateInstance&quot;,   CC &quot;(&quot; CLS &quot;)&quot; OBJ,        FN_PTR(Unsafe_AllocateInstance)},
1160     {CC &quot;throwException&quot;,     CC &quot;(&quot; THR &quot;)V&quot;,           FN_PTR(Unsafe_ThrowException)},
1161     {CC &quot;compareAndSetReference&quot;,CC &quot;(&quot; OBJ &quot;J&quot; OBJ &quot;&quot; OBJ &quot;)Z&quot;, FN_PTR(Unsafe_CompareAndSetReference)},
1162     {CC &quot;compareAndSetInt&quot;,   CC &quot;(&quot; OBJ &quot;J&quot;&quot;I&quot;&quot;I&quot;&quot;)Z&quot;,  FN_PTR(Unsafe_CompareAndSetInt)},
1163     {CC &quot;compareAndSetLong&quot;,  CC &quot;(&quot; OBJ &quot;J&quot;&quot;J&quot;&quot;J&quot;&quot;)Z&quot;,  FN_PTR(Unsafe_CompareAndSetLong)},
1164     {CC &quot;compareAndExchangeReference&quot;, CC &quot;(&quot; OBJ &quot;J&quot; OBJ &quot;&quot; OBJ &quot;)&quot; OBJ, FN_PTR(Unsafe_CompareAndExchangeReference)},
1165     {CC &quot;compareAndExchangeInt&quot;,  CC &quot;(&quot; OBJ &quot;J&quot;&quot;I&quot;&quot;I&quot;&quot;)I&quot;, FN_PTR(Unsafe_CompareAndExchangeInt)},
1166     {CC &quot;compareAndExchangeLong&quot;, CC &quot;(&quot; OBJ &quot;J&quot;&quot;J&quot;&quot;J&quot;&quot;)J&quot;, FN_PTR(Unsafe_CompareAndExchangeLong)},
1167 
1168     {CC &quot;park&quot;,               CC &quot;(ZJ)V&quot;,                FN_PTR(Unsafe_Park)},
1169     {CC &quot;unpark&quot;,             CC &quot;(&quot; OBJ &quot;)V&quot;,           FN_PTR(Unsafe_Unpark)},
1170 
1171     {CC &quot;getLoadAverage0&quot;,    CC &quot;([DI)I&quot;,               FN_PTR(Unsafe_GetLoadAverage0)},
1172 
1173     {CC &quot;copyMemory0&quot;,        CC &quot;(&quot; OBJ &quot;J&quot; OBJ &quot;JJ)V&quot;, FN_PTR(Unsafe_CopyMemory0)},
1174     {CC &quot;copySwapMemory0&quot;,    CC &quot;(&quot; OBJ &quot;J&quot; OBJ &quot;JJJ)V&quot;, FN_PTR(Unsafe_CopySwapMemory0)},



1175     {CC &quot;setMemory0&quot;,         CC &quot;(&quot; OBJ &quot;JJB)V&quot;,        FN_PTR(Unsafe_SetMemory0)},
1176 
1177     {CC &quot;defineAnonymousClass0&quot;, CC &quot;(&quot; DAC_Args &quot;)&quot; CLS, FN_PTR(Unsafe_DefineAnonymousClass0)},
1178 
1179     {CC &quot;shouldBeInitialized0&quot;, CC &quot;(&quot; CLS &quot;)Z&quot;,         FN_PTR(Unsafe_ShouldBeInitialized0)},
1180 
1181     {CC &quot;loadFence&quot;,          CC &quot;()V&quot;,                  FN_PTR(Unsafe_LoadFence)},
1182     {CC &quot;storeFence&quot;,         CC &quot;()V&quot;,                  FN_PTR(Unsafe_StoreFence)},
1183     {CC &quot;fullFence&quot;,          CC &quot;()V&quot;,                  FN_PTR(Unsafe_FullFence)},
<span class="line-removed">1184 </span>
<span class="line-removed">1185     {CC &quot;isBigEndian0&quot;,       CC &quot;()Z&quot;,                  FN_PTR(Unsafe_isBigEndian0)},</span>
<span class="line-removed">1186     {CC &quot;unalignedAccess0&quot;,   CC &quot;()Z&quot;,                  FN_PTR(Unsafe_unalignedAccess0)}</span>
1187 };
1188 
1189 #undef CC
1190 #undef FN_PTR
1191 
1192 #undef ADR
1193 #undef LANG
1194 #undef OBJ
1195 #undef CLS
1196 #undef FLD
1197 #undef THR
1198 #undef DC_Args
1199 #undef DAC_Args
1200 
1201 #undef DECLARE_GETPUTOOP
1202 
1203 
1204 // This function is exported, used by NativeLookup.
1205 // The Unsafe_xxx functions above are called only from the interpreter.
1206 // The optimizer looks at names and signatures to recognize
</pre>
</td>
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 2000, 2020, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include &quot;precompiled.hpp&quot;
  26 #include &quot;jni.h&quot;
  27 #include &quot;jvm.h&quot;
  28 #include &quot;classfile/classFileStream.hpp&quot;
<span class="line-added">  29 #include &quot;classfile/classLoader.hpp&quot;</span>
  30 #include &quot;classfile/vmSymbols.hpp&quot;
  31 #include &quot;jfr/jfrEvents.hpp&quot;
  32 #include &quot;memory/allocation.inline.hpp&quot;
  33 #include &quot;memory/resourceArea.hpp&quot;
  34 #include &quot;oops/access.inline.hpp&quot;
<span class="line-modified">  35 #include &quot;oops/fieldStreams.inline.hpp&quot;</span>
  36 #include &quot;oops/objArrayOop.inline.hpp&quot;
  37 #include &quot;oops/oop.inline.hpp&quot;
  38 #include &quot;oops/typeArrayOop.inline.hpp&quot;
  39 #include &quot;prims/unsafe.hpp&quot;

  40 #include &quot;runtime/globals.hpp&quot;
  41 #include &quot;runtime/handles.inline.hpp&quot;
  42 #include &quot;runtime/interfaceSupport.inline.hpp&quot;
  43 #include &quot;runtime/jniHandles.inline.hpp&quot;
  44 #include &quot;runtime/orderAccess.hpp&quot;
  45 #include &quot;runtime/reflection.hpp&quot;
<span class="line-added">  46 #include &quot;runtime/sharedRuntime.hpp&quot;</span>
  47 #include &quot;runtime/thread.hpp&quot;
  48 #include &quot;runtime/threadSMR.hpp&quot;
  49 #include &quot;runtime/vm_version.hpp&quot;
  50 #include &quot;services/threadService.hpp&quot;
  51 #include &quot;utilities/align.hpp&quot;
  52 #include &quot;utilities/copy.hpp&quot;
  53 #include &quot;utilities/dtrace.hpp&quot;
  54 #include &quot;utilities/macros.hpp&quot;
  55 #if INCLUDE_TSAN

  56 #include &quot;tsan/tsanExternalDecls.hpp&quot;
  57 #endif
  58 
  59 /**
  60  * Implementation of the jdk.internal.misc.Unsafe class
  61  */
  62 
  63 
  64 #define MAX_OBJECT_SIZE \
  65   ( arrayOopDesc::header_size(T_DOUBLE) * HeapWordSize \
  66     + ((julong)max_jint * sizeof(double)) )
  67 
  68 
  69 #define UNSAFE_ENTRY(result_type, header) \
  70   JVM_ENTRY(static result_type, header)
  71 
  72 #define UNSAFE_LEAF(result_type, header) \
  73   JVM_LEAF(static result_type, header)
  74 
  75 #define UNSAFE_END JVM_END
</pre>
<hr />
<pre>
  97 // through the Unsafe API are opaque cookies that just happen to be byte
  98 // offsets.  We represent this state of affairs by passing the cookies
  99 // through conversion functions when going between the VM and the Unsafe API.
 100 // The conversion functions just happen to be no-ops at present.
 101 
 102 static inline jlong field_offset_to_byte_offset(jlong field_offset) {
 103   return field_offset;
 104 }
 105 
 106 static inline jlong field_offset_from_byte_offset(jlong byte_offset) {
 107   return byte_offset;
 108 }
 109 
 110 static inline void assert_field_offset_sane(oop p, jlong field_offset) {
 111 #ifdef ASSERT
 112   jlong byte_offset = field_offset_to_byte_offset(field_offset);
 113 
 114   if (p != NULL) {
 115     assert(byte_offset &gt;= 0 &amp;&amp; byte_offset &lt;= (jlong)MAX_OBJECT_SIZE, &quot;sane offset&quot;);
 116     if (byte_offset == (jint)byte_offset) {
<span class="line-modified"> 117       void* ptr_plus_disp = cast_from_oop&lt;address&gt;(p) + byte_offset;</span>
 118       assert(p-&gt;field_addr_raw((jint)byte_offset) == ptr_plus_disp,
 119              &quot;raw [ptr+disp] must be consistent with oop::field_addr_raw&quot;);
 120     }
 121     jlong p_size = HeapWordSize * (jlong)(p-&gt;size());
 122     assert(byte_offset &lt; p_size, &quot;Unsafe access: offset &quot; INT64_FORMAT &quot; &gt; object&#39;s size &quot; INT64_FORMAT, (int64_t)byte_offset, (int64_t)p_size);
 123   }
 124 #endif
 125 }
 126 
 127 static inline void* index_oop_from_field_offset_long(oop p, jlong field_offset) {
 128   assert_field_offset_sane(p, field_offset);
 129   jlong byte_offset = field_offset_to_byte_offset(field_offset);
 130 
 131   if (p != NULL) {
 132     p = Access&lt;&gt;::resolve(p);
 133   }
 134 
 135   if (sizeof(char*) == sizeof(jint)) {   // (this constant folds!)
<span class="line-modified"> 136     return cast_from_oop&lt;address&gt;(p) + (jint) byte_offset;</span>
 137   } else {
<span class="line-modified"> 138     return cast_from_oop&lt;address&gt;(p) +        byte_offset;</span>
 139   }
 140 }
 141 
 142 // Externally callable versions:
 143 // (Use these in compiler intrinsics which emulate unsafe primitives.)
 144 jlong Unsafe_field_offset_to_byte_offset(jlong field_offset) {
 145   return field_offset;
 146 }
 147 jlong Unsafe_field_offset_from_byte_offset(jlong byte_offset) {
 148   return byte_offset;
 149 }
 150 
 151 
 152 ///// Data read/writes on the Java heap and in native (off-heap) memory
 153 
<span class="line-added"> 154 /**</span>
<span class="line-added"> 155  * Helper class to wrap memory accesses in JavaThread::doing_unsafe_access()</span>
<span class="line-added"> 156  */</span>
<span class="line-added"> 157 class GuardUnsafeAccess {</span>
<span class="line-added"> 158   JavaThread* _thread;</span>
<span class="line-added"> 159 </span>
<span class="line-added"> 160 public:</span>
<span class="line-added"> 161   GuardUnsafeAccess(JavaThread* thread) : _thread(thread) {</span>
<span class="line-added"> 162     // native/off-heap access which may raise SIGBUS if accessing</span>
<span class="line-added"> 163     // memory mapped file data in a region of the file which has</span>
<span class="line-added"> 164     // been truncated and is now invalid.</span>
<span class="line-added"> 165     _thread-&gt;set_doing_unsafe_access(true);</span>
<span class="line-added"> 166   }</span>
<span class="line-added"> 167 </span>
<span class="line-added"> 168   ~GuardUnsafeAccess() {</span>
<span class="line-added"> 169     _thread-&gt;set_doing_unsafe_access(false);</span>
<span class="line-added"> 170   }</span>
<span class="line-added"> 171 };</span>
<span class="line-added"> 172 </span>
 173 /**
 174  * Helper class for accessing memory.
 175  *
 176  * Normalizes values and wraps accesses in
 177  * JavaThread::doing_unsafe_access() if needed.
 178  */
 179 template &lt;typename T&gt;
 180 class MemoryAccess : StackObj {
 181   JavaThread* _thread;
 182   oop _obj;
 183   ptrdiff_t _offset;
 184 
 185   // Resolves and returns the address of the memory access.
 186   // This raw memory access may fault, so we make sure it happens within the
 187   // guarded scope by making the access volatile at least. Since the store
 188   // of Thread::set_doing_unsafe_access() is also volatile, these accesses
 189   // can not be reordered by the compiler. Therefore, if the access triggers
 190   // a fault, we will know that Thread::doing_unsafe_access() returns true.
 191   volatile T* addr() {
 192     void* addr = index_oop_from_field_offset_long(_obj, _offset);
</pre>
<hr />
<pre>
 194   }
 195 
 196   template &lt;typename U&gt;
 197   U normalize_for_write(U x) {
 198     return x;
 199   }
 200 
 201   jboolean normalize_for_write(jboolean x) {
 202     return x &amp; 1;
 203   }
 204 
 205   template &lt;typename U&gt;
 206   U normalize_for_read(U x) {
 207     return x;
 208   }
 209 
 210   jboolean normalize_for_read(jboolean x) {
 211     return x != 0;
 212   }
 213 



















 214 public:
 215   MemoryAccess(JavaThread* thread, jobject obj, jlong offset)
 216     : _thread(thread), _obj(JNIHandles::resolve(obj)), _offset((ptrdiff_t)offset) {
 217     assert_field_offset_sane(_obj, offset);
 218   }
 219 
 220   T get() {
 221     if (_obj == NULL) {
 222       GuardUnsafeAccess guard(_thread);
 223       T ret = RawAccess&lt;&gt;::load(addr());
 224       return normalize_for_read(ret);
 225     } else {
 226       T ret = HeapAccess&lt;&gt;::load_at(_obj, _offset);
 227       return normalize_for_read(ret);
 228     }
 229   }
 230 
 231   void put(T x) {
 232     if (_obj == NULL) {
 233       GuardUnsafeAccess guard(_thread);
</pre>
<hr />
<pre>
 302   );
 303   return JNIHandles::make_local(env, v);
 304 } UNSAFE_END
 305 
 306 UNSAFE_ENTRY(void, Unsafe_PutReferenceVolatile(JNIEnv *env, jobject unsafe, jobject obj, jlong offset, jobject x_h)) {
 307   oop x = JNIHandles::resolve(x_h);
 308   oop p = JNIHandles::resolve(obj);
 309   assert_field_offset_sane(p, offset);
 310   TSAN_RUNTIME_ONLY(
 311     void* addr = index_oop_from_field_offset_long(p, offset);
 312     __tsan_java_release(addr);
 313   );
 314   HeapAccess&lt;MO_SEQ_CST | ON_UNKNOWN_OOP_REF&gt;::oop_store_at(p, offset, x);
 315 } UNSAFE_END
 316 
 317 UNSAFE_ENTRY(jobject, Unsafe_GetUncompressedObject(JNIEnv *env, jobject unsafe, jlong addr)) {
 318   oop v = *(oop*) (address) addr;
 319   return JNIHandles::make_local(env, v);
 320 } UNSAFE_END
 321 












 322 #define DEFINE_GETSETOOP(java_type, Type, size) \
 323  \
 324 UNSAFE_ENTRY(java_type, Unsafe_Get##Type(JNIEnv *env, jobject unsafe, jobject obj, jlong offset)) { \
 325   java_type ret = MemoryAccess&lt;java_type&gt;(thread, obj, offset).get(); \
 326   TSAN_RUNTIME_ONLY( \
 327     void* addr = index_oop_from_field_offset_long(JNIHandles::resolve(obj), offset); \
 328     __tsan_read##size##_pc(addr, SharedRuntime::tsan_code_location(0, 0)); \
 329   ); \
 330   return ret; \
 331 } UNSAFE_END \
 332  \
 333 UNSAFE_ENTRY(void, Unsafe_Put##Type(JNIEnv *env, jobject unsafe, jobject obj, jlong offset, java_type x)) { \
 334   TSAN_RUNTIME_ONLY( \
 335     void* addr = index_oop_from_field_offset_long(JNIHandles::resolve(obj), offset); \
 336     __tsan_write##size##_pc(addr, SharedRuntime::tsan_code_location(0, 0)); \
 337   ); \
 338   MemoryAccess&lt;java_type&gt;(thread, obj, offset).put(x); \
 339 } UNSAFE_END \
 340  \
 341 // END DEFINE_GETSETOOP.
</pre>
<hr />
<pre>
 388 } UNSAFE_END
 389 
 390 UNSAFE_LEAF(void, Unsafe_StoreFence(JNIEnv *env, jobject unsafe)) {
 391   OrderAccess::release();
 392 } UNSAFE_END
 393 
 394 UNSAFE_LEAF(void, Unsafe_FullFence(JNIEnv *env, jobject unsafe)) {
 395   OrderAccess::fence();
 396 } UNSAFE_END
 397 
 398 ////// Allocation requests
 399 
 400 UNSAFE_ENTRY(jobject, Unsafe_AllocateInstance(JNIEnv *env, jobject unsafe, jclass cls)) {
 401   ThreadToNativeFromVM ttnfv(thread);
 402   return env-&gt;AllocObject(cls);
 403 } UNSAFE_END
 404 
 405 UNSAFE_ENTRY(jlong, Unsafe_AllocateMemory0(JNIEnv *env, jobject unsafe, jlong size)) {
 406   size_t sz = (size_t)size;
 407 
<span class="line-modified"> 408   assert(is_aligned(sz, HeapWordSize), &quot;sz not aligned&quot;);</span>
<span class="line-added"> 409 </span>
 410   void* x = os::malloc(sz, mtOther);
 411 
 412   return addr_to_java(x);
 413 } UNSAFE_END
 414 
 415 UNSAFE_ENTRY(jlong, Unsafe_ReallocateMemory0(JNIEnv *env, jobject unsafe, jlong addr, jlong size)) {
 416   void* p = addr_from_java(addr);
 417   size_t sz = (size_t)size;
<span class="line-modified"> 418 </span>
<span class="line-added"> 419   assert(is_aligned(sz, HeapWordSize), &quot;sz not aligned&quot;);</span>
 420 
 421   void* x = os::realloc(p, sz, mtOther);
 422 
 423   return addr_to_java(x);
 424 } UNSAFE_END
 425 
 426 UNSAFE_ENTRY(void, Unsafe_FreeMemory0(JNIEnv *env, jobject unsafe, jlong addr)) {
 427   void* p = addr_from_java(addr);
 428 
 429   os::free(p);
 430 } UNSAFE_END
 431 
 432 UNSAFE_ENTRY(void, Unsafe_SetMemory0(JNIEnv *env, jobject unsafe, jobject obj, jlong offset, jlong size, jbyte value)) {
 433   size_t sz = (size_t)size;
 434 
 435   oop base = JNIHandles::resolve(obj);
 436   void* p = index_oop_from_field_offset_long(base, offset);
 437 
 438   Copy::fill_to_memory_atomic(p, sz, value);
 439 } UNSAFE_END
 440 
 441 UNSAFE_ENTRY(void, Unsafe_CopyMemory0(JNIEnv *env, jobject unsafe, jobject srcObj, jlong srcOffset, jobject dstObj, jlong dstOffset, jlong size)) {
 442   size_t sz = (size_t)size;
 443 
 444   oop srcp = JNIHandles::resolve(srcObj);
 445   oop dstp = JNIHandles::resolve(dstObj);
 446 
 447   void* src = index_oop_from_field_offset_long(srcp, srcOffset);
 448   void* dst = index_oop_from_field_offset_long(dstp, dstOffset);
<span class="line-modified"> 449   {</span>
<span class="line-modified"> 450     GuardUnsafeAccess guard(thread);</span>
<span class="line-added"> 451     if (StubRoutines::unsafe_arraycopy() != NULL) {</span>
<span class="line-added"> 452       StubRoutines::UnsafeArrayCopy_stub()(src, dst, sz);</span>
<span class="line-added"> 453     } else {</span>
<span class="line-added"> 454       Copy::conjoint_memory_atomic(src, dst, sz);</span>
<span class="line-added"> 455     }</span>
<span class="line-added"> 456   }</span>
 457 } UNSAFE_END
 458 
 459 // This function is a leaf since if the source and destination are both in native memory
 460 // the copy may potentially be very large, and we don&#39;t want to disable GC if we can avoid it.
 461 // If either source or destination (or both) are on the heap, the function will enter VM using
 462 // JVM_ENTRY_FROM_LEAF
 463 UNSAFE_LEAF(void, Unsafe_CopySwapMemory0(JNIEnv *env, jobject unsafe, jobject srcObj, jlong srcOffset, jobject dstObj, jlong dstOffset, jlong size, jlong elemSize)) {
 464   size_t sz = (size_t)size;
 465   size_t esz = (size_t)elemSize;
 466 
 467   if (srcObj == NULL &amp;&amp; dstObj == NULL) {
 468     // Both src &amp; dst are in native memory
 469     address src = (address)srcOffset;
 470     address dst = (address)dstOffset;
 471 
<span class="line-modified"> 472     {</span>
<span class="line-added"> 473       JavaThread* thread = JavaThread::thread_from_jni_environment(env);</span>
<span class="line-added"> 474       GuardUnsafeAccess guard(thread);</span>
<span class="line-added"> 475       Copy::conjoint_swap(src, dst, sz, esz);</span>
<span class="line-added"> 476     }</span>
 477   } else {
 478     // At least one of src/dst are on heap, transition to VM to access raw pointers
 479 
 480     JVM_ENTRY_FROM_LEAF(env, void, Unsafe_CopySwapMemory0) {
 481       oop srcp = JNIHandles::resolve(srcObj);
 482       oop dstp = JNIHandles::resolve(dstObj);
 483 
 484       address src = (address)index_oop_from_field_offset_long(srcp, srcOffset);
 485       address dst = (address)index_oop_from_field_offset_long(dstp, dstOffset);
 486 
<span class="line-modified"> 487       {</span>
<span class="line-added"> 488         GuardUnsafeAccess guard(thread);</span>
<span class="line-added"> 489         Copy::conjoint_swap(src, dst, sz, esz);</span>
<span class="line-added"> 490       }</span>
 491     } JVM_END
 492   }
 493 } UNSAFE_END
 494 
<span class="line-modified"> 495 UNSAFE_LEAF (void, Unsafe_WriteBack0(JNIEnv *env, jobject unsafe, jlong line)) {</span>
<span class="line-added"> 496   assert(VM_Version::supports_data_cache_line_flush(), &quot;should not get here&quot;);</span>
<span class="line-added"> 497 #ifdef ASSERT</span>
<span class="line-added"> 498   if (TraceMemoryWriteback) {</span>
<span class="line-added"> 499     tty-&gt;print_cr(&quot;Unsafe: writeback 0x%p&quot;, addr_from_java(line));</span>
<span class="line-added"> 500   }</span>
<span class="line-added"> 501 #endif</span>
 502 
<span class="line-modified"> 503   assert(StubRoutines::data_cache_writeback() != NULL, &quot;sanity&quot;);</span>
<span class="line-modified"> 504   (StubRoutines::DataCacheWriteback_stub())(addr_from_java(line));</span>
 505 } UNSAFE_END
 506 
<span class="line-modified"> 507 static void doWriteBackSync0(bool is_pre)</span>
<span class="line-modified"> 508 {</span>
<span class="line-added"> 509   assert(StubRoutines::data_cache_writeback_sync() != NULL, &quot;sanity&quot;);</span>
<span class="line-added"> 510   (StubRoutines::DataCacheWritebackSync_stub())(is_pre);</span>
<span class="line-added"> 511 }</span>
<span class="line-added"> 512 </span>
<span class="line-added"> 513 UNSAFE_LEAF (void, Unsafe_WriteBackPreSync0(JNIEnv *env, jobject unsafe)) {</span>
<span class="line-added"> 514   assert(VM_Version::supports_data_cache_line_flush(), &quot;should not get here&quot;);</span>
<span class="line-added"> 515 #ifdef ASSERT</span>
<span class="line-added"> 516   if (TraceMemoryWriteback) {</span>
<span class="line-added"> 517       tty-&gt;print_cr(&quot;Unsafe: writeback pre-sync&quot;);</span>
<span class="line-added"> 518   }</span>
<span class="line-added"> 519 #endif</span>
<span class="line-added"> 520 </span>
<span class="line-added"> 521   doWriteBackSync0(true);</span>
<span class="line-added"> 522 } UNSAFE_END</span>
<span class="line-added"> 523 </span>
<span class="line-added"> 524 UNSAFE_LEAF (void, Unsafe_WriteBackPostSync0(JNIEnv *env, jobject unsafe)) {</span>
<span class="line-added"> 525   assert(VM_Version::supports_data_cache_line_flush(), &quot;should not get here&quot;);</span>
<span class="line-added"> 526 #ifdef ASSERT</span>
<span class="line-added"> 527   if (TraceMemoryWriteback) {</span>
<span class="line-added"> 528     tty-&gt;print_cr(&quot;Unsafe: writeback pre-sync&quot;);</span>
<span class="line-added"> 529   }</span>
<span class="line-added"> 530 #endif</span>
<span class="line-added"> 531 </span>
<span class="line-added"> 532   doWriteBackSync0(false);</span>
 533 } UNSAFE_END
 534 
<span class="line-added"> 535 ////// Random queries</span>
<span class="line-added"> 536 </span>
 537 static jlong find_field_offset(jclass clazz, jstring name, TRAPS) {
 538   assert(clazz != NULL, &quot;clazz must not be NULL&quot;);
 539   assert(name != NULL, &quot;name must not be NULL&quot;);
 540 
 541   ResourceMark rm(THREAD);
 542   char *utf_name = java_lang_String::as_utf8_string(JNIHandles::resolve_non_null(name));
 543 
 544   InstanceKlass* k = InstanceKlass::cast(java_lang_Class::as_Klass(JNIHandles::resolve_non_null(clazz)));
 545 
 546   jint offset = -1;
 547   for (JavaFieldStream fs(k); !fs.done(); fs.next()) {
 548     Symbol *name = fs.name();
 549     if (name-&gt;equals(utf_name)) {
 550       offset = fs.offset();
 551       break;
 552     }
 553   }
 554   if (offset &lt; 0) {
 555     THROW_0(vmSymbols::java_lang_InternalError());
 556   }
</pre>
<hr />
<pre>
 698   }
 699 
 700   env-&gt;ThrowNew(cls, NULL);
 701 }
 702 
 703 static jclass Unsafe_DefineClass_impl(JNIEnv *env, jstring name, jbyteArray data, int offset, int length, jobject loader, jobject pd) {
 704   // Code lifted from JDK 1.3 ClassLoader.c
 705 
 706   jbyte *body;
 707   char *utfName = NULL;
 708   jclass result = 0;
 709   char buf[128];
 710 
 711   assert(data != NULL, &quot;Class bytes must not be NULL&quot;);
 712   assert(length &gt;= 0, &quot;length must not be negative: %d&quot;, length);
 713 
 714   if (UsePerfData) {
 715     ClassLoader::unsafe_defineClassCallCounter()-&gt;inc();
 716   }
 717 
<span class="line-modified"> 718   body = NEW_C_HEAP_ARRAY_RETURN_NULL(jbyte, length, mtInternal);</span>
 719   if (body == NULL) {
 720     throw_new(env, &quot;java/lang/OutOfMemoryError&quot;);
 721     return 0;
 722   }
 723 
 724   env-&gt;GetByteArrayRegion(data, offset, length, body);
 725   if (env-&gt;ExceptionOccurred()) {
 726     goto free_body;
 727   }
 728 
 729   if (name != NULL) {
 730     uint len = env-&gt;GetStringUTFLength(name);
 731     int unicode_len = env-&gt;GetStringLength(name);
 732 
 733     if (len &gt;= sizeof(buf)) {
<span class="line-modified"> 734       utfName = NEW_C_HEAP_ARRAY_RETURN_NULL(char, len + 1, mtInternal);</span>
 735       if (utfName == NULL) {
 736         throw_new(env, &quot;java/lang/OutOfMemoryError&quot;);
 737         goto free_body;
 738       }
 739     } else {
 740       utfName = buf;
 741     }
 742 
 743     env-&gt;GetStringUTFRegion(name, 0, unicode_len, utfName);
 744 
 745     for (uint i = 0; i &lt; len; i++) {
 746       if (utfName[i] == &#39;.&#39;)   utfName[i] = &#39;/&#39;;
 747     }
 748   }
 749 
 750   result = JVM_DefineClass(env, utfName, loader, body, length, pd);
 751 
 752   if (utfName &amp;&amp; utfName != buf) {
 753     FREE_C_HEAP_ARRAY(char, utfName);
 754   }
</pre>
<hr />
<pre>
 819 // not just a literal string.  For such ldc instructions, the verifier uses the
 820 // type Object instead of String, if the loaded constant is not in fact a String.
 821 
 822 static InstanceKlass*
 823 Unsafe_DefineAnonymousClass_impl(JNIEnv *env,
 824                                  jclass host_class, jbyteArray data, jobjectArray cp_patches_jh,
 825                                  u1** temp_alloc,
 826                                  TRAPS) {
 827   assert(host_class != NULL, &quot;host_class must not be NULL&quot;);
 828   assert(data != NULL, &quot;data must not be NULL&quot;);
 829 
 830   if (UsePerfData) {
 831     ClassLoader::unsafe_defineClassCallCounter()-&gt;inc();
 832   }
 833 
 834   jint length = typeArrayOop(JNIHandles::resolve_non_null(data))-&gt;length();
 835   assert(length &gt;= 0, &quot;class_bytes_length must not be negative: %d&quot;, length);
 836 
 837   int class_bytes_length = (int) length;
 838 
<span class="line-modified"> 839   u1* class_bytes = NEW_C_HEAP_ARRAY_RETURN_NULL(u1, length, mtInternal);</span>
 840   if (class_bytes == NULL) {
 841     THROW_0(vmSymbols::java_lang_OutOfMemoryError());
 842   }
 843 
 844   // caller responsible to free it:
 845   *temp_alloc = class_bytes;
 846 
 847   ArrayAccess&lt;&gt;::arraycopy_to_native(arrayOop(JNIHandles::resolve_non_null(data)), typeArrayOopDesc::element_offset&lt;jbyte&gt;(0),
 848                                      reinterpret_cast&lt;jbyte*&gt;(class_bytes), length);
 849 
 850   objArrayHandle cp_patches_h;
 851   if (cp_patches_jh != NULL) {
 852     oop p = JNIHandles::resolve_non_null(cp_patches_jh);
 853     assert(p-&gt;is_objArray(), &quot;cp_patches must be an object[]&quot;);
 854     cp_patches_h = objArrayHandle(THREAD, (objArrayOop)p);
 855   }
 856 
 857   const Klass* host_klass = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(host_class));
 858 
 859   // Make sure it&#39;s the real host class, not another anonymous class.
</pre>
<hr />
<pre>
 904                                                 CHECK_NULL);
 905   if (anonk == NULL) {
 906     return NULL;
 907   }
 908 
 909   return InstanceKlass::cast(anonk);
 910 }
 911 
 912 UNSAFE_ENTRY(jclass, Unsafe_DefineAnonymousClass0(JNIEnv *env, jobject unsafe, jclass host_class, jbyteArray data, jobjectArray cp_patches_jh)) {
 913   ResourceMark rm(THREAD);
 914 
 915   jobject res_jh = NULL;
 916   u1* temp_alloc = NULL;
 917 
 918   InstanceKlass* anon_klass = Unsafe_DefineAnonymousClass_impl(env, host_class, data, cp_patches_jh, &amp;temp_alloc, THREAD);
 919   if (anon_klass != NULL) {
 920     res_jh = JNIHandles::make_local(env, anon_klass-&gt;java_mirror());
 921   }
 922 
 923   // try/finally clause:
<span class="line-modified"> 924   FREE_C_HEAP_ARRAY(u1, temp_alloc);</span>


 925 
 926   // The anonymous class loader data has been artificially been kept alive to
 927   // this point.   The mirror and any instances of this class have to keep
 928   // it alive afterwards.
 929   if (anon_klass != NULL) {
 930     anon_klass-&gt;class_loader_data()-&gt;dec_keep_alive();
 931   }
 932 
 933   // let caller initialize it as needed...
 934 
 935   return (jclass) res_jh;
 936 } UNSAFE_END
 937 
 938 
 939 
 940 UNSAFE_ENTRY(void, Unsafe_ThrowException(JNIEnv *env, jobject unsafe, jthrowable thr)) {
 941   ThreadToNativeFromVM ttnfv(thread);
 942   env-&gt;Throw(thr);
 943 } UNSAFE_END
 944 
</pre>
<hr />
<pre>
 957   }
 958 
 959   ScopedReleaseAcquire(oop obj, jlong offset) {
 960     TSAN_RUNTIME_ONLY(
 961       _addr = index_oop_from_field_offset_long(obj, offset);
 962       __tsan_java_release(_addr);
 963     );
 964   }
 965 
 966   ~ScopedReleaseAcquire() {
 967     TSAN_RUNTIME_ONLY(__tsan_java_acquire(_addr));
 968   }
 969 };
 970 
 971 UNSAFE_ENTRY(jobject, Unsafe_CompareAndExchangeReference(JNIEnv *env, jobject unsafe, jobject obj, jlong offset, jobject e_h, jobject x_h)) {
 972   oop x = JNIHandles::resolve(x_h);
 973   oop e = JNIHandles::resolve(e_h);
 974   oop p = JNIHandles::resolve(obj);
 975   assert_field_offset_sane(p, offset);
 976   ScopedReleaseAcquire releaseAcquire(p, offset);
<span class="line-modified"> 977   oop res = HeapAccess&lt;ON_UNKNOWN_OOP_REF&gt;::oop_atomic_cmpxchg_at(p, (ptrdiff_t)offset, e, x);</span>
 978   return JNIHandles::make_local(env, res);
 979 } UNSAFE_END
 980 
 981 UNSAFE_ENTRY(jint, Unsafe_CompareAndExchangeInt(JNIEnv *env, jobject unsafe, jobject obj, jlong offset, jint e, jint x)) {
 982   oop p = JNIHandles::resolve(obj);
 983   if (p == NULL) {
 984     volatile jint* addr = (volatile jint*)index_oop_from_field_offset_long(p, offset);
 985     ScopedReleaseAcquire releaseAcquire(addr);
<span class="line-modified"> 986     return RawAccess&lt;&gt;::atomic_cmpxchg(addr, e, x);</span>
 987   } else {
 988     assert_field_offset_sane(p, offset);
 989     ScopedReleaseAcquire releaseAcquire(p, offset);
<span class="line-modified"> 990     return HeapAccess&lt;&gt;::atomic_cmpxchg_at(p, (ptrdiff_t)offset, e, x);</span>
 991   }
 992 } UNSAFE_END
 993 
 994 UNSAFE_ENTRY(jlong, Unsafe_CompareAndExchangeLong(JNIEnv *env, jobject unsafe, jobject obj, jlong offset, jlong e, jlong x)) {
 995   oop p = JNIHandles::resolve(obj);
 996   if (p == NULL) {
 997     volatile jlong* addr = (volatile jlong*)index_oop_from_field_offset_long(p, offset);
 998     ScopedReleaseAcquire releaseAcquire(addr);
<span class="line-modified"> 999     return RawAccess&lt;&gt;::atomic_cmpxchg(addr, e, x);</span>
1000   } else {
1001     assert_field_offset_sane(p, offset);
1002     ScopedReleaseAcquire releaseAcquire(p, offset);
<span class="line-modified">1003     return HeapAccess&lt;&gt;::atomic_cmpxchg_at(p, (ptrdiff_t)offset, e, x);</span>
1004   }
1005 } UNSAFE_END
1006 
1007 UNSAFE_ENTRY(jboolean, Unsafe_CompareAndSetReference(JNIEnv *env, jobject unsafe, jobject obj, jlong offset, jobject e_h, jobject x_h)) {
1008   oop x = JNIHandles::resolve(x_h);
1009   oop e = JNIHandles::resolve(e_h);
1010   oop p = JNIHandles::resolve(obj);
1011   assert_field_offset_sane(p, offset);
1012   ScopedReleaseAcquire releaseAcquire(p, offset);
<span class="line-modified">1013   oop ret = HeapAccess&lt;ON_UNKNOWN_OOP_REF&gt;::oop_atomic_cmpxchg_at(p, (ptrdiff_t)offset, e, x);</span>
<span class="line-modified">1014   return ret == e;</span>
1015 } UNSAFE_END
1016 
1017 UNSAFE_ENTRY(jboolean, Unsafe_CompareAndSetInt(JNIEnv *env, jobject unsafe, jobject obj, jlong offset, jint e, jint x)) {
1018   oop p = JNIHandles::resolve(obj);
1019   if (p == NULL) {
1020     volatile jint* addr = (volatile jint*)index_oop_from_field_offset_long(p, offset);
1021     ScopedReleaseAcquire releaseAcquire(addr);
<span class="line-modified">1022     return RawAccess&lt;&gt;::atomic_cmpxchg(addr, e, x) == e;</span>
1023   } else {
1024     assert_field_offset_sane(p, offset);
1025     ScopedReleaseAcquire releaseAcquire(p, offset);
<span class="line-modified">1026     return HeapAccess&lt;&gt;::atomic_cmpxchg_at(p, (ptrdiff_t)offset, e, x) == e;</span>
1027   }
1028 } UNSAFE_END
1029 
1030 UNSAFE_ENTRY(jboolean, Unsafe_CompareAndSetLong(JNIEnv *env, jobject unsafe, jobject obj, jlong offset, jlong e, jlong x)) {
1031   oop p = JNIHandles::resolve(obj);
1032   if (p == NULL) {
1033     volatile jlong* addr = (volatile jlong*)index_oop_from_field_offset_long(p, offset);
1034     ScopedReleaseAcquire releaseAcquire(addr);
<span class="line-modified">1035     return RawAccess&lt;&gt;::atomic_cmpxchg(addr, e, x) == e;</span>
1036   } else {
1037     assert_field_offset_sane(p, offset);
1038     ScopedReleaseAcquire releaseAcquire(p, offset);
<span class="line-modified">1039     return HeapAccess&lt;&gt;::atomic_cmpxchg_at(p, (ptrdiff_t)offset, e, x) == e;</span>
1040   }
1041 } UNSAFE_END
1042 
1043 static void post_thread_park_event(EventThreadPark* event, const oop obj, jlong timeout_nanos, jlong until_epoch_millis) {
1044   assert(event != NULL, &quot;invariant&quot;);
1045   assert(event-&gt;should_commit(), &quot;invariant&quot;);
1046   event-&gt;set_parkedClass((obj != NULL) ? obj-&gt;klass() : NULL);
1047   event-&gt;set_timeout(timeout_nanos);
1048   event-&gt;set_until(until_epoch_millis);
1049   event-&gt;set_address((obj != NULL) ? (u8)cast_from_oop&lt;uintptr_t&gt;(obj) : 0);
1050   event-&gt;commit();
1051 }
1052 
1053 UNSAFE_ENTRY(void, Unsafe_Park(JNIEnv *env, jobject unsafe, jboolean isAbsolute, jlong time)) {
1054   HOTSPOT_THREAD_PARK_BEGIN((uintptr_t) thread-&gt;parker(), (int) isAbsolute, time);
1055   EventThreadPark event;
1056 
1057   JavaThreadParkedState jtps(thread, time != 0);
1058   thread-&gt;parker()-&gt;park(isAbsolute != 0, time);
1059   if (event.should_commit()) {
</pre>
<hr />
<pre>
1064       if (isAbsolute != 0) {
1065         post_thread_park_event(&amp;event, obj, min_jlong, time);
1066       } else {
1067         post_thread_park_event(&amp;event, obj, time, min_jlong);
1068       }
1069     }
1070   }
1071   HOTSPOT_THREAD_PARK_END((uintptr_t) thread-&gt;parker());
1072 } UNSAFE_END
1073 
1074 UNSAFE_ENTRY(void, Unsafe_Unpark(JNIEnv *env, jobject unsafe, jobject jthread)) {
1075   Parker* p = NULL;
1076 
1077   if (jthread != NULL) {
1078     ThreadsListHandle tlh;
1079     JavaThread* thr = NULL;
1080     oop java_thread = NULL;
1081     (void) tlh.cv_internal_thread_to_JavaThread(jthread, &amp;thr, &amp;java_thread);
1082     if (java_thread != NULL) {
1083       // This is a valid oop.
<span class="line-modified">1084       if (thr != NULL) {</span>
<span class="line-modified">1085         // The JavaThread is alive.</span>
<span class="line-modified">1086         p = thr-&gt;parker();</span>














1087       }
1088     }
1089   } // ThreadsListHandle is destroyed here.
1090 
<span class="line-added">1091   // &#39;p&#39; points to type-stable-memory if non-NULL. If the target</span>
<span class="line-added">1092   // thread terminates before we get here the new user of this</span>
<span class="line-added">1093   // Parker will get a &#39;spurious&#39; unpark - which is perfectly valid.</span>
1094   if (p != NULL) {
1095     HOTSPOT_THREAD_UNPARK((uintptr_t) p);
1096     p-&gt;unpark();
1097   }
1098 } UNSAFE_END
1099 
1100 UNSAFE_ENTRY(jint, Unsafe_GetLoadAverage0(JNIEnv *env, jobject unsafe, jdoubleArray loadavg, jint nelem)) {
1101   const int max_nelem = 3;
1102   double la[max_nelem];
1103   jint ret;
1104 
1105   typeArrayOop a = typeArrayOop(JNIHandles::resolve_non_null(loadavg));
1106   assert(a-&gt;is_typeArray(), &quot;must be type array&quot;);
1107 
1108   ret = os::loadavg(la, nelem);
1109   if (ret == -1) {
1110     return -1;
1111   }
1112 
1113   // if successful, ret is the number of samples actually retrieved.
</pre>
<hr />
<pre>
1157     DECLARE_GETPUTOOP(Boolean, Z),
1158     DECLARE_GETPUTOOP(Byte, B),
1159     DECLARE_GETPUTOOP(Short, S),
1160     DECLARE_GETPUTOOP(Char, C),
1161     DECLARE_GETPUTOOP(Int, I),
1162     DECLARE_GETPUTOOP(Long, J),
1163     DECLARE_GETPUTOOP(Float, F),
1164     DECLARE_GETPUTOOP(Double, D),
1165 
1166     {CC &quot;allocateMemory0&quot;,    CC &quot;(J)&quot; ADR,              FN_PTR(Unsafe_AllocateMemory0)},
1167     {CC &quot;reallocateMemory0&quot;,  CC &quot;(&quot; ADR &quot;J)&quot; ADR,       FN_PTR(Unsafe_ReallocateMemory0)},
1168     {CC &quot;freeMemory0&quot;,        CC &quot;(&quot; ADR &quot;)V&quot;,           FN_PTR(Unsafe_FreeMemory0)},
1169 
1170     {CC &quot;objectFieldOffset0&quot;, CC &quot;(&quot; FLD &quot;)J&quot;,           FN_PTR(Unsafe_ObjectFieldOffset0)},
1171     {CC &quot;objectFieldOffset1&quot;, CC &quot;(&quot; CLS LANG &quot;String;)J&quot;, FN_PTR(Unsafe_ObjectFieldOffset1)},
1172     {CC &quot;staticFieldOffset0&quot;, CC &quot;(&quot; FLD &quot;)J&quot;,           FN_PTR(Unsafe_StaticFieldOffset0)},
1173     {CC &quot;staticFieldBase0&quot;,   CC &quot;(&quot; FLD &quot;)&quot; OBJ,        FN_PTR(Unsafe_StaticFieldBase0)},
1174     {CC &quot;ensureClassInitialized0&quot;, CC &quot;(&quot; CLS &quot;)V&quot;,      FN_PTR(Unsafe_EnsureClassInitialized0)},
1175     {CC &quot;arrayBaseOffset0&quot;,   CC &quot;(&quot; CLS &quot;)I&quot;,           FN_PTR(Unsafe_ArrayBaseOffset0)},
1176     {CC &quot;arrayIndexScale0&quot;,   CC &quot;(&quot; CLS &quot;)I&quot;,           FN_PTR(Unsafe_ArrayIndexScale0)},


1177 
1178     {CC &quot;defineClass0&quot;,       CC &quot;(&quot; DC_Args &quot;)&quot; CLS,    FN_PTR(Unsafe_DefineClass0)},
1179     {CC &quot;allocateInstance&quot;,   CC &quot;(&quot; CLS &quot;)&quot; OBJ,        FN_PTR(Unsafe_AllocateInstance)},
1180     {CC &quot;throwException&quot;,     CC &quot;(&quot; THR &quot;)V&quot;,           FN_PTR(Unsafe_ThrowException)},
1181     {CC &quot;compareAndSetReference&quot;,CC &quot;(&quot; OBJ &quot;J&quot; OBJ &quot;&quot; OBJ &quot;)Z&quot;, FN_PTR(Unsafe_CompareAndSetReference)},
1182     {CC &quot;compareAndSetInt&quot;,   CC &quot;(&quot; OBJ &quot;J&quot;&quot;I&quot;&quot;I&quot;&quot;)Z&quot;,  FN_PTR(Unsafe_CompareAndSetInt)},
1183     {CC &quot;compareAndSetLong&quot;,  CC &quot;(&quot; OBJ &quot;J&quot;&quot;J&quot;&quot;J&quot;&quot;)Z&quot;,  FN_PTR(Unsafe_CompareAndSetLong)},
1184     {CC &quot;compareAndExchangeReference&quot;, CC &quot;(&quot; OBJ &quot;J&quot; OBJ &quot;&quot; OBJ &quot;)&quot; OBJ, FN_PTR(Unsafe_CompareAndExchangeReference)},
1185     {CC &quot;compareAndExchangeInt&quot;,  CC &quot;(&quot; OBJ &quot;J&quot;&quot;I&quot;&quot;I&quot;&quot;)I&quot;, FN_PTR(Unsafe_CompareAndExchangeInt)},
1186     {CC &quot;compareAndExchangeLong&quot;, CC &quot;(&quot; OBJ &quot;J&quot;&quot;J&quot;&quot;J&quot;&quot;)J&quot;, FN_PTR(Unsafe_CompareAndExchangeLong)},
1187 
1188     {CC &quot;park&quot;,               CC &quot;(ZJ)V&quot;,                FN_PTR(Unsafe_Park)},
1189     {CC &quot;unpark&quot;,             CC &quot;(&quot; OBJ &quot;)V&quot;,           FN_PTR(Unsafe_Unpark)},
1190 
1191     {CC &quot;getLoadAverage0&quot;,    CC &quot;([DI)I&quot;,               FN_PTR(Unsafe_GetLoadAverage0)},
1192 
1193     {CC &quot;copyMemory0&quot;,        CC &quot;(&quot; OBJ &quot;J&quot; OBJ &quot;JJ)V&quot;, FN_PTR(Unsafe_CopyMemory0)},
1194     {CC &quot;copySwapMemory0&quot;,    CC &quot;(&quot; OBJ &quot;J&quot; OBJ &quot;JJJ)V&quot;, FN_PTR(Unsafe_CopySwapMemory0)},
<span class="line-added">1195     {CC &quot;writeback0&quot;,         CC &quot;(&quot; &quot;J&quot; &quot;)V&quot;,           FN_PTR(Unsafe_WriteBack0)},</span>
<span class="line-added">1196     {CC &quot;writebackPreSync0&quot;,  CC &quot;()V&quot;,                  FN_PTR(Unsafe_WriteBackPreSync0)},</span>
<span class="line-added">1197     {CC &quot;writebackPostSync0&quot;, CC &quot;()V&quot;,                  FN_PTR(Unsafe_WriteBackPostSync0)},</span>
1198     {CC &quot;setMemory0&quot;,         CC &quot;(&quot; OBJ &quot;JJB)V&quot;,        FN_PTR(Unsafe_SetMemory0)},
1199 
1200     {CC &quot;defineAnonymousClass0&quot;, CC &quot;(&quot; DAC_Args &quot;)&quot; CLS, FN_PTR(Unsafe_DefineAnonymousClass0)},
1201 
1202     {CC &quot;shouldBeInitialized0&quot;, CC &quot;(&quot; CLS &quot;)Z&quot;,         FN_PTR(Unsafe_ShouldBeInitialized0)},
1203 
1204     {CC &quot;loadFence&quot;,          CC &quot;()V&quot;,                  FN_PTR(Unsafe_LoadFence)},
1205     {CC &quot;storeFence&quot;,         CC &quot;()V&quot;,                  FN_PTR(Unsafe_StoreFence)},
1206     {CC &quot;fullFence&quot;,          CC &quot;()V&quot;,                  FN_PTR(Unsafe_FullFence)},



1207 };
1208 
1209 #undef CC
1210 #undef FN_PTR
1211 
1212 #undef ADR
1213 #undef LANG
1214 #undef OBJ
1215 #undef CLS
1216 #undef FLD
1217 #undef THR
1218 #undef DC_Args
1219 #undef DAC_Args
1220 
1221 #undef DECLARE_GETPUTOOP
1222 
1223 
1224 // This function is exported, used by NativeLookup.
1225 // The Unsafe_xxx functions above are called only from the interpreter.
1226 // The optimizer looks at names and signatures to recognize
</pre>
</td>
</tr>
</table>
<center><a href="jvmtiTagMap.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="../runtime/arguments.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
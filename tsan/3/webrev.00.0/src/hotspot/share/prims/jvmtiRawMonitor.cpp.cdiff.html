<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/hotspot/share/prims/jvmtiRawMonitor.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="jvmtiEnv.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="jvmtiTagMap.cpp.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/prims/jvmtiRawMonitor.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 1,7 ***</span>
  /*
<span class="line-modified">!  * Copyright (c) 2003, 2018, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.
<span class="line-new-header">--- 1,7 ---</span>
  /*
<span class="line-modified">!  * Copyright (c) 2003, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 31,41 ***</span>
  #include &quot;runtime/thread.inline.hpp&quot;
  #if INCLUDE_TSAN
  #include &quot;tsan/tsan.hpp&quot;
  #endif  // INCLUDE_TSAN
  
<span class="line-modified">! GrowableArray&lt;JvmtiRawMonitor*&gt; *JvmtiPendingMonitors::_monitors = new (ResourceObj::C_HEAP, mtInternal) GrowableArray&lt;JvmtiRawMonitor*&gt;(1,true);</span>
  
  void JvmtiPendingMonitors::transition_raw_monitors() {
    assert((Threads::number_of_threads()==1),
<span class="line-modified">!          &quot;Java thread has not created yet or more than one java thread \</span>
<span class="line-modified">! is running. Raw monitor transition will not work&quot;);</span>
<span class="line-modified">!   JavaThread *current_java_thread = JavaThread::current();</span>
    assert(current_java_thread-&gt;thread_state() == _thread_in_vm, &quot;Must be in vm&quot;);
<span class="line-modified">!   {</span>
<span class="line-modified">!     ThreadBlockInVM __tbivm(current_java_thread);</span>
<span class="line-modified">!     for(int i=0; i&lt; count(); i++) {</span>
<span class="line-modified">!       JvmtiRawMonitor *rmonitor = monitors()-&gt;at(i);</span>
<span class="line-removed">-       int r = rmonitor-&gt;raw_enter(current_java_thread);</span>
<span class="line-removed">-       assert(r == ObjectMonitor::OM_OK, &quot;raw_enter should have worked&quot;);</span>
<span class="line-removed">-       TSAN_RUNTIME_ONLY(TSAN_RAW_LOCK_ACQUIRED(rmonitor));</span>
<span class="line-removed">-     }</span>
    }
    // pending monitors are converted to real monitor so delete them all.
    dispose();
  }
  
  //
  // class JvmtiRawMonitor
  //
  
<span class="line-modified">! JvmtiRawMonitor::JvmtiRawMonitor(const char *name) {</span>
  #ifdef ASSERT
    _name = strcpy(NEW_C_HEAP_ARRAY(char, strlen(name) + 1, mtInternal), name);
<span class="line-removed">- #else</span>
<span class="line-removed">-   _name = NULL;</span>
<span class="line-removed">- #endif</span>
  #endif
  }
  
  JvmtiRawMonitor::~JvmtiRawMonitor() {
  #ifdef ASSERT
<span class="line-new-header">--- 31,46 ---</span>
  #include &quot;runtime/thread.inline.hpp&quot;
  #if INCLUDE_TSAN
  #include &quot;tsan/tsan.hpp&quot;
  #endif  // INCLUDE_TSAN
  
<span class="line-modified">! JvmtiRawMonitor::QNode::QNode(Thread* thread) : _next(NULL), _prev(NULL),</span>
<span class="line-added">+                                                 _event(thread-&gt;_ParkEvent),</span>
<span class="line-added">+                                                 _notified(0), _t_state(TS_RUN) {</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ GrowableArray&lt;JvmtiRawMonitor*&gt;* JvmtiPendingMonitors::_monitors =</span>
<span class="line-added">+   new (ResourceObj::C_HEAP, mtInternal) GrowableArray&lt;JvmtiRawMonitor*&gt;(1, true);</span>
  
  void JvmtiPendingMonitors::transition_raw_monitors() {
    assert((Threads::number_of_threads()==1),
<span class="line-modified">!          &quot;Java thread has not been created yet or more than one java thread &quot;</span>
<span class="line-modified">!          &quot;is running. Raw monitor transition will not work&quot;);</span>
<span class="line-modified">!   JavaThread* current_java_thread = JavaThread::current();</span>
    assert(current_java_thread-&gt;thread_state() == _thread_in_vm, &quot;Must be in vm&quot;);
<span class="line-modified">!   for (int i = 0; i &lt; count(); i++) {</span>
<span class="line-modified">!     JvmtiRawMonitor* rmonitor = monitors()-&gt;at(i);</span>
<span class="line-modified">!     rmonitor-&gt;raw_enter(current_java_thread);</span>
<span class="line-modified">!     TSAN_RUNTIME_ONLY(TSAN_RAW_LOCK_ACQUIRED(rmonitor));</span>
    }
    // pending monitors are converted to real monitor so delete them all.
    dispose();
  }
  
  //
  // class JvmtiRawMonitor
  //
  
<span class="line-modified">! JvmtiRawMonitor::JvmtiRawMonitor(const char* name) : _owner(NULL),</span>
<span class="line-added">+                                                      _recursions(0),</span>
<span class="line-added">+                                                      _entry_list(NULL),</span>
<span class="line-added">+                                                      _wait_set(NULL),</span>
<span class="line-added">+                                                      _waiters(0),</span>
<span class="line-added">+                                                      _magic(JVMTI_RM_MAGIC),</span>
<span class="line-added">+                                                      _name(NULL) {</span>
  #ifdef ASSERT
    _name = strcpy(NEW_C_HEAP_ARRAY(char, strlen(name) + 1, mtInternal), name);
  #endif
  }
  
  JvmtiRawMonitor::~JvmtiRawMonitor() {
  #ifdef ASSERT
</pre>
<hr />
<pre>
<span class="line-old-header">*** 102,322 ***</span>
  
    return value == JVMTI_RM_MAGIC;
  }
  
  // -------------------------------------------------------------------------
<span class="line-modified">! // The raw monitor subsystem is entirely distinct from normal</span>
<span class="line-modified">! // java-synchronization or jni-synchronization.  raw monitors are not</span>
  // associated with objects.  They can be implemented in any manner
  // that makes sense.  The original implementors decided to piggy-back
<span class="line-modified">! // the raw-monitor implementation on the existing Java objectMonitor mechanism.</span>
<span class="line-modified">! // This flaw needs to fixed.  We should reimplement raw monitors as sui-generis.</span>
<span class="line-removed">- // Specifically, we should not implement raw monitors via java monitors.</span>
<span class="line-removed">- // Time permitting, we should disentangle and deconvolve the two implementations</span>
<span class="line-removed">- // and move the resulting raw monitor implementation over to the JVMTI directories.</span>
<span class="line-removed">- // Ideally, the raw monitor implementation would be built on top of</span>
<span class="line-removed">- // park-unpark and nothing else.</span>
<span class="line-removed">- //</span>
<span class="line-removed">- // raw monitors are used mainly by JVMTI</span>
<span class="line-removed">- // The raw monitor implementation borrows the ObjectMonitor structure,</span>
<span class="line-removed">- // but the operators are degenerate and extremely simple.</span>
<span class="line-removed">- //</span>
<span class="line-removed">- // Mixed use of a single objectMonitor instance -- as both a raw monitor</span>
<span class="line-removed">- // and a normal java monitor -- is not permissible.</span>
  //
  // Note that we use the single RawMonitor_lock to protect queue operations for
  // _all_ raw monitors.  This is a scalability impediment, but since raw monitor usage
<span class="line-modified">! // is deprecated and rare, this is not of concern.  The RawMonitor_lock can not</span>
  // be held indefinitely.  The critical sections must be short and bounded.
  //
  // -------------------------------------------------------------------------
  
<span class="line-modified">! int JvmtiRawMonitor::SimpleEnter (Thread * Self) {</span>
    for (;;) {
<span class="line-modified">!     if (Atomic::replace_if_null(Self, &amp;_owner)) {</span>
<span class="line-modified">!        return OS_OK ;</span>
      }
  
<span class="line-modified">!     ObjectWaiter Node (Self) ;</span>
<span class="line-modified">!     Self-&gt;_ParkEvent-&gt;reset() ;     // strictly optional</span>
<span class="line-modified">!     Node.TState = ObjectWaiter::TS_ENTER ;</span>
<span class="line-modified">! </span>
<span class="line-modified">!     RawMonitor_lock-&gt;lock_without_safepoint_check() ;</span>
<span class="line-modified">!     Node._next  = _EntryList ;</span>
<span class="line-modified">!     _EntryList  = &amp;Node ;</span>
<span class="line-modified">!     OrderAccess::fence() ;</span>
<span class="line-modified">!     if (_owner == NULL &amp;&amp; Atomic::replace_if_null(Self, &amp;_owner)) {</span>
<span class="line-modified">!         _EntryList = Node._next ;</span>
<span class="line-modified">!         RawMonitor_lock-&gt;unlock() ;</span>
<span class="line-modified">!         return OS_OK ;</span>
      }
<span class="line-modified">!     RawMonitor_lock-&gt;unlock() ;</span>
<span class="line-modified">!     while (Node.TState == ObjectWaiter::TS_ENTER) {</span>
<span class="line-modified">!        Self-&gt;_ParkEvent-&gt;park() ;</span>
      }
    }
  }
  
<span class="line-modified">! int JvmtiRawMonitor::SimpleExit (Thread * Self) {</span>
<span class="line-modified">!   guarantee (_owner == Self, &quot;invariant&quot;) ;</span>
<span class="line-modified">!   OrderAccess::release_store(&amp;_owner, (void*)NULL) ;</span>
<span class="line-modified">!   OrderAccess::fence() ;</span>
<span class="line-modified">!   if (_EntryList == NULL) return OS_OK ;</span>
<span class="line-modified">!   ObjectWaiter * w ;</span>
  
<span class="line-modified">!   RawMonitor_lock-&gt;lock_without_safepoint_check() ;</span>
<span class="line-modified">!   w = _EntryList ;</span>
    if (w != NULL) {
<span class="line-modified">!       _EntryList = w-&gt;_next ;</span>
    }
<span class="line-modified">!   RawMonitor_lock-&gt;unlock() ;</span>
    if (w != NULL) {
<span class="line-modified">!       guarantee (w -&gt;TState == ObjectWaiter::TS_ENTER, &quot;invariant&quot;) ;</span>
<span class="line-modified">!       ParkEvent * ev = w-&gt;_event ;</span>
<span class="line-modified">!       w-&gt;TState = ObjectWaiter::TS_RUN ;</span>
<span class="line-modified">!       OrderAccess::fence() ;</span>
<span class="line-modified">!       ev-&gt;unpark() ;</span>
    }
<span class="line-modified">!   return OS_OK ;</span>
  }
  
<span class="line-modified">! int JvmtiRawMonitor::SimpleWait (Thread * Self, jlong millis) {</span>
<span class="line-modified">!   guarantee (_owner == Self  , &quot;invariant&quot;) ;</span>
<span class="line-modified">!   guarantee (_recursions == 0, &quot;invariant&quot;) ;</span>
<span class="line-modified">! </span>
<span class="line-modified">!   ObjectWaiter Node (Self) ;</span>
<span class="line-modified">!   Node._notified = 0 ;</span>
<span class="line-modified">!   Node.TState    = ObjectWaiter::TS_WAIT ;</span>
<span class="line-modified">! </span>
<span class="line-removed">-   RawMonitor_lock-&gt;lock_without_safepoint_check() ;</span>
<span class="line-removed">-   Node._next     = _WaitSet ;</span>
<span class="line-removed">-   _WaitSet       = &amp;Node ;</span>
<span class="line-removed">-   RawMonitor_lock-&gt;unlock() ;</span>
<span class="line-removed">- </span>
<span class="line-removed">-   SimpleExit (Self) ;</span>
<span class="line-removed">-   guarantee (_owner != Self, &quot;invariant&quot;) ;</span>
<span class="line-removed">- </span>
<span class="line-removed">-   int ret = OS_OK ;</span>
<span class="line-removed">-   if (millis &lt;= 0) {</span>
<span class="line-removed">-     Self-&gt;_ParkEvent-&gt;park();</span>
<span class="line-removed">-   } else {</span>
<span class="line-removed">-     ret = Self-&gt;_ParkEvent-&gt;park(millis);</span>
<span class="line-removed">-   }</span>
  
    // If thread still resides on the waitset then unlink it.
    // Double-checked locking -- the usage is safe in this context
<span class="line-modified">!   // as we TState is volatile and the lock-unlock operators are</span>
    // serializing (barrier-equivalent).
  
<span class="line-modified">!   if (Node.TState == ObjectWaiter::TS_WAIT) {</span>
<span class="line-modified">!     RawMonitor_lock-&gt;lock_without_safepoint_check() ;</span>
<span class="line-modified">!     if (Node.TState == ObjectWaiter::TS_WAIT) {</span>
        // Simple O(n) unlink, but performance isn&#39;t critical here.
<span class="line-modified">!       ObjectWaiter * p ;</span>
<span class="line-modified">!       ObjectWaiter * q = NULL ;</span>
<span class="line-modified">!       for (p = _WaitSet ; p != &amp;Node; p = p-&gt;_next) {</span>
<span class="line-modified">!          q = p ;</span>
        }
<span class="line-modified">!       guarantee (p == &amp;Node, &quot;invariant&quot;) ;</span>
        if (q == NULL) {
<span class="line-modified">!         guarantee (p == _WaitSet, &quot;invariant&quot;) ;</span>
<span class="line-modified">!         _WaitSet = p-&gt;_next ;</span>
        } else {
<span class="line-modified">!         guarantee (p == q-&gt;_next, &quot;invariant&quot;) ;</span>
<span class="line-modified">!         q-&gt;_next = p-&gt;_next ;</span>
        }
<span class="line-modified">!       Node.TState = ObjectWaiter::TS_RUN ;</span>
      }
<span class="line-modified">!     RawMonitor_lock-&gt;unlock() ;</span>
    }
  
<span class="line-modified">!   guarantee (Node.TState == ObjectWaiter::TS_RUN, &quot;invariant&quot;) ;</span>
<span class="line-modified">!   SimpleEnter (Self) ;</span>
  
<span class="line-modified">!   guarantee (_owner == Self, &quot;invariant&quot;) ;</span>
<span class="line-modified">!   guarantee (_recursions == 0, &quot;invariant&quot;) ;</span>
<span class="line-modified">!   return ret ;</span>
  }
  
<span class="line-modified">! int JvmtiRawMonitor::SimpleNotify (Thread * Self, bool All) {</span>
<span class="line-modified">!   guarantee (_owner == Self, &quot;invariant&quot;) ;</span>
<span class="line-modified">!   if (_WaitSet == NULL) return OS_OK ;</span>
  
    // We have two options:
<span class="line-modified">!   // A. Transfer the threads from the WaitSet to the EntryList</span>
<span class="line-modified">!   // B. Remove the thread from the WaitSet and unpark() it.</span>
    //
    // We use (B), which is crude and results in lots of futile
    // context switching.  In particular (B) induces lots of contention.
  
<span class="line-modified">!   ParkEvent * ev = NULL ;       // consider using a small auto array ...</span>
<span class="line-modified">!   RawMonitor_lock-&gt;lock_without_safepoint_check() ;</span>
    for (;;) {
<span class="line-modified">!       ObjectWaiter * w = _WaitSet ;</span>
<span class="line-modified">!       if (w == NULL) break ;</span>
<span class="line-modified">!       _WaitSet = w-&gt;_next ;</span>
<span class="line-modified">!       if (ev != NULL) { ev-&gt;unpark(); ev = NULL; }</span>
<span class="line-modified">!       ev = w-&gt;_event ;</span>
<span class="line-modified">!       OrderAccess::loadstore() ;</span>
<span class="line-modified">!       w-&gt;TState = ObjectWaiter::TS_RUN ;</span>
<span class="line-modified">!       OrderAccess::storeload();</span>
<span class="line-modified">!       if (!All) break ;</span>
    }
<span class="line-modified">!   RawMonitor_lock-&gt;unlock() ;</span>
<span class="line-modified">!   if (ev != NULL) ev-&gt;unpark();</span>
<span class="line-modified">!   return OS_OK ;</span>
  }
  
  // Any JavaThread will enter here with state _thread_blocked
<span class="line-modified">! int JvmtiRawMonitor::raw_enter(TRAPS) {</span>
<span class="line-modified">!   void * Contended ;</span>
<span class="line-modified">! </span>
    // don&#39;t enter raw monitor if thread is being externally suspended, it will
    // surprise the suspender if a &quot;suspended&quot; thread can still enter monitor
<span class="line-modified">!   JavaThread * jt = (JavaThread *)THREAD;</span>
<span class="line-modified">!   if (THREAD-&gt;is_Java_thread()) {</span>
      jt-&gt;SR_lock()-&gt;lock_without_safepoint_check();
      while (jt-&gt;is_external_suspend()) {
        jt-&gt;SR_lock()-&gt;unlock();
        jt-&gt;java_suspend_self();
        jt-&gt;SR_lock()-&gt;lock_without_safepoint_check();
      }
      // guarded by SR_lock to avoid racing with new external suspend requests.
<span class="line-modified">!     Contended = Atomic::cmpxchg(THREAD, &amp;_owner, (void*)NULL);</span>
      jt-&gt;SR_lock()-&gt;unlock();
    } else {
<span class="line-modified">!     Contended = Atomic::cmpxchg(THREAD, &amp;_owner, (void*)NULL);</span>
    }
  
<span class="line-modified">!   if (Contended == THREAD) {</span>
<span class="line-modified">!      _recursions ++ ;</span>
<span class="line-modified">!      return OM_OK ;</span>
    }
  
<span class="line-modified">!   if (Contended == NULL) {</span>
<span class="line-modified">!      guarantee (_owner == THREAD, &quot;invariant&quot;) ;</span>
<span class="line-modified">!      guarantee (_recursions == 0, &quot;invariant&quot;) ;</span>
<span class="line-modified">!      return OM_OK ;</span>
    }
  
<span class="line-modified">!   THREAD-&gt;set_current_pending_monitor(this);</span>
<span class="line-modified">! </span>
<span class="line-modified">!   if (!THREAD-&gt;is_Java_thread()) {</span>
<span class="line-modified">!      // No other non-Java threads besides VM thread would acquire</span>
<span class="line-modified">!      // a raw monitor.</span>
<span class="line-modified">!      assert(THREAD-&gt;is_VM_thread(), &quot;must be VM thread&quot;);</span>
<span class="line-modified">!      SimpleEnter (THREAD) ;</span>
<span class="line-modified">!    } else {</span>
<span class="line-modified">!      guarantee (jt-&gt;thread_state() == _thread_blocked, &quot;invariant&quot;) ;</span>
<span class="line-modified">!      for (;;) {</span>
<span class="line-modified">!        jt-&gt;set_suspend_equivalent();</span>
<span class="line-modified">!        // cleared by handle_special_suspend_equivalent_condition() or</span>
<span class="line-modified">!        // java_suspend_self()</span>
<span class="line-modified">!        SimpleEnter (THREAD) ;</span>
<span class="line-modified">! </span>
<span class="line-modified">!        // were we externally suspended while we were waiting?</span>
<span class="line-modified">!        if (!jt-&gt;handle_special_suspend_equivalent_condition()) break ;</span>
<span class="line-modified">! </span>
<span class="line-modified">!        // This thread was externally suspended</span>
<span class="line-modified">!        //</span>
<span class="line-modified">!        // This logic isn&#39;t needed for JVMTI raw monitors,</span>
<span class="line-modified">!        // but doesn&#39;t hurt just in case the suspend rules change. This</span>
<span class="line-modified">!            // logic is needed for the JvmtiRawMonitor.wait() reentry phase.</span>
<span class="line-modified">!            // We have reentered the contended monitor, but while we were</span>
<span class="line-modified">!            // waiting another thread suspended us. We don&#39;t want to reenter</span>
<span class="line-modified">!            // the monitor while suspended because that would surprise the</span>
<span class="line-modified">!            // thread that suspended us.</span>
<span class="line-modified">!            //</span>
<span class="line-removed">-            // Drop the lock -</span>
<span class="line-removed">-        SimpleExit (THREAD) ;</span>
<span class="line-removed">- </span>
<span class="line-removed">-            jt-&gt;java_suspend_self();</span>
<span class="line-removed">-          }</span>
<span class="line-removed">- </span>
<span class="line-removed">-      assert(_owner == THREAD, &quot;Fatal error with monitor owner!&quot;);</span>
<span class="line-removed">-      assert(_recursions == 0, &quot;Fatal error with monitor recursions!&quot;);</span>
    }
  
<span class="line-modified">!   THREAD-&gt;set_current_pending_monitor(NULL);</span>
<span class="line-modified">!   guarantee (_recursions == 0, &quot;invariant&quot;) ;</span>
<span class="line-modified">!   return OM_OK;</span>
  }
  
<span class="line-modified">! // Used mainly for JVMTI raw monitor implementation</span>
<span class="line-modified">! // Also used for JvmtiRawMonitor::wait().</span>
<span class="line-modified">! int JvmtiRawMonitor::raw_exit(TRAPS) {</span>
<span class="line-removed">-   if (THREAD != _owner) {</span>
<span class="line-removed">-     return OM_ILLEGAL_MONITOR_STATE;</span>
    }
    if (_recursions &gt; 0) {
<span class="line-modified">!     --_recursions ;</span>
<span class="line-modified">!     return OM_OK ;</span>
    }
  
<span class="line-modified">!   void * List = _EntryList ;</span>
<span class="line-removed">-   SimpleExit (THREAD) ;</span>
<span class="line-removed">- </span>
<span class="line-removed">-   return OM_OK;</span>
  }
  
<span class="line-modified">! // Used for JVMTI raw monitor implementation.</span>
<span class="line-modified">! // All JavaThreads will enter here with state _thread_blocked</span>
<span class="line-modified">! </span>
<span class="line-removed">- int JvmtiRawMonitor::raw_wait(jlong millis, bool interruptible, TRAPS) {</span>
<span class="line-removed">-   if (THREAD != _owner) {</span>
<span class="line-removed">-     return OM_ILLEGAL_MONITOR_STATE;</span>
    }
  
<span class="line-modified">!   // To avoid spurious wakeups we reset the parkevent -- This is strictly optional.</span>
<span class="line-removed">-   // The caller must be able to tolerate spurious returns from raw_wait().</span>
<span class="line-removed">-   THREAD-&gt;_ParkEvent-&gt;reset() ;</span>
<span class="line-removed">-   OrderAccess::fence() ;</span>
<span class="line-removed">- </span>
<span class="line-removed">-   // check interrupt event</span>
<span class="line-removed">-   if (interruptible &amp;&amp; Thread::is_interrupted(THREAD, true)) {</span>
<span class="line-removed">-     return OM_INTERRUPTED;</span>
<span class="line-removed">-   }</span>
  
<span class="line-modified">!   intptr_t save = _recursions ;</span>
<span class="line-modified">!   _recursions = 0 ;</span>
<span class="line-modified">!   _waiters ++ ;</span>
<span class="line-modified">!   if (THREAD-&gt;is_Java_thread()) {</span>
<span class="line-modified">!     guarantee (((JavaThread *) THREAD)-&gt;thread_state() == _thread_blocked, &quot;invariant&quot;) ;</span>
<span class="line-modified">!     ((JavaThread *)THREAD)-&gt;set_suspend_equivalent();</span>
<span class="line-modified">!   }</span>
<span class="line-modified">!   int rv = SimpleWait (THREAD, millis) ;</span>
<span class="line-modified">!   _recursions = save ;</span>
<span class="line-modified">!   _waiters -- ;</span>
<span class="line-modified">! </span>
<span class="line-modified">!   guarantee (THREAD == _owner, &quot;invariant&quot;) ;</span>
<span class="line-modified">!   if (THREAD-&gt;is_Java_thread()) {</span>
<span class="line-modified">!      JavaThread * jSelf = (JavaThread *) THREAD ;</span>
<span class="line-modified">!      for (;;) {</span>
<span class="line-modified">!         if (!jSelf-&gt;handle_special_suspend_equivalent_condition()) break ;</span>
<span class="line-modified">!         SimpleExit (THREAD) ;</span>
<span class="line-modified">!         jSelf-&gt;java_suspend_self();</span>
<span class="line-modified">!         SimpleEnter (THREAD) ;</span>
<span class="line-modified">!         jSelf-&gt;set_suspend_equivalent() ;</span>
<span class="line-modified">!      }</span>
    }
<span class="line-modified">!   guarantee (THREAD == _owner, &quot;invariant&quot;) ;</span>
<span class="line-removed">- </span>
<span class="line-removed">-   if (interruptible &amp;&amp; Thread::is_interrupted(THREAD, true)) {</span>
<span class="line-removed">-     return OM_INTERRUPTED;</span>
<span class="line-removed">-   }</span>
    return ret;
  }
  
<span class="line-modified">! int JvmtiRawMonitor::raw_notify(TRAPS) {</span>
<span class="line-modified">!   if (THREAD != _owner) {</span>
<span class="line-modified">!     return OM_ILLEGAL_MONITOR_STATE;</span>
    }
<span class="line-modified">!   SimpleNotify (THREAD, false) ;</span>
<span class="line-modified">!   return OM_OK;</span>
  }
  
<span class="line-modified">! int JvmtiRawMonitor::raw_notifyAll(TRAPS) {</span>
<span class="line-modified">!   if (THREAD != _owner) {</span>
<span class="line-modified">!     return OM_ILLEGAL_MONITOR_STATE;</span>
    }
<span class="line-modified">!   SimpleNotify (THREAD, true) ;</span>
<span class="line-modified">!   return OM_OK;</span>
  }
<span class="line-new-header">--- 107,358 ---</span>
  
    return value == JVMTI_RM_MAGIC;
  }
  
  // -------------------------------------------------------------------------
<span class="line-modified">! // The JVMTI raw monitor subsystem is entirely distinct from normal</span>
<span class="line-modified">! // java-synchronization or jni-synchronization.  JVMTI raw monitors are not</span>
  // associated with objects.  They can be implemented in any manner
  // that makes sense.  The original implementors decided to piggy-back
<span class="line-modified">! // the raw-monitor implementation on the existing Java ObjectMonitor mechanism.</span>
<span class="line-modified">! // Now we just use a simplified form of that ObjectMonitor code.</span>
  //
  // Note that we use the single RawMonitor_lock to protect queue operations for
  // _all_ raw monitors.  This is a scalability impediment, but since raw monitor usage
<span class="line-modified">! // is fairly rare, this is not of concern.  The RawMonitor_lock can not</span>
  // be held indefinitely.  The critical sections must be short and bounded.
  //
  // -------------------------------------------------------------------------
  
<span class="line-modified">! void JvmtiRawMonitor::simple_enter(Thread* self) {</span>
    for (;;) {
<span class="line-modified">!     if (Atomic::replace_if_null(&amp;_owner, self)) {</span>
<span class="line-modified">!       return;</span>
      }
  
<span class="line-modified">!     QNode node(self);</span>
<span class="line-modified">!     self-&gt;_ParkEvent-&gt;reset();     // strictly optional</span>
<span class="line-modified">!     node._t_state = QNode::TS_ENTER;</span>
<span class="line-modified">! </span>
<span class="line-modified">!     RawMonitor_lock-&gt;lock_without_safepoint_check();</span>
<span class="line-modified">!     node._next = _entry_list;</span>
<span class="line-modified">!     _entry_list = &amp;node;</span>
<span class="line-modified">!     OrderAccess::fence();</span>
<span class="line-modified">!     if (_owner == NULL &amp;&amp; Atomic::replace_if_null(&amp;_owner, self)) {</span>
<span class="line-modified">!       _entry_list = node._next;</span>
<span class="line-modified">!       RawMonitor_lock-&gt;unlock();</span>
<span class="line-modified">!       return;</span>
      }
<span class="line-modified">!     RawMonitor_lock-&gt;unlock();</span>
<span class="line-modified">!     while (node._t_state == QNode::TS_ENTER) {</span>
<span class="line-modified">!       self-&gt;_ParkEvent-&gt;park();</span>
      }
    }
  }
  
<span class="line-modified">! void JvmtiRawMonitor::simple_exit(Thread* self) {</span>
<span class="line-modified">!   guarantee(_owner == self, &quot;invariant&quot;);</span>
<span class="line-modified">!   Atomic::release_store(&amp;_owner, (Thread*)NULL);</span>
<span class="line-modified">!   OrderAccess::fence();</span>
<span class="line-modified">!   if (_entry_list == NULL) {</span>
<span class="line-modified">!     return;</span>
<span class="line-added">+   }</span>
  
<span class="line-modified">!   RawMonitor_lock-&gt;lock_without_safepoint_check();</span>
<span class="line-modified">!   QNode* w = _entry_list;</span>
    if (w != NULL) {
<span class="line-modified">!     _entry_list = w-&gt;_next;</span>
    }
<span class="line-modified">!   RawMonitor_lock-&gt;unlock();</span>
    if (w != NULL) {
<span class="line-modified">!     guarantee(w -&gt;_t_state == QNode::TS_ENTER, &quot;invariant&quot;);</span>
<span class="line-modified">!     // Once we set _t_state to TS_RUN the waiting thread can complete</span>
<span class="line-modified">!     // simple_enter and &#39;w&#39; is pointing into random stack space. So we have</span>
<span class="line-modified">!     // to ensure we extract the ParkEvent (which is in type-stable memory)</span>
<span class="line-modified">!     // before we set the state, and then don&#39;t access &#39;w&#39;.</span>
<span class="line-added">+     ParkEvent* ev = w-&gt;_event;</span>
<span class="line-added">+     OrderAccess::loadstore();</span>
<span class="line-added">+     w-&gt;_t_state = QNode::TS_RUN;</span>
<span class="line-added">+     OrderAccess::fence();</span>
<span class="line-added">+     ev-&gt;unpark();</span>
    }
<span class="line-modified">!   return;</span>
  }
  
<span class="line-modified">! inline void JvmtiRawMonitor::enqueue_waiter(QNode&amp; node) {</span>
<span class="line-modified">!   node._notified = 0;</span>
<span class="line-modified">!   node._t_state = QNode::TS_WAIT;</span>
<span class="line-modified">!   RawMonitor_lock-&gt;lock_without_safepoint_check();</span>
<span class="line-modified">!   node._next = _wait_set;</span>
<span class="line-modified">!   _wait_set = &amp;node;</span>
<span class="line-modified">!   RawMonitor_lock-&gt;unlock();</span>
<span class="line-modified">! }</span>
  
<span class="line-added">+ inline void JvmtiRawMonitor::dequeue_waiter(QNode&amp; node) {</span>
    // If thread still resides on the waitset then unlink it.
    // Double-checked locking -- the usage is safe in this context
<span class="line-modified">!   // as _t_state is volatile and the lock-unlock operators are</span>
    // serializing (barrier-equivalent).
  
<span class="line-modified">!   if (node._t_state == QNode::TS_WAIT) {</span>
<span class="line-modified">!     RawMonitor_lock-&gt;lock_without_safepoint_check();</span>
<span class="line-modified">!     if (node._t_state == QNode::TS_WAIT) {</span>
        // Simple O(n) unlink, but performance isn&#39;t critical here.
<span class="line-modified">!       QNode* p;</span>
<span class="line-modified">!       QNode* q = NULL;</span>
<span class="line-modified">!       for (p = _wait_set; p != &amp;node; p = p-&gt;_next) {</span>
<span class="line-modified">!         q = p;</span>
        }
<span class="line-modified">!       guarantee(p == &amp;node, &quot;invariant&quot;);</span>
        if (q == NULL) {
<span class="line-modified">!         guarantee (p == _wait_set, &quot;invariant&quot;);</span>
<span class="line-modified">!         _wait_set = p-&gt;_next;</span>
        } else {
<span class="line-modified">!         guarantee(p == q-&gt;_next, &quot;invariant&quot;);</span>
<span class="line-modified">!         q-&gt;_next = p-&gt;_next;</span>
        }
<span class="line-modified">!       node._t_state = QNode::TS_RUN;</span>
      }
<span class="line-modified">!     RawMonitor_lock-&gt;unlock();</span>
    }
  
<span class="line-modified">!   guarantee(node._t_state == QNode::TS_RUN, &quot;invariant&quot;);</span>
<span class="line-modified">! }</span>
<span class="line-added">+ </span>
<span class="line-added">+ // simple_wait is not quite so simple as we have to deal with the interaction</span>
<span class="line-added">+ // with the Thread interrupt state, which resides in the java.lang.Thread object.</span>
<span class="line-added">+ // That state must only be accessed while _thread_in_vm and requires proper thread-state</span>
<span class="line-added">+ // transitions. However, we cannot perform such transitions whilst we hold the RawMonitor,</span>
<span class="line-added">+ // else we can deadlock with the VMThread (which may also use RawMonitors as part of</span>
<span class="line-added">+ // executing various callbacks).</span>
<span class="line-added">+ // Returns M_OK usually, but M_INTERRUPTED if the thread is a JavaThread and was</span>
<span class="line-added">+ // interrupted.</span>
<span class="line-added">+ int JvmtiRawMonitor::simple_wait(Thread* self, jlong millis) {</span>
<span class="line-added">+   guarantee(_owner == self  , &quot;invariant&quot;);</span>
<span class="line-added">+   guarantee(_recursions == 0, &quot;invariant&quot;);</span>
<span class="line-added">+ </span>
<span class="line-added">+   QNode node(self);</span>
<span class="line-added">+   enqueue_waiter(node);</span>
<span class="line-added">+ </span>
<span class="line-added">+   simple_exit(self);</span>
<span class="line-added">+   guarantee(_owner != self, &quot;invariant&quot;);</span>
<span class="line-added">+ </span>
<span class="line-added">+   int ret = M_OK;</span>
<span class="line-added">+   if (self-&gt;is_Java_thread()) {</span>
<span class="line-added">+     JavaThread* jt = (JavaThread*) self;</span>
<span class="line-added">+     // Transition to VM so we can check interrupt state</span>
<span class="line-added">+     ThreadInVMfromNative tivm(jt);</span>
<span class="line-added">+     if (jt-&gt;is_interrupted(true)) {</span>
<span class="line-added">+         ret = M_INTERRUPTED;</span>
<span class="line-added">+     } else {</span>
<span class="line-added">+       ThreadBlockInVM tbivm(jt);</span>
<span class="line-added">+       jt-&gt;set_suspend_equivalent();</span>
<span class="line-added">+       if (millis &lt;= 0) {</span>
<span class="line-added">+         self-&gt;_ParkEvent-&gt;park();</span>
<span class="line-added">+       } else {</span>
<span class="line-added">+         self-&gt;_ParkEvent-&gt;park(millis);</span>
<span class="line-added">+       }</span>
<span class="line-added">+       // Return to VM before post-check of interrupt state</span>
<span class="line-added">+     }</span>
<span class="line-added">+     if (jt-&gt;is_interrupted(true)) {</span>
<span class="line-added">+       ret = M_INTERRUPTED;</span>
<span class="line-added">+     }</span>
<span class="line-added">+   } else {</span>
<span class="line-added">+     if (millis &lt;= 0) {</span>
<span class="line-added">+       self-&gt;_ParkEvent-&gt;park();</span>
<span class="line-added">+     } else {</span>
<span class="line-added">+       self-&gt;_ParkEvent-&gt;park(millis);</span>
<span class="line-added">+     }</span>
<span class="line-added">+   }</span>
  
<span class="line-modified">!   dequeue_waiter(node);</span>
<span class="line-modified">! </span>
<span class="line-modified">!   simple_enter(self);</span>
<span class="line-added">+   guarantee(_owner == self, &quot;invariant&quot;);</span>
<span class="line-added">+   guarantee(_recursions == 0, &quot;invariant&quot;);</span>
<span class="line-added">+ </span>
<span class="line-added">+   return ret;</span>
  }
  
<span class="line-modified">! void JvmtiRawMonitor::simple_notify(Thread* self, bool all) {</span>
<span class="line-modified">!   guarantee(_owner == self, &quot;invariant&quot;);</span>
<span class="line-modified">!   if (_wait_set == NULL) {</span>
<span class="line-added">+     return;</span>
<span class="line-added">+   }</span>
  
    // We have two options:
<span class="line-modified">!   // A. Transfer the threads from the _wait_set to the _entry_list</span>
<span class="line-modified">!   // B. Remove the thread from the _wait_set and unpark() it.</span>
    //
    // We use (B), which is crude and results in lots of futile
    // context switching.  In particular (B) induces lots of contention.
  
<span class="line-modified">!   ParkEvent* ev = NULL;       // consider using a small auto array ...</span>
<span class="line-modified">!   RawMonitor_lock-&gt;lock_without_safepoint_check();</span>
    for (;;) {
<span class="line-modified">!     QNode* w = _wait_set;</span>
<span class="line-modified">!     if (w == NULL) break;</span>
<span class="line-modified">!     _wait_set = w-&gt;_next;</span>
<span class="line-modified">!     if (ev != NULL) {</span>
<span class="line-modified">!       ev-&gt;unpark();</span>
<span class="line-modified">!       ev = NULL;</span>
<span class="line-modified">!     }</span>
<span class="line-modified">!     ev = w-&gt;_event;</span>
<span class="line-modified">!     OrderAccess::loadstore();</span>
<span class="line-added">+     w-&gt;_t_state = QNode::TS_RUN;</span>
<span class="line-added">+     OrderAccess::storeload();</span>
<span class="line-added">+     if (!all) {</span>
<span class="line-added">+       break;</span>
<span class="line-added">+     }</span>
    }
<span class="line-modified">!   RawMonitor_lock-&gt;unlock();</span>
<span class="line-modified">!   if (ev != NULL) {</span>
<span class="line-modified">!     ev-&gt;unpark();</span>
<span class="line-added">+   }</span>
<span class="line-added">+   return;</span>
  }
  
  // Any JavaThread will enter here with state _thread_blocked
<span class="line-modified">! void JvmtiRawMonitor::raw_enter(Thread* self) {</span>
<span class="line-modified">!   void* contended;</span>
<span class="line-modified">!   JavaThread* jt = NULL;</span>
    // don&#39;t enter raw monitor if thread is being externally suspended, it will
    // surprise the suspender if a &quot;suspended&quot; thread can still enter monitor
<span class="line-modified">!   if (self-&gt;is_Java_thread()) {</span>
<span class="line-modified">!     jt = (JavaThread*)self;</span>
      jt-&gt;SR_lock()-&gt;lock_without_safepoint_check();
      while (jt-&gt;is_external_suspend()) {
        jt-&gt;SR_lock()-&gt;unlock();
        jt-&gt;java_suspend_self();
        jt-&gt;SR_lock()-&gt;lock_without_safepoint_check();
      }
      // guarded by SR_lock to avoid racing with new external suspend requests.
<span class="line-modified">!     contended = Atomic::cmpxchg(&amp;_owner, (Thread*)NULL, jt);</span>
      jt-&gt;SR_lock()-&gt;unlock();
    } else {
<span class="line-modified">!     contended = Atomic::cmpxchg(&amp;_owner, (Thread*)NULL, self);</span>
    }
  
<span class="line-modified">!   if (contended == self) {</span>
<span class="line-modified">!     _recursions++;</span>
<span class="line-modified">!     return;</span>
    }
  
<span class="line-modified">!   if (contended == NULL) {</span>
<span class="line-modified">!     guarantee(_owner == self, &quot;invariant&quot;);</span>
<span class="line-modified">!     guarantee(_recursions == 0, &quot;invariant&quot;);</span>
<span class="line-modified">!     return;</span>
    }
  
<span class="line-modified">!   self-&gt;set_current_pending_raw_monitor(this);</span>
<span class="line-modified">! </span>
<span class="line-modified">!   if (!self-&gt;is_Java_thread()) {</span>
<span class="line-modified">!     simple_enter(self);</span>
<span class="line-modified">!   } else {</span>
<span class="line-modified">!     guarantee(jt-&gt;thread_state() == _thread_blocked, &quot;invariant&quot;);</span>
<span class="line-modified">!     for (;;) {</span>
<span class="line-modified">!       jt-&gt;set_suspend_equivalent();</span>
<span class="line-modified">!       // cleared by handle_special_suspend_equivalent_condition() or</span>
<span class="line-modified">!       // java_suspend_self()</span>
<span class="line-modified">!       simple_enter(jt);</span>
<span class="line-modified">! </span>
<span class="line-modified">!       // were we externally suspended while we were waiting?</span>
<span class="line-modified">!       if (!jt-&gt;handle_special_suspend_equivalent_condition()) {</span>
<span class="line-modified">!         break;</span>
<span class="line-modified">!       }</span>
<span class="line-modified">! </span>
<span class="line-modified">!       // This thread was externally suspended</span>
<span class="line-modified">!       // We have reentered the contended monitor, but while we were</span>
<span class="line-modified">!       // waiting another thread suspended us. We don&#39;t want to reenter</span>
<span class="line-modified">!       // the monitor while suspended because that would surprise the</span>
<span class="line-modified">!       // thread that suspended us.</span>
<span class="line-modified">!       //</span>
<span class="line-modified">!       // Drop the lock</span>
<span class="line-modified">!       simple_exit(jt);</span>
<span class="line-modified">! </span>
<span class="line-modified">!       jt-&gt;java_suspend_self();</span>
<span class="line-modified">!     }</span>
    }
  
<span class="line-modified">!   self-&gt;set_current_pending_raw_monitor(NULL);</span>
<span class="line-modified">! </span>
<span class="line-modified">!   guarantee(_owner == self, &quot;invariant&quot;);</span>
<span class="line-added">+   guarantee(_recursions == 0, &quot;invariant&quot;);</span>
  }
  
<span class="line-modified">! int JvmtiRawMonitor::raw_exit(Thread* self) {</span>
<span class="line-modified">!   if (self != _owner) {</span>
<span class="line-modified">!     return M_ILLEGAL_MONITOR_STATE;</span>
    }
    if (_recursions &gt; 0) {
<span class="line-modified">!     _recursions--;</span>
<span class="line-modified">!   } else {</span>
<span class="line-added">+     simple_exit(self);</span>
    }
  
<span class="line-modified">!   return M_OK;</span>
  }
  
<span class="line-modified">! int JvmtiRawMonitor::raw_wait(jlong millis, Thread* self) {</span>
<span class="line-modified">!   if (self != _owner) {</span>
<span class="line-modified">!     return M_ILLEGAL_MONITOR_STATE;</span>
    }
  
<span class="line-modified">!   int ret = M_OK;</span>
  
<span class="line-modified">!   // To avoid spurious wakeups we reset the parkevent. This is strictly optional.</span>
<span class="line-modified">!   // The caller must be able to tolerate spurious returns from raw_wait().</span>
<span class="line-modified">!   self-&gt;_ParkEvent-&gt;reset();</span>
<span class="line-modified">!   OrderAccess::fence();</span>
<span class="line-modified">! </span>
<span class="line-modified">!   intptr_t save = _recursions;</span>
<span class="line-modified">!   _recursions = 0;</span>
<span class="line-modified">!   _waiters++;</span>
<span class="line-modified">!   ret = simple_wait(self, millis);</span>
<span class="line-modified">!   _recursions = save;</span>
<span class="line-modified">!   _waiters--;</span>
<span class="line-modified">! </span>
<span class="line-modified">!   guarantee(self == _owner, &quot;invariant&quot;);</span>
<span class="line-modified">! </span>
<span class="line-modified">!   if (self-&gt;is_Java_thread()) {</span>
<span class="line-modified">!     JavaThread* jt = (JavaThread*)self;</span>
<span class="line-modified">!     for (;;) {</span>
<span class="line-modified">!       jt-&gt;set_suspend_equivalent();</span>
<span class="line-modified">!       if (!jt-&gt;handle_special_suspend_equivalent_condition()) {</span>
<span class="line-modified">!         break;</span>
<span class="line-modified">!       } else {</span>
<span class="line-added">+         // We&#39;ve been suspended whilst waiting and so we have to</span>
<span class="line-added">+         // relinquish the raw monitor until we are resumed. Of course</span>
<span class="line-added">+         // after reacquiring we have to re-check for suspension again.</span>
<span class="line-added">+         // Suspension requires we are _thread_blocked, and we also have to</span>
<span class="line-added">+         // recheck for being interrupted.</span>
<span class="line-added">+         simple_exit(jt);</span>
<span class="line-added">+         {</span>
<span class="line-added">+           ThreadInVMfromNative tivm(jt);</span>
<span class="line-added">+           {</span>
<span class="line-added">+             ThreadBlockInVM tbivm(jt);</span>
<span class="line-added">+             jt-&gt;java_suspend_self();</span>
<span class="line-added">+           }</span>
<span class="line-added">+           if (jt-&gt;is_interrupted(true)) {</span>
<span class="line-added">+             ret = M_INTERRUPTED;</span>
<span class="line-added">+           }</span>
<span class="line-added">+         }</span>
<span class="line-added">+         simple_enter(jt);</span>
<span class="line-added">+       }</span>
<span class="line-added">+     }</span>
<span class="line-added">+     guarantee(jt == _owner, &quot;invariant&quot;);</span>
<span class="line-added">+   } else {</span>
<span class="line-added">+     assert(ret != M_INTERRUPTED, &quot;Only JavaThreads can be interrupted&quot;);</span>
    }
<span class="line-modified">! </span>
    return ret;
  }
  
<span class="line-modified">! int JvmtiRawMonitor::raw_notify(Thread* self) {</span>
<span class="line-modified">!   if (self != _owner) {</span>
<span class="line-modified">!     return M_ILLEGAL_MONITOR_STATE;</span>
    }
<span class="line-modified">!   simple_notify(self, false);</span>
<span class="line-modified">!   return M_OK;</span>
  }
  
<span class="line-modified">! int JvmtiRawMonitor::raw_notifyAll(Thread* self) {</span>
<span class="line-modified">!   if (self != _owner) {</span>
<span class="line-modified">!     return M_ILLEGAL_MONITOR_STATE;</span>
    }
<span class="line-modified">!   simple_notify(self, true);</span>
<span class="line-modified">!   return M_OK;</span>
  }
</pre>
<center><a href="jvmtiEnv.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="jvmtiTagMap.cpp.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
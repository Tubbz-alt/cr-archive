<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/hotspot/share/prims/jvmtiTagMap.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="jvmtiRawMonitor.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="jvmtiTagMap.hpp.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/prims/jvmtiTagMap.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 1,7 ***</span>
  /*
<span class="line-modified">!  * Copyright (c) 2003, 2018, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.
<span class="line-new-header">--- 1,7 ---</span>
  /*
<span class="line-modified">!  * Copyright (c) 2003, 2020, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 30,10 ***</span>
<span class="line-new-header">--- 30,11 ---</span>
  #include &quot;classfile/vmSymbols.hpp&quot;
  #include &quot;jvmtifiles/jvmtiEnv.hpp&quot;
  #include &quot;logging/log.hpp&quot;
  #include &quot;memory/allocation.inline.hpp&quot;
  #include &quot;memory/resourceArea.hpp&quot;
<span class="line-added">+ #include &quot;memory/universe.hpp&quot;</span>
  #include &quot;oops/access.inline.hpp&quot;
  #include &quot;oops/arrayOop.inline.hpp&quot;
  #include &quot;oops/constantPool.inline.hpp&quot;
  #include &quot;oops/instanceMirrorKlass.hpp&quot;
  #include &quot;oops/objArrayKlass.hpp&quot;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 97,19 ***</span>
    // Peek at the object without keeping it alive. The returned object must be
    // kept alive using a normal access if it leaks out of a thread transition from VM.
    inline oop object_peek()  {
      return NativeAccess&lt;ON_PHANTOM_OOP_REF | AS_NO_KEEPALIVE&gt;::oop_load(object_addr());
    }
    inline jlong tag() const  { return _tag; }
  
    inline void set_tag(jlong tag) {
      assert(tag != 0, &quot;can&#39;t be zero&quot;);
      _tag = tag;
    }
  
    inline bool equals(oop object) {
<span class="line-modified">!     return oopDesc::equals(object, object_peek());</span>
    }
  
    inline JvmtiTagHashmapEntry* next() const        { return _next; }
    inline void set_next(JvmtiTagHashmapEntry* next) { _next = next; }
  };
<span class="line-new-header">--- 98,24 ---</span>
    // Peek at the object without keeping it alive. The returned object must be
    // kept alive using a normal access if it leaks out of a thread transition from VM.
    inline oop object_peek()  {
      return NativeAccess&lt;ON_PHANTOM_OOP_REF | AS_NO_KEEPALIVE&gt;::oop_load(object_addr());
    }
<span class="line-added">+ </span>
<span class="line-added">+   inline oop object_raw() {</span>
<span class="line-added">+     return RawAccess&lt;&gt;::oop_load(object_addr());</span>
<span class="line-added">+   }</span>
<span class="line-added">+ </span>
    inline jlong tag() const  { return _tag; }
  
    inline void set_tag(jlong tag) {
      assert(tag != 0, &quot;can&#39;t be zero&quot;);
      _tag = tag;
    }
  
    inline bool equals(oop object) {
<span class="line-modified">!     return object == object_peek();</span>
    }
  
    inline JvmtiTagHashmapEntry* next() const        { return _next; }
    inline void set_next(JvmtiTagHashmapEntry* next) { _next = next; }
  };
</pre>
<hr />
<pre>
<span class="line-old-header">*** 182,21 ***</span>
      }
    }
  
    // hash a given key (oop) with the specified size
    static unsigned int hash(oop key, int size) {
<span class="line-modified">!     ZGC_ONLY(assert(ZAddressMetadataShift &gt;= sizeof(unsigned int) * BitsPerByte, &quot;cast removes the metadata bits&quot;);)</span>
<span class="line-modified">! </span>
<span class="line-modified">!     // shift right to get better distribution (as these bits will be zero</span>
<span class="line-removed">-     // with aligned addresses)</span>
<span class="line-removed">-     key = Access&lt;&gt;::resolve(key);</span>
<span class="line-removed">-     unsigned int addr = (unsigned int)(cast_from_oop&lt;intptr_t&gt;(key));</span>
<span class="line-removed">- #ifdef _LP64</span>
<span class="line-removed">-     return (addr &gt;&gt; 3) % size;</span>
<span class="line-removed">- #else</span>
<span class="line-removed">-     return (addr &gt;&gt; 2) % size;</span>
<span class="line-removed">- #endif</span>
    }
  
    // hash a given key (oop)
    unsigned int hash(oop key) {
      return hash(key, _size);
<span class="line-new-header">--- 188,13 ---</span>
      }
    }
  
    // hash a given key (oop) with the specified size
    static unsigned int hash(oop key, int size) {
<span class="line-modified">!     const oop obj = Access&lt;&gt;::resolve(key);</span>
<span class="line-modified">!     const unsigned int hash = Universe::heap()-&gt;hash_oop(obj);</span>
<span class="line-modified">!     return hash % size;</span>
    }
  
    // hash a given key (oop)
    unsigned int hash(oop key) {
      return hash(key, _size);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 383,15 ***</span>
  };
  
  // Tsan should know that the JVMTI TagMap is protected by a mutex.
  class TsanMutexScope : public StackObj {
   private:
<span class="line-modified">!   Monitor *_lock;  // Keep my own reference, for destructor.</span>
  
   public:
    // Don&#39;t actually lock it, just tell tsan we did.
<span class="line-modified">!   TsanMutexScope(Monitor* mutex) : _lock(mutex) {</span>
      TSAN_RUNTIME_ONLY(TSAN_RAW_LOCK_ACQUIRED(_lock));
    }
  
    ~TsanMutexScope() {
      TSAN_RUNTIME_ONLY(TSAN_RAW_LOCK_RELEASED(_lock));
<span class="line-new-header">--- 381,15 ---</span>
  };
  
  // Tsan should know that the JVMTI TagMap is protected by a mutex.
  class TsanMutexScope : public StackObj {
   private:
<span class="line-modified">!   Mutex *_lock;  // Keep my own reference, for destructor.</span>
  
   public:
    // Don&#39;t actually lock it, just tell tsan we did.
<span class="line-modified">!   TsanMutexScope(Mutex* mutex) : _lock(mutex) {</span>
      TSAN_RUNTIME_ONLY(TSAN_RAW_LOCK_ACQUIRED(_lock));
    }
  
    ~TsanMutexScope() {
      TSAN_RUNTIME_ONLY(TSAN_RAW_LOCK_RELEASED(_lock));
</pre>
<hr />
<pre>
<span class="line-old-header">*** 485,11 ***</span>
    //  solutions.
  
    _hashmap = new JvmtiTagHashmap();
  
    // finally add us to the environment
<span class="line-modified">!   ((JvmtiEnvBase *)env)-&gt;set_tag_map(this);</span>
  }
  
  
  // destroy a JvmtiTagMap
  JvmtiTagMap::~JvmtiTagMap() {
<span class="line-new-header">--- 483,11 ---</span>
    //  solutions.
  
    _hashmap = new JvmtiTagHashmap();
  
    // finally add us to the environment
<span class="line-modified">!   ((JvmtiEnvBase *)env)-&gt;release_set_tag_map(this);</span>
  }
  
  
  // destroy a JvmtiTagMap
  JvmtiTagMap::~JvmtiTagMap() {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 526,10 ***</span>
<span class="line-new-header">--- 524,15 ---</span>
  // create a hashmap entry
  // - if there&#39;s an entry on the (per-environment) free list then this
  // is returned. Otherwise an new entry is allocated.
  JvmtiTagHashmapEntry* JvmtiTagMap::create_entry(oop ref, jlong tag) {
    assert(Thread::current()-&gt;is_VM_thread() || is_locked(), &quot;checking&quot;);
<span class="line-added">+ </span>
<span class="line-added">+   // ref was read with AS_NO_KEEPALIVE, or equivalent.</span>
<span class="line-added">+   // The object needs to be kept alive when it is published.</span>
<span class="line-added">+   Universe::heap()-&gt;keep_alive(ref);</span>
<span class="line-added">+ </span>
    JvmtiTagHashmapEntry* entry;
    if (_free_entries == NULL) {
      entry = new JvmtiTagHashmapEntry(ref, tag);
    } else {
      assert(_free_entries_count &gt; 0, &quot;mismatched _free_entries_count&quot;);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 555,19 ***</span>
  }
  
  // returns the tag map for the given environments. If the tag map
  // doesn&#39;t exist then it is created.
  JvmtiTagMap* JvmtiTagMap::tag_map_for(JvmtiEnv* env) {
<span class="line-modified">!   JvmtiTagMap* tag_map = ((JvmtiEnvBase*)env)-&gt;tag_map();</span>
    if (tag_map == NULL) {
      MutexLocker mu(JvmtiThreadState_lock);
      tag_map = ((JvmtiEnvBase*)env)-&gt;tag_map();
      if (tag_map == NULL) {
        tag_map = new JvmtiTagMap(env);
      }
    } else {
<span class="line-modified">!     CHECK_UNHANDLED_OOPS_ONLY(Thread::current()-&gt;clear_unhandled_oops());</span>
    }
    return tag_map;
  }
  
  // iterate over all entries in the tag map.
<span class="line-new-header">--- 558,19 ---</span>
  }
  
  // returns the tag map for the given environments. If the tag map
  // doesn&#39;t exist then it is created.
  JvmtiTagMap* JvmtiTagMap::tag_map_for(JvmtiEnv* env) {
<span class="line-modified">!   JvmtiTagMap* tag_map = ((JvmtiEnvBase*)env)-&gt;tag_map_acquire();</span>
    if (tag_map == NULL) {
      MutexLocker mu(JvmtiThreadState_lock);
      tag_map = ((JvmtiEnvBase*)env)-&gt;tag_map();
      if (tag_map == NULL) {
        tag_map = new JvmtiTagMap(env);
      }
    } else {
<span class="line-modified">!     DEBUG_ONLY(Thread::current()-&gt;check_possible_safepoint());</span>
    }
    return tag_map;
  }
  
  // iterate over all entries in the tag map.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1077,11 ***</span>
    return false;
  }
  
  // helper function to tell if a field is a primitive field or not
  static inline bool is_primitive_field_type(char type) {
<span class="line-modified">!   return (type != &#39;L&#39; &amp;&amp; type != &#39;[&#39;);</span>
  }
  
  // helper function to copy the value from location addr to jvalue.
  static inline void copy_to_jvalue(jvalue *v, address addr, jvmtiPrimitiveType value_type) {
    switch (value_type) {
<span class="line-new-header">--- 1080,11 ---</span>
    return false;
  }
  
  // helper function to tell if a field is a primitive field or not
  static inline bool is_primitive_field_type(char type) {
<span class="line-modified">!   return (type != JVM_SIGNATURE_CLASS &amp;&amp; type != JVM_SIGNATURE_ARRAY);</span>
  }
  
  // helper function to copy the value from location addr to jvalue.
  static inline void copy_to_jvalue(jvalue *v, address addr, jvmtiPrimitiveType value_type) {
    switch (value_type) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1217,11 ***</span>
      // one-to-one mapping
      jvmtiPrimitiveType value_type = (jvmtiPrimitiveType)type;
  
      // get offset and field value
      int offset = field-&gt;field_offset();
<span class="line-modified">!     address addr = (address)klass-&gt;java_mirror() + offset;</span>
      jvalue value;
      copy_to_jvalue(&amp;value, addr, value_type);
  
      // field index
      reference_info.field.index = field-&gt;field_index();
<span class="line-new-header">--- 1220,11 ---</span>
      // one-to-one mapping
      jvmtiPrimitiveType value_type = (jvmtiPrimitiveType)type;
  
      // get offset and field value
      int offset = field-&gt;field_offset();
<span class="line-modified">!     address addr = cast_from_oop&lt;address&gt;(klass-&gt;java_mirror()) + offset;</span>
      jvalue value;
      copy_to_jvalue(&amp;value, addr, value_type);
  
      // field index
      reference_info.field.index = field-&gt;field_index();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1270,11 ***</span>
      // one-to-one mapping
      jvmtiPrimitiveType value_type = (jvmtiPrimitiveType)type;
  
      // get offset and field value
      int offset = field-&gt;field_offset();
<span class="line-modified">!     address addr = (address)obj + offset;</span>
      jvalue value;
      copy_to_jvalue(&amp;value, addr, value_type);
  
      // field index
      reference_info.field.index = field-&gt;field_index();
<span class="line-new-header">--- 1273,11 ---</span>
      // one-to-one mapping
      jvmtiPrimitiveType value_type = (jvmtiPrimitiveType)type;
  
      // get offset and field value
      int offset = field-&gt;field_offset();
<span class="line-modified">!     address addr = cast_from_oop&lt;address&gt;(obj) + offset;</span>
      jvalue value;
      copy_to_jvalue(&amp;value, addr, value_type);
  
      // field index
      reference_info.field.index = field-&gt;field_index();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1327,13 ***</span>
      if (VerifyBeforeIteration) {
        Universe::verify();
      }
  
      // do the iteration
<span class="line-removed">-     // If this operation encounters a bad object when using CMS,</span>
<span class="line-removed">-     // consider using safe_object_iterate() which avoids perm gen</span>
<span class="line-removed">-     // objects that may contain bad references.</span>
      Universe::heap()-&gt;object_iterate(_blk);
    }
  
  };
  
<span class="line-new-header">--- 1330,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1601,11 ***</span>
          // The reference in this tag map could be the only (implicitly weak)
          // reference to that object. If we hand it out, we need to keep it live wrt
          // SATB marking similar to other j.l.ref.Reference referents. This is
          // achieved by using a phantom load in the object() accessor.
          oop o = entry-&gt;object();
<span class="line-modified">!         assert(o != NULL &amp;&amp; Universe::heap()-&gt;is_in_reserved(o), &quot;sanity check&quot;);</span>
          jobject ref = JNIHandles::make_local(JavaThread::current(), o);
          _object_results-&gt;append(ref);
          _tag_results-&gt;append((uint64_t)entry-&gt;tag());
        }
      }
<span class="line-new-header">--- 1601,11 ---</span>
          // The reference in this tag map could be the only (implicitly weak)
          // reference to that object. If we hand it out, we need to keep it live wrt
          // SATB marking similar to other j.l.ref.Reference referents. This is
          // achieved by using a phantom load in the object() accessor.
          oop o = entry-&gt;object();
<span class="line-modified">!         assert(o != NULL &amp;&amp; Universe::heap()-&gt;is_in(o), &quot;sanity check&quot;);</span>
          jobject ref = JNIHandles::make_local(JavaThread::current(), o);
          _object_results-&gt;append(ref);
          _tag_results-&gt;append((uint64_t)entry-&gt;tag());
        }
      }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1685,12 ***</span>
  // An ObjectClosure used to restore the mark bits of an object
  class RestoreMarksClosure : public ObjectClosure {
   public:
    void do_object(oop o) {
      if (o != NULL) {
<span class="line-modified">!       markOop mark = o-&gt;mark();</span>
<span class="line-modified">!       if (mark-&gt;is_marked()) {</span>
          o-&gt;init_mark();
        }
      }
    }
  };
<span class="line-new-header">--- 1685,12 ---</span>
  // An ObjectClosure used to restore the mark bits of an object
  class RestoreMarksClosure : public ObjectClosure {
   public:
    void do_object(oop o) {
      if (o != NULL) {
<span class="line-modified">!       markWord mark = o-&gt;mark();</span>
<span class="line-modified">!       if (mark.is_marked()) {</span>
          o-&gt;init_mark();
        }
      }
    }
  };
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1698,11 ***</span>
  // ObjectMarker provides the mark and visited functions
  class ObjectMarker : AllStatic {
   private:
    // saved headers
    static GrowableArray&lt;oop&gt;* _saved_oop_stack;
<span class="line-modified">!   static GrowableArray&lt;markOop&gt;* _saved_mark_stack;</span>
    static bool _needs_reset;                  // do we need to reset mark bits?
  
   public:
    static void init();                       // initialize
    static void done();                       // clean-up
<span class="line-new-header">--- 1698,11 ---</span>
  // ObjectMarker provides the mark and visited functions
  class ObjectMarker : AllStatic {
   private:
    // saved headers
    static GrowableArray&lt;oop&gt;* _saved_oop_stack;
<span class="line-modified">!   static GrowableArray&lt;markWord&gt;* _saved_mark_stack;</span>
    static bool _needs_reset;                  // do we need to reset mark bits?
  
   public:
    static void init();                       // initialize
    static void done();                       // clean-up
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1713,22 ***</span>
    static inline bool needs_reset()            { return _needs_reset; }
    static inline void set_needs_reset(bool v)  { _needs_reset = v; }
  };
  
  GrowableArray&lt;oop&gt;* ObjectMarker::_saved_oop_stack = NULL;
<span class="line-modified">! GrowableArray&lt;markOop&gt;* ObjectMarker::_saved_mark_stack = NULL;</span>
  bool ObjectMarker::_needs_reset = true;  // need to reset mark bits by default
  
  // initialize ObjectMarker - prepares for object marking
  void ObjectMarker::init() {
    assert(Thread::current()-&gt;is_VM_thread(), &quot;must be VMThread&quot;);
  
    // prepare heap for iteration
    Universe::heap()-&gt;ensure_parsability(false);  // no need to retire TLABs
  
    // create stacks for interesting headers
<span class="line-modified">!   _saved_mark_stack = new (ResourceObj::C_HEAP, mtInternal) GrowableArray&lt;markOop&gt;(4000, true);</span>
    _saved_oop_stack = new (ResourceObj::C_HEAP, mtInternal) GrowableArray&lt;oop&gt;(4000, true);
  
    if (UseBiasedLocking) {
      BiasedLocking::preserve_marks();
    }
<span class="line-new-header">--- 1713,22 ---</span>
    static inline bool needs_reset()            { return _needs_reset; }
    static inline void set_needs_reset(bool v)  { _needs_reset = v; }
  };
  
  GrowableArray&lt;oop&gt;* ObjectMarker::_saved_oop_stack = NULL;
<span class="line-modified">! GrowableArray&lt;markWord&gt;* ObjectMarker::_saved_mark_stack = NULL;</span>
  bool ObjectMarker::_needs_reset = true;  // need to reset mark bits by default
  
  // initialize ObjectMarker - prepares for object marking
  void ObjectMarker::init() {
    assert(Thread::current()-&gt;is_VM_thread(), &quot;must be VMThread&quot;);
  
    // prepare heap for iteration
    Universe::heap()-&gt;ensure_parsability(false);  // no need to retire TLABs
  
    // create stacks for interesting headers
<span class="line-modified">!   _saved_mark_stack = new (ResourceObj::C_HEAP, mtInternal) GrowableArray&lt;markWord&gt;(4000, true);</span>
    _saved_oop_stack = new (ResourceObj::C_HEAP, mtInternal) GrowableArray&lt;oop&gt;(4000, true);
  
    if (UseBiasedLocking) {
      BiasedLocking::preserve_marks();
    }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1748,11 ***</span>
    }
  
    // now restore the interesting headers
    for (int i = 0; i &lt; _saved_oop_stack-&gt;length(); i++) {
      oop o = _saved_oop_stack-&gt;at(i);
<span class="line-modified">!     markOop mark = _saved_mark_stack-&gt;at(i);</span>
      o-&gt;set_mark(mark);
    }
  
    if (UseBiasedLocking) {
      BiasedLocking::restore_marks();
<span class="line-new-header">--- 1748,11 ---</span>
    }
  
    // now restore the interesting headers
    for (int i = 0; i &lt; _saved_oop_stack-&gt;length(); i++) {
      oop o = _saved_oop_stack-&gt;at(i);
<span class="line-modified">!     markWord mark = _saved_mark_stack-&gt;at(i);</span>
      o-&gt;set_mark(mark);
    }
  
    if (UseBiasedLocking) {
      BiasedLocking::restore_marks();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1764,27 ***</span>
  }
  
  // mark an object
  inline void ObjectMarker::mark(oop o) {
    assert(Universe::heap()-&gt;is_in(o), &quot;sanity check&quot;);
<span class="line-modified">!   assert(!o-&gt;mark()-&gt;is_marked(), &quot;should only mark an object once&quot;);</span>
  
    // object&#39;s mark word
<span class="line-modified">!   markOop mark = o-&gt;mark();</span>
  
<span class="line-modified">!   if (mark-&gt;must_be_preserved(o)) {</span>
      _saved_mark_stack-&gt;push(mark);
      _saved_oop_stack-&gt;push(o);
    }
  
    // mark the object
<span class="line-modified">!   o-&gt;set_mark(markOopDesc::prototype()-&gt;set_marked());</span>
  }
  
  // return true if object is marked
  inline bool ObjectMarker::visited(oop o) {
<span class="line-modified">!   return o-&gt;mark()-&gt;is_marked();</span>
  }
  
  // Stack allocated class to help ensure that ObjectMarker is used
  // correctly. Constructor initializes ObjectMarker, destructor calls
  // ObjectMarker&#39;s done() function to restore object headers.
<span class="line-new-header">--- 1764,27 ---</span>
  }
  
  // mark an object
  inline void ObjectMarker::mark(oop o) {
    assert(Universe::heap()-&gt;is_in(o), &quot;sanity check&quot;);
<span class="line-modified">!   assert(!o-&gt;mark().is_marked(), &quot;should only mark an object once&quot;);</span>
  
    // object&#39;s mark word
<span class="line-modified">!   markWord mark = o-&gt;mark();</span>
  
<span class="line-modified">!   if (o-&gt;mark_must_be_preserved(mark)) {</span>
      _saved_mark_stack-&gt;push(mark);
      _saved_oop_stack-&gt;push(o);
    }
  
    // mark the object
<span class="line-modified">!   o-&gt;set_mark(markWord::prototype().set_marked());</span>
  }
  
  // return true if object is marked
  inline bool ObjectMarker::visited(oop o) {
<span class="line-modified">!   return o-&gt;mark().is_marked();</span>
  }
  
  // Stack allocated class to help ensure that ObjectMarker is used
  // correctly. Constructor initializes ObjectMarker, destructor calls
  // ObjectMarker&#39;s done() function to restore object headers.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2629,11 ***</span>
      // ignore null
      if (o == NULL) {
        return;
      }
  
<span class="line-modified">!     assert(Universe::heap()-&gt;is_in_reserved(o), &quot;should be impossible&quot;);</span>
  
      jvmtiHeapReferenceKind kind = root_kind();
      if (kind == JVMTI_HEAP_REFERENCE_SYSTEM_CLASS) {
        // SystemDictionary::oops_do reports the application
        // class loader as a root. We want this root to be reported as
<span class="line-new-header">--- 2629,11 ---</span>
      // ignore null
      if (o == NULL) {
        return;
      }
  
<span class="line-modified">!     assert(Universe::heap()-&gt;is_in(o), &quot;should be impossible&quot;);</span>
  
      jvmtiHeapReferenceKind kind = root_kind();
      if (kind == JVMTI_HEAP_REFERENCE_SYSTEM_CLASS) {
        // SystemDictionary::oops_do reports the application
        // class loader as a root. We want this root to be reported as
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2858,11 ***</span>
  
  #ifdef ASSERT
  // verify that a static oop field is in range
  static inline bool verify_static_oop(InstanceKlass* ik,
                                       oop mirror, int offset) {
<span class="line-modified">!   address obj_p = (address)mirror + offset;</span>
    address start = (address)InstanceMirrorKlass::start_of_static_fields(mirror);
    address end = start + (java_lang_Class::static_oop_field_count(mirror) * heapOopSize);
    assert(end &gt;= start, &quot;sanity check&quot;);
  
    if (obj_p &gt;= start &amp;&amp; obj_p &lt; end) {
<span class="line-new-header">--- 2858,11 ---</span>
  
  #ifdef ASSERT
  // verify that a static oop field is in range
  static inline bool verify_static_oop(InstanceKlass* ik,
                                       oop mirror, int offset) {
<span class="line-modified">!   address obj_p = cast_from_oop&lt;address&gt;(mirror) + offset;</span>
    address start = (address)InstanceMirrorKlass::start_of_static_fields(mirror);
    address end = start + (java_lang_Class::static_oop_field_count(mirror) * heapOopSize);
    assert(end &gt;= start, &quot;sanity check&quot;);
  
    if (obj_p &gt;= start &amp;&amp; obj_p &lt; end) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2986,11 ***</span>
              return false;
            }
          }
        } else {
           if (is_reporting_primitive_fields()) {
<span class="line-modified">!            address addr = (address)mirror + field-&gt;field_offset();</span>
             int slot = field-&gt;field_index();
             if (!CallbackInvoker::report_primitive_static_field(mirror, slot, addr, type)) {
               delete field_map;
               return false;
            }
<span class="line-new-header">--- 2986,11 ---</span>
              return false;
            }
          }
        } else {
           if (is_reporting_primitive_fields()) {
<span class="line-modified">!            address addr = cast_from_oop&lt;address&gt;(mirror) + field-&gt;field_offset();</span>
             int slot = field-&gt;field_index();
             if (!CallbackInvoker::report_primitive_static_field(mirror, slot, addr, type)) {
               delete field_map;
               return false;
            }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3018,24 ***</span>
    ClassFieldMap* field_map = JvmtiCachedClassFieldMap::get_map_of_instance_fields(o);
    for (int i=0; i&lt;field_map-&gt;field_count(); i++) {
      ClassFieldDescriptor* field = field_map-&gt;field_at(i);
      char type = field-&gt;field_type();
      if (!is_primitive_field_type(type)) {
<span class="line-modified">!       oop fld_o = o-&gt;obj_field(field-&gt;field_offset());</span>
        // ignore any objects that aren&#39;t visible to profiler
        if (fld_o != NULL) {
<span class="line-modified">!         assert(Universe::heap()-&gt;is_in_reserved(fld_o), &quot;unsafe code should not &quot;</span>
                 &quot;have references to Klass* anymore&quot;);
          int slot = field-&gt;field_index();
          if (!CallbackInvoker::report_field_reference(o, fld_o, slot)) {
            return false;
          }
        }
      } else {
        if (is_reporting_primitive_fields()) {
          // primitive instance field
<span class="line-modified">!         address addr = (address)o + field-&gt;field_offset();</span>
          int slot = field-&gt;field_index();
          if (!CallbackInvoker::report_primitive_instance_field(o, slot, addr, type)) {
            return false;
          }
        }
<span class="line-new-header">--- 3018,24 ---</span>
    ClassFieldMap* field_map = JvmtiCachedClassFieldMap::get_map_of_instance_fields(o);
    for (int i=0; i&lt;field_map-&gt;field_count(); i++) {
      ClassFieldDescriptor* field = field_map-&gt;field_at(i);
      char type = field-&gt;field_type();
      if (!is_primitive_field_type(type)) {
<span class="line-modified">!       oop fld_o = o-&gt;obj_field_access&lt;AS_NO_KEEPALIVE | ON_UNKNOWN_OOP_REF&gt;(field-&gt;field_offset());</span>
        // ignore any objects that aren&#39;t visible to profiler
        if (fld_o != NULL) {
<span class="line-modified">!         assert(Universe::heap()-&gt;is_in(fld_o), &quot;unsafe code should not &quot;</span>
                 &quot;have references to Klass* anymore&quot;);
          int slot = field-&gt;field_index();
          if (!CallbackInvoker::report_field_reference(o, fld_o, slot)) {
            return false;
          }
        }
      } else {
        if (is_reporting_primitive_fields()) {
          // primitive instance field
<span class="line-modified">!         address addr = cast_from_oop&lt;address&gt;(o) + field-&gt;field_offset();</span>
          int slot = field-&gt;field_index();
          if (!CallbackInvoker::report_primitive_instance_field(o, slot, addr, type)) {
            return false;
          }
        }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3092,10 ***</span>
<span class="line-new-header">--- 3092,13 ---</span>
    // Other kinds of roots maintained by HotSpot
    // Many of these won&#39;t be visible but others (such as instances of important
    // exceptions) will be visible.
    blk.set_kind(JVMTI_HEAP_REFERENCE_OTHER);
    Universe::oops_do(&amp;blk);
<span class="line-added">+   if (blk.stopped()) {</span>
<span class="line-added">+     return false;</span>
<span class="line-added">+   }</span>
  
    return true;
  }
  
  // Walk the stack of a given thread and find all references (locals
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3367,11 ***</span>
           SafepointSynchronize::is_at_safepoint(),
           &quot;must be executed at a safepoint&quot;);
    if (JvmtiEnv::environments_might_exist()) {
      JvmtiEnvIterator it;
      for (JvmtiEnvBase* env = it.first(); env != NULL; env = it.next(env)) {
<span class="line-modified">!       JvmtiTagMap* tag_map = env-&gt;tag_map();</span>
        if (tag_map != NULL &amp;&amp; !tag_map-&gt;is_empty()) {
          tag_map-&gt;do_weak_oops(is_alive, f);
        }
      }
    }
<span class="line-new-header">--- 3370,11 ---</span>
           SafepointSynchronize::is_at_safepoint(),
           &quot;must be executed at a safepoint&quot;);
    if (JvmtiEnv::environments_might_exist()) {
      JvmtiEnvIterator it;
      for (JvmtiEnvBase* env = it.first(); env != NULL; env = it.next(env)) {
<span class="line-modified">!       JvmtiTagMap* tag_map = env-&gt;tag_map_acquire();</span>
        if (tag_map != NULL &amp;&amp; !tag_map-&gt;is_empty()) {
          tag_map-&gt;do_weak_oops(is_alive, f);
        }
      }
    }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3409,11 ***</span>
  
      while (entry != NULL) {
        JvmtiTagHashmapEntry* next = entry-&gt;next();
  
        // has object been GC&#39;ed
<span class="line-modified">!       if (!is_alive-&gt;do_object_b(entry-&gt;object_peek())) {</span>
          // grab the tag
          jlong tag = entry-&gt;tag();
          guarantee(tag != 0, &quot;checking&quot;);
  
          // remove GC&#39;ed entry from hashmap and return the
<span class="line-new-header">--- 3412,11 ---</span>
  
      while (entry != NULL) {
        JvmtiTagHashmapEntry* next = entry-&gt;next();
  
        // has object been GC&#39;ed
<span class="line-modified">!       if (!is_alive-&gt;do_object_b(entry-&gt;object_raw())) {</span>
          // grab the tag
          jlong tag = entry-&gt;tag();
          guarantee(tag != 0, &quot;checking&quot;);
  
          // remove GC&#39;ed entry from hashmap and return the
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3427,11 ***</span>
          }
  
          ++freed;
        } else {
          f-&gt;do_oop(entry-&gt;object_addr());
<span class="line-modified">!         oop new_oop = entry-&gt;object_peek();</span>
  
          // if the object has moved then re-hash it and move its
          // entry to its new location.
          unsigned int new_pos = JvmtiTagHashmap::hash(new_oop, size);
          if (new_pos != (unsigned int)pos) {
<span class="line-new-header">--- 3430,11 ---</span>
          }
  
          ++freed;
        } else {
          f-&gt;do_oop(entry-&gt;object_addr());
<span class="line-modified">!         oop new_oop = entry-&gt;object_raw();</span>
  
          // if the object has moved then re-hash it and move its
          // entry to its new location.
          unsigned int new_pos = JvmtiTagHashmap::hash(new_oop, size);
          if (new_pos != (unsigned int)pos) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3461,11 ***</span>
    }
  
    // Re-add all the entries which were kept aside
    while (delayed_add != NULL) {
      JvmtiTagHashmapEntry* next = delayed_add-&gt;next();
<span class="line-modified">!     unsigned int pos = JvmtiTagHashmap::hash(delayed_add-&gt;object_peek(), size);</span>
      delayed_add-&gt;set_next(table[pos]);
      table[pos] = delayed_add;
      delayed_add = next;
    }
  
<span class="line-new-header">--- 3464,11 ---</span>
    }
  
    // Re-add all the entries which were kept aside
    while (delayed_add != NULL) {
      JvmtiTagHashmapEntry* next = delayed_add-&gt;next();
<span class="line-modified">!     unsigned int pos = JvmtiTagHashmap::hash(delayed_add-&gt;object_raw(), size);</span>
      delayed_add-&gt;set_next(table[pos]);
      table[pos] = delayed_add;
      delayed_add = next;
    }
  
</pre>
<center><a href="jvmtiRawMonitor.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="jvmtiTagMap.hpp.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
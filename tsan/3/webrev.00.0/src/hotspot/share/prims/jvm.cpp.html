<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/hotspot/share/prims/jvm.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 1997, 2020, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include &quot;precompiled.hpp&quot;
  26 #include &quot;jvm.h&quot;
  27 #include &quot;classfile/classFileStream.hpp&quot;
  28 #include &quot;classfile/classLoader.hpp&quot;
  29 #include &quot;classfile/classLoaderData.inline.hpp&quot;
  30 #include &quot;classfile/javaAssertions.hpp&quot;
  31 #include &quot;classfile/javaClasses.inline.hpp&quot;
  32 #include &quot;classfile/moduleEntry.hpp&quot;
  33 #include &quot;classfile/modules.hpp&quot;
  34 #include &quot;classfile/packageEntry.hpp&quot;
  35 #include &quot;classfile/stringTable.hpp&quot;
  36 #include &quot;classfile/symbolTable.hpp&quot;
  37 #include &quot;classfile/systemDictionary.hpp&quot;
  38 #include &quot;classfile/vmSymbols.hpp&quot;
  39 #include &quot;gc/shared/collectedHeap.inline.hpp&quot;
  40 #include &quot;interpreter/bytecode.hpp&quot;
  41 #include &quot;interpreter/bytecodeUtils.hpp&quot;
  42 #include &quot;jfr/jfrEvents.hpp&quot;
  43 #include &quot;logging/log.hpp&quot;
  44 #include &quot;memory/heapShared.hpp&quot;
  45 #include &quot;memory/oopFactory.hpp&quot;
  46 #include &quot;memory/referenceType.hpp&quot;
  47 #include &quot;memory/resourceArea.hpp&quot;
  48 #include &quot;memory/universe.hpp&quot;
  49 #include &quot;oops/access.inline.hpp&quot;
  50 #include &quot;oops/constantPool.hpp&quot;
  51 #include &quot;oops/fieldStreams.inline.hpp&quot;
  52 #include &quot;oops/instanceKlass.hpp&quot;
  53 #include &quot;oops/method.hpp&quot;
  54 #include &quot;oops/recordComponent.hpp&quot;
  55 #include &quot;oops/objArrayKlass.hpp&quot;
  56 #include &quot;oops/objArrayOop.inline.hpp&quot;
  57 #include &quot;oops/oop.inline.hpp&quot;
  58 #include &quot;prims/jvm_misc.hpp&quot;
  59 #include &quot;prims/jvmtiExport.hpp&quot;
  60 #include &quot;prims/jvmtiThreadState.hpp&quot;
  61 #include &quot;prims/nativeLookup.hpp&quot;
  62 #include &quot;prims/stackwalk.hpp&quot;
  63 #include &quot;runtime/arguments.hpp&quot;
  64 #include &quot;runtime/atomic.hpp&quot;
  65 #include &quot;runtime/handles.inline.hpp&quot;
  66 #include &quot;runtime/init.hpp&quot;
  67 #include &quot;runtime/interfaceSupport.inline.hpp&quot;
  68 #include &quot;runtime/deoptimization.hpp&quot;
  69 #include &quot;runtime/handshake.hpp&quot;
  70 #include &quot;runtime/java.hpp&quot;
  71 #include &quot;runtime/javaCalls.hpp&quot;
  72 #include &quot;runtime/jfieldIDWorkaround.hpp&quot;
  73 #include &quot;runtime/jniHandles.inline.hpp&quot;
  74 #include &quot;runtime/os.inline.hpp&quot;
  75 #include &quot;runtime/perfData.hpp&quot;
  76 #include &quot;runtime/reflection.hpp&quot;
  77 #include &quot;runtime/thread.inline.hpp&quot;
  78 #include &quot;runtime/threadSMR.hpp&quot;
  79 #include &quot;runtime/vframe.inline.hpp&quot;
  80 #include &quot;runtime/vmOperations.hpp&quot;
  81 #include &quot;runtime/vm_version.hpp&quot;
  82 #include &quot;services/attachListener.hpp&quot;
  83 #include &quot;services/management.hpp&quot;
  84 #include &quot;services/threadService.hpp&quot;
  85 #if INCLUDE_TSAN
  86 #include &quot;tsan/tsan.hpp&quot;
  87 #endif  // INCLUDE_TSAN
  88 #include &quot;utilities/copy.hpp&quot;
  89 #include &quot;utilities/defaultStream.hpp&quot;
  90 #include &quot;utilities/dtrace.hpp&quot;
  91 #include &quot;utilities/events.hpp&quot;
  92 #include &quot;utilities/histogram.hpp&quot;
  93 #include &quot;utilities/macros.hpp&quot;
  94 #include &quot;utilities/utf8.hpp&quot;
  95 #if INCLUDE_CDS
  96 #include &quot;classfile/systemDictionaryShared.hpp&quot;
  97 #endif
  98 
  99 #include &lt;errno.h&gt;
 100 
 101 /*
 102   NOTE about use of any ctor or function call that can trigger a safepoint/GC:
 103   such ctors and calls MUST NOT come between an oop declaration/init and its
 104   usage because if objects are move this may cause various memory stomps, bus
 105   errors and segfaults. Here is a cookbook for causing so called &quot;naked oop
 106   failures&quot;:
 107 
 108       JVM_ENTRY(jobjectArray, JVM_GetClassDeclaredFields&lt;etc&gt; {
 109           JVMWrapper(&quot;JVM_GetClassDeclaredFields&quot;);
 110 
 111           // Object address to be held directly in mirror &amp; not visible to GC
 112           oop mirror = JNIHandles::resolve_non_null(ofClass);
 113 
 114           // If this ctor can hit a safepoint, moving objects around, then
 115           ComplexConstructor foo;
 116 
 117           // Boom! mirror may point to JUNK instead of the intended object
 118           (some dereference of mirror)
 119 
 120           // Here&#39;s another call that may block for GC, making mirror stale
 121           MutexLocker ml(some_lock);
 122 
 123           // And here&#39;s an initializer that can result in a stale oop
 124           // all in one step.
 125           oop o = call_that_can_throw_exception(TRAPS);
 126 
 127 
 128   The solution is to keep the oop declaration BELOW the ctor or function
 129   call that might cause a GC, do another resolve to reassign the oop, or
 130   consider use of a Handle instead of an oop so there is immunity from object
 131   motion. But note that the &quot;QUICK&quot; entries below do not have a handlemark
 132   and thus can only support use of handles passed in.
 133 */
 134 
 135 static void trace_class_resolution_impl(Klass* to_class, TRAPS) {
 136   ResourceMark rm;
 137   int line_number = -1;
 138   const char * source_file = NULL;
 139   const char * trace = &quot;explicit&quot;;
 140   InstanceKlass* caller = NULL;
 141   JavaThread* jthread = JavaThread::current();
 142   if (jthread-&gt;has_last_Java_frame()) {
 143     vframeStream vfst(jthread);
 144 
 145     // scan up the stack skipping ClassLoader, AccessController and PrivilegedAction frames
 146     TempNewSymbol access_controller = SymbolTable::new_symbol(&quot;java/security/AccessController&quot;);
 147     Klass* access_controller_klass = SystemDictionary::resolve_or_fail(access_controller, false, CHECK);
 148     TempNewSymbol privileged_action = SymbolTable::new_symbol(&quot;java/security/PrivilegedAction&quot;);
 149     Klass* privileged_action_klass = SystemDictionary::resolve_or_fail(privileged_action, false, CHECK);
 150 
 151     Method* last_caller = NULL;
 152 
 153     while (!vfst.at_end()) {
 154       Method* m = vfst.method();
 155       if (!vfst.method()-&gt;method_holder()-&gt;is_subclass_of(SystemDictionary::ClassLoader_klass())&amp;&amp;
 156           !vfst.method()-&gt;method_holder()-&gt;is_subclass_of(access_controller_klass) &amp;&amp;
 157           !vfst.method()-&gt;method_holder()-&gt;is_subclass_of(privileged_action_klass)) {
 158         break;
 159       }
 160       last_caller = m;
 161       vfst.next();
 162     }
 163     // if this is called from Class.forName0 and that is called from Class.forName,
 164     // then print the caller of Class.forName.  If this is Class.loadClass, then print
 165     // that caller, otherwise keep quiet since this should be picked up elsewhere.
 166     bool found_it = false;
 167     if (!vfst.at_end() &amp;&amp;
 168         vfst.method()-&gt;method_holder()-&gt;name() == vmSymbols::java_lang_Class() &amp;&amp;
 169         vfst.method()-&gt;name() == vmSymbols::forName0_name()) {
 170       vfst.next();
 171       if (!vfst.at_end() &amp;&amp;
 172           vfst.method()-&gt;method_holder()-&gt;name() == vmSymbols::java_lang_Class() &amp;&amp;
 173           vfst.method()-&gt;name() == vmSymbols::forName_name()) {
 174         vfst.next();
 175         found_it = true;
 176       }
 177     } else if (last_caller != NULL &amp;&amp;
 178                last_caller-&gt;method_holder()-&gt;name() ==
 179                  vmSymbols::java_lang_ClassLoader() &amp;&amp;
 180                last_caller-&gt;name() == vmSymbols::loadClass_name()) {
 181       found_it = true;
 182     } else if (!vfst.at_end()) {
 183       if (vfst.method()-&gt;is_native()) {
 184         // JNI call
 185         found_it = true;
 186       }
 187     }
 188     if (found_it &amp;&amp; !vfst.at_end()) {
 189       // found the caller
 190       caller = vfst.method()-&gt;method_holder();
 191       line_number = vfst.method()-&gt;line_number_from_bci(vfst.bci());
 192       if (line_number == -1) {
 193         // show method name if it&#39;s a native method
 194         trace = vfst.method()-&gt;name_and_sig_as_C_string();
 195       }
 196       Symbol* s = caller-&gt;source_file_name();
 197       if (s != NULL) {
 198         source_file = s-&gt;as_C_string();
 199       }
 200     }
 201   }
 202   if (caller != NULL) {
 203     if (to_class != caller) {
 204       const char * from = caller-&gt;external_name();
 205       const char * to = to_class-&gt;external_name();
 206       // print in a single call to reduce interleaving between threads
 207       if (source_file != NULL) {
 208         log_debug(class, resolve)(&quot;%s %s %s:%d (%s)&quot;, from, to, source_file, line_number, trace);
 209       } else {
 210         log_debug(class, resolve)(&quot;%s %s (%s)&quot;, from, to, trace);
 211       }
 212     }
 213   }
 214 }
 215 
 216 void trace_class_resolution(Klass* to_class) {
 217   EXCEPTION_MARK;
 218   trace_class_resolution_impl(to_class, THREAD);
 219   if (HAS_PENDING_EXCEPTION) {
 220     CLEAR_PENDING_EXCEPTION;
 221   }
 222 }
 223 
 224 // Wrapper to trace JVM functions
 225 
 226 #ifdef ASSERT
 227   Histogram* JVMHistogram;
 228   volatile int JVMHistogram_lock = 0;
 229 
 230   class JVMHistogramElement : public HistogramElement {
 231     public:
 232      JVMHistogramElement(const char* name);
 233   };
 234 
 235   JVMHistogramElement::JVMHistogramElement(const char* elementName) {
 236     _name = elementName;
 237     uintx count = 0;
 238 
 239     while (Atomic::cmpxchg(&amp;JVMHistogram_lock, 0, 1) != 0) {
 240       while (Atomic::load_acquire(&amp;JVMHistogram_lock) != 0) {
 241         count +=1;
 242         if ( (WarnOnStalledSpinLock &gt; 0)
 243           &amp;&amp; (count % WarnOnStalledSpinLock == 0)) {
 244           warning(&quot;JVMHistogram_lock seems to be stalled&quot;);
 245         }
 246       }
 247      }
 248 
 249     if(JVMHistogram == NULL)
 250       JVMHistogram = new Histogram(&quot;JVM Call Counts&quot;,100);
 251 
 252     JVMHistogram-&gt;add_element(this);
 253     Atomic::dec(&amp;JVMHistogram_lock);
 254   }
 255 
 256   #define JVMCountWrapper(arg) \
 257       static JVMHistogramElement* e = new JVMHistogramElement(arg); \
 258       if (e != NULL) e-&gt;increment_count();  // Due to bug in VC++, we need a NULL check here eventhough it should never happen!
 259 
 260   #define JVMWrapper(arg) JVMCountWrapper(arg);
 261 #else
 262   #define JVMWrapper(arg)
 263 #endif
 264 
 265 
 266 // Interface version /////////////////////////////////////////////////////////////////////
 267 
 268 
 269 JVM_LEAF(jint, JVM_GetInterfaceVersion())
 270   return JVM_INTERFACE_VERSION;
 271 JVM_END
 272 
 273 
 274 // java.lang.System //////////////////////////////////////////////////////////////////////
 275 
 276 
 277 JVM_LEAF(jlong, JVM_CurrentTimeMillis(JNIEnv *env, jclass ignored))
 278   JVMWrapper(&quot;JVM_CurrentTimeMillis&quot;);
 279   return os::javaTimeMillis();
 280 JVM_END
 281 
 282 JVM_LEAF(jlong, JVM_NanoTime(JNIEnv *env, jclass ignored))
 283   JVMWrapper(&quot;JVM_NanoTime&quot;);
 284   return os::javaTimeNanos();
 285 JVM_END
 286 
 287 // The function below is actually exposed by jdk.internal.misc.VM and not
 288 // java.lang.System, but we choose to keep it here so that it stays next
 289 // to JVM_CurrentTimeMillis and JVM_NanoTime
 290 
 291 const jlong MAX_DIFF_SECS = CONST64(0x0100000000); //  2^32
 292 const jlong MIN_DIFF_SECS = -MAX_DIFF_SECS; // -2^32
 293 
 294 JVM_LEAF(jlong, JVM_GetNanoTimeAdjustment(JNIEnv *env, jclass ignored, jlong offset_secs))
 295   JVMWrapper(&quot;JVM_GetNanoTimeAdjustment&quot;);
 296   jlong seconds;
 297   jlong nanos;
 298 
 299   os::javaTimeSystemUTC(seconds, nanos);
 300 
 301   // We&#39;re going to verify that the result can fit in a long.
 302   // For that we need the difference in seconds between &#39;seconds&#39;
 303   // and &#39;offset_secs&#39; to be such that:
 304   //     |seconds - offset_secs| &lt; (2^63/10^9)
 305   // We&#39;re going to approximate 10^9 ~&lt; 2^30 (1000^3 ~&lt; 1024^3)
 306   // which makes |seconds - offset_secs| &lt; 2^33
 307   // and we will prefer +/- 2^32 as the maximum acceptable diff
 308   // as 2^32 has a more natural feel than 2^33...
 309   //
 310   // So if |seconds - offset_secs| &gt;= 2^32 - we return a special
 311   // sentinel value (-1) which the caller should take as an
 312   // exception value indicating that the offset given to us is
 313   // too far from range of the current time - leading to too big
 314   // a nano adjustment. The caller is expected to recover by
 315   // computing a more accurate offset and calling this method
 316   // again. (For the record 2^32 secs is ~136 years, so that
 317   // should rarely happen)
 318   //
 319   jlong diff = seconds - offset_secs;
 320   if (diff &gt;= MAX_DIFF_SECS || diff &lt;= MIN_DIFF_SECS) {
 321      return -1; // sentinel value: the offset is too far off the target
 322   }
 323 
 324   // return the adjustment. If you compute a time by adding
 325   // this number of nanoseconds along with the number of seconds
 326   // in the offset you should get the current UTC time.
 327   return (diff * (jlong)1000000000) + nanos;
 328 JVM_END
 329 
 330 JVM_ENTRY(void, JVM_ArrayCopy(JNIEnv *env, jclass ignored, jobject src, jint src_pos,
 331                                jobject dst, jint dst_pos, jint length))
 332   JVMWrapper(&quot;JVM_ArrayCopy&quot;);
 333   // Check if we have null pointers
 334   if (src == NULL || dst == NULL) {
 335     THROW(vmSymbols::java_lang_NullPointerException());
 336   }
 337   arrayOop s = arrayOop(JNIHandles::resolve_non_null(src));
 338   arrayOop d = arrayOop(JNIHandles::resolve_non_null(dst));
 339   assert(oopDesc::is_oop(s), &quot;JVM_ArrayCopy: src not an oop&quot;);
 340   assert(oopDesc::is_oop(d), &quot;JVM_ArrayCopy: dst not an oop&quot;);
 341   // Do copy
 342   s-&gt;klass()-&gt;copy_array(s, src_pos, d, dst_pos, length, thread);
 343 JVM_END
 344 
 345 
 346 static void set_property(Handle props, const char* key, const char* value, TRAPS) {
 347   JavaValue r(T_OBJECT);
 348   // public synchronized Object put(Object key, Object value);
 349   HandleMark hm(THREAD);
 350   Handle key_str    = java_lang_String::create_from_platform_dependent_str(key, CHECK);
 351   Handle value_str  = java_lang_String::create_from_platform_dependent_str((value != NULL ? value : &quot;&quot;), CHECK);
 352   JavaCalls::call_virtual(&amp;r,
 353                           props,
 354                           SystemDictionary::Properties_klass(),
 355                           vmSymbols::put_name(),
 356                           vmSymbols::object_object_object_signature(),
 357                           key_str,
 358                           value_str,
 359                           THREAD);
 360 }
 361 
 362 
 363 #define PUTPROP(props, name, value) set_property((props), (name), (value), CHECK_(properties));
 364 
 365 /*
 366  * Return all of the system properties in a Java String array with alternating
 367  * names and values from the jvm SystemProperty.
 368  * Which includes some internal and all commandline -D defined properties.
 369  */
 370 JVM_ENTRY(jobjectArray, JVM_GetProperties(JNIEnv *env))
 371   JVMWrapper(&quot;JVM_GetProperties&quot;);
 372   ResourceMark rm(THREAD);
 373   HandleMark hm(THREAD);
 374   int ndx = 0;
 375   int fixedCount = 2;
 376 
 377   SystemProperty* p = Arguments::system_properties();
 378   int count = Arguments::PropertyList_count(p);
 379 
 380   // Allocate result String array
 381   InstanceKlass* ik = SystemDictionary::String_klass();
 382   objArrayOop r = oopFactory::new_objArray(ik, (count + fixedCount) * 2, CHECK_NULL);
 383   objArrayHandle result_h(THREAD, r);
 384 
 385   while (p != NULL) {
 386     const char * key = p-&gt;key();
 387     if (strcmp(key, &quot;sun.nio.MaxDirectMemorySize&quot;) != 0) {
 388         const char * value = p-&gt;value();
 389         Handle key_str    = java_lang_String::create_from_platform_dependent_str(key, CHECK_NULL);
 390         Handle value_str  = java_lang_String::create_from_platform_dependent_str((value != NULL ? value : &quot;&quot;), CHECK_NULL);
 391         result_h-&gt;obj_at_put(ndx * 2,  key_str());
 392         result_h-&gt;obj_at_put(ndx * 2 + 1, value_str());
 393         ndx++;
 394     }
 395     p = p-&gt;next();
 396   }
 397 
 398   // Convert the -XX:MaxDirectMemorySize= command line flag
 399   // to the sun.nio.MaxDirectMemorySize property.
 400   // Do this after setting user properties to prevent people
 401   // from setting the value with a -D option, as requested.
 402   // Leave empty if not supplied
 403   if (!FLAG_IS_DEFAULT(MaxDirectMemorySize)) {
 404     char as_chars[256];
 405     jio_snprintf(as_chars, sizeof(as_chars), JULONG_FORMAT, MaxDirectMemorySize);
 406     Handle key_str = java_lang_String::create_from_platform_dependent_str(&quot;sun.nio.MaxDirectMemorySize&quot;, CHECK_NULL);
 407     Handle value_str  = java_lang_String::create_from_platform_dependent_str(as_chars, CHECK_NULL);
 408     result_h-&gt;obj_at_put(ndx * 2,  key_str());
 409     result_h-&gt;obj_at_put(ndx * 2 + 1, value_str());
 410     ndx++;
 411   }
 412 
 413   // JVM monitoring and management support
 414   // Add the sun.management.compiler property for the compiler&#39;s name
 415   {
 416 #undef CSIZE
 417 #if defined(_LP64) || defined(_WIN64)
 418   #define CSIZE &quot;64-Bit &quot;
 419 #else
 420   #define CSIZE
 421 #endif // 64bit
 422 
 423 #ifdef TIERED
 424     const char* compiler_name = &quot;HotSpot &quot; CSIZE &quot;Tiered Compilers&quot;;
 425 #else
 426 #if defined(COMPILER1)
 427     const char* compiler_name = &quot;HotSpot &quot; CSIZE &quot;Client Compiler&quot;;
 428 #elif defined(COMPILER2)
 429     const char* compiler_name = &quot;HotSpot &quot; CSIZE &quot;Server Compiler&quot;;
 430 #elif INCLUDE_JVMCI
 431     #error &quot;INCLUDE_JVMCI should imply TIERED&quot;
 432 #else
 433     const char* compiler_name = &quot;&quot;;
 434 #endif // compilers
 435 #endif // TIERED
 436 
 437     if (*compiler_name != &#39;\0&#39; &amp;&amp;
 438         (Arguments::mode() != Arguments::_int)) {
 439       Handle key_str = java_lang_String::create_from_platform_dependent_str(&quot;sun.management.compiler&quot;, CHECK_NULL);
 440       Handle value_str  = java_lang_String::create_from_platform_dependent_str(compiler_name, CHECK_NULL);
 441       result_h-&gt;obj_at_put(ndx * 2,  key_str());
 442       result_h-&gt;obj_at_put(ndx * 2 + 1, value_str());
 443       ndx++;
 444     }
 445   }
 446 
 447   return (jobjectArray) JNIHandles::make_local(env, result_h());
 448 JVM_END
 449 
 450 
 451 /*
 452  * Return the temporary directory that the VM uses for the attach
 453  * and perf data files.
 454  *
 455  * It is important that this directory is well-known and the
 456  * same for all VM instances. It cannot be affected by configuration
 457  * variables such as java.io.tmpdir.
 458  */
 459 JVM_ENTRY(jstring, JVM_GetTemporaryDirectory(JNIEnv *env))
 460   JVMWrapper(&quot;JVM_GetTemporaryDirectory&quot;);
 461   HandleMark hm(THREAD);
 462   const char* temp_dir = os::get_temp_directory();
 463   Handle h = java_lang_String::create_from_platform_dependent_str(temp_dir, CHECK_NULL);
 464   return (jstring) JNIHandles::make_local(env, h());
 465 JVM_END
 466 
 467 
 468 // java.lang.Runtime /////////////////////////////////////////////////////////////////////////
 469 
 470 extern volatile jint vm_created;
 471 
 472 JVM_ENTRY_NO_ENV(void, JVM_BeforeHalt())
 473   JVMWrapper(&quot;JVM_BeforeHalt&quot;);
 474   EventShutdown event;
 475   if (event.should_commit()) {
 476     event.set_reason(&quot;Shutdown requested from Java&quot;);
 477     event.commit();
 478   }
 479 JVM_END
 480 
 481 
 482 JVM_ENTRY_NO_ENV(void, JVM_Halt(jint code))
 483   before_exit(thread);
 484   vm_exit(code);
 485 JVM_END
 486 
 487 
 488 JVM_ENTRY_NO_ENV(void, JVM_GC(void))
 489   JVMWrapper(&quot;JVM_GC&quot;);
 490   if (!DisableExplicitGC) {
 491     Universe::heap()-&gt;collect(GCCause::_java_lang_system_gc);
 492   }
 493 JVM_END
 494 
 495 
 496 JVM_LEAF(jlong, JVM_MaxObjectInspectionAge(void))
 497   JVMWrapper(&quot;JVM_MaxObjectInspectionAge&quot;);
 498   return Universe::heap()-&gt;millis_since_last_gc();
 499 JVM_END
 500 
 501 
 502 static inline jlong convert_size_t_to_jlong(size_t val) {
 503   // In the 64-bit vm, a size_t can overflow a jlong (which is signed).
 504   NOT_LP64 (return (jlong)val;)
 505   LP64_ONLY(return (jlong)MIN2(val, (size_t)max_jlong);)
 506 }
 507 
 508 JVM_ENTRY_NO_ENV(jlong, JVM_TotalMemory(void))
 509   JVMWrapper(&quot;JVM_TotalMemory&quot;);
 510   size_t n = Universe::heap()-&gt;capacity();
 511   return convert_size_t_to_jlong(n);
 512 JVM_END
 513 
 514 
 515 JVM_ENTRY_NO_ENV(jlong, JVM_FreeMemory(void))
 516   JVMWrapper(&quot;JVM_FreeMemory&quot;);
 517   size_t n = Universe::heap()-&gt;unused();
 518   return convert_size_t_to_jlong(n);
 519 JVM_END
 520 
 521 
 522 JVM_ENTRY_NO_ENV(jlong, JVM_MaxMemory(void))
 523   JVMWrapper(&quot;JVM_MaxMemory&quot;);
 524   size_t n = Universe::heap()-&gt;max_capacity();
 525   return convert_size_t_to_jlong(n);
 526 JVM_END
 527 
 528 
 529 JVM_ENTRY_NO_ENV(jint, JVM_ActiveProcessorCount(void))
 530   JVMWrapper(&quot;JVM_ActiveProcessorCount&quot;);
 531   return os::active_processor_count();
 532 JVM_END
 533 
 534 
 535 
 536 // java.lang.Throwable //////////////////////////////////////////////////////
 537 
 538 JVM_ENTRY(void, JVM_FillInStackTrace(JNIEnv *env, jobject receiver))
 539   JVMWrapper(&quot;JVM_FillInStackTrace&quot;);
 540   Handle exception(thread, JNIHandles::resolve_non_null(receiver));
 541   java_lang_Throwable::fill_in_stack_trace(exception);
 542 JVM_END
 543 
 544 // java.lang.NullPointerException ///////////////////////////////////////////
 545 
 546 JVM_ENTRY(jstring, JVM_GetExtendedNPEMessage(JNIEnv *env, jthrowable throwable))
 547   if (!ShowCodeDetailsInExceptionMessages) return NULL;
 548 
 549   oop exc = JNIHandles::resolve_non_null(throwable);
 550 
 551   Method* method;
 552   int bci;
 553   if (!java_lang_Throwable::get_top_method_and_bci(exc, &amp;method, &amp;bci)) {
 554     return NULL;
 555   }
 556   if (method-&gt;is_native()) {
 557     return NULL;
 558   }
 559 
 560   stringStream ss;
 561   bool ok = BytecodeUtils::get_NPE_message_at(&amp;ss, method, bci);
 562   if (ok) {
 563     oop result = java_lang_String::create_oop_from_str(ss.base(), CHECK_0);
 564     return (jstring) JNIHandles::make_local(env, result);
 565   } else {
 566     return NULL;
 567   }
 568 JVM_END
 569 
 570 // java.lang.StackTraceElement //////////////////////////////////////////////
 571 
 572 
 573 JVM_ENTRY(void, JVM_InitStackTraceElementArray(JNIEnv *env, jobjectArray elements, jobject throwable))
 574   JVMWrapper(&quot;JVM_InitStackTraceElementArray&quot;);
 575   Handle exception(THREAD, JNIHandles::resolve(throwable));
 576   objArrayOop st = objArrayOop(JNIHandles::resolve(elements));
 577   objArrayHandle stack_trace(THREAD, st);
 578   // Fill in the allocated stack trace
 579   java_lang_Throwable::get_stack_trace_elements(exception, stack_trace, CHECK);
 580 JVM_END
 581 
 582 
 583 JVM_ENTRY(void, JVM_InitStackTraceElement(JNIEnv* env, jobject element, jobject stackFrameInfo))
 584   JVMWrapper(&quot;JVM_InitStackTraceElement&quot;);
 585   Handle stack_frame_info(THREAD, JNIHandles::resolve_non_null(stackFrameInfo));
 586   Handle stack_trace_element(THREAD, JNIHandles::resolve_non_null(element));
 587   java_lang_StackFrameInfo::to_stack_trace_element(stack_frame_info, stack_trace_element, THREAD);
 588 JVM_END
 589 
 590 
 591 // java.lang.StackWalker //////////////////////////////////////////////////////
 592 
 593 
 594 JVM_ENTRY(jobject, JVM_CallStackWalk(JNIEnv *env, jobject stackStream, jlong mode,
 595                                      jint skip_frames, jint frame_count, jint start_index,
 596                                      jobjectArray frames))
 597   JVMWrapper(&quot;JVM_CallStackWalk&quot;);
 598   JavaThread* jt = (JavaThread*) THREAD;
 599   if (!jt-&gt;is_Java_thread() || !jt-&gt;has_last_Java_frame()) {
 600     THROW_MSG_(vmSymbols::java_lang_InternalError(), &quot;doStackWalk: no stack trace&quot;, NULL);
 601   }
 602 
 603   Handle stackStream_h(THREAD, JNIHandles::resolve_non_null(stackStream));
 604 
 605   // frames array is a Class&lt;?&gt;[] array when only getting caller reference,
 606   // and a StackFrameInfo[] array (or derivative) otherwise. It should never
 607   // be null.
 608   objArrayOop fa = objArrayOop(JNIHandles::resolve_non_null(frames));
 609   objArrayHandle frames_array_h(THREAD, fa);
 610 
 611   int limit = start_index + frame_count;
 612   if (frames_array_h-&gt;length() &lt; limit) {
 613     THROW_MSG_(vmSymbols::java_lang_IllegalArgumentException(), &quot;not enough space in buffers&quot;, NULL);
 614   }
 615 
 616   oop result = StackWalk::walk(stackStream_h, mode, skip_frames, frame_count,
 617                                start_index, frames_array_h, CHECK_NULL);
 618   return JNIHandles::make_local(env, result);
 619 JVM_END
 620 
 621 
 622 JVM_ENTRY(jint, JVM_MoreStackWalk(JNIEnv *env, jobject stackStream, jlong mode, jlong anchor,
 623                                   jint frame_count, jint start_index,
 624                                   jobjectArray frames))
 625   JVMWrapper(&quot;JVM_MoreStackWalk&quot;);
 626   JavaThread* jt = (JavaThread*) THREAD;
 627 
 628   // frames array is a Class&lt;?&gt;[] array when only getting caller reference,
 629   // and a StackFrameInfo[] array (or derivative) otherwise. It should never
 630   // be null.
 631   objArrayOop fa = objArrayOop(JNIHandles::resolve_non_null(frames));
 632   objArrayHandle frames_array_h(THREAD, fa);
 633 
 634   int limit = start_index+frame_count;
 635   if (frames_array_h-&gt;length() &lt; limit) {
 636     THROW_MSG_0(vmSymbols::java_lang_IllegalArgumentException(), &quot;not enough space in buffers&quot;);
 637   }
 638 
 639   Handle stackStream_h(THREAD, JNIHandles::resolve_non_null(stackStream));
 640   return StackWalk::fetchNextBatch(stackStream_h, mode, anchor, frame_count,
 641                                    start_index, frames_array_h, THREAD);
 642 JVM_END
 643 
 644 // java.lang.Object ///////////////////////////////////////////////
 645 
 646 
 647 JVM_ENTRY(jint, JVM_IHashCode(JNIEnv* env, jobject handle))
 648   JVMWrapper(&quot;JVM_IHashCode&quot;);
 649   // as implemented in the classic virtual machine; return 0 if object is NULL
 650   return handle == NULL ? 0 : ObjectSynchronizer::FastHashCode (THREAD, JNIHandles::resolve_non_null(handle)) ;
 651 JVM_END
 652 
 653 
 654 JVM_ENTRY(void, JVM_MonitorWait(JNIEnv* env, jobject handle, jlong ms))
 655   JVMWrapper(&quot;JVM_MonitorWait&quot;);
 656   Handle obj(THREAD, JNIHandles::resolve_non_null(handle));
 657   JavaThreadInObjectWaitState jtiows(thread, ms != 0);
 658   if (JvmtiExport::should_post_monitor_wait()) {
 659     JvmtiExport::post_monitor_wait((JavaThread *)THREAD, (oop)obj(), ms);
 660 
 661     // The current thread already owns the monitor and it has not yet
 662     // been added to the wait queue so the current thread cannot be
 663     // made the successor. This means that the JVMTI_EVENT_MONITOR_WAIT
 664     // event handler cannot accidentally consume an unpark() meant for
 665     // the ParkEvent associated with this ObjectMonitor.
 666   }
 667   ObjectSynchronizer::wait(obj, ms, CHECK);
 668 JVM_END
 669 
 670 
 671 JVM_ENTRY(void, JVM_MonitorNotify(JNIEnv* env, jobject handle))
 672   JVMWrapper(&quot;JVM_MonitorNotify&quot;);
 673   Handle obj(THREAD, JNIHandles::resolve_non_null(handle));
 674   ObjectSynchronizer::notify(obj, CHECK);
 675 JVM_END
 676 
 677 
 678 JVM_ENTRY(void, JVM_MonitorNotifyAll(JNIEnv* env, jobject handle))
 679   JVMWrapper(&quot;JVM_MonitorNotifyAll&quot;);
 680   Handle obj(THREAD, JNIHandles::resolve_non_null(handle));
 681   ObjectSynchronizer::notifyall(obj, CHECK);
 682 JVM_END
 683 
 684 
 685 JVM_ENTRY(jobject, JVM_Clone(JNIEnv* env, jobject handle))
 686   JVMWrapper(&quot;JVM_Clone&quot;);
 687   Handle obj(THREAD, JNIHandles::resolve_non_null(handle));
 688   Klass* klass = obj-&gt;klass();
 689   JvmtiVMObjectAllocEventCollector oam;
 690 
 691 #ifdef ASSERT
 692   // Just checking that the cloneable flag is set correct
 693   if (obj-&gt;is_array()) {
 694     guarantee(klass-&gt;is_cloneable(), &quot;all arrays are cloneable&quot;);
 695   } else {
 696     guarantee(obj-&gt;is_instance(), &quot;should be instanceOop&quot;);
 697     bool cloneable = klass-&gt;is_subtype_of(SystemDictionary::Cloneable_klass());
 698     guarantee(cloneable == klass-&gt;is_cloneable(), &quot;incorrect cloneable flag&quot;);
 699   }
 700 #endif
 701 
 702   // Check if class of obj supports the Cloneable interface.
 703   // All arrays are considered to be cloneable (See JLS 20.1.5).
 704   // All j.l.r.Reference classes are considered non-cloneable.
 705   if (!klass-&gt;is_cloneable() ||
 706       (klass-&gt;is_instance_klass() &amp;&amp;
 707        InstanceKlass::cast(klass)-&gt;reference_type() != REF_NONE)) {
 708     ResourceMark rm(THREAD);
 709     THROW_MSG_0(vmSymbols::java_lang_CloneNotSupportedException(), klass-&gt;external_name());
 710   }
 711 
 712   // Make shallow object copy
 713   const int size = obj-&gt;size();
 714   oop new_obj_oop = NULL;
 715   if (obj-&gt;is_array()) {
 716     const int length = ((arrayOop)obj())-&gt;length();
 717     new_obj_oop = Universe::heap()-&gt;array_allocate(klass, size, length,
 718                                                    /* do_zero */ true, CHECK_NULL);
 719   } else {
 720     new_obj_oop = Universe::heap()-&gt;obj_allocate(klass, size, CHECK_NULL);
 721   }
 722 
 723   HeapAccess&lt;&gt;::clone(obj(), new_obj_oop, size);
 724 
 725   Handle new_obj(THREAD, new_obj_oop);
 726   // Caution: this involves a java upcall, so the clone should be
 727   // &quot;gc-robust&quot; by this stage.
 728   if (klass-&gt;has_finalizer()) {
 729     assert(obj-&gt;is_instance(), &quot;should be instanceOop&quot;);
 730     new_obj_oop = InstanceKlass::register_finalizer(instanceOop(new_obj()), CHECK_NULL);
 731     new_obj = Handle(THREAD, new_obj_oop);
 732   }
 733 
 734   return JNIHandles::make_local(env, new_obj());
 735 JVM_END
 736 
 737 // java.io.File ///////////////////////////////////////////////////////////////
 738 
 739 JVM_LEAF(char*, JVM_NativePath(char* path))
 740   JVMWrapper(&quot;JVM_NativePath&quot;);
 741   return os::native_path(path);
 742 JVM_END
 743 
 744 
 745 // Misc. class handling ///////////////////////////////////////////////////////////
 746 
 747 
 748 JVM_ENTRY(jclass, JVM_GetCallerClass(JNIEnv* env))
 749   JVMWrapper(&quot;JVM_GetCallerClass&quot;);
 750 
 751   // Getting the class of the caller frame.
 752   //
 753   // The call stack at this point looks something like this:
 754   //
 755   // [0] [ @CallerSensitive public sun.reflect.Reflection.getCallerClass ]
 756   // [1] [ @CallerSensitive API.method                                   ]
 757   // [.] [ (skipped intermediate frames)                                 ]
 758   // [n] [ caller                                                        ]
 759   vframeStream vfst(thread);
 760   // Cf. LibraryCallKit::inline_native_Reflection_getCallerClass
 761   for (int n = 0; !vfst.at_end(); vfst.security_next(), n++) {
 762     Method* m = vfst.method();
 763     assert(m != NULL, &quot;sanity&quot;);
 764     switch (n) {
 765     case 0:
 766       // This must only be called from Reflection.getCallerClass
 767       if (m-&gt;intrinsic_id() != vmIntrinsics::_getCallerClass) {
 768         THROW_MSG_NULL(vmSymbols::java_lang_InternalError(), &quot;JVM_GetCallerClass must only be called from Reflection.getCallerClass&quot;);
 769       }
 770       // fall-through
 771     case 1:
 772       // Frame 0 and 1 must be caller sensitive.
 773       if (!m-&gt;caller_sensitive()) {
 774         THROW_MSG_NULL(vmSymbols::java_lang_InternalError(), err_msg(&quot;CallerSensitive annotation expected at frame %d&quot;, n));
 775       }
 776       break;
 777     default:
 778       if (!m-&gt;is_ignored_by_security_stack_walk()) {
 779         // We have reached the desired frame; return the holder class.
 780         return (jclass) JNIHandles::make_local(env, m-&gt;method_holder()-&gt;java_mirror());
 781       }
 782       break;
 783     }
 784   }
 785   return NULL;
 786 JVM_END
 787 
 788 
 789 JVM_ENTRY(jclass, JVM_FindPrimitiveClass(JNIEnv* env, const char* utf))
 790   JVMWrapper(&quot;JVM_FindPrimitiveClass&quot;);
 791   oop mirror = NULL;
 792   BasicType t = name2type(utf);
 793   if (t != T_ILLEGAL &amp;&amp; !is_reference_type(t)) {
 794     mirror = Universe::java_mirror(t);
 795   }
 796   if (mirror == NULL) {
 797     THROW_MSG_0(vmSymbols::java_lang_ClassNotFoundException(), (char*) utf);
 798   } else {
 799     return (jclass) JNIHandles::make_local(env, mirror);
 800   }
 801 JVM_END
 802 
 803 
 804 // Returns a class loaded by the bootstrap class loader; or null
 805 // if not found.  ClassNotFoundException is not thrown.
 806 // FindClassFromBootLoader is exported to the launcher for windows.
 807 JVM_ENTRY(jclass, JVM_FindClassFromBootLoader(JNIEnv* env,
 808                                               const char* name))
 809   JVMWrapper(&quot;JVM_FindClassFromBootLoader&quot;);
 810 
 811   // Java libraries should ensure that name is never null...
 812   if (name == NULL || (int)strlen(name) &gt; Symbol::max_length()) {
 813     // It&#39;s impossible to create this class;  the name cannot fit
 814     // into the constant pool.
 815     return NULL;
 816   }
 817 
 818   TempNewSymbol h_name = SymbolTable::new_symbol(name);
 819   Klass* k = SystemDictionary::resolve_or_null(h_name, CHECK_NULL);
 820   if (k == NULL) {
 821     return NULL;
 822   }
 823 
 824   if (log_is_enabled(Debug, class, resolve)) {
 825     trace_class_resolution(k);
 826   }
 827   return (jclass) JNIHandles::make_local(env, k-&gt;java_mirror());
 828 JVM_END
 829 
 830 // Find a class with this name in this loader, using the caller&#39;s protection domain.
 831 JVM_ENTRY(jclass, JVM_FindClassFromCaller(JNIEnv* env, const char* name,
 832                                           jboolean init, jobject loader,
 833                                           jclass caller))
 834   JVMWrapper(&quot;JVM_FindClassFromCaller throws ClassNotFoundException&quot;);
 835   // Java libraries should ensure that name is never null...
 836   if (name == NULL || (int)strlen(name) &gt; Symbol::max_length()) {
 837     // It&#39;s impossible to create this class;  the name cannot fit
 838     // into the constant pool.
 839     THROW_MSG_0(vmSymbols::java_lang_ClassNotFoundException(), name);
 840   }
 841 
 842   TempNewSymbol h_name = SymbolTable::new_symbol(name);
 843 
 844   oop loader_oop = JNIHandles::resolve(loader);
 845   oop from_class = JNIHandles::resolve(caller);
 846   oop protection_domain = NULL;
 847   // If loader is null, shouldn&#39;t call ClassLoader.checkPackageAccess; otherwise get
 848   // NPE. Put it in another way, the bootstrap class loader has all permission and
 849   // thus no checkPackageAccess equivalence in the VM class loader.
 850   // The caller is also passed as NULL by the java code if there is no security
 851   // manager to avoid the performance cost of getting the calling class.
 852   if (from_class != NULL &amp;&amp; loader_oop != NULL) {
 853     protection_domain = java_lang_Class::as_Klass(from_class)-&gt;protection_domain();
 854   }
 855 
 856   Handle h_loader(THREAD, loader_oop);
 857   Handle h_prot(THREAD, protection_domain);
 858   jclass result = find_class_from_class_loader(env, h_name, init, h_loader,
 859                                                h_prot, false, THREAD);
 860 
 861   if (log_is_enabled(Debug, class, resolve) &amp;&amp; result != NULL) {
 862     trace_class_resolution(java_lang_Class::as_Klass(JNIHandles::resolve_non_null(result)));
 863   }
 864   return result;
 865 JVM_END
 866 
 867 // Currently only called from the old verifier.
 868 JVM_ENTRY(jclass, JVM_FindClassFromClass(JNIEnv *env, const char *name,
 869                                          jboolean init, jclass from))
 870   JVMWrapper(&quot;JVM_FindClassFromClass&quot;);
 871   if (name == NULL) {
 872     THROW_MSG_0(vmSymbols::java_lang_NoClassDefFoundError(), &quot;No class name given&quot;);
 873   }
 874   if ((int)strlen(name) &gt; Symbol::max_length()) {
 875     // It&#39;s impossible to create this class;  the name cannot fit
 876     // into the constant pool.
 877     Exceptions::fthrow(THREAD_AND_LOCATION,
 878                        vmSymbols::java_lang_NoClassDefFoundError(),
 879                        &quot;Class name exceeds maximum length of %d: %s&quot;,
 880                        Symbol::max_length(),
 881                        name);
 882     return 0;
 883   }
 884   TempNewSymbol h_name = SymbolTable::new_symbol(name);
 885   oop from_class_oop = JNIHandles::resolve(from);
 886   Klass* from_class = (from_class_oop == NULL)
 887                            ? (Klass*)NULL
 888                            : java_lang_Class::as_Klass(from_class_oop);
 889   oop class_loader = NULL;
 890   oop protection_domain = NULL;
 891   if (from_class != NULL) {
 892     class_loader = from_class-&gt;class_loader();
 893     protection_domain = from_class-&gt;protection_domain();
 894   }
 895   Handle h_loader(THREAD, class_loader);
 896   Handle h_prot  (THREAD, protection_domain);
 897   jclass result = find_class_from_class_loader(env, h_name, init, h_loader,
 898                                                h_prot, true, thread);
 899 
 900   if (log_is_enabled(Debug, class, resolve) &amp;&amp; result != NULL) {
 901     // this function is generally only used for class loading during verification.
 902     ResourceMark rm;
 903     oop from_mirror = JNIHandles::resolve_non_null(from);
 904     Klass* from_class = java_lang_Class::as_Klass(from_mirror);
 905     const char * from_name = from_class-&gt;external_name();
 906 
 907     oop mirror = JNIHandles::resolve_non_null(result);
 908     Klass* to_class = java_lang_Class::as_Klass(mirror);
 909     const char * to = to_class-&gt;external_name();
 910     log_debug(class, resolve)(&quot;%s %s (verification)&quot;, from_name, to);
 911   }
 912 
 913   return result;
 914 JVM_END
 915 
 916 static void is_lock_held_by_thread(Handle loader, PerfCounter* counter, TRAPS) {
 917   if (loader.is_null()) {
 918     return;
 919   }
 920 
 921   // check whether the current caller thread holds the lock or not.
 922   // If not, increment the corresponding counter
 923   if (ObjectSynchronizer::query_lock_ownership((JavaThread*)THREAD, loader) !=
 924       ObjectSynchronizer::owner_self) {
 925     counter-&gt;inc();
 926   }
 927 }
 928 
 929 // common code for JVM_DefineClass() and JVM_DefineClassWithSource()
 930 static jclass jvm_define_class_common(JNIEnv *env, const char *name,
 931                                       jobject loader, const jbyte *buf,
 932                                       jsize len, jobject pd, const char *source,
 933                                       TRAPS) {
 934   if (source == NULL)  source = &quot;__JVM_DefineClass__&quot;;
 935 
 936   assert(THREAD-&gt;is_Java_thread(), &quot;must be a JavaThread&quot;);
 937   JavaThread* jt = (JavaThread*) THREAD;
 938 
 939   PerfClassTraceTime vmtimer(ClassLoader::perf_define_appclass_time(),
 940                              ClassLoader::perf_define_appclass_selftime(),
 941                              ClassLoader::perf_define_appclasses(),
 942                              jt-&gt;get_thread_stat()-&gt;perf_recursion_counts_addr(),
 943                              jt-&gt;get_thread_stat()-&gt;perf_timers_addr(),
 944                              PerfClassTraceTime::DEFINE_CLASS);
 945 
 946   if (UsePerfData) {
 947     ClassLoader::perf_app_classfile_bytes_read()-&gt;inc(len);
 948   }
 949 
 950   // Since exceptions can be thrown, class initialization can take place
 951   // if name is NULL no check for class name in .class stream has to be made.
 952   TempNewSymbol class_name = NULL;
 953   if (name != NULL) {
 954     const int str_len = (int)strlen(name);
 955     if (str_len &gt; Symbol::max_length()) {
 956       // It&#39;s impossible to create this class;  the name cannot fit
 957       // into the constant pool.
 958       Exceptions::fthrow(THREAD_AND_LOCATION,
 959                          vmSymbols::java_lang_NoClassDefFoundError(),
 960                          &quot;Class name exceeds maximum length of %d: %s&quot;,
 961                          Symbol::max_length(),
 962                          name);
 963       return 0;
 964     }
 965     class_name = SymbolTable::new_symbol(name, str_len);
 966   }
 967 
 968   ResourceMark rm(THREAD);
 969   ClassFileStream st((u1*)buf, len, source, ClassFileStream::verify);
 970   Handle class_loader (THREAD, JNIHandles::resolve(loader));
 971   if (UsePerfData) {
 972     is_lock_held_by_thread(class_loader,
 973                            ClassLoader::sync_JVMDefineClassLockFreeCounter(),
 974                            THREAD);
 975   }
 976   Handle protection_domain (THREAD, JNIHandles::resolve(pd));
 977   Klass* k = SystemDictionary::resolve_from_stream(class_name,
 978                                                    class_loader,
 979                                                    protection_domain,
 980                                                    &amp;st,
 981                                                    CHECK_NULL);
 982 
 983   if (log_is_enabled(Debug, class, resolve) &amp;&amp; k != NULL) {
 984     trace_class_resolution(k);
 985   }
 986 
 987   return (jclass) JNIHandles::make_local(env, k-&gt;java_mirror());
 988 }
 989 
 990 
 991 JVM_ENTRY(jclass, JVM_DefineClass(JNIEnv *env, const char *name, jobject loader, const jbyte *buf, jsize len, jobject pd))
 992   JVMWrapper(&quot;JVM_DefineClass&quot;);
 993 
 994   return jvm_define_class_common(env, name, loader, buf, len, pd, NULL, THREAD);
 995 JVM_END
 996 
 997 
 998 JVM_ENTRY(jclass, JVM_DefineClassWithSource(JNIEnv *env, const char *name, jobject loader, const jbyte *buf, jsize len, jobject pd, const char *source))
 999   JVMWrapper(&quot;JVM_DefineClassWithSource&quot;);
1000 
1001   return jvm_define_class_common(env, name, loader, buf, len, pd, source, THREAD);
1002 JVM_END
1003 
1004 JVM_ENTRY(jclass, JVM_FindLoadedClass(JNIEnv *env, jobject loader, jstring name))
1005   JVMWrapper(&quot;JVM_FindLoadedClass&quot;);
1006   ResourceMark rm(THREAD);
1007 
1008   Handle h_name (THREAD, JNIHandles::resolve_non_null(name));
1009   char* str = java_lang_String::as_utf8_string(h_name());
1010 
1011   // Sanity check, don&#39;t expect null
1012   if (str == NULL) return NULL;
1013 
1014   // Internalize the string, converting &#39;.&#39; to &#39;/&#39; in string.
1015   char* p = (char*)str;
1016   while (*p != &#39;\0&#39;) {
1017       if (*p == &#39;.&#39;) {
1018           *p = &#39;/&#39;;
1019       }
1020       p++;
1021   }
1022 
1023   const int str_len = (int)(p - str);
1024   if (str_len &gt; Symbol::max_length()) {
1025     // It&#39;s impossible to create this class;  the name cannot fit
1026     // into the constant pool.
1027     return NULL;
1028   }
1029   TempNewSymbol klass_name = SymbolTable::new_symbol(str, str_len);
1030 
1031   // Security Note:
1032   //   The Java level wrapper will perform the necessary security check allowing
1033   //   us to pass the NULL as the initiating class loader.
1034   Handle h_loader(THREAD, JNIHandles::resolve(loader));
1035   if (UsePerfData) {
1036     is_lock_held_by_thread(h_loader,
1037                            ClassLoader::sync_JVMFindLoadedClassLockFreeCounter(),
1038                            THREAD);
1039   }
1040 
1041   Klass* k = SystemDictionary::find_instance_or_array_klass(klass_name,
1042                                                               h_loader,
1043                                                               Handle(),
1044                                                               CHECK_NULL);
1045 #if INCLUDE_CDS
1046   if (k == NULL) {
1047     // If the class is not already loaded, try to see if it&#39;s in the shared
1048     // archive for the current classloader (h_loader).
1049     k = SystemDictionaryShared::find_or_load_shared_class(klass_name, h_loader, CHECK_NULL);
1050   }
1051 #endif
1052   return (k == NULL) ? NULL :
1053             (jclass) JNIHandles::make_local(env, k-&gt;java_mirror());
1054 JVM_END
1055 
1056 // Module support //////////////////////////////////////////////////////////////////////////////
1057 
1058 JVM_ENTRY(void, JVM_DefineModule(JNIEnv *env, jobject module, jboolean is_open, jstring version,
1059                                  jstring location, const char* const* packages, jsize num_packages))
1060   JVMWrapper(&quot;JVM_DefineModule&quot;);
1061   Modules::define_module(module, is_open, version, location, packages, num_packages, CHECK);
1062 JVM_END
1063 
1064 JVM_ENTRY(void, JVM_SetBootLoaderUnnamedModule(JNIEnv *env, jobject module))
1065   JVMWrapper(&quot;JVM_SetBootLoaderUnnamedModule&quot;);
1066   Modules::set_bootloader_unnamed_module(module, CHECK);
1067 JVM_END
1068 
1069 JVM_ENTRY(void, JVM_AddModuleExports(JNIEnv *env, jobject from_module, const char* package, jobject to_module))
1070   JVMWrapper(&quot;JVM_AddModuleExports&quot;);
1071   Modules::add_module_exports_qualified(from_module, package, to_module, CHECK);
1072 JVM_END
1073 
1074 JVM_ENTRY(void, JVM_AddModuleExportsToAllUnnamed(JNIEnv *env, jobject from_module, const char* package))
1075   JVMWrapper(&quot;JVM_AddModuleExportsToAllUnnamed&quot;);
1076   Modules::add_module_exports_to_all_unnamed(from_module, package, CHECK);
1077 JVM_END
1078 
1079 JVM_ENTRY(void, JVM_AddModuleExportsToAll(JNIEnv *env, jobject from_module, const char* package))
1080   JVMWrapper(&quot;JVM_AddModuleExportsToAll&quot;);
1081   Modules::add_module_exports(from_module, package, NULL, CHECK);
1082 JVM_END
1083 
1084 JVM_ENTRY (void, JVM_AddReadsModule(JNIEnv *env, jobject from_module, jobject source_module))
1085   JVMWrapper(&quot;JVM_AddReadsModule&quot;);
1086   Modules::add_reads_module(from_module, source_module, CHECK);
1087 JVM_END
1088 
1089 // Reflection support //////////////////////////////////////////////////////////////////////////////
1090 
1091 JVM_ENTRY(jstring, JVM_InitClassName(JNIEnv *env, jclass cls))
1092   assert (cls != NULL, &quot;illegal class&quot;);
1093   JVMWrapper(&quot;JVM_InitClassName&quot;);
1094   JvmtiVMObjectAllocEventCollector oam;
1095   ResourceMark rm(THREAD);
1096   HandleMark hm(THREAD);
1097   Handle java_class(THREAD, JNIHandles::resolve(cls));
1098   oop result = java_lang_Class::name(java_class, CHECK_NULL);
1099   return (jstring) JNIHandles::make_local(env, result);
1100 JVM_END
1101 
1102 
1103 JVM_ENTRY(jobjectArray, JVM_GetClassInterfaces(JNIEnv *env, jclass cls))
1104   JVMWrapper(&quot;JVM_GetClassInterfaces&quot;);
1105   JvmtiVMObjectAllocEventCollector oam;
1106   oop mirror = JNIHandles::resolve_non_null(cls);
1107 
1108   // Special handling for primitive objects
1109   if (java_lang_Class::is_primitive(mirror)) {
1110     // Primitive objects does not have any interfaces
1111     objArrayOop r = oopFactory::new_objArray(SystemDictionary::Class_klass(), 0, CHECK_NULL);
1112     return (jobjectArray) JNIHandles::make_local(env, r);
1113   }
1114 
1115   Klass* klass = java_lang_Class::as_Klass(mirror);
1116   // Figure size of result array
1117   int size;
1118   if (klass-&gt;is_instance_klass()) {
1119     size = InstanceKlass::cast(klass)-&gt;local_interfaces()-&gt;length();
1120   } else {
1121     assert(klass-&gt;is_objArray_klass() || klass-&gt;is_typeArray_klass(), &quot;Illegal mirror klass&quot;);
1122     size = 2;
1123   }
1124 
1125   // Allocate result array
1126   objArrayOop r = oopFactory::new_objArray(SystemDictionary::Class_klass(), size, CHECK_NULL);
1127   objArrayHandle result (THREAD, r);
1128   // Fill in result
1129   if (klass-&gt;is_instance_klass()) {
1130     // Regular instance klass, fill in all local interfaces
1131     for (int index = 0; index &lt; size; index++) {
1132       Klass* k = InstanceKlass::cast(klass)-&gt;local_interfaces()-&gt;at(index);
1133       result-&gt;obj_at_put(index, k-&gt;java_mirror());
1134     }
1135   } else {
1136     // All arrays implement java.lang.Cloneable and java.io.Serializable
1137     result-&gt;obj_at_put(0, SystemDictionary::Cloneable_klass()-&gt;java_mirror());
1138     result-&gt;obj_at_put(1, SystemDictionary::Serializable_klass()-&gt;java_mirror());
1139   }
1140   return (jobjectArray) JNIHandles::make_local(env, result());
1141 JVM_END
1142 
1143 
1144 JVM_ENTRY(jboolean, JVM_IsInterface(JNIEnv *env, jclass cls))
1145   JVMWrapper(&quot;JVM_IsInterface&quot;);
1146   oop mirror = JNIHandles::resolve_non_null(cls);
1147   if (java_lang_Class::is_primitive(mirror)) {
1148     return JNI_FALSE;
1149   }
1150   Klass* k = java_lang_Class::as_Klass(mirror);
1151   jboolean result = k-&gt;is_interface();
1152   assert(!result || k-&gt;is_instance_klass(),
1153          &quot;all interfaces are instance types&quot;);
1154   // The compiler intrinsic for isInterface tests the
1155   // Klass::_access_flags bits in the same way.
1156   return result;
1157 JVM_END
1158 
1159 
1160 JVM_ENTRY(jobjectArray, JVM_GetClassSigners(JNIEnv *env, jclass cls))
1161   JVMWrapper(&quot;JVM_GetClassSigners&quot;);
1162   JvmtiVMObjectAllocEventCollector oam;
1163   if (java_lang_Class::is_primitive(JNIHandles::resolve_non_null(cls))) {
1164     // There are no signers for primitive types
1165     return NULL;
1166   }
1167 
1168   objArrayHandle signers(THREAD, java_lang_Class::signers(JNIHandles::resolve_non_null(cls)));
1169 
1170   // If there are no signers set in the class, or if the class
1171   // is an array, return NULL.
1172   if (signers == NULL) return NULL;
1173 
1174   // copy of the signers array
1175   Klass* element = ObjArrayKlass::cast(signers-&gt;klass())-&gt;element_klass();
1176   objArrayOop signers_copy = oopFactory::new_objArray(element, signers-&gt;length(), CHECK_NULL);
1177   for (int index = 0; index &lt; signers-&gt;length(); index++) {
1178     signers_copy-&gt;obj_at_put(index, signers-&gt;obj_at(index));
1179   }
1180 
1181   // return the copy
1182   return (jobjectArray) JNIHandles::make_local(env, signers_copy);
1183 JVM_END
1184 
1185 
1186 JVM_ENTRY(void, JVM_SetClassSigners(JNIEnv *env, jclass cls, jobjectArray signers))
1187   JVMWrapper(&quot;JVM_SetClassSigners&quot;);
1188   if (!java_lang_Class::is_primitive(JNIHandles::resolve_non_null(cls))) {
1189     // This call is ignored for primitive types and arrays.
1190     // Signers are only set once, ClassLoader.java, and thus shouldn&#39;t
1191     // be called with an array.  Only the bootstrap loader creates arrays.
1192     Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(cls));
1193     if (k-&gt;is_instance_klass()) {
1194       java_lang_Class::set_signers(k-&gt;java_mirror(), objArrayOop(JNIHandles::resolve(signers)));
1195     }
1196   }
1197 JVM_END
1198 
1199 
1200 JVM_ENTRY(jobject, JVM_GetProtectionDomain(JNIEnv *env, jclass cls))
1201   JVMWrapper(&quot;JVM_GetProtectionDomain&quot;);
1202   if (JNIHandles::resolve(cls) == NULL) {
1203     THROW_(vmSymbols::java_lang_NullPointerException(), NULL);
1204   }
1205 
1206   if (java_lang_Class::is_primitive(JNIHandles::resolve(cls))) {
1207     // Primitive types does not have a protection domain.
1208     return NULL;
1209   }
1210 
1211   oop pd = java_lang_Class::protection_domain(JNIHandles::resolve(cls));
1212   return (jobject) JNIHandles::make_local(env, pd);
1213 JVM_END
1214 
1215 
1216 // Returns the inherited_access_control_context field of the running thread.
1217 JVM_ENTRY(jobject, JVM_GetInheritedAccessControlContext(JNIEnv *env, jclass cls))
1218   JVMWrapper(&quot;JVM_GetInheritedAccessControlContext&quot;);
1219   oop result = java_lang_Thread::inherited_access_control_context(thread-&gt;threadObj());
1220   return JNIHandles::make_local(env, result);
1221 JVM_END
1222 
1223 class RegisterArrayForGC {
1224  private:
1225   JavaThread *_thread;
1226  public:
1227   RegisterArrayForGC(JavaThread *thread, GrowableArray&lt;oop&gt;* array)  {
1228     _thread = thread;
1229     _thread-&gt;register_array_for_gc(array);
1230   }
1231 
1232   ~RegisterArrayForGC() {
1233     _thread-&gt;register_array_for_gc(NULL);
1234   }
1235 };
1236 
1237 
1238 JVM_ENTRY(jobject, JVM_GetStackAccessControlContext(JNIEnv *env, jclass cls))
1239   JVMWrapper(&quot;JVM_GetStackAccessControlContext&quot;);
1240   if (!UsePrivilegedStack) return NULL;
1241 
1242   ResourceMark rm(THREAD);
1243   GrowableArray&lt;oop&gt;* local_array = new GrowableArray&lt;oop&gt;(12);
1244   JvmtiVMObjectAllocEventCollector oam;
1245 
1246   // count the protection domains on the execution stack. We collapse
1247   // duplicate consecutive protection domains into a single one, as
1248   // well as stopping when we hit a privileged frame.
1249 
1250   oop previous_protection_domain = NULL;
1251   Handle privileged_context(thread, NULL);
1252   bool is_privileged = false;
1253   oop protection_domain = NULL;
1254 
1255   // Iterate through Java frames
1256   vframeStream vfst(thread);
1257   for(; !vfst.at_end(); vfst.next()) {
1258     // get method of frame
1259     Method* method = vfst.method();
1260 
1261     // stop at the first privileged frame
1262     if (method-&gt;method_holder() == SystemDictionary::AccessController_klass() &amp;&amp;
1263       method-&gt;name() == vmSymbols::executePrivileged_name())
1264     {
1265       // this frame is privileged
1266       is_privileged = true;
1267 
1268       javaVFrame *priv = vfst.asJavaVFrame();       // executePrivileged
1269 
1270       StackValueCollection* locals = priv-&gt;locals();
1271       StackValue* ctx_sv = locals-&gt;at(1); // AccessControlContext context
1272       StackValue* clr_sv = locals-&gt;at(2); // Class&lt;?&gt; caller
1273       assert(!ctx_sv-&gt;obj_is_scalar_replaced(), &quot;found scalar-replaced object&quot;);
1274       assert(!clr_sv-&gt;obj_is_scalar_replaced(), &quot;found scalar-replaced object&quot;);
1275       privileged_context    = ctx_sv-&gt;get_obj();
1276       Handle caller         = clr_sv-&gt;get_obj();
1277 
1278       Klass *caller_klass = java_lang_Class::as_Klass(caller());
1279       protection_domain  = caller_klass-&gt;protection_domain();
1280     } else {
1281       protection_domain = method-&gt;method_holder()-&gt;protection_domain();
1282     }
1283 
1284     if ((previous_protection_domain != protection_domain) &amp;&amp; (protection_domain != NULL)) {
1285       local_array-&gt;push(protection_domain);
1286       previous_protection_domain = protection_domain;
1287     }
1288 
1289     if (is_privileged) break;
1290   }
1291 
1292 
1293   // either all the domains on the stack were system domains, or
1294   // we had a privileged system domain
1295   if (local_array-&gt;is_empty()) {
1296     if (is_privileged &amp;&amp; privileged_context.is_null()) return NULL;
1297 
1298     oop result = java_security_AccessControlContext::create(objArrayHandle(), is_privileged, privileged_context, CHECK_NULL);
1299     return JNIHandles::make_local(env, result);
1300   }
1301 
1302   // the resource area must be registered in case of a gc
1303   RegisterArrayForGC ragc(thread, local_array);
1304   objArrayOop context = oopFactory::new_objArray(SystemDictionary::ProtectionDomain_klass(),
1305                                                  local_array-&gt;length(), CHECK_NULL);
1306   objArrayHandle h_context(thread, context);
1307   for (int index = 0; index &lt; local_array-&gt;length(); index++) {
1308     h_context-&gt;obj_at_put(index, local_array-&gt;at(index));
1309   }
1310 
1311   oop result = java_security_AccessControlContext::create(h_context, is_privileged, privileged_context, CHECK_NULL);
1312 
1313   return JNIHandles::make_local(env, result);
1314 JVM_END
1315 
1316 
1317 JVM_ENTRY(jboolean, JVM_IsArrayClass(JNIEnv *env, jclass cls))
1318   JVMWrapper(&quot;JVM_IsArrayClass&quot;);
1319   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(cls));
1320   return (k != NULL) &amp;&amp; k-&gt;is_array_klass() ? true : false;
1321 JVM_END
1322 
1323 
1324 JVM_ENTRY(jboolean, JVM_IsPrimitiveClass(JNIEnv *env, jclass cls))
1325   JVMWrapper(&quot;JVM_IsPrimitiveClass&quot;);
1326   oop mirror = JNIHandles::resolve_non_null(cls);
1327   return (jboolean) java_lang_Class::is_primitive(mirror);
1328 JVM_END
1329 
1330 
1331 JVM_ENTRY(jint, JVM_GetClassModifiers(JNIEnv *env, jclass cls))
1332   JVMWrapper(&quot;JVM_GetClassModifiers&quot;);
1333   if (java_lang_Class::is_primitive(JNIHandles::resolve_non_null(cls))) {
1334     // Primitive type
1335     return JVM_ACC_ABSTRACT | JVM_ACC_FINAL | JVM_ACC_PUBLIC;
1336   }
1337 
1338   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(cls));
1339   debug_only(int computed_modifiers = k-&gt;compute_modifier_flags(CHECK_0));
1340   assert(k-&gt;modifier_flags() == computed_modifiers, &quot;modifiers cache is OK&quot;);
1341   return k-&gt;modifier_flags();
1342 JVM_END
1343 
1344 
1345 // Inner class reflection ///////////////////////////////////////////////////////////////////////////////
1346 
1347 JVM_ENTRY(jobjectArray, JVM_GetDeclaredClasses(JNIEnv *env, jclass ofClass))
1348   JvmtiVMObjectAllocEventCollector oam;
1349   // ofClass is a reference to a java_lang_Class object. The mirror object
1350   // of an InstanceKlass
1351 
1352   if (java_lang_Class::is_primitive(JNIHandles::resolve_non_null(ofClass)) ||
1353       ! java_lang_Class::as_Klass(JNIHandles::resolve_non_null(ofClass))-&gt;is_instance_klass()) {
1354     oop result = oopFactory::new_objArray(SystemDictionary::Class_klass(), 0, CHECK_NULL);
1355     return (jobjectArray)JNIHandles::make_local(env, result);
1356   }
1357 
1358   InstanceKlass* k = InstanceKlass::cast(java_lang_Class::as_Klass(JNIHandles::resolve_non_null(ofClass)));
1359   InnerClassesIterator iter(k);
1360 
1361   if (iter.length() == 0) {
1362     // Neither an inner nor outer class
1363     oop result = oopFactory::new_objArray(SystemDictionary::Class_klass(), 0, CHECK_NULL);
1364     return (jobjectArray)JNIHandles::make_local(env, result);
1365   }
1366 
1367   // find inner class info
1368   constantPoolHandle cp(thread, k-&gt;constants());
1369   int length = iter.length();
1370 
1371   // Allocate temp. result array
1372   objArrayOop r = oopFactory::new_objArray(SystemDictionary::Class_klass(), length/4, CHECK_NULL);
1373   objArrayHandle result (THREAD, r);
1374   int members = 0;
1375 
1376   for (; !iter.done(); iter.next()) {
1377     int ioff = iter.inner_class_info_index();
1378     int ooff = iter.outer_class_info_index();
1379 
1380     if (ioff != 0 &amp;&amp; ooff != 0) {
1381       // Check to see if the name matches the class we&#39;re looking for
1382       // before attempting to find the class.
1383       if (cp-&gt;klass_name_at_matches(k, ooff)) {
1384         Klass* outer_klass = cp-&gt;klass_at(ooff, CHECK_NULL);
1385         if (outer_klass == k) {
1386            Klass* ik = cp-&gt;klass_at(ioff, CHECK_NULL);
1387            InstanceKlass* inner_klass = InstanceKlass::cast(ik);
1388 
1389            // Throws an exception if outer klass has not declared k as
1390            // an inner klass
1391            Reflection::check_for_inner_class(k, inner_klass, true, CHECK_NULL);
1392 
1393            result-&gt;obj_at_put(members, inner_klass-&gt;java_mirror());
1394            members++;
1395         }
1396       }
1397     }
1398   }
1399 
1400   if (members != length) {
1401     // Return array of right length
1402     objArrayOop res = oopFactory::new_objArray(SystemDictionary::Class_klass(), members, CHECK_NULL);
1403     for(int i = 0; i &lt; members; i++) {
1404       res-&gt;obj_at_put(i, result-&gt;obj_at(i));
1405     }
1406     return (jobjectArray)JNIHandles::make_local(env, res);
1407   }
1408 
1409   return (jobjectArray)JNIHandles::make_local(env, result());
1410 JVM_END
1411 
1412 
1413 JVM_ENTRY(jclass, JVM_GetDeclaringClass(JNIEnv *env, jclass ofClass))
1414 {
1415   // ofClass is a reference to a java_lang_Class object.
1416   if (java_lang_Class::is_primitive(JNIHandles::resolve_non_null(ofClass)) ||
1417       ! java_lang_Class::as_Klass(JNIHandles::resolve_non_null(ofClass))-&gt;is_instance_klass()) {
1418     return NULL;
1419   }
1420 
1421   bool inner_is_member = false;
1422   Klass* outer_klass
1423     = InstanceKlass::cast(java_lang_Class::as_Klass(JNIHandles::resolve_non_null(ofClass))
1424                           )-&gt;compute_enclosing_class(&amp;inner_is_member, CHECK_NULL);
1425   if (outer_klass == NULL)  return NULL;  // already a top-level class
1426   if (!inner_is_member)  return NULL;     // an anonymous class (inside a method)
1427   return (jclass) JNIHandles::make_local(env, outer_klass-&gt;java_mirror());
1428 }
1429 JVM_END
1430 
1431 JVM_ENTRY(jstring, JVM_GetSimpleBinaryName(JNIEnv *env, jclass cls))
1432 {
1433   oop mirror = JNIHandles::resolve_non_null(cls);
1434   if (java_lang_Class::is_primitive(mirror) ||
1435       !java_lang_Class::as_Klass(mirror)-&gt;is_instance_klass()) {
1436     return NULL;
1437   }
1438   InstanceKlass* k = InstanceKlass::cast(java_lang_Class::as_Klass(mirror));
1439   int ooff = 0, noff = 0;
1440   if (k-&gt;find_inner_classes_attr(&amp;ooff, &amp;noff, THREAD)) {
1441     if (noff != 0) {
1442       constantPoolHandle i_cp(thread, k-&gt;constants());
1443       Symbol* name = i_cp-&gt;symbol_at(noff);
1444       Handle str = java_lang_String::create_from_symbol(name, CHECK_NULL);
1445       return (jstring) JNIHandles::make_local(env, str());
1446     }
1447   }
1448   return NULL;
1449 }
1450 JVM_END
1451 
1452 JVM_ENTRY(jstring, JVM_GetClassSignature(JNIEnv *env, jclass cls))
1453   assert (cls != NULL, &quot;illegal class&quot;);
1454   JVMWrapper(&quot;JVM_GetClassSignature&quot;);
1455   JvmtiVMObjectAllocEventCollector oam;
1456   ResourceMark rm(THREAD);
1457   // Return null for arrays and primatives
1458   if (!java_lang_Class::is_primitive(JNIHandles::resolve(cls))) {
1459     Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve(cls));
1460     if (k-&gt;is_instance_klass()) {
1461       Symbol* sym = InstanceKlass::cast(k)-&gt;generic_signature();
1462       if (sym == NULL) return NULL;
1463       Handle str = java_lang_String::create_from_symbol(sym, CHECK_NULL);
1464       return (jstring) JNIHandles::make_local(env, str());
1465     }
1466   }
1467   return NULL;
1468 JVM_END
1469 
1470 
1471 JVM_ENTRY(jbyteArray, JVM_GetClassAnnotations(JNIEnv *env, jclass cls))
1472   assert (cls != NULL, &quot;illegal class&quot;);
1473   JVMWrapper(&quot;JVM_GetClassAnnotations&quot;);
1474 
1475   // Return null for arrays and primitives
1476   if (!java_lang_Class::is_primitive(JNIHandles::resolve(cls))) {
1477     Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve(cls));
1478     if (k-&gt;is_instance_klass()) {
1479       typeArrayOop a = Annotations::make_java_array(InstanceKlass::cast(k)-&gt;class_annotations(), CHECK_NULL);
1480       return (jbyteArray) JNIHandles::make_local(env, a);
1481     }
1482   }
1483   return NULL;
1484 JVM_END
1485 
1486 
1487 static bool jvm_get_field_common(jobject field, fieldDescriptor&amp; fd, TRAPS) {
1488   // some of this code was adapted from from jni_FromReflectedField
1489 
1490   oop reflected = JNIHandles::resolve_non_null(field);
1491   oop mirror    = java_lang_reflect_Field::clazz(reflected);
1492   Klass* k    = java_lang_Class::as_Klass(mirror);
1493   int slot      = java_lang_reflect_Field::slot(reflected);
1494   int modifiers = java_lang_reflect_Field::modifiers(reflected);
1495 
1496   InstanceKlass* ik = InstanceKlass::cast(k);
1497   intptr_t offset = ik-&gt;field_offset(slot);
1498 
1499   if (modifiers &amp; JVM_ACC_STATIC) {
1500     // for static fields we only look in the current class
1501     if (!ik-&gt;find_local_field_from_offset(offset, true, &amp;fd)) {
1502       assert(false, &quot;cannot find static field&quot;);
1503       return false;
1504     }
1505   } else {
1506     // for instance fields we start with the current class and work
1507     // our way up through the superclass chain
1508     if (!ik-&gt;find_field_from_offset(offset, false, &amp;fd)) {
1509       assert(false, &quot;cannot find instance field&quot;);
1510       return false;
1511     }
1512   }
1513   return true;
1514 }
1515 
1516 static Method* jvm_get_method_common(jobject method) {
1517   // some of this code was adapted from from jni_FromReflectedMethod
1518 
1519   oop reflected = JNIHandles::resolve_non_null(method);
1520   oop mirror    = NULL;
1521   int slot      = 0;
1522 
1523   if (reflected-&gt;klass() == SystemDictionary::reflect_Constructor_klass()) {
1524     mirror = java_lang_reflect_Constructor::clazz(reflected);
1525     slot   = java_lang_reflect_Constructor::slot(reflected);
1526   } else {
1527     assert(reflected-&gt;klass() == SystemDictionary::reflect_Method_klass(),
1528            &quot;wrong type&quot;);
1529     mirror = java_lang_reflect_Method::clazz(reflected);
1530     slot   = java_lang_reflect_Method::slot(reflected);
1531   }
1532   Klass* k = java_lang_Class::as_Klass(mirror);
1533 
1534   Method* m = InstanceKlass::cast(k)-&gt;method_with_idnum(slot);
1535   assert(m != NULL, &quot;cannot find method&quot;);
1536   return m;  // caller has to deal with NULL in product mode
1537 }
1538 
1539 /* Type use annotations support (JDK 1.8) */
1540 
1541 JVM_ENTRY(jbyteArray, JVM_GetClassTypeAnnotations(JNIEnv *env, jclass cls))
1542   assert (cls != NULL, &quot;illegal class&quot;);
1543   JVMWrapper(&quot;JVM_GetClassTypeAnnotations&quot;);
1544   ResourceMark rm(THREAD);
1545   // Return null for arrays and primitives
1546   if (!java_lang_Class::is_primitive(JNIHandles::resolve(cls))) {
1547     Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve(cls));
1548     if (k-&gt;is_instance_klass()) {
1549       AnnotationArray* type_annotations = InstanceKlass::cast(k)-&gt;class_type_annotations();
1550       if (type_annotations != NULL) {
1551         typeArrayOop a = Annotations::make_java_array(type_annotations, CHECK_NULL);
1552         return (jbyteArray) JNIHandles::make_local(env, a);
1553       }
1554     }
1555   }
1556   return NULL;
1557 JVM_END
1558 
1559 JVM_ENTRY(jbyteArray, JVM_GetMethodTypeAnnotations(JNIEnv *env, jobject method))
1560   assert (method != NULL, &quot;illegal method&quot;);
1561   JVMWrapper(&quot;JVM_GetMethodTypeAnnotations&quot;);
1562 
1563   // method is a handle to a java.lang.reflect.Method object
1564   Method* m = jvm_get_method_common(method);
1565   if (m == NULL) {
1566     return NULL;
1567   }
1568 
1569   AnnotationArray* type_annotations = m-&gt;type_annotations();
1570   if (type_annotations != NULL) {
1571     typeArrayOop a = Annotations::make_java_array(type_annotations, CHECK_NULL);
1572     return (jbyteArray) JNIHandles::make_local(env, a);
1573   }
1574 
1575   return NULL;
1576 JVM_END
1577 
1578 JVM_ENTRY(jbyteArray, JVM_GetFieldTypeAnnotations(JNIEnv *env, jobject field))
1579   assert (field != NULL, &quot;illegal field&quot;);
1580   JVMWrapper(&quot;JVM_GetFieldTypeAnnotations&quot;);
1581 
1582   fieldDescriptor fd;
1583   bool gotFd = jvm_get_field_common(field, fd, CHECK_NULL);
1584   if (!gotFd) {
1585     return NULL;
1586   }
1587 
1588   return (jbyteArray) JNIHandles::make_local(env, Annotations::make_java_array(fd.type_annotations(), THREAD));
1589 JVM_END
1590 
1591 static void bounds_check(const constantPoolHandle&amp; cp, jint index, TRAPS) {
1592   if (!cp-&gt;is_within_bounds(index)) {
1593     THROW_MSG(vmSymbols::java_lang_IllegalArgumentException(), &quot;Constant pool index out of bounds&quot;);
1594   }
1595 }
1596 
1597 JVM_ENTRY(jobjectArray, JVM_GetMethodParameters(JNIEnv *env, jobject method))
1598 {
1599   JVMWrapper(&quot;JVM_GetMethodParameters&quot;);
1600   // method is a handle to a java.lang.reflect.Method object
1601   Method* method_ptr = jvm_get_method_common(method);
1602   methodHandle mh (THREAD, method_ptr);
1603   Handle reflected_method (THREAD, JNIHandles::resolve_non_null(method));
1604   const int num_params = mh-&gt;method_parameters_length();
1605 
1606   if (num_params &lt; 0) {
1607     // A -1 return value from method_parameters_length means there is no
1608     // parameter data.  Return null to indicate this to the reflection
1609     // API.
1610     assert(num_params == -1, &quot;num_params should be -1 if it is less than zero&quot;);
1611     return (jobjectArray)NULL;
1612   } else {
1613     // Otherwise, we return something up to reflection, even if it is
1614     // a zero-length array.  Why?  Because in some cases this can
1615     // trigger a MalformedParametersException.
1616 
1617     // make sure all the symbols are properly formatted
1618     for (int i = 0; i &lt; num_params; i++) {
1619       MethodParametersElement* params = mh-&gt;method_parameters_start();
1620       int index = params[i].name_cp_index;
1621       constantPoolHandle cp(THREAD, mh-&gt;constants());
1622       bounds_check(cp, index, CHECK_NULL);
1623 
1624       if (0 != index &amp;&amp; !mh-&gt;constants()-&gt;tag_at(index).is_utf8()) {
1625         THROW_MSG_0(vmSymbols::java_lang_IllegalArgumentException(),
1626                     &quot;Wrong type at constant pool index&quot;);
1627       }
1628 
1629     }
1630 
1631     objArrayOop result_oop = oopFactory::new_objArray(SystemDictionary::reflect_Parameter_klass(), num_params, CHECK_NULL);
1632     objArrayHandle result (THREAD, result_oop);
1633 
1634     for (int i = 0; i &lt; num_params; i++) {
1635       MethodParametersElement* params = mh-&gt;method_parameters_start();
1636       // For a 0 index, give a NULL symbol
1637       Symbol* sym = 0 != params[i].name_cp_index ?
1638         mh-&gt;constants()-&gt;symbol_at(params[i].name_cp_index) : NULL;
1639       int flags = params[i].flags;
1640       oop param = Reflection::new_parameter(reflected_method, i, sym,
1641                                             flags, CHECK_NULL);
1642       result-&gt;obj_at_put(i, param);
1643     }
1644     return (jobjectArray)JNIHandles::make_local(env, result());
1645   }
1646 }
1647 JVM_END
1648 
1649 // New (JDK 1.4) reflection implementation /////////////////////////////////////
1650 
1651 JVM_ENTRY(jobjectArray, JVM_GetClassDeclaredFields(JNIEnv *env, jclass ofClass, jboolean publicOnly))
1652 {
1653   JVMWrapper(&quot;JVM_GetClassDeclaredFields&quot;);
1654   JvmtiVMObjectAllocEventCollector oam;
1655 
1656   // Exclude primitive types and array types
1657   if (java_lang_Class::is_primitive(JNIHandles::resolve_non_null(ofClass)) ||
1658       java_lang_Class::as_Klass(JNIHandles::resolve_non_null(ofClass))-&gt;is_array_klass()) {
1659     // Return empty array
1660     oop res = oopFactory::new_objArray(SystemDictionary::reflect_Field_klass(), 0, CHECK_NULL);
1661     return (jobjectArray) JNIHandles::make_local(env, res);
1662   }
1663 
1664   InstanceKlass* k = InstanceKlass::cast(java_lang_Class::as_Klass(JNIHandles::resolve_non_null(ofClass)));
1665   constantPoolHandle cp(THREAD, k-&gt;constants());
1666 
1667   // Ensure class is linked
1668   k-&gt;link_class(CHECK_NULL);
1669 
1670   // Allocate result
1671   int num_fields;
1672 
1673   if (publicOnly) {
1674     num_fields = 0;
1675     for (JavaFieldStream fs(k); !fs.done(); fs.next()) {
1676       if (fs.access_flags().is_public()) ++num_fields;
1677     }
1678   } else {
1679     num_fields = k-&gt;java_fields_count();
1680   }
1681 
1682   objArrayOop r = oopFactory::new_objArray(SystemDictionary::reflect_Field_klass(), num_fields, CHECK_NULL);
1683   objArrayHandle result (THREAD, r);
1684 
1685   int out_idx = 0;
1686   fieldDescriptor fd;
1687   for (JavaFieldStream fs(k); !fs.done(); fs.next()) {
1688     if (!publicOnly || fs.access_flags().is_public()) {
1689       fd.reinitialize(k, fs.index());
1690       oop field = Reflection::new_field(&amp;fd, CHECK_NULL);
1691       result-&gt;obj_at_put(out_idx, field);
1692       ++out_idx;
1693     }
1694   }
1695   assert(out_idx == num_fields, &quot;just checking&quot;);
1696   return (jobjectArray) JNIHandles::make_local(env, result());
1697 }
1698 JVM_END
1699 
1700 JVM_ENTRY(jboolean, JVM_IsRecord(JNIEnv *env, jclass cls))
1701 {
1702   JVMWrapper(&quot;JVM_IsRecord&quot;);
1703   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(cls));
1704   if (k != NULL &amp;&amp; k-&gt;is_instance_klass()) {
1705     InstanceKlass* ik = InstanceKlass::cast(k);
1706     return ik-&gt;is_record();
1707   } else {
1708     return false;
1709   }
1710 }
1711 JVM_END
1712 
1713 JVM_ENTRY(jobjectArray, JVM_GetRecordComponents(JNIEnv* env, jclass ofClass))
1714 {
1715   JVMWrapper(&quot;JVM_GetRecordComponents&quot;);
1716   Klass* c = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(ofClass));
1717   assert(c-&gt;is_instance_klass(), &quot;must be&quot;);
1718   InstanceKlass* ik = InstanceKlass::cast(c);
1719 
1720   if (ik-&gt;is_record()) {
1721     Array&lt;RecordComponent*&gt;* components = ik-&gt;record_components();
1722     assert(components != NULL, &quot;components should not be NULL&quot;);
1723     {
1724       JvmtiVMObjectAllocEventCollector oam;
1725       constantPoolHandle cp(THREAD, ik-&gt;constants());
1726       int length = components-&gt;length();
1727       assert(length &gt;= 0, &quot;unexpected record_components length&quot;);
1728       objArrayOop record_components =
1729         oopFactory::new_objArray(SystemDictionary::RecordComponent_klass(), length, CHECK_NULL);
1730       objArrayHandle components_h (THREAD, record_components);
1731 
1732       for (int x = 0; x &lt; length; x++) {
1733         RecordComponent* component = components-&gt;at(x);
1734         assert(component != NULL, &quot;unexpected NULL record component&quot;);
1735         oop component_oop = java_lang_reflect_RecordComponent::create(ik, component, CHECK_NULL);
1736         components_h-&gt;obj_at_put(x, component_oop);
1737       }
1738       return (jobjectArray)JNIHandles::make_local(components_h());
1739     }
1740   }
1741 
1742   // Return empty array if ofClass is not a record.
1743   objArrayOop result = oopFactory::new_objArray(SystemDictionary::RecordComponent_klass(), 0, CHECK_NULL);
1744   return (jobjectArray)JNIHandles::make_local(env, result);
1745 }
1746 JVM_END
1747 
1748 static bool select_method(const methodHandle&amp; method, bool want_constructor) {
1749   if (want_constructor) {
1750     return (method-&gt;is_initializer() &amp;&amp; !method-&gt;is_static());
1751   } else {
1752     return  (!method-&gt;is_initializer() &amp;&amp; !method-&gt;is_overpass());
1753   }
1754 }
1755 
1756 static jobjectArray get_class_declared_methods_helper(
1757                                   JNIEnv *env,
1758                                   jclass ofClass, jboolean publicOnly,
1759                                   bool want_constructor,
1760                                   Klass* klass, TRAPS) {
1761 
1762   JvmtiVMObjectAllocEventCollector oam;
1763 
1764   // Exclude primitive types and array types
1765   if (java_lang_Class::is_primitive(JNIHandles::resolve_non_null(ofClass))
1766       || java_lang_Class::as_Klass(JNIHandles::resolve_non_null(ofClass))-&gt;is_array_klass()) {
1767     // Return empty array
1768     oop res = oopFactory::new_objArray(klass, 0, CHECK_NULL);
1769     return (jobjectArray) JNIHandles::make_local(env, res);
1770   }
1771 
1772   InstanceKlass* k = InstanceKlass::cast(java_lang_Class::as_Klass(JNIHandles::resolve_non_null(ofClass)));
1773 
1774   // Ensure class is linked
1775   k-&gt;link_class(CHECK_NULL);
1776 
1777   Array&lt;Method*&gt;* methods = k-&gt;methods();
1778   int methods_length = methods-&gt;length();
1779 
1780   // Save original method_idnum in case of redefinition, which can change
1781   // the idnum of obsolete methods.  The new method will have the same idnum
1782   // but if we refresh the methods array, the counts will be wrong.
1783   ResourceMark rm(THREAD);
1784   GrowableArray&lt;int&gt;* idnums = new GrowableArray&lt;int&gt;(methods_length);
1785   int num_methods = 0;
1786 
1787   for (int i = 0; i &lt; methods_length; i++) {
1788     methodHandle method(THREAD, methods-&gt;at(i));
1789     if (select_method(method, want_constructor)) {
1790       if (!publicOnly || method-&gt;is_public()) {
1791         idnums-&gt;push(method-&gt;method_idnum());
1792         ++num_methods;
1793       }
1794     }
1795   }
1796 
1797   // Allocate result
1798   objArrayOop r = oopFactory::new_objArray(klass, num_methods, CHECK_NULL);
1799   objArrayHandle result (THREAD, r);
1800 
1801   // Now just put the methods that we selected above, but go by their idnum
1802   // in case of redefinition.  The methods can be redefined at any safepoint,
1803   // so above when allocating the oop array and below when creating reflect
1804   // objects.
1805   for (int i = 0; i &lt; num_methods; i++) {
1806     methodHandle method(THREAD, k-&gt;method_with_idnum(idnums-&gt;at(i)));
1807     if (method.is_null()) {
1808       // Method may have been deleted and seems this API can handle null
1809       // Otherwise should probably put a method that throws NSME
1810       result-&gt;obj_at_put(i, NULL);
1811     } else {
1812       oop m;
1813       if (want_constructor) {
1814         m = Reflection::new_constructor(method, CHECK_NULL);
1815       } else {
1816         m = Reflection::new_method(method, false, CHECK_NULL);
1817       }
1818       result-&gt;obj_at_put(i, m);
1819     }
1820   }
1821 
1822   return (jobjectArray) JNIHandles::make_local(env, result());
1823 }
1824 
1825 JVM_ENTRY(jobjectArray, JVM_GetClassDeclaredMethods(JNIEnv *env, jclass ofClass, jboolean publicOnly))
1826 {
1827   JVMWrapper(&quot;JVM_GetClassDeclaredMethods&quot;);
1828   return get_class_declared_methods_helper(env, ofClass, publicOnly,
1829                                            /*want_constructor*/ false,
1830                                            SystemDictionary::reflect_Method_klass(), THREAD);
1831 }
1832 JVM_END
1833 
1834 JVM_ENTRY(jobjectArray, JVM_GetClassDeclaredConstructors(JNIEnv *env, jclass ofClass, jboolean publicOnly))
1835 {
1836   JVMWrapper(&quot;JVM_GetClassDeclaredConstructors&quot;);
1837   return get_class_declared_methods_helper(env, ofClass, publicOnly,
1838                                            /*want_constructor*/ true,
1839                                            SystemDictionary::reflect_Constructor_klass(), THREAD);
1840 }
1841 JVM_END
1842 
1843 JVM_ENTRY(jint, JVM_GetClassAccessFlags(JNIEnv *env, jclass cls))
1844 {
1845   JVMWrapper(&quot;JVM_GetClassAccessFlags&quot;);
1846   if (java_lang_Class::is_primitive(JNIHandles::resolve_non_null(cls))) {
1847     // Primitive type
1848     return JVM_ACC_ABSTRACT | JVM_ACC_FINAL | JVM_ACC_PUBLIC;
1849   }
1850 
1851   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(cls));
1852   return k-&gt;access_flags().as_int() &amp; JVM_ACC_WRITTEN_FLAGS;
1853 }
1854 JVM_END
1855 
1856 JVM_ENTRY(jboolean, JVM_AreNestMates(JNIEnv *env, jclass current, jclass member))
1857 {
1858   JVMWrapper(&quot;JVM_AreNestMates&quot;);
1859   Klass* c = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(current));
1860   assert(c-&gt;is_instance_klass(), &quot;must be&quot;);
1861   InstanceKlass* ck = InstanceKlass::cast(c);
1862   Klass* m = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(member));
1863   assert(m-&gt;is_instance_klass(), &quot;must be&quot;);
1864   InstanceKlass* mk = InstanceKlass::cast(m);
1865   return ck-&gt;has_nestmate_access_to(mk, THREAD);
1866 }
1867 JVM_END
1868 
1869 JVM_ENTRY(jclass, JVM_GetNestHost(JNIEnv* env, jclass current))
1870 {
1871   // current is not a primitive or array class
1872   JVMWrapper(&quot;JVM_GetNestHost&quot;);
1873   Klass* c = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(current));
1874   assert(c-&gt;is_instance_klass(), &quot;must be&quot;);
1875   InstanceKlass* ck = InstanceKlass::cast(c);
1876   // Don&#39;t post exceptions if validation fails
1877   InstanceKlass* host = ck-&gt;nest_host(NULL, THREAD);
1878   return (jclass) (host == NULL ? NULL :
1879                    JNIHandles::make_local(THREAD, host-&gt;java_mirror()));
1880 }
1881 JVM_END
1882 
1883 JVM_ENTRY(jobjectArray, JVM_GetNestMembers(JNIEnv* env, jclass current))
1884 {
1885   // current is not a primitive or array class
1886   JVMWrapper(&quot;JVM_GetNestMembers&quot;);
1887   Klass* c = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(current));
1888   assert(c-&gt;is_instance_klass(), &quot;must be&quot;);
1889   InstanceKlass* ck = InstanceKlass::cast(c);
1890   // Get the nest host for this nest - throw ICCE if validation fails
1891   Symbol* icce = vmSymbols::java_lang_IncompatibleClassChangeError();
1892   InstanceKlass* host = ck-&gt;nest_host(icce, CHECK_NULL);
1893 
1894   {
1895     JvmtiVMObjectAllocEventCollector oam;
1896     Array&lt;u2&gt;* members = host-&gt;nest_members();
1897     int length = members == NULL ? 0 : members-&gt;length();
1898     // nest host is first in the array so make it one bigger
1899     objArrayOop r = oopFactory::new_objArray(SystemDictionary::Class_klass(),
1900                                              length + 1, CHECK_NULL);
1901     objArrayHandle result (THREAD, r);
1902     result-&gt;obj_at_put(0, host-&gt;java_mirror());
1903     if (length != 0) {
1904       int i;
1905       for (i = 0; i &lt; length; i++) {
1906          int cp_index = members-&gt;at(i);
1907          Klass* k = host-&gt;constants()-&gt;klass_at(cp_index, CHECK_NULL);
1908          if (k-&gt;is_instance_klass()) {
1909            InstanceKlass* nest_host_k =
1910              InstanceKlass::cast(k)-&gt;nest_host(icce, CHECK_NULL);
1911            if (nest_host_k == host) {
1912              result-&gt;obj_at_put(i+1, k-&gt;java_mirror());
1913            }
1914            else {
1915              // k&#39;s nest host is legal but it isn&#39;t our host so
1916              // throw ICCE
1917              ResourceMark rm(THREAD);
1918              Exceptions::fthrow(THREAD_AND_LOCATION,
1919                                 icce,
1920                                 &quot;Nest member %s in %s declares a different nest host of %s&quot;,
1921                                 k-&gt;external_name(),
1922                                 host-&gt;external_name(),
1923                                 nest_host_k-&gt;external_name()
1924                            );
1925              return NULL;
1926            }
1927          }
1928          else {
1929            // we have a bad nest member entry - throw ICCE
1930            ResourceMark rm(THREAD);
1931            Exceptions::fthrow(THREAD_AND_LOCATION,
1932                               icce,
1933                               &quot;Class %s can not be a nest member of %s&quot;,
1934                               k-&gt;external_name(),
1935                               host-&gt;external_name()
1936                               );
1937            return NULL;
1938          }
1939       }
1940     }
1941     else {
1942       assert(host == ck, &quot;must be singleton nest&quot;);
1943     }
1944     return (jobjectArray)JNIHandles::make_local(THREAD, result());
1945   }
1946 }
1947 JVM_END
1948 
1949 // Constant pool access //////////////////////////////////////////////////////////
1950 
1951 JVM_ENTRY(jobject, JVM_GetClassConstantPool(JNIEnv *env, jclass cls))
1952 {
1953   JVMWrapper(&quot;JVM_GetClassConstantPool&quot;);
1954   JvmtiVMObjectAllocEventCollector oam;
1955 
1956   // Return null for primitives and arrays
1957   if (!java_lang_Class::is_primitive(JNIHandles::resolve_non_null(cls))) {
1958     Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(cls));
1959     if (k-&gt;is_instance_klass()) {
1960       InstanceKlass* k_h = InstanceKlass::cast(k);
1961       Handle jcp = reflect_ConstantPool::create(CHECK_NULL);
1962       reflect_ConstantPool::set_cp(jcp(), k_h-&gt;constants());
1963       return JNIHandles::make_local(jcp());
1964     }
1965   }
1966   return NULL;
1967 }
1968 JVM_END
1969 
1970 
1971 JVM_ENTRY(jint, JVM_ConstantPoolGetSize(JNIEnv *env, jobject obj, jobject unused))
1972 {
1973   JVMWrapper(&quot;JVM_ConstantPoolGetSize&quot;);
1974   constantPoolHandle cp = constantPoolHandle(THREAD, reflect_ConstantPool::get_cp(JNIHandles::resolve_non_null(obj)));
1975   return cp-&gt;length();
1976 }
1977 JVM_END
1978 
1979 
1980 JVM_ENTRY(jclass, JVM_ConstantPoolGetClassAt(JNIEnv *env, jobject obj, jobject unused, jint index))
1981 {
1982   JVMWrapper(&quot;JVM_ConstantPoolGetClassAt&quot;);
1983   constantPoolHandle cp = constantPoolHandle(THREAD, reflect_ConstantPool::get_cp(JNIHandles::resolve_non_null(obj)));
1984   bounds_check(cp, index, CHECK_NULL);
1985   constantTag tag = cp-&gt;tag_at(index);
1986   if (!tag.is_klass() &amp;&amp; !tag.is_unresolved_klass()) {
1987     THROW_MSG_0(vmSymbols::java_lang_IllegalArgumentException(), &quot;Wrong type at constant pool index&quot;);
1988   }
1989   Klass* k = cp-&gt;klass_at(index, CHECK_NULL);
1990   return (jclass) JNIHandles::make_local(k-&gt;java_mirror());
1991 }
1992 JVM_END
1993 
1994 JVM_ENTRY(jclass, JVM_ConstantPoolGetClassAtIfLoaded(JNIEnv *env, jobject obj, jobject unused, jint index))
1995 {
1996   JVMWrapper(&quot;JVM_ConstantPoolGetClassAtIfLoaded&quot;);
1997   constantPoolHandle cp = constantPoolHandle(THREAD, reflect_ConstantPool::get_cp(JNIHandles::resolve_non_null(obj)));
1998   bounds_check(cp, index, CHECK_NULL);
1999   constantTag tag = cp-&gt;tag_at(index);
2000   if (!tag.is_klass() &amp;&amp; !tag.is_unresolved_klass()) {
2001     THROW_MSG_0(vmSymbols::java_lang_IllegalArgumentException(), &quot;Wrong type at constant pool index&quot;);
2002   }
2003   Klass* k = ConstantPool::klass_at_if_loaded(cp, index);
2004   if (k == NULL) return NULL;
2005   return (jclass) JNIHandles::make_local(k-&gt;java_mirror());
2006 }
2007 JVM_END
2008 
2009 static jobject get_method_at_helper(const constantPoolHandle&amp; cp, jint index, bool force_resolution, TRAPS) {
2010   constantTag tag = cp-&gt;tag_at(index);
2011   if (!tag.is_method() &amp;&amp; !tag.is_interface_method()) {
2012     THROW_MSG_0(vmSymbols::java_lang_IllegalArgumentException(), &quot;Wrong type at constant pool index&quot;);
2013   }
2014   int klass_ref  = cp-&gt;uncached_klass_ref_index_at(index);
2015   Klass* k_o;
2016   if (force_resolution) {
2017     k_o = cp-&gt;klass_at(klass_ref, CHECK_NULL);
2018   } else {
2019     k_o = ConstantPool::klass_at_if_loaded(cp, klass_ref);
2020     if (k_o == NULL) return NULL;
2021   }
2022   InstanceKlass* k = InstanceKlass::cast(k_o);
2023   Symbol* name = cp-&gt;uncached_name_ref_at(index);
2024   Symbol* sig  = cp-&gt;uncached_signature_ref_at(index);
2025   methodHandle m (THREAD, k-&gt;find_method(name, sig));
2026   if (m.is_null()) {
2027     THROW_MSG_0(vmSymbols::java_lang_RuntimeException(), &quot;Unable to look up method in target class&quot;);
2028   }
2029   oop method;
2030   if (!m-&gt;is_initializer() || m-&gt;is_static()) {
2031     method = Reflection::new_method(m, true, CHECK_NULL);
2032   } else {
2033     method = Reflection::new_constructor(m, CHECK_NULL);
2034   }
2035   return JNIHandles::make_local(method);
2036 }
2037 
2038 JVM_ENTRY(jobject, JVM_ConstantPoolGetMethodAt(JNIEnv *env, jobject obj, jobject unused, jint index))
2039 {
2040   JVMWrapper(&quot;JVM_ConstantPoolGetMethodAt&quot;);
2041   JvmtiVMObjectAllocEventCollector oam;
2042   constantPoolHandle cp = constantPoolHandle(THREAD, reflect_ConstantPool::get_cp(JNIHandles::resolve_non_null(obj)));
2043   bounds_check(cp, index, CHECK_NULL);
2044   jobject res = get_method_at_helper(cp, index, true, CHECK_NULL);
2045   return res;
2046 }
2047 JVM_END
2048 
2049 JVM_ENTRY(jobject, JVM_ConstantPoolGetMethodAtIfLoaded(JNIEnv *env, jobject obj, jobject unused, jint index))
2050 {
2051   JVMWrapper(&quot;JVM_ConstantPoolGetMethodAtIfLoaded&quot;);
2052   JvmtiVMObjectAllocEventCollector oam;
2053   constantPoolHandle cp = constantPoolHandle(THREAD, reflect_ConstantPool::get_cp(JNIHandles::resolve_non_null(obj)));
2054   bounds_check(cp, index, CHECK_NULL);
2055   jobject res = get_method_at_helper(cp, index, false, CHECK_NULL);
2056   return res;
2057 }
2058 JVM_END
2059 
2060 static jobject get_field_at_helper(constantPoolHandle cp, jint index, bool force_resolution, TRAPS) {
2061   constantTag tag = cp-&gt;tag_at(index);
2062   if (!tag.is_field()) {
2063     THROW_MSG_0(vmSymbols::java_lang_IllegalArgumentException(), &quot;Wrong type at constant pool index&quot;);
2064   }
2065   int klass_ref  = cp-&gt;uncached_klass_ref_index_at(index);
2066   Klass* k_o;
2067   if (force_resolution) {
2068     k_o = cp-&gt;klass_at(klass_ref, CHECK_NULL);
2069   } else {
2070     k_o = ConstantPool::klass_at_if_loaded(cp, klass_ref);
2071     if (k_o == NULL) return NULL;
2072   }
2073   InstanceKlass* k = InstanceKlass::cast(k_o);
2074   Symbol* name = cp-&gt;uncached_name_ref_at(index);
2075   Symbol* sig  = cp-&gt;uncached_signature_ref_at(index);
2076   fieldDescriptor fd;
2077   Klass* target_klass = k-&gt;find_field(name, sig, &amp;fd);
2078   if (target_klass == NULL) {
2079     THROW_MSG_0(vmSymbols::java_lang_RuntimeException(), &quot;Unable to look up field in target class&quot;);
2080   }
2081   oop field = Reflection::new_field(&amp;fd, CHECK_NULL);
2082   return JNIHandles::make_local(field);
2083 }
2084 
2085 JVM_ENTRY(jobject, JVM_ConstantPoolGetFieldAt(JNIEnv *env, jobject obj, jobject unusedl, jint index))
2086 {
2087   JVMWrapper(&quot;JVM_ConstantPoolGetFieldAt&quot;);
2088   JvmtiVMObjectAllocEventCollector oam;
2089   constantPoolHandle cp = constantPoolHandle(THREAD, reflect_ConstantPool::get_cp(JNIHandles::resolve_non_null(obj)));
2090   bounds_check(cp, index, CHECK_NULL);
2091   jobject res = get_field_at_helper(cp, index, true, CHECK_NULL);
2092   return res;
2093 }
2094 JVM_END
2095 
2096 JVM_ENTRY(jobject, JVM_ConstantPoolGetFieldAtIfLoaded(JNIEnv *env, jobject obj, jobject unused, jint index))
2097 {
2098   JVMWrapper(&quot;JVM_ConstantPoolGetFieldAtIfLoaded&quot;);
2099   JvmtiVMObjectAllocEventCollector oam;
2100   constantPoolHandle cp = constantPoolHandle(THREAD, reflect_ConstantPool::get_cp(JNIHandles::resolve_non_null(obj)));
2101   bounds_check(cp, index, CHECK_NULL);
2102   jobject res = get_field_at_helper(cp, index, false, CHECK_NULL);
2103   return res;
2104 }
2105 JVM_END
2106 
2107 JVM_ENTRY(jobjectArray, JVM_ConstantPoolGetMemberRefInfoAt(JNIEnv *env, jobject obj, jobject unused, jint index))
2108 {
2109   JVMWrapper(&quot;JVM_ConstantPoolGetMemberRefInfoAt&quot;);
2110   JvmtiVMObjectAllocEventCollector oam;
2111   constantPoolHandle cp = constantPoolHandle(THREAD, reflect_ConstantPool::get_cp(JNIHandles::resolve_non_null(obj)));
2112   bounds_check(cp, index, CHECK_NULL);
2113   constantTag tag = cp-&gt;tag_at(index);
2114   if (!tag.is_field_or_method()) {
2115     THROW_MSG_0(vmSymbols::java_lang_IllegalArgumentException(), &quot;Wrong type at constant pool index&quot;);
2116   }
2117   int klass_ref = cp-&gt;uncached_klass_ref_index_at(index);
2118   Symbol*  klass_name  = cp-&gt;klass_name_at(klass_ref);
2119   Symbol*  member_name = cp-&gt;uncached_name_ref_at(index);
2120   Symbol*  member_sig  = cp-&gt;uncached_signature_ref_at(index);
2121   objArrayOop  dest_o = oopFactory::new_objArray(SystemDictionary::String_klass(), 3, CHECK_NULL);
2122   objArrayHandle dest(THREAD, dest_o);
2123   Handle str = java_lang_String::create_from_symbol(klass_name, CHECK_NULL);
2124   dest-&gt;obj_at_put(0, str());
2125   str = java_lang_String::create_from_symbol(member_name, CHECK_NULL);
2126   dest-&gt;obj_at_put(1, str());
2127   str = java_lang_String::create_from_symbol(member_sig, CHECK_NULL);
2128   dest-&gt;obj_at_put(2, str());
2129   return (jobjectArray) JNIHandles::make_local(dest());
2130 }
2131 JVM_END
2132 
2133 JVM_ENTRY(jint, JVM_ConstantPoolGetClassRefIndexAt(JNIEnv *env, jobject obj, jobject unused, jint index))
2134 {
2135   JVMWrapper(&quot;JVM_ConstantPoolGetClassRefIndexAt&quot;);
2136   JvmtiVMObjectAllocEventCollector oam;
2137   constantPoolHandle cp(THREAD, reflect_ConstantPool::get_cp(JNIHandles::resolve_non_null(obj)));
2138   bounds_check(cp, index, CHECK_0);
2139   constantTag tag = cp-&gt;tag_at(index);
2140   if (!tag.is_field_or_method()) {
2141     THROW_MSG_0(vmSymbols::java_lang_IllegalArgumentException(), &quot;Wrong type at constant pool index&quot;);
2142   }
2143   return (jint) cp-&gt;uncached_klass_ref_index_at(index);
2144 }
2145 JVM_END
2146 
2147 JVM_ENTRY(jint, JVM_ConstantPoolGetNameAndTypeRefIndexAt(JNIEnv *env, jobject obj, jobject unused, jint index))
2148 {
2149   JVMWrapper(&quot;JVM_ConstantPoolGetNameAndTypeRefIndexAt&quot;);
2150   JvmtiVMObjectAllocEventCollector oam;
2151   constantPoolHandle cp(THREAD, reflect_ConstantPool::get_cp(JNIHandles::resolve_non_null(obj)));
2152   bounds_check(cp, index, CHECK_0);
2153   constantTag tag = cp-&gt;tag_at(index);
2154   if (!tag.is_invoke_dynamic() &amp;&amp; !tag.is_field_or_method()) {
2155     THROW_MSG_0(vmSymbols::java_lang_IllegalArgumentException(), &quot;Wrong type at constant pool index&quot;);
2156   }
2157   return (jint) cp-&gt;uncached_name_and_type_ref_index_at(index);
2158 }
2159 JVM_END
2160 
2161 JVM_ENTRY(jobjectArray, JVM_ConstantPoolGetNameAndTypeRefInfoAt(JNIEnv *env, jobject obj, jobject unused, jint index))
2162 {
2163   JVMWrapper(&quot;JVM_ConstantPoolGetNameAndTypeRefInfoAt&quot;);
2164   JvmtiVMObjectAllocEventCollector oam;
2165   constantPoolHandle cp(THREAD, reflect_ConstantPool::get_cp(JNIHandles::resolve_non_null(obj)));
2166   bounds_check(cp, index, CHECK_NULL);
2167   constantTag tag = cp-&gt;tag_at(index);
2168   if (!tag.is_name_and_type()) {
2169     THROW_MSG_0(vmSymbols::java_lang_IllegalArgumentException(), &quot;Wrong type at constant pool index&quot;);
2170   }
2171   Symbol* member_name = cp-&gt;symbol_at(cp-&gt;name_ref_index_at(index));
2172   Symbol* member_sig = cp-&gt;symbol_at(cp-&gt;signature_ref_index_at(index));
2173   objArrayOop dest_o = oopFactory::new_objArray(SystemDictionary::String_klass(), 2, CHECK_NULL);
2174   objArrayHandle dest(THREAD, dest_o);
2175   Handle str = java_lang_String::create_from_symbol(member_name, CHECK_NULL);
2176   dest-&gt;obj_at_put(0, str());
2177   str = java_lang_String::create_from_symbol(member_sig, CHECK_NULL);
2178   dest-&gt;obj_at_put(1, str());
2179   return (jobjectArray) JNIHandles::make_local(dest());
2180 }
2181 JVM_END
2182 
2183 JVM_ENTRY(jint, JVM_ConstantPoolGetIntAt(JNIEnv *env, jobject obj, jobject unused, jint index))
2184 {
2185   JVMWrapper(&quot;JVM_ConstantPoolGetIntAt&quot;);
2186   constantPoolHandle cp = constantPoolHandle(THREAD, reflect_ConstantPool::get_cp(JNIHandles::resolve_non_null(obj)));
2187   bounds_check(cp, index, CHECK_0);
2188   constantTag tag = cp-&gt;tag_at(index);
2189   if (!tag.is_int()) {
2190     THROW_MSG_0(vmSymbols::java_lang_IllegalArgumentException(), &quot;Wrong type at constant pool index&quot;);
2191   }
2192   return cp-&gt;int_at(index);
2193 }
2194 JVM_END
2195 
2196 JVM_ENTRY(jlong, JVM_ConstantPoolGetLongAt(JNIEnv *env, jobject obj, jobject unused, jint index))
2197 {
2198   JVMWrapper(&quot;JVM_ConstantPoolGetLongAt&quot;);
2199   constantPoolHandle cp = constantPoolHandle(THREAD, reflect_ConstantPool::get_cp(JNIHandles::resolve_non_null(obj)));
2200   bounds_check(cp, index, CHECK_(0L));
2201   constantTag tag = cp-&gt;tag_at(index);
2202   if (!tag.is_long()) {
2203     THROW_MSG_0(vmSymbols::java_lang_IllegalArgumentException(), &quot;Wrong type at constant pool index&quot;);
2204   }
2205   return cp-&gt;long_at(index);
2206 }
2207 JVM_END
2208 
2209 JVM_ENTRY(jfloat, JVM_ConstantPoolGetFloatAt(JNIEnv *env, jobject obj, jobject unused, jint index))
2210 {
2211   JVMWrapper(&quot;JVM_ConstantPoolGetFloatAt&quot;);
2212   constantPoolHandle cp = constantPoolHandle(THREAD, reflect_ConstantPool::get_cp(JNIHandles::resolve_non_null(obj)));
2213   bounds_check(cp, index, CHECK_(0.0f));
2214   constantTag tag = cp-&gt;tag_at(index);
2215   if (!tag.is_float()) {
2216     THROW_MSG_0(vmSymbols::java_lang_IllegalArgumentException(), &quot;Wrong type at constant pool index&quot;);
2217   }
2218   return cp-&gt;float_at(index);
2219 }
2220 JVM_END
2221 
2222 JVM_ENTRY(jdouble, JVM_ConstantPoolGetDoubleAt(JNIEnv *env, jobject obj, jobject unused, jint index))
2223 {
2224   JVMWrapper(&quot;JVM_ConstantPoolGetDoubleAt&quot;);
2225   constantPoolHandle cp = constantPoolHandle(THREAD, reflect_ConstantPool::get_cp(JNIHandles::resolve_non_null(obj)));
2226   bounds_check(cp, index, CHECK_(0.0));
2227   constantTag tag = cp-&gt;tag_at(index);
2228   if (!tag.is_double()) {
2229     THROW_MSG_0(vmSymbols::java_lang_IllegalArgumentException(), &quot;Wrong type at constant pool index&quot;);
2230   }
2231   return cp-&gt;double_at(index);
2232 }
2233 JVM_END
2234 
2235 JVM_ENTRY(jstring, JVM_ConstantPoolGetStringAt(JNIEnv *env, jobject obj, jobject unused, jint index))
2236 {
2237   JVMWrapper(&quot;JVM_ConstantPoolGetStringAt&quot;);
2238   constantPoolHandle cp = constantPoolHandle(THREAD, reflect_ConstantPool::get_cp(JNIHandles::resolve_non_null(obj)));
2239   bounds_check(cp, index, CHECK_NULL);
2240   constantTag tag = cp-&gt;tag_at(index);
2241   if (!tag.is_string()) {
2242     THROW_MSG_0(vmSymbols::java_lang_IllegalArgumentException(), &quot;Wrong type at constant pool index&quot;);
2243   }
2244   oop str = cp-&gt;string_at(index, CHECK_NULL);
2245   return (jstring) JNIHandles::make_local(str);
2246 }
2247 JVM_END
2248 
2249 JVM_ENTRY(jstring, JVM_ConstantPoolGetUTF8At(JNIEnv *env, jobject obj, jobject unused, jint index))
2250 {
2251   JVMWrapper(&quot;JVM_ConstantPoolGetUTF8At&quot;);
2252   JvmtiVMObjectAllocEventCollector oam;
2253   constantPoolHandle cp = constantPoolHandle(THREAD, reflect_ConstantPool::get_cp(JNIHandles::resolve_non_null(obj)));
2254   bounds_check(cp, index, CHECK_NULL);
2255   constantTag tag = cp-&gt;tag_at(index);
2256   if (!tag.is_symbol()) {
2257     THROW_MSG_0(vmSymbols::java_lang_IllegalArgumentException(), &quot;Wrong type at constant pool index&quot;);
2258   }
2259   Symbol* sym = cp-&gt;symbol_at(index);
2260   Handle str = java_lang_String::create_from_symbol(sym, CHECK_NULL);
2261   return (jstring) JNIHandles::make_local(str());
2262 }
2263 JVM_END
2264 
2265 JVM_ENTRY(jbyte, JVM_ConstantPoolGetTagAt(JNIEnv *env, jobject obj, jobject unused, jint index))
2266 {
2267   JVMWrapper(&quot;JVM_ConstantPoolGetTagAt&quot;);
2268   constantPoolHandle cp = constantPoolHandle(THREAD, reflect_ConstantPool::get_cp(JNIHandles::resolve_non_null(obj)));
2269   bounds_check(cp, index, CHECK_0);
2270   constantTag tag = cp-&gt;tag_at(index);
2271   jbyte result = tag.value();
2272   // If returned tag values are not from the JVM spec, e.g. tags from 100 to 105,
2273   // they are changed to the corresponding tags from the JVM spec, so that java code in
2274   // sun.reflect.ConstantPool will return only tags from the JVM spec, not internal ones.
2275   if (tag.is_klass_or_reference()) {
2276       result = JVM_CONSTANT_Class;
2277   } else if (tag.is_string_index()) {
2278       result = JVM_CONSTANT_String;
2279   } else if (tag.is_method_type_in_error()) {
2280       result = JVM_CONSTANT_MethodType;
2281   } else if (tag.is_method_handle_in_error()) {
2282       result = JVM_CONSTANT_MethodHandle;
2283   } else if (tag.is_dynamic_constant_in_error()) {
2284       result = JVM_CONSTANT_Dynamic;
2285   }
2286   return result;
2287 }
2288 JVM_END
2289 
2290 // Assertion support. //////////////////////////////////////////////////////////
2291 
2292 JVM_ENTRY(jboolean, JVM_DesiredAssertionStatus(JNIEnv *env, jclass unused, jclass cls))
2293   JVMWrapper(&quot;JVM_DesiredAssertionStatus&quot;);
2294   assert(cls != NULL, &quot;bad class&quot;);
2295 
2296   oop r = JNIHandles::resolve(cls);
2297   assert(! java_lang_Class::is_primitive(r), &quot;primitive classes not allowed&quot;);
2298   if (java_lang_Class::is_primitive(r)) return false;
2299 
2300   Klass* k = java_lang_Class::as_Klass(r);
2301   assert(k-&gt;is_instance_klass(), &quot;must be an instance klass&quot;);
2302   if (!k-&gt;is_instance_klass()) return false;
2303 
2304   ResourceMark rm(THREAD);
2305   const char* name = k-&gt;name()-&gt;as_C_string();
2306   bool system_class = k-&gt;class_loader() == NULL;
2307   return JavaAssertions::enabled(name, system_class);
2308 
2309 JVM_END
2310 
2311 
2312 // Return a new AssertionStatusDirectives object with the fields filled in with
2313 // command-line assertion arguments (i.e., -ea, -da).
2314 JVM_ENTRY(jobject, JVM_AssertionStatusDirectives(JNIEnv *env, jclass unused))
2315   JVMWrapper(&quot;JVM_AssertionStatusDirectives&quot;);
2316   JvmtiVMObjectAllocEventCollector oam;
2317   oop asd = JavaAssertions::createAssertionStatusDirectives(CHECK_NULL);
2318   return JNIHandles::make_local(env, asd);
2319 JVM_END
2320 
2321 // Verification ////////////////////////////////////////////////////////////////////////////////
2322 
2323 // Reflection for the verifier /////////////////////////////////////////////////////////////////
2324 
2325 // RedefineClasses support: bug 6214132 caused verification to fail.
2326 // All functions from this section should call the jvmtiThreadSate function:
2327 //   Klass* class_to_verify_considering_redefinition(Klass* klass).
2328 // The function returns a Klass* of the _scratch_class if the verifier
2329 // was invoked in the middle of the class redefinition.
2330 // Otherwise it returns its argument value which is the _the_class Klass*.
2331 // Please, refer to the description in the jvmtiThreadSate.hpp.
2332 
2333 JVM_ENTRY(const char*, JVM_GetClassNameUTF(JNIEnv *env, jclass cls))
2334   JVMWrapper(&quot;JVM_GetClassNameUTF&quot;);
2335   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(cls));
2336   k = JvmtiThreadState::class_to_verify_considering_redefinition(k, thread);
2337   return k-&gt;name()-&gt;as_utf8();
2338 JVM_END
2339 
2340 
2341 JVM_ENTRY(void, JVM_GetClassCPTypes(JNIEnv *env, jclass cls, unsigned char *types))
2342   JVMWrapper(&quot;JVM_GetClassCPTypes&quot;);
2343   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(cls));
2344   k = JvmtiThreadState::class_to_verify_considering_redefinition(k, thread);
2345   // types will have length zero if this is not an InstanceKlass
2346   // (length is determined by call to JVM_GetClassCPEntriesCount)
2347   if (k-&gt;is_instance_klass()) {
2348     ConstantPool* cp = InstanceKlass::cast(k)-&gt;constants();
2349     for (int index = cp-&gt;length() - 1; index &gt;= 0; index--) {
2350       constantTag tag = cp-&gt;tag_at(index);
2351       types[index] = (tag.is_unresolved_klass()) ? (unsigned char) JVM_CONSTANT_Class : tag.value();
2352     }
2353   }
2354 JVM_END
2355 
2356 
2357 JVM_ENTRY(jint, JVM_GetClassCPEntriesCount(JNIEnv *env, jclass cls))
2358   JVMWrapper(&quot;JVM_GetClassCPEntriesCount&quot;);
2359   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(cls));
2360   k = JvmtiThreadState::class_to_verify_considering_redefinition(k, thread);
2361   return (!k-&gt;is_instance_klass()) ? 0 : InstanceKlass::cast(k)-&gt;constants()-&gt;length();
2362 JVM_END
2363 
2364 
2365 JVM_ENTRY(jint, JVM_GetClassFieldsCount(JNIEnv *env, jclass cls))
2366   JVMWrapper(&quot;JVM_GetClassFieldsCount&quot;);
2367   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(cls));
2368   k = JvmtiThreadState::class_to_verify_considering_redefinition(k, thread);
2369   return (!k-&gt;is_instance_klass()) ? 0 : InstanceKlass::cast(k)-&gt;java_fields_count();
2370 JVM_END
2371 
2372 
2373 JVM_ENTRY(jint, JVM_GetClassMethodsCount(JNIEnv *env, jclass cls))
2374   JVMWrapper(&quot;JVM_GetClassMethodsCount&quot;);
2375   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(cls));
2376   k = JvmtiThreadState::class_to_verify_considering_redefinition(k, thread);
2377   return (!k-&gt;is_instance_klass()) ? 0 : InstanceKlass::cast(k)-&gt;methods()-&gt;length();
2378 JVM_END
2379 
2380 
2381 // The following methods, used for the verifier, are never called with
2382 // array klasses, so a direct cast to InstanceKlass is safe.
2383 // Typically, these methods are called in a loop with bounds determined
2384 // by the results of JVM_GetClass{Fields,Methods}Count, which return
2385 // zero for arrays.
2386 JVM_ENTRY(void, JVM_GetMethodIxExceptionIndexes(JNIEnv *env, jclass cls, jint method_index, unsigned short *exceptions))
2387   JVMWrapper(&quot;JVM_GetMethodIxExceptionIndexes&quot;);
2388   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(cls));
2389   k = JvmtiThreadState::class_to_verify_considering_redefinition(k, thread);
2390   Method* method = InstanceKlass::cast(k)-&gt;methods()-&gt;at(method_index);
2391   int length = method-&gt;checked_exceptions_length();
2392   if (length &gt; 0) {
2393     CheckedExceptionElement* table= method-&gt;checked_exceptions_start();
2394     for (int i = 0; i &lt; length; i++) {
2395       exceptions[i] = table[i].class_cp_index;
2396     }
2397   }
2398 JVM_END
2399 
2400 
2401 JVM_ENTRY(jint, JVM_GetMethodIxExceptionsCount(JNIEnv *env, jclass cls, jint method_index))
2402   JVMWrapper(&quot;JVM_GetMethodIxExceptionsCount&quot;);
2403   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(cls));
2404   k = JvmtiThreadState::class_to_verify_considering_redefinition(k, thread);
2405   Method* method = InstanceKlass::cast(k)-&gt;methods()-&gt;at(method_index);
2406   return method-&gt;checked_exceptions_length();
2407 JVM_END
2408 
2409 
2410 JVM_ENTRY(void, JVM_GetMethodIxByteCode(JNIEnv *env, jclass cls, jint method_index, unsigned char *code))
2411   JVMWrapper(&quot;JVM_GetMethodIxByteCode&quot;);
2412   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(cls));
2413   k = JvmtiThreadState::class_to_verify_considering_redefinition(k, thread);
2414   Method* method = InstanceKlass::cast(k)-&gt;methods()-&gt;at(method_index);
2415   memcpy(code, method-&gt;code_base(), method-&gt;code_size());
2416 JVM_END
2417 
2418 
2419 JVM_ENTRY(jint, JVM_GetMethodIxByteCodeLength(JNIEnv *env, jclass cls, jint method_index))
2420   JVMWrapper(&quot;JVM_GetMethodIxByteCodeLength&quot;);
2421   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(cls));
2422   k = JvmtiThreadState::class_to_verify_considering_redefinition(k, thread);
2423   Method* method = InstanceKlass::cast(k)-&gt;methods()-&gt;at(method_index);
2424   return method-&gt;code_size();
2425 JVM_END
2426 
2427 
2428 JVM_ENTRY(void, JVM_GetMethodIxExceptionTableEntry(JNIEnv *env, jclass cls, jint method_index, jint entry_index, JVM_ExceptionTableEntryType *entry))
2429   JVMWrapper(&quot;JVM_GetMethodIxExceptionTableEntry&quot;);
2430   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(cls));
2431   k = JvmtiThreadState::class_to_verify_considering_redefinition(k, thread);
2432   Method* method = InstanceKlass::cast(k)-&gt;methods()-&gt;at(method_index);
2433   ExceptionTable extable(method);
2434   entry-&gt;start_pc   = extable.start_pc(entry_index);
2435   entry-&gt;end_pc     = extable.end_pc(entry_index);
2436   entry-&gt;handler_pc = extable.handler_pc(entry_index);
2437   entry-&gt;catchType  = extable.catch_type_index(entry_index);
2438 JVM_END
2439 
2440 
2441 JVM_ENTRY(jint, JVM_GetMethodIxExceptionTableLength(JNIEnv *env, jclass cls, int method_index))
2442   JVMWrapper(&quot;JVM_GetMethodIxExceptionTableLength&quot;);
2443   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(cls));
2444   k = JvmtiThreadState::class_to_verify_considering_redefinition(k, thread);
2445   Method* method = InstanceKlass::cast(k)-&gt;methods()-&gt;at(method_index);
2446   return method-&gt;exception_table_length();
2447 JVM_END
2448 
2449 
2450 JVM_ENTRY(jint, JVM_GetMethodIxModifiers(JNIEnv *env, jclass cls, int method_index))
2451   JVMWrapper(&quot;JVM_GetMethodIxModifiers&quot;);
2452   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(cls));
2453   k = JvmtiThreadState::class_to_verify_considering_redefinition(k, thread);
2454   Method* method = InstanceKlass::cast(k)-&gt;methods()-&gt;at(method_index);
2455   return method-&gt;access_flags().as_int() &amp; JVM_RECOGNIZED_METHOD_MODIFIERS;
2456 JVM_END
2457 
2458 
2459 JVM_ENTRY(jint, JVM_GetFieldIxModifiers(JNIEnv *env, jclass cls, int field_index))
2460   JVMWrapper(&quot;JVM_GetFieldIxModifiers&quot;);
2461   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(cls));
2462   k = JvmtiThreadState::class_to_verify_considering_redefinition(k, thread);
2463   return InstanceKlass::cast(k)-&gt;field_access_flags(field_index) &amp; JVM_RECOGNIZED_FIELD_MODIFIERS;
2464 JVM_END
2465 
2466 
2467 JVM_ENTRY(jint, JVM_GetMethodIxLocalsCount(JNIEnv *env, jclass cls, int method_index))
2468   JVMWrapper(&quot;JVM_GetMethodIxLocalsCount&quot;);
2469   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(cls));
2470   k = JvmtiThreadState::class_to_verify_considering_redefinition(k, thread);
2471   Method* method = InstanceKlass::cast(k)-&gt;methods()-&gt;at(method_index);
2472   return method-&gt;max_locals();
2473 JVM_END
2474 
2475 
2476 JVM_ENTRY(jint, JVM_GetMethodIxArgsSize(JNIEnv *env, jclass cls, int method_index))
2477   JVMWrapper(&quot;JVM_GetMethodIxArgsSize&quot;);
2478   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(cls));
2479   k = JvmtiThreadState::class_to_verify_considering_redefinition(k, thread);
2480   Method* method = InstanceKlass::cast(k)-&gt;methods()-&gt;at(method_index);
2481   return method-&gt;size_of_parameters();
2482 JVM_END
2483 
2484 
2485 JVM_ENTRY(jint, JVM_GetMethodIxMaxStack(JNIEnv *env, jclass cls, int method_index))
2486   JVMWrapper(&quot;JVM_GetMethodIxMaxStack&quot;);
2487   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(cls));
2488   k = JvmtiThreadState::class_to_verify_considering_redefinition(k, thread);
2489   Method* method = InstanceKlass::cast(k)-&gt;methods()-&gt;at(method_index);
2490   return method-&gt;verifier_max_stack();
2491 JVM_END
2492 
2493 
2494 JVM_ENTRY(jboolean, JVM_IsConstructorIx(JNIEnv *env, jclass cls, int method_index))
2495   JVMWrapper(&quot;JVM_IsConstructorIx&quot;);
2496   ResourceMark rm(THREAD);
2497   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(cls));
2498   k = JvmtiThreadState::class_to_verify_considering_redefinition(k, thread);
2499   Method* method = InstanceKlass::cast(k)-&gt;methods()-&gt;at(method_index);
2500   return method-&gt;name() == vmSymbols::object_initializer_name();
2501 JVM_END
2502 
2503 
2504 JVM_ENTRY(jboolean, JVM_IsVMGeneratedMethodIx(JNIEnv *env, jclass cls, int method_index))
2505   JVMWrapper(&quot;JVM_IsVMGeneratedMethodIx&quot;);
2506   ResourceMark rm(THREAD);
2507   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(cls));
2508   k = JvmtiThreadState::class_to_verify_considering_redefinition(k, thread);
2509   Method* method = InstanceKlass::cast(k)-&gt;methods()-&gt;at(method_index);
2510   return method-&gt;is_overpass();
2511 JVM_END
2512 
2513 JVM_ENTRY(const char*, JVM_GetMethodIxNameUTF(JNIEnv *env, jclass cls, jint method_index))
2514   JVMWrapper(&quot;JVM_GetMethodIxIxUTF&quot;);
2515   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(cls));
2516   k = JvmtiThreadState::class_to_verify_considering_redefinition(k, thread);
2517   Method* method = InstanceKlass::cast(k)-&gt;methods()-&gt;at(method_index);
2518   return method-&gt;name()-&gt;as_utf8();
2519 JVM_END
2520 
2521 
2522 JVM_ENTRY(const char*, JVM_GetMethodIxSignatureUTF(JNIEnv *env, jclass cls, jint method_index))
2523   JVMWrapper(&quot;JVM_GetMethodIxSignatureUTF&quot;);
2524   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(cls));
2525   k = JvmtiThreadState::class_to_verify_considering_redefinition(k, thread);
2526   Method* method = InstanceKlass::cast(k)-&gt;methods()-&gt;at(method_index);
2527   return method-&gt;signature()-&gt;as_utf8();
2528 JVM_END
2529 
2530 /**
2531  * All of these JVM_GetCP-xxx methods are used by the old verifier to
2532  * read entries in the constant pool.  Since the old verifier always
2533  * works on a copy of the code, it will not see any rewriting that
2534  * may possibly occur in the middle of verification.  So it is important
2535  * that nothing it calls tries to use the cpCache instead of the raw
2536  * constant pool, so we must use cp-&gt;uncached_x methods when appropriate.
2537  */
2538 JVM_ENTRY(const char*, JVM_GetCPFieldNameUTF(JNIEnv *env, jclass cls, jint cp_index))
2539   JVMWrapper(&quot;JVM_GetCPFieldNameUTF&quot;);
2540   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(cls));
2541   k = JvmtiThreadState::class_to_verify_considering_redefinition(k, thread);
2542   ConstantPool* cp = InstanceKlass::cast(k)-&gt;constants();
2543   switch (cp-&gt;tag_at(cp_index).value()) {
2544     case JVM_CONSTANT_Fieldref:
2545       return cp-&gt;uncached_name_ref_at(cp_index)-&gt;as_utf8();
2546     default:
2547       fatal(&quot;JVM_GetCPFieldNameUTF: illegal constant&quot;);
2548   }
2549   ShouldNotReachHere();
2550   return NULL;
2551 JVM_END
2552 
2553 
2554 JVM_ENTRY(const char*, JVM_GetCPMethodNameUTF(JNIEnv *env, jclass cls, jint cp_index))
2555   JVMWrapper(&quot;JVM_GetCPMethodNameUTF&quot;);
2556   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(cls));
2557   k = JvmtiThreadState::class_to_verify_considering_redefinition(k, thread);
2558   ConstantPool* cp = InstanceKlass::cast(k)-&gt;constants();
2559   switch (cp-&gt;tag_at(cp_index).value()) {
2560     case JVM_CONSTANT_InterfaceMethodref:
2561     case JVM_CONSTANT_Methodref:
2562       return cp-&gt;uncached_name_ref_at(cp_index)-&gt;as_utf8();
2563     default:
2564       fatal(&quot;JVM_GetCPMethodNameUTF: illegal constant&quot;);
2565   }
2566   ShouldNotReachHere();
2567   return NULL;
2568 JVM_END
2569 
2570 
2571 JVM_ENTRY(const char*, JVM_GetCPMethodSignatureUTF(JNIEnv *env, jclass cls, jint cp_index))
2572   JVMWrapper(&quot;JVM_GetCPMethodSignatureUTF&quot;);
2573   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(cls));
2574   k = JvmtiThreadState::class_to_verify_considering_redefinition(k, thread);
2575   ConstantPool* cp = InstanceKlass::cast(k)-&gt;constants();
2576   switch (cp-&gt;tag_at(cp_index).value()) {
2577     case JVM_CONSTANT_InterfaceMethodref:
2578     case JVM_CONSTANT_Methodref:
2579       return cp-&gt;uncached_signature_ref_at(cp_index)-&gt;as_utf8();
2580     default:
2581       fatal(&quot;JVM_GetCPMethodSignatureUTF: illegal constant&quot;);
2582   }
2583   ShouldNotReachHere();
2584   return NULL;
2585 JVM_END
2586 
2587 
2588 JVM_ENTRY(const char*, JVM_GetCPFieldSignatureUTF(JNIEnv *env, jclass cls, jint cp_index))
2589   JVMWrapper(&quot;JVM_GetCPFieldSignatureUTF&quot;);
2590   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(cls));
2591   k = JvmtiThreadState::class_to_verify_considering_redefinition(k, thread);
2592   ConstantPool* cp = InstanceKlass::cast(k)-&gt;constants();
2593   switch (cp-&gt;tag_at(cp_index).value()) {
2594     case JVM_CONSTANT_Fieldref:
2595       return cp-&gt;uncached_signature_ref_at(cp_index)-&gt;as_utf8();
2596     default:
2597       fatal(&quot;JVM_GetCPFieldSignatureUTF: illegal constant&quot;);
2598   }
2599   ShouldNotReachHere();
2600   return NULL;
2601 JVM_END
2602 
2603 
2604 JVM_ENTRY(const char*, JVM_GetCPClassNameUTF(JNIEnv *env, jclass cls, jint cp_index))
2605   JVMWrapper(&quot;JVM_GetCPClassNameUTF&quot;);
2606   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(cls));
2607   k = JvmtiThreadState::class_to_verify_considering_redefinition(k, thread);
2608   ConstantPool* cp = InstanceKlass::cast(k)-&gt;constants();
2609   Symbol* classname = cp-&gt;klass_name_at(cp_index);
2610   return classname-&gt;as_utf8();
2611 JVM_END
2612 
2613 
2614 JVM_ENTRY(const char*, JVM_GetCPFieldClassNameUTF(JNIEnv *env, jclass cls, jint cp_index))
2615   JVMWrapper(&quot;JVM_GetCPFieldClassNameUTF&quot;);
2616   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(cls));
2617   k = JvmtiThreadState::class_to_verify_considering_redefinition(k, thread);
2618   ConstantPool* cp = InstanceKlass::cast(k)-&gt;constants();
2619   switch (cp-&gt;tag_at(cp_index).value()) {
2620     case JVM_CONSTANT_Fieldref: {
2621       int class_index = cp-&gt;uncached_klass_ref_index_at(cp_index);
2622       Symbol* classname = cp-&gt;klass_name_at(class_index);
2623       return classname-&gt;as_utf8();
2624     }
2625     default:
2626       fatal(&quot;JVM_GetCPFieldClassNameUTF: illegal constant&quot;);
2627   }
2628   ShouldNotReachHere();
2629   return NULL;
2630 JVM_END
2631 
2632 
2633 JVM_ENTRY(const char*, JVM_GetCPMethodClassNameUTF(JNIEnv *env, jclass cls, jint cp_index))
2634   JVMWrapper(&quot;JVM_GetCPMethodClassNameUTF&quot;);
2635   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(cls));
2636   k = JvmtiThreadState::class_to_verify_considering_redefinition(k, thread);
2637   ConstantPool* cp = InstanceKlass::cast(k)-&gt;constants();
2638   switch (cp-&gt;tag_at(cp_index).value()) {
2639     case JVM_CONSTANT_Methodref:
2640     case JVM_CONSTANT_InterfaceMethodref: {
2641       int class_index = cp-&gt;uncached_klass_ref_index_at(cp_index);
2642       Symbol* classname = cp-&gt;klass_name_at(class_index);
2643       return classname-&gt;as_utf8();
2644     }
2645     default:
2646       fatal(&quot;JVM_GetCPMethodClassNameUTF: illegal constant&quot;);
2647   }
2648   ShouldNotReachHere();
2649   return NULL;
2650 JVM_END
2651 
2652 
2653 JVM_ENTRY(jint, JVM_GetCPFieldModifiers(JNIEnv *env, jclass cls, int cp_index, jclass called_cls))
2654   JVMWrapper(&quot;JVM_GetCPFieldModifiers&quot;);
2655   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(cls));
2656   Klass* k_called = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(called_cls));
2657   k        = JvmtiThreadState::class_to_verify_considering_redefinition(k, thread);
2658   k_called = JvmtiThreadState::class_to_verify_considering_redefinition(k_called, thread);
2659   ConstantPool* cp = InstanceKlass::cast(k)-&gt;constants();
2660   ConstantPool* cp_called = InstanceKlass::cast(k_called)-&gt;constants();
2661   switch (cp-&gt;tag_at(cp_index).value()) {
2662     case JVM_CONSTANT_Fieldref: {
2663       Symbol* name      = cp-&gt;uncached_name_ref_at(cp_index);
2664       Symbol* signature = cp-&gt;uncached_signature_ref_at(cp_index);
2665       InstanceKlass* ik = InstanceKlass::cast(k_called);
2666       for (JavaFieldStream fs(ik); !fs.done(); fs.next()) {
2667         if (fs.name() == name &amp;&amp; fs.signature() == signature) {
2668           return fs.access_flags().as_short() &amp; JVM_RECOGNIZED_FIELD_MODIFIERS;
2669         }
2670       }
2671       return -1;
2672     }
2673     default:
2674       fatal(&quot;JVM_GetCPFieldModifiers: illegal constant&quot;);
2675   }
2676   ShouldNotReachHere();
2677   return 0;
2678 JVM_END
2679 
2680 
2681 JVM_ENTRY(jint, JVM_GetCPMethodModifiers(JNIEnv *env, jclass cls, int cp_index, jclass called_cls))
2682   JVMWrapper(&quot;JVM_GetCPMethodModifiers&quot;);
2683   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(cls));
2684   Klass* k_called = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(called_cls));
2685   k        = JvmtiThreadState::class_to_verify_considering_redefinition(k, thread);
2686   k_called = JvmtiThreadState::class_to_verify_considering_redefinition(k_called, thread);
2687   ConstantPool* cp = InstanceKlass::cast(k)-&gt;constants();
2688   switch (cp-&gt;tag_at(cp_index).value()) {
2689     case JVM_CONSTANT_Methodref:
2690     case JVM_CONSTANT_InterfaceMethodref: {
2691       Symbol* name      = cp-&gt;uncached_name_ref_at(cp_index);
2692       Symbol* signature = cp-&gt;uncached_signature_ref_at(cp_index);
2693       Array&lt;Method*&gt;* methods = InstanceKlass::cast(k_called)-&gt;methods();
2694       int methods_count = methods-&gt;length();
2695       for (int i = 0; i &lt; methods_count; i++) {
2696         Method* method = methods-&gt;at(i);
2697         if (method-&gt;name() == name &amp;&amp; method-&gt;signature() == signature) {
2698             return method-&gt;access_flags().as_int() &amp; JVM_RECOGNIZED_METHOD_MODIFIERS;
2699         }
2700       }
2701       return -1;
2702     }
2703     default:
2704       fatal(&quot;JVM_GetCPMethodModifiers: illegal constant&quot;);
2705   }
2706   ShouldNotReachHere();
2707   return 0;
2708 JVM_END
2709 
2710 
2711 // Misc //////////////////////////////////////////////////////////////////////////////////////////////
2712 
2713 JVM_LEAF(void, JVM_ReleaseUTF(const char *utf))
2714   // So long as UTF8::convert_to_utf8 returns resource strings, we don&#39;t have to do anything
2715 JVM_END
2716 
2717 
2718 JVM_ENTRY(jboolean, JVM_IsSameClassPackage(JNIEnv *env, jclass class1, jclass class2))
2719   JVMWrapper(&quot;JVM_IsSameClassPackage&quot;);
2720   oop class1_mirror = JNIHandles::resolve_non_null(class1);
2721   oop class2_mirror = JNIHandles::resolve_non_null(class2);
2722   Klass* klass1 = java_lang_Class::as_Klass(class1_mirror);
2723   Klass* klass2 = java_lang_Class::as_Klass(class2_mirror);
2724   return (jboolean) Reflection::is_same_class_package(klass1, klass2);
2725 JVM_END
2726 
2727 // Printing support //////////////////////////////////////////////////
2728 extern &quot;C&quot; {
2729 
2730 ATTRIBUTE_PRINTF(3, 0)
2731 int jio_vsnprintf(char *str, size_t count, const char *fmt, va_list args) {
2732   // Reject count values that are negative signed values converted to
2733   // unsigned; see bug 4399518, 4417214
2734   if ((intptr_t)count &lt;= 0) return -1;
2735 
2736   int result = os::vsnprintf(str, count, fmt, args);
2737   if (result &gt; 0 &amp;&amp; (size_t)result &gt;= count) {
2738     result = -1;
2739   }
2740 
2741   return result;
2742 }
2743 
2744 ATTRIBUTE_PRINTF(3, 4)
2745 int jio_snprintf(char *str, size_t count, const char *fmt, ...) {
2746   va_list args;
2747   int len;
2748   va_start(args, fmt);
2749   len = jio_vsnprintf(str, count, fmt, args);
2750   va_end(args);
2751   return len;
2752 }
2753 
2754 ATTRIBUTE_PRINTF(2, 3)
2755 int jio_fprintf(FILE* f, const char *fmt, ...) {
2756   int len;
2757   va_list args;
2758   va_start(args, fmt);
2759   len = jio_vfprintf(f, fmt, args);
2760   va_end(args);
2761   return len;
2762 }
2763 
2764 ATTRIBUTE_PRINTF(2, 0)
2765 int jio_vfprintf(FILE* f, const char *fmt, va_list args) {
2766   if (Arguments::vfprintf_hook() != NULL) {
2767      return Arguments::vfprintf_hook()(f, fmt, args);
2768   } else {
2769     return vfprintf(f, fmt, args);
2770   }
2771 }
2772 
2773 ATTRIBUTE_PRINTF(1, 2)
2774 JNIEXPORT int jio_printf(const char *fmt, ...) {
2775   int len;
2776   va_list args;
2777   va_start(args, fmt);
2778   len = jio_vfprintf(defaultStream::output_stream(), fmt, args);
2779   va_end(args);
2780   return len;
2781 }
2782 
2783 // HotSpot specific jio method
2784 void jio_print(const char* s, size_t len) {
2785   // Try to make this function as atomic as possible.
2786   if (Arguments::vfprintf_hook() != NULL) {
2787     jio_fprintf(defaultStream::output_stream(), &quot;%.*s&quot;, (int)len, s);
2788   } else {
2789     // Make an unused local variable to avoid warning from gcc compiler.
2790     size_t count = ::write(defaultStream::output_fd(), s, (int)len);
2791   }
2792 }
2793 
2794 } // Extern C
2795 
2796 // java.lang.Thread //////////////////////////////////////////////////////////////////////////////
2797 
2798 // In most of the JVM thread support functions we need to access the
2799 // thread through a ThreadsListHandle to prevent it from exiting and
2800 // being reclaimed while we try to operate on it. The exceptions to this
2801 // rule are when operating on the current thread, or if the monitor of
2802 // the target java.lang.Thread is locked at the Java level - in both
2803 // cases the target cannot exit.
2804 
2805 static void thread_entry(JavaThread* thread, TRAPS) {
2806   HandleMark hm(THREAD);
2807   Handle obj(THREAD, thread-&gt;threadObj());
2808   JavaValue result(T_VOID);
2809   JavaCalls::call_virtual(&amp;result,
2810                           obj,
2811                           SystemDictionary::Thread_klass(),
2812                           vmSymbols::run_method_name(),
2813                           vmSymbols::void_method_signature(),
2814                           THREAD);
2815 }
2816 
2817 
2818 JVM_ENTRY(void, JVM_StartThread(JNIEnv* env, jobject jthread))
2819   JVMWrapper(&quot;JVM_StartThread&quot;);
2820   JavaThread *native_thread = NULL;
2821 
2822   // We cannot hold the Threads_lock when we throw an exception,
2823   // due to rank ordering issues. Example:  we might need to grab the
2824   // Heap_lock while we construct the exception.
2825   bool throw_illegal_thread_state = false;
2826 
2827   // We must release the Threads_lock before we can post a jvmti event
2828   // in Thread::start.
2829   {
2830     // Ensure that the C++ Thread and OSThread structures aren&#39;t freed before
2831     // we operate.
2832     MutexLocker mu(Threads_lock);
2833 
2834     // Since JDK 5 the java.lang.Thread threadStatus is used to prevent
2835     // re-starting an already started thread, so we should usually find
2836     // that the JavaThread is null. However for a JNI attached thread
2837     // there is a small window between the Thread object being created
2838     // (with its JavaThread set) and the update to its threadStatus, so we
2839     // have to check for this
2840     if (java_lang_Thread::thread(JNIHandles::resolve_non_null(jthread)) != NULL) {
2841       throw_illegal_thread_state = true;
2842     } else {
2843       // We could also check the stillborn flag to see if this thread was already stopped, but
2844       // for historical reasons we let the thread detect that itself when it starts running
2845 
2846       jlong size =
2847              java_lang_Thread::stackSize(JNIHandles::resolve_non_null(jthread));
2848       // Allocate the C++ Thread structure and create the native thread.  The
2849       // stack size retrieved from java is 64-bit signed, but the constructor takes
2850       // size_t (an unsigned type), which may be 32 or 64-bit depending on the platform.
2851       //  - Avoid truncating on 32-bit platforms if size is greater than UINT_MAX.
2852       //  - Avoid passing negative values which would result in really large stacks.
2853       NOT_LP64(if (size &gt; SIZE_MAX) size = SIZE_MAX;)
2854       size_t sz = size &gt; 0 ? (size_t) size : 0;
2855       native_thread = new JavaThread(&amp;thread_entry, sz);
2856 
2857       // At this point it may be possible that no osthread was created for the
2858       // JavaThread due to lack of memory. Check for this situation and throw
2859       // an exception if necessary. Eventually we may want to change this so
2860       // that we only grab the lock if the thread was created successfully -
2861       // then we can also do this check and throw the exception in the
2862       // JavaThread constructor.
2863       if (native_thread-&gt;osthread() != NULL) {
2864         // Note: the current thread is not being used within &quot;prepare&quot;.
2865         native_thread-&gt;prepare(jthread);
2866       }
2867     }
2868   }
2869 
2870   if (throw_illegal_thread_state) {
2871     THROW(vmSymbols::java_lang_IllegalThreadStateException());
2872   }
2873 
2874   assert(native_thread != NULL, &quot;Starting null thread?&quot;);
2875 
2876   if (native_thread-&gt;osthread() == NULL) {
2877     // No one should hold a reference to the &#39;native_thread&#39;.
2878     native_thread-&gt;smr_delete();
2879     if (JvmtiExport::should_post_resource_exhausted()) {
2880       JvmtiExport::post_resource_exhausted(
2881         JVMTI_RESOURCE_EXHAUSTED_OOM_ERROR | JVMTI_RESOURCE_EXHAUSTED_THREADS,
2882         os::native_thread_creation_failed_msg());
2883     }
2884     THROW_MSG(vmSymbols::java_lang_OutOfMemoryError(),
2885               os::native_thread_creation_failed_msg());
2886   }
2887 
2888   Thread::start(native_thread);
2889 
2890 JVM_END
2891 
2892 
2893 // JVM_Stop is implemented using a VM_Operation, so threads are forced to safepoints
2894 // before the quasi-asynchronous exception is delivered.  This is a little obtrusive,
2895 // but is thought to be reliable and simple. In the case, where the receiver is the
2896 // same thread as the sender, no VM_Operation is needed.
2897 JVM_ENTRY(void, JVM_StopThread(JNIEnv* env, jobject jthread, jobject throwable))
2898   JVMWrapper(&quot;JVM_StopThread&quot;);
2899 
2900   // A nested ThreadsListHandle will grab the Threads_lock so create
2901   // tlh before we resolve throwable.
2902   ThreadsListHandle tlh(thread);
2903   oop java_throwable = JNIHandles::resolve(throwable);
2904   if (java_throwable == NULL) {
2905     THROW(vmSymbols::java_lang_NullPointerException());
2906   }
2907   oop java_thread = NULL;
2908   JavaThread* receiver = NULL;
2909   bool is_alive = tlh.cv_internal_thread_to_JavaThread(jthread, &amp;receiver, &amp;java_thread);
2910   Events::log_exception(thread,
2911                         &quot;JVM_StopThread thread JavaThread &quot; INTPTR_FORMAT &quot; as oop &quot; INTPTR_FORMAT &quot; [exception &quot; INTPTR_FORMAT &quot;]&quot;,
2912                         p2i(receiver), p2i(java_thread), p2i(throwable));
2913 
2914   if (is_alive) {
2915     // jthread refers to a live JavaThread.
2916     if (thread == receiver) {
2917       // Exception is getting thrown at self so no VM_Operation needed.
2918       THROW_OOP(java_throwable);
2919     } else {
2920       // Use a VM_Operation to throw the exception.
2921       Thread::send_async_exception(java_thread, java_throwable);
2922     }
2923   } else {
2924     // Either:
2925     // - target thread has not been started before being stopped, or
2926     // - target thread already terminated
2927     // We could read the threadStatus to determine which case it is
2928     // but that is overkill as it doesn&#39;t matter. We must set the
2929     // stillborn flag for the first case, and if the thread has already
2930     // exited setting this flag has no effect.
2931     java_lang_Thread::set_stillborn(java_thread);
2932   }
2933 JVM_END
2934 
2935 
2936 JVM_ENTRY(jboolean, JVM_IsThreadAlive(JNIEnv* env, jobject jthread))
2937   JVMWrapper(&quot;JVM_IsThreadAlive&quot;);
2938 
2939   oop thread_oop = JNIHandles::resolve_non_null(jthread);
2940   return java_lang_Thread::is_alive(thread_oop);
2941 JVM_END
2942 
2943 
2944 JVM_ENTRY(void, JVM_SuspendThread(JNIEnv* env, jobject jthread))
2945   JVMWrapper(&quot;JVM_SuspendThread&quot;);
2946 
2947   ThreadsListHandle tlh(thread);
2948   JavaThread* receiver = NULL;
2949   bool is_alive = tlh.cv_internal_thread_to_JavaThread(jthread, &amp;receiver, NULL);
2950   if (is_alive) {
2951     // jthread refers to a live JavaThread.
2952     {
2953       MutexLocker ml(receiver-&gt;SR_lock(), Mutex::_no_safepoint_check_flag);
2954       if (receiver-&gt;is_external_suspend()) {
2955         // Don&#39;t allow nested external suspend requests. We can&#39;t return
2956         // an error from this interface so just ignore the problem.
2957         return;
2958       }
2959       if (receiver-&gt;is_exiting()) { // thread is in the process of exiting
2960         return;
2961       }
2962       receiver-&gt;set_external_suspend();
2963     }
2964 
2965     // java_suspend() will catch threads in the process of exiting
2966     // and will ignore them.
2967     receiver-&gt;java_suspend();
2968 
2969     // It would be nice to have the following assertion in all the
2970     // time, but it is possible for a racing resume request to have
2971     // resumed this thread right after we suspended it. Temporarily
2972     // enable this assertion if you are chasing a different kind of
2973     // bug.
2974     //
2975     // assert(java_lang_Thread::thread(receiver-&gt;threadObj()) == NULL ||
2976     //   receiver-&gt;is_being_ext_suspended(), &quot;thread is not suspended&quot;);
2977   }
2978 JVM_END
2979 
2980 
2981 JVM_ENTRY(void, JVM_ResumeThread(JNIEnv* env, jobject jthread))
2982   JVMWrapper(&quot;JVM_ResumeThread&quot;);
2983 
2984   ThreadsListHandle tlh(thread);
2985   JavaThread* receiver = NULL;
2986   bool is_alive = tlh.cv_internal_thread_to_JavaThread(jthread, &amp;receiver, NULL);
2987   if (is_alive) {
2988     // jthread refers to a live JavaThread.
2989 
2990     // This is the original comment for this Threads_lock grab:
2991     //   We need to *always* get the threads lock here, since this operation cannot be allowed during
2992     //   a safepoint. The safepoint code relies on suspending a thread to examine its state. If other
2993     //   threads randomly resumes threads, then a thread might not be suspended when the safepoint code
2994     //   looks at it.
2995     //
2996     // The above comment dates back to when we had both internal and
2997     // external suspend APIs that shared a common underlying mechanism.
2998     // External suspend is now entirely cooperative and doesn&#39;t share
2999     // anything with internal suspend. That said, there are some
3000     // assumptions in the VM that an external resume grabs the
3001     // Threads_lock. We can&#39;t drop the Threads_lock grab here until we
3002     // resolve the assumptions that exist elsewhere.
3003     //
3004     MutexLocker ml(Threads_lock);
3005     receiver-&gt;java_resume();
3006   }
3007 JVM_END
3008 
3009 
3010 JVM_ENTRY(void, JVM_SetThreadPriority(JNIEnv* env, jobject jthread, jint prio))
3011   JVMWrapper(&quot;JVM_SetThreadPriority&quot;);
3012 
3013   ThreadsListHandle tlh(thread);
3014   oop java_thread = NULL;
3015   JavaThread* receiver = NULL;
3016   bool is_alive = tlh.cv_internal_thread_to_JavaThread(jthread, &amp;receiver, &amp;java_thread);
3017   java_lang_Thread::set_priority(java_thread, (ThreadPriority)prio);
3018 
3019   if (is_alive) {
3020     // jthread refers to a live JavaThread.
3021     Thread::set_priority(receiver, (ThreadPriority)prio);
3022   }
3023   // Implied else: If the JavaThread hasn&#39;t started yet, then the
3024   // priority set in the java.lang.Thread object above will be pushed
3025   // down when it does start.
3026 JVM_END
3027 
3028 
3029 JVM_ENTRY(void, JVM_Yield(JNIEnv *env, jclass threadClass))
3030   JVMWrapper(&quot;JVM_Yield&quot;);
3031   if (os::dont_yield()) return;
3032   HOTSPOT_THREAD_YIELD();
3033   os::naked_yield();
3034 JVM_END
3035 
3036 static void post_thread_sleep_event(EventThreadSleep* event, jlong millis) {
3037   assert(event != NULL, &quot;invariant&quot;);
3038   assert(event-&gt;should_commit(), &quot;invariant&quot;);
3039   event-&gt;set_time(millis);
3040   event-&gt;commit();
3041 }
3042 
3043 JVM_ENTRY(void, JVM_Sleep(JNIEnv* env, jclass threadClass, jlong millis))
3044   JVMWrapper(&quot;JVM_Sleep&quot;);
3045 
3046   if (millis &lt; 0) {
3047     THROW_MSG(vmSymbols::java_lang_IllegalArgumentException(), &quot;timeout value is negative&quot;);
3048   }
3049 
3050   if (thread-&gt;is_interrupted(true) &amp;&amp; !HAS_PENDING_EXCEPTION) {
3051     THROW_MSG(vmSymbols::java_lang_InterruptedException(), &quot;sleep interrupted&quot;);
3052   }
3053 
3054   // Save current thread state and restore it at the end of this block.
3055   // And set new thread state to SLEEPING.
3056   JavaThreadSleepState jtss(thread);
3057 
3058   HOTSPOT_THREAD_SLEEP_BEGIN(millis);
3059   EventThreadSleep event;
3060 
3061   if (millis == 0) {
3062     os::naked_yield();
3063   } else {
3064     ThreadState old_state = thread-&gt;osthread()-&gt;get_state();
3065     thread-&gt;osthread()-&gt;set_state(SLEEPING);
3066     if (!thread-&gt;sleep(millis)) { // interrupted
3067       // An asynchronous exception (e.g., ThreadDeathException) could have been thrown on
3068       // us while we were sleeping. We do not overwrite those.
3069       if (!HAS_PENDING_EXCEPTION) {
3070         if (event.should_commit()) {
3071           post_thread_sleep_event(&amp;event, millis);
3072         }
3073         HOTSPOT_THREAD_SLEEP_END(1);
3074 
3075         // TODO-FIXME: THROW_MSG returns which means we will not call set_state()
3076         // to properly restore the thread state.  That&#39;s likely wrong.
3077         THROW_MSG(vmSymbols::java_lang_InterruptedException(), &quot;sleep interrupted&quot;);
3078       }
3079     }
3080     thread-&gt;osthread()-&gt;set_state(old_state);
3081   }
3082   if (event.should_commit()) {
3083     post_thread_sleep_event(&amp;event, millis);
3084   }
3085   HOTSPOT_THREAD_SLEEP_END(0);
3086 JVM_END
3087 
3088 JVM_ENTRY(jobject, JVM_CurrentThread(JNIEnv* env, jclass threadClass))
3089   JVMWrapper(&quot;JVM_CurrentThread&quot;);
3090   oop jthread = thread-&gt;threadObj();
3091   assert (thread != NULL, &quot;no current thread!&quot;);
3092   return JNIHandles::make_local(env, jthread);
3093 JVM_END
3094 
3095 JVM_ENTRY(void, JVM_Interrupt(JNIEnv* env, jobject jthread))
3096   JVMWrapper(&quot;JVM_Interrupt&quot;);
3097 
3098   ThreadsListHandle tlh(thread);
3099   JavaThread* receiver = NULL;
3100   bool is_alive = tlh.cv_internal_thread_to_JavaThread(jthread, &amp;receiver, NULL);
3101   if (is_alive) {
3102     // jthread refers to a live JavaThread.
3103     receiver-&gt;interrupt();
3104   }
3105 JVM_END
3106 
3107 
3108 // Return true iff the current thread has locked the object passed in
3109 
3110 JVM_ENTRY(jboolean, JVM_HoldsLock(JNIEnv* env, jclass threadClass, jobject obj))
3111   JVMWrapper(&quot;JVM_HoldsLock&quot;);
3112   assert(THREAD-&gt;is_Java_thread(), &quot;sanity check&quot;);
3113   if (obj == NULL) {
3114     THROW_(vmSymbols::java_lang_NullPointerException(), JNI_FALSE);
3115   }
3116   Handle h_obj(THREAD, JNIHandles::resolve(obj));
3117   return ObjectSynchronizer::current_thread_holds_lock((JavaThread*)THREAD, h_obj);
3118 JVM_END
3119 
3120 
3121 JVM_ENTRY(void, JVM_DumpAllStacks(JNIEnv* env, jclass))
3122   JVMWrapper(&quot;JVM_DumpAllStacks&quot;);
3123   VM_PrintThreads op;
3124   VMThread::execute(&amp;op);
3125   if (JvmtiExport::should_post_data_dump()) {
3126     JvmtiExport::post_data_dump();
3127   }
3128 JVM_END
3129 
3130 JVM_ENTRY(void, JVM_SetNativeThreadName(JNIEnv* env, jobject jthread, jstring name))
3131   JVMWrapper(&quot;JVM_SetNativeThreadName&quot;);
3132 
3133   // We don&#39;t use a ThreadsListHandle here because the current thread
3134   // must be alive.
3135   oop java_thread = JNIHandles::resolve_non_null(jthread);
3136   JavaThread* thr = java_lang_Thread::thread(java_thread);
3137   if (thread == thr &amp;&amp; !thr-&gt;has_attached_via_jni()) {
3138     // Thread naming is only supported for the current thread and
3139     // we don&#39;t set the name of an attached thread to avoid stepping
3140     // on other programs.
3141     ResourceMark rm(thread);
3142     const char *thread_name = java_lang_String::as_utf8_string(JNIHandles::resolve_non_null(name));
3143     os::set_native_thread_name(thread_name);
3144   }
3145 JVM_END
3146 
3147 // java.lang.SecurityManager ///////////////////////////////////////////////////////////////////////
3148 
3149 JVM_ENTRY(jobjectArray, JVM_GetClassContext(JNIEnv *env))
3150   JVMWrapper(&quot;JVM_GetClassContext&quot;);
3151   ResourceMark rm(THREAD);
3152   JvmtiVMObjectAllocEventCollector oam;
3153   vframeStream vfst(thread);
3154 
3155   if (SystemDictionary::reflect_CallerSensitive_klass() != NULL) {
3156     // This must only be called from SecurityManager.getClassContext
3157     Method* m = vfst.method();
3158     if (!(m-&gt;method_holder() == SystemDictionary::SecurityManager_klass() &amp;&amp;
3159           m-&gt;name()          == vmSymbols::getClassContext_name() &amp;&amp;
3160           m-&gt;signature()     == vmSymbols::void_class_array_signature())) {
3161       THROW_MSG_NULL(vmSymbols::java_lang_InternalError(), &quot;JVM_GetClassContext must only be called from SecurityManager.getClassContext&quot;);
3162     }
3163   }
3164 
3165   // Collect method holders
3166   GrowableArray&lt;Klass*&gt;* klass_array = new GrowableArray&lt;Klass*&gt;();
3167   for (; !vfst.at_end(); vfst.security_next()) {
3168     Method* m = vfst.method();
3169     // Native frames are not returned
3170     if (!m-&gt;is_ignored_by_security_stack_walk() &amp;&amp; !m-&gt;is_native()) {
3171       Klass* holder = m-&gt;method_holder();
3172       assert(holder-&gt;is_klass(), &quot;just checking&quot;);
3173       klass_array-&gt;append(holder);
3174     }
3175   }
3176 
3177   // Create result array of type [Ljava/lang/Class;
3178   objArrayOop result = oopFactory::new_objArray(SystemDictionary::Class_klass(), klass_array-&gt;length(), CHECK_NULL);
3179   // Fill in mirrors corresponding to method holders
3180   for (int i = 0; i &lt; klass_array-&gt;length(); i++) {
3181     result-&gt;obj_at_put(i, klass_array-&gt;at(i)-&gt;java_mirror());
3182   }
3183 
3184   return (jobjectArray) JNIHandles::make_local(env, result);
3185 JVM_END
3186 
3187 
3188 // java.lang.Package ////////////////////////////////////////////////////////////////
3189 
3190 
3191 JVM_ENTRY(jstring, JVM_GetSystemPackage(JNIEnv *env, jstring name))
3192   JVMWrapper(&quot;JVM_GetSystemPackage&quot;);
3193   ResourceMark rm(THREAD);
3194   JvmtiVMObjectAllocEventCollector oam;
3195   char* str = java_lang_String::as_utf8_string(JNIHandles::resolve_non_null(name));
3196   oop result = ClassLoader::get_system_package(str, CHECK_NULL);
3197   return (jstring) JNIHandles::make_local(result);
3198 JVM_END
3199 
3200 
3201 JVM_ENTRY(jobjectArray, JVM_GetSystemPackages(JNIEnv *env))
3202   JVMWrapper(&quot;JVM_GetSystemPackages&quot;);
3203   JvmtiVMObjectAllocEventCollector oam;
3204   objArrayOop result = ClassLoader::get_system_packages(CHECK_NULL);
3205   return (jobjectArray) JNIHandles::make_local(result);
3206 JVM_END
3207 
3208 
3209 // java.lang.ref.Finalizer ///////////////////////////////////////////////////////////////
3210 
3211 JVM_ENTRY(jboolean, JVM_GetTsanEnabled(JNIEnv *env))
3212   JVMWrapper(&quot;JVM_GetTsanEnabled&quot;);
3213   TSAN_ONLY(return ThreadSanitizer;)
3214   NOT_TSAN(return JNI_FALSE;)
3215 JVM_END
3216 
3217 
3218 // java.lang.ref.Reference ///////////////////////////////////////////////////////////////
3219 
3220 
3221 JVM_ENTRY(jobject, JVM_GetAndClearReferencePendingList(JNIEnv* env))
3222   JVMWrapper(&quot;JVM_GetAndClearReferencePendingList&quot;);
3223 
3224   MonitorLocker ml(Heap_lock);
3225   oop ref = Universe::reference_pending_list();
3226   if (ref != NULL) {
3227     Universe::set_reference_pending_list(NULL);
3228   }
3229   return JNIHandles::make_local(env, ref);
3230 JVM_END
3231 
3232 JVM_ENTRY(jboolean, JVM_HasReferencePendingList(JNIEnv* env))
3233   JVMWrapper(&quot;JVM_HasReferencePendingList&quot;);
3234   MonitorLocker ml(Heap_lock);
3235   return Universe::has_reference_pending_list();
3236 JVM_END
3237 
3238 JVM_ENTRY(void, JVM_WaitForReferencePendingList(JNIEnv* env))
3239   JVMWrapper(&quot;JVM_WaitForReferencePendingList&quot;);
3240   MonitorLocker ml(Heap_lock);
3241   while (!Universe::has_reference_pending_list()) {
3242     ml.wait();
3243   }
3244 JVM_END
3245 
3246 
3247 // ObjectInputStream ///////////////////////////////////////////////////////////////
3248 
3249 // Return the first user-defined class loader up the execution stack, or null
3250 // if only code from the bootstrap or platform class loader is on the stack.
3251 
3252 JVM_ENTRY(jobject, JVM_LatestUserDefinedLoader(JNIEnv *env))
3253   for (vframeStream vfst(thread); !vfst.at_end(); vfst.next()) {
3254     vfst.skip_reflection_related_frames(); // Only needed for 1.4 reflection
3255     oop loader = vfst.method()-&gt;method_holder()-&gt;class_loader();
3256     if (loader != NULL &amp;&amp; !SystemDictionary::is_platform_class_loader(loader)) {
3257       return JNIHandles::make_local(env, loader);
3258     }
3259   }
3260   return NULL;
3261 JVM_END
3262 
3263 
3264 // Array ///////////////////////////////////////////////////////////////////////////////////////////
3265 
3266 
3267 // resolve array handle and check arguments
3268 static inline arrayOop check_array(JNIEnv *env, jobject arr, bool type_array_only, TRAPS) {
3269   if (arr == NULL) {
3270     THROW_0(vmSymbols::java_lang_NullPointerException());
3271   }
3272   oop a = JNIHandles::resolve_non_null(arr);
3273   if (!a-&gt;is_array()) {
3274     THROW_MSG_0(vmSymbols::java_lang_IllegalArgumentException(), &quot;Argument is not an array&quot;);
3275   } else if (type_array_only &amp;&amp; !a-&gt;is_typeArray()) {
3276     THROW_MSG_0(vmSymbols::java_lang_IllegalArgumentException(), &quot;Argument is not an array of primitive type&quot;);
3277   }
3278   return arrayOop(a);
3279 }
3280 
3281 
3282 JVM_ENTRY(jint, JVM_GetArrayLength(JNIEnv *env, jobject arr))
3283   JVMWrapper(&quot;JVM_GetArrayLength&quot;);
3284   arrayOop a = check_array(env, arr, false, CHECK_0);
3285   return a-&gt;length();
3286 JVM_END
3287 
3288 
3289 JVM_ENTRY(jobject, JVM_GetArrayElement(JNIEnv *env, jobject arr, jint index))
3290   JVMWrapper(&quot;JVM_Array_Get&quot;);
3291   JvmtiVMObjectAllocEventCollector oam;
3292   arrayOop a = check_array(env, arr, false, CHECK_NULL);
3293   jvalue value;
3294   BasicType type = Reflection::array_get(&amp;value, a, index, CHECK_NULL);
3295   oop box = Reflection::box(&amp;value, type, CHECK_NULL);
3296   return JNIHandles::make_local(env, box);
3297 JVM_END
3298 
3299 
3300 JVM_ENTRY(jvalue, JVM_GetPrimitiveArrayElement(JNIEnv *env, jobject arr, jint index, jint wCode))
3301   JVMWrapper(&quot;JVM_GetPrimitiveArrayElement&quot;);
3302   jvalue value;
3303   value.i = 0; // to initialize value before getting used in CHECK
3304   arrayOop a = check_array(env, arr, true, CHECK_(value));
3305   assert(a-&gt;is_typeArray(), &quot;just checking&quot;);
3306   BasicType type = Reflection::array_get(&amp;value, a, index, CHECK_(value));
3307   BasicType wide_type = (BasicType) wCode;
3308   if (type != wide_type) {
3309     Reflection::widen(&amp;value, type, wide_type, CHECK_(value));
3310   }
3311   return value;
3312 JVM_END
3313 
3314 
3315 JVM_ENTRY(void, JVM_SetArrayElement(JNIEnv *env, jobject arr, jint index, jobject val))
3316   JVMWrapper(&quot;JVM_SetArrayElement&quot;);
3317   arrayOop a = check_array(env, arr, false, CHECK);
3318   oop box = JNIHandles::resolve(val);
3319   jvalue value;
3320   value.i = 0; // to initialize value before getting used in CHECK
3321   BasicType value_type;
3322   if (a-&gt;is_objArray()) {
3323     // Make sure we do no unbox e.g. java/lang/Integer instances when storing into an object array
3324     value_type = Reflection::unbox_for_regular_object(box, &amp;value);
3325   } else {
3326     value_type = Reflection::unbox_for_primitive(box, &amp;value, CHECK);
3327   }
3328   Reflection::array_set(&amp;value, a, index, value_type, CHECK);
3329 JVM_END
3330 
3331 
3332 JVM_ENTRY(void, JVM_SetPrimitiveArrayElement(JNIEnv *env, jobject arr, jint index, jvalue v, unsigned char vCode))
3333   JVMWrapper(&quot;JVM_SetPrimitiveArrayElement&quot;);
3334   arrayOop a = check_array(env, arr, true, CHECK);
3335   assert(a-&gt;is_typeArray(), &quot;just checking&quot;);
3336   BasicType value_type = (BasicType) vCode;
3337   Reflection::array_set(&amp;v, a, index, value_type, CHECK);
3338 JVM_END
3339 
3340 
3341 JVM_ENTRY(jobject, JVM_NewArray(JNIEnv *env, jclass eltClass, jint length))
3342   JVMWrapper(&quot;JVM_NewArray&quot;);
3343   JvmtiVMObjectAllocEventCollector oam;
3344   oop element_mirror = JNIHandles::resolve(eltClass);
3345   oop result = Reflection::reflect_new_array(element_mirror, length, CHECK_NULL);
3346   return JNIHandles::make_local(env, result);
3347 JVM_END
3348 
3349 
3350 JVM_ENTRY(jobject, JVM_NewMultiArray(JNIEnv *env, jclass eltClass, jintArray dim))
3351   JVMWrapper(&quot;JVM_NewMultiArray&quot;);
3352   JvmtiVMObjectAllocEventCollector oam;
3353   arrayOop dim_array = check_array(env, dim, true, CHECK_NULL);
3354   oop element_mirror = JNIHandles::resolve(eltClass);
3355   assert(dim_array-&gt;is_typeArray(), &quot;just checking&quot;);
3356   oop result = Reflection::reflect_new_multi_array(element_mirror, typeArrayOop(dim_array), CHECK_NULL);
3357   return JNIHandles::make_local(env, result);
3358 JVM_END
3359 
3360 
3361 // Library support ///////////////////////////////////////////////////////////////////////////
3362 
3363 JVM_ENTRY_NO_ENV(void*, JVM_LoadLibrary(const char* name))
3364   //%note jvm_ct
3365   JVMWrapper(&quot;JVM_LoadLibrary&quot;);
3366   char ebuf[1024];
3367   void *load_result;
3368   {
3369     ThreadToNativeFromVM ttnfvm(thread);
3370     load_result = os::dll_load(name, ebuf, sizeof ebuf);
3371   }
3372   if (load_result == NULL) {
3373     char msg[1024];
3374     jio_snprintf(msg, sizeof msg, &quot;%s: %s&quot;, name, ebuf);
3375     // Since &#39;ebuf&#39; may contain a string encoded using
3376     // platform encoding scheme, we need to pass
3377     // Exceptions::unsafe_to_utf8 to the new_exception method
3378     // as the last argument. See bug 6367357.
3379     Handle h_exception =
3380       Exceptions::new_exception(thread,
3381                                 vmSymbols::java_lang_UnsatisfiedLinkError(),
3382                                 msg, Exceptions::unsafe_to_utf8);
3383 
3384     THROW_HANDLE_0(h_exception);
3385   }
3386   log_info(library)(&quot;Loaded library %s, handle &quot; INTPTR_FORMAT, name, p2i(load_result));
3387   return load_result;
3388 JVM_END
3389 
3390 
3391 JVM_LEAF(void, JVM_UnloadLibrary(void* handle))
3392   JVMWrapper(&quot;JVM_UnloadLibrary&quot;);
3393   os::dll_unload(handle);
3394   log_info(library)(&quot;Unloaded library with handle &quot; INTPTR_FORMAT, p2i(handle));
3395 JVM_END
3396 
3397 
3398 JVM_LEAF(void*, JVM_FindLibraryEntry(void* handle, const char* name))
3399   JVMWrapper(&quot;JVM_FindLibraryEntry&quot;);
3400   void* find_result = os::dll_lookup(handle, name);
3401   log_info(library)(&quot;%s %s in library with handle &quot; INTPTR_FORMAT,
3402                     find_result != NULL ? &quot;Found&quot; : &quot;Failed to find&quot;,
3403                     name, p2i(handle));
3404   return find_result;
3405 JVM_END
3406 
3407 
3408 // JNI version ///////////////////////////////////////////////////////////////////////////////
3409 
3410 JVM_LEAF(jboolean, JVM_IsSupportedJNIVersion(jint version))
3411   JVMWrapper(&quot;JVM_IsSupportedJNIVersion&quot;);
3412   return Threads::is_supported_jni_version_including_1_1(version);
3413 JVM_END
3414 
3415 
3416 // String support ///////////////////////////////////////////////////////////////////////////
3417 
3418 JVM_ENTRY(jstring, JVM_InternString(JNIEnv *env, jstring str))
3419   JVMWrapper(&quot;JVM_InternString&quot;);
3420   JvmtiVMObjectAllocEventCollector oam;
3421   if (str == NULL) return NULL;
3422   oop string = JNIHandles::resolve_non_null(str);
3423   oop result = StringTable::intern(string, CHECK_NULL);
3424   return (jstring) JNIHandles::make_local(env, result);
3425 JVM_END
3426 
3427 
3428 // VM Raw monitor support //////////////////////////////////////////////////////////////////////
3429 
3430 // VM Raw monitors (not to be confused with JvmtiRawMonitors) are a simple mutual exclusion
3431 // lock (not actually monitors: no wait/notify) that is exported by the VM for use by JDK
3432 // library code. They may be used by JavaThreads and non-JavaThreads and do not participate
3433 // in the safepoint protocol, thread suspension, thread interruption, or anything of that
3434 // nature. JavaThreads will be &quot;in native&quot; when using this API from JDK code.
3435 
3436 
3437 JNIEXPORT void* JNICALL JVM_RawMonitorCreate(void) {
3438   VM_Exit::block_if_vm_exited();
3439   JVMWrapper(&quot;JVM_RawMonitorCreate&quot;);
3440   void *mon = new os::PlatformMutex();
3441   TSAN_RUNTIME_ONLY(TSAN_RAW_LOCK_CREATE(mon));
3442   return mon;
3443 }
3444 
3445 
3446 JNIEXPORT void JNICALL  JVM_RawMonitorDestroy(void *mon) {
3447   VM_Exit::block_if_vm_exited();
3448   JVMWrapper(&quot;JVM_RawMonitorDestroy&quot;);
3449   TSAN_RUNTIME_ONLY(TSAN_RAW_LOCK_DESTROY(mon));
3450   delete ((os::PlatformMutex*) mon);
3451 }
3452 
3453 
3454 JNIEXPORT jint JNICALL JVM_RawMonitorEnter(void *mon) {
3455   VM_Exit::block_if_vm_exited();
3456   JVMWrapper(&quot;JVM_RawMonitorEnter&quot;);
3457   ((os::PlatformMutex*) mon)-&gt;lock();
3458   TSAN_RUNTIME_ONLY(TSAN_RAW_LOCK_ACQUIRED(mon));
3459   return 0;
3460 }
3461 
3462 
3463 JNIEXPORT void JNICALL JVM_RawMonitorExit(void *mon) {
3464   VM_Exit::block_if_vm_exited();
3465   JVMWrapper(&quot;JVM_RawMonitorExit&quot;);
3466   TSAN_RUNTIME_ONLY(TSAN_RAW_LOCK_RELEASED(mon));
3467   ((os::PlatformMutex*) mon)-&gt;unlock();
3468 }
3469 
3470 
3471 // Shared JNI/JVM entry points //////////////////////////////////////////////////////////////
3472 
3473 jclass find_class_from_class_loader(JNIEnv* env, Symbol* name, jboolean init,
3474                                     Handle loader, Handle protection_domain,
3475                                     jboolean throwError, TRAPS) {
3476   // Security Note:
3477   //   The Java level wrapper will perform the necessary security check allowing
3478   //   us to pass the NULL as the initiating class loader.  The VM is responsible for
3479   //   the checkPackageAccess relative to the initiating class loader via the
3480   //   protection_domain. The protection_domain is passed as NULL by the java code
3481   //   if there is no security manager in 3-arg Class.forName().
3482   Klass* klass = SystemDictionary::resolve_or_fail(name, loader, protection_domain, throwError != 0, CHECK_NULL);
3483 
3484   // Check if we should initialize the class
3485   if (init &amp;&amp; klass-&gt;is_instance_klass()) {
3486     klass-&gt;initialize(CHECK_NULL);
3487   }
3488   return (jclass) JNIHandles::make_local(env, klass-&gt;java_mirror());
3489 }
3490 
3491 
3492 // Method ///////////////////////////////////////////////////////////////////////////////////////////
3493 
3494 JVM_ENTRY(jobject, JVM_InvokeMethod(JNIEnv *env, jobject method, jobject obj, jobjectArray args0))
3495   JVMWrapper(&quot;JVM_InvokeMethod&quot;);
3496   Handle method_handle;
3497   if (thread-&gt;stack_available((address) &amp;method_handle) &gt;= JVMInvokeMethodSlack) {
3498     method_handle = Handle(THREAD, JNIHandles::resolve(method));
3499     Handle receiver(THREAD, JNIHandles::resolve(obj));
3500     objArrayHandle args(THREAD, objArrayOop(JNIHandles::resolve(args0)));
3501     oop result = Reflection::invoke_method(method_handle(), receiver, args, CHECK_NULL);
3502     jobject res = JNIHandles::make_local(env, result);
3503     if (JvmtiExport::should_post_vm_object_alloc()) {
3504       oop ret_type = java_lang_reflect_Method::return_type(method_handle());
3505       assert(ret_type != NULL, &quot;sanity check: ret_type oop must not be NULL!&quot;);
3506       if (java_lang_Class::is_primitive(ret_type)) {
3507         // Only for primitive type vm allocates memory for java object.
3508         // See box() method.
3509         JvmtiExport::post_vm_object_alloc(JavaThread::current(), result);
3510       }
3511     }
3512     return res;
3513   } else {
3514     THROW_0(vmSymbols::java_lang_StackOverflowError());
3515   }
3516 JVM_END
3517 
3518 
3519 JVM_ENTRY(jobject, JVM_NewInstanceFromConstructor(JNIEnv *env, jobject c, jobjectArray args0))
3520   JVMWrapper(&quot;JVM_NewInstanceFromConstructor&quot;);
3521   oop constructor_mirror = JNIHandles::resolve(c);
3522   objArrayHandle args(THREAD, objArrayOop(JNIHandles::resolve(args0)));
3523   oop result = Reflection::invoke_constructor(constructor_mirror, args, CHECK_NULL);
3524   jobject res = JNIHandles::make_local(env, result);
3525   if (JvmtiExport::should_post_vm_object_alloc()) {
3526     JvmtiExport::post_vm_object_alloc(JavaThread::current(), result);
3527   }
3528   return res;
3529 JVM_END
3530 
3531 // Atomic ///////////////////////////////////////////////////////////////////////////////////////////
3532 
3533 JVM_LEAF(jboolean, JVM_SupportsCX8())
3534   JVMWrapper(&quot;JVM_SupportsCX8&quot;);
3535   return VM_Version::supports_cx8();
3536 JVM_END
3537 
3538 JVM_ENTRY(void, JVM_InitializeFromArchive(JNIEnv* env, jclass cls))
3539   JVMWrapper(&quot;JVM_InitializeFromArchive&quot;);
3540   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve(cls));
3541   assert(k-&gt;is_klass(), &quot;just checking&quot;);
3542   HeapShared::initialize_from_archived_subgraph(k);
3543 JVM_END
3544 
3545 // Returns an array of all live Thread objects (VM internal JavaThreads,
3546 // jvmti agent threads, and JNI attaching threads  are skipped)
3547 // See CR 6404306 regarding JNI attaching threads
3548 JVM_ENTRY(jobjectArray, JVM_GetAllThreads(JNIEnv *env, jclass dummy))
3549   ResourceMark rm(THREAD);
3550   ThreadsListEnumerator tle(THREAD, false, false);
3551   JvmtiVMObjectAllocEventCollector oam;
3552 
3553   int num_threads = tle.num_threads();
3554   objArrayOop r = oopFactory::new_objArray(SystemDictionary::Thread_klass(), num_threads, CHECK_NULL);
3555   objArrayHandle threads_ah(THREAD, r);
3556 
3557   for (int i = 0; i &lt; num_threads; i++) {
3558     Handle h = tle.get_threadObj(i);
3559     threads_ah-&gt;obj_at_put(i, h());
3560   }
3561 
3562   return (jobjectArray) JNIHandles::make_local(env, threads_ah());
3563 JVM_END
3564 
3565 
3566 // Support for java.lang.Thread.getStackTrace() and getAllStackTraces() methods
3567 // Return StackTraceElement[][], each element is the stack trace of a thread in
3568 // the corresponding entry in the given threads array
3569 JVM_ENTRY(jobjectArray, JVM_DumpThreads(JNIEnv *env, jclass threadClass, jobjectArray threads))
3570   JVMWrapper(&quot;JVM_DumpThreads&quot;);
3571   JvmtiVMObjectAllocEventCollector oam;
3572 
3573   // Check if threads is null
3574   if (threads == NULL) {
3575     THROW_(vmSymbols::java_lang_NullPointerException(), 0);
3576   }
3577 
3578   objArrayOop a = objArrayOop(JNIHandles::resolve_non_null(threads));
3579   objArrayHandle ah(THREAD, a);
3580   int num_threads = ah-&gt;length();
3581   // check if threads is non-empty array
3582   if (num_threads == 0) {
3583     THROW_(vmSymbols::java_lang_IllegalArgumentException(), 0);
3584   }
3585 
3586   // check if threads is not an array of objects of Thread class
3587   Klass* k = ObjArrayKlass::cast(ah-&gt;klass())-&gt;element_klass();
3588   if (k != SystemDictionary::Thread_klass()) {
3589     THROW_(vmSymbols::java_lang_IllegalArgumentException(), 0);
3590   }
3591 
3592   ResourceMark rm(THREAD);
3593 
3594   GrowableArray&lt;instanceHandle&gt;* thread_handle_array = new GrowableArray&lt;instanceHandle&gt;(num_threads);
3595   for (int i = 0; i &lt; num_threads; i++) {
3596     oop thread_obj = ah-&gt;obj_at(i);
3597     instanceHandle h(THREAD, (instanceOop) thread_obj);
3598     thread_handle_array-&gt;append(h);
3599   }
3600 
3601   // The JavaThread references in thread_handle_array are validated
3602   // in VM_ThreadDump::doit().
3603   Handle stacktraces = ThreadService::dump_stack_traces(thread_handle_array, num_threads, CHECK_NULL);
3604   return (jobjectArray)JNIHandles::make_local(env, stacktraces());
3605 
3606 JVM_END
3607 
3608 // JVM monitoring and management support
3609 JVM_ENTRY_NO_ENV(void*, JVM_GetManagement(jint version))
3610   return Management::get_jmm_interface(version);
3611 JVM_END
3612 
3613 // com.sun.tools.attach.VirtualMachine agent properties support
3614 //
3615 // Initialize the agent properties with the properties maintained in the VM
3616 JVM_ENTRY(jobject, JVM_InitAgentProperties(JNIEnv *env, jobject properties))
3617   JVMWrapper(&quot;JVM_InitAgentProperties&quot;);
3618   ResourceMark rm;
3619 
3620   Handle props(THREAD, JNIHandles::resolve_non_null(properties));
3621 
3622   PUTPROP(props, &quot;sun.java.command&quot;, Arguments::java_command());
3623   PUTPROP(props, &quot;sun.jvm.flags&quot;, Arguments::jvm_flags());
3624   PUTPROP(props, &quot;sun.jvm.args&quot;, Arguments::jvm_args());
3625   return properties;
3626 JVM_END
3627 
3628 JVM_ENTRY(jobjectArray, JVM_GetEnclosingMethodInfo(JNIEnv *env, jclass ofClass))
3629 {
3630   JVMWrapper(&quot;JVM_GetEnclosingMethodInfo&quot;);
3631   JvmtiVMObjectAllocEventCollector oam;
3632 
3633   if (ofClass == NULL) {
3634     return NULL;
3635   }
3636   Handle mirror(THREAD, JNIHandles::resolve_non_null(ofClass));
3637   // Special handling for primitive objects
3638   if (java_lang_Class::is_primitive(mirror())) {
3639     return NULL;
3640   }
3641   Klass* k = java_lang_Class::as_Klass(mirror());
3642   if (!k-&gt;is_instance_klass()) {
3643     return NULL;
3644   }
3645   InstanceKlass* ik = InstanceKlass::cast(k);
3646   int encl_method_class_idx = ik-&gt;enclosing_method_class_index();
3647   if (encl_method_class_idx == 0) {
3648     return NULL;
3649   }
3650   objArrayOop dest_o = oopFactory::new_objArray(SystemDictionary::Object_klass(), 3, CHECK_NULL);
3651   objArrayHandle dest(THREAD, dest_o);
3652   Klass* enc_k = ik-&gt;constants()-&gt;klass_at(encl_method_class_idx, CHECK_NULL);
3653   dest-&gt;obj_at_put(0, enc_k-&gt;java_mirror());
3654   int encl_method_method_idx = ik-&gt;enclosing_method_method_index();
3655   if (encl_method_method_idx != 0) {
3656     Symbol* sym = ik-&gt;constants()-&gt;symbol_at(
3657                         extract_low_short_from_int(
3658                           ik-&gt;constants()-&gt;name_and_type_at(encl_method_method_idx)));
3659     Handle str = java_lang_String::create_from_symbol(sym, CHECK_NULL);
3660     dest-&gt;obj_at_put(1, str());
3661     sym = ik-&gt;constants()-&gt;symbol_at(
3662               extract_high_short_from_int(
3663                 ik-&gt;constants()-&gt;name_and_type_at(encl_method_method_idx)));
3664     str = java_lang_String::create_from_symbol(sym, CHECK_NULL);
3665     dest-&gt;obj_at_put(2, str());
3666   }
3667   return (jobjectArray) JNIHandles::make_local(dest());
3668 }
3669 JVM_END
3670 
3671 // Returns an array of java.lang.String objects containing the input arguments to the VM.
3672 JVM_ENTRY(jobjectArray, JVM_GetVmArguments(JNIEnv *env))
3673   ResourceMark rm(THREAD);
3674 
3675   if (Arguments::num_jvm_args() == 0 &amp;&amp; Arguments::num_jvm_flags() == 0) {
3676     return NULL;
3677   }
3678 
3679   char** vm_flags = Arguments::jvm_flags_array();
3680   char** vm_args = Arguments::jvm_args_array();
3681   int num_flags = Arguments::num_jvm_flags();
3682   int num_args = Arguments::num_jvm_args();
3683 
3684   InstanceKlass* ik = SystemDictionary::String_klass();
3685   objArrayOop r = oopFactory::new_objArray(ik, num_args + num_flags, CHECK_NULL);
3686   objArrayHandle result_h(THREAD, r);
3687 
3688   int index = 0;
3689   for (int j = 0; j &lt; num_flags; j++, index++) {
3690     Handle h = java_lang_String::create_from_platform_dependent_str(vm_flags[j], CHECK_NULL);
3691     result_h-&gt;obj_at_put(index, h());
3692   }
3693   for (int i = 0; i &lt; num_args; i++, index++) {
3694     Handle h = java_lang_String::create_from_platform_dependent_str(vm_args[i], CHECK_NULL);
3695     result_h-&gt;obj_at_put(index, h());
3696   }
3697   return (jobjectArray) JNIHandles::make_local(env, result_h());
3698 JVM_END
3699 
3700 JVM_ENTRY_NO_ENV(jint, JVM_FindSignal(const char *name))
3701   return os::get_signal_number(name);
3702 JVM_END
    </pre>
  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/share/oops/cpCache.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
    <script type="text/javascript" src="../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (c) 1998, 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #include &quot;precompiled.hpp&quot;
 26 #include &quot;classfile/resolutionErrors.hpp&quot;
 27 #include &quot;interpreter/bytecodeStream.hpp&quot;
 28 #include &quot;interpreter/bytecodes.hpp&quot;
 29 #include &quot;interpreter/interpreter.hpp&quot;
 30 #include &quot;interpreter/linkResolver.hpp&quot;
 31 #include &quot;interpreter/rewriter.hpp&quot;
 32 #include &quot;logging/log.hpp&quot;
 33 #include &quot;memory/heapShared.hpp&quot;
 34 #include &quot;memory/metadataFactory.hpp&quot;
 35 #include &quot;memory/metaspaceClosure.hpp&quot;
 36 #include &quot;memory/metaspaceShared.hpp&quot;
 37 #include &quot;memory/resourceArea.hpp&quot;
<a name="1" id="anc1"></a><span class="line-modified"> 38 #include &quot;memory/universe.hpp&quot;</span>
 39 #include &quot;oops/access.inline.hpp&quot;
 40 #include &quot;oops/constantPool.inline.hpp&quot;
 41 #include &quot;oops/cpCache.inline.hpp&quot;
 42 #include &quot;oops/objArrayOop.inline.hpp&quot;
 43 #include &quot;oops/oop.inline.hpp&quot;
 44 #include &quot;prims/methodHandles.hpp&quot;
 45 #include &quot;runtime/atomic.hpp&quot;
 46 #include &quot;runtime/handles.inline.hpp&quot;
<a name="2" id="anc2"></a><span class="line-removed"> 47 #include &quot;runtime/orderAccess.hpp&quot;</span>
 48 #include &quot;utilities/macros.hpp&quot;
 49 
 50 // Implementation of ConstantPoolCacheEntry
 51 
 52 void ConstantPoolCacheEntry::initialize_entry(int index) {
 53   assert(0 &lt; index &amp;&amp; index &lt; 0x10000, &quot;sanity check&quot;);
 54   _indices = index;
 55   _f1 = NULL;
 56   _f2 = _flags = 0;
 57   assert(constant_pool_index() == index, &quot;&quot;);
 58 }
 59 
 60 void ConstantPoolCacheEntry::verify_just_initialized(bool f2_used) {
 61   assert((_indices &amp; (~cp_index_mask)) == 0, &quot;sanity&quot;);
 62   assert(_f1 == NULL, &quot;sanity&quot;);
 63   assert(_flags == 0, &quot;sanity&quot;);
 64   if (!f2_used) {
 65     assert(_f2 == 0, &quot;sanity&quot;);
 66   }
 67 }
 68 
 69 void ConstantPoolCacheEntry::reinitialize(bool f2_used) {
 70   _indices &amp;= cp_index_mask;
 71   _f1 = NULL;
 72   _flags = 0;
 73   if (!f2_used) {
 74     _f2 = 0;
 75   }
 76 }
 77 
 78 int ConstantPoolCacheEntry::make_flags(TosState state,
 79                                        int option_bits,
 80                                        int field_index_or_method_params) {
 81   assert(state &lt; number_of_states, &quot;Invalid state in make_flags&quot;);
 82   int f = ((int)state &lt;&lt; tos_state_shift) | option_bits | field_index_or_method_params;
 83   // Preserve existing flag bit values
 84   // The low bits are a field offset, or else the method parameter size.
 85 #ifdef ASSERT
 86   TosState old_state = flag_state();
 87   assert(old_state == (TosState)0 || old_state == state,
 88          &quot;inconsistent cpCache flags state&quot;);
 89 #endif
 90   return (_flags | f) ;
 91 }
 92 
 93 void ConstantPoolCacheEntry::set_bytecode_1(Bytecodes::Code code) {
 94 #ifdef ASSERT
 95   // Read once.
 96   volatile Bytecodes::Code c = bytecode_1();
 97   assert(c == 0 || c == code || code == 0, &quot;update must be consistent&quot;);
 98 #endif
 99   // Need to flush pending stores here before bytecode is written.
<a name="3" id="anc3"></a><span class="line-modified">100   OrderAccess::release_store(&amp;_indices, _indices | ((u_char)code &lt;&lt; bytecode_1_shift));</span>
101 }
102 
103 void ConstantPoolCacheEntry::set_bytecode_2(Bytecodes::Code code) {
104 #ifdef ASSERT
105   // Read once.
106   volatile Bytecodes::Code c = bytecode_2();
107   assert(c == 0 || c == code || code == 0, &quot;update must be consistent&quot;);
108 #endif
109   // Need to flush pending stores here before bytecode is written.
<a name="4" id="anc4"></a><span class="line-modified">110   OrderAccess::release_store(&amp;_indices, _indices | ((u_char)code &lt;&lt; bytecode_2_shift));</span>
111 }
112 
113 // Sets f1, ordering with previous writes.
114 void ConstantPoolCacheEntry::release_set_f1(Metadata* f1) {
115   assert(f1 != NULL, &quot;&quot;);
<a name="5" id="anc5"></a><span class="line-modified">116   OrderAccess::release_store(&amp;_f1, f1);</span>
117 }
118 
119 void ConstantPoolCacheEntry::set_indy_resolution_failed() {
<a name="6" id="anc6"></a><span class="line-modified">120   OrderAccess::release_store(&amp;_flags, _flags | (1 &lt;&lt; indy_resolution_failed_shift));</span>
121 }
122 
123 // Note that concurrent update of both bytecodes can leave one of them
124 // reset to zero.  This is harmless; the interpreter will simply re-resolve
125 // the damaged entry.  More seriously, the memory synchronization is needed
126 // to flush other fields (f1, f2) completely to memory before the bytecodes
127 // are updated, lest other processors see a non-zero bytecode but zero f1/f2.
128 void ConstantPoolCacheEntry::set_field(Bytecodes::Code get_code,
129                                        Bytecodes::Code put_code,
130                                        Klass* field_holder,
131                                        int field_index,
132                                        int field_offset,
133                                        TosState field_type,
134                                        bool is_final,
135                                        bool is_volatile,
136                                        bool is_tsan_ignore,
137                                        Klass* root_klass) {
138   set_f1(field_holder);
139   set_f2(field_offset);
140   assert((field_index &amp; field_index_mask) == field_index,
141          &quot;field index does not fit in low flag bits&quot;);
142   set_field_flags(field_type,
143                   ((is_volatile ? 1 : 0) &lt;&lt; is_volatile_shift) |
144                   ((is_final    ? 1 : 0) &lt;&lt; is_final_shift) |
145                   ((is_tsan_ignore ? 1 : 0) &lt;&lt; is_tsan_ignore_shift),
146                   field_index);
147   set_bytecode_1(get_code);
148   set_bytecode_2(put_code);
149   NOT_PRODUCT(verify(tty));
150 }
151 
152 void ConstantPoolCacheEntry::set_parameter_size(int value) {
153   // This routine is called only in corner cases where the CPCE is not yet initialized.
154   // See AbstractInterpreter::deopt_continue_after_entry.
155   assert(_flags == 0 || parameter_size() == 0 || parameter_size() == value,
156          &quot;size must not change: parameter_size=%d, value=%d&quot;, parameter_size(), value);
157   // Setting the parameter size by itself is only safe if the
158   // current value of _flags is 0, otherwise another thread may have
159   // updated it and we don&#39;t want to overwrite that value.  Don&#39;t
160   // bother trying to update it once it&#39;s nonzero but always make
161   // sure that the final parameter size agrees with what was passed.
162   if (_flags == 0) {
163     intx newflags = (value &amp; parameter_size_mask);
<a name="7" id="anc7"></a><span class="line-modified">164     Atomic::cmpxchg(newflags, &amp;_flags, (intx)0);</span>
165   }
166   guarantee(parameter_size() == value,
167             &quot;size must not change: parameter_size=%d, value=%d&quot;, parameter_size(), value);
168 }
169 
170 void ConstantPoolCacheEntry::set_direct_or_vtable_call(Bytecodes::Code invoke_code,
171                                                        const methodHandle&amp; method,
172                                                        int vtable_index,
<a name="8" id="anc8"></a><span class="line-modified">173                                                        bool sender_is_interface,</span>
<span class="line-removed">174                                                        InstanceKlass* pool_holder) {</span>
175   bool is_vtable_call = (vtable_index &gt;= 0);  // FIXME: split this method on this boolean
176   assert(method-&gt;interpreter_entry() != NULL, &quot;should have been set at this point&quot;);
177   assert(!method-&gt;is_obsolete(),  &quot;attempt to write obsolete method to cpCache&quot;);
178 
179   int byte_no = -1;
180   bool change_to_virtual = false;
181   InstanceKlass* holder = NULL;  // have to declare this outside the switch
182   switch (invoke_code) {
183     case Bytecodes::_invokeinterface:
184       holder = method-&gt;method_holder();
185       // check for private interface method invocations
186       if (vtable_index == Method::nonvirtual_vtable_index &amp;&amp; holder-&gt;is_interface() ) {
187         assert(method-&gt;is_private(), &quot;unexpected non-private method&quot;);
188         assert(method-&gt;can_be_statically_bound(), &quot;unexpected non-statically-bound method&quot;);
189         // set_f2_as_vfinal_method checks if is_vfinal flag is true.
190         set_method_flags(as_TosState(method-&gt;result_type()),
191                          (                             1      &lt;&lt; is_vfinal_shift) |
192                          ((method-&gt;is_final_method() ? 1 : 0) &lt;&lt; is_final_shift),
193                          method()-&gt;size_of_parameters());
194         set_f2_as_vfinal_method(method());
195         byte_no = 2;
196         set_f1(holder); // interface klass*
197         break;
198       }
199       else {
200         // We get here from InterpreterRuntime::resolve_invoke when an invokeinterface
201         // instruction links to a non-interface method (in Object). This can happen when
202         // an interface redeclares an Object method (like CharSequence declaring toString())
203         // or when invokeinterface is used explicitly.
204         // In that case, the method has no itable index and must be invoked as a virtual.
205         // Set a flag to keep track of this corner case.
206         assert(holder-&gt;is_interface() || holder == SystemDictionary::Object_klass(), &quot;unexpected holder class&quot;);
207         assert(method-&gt;is_public(), &quot;Calling non-public method in Object with invokeinterface&quot;);
208         change_to_virtual = true;
209 
210         // ...and fall through as if we were handling invokevirtual:
211       }
212     case Bytecodes::_invokevirtual:
213       {
214         if (!is_vtable_call) {
215           assert(method-&gt;can_be_statically_bound(), &quot;&quot;);
216           // set_f2_as_vfinal_method checks if is_vfinal flag is true.
217           set_method_flags(as_TosState(method-&gt;result_type()),
218                            (                             1      &lt;&lt; is_vfinal_shift) |
219                            ((method-&gt;is_final_method() ? 1 : 0) &lt;&lt; is_final_shift)  |
220                            ((change_to_virtual         ? 1 : 0) &lt;&lt; is_forced_virtual_shift),
221                            method()-&gt;size_of_parameters());
222           set_f2_as_vfinal_method(method());
223         } else {
224           assert(!method-&gt;can_be_statically_bound(), &quot;&quot;);
225           assert(vtable_index &gt;= 0, &quot;valid index&quot;);
226           assert(!method-&gt;is_final_method(), &quot;sanity&quot;);
227           set_method_flags(as_TosState(method-&gt;result_type()),
228                            ((change_to_virtual ? 1 : 0) &lt;&lt; is_forced_virtual_shift),
229                            method()-&gt;size_of_parameters());
230           set_f2(vtable_index);
231         }
232         byte_no = 2;
233         break;
234       }
235 
236     case Bytecodes::_invokespecial:
237     case Bytecodes::_invokestatic:
238       assert(!is_vtable_call, &quot;&quot;);
239       // Note:  Read and preserve the value of the is_vfinal flag on any
240       // invokevirtual bytecode shared with this constant pool cache entry.
241       // It is cheap and safe to consult is_vfinal() at all times.
242       // Once is_vfinal is set, it must stay that way, lest we get a dangling oop.
243       set_method_flags(as_TosState(method-&gt;result_type()),
244                        ((is_vfinal()               ? 1 : 0) &lt;&lt; is_vfinal_shift) |
245                        ((method-&gt;is_final_method() ? 1 : 0) &lt;&lt; is_final_shift),
246                        method()-&gt;size_of_parameters());
247       set_f1(method());
248       byte_no = 1;
249       break;
250     default:
251       ShouldNotReachHere();
252       break;
253   }
254 
255   // Note:  byte_no also appears in TemplateTable::resolve.
256   if (byte_no == 1) {
257     assert(invoke_code != Bytecodes::_invokevirtual &amp;&amp;
258            invoke_code != Bytecodes::_invokeinterface, &quot;&quot;);
259     bool do_resolve = true;
260     // Don&#39;t mark invokespecial to method as resolved if sender is an interface.  The receiver
261     // has to be checked that it is a subclass of the current class every time this bytecode
262     // is executed.
263     if (invoke_code == Bytecodes::_invokespecial &amp;&amp; sender_is_interface &amp;&amp;
264         method-&gt;name() != vmSymbols::object_initializer_name()) {
265       do_resolve = false;
266     }
<a name="9" id="anc9"></a><span class="line-modified">267     // Don&#39;t mark invokestatic to method as resolved if the holder class has not yet completed</span>
<span class="line-modified">268     // initialization. An invokestatic must only proceed if the class is initialized, but if</span>
<span class="line-modified">269     // we resolve it before then that class initialization check is skipped. However if the call</span>
<span class="line-modified">270     // is from the same class we can resolve as we must be executing with &lt;clinit&gt; on our call stack.</span>
<span class="line-modified">271     if (invoke_code == Bytecodes::_invokestatic) {</span>
<span class="line-modified">272       if (!method-&gt;method_holder()-&gt;is_initialized() &amp;&amp;</span>







273           method-&gt;method_holder() != pool_holder) {
274         do_resolve = false;
<a name="10" id="anc10"></a><span class="line-removed">275       } else {</span>
<span class="line-removed">276         assert(method-&gt;method_holder()-&gt;is_initialized() ||</span>
<span class="line-removed">277                method-&gt;method_holder()-&gt;is_reentrant_initialization(Thread::current()),</span>
<span class="line-removed">278                &quot;invalid class initialization state for invoke_static&quot;);</span>
279       }
280     }
281     if (do_resolve) {
282       set_bytecode_1(invoke_code);
283     }
284   } else if (byte_no == 2)  {
285     if (change_to_virtual) {
286       assert(invoke_code == Bytecodes::_invokeinterface, &quot;&quot;);
287       // NOTE: THIS IS A HACK - BE VERY CAREFUL!!!
288       //
289       // Workaround for the case where we encounter an invokeinterface, but we
290       // should really have an _invokevirtual since the resolved method is a
291       // virtual method in java.lang.Object. This is a corner case in the spec
292       // but is presumably legal. javac does not generate this code.
293       //
294       // We do not set bytecode_1() to _invokeinterface, because that is the
295       // bytecode # used by the interpreter to see if it is resolved.  In this
296       // case, the method gets reresolved with caller for each interface call
297       // because the actual selected method may not be public.
298       //
299       // We set bytecode_2() to _invokevirtual.
300       // See also interpreterRuntime.cpp. (8/25/2000)
301     } else {
302       assert(invoke_code == Bytecodes::_invokevirtual ||
303              (invoke_code == Bytecodes::_invokeinterface &amp;&amp;
304               ((method-&gt;is_private() ||
305                 (method-&gt;is_final() &amp;&amp; method-&gt;method_holder() == SystemDictionary::Object_klass())))),
306              &quot;unexpected invocation mode&quot;);
307       if (invoke_code == Bytecodes::_invokeinterface &amp;&amp;
308           (method-&gt;is_private() || method-&gt;is_final())) {
309         // We set bytecode_1() to _invokeinterface, because that is the
310         // bytecode # used by the interpreter to see if it is resolved.
311         // We set bytecode_2() to _invokevirtual.
312         set_bytecode_1(invoke_code);
313       }
314     }
315     // set up for invokevirtual, even if linking for invokeinterface also:
316     set_bytecode_2(Bytecodes::_invokevirtual);
317   } else {
318     ShouldNotReachHere();
319   }
320   NOT_PRODUCT(verify(tty));
321 }
322 
323 void ConstantPoolCacheEntry::set_direct_call(Bytecodes::Code invoke_code, const methodHandle&amp; method,
<a name="11" id="anc11"></a><span class="line-modified">324                                              bool sender_is_interface, InstanceKlass* pool_holder) {</span>
325   int index = Method::nonvirtual_vtable_index;
326   // index &lt; 0; FIXME: inline and customize set_direct_or_vtable_call
<a name="12" id="anc12"></a><span class="line-modified">327   set_direct_or_vtable_call(invoke_code, method, index, sender_is_interface, pool_holder);</span>
328 }
329 
330 void ConstantPoolCacheEntry::set_vtable_call(Bytecodes::Code invoke_code, const methodHandle&amp; method, int index) {
331   // either the method is a miranda or its holder should accept the given index
332   assert(method-&gt;method_holder()-&gt;is_interface() || method-&gt;method_holder()-&gt;verify_vtable_index(index), &quot;&quot;);
333   // index &gt;= 0; FIXME: inline and customize set_direct_or_vtable_call
<a name="13" id="anc13"></a><span class="line-modified">334   set_direct_or_vtable_call(invoke_code, method, index, false, NULL /* not used */);</span>
335 }
336 
337 void ConstantPoolCacheEntry::set_itable_call(Bytecodes::Code invoke_code,
338                                              Klass* referenced_klass,
339                                              const methodHandle&amp; method, int index) {
340   assert(method-&gt;method_holder()-&gt;verify_itable_index(index), &quot;&quot;);
341   assert(invoke_code == Bytecodes::_invokeinterface, &quot;&quot;);
342   InstanceKlass* interf = method-&gt;method_holder();
343   assert(interf-&gt;is_interface(), &quot;must be an interface&quot;);
344   assert(!method-&gt;is_final_method(), &quot;interfaces do not have final methods; cannot link to one here&quot;);
345   set_f1(referenced_klass);
346   set_f2((intx)method());
347   set_method_flags(as_TosState(method-&gt;result_type()),
348                    0,  // no option bits
349                    method()-&gt;size_of_parameters());
350   set_bytecode_1(Bytecodes::_invokeinterface);
351 }
352 
353 
354 void ConstantPoolCacheEntry::set_method_handle(const constantPoolHandle&amp; cpool, const CallInfo &amp;call_info) {
355   set_method_handle_common(cpool, Bytecodes::_invokehandle, call_info);
356 }
357 
358 void ConstantPoolCacheEntry::set_dynamic_call(const constantPoolHandle&amp; cpool, const CallInfo &amp;call_info) {
359   set_method_handle_common(cpool, Bytecodes::_invokedynamic, call_info);
360 }
361 
362 void ConstantPoolCacheEntry::set_method_handle_common(const constantPoolHandle&amp; cpool,
363                                                       Bytecodes::Code invoke_code,
364                                                       const CallInfo &amp;call_info) {
365   // NOTE: This CPCE can be the subject of data races.
366   // There are three words to update: flags, refs[f2], f1 (in that order).
367   // Writers must store all other values before f1.
368   // Readers must test f1 first for non-null before reading other fields.
369   // Competing writers must acquire exclusive access via a lock.
370   // A losing writer waits on the lock until the winner writes f1 and leaves
371   // the lock, so that when the losing writer returns, he can use the linked
372   // cache entry.
373 
374   objArrayHandle resolved_references(Thread::current(), cpool-&gt;resolved_references());
375   // Use the resolved_references() lock for this cpCache entry.
376   // resolved_references are created for all classes with Invokedynamic, MethodHandle
377   // or MethodType constant pool cache entries.
378   assert(resolved_references() != NULL,
379          &quot;a resolved_references array should have been created for this class&quot;);
380   ObjectLocker ol(resolved_references, Thread::current());
381   if (!is_f1_null()) {
382     return;
383   }
384 
385   if (indy_resolution_failed()) {
386     // Before we got here, another thread got a LinkageError exception during
387     // resolution.  Ignore our success and throw their exception.
388     ConstantPoolCache* cpCache = cpool-&gt;cache();
389     int index = -1;
390     for (int i = 0; i &lt; cpCache-&gt;length(); i++) {
391       if (cpCache-&gt;entry_at(i) == this) {
392         index = i;
393         break;
394       }
395     }
396     guarantee(index &gt;= 0, &quot;Didn&#39;t find cpCache entry!&quot;);
397     int encoded_index = ResolutionErrorTable::encode_cpcache_index(
398                           ConstantPool::encode_invokedynamic_index(index));
399     Thread* THREAD = Thread::current();
400     ConstantPool::throw_resolution_error(cpool, encoded_index, THREAD);
401     return;
402   }
403 
<a name="14" id="anc14"></a><span class="line-modified">404   const methodHandle adapter = call_info.resolved_method();</span>
405   const Handle appendix      = call_info.resolved_appendix();
406   const bool has_appendix    = appendix.not_null();
407 
408   // Write the flags.
409   // MHs and indy are always sig-poly and have a local signature.
410   set_method_flags(as_TosState(adapter-&gt;result_type()),
411                    ((has_appendix    ? 1 : 0) &lt;&lt; has_appendix_shift        ) |
412                    (                   1      &lt;&lt; has_local_signature_shift ) |
413                    (                   1      &lt;&lt; is_final_shift            ),
414                    adapter-&gt;size_of_parameters());
415 
416   if (TraceInvokeDynamic) {
417     ttyLocker ttyl;
418     tty-&gt;print_cr(&quot;set_method_handle bc=%d appendix=&quot; PTR_FORMAT &quot;%s method=&quot; PTR_FORMAT &quot; (local signature) &quot;,
419                   invoke_code,
420                   p2i(appendix()),
421                   (has_appendix ? &quot;&quot; : &quot; (unused)&quot;),
<a name="15" id="anc15"></a><span class="line-modified">422                   p2i(adapter()));</span>
423     adapter-&gt;print();
424     if (has_appendix)  appendix()-&gt;print();
425   }
426 
427   // Method handle invokes and invokedynamic sites use both cp cache words.
428   // refs[f2], if not null, contains a value passed as a trailing argument to the adapter.
429   // In the general case, this could be the call site&#39;s MethodType,
430   // for use with java.lang.Invokers.checkExactType, or else a CallSite object.
431   // f1 contains the adapter method which manages the actual call.
432   // In the general case, this is a compiled LambdaForm.
433   // (The Java code is free to optimize these calls by binding other
434   // sorts of methods and appendices to call sites.)
435   // JVM-level linking is via f1, as if for invokespecial, and signatures are erased.
436   // The appendix argument (if any) is added to the signature, and is counted in the parameter_size bits.
437   // Even with the appendix, the method will never take more than 255 parameter slots.
438   //
439   // This means that given a call site like (List)mh.invoke(&quot;foo&quot;),
440   // the f1 method has signature &#39;(Ljl/Object;Ljl/invoke/MethodType;)Ljl/Object;&#39;,
441   // not &#39;(Ljava/lang/String;)Ljava/util/List;&#39;.
442   // The fact that String and List are involved is encoded in the MethodType in refs[f2].
443   // This allows us to create fewer Methods, while keeping type safety.
444   //
445 
446   // Store appendix, if any.
447   if (has_appendix) {
448     const int appendix_index = f2_as_index();
449     assert(appendix_index &gt;= 0 &amp;&amp; appendix_index &lt; resolved_references-&gt;length(), &quot;oob&quot;);
450     assert(resolved_references-&gt;obj_at(appendix_index) == NULL, &quot;init just once&quot;);
451     resolved_references-&gt;obj_at_put(appendix_index, appendix());
452   }
453 
<a name="16" id="anc16"></a><span class="line-modified">454   release_set_f1(adapter());  // This must be the last one to set (see NOTE above)!</span>
455 
456   // The interpreter assembly code does not check byte_2,
457   // but it is used by is_resolved, method_if_resolved, etc.
458   set_bytecode_1(invoke_code);
459   NOT_PRODUCT(verify(tty));
460   if (TraceInvokeDynamic) {
461     ttyLocker ttyl;
462     this-&gt;print(tty, 0);
463   }
464 
465   assert(has_appendix == this-&gt;has_appendix(), &quot;proper storage of appendix flag&quot;);
466   assert(this-&gt;has_local_signature(), &quot;proper storage of signature flag&quot;);
467 }
468 
469 bool ConstantPoolCacheEntry::save_and_throw_indy_exc(
470   const constantPoolHandle&amp; cpool, int cpool_index, int index, constantTag tag, TRAPS) {
471 
472   assert(HAS_PENDING_EXCEPTION, &quot;No exception got thrown!&quot;);
473   assert(PENDING_EXCEPTION-&gt;is_a(SystemDictionary::LinkageError_klass()),
474          &quot;No LinkageError exception&quot;);
475 
476   // Use the resolved_references() lock for this cpCache entry.
477   // resolved_references are created for all classes with Invokedynamic, MethodHandle
478   // or MethodType constant pool cache entries.
479   objArrayHandle resolved_references(Thread::current(), cpool-&gt;resolved_references());
480   assert(resolved_references() != NULL,
481          &quot;a resolved_references array should have been created for this class&quot;);
482   ObjectLocker ol(resolved_references, THREAD);
483 
484   // if f1 is not null or the indy_resolution_failed flag is set then another
485   // thread either succeeded in resolving the method or got a LinkageError
486   // exception, before this thread was able to record its failure.  So, clear
487   // this thread&#39;s exception and return false so caller can use the earlier
488   // thread&#39;s result.
489   if (!is_f1_null() || indy_resolution_failed()) {
490     CLEAR_PENDING_EXCEPTION;
491     return false;
492   }
493 
494   Symbol* error = PENDING_EXCEPTION-&gt;klass()-&gt;name();
495   Symbol* message = java_lang_Throwable::detail_message(PENDING_EXCEPTION);
496 
497   SystemDictionary::add_resolution_error(cpool, index, error, message);
498   set_indy_resolution_failed();
499   return true;
500 }
501 
502 Method* ConstantPoolCacheEntry::method_if_resolved(const constantPoolHandle&amp; cpool) {
503   // Decode the action of set_method and set_interface_call
504   Bytecodes::Code invoke_code = bytecode_1();
505   if (invoke_code != (Bytecodes::Code)0) {
506     Metadata* f1 = f1_ord();
507     if (f1 != NULL) {
508       switch (invoke_code) {
509       case Bytecodes::_invokeinterface:
510         assert(f1-&gt;is_klass(), &quot;&quot;);
<a name="17" id="anc17"></a><span class="line-modified">511         return klassItable::method_for_itable_index((InstanceKlass*)f1, f2_as_index());</span>
512       case Bytecodes::_invokestatic:
513       case Bytecodes::_invokespecial:
514         assert(!has_appendix(), &quot;&quot;);
515       case Bytecodes::_invokehandle:
516       case Bytecodes::_invokedynamic:
517         assert(f1-&gt;is_method(), &quot;&quot;);
518         return (Method*)f1;
519       default:
520         break;
521       }
522     }
523   }
524   invoke_code = bytecode_2();
525   if (invoke_code != (Bytecodes::Code)0) {
526     switch (invoke_code) {
527     case Bytecodes::_invokevirtual:
528       if (is_vfinal()) {
529         // invokevirtual
530         Method* m = f2_as_vfinal_method();
531         assert(m-&gt;is_method(), &quot;&quot;);
532         return m;
533       } else {
534         int holder_index = cpool-&gt;uncached_klass_ref_index_at(constant_pool_index());
535         if (cpool-&gt;tag_at(holder_index).is_klass()) {
536           Klass* klass = cpool-&gt;resolved_klass_at(holder_index);
537           return klass-&gt;method_at_vtable(f2_as_index());
538         }
539       }
540       break;
541     default:
542       break;
543     }
544   }
545   return NULL;
546 }
547 
548 
549 oop ConstantPoolCacheEntry::appendix_if_resolved(const constantPoolHandle&amp; cpool) {
550   if (!has_appendix())
551     return NULL;
552   const int ref_index = f2_as_index();
553   objArrayOop resolved_references = cpool-&gt;resolved_references();
554   return resolved_references-&gt;obj_at(ref_index);
555 }
556 
557 
558 #if INCLUDE_JVMTI
559 
560 void log_adjust(const char* entry_type, Method* old_method, Method* new_method, bool* trace_name_printed) {
561   if (log_is_enabled(Info, redefine, class, update)) {
562     ResourceMark rm;
563     if (!(*trace_name_printed)) {
564       log_info(redefine, class, update)(&quot;adjust: name=%s&quot;, old_method-&gt;method_holder()-&gt;external_name());
565       *trace_name_printed = true;
566     }
567     log_debug(redefine, class, update, constantpool)
568           (&quot;cpc %s entry update: %s(%s)&quot;, entry_type, new_method-&gt;name()-&gt;as_C_string(), new_method-&gt;signature()-&gt;as_C_string());
569   }
570 }
571 
572 // RedefineClasses() API support:
573 // If this ConstantPoolCacheEntry refers to old_method then update it
574 // to refer to new_method.
575 void ConstantPoolCacheEntry::adjust_method_entry(Method* old_method,
576        Method* new_method, bool * trace_name_printed) {
577 
578   if (is_vfinal()) {
579     // virtual and final so _f2 contains method ptr instead of vtable index
580     if (f2_as_vfinal_method() == old_method) {
581       // match old_method so need an update
582       // NOTE: can&#39;t use set_f2_as_vfinal_method as it asserts on different values
583       _f2 = (intptr_t)new_method;
584       log_adjust(&quot;vfinal&quot;, old_method, new_method, trace_name_printed);
585     }
586     return;
587   }
588 
589   assert (_f1 != NULL, &quot;should not call with uninteresting entry&quot;);
590 
591   if (!(_f1-&gt;is_method())) {
592     // _f1 is a Klass* for an interface, _f2 is the method
593     if (f2_as_interface_method() == old_method) {
594       _f2 = (intptr_t)new_method;
595       log_adjust(&quot;interface&quot;, old_method, new_method, trace_name_printed);
596     }
597   } else if (_f1 == old_method) {
598     _f1 = new_method;
599     log_adjust(&quot;special, static or dynamic&quot;, old_method, new_method, trace_name_printed);
600   }
601 }
602 
603 // a constant pool cache entry should never contain old or obsolete methods
604 bool ConstantPoolCacheEntry::check_no_old_or_obsolete_entries() {
605   Method* m = get_interesting_method_entry();
606   // return false if m refers to a non-deleted old or obsolete method
607   if (m != NULL) {
608     assert(m-&gt;is_valid() &amp;&amp; m-&gt;is_method(), &quot;m is a valid method&quot;);
609     return !m-&gt;is_old() &amp;&amp; !m-&gt;is_obsolete(); // old is always set for old and obsolete
610   } else {
611     return true;
612   }
613 }
614 
615 Method* ConstantPoolCacheEntry::get_interesting_method_entry() {
616   if (!is_method_entry()) {
617     // not a method entry so not interesting by default
618     return NULL;
619   }
620   Method* m = NULL;
621   if (is_vfinal()) {
622     // virtual and final so _f2 contains method ptr instead of vtable index
623     m = f2_as_vfinal_method();
624   } else if (is_f1_null()) {
625     // NULL _f1 means this is a virtual entry so also not interesting
626     return NULL;
627   } else {
628     if (!(_f1-&gt;is_method())) {
629       // _f1 is a Klass* for an interface
630       m = f2_as_interface_method();
631     } else {
632       m = f1_as_method();
633     }
634   }
635   assert(m != NULL &amp;&amp; m-&gt;is_method(), &quot;sanity check&quot;);
636   if (m == NULL || !m-&gt;is_method()) {
637     return NULL;
638   }
639   return m;
640 }
641 #endif // INCLUDE_JVMTI
642 
643 void ConstantPoolCacheEntry::print(outputStream* st, int index) const {
644   // print separator
645   if (index == 0) st-&gt;print_cr(&quot;                 -------------&quot;);
646   // print entry
647   st-&gt;print(&quot;%3d  (&quot; PTR_FORMAT &quot;)  &quot;, index, (intptr_t)this);
648   st-&gt;print_cr(&quot;[%02x|%02x|%5d]&quot;, bytecode_2(), bytecode_1(),
649                constant_pool_index());
650   st-&gt;print_cr(&quot;                 [   &quot; PTR_FORMAT &quot;]&quot;, (intptr_t)_f1);
651   st-&gt;print_cr(&quot;                 [   &quot; PTR_FORMAT &quot;]&quot;, (intptr_t)_f2);
652   st-&gt;print_cr(&quot;                 [   &quot; PTR_FORMAT &quot;]&quot;, (intptr_t)_flags);
653   st-&gt;print_cr(&quot;                 -------------&quot;);
654 }
655 
656 void ConstantPoolCacheEntry::verify(outputStream* st) const {
657   // not implemented yet
658 }
659 
660 // Implementation of ConstantPoolCache
661 
662 ConstantPoolCache* ConstantPoolCache::allocate(ClassLoaderData* loader_data,
663                                      const intStack&amp; index_map,
664                                      const intStack&amp; invokedynamic_index_map,
665                                      const intStack&amp; invokedynamic_map, TRAPS) {
666 
667   const int length = index_map.length() + invokedynamic_index_map.length();
668   int size = ConstantPoolCache::size(length);
669 
670   return new (loader_data, size, MetaspaceObj::ConstantPoolCacheType, THREAD)
671     ConstantPoolCache(length, index_map, invokedynamic_index_map, invokedynamic_map);
672 }
673 
674 void ConstantPoolCache::initialize(const intArray&amp; inverse_index_map,
675                                    const intArray&amp; invokedynamic_inverse_index_map,
676                                    const intArray&amp; invokedynamic_references_map) {
677   for (int i = 0; i &lt; inverse_index_map.length(); i++) {
678     ConstantPoolCacheEntry* e = entry_at(i);
679     int original_index = inverse_index_map.at(i);
680     e-&gt;initialize_entry(original_index);
681     assert(entry_at(i) == e, &quot;sanity&quot;);
682   }
683 
684   // Append invokedynamic entries at the end
685   int invokedynamic_offset = inverse_index_map.length();
686   for (int i = 0; i &lt; invokedynamic_inverse_index_map.length(); i++) {
687     int offset = i + invokedynamic_offset;
688     ConstantPoolCacheEntry* e = entry_at(offset);
689     int original_index = invokedynamic_inverse_index_map.at(i);
690     e-&gt;initialize_entry(original_index);
691     assert(entry_at(offset) == e, &quot;sanity&quot;);
692   }
693 
694   for (int ref = 0; ref &lt; invokedynamic_references_map.length(); ref++) {
695     const int cpci = invokedynamic_references_map.at(ref);
696     if (cpci &gt;= 0) {
697       entry_at(cpci)-&gt;initialize_resolved_reference_index(ref);
698     }
699   }
700 }
701 
702 void ConstantPoolCache::verify_just_initialized() {
703   DEBUG_ONLY(walk_entries_for_initialization(/*check_only = */ true));
704 }
705 
706 void ConstantPoolCache::remove_unshareable_info() {
707   walk_entries_for_initialization(/*check_only = */ false);
708 }
709 
710 void ConstantPoolCache::walk_entries_for_initialization(bool check_only) {
<a name="18" id="anc18"></a><span class="line-modified">711   assert(DumpSharedSpaces, &quot;sanity&quot;);</span>
712   // When dumping the archive, we want to clean up the ConstantPoolCache
713   // to remove any effect of linking due to the execution of Java code --
714   // each ConstantPoolCacheEntry will have the same contents as if
715   // ConstantPoolCache::initialize has just returned:
716   //
717   // - We keep the ConstantPoolCache::constant_pool_index() bits for all entries.
718   // - We keep the &quot;f2&quot; field for entries used by invokedynamic and invokehandle
719   // - All other bits in the entries are cleared to zero.
720   ResourceMark rm;
721 
722   InstanceKlass* ik = constant_pool()-&gt;pool_holder();
723   bool* f2_used = NEW_RESOURCE_ARRAY(bool, length());
724   memset(f2_used, 0, sizeof(bool) * length());
725 
<a name="19" id="anc19"></a>

726   // Find all the slots that we need to preserve f2
727   for (int i = 0; i &lt; ik-&gt;methods()-&gt;length(); i++) {
728     Method* m = ik-&gt;methods()-&gt;at(i);
<a name="20" id="anc20"></a><span class="line-modified">729     RawBytecodeStream bcs(m);</span>
730     while (!bcs.is_last_bytecode()) {
731       Bytecodes::Code opcode = bcs.raw_next();
732       switch (opcode) {
733       case Bytecodes::_invokedynamic: {
734           int index = Bytes::get_native_u4(bcs.bcp() + 1);
735           int cp_cache_index = constant_pool()-&gt;invokedynamic_cp_cache_index(index);
736           f2_used[cp_cache_index] = 1;
737         }
738         break;
739       case Bytecodes::_invokehandle: {
740           int cp_cache_index = Bytes::get_native_u2(bcs.bcp() + 1);
741           f2_used[cp_cache_index] = 1;
742         }
743         break;
744       default:
745         break;
746       }
747     }
748   }
749 
750   if (check_only) {
751     DEBUG_ONLY(
752       for (int i=0; i&lt;length(); i++) {
753         entry_at(i)-&gt;verify_just_initialized(f2_used[i]);
754       })
755   } else {
756     for (int i=0; i&lt;length(); i++) {
757       entry_at(i)-&gt;reinitialize(f2_used[i]);
758     }
759   }
760 }
761 
762 void ConstantPoolCache::deallocate_contents(ClassLoaderData* data) {
763   assert(!is_shared(), &quot;shared caches are not deallocated&quot;);
764   data-&gt;remove_handle(_resolved_references);
765   set_resolved_references(NULL);
766   MetadataFactory::free_array&lt;u2&gt;(data, _reference_map);
767   set_reference_map(NULL);
768 }
769 
770 #if INCLUDE_CDS_JAVA_HEAP
771 oop ConstantPoolCache::archived_references() {
772   if (CompressedOops::is_null(_archived_references)) {
773     return NULL;
774   }
775   return HeapShared::materialize_archived_object(_archived_references);
776 }
777 
778 void ConstantPoolCache::set_archived_references(oop o) {
779   assert(DumpSharedSpaces, &quot;called only during runtime&quot;);
780   _archived_references = CompressedOops::encode(o);
781 }
782 #endif
783 
784 #if INCLUDE_JVMTI
785 // RedefineClasses() API support:
786 // If any entry of this ConstantPoolCache points to any of
787 // old_methods, replace it with the corresponding new_method.
788 void ConstantPoolCache::adjust_method_entries(bool * trace_name_printed) {
789   for (int i = 0; i &lt; length(); i++) {
790     ConstantPoolCacheEntry* entry = entry_at(i);
791     Method* old_method = entry-&gt;get_interesting_method_entry();
792     if (old_method == NULL || !old_method-&gt;is_old()) {
793       continue; // skip uninteresting entries
794     }
795     if (old_method-&gt;is_deleted()) {
796       // clean up entries with deleted methods
797       entry-&gt;initialize_entry(entry-&gt;constant_pool_index());
798       continue;
799     }
800     Method* new_method = old_method-&gt;get_new_method();
801     entry_at(i)-&gt;adjust_method_entry(old_method, new_method, trace_name_printed);
802   }
803 }
804 
805 // the constant pool cache should never contain old or obsolete methods
806 bool ConstantPoolCache::check_no_old_or_obsolete_entries() {
807   for (int i = 1; i &lt; length(); i++) {
808     if (entry_at(i)-&gt;get_interesting_method_entry() != NULL &amp;&amp;
809         !entry_at(i)-&gt;check_no_old_or_obsolete_entries()) {
810       return false;
811     }
812   }
813   return true;
814 }
815 
816 void ConstantPoolCache::dump_cache() {
817   for (int i = 1; i &lt; length(); i++) {
818     if (entry_at(i)-&gt;get_interesting_method_entry() != NULL) {
819       entry_at(i)-&gt;print(tty, i);
820     }
821   }
822 }
823 #endif // INCLUDE_JVMTI
824 
825 void ConstantPoolCache::metaspace_pointers_do(MetaspaceClosure* it) {
826   log_trace(cds)(&quot;Iter(ConstantPoolCache): %p&quot;, this);
827   it-&gt;push(&amp;_constant_pool);
828   it-&gt;push(&amp;_reference_map);
829 }
830 
831 // Printing
832 
833 void ConstantPoolCache::print_on(outputStream* st) const {
834   st-&gt;print_cr(&quot;%s&quot;, internal_name());
835   // print constant pool cache entries
836   for (int i = 0; i &lt; length(); i++) entry_at(i)-&gt;print(st, i);
837 }
838 
839 void ConstantPoolCache::print_value_on(outputStream* st) const {
840   st-&gt;print(&quot;cache [%d]&quot;, length());
841   print_address_on(st);
842   st-&gt;print(&quot; for &quot;);
843   constant_pool()-&gt;print_value_on(st);
844 }
845 
846 
847 // Verification
848 
849 void ConstantPoolCache::verify_on(outputStream* st) {
850   // print constant pool cache entries
851   for (int i = 0; i &lt; length(); i++) entry_at(i)-&gt;verify(st);
852 }
<a name="21" id="anc21"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="21" type="hidden" />
</body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/hotspot/share/oops/instanceKlass.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="fieldInfo.hpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="../prims/jvm.cpp.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/oops/instanceKlass.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 1,7 ***</span>
  /*
<span class="line-modified">!  * Copyright (c) 1997, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.
<span class="line-new-header">--- 1,7 ---</span>
  /*
<span class="line-modified">!  * Copyright (c) 1997, 2020, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 29,10 ***</span>
<span class="line-new-header">--- 29,11 ---</span>
  #include &quot;classfile/classFileStream.hpp&quot;
  #include &quot;classfile/classLoader.hpp&quot;
  #include &quot;classfile/classLoaderData.inline.hpp&quot;
  #include &quot;classfile/javaClasses.hpp&quot;
  #include &quot;classfile/moduleEntry.hpp&quot;
<span class="line-added">+ #include &quot;classfile/symbolTable.hpp&quot;</span>
  #include &quot;classfile/systemDictionary.hpp&quot;
  #include &quot;classfile/systemDictionaryShared.hpp&quot;
  #include &quot;classfile/verifier.hpp&quot;
  #include &quot;classfile/vmSymbols.hpp&quot;
  #include &quot;code/dependencyContext.hpp&quot;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 43,32 ***</span>
  #include &quot;jvmtifiles/jvmti.h&quot;
  #include &quot;logging/log.hpp&quot;
  #include &quot;logging/logMessage.hpp&quot;
  #include &quot;logging/logStream.hpp&quot;
  #include &quot;memory/allocation.inline.hpp&quot;
<span class="line-removed">- #include &quot;memory/heapInspection.hpp&quot;</span>
  #include &quot;memory/iterator.inline.hpp&quot;
  #include &quot;memory/metadataFactory.hpp&quot;
  #include &quot;memory/metaspaceClosure.hpp&quot;
  #include &quot;memory/metaspaceShared.hpp&quot;
  #include &quot;memory/oopFactory.hpp&quot;
  #include &quot;memory/resourceArea.hpp&quot;
<span class="line-modified">! #include &quot;oops/fieldStreams.hpp&quot;</span>
  #include &quot;oops/constantPool.hpp&quot;
  #include &quot;oops/instanceClassLoaderKlass.hpp&quot;
  #include &quot;oops/instanceKlass.inline.hpp&quot;
  #include &quot;oops/instanceMirrorKlass.hpp&quot;
  #include &quot;oops/instanceOop.hpp&quot;
  #include &quot;oops/klass.inline.hpp&quot;
  #include &quot;oops/method.hpp&quot;
  #include &quot;oops/oop.inline.hpp&quot;
  #include &quot;oops/symbol.hpp&quot;
  #include &quot;prims/jvmtiExport.hpp&quot;
  #include &quot;prims/jvmtiRedefineClasses.hpp&quot;
  #include &quot;prims/jvmtiThreadState.hpp&quot;
  #include &quot;prims/methodComparator.hpp&quot;
  #include &quot;runtime/atomic.hpp&quot;
  #include &quot;runtime/fieldDescriptor.inline.hpp&quot;
  #include &quot;runtime/handles.inline.hpp&quot;
  #include &quot;runtime/javaCalls.hpp&quot;
  #include &quot;runtime/mutexLocker.hpp&quot;
  #include &quot;runtime/orderAccess.hpp&quot;
<span class="line-new-header">--- 44,34 ---</span>
  #include &quot;jvmtifiles/jvmti.h&quot;
  #include &quot;logging/log.hpp&quot;
  #include &quot;logging/logMessage.hpp&quot;
  #include &quot;logging/logStream.hpp&quot;
  #include &quot;memory/allocation.inline.hpp&quot;
  #include &quot;memory/iterator.inline.hpp&quot;
  #include &quot;memory/metadataFactory.hpp&quot;
  #include &quot;memory/metaspaceClosure.hpp&quot;
  #include &quot;memory/metaspaceShared.hpp&quot;
  #include &quot;memory/oopFactory.hpp&quot;
  #include &quot;memory/resourceArea.hpp&quot;
<span class="line-modified">! #include &quot;memory/universe.hpp&quot;</span>
<span class="line-added">+ #include &quot;oops/fieldStreams.inline.hpp&quot;</span>
  #include &quot;oops/constantPool.hpp&quot;
  #include &quot;oops/instanceClassLoaderKlass.hpp&quot;
  #include &quot;oops/instanceKlass.inline.hpp&quot;
  #include &quot;oops/instanceMirrorKlass.hpp&quot;
  #include &quot;oops/instanceOop.hpp&quot;
  #include &quot;oops/klass.inline.hpp&quot;
  #include &quot;oops/method.hpp&quot;
  #include &quot;oops/oop.inline.hpp&quot;
<span class="line-added">+ #include &quot;oops/recordComponent.hpp&quot;</span>
  #include &quot;oops/symbol.hpp&quot;
  #include &quot;prims/jvmtiExport.hpp&quot;
  #include &quot;prims/jvmtiRedefineClasses.hpp&quot;
  #include &quot;prims/jvmtiThreadState.hpp&quot;
  #include &quot;prims/methodComparator.hpp&quot;
  #include &quot;runtime/atomic.hpp&quot;
<span class="line-added">+ #include &quot;runtime/biasedLocking.hpp&quot;</span>
  #include &quot;runtime/fieldDescriptor.inline.hpp&quot;
  #include &quot;runtime/handles.inline.hpp&quot;
  #include &quot;runtime/javaCalls.hpp&quot;
  #include &quot;runtime/mutexLocker.hpp&quot;
  #include &quot;runtime/orderAccess.hpp&quot;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 434,13 ***</span>
<span class="line-new-header">--- 437,16 ---</span>
  InstanceKlass::InstanceKlass(const ClassFileParser&amp; parser, unsigned kind, KlassID id) :
    Klass(id),
    _nest_members(NULL),
    _nest_host_index(0),
    _nest_host(NULL),
<span class="line-added">+   _record_components(NULL),</span>
    _static_field_size(parser.static_field_size()),
    _nonstatic_oop_map_size(nonstatic_oop_map_size(parser.total_oop_map_count())),
    _itable_len(parser.itable_size()),
<span class="line-added">+   _init_thread(NULL),</span>
<span class="line-added">+   _init_state(allocated),</span>
    _reference_type(parser.reference_type())
  {
    set_vtable_length(parser.vtable_size());
    set_kind(kind);
    set_access_flags(parser.access_flags());
</pre>
<hr />
<pre>
<span class="line-old-header">*** 450,13 ***</span>
  
    assert(NULL == _methods, &quot;underlying memory not zeroed?&quot;);
    assert(is_instance_klass(), &quot;is layout incorrect?&quot;);
    assert(size_helper() == parser.layout_size(), &quot;incorrect size_helper?&quot;);
  
<span class="line-modified">!   if (DumpSharedSpaces) {</span>
      SystemDictionaryShared::init_dumptime_info(this);
    }
  }
  
  void InstanceKlass::deallocate_methods(ClassLoaderData* loader_data,
                                         Array&lt;Method*&gt;* methods) {
    if (methods != NULL &amp;&amp; methods != Universe::the_empty_method_array() &amp;&amp;
<span class="line-new-header">--- 456,19 ---</span>
  
    assert(NULL == _methods, &quot;underlying memory not zeroed?&quot;);
    assert(is_instance_klass(), &quot;is layout incorrect?&quot;);
    assert(size_helper() == parser.layout_size(), &quot;incorrect size_helper?&quot;);
  
<span class="line-modified">!   if (Arguments::is_dumping_archive()) {</span>
      SystemDictionaryShared::init_dumptime_info(this);
    }
<span class="line-added">+ </span>
<span class="line-added">+   // Set biased locking bit for all instances of this class; it will be</span>
<span class="line-added">+   // cleared if revocation occurs too often for this type</span>
<span class="line-added">+   if (UseBiasedLocking &amp;&amp; BiasedLocking::enabled()) {</span>
<span class="line-added">+     set_prototype_header(markWord::biased_locking_prototype());</span>
<span class="line-added">+   }</span>
  }
  
  void InstanceKlass::deallocate_methods(ClassLoaderData* loader_data,
                                         Array&lt;Method*&gt;* methods) {
    if (methods != NULL &amp;&amp; methods != Universe::the_empty_method_array() &amp;&amp;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 494,10 ***</span>
<span class="line-new-header">--- 506,21 ---</span>
        local_interfaces != NULL &amp;&amp; !local_interfaces-&gt;is_shared()) {
      MetadataFactory::free_array&lt;InstanceKlass*&gt;(loader_data, local_interfaces);
    }
  }
  
<span class="line-added">+ void InstanceKlass::deallocate_record_components(ClassLoaderData* loader_data,</span>
<span class="line-added">+                                                  Array&lt;RecordComponent*&gt;* record_components) {</span>
<span class="line-added">+   if (record_components != NULL &amp;&amp; !record_components-&gt;is_shared()) {</span>
<span class="line-added">+     for (int i = 0; i &lt; record_components-&gt;length(); i++) {</span>
<span class="line-added">+       RecordComponent* record_component = record_components-&gt;at(i);</span>
<span class="line-added">+       MetadataFactory::free_metadata(loader_data, record_component);</span>
<span class="line-added">+     }</span>
<span class="line-added">+     MetadataFactory::free_array&lt;RecordComponent*&gt;(loader_data, record_components);</span>
<span class="line-added">+   }</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
  // This function deallocates the metadata and C heap pointers that the
  // InstanceKlass points to.
  void InstanceKlass::deallocate_contents(ClassLoaderData* loader_data) {
  
    // Orphan the mirror first, CMS thinks it&#39;s still live.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 522,10 ***</span>
<span class="line-new-header">--- 545,13 ---</span>
    release_C_heap_structures();
  
    deallocate_methods(loader_data, methods());
    set_methods(NULL);
  
<span class="line-added">+   deallocate_record_components(loader_data, record_components());</span>
<span class="line-added">+   set_record_components(NULL);</span>
<span class="line-added">+ </span>
    if (method_ordering() != NULL &amp;&amp;
        method_ordering() != Universe::the_empty_int_array() &amp;&amp;
        !method_ordering()-&gt;is_shared()) {
      MetadataFactory::free_array&lt;int&gt;(loader_data, method_ordering());
    }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 600,11 ***</span>
    if (annotations() != NULL &amp;&amp; !annotations()-&gt;is_shared()) {
      MetadataFactory::free_metadata(loader_data, annotations());
    }
    set_annotations(NULL);
  
<span class="line-modified">!   if (DumpSharedSpaces) {</span>
      SystemDictionaryShared::remove_dumptime_info(this);
    }
  }
  
  bool InstanceKlass::should_be_initialized() const {
<span class="line-new-header">--- 626,11 ---</span>
    if (annotations() != NULL &amp;&amp; !annotations()-&gt;is_shared()) {
      MetadataFactory::free_metadata(loader_data, annotations());
    }
    set_annotations(NULL);
  
<span class="line-modified">!   if (Arguments::is_dumping_archive()) {</span>
      SystemDictionaryShared::remove_dumptime_info(this);
    }
  }
  
  bool InstanceKlass::should_be_initialized() const {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 957,11 ***</span>
      // we might end up throwing IE from link/symbol resolution sites
      // that aren&#39;t expected to throw.  This would wreak havoc.  See 6320309.
      while (is_being_initialized() &amp;&amp; !is_reentrant_initialization(jt)) {
        wait = true;
        jt-&gt;set_class_to_be_initialized(this);
<span class="line-modified">!       ol.waitUninterruptibly(jt);</span>
        jt-&gt;set_class_to_be_initialized(NULL);
      }
  
      // Step 3
      if (is_being_initialized() &amp;&amp; is_reentrant_initialization(jt)) {
<span class="line-new-header">--- 983,11 ---</span>
      // we might end up throwing IE from link/symbol resolution sites
      // that aren&#39;t expected to throw.  This would wreak havoc.  See 6320309.
      while (is_being_initialized() &amp;&amp; !is_reentrant_initialization(jt)) {
        wait = true;
        jt-&gt;set_class_to_be_initialized(this);
<span class="line-modified">!       ol.wait_uninterruptibly(jt);</span>
        jt-&gt;set_class_to_be_initialized(NULL);
      }
  
      // Step 3
      if (is_being_initialized() &amp;&amp; is_reentrant_initialization(jt)) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1091,42 ***</span>
        // fully_initialized and the later checking if it&#39;s initialized.
        void* const lock_address = reinterpret_cast&lt;void*&gt;(
            java_lang_Class::init_lock_addr(java_mirror()));
        SharedRuntime::tsan_release(lock_address);
      );
      set_init_state(state);
      fence_and_clear_init_lock();
      ol.notify_all(CHECK);
    } else {
      assert(h_init_lock() != NULL, &quot;The initialization state should never be set twice&quot;);
      set_init_state(state);
    }
  }
  
  Klass* InstanceKlass::implementor() const {
    Klass* volatile* k = adr_implementor();
    if (k == NULL) {
      return NULL;
    } else {
      // This load races with inserts, and therefore needs acquire.
<span class="line-modified">!     Klass* kls = OrderAccess::load_acquire(k);</span>
      if (kls != NULL &amp;&amp; !kls-&gt;is_loader_alive()) {
        return NULL;  // don&#39;t return unloaded class
      } else {
        return kls;
      }
    }
  }
  
  
  void InstanceKlass::set_implementor(Klass* k) {
<span class="line-modified">!   assert_lock_strong(Compile_lock);</span>
    assert(is_interface(), &quot;not interface&quot;);
    Klass* volatile* addr = adr_implementor();
    assert(addr != NULL, &quot;null addr&quot;);
    if (addr != NULL) {
<span class="line-modified">!     OrderAccess::release_store(addr, k);</span>
    }
  }
  
  int  InstanceKlass::nof_implementors() const {
    Klass* k = implementor();
<span class="line-new-header">--- 1117,44 ---</span>
        // fully_initialized and the later checking if it&#39;s initialized.
        void* const lock_address = reinterpret_cast&lt;void*&gt;(
            java_lang_Class::init_lock_addr(java_mirror()));
        SharedRuntime::tsan_release(lock_address);
      );
<span class="line-added">+     set_init_thread(NULL); // reset _init_thread before changing _init_state</span>
      set_init_state(state);
      fence_and_clear_init_lock();
      ol.notify_all(CHECK);
    } else {
      assert(h_init_lock() != NULL, &quot;The initialization state should never be set twice&quot;);
<span class="line-added">+     set_init_thread(NULL); // reset _init_thread before changing _init_state</span>
      set_init_state(state);
    }
  }
  
  Klass* InstanceKlass::implementor() const {
    Klass* volatile* k = adr_implementor();
    if (k == NULL) {
      return NULL;
    } else {
      // This load races with inserts, and therefore needs acquire.
<span class="line-modified">!     Klass* kls = Atomic::load_acquire(k);</span>
      if (kls != NULL &amp;&amp; !kls-&gt;is_loader_alive()) {
        return NULL;  // don&#39;t return unloaded class
      } else {
        return kls;
      }
    }
  }
  
  
  void InstanceKlass::set_implementor(Klass* k) {
<span class="line-modified">!   assert_locked_or_safepoint(Compile_lock);</span>
    assert(is_interface(), &quot;not interface&quot;);
    Klass* volatile* addr = adr_implementor();
    assert(addr != NULL, &quot;null addr&quot;);
    if (addr != NULL) {
<span class="line-modified">!     Atomic::release_store(addr, k);</span>
    }
  }
  
  int  InstanceKlass::nof_implementors() const {
    Klass* k = implementor();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1166,11 ***</span>
      return;
  
    Klass* ik = implementor();
    if (ik == NULL) {
      set_implementor(k);
<span class="line-modified">!   } else if (ik != this) {</span>
      // There is already an implementor. Use itself as an indicator of
      // more than one implementors.
      set_implementor(this);
    }
  
<span class="line-new-header">--- 1194,11 ---</span>
      return;
  
    Klass* ik = implementor();
    if (ik == NULL) {
      set_implementor(k);
<span class="line-modified">!   } else if (ik != this &amp;&amp; ik != k) {</span>
      // There is already an implementor. Use itself as an indicator of
      // more than one implementors.
      set_implementor(this);
    }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1312,15 ***</span>
  Klass* InstanceKlass::array_klass_impl(bool or_null, int n, TRAPS) {
    // Need load-acquire for lock-free read
    if (array_klasses_acquire() == NULL) {
      if (or_null) return NULL;
  
<span class="line-modified">!     ResourceMark rm;</span>
      JavaThread *jt = (JavaThread *)THREAD;
      {
        // Atomic creation of array_klasses
<span class="line-modified">!       MutexLocker ma(MultiArray_lock, THREAD);</span>
  
        // Check if update has already taken place
        if (array_klasses() == NULL) {
          Klass*    k = ObjArrayKlass::allocate_objArray_klass(class_loader_data(), 1, this, CHECK_NULL);
          // use &#39;release&#39; to pair with lock-free load
<span class="line-new-header">--- 1340,15 ---</span>
  Klass* InstanceKlass::array_klass_impl(bool or_null, int n, TRAPS) {
    // Need load-acquire for lock-free read
    if (array_klasses_acquire() == NULL) {
      if (or_null) return NULL;
  
<span class="line-modified">!     ResourceMark rm(THREAD);</span>
      JavaThread *jt = (JavaThread *)THREAD;
      {
        // Atomic creation of array_klasses
<span class="line-modified">!       MutexLocker ma(THREAD, MultiArray_lock);</span>
  
        // Check if update has already taken place
        if (array_klasses() == NULL) {
          Klass*    k = ObjArrayKlass::allocate_objArray_klass(class_loader_data(), 1, this, CHECK_NULL);
          // use &#39;release&#39; to pair with lock-free load
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1361,11 ***</span>
  
    methodHandle h_method(THREAD, class_initializer());
    assert(!is_initialized(), &quot;we cannot initialize twice&quot;);
    LogTarget(Info, class, init) lt;
    if (lt.is_enabled()) {
<span class="line-modified">!     ResourceMark rm;</span>
      LogStream ls(lt);
      ls.print(&quot;%d Initializing &quot;, call_class_initializer_counter++);
      name()-&gt;print_value_on(&amp;ls);
      ls.print_cr(&quot;%s (&quot; INTPTR_FORMAT &quot;)&quot;, h_method() == NULL ? &quot;(no method)&quot; : &quot;&quot;, p2i(this));
    }
<span class="line-new-header">--- 1389,11 ---</span>
  
    methodHandle h_method(THREAD, class_initializer());
    assert(!is_initialized(), &quot;we cannot initialize twice&quot;);
    LogTarget(Info, class, init) lt;
    if (lt.is_enabled()) {
<span class="line-modified">!     ResourceMark rm(THREAD);</span>
      LogStream ls(lt);
      ls.print(&quot;%d Initializing &quot;, call_class_initializer_counter++);
      name()-&gt;print_value_on(&amp;ls);
      ls.print_cr(&quot;%s (&quot; INTPTR_FORMAT &quot;)&quot;, h_method() == NULL ? &quot;(no method)&quot; : &quot;&quot;, p2i(this));
    }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1379,24 ***</span>
  
  void InstanceKlass::mask_for(const methodHandle&amp; method, int bci,
    InterpreterOopMap* entry_for) {
    // Lazily create the _oop_map_cache at first request
    // Lock-free access requires load_acquire.
<span class="line-modified">!   OopMapCache* oop_map_cache = OrderAccess::load_acquire(&amp;_oop_map_cache);</span>
    if (oop_map_cache == NULL) {
      MutexLocker x(OopMapCacheAlloc_lock);
      // Check if _oop_map_cache was allocated while we were waiting for this lock
      if ((oop_map_cache = _oop_map_cache) == NULL) {
        oop_map_cache = new OopMapCache();
        // Ensure _oop_map_cache is stable, since it is examined without a lock
<span class="line-modified">!       OrderAccess::release_store(&amp;_oop_map_cache, oop_map_cache);</span>
      }
    }
    // _oop_map_cache is constant after init; lookup below does its own locking.
    oop_map_cache-&gt;lookup(method, bci, entry_for);
  }
  
  
  bool InstanceKlass::find_local_field(Symbol* name, Symbol* sig, fieldDescriptor* fd) const {
    for (JavaFieldStream fs(this); !fs.done(); fs.next()) {
      Symbol* f_name = fs.name();
      Symbol* f_sig  = fs.signature();
<span class="line-new-header">--- 1407,28 ---</span>
  
  void InstanceKlass::mask_for(const methodHandle&amp; method, int bci,
    InterpreterOopMap* entry_for) {
    // Lazily create the _oop_map_cache at first request
    // Lock-free access requires load_acquire.
<span class="line-modified">!   OopMapCache* oop_map_cache = Atomic::load_acquire(&amp;_oop_map_cache);</span>
    if (oop_map_cache == NULL) {
      MutexLocker x(OopMapCacheAlloc_lock);
      // Check if _oop_map_cache was allocated while we were waiting for this lock
      if ((oop_map_cache = _oop_map_cache) == NULL) {
        oop_map_cache = new OopMapCache();
        // Ensure _oop_map_cache is stable, since it is examined without a lock
<span class="line-modified">!       Atomic::release_store(&amp;_oop_map_cache, oop_map_cache);</span>
      }
    }
    // _oop_map_cache is constant after init; lookup below does its own locking.
    oop_map_cache-&gt;lookup(method, bci, entry_for);
  }
  
<span class="line-added">+ bool InstanceKlass::contains_field_offset(int offset) {</span>
<span class="line-added">+   fieldDescriptor fd;</span>
<span class="line-added">+   return find_field_from_offset(offset, false, &amp;fd);</span>
<span class="line-added">+ }</span>
  
  bool InstanceKlass::find_local_field(Symbol* name, Symbol* sig, fieldDescriptor* fd) const {
    for (JavaFieldStream fs(this); !fs.done(); fs.next()) {
      Symbol* f_name = fs.name();
      Symbol* f_sig  = fs.signature();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1586,15 ***</span>
    }
    return -1;
  }
  #endif
  
<span class="line-modified">! static int binary_search(const Array&lt;Method*&gt;* methods, const Symbol* name) {</span>
    int len = methods-&gt;length();
<span class="line-removed">-   // methods are sorted, so do binary search</span>
    int l = 0;
    int h = len - 1;
    while (l &lt;= h) {
      int mid = (l + h) &gt;&gt; 1;
      Method* m = methods-&gt;at(mid);
      assert(m-&gt;is_method(), &quot;must be method&quot;);
      int res = m-&gt;name()-&gt;fast_compare(name);
<span class="line-new-header">--- 1618,41 ---</span>
    }
    return -1;
  }
  #endif
  
<span class="line-modified">! bool InstanceKlass::_disable_method_binary_search = false;</span>
<span class="line-added">+ </span>
<span class="line-added">+ NOINLINE int linear_search(const Array&lt;Method*&gt;* methods, const Symbol* name) {</span>
<span class="line-added">+   int len = methods-&gt;length();</span>
<span class="line-added">+   int l = 0;</span>
<span class="line-added">+   int h = len - 1;</span>
<span class="line-added">+   while (l &lt;= h) {</span>
<span class="line-added">+     Method* m = methods-&gt;at(l);</span>
<span class="line-added">+     if (m-&gt;name() == name) {</span>
<span class="line-added">+       return l;</span>
<span class="line-added">+     }</span>
<span class="line-added">+     l++;</span>
<span class="line-added">+   }</span>
<span class="line-added">+   return -1;</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ inline int InstanceKlass::quick_search(const Array&lt;Method*&gt;* methods, const Symbol* name) {</span>
<span class="line-added">+   if (_disable_method_binary_search) {</span>
<span class="line-added">+     assert(DynamicDumpSharedSpaces, &quot;must be&quot;);</span>
<span class="line-added">+     // At the final stage of dynamic dumping, the methods array may not be sorted</span>
<span class="line-added">+     // by ascending addresses of their names, so we can&#39;t use binary search anymore.</span>
<span class="line-added">+     // However, methods with the same name are still laid out consecutively inside the</span>
<span class="line-added">+     // methods array, so let&#39;s look for the first one that matches.</span>
<span class="line-added">+     return linear_search(methods, name);</span>
<span class="line-added">+   }</span>
<span class="line-added">+ </span>
    int len = methods-&gt;length();
    int l = 0;
    int h = len - 1;
<span class="line-added">+ </span>
<span class="line-added">+   // methods are sorted by ascending addresses of their names, so do binary search</span>
    while (l &lt;= h) {
      int mid = (l + h) &gt;&gt; 1;
      Method* m = methods-&gt;at(mid);
      assert(m-&gt;is_method(), &quot;must be method&quot;);
      int res = m-&gt;name()-&gt;fast_compare(name);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1742,11 ***</span>
                                       StaticLookupMode static_mode,
                                       PrivateLookupMode private_mode) {
    const bool skipping_overpass = (overpass_mode == skip_overpass);
    const bool skipping_static = (static_mode == skip_static);
    const bool skipping_private = (private_mode == skip_private);
<span class="line-modified">!   const int hit = binary_search(methods, name);</span>
    if (hit != -1) {
      const Method* const m = methods-&gt;at(hit);
  
      // Do linear search to find matching signature.  First, quick check
      // for common case, ignoring overpasses if requested.
<span class="line-new-header">--- 1800,11 ---</span>
                                       StaticLookupMode static_mode,
                                       PrivateLookupMode private_mode) {
    const bool skipping_overpass = (overpass_mode == skip_overpass);
    const bool skipping_static = (static_mode == skip_static);
    const bool skipping_private = (private_mode == skip_private);
<span class="line-modified">!   const int hit = quick_search(methods, name);</span>
    if (hit != -1) {
      const Method* const m = methods-&gt;at(hit);
  
      // Do linear search to find matching signature.  First, quick check
      // for common case, ignoring overpasses if requested.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1793,11 ***</span>
  
  int InstanceKlass::find_method_by_name(const Array&lt;Method*&gt;* methods,
                                         const Symbol* name,
                                         int* end_ptr) {
    assert(end_ptr != NULL, &quot;just checking&quot;);
<span class="line-modified">!   int start = binary_search(methods, name);</span>
    int end = start + 1;
    if (start != -1) {
      while (start - 1 &gt;= 0 &amp;&amp; (methods-&gt;at(start - 1))-&gt;name() == name) --start;
      while (end &lt; methods-&gt;length() &amp;&amp; (methods-&gt;at(end))-&gt;name() == name) ++end;
      *end_ptr = end;
<span class="line-new-header">--- 1851,11 ---</span>
  
  int InstanceKlass::find_method_by_name(const Array&lt;Method*&gt;* methods,
                                         const Symbol* name,
                                         int* end_ptr) {
    assert(end_ptr != NULL, &quot;just checking&quot;);
<span class="line-modified">!   int start = quick_search(methods, name);</span>
    int end = start + 1;
    if (start != -1) {
      while (start - 1 &gt;= 0 &amp;&amp; (methods-&gt;at(start - 1))-&gt;name() == name) --start;
      while (end &lt; methods-&gt;length() &amp;&amp; (methods-&gt;at(end))-&gt;name() == name) ++end;
      *end_ptr = end;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1970,11 ***</span>
        if (Threads::number_of_threads() == 0 ||
            SafepointSynchronize::is_at_safepoint()) {
          // we&#39;re single threaded or at a safepoint - no locking needed
          get_jmethod_id_length_value(jmeths, idnum, &amp;length, &amp;id);
        } else {
<span class="line-modified">!         MutexLocker ml(JmethodIdCreation_lock);</span>
          get_jmethod_id_length_value(jmeths, idnum, &amp;length, &amp;id);
        }
      }
    }
    // implied else:
<span class="line-new-header">--- 2028,11 ---</span>
        if (Threads::number_of_threads() == 0 ||
            SafepointSynchronize::is_at_safepoint()) {
          // we&#39;re single threaded or at a safepoint - no locking needed
          get_jmethod_id_length_value(jmeths, idnum, &amp;length, &amp;id);
        } else {
<span class="line-modified">!         MutexLocker ml(JmethodIdCreation_lock, Mutex::_no_safepoint_check_flag);</span>
          get_jmethod_id_length_value(jmeths, idnum, &amp;length, &amp;id);
        }
      }
    }
    // implied else:
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2020,11 ***</span>
          SafepointSynchronize::is_at_safepoint()) {
        // we&#39;re single threaded or at a safepoint - no locking needed
        id = get_jmethod_id_fetch_or_update(idnum, new_id, new_jmeths,
                                            &amp;to_dealloc_id, &amp;to_dealloc_jmeths);
      } else {
<span class="line-modified">!       MutexLocker ml(JmethodIdCreation_lock);</span>
        id = get_jmethod_id_fetch_or_update(idnum, new_id, new_jmeths,
                                            &amp;to_dealloc_id, &amp;to_dealloc_jmeths);
      }
  
      // The lock has been dropped so we can free resources.
<span class="line-new-header">--- 2078,11 ---</span>
          SafepointSynchronize::is_at_safepoint()) {
        // we&#39;re single threaded or at a safepoint - no locking needed
        id = get_jmethod_id_fetch_or_update(idnum, new_id, new_jmeths,
                                            &amp;to_dealloc_id, &amp;to_dealloc_jmeths);
      } else {
<span class="line-modified">!       MutexLocker ml(JmethodIdCreation_lock, Mutex::_no_safepoint_check_flag);</span>
        id = get_jmethod_id_fetch_or_update(idnum, new_id, new_jmeths,
                                            &amp;to_dealloc_id, &amp;to_dealloc_jmeths);
      }
  
      // The lock has been dropped so we can free resources.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2104,11 ***</span>
      id = new_id;
  
      // The jmethodID cache can be read while unlocked so we have to
      // make sure the new jmethodID is complete before installing it
      // in the cache.
<span class="line-modified">!     OrderAccess::release_store(&amp;jmeths[idnum+1], id);</span>
    } else {
      *to_dealloc_id_p = new_id; // save new id for later delete
    }
    return id;
  }
<span class="line-new-header">--- 2162,11 ---</span>
      id = new_id;
  
      // The jmethodID cache can be read while unlocked so we have to
      // make sure the new jmethodID is complete before installing it
      // in the cache.
<span class="line-modified">!     Atomic::release_store(&amp;jmeths[idnum+1], id);</span>
    } else {
      *to_dealloc_id_p = new_id; // save new id for later delete
    }
    return id;
  }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2186,15 ***</span>
    assert(is_loader_alive(), &quot;this klass should be live&quot;);
    if (is_interface()) {
      assert (ClassUnloading, &quot;only called for ClassUnloading&quot;);
      for (;;) {
        // Use load_acquire due to competing with inserts
<span class="line-modified">!       Klass* impl = OrderAccess::load_acquire(adr_implementor());</span>
        if (impl != NULL &amp;&amp; !impl-&gt;is_loader_alive()) {
          // NULL this field, might be an unloaded klass or NULL
          Klass* volatile* klass = adr_implementor();
<span class="line-modified">!         if (Atomic::cmpxchg((Klass*)NULL, klass, impl) == impl) {</span>
            // Successfully unlinking implementor.
            if (log_is_enabled(Trace, class, unload)) {
              ResourceMark rm;
              log_trace(class, unload)(&quot;unlinking class (implementor): %s&quot;, impl-&gt;external_name());
            }
<span class="line-new-header">--- 2244,15 ---</span>
    assert(is_loader_alive(), &quot;this klass should be live&quot;);
    if (is_interface()) {
      assert (ClassUnloading, &quot;only called for ClassUnloading&quot;);
      for (;;) {
        // Use load_acquire due to competing with inserts
<span class="line-modified">!       Klass* impl = Atomic::load_acquire(adr_implementor());</span>
        if (impl != NULL &amp;&amp; !impl-&gt;is_loader_alive()) {
          // NULL this field, might be an unloaded klass or NULL
          Klass* volatile* klass = adr_implementor();
<span class="line-modified">!         if (Atomic::cmpxchg(klass, impl, (Klass*)NULL) == impl) {</span>
            // Successfully unlinking implementor.
            if (log_is_enabled(Trace, class, unload)) {
              ResourceMark rm;
              log_trace(class, unload)(&quot;unlinking class (implementor): %s&quot;, impl-&gt;external_name());
            }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2209,11 ***</span>
  
  void InstanceKlass::clean_method_data() {
    for (int m = 0; m &lt; methods()-&gt;length(); m++) {
      MethodData* mdo = methods()-&gt;at(m)-&gt;method_data();
      if (mdo != NULL) {
<span class="line-modified">!       MutexLockerEx ml(SafepointSynchronize::is_at_safepoint() ? NULL : mdo-&gt;extra_data_lock());</span>
        mdo-&gt;clean_method_data(/*always_clean*/false);
      }
    }
  }
  
<span class="line-new-header">--- 2267,11 ---</span>
  
  void InstanceKlass::clean_method_data() {
    for (int m = 0; m &lt; methods()-&gt;length(); m++) {
      MethodData* mdo = methods()-&gt;at(m)-&gt;method_data();
      if (mdo != NULL) {
<span class="line-modified">!       MutexLocker ml(SafepointSynchronize::is_at_safepoint() ? NULL : mdo-&gt;extra_data_lock());</span>
        mdo-&gt;clean_method_data(/*always_clean*/false);
      }
    }
  }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2245,12 ***</span>
    // We store the fingerprint into the InstanceKlass only in the following 2 cases:
    if (CalculateClassFingerprint) {
      // (1) We are running AOT to generate a shared library.
      return true;
    }
<span class="line-modified">!   if (DumpSharedSpaces) {</span>
<span class="line-modified">!     // (2) We are running -Xshare:dump to create a shared archive</span>
      return true;
    }
    if (UseAOT &amp;&amp; is_unsafe_anonymous) {
      // (3) We are using AOT code from a shared library and see an unsafe anonymous class
      return true;
<span class="line-new-header">--- 2303,12 ---</span>
    // We store the fingerprint into the InstanceKlass only in the following 2 cases:
    if (CalculateClassFingerprint) {
      // (1) We are running AOT to generate a shared library.
      return true;
    }
<span class="line-modified">!   if (Arguments::is_dumping_archive()) {</span>
<span class="line-modified">!     // (2) We are running -Xshare:dump or -XX:ArchiveClassesAtExit to create a shared archive</span>
      return true;
    }
    if (UseAOT &amp;&amp; is_unsafe_anonymous) {
      // (3) We are using AOT code from a shared library and see an unsafe anonymous class
      return true;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2329,10 ***</span>
<span class="line-new-header">--- 2387,11 ---</span>
        }
      }
    }
  
    it-&gt;push(&amp;_nest_members);
<span class="line-added">+   it-&gt;push(&amp;_record_components);</span>
  }
  
  void InstanceKlass::remove_unshareable_info() {
    Klass::remove_unshareable_info();
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2349,12 ***</span>
    // a shared class at runtime while the class is still being loaded and
    // restored. A class&#39; init_state is set to &#39;loaded&#39; at runtime when it&#39;s
    // being added to class hierarchy (see SystemDictionary:::add_to_hierarchy()).
    _init_state = allocated;
  
<span class="line-modified">!   {</span>
<span class="line-modified">!     MutexLocker ml(Compile_lock);</span>
      init_implementor();
    }
  
    constants()-&gt;remove_unshareable_info();
  
<span class="line-new-header">--- 2408,12 ---</span>
    // a shared class at runtime while the class is still being loaded and
    // restored. A class&#39; init_state is set to &#39;loaded&#39; at runtime when it&#39;s
    // being added to class hierarchy (see SystemDictionary:::add_to_hierarchy()).
    _init_state = allocated;
  
<span class="line-modified">!   { // Otherwise this needs to take out the Compile_lock.</span>
<span class="line-modified">!     assert(SafepointSynchronize::is_at_safepoint(), &quot;only called at safepoint&quot;);</span>
      init_implementor();
    }
  
    constants()-&gt;remove_unshareable_info();
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2366,28 ***</span>
    // do array classes also.
    if (array_klasses() != NULL) {
      array_klasses()-&gt;remove_unshareable_info();
    }
  
<span class="line-modified">!   // These are not allocated from metaspace, but they should should all be empty</span>
<span class="line-modified">!   // during dump time, so we don&#39;t need to worry about them in InstanceKlass::iterate().</span>
<span class="line-modified">!   guarantee(_source_debug_extension == NULL, &quot;must be&quot;);</span>
<span class="line-modified">!   guarantee(_dep_context == NULL, &quot;must be&quot;);</span>
<span class="line-removed">-   guarantee(_osr_nmethods_head == NULL, &quot;must be&quot;);</span>
<span class="line-removed">- </span>
  #if INCLUDE_JVMTI
<span class="line-modified">!   guarantee(_breakpoints == NULL, &quot;must be&quot;);</span>
<span class="line-modified">!   guarantee(_previous_versions == NULL, &quot;must be&quot;);</span>
    _cached_class_file = NULL;
  #endif
  
    _init_thread = NULL;
    _methods_jmethod_ids = NULL;
    _jni_ids = NULL;
    _oop_map_cache = NULL;
    // clear _nest_host to ensure re-load at runtime
    _nest_host = NULL;
  }
  
  void InstanceKlass::remove_java_mirror() {
    Klass::remove_java_mirror();
  
<span class="line-new-header">--- 2425,29 ---</span>
    // do array classes also.
    if (array_klasses() != NULL) {
      array_klasses()-&gt;remove_unshareable_info();
    }
  
<span class="line-modified">!   // These are not allocated from metaspace. They are safe to set to NULL.</span>
<span class="line-modified">!   _source_debug_extension = NULL;</span>
<span class="line-modified">!   _dep_context = NULL;</span>
<span class="line-modified">!   _osr_nmethods_head = NULL;</span>
  #if INCLUDE_JVMTI
<span class="line-modified">!   _breakpoints = NULL;</span>
<span class="line-modified">!   _previous_versions = NULL;</span>
    _cached_class_file = NULL;
<span class="line-added">+   _jvmti_cached_class_field_map = NULL;</span>
  #endif
  
    _init_thread = NULL;
    _methods_jmethod_ids = NULL;
    _jni_ids = NULL;
    _oop_map_cache = NULL;
    // clear _nest_host to ensure re-load at runtime
    _nest_host = NULL;
<span class="line-added">+   _package_entry = NULL;</span>
<span class="line-added">+   _dep_context_last_cleaned = 0;</span>
  }
  
  void InstanceKlass::remove_java_mirror() {
    Klass::remove_java_mirror();
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2426,10 ***</span>
<span class="line-new-header">--- 2486,15 ---</span>
    if (array_klasses() != NULL) {
      // Array classes have null protection domain.
      // --&gt; see ArrayKlass::complete_create_array_klass()
      array_klasses()-&gt;restore_unshareable_info(ClassLoaderData::the_null_class_loader_data(), Handle(), CHECK);
    }
<span class="line-added">+ </span>
<span class="line-added">+   // Initialize current biased locking state.</span>
<span class="line-added">+   if (UseBiasedLocking &amp;&amp; BiasedLocking::enabled()) {</span>
<span class="line-added">+     set_prototype_header(markWord::biased_locking_prototype());</span>
<span class="line-added">+   }</span>
  }
  
  // returns true IFF is_in_error_state() has been changed as a result of this call.
  bool InstanceKlass::check_sharing_error_state() {
    assert(DumpSharedSpaces, &quot;should only be called during dumping&quot;);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2460,10 ***</span>
<span class="line-new-header">--- 2525,27 ---</span>
    }
  
    return (old_state != is_in_error_state());
  }
  
<span class="line-added">+ void InstanceKlass::set_class_loader_type(s2 loader_type) {</span>
<span class="line-added">+   switch (loader_type) {</span>
<span class="line-added">+   case ClassLoader::BOOT_LOADER:</span>
<span class="line-added">+     _misc_flags |= _misc_is_shared_boot_class;</span>
<span class="line-added">+     break;</span>
<span class="line-added">+   case ClassLoader::PLATFORM_LOADER:</span>
<span class="line-added">+     _misc_flags |= _misc_is_shared_platform_class;</span>
<span class="line-added">+     break;</span>
<span class="line-added">+   case ClassLoader::APP_LOADER:</span>
<span class="line-added">+     _misc_flags |= _misc_is_shared_app_class;</span>
<span class="line-added">+     break;</span>
<span class="line-added">+   default:</span>
<span class="line-added">+     ShouldNotReachHere();</span>
<span class="line-added">+     break;</span>
<span class="line-added">+   }</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
  #if INCLUDE_JVMTI
  static void clear_all_breakpoints(Method* m) {
    m-&gt;clear_all_breakpoints();
  }
  #endif
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2478,10 ***</span>
<span class="line-new-header">--- 2560,14 ---</span>
    }
  
    // notify ClassLoadingService of class unload
    ClassLoadingService::notify_class_unloaded(ik);
  
<span class="line-added">+   if (Arguments::is_dumping_archive()) {</span>
<span class="line-added">+     SystemDictionaryShared::remove_dumptime_info(ik);</span>
<span class="line-added">+   }</span>
<span class="line-added">+ </span>
    if (log_is_enabled(Info, class, unload)) {
      ResourceMark rm;
      log_info(class, unload)(&quot;unloading class %s &quot; INTPTR_FORMAT, ik-&gt;external_name(), p2i(ik));
    }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2494,14 ***</span>
<span class="line-new-header">--- 2580,22 ---</span>
    event.set_definingClassLoader(ik-&gt;class_loader_data());
    event.commit();
  #endif
  }
  
<span class="line-added">+ static void method_release_C_heap_structures(Method* m) {</span>
<span class="line-added">+   m-&gt;release_C_heap_structures();</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
  void InstanceKlass::release_C_heap_structures(InstanceKlass* ik) {
    // Clean up C heap
    ik-&gt;release_C_heap_structures();
    ik-&gt;constants()-&gt;release_C_heap_structures();
<span class="line-added">+ </span>
<span class="line-added">+   // Deallocate and call destructors for MDO mutexes</span>
<span class="line-added">+   ik-&gt;methods_do(method_release_C_heap_structures);</span>
<span class="line-added">+ </span>
  }
  
  void InstanceKlass::release_C_heap_structures() {
    // Can&#39;t release the constant pool here because the constant pool can be
    // deallocated separately from the InstanceKlass for default methods and
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2543,11 ***</span>
    // Decrement symbol reference counts associated with the unloaded class.
    if (_name != NULL) _name-&gt;decrement_refcount();
    // unreference array name derived from this class name (arrays of an unloaded
    // class can&#39;t be referenced anymore).
    if (_array_name != NULL)  _array_name-&gt;decrement_refcount();
<span class="line-modified">!   if (_source_debug_extension != NULL) FREE_C_HEAP_ARRAY(char, _source_debug_extension);</span>
  }
  
  void InstanceKlass::set_source_debug_extension(const char* array, int length) {
    if (array == NULL) {
      _source_debug_extension = NULL;
<span class="line-new-header">--- 2637,11 ---</span>
    // Decrement symbol reference counts associated with the unloaded class.
    if (_name != NULL) _name-&gt;decrement_refcount();
    // unreference array name derived from this class name (arrays of an unloaded
    // class can&#39;t be referenced anymore).
    if (_array_name != NULL)  _array_name-&gt;decrement_refcount();
<span class="line-modified">!   FREE_C_HEAP_ARRAY(char, _source_debug_extension);</span>
  }
  
  void InstanceKlass::set_source_debug_extension(const char* array, int length) {
    if (array == NULL) {
      _source_debug_extension = NULL;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2583,11 ***</span>
  
    char* dest = NEW_RESOURCE_ARRAY(char, src_length + hash_len + 3);
  
    // Add L as type indicator
    int dest_index = 0;
<span class="line-modified">!   dest[dest_index++] = &#39;L&#39;;</span>
  
    // Add the actual class name
    for (int src_index = 0; src_index &lt; src_length; ) {
      dest[dest_index++] = src[src_index++];
    }
<span class="line-new-header">--- 2677,11 ---</span>
  
    char* dest = NEW_RESOURCE_ARRAY(char, src_length + hash_len + 3);
  
    // Add L as type indicator
    int dest_index = 0;
<span class="line-modified">!   dest[dest_index++] = JVM_SIGNATURE_CLASS;</span>
  
    // Add the actual class name
    for (int src_index = 0; src_index &lt; src_length; ) {
      dest[dest_index++] = src[src_index++];
    }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2596,11 ***</span>
    for (int hash_index = 0; hash_index &lt; hash_len; ) {
      dest[dest_index++] = hash_buf[hash_index++];
    }
  
    // Add the semicolon and the NULL
<span class="line-modified">!   dest[dest_index++] = &#39;;&#39;;</span>
    dest[dest_index] = &#39;\0&#39;;
    return dest;
  }
  
  // Used to obtain the package name from a fully qualified class name.
<span class="line-new-header">--- 2690,11 ---</span>
    for (int hash_index = 0; hash_index &lt; hash_len; ) {
      dest[dest_index++] = hash_buf[hash_index++];
    }
  
    // Add the semicolon and the NULL
<span class="line-modified">!   dest[dest_index++] = JVM_SIGNATURE_ENDCLASS;</span>
    dest[dest_index] = &#39;\0&#39;;
    return dest;
  }
  
  // Used to obtain the package name from a fully qualified class name.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2609,16 ***</span>
      return NULL;
    } else {
      if (name-&gt;utf8_length() &lt;= 0) {
        return NULL;
      }
<span class="line-modified">!     ResourceMark rm;</span>
      const char* package_name = ClassLoader::package_from_name((const char*) name-&gt;as_C_string());
      if (package_name == NULL) {
        return NULL;
      }
<span class="line-modified">!     Symbol* pkg_name = SymbolTable::new_symbol(package_name, THREAD);</span>
      return pkg_name;
    }
  }
  
  ModuleEntry* InstanceKlass::module() const {
<span class="line-new-header">--- 2703,16 ---</span>
      return NULL;
    } else {
      if (name-&gt;utf8_length() &lt;= 0) {
        return NULL;
      }
<span class="line-modified">!     ResourceMark rm(THREAD);</span>
      const char* package_name = ClassLoader::package_from_name((const char*) name-&gt;as_C_string());
      if (package_name == NULL) {
        return NULL;
      }
<span class="line-modified">!     Symbol* pkg_name = SymbolTable::new_symbol(package_name);</span>
      return pkg_name;
    }
  }
  
  ModuleEntry* InstanceKlass::module() const {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2651,11 ***</span>
  
      // If the package name is not found in the loader&#39;s package
      // entry table, it is an indication that the package has not
      // been defined. Consider it defined within the unnamed module.
      if (_package_entry == NULL) {
<span class="line-modified">!       ResourceMark rm;</span>
  
        if (!ModuleEntryTable::javabase_defined()) {
          // Before java.base is defined during bootstrapping, define all packages in
          // the java.base module.  If a non-java.base package is erroneously placed
          // in the java.base module it will be caught later when java.base
<span class="line-new-header">--- 2745,11 ---</span>
  
      // If the package name is not found in the loader&#39;s package
      // entry table, it is an indication that the package has not
      // been defined. Consider it defined within the unnamed module.
      if (_package_entry == NULL) {
<span class="line-modified">!       ResourceMark rm(THREAD);</span>
  
        if (!ModuleEntryTable::javabase_defined()) {
          // Before java.base is defined during bootstrapping, define all packages in
          // the java.base module.  If a non-java.base package is erroneously placed
          // in the java.base module it will be caught later when java.base
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2672,20 ***</span>
        assert(_package_entry != NULL, &quot;Package entry for class %s not found, loader %s&quot;,
               name()-&gt;as_C_string(), loader_data-&gt;loader_name_and_id());
      }
  
      if (log_is_enabled(Debug, module)) {
<span class="line-modified">!       ResourceMark rm;</span>
        ModuleEntry* m = _package_entry-&gt;module();
        log_trace(module)(&quot;Setting package: class: %s, package: %s, loader: %s, module: %s&quot;,
                          external_name(),
                          pkg_name-&gt;as_C_string(),
                          loader_data-&gt;loader_name_and_id(),
                          (m-&gt;is_named() ? m-&gt;name()-&gt;as_C_string() : UNNAMED_MODULE));
      }
    } else {
<span class="line-modified">!     ResourceMark rm;</span>
      log_trace(module)(&quot;Setting package: class: %s, package: unnamed, loader: %s, module: %s&quot;,
                        external_name(),
                        (loader_data != NULL) ? loader_data-&gt;loader_name_and_id() : &quot;NULL&quot;,
                        UNNAMED_MODULE);
    }
<span class="line-new-header">--- 2766,20 ---</span>
        assert(_package_entry != NULL, &quot;Package entry for class %s not found, loader %s&quot;,
               name()-&gt;as_C_string(), loader_data-&gt;loader_name_and_id());
      }
  
      if (log_is_enabled(Debug, module)) {
<span class="line-modified">!       ResourceMark rm(THREAD);</span>
        ModuleEntry* m = _package_entry-&gt;module();
        log_trace(module)(&quot;Setting package: class: %s, package: %s, loader: %s, module: %s&quot;,
                          external_name(),
                          pkg_name-&gt;as_C_string(),
                          loader_data-&gt;loader_name_and_id(),
                          (m-&gt;is_named() ? m-&gt;name()-&gt;as_C_string() : UNNAMED_MODULE));
      }
    } else {
<span class="line-modified">!     ResourceMark rm(THREAD);</span>
      log_trace(module)(&quot;Setting package: class: %s, package: unnamed, loader: %s, module: %s&quot;,
                        external_name(),
                        (loader_data != NULL) ? loader_data-&gt;loader_name_and_id() : &quot;NULL&quot;,
                        UNNAMED_MODULE);
    }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2714,22 ***</span>
  
    // Same package is determined by comparing class loader
    // and package entries. Both must be the same. This rule
    // applies even to classes that are defined in the unnamed
    // package, they still must have the same class loader.
<span class="line-modified">!   if (oopDesc::equals(classloader1, classloader2) &amp;&amp; (classpkg1 == classpkg2)) {</span>
      return true;
    }
  
    return false;
  }
  
  // return true if this class and other_class are in the same package. Classloader
  // and classname information is enough to determine a class&#39;s package
  bool InstanceKlass::is_same_class_package(oop other_class_loader,
                                            const Symbol* other_class_name) const {
<span class="line-modified">!   if (!oopDesc::equals(class_loader(), other_class_loader)) {</span>
      return false;
    }
    if (name()-&gt;fast_compare(other_class_name) == 0) {
       return true;
    }
<span class="line-new-header">--- 2808,22 ---</span>
  
    // Same package is determined by comparing class loader
    // and package entries. Both must be the same. This rule
    // applies even to classes that are defined in the unnamed
    // package, they still must have the same class loader.
<span class="line-modified">!   if ((classloader1 == classloader2) &amp;&amp; (classpkg1 == classpkg2)) {</span>
      return true;
    }
  
    return false;
  }
  
  // return true if this class and other_class are in the same package. Classloader
  // and classname information is enough to determine a class&#39;s package
  bool InstanceKlass::is_same_class_package(oop other_class_loader,
                                            const Symbol* other_class_name) const {
<span class="line-modified">!   if (class_loader() != other_class_loader) {</span>
      return false;
    }
    if (name()-&gt;fast_compare(other_class_name) == 0) {
       return true;
    }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2970,14 ***</span>
  }
  #endif // INCLUDE_JVMTI
  
  // On-stack replacement stuff
  void InstanceKlass::add_osr_nmethod(nmethod* n) {
    // only one compilation can be active
    {
<span class="line-removed">-     // This is a short non-blocking critical region, so the no safepoint check is ok.</span>
<span class="line-removed">-     MutexLockerEx ml(OsrList_lock, Mutex::_no_safepoint_check_flag);</span>
      assert(n-&gt;is_osr_method(), &quot;wrong kind of nmethod&quot;);
      n-&gt;set_osr_link(osr_nmethods_head());
      set_osr_nmethods_head(n);
      // Raise the highest osr level if necessary
      if (TieredCompilation) {
<span class="line-new-header">--- 3064,20 ---</span>
  }
  #endif // INCLUDE_JVMTI
  
  // On-stack replacement stuff
  void InstanceKlass::add_osr_nmethod(nmethod* n) {
<span class="line-added">+   assert_lock_strong(CompiledMethod_lock);</span>
<span class="line-added">+ #ifndef PRODUCT</span>
<span class="line-added">+   if (TieredCompilation) {</span>
<span class="line-added">+       nmethod * prev = lookup_osr_nmethod(n-&gt;method(), n-&gt;osr_entry_bci(), n-&gt;comp_level(), true);</span>
<span class="line-added">+       assert(prev == NULL || !prev-&gt;is_in_use(),</span>
<span class="line-added">+       &quot;redundunt OSR recompilation detected. memory leak in CodeCache!&quot;);</span>
<span class="line-added">+   }</span>
<span class="line-added">+ #endif</span>
    // only one compilation can be active
    {
      assert(n-&gt;is_osr_method(), &quot;wrong kind of nmethod&quot;);
      n-&gt;set_osr_link(osr_nmethods_head());
      set_osr_nmethods_head(n);
      // Raise the highest osr level if necessary
      if (TieredCompilation) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2998,11 ***</span>
  }
  
  // Remove osr nmethod from the list. Return true if found and removed.
  bool InstanceKlass::remove_osr_nmethod(nmethod* n) {
    // This is a short non-blocking critical region, so the no safepoint check is ok.
<span class="line-modified">!   MutexLockerEx ml(OsrList_lock, Mutex::_no_safepoint_check_flag);</span>
    assert(n-&gt;is_osr_method(), &quot;wrong kind of nmethod&quot;);
    nmethod* last = NULL;
    nmethod* cur  = osr_nmethods_head();
    int max_level = CompLevel_none;  // Find the max comp level excluding n
    Method* m = n-&gt;method();
<span class="line-new-header">--- 3098,12 ---</span>
  }
  
  // Remove osr nmethod from the list. Return true if found and removed.
  bool InstanceKlass::remove_osr_nmethod(nmethod* n) {
    // This is a short non-blocking critical region, so the no safepoint check is ok.
<span class="line-modified">!   MutexLocker ml(CompiledMethod_lock-&gt;owned_by_self() ? NULL : CompiledMethod_lock</span>
<span class="line-added">+                  , Mutex::_no_safepoint_check_flag);</span>
    assert(n-&gt;is_osr_method(), &quot;wrong kind of nmethod&quot;);
    nmethod* last = NULL;
    nmethod* cur  = osr_nmethods_head();
    int max_level = CompLevel_none;  // Find the max comp level excluding n
    Method* m = n-&gt;method();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3041,12 ***</span>
    }
    return found;
  }
  
  int InstanceKlass::mark_osr_nmethods(const Method* m) {
<span class="line-modified">!   // This is a short non-blocking critical region, so the no safepoint check is ok.</span>
<span class="line-modified">!   MutexLockerEx ml(OsrList_lock, Mutex::_no_safepoint_check_flag);</span>
    nmethod* osr = osr_nmethods_head();
    int found = 0;
    while (osr != NULL) {
      assert(osr-&gt;is_osr_method(), &quot;wrong kind of nmethod found in chain&quot;);
      if (osr-&gt;method() == m) {
<span class="line-new-header">--- 3142,12 ---</span>
    }
    return found;
  }
  
  int InstanceKlass::mark_osr_nmethods(const Method* m) {
<span class="line-modified">!   MutexLocker ml(CompiledMethod_lock-&gt;owned_by_self() ? NULL : CompiledMethod_lock,</span>
<span class="line-modified">!                  Mutex::_no_safepoint_check_flag);</span>
    nmethod* osr = osr_nmethods_head();
    int found = 0;
    while (osr != NULL) {
      assert(osr-&gt;is_osr_method(), &quot;wrong kind of nmethod found in chain&quot;);
      if (osr-&gt;method() == m) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3057,12 ***</span>
    }
    return found;
  }
  
  nmethod* InstanceKlass::lookup_osr_nmethod(const Method* m, int bci, int comp_level, bool match_level) const {
<span class="line-modified">!   // This is a short non-blocking critical region, so the no safepoint check is ok.</span>
<span class="line-modified">!   MutexLockerEx ml(OsrList_lock, Mutex::_no_safepoint_check_flag);</span>
    nmethod* osr = osr_nmethods_head();
    nmethod* best = NULL;
    while (osr != NULL) {
      assert(osr-&gt;is_osr_method(), &quot;wrong kind of nmethod found in chain&quot;);
      // There can be a time when a c1 osr method exists but we are waiting
<span class="line-new-header">--- 3158,12 ---</span>
    }
    return found;
  }
  
  nmethod* InstanceKlass::lookup_osr_nmethod(const Method* m, int bci, int comp_level, bool match_level) const {
<span class="line-modified">!   MutexLocker ml(CompiledMethod_lock-&gt;owned_by_self() ? NULL : CompiledMethod_lock,</span>
<span class="line-modified">!                  Mutex::_no_safepoint_check_flag);</span>
    nmethod* osr = osr_nmethods_head();
    nmethod* best = NULL;
    while (osr != NULL) {
      assert(osr-&gt;is_osr_method(), &quot;wrong kind of nmethod found in chain&quot;);
      // There can be a time when a c1 osr method exists but we are waiting
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3088,11 ***</span>
          }
        }
      }
      osr = osr-&gt;osr_link();
    }
<span class="line-modified">!   if (best != NULL &amp;&amp; best-&gt;comp_level() &gt;= comp_level &amp;&amp; match_level == false) {</span>
      return best;
    }
    return NULL;
  }
  
<span class="line-new-header">--- 3189,13 ---</span>
          }
        }
      }
      osr = osr-&gt;osr_link();
    }
<span class="line-modified">! </span>
<span class="line-added">+   assert(match_level == false || best == NULL, &quot;shouldn&#39;t pick up anything if match_level is set&quot;);</span>
<span class="line-added">+   if (best != NULL &amp;&amp; best-&gt;comp_level() &gt;= comp_level) {</span>
      return best;
    }
    return NULL;
  }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3109,11 ***</span>
  
  static void print_vtable(intptr_t* start, int len, outputStream* st) {
    for (int i = 0; i &lt; len; i++) {
      intptr_t e = start[i];
      st-&gt;print(&quot;%d : &quot; INTPTR_FORMAT, i, e);
<span class="line-modified">!     if (e != 0 &amp;&amp; ((Metadata*)e)-&gt;is_metaspace_object()) {</span>
        st-&gt;print(&quot; &quot;);
        ((Metadata*)e)-&gt;print_value_on(st);
      }
      st-&gt;cr();
    }
<span class="line-new-header">--- 3212,11 ---</span>
  
  static void print_vtable(intptr_t* start, int len, outputStream* st) {
    for (int i = 0; i &lt; len; i++) {
      intptr_t e = start[i];
      st-&gt;print(&quot;%d : &quot; INTPTR_FORMAT, i, e);
<span class="line-modified">!     if (MetaspaceObj::is_valid((Metadata*)e)) {</span>
        st-&gt;print(&quot; &quot;);
        ((Metadata*)e)-&gt;print_value_on(st);
      }
      st-&gt;cr();
    }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3216,10 ***</span>
<span class="line-new-header">--- 3319,13 ---</span>
      generic_signature()-&gt;print_value_on(st);
      st-&gt;cr();
    }
    st-&gt;print(BULLET&quot;inner classes:     &quot;); inner_classes()-&gt;print_value_on(st);     st-&gt;cr();
    st-&gt;print(BULLET&quot;nest members:     &quot;); nest_members()-&gt;print_value_on(st);     st-&gt;cr();
<span class="line-added">+   if (record_components() != NULL) {</span>
<span class="line-added">+     st-&gt;print(BULLET&quot;record components:     &quot;); record_components()-&gt;print_value_on(st);     st-&gt;cr();</span>
<span class="line-added">+   }</span>
    if (java_mirror() != NULL) {
      st-&gt;print(BULLET&quot;java mirror:       &quot;);
      java_mirror()-&gt;print_value_on(st);
      st-&gt;cr();
    } else {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3389,11 ***</span>
  
    // Source
    if (cfs != NULL) {
      if (cfs-&gt;source() != NULL) {
        if (module_name != NULL) {
<span class="line-modified">!         if (ClassLoader::is_modules_image(cfs-&gt;source())) {</span>
            info_stream.print(&quot; source: jrt:/%s&quot;, module_name);
          } else {
            info_stream.print(&quot; source: %s&quot;, cfs-&gt;source());
          }
        } else {
<span class="line-new-header">--- 3495,13 ---</span>
  
    // Source
    if (cfs != NULL) {
      if (cfs-&gt;source() != NULL) {
        if (module_name != NULL) {
<span class="line-modified">!         // When the boot loader created the stream, it didn&#39;t know the module name</span>
<span class="line-added">+         // yet. Let&#39;s format it now.</span>
<span class="line-added">+         if (cfs-&gt;from_boot_loader_modules_image()) {</span>
            info_stream.print(&quot; source: jrt:/%s&quot;, module_name);
          } else {
            info_stream.print(&quot; source: %s&quot;, cfs-&gt;source());
          }
        } else {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3414,11 ***</span>
      } else {
        oop class_loader = loader_data-&gt;class_loader();
        info_stream.print(&quot; source: %s&quot;, class_loader-&gt;klass()-&gt;external_name());
      }
    } else {
<span class="line-modified">!     info_stream.print(&quot; source: shared objects file&quot;);</span>
    }
  
    msg.info(&quot;%s&quot;, info_stream.as_string());
  
    if (log_is_enabled(Debug, class, load)) {
<span class="line-new-header">--- 3522,16 ---</span>
      } else {
        oop class_loader = loader_data-&gt;class_loader();
        info_stream.print(&quot; source: %s&quot;, class_loader-&gt;klass()-&gt;external_name());
      }
    } else {
<span class="line-modified">!     assert(this-&gt;is_shared(), &quot;must be&quot;);</span>
<span class="line-added">+     if (MetaspaceShared::is_shared_dynamic((void*)this)) {</span>
<span class="line-added">+       info_stream.print(&quot; source: shared objects file (top)&quot;);</span>
<span class="line-added">+     } else {</span>
<span class="line-added">+       info_stream.print(&quot; source: shared objects file&quot;);</span>
<span class="line-added">+     }</span>
    }
  
    msg.info(&quot;%s&quot;, info_stream.as_string());
  
    if (log_is_enabled(Debug, class, load)) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3453,53 ***</span>
  
      msg.debug(&quot;%s&quot;, debug_stream.as_string());
    }
  }
  
<span class="line-removed">- #if INCLUDE_SERVICES</span>
<span class="line-removed">- // Size Statistics</span>
<span class="line-removed">- void InstanceKlass::collect_statistics(KlassSizeStats *sz) const {</span>
<span class="line-removed">-   Klass::collect_statistics(sz);</span>
<span class="line-removed">- </span>
<span class="line-removed">-   sz-&gt;_inst_size  = wordSize * size_helper();</span>
<span class="line-removed">-   sz-&gt;_vtab_bytes = wordSize * vtable_length();</span>
<span class="line-removed">-   sz-&gt;_itab_bytes = wordSize * itable_length();</span>
<span class="line-removed">-   sz-&gt;_nonstatic_oopmap_bytes = wordSize * nonstatic_oop_map_size();</span>
<span class="line-removed">- </span>
<span class="line-removed">-   int n = 0;</span>
<span class="line-removed">-   n += (sz-&gt;_methods_array_bytes         = sz-&gt;count_array(methods()));</span>
<span class="line-removed">-   n += (sz-&gt;_method_ordering_bytes       = sz-&gt;count_array(method_ordering()));</span>
<span class="line-removed">-   n += (sz-&gt;_local_interfaces_bytes      = sz-&gt;count_array(local_interfaces()));</span>
<span class="line-removed">-   n += (sz-&gt;_transitive_interfaces_bytes = sz-&gt;count_array(transitive_interfaces()));</span>
<span class="line-removed">-   n += (sz-&gt;_fields_bytes                = sz-&gt;count_array(fields()));</span>
<span class="line-removed">-   n += (sz-&gt;_inner_classes_bytes         = sz-&gt;count_array(inner_classes()));</span>
<span class="line-removed">-   n += (sz-&gt;_nest_members_bytes          = sz-&gt;count_array(nest_members()));</span>
<span class="line-removed">-   sz-&gt;_ro_bytes += n;</span>
<span class="line-removed">- </span>
<span class="line-removed">-   const ConstantPool* cp = constants();</span>
<span class="line-removed">-   if (cp) {</span>
<span class="line-removed">-     cp-&gt;collect_statistics(sz);</span>
<span class="line-removed">-   }</span>
<span class="line-removed">- </span>
<span class="line-removed">-   const Annotations* anno = annotations();</span>
<span class="line-removed">-   if (anno) {</span>
<span class="line-removed">-     anno-&gt;collect_statistics(sz);</span>
<span class="line-removed">-   }</span>
<span class="line-removed">- </span>
<span class="line-removed">-   const Array&lt;Method*&gt;* methods_array = methods();</span>
<span class="line-removed">-   if (methods()) {</span>
<span class="line-removed">-     for (int i = 0; i &lt; methods_array-&gt;length(); i++) {</span>
<span class="line-removed">-       Method* method = methods_array-&gt;at(i);</span>
<span class="line-removed">-       if (method) {</span>
<span class="line-removed">-         sz-&gt;_method_count ++;</span>
<span class="line-removed">-         method-&gt;collect_statistics(sz);</span>
<span class="line-removed">-       }</span>
<span class="line-removed">-     }</span>
<span class="line-removed">-   }</span>
<span class="line-removed">- }</span>
<span class="line-removed">- #endif // INCLUDE_SERVICES</span>
<span class="line-removed">- </span>
  // Verification
  
  class VerifyFieldClosure: public BasicOopIterateClosure {
   protected:
    template &lt;class T&gt; void do_oop_work(T* p) {
<span class="line-new-header">--- 3566,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3587,11 ***</span>
    // Verify method ordering
    if (method_ordering() != NULL) {
      Array&lt;int&gt;* method_ordering = this-&gt;method_ordering();
      int length = method_ordering-&gt;length();
      if (JvmtiExport::can_maintain_original_method_order() ||
<span class="line-modified">!         ((UseSharedSpaces || DumpSharedSpaces) &amp;&amp; length != 0)) {</span>
        guarantee(length == methods()-&gt;length(), &quot;invalid method ordering length&quot;);
        jlong sum = 0;
        for (int j = 0; j &lt; length; j++) {
          int original_index = method_ordering-&gt;at(j);
          guarantee(original_index &gt;= 0, &quot;invalid method ordering index&quot;);
<span class="line-new-header">--- 3657,11 ---</span>
    // Verify method ordering
    if (method_ordering() != NULL) {
      Array&lt;int&gt;* method_ordering = this-&gt;method_ordering();
      int length = method_ordering-&gt;length();
      if (JvmtiExport::can_maintain_original_method_order() ||
<span class="line-modified">!         ((UseSharedSpaces || Arguments::is_dumping_archive()) &amp;&amp; length != 0)) {</span>
        guarantee(length == methods()-&gt;length(), &quot;invalid method ordering length&quot;);
        jlong sum = 0;
        for (int j = 0; j &lt; length; j++) {
          int original_index = method_ordering-&gt;at(j);
          guarantee(original_index &gt;= 0, &quot;invalid method ordering index&quot;);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3695,10 ***</span>
<span class="line-new-header">--- 3765,11 ---</span>
  #ifdef ASSERT
    bool good_state = is_shared() ? (_init_state &lt;= state)
                                                 : (_init_state &lt; state);
    assert(good_state || state == allocated, &quot;illegal state transition&quot;);
  #endif
<span class="line-added">+   assert(_init_thread == NULL, &quot;should be cleared before state change&quot;);</span>
    _init_state = (u1)state;
  }
  
  #if INCLUDE_JVMTI
  
</pre>
<center><a href="fieldInfo.hpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="../prims/jvm.cpp.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
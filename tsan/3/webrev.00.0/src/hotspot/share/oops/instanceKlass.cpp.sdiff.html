<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/oops/instanceKlass.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="fieldInfo.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="../prims/jvm.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/oops/instanceKlass.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 1997, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include &quot;precompiled.hpp&quot;
  26 #include &quot;jvm.h&quot;
  27 #include &quot;aot/aotLoader.hpp&quot;
  28 #include &quot;classfile/classFileParser.hpp&quot;
  29 #include &quot;classfile/classFileStream.hpp&quot;
  30 #include &quot;classfile/classLoader.hpp&quot;
  31 #include &quot;classfile/classLoaderData.inline.hpp&quot;
  32 #include &quot;classfile/javaClasses.hpp&quot;
  33 #include &quot;classfile/moduleEntry.hpp&quot;

  34 #include &quot;classfile/systemDictionary.hpp&quot;
  35 #include &quot;classfile/systemDictionaryShared.hpp&quot;
  36 #include &quot;classfile/verifier.hpp&quot;
  37 #include &quot;classfile/vmSymbols.hpp&quot;
  38 #include &quot;code/dependencyContext.hpp&quot;
  39 #include &quot;compiler/compileBroker.hpp&quot;
  40 #include &quot;gc/shared/collectedHeap.inline.hpp&quot;
  41 #include &quot;interpreter/oopMapCache.hpp&quot;
  42 #include &quot;interpreter/rewriter.hpp&quot;
  43 #include &quot;jvmtifiles/jvmti.h&quot;
  44 #include &quot;logging/log.hpp&quot;
  45 #include &quot;logging/logMessage.hpp&quot;
  46 #include &quot;logging/logStream.hpp&quot;
  47 #include &quot;memory/allocation.inline.hpp&quot;
<span class="line-removed">  48 #include &quot;memory/heapInspection.hpp&quot;</span>
  49 #include &quot;memory/iterator.inline.hpp&quot;
  50 #include &quot;memory/metadataFactory.hpp&quot;
  51 #include &quot;memory/metaspaceClosure.hpp&quot;
  52 #include &quot;memory/metaspaceShared.hpp&quot;
  53 #include &quot;memory/oopFactory.hpp&quot;
  54 #include &quot;memory/resourceArea.hpp&quot;
<span class="line-modified">  55 #include &quot;oops/fieldStreams.hpp&quot;</span>

  56 #include &quot;oops/constantPool.hpp&quot;
  57 #include &quot;oops/instanceClassLoaderKlass.hpp&quot;
  58 #include &quot;oops/instanceKlass.inline.hpp&quot;
  59 #include &quot;oops/instanceMirrorKlass.hpp&quot;
  60 #include &quot;oops/instanceOop.hpp&quot;
  61 #include &quot;oops/klass.inline.hpp&quot;
  62 #include &quot;oops/method.hpp&quot;
  63 #include &quot;oops/oop.inline.hpp&quot;

  64 #include &quot;oops/symbol.hpp&quot;
  65 #include &quot;prims/jvmtiExport.hpp&quot;
  66 #include &quot;prims/jvmtiRedefineClasses.hpp&quot;
  67 #include &quot;prims/jvmtiThreadState.hpp&quot;
  68 #include &quot;prims/methodComparator.hpp&quot;
  69 #include &quot;runtime/atomic.hpp&quot;

  70 #include &quot;runtime/fieldDescriptor.inline.hpp&quot;
  71 #include &quot;runtime/handles.inline.hpp&quot;
  72 #include &quot;runtime/javaCalls.hpp&quot;
  73 #include &quot;runtime/mutexLocker.hpp&quot;
  74 #include &quot;runtime/orderAccess.hpp&quot;
  75 #include &quot;runtime/thread.inline.hpp&quot;
  76 #include &quot;services/classLoadingService.hpp&quot;
  77 #include &quot;services/threadService.hpp&quot;
  78 #include &quot;utilities/dtrace.hpp&quot;
  79 #include &quot;utilities/events.hpp&quot;
  80 #include &quot;utilities/macros.hpp&quot;
  81 #include &quot;utilities/stringUtils.hpp&quot;
  82 #ifdef COMPILER1
  83 #include &quot;c1/c1_Compiler.hpp&quot;
  84 #endif
  85 #if INCLUDE_JFR
  86 #include &quot;jfr/jfrEvents.hpp&quot;
  87 #endif
  88 #if INCLUDE_TSAN
  89 #include &quot;runtime/sharedRuntime.hpp&quot;
</pre>
<hr />
<pre>
 419       _method_ordering-&gt;at_put(i, m-&gt;at(i));
 420     }
 421   } else {
 422     _method_ordering = Universe::the_empty_int_array();
 423   }
 424 }
 425 
 426 // create a new array of vtable_indices for default methods
 427 Array&lt;int&gt;* InstanceKlass::create_new_default_vtable_indices(int len, TRAPS) {
 428   Array&lt;int&gt;* vtable_indices = MetadataFactory::new_array&lt;int&gt;(class_loader_data(), len, CHECK_NULL);
 429   assert(default_vtable_indices() == NULL, &quot;only create once&quot;);
 430   set_default_vtable_indices(vtable_indices);
 431   return vtable_indices;
 432 }
 433 
 434 InstanceKlass::InstanceKlass(const ClassFileParser&amp; parser, unsigned kind, KlassID id) :
 435   Klass(id),
 436   _nest_members(NULL),
 437   _nest_host_index(0),
 438   _nest_host(NULL),

 439   _static_field_size(parser.static_field_size()),
 440   _nonstatic_oop_map_size(nonstatic_oop_map_size(parser.total_oop_map_count())),
 441   _itable_len(parser.itable_size()),


 442   _reference_type(parser.reference_type())
 443 {
 444   set_vtable_length(parser.vtable_size());
 445   set_kind(kind);
 446   set_access_flags(parser.access_flags());
 447   set_is_unsafe_anonymous(parser.is_unsafe_anonymous());
 448   set_layout_helper(Klass::instance_layout_helper(parser.layout_size(),
 449                                                     false));
 450 
 451   assert(NULL == _methods, &quot;underlying memory not zeroed?&quot;);
 452   assert(is_instance_klass(), &quot;is layout incorrect?&quot;);
 453   assert(size_helper() == parser.layout_size(), &quot;incorrect size_helper?&quot;);
 454 
<span class="line-modified"> 455   if (DumpSharedSpaces) {</span>
 456     SystemDictionaryShared::init_dumptime_info(this);
 457   }






 458 }
 459 
 460 void InstanceKlass::deallocate_methods(ClassLoaderData* loader_data,
 461                                        Array&lt;Method*&gt;* methods) {
 462   if (methods != NULL &amp;&amp; methods != Universe::the_empty_method_array() &amp;&amp;
 463       !methods-&gt;is_shared()) {
 464     for (int i = 0; i &lt; methods-&gt;length(); i++) {
 465       Method* method = methods-&gt;at(i);
 466       if (method == NULL) continue;  // maybe null if error processing
 467       // Only want to delete methods that are not executing for RedefineClasses.
 468       // The previous version will point to them so they&#39;re not totally dangling
 469       assert (!method-&gt;on_stack(), &quot;shouldn&#39;t be called with methods on stack&quot;);
 470       MetadataFactory::free_metadata(loader_data, method);
 471     }
 472     MetadataFactory::free_array&lt;Method*&gt;(loader_data, methods);
 473   }
 474 }
 475 
 476 void InstanceKlass::deallocate_interfaces(ClassLoaderData* loader_data,
 477                                           const Klass* super_klass,
</pre>
<hr />
<pre>
 479                                           Array&lt;InstanceKlass*&gt;* transitive_interfaces) {
 480   // Only deallocate transitive interfaces if not empty, same as super class
 481   // or same as local interfaces.  See code in parseClassFile.
 482   Array&lt;InstanceKlass*&gt;* ti = transitive_interfaces;
 483   if (ti != Universe::the_empty_instance_klass_array() &amp;&amp; ti != local_interfaces) {
 484     // check that the interfaces don&#39;t come from super class
 485     Array&lt;InstanceKlass*&gt;* sti = (super_klass == NULL) ? NULL :
 486                     InstanceKlass::cast(super_klass)-&gt;transitive_interfaces();
 487     if (ti != sti &amp;&amp; ti != NULL &amp;&amp; !ti-&gt;is_shared()) {
 488       MetadataFactory::free_array&lt;InstanceKlass*&gt;(loader_data, ti);
 489     }
 490   }
 491 
 492   // local interfaces can be empty
 493   if (local_interfaces != Universe::the_empty_instance_klass_array() &amp;&amp;
 494       local_interfaces != NULL &amp;&amp; !local_interfaces-&gt;is_shared()) {
 495     MetadataFactory::free_array&lt;InstanceKlass*&gt;(loader_data, local_interfaces);
 496   }
 497 }
 498 











 499 // This function deallocates the metadata and C heap pointers that the
 500 // InstanceKlass points to.
 501 void InstanceKlass::deallocate_contents(ClassLoaderData* loader_data) {
 502 
 503   // Orphan the mirror first, CMS thinks it&#39;s still live.
 504   if (java_mirror() != NULL) {
 505     java_lang_Class::set_klass(java_mirror(), NULL);
 506   }
 507 
 508   // Also remove mirror from handles
 509   loader_data-&gt;remove_handle(_java_mirror);
 510 
 511   // Need to take this class off the class loader data list.
 512   loader_data-&gt;remove_class(this);
 513 
 514   // The array_klass for this class is created later, after error handling.
 515   // For class redefinition, we keep the original class so this scratch class
 516   // doesn&#39;t have an array class.  Either way, assert that there is nothing
 517   // to deallocate.
 518   assert(array_klasses() == NULL, &quot;array classes shouldn&#39;t be created for this class yet&quot;);
 519 
 520   // Release C heap allocated data that this might point to, which includes
 521   // reference counting symbol names.
 522   release_C_heap_structures();
 523 
 524   deallocate_methods(loader_data, methods());
 525   set_methods(NULL);
 526 



 527   if (method_ordering() != NULL &amp;&amp;
 528       method_ordering() != Universe::the_empty_int_array() &amp;&amp;
 529       !method_ordering()-&gt;is_shared()) {
 530     MetadataFactory::free_array&lt;int&gt;(loader_data, method_ordering());
 531   }
 532   set_method_ordering(NULL);
 533 
 534   // default methods can be empty
 535   if (default_methods() != NULL &amp;&amp;
 536       default_methods() != Universe::the_empty_method_array() &amp;&amp;
 537       !default_methods()-&gt;is_shared()) {
 538     MetadataFactory::free_array&lt;Method*&gt;(loader_data, default_methods());
 539   }
 540   // Do NOT deallocate the default methods, they are owned by superinterfaces.
 541   set_default_methods(NULL);
 542 
 543   // default methods vtable indices can be empty
 544   if (default_vtable_indices() != NULL &amp;&amp;
 545       !default_vtable_indices()-&gt;is_shared()) {
 546     MetadataFactory::free_array&lt;int&gt;(loader_data, default_vtable_indices());
</pre>
<hr />
<pre>
 585   if (inner_classes() != NULL &amp;&amp;
 586       inner_classes() != Universe::the_empty_short_array() &amp;&amp;
 587       !inner_classes()-&gt;is_shared()) {
 588     MetadataFactory::free_array&lt;jushort&gt;(loader_data, inner_classes());
 589   }
 590   set_inner_classes(NULL);
 591 
 592   if (nest_members() != NULL &amp;&amp;
 593       nest_members() != Universe::the_empty_short_array() &amp;&amp;
 594       !nest_members()-&gt;is_shared()) {
 595     MetadataFactory::free_array&lt;jushort&gt;(loader_data, nest_members());
 596   }
 597   set_nest_members(NULL);
 598 
 599   // We should deallocate the Annotations instance if it&#39;s not in shared spaces.
 600   if (annotations() != NULL &amp;&amp; !annotations()-&gt;is_shared()) {
 601     MetadataFactory::free_metadata(loader_data, annotations());
 602   }
 603   set_annotations(NULL);
 604 
<span class="line-modified"> 605   if (DumpSharedSpaces) {</span>
 606     SystemDictionaryShared::remove_dumptime_info(this);
 607   }
 608 }
 609 
 610 bool InstanceKlass::should_be_initialized() const {
 611   return !is_initialized();
 612 }
 613 
 614 klassItable InstanceKlass::itable() const {
 615   return klassItable(const_cast&lt;InstanceKlass*&gt;(this));
 616 }
 617 
 618 void InstanceKlass::eager_initialize(Thread *thread) {
 619   if (!EagerInitialization) return;
 620 
 621   if (this-&gt;is_not_initialized()) {
 622     // abort if the the class has a class initializer
 623     if (this-&gt;class_initializer() != NULL) return;
 624 
 625     // abort if it is java.lang.Object (initialization is handled in genesis)
</pre>
<hr />
<pre>
 942   DTRACE_CLASSINIT_PROBE(required, -1);
 943 
 944   bool wait = false;
 945 
 946   assert(THREAD-&gt;is_Java_thread(), &quot;non-JavaThread in initialize_impl&quot;);
 947   JavaThread* jt = (JavaThread*)THREAD;
 948 
 949   // refer to the JVM book page 47 for description of steps
 950   // Step 1
 951   {
 952     Handle h_init_lock(THREAD, init_lock());
 953     ObjectLocker ol(h_init_lock, THREAD, h_init_lock() != NULL);
 954 
 955     // Step 2
 956     // If we were to use wait() instead of waitInterruptibly() then
 957     // we might end up throwing IE from link/symbol resolution sites
 958     // that aren&#39;t expected to throw.  This would wreak havoc.  See 6320309.
 959     while (is_being_initialized() &amp;&amp; !is_reentrant_initialization(jt)) {
 960       wait = true;
 961       jt-&gt;set_class_to_be_initialized(this);
<span class="line-modified"> 962       ol.waitUninterruptibly(jt);</span>
 963       jt-&gt;set_class_to_be_initialized(NULL);
 964     }
 965 
 966     // Step 3
 967     if (is_being_initialized() &amp;&amp; is_reentrant_initialization(jt)) {
 968       DTRACE_CLASSINIT_PROBE_WAIT(recursive, -1, wait);
 969       return;
 970     }
 971 
 972     // Step 4
 973     if (is_initialized()) {
 974       DTRACE_CLASSINIT_PROBE_WAIT(concurrent, -1, wait);
 975       return;
 976     }
 977 
 978     // Step 5
 979     if (is_in_error_state()) {
 980       DTRACE_CLASSINIT_PROBE_WAIT(erroneous, -1, wait);
 981       ResourceMark rm(THREAD);
 982       const char* desc = &quot;Could not initialize class &quot;;
</pre>
<hr />
<pre>
1076       THROW_ARG(vmSymbols::java_lang_ExceptionInInitializerError(),
1077                 vmSymbols::throwable_void_signature(),
1078                 &amp;args);
1079     }
1080   }
1081   DTRACE_CLASSINIT_PROBE_WAIT(end, -1, wait);
1082 }
1083 
1084 
1085 void InstanceKlass::set_initialization_state_and_notify(ClassState state, TRAPS) {
1086   Handle h_init_lock(THREAD, init_lock());
1087   if (h_init_lock() != NULL) {
1088     ObjectLocker ol(h_init_lock, THREAD);
1089     TSAN_RUNTIME_ONLY(
1090       // Construct a happens-before edge between the write of _init_state to
1091       // fully_initialized and the later checking if it&#39;s initialized.
1092       void* const lock_address = reinterpret_cast&lt;void*&gt;(
1093           java_lang_Class::init_lock_addr(java_mirror()));
1094       SharedRuntime::tsan_release(lock_address);
1095     );

1096     set_init_state(state);
1097     fence_and_clear_init_lock();
1098     ol.notify_all(CHECK);
1099   } else {
1100     assert(h_init_lock() != NULL, &quot;The initialization state should never be set twice&quot;);

1101     set_init_state(state);
1102   }
1103 }
1104 
1105 Klass* InstanceKlass::implementor() const {
1106   Klass* volatile* k = adr_implementor();
1107   if (k == NULL) {
1108     return NULL;
1109   } else {
1110     // This load races with inserts, and therefore needs acquire.
<span class="line-modified">1111     Klass* kls = OrderAccess::load_acquire(k);</span>
1112     if (kls != NULL &amp;&amp; !kls-&gt;is_loader_alive()) {
1113       return NULL;  // don&#39;t return unloaded class
1114     } else {
1115       return kls;
1116     }
1117   }
1118 }
1119 
1120 
1121 void InstanceKlass::set_implementor(Klass* k) {
<span class="line-modified">1122   assert_lock_strong(Compile_lock);</span>
1123   assert(is_interface(), &quot;not interface&quot;);
1124   Klass* volatile* addr = adr_implementor();
1125   assert(addr != NULL, &quot;null addr&quot;);
1126   if (addr != NULL) {
<span class="line-modified">1127     OrderAccess::release_store(addr, k);</span>
1128   }
1129 }
1130 
1131 int  InstanceKlass::nof_implementors() const {
1132   Klass* k = implementor();
1133   if (k == NULL) {
1134     return 0;
1135   } else if (k != this) {
1136     return 1;
1137   } else {
1138     return 2;
1139   }
1140 }
1141 
1142 // The embedded _implementor field can only record one implementor.
1143 // When there are more than one implementors, the _implementor field
1144 // is set to the interface Klass* itself. Following are the possible
1145 // values for the _implementor field:
1146 //   NULL                  - no implementor
1147 //   implementor Klass*    - one implementor
</pre>
<hr />
<pre>
1151 void InstanceKlass::add_implementor(Klass* k) {
1152   assert_lock_strong(Compile_lock);
1153   assert(is_interface(), &quot;not interface&quot;);
1154   // Filter out my subinterfaces.
1155   // (Note: Interfaces are never on the subklass list.)
1156   if (InstanceKlass::cast(k)-&gt;is_interface()) return;
1157 
1158   // Filter out subclasses whose supers already implement me.
1159   // (Note: CHA must walk subclasses of direct implementors
1160   // in order to locate indirect implementors.)
1161   Klass* sk = k-&gt;super();
1162   if (sk != NULL &amp;&amp; InstanceKlass::cast(sk)-&gt;implements_interface(this))
1163     // We only need to check one immediate superclass, since the
1164     // implements_interface query looks at transitive_interfaces.
1165     // Any supers of the super have the same (or fewer) transitive_interfaces.
1166     return;
1167 
1168   Klass* ik = implementor();
1169   if (ik == NULL) {
1170     set_implementor(k);
<span class="line-modified">1171   } else if (ik != this) {</span>
1172     // There is already an implementor. Use itself as an indicator of
1173     // more than one implementors.
1174     set_implementor(this);
1175   }
1176 
1177   // The implementor also implements the transitive_interfaces
1178   for (int index = 0; index &lt; local_interfaces()-&gt;length(); index++) {
1179     InstanceKlass::cast(local_interfaces()-&gt;at(index))-&gt;add_implementor(k);
1180   }
1181 }
1182 
1183 void InstanceKlass::init_implementor() {
1184   if (is_interface()) {
1185     set_implementor(NULL);
1186   }
1187 }
1188 
1189 
1190 void InstanceKlass::process_interfaces(Thread *thread) {
1191   // link this class into the implementors list of every interface it implements
</pre>
<hr />
<pre>
1297 }
1298 
1299 void InstanceKlass::check_valid_for_instantiation(bool throwError, TRAPS) {
1300   if (is_interface() || is_abstract()) {
1301     ResourceMark rm(THREAD);
1302     THROW_MSG(throwError ? vmSymbols::java_lang_InstantiationError()
1303               : vmSymbols::java_lang_InstantiationException(), external_name());
1304   }
1305   if (this == SystemDictionary::Class_klass()) {
1306     ResourceMark rm(THREAD);
1307     THROW_MSG(throwError ? vmSymbols::java_lang_IllegalAccessError()
1308               : vmSymbols::java_lang_IllegalAccessException(), external_name());
1309   }
1310 }
1311 
1312 Klass* InstanceKlass::array_klass_impl(bool or_null, int n, TRAPS) {
1313   // Need load-acquire for lock-free read
1314   if (array_klasses_acquire() == NULL) {
1315     if (or_null) return NULL;
1316 
<span class="line-modified">1317     ResourceMark rm;</span>
1318     JavaThread *jt = (JavaThread *)THREAD;
1319     {
1320       // Atomic creation of array_klasses
<span class="line-modified">1321       MutexLocker ma(MultiArray_lock, THREAD);</span>
1322 
1323       // Check if update has already taken place
1324       if (array_klasses() == NULL) {
1325         Klass*    k = ObjArrayKlass::allocate_objArray_klass(class_loader_data(), 1, this, CHECK_NULL);
1326         // use &#39;release&#39; to pair with lock-free load
1327         release_set_array_klasses(k);
1328       }
1329     }
1330   }
1331   // _this will always be set at this point
1332   ObjArrayKlass* oak = (ObjArrayKlass*)array_klasses();
1333   if (or_null) {
1334     return oak-&gt;array_klass_or_null(n);
1335   }
1336   return oak-&gt;array_klass(n, THREAD);
1337 }
1338 
1339 Klass* InstanceKlass::array_klass_impl(bool or_null, TRAPS) {
1340   return array_klass_impl(or_null, 1, THREAD);
1341 }
</pre>
<hr />
<pre>
1346   Method* clinit = find_method(
1347       vmSymbols::class_initializer_name(), vmSymbols::void_method_signature());
1348   if (clinit != NULL &amp;&amp; clinit-&gt;has_valid_initializer_flags()) {
1349     return clinit;
1350   }
1351   return NULL;
1352 }
1353 
1354 void InstanceKlass::call_class_initializer(TRAPS) {
1355   if (ReplayCompiles &amp;&amp;
1356       (ReplaySuppressInitializers == 1 ||
1357        (ReplaySuppressInitializers &gt;= 2 &amp;&amp; class_loader() != NULL))) {
1358     // Hide the existence of the initializer for the purpose of replaying the compile
1359     return;
1360   }
1361 
1362   methodHandle h_method(THREAD, class_initializer());
1363   assert(!is_initialized(), &quot;we cannot initialize twice&quot;);
1364   LogTarget(Info, class, init) lt;
1365   if (lt.is_enabled()) {
<span class="line-modified">1366     ResourceMark rm;</span>
1367     LogStream ls(lt);
1368     ls.print(&quot;%d Initializing &quot;, call_class_initializer_counter++);
1369     name()-&gt;print_value_on(&amp;ls);
1370     ls.print_cr(&quot;%s (&quot; INTPTR_FORMAT &quot;)&quot;, h_method() == NULL ? &quot;(no method)&quot; : &quot;&quot;, p2i(this));
1371   }
1372   if (h_method() != NULL) {
1373     JavaCallArguments args; // No arguments
1374     JavaValue result(T_VOID);
1375     JavaCalls::call(&amp;result, h_method, &amp;args, CHECK); // Static call (no args)
1376   }
1377 }
1378 
1379 
1380 void InstanceKlass::mask_for(const methodHandle&amp; method, int bci,
1381   InterpreterOopMap* entry_for) {
1382   // Lazily create the _oop_map_cache at first request
1383   // Lock-free access requires load_acquire.
<span class="line-modified">1384   OopMapCache* oop_map_cache = OrderAccess::load_acquire(&amp;_oop_map_cache);</span>
1385   if (oop_map_cache == NULL) {
1386     MutexLocker x(OopMapCacheAlloc_lock);
1387     // Check if _oop_map_cache was allocated while we were waiting for this lock
1388     if ((oop_map_cache = _oop_map_cache) == NULL) {
1389       oop_map_cache = new OopMapCache();
1390       // Ensure _oop_map_cache is stable, since it is examined without a lock
<span class="line-modified">1391       OrderAccess::release_store(&amp;_oop_map_cache, oop_map_cache);</span>
1392     }
1393   }
1394   // _oop_map_cache is constant after init; lookup below does its own locking.
1395   oop_map_cache-&gt;lookup(method, bci, entry_for);
1396 }
1397 




1398 
1399 bool InstanceKlass::find_local_field(Symbol* name, Symbol* sig, fieldDescriptor* fd) const {
1400   for (JavaFieldStream fs(this); !fs.done(); fs.next()) {
1401     Symbol* f_name = fs.name();
1402     Symbol* f_sig  = fs.signature();
1403     if (f_name == name &amp;&amp; f_sig == sig) {
1404       fd-&gt;reinitialize(const_cast&lt;InstanceKlass*&gt;(this), fs.index());
1405       return true;
1406     }
1407   }
1408   return false;
1409 }
1410 
1411 
1412 Klass* InstanceKlass::find_interface_field(Symbol* name, Symbol* sig, fieldDescriptor* fd) const {
1413   const int n = local_interfaces()-&gt;length();
1414   for (int i = 0; i &lt; n; i++) {
1415     Klass* intf1 = local_interfaces()-&gt;at(i);
1416     assert(intf1-&gt;is_interface(), &quot;just checking type&quot;);
1417     // search for field in current interface
</pre>
<hr />
<pre>
1571   if (array_klasses() != NULL)
1572     ArrayKlass::cast(array_klasses())-&gt;array_klasses_do(f);
1573 }
1574 
1575 #ifdef ASSERT
1576 static int linear_search(const Array&lt;Method*&gt;* methods,
1577                          const Symbol* name,
1578                          const Symbol* signature) {
1579   const int len = methods-&gt;length();
1580   for (int index = 0; index &lt; len; index++) {
1581     const Method* const m = methods-&gt;at(index);
1582     assert(m-&gt;is_method(), &quot;must be method&quot;);
1583     if (m-&gt;signature() == signature &amp;&amp; m-&gt;name() == name) {
1584        return index;
1585     }
1586   }
1587   return -1;
1588 }
1589 #endif
1590 
<span class="line-modified">1591 static int binary_search(const Array&lt;Method*&gt;* methods, const Symbol* name) {</span>

























1592   int len = methods-&gt;length();
<span class="line-removed">1593   // methods are sorted, so do binary search</span>
1594   int l = 0;
1595   int h = len - 1;


1596   while (l &lt;= h) {
1597     int mid = (l + h) &gt;&gt; 1;
1598     Method* m = methods-&gt;at(mid);
1599     assert(m-&gt;is_method(), &quot;must be method&quot;);
1600     int res = m-&gt;name()-&gt;fast_compare(name);
1601     if (res == 0) {
1602       return mid;
1603     } else if (res &lt; 0) {
1604       l = mid + 1;
1605     } else {
1606       h = mid - 1;
1607     }
1608   }
1609   return -1;
1610 }
1611 
1612 // find_method looks up the name/signature in the local methods array
1613 Method* InstanceKlass::find_method(const Symbol* name,
1614                                    const Symbol* signature) const {
1615   return find_method_impl(name, signature, find_overpass, find_static, find_private);
</pre>
<hr />
<pre>
1727 // default_vtable_indices, and indirectly by find_method
1728 // find_method_index looks in the local methods array to return the index
1729 // of the matching name/signature. If, overpass methods are being ignored,
1730 // the search continues to find a potential non-overpass match.  This capability
1731 // is important during method resolution to prefer a static method, for example,
1732 // over an overpass method.
1733 // There is the possibility in any _method&#39;s array to have the same name/signature
1734 // for a static method, an overpass method and a local instance method
1735 // To correctly catch a given method, the search criteria may need
1736 // to explicitly skip the other two. For local instance methods, it
1737 // is often necessary to skip private methods
1738 int InstanceKlass::find_method_index(const Array&lt;Method*&gt;* methods,
1739                                      const Symbol* name,
1740                                      const Symbol* signature,
1741                                      OverpassLookupMode overpass_mode,
1742                                      StaticLookupMode static_mode,
1743                                      PrivateLookupMode private_mode) {
1744   const bool skipping_overpass = (overpass_mode == skip_overpass);
1745   const bool skipping_static = (static_mode == skip_static);
1746   const bool skipping_private = (private_mode == skip_private);
<span class="line-modified">1747   const int hit = binary_search(methods, name);</span>
1748   if (hit != -1) {
1749     const Method* const m = methods-&gt;at(hit);
1750 
1751     // Do linear search to find matching signature.  First, quick check
1752     // for common case, ignoring overpasses if requested.
1753     if (method_matches(m, signature, skipping_overpass, skipping_static, skipping_private)) {
1754       return hit;
1755     }
1756 
1757     // search downwards through overloaded methods
1758     int i;
1759     for (i = hit - 1; i &gt;= 0; --i) {
1760         const Method* const m = methods-&gt;at(i);
1761         assert(m-&gt;is_method(), &quot;must be method&quot;);
1762         if (m-&gt;name() != name) {
1763           break;
1764         }
1765         if (method_matches(m, signature, skipping_overpass, skipping_static, skipping_private)) {
1766           return i;
1767         }
</pre>
<hr />
<pre>
1778         }
1779     }
1780     // not found
1781 #ifdef ASSERT
1782     const int index = (skipping_overpass || skipping_static || skipping_private) ? -1 :
1783       linear_search(methods, name, signature);
1784     assert(-1 == index, &quot;binary search should have found entry %d&quot;, index);
1785 #endif
1786   }
1787   return -1;
1788 }
1789 
1790 int InstanceKlass::find_method_by_name(const Symbol* name, int* end) const {
1791   return find_method_by_name(methods(), name, end);
1792 }
1793 
1794 int InstanceKlass::find_method_by_name(const Array&lt;Method*&gt;* methods,
1795                                        const Symbol* name,
1796                                        int* end_ptr) {
1797   assert(end_ptr != NULL, &quot;just checking&quot;);
<span class="line-modified">1798   int start = binary_search(methods, name);</span>
1799   int end = start + 1;
1800   if (start != -1) {
1801     while (start - 1 &gt;= 0 &amp;&amp; (methods-&gt;at(start - 1))-&gt;name() == name) --start;
1802     while (end &lt; methods-&gt;length() &amp;&amp; (methods-&gt;at(end))-&gt;name() == name) ++end;
1803     *end_ptr = end;
1804     return start;
1805   }
1806   return -1;
1807 }
1808 
1809 // uncached_lookup_method searches both the local class methods array and all
1810 // superclasses methods arrays, skipping any overpass methods in superclasses,
1811 // and possibly skipping private methods.
1812 Method* InstanceKlass::uncached_lookup_method(const Symbol* name,
1813                                               const Symbol* signature,
1814                                               OverpassLookupMode overpass_mode,
1815                                               PrivateLookupMode private_mode) const {
1816   OverpassLookupMode overpass_local_mode = overpass_mode;
1817   const Klass* klass = this;
1818   while (klass != NULL) {
</pre>
<hr />
<pre>
1955   // generally acquired in those two cases.
1956   //
1957   // If the RedefineClasses() API has been used, then this cache can
1958   // grow and we&#39;ll have transitions from non-NULL to bigger non-NULL.
1959   // Cache creation requires no leaks and we require safety between all
1960   // cache accesses and freeing of the old cache so a lock is generally
1961   // acquired when the RedefineClasses() API has been used.
1962 
1963   if (jmeths != NULL) {
1964     // the cache already exists
1965     if (!idnum_can_increment()) {
1966       // the cache can&#39;t grow so we can just get the current values
1967       get_jmethod_id_length_value(jmeths, idnum, &amp;length, &amp;id);
1968     } else {
1969       // cache can grow so we have to be more careful
1970       if (Threads::number_of_threads() == 0 ||
1971           SafepointSynchronize::is_at_safepoint()) {
1972         // we&#39;re single threaded or at a safepoint - no locking needed
1973         get_jmethod_id_length_value(jmeths, idnum, &amp;length, &amp;id);
1974       } else {
<span class="line-modified">1975         MutexLocker ml(JmethodIdCreation_lock);</span>
1976         get_jmethod_id_length_value(jmeths, idnum, &amp;length, &amp;id);
1977       }
1978     }
1979   }
1980   // implied else:
1981   // we need to allocate a cache so default length and id values are good
1982 
1983   if (jmeths == NULL ||   // no cache yet
1984       length &lt;= idnum ||  // cache is too short
1985       id == NULL) {       // cache doesn&#39;t contain entry
1986 
1987     // This function can be called by the VMThread so we have to do all
1988     // things that might block on a safepoint before grabbing the lock.
1989     // Otherwise, we can deadlock with the VMThread or have a cache
1990     // consistency issue. These vars keep track of what we might have
1991     // to free after the lock is dropped.
1992     jmethodID  to_dealloc_id     = NULL;
1993     jmethodID* to_dealloc_jmeths = NULL;
1994 
1995     // may not allocate new_jmeths or use it if we allocate it
</pre>
<hr />
<pre>
2005 
2006     // allocate a new jmethodID that might be used
2007     jmethodID new_id = NULL;
2008     if (method_h-&gt;is_old() &amp;&amp; !method_h-&gt;is_obsolete()) {
2009       // The method passed in is old (but not obsolete), we need to use the current version
2010       Method* current_method = method_with_idnum((int)idnum);
2011       assert(current_method != NULL, &quot;old and but not obsolete, so should exist&quot;);
2012       new_id = Method::make_jmethod_id(class_loader_data(), current_method);
2013     } else {
2014       // It is the current version of the method or an obsolete method,
2015       // use the version passed in
2016       new_id = Method::make_jmethod_id(class_loader_data(), method_h());
2017     }
2018 
2019     if (Threads::number_of_threads() == 0 ||
2020         SafepointSynchronize::is_at_safepoint()) {
2021       // we&#39;re single threaded or at a safepoint - no locking needed
2022       id = get_jmethod_id_fetch_or_update(idnum, new_id, new_jmeths,
2023                                           &amp;to_dealloc_id, &amp;to_dealloc_jmeths);
2024     } else {
<span class="line-modified">2025       MutexLocker ml(JmethodIdCreation_lock);</span>
2026       id = get_jmethod_id_fetch_or_update(idnum, new_id, new_jmeths,
2027                                           &amp;to_dealloc_id, &amp;to_dealloc_jmeths);
2028     }
2029 
2030     // The lock has been dropped so we can free resources.
2031     // Free up either the old cache or the new cache if we allocated one.
2032     if (to_dealloc_jmeths != NULL) {
2033       FreeHeap(to_dealloc_jmeths);
2034     }
2035     // free up the new ID since it wasn&#39;t needed
2036     if (to_dealloc_id != NULL) {
2037       Method::destroy_jmethod_id(class_loader_data(), to_dealloc_id);
2038     }
2039   }
2040   return id;
2041 }
2042 
2043 // Figure out how many jmethodIDs haven&#39;t been allocated, and make
2044 // sure space for them is pre-allocated.  This makes getting all
2045 // method ids much, much faster with classes with more than 8
</pre>
<hr />
<pre>
2089         new_jmeths[index+1] = jmeths[index+1];
2090       }
2091       *to_dealloc_jmeths_p = jmeths;  // save old cache for later delete
2092     }
2093     release_set_methods_jmethod_ids(jmeths = new_jmeths);
2094   } else {
2095     // fetch jmethodID (if any) from the existing cache
2096     id = jmeths[idnum+1];
2097     *to_dealloc_jmeths_p = new_jmeths;  // save new cache for later delete
2098   }
2099   if (id == NULL) {
2100     // No matching jmethodID in the existing cache or we have a new
2101     // cache or we just grew the cache. This cache write is done here
2102     // by the first thread to win the foot race because a jmethodID
2103     // needs to be unique once it is generally available.
2104     id = new_id;
2105 
2106     // The jmethodID cache can be read while unlocked so we have to
2107     // make sure the new jmethodID is complete before installing it
2108     // in the cache.
<span class="line-modified">2109     OrderAccess::release_store(&amp;jmeths[idnum+1], id);</span>
2110   } else {
2111     *to_dealloc_id_p = new_id; // save new id for later delete
2112   }
2113   return id;
2114 }
2115 
2116 
2117 // Common code to get the jmethodID cache length and the jmethodID
2118 // value at index idnum if there is one.
2119 //
2120 void InstanceKlass::get_jmethod_id_length_value(jmethodID* cache,
2121        size_t idnum, size_t *length_p, jmethodID* id_p) {
2122   assert(cache != NULL, &quot;sanity check&quot;);
2123   assert(length_p != NULL, &quot;sanity check&quot;);
2124   assert(id_p != NULL, &quot;sanity check&quot;);
2125 
2126   // cache size is stored in element[0], other elements offset by one
2127   *length_p = (size_t)cache[0];
2128   if (*length_p &lt;= idnum) {  // cache is too short
2129     *id_p = NULL;
</pre>
<hr />
<pre>
2171 void InstanceKlass::print_dependent_nmethods(bool verbose) {
2172   dependencies().print_dependent_nmethods(verbose);
2173 }
2174 
2175 bool InstanceKlass::is_dependent_nmethod(nmethod* nm) {
2176   return dependencies().is_dependent_nmethod(nm);
2177 }
2178 #endif //PRODUCT
2179 
2180 void InstanceKlass::clean_weak_instanceklass_links() {
2181   clean_implementors_list();
2182   clean_method_data();
2183 }
2184 
2185 void InstanceKlass::clean_implementors_list() {
2186   assert(is_loader_alive(), &quot;this klass should be live&quot;);
2187   if (is_interface()) {
2188     assert (ClassUnloading, &quot;only called for ClassUnloading&quot;);
2189     for (;;) {
2190       // Use load_acquire due to competing with inserts
<span class="line-modified">2191       Klass* impl = OrderAccess::load_acquire(adr_implementor());</span>
2192       if (impl != NULL &amp;&amp; !impl-&gt;is_loader_alive()) {
2193         // NULL this field, might be an unloaded klass or NULL
2194         Klass* volatile* klass = adr_implementor();
<span class="line-modified">2195         if (Atomic::cmpxchg((Klass*)NULL, klass, impl) == impl) {</span>
2196           // Successfully unlinking implementor.
2197           if (log_is_enabled(Trace, class, unload)) {
2198             ResourceMark rm;
2199             log_trace(class, unload)(&quot;unlinking class (implementor): %s&quot;, impl-&gt;external_name());
2200           }
2201           return;
2202         }
2203       } else {
2204         return;
2205       }
2206     }
2207   }
2208 }
2209 
2210 void InstanceKlass::clean_method_data() {
2211   for (int m = 0; m &lt; methods()-&gt;length(); m++) {
2212     MethodData* mdo = methods()-&gt;at(m)-&gt;method_data();
2213     if (mdo != NULL) {
<span class="line-modified">2214       MutexLockerEx ml(SafepointSynchronize::is_at_safepoint() ? NULL : mdo-&gt;extra_data_lock());</span>
2215       mdo-&gt;clean_method_data(/*always_clean*/false);
2216     }
2217   }
2218 }
2219 
2220 bool InstanceKlass::supers_have_passed_fingerprint_checks() {
2221   if (java_super() != NULL &amp;&amp; !java_super()-&gt;has_passed_fingerprint_check()) {
2222     ResourceMark rm;
2223     log_trace(class, fingerprint)(&quot;%s : super %s not fingerprinted&quot;, external_name(), java_super()-&gt;external_name());
2224     return false;
2225   }
2226 
2227   Array&lt;InstanceKlass*&gt;* local_interfaces = this-&gt;local_interfaces();
2228   if (local_interfaces != NULL) {
2229     int length = local_interfaces-&gt;length();
2230     for (int i = 0; i &lt; length; i++) {
2231       InstanceKlass* intf = local_interfaces-&gt;at(i);
2232       if (!intf-&gt;has_passed_fingerprint_check()) {
2233         ResourceMark rm;
2234         log_trace(class, fingerprint)(&quot;%s : interface %s not fingerprinted&quot;, external_name(), intf-&gt;external_name());
2235         return false;
2236       }
2237     }
2238   }
2239 
2240   return true;
2241 }
2242 
2243 bool InstanceKlass::should_store_fingerprint(bool is_unsafe_anonymous) {
2244 #if INCLUDE_AOT
2245   // We store the fingerprint into the InstanceKlass only in the following 2 cases:
2246   if (CalculateClassFingerprint) {
2247     // (1) We are running AOT to generate a shared library.
2248     return true;
2249   }
<span class="line-modified">2250   if (DumpSharedSpaces) {</span>
<span class="line-modified">2251     // (2) We are running -Xshare:dump to create a shared archive</span>
2252     return true;
2253   }
2254   if (UseAOT &amp;&amp; is_unsafe_anonymous) {
2255     // (3) We are using AOT code from a shared library and see an unsafe anonymous class
2256     return true;
2257   }
2258 #endif
2259 
2260   // In all other cases we might set the _misc_has_passed_fingerprint_check bit,
2261   // but do not store the 64-bit fingerprint to save space.
2262   return false;
2263 }
2264 
2265 bool InstanceKlass::has_stored_fingerprint() const {
2266 #if INCLUDE_AOT
2267   return should_store_fingerprint() || is_shared();
2268 #else
2269   return false;
2270 #endif
2271 }
</pre>
<hr />
<pre>
2314 
2315   if (itable_length() &gt; 0) {
2316     itableOffsetEntry* ioe = (itableOffsetEntry*)start_of_itable();
2317     int method_table_offset_in_words = ioe-&gt;offset()/wordSize;
2318     int nof_interfaces = (method_table_offset_in_words - itable_offset_in_words())
2319                          / itableOffsetEntry::size();
2320 
2321     for (int i = 0; i &lt; nof_interfaces; i ++, ioe ++) {
2322       if (ioe-&gt;interface_klass() != NULL) {
2323         it-&gt;push(ioe-&gt;interface_klass_addr());
2324         itableMethodEntry* ime = ioe-&gt;first_method_entry(this);
2325         int n = klassItable::method_count_for_interface(ioe-&gt;interface_klass());
2326         for (int index = 0; index &lt; n; index ++) {
2327           it-&gt;push(ime[index].method_addr());
2328         }
2329       }
2330     }
2331   }
2332 
2333   it-&gt;push(&amp;_nest_members);

2334 }
2335 
2336 void InstanceKlass::remove_unshareable_info() {
2337   Klass::remove_unshareable_info();
2338 
2339   if (is_in_error_state()) {
2340     // Classes are attempted to link during dumping and may fail,
2341     // but these classes are still in the dictionary and class list in CLD.
2342     // Check in_error state first because in_error is &gt; linked state, so
2343     // is_linked() is true.
2344     // If there&#39;s a linking error, there is nothing else to remove.
2345     return;
2346   }
2347 
2348   // Reset to the &#39;allocated&#39; state to prevent any premature accessing to
2349   // a shared class at runtime while the class is still being loaded and
2350   // restored. A class&#39; init_state is set to &#39;loaded&#39; at runtime when it&#39;s
2351   // being added to class hierarchy (see SystemDictionary:::add_to_hierarchy()).
2352   _init_state = allocated;
2353 
<span class="line-modified">2354   {</span>
<span class="line-modified">2355     MutexLocker ml(Compile_lock);</span>
2356     init_implementor();
2357   }
2358 
2359   constants()-&gt;remove_unshareable_info();
2360 
2361   for (int i = 0; i &lt; methods()-&gt;length(); i++) {
2362     Method* m = methods()-&gt;at(i);
2363     m-&gt;remove_unshareable_info();
2364   }
2365 
2366   // do array classes also.
2367   if (array_klasses() != NULL) {
2368     array_klasses()-&gt;remove_unshareable_info();
2369   }
2370 
<span class="line-modified">2371   // These are not allocated from metaspace, but they should should all be empty</span>
<span class="line-modified">2372   // during dump time, so we don&#39;t need to worry about them in InstanceKlass::iterate().</span>
<span class="line-modified">2373   guarantee(_source_debug_extension == NULL, &quot;must be&quot;);</span>
<span class="line-modified">2374   guarantee(_dep_context == NULL, &quot;must be&quot;);</span>
<span class="line-removed">2375   guarantee(_osr_nmethods_head == NULL, &quot;must be&quot;);</span>
<span class="line-removed">2376 </span>
2377 #if INCLUDE_JVMTI
<span class="line-modified">2378   guarantee(_breakpoints == NULL, &quot;must be&quot;);</span>
<span class="line-modified">2379   guarantee(_previous_versions == NULL, &quot;must be&quot;);</span>
2380   _cached_class_file = NULL;

2381 #endif
2382 
2383   _init_thread = NULL;
2384   _methods_jmethod_ids = NULL;
2385   _jni_ids = NULL;
2386   _oop_map_cache = NULL;
2387   // clear _nest_host to ensure re-load at runtime
2388   _nest_host = NULL;


2389 }
2390 
2391 void InstanceKlass::remove_java_mirror() {
2392   Klass::remove_java_mirror();
2393 
2394   // do array classes also.
2395   if (array_klasses() != NULL) {
2396     array_klasses()-&gt;remove_java_mirror();
2397   }
2398 }
2399 
2400 void InstanceKlass::restore_unshareable_info(ClassLoaderData* loader_data, Handle protection_domain, TRAPS) {
2401   // SystemDictionary::add_to_hierarchy() sets the init_state to loaded
2402   // before the InstanceKlass is added to the SystemDictionary. Make
2403   // sure the current state is &lt;loaded.
2404   assert(!is_loaded(), &quot;invalid init state&quot;);
2405   set_package(loader_data, CHECK);
2406   Klass::restore_unshareable_info(loader_data, protection_domain, CHECK);
2407 
2408   Array&lt;Method*&gt;* methods = this-&gt;methods();
</pre>
<hr />
<pre>
2411     methods-&gt;at(index)-&gt;restore_unshareable_info(CHECK);
2412   }
2413   if (JvmtiExport::has_redefined_a_class()) {
2414     // Reinitialize vtable because RedefineClasses may have changed some
2415     // entries in this vtable for super classes so the CDS vtable might
2416     // point to old or obsolete entries.  RedefineClasses doesn&#39;t fix up
2417     // vtables in the shared system dictionary, only the main one.
2418     // It also redefines the itable too so fix that too.
2419     vtable().initialize_vtable(false, CHECK);
2420     itable().initialize_itable(false, CHECK);
2421   }
2422 
2423   // restore constant pool resolved references
2424   constants()-&gt;restore_unshareable_info(CHECK);
2425 
2426   if (array_klasses() != NULL) {
2427     // Array classes have null protection domain.
2428     // --&gt; see ArrayKlass::complete_create_array_klass()
2429     array_klasses()-&gt;restore_unshareable_info(ClassLoaderData::the_null_class_loader_data(), Handle(), CHECK);
2430   }





2431 }
2432 
2433 // returns true IFF is_in_error_state() has been changed as a result of this call.
2434 bool InstanceKlass::check_sharing_error_state() {
2435   assert(DumpSharedSpaces, &quot;should only be called during dumping&quot;);
2436   bool old_state = is_in_error_state();
2437 
2438   if (!is_in_error_state()) {
2439     bool bad = false;
2440     for (InstanceKlass* sup = java_super(); sup; sup = sup-&gt;java_super()) {
2441       if (sup-&gt;is_in_error_state()) {
2442         bad = true;
2443         break;
2444       }
2445     }
2446     if (!bad) {
2447       Array&lt;InstanceKlass*&gt;* interfaces = transitive_interfaces();
2448       for (int i = 0; i &lt; interfaces-&gt;length(); i++) {
2449         InstanceKlass* iface = interfaces-&gt;at(i);
2450         if (iface-&gt;is_in_error_state()) {
2451           bad = true;
2452           break;
2453         }
2454       }
2455     }
2456 
2457     if (bad) {
2458       set_in_error_state();
2459     }
2460   }
2461 
2462   return (old_state != is_in_error_state());
2463 }
2464 

















2465 #if INCLUDE_JVMTI
2466 static void clear_all_breakpoints(Method* m) {
2467   m-&gt;clear_all_breakpoints();
2468 }
2469 #endif
2470 
2471 void InstanceKlass::unload_class(InstanceKlass* ik) {
2472   // Release dependencies.
2473   ik-&gt;dependencies().remove_all_dependents();
2474 
2475   // notify the debugger
2476   if (JvmtiExport::should_post_class_unload()) {
2477     JvmtiExport::post_class_unload(ik);
2478   }
2479 
2480   // notify ClassLoadingService of class unload
2481   ClassLoadingService::notify_class_unloaded(ik);
2482 




2483   if (log_is_enabled(Info, class, unload)) {
2484     ResourceMark rm;
2485     log_info(class, unload)(&quot;unloading class %s &quot; INTPTR_FORMAT, ik-&gt;external_name(), p2i(ik));
2486   }
2487 
2488   Events::log_class_unloading(Thread::current(), ik);
2489 
2490 #if INCLUDE_JFR
2491   assert(ik != NULL, &quot;invariant&quot;);
2492   EventClassUnload event;
2493   event.set_unloadedClass(ik);
2494   event.set_definingClassLoader(ik-&gt;class_loader_data());
2495   event.commit();
2496 #endif
2497 }
2498 




2499 void InstanceKlass::release_C_heap_structures(InstanceKlass* ik) {
2500   // Clean up C heap
2501   ik-&gt;release_C_heap_structures();
2502   ik-&gt;constants()-&gt;release_C_heap_structures();




2503 }
2504 
2505 void InstanceKlass::release_C_heap_structures() {
2506   // Can&#39;t release the constant pool here because the constant pool can be
2507   // deallocated separately from the InstanceKlass for default methods and
2508   // redefine classes.
2509 
2510   // Deallocate oop map cache
2511   if (_oop_map_cache != NULL) {
2512     delete _oop_map_cache;
2513     _oop_map_cache = NULL;
2514   }
2515 
2516   // Deallocate JNI identifiers for jfieldIDs
2517   JNIid::deallocate(jni_ids());
2518   set_jni_ids(NULL);
2519 
2520   jmethodID* jmeths = methods_jmethod_ids_acquire();
2521   if (jmeths != (jmethodID*)NULL) {
2522     release_set_methods_jmethod_ids(NULL);
</pre>
<hr />
<pre>
2528 
2529 #if INCLUDE_JVMTI
2530   // Deallocate breakpoint records
2531   if (breakpoints() != 0x0) {
2532     methods_do(clear_all_breakpoints);
2533     assert(breakpoints() == 0x0, &quot;should have cleared breakpoints&quot;);
2534   }
2535 
2536   // deallocate the cached class file
2537   if (_cached_class_file != NULL) {
2538     os::free(_cached_class_file);
2539     _cached_class_file = NULL;
2540   }
2541 #endif
2542 
2543   // Decrement symbol reference counts associated with the unloaded class.
2544   if (_name != NULL) _name-&gt;decrement_refcount();
2545   // unreference array name derived from this class name (arrays of an unloaded
2546   // class can&#39;t be referenced anymore).
2547   if (_array_name != NULL)  _array_name-&gt;decrement_refcount();
<span class="line-modified">2548   if (_source_debug_extension != NULL) FREE_C_HEAP_ARRAY(char, _source_debug_extension);</span>
2549 }
2550 
2551 void InstanceKlass::set_source_debug_extension(const char* array, int length) {
2552   if (array == NULL) {
2553     _source_debug_extension = NULL;
2554   } else {
2555     // Adding one to the attribute length in order to store a null terminator
2556     // character could cause an overflow because the attribute length is
2557     // already coded with an u4 in the classfile, but in practice, it&#39;s
2558     // unlikely to happen.
2559     assert((length+1) &gt; length, &quot;Overflow checking&quot;);
2560     char* sde = NEW_C_HEAP_ARRAY(char, (length + 1), mtClass);
2561     for (int i = 0; i &lt; length; i++) {
2562       sde[i] = array[i];
2563     }
2564     sde[length] = &#39;\0&#39;;
2565     _source_debug_extension = sde;
2566   }
2567 }
2568 
2569 const char* InstanceKlass::signature_name() const {
2570   int hash_len = 0;
2571   char hash_buf[40];
2572 
2573   // If this is an unsafe anonymous class, append a hash to make the name unique
2574   if (is_unsafe_anonymous()) {
2575     intptr_t hash = (java_mirror() != NULL) ? java_mirror()-&gt;identity_hash() : 0;
2576     jio_snprintf(hash_buf, sizeof(hash_buf), &quot;/&quot; UINTX_FORMAT, (uintx)hash);
2577     hash_len = (int)strlen(hash_buf);
2578   }
2579 
2580   // Get the internal name as a c string
2581   const char* src = (const char*) (name()-&gt;as_C_string());
2582   const int src_length = (int)strlen(src);
2583 
2584   char* dest = NEW_RESOURCE_ARRAY(char, src_length + hash_len + 3);
2585 
2586   // Add L as type indicator
2587   int dest_index = 0;
<span class="line-modified">2588   dest[dest_index++] = &#39;L&#39;;</span>
2589 
2590   // Add the actual class name
2591   for (int src_index = 0; src_index &lt; src_length; ) {
2592     dest[dest_index++] = src[src_index++];
2593   }
2594 
2595   // If we have a hash, append it
2596   for (int hash_index = 0; hash_index &lt; hash_len; ) {
2597     dest[dest_index++] = hash_buf[hash_index++];
2598   }
2599 
2600   // Add the semicolon and the NULL
<span class="line-modified">2601   dest[dest_index++] = &#39;;&#39;;</span>
2602   dest[dest_index] = &#39;\0&#39;;
2603   return dest;
2604 }
2605 
2606 // Used to obtain the package name from a fully qualified class name.
2607 Symbol* InstanceKlass::package_from_name(const Symbol* name, TRAPS) {
2608   if (name == NULL) {
2609     return NULL;
2610   } else {
2611     if (name-&gt;utf8_length() &lt;= 0) {
2612       return NULL;
2613     }
<span class="line-modified">2614     ResourceMark rm;</span>
2615     const char* package_name = ClassLoader::package_from_name((const char*) name-&gt;as_C_string());
2616     if (package_name == NULL) {
2617       return NULL;
2618     }
<span class="line-modified">2619     Symbol* pkg_name = SymbolTable::new_symbol(package_name, THREAD);</span>
2620     return pkg_name;
2621   }
2622 }
2623 
2624 ModuleEntry* InstanceKlass::module() const {
2625   // For an unsafe anonymous class return the host class&#39; module
2626   if (is_unsafe_anonymous()) {
2627     assert(unsafe_anonymous_host() != NULL, &quot;unsafe anonymous class must have a host class&quot;);
2628     return unsafe_anonymous_host()-&gt;module();
2629   }
2630 
2631   // Class is in a named package
2632   if (!in_unnamed_package()) {
2633     return _package_entry-&gt;module();
2634   }
2635 
2636   // Class is in an unnamed package, return its loader&#39;s unnamed module
2637   return class_loader_data()-&gt;unnamed_module();
2638 }
2639 
2640 void InstanceKlass::set_package(ClassLoaderData* loader_data, TRAPS) {
2641 
2642   // ensure java/ packages only loaded by boot or platform builtin loaders
2643   check_prohibited_package(name(), loader_data, CHECK);
2644 
2645   TempNewSymbol pkg_name = package_from_name(name(), CHECK);
2646 
2647   if (pkg_name != NULL &amp;&amp; loader_data != NULL) {
2648 
2649     // Find in class loader&#39;s package entry table.
2650     _package_entry = loader_data-&gt;packages()-&gt;lookup_only(pkg_name);
2651 
2652     // If the package name is not found in the loader&#39;s package
2653     // entry table, it is an indication that the package has not
2654     // been defined. Consider it defined within the unnamed module.
2655     if (_package_entry == NULL) {
<span class="line-modified">2656       ResourceMark rm;</span>
2657 
2658       if (!ModuleEntryTable::javabase_defined()) {
2659         // Before java.base is defined during bootstrapping, define all packages in
2660         // the java.base module.  If a non-java.base package is erroneously placed
2661         // in the java.base module it will be caught later when java.base
2662         // is defined by ModuleEntryTable::verify_javabase_packages check.
2663         assert(ModuleEntryTable::javabase_moduleEntry() != NULL, JAVA_BASE_NAME &quot; module is NULL&quot;);
2664         _package_entry = loader_data-&gt;packages()-&gt;lookup(pkg_name, ModuleEntryTable::javabase_moduleEntry());
2665       } else {
2666         assert(loader_data-&gt;unnamed_module() != NULL, &quot;unnamed module is NULL&quot;);
2667         _package_entry = loader_data-&gt;packages()-&gt;lookup(pkg_name,
2668                                                          loader_data-&gt;unnamed_module());
2669       }
2670 
2671       // A package should have been successfully created
2672       assert(_package_entry != NULL, &quot;Package entry for class %s not found, loader %s&quot;,
2673              name()-&gt;as_C_string(), loader_data-&gt;loader_name_and_id());
2674     }
2675 
2676     if (log_is_enabled(Debug, module)) {
<span class="line-modified">2677       ResourceMark rm;</span>
2678       ModuleEntry* m = _package_entry-&gt;module();
2679       log_trace(module)(&quot;Setting package: class: %s, package: %s, loader: %s, module: %s&quot;,
2680                         external_name(),
2681                         pkg_name-&gt;as_C_string(),
2682                         loader_data-&gt;loader_name_and_id(),
2683                         (m-&gt;is_named() ? m-&gt;name()-&gt;as_C_string() : UNNAMED_MODULE));
2684     }
2685   } else {
<span class="line-modified">2686     ResourceMark rm;</span>
2687     log_trace(module)(&quot;Setting package: class: %s, package: unnamed, loader: %s, module: %s&quot;,
2688                       external_name(),
2689                       (loader_data != NULL) ? loader_data-&gt;loader_name_and_id() : &quot;NULL&quot;,
2690                       UNNAMED_MODULE);
2691   }
2692 }
2693 
2694 
2695 // different versions of is_same_class_package
2696 
2697 bool InstanceKlass::is_same_class_package(const Klass* class2) const {
2698   oop classloader1 = this-&gt;class_loader();
2699   PackageEntry* classpkg1 = this-&gt;package();
2700   if (class2-&gt;is_objArray_klass()) {
2701     class2 = ObjArrayKlass::cast(class2)-&gt;bottom_klass();
2702   }
2703 
2704   oop classloader2;
2705   PackageEntry* classpkg2;
2706   if (class2-&gt;is_instance_klass()) {
2707     classloader2 = class2-&gt;class_loader();
2708     classpkg2 = class2-&gt;package();
2709   } else {
2710     assert(class2-&gt;is_typeArray_klass(), &quot;should be type array&quot;);
2711     classloader2 = NULL;
2712     classpkg2 = NULL;
2713   }
2714 
2715   // Same package is determined by comparing class loader
2716   // and package entries. Both must be the same. This rule
2717   // applies even to classes that are defined in the unnamed
2718   // package, they still must have the same class loader.
<span class="line-modified">2719   if (oopDesc::equals(classloader1, classloader2) &amp;&amp; (classpkg1 == classpkg2)) {</span>
2720     return true;
2721   }
2722 
2723   return false;
2724 }
2725 
2726 // return true if this class and other_class are in the same package. Classloader
2727 // and classname information is enough to determine a class&#39;s package
2728 bool InstanceKlass::is_same_class_package(oop other_class_loader,
2729                                           const Symbol* other_class_name) const {
<span class="line-modified">2730   if (!oopDesc::equals(class_loader(), other_class_loader)) {</span>
2731     return false;
2732   }
2733   if (name()-&gt;fast_compare(other_class_name) == 0) {
2734      return true;
2735   }
2736 
2737   {
2738     ResourceMark rm;
2739 
2740     bool bad_class_name = false;
2741     const char* other_pkg =
2742       ClassLoader::package_from_name((const char*) other_class_name-&gt;as_C_string(), &amp;bad_class_name);
2743     if (bad_class_name) {
2744       return false;
2745     }
2746     // Check that package_from_name() returns NULL, not &quot;&quot;, if there is no package.
2747     assert(other_pkg == NULL || strlen(other_pkg) &gt; 0, &quot;package name is empty string&quot;);
2748 
2749     const Symbol* const this_package_name =
2750       this-&gt;package() != NULL ? this-&gt;package()-&gt;name() : NULL;
</pre>
<hr />
<pre>
2955 
2956       if (log_is_enabled(Info, redefine, class, update)) {
2957         ResourceMark rm;
2958         if (!(*trace_name_printed)) {
2959           log_info(redefine, class, update)
2960             (&quot;adjust: klassname=%s default methods from name=%s&quot;,
2961              external_name(), old_method-&gt;method_holder()-&gt;external_name());
2962           *trace_name_printed = true;
2963         }
2964         log_debug(redefine, class, update, vtables)
2965           (&quot;default method update: %s(%s) &quot;,
2966            new_method-&gt;name()-&gt;as_C_string(), new_method-&gt;signature()-&gt;as_C_string());
2967       }
2968     }
2969   }
2970 }
2971 #endif // INCLUDE_JVMTI
2972 
2973 // On-stack replacement stuff
2974 void InstanceKlass::add_osr_nmethod(nmethod* n) {








2975   // only one compilation can be active
2976   {
<span class="line-removed">2977     // This is a short non-blocking critical region, so the no safepoint check is ok.</span>
<span class="line-removed">2978     MutexLockerEx ml(OsrList_lock, Mutex::_no_safepoint_check_flag);</span>
2979     assert(n-&gt;is_osr_method(), &quot;wrong kind of nmethod&quot;);
2980     n-&gt;set_osr_link(osr_nmethods_head());
2981     set_osr_nmethods_head(n);
2982     // Raise the highest osr level if necessary
2983     if (TieredCompilation) {
2984       Method* m = n-&gt;method();
2985       m-&gt;set_highest_osr_comp_level(MAX2(m-&gt;highest_osr_comp_level(), n-&gt;comp_level()));
2986     }
2987   }
2988 
2989   // Get rid of the osr methods for the same bci that have lower levels.
2990   if (TieredCompilation) {
2991     for (int l = CompLevel_limited_profile; l &lt; n-&gt;comp_level(); l++) {
2992       nmethod *inv = lookup_osr_nmethod(n-&gt;method(), n-&gt;osr_entry_bci(), l, true);
2993       if (inv != NULL &amp;&amp; inv-&gt;is_in_use()) {
2994         inv-&gt;make_not_entrant();
2995       }
2996     }
2997   }
2998 }
2999 
3000 // Remove osr nmethod from the list. Return true if found and removed.
3001 bool InstanceKlass::remove_osr_nmethod(nmethod* n) {
3002   // This is a short non-blocking critical region, so the no safepoint check is ok.
<span class="line-modified">3003   MutexLockerEx ml(OsrList_lock, Mutex::_no_safepoint_check_flag);</span>

3004   assert(n-&gt;is_osr_method(), &quot;wrong kind of nmethod&quot;);
3005   nmethod* last = NULL;
3006   nmethod* cur  = osr_nmethods_head();
3007   int max_level = CompLevel_none;  // Find the max comp level excluding n
3008   Method* m = n-&gt;method();
3009   // Search for match
3010   bool found = false;
3011   while(cur != NULL &amp;&amp; cur != n) {
3012     if (TieredCompilation &amp;&amp; m == cur-&gt;method()) {
3013       // Find max level before n
3014       max_level = MAX2(max_level, cur-&gt;comp_level());
3015     }
3016     last = cur;
3017     cur = cur-&gt;osr_link();
3018   }
3019   nmethod* next = NULL;
3020   if (cur == n) {
3021     found = true;
3022     next = cur-&gt;osr_link();
3023     if (last == NULL) {
</pre>
<hr />
<pre>
3026     } else {
3027       last-&gt;set_osr_link(next);
3028     }
3029   }
3030   n-&gt;set_osr_link(NULL);
3031   if (TieredCompilation) {
3032     cur = next;
3033     while (cur != NULL) {
3034       // Find max level after n
3035       if (m == cur-&gt;method()) {
3036         max_level = MAX2(max_level, cur-&gt;comp_level());
3037       }
3038       cur = cur-&gt;osr_link();
3039     }
3040     m-&gt;set_highest_osr_comp_level(max_level);
3041   }
3042   return found;
3043 }
3044 
3045 int InstanceKlass::mark_osr_nmethods(const Method* m) {
<span class="line-modified">3046   // This is a short non-blocking critical region, so the no safepoint check is ok.</span>
<span class="line-modified">3047   MutexLockerEx ml(OsrList_lock, Mutex::_no_safepoint_check_flag);</span>
3048   nmethod* osr = osr_nmethods_head();
3049   int found = 0;
3050   while (osr != NULL) {
3051     assert(osr-&gt;is_osr_method(), &quot;wrong kind of nmethod found in chain&quot;);
3052     if (osr-&gt;method() == m) {
3053       osr-&gt;mark_for_deoptimization();
3054       found++;
3055     }
3056     osr = osr-&gt;osr_link();
3057   }
3058   return found;
3059 }
3060 
3061 nmethod* InstanceKlass::lookup_osr_nmethod(const Method* m, int bci, int comp_level, bool match_level) const {
<span class="line-modified">3062   // This is a short non-blocking critical region, so the no safepoint check is ok.</span>
<span class="line-modified">3063   MutexLockerEx ml(OsrList_lock, Mutex::_no_safepoint_check_flag);</span>
3064   nmethod* osr = osr_nmethods_head();
3065   nmethod* best = NULL;
3066   while (osr != NULL) {
3067     assert(osr-&gt;is_osr_method(), &quot;wrong kind of nmethod found in chain&quot;);
3068     // There can be a time when a c1 osr method exists but we are waiting
3069     // for a c2 version. When c2 completes its osr nmethod we will trash
3070     // the c1 version and only be able to find the c2 version. However
3071     // while we overflow in the c1 code at back branches we don&#39;t want to
3072     // try and switch to the same code as we are already running
3073 
3074     if (osr-&gt;method() == m &amp;&amp;
3075         (bci == InvocationEntryBci || osr-&gt;osr_entry_bci() == bci)) {
3076       if (match_level) {
3077         if (osr-&gt;comp_level() == comp_level) {
3078           // Found a match - return it.
3079           return osr;
3080         }
3081       } else {
3082         if (best == NULL || (osr-&gt;comp_level() &gt; best-&gt;comp_level())) {
3083           if (osr-&gt;comp_level() == CompLevel_highest_tier) {
3084             // Found the best possible - return it.
3085             return osr;
3086           }
3087           best = osr;
3088         }
3089       }
3090     }
3091     osr = osr-&gt;osr_link();
3092   }
<span class="line-modified">3093   if (best != NULL &amp;&amp; best-&gt;comp_level() &gt;= comp_level &amp;&amp; match_level == false) {</span>


3094     return best;
3095   }
3096   return NULL;
3097 }
3098 
3099 // -----------------------------------------------------------------------------------------------------
3100 // Printing
3101 
3102 #ifndef PRODUCT
3103 
3104 #define BULLET  &quot; - &quot;
3105 
3106 static const char* state_names[] = {
3107   &quot;allocated&quot;, &quot;loaded&quot;, &quot;linked&quot;, &quot;being_initialized&quot;, &quot;fully_initialized&quot;, &quot;initialization_error&quot;
3108 };
3109 
3110 static void print_vtable(intptr_t* start, int len, outputStream* st) {
3111   for (int i = 0; i &lt; len; i++) {
3112     intptr_t e = start[i];
3113     st-&gt;print(&quot;%d : &quot; INTPTR_FORMAT, i, e);
<span class="line-modified">3114     if (e != 0 &amp;&amp; ((Metadata*)e)-&gt;is_metaspace_object()) {</span>
3115       st-&gt;print(&quot; &quot;);
3116       ((Metadata*)e)-&gt;print_value_on(st);
3117     }
3118     st-&gt;cr();
3119   }
3120 }
3121 
3122 static void print_vtable(vtableEntry* start, int len, outputStream* st) {
3123   return print_vtable(reinterpret_cast&lt;intptr_t*&gt;(start), len, st);
3124 }
3125 
3126 void InstanceKlass::print_on(outputStream* st) const {
3127   assert(is_klass(), &quot;must be klass&quot;);
3128   Klass::print_on(st);
3129 
3130   st-&gt;print(BULLET&quot;instance size:     %d&quot;, size_helper());                        st-&gt;cr();
3131   st-&gt;print(BULLET&quot;klass size:        %d&quot;, size());                               st-&gt;cr();
3132   st-&gt;print(BULLET&quot;access:            &quot;); access_flags().print_on(st);            st-&gt;cr();
3133   st-&gt;print(BULLET&quot;state:             &quot;); st-&gt;print_cr(&quot;%s&quot;, state_names[_init_state]);
3134   st-&gt;print(BULLET&quot;name:              &quot;); name()-&gt;print_value_on(st);             st-&gt;cr();
</pre>
<hr />
<pre>
3201     bool have_pv = false;
3202     // previous versions are linked together through the InstanceKlass
3203     for (InstanceKlass* pv_node = previous_versions();
3204          pv_node != NULL;
3205          pv_node = pv_node-&gt;previous_versions()) {
3206       if (!have_pv)
3207         st-&gt;print(BULLET&quot;previous version:  &quot;);
3208       have_pv = true;
3209       pv_node-&gt;constants()-&gt;print_value_on(st);
3210     }
3211     if (have_pv) st-&gt;cr();
3212   }
3213 
3214   if (generic_signature() != NULL) {
3215     st-&gt;print(BULLET&quot;generic signature: &quot;);
3216     generic_signature()-&gt;print_value_on(st);
3217     st-&gt;cr();
3218   }
3219   st-&gt;print(BULLET&quot;inner classes:     &quot;); inner_classes()-&gt;print_value_on(st);     st-&gt;cr();
3220   st-&gt;print(BULLET&quot;nest members:     &quot;); nest_members()-&gt;print_value_on(st);     st-&gt;cr();



3221   if (java_mirror() != NULL) {
3222     st-&gt;print(BULLET&quot;java mirror:       &quot;);
3223     java_mirror()-&gt;print_value_on(st);
3224     st-&gt;cr();
3225   } else {
3226     st-&gt;print_cr(BULLET&quot;java mirror:       NULL&quot;);
3227   }
3228   st-&gt;print(BULLET&quot;vtable length      %d  (start addr: &quot; INTPTR_FORMAT &quot;)&quot;, vtable_length(), p2i(start_of_vtable())); st-&gt;cr();
3229   if (vtable_length() &gt; 0 &amp;&amp; (Verbose || WizardMode))  print_vtable(start_of_vtable(), vtable_length(), st);
3230   st-&gt;print(BULLET&quot;itable length      %d (start addr: &quot; INTPTR_FORMAT &quot;)&quot;, itable_length(), p2i(start_of_itable())); st-&gt;cr();
3231   if (itable_length() &gt; 0 &amp;&amp; (Verbose || WizardMode))  print_vtable(start_of_itable(), itable_length(), st);
3232   st-&gt;print_cr(BULLET&quot;---- static fields (%d words):&quot;, static_field_size());
3233   FieldPrinter print_static_field(st);
3234   ((InstanceKlass*)this)-&gt;do_local_static_fields(&amp;print_static_field);
3235   st-&gt;print_cr(BULLET&quot;---- non-static fields (%d words):&quot;, nonstatic_field_size());
3236   FieldPrinter print_nonstatic_field(st);
3237   InstanceKlass* ik = const_cast&lt;InstanceKlass*&gt;(this);
3238   ik-&gt;do_nonstatic_fields(&amp;print_nonstatic_field);
3239 
3240   st-&gt;print(BULLET&quot;non-static oop maps: &quot;);
</pre>
<hr />
<pre>
3374 }
3375 
3376 void InstanceKlass::print_class_load_logging(ClassLoaderData* loader_data,
3377                                              const char* module_name,
3378                                              const ClassFileStream* cfs) const {
3379   if (!log_is_enabled(Info, class, load)) {
3380     return;
3381   }
3382 
3383   ResourceMark rm;
3384   LogMessage(class, load) msg;
3385   stringStream info_stream;
3386 
3387   // Name and class hierarchy info
3388   info_stream.print(&quot;%s&quot;, external_name());
3389 
3390   // Source
3391   if (cfs != NULL) {
3392     if (cfs-&gt;source() != NULL) {
3393       if (module_name != NULL) {
<span class="line-modified">3394         if (ClassLoader::is_modules_image(cfs-&gt;source())) {</span>


3395           info_stream.print(&quot; source: jrt:/%s&quot;, module_name);
3396         } else {
3397           info_stream.print(&quot; source: %s&quot;, cfs-&gt;source());
3398         }
3399       } else {
3400         info_stream.print(&quot; source: %s&quot;, cfs-&gt;source());
3401       }
3402     } else if (loader_data == ClassLoaderData::the_null_class_loader_data()) {
3403       Thread* THREAD = Thread::current();
3404       Klass* caller =
3405             THREAD-&gt;is_Java_thread()
3406                 ? ((JavaThread*)THREAD)-&gt;security_get_caller_class(1)
3407                 : NULL;
3408       // caller can be NULL, for example, during a JVMTI VM_Init hook
3409       if (caller != NULL) {
3410         info_stream.print(&quot; source: instance of %s&quot;, caller-&gt;external_name());
3411       } else {
3412         // source is unknown
3413       }
3414     } else {
3415       oop class_loader = loader_data-&gt;class_loader();
3416       info_stream.print(&quot; source: %s&quot;, class_loader-&gt;klass()-&gt;external_name());
3417     }
3418   } else {
<span class="line-modified">3419     info_stream.print(&quot; source: shared objects file&quot;);</span>





3420   }
3421 
3422   msg.info(&quot;%s&quot;, info_stream.as_string());
3423 
3424   if (log_is_enabled(Debug, class, load)) {
3425     stringStream debug_stream;
3426 
3427     // Class hierarchy info
3428     debug_stream.print(&quot; klass: &quot; INTPTR_FORMAT &quot; super: &quot; INTPTR_FORMAT,
3429                        p2i(this),  p2i(superklass()));
3430 
3431     // Interfaces
3432     if (local_interfaces() != NULL &amp;&amp; local_interfaces()-&gt;length() &gt; 0) {
3433       debug_stream.print(&quot; interfaces:&quot;);
3434       int length = local_interfaces()-&gt;length();
3435       for (int i = 0; i &lt; length; i++) {
3436         debug_stream.print(&quot; &quot; INTPTR_FORMAT,
3437                            p2i(InstanceKlass::cast(local_interfaces()-&gt;at(i))));
3438       }
3439     }
3440 
3441     // Class loader
3442     debug_stream.print(&quot; loader: [&quot;);
3443     loader_data-&gt;print_value_on(&amp;debug_stream);
3444     debug_stream.print(&quot;]&quot;);
3445 
3446     // Classfile checksum
3447     if (cfs) {
3448       debug_stream.print(&quot; bytes: %d checksum: %08x&quot;,
3449                          cfs-&gt;length(),
3450                          ClassLoader::crc32(0, (const char*)cfs-&gt;buffer(),
3451                          cfs-&gt;length()));
3452     }
3453 
3454     msg.debug(&quot;%s&quot;, debug_stream.as_string());
3455   }
3456 }
3457 
<span class="line-removed">3458 #if INCLUDE_SERVICES</span>
<span class="line-removed">3459 // Size Statistics</span>
<span class="line-removed">3460 void InstanceKlass::collect_statistics(KlassSizeStats *sz) const {</span>
<span class="line-removed">3461   Klass::collect_statistics(sz);</span>
<span class="line-removed">3462 </span>
<span class="line-removed">3463   sz-&gt;_inst_size  = wordSize * size_helper();</span>
<span class="line-removed">3464   sz-&gt;_vtab_bytes = wordSize * vtable_length();</span>
<span class="line-removed">3465   sz-&gt;_itab_bytes = wordSize * itable_length();</span>
<span class="line-removed">3466   sz-&gt;_nonstatic_oopmap_bytes = wordSize * nonstatic_oop_map_size();</span>
<span class="line-removed">3467 </span>
<span class="line-removed">3468   int n = 0;</span>
<span class="line-removed">3469   n += (sz-&gt;_methods_array_bytes         = sz-&gt;count_array(methods()));</span>
<span class="line-removed">3470   n += (sz-&gt;_method_ordering_bytes       = sz-&gt;count_array(method_ordering()));</span>
<span class="line-removed">3471   n += (sz-&gt;_local_interfaces_bytes      = sz-&gt;count_array(local_interfaces()));</span>
<span class="line-removed">3472   n += (sz-&gt;_transitive_interfaces_bytes = sz-&gt;count_array(transitive_interfaces()));</span>
<span class="line-removed">3473   n += (sz-&gt;_fields_bytes                = sz-&gt;count_array(fields()));</span>
<span class="line-removed">3474   n += (sz-&gt;_inner_classes_bytes         = sz-&gt;count_array(inner_classes()));</span>
<span class="line-removed">3475   n += (sz-&gt;_nest_members_bytes          = sz-&gt;count_array(nest_members()));</span>
<span class="line-removed">3476   sz-&gt;_ro_bytes += n;</span>
<span class="line-removed">3477 </span>
<span class="line-removed">3478   const ConstantPool* cp = constants();</span>
<span class="line-removed">3479   if (cp) {</span>
<span class="line-removed">3480     cp-&gt;collect_statistics(sz);</span>
<span class="line-removed">3481   }</span>
<span class="line-removed">3482 </span>
<span class="line-removed">3483   const Annotations* anno = annotations();</span>
<span class="line-removed">3484   if (anno) {</span>
<span class="line-removed">3485     anno-&gt;collect_statistics(sz);</span>
<span class="line-removed">3486   }</span>
<span class="line-removed">3487 </span>
<span class="line-removed">3488   const Array&lt;Method*&gt;* methods_array = methods();</span>
<span class="line-removed">3489   if (methods()) {</span>
<span class="line-removed">3490     for (int i = 0; i &lt; methods_array-&gt;length(); i++) {</span>
<span class="line-removed">3491       Method* method = methods_array-&gt;at(i);</span>
<span class="line-removed">3492       if (method) {</span>
<span class="line-removed">3493         sz-&gt;_method_count ++;</span>
<span class="line-removed">3494         method-&gt;collect_statistics(sz);</span>
<span class="line-removed">3495       }</span>
<span class="line-removed">3496     }</span>
<span class="line-removed">3497   }</span>
<span class="line-removed">3498 }</span>
<span class="line-removed">3499 #endif // INCLUDE_SERVICES</span>
<span class="line-removed">3500 </span>
3501 // Verification
3502 
3503 class VerifyFieldClosure: public BasicOopIterateClosure {
3504  protected:
3505   template &lt;class T&gt; void do_oop_work(T* p) {
3506     oop obj = RawAccess&lt;&gt;::oop_load(p);
3507     if (!oopDesc::is_oop_or_null(obj)) {
3508       tty-&gt;print_cr(&quot;Failed: &quot; PTR_FORMAT &quot; -&gt; &quot; PTR_FORMAT, p2i(p), p2i(obj));
3509       Universe::print_on(tty);
3510       guarantee(false, &quot;boom&quot;);
3511     }
3512   }
3513  public:
3514   virtual void do_oop(oop* p)       { VerifyFieldClosure::do_oop_work(p); }
3515   virtual void do_oop(narrowOop* p) { VerifyFieldClosure::do_oop_work(p); }
3516 };
3517 
3518 void InstanceKlass::verify_on(outputStream* st) {
3519 #ifndef PRODUCT
3520   // Avoid redundant verifies, this really should be in product.
</pre>
<hr />
<pre>
3572   }
3573 
3574   // Verify methods
3575   if (methods() != NULL) {
3576     Array&lt;Method*&gt;* methods = this-&gt;methods();
3577     for (int j = 0; j &lt; methods-&gt;length(); j++) {
3578       guarantee(methods-&gt;at(j)-&gt;is_method(), &quot;non-method in methods array&quot;);
3579     }
3580     for (int j = 0; j &lt; methods-&gt;length() - 1; j++) {
3581       Method* m1 = methods-&gt;at(j);
3582       Method* m2 = methods-&gt;at(j + 1);
3583       guarantee(m1-&gt;name()-&gt;fast_compare(m2-&gt;name()) &lt;= 0, &quot;methods not sorted correctly&quot;);
3584     }
3585   }
3586 
3587   // Verify method ordering
3588   if (method_ordering() != NULL) {
3589     Array&lt;int&gt;* method_ordering = this-&gt;method_ordering();
3590     int length = method_ordering-&gt;length();
3591     if (JvmtiExport::can_maintain_original_method_order() ||
<span class="line-modified">3592         ((UseSharedSpaces || DumpSharedSpaces) &amp;&amp; length != 0)) {</span>
3593       guarantee(length == methods()-&gt;length(), &quot;invalid method ordering length&quot;);
3594       jlong sum = 0;
3595       for (int j = 0; j &lt; length; j++) {
3596         int original_index = method_ordering-&gt;at(j);
3597         guarantee(original_index &gt;= 0, &quot;invalid method ordering index&quot;);
3598         guarantee(original_index &lt; length, &quot;invalid method ordering index&quot;);
3599         sum += original_index;
3600       }
3601       // Verify sum of indices 0,1,...,length-1
3602       guarantee(sum == ((jlong)length*(length-1))/2, &quot;invalid method ordering sum&quot;);
3603     } else {
3604       guarantee(length == 0, &quot;invalid method ordering length&quot;);
3605     }
3606   }
3607 
3608   // Verify default methods
3609   if (default_methods() != NULL) {
3610     Array&lt;Method*&gt;* methods = this-&gt;default_methods();
3611     for (int j = 0; j &lt; methods-&gt;length(); j++) {
3612       guarantee(methods-&gt;at(j)-&gt;is_method(), &quot;non-method in methods array&quot;);
</pre>
<hr />
<pre>
3680 
3681   JNIid* current = this;
3682   while (current != NULL) {
3683     guarantee(current-&gt;holder() == holder, &quot;Invalid klass in JNIid&quot;);
3684 #ifdef ASSERT
3685     int o = current-&gt;offset();
3686     if (current-&gt;is_static_field_id()) {
3687       guarantee(o &gt;= first_field_offset  &amp;&amp; o &lt; end_field_offset,  &quot;Invalid static field offset in JNIid&quot;);
3688     }
3689 #endif
3690     current = current-&gt;next();
3691   }
3692 }
3693 
3694 void InstanceKlass::set_init_state(ClassState state) {
3695 #ifdef ASSERT
3696   bool good_state = is_shared() ? (_init_state &lt;= state)
3697                                                : (_init_state &lt; state);
3698   assert(good_state || state == allocated, &quot;illegal state transition&quot;);
3699 #endif

3700   _init_state = (u1)state;
3701 }
3702 
3703 #if INCLUDE_JVMTI
3704 
3705 // RedefineClasses() support for previous versions
3706 
3707 // Globally, there is at least one previous version of a class to walk
3708 // during class unloading, which is saved because old methods in the class
3709 // are still running.   Otherwise the previous version list is cleaned up.
3710 bool InstanceKlass::_has_previous_versions = false;
3711 
3712 // Returns true if there are previous versions of a class for class
3713 // unloading only. Also resets the flag to false. purge_previous_version
3714 // will set the flag to true if there are any left, i.e., if there&#39;s any
3715 // work to do for next time. This is to avoid the expensive code cache
3716 // walk in CLDG::clean_deallocate_lists().
3717 bool InstanceKlass::has_previous_versions_and_reset() {
3718   bool ret = _has_previous_versions;
3719   log_trace(redefine, class, iklass, purge)(&quot;Class unloading: has_previous_versions = %s&quot;,
</pre>
</td>
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 1997, 2020, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include &quot;precompiled.hpp&quot;
  26 #include &quot;jvm.h&quot;
  27 #include &quot;aot/aotLoader.hpp&quot;
  28 #include &quot;classfile/classFileParser.hpp&quot;
  29 #include &quot;classfile/classFileStream.hpp&quot;
  30 #include &quot;classfile/classLoader.hpp&quot;
  31 #include &quot;classfile/classLoaderData.inline.hpp&quot;
  32 #include &quot;classfile/javaClasses.hpp&quot;
  33 #include &quot;classfile/moduleEntry.hpp&quot;
<span class="line-added">  34 #include &quot;classfile/symbolTable.hpp&quot;</span>
  35 #include &quot;classfile/systemDictionary.hpp&quot;
  36 #include &quot;classfile/systemDictionaryShared.hpp&quot;
  37 #include &quot;classfile/verifier.hpp&quot;
  38 #include &quot;classfile/vmSymbols.hpp&quot;
  39 #include &quot;code/dependencyContext.hpp&quot;
  40 #include &quot;compiler/compileBroker.hpp&quot;
  41 #include &quot;gc/shared/collectedHeap.inline.hpp&quot;
  42 #include &quot;interpreter/oopMapCache.hpp&quot;
  43 #include &quot;interpreter/rewriter.hpp&quot;
  44 #include &quot;jvmtifiles/jvmti.h&quot;
  45 #include &quot;logging/log.hpp&quot;
  46 #include &quot;logging/logMessage.hpp&quot;
  47 #include &quot;logging/logStream.hpp&quot;
  48 #include &quot;memory/allocation.inline.hpp&quot;

  49 #include &quot;memory/iterator.inline.hpp&quot;
  50 #include &quot;memory/metadataFactory.hpp&quot;
  51 #include &quot;memory/metaspaceClosure.hpp&quot;
  52 #include &quot;memory/metaspaceShared.hpp&quot;
  53 #include &quot;memory/oopFactory.hpp&quot;
  54 #include &quot;memory/resourceArea.hpp&quot;
<span class="line-modified">  55 #include &quot;memory/universe.hpp&quot;</span>
<span class="line-added">  56 #include &quot;oops/fieldStreams.inline.hpp&quot;</span>
  57 #include &quot;oops/constantPool.hpp&quot;
  58 #include &quot;oops/instanceClassLoaderKlass.hpp&quot;
  59 #include &quot;oops/instanceKlass.inline.hpp&quot;
  60 #include &quot;oops/instanceMirrorKlass.hpp&quot;
  61 #include &quot;oops/instanceOop.hpp&quot;
  62 #include &quot;oops/klass.inline.hpp&quot;
  63 #include &quot;oops/method.hpp&quot;
  64 #include &quot;oops/oop.inline.hpp&quot;
<span class="line-added">  65 #include &quot;oops/recordComponent.hpp&quot;</span>
  66 #include &quot;oops/symbol.hpp&quot;
  67 #include &quot;prims/jvmtiExport.hpp&quot;
  68 #include &quot;prims/jvmtiRedefineClasses.hpp&quot;
  69 #include &quot;prims/jvmtiThreadState.hpp&quot;
  70 #include &quot;prims/methodComparator.hpp&quot;
  71 #include &quot;runtime/atomic.hpp&quot;
<span class="line-added">  72 #include &quot;runtime/biasedLocking.hpp&quot;</span>
  73 #include &quot;runtime/fieldDescriptor.inline.hpp&quot;
  74 #include &quot;runtime/handles.inline.hpp&quot;
  75 #include &quot;runtime/javaCalls.hpp&quot;
  76 #include &quot;runtime/mutexLocker.hpp&quot;
  77 #include &quot;runtime/orderAccess.hpp&quot;
  78 #include &quot;runtime/thread.inline.hpp&quot;
  79 #include &quot;services/classLoadingService.hpp&quot;
  80 #include &quot;services/threadService.hpp&quot;
  81 #include &quot;utilities/dtrace.hpp&quot;
  82 #include &quot;utilities/events.hpp&quot;
  83 #include &quot;utilities/macros.hpp&quot;
  84 #include &quot;utilities/stringUtils.hpp&quot;
  85 #ifdef COMPILER1
  86 #include &quot;c1/c1_Compiler.hpp&quot;
  87 #endif
  88 #if INCLUDE_JFR
  89 #include &quot;jfr/jfrEvents.hpp&quot;
  90 #endif
  91 #if INCLUDE_TSAN
  92 #include &quot;runtime/sharedRuntime.hpp&quot;
</pre>
<hr />
<pre>
 422       _method_ordering-&gt;at_put(i, m-&gt;at(i));
 423     }
 424   } else {
 425     _method_ordering = Universe::the_empty_int_array();
 426   }
 427 }
 428 
 429 // create a new array of vtable_indices for default methods
 430 Array&lt;int&gt;* InstanceKlass::create_new_default_vtable_indices(int len, TRAPS) {
 431   Array&lt;int&gt;* vtable_indices = MetadataFactory::new_array&lt;int&gt;(class_loader_data(), len, CHECK_NULL);
 432   assert(default_vtable_indices() == NULL, &quot;only create once&quot;);
 433   set_default_vtable_indices(vtable_indices);
 434   return vtable_indices;
 435 }
 436 
 437 InstanceKlass::InstanceKlass(const ClassFileParser&amp; parser, unsigned kind, KlassID id) :
 438   Klass(id),
 439   _nest_members(NULL),
 440   _nest_host_index(0),
 441   _nest_host(NULL),
<span class="line-added"> 442   _record_components(NULL),</span>
 443   _static_field_size(parser.static_field_size()),
 444   _nonstatic_oop_map_size(nonstatic_oop_map_size(parser.total_oop_map_count())),
 445   _itable_len(parser.itable_size()),
<span class="line-added"> 446   _init_thread(NULL),</span>
<span class="line-added"> 447   _init_state(allocated),</span>
 448   _reference_type(parser.reference_type())
 449 {
 450   set_vtable_length(parser.vtable_size());
 451   set_kind(kind);
 452   set_access_flags(parser.access_flags());
 453   set_is_unsafe_anonymous(parser.is_unsafe_anonymous());
 454   set_layout_helper(Klass::instance_layout_helper(parser.layout_size(),
 455                                                     false));
 456 
 457   assert(NULL == _methods, &quot;underlying memory not zeroed?&quot;);
 458   assert(is_instance_klass(), &quot;is layout incorrect?&quot;);
 459   assert(size_helper() == parser.layout_size(), &quot;incorrect size_helper?&quot;);
 460 
<span class="line-modified"> 461   if (Arguments::is_dumping_archive()) {</span>
 462     SystemDictionaryShared::init_dumptime_info(this);
 463   }
<span class="line-added"> 464 </span>
<span class="line-added"> 465   // Set biased locking bit for all instances of this class; it will be</span>
<span class="line-added"> 466   // cleared if revocation occurs too often for this type</span>
<span class="line-added"> 467   if (UseBiasedLocking &amp;&amp; BiasedLocking::enabled()) {</span>
<span class="line-added"> 468     set_prototype_header(markWord::biased_locking_prototype());</span>
<span class="line-added"> 469   }</span>
 470 }
 471 
 472 void InstanceKlass::deallocate_methods(ClassLoaderData* loader_data,
 473                                        Array&lt;Method*&gt;* methods) {
 474   if (methods != NULL &amp;&amp; methods != Universe::the_empty_method_array() &amp;&amp;
 475       !methods-&gt;is_shared()) {
 476     for (int i = 0; i &lt; methods-&gt;length(); i++) {
 477       Method* method = methods-&gt;at(i);
 478       if (method == NULL) continue;  // maybe null if error processing
 479       // Only want to delete methods that are not executing for RedefineClasses.
 480       // The previous version will point to them so they&#39;re not totally dangling
 481       assert (!method-&gt;on_stack(), &quot;shouldn&#39;t be called with methods on stack&quot;);
 482       MetadataFactory::free_metadata(loader_data, method);
 483     }
 484     MetadataFactory::free_array&lt;Method*&gt;(loader_data, methods);
 485   }
 486 }
 487 
 488 void InstanceKlass::deallocate_interfaces(ClassLoaderData* loader_data,
 489                                           const Klass* super_klass,
</pre>
<hr />
<pre>
 491                                           Array&lt;InstanceKlass*&gt;* transitive_interfaces) {
 492   // Only deallocate transitive interfaces if not empty, same as super class
 493   // or same as local interfaces.  See code in parseClassFile.
 494   Array&lt;InstanceKlass*&gt;* ti = transitive_interfaces;
 495   if (ti != Universe::the_empty_instance_klass_array() &amp;&amp; ti != local_interfaces) {
 496     // check that the interfaces don&#39;t come from super class
 497     Array&lt;InstanceKlass*&gt;* sti = (super_klass == NULL) ? NULL :
 498                     InstanceKlass::cast(super_klass)-&gt;transitive_interfaces();
 499     if (ti != sti &amp;&amp; ti != NULL &amp;&amp; !ti-&gt;is_shared()) {
 500       MetadataFactory::free_array&lt;InstanceKlass*&gt;(loader_data, ti);
 501     }
 502   }
 503 
 504   // local interfaces can be empty
 505   if (local_interfaces != Universe::the_empty_instance_klass_array() &amp;&amp;
 506       local_interfaces != NULL &amp;&amp; !local_interfaces-&gt;is_shared()) {
 507     MetadataFactory::free_array&lt;InstanceKlass*&gt;(loader_data, local_interfaces);
 508   }
 509 }
 510 
<span class="line-added"> 511 void InstanceKlass::deallocate_record_components(ClassLoaderData* loader_data,</span>
<span class="line-added"> 512                                                  Array&lt;RecordComponent*&gt;* record_components) {</span>
<span class="line-added"> 513   if (record_components != NULL &amp;&amp; !record_components-&gt;is_shared()) {</span>
<span class="line-added"> 514     for (int i = 0; i &lt; record_components-&gt;length(); i++) {</span>
<span class="line-added"> 515       RecordComponent* record_component = record_components-&gt;at(i);</span>
<span class="line-added"> 516       MetadataFactory::free_metadata(loader_data, record_component);</span>
<span class="line-added"> 517     }</span>
<span class="line-added"> 518     MetadataFactory::free_array&lt;RecordComponent*&gt;(loader_data, record_components);</span>
<span class="line-added"> 519   }</span>
<span class="line-added"> 520 }</span>
<span class="line-added"> 521 </span>
 522 // This function deallocates the metadata and C heap pointers that the
 523 // InstanceKlass points to.
 524 void InstanceKlass::deallocate_contents(ClassLoaderData* loader_data) {
 525 
 526   // Orphan the mirror first, CMS thinks it&#39;s still live.
 527   if (java_mirror() != NULL) {
 528     java_lang_Class::set_klass(java_mirror(), NULL);
 529   }
 530 
 531   // Also remove mirror from handles
 532   loader_data-&gt;remove_handle(_java_mirror);
 533 
 534   // Need to take this class off the class loader data list.
 535   loader_data-&gt;remove_class(this);
 536 
 537   // The array_klass for this class is created later, after error handling.
 538   // For class redefinition, we keep the original class so this scratch class
 539   // doesn&#39;t have an array class.  Either way, assert that there is nothing
 540   // to deallocate.
 541   assert(array_klasses() == NULL, &quot;array classes shouldn&#39;t be created for this class yet&quot;);
 542 
 543   // Release C heap allocated data that this might point to, which includes
 544   // reference counting symbol names.
 545   release_C_heap_structures();
 546 
 547   deallocate_methods(loader_data, methods());
 548   set_methods(NULL);
 549 
<span class="line-added"> 550   deallocate_record_components(loader_data, record_components());</span>
<span class="line-added"> 551   set_record_components(NULL);</span>
<span class="line-added"> 552 </span>
 553   if (method_ordering() != NULL &amp;&amp;
 554       method_ordering() != Universe::the_empty_int_array() &amp;&amp;
 555       !method_ordering()-&gt;is_shared()) {
 556     MetadataFactory::free_array&lt;int&gt;(loader_data, method_ordering());
 557   }
 558   set_method_ordering(NULL);
 559 
 560   // default methods can be empty
 561   if (default_methods() != NULL &amp;&amp;
 562       default_methods() != Universe::the_empty_method_array() &amp;&amp;
 563       !default_methods()-&gt;is_shared()) {
 564     MetadataFactory::free_array&lt;Method*&gt;(loader_data, default_methods());
 565   }
 566   // Do NOT deallocate the default methods, they are owned by superinterfaces.
 567   set_default_methods(NULL);
 568 
 569   // default methods vtable indices can be empty
 570   if (default_vtable_indices() != NULL &amp;&amp;
 571       !default_vtable_indices()-&gt;is_shared()) {
 572     MetadataFactory::free_array&lt;int&gt;(loader_data, default_vtable_indices());
</pre>
<hr />
<pre>
 611   if (inner_classes() != NULL &amp;&amp;
 612       inner_classes() != Universe::the_empty_short_array() &amp;&amp;
 613       !inner_classes()-&gt;is_shared()) {
 614     MetadataFactory::free_array&lt;jushort&gt;(loader_data, inner_classes());
 615   }
 616   set_inner_classes(NULL);
 617 
 618   if (nest_members() != NULL &amp;&amp;
 619       nest_members() != Universe::the_empty_short_array() &amp;&amp;
 620       !nest_members()-&gt;is_shared()) {
 621     MetadataFactory::free_array&lt;jushort&gt;(loader_data, nest_members());
 622   }
 623   set_nest_members(NULL);
 624 
 625   // We should deallocate the Annotations instance if it&#39;s not in shared spaces.
 626   if (annotations() != NULL &amp;&amp; !annotations()-&gt;is_shared()) {
 627     MetadataFactory::free_metadata(loader_data, annotations());
 628   }
 629   set_annotations(NULL);
 630 
<span class="line-modified"> 631   if (Arguments::is_dumping_archive()) {</span>
 632     SystemDictionaryShared::remove_dumptime_info(this);
 633   }
 634 }
 635 
 636 bool InstanceKlass::should_be_initialized() const {
 637   return !is_initialized();
 638 }
 639 
 640 klassItable InstanceKlass::itable() const {
 641   return klassItable(const_cast&lt;InstanceKlass*&gt;(this));
 642 }
 643 
 644 void InstanceKlass::eager_initialize(Thread *thread) {
 645   if (!EagerInitialization) return;
 646 
 647   if (this-&gt;is_not_initialized()) {
 648     // abort if the the class has a class initializer
 649     if (this-&gt;class_initializer() != NULL) return;
 650 
 651     // abort if it is java.lang.Object (initialization is handled in genesis)
</pre>
<hr />
<pre>
 968   DTRACE_CLASSINIT_PROBE(required, -1);
 969 
 970   bool wait = false;
 971 
 972   assert(THREAD-&gt;is_Java_thread(), &quot;non-JavaThread in initialize_impl&quot;);
 973   JavaThread* jt = (JavaThread*)THREAD;
 974 
 975   // refer to the JVM book page 47 for description of steps
 976   // Step 1
 977   {
 978     Handle h_init_lock(THREAD, init_lock());
 979     ObjectLocker ol(h_init_lock, THREAD, h_init_lock() != NULL);
 980 
 981     // Step 2
 982     // If we were to use wait() instead of waitInterruptibly() then
 983     // we might end up throwing IE from link/symbol resolution sites
 984     // that aren&#39;t expected to throw.  This would wreak havoc.  See 6320309.
 985     while (is_being_initialized() &amp;&amp; !is_reentrant_initialization(jt)) {
 986       wait = true;
 987       jt-&gt;set_class_to_be_initialized(this);
<span class="line-modified"> 988       ol.wait_uninterruptibly(jt);</span>
 989       jt-&gt;set_class_to_be_initialized(NULL);
 990     }
 991 
 992     // Step 3
 993     if (is_being_initialized() &amp;&amp; is_reentrant_initialization(jt)) {
 994       DTRACE_CLASSINIT_PROBE_WAIT(recursive, -1, wait);
 995       return;
 996     }
 997 
 998     // Step 4
 999     if (is_initialized()) {
1000       DTRACE_CLASSINIT_PROBE_WAIT(concurrent, -1, wait);
1001       return;
1002     }
1003 
1004     // Step 5
1005     if (is_in_error_state()) {
1006       DTRACE_CLASSINIT_PROBE_WAIT(erroneous, -1, wait);
1007       ResourceMark rm(THREAD);
1008       const char* desc = &quot;Could not initialize class &quot;;
</pre>
<hr />
<pre>
1102       THROW_ARG(vmSymbols::java_lang_ExceptionInInitializerError(),
1103                 vmSymbols::throwable_void_signature(),
1104                 &amp;args);
1105     }
1106   }
1107   DTRACE_CLASSINIT_PROBE_WAIT(end, -1, wait);
1108 }
1109 
1110 
1111 void InstanceKlass::set_initialization_state_and_notify(ClassState state, TRAPS) {
1112   Handle h_init_lock(THREAD, init_lock());
1113   if (h_init_lock() != NULL) {
1114     ObjectLocker ol(h_init_lock, THREAD);
1115     TSAN_RUNTIME_ONLY(
1116       // Construct a happens-before edge between the write of _init_state to
1117       // fully_initialized and the later checking if it&#39;s initialized.
1118       void* const lock_address = reinterpret_cast&lt;void*&gt;(
1119           java_lang_Class::init_lock_addr(java_mirror()));
1120       SharedRuntime::tsan_release(lock_address);
1121     );
<span class="line-added">1122     set_init_thread(NULL); // reset _init_thread before changing _init_state</span>
1123     set_init_state(state);
1124     fence_and_clear_init_lock();
1125     ol.notify_all(CHECK);
1126   } else {
1127     assert(h_init_lock() != NULL, &quot;The initialization state should never be set twice&quot;);
<span class="line-added">1128     set_init_thread(NULL); // reset _init_thread before changing _init_state</span>
1129     set_init_state(state);
1130   }
1131 }
1132 
1133 Klass* InstanceKlass::implementor() const {
1134   Klass* volatile* k = adr_implementor();
1135   if (k == NULL) {
1136     return NULL;
1137   } else {
1138     // This load races with inserts, and therefore needs acquire.
<span class="line-modified">1139     Klass* kls = Atomic::load_acquire(k);</span>
1140     if (kls != NULL &amp;&amp; !kls-&gt;is_loader_alive()) {
1141       return NULL;  // don&#39;t return unloaded class
1142     } else {
1143       return kls;
1144     }
1145   }
1146 }
1147 
1148 
1149 void InstanceKlass::set_implementor(Klass* k) {
<span class="line-modified">1150   assert_locked_or_safepoint(Compile_lock);</span>
1151   assert(is_interface(), &quot;not interface&quot;);
1152   Klass* volatile* addr = adr_implementor();
1153   assert(addr != NULL, &quot;null addr&quot;);
1154   if (addr != NULL) {
<span class="line-modified">1155     Atomic::release_store(addr, k);</span>
1156   }
1157 }
1158 
1159 int  InstanceKlass::nof_implementors() const {
1160   Klass* k = implementor();
1161   if (k == NULL) {
1162     return 0;
1163   } else if (k != this) {
1164     return 1;
1165   } else {
1166     return 2;
1167   }
1168 }
1169 
1170 // The embedded _implementor field can only record one implementor.
1171 // When there are more than one implementors, the _implementor field
1172 // is set to the interface Klass* itself. Following are the possible
1173 // values for the _implementor field:
1174 //   NULL                  - no implementor
1175 //   implementor Klass*    - one implementor
</pre>
<hr />
<pre>
1179 void InstanceKlass::add_implementor(Klass* k) {
1180   assert_lock_strong(Compile_lock);
1181   assert(is_interface(), &quot;not interface&quot;);
1182   // Filter out my subinterfaces.
1183   // (Note: Interfaces are never on the subklass list.)
1184   if (InstanceKlass::cast(k)-&gt;is_interface()) return;
1185 
1186   // Filter out subclasses whose supers already implement me.
1187   // (Note: CHA must walk subclasses of direct implementors
1188   // in order to locate indirect implementors.)
1189   Klass* sk = k-&gt;super();
1190   if (sk != NULL &amp;&amp; InstanceKlass::cast(sk)-&gt;implements_interface(this))
1191     // We only need to check one immediate superclass, since the
1192     // implements_interface query looks at transitive_interfaces.
1193     // Any supers of the super have the same (or fewer) transitive_interfaces.
1194     return;
1195 
1196   Klass* ik = implementor();
1197   if (ik == NULL) {
1198     set_implementor(k);
<span class="line-modified">1199   } else if (ik != this &amp;&amp; ik != k) {</span>
1200     // There is already an implementor. Use itself as an indicator of
1201     // more than one implementors.
1202     set_implementor(this);
1203   }
1204 
1205   // The implementor also implements the transitive_interfaces
1206   for (int index = 0; index &lt; local_interfaces()-&gt;length(); index++) {
1207     InstanceKlass::cast(local_interfaces()-&gt;at(index))-&gt;add_implementor(k);
1208   }
1209 }
1210 
1211 void InstanceKlass::init_implementor() {
1212   if (is_interface()) {
1213     set_implementor(NULL);
1214   }
1215 }
1216 
1217 
1218 void InstanceKlass::process_interfaces(Thread *thread) {
1219   // link this class into the implementors list of every interface it implements
</pre>
<hr />
<pre>
1325 }
1326 
1327 void InstanceKlass::check_valid_for_instantiation(bool throwError, TRAPS) {
1328   if (is_interface() || is_abstract()) {
1329     ResourceMark rm(THREAD);
1330     THROW_MSG(throwError ? vmSymbols::java_lang_InstantiationError()
1331               : vmSymbols::java_lang_InstantiationException(), external_name());
1332   }
1333   if (this == SystemDictionary::Class_klass()) {
1334     ResourceMark rm(THREAD);
1335     THROW_MSG(throwError ? vmSymbols::java_lang_IllegalAccessError()
1336               : vmSymbols::java_lang_IllegalAccessException(), external_name());
1337   }
1338 }
1339 
1340 Klass* InstanceKlass::array_klass_impl(bool or_null, int n, TRAPS) {
1341   // Need load-acquire for lock-free read
1342   if (array_klasses_acquire() == NULL) {
1343     if (or_null) return NULL;
1344 
<span class="line-modified">1345     ResourceMark rm(THREAD);</span>
1346     JavaThread *jt = (JavaThread *)THREAD;
1347     {
1348       // Atomic creation of array_klasses
<span class="line-modified">1349       MutexLocker ma(THREAD, MultiArray_lock);</span>
1350 
1351       // Check if update has already taken place
1352       if (array_klasses() == NULL) {
1353         Klass*    k = ObjArrayKlass::allocate_objArray_klass(class_loader_data(), 1, this, CHECK_NULL);
1354         // use &#39;release&#39; to pair with lock-free load
1355         release_set_array_klasses(k);
1356       }
1357     }
1358   }
1359   // _this will always be set at this point
1360   ObjArrayKlass* oak = (ObjArrayKlass*)array_klasses();
1361   if (or_null) {
1362     return oak-&gt;array_klass_or_null(n);
1363   }
1364   return oak-&gt;array_klass(n, THREAD);
1365 }
1366 
1367 Klass* InstanceKlass::array_klass_impl(bool or_null, TRAPS) {
1368   return array_klass_impl(or_null, 1, THREAD);
1369 }
</pre>
<hr />
<pre>
1374   Method* clinit = find_method(
1375       vmSymbols::class_initializer_name(), vmSymbols::void_method_signature());
1376   if (clinit != NULL &amp;&amp; clinit-&gt;has_valid_initializer_flags()) {
1377     return clinit;
1378   }
1379   return NULL;
1380 }
1381 
1382 void InstanceKlass::call_class_initializer(TRAPS) {
1383   if (ReplayCompiles &amp;&amp;
1384       (ReplaySuppressInitializers == 1 ||
1385        (ReplaySuppressInitializers &gt;= 2 &amp;&amp; class_loader() != NULL))) {
1386     // Hide the existence of the initializer for the purpose of replaying the compile
1387     return;
1388   }
1389 
1390   methodHandle h_method(THREAD, class_initializer());
1391   assert(!is_initialized(), &quot;we cannot initialize twice&quot;);
1392   LogTarget(Info, class, init) lt;
1393   if (lt.is_enabled()) {
<span class="line-modified">1394     ResourceMark rm(THREAD);</span>
1395     LogStream ls(lt);
1396     ls.print(&quot;%d Initializing &quot;, call_class_initializer_counter++);
1397     name()-&gt;print_value_on(&amp;ls);
1398     ls.print_cr(&quot;%s (&quot; INTPTR_FORMAT &quot;)&quot;, h_method() == NULL ? &quot;(no method)&quot; : &quot;&quot;, p2i(this));
1399   }
1400   if (h_method() != NULL) {
1401     JavaCallArguments args; // No arguments
1402     JavaValue result(T_VOID);
1403     JavaCalls::call(&amp;result, h_method, &amp;args, CHECK); // Static call (no args)
1404   }
1405 }
1406 
1407 
1408 void InstanceKlass::mask_for(const methodHandle&amp; method, int bci,
1409   InterpreterOopMap* entry_for) {
1410   // Lazily create the _oop_map_cache at first request
1411   // Lock-free access requires load_acquire.
<span class="line-modified">1412   OopMapCache* oop_map_cache = Atomic::load_acquire(&amp;_oop_map_cache);</span>
1413   if (oop_map_cache == NULL) {
1414     MutexLocker x(OopMapCacheAlloc_lock);
1415     // Check if _oop_map_cache was allocated while we were waiting for this lock
1416     if ((oop_map_cache = _oop_map_cache) == NULL) {
1417       oop_map_cache = new OopMapCache();
1418       // Ensure _oop_map_cache is stable, since it is examined without a lock
<span class="line-modified">1419       Atomic::release_store(&amp;_oop_map_cache, oop_map_cache);</span>
1420     }
1421   }
1422   // _oop_map_cache is constant after init; lookup below does its own locking.
1423   oop_map_cache-&gt;lookup(method, bci, entry_for);
1424 }
1425 
<span class="line-added">1426 bool InstanceKlass::contains_field_offset(int offset) {</span>
<span class="line-added">1427   fieldDescriptor fd;</span>
<span class="line-added">1428   return find_field_from_offset(offset, false, &amp;fd);</span>
<span class="line-added">1429 }</span>
1430 
1431 bool InstanceKlass::find_local_field(Symbol* name, Symbol* sig, fieldDescriptor* fd) const {
1432   for (JavaFieldStream fs(this); !fs.done(); fs.next()) {
1433     Symbol* f_name = fs.name();
1434     Symbol* f_sig  = fs.signature();
1435     if (f_name == name &amp;&amp; f_sig == sig) {
1436       fd-&gt;reinitialize(const_cast&lt;InstanceKlass*&gt;(this), fs.index());
1437       return true;
1438     }
1439   }
1440   return false;
1441 }
1442 
1443 
1444 Klass* InstanceKlass::find_interface_field(Symbol* name, Symbol* sig, fieldDescriptor* fd) const {
1445   const int n = local_interfaces()-&gt;length();
1446   for (int i = 0; i &lt; n; i++) {
1447     Klass* intf1 = local_interfaces()-&gt;at(i);
1448     assert(intf1-&gt;is_interface(), &quot;just checking type&quot;);
1449     // search for field in current interface
</pre>
<hr />
<pre>
1603   if (array_klasses() != NULL)
1604     ArrayKlass::cast(array_klasses())-&gt;array_klasses_do(f);
1605 }
1606 
1607 #ifdef ASSERT
1608 static int linear_search(const Array&lt;Method*&gt;* methods,
1609                          const Symbol* name,
1610                          const Symbol* signature) {
1611   const int len = methods-&gt;length();
1612   for (int index = 0; index &lt; len; index++) {
1613     const Method* const m = methods-&gt;at(index);
1614     assert(m-&gt;is_method(), &quot;must be method&quot;);
1615     if (m-&gt;signature() == signature &amp;&amp; m-&gt;name() == name) {
1616        return index;
1617     }
1618   }
1619   return -1;
1620 }
1621 #endif
1622 
<span class="line-modified">1623 bool InstanceKlass::_disable_method_binary_search = false;</span>
<span class="line-added">1624 </span>
<span class="line-added">1625 NOINLINE int linear_search(const Array&lt;Method*&gt;* methods, const Symbol* name) {</span>
<span class="line-added">1626   int len = methods-&gt;length();</span>
<span class="line-added">1627   int l = 0;</span>
<span class="line-added">1628   int h = len - 1;</span>
<span class="line-added">1629   while (l &lt;= h) {</span>
<span class="line-added">1630     Method* m = methods-&gt;at(l);</span>
<span class="line-added">1631     if (m-&gt;name() == name) {</span>
<span class="line-added">1632       return l;</span>
<span class="line-added">1633     }</span>
<span class="line-added">1634     l++;</span>
<span class="line-added">1635   }</span>
<span class="line-added">1636   return -1;</span>
<span class="line-added">1637 }</span>
<span class="line-added">1638 </span>
<span class="line-added">1639 inline int InstanceKlass::quick_search(const Array&lt;Method*&gt;* methods, const Symbol* name) {</span>
<span class="line-added">1640   if (_disable_method_binary_search) {</span>
<span class="line-added">1641     assert(DynamicDumpSharedSpaces, &quot;must be&quot;);</span>
<span class="line-added">1642     // At the final stage of dynamic dumping, the methods array may not be sorted</span>
<span class="line-added">1643     // by ascending addresses of their names, so we can&#39;t use binary search anymore.</span>
<span class="line-added">1644     // However, methods with the same name are still laid out consecutively inside the</span>
<span class="line-added">1645     // methods array, so let&#39;s look for the first one that matches.</span>
<span class="line-added">1646     return linear_search(methods, name);</span>
<span class="line-added">1647   }</span>
<span class="line-added">1648 </span>
1649   int len = methods-&gt;length();

1650   int l = 0;
1651   int h = len - 1;
<span class="line-added">1652 </span>
<span class="line-added">1653   // methods are sorted by ascending addresses of their names, so do binary search</span>
1654   while (l &lt;= h) {
1655     int mid = (l + h) &gt;&gt; 1;
1656     Method* m = methods-&gt;at(mid);
1657     assert(m-&gt;is_method(), &quot;must be method&quot;);
1658     int res = m-&gt;name()-&gt;fast_compare(name);
1659     if (res == 0) {
1660       return mid;
1661     } else if (res &lt; 0) {
1662       l = mid + 1;
1663     } else {
1664       h = mid - 1;
1665     }
1666   }
1667   return -1;
1668 }
1669 
1670 // find_method looks up the name/signature in the local methods array
1671 Method* InstanceKlass::find_method(const Symbol* name,
1672                                    const Symbol* signature) const {
1673   return find_method_impl(name, signature, find_overpass, find_static, find_private);
</pre>
<hr />
<pre>
1785 // default_vtable_indices, and indirectly by find_method
1786 // find_method_index looks in the local methods array to return the index
1787 // of the matching name/signature. If, overpass methods are being ignored,
1788 // the search continues to find a potential non-overpass match.  This capability
1789 // is important during method resolution to prefer a static method, for example,
1790 // over an overpass method.
1791 // There is the possibility in any _method&#39;s array to have the same name/signature
1792 // for a static method, an overpass method and a local instance method
1793 // To correctly catch a given method, the search criteria may need
1794 // to explicitly skip the other two. For local instance methods, it
1795 // is often necessary to skip private methods
1796 int InstanceKlass::find_method_index(const Array&lt;Method*&gt;* methods,
1797                                      const Symbol* name,
1798                                      const Symbol* signature,
1799                                      OverpassLookupMode overpass_mode,
1800                                      StaticLookupMode static_mode,
1801                                      PrivateLookupMode private_mode) {
1802   const bool skipping_overpass = (overpass_mode == skip_overpass);
1803   const bool skipping_static = (static_mode == skip_static);
1804   const bool skipping_private = (private_mode == skip_private);
<span class="line-modified">1805   const int hit = quick_search(methods, name);</span>
1806   if (hit != -1) {
1807     const Method* const m = methods-&gt;at(hit);
1808 
1809     // Do linear search to find matching signature.  First, quick check
1810     // for common case, ignoring overpasses if requested.
1811     if (method_matches(m, signature, skipping_overpass, skipping_static, skipping_private)) {
1812       return hit;
1813     }
1814 
1815     // search downwards through overloaded methods
1816     int i;
1817     for (i = hit - 1; i &gt;= 0; --i) {
1818         const Method* const m = methods-&gt;at(i);
1819         assert(m-&gt;is_method(), &quot;must be method&quot;);
1820         if (m-&gt;name() != name) {
1821           break;
1822         }
1823         if (method_matches(m, signature, skipping_overpass, skipping_static, skipping_private)) {
1824           return i;
1825         }
</pre>
<hr />
<pre>
1836         }
1837     }
1838     // not found
1839 #ifdef ASSERT
1840     const int index = (skipping_overpass || skipping_static || skipping_private) ? -1 :
1841       linear_search(methods, name, signature);
1842     assert(-1 == index, &quot;binary search should have found entry %d&quot;, index);
1843 #endif
1844   }
1845   return -1;
1846 }
1847 
1848 int InstanceKlass::find_method_by_name(const Symbol* name, int* end) const {
1849   return find_method_by_name(methods(), name, end);
1850 }
1851 
1852 int InstanceKlass::find_method_by_name(const Array&lt;Method*&gt;* methods,
1853                                        const Symbol* name,
1854                                        int* end_ptr) {
1855   assert(end_ptr != NULL, &quot;just checking&quot;);
<span class="line-modified">1856   int start = quick_search(methods, name);</span>
1857   int end = start + 1;
1858   if (start != -1) {
1859     while (start - 1 &gt;= 0 &amp;&amp; (methods-&gt;at(start - 1))-&gt;name() == name) --start;
1860     while (end &lt; methods-&gt;length() &amp;&amp; (methods-&gt;at(end))-&gt;name() == name) ++end;
1861     *end_ptr = end;
1862     return start;
1863   }
1864   return -1;
1865 }
1866 
1867 // uncached_lookup_method searches both the local class methods array and all
1868 // superclasses methods arrays, skipping any overpass methods in superclasses,
1869 // and possibly skipping private methods.
1870 Method* InstanceKlass::uncached_lookup_method(const Symbol* name,
1871                                               const Symbol* signature,
1872                                               OverpassLookupMode overpass_mode,
1873                                               PrivateLookupMode private_mode) const {
1874   OverpassLookupMode overpass_local_mode = overpass_mode;
1875   const Klass* klass = this;
1876   while (klass != NULL) {
</pre>
<hr />
<pre>
2013   // generally acquired in those two cases.
2014   //
2015   // If the RedefineClasses() API has been used, then this cache can
2016   // grow and we&#39;ll have transitions from non-NULL to bigger non-NULL.
2017   // Cache creation requires no leaks and we require safety between all
2018   // cache accesses and freeing of the old cache so a lock is generally
2019   // acquired when the RedefineClasses() API has been used.
2020 
2021   if (jmeths != NULL) {
2022     // the cache already exists
2023     if (!idnum_can_increment()) {
2024       // the cache can&#39;t grow so we can just get the current values
2025       get_jmethod_id_length_value(jmeths, idnum, &amp;length, &amp;id);
2026     } else {
2027       // cache can grow so we have to be more careful
2028       if (Threads::number_of_threads() == 0 ||
2029           SafepointSynchronize::is_at_safepoint()) {
2030         // we&#39;re single threaded or at a safepoint - no locking needed
2031         get_jmethod_id_length_value(jmeths, idnum, &amp;length, &amp;id);
2032       } else {
<span class="line-modified">2033         MutexLocker ml(JmethodIdCreation_lock, Mutex::_no_safepoint_check_flag);</span>
2034         get_jmethod_id_length_value(jmeths, idnum, &amp;length, &amp;id);
2035       }
2036     }
2037   }
2038   // implied else:
2039   // we need to allocate a cache so default length and id values are good
2040 
2041   if (jmeths == NULL ||   // no cache yet
2042       length &lt;= idnum ||  // cache is too short
2043       id == NULL) {       // cache doesn&#39;t contain entry
2044 
2045     // This function can be called by the VMThread so we have to do all
2046     // things that might block on a safepoint before grabbing the lock.
2047     // Otherwise, we can deadlock with the VMThread or have a cache
2048     // consistency issue. These vars keep track of what we might have
2049     // to free after the lock is dropped.
2050     jmethodID  to_dealloc_id     = NULL;
2051     jmethodID* to_dealloc_jmeths = NULL;
2052 
2053     // may not allocate new_jmeths or use it if we allocate it
</pre>
<hr />
<pre>
2063 
2064     // allocate a new jmethodID that might be used
2065     jmethodID new_id = NULL;
2066     if (method_h-&gt;is_old() &amp;&amp; !method_h-&gt;is_obsolete()) {
2067       // The method passed in is old (but not obsolete), we need to use the current version
2068       Method* current_method = method_with_idnum((int)idnum);
2069       assert(current_method != NULL, &quot;old and but not obsolete, so should exist&quot;);
2070       new_id = Method::make_jmethod_id(class_loader_data(), current_method);
2071     } else {
2072       // It is the current version of the method or an obsolete method,
2073       // use the version passed in
2074       new_id = Method::make_jmethod_id(class_loader_data(), method_h());
2075     }
2076 
2077     if (Threads::number_of_threads() == 0 ||
2078         SafepointSynchronize::is_at_safepoint()) {
2079       // we&#39;re single threaded or at a safepoint - no locking needed
2080       id = get_jmethod_id_fetch_or_update(idnum, new_id, new_jmeths,
2081                                           &amp;to_dealloc_id, &amp;to_dealloc_jmeths);
2082     } else {
<span class="line-modified">2083       MutexLocker ml(JmethodIdCreation_lock, Mutex::_no_safepoint_check_flag);</span>
2084       id = get_jmethod_id_fetch_or_update(idnum, new_id, new_jmeths,
2085                                           &amp;to_dealloc_id, &amp;to_dealloc_jmeths);
2086     }
2087 
2088     // The lock has been dropped so we can free resources.
2089     // Free up either the old cache or the new cache if we allocated one.
2090     if (to_dealloc_jmeths != NULL) {
2091       FreeHeap(to_dealloc_jmeths);
2092     }
2093     // free up the new ID since it wasn&#39;t needed
2094     if (to_dealloc_id != NULL) {
2095       Method::destroy_jmethod_id(class_loader_data(), to_dealloc_id);
2096     }
2097   }
2098   return id;
2099 }
2100 
2101 // Figure out how many jmethodIDs haven&#39;t been allocated, and make
2102 // sure space for them is pre-allocated.  This makes getting all
2103 // method ids much, much faster with classes with more than 8
</pre>
<hr />
<pre>
2147         new_jmeths[index+1] = jmeths[index+1];
2148       }
2149       *to_dealloc_jmeths_p = jmeths;  // save old cache for later delete
2150     }
2151     release_set_methods_jmethod_ids(jmeths = new_jmeths);
2152   } else {
2153     // fetch jmethodID (if any) from the existing cache
2154     id = jmeths[idnum+1];
2155     *to_dealloc_jmeths_p = new_jmeths;  // save new cache for later delete
2156   }
2157   if (id == NULL) {
2158     // No matching jmethodID in the existing cache or we have a new
2159     // cache or we just grew the cache. This cache write is done here
2160     // by the first thread to win the foot race because a jmethodID
2161     // needs to be unique once it is generally available.
2162     id = new_id;
2163 
2164     // The jmethodID cache can be read while unlocked so we have to
2165     // make sure the new jmethodID is complete before installing it
2166     // in the cache.
<span class="line-modified">2167     Atomic::release_store(&amp;jmeths[idnum+1], id);</span>
2168   } else {
2169     *to_dealloc_id_p = new_id; // save new id for later delete
2170   }
2171   return id;
2172 }
2173 
2174 
2175 // Common code to get the jmethodID cache length and the jmethodID
2176 // value at index idnum if there is one.
2177 //
2178 void InstanceKlass::get_jmethod_id_length_value(jmethodID* cache,
2179        size_t idnum, size_t *length_p, jmethodID* id_p) {
2180   assert(cache != NULL, &quot;sanity check&quot;);
2181   assert(length_p != NULL, &quot;sanity check&quot;);
2182   assert(id_p != NULL, &quot;sanity check&quot;);
2183 
2184   // cache size is stored in element[0], other elements offset by one
2185   *length_p = (size_t)cache[0];
2186   if (*length_p &lt;= idnum) {  // cache is too short
2187     *id_p = NULL;
</pre>
<hr />
<pre>
2229 void InstanceKlass::print_dependent_nmethods(bool verbose) {
2230   dependencies().print_dependent_nmethods(verbose);
2231 }
2232 
2233 bool InstanceKlass::is_dependent_nmethod(nmethod* nm) {
2234   return dependencies().is_dependent_nmethod(nm);
2235 }
2236 #endif //PRODUCT
2237 
2238 void InstanceKlass::clean_weak_instanceklass_links() {
2239   clean_implementors_list();
2240   clean_method_data();
2241 }
2242 
2243 void InstanceKlass::clean_implementors_list() {
2244   assert(is_loader_alive(), &quot;this klass should be live&quot;);
2245   if (is_interface()) {
2246     assert (ClassUnloading, &quot;only called for ClassUnloading&quot;);
2247     for (;;) {
2248       // Use load_acquire due to competing with inserts
<span class="line-modified">2249       Klass* impl = Atomic::load_acquire(adr_implementor());</span>
2250       if (impl != NULL &amp;&amp; !impl-&gt;is_loader_alive()) {
2251         // NULL this field, might be an unloaded klass or NULL
2252         Klass* volatile* klass = adr_implementor();
<span class="line-modified">2253         if (Atomic::cmpxchg(klass, impl, (Klass*)NULL) == impl) {</span>
2254           // Successfully unlinking implementor.
2255           if (log_is_enabled(Trace, class, unload)) {
2256             ResourceMark rm;
2257             log_trace(class, unload)(&quot;unlinking class (implementor): %s&quot;, impl-&gt;external_name());
2258           }
2259           return;
2260         }
2261       } else {
2262         return;
2263       }
2264     }
2265   }
2266 }
2267 
2268 void InstanceKlass::clean_method_data() {
2269   for (int m = 0; m &lt; methods()-&gt;length(); m++) {
2270     MethodData* mdo = methods()-&gt;at(m)-&gt;method_data();
2271     if (mdo != NULL) {
<span class="line-modified">2272       MutexLocker ml(SafepointSynchronize::is_at_safepoint() ? NULL : mdo-&gt;extra_data_lock());</span>
2273       mdo-&gt;clean_method_data(/*always_clean*/false);
2274     }
2275   }
2276 }
2277 
2278 bool InstanceKlass::supers_have_passed_fingerprint_checks() {
2279   if (java_super() != NULL &amp;&amp; !java_super()-&gt;has_passed_fingerprint_check()) {
2280     ResourceMark rm;
2281     log_trace(class, fingerprint)(&quot;%s : super %s not fingerprinted&quot;, external_name(), java_super()-&gt;external_name());
2282     return false;
2283   }
2284 
2285   Array&lt;InstanceKlass*&gt;* local_interfaces = this-&gt;local_interfaces();
2286   if (local_interfaces != NULL) {
2287     int length = local_interfaces-&gt;length();
2288     for (int i = 0; i &lt; length; i++) {
2289       InstanceKlass* intf = local_interfaces-&gt;at(i);
2290       if (!intf-&gt;has_passed_fingerprint_check()) {
2291         ResourceMark rm;
2292         log_trace(class, fingerprint)(&quot;%s : interface %s not fingerprinted&quot;, external_name(), intf-&gt;external_name());
2293         return false;
2294       }
2295     }
2296   }
2297 
2298   return true;
2299 }
2300 
2301 bool InstanceKlass::should_store_fingerprint(bool is_unsafe_anonymous) {
2302 #if INCLUDE_AOT
2303   // We store the fingerprint into the InstanceKlass only in the following 2 cases:
2304   if (CalculateClassFingerprint) {
2305     // (1) We are running AOT to generate a shared library.
2306     return true;
2307   }
<span class="line-modified">2308   if (Arguments::is_dumping_archive()) {</span>
<span class="line-modified">2309     // (2) We are running -Xshare:dump or -XX:ArchiveClassesAtExit to create a shared archive</span>
2310     return true;
2311   }
2312   if (UseAOT &amp;&amp; is_unsafe_anonymous) {
2313     // (3) We are using AOT code from a shared library and see an unsafe anonymous class
2314     return true;
2315   }
2316 #endif
2317 
2318   // In all other cases we might set the _misc_has_passed_fingerprint_check bit,
2319   // but do not store the 64-bit fingerprint to save space.
2320   return false;
2321 }
2322 
2323 bool InstanceKlass::has_stored_fingerprint() const {
2324 #if INCLUDE_AOT
2325   return should_store_fingerprint() || is_shared();
2326 #else
2327   return false;
2328 #endif
2329 }
</pre>
<hr />
<pre>
2372 
2373   if (itable_length() &gt; 0) {
2374     itableOffsetEntry* ioe = (itableOffsetEntry*)start_of_itable();
2375     int method_table_offset_in_words = ioe-&gt;offset()/wordSize;
2376     int nof_interfaces = (method_table_offset_in_words - itable_offset_in_words())
2377                          / itableOffsetEntry::size();
2378 
2379     for (int i = 0; i &lt; nof_interfaces; i ++, ioe ++) {
2380       if (ioe-&gt;interface_klass() != NULL) {
2381         it-&gt;push(ioe-&gt;interface_klass_addr());
2382         itableMethodEntry* ime = ioe-&gt;first_method_entry(this);
2383         int n = klassItable::method_count_for_interface(ioe-&gt;interface_klass());
2384         for (int index = 0; index &lt; n; index ++) {
2385           it-&gt;push(ime[index].method_addr());
2386         }
2387       }
2388     }
2389   }
2390 
2391   it-&gt;push(&amp;_nest_members);
<span class="line-added">2392   it-&gt;push(&amp;_record_components);</span>
2393 }
2394 
2395 void InstanceKlass::remove_unshareable_info() {
2396   Klass::remove_unshareable_info();
2397 
2398   if (is_in_error_state()) {
2399     // Classes are attempted to link during dumping and may fail,
2400     // but these classes are still in the dictionary and class list in CLD.
2401     // Check in_error state first because in_error is &gt; linked state, so
2402     // is_linked() is true.
2403     // If there&#39;s a linking error, there is nothing else to remove.
2404     return;
2405   }
2406 
2407   // Reset to the &#39;allocated&#39; state to prevent any premature accessing to
2408   // a shared class at runtime while the class is still being loaded and
2409   // restored. A class&#39; init_state is set to &#39;loaded&#39; at runtime when it&#39;s
2410   // being added to class hierarchy (see SystemDictionary:::add_to_hierarchy()).
2411   _init_state = allocated;
2412 
<span class="line-modified">2413   { // Otherwise this needs to take out the Compile_lock.</span>
<span class="line-modified">2414     assert(SafepointSynchronize::is_at_safepoint(), &quot;only called at safepoint&quot;);</span>
2415     init_implementor();
2416   }
2417 
2418   constants()-&gt;remove_unshareable_info();
2419 
2420   for (int i = 0; i &lt; methods()-&gt;length(); i++) {
2421     Method* m = methods()-&gt;at(i);
2422     m-&gt;remove_unshareable_info();
2423   }
2424 
2425   // do array classes also.
2426   if (array_klasses() != NULL) {
2427     array_klasses()-&gt;remove_unshareable_info();
2428   }
2429 
<span class="line-modified">2430   // These are not allocated from metaspace. They are safe to set to NULL.</span>
<span class="line-modified">2431   _source_debug_extension = NULL;</span>
<span class="line-modified">2432   _dep_context = NULL;</span>
<span class="line-modified">2433   _osr_nmethods_head = NULL;</span>


2434 #if INCLUDE_JVMTI
<span class="line-modified">2435   _breakpoints = NULL;</span>
<span class="line-modified">2436   _previous_versions = NULL;</span>
2437   _cached_class_file = NULL;
<span class="line-added">2438   _jvmti_cached_class_field_map = NULL;</span>
2439 #endif
2440 
2441   _init_thread = NULL;
2442   _methods_jmethod_ids = NULL;
2443   _jni_ids = NULL;
2444   _oop_map_cache = NULL;
2445   // clear _nest_host to ensure re-load at runtime
2446   _nest_host = NULL;
<span class="line-added">2447   _package_entry = NULL;</span>
<span class="line-added">2448   _dep_context_last_cleaned = 0;</span>
2449 }
2450 
2451 void InstanceKlass::remove_java_mirror() {
2452   Klass::remove_java_mirror();
2453 
2454   // do array classes also.
2455   if (array_klasses() != NULL) {
2456     array_klasses()-&gt;remove_java_mirror();
2457   }
2458 }
2459 
2460 void InstanceKlass::restore_unshareable_info(ClassLoaderData* loader_data, Handle protection_domain, TRAPS) {
2461   // SystemDictionary::add_to_hierarchy() sets the init_state to loaded
2462   // before the InstanceKlass is added to the SystemDictionary. Make
2463   // sure the current state is &lt;loaded.
2464   assert(!is_loaded(), &quot;invalid init state&quot;);
2465   set_package(loader_data, CHECK);
2466   Klass::restore_unshareable_info(loader_data, protection_domain, CHECK);
2467 
2468   Array&lt;Method*&gt;* methods = this-&gt;methods();
</pre>
<hr />
<pre>
2471     methods-&gt;at(index)-&gt;restore_unshareable_info(CHECK);
2472   }
2473   if (JvmtiExport::has_redefined_a_class()) {
2474     // Reinitialize vtable because RedefineClasses may have changed some
2475     // entries in this vtable for super classes so the CDS vtable might
2476     // point to old or obsolete entries.  RedefineClasses doesn&#39;t fix up
2477     // vtables in the shared system dictionary, only the main one.
2478     // It also redefines the itable too so fix that too.
2479     vtable().initialize_vtable(false, CHECK);
2480     itable().initialize_itable(false, CHECK);
2481   }
2482 
2483   // restore constant pool resolved references
2484   constants()-&gt;restore_unshareable_info(CHECK);
2485 
2486   if (array_klasses() != NULL) {
2487     // Array classes have null protection domain.
2488     // --&gt; see ArrayKlass::complete_create_array_klass()
2489     array_klasses()-&gt;restore_unshareable_info(ClassLoaderData::the_null_class_loader_data(), Handle(), CHECK);
2490   }
<span class="line-added">2491 </span>
<span class="line-added">2492   // Initialize current biased locking state.</span>
<span class="line-added">2493   if (UseBiasedLocking &amp;&amp; BiasedLocking::enabled()) {</span>
<span class="line-added">2494     set_prototype_header(markWord::biased_locking_prototype());</span>
<span class="line-added">2495   }</span>
2496 }
2497 
2498 // returns true IFF is_in_error_state() has been changed as a result of this call.
2499 bool InstanceKlass::check_sharing_error_state() {
2500   assert(DumpSharedSpaces, &quot;should only be called during dumping&quot;);
2501   bool old_state = is_in_error_state();
2502 
2503   if (!is_in_error_state()) {
2504     bool bad = false;
2505     for (InstanceKlass* sup = java_super(); sup; sup = sup-&gt;java_super()) {
2506       if (sup-&gt;is_in_error_state()) {
2507         bad = true;
2508         break;
2509       }
2510     }
2511     if (!bad) {
2512       Array&lt;InstanceKlass*&gt;* interfaces = transitive_interfaces();
2513       for (int i = 0; i &lt; interfaces-&gt;length(); i++) {
2514         InstanceKlass* iface = interfaces-&gt;at(i);
2515         if (iface-&gt;is_in_error_state()) {
2516           bad = true;
2517           break;
2518         }
2519       }
2520     }
2521 
2522     if (bad) {
2523       set_in_error_state();
2524     }
2525   }
2526 
2527   return (old_state != is_in_error_state());
2528 }
2529 
<span class="line-added">2530 void InstanceKlass::set_class_loader_type(s2 loader_type) {</span>
<span class="line-added">2531   switch (loader_type) {</span>
<span class="line-added">2532   case ClassLoader::BOOT_LOADER:</span>
<span class="line-added">2533     _misc_flags |= _misc_is_shared_boot_class;</span>
<span class="line-added">2534     break;</span>
<span class="line-added">2535   case ClassLoader::PLATFORM_LOADER:</span>
<span class="line-added">2536     _misc_flags |= _misc_is_shared_platform_class;</span>
<span class="line-added">2537     break;</span>
<span class="line-added">2538   case ClassLoader::APP_LOADER:</span>
<span class="line-added">2539     _misc_flags |= _misc_is_shared_app_class;</span>
<span class="line-added">2540     break;</span>
<span class="line-added">2541   default:</span>
<span class="line-added">2542     ShouldNotReachHere();</span>
<span class="line-added">2543     break;</span>
<span class="line-added">2544   }</span>
<span class="line-added">2545 }</span>
<span class="line-added">2546 </span>
2547 #if INCLUDE_JVMTI
2548 static void clear_all_breakpoints(Method* m) {
2549   m-&gt;clear_all_breakpoints();
2550 }
2551 #endif
2552 
2553 void InstanceKlass::unload_class(InstanceKlass* ik) {
2554   // Release dependencies.
2555   ik-&gt;dependencies().remove_all_dependents();
2556 
2557   // notify the debugger
2558   if (JvmtiExport::should_post_class_unload()) {
2559     JvmtiExport::post_class_unload(ik);
2560   }
2561 
2562   // notify ClassLoadingService of class unload
2563   ClassLoadingService::notify_class_unloaded(ik);
2564 
<span class="line-added">2565   if (Arguments::is_dumping_archive()) {</span>
<span class="line-added">2566     SystemDictionaryShared::remove_dumptime_info(ik);</span>
<span class="line-added">2567   }</span>
<span class="line-added">2568 </span>
2569   if (log_is_enabled(Info, class, unload)) {
2570     ResourceMark rm;
2571     log_info(class, unload)(&quot;unloading class %s &quot; INTPTR_FORMAT, ik-&gt;external_name(), p2i(ik));
2572   }
2573 
2574   Events::log_class_unloading(Thread::current(), ik);
2575 
2576 #if INCLUDE_JFR
2577   assert(ik != NULL, &quot;invariant&quot;);
2578   EventClassUnload event;
2579   event.set_unloadedClass(ik);
2580   event.set_definingClassLoader(ik-&gt;class_loader_data());
2581   event.commit();
2582 #endif
2583 }
2584 
<span class="line-added">2585 static void method_release_C_heap_structures(Method* m) {</span>
<span class="line-added">2586   m-&gt;release_C_heap_structures();</span>
<span class="line-added">2587 }</span>
<span class="line-added">2588 </span>
2589 void InstanceKlass::release_C_heap_structures(InstanceKlass* ik) {
2590   // Clean up C heap
2591   ik-&gt;release_C_heap_structures();
2592   ik-&gt;constants()-&gt;release_C_heap_structures();
<span class="line-added">2593 </span>
<span class="line-added">2594   // Deallocate and call destructors for MDO mutexes</span>
<span class="line-added">2595   ik-&gt;methods_do(method_release_C_heap_structures);</span>
<span class="line-added">2596 </span>
2597 }
2598 
2599 void InstanceKlass::release_C_heap_structures() {
2600   // Can&#39;t release the constant pool here because the constant pool can be
2601   // deallocated separately from the InstanceKlass for default methods and
2602   // redefine classes.
2603 
2604   // Deallocate oop map cache
2605   if (_oop_map_cache != NULL) {
2606     delete _oop_map_cache;
2607     _oop_map_cache = NULL;
2608   }
2609 
2610   // Deallocate JNI identifiers for jfieldIDs
2611   JNIid::deallocate(jni_ids());
2612   set_jni_ids(NULL);
2613 
2614   jmethodID* jmeths = methods_jmethod_ids_acquire();
2615   if (jmeths != (jmethodID*)NULL) {
2616     release_set_methods_jmethod_ids(NULL);
</pre>
<hr />
<pre>
2622 
2623 #if INCLUDE_JVMTI
2624   // Deallocate breakpoint records
2625   if (breakpoints() != 0x0) {
2626     methods_do(clear_all_breakpoints);
2627     assert(breakpoints() == 0x0, &quot;should have cleared breakpoints&quot;);
2628   }
2629 
2630   // deallocate the cached class file
2631   if (_cached_class_file != NULL) {
2632     os::free(_cached_class_file);
2633     _cached_class_file = NULL;
2634   }
2635 #endif
2636 
2637   // Decrement symbol reference counts associated with the unloaded class.
2638   if (_name != NULL) _name-&gt;decrement_refcount();
2639   // unreference array name derived from this class name (arrays of an unloaded
2640   // class can&#39;t be referenced anymore).
2641   if (_array_name != NULL)  _array_name-&gt;decrement_refcount();
<span class="line-modified">2642   FREE_C_HEAP_ARRAY(char, _source_debug_extension);</span>
2643 }
2644 
2645 void InstanceKlass::set_source_debug_extension(const char* array, int length) {
2646   if (array == NULL) {
2647     _source_debug_extension = NULL;
2648   } else {
2649     // Adding one to the attribute length in order to store a null terminator
2650     // character could cause an overflow because the attribute length is
2651     // already coded with an u4 in the classfile, but in practice, it&#39;s
2652     // unlikely to happen.
2653     assert((length+1) &gt; length, &quot;Overflow checking&quot;);
2654     char* sde = NEW_C_HEAP_ARRAY(char, (length + 1), mtClass);
2655     for (int i = 0; i &lt; length; i++) {
2656       sde[i] = array[i];
2657     }
2658     sde[length] = &#39;\0&#39;;
2659     _source_debug_extension = sde;
2660   }
2661 }
2662 
2663 const char* InstanceKlass::signature_name() const {
2664   int hash_len = 0;
2665   char hash_buf[40];
2666 
2667   // If this is an unsafe anonymous class, append a hash to make the name unique
2668   if (is_unsafe_anonymous()) {
2669     intptr_t hash = (java_mirror() != NULL) ? java_mirror()-&gt;identity_hash() : 0;
2670     jio_snprintf(hash_buf, sizeof(hash_buf), &quot;/&quot; UINTX_FORMAT, (uintx)hash);
2671     hash_len = (int)strlen(hash_buf);
2672   }
2673 
2674   // Get the internal name as a c string
2675   const char* src = (const char*) (name()-&gt;as_C_string());
2676   const int src_length = (int)strlen(src);
2677 
2678   char* dest = NEW_RESOURCE_ARRAY(char, src_length + hash_len + 3);
2679 
2680   // Add L as type indicator
2681   int dest_index = 0;
<span class="line-modified">2682   dest[dest_index++] = JVM_SIGNATURE_CLASS;</span>
2683 
2684   // Add the actual class name
2685   for (int src_index = 0; src_index &lt; src_length; ) {
2686     dest[dest_index++] = src[src_index++];
2687   }
2688 
2689   // If we have a hash, append it
2690   for (int hash_index = 0; hash_index &lt; hash_len; ) {
2691     dest[dest_index++] = hash_buf[hash_index++];
2692   }
2693 
2694   // Add the semicolon and the NULL
<span class="line-modified">2695   dest[dest_index++] = JVM_SIGNATURE_ENDCLASS;</span>
2696   dest[dest_index] = &#39;\0&#39;;
2697   return dest;
2698 }
2699 
2700 // Used to obtain the package name from a fully qualified class name.
2701 Symbol* InstanceKlass::package_from_name(const Symbol* name, TRAPS) {
2702   if (name == NULL) {
2703     return NULL;
2704   } else {
2705     if (name-&gt;utf8_length() &lt;= 0) {
2706       return NULL;
2707     }
<span class="line-modified">2708     ResourceMark rm(THREAD);</span>
2709     const char* package_name = ClassLoader::package_from_name((const char*) name-&gt;as_C_string());
2710     if (package_name == NULL) {
2711       return NULL;
2712     }
<span class="line-modified">2713     Symbol* pkg_name = SymbolTable::new_symbol(package_name);</span>
2714     return pkg_name;
2715   }
2716 }
2717 
2718 ModuleEntry* InstanceKlass::module() const {
2719   // For an unsafe anonymous class return the host class&#39; module
2720   if (is_unsafe_anonymous()) {
2721     assert(unsafe_anonymous_host() != NULL, &quot;unsafe anonymous class must have a host class&quot;);
2722     return unsafe_anonymous_host()-&gt;module();
2723   }
2724 
2725   // Class is in a named package
2726   if (!in_unnamed_package()) {
2727     return _package_entry-&gt;module();
2728   }
2729 
2730   // Class is in an unnamed package, return its loader&#39;s unnamed module
2731   return class_loader_data()-&gt;unnamed_module();
2732 }
2733 
2734 void InstanceKlass::set_package(ClassLoaderData* loader_data, TRAPS) {
2735 
2736   // ensure java/ packages only loaded by boot or platform builtin loaders
2737   check_prohibited_package(name(), loader_data, CHECK);
2738 
2739   TempNewSymbol pkg_name = package_from_name(name(), CHECK);
2740 
2741   if (pkg_name != NULL &amp;&amp; loader_data != NULL) {
2742 
2743     // Find in class loader&#39;s package entry table.
2744     _package_entry = loader_data-&gt;packages()-&gt;lookup_only(pkg_name);
2745 
2746     // If the package name is not found in the loader&#39;s package
2747     // entry table, it is an indication that the package has not
2748     // been defined. Consider it defined within the unnamed module.
2749     if (_package_entry == NULL) {
<span class="line-modified">2750       ResourceMark rm(THREAD);</span>
2751 
2752       if (!ModuleEntryTable::javabase_defined()) {
2753         // Before java.base is defined during bootstrapping, define all packages in
2754         // the java.base module.  If a non-java.base package is erroneously placed
2755         // in the java.base module it will be caught later when java.base
2756         // is defined by ModuleEntryTable::verify_javabase_packages check.
2757         assert(ModuleEntryTable::javabase_moduleEntry() != NULL, JAVA_BASE_NAME &quot; module is NULL&quot;);
2758         _package_entry = loader_data-&gt;packages()-&gt;lookup(pkg_name, ModuleEntryTable::javabase_moduleEntry());
2759       } else {
2760         assert(loader_data-&gt;unnamed_module() != NULL, &quot;unnamed module is NULL&quot;);
2761         _package_entry = loader_data-&gt;packages()-&gt;lookup(pkg_name,
2762                                                          loader_data-&gt;unnamed_module());
2763       }
2764 
2765       // A package should have been successfully created
2766       assert(_package_entry != NULL, &quot;Package entry for class %s not found, loader %s&quot;,
2767              name()-&gt;as_C_string(), loader_data-&gt;loader_name_and_id());
2768     }
2769 
2770     if (log_is_enabled(Debug, module)) {
<span class="line-modified">2771       ResourceMark rm(THREAD);</span>
2772       ModuleEntry* m = _package_entry-&gt;module();
2773       log_trace(module)(&quot;Setting package: class: %s, package: %s, loader: %s, module: %s&quot;,
2774                         external_name(),
2775                         pkg_name-&gt;as_C_string(),
2776                         loader_data-&gt;loader_name_and_id(),
2777                         (m-&gt;is_named() ? m-&gt;name()-&gt;as_C_string() : UNNAMED_MODULE));
2778     }
2779   } else {
<span class="line-modified">2780     ResourceMark rm(THREAD);</span>
2781     log_trace(module)(&quot;Setting package: class: %s, package: unnamed, loader: %s, module: %s&quot;,
2782                       external_name(),
2783                       (loader_data != NULL) ? loader_data-&gt;loader_name_and_id() : &quot;NULL&quot;,
2784                       UNNAMED_MODULE);
2785   }
2786 }
2787 
2788 
2789 // different versions of is_same_class_package
2790 
2791 bool InstanceKlass::is_same_class_package(const Klass* class2) const {
2792   oop classloader1 = this-&gt;class_loader();
2793   PackageEntry* classpkg1 = this-&gt;package();
2794   if (class2-&gt;is_objArray_klass()) {
2795     class2 = ObjArrayKlass::cast(class2)-&gt;bottom_klass();
2796   }
2797 
2798   oop classloader2;
2799   PackageEntry* classpkg2;
2800   if (class2-&gt;is_instance_klass()) {
2801     classloader2 = class2-&gt;class_loader();
2802     classpkg2 = class2-&gt;package();
2803   } else {
2804     assert(class2-&gt;is_typeArray_klass(), &quot;should be type array&quot;);
2805     classloader2 = NULL;
2806     classpkg2 = NULL;
2807   }
2808 
2809   // Same package is determined by comparing class loader
2810   // and package entries. Both must be the same. This rule
2811   // applies even to classes that are defined in the unnamed
2812   // package, they still must have the same class loader.
<span class="line-modified">2813   if ((classloader1 == classloader2) &amp;&amp; (classpkg1 == classpkg2)) {</span>
2814     return true;
2815   }
2816 
2817   return false;
2818 }
2819 
2820 // return true if this class and other_class are in the same package. Classloader
2821 // and classname information is enough to determine a class&#39;s package
2822 bool InstanceKlass::is_same_class_package(oop other_class_loader,
2823                                           const Symbol* other_class_name) const {
<span class="line-modified">2824   if (class_loader() != other_class_loader) {</span>
2825     return false;
2826   }
2827   if (name()-&gt;fast_compare(other_class_name) == 0) {
2828      return true;
2829   }
2830 
2831   {
2832     ResourceMark rm;
2833 
2834     bool bad_class_name = false;
2835     const char* other_pkg =
2836       ClassLoader::package_from_name((const char*) other_class_name-&gt;as_C_string(), &amp;bad_class_name);
2837     if (bad_class_name) {
2838       return false;
2839     }
2840     // Check that package_from_name() returns NULL, not &quot;&quot;, if there is no package.
2841     assert(other_pkg == NULL || strlen(other_pkg) &gt; 0, &quot;package name is empty string&quot;);
2842 
2843     const Symbol* const this_package_name =
2844       this-&gt;package() != NULL ? this-&gt;package()-&gt;name() : NULL;
</pre>
<hr />
<pre>
3049 
3050       if (log_is_enabled(Info, redefine, class, update)) {
3051         ResourceMark rm;
3052         if (!(*trace_name_printed)) {
3053           log_info(redefine, class, update)
3054             (&quot;adjust: klassname=%s default methods from name=%s&quot;,
3055              external_name(), old_method-&gt;method_holder()-&gt;external_name());
3056           *trace_name_printed = true;
3057         }
3058         log_debug(redefine, class, update, vtables)
3059           (&quot;default method update: %s(%s) &quot;,
3060            new_method-&gt;name()-&gt;as_C_string(), new_method-&gt;signature()-&gt;as_C_string());
3061       }
3062     }
3063   }
3064 }
3065 #endif // INCLUDE_JVMTI
3066 
3067 // On-stack replacement stuff
3068 void InstanceKlass::add_osr_nmethod(nmethod* n) {
<span class="line-added">3069   assert_lock_strong(CompiledMethod_lock);</span>
<span class="line-added">3070 #ifndef PRODUCT</span>
<span class="line-added">3071   if (TieredCompilation) {</span>
<span class="line-added">3072       nmethod * prev = lookup_osr_nmethod(n-&gt;method(), n-&gt;osr_entry_bci(), n-&gt;comp_level(), true);</span>
<span class="line-added">3073       assert(prev == NULL || !prev-&gt;is_in_use(),</span>
<span class="line-added">3074       &quot;redundunt OSR recompilation detected. memory leak in CodeCache!&quot;);</span>
<span class="line-added">3075   }</span>
<span class="line-added">3076 #endif</span>
3077   // only one compilation can be active
3078   {


3079     assert(n-&gt;is_osr_method(), &quot;wrong kind of nmethod&quot;);
3080     n-&gt;set_osr_link(osr_nmethods_head());
3081     set_osr_nmethods_head(n);
3082     // Raise the highest osr level if necessary
3083     if (TieredCompilation) {
3084       Method* m = n-&gt;method();
3085       m-&gt;set_highest_osr_comp_level(MAX2(m-&gt;highest_osr_comp_level(), n-&gt;comp_level()));
3086     }
3087   }
3088 
3089   // Get rid of the osr methods for the same bci that have lower levels.
3090   if (TieredCompilation) {
3091     for (int l = CompLevel_limited_profile; l &lt; n-&gt;comp_level(); l++) {
3092       nmethod *inv = lookup_osr_nmethod(n-&gt;method(), n-&gt;osr_entry_bci(), l, true);
3093       if (inv != NULL &amp;&amp; inv-&gt;is_in_use()) {
3094         inv-&gt;make_not_entrant();
3095       }
3096     }
3097   }
3098 }
3099 
3100 // Remove osr nmethod from the list. Return true if found and removed.
3101 bool InstanceKlass::remove_osr_nmethod(nmethod* n) {
3102   // This is a short non-blocking critical region, so the no safepoint check is ok.
<span class="line-modified">3103   MutexLocker ml(CompiledMethod_lock-&gt;owned_by_self() ? NULL : CompiledMethod_lock</span>
<span class="line-added">3104                  , Mutex::_no_safepoint_check_flag);</span>
3105   assert(n-&gt;is_osr_method(), &quot;wrong kind of nmethod&quot;);
3106   nmethod* last = NULL;
3107   nmethod* cur  = osr_nmethods_head();
3108   int max_level = CompLevel_none;  // Find the max comp level excluding n
3109   Method* m = n-&gt;method();
3110   // Search for match
3111   bool found = false;
3112   while(cur != NULL &amp;&amp; cur != n) {
3113     if (TieredCompilation &amp;&amp; m == cur-&gt;method()) {
3114       // Find max level before n
3115       max_level = MAX2(max_level, cur-&gt;comp_level());
3116     }
3117     last = cur;
3118     cur = cur-&gt;osr_link();
3119   }
3120   nmethod* next = NULL;
3121   if (cur == n) {
3122     found = true;
3123     next = cur-&gt;osr_link();
3124     if (last == NULL) {
</pre>
<hr />
<pre>
3127     } else {
3128       last-&gt;set_osr_link(next);
3129     }
3130   }
3131   n-&gt;set_osr_link(NULL);
3132   if (TieredCompilation) {
3133     cur = next;
3134     while (cur != NULL) {
3135       // Find max level after n
3136       if (m == cur-&gt;method()) {
3137         max_level = MAX2(max_level, cur-&gt;comp_level());
3138       }
3139       cur = cur-&gt;osr_link();
3140     }
3141     m-&gt;set_highest_osr_comp_level(max_level);
3142   }
3143   return found;
3144 }
3145 
3146 int InstanceKlass::mark_osr_nmethods(const Method* m) {
<span class="line-modified">3147   MutexLocker ml(CompiledMethod_lock-&gt;owned_by_self() ? NULL : CompiledMethod_lock,</span>
<span class="line-modified">3148                  Mutex::_no_safepoint_check_flag);</span>
3149   nmethod* osr = osr_nmethods_head();
3150   int found = 0;
3151   while (osr != NULL) {
3152     assert(osr-&gt;is_osr_method(), &quot;wrong kind of nmethod found in chain&quot;);
3153     if (osr-&gt;method() == m) {
3154       osr-&gt;mark_for_deoptimization();
3155       found++;
3156     }
3157     osr = osr-&gt;osr_link();
3158   }
3159   return found;
3160 }
3161 
3162 nmethod* InstanceKlass::lookup_osr_nmethod(const Method* m, int bci, int comp_level, bool match_level) const {
<span class="line-modified">3163   MutexLocker ml(CompiledMethod_lock-&gt;owned_by_self() ? NULL : CompiledMethod_lock,</span>
<span class="line-modified">3164                  Mutex::_no_safepoint_check_flag);</span>
3165   nmethod* osr = osr_nmethods_head();
3166   nmethod* best = NULL;
3167   while (osr != NULL) {
3168     assert(osr-&gt;is_osr_method(), &quot;wrong kind of nmethod found in chain&quot;);
3169     // There can be a time when a c1 osr method exists but we are waiting
3170     // for a c2 version. When c2 completes its osr nmethod we will trash
3171     // the c1 version and only be able to find the c2 version. However
3172     // while we overflow in the c1 code at back branches we don&#39;t want to
3173     // try and switch to the same code as we are already running
3174 
3175     if (osr-&gt;method() == m &amp;&amp;
3176         (bci == InvocationEntryBci || osr-&gt;osr_entry_bci() == bci)) {
3177       if (match_level) {
3178         if (osr-&gt;comp_level() == comp_level) {
3179           // Found a match - return it.
3180           return osr;
3181         }
3182       } else {
3183         if (best == NULL || (osr-&gt;comp_level() &gt; best-&gt;comp_level())) {
3184           if (osr-&gt;comp_level() == CompLevel_highest_tier) {
3185             // Found the best possible - return it.
3186             return osr;
3187           }
3188           best = osr;
3189         }
3190       }
3191     }
3192     osr = osr-&gt;osr_link();
3193   }
<span class="line-modified">3194 </span>
<span class="line-added">3195   assert(match_level == false || best == NULL, &quot;shouldn&#39;t pick up anything if match_level is set&quot;);</span>
<span class="line-added">3196   if (best != NULL &amp;&amp; best-&gt;comp_level() &gt;= comp_level) {</span>
3197     return best;
3198   }
3199   return NULL;
3200 }
3201 
3202 // -----------------------------------------------------------------------------------------------------
3203 // Printing
3204 
3205 #ifndef PRODUCT
3206 
3207 #define BULLET  &quot; - &quot;
3208 
3209 static const char* state_names[] = {
3210   &quot;allocated&quot;, &quot;loaded&quot;, &quot;linked&quot;, &quot;being_initialized&quot;, &quot;fully_initialized&quot;, &quot;initialization_error&quot;
3211 };
3212 
3213 static void print_vtable(intptr_t* start, int len, outputStream* st) {
3214   for (int i = 0; i &lt; len; i++) {
3215     intptr_t e = start[i];
3216     st-&gt;print(&quot;%d : &quot; INTPTR_FORMAT, i, e);
<span class="line-modified">3217     if (MetaspaceObj::is_valid((Metadata*)e)) {</span>
3218       st-&gt;print(&quot; &quot;);
3219       ((Metadata*)e)-&gt;print_value_on(st);
3220     }
3221     st-&gt;cr();
3222   }
3223 }
3224 
3225 static void print_vtable(vtableEntry* start, int len, outputStream* st) {
3226   return print_vtable(reinterpret_cast&lt;intptr_t*&gt;(start), len, st);
3227 }
3228 
3229 void InstanceKlass::print_on(outputStream* st) const {
3230   assert(is_klass(), &quot;must be klass&quot;);
3231   Klass::print_on(st);
3232 
3233   st-&gt;print(BULLET&quot;instance size:     %d&quot;, size_helper());                        st-&gt;cr();
3234   st-&gt;print(BULLET&quot;klass size:        %d&quot;, size());                               st-&gt;cr();
3235   st-&gt;print(BULLET&quot;access:            &quot;); access_flags().print_on(st);            st-&gt;cr();
3236   st-&gt;print(BULLET&quot;state:             &quot;); st-&gt;print_cr(&quot;%s&quot;, state_names[_init_state]);
3237   st-&gt;print(BULLET&quot;name:              &quot;); name()-&gt;print_value_on(st);             st-&gt;cr();
</pre>
<hr />
<pre>
3304     bool have_pv = false;
3305     // previous versions are linked together through the InstanceKlass
3306     for (InstanceKlass* pv_node = previous_versions();
3307          pv_node != NULL;
3308          pv_node = pv_node-&gt;previous_versions()) {
3309       if (!have_pv)
3310         st-&gt;print(BULLET&quot;previous version:  &quot;);
3311       have_pv = true;
3312       pv_node-&gt;constants()-&gt;print_value_on(st);
3313     }
3314     if (have_pv) st-&gt;cr();
3315   }
3316 
3317   if (generic_signature() != NULL) {
3318     st-&gt;print(BULLET&quot;generic signature: &quot;);
3319     generic_signature()-&gt;print_value_on(st);
3320     st-&gt;cr();
3321   }
3322   st-&gt;print(BULLET&quot;inner classes:     &quot;); inner_classes()-&gt;print_value_on(st);     st-&gt;cr();
3323   st-&gt;print(BULLET&quot;nest members:     &quot;); nest_members()-&gt;print_value_on(st);     st-&gt;cr();
<span class="line-added">3324   if (record_components() != NULL) {</span>
<span class="line-added">3325     st-&gt;print(BULLET&quot;record components:     &quot;); record_components()-&gt;print_value_on(st);     st-&gt;cr();</span>
<span class="line-added">3326   }</span>
3327   if (java_mirror() != NULL) {
3328     st-&gt;print(BULLET&quot;java mirror:       &quot;);
3329     java_mirror()-&gt;print_value_on(st);
3330     st-&gt;cr();
3331   } else {
3332     st-&gt;print_cr(BULLET&quot;java mirror:       NULL&quot;);
3333   }
3334   st-&gt;print(BULLET&quot;vtable length      %d  (start addr: &quot; INTPTR_FORMAT &quot;)&quot;, vtable_length(), p2i(start_of_vtable())); st-&gt;cr();
3335   if (vtable_length() &gt; 0 &amp;&amp; (Verbose || WizardMode))  print_vtable(start_of_vtable(), vtable_length(), st);
3336   st-&gt;print(BULLET&quot;itable length      %d (start addr: &quot; INTPTR_FORMAT &quot;)&quot;, itable_length(), p2i(start_of_itable())); st-&gt;cr();
3337   if (itable_length() &gt; 0 &amp;&amp; (Verbose || WizardMode))  print_vtable(start_of_itable(), itable_length(), st);
3338   st-&gt;print_cr(BULLET&quot;---- static fields (%d words):&quot;, static_field_size());
3339   FieldPrinter print_static_field(st);
3340   ((InstanceKlass*)this)-&gt;do_local_static_fields(&amp;print_static_field);
3341   st-&gt;print_cr(BULLET&quot;---- non-static fields (%d words):&quot;, nonstatic_field_size());
3342   FieldPrinter print_nonstatic_field(st);
3343   InstanceKlass* ik = const_cast&lt;InstanceKlass*&gt;(this);
3344   ik-&gt;do_nonstatic_fields(&amp;print_nonstatic_field);
3345 
3346   st-&gt;print(BULLET&quot;non-static oop maps: &quot;);
</pre>
<hr />
<pre>
3480 }
3481 
3482 void InstanceKlass::print_class_load_logging(ClassLoaderData* loader_data,
3483                                              const char* module_name,
3484                                              const ClassFileStream* cfs) const {
3485   if (!log_is_enabled(Info, class, load)) {
3486     return;
3487   }
3488 
3489   ResourceMark rm;
3490   LogMessage(class, load) msg;
3491   stringStream info_stream;
3492 
3493   // Name and class hierarchy info
3494   info_stream.print(&quot;%s&quot;, external_name());
3495 
3496   // Source
3497   if (cfs != NULL) {
3498     if (cfs-&gt;source() != NULL) {
3499       if (module_name != NULL) {
<span class="line-modified">3500         // When the boot loader created the stream, it didn&#39;t know the module name</span>
<span class="line-added">3501         // yet. Let&#39;s format it now.</span>
<span class="line-added">3502         if (cfs-&gt;from_boot_loader_modules_image()) {</span>
3503           info_stream.print(&quot; source: jrt:/%s&quot;, module_name);
3504         } else {
3505           info_stream.print(&quot; source: %s&quot;, cfs-&gt;source());
3506         }
3507       } else {
3508         info_stream.print(&quot; source: %s&quot;, cfs-&gt;source());
3509       }
3510     } else if (loader_data == ClassLoaderData::the_null_class_loader_data()) {
3511       Thread* THREAD = Thread::current();
3512       Klass* caller =
3513             THREAD-&gt;is_Java_thread()
3514                 ? ((JavaThread*)THREAD)-&gt;security_get_caller_class(1)
3515                 : NULL;
3516       // caller can be NULL, for example, during a JVMTI VM_Init hook
3517       if (caller != NULL) {
3518         info_stream.print(&quot; source: instance of %s&quot;, caller-&gt;external_name());
3519       } else {
3520         // source is unknown
3521       }
3522     } else {
3523       oop class_loader = loader_data-&gt;class_loader();
3524       info_stream.print(&quot; source: %s&quot;, class_loader-&gt;klass()-&gt;external_name());
3525     }
3526   } else {
<span class="line-modified">3527     assert(this-&gt;is_shared(), &quot;must be&quot;);</span>
<span class="line-added">3528     if (MetaspaceShared::is_shared_dynamic((void*)this)) {</span>
<span class="line-added">3529       info_stream.print(&quot; source: shared objects file (top)&quot;);</span>
<span class="line-added">3530     } else {</span>
<span class="line-added">3531       info_stream.print(&quot; source: shared objects file&quot;);</span>
<span class="line-added">3532     }</span>
3533   }
3534 
3535   msg.info(&quot;%s&quot;, info_stream.as_string());
3536 
3537   if (log_is_enabled(Debug, class, load)) {
3538     stringStream debug_stream;
3539 
3540     // Class hierarchy info
3541     debug_stream.print(&quot; klass: &quot; INTPTR_FORMAT &quot; super: &quot; INTPTR_FORMAT,
3542                        p2i(this),  p2i(superklass()));
3543 
3544     // Interfaces
3545     if (local_interfaces() != NULL &amp;&amp; local_interfaces()-&gt;length() &gt; 0) {
3546       debug_stream.print(&quot; interfaces:&quot;);
3547       int length = local_interfaces()-&gt;length();
3548       for (int i = 0; i &lt; length; i++) {
3549         debug_stream.print(&quot; &quot; INTPTR_FORMAT,
3550                            p2i(InstanceKlass::cast(local_interfaces()-&gt;at(i))));
3551       }
3552     }
3553 
3554     // Class loader
3555     debug_stream.print(&quot; loader: [&quot;);
3556     loader_data-&gt;print_value_on(&amp;debug_stream);
3557     debug_stream.print(&quot;]&quot;);
3558 
3559     // Classfile checksum
3560     if (cfs) {
3561       debug_stream.print(&quot; bytes: %d checksum: %08x&quot;,
3562                          cfs-&gt;length(),
3563                          ClassLoader::crc32(0, (const char*)cfs-&gt;buffer(),
3564                          cfs-&gt;length()));
3565     }
3566 
3567     msg.debug(&quot;%s&quot;, debug_stream.as_string());
3568   }
3569 }
3570 











































3571 // Verification
3572 
3573 class VerifyFieldClosure: public BasicOopIterateClosure {
3574  protected:
3575   template &lt;class T&gt; void do_oop_work(T* p) {
3576     oop obj = RawAccess&lt;&gt;::oop_load(p);
3577     if (!oopDesc::is_oop_or_null(obj)) {
3578       tty-&gt;print_cr(&quot;Failed: &quot; PTR_FORMAT &quot; -&gt; &quot; PTR_FORMAT, p2i(p), p2i(obj));
3579       Universe::print_on(tty);
3580       guarantee(false, &quot;boom&quot;);
3581     }
3582   }
3583  public:
3584   virtual void do_oop(oop* p)       { VerifyFieldClosure::do_oop_work(p); }
3585   virtual void do_oop(narrowOop* p) { VerifyFieldClosure::do_oop_work(p); }
3586 };
3587 
3588 void InstanceKlass::verify_on(outputStream* st) {
3589 #ifndef PRODUCT
3590   // Avoid redundant verifies, this really should be in product.
</pre>
<hr />
<pre>
3642   }
3643 
3644   // Verify methods
3645   if (methods() != NULL) {
3646     Array&lt;Method*&gt;* methods = this-&gt;methods();
3647     for (int j = 0; j &lt; methods-&gt;length(); j++) {
3648       guarantee(methods-&gt;at(j)-&gt;is_method(), &quot;non-method in methods array&quot;);
3649     }
3650     for (int j = 0; j &lt; methods-&gt;length() - 1; j++) {
3651       Method* m1 = methods-&gt;at(j);
3652       Method* m2 = methods-&gt;at(j + 1);
3653       guarantee(m1-&gt;name()-&gt;fast_compare(m2-&gt;name()) &lt;= 0, &quot;methods not sorted correctly&quot;);
3654     }
3655   }
3656 
3657   // Verify method ordering
3658   if (method_ordering() != NULL) {
3659     Array&lt;int&gt;* method_ordering = this-&gt;method_ordering();
3660     int length = method_ordering-&gt;length();
3661     if (JvmtiExport::can_maintain_original_method_order() ||
<span class="line-modified">3662         ((UseSharedSpaces || Arguments::is_dumping_archive()) &amp;&amp; length != 0)) {</span>
3663       guarantee(length == methods()-&gt;length(), &quot;invalid method ordering length&quot;);
3664       jlong sum = 0;
3665       for (int j = 0; j &lt; length; j++) {
3666         int original_index = method_ordering-&gt;at(j);
3667         guarantee(original_index &gt;= 0, &quot;invalid method ordering index&quot;);
3668         guarantee(original_index &lt; length, &quot;invalid method ordering index&quot;);
3669         sum += original_index;
3670       }
3671       // Verify sum of indices 0,1,...,length-1
3672       guarantee(sum == ((jlong)length*(length-1))/2, &quot;invalid method ordering sum&quot;);
3673     } else {
3674       guarantee(length == 0, &quot;invalid method ordering length&quot;);
3675     }
3676   }
3677 
3678   // Verify default methods
3679   if (default_methods() != NULL) {
3680     Array&lt;Method*&gt;* methods = this-&gt;default_methods();
3681     for (int j = 0; j &lt; methods-&gt;length(); j++) {
3682       guarantee(methods-&gt;at(j)-&gt;is_method(), &quot;non-method in methods array&quot;);
</pre>
<hr />
<pre>
3750 
3751   JNIid* current = this;
3752   while (current != NULL) {
3753     guarantee(current-&gt;holder() == holder, &quot;Invalid klass in JNIid&quot;);
3754 #ifdef ASSERT
3755     int o = current-&gt;offset();
3756     if (current-&gt;is_static_field_id()) {
3757       guarantee(o &gt;= first_field_offset  &amp;&amp; o &lt; end_field_offset,  &quot;Invalid static field offset in JNIid&quot;);
3758     }
3759 #endif
3760     current = current-&gt;next();
3761   }
3762 }
3763 
3764 void InstanceKlass::set_init_state(ClassState state) {
3765 #ifdef ASSERT
3766   bool good_state = is_shared() ? (_init_state &lt;= state)
3767                                                : (_init_state &lt; state);
3768   assert(good_state || state == allocated, &quot;illegal state transition&quot;);
3769 #endif
<span class="line-added">3770   assert(_init_thread == NULL, &quot;should be cleared before state change&quot;);</span>
3771   _init_state = (u1)state;
3772 }
3773 
3774 #if INCLUDE_JVMTI
3775 
3776 // RedefineClasses() support for previous versions
3777 
3778 // Globally, there is at least one previous version of a class to walk
3779 // during class unloading, which is saved because old methods in the class
3780 // are still running.   Otherwise the previous version list is cleaned up.
3781 bool InstanceKlass::_has_previous_versions = false;
3782 
3783 // Returns true if there are previous versions of a class for class
3784 // unloading only. Also resets the flag to false. purge_previous_version
3785 // will set the flag to true if there are any left, i.e., if there&#39;s any
3786 // work to do for next time. This is to avoid the expensive code cache
3787 // walk in CLDG::clean_deallocate_lists().
3788 bool InstanceKlass::has_previous_versions_and_reset() {
3789   bool ret = _has_previous_versions;
3790   log_trace(redefine, class, iklass, purge)(&quot;Class unloading: has_previous_versions = %s&quot;,
</pre>
</td>
</tr>
</table>
<center><a href="fieldInfo.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="../prims/jvm.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
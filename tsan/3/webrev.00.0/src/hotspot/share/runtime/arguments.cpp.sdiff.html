<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/runtime/arguments.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="../prims/unsafe.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="globals.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/runtime/arguments.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 1997, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include &quot;precompiled.hpp&quot;
  26 #include &quot;jvm.h&quot;
  27 #include &quot;classfile/classLoader.hpp&quot;
  28 #include &quot;classfile/javaAssertions.hpp&quot;
  29 #include &quot;classfile/moduleEntry.hpp&quot;
  30 #include &quot;classfile/stringTable.hpp&quot;
  31 #include &quot;classfile/symbolTable.hpp&quot;
<span class="line-removed">  32 #include &quot;gc/shared/collectorPolicy.hpp&quot;</span>
  33 #include &quot;gc/shared/gcArguments.hpp&quot;
  34 #include &quot;gc/shared/gcConfig.hpp&quot;
  35 #include &quot;logging/log.hpp&quot;
  36 #include &quot;logging/logConfiguration.hpp&quot;
  37 #include &quot;logging/logStream.hpp&quot;
  38 #include &quot;logging/logTag.hpp&quot;
  39 #include &quot;memory/allocation.inline.hpp&quot;
<span class="line-modified">  40 #include &quot;memory/universe.hpp&quot;</span>
  41 #include &quot;oops/oop.inline.hpp&quot;
  42 #include &quot;prims/jvmtiExport.hpp&quot;
  43 #include &quot;runtime/arguments.hpp&quot;
  44 #include &quot;runtime/flags/jvmFlag.hpp&quot;
  45 #include &quot;runtime/flags/jvmFlagConstraintList.hpp&quot;
<span class="line-removed">  46 #include &quot;runtime/flags/jvmFlagWriteableList.hpp&quot;</span>
  47 #include &quot;runtime/flags/jvmFlagRangeList.hpp&quot;
  48 #include &quot;runtime/globals_extension.hpp&quot;
  49 #include &quot;runtime/java.hpp&quot;
  50 #include &quot;runtime/os.inline.hpp&quot;
  51 #include &quot;runtime/safepoint.hpp&quot;
  52 #include &quot;runtime/safepointMechanism.hpp&quot;
  53 #include &quot;runtime/vm_version.hpp&quot;
  54 #include &quot;services/management.hpp&quot;
  55 #include &quot;services/memTracker.hpp&quot;
  56 #include &quot;utilities/align.hpp&quot;
  57 #include &quot;utilities/defaultStream.hpp&quot;
  58 #include &quot;utilities/macros.hpp&quot;

  59 #include &quot;utilities/stringUtils.hpp&quot;
<span class="line-removed">  60 #if INCLUDE_JVMCI</span>
<span class="line-removed">  61 #include &quot;jvmci/jvmciRuntime.hpp&quot;</span>
<span class="line-removed">  62 #endif</span>
  63 #if INCLUDE_JFR
  64 #include &quot;jfr/jfr.hpp&quot;
  65 #endif
  66 
<span class="line-removed">  67 // Note: This is a special bug reporting site for the JVM</span>
<span class="line-removed">  68 #ifdef VENDOR_URL_VM_BUG</span>
<span class="line-removed">  69 # define DEFAULT_VENDOR_URL_BUG VENDOR_URL_VM_BUG</span>
<span class="line-removed">  70 #else</span>
<span class="line-removed">  71 # define DEFAULT_VENDOR_URL_BUG &quot;http://bugreport.java.com/bugreport/crash.jsp&quot;</span>
<span class="line-removed">  72 #endif</span>
  73 #define DEFAULT_JAVA_LAUNCHER  &quot;generic&quot;
  74 
  75 char*  Arguments::_jvm_flags_file               = NULL;
  76 char** Arguments::_jvm_flags_array              = NULL;
  77 int    Arguments::_num_jvm_flags                = 0;
  78 char** Arguments::_jvm_args_array               = NULL;
  79 int    Arguments::_num_jvm_args                 = 0;
  80 char*  Arguments::_java_command                 = NULL;
  81 SystemProperty* Arguments::_system_properties   = NULL;
  82 const char*  Arguments::_gc_log_filename        = NULL;
  83 size_t Arguments::_conservative_max_heap_alignment = 0;
<span class="line-removed">  84 size_t Arguments::_min_heap_size                = 0;</span>
  85 Arguments::Mode Arguments::_mode                = _mixed;
  86 bool   Arguments::_java_compiler                = false;
  87 bool   Arguments::_xdebug_mode                  = false;
<span class="line-modified">  88 const char*  Arguments::_java_vendor_url_bug    = DEFAULT_VENDOR_URL_BUG;</span>
  89 const char*  Arguments::_sun_java_launcher      = DEFAULT_JAVA_LAUNCHER;
<span class="line-removed">  90 int    Arguments::_sun_java_launcher_pid        = -1;</span>
  91 bool   Arguments::_sun_java_launcher_is_altjvm  = false;
  92 
  93 // These parameters are reset in method parse_vm_init_args()
  94 bool   Arguments::_AlwaysCompileLoopMethods     = AlwaysCompileLoopMethods;
  95 bool   Arguments::_UseOnStackReplacement        = UseOnStackReplacement;
  96 bool   Arguments::_BackgroundCompilation        = BackgroundCompilation;
  97 bool   Arguments::_ClipInlining                 = ClipInlining;
  98 intx   Arguments::_Tier3InvokeNotifyFreqLog     = Tier3InvokeNotifyFreqLog;
  99 intx   Arguments::_Tier4InvocationThreshold     = Tier4InvocationThreshold;

 100 
 101 bool   Arguments::_enable_preview               = false;
 102 
 103 char*  Arguments::SharedArchivePath             = NULL;

 104 
 105 AgentLibraryList Arguments::_libraryList;
 106 AgentLibraryList Arguments::_agentList;
 107 
 108 // These are not set by the JDK&#39;s built-in launchers, but they can be set by
 109 // programs that embed the JVM using JNI_CreateJavaVM. See comments around
 110 // JavaVMOption in jni.h.
 111 abort_hook_t     Arguments::_abort_hook         = NULL;
 112 exit_hook_t      Arguments::_exit_hook          = NULL;
 113 vfprintf_hook_t  Arguments::_vfprintf_hook      = NULL;
 114 
 115 
 116 SystemProperty *Arguments::_sun_boot_library_path = NULL;
 117 SystemProperty *Arguments::_java_library_path = NULL;
 118 SystemProperty *Arguments::_java_home = NULL;
 119 SystemProperty *Arguments::_java_class_path = NULL;
 120 SystemProperty *Arguments::_jdk_boot_class_path_append = NULL;
 121 SystemProperty *Arguments::_vm_info = NULL;
 122 
 123 GrowableArray&lt;ModulePatchPath*&gt; *Arguments::_patch_mod_prefix = NULL;
</pre>
<hr />
<pre>
 254     return false;
 255   }
 256 }
 257 
 258 // Return true if any of the strings in null-terminated array &#39;names&#39; matches.
 259 // If tail_allowed is true, then the tail must begin with a colon; otherwise,
 260 // the option must match exactly.
 261 static bool match_option(const JavaVMOption* option, const char** names, const char** tail,
 262   bool tail_allowed) {
 263   for (/* empty */; *names != NULL; ++names) {
 264   if (match_option(option, *names, tail)) {
 265       if (**tail == &#39;\0&#39; || (tail_allowed &amp;&amp; **tail == &#39;:&#39;)) {
 266         return true;
 267       }
 268     }
 269   }
 270   return false;
 271 }
 272 
 273 #if INCLUDE_JFR


 274 // return true on failure
 275 static bool match_jfr_option(const JavaVMOption** option) {
 276   assert((*option)-&gt;optionString != NULL, &quot;invariant&quot;);
 277   char* tail = NULL;
 278   if (match_option(*option, &quot;-XX:StartFlightRecording&quot;, (const char**)&amp;tail)) {

 279     return Jfr::on_start_flight_recording_option(option, tail);
 280   } else if (match_option(*option, &quot;-XX:FlightRecorderOptions&quot;, (const char**)&amp;tail)) {

 281     return Jfr::on_flight_recorder_option(option, tail);
 282   }
 283   return false;
 284 }




 285 #endif
 286 
 287 static void logOption(const char* opt) {
 288   if (PrintVMOptions) {
 289     jio_fprintf(defaultStream::output_stream(), &quot;VM option &#39;%s&#39;\n&quot;, opt);
 290   }
 291 }
 292 
 293 bool needs_module_property_warning = false;
 294 
 295 #define MODULE_PROPERTY_PREFIX &quot;jdk.module.&quot;
 296 #define MODULE_PROPERTY_PREFIX_LEN 11
 297 #define ADDEXPORTS &quot;addexports&quot;
 298 #define ADDEXPORTS_LEN 10
 299 #define ADDREADS &quot;addreads&quot;
 300 #define ADDREADS_LEN 8
 301 #define ADDOPENS &quot;addopens&quot;
 302 #define ADDOPENS_LEN 8
 303 #define PATCH &quot;patch&quot;
 304 #define PATCH_LEN 5
</pre>
<hr />
<pre>
 340 bool Arguments::is_internal_module_property(const char* property) {
 341   assert((strncmp(property, &quot;-D&quot;, 2) != 0), &quot;Unexpected leading -D&quot;);
 342   if  (strncmp(property, MODULE_PROPERTY_PREFIX, MODULE_PROPERTY_PREFIX_LEN) == 0) {
 343     const char* property_suffix = property + MODULE_PROPERTY_PREFIX_LEN;
 344     if (matches_property_suffix(property_suffix, ADDEXPORTS, ADDEXPORTS_LEN) ||
 345         matches_property_suffix(property_suffix, ADDREADS, ADDREADS_LEN) ||
 346         matches_property_suffix(property_suffix, ADDOPENS, ADDOPENS_LEN) ||
 347         matches_property_suffix(property_suffix, PATCH, PATCH_LEN) ||
 348         matches_property_suffix(property_suffix, ADDMODS, ADDMODS_LEN) ||
 349         matches_property_suffix(property_suffix, LIMITMODS, LIMITMODS_LEN) ||
 350         matches_property_suffix(property_suffix, PATH, PATH_LEN) ||
 351         matches_property_suffix(property_suffix, UPGRADE_PATH, UPGRADE_PATH_LEN)) {
 352       return true;
 353     }
 354   }
 355   return false;
 356 }
 357 
 358 // Process java launcher properties.
 359 void Arguments::process_sun_java_launcher_properties(JavaVMInitArgs* args) {
<span class="line-modified"> 360   // See if sun.java.launcher, sun.java.launcher.is_altjvm or</span>
<span class="line-removed"> 361   // sun.java.launcher.pid is defined.</span>
 362   // Must do this before setting up other system properties,
 363   // as some of them may depend on launcher type.
 364   for (int index = 0; index &lt; args-&gt;nOptions; index++) {
 365     const JavaVMOption* option = args-&gt;options + index;
 366     const char* tail;
 367 
 368     if (match_option(option, &quot;-Dsun.java.launcher=&quot;, &amp;tail)) {
 369       process_java_launcher_argument(tail, option-&gt;extraInfo);
 370       continue;
 371     }
 372     if (match_option(option, &quot;-Dsun.java.launcher.is_altjvm=&quot;, &amp;tail)) {
 373       if (strcmp(tail, &quot;true&quot;) == 0) {
 374         _sun_java_launcher_is_altjvm = true;
 375       }
 376       continue;
 377     }
<span class="line-removed"> 378     if (match_option(option, &quot;-Dsun.java.launcher.pid=&quot;, &amp;tail)) {</span>
<span class="line-removed"> 379       _sun_java_launcher_pid = atoi(tail);</span>
<span class="line-removed"> 380       continue;</span>
<span class="line-removed"> 381     }</span>
 382   }
 383 }
 384 
 385 // Initialize system properties key and value.
 386 void Arguments::init_system_properties() {
 387 
 388   // Set up _system_boot_class_path which is not a property but
 389   // relies heavily on argument processing and the jdk.boot.class.path.append
 390   // property. It is used to store the underlying system boot class path.
 391   _system_boot_class_path = new PathString(NULL);
 392 
 393   PropertyList_add(&amp;_system_properties, new SystemProperty(&quot;java.vm.specification.name&quot;,
 394                                                            &quot;Java Virtual Machine Specification&quot;,  false));
 395   PropertyList_add(&amp;_system_properties, new SystemProperty(&quot;java.vm.version&quot;, VM_Version::vm_release(),  false));
 396   PropertyList_add(&amp;_system_properties, new SystemProperty(&quot;java.vm.name&quot;, VM_Version::vm_name(),  false));
 397   PropertyList_add(&amp;_system_properties, new SystemProperty(&quot;jdk.debug&quot;, VM_Version::jdk_debug_level(),  false));
 398 
 399   // Initialize the vm.info now, but it will need updating after argument parsing.
 400   _vm_info = new SystemProperty(&quot;java.vm.info&quot;, VM_Version::vm_info_string(), true);
 401 
</pre>
<hr />
<pre>
 506 // &quot;deprecated_in&quot; or &quot;obsolete_in&quot; fields may be set to &quot;undefined&quot;, but not both.
 507 // When the JDK version reaches &#39;deprecated_in&#39; limit, the JVM will process this flag on
 508 // the command-line as usual, but will issue a warning.
 509 // When the JDK version reaches &#39;obsolete_in&#39; limit, the JVM will continue accepting this flag on
 510 // the command-line, while issuing a warning and ignoring the flag value.
 511 // Once the JDK version reaches &#39;expired_in&#39; limit, the JVM will flatly refuse to admit the
 512 // existence of the flag.
 513 //
 514 // MANUAL CLEANUP ON JDK VERSION UPDATES:
 515 // This table ensures that the handling of options will update automatically when the JDK
 516 // version is incremented, but the source code needs to be cleanup up manually:
 517 // - As &quot;deprecated&quot; options age into &quot;obsolete&quot; or &quot;expired&quot; options, the associated &quot;globals&quot;
 518 //   variable should be removed, as well as users of the variable.
 519 // - As &quot;deprecated&quot; options age into &quot;obsolete&quot; options, move the entry into the
 520 //   &quot;Obsolete Flags&quot; section of the table.
 521 // - All expired options should be removed from the table.
 522 static SpecialFlag const special_jvm_flags[] = {
 523   // -------------- Deprecated Flags --------------
 524   // --- Non-alias flags - sorted by obsolete_in then expired_in:
 525   { &quot;MaxGCMinorPauseMillis&quot;,        JDK_Version::jdk(8), JDK_Version::undefined(), JDK_Version::undefined() },
<span class="line-removed"> 526   { &quot;UseConcMarkSweepGC&quot;,           JDK_Version::jdk(9), JDK_Version::undefined(), JDK_Version::undefined() },</span>
 527   { &quot;MaxRAMFraction&quot;,               JDK_Version::jdk(10),  JDK_Version::undefined(), JDK_Version::undefined() },
 528   { &quot;MinRAMFraction&quot;,               JDK_Version::jdk(10),  JDK_Version::undefined(), JDK_Version::undefined() },
 529   { &quot;InitialRAMFraction&quot;,           JDK_Version::jdk(10),  JDK_Version::undefined(), JDK_Version::undefined() },
 530   { &quot;UseMembar&quot;,                    JDK_Version::jdk(10), JDK_Version::jdk(12), JDK_Version::undefined() },
<span class="line-modified"> 531   { &quot;CompilationPolicyChoice&quot;,      JDK_Version::jdk(13), JDK_Version::jdk(14), JDK_Version::undefined() },</span>
<span class="line-modified"> 532   { &quot;FailOverToOldVerifier&quot;,        JDK_Version::jdk(13), JDK_Version::jdk(14), JDK_Version::undefined() },</span>
<span class="line-modified"> 533   { &quot;ThreadLocalHandshakes&quot;,        JDK_Version::jdk(13), JDK_Version::jdk(14), JDK_Version::jdk(15) },</span>


 534 
 535   // --- Deprecated alias flags (see also aliased_jvm_flags) - sorted by obsolete_in then expired_in:
 536   { &quot;DefaultMaxRAMFraction&quot;,        JDK_Version::jdk(8),  JDK_Version::undefined(), JDK_Version::undefined() },
 537   { &quot;CreateMinidumpOnCrash&quot;,        JDK_Version::jdk(9),  JDK_Version::undefined(), JDK_Version::undefined() },
 538   { &quot;TLABStats&quot;,                    JDK_Version::jdk(12), JDK_Version::undefined(), JDK_Version::undefined() },
 539 
 540   // -------------- Obsolete Flags - sorted by expired_in --------------
 541   { &quot;PermSize&quot;,                      JDK_Version::undefined(), JDK_Version::jdk(8),  JDK_Version::undefined() },
 542   { &quot;MaxPermSize&quot;,                   JDK_Version::undefined(), JDK_Version::jdk(8),  JDK_Version::undefined() },
 543   { &quot;SharedReadWriteSize&quot;,           JDK_Version::undefined(), JDK_Version::jdk(10), JDK_Version::undefined() },
 544   { &quot;SharedReadOnlySize&quot;,            JDK_Version::undefined(), JDK_Version::jdk(10), JDK_Version::undefined() },
 545   { &quot;SharedMiscDataSize&quot;,            JDK_Version::undefined(), JDK_Version::jdk(10), JDK_Version::undefined() },
 546   { &quot;SharedMiscCodeSize&quot;,            JDK_Version::undefined(), JDK_Version::jdk(10), JDK_Version::undefined() },
<span class="line-modified"> 547   { &quot;ProfilerPrintByteCodeStatistics&quot;, JDK_Version::undefined(), JDK_Version::jdk(13), JDK_Version::jdk(14) },</span>
<span class="line-modified"> 548   { &quot;ProfilerRecordPC&quot;,              JDK_Version::undefined(), JDK_Version::jdk(13), JDK_Version::jdk(14) },</span>
<span class="line-modified"> 549   { &quot;ProfileVM&quot;,                     JDK_Version::undefined(), JDK_Version::jdk(13), JDK_Version::jdk(14) },</span>
<span class="line-modified"> 550   { &quot;ProfileIntervals&quot;,              JDK_Version::undefined(), JDK_Version::jdk(13), JDK_Version::jdk(14) },</span>
<span class="line-modified"> 551   { &quot;ProfileIntervalsTicks&quot;,         JDK_Version::undefined(), JDK_Version::jdk(13), JDK_Version::jdk(14) },</span>
<span class="line-modified"> 552   { &quot;ProfilerCheckIntervals&quot;,        JDK_Version::undefined(), JDK_Version::jdk(13), JDK_Version::jdk(14) },</span>
<span class="line-modified"> 553   { &quot;ProfilerNumberOfInterpretedMethods&quot;, JDK_Version::undefined(), JDK_Version::jdk(13), JDK_Version::jdk(14) },</span>
<span class="line-removed"> 554   { &quot;ProfilerNumberOfCompiledMethods&quot;, JDK_Version::undefined(), JDK_Version::jdk(13), JDK_Version::jdk(14) },</span>
<span class="line-removed"> 555   { &quot;ProfilerNumberOfStubMethods&quot;,   JDK_Version::undefined(), JDK_Version::jdk(13), JDK_Version::jdk(14) },</span>
<span class="line-removed"> 556   { &quot;ProfilerNumberOfRuntimeStubNodes&quot;, JDK_Version::undefined(), JDK_Version::jdk(13), JDK_Version::jdk(14) },</span>
<span class="line-removed"> 557   { &quot;UseImplicitStableValues&quot;,       JDK_Version::undefined(), JDK_Version::jdk(13), JDK_Version::jdk(14) },</span>
 558 
 559 #ifdef TEST_VERIFY_SPECIAL_JVM_FLAGS
 560   // These entries will generate build errors.  Their purpose is to test the macros.
 561   { &quot;dep &gt; obs&quot;,                    JDK_Version::jdk(9), JDK_Version::jdk(8), JDK_Version::undefined() },
 562   { &quot;dep &gt; exp &quot;,                   JDK_Version::jdk(9), JDK_Version::undefined(), JDK_Version::jdk(8) },
 563   { &quot;obs &gt; exp &quot;,                   JDK_Version::undefined(), JDK_Version::jdk(9), JDK_Version::jdk(8) },

 564   { &quot;not deprecated or obsolete&quot;,   JDK_Version::undefined(), JDK_Version::undefined(), JDK_Version::jdk(9) },
 565   { &quot;dup option&quot;,                   JDK_Version::jdk(9), JDK_Version::undefined(), JDK_Version::undefined() },
 566   { &quot;dup option&quot;,                   JDK_Version::jdk(9), JDK_Version::undefined(), JDK_Version::undefined() },
 567 #endif
 568 
 569   { NULL, JDK_Version(0), JDK_Version(0) }
 570 };
 571 
 572 // Flags that are aliases for other flags.
 573 typedef struct {
 574   const char* alias_name;
 575   const char* real_name;
 576 } AliasedFlag;
 577 
 578 static AliasedFlag const aliased_jvm_flags[] = {
 579   { &quot;DefaultMaxRAMFraction&quot;,    &quot;MaxRAMFraction&quot;    },
 580   { &quot;CreateMinidumpOnCrash&quot;,    &quot;CreateCoredumpOnCrash&quot; },
 581   { NULL, NULL}
 582 };
 583 
 584 // NOTE: A compatibility request will be necessary for each alias to be removed.
 585 static AliasedLoggingFlag const aliased_logging_flags[] = {
 586   { &quot;PrintCompressedOopsMode&quot;,   LogLevel::Info,  true,  LOG_TAGS(gc, heap, coops) },
 587   { &quot;PrintSharedSpaces&quot;,         LogLevel::Info,  true,  LOG_TAGS(cds) },
 588   { &quot;TraceBiasedLocking&quot;,        LogLevel::Info,  true,  LOG_TAGS(biasedlocking) },
 589   { &quot;TraceClassLoading&quot;,         LogLevel::Info,  true,  LOG_TAGS(class, load) },
 590   { &quot;TraceClassLoadingPreorder&quot;, LogLevel::Debug, true,  LOG_TAGS(class, preorder) },
 591   { &quot;TraceClassPaths&quot;,           LogLevel::Info,  true,  LOG_TAGS(class, path) },
 592   { &quot;TraceClassResolution&quot;,      LogLevel::Debug, true,  LOG_TAGS(class, resolve) },
 593   { &quot;TraceClassUnloading&quot;,       LogLevel::Info,  true,  LOG_TAGS(class, unload) },
 594   { &quot;TraceExceptions&quot;,           LogLevel::Info,  true,  LOG_TAGS(exceptions) },
 595   { &quot;TraceLoaderConstraints&quot;,    LogLevel::Info,  true,  LOG_TAGS(class, loader, constraints) },
 596   { &quot;TraceMonitorInflation&quot;,     LogLevel::Trace, true,  LOG_TAGS(monitorinflation) },
 597   { &quot;TraceSafepointCleanupTime&quot;, LogLevel::Info,  true,  LOG_TAGS(safepoint, cleanup) },
 598   { &quot;TraceJVMTIObjectTagging&quot;,   LogLevel::Debug, true,  LOG_TAGS(jvmti, objecttagging) },
 599   { &quot;TraceRedefineClasses&quot;,      LogLevel::Info,  false, LOG_TAGS(redefine, class) },

 600   { NULL,                        LogLevel::Off,   false, LOG_TAGS(_NO_TAG) }
 601 };
 602 
 603 #ifndef PRODUCT
 604 // These options are removed in jdk9. Remove this code for jdk10.
 605 static AliasedFlag const removed_develop_logging_flags[] = {
 606   { &quot;TraceClassInitialization&quot;,   &quot;-Xlog:class+init&quot; },
 607   { &quot;TraceClassLoaderData&quot;,       &quot;-Xlog:class+loader+data&quot; },
 608   { &quot;TraceDefaultMethods&quot;,        &quot;-Xlog:defaultmethods=debug&quot; },
 609   { &quot;TraceItables&quot;,               &quot;-Xlog:itables=debug&quot; },
 610   { &quot;TraceMonitorMismatch&quot;,       &quot;-Xlog:monitormismatch=info&quot; },
 611   { &quot;TraceSafepoint&quot;,             &quot;-Xlog:safepoint=debug&quot; },
 612   { &quot;TraceStartupTime&quot;,           &quot;-Xlog:startuptime&quot; },
 613   { &quot;TraceVMOperation&quot;,           &quot;-Xlog:vmoperation=debug&quot; },
 614   { &quot;PrintVtables&quot;,               &quot;-Xlog:vtables=debug&quot; },
 615   { &quot;VerboseVerification&quot;,        &quot;-Xlog:verification&quot; },
 616   { NULL, NULL }
 617 };
 618 #endif //PRODUCT
 619 
 620 // Return true if &quot;v&quot; is less than &quot;other&quot;, where &quot;other&quot; may be &quot;undefined&quot;.
 621 static bool version_less_than(JDK_Version v, JDK_Version other) {
 622   assert(!v.is_undefined(), &quot;must be defined&quot;);
 623   if (!other.is_undefined() &amp;&amp; v.compare(other) &gt;= 0) {
 624     return false;
 625   } else {
 626     return true;
 627   }
 628 }
 629 
<span class="line-removed"> 630 extern bool lookup_special_flag_ext(const char *flag_name, SpecialFlag&amp; flag);</span>
<span class="line-removed"> 631 </span>
<span class="line-removed"> 632 static bool lookup_special_flag(const char *flag_name, SpecialFlag&amp; flag) {</span>
<span class="line-removed"> 633   // Allow extensions to have priority</span>
<span class="line-removed"> 634   if (lookup_special_flag_ext(flag_name, flag)) {</span>
<span class="line-removed"> 635     return true;</span>
<span class="line-removed"> 636   }</span>
 637 
 638   for (size_t i = 0; special_jvm_flags[i].name != NULL; i++) {
 639     if ((strcmp(special_jvm_flags[i].name, flag_name) == 0)) {
 640       flag = special_jvm_flags[i];
 641       return true;
 642     }
 643   }
 644   return false;
 645 }
 646 
 647 bool Arguments::is_obsolete_flag(const char *flag_name, JDK_Version* version) {
 648   assert(version != NULL, &quot;Must provide a version buffer&quot;);
 649   SpecialFlag flag;
 650   if (lookup_special_flag(flag_name, flag)) {
 651     if (!flag.obsolete_in.is_undefined()) {
 652       if (!version_less_than(JDK_Version::current(), flag.obsolete_in)) {
 653         *version = flag.obsolete_in;












 654         return true;
 655       }
 656     }
 657   }
 658   return false;
 659 }
 660 
 661 int Arguments::is_deprecated_flag(const char *flag_name, JDK_Version* version) {
 662   assert(version != NULL, &quot;Must provide a version buffer&quot;);
 663   SpecialFlag flag;
 664   if (lookup_special_flag(flag_name, flag)) {
 665     if (!flag.deprecated_in.is_undefined()) {
 666       if (version_less_than(JDK_Version::current(), flag.obsolete_in) &amp;&amp;
 667           version_less_than(JDK_Version::current(), flag.expired_in)) {
 668         *version = flag.deprecated_in;
 669         return 1;
 670       } else {
 671         return -1;
 672       }
 673     }
</pre>
<hr />
<pre>
 694         return flag_status.real_name;
 695     }
 696   }
 697   return flag_name;
 698 }
 699 
 700 #ifdef ASSERT
 701 static bool lookup_special_flag(const char *flag_name, size_t skip_index) {
 702   for (size_t i = 0; special_jvm_flags[i].name != NULL; i++) {
 703     if ((i != skip_index) &amp;&amp; (strcmp(special_jvm_flags[i].name, flag_name) == 0)) {
 704       return true;
 705     }
 706   }
 707   return false;
 708 }
 709 
 710 // Verifies the correctness of the entries in the special_jvm_flags table.
 711 // If there is a semantic error (i.e. a bug in the table) such as the obsoletion
 712 // version being earlier than the deprecation version, then a warning is issued
 713 // and verification fails - by returning false. If it is detected that the table
<span class="line-modified"> 714 // is out of date, with respect to the current version, then a warning is issued</span>
<span class="line-modified"> 715 // but verification does not fail. This allows the VM to operate when the version</span>
<span class="line-modified"> 716 // is first updated, without needing to update all the impacted flags at the</span>
<span class="line-modified"> 717 // same time.</span>
<span class="line-modified"> 718 static bool verify_special_jvm_flags() {</span>











 719   bool success = true;
 720   for (size_t i = 0; special_jvm_flags[i].name != NULL; i++) {
 721     const SpecialFlag&amp; flag = special_jvm_flags[i];
 722     if (lookup_special_flag(flag.name, i)) {
 723       warning(&quot;Duplicate special flag declaration \&quot;%s\&quot;&quot;, flag.name);
 724       success = false;
 725     }
 726     if (flag.deprecated_in.is_undefined() &amp;&amp;
 727         flag.obsolete_in.is_undefined()) {
 728       warning(&quot;Special flag entry \&quot;%s\&quot; must declare version deprecated and/or obsoleted in.&quot;, flag.name);
 729       success = false;
 730     }
 731 
 732     if (!flag.deprecated_in.is_undefined()) {
 733       if (!version_less_than(flag.deprecated_in, flag.obsolete_in)) {
 734         warning(&quot;Special flag entry \&quot;%s\&quot; must be deprecated before obsoleted.&quot;, flag.name);
 735         success = false;
 736       }
 737 
 738       if (!version_less_than(flag.deprecated_in, flag.expired_in)) {
 739         warning(&quot;Special flag entry \&quot;%s\&quot; must be deprecated before expired.&quot;, flag.name);
 740         success = false;
 741       }
 742     }
 743 
 744     if (!flag.obsolete_in.is_undefined()) {
 745       if (!version_less_than(flag.obsolete_in, flag.expired_in)) {
 746         warning(&quot;Special flag entry \&quot;%s\&quot; must be obsoleted before expired.&quot;, flag.name);
 747         success = false;
 748       }
 749 
 750       // if flag has become obsolete it should not have a &quot;globals&quot; flag defined anymore.
<span class="line-modified"> 751       if (!version_less_than(JDK_Version::current(), flag.obsolete_in)) {</span>
<span class="line-modified"> 752         if (JVMFlag::find_flag(flag.name) != NULL) {</span>
<span class="line-modified"> 753           // Temporarily disable the warning: 8196739</span>
<span class="line-modified"> 754           // warning(&quot;Global variable for obsolete special flag entry \&quot;%s\&quot; should be removed&quot;, flag.name);</span>

 755         }
 756       }




 757     }
 758 
 759     if (!flag.expired_in.is_undefined()) {
 760       // if flag has become expired it should not have a &quot;globals&quot; flag defined anymore.
<span class="line-modified"> 761       if (!version_less_than(JDK_Version::current(), flag.expired_in)) {</span>
<span class="line-modified"> 762         if (JVMFlag::find_flag(flag.name) != NULL) {</span>
<span class="line-modified"> 763           // Temporarily disable the warning: 8196739</span>
<span class="line-modified"> 764           // warning(&quot;Global variable for expired flag entry \&quot;%s\&quot; should be removed&quot;, flag.name);</span>

 765         }
 766       }
 767     }
<span class="line-removed"> 768 </span>
 769   }
 770   return success;
 771 }
 772 #endif
 773 
 774 // Parses a size specification string.
 775 bool Arguments::atojulong(const char *s, julong* result) {
 776   julong n = 0;
 777 
 778   // First char must be a digit. Don&#39;t allow negative numbers or leading spaces.
 779   if (!isdigit(*s)) {
 780     return false;
 781   }
 782 
 783   bool is_hex = (s[0] == &#39;0&#39; &amp;&amp; (s[1] == &#39;x&#39; || s[1] == &#39;X&#39;));
 784   char* remainder;
 785   errno = 0;
 786   n = strtoull(s, &amp;remainder, (is_hex ? 16 : 10));
 787   if (errno != 0) {
 788     return false;
</pre>
<hr />
<pre>
 826 }
 827 
 828 // Describe an argument out of range error
 829 void Arguments::describe_range_error(ArgsRange errcode) {
 830   switch(errcode) {
 831   case arg_too_big:
 832     jio_fprintf(defaultStream::error_stream(),
 833                 &quot;The specified size exceeds the maximum &quot;
 834                 &quot;representable size.\n&quot;);
 835     break;
 836   case arg_too_small:
 837   case arg_unreadable:
 838   case arg_in_range:
 839     // do nothing for now
 840     break;
 841   default:
 842     ShouldNotReachHere();
 843   }
 844 }
 845 
<span class="line-modified"> 846 static bool set_bool_flag(const char* name, bool value, JVMFlag::Flags origin) {</span>
<span class="line-modified"> 847   if (JVMFlag::boolAtPut(name, &amp;value, origin) == JVMFlag::SUCCESS) {</span>
 848     return true;
 849   } else {
 850     return false;
 851   }
 852 }
 853 
<span class="line-modified"> 854 static bool set_fp_numeric_flag(const char* name, char* value, JVMFlag::Flags origin) {</span>
 855   char* end;
 856   errno = 0;
 857   double v = strtod(value, &amp;end);
 858   if ((errno != 0) || (*end != 0)) {
 859     return false;
 860   }
 861 
<span class="line-modified"> 862   if (JVMFlag::doubleAtPut(name, &amp;v, origin) == JVMFlag::SUCCESS) {</span>
 863     return true;
 864   }
 865   return false;
 866 }
 867 
<span class="line-modified"> 868 static bool set_numeric_flag(const char* name, char* value, JVMFlag::Flags origin) {</span>
 869   julong v;
 870   int int_v;
 871   intx intx_v;
 872   bool is_neg = false;
<span class="line-modified"> 873   JVMFlag* result = JVMFlag::find_flag(name, strlen(name));</span>
<span class="line-removed"> 874 </span>
 875   if (result == NULL) {
 876     return false;
 877   }
 878 
 879   // Check the sign first since atojulong() parses only unsigned values.
 880   if (*value == &#39;-&#39;) {
<span class="line-modified"> 881     if (!result-&gt;is_intx() &amp;&amp; !result-&gt;is_int()) {</span>
 882       return false;
 883     }
 884     value++;
 885     is_neg = true;
 886   }
 887   if (!Arguments::atojulong(value, &amp;v)) {
 888     return false;
 889   }
<span class="line-modified"> 890   if (result-&gt;is_int()) {</span>
 891     int_v = (int) v;
 892     if (is_neg) {
 893       int_v = -int_v;
 894     }
<span class="line-modified"> 895     return JVMFlag::intAtPut(result, &amp;int_v, origin) == JVMFlag::SUCCESS;</span>
<span class="line-modified"> 896   } else if (result-&gt;is_uint()) {</span>
 897     uint uint_v = (uint) v;
<span class="line-modified"> 898     return JVMFlag::uintAtPut(result, &amp;uint_v, origin) == JVMFlag::SUCCESS;</span>
<span class="line-modified"> 899   } else if (result-&gt;is_intx()) {</span>
 900     intx_v = (intx) v;
 901     if (is_neg) {
 902       intx_v = -intx_v;
 903     }
<span class="line-modified"> 904     return JVMFlag::intxAtPut(result, &amp;intx_v, origin) == JVMFlag::SUCCESS;</span>
<span class="line-modified"> 905   } else if (result-&gt;is_uintx()) {</span>
 906     uintx uintx_v = (uintx) v;
<span class="line-modified"> 907     return JVMFlag::uintxAtPut(result, &amp;uintx_v, origin) == JVMFlag::SUCCESS;</span>
<span class="line-modified"> 908   } else if (result-&gt;is_uint64_t()) {</span>
 909     uint64_t uint64_t_v = (uint64_t) v;
<span class="line-modified"> 910     return JVMFlag::uint64_tAtPut(result, &amp;uint64_t_v, origin) == JVMFlag::SUCCESS;</span>
<span class="line-modified"> 911   } else if (result-&gt;is_size_t()) {</span>
 912     size_t size_t_v = (size_t) v;
<span class="line-modified"> 913     return JVMFlag::size_tAtPut(result, &amp;size_t_v, origin) == JVMFlag::SUCCESS;</span>
<span class="line-modified"> 914   } else if (result-&gt;is_double()) {</span>
 915     double double_v = (double) v;
<span class="line-modified"> 916     return JVMFlag::doubleAtPut(result, &amp;double_v, origin) == JVMFlag::SUCCESS;</span>
 917   } else {
 918     return false;
 919   }
 920 }
 921 
<span class="line-modified"> 922 static bool set_string_flag(const char* name, const char* value, JVMFlag::Flags origin) {</span>
<span class="line-modified"> 923   if (JVMFlag::ccstrAtPut(name, &amp;value, origin) != JVMFlag::SUCCESS) return false;</span>
 924   // Contract:  JVMFlag always returns a pointer that needs freeing.
 925   FREE_C_HEAP_ARRAY(char, value);
 926   return true;
 927 }
 928 
<span class="line-modified"> 929 static bool append_to_string_flag(const char* name, const char* new_value, JVMFlag::Flags origin) {</span>
 930   const char* old_value = &quot;&quot;;
<span class="line-modified"> 931   if (JVMFlag::ccstrAt(name, &amp;old_value) != JVMFlag::SUCCESS) return false;</span>
 932   size_t old_len = old_value != NULL ? strlen(old_value) : 0;
 933   size_t new_len = strlen(new_value);
 934   const char* value;
 935   char* free_this_too = NULL;
 936   if (old_len == 0) {
 937     value = new_value;
 938   } else if (new_len == 0) {
 939     value = old_value;
 940   } else {
 941      size_t length = old_len + 1 + new_len + 1;
 942      char* buf = NEW_C_HEAP_ARRAY(char, length, mtArguments);
 943     // each new setting adds another LINE to the switch:
 944     jio_snprintf(buf, length, &quot;%s\n%s&quot;, old_value, new_value);
 945     value = buf;
 946     free_this_too = buf;
 947   }
<span class="line-modified"> 948   (void) JVMFlag::ccstrAtPut(name, &amp;value, origin);</span>
 949   // JVMFlag always returns a pointer that needs freeing.
 950   FREE_C_HEAP_ARRAY(char, value);
<span class="line-modified"> 951   if (free_this_too != NULL) {</span>
<span class="line-modified"> 952     // JVMFlag made its own copy, so I must delete my own temp. buffer.</span>
<span class="line-removed"> 953     FREE_C_HEAP_ARRAY(char, free_this_too);</span>
<span class="line-removed"> 954   }</span>
 955   return true;
 956 }
 957 
 958 const char* Arguments::handle_aliases_and_deprecation(const char* arg, bool warn) {
 959   const char* real_name = real_flag_name(arg);
 960   JDK_Version since = JDK_Version();
 961   switch (is_deprecated_flag(arg, &amp;since)) {
<span class="line-modified"> 962     case -1:</span>
<span class="line-modified"> 963       return NULL; // obsolete or expired, don&#39;t process normally</span>









 964     case 0:
 965       return real_name;
 966     case 1: {
 967       if (warn) {
 968         char version[256];
 969         since.to_string(version, sizeof(version));
 970         if (real_name != arg) {
 971           warning(&quot;Option %s was deprecated in version %s and will likely be removed in a future release. Use option %s instead.&quot;,
 972                   arg, version, real_name);
 973         } else {
 974           warning(&quot;Option %s was deprecated in version %s and will likely be removed in a future release.&quot;,
 975                   arg, version);
 976         }
 977       }
 978       return real_name;
 979     }
 980   }
 981   ShouldNotReachHere();
 982   return NULL;
 983 }
</pre>
<hr />
<pre>
1023 bool Arguments::parse_argument(const char* arg, JVMFlag::Flags origin) {
1024 
1025   // range of acceptable characters spelled out for portability reasons
1026 #define NAME_RANGE  &quot;[abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789_]&quot;
1027 #define BUFLEN 255
1028   char name[BUFLEN+1];
1029   char dummy;
1030   const char* real_name;
1031   bool warn_if_deprecated = true;
1032 
1033   if (sscanf(arg, &quot;-%&quot; XSTR(BUFLEN) NAME_RANGE &quot;%c&quot;, name, &amp;dummy) == 1) {
1034     AliasedLoggingFlag alf = catch_logging_aliases(name, false);
1035     if (alf.alias_name != NULL){
1036       LogConfiguration::configure_stdout(LogLevel::Off, alf.exactMatch, alf.tag0, alf.tag1, alf.tag2, alf.tag3, alf.tag4, alf.tag5);
1037       return true;
1038     }
1039     real_name = handle_aliases_and_deprecation(name, warn_if_deprecated);
1040     if (real_name == NULL) {
1041       return false;
1042     }
<span class="line-modified">1043     return set_bool_flag(real_name, false, origin);</span>

1044   }
1045   if (sscanf(arg, &quot;+%&quot; XSTR(BUFLEN) NAME_RANGE &quot;%c&quot;, name, &amp;dummy) == 1) {
1046     AliasedLoggingFlag alf = catch_logging_aliases(name, true);
1047     if (alf.alias_name != NULL){
1048       LogConfiguration::configure_stdout(alf.level, alf.exactMatch, alf.tag0, alf.tag1, alf.tag2, alf.tag3, alf.tag4, alf.tag5);
1049       return true;
1050     }
1051     real_name = handle_aliases_and_deprecation(name, warn_if_deprecated);
1052     if (real_name == NULL) {
1053       return false;
1054     }
<span class="line-modified">1055     return set_bool_flag(real_name, true, origin);</span>

1056   }
1057 
1058   char punct;
1059   if (sscanf(arg, &quot;%&quot; XSTR(BUFLEN) NAME_RANGE &quot;%c&quot;, name, &amp;punct) == 2 &amp;&amp; punct == &#39;=&#39;) {
1060     const char* value = strchr(arg, &#39;=&#39;) + 1;
<span class="line-removed">1061     JVMFlag* flag;</span>
1062 
1063     // this scanf pattern matches both strings (handled here) and numbers (handled later))
1064     AliasedLoggingFlag alf = catch_logging_aliases(name, true);
1065     if (alf.alias_name != NULL) {
1066       LogConfiguration::configure_stdout(alf.level, alf.exactMatch, alf.tag0, alf.tag1, alf.tag2, alf.tag3, alf.tag4, alf.tag5);
1067       return true;
1068     }
1069     real_name = handle_aliases_and_deprecation(name, warn_if_deprecated);
1070     if (real_name == NULL) {
1071       return false;
1072     }
<span class="line-modified">1073     flag = JVMFlag::find_flag(real_name);</span>
1074     if (flag != NULL &amp;&amp; flag-&gt;is_ccstr()) {
1075       if (flag-&gt;ccstr_accumulates()) {
<span class="line-modified">1076         return append_to_string_flag(real_name, value, origin);</span>
1077       } else {
1078         if (value[0] == &#39;\0&#39;) {
1079           value = NULL;
1080         }
<span class="line-modified">1081         return set_string_flag(real_name, value, origin);</span>
1082       }
1083     } else {
1084       warn_if_deprecated = false; // if arg is deprecated, we&#39;ve already done warning...
1085     }
1086   }
1087 
1088   if (sscanf(arg, &quot;%&quot; XSTR(BUFLEN) NAME_RANGE &quot;:%c&quot;, name, &amp;punct) == 2 &amp;&amp; punct == &#39;=&#39;) {
1089     const char* value = strchr(arg, &#39;=&#39;) + 1;
1090     // -XX:Foo:=xxx will reset the string flag to the given value.
1091     if (value[0] == &#39;\0&#39;) {
1092       value = NULL;
1093     }
1094     real_name = handle_aliases_and_deprecation(name, warn_if_deprecated);
1095     if (real_name == NULL) {
1096       return false;
1097     }
<span class="line-modified">1098     return set_string_flag(real_name, value, origin);</span>

1099   }
1100 
1101 #define SIGNED_FP_NUMBER_RANGE &quot;[-0123456789.eE+]&quot;
1102 #define SIGNED_NUMBER_RANGE    &quot;[-0123456789]&quot;
1103 #define        NUMBER_RANGE    &quot;[0123456789eE+-]&quot;
1104   char value[BUFLEN + 1];
1105   char value2[BUFLEN + 1];
1106   if (sscanf(arg, &quot;%&quot; XSTR(BUFLEN) NAME_RANGE &quot;=&quot; &quot;%&quot; XSTR(BUFLEN) SIGNED_NUMBER_RANGE &quot;.&quot; &quot;%&quot; XSTR(BUFLEN) NUMBER_RANGE &quot;%c&quot;, name, value, value2, &amp;dummy) == 3) {
1107     // Looks like a floating-point number -- try again with more lenient format string
1108     if (sscanf(arg, &quot;%&quot; XSTR(BUFLEN) NAME_RANGE &quot;=&quot; &quot;%&quot; XSTR(BUFLEN) SIGNED_FP_NUMBER_RANGE &quot;%c&quot;, name, value, &amp;dummy) == 2) {
1109       real_name = handle_aliases_and_deprecation(name, warn_if_deprecated);
1110       if (real_name == NULL) {
1111         return false;
1112       }
<span class="line-modified">1113       return set_fp_numeric_flag(real_name, value, origin);</span>

1114     }
1115   }
1116 
1117 #define VALUE_RANGE &quot;[-kmgtxKMGTX0123456789abcdefABCDEF]&quot;
1118   if (sscanf(arg, &quot;%&quot; XSTR(BUFLEN) NAME_RANGE &quot;=&quot; &quot;%&quot; XSTR(BUFLEN) VALUE_RANGE &quot;%c&quot;, name, value, &amp;dummy) == 2) {
1119     real_name = handle_aliases_and_deprecation(name, warn_if_deprecated);
1120     if (real_name == NULL) {
1121       return false;
1122     }
<span class="line-modified">1123     return set_numeric_flag(real_name, value, origin);</span>

1124   }
1125 
1126   return false;
1127 }
1128 
1129 void Arguments::add_string(char*** bldarray, int* count, const char* arg) {
1130   assert(bldarray != NULL, &quot;illegal argument&quot;);
1131 
1132   if (arg == NULL) {
1133     return;
1134   }
1135 
1136   int new_count = *count + 1;
1137 
1138   // expand the array and add arg to the last element
1139   if (*bldarray == NULL) {
1140     *bldarray = NEW_C_HEAP_ARRAY(char*, new_count, mtArguments);
1141   } else {
1142     *bldarray = REALLOC_C_HEAP_ARRAY(char*, *bldarray, new_count, mtArguments);
1143   }
</pre>
<hr />
<pre>
1259       char version[256];
1260       since.to_string(version, sizeof(version));
1261       warning(&quot;Ignoring option %s; support was removed in %s&quot;, stripped_argname, version);
1262       return true;
1263     }
1264 #ifndef PRODUCT
1265     else {
1266       const char* replacement;
1267       if ((replacement = removed_develop_logging_flag_name(stripped_argname)) != NULL){
1268         log_warning(arguments)(&quot;%s has been removed. Please use %s instead.&quot;,
1269                                stripped_argname,
1270                                replacement);
1271         return false;
1272       }
1273     }
1274 #endif //PRODUCT
1275   }
1276 
1277   // For locked flags, report a custom error message if available.
1278   // Otherwise, report the standard unrecognized VM option.
<span class="line-modified">1279   JVMFlag* found_flag = JVMFlag::find_flag((const char*)argname, arg_len, true, true);</span>
1280   if (found_flag != NULL) {
1281     char locked_message_buf[BUFLEN];
1282     JVMFlag::MsgType msg_type = found_flag-&gt;get_locked_message(locked_message_buf, BUFLEN);
1283     if (strlen(locked_message_buf) == 0) {
1284       if (found_flag-&gt;is_bool() &amp;&amp; !has_plus_minus) {
1285         jio_fprintf(defaultStream::error_stream(),
1286           &quot;Missing +/- setting for VM option &#39;%s&#39;\n&quot;, argname);
1287       } else if (!found_flag-&gt;is_bool() &amp;&amp; has_plus_minus) {
1288         jio_fprintf(defaultStream::error_stream(),
1289           &quot;Unexpected +/- setting in VM option &#39;%s&#39;\n&quot;, argname);
1290       } else {
1291         jio_fprintf(defaultStream::error_stream(),
1292           &quot;Improperly specified VM option &#39;%s&#39;\n&quot;, argname);
1293       }
1294     } else {
1295 #ifdef PRODUCT
1296       bool mismatched = ((msg_type == JVMFlag::NOTPRODUCT_FLAG_BUT_PRODUCT_BUILD) ||
1297                          (msg_type == JVMFlag::DEVELOPER_FLAG_BUT_PRODUCT_BUILD));
1298       if (ignore_unrecognized &amp;&amp; mismatched) {
1299         return true;
</pre>
<hr />
<pre>
1398   const char* value = &quot;&quot;;
1399 
1400   if (eq == NULL) {
1401     // property doesn&#39;t have a value, thus use passed string
1402     key = prop;
1403   } else {
1404     // property have a value, thus extract it and save to the
1405     // allocated string
1406     size_t key_len = eq - prop;
1407     char* tmp_key = AllocateHeap(key_len + 1, mtArguments);
1408 
1409     jio_snprintf(tmp_key, key_len + 1, &quot;%s&quot;, prop);
1410     key = tmp_key;
1411 
1412     value = &amp;prop[key_len + 1];
1413   }
1414 
1415   if (strcmp(key, &quot;java.compiler&quot;) == 0) {
1416     process_java_compiler_argument(value);
1417     // Record value in Arguments, but let it get passed to Java.
<span class="line-modified">1418   } else if (strcmp(key, &quot;sun.java.launcher.is_altjvm&quot;) == 0 ||</span>
<span class="line-modified">1419              strcmp(key, &quot;sun.java.launcher.pid&quot;) == 0) {</span>
<span class="line-modified">1420     // sun.java.launcher.is_altjvm and sun.java.launcher.pid property are</span>
<span class="line-removed">1421     // private and are processed in process_sun_java_launcher_properties();</span>
1422     // the sun.java.launcher property is passed on to the java application
1423   } else if (strcmp(key, &quot;sun.boot.library.path&quot;) == 0) {
1424     // append is true, writable is true, internal is false
1425     PropertyList_unique_add(&amp;_system_properties, key, value, AppendProperty,
1426                             WriteableProperty, ExternalProperty);
1427   } else {
1428     if (strcmp(key, &quot;sun.java.command&quot;) == 0) {
1429       char *old_java_command = _java_command;
1430       _java_command = os::strdup_check_oom(value, mtArguments);
1431       if (old_java_command != NULL) {
1432         os::free(old_java_command);
1433       }
1434     } else if (strcmp(key, &quot;java.vendor.url.bug&quot;) == 0) {





1435       const char* old_java_vendor_url_bug = _java_vendor_url_bug;
1436       // save it in _java_vendor_url_bug, so JVM fatal error handler can access
1437       // its value without going through the property list or making a Java call.
1438       _java_vendor_url_bug = os::strdup_check_oom(value, mtArguments);
<span class="line-modified">1439       if (old_java_vendor_url_bug != DEFAULT_VENDOR_URL_BUG) {</span>
<span class="line-removed">1440         assert(old_java_vendor_url_bug != NULL, &quot;_java_vendor_url_bug is NULL&quot;);</span>
1441         os::free((void *)old_java_vendor_url_bug);
1442       }
1443     }
1444 
1445     // Create new property and add at the end of the list
1446     PropertyList_unique_add(&amp;_system_properties, key, value, AddProperty, writeable, internal);
1447   }
1448 
1449   if (key != prop) {
1450     // SystemProperty copy passed value, thus free previously allocated
1451     // memory
1452     FreeHeap((void *)key);
1453   }
1454 
1455   return true;
1456 }
1457 
1458 #if INCLUDE_CDS
1459 const char* unsupported_properties[] = { &quot;jdk.module.limitmods&quot;,
1460                                          &quot;jdk.module.upgrade.path&quot;,
1461                                          &quot;jdk.module.patch.0&quot; };
1462 const char* unsupported_options[] = { &quot;--limit-modules&quot;,
1463                                       &quot;--upgrade-module-path&quot;,
1464                                       &quot;--patch-module&quot;
1465                                     };
1466 void Arguments::check_unsupported_dumping_properties() {
<span class="line-modified">1467   assert(DumpSharedSpaces, &quot;this function is only used with -Xshare:dump&quot;);</span>

1468   assert(ARRAY_SIZE(unsupported_properties) == ARRAY_SIZE(unsupported_options), &quot;must be&quot;);
1469   // If a vm option is found in the unsupported_options array, vm will exit with an error message.
1470   SystemProperty* sp = system_properties();
1471   while (sp != NULL) {
1472     for (uint i = 0; i &lt; ARRAY_SIZE(unsupported_properties); i++) {
1473       if (strcmp(sp-&gt;key(), unsupported_properties[i]) == 0) {
1474         vm_exit_during_initialization(
1475           &quot;Cannot use the following option when dumping the shared archive&quot;, unsupported_options[i]);
1476       }
1477     }
1478     sp = sp-&gt;next();
1479   }
1480 
1481   // Check for an exploded module build in use with -Xshare:dump.
1482   if (!has_jimage()) {
1483     vm_exit_during_initialization(&quot;Dumping the shared archive is not supported with an exploded module build&quot;);
1484   }
1485 }
1486 
1487 bool Arguments::check_unsupported_cds_runtime_properties() {
1488   assert(UseSharedSpaces, &quot;this function is only used with -Xshare:{on,auto}&quot;);
1489   assert(ARRAY_SIZE(unsupported_properties) == ARRAY_SIZE(unsupported_options), &quot;must be&quot;);







1490   for (uint i = 0; i &lt; ARRAY_SIZE(unsupported_properties); i++) {
1491     if (get_property(unsupported_properties[i]) != NULL) {
1492       if (RequireSharedSpaces) {
1493         warning(&quot;CDS is disabled when the %s option is specified.&quot;, unsupported_options[i]);
1494       }
1495       return true;
1496     }
1497   }
1498   return false;
1499 }
1500 #endif
1501 
1502 //===========================================================================================================
1503 // Setting int/mixed/comp mode flags
1504 
1505 void Arguments::set_mode_flags(Mode mode) {
1506   // Set up default values for all flags.
1507   // If you add a flag to any of the branches below,
1508   // add a default value for it here.
1509   set_java_compiler(false);
</pre>
<hr />
<pre>
1553     ClipInlining             = false;
1554     // Be much more aggressive in tiered mode with -Xcomp and exercise C2 more.
1555     // We will first compile a level 3 version (C1 with full profiling), then do one invocation of it and
1556     // compile a level 4 (C2) and then continue executing it.
1557     if (TieredCompilation) {
1558       Tier3InvokeNotifyFreqLog = 0;
1559       Tier4InvocationThreshold = 0;
1560     }
1561     break;
1562   }
1563 }
1564 
1565 // Conflict: required to use shared spaces (-Xshare:on), but
1566 // incompatible command line options were chosen.
1567 static void no_shared_spaces(const char* message) {
1568   if (RequireSharedSpaces) {
1569     jio_fprintf(defaultStream::error_stream(),
1570       &quot;Class data sharing is inconsistent with other specified options.\n&quot;);
1571     vm_exit_during_initialization(&quot;Unable to use shared archive&quot;, message);
1572   } else {

1573     FLAG_SET_DEFAULT(UseSharedSpaces, false);
1574   }
1575 }
1576 
1577 void set_object_alignment() {
1578   // Object alignment.
1579   assert(is_power_of_2(ObjectAlignmentInBytes), &quot;ObjectAlignmentInBytes must be power of 2&quot;);
1580   MinObjAlignmentInBytes     = ObjectAlignmentInBytes;
1581   assert(MinObjAlignmentInBytes &gt;= HeapWordsPerLong * HeapWordSize, &quot;ObjectAlignmentInBytes value is too small&quot;);
1582   MinObjAlignment            = MinObjAlignmentInBytes / HeapWordSize;
1583   assert(MinObjAlignmentInBytes == MinObjAlignment * HeapWordSize, &quot;ObjectAlignmentInBytes value is incorrect&quot;);
1584   MinObjAlignmentInBytesMask = MinObjAlignmentInBytes - 1;
1585 
1586   LogMinObjAlignmentInBytes  = exact_log2(ObjectAlignmentInBytes);
1587   LogMinObjAlignment         = LogMinObjAlignmentInBytes - LogHeapWordSize;
1588 
1589   // Oop encoding heap max
1590   OopEncodingHeapMax = (uint64_t(max_juint) + 1) &lt;&lt; LogMinObjAlignmentInBytes;
1591 
1592   if (SurvivorAlignmentInBytes == 0) {
</pre>
<hr />
<pre>
1596 
1597 size_t Arguments::max_heap_for_compressed_oops() {
1598   // Avoid sign flip.
1599   assert(OopEncodingHeapMax &gt; (uint64_t)os::vm_page_size(), &quot;Unusual page size&quot;);
1600   // We need to fit both the NULL page and the heap into the memory budget, while
1601   // keeping alignment constraints of the heap. To guarantee the latter, as the
1602   // NULL page is located before the heap, we pad the NULL page to the conservative
1603   // maximum alignment that the GC may ever impose upon the heap.
1604   size_t displacement_due_to_null_page = align_up((size_t)os::vm_page_size(),
1605                                                   _conservative_max_heap_alignment);
1606 
1607   LP64_ONLY(return OopEncodingHeapMax - displacement_due_to_null_page);
1608   NOT_LP64(ShouldNotReachHere(); return 0);
1609 }
1610 
1611 void Arguments::set_use_compressed_oops() {
1612 #ifndef ZERO
1613 #ifdef _LP64
1614   // MaxHeapSize is not set up properly at this point, but
1615   // the only value that can override MaxHeapSize if we are
<span class="line-modified">1616   // to use UseCompressedOops is InitialHeapSize.</span>
<span class="line-modified">1617   size_t max_heap_size = MAX2(MaxHeapSize, InitialHeapSize);</span>
1618 
1619   if (max_heap_size &lt;= max_heap_for_compressed_oops()) {
<span class="line-modified">1620 #if !defined(COMPILER1) || defined(TIERED)</span>
<span class="line-removed">1621     if (FLAG_IS_DEFAULT(UseCompressedOops)) {</span>
1622       FLAG_SET_ERGO(bool, UseCompressedOops, true);
1623     }
<span class="line-removed">1624 #endif</span>
1625   } else {
1626     if (UseCompressedOops &amp;&amp; !FLAG_IS_DEFAULT(UseCompressedOops)) {
1627       warning(&quot;Max heap size too large for Compressed Oops&quot;);
1628       FLAG_SET_DEFAULT(UseCompressedOops, false);
1629       FLAG_SET_DEFAULT(UseCompressedClassPointers, false);
1630     }
1631   }
1632 #endif // _LP64
1633 #endif // ZERO
1634 }
1635 
1636 
1637 // NOTE: set_use_compressed_klass_ptrs() must be called after calling
1638 // set_use_compressed_oops().
1639 void Arguments::set_use_compressed_klass_ptrs() {
1640 #ifndef ZERO
1641 #ifdef _LP64
1642   // UseCompressedOops must be on for UseCompressedClassPointers to be on.
1643   if (!UseCompressedOops) {
1644     if (UseCompressedClassPointers) {
1645       warning(&quot;UseCompressedClassPointers requires UseCompressedOops&quot;);
1646     }
1647     FLAG_SET_DEFAULT(UseCompressedClassPointers, false);
1648   } else {
1649     // Turn on UseCompressedClassPointers too
1650     if (FLAG_IS_DEFAULT(UseCompressedClassPointers)) {
<span class="line-modified">1651       FLAG_SET_ERGO(bool, UseCompressedClassPointers, true);</span>
1652     }
1653     // Check the CompressedClassSpaceSize to make sure we use compressed klass ptrs.
1654     if (UseCompressedClassPointers) {
1655       if (CompressedClassSpaceSize &gt; KlassEncodingMetaspaceMax) {
1656         warning(&quot;CompressedClassSpaceSize is too large for UseCompressedClassPointers&quot;);
1657         FLAG_SET_DEFAULT(UseCompressedClassPointers, false);
1658       }
1659     }
1660   }
1661 #endif // _LP64
1662 #endif // !ZERO
1663 }
1664 
1665 void Arguments::set_conservative_max_heap_alignment() {
1666   // The conservative maximum required alignment for the heap is the maximum of
1667   // the alignments imposed by several sources: any requirements from the heap
<span class="line-modified">1668   // itself, the collector policy and the maximum page size we may run the VM</span>
<span class="line-removed">1669   // with.</span>
1670   size_t heap_alignment = GCConfig::arguments()-&gt;conservative_max_heap_alignment();
1671   _conservative_max_heap_alignment = MAX4(heap_alignment,
1672                                           (size_t)os::vm_allocation_granularity(),
1673                                           os::max_page_size(),
<span class="line-modified">1674                                           CollectorPolicy::compute_heap_alignment());</span>
1675 }
1676 
1677 jint Arguments::set_ergonomics_flags() {
1678   GCConfig::initialize();
1679 
1680   set_conservative_max_heap_alignment();
1681 
1682 #ifndef ZERO
1683 #ifdef _LP64
1684   set_use_compressed_oops();
1685 
1686   // set_use_compressed_klass_ptrs() must be called after calling
1687   // set_use_compressed_oops().
1688   set_use_compressed_klass_ptrs();
1689 
1690   // Also checks that certain machines are slower with compressed oops
1691   // in vm_version initialization code.
1692 #endif // _LP64
1693 #endif // !ZERO
1694 
1695   return JNI_OK;
1696 }
1697 
1698 julong Arguments::limit_by_allocatable_memory(julong limit) {
1699   julong max_allocatable;
1700   julong result = limit;
1701   if (os::has_allocatable_memory_limit(&amp;max_allocatable)) {
1702     result = MIN2(result, max_allocatable / MaxVirtMemFraction);
1703   }
1704   return result;
1705 }
1706 
1707 // Use static initialization to get the default before parsing
1708 static const size_t DefaultHeapBaseMinAddress = HeapBaseMinAddress;
1709 
1710 void Arguments::set_heap_size() {
<span class="line-modified">1711   julong phys_mem =</span>
<span class="line-modified">1712     FLAG_IS_DEFAULT(MaxRAM) ? MIN2(os::physical_memory(), (julong)MaxRAM)</span>
<span class="line-modified">1713                             : (julong)MaxRAM;</span>
























1714 
1715   // Convert deprecated flags
1716   if (FLAG_IS_DEFAULT(MaxRAMPercentage) &amp;&amp;
1717       !FLAG_IS_DEFAULT(MaxRAMFraction))
1718     MaxRAMPercentage = 100.0 / MaxRAMFraction;
1719 
1720   if (FLAG_IS_DEFAULT(MinRAMPercentage) &amp;&amp;
1721       !FLAG_IS_DEFAULT(MinRAMFraction))
1722     MinRAMPercentage = 100.0 / MinRAMFraction;
1723 
1724   if (FLAG_IS_DEFAULT(InitialRAMPercentage) &amp;&amp;
1725       !FLAG_IS_DEFAULT(InitialRAMFraction))
1726     InitialRAMPercentage = 100.0 / InitialRAMFraction;
1727 
1728   // If the maximum heap size has not been set with -Xmx,
1729   // then set it as fraction of the size of physical memory,
1730   // respecting the maximum and minimum sizes of the heap.
1731   if (FLAG_IS_DEFAULT(MaxHeapSize)) {
1732     julong reasonable_max = (julong)((phys_mem * MaxRAMPercentage) / 100);
1733     const julong reasonable_min = (julong)((phys_mem * MinRAMPercentage) / 100);
1734     if (reasonable_min &lt; MaxHeapSize) {
1735       // Small physical memory, so use a minimum fraction of it for the heap
1736       reasonable_max = reasonable_min;
1737     } else {
1738       // Not-small physical memory, so require a heap at least
1739       // as large as MaxHeapSize
1740       reasonable_max = MAX2(reasonable_max, (julong)MaxHeapSize);
1741     }
1742 
1743     if (!FLAG_IS_DEFAULT(ErgoHeapSizeLimit) &amp;&amp; ErgoHeapSizeLimit != 0) {
1744       // Limit the heap size to ErgoHeapSizeLimit
1745       reasonable_max = MIN2(reasonable_max, (julong)ErgoHeapSizeLimit);
1746     }


1747     if (UseCompressedOops) {
1748       // Limit the heap size to the maximum possible when using compressed oops
1749       julong max_coop_heap = (julong)max_heap_for_compressed_oops();
1750 
1751       // HeapBaseMinAddress can be greater than default but not less than.
1752       if (!FLAG_IS_DEFAULT(HeapBaseMinAddress)) {
1753         if (HeapBaseMinAddress &lt; DefaultHeapBaseMinAddress) {
1754           // matches compressed oops printing flags
1755           log_debug(gc, heap, coops)(&quot;HeapBaseMinAddress must be at least &quot; SIZE_FORMAT
1756                                      &quot; (&quot; SIZE_FORMAT &quot;G) which is greater than value given &quot; SIZE_FORMAT,
1757                                      DefaultHeapBaseMinAddress,
1758                                      DefaultHeapBaseMinAddress/G,
1759                                      HeapBaseMinAddress);
<span class="line-modified">1760           FLAG_SET_ERGO(size_t, HeapBaseMinAddress, DefaultHeapBaseMinAddress);</span>
1761         }
1762       }
1763 
1764       if (HeapBaseMinAddress + MaxHeapSize &lt; max_coop_heap) {
1765         // Heap should be above HeapBaseMinAddress to get zero based compressed oops
1766         // but it should be not less than default MaxHeapSize.
1767         max_coop_heap -= HeapBaseMinAddress;
1768       }
<span class="line-modified">1769       reasonable_max = MIN2(reasonable_max, max_coop_heap);</span>
















1770     }


1771     reasonable_max = limit_by_allocatable_memory(reasonable_max);
1772 
1773     if (!FLAG_IS_DEFAULT(InitialHeapSize)) {
1774       // An initial heap size was specified on the command line,
1775       // so be sure that the maximum size is consistent.  Done
1776       // after call to limit_by_allocatable_memory because that
1777       // method might reduce the allocation size.
1778       reasonable_max = MAX2(reasonable_max, (julong)InitialHeapSize);


1779     }
1780 
1781     log_trace(gc, heap)(&quot;  Maximum heap size &quot; SIZE_FORMAT, (size_t) reasonable_max);
<span class="line-modified">1782     FLAG_SET_ERGO(size_t, MaxHeapSize, (size_t)reasonable_max);</span>
1783   }
1784 
1785   // If the minimum or initial heap_size have not been set or requested to be set
1786   // ergonomically, set them accordingly.
<span class="line-modified">1787   if (InitialHeapSize == 0 || min_heap_size() == 0) {</span>
1788     julong reasonable_minimum = (julong)(OldSize + NewSize);
1789 
1790     reasonable_minimum = MIN2(reasonable_minimum, (julong)MaxHeapSize);
1791 
1792     reasonable_minimum = limit_by_allocatable_memory(reasonable_minimum);
1793 
1794     if (InitialHeapSize == 0) {
1795       julong reasonable_initial = (julong)((phys_mem * InitialRAMPercentage) / 100);
1796 
<span class="line-modified">1797       reasonable_initial = MAX3(reasonable_initial, reasonable_minimum, (julong)min_heap_size());</span>
1798       reasonable_initial = MIN2(reasonable_initial, (julong)MaxHeapSize);
1799 
1800       reasonable_initial = limit_by_allocatable_memory(reasonable_initial);
1801 
<span class="line-modified">1802       log_trace(gc, heap)(&quot;  Initial heap size &quot; SIZE_FORMAT, (size_t)reasonable_initial);</span>
<span class="line-modified">1803       FLAG_SET_ERGO(size_t, InitialHeapSize, (size_t)reasonable_initial);</span>
1804     }
<span class="line-modified">1805     // If the minimum heap size has not been set (via -Xms),</span>
1806     // synchronize with InitialHeapSize to avoid errors with the default value.
<span class="line-modified">1807     if (min_heap_size() == 0) {</span>
<span class="line-modified">1808       set_min_heap_size(MIN2((size_t)reasonable_minimum, InitialHeapSize));</span>
<span class="line-modified">1809       log_trace(gc, heap)(&quot;  Minimum heap size &quot; SIZE_FORMAT, min_heap_size());</span>
1810     }
1811   }
1812 }
1813 
1814 // This option inspects the machine and attempts to set various
1815 // parameters to be optimal for long-running, memory allocation
1816 // intensive jobs.  It is intended for machines with large
1817 // amounts of cpu and memory.
1818 jint Arguments::set_aggressive_heap_flags() {
1819   // initHeapSize is needed since _initial_heap_size is 4 bytes on a 32 bit
1820   // VM, but we may not be able to represent the total physical memory
1821   // available (like having 8gb of memory on a box but using a 32bit VM).
1822   // Thus, we need to make sure we&#39;re using a julong for intermediate
1823   // calculations.
1824   julong initHeapSize;
1825   julong total_memory = os::physical_memory();
1826 
1827   if (total_memory &lt; (julong) 256 * M) {
1828     jio_fprintf(defaultStream::error_stream(),
1829             &quot;You need at least 256mb of memory to use -XX:+AggressiveHeap\n&quot;);
1830     vm_exit(1);
1831   }
1832 
1833   // The heap size is half of available memory, or (at most)
1834   // all of possible memory less 160mb (leaving room for the OS
1835   // when using ISM).  This is the maximum; because adaptive sizing
1836   // is turned on below, the actual space used may be smaller.
1837 
1838   initHeapSize = MIN2(total_memory / (julong) 2,
1839           total_memory - (julong) 160 * M);
1840 
1841   initHeapSize = limit_by_allocatable_memory(initHeapSize);
1842 
1843   if (FLAG_IS_DEFAULT(MaxHeapSize)) {
<span class="line-modified">1844     if (FLAG_SET_CMDLINE(size_t, MaxHeapSize, initHeapSize) != JVMFlag::SUCCESS) {</span>
1845       return JNI_EINVAL;
1846     }
<span class="line-modified">1847     if (FLAG_SET_CMDLINE(size_t, InitialHeapSize, initHeapSize) != JVMFlag::SUCCESS) {</span>



1848       return JNI_EINVAL;
1849     }
<span class="line-removed">1850     // Currently the minimum size and the initial heap sizes are the same.</span>
<span class="line-removed">1851     set_min_heap_size(initHeapSize);</span>
1852   }
1853   if (FLAG_IS_DEFAULT(NewSize)) {
1854     // Make the young generation 3/8ths of the total heap.
<span class="line-modified">1855     if (FLAG_SET_CMDLINE(size_t, NewSize,</span>
1856             ((julong) MaxHeapSize / (julong) 8) * (julong) 3) != JVMFlag::SUCCESS) {
1857       return JNI_EINVAL;
1858     }
<span class="line-modified">1859     if (FLAG_SET_CMDLINE(size_t, MaxNewSize, NewSize) != JVMFlag::SUCCESS) {</span>
1860       return JNI_EINVAL;
1861     }
1862   }
1863 
1864 #if !defined(_ALLBSD_SOURCE) &amp;&amp; !defined(AIX)  // UseLargePages is not yet supported on BSD and AIX.
1865   FLAG_SET_DEFAULT(UseLargePages, true);
1866 #endif
1867 
1868   // Increase some data structure sizes for efficiency
<span class="line-modified">1869   if (FLAG_SET_CMDLINE(size_t, BaseFootPrintEstimate, MaxHeapSize) != JVMFlag::SUCCESS) {</span>
1870     return JNI_EINVAL;
1871   }
<span class="line-modified">1872   if (FLAG_SET_CMDLINE(bool, ResizeTLAB, false) != JVMFlag::SUCCESS) {</span>
1873     return JNI_EINVAL;
1874   }
<span class="line-modified">1875   if (FLAG_SET_CMDLINE(size_t, TLABSize, 256 * K) != JVMFlag::SUCCESS) {</span>
1876     return JNI_EINVAL;
1877   }
1878 
1879   // See the OldPLABSize comment below, but replace &#39;after promotion&#39;
1880   // with &#39;after copying&#39;.  YoungPLABSize is the size of the survivor
1881   // space per-gc-thread buffers.  The default is 4kw.
<span class="line-modified">1882   if (FLAG_SET_CMDLINE(size_t, YoungPLABSize, 256 * K) != JVMFlag::SUCCESS) { // Note: this is in words</span>
1883     return JNI_EINVAL;
1884   }
1885 
1886   // OldPLABSize is the size of the buffers in the old gen that
1887   // UseParallelGC uses to promote live data that doesn&#39;t fit in the
1888   // survivor spaces.  At any given time, there&#39;s one for each gc thread.
1889   // The default size is 1kw. These buffers are rarely used, since the
1890   // survivor spaces are usually big enough.  For specjbb, however, there
1891   // are occasions when there&#39;s lots of live data in the young gen
1892   // and we end up promoting some of it.  We don&#39;t have a definite
1893   // explanation for why bumping OldPLABSize helps, but the theory
1894   // is that a bigger PLAB results in retaining something like the
1895   // original allocation order after promotion, which improves mutator
1896   // locality.  A minor effect may be that larger PLABs reduce the
1897   // number of PLAB allocation events during gc.  The value of 8kw
1898   // was arrived at by experimenting with specjbb.
<span class="line-modified">1899   if (FLAG_SET_CMDLINE(size_t, OldPLABSize, 8 * K) != JVMFlag::SUCCESS) { // Note: this is in words</span>
1900     return JNI_EINVAL;
1901   }
1902 
1903   // Enable parallel GC and adaptive generation sizing
<span class="line-modified">1904   if (FLAG_SET_CMDLINE(bool, UseParallelGC, true) != JVMFlag::SUCCESS) {</span>
1905     return JNI_EINVAL;
1906   }
1907 
1908   // Encourage steady state memory management
<span class="line-modified">1909   if (FLAG_SET_CMDLINE(uintx, ThresholdTolerance, 100) != JVMFlag::SUCCESS) {</span>
1910     return JNI_EINVAL;
1911   }
1912 
1913   // This appears to improve mutator locality
<span class="line-modified">1914   if (FLAG_SET_CMDLINE(bool, ScavengeBeforeFullGC, false) != JVMFlag::SUCCESS) {</span>
<span class="line-removed">1915     return JNI_EINVAL;</span>
<span class="line-removed">1916   }</span>
<span class="line-removed">1917 </span>
<span class="line-removed">1918   // Get around early Solaris scheduling bug</span>
<span class="line-removed">1919   // (affinity vs other jobs on system)</span>
<span class="line-removed">1920   // but disallow DR and offlining (5008695).</span>
<span class="line-removed">1921   if (FLAG_SET_CMDLINE(bool, BindGCTaskThreadsToCPUs, true) != JVMFlag::SUCCESS) {</span>
1922     return JNI_EINVAL;
1923   }
1924 
1925   return JNI_OK;
1926 }
1927 
1928 // This must be called after ergonomics.
1929 void Arguments::set_bytecode_flags() {
1930   if (!RewriteBytecodes) {
1931     FLAG_SET_DEFAULT(RewriteFrequentPairs, false);
1932   }
1933 }
1934 
1935 // Aggressive optimization flags
1936 jint Arguments::set_aggressive_opts_flags() {
1937 #ifdef COMPILER2
1938   if (AggressiveUnboxing) {
1939     if (FLAG_IS_DEFAULT(EliminateAutoBox)) {
1940       FLAG_SET_DEFAULT(EliminateAutoBox, true);
1941     } else if (!EliminateAutoBox) {
</pre>
<hr />
<pre>
2022       warning(&quot;PrintNMTStatistics is disabled, because native memory tracking is not enabled&quot;);
2023       PrintNMTStatistics = false;
2024 #if INCLUDE_NMT
2025     }
2026 #endif
2027   }
2028 
2029   status = CompilerConfig::check_args_consistency(status);
2030 #if INCLUDE_JVMCI
2031   if (status &amp;&amp; EnableJVMCI) {
2032     PropertyList_unique_add(&amp;_system_properties, &quot;jdk.internal.vm.ci.enabled&quot;, &quot;true&quot;,
2033         AddProperty, UnwriteableProperty, InternalProperty);
2034     if (!create_numbered_property(&quot;jdk.module.addmods&quot;, &quot;jdk.internal.vm.ci&quot;, addmods_count++)) {
2035       return false;
2036     }
2037   }
2038 #endif
2039 
2040 #ifndef SUPPORT_RESERVED_STACK_AREA
2041   if (StackReservedPages != 0) {
<span class="line-modified">2042     FLAG_SET_CMDLINE(intx, StackReservedPages, 0);</span>
2043     warning(&quot;Reserved Stack Area not supported on this platform&quot;);
2044   }
2045 #endif
2046 
<span class="line-removed">2047   if (!FLAG_IS_DEFAULT(AllocateHeapAt)) {</span>
<span class="line-removed">2048     if ((UseNUMAInterleaving &amp;&amp; !FLAG_IS_DEFAULT(UseNUMAInterleaving)) || (UseNUMA &amp;&amp; !FLAG_IS_DEFAULT(UseNUMA))) {</span>
<span class="line-removed">2049       log_warning(arguments) (&quot;NUMA support for Heap depends on the file system when AllocateHeapAt option is used.\n&quot;);</span>
<span class="line-removed">2050     }</span>
<span class="line-removed">2051   }</span>
<span class="line-removed">2052 </span>
2053   status = status &amp;&amp; GCArguments::check_args_consistency();
2054 
2055   return status;
2056 }
2057 
2058 bool Arguments::is_bad_option(const JavaVMOption* option, jboolean ignore,
2059   const char* option_type) {
2060   if (ignore) return false;
2061 
2062   const char* spacer = &quot; &quot;;
2063   if (option_type == NULL) {
2064     option_type = ++spacer; // Set both to the empty string.
2065   }
2066 
2067   jio_fprintf(defaultStream::error_stream(),
2068               &quot;Unrecognized %s%soption: %s\n&quot;, option_type, spacer,
2069               option-&gt;optionString);
2070   return true;
2071 }
2072 
</pre>
<hr />
<pre>
2131     }
2132     bool added = add_property(property, UnwriteableProperty, InternalProperty);
2133     FreeHeap(property);
2134     return added;
2135   }
2136 
2137   jio_fprintf(defaultStream::error_stream(), &quot;Property count limit exceeded: %s, limit=%d\n&quot;, prop_base_name, props_count_limit);
2138   return false;
2139 }
2140 
2141 Arguments::ArgsRange Arguments::parse_memory_size(const char* s,
2142                                                   julong* long_arg,
2143                                                   julong min_size,
2144                                                   julong max_size) {
2145   if (!atojulong(s, long_arg)) return arg_unreadable;
2146   return check_memory_size(*long_arg, min_size, max_size);
2147 }
2148 
2149 // Parse JavaVMInitArgs structure
2150 
<span class="line-modified">2151 jint Arguments::parse_vm_init_args(const JavaVMInitArgs *java_tool_options_args,</span>

2152                                    const JavaVMInitArgs *java_options_args,
2153                                    const JavaVMInitArgs *cmd_line_args) {
2154   bool patch_mod_javabase = false;
2155 
2156   // Save default settings for some mode flags
2157   Arguments::_AlwaysCompileLoopMethods = AlwaysCompileLoopMethods;
2158   Arguments::_UseOnStackReplacement    = UseOnStackReplacement;
2159   Arguments::_ClipInlining             = ClipInlining;
2160   Arguments::_BackgroundCompilation    = BackgroundCompilation;
2161   if (TieredCompilation) {
2162     Arguments::_Tier3InvokeNotifyFreqLog = Tier3InvokeNotifyFreqLog;
2163     Arguments::_Tier4InvocationThreshold = Tier4InvocationThreshold;
2164   }
2165 



2166   // Setup flags for mixed which is the default
2167   set_mode_flags(_mixed);
2168 






2169   // Parse args structure generated from JAVA_TOOL_OPTIONS environment
2170   // variable (if present).
<span class="line-modified">2171   jint result = parse_each_vm_init_arg(java_tool_options_args, &amp;patch_mod_javabase, JVMFlag::ENVIRON_VAR);</span>
2172   if (result != JNI_OK) {
2173     return result;
2174   }
2175 
2176   // Parse args structure generated from the command line flags.
2177   result = parse_each_vm_init_arg(cmd_line_args, &amp;patch_mod_javabase, JVMFlag::COMMAND_LINE);
2178   if (result != JNI_OK) {
2179     return result;
2180   }
2181 
2182   // Parse args structure generated from the _JAVA_OPTIONS environment
2183   // variable (if present) (mimics classic VM)
2184   result = parse_each_vm_init_arg(java_options_args, &amp;patch_mod_javabase, JVMFlag::ENVIRON_VAR);
2185   if (result != JNI_OK) {
2186     return result;
2187   }
2188 
2189   // We need to ensure processor and memory resources have been properly
2190   // configured - which may rely on arguments we just processed - before
2191   // doing the final argument processing. Any argument processing that
</pre>
<hr />
<pre>
2341 
2342         // add all jvm options to the jvm_args string. This string
2343         // is used later to set the java.vm.args PerfData string constant.
2344         // the -Djava.class.path and the -Dsun.java.command options are
2345         // omitted from jvm_args string as each have their own PerfData
2346         // string constant object.
2347         build_jvm_args(option-&gt;optionString);
2348     }
2349 
2350     // -verbose:[class/module/gc/jni]
2351     if (match_option(option, &quot;-verbose&quot;, &amp;tail)) {
2352       if (!strcmp(tail, &quot;:class&quot;) || !strcmp(tail, &quot;&quot;)) {
2353         LogConfiguration::configure_stdout(LogLevel::Info, true, LOG_TAGS(class, load));
2354         LogConfiguration::configure_stdout(LogLevel::Info, true, LOG_TAGS(class, unload));
2355       } else if (!strcmp(tail, &quot;:module&quot;)) {
2356         LogConfiguration::configure_stdout(LogLevel::Info, true, LOG_TAGS(module, load));
2357         LogConfiguration::configure_stdout(LogLevel::Info, true, LOG_TAGS(module, unload));
2358       } else if (!strcmp(tail, &quot;:gc&quot;)) {
2359         LogConfiguration::configure_stdout(LogLevel::Info, true, LOG_TAGS(gc));
2360       } else if (!strcmp(tail, &quot;:jni&quot;)) {
<span class="line-modified">2361         if (FLAG_SET_CMDLINE(bool, PrintJNIResolving, true) != JVMFlag::SUCCESS) {</span>
<span class="line-removed">2362           return JNI_EINVAL;</span>
<span class="line-removed">2363         }</span>
2364       }
2365     // -da / -ea / -disableassertions / -enableassertions
2366     // These accept an optional class/package name separated by a colon, e.g.,
2367     // -da:java.lang.Thread.
2368     } else if (match_option(option, user_assertion_options, &amp;tail, true)) {
2369       bool enable = option-&gt;optionString[1] == &#39;e&#39;;     // char after &#39;-&#39; is &#39;e&#39;
2370       if (*tail == &#39;\0&#39;) {
2371         JavaAssertions::setUserClassDefault(enable);
2372       } else {
2373         assert(*tail == &#39;:&#39;, &quot;bogus match by match_option()&quot;);
2374         JavaAssertions::addOption(tail + 1, enable);
2375       }
2376     // -dsa / -esa / -disablesystemassertions / -enablesystemassertions
2377     } else if (match_option(option, system_assertion_options, &amp;tail, false)) {
2378       bool enable = option-&gt;optionString[1] == &#39;e&#39;;     // char after &#39;-&#39; is &#39;e&#39;
2379       JavaAssertions::setSystemClassDefault(enable);
2380     // -bootclasspath:
2381     } else if (match_option(option, &quot;-Xbootclasspath:&quot;, &amp;tail)) {
2382         jio_fprintf(defaultStream::output_stream(),
2383           &quot;-Xbootclasspath is no longer a supported option.\n&quot;);
</pre>
<hr />
<pre>
2484       jio_fprintf(defaultStream::error_stream(),
2485         &quot;Instrumentation agents are not supported in this VM\n&quot;);
2486       return JNI_ERR;
2487 #else
2488       if (tail != NULL) {
2489         size_t length = strlen(tail) + 1;
2490         char *options = NEW_C_HEAP_ARRAY(char, length, mtArguments);
2491         jio_snprintf(options, length, &quot;%s&quot;, tail);
2492         add_instrument_agent(&quot;instrument&quot;, options, false);
2493         // java agents need module java.instrument
2494         if (!create_numbered_property(&quot;jdk.module.addmods&quot;, &quot;java.instrument&quot;, addmods_count++)) {
2495           return JNI_ENOMEM;
2496         }
2497       }
2498 #endif // !INCLUDE_JVMTI
2499     // --enable_preview
2500     } else if (match_option(option, &quot;--enable-preview&quot;)) {
2501       set_enable_preview();
2502     // -Xnoclassgc
2503     } else if (match_option(option, &quot;-Xnoclassgc&quot;)) {
<span class="line-modified">2504       if (FLAG_SET_CMDLINE(bool, ClassUnloading, false) != JVMFlag::SUCCESS) {</span>
2505         return JNI_EINVAL;
2506       }
<span class="line-removed">2507     // -Xconcgc</span>
<span class="line-removed">2508     } else if (match_option(option, &quot;-Xconcgc&quot;)) {</span>
<span class="line-removed">2509       if (FLAG_SET_CMDLINE(bool, UseConcMarkSweepGC, true) != JVMFlag::SUCCESS) {</span>
<span class="line-removed">2510         return JNI_EINVAL;</span>
<span class="line-removed">2511       }</span>
<span class="line-removed">2512       handle_extra_cms_flags(&quot;-Xconcgc uses UseConcMarkSweepGC&quot;);</span>
<span class="line-removed">2513     // -Xnoconcgc</span>
<span class="line-removed">2514     } else if (match_option(option, &quot;-Xnoconcgc&quot;)) {</span>
<span class="line-removed">2515       if (FLAG_SET_CMDLINE(bool, UseConcMarkSweepGC, false) != JVMFlag::SUCCESS) {</span>
<span class="line-removed">2516         return JNI_EINVAL;</span>
<span class="line-removed">2517       }</span>
<span class="line-removed">2518       handle_extra_cms_flags(&quot;-Xnoconcgc uses UseConcMarkSweepGC&quot;);</span>
2519     // -Xbatch
2520     } else if (match_option(option, &quot;-Xbatch&quot;)) {
<span class="line-modified">2521       if (FLAG_SET_CMDLINE(bool, BackgroundCompilation, false) != JVMFlag::SUCCESS) {</span>
2522         return JNI_EINVAL;
2523       }
2524     // -Xmn for compatibility with other JVM vendors
2525     } else if (match_option(option, &quot;-Xmn&quot;, &amp;tail)) {
2526       julong long_initial_young_size = 0;
2527       ArgsRange errcode = parse_memory_size(tail, &amp;long_initial_young_size, 1);
2528       if (errcode != arg_in_range) {
2529         jio_fprintf(defaultStream::error_stream(),
2530                     &quot;Invalid initial young generation size: %s\n&quot;, option-&gt;optionString);
2531         describe_range_error(errcode);
2532         return JNI_EINVAL;
2533       }
<span class="line-modified">2534       if (FLAG_SET_CMDLINE(size_t, MaxNewSize, (size_t)long_initial_young_size) != JVMFlag::SUCCESS) {</span>
2535         return JNI_EINVAL;
2536       }
<span class="line-modified">2537       if (FLAG_SET_CMDLINE(size_t, NewSize, (size_t)long_initial_young_size) != JVMFlag::SUCCESS) {</span>
2538         return JNI_EINVAL;
2539       }
2540     // -Xms
2541     } else if (match_option(option, &quot;-Xms&quot;, &amp;tail)) {
<span class="line-modified">2542       julong long_initial_heap_size = 0;</span>
2543       // an initial heap size of 0 means automatically determine
<span class="line-modified">2544       ArgsRange errcode = parse_memory_size(tail, &amp;long_initial_heap_size, 0);</span>
2545       if (errcode != arg_in_range) {
2546         jio_fprintf(defaultStream::error_stream(),
2547                     &quot;Invalid initial heap size: %s\n&quot;, option-&gt;optionString);
2548         describe_range_error(errcode);
2549         return JNI_EINVAL;
2550       }
<span class="line-modified">2551       set_min_heap_size((size_t)long_initial_heap_size);</span>
<span class="line-modified">2552       // Currently the minimum size and the initial heap sizes are the same.</span>
<span class="line-modified">2553       // Can be overridden with -XX:InitialHeapSize.</span>
<span class="line-modified">2554       if (FLAG_SET_CMDLINE(size_t, InitialHeapSize, (size_t)long_initial_heap_size) != JVMFlag::SUCCESS) {</span>
2555         return JNI_EINVAL;
2556       }
2557     // -Xmx
2558     } else if (match_option(option, &quot;-Xmx&quot;, &amp;tail) || match_option(option, &quot;-XX:MaxHeapSize=&quot;, &amp;tail)) {
2559       julong long_max_heap_size = 0;
2560       ArgsRange errcode = parse_memory_size(tail, &amp;long_max_heap_size, 1);
2561       if (errcode != arg_in_range) {
2562         jio_fprintf(defaultStream::error_stream(),
2563                     &quot;Invalid maximum heap size: %s\n&quot;, option-&gt;optionString);
2564         describe_range_error(errcode);
2565         return JNI_EINVAL;
2566       }
<span class="line-modified">2567       if (FLAG_SET_CMDLINE(size_t, MaxHeapSize, (size_t)long_max_heap_size) != JVMFlag::SUCCESS) {</span>
2568         return JNI_EINVAL;
2569       }
2570     // Xmaxf
2571     } else if (match_option(option, &quot;-Xmaxf&quot;, &amp;tail)) {
2572       char* err;
2573       int maxf = (int)(strtod(tail, &amp;err) * 100);
2574       if (*err != &#39;\0&#39; || *tail == &#39;\0&#39;) {
2575         jio_fprintf(defaultStream::error_stream(),
2576                     &quot;Bad max heap free percentage size: %s\n&quot;,
2577                     option-&gt;optionString);
2578         return JNI_EINVAL;
2579       } else {
<span class="line-modified">2580         if (FLAG_SET_CMDLINE(uintx, MaxHeapFreeRatio, maxf) != JVMFlag::SUCCESS) {</span>
2581             return JNI_EINVAL;
2582         }
2583       }
2584     // Xminf
2585     } else if (match_option(option, &quot;-Xminf&quot;, &amp;tail)) {
2586       char* err;
2587       int minf = (int)(strtod(tail, &amp;err) * 100);
2588       if (*err != &#39;\0&#39; || *tail == &#39;\0&#39;) {
2589         jio_fprintf(defaultStream::error_stream(),
2590                     &quot;Bad min heap free percentage size: %s\n&quot;,
2591                     option-&gt;optionString);
2592         return JNI_EINVAL;
2593       } else {
<span class="line-modified">2594         if (FLAG_SET_CMDLINE(uintx, MinHeapFreeRatio, minf) != JVMFlag::SUCCESS) {</span>
2595           return JNI_EINVAL;
2596         }
2597       }
2598     // -Xss
2599     } else if (match_option(option, &quot;-Xss&quot;, &amp;tail)) {
2600       intx value = 0;
2601       jint err = parse_xss(option, tail, &amp;value);
2602       if (err != JNI_OK) {
2603         return err;
2604       }
<span class="line-modified">2605       if (FLAG_SET_CMDLINE(intx, ThreadStackSize, value) != JVMFlag::SUCCESS) {</span>
2606         return JNI_EINVAL;
2607       }
2608     } else if (match_option(option, &quot;-Xmaxjitcodesize&quot;, &amp;tail) ||
2609                match_option(option, &quot;-XX:ReservedCodeCacheSize=&quot;, &amp;tail)) {
2610       julong long_ReservedCodeCacheSize = 0;
2611 
2612       ArgsRange errcode = parse_memory_size(tail, &amp;long_ReservedCodeCacheSize, 1);
2613       if (errcode != arg_in_range) {
2614         jio_fprintf(defaultStream::error_stream(),
2615                     &quot;Invalid maximum code cache size: %s.\n&quot;, option-&gt;optionString);
2616         return JNI_EINVAL;
2617       }
<span class="line-modified">2618       if (FLAG_SET_CMDLINE(uintx, ReservedCodeCacheSize, (uintx)long_ReservedCodeCacheSize) != JVMFlag::SUCCESS) {</span>
2619         return JNI_EINVAL;
2620       }
2621     // -green
2622     } else if (match_option(option, &quot;-green&quot;)) {
2623       jio_fprintf(defaultStream::error_stream(),
2624                   &quot;Green threads support not available\n&quot;);
2625           return JNI_EINVAL;
2626     // -native
2627     } else if (match_option(option, &quot;-native&quot;)) {
2628           // HotSpot always uses native threads, ignore silently for compatibility
2629     // -Xrs
2630     } else if (match_option(option, &quot;-Xrs&quot;)) {
2631           // Classic/EVM option, new functionality
<span class="line-modified">2632       if (FLAG_SET_CMDLINE(bool, ReduceSignalUsage, true) != JVMFlag::SUCCESS) {</span>
2633         return JNI_EINVAL;
2634       }
2635       // -Xprof
2636     } else if (match_option(option, &quot;-Xprof&quot;)) {
2637       char version[256];
2638       // Obsolete in JDK 10
2639       JDK_Version::jdk(10).to_string(version, sizeof(version));
2640       warning(&quot;Ignoring option %s; support was removed in %s&quot;, option-&gt;optionString, version);
2641     // -Xinternalversion
2642     } else if (match_option(option, &quot;-Xinternalversion&quot;)) {
2643       jio_fprintf(defaultStream::output_stream(), &quot;%s\n&quot;,
2644                   VM_Version::internal_vm_info_string());
2645       vm_exit(0);
2646 #ifndef PRODUCT
2647     // -Xprintflags
2648     } else if (match_option(option, &quot;-Xprintflags&quot;)) {
2649       JVMFlag::printFlags(tty, false);
2650       vm_exit(0);
2651 #endif
2652     // -D
</pre>
<hr />
<pre>
2657         // abort if -Djava.endorsed.dirs is set
2658         jio_fprintf(defaultStream::output_stream(),
2659           &quot;-Djava.endorsed.dirs=%s is not supported. Endorsed standards and standalone APIs\n&quot;
2660           &quot;in modular form will be supported via the concept of upgradeable modules.\n&quot;, value);
2661         return JNI_EINVAL;
2662       }
2663       if (match_option(option, &quot;-Djava.ext.dirs=&quot;, &amp;value) &amp;&amp;
2664             *value != &#39;\0&#39; &amp;&amp; strcmp(value, &quot;\&quot;\&quot;&quot;) != 0) {
2665         // abort if -Djava.ext.dirs is set
2666         jio_fprintf(defaultStream::output_stream(),
2667           &quot;-Djava.ext.dirs=%s is not supported.  Use -classpath instead.\n&quot;, value);
2668         return JNI_EINVAL;
2669       }
2670       // Check for module related properties.  They must be set using the modules
2671       // options. For example: use &quot;--add-modules=java.sql&quot;, not
2672       // &quot;-Djdk.module.addmods=java.sql&quot;
2673       if (is_internal_module_property(option-&gt;optionString + 2)) {
2674         needs_module_property_warning = true;
2675         continue;
2676       }
<span class="line-removed">2677 </span>
2678       if (!add_property(tail)) {
2679         return JNI_ENOMEM;
2680       }
2681       // Out of the box management support
2682       if (match_option(option, &quot;-Dcom.sun.management&quot;, &amp;tail)) {
2683 #if INCLUDE_MANAGEMENT
<span class="line-modified">2684         if (FLAG_SET_CMDLINE(bool, ManagementServer, true) != JVMFlag::SUCCESS) {</span>
2685           return JNI_EINVAL;
2686         }
2687         // management agent in module jdk.management.agent
2688         if (!create_numbered_property(&quot;jdk.module.addmods&quot;, &quot;jdk.management.agent&quot;, addmods_count++)) {
2689           return JNI_ENOMEM;
2690         }
2691 #else
2692         jio_fprintf(defaultStream::output_stream(),
2693           &quot;-Dcom.sun.management is not supported in this VM.\n&quot;);
2694         return JNI_ERR;
2695 #endif
2696       }
2697     // -Xint
2698     } else if (match_option(option, &quot;-Xint&quot;)) {
2699           set_mode_flags(_int);
2700     // -Xmixed
2701     } else if (match_option(option, &quot;-Xmixed&quot;)) {
2702           set_mode_flags(_mixed);
2703     // -Xcomp
2704     } else if (match_option(option, &quot;-Xcomp&quot;)) {
2705       // for testing the compiler; turn off all flags that inhibit compilation
2706           set_mode_flags(_comp);
2707     // -Xshare:dump
2708     } else if (match_option(option, &quot;-Xshare:dump&quot;)) {
<span class="line-modified">2709       if (FLAG_SET_CMDLINE(bool, DumpSharedSpaces, true) != JVMFlag::SUCCESS) {</span>
2710         return JNI_EINVAL;
2711       }
<span class="line-removed">2712       set_mode_flags(_int);     // Prevent compilation, which creates objects</span>
2713     // -Xshare:on
2714     } else if (match_option(option, &quot;-Xshare:on&quot;)) {
<span class="line-modified">2715       if (FLAG_SET_CMDLINE(bool, UseSharedSpaces, true) != JVMFlag::SUCCESS) {</span>
2716         return JNI_EINVAL;
2717       }
<span class="line-modified">2718       if (FLAG_SET_CMDLINE(bool, RequireSharedSpaces, true) != JVMFlag::SUCCESS) {</span>
2719         return JNI_EINVAL;
2720       }
<span class="line-modified">2721     // -Xshare:auto</span>
2722     } else if (match_option(option, &quot;-Xshare:auto&quot;)) {
<span class="line-modified">2723       if (FLAG_SET_CMDLINE(bool, UseSharedSpaces, true) != JVMFlag::SUCCESS) {</span>
2724         return JNI_EINVAL;
2725       }
<span class="line-modified">2726       if (FLAG_SET_CMDLINE(bool, RequireSharedSpaces, false) != JVMFlag::SUCCESS) {</span>
2727         return JNI_EINVAL;
2728       }
2729     // -Xshare:off
2730     } else if (match_option(option, &quot;-Xshare:off&quot;)) {
<span class="line-modified">2731       if (FLAG_SET_CMDLINE(bool, UseSharedSpaces, false) != JVMFlag::SUCCESS) {</span>
2732         return JNI_EINVAL;
2733       }
<span class="line-modified">2734       if (FLAG_SET_CMDLINE(bool, RequireSharedSpaces, false) != JVMFlag::SUCCESS) {</span>
2735         return JNI_EINVAL;
2736       }
2737     // -Xverify
2738     } else if (match_option(option, &quot;-Xverify&quot;, &amp;tail)) {
2739       if (strcmp(tail, &quot;:all&quot;) == 0 || strcmp(tail, &quot;&quot;) == 0) {
<span class="line-modified">2740         if (FLAG_SET_CMDLINE(bool, BytecodeVerificationLocal, true) != JVMFlag::SUCCESS) {</span>
2741           return JNI_EINVAL;
2742         }
<span class="line-modified">2743         if (FLAG_SET_CMDLINE(bool, BytecodeVerificationRemote, true) != JVMFlag::SUCCESS) {</span>
2744           return JNI_EINVAL;
2745         }
2746       } else if (strcmp(tail, &quot;:remote&quot;) == 0) {
<span class="line-modified">2747         if (FLAG_SET_CMDLINE(bool, BytecodeVerificationLocal, false) != JVMFlag::SUCCESS) {</span>
2748           return JNI_EINVAL;
2749         }
<span class="line-modified">2750         if (FLAG_SET_CMDLINE(bool, BytecodeVerificationRemote, true) != JVMFlag::SUCCESS) {</span>
2751           return JNI_EINVAL;
2752         }
2753       } else if (strcmp(tail, &quot;:none&quot;) == 0) {
<span class="line-modified">2754         if (FLAG_SET_CMDLINE(bool, BytecodeVerificationLocal, false) != JVMFlag::SUCCESS) {</span>
2755           return JNI_EINVAL;
2756         }
<span class="line-modified">2757         if (FLAG_SET_CMDLINE(bool, BytecodeVerificationRemote, false) != JVMFlag::SUCCESS) {</span>
2758           return JNI_EINVAL;
2759         }
2760         warning(&quot;Options -Xverify:none and -noverify were deprecated in JDK 13 and will likely be removed in a future release.&quot;);
2761       } else if (is_bad_option(option, args-&gt;ignoreUnrecognized, &quot;verification&quot;)) {
2762         return JNI_EINVAL;
2763       }
2764     // -Xdebug
2765     } else if (match_option(option, &quot;-Xdebug&quot;)) {
2766       // note this flag has been used, then ignore
2767       set_xdebug_mode(true);
2768     // -Xnoagent
2769     } else if (match_option(option, &quot;-Xnoagent&quot;)) {
2770       // For compatibility with classic. HotSpot refuses to load the old style agent.dll.
2771     } else if (match_option(option, &quot;-Xloggc:&quot;, &amp;tail)) {
2772       // Deprecated flag to redirect GC output to a file. -Xloggc:&lt;filename&gt;
2773       log_warning(gc)(&quot;-Xloggc is deprecated. Will use -Xlog:gc:%s instead.&quot;, tail);
2774       _gc_log_filename = os::strdup_check_oom(tail);
2775     } else if (match_option(option, &quot;-Xlog&quot;, &amp;tail)) {
2776       bool ret = false;
2777       if (strcmp(tail, &quot;:help&quot;) == 0) {
</pre>
<hr />
<pre>
2797     } else if (match_option(option, &quot;-Xcheck&quot;, &amp;tail)) {
2798       if (!strcmp(tail, &quot;:jni&quot;)) {
2799 #if !INCLUDE_JNI_CHECK
2800         warning(&quot;JNI CHECKING is not supported in this VM&quot;);
2801 #else
2802         CheckJNICalls = true;
2803 #endif // INCLUDE_JNI_CHECK
2804       } else if (is_bad_option(option, args-&gt;ignoreUnrecognized,
2805                                      &quot;check&quot;)) {
2806         return JNI_EINVAL;
2807       }
2808     } else if (match_option(option, &quot;vfprintf&quot;)) {
2809       _vfprintf_hook = CAST_TO_FN_PTR(vfprintf_hook_t, option-&gt;extraInfo);
2810     } else if (match_option(option, &quot;exit&quot;)) {
2811       _exit_hook = CAST_TO_FN_PTR(exit_hook_t, option-&gt;extraInfo);
2812     } else if (match_option(option, &quot;abort&quot;)) {
2813       _abort_hook = CAST_TO_FN_PTR(abort_hook_t, option-&gt;extraInfo);
2814     // Need to keep consistency of MaxTenuringThreshold and AlwaysTenure/NeverTenure;
2815     // and the last option wins.
2816     } else if (match_option(option, &quot;-XX:+NeverTenure&quot;)) {
<span class="line-modified">2817       if (FLAG_SET_CMDLINE(bool, NeverTenure, true) != JVMFlag::SUCCESS) {</span>
2818         return JNI_EINVAL;
2819       }
<span class="line-modified">2820       if (FLAG_SET_CMDLINE(bool, AlwaysTenure, false) != JVMFlag::SUCCESS) {</span>
2821         return JNI_EINVAL;
2822       }
<span class="line-modified">2823       if (FLAG_SET_CMDLINE(uintx, MaxTenuringThreshold, markOopDesc::max_age + 1) != JVMFlag::SUCCESS) {</span>
2824         return JNI_EINVAL;
2825       }
2826     } else if (match_option(option, &quot;-XX:+AlwaysTenure&quot;)) {
<span class="line-modified">2827       if (FLAG_SET_CMDLINE(bool, NeverTenure, false) != JVMFlag::SUCCESS) {</span>
2828         return JNI_EINVAL;
2829       }
<span class="line-modified">2830       if (FLAG_SET_CMDLINE(bool, AlwaysTenure, true) != JVMFlag::SUCCESS) {</span>
2831         return JNI_EINVAL;
2832       }
<span class="line-modified">2833       if (FLAG_SET_CMDLINE(uintx, MaxTenuringThreshold, 0) != JVMFlag::SUCCESS) {</span>
2834         return JNI_EINVAL;
2835       }
2836     } else if (match_option(option, &quot;-XX:MaxTenuringThreshold=&quot;, &amp;tail)) {
2837       uintx max_tenuring_thresh = 0;
2838       if (!parse_uintx(tail, &amp;max_tenuring_thresh, 0)) {
2839         jio_fprintf(defaultStream::error_stream(),
2840                     &quot;Improperly specified VM option \&#39;MaxTenuringThreshold=%s\&#39;\n&quot;, tail);
2841         return JNI_EINVAL;
2842       }
2843 
<span class="line-modified">2844       if (FLAG_SET_CMDLINE(uintx, MaxTenuringThreshold, max_tenuring_thresh) != JVMFlag::SUCCESS) {</span>
2845         return JNI_EINVAL;
2846       }
2847 
2848       if (MaxTenuringThreshold == 0) {
<span class="line-modified">2849         if (FLAG_SET_CMDLINE(bool, NeverTenure, false) != JVMFlag::SUCCESS) {</span>
2850           return JNI_EINVAL;
2851         }
<span class="line-modified">2852         if (FLAG_SET_CMDLINE(bool, AlwaysTenure, true) != JVMFlag::SUCCESS) {</span>
2853           return JNI_EINVAL;
2854         }
2855       } else {
<span class="line-modified">2856         if (FLAG_SET_CMDLINE(bool, NeverTenure, false) != JVMFlag::SUCCESS) {</span>
2857           return JNI_EINVAL;
2858         }
<span class="line-modified">2859         if (FLAG_SET_CMDLINE(bool, AlwaysTenure, false) != JVMFlag::SUCCESS) {</span>
2860           return JNI_EINVAL;
2861         }
2862       }
2863     } else if (match_option(option, &quot;-XX:+DisplayVMOutputToStderr&quot;)) {
<span class="line-modified">2864       if (FLAG_SET_CMDLINE(bool, DisplayVMOutputToStdout, false) != JVMFlag::SUCCESS) {</span>
2865         return JNI_EINVAL;
2866       }
<span class="line-modified">2867       if (FLAG_SET_CMDLINE(bool, DisplayVMOutputToStderr, true) != JVMFlag::SUCCESS) {</span>
2868         return JNI_EINVAL;
2869       }
2870     } else if (match_option(option, &quot;-XX:+DisplayVMOutputToStdout&quot;)) {
<span class="line-modified">2871       if (FLAG_SET_CMDLINE(bool, DisplayVMOutputToStderr, false) != JVMFlag::SUCCESS) {</span>














2872         return JNI_EINVAL;
2873       }
<span class="line-modified">2874       if (FLAG_SET_CMDLINE(bool, DisplayVMOutputToStdout, true) != JVMFlag::SUCCESS) {</span>
2875         return JNI_EINVAL;
2876       }
2877     } else if (match_option(option, &quot;-XX:+ExtendedDTraceProbes&quot;)) {
2878 #if defined(DTRACE_ENABLED)
<span class="line-modified">2879       if (FLAG_SET_CMDLINE(bool, ExtendedDTraceProbes, true) != JVMFlag::SUCCESS) {</span>
2880         return JNI_EINVAL;
2881       }
<span class="line-modified">2882       if (FLAG_SET_CMDLINE(bool, DTraceMethodProbes, true) != JVMFlag::SUCCESS) {</span>
2883         return JNI_EINVAL;
2884       }
<span class="line-modified">2885       if (FLAG_SET_CMDLINE(bool, DTraceAllocProbes, true) != JVMFlag::SUCCESS) {</span>
2886         return JNI_EINVAL;
2887       }
<span class="line-modified">2888       if (FLAG_SET_CMDLINE(bool, DTraceMonitorProbes, true) != JVMFlag::SUCCESS) {</span>
2889         return JNI_EINVAL;
2890       }
2891 #else // defined(DTRACE_ENABLED)
2892       jio_fprintf(defaultStream::error_stream(),
2893                   &quot;ExtendedDTraceProbes flag is not applicable for this configuration\n&quot;);
2894       return JNI_EINVAL;
2895 #endif // defined(DTRACE_ENABLED)
2896 #ifdef ASSERT
2897     } else if (match_option(option, &quot;-XX:+FullGCALot&quot;)) {
<span class="line-modified">2898       if (FLAG_SET_CMDLINE(bool, FullGCALot, true) != JVMFlag::SUCCESS) {</span>
2899         return JNI_EINVAL;
2900       }
2901       // disable scavenge before parallel mark-compact
<span class="line-modified">2902       if (FLAG_SET_CMDLINE(bool, ScavengeBeforeFullGC, false) != JVMFlag::SUCCESS) {</span>
2903         return JNI_EINVAL;
2904       }
2905 #endif
2906 #if !INCLUDE_MANAGEMENT
2907     } else if (match_option(option, &quot;-XX:+ManagementServer&quot;)) {
2908         jio_fprintf(defaultStream::error_stream(),
2909           &quot;ManagementServer is not supported in this VM.\n&quot;);
2910         return JNI_ERR;
2911 #endif // INCLUDE_MANAGEMENT






















2912 #if INCLUDE_JFR
2913     } else if (match_jfr_option(&amp;option)) {
2914       return JNI_EINVAL;
2915 #endif
2916     } else if (match_option(option, &quot;-XX:&quot;, &amp;tail)) { // -XX:xxxx
2917       // Skip -XX:Flags= and -XX:VMOptionsFile= since those cases have
2918       // already been handled
2919       if ((strncmp(tail, &quot;Flags=&quot;, strlen(&quot;Flags=&quot;)) != 0) &amp;&amp;
2920           (strncmp(tail, &quot;VMOptionsFile=&quot;, strlen(&quot;VMOptionsFile=&quot;)) != 0)) {
2921         if (!process_argument(tail, args-&gt;ignoreUnrecognized, origin)) {
2922           return JNI_EINVAL;
2923         }
2924       }
2925     // Unknown option
2926     } else if (is_bad_option(option, args-&gt;ignoreUnrecognized)) {
2927       return JNI_ERR;
2928     }
2929   }
2930 
2931   // PrintSharedArchiveAndExit will turn on
2932   //   -Xshare:on
2933   //   -Xlog:class+path=info
2934   if (PrintSharedArchiveAndExit) {
<span class="line-modified">2935     if (FLAG_SET_CMDLINE(bool, UseSharedSpaces, true) != JVMFlag::SUCCESS) {</span>
2936       return JNI_EINVAL;
2937     }
<span class="line-modified">2938     if (FLAG_SET_CMDLINE(bool, RequireSharedSpaces, true) != JVMFlag::SUCCESS) {</span>
2939       return JNI_EINVAL;
2940     }
2941     LogConfiguration::configure_stdout(LogLevel::Info, true, LOG_TAGS(class, path));
2942   }
2943 
<span class="line-removed">2944   // Change the default value for flags  which have different default values</span>
<span class="line-removed">2945   // when working with older JDKs.</span>
<span class="line-removed">2946 #ifdef LINUX</span>
<span class="line-removed">2947  if (JDK_Version::current().compare_major(6) &lt;= 0 &amp;&amp;</span>
<span class="line-removed">2948       FLAG_IS_DEFAULT(UseLinuxPosixThreadCPUClocks)) {</span>
<span class="line-removed">2949     FLAG_SET_DEFAULT(UseLinuxPosixThreadCPUClocks, false);</span>
<span class="line-removed">2950   }</span>
<span class="line-removed">2951 #endif // LINUX</span>
2952   fix_appclasspath();
2953 
2954   return JNI_OK;
2955 }
2956 
2957 void Arguments::add_patch_mod_prefix(const char* module_name, const char* path, bool* patch_mod_javabase) {
2958   // For java.base check for duplicate --patch-module options being specified on the command line.
2959   // This check is only required for java.base, all other duplicate module specifications
2960   // will be checked during module system initialization.  The module system initialization
2961   // will throw an ExceptionInInitializerError if this situation occurs.
2962   if (strcmp(module_name, JAVA_BASE_NAME) == 0) {
2963     if (*patch_mod_javabase) {
2964       vm_exit_during_initialization(&quot;Cannot specify &quot; JAVA_BASE_NAME &quot; more than once to --patch-module&quot;);
2965     } else {
2966       *patch_mod_javabase = true;
2967     }
2968   }
2969 
2970   // Create GrowableArray lazily, only if --patch-module has been specified
2971   if (_patch_mod_prefix == NULL) {
</pre>
<hr />
<pre>
3051   }
3052 
3053   // This must be done after all arguments have been processed.
3054   // java_compiler() true means set to &quot;NONE&quot; or empty.
3055   if (java_compiler() &amp;&amp; !xdebug_mode()) {
3056     // For backwards compatibility, we switch to interpreted mode if
3057     // -Djava.compiler=&quot;NONE&quot; or &quot;&quot; is specified AND &quot;-Xdebug&quot; was
3058     // not specified.
3059     set_mode_flags(_int);
3060   }
3061 
3062   // CompileThresholdScaling == 0.0 is same as -Xint: Disable compilation (enable interpreter-only mode),
3063   // but like -Xint, leave compilation thresholds unaffected.
3064   // With tiered compilation disabled, setting CompileThreshold to 0 disables compilation as well.
3065   if ((CompileThresholdScaling == 0.0) || (!TieredCompilation &amp;&amp; CompileThreshold == 0)) {
3066     set_mode_flags(_int);
3067   }
3068 
3069   // eventually fix up InitialTenuringThreshold if only MaxTenuringThreshold is set
3070   if (FLAG_IS_DEFAULT(InitialTenuringThreshold) &amp;&amp; (InitialTenuringThreshold &gt; MaxTenuringThreshold)) {
<span class="line-modified">3071     FLAG_SET_ERGO(uintx, InitialTenuringThreshold, MaxTenuringThreshold);</span>
3072   }
3073 
3074 #if !COMPILER2_OR_JVMCI
3075   // Don&#39;t degrade server performance for footprint
3076   if (FLAG_IS_DEFAULT(UseLargePages) &amp;&amp;
3077       MaxHeapSize &lt; LargePageHeapSizeThreshold) {
3078     // No need for large granularity pages w/small heaps.
3079     // Note that large pages are enabled/disabled for both the
3080     // Java heap and the code cache.
3081     FLAG_SET_DEFAULT(UseLargePages, false);
3082   }
3083 
3084   UNSUPPORTED_OPTION(ProfileInterpreter);
3085   NOT_PRODUCT(UNSUPPORTED_OPTION(TraceProfileInterpreter));
3086 #endif
3087 
<span class="line-modified">3088 #ifndef TIERED</span>






3089   // Tiered compilation is undefined.
3090   UNSUPPORTED_OPTION(TieredCompilation);
3091 #endif
3092 
3093   if (!check_vm_args_consistency()) {
3094     return JNI_ERR;
3095   }
3096 
3097 #if INCLUDE_CDS
3098   if (DumpSharedSpaces) {
3099     // Disable biased locking now as it interferes with the clean up of
3100     // the archived Klasses and Java string objects (at dump time only).
3101     UseBiasedLocking = false;
3102 










3103     // Always verify non-system classes during CDS dump
3104     if (!BytecodeVerificationRemote) {
3105       BytecodeVerificationRemote = true;
3106       log_info(cds)(&quot;All non-system classes will be verified (-Xverify:remote) during CDS dump time.&quot;);
3107     }
<span class="line-modified">3108 </span>
<span class="line-modified">3109     // Compilation is already disabled if the user specifies -Xshare:dump.</span>
<span class="line-modified">3110     // Disable compilation in case user specifies -XX:+DumpSharedSpaces instead of -Xshare:dump.</span>
<span class="line-removed">3111     set_mode_flags(_int);</span>
3112   }
3113   if (UseSharedSpaces &amp;&amp; patch_mod_javabase) {
3114     no_shared_spaces(&quot;CDS is disabled when &quot; JAVA_BASE_NAME &quot; module is patched.&quot;);
3115   }
3116   if (UseSharedSpaces &amp;&amp; !DumpSharedSpaces &amp;&amp; check_unsupported_cds_runtime_properties()) {
3117     FLAG_SET_DEFAULT(UseSharedSpaces, false);
3118   }
3119 #endif
3120 
3121 #ifndef CAN_SHOW_REGISTERS_ON_ASSERT
3122   UNSUPPORTED_OPTION(ShowRegistersOnAssert);
3123 #endif // CAN_SHOW_REGISTERS_ON_ASSERT
3124 
3125   return JNI_OK;
3126 }
3127 
3128 // Helper class for controlling the lifetime of JavaVMInitArgs
3129 // objects.  The contents of the JavaVMInitArgs are guaranteed to be
3130 // deleted on the destruction of the ScopedVMInitArgs object.
3131 class ScopedVMInitArgs : public StackObj {
</pre>
<hr />
<pre>
3375     // We now have a complete token
3376 
3377     JavaVMOption option;
3378     option.optionString = opt_hd;
3379     option.extraInfo = NULL;
3380 
3381     options-&gt;append(option);                // Fill in option
3382 
3383     rd++;  // Advance to next character
3384   }
3385 
3386   // Fill out JavaVMInitArgs structure.
3387   jint status = vm_args-&gt;set_args(options);
3388 
3389   delete options;
3390   return status;
3391 }
3392 
3393 void Arguments::set_shared_spaces_flags() {
3394   if (DumpSharedSpaces) {
<span class="line-removed">3395     if (FailOverToOldVerifier) {</span>
<span class="line-removed">3396       // Don&#39;t fall back to the old verifier on verification failure. If a</span>
<span class="line-removed">3397       // class fails verification with the split verifier, it might fail the</span>
<span class="line-removed">3398       // CDS runtime verifier constraint check. In that case, we don&#39;t want</span>
<span class="line-removed">3399       // to share the class. We only archive classes that pass the split verifier.</span>
<span class="line-removed">3400       FLAG_SET_DEFAULT(FailOverToOldVerifier, false);</span>
<span class="line-removed">3401     }</span>
<span class="line-removed">3402 </span>
3403     if (RequireSharedSpaces) {
3404       warning(&quot;Cannot dump shared archive while using shared archive&quot;);
3405     }
3406     UseSharedSpaces = false;
<span class="line-removed">3407 #ifdef _LP64</span>
<span class="line-removed">3408     if (!UseCompressedOops || !UseCompressedClassPointers) {</span>
<span class="line-removed">3409       vm_exit_during_initialization(</span>
<span class="line-removed">3410         &quot;Cannot dump shared archive when UseCompressedOops or UseCompressedClassPointers is off.&quot;, NULL);</span>
<span class="line-removed">3411     }</span>
<span class="line-removed">3412   } else {</span>
<span class="line-removed">3413     if (!UseCompressedOops || !UseCompressedClassPointers) {</span>
<span class="line-removed">3414       no_shared_spaces(&quot;UseCompressedOops and UseCompressedClassPointers must be on for UseSharedSpaces.&quot;);</span>
<span class="line-removed">3415     }</span>
<span class="line-removed">3416 #endif</span>
3417   }
3418 }
3419 

3420 // Sharing support
3421 // Construct the path to the archive
3422 char* Arguments::get_default_shared_archive_path() {
3423   char *default_archive_path;
3424   char jvm_path[JVM_MAXPATHLEN];
3425   os::jvm_path(jvm_path, sizeof(jvm_path));
3426   char *end = strrchr(jvm_path, *os::file_separator());
3427   if (end != NULL) *end = &#39;\0&#39;;
3428   size_t jvm_path_len = strlen(jvm_path);
3429   size_t file_sep_len = strlen(os::file_separator());
3430   const size_t len = jvm_path_len + file_sep_len + 20;
3431   default_archive_path = NEW_C_HEAP_ARRAY(char, len, mtArguments);
<span class="line-modified">3432   if (default_archive_path != NULL) {</span>
<span class="line-modified">3433     jio_snprintf(default_archive_path, len, &quot;%s%sclasses.jsa&quot;,</span>
<span class="line-removed">3434       jvm_path, os::file_separator());</span>
<span class="line-removed">3435   }</span>
3436   return default_archive_path;
3437 }
3438 
<span class="line-modified">3439 static char* get_shared_archive_path() {</span>
<span class="line-modified">3440   char *shared_archive_path;</span>





















































3441   if (SharedArchiveFile == NULL) {
<span class="line-modified">3442     shared_archive_path = Arguments::get_default_shared_archive_path();</span>
3443   } else {
<span class="line-modified">3444     shared_archive_path = os::strdup_check_oom(SharedArchiveFile, mtArguments);</span>



































3445   }
<span class="line-modified">3446   return shared_archive_path;</span>
3447 }

3448 
3449 #ifndef PRODUCT
3450 // Determine whether LogVMOutput should be implicitly turned on.
3451 static bool use_vm_log() {
3452   if (LogCompilation || !FLAG_IS_DEFAULT(LogFile) ||
3453       PrintCompilation || PrintInlining || PrintDependencies || PrintNativeNMethods ||
3454       PrintDebugInfo || PrintRelocations || PrintNMethods || PrintExceptionHandlers ||
3455       PrintAssembly || TraceDeoptimization || TraceDependencies ||
3456       (VerifyDependencies &amp;&amp; FLAG_IS_CMDLINE(VerifyDependencies))) {
3457     return true;
3458   }
3459 
3460 #ifdef COMPILER1
3461   if (PrintC1Statistics) {
3462     return true;
3463   }
3464 #endif // COMPILER1
3465 
3466 #ifdef COMPILER2
3467   if (PrintOptoAssembly || PrintOptoStatistics) {
</pre>
<hr />
<pre>
3645   if (PrintGC) {
3646     log_warning(gc)(&quot;-XX:+PrintGC is deprecated. Will use -Xlog:gc instead.&quot;);
3647   }
3648   if (PrintGCDetails) {
3649     log_warning(gc)(&quot;-XX:+PrintGCDetails is deprecated. Will use -Xlog:gc* instead.&quot;);
3650   }
3651 
3652   if (_gc_log_filename != NULL) {
3653     // -Xloggc was used to specify a filename
3654     const char* gc_conf = PrintGCDetails ? &quot;gc*&quot; : &quot;gc&quot;;
3655 
3656     LogTarget(Error, logging) target;
3657     LogStream errstream(target);
3658     return LogConfiguration::parse_log_arguments(_gc_log_filename, gc_conf, NULL, NULL, &amp;errstream);
3659   } else if (PrintGC || PrintGCDetails) {
3660     LogConfiguration::configure_stdout(LogLevel::Info, !PrintGCDetails, LOG_TAGS(gc));
3661   }
3662   return true;
3663 }
3664 
<span class="line-removed">3665 void Arguments::handle_extra_cms_flags(const char* msg) {</span>
<span class="line-removed">3666   SpecialFlag flag;</span>
<span class="line-removed">3667   const char *flag_name = &quot;UseConcMarkSweepGC&quot;;</span>
<span class="line-removed">3668   if (lookup_special_flag(flag_name, flag)) {</span>
<span class="line-removed">3669     handle_aliases_and_deprecation(flag_name, /* print warning */ true);</span>
<span class="line-removed">3670     warning(&quot;%s&quot;, msg);</span>
<span class="line-removed">3671   }</span>
<span class="line-removed">3672 }</span>
<span class="line-removed">3673 </span>
3674 // Parse entry point called from JNI_CreateJavaVM
3675 
3676 jint Arguments::parse(const JavaVMInitArgs* initial_cmd_args) {
<span class="line-modified">3677   assert(verify_special_jvm_flags(), &quot;deprecated and obsolete flag table inconsistent&quot;);</span>
3678 
<span class="line-modified">3679   // Initialize ranges, constraints and writeables</span>
3680   JVMFlagRangeList::init();
3681   JVMFlagConstraintList::init();
<span class="line-removed">3682   JVMFlagWriteableList::init();</span>
3683 
3684   // If flag &quot;-XX:Flags=flags-file&quot; is used it will be the first option to be processed.
3685   const char* hotspotrc = &quot;.hotspotrc&quot;;
3686   bool settings_file_specified = false;
3687   bool needs_hotspotrc_warning = false;

3688   ScopedVMInitArgs initial_java_tool_options_args(&quot;env_var=&#39;JAVA_TOOL_OPTIONS&#39;&quot;);
3689   ScopedVMInitArgs initial_java_options_args(&quot;env_var=&#39;_JAVA_OPTIONS&#39;&quot;);
3690 
3691   // Pointers to current working set of containers
3692   JavaVMInitArgs* cur_cmd_args;

3693   JavaVMInitArgs* cur_java_options_args;
3694   JavaVMInitArgs* cur_java_tool_options_args;
3695 
3696   // Containers for modified/expanded options
3697   ScopedVMInitArgs mod_cmd_args(&quot;cmd_line_args&quot;);

3698   ScopedVMInitArgs mod_java_tool_options_args(&quot;env_var=&#39;JAVA_TOOL_OPTIONS&#39;&quot;);
3699   ScopedVMInitArgs mod_java_options_args(&quot;env_var=&#39;_JAVA_OPTIONS&#39;&quot;);
3700 
3701 
3702   jint code =
3703       parse_java_tool_options_environment_variable(&amp;initial_java_tool_options_args);
3704   if (code != JNI_OK) {
3705     return code;
3706   }
3707 
3708   code = parse_java_options_environment_variable(&amp;initial_java_options_args);
3709   if (code != JNI_OK) {
3710     return code;
3711   }
3712 










3713   code = expand_vm_options_as_needed(initial_java_tool_options_args.get(),
3714                                      &amp;mod_java_tool_options_args,
3715                                      &amp;cur_java_tool_options_args);
3716   if (code != JNI_OK) {
3717     return code;
3718   }
3719 
3720   code = expand_vm_options_as_needed(initial_cmd_args,
3721                                      &amp;mod_cmd_args,
3722                                      &amp;cur_cmd_args);
3723   if (code != JNI_OK) {
3724     return code;
3725   }
3726 
3727   code = expand_vm_options_as_needed(initial_java_options_args.get(),
3728                                      &amp;mod_java_options_args,
3729                                      &amp;cur_java_options_args);
3730   if (code != JNI_OK) {
3731     return code;
3732   }
3733 







3734   const char* flags_file = Arguments::get_jvm_flags_file();
3735   settings_file_specified = (flags_file != NULL);
3736 
3737   if (IgnoreUnrecognizedVMOptions) {
3738     cur_cmd_args-&gt;ignoreUnrecognized = true;
3739     cur_java_tool_options_args-&gt;ignoreUnrecognized = true;
3740     cur_java_options_args-&gt;ignoreUnrecognized = true;
3741   }
3742 
3743   // Parse specified settings file
3744   if (settings_file_specified) {
3745     if (!process_settings_file(flags_file, true,
3746                                cur_cmd_args-&gt;ignoreUnrecognized)) {
3747       return JNI_EINVAL;
3748     }
3749   } else {
3750 #ifdef ASSERT
3751     // Parse default .hotspotrc settings file
3752     if (!process_settings_file(&quot;.hotspotrc&quot;, false,
3753                                cur_cmd_args-&gt;ignoreUnrecognized)) {
3754       return JNI_EINVAL;
3755     }
3756 #else
3757     struct stat buf;
3758     if (os::stat(hotspotrc, &amp;buf) == 0) {
3759       needs_hotspotrc_warning = true;
3760     }
3761 #endif
3762   }
3763 
3764   if (PrintVMOptions) {
3765     print_options(cur_java_tool_options_args);
3766     print_options(cur_cmd_args);
3767     print_options(cur_java_options_args);
3768   }
3769 
3770   // Parse JavaVMInitArgs structure passed in, as well as JAVA_TOOL_OPTIONS and _JAVA_OPTIONS
<span class="line-modified">3771   jint result = parse_vm_init_args(cur_java_tool_options_args,</span>

3772                                    cur_java_options_args,
3773                                    cur_cmd_args);
3774 
3775   if (result != JNI_OK) {
3776     return result;
3777   }
3778 
<span class="line-modified">3779   // Call get_shared_archive_path() here, after possible SharedArchiveFile option got parsed.</span>
<span class="line-modified">3780   SharedArchivePath = get_shared_archive_path();</span>
<span class="line-modified">3781   if (SharedArchivePath == NULL) {</span>
3782     return JNI_ENOMEM;
3783   }
<span class="line-modified">3784 </span>
<span class="line-removed">3785   // Set up VerifySharedSpaces</span>
<span class="line-removed">3786   if (FLAG_IS_DEFAULT(VerifySharedSpaces) &amp;&amp; SharedArchiveFile != NULL) {</span>
<span class="line-removed">3787     VerifySharedSpaces = true;</span>
<span class="line-removed">3788   }</span>
3789 
3790   // Delay warning until here so that we&#39;ve had a chance to process
3791   // the -XX:-PrintWarnings flag
3792   if (needs_hotspotrc_warning) {
3793     warning(&quot;%s file is present but has been ignored.  &quot;
3794             &quot;Run with -XX:Flags=%s to load the file.&quot;,
3795             hotspotrc, hotspotrc);
3796   }
3797 
3798   if (needs_module_property_warning) {
3799     warning(&quot;Ignoring system property options whose names match the &#39;-Djdk.module.*&#39;.&quot;
3800             &quot; names that are reserved for internal use.&quot;);
3801   }
3802 
3803 #if defined(_ALLBSD_SOURCE) || defined(AIX)  // UseLargePages is not yet supported on BSD and AIX.
3804   UNSUPPORTED_OPTION(UseLargePages);
3805 #endif
3806 
3807 #if defined(AIX)
3808   UNSUPPORTED_OPTION_NULL(AllocateHeapAt);
</pre>
<hr />
<pre>
3824   if (ScavengeRootsInCode == 0) {
3825     if (!FLAG_IS_DEFAULT(ScavengeRootsInCode)) {
3826       warning(&quot;Forcing ScavengeRootsInCode non-zero&quot;);
3827     }
3828     ScavengeRootsInCode = 1;
3829   }
3830 
3831   if (!handle_deprecated_print_gc_flags()) {
3832     return JNI_EINVAL;
3833   }
3834 
3835   // Set object alignment values.
3836   set_object_alignment();
3837 
3838 #if !INCLUDE_CDS
3839   if (DumpSharedSpaces || RequireSharedSpaces) {
3840     jio_fprintf(defaultStream::error_stream(),
3841       &quot;Shared spaces are not supported in this VM\n&quot;);
3842     return JNI_ERR;
3843   }





3844   if ((UseSharedSpaces &amp;&amp; FLAG_IS_CMDLINE(UseSharedSpaces)) ||
3845       log_is_enabled(Info, cds)) {
3846     warning(&quot;Shared spaces are not supported in this VM&quot;);
3847     FLAG_SET_DEFAULT(UseSharedSpaces, false);
3848     LogConfiguration::configure_stdout(LogLevel::Off, true, LOG_TAGS(cds));
3849   }
3850   no_shared_spaces(&quot;CDS Disabled&quot;);
3851 #endif // INCLUDE_CDS
3852 






3853   TSAN_RUNTIME_ONLY(
3854     // Currently TSAN is only implemented for interpreter.
3855     set_mode_flags(_int);
3856     // TSAN instrumentation is not implemented for the RewriteBytecodes
3857     // code paths because TSAN slows down the application so much that the
3858     // performance benefits from rewriting bytecodes is negligible.
<span class="line-modified">3859     FLAG_SET_ERGO(bool, RewriteBytecodes, false);</span>
<span class="line-modified">3860     FLAG_SET_ERGO(bool, RewriteFrequentPairs, false);</span>
3861     // Turn off CDS, it interferes with eagerly allocating jmethodIDs.
3862     no_shared_spaces(&quot;CDS is not compatible with TSAN&quot;);
3863   );
3864 
3865   return JNI_OK;
3866 }
3867 
3868 jint Arguments::apply_ergo() {
3869   // Set flags based on ergonomics.
3870   jint result = set_ergonomics_flags();
3871   if (result != JNI_OK) return result;
3872 
3873   // Set heap size based on available physical memory
3874   set_heap_size();
3875 
3876   GCConfig::arguments()-&gt;initialize();
3877 
3878   set_shared_spaces_flags();
3879 
3880   // Initialize Metaspace flags and alignments
</pre>
<hr />
<pre>
3945   }
3946 #endif // PRODUCT
3947 
3948   if (PrintCommandLineFlags) {
3949     JVMFlag::printSetFlags(tty);
3950   }
3951 
3952   // Apply CPU specific policy for the BiasedLocking
3953   if (UseBiasedLocking) {
3954     if (!VM_Version::use_biased_locking() &amp;&amp;
3955         !(FLAG_IS_CMDLINE(UseBiasedLocking))) {
3956       UseBiasedLocking = false;
3957     }
3958   }
3959 #ifdef COMPILER2
3960   if (!UseBiasedLocking) {
3961     UseOptoBiasInlining = false;
3962   }
3963 #endif
3964 
<span class="line-removed">3965 #if defined(IA32)</span>
<span class="line-removed">3966   // Only server compiler can optimize safepoints well enough.</span>
<span class="line-removed">3967   if (!is_server_compilation_mode_vm()) {</span>
<span class="line-removed">3968     FLAG_SET_ERGO_IF_DEFAULT(bool, ThreadLocalHandshakes, false);</span>
<span class="line-removed">3969   }</span>
<span class="line-removed">3970 #endif</span>
<span class="line-removed">3971 </span>
<span class="line-removed">3972   // ThreadLocalHandshakesConstraintFunc handles the constraints.</span>
<span class="line-removed">3973   if (FLAG_IS_DEFAULT(ThreadLocalHandshakes) || !SafepointMechanism::supports_thread_local_poll()) {</span>
<span class="line-removed">3974     log_debug(ergo)(&quot;ThreadLocalHandshakes %s&quot;, ThreadLocalHandshakes ? &quot;enabled.&quot; : &quot;disabled.&quot;);</span>
<span class="line-removed">3975   } else {</span>
<span class="line-removed">3976     log_info(ergo)(&quot;ThreadLocalHandshakes %s&quot;, ThreadLocalHandshakes ? &quot;enabled.&quot; : &quot;disabled.&quot;);</span>
<span class="line-removed">3977   }</span>
<span class="line-removed">3978 </span>
3979   return JNI_OK;
3980 }
3981 
3982 jint Arguments::adjust_after_os() {
3983   if (UseNUMA) {
<span class="line-modified">3984     if (!FLAG_IS_DEFAULT(AllocateHeapAt)) {</span>
<span class="line-removed">3985       FLAG_SET_ERGO(bool, UseNUMA, false);</span>
<span class="line-removed">3986     } else if (UseParallelGC || UseParallelOldGC) {</span>
3987       if (FLAG_IS_DEFAULT(MinHeapDeltaBytes)) {
3988          FLAG_SET_DEFAULT(MinHeapDeltaBytes, 64*M);
3989       }
3990     }
<span class="line-modified">3991     // UseNUMAInterleaving is set to ON for all collectors and</span>
<span class="line-modified">3992     // platforms when UseNUMA is set to ON. NUMA-aware collectors</span>
<span class="line-modified">3993     // such as the parallel collector for Linux and Solaris will</span>
<span class="line-modified">3994     // interleave old gen and survivor spaces on top of NUMA</span>
<span class="line-modified">3995     // allocation policy for the eden space.</span>
<span class="line-removed">3996     // Non NUMA-aware collectors such as CMS, G1 and Serial-GC on</span>
<span class="line-removed">3997     // all platforms and ParallelGC on Windows will interleave all</span>
<span class="line-removed">3998     // of the heap spaces across NUMA nodes.</span>
3999     if (FLAG_IS_DEFAULT(UseNUMAInterleaving)) {
<span class="line-modified">4000       FLAG_SET_ERGO(bool, UseNUMAInterleaving, true);</span>
4001     }
4002   }
4003   return JNI_OK;
4004 }
4005 
4006 int Arguments::PropertyList_count(SystemProperty* pl) {
4007   int count = 0;
4008   while(pl != NULL) {
4009     count++;
4010     pl = pl-&gt;next();
4011   }
4012   return count;
4013 }
4014 
4015 // Return the number of readable properties.
4016 int Arguments::PropertyList_readable_count(SystemProperty* pl) {
4017   int count = 0;
4018   while(pl != NULL) {
4019     if (pl-&gt;is_readable()) {
4020       count++;
</pre>
</td>
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 1997, 2020, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include &quot;precompiled.hpp&quot;
  26 #include &quot;jvm.h&quot;
  27 #include &quot;classfile/classLoader.hpp&quot;
  28 #include &quot;classfile/javaAssertions.hpp&quot;
  29 #include &quot;classfile/moduleEntry.hpp&quot;
  30 #include &quot;classfile/stringTable.hpp&quot;
  31 #include &quot;classfile/symbolTable.hpp&quot;

  32 #include &quot;gc/shared/gcArguments.hpp&quot;
  33 #include &quot;gc/shared/gcConfig.hpp&quot;
  34 #include &quot;logging/log.hpp&quot;
  35 #include &quot;logging/logConfiguration.hpp&quot;
  36 #include &quot;logging/logStream.hpp&quot;
  37 #include &quot;logging/logTag.hpp&quot;
  38 #include &quot;memory/allocation.inline.hpp&quot;
<span class="line-modified">  39 #include &quot;memory/filemap.hpp&quot;</span>
  40 #include &quot;oops/oop.inline.hpp&quot;
  41 #include &quot;prims/jvmtiExport.hpp&quot;
  42 #include &quot;runtime/arguments.hpp&quot;
  43 #include &quot;runtime/flags/jvmFlag.hpp&quot;
  44 #include &quot;runtime/flags/jvmFlagConstraintList.hpp&quot;

  45 #include &quot;runtime/flags/jvmFlagRangeList.hpp&quot;
  46 #include &quot;runtime/globals_extension.hpp&quot;
  47 #include &quot;runtime/java.hpp&quot;
  48 #include &quot;runtime/os.inline.hpp&quot;
  49 #include &quot;runtime/safepoint.hpp&quot;
  50 #include &quot;runtime/safepointMechanism.hpp&quot;
  51 #include &quot;runtime/vm_version.hpp&quot;
  52 #include &quot;services/management.hpp&quot;
  53 #include &quot;services/memTracker.hpp&quot;
  54 #include &quot;utilities/align.hpp&quot;
  55 #include &quot;utilities/defaultStream.hpp&quot;
  56 #include &quot;utilities/macros.hpp&quot;
<span class="line-added">  57 #include &quot;utilities/powerOfTwo.hpp&quot;</span>
  58 #include &quot;utilities/stringUtils.hpp&quot;



  59 #if INCLUDE_JFR
  60 #include &quot;jfr/jfr.hpp&quot;
  61 #endif
  62 






  63 #define DEFAULT_JAVA_LAUNCHER  &quot;generic&quot;
  64 
  65 char*  Arguments::_jvm_flags_file               = NULL;
  66 char** Arguments::_jvm_flags_array              = NULL;
  67 int    Arguments::_num_jvm_flags                = 0;
  68 char** Arguments::_jvm_args_array               = NULL;
  69 int    Arguments::_num_jvm_args                 = 0;
  70 char*  Arguments::_java_command                 = NULL;
  71 SystemProperty* Arguments::_system_properties   = NULL;
  72 const char*  Arguments::_gc_log_filename        = NULL;
  73 size_t Arguments::_conservative_max_heap_alignment = 0;

  74 Arguments::Mode Arguments::_mode                = _mixed;
  75 bool   Arguments::_java_compiler                = false;
  76 bool   Arguments::_xdebug_mode                  = false;
<span class="line-modified">  77 const char*  Arguments::_java_vendor_url_bug    = NULL;</span>
  78 const char*  Arguments::_sun_java_launcher      = DEFAULT_JAVA_LAUNCHER;

  79 bool   Arguments::_sun_java_launcher_is_altjvm  = false;
  80 
  81 // These parameters are reset in method parse_vm_init_args()
  82 bool   Arguments::_AlwaysCompileLoopMethods     = AlwaysCompileLoopMethods;
  83 bool   Arguments::_UseOnStackReplacement        = UseOnStackReplacement;
  84 bool   Arguments::_BackgroundCompilation        = BackgroundCompilation;
  85 bool   Arguments::_ClipInlining                 = ClipInlining;
  86 intx   Arguments::_Tier3InvokeNotifyFreqLog     = Tier3InvokeNotifyFreqLog;
  87 intx   Arguments::_Tier4InvocationThreshold     = Tier4InvocationThreshold;
<span class="line-added">  88 size_t Arguments::_SharedBaseAddress            = SharedBaseAddress;</span>
  89 
  90 bool   Arguments::_enable_preview               = false;
  91 
  92 char*  Arguments::SharedArchivePath             = NULL;
<span class="line-added">  93 char*  Arguments::SharedDynamicArchivePath      = NULL;</span>
  94 
  95 AgentLibraryList Arguments::_libraryList;
  96 AgentLibraryList Arguments::_agentList;
  97 
  98 // These are not set by the JDK&#39;s built-in launchers, but they can be set by
  99 // programs that embed the JVM using JNI_CreateJavaVM. See comments around
 100 // JavaVMOption in jni.h.
 101 abort_hook_t     Arguments::_abort_hook         = NULL;
 102 exit_hook_t      Arguments::_exit_hook          = NULL;
 103 vfprintf_hook_t  Arguments::_vfprintf_hook      = NULL;
 104 
 105 
 106 SystemProperty *Arguments::_sun_boot_library_path = NULL;
 107 SystemProperty *Arguments::_java_library_path = NULL;
 108 SystemProperty *Arguments::_java_home = NULL;
 109 SystemProperty *Arguments::_java_class_path = NULL;
 110 SystemProperty *Arguments::_jdk_boot_class_path_append = NULL;
 111 SystemProperty *Arguments::_vm_info = NULL;
 112 
 113 GrowableArray&lt;ModulePatchPath*&gt; *Arguments::_patch_mod_prefix = NULL;
</pre>
<hr />
<pre>
 244     return false;
 245   }
 246 }
 247 
 248 // Return true if any of the strings in null-terminated array &#39;names&#39; matches.
 249 // If tail_allowed is true, then the tail must begin with a colon; otherwise,
 250 // the option must match exactly.
 251 static bool match_option(const JavaVMOption* option, const char** names, const char** tail,
 252   bool tail_allowed) {
 253   for (/* empty */; *names != NULL; ++names) {
 254   if (match_option(option, *names, tail)) {
 255       if (**tail == &#39;\0&#39; || (tail_allowed &amp;&amp; **tail == &#39;:&#39;)) {
 256         return true;
 257       }
 258     }
 259   }
 260   return false;
 261 }
 262 
 263 #if INCLUDE_JFR
<span class="line-added"> 264 static bool _has_jfr_option = false;  // is using JFR</span>
<span class="line-added"> 265 </span>
 266 // return true on failure
 267 static bool match_jfr_option(const JavaVMOption** option) {
 268   assert((*option)-&gt;optionString != NULL, &quot;invariant&quot;);
 269   char* tail = NULL;
 270   if (match_option(*option, &quot;-XX:StartFlightRecording&quot;, (const char**)&amp;tail)) {
<span class="line-added"> 271     _has_jfr_option = true;</span>
 272     return Jfr::on_start_flight_recording_option(option, tail);
 273   } else if (match_option(*option, &quot;-XX:FlightRecorderOptions&quot;, (const char**)&amp;tail)) {
<span class="line-added"> 274     _has_jfr_option = true;</span>
 275     return Jfr::on_flight_recorder_option(option, tail);
 276   }
 277   return false;
 278 }
<span class="line-added"> 279 </span>
<span class="line-added"> 280 bool Arguments::has_jfr_option() {</span>
<span class="line-added"> 281   return _has_jfr_option;</span>
<span class="line-added"> 282 }</span>
 283 #endif
 284 
 285 static void logOption(const char* opt) {
 286   if (PrintVMOptions) {
 287     jio_fprintf(defaultStream::output_stream(), &quot;VM option &#39;%s&#39;\n&quot;, opt);
 288   }
 289 }
 290 
 291 bool needs_module_property_warning = false;
 292 
 293 #define MODULE_PROPERTY_PREFIX &quot;jdk.module.&quot;
 294 #define MODULE_PROPERTY_PREFIX_LEN 11
 295 #define ADDEXPORTS &quot;addexports&quot;
 296 #define ADDEXPORTS_LEN 10
 297 #define ADDREADS &quot;addreads&quot;
 298 #define ADDREADS_LEN 8
 299 #define ADDOPENS &quot;addopens&quot;
 300 #define ADDOPENS_LEN 8
 301 #define PATCH &quot;patch&quot;
 302 #define PATCH_LEN 5
</pre>
<hr />
<pre>
 338 bool Arguments::is_internal_module_property(const char* property) {
 339   assert((strncmp(property, &quot;-D&quot;, 2) != 0), &quot;Unexpected leading -D&quot;);
 340   if  (strncmp(property, MODULE_PROPERTY_PREFIX, MODULE_PROPERTY_PREFIX_LEN) == 0) {
 341     const char* property_suffix = property + MODULE_PROPERTY_PREFIX_LEN;
 342     if (matches_property_suffix(property_suffix, ADDEXPORTS, ADDEXPORTS_LEN) ||
 343         matches_property_suffix(property_suffix, ADDREADS, ADDREADS_LEN) ||
 344         matches_property_suffix(property_suffix, ADDOPENS, ADDOPENS_LEN) ||
 345         matches_property_suffix(property_suffix, PATCH, PATCH_LEN) ||
 346         matches_property_suffix(property_suffix, ADDMODS, ADDMODS_LEN) ||
 347         matches_property_suffix(property_suffix, LIMITMODS, LIMITMODS_LEN) ||
 348         matches_property_suffix(property_suffix, PATH, PATH_LEN) ||
 349         matches_property_suffix(property_suffix, UPGRADE_PATH, UPGRADE_PATH_LEN)) {
 350       return true;
 351     }
 352   }
 353   return false;
 354 }
 355 
 356 // Process java launcher properties.
 357 void Arguments::process_sun_java_launcher_properties(JavaVMInitArgs* args) {
<span class="line-modified"> 358   // See if sun.java.launcher or sun.java.launcher.is_altjvm is defined.</span>

 359   // Must do this before setting up other system properties,
 360   // as some of them may depend on launcher type.
 361   for (int index = 0; index &lt; args-&gt;nOptions; index++) {
 362     const JavaVMOption* option = args-&gt;options + index;
 363     const char* tail;
 364 
 365     if (match_option(option, &quot;-Dsun.java.launcher=&quot;, &amp;tail)) {
 366       process_java_launcher_argument(tail, option-&gt;extraInfo);
 367       continue;
 368     }
 369     if (match_option(option, &quot;-Dsun.java.launcher.is_altjvm=&quot;, &amp;tail)) {
 370       if (strcmp(tail, &quot;true&quot;) == 0) {
 371         _sun_java_launcher_is_altjvm = true;
 372       }
 373       continue;
 374     }




 375   }
 376 }
 377 
 378 // Initialize system properties key and value.
 379 void Arguments::init_system_properties() {
 380 
 381   // Set up _system_boot_class_path which is not a property but
 382   // relies heavily on argument processing and the jdk.boot.class.path.append
 383   // property. It is used to store the underlying system boot class path.
 384   _system_boot_class_path = new PathString(NULL);
 385 
 386   PropertyList_add(&amp;_system_properties, new SystemProperty(&quot;java.vm.specification.name&quot;,
 387                                                            &quot;Java Virtual Machine Specification&quot;,  false));
 388   PropertyList_add(&amp;_system_properties, new SystemProperty(&quot;java.vm.version&quot;, VM_Version::vm_release(),  false));
 389   PropertyList_add(&amp;_system_properties, new SystemProperty(&quot;java.vm.name&quot;, VM_Version::vm_name(),  false));
 390   PropertyList_add(&amp;_system_properties, new SystemProperty(&quot;jdk.debug&quot;, VM_Version::jdk_debug_level(),  false));
 391 
 392   // Initialize the vm.info now, but it will need updating after argument parsing.
 393   _vm_info = new SystemProperty(&quot;java.vm.info&quot;, VM_Version::vm_info_string(), true);
 394 
</pre>
<hr />
<pre>
 499 // &quot;deprecated_in&quot; or &quot;obsolete_in&quot; fields may be set to &quot;undefined&quot;, but not both.
 500 // When the JDK version reaches &#39;deprecated_in&#39; limit, the JVM will process this flag on
 501 // the command-line as usual, but will issue a warning.
 502 // When the JDK version reaches &#39;obsolete_in&#39; limit, the JVM will continue accepting this flag on
 503 // the command-line, while issuing a warning and ignoring the flag value.
 504 // Once the JDK version reaches &#39;expired_in&#39; limit, the JVM will flatly refuse to admit the
 505 // existence of the flag.
 506 //
 507 // MANUAL CLEANUP ON JDK VERSION UPDATES:
 508 // This table ensures that the handling of options will update automatically when the JDK
 509 // version is incremented, but the source code needs to be cleanup up manually:
 510 // - As &quot;deprecated&quot; options age into &quot;obsolete&quot; or &quot;expired&quot; options, the associated &quot;globals&quot;
 511 //   variable should be removed, as well as users of the variable.
 512 // - As &quot;deprecated&quot; options age into &quot;obsolete&quot; options, move the entry into the
 513 //   &quot;Obsolete Flags&quot; section of the table.
 514 // - All expired options should be removed from the table.
 515 static SpecialFlag const special_jvm_flags[] = {
 516   // -------------- Deprecated Flags --------------
 517   // --- Non-alias flags - sorted by obsolete_in then expired_in:
 518   { &quot;MaxGCMinorPauseMillis&quot;,        JDK_Version::jdk(8), JDK_Version::undefined(), JDK_Version::undefined() },

 519   { &quot;MaxRAMFraction&quot;,               JDK_Version::jdk(10),  JDK_Version::undefined(), JDK_Version::undefined() },
 520   { &quot;MinRAMFraction&quot;,               JDK_Version::jdk(10),  JDK_Version::undefined(), JDK_Version::undefined() },
 521   { &quot;InitialRAMFraction&quot;,           JDK_Version::jdk(10),  JDK_Version::undefined(), JDK_Version::undefined() },
 522   { &quot;UseMembar&quot;,                    JDK_Version::jdk(10), JDK_Version::jdk(12), JDK_Version::undefined() },
<span class="line-modified"> 523   { &quot;AllowRedefinitionToAddDeleteMethods&quot;, JDK_Version::jdk(13), JDK_Version::undefined(), JDK_Version::undefined() },</span>
<span class="line-modified"> 524   { &quot;FlightRecorder&quot;,               JDK_Version::jdk(13), JDK_Version::undefined(), JDK_Version::undefined() },</span>
<span class="line-modified"> 525   { &quot;MonitorBound&quot;,                 JDK_Version::jdk(14), JDK_Version::jdk(15), JDK_Version::jdk(16) },</span>
<span class="line-added"> 526   { &quot;PrintVMQWaitTime&quot;,             JDK_Version::jdk(15), JDK_Version::jdk(16), JDK_Version::jdk(17) },</span>
<span class="line-added"> 527   { &quot;UseNewFieldLayout&quot;,            JDK_Version::jdk(15), JDK_Version::jdk(16), JDK_Version::jdk(17) },</span>
 528 
 529   // --- Deprecated alias flags (see also aliased_jvm_flags) - sorted by obsolete_in then expired_in:
 530   { &quot;DefaultMaxRAMFraction&quot;,        JDK_Version::jdk(8),  JDK_Version::undefined(), JDK_Version::undefined() },
 531   { &quot;CreateMinidumpOnCrash&quot;,        JDK_Version::jdk(9),  JDK_Version::undefined(), JDK_Version::undefined() },
 532   { &quot;TLABStats&quot;,                    JDK_Version::jdk(12), JDK_Version::undefined(), JDK_Version::undefined() },
 533 
 534   // -------------- Obsolete Flags - sorted by expired_in --------------
 535   { &quot;PermSize&quot;,                      JDK_Version::undefined(), JDK_Version::jdk(8),  JDK_Version::undefined() },
 536   { &quot;MaxPermSize&quot;,                   JDK_Version::undefined(), JDK_Version::jdk(8),  JDK_Version::undefined() },
 537   { &quot;SharedReadWriteSize&quot;,           JDK_Version::undefined(), JDK_Version::jdk(10), JDK_Version::undefined() },
 538   { &quot;SharedReadOnlySize&quot;,            JDK_Version::undefined(), JDK_Version::jdk(10), JDK_Version::undefined() },
 539   { &quot;SharedMiscDataSize&quot;,            JDK_Version::undefined(), JDK_Version::jdk(10), JDK_Version::undefined() },
 540   { &quot;SharedMiscCodeSize&quot;,            JDK_Version::undefined(), JDK_Version::jdk(10), JDK_Version::undefined() },
<span class="line-modified"> 541   { &quot;BindGCTaskThreadsToCPUs&quot;,       JDK_Version::undefined(), JDK_Version::jdk(14), JDK_Version::jdk(16) },</span>
<span class="line-modified"> 542   { &quot;UseGCTaskAffinity&quot;,             JDK_Version::undefined(), JDK_Version::jdk(14), JDK_Version::jdk(16) },</span>
<span class="line-modified"> 543   { &quot;GCTaskTimeStampEntries&quot;,        JDK_Version::undefined(), JDK_Version::jdk(14), JDK_Version::jdk(16) },</span>
<span class="line-modified"> 544   { &quot;G1RSetScanBlockSize&quot;,           JDK_Version::jdk(14),     JDK_Version::jdk(15), JDK_Version::jdk(16) },</span>
<span class="line-modified"> 545   { &quot;UseParallelOldGC&quot;,              JDK_Version::jdk(14),     JDK_Version::jdk(15), JDK_Version::jdk(16) },</span>
<span class="line-modified"> 546   { &quot;CompactFields&quot;,                 JDK_Version::jdk(14),     JDK_Version::jdk(15), JDK_Version::jdk(16) },</span>
<span class="line-modified"> 547   { &quot;FieldsAllocationStyle&quot;,         JDK_Version::jdk(14),     JDK_Version::jdk(15), JDK_Version::jdk(16) },</span>




 548 
 549 #ifdef TEST_VERIFY_SPECIAL_JVM_FLAGS
 550   // These entries will generate build errors.  Their purpose is to test the macros.
 551   { &quot;dep &gt; obs&quot;,                    JDK_Version::jdk(9), JDK_Version::jdk(8), JDK_Version::undefined() },
 552   { &quot;dep &gt; exp &quot;,                   JDK_Version::jdk(9), JDK_Version::undefined(), JDK_Version::jdk(8) },
 553   { &quot;obs &gt; exp &quot;,                   JDK_Version::undefined(), JDK_Version::jdk(9), JDK_Version::jdk(8) },
<span class="line-added"> 554   { &quot;obs &gt; exp&quot;,                    JDK_Version::jdk(8), JDK_Version::undefined(), JDK_Version::jdk(10) },</span>
 555   { &quot;not deprecated or obsolete&quot;,   JDK_Version::undefined(), JDK_Version::undefined(), JDK_Version::jdk(9) },
 556   { &quot;dup option&quot;,                   JDK_Version::jdk(9), JDK_Version::undefined(), JDK_Version::undefined() },
 557   { &quot;dup option&quot;,                   JDK_Version::jdk(9), JDK_Version::undefined(), JDK_Version::undefined() },
 558 #endif
 559 
 560   { NULL, JDK_Version(0), JDK_Version(0) }
 561 };
 562 
 563 // Flags that are aliases for other flags.
 564 typedef struct {
 565   const char* alias_name;
 566   const char* real_name;
 567 } AliasedFlag;
 568 
 569 static AliasedFlag const aliased_jvm_flags[] = {
 570   { &quot;DefaultMaxRAMFraction&quot;,    &quot;MaxRAMFraction&quot;    },
 571   { &quot;CreateMinidumpOnCrash&quot;,    &quot;CreateCoredumpOnCrash&quot; },
 572   { NULL, NULL}
 573 };
 574 
 575 // NOTE: A compatibility request will be necessary for each alias to be removed.
 576 static AliasedLoggingFlag const aliased_logging_flags[] = {
 577   { &quot;PrintCompressedOopsMode&quot;,   LogLevel::Info,  true,  LOG_TAGS(gc, heap, coops) },
 578   { &quot;PrintSharedSpaces&quot;,         LogLevel::Info,  true,  LOG_TAGS(cds) },
 579   { &quot;TraceBiasedLocking&quot;,        LogLevel::Info,  true,  LOG_TAGS(biasedlocking) },
 580   { &quot;TraceClassLoading&quot;,         LogLevel::Info,  true,  LOG_TAGS(class, load) },
 581   { &quot;TraceClassLoadingPreorder&quot;, LogLevel::Debug, true,  LOG_TAGS(class, preorder) },
 582   { &quot;TraceClassPaths&quot;,           LogLevel::Info,  true,  LOG_TAGS(class, path) },
 583   { &quot;TraceClassResolution&quot;,      LogLevel::Debug, true,  LOG_TAGS(class, resolve) },
 584   { &quot;TraceClassUnloading&quot;,       LogLevel::Info,  true,  LOG_TAGS(class, unload) },
 585   { &quot;TraceExceptions&quot;,           LogLevel::Info,  true,  LOG_TAGS(exceptions) },
 586   { &quot;TraceLoaderConstraints&quot;,    LogLevel::Info,  true,  LOG_TAGS(class, loader, constraints) },
 587   { &quot;TraceMonitorInflation&quot;,     LogLevel::Trace, true,  LOG_TAGS(monitorinflation) },
 588   { &quot;TraceSafepointCleanupTime&quot;, LogLevel::Info,  true,  LOG_TAGS(safepoint, cleanup) },
 589   { &quot;TraceJVMTIObjectTagging&quot;,   LogLevel::Debug, true,  LOG_TAGS(jvmti, objecttagging) },
 590   { &quot;TraceRedefineClasses&quot;,      LogLevel::Info,  false, LOG_TAGS(redefine, class) },
<span class="line-added"> 591   { &quot;PrintJNIResolving&quot;,         LogLevel::Debug, true,  LOG_TAGS(jni, resolve) },</span>
 592   { NULL,                        LogLevel::Off,   false, LOG_TAGS(_NO_TAG) }
 593 };
 594 
 595 #ifndef PRODUCT
 596 // These options are removed in jdk9. Remove this code for jdk10.
 597 static AliasedFlag const removed_develop_logging_flags[] = {
 598   { &quot;TraceClassInitialization&quot;,   &quot;-Xlog:class+init&quot; },
 599   { &quot;TraceClassLoaderData&quot;,       &quot;-Xlog:class+loader+data&quot; },
 600   { &quot;TraceDefaultMethods&quot;,        &quot;-Xlog:defaultmethods=debug&quot; },
 601   { &quot;TraceItables&quot;,               &quot;-Xlog:itables=debug&quot; },
 602   { &quot;TraceMonitorMismatch&quot;,       &quot;-Xlog:monitormismatch=info&quot; },
 603   { &quot;TraceSafepoint&quot;,             &quot;-Xlog:safepoint=debug&quot; },
 604   { &quot;TraceStartupTime&quot;,           &quot;-Xlog:startuptime&quot; },
 605   { &quot;TraceVMOperation&quot;,           &quot;-Xlog:vmoperation=debug&quot; },
 606   { &quot;PrintVtables&quot;,               &quot;-Xlog:vtables=debug&quot; },
 607   { &quot;VerboseVerification&quot;,        &quot;-Xlog:verification&quot; },
 608   { NULL, NULL }
 609 };
 610 #endif //PRODUCT
 611 
 612 // Return true if &quot;v&quot; is less than &quot;other&quot;, where &quot;other&quot; may be &quot;undefined&quot;.
 613 static bool version_less_than(JDK_Version v, JDK_Version other) {
 614   assert(!v.is_undefined(), &quot;must be defined&quot;);
 615   if (!other.is_undefined() &amp;&amp; v.compare(other) &gt;= 0) {
 616     return false;
 617   } else {
 618     return true;
 619   }
 620 }
 621 







 622 static bool lookup_special_flag(const char *flag_name, SpecialFlag&amp; flag) {
 623   for (size_t i = 0; special_jvm_flags[i].name != NULL; i++) {
 624     if ((strcmp(special_jvm_flags[i].name, flag_name) == 0)) {
 625       flag = special_jvm_flags[i];
 626       return true;
 627     }
 628   }
 629   return false;
 630 }
 631 
 632 bool Arguments::is_obsolete_flag(const char *flag_name, JDK_Version* version) {
 633   assert(version != NULL, &quot;Must provide a version buffer&quot;);
 634   SpecialFlag flag;
 635   if (lookup_special_flag(flag_name, flag)) {
 636     if (!flag.obsolete_in.is_undefined()) {
 637       if (!version_less_than(JDK_Version::current(), flag.obsolete_in)) {
 638         *version = flag.obsolete_in;
<span class="line-added"> 639         // This flag may have been marked for obsoletion in this version, but we may not</span>
<span class="line-added"> 640         // have actually removed it yet. Rather than ignoring it as soon as we reach</span>
<span class="line-added"> 641         // this version we allow some time for the removal to happen. So if the flag</span>
<span class="line-added"> 642         // still actually exists we process it as normal, but issue an adjusted warning.</span>
<span class="line-added"> 643         const JVMFlag *real_flag = JVMFlag::find_declared_flag(flag_name);</span>
<span class="line-added"> 644         if (real_flag != NULL) {</span>
<span class="line-added"> 645           char version_str[256];</span>
<span class="line-added"> 646           version-&gt;to_string(version_str, sizeof(version_str));</span>
<span class="line-added"> 647           warning(&quot;Temporarily processing option %s; support is scheduled for removal in %s&quot;,</span>
<span class="line-added"> 648                   flag_name, version_str);</span>
<span class="line-added"> 649           return false;</span>
<span class="line-added"> 650         }</span>
 651         return true;
 652       }
 653     }
 654   }
 655   return false;
 656 }
 657 
 658 int Arguments::is_deprecated_flag(const char *flag_name, JDK_Version* version) {
 659   assert(version != NULL, &quot;Must provide a version buffer&quot;);
 660   SpecialFlag flag;
 661   if (lookup_special_flag(flag_name, flag)) {
 662     if (!flag.deprecated_in.is_undefined()) {
 663       if (version_less_than(JDK_Version::current(), flag.obsolete_in) &amp;&amp;
 664           version_less_than(JDK_Version::current(), flag.expired_in)) {
 665         *version = flag.deprecated_in;
 666         return 1;
 667       } else {
 668         return -1;
 669       }
 670     }
</pre>
<hr />
<pre>
 691         return flag_status.real_name;
 692     }
 693   }
 694   return flag_name;
 695 }
 696 
 697 #ifdef ASSERT
 698 static bool lookup_special_flag(const char *flag_name, size_t skip_index) {
 699   for (size_t i = 0; special_jvm_flags[i].name != NULL; i++) {
 700     if ((i != skip_index) &amp;&amp; (strcmp(special_jvm_flags[i].name, flag_name) == 0)) {
 701       return true;
 702     }
 703   }
 704   return false;
 705 }
 706 
 707 // Verifies the correctness of the entries in the special_jvm_flags table.
 708 // If there is a semantic error (i.e. a bug in the table) such as the obsoletion
 709 // version being earlier than the deprecation version, then a warning is issued
 710 // and verification fails - by returning false. If it is detected that the table
<span class="line-modified"> 711 // is out of date, with respect to the current version, then ideally a warning is</span>
<span class="line-modified"> 712 // issued but verification does not fail. This allows the VM to operate when the</span>
<span class="line-modified"> 713 // version is first updated, without needing to update all the impacted flags at</span>
<span class="line-modified"> 714 // the same time. In practice we can&#39;t issue the warning immediately when the version</span>
<span class="line-modified"> 715 // is updated as it occurs for every test and some tests are not prepared to handle</span>
<span class="line-added"> 716 // unexpected output - see 8196739. Instead we only check if the table is up-to-date</span>
<span class="line-added"> 717 // if the check_globals flag is true, and in addition allow a grace period and only</span>
<span class="line-added"> 718 // check for stale flags when we hit build 20 (which is far enough into the 6 month</span>
<span class="line-added"> 719 // release cycle that all flag updates should have been processed, whilst still</span>
<span class="line-added"> 720 // leaving time to make the change before RDP2).</span>
<span class="line-added"> 721 // We use a gtest to call this, passing true, so that we can detect stale flags before</span>
<span class="line-added"> 722 // the end of the release cycle.</span>
<span class="line-added"> 723 </span>
<span class="line-added"> 724 static const int SPECIAL_FLAG_VALIDATION_BUILD = 20;</span>
<span class="line-added"> 725 </span>
<span class="line-added"> 726 bool Arguments::verify_special_jvm_flags(bool check_globals) {</span>
 727   bool success = true;
 728   for (size_t i = 0; special_jvm_flags[i].name != NULL; i++) {
 729     const SpecialFlag&amp; flag = special_jvm_flags[i];
 730     if (lookup_special_flag(flag.name, i)) {
 731       warning(&quot;Duplicate special flag declaration \&quot;%s\&quot;&quot;, flag.name);
 732       success = false;
 733     }
 734     if (flag.deprecated_in.is_undefined() &amp;&amp;
 735         flag.obsolete_in.is_undefined()) {
 736       warning(&quot;Special flag entry \&quot;%s\&quot; must declare version deprecated and/or obsoleted in.&quot;, flag.name);
 737       success = false;
 738     }
 739 
 740     if (!flag.deprecated_in.is_undefined()) {
 741       if (!version_less_than(flag.deprecated_in, flag.obsolete_in)) {
 742         warning(&quot;Special flag entry \&quot;%s\&quot; must be deprecated before obsoleted.&quot;, flag.name);
 743         success = false;
 744       }
 745 
 746       if (!version_less_than(flag.deprecated_in, flag.expired_in)) {
 747         warning(&quot;Special flag entry \&quot;%s\&quot; must be deprecated before expired.&quot;, flag.name);
 748         success = false;
 749       }
 750     }
 751 
 752     if (!flag.obsolete_in.is_undefined()) {
 753       if (!version_less_than(flag.obsolete_in, flag.expired_in)) {
 754         warning(&quot;Special flag entry \&quot;%s\&quot; must be obsoleted before expired.&quot;, flag.name);
 755         success = false;
 756       }
 757 
 758       // if flag has become obsolete it should not have a &quot;globals&quot; flag defined anymore.
<span class="line-modified"> 759       if (check_globals &amp;&amp; VM_Version::vm_build_number() &gt;= SPECIAL_FLAG_VALIDATION_BUILD &amp;&amp;</span>
<span class="line-modified"> 760           !version_less_than(JDK_Version::current(), flag.obsolete_in)) {</span>
<span class="line-modified"> 761         if (JVMFlag::find_declared_flag(flag.name) != NULL) {</span>
<span class="line-modified"> 762           warning(&quot;Global variable for obsolete special flag entry \&quot;%s\&quot; should be removed&quot;, flag.name);</span>
<span class="line-added"> 763           success = false;</span>
 764         }
 765       }
<span class="line-added"> 766 </span>
<span class="line-added"> 767     } else if (!flag.expired_in.is_undefined()) {</span>
<span class="line-added"> 768       warning(&quot;Special flag entry \&quot;%s\&quot; must be explicitly obsoleted before expired.&quot;, flag.name);</span>
<span class="line-added"> 769       success = false;</span>
 770     }
 771 
 772     if (!flag.expired_in.is_undefined()) {
 773       // if flag has become expired it should not have a &quot;globals&quot; flag defined anymore.
<span class="line-modified"> 774       if (check_globals &amp;&amp; VM_Version::vm_build_number() &gt;= SPECIAL_FLAG_VALIDATION_BUILD &amp;&amp;</span>
<span class="line-modified"> 775           !version_less_than(JDK_Version::current(), flag.expired_in)) {</span>
<span class="line-modified"> 776         if (JVMFlag::find_declared_flag(flag.name) != NULL) {</span>
<span class="line-modified"> 777           warning(&quot;Global variable for expired flag entry \&quot;%s\&quot; should be removed&quot;, flag.name);</span>
<span class="line-added"> 778           success = false;</span>
 779         }
 780       }
 781     }

 782   }
 783   return success;
 784 }
 785 #endif
 786 
 787 // Parses a size specification string.
 788 bool Arguments::atojulong(const char *s, julong* result) {
 789   julong n = 0;
 790 
 791   // First char must be a digit. Don&#39;t allow negative numbers or leading spaces.
 792   if (!isdigit(*s)) {
 793     return false;
 794   }
 795 
 796   bool is_hex = (s[0] == &#39;0&#39; &amp;&amp; (s[1] == &#39;x&#39; || s[1] == &#39;X&#39;));
 797   char* remainder;
 798   errno = 0;
 799   n = strtoull(s, &amp;remainder, (is_hex ? 16 : 10));
 800   if (errno != 0) {
 801     return false;
</pre>
<hr />
<pre>
 839 }
 840 
 841 // Describe an argument out of range error
 842 void Arguments::describe_range_error(ArgsRange errcode) {
 843   switch(errcode) {
 844   case arg_too_big:
 845     jio_fprintf(defaultStream::error_stream(),
 846                 &quot;The specified size exceeds the maximum &quot;
 847                 &quot;representable size.\n&quot;);
 848     break;
 849   case arg_too_small:
 850   case arg_unreadable:
 851   case arg_in_range:
 852     // do nothing for now
 853     break;
 854   default:
 855     ShouldNotReachHere();
 856   }
 857 }
 858 
<span class="line-modified"> 859 static bool set_bool_flag(JVMFlag* flag, bool value, JVMFlag::Flags origin) {</span>
<span class="line-modified"> 860   if (JVMFlag::boolAtPut(flag, &amp;value, origin) == JVMFlag::SUCCESS) {</span>
 861     return true;
 862   } else {
 863     return false;
 864   }
 865 }
 866 
<span class="line-modified"> 867 static bool set_fp_numeric_flag(JVMFlag* flag, char* value, JVMFlag::Flags origin) {</span>
 868   char* end;
 869   errno = 0;
 870   double v = strtod(value, &amp;end);
 871   if ((errno != 0) || (*end != 0)) {
 872     return false;
 873   }
 874 
<span class="line-modified"> 875   if (JVMFlag::doubleAtPut(flag, &amp;v, origin) == JVMFlag::SUCCESS) {</span>
 876     return true;
 877   }
 878   return false;
 879 }
 880 
<span class="line-modified"> 881 static bool set_numeric_flag(JVMFlag* flag, char* value, JVMFlag::Flags origin) {</span>
 882   julong v;
 883   int int_v;
 884   intx intx_v;
 885   bool is_neg = false;
<span class="line-modified"> 886 </span>

 887   if (flag == NULL) {
 888     return false;
 889   }
 890 
 891   // Check the sign first since atojulong() parses only unsigned values.
 892   if (*value == &#39;-&#39;) {
<span class="line-modified"> 893     if (!flag-&gt;is_intx() &amp;&amp; !flag-&gt;is_int()) {</span>
 894       return false;
 895     }
 896     value++;
 897     is_neg = true;
 898   }
 899   if (!Arguments::atojulong(value, &amp;v)) {
 900     return false;
 901   }
<span class="line-modified"> 902   if (flag-&gt;is_int()) {</span>
 903     int_v = (int) v;
 904     if (is_neg) {
 905       int_v = -int_v;
 906     }
<span class="line-modified"> 907     return JVMFlag::intAtPut(flag, &amp;int_v, origin) == JVMFlag::SUCCESS;</span>
<span class="line-modified"> 908   } else if (flag-&gt;is_uint()) {</span>
 909     uint uint_v = (uint) v;
<span class="line-modified"> 910     return JVMFlag::uintAtPut(flag, &amp;uint_v, origin) == JVMFlag::SUCCESS;</span>
<span class="line-modified"> 911   } else if (flag-&gt;is_intx()) {</span>
 912     intx_v = (intx) v;
 913     if (is_neg) {
 914       intx_v = -intx_v;
 915     }
<span class="line-modified"> 916     return JVMFlag::intxAtPut(flag, &amp;intx_v, origin) == JVMFlag::SUCCESS;</span>
<span class="line-modified"> 917   } else if (flag-&gt;is_uintx()) {</span>
 918     uintx uintx_v = (uintx) v;
<span class="line-modified"> 919     return JVMFlag::uintxAtPut(flag, &amp;uintx_v, origin) == JVMFlag::SUCCESS;</span>
<span class="line-modified"> 920   } else if (flag-&gt;is_uint64_t()) {</span>
 921     uint64_t uint64_t_v = (uint64_t) v;
<span class="line-modified"> 922     return JVMFlag::uint64_tAtPut(flag, &amp;uint64_t_v, origin) == JVMFlag::SUCCESS;</span>
<span class="line-modified"> 923   } else if (flag-&gt;is_size_t()) {</span>
 924     size_t size_t_v = (size_t) v;
<span class="line-modified"> 925     return JVMFlag::size_tAtPut(flag, &amp;size_t_v, origin) == JVMFlag::SUCCESS;</span>
<span class="line-modified"> 926   } else if (flag-&gt;is_double()) {</span>
 927     double double_v = (double) v;
<span class="line-modified"> 928     return JVMFlag::doubleAtPut(flag, &amp;double_v, origin) == JVMFlag::SUCCESS;</span>
 929   } else {
 930     return false;
 931   }
 932 }
 933 
<span class="line-modified"> 934 static bool set_string_flag(JVMFlag* flag, const char* value, JVMFlag::Flags origin) {</span>
<span class="line-modified"> 935   if (JVMFlag::ccstrAtPut(flag, &amp;value, origin) != JVMFlag::SUCCESS) return false;</span>
 936   // Contract:  JVMFlag always returns a pointer that needs freeing.
 937   FREE_C_HEAP_ARRAY(char, value);
 938   return true;
 939 }
 940 
<span class="line-modified"> 941 static bool append_to_string_flag(JVMFlag* flag, const char* new_value, JVMFlag::Flags origin) {</span>
 942   const char* old_value = &quot;&quot;;
<span class="line-modified"> 943   if (JVMFlag::ccstrAt(flag, &amp;old_value) != JVMFlag::SUCCESS) return false;</span>
 944   size_t old_len = old_value != NULL ? strlen(old_value) : 0;
 945   size_t new_len = strlen(new_value);
 946   const char* value;
 947   char* free_this_too = NULL;
 948   if (old_len == 0) {
 949     value = new_value;
 950   } else if (new_len == 0) {
 951     value = old_value;
 952   } else {
 953      size_t length = old_len + 1 + new_len + 1;
 954      char* buf = NEW_C_HEAP_ARRAY(char, length, mtArguments);
 955     // each new setting adds another LINE to the switch:
 956     jio_snprintf(buf, length, &quot;%s\n%s&quot;, old_value, new_value);
 957     value = buf;
 958     free_this_too = buf;
 959   }
<span class="line-modified"> 960   (void) JVMFlag::ccstrAtPut(flag, &amp;value, origin);</span>
 961   // JVMFlag always returns a pointer that needs freeing.
 962   FREE_C_HEAP_ARRAY(char, value);
<span class="line-modified"> 963   // JVMFlag made its own copy, so I must delete my own temp. buffer.</span>
<span class="line-modified"> 964   FREE_C_HEAP_ARRAY(char, free_this_too);</span>


 965   return true;
 966 }
 967 
 968 const char* Arguments::handle_aliases_and_deprecation(const char* arg, bool warn) {
 969   const char* real_name = real_flag_name(arg);
 970   JDK_Version since = JDK_Version();
 971   switch (is_deprecated_flag(arg, &amp;since)) {
<span class="line-modified"> 972   case -1: {</span>
<span class="line-modified"> 973       // Obsolete or expired, so don&#39;t process normally,</span>
<span class="line-added"> 974       // but allow for an obsolete flag we&#39;re still</span>
<span class="line-added"> 975       // temporarily allowing.</span>
<span class="line-added"> 976       if (!is_obsolete_flag(arg, &amp;since)) {</span>
<span class="line-added"> 977         return real_name;</span>
<span class="line-added"> 978       }</span>
<span class="line-added"> 979       // Note if we&#39;re not considered obsolete then we can&#39;t be expired either</span>
<span class="line-added"> 980       // as obsoletion must come first.</span>
<span class="line-added"> 981       return NULL;</span>
<span class="line-added"> 982     }</span>
 983     case 0:
 984       return real_name;
 985     case 1: {
 986       if (warn) {
 987         char version[256];
 988         since.to_string(version, sizeof(version));
 989         if (real_name != arg) {
 990           warning(&quot;Option %s was deprecated in version %s and will likely be removed in a future release. Use option %s instead.&quot;,
 991                   arg, version, real_name);
 992         } else {
 993           warning(&quot;Option %s was deprecated in version %s and will likely be removed in a future release.&quot;,
 994                   arg, version);
 995         }
 996       }
 997       return real_name;
 998     }
 999   }
1000   ShouldNotReachHere();
1001   return NULL;
1002 }
</pre>
<hr />
<pre>
1042 bool Arguments::parse_argument(const char* arg, JVMFlag::Flags origin) {
1043 
1044   // range of acceptable characters spelled out for portability reasons
1045 #define NAME_RANGE  &quot;[abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789_]&quot;
1046 #define BUFLEN 255
1047   char name[BUFLEN+1];
1048   char dummy;
1049   const char* real_name;
1050   bool warn_if_deprecated = true;
1051 
1052   if (sscanf(arg, &quot;-%&quot; XSTR(BUFLEN) NAME_RANGE &quot;%c&quot;, name, &amp;dummy) == 1) {
1053     AliasedLoggingFlag alf = catch_logging_aliases(name, false);
1054     if (alf.alias_name != NULL){
1055       LogConfiguration::configure_stdout(LogLevel::Off, alf.exactMatch, alf.tag0, alf.tag1, alf.tag2, alf.tag3, alf.tag4, alf.tag5);
1056       return true;
1057     }
1058     real_name = handle_aliases_and_deprecation(name, warn_if_deprecated);
1059     if (real_name == NULL) {
1060       return false;
1061     }
<span class="line-modified">1062     JVMFlag* flag = JVMFlag::find_flag(real_name);</span>
<span class="line-added">1063     return set_bool_flag(flag, false, origin);</span>
1064   }
1065   if (sscanf(arg, &quot;+%&quot; XSTR(BUFLEN) NAME_RANGE &quot;%c&quot;, name, &amp;dummy) == 1) {
1066     AliasedLoggingFlag alf = catch_logging_aliases(name, true);
1067     if (alf.alias_name != NULL){
1068       LogConfiguration::configure_stdout(alf.level, alf.exactMatch, alf.tag0, alf.tag1, alf.tag2, alf.tag3, alf.tag4, alf.tag5);
1069       return true;
1070     }
1071     real_name = handle_aliases_and_deprecation(name, warn_if_deprecated);
1072     if (real_name == NULL) {
1073       return false;
1074     }
<span class="line-modified">1075     JVMFlag* flag = JVMFlag::find_flag(real_name);</span>
<span class="line-added">1076     return set_bool_flag(flag, true, origin);</span>
1077   }
1078 
1079   char punct;
1080   if (sscanf(arg, &quot;%&quot; XSTR(BUFLEN) NAME_RANGE &quot;%c&quot;, name, &amp;punct) == 2 &amp;&amp; punct == &#39;=&#39;) {
1081     const char* value = strchr(arg, &#39;=&#39;) + 1;

1082 
1083     // this scanf pattern matches both strings (handled here) and numbers (handled later))
1084     AliasedLoggingFlag alf = catch_logging_aliases(name, true);
1085     if (alf.alias_name != NULL) {
1086       LogConfiguration::configure_stdout(alf.level, alf.exactMatch, alf.tag0, alf.tag1, alf.tag2, alf.tag3, alf.tag4, alf.tag5);
1087       return true;
1088     }
1089     real_name = handle_aliases_and_deprecation(name, warn_if_deprecated);
1090     if (real_name == NULL) {
1091       return false;
1092     }
<span class="line-modified">1093     JVMFlag* flag = JVMFlag::find_flag(real_name);</span>
1094     if (flag != NULL &amp;&amp; flag-&gt;is_ccstr()) {
1095       if (flag-&gt;ccstr_accumulates()) {
<span class="line-modified">1096         return append_to_string_flag(flag, value, origin);</span>
1097       } else {
1098         if (value[0] == &#39;\0&#39;) {
1099           value = NULL;
1100         }
<span class="line-modified">1101         return set_string_flag(flag, value, origin);</span>
1102       }
1103     } else {
1104       warn_if_deprecated = false; // if arg is deprecated, we&#39;ve already done warning...
1105     }
1106   }
1107 
1108   if (sscanf(arg, &quot;%&quot; XSTR(BUFLEN) NAME_RANGE &quot;:%c&quot;, name, &amp;punct) == 2 &amp;&amp; punct == &#39;=&#39;) {
1109     const char* value = strchr(arg, &#39;=&#39;) + 1;
1110     // -XX:Foo:=xxx will reset the string flag to the given value.
1111     if (value[0] == &#39;\0&#39;) {
1112       value = NULL;
1113     }
1114     real_name = handle_aliases_and_deprecation(name, warn_if_deprecated);
1115     if (real_name == NULL) {
1116       return false;
1117     }
<span class="line-modified">1118     JVMFlag* flag = JVMFlag::find_flag(real_name);</span>
<span class="line-added">1119     return set_string_flag(flag, value, origin);</span>
1120   }
1121 
1122 #define SIGNED_FP_NUMBER_RANGE &quot;[-0123456789.eE+]&quot;
1123 #define SIGNED_NUMBER_RANGE    &quot;[-0123456789]&quot;
1124 #define        NUMBER_RANGE    &quot;[0123456789eE+-]&quot;
1125   char value[BUFLEN + 1];
1126   char value2[BUFLEN + 1];
1127   if (sscanf(arg, &quot;%&quot; XSTR(BUFLEN) NAME_RANGE &quot;=&quot; &quot;%&quot; XSTR(BUFLEN) SIGNED_NUMBER_RANGE &quot;.&quot; &quot;%&quot; XSTR(BUFLEN) NUMBER_RANGE &quot;%c&quot;, name, value, value2, &amp;dummy) == 3) {
1128     // Looks like a floating-point number -- try again with more lenient format string
1129     if (sscanf(arg, &quot;%&quot; XSTR(BUFLEN) NAME_RANGE &quot;=&quot; &quot;%&quot; XSTR(BUFLEN) SIGNED_FP_NUMBER_RANGE &quot;%c&quot;, name, value, &amp;dummy) == 2) {
1130       real_name = handle_aliases_and_deprecation(name, warn_if_deprecated);
1131       if (real_name == NULL) {
1132         return false;
1133       }
<span class="line-modified">1134       JVMFlag* flag = JVMFlag::find_flag(real_name);</span>
<span class="line-added">1135       return set_fp_numeric_flag(flag, value, origin);</span>
1136     }
1137   }
1138 
1139 #define VALUE_RANGE &quot;[-kmgtxKMGTX0123456789abcdefABCDEF]&quot;
1140   if (sscanf(arg, &quot;%&quot; XSTR(BUFLEN) NAME_RANGE &quot;=&quot; &quot;%&quot; XSTR(BUFLEN) VALUE_RANGE &quot;%c&quot;, name, value, &amp;dummy) == 2) {
1141     real_name = handle_aliases_and_deprecation(name, warn_if_deprecated);
1142     if (real_name == NULL) {
1143       return false;
1144     }
<span class="line-modified">1145     JVMFlag* flag = JVMFlag::find_flag(real_name);</span>
<span class="line-added">1146     return set_numeric_flag(flag, value, origin);</span>
1147   }
1148 
1149   return false;
1150 }
1151 
1152 void Arguments::add_string(char*** bldarray, int* count, const char* arg) {
1153   assert(bldarray != NULL, &quot;illegal argument&quot;);
1154 
1155   if (arg == NULL) {
1156     return;
1157   }
1158 
1159   int new_count = *count + 1;
1160 
1161   // expand the array and add arg to the last element
1162   if (*bldarray == NULL) {
1163     *bldarray = NEW_C_HEAP_ARRAY(char*, new_count, mtArguments);
1164   } else {
1165     *bldarray = REALLOC_C_HEAP_ARRAY(char*, *bldarray, new_count, mtArguments);
1166   }
</pre>
<hr />
<pre>
1282       char version[256];
1283       since.to_string(version, sizeof(version));
1284       warning(&quot;Ignoring option %s; support was removed in %s&quot;, stripped_argname, version);
1285       return true;
1286     }
1287 #ifndef PRODUCT
1288     else {
1289       const char* replacement;
1290       if ((replacement = removed_develop_logging_flag_name(stripped_argname)) != NULL){
1291         log_warning(arguments)(&quot;%s has been removed. Please use %s instead.&quot;,
1292                                stripped_argname,
1293                                replacement);
1294         return false;
1295       }
1296     }
1297 #endif //PRODUCT
1298   }
1299 
1300   // For locked flags, report a custom error message if available.
1301   // Otherwise, report the standard unrecognized VM option.
<span class="line-modified">1302   const JVMFlag* found_flag = JVMFlag::find_declared_flag((const char*)argname, arg_len);</span>
1303   if (found_flag != NULL) {
1304     char locked_message_buf[BUFLEN];
1305     JVMFlag::MsgType msg_type = found_flag-&gt;get_locked_message(locked_message_buf, BUFLEN);
1306     if (strlen(locked_message_buf) == 0) {
1307       if (found_flag-&gt;is_bool() &amp;&amp; !has_plus_minus) {
1308         jio_fprintf(defaultStream::error_stream(),
1309           &quot;Missing +/- setting for VM option &#39;%s&#39;\n&quot;, argname);
1310       } else if (!found_flag-&gt;is_bool() &amp;&amp; has_plus_minus) {
1311         jio_fprintf(defaultStream::error_stream(),
1312           &quot;Unexpected +/- setting in VM option &#39;%s&#39;\n&quot;, argname);
1313       } else {
1314         jio_fprintf(defaultStream::error_stream(),
1315           &quot;Improperly specified VM option &#39;%s&#39;\n&quot;, argname);
1316       }
1317     } else {
1318 #ifdef PRODUCT
1319       bool mismatched = ((msg_type == JVMFlag::NOTPRODUCT_FLAG_BUT_PRODUCT_BUILD) ||
1320                          (msg_type == JVMFlag::DEVELOPER_FLAG_BUT_PRODUCT_BUILD));
1321       if (ignore_unrecognized &amp;&amp; mismatched) {
1322         return true;
</pre>
<hr />
<pre>
1421   const char* value = &quot;&quot;;
1422 
1423   if (eq == NULL) {
1424     // property doesn&#39;t have a value, thus use passed string
1425     key = prop;
1426   } else {
1427     // property have a value, thus extract it and save to the
1428     // allocated string
1429     size_t key_len = eq - prop;
1430     char* tmp_key = AllocateHeap(key_len + 1, mtArguments);
1431 
1432     jio_snprintf(tmp_key, key_len + 1, &quot;%s&quot;, prop);
1433     key = tmp_key;
1434 
1435     value = &amp;prop[key_len + 1];
1436   }
1437 
1438   if (strcmp(key, &quot;java.compiler&quot;) == 0) {
1439     process_java_compiler_argument(value);
1440     // Record value in Arguments, but let it get passed to Java.
<span class="line-modified">1441   } else if (strcmp(key, &quot;sun.java.launcher.is_altjvm&quot;) == 0) {</span>
<span class="line-modified">1442     // sun.java.launcher.is_altjvm property is</span>
<span class="line-modified">1443     // private and is processed in process_sun_java_launcher_properties();</span>

1444     // the sun.java.launcher property is passed on to the java application
1445   } else if (strcmp(key, &quot;sun.boot.library.path&quot;) == 0) {
1446     // append is true, writable is true, internal is false
1447     PropertyList_unique_add(&amp;_system_properties, key, value, AppendProperty,
1448                             WriteableProperty, ExternalProperty);
1449   } else {
1450     if (strcmp(key, &quot;sun.java.command&quot;) == 0) {
1451       char *old_java_command = _java_command;
1452       _java_command = os::strdup_check_oom(value, mtArguments);
1453       if (old_java_command != NULL) {
1454         os::free(old_java_command);
1455       }
1456     } else if (strcmp(key, &quot;java.vendor.url.bug&quot;) == 0) {
<span class="line-added">1457       // If this property is set on the command line then its value will be</span>
<span class="line-added">1458       // displayed in VM error logs as the URL at which to submit such logs.</span>
<span class="line-added">1459       // Normally the URL displayed in error logs is different from the value</span>
<span class="line-added">1460       // of this system property, so a different property should have been</span>
<span class="line-added">1461       // used here, but we leave this as-is in case someone depends upon it.</span>
1462       const char* old_java_vendor_url_bug = _java_vendor_url_bug;
1463       // save it in _java_vendor_url_bug, so JVM fatal error handler can access
1464       // its value without going through the property list or making a Java call.
1465       _java_vendor_url_bug = os::strdup_check_oom(value, mtArguments);
<span class="line-modified">1466       if (old_java_vendor_url_bug != NULL) {</span>

1467         os::free((void *)old_java_vendor_url_bug);
1468       }
1469     }
1470 
1471     // Create new property and add at the end of the list
1472     PropertyList_unique_add(&amp;_system_properties, key, value, AddProperty, writeable, internal);
1473   }
1474 
1475   if (key != prop) {
1476     // SystemProperty copy passed value, thus free previously allocated
1477     // memory
1478     FreeHeap((void *)key);
1479   }
1480 
1481   return true;
1482 }
1483 
1484 #if INCLUDE_CDS
1485 const char* unsupported_properties[] = { &quot;jdk.module.limitmods&quot;,
1486                                          &quot;jdk.module.upgrade.path&quot;,
1487                                          &quot;jdk.module.patch.0&quot; };
1488 const char* unsupported_options[] = { &quot;--limit-modules&quot;,
1489                                       &quot;--upgrade-module-path&quot;,
1490                                       &quot;--patch-module&quot;
1491                                     };
1492 void Arguments::check_unsupported_dumping_properties() {
<span class="line-modified">1493   assert(is_dumping_archive(),</span>
<span class="line-added">1494          &quot;this function is only used with CDS dump time&quot;);</span>
1495   assert(ARRAY_SIZE(unsupported_properties) == ARRAY_SIZE(unsupported_options), &quot;must be&quot;);
1496   // If a vm option is found in the unsupported_options array, vm will exit with an error message.
1497   SystemProperty* sp = system_properties();
1498   while (sp != NULL) {
1499     for (uint i = 0; i &lt; ARRAY_SIZE(unsupported_properties); i++) {
1500       if (strcmp(sp-&gt;key(), unsupported_properties[i]) == 0) {
1501         vm_exit_during_initialization(
1502           &quot;Cannot use the following option when dumping the shared archive&quot;, unsupported_options[i]);
1503       }
1504     }
1505     sp = sp-&gt;next();
1506   }
1507 
1508   // Check for an exploded module build in use with -Xshare:dump.
1509   if (!has_jimage()) {
1510     vm_exit_during_initialization(&quot;Dumping the shared archive is not supported with an exploded module build&quot;);
1511   }
1512 }
1513 
1514 bool Arguments::check_unsupported_cds_runtime_properties() {
1515   assert(UseSharedSpaces, &quot;this function is only used with -Xshare:{on,auto}&quot;);
1516   assert(ARRAY_SIZE(unsupported_properties) == ARRAY_SIZE(unsupported_options), &quot;must be&quot;);
<span class="line-added">1517   if (ArchiveClassesAtExit != NULL) {</span>
<span class="line-added">1518     // dynamic dumping, just return false for now.</span>
<span class="line-added">1519     // check_unsupported_dumping_properties() will be called later to check the same set of</span>
<span class="line-added">1520     // properties, and will exit the VM with the correct error message if the unsupported properties</span>
<span class="line-added">1521     // are used.</span>
<span class="line-added">1522     return false;</span>
<span class="line-added">1523   }</span>
1524   for (uint i = 0; i &lt; ARRAY_SIZE(unsupported_properties); i++) {
1525     if (get_property(unsupported_properties[i]) != NULL) {
1526       if (RequireSharedSpaces) {
1527         warning(&quot;CDS is disabled when the %s option is specified.&quot;, unsupported_options[i]);
1528       }
1529       return true;
1530     }
1531   }
1532   return false;
1533 }
1534 #endif
1535 
1536 //===========================================================================================================
1537 // Setting int/mixed/comp mode flags
1538 
1539 void Arguments::set_mode_flags(Mode mode) {
1540   // Set up default values for all flags.
1541   // If you add a flag to any of the branches below,
1542   // add a default value for it here.
1543   set_java_compiler(false);
</pre>
<hr />
<pre>
1587     ClipInlining             = false;
1588     // Be much more aggressive in tiered mode with -Xcomp and exercise C2 more.
1589     // We will first compile a level 3 version (C1 with full profiling), then do one invocation of it and
1590     // compile a level 4 (C2) and then continue executing it.
1591     if (TieredCompilation) {
1592       Tier3InvokeNotifyFreqLog = 0;
1593       Tier4InvocationThreshold = 0;
1594     }
1595     break;
1596   }
1597 }
1598 
1599 // Conflict: required to use shared spaces (-Xshare:on), but
1600 // incompatible command line options were chosen.
1601 static void no_shared_spaces(const char* message) {
1602   if (RequireSharedSpaces) {
1603     jio_fprintf(defaultStream::error_stream(),
1604       &quot;Class data sharing is inconsistent with other specified options.\n&quot;);
1605     vm_exit_during_initialization(&quot;Unable to use shared archive&quot;, message);
1606   } else {
<span class="line-added">1607     log_info(cds)(&quot;Unable to use shared archive: %s&quot;, message);</span>
1608     FLAG_SET_DEFAULT(UseSharedSpaces, false);
1609   }
1610 }
1611 
1612 void set_object_alignment() {
1613   // Object alignment.
1614   assert(is_power_of_2(ObjectAlignmentInBytes), &quot;ObjectAlignmentInBytes must be power of 2&quot;);
1615   MinObjAlignmentInBytes     = ObjectAlignmentInBytes;
1616   assert(MinObjAlignmentInBytes &gt;= HeapWordsPerLong * HeapWordSize, &quot;ObjectAlignmentInBytes value is too small&quot;);
1617   MinObjAlignment            = MinObjAlignmentInBytes / HeapWordSize;
1618   assert(MinObjAlignmentInBytes == MinObjAlignment * HeapWordSize, &quot;ObjectAlignmentInBytes value is incorrect&quot;);
1619   MinObjAlignmentInBytesMask = MinObjAlignmentInBytes - 1;
1620 
1621   LogMinObjAlignmentInBytes  = exact_log2(ObjectAlignmentInBytes);
1622   LogMinObjAlignment         = LogMinObjAlignmentInBytes - LogHeapWordSize;
1623 
1624   // Oop encoding heap max
1625   OopEncodingHeapMax = (uint64_t(max_juint) + 1) &lt;&lt; LogMinObjAlignmentInBytes;
1626 
1627   if (SurvivorAlignmentInBytes == 0) {
</pre>
<hr />
<pre>
1631 
1632 size_t Arguments::max_heap_for_compressed_oops() {
1633   // Avoid sign flip.
1634   assert(OopEncodingHeapMax &gt; (uint64_t)os::vm_page_size(), &quot;Unusual page size&quot;);
1635   // We need to fit both the NULL page and the heap into the memory budget, while
1636   // keeping alignment constraints of the heap. To guarantee the latter, as the
1637   // NULL page is located before the heap, we pad the NULL page to the conservative
1638   // maximum alignment that the GC may ever impose upon the heap.
1639   size_t displacement_due_to_null_page = align_up((size_t)os::vm_page_size(),
1640                                                   _conservative_max_heap_alignment);
1641 
1642   LP64_ONLY(return OopEncodingHeapMax - displacement_due_to_null_page);
1643   NOT_LP64(ShouldNotReachHere(); return 0);
1644 }
1645 
1646 void Arguments::set_use_compressed_oops() {
1647 #ifndef ZERO
1648 #ifdef _LP64
1649   // MaxHeapSize is not set up properly at this point, but
1650   // the only value that can override MaxHeapSize if we are
<span class="line-modified">1651   // to use UseCompressedOops are InitialHeapSize and MinHeapSize.</span>
<span class="line-modified">1652   size_t max_heap_size = MAX3(MaxHeapSize, InitialHeapSize, MinHeapSize);</span>
1653 
1654   if (max_heap_size &lt;= max_heap_for_compressed_oops()) {
<span class="line-modified">1655     if (FLAG_IS_DEFAULT(UseCompressedOops)) {</span>

1656       FLAG_SET_ERGO(UseCompressedOops, true);
1657     }

1658   } else {
1659     if (UseCompressedOops &amp;&amp; !FLAG_IS_DEFAULT(UseCompressedOops)) {
1660       warning(&quot;Max heap size too large for Compressed Oops&quot;);
1661       FLAG_SET_DEFAULT(UseCompressedOops, false);
1662       FLAG_SET_DEFAULT(UseCompressedClassPointers, false);
1663     }
1664   }
1665 #endif // _LP64
1666 #endif // ZERO
1667 }
1668 
1669 
1670 // NOTE: set_use_compressed_klass_ptrs() must be called after calling
1671 // set_use_compressed_oops().
1672 void Arguments::set_use_compressed_klass_ptrs() {
1673 #ifndef ZERO
1674 #ifdef _LP64
1675   // UseCompressedOops must be on for UseCompressedClassPointers to be on.
1676   if (!UseCompressedOops) {
1677     if (UseCompressedClassPointers) {
1678       warning(&quot;UseCompressedClassPointers requires UseCompressedOops&quot;);
1679     }
1680     FLAG_SET_DEFAULT(UseCompressedClassPointers, false);
1681   } else {
1682     // Turn on UseCompressedClassPointers too
1683     if (FLAG_IS_DEFAULT(UseCompressedClassPointers)) {
<span class="line-modified">1684       FLAG_SET_ERGO(UseCompressedClassPointers, true);</span>
1685     }
1686     // Check the CompressedClassSpaceSize to make sure we use compressed klass ptrs.
1687     if (UseCompressedClassPointers) {
1688       if (CompressedClassSpaceSize &gt; KlassEncodingMetaspaceMax) {
1689         warning(&quot;CompressedClassSpaceSize is too large for UseCompressedClassPointers&quot;);
1690         FLAG_SET_DEFAULT(UseCompressedClassPointers, false);
1691       }
1692     }
1693   }
1694 #endif // _LP64
1695 #endif // !ZERO
1696 }
1697 
1698 void Arguments::set_conservative_max_heap_alignment() {
1699   // The conservative maximum required alignment for the heap is the maximum of
1700   // the alignments imposed by several sources: any requirements from the heap
<span class="line-modified">1701   // itself and the maximum page size we may run the VM with.</span>

1702   size_t heap_alignment = GCConfig::arguments()-&gt;conservative_max_heap_alignment();
1703   _conservative_max_heap_alignment = MAX4(heap_alignment,
1704                                           (size_t)os::vm_allocation_granularity(),
1705                                           os::max_page_size(),
<span class="line-modified">1706                                           GCArguments::compute_heap_alignment());</span>
1707 }
1708 
1709 jint Arguments::set_ergonomics_flags() {
1710   GCConfig::initialize();
1711 
1712   set_conservative_max_heap_alignment();
1713 
1714 #ifndef ZERO
1715 #ifdef _LP64
1716   set_use_compressed_oops();
1717 
1718   // set_use_compressed_klass_ptrs() must be called after calling
1719   // set_use_compressed_oops().
1720   set_use_compressed_klass_ptrs();
1721 
1722   // Also checks that certain machines are slower with compressed oops
1723   // in vm_version initialization code.
1724 #endif // _LP64
1725 #endif // !ZERO
1726 
1727   return JNI_OK;
1728 }
1729 
1730 julong Arguments::limit_by_allocatable_memory(julong limit) {
1731   julong max_allocatable;
1732   julong result = limit;
1733   if (os::has_allocatable_memory_limit(&amp;max_allocatable)) {
1734     result = MIN2(result, max_allocatable / MaxVirtMemFraction);
1735   }
1736   return result;
1737 }
1738 
1739 // Use static initialization to get the default before parsing
1740 static const size_t DefaultHeapBaseMinAddress = HeapBaseMinAddress;
1741 
1742 void Arguments::set_heap_size() {
<span class="line-modified">1743   julong phys_mem;</span>
<span class="line-modified">1744 </span>
<span class="line-modified">1745   // If the user specified one of these options, they</span>
<span class="line-added">1746   // want specific memory sizing so do not limit memory</span>
<span class="line-added">1747   // based on compressed oops addressability.</span>
<span class="line-added">1748   // Also, memory limits will be calculated based on</span>
<span class="line-added">1749   // available os physical memory, not our MaxRAM limit,</span>
<span class="line-added">1750   // unless MaxRAM is also specified.</span>
<span class="line-added">1751   bool override_coop_limit = (!FLAG_IS_DEFAULT(MaxRAMPercentage) ||</span>
<span class="line-added">1752                            !FLAG_IS_DEFAULT(MaxRAMFraction) ||</span>
<span class="line-added">1753                            !FLAG_IS_DEFAULT(MinRAMPercentage) ||</span>
<span class="line-added">1754                            !FLAG_IS_DEFAULT(MinRAMFraction) ||</span>
<span class="line-added">1755                            !FLAG_IS_DEFAULT(InitialRAMPercentage) ||</span>
<span class="line-added">1756                            !FLAG_IS_DEFAULT(InitialRAMFraction) ||</span>
<span class="line-added">1757                            !FLAG_IS_DEFAULT(MaxRAM));</span>
<span class="line-added">1758   if (override_coop_limit) {</span>
<span class="line-added">1759     if (FLAG_IS_DEFAULT(MaxRAM)) {</span>
<span class="line-added">1760       phys_mem = os::physical_memory();</span>
<span class="line-added">1761       FLAG_SET_ERGO(MaxRAM, (uint64_t)phys_mem);</span>
<span class="line-added">1762     } else {</span>
<span class="line-added">1763       phys_mem = (julong)MaxRAM;</span>
<span class="line-added">1764     }</span>
<span class="line-added">1765   } else {</span>
<span class="line-added">1766     phys_mem = FLAG_IS_DEFAULT(MaxRAM) ? MIN2(os::physical_memory(), (julong)MaxRAM)</span>
<span class="line-added">1767                                        : (julong)MaxRAM;</span>
<span class="line-added">1768   }</span>
<span class="line-added">1769 </span>
1770 
1771   // Convert deprecated flags
1772   if (FLAG_IS_DEFAULT(MaxRAMPercentage) &amp;&amp;
1773       !FLAG_IS_DEFAULT(MaxRAMFraction))
1774     MaxRAMPercentage = 100.0 / MaxRAMFraction;
1775 
1776   if (FLAG_IS_DEFAULT(MinRAMPercentage) &amp;&amp;
1777       !FLAG_IS_DEFAULT(MinRAMFraction))
1778     MinRAMPercentage = 100.0 / MinRAMFraction;
1779 
1780   if (FLAG_IS_DEFAULT(InitialRAMPercentage) &amp;&amp;
1781       !FLAG_IS_DEFAULT(InitialRAMFraction))
1782     InitialRAMPercentage = 100.0 / InitialRAMFraction;
1783 
1784   // If the maximum heap size has not been set with -Xmx,
1785   // then set it as fraction of the size of physical memory,
1786   // respecting the maximum and minimum sizes of the heap.
1787   if (FLAG_IS_DEFAULT(MaxHeapSize)) {
1788     julong reasonable_max = (julong)((phys_mem * MaxRAMPercentage) / 100);
1789     const julong reasonable_min = (julong)((phys_mem * MinRAMPercentage) / 100);
1790     if (reasonable_min &lt; MaxHeapSize) {
1791       // Small physical memory, so use a minimum fraction of it for the heap
1792       reasonable_max = reasonable_min;
1793     } else {
1794       // Not-small physical memory, so require a heap at least
1795       // as large as MaxHeapSize
1796       reasonable_max = MAX2(reasonable_max, (julong)MaxHeapSize);
1797     }
1798 
1799     if (!FLAG_IS_DEFAULT(ErgoHeapSizeLimit) &amp;&amp; ErgoHeapSizeLimit != 0) {
1800       // Limit the heap size to ErgoHeapSizeLimit
1801       reasonable_max = MIN2(reasonable_max, (julong)ErgoHeapSizeLimit);
1802     }
<span class="line-added">1803 </span>
<span class="line-added">1804 #ifdef _LP64</span>
1805     if (UseCompressedOops) {
1806       // Limit the heap size to the maximum possible when using compressed oops
1807       julong max_coop_heap = (julong)max_heap_for_compressed_oops();
1808 
1809       // HeapBaseMinAddress can be greater than default but not less than.
1810       if (!FLAG_IS_DEFAULT(HeapBaseMinAddress)) {
1811         if (HeapBaseMinAddress &lt; DefaultHeapBaseMinAddress) {
1812           // matches compressed oops printing flags
1813           log_debug(gc, heap, coops)(&quot;HeapBaseMinAddress must be at least &quot; SIZE_FORMAT
1814                                      &quot; (&quot; SIZE_FORMAT &quot;G) which is greater than value given &quot; SIZE_FORMAT,
1815                                      DefaultHeapBaseMinAddress,
1816                                      DefaultHeapBaseMinAddress/G,
1817                                      HeapBaseMinAddress);
<span class="line-modified">1818           FLAG_SET_ERGO(HeapBaseMinAddress, DefaultHeapBaseMinAddress);</span>
1819         }
1820       }
1821 
1822       if (HeapBaseMinAddress + MaxHeapSize &lt; max_coop_heap) {
1823         // Heap should be above HeapBaseMinAddress to get zero based compressed oops
1824         // but it should be not less than default MaxHeapSize.
1825         max_coop_heap -= HeapBaseMinAddress;
1826       }
<span class="line-modified">1827 </span>
<span class="line-added">1828       // If user specified flags prioritizing os physical</span>
<span class="line-added">1829       // memory limits, then disable compressed oops if</span>
<span class="line-added">1830       // limits exceed max_coop_heap and UseCompressedOops</span>
<span class="line-added">1831       // was not specified.</span>
<span class="line-added">1832       if (reasonable_max &gt; max_coop_heap) {</span>
<span class="line-added">1833         if (FLAG_IS_ERGO(UseCompressedOops) &amp;&amp; override_coop_limit) {</span>
<span class="line-added">1834           log_info(cds)(&quot;UseCompressedOops and UseCompressedClassPointers have been disabled due to&quot;</span>
<span class="line-added">1835             &quot; max heap &quot; SIZE_FORMAT &quot; &gt; compressed oop heap &quot; SIZE_FORMAT &quot;. &quot;</span>
<span class="line-added">1836             &quot;Please check the setting of MaxRAMPercentage %5.2f.&quot;</span>
<span class="line-added">1837             ,(size_t)reasonable_max, (size_t)max_coop_heap, MaxRAMPercentage);</span>
<span class="line-added">1838           FLAG_SET_ERGO(UseCompressedOops, false);</span>
<span class="line-added">1839           FLAG_SET_ERGO(UseCompressedClassPointers, false);</span>
<span class="line-added">1840         } else {</span>
<span class="line-added">1841           reasonable_max = MIN2(reasonable_max, max_coop_heap);</span>
<span class="line-added">1842         }</span>
<span class="line-added">1843       }</span>
1844     }
<span class="line-added">1845 #endif // _LP64</span>
<span class="line-added">1846 </span>
1847     reasonable_max = limit_by_allocatable_memory(reasonable_max);
1848 
1849     if (!FLAG_IS_DEFAULT(InitialHeapSize)) {
1850       // An initial heap size was specified on the command line,
1851       // so be sure that the maximum size is consistent.  Done
1852       // after call to limit_by_allocatable_memory because that
1853       // method might reduce the allocation size.
1854       reasonable_max = MAX2(reasonable_max, (julong)InitialHeapSize);
<span class="line-added">1855     } else if (!FLAG_IS_DEFAULT(MinHeapSize)) {</span>
<span class="line-added">1856       reasonable_max = MAX2(reasonable_max, (julong)MinHeapSize);</span>
1857     }
1858 
1859     log_trace(gc, heap)(&quot;  Maximum heap size &quot; SIZE_FORMAT, (size_t) reasonable_max);
<span class="line-modified">1860     FLAG_SET_ERGO(MaxHeapSize, (size_t)reasonable_max);</span>
1861   }
1862 
1863   // If the minimum or initial heap_size have not been set or requested to be set
1864   // ergonomically, set them accordingly.
<span class="line-modified">1865   if (InitialHeapSize == 0 || MinHeapSize == 0) {</span>
1866     julong reasonable_minimum = (julong)(OldSize + NewSize);
1867 
1868     reasonable_minimum = MIN2(reasonable_minimum, (julong)MaxHeapSize);
1869 
1870     reasonable_minimum = limit_by_allocatable_memory(reasonable_minimum);
1871 
1872     if (InitialHeapSize == 0) {
1873       julong reasonable_initial = (julong)((phys_mem * InitialRAMPercentage) / 100);
1874 
<span class="line-modified">1875       reasonable_initial = MAX3(reasonable_initial, reasonable_minimum, (julong)MinHeapSize);</span>
1876       reasonable_initial = MIN2(reasonable_initial, (julong)MaxHeapSize);
1877 
1878       reasonable_initial = limit_by_allocatable_memory(reasonable_initial);
1879 
<span class="line-modified">1880       FLAG_SET_ERGO(InitialHeapSize, (size_t)reasonable_initial);</span>
<span class="line-modified">1881       log_trace(gc, heap)(&quot;  Initial heap size &quot; SIZE_FORMAT, InitialHeapSize);</span>
1882     }
<span class="line-modified">1883     // If the minimum heap size has not been set (via -Xms or -XX:MinHeapSize),</span>
1884     // synchronize with InitialHeapSize to avoid errors with the default value.
<span class="line-modified">1885     if (MinHeapSize == 0) {</span>
<span class="line-modified">1886       FLAG_SET_ERGO(MinHeapSize, MIN2((size_t)reasonable_minimum, InitialHeapSize));</span>
<span class="line-modified">1887       log_trace(gc, heap)(&quot;  Minimum heap size &quot; SIZE_FORMAT, MinHeapSize);</span>
1888     }
1889   }
1890 }
1891 
1892 // This option inspects the machine and attempts to set various
1893 // parameters to be optimal for long-running, memory allocation
1894 // intensive jobs.  It is intended for machines with large
1895 // amounts of cpu and memory.
1896 jint Arguments::set_aggressive_heap_flags() {
1897   // initHeapSize is needed since _initial_heap_size is 4 bytes on a 32 bit
1898   // VM, but we may not be able to represent the total physical memory
1899   // available (like having 8gb of memory on a box but using a 32bit VM).
1900   // Thus, we need to make sure we&#39;re using a julong for intermediate
1901   // calculations.
1902   julong initHeapSize;
1903   julong total_memory = os::physical_memory();
1904 
1905   if (total_memory &lt; (julong) 256 * M) {
1906     jio_fprintf(defaultStream::error_stream(),
1907             &quot;You need at least 256mb of memory to use -XX:+AggressiveHeap\n&quot;);
1908     vm_exit(1);
1909   }
1910 
1911   // The heap size is half of available memory, or (at most)
1912   // all of possible memory less 160mb (leaving room for the OS
1913   // when using ISM).  This is the maximum; because adaptive sizing
1914   // is turned on below, the actual space used may be smaller.
1915 
1916   initHeapSize = MIN2(total_memory / (julong) 2,
1917           total_memory - (julong) 160 * M);
1918 
1919   initHeapSize = limit_by_allocatable_memory(initHeapSize);
1920 
1921   if (FLAG_IS_DEFAULT(MaxHeapSize)) {
<span class="line-modified">1922     if (FLAG_SET_CMDLINE(MaxHeapSize, initHeapSize) != JVMFlag::SUCCESS) {</span>
1923       return JNI_EINVAL;
1924     }
<span class="line-modified">1925     if (FLAG_SET_CMDLINE(InitialHeapSize, initHeapSize) != JVMFlag::SUCCESS) {</span>
<span class="line-added">1926       return JNI_EINVAL;</span>
<span class="line-added">1927     }</span>
<span class="line-added">1928     if (FLAG_SET_CMDLINE(MinHeapSize, initHeapSize) != JVMFlag::SUCCESS) {</span>
1929       return JNI_EINVAL;
1930     }


1931   }
1932   if (FLAG_IS_DEFAULT(NewSize)) {
1933     // Make the young generation 3/8ths of the total heap.
<span class="line-modified">1934     if (FLAG_SET_CMDLINE(NewSize,</span>
1935             ((julong) MaxHeapSize / (julong) 8) * (julong) 3) != JVMFlag::SUCCESS) {
1936       return JNI_EINVAL;
1937     }
<span class="line-modified">1938     if (FLAG_SET_CMDLINE(MaxNewSize, NewSize) != JVMFlag::SUCCESS) {</span>
1939       return JNI_EINVAL;
1940     }
1941   }
1942 
1943 #if !defined(_ALLBSD_SOURCE) &amp;&amp; !defined(AIX)  // UseLargePages is not yet supported on BSD and AIX.
1944   FLAG_SET_DEFAULT(UseLargePages, true);
1945 #endif
1946 
1947   // Increase some data structure sizes for efficiency
<span class="line-modified">1948   if (FLAG_SET_CMDLINE(BaseFootPrintEstimate, MaxHeapSize) != JVMFlag::SUCCESS) {</span>
1949     return JNI_EINVAL;
1950   }
<span class="line-modified">1951   if (FLAG_SET_CMDLINE(ResizeTLAB, false) != JVMFlag::SUCCESS) {</span>
1952     return JNI_EINVAL;
1953   }
<span class="line-modified">1954   if (FLAG_SET_CMDLINE(TLABSize, 256 * K) != JVMFlag::SUCCESS) {</span>
1955     return JNI_EINVAL;
1956   }
1957 
1958   // See the OldPLABSize comment below, but replace &#39;after promotion&#39;
1959   // with &#39;after copying&#39;.  YoungPLABSize is the size of the survivor
1960   // space per-gc-thread buffers.  The default is 4kw.
<span class="line-modified">1961   if (FLAG_SET_CMDLINE(YoungPLABSize, 256 * K) != JVMFlag::SUCCESS) { // Note: this is in words</span>
1962     return JNI_EINVAL;
1963   }
1964 
1965   // OldPLABSize is the size of the buffers in the old gen that
1966   // UseParallelGC uses to promote live data that doesn&#39;t fit in the
1967   // survivor spaces.  At any given time, there&#39;s one for each gc thread.
1968   // The default size is 1kw. These buffers are rarely used, since the
1969   // survivor spaces are usually big enough.  For specjbb, however, there
1970   // are occasions when there&#39;s lots of live data in the young gen
1971   // and we end up promoting some of it.  We don&#39;t have a definite
1972   // explanation for why bumping OldPLABSize helps, but the theory
1973   // is that a bigger PLAB results in retaining something like the
1974   // original allocation order after promotion, which improves mutator
1975   // locality.  A minor effect may be that larger PLABs reduce the
1976   // number of PLAB allocation events during gc.  The value of 8kw
1977   // was arrived at by experimenting with specjbb.
<span class="line-modified">1978   if (FLAG_SET_CMDLINE(OldPLABSize, 8 * K) != JVMFlag::SUCCESS) { // Note: this is in words</span>
1979     return JNI_EINVAL;
1980   }
1981 
1982   // Enable parallel GC and adaptive generation sizing
<span class="line-modified">1983   if (FLAG_SET_CMDLINE(UseParallelGC, true) != JVMFlag::SUCCESS) {</span>
1984     return JNI_EINVAL;
1985   }
1986 
1987   // Encourage steady state memory management
<span class="line-modified">1988   if (FLAG_SET_CMDLINE(ThresholdTolerance, 100) != JVMFlag::SUCCESS) {</span>
1989     return JNI_EINVAL;
1990   }
1991 
1992   // This appears to improve mutator locality
<span class="line-modified">1993   if (FLAG_SET_CMDLINE(ScavengeBeforeFullGC, false) != JVMFlag::SUCCESS) {</span>







1994     return JNI_EINVAL;
1995   }
1996 
1997   return JNI_OK;
1998 }
1999 
2000 // This must be called after ergonomics.
2001 void Arguments::set_bytecode_flags() {
2002   if (!RewriteBytecodes) {
2003     FLAG_SET_DEFAULT(RewriteFrequentPairs, false);
2004   }
2005 }
2006 
2007 // Aggressive optimization flags
2008 jint Arguments::set_aggressive_opts_flags() {
2009 #ifdef COMPILER2
2010   if (AggressiveUnboxing) {
2011     if (FLAG_IS_DEFAULT(EliminateAutoBox)) {
2012       FLAG_SET_DEFAULT(EliminateAutoBox, true);
2013     } else if (!EliminateAutoBox) {
</pre>
<hr />
<pre>
2094       warning(&quot;PrintNMTStatistics is disabled, because native memory tracking is not enabled&quot;);
2095       PrintNMTStatistics = false;
2096 #if INCLUDE_NMT
2097     }
2098 #endif
2099   }
2100 
2101   status = CompilerConfig::check_args_consistency(status);
2102 #if INCLUDE_JVMCI
2103   if (status &amp;&amp; EnableJVMCI) {
2104     PropertyList_unique_add(&amp;_system_properties, &quot;jdk.internal.vm.ci.enabled&quot;, &quot;true&quot;,
2105         AddProperty, UnwriteableProperty, InternalProperty);
2106     if (!create_numbered_property(&quot;jdk.module.addmods&quot;, &quot;jdk.internal.vm.ci&quot;, addmods_count++)) {
2107       return false;
2108     }
2109   }
2110 #endif
2111 
2112 #ifndef SUPPORT_RESERVED_STACK_AREA
2113   if (StackReservedPages != 0) {
<span class="line-modified">2114     FLAG_SET_CMDLINE(StackReservedPages, 0);</span>
2115     warning(&quot;Reserved Stack Area not supported on this platform&quot;);
2116   }
2117 #endif
2118 






2119   status = status &amp;&amp; GCArguments::check_args_consistency();
2120 
2121   return status;
2122 }
2123 
2124 bool Arguments::is_bad_option(const JavaVMOption* option, jboolean ignore,
2125   const char* option_type) {
2126   if (ignore) return false;
2127 
2128   const char* spacer = &quot; &quot;;
2129   if (option_type == NULL) {
2130     option_type = ++spacer; // Set both to the empty string.
2131   }
2132 
2133   jio_fprintf(defaultStream::error_stream(),
2134               &quot;Unrecognized %s%soption: %s\n&quot;, option_type, spacer,
2135               option-&gt;optionString);
2136   return true;
2137 }
2138 
</pre>
<hr />
<pre>
2197     }
2198     bool added = add_property(property, UnwriteableProperty, InternalProperty);
2199     FreeHeap(property);
2200     return added;
2201   }
2202 
2203   jio_fprintf(defaultStream::error_stream(), &quot;Property count limit exceeded: %s, limit=%d\n&quot;, prop_base_name, props_count_limit);
2204   return false;
2205 }
2206 
2207 Arguments::ArgsRange Arguments::parse_memory_size(const char* s,
2208                                                   julong* long_arg,
2209                                                   julong min_size,
2210                                                   julong max_size) {
2211   if (!atojulong(s, long_arg)) return arg_unreadable;
2212   return check_memory_size(*long_arg, min_size, max_size);
2213 }
2214 
2215 // Parse JavaVMInitArgs structure
2216 
<span class="line-modified">2217 jint Arguments::parse_vm_init_args(const JavaVMInitArgs *vm_options_args,</span>
<span class="line-added">2218                                    const JavaVMInitArgs *java_tool_options_args,</span>
2219                                    const JavaVMInitArgs *java_options_args,
2220                                    const JavaVMInitArgs *cmd_line_args) {
2221   bool patch_mod_javabase = false;
2222 
2223   // Save default settings for some mode flags
2224   Arguments::_AlwaysCompileLoopMethods = AlwaysCompileLoopMethods;
2225   Arguments::_UseOnStackReplacement    = UseOnStackReplacement;
2226   Arguments::_ClipInlining             = ClipInlining;
2227   Arguments::_BackgroundCompilation    = BackgroundCompilation;
2228   if (TieredCompilation) {
2229     Arguments::_Tier3InvokeNotifyFreqLog = Tier3InvokeNotifyFreqLog;
2230     Arguments::_Tier4InvocationThreshold = Tier4InvocationThreshold;
2231   }
2232 
<span class="line-added">2233   // CDS dumping always write the archive to the default value of SharedBaseAddress.</span>
<span class="line-added">2234   Arguments::_SharedBaseAddress = SharedBaseAddress;</span>
<span class="line-added">2235 </span>
2236   // Setup flags for mixed which is the default
2237   set_mode_flags(_mixed);
2238 
<span class="line-added">2239   // Parse args structure generated from java.base vm options resource</span>
<span class="line-added">2240   jint result = parse_each_vm_init_arg(vm_options_args, &amp;patch_mod_javabase, JVMFlag::JIMAGE_RESOURCE);</span>
<span class="line-added">2241   if (result != JNI_OK) {</span>
<span class="line-added">2242     return result;</span>
<span class="line-added">2243   }</span>
<span class="line-added">2244 </span>
2245   // Parse args structure generated from JAVA_TOOL_OPTIONS environment
2246   // variable (if present).
<span class="line-modified">2247   result = parse_each_vm_init_arg(java_tool_options_args, &amp;patch_mod_javabase, JVMFlag::ENVIRON_VAR);</span>
2248   if (result != JNI_OK) {
2249     return result;
2250   }
2251 
2252   // Parse args structure generated from the command line flags.
2253   result = parse_each_vm_init_arg(cmd_line_args, &amp;patch_mod_javabase, JVMFlag::COMMAND_LINE);
2254   if (result != JNI_OK) {
2255     return result;
2256   }
2257 
2258   // Parse args structure generated from the _JAVA_OPTIONS environment
2259   // variable (if present) (mimics classic VM)
2260   result = parse_each_vm_init_arg(java_options_args, &amp;patch_mod_javabase, JVMFlag::ENVIRON_VAR);
2261   if (result != JNI_OK) {
2262     return result;
2263   }
2264 
2265   // We need to ensure processor and memory resources have been properly
2266   // configured - which may rely on arguments we just processed - before
2267   // doing the final argument processing. Any argument processing that
</pre>
<hr />
<pre>
2417 
2418         // add all jvm options to the jvm_args string. This string
2419         // is used later to set the java.vm.args PerfData string constant.
2420         // the -Djava.class.path and the -Dsun.java.command options are
2421         // omitted from jvm_args string as each have their own PerfData
2422         // string constant object.
2423         build_jvm_args(option-&gt;optionString);
2424     }
2425 
2426     // -verbose:[class/module/gc/jni]
2427     if (match_option(option, &quot;-verbose&quot;, &amp;tail)) {
2428       if (!strcmp(tail, &quot;:class&quot;) || !strcmp(tail, &quot;&quot;)) {
2429         LogConfiguration::configure_stdout(LogLevel::Info, true, LOG_TAGS(class, load));
2430         LogConfiguration::configure_stdout(LogLevel::Info, true, LOG_TAGS(class, unload));
2431       } else if (!strcmp(tail, &quot;:module&quot;)) {
2432         LogConfiguration::configure_stdout(LogLevel::Info, true, LOG_TAGS(module, load));
2433         LogConfiguration::configure_stdout(LogLevel::Info, true, LOG_TAGS(module, unload));
2434       } else if (!strcmp(tail, &quot;:gc&quot;)) {
2435         LogConfiguration::configure_stdout(LogLevel::Info, true, LOG_TAGS(gc));
2436       } else if (!strcmp(tail, &quot;:jni&quot;)) {
<span class="line-modified">2437         LogConfiguration::configure_stdout(LogLevel::Debug, true, LOG_TAGS(jni, resolve));</span>


2438       }
2439     // -da / -ea / -disableassertions / -enableassertions
2440     // These accept an optional class/package name separated by a colon, e.g.,
2441     // -da:java.lang.Thread.
2442     } else if (match_option(option, user_assertion_options, &amp;tail, true)) {
2443       bool enable = option-&gt;optionString[1] == &#39;e&#39;;     // char after &#39;-&#39; is &#39;e&#39;
2444       if (*tail == &#39;\0&#39;) {
2445         JavaAssertions::setUserClassDefault(enable);
2446       } else {
2447         assert(*tail == &#39;:&#39;, &quot;bogus match by match_option()&quot;);
2448         JavaAssertions::addOption(tail + 1, enable);
2449       }
2450     // -dsa / -esa / -disablesystemassertions / -enablesystemassertions
2451     } else if (match_option(option, system_assertion_options, &amp;tail, false)) {
2452       bool enable = option-&gt;optionString[1] == &#39;e&#39;;     // char after &#39;-&#39; is &#39;e&#39;
2453       JavaAssertions::setSystemClassDefault(enable);
2454     // -bootclasspath:
2455     } else if (match_option(option, &quot;-Xbootclasspath:&quot;, &amp;tail)) {
2456         jio_fprintf(defaultStream::output_stream(),
2457           &quot;-Xbootclasspath is no longer a supported option.\n&quot;);
</pre>
<hr />
<pre>
2558       jio_fprintf(defaultStream::error_stream(),
2559         &quot;Instrumentation agents are not supported in this VM\n&quot;);
2560       return JNI_ERR;
2561 #else
2562       if (tail != NULL) {
2563         size_t length = strlen(tail) + 1;
2564         char *options = NEW_C_HEAP_ARRAY(char, length, mtArguments);
2565         jio_snprintf(options, length, &quot;%s&quot;, tail);
2566         add_instrument_agent(&quot;instrument&quot;, options, false);
2567         // java agents need module java.instrument
2568         if (!create_numbered_property(&quot;jdk.module.addmods&quot;, &quot;java.instrument&quot;, addmods_count++)) {
2569           return JNI_ENOMEM;
2570         }
2571       }
2572 #endif // !INCLUDE_JVMTI
2573     // --enable_preview
2574     } else if (match_option(option, &quot;--enable-preview&quot;)) {
2575       set_enable_preview();
2576     // -Xnoclassgc
2577     } else if (match_option(option, &quot;-Xnoclassgc&quot;)) {
<span class="line-modified">2578       if (FLAG_SET_CMDLINE(ClassUnloading, false) != JVMFlag::SUCCESS) {</span>
2579         return JNI_EINVAL;
2580       }












2581     // -Xbatch
2582     } else if (match_option(option, &quot;-Xbatch&quot;)) {
<span class="line-modified">2583       if (FLAG_SET_CMDLINE(BackgroundCompilation, false) != JVMFlag::SUCCESS) {</span>
2584         return JNI_EINVAL;
2585       }
2586     // -Xmn for compatibility with other JVM vendors
2587     } else if (match_option(option, &quot;-Xmn&quot;, &amp;tail)) {
2588       julong long_initial_young_size = 0;
2589       ArgsRange errcode = parse_memory_size(tail, &amp;long_initial_young_size, 1);
2590       if (errcode != arg_in_range) {
2591         jio_fprintf(defaultStream::error_stream(),
2592                     &quot;Invalid initial young generation size: %s\n&quot;, option-&gt;optionString);
2593         describe_range_error(errcode);
2594         return JNI_EINVAL;
2595       }
<span class="line-modified">2596       if (FLAG_SET_CMDLINE(MaxNewSize, (size_t)long_initial_young_size) != JVMFlag::SUCCESS) {</span>
2597         return JNI_EINVAL;
2598       }
<span class="line-modified">2599       if (FLAG_SET_CMDLINE(NewSize, (size_t)long_initial_young_size) != JVMFlag::SUCCESS) {</span>
2600         return JNI_EINVAL;
2601       }
2602     // -Xms
2603     } else if (match_option(option, &quot;-Xms&quot;, &amp;tail)) {
<span class="line-modified">2604       julong size = 0;</span>
2605       // an initial heap size of 0 means automatically determine
<span class="line-modified">2606       ArgsRange errcode = parse_memory_size(tail, &amp;size, 0);</span>
2607       if (errcode != arg_in_range) {
2608         jio_fprintf(defaultStream::error_stream(),
2609                     &quot;Invalid initial heap size: %s\n&quot;, option-&gt;optionString);
2610         describe_range_error(errcode);
2611         return JNI_EINVAL;
2612       }
<span class="line-modified">2613       if (FLAG_SET_CMDLINE(MinHeapSize, (size_t)size) != JVMFlag::SUCCESS) {</span>
<span class="line-modified">2614         return JNI_EINVAL;</span>
<span class="line-modified">2615       }</span>
<span class="line-modified">2616       if (FLAG_SET_CMDLINE(InitialHeapSize, (size_t)size) != JVMFlag::SUCCESS) {</span>
2617         return JNI_EINVAL;
2618       }
2619     // -Xmx
2620     } else if (match_option(option, &quot;-Xmx&quot;, &amp;tail) || match_option(option, &quot;-XX:MaxHeapSize=&quot;, &amp;tail)) {
2621       julong long_max_heap_size = 0;
2622       ArgsRange errcode = parse_memory_size(tail, &amp;long_max_heap_size, 1);
2623       if (errcode != arg_in_range) {
2624         jio_fprintf(defaultStream::error_stream(),
2625                     &quot;Invalid maximum heap size: %s\n&quot;, option-&gt;optionString);
2626         describe_range_error(errcode);
2627         return JNI_EINVAL;
2628       }
<span class="line-modified">2629       if (FLAG_SET_CMDLINE(MaxHeapSize, (size_t)long_max_heap_size) != JVMFlag::SUCCESS) {</span>
2630         return JNI_EINVAL;
2631       }
2632     // Xmaxf
2633     } else if (match_option(option, &quot;-Xmaxf&quot;, &amp;tail)) {
2634       char* err;
2635       int maxf = (int)(strtod(tail, &amp;err) * 100);
2636       if (*err != &#39;\0&#39; || *tail == &#39;\0&#39;) {
2637         jio_fprintf(defaultStream::error_stream(),
2638                     &quot;Bad max heap free percentage size: %s\n&quot;,
2639                     option-&gt;optionString);
2640         return JNI_EINVAL;
2641       } else {
<span class="line-modified">2642         if (FLAG_SET_CMDLINE(MaxHeapFreeRatio, maxf) != JVMFlag::SUCCESS) {</span>
2643             return JNI_EINVAL;
2644         }
2645       }
2646     // Xminf
2647     } else if (match_option(option, &quot;-Xminf&quot;, &amp;tail)) {
2648       char* err;
2649       int minf = (int)(strtod(tail, &amp;err) * 100);
2650       if (*err != &#39;\0&#39; || *tail == &#39;\0&#39;) {
2651         jio_fprintf(defaultStream::error_stream(),
2652                     &quot;Bad min heap free percentage size: %s\n&quot;,
2653                     option-&gt;optionString);
2654         return JNI_EINVAL;
2655       } else {
<span class="line-modified">2656         if (FLAG_SET_CMDLINE(MinHeapFreeRatio, minf) != JVMFlag::SUCCESS) {</span>
2657           return JNI_EINVAL;
2658         }
2659       }
2660     // -Xss
2661     } else if (match_option(option, &quot;-Xss&quot;, &amp;tail)) {
2662       intx value = 0;
2663       jint err = parse_xss(option, tail, &amp;value);
2664       if (err != JNI_OK) {
2665         return err;
2666       }
<span class="line-modified">2667       if (FLAG_SET_CMDLINE(ThreadStackSize, value) != JVMFlag::SUCCESS) {</span>
2668         return JNI_EINVAL;
2669       }
2670     } else if (match_option(option, &quot;-Xmaxjitcodesize&quot;, &amp;tail) ||
2671                match_option(option, &quot;-XX:ReservedCodeCacheSize=&quot;, &amp;tail)) {
2672       julong long_ReservedCodeCacheSize = 0;
2673 
2674       ArgsRange errcode = parse_memory_size(tail, &amp;long_ReservedCodeCacheSize, 1);
2675       if (errcode != arg_in_range) {
2676         jio_fprintf(defaultStream::error_stream(),
2677                     &quot;Invalid maximum code cache size: %s.\n&quot;, option-&gt;optionString);
2678         return JNI_EINVAL;
2679       }
<span class="line-modified">2680       if (FLAG_SET_CMDLINE(ReservedCodeCacheSize, (uintx)long_ReservedCodeCacheSize) != JVMFlag::SUCCESS) {</span>
2681         return JNI_EINVAL;
2682       }
2683     // -green
2684     } else if (match_option(option, &quot;-green&quot;)) {
2685       jio_fprintf(defaultStream::error_stream(),
2686                   &quot;Green threads support not available\n&quot;);
2687           return JNI_EINVAL;
2688     // -native
2689     } else if (match_option(option, &quot;-native&quot;)) {
2690           // HotSpot always uses native threads, ignore silently for compatibility
2691     // -Xrs
2692     } else if (match_option(option, &quot;-Xrs&quot;)) {
2693           // Classic/EVM option, new functionality
<span class="line-modified">2694       if (FLAG_SET_CMDLINE(ReduceSignalUsage, true) != JVMFlag::SUCCESS) {</span>
2695         return JNI_EINVAL;
2696       }
2697       // -Xprof
2698     } else if (match_option(option, &quot;-Xprof&quot;)) {
2699       char version[256];
2700       // Obsolete in JDK 10
2701       JDK_Version::jdk(10).to_string(version, sizeof(version));
2702       warning(&quot;Ignoring option %s; support was removed in %s&quot;, option-&gt;optionString, version);
2703     // -Xinternalversion
2704     } else if (match_option(option, &quot;-Xinternalversion&quot;)) {
2705       jio_fprintf(defaultStream::output_stream(), &quot;%s\n&quot;,
2706                   VM_Version::internal_vm_info_string());
2707       vm_exit(0);
2708 #ifndef PRODUCT
2709     // -Xprintflags
2710     } else if (match_option(option, &quot;-Xprintflags&quot;)) {
2711       JVMFlag::printFlags(tty, false);
2712       vm_exit(0);
2713 #endif
2714     // -D
</pre>
<hr />
<pre>
2719         // abort if -Djava.endorsed.dirs is set
2720         jio_fprintf(defaultStream::output_stream(),
2721           &quot;-Djava.endorsed.dirs=%s is not supported. Endorsed standards and standalone APIs\n&quot;
2722           &quot;in modular form will be supported via the concept of upgradeable modules.\n&quot;, value);
2723         return JNI_EINVAL;
2724       }
2725       if (match_option(option, &quot;-Djava.ext.dirs=&quot;, &amp;value) &amp;&amp;
2726             *value != &#39;\0&#39; &amp;&amp; strcmp(value, &quot;\&quot;\&quot;&quot;) != 0) {
2727         // abort if -Djava.ext.dirs is set
2728         jio_fprintf(defaultStream::output_stream(),
2729           &quot;-Djava.ext.dirs=%s is not supported.  Use -classpath instead.\n&quot;, value);
2730         return JNI_EINVAL;
2731       }
2732       // Check for module related properties.  They must be set using the modules
2733       // options. For example: use &quot;--add-modules=java.sql&quot;, not
2734       // &quot;-Djdk.module.addmods=java.sql&quot;
2735       if (is_internal_module_property(option-&gt;optionString + 2)) {
2736         needs_module_property_warning = true;
2737         continue;
2738       }

2739       if (!add_property(tail)) {
2740         return JNI_ENOMEM;
2741       }
2742       // Out of the box management support
2743       if (match_option(option, &quot;-Dcom.sun.management&quot;, &amp;tail)) {
2744 #if INCLUDE_MANAGEMENT
<span class="line-modified">2745         if (FLAG_SET_CMDLINE(ManagementServer, true) != JVMFlag::SUCCESS) {</span>
2746           return JNI_EINVAL;
2747         }
2748         // management agent in module jdk.management.agent
2749         if (!create_numbered_property(&quot;jdk.module.addmods&quot;, &quot;jdk.management.agent&quot;, addmods_count++)) {
2750           return JNI_ENOMEM;
2751         }
2752 #else
2753         jio_fprintf(defaultStream::output_stream(),
2754           &quot;-Dcom.sun.management is not supported in this VM.\n&quot;);
2755         return JNI_ERR;
2756 #endif
2757       }
2758     // -Xint
2759     } else if (match_option(option, &quot;-Xint&quot;)) {
2760           set_mode_flags(_int);
2761     // -Xmixed
2762     } else if (match_option(option, &quot;-Xmixed&quot;)) {
2763           set_mode_flags(_mixed);
2764     // -Xcomp
2765     } else if (match_option(option, &quot;-Xcomp&quot;)) {
2766       // for testing the compiler; turn off all flags that inhibit compilation
2767           set_mode_flags(_comp);
2768     // -Xshare:dump
2769     } else if (match_option(option, &quot;-Xshare:dump&quot;)) {
<span class="line-modified">2770       if (FLAG_SET_CMDLINE(DumpSharedSpaces, true) != JVMFlag::SUCCESS) {</span>
2771         return JNI_EINVAL;
2772       }

2773     // -Xshare:on
2774     } else if (match_option(option, &quot;-Xshare:on&quot;)) {
<span class="line-modified">2775       if (FLAG_SET_CMDLINE(UseSharedSpaces, true) != JVMFlag::SUCCESS) {</span>
2776         return JNI_EINVAL;
2777       }
<span class="line-modified">2778       if (FLAG_SET_CMDLINE(RequireSharedSpaces, true) != JVMFlag::SUCCESS) {</span>
2779         return JNI_EINVAL;
2780       }
<span class="line-modified">2781     // -Xshare:auto || -XX:ArchiveClassesAtExit=&lt;archive file&gt;</span>
2782     } else if (match_option(option, &quot;-Xshare:auto&quot;)) {
<span class="line-modified">2783       if (FLAG_SET_CMDLINE(UseSharedSpaces, true) != JVMFlag::SUCCESS) {</span>
2784         return JNI_EINVAL;
2785       }
<span class="line-modified">2786       if (FLAG_SET_CMDLINE(RequireSharedSpaces, false) != JVMFlag::SUCCESS) {</span>
2787         return JNI_EINVAL;
2788       }
2789     // -Xshare:off
2790     } else if (match_option(option, &quot;-Xshare:off&quot;)) {
<span class="line-modified">2791       if (FLAG_SET_CMDLINE(UseSharedSpaces, false) != JVMFlag::SUCCESS) {</span>
2792         return JNI_EINVAL;
2793       }
<span class="line-modified">2794       if (FLAG_SET_CMDLINE(RequireSharedSpaces, false) != JVMFlag::SUCCESS) {</span>
2795         return JNI_EINVAL;
2796       }
2797     // -Xverify
2798     } else if (match_option(option, &quot;-Xverify&quot;, &amp;tail)) {
2799       if (strcmp(tail, &quot;:all&quot;) == 0 || strcmp(tail, &quot;&quot;) == 0) {
<span class="line-modified">2800         if (FLAG_SET_CMDLINE(BytecodeVerificationLocal, true) != JVMFlag::SUCCESS) {</span>
2801           return JNI_EINVAL;
2802         }
<span class="line-modified">2803         if (FLAG_SET_CMDLINE(BytecodeVerificationRemote, true) != JVMFlag::SUCCESS) {</span>
2804           return JNI_EINVAL;
2805         }
2806       } else if (strcmp(tail, &quot;:remote&quot;) == 0) {
<span class="line-modified">2807         if (FLAG_SET_CMDLINE(BytecodeVerificationLocal, false) != JVMFlag::SUCCESS) {</span>
2808           return JNI_EINVAL;
2809         }
<span class="line-modified">2810         if (FLAG_SET_CMDLINE(BytecodeVerificationRemote, true) != JVMFlag::SUCCESS) {</span>
2811           return JNI_EINVAL;
2812         }
2813       } else if (strcmp(tail, &quot;:none&quot;) == 0) {
<span class="line-modified">2814         if (FLAG_SET_CMDLINE(BytecodeVerificationLocal, false) != JVMFlag::SUCCESS) {</span>
2815           return JNI_EINVAL;
2816         }
<span class="line-modified">2817         if (FLAG_SET_CMDLINE(BytecodeVerificationRemote, false) != JVMFlag::SUCCESS) {</span>
2818           return JNI_EINVAL;
2819         }
2820         warning(&quot;Options -Xverify:none and -noverify were deprecated in JDK 13 and will likely be removed in a future release.&quot;);
2821       } else if (is_bad_option(option, args-&gt;ignoreUnrecognized, &quot;verification&quot;)) {
2822         return JNI_EINVAL;
2823       }
2824     // -Xdebug
2825     } else if (match_option(option, &quot;-Xdebug&quot;)) {
2826       // note this flag has been used, then ignore
2827       set_xdebug_mode(true);
2828     // -Xnoagent
2829     } else if (match_option(option, &quot;-Xnoagent&quot;)) {
2830       // For compatibility with classic. HotSpot refuses to load the old style agent.dll.
2831     } else if (match_option(option, &quot;-Xloggc:&quot;, &amp;tail)) {
2832       // Deprecated flag to redirect GC output to a file. -Xloggc:&lt;filename&gt;
2833       log_warning(gc)(&quot;-Xloggc is deprecated. Will use -Xlog:gc:%s instead.&quot;, tail);
2834       _gc_log_filename = os::strdup_check_oom(tail);
2835     } else if (match_option(option, &quot;-Xlog&quot;, &amp;tail)) {
2836       bool ret = false;
2837       if (strcmp(tail, &quot;:help&quot;) == 0) {
</pre>
<hr />
<pre>
2857     } else if (match_option(option, &quot;-Xcheck&quot;, &amp;tail)) {
2858       if (!strcmp(tail, &quot;:jni&quot;)) {
2859 #if !INCLUDE_JNI_CHECK
2860         warning(&quot;JNI CHECKING is not supported in this VM&quot;);
2861 #else
2862         CheckJNICalls = true;
2863 #endif // INCLUDE_JNI_CHECK
2864       } else if (is_bad_option(option, args-&gt;ignoreUnrecognized,
2865                                      &quot;check&quot;)) {
2866         return JNI_EINVAL;
2867       }
2868     } else if (match_option(option, &quot;vfprintf&quot;)) {
2869       _vfprintf_hook = CAST_TO_FN_PTR(vfprintf_hook_t, option-&gt;extraInfo);
2870     } else if (match_option(option, &quot;exit&quot;)) {
2871       _exit_hook = CAST_TO_FN_PTR(exit_hook_t, option-&gt;extraInfo);
2872     } else if (match_option(option, &quot;abort&quot;)) {
2873       _abort_hook = CAST_TO_FN_PTR(abort_hook_t, option-&gt;extraInfo);
2874     // Need to keep consistency of MaxTenuringThreshold and AlwaysTenure/NeverTenure;
2875     // and the last option wins.
2876     } else if (match_option(option, &quot;-XX:+NeverTenure&quot;)) {
<span class="line-modified">2877       if (FLAG_SET_CMDLINE(NeverTenure, true) != JVMFlag::SUCCESS) {</span>
2878         return JNI_EINVAL;
2879       }
<span class="line-modified">2880       if (FLAG_SET_CMDLINE(AlwaysTenure, false) != JVMFlag::SUCCESS) {</span>
2881         return JNI_EINVAL;
2882       }
<span class="line-modified">2883       if (FLAG_SET_CMDLINE(MaxTenuringThreshold, markWord::max_age + 1) != JVMFlag::SUCCESS) {</span>
2884         return JNI_EINVAL;
2885       }
2886     } else if (match_option(option, &quot;-XX:+AlwaysTenure&quot;)) {
<span class="line-modified">2887       if (FLAG_SET_CMDLINE(NeverTenure, false) != JVMFlag::SUCCESS) {</span>
2888         return JNI_EINVAL;
2889       }
<span class="line-modified">2890       if (FLAG_SET_CMDLINE(AlwaysTenure, true) != JVMFlag::SUCCESS) {</span>
2891         return JNI_EINVAL;
2892       }
<span class="line-modified">2893       if (FLAG_SET_CMDLINE(MaxTenuringThreshold, 0) != JVMFlag::SUCCESS) {</span>
2894         return JNI_EINVAL;
2895       }
2896     } else if (match_option(option, &quot;-XX:MaxTenuringThreshold=&quot;, &amp;tail)) {
2897       uintx max_tenuring_thresh = 0;
2898       if (!parse_uintx(tail, &amp;max_tenuring_thresh, 0)) {
2899         jio_fprintf(defaultStream::error_stream(),
2900                     &quot;Improperly specified VM option \&#39;MaxTenuringThreshold=%s\&#39;\n&quot;, tail);
2901         return JNI_EINVAL;
2902       }
2903 
<span class="line-modified">2904       if (FLAG_SET_CMDLINE(MaxTenuringThreshold, max_tenuring_thresh) != JVMFlag::SUCCESS) {</span>
2905         return JNI_EINVAL;
2906       }
2907 
2908       if (MaxTenuringThreshold == 0) {
<span class="line-modified">2909         if (FLAG_SET_CMDLINE(NeverTenure, false) != JVMFlag::SUCCESS) {</span>
2910           return JNI_EINVAL;
2911         }
<span class="line-modified">2912         if (FLAG_SET_CMDLINE(AlwaysTenure, true) != JVMFlag::SUCCESS) {</span>
2913           return JNI_EINVAL;
2914         }
2915       } else {
<span class="line-modified">2916         if (FLAG_SET_CMDLINE(NeverTenure, false) != JVMFlag::SUCCESS) {</span>
2917           return JNI_EINVAL;
2918         }
<span class="line-modified">2919         if (FLAG_SET_CMDLINE(AlwaysTenure, false) != JVMFlag::SUCCESS) {</span>
2920           return JNI_EINVAL;
2921         }
2922       }
2923     } else if (match_option(option, &quot;-XX:+DisplayVMOutputToStderr&quot;)) {
<span class="line-modified">2924       if (FLAG_SET_CMDLINE(DisplayVMOutputToStdout, false) != JVMFlag::SUCCESS) {</span>
2925         return JNI_EINVAL;
2926       }
<span class="line-modified">2927       if (FLAG_SET_CMDLINE(DisplayVMOutputToStderr, true) != JVMFlag::SUCCESS) {</span>
2928         return JNI_EINVAL;
2929       }
2930     } else if (match_option(option, &quot;-XX:+DisplayVMOutputToStdout&quot;)) {
<span class="line-modified">2931       if (FLAG_SET_CMDLINE(DisplayVMOutputToStderr, false) != JVMFlag::SUCCESS) {</span>
<span class="line-added">2932         return JNI_EINVAL;</span>
<span class="line-added">2933       }</span>
<span class="line-added">2934       if (FLAG_SET_CMDLINE(DisplayVMOutputToStdout, true) != JVMFlag::SUCCESS) {</span>
<span class="line-added">2935         return JNI_EINVAL;</span>
<span class="line-added">2936       }</span>
<span class="line-added">2937     } else if (match_option(option, &quot;-XX:+ErrorFileToStderr&quot;)) {</span>
<span class="line-added">2938       if (FLAG_SET_CMDLINE(ErrorFileToStdout, false) != JVMFlag::SUCCESS) {</span>
<span class="line-added">2939         return JNI_EINVAL;</span>
<span class="line-added">2940       }</span>
<span class="line-added">2941       if (FLAG_SET_CMDLINE(ErrorFileToStderr, true) != JVMFlag::SUCCESS) {</span>
<span class="line-added">2942         return JNI_EINVAL;</span>
<span class="line-added">2943       }</span>
<span class="line-added">2944     } else if (match_option(option, &quot;-XX:+ErrorFileToStdout&quot;)) {</span>
<span class="line-added">2945       if (FLAG_SET_CMDLINE(ErrorFileToStderr, false) != JVMFlag::SUCCESS) {</span>
2946         return JNI_EINVAL;
2947       }
<span class="line-modified">2948       if (FLAG_SET_CMDLINE(ErrorFileToStdout, true) != JVMFlag::SUCCESS) {</span>
2949         return JNI_EINVAL;
2950       }
2951     } else if (match_option(option, &quot;-XX:+ExtendedDTraceProbes&quot;)) {
2952 #if defined(DTRACE_ENABLED)
<span class="line-modified">2953       if (FLAG_SET_CMDLINE(ExtendedDTraceProbes, true) != JVMFlag::SUCCESS) {</span>
2954         return JNI_EINVAL;
2955       }
<span class="line-modified">2956       if (FLAG_SET_CMDLINE(DTraceMethodProbes, true) != JVMFlag::SUCCESS) {</span>
2957         return JNI_EINVAL;
2958       }
<span class="line-modified">2959       if (FLAG_SET_CMDLINE(DTraceAllocProbes, true) != JVMFlag::SUCCESS) {</span>
2960         return JNI_EINVAL;
2961       }
<span class="line-modified">2962       if (FLAG_SET_CMDLINE(DTraceMonitorProbes, true) != JVMFlag::SUCCESS) {</span>
2963         return JNI_EINVAL;
2964       }
2965 #else // defined(DTRACE_ENABLED)
2966       jio_fprintf(defaultStream::error_stream(),
2967                   &quot;ExtendedDTraceProbes flag is not applicable for this configuration\n&quot;);
2968       return JNI_EINVAL;
2969 #endif // defined(DTRACE_ENABLED)
2970 #ifdef ASSERT
2971     } else if (match_option(option, &quot;-XX:+FullGCALot&quot;)) {
<span class="line-modified">2972       if (FLAG_SET_CMDLINE(FullGCALot, true) != JVMFlag::SUCCESS) {</span>
2973         return JNI_EINVAL;
2974       }
2975       // disable scavenge before parallel mark-compact
<span class="line-modified">2976       if (FLAG_SET_CMDLINE(ScavengeBeforeFullGC, false) != JVMFlag::SUCCESS) {</span>
2977         return JNI_EINVAL;
2978       }
2979 #endif
2980 #if !INCLUDE_MANAGEMENT
2981     } else if (match_option(option, &quot;-XX:+ManagementServer&quot;)) {
2982         jio_fprintf(defaultStream::error_stream(),
2983           &quot;ManagementServer is not supported in this VM.\n&quot;);
2984         return JNI_ERR;
2985 #endif // INCLUDE_MANAGEMENT
<span class="line-added">2986 #if INCLUDE_JVMCI</span>
<span class="line-added">2987     } else if (match_option(option, &quot;-XX:-EnableJVMCIProduct&quot;)) {</span>
<span class="line-added">2988       if (EnableJVMCIProduct) {</span>
<span class="line-added">2989         jio_fprintf(defaultStream::error_stream(),</span>
<span class="line-added">2990                   &quot;-XX:-EnableJVMCIProduct cannot come after -XX:+EnableJVMCIProduct\n&quot;);</span>
<span class="line-added">2991         return JNI_EINVAL;</span>
<span class="line-added">2992       }</span>
<span class="line-added">2993     } else if (match_option(option, &quot;-XX:+EnableJVMCIProduct&quot;)) {</span>
<span class="line-added">2994       JVMFlag *jvmciFlag = JVMFlag::find_flag(&quot;EnableJVMCIProduct&quot;);</span>
<span class="line-added">2995       // Allow this flag if it has been unlocked.</span>
<span class="line-added">2996       if (jvmciFlag != NULL &amp;&amp; jvmciFlag-&gt;is_unlocked()) {</span>
<span class="line-added">2997         if (!JVMCIGlobals::enable_jvmci_product_mode(origin)) {</span>
<span class="line-added">2998           jio_fprintf(defaultStream::error_stream(),</span>
<span class="line-added">2999             &quot;Unable to enable JVMCI in product mode&quot;);</span>
<span class="line-added">3000           return JNI_ERR;</span>
<span class="line-added">3001         }</span>
<span class="line-added">3002       }</span>
<span class="line-added">3003       // The flag was locked so process normally to report that error</span>
<span class="line-added">3004       else if (!process_argument(&quot;EnableJVMCIProduct&quot;, args-&gt;ignoreUnrecognized, origin)) {</span>
<span class="line-added">3005         return JNI_EINVAL;</span>
<span class="line-added">3006       }</span>
<span class="line-added">3007 #endif // INCLUDE_JVMCI</span>
3008 #if INCLUDE_JFR
3009     } else if (match_jfr_option(&amp;option)) {
3010       return JNI_EINVAL;
3011 #endif
3012     } else if (match_option(option, &quot;-XX:&quot;, &amp;tail)) { // -XX:xxxx
3013       // Skip -XX:Flags= and -XX:VMOptionsFile= since those cases have
3014       // already been handled
3015       if ((strncmp(tail, &quot;Flags=&quot;, strlen(&quot;Flags=&quot;)) != 0) &amp;&amp;
3016           (strncmp(tail, &quot;VMOptionsFile=&quot;, strlen(&quot;VMOptionsFile=&quot;)) != 0)) {
3017         if (!process_argument(tail, args-&gt;ignoreUnrecognized, origin)) {
3018           return JNI_EINVAL;
3019         }
3020       }
3021     // Unknown option
3022     } else if (is_bad_option(option, args-&gt;ignoreUnrecognized)) {
3023       return JNI_ERR;
3024     }
3025   }
3026 
3027   // PrintSharedArchiveAndExit will turn on
3028   //   -Xshare:on
3029   //   -Xlog:class+path=info
3030   if (PrintSharedArchiveAndExit) {
<span class="line-modified">3031     if (FLAG_SET_CMDLINE(UseSharedSpaces, true) != JVMFlag::SUCCESS) {</span>
3032       return JNI_EINVAL;
3033     }
<span class="line-modified">3034     if (FLAG_SET_CMDLINE(RequireSharedSpaces, true) != JVMFlag::SUCCESS) {</span>
3035       return JNI_EINVAL;
3036     }
3037     LogConfiguration::configure_stdout(LogLevel::Info, true, LOG_TAGS(class, path));
3038   }
3039 








3040   fix_appclasspath();
3041 
3042   return JNI_OK;
3043 }
3044 
3045 void Arguments::add_patch_mod_prefix(const char* module_name, const char* path, bool* patch_mod_javabase) {
3046   // For java.base check for duplicate --patch-module options being specified on the command line.
3047   // This check is only required for java.base, all other duplicate module specifications
3048   // will be checked during module system initialization.  The module system initialization
3049   // will throw an ExceptionInInitializerError if this situation occurs.
3050   if (strcmp(module_name, JAVA_BASE_NAME) == 0) {
3051     if (*patch_mod_javabase) {
3052       vm_exit_during_initialization(&quot;Cannot specify &quot; JAVA_BASE_NAME &quot; more than once to --patch-module&quot;);
3053     } else {
3054       *patch_mod_javabase = true;
3055     }
3056   }
3057 
3058   // Create GrowableArray lazily, only if --patch-module has been specified
3059   if (_patch_mod_prefix == NULL) {
</pre>
<hr />
<pre>
3139   }
3140 
3141   // This must be done after all arguments have been processed.
3142   // java_compiler() true means set to &quot;NONE&quot; or empty.
3143   if (java_compiler() &amp;&amp; !xdebug_mode()) {
3144     // For backwards compatibility, we switch to interpreted mode if
3145     // -Djava.compiler=&quot;NONE&quot; or &quot;&quot; is specified AND &quot;-Xdebug&quot; was
3146     // not specified.
3147     set_mode_flags(_int);
3148   }
3149 
3150   // CompileThresholdScaling == 0.0 is same as -Xint: Disable compilation (enable interpreter-only mode),
3151   // but like -Xint, leave compilation thresholds unaffected.
3152   // With tiered compilation disabled, setting CompileThreshold to 0 disables compilation as well.
3153   if ((CompileThresholdScaling == 0.0) || (!TieredCompilation &amp;&amp; CompileThreshold == 0)) {
3154     set_mode_flags(_int);
3155   }
3156 
3157   // eventually fix up InitialTenuringThreshold if only MaxTenuringThreshold is set
3158   if (FLAG_IS_DEFAULT(InitialTenuringThreshold) &amp;&amp; (InitialTenuringThreshold &gt; MaxTenuringThreshold)) {
<span class="line-modified">3159     FLAG_SET_ERGO(InitialTenuringThreshold, MaxTenuringThreshold);</span>
3160   }
3161 
3162 #if !COMPILER2_OR_JVMCI
3163   // Don&#39;t degrade server performance for footprint
3164   if (FLAG_IS_DEFAULT(UseLargePages) &amp;&amp;
3165       MaxHeapSize &lt; LargePageHeapSizeThreshold) {
3166     // No need for large granularity pages w/small heaps.
3167     // Note that large pages are enabled/disabled for both the
3168     // Java heap and the code cache.
3169     FLAG_SET_DEFAULT(UseLargePages, false);
3170   }
3171 
3172   UNSUPPORTED_OPTION(ProfileInterpreter);
3173   NOT_PRODUCT(UNSUPPORTED_OPTION(TraceProfileInterpreter));
3174 #endif
3175 
<span class="line-modified">3176 </span>
<span class="line-added">3177 #ifdef TIERED</span>
<span class="line-added">3178   // Parse the CompilationMode flag</span>
<span class="line-added">3179   if (!CompilationModeFlag::initialize()) {</span>
<span class="line-added">3180     return JNI_ERR;</span>
<span class="line-added">3181   }</span>
<span class="line-added">3182 #else</span>
3183   // Tiered compilation is undefined.
3184   UNSUPPORTED_OPTION(TieredCompilation);
3185 #endif
3186 
3187   if (!check_vm_args_consistency()) {
3188     return JNI_ERR;
3189   }
3190 
3191 #if INCLUDE_CDS
3192   if (DumpSharedSpaces) {
3193     // Disable biased locking now as it interferes with the clean up of
3194     // the archived Klasses and Java string objects (at dump time only).
3195     UseBiasedLocking = false;
3196 
<span class="line-added">3197     // Compiler threads may concurrently update the class metadata (such as method entries), so it&#39;s</span>
<span class="line-added">3198     // unsafe with DumpSharedSpaces (which modifies the class metadata in place). Let&#39;s disable</span>
<span class="line-added">3199     // compiler just to be safe.</span>
<span class="line-added">3200     //</span>
<span class="line-added">3201     // Note: this is not a concern for DynamicDumpSharedSpaces, which makes a copy of the class metadata</span>
<span class="line-added">3202     // instead of modifying them in place. The copy is inaccessible to the compiler.</span>
<span class="line-added">3203     // TODO: revisit the following for the static archive case.</span>
<span class="line-added">3204     set_mode_flags(_int);</span>
<span class="line-added">3205   }</span>
<span class="line-added">3206   if (DumpSharedSpaces || ArchiveClassesAtExit != NULL) {</span>
3207     // Always verify non-system classes during CDS dump
3208     if (!BytecodeVerificationRemote) {
3209       BytecodeVerificationRemote = true;
3210       log_info(cds)(&quot;All non-system classes will be verified (-Xverify:remote) during CDS dump time.&quot;);
3211     }
<span class="line-modified">3212   }</span>
<span class="line-modified">3213   if (ArchiveClassesAtExit == NULL) {</span>
<span class="line-modified">3214     FLAG_SET_DEFAULT(DynamicDumpSharedSpaces, false);</span>

3215   }
3216   if (UseSharedSpaces &amp;&amp; patch_mod_javabase) {
3217     no_shared_spaces(&quot;CDS is disabled when &quot; JAVA_BASE_NAME &quot; module is patched.&quot;);
3218   }
3219   if (UseSharedSpaces &amp;&amp; !DumpSharedSpaces &amp;&amp; check_unsupported_cds_runtime_properties()) {
3220     FLAG_SET_DEFAULT(UseSharedSpaces, false);
3221   }
3222 #endif
3223 
3224 #ifndef CAN_SHOW_REGISTERS_ON_ASSERT
3225   UNSUPPORTED_OPTION(ShowRegistersOnAssert);
3226 #endif // CAN_SHOW_REGISTERS_ON_ASSERT
3227 
3228   return JNI_OK;
3229 }
3230 
3231 // Helper class for controlling the lifetime of JavaVMInitArgs
3232 // objects.  The contents of the JavaVMInitArgs are guaranteed to be
3233 // deleted on the destruction of the ScopedVMInitArgs object.
3234 class ScopedVMInitArgs : public StackObj {
</pre>
<hr />
<pre>
3478     // We now have a complete token
3479 
3480     JavaVMOption option;
3481     option.optionString = opt_hd;
3482     option.extraInfo = NULL;
3483 
3484     options-&gt;append(option);                // Fill in option
3485 
3486     rd++;  // Advance to next character
3487   }
3488 
3489   // Fill out JavaVMInitArgs structure.
3490   jint status = vm_args-&gt;set_args(options);
3491 
3492   delete options;
3493   return status;
3494 }
3495 
3496 void Arguments::set_shared_spaces_flags() {
3497   if (DumpSharedSpaces) {








3498     if (RequireSharedSpaces) {
3499       warning(&quot;Cannot dump shared archive while using shared archive&quot;);
3500     }
3501     UseSharedSpaces = false;










3502   }
3503 }
3504 
<span class="line-added">3505 #if INCLUDE_CDS</span>
3506 // Sharing support
3507 // Construct the path to the archive
3508 char* Arguments::get_default_shared_archive_path() {
3509   char *default_archive_path;
3510   char jvm_path[JVM_MAXPATHLEN];
3511   os::jvm_path(jvm_path, sizeof(jvm_path));
3512   char *end = strrchr(jvm_path, *os::file_separator());
3513   if (end != NULL) *end = &#39;\0&#39;;
3514   size_t jvm_path_len = strlen(jvm_path);
3515   size_t file_sep_len = strlen(os::file_separator());
3516   const size_t len = jvm_path_len + file_sep_len + 20;
3517   default_archive_path = NEW_C_HEAP_ARRAY(char, len, mtArguments);
<span class="line-modified">3518   jio_snprintf(default_archive_path, len, &quot;%s%sclasses.jsa&quot;,</span>
<span class="line-modified">3519                jvm_path, os::file_separator());</span>


3520   return default_archive_path;
3521 }
3522 
<span class="line-modified">3523 int Arguments::num_archives(const char* archive_path) {</span>
<span class="line-modified">3524   if (archive_path == NULL) {</span>
<span class="line-added">3525     return 0;</span>
<span class="line-added">3526   }</span>
<span class="line-added">3527   int npaths = 1;</span>
<span class="line-added">3528   char* p = (char*)archive_path;</span>
<span class="line-added">3529   while (*p != &#39;\0&#39;) {</span>
<span class="line-added">3530     if (*p == os::path_separator()[0]) {</span>
<span class="line-added">3531       npaths++;</span>
<span class="line-added">3532     }</span>
<span class="line-added">3533     p++;</span>
<span class="line-added">3534   }</span>
<span class="line-added">3535   return npaths;</span>
<span class="line-added">3536 }</span>
<span class="line-added">3537 </span>
<span class="line-added">3538 void Arguments::extract_shared_archive_paths(const char* archive_path,</span>
<span class="line-added">3539                                          char** base_archive_path,</span>
<span class="line-added">3540                                          char** top_archive_path) {</span>
<span class="line-added">3541   char* begin_ptr = (char*)archive_path;</span>
<span class="line-added">3542   char* end_ptr = strchr((char*)archive_path, os::path_separator()[0]);</span>
<span class="line-added">3543   if (end_ptr == NULL || end_ptr == begin_ptr) {</span>
<span class="line-added">3544     vm_exit_during_initialization(&quot;Base archive was not specified&quot;, archive_path);</span>
<span class="line-added">3545   }</span>
<span class="line-added">3546   size_t len = end_ptr - begin_ptr;</span>
<span class="line-added">3547   char* cur_path = NEW_C_HEAP_ARRAY(char, len + 1, mtInternal);</span>
<span class="line-added">3548   strncpy(cur_path, begin_ptr, len);</span>
<span class="line-added">3549   cur_path[len] = &#39;\0&#39;;</span>
<span class="line-added">3550   FileMapInfo::check_archive((const char*)cur_path, true /*is_static*/);</span>
<span class="line-added">3551   *base_archive_path = cur_path;</span>
<span class="line-added">3552 </span>
<span class="line-added">3553   begin_ptr = ++end_ptr;</span>
<span class="line-added">3554   if (*begin_ptr == &#39;\0&#39;) {</span>
<span class="line-added">3555     vm_exit_during_initialization(&quot;Top archive was not specified&quot;, archive_path);</span>
<span class="line-added">3556   }</span>
<span class="line-added">3557   end_ptr = strchr(begin_ptr, &#39;\0&#39;);</span>
<span class="line-added">3558   assert(end_ptr != NULL, &quot;sanity&quot;);</span>
<span class="line-added">3559   len = end_ptr - begin_ptr;</span>
<span class="line-added">3560   cur_path = NEW_C_HEAP_ARRAY(char, len + 1, mtInternal);</span>
<span class="line-added">3561   strncpy(cur_path, begin_ptr, len + 1);</span>
<span class="line-added">3562   //cur_path[len] = &#39;\0&#39;;</span>
<span class="line-added">3563   FileMapInfo::check_archive((const char*)cur_path, false /*is_static*/);</span>
<span class="line-added">3564   *top_archive_path = cur_path;</span>
<span class="line-added">3565 }</span>
<span class="line-added">3566 </span>
<span class="line-added">3567 bool Arguments::init_shared_archive_paths() {</span>
<span class="line-added">3568   if (ArchiveClassesAtExit != NULL) {</span>
<span class="line-added">3569     if (DumpSharedSpaces) {</span>
<span class="line-added">3570       vm_exit_during_initialization(&quot;-XX:ArchiveClassesAtExit cannot be used with -Xshare:dump&quot;);</span>
<span class="line-added">3571     }</span>
<span class="line-added">3572     if (FLAG_SET_CMDLINE(DynamicDumpSharedSpaces, true) != JVMFlag::SUCCESS) {</span>
<span class="line-added">3573       return false;</span>
<span class="line-added">3574     }</span>
<span class="line-added">3575     check_unsupported_dumping_properties();</span>
<span class="line-added">3576     SharedDynamicArchivePath = os::strdup_check_oom(ArchiveClassesAtExit, mtArguments);</span>
<span class="line-added">3577   }</span>
3578   if (SharedArchiveFile == NULL) {
<span class="line-modified">3579     SharedArchivePath = get_default_shared_archive_path();</span>
3580   } else {
<span class="line-modified">3581     int archives = num_archives(SharedArchiveFile);</span>
<span class="line-added">3582     if (is_dumping_archive()) {</span>
<span class="line-added">3583       if (archives &gt; 1) {</span>
<span class="line-added">3584         vm_exit_during_initialization(</span>
<span class="line-added">3585           &quot;Cannot have more than 1 archive file specified in -XX:SharedArchiveFile during CDS dumping&quot;);</span>
<span class="line-added">3586       }</span>
<span class="line-added">3587       if (DynamicDumpSharedSpaces) {</span>
<span class="line-added">3588         if (os::same_files(SharedArchiveFile, ArchiveClassesAtExit)) {</span>
<span class="line-added">3589           vm_exit_during_initialization(</span>
<span class="line-added">3590             &quot;Cannot have the same archive file specified for -XX:SharedArchiveFile and -XX:ArchiveClassesAtExit&quot;,</span>
<span class="line-added">3591             SharedArchiveFile);</span>
<span class="line-added">3592         }</span>
<span class="line-added">3593       }</span>
<span class="line-added">3594     }</span>
<span class="line-added">3595     if (!is_dumping_archive()){</span>
<span class="line-added">3596       if (archives &gt; 2) {</span>
<span class="line-added">3597         vm_exit_during_initialization(</span>
<span class="line-added">3598           &quot;Cannot have more than 2 archive files specified in the -XX:SharedArchiveFile option&quot;);</span>
<span class="line-added">3599       }</span>
<span class="line-added">3600       if (archives == 1) {</span>
<span class="line-added">3601         char* temp_archive_path = os::strdup_check_oom(SharedArchiveFile, mtArguments);</span>
<span class="line-added">3602         int name_size;</span>
<span class="line-added">3603         bool success =</span>
<span class="line-added">3604           FileMapInfo::get_base_archive_name_from_header(temp_archive_path, &amp;name_size, &amp;SharedArchivePath);</span>
<span class="line-added">3605         if (!success) {</span>
<span class="line-added">3606           SharedArchivePath = temp_archive_path;</span>
<span class="line-added">3607         } else {</span>
<span class="line-added">3608           SharedDynamicArchivePath = temp_archive_path;</span>
<span class="line-added">3609         }</span>
<span class="line-added">3610       } else {</span>
<span class="line-added">3611         extract_shared_archive_paths((const char*)SharedArchiveFile,</span>
<span class="line-added">3612                                       &amp;SharedArchivePath, &amp;SharedDynamicArchivePath);</span>
<span class="line-added">3613       }</span>
<span class="line-added">3614     } else { // CDS dumping</span>
<span class="line-added">3615       SharedArchivePath = os::strdup_check_oom(SharedArchiveFile, mtArguments);</span>
<span class="line-added">3616     }</span>
3617   }
<span class="line-modified">3618   return (SharedArchivePath != NULL);</span>
3619 }
<span class="line-added">3620 #endif // INCLUDE_CDS</span>
3621 
3622 #ifndef PRODUCT
3623 // Determine whether LogVMOutput should be implicitly turned on.
3624 static bool use_vm_log() {
3625   if (LogCompilation || !FLAG_IS_DEFAULT(LogFile) ||
3626       PrintCompilation || PrintInlining || PrintDependencies || PrintNativeNMethods ||
3627       PrintDebugInfo || PrintRelocations || PrintNMethods || PrintExceptionHandlers ||
3628       PrintAssembly || TraceDeoptimization || TraceDependencies ||
3629       (VerifyDependencies &amp;&amp; FLAG_IS_CMDLINE(VerifyDependencies))) {
3630     return true;
3631   }
3632 
3633 #ifdef COMPILER1
3634   if (PrintC1Statistics) {
3635     return true;
3636   }
3637 #endif // COMPILER1
3638 
3639 #ifdef COMPILER2
3640   if (PrintOptoAssembly || PrintOptoStatistics) {
</pre>
<hr />
<pre>
3818   if (PrintGC) {
3819     log_warning(gc)(&quot;-XX:+PrintGC is deprecated. Will use -Xlog:gc instead.&quot;);
3820   }
3821   if (PrintGCDetails) {
3822     log_warning(gc)(&quot;-XX:+PrintGCDetails is deprecated. Will use -Xlog:gc* instead.&quot;);
3823   }
3824 
3825   if (_gc_log_filename != NULL) {
3826     // -Xloggc was used to specify a filename
3827     const char* gc_conf = PrintGCDetails ? &quot;gc*&quot; : &quot;gc&quot;;
3828 
3829     LogTarget(Error, logging) target;
3830     LogStream errstream(target);
3831     return LogConfiguration::parse_log_arguments(_gc_log_filename, gc_conf, NULL, NULL, &amp;errstream);
3832   } else if (PrintGC || PrintGCDetails) {
3833     LogConfiguration::configure_stdout(LogLevel::Info, !PrintGCDetails, LOG_TAGS(gc));
3834   }
3835   return true;
3836 }
3837 









3838 // Parse entry point called from JNI_CreateJavaVM
3839 
3840 jint Arguments::parse(const JavaVMInitArgs* initial_cmd_args) {
<span class="line-modified">3841   assert(verify_special_jvm_flags(false), &quot;deprecated and obsolete flag table inconsistent&quot;);</span>
3842 
<span class="line-modified">3843   // Initialize ranges and constraints</span>
3844   JVMFlagRangeList::init();
3845   JVMFlagConstraintList::init();

3846 
3847   // If flag &quot;-XX:Flags=flags-file&quot; is used it will be the first option to be processed.
3848   const char* hotspotrc = &quot;.hotspotrc&quot;;
3849   bool settings_file_specified = false;
3850   bool needs_hotspotrc_warning = false;
<span class="line-added">3851   ScopedVMInitArgs initial_vm_options_args(&quot;&quot;);</span>
3852   ScopedVMInitArgs initial_java_tool_options_args(&quot;env_var=&#39;JAVA_TOOL_OPTIONS&#39;&quot;);
3853   ScopedVMInitArgs initial_java_options_args(&quot;env_var=&#39;_JAVA_OPTIONS&#39;&quot;);
3854 
3855   // Pointers to current working set of containers
3856   JavaVMInitArgs* cur_cmd_args;
<span class="line-added">3857   JavaVMInitArgs* cur_vm_options_args;</span>
3858   JavaVMInitArgs* cur_java_options_args;
3859   JavaVMInitArgs* cur_java_tool_options_args;
3860 
3861   // Containers for modified/expanded options
3862   ScopedVMInitArgs mod_cmd_args(&quot;cmd_line_args&quot;);
<span class="line-added">3863   ScopedVMInitArgs mod_vm_options_args(&quot;vm_options_args&quot;);</span>
3864   ScopedVMInitArgs mod_java_tool_options_args(&quot;env_var=&#39;JAVA_TOOL_OPTIONS&#39;&quot;);
3865   ScopedVMInitArgs mod_java_options_args(&quot;env_var=&#39;_JAVA_OPTIONS&#39;&quot;);
3866 
3867 
3868   jint code =
3869       parse_java_tool_options_environment_variable(&amp;initial_java_tool_options_args);
3870   if (code != JNI_OK) {
3871     return code;
3872   }
3873 
3874   code = parse_java_options_environment_variable(&amp;initial_java_options_args);
3875   if (code != JNI_OK) {
3876     return code;
3877   }
3878 
<span class="line-added">3879   // Parse the options in the /java.base/jdk/internal/vm/options resource, if present</span>
<span class="line-added">3880   char *vmoptions = ClassLoader::lookup_vm_options();</span>
<span class="line-added">3881   if (vmoptions != NULL) {</span>
<span class="line-added">3882     code = parse_options_buffer(&quot;vm options resource&quot;, vmoptions, strlen(vmoptions), &amp;initial_vm_options_args);</span>
<span class="line-added">3883     FREE_C_HEAP_ARRAY(char, vmoptions);</span>
<span class="line-added">3884     if (code != JNI_OK) {</span>
<span class="line-added">3885       return code;</span>
<span class="line-added">3886     }</span>
<span class="line-added">3887   }</span>
<span class="line-added">3888 </span>
3889   code = expand_vm_options_as_needed(initial_java_tool_options_args.get(),
3890                                      &amp;mod_java_tool_options_args,
3891                                      &amp;cur_java_tool_options_args);
3892   if (code != JNI_OK) {
3893     return code;
3894   }
3895 
3896   code = expand_vm_options_as_needed(initial_cmd_args,
3897                                      &amp;mod_cmd_args,
3898                                      &amp;cur_cmd_args);
3899   if (code != JNI_OK) {
3900     return code;
3901   }
3902 
3903   code = expand_vm_options_as_needed(initial_java_options_args.get(),
3904                                      &amp;mod_java_options_args,
3905                                      &amp;cur_java_options_args);
3906   if (code != JNI_OK) {
3907     return code;
3908   }
3909 
<span class="line-added">3910   code = expand_vm_options_as_needed(initial_vm_options_args.get(),</span>
<span class="line-added">3911                                      &amp;mod_vm_options_args,</span>
<span class="line-added">3912                                      &amp;cur_vm_options_args);</span>
<span class="line-added">3913   if (code != JNI_OK) {</span>
<span class="line-added">3914     return code;</span>
<span class="line-added">3915   }</span>
<span class="line-added">3916 </span>
3917   const char* flags_file = Arguments::get_jvm_flags_file();
3918   settings_file_specified = (flags_file != NULL);
3919 
3920   if (IgnoreUnrecognizedVMOptions) {
3921     cur_cmd_args-&gt;ignoreUnrecognized = true;
3922     cur_java_tool_options_args-&gt;ignoreUnrecognized = true;
3923     cur_java_options_args-&gt;ignoreUnrecognized = true;
3924   }
3925 
3926   // Parse specified settings file
3927   if (settings_file_specified) {
3928     if (!process_settings_file(flags_file, true,
3929                                cur_cmd_args-&gt;ignoreUnrecognized)) {
3930       return JNI_EINVAL;
3931     }
3932   } else {
3933 #ifdef ASSERT
3934     // Parse default .hotspotrc settings file
3935     if (!process_settings_file(&quot;.hotspotrc&quot;, false,
3936                                cur_cmd_args-&gt;ignoreUnrecognized)) {
3937       return JNI_EINVAL;
3938     }
3939 #else
3940     struct stat buf;
3941     if (os::stat(hotspotrc, &amp;buf) == 0) {
3942       needs_hotspotrc_warning = true;
3943     }
3944 #endif
3945   }
3946 
3947   if (PrintVMOptions) {
3948     print_options(cur_java_tool_options_args);
3949     print_options(cur_cmd_args);
3950     print_options(cur_java_options_args);
3951   }
3952 
3953   // Parse JavaVMInitArgs structure passed in, as well as JAVA_TOOL_OPTIONS and _JAVA_OPTIONS
<span class="line-modified">3954   jint result = parse_vm_init_args(cur_vm_options_args,</span>
<span class="line-added">3955                                    cur_java_tool_options_args,</span>
3956                                    cur_java_options_args,
3957                                    cur_cmd_args);
3958 
3959   if (result != JNI_OK) {
3960     return result;
3961   }
3962 
<span class="line-modified">3963 #if INCLUDE_CDS</span>
<span class="line-modified">3964   // Initialize shared archive paths which could include both base and dynamic archive paths</span>
<span class="line-modified">3965   if (!init_shared_archive_paths()) {</span>
3966     return JNI_ENOMEM;
3967   }
<span class="line-modified">3968 #endif</span>




3969 
3970   // Delay warning until here so that we&#39;ve had a chance to process
3971   // the -XX:-PrintWarnings flag
3972   if (needs_hotspotrc_warning) {
3973     warning(&quot;%s file is present but has been ignored.  &quot;
3974             &quot;Run with -XX:Flags=%s to load the file.&quot;,
3975             hotspotrc, hotspotrc);
3976   }
3977 
3978   if (needs_module_property_warning) {
3979     warning(&quot;Ignoring system property options whose names match the &#39;-Djdk.module.*&#39;.&quot;
3980             &quot; names that are reserved for internal use.&quot;);
3981   }
3982 
3983 #if defined(_ALLBSD_SOURCE) || defined(AIX)  // UseLargePages is not yet supported on BSD and AIX.
3984   UNSUPPORTED_OPTION(UseLargePages);
3985 #endif
3986 
3987 #if defined(AIX)
3988   UNSUPPORTED_OPTION_NULL(AllocateHeapAt);
</pre>
<hr />
<pre>
4004   if (ScavengeRootsInCode == 0) {
4005     if (!FLAG_IS_DEFAULT(ScavengeRootsInCode)) {
4006       warning(&quot;Forcing ScavengeRootsInCode non-zero&quot;);
4007     }
4008     ScavengeRootsInCode = 1;
4009   }
4010 
4011   if (!handle_deprecated_print_gc_flags()) {
4012     return JNI_EINVAL;
4013   }
4014 
4015   // Set object alignment values.
4016   set_object_alignment();
4017 
4018 #if !INCLUDE_CDS
4019   if (DumpSharedSpaces || RequireSharedSpaces) {
4020     jio_fprintf(defaultStream::error_stream(),
4021       &quot;Shared spaces are not supported in this VM\n&quot;);
4022     return JNI_ERR;
4023   }
<span class="line-added">4024   if (DumpLoadedClassList != NULL) {</span>
<span class="line-added">4025     jio_fprintf(defaultStream::error_stream(),</span>
<span class="line-added">4026       &quot;DumpLoadedClassList is not supported in this VM\n&quot;);</span>
<span class="line-added">4027     return JNI_ERR;</span>
<span class="line-added">4028   }</span>
4029   if ((UseSharedSpaces &amp;&amp; FLAG_IS_CMDLINE(UseSharedSpaces)) ||
4030       log_is_enabled(Info, cds)) {
4031     warning(&quot;Shared spaces are not supported in this VM&quot;);
4032     FLAG_SET_DEFAULT(UseSharedSpaces, false);
4033     LogConfiguration::configure_stdout(LogLevel::Off, true, LOG_TAGS(cds));
4034   }
4035   no_shared_spaces(&quot;CDS Disabled&quot;);
4036 #endif // INCLUDE_CDS
4037 
<span class="line-added">4038 #ifndef TIERED</span>
<span class="line-added">4039   if (FLAG_IS_CMDLINE(CompilationMode)) {</span>
<span class="line-added">4040     warning(&quot;CompilationMode has no effect in non-tiered VMs&quot;);</span>
<span class="line-added">4041   }</span>
<span class="line-added">4042 #endif</span>
<span class="line-added">4043 </span>
4044   TSAN_RUNTIME_ONLY(
4045     // Currently TSAN is only implemented for interpreter.
4046     set_mode_flags(_int);
4047     // TSAN instrumentation is not implemented for the RewriteBytecodes
4048     // code paths because TSAN slows down the application so much that the
4049     // performance benefits from rewriting bytecodes is negligible.
<span class="line-modified">4050     FLAG_SET_ERGO(RewriteBytecodes, false);</span>
<span class="line-modified">4051     FLAG_SET_ERGO(RewriteFrequentPairs, false);</span>
4052     // Turn off CDS, it interferes with eagerly allocating jmethodIDs.
4053     no_shared_spaces(&quot;CDS is not compatible with TSAN&quot;);
4054   );
4055 
4056   return JNI_OK;
4057 }
4058 
4059 jint Arguments::apply_ergo() {
4060   // Set flags based on ergonomics.
4061   jint result = set_ergonomics_flags();
4062   if (result != JNI_OK) return result;
4063 
4064   // Set heap size based on available physical memory
4065   set_heap_size();
4066 
4067   GCConfig::arguments()-&gt;initialize();
4068 
4069   set_shared_spaces_flags();
4070 
4071   // Initialize Metaspace flags and alignments
</pre>
<hr />
<pre>
4136   }
4137 #endif // PRODUCT
4138 
4139   if (PrintCommandLineFlags) {
4140     JVMFlag::printSetFlags(tty);
4141   }
4142 
4143   // Apply CPU specific policy for the BiasedLocking
4144   if (UseBiasedLocking) {
4145     if (!VM_Version::use_biased_locking() &amp;&amp;
4146         !(FLAG_IS_CMDLINE(UseBiasedLocking))) {
4147       UseBiasedLocking = false;
4148     }
4149   }
4150 #ifdef COMPILER2
4151   if (!UseBiasedLocking) {
4152     UseOptoBiasInlining = false;
4153   }
4154 #endif
4155 














4156   return JNI_OK;
4157 }
4158 
4159 jint Arguments::adjust_after_os() {
4160   if (UseNUMA) {
<span class="line-modified">4161     if (UseParallelGC) {</span>


4162       if (FLAG_IS_DEFAULT(MinHeapDeltaBytes)) {
4163          FLAG_SET_DEFAULT(MinHeapDeltaBytes, 64*M);
4164       }
4165     }
<span class="line-modified">4166     // UseNUMAInterleaving is set to ON for all collectors and platforms when</span>
<span class="line-modified">4167     // UseNUMA is set to ON. NUMA-aware collectors will interleave old gen and</span>
<span class="line-modified">4168     // survivor spaces on top of NUMA allocation policy for the eden space.</span>
<span class="line-modified">4169     // Non NUMA-aware collectors will interleave all of the heap spaces across</span>
<span class="line-modified">4170     // NUMA nodes.</span>



4171     if (FLAG_IS_DEFAULT(UseNUMAInterleaving)) {
<span class="line-modified">4172       FLAG_SET_ERGO(UseNUMAInterleaving, true);</span>
4173     }
4174   }
4175   return JNI_OK;
4176 }
4177 
4178 int Arguments::PropertyList_count(SystemProperty* pl) {
4179   int count = 0;
4180   while(pl != NULL) {
4181     count++;
4182     pl = pl-&gt;next();
4183   }
4184   return count;
4185 }
4186 
4187 // Return the number of readable properties.
4188 int Arguments::PropertyList_readable_count(SystemProperty* pl) {
4189   int count = 0;
4190   while(pl != NULL) {
4191     if (pl-&gt;is_readable()) {
4192       count++;
</pre>
</td>
</tr>
</table>
<center><a href="../prims/unsafe.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="globals.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
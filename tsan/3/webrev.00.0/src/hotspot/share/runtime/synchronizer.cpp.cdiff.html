<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/hotspot/share/runtime/synchronizer.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="sharedRuntime.hpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="../tsan/tsan.cpp.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/runtime/synchronizer.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 1,7 ***</span>
  /*
<span class="line-modified">!  * Copyright (c) 1998, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.
<span class="line-new-header">--- 1,7 ---</span>
  /*
<span class="line-modified">!  * Copyright (c) 1998, 2020, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 29,11 ***</span>
  #include &quot;jfr/jfrEvents.hpp&quot;
  #include &quot;memory/allocation.inline.hpp&quot;
  #include &quot;memory/metaspaceShared.hpp&quot;
  #include &quot;memory/padded.hpp&quot;
  #include &quot;memory/resourceArea.hpp&quot;
<span class="line-modified">! #include &quot;oops/markOop.hpp&quot;</span>
  #include &quot;oops/oop.inline.hpp&quot;
  #include &quot;runtime/atomic.hpp&quot;
  #include &quot;runtime/biasedLocking.hpp&quot;
  #include &quot;runtime/handles.inline.hpp&quot;
  #include &quot;runtime/interfaceSupport.inline.hpp&quot;
<span class="line-new-header">--- 29,12 ---</span>
  #include &quot;jfr/jfrEvents.hpp&quot;
  #include &quot;memory/allocation.inline.hpp&quot;
  #include &quot;memory/metaspaceShared.hpp&quot;
  #include &quot;memory/padded.hpp&quot;
  #include &quot;memory/resourceArea.hpp&quot;
<span class="line-modified">! #include &quot;memory/universe.hpp&quot;</span>
<span class="line-added">+ #include &quot;oops/markWord.hpp&quot;</span>
  #include &quot;oops/oop.inline.hpp&quot;
  #include &quot;runtime/atomic.hpp&quot;
  #include &quot;runtime/biasedLocking.hpp&quot;
  #include &quot;runtime/handles.inline.hpp&quot;
  #include &quot;runtime/interfaceSupport.inline.hpp&quot;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 114,26 ***</span>
  
  #define NINFLATIONLOCKS 256
  static volatile intptr_t gInflationLocks[NINFLATIONLOCKS];
  
  // global list of blocks of monitors
<span class="line-modified">! PaddedEnd&lt;ObjectMonitor&gt; * volatile ObjectSynchronizer::gBlockList = NULL;</span>
<span class="line-modified">! // global monitor free list</span>
<span class="line-modified">! ObjectMonitor * volatile ObjectSynchronizer::gFreeList  = NULL;</span>
<span class="line-modified">! // global monitor in-use list, for moribund threads,</span>
<span class="line-modified">! // monitors they inflated need to be scanned for deflation</span>
<span class="line-modified">! ObjectMonitor * volatile ObjectSynchronizer::gOmInUseList  = NULL;</span>
<span class="line-modified">! // count of entries in gOmInUseList</span>
<span class="line-modified">! int ObjectSynchronizer::gOmInUseCount = 0;</span>
<span class="line-modified">! </span>
<span class="line-modified">! static volatile intptr_t gListLock = 0;      // protects global monitor lists</span>
<span class="line-modified">! static volatile int gMonitorFreeCount  = 0;  // # on gFreeList</span>
<span class="line-modified">! static volatile int gMonitorPopulation = 0;  // # Extant -- in circulation</span>
  
  #define CHAINMARKER (cast_to_oop&lt;intptr_t&gt;(-1))
  
  
  // =====================&gt; Quick functions
  
  // The quick_* forms are special fast-path variants used to improve
  // performance.  In the simplest case, a &quot;quick_*&quot; implementation could
  // simply return false, in which case the caller will perform the necessary
<span class="line-new-header">--- 115,278 ---</span>
  
  #define NINFLATIONLOCKS 256
  static volatile intptr_t gInflationLocks[NINFLATIONLOCKS];
  
  // global list of blocks of monitors
<span class="line-modified">! PaddedObjectMonitor* ObjectSynchronizer::g_block_list = NULL;</span>
<span class="line-modified">! </span>
<span class="line-modified">! struct ObjectMonitorListGlobals {</span>
<span class="line-modified">!   char         _pad_prefix[OM_CACHE_LINE_SIZE];</span>
<span class="line-modified">!   // These are highly shared list related variables.</span>
<span class="line-modified">!   // To avoid false-sharing they need to be the sole occupants of a cache line.</span>
<span class="line-modified">! </span>
<span class="line-modified">!   // Global ObjectMonitor free list. Newly allocated and deflated</span>
<span class="line-modified">!   // ObjectMonitors are prepended here.</span>
<span class="line-modified">!   ObjectMonitor* _free_list;</span>
<span class="line-modified">!   DEFINE_PAD_MINUS_SIZE(1, OM_CACHE_LINE_SIZE, sizeof(ObjectMonitor*));</span>
<span class="line-modified">! </span>
<span class="line-added">+   // Global ObjectMonitor in-use list. When a JavaThread is exiting,</span>
<span class="line-added">+   // ObjectMonitors on its per-thread in-use list are prepended here.</span>
<span class="line-added">+   ObjectMonitor* _in_use_list;</span>
<span class="line-added">+   DEFINE_PAD_MINUS_SIZE(2, OM_CACHE_LINE_SIZE, sizeof(ObjectMonitor*));</span>
<span class="line-added">+ </span>
<span class="line-added">+   int _free_count;    // # on free_list</span>
<span class="line-added">+   DEFINE_PAD_MINUS_SIZE(3, OM_CACHE_LINE_SIZE, sizeof(int));</span>
<span class="line-added">+ </span>
<span class="line-added">+   int _in_use_count;  // # on in_use_list</span>
<span class="line-added">+   DEFINE_PAD_MINUS_SIZE(4, OM_CACHE_LINE_SIZE, sizeof(int));</span>
<span class="line-added">+ </span>
<span class="line-added">+   int _population;    // # Extant -- in circulation</span>
<span class="line-added">+   DEFINE_PAD_MINUS_SIZE(5, OM_CACHE_LINE_SIZE, sizeof(int));</span>
<span class="line-added">+ };</span>
<span class="line-added">+ static ObjectMonitorListGlobals om_list_globals;</span>
  
  #define CHAINMARKER (cast_to_oop&lt;intptr_t&gt;(-1))
  
  
<span class="line-added">+ // =====================&gt; Spin-lock functions</span>
<span class="line-added">+ </span>
<span class="line-added">+ // ObjectMonitors are not lockable outside of this file. We use spin-locks</span>
<span class="line-added">+ // implemented using a bit in the _next_om field instead of the heavier</span>
<span class="line-added">+ // weight locking mechanisms for faster list management.</span>
<span class="line-added">+ </span>
<span class="line-added">+ #define OM_LOCK_BIT 0x1</span>
<span class="line-added">+ </span>
<span class="line-added">+ // Return true if the ObjectMonitor is locked.</span>
<span class="line-added">+ // Otherwise returns false.</span>
<span class="line-added">+ static bool is_locked(ObjectMonitor* om) {</span>
<span class="line-added">+   return ((intptr_t)om-&gt;next_om() &amp; OM_LOCK_BIT) == OM_LOCK_BIT;</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ // Mark an ObjectMonitor* with OM_LOCK_BIT and return it.</span>
<span class="line-added">+ static ObjectMonitor* mark_om_ptr(ObjectMonitor* om) {</span>
<span class="line-added">+   return (ObjectMonitor*)((intptr_t)om | OM_LOCK_BIT);</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ // Return the unmarked next field in an ObjectMonitor. Note: the next</span>
<span class="line-added">+ // field may or may not have been marked with OM_LOCK_BIT originally.</span>
<span class="line-added">+ static ObjectMonitor* unmarked_next(ObjectMonitor* om) {</span>
<span class="line-added">+   return (ObjectMonitor*)((intptr_t)om-&gt;next_om() &amp; ~OM_LOCK_BIT);</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ // Try to lock an ObjectMonitor. Returns true if locking was successful.</span>
<span class="line-added">+ // Otherwise returns false.</span>
<span class="line-added">+ static bool try_om_lock(ObjectMonitor* om) {</span>
<span class="line-added">+   // Get current next field without any OM_LOCK_BIT value.</span>
<span class="line-added">+   ObjectMonitor* next = unmarked_next(om);</span>
<span class="line-added">+   if (om-&gt;try_set_next_om(next, mark_om_ptr(next)) != next) {</span>
<span class="line-added">+     return false;  // Cannot lock the ObjectMonitor.</span>
<span class="line-added">+   }</span>
<span class="line-added">+   return true;</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ // Lock an ObjectMonitor.</span>
<span class="line-added">+ static void om_lock(ObjectMonitor* om) {</span>
<span class="line-added">+   while (true) {</span>
<span class="line-added">+     if (try_om_lock(om)) {</span>
<span class="line-added">+       return;</span>
<span class="line-added">+     }</span>
<span class="line-added">+   }</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ // Unlock an ObjectMonitor.</span>
<span class="line-added">+ static void om_unlock(ObjectMonitor* om) {</span>
<span class="line-added">+   ObjectMonitor* next = om-&gt;next_om();</span>
<span class="line-added">+   guarantee(((intptr_t)next &amp; OM_LOCK_BIT) == OM_LOCK_BIT, &quot;next=&quot; INTPTR_FORMAT</span>
<span class="line-added">+             &quot; must have OM_LOCK_BIT=%x set.&quot;, p2i(next), OM_LOCK_BIT);</span>
<span class="line-added">+ </span>
<span class="line-added">+   next = (ObjectMonitor*)((intptr_t)next &amp; ~OM_LOCK_BIT);  // Clear OM_LOCK_BIT.</span>
<span class="line-added">+   om-&gt;set_next_om(next);</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ // Get the list head after locking it. Returns the list head or NULL</span>
<span class="line-added">+ // if the list is empty.</span>
<span class="line-added">+ static ObjectMonitor* get_list_head_locked(ObjectMonitor** list_p) {</span>
<span class="line-added">+   while (true) {</span>
<span class="line-added">+     ObjectMonitor* mid = Atomic::load(list_p);</span>
<span class="line-added">+     if (mid == NULL) {</span>
<span class="line-added">+       return NULL;  // The list is empty.</span>
<span class="line-added">+     }</span>
<span class="line-added">+     if (try_om_lock(mid)) {</span>
<span class="line-added">+       if (Atomic::load(list_p) != mid) {</span>
<span class="line-added">+         // The list head changed before we could lock it so we have to retry.</span>
<span class="line-added">+         om_unlock(mid);</span>
<span class="line-added">+         continue;</span>
<span class="line-added">+       }</span>
<span class="line-added">+       return mid;</span>
<span class="line-added">+     }</span>
<span class="line-added">+   }</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ #undef OM_LOCK_BIT</span>
<span class="line-added">+ </span>
<span class="line-added">+ </span>
<span class="line-added">+ // =====================&gt; List Management functions</span>
<span class="line-added">+ </span>
<span class="line-added">+ // Prepend a list of ObjectMonitors to the specified *list_p. &#39;tail&#39; is</span>
<span class="line-added">+ // the last ObjectMonitor in the list and there are &#39;count&#39; on the list.</span>
<span class="line-added">+ // Also updates the specified *count_p.</span>
<span class="line-added">+ static void prepend_list_to_common(ObjectMonitor* list, ObjectMonitor* tail,</span>
<span class="line-added">+                                    int count, ObjectMonitor** list_p,</span>
<span class="line-added">+                                    int* count_p) {</span>
<span class="line-added">+   while (true) {</span>
<span class="line-added">+     ObjectMonitor* cur = Atomic::load(list_p);</span>
<span class="line-added">+     // Prepend list to *list_p.</span>
<span class="line-added">+     if (!try_om_lock(tail)) {</span>
<span class="line-added">+       // Failed to lock tail due to a list walker so try it all again.</span>
<span class="line-added">+       continue;</span>
<span class="line-added">+     }</span>
<span class="line-added">+     tail-&gt;set_next_om(cur);  // tail now points to cur (and unlocks tail)</span>
<span class="line-added">+     if (cur == NULL) {</span>
<span class="line-added">+       // No potential race with takers or other prependers since</span>
<span class="line-added">+       // *list_p is empty.</span>
<span class="line-added">+       if (Atomic::cmpxchg(list_p, cur, list) == cur) {</span>
<span class="line-added">+         // Successfully switched *list_p to the list value.</span>
<span class="line-added">+         Atomic::add(count_p, count);</span>
<span class="line-added">+         break;</span>
<span class="line-added">+       }</span>
<span class="line-added">+       // Implied else: try it all again</span>
<span class="line-added">+     } else {</span>
<span class="line-added">+       if (!try_om_lock(cur)) {</span>
<span class="line-added">+         continue;  // failed to lock cur so try it all again</span>
<span class="line-added">+       }</span>
<span class="line-added">+       // We locked cur so try to switch *list_p to the list value.</span>
<span class="line-added">+       if (Atomic::cmpxchg(list_p, cur, list) != cur) {</span>
<span class="line-added">+         // The list head has changed so unlock cur and try again:</span>
<span class="line-added">+         om_unlock(cur);</span>
<span class="line-added">+         continue;</span>
<span class="line-added">+       }</span>
<span class="line-added">+       Atomic::add(count_p, count);</span>
<span class="line-added">+       om_unlock(cur);</span>
<span class="line-added">+       break;</span>
<span class="line-added">+     }</span>
<span class="line-added">+   }</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ // Prepend a newly allocated block of ObjectMonitors to g_block_list and</span>
<span class="line-added">+ // om_list_globals._free_list. Also updates om_list_globals._population</span>
<span class="line-added">+ // and om_list_globals._free_count.</span>
<span class="line-added">+ void ObjectSynchronizer::prepend_block_to_lists(PaddedObjectMonitor* new_blk) {</span>
<span class="line-added">+   // First we handle g_block_list:</span>
<span class="line-added">+   while (true) {</span>
<span class="line-added">+     PaddedObjectMonitor* cur = Atomic::load(&amp;g_block_list);</span>
<span class="line-added">+     // Prepend new_blk to g_block_list. The first ObjectMonitor in</span>
<span class="line-added">+     // a block is reserved for use as linkage to the next block.</span>
<span class="line-added">+     new_blk[0].set_next_om(cur);</span>
<span class="line-added">+     if (Atomic::cmpxchg(&amp;g_block_list, cur, new_blk) == cur) {</span>
<span class="line-added">+       // Successfully switched g_block_list to the new_blk value.</span>
<span class="line-added">+       Atomic::add(&amp;om_list_globals._population, _BLOCKSIZE - 1);</span>
<span class="line-added">+       break;</span>
<span class="line-added">+     }</span>
<span class="line-added">+     // Implied else: try it all again</span>
<span class="line-added">+   }</span>
<span class="line-added">+ </span>
<span class="line-added">+   // Second we handle om_list_globals._free_list:</span>
<span class="line-added">+   prepend_list_to_common(new_blk + 1, &amp;new_blk[_BLOCKSIZE - 1], _BLOCKSIZE - 1,</span>
<span class="line-added">+                          &amp;om_list_globals._free_list, &amp;om_list_globals._free_count);</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ // Prepend a list of ObjectMonitors to om_list_globals._free_list.</span>
<span class="line-added">+ // &#39;tail&#39; is the last ObjectMonitor in the list and there are &#39;count&#39;</span>
<span class="line-added">+ // on the list. Also updates om_list_globals._free_count.</span>
<span class="line-added">+ static void prepend_list_to_global_free_list(ObjectMonitor* list,</span>
<span class="line-added">+                                              ObjectMonitor* tail, int count) {</span>
<span class="line-added">+   prepend_list_to_common(list, tail, count, &amp;om_list_globals._free_list,</span>
<span class="line-added">+                          &amp;om_list_globals._free_count);</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ // Prepend a list of ObjectMonitors to om_list_globals._in_use_list.</span>
<span class="line-added">+ // &#39;tail&#39; is the last ObjectMonitor in the list and there are &#39;count&#39;</span>
<span class="line-added">+ // on the list. Also updates om_list_globals._in_use_list.</span>
<span class="line-added">+ static void prepend_list_to_global_in_use_list(ObjectMonitor* list,</span>
<span class="line-added">+                                                ObjectMonitor* tail, int count) {</span>
<span class="line-added">+   prepend_list_to_common(list, tail, count, &amp;om_list_globals._in_use_list,</span>
<span class="line-added">+                          &amp;om_list_globals._in_use_count);</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ // Prepend an ObjectMonitor to the specified list. Also updates</span>
<span class="line-added">+ // the specified counter.</span>
<span class="line-added">+ static void prepend_to_common(ObjectMonitor* m, ObjectMonitor** list_p,</span>
<span class="line-added">+                               int* count_p) {</span>
<span class="line-added">+   while (true) {</span>
<span class="line-added">+     om_lock(m);  // Lock m so we can safely update its next field.</span>
<span class="line-added">+     ObjectMonitor* cur = NULL;</span>
<span class="line-added">+     // Lock the list head to guard against races with a list walker</span>
<span class="line-added">+     // thread:</span>
<span class="line-added">+     if ((cur = get_list_head_locked(list_p)) != NULL) {</span>
<span class="line-added">+       // List head is now locked so we can safely switch it.</span>
<span class="line-added">+       m-&gt;set_next_om(cur);  // m now points to cur (and unlocks m)</span>
<span class="line-added">+       Atomic::store(list_p, m);  // Switch list head to unlocked m.</span>
<span class="line-added">+       om_unlock(cur);</span>
<span class="line-added">+       break;</span>
<span class="line-added">+     }</span>
<span class="line-added">+     // The list is empty so try to set the list head.</span>
<span class="line-added">+     assert(cur == NULL, &quot;cur must be NULL: cur=&quot; INTPTR_FORMAT, p2i(cur));</span>
<span class="line-added">+     m-&gt;set_next_om(cur);  // m now points to NULL (and unlocks m)</span>
<span class="line-added">+     if (Atomic::cmpxchg(list_p, cur, m) == cur) {</span>
<span class="line-added">+       // List head is now unlocked m.</span>
<span class="line-added">+       break;</span>
<span class="line-added">+     }</span>
<span class="line-added">+     // Implied else: try it all again</span>
<span class="line-added">+   }</span>
<span class="line-added">+   Atomic::inc(count_p);</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ // Prepend an ObjectMonitor to a per-thread om_free_list.</span>
<span class="line-added">+ // Also updates the per-thread om_free_count.</span>
<span class="line-added">+ static void prepend_to_om_free_list(Thread* self, ObjectMonitor* m) {</span>
<span class="line-added">+   prepend_to_common(m, &amp;self-&gt;om_free_list, &amp;self-&gt;om_free_count);</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ // Prepend an ObjectMonitor to a per-thread om_in_use_list.</span>
<span class="line-added">+ // Also updates the per-thread om_in_use_count.</span>
<span class="line-added">+ static void prepend_to_om_in_use_list(Thread* self, ObjectMonitor* m) {</span>
<span class="line-added">+   prepend_to_common(m, &amp;self-&gt;om_in_use_list, &amp;self-&gt;om_in_use_count);</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ // Take an ObjectMonitor from the start of the specified list. Also</span>
<span class="line-added">+ // decrements the specified counter. Returns NULL if none are available.</span>
<span class="line-added">+ static ObjectMonitor* take_from_start_of_common(ObjectMonitor** list_p,</span>
<span class="line-added">+                                                 int* count_p) {</span>
<span class="line-added">+   ObjectMonitor* take = NULL;</span>
<span class="line-added">+   // Lock the list head to guard against races with a list walker</span>
<span class="line-added">+   // thread:</span>
<span class="line-added">+   if ((take = get_list_head_locked(list_p)) == NULL) {</span>
<span class="line-added">+     return NULL;  // None are available.</span>
<span class="line-added">+   }</span>
<span class="line-added">+   ObjectMonitor* next = unmarked_next(take);</span>
<span class="line-added">+   // Switch locked list head to next (which unlocks the list head, but</span>
<span class="line-added">+   // leaves take locked):</span>
<span class="line-added">+   Atomic::store(list_p, next);</span>
<span class="line-added">+   Atomic::dec(count_p);</span>
<span class="line-added">+   // Unlock take, but leave the next value for any lagging list</span>
<span class="line-added">+   // walkers. It will get cleaned up when take is prepended to</span>
<span class="line-added">+   // the in-use list:</span>
<span class="line-added">+   om_unlock(take);</span>
<span class="line-added">+   return take;</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ // Take an ObjectMonitor from the start of the om_list_globals._free_list.</span>
<span class="line-added">+ // Also updates om_list_globals._free_count. Returns NULL if none are</span>
<span class="line-added">+ // available.</span>
<span class="line-added">+ static ObjectMonitor* take_from_start_of_global_free_list() {</span>
<span class="line-added">+   return take_from_start_of_common(&amp;om_list_globals._free_list,</span>
<span class="line-added">+                                    &amp;om_list_globals._free_count);</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ // Take an ObjectMonitor from the start of a per-thread free-list.</span>
<span class="line-added">+ // Also updates om_free_count. Returns NULL if none are available.</span>
<span class="line-added">+ static ObjectMonitor* take_from_start_of_om_free_list(Thread* self) {</span>
<span class="line-added">+   return take_from_start_of_common(&amp;self-&gt;om_free_list, &amp;self-&gt;om_free_count);</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ </span>
  // =====================&gt; Quick functions
  
  // The quick_* forms are special fast-path variants used to improve
  // performance.  In the simplest case, a &quot;quick_*&quot; implementation could
  // simply return false, in which case the caller will perform the necessary
</pre>
<hr />
<pre>
<span class="line-old-header">*** 152,27 ***</span>
  //   synchronized (someobj) { .... ; notify(); }
  // That is, we find a notify() or notifyAll() call that immediately precedes
  // the monitorexit operation.  In that case the JIT could fuse the operations
  // into a single notifyAndExit() runtime primitive.
  
<span class="line-modified">! bool ObjectSynchronizer::quick_notify(oopDesc * obj, Thread * self, bool all) {</span>
    assert(!SafepointSynchronize::is_at_safepoint(), &quot;invariant&quot;);
    assert(self-&gt;is_Java_thread(), &quot;invariant&quot;);
    assert(((JavaThread *) self)-&gt;thread_state() == _thread_in_Java, &quot;invariant&quot;);
    NoSafepointVerifier nsv;
    if (obj == NULL) return false;  // slow-path for invalid obj
<span class="line-modified">!   const markOop mark = obj-&gt;mark();</span>
  
<span class="line-modified">!   if (mark-&gt;has_locker() &amp;&amp; self-&gt;is_lock_owned((address)mark-&gt;locker())) {</span>
      // Degenerate notify
      // stack-locked by caller so by definition the implied waitset is empty.
      return true;
    }
  
<span class="line-modified">!   if (mark-&gt;has_monitor()) {</span>
<span class="line-modified">!     ObjectMonitor * const mon = mark-&gt;monitor();</span>
<span class="line-modified">!     assert(oopDesc::equals((oop) mon-&gt;object(), obj), &quot;invariant&quot;);</span>
      if (mon-&gt;owner() != self) return false;  // slow-path for IMS exception
  
      if (mon-&gt;first_waiter() != NULL) {
        // We have one or more waiters. Since this is an inflated monitor
        // that we own, we can transfer one or more threads from the waitset
<span class="line-new-header">--- 405,27 ---</span>
  //   synchronized (someobj) { .... ; notify(); }
  // That is, we find a notify() or notifyAll() call that immediately precedes
  // the monitorexit operation.  In that case the JIT could fuse the operations
  // into a single notifyAndExit() runtime primitive.
  
<span class="line-modified">! bool ObjectSynchronizer::quick_notify(oopDesc* obj, Thread* self, bool all) {</span>
    assert(!SafepointSynchronize::is_at_safepoint(), &quot;invariant&quot;);
    assert(self-&gt;is_Java_thread(), &quot;invariant&quot;);
    assert(((JavaThread *) self)-&gt;thread_state() == _thread_in_Java, &quot;invariant&quot;);
    NoSafepointVerifier nsv;
    if (obj == NULL) return false;  // slow-path for invalid obj
<span class="line-modified">!   const markWord mark = obj-&gt;mark();</span>
  
<span class="line-modified">!   if (mark.has_locker() &amp;&amp; self-&gt;is_lock_owned((address)mark.locker())) {</span>
      // Degenerate notify
      // stack-locked by caller so by definition the implied waitset is empty.
      return true;
    }
  
<span class="line-modified">!   if (mark.has_monitor()) {</span>
<span class="line-modified">!     ObjectMonitor* const mon = mark.monitor();</span>
<span class="line-modified">!     assert(mon-&gt;object() == obj, &quot;invariant&quot;);</span>
      if (mon-&gt;owner() != self) return false;  // slow-path for IMS exception
  
      if (mon-&gt;first_waiter() != NULL) {
        // We have one or more waiters. Since this is an inflated monitor
        // that we own, we can transfer one or more threads from the waitset
</pre>
<hr />
<pre>
<span class="line-old-header">*** 180,16 ***</span>
        if (all) {
          DTRACE_MONITOR_PROBE(notifyAll, mon, obj, self);
        } else {
          DTRACE_MONITOR_PROBE(notify, mon, obj, self);
        }
<span class="line-modified">!       int tally = 0;</span>
        do {
          mon-&gt;INotify(self);
<span class="line-modified">!         ++tally;</span>
        } while (mon-&gt;first_waiter() != NULL &amp;&amp; all);
<span class="line-modified">!       OM_PERFDATA_OP(Notifications, inc(tally));</span>
      }
      return true;
    }
  
    // biased locking and any other IMS exception states take the slow-path
<span class="line-new-header">--- 433,16 ---</span>
        if (all) {
          DTRACE_MONITOR_PROBE(notifyAll, mon, obj, self);
        } else {
          DTRACE_MONITOR_PROBE(notify, mon, obj, self);
        }
<span class="line-modified">!       int free_count = 0;</span>
        do {
          mon-&gt;INotify(self);
<span class="line-modified">!         ++free_count;</span>
        } while (mon-&gt;first_waiter() != NULL &amp;&amp; all);
<span class="line-modified">!       OM_PERFDATA_OP(Notifications, inc(free_count));</span>
      }
      return true;
    }
  
    // biased locking and any other IMS exception states take the slow-path
</pre>
<hr />
<pre>
<span class="line-old-header">*** 201,30 ***</span>
  // been too big if it were to have included support for the cases of inflated
  // recursive enter and exit, so they go here instead.
  // Note that we can&#39;t safely call AsyncPrintJavaStack() from within
  // quick_enter() as our thread state remains _in_Java.
  
<span class="line-modified">! bool ObjectSynchronizer::quick_enter(oop obj, Thread * Self,</span>
                                       BasicLock * lock) {
    assert(!SafepointSynchronize::is_at_safepoint(), &quot;invariant&quot;);
<span class="line-modified">!   assert(Self-&gt;is_Java_thread(), &quot;invariant&quot;);</span>
<span class="line-modified">!   assert(((JavaThread *) Self)-&gt;thread_state() == _thread_in_Java, &quot;invariant&quot;);</span>
    NoSafepointVerifier nsv;
    if (obj == NULL) return false;       // Need to throw NPE
<span class="line-modified">!   const markOop mark = obj-&gt;mark();</span>
  
<span class="line-modified">!   if (mark-&gt;has_monitor()) {</span>
<span class="line-modified">!     ObjectMonitor * const m = mark-&gt;monitor();</span>
<span class="line-modified">!     assert(oopDesc::equals((oop) m-&gt;object(), obj), &quot;invariant&quot;);</span>
<span class="line-modified">!     Thread * const owner = (Thread *) m-&gt;_owner;</span>
  
      // Lock contention and Transactional Lock Elision (TLE) diagnostics
      // and observability
      // Case: light contention possibly amenable to TLE
      // Case: TLE inimical operations such as nested/recursive synchronization
  
<span class="line-modified">!     if (owner == Self) {</span>
        m-&gt;_recursions++;
        return true;
      }
  
      // This Java Monitor is inflated so obj&#39;s header will never be
<span class="line-new-header">--- 454,30 ---</span>
  // been too big if it were to have included support for the cases of inflated
  // recursive enter and exit, so they go here instead.
  // Note that we can&#39;t safely call AsyncPrintJavaStack() from within
  // quick_enter() as our thread state remains _in_Java.
  
<span class="line-modified">! bool ObjectSynchronizer::quick_enter(oop obj, Thread* self,</span>
                                       BasicLock * lock) {
    assert(!SafepointSynchronize::is_at_safepoint(), &quot;invariant&quot;);
<span class="line-modified">!   assert(self-&gt;is_Java_thread(), &quot;invariant&quot;);</span>
<span class="line-modified">!   assert(((JavaThread *) self)-&gt;thread_state() == _thread_in_Java, &quot;invariant&quot;);</span>
    NoSafepointVerifier nsv;
    if (obj == NULL) return false;       // Need to throw NPE
<span class="line-modified">!   const markWord mark = obj-&gt;mark();</span>
  
<span class="line-modified">!   if (mark.has_monitor()) {</span>
<span class="line-modified">!     ObjectMonitor* const m = mark.monitor();</span>
<span class="line-modified">!     assert(m-&gt;object() == obj, &quot;invariant&quot;);</span>
<span class="line-modified">!     Thread* const owner = (Thread *) m-&gt;_owner;</span>
  
      // Lock contention and Transactional Lock Elision (TLE) diagnostics
      // and observability
      // Case: light contention possibly amenable to TLE
      // Case: TLE inimical operations such as nested/recursive synchronization
  
<span class="line-modified">!     if (owner == self) {</span>
        m-&gt;_recursions++;
        return true;
      }
  
      // This Java Monitor is inflated so obj&#39;s header will never be
</pre>
<hr />
<pre>
<span class="line-old-header">*** 235,15 ***</span>
      // performance reasons, stack walkers generally first check for
      // Biased Locking in the object&#39;s header, the second check is for
      // stack-locking in the object&#39;s header, the third check is for
      // recursive stack-locking in the displaced header in the BasicLock,
      // and last are the inflated Java Monitor (ObjectMonitor) checks.
<span class="line-modified">!     lock-&gt;set_displaced_header(markOopDesc::unused_mark());</span>
  
<span class="line-modified">!     if (owner == NULL &amp;&amp; Atomic::replace_if_null(Self, &amp;(m-&gt;_owner))) {</span>
        assert(m-&gt;_recursions == 0, &quot;invariant&quot;);
<span class="line-removed">-       assert(m-&gt;_owner == Self, &quot;invariant&quot;);</span>
        return true;
      }
    }
  
    // Note that we could inflate in quick_enter.
<span class="line-new-header">--- 488,14 ---</span>
      // performance reasons, stack walkers generally first check for
      // Biased Locking in the object&#39;s header, the second check is for
      // stack-locking in the object&#39;s header, the third check is for
      // recursive stack-locking in the displaced header in the BasicLock,
      // and last are the inflated Java Monitor (ObjectMonitor) checks.
<span class="line-modified">!     lock-&gt;set_displaced_header(markWord::unused_mark());</span>
  
<span class="line-modified">!     if (owner == NULL &amp;&amp; m-&gt;try_set_owner_from(NULL, self) == NULL) {</span>
        assert(m-&gt;_recursions == 0, &quot;invariant&quot;);
        return true;
      }
    }
  
    // Note that we could inflate in quick_enter.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 255,124 ***</span>
  
    return false;        // revert to slow-path
  }
  
  // -----------------------------------------------------------------------------
<span class="line-modified">! //  Fast Monitor Enter/Exit</span>
<span class="line-modified">! // This the fast monitor enter. The interpreter and compiler use</span>
<span class="line-modified">! // some assembly copies of this code. Make sure update those code</span>
<span class="line-modified">! // if the following function is changed. The implementation is</span>
<span class="line-modified">! // extremely sensitive to race condition. Be careful.</span>
<span class="line-modified">! </span>
<span class="line-removed">- void ObjectSynchronizer::fast_enter(Handle obj, BasicLock* lock,</span>
<span class="line-removed">-                                     bool attempt_rebias, TRAPS) {</span>
    if (UseBiasedLocking) {
      if (!SafepointSynchronize::is_at_safepoint()) {
<span class="line-modified">!       BiasedLocking::Condition cond = BiasedLocking::revoke_and_rebias(obj, attempt_rebias, THREAD);</span>
<span class="line-removed">-       if (cond == BiasedLocking::BIAS_REVOKED_AND_REBIASED) {</span>
<span class="line-removed">-         return;</span>
<span class="line-removed">-       }</span>
      } else {
<span class="line-removed">-       assert(!attempt_rebias, &quot;can not rebias toward VM thread&quot;);</span>
        BiasedLocking::revoke_at_safepoint(obj);
      }
<span class="line-removed">-     assert(!obj-&gt;mark()-&gt;has_bias_pattern(), &quot;biases should be revoked by now&quot;);</span>
    }
  
<span class="line-modified">!   slow_enter(obj, lock, THREAD);</span>
  }
  
<span class="line-modified">! void ObjectSynchronizer::fast_exit(oop object, BasicLock* lock, TRAPS) {</span>
<span class="line-modified">!   markOop mark = object-&gt;mark();</span>
    // We cannot check for Biased Locking if we are racing an inflation.
<span class="line-modified">!   assert(mark == markOopDesc::INFLATING() ||</span>
<span class="line-modified">!          !mark-&gt;has_bias_pattern(), &quot;should not see bias pattern here&quot;);</span>
  
<span class="line-modified">!   markOop dhw = lock-&gt;displaced_header();</span>
<span class="line-modified">!   if (dhw == NULL) {</span>
      // If the displaced header is NULL, then this exit matches up with
      // a recursive enter. No real work to do here except for diagnostics.
  #ifndef PRODUCT
<span class="line-modified">!     if (mark != markOopDesc::INFLATING()) {</span>
        // Only do diagnostics if we are not racing an inflation. Simply
        // exiting a recursive enter of a Java Monitor that is being
        // inflated is safe; see the has_monitor() comment below.
<span class="line-modified">!       assert(!mark-&gt;is_neutral(), &quot;invariant&quot;);</span>
<span class="line-modified">!       assert(!mark-&gt;has_locker() ||</span>
<span class="line-modified">!              THREAD-&gt;is_lock_owned((address)mark-&gt;locker()), &quot;invariant&quot;);</span>
<span class="line-modified">!       if (mark-&gt;has_monitor()) {</span>
          // The BasicLock&#39;s displaced_header is marked as a recursive
          // enter and we have an inflated Java Monitor (ObjectMonitor).
          // This is a special case where the Java Monitor was inflated
          // after this thread entered the stack-lock recursively. When a
          // Java Monitor is inflated, we cannot safely walk the Java
          // Monitor owner&#39;s stack and update the BasicLocks because a
          // Java Monitor can be asynchronously inflated by a thread that
          // does not own the Java Monitor.
<span class="line-modified">!         ObjectMonitor * m = mark-&gt;monitor();</span>
          assert(((oop)(m-&gt;object()))-&gt;mark() == mark, &quot;invariant&quot;);
          assert(m-&gt;is_entered(THREAD), &quot;invariant&quot;);
        }
      }
  #endif
      return;
    }
  
<span class="line-modified">!   if (mark == (markOop) lock) {</span>
      // If the object is stack-locked by the current thread, try to
      // swing the displaced header from the BasicLock back to the mark.
<span class="line-modified">!     assert(dhw-&gt;is_neutral(), &quot;invariant&quot;);</span>
      if (object-&gt;cas_set_mark(dhw, mark) == mark) {
        return;
      }
    }
  
    // We have to take the slow-path of possible inflation and then exit.
    inflate(THREAD, object, inflate_cause_vm_internal)-&gt;exit(true, THREAD);
  }
  
<span class="line-removed">- // -----------------------------------------------------------------------------</span>
<span class="line-removed">- // Interpreter/Compiler Slow Case</span>
<span class="line-removed">- // This routine is used to handle interpreter/compiler slow case</span>
<span class="line-removed">- // We don&#39;t need to use fast path here, because it must have been</span>
<span class="line-removed">- // failed in the interpreter/compiler code.</span>
<span class="line-removed">- void ObjectSynchronizer::slow_enter(Handle obj, BasicLock* lock, TRAPS) {</span>
<span class="line-removed">-   markOop mark = obj-&gt;mark();</span>
<span class="line-removed">-   assert(!mark-&gt;has_bias_pattern(), &quot;should not see bias pattern here&quot;);</span>
<span class="line-removed">- </span>
<span class="line-removed">-   if (mark-&gt;is_neutral()) {</span>
<span class="line-removed">-     // Anticipate successful CAS -- the ST of the displaced mark must</span>
<span class="line-removed">-     // be visible &lt;= the ST performed by the CAS.</span>
<span class="line-removed">-     lock-&gt;set_displaced_header(mark);</span>
<span class="line-removed">-     if (mark == obj()-&gt;cas_set_mark((markOop) lock, mark)) {</span>
<span class="line-removed">-       return;</span>
<span class="line-removed">-     }</span>
<span class="line-removed">-     // Fall through to inflate() ...</span>
<span class="line-removed">-   } else if (mark-&gt;has_locker() &amp;&amp;</span>
<span class="line-removed">-              THREAD-&gt;is_lock_owned((address)mark-&gt;locker())) {</span>
<span class="line-removed">-     assert(lock != mark-&gt;locker(), &quot;must not re-lock the same lock&quot;);</span>
<span class="line-removed">-     assert(lock != (BasicLock*)obj-&gt;mark(), &quot;don&#39;t relock with same BasicLock&quot;);</span>
<span class="line-removed">-     lock-&gt;set_displaced_header(NULL);</span>
<span class="line-removed">-     return;</span>
<span class="line-removed">-   }</span>
<span class="line-removed">- </span>
<span class="line-removed">-   // The object header will never be displaced to this lock,</span>
<span class="line-removed">-   // so it does not matter what the value is, except that it</span>
<span class="line-removed">-   // must be non-zero to avoid looking like a re-entrant lock,</span>
<span class="line-removed">-   // and must not look locked either.</span>
<span class="line-removed">-   lock-&gt;set_displaced_header(markOopDesc::unused_mark());</span>
<span class="line-removed">-   inflate(THREAD, obj(), inflate_cause_monitor_enter)-&gt;enter(THREAD);</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- // This routine is used to handle interpreter/compiler slow case</span>
<span class="line-removed">- // We don&#39;t need to use fast path here, because it must have</span>
<span class="line-removed">- // failed in the interpreter/compiler code. Simply use the heavy</span>
<span class="line-removed">- // weight monitor should be ok, unless someone find otherwise.</span>
<span class="line-removed">- void ObjectSynchronizer::slow_exit(oop object, BasicLock* lock, TRAPS) {</span>
<span class="line-removed">-   fast_exit(object, lock, THREAD);</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
  // -----------------------------------------------------------------------------
  // Class Loader  support to workaround deadlocks on the class loader lock objects
  // Also used by GC
  // complete_exit()/reenter() are used to wait on a nested lock
  // i.e. to give up an outer lock completely and then re-enter
<span class="line-new-header">--- 507,100 ---</span>
  
    return false;        // revert to slow-path
  }
  
  // -----------------------------------------------------------------------------
<span class="line-modified">! // Monitor Enter/Exit</span>
<span class="line-modified">! // The interpreter and compiler assembly code tries to lock using the fast path</span>
<span class="line-modified">! // of this algorithm. Make sure to update that code if the following function is</span>
<span class="line-modified">! // changed. The implementation is extremely sensitive to race condition. Be careful.</span>
<span class="line-modified">! </span>
<span class="line-modified">! void ObjectSynchronizer::enter(Handle obj, BasicLock* lock, TRAPS) {</span>
    if (UseBiasedLocking) {
      if (!SafepointSynchronize::is_at_safepoint()) {
<span class="line-modified">!       BiasedLocking::revoke(obj, THREAD);</span>
      } else {
        BiasedLocking::revoke_at_safepoint(obj);
      }
    }
  
<span class="line-modified">!   markWord mark = obj-&gt;mark();</span>
<span class="line-added">+   assert(!mark.has_bias_pattern(), &quot;should not see bias pattern here&quot;);</span>
<span class="line-added">+ </span>
<span class="line-added">+   if (mark.is_neutral()) {</span>
<span class="line-added">+     // Anticipate successful CAS -- the ST of the displaced mark must</span>
<span class="line-added">+     // be visible &lt;= the ST performed by the CAS.</span>
<span class="line-added">+     lock-&gt;set_displaced_header(mark);</span>
<span class="line-added">+     if (mark == obj()-&gt;cas_set_mark(markWord::from_pointer(lock), mark)) {</span>
<span class="line-added">+       return;</span>
<span class="line-added">+     }</span>
<span class="line-added">+     // Fall through to inflate() ...</span>
<span class="line-added">+   } else if (mark.has_locker() &amp;&amp;</span>
<span class="line-added">+              THREAD-&gt;is_lock_owned((address)mark.locker())) {</span>
<span class="line-added">+     assert(lock != mark.locker(), &quot;must not re-lock the same lock&quot;);</span>
<span class="line-added">+     assert(lock != (BasicLock*)obj-&gt;mark().value(), &quot;don&#39;t relock with same BasicLock&quot;);</span>
<span class="line-added">+     lock-&gt;set_displaced_header(markWord::from_pointer(NULL));</span>
<span class="line-added">+     return;</span>
<span class="line-added">+   }</span>
<span class="line-added">+ </span>
<span class="line-added">+   // The object header will never be displaced to this lock,</span>
<span class="line-added">+   // so it does not matter what the value is, except that it</span>
<span class="line-added">+   // must be non-zero to avoid looking like a re-entrant lock,</span>
<span class="line-added">+   // and must not look locked either.</span>
<span class="line-added">+   lock-&gt;set_displaced_header(markWord::unused_mark());</span>
<span class="line-added">+   inflate(THREAD, obj(), inflate_cause_monitor_enter)-&gt;enter(THREAD);</span>
  }
  
<span class="line-modified">! void ObjectSynchronizer::exit(oop object, BasicLock* lock, TRAPS) {</span>
<span class="line-modified">!   markWord mark = object-&gt;mark();</span>
    // We cannot check for Biased Locking if we are racing an inflation.
<span class="line-modified">!   assert(mark == markWord::INFLATING() ||</span>
<span class="line-modified">!          !mark.has_bias_pattern(), &quot;should not see bias pattern here&quot;);</span>
  
<span class="line-modified">!   markWord dhw = lock-&gt;displaced_header();</span>
<span class="line-modified">!   if (dhw.value() == 0) {</span>
      // If the displaced header is NULL, then this exit matches up with
      // a recursive enter. No real work to do here except for diagnostics.
  #ifndef PRODUCT
<span class="line-modified">!     if (mark != markWord::INFLATING()) {</span>
        // Only do diagnostics if we are not racing an inflation. Simply
        // exiting a recursive enter of a Java Monitor that is being
        // inflated is safe; see the has_monitor() comment below.
<span class="line-modified">!       assert(!mark.is_neutral(), &quot;invariant&quot;);</span>
<span class="line-modified">!       assert(!mark.has_locker() ||</span>
<span class="line-modified">!              THREAD-&gt;is_lock_owned((address)mark.locker()), &quot;invariant&quot;);</span>
<span class="line-modified">!       if (mark.has_monitor()) {</span>
          // The BasicLock&#39;s displaced_header is marked as a recursive
          // enter and we have an inflated Java Monitor (ObjectMonitor).
          // This is a special case where the Java Monitor was inflated
          // after this thread entered the stack-lock recursively. When a
          // Java Monitor is inflated, we cannot safely walk the Java
          // Monitor owner&#39;s stack and update the BasicLocks because a
          // Java Monitor can be asynchronously inflated by a thread that
          // does not own the Java Monitor.
<span class="line-modified">!         ObjectMonitor* m = mark.monitor();</span>
          assert(((oop)(m-&gt;object()))-&gt;mark() == mark, &quot;invariant&quot;);
          assert(m-&gt;is_entered(THREAD), &quot;invariant&quot;);
        }
      }
  #endif
      return;
    }
  
<span class="line-modified">!   if (mark == markWord::from_pointer(lock)) {</span>
      // If the object is stack-locked by the current thread, try to
      // swing the displaced header from the BasicLock back to the mark.
<span class="line-modified">!     assert(dhw.is_neutral(), &quot;invariant&quot;);</span>
      if (object-&gt;cas_set_mark(dhw, mark) == mark) {
        return;
      }
    }
  
    // We have to take the slow-path of possible inflation and then exit.
    inflate(THREAD, object, inflate_cause_vm_internal)-&gt;exit(true, THREAD);
  }
  
  // -----------------------------------------------------------------------------
  // Class Loader  support to workaround deadlocks on the class loader lock objects
  // Also used by GC
  // complete_exit()/reenter() are used to wait on a nested lock
  // i.e. to give up an outer lock completely and then re-enter
</pre>
<hr />
<pre>
<span class="line-old-header">*** 389,40 ***</span>
  //             the absolute recursion count tracked by Tsan, and (2) in the
  //             general case, we cannot merely store Tsan&#39;s recursion count
  //             once: we must track it for *each invocation* of complete_exit.
  //             Hence, the best place to instrument for Tsan is at the call site
  //             for complete_exit/reenter. Luckily, there is only one call site.
<span class="line-modified">! intptr_t ObjectSynchronizer::complete_exit(Handle obj, TRAPS) {</span>
    if (UseBiasedLocking) {
<span class="line-modified">!     BiasedLocking::revoke_and_rebias(obj, false, THREAD);</span>
<span class="line-modified">!     assert(!obj-&gt;mark()-&gt;has_bias_pattern(), &quot;biases should be revoked by now&quot;);</span>
    }
  
    ObjectMonitor* monitor = inflate(THREAD, obj(), inflate_cause_vm_internal);
  
    return monitor-&gt;complete_exit(THREAD);
  }
  
  // NOTE: must use heavy weight monitor to handle complete_exit/reenter()
<span class="line-modified">! void ObjectSynchronizer::reenter(Handle obj, intptr_t recursion, TRAPS) {</span>
    if (UseBiasedLocking) {
<span class="line-modified">!     BiasedLocking::revoke_and_rebias(obj, false, THREAD);</span>
<span class="line-modified">!     assert(!obj-&gt;mark()-&gt;has_bias_pattern(), &quot;biases should be revoked by now&quot;);</span>
    }
  
    ObjectMonitor* monitor = inflate(THREAD, obj(), inflate_cause_vm_internal);
  
<span class="line-modified">!   monitor-&gt;reenter(recursion, THREAD);</span>
  }
  // -----------------------------------------------------------------------------
  // JNI locks on java objects
  // NOTE: must use heavy weight monitor to handle jni monitor enter
  void ObjectSynchronizer::jni_enter(Handle obj, TRAPS) {
    // the current locking is from JNI instead of Java code
    if (UseBiasedLocking) {
<span class="line-modified">!     BiasedLocking::revoke_and_rebias(obj, false, THREAD);</span>
<span class="line-modified">!     assert(!obj-&gt;mark()-&gt;has_bias_pattern(), &quot;biases should be revoked by now&quot;);</span>
    }
    THREAD-&gt;set_current_pending_monitor_is_from_java(false);
    inflate(THREAD, obj(), inflate_cause_jni_enter)-&gt;enter(THREAD);
    THREAD-&gt;set_current_pending_monitor_is_from_java(true);
    TSAN_RUNTIME_ONLY(SharedRuntime::tsan_oop_lock(THREAD, obj()));
<span class="line-new-header">--- 617,40 ---</span>
  //             the absolute recursion count tracked by Tsan, and (2) in the
  //             general case, we cannot merely store Tsan&#39;s recursion count
  //             once: we must track it for *each invocation* of complete_exit.
  //             Hence, the best place to instrument for Tsan is at the call site
  //             for complete_exit/reenter. Luckily, there is only one call site.
<span class="line-modified">! intx ObjectSynchronizer::complete_exit(Handle obj, TRAPS) {</span>
    if (UseBiasedLocking) {
<span class="line-modified">!     BiasedLocking::revoke(obj, THREAD);</span>
<span class="line-modified">!     assert(!obj-&gt;mark().has_bias_pattern(), &quot;biases should be revoked by now&quot;);</span>
    }
  
    ObjectMonitor* monitor = inflate(THREAD, obj(), inflate_cause_vm_internal);
  
    return monitor-&gt;complete_exit(THREAD);
  }
  
  // NOTE: must use heavy weight monitor to handle complete_exit/reenter()
<span class="line-modified">! void ObjectSynchronizer::reenter(Handle obj, intx recursions, TRAPS) {</span>
    if (UseBiasedLocking) {
<span class="line-modified">!     BiasedLocking::revoke(obj, THREAD);</span>
<span class="line-modified">!     assert(!obj-&gt;mark().has_bias_pattern(), &quot;biases should be revoked by now&quot;);</span>
    }
  
    ObjectMonitor* monitor = inflate(THREAD, obj(), inflate_cause_vm_internal);
  
<span class="line-modified">!   monitor-&gt;reenter(recursions, THREAD);</span>
  }
  // -----------------------------------------------------------------------------
  // JNI locks on java objects
  // NOTE: must use heavy weight monitor to handle jni monitor enter
  void ObjectSynchronizer::jni_enter(Handle obj, TRAPS) {
    // the current locking is from JNI instead of Java code
    if (UseBiasedLocking) {
<span class="line-modified">!     BiasedLocking::revoke(obj, THREAD);</span>
<span class="line-modified">!     assert(!obj-&gt;mark().has_bias_pattern(), &quot;biases should be revoked by now&quot;);</span>
    }
    THREAD-&gt;set_current_pending_monitor_is_from_java(false);
    inflate(THREAD, obj(), inflate_cause_jni_enter)-&gt;enter(THREAD);
    THREAD-&gt;set_current_pending_monitor_is_from_java(true);
    TSAN_RUNTIME_ONLY(SharedRuntime::tsan_oop_lock(THREAD, obj()));
</pre>
<hr />
<pre>
<span class="line-old-header">*** 430,54 ***</span>
  
  // NOTE: must use heavy weight monitor to handle jni monitor exit
  void ObjectSynchronizer::jni_exit(oop obj, Thread* THREAD) {
    if (UseBiasedLocking) {
      Handle h_obj(THREAD, obj);
<span class="line-modified">!     BiasedLocking::revoke_and_rebias(h_obj, false, THREAD);</span>
      obj = h_obj();
    }
<span class="line-modified">!   assert(!obj-&gt;mark()-&gt;has_bias_pattern(), &quot;biases should be revoked by now&quot;);</span>
  
    ObjectMonitor* monitor = inflate(THREAD, obj, inflate_cause_jni_exit);
<span class="line-modified">!   // If this thread has locked the object, exit the monitor.  Note:  can&#39;t use</span>
<span class="line-modified">!   // monitor-&gt;check(CHECK); must exit even if an exception is pending.</span>
<span class="line-modified">!   if (monitor-&gt;check(THREAD)) {</span>
      TSAN_RUNTIME_ONLY(SharedRuntime::tsan_oop_unlock(THREAD, obj));
      monitor-&gt;exit(true, THREAD);
    }
  }
  
  // -----------------------------------------------------------------------------
  // Internal VM locks on java objects
  // standard constructor, allows locking failures
<span class="line-modified">! ObjectLocker::ObjectLocker(Handle obj, Thread* thread, bool doLock) {</span>
<span class="line-modified">!   _dolock = doLock;</span>
    _thread = thread;
<span class="line-modified">!   debug_only(if (StrictSafepointChecks) _thread-&gt;check_for_valid_safepoint_state(false);)</span>
    _obj = obj;
  
    if (_dolock) {
<span class="line-modified">!     ObjectSynchronizer::fast_enter(_obj, &amp;_lock, false, _thread);</span>
      TSAN_RUNTIME_ONLY(SharedRuntime::tsan_oop_lock(_thread, _obj()));
    }
  }
  
  ObjectLocker::~ObjectLocker() {
    if (_dolock) {
      TSAN_RUNTIME_ONLY(SharedRuntime::tsan_oop_unlock(_thread, _obj()));
<span class="line-modified">!     ObjectSynchronizer::fast_exit(_obj(), &amp;_lock, _thread);</span>
    }
  }
  
  
  // -----------------------------------------------------------------------------
  //  Wait/Notify/NotifyAll
  // NOTE: must use heavy weight monitor to handle wait()
  int ObjectSynchronizer::wait(Handle obj, jlong millis, TRAPS) {
    if (UseBiasedLocking) {
<span class="line-modified">!     BiasedLocking::revoke_and_rebias(obj, false, THREAD);</span>
<span class="line-modified">!     assert(!obj-&gt;mark()-&gt;has_bias_pattern(), &quot;biases should be revoked by now&quot;);</span>
    }
    if (millis &lt; 0) {
      THROW_MSG_0(vmSymbols::java_lang_IllegalArgumentException(), &quot;timeout value is negative&quot;);
    }
    ObjectMonitor* monitor = inflate(THREAD, obj(), inflate_cause_wait);
<span class="line-new-header">--- 658,55 ---</span>
  
  // NOTE: must use heavy weight monitor to handle jni monitor exit
  void ObjectSynchronizer::jni_exit(oop obj, Thread* THREAD) {
    if (UseBiasedLocking) {
      Handle h_obj(THREAD, obj);
<span class="line-modified">!     BiasedLocking::revoke(h_obj, THREAD);</span>
      obj = h_obj();
    }
<span class="line-modified">!   assert(!obj-&gt;mark().has_bias_pattern(), &quot;biases should be revoked by now&quot;);</span>
  
    ObjectMonitor* monitor = inflate(THREAD, obj, inflate_cause_jni_exit);
<span class="line-modified">!   // If this thread has locked the object, exit the monitor. We</span>
<span class="line-modified">!   // intentionally do not use CHECK here because we must exit the</span>
<span class="line-modified">!   // monitor even if an exception is pending.</span>
<span class="line-added">+   if (monitor-&gt;check_owner(THREAD)) {</span>
      TSAN_RUNTIME_ONLY(SharedRuntime::tsan_oop_unlock(THREAD, obj));
      monitor-&gt;exit(true, THREAD);
    }
  }
  
  // -----------------------------------------------------------------------------
  // Internal VM locks on java objects
  // standard constructor, allows locking failures
<span class="line-modified">! ObjectLocker::ObjectLocker(Handle obj, Thread* thread, bool do_lock) {</span>
<span class="line-modified">!   _dolock = do_lock;</span>
    _thread = thread;
<span class="line-modified">!   _thread-&gt;check_for_valid_safepoint_state();</span>
    _obj = obj;
  
    if (_dolock) {
<span class="line-modified">!     ObjectSynchronizer::enter(_obj, &amp;_lock, _thread);</span>
      TSAN_RUNTIME_ONLY(SharedRuntime::tsan_oop_lock(_thread, _obj()));
    }
  }
  
  ObjectLocker::~ObjectLocker() {
    if (_dolock) {
      TSAN_RUNTIME_ONLY(SharedRuntime::tsan_oop_unlock(_thread, _obj()));
<span class="line-modified">!     ObjectSynchronizer::exit(_obj(), &amp;_lock, _thread);</span>
    }
  }
  
  
  // -----------------------------------------------------------------------------
  //  Wait/Notify/NotifyAll
  // NOTE: must use heavy weight monitor to handle wait()
  int ObjectSynchronizer::wait(Handle obj, jlong millis, TRAPS) {
    if (UseBiasedLocking) {
<span class="line-modified">!     BiasedLocking::revoke(obj, THREAD);</span>
<span class="line-modified">!     assert(!obj-&gt;mark().has_bias_pattern(), &quot;biases should be revoked by now&quot;);</span>
    }
    if (millis &lt; 0) {
      THROW_MSG_0(vmSymbols::java_lang_IllegalArgumentException(), &quot;timeout value is negative&quot;);
    }
    ObjectMonitor* monitor = inflate(THREAD, obj(), inflate_cause_wait);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 499,14 ***</span>
    // and change this function back into a &quot;void&quot; func.
    // DTRACE_MONITOR_PROBE(waited, monitor, obj(), THREAD);
    return dtrace_waited_probe(monitor, obj, THREAD);
  }
  
<span class="line-modified">! void ObjectSynchronizer::waitUninterruptibly(Handle obj, jlong millis, TRAPS) {</span>
    if (UseBiasedLocking) {
<span class="line-modified">!     BiasedLocking::revoke_and_rebias(obj, false, THREAD);</span>
<span class="line-modified">!     assert(!obj-&gt;mark()-&gt;has_bias_pattern(), &quot;biases should be revoked by now&quot;);</span>
    }
    if (millis &lt; 0) {
      THROW_MSG(vmSymbols::java_lang_IllegalArgumentException(), &quot;timeout value is negative&quot;);
    }
    ObjectMonitor* monitor = inflate(THREAD, obj(), inflate_cause_wait);
<span class="line-new-header">--- 728,14 ---</span>
    // and change this function back into a &quot;void&quot; func.
    // DTRACE_MONITOR_PROBE(waited, monitor, obj(), THREAD);
    return dtrace_waited_probe(monitor, obj, THREAD);
  }
  
<span class="line-modified">! void ObjectSynchronizer::wait_uninterruptibly(Handle obj, jlong millis, TRAPS) {</span>
    if (UseBiasedLocking) {
<span class="line-modified">!     BiasedLocking::revoke(obj, THREAD);</span>
<span class="line-modified">!     assert(!obj-&gt;mark().has_bias_pattern(), &quot;biases should be revoked by now&quot;);</span>
    }
    if (millis &lt; 0) {
      THROW_MSG(vmSymbols::java_lang_IllegalArgumentException(), &quot;timeout value is negative&quot;);
    }
    ObjectMonitor* monitor = inflate(THREAD, obj(), inflate_cause_wait);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 519,30 ***</span>
    TSAN_RUNTIME_ONLY(SharedRuntime::tsan_oop_rec_lock(THREAD, obj(), tsan_rec));
  }
  
  void ObjectSynchronizer::notify(Handle obj, TRAPS) {
    if (UseBiasedLocking) {
<span class="line-modified">!     BiasedLocking::revoke_and_rebias(obj, false, THREAD);</span>
<span class="line-modified">!     assert(!obj-&gt;mark()-&gt;has_bias_pattern(), &quot;biases should be revoked by now&quot;);</span>
    }
  
<span class="line-modified">!   markOop mark = obj-&gt;mark();</span>
<span class="line-modified">!   if (mark-&gt;has_locker() &amp;&amp; THREAD-&gt;is_lock_owned((address)mark-&gt;locker())) {</span>
      return;
    }
    inflate(THREAD, obj(), inflate_cause_notify)-&gt;notify(THREAD);
  }
  
  // NOTE: see comment of notify()
  void ObjectSynchronizer::notifyall(Handle obj, TRAPS) {
    if (UseBiasedLocking) {
<span class="line-modified">!     BiasedLocking::revoke_and_rebias(obj, false, THREAD);</span>
<span class="line-modified">!     assert(!obj-&gt;mark()-&gt;has_bias_pattern(), &quot;biases should be revoked by now&quot;);</span>
    }
  
<span class="line-modified">!   markOop mark = obj-&gt;mark();</span>
<span class="line-modified">!   if (mark-&gt;has_locker() &amp;&amp; THREAD-&gt;is_lock_owned((address)mark-&gt;locker())) {</span>
      return;
    }
    inflate(THREAD, obj(), inflate_cause_notify)-&gt;notifyAll(THREAD);
  }
  
<span class="line-new-header">--- 748,30 ---</span>
    TSAN_RUNTIME_ONLY(SharedRuntime::tsan_oop_rec_lock(THREAD, obj(), tsan_rec));
  }
  
  void ObjectSynchronizer::notify(Handle obj, TRAPS) {
    if (UseBiasedLocking) {
<span class="line-modified">!     BiasedLocking::revoke(obj, THREAD);</span>
<span class="line-modified">!     assert(!obj-&gt;mark().has_bias_pattern(), &quot;biases should be revoked by now&quot;);</span>
    }
  
<span class="line-modified">!   markWord mark = obj-&gt;mark();</span>
<span class="line-modified">!   if (mark.has_locker() &amp;&amp; THREAD-&gt;is_lock_owned((address)mark.locker())) {</span>
      return;
    }
    inflate(THREAD, obj(), inflate_cause_notify)-&gt;notify(THREAD);
  }
  
  // NOTE: see comment of notify()
  void ObjectSynchronizer::notifyall(Handle obj, TRAPS) {
    if (UseBiasedLocking) {
<span class="line-modified">!     BiasedLocking::revoke(obj, THREAD);</span>
<span class="line-modified">!     assert(!obj-&gt;mark().has_bias_pattern(), &quot;biases should be revoked by now&quot;);</span>
    }
  
<span class="line-modified">!   markWord mark = obj-&gt;mark();</span>
<span class="line-modified">!   if (mark.has_locker() &amp;&amp; THREAD-&gt;is_lock_owned((address)mark.locker())) {</span>
      return;
    }
    inflate(THREAD, obj(), inflate_cause_notify)-&gt;notifyAll(THREAD);
  }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 566,40 ***</span>
  // As a general policy we use &quot;volatile&quot; to control compiler-based reordering
  // and explicit fences (barriers) to control for architectural reordering
  // performed by the CPU(s) or platform.
  
  struct SharedGlobals {
<span class="line-modified">!   char         _pad_prefix[DEFAULT_CACHE_LINE_SIZE];</span>
    // These are highly shared mostly-read variables.
    // To avoid false-sharing they need to be the sole occupants of a cache line.
<span class="line-modified">!   volatile int stwRandom;</span>
<span class="line-modified">!   volatile int stwCycle;</span>
<span class="line-modified">!   DEFINE_PAD_MINUS_SIZE(1, DEFAULT_CACHE_LINE_SIZE, sizeof(volatile int) * 2);</span>
    // Hot RW variable -- Sequester to avoid false-sharing
<span class="line-modified">!   volatile int hcSequence;</span>
<span class="line-modified">!   DEFINE_PAD_MINUS_SIZE(2, DEFAULT_CACHE_LINE_SIZE, sizeof(volatile int));</span>
  };
  
  static SharedGlobals GVars;
<span class="line-modified">! static int MonitorScavengeThreshold = 1000000;</span>
<span class="line-removed">- static volatile int ForceMonitorScavenge = 0; // Scavenge required and pending</span>
  
<span class="line-modified">! static markOop ReadStableMark(oop obj) {</span>
<span class="line-modified">!   markOop mark = obj-&gt;mark();</span>
<span class="line-modified">!   if (!mark-&gt;is_being_inflated()) {</span>
      return mark;       // normal fast-path return
    }
  
    int its = 0;
    for (;;) {
<span class="line-modified">!     markOop mark = obj-&gt;mark();</span>
<span class="line-modified">!     if (!mark-&gt;is_being_inflated()) {</span>
        return mark;    // normal fast-path return
      }
  
      // The object is being inflated by some other thread.
<span class="line-modified">!     // The caller of ReadStableMark() must wait for inflation to complete.</span>
      // Avoid live-lock
      // TODO: consider calling SafepointSynchronize::do_call_back() while
      // spinning to see if there&#39;s a safepoint pending.  If so, immediately
      // yielding or blocking would be appropriate.  Avoid spinning while
      // there is a safepoint pending.
<span class="line-new-header">--- 795,39 ---</span>
  // As a general policy we use &quot;volatile&quot; to control compiler-based reordering
  // and explicit fences (barriers) to control for architectural reordering
  // performed by the CPU(s) or platform.
  
  struct SharedGlobals {
<span class="line-modified">!   char         _pad_prefix[OM_CACHE_LINE_SIZE];</span>
    // These are highly shared mostly-read variables.
    // To avoid false-sharing they need to be the sole occupants of a cache line.
<span class="line-modified">!   volatile int stw_random;</span>
<span class="line-modified">!   volatile int stw_cycle;</span>
<span class="line-modified">!   DEFINE_PAD_MINUS_SIZE(1, OM_CACHE_LINE_SIZE, sizeof(volatile int) * 2);</span>
    // Hot RW variable -- Sequester to avoid false-sharing
<span class="line-modified">!   volatile int hc_sequence;</span>
<span class="line-modified">!   DEFINE_PAD_MINUS_SIZE(2, OM_CACHE_LINE_SIZE, sizeof(volatile int));</span>
  };
  
  static SharedGlobals GVars;
<span class="line-modified">! static int _forceMonitorScavenge = 0; // Scavenge required and pending</span>
  
<span class="line-modified">! static markWord read_stable_mark(oop obj) {</span>
<span class="line-modified">!   markWord mark = obj-&gt;mark();</span>
<span class="line-modified">!   if (!mark.is_being_inflated()) {</span>
      return mark;       // normal fast-path return
    }
  
    int its = 0;
    for (;;) {
<span class="line-modified">!     markWord mark = obj-&gt;mark();</span>
<span class="line-modified">!     if (!mark.is_being_inflated()) {</span>
        return mark;    // normal fast-path return
      }
  
      // The object is being inflated by some other thread.
<span class="line-modified">!     // The caller of read_stable_mark() must wait for inflation to complete.</span>
      // Avoid live-lock
      // TODO: consider calling SafepointSynchronize::do_call_back() while
      // spinning to see if there&#39;s a safepoint pending.  If so, immediately
      // yielding or blocking would be appropriate.  Avoid spinning while
      // there is a safepoint pending.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 629,13 ***</span>
          int ix = (cast_from_oop&lt;intptr_t&gt;(obj) &gt;&gt; 5) &amp; (NINFLATIONLOCKS-1);
          int YieldThenBlock = 0;
          assert(ix &gt;= 0 &amp;&amp; ix &lt; NINFLATIONLOCKS, &quot;invariant&quot;);
          assert((NINFLATIONLOCKS &amp; (NINFLATIONLOCKS-1)) == 0, &quot;invariant&quot;);
          Thread::muxAcquire(gInflationLocks + ix, &quot;gInflationLock&quot;);
<span class="line-modified">!         while (obj-&gt;mark() == markOopDesc::INFLATING()) {</span>
            // Beware: NakedYield() is advisory and has almost no effect on some platforms
<span class="line-modified">!           // so we periodically call Self-&gt;_ParkEvent-&gt;park(1).</span>
            // We use a mixed spin/yield/block mechanism.
            if ((YieldThenBlock++) &gt;= 16) {
              Thread::current()-&gt;_ParkEvent-&gt;park(1);
            } else {
              os::naked_yield();
<span class="line-new-header">--- 857,13 ---</span>
          int ix = (cast_from_oop&lt;intptr_t&gt;(obj) &gt;&gt; 5) &amp; (NINFLATIONLOCKS-1);
          int YieldThenBlock = 0;
          assert(ix &gt;= 0 &amp;&amp; ix &lt; NINFLATIONLOCKS, &quot;invariant&quot;);
          assert((NINFLATIONLOCKS &amp; (NINFLATIONLOCKS-1)) == 0, &quot;invariant&quot;);
          Thread::muxAcquire(gInflationLocks + ix, &quot;gInflationLock&quot;);
<span class="line-modified">!         while (obj-&gt;mark() == markWord::INFLATING()) {</span>
            // Beware: NakedYield() is advisory and has almost no effect on some platforms
<span class="line-modified">!           // so we periodically call self-&gt;_ParkEvent-&gt;park(1).</span>
            // We use a mixed spin/yield/block mechanism.
            if ((YieldThenBlock++) &gt;= 16) {
              Thread::current()-&gt;_ParkEvent-&gt;park(1);
            } else {
              os::naked_yield();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 650,166 ***</span>
  }
  
  // hashCode() generation :
  //
  // Possibilities:
<span class="line-modified">! // * MD5Digest of {obj,stwRandom}</span>
<span class="line-modified">! // * CRC32 of {obj,stwRandom} or any linear-feedback shift register function.</span>
  // * A DES- or AES-style SBox[] mechanism
  // * One of the Phi-based schemes, such as:
  //   2654435761 = 2^32 * Phi (golden ratio)
<span class="line-modified">! //   HashCodeValue = ((uintptr_t(obj) &gt;&gt; 3) * 2654435761) ^ GVars.stwRandom ;</span>
  // * A variation of Marsaglia&#39;s shift-xor RNG scheme.
<span class="line-modified">! // * (obj ^ stwRandom) is appealing, but can result</span>
  //   in undesirable regularity in the hashCode values of adjacent objects
  //   (objects allocated back-to-back, in particular).  This could potentially
  //   result in hashtable collisions and reduced hashtable efficiency.
  //   There are simple ways to &quot;diffuse&quot; the middle address bits over the
  //   generated hashCode values:
  
<span class="line-modified">! static inline intptr_t get_next_hash(Thread * Self, oop obj) {</span>
    intptr_t value = 0;
    if (hashCode == 0) {
      // This form uses global Park-Miller RNG.
      // On MP system we&#39;ll have lots of RW access to a global, so the
      // mechanism induces lots of coherency traffic.
      value = os::random();
    } else if (hashCode == 1) {
      // This variation has the property of being stable (idempotent)
      // between STW operations.  This can be useful in some of the 1-0
      // synchronization schemes.
<span class="line-modified">!     intptr_t addrBits = cast_from_oop&lt;intptr_t&gt;(obj) &gt;&gt; 3;</span>
<span class="line-modified">!     value = addrBits ^ (addrBits &gt;&gt; 5) ^ GVars.stwRandom;</span>
    } else if (hashCode == 2) {
      value = 1;            // for sensitivity testing
    } else if (hashCode == 3) {
<span class="line-modified">!     value = ++GVars.hcSequence;</span>
    } else if (hashCode == 4) {
      value = cast_from_oop&lt;intptr_t&gt;(obj);
    } else {
      // Marsaglia&#39;s xor-shift scheme with thread-specific state
      // This is probably the best overall implementation -- we&#39;ll
      // likely make this the default in future releases.
<span class="line-modified">!     unsigned t = Self-&gt;_hashStateX;</span>
      t ^= (t &lt;&lt; 11);
<span class="line-modified">!     Self-&gt;_hashStateX = Self-&gt;_hashStateY;</span>
<span class="line-modified">!     Self-&gt;_hashStateY = Self-&gt;_hashStateZ;</span>
<span class="line-modified">!     Self-&gt;_hashStateZ = Self-&gt;_hashStateW;</span>
<span class="line-modified">!     unsigned v = Self-&gt;_hashStateW;</span>
      v = (v ^ (v &gt;&gt; 19)) ^ (t ^ (t &gt;&gt; 8));
<span class="line-modified">!     Self-&gt;_hashStateW = v;</span>
      value = v;
    }
  
<span class="line-modified">!   value &amp;= markOopDesc::hash_mask;</span>
    if (value == 0) value = 0xBAD;
<span class="line-modified">!   assert(value != markOopDesc::no_hash, &quot;invariant&quot;);</span>
    return value;
  }
  
<span class="line-modified">! intptr_t ObjectSynchronizer::FastHashCode(Thread * Self, oop obj) {</span>
    if (UseBiasedLocking) {
      // NOTE: many places throughout the JVM do not expect a safepoint
      // to be taken here, in particular most operations on perm gen
      // objects. However, we only ever bias Java instances and all of
      // the call sites of identity_hash that might revoke biases have
      // been checked to make sure they can handle a safepoint. The
      // added check of the bias pattern is to avoid useless calls to
      // thread-local storage.
<span class="line-modified">!     if (obj-&gt;mark()-&gt;has_bias_pattern()) {</span>
        // Handle for oop obj in case of STW safepoint
<span class="line-modified">!       Handle hobj(Self, obj);</span>
        // Relaxing assertion for bug 6320749.
        assert(Universe::verify_in_progress() ||
               !SafepointSynchronize::is_at_safepoint(),
               &quot;biases should not be seen by VM thread here&quot;);
<span class="line-modified">!       BiasedLocking::revoke_and_rebias(hobj, false, JavaThread::current());</span>
        obj = hobj();
<span class="line-modified">!       assert(!obj-&gt;mark()-&gt;has_bias_pattern(), &quot;biases should be revoked by now&quot;);</span>
      }
    }
  
    // hashCode() is a heap mutator ...
    // Relaxing assertion for bug 6320749.
    assert(Universe::verify_in_progress() || DumpSharedSpaces ||
           !SafepointSynchronize::is_at_safepoint(), &quot;invariant&quot;);
    assert(Universe::verify_in_progress() || DumpSharedSpaces ||
<span class="line-modified">!          Self-&gt;is_Java_thread() , &quot;invariant&quot;);</span>
    assert(Universe::verify_in_progress() || DumpSharedSpaces ||
<span class="line-modified">!          ((JavaThread *)Self)-&gt;thread_state() != _thread_blocked, &quot;invariant&quot;);</span>
  
    ObjectMonitor* monitor = NULL;
<span class="line-modified">!   markOop temp, test;</span>
    intptr_t hash;
<span class="line-modified">!   markOop mark = ReadStableMark(obj);</span>
  
    // object should remain ineligible for biased locking
<span class="line-modified">!   assert(!mark-&gt;has_bias_pattern(), &quot;invariant&quot;);</span>
  
<span class="line-modified">!   if (mark-&gt;is_neutral()) {</span>
<span class="line-modified">!     hash = mark-&gt;hash();              // this is a normal header</span>
<span class="line-modified">!     if (hash != 0) {                  // if it has hash, just return it</span>
        return hash;
      }
<span class="line-modified">!     hash = get_next_hash(Self, obj);  // allocate a new hash code</span>
<span class="line-modified">!     temp = mark-&gt;copy_set_hash(hash); // merge the hash code into header</span>
<span class="line-modified">!     // use (machine word version) atomic operation to install the hash</span>
      test = obj-&gt;cas_set_mark(temp, mark);
<span class="line-modified">!     if (test == mark) {</span>
        return hash;
      }
<span class="line-modified">!     // If atomic operation failed, we must inflate the header</span>
<span class="line-modified">!     // into heavy weight monitor. We could add more code here</span>
<span class="line-modified">!     // for fast path, but it does not worth the complexity.</span>
<span class="line-modified">!   } else if (mark-&gt;has_monitor()) {</span>
<span class="line-modified">!     monitor = mark-&gt;monitor();</span>
      temp = monitor-&gt;header();
<span class="line-modified">!     assert(temp-&gt;is_neutral(), &quot;invariant: header=&quot; INTPTR_FORMAT, p2i((address)temp));</span>
<span class="line-modified">!     hash = temp-&gt;hash();</span>
<span class="line-modified">!     if (hash != 0) {</span>
        return hash;
      }
<span class="line-modified">!     // Skip to the following code to reduce code size</span>
<span class="line-modified">!   } else if (Self-&gt;is_lock_owned((address)mark-&gt;locker())) {</span>
<span class="line-modified">!     temp = mark-&gt;displaced_mark_helper(); // this is a lightweight monitor owned</span>
<span class="line-modified">!     assert(temp-&gt;is_neutral(), &quot;invariant: header=&quot; INTPTR_FORMAT, p2i((address)temp));</span>
<span class="line-modified">!     hash = temp-&gt;hash();              // by current thread, check if the displaced</span>
<span class="line-modified">!     if (hash != 0) {                  // header contains hash code</span>
        return hash;
      }
      // WARNING:
<span class="line-modified">!     //   The displaced header is strictly immutable.</span>
<span class="line-modified">!     // It can NOT be changed in ANY cases. So we have</span>
<span class="line-modified">!     // to inflate the header into heavyweight monitor</span>
<span class="line-modified">!     // even the current thread owns the lock. The reason</span>
<span class="line-modified">!     // is the BasicLock (stack slot) will be asynchronously</span>
<span class="line-modified">!     // read by other threads during the inflate() function.</span>
<span class="line-modified">!     // Any change to stack may not propagate to other threads</span>
<span class="line-modified">!     // correctly.</span>
<span class="line-modified">!   }</span>
<span class="line-modified">! </span>
<span class="line-modified">!   // Inflate the monitor to set hash code</span>
<span class="line-modified">!   monitor = inflate(Self, obj, inflate_cause_hash_code);</span>
<span class="line-removed">-   // Load displaced header and check it has hash code</span>
    mark = monitor-&gt;header();
<span class="line-modified">!   assert(mark-&gt;is_neutral(), &quot;invariant: header=&quot; INTPTR_FORMAT, p2i((address)mark));</span>
<span class="line-modified">!   hash = mark-&gt;hash();</span>
<span class="line-modified">!   if (hash == 0) {</span>
<span class="line-modified">!     hash = get_next_hash(Self, obj);</span>
<span class="line-modified">!     temp = mark-&gt;copy_set_hash(hash); // merge hash code into header</span>
<span class="line-modified">!     assert(temp-&gt;is_neutral(), &quot;invariant: header=&quot; INTPTR_FORMAT, p2i((address)temp));</span>
<span class="line-modified">!     test = Atomic::cmpxchg(temp, monitor-&gt;header_addr(), mark);</span>
      if (test != mark) {
<span class="line-modified">!       // The only update to the header in the monitor (outside GC)</span>
<span class="line-modified">!       // is install the hash code. If someone add new usage of</span>
<span class="line-modified">!       // displaced header, please update this code</span>
<span class="line-modified">!       hash = test-&gt;hash();</span>
<span class="line-modified">!       assert(test-&gt;is_neutral(), &quot;invariant: header=&quot; INTPTR_FORMAT, p2i((address)test));</span>
<span class="line-modified">!       assert(hash != 0, &quot;Trivial unexpected object/monitor header usage.&quot;);</span>
      }
    }
<span class="line-modified">!   // We finally get the hash</span>
    return hash;
  }
  
  // Deprecated -- use FastHashCode() instead.
  
<span class="line-new-header">--- 878,172 ---</span>
  }
  
  // hashCode() generation :
  //
  // Possibilities:
<span class="line-modified">! // * MD5Digest of {obj,stw_random}</span>
<span class="line-modified">! // * CRC32 of {obj,stw_random} or any linear-feedback shift register function.</span>
  // * A DES- or AES-style SBox[] mechanism
  // * One of the Phi-based schemes, such as:
  //   2654435761 = 2^32 * Phi (golden ratio)
<span class="line-modified">! //   HashCodeValue = ((uintptr_t(obj) &gt;&gt; 3) * 2654435761) ^ GVars.stw_random ;</span>
  // * A variation of Marsaglia&#39;s shift-xor RNG scheme.
<span class="line-modified">! // * (obj ^ stw_random) is appealing, but can result</span>
  //   in undesirable regularity in the hashCode values of adjacent objects
  //   (objects allocated back-to-back, in particular).  This could potentially
  //   result in hashtable collisions and reduced hashtable efficiency.
  //   There are simple ways to &quot;diffuse&quot; the middle address bits over the
  //   generated hashCode values:
  
<span class="line-modified">! static inline intptr_t get_next_hash(Thread* self, oop obj) {</span>
    intptr_t value = 0;
    if (hashCode == 0) {
      // This form uses global Park-Miller RNG.
      // On MP system we&#39;ll have lots of RW access to a global, so the
      // mechanism induces lots of coherency traffic.
      value = os::random();
    } else if (hashCode == 1) {
      // This variation has the property of being stable (idempotent)
      // between STW operations.  This can be useful in some of the 1-0
      // synchronization schemes.
<span class="line-modified">!     intptr_t addr_bits = cast_from_oop&lt;intptr_t&gt;(obj) &gt;&gt; 3;</span>
<span class="line-modified">!     value = addr_bits ^ (addr_bits &gt;&gt; 5) ^ GVars.stw_random;</span>
    } else if (hashCode == 2) {
      value = 1;            // for sensitivity testing
    } else if (hashCode == 3) {
<span class="line-modified">!     value = ++GVars.hc_sequence;</span>
    } else if (hashCode == 4) {
      value = cast_from_oop&lt;intptr_t&gt;(obj);
    } else {
      // Marsaglia&#39;s xor-shift scheme with thread-specific state
      // This is probably the best overall implementation -- we&#39;ll
      // likely make this the default in future releases.
<span class="line-modified">!     unsigned t = self-&gt;_hashStateX;</span>
      t ^= (t &lt;&lt; 11);
<span class="line-modified">!     self-&gt;_hashStateX = self-&gt;_hashStateY;</span>
<span class="line-modified">!     self-&gt;_hashStateY = self-&gt;_hashStateZ;</span>
<span class="line-modified">!     self-&gt;_hashStateZ = self-&gt;_hashStateW;</span>
<span class="line-modified">!     unsigned v = self-&gt;_hashStateW;</span>
      v = (v ^ (v &gt;&gt; 19)) ^ (t ^ (t &gt;&gt; 8));
<span class="line-modified">!     self-&gt;_hashStateW = v;</span>
      value = v;
    }
  
<span class="line-modified">!   value &amp;= markWord::hash_mask;</span>
    if (value == 0) value = 0xBAD;
<span class="line-modified">!   assert(value != markWord::no_hash, &quot;invariant&quot;);</span>
    return value;
  }
  
<span class="line-modified">! intptr_t ObjectSynchronizer::FastHashCode(Thread* self, oop obj) {</span>
    if (UseBiasedLocking) {
      // NOTE: many places throughout the JVM do not expect a safepoint
      // to be taken here, in particular most operations on perm gen
      // objects. However, we only ever bias Java instances and all of
      // the call sites of identity_hash that might revoke biases have
      // been checked to make sure they can handle a safepoint. The
      // added check of the bias pattern is to avoid useless calls to
      // thread-local storage.
<span class="line-modified">!     if (obj-&gt;mark().has_bias_pattern()) {</span>
        // Handle for oop obj in case of STW safepoint
<span class="line-modified">!       Handle hobj(self, obj);</span>
        // Relaxing assertion for bug 6320749.
        assert(Universe::verify_in_progress() ||
               !SafepointSynchronize::is_at_safepoint(),
               &quot;biases should not be seen by VM thread here&quot;);
<span class="line-modified">!       BiasedLocking::revoke(hobj, JavaThread::current());</span>
        obj = hobj();
<span class="line-modified">!       assert(!obj-&gt;mark().has_bias_pattern(), &quot;biases should be revoked by now&quot;);</span>
      }
    }
  
    // hashCode() is a heap mutator ...
    // Relaxing assertion for bug 6320749.
    assert(Universe::verify_in_progress() || DumpSharedSpaces ||
           !SafepointSynchronize::is_at_safepoint(), &quot;invariant&quot;);
    assert(Universe::verify_in_progress() || DumpSharedSpaces ||
<span class="line-modified">!          self-&gt;is_Java_thread() , &quot;invariant&quot;);</span>
    assert(Universe::verify_in_progress() || DumpSharedSpaces ||
<span class="line-modified">!          ((JavaThread *)self)-&gt;thread_state() != _thread_blocked, &quot;invariant&quot;);</span>
  
    ObjectMonitor* monitor = NULL;
<span class="line-modified">!   markWord temp, test;</span>
    intptr_t hash;
<span class="line-modified">!   markWord mark = read_stable_mark(obj);</span>
  
    // object should remain ineligible for biased locking
<span class="line-modified">!   assert(!mark.has_bias_pattern(), &quot;invariant&quot;);</span>
  
<span class="line-modified">!   if (mark.is_neutral()) {            // if this is a normal header</span>
<span class="line-modified">!     hash = mark.hash();</span>
<span class="line-modified">!     if (hash != 0) {                  // if it has a hash, just return it</span>
        return hash;
      }
<span class="line-modified">!     hash = get_next_hash(self, obj);  // get a new hash</span>
<span class="line-modified">!     temp = mark.copy_set_hash(hash);  // merge the hash into header</span>
<span class="line-modified">!                                       // try to install the hash</span>
      test = obj-&gt;cas_set_mark(temp, mark);
<span class="line-modified">!     if (test == mark) {               // if the hash was installed, return it</span>
        return hash;
      }
<span class="line-modified">!     // Failed to install the hash. It could be that another thread</span>
<span class="line-modified">!     // installed the hash just before our attempt or inflation has</span>
<span class="line-modified">!     // occurred or... so we fall thru to inflate the monitor for</span>
<span class="line-modified">!     // stability and then install the hash.</span>
<span class="line-modified">!   } else if (mark.has_monitor()) {</span>
<span class="line-added">+     monitor = mark.monitor();</span>
      temp = monitor-&gt;header();
<span class="line-modified">!     assert(temp.is_neutral(), &quot;invariant: header=&quot; INTPTR_FORMAT, temp.value());</span>
<span class="line-modified">!     hash = temp.hash();</span>
<span class="line-modified">!     if (hash != 0) {                  // if it has a hash, just return it</span>
        return hash;
      }
<span class="line-modified">!     // Fall thru so we only have one place that installs the hash in</span>
<span class="line-modified">!     // the ObjectMonitor.</span>
<span class="line-modified">!   } else if (self-&gt;is_lock_owned((address)mark.locker())) {</span>
<span class="line-modified">!     // This is a stack lock owned by the calling thread so fetch the</span>
<span class="line-modified">!     // displaced markWord from the BasicLock on the stack.</span>
<span class="line-modified">!     temp = mark.displaced_mark_helper();</span>
<span class="line-added">+     assert(temp.is_neutral(), &quot;invariant: header=&quot; INTPTR_FORMAT, temp.value());</span>
<span class="line-added">+     hash = temp.hash();</span>
<span class="line-added">+     if (hash != 0) {                  // if it has a hash, just return it</span>
        return hash;
      }
      // WARNING:
<span class="line-modified">!     // The displaced header in the BasicLock on a thread&#39;s stack</span>
<span class="line-modified">!     // is strictly immutable. It CANNOT be changed in ANY cases.</span>
<span class="line-modified">!     // So we have to inflate the stack lock into an ObjectMonitor</span>
<span class="line-modified">!     // even if the current thread owns the lock. The BasicLock on</span>
<span class="line-modified">!     // a thread&#39;s stack can be asynchronously read by other threads</span>
<span class="line-modified">!     // during an inflate() call so any change to that stack memory</span>
<span class="line-modified">!     // may not propagate to other threads correctly.</span>
<span class="line-modified">!   }</span>
<span class="line-modified">! </span>
<span class="line-modified">!   // Inflate the monitor to set the hash.</span>
<span class="line-modified">!   monitor = inflate(self, obj, inflate_cause_hash_code);</span>
<span class="line-modified">!   // Load ObjectMonitor&#39;s header/dmw field and see if it has a hash.</span>
    mark = monitor-&gt;header();
<span class="line-modified">!   assert(mark.is_neutral(), &quot;invariant: header=&quot; INTPTR_FORMAT, mark.value());</span>
<span class="line-modified">!   hash = mark.hash();</span>
<span class="line-modified">!   if (hash == 0) {                    // if it does not have a hash</span>
<span class="line-modified">!     hash = get_next_hash(self, obj);  // get a new hash</span>
<span class="line-modified">!     temp = mark.copy_set_hash(hash);  // merge the hash into header</span>
<span class="line-modified">!     assert(temp.is_neutral(), &quot;invariant: header=&quot; INTPTR_FORMAT, temp.value());</span>
<span class="line-modified">!     uintptr_t v = Atomic::cmpxchg((volatile uintptr_t*)monitor-&gt;header_addr(), mark.value(), temp.value());</span>
<span class="line-added">+     test = markWord(v);</span>
      if (test != mark) {
<span class="line-modified">!       // The attempt to update the ObjectMonitor&#39;s header/dmw field</span>
<span class="line-modified">!       // did not work. This can happen if another thread managed to</span>
<span class="line-modified">!       // merge in the hash just before our cmpxchg().</span>
<span class="line-modified">!       // If we add any new usages of the header/dmw field, this code</span>
<span class="line-modified">!       // will need to be updated.</span>
<span class="line-modified">!       hash = test.hash();</span>
<span class="line-added">+       assert(test.is_neutral(), &quot;invariant: header=&quot; INTPTR_FORMAT, test.value());</span>
<span class="line-added">+       assert(hash != 0, &quot;should only have lost the race to a thread that set a non-zero hash&quot;);</span>
      }
    }
<span class="line-modified">!   // We finally get the hash.</span>
    return hash;
  }
  
  // Deprecated -- use FastHashCode() instead.
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 819,30 ***</span>
  
  
  bool ObjectSynchronizer::current_thread_holds_lock(JavaThread* thread,
                                                     Handle h_obj) {
    if (UseBiasedLocking) {
<span class="line-modified">!     BiasedLocking::revoke_and_rebias(h_obj, false, thread);</span>
<span class="line-modified">!     assert(!h_obj-&gt;mark()-&gt;has_bias_pattern(), &quot;biases should be revoked by now&quot;);</span>
    }
  
    assert(thread == JavaThread::current(), &quot;Can only be called on current thread&quot;);
    oop obj = h_obj();
  
<span class="line-modified">!   markOop mark = ReadStableMark(obj);</span>
  
    // Uncontended case, header points to stack
<span class="line-modified">!   if (mark-&gt;has_locker()) {</span>
<span class="line-modified">!     return thread-&gt;is_lock_owned((address)mark-&gt;locker());</span>
    }
    // Contended case, header points to ObjectMonitor (tagged pointer)
<span class="line-modified">!   if (mark-&gt;has_monitor()) {</span>
<span class="line-modified">!     ObjectMonitor* monitor = mark-&gt;monitor();</span>
      return monitor-&gt;is_entered(thread) != 0;
    }
    // Unlocked case, header in place
<span class="line-modified">!   assert(mark-&gt;is_neutral(), &quot;sanity check&quot;);</span>
    return false;
  }
  
  // Be aware of this method could revoke bias of the lock object.
  // This method queries the ownership of the lock handle specified by &#39;h_obj&#39;.
<span class="line-new-header">--- 1053,30 ---</span>
  
  
  bool ObjectSynchronizer::current_thread_holds_lock(JavaThread* thread,
                                                     Handle h_obj) {
    if (UseBiasedLocking) {
<span class="line-modified">!     BiasedLocking::revoke(h_obj, thread);</span>
<span class="line-modified">!     assert(!h_obj-&gt;mark().has_bias_pattern(), &quot;biases should be revoked by now&quot;);</span>
    }
  
    assert(thread == JavaThread::current(), &quot;Can only be called on current thread&quot;);
    oop obj = h_obj();
  
<span class="line-modified">!   markWord mark = read_stable_mark(obj);</span>
  
    // Uncontended case, header points to stack
<span class="line-modified">!   if (mark.has_locker()) {</span>
<span class="line-modified">!     return thread-&gt;is_lock_owned((address)mark.locker());</span>
    }
    // Contended case, header points to ObjectMonitor (tagged pointer)
<span class="line-modified">!   if (mark.has_monitor()) {</span>
<span class="line-modified">!     ObjectMonitor* monitor = mark.monitor();</span>
      return monitor-&gt;is_entered(thread) != 0;
    }
    // Unlocked case, header in place
<span class="line-modified">!   assert(mark.is_neutral(), &quot;sanity check&quot;);</span>
    return false;
  }
  
  // Be aware of this method could revoke bias of the lock object.
  // This method queries the ownership of the lock handle specified by &#39;h_obj&#39;.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 856,66 ***</span>
    assert(!SafepointSynchronize::is_at_safepoint(), &quot;invariant&quot;);
    assert(self-&gt;thread_state() != _thread_blocked, &quot;invariant&quot;);
  
    // Possible mark states: neutral, biased, stack-locked, inflated
  
<span class="line-modified">!   if (UseBiasedLocking &amp;&amp; h_obj()-&gt;mark()-&gt;has_bias_pattern()) {</span>
      // CASE: biased
<span class="line-modified">!     BiasedLocking::revoke_and_rebias(h_obj, false, self);</span>
<span class="line-modified">!     assert(!h_obj-&gt;mark()-&gt;has_bias_pattern(),</span>
             &quot;biases should be revoked by now&quot;);
    }
  
    assert(self == JavaThread::current(), &quot;Can only be called on current thread&quot;);
    oop obj = h_obj();
<span class="line-modified">!   markOop mark = ReadStableMark(obj);</span>
  
    // CASE: stack-locked.  Mark points to a BasicLock on the owner&#39;s stack.
<span class="line-modified">!   if (mark-&gt;has_locker()) {</span>
<span class="line-modified">!     return self-&gt;is_lock_owned((address)mark-&gt;locker()) ?</span>
        owner_self : owner_other;
    }
  
    // CASE: inflated. Mark (tagged pointer) points to an ObjectMonitor.
    // The Object:ObjectMonitor relationship is stable as long as we&#39;re
    // not at a safepoint.
<span class="line-modified">!   if (mark-&gt;has_monitor()) {</span>
<span class="line-modified">!     void * owner = mark-&gt;monitor()-&gt;_owner;</span>
      if (owner == NULL) return owner_none;
      return (owner == self ||
              self-&gt;is_lock_owned((address)owner)) ? owner_self : owner_other;
    }
  
    // CASE: neutral
<span class="line-modified">!   assert(mark-&gt;is_neutral(), &quot;sanity check&quot;);</span>
    return owner_none;           // it&#39;s unlocked
  }
  
  // FIXME: jvmti should call this
  JavaThread* ObjectSynchronizer::get_lock_owner(ThreadsList * t_list, Handle h_obj) {
    if (UseBiasedLocking) {
      if (SafepointSynchronize::is_at_safepoint()) {
        BiasedLocking::revoke_at_safepoint(h_obj);
      } else {
<span class="line-modified">!       BiasedLocking::revoke_and_rebias(h_obj, false, JavaThread::current());</span>
      }
<span class="line-modified">!     assert(!h_obj-&gt;mark()-&gt;has_bias_pattern(), &quot;biases should be revoked by now&quot;);</span>
    }
  
    oop obj = h_obj();
    address owner = NULL;
  
<span class="line-modified">!   markOop mark = ReadStableMark(obj);</span>
  
    // Uncontended case, header points to stack
<span class="line-modified">!   if (mark-&gt;has_locker()) {</span>
<span class="line-modified">!     owner = (address) mark-&gt;locker();</span>
    }
  
    // Contended case, header points to ObjectMonitor (tagged pointer)
<span class="line-modified">!   else if (mark-&gt;has_monitor()) {</span>
<span class="line-modified">!     ObjectMonitor* monitor = mark-&gt;monitor();</span>
      assert(monitor != NULL, &quot;monitor should be non-null&quot;);
      owner = (address) monitor-&gt;owner();
    }
  
    if (owner != NULL) {
<span class="line-new-header">--- 1090,66 ---</span>
    assert(!SafepointSynchronize::is_at_safepoint(), &quot;invariant&quot;);
    assert(self-&gt;thread_state() != _thread_blocked, &quot;invariant&quot;);
  
    // Possible mark states: neutral, biased, stack-locked, inflated
  
<span class="line-modified">!   if (UseBiasedLocking &amp;&amp; h_obj()-&gt;mark().has_bias_pattern()) {</span>
      // CASE: biased
<span class="line-modified">!     BiasedLocking::revoke(h_obj, self);</span>
<span class="line-modified">!     assert(!h_obj-&gt;mark().has_bias_pattern(),</span>
             &quot;biases should be revoked by now&quot;);
    }
  
    assert(self == JavaThread::current(), &quot;Can only be called on current thread&quot;);
    oop obj = h_obj();
<span class="line-modified">!   markWord mark = read_stable_mark(obj);</span>
  
    // CASE: stack-locked.  Mark points to a BasicLock on the owner&#39;s stack.
<span class="line-modified">!   if (mark.has_locker()) {</span>
<span class="line-modified">!     return self-&gt;is_lock_owned((address)mark.locker()) ?</span>
        owner_self : owner_other;
    }
  
    // CASE: inflated. Mark (tagged pointer) points to an ObjectMonitor.
    // The Object:ObjectMonitor relationship is stable as long as we&#39;re
    // not at a safepoint.
<span class="line-modified">!   if (mark.has_monitor()) {</span>
<span class="line-modified">!     void* owner = mark.monitor()-&gt;_owner;</span>
      if (owner == NULL) return owner_none;
      return (owner == self ||
              self-&gt;is_lock_owned((address)owner)) ? owner_self : owner_other;
    }
  
    // CASE: neutral
<span class="line-modified">!   assert(mark.is_neutral(), &quot;sanity check&quot;);</span>
    return owner_none;           // it&#39;s unlocked
  }
  
  // FIXME: jvmti should call this
  JavaThread* ObjectSynchronizer::get_lock_owner(ThreadsList * t_list, Handle h_obj) {
    if (UseBiasedLocking) {
      if (SafepointSynchronize::is_at_safepoint()) {
        BiasedLocking::revoke_at_safepoint(h_obj);
      } else {
<span class="line-modified">!       BiasedLocking::revoke(h_obj, JavaThread::current());</span>
      }
<span class="line-modified">!     assert(!h_obj-&gt;mark().has_bias_pattern(), &quot;biases should be revoked by now&quot;);</span>
    }
  
    oop obj = h_obj();
    address owner = NULL;
  
<span class="line-modified">!   markWord mark = read_stable_mark(obj);</span>
  
    // Uncontended case, header points to stack
<span class="line-modified">!   if (mark.has_locker()) {</span>
<span class="line-modified">!     owner = (address) mark.locker();</span>
    }
  
    // Contended case, header points to ObjectMonitor (tagged pointer)
<span class="line-modified">!   else if (mark.has_monitor()) {</span>
<span class="line-modified">!     ObjectMonitor* monitor = mark.monitor();</span>
      assert(monitor != NULL, &quot;monitor should be non-null&quot;);
      owner = (address) monitor-&gt;owner();
    }
  
    if (owner != NULL) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 924,52 ***</span>
    }
  
    // Unlocked case, header in place
    // Cannot have assertion since this object may have been
    // locked by another thread when reaching here.
<span class="line-modified">!   // assert(mark-&gt;is_neutral(), &quot;sanity check&quot;);</span>
  
    return NULL;
  }
  
  // Visitors ...
  
  void ObjectSynchronizer::monitors_iterate(MonitorClosure* closure) {
<span class="line-modified">!   PaddedEnd&lt;ObjectMonitor&gt; * block = OrderAccess::load_acquire(&amp;gBlockList);</span>
    while (block != NULL) {
      assert(block-&gt;object() == CHAINMARKER, &quot;must be a block header&quot;);
      for (int i = _BLOCKSIZE - 1; i &gt; 0; i--) {
        ObjectMonitor* mid = (ObjectMonitor *)(block + i);
        oop object = (oop)mid-&gt;object();
        if (object != NULL) {
          closure-&gt;do_monitor(mid);
        }
      }
<span class="line-modified">!     block = (PaddedEnd&lt;ObjectMonitor&gt; *)block-&gt;FreeNext;</span>
    }
  }
  
<span class="line-modified">! // Get the next block in the block list.</span>
<span class="line-modified">! static inline PaddedEnd&lt;ObjectMonitor&gt;* next(PaddedEnd&lt;ObjectMonitor&gt;* block) {</span>
<span class="line-removed">-   assert(block-&gt;object() == CHAINMARKER, &quot;must be a block header&quot;);</span>
<span class="line-removed">-   block = (PaddedEnd&lt;ObjectMonitor&gt;*) block-&gt;FreeNext;</span>
<span class="line-removed">-   assert(block == NULL || block-&gt;object() == CHAINMARKER, &quot;must be a block header&quot;);</span>
<span class="line-removed">-   return block;</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- static bool monitors_used_above_threshold() {</span>
    if (population == 0) {
      return false;
    }
<span class="line-modified">!   int monitors_used = gMonitorPopulation - gMonitorFreeCount;</span>
<span class="line-modified">!   int monitor_usage = (monitors_used * 100LL) / gMonitorPopulation;</span>
<span class="line-modified">!   return monitor_usage &gt; MonitorUsedDeflationThreshold;</span>
  }
  
  bool ObjectSynchronizer::is_cleanup_needed() {
<span class="line-modified">!   if (MonitorUsedDeflationThreshold &gt; 0) {</span>
<span class="line-modified">!     return monitors_used_above_threshold();</span>
    }
    return false;
  }
  
  void ObjectSynchronizer::oops_do(OopClosure* f) {
<span class="line-new-header">--- 1158,67 ---</span>
    }
  
    // Unlocked case, header in place
    // Cannot have assertion since this object may have been
    // locked by another thread when reaching here.
<span class="line-modified">!   // assert(mark.is_neutral(), &quot;sanity check&quot;);</span>
  
    return NULL;
  }
  
  // Visitors ...
  
  void ObjectSynchronizer::monitors_iterate(MonitorClosure* closure) {
<span class="line-modified">!   PaddedObjectMonitor* block = Atomic::load(&amp;g_block_list);</span>
    while (block != NULL) {
      assert(block-&gt;object() == CHAINMARKER, &quot;must be a block header&quot;);
      for (int i = _BLOCKSIZE - 1; i &gt; 0; i--) {
        ObjectMonitor* mid = (ObjectMonitor *)(block + i);
        oop object = (oop)mid-&gt;object();
        if (object != NULL) {
<span class="line-added">+         // Only process with closure if the object is set.</span>
          closure-&gt;do_monitor(mid);
        }
      }
<span class="line-modified">!     // unmarked_next() is not needed with g_block_list (no locking</span>
<span class="line-added">+     // used with block linkage _next_om fields).</span>
<span class="line-added">+     block = (PaddedObjectMonitor*)block-&gt;next_om();</span>
    }
  }
  
<span class="line-modified">! static bool monitors_used_above_threshold() {</span>
<span class="line-modified">!   int population = Atomic::load(&amp;om_list_globals._population);</span>
    if (population == 0) {
      return false;
    }
<span class="line-modified">!   if (MonitorUsedDeflationThreshold &gt; 0) {</span>
<span class="line-modified">!     int monitors_used = population - Atomic::load(&amp;om_list_globals._free_count);</span>
<span class="line-modified">!     int monitor_usage = (monitors_used * 100LL) / population;</span>
<span class="line-added">+     return monitor_usage &gt; MonitorUsedDeflationThreshold;</span>
<span class="line-added">+   }</span>
<span class="line-added">+   return false;</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ // Returns true if MonitorBound is set (&gt; 0) and if the specified</span>
<span class="line-added">+ // cnt is &gt; MonitorBound. Otherwise returns false.</span>
<span class="line-added">+ static bool is_MonitorBound_exceeded(const int cnt) {</span>
<span class="line-added">+   const int mx = MonitorBound;</span>
<span class="line-added">+   return mx &gt; 0 &amp;&amp; cnt &gt; mx;</span>
  }
  
  bool ObjectSynchronizer::is_cleanup_needed() {
<span class="line-modified">!   if (monitors_used_above_threshold()) {</span>
<span class="line-modified">!     // Too many monitors in use.</span>
<span class="line-added">+     return true;</span>
<span class="line-added">+   }</span>
<span class="line-added">+   return needs_monitor_scavenge();</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ bool ObjectSynchronizer::needs_monitor_scavenge() {</span>
<span class="line-added">+   if (Atomic::load(&amp;_forceMonitorScavenge) == 1) {</span>
<span class="line-added">+     log_info(monitorinflation)(&quot;Monitor scavenge needed, triggering safepoint cleanup.&quot;);</span>
<span class="line-added">+     return true;</span>
    }
    return false;
  }
  
  void ObjectSynchronizer::oops_do(OopClosure* f) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 978,51 ***</span>
    global_used_oops_do(f);
  }
  
  void ObjectSynchronizer::global_used_oops_do(OopClosure* f) {
    assert(SafepointSynchronize::is_at_safepoint(), &quot;must be at safepoint&quot;);
<span class="line-modified">!   list_oops_do(gOmInUseList, f);</span>
  }
  
  void ObjectSynchronizer::thread_local_used_oops_do(Thread* thread, OopClosure* f) {
    assert(SafepointSynchronize::is_at_safepoint(), &quot;must be at safepoint&quot;);
<span class="line-modified">!   list_oops_do(thread-&gt;omInUseList, f);</span>
  }
  
  void ObjectSynchronizer::list_oops_do(ObjectMonitor* list, OopClosure* f) {
    assert(SafepointSynchronize::is_at_safepoint(), &quot;must be at safepoint&quot;);
<span class="line-modified">!   ObjectMonitor* mid;</span>
<span class="line-modified">!   for (mid = list; mid != NULL; mid = mid-&gt;FreeNext) {</span>
      if (mid-&gt;object() != NULL) {
        f-&gt;do_oop((oop*)mid-&gt;object_addr());
      }
    }
  }
  
  
  // -----------------------------------------------------------------------------
  // ObjectMonitor Lifecycle
  // -----------------------
<span class="line-modified">! // Inflation unlinks monitors from the global gFreeList and</span>
<span class="line-modified">! // associates them with objects.  Deflation -- which occurs at</span>
<span class="line-modified">! // STW-time -- disassociates idle monitors from objects.  Such</span>
<span class="line-modified">! // scavenged monitors are returned to the gFreeList.</span>
<span class="line-removed">- //</span>
<span class="line-removed">- // The global list is protected by gListLock.  All the critical sections</span>
<span class="line-removed">- // are short and operate in constant-time.</span>
  //
  // ObjectMonitors reside in type-stable memory (TSM) and are immortal.
  //
  // Lifecycle:
<span class="line-modified">! // --   unassigned and on the global free list</span>
<span class="line-modified">! // --   unassigned and on a thread&#39;s private omFreeList</span>
  // --   assigned to an object.  The object is inflated and the mark refers
<span class="line-modified">! //      to the objectmonitor.</span>
  
  
  // Constraining monitor pool growth via MonitorBound ...
  //
  // The monitor pool is grow-only.  We scavenge at STW safepoint-time, but the
  // the rate of scavenging is driven primarily by GC.  As such,  we can find
  // an inordinate number of monitors in circulation.
  // To avoid that scenario we can artificially induce a STW safepoint
  // if the pool appears to be growing past some reasonable bound.
<span class="line-new-header">--- 1227,51 ---</span>
    global_used_oops_do(f);
  }
  
  void ObjectSynchronizer::global_used_oops_do(OopClosure* f) {
    assert(SafepointSynchronize::is_at_safepoint(), &quot;must be at safepoint&quot;);
<span class="line-modified">!   list_oops_do(Atomic::load(&amp;om_list_globals._in_use_list), f);</span>
  }
  
  void ObjectSynchronizer::thread_local_used_oops_do(Thread* thread, OopClosure* f) {
    assert(SafepointSynchronize::is_at_safepoint(), &quot;must be at safepoint&quot;);
<span class="line-modified">!   list_oops_do(thread-&gt;om_in_use_list, f);</span>
  }
  
  void ObjectSynchronizer::list_oops_do(ObjectMonitor* list, OopClosure* f) {
    assert(SafepointSynchronize::is_at_safepoint(), &quot;must be at safepoint&quot;);
<span class="line-modified">!   // The oops_do() phase does not overlap with monitor deflation</span>
<span class="line-modified">!   // so no need to lock ObjectMonitors for the list traversal.</span>
<span class="line-added">+   for (ObjectMonitor* mid = list; mid != NULL; mid = unmarked_next(mid)) {</span>
      if (mid-&gt;object() != NULL) {
        f-&gt;do_oop((oop*)mid-&gt;object_addr());
      }
    }
  }
  
  
  // -----------------------------------------------------------------------------
  // ObjectMonitor Lifecycle
  // -----------------------
<span class="line-modified">! // Inflation unlinks monitors from om_list_globals._free_list or a per-thread</span>
<span class="line-modified">! // free list and associates them with objects. Deflation -- which occurs at</span>
<span class="line-modified">! // STW-time -- disassociates idle monitors from objects.</span>
<span class="line-modified">! // Such scavenged monitors are returned to the om_list_globals._free_list.</span>
  //
  // ObjectMonitors reside in type-stable memory (TSM) and are immortal.
  //
  // Lifecycle:
<span class="line-modified">! // --   unassigned and on the om_list_globals._free_list</span>
<span class="line-modified">! // --   unassigned and on a per-thread free list</span>
  // --   assigned to an object.  The object is inflated and the mark refers
<span class="line-modified">! //      to the ObjectMonitor.</span>
  
  
  // Constraining monitor pool growth via MonitorBound ...
  //
<span class="line-added">+ // If MonitorBound is not set (&lt;= 0), MonitorBound checks are disabled.</span>
<span class="line-added">+ //</span>
  // The monitor pool is grow-only.  We scavenge at STW safepoint-time, but the
  // the rate of scavenging is driven primarily by GC.  As such,  we can find
  // an inordinate number of monitors in circulation.
  // To avoid that scenario we can artificially induce a STW safepoint
  // if the pool appears to be growing past some reasonable bound.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1031,275 ***</span>
  // type of limit.  Beware that if MonitorBound is set to too low a value
  // we could just loop. In addition, if MonitorBound is set to a low value
  // we&#39;ll incur more safepoints, which are harmful to performance.
  // See also: GuaranteedSafepointInterval
  //
<span class="line-modified">! // The current implementation uses asynchronous VM operations.</span>
  
<span class="line-modified">! static void InduceScavenge(Thread * Self, const char * Whence) {</span>
    // Induce STW safepoint to trim monitors
    // Ultimately, this results in a call to deflate_idle_monitors() in the near future.
<span class="line-modified">!   // More precisely, trigger an asynchronous STW safepoint as the number</span>
    // of active monitors passes the specified threshold.
    // TODO: assert thread state is reasonable
  
<span class="line-modified">!   if (ForceMonitorScavenge == 0 &amp;&amp; Atomic::xchg (1, &amp;ForceMonitorScavenge) == 0) {</span>
<span class="line-modified">!     // Induce a &#39;null&#39; safepoint to scavenge monitors</span>
<span class="line-removed">-     // Must VM_Operation instance be heap allocated as the op will be enqueue and posted</span>
<span class="line-removed">-     // to the VMthread and have a lifespan longer than that of this activation record.</span>
<span class="line-removed">-     // The VMThread will delete the op when completed.</span>
<span class="line-removed">-     VMThread::execute(new VM_ScavengeMonitors());</span>
    }
  }
  
<span class="line-modified">! ObjectMonitor* ObjectSynchronizer::omAlloc(Thread * Self) {</span>
    // A large MAXPRIVATE value reduces both list lock contention
    // and list coherency traffic, but also tends to increase the
<span class="line-modified">!   // number of objectMonitors in circulation as well as the STW</span>
    // scavenge costs.  As usual, we lean toward time in space-time
    // tradeoffs.
    const int MAXPRIVATE = 1024;
    for (;;) {
<span class="line-modified">!     ObjectMonitor * m;</span>
  
<span class="line-modified">!     // 1: try to allocate from the thread&#39;s local omFreeList.</span>
      // Threads will attempt to allocate first from their local list, then
<span class="line-modified">!     // from the global list, and only after those attempts fail will the thread</span>
<span class="line-modified">!     // attempt to instantiate new monitors.   Thread-local free lists take</span>
<span class="line-modified">!     // heat off the gListLock and improve allocation latency, as well as reducing</span>
<span class="line-modified">!     // coherency traffic on the shared global list.</span>
<span class="line-modified">!     m = Self-&gt;omFreeList;</span>
      if (m != NULL) {
<span class="line-modified">!       Self-&gt;omFreeList = m-&gt;FreeNext;</span>
<span class="line-removed">-       Self-&gt;omFreeCount--;</span>
<span class="line-removed">-       guarantee(m-&gt;object() == NULL, &quot;invariant&quot;);</span>
<span class="line-removed">-       m-&gt;FreeNext = Self-&gt;omInUseList;</span>
<span class="line-removed">-       Self-&gt;omInUseList = m;</span>
        prepend_to_om_in_use_list(self, m);
        return m;
      }
  
<span class="line-modified">!     // 2: try to allocate from the global gFreeList</span>
<span class="line-removed">-     // CONSIDER: use muxTry() instead of muxAcquire().</span>
<span class="line-removed">-     // If the muxTry() fails then drop immediately into case 3.</span>
      // If we&#39;re using thread-local free lists then try
      // to reprovision the caller&#39;s free list.
<span class="line-modified">!     if (gFreeList != NULL) {</span>
<span class="line-modified">!       // Reprovision the thread&#39;s omFreeList.</span>
        // Use bulk transfers to reduce the allocation rate and heat
        // on various locks.
<span class="line-modified">!       Thread::muxAcquire(&amp;gListLock, &quot;omAlloc(1)&quot;);</span>
<span class="line-modified">!       for (int i = Self-&gt;omFreeProvision; --i &gt;= 0 &amp;&amp; gFreeList != NULL;) {</span>
<span class="line-modified">!         gMonitorFreeCount--;</span>
<span class="line-modified">!         ObjectMonitor * take = gFreeList;</span>
<span class="line-modified">!         gFreeList = take-&gt;FreeNext;</span>
          guarantee(take-&gt;object() == NULL, &quot;invariant&quot;);
<span class="line-modified">!         guarantee(!take-&gt;is_busy(), &quot;invariant&quot;);</span>
<span class="line-removed">-         take-&gt;Recycle();</span>
          om_release(self, take, false);
        }
<span class="line-modified">!       Thread::muxRelease(&amp;gListLock);</span>
<span class="line-modified">!       Self-&gt;omFreeProvision += 1 + (Self-&gt;omFreeProvision/2);</span>
<span class="line-removed">-       if (Self-&gt;omFreeProvision &gt; MAXPRIVATE) Self-&gt;omFreeProvision = MAXPRIVATE;</span>
  
<span class="line-modified">!       const int mx = MonitorBound;</span>
<span class="line-modified">!       if (mx &gt; 0 &amp;&amp; (gMonitorPopulation-gMonitorFreeCount) &gt; mx) {</span>
<span class="line-modified">!         // We can&#39;t safely induce a STW safepoint from omAlloc() as our thread</span>
          // state may not be appropriate for such activities and callers may hold
          // naked oops, so instead we defer the action.
<span class="line-modified">!         InduceScavenge(Self, &quot;omAlloc&quot;);</span>
        }
        continue;
      }
  
      // 3: allocate a block of new ObjectMonitors
      // Both the local and global free lists are empty -- resort to malloc().
<span class="line-modified">!     // In the current implementation objectMonitors are TSM - immortal.</span>
      // Ideally, we&#39;d write &quot;new ObjectMonitor[_BLOCKSIZE], but we want
      // each ObjectMonitor to start at the beginning of a cache line,
      // so we use align_up().
      // A better solution would be to use C++ placement-new.
      // BEWARE: As it stands currently, we don&#39;t run the ctors!
      assert(_BLOCKSIZE &gt; 1, &quot;invariant&quot;);
<span class="line-modified">!     size_t neededsize = sizeof(PaddedEnd&lt;ObjectMonitor&gt;) * _BLOCKSIZE;</span>
<span class="line-modified">!     PaddedEnd&lt;ObjectMonitor&gt; * temp;</span>
<span class="line-modified">!     size_t aligned_size = neededsize + (DEFAULT_CACHE_LINE_SIZE - 1);</span>
<span class="line-modified">!     void* real_malloc_addr = (void *)NEW_C_HEAP_ARRAY(char, aligned_size,</span>
<span class="line-modified">!                                                       mtInternal);</span>
<span class="line-removed">-     temp = (PaddedEnd&lt;ObjectMonitor&gt; *)</span>
<span class="line-removed">-              align_up(real_malloc_addr, DEFAULT_CACHE_LINE_SIZE);</span>
<span class="line-removed">- </span>
<span class="line-removed">-     // NOTE: (almost) no way to recover if allocation failed.</span>
<span class="line-removed">-     // We might be able to induce a STW safepoint and scavenge enough</span>
<span class="line-removed">-     // objectMonitors to permit progress.</span>
<span class="line-removed">-     if (temp == NULL) {</span>
<span class="line-removed">-       vm_exit_out_of_memory(neededsize, OOM_MALLOC_ERROR,</span>
<span class="line-removed">-                             &quot;Allocate ObjectMonitors&quot;);</span>
<span class="line-removed">-     }</span>
      (void)memset((void *) temp, 0, neededsize);
  
      // Format the block.
      // initialize the linked list, each monitor points to its next
      // forming the single linked free list, the very first monitor
      // will points to next block, which forms the block list.
<span class="line-modified">!     // The trick of using the 1st element in the block as gBlockList</span>
      // linkage should be reconsidered.  A better implementation would
      // look like: class Block { Block * next; int N; ObjectMonitor Body [N] ; }
  
      for (int i = 1; i &lt; _BLOCKSIZE; i++) {
<span class="line-modified">!       temp[i].FreeNext = (ObjectMonitor *)&amp;temp[i+1];</span>
      }
  
      // terminate the last monitor as the end of list
<span class="line-modified">!     temp[_BLOCKSIZE - 1].FreeNext = NULL;</span>
  
      // Element [0] is reserved for global list linkage
      temp[0].set_object(CHAINMARKER);
  
      // Consider carving out this thread&#39;s current request from the
      // block in hand.  This avoids some lock traffic and redundant
      // list activity.
  
<span class="line-modified">!     // Acquire the gListLock to manipulate gBlockList and gFreeList.</span>
<span class="line-removed">-     // An Oyama-Taura-Yonezawa scheme might be more efficient.</span>
<span class="line-removed">-     Thread::muxAcquire(&amp;gListLock, &quot;omAlloc(2)&quot;);</span>
<span class="line-removed">-     gMonitorPopulation += _BLOCKSIZE-1;</span>
<span class="line-removed">-     gMonitorFreeCount += _BLOCKSIZE-1;</span>
<span class="line-removed">- </span>
<span class="line-removed">-     // Add the new block to the list of extant blocks (gBlockList).</span>
<span class="line-removed">-     // The very first objectMonitor in a block is reserved and dedicated.</span>
<span class="line-removed">-     // It serves as blocklist &quot;next&quot; linkage.</span>
<span class="line-removed">-     temp[0].FreeNext = gBlockList;</span>
<span class="line-removed">-     // There are lock-free uses of gBlockList so make sure that</span>
<span class="line-removed">-     // the previous stores happen before we update gBlockList.</span>
<span class="line-removed">-     OrderAccess::release_store(&amp;gBlockList, temp);</span>
<span class="line-removed">- </span>
<span class="line-removed">-     // Add the new string of objectMonitors to the global free list</span>
<span class="line-removed">-     temp[_BLOCKSIZE - 1].FreeNext = gFreeList;</span>
<span class="line-removed">-     gFreeList = temp + 1;</span>
<span class="line-removed">-     Thread::muxRelease(&amp;gListLock);</span>
    }
  }
  
<span class="line-modified">! // Place &quot;m&quot; on the caller&#39;s private per-thread omFreeList.</span>
  // In practice there&#39;s no need to clamp or limit the number of
<span class="line-modified">! // monitors on a thread&#39;s omFreeList as the only time we&#39;ll call</span>
<span class="line-modified">! // omRelease is to return a monitor to the free list after a CAS</span>
<span class="line-modified">! // attempt failed.  This doesn&#39;t allow unbounded #s of monitors to</span>
  // accumulate on a thread&#39;s free list.
  //
  // Key constraint: all ObjectMonitors on a thread&#39;s free list and the global
  // free list must have their object field set to null. This prevents the
<span class="line-modified">! // scavenger -- deflate_monitor_list() -- from reclaiming them.</span>
  
<span class="line-modified">! void ObjectSynchronizer::omRelease(Thread * Self, ObjectMonitor * m,</span>
<span class="line-modified">!                                    bool fromPerThreadAlloc) {</span>
<span class="line-modified">!   guarantee(m-&gt;header() == NULL, &quot;invariant&quot;);</span>
    guarantee(m-&gt;object() == NULL, &quot;invariant&quot;);
<span class="line-modified">!   guarantee(((m-&gt;is_busy()|m-&gt;_recursions) == 0), &quot;freeing in-use monitor&quot;);</span>
<span class="line-modified">!   // Remove from omInUseList</span>
<span class="line-modified">!   if (fromPerThreadAlloc) {</span>
<span class="line-modified">!     ObjectMonitor* cur_mid_in_use = NULL;</span>
<span class="line-modified">!     bool extracted = false;</span>
<span class="line-modified">!     for (ObjectMonitor* mid = Self-&gt;omInUseList; mid != NULL; cur_mid_in_use = mid, mid = mid-&gt;FreeNext) {</span>
<span class="line-modified">!       if (m == mid) {</span>
<span class="line-modified">!         // extract from per-thread in-use list</span>
<span class="line-modified">!         if (mid == Self-&gt;omInUseList) {</span>
<span class="line-modified">!           Self-&gt;omInUseList = mid-&gt;FreeNext;</span>
<span class="line-modified">!         } else if (cur_mid_in_use != NULL) {</span>
<span class="line-modified">!           cur_mid_in_use-&gt;FreeNext = mid-&gt;FreeNext; // maintain the current thread in-use list</span>
          }
<span class="line-removed">-         extracted = true;</span>
<span class="line-removed">-         Self-&gt;omInUseCount--;</span>
<span class="line-removed">-         break;</span>
        }
      }
<span class="line-modified">!     assert(extracted, &quot;Should have extracted from in-use list&quot;);</span>
    }
  
<span class="line-modified">!   // FreeNext is used for both omInUseList and omFreeList, so clear old before setting new</span>
<span class="line-removed">-   m-&gt;FreeNext = Self-&gt;omFreeList;</span>
<span class="line-removed">-   Self-&gt;omFreeList = m;</span>
<span class="line-removed">-   Self-&gt;omFreeCount++;</span>
  }
  
<span class="line-modified">! // Return the monitors of a moribund thread&#39;s local free list to</span>
<span class="line-modified">! // the global free list.  Typically a thread calls omFlush() when</span>
<span class="line-modified">! // it&#39;s dying.  We could also consider having the VM thread steal</span>
<span class="line-removed">- // monitors from threads that have not run java code over a few</span>
<span class="line-removed">- // consecutive STW safepoints.  Relatedly, we might decay</span>
<span class="line-removed">- // omFreeProvision at STW safepoints.</span>
<span class="line-removed">- //</span>
<span class="line-removed">- // Also return the monitors of a moribund thread&#39;s omInUseList to</span>
<span class="line-removed">- // a global gOmInUseList under the global list lock so these</span>
<span class="line-removed">- // will continue to be scanned.</span>
  //
<span class="line-modified">! // We currently call omFlush() from Threads::remove() _before the thread</span>
<span class="line-modified">! // has been excised from the thread list and is no longer a mutator.</span>
<span class="line-modified">! // This means that omFlush() cannot run concurrently with a safepoint and</span>
<span class="line-modified">! // interleave with the deflate_idle_monitors scavenge operator. In particular,</span>
<span class="line-modified">! // this ensures that the thread&#39;s monitors are scanned by a GC safepoint,</span>
<span class="line-modified">! // either via Thread::oops_do() (if safepoint happens before omFlush()) or via</span>
<span class="line-modified">! // ObjectSynchronizer::oops_do() (if it happens after omFlush() and the thread&#39;s</span>
<span class="line-modified">! // monitors have been transferred to the global in-use list).</span>
<span class="line-modified">! </span>
<span class="line-modified">! void ObjectSynchronizer::omFlush(Thread * Self) {</span>
<span class="line-modified">!   ObjectMonitor * list = Self-&gt;omFreeList;  // Null-terminated SLL</span>
<span class="line-modified">!   ObjectMonitor * tail = NULL;</span>
<span class="line-modified">!   int tally = 0;</span>
<span class="line-modified">!   if (list != NULL) {</span>
<span class="line-modified">!     ObjectMonitor * s;</span>
<span class="line-modified">!     // The thread is going away, the per-thread free monitors</span>
<span class="line-modified">!     // are freed via set_owner(NULL)</span>
<span class="line-modified">!     // Link them to tail, which will be linked into the global free list</span>
<span class="line-modified">!     // gFreeList below, under the gListLock</span>
<span class="line-modified">!     for (s = list; s != NULL; s = s-&gt;FreeNext) {</span>
<span class="line-modified">!       tally++;</span>
<span class="line-modified">!       tail = s;</span>
<span class="line-modified">!       guarantee(s-&gt;object() == NULL, &quot;invariant&quot;);</span>
<span class="line-modified">!       guarantee(!s-&gt;is_busy(), &quot;invariant&quot;);</span>
<span class="line-modified">!       s-&gt;set_owner(NULL);   // redundant but good hygiene</span>
      }
<span class="line-modified">!     guarantee(tail != NULL, &quot;invariant&quot;);</span>
<span class="line-modified">!     assert(Self-&gt;omFreeCount == tally, &quot;free-count off&quot;);</span>
<span class="line-modified">!     Self-&gt;omFreeList = NULL;</span>
<span class="line-modified">!     Self-&gt;omFreeCount = 0;</span>
<span class="line-modified">!   }</span>
<span class="line-modified">! </span>
<span class="line-modified">!   ObjectMonitor * inUseList = Self-&gt;omInUseList;</span>
<span class="line-modified">!   ObjectMonitor * inUseTail = NULL;</span>
<span class="line-modified">!   int inUseTally = 0;</span>
<span class="line-modified">!   if (inUseList != NULL) {</span>
<span class="line-modified">!     ObjectMonitor *cur_om;</span>
<span class="line-modified">!     // The thread is going away, however the omInUseList inflated</span>
<span class="line-modified">!     // monitors may still be in-use by other threads.</span>
<span class="line-modified">!     // Link them to inUseTail, which will be linked into the global in-use list</span>
<span class="line-modified">!     // gOmInUseList below, under the gListLock</span>
<span class="line-modified">!     for (cur_om = inUseList; cur_om != NULL; cur_om = cur_om-&gt;FreeNext) {</span>
<span class="line-modified">!       inUseTail = cur_om;</span>
<span class="line-modified">!       inUseTally++;</span>
      }
<span class="line-modified">!     guarantee(inUseTail != NULL, &quot;invariant&quot;);</span>
<span class="line-modified">!     assert(Self-&gt;omInUseCount == inUseTally, &quot;in-use count off&quot;);</span>
<span class="line-modified">!     Self-&gt;omInUseList = NULL;</span>
<span class="line-modified">!     Self-&gt;omInUseCount = 0;</span>
    }
  
<span class="line-modified">!   Thread::muxAcquire(&amp;gListLock, &quot;omFlush&quot;);</span>
<span class="line-modified">!   if (tail != NULL) {</span>
<span class="line-removed">-     tail-&gt;FreeNext = gFreeList;</span>
<span class="line-removed">-     gFreeList = list;</span>
<span class="line-removed">-     gMonitorFreeCount += tally;</span>
    }
  
<span class="line-modified">!   if (inUseTail != NULL) {</span>
<span class="line-modified">!     inUseTail-&gt;FreeNext = gOmInUseList;</span>
<span class="line-removed">-     gOmInUseList = inUseList;</span>
<span class="line-removed">-     gOmInUseCount += inUseTally;</span>
    }
  
<span class="line-modified">!   Thread::muxRelease(&amp;gListLock);</span>
  }
  
  static void post_monitor_inflate_event(EventJavaMonitorInflate* event,
                                         const oop obj,
                                         ObjectSynchronizer::InflateCause cause) {
<span class="line-new-header">--- 1280,344 ---</span>
  // type of limit.  Beware that if MonitorBound is set to too low a value
  // we could just loop. In addition, if MonitorBound is set to a low value
  // we&#39;ll incur more safepoints, which are harmful to performance.
  // See also: GuaranteedSafepointInterval
  //
<span class="line-modified">! // If MonitorBound is set, the boundry applies to</span>
<span class="line-added">+ //     (om_list_globals._population - om_list_globals._free_count)</span>
<span class="line-added">+ // i.e., if there are not enough ObjectMonitors on the global free list,</span>
<span class="line-added">+ // then a safepoint deflation is induced. Picking a good MonitorBound value</span>
<span class="line-added">+ // is non-trivial.</span>
  
<span class="line-modified">! static void InduceScavenge(Thread* self, const char * Whence) {</span>
    // Induce STW safepoint to trim monitors
    // Ultimately, this results in a call to deflate_idle_monitors() in the near future.
<span class="line-modified">!   // More precisely, trigger a cleanup safepoint as the number</span>
    // of active monitors passes the specified threshold.
    // TODO: assert thread state is reasonable
  
<span class="line-modified">!   if (Atomic::xchg(&amp;_forceMonitorScavenge, 1) == 0) {</span>
<span class="line-modified">!     VMThread::check_for_forced_cleanup();</span>
    }
  }
  
<span class="line-modified">! ObjectMonitor* ObjectSynchronizer::om_alloc(Thread* self) {</span>
    // A large MAXPRIVATE value reduces both list lock contention
    // and list coherency traffic, but also tends to increase the
<span class="line-modified">!   // number of ObjectMonitors in circulation as well as the STW</span>
    // scavenge costs.  As usual, we lean toward time in space-time
    // tradeoffs.
    const int MAXPRIVATE = 1024;
<span class="line-added">+   NoSafepointVerifier nsv;</span>
<span class="line-added">+ </span>
<span class="line-added">+   stringStream ss;</span>
    for (;;) {
<span class="line-modified">!     ObjectMonitor* m;</span>
  
<span class="line-modified">!     // 1: try to allocate from the thread&#39;s local om_free_list.</span>
      // Threads will attempt to allocate first from their local list, then
<span class="line-modified">!     // from the global list, and only after those attempts fail will the</span>
<span class="line-modified">!     // thread attempt to instantiate new monitors. Thread-local free lists</span>
<span class="line-modified">!     // improve allocation latency, as well as reducing coherency traffic</span>
<span class="line-modified">!     // on the shared global list.</span>
<span class="line-modified">!     m = take_from_start_of_om_free_list(self);</span>
      if (m != NULL) {
<span class="line-modified">!       guarantee(m-&gt;object() == NULL, &quot;invariant&quot;);</span>
        prepend_to_om_in_use_list(self, m);
        return m;
      }
  
<span class="line-modified">!     // 2: try to allocate from the global om_list_globals._free_list</span>
      // If we&#39;re using thread-local free lists then try
      // to reprovision the caller&#39;s free list.
<span class="line-modified">!     if (Atomic::load(&amp;om_list_globals._free_list) != NULL) {</span>
<span class="line-modified">!       // Reprovision the thread&#39;s om_free_list.</span>
        // Use bulk transfers to reduce the allocation rate and heat
        // on various locks.
<span class="line-modified">!       for (int i = self-&gt;om_free_provision; --i &gt;= 0;) {</span>
<span class="line-modified">!         ObjectMonitor* take = take_from_start_of_global_free_list();</span>
<span class="line-modified">!         if (take == NULL) {</span>
<span class="line-modified">!           break;  // No more are available.</span>
<span class="line-modified">!         }</span>
          guarantee(take-&gt;object() == NULL, &quot;invariant&quot;);
<span class="line-modified">!         take-&gt;Recycle();</span>
          om_release(self, take, false);
        }
<span class="line-modified">!       self-&gt;om_free_provision += 1 + (self-&gt;om_free_provision / 2);</span>
<span class="line-modified">!       if (self-&gt;om_free_provision &gt; MAXPRIVATE) self-&gt;om_free_provision = MAXPRIVATE;</span>
  
<span class="line-modified">!       if (is_MonitorBound_exceeded(Atomic::load(&amp;om_list_globals._population) -</span>
<span class="line-modified">!                                    Atomic::load(&amp;om_list_globals._free_count))) {</span>
<span class="line-modified">!         // Not enough ObjectMonitors on the global free list.</span>
<span class="line-added">+         // We can&#39;t safely induce a STW safepoint from om_alloc() as our thread</span>
          // state may not be appropriate for such activities and callers may hold
          // naked oops, so instead we defer the action.
<span class="line-modified">!         InduceScavenge(self, &quot;om_alloc&quot;);</span>
        }
        continue;
      }
  
      // 3: allocate a block of new ObjectMonitors
      // Both the local and global free lists are empty -- resort to malloc().
<span class="line-modified">!     // In the current implementation ObjectMonitors are TSM - immortal.</span>
      // Ideally, we&#39;d write &quot;new ObjectMonitor[_BLOCKSIZE], but we want
      // each ObjectMonitor to start at the beginning of a cache line,
      // so we use align_up().
      // A better solution would be to use C++ placement-new.
      // BEWARE: As it stands currently, we don&#39;t run the ctors!
      assert(_BLOCKSIZE &gt; 1, &quot;invariant&quot;);
<span class="line-modified">!     size_t neededsize = sizeof(PaddedObjectMonitor) * _BLOCKSIZE;</span>
<span class="line-modified">!     PaddedObjectMonitor* temp;</span>
<span class="line-modified">!     size_t aligned_size = neededsize + (OM_CACHE_LINE_SIZE - 1);</span>
<span class="line-modified">!     void* real_malloc_addr = NEW_C_HEAP_ARRAY(char, aligned_size, mtInternal);</span>
<span class="line-modified">!     temp = (PaddedObjectMonitor*)align_up(real_malloc_addr, OM_CACHE_LINE_SIZE);</span>
      (void)memset((void *) temp, 0, neededsize);
  
      // Format the block.
      // initialize the linked list, each monitor points to its next
      // forming the single linked free list, the very first monitor
      // will points to next block, which forms the block list.
<span class="line-modified">!     // The trick of using the 1st element in the block as g_block_list</span>
      // linkage should be reconsidered.  A better implementation would
      // look like: class Block { Block * next; int N; ObjectMonitor Body [N] ; }
  
      for (int i = 1; i &lt; _BLOCKSIZE; i++) {
<span class="line-modified">!       temp[i].set_next_om((ObjectMonitor*)&amp;temp[i + 1]);</span>
      }
  
      // terminate the last monitor as the end of list
<span class="line-modified">!     temp[_BLOCKSIZE - 1].set_next_om((ObjectMonitor*)NULL);</span>
  
      // Element [0] is reserved for global list linkage
      temp[0].set_object(CHAINMARKER);
  
      // Consider carving out this thread&#39;s current request from the
      // block in hand.  This avoids some lock traffic and redundant
      // list activity.
  
<span class="line-modified">!     prepend_block_to_lists(temp);</span>
    }
  }
  
<span class="line-modified">! // Place &quot;m&quot; on the caller&#39;s private per-thread om_free_list.</span>
  // In practice there&#39;s no need to clamp or limit the number of
<span class="line-modified">! // monitors on a thread&#39;s om_free_list as the only non-allocation time</span>
<span class="line-modified">! // we&#39;ll call om_release() is to return a monitor to the free list after</span>
<span class="line-modified">! // a CAS attempt failed. This doesn&#39;t allow unbounded #s of monitors to</span>
  // accumulate on a thread&#39;s free list.
  //
  // Key constraint: all ObjectMonitors on a thread&#39;s free list and the global
  // free list must have their object field set to null. This prevents the
<span class="line-modified">! // scavenger -- deflate_monitor_list() -- from reclaiming them while we</span>
<span class="line-added">+ // are trying to release them.</span>
  
<span class="line-modified">! void ObjectSynchronizer::om_release(Thread* self, ObjectMonitor* m,</span>
<span class="line-modified">!                                     bool from_per_thread_alloc) {</span>
<span class="line-modified">!   guarantee(m-&gt;header().value() == 0, &quot;invariant&quot;);</span>
    guarantee(m-&gt;object() == NULL, &quot;invariant&quot;);
<span class="line-modified">!   NoSafepointVerifier nsv;</span>
<span class="line-modified">! </span>
<span class="line-modified">!   stringStream ss;</span>
<span class="line-modified">!   guarantee((m-&gt;is_busy() | m-&gt;_recursions) == 0, &quot;freeing in-use monitor: &quot;</span>
<span class="line-modified">!             &quot;%s, recursions=&quot; INTX_FORMAT, m-&gt;is_busy_to_string(&amp;ss),</span>
<span class="line-modified">!             m-&gt;_recursions);</span>
<span class="line-modified">!   // _next_om is used for both per-thread in-use and free lists so</span>
<span class="line-modified">!   // we have to remove &#39;m&#39; from the in-use list first (as needed).</span>
<span class="line-modified">!   if (from_per_thread_alloc) {</span>
<span class="line-modified">!     // Need to remove &#39;m&#39; from om_in_use_list.</span>
<span class="line-modified">!     ObjectMonitor* mid = NULL;</span>
<span class="line-modified">!     ObjectMonitor* next = NULL;</span>
<span class="line-added">+ </span>
<span class="line-added">+     // This list walk can only race with another list walker since</span>
<span class="line-added">+     // deflation can only happen at a safepoint so we don&#39;t have to</span>
<span class="line-added">+     // worry about an ObjectMonitor being removed from this list</span>
<span class="line-added">+     // while we are walking it.</span>
<span class="line-added">+ </span>
<span class="line-added">+     // Lock the list head to avoid racing with another list walker.</span>
<span class="line-added">+     if ((mid = get_list_head_locked(&amp;self-&gt;om_in_use_list)) == NULL) {</span>
<span class="line-added">+       fatal(&quot;thread=&quot; INTPTR_FORMAT &quot; in-use list must not be empty.&quot;, p2i(self));</span>
<span class="line-added">+     }</span>
<span class="line-added">+     next = unmarked_next(mid);</span>
<span class="line-added">+     if (m == mid) {</span>
<span class="line-added">+       // First special case:</span>
<span class="line-added">+       // &#39;m&#39; matches mid, is the list head and is locked. Switch the list</span>
<span class="line-added">+       // head to next which unlocks the list head, but leaves the extracted</span>
<span class="line-added">+       // mid locked:</span>
<span class="line-added">+       Atomic::store(&amp;self-&gt;om_in_use_list, next);</span>
<span class="line-added">+     } else if (m == next) {</span>
<span class="line-added">+       // Second special case:</span>
<span class="line-added">+       // &#39;m&#39; matches next after the list head and we already have the list</span>
<span class="line-added">+       // head locked so set mid to what we are extracting:</span>
<span class="line-added">+       mid = next;</span>
<span class="line-added">+       // Lock mid to prevent races with a list walker:</span>
<span class="line-added">+       om_lock(mid);</span>
<span class="line-added">+       // Update next to what follows mid (if anything):</span>
<span class="line-added">+       next = unmarked_next(mid);</span>
<span class="line-added">+       // Switch next after the list head to new next which unlocks the</span>
<span class="line-added">+       // list head, but leaves the extracted mid locked:</span>
<span class="line-added">+       self-&gt;om_in_use_list-&gt;set_next_om(next);</span>
<span class="line-added">+     } else {</span>
<span class="line-added">+       // We have to search the list to find &#39;m&#39;.</span>
<span class="line-added">+       om_unlock(mid);  // unlock the list head</span>
<span class="line-added">+       guarantee(next != NULL, &quot;thread=&quot; INTPTR_FORMAT &quot;: om_in_use_list=&quot; INTPTR_FORMAT</span>
<span class="line-added">+                 &quot; is too short.&quot;, p2i(self), p2i(self-&gt;om_in_use_list));</span>
<span class="line-added">+       // Our starting anchor is next after the list head which is the</span>
<span class="line-added">+       // last ObjectMonitor we checked:</span>
<span class="line-added">+       ObjectMonitor* anchor = next;</span>
<span class="line-added">+       while ((mid = unmarked_next(anchor)) != NULL) {</span>
<span class="line-added">+         if (m == mid) {</span>
<span class="line-added">+           // We found &#39;m&#39; on the per-thread in-use list so extract it.</span>
<span class="line-added">+           om_lock(anchor);  // Lock the anchor so we can safely modify it.</span>
<span class="line-added">+           // Update next to what follows mid (if anything):</span>
<span class="line-added">+           next = unmarked_next(mid);</span>
<span class="line-added">+           // Switch next after the anchor to new next which unlocks the</span>
<span class="line-added">+           // anchor, but leaves the extracted mid locked:</span>
<span class="line-added">+           anchor-&gt;set_next_om(next);</span>
<span class="line-added">+           break;</span>
<span class="line-added">+         } else {</span>
<span class="line-added">+           anchor = mid;</span>
          }
        }
      }
<span class="line-modified">! </span>
<span class="line-added">+     if (mid == NULL) {</span>
<span class="line-added">+       // Reached end of the list and didn&#39;t find &#39;m&#39; so:</span>
<span class="line-added">+       fatal(&quot;thread=&quot; INTPTR_FORMAT &quot; must find m=&quot; INTPTR_FORMAT &quot;on om_in_use_list=&quot;</span>
<span class="line-added">+             INTPTR_FORMAT, p2i(self), p2i(m), p2i(self-&gt;om_in_use_list));</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     // At this point mid is disconnected from the in-use list so</span>
<span class="line-added">+     // its lock no longer has any effects on the in-use list.</span>
<span class="line-added">+     Atomic::dec(&amp;self-&gt;om_in_use_count);</span>
<span class="line-added">+     // Unlock mid, but leave the next value for any lagging list</span>
<span class="line-added">+     // walkers. It will get cleaned up when mid is prepended to</span>
<span class="line-added">+     // the thread&#39;s free list:</span>
<span class="line-added">+     om_unlock(mid);</span>
    }
  
<span class="line-modified">!   prepend_to_om_free_list(self, m);</span>
  }
  
<span class="line-modified">! // Return ObjectMonitors on a moribund thread&#39;s free and in-use</span>
<span class="line-modified">! // lists to the appropriate global lists. The ObjectMonitors on the</span>
<span class="line-modified">! // per-thread in-use list may still be in use by other threads.</span>
  //
<span class="line-modified">! // We currently call om_flush() from Threads::remove() before the</span>
<span class="line-modified">! // thread has been excised from the thread list and is no longer a</span>
<span class="line-modified">! // mutator. This means that om_flush() cannot run concurrently with</span>
<span class="line-modified">! // a safepoint and interleave with deflate_idle_monitors(). In</span>
<span class="line-modified">! // particular, this ensures that the thread&#39;s in-use monitors are</span>
<span class="line-modified">! // scanned by a GC safepoint, either via Thread::oops_do() (before</span>
<span class="line-modified">! // om_flush() is called) or via ObjectSynchronizer::oops_do() (after</span>
<span class="line-modified">! // om_flush() is called).</span>
<span class="line-modified">! </span>
<span class="line-modified">! void ObjectSynchronizer::om_flush(Thread* self) {</span>
<span class="line-modified">!   // Process the per-thread in-use list first to be consistent.</span>
<span class="line-modified">!   int in_use_count = 0;</span>
<span class="line-modified">!   ObjectMonitor* in_use_list = NULL;</span>
<span class="line-modified">!   ObjectMonitor* in_use_tail = NULL;</span>
<span class="line-modified">!   NoSafepointVerifier nsv;</span>
<span class="line-modified">! </span>
<span class="line-modified">!   // This function can race with a list walker thread so we lock the</span>
<span class="line-modified">!   // list head to prevent confusion.</span>
<span class="line-modified">!   if ((in_use_list = get_list_head_locked(&amp;self-&gt;om_in_use_list)) != NULL) {</span>
<span class="line-modified">!     // At this point, we have locked the in-use list head so a racing</span>
<span class="line-modified">!     // thread cannot come in after us. However, a racing thread could</span>
<span class="line-modified">!     // be ahead of us; we&#39;ll detect that and delay to let it finish.</span>
<span class="line-modified">!     //</span>
<span class="line-modified">!     // The thread is going away, however the ObjectMonitors on the</span>
<span class="line-modified">!     // om_in_use_list may still be in-use by other threads. Link</span>
<span class="line-added">+     // them to in_use_tail, which will be linked into the global</span>
<span class="line-added">+     // in-use list (om_list_globals._in_use_list) below.</span>
<span class="line-added">+     //</span>
<span class="line-added">+     // Account for the in-use list head before the loop since it is</span>
<span class="line-added">+     // already locked (by this thread):</span>
<span class="line-added">+     in_use_tail = in_use_list;</span>
<span class="line-added">+     in_use_count++;</span>
<span class="line-added">+     for (ObjectMonitor* cur_om = unmarked_next(in_use_list); cur_om != NULL; cur_om = unmarked_next(cur_om)) {</span>
<span class="line-added">+       if (is_locked(cur_om)) {</span>
<span class="line-added">+         // cur_om is locked so there must be a racing walker thread ahead</span>
<span class="line-added">+         // of us so we&#39;ll give it a chance to finish.</span>
<span class="line-added">+         while (is_locked(cur_om)) {</span>
<span class="line-added">+           os::naked_short_sleep(1);</span>
<span class="line-added">+         }</span>
<span class="line-added">+       }</span>
<span class="line-added">+       in_use_tail = cur_om;</span>
<span class="line-added">+       in_use_count++;</span>
      }
<span class="line-modified">!     guarantee(in_use_tail != NULL, &quot;invariant&quot;);</span>
<span class="line-modified">!     int l_om_in_use_count = Atomic::load(&amp;self-&gt;om_in_use_count);</span>
<span class="line-modified">!     assert(l_om_in_use_count == in_use_count, &quot;in-use counts don&#39;t match: &quot;</span>
<span class="line-modified">!           &quot;l_om_in_use_count=%d, in_use_count=%d&quot;, l_om_in_use_count, in_use_count);</span>
<span class="line-modified">!     Atomic::store(&amp;self-&gt;om_in_use_count, 0);</span>
<span class="line-modified">!     // Clear the in-use list head (which also unlocks it):</span>
<span class="line-modified">!     Atomic::store(&amp;self-&gt;om_in_use_list, (ObjectMonitor*)NULL);</span>
<span class="line-modified">!     om_unlock(in_use_list);</span>
<span class="line-modified">!   }</span>
<span class="line-modified">! </span>
<span class="line-modified">!   int free_count = 0;</span>
<span class="line-modified">!   ObjectMonitor* free_list = NULL;</span>
<span class="line-modified">!   ObjectMonitor* free_tail = NULL;</span>
<span class="line-modified">!   // This function can race with a list walker thread so we lock the</span>
<span class="line-modified">!   // list head to prevent confusion.</span>
<span class="line-modified">!   if ((free_list = get_list_head_locked(&amp;self-&gt;om_free_list)) != NULL) {</span>
<span class="line-modified">!     // At this point, we have locked the free list head so a racing</span>
<span class="line-modified">!     // thread cannot come in after us. However, a racing thread could</span>
<span class="line-added">+     // be ahead of us; we&#39;ll detect that and delay to let it finish.</span>
<span class="line-added">+     //</span>
<span class="line-added">+     // The thread is going away. Set &#39;free_tail&#39; to the last per-thread free</span>
<span class="line-added">+     // monitor which will be linked to om_list_globals._free_list below.</span>
<span class="line-added">+     //</span>
<span class="line-added">+     // Account for the free list head before the loop since it is</span>
<span class="line-added">+     // already locked (by this thread):</span>
<span class="line-added">+     free_tail = free_list;</span>
<span class="line-added">+     free_count++;</span>
<span class="line-added">+     for (ObjectMonitor* s = unmarked_next(free_list); s != NULL; s = unmarked_next(s)) {</span>
<span class="line-added">+       if (is_locked(s)) {</span>
<span class="line-added">+         // s is locked so there must be a racing walker thread ahead</span>
<span class="line-added">+         // of us so we&#39;ll give it a chance to finish.</span>
<span class="line-added">+         while (is_locked(s)) {</span>
<span class="line-added">+           os::naked_short_sleep(1);</span>
<span class="line-added">+         }</span>
<span class="line-added">+       }</span>
<span class="line-added">+       free_tail = s;</span>
<span class="line-added">+       free_count++;</span>
<span class="line-added">+       guarantee(s-&gt;object() == NULL, &quot;invariant&quot;);</span>
<span class="line-added">+       stringStream ss;</span>
<span class="line-added">+       guarantee(!s-&gt;is_busy(), &quot;must be !is_busy: %s&quot;, s-&gt;is_busy_to_string(&amp;ss));</span>
      }
<span class="line-modified">!     guarantee(free_tail != NULL, &quot;invariant&quot;);</span>
<span class="line-modified">!     int l_om_free_count = Atomic::load(&amp;self-&gt;om_free_count);</span>
<span class="line-modified">!     assert(l_om_free_count == free_count, &quot;free counts don&#39;t match: &quot;</span>
<span class="line-modified">!            &quot;l_om_free_count=%d, free_count=%d&quot;, l_om_free_count, free_count);</span>
<span class="line-added">+     Atomic::store(&amp;self-&gt;om_free_count, 0);</span>
<span class="line-added">+     Atomic::store(&amp;self-&gt;om_free_list, (ObjectMonitor*)NULL);</span>
<span class="line-added">+     om_unlock(free_list);</span>
    }
  
<span class="line-modified">!   if (free_tail != NULL) {</span>
<span class="line-modified">!     prepend_list_to_global_free_list(free_list, free_tail, free_count);</span>
    }
  
<span class="line-modified">!   if (in_use_tail != NULL) {</span>
<span class="line-modified">!     prepend_list_to_global_in_use_list(in_use_list, in_use_tail, in_use_count);</span>
    }
  
<span class="line-modified">!   LogStreamHandle(Debug, monitorinflation) lsh_debug;</span>
<span class="line-added">+   LogStreamHandle(Info, monitorinflation) lsh_info;</span>
<span class="line-added">+   LogStream* ls = NULL;</span>
<span class="line-added">+   if (log_is_enabled(Debug, monitorinflation)) {</span>
<span class="line-added">+     ls = &amp;lsh_debug;</span>
<span class="line-added">+   } else if ((free_count != 0 || in_use_count != 0) &amp;&amp;</span>
<span class="line-added">+              log_is_enabled(Info, monitorinflation)) {</span>
<span class="line-added">+     ls = &amp;lsh_info;</span>
<span class="line-added">+   }</span>
<span class="line-added">+   if (ls != NULL) {</span>
<span class="line-added">+     ls-&gt;print_cr(&quot;om_flush: jt=&quot; INTPTR_FORMAT &quot;, free_count=%d&quot;</span>
<span class="line-added">+                  &quot;, in_use_count=%d&quot; &quot;, om_free_provision=%d&quot;,</span>
<span class="line-added">+                  p2i(self), free_count, in_use_count, self-&gt;om_free_provision);</span>
<span class="line-added">+   }</span>
  }
  
  static void post_monitor_inflate_event(EventJavaMonitorInflate* event,
                                         const oop obj,
                                         ObjectSynchronizer::InflateCause cause) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1311,58 ***</span>
    event-&gt;commit();
  }
  
  // Fast path code shared by multiple functions
  void ObjectSynchronizer::inflate_helper(oop obj) {
<span class="line-modified">!   markOop mark = obj-&gt;mark();</span>
<span class="line-modified">!   if (mark-&gt;has_monitor()) {</span>
<span class="line-modified">!     assert(ObjectSynchronizer::verify_objmon_isinpool(mark-&gt;monitor()), &quot;monitor is invalid&quot;);</span>
<span class="line-modified">!     assert(mark-&gt;monitor()-&gt;header()-&gt;is_neutral(), &quot;monitor must record a good object header&quot;);</span>
      return;
    }
    inflate(Thread::current(), obj, inflate_cause_vm_internal);
  }
  
<span class="line-modified">! ObjectMonitor* ObjectSynchronizer::inflate(Thread * Self,</span>
<span class="line-modified">!                                            oop object,</span>
<span class="line-removed">-                                            const InflateCause cause) {</span>
    // Inflate mutates the heap ...
    // Relaxing assertion for bug 6320749.
    assert(Universe::verify_in_progress() ||
           !SafepointSynchronize::is_at_safepoint(), &quot;invariant&quot;);
  
    EventJavaMonitorInflate event;
  
    for (;;) {
<span class="line-modified">!     const markOop mark = object-&gt;mark();</span>
<span class="line-modified">!     assert(!mark-&gt;has_bias_pattern(), &quot;invariant&quot;);</span>
  
      // The mark can be in one of the following states:
      // *  Inflated     - just return
      // *  Stack-locked - coerce it to inflated
      // *  INFLATING    - busy wait for conversion to complete
      // *  Neutral      - aggressively inflate the object.
      // *  BIASED       - Illegal.  We should never see this
  
      // CASE: inflated
<span class="line-modified">!     if (mark-&gt;has_monitor()) {</span>
<span class="line-modified">!       ObjectMonitor * inf = mark-&gt;monitor();</span>
<span class="line-modified">!       markOop dmw = inf-&gt;header();</span>
<span class="line-modified">!       assert(dmw-&gt;is_neutral(), &quot;invariant: header=&quot; INTPTR_FORMAT, p2i((address)dmw));</span>
<span class="line-modified">!       assert(oopDesc::equals((oop) inf-&gt;object(), object), &quot;invariant&quot;);</span>
        assert(ObjectSynchronizer::verify_objmon_isinpool(inf), &quot;monitor is invalid&quot;);
        return inf;
      }
  
      // CASE: inflation in progress - inflating over a stack-lock.
      // Some other thread is converting from stack-locked to inflated.
      // Only that thread can complete inflation -- other threads must wait.
      // The INFLATING value is transient.
      // Currently, we spin/yield/park and poll the markword, waiting for inflation to finish.
      // We could always eliminate polling by parking the thread on some auxiliary list.
<span class="line-modified">!     if (mark == markOopDesc::INFLATING()) {</span>
<span class="line-modified">!       ReadStableMark(object);</span>
        continue;
      }
  
      // CASE: stack-locked
      // Could be stack-locked either by this thread or by some other thread.
<span class="line-new-header">--- 1629,57 ---</span>
    event-&gt;commit();
  }
  
  // Fast path code shared by multiple functions
  void ObjectSynchronizer::inflate_helper(oop obj) {
<span class="line-modified">!   markWord mark = obj-&gt;mark();</span>
<span class="line-modified">!   if (mark.has_monitor()) {</span>
<span class="line-modified">!     assert(ObjectSynchronizer::verify_objmon_isinpool(mark.monitor()), &quot;monitor is invalid&quot;);</span>
<span class="line-modified">!     assert(mark.monitor()-&gt;header().is_neutral(), &quot;monitor must record a good object header&quot;);</span>
      return;
    }
    inflate(Thread::current(), obj, inflate_cause_vm_internal);
  }
  
<span class="line-modified">! ObjectMonitor* ObjectSynchronizer::inflate(Thread* self,</span>
<span class="line-modified">!                                            oop object, const InflateCause cause) {</span>
    // Inflate mutates the heap ...
    // Relaxing assertion for bug 6320749.
    assert(Universe::verify_in_progress() ||
           !SafepointSynchronize::is_at_safepoint(), &quot;invariant&quot;);
  
    EventJavaMonitorInflate event;
  
    for (;;) {
<span class="line-modified">!     const markWord mark = object-&gt;mark();</span>
<span class="line-modified">!     assert(!mark.has_bias_pattern(), &quot;invariant&quot;);</span>
  
      // The mark can be in one of the following states:
      // *  Inflated     - just return
      // *  Stack-locked - coerce it to inflated
      // *  INFLATING    - busy wait for conversion to complete
      // *  Neutral      - aggressively inflate the object.
      // *  BIASED       - Illegal.  We should never see this
  
      // CASE: inflated
<span class="line-modified">!     if (mark.has_monitor()) {</span>
<span class="line-modified">!       ObjectMonitor* inf = mark.monitor();</span>
<span class="line-modified">!       markWord dmw = inf-&gt;header();</span>
<span class="line-modified">!       assert(dmw.is_neutral(), &quot;invariant: header=&quot; INTPTR_FORMAT, dmw.value());</span>
<span class="line-modified">!       assert(inf-&gt;object() == object, &quot;invariant&quot;);</span>
        assert(ObjectSynchronizer::verify_objmon_isinpool(inf), &quot;monitor is invalid&quot;);
        return inf;
      }
  
      // CASE: inflation in progress - inflating over a stack-lock.
      // Some other thread is converting from stack-locked to inflated.
      // Only that thread can complete inflation -- other threads must wait.
      // The INFLATING value is transient.
      // Currently, we spin/yield/park and poll the markword, waiting for inflation to finish.
      // We could always eliminate polling by parking the thread on some auxiliary list.
<span class="line-modified">!     if (mark == markWord::INFLATING()) {</span>
<span class="line-modified">!       read_stable_mark(object);</span>
        continue;
      }
  
      // CASE: stack-locked
      // Could be stack-locked either by this thread or by some other thread.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1377,29 ***</span>
      // We now use per-thread private objectmonitor free lists.
      // These list are reprovisioned from the global free list outside the
      // critical INFLATING...ST interval.  A thread can transfer
      // multiple objectmonitors en-mass from the global free list to its local free list.
      // This reduces coherency traffic and lock contention on the global free list.
<span class="line-modified">!     // Using such local free lists, it doesn&#39;t matter if the omAlloc() call appears</span>
      // before or after the CAS(INFLATING) operation.
<span class="line-modified">!     // See the comments in omAlloc().</span>
  
      LogStreamHandle(Trace, monitorinflation) lsh;
  
<span class="line-modified">!     if (mark-&gt;has_locker()) {</span>
<span class="line-modified">!       ObjectMonitor * m = omAlloc(Self);</span>
        // Optimistically prepare the objectmonitor - anticipate successful CAS
        // We do this before the CAS in order to minimize the length of time
        // in which INFLATING appears in the mark.
        m-&gt;Recycle();
        m-&gt;_Responsible  = NULL;
<span class="line-removed">-       m-&gt;_recursions   = 0;</span>
        m-&gt;_SpinDuration = ObjectMonitor::Knob_SpinLimit;   // Consider: maintain by type/class
  
<span class="line-modified">!       markOop cmp = object-&gt;cas_set_mark(markOopDesc::INFLATING(), mark);</span>
        if (cmp != mark) {
<span class="line-modified">!         omRelease(Self, m, true);</span>
          continue;       // Interference -- just retry
        }
  
        // We&#39;ve successfully installed INFLATING (0) into the mark-word.
        // This is the only case where 0 will appear in a mark-word.
<span class="line-new-header">--- 1694,28 ---</span>
      // We now use per-thread private objectmonitor free lists.
      // These list are reprovisioned from the global free list outside the
      // critical INFLATING...ST interval.  A thread can transfer
      // multiple objectmonitors en-mass from the global free list to its local free list.
      // This reduces coherency traffic and lock contention on the global free list.
<span class="line-modified">!     // Using such local free lists, it doesn&#39;t matter if the om_alloc() call appears</span>
      // before or after the CAS(INFLATING) operation.
<span class="line-modified">!     // See the comments in om_alloc().</span>
  
      LogStreamHandle(Trace, monitorinflation) lsh;
  
<span class="line-modified">!     if (mark.has_locker()) {</span>
<span class="line-modified">!       ObjectMonitor* m = om_alloc(self);</span>
        // Optimistically prepare the objectmonitor - anticipate successful CAS
        // We do this before the CAS in order to minimize the length of time
        // in which INFLATING appears in the mark.
        m-&gt;Recycle();
        m-&gt;_Responsible  = NULL;
        m-&gt;_SpinDuration = ObjectMonitor::Knob_SpinLimit;   // Consider: maintain by type/class
  
<span class="line-modified">!       markWord cmp = object-&gt;cas_set_mark(markWord::INFLATING(), mark);</span>
        if (cmp != mark) {
<span class="line-modified">!         om_release(self, m, true);</span>
          continue;       // Interference -- just retry
        }
  
        // We&#39;ve successfully installed INFLATING (0) into the mark-word.
        // This is the only case where 0 will appear in a mark-word.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1408,92 ***</span>
        //
        // Why do we CAS a 0 into the mark-word instead of just CASing the
        // mark-word from the stack-locked value directly to the new inflated state?
        // Consider what happens when a thread unlocks a stack-locked object.
        // It attempts to use CAS to swing the displaced header value from the
<span class="line-modified">!       // on-stack basiclock back into the object header.  Recall also that the</span>
<span class="line-modified">!       // header value (hashcode, etc) can reside in (a) the object header, or</span>
        // (b) a displaced header associated with the stack-lock, or (c) a displaced
<span class="line-modified">!       // header in an objectMonitor.  The inflate() routine must copy the header</span>
<span class="line-modified">!       // value from the basiclock on the owner&#39;s stack to the objectMonitor, all</span>
        // the while preserving the hashCode stability invariants.  If the owner
        // decides to release the lock while the value is 0, the unlock will fail
        // and control will eventually pass from slow_exit() to inflate.  The owner
        // will then spin, waiting for the 0 value to disappear.   Put another way,
        // the 0 causes the owner to stall if the owner happens to try to
<span class="line-modified">!       // drop the lock (restoring the header from the basiclock to the object)</span>
        // while inflation is in-progress.  This protocol avoids races that might
        // would otherwise permit hashCode values to change or &quot;flicker&quot; for an object.
<span class="line-modified">!       // Critically, while object-&gt;mark is 0 mark-&gt;displaced_mark_helper() is stable.</span>
        // 0 serves as a &quot;BUSY&quot; inflate-in-progress indicator.
  
  
        // fetch the displaced mark from the owner&#39;s stack.
        // The owner can&#39;t die or unwind past the lock while our INFLATING
        // object is in the mark.  Furthermore the owner can&#39;t complete
        // an unlock on the object, either.
<span class="line-modified">!       markOop dmw = mark-&gt;displaced_mark_helper();</span>
<span class="line-modified">!       assert(dmw-&gt;is_neutral(), &quot;invariant&quot;);</span>
  
        // Setup monitor fields to proper values -- prepare the monitor
        m-&gt;set_header(dmw);
  
<span class="line-modified">!       // Optimization: if the mark-&gt;locker stack address is associated</span>
<span class="line-modified">!       // with this thread we could simply set m-&gt;_owner = Self.</span>
        // Note that a thread can inflate an object
        // that it has stack-locked -- as might happen in wait() -- directly
        // with CAS.  That is, we can avoid the xchg-NULL .... ST idiom.
<span class="line-modified">!       m-&gt;set_owner(mark-&gt;locker());</span>
        m-&gt;set_object(object);
        // TODO-FIXME: assert BasicLock-&gt;dhw != 0.
  
        // Must preserve store ordering. The monitor state must
        // be stable at the time of publishing the monitor address.
<span class="line-modified">!       guarantee(object-&gt;mark() == markOopDesc::INFLATING(), &quot;invariant&quot;);</span>
<span class="line-modified">!       object-&gt;release_set_mark(markOopDesc::encode(m));</span>
  
        // Hopefully the performance counters are allocated on distinct cache lines
        // to avoid false sharing on MP systems ...
        OM_PERFDATA_OP(Inflations, inc());
        if (log_is_enabled(Trace, monitorinflation)) {
<span class="line-modified">!         ResourceMark rm(Self);</span>
          lsh.print_cr(&quot;inflate(has_locker): object=&quot; INTPTR_FORMAT &quot;, mark=&quot;
                       INTPTR_FORMAT &quot;, type=&#39;%s&#39;&quot;, p2i(object),
<span class="line-modified">!                      p2i(object-&gt;mark()), object-&gt;klass()-&gt;external_name());</span>
        }
        if (event.should_commit()) {
          post_monitor_inflate_event(&amp;event, object, cause);
        }
        return m;
      }
  
      // CASE: neutral
      // TODO-FIXME: for entry we currently inflate and then try to CAS _owner.
      // If we know we&#39;re inflating for entry it&#39;s better to inflate by swinging a
<span class="line-modified">!     // pre-locked objectMonitor pointer into the object header.   A successful</span>
      // CAS inflates the object *and* confers ownership to the inflating thread.
      // In the current implementation we use a 2-step mechanism where we CAS()
<span class="line-modified">!     // to inflate and then CAS() again to try to swing _owner from NULL to Self.</span>
<span class="line-modified">!     // An inflateTry() method that we could call from fast_enter() and slow_enter()</span>
<span class="line-removed">-     // would be useful.</span>
  
<span class="line-modified">!     assert(mark-&gt;is_neutral(), &quot;invariant&quot;);</span>
<span class="line-modified">!     ObjectMonitor * m = omAlloc(Self);</span>
      // prepare m for installation - set monitor to initial state
      m-&gt;Recycle();
      m-&gt;set_header(mark);
<span class="line-removed">-     m-&gt;set_owner(NULL);</span>
<span class="line-removed">-     m-&gt;set_object(object);</span>
      m-&gt;set_object(object);
      m-&gt;_Responsible  = NULL;
      m-&gt;_SpinDuration = ObjectMonitor::Knob_SpinLimit;       // consider: keep metastats by type/class
  
<span class="line-modified">!     if (object-&gt;cas_set_mark(markOopDesc::encode(m), mark) != mark) {</span>
<span class="line-modified">!       m-&gt;set_header(NULL);</span>
        m-&gt;set_object(NULL);
        m-&gt;Recycle();
<span class="line-modified">!       omRelease(Self, m, true);</span>
        m = NULL;
        continue;
        // interference - the markword changed - just retry.
        // The state-transitions are one-way, so there&#39;s no chance of
        // live-lock -- &quot;Inflated&quot; is an absorbing state.
<span class="line-new-header">--- 1724,93 ---</span>
        //
        // Why do we CAS a 0 into the mark-word instead of just CASing the
        // mark-word from the stack-locked value directly to the new inflated state?
        // Consider what happens when a thread unlocks a stack-locked object.
        // It attempts to use CAS to swing the displaced header value from the
<span class="line-modified">!       // on-stack BasicLock back into the object header.  Recall also that the</span>
<span class="line-modified">!       // header value (hash code, etc) can reside in (a) the object header, or</span>
        // (b) a displaced header associated with the stack-lock, or (c) a displaced
<span class="line-modified">!       // header in an ObjectMonitor.  The inflate() routine must copy the header</span>
<span class="line-modified">!       // value from the BasicLock on the owner&#39;s stack to the ObjectMonitor, all</span>
        // the while preserving the hashCode stability invariants.  If the owner
        // decides to release the lock while the value is 0, the unlock will fail
        // and control will eventually pass from slow_exit() to inflate.  The owner
        // will then spin, waiting for the 0 value to disappear.   Put another way,
        // the 0 causes the owner to stall if the owner happens to try to
<span class="line-modified">!       // drop the lock (restoring the header from the BasicLock to the object)</span>
        // while inflation is in-progress.  This protocol avoids races that might
        // would otherwise permit hashCode values to change or &quot;flicker&quot; for an object.
<span class="line-modified">!       // Critically, while object-&gt;mark is 0 mark.displaced_mark_helper() is stable.</span>
        // 0 serves as a &quot;BUSY&quot; inflate-in-progress indicator.
  
  
        // fetch the displaced mark from the owner&#39;s stack.
        // The owner can&#39;t die or unwind past the lock while our INFLATING
        // object is in the mark.  Furthermore the owner can&#39;t complete
        // an unlock on the object, either.
<span class="line-modified">!       markWord dmw = mark.displaced_mark_helper();</span>
<span class="line-modified">!       // Catch if the object&#39;s header is not neutral (not locked and</span>
<span class="line-added">+       // not marked is what we care about here).</span>
<span class="line-added">+       assert(dmw.is_neutral(), &quot;invariant: header=&quot; INTPTR_FORMAT, dmw.value());</span>
  
        // Setup monitor fields to proper values -- prepare the monitor
        m-&gt;set_header(dmw);
  
<span class="line-modified">!       // Optimization: if the mark.locker stack address is associated</span>
<span class="line-modified">!       // with this thread we could simply set m-&gt;_owner = self.</span>
        // Note that a thread can inflate an object
        // that it has stack-locked -- as might happen in wait() -- directly
        // with CAS.  That is, we can avoid the xchg-NULL .... ST idiom.
<span class="line-modified">!       m-&gt;set_owner_from(NULL, mark.locker());</span>
        m-&gt;set_object(object);
        // TODO-FIXME: assert BasicLock-&gt;dhw != 0.
  
        // Must preserve store ordering. The monitor state must
        // be stable at the time of publishing the monitor address.
<span class="line-modified">!       guarantee(object-&gt;mark() == markWord::INFLATING(), &quot;invariant&quot;);</span>
<span class="line-modified">!       object-&gt;release_set_mark(markWord::encode(m));</span>
  
        // Hopefully the performance counters are allocated on distinct cache lines
        // to avoid false sharing on MP systems ...
        OM_PERFDATA_OP(Inflations, inc());
        if (log_is_enabled(Trace, monitorinflation)) {
<span class="line-modified">!         ResourceMark rm(self);</span>
          lsh.print_cr(&quot;inflate(has_locker): object=&quot; INTPTR_FORMAT &quot;, mark=&quot;
                       INTPTR_FORMAT &quot;, type=&#39;%s&#39;&quot;, p2i(object),
<span class="line-modified">!                      object-&gt;mark().value(), object-&gt;klass()-&gt;external_name());</span>
        }
        if (event.should_commit()) {
          post_monitor_inflate_event(&amp;event, object, cause);
        }
        return m;
      }
  
      // CASE: neutral
      // TODO-FIXME: for entry we currently inflate and then try to CAS _owner.
      // If we know we&#39;re inflating for entry it&#39;s better to inflate by swinging a
<span class="line-modified">!     // pre-locked ObjectMonitor pointer into the object header.   A successful</span>
      // CAS inflates the object *and* confers ownership to the inflating thread.
      // In the current implementation we use a 2-step mechanism where we CAS()
<span class="line-modified">!     // to inflate and then CAS() again to try to swing _owner from NULL to self.</span>
<span class="line-modified">!     // An inflateTry() method that we could call from enter() would be useful.</span>
  
<span class="line-modified">!     // Catch if the object&#39;s header is not neutral (not locked and</span>
<span class="line-modified">!     // not marked is what we care about here).</span>
<span class="line-added">+     assert(mark.is_neutral(), &quot;invariant: header=&quot; INTPTR_FORMAT, mark.value());</span>
<span class="line-added">+     ObjectMonitor* m = om_alloc(self);</span>
      // prepare m for installation - set monitor to initial state
      m-&gt;Recycle();
      m-&gt;set_header(mark);
      m-&gt;set_object(object);
      m-&gt;_Responsible  = NULL;
      m-&gt;_SpinDuration = ObjectMonitor::Knob_SpinLimit;       // consider: keep metastats by type/class
  
<span class="line-modified">!     if (object-&gt;cas_set_mark(markWord::encode(m), mark) != mark) {</span>
<span class="line-modified">!       m-&gt;set_header(markWord::zero());</span>
        m-&gt;set_object(NULL);
        m-&gt;Recycle();
<span class="line-modified">!       om_release(self, m, true);</span>
        m = NULL;
        continue;
        // interference - the markword changed - just retry.
        // The state-transitions are one-way, so there&#39;s no chance of
        // live-lock -- &quot;Inflated&quot; is an absorbing state.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1501,183 ***</span>
  
      // Hopefully the performance counters are allocated on distinct
      // cache lines to avoid false sharing on MP systems ...
      OM_PERFDATA_OP(Inflations, inc());
      if (log_is_enabled(Trace, monitorinflation)) {
<span class="line-modified">!       ResourceMark rm(Self);</span>
        lsh.print_cr(&quot;inflate(neutral): object=&quot; INTPTR_FORMAT &quot;, mark=&quot;
                     INTPTR_FORMAT &quot;, type=&#39;%s&#39;&quot;, p2i(object),
<span class="line-modified">!                    p2i(object-&gt;mark()), object-&gt;klass()-&gt;external_name());</span>
      }
      if (event.should_commit()) {
        post_monitor_inflate_event(&amp;event, object, cause);
      }
      return m;
    }
  }
  
  
<span class="line-modified">! // We create a list of in-use monitors for each thread.</span>
  //
  // deflate_thread_local_monitors() scans a single thread&#39;s in-use list, while
  // deflate_idle_monitors() scans only a global list of in-use monitors which
<span class="line-modified">! // is populated only as a thread dies (see omFlush()).</span>
  //
  // These operations are called at all safepoints, immediately after mutators
  // are stopped, but before any objects have moved. Collectively they traverse
  // the population of in-use monitors, deflating where possible. The scavenged
<span class="line-modified">! // monitors are returned to the monitor free list.</span>
  //
  // Beware that we scavenge at *every* stop-the-world point. Having a large
  // number of monitors in-use could negatively impact performance. We also want
  // to minimize the total # of monitors in circulation, as they incur a small
  // footprint penalty.
  //
  // Perversely, the heap size -- and thus the STW safepoint rate --
  // typically drives the scavenge rate.  Large heaps can mean infrequent GC,
<span class="line-modified">! // which in turn can mean large(r) numbers of objectmonitors in circulation.</span>
  // This is an unfortunate aspect of this design.
  
  // Deflate a single monitor if not in-use
  // Return true if deflated, false if in-use
  bool ObjectSynchronizer::deflate_monitor(ObjectMonitor* mid, oop obj,
<span class="line-modified">!                                          ObjectMonitor** freeHeadp,</span>
<span class="line-modified">!                                          ObjectMonitor** freeTailp) {</span>
    bool deflated;
    // Normal case ... The monitor is associated with obj.
<span class="line-modified">!   guarantee(obj-&gt;mark() == markOopDesc::encode(mid), &quot;invariant&quot;);</span>
<span class="line-modified">!   guarantee(mid == obj-&gt;mark()-&gt;monitor(), &quot;invariant&quot;);</span>
<span class="line-modified">!   guarantee(mid-&gt;header()-&gt;is_neutral(), &quot;invariant&quot;);</span>
  
    if (mid-&gt;is_busy()) {
      deflated = false;
    } else {
      // Deflate the monitor if it is no longer being used
      // It&#39;s idle - scavenge and return to the global free list
      // plain old deflation ...
      if (log_is_enabled(Trace, monitorinflation)) {
        ResourceMark rm;
        log_trace(monitorinflation)(&quot;deflate_monitor: &quot;
<span class="line-modified">!                                   &quot;object=&quot; INTPTR_FORMAT &quot;, mark=&quot; INTPTR_FORMAT &quot;, type=&#39;%s&#39;&quot;,</span>
<span class="line-modified">!                                   p2i(obj), p2i(obj-&gt;mark()),</span>
<span class="line-modified">!                                   obj-&gt;klass()-&gt;external_name());</span>
      }
  
      // Restore the header back to obj
<span class="line-modified">!     obj-&gt;release_set_mark(mid-&gt;header());</span>
      mid-&gt;clear();
  
<span class="line-modified">!     assert(mid-&gt;object() == NULL, &quot;invariant&quot;);</span>
<span class="line-modified">! </span>
<span class="line-modified">!     // Move the object to the working free list defined by freeHeadp, freeTailp</span>
<span class="line-modified">!     if (*freeHeadp == NULL) *freeHeadp = mid;</span>
<span class="line-modified">!     if (*freeTailp != NULL) {</span>
<span class="line-modified">!       ObjectMonitor * prevtail = *freeTailp;</span>
<span class="line-modified">!       assert(prevtail-&gt;FreeNext == NULL, &quot;cleaned up deflated?&quot;);</span>
<span class="line-modified">!       prevtail-&gt;FreeNext = mid;</span>
      }
<span class="line-modified">!     *freeTailp = mid;</span>
      deflated = true;
    }
    return deflated;
  }
  
<span class="line-modified">! // Walk a given monitor list, and deflate idle monitors</span>
<span class="line-modified">! // The given list could be a per-thread list or a global list</span>
<span class="line-removed">- // Caller acquires gListLock as needed.</span>
  //
  // In the case of parallel processing of thread local monitor lists,
  // work is done by Threads::parallel_threads_do() which ensures that
  // each Java thread is processed by exactly one worker thread, and
  // thus avoid conflicts that would arise when worker threads would
  // process the same monitor lists concurrently.
  //
  // See also ParallelSPCleanupTask and
  // SafepointSynchronize::do_cleanup_tasks() in safepoint.cpp and
  // Threads::parallel_java_threads_do() in thread.cpp.
<span class="line-modified">! int ObjectSynchronizer::deflate_monitor_list(ObjectMonitor** listHeadp,</span>
<span class="line-modified">!                                              ObjectMonitor** freeHeadp,</span>
<span class="line-modified">!                                              ObjectMonitor** freeTailp) {</span>
<span class="line-modified">!   ObjectMonitor* mid;</span>
<span class="line-removed">-   ObjectMonitor* next;</span>
    ObjectMonitor* cur_mid_in_use = NULL;
    int deflated_count = 0;
  
<span class="line-modified">!   for (mid = *listHeadp; mid != NULL;) {</span>
      oop obj = (oop) mid-&gt;object();
<span class="line-modified">!     if (obj != NULL &amp;&amp; deflate_monitor(mid, obj, freeHeadp, freeTailp)) {</span>
<span class="line-modified">!       // if deflate_monitor succeeded,</span>
<span class="line-modified">!       // extract from per-thread in-use list</span>
<span class="line-modified">!       if (mid == *listHeadp) {</span>
<span class="line-modified">!         *listHeadp = mid-&gt;FreeNext;</span>
<span class="line-modified">!       } else if (cur_mid_in_use != NULL) {</span>
<span class="line-modified">!         cur_mid_in_use-&gt;FreeNext = mid-&gt;FreeNext; // maintain the current thread in-use list</span>
        }
<span class="line-modified">!       next = mid-&gt;FreeNext;</span>
<span class="line-removed">-       mid-&gt;FreeNext = NULL;  // This mid is current tail in the freeHeadp list</span>
<span class="line-removed">-       mid = next;</span>
        deflated_count++;
      } else {
        cur_mid_in_use = mid;
<span class="line-removed">-       mid = mid-&gt;FreeNext;</span>
      }
    }
    return deflated_count;
  }
  
  void ObjectSynchronizer::prepare_deflate_idle_monitors(DeflateMonitorCounters* counters) {
<span class="line-modified">!   counters-&gt;nInuse = 0;              // currently associated with objects</span>
<span class="line-modified">!   counters-&gt;nInCirculation = 0;      // extant</span>
<span class="line-modified">!   counters-&gt;nScavenged = 0;          // reclaimed (global and per-thread)</span>
<span class="line-modified">!   counters-&gt;perThreadScavenged = 0;  // per-thread scavenge total</span>
<span class="line-modified">!   counters-&gt;perThreadTimes = 0.0;    // per-thread scavenge times</span>
  }
  
  void ObjectSynchronizer::deflate_idle_monitors(DeflateMonitorCounters* counters) {
    assert(SafepointSynchronize::is_at_safepoint(), &quot;must be at safepoint&quot;);
    bool deflated = false;
  
<span class="line-modified">!   ObjectMonitor * freeHeadp = NULL;  // Local SLL of scavenged monitors</span>
<span class="line-modified">!   ObjectMonitor * freeTailp = NULL;</span>
    elapsedTimer timer;
  
    if (log_is_enabled(Info, monitorinflation)) {
      timer.start();
    }
  
<span class="line-removed">-   // Prevent omFlush from changing mids in Thread dtor&#39;s during deflation</span>
<span class="line-removed">-   // And in case the vm thread is acquiring a lock during a safepoint</span>
<span class="line-removed">-   // See e.g. 6320749</span>
<span class="line-removed">-   Thread::muxAcquire(&amp;gListLock, &quot;deflate_idle_monitors&quot;);</span>
<span class="line-removed">- </span>
    // Note: the thread-local monitors lists get deflated in
    // a separate pass. See deflate_thread_local_monitors().
  
<span class="line-modified">!   // For moribund threads, scan gOmInUseList</span>
    int deflated_count = 0;
<span class="line-modified">!   if (gOmInUseList) {</span>
<span class="line-modified">!     counters-&gt;nInCirculation += gOmInUseCount;</span>
<span class="line-modified">!     deflated_count = deflate_monitor_list((ObjectMonitor **)&amp;gOmInUseList, &amp;freeHeadp, &amp;freeTailp);</span>
<span class="line-modified">!     gOmInUseCount -= deflated_count;</span>
<span class="line-modified">!     counters-&gt;nScavenged += deflated_count;</span>
<span class="line-modified">!     counters-&gt;nInuse += gOmInUseCount;</span>
<span class="line-modified">!   }</span>
<span class="line-modified">! </span>
<span class="line-modified">!   // Move the scavenged monitors back to the global free list.</span>
<span class="line-modified">!   if (freeHeadp != NULL) {</span>
<span class="line-modified">!     guarantee(freeTailp != NULL &amp;&amp; counters-&gt;nScavenged &gt; 0, &quot;invariant&quot;);</span>
<span class="line-modified">!     assert(freeTailp-&gt;FreeNext == NULL, &quot;invariant&quot;);</span>
<span class="line-modified">!     // constant-time list splice - prepend scavenged segment to gFreeList</span>
<span class="line-modified">!     freeTailp-&gt;FreeNext = gFreeList;</span>
<span class="line-modified">!     gFreeList = freeHeadp;</span>
<span class="line-modified">!   }</span>
<span class="line-modified">!   Thread::muxRelease(&amp;gListLock);</span>
    timer.stop();
  
    LogStreamHandle(Debug, monitorinflation) lsh_debug;
    LogStreamHandle(Info, monitorinflation) lsh_info;
<span class="line-modified">!   LogStream * ls = NULL;</span>
    if (log_is_enabled(Debug, monitorinflation)) {
      ls = &amp;lsh_debug;
    } else if (deflated_count != 0 &amp;&amp; log_is_enabled(Info, monitorinflation)) {
      ls = &amp;lsh_info;
    }
<span class="line-new-header">--- 1818,212 ---</span>
  
      // Hopefully the performance counters are allocated on distinct
      // cache lines to avoid false sharing on MP systems ...
      OM_PERFDATA_OP(Inflations, inc());
      if (log_is_enabled(Trace, monitorinflation)) {
<span class="line-modified">!       ResourceMark rm(self);</span>
        lsh.print_cr(&quot;inflate(neutral): object=&quot; INTPTR_FORMAT &quot;, mark=&quot;
                     INTPTR_FORMAT &quot;, type=&#39;%s&#39;&quot;, p2i(object),
<span class="line-modified">!                    object-&gt;mark().value(), object-&gt;klass()-&gt;external_name());</span>
      }
      if (event.should_commit()) {
        post_monitor_inflate_event(&amp;event, object, cause);
      }
      return m;
    }
  }
  
  
<span class="line-modified">! // We maintain a list of in-use monitors for each thread.</span>
  //
  // deflate_thread_local_monitors() scans a single thread&#39;s in-use list, while
  // deflate_idle_monitors() scans only a global list of in-use monitors which
<span class="line-modified">! // is populated only as a thread dies (see om_flush()).</span>
  //
  // These operations are called at all safepoints, immediately after mutators
  // are stopped, but before any objects have moved. Collectively they traverse
  // the population of in-use monitors, deflating where possible. The scavenged
<span class="line-modified">! // monitors are returned to the global monitor free list.</span>
  //
  // Beware that we scavenge at *every* stop-the-world point. Having a large
  // number of monitors in-use could negatively impact performance. We also want
  // to minimize the total # of monitors in circulation, as they incur a small
  // footprint penalty.
  //
  // Perversely, the heap size -- and thus the STW safepoint rate --
  // typically drives the scavenge rate.  Large heaps can mean infrequent GC,
<span class="line-modified">! // which in turn can mean large(r) numbers of ObjectMonitors in circulation.</span>
  // This is an unfortunate aspect of this design.
  
  // Deflate a single monitor if not in-use
  // Return true if deflated, false if in-use
  bool ObjectSynchronizer::deflate_monitor(ObjectMonitor* mid, oop obj,
<span class="line-modified">!                                          ObjectMonitor** free_head_p,</span>
<span class="line-modified">!                                          ObjectMonitor** free_tail_p) {</span>
    bool deflated;
    // Normal case ... The monitor is associated with obj.
<span class="line-modified">!   const markWord mark = obj-&gt;mark();</span>
<span class="line-modified">!   guarantee(mark == markWord::encode(mid), &quot;should match: mark=&quot;</span>
<span class="line-modified">!             INTPTR_FORMAT &quot;, encoded mid=&quot; INTPTR_FORMAT, mark.value(),</span>
<span class="line-added">+             markWord::encode(mid).value());</span>
<span class="line-added">+   // Make sure that mark.monitor() and markWord::encode() agree:</span>
<span class="line-added">+   guarantee(mark.monitor() == mid, &quot;should match: monitor()=&quot; INTPTR_FORMAT</span>
<span class="line-added">+             &quot;, mid=&quot; INTPTR_FORMAT, p2i(mark.monitor()), p2i(mid));</span>
<span class="line-added">+   const markWord dmw = mid-&gt;header();</span>
<span class="line-added">+   guarantee(dmw.is_neutral(), &quot;invariant: header=&quot; INTPTR_FORMAT, dmw.value());</span>
  
    if (mid-&gt;is_busy()) {
<span class="line-added">+     // Easy checks are first - the ObjectMonitor is busy so no deflation.</span>
      deflated = false;
    } else {
      // Deflate the monitor if it is no longer being used
      // It&#39;s idle - scavenge and return to the global free list
      // plain old deflation ...
      if (log_is_enabled(Trace, monitorinflation)) {
        ResourceMark rm;
        log_trace(monitorinflation)(&quot;deflate_monitor: &quot;
<span class="line-modified">!                                   &quot;object=&quot; INTPTR_FORMAT &quot;, mark=&quot;</span>
<span class="line-modified">!                                   INTPTR_FORMAT &quot;, type=&#39;%s&#39;&quot;, p2i(obj),</span>
<span class="line-modified">!                                   mark.value(), obj-&gt;klass()-&gt;external_name());</span>
      }
  
      // Restore the header back to obj
<span class="line-modified">!     obj-&gt;release_set_mark(dmw);</span>
      mid-&gt;clear();
  
<span class="line-modified">!     assert(mid-&gt;object() == NULL, &quot;invariant: object=&quot; INTPTR_FORMAT,</span>
<span class="line-modified">!            p2i(mid-&gt;object()));</span>
<span class="line-modified">! </span>
<span class="line-modified">!     // Move the deflated ObjectMonitor to the working free list</span>
<span class="line-modified">!     // defined by free_head_p and free_tail_p.</span>
<span class="line-modified">!     if (*free_head_p == NULL) *free_head_p = mid;</span>
<span class="line-modified">!     if (*free_tail_p != NULL) {</span>
<span class="line-modified">!       // We append to the list so the caller can use mid-&gt;_next_om</span>
<span class="line-added">+       // to fix the linkages in its context.</span>
<span class="line-added">+       ObjectMonitor* prevtail = *free_tail_p;</span>
<span class="line-added">+       // Should have been cleaned up by the caller:</span>
<span class="line-added">+       // Note: Should not have to lock prevtail here since we&#39;re at a</span>
<span class="line-added">+       // safepoint and ObjectMonitors on the local free list should</span>
<span class="line-added">+       // not be accessed in parallel.</span>
<span class="line-added">+ #ifdef ASSERT</span>
<span class="line-added">+       ObjectMonitor* l_next_om = prevtail-&gt;next_om();</span>
<span class="line-added">+ #endif</span>
<span class="line-added">+       assert(l_next_om == NULL, &quot;must be NULL: _next_om=&quot; INTPTR_FORMAT, p2i(l_next_om));</span>
<span class="line-added">+       prevtail-&gt;set_next_om(mid);</span>
      }
<span class="line-modified">!     *free_tail_p = mid;</span>
<span class="line-added">+     // At this point, mid-&gt;_next_om still refers to its current</span>
<span class="line-added">+     // value and another ObjectMonitor&#39;s _next_om field still</span>
<span class="line-added">+     // refers to this ObjectMonitor. Those linkages have to be</span>
<span class="line-added">+     // cleaned up by the caller who has the complete context.</span>
      deflated = true;
    }
    return deflated;
  }
  
<span class="line-modified">! // Walk a given monitor list, and deflate idle monitors.</span>
<span class="line-modified">! // The given list could be a per-thread list or a global list.</span>
  //
  // In the case of parallel processing of thread local monitor lists,
  // work is done by Threads::parallel_threads_do() which ensures that
  // each Java thread is processed by exactly one worker thread, and
  // thus avoid conflicts that would arise when worker threads would
  // process the same monitor lists concurrently.
  //
  // See also ParallelSPCleanupTask and
  // SafepointSynchronize::do_cleanup_tasks() in safepoint.cpp and
  // Threads::parallel_java_threads_do() in thread.cpp.
<span class="line-modified">! int ObjectSynchronizer::deflate_monitor_list(ObjectMonitor** list_p,</span>
<span class="line-modified">!                                              int* count_p,</span>
<span class="line-modified">!                                              ObjectMonitor** free_head_p,</span>
<span class="line-modified">!                                              ObjectMonitor** free_tail_p) {</span>
    ObjectMonitor* cur_mid_in_use = NULL;
<span class="line-added">+   ObjectMonitor* mid = NULL;</span>
<span class="line-added">+   ObjectMonitor* next = NULL;</span>
    int deflated_count = 0;
  
<span class="line-modified">!   // This list walk executes at a safepoint and does not race with any</span>
<span class="line-added">+   // other list walkers.</span>
<span class="line-added">+ </span>
<span class="line-added">+   for (mid = Atomic::load(list_p); mid != NULL; mid = next) {</span>
<span class="line-added">+     next = unmarked_next(mid);</span>
      oop obj = (oop) mid-&gt;object();
<span class="line-modified">!     if (obj != NULL &amp;&amp; deflate_monitor(mid, obj, free_head_p, free_tail_p)) {</span>
<span class="line-modified">!       // Deflation succeeded and already updated free_head_p and</span>
<span class="line-modified">!       // free_tail_p as needed. Finish the move to the local free list</span>
<span class="line-modified">!       // by unlinking mid from the global or per-thread in-use list.</span>
<span class="line-modified">!       if (cur_mid_in_use == NULL) {</span>
<span class="line-modified">!         // mid is the list head so switch the list head to next:</span>
<span class="line-modified">!         Atomic::store(list_p, next);</span>
<span class="line-added">+       } else {</span>
<span class="line-added">+         // Switch cur_mid_in_use&#39;s next field to next:</span>
<span class="line-added">+         cur_mid_in_use-&gt;set_next_om(next);</span>
        }
<span class="line-modified">!       // At this point mid is disconnected from the in-use list.</span>
        deflated_count++;
<span class="line-added">+       Atomic::dec(count_p);</span>
<span class="line-added">+       // mid is current tail in the free_head_p list so NULL terminate it:</span>
<span class="line-added">+       mid-&gt;set_next_om(NULL);</span>
      } else {
        cur_mid_in_use = mid;
      }
    }
    return deflated_count;
  }
  
  void ObjectSynchronizer::prepare_deflate_idle_monitors(DeflateMonitorCounters* counters) {
<span class="line-modified">!   counters-&gt;n_in_use = 0;              // currently associated with objects</span>
<span class="line-modified">!   counters-&gt;n_in_circulation = 0;      // extant</span>
<span class="line-modified">!   counters-&gt;n_scavenged = 0;           // reclaimed (global and per-thread)</span>
<span class="line-modified">!   counters-&gt;per_thread_scavenged = 0;  // per-thread scavenge total</span>
<span class="line-modified">!   counters-&gt;per_thread_times = 0.0;    // per-thread scavenge times</span>
  }
  
  void ObjectSynchronizer::deflate_idle_monitors(DeflateMonitorCounters* counters) {
    assert(SafepointSynchronize::is_at_safepoint(), &quot;must be at safepoint&quot;);
    bool deflated = false;
  
<span class="line-modified">!   ObjectMonitor* free_head_p = NULL;  // Local SLL of scavenged monitors</span>
<span class="line-modified">!   ObjectMonitor* free_tail_p = NULL;</span>
    elapsedTimer timer;
  
    if (log_is_enabled(Info, monitorinflation)) {
      timer.start();
    }
  
    // Note: the thread-local monitors lists get deflated in
    // a separate pass. See deflate_thread_local_monitors().
  
<span class="line-modified">!   // For moribund threads, scan om_list_globals._in_use_list</span>
    int deflated_count = 0;
<span class="line-modified">!   if (Atomic::load(&amp;om_list_globals._in_use_list) != NULL) {</span>
<span class="line-modified">!     // Update n_in_circulation before om_list_globals._in_use_count is</span>
<span class="line-modified">!     // updated by deflation.</span>
<span class="line-modified">!     Atomic::add(&amp;counters-&gt;n_in_circulation,</span>
<span class="line-modified">!                 Atomic::load(&amp;om_list_globals._in_use_count));</span>
<span class="line-modified">! </span>
<span class="line-modified">!     deflated_count = deflate_monitor_list(&amp;om_list_globals._in_use_list,</span>
<span class="line-modified">!                                           &amp;om_list_globals._in_use_count,</span>
<span class="line-modified">!                                           &amp;free_head_p, &amp;free_tail_p);</span>
<span class="line-modified">!     Atomic::add(&amp;counters-&gt;n_in_use, Atomic::load(&amp;om_list_globals._in_use_count));</span>
<span class="line-modified">!   }</span>
<span class="line-modified">! </span>
<span class="line-modified">!   if (free_head_p != NULL) {</span>
<span class="line-modified">!     // Move the deflated ObjectMonitors back to the global free list.</span>
<span class="line-modified">!     guarantee(free_tail_p != NULL &amp;&amp; deflated_count &gt; 0, &quot;invariant&quot;);</span>
<span class="line-modified">! #ifdef ASSERT</span>
<span class="line-modified">!     ObjectMonitor* l_next_om = free_tail_p-&gt;next_om();</span>
<span class="line-added">+ #endif</span>
<span class="line-added">+     assert(l_next_om == NULL, &quot;must be NULL: _next_om=&quot; INTPTR_FORMAT, p2i(l_next_om));</span>
<span class="line-added">+     prepend_list_to_global_free_list(free_head_p, free_tail_p, deflated_count);</span>
<span class="line-added">+     Atomic::add(&amp;counters-&gt;n_scavenged, deflated_count);</span>
<span class="line-added">+   }</span>
    timer.stop();
  
    LogStreamHandle(Debug, monitorinflation) lsh_debug;
    LogStreamHandle(Info, monitorinflation) lsh_info;
<span class="line-modified">!   LogStream* ls = NULL;</span>
    if (log_is_enabled(Debug, monitorinflation)) {
      ls = &amp;lsh_debug;
    } else if (deflated_count != 0 &amp;&amp; log_is_enabled(Info, monitorinflation)) {
      ls = &amp;lsh_info;
    }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1689,78 ***</span>
  void ObjectSynchronizer::finish_deflate_idle_monitors(DeflateMonitorCounters* counters) {
    // Report the cumulative time for deflating each thread&#39;s idle
    // monitors. Note: if the work is split among more than one
    // worker thread, then the reported time will likely be more
    // than a beginning to end measurement of the phase.
<span class="line-modified">!   log_info(safepoint, cleanup)(&quot;deflating per-thread idle monitors, %3.7f secs, monitors=%d&quot;, counters-&gt;perThreadTimes, counters-&gt;perThreadScavenged);</span>
<span class="line-removed">- </span>
<span class="line-removed">-   LogStreamHandle(Debug, monitorinflation) lsh_debug;</span>
<span class="line-removed">-   LogStreamHandle(Info, monitorinflation) lsh_info;</span>
<span class="line-removed">-   LogStream * ls = NULL;</span>
<span class="line-removed">-   if (log_is_enabled(Debug, monitorinflation)) {</span>
<span class="line-removed">-     ls = &amp;lsh_debug;</span>
<span class="line-removed">-   } else if (counters-&gt;perThreadScavenged != 0 &amp;&amp; log_is_enabled(Info, monitorinflation)) {</span>
<span class="line-removed">-     ls = &amp;lsh_info;</span>
<span class="line-removed">-   }</span>
<span class="line-removed">-   if (ls != NULL) {</span>
<span class="line-removed">-     ls-&gt;print_cr(&quot;deflating per-thread idle monitors, %3.7f secs, %d monitors&quot;, counters-&gt;perThreadTimes, counters-&gt;perThreadScavenged);</span>
<span class="line-removed">-   }</span>
<span class="line-removed">- </span>
<span class="line-removed">-   gMonitorFreeCount += counters-&gt;nScavenged;</span>
  
    if (log_is_enabled(Debug, monitorinflation)) {
      // exit_globals()&#39;s call to audit_and_print_stats() is done
<span class="line-modified">!     // at the Info level.</span>
      ObjectSynchronizer::audit_and_print_stats(false /* on_exit */);
    }
  
<span class="line-modified">!   ForceMonitorScavenge = 0;    // Reset</span>
  
<span class="line-modified">!   OM_PERFDATA_OP(Deflations, inc(counters-&gt;nScavenged));</span>
<span class="line-modified">!   OM_PERFDATA_OP(MonExtant, set_value(counters-&gt;nInCirculation));</span>
  
<span class="line-modified">!   GVars.stwRandom = os::random();</span>
<span class="line-modified">!   GVars.stwCycle++;</span>
  }
  
  void ObjectSynchronizer::deflate_thread_local_monitors(Thread* thread, DeflateMonitorCounters* counters) {
    assert(SafepointSynchronize::is_at_safepoint(), &quot;must be at safepoint&quot;);
  
<span class="line-modified">!   ObjectMonitor * freeHeadp = NULL;  // Local SLL of scavenged monitors</span>
<span class="line-modified">!   ObjectMonitor * freeTailp = NULL;</span>
    elapsedTimer timer;
  
    if (log_is_enabled(Info, safepoint, cleanup) ||
        log_is_enabled(Info, monitorinflation)) {
      timer.start();
    }
  
<span class="line-modified">!   int deflated_count = deflate_monitor_list(thread-&gt;omInUseList_addr(), &amp;freeHeadp, &amp;freeTailp);</span>
<span class="line-modified">! </span>
<span class="line-removed">-   timer.stop();</span>
  
<span class="line-modified">!   Thread::muxAcquire(&amp;gListLock, &quot;deflate_thread_local_monitors&quot;);</span>
  
<span class="line-modified">!   // Adjust counters</span>
<span class="line-modified">!   counters-&gt;nInCirculation += thread-&gt;omInUseCount;</span>
<span class="line-modified">!   thread-&gt;omInUseCount -= deflated_count;</span>
<span class="line-modified">!   counters-&gt;nScavenged += deflated_count;</span>
<span class="line-modified">!   counters-&gt;nInuse += thread-&gt;omInUseCount;</span>
<span class="line-modified">!   counters-&gt;perThreadScavenged += deflated_count;</span>
<span class="line-modified">!   // For now, we only care about cumulative per-thread deflation time.</span>
<span class="line-modified">!   counters-&gt;perThreadTimes += timer.seconds();</span>
  
<span class="line-modified">!   // Move the scavenged monitors back to the global free list.</span>
<span class="line-modified">!   if (freeHeadp != NULL) {</span>
<span class="line-removed">-     guarantee(freeTailp != NULL &amp;&amp; deflated_count &gt; 0, &quot;invariant&quot;);</span>
<span class="line-removed">-     assert(freeTailp-&gt;FreeNext == NULL, &quot;invariant&quot;);</span>
  
<span class="line-modified">!     // constant-time list splice - prepend scavenged segment to gFreeList</span>
<span class="line-modified">!     freeTailp-&gt;FreeNext = gFreeList;</span>
<span class="line-modified">!     gFreeList = freeHeadp;</span>
    }
<span class="line-removed">-   Thread::muxRelease(&amp;gListLock);</span>
  }
  
  // Monitor cleanup on JavaThread::exit
  
  // Iterate through monitor cache and attempt to release thread&#39;s monitors
<span class="line-new-header">--- 2035,77 ---</span>
  void ObjectSynchronizer::finish_deflate_idle_monitors(DeflateMonitorCounters* counters) {
    // Report the cumulative time for deflating each thread&#39;s idle
    // monitors. Note: if the work is split among more than one
    // worker thread, then the reported time will likely be more
    // than a beginning to end measurement of the phase.
<span class="line-modified">!   log_info(safepoint, cleanup)(&quot;deflating per-thread idle monitors, %3.7f secs, monitors=%d&quot;, counters-&gt;per_thread_times, counters-&gt;per_thread_scavenged);</span>
  
    if (log_is_enabled(Debug, monitorinflation)) {
      // exit_globals()&#39;s call to audit_and_print_stats() is done
<span class="line-modified">!     // at the Info level and not at a safepoint.</span>
      ObjectSynchronizer::audit_and_print_stats(false /* on_exit */);
<span class="line-added">+   } else if (log_is_enabled(Info, monitorinflation)) {</span>
<span class="line-added">+     log_info(monitorinflation)(&quot;global_population=%d, global_in_use_count=%d, &quot;</span>
<span class="line-added">+                                &quot;global_free_count=%d&quot;,</span>
<span class="line-added">+                                Atomic::load(&amp;om_list_globals._population),</span>
<span class="line-added">+                                Atomic::load(&amp;om_list_globals._in_use_count),</span>
<span class="line-added">+                                Atomic::load(&amp;om_list_globals._free_count));</span>
    }
  
<span class="line-modified">!   Atomic::store(&amp;_forceMonitorScavenge, 0);    // Reset</span>
  
<span class="line-modified">!   OM_PERFDATA_OP(Deflations, inc(counters-&gt;n_scavenged));</span>
<span class="line-modified">!   OM_PERFDATA_OP(MonExtant, set_value(counters-&gt;n_in_circulation));</span>
  
<span class="line-modified">!   GVars.stw_random = os::random();</span>
<span class="line-modified">!   GVars.stw_cycle++;</span>
  }
  
  void ObjectSynchronizer::deflate_thread_local_monitors(Thread* thread, DeflateMonitorCounters* counters) {
    assert(SafepointSynchronize::is_at_safepoint(), &quot;must be at safepoint&quot;);
  
<span class="line-modified">!   ObjectMonitor* free_head_p = NULL;  // Local SLL of scavenged monitors</span>
<span class="line-modified">!   ObjectMonitor* free_tail_p = NULL;</span>
    elapsedTimer timer;
  
    if (log_is_enabled(Info, safepoint, cleanup) ||
        log_is_enabled(Info, monitorinflation)) {
      timer.start();
    }
  
<span class="line-modified">!   // Update n_in_circulation before om_in_use_count is updated by deflation.</span>
<span class="line-modified">!   Atomic::add(&amp;counters-&gt;n_in_circulation, Atomic::load(&amp;thread-&gt;om_in_use_count));</span>
  
<span class="line-modified">!   int deflated_count = deflate_monitor_list(&amp;thread-&gt;om_in_use_list, &amp;thread-&gt;om_in_use_count, &amp;free_head_p, &amp;free_tail_p);</span>
<span class="line-added">+   Atomic::add(&amp;counters-&gt;n_in_use, Atomic::load(&amp;thread-&gt;om_in_use_count));</span>
  
<span class="line-modified">!   if (free_head_p != NULL) {</span>
<span class="line-modified">!     // Move the deflated ObjectMonitors back to the global free list.</span>
<span class="line-modified">!     guarantee(free_tail_p != NULL &amp;&amp; deflated_count &gt; 0, &quot;invariant&quot;);</span>
<span class="line-modified">! #ifdef ASSERT</span>
<span class="line-modified">!     ObjectMonitor* l_next_om = free_tail_p-&gt;next_om();</span>
<span class="line-modified">! #endif</span>
<span class="line-modified">!     assert(l_next_om == NULL, &quot;must be NULL: _next_om=&quot; INTPTR_FORMAT, p2i(l_next_om));</span>
<span class="line-modified">!     prepend_list_to_global_free_list(free_head_p, free_tail_p, deflated_count);</span>
<span class="line-added">+     Atomic::add(&amp;counters-&gt;n_scavenged, deflated_count);</span>
<span class="line-added">+     Atomic::add(&amp;counters-&gt;per_thread_scavenged, deflated_count);</span>
<span class="line-added">+   }</span>
  
<span class="line-modified">!   timer.stop();</span>
<span class="line-modified">!   counters-&gt;per_thread_times += timer.seconds();</span>
  
<span class="line-modified">!   LogStreamHandle(Debug, monitorinflation) lsh_debug;</span>
<span class="line-modified">!   LogStreamHandle(Info, monitorinflation) lsh_info;</span>
<span class="line-modified">!   LogStream* ls = NULL;</span>
<span class="line-added">+   if (log_is_enabled(Debug, monitorinflation)) {</span>
<span class="line-added">+     ls = &amp;lsh_debug;</span>
<span class="line-added">+   } else if (deflated_count != 0 &amp;&amp; log_is_enabled(Info, monitorinflation)) {</span>
<span class="line-added">+     ls = &amp;lsh_info;</span>
<span class="line-added">+   }</span>
<span class="line-added">+   if (ls != NULL) {</span>
<span class="line-added">+     ls-&gt;print_cr(&quot;jt=&quot; INTPTR_FORMAT &quot;: deflating per-thread idle monitors, %3.7f secs, %d monitors&quot;, p2i(thread), timer.seconds(), deflated_count);</span>
    }
  }
  
  // Monitor cleanup on JavaThread::exit
  
  // Iterate through monitor cache and attempt to release thread&#39;s monitors
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1800,12 ***</span>
  
  void ObjectSynchronizer::release_monitors_owned_by_thread(TRAPS) {
    assert(THREAD == JavaThread::current(), &quot;must be current Java thread&quot;);
    NoSafepointVerifier nsv;
    ReleaseJavaMonitorsClosure rjmc(THREAD);
<span class="line-removed">-   Thread::muxAcquire(&amp;gListLock, &quot;release_monitors_owned_by_thread&quot;);</span>
<span class="line-removed">-   ObjectSynchronizer::monitors_iterate(&amp;rjmc);</span>
    ObjectSynchronizer::monitors_iterate(&amp;rjmc);
    THREAD-&gt;clear_pending_exception();
  }
  
  const char* ObjectSynchronizer::inflate_cause_name(const InflateCause cause) {
<span class="line-new-header">--- 2145,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1828,77 ***</span>
  
  u_char* ObjectSynchronizer::get_gvars_addr() {
    return (u_char*)&amp;GVars;
  }
  
<span class="line-modified">! u_char* ObjectSynchronizer::get_gvars_hcSequence_addr() {</span>
<span class="line-modified">!   return (u_char*)&amp;GVars.hcSequence;</span>
  }
  
  size_t ObjectSynchronizer::get_gvars_size() {
    return sizeof(SharedGlobals);
  }
  
<span class="line-modified">! u_char* ObjectSynchronizer::get_gvars_stwRandom_addr() {</span>
<span class="line-modified">!   return (u_char*)&amp;GVars.stwRandom;</span>
  }
  
  void ObjectSynchronizer::audit_and_print_stats(bool on_exit) {
    assert(on_exit || SafepointSynchronize::is_at_safepoint(), &quot;invariant&quot;);
  
    LogStreamHandle(Debug, monitorinflation) lsh_debug;
    LogStreamHandle(Info, monitorinflation) lsh_info;
    LogStreamHandle(Trace, monitorinflation) lsh_trace;
<span class="line-modified">!   LogStream * ls = NULL;</span>
    if (log_is_enabled(Trace, monitorinflation)) {
      ls = &amp;lsh_trace;
    } else if (log_is_enabled(Debug, monitorinflation)) {
      ls = &amp;lsh_debug;
    } else if (log_is_enabled(Info, monitorinflation)) {
      ls = &amp;lsh_info;
    }
    assert(ls != NULL, &quot;sanity check&quot;);
  
<span class="line-modified">!   if (!on_exit) {</span>
<span class="line-removed">-     // Not at VM exit so grab the global list lock.</span>
<span class="line-removed">-     Thread::muxAcquire(&amp;gListLock, &quot;audit_and_print_stats&quot;);</span>
<span class="line-removed">-   }</span>
<span class="line-removed">- </span>
<span class="line-removed">-   // Log counts for the global and per-thread monitor lists:</span>
    int chk_om_population = log_monitor_list_counts(ls);
    int error_cnt = 0;
  
    ls-&gt;print_cr(&quot;Checking global lists:&quot;);
  
<span class="line-modified">!   // Check gMonitorPopulation:</span>
<span class="line-modified">!   if (gMonitorPopulation == chkMonitorPopulation) {</span>
<span class="line-modified">!      ls-&gt;print_cr(&quot;gMonitorPopulation=%d equals chkMonitorPopulation=%d&quot;,</span>
<span class="line-modified">!                   gMonitorPopulation, chkMonitorPopulation);</span>
    } else {
<span class="line-modified">!      ls-&gt;print_cr(&quot;ERROR: gMonitorPopulation=%d is not equal to &quot;</span>
<span class="line-modified">!                   &quot;chkMonitorPopulation=%d&quot;, gMonitorPopulation,</span>
<span class="line-modified">!                   chkMonitorPopulation);</span>
<span class="line-modified">!      error_cnt++;</span>
    }
  
<span class="line-modified">!   // Check gOmInUseList and gOmInUseCount:</span>
    chk_global_in_use_list_and_count(ls, &amp;error_cnt);
  
<span class="line-modified">!   // Check gFreeList and gMonitorFreeCount:</span>
    chk_global_free_list_and_count(ls, &amp;error_cnt);
  
<span class="line-removed">-   if (!on_exit) {</span>
<span class="line-removed">-     Thread::muxRelease(&amp;gListLock);</span>
<span class="line-removed">-   }</span>
<span class="line-removed">- </span>
    ls-&gt;print_cr(&quot;Checking per-thread lists:&quot;);
  
    for (JavaThreadIteratorWithHandle jtiwh; JavaThread *jt = jtiwh.next(); ) {
<span class="line-modified">!     // Check omInUseList and omInUseCount:</span>
      chk_per_thread_in_use_list_and_count(jt, ls, &amp;error_cnt);
  
<span class="line-modified">!     // Check omFreeList and omFreeCount:</span>
      chk_per_thread_free_list_and_count(jt, ls, &amp;error_cnt);
    }
  
    if (error_cnt == 0) {
      ls-&gt;print_cr(&quot;No errors found in monitor list checks.&quot;);
<span class="line-new-header">--- 2171,84 ---</span>
  
  u_char* ObjectSynchronizer::get_gvars_addr() {
    return (u_char*)&amp;GVars;
  }
  
<span class="line-modified">! u_char* ObjectSynchronizer::get_gvars_hc_sequence_addr() {</span>
<span class="line-modified">!   return (u_char*)&amp;GVars.hc_sequence;</span>
  }
  
  size_t ObjectSynchronizer::get_gvars_size() {
    return sizeof(SharedGlobals);
  }
  
<span class="line-modified">! u_char* ObjectSynchronizer::get_gvars_stw_random_addr() {</span>
<span class="line-modified">!   return (u_char*)&amp;GVars.stw_random;</span>
  }
  
<span class="line-added">+ // This function can be called at a safepoint or it can be called when</span>
<span class="line-added">+ // we are trying to exit the VM. When we are trying to exit the VM, the</span>
<span class="line-added">+ // list walker functions can run in parallel with the other list</span>
<span class="line-added">+ // operations so spin-locking is used for safety.</span>
<span class="line-added">+ //</span>
<span class="line-added">+ // Calls to this function can be added in various places as a debugging</span>
<span class="line-added">+ // aid; pass &#39;true&#39; for the &#39;on_exit&#39; parameter to have in-use monitor</span>
<span class="line-added">+ // details logged at the Info level and &#39;false&#39; for the &#39;on_exit&#39;</span>
<span class="line-added">+ // parameter to have in-use monitor details logged at the Trace level.</span>
<span class="line-added">+ // deflate_monitor_list() no longer uses spin-locking so be careful</span>
<span class="line-added">+ // when adding audit_and_print_stats() calls at a safepoint.</span>
<span class="line-added">+ //</span>
  void ObjectSynchronizer::audit_and_print_stats(bool on_exit) {
    assert(on_exit || SafepointSynchronize::is_at_safepoint(), &quot;invariant&quot;);
  
    LogStreamHandle(Debug, monitorinflation) lsh_debug;
    LogStreamHandle(Info, monitorinflation) lsh_info;
    LogStreamHandle(Trace, monitorinflation) lsh_trace;
<span class="line-modified">!   LogStream* ls = NULL;</span>
    if (log_is_enabled(Trace, monitorinflation)) {
      ls = &amp;lsh_trace;
    } else if (log_is_enabled(Debug, monitorinflation)) {
      ls = &amp;lsh_debug;
    } else if (log_is_enabled(Info, monitorinflation)) {
      ls = &amp;lsh_info;
    }
    assert(ls != NULL, &quot;sanity check&quot;);
  
<span class="line-modified">!   // Log counts for the global and per-thread monitor lists:</span>
    int chk_om_population = log_monitor_list_counts(ls);
    int error_cnt = 0;
  
    ls-&gt;print_cr(&quot;Checking global lists:&quot;);
  
<span class="line-modified">!   // Check om_list_globals._population:</span>
<span class="line-modified">!   if (Atomic::load(&amp;om_list_globals._population) == chk_om_population) {</span>
<span class="line-modified">!     ls-&gt;print_cr(&quot;global_population=%d equals chk_om_population=%d&quot;,</span>
<span class="line-modified">!                  Atomic::load(&amp;om_list_globals._population), chk_om_population);</span>
    } else {
<span class="line-modified">!     // With fine grained locks on the monitor lists, it is possible for</span>
<span class="line-modified">!     // log_monitor_list_counts() to return a value that doesn&#39;t match</span>
<span class="line-modified">!     // om_list_globals._population. So far a higher value has been</span>
<span class="line-modified">!     // seen in testing so something is being double counted by</span>
<span class="line-added">+     // log_monitor_list_counts().</span>
<span class="line-added">+     ls-&gt;print_cr(&quot;WARNING: global_population=%d is not equal to &quot;</span>
<span class="line-added">+                  &quot;chk_om_population=%d&quot;,</span>
<span class="line-added">+                  Atomic::load(&amp;om_list_globals._population), chk_om_population);</span>
    }
  
<span class="line-modified">!   // Check om_list_globals._in_use_list and om_list_globals._in_use_count:</span>
    chk_global_in_use_list_and_count(ls, &amp;error_cnt);
  
<span class="line-modified">!   // Check om_list_globals._free_list and om_list_globals._free_count:</span>
    chk_global_free_list_and_count(ls, &amp;error_cnt);
  
    ls-&gt;print_cr(&quot;Checking per-thread lists:&quot;);
  
    for (JavaThreadIteratorWithHandle jtiwh; JavaThread *jt = jtiwh.next(); ) {
<span class="line-modified">!     // Check om_in_use_list and om_in_use_count:</span>
      chk_per_thread_in_use_list_and_count(jt, ls, &amp;error_cnt);
  
<span class="line-modified">!     // Check om_free_list and om_free_count:</span>
      chk_per_thread_free_list_and_count(jt, ls, &amp;error_cnt);
    }
  
    if (error_cnt == 0) {
      ls-&gt;print_cr(&quot;No errors found in monitor list checks.&quot;);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1909,42 ***</span>
    if ((on_exit &amp;&amp; log_is_enabled(Info, monitorinflation)) ||
        (!on_exit &amp;&amp; log_is_enabled(Trace, monitorinflation))) {
      // When exiting this log output is at the Info level. When called
      // at a safepoint, this log output is at the Trace level since
      // there can be a lot of it.
<span class="line-modified">!     log_in_use_monitor_details(ls, on_exit);</span>
    }
  
    ls-&gt;flush();
  
    guarantee(error_cnt == 0, &quot;ERROR: found monitor list errors: error_cnt=%d&quot;, error_cnt);
  }
  
  // Check a free monitor entry; log any errors.
<span class="line-modified">! void ObjectSynchronizer::chk_free_entry(JavaThread * jt, ObjectMonitor * n,</span>
                                          outputStream * out, int *error_cnt_p) {
    if (n-&gt;is_busy()) {
      if (jt != NULL) {
        out-&gt;print_cr(&quot;ERROR: jt=&quot; INTPTR_FORMAT &quot;, monitor=&quot; INTPTR_FORMAT
<span class="line-modified">!                     &quot;: free per-thread monitor must not be busy.&quot;, p2i(jt),</span>
<span class="line-modified">!                     p2i(n));</span>
      } else {
        out-&gt;print_cr(&quot;ERROR: monitor=&quot; INTPTR_FORMAT &quot;: free global monitor &quot;
<span class="line-modified">!                     &quot;must not be busy.&quot;, p2i(n));</span>
      }
      *error_cnt_p = *error_cnt_p + 1;
    }
<span class="line-modified">!   if (n-&gt;header() != NULL) {</span>
      if (jt != NULL) {
        out-&gt;print_cr(&quot;ERROR: jt=&quot; INTPTR_FORMAT &quot;, monitor=&quot; INTPTR_FORMAT
                      &quot;: free per-thread monitor must have NULL _header &quot;
                      &quot;field: _header=&quot; INTPTR_FORMAT, p2i(jt), p2i(n),
<span class="line-modified">!                     p2i(n-&gt;header()));</span>
      } else {
        out-&gt;print_cr(&quot;ERROR: monitor=&quot; INTPTR_FORMAT &quot;: free global monitor &quot;
                      &quot;must have NULL _header field: _header=&quot; INTPTR_FORMAT,
<span class="line-modified">!                     p2i(n), p2i(n-&gt;header()));</span>
      }
      *error_cnt_p = *error_cnt_p + 1;
    }
    if (n-&gt;object() != NULL) {
      if (jt != NULL) {
<span class="line-new-header">--- 2259,43 ---</span>
    if ((on_exit &amp;&amp; log_is_enabled(Info, monitorinflation)) ||
        (!on_exit &amp;&amp; log_is_enabled(Trace, monitorinflation))) {
      // When exiting this log output is at the Info level. When called
      // at a safepoint, this log output is at the Trace level since
      // there can be a lot of it.
<span class="line-modified">!     log_in_use_monitor_details(ls);</span>
    }
  
    ls-&gt;flush();
  
    guarantee(error_cnt == 0, &quot;ERROR: found monitor list errors: error_cnt=%d&quot;, error_cnt);
  }
  
  // Check a free monitor entry; log any errors.
<span class="line-modified">! void ObjectSynchronizer::chk_free_entry(JavaThread* jt, ObjectMonitor* n,</span>
                                          outputStream * out, int *error_cnt_p) {
<span class="line-added">+   stringStream ss;</span>
    if (n-&gt;is_busy()) {
      if (jt != NULL) {
        out-&gt;print_cr(&quot;ERROR: jt=&quot; INTPTR_FORMAT &quot;, monitor=&quot; INTPTR_FORMAT
<span class="line-modified">!                     &quot;: free per-thread monitor must not be busy: %s&quot;, p2i(jt),</span>
<span class="line-modified">!                     p2i(n), n-&gt;is_busy_to_string(&amp;ss));</span>
      } else {
        out-&gt;print_cr(&quot;ERROR: monitor=&quot; INTPTR_FORMAT &quot;: free global monitor &quot;
<span class="line-modified">!                     &quot;must not be busy: %s&quot;, p2i(n), n-&gt;is_busy_to_string(&amp;ss));</span>
      }
      *error_cnt_p = *error_cnt_p + 1;
    }
<span class="line-modified">!   if (n-&gt;header().value() != 0) {</span>
      if (jt != NULL) {
        out-&gt;print_cr(&quot;ERROR: jt=&quot; INTPTR_FORMAT &quot;, monitor=&quot; INTPTR_FORMAT
                      &quot;: free per-thread monitor must have NULL _header &quot;
                      &quot;field: _header=&quot; INTPTR_FORMAT, p2i(jt), p2i(n),
<span class="line-modified">!                     n-&gt;header().value());</span>
      } else {
        out-&gt;print_cr(&quot;ERROR: monitor=&quot; INTPTR_FORMAT &quot;: free global monitor &quot;
                      &quot;must have NULL _header field: _header=&quot; INTPTR_FORMAT,
<span class="line-modified">!                     p2i(n), n-&gt;header().value());</span>
      }
      *error_cnt_p = *error_cnt_p + 1;
    }
    if (n-&gt;object() != NULL) {
      if (jt != NULL) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1959,51 ***</span>
      }
      *error_cnt_p = *error_cnt_p + 1;
    }
  }
  
  // Check the global free list and count; log the results of the checks.
  void ObjectSynchronizer::chk_global_free_list_and_count(outputStream * out,
                                                          int *error_cnt_p) {
<span class="line-modified">!   int chkMonitorFreeCount = 0;</span>
<span class="line-modified">!   for (ObjectMonitor * n = gFreeList; n != NULL; n = n-&gt;FreeNext) {</span>
<span class="line-modified">!     chk_free_entry(NULL /* jt */, n, out, error_cnt_p);</span>
<span class="line-modified">!     chkMonitorFreeCount++;</span>
<span class="line-modified">!   }</span>
<span class="line-modified">!   if (gMonitorFreeCount == chkMonitorFreeCount) {</span>
<span class="line-modified">!     out-&gt;print_cr(&quot;gMonitorFreeCount=%d equals chkMonitorFreeCount=%d&quot;,</span>
<span class="line-modified">!                   gMonitorFreeCount, chkMonitorFreeCount);</span>
    } else {
<span class="line-modified">!     out-&gt;print_cr(&quot;ERROR: gMonitorFreeCount=%d is not equal to &quot;</span>
<span class="line-modified">!                   &quot;chkMonitorFreeCount=%d&quot;, gMonitorFreeCount,</span>
<span class="line-modified">!                   chkMonitorFreeCount);</span>
<span class="line-modified">!     *error_cnt_p = *error_cnt_p + 1;</span>
    }
  }
  
  // Check the global in-use list and count; log the results of the checks.
  void ObjectSynchronizer::chk_global_in_use_list_and_count(outputStream * out,
                                                            int *error_cnt_p) {
<span class="line-modified">!   int chkOmInUseCount = 0;</span>
<span class="line-modified">!   for (ObjectMonitor * n = gOmInUseList; n != NULL; n = n-&gt;FreeNext) {</span>
<span class="line-modified">!     chk_in_use_entry(NULL /* jt */, n, out, error_cnt_p);</span>
<span class="line-modified">!     chkOmInUseCount++;</span>
<span class="line-modified">!   }</span>
<span class="line-modified">!   if (gOmInUseCount == chkOmInUseCount) {</span>
<span class="line-modified">!     out-&gt;print_cr(&quot;gOmInUseCount=%d equals chkOmInUseCount=%d&quot;, gOmInUseCount,</span>
<span class="line-modified">!                   chkOmInUseCount);</span>
    } else {
<span class="line-modified">!     out-&gt;print_cr(&quot;ERROR: gOmInUseCount=%d is not equal to chkOmInUseCount=%d&quot;,</span>
<span class="line-modified">!                   gOmInUseCount, chkOmInUseCount);</span>
<span class="line-modified">!     *error_cnt_p = *error_cnt_p + 1;</span>
    }
  }
  
  // Check an in-use monitor entry; log any errors.
<span class="line-modified">! void ObjectSynchronizer::chk_in_use_entry(JavaThread * jt, ObjectMonitor * n,</span>
                                            outputStream * out, int *error_cnt_p) {
<span class="line-modified">!   if (n-&gt;header() == NULL) {</span>
      if (jt != NULL) {
        out-&gt;print_cr(&quot;ERROR: jt=&quot; INTPTR_FORMAT &quot;, monitor=&quot; INTPTR_FORMAT
                      &quot;: in-use per-thread monitor must have non-NULL _header &quot;
                      &quot;field.&quot;, p2i(jt), p2i(n));
      } else {
<span class="line-new-header">--- 2310,94 ---</span>
      }
      *error_cnt_p = *error_cnt_p + 1;
    }
  }
  
<span class="line-added">+ // Lock the next ObjectMonitor for traversal and unlock the current</span>
<span class="line-added">+ // ObjectMonitor. Returns the next ObjectMonitor if there is one.</span>
<span class="line-added">+ // Otherwise returns NULL (after unlocking the current ObjectMonitor).</span>
<span class="line-added">+ // This function is used by the various list walker functions to</span>
<span class="line-added">+ // safely walk a list without allowing an ObjectMonitor to be moved</span>
<span class="line-added">+ // to another list in the middle of a walk.</span>
<span class="line-added">+ static ObjectMonitor* lock_next_for_traversal(ObjectMonitor* cur) {</span>
<span class="line-added">+   assert(is_locked(cur), &quot;cur=&quot; INTPTR_FORMAT &quot; must be locked&quot;, p2i(cur));</span>
<span class="line-added">+   ObjectMonitor* next = unmarked_next(cur);</span>
<span class="line-added">+   if (next == NULL) {  // Reached the end of the list.</span>
<span class="line-added">+     om_unlock(cur);</span>
<span class="line-added">+     return NULL;</span>
<span class="line-added">+   }</span>
<span class="line-added">+   om_lock(next);   // Lock next before unlocking current to keep</span>
<span class="line-added">+   om_unlock(cur);  // from being by-passed by another thread.</span>
<span class="line-added">+   return next;</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
  // Check the global free list and count; log the results of the checks.
  void ObjectSynchronizer::chk_global_free_list_and_count(outputStream * out,
                                                          int *error_cnt_p) {
<span class="line-modified">!   int chk_om_free_count = 0;</span>
<span class="line-modified">!   ObjectMonitor* cur = NULL;</span>
<span class="line-modified">!   if ((cur = get_list_head_locked(&amp;om_list_globals._free_list)) != NULL) {</span>
<span class="line-modified">!     // Marked the global free list head so process the list.</span>
<span class="line-modified">!     while (true) {</span>
<span class="line-modified">!       chk_free_entry(NULL /* jt */, cur, out, error_cnt_p);</span>
<span class="line-modified">!       chk_om_free_count++;</span>
<span class="line-modified">! </span>
<span class="line-added">+       cur = lock_next_for_traversal(cur);</span>
<span class="line-added">+       if (cur == NULL) {</span>
<span class="line-added">+         break;</span>
<span class="line-added">+       }</span>
<span class="line-added">+     }</span>
<span class="line-added">+   }</span>
<span class="line-added">+   int l_free_count = Atomic::load(&amp;om_list_globals._free_count);</span>
<span class="line-added">+   if (l_free_count == chk_om_free_count) {</span>
<span class="line-added">+     out-&gt;print_cr(&quot;global_free_count=%d equals chk_om_free_count=%d&quot;,</span>
<span class="line-added">+                   l_free_count, chk_om_free_count);</span>
    } else {
<span class="line-modified">!     // With fine grained locks on om_list_globals._free_list, it</span>
<span class="line-modified">!     // is possible for an ObjectMonitor to be prepended to</span>
<span class="line-modified">!     // om_list_globals._free_list after we started calculating</span>
<span class="line-modified">!     // chk_om_free_count so om_list_globals._free_count may not</span>
<span class="line-added">+     // match anymore.</span>
<span class="line-added">+     out-&gt;print_cr(&quot;WARNING: global_free_count=%d is not equal to &quot;</span>
<span class="line-added">+                   &quot;chk_om_free_count=%d&quot;, l_free_count, chk_om_free_count);</span>
    }
  }
  
  // Check the global in-use list and count; log the results of the checks.
  void ObjectSynchronizer::chk_global_in_use_list_and_count(outputStream * out,
                                                            int *error_cnt_p) {
<span class="line-modified">!   int chk_om_in_use_count = 0;</span>
<span class="line-modified">!   ObjectMonitor* cur = NULL;</span>
<span class="line-modified">!   if ((cur = get_list_head_locked(&amp;om_list_globals._in_use_list)) != NULL) {</span>
<span class="line-modified">!     // Marked the global in-use list head so process the list.</span>
<span class="line-modified">!     while (true) {</span>
<span class="line-modified">!       chk_in_use_entry(NULL /* jt */, cur, out, error_cnt_p);</span>
<span class="line-modified">!       chk_om_in_use_count++;</span>
<span class="line-modified">! </span>
<span class="line-added">+       cur = lock_next_for_traversal(cur);</span>
<span class="line-added">+       if (cur == NULL) {</span>
<span class="line-added">+         break;</span>
<span class="line-added">+       }</span>
<span class="line-added">+     }</span>
<span class="line-added">+   }</span>
<span class="line-added">+   int l_in_use_count = Atomic::load(&amp;om_list_globals._in_use_count);</span>
<span class="line-added">+   if (l_in_use_count == chk_om_in_use_count) {</span>
<span class="line-added">+     out-&gt;print_cr(&quot;global_in_use_count=%d equals chk_om_in_use_count=%d&quot;,</span>
<span class="line-added">+                   l_in_use_count, chk_om_in_use_count);</span>
    } else {
<span class="line-modified">!     // With fine grained locks on the monitor lists, it is possible for</span>
<span class="line-modified">!     // an exiting JavaThread to put its in-use ObjectMonitors on the</span>
<span class="line-modified">!     // global in-use list after chk_om_in_use_count is calculated above.</span>
<span class="line-added">+     out-&gt;print_cr(&quot;WARNING: global_in_use_count=%d is not equal to chk_om_in_use_count=%d&quot;,</span>
<span class="line-added">+                   l_in_use_count, chk_om_in_use_count);</span>
    }
  }
  
  // Check an in-use monitor entry; log any errors.
<span class="line-modified">! void ObjectSynchronizer::chk_in_use_entry(JavaThread* jt, ObjectMonitor* n,</span>
                                            outputStream * out, int *error_cnt_p) {
<span class="line-modified">!   if (n-&gt;header().value() == 0) {</span>
      if (jt != NULL) {
        out-&gt;print_cr(&quot;ERROR: jt=&quot; INTPTR_FORMAT &quot;, monitor=&quot; INTPTR_FORMAT
                      &quot;: in-use per-thread monitor must have non-NULL _header &quot;
                      &quot;field.&quot;, p2i(jt), p2i(n));
      } else {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2022,178 ***</span>
                      &quot;must have non-NULL _object field.&quot;, p2i(n));
      }
      *error_cnt_p = *error_cnt_p + 1;
    }
    const oop obj = (oop)n-&gt;object();
<span class="line-modified">!   const markOop mark = obj-&gt;mark();</span>
<span class="line-modified">!   if (!mark-&gt;has_monitor()) {</span>
      if (jt != NULL) {
        out-&gt;print_cr(&quot;ERROR: jt=&quot; INTPTR_FORMAT &quot;, monitor=&quot; INTPTR_FORMAT
                      &quot;: in-use per-thread monitor&#39;s object does not think &quot;
                      &quot;it has a monitor: obj=&quot; INTPTR_FORMAT &quot;, mark=&quot;
<span class="line-modified">!                     INTPTR_FORMAT,  p2i(jt), p2i(n), p2i((address)obj),</span>
<span class="line-removed">-                     p2i((address)mark));</span>
      } else {
        out-&gt;print_cr(&quot;ERROR: monitor=&quot; INTPTR_FORMAT &quot;: in-use global &quot;
                      &quot;monitor&#39;s object does not think it has a monitor: obj=&quot;
                      INTPTR_FORMAT &quot;, mark=&quot; INTPTR_FORMAT, p2i(n),
<span class="line-modified">!                     p2i((address)obj), p2i((address)mark));</span>
      }
      *error_cnt_p = *error_cnt_p + 1;
    }
<span class="line-modified">!   ObjectMonitor * const obj_mon = mark-&gt;monitor();</span>
    if (n != obj_mon) {
      if (jt != NULL) {
        out-&gt;print_cr(&quot;ERROR: jt=&quot; INTPTR_FORMAT &quot;, monitor=&quot; INTPTR_FORMAT
                      &quot;: in-use per-thread monitor&#39;s object does not refer &quot;
                      &quot;to the same monitor: obj=&quot; INTPTR_FORMAT &quot;, mark=&quot;
                      INTPTR_FORMAT &quot;, obj_mon=&quot; INTPTR_FORMAT, p2i(jt),
<span class="line-modified">!                     p2i(n), p2i((address)obj), p2i((address)mark),</span>
<span class="line-removed">-                     p2i((address)obj_mon));</span>
      } else {
        out-&gt;print_cr(&quot;ERROR: monitor=&quot; INTPTR_FORMAT &quot;: in-use global &quot;
                      &quot;monitor&#39;s object does not refer to the same monitor: obj=&quot;
                      INTPTR_FORMAT &quot;, mark=&quot; INTPTR_FORMAT &quot;, obj_mon=&quot;
<span class="line-modified">!                     INTPTR_FORMAT, p2i(n), p2i((address)obj),</span>
<span class="line-removed">-                     p2i((address)mark), p2i((address)obj_mon));</span>
      }
      *error_cnt_p = *error_cnt_p + 1;
    }
  }
  
  // Check the thread&#39;s free list and count; log the results of the checks.
  void ObjectSynchronizer::chk_per_thread_free_list_and_count(JavaThread *jt,
                                                              outputStream * out,
                                                              int *error_cnt_p) {
<span class="line-modified">!   int chkOmFreeCount = 0;</span>
<span class="line-modified">!   for (ObjectMonitor * n = jt-&gt;omFreeList; n != NULL; n = n-&gt;FreeNext) {</span>
<span class="line-modified">!     chk_free_entry(jt, n, out, error_cnt_p);</span>
<span class="line-modified">!     chkOmFreeCount++;</span>
<span class="line-modified">!   }</span>
<span class="line-modified">!   if (jt-&gt;omFreeCount == chkOmFreeCount) {</span>
<span class="line-modified">!     out-&gt;print_cr(&quot;jt=&quot; INTPTR_FORMAT &quot;: omFreeCount=%d equals &quot;</span>
<span class="line-modified">!                   &quot;chkOmFreeCount=%d&quot;, p2i(jt), jt-&gt;omFreeCount, chkOmFreeCount);</span>
    } else {
<span class="line-modified">!     out-&gt;print_cr(&quot;ERROR: jt=&quot; INTPTR_FORMAT &quot;: omFreeCount=%d is not &quot;</span>
<span class="line-modified">!                   &quot;equal to chkOmFreeCount=%d&quot;, p2i(jt), jt-&gt;omFreeCount,</span>
<span class="line-modified">!                   chkOmFreeCount);</span>
      *error_cnt_p = *error_cnt_p + 1;
    }
  }
  
  // Check the thread&#39;s in-use list and count; log the results of the checks.
  void ObjectSynchronizer::chk_per_thread_in_use_list_and_count(JavaThread *jt,
                                                                outputStream * out,
                                                                int *error_cnt_p) {
<span class="line-modified">!   int chkOmInUseCount = 0;</span>
<span class="line-modified">!   for (ObjectMonitor * n = jt-&gt;omInUseList; n != NULL; n = n-&gt;FreeNext) {</span>
<span class="line-modified">!     chk_in_use_entry(jt, n, out, error_cnt_p);</span>
<span class="line-modified">!     chkOmInUseCount++;</span>
<span class="line-modified">!   }</span>
<span class="line-modified">!   if (jt-&gt;omInUseCount == chkOmInUseCount) {</span>
<span class="line-modified">!     out-&gt;print_cr(&quot;jt=&quot; INTPTR_FORMAT &quot;: omInUseCount=%d equals &quot;</span>
<span class="line-modified">!                   &quot;chkOmInUseCount=%d&quot;, p2i(jt), jt-&gt;omInUseCount,</span>
<span class="line-modified">!                   chkOmInUseCount);</span>
    } else {
<span class="line-modified">!     out-&gt;print_cr(&quot;ERROR: jt=&quot; INTPTR_FORMAT &quot;: omInUseCount=%d is not &quot;</span>
<span class="line-modified">!                   &quot;equal to chkOmInUseCount=%d&quot;, p2i(jt), jt-&gt;omInUseCount,</span>
<span class="line-modified">!                   chkOmInUseCount);</span>
      *error_cnt_p = *error_cnt_p + 1;
    }
  }
  
  // Log details about ObjectMonitors on the in-use lists. The &#39;BHL&#39;
  // flags indicate why the entry is in-use, &#39;object&#39; and &#39;object type&#39;
  // indicate the associated object and its type.
<span class="line-modified">! void ObjectSynchronizer::log_in_use_monitor_details(outputStream * out,</span>
<span class="line-modified">!                                                     bool on_exit) {</span>
<span class="line-modified">!   if (!on_exit) {</span>
<span class="line-removed">-     // Not at VM exit so grab the global list lock.</span>
<span class="line-removed">-     Thread::muxAcquire(&amp;gListLock, &quot;log_in_use_monitor_details&quot;);</span>
<span class="line-removed">-   }</span>
<span class="line-removed">- </span>
<span class="line-removed">-   if (gOmInUseCount &gt; 0) {</span>
      out-&gt;print_cr(&quot;In-use global monitor info:&quot;);
<span class="line-modified">!     out-&gt;print_cr(&quot;(B -&gt; is_busy, H -&gt; has hashcode, L -&gt; lock status)&quot;);</span>
      out-&gt;print_cr(&quot;%18s  %s  %18s  %18s&quot;,
                    &quot;monitor&quot;, &quot;BHL&quot;, &quot;object&quot;, &quot;object type&quot;);
      out-&gt;print_cr(&quot;==================  ===  ==================  ==================&quot;);
<span class="line-modified">!     for (ObjectMonitor * n = gOmInUseList; n != NULL; n = n-&gt;FreeNext) {</span>
<span class="line-modified">!       const oop obj = (oop) n-&gt;object();</span>
<span class="line-modified">!       const markOop mark = n-&gt;header();</span>
<span class="line-modified">!       ResourceMark rm;</span>
<span class="line-modified">!       out-&gt;print_cr(INTPTR_FORMAT &quot;  %d%d%d  &quot; INTPTR_FORMAT &quot;  %s&quot;, p2i(n),</span>
<span class="line-modified">!                     n-&gt;is_busy() != 0, mark-&gt;hash() != 0, n-&gt;owner() != NULL,</span>
<span class="line-modified">!                     p2i(obj), obj-&gt;klass()-&gt;external_name());</span>
<span class="line-modified">!     }</span>
<span class="line-modified">!   }</span>
  
<span class="line-modified">!   if (!on_exit) {</span>
<span class="line-modified">!     Thread::muxRelease(&amp;gListLock);</span>
    }
  
    out-&gt;print_cr(&quot;In-use per-thread monitor info:&quot;);
<span class="line-modified">!   out-&gt;print_cr(&quot;(B -&gt; is_busy, H -&gt; has hashcode, L -&gt; lock status)&quot;);</span>
    out-&gt;print_cr(&quot;%18s  %18s  %s  %18s  %18s&quot;,
                  &quot;jt&quot;, &quot;monitor&quot;, &quot;BHL&quot;, &quot;object&quot;, &quot;object type&quot;);
    out-&gt;print_cr(&quot;==================  ==================  ===  ==================  ==================&quot;);
    for (JavaThreadIteratorWithHandle jtiwh; JavaThread *jt = jtiwh.next(); ) {
<span class="line-modified">!     for (ObjectMonitor * n = jt-&gt;omInUseList; n != NULL; n = n-&gt;FreeNext) {</span>
<span class="line-modified">!       const oop obj = (oop) n-&gt;object();</span>
<span class="line-modified">!       const markOop mark = n-&gt;header();</span>
<span class="line-modified">!       ResourceMark rm;</span>
<span class="line-modified">!       out-&gt;print_cr(INTPTR_FORMAT &quot;  &quot; INTPTR_FORMAT &quot;  %d%d%d  &quot; INTPTR_FORMAT</span>
<span class="line-modified">!                     &quot;  %s&quot;, p2i(jt), p2i(n), n-&gt;is_busy() != 0,</span>
<span class="line-modified">!                     mark-&gt;hash() != 0, n-&gt;owner() != NULL, p2i(obj),</span>
<span class="line-modified">!                     obj-&gt;klass()-&gt;external_name());</span>
      }
    }
  
    out-&gt;flush();
  }
  
  // Log counts for the global and per-thread monitor lists and return
  // the population count.
  int ObjectSynchronizer::log_monitor_list_counts(outputStream * out) {
<span class="line-modified">!   int popCount = 0;</span>
    out-&gt;print_cr(&quot;%18s  %10s  %10s  %10s&quot;,
                  &quot;Global Lists:&quot;, &quot;InUse&quot;, &quot;Free&quot;, &quot;Total&quot;);
    out-&gt;print_cr(&quot;==================  ==========  ==========  ==========&quot;);
<span class="line-modified">!   out-&gt;print_cr(&quot;%18s  %10d  %10d  %10d&quot;, &quot;&quot;,</span>
<span class="line-modified">!                 gOmInUseCount, gMonitorFreeCount, gMonitorPopulation);</span>
<span class="line-modified">!   popCount += gOmInUseCount + gMonitorFreeCount;</span>
  
    out-&gt;print_cr(&quot;%18s  %10s  %10s  %10s&quot;,
                  &quot;Per-Thread Lists:&quot;, &quot;InUse&quot;, &quot;Free&quot;, &quot;Provision&quot;);
    out-&gt;print_cr(&quot;==================  ==========  ==========  ==========&quot;);
  
    for (JavaThreadIteratorWithHandle jtiwh; JavaThread *jt = jtiwh.next(); ) {
      out-&gt;print_cr(INTPTR_FORMAT &quot;  %10d  %10d  %10d&quot;, p2i(jt),
<span class="line-modified">!                   jt-&gt;omInUseCount, jt-&gt;omFreeCount, jt-&gt;omFreeProvision);</span>
<span class="line-modified">!     popCount += jt-&gt;omInUseCount + jt-&gt;omFreeCount;</span>
    }
<span class="line-modified">!   return popCount;</span>
  }
  
  #ifndef PRODUCT
  
  // Check if monitor belongs to the monitor cache
  // The list is grow-only so it&#39;s *relatively* safe to traverse
  // the list of extant blocks without taking a lock.
  
  int ObjectSynchronizer::verify_objmon_isinpool(ObjectMonitor *monitor) {
<span class="line-modified">!   PaddedEnd&lt;ObjectMonitor&gt; * block = OrderAccess::load_acquire(&amp;gBlockList);</span>
    while (block != NULL) {
      assert(block-&gt;object() == CHAINMARKER, &quot;must be a block header&quot;);
      if (monitor &gt; &amp;block[0] &amp;&amp; monitor &lt; &amp;block[_BLOCKSIZE]) {
        address mon = (address)monitor;
        address blk = (address)block;
        size_t diff = mon - blk;
<span class="line-modified">!       assert((diff % sizeof(PaddedEnd&lt;ObjectMonitor&gt;)) == 0, &quot;must be aligned&quot;);</span>
        return 1;
      }
<span class="line-modified">!     block = (PaddedEnd&lt;ObjectMonitor&gt; *)block-&gt;FreeNext;</span>
    }
    return 0;
  }
  
  #endif
<span class="line-new-header">--- 2416,220 ---</span>
                      &quot;must have non-NULL _object field.&quot;, p2i(n));
      }
      *error_cnt_p = *error_cnt_p + 1;
    }
    const oop obj = (oop)n-&gt;object();
<span class="line-modified">!   const markWord mark = obj-&gt;mark();</span>
<span class="line-modified">!   if (!mark.has_monitor()) {</span>
      if (jt != NULL) {
        out-&gt;print_cr(&quot;ERROR: jt=&quot; INTPTR_FORMAT &quot;, monitor=&quot; INTPTR_FORMAT
                      &quot;: in-use per-thread monitor&#39;s object does not think &quot;
                      &quot;it has a monitor: obj=&quot; INTPTR_FORMAT &quot;, mark=&quot;
<span class="line-modified">!                     INTPTR_FORMAT,  p2i(jt), p2i(n), p2i(obj), mark.value());</span>
      } else {
        out-&gt;print_cr(&quot;ERROR: monitor=&quot; INTPTR_FORMAT &quot;: in-use global &quot;
                      &quot;monitor&#39;s object does not think it has a monitor: obj=&quot;
                      INTPTR_FORMAT &quot;, mark=&quot; INTPTR_FORMAT, p2i(n),
<span class="line-modified">!                     p2i(obj), mark.value());</span>
      }
      *error_cnt_p = *error_cnt_p + 1;
    }
<span class="line-modified">!   ObjectMonitor* const obj_mon = mark.monitor();</span>
    if (n != obj_mon) {
      if (jt != NULL) {
        out-&gt;print_cr(&quot;ERROR: jt=&quot; INTPTR_FORMAT &quot;, monitor=&quot; INTPTR_FORMAT
                      &quot;: in-use per-thread monitor&#39;s object does not refer &quot;
                      &quot;to the same monitor: obj=&quot; INTPTR_FORMAT &quot;, mark=&quot;
                      INTPTR_FORMAT &quot;, obj_mon=&quot; INTPTR_FORMAT, p2i(jt),
<span class="line-modified">!                     p2i(n), p2i(obj), mark.value(), p2i(obj_mon));</span>
      } else {
        out-&gt;print_cr(&quot;ERROR: monitor=&quot; INTPTR_FORMAT &quot;: in-use global &quot;
                      &quot;monitor&#39;s object does not refer to the same monitor: obj=&quot;
                      INTPTR_FORMAT &quot;, mark=&quot; INTPTR_FORMAT &quot;, obj_mon=&quot;
<span class="line-modified">!                     INTPTR_FORMAT, p2i(n), p2i(obj), mark.value(), p2i(obj_mon));</span>
      }
      *error_cnt_p = *error_cnt_p + 1;
    }
  }
  
  // Check the thread&#39;s free list and count; log the results of the checks.
  void ObjectSynchronizer::chk_per_thread_free_list_and_count(JavaThread *jt,
                                                              outputStream * out,
                                                              int *error_cnt_p) {
<span class="line-modified">!   int chk_om_free_count = 0;</span>
<span class="line-modified">!   ObjectMonitor* cur = NULL;</span>
<span class="line-modified">!   if ((cur = get_list_head_locked(&amp;jt-&gt;om_free_list)) != NULL) {</span>
<span class="line-modified">!     // Marked the per-thread free list head so process the list.</span>
<span class="line-modified">!     while (true) {</span>
<span class="line-modified">!       chk_free_entry(jt, cur, out, error_cnt_p);</span>
<span class="line-modified">!       chk_om_free_count++;</span>
<span class="line-modified">! </span>
<span class="line-added">+       cur = lock_next_for_traversal(cur);</span>
<span class="line-added">+       if (cur == NULL) {</span>
<span class="line-added">+         break;</span>
<span class="line-added">+       }</span>
<span class="line-added">+     }</span>
<span class="line-added">+   }</span>
<span class="line-added">+   int l_om_free_count = Atomic::load(&amp;jt-&gt;om_free_count);</span>
<span class="line-added">+   if (l_om_free_count == chk_om_free_count) {</span>
<span class="line-added">+     out-&gt;print_cr(&quot;jt=&quot; INTPTR_FORMAT &quot;: om_free_count=%d equals &quot;</span>
<span class="line-added">+                   &quot;chk_om_free_count=%d&quot;, p2i(jt), l_om_free_count, chk_om_free_count);</span>
    } else {
<span class="line-modified">!     out-&gt;print_cr(&quot;ERROR: jt=&quot; INTPTR_FORMAT &quot;: om_free_count=%d is not &quot;</span>
<span class="line-modified">!                   &quot;equal to chk_om_free_count=%d&quot;, p2i(jt), l_om_free_count,</span>
<span class="line-modified">!                   chk_om_free_count);</span>
      *error_cnt_p = *error_cnt_p + 1;
    }
  }
  
  // Check the thread&#39;s in-use list and count; log the results of the checks.
  void ObjectSynchronizer::chk_per_thread_in_use_list_and_count(JavaThread *jt,
                                                                outputStream * out,
                                                                int *error_cnt_p) {
<span class="line-modified">!   int chk_om_in_use_count = 0;</span>
<span class="line-modified">!   ObjectMonitor* cur = NULL;</span>
<span class="line-modified">!   if ((cur = get_list_head_locked(&amp;jt-&gt;om_in_use_list)) != NULL) {</span>
<span class="line-modified">!     // Marked the per-thread in-use list head so process the list.</span>
<span class="line-modified">!     while (true) {</span>
<span class="line-modified">!       chk_in_use_entry(jt, cur, out, error_cnt_p);</span>
<span class="line-modified">!       chk_om_in_use_count++;</span>
<span class="line-modified">! </span>
<span class="line-modified">!       cur = lock_next_for_traversal(cur);</span>
<span class="line-added">+       if (cur == NULL) {</span>
<span class="line-added">+         break;</span>
<span class="line-added">+       }</span>
<span class="line-added">+     }</span>
<span class="line-added">+   }</span>
<span class="line-added">+   int l_om_in_use_count = Atomic::load(&amp;jt-&gt;om_in_use_count);</span>
<span class="line-added">+   if (l_om_in_use_count == chk_om_in_use_count) {</span>
<span class="line-added">+     out-&gt;print_cr(&quot;jt=&quot; INTPTR_FORMAT &quot;: om_in_use_count=%d equals &quot;</span>
<span class="line-added">+                   &quot;chk_om_in_use_count=%d&quot;, p2i(jt), l_om_in_use_count,</span>
<span class="line-added">+                   chk_om_in_use_count);</span>
    } else {
<span class="line-modified">!     out-&gt;print_cr(&quot;ERROR: jt=&quot; INTPTR_FORMAT &quot;: om_in_use_count=%d is not &quot;</span>
<span class="line-modified">!                   &quot;equal to chk_om_in_use_count=%d&quot;, p2i(jt), l_om_in_use_count,</span>
<span class="line-modified">!                   chk_om_in_use_count);</span>
      *error_cnt_p = *error_cnt_p + 1;
    }
  }
  
  // Log details about ObjectMonitors on the in-use lists. The &#39;BHL&#39;
  // flags indicate why the entry is in-use, &#39;object&#39; and &#39;object type&#39;
  // indicate the associated object and its type.
<span class="line-modified">! void ObjectSynchronizer::log_in_use_monitor_details(outputStream * out) {</span>
<span class="line-modified">!   stringStream ss;</span>
<span class="line-modified">!   if (Atomic::load(&amp;om_list_globals._in_use_count) &gt; 0) {</span>
      out-&gt;print_cr(&quot;In-use global monitor info:&quot;);
<span class="line-modified">!     out-&gt;print_cr(&quot;(B -&gt; is_busy, H -&gt; has hash code, L -&gt; lock status)&quot;);</span>
      out-&gt;print_cr(&quot;%18s  %s  %18s  %18s&quot;,
                    &quot;monitor&quot;, &quot;BHL&quot;, &quot;object&quot;, &quot;object type&quot;);
      out-&gt;print_cr(&quot;==================  ===  ==================  ==================&quot;);
<span class="line-modified">!     ObjectMonitor* cur = NULL;</span>
<span class="line-modified">!     if ((cur = get_list_head_locked(&amp;om_list_globals._in_use_list)) != NULL) {</span>
<span class="line-modified">!       // Marked the global in-use list head so process the list.</span>
<span class="line-modified">!       while (true) {</span>
<span class="line-modified">!         const oop obj = (oop) cur-&gt;object();</span>
<span class="line-modified">!         const markWord mark = cur-&gt;header();</span>
<span class="line-modified">!         ResourceMark rm;</span>
<span class="line-modified">!         out-&gt;print(INTPTR_FORMAT &quot;  %d%d%d  &quot; INTPTR_FORMAT &quot;  %s&quot;, p2i(cur),</span>
<span class="line-modified">!                    cur-&gt;is_busy() != 0, mark.hash() != 0, cur-&gt;owner() != NULL,</span>
<span class="line-added">+                    p2i(obj), obj-&gt;klass()-&gt;external_name());</span>
<span class="line-added">+         if (cur-&gt;is_busy() != 0) {</span>
<span class="line-added">+           out-&gt;print(&quot; (%s)&quot;, cur-&gt;is_busy_to_string(&amp;ss));</span>
<span class="line-added">+           ss.reset();</span>
<span class="line-added">+         }</span>
<span class="line-added">+         out-&gt;cr();</span>
  
<span class="line-modified">!         cur = lock_next_for_traversal(cur);</span>
<span class="line-modified">!         if (cur == NULL) {</span>
<span class="line-added">+           break;</span>
<span class="line-added">+         }</span>
<span class="line-added">+       }</span>
<span class="line-added">+     }</span>
    }
  
    out-&gt;print_cr(&quot;In-use per-thread monitor info:&quot;);
<span class="line-modified">!   out-&gt;print_cr(&quot;(B -&gt; is_busy, H -&gt; has hash code, L -&gt; lock status)&quot;);</span>
    out-&gt;print_cr(&quot;%18s  %18s  %s  %18s  %18s&quot;,
                  &quot;jt&quot;, &quot;monitor&quot;, &quot;BHL&quot;, &quot;object&quot;, &quot;object type&quot;);
    out-&gt;print_cr(&quot;==================  ==================  ===  ==================  ==================&quot;);
    for (JavaThreadIteratorWithHandle jtiwh; JavaThread *jt = jtiwh.next(); ) {
<span class="line-modified">!     ObjectMonitor* cur = NULL;</span>
<span class="line-modified">!     if ((cur = get_list_head_locked(&amp;jt-&gt;om_in_use_list)) != NULL) {</span>
<span class="line-modified">!       // Marked the global in-use list head so process the list.</span>
<span class="line-modified">!       while (true) {</span>
<span class="line-modified">!         const oop obj = (oop) cur-&gt;object();</span>
<span class="line-modified">!         const markWord mark = cur-&gt;header();</span>
<span class="line-modified">!         ResourceMark rm;</span>
<span class="line-modified">!         out-&gt;print(INTPTR_FORMAT &quot;  &quot; INTPTR_FORMAT &quot;  %d%d%d  &quot; INTPTR_FORMAT</span>
<span class="line-added">+                    &quot;  %s&quot;, p2i(jt), p2i(cur), cur-&gt;is_busy() != 0,</span>
<span class="line-added">+                    mark.hash() != 0, cur-&gt;owner() != NULL, p2i(obj),</span>
<span class="line-added">+                    obj-&gt;klass()-&gt;external_name());</span>
<span class="line-added">+         if (cur-&gt;is_busy() != 0) {</span>
<span class="line-added">+           out-&gt;print(&quot; (%s)&quot;, cur-&gt;is_busy_to_string(&amp;ss));</span>
<span class="line-added">+           ss.reset();</span>
<span class="line-added">+         }</span>
<span class="line-added">+         out-&gt;cr();</span>
<span class="line-added">+ </span>
<span class="line-added">+         cur = lock_next_for_traversal(cur);</span>
<span class="line-added">+         if (cur == NULL) {</span>
<span class="line-added">+           break;</span>
<span class="line-added">+         }</span>
<span class="line-added">+       }</span>
      }
    }
  
    out-&gt;flush();
  }
  
  // Log counts for the global and per-thread monitor lists and return
  // the population count.
  int ObjectSynchronizer::log_monitor_list_counts(outputStream * out) {
<span class="line-modified">!   int pop_count = 0;</span>
    out-&gt;print_cr(&quot;%18s  %10s  %10s  %10s&quot;,
                  &quot;Global Lists:&quot;, &quot;InUse&quot;, &quot;Free&quot;, &quot;Total&quot;);
    out-&gt;print_cr(&quot;==================  ==========  ==========  ==========&quot;);
<span class="line-modified">!   int l_in_use_count = Atomic::load(&amp;om_list_globals._in_use_count);</span>
<span class="line-modified">!   int l_free_count = Atomic::load(&amp;om_list_globals._free_count);</span>
<span class="line-modified">!   out-&gt;print_cr(&quot;%18s  %10d  %10d  %10d&quot;, &quot;&quot;, l_in_use_count,</span>
<span class="line-added">+                 l_free_count, Atomic::load(&amp;om_list_globals._population));</span>
<span class="line-added">+   pop_count += l_in_use_count + l_free_count;</span>
  
    out-&gt;print_cr(&quot;%18s  %10s  %10s  %10s&quot;,
                  &quot;Per-Thread Lists:&quot;, &quot;InUse&quot;, &quot;Free&quot;, &quot;Provision&quot;);
    out-&gt;print_cr(&quot;==================  ==========  ==========  ==========&quot;);
  
    for (JavaThreadIteratorWithHandle jtiwh; JavaThread *jt = jtiwh.next(); ) {
<span class="line-added">+     int l_om_in_use_count = Atomic::load(&amp;jt-&gt;om_in_use_count);</span>
<span class="line-added">+     int l_om_free_count = Atomic::load(&amp;jt-&gt;om_free_count);</span>
      out-&gt;print_cr(INTPTR_FORMAT &quot;  %10d  %10d  %10d&quot;, p2i(jt),
<span class="line-modified">!                   l_om_in_use_count, l_om_free_count, jt-&gt;om_free_provision);</span>
<span class="line-modified">!     pop_count += l_om_in_use_count + l_om_free_count;</span>
    }
<span class="line-modified">!   return pop_count;</span>
  }
  
  #ifndef PRODUCT
  
  // Check if monitor belongs to the monitor cache
  // The list is grow-only so it&#39;s *relatively* safe to traverse
  // the list of extant blocks without taking a lock.
  
  int ObjectSynchronizer::verify_objmon_isinpool(ObjectMonitor *monitor) {
<span class="line-modified">!   PaddedObjectMonitor* block = Atomic::load(&amp;g_block_list);</span>
    while (block != NULL) {
      assert(block-&gt;object() == CHAINMARKER, &quot;must be a block header&quot;);
      if (monitor &gt; &amp;block[0] &amp;&amp; monitor &lt; &amp;block[_BLOCKSIZE]) {
        address mon = (address)monitor;
        address blk = (address)block;
        size_t diff = mon - blk;
<span class="line-modified">!       assert((diff % sizeof(PaddedObjectMonitor)) == 0, &quot;must be aligned&quot;);</span>
        return 1;
      }
<span class="line-modified">!     // unmarked_next() is not needed with g_block_list (no locking</span>
<span class="line-added">+     // used with block linkage _next_om fields).</span>
<span class="line-added">+     block = (PaddedObjectMonitor*)block-&gt;next_om();</span>
    }
    return 0;
  }
  
  #endif
</pre>
<center><a href="sharedRuntime.hpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="../tsan/tsan.cpp.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
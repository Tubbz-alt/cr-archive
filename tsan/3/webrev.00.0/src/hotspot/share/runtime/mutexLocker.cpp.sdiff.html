<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/runtime/mutexLocker.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="init.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="mutexLocker.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/runtime/mutexLocker.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 1997, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #include &quot;precompiled.hpp&quot;

 26 #include &quot;runtime/mutexLocker.hpp&quot;
 27 #include &quot;runtime/os.inline.hpp&quot;
 28 #include &quot;runtime/safepoint.hpp&quot;
 29 #include &quot;runtime/thread.inline.hpp&quot;
 30 #include &quot;runtime/vmThread.hpp&quot;
 31 
 32 // Mutexes used in the VM (see comment in mutexLocker.hpp):
 33 //
 34 // Note that the following pointers are effectively final -- after having been
 35 // set at JVM startup-time, they should never be subsequently mutated.
 36 // Instead of using pointers to malloc()ed monitors and mutexes we should consider
 37 // eliminating the indirection and using instances instead.
 38 // Consider using GCC&#39;s __read_mostly.
 39 
 40 Mutex*   Patching_lock                = NULL;

 41 Monitor* SystemDictionary_lock        = NULL;
 42 Mutex*   ProtectionDomainSet_lock     = NULL;
 43 Mutex*   SharedDictionary_lock        = NULL;
 44 Mutex*   Module_lock                  = NULL;
 45 Mutex*   CompiledIC_lock              = NULL;
 46 Mutex*   InlineCacheBuffer_lock       = NULL;
 47 Mutex*   VMStatistic_lock             = NULL;
<span class="line-removed"> 48 Mutex*   JNIGlobalAlloc_lock          = NULL;</span>
<span class="line-removed"> 49 Mutex*   JNIGlobalActive_lock         = NULL;</span>
<span class="line-removed"> 50 Mutex*   JNIWeakAlloc_lock            = NULL;</span>
<span class="line-removed"> 51 Mutex*   JNIWeakActive_lock           = NULL;</span>
<span class="line-removed"> 52 Mutex*   StringTableWeakAlloc_lock    = NULL;</span>
<span class="line-removed"> 53 Mutex*   StringTableWeakActive_lock   = NULL;</span>
<span class="line-removed"> 54 Mutex*   JNIHandleBlockFreeList_lock  = NULL;</span>
<span class="line-removed"> 55 Mutex*   VMWeakAlloc_lock             = NULL;</span>
<span class="line-removed"> 56 Mutex*   VMWeakActive_lock            = NULL;</span>
 57 Mutex*   ResolvedMethodTable_lock     = NULL;
 58 Mutex*   JmethodIdCreation_lock       = NULL;
 59 Mutex*   JfieldIdCreation_lock        = NULL;
 60 Monitor* JNICritical_lock             = NULL;
 61 Mutex*   JvmtiThreadState_lock        = NULL;
 62 Monitor* Heap_lock                    = NULL;
 63 Mutex*   ExpandHeap_lock              = NULL;
 64 Mutex*   AdapterHandlerLibrary_lock   = NULL;
 65 Mutex*   SignatureHandlerLibrary_lock = NULL;
 66 Mutex*   VtableStubs_lock             = NULL;
 67 Mutex*   SymbolArena_lock             = NULL;
 68 Monitor* StringDedupQueue_lock        = NULL;
 69 Mutex*   StringDedupTable_lock        = NULL;
 70 Monitor* CodeCache_lock               = NULL;
 71 Mutex*   MethodData_lock              = NULL;
 72 Mutex*   TouchedMethodLog_lock        = NULL;
 73 Mutex*   RetData_lock                 = NULL;
 74 Monitor* VMOperationQueue_lock        = NULL;
 75 Monitor* VMOperationRequest_lock      = NULL;
<span class="line-removed"> 76 Monitor* SerializePage_lock           = NULL;</span>
 77 Monitor* Threads_lock                 = NULL;
 78 Mutex*   NonJavaThreadsList_lock      = NULL;

 79 Monitor* CGC_lock                     = NULL;
 80 Monitor* STS_lock                     = NULL;
 81 Monitor* FullGCCount_lock             = NULL;
<span class="line-modified"> 82 Monitor* SATB_Q_CBL_mon               = NULL;</span>
<span class="line-removed"> 83 Monitor* DirtyCardQ_CBL_mon           = NULL;</span>
 84 Mutex*   Shared_DirtyCardQ_lock       = NULL;
 85 Mutex*   MarkStackFreeList_lock       = NULL;
 86 Mutex*   MarkStackChunkList_lock      = NULL;
 87 Mutex*   MonitoringSupport_lock       = NULL;
 88 Mutex*   ParGCRareEvent_lock          = NULL;
<span class="line-removed"> 89 Mutex*   DerivedPointerTableGC_lock   = NULL;</span>
 90 Monitor* CGCPhaseManager_lock         = NULL;
 91 Mutex*   Compile_lock                 = NULL;
 92 Monitor* MethodCompileQueue_lock      = NULL;
 93 Monitor* CompileThread_lock           = NULL;
 94 Monitor* Compilation_lock             = NULL;
 95 Mutex*   CompileTaskAlloc_lock        = NULL;
 96 Mutex*   CompileStatistics_lock       = NULL;
 97 Mutex*   DirectivesStack_lock         = NULL;
 98 Mutex*   MultiArray_lock              = NULL;
 99 Monitor* Terminator_lock              = NULL;

100 Monitor* BeforeExit_lock              = NULL;
101 Monitor* Notify_lock                  = NULL;
102 Mutex*   ProfilePrint_lock            = NULL;
103 Mutex*   ExceptionCache_lock          = NULL;
<span class="line-removed">104 Mutex*   OsrList_lock                 = NULL;</span>
105 Mutex*   NMethodSweeperStats_lock     = NULL;
106 #ifndef PRODUCT
107 Mutex*   FullGCALot_lock              = NULL;
108 #endif
109 
110 Mutex*   Debug1_lock                  = NULL;
111 Mutex*   Debug2_lock                  = NULL;
112 Mutex*   Debug3_lock                  = NULL;
113 
114 Mutex*   tty_lock                     = NULL;
115 
116 Mutex*   RawMonitor_lock              = NULL;
117 Mutex*   PerfDataMemAlloc_lock        = NULL;
118 Mutex*   PerfDataManager_lock         = NULL;
119 Mutex*   OopMapCacheAlloc_lock        = NULL;
120 
121 Mutex*   FreeList_lock                = NULL;
122 Mutex*   OldSets_lock                 = NULL;
123 Monitor* RootRegionScan_lock          = NULL;
124 
<span class="line-removed">125 Monitor* GCTaskManager_lock           = NULL;</span>
<span class="line-removed">126 </span>
127 Mutex*   Management_lock              = NULL;
128 Monitor* Service_lock                 = NULL;

129 Monitor* PeriodicTask_lock            = NULL;
130 Monitor* RedefineClasses_lock         = NULL;

131 
132 #if INCLUDE_JFR
133 Mutex*   JfrStacktrace_lock           = NULL;
134 Monitor* JfrMsg_lock                  = NULL;
135 Mutex*   JfrBuffer_lock               = NULL;
136 Mutex*   JfrStream_lock               = NULL;
137 Monitor* JfrThreadSampler_lock        = NULL;
138 #endif
139 
140 #if INCLUDE_TSAN
141 Mutex*   TsanOopMap_lock              = NULL;
142 #endif
143 
144 #ifndef SUPPORTS_NATIVE_CX8
145 Mutex*   UnsafeJlong_lock             = NULL;
146 #endif
<span class="line-modified">147 Monitor* CodeHeapStateAnalytics_lock  = NULL;</span>
148 
149 Mutex*   MetaspaceExpand_lock         = NULL;
150 Mutex*   ClassLoaderDataGraph_lock    = NULL;
151 Monitor* ThreadsSMRDelete_lock        = NULL;

152 Mutex*   SharedDecoder_lock           = NULL;
153 Mutex*   DCmdFactory_lock             = NULL;
154 #if INCLUDE_NMT
155 Mutex*   NMTQuery_lock                = NULL;
156 #endif
<span class="line-modified">157 #if INCLUDE_CDS &amp;&amp; INCLUDE_JVMTI</span>

158 Mutex*   CDSClassFileStream_lock      = NULL;
159 #endif







160 
161 #define MAX_NUM_MUTEX 128
<span class="line-modified">162 static Monitor * _mutex_array[MAX_NUM_MUTEX];</span>
163 static int _num_mutex;
164 
165 #ifdef ASSERT
<span class="line-modified">166 void assert_locked_or_safepoint(const Monitor * lock) {</span>
167   // check if this thread owns the lock (common case)
<span class="line-removed">168   if (IgnoreLockingAssertions) return;</span>
169   assert(lock != NULL, &quot;Need non-NULL lock&quot;);
170   if (lock-&gt;owned_by_self()) return;
171   if (SafepointSynchronize::is_at_safepoint()) return;
172   if (!Universe::is_fully_initialized()) return;
173   // see if invoker of VM operation owns it
174   VM_Operation* op = VMThread::vm_operation();
175   if (op != NULL &amp;&amp; op-&gt;calling_thread() == lock-&gt;owner()) return;
176   fatal(&quot;must own lock %s&quot;, lock-&gt;name());
177 }
178 
179 // a weaker assertion than the above
<span class="line-modified">180 void assert_locked_or_safepoint_weak(const Monitor * lock) {</span>
<span class="line-removed">181   if (IgnoreLockingAssertions) return;</span>
182   assert(lock != NULL, &quot;Need non-NULL lock&quot;);
183   if (lock-&gt;is_locked()) return;
184   if (SafepointSynchronize::is_at_safepoint()) return;
185   if (!Universe::is_fully_initialized()) return;
186   fatal(&quot;must own lock %s&quot;, lock-&gt;name());
187 }
188 
189 // a stronger assertion than the above
<span class="line-modified">190 void assert_lock_strong(const Monitor * lock) {</span>
<span class="line-removed">191   if (IgnoreLockingAssertions) return;</span>
192   assert(lock != NULL, &quot;Need non-NULL lock&quot;);
193   if (lock-&gt;owned_by_self()) return;
194   fatal(&quot;must own lock %s&quot;, lock-&gt;name());
195 }





196 #endif
197 
198 #define def(var, type, pri, vm_block, safepoint_check_allowed ) {      \
<span class="line-modified">199   var = new type(Mutex::pri, #var, vm_block, safepoint_check_allowed); \</span>
200   assert(_num_mutex &lt; MAX_NUM_MUTEX, &quot;increase MAX_NUM_MUTEX&quot;);        \
201   _mutex_array[_num_mutex++] = var;                                      \
202 }
203 
204 // Using Padded subclasses to prevent false sharing of these global monitors and mutexes.
205 void mutex_init() {
<span class="line-modified">206   def(tty_lock                     , PaddedMutex  , tty,         true,  Monitor::_safepoint_check_never);      // allow to lock in VM</span>
<span class="line-removed">207 </span>
<span class="line-removed">208   def(CGC_lock                     , PaddedMonitor, special,     true,  Monitor::_safepoint_check_never);      // coordinate between fore- and background GC</span>
<span class="line-removed">209   def(STS_lock                     , PaddedMonitor, leaf,        true,  Monitor::_safepoint_check_never);</span>
210 
<span class="line-modified">211   def(VMWeakAlloc_lock             , PaddedMutex  , vmweak,      true,  Monitor::_safepoint_check_never);</span>
<span class="line-modified">212   def(VMWeakActive_lock            , PaddedMutex  , vmweak-1,    true,  Monitor::_safepoint_check_never);</span>
213 
<span class="line-modified">214   def(StringTableWeakAlloc_lock    , PaddedMutex  , vmweak,      true,  Monitor::_safepoint_check_never);</span>
<span class="line-removed">215   def(StringTableWeakActive_lock   , PaddedMutex  , vmweak-1,    true,  Monitor::_safepoint_check_never);</span>
<span class="line-removed">216 </span>
<span class="line-removed">217   if (UseConcMarkSweepGC || UseG1GC) {</span>
<span class="line-removed">218     def(FullGCCount_lock           , PaddedMonitor, leaf,        true,  Monitor::_safepoint_check_never);      // in support of ExplicitGCInvokesConcurrent</span>
<span class="line-removed">219   }</span>
220   if (UseG1GC) {
<span class="line-modified">221     def(SATB_Q_CBL_mon             , PaddedMonitor, access,      true,  Monitor::_safepoint_check_never);</span>
222 
<span class="line-modified">223     def(DirtyCardQ_CBL_mon         , PaddedMonitor, access,      true,  Monitor::_safepoint_check_never);</span>
<span class="line-removed">224     def(Shared_DirtyCardQ_lock     , PaddedMutex  , access + 1,  true,  Monitor::_safepoint_check_never);</span>
225 
<span class="line-modified">226     def(FreeList_lock              , PaddedMutex  , leaf     ,   true,  Monitor::_safepoint_check_never);</span>
<span class="line-modified">227     def(OldSets_lock               , PaddedMutex  , leaf     ,   true,  Monitor::_safepoint_check_never);</span>
<span class="line-modified">228     def(RootRegionScan_lock        , PaddedMonitor, leaf     ,   true,  Monitor::_safepoint_check_never);</span>
229 
<span class="line-modified">230     def(StringDedupQueue_lock      , PaddedMonitor, leaf,        true,  Monitor::_safepoint_check_never);</span>
<span class="line-modified">231     def(StringDedupTable_lock      , PaddedMutex  , leaf,        true,  Monitor::_safepoint_check_never);</span>
232 
<span class="line-modified">233     def(MarkStackFreeList_lock     , PaddedMutex  , leaf     ,   true,  Monitor::_safepoint_check_never);</span>
<span class="line-modified">234     def(MarkStackChunkList_lock    , PaddedMutex  , leaf     ,   true,  Monitor::_safepoint_check_never);</span>
235 
<span class="line-modified">236     def(MonitoringSupport_lock     , PaddedMutex  , native   ,   true,  Monitor::_safepoint_check_never);      // used for serviceability monitoring support</span>
237   }
238   if (UseShenandoahGC) {
<span class="line-modified">239     def(SATB_Q_CBL_mon             , PaddedMonitor, access,      true,  Monitor::_safepoint_check_never);</span>










240 
<span class="line-modified">241     def(StringDedupQueue_lock      , PaddedMonitor, leaf,        true,  Monitor::_safepoint_check_never);</span>
<span class="line-modified">242     def(StringDedupTable_lock      , PaddedMutex  , leaf,        true,  Monitor::_safepoint_check_never);</span>






243   }
<span class="line-modified">244   def(ParGCRareEvent_lock          , PaddedMutex  , leaf     ,   true,  Monitor::_safepoint_check_sometimes);</span>
<span class="line-modified">245   def(DerivedPointerTableGC_lock   , PaddedMutex  , leaf,        true,  Monitor::_safepoint_check_never);</span>
<span class="line-modified">246   def(CGCPhaseManager_lock         , PaddedMonitor, leaf,        false, Monitor::_safepoint_check_sometimes);</span>
<span class="line-modified">247   def(CodeCache_lock               , PaddedMutex  , special,     true,  Monitor::_safepoint_check_never);</span>
<span class="line-modified">248   def(RawMonitor_lock              , PaddedMutex  , special,     true,  Monitor::_safepoint_check_never);</span>
<span class="line-modified">249   def(OopMapCacheAlloc_lock        , PaddedMutex  , leaf,        true,  Monitor::_safepoint_check_always);     // used for oop_map_cache allocation.</span>
<span class="line-modified">250 </span>
<span class="line-modified">251   def(MetaspaceExpand_lock         , PaddedMutex  , leaf-1,      true,  Monitor::_safepoint_check_never);</span>
<span class="line-modified">252   def(ClassLoaderDataGraph_lock    , PaddedMutex  , nonleaf,     true,  Monitor::_safepoint_check_always);</span>
<span class="line-modified">253 </span>
<span class="line-modified">254   def(Patching_lock                , PaddedMutex  , special,     true,  Monitor::_safepoint_check_never);      // used for safepointing and code patching.</span>
<span class="line-modified">255   def(Service_lock                 , PaddedMonitor, special,     true,  Monitor::_safepoint_check_never);      // used for service thread operations</span>
<span class="line-modified">256   def(JmethodIdCreation_lock       , PaddedMutex  , leaf,        true,  Monitor::_safepoint_check_always);     // used for creating jmethodIDs.</span>
<span class="line-modified">257 </span>
<span class="line-modified">258   def(SystemDictionary_lock        , PaddedMonitor, leaf,        true,  Monitor::_safepoint_check_always);     // lookups done by VM thread</span>
<span class="line-modified">259   def(ProtectionDomainSet_lock     , PaddedMutex  , leaf-1,      true,  Monitor::_safepoint_check_never);</span>
<span class="line-removed">260   def(SharedDictionary_lock        , PaddedMutex  , leaf,        true,  Monitor::_safepoint_check_always);     // lookups done by VM thread</span>
<span class="line-removed">261   def(Module_lock                  , PaddedMutex  , leaf+2,      true,  Monitor::_safepoint_check_always);</span>
<span class="line-removed">262   def(InlineCacheBuffer_lock       , PaddedMutex  , leaf,        true,  Monitor::_safepoint_check_never);</span>
<span class="line-removed">263   def(VMStatistic_lock             , PaddedMutex  , leaf,        false, Monitor::_safepoint_check_always);</span>
<span class="line-removed">264   def(ExpandHeap_lock              , PaddedMutex  , leaf,        true,  Monitor::_safepoint_check_always);     // Used during compilation by VM thread</span>
<span class="line-removed">265   def(JNIHandleBlockFreeList_lock  , PaddedMutex  , leaf-1,      true,  Monitor::_safepoint_check_never);      // handles are used by VM thread</span>
<span class="line-removed">266   def(SignatureHandlerLibrary_lock , PaddedMutex  , leaf,        false, Monitor::_safepoint_check_always);</span>
<span class="line-removed">267   def(SymbolArena_lock             , PaddedMutex  , leaf+2,      true,  Monitor::_safepoint_check_never);</span>
<span class="line-removed">268   def(ProfilePrint_lock            , PaddedMutex  , leaf,        false, Monitor::_safepoint_check_always);     // serial profile printing</span>
<span class="line-removed">269   def(ExceptionCache_lock          , PaddedMutex  , leaf,        false, Monitor::_safepoint_check_always);     // serial profile printing</span>
<span class="line-removed">270   def(OsrList_lock                 , PaddedMutex  , leaf,        true,  Monitor::_safepoint_check_never);</span>
<span class="line-removed">271   def(Debug1_lock                  , PaddedMutex  , leaf,        true,  Monitor::_safepoint_check_never);</span>
272 #ifndef PRODUCT
<span class="line-modified">273   def(FullGCALot_lock              , PaddedMutex  , leaf,        false, Monitor::_safepoint_check_always);     // a lock to make FullGCALot MT safe</span>
274 #endif
<span class="line-modified">275   def(BeforeExit_lock              , PaddedMonitor, leaf,        true,  Monitor::_safepoint_check_always);</span>
<span class="line-modified">276   def(PerfDataMemAlloc_lock        , PaddedMutex  , leaf,        true,  Monitor::_safepoint_check_always);     // used for allocating PerfData memory for performance data</span>
<span class="line-modified">277   def(PerfDataManager_lock         , PaddedMutex  , leaf,        true,  Monitor::_safepoint_check_always);     // used for synchronized access to PerfDataManager resources</span>
<span class="line-modified">278 </span>
<span class="line-modified">279   // CMS_modUnionTable_lock                   leaf</span>
<span class="line-modified">280   // CMS_bitMap_lock                          leaf 1</span>
<span class="line-modified">281   // CMS_freeList_lock                        leaf 2</span>
<span class="line-modified">282 </span>
<span class="line-modified">283   def(Threads_lock                 , PaddedMonitor, barrier,     true,  Monitor::_safepoint_check_sometimes);</span>
<span class="line-modified">284   def(NonJavaThreadsList_lock      , PaddedMutex,   leaf,        true,  Monitor::_safepoint_check_never);</span>
<span class="line-modified">285 </span>
<span class="line-modified">286   def(VMOperationQueue_lock        , PaddedMonitor, nonleaf,     true,  Monitor::_safepoint_check_sometimes);  // VM_thread allowed to block on these</span>
<span class="line-modified">287   def(VMOperationRequest_lock      , PaddedMonitor, nonleaf,     true,  Monitor::_safepoint_check_sometimes);</span>
<span class="line-modified">288   def(RetData_lock                 , PaddedMutex  , nonleaf,     false, Monitor::_safepoint_check_always);</span>
<span class="line-modified">289   def(Terminator_lock              , PaddedMonitor, nonleaf,     true,  Monitor::_safepoint_check_sometimes);</span>
<span class="line-modified">290   def(VtableStubs_lock             , PaddedMutex  , nonleaf,     true,  Monitor::_safepoint_check_never);</span>
<span class="line-modified">291   def(Notify_lock                  , PaddedMonitor, nonleaf,     true,  Monitor::_safepoint_check_always);</span>
<span class="line-modified">292   def(JNIGlobalAlloc_lock          , PaddedMutex  , nonleaf,     true,  Monitor::_safepoint_check_never);</span>
<span class="line-modified">293   def(JNIGlobalActive_lock         , PaddedMutex  , nonleaf-1,   true,  Monitor::_safepoint_check_never);</span>
<span class="line-modified">294   def(JNIWeakAlloc_lock            , PaddedMutex  , nonleaf,     true,  Monitor::_safepoint_check_never);</span>
<span class="line-modified">295   def(JNIWeakActive_lock           , PaddedMutex  , nonleaf-1,   true,  Monitor::_safepoint_check_never);</span>
<span class="line-modified">296   def(JNICritical_lock             , PaddedMonitor, nonleaf,     true,  Monitor::_safepoint_check_always);     // used for JNI critical regions</span>
<span class="line-modified">297   def(AdapterHandlerLibrary_lock   , PaddedMutex  , nonleaf,     true,  Monitor::_safepoint_check_always);</span>
<span class="line-modified">298 </span>
<span class="line-modified">299   def(Heap_lock                    , PaddedMonitor, nonleaf+1,   false, Monitor::_safepoint_check_sometimes);</span>
<span class="line-modified">300   def(JfieldIdCreation_lock        , PaddedMutex  , nonleaf+1,   true,  Monitor::_safepoint_check_always);     // jfieldID, Used in VM_Operation</span>
<span class="line-modified">301   def(ResolvedMethodTable_lock     , PaddedMutex  , nonleaf+1,   false, Monitor::_safepoint_check_always);     // Used to protect ResolvedMethodTable</span>
<span class="line-modified">302 </span>
<span class="line-modified">303   def(CompiledIC_lock              , PaddedMutex  , nonleaf+2,   false, Monitor::_safepoint_check_never);      // locks VtableStubs_lock, InlineCacheBuffer_lock</span>
<span class="line-modified">304   def(CompileTaskAlloc_lock        , PaddedMutex  , nonleaf+2,   true,  Monitor::_safepoint_check_always);</span>
<span class="line-modified">305   def(CompileStatistics_lock       , PaddedMutex  , nonleaf+2,   false, Monitor::_safepoint_check_always);</span>
<span class="line-modified">306   def(DirectivesStack_lock         , PaddedMutex  , special,     true,  Monitor::_safepoint_check_never);</span>
<span class="line-modified">307   def(MultiArray_lock              , PaddedMutex  , nonleaf+2,   false, Monitor::_safepoint_check_always);</span>
<span class="line-modified">308 </span>
<span class="line-modified">309   def(JvmtiThreadState_lock        , PaddedMutex  , nonleaf+2,   false, Monitor::_safepoint_check_always);     // Used by JvmtiThreadState/JvmtiEventController</span>
<span class="line-modified">310   def(Management_lock              , PaddedMutex  , nonleaf+2,   false, Monitor::_safepoint_check_always);     // used for JVM management</span>
<span class="line-modified">311 </span>
<span class="line-modified">312   def(Compile_lock                 , PaddedMutex  , nonleaf+3,   true,  Monitor::_safepoint_check_always);</span>
<span class="line-modified">313   def(MethodData_lock              , PaddedMutex  , nonleaf+3,   false, Monitor::_safepoint_check_always);</span>
<span class="line-modified">314   def(TouchedMethodLog_lock        , PaddedMutex  , nonleaf+3,   false, Monitor::_safepoint_check_always);</span>
<span class="line-modified">315 </span>
<span class="line-removed">316   def(MethodCompileQueue_lock      , PaddedMonitor, nonleaf+4,   true,  Monitor::_safepoint_check_always);</span>
<span class="line-removed">317   def(Debug2_lock                  , PaddedMutex  , nonleaf+4,   true,  Monitor::_safepoint_check_never);</span>
<span class="line-removed">318   def(Debug3_lock                  , PaddedMutex  , nonleaf+4,   true,  Monitor::_safepoint_check_never);</span>
<span class="line-removed">319   def(CompileThread_lock           , PaddedMonitor, nonleaf+5,   false, Monitor::_safepoint_check_always);</span>
<span class="line-removed">320   def(PeriodicTask_lock            , PaddedMonitor, nonleaf+5,   true,  Monitor::_safepoint_check_sometimes);</span>
<span class="line-removed">321   def(RedefineClasses_lock         , PaddedMonitor, nonleaf+5,   true,  Monitor::_safepoint_check_always);</span>
322 
323   if (WhiteBoxAPI) {
<span class="line-modified">324     def(Compilation_lock           , PaddedMonitor, leaf,        false, Monitor::_safepoint_check_never);</span>
325   }
326 
327 #if INCLUDE_JFR
<span class="line-modified">328   def(JfrMsg_lock                  , PaddedMonitor, leaf,        true,  Monitor::_safepoint_check_always);</span>
<span class="line-modified">329   def(JfrBuffer_lock               , PaddedMutex  , leaf,        true,  Monitor::_safepoint_check_never);</span>
<span class="line-modified">330   def(JfrStream_lock               , PaddedMutex  , leaf+1,      true,  Monitor::_safepoint_check_never);      // ensure to rank lower than &#39;safepoint&#39;</span>
<span class="line-modified">331   def(JfrStacktrace_lock           , PaddedMutex  , special,     true,  Monitor::_safepoint_check_sometimes);</span>
<span class="line-modified">332   def(JfrThreadSampler_lock        , PaddedMonitor, leaf,        true,  Monitor::_safepoint_check_never);</span>
333 #endif
334 
335   TSAN_RUNTIME_ONLY(
<span class="line-modified">336     def(TsanOopMap_lock            , PaddedMutex  , special,     true,  Monitor::_safepoint_check_never);</span>
337   );
338 
339 #ifndef SUPPORTS_NATIVE_CX8
<span class="line-modified">340   def(UnsafeJlong_lock             , PaddedMutex  , special,     false, Monitor::_safepoint_check_never);</span>
341 #endif
342 
<span class="line-modified">343   def(CodeHeapStateAnalytics_lock  , PaddedMutex  , leaf,        true,  Monitor::_safepoint_check_never);</span>
<span class="line-modified">344 </span>
<span class="line-modified">345   def(NMethodSweeperStats_lock     , PaddedMutex  , special,     true,  Monitor::_safepoint_check_sometimes);</span>
<span class="line-modified">346   def(ThreadsSMRDelete_lock        , PaddedMonitor, special,     false, Monitor::_safepoint_check_never);</span>
<span class="line-modified">347   def(SharedDecoder_lock           , PaddedMutex  , native,      false, Monitor::_safepoint_check_never);</span>
<span class="line-modified">348   def(DCmdFactory_lock             , PaddedMutex  , leaf,        true,  Monitor::_safepoint_check_never);</span>
349 #if INCLUDE_NMT
<span class="line-modified">350   def(NMTQuery_lock                , PaddedMutex  , max_nonleaf, false, Monitor::_safepoint_check_always);</span>
351 #endif
<span class="line-modified">352 #if INCLUDE_CDS &amp;&amp; INCLUDE_JVMTI</span>
<span class="line-modified">353   def(CDSClassFileStream_lock      , PaddedMutex  , max_nonleaf, false, Monitor::_safepoint_check_always);</span>







354 #endif
355 }
356 
<span class="line-modified">357 GCMutexLocker::GCMutexLocker(Monitor * mutex) {</span>
358   if (SafepointSynchronize::is_at_safepoint()) {
359     _locked = false;
360   } else {
361     _mutex = mutex;
362     _locked = true;
363     _mutex-&gt;lock();
364   }
365 }
366 
367 // Print all mutexes/monitors that are currently owned by a thread; called
368 // by fatal error handler.
369 void print_owned_locks_on_error(outputStream* st) {
370   st-&gt;print(&quot;VM Mutex/Monitor currently owned by a thread: &quot;);
371   bool none = true;
372   for (int i = 0; i &lt; _num_mutex; i++) {
373      // see if it has an owner
374      if (_mutex_array[i]-&gt;owner() != NULL) {
375        if (none) {
376           // print format used by Mutex::print_on_error()
377           st-&gt;print_cr(&quot; ([mutex/lock_event])&quot;);
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 1997, 2020, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #include &quot;precompiled.hpp&quot;
<span class="line-added"> 26 #include &quot;memory/universe.hpp&quot;</span>
 27 #include &quot;runtime/mutexLocker.hpp&quot;
 28 #include &quot;runtime/os.inline.hpp&quot;
 29 #include &quot;runtime/safepoint.hpp&quot;
 30 #include &quot;runtime/thread.inline.hpp&quot;
 31 #include &quot;runtime/vmThread.hpp&quot;
 32 
 33 // Mutexes used in the VM (see comment in mutexLocker.hpp):
 34 //
 35 // Note that the following pointers are effectively final -- after having been
 36 // set at JVM startup-time, they should never be subsequently mutated.
 37 // Instead of using pointers to malloc()ed monitors and mutexes we should consider
 38 // eliminating the indirection and using instances instead.
 39 // Consider using GCC&#39;s __read_mostly.
 40 
 41 Mutex*   Patching_lock                = NULL;
<span class="line-added"> 42 Mutex*   CompiledMethod_lock          = NULL;</span>
 43 Monitor* SystemDictionary_lock        = NULL;
 44 Mutex*   ProtectionDomainSet_lock     = NULL;
 45 Mutex*   SharedDictionary_lock        = NULL;
 46 Mutex*   Module_lock                  = NULL;
 47 Mutex*   CompiledIC_lock              = NULL;
 48 Mutex*   InlineCacheBuffer_lock       = NULL;
 49 Mutex*   VMStatistic_lock             = NULL;









 50 Mutex*   JNIHandleBlockFreeList_lock  = NULL;
 51 Mutex*   JmethodIdCreation_lock       = NULL;
 52 Mutex*   JfieldIdCreation_lock        = NULL;
 53 Monitor* JNICritical_lock             = NULL;
 54 Mutex*   JvmtiThreadState_lock        = NULL;
 55 Monitor* Heap_lock                    = NULL;
 56 Mutex*   ExpandHeap_lock              = NULL;
 57 Mutex*   AdapterHandlerLibrary_lock   = NULL;
 58 Mutex*   SignatureHandlerLibrary_lock = NULL;
 59 Mutex*   VtableStubs_lock             = NULL;
 60 Mutex*   SymbolArena_lock             = NULL;
 61 Monitor* StringDedupQueue_lock        = NULL;
 62 Mutex*   StringDedupTable_lock        = NULL;
 63 Monitor* CodeCache_lock               = NULL;
 64 Mutex*   MethodData_lock              = NULL;
 65 Mutex*   TouchedMethodLog_lock        = NULL;
 66 Mutex*   RetData_lock                 = NULL;
 67 Monitor* VMOperationQueue_lock        = NULL;
 68 Monitor* VMOperationRequest_lock      = NULL;

 69 Monitor* Threads_lock                 = NULL;
 70 Mutex*   NonJavaThreadsList_lock      = NULL;
<span class="line-added"> 71 Mutex*   NonJavaThreadsListSync_lock  = NULL;</span>
 72 Monitor* CGC_lock                     = NULL;
 73 Monitor* STS_lock                     = NULL;
 74 Monitor* FullGCCount_lock             = NULL;
<span class="line-modified"> 75 Monitor* G1OldGCCount_lock            = NULL;</span>

 76 Mutex*   Shared_DirtyCardQ_lock       = NULL;
 77 Mutex*   MarkStackFreeList_lock       = NULL;
 78 Mutex*   MarkStackChunkList_lock      = NULL;
 79 Mutex*   MonitoringSupport_lock       = NULL;
 80 Mutex*   ParGCRareEvent_lock          = NULL;

 81 Monitor* CGCPhaseManager_lock         = NULL;
 82 Mutex*   Compile_lock                 = NULL;
 83 Monitor* MethodCompileQueue_lock      = NULL;
 84 Monitor* CompileThread_lock           = NULL;
 85 Monitor* Compilation_lock             = NULL;
 86 Mutex*   CompileTaskAlloc_lock        = NULL;
 87 Mutex*   CompileStatistics_lock       = NULL;
 88 Mutex*   DirectivesStack_lock         = NULL;
 89 Mutex*   MultiArray_lock              = NULL;
 90 Monitor* Terminator_lock              = NULL;
<span class="line-added"> 91 Monitor* InitCompleted_lock           = NULL;</span>
 92 Monitor* BeforeExit_lock              = NULL;
 93 Monitor* Notify_lock                  = NULL;
 94 Mutex*   ProfilePrint_lock            = NULL;
 95 Mutex*   ExceptionCache_lock          = NULL;

 96 Mutex*   NMethodSweeperStats_lock     = NULL;
 97 #ifndef PRODUCT
 98 Mutex*   FullGCALot_lock              = NULL;
 99 #endif
100 
101 Mutex*   Debug1_lock                  = NULL;
102 Mutex*   Debug2_lock                  = NULL;
103 Mutex*   Debug3_lock                  = NULL;
104 
105 Mutex*   tty_lock                     = NULL;
106 
107 Mutex*   RawMonitor_lock              = NULL;
108 Mutex*   PerfDataMemAlloc_lock        = NULL;
109 Mutex*   PerfDataManager_lock         = NULL;
110 Mutex*   OopMapCacheAlloc_lock        = NULL;
111 
112 Mutex*   FreeList_lock                = NULL;
113 Mutex*   OldSets_lock                 = NULL;
114 Monitor* RootRegionScan_lock          = NULL;
115 


116 Mutex*   Management_lock              = NULL;
117 Monitor* Service_lock                 = NULL;
<span class="line-added">118 Monitor* Notification_lock            = NULL;</span>
119 Monitor* PeriodicTask_lock            = NULL;
120 Monitor* RedefineClasses_lock         = NULL;
<span class="line-added">121 Mutex*   Verify_lock                  = NULL;</span>
122 
123 #if INCLUDE_JFR
124 Mutex*   JfrStacktrace_lock           = NULL;
125 Monitor* JfrMsg_lock                  = NULL;
126 Mutex*   JfrBuffer_lock               = NULL;
127 Mutex*   JfrStream_lock               = NULL;
128 Monitor* JfrThreadSampler_lock        = NULL;
129 #endif
130 
131 #if INCLUDE_TSAN
132 Mutex*   TsanOopMap_lock              = NULL;
133 #endif
134 
135 #ifndef SUPPORTS_NATIVE_CX8
136 Mutex*   UnsafeJlong_lock             = NULL;
137 #endif
<span class="line-modified">138 Mutex*   CodeHeapStateAnalytics_lock  = NULL;</span>
139 
140 Mutex*   MetaspaceExpand_lock         = NULL;
141 Mutex*   ClassLoaderDataGraph_lock    = NULL;
142 Monitor* ThreadsSMRDelete_lock        = NULL;
<span class="line-added">143 Mutex*   ThreadIdTableCreate_lock     = NULL;</span>
144 Mutex*   SharedDecoder_lock           = NULL;
145 Mutex*   DCmdFactory_lock             = NULL;
146 #if INCLUDE_NMT
147 Mutex*   NMTQuery_lock                = NULL;
148 #endif
<span class="line-modified">149 #if INCLUDE_CDS</span>
<span class="line-added">150 #if INCLUDE_JVMTI</span>
151 Mutex*   CDSClassFileStream_lock      = NULL;
152 #endif
<span class="line-added">153 Mutex*   DumpTimeTable_lock           = NULL;</span>
<span class="line-added">154 #endif // INCLUDE_CDS</span>
<span class="line-added">155 </span>
<span class="line-added">156 #if INCLUDE_JVMCI</span>
<span class="line-added">157 Monitor* JVMCI_lock                   = NULL;</span>
<span class="line-added">158 #endif</span>
<span class="line-added">159 </span>
160 
161 #define MAX_NUM_MUTEX 128
<span class="line-modified">162 static Mutex* _mutex_array[MAX_NUM_MUTEX];</span>
163 static int _num_mutex;
164 
165 #ifdef ASSERT
<span class="line-modified">166 void assert_locked_or_safepoint(const Mutex* lock) {</span>
167   // check if this thread owns the lock (common case)

168   assert(lock != NULL, &quot;Need non-NULL lock&quot;);
169   if (lock-&gt;owned_by_self()) return;
170   if (SafepointSynchronize::is_at_safepoint()) return;
171   if (!Universe::is_fully_initialized()) return;
172   // see if invoker of VM operation owns it
173   VM_Operation* op = VMThread::vm_operation();
174   if (op != NULL &amp;&amp; op-&gt;calling_thread() == lock-&gt;owner()) return;
175   fatal(&quot;must own lock %s&quot;, lock-&gt;name());
176 }
177 
178 // a weaker assertion than the above
<span class="line-modified">179 void assert_locked_or_safepoint_weak(const Mutex* lock) {</span>

180   assert(lock != NULL, &quot;Need non-NULL lock&quot;);
181   if (lock-&gt;is_locked()) return;
182   if (SafepointSynchronize::is_at_safepoint()) return;
183   if (!Universe::is_fully_initialized()) return;
184   fatal(&quot;must own lock %s&quot;, lock-&gt;name());
185 }
186 
187 // a stronger assertion than the above
<span class="line-modified">188 void assert_lock_strong(const Mutex* lock) {</span>

189   assert(lock != NULL, &quot;Need non-NULL lock&quot;);
190   if (lock-&gt;owned_by_self()) return;
191   fatal(&quot;must own lock %s&quot;, lock-&gt;name());
192 }
<span class="line-added">193 </span>
<span class="line-added">194 void assert_locked_or_safepoint_or_handshake(const Mutex* lock, const JavaThread* thread) {</span>
<span class="line-added">195   if (Thread::current()-&gt;is_VM_thread() &amp;&amp; thread-&gt;is_vmthread_processing_handshake()) return;</span>
<span class="line-added">196   assert_locked_or_safepoint(lock);</span>
<span class="line-added">197 }</span>
198 #endif
199 
200 #define def(var, type, pri, vm_block, safepoint_check_allowed ) {      \
<span class="line-modified">201   var = new type(Mutex::pri, #var, vm_block, Mutex::safepoint_check_allowed); \</span>
202   assert(_num_mutex &lt; MAX_NUM_MUTEX, &quot;increase MAX_NUM_MUTEX&quot;);        \
203   _mutex_array[_num_mutex++] = var;                                      \
204 }
205 
206 // Using Padded subclasses to prevent false sharing of these global monitors and mutexes.
207 void mutex_init() {
<span class="line-modified">208   def(tty_lock                     , PaddedMutex  , tty,         true,  _safepoint_check_never);      // allow to lock in VM</span>



209 
<span class="line-modified">210   def(CGC_lock                     , PaddedMonitor, special,     true,  _safepoint_check_never);      // coordinate between fore- and background GC</span>
<span class="line-modified">211   def(STS_lock                     , PaddedMonitor, leaf,        true,  _safepoint_check_never);</span>
212 
<span class="line-modified">213   def(FullGCCount_lock             , PaddedMonitor, leaf,        true,  _safepoint_check_never);      // in support of ExplicitGCInvokesConcurrent</span>





214   if (UseG1GC) {
<span class="line-modified">215     def(G1OldGCCount_lock          , PaddedMonitor, leaf,        true,  _safepoint_check_always);</span>
216 
<span class="line-modified">217     def(Shared_DirtyCardQ_lock     , PaddedMutex  , access + 1,  true,  _safepoint_check_never);</span>

218 
<span class="line-modified">219     def(FreeList_lock              , PaddedMutex  , leaf     ,   true,  _safepoint_check_never);</span>
<span class="line-modified">220     def(OldSets_lock               , PaddedMutex  , leaf     ,   true,  _safepoint_check_never);</span>
<span class="line-modified">221     def(RootRegionScan_lock        , PaddedMonitor, leaf     ,   true,  _safepoint_check_never);</span>
222 
<span class="line-modified">223     def(StringDedupQueue_lock      , PaddedMonitor, leaf,        true,  _safepoint_check_never);</span>
<span class="line-modified">224     def(StringDedupTable_lock      , PaddedMutex  , leaf,        true,  _safepoint_check_never);</span>
225 
<span class="line-modified">226     def(MarkStackFreeList_lock     , PaddedMutex  , leaf     ,   true,  _safepoint_check_never);</span>
<span class="line-modified">227     def(MarkStackChunkList_lock    , PaddedMutex  , leaf     ,   true,  _safepoint_check_never);</span>
228 
<span class="line-modified">229     def(MonitoringSupport_lock     , PaddedMutex  , native   ,   true,  _safepoint_check_never);      // used for serviceability monitoring support</span>
230   }
231   if (UseShenandoahGC) {
<span class="line-modified">232     def(StringDedupQueue_lock      , PaddedMonitor, leaf,        true,  _safepoint_check_never);</span>
<span class="line-added">233     def(StringDedupTable_lock      , PaddedMutex  , leaf + 1,    true,  _safepoint_check_never);</span>
<span class="line-added">234   }</span>
<span class="line-added">235   def(ParGCRareEvent_lock          , PaddedMutex  , leaf     ,   true,  _safepoint_check_always);</span>
<span class="line-added">236   def(CGCPhaseManager_lock         , PaddedMonitor, leaf,        false, _safepoint_check_always);</span>
<span class="line-added">237   def(CodeCache_lock               , PaddedMonitor, special,     true,  _safepoint_check_never);</span>
<span class="line-added">238   def(RawMonitor_lock              , PaddedMutex  , special,     true,  _safepoint_check_never);</span>
<span class="line-added">239   def(OopMapCacheAlloc_lock        , PaddedMutex  , leaf,        true,  _safepoint_check_always); // used for oop_map_cache allocation.</span>
<span class="line-added">240 </span>
<span class="line-added">241   def(MetaspaceExpand_lock         , PaddedMutex  , leaf-1,      true,  _safepoint_check_never);</span>
<span class="line-added">242   def(ClassLoaderDataGraph_lock    , PaddedMutex  , nonleaf,     false, _safepoint_check_always);</span>
243 
<span class="line-modified">244   def(Patching_lock                , PaddedMutex  , special,     true,  _safepoint_check_never);      // used for safepointing and code patching.</span>
<span class="line-modified">245   def(CompiledMethod_lock          , PaddedMutex  , special-1,   true,  _safepoint_check_never);</span>
<span class="line-added">246   def(Service_lock                 , PaddedMonitor, special,     true,  _safepoint_check_never);      // used for service thread operations</span>
<span class="line-added">247 </span>
<span class="line-added">248   if (UseNotificationThread) {</span>
<span class="line-added">249     def(Notification_lock            , PaddedMonitor, special,     true,  _safepoint_check_never);  // used for notification thread operations</span>
<span class="line-added">250   } else {</span>
<span class="line-added">251     Notification_lock = Service_lock;</span>
252   }
<span class="line-modified">253 </span>
<span class="line-modified">254   def(JmethodIdCreation_lock       , PaddedMutex  , leaf,        true,  _safepoint_check_never); // used for creating jmethodIDs.</span>
<span class="line-modified">255 </span>
<span class="line-modified">256   def(SystemDictionary_lock        , PaddedMonitor, leaf,        true,  _safepoint_check_always);</span>
<span class="line-modified">257   def(ProtectionDomainSet_lock     , PaddedMutex  , leaf-1,      true,  _safepoint_check_never);</span>
<span class="line-modified">258   def(SharedDictionary_lock        , PaddedMutex  , leaf,        true,  _safepoint_check_always);</span>
<span class="line-modified">259   def(Module_lock                  , PaddedMutex  , leaf+2,      false, _safepoint_check_always);</span>
<span class="line-modified">260   def(InlineCacheBuffer_lock       , PaddedMutex  , leaf,        true,  _safepoint_check_never);</span>
<span class="line-modified">261   def(VMStatistic_lock             , PaddedMutex  , leaf,        false, _safepoint_check_always);</span>
<span class="line-modified">262   def(ExpandHeap_lock              , PaddedMutex  , leaf,        true,  _safepoint_check_always); // Used during compilation by VM thread</span>
<span class="line-modified">263   def(JNIHandleBlockFreeList_lock  , PaddedMutex  , leaf-1,      true,  _safepoint_check_never);      // handles are used by VM thread</span>
<span class="line-modified">264   def(SignatureHandlerLibrary_lock , PaddedMutex  , leaf,        false, _safepoint_check_always);</span>
<span class="line-modified">265   def(SymbolArena_lock             , PaddedMutex  , leaf+2,      true,  _safepoint_check_never);</span>
<span class="line-modified">266   def(ProfilePrint_lock            , PaddedMutex  , leaf,        false, _safepoint_check_always); // serial profile printing</span>
<span class="line-modified">267   def(ExceptionCache_lock          , PaddedMutex  , leaf,        false, _safepoint_check_always); // serial profile printing</span>
<span class="line-modified">268   def(Debug1_lock                  , PaddedMutex  , leaf,        true,  _safepoint_check_never);</span>












269 #ifndef PRODUCT
<span class="line-modified">270   def(FullGCALot_lock              , PaddedMutex  , leaf,        false, _safepoint_check_always); // a lock to make FullGCALot MT safe</span>
271 #endif
<span class="line-modified">272   def(BeforeExit_lock              , PaddedMonitor, leaf,        true,  _safepoint_check_always);</span>
<span class="line-modified">273   def(PerfDataMemAlloc_lock        , PaddedMutex  , leaf,        true,  _safepoint_check_always); // used for allocating PerfData memory for performance data</span>
<span class="line-modified">274   def(PerfDataManager_lock         , PaddedMutex  , leaf,        true,  _safepoint_check_always); // used for synchronized access to PerfDataManager resources</span>
<span class="line-modified">275 </span>
<span class="line-modified">276   def(Threads_lock                 , PaddedMonitor, barrier,     true,  _safepoint_check_always);  // Used for safepoint protocol.</span>
<span class="line-modified">277   def(NonJavaThreadsList_lock      , PaddedMutex,   leaf,        true,  _safepoint_check_never);</span>
<span class="line-modified">278   def(NonJavaThreadsListSync_lock  , PaddedMutex,   leaf,        true,  _safepoint_check_never);</span>
<span class="line-modified">279 </span>
<span class="line-modified">280   def(VMOperationQueue_lock        , PaddedMonitor, nonleaf,     true,  _safepoint_check_never);  // VM_thread allowed to block on these</span>
<span class="line-modified">281   def(VMOperationRequest_lock      , PaddedMonitor, nonleaf,     true,  _safepoint_check_always);</span>
<span class="line-modified">282   def(RetData_lock                 , PaddedMutex  , nonleaf,     false, _safepoint_check_always);</span>
<span class="line-modified">283   def(Terminator_lock              , PaddedMonitor, nonleaf,     true,  _safepoint_check_always);</span>
<span class="line-modified">284   def(InitCompleted_lock           , PaddedMonitor, leaf,        true,  _safepoint_check_never);</span>
<span class="line-modified">285   def(VtableStubs_lock             , PaddedMutex  , nonleaf,     true,  _safepoint_check_never);</span>
<span class="line-modified">286   def(Notify_lock                  , PaddedMonitor, nonleaf,     true,  _safepoint_check_always);</span>
<span class="line-modified">287   def(JNICritical_lock             , PaddedMonitor, nonleaf,     true,  _safepoint_check_always); // used for JNI critical regions</span>
<span class="line-modified">288   def(AdapterHandlerLibrary_lock   , PaddedMutex  , nonleaf,     true,  _safepoint_check_always);</span>
<span class="line-modified">289 </span>
<span class="line-modified">290   def(Heap_lock                    , PaddedMonitor, nonleaf+1,   false, _safepoint_check_sometimes);  // Doesn&#39;t safepoint check during termination.</span>
<span class="line-modified">291   def(JfieldIdCreation_lock        , PaddedMutex  , nonleaf+1,   true,  _safepoint_check_always); // jfieldID, Used in VM_Operation</span>
<span class="line-modified">292 </span>
<span class="line-modified">293   def(CompiledIC_lock              , PaddedMutex  , nonleaf+2,   false, _safepoint_check_never);      // locks VtableStubs_lock, InlineCacheBuffer_lock</span>
<span class="line-modified">294   def(CompileTaskAlloc_lock        , PaddedMutex  , nonleaf+2,   true,  _safepoint_check_always);</span>
<span class="line-modified">295   def(CompileStatistics_lock       , PaddedMutex  , nonleaf+2,   false, _safepoint_check_always);</span>
<span class="line-modified">296   def(DirectivesStack_lock         , PaddedMutex  , special,     true,  _safepoint_check_never);</span>
<span class="line-modified">297   def(MultiArray_lock              , PaddedMutex  , nonleaf+2,   false, _safepoint_check_always);</span>
<span class="line-modified">298 </span>
<span class="line-modified">299   def(JvmtiThreadState_lock        , PaddedMutex  , nonleaf+2,   false, _safepoint_check_always); // Used by JvmtiThreadState/JvmtiEventController</span>
<span class="line-modified">300   def(Management_lock              , PaddedMutex  , nonleaf+2,   false, _safepoint_check_always); // used for JVM management</span>
<span class="line-modified">301 </span>
<span class="line-modified">302   def(Compile_lock                 , PaddedMutex  , nonleaf+3,   false, _safepoint_check_always);</span>
<span class="line-modified">303   def(MethodData_lock              , PaddedMutex  , nonleaf+3,   false, _safepoint_check_always);</span>
<span class="line-modified">304   def(TouchedMethodLog_lock        , PaddedMutex  , nonleaf+3,   false, _safepoint_check_always);</span>
<span class="line-modified">305 </span>
<span class="line-modified">306   def(MethodCompileQueue_lock      , PaddedMonitor, nonleaf+4,   false, _safepoint_check_always);</span>
<span class="line-modified">307   def(Debug2_lock                  , PaddedMutex  , nonleaf+4,   true,  _safepoint_check_never);</span>
<span class="line-modified">308   def(Debug3_lock                  , PaddedMutex  , nonleaf+4,   true,  _safepoint_check_never);</span>
<span class="line-modified">309   def(CompileThread_lock           , PaddedMonitor, nonleaf+5,   false, _safepoint_check_always);</span>
<span class="line-modified">310   def(PeriodicTask_lock            , PaddedMonitor, nonleaf+5,   true,  _safepoint_check_always);</span>
<span class="line-modified">311   def(RedefineClasses_lock         , PaddedMonitor, nonleaf+5,   true,  _safepoint_check_always);</span>
<span class="line-modified">312   def(Verify_lock                  , PaddedMutex,   nonleaf+5,   true,  _safepoint_check_always);</span>






313 
314   if (WhiteBoxAPI) {
<span class="line-modified">315     def(Compilation_lock           , PaddedMonitor, leaf,        false, _safepoint_check_never);</span>
316   }
317 
318 #if INCLUDE_JFR
<span class="line-modified">319   def(JfrMsg_lock                  , PaddedMonitor, leaf,        true,  _safepoint_check_always);</span>
<span class="line-modified">320   def(JfrBuffer_lock               , PaddedMutex  , leaf,        true,  _safepoint_check_never);</span>
<span class="line-modified">321   def(JfrStream_lock               , PaddedMutex  , nonleaf + 1, false, _safepoint_check_never);</span>
<span class="line-modified">322   def(JfrStacktrace_lock           , PaddedMutex  , special,     true,  _safepoint_check_never);</span>
<span class="line-modified">323   def(JfrThreadSampler_lock        , PaddedMonitor, leaf,        true,  _safepoint_check_never);</span>
324 #endif
325 
326   TSAN_RUNTIME_ONLY(
<span class="line-modified">327     def(TsanOopMap_lock            , PaddedMutex  , special,     true,  _safepoint_check_never);</span>
328   );
329 
330 #ifndef SUPPORTS_NATIVE_CX8
<span class="line-modified">331   def(UnsafeJlong_lock             , PaddedMutex  , special,     false, _safepoint_check_never);</span>
332 #endif
333 
<span class="line-modified">334   def(CodeHeapStateAnalytics_lock  , PaddedMutex  , leaf,        true,  _safepoint_check_never);</span>
<span class="line-modified">335   def(NMethodSweeperStats_lock     , PaddedMutex  , special,     true,  _safepoint_check_never);</span>
<span class="line-modified">336   def(ThreadsSMRDelete_lock        , PaddedMonitor, special,     true,  _safepoint_check_never);</span>
<span class="line-modified">337   def(ThreadIdTableCreate_lock     , PaddedMutex  , leaf,        false, _safepoint_check_always);</span>
<span class="line-modified">338   def(SharedDecoder_lock           , PaddedMutex  , native,      true,  _safepoint_check_never);</span>
<span class="line-modified">339   def(DCmdFactory_lock             , PaddedMutex  , leaf,        true,  _safepoint_check_never);</span>
340 #if INCLUDE_NMT
<span class="line-modified">341   def(NMTQuery_lock                , PaddedMutex  , max_nonleaf, false, _safepoint_check_always);</span>
342 #endif
<span class="line-modified">343 #if INCLUDE_CDS</span>
<span class="line-modified">344 #if INCLUDE_JVMTI</span>
<span class="line-added">345   def(CDSClassFileStream_lock      , PaddedMutex  , max_nonleaf, false, _safepoint_check_always);</span>
<span class="line-added">346 #endif</span>
<span class="line-added">347   def(DumpTimeTable_lock           , PaddedMutex  , leaf,        true,  _safepoint_check_never);</span>
<span class="line-added">348 #endif // INCLUDE_CDS</span>
<span class="line-added">349 </span>
<span class="line-added">350 #if INCLUDE_JVMCI</span>
<span class="line-added">351   def(JVMCI_lock                   , PaddedMonitor, nonleaf+2,   true,  _safepoint_check_always);</span>
352 #endif
353 }
354 
<span class="line-modified">355 GCMutexLocker::GCMutexLocker(Mutex* mutex) {</span>
356   if (SafepointSynchronize::is_at_safepoint()) {
357     _locked = false;
358   } else {
359     _mutex = mutex;
360     _locked = true;
361     _mutex-&gt;lock();
362   }
363 }
364 
365 // Print all mutexes/monitors that are currently owned by a thread; called
366 // by fatal error handler.
367 void print_owned_locks_on_error(outputStream* st) {
368   st-&gt;print(&quot;VM Mutex/Monitor currently owned by a thread: &quot;);
369   bool none = true;
370   for (int i = 0; i &lt; _num_mutex; i++) {
371      // see if it has an owner
372      if (_mutex_array[i]-&gt;owner() != NULL) {
373        if (none) {
374           // print format used by Mutex::print_on_error()
375           st-&gt;print_cr(&quot; ([mutex/lock_event])&quot;);
</pre>
</td>
</tr>
</table>
<center><a href="init.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="mutexLocker.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
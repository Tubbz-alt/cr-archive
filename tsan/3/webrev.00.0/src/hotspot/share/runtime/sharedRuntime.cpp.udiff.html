<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Udiff src/hotspot/share/runtime/sharedRuntime.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="mutexLocker.hpp.udiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="sharedRuntime.hpp.udiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/runtime/sharedRuntime.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-new-header">@@ -1,7 +1,7 @@</span>
  /*
<span class="udiff-line-modified-removed">-  * Copyright (c) 1997, 2019, Oracle and/or its affiliates. All rights reserved.</span>
<span class="udiff-line-modified-added">+  * Copyright (c) 1997, 2020, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -55,11 +55,10 @@</span>
  #include &quot;prims/methodHandles.hpp&quot;
  #include &quot;prims/nativeLookup.hpp&quot;
  #include &quot;runtime/arguments.hpp&quot;
  #include &quot;runtime/atomic.hpp&quot;
  #include &quot;runtime/biasedLocking.hpp&quot;
<span class="udiff-line-removed">- #include &quot;runtime/compilationPolicy.hpp&quot;</span>
  #include &quot;runtime/frame.inline.hpp&quot;
  #include &quot;runtime/handles.inline.hpp&quot;
  #include &quot;runtime/init.hpp&quot;
  #include &quot;runtime/interfaceSupport.inline.hpp&quot;
  #include &quot;runtime/java.hpp&quot;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -766,22 +765,13 @@</span>
    // Increment counter for hs_err file reporting
    Atomic::inc(&amp;Exceptions::_stack_overflow_errors);
    throw_and_post_jvmti_exception(thread, exception);
  }
  
<span class="udiff-line-removed">- #if INCLUDE_JVMCI</span>
<span class="udiff-line-removed">- address SharedRuntime::deoptimize_for_implicit_exception(JavaThread* thread, address pc, CompiledMethod* nm, int deopt_reason) {</span>
<span class="udiff-line-removed">-   assert(deopt_reason &gt; Deoptimization::Reason_none &amp;&amp; deopt_reason &lt; Deoptimization::Reason_LIMIT, &quot;invalid deopt reason&quot;);</span>
<span class="udiff-line-removed">-   thread-&gt;set_jvmci_implicit_exception_pc(pc);</span>
<span class="udiff-line-removed">-   thread-&gt;set_pending_deoptimization(Deoptimization::make_trap_request((Deoptimization::DeoptReason)deopt_reason, Deoptimization::Action_reinterpret));</span>
<span class="udiff-line-removed">-   return (SharedRuntime::deopt_blob()-&gt;implicit_exception_uncommon_trap());</span>
<span class="udiff-line-removed">- }</span>
<span class="udiff-line-removed">- #endif // INCLUDE_JVMCI</span>
<span class="udiff-line-removed">- </span>
  address SharedRuntime::continuation_for_implicit_exception(JavaThread* thread,
                                                             address pc,
<span class="udiff-line-modified-removed">-                                                            SharedRuntime::ImplicitExceptionKind exception_kind)</span>
<span class="udiff-line-modified-added">+                                                            ImplicitExceptionKind exception_kind)</span>
  {
    address target_pc = NULL;
  
    if (Interpreter::contains(pc)) {
  #ifdef CC_INTERP
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -878,23 +868,11 @@</span>
            }
  
  #ifndef PRODUCT
            _implicit_null_throws++;
  #endif
<span class="udiff-line-modified-removed">- #if INCLUDE_JVMCI</span>
<span class="udiff-line-removed">-           if (cm-&gt;is_compiled_by_jvmci() &amp;&amp; cm-&gt;pc_desc_at(pc) != NULL) {</span>
<span class="udiff-line-removed">-             // If there&#39;s no PcDesc then we&#39;ll die way down inside of</span>
<span class="udiff-line-removed">-             // deopt instead of just getting normal error reporting,</span>
<span class="udiff-line-removed">-             // so only go there if it will succeed.</span>
<span class="udiff-line-removed">-             return deoptimize_for_implicit_exception(thread, pc, cm, Deoptimization::Reason_null_check);</span>
<span class="udiff-line-removed">-           } else {</span>
<span class="udiff-line-removed">- #endif // INCLUDE_JVMCI</span>
<span class="udiff-line-removed">-           assert (cm-&gt;is_nmethod(), &quot;Expect nmethod&quot;);</span>
<span class="udiff-line-removed">-           target_pc = ((nmethod*)cm)-&gt;continuation_for_implicit_exception(pc);</span>
<span class="udiff-line-removed">- #if INCLUDE_JVMCI</span>
<span class="udiff-line-removed">-           }</span>
<span class="udiff-line-removed">- #endif // INCLUDE_JVMCI</span>
<span class="udiff-line-modified-added">+           target_pc = cm-&gt;continuation_for_implicit_null_exception(pc);</span>
            // If there&#39;s an unexpected fault, target_pc might be NULL,
            // in which case we want to fall through into the normal
            // error handling code.
          }
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -906,19 +884,11 @@</span>
          CompiledMethod* cm = CodeCache::find_compiled(pc);
          guarantee(cm != NULL, &quot;must have containing compiled method for implicit division-by-zero exceptions&quot;);
  #ifndef PRODUCT
          _implicit_div0_throws++;
  #endif
<span class="udiff-line-modified-removed">- #if INCLUDE_JVMCI</span>
<span class="udiff-line-removed">-         if (cm-&gt;is_compiled_by_jvmci() &amp;&amp; cm-&gt;pc_desc_at(pc) != NULL) {</span>
<span class="udiff-line-removed">-           return deoptimize_for_implicit_exception(thread, pc, cm, Deoptimization::Reason_div0_check);</span>
<span class="udiff-line-removed">-         } else {</span>
<span class="udiff-line-removed">- #endif // INCLUDE_JVMCI</span>
<span class="udiff-line-removed">-         target_pc = cm-&gt;continuation_for_implicit_exception(pc);</span>
<span class="udiff-line-removed">- #if INCLUDE_JVMCI</span>
<span class="udiff-line-removed">-         }</span>
<span class="udiff-line-removed">- #endif // INCLUDE_JVMCI</span>
<span class="udiff-line-modified-added">+         target_pc = cm-&gt;continuation_for_implicit_div0_exception(pc);</span>
          // If there&#39;s an unexpected fault, target_pc might be NULL,
          // in which case we want to fall through into the normal
          // error handling code.
          break; // fall through
        }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1056,11 +1026,10 @@</span>
  //     address instead of the method that&#39;s being called. This also matches
  //     the entry/exit convention that TSAN uses for C++.
  // We use JRT_ENTRY since call_VM_leaf doesn&#39;t set _last_Java_sp that we need.
  JRT_ENTRY(void, SharedRuntime::tsan_interp_method_entry(JavaThread *thread))
    DEBUG_ONLY(NoSafepointVerifier nsv;)
<span class="udiff-line-removed">-   DEBUG_ONLY(NoAllocVerifier nav;)</span>
    DEBUG_ONLY(NoHandleMark nhm;)
    assert(ThreadSanitizer, &quot;Need -XX:+ThreadSanitizer&quot;);
  
    RegisterMap unused_reg_map(thread, false);
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1094,44 +1063,44 @@</span>
    assert(thread != NULL, &quot;null thread&quot;);
    assert(obj != NULL, &quot;null oop&quot;);
    assert(oopDesc::is_oop(obj), &quot;invalid oop&quot;);
  
    TsanOopMap::add_oop(obj);
<span class="udiff-line-modified-removed">-   __tsan_java_mutex_lock((julong)(address)obj);</span>
<span class="udiff-line-modified-added">+   __tsan_java_mutex_lock((julong)(oopDesc*)obj);</span>
  }
  
  void SharedRuntime::tsan_oop_unlock(Thread *thread, oop obj) {
    DEBUG_ONLY(NoSafepointVerifier nsv;)
    assert(ThreadSanitizer, &quot;Need -XX:+ThreadSanitizer&quot;);
    assert(thread != NULL, &quot;null thread&quot;);
    assert(obj != NULL, &quot;null oop&quot;);
    assert(oopDesc::is_oop(obj), &quot;invalid oop&quot;);
    assert(TsanOopMap::exists(obj), &quot;oop seen in unlock but not tracked&quot;);
  
<span class="udiff-line-modified-removed">-   __tsan_java_mutex_unlock((julong)(address)obj);</span>
<span class="udiff-line-modified-added">+   __tsan_java_mutex_unlock((julong)(oopDesc*)obj);</span>
  }
  
  void SharedRuntime::tsan_oop_rec_lock(Thread* thread, oop obj, int rec) {
    DEBUG_ONLY(NoSafepointVerifier nsv;)
    assert(ThreadSanitizer, &quot;Need -XX:+ThreadSanitizer&quot;);
    assert(thread != NULL, &quot;null thread&quot;);
    assert(obj != NULL, &quot;null oop&quot;);
    assert(oopDesc::is_oop(obj), &quot;invalid oop&quot;);
  
    TsanOopMap::add_oop(obj);
<span class="udiff-line-modified-removed">-   __tsan_java_mutex_lock_rec((julong)(address)obj, rec);</span>
<span class="udiff-line-modified-added">+   __tsan_java_mutex_lock_rec((julong)(oopDesc*)obj, rec);</span>
  }
  
  int SharedRuntime::tsan_oop_rec_unlock(Thread *thread, oop obj) {
    DEBUG_ONLY(NoSafepointVerifier nsv;)
    assert(ThreadSanitizer, &quot;Need -XX:+ThreadSanitizer&quot;);
    assert(thread != NULL, &quot;null thread&quot;);
    assert(obj != NULL, &quot;null oop&quot;);
    assert(oopDesc::is_oop(obj), &quot;invalid oop&quot;);
    assert(TsanOopMap::exists(obj), &quot;oop seen in unlock but not tracked&quot;);
  
<span class="udiff-line-modified-removed">-   return __tsan_java_mutex_unlock_rec((julong)(address)obj);</span>
<span class="udiff-line-modified-added">+   return __tsan_java_mutex_unlock_rec((julong)(oopDesc*)obj);</span>
  }
  
  JRT_LEAF(void, SharedRuntime::tsan_interp_lock(JavaThread* thread,
                                                 BasicObjectLock* elem))
    DEBUG_ONLY(thread-&gt;last_frame().interpreter_frame_verify_monitor(elem);)
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1225,11 +1194,11 @@</span>
    vframeStream vfst(thread, true);  // Do not skip and javaCalls
  
    return find_callee_info_helper(thread, vfst, bc, callinfo, THREAD);
  }
  
<span class="udiff-line-modified-removed">- methodHandle SharedRuntime::extract_attached_method(vframeStream&amp; vfst) {</span>
<span class="udiff-line-modified-added">+ Method* SharedRuntime::extract_attached_method(vframeStream&amp; vfst) {</span>
    CompiledMethod* caller = vfst.nm();
  
    nmethodLocker caller_lock(caller);
  
    address pc = vfst.frame_pc();
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1258,13 +1227,13 @@</span>
  
    Bytecode_invoke bytecode(caller, bci);
    int bytecode_index = bytecode.index();
    bc = bytecode.invoke_code();
  
<span class="udiff-line-modified-removed">-   methodHandle attached_method = extract_attached_method(vfst);</span>
<span class="udiff-line-modified-added">+   methodHandle attached_method(THREAD, extract_attached_method(vfst));</span>
    if (attached_method.not_null()) {
<span class="udiff-line-modified-removed">-     methodHandle callee = bytecode.static_target(CHECK_NH);</span>
<span class="udiff-line-modified-added">+     Method* callee = bytecode.static_target(CHECK_NH);</span>
      vmIntrinsics::ID id = callee-&gt;intrinsic_id();
      // When VM replaces MH.invokeBasic/linkTo* call with a direct/virtual call,
      // it attaches statically resolved method to the call site.
      if (MethodHandles::is_signature_polymorphic(id) &amp;&amp;
          MethodHandles::is_signature_polymorphic_intrinsic(id)) {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1308,12 +1277,12 @@</span>
      frame stubFrame   = thread-&gt;last_frame();
      // Caller-frame is a compiled frame
      frame callerFrame = stubFrame.sender(&amp;reg_map2);
  
      if (attached_method.is_null()) {
<span class="udiff-line-modified-removed">-       methodHandle callee = bytecode.static_target(CHECK_NH);</span>
<span class="udiff-line-modified-removed">-       if (callee.is_null()) {</span>
<span class="udiff-line-modified-added">+       Method* callee = bytecode.static_target(CHECK_NH);</span>
<span class="udiff-line-modified-added">+       if (callee == NULL) {</span>
          THROW_(vmSymbols::java_lang_NoSuchMethodException(), nullHandle);
        }
      }
  
      // Retrieve from a compiled argument list
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1347,11 +1316,10 @@</span>
        // Klass is already loaded.
        constantPoolHandle constants(THREAD, caller-&gt;constants());
        rk = constants-&gt;klass_ref_at(bytecode_index, CHECK_NH);
      }
      Klass* static_receiver_klass = rk;
<span class="udiff-line-removed">-     methodHandle callee = callinfo.selected_method();</span>
      assert(receiver_klass-&gt;is_subtype_of(static_receiver_klass),
             &quot;actual receiver must be subclass of static receiver klass&quot;);
      if (receiver_klass-&gt;is_instance_klass()) {
        if (InstanceKlass::cast(receiver_klass)-&gt;is_not_initialized()) {
          tty-&gt;print_cr(&quot;ERROR: Klass not yet initialized!!&quot;);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1385,11 +1353,11 @@</span>
      callee_method = methodHandle(THREAD, fr.entry_frame_call_wrapper()-&gt;callee_method());
    } else {
      Bytecodes::Code bc;
      CallInfo callinfo;
      find_callee_info_helper(thread, vfst, bc, callinfo, CHECK_(methodHandle()));
<span class="udiff-line-modified-removed">-     callee_method = callinfo.selected_method();</span>
<span class="udiff-line-modified-added">+     callee_method = methodHandle(THREAD, callinfo.selected_method());</span>
    }
    assert(callee_method()-&gt;is_method(), &quot;must be&quot;);
    return callee_method;
  }
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1471,10 +1439,11 @@</span>
      // Don&#39;t update call site if callee nmethod was replaced by an other nmethod
      // which may happen when multiply alive nmethod (tiered compilation)
      // will be supported.
      if (!callee_method-&gt;is_old() &amp;&amp;
          (callee == NULL || (callee-&gt;is_in_use() &amp;&amp; callee_method-&gt;code() == callee))) {
<span class="udiff-line-added">+       NoSafepointVerifier nsv;</span>
  #ifdef ASSERT
        // We must not try to patch to jump to an already unloaded method.
        if (dest_entry_point != 0) {
          CodeBlob* cb = CodeCache::find_blob(dest_entry_point);
          assert((cb != NULL) &amp;&amp; cb-&gt;is_compiled() &amp;&amp; (((CompiledMethod*)cb) == callee),
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1487,10 +1456,16 @@</span>
            if (!inline_cache-&gt;set_to_monomorphic(virtual_call_info)) {
              return false;
            }
          }
        } else {
<span class="udiff-line-added">+         if (VM_Version::supports_fast_class_init_checks() &amp;&amp;</span>
<span class="udiff-line-added">+             invoke_code == Bytecodes::_invokestatic &amp;&amp;</span>
<span class="udiff-line-added">+             callee_method-&gt;needs_clinit_barrier() &amp;&amp;</span>
<span class="udiff-line-added">+             callee != NULL &amp;&amp; (callee-&gt;is_compiled_by_jvmci() || callee-&gt;is_aot())) {</span>
<span class="udiff-line-added">+           return true; // skip patching for JVMCI or AOT code</span>
<span class="udiff-line-added">+         }</span>
          CompiledStaticCall* ssc = caller_nm-&gt;compiledStaticCall_before(caller_frame.pc());
          if (ssc-&gt;is_clean()) ssc-&gt;set(static_call_info);
        }
      }
    } // unlock CompiledICLocker
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1521,11 +1496,11 @@</span>
    //       b) an exception is thrown if receiver is NULL for non-static calls
    CallInfo call_info;
    Bytecodes::Code invoke_code = Bytecodes::_illegal;
    Handle receiver = find_callee_info(thread, invoke_code,
                                       call_info, CHECK_(methodHandle()));
<span class="udiff-line-modified-removed">-   methodHandle callee_method = call_info.selected_method();</span>
<span class="udiff-line-modified-added">+   methodHandle callee_method(THREAD, call_info.selected_method());</span>
  
    assert((!is_virtual &amp;&amp; invoke_code == Bytecodes::_invokestatic ) ||
           (!is_virtual &amp;&amp; invoke_code == Bytecodes::_invokespecial) ||
           (!is_virtual &amp;&amp; invoke_code == Bytecodes::_invokehandle ) ||
           (!is_virtual &amp;&amp; invoke_code == Bytecodes::_invokedynamic) ||
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1549,21 +1524,23 @@</span>
      tty-&gt;print_cr(&quot; at pc: &quot; INTPTR_FORMAT &quot; to code: &quot; INTPTR_FORMAT,
                    p2i(caller_frame.pc()), p2i(callee_method-&gt;code()));
    }
  #endif
  
<span class="udiff-line-modified-removed">-   // Do not patch call site for static call to another class</span>
<span class="udiff-line-modified-removed">-   // when the class is not fully initialized.</span>
<span class="udiff-line-modified-removed">-   if (invoke_code == Bytecodes::_invokestatic) {</span>
<span class="udiff-line-modified-removed">-     if (!callee_method-&gt;method_holder()-&gt;is_initialized() &amp;&amp;</span>
<span class="udiff-line-modified-added">+   if (invoke_code == Bytecodes::_invokestatic) {</span>
<span class="udiff-line-modified-added">+     assert(callee_method-&gt;method_holder()-&gt;is_initialized() ||</span>
<span class="udiff-line-modified-added">+            callee_method-&gt;method_holder()-&gt;is_reentrant_initialization(thread),</span>
<span class="udiff-line-modified-added">+            &quot;invalid class initialization state for invoke_static&quot;);</span>
<span class="udiff-line-added">+     if (!VM_Version::supports_fast_class_init_checks() &amp;&amp; callee_method-&gt;needs_clinit_barrier()) {</span>
<span class="udiff-line-added">+       // In order to keep class initialization check, do not patch call</span>
<span class="udiff-line-added">+       // site for static call when the class is not fully initialized.</span>
<span class="udiff-line-added">+       // Proper check is enforced by call site re-resolution on every invocation.</span>
<span class="udiff-line-added">+       //</span>
<span class="udiff-line-added">+       // When fast class initialization checks are supported (VM_Version::supports_fast_class_init_checks() == true),</span>
        // explicit class initialization check is put in nmethod entry (VEP).
        assert(callee_method-&gt;method_holder()-&gt;is_linked(), &quot;must be&quot;);
        return callee_method;
<span class="udiff-line-removed">-     } else {</span>
<span class="udiff-line-removed">-       assert(callee_method-&gt;method_holder()-&gt;is_initialized() ||</span>
<span class="udiff-line-removed">-              callee_method-&gt;method_holder()-&gt;is_reentrant_initialization(thread),</span>
<span class="udiff-line-removed">-              &quot;invalid class initialization state for invoke_static&quot;);</span>
      }
    }
  
    // JSR 292 key invariant:
    // If the resolved method is a MethodHandle invoke target, the call
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1640,11 +1617,23 @@</span>
        caller_frame.is_entry_frame()) {
      Method* callee = thread-&gt;callee_target();
      guarantee(callee != NULL &amp;&amp; callee-&gt;is_method(), &quot;bad handshake&quot;);
      thread-&gt;set_vm_result_2(callee);
      thread-&gt;set_callee_target(NULL);
<span class="udiff-line-modified-removed">-     return callee-&gt;get_c2i_entry();</span>
<span class="udiff-line-modified-added">+     if (caller_frame.is_entry_frame() &amp;&amp; VM_Version::supports_fast_class_init_checks()) {</span>
<span class="udiff-line-added">+       // Bypass class initialization checks in c2i when caller is in native.</span>
<span class="udiff-line-added">+       // JNI calls to static methods don&#39;t have class initialization checks.</span>
<span class="udiff-line-added">+       // Fast class initialization checks are present in c2i adapters and call into</span>
<span class="udiff-line-added">+       // SharedRuntime::handle_wrong_method() on the slow path.</span>
<span class="udiff-line-added">+       //</span>
<span class="udiff-line-added">+       // JVM upcalls may land here as well, but there&#39;s a proper check present in</span>
<span class="udiff-line-added">+       // LinkResolver::resolve_static_call (called from JavaCalls::call_static),</span>
<span class="udiff-line-added">+       // so bypassing it in c2i adapter is benign.</span>
<span class="udiff-line-added">+       return callee-&gt;get_c2i_no_clinit_check_entry();</span>
<span class="udiff-line-added">+     } else {</span>
<span class="udiff-line-added">+       return callee-&gt;get_c2i_entry();</span>
<span class="udiff-line-added">+     }</span>
    }
  
    // Must be compiled to compiled path which is safe to stackwalk
    methodHandle callee_method;
    JRT_BLOCK
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1661,11 +1650,11 @@</span>
  JRT_BLOCK_ENTRY(address, SharedRuntime::handle_wrong_method_abstract(JavaThread* thread))
    // Verbose error message for AbstractMethodError.
    // Get the called method from the invoke bytecode.
    vframeStream vfst(thread, true);
    assert(!vfst.at_end(), &quot;Java frame must exist&quot;);
<span class="udiff-line-modified-removed">-   methodHandle caller(vfst.method());</span>
<span class="udiff-line-modified-added">+   methodHandle caller(thread, vfst.method());</span>
    Bytecode_invoke invoke(caller, vfst.bci());
    DEBUG_ONLY( invoke.verify(); )
  
    // Find the compiled caller frame.
    RegisterMap reg_map(thread);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1675,11 +1664,11 @@</span>
    assert(callerFrame.is_compiled_frame(), &quot;must be&quot;);
  
    // Install exception and return forward entry.
    address res = StubRoutines::throw_AbstractMethodError_entry();
    JRT_BLOCK
<span class="udiff-line-modified-removed">-     methodHandle callee = invoke.static_target(thread);</span>
<span class="udiff-line-modified-added">+     methodHandle callee(thread, invoke.static_target(thread));</span>
      if (!callee.is_null()) {
        oop recv = callerFrame.retrieve_receiver(&amp;reg_map);
        Klass *recv_klass = (recv != NULL) ? recv-&gt;klass() : NULL;
        LinkResolver::throw_abstract_method_error(callee, recv_klass, thread);
        res = StubRoutines::forward_exception_entry();
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1839,11 +1828,11 @@</span>
        tty-&gt;print_cr(&quot; code: &quot; INTPTR_FORMAT, p2i(callee_method-&gt;code()));
      }
      return callee_method;
    }
  
<span class="udiff-line-modified-removed">-   methodHandle callee_method = call_info.selected_method();</span>
<span class="udiff-line-modified-added">+   methodHandle callee_method(thread, call_info.selected_method());</span>
  
  #ifndef PRODUCT
    Atomic::inc(&amp;_ic_miss_ctr);
  
    // Statistics &amp; Tracing
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2091,11 +2080,11 @@</span>
  // We are calling the interpreter via a c2i. Normally this would mean that
  // we were called by a compiled method. However we could have lost a race
  // where we went int -&gt; i2c -&gt; c2i and so the caller could in fact be
  // interpreted. If the caller is compiled we attempt to patch the caller
  // so he no longer calls into the interpreter.
<span class="udiff-line-modified-removed">- IRT_LEAF(void, SharedRuntime::fixup_callers_callsite(Method* method, address caller_pc))</span>
<span class="udiff-line-modified-added">+ JRT_LEAF(void, SharedRuntime::fixup_callers_callsite(Method* method, address caller_pc))</span>
    Method* moop(method);
  
    address entry_point = moop-&gt;from_compiled_entry_no_trampoline();
  
    // It&#39;s possible that deoptimization can occur at a call site which hasn&#39;t
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2160,11 +2149,11 @@</span>
        if (should_fixup_call_destination(destination, entry_point, caller_pc, moop, cb)) {
          call-&gt;set_destination_mt_safe(entry_point);
        }
      }
    }
<span class="udiff-line-modified-removed">- IRT_END</span>
<span class="udiff-line-modified-added">+ JRT_END</span>
  
  
  // same as JVM_Arraycopy, but called directly from compiled code
  JRT_ENTRY(void, SharedRuntime::slow_arraycopy_C(oopDesc* src,  jint src_pos,
                                                  oopDesc* dest, jint dest_pos,
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2214,11 +2203,11 @@</span>
  char* SharedRuntime::generate_class_cast_message(
      Klass* caster_klass, Klass* target_klass, Symbol* target_klass_name) {
    const char* caster_name = caster_klass-&gt;external_name();
  
    assert(target_klass != NULL || target_klass_name != NULL, &quot;one must be provided&quot;);
<span class="udiff-line-modified-removed">-   const char* target_name = target_klass == NULL ? target_klass_name-&gt;as_C_string() :</span>
<span class="udiff-line-modified-added">+   const char* target_name = target_klass == NULL ? target_klass_name-&gt;as_klass_external_name() :</span>
                                                     target_klass-&gt;external_name();
  
    size_t msglen = strlen(caster_name) + strlen(&quot;class &quot;) + strlen(&quot; cannot be cast to class &quot;) + strlen(target_name) + 1;
  
    const char* caster_klass_description = &quot;&quot;;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2273,16 +2262,11 @@</span>
    oop obj(_obj);
    if (PrintBiasedLockingStatistics) {
      Atomic::inc(BiasedLocking::slow_path_entry_count_addr());
    }
    Handle h_obj(THREAD, obj);
<span class="udiff-line-modified-removed">-   if (UseBiasedLocking) {</span>
<span class="udiff-line-removed">-     // Retry fast entry if bias is revoked to avoid unnecessary inflation</span>
<span class="udiff-line-removed">-     ObjectSynchronizer::fast_enter(h_obj, lock, true, CHECK);</span>
<span class="udiff-line-removed">-   } else {</span>
<span class="udiff-line-removed">-     ObjectSynchronizer::slow_enter(h_obj, lock, CHECK);</span>
<span class="udiff-line-removed">-   }</span>
<span class="udiff-line-modified-added">+   ObjectSynchronizer::enter(h_obj, lock, CHECK);</span>
    assert(!HAS_PENDING_EXCEPTION, &quot;Should have no exception here&quot;);
    JRT_BLOCK_END
  JRT_END
  
  // Handles the uncommon cases of monitor unlocking in compiled code
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2309,11 +2293,11 @@</span>
  #endif /* MIGHT_HAVE_PENDING */
  
    {
      // Exit must be non-blocking, and therefore no exceptions can be thrown.
      EXCEPTION_MARK;
<span class="udiff-line-modified-removed">-     ObjectSynchronizer::slow_exit(obj, lock, THREAD);</span>
<span class="udiff-line-modified-added">+     ObjectSynchronizer::exit(obj, lock, THREAD);</span>
    }
  
  #ifdef MIGHT_HAVE_PENDING
    if (pending_excep != NULL) {
      THREAD-&gt;set_pending_exception(pending_excep, pending_file, pending_line);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2429,11 +2413,11 @@</span>
      tty-&gt;cr();
    }
  
   public:
    MethodArityHistogram() {
<span class="udiff-line-modified-removed">-     MutexLockerEx mu(CodeCache_lock, Mutex::_no_safepoint_check_flag);</span>
<span class="udiff-line-modified-added">+     MutexLocker mu(CodeCache_lock, Mutex::_no_safepoint_check_flag);</span>
      _max_arity = _max_size = 0;
      for (int i = 0; i &lt; MAX_ARITY; i++) _arity_histogram[i] = _size_histogram[i] = 0;
      CodeCache::nmethods_do(add_method_to_histogram);
      print_histogram();
    }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2644,13 +2628,13 @@</span>
   public:
    AdapterHandlerTable()
      : BasicHashtable&lt;mtCode&gt;(293, (DumpSharedSpaces ? sizeof(CDSAdapterHandlerEntry) : sizeof(AdapterHandlerEntry))) { }
  
    // Create a new entry suitable for insertion in the table
<span class="udiff-line-modified-removed">-   AdapterHandlerEntry* new_entry(AdapterFingerPrint* fingerprint, address i2c_entry, address c2i_entry, address c2i_unverified_entry) {</span>
<span class="udiff-line-modified-added">+   AdapterHandlerEntry* new_entry(AdapterFingerPrint* fingerprint, address i2c_entry, address c2i_entry, address c2i_unverified_entry, address c2i_no_clinit_check_entry) {</span>
      AdapterHandlerEntry* entry = (AdapterHandlerEntry*)BasicHashtable&lt;mtCode&gt;::new_entry(fingerprint-&gt;compute_hash());
<span class="udiff-line-modified-removed">-     entry-&gt;init(fingerprint, i2c_entry, c2i_entry, c2i_unverified_entry);</span>
<span class="udiff-line-modified-added">+     entry-&gt;init(fingerprint, i2c_entry, c2i_entry, c2i_unverified_entry, c2i_no_clinit_check_entry);</span>
      if (DumpSharedSpaces) {
        ((CDSAdapterHandlerEntry*)entry)-&gt;init();
      }
      return entry;
    }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2795,17 +2779,18 @@</span>
  }
  
  AdapterHandlerEntry* AdapterHandlerLibrary::new_entry(AdapterFingerPrint* fingerprint,
                                                        address i2c_entry,
                                                        address c2i_entry,
<span class="udiff-line-modified-removed">-                                                       address c2i_unverified_entry) {</span>
<span class="udiff-line-modified-removed">-   return _adapters-&gt;new_entry(fingerprint, i2c_entry, c2i_entry, c2i_unverified_entry);</span>
<span class="udiff-line-modified-added">+                                                       address c2i_unverified_entry,</span>
<span class="udiff-line-modified-added">+                                                       address c2i_no_clinit_check_entry) {</span>
<span class="udiff-line-added">+   return _adapters-&gt;new_entry(fingerprint, i2c_entry, c2i_entry, c2i_unverified_entry, c2i_no_clinit_check_entry);</span>
  }
  
  AdapterHandlerEntry* AdapterHandlerLibrary::get_adapter(const methodHandle&amp; method) {
    AdapterHandlerEntry* entry = get_adapter0(method);
<span class="udiff-line-modified-removed">-   if (method-&gt;is_shared()) {</span>
<span class="udiff-line-modified-added">+   if (entry != NULL &amp;&amp; method-&gt;is_shared()) {</span>
      // See comments around Method::link_method()
      MutexLocker mu(AdapterHandlerLibrary_lock);
      if (method-&gt;adapter() == NULL) {
        method-&gt;update_adapter_trampoline(entry);
      }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2813,10 +2798,11 @@</span>
      if (*(int*)trampoline == 0) {
        CodeBuffer buffer(trampoline, (int)SharedRuntime::trampoline_size());
        MacroAssembler _masm(&amp;buffer);
        SharedRuntime::generate_trampoline(&amp;_masm, entry-&gt;get_c2i_entry());
        assert(*(int*)trampoline != 0, &quot;Instruction(s) for trampoline must not be encoded as zeros.&quot;);
<span class="udiff-line-added">+       _masm.flush();</span>
  
        if (PrintInterpreter) {
          Disassembler::decode(buffer.insts_begin(), buffer.insts_end());
        }
      }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2972,10 +2958,11 @@</span>
  address AdapterHandlerEntry::base_address() {
    address base = _i2c_entry;
    if (base == NULL)  base = _c2i_entry;
    assert(base &lt;= _c2i_entry || _c2i_entry == NULL, &quot;&quot;);
    assert(base &lt;= _c2i_unverified_entry || _c2i_unverified_entry == NULL, &quot;&quot;);
<span class="udiff-line-added">+   assert(base &lt;= _c2i_no_clinit_check_entry || _c2i_no_clinit_check_entry == NULL, &quot;&quot;);</span>
    return base;
  }
  
  void AdapterHandlerEntry::relocate(address new_base) {
    address old_base = base_address();
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2985,18 +2972,20 @@</span>
      _i2c_entry += delta;
    if (_c2i_entry != NULL)
      _c2i_entry += delta;
    if (_c2i_unverified_entry != NULL)
      _c2i_unverified_entry += delta;
<span class="udiff-line-added">+   if (_c2i_no_clinit_check_entry != NULL)</span>
<span class="udiff-line-added">+     _c2i_no_clinit_check_entry += delta;</span>
    assert(base_address() == new_base, &quot;&quot;);
  }
  
  
  void AdapterHandlerEntry::deallocate() {
    delete _fingerprint;
  #ifdef ASSERT
<span class="udiff-line-modified-removed">-   if (_saved_code) FREE_C_HEAP_ARRAY(unsigned char, _saved_code);</span>
<span class="udiff-line-modified-added">+   FREE_C_HEAP_ARRAY(unsigned char, _saved_code);</span>
  #endif
  }
  
  
  #ifdef ASSERT
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -3027,15 +3016,21 @@</span>
   * back to java blocking if a safepoint is in progress.
   */
  void AdapterHandlerLibrary::create_native_wrapper(const methodHandle&amp; method) {
    ResourceMark rm;
    nmethod* nm = NULL;
<span class="udiff-line-added">+   address critical_entry = NULL;</span>
  
    assert(method-&gt;is_native(), &quot;must be native&quot;);
    assert(method-&gt;is_method_handle_intrinsic() ||
           method-&gt;has_native_function(), &quot;must have something valid to call!&quot;);
  
<span class="udiff-line-added">+   if (CriticalJNINatives &amp;&amp; !method-&gt;is_method_handle_intrinsic()) {</span>
<span class="udiff-line-added">+     // We perform the I/O with transition to native before acquiring AdapterHandlerLibrary_lock.</span>
<span class="udiff-line-added">+     critical_entry = NativeLookup::lookup_critical_entry(method);</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+ </span>
    {
      // Perform the work while holding the lock, but perform any printing outside the lock
      MutexLocker mu(AdapterHandlerLibrary_lock);
      // See if somebody beat us to it
      if (method-&gt;code() != NULL) {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -3076,14 +3071,19 @@</span>
        // are just trampolines so the argument registers must be outgoing ones.
        const bool is_outgoing = method-&gt;is_method_handle_intrinsic();
        int comp_args_on_stack = SharedRuntime::java_calling_convention(sig_bt, regs, total_args_passed, is_outgoing);
  
        // Generate the compiled-to-native wrapper code
<span class="udiff-line-modified-removed">-       nm = SharedRuntime::generate_native_wrapper(&amp;_masm, method, compile_id, sig_bt, regs, ret_type);</span>
<span class="udiff-line-modified-added">+       nm = SharedRuntime::generate_native_wrapper(&amp;_masm, method, compile_id, sig_bt, regs, ret_type, critical_entry);</span>
  
        if (nm != NULL) {
<span class="udiff-line-modified-removed">-         method-&gt;set_code(method, nm);</span>
<span class="udiff-line-modified-added">+         {</span>
<span class="udiff-line-added">+           MutexLocker pl(CompiledMethod_lock, Mutex::_no_safepoint_check_flag);</span>
<span class="udiff-line-added">+           if (nm-&gt;make_in_use()) {</span>
<span class="udiff-line-added">+             method-&gt;set_code(method, nm);</span>
<span class="udiff-line-added">+           }</span>
<span class="udiff-line-added">+         }</span>
  
          DirectiveSet* directive = DirectivesStack::getDefaultDirective(CompileBroker::compiler(CompLevel_simple));
          if (directive-&gt;PrintAssemblyOption) {
            nm-&gt;print_code();
          }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -3151,48 +3151,23 @@</span>
  }
  
  VMRegPair *SharedRuntime::find_callee_arguments(Symbol* sig, bool has_receiver, bool has_appendix, int* arg_size) {
    // This method is returning a data structure allocating as a
    // ResourceObject, so do not put any ResourceMarks in here.
<span class="udiff-line-removed">-   char *s = sig-&gt;as_C_string();</span>
<span class="udiff-line-removed">-   int len = (int)strlen(s);</span>
<span class="udiff-line-removed">-   s++; len--;                   // Skip opening paren</span>
  
    BasicType *sig_bt = NEW_RESOURCE_ARRAY(BasicType, 256);
    VMRegPair *regs = NEW_RESOURCE_ARRAY(VMRegPair, 256);
    int cnt = 0;
    if (has_receiver) {
      sig_bt[cnt++] = T_OBJECT; // Receiver is argument 0; not in signature
    }
  
<span class="udiff-line-modified-removed">-   while (*s != &#39;)&#39;) {          // Find closing right paren</span>
<span class="udiff-line-modified-removed">-     switch (*s++) {            // Switch on signature character</span>
<span class="udiff-line-modified-removed">-     case &#39;B&#39;: sig_bt[cnt++] = T_BYTE;    break;</span>
<span class="udiff-line-modified-removed">-     case &#39;C&#39;: sig_bt[cnt++] = T_CHAR;    break;</span>
<span class="udiff-line-modified-removed">-     case &#39;D&#39;: sig_bt[cnt++] = T_DOUBLE;  sig_bt[cnt++] = T_VOID; break;</span>
<span class="udiff-line-removed">-     case &#39;F&#39;: sig_bt[cnt++] = T_FLOAT;   break;</span>
<span class="udiff-line-removed">-     case &#39;I&#39;: sig_bt[cnt++] = T_INT;     break;</span>
<span class="udiff-line-removed">-     case &#39;J&#39;: sig_bt[cnt++] = T_LONG;    sig_bt[cnt++] = T_VOID; break;</span>
<span class="udiff-line-removed">-     case &#39;S&#39;: sig_bt[cnt++] = T_SHORT;   break;</span>
<span class="udiff-line-removed">-     case &#39;Z&#39;: sig_bt[cnt++] = T_BOOLEAN; break;</span>
<span class="udiff-line-removed">-     case &#39;V&#39;: sig_bt[cnt++] = T_VOID;    break;</span>
<span class="udiff-line-removed">-     case &#39;L&#39;:                   // Oop</span>
<span class="udiff-line-removed">-       while (*s++ != &#39;;&#39;);   // Skip signature</span>
<span class="udiff-line-removed">-       sig_bt[cnt++] = T_OBJECT;</span>
<span class="udiff-line-removed">-       break;</span>
<span class="udiff-line-removed">-     case &#39;[&#39;: {                 // Array</span>
<span class="udiff-line-removed">-       do {                      // Skip optional size</span>
<span class="udiff-line-removed">-         while (*s &gt;= &#39;0&#39; &amp;&amp; *s &lt;= &#39;9&#39;) s++;</span>
<span class="udiff-line-removed">-       } while (*s++ == &#39;[&#39;);   // Nested arrays?</span>
<span class="udiff-line-removed">-       // Skip element type</span>
<span class="udiff-line-removed">-       if (s[-1] == &#39;L&#39;)</span>
<span class="udiff-line-removed">-         while (*s++ != &#39;;&#39;); // Skip signature</span>
<span class="udiff-line-removed">-       sig_bt[cnt++] = T_ARRAY;</span>
<span class="udiff-line-removed">-       break;</span>
<span class="udiff-line-removed">-     }</span>
<span class="udiff-line-removed">-     default : ShouldNotReachHere();</span>
<span class="udiff-line-removed">-     }</span>
<span class="udiff-line-modified-added">+   for (SignatureStream ss(sig); !ss.at_return_type(); ss.next()) {</span>
<span class="udiff-line-modified-added">+     BasicType type = ss.type();</span>
<span class="udiff-line-modified-added">+     sig_bt[cnt++] = type;</span>
<span class="udiff-line-modified-added">+     if (is_double_word_type(type))</span>
<span class="udiff-line-modified-added">+       sig_bt[cnt++] = T_VOID;</span>
    }
  
    if (has_appendix) {
      sig_bt[cnt++] = T_OBJECT;
    }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -3284,14 +3259,14 @@</span>
         kptr2 &lt; fr.interpreter_frame_monitor_begin();
         kptr2 = fr.next_monitor_in_interpreter_frame(kptr2) ) {
      if (kptr2-&gt;obj() != NULL) {         // Avoid &#39;holes&#39; in the monitor array
        BasicLock *lock = kptr2-&gt;lock();
        // Inflate so the displaced header becomes position-independent
<span class="udiff-line-modified-removed">-       if (lock-&gt;displaced_header()-&gt;is_unlocked())</span>
<span class="udiff-line-modified-added">+       if (lock-&gt;displaced_header().is_unlocked())</span>
          ObjectSynchronizer::inflate_helper(kptr2-&gt;obj());
        // Now the displaced header is free to move
<span class="udiff-line-modified-removed">-       buf[i++] = (intptr_t)lock-&gt;displaced_header();</span>
<span class="udiff-line-modified-added">+       buf[i++] = (intptr_t)lock-&gt;displaced_header().value();</span>
        buf[i++] = cast_from_oop&lt;intptr_t&gt;(kptr2-&gt;obj());
      }
    }
    assert(i - max_locals == active_monitor_count*2, &quot;found the expected number of monitors&quot;);
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -3323,14 +3298,24 @@</span>
    }
    assert(false, &quot;Should have found handler&quot;);
  }
  
  void AdapterHandlerEntry::print_adapter_on(outputStream* st) const {
<span class="udiff-line-modified-removed">-   st-&gt;print_cr(&quot;AHE@&quot; INTPTR_FORMAT &quot;: %s i2c: &quot; INTPTR_FORMAT &quot; c2i: &quot; INTPTR_FORMAT &quot; c2iUV: &quot; INTPTR_FORMAT,</span>
<span class="udiff-line-modified-removed">-                p2i(this), fingerprint()-&gt;as_string(),</span>
<span class="udiff-line-modified-removed">-                p2i(get_i2c_entry()), p2i(get_c2i_entry()), p2i(get_c2i_unverified_entry()));</span>
<span class="udiff-line-modified-removed">- </span>
<span class="udiff-line-modified-added">+   st-&gt;print(&quot;AHE@&quot; INTPTR_FORMAT &quot;: %s&quot;, p2i(this), fingerprint()-&gt;as_string());</span>
<span class="udiff-line-modified-added">+   if (get_i2c_entry() != NULL) {</span>
<span class="udiff-line-modified-added">+     st-&gt;print(&quot; i2c: &quot; INTPTR_FORMAT, p2i(get_i2c_entry()));</span>
<span class="udiff-line-modified-added">+   }</span>
<span class="udiff-line-added">+   if (get_c2i_entry() != NULL) {</span>
<span class="udiff-line-added">+     st-&gt;print(&quot; c2i: &quot; INTPTR_FORMAT, p2i(get_c2i_entry()));</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+   if (get_c2i_unverified_entry() != NULL) {</span>
<span class="udiff-line-added">+     st-&gt;print(&quot; c2iUV: &quot; INTPTR_FORMAT, p2i(get_c2i_unverified_entry()));</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+   if (get_c2i_no_clinit_check_entry() != NULL) {</span>
<span class="udiff-line-added">+     st-&gt;print(&quot; c2iNCI: &quot; INTPTR_FORMAT, p2i(get_c2i_no_clinit_check_entry()));</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+   st-&gt;cr();</span>
  }
  
  #if INCLUDE_CDS
  
  void CDSAdapterHandlerEntry::init() {
</pre>
<center><a href="mutexLocker.hpp.udiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="sharedRuntime.hpp.udiff.html" target="_top">next &gt;</a></center>  </body>
</html>
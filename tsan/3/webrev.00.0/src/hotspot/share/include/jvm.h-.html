<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/hotspot/share/include/jvm.h</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 1997, 2019, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 #ifndef _JAVASOFT_JVM_H_
  27 #define _JAVASOFT_JVM_H_
  28 
  29 #include &lt;sys/stat.h&gt;
  30 
  31 #include &quot;jni.h&quot;
  32 #include &quot;jvm_md.h&quot;
  33 
  34 #ifdef __cplusplus
  35 extern &quot;C&quot; {
  36 #endif
  37 
  38 /*
  39  * This file contains additional functions exported from the VM.
  40  * These functions are complementary to the standard JNI support.
  41  * There are three parts to this file:
  42  *
  43  * First, this file contains the VM-related functions needed by native
  44  * libraries in the standard Java API. For example, the java.lang.Object
  45  * class needs VM-level functions that wait for and notify monitors.
  46  *
  47  * Second, this file contains the functions and constant definitions
  48  * needed by the byte code verifier and class file format checker.
  49  * These functions allow the verifier and format checker to be written
  50  * in a VM-independent way.
  51  *
  52  * Third, this file contains various I/O and network operations needed
  53  * by the standard Java I/O and network APIs.
  54  */
  55 
  56 /*
  57  * Bump the version number when either of the following happens:
  58  *
  59  * 1. There is a change in JVM_* functions.
  60  *
  61  * 2. There is a change in the contract between VM and Java classes.
  62  *    For example, if the VM relies on a new private field in Thread
  63  *    class.
  64  */
  65 
  66 #define JVM_INTERFACE_VERSION 6
  67 
  68 JNIEXPORT jint JNICALL
  69 JVM_GetInterfaceVersion(void);
  70 
  71 /*************************************************************************
  72  PART 1: Functions for Native Libraries
  73  ************************************************************************/
  74 /*
  75  * java.lang.Object
  76  */
  77 JNIEXPORT jint JNICALL
  78 JVM_IHashCode(JNIEnv *env, jobject obj);
  79 
  80 JNIEXPORT void JNICALL
  81 JVM_MonitorWait(JNIEnv *env, jobject obj, jlong ms);
  82 
  83 JNIEXPORT void JNICALL
  84 JVM_MonitorNotify(JNIEnv *env, jobject obj);
  85 
  86 JNIEXPORT void JNICALL
  87 JVM_MonitorNotifyAll(JNIEnv *env, jobject obj);
  88 
  89 JNIEXPORT jobject JNICALL
  90 JVM_Clone(JNIEnv *env, jobject obj);
  91 
  92 /*
  93  * java.lang.String
  94  */
  95 JNIEXPORT jstring JNICALL
  96 JVM_InternString(JNIEnv *env, jstring str);
  97 
  98 /*
  99  * java.lang.System
 100  */
 101 JNIEXPORT jlong JNICALL
 102 JVM_CurrentTimeMillis(JNIEnv *env, jclass ignored);
 103 
 104 JNIEXPORT jlong JNICALL
 105 JVM_NanoTime(JNIEnv *env, jclass ignored);
 106 
 107 JNIEXPORT jlong JNICALL
 108 JVM_GetNanoTimeAdjustment(JNIEnv *env, jclass ignored, jlong offset_secs);
 109 
 110 JNIEXPORT void JNICALL
 111 JVM_ArrayCopy(JNIEnv *env, jclass ignored, jobject src, jint src_pos,
 112               jobject dst, jint dst_pos, jint length);
 113 
 114 /*
 115  * Return an array of all properties as alternating name and value pairs.
 116  */
 117 JNIEXPORT jobjectArray JNICALL
 118 JVM_GetProperties(JNIEnv *env);
 119 
 120 /*
 121  * java.lang.Runtime
 122  */
 123 JNIEXPORT void JNICALL
 124 JVM_BeforeHalt();
 125 
 126 JNIEXPORT void JNICALL
 127 JVM_Halt(jint code);
 128 
 129 JNIEXPORT void JNICALL
 130 JVM_GC(void);
 131 
 132 /* Returns the number of real-time milliseconds that have elapsed since the
 133  * least-recently-inspected heap object was last inspected by the garbage
 134  * collector.
 135  *
 136  * For simple stop-the-world collectors this value is just the time
 137  * since the most recent collection.  For generational collectors it is the
 138  * time since the oldest generation was most recently collected.  Other
 139  * collectors are free to return a pessimistic estimate of the elapsed time, or
 140  * simply the time since the last full collection was performed.
 141  *
 142  * Note that in the presence of reference objects, a given object that is no
 143  * longer strongly reachable may have to be inspected multiple times before it
 144  * can be reclaimed.
 145  */
 146 JNIEXPORT jlong JNICALL
 147 JVM_MaxObjectInspectionAge(void);
 148 
 149 JNIEXPORT jlong JNICALL
 150 JVM_TotalMemory(void);
 151 
 152 JNIEXPORT jlong JNICALL
 153 JVM_FreeMemory(void);
 154 
 155 JNIEXPORT jlong JNICALL
 156 JVM_MaxMemory(void);
 157 
 158 JNIEXPORT jint JNICALL
 159 JVM_ActiveProcessorCount(void);
 160 
 161 JNIEXPORT void * JNICALL
 162 JVM_LoadLibrary(const char *name);
 163 
 164 JNIEXPORT void JNICALL
 165 JVM_UnloadLibrary(void * handle);
 166 
 167 JNIEXPORT void * JNICALL
 168 JVM_FindLibraryEntry(void *handle, const char *name);
 169 
 170 JNIEXPORT jboolean JNICALL
 171 JVM_IsSupportedJNIVersion(jint version);
 172 
 173 JNIEXPORT jobjectArray JNICALL
 174 JVM_GetVmArguments(JNIEnv *env);
 175 
 176 JNIEXPORT void JNICALL
 177 JVM_InitializeFromArchive(JNIEnv* env, jclass cls);
 178 
 179 /*
 180  * java.lang.Throwable
 181  */
 182 JNIEXPORT void JNICALL
 183 JVM_FillInStackTrace(JNIEnv *env, jobject throwable);
 184 
 185 /*
 186  * java.lang.StackTraceElement
 187  */
 188 JNIEXPORT void JNICALL
 189 JVM_InitStackTraceElementArray(JNIEnv *env, jobjectArray elements, jobject throwable);
 190 
 191 JNIEXPORT void JNICALL
 192 JVM_InitStackTraceElement(JNIEnv* env, jobject element, jobject stackFrameInfo);
 193 
 194 /*
 195  * java.lang.StackWalker
 196  */
 197 enum {
 198   JVM_STACKWALK_FILL_CLASS_REFS_ONLY       = 0x2,
 199   JVM_STACKWALK_GET_CALLER_CLASS           = 0x04,
 200   JVM_STACKWALK_SHOW_HIDDEN_FRAMES         = 0x20,
 201   JVM_STACKWALK_FILL_LIVE_STACK_FRAMES     = 0x100
 202 };
 203 
 204 JNIEXPORT jobject JNICALL
 205 JVM_CallStackWalk(JNIEnv *env, jobject stackStream, jlong mode,
 206                   jint skip_frames, jint frame_count, jint start_index,
 207                   jobjectArray frames);
 208 
 209 JNIEXPORT jint JNICALL
 210 JVM_MoreStackWalk(JNIEnv *env, jobject stackStream, jlong mode, jlong anchor,
 211                   jint frame_count, jint start_index,
 212                   jobjectArray frames);
 213 
 214 /*
 215  * java.lang.Thread
 216  */
 217 JNIEXPORT void JNICALL
 218 JVM_StartThread(JNIEnv *env, jobject thread);
 219 
 220 JNIEXPORT void JNICALL
 221 JVM_StopThread(JNIEnv *env, jobject thread, jobject exception);
 222 
 223 JNIEXPORT jboolean JNICALL
 224 JVM_IsThreadAlive(JNIEnv *env, jobject thread);
 225 
 226 JNIEXPORT void JNICALL
 227 JVM_SuspendThread(JNIEnv *env, jobject thread);
 228 
 229 JNIEXPORT void JNICALL
 230 JVM_ResumeThread(JNIEnv *env, jobject thread);
 231 
 232 JNIEXPORT void JNICALL
 233 JVM_SetThreadPriority(JNIEnv *env, jobject thread, jint prio);
 234 
 235 JNIEXPORT void JNICALL
 236 JVM_Yield(JNIEnv *env, jclass threadClass);
 237 
 238 JNIEXPORT void JNICALL
 239 JVM_Sleep(JNIEnv *env, jclass threadClass, jlong millis);
 240 
 241 JNIEXPORT jobject JNICALL
 242 JVM_CurrentThread(JNIEnv *env, jclass threadClass);
 243 
 244 JNIEXPORT jint JNICALL
 245 JVM_CountStackFrames(JNIEnv *env, jobject thread);
 246 
 247 JNIEXPORT void JNICALL
 248 JVM_Interrupt(JNIEnv *env, jobject thread);
 249 
 250 JNIEXPORT jboolean JNICALL
 251 JVM_IsInterrupted(JNIEnv *env, jobject thread, jboolean clearInterrupted);
 252 
 253 JNIEXPORT jboolean JNICALL
 254 JVM_HoldsLock(JNIEnv *env, jclass threadClass, jobject obj);
 255 
 256 JNIEXPORT void JNICALL
 257 JVM_DumpAllStacks(JNIEnv *env, jclass unused);
 258 
 259 JNIEXPORT jobjectArray JNICALL
 260 JVM_GetAllThreads(JNIEnv *env, jclass dummy);
 261 
 262 JNIEXPORT void JNICALL
 263 JVM_SetNativeThreadName(JNIEnv *env, jobject jthread, jstring name);
 264 
 265 /* getStackTrace() and getAllStackTraces() method */
 266 JNIEXPORT jobjectArray JNICALL
 267 JVM_DumpThreads(JNIEnv *env, jclass threadClass, jobjectArray threads);
 268 
 269 /*
 270  * java.lang.SecurityManager
 271  */
 272 JNIEXPORT jobjectArray JNICALL
 273 JVM_GetClassContext(JNIEnv *env);
 274 
 275 /*
 276  * java.lang.Package
 277  */
 278 JNIEXPORT jstring JNICALL
 279 JVM_GetSystemPackage(JNIEnv *env, jstring name);
 280 
 281 JNIEXPORT jobjectArray JNICALL
 282 JVM_GetSystemPackages(JNIEnv *env);
 283 
 284 /*
 285  * java.lang.ref.Finalizer
 286  */
 287 JNIEXPORT jboolean JNICALL
 288 JVM_GetTsanEnabled(JNIEnv *env);
 289 
 290 /*
 291  * java.lang.ref.Reference
 292  */
 293 JNIEXPORT jobject JNICALL
 294 JVM_GetAndClearReferencePendingList(JNIEnv *env);
 295 
 296 JNIEXPORT jboolean JNICALL
 297 JVM_HasReferencePendingList(JNIEnv *env);
 298 
 299 JNIEXPORT void JNICALL
 300 JVM_WaitForReferencePendingList(JNIEnv *env);
 301 
 302 /*
 303  * java.io.ObjectInputStream
 304  */
 305 JNIEXPORT jobject JNICALL
 306 JVM_LatestUserDefinedLoader(JNIEnv *env);
 307 
 308 /*
 309  * java.lang.reflect.Array
 310  */
 311 JNIEXPORT jint JNICALL
 312 JVM_GetArrayLength(JNIEnv *env, jobject arr);
 313 
 314 JNIEXPORT jobject JNICALL
 315 JVM_GetArrayElement(JNIEnv *env, jobject arr, jint index);
 316 
 317 JNIEXPORT jvalue JNICALL
 318 JVM_GetPrimitiveArrayElement(JNIEnv *env, jobject arr, jint index, jint wCode);
 319 
 320 JNIEXPORT void JNICALL
 321 JVM_SetArrayElement(JNIEnv *env, jobject arr, jint index, jobject val);
 322 
 323 JNIEXPORT void JNICALL
 324 JVM_SetPrimitiveArrayElement(JNIEnv *env, jobject arr, jint index, jvalue v,
 325                              unsigned char vCode);
 326 
 327 JNIEXPORT jobject JNICALL
 328 JVM_NewArray(JNIEnv *env, jclass eltClass, jint length);
 329 
 330 JNIEXPORT jobject JNICALL
 331 JVM_NewMultiArray(JNIEnv *env, jclass eltClass, jintArray dim);
 332 
 333 
 334 /*
 335  * Returns the immediate caller class of the native method invoking
 336  * JVM_GetCallerClass.  The Method.invoke and other frames due to
 337  * reflection machinery are skipped.
 338  *
 339  * The caller is expected to be marked with
 340  * jdk.internal.reflect.CallerSensitive. The JVM will throw an
 341  * error if it is not marked properly.
 342  */
 343 JNIEXPORT jclass JNICALL
 344 JVM_GetCallerClass(JNIEnv *env);
 345 
 346 
 347 /*
 348  * Find primitive classes
 349  * utf: class name
 350  */
 351 JNIEXPORT jclass JNICALL
 352 JVM_FindPrimitiveClass(JNIEnv *env, const char *utf);
 353 
 354 
 355 /*
 356  * Find a class from a boot class loader. Returns NULL if class not found.
 357  */
 358 JNIEXPORT jclass JNICALL
 359 JVM_FindClassFromBootLoader(JNIEnv *env, const char *name);
 360 
 361 /*
 362  * Find a class from a given class loader.  Throws ClassNotFoundException.
 363  *  name:   name of class
 364  *  init:   whether initialization is done
 365  *  loader: class loader to look up the class. This may not be the same as the caller&#39;s
 366  *          class loader.
 367  *  caller: initiating class. The initiating class may be null when a security
 368  *          manager is not installed.
 369  */
 370 JNIEXPORT jclass JNICALL
 371 JVM_FindClassFromCaller(JNIEnv *env, const char *name, jboolean init,
 372                         jobject loader, jclass caller);
 373 
 374 /*
 375  * Find a class from a given class.
 376  */
 377 JNIEXPORT jclass JNICALL
 378 JVM_FindClassFromClass(JNIEnv *env, const char *name, jboolean init,
 379                              jclass from);
 380 
 381 /* Find a loaded class cached by the VM */
 382 JNIEXPORT jclass JNICALL
 383 JVM_FindLoadedClass(JNIEnv *env, jobject loader, jstring name);
 384 
 385 /* Define a class */
 386 JNIEXPORT jclass JNICALL
 387 JVM_DefineClass(JNIEnv *env, const char *name, jobject loader, const jbyte *buf,
 388                 jsize len, jobject pd);
 389 
 390 /* Define a class with a source (added in JDK1.5) */
 391 JNIEXPORT jclass JNICALL
 392 JVM_DefineClassWithSource(JNIEnv *env, const char *name, jobject loader,
 393                           const jbyte *buf, jsize len, jobject pd,
 394                           const char *source);
 395 
 396 /*
 397  * Module support funcions
 398  */
 399 
 400 /*
 401  * Define a module with the specified packages and bind the module to the
 402  * given class loader.
 403  *  module:       module to define
 404  *  is_open:      specifies if module is open (currently ignored)
 405  *  version:      the module version
 406  *  location:     the module location
 407  *  packages:     list of packages in the module
 408  *  num_packages: number of packages in the module
 409  */
 410 JNIEXPORT void JNICALL
 411 JVM_DefineModule(JNIEnv *env, jobject module, jboolean is_open, jstring version,
 412                  jstring location, const char* const* packages, jsize num_packages);
 413 
 414 /*
 415  * Set the boot loader&#39;s unnamed module.
 416  *  module: boot loader&#39;s unnamed module
 417  */
 418 JNIEXPORT void JNICALL
 419 JVM_SetBootLoaderUnnamedModule(JNIEnv *env, jobject module);
 420 
 421 /*
 422  * Do a qualified export of a package.
 423  *  from_module: module containing the package to export
 424  *  package:     name of the package to export
 425  *  to_module:   module to export the package to
 426  */
 427 JNIEXPORT void JNICALL
 428 JVM_AddModuleExports(JNIEnv *env, jobject from_module, const char* package, jobject to_module);
 429 
 430 /*
 431  * Do an export of a package to all unnamed modules.
 432  *  from_module: module containing the package to export
 433  *  package:     name of the package to export to all unnamed modules
 434  */
 435 JNIEXPORT void JNICALL
 436 JVM_AddModuleExportsToAllUnnamed(JNIEnv *env, jobject from_module, const char* package);
 437 
 438 /*
 439  * Do an unqualified export of a package.
 440  *  from_module: module containing the package to export
 441  *  package:     name of the package to export
 442  */
 443 JNIEXPORT void JNICALL
 444 JVM_AddModuleExportsToAll(JNIEnv *env, jobject from_module, const char* package);
 445 
 446 /*
 447  * Add a module to the list of modules that a given module can read.
 448  *  from_module:   module requesting read access
 449  *  source_module: module that from_module wants to read
 450  */
 451 JNIEXPORT void JNICALL
 452 JVM_AddReadsModule(JNIEnv *env, jobject from_module, jobject source_module);
 453 
 454 /*
 455  * Reflection support functions
 456  */
 457 
 458 JNIEXPORT jstring JNICALL
 459 JVM_InitClassName(JNIEnv *env, jclass cls);
 460 
 461 JNIEXPORT jobjectArray JNICALL
 462 JVM_GetClassInterfaces(JNIEnv *env, jclass cls);
 463 
 464 JNIEXPORT jboolean JNICALL
 465 JVM_IsInterface(JNIEnv *env, jclass cls);
 466 
 467 JNIEXPORT jobjectArray JNICALL
 468 JVM_GetClassSigners(JNIEnv *env, jclass cls);
 469 
 470 JNIEXPORT void JNICALL
 471 JVM_SetClassSigners(JNIEnv *env, jclass cls, jobjectArray signers);
 472 
 473 JNIEXPORT jobject JNICALL
 474 JVM_GetProtectionDomain(JNIEnv *env, jclass cls);
 475 
 476 JNIEXPORT jboolean JNICALL
 477 JVM_IsArrayClass(JNIEnv *env, jclass cls);
 478 
 479 JNIEXPORT jboolean JNICALL
 480 JVM_IsPrimitiveClass(JNIEnv *env, jclass cls);
 481 
 482 JNIEXPORT jint JNICALL
 483 JVM_GetClassModifiers(JNIEnv *env, jclass cls);
 484 
 485 JNIEXPORT jobjectArray JNICALL
 486 JVM_GetDeclaredClasses(JNIEnv *env, jclass ofClass);
 487 
 488 JNIEXPORT jclass JNICALL
 489 JVM_GetDeclaringClass(JNIEnv *env, jclass ofClass);
 490 
 491 JNIEXPORT jstring JNICALL
 492 JVM_GetSimpleBinaryName(JNIEnv *env, jclass ofClass);
 493 
 494 /* Generics support (JDK 1.5) */
 495 JNIEXPORT jstring JNICALL
 496 JVM_GetClassSignature(JNIEnv *env, jclass cls);
 497 
 498 /* Annotations support (JDK 1.5) */
 499 JNIEXPORT jbyteArray JNICALL
 500 JVM_GetClassAnnotations(JNIEnv *env, jclass cls);
 501 
 502 /* Type use annotations support (JDK 1.8) */
 503 
 504 JNIEXPORT jbyteArray JNICALL
 505 JVM_GetClassTypeAnnotations(JNIEnv *env, jclass cls);
 506 
 507 JNIEXPORT jbyteArray JNICALL
 508 JVM_GetFieldTypeAnnotations(JNIEnv *env, jobject field);
 509 
 510 JNIEXPORT jbyteArray JNICALL
 511 JVM_GetMethodTypeAnnotations(JNIEnv *env, jobject method);
 512 
 513 /*
 514  * New (JDK 1.4) reflection implementation
 515  */
 516 
 517 JNIEXPORT jobjectArray JNICALL
 518 JVM_GetClassDeclaredMethods(JNIEnv *env, jclass ofClass, jboolean publicOnly);
 519 
 520 JNIEXPORT jobjectArray JNICALL
 521 JVM_GetClassDeclaredFields(JNIEnv *env, jclass ofClass, jboolean publicOnly);
 522 
 523 JNIEXPORT jobjectArray JNICALL
 524 JVM_GetClassDeclaredConstructors(JNIEnv *env, jclass ofClass, jboolean publicOnly);
 525 
 526 /* Differs from JVM_GetClassModifiers in treatment of inner classes.
 527    This returns the access flags for the class as specified in the
 528    class file rather than searching the InnerClasses attribute (if
 529    present) to find the source-level access flags. Only the values of
 530    the low 13 bits (i.e., a mask of 0x1FFF) are guaranteed to be
 531    valid. */
 532 JNIEXPORT jint JNICALL
 533 JVM_GetClassAccessFlags(JNIEnv *env, jclass cls);
 534 
 535 /* Nestmates - since JDK 11 */
 536 
 537 JNIEXPORT jboolean JNICALL
 538 JVM_AreNestMates(JNIEnv *env, jclass current, jclass member);
 539 
 540 JNIEXPORT jclass JNICALL
 541 JVM_GetNestHost(JNIEnv *env, jclass current);
 542 
 543 JNIEXPORT jobjectArray JNICALL
 544 JVM_GetNestMembers(JNIEnv *env, jclass current);
 545 
 546 /* The following two reflection routines are still needed due to startup time issues */
 547 /*
 548  * java.lang.reflect.Method
 549  */
 550 JNIEXPORT jobject JNICALL
 551 JVM_InvokeMethod(JNIEnv *env, jobject method, jobject obj, jobjectArray args0);
 552 
 553 /*
 554  * java.lang.reflect.Constructor
 555  */
 556 JNIEXPORT jobject JNICALL
 557 JVM_NewInstanceFromConstructor(JNIEnv *env, jobject c, jobjectArray args0);
 558 
 559 /*
 560  * Constant pool access; currently used to implement reflective access to annotations (JDK 1.5)
 561  */
 562 
 563 JNIEXPORT jobject JNICALL
 564 JVM_GetClassConstantPool(JNIEnv *env, jclass cls);
 565 
 566 JNIEXPORT jint JNICALL JVM_ConstantPoolGetSize
 567 (JNIEnv *env, jobject unused, jobject jcpool);
 568 
 569 JNIEXPORT jclass JNICALL JVM_ConstantPoolGetClassAt
 570 (JNIEnv *env, jobject unused, jobject jcpool, jint index);
 571 
 572 JNIEXPORT jclass JNICALL JVM_ConstantPoolGetClassAtIfLoaded
 573 (JNIEnv *env, jobject unused, jobject jcpool, jint index);
 574 
 575 JNIEXPORT jint JNICALL JVM_ConstantPoolGetClassRefIndexAt
 576 (JNIEnv *env, jobject obj, jobject unused, jint index);
 577 
 578 JNIEXPORT jobject JNICALL JVM_ConstantPoolGetMethodAt
 579 (JNIEnv *env, jobject unused, jobject jcpool, jint index);
 580 
 581 JNIEXPORT jobject JNICALL JVM_ConstantPoolGetMethodAtIfLoaded
 582 (JNIEnv *env, jobject unused, jobject jcpool, jint index);
 583 
 584 JNIEXPORT jobject JNICALL JVM_ConstantPoolGetFieldAt
 585 (JNIEnv *env, jobject unused, jobject jcpool, jint index);
 586 
 587 JNIEXPORT jobject JNICALL JVM_ConstantPoolGetFieldAtIfLoaded
 588 (JNIEnv *env, jobject unused, jobject jcpool, jint index);
 589 
 590 JNIEXPORT jobjectArray JNICALL JVM_ConstantPoolGetMemberRefInfoAt
 591 (JNIEnv *env, jobject unused, jobject jcpool, jint index);
 592 
 593 JNIEXPORT jint JNICALL JVM_ConstantPoolGetNameAndTypeRefIndexAt
 594 (JNIEnv *env, jobject obj, jobject unused, jint index);
 595 
 596 JNIEXPORT jobjectArray JNICALL JVM_ConstantPoolGetNameAndTypeRefInfoAt
 597 (JNIEnv *env, jobject obj, jobject unused, jint index);
 598 
 599 JNIEXPORT jint JNICALL JVM_ConstantPoolGetIntAt
 600 (JNIEnv *env, jobject unused, jobject jcpool, jint index);
 601 
 602 JNIEXPORT jlong JNICALL JVM_ConstantPoolGetLongAt
 603 (JNIEnv *env, jobject unused, jobject jcpool, jint index);
 604 
 605 JNIEXPORT jfloat JNICALL JVM_ConstantPoolGetFloatAt
 606 (JNIEnv *env, jobject unused, jobject jcpool, jint index);
 607 
 608 JNIEXPORT jdouble JNICALL JVM_ConstantPoolGetDoubleAt
 609 (JNIEnv *env, jobject unused, jobject jcpool, jint index);
 610 
 611 JNIEXPORT jstring JNICALL JVM_ConstantPoolGetStringAt
 612 (JNIEnv *env, jobject unused, jobject jcpool, jint index);
 613 
 614 JNIEXPORT jstring JNICALL JVM_ConstantPoolGetUTF8At
 615 (JNIEnv *env, jobject unused, jobject jcpool, jint index);
 616 
 617 JNIEXPORT jbyte JNICALL JVM_ConstantPoolGetTagAt
 618 (JNIEnv *env, jobject unused, jobject jcpool, jint index);
 619 
 620 /*
 621  * Parameter reflection
 622  */
 623 
 624 JNIEXPORT jobjectArray JNICALL
 625 JVM_GetMethodParameters(JNIEnv *env, jobject method);
 626 
 627 /*
 628  * java.security.*
 629  */
 630 
 631 JNIEXPORT jobject JNICALL
 632 JVM_GetInheritedAccessControlContext(JNIEnv *env, jclass cls);
 633 
 634 /*
 635  * Ensure that code doing a stackwalk and using javaVFrame::locals() to
 636  * get the value will see a materialized value and not a scalar-replaced
 637  * null value.
 638  */
 639 #define JVM_EnsureMaterializedForStackWalk(env, value) \
 640     do {} while(0) // Nothing to do.  The fact that the value escaped
 641                    // through a native method is enough.
 642 
 643 JNIEXPORT jobject JNICALL
 644 JVM_GetStackAccessControlContext(JNIEnv *env, jclass cls);
 645 
 646 /*
 647  * Signal support, used to implement the shutdown sequence.  Every VM must
 648  * support JVM_SIGINT and JVM_SIGTERM, raising the former for user interrupts
 649  * (^C) and the latter for external termination (kill, system shutdown, etc.).
 650  * Other platform-dependent signal values may also be supported.
 651  */
 652 
 653 JNIEXPORT void * JNICALL
 654 JVM_RegisterSignal(jint sig, void *handler);
 655 
 656 JNIEXPORT jboolean JNICALL
 657 JVM_RaiseSignal(jint sig);
 658 
 659 JNIEXPORT jint JNICALL
 660 JVM_FindSignal(const char *name);
 661 
 662 /*
 663  * Retrieve the assertion directives for the specified class.
 664  */
 665 JNIEXPORT jboolean JNICALL
 666 JVM_DesiredAssertionStatus(JNIEnv *env, jclass unused, jclass cls);
 667 
 668 /*
 669  * Retrieve the assertion directives from the VM.
 670  */
 671 JNIEXPORT jobject JNICALL
 672 JVM_AssertionStatusDirectives(JNIEnv *env, jclass unused);
 673 
 674 /*
 675  * java.util.concurrent.atomic.AtomicLong
 676  */
 677 JNIEXPORT jboolean JNICALL
 678 JVM_SupportsCX8(void);
 679 
 680 /*
 681  * com.sun.dtrace.jsdt support
 682  */
 683 
 684 #define JVM_TRACING_DTRACE_VERSION 1
 685 
 686 /*
 687  * Structure to pass one probe description to JVM
 688  */
 689 typedef struct {
 690     jmethodID method;
 691     jstring   function;
 692     jstring   name;
 693     void*            reserved[4];     // for future use
 694 } JVM_DTraceProbe;
 695 
 696 /**
 697  * Encapsulates the stability ratings for a DTrace provider field
 698  */
 699 typedef struct {
 700     jint nameStability;
 701     jint dataStability;
 702     jint dependencyClass;
 703 } JVM_DTraceInterfaceAttributes;
 704 
 705 /*
 706  * Structure to pass one provider description to JVM
 707  */
 708 typedef struct {
 709     jstring                       name;
 710     JVM_DTraceProbe*              probes;
 711     jint                          probe_count;
 712     JVM_DTraceInterfaceAttributes providerAttributes;
 713     JVM_DTraceInterfaceAttributes moduleAttributes;
 714     JVM_DTraceInterfaceAttributes functionAttributes;
 715     JVM_DTraceInterfaceAttributes nameAttributes;
 716     JVM_DTraceInterfaceAttributes argsAttributes;
 717     void*                         reserved[4]; // for future use
 718 } JVM_DTraceProvider;
 719 
 720 /*
 721  * Get the version number the JVM was built with
 722  */
 723 JNIEXPORT jint JNICALL
 724 JVM_DTraceGetVersion(JNIEnv* env);
 725 
 726 /*
 727  * Register new probe with given signature, return global handle
 728  *
 729  * The version passed in is the version that the library code was
 730  * built with.
 731  */
 732 JNIEXPORT jlong JNICALL
 733 JVM_DTraceActivate(JNIEnv* env, jint version, jstring module_name,
 734   jint providers_count, JVM_DTraceProvider* providers);
 735 
 736 /*
 737  * Check JSDT probe
 738  */
 739 JNIEXPORT jboolean JNICALL
 740 JVM_DTraceIsProbeEnabled(JNIEnv* env, jmethodID method);
 741 
 742 /*
 743  * Destroy custom DOF
 744  */
 745 JNIEXPORT void JNICALL
 746 JVM_DTraceDispose(JNIEnv* env, jlong activation_handle);
 747 
 748 /*
 749  * Check to see if DTrace is supported by OS
 750  */
 751 JNIEXPORT jboolean JNICALL
 752 JVM_DTraceIsSupported(JNIEnv* env);
 753 
 754 /*************************************************************************
 755  PART 2: Support for the Verifier and Class File Format Checker
 756  ************************************************************************/
 757 /*
 758  * Return the class name in UTF format. The result is valid
 759  * until JVM_ReleaseUTf is called.
 760  *
 761  * The caller must treat the string as a constant and not modify it
 762  * in any way.
 763  */
 764 JNIEXPORT const char * JNICALL
 765 JVM_GetClassNameUTF(JNIEnv *env, jclass cb);
 766 
 767 /*
 768  * Returns the constant pool types in the buffer provided by &quot;types.&quot;
 769  */
 770 JNIEXPORT void JNICALL
 771 JVM_GetClassCPTypes(JNIEnv *env, jclass cb, unsigned char *types);
 772 
 773 /*
 774  * Returns the number of Constant Pool entries.
 775  */
 776 JNIEXPORT jint JNICALL
 777 JVM_GetClassCPEntriesCount(JNIEnv *env, jclass cb);
 778 
 779 /*
 780  * Returns the number of *declared* fields or methods.
 781  */
 782 JNIEXPORT jint JNICALL
 783 JVM_GetClassFieldsCount(JNIEnv *env, jclass cb);
 784 
 785 JNIEXPORT jint JNICALL
 786 JVM_GetClassMethodsCount(JNIEnv *env, jclass cb);
 787 
 788 /*
 789  * Returns the CP indexes of exceptions raised by a given method.
 790  * Places the result in the given buffer.
 791  *
 792  * The method is identified by method_index.
 793  */
 794 JNIEXPORT void JNICALL
 795 JVM_GetMethodIxExceptionIndexes(JNIEnv *env, jclass cb, jint method_index,
 796                                 unsigned short *exceptions);
 797 /*
 798  * Returns the number of exceptions raised by a given method.
 799  * The method is identified by method_index.
 800  */
 801 JNIEXPORT jint JNICALL
 802 JVM_GetMethodIxExceptionsCount(JNIEnv *env, jclass cb, jint method_index);
 803 
 804 /*
 805  * Returns the byte code sequence of a given method.
 806  * Places the result in the given buffer.
 807  *
 808  * The method is identified by method_index.
 809  */
 810 JNIEXPORT void JNICALL
 811 JVM_GetMethodIxByteCode(JNIEnv *env, jclass cb, jint method_index,
 812                         unsigned char *code);
 813 
 814 /*
 815  * Returns the length of the byte code sequence of a given method.
 816  * The method is identified by method_index.
 817  */
 818 JNIEXPORT jint JNICALL
 819 JVM_GetMethodIxByteCodeLength(JNIEnv *env, jclass cb, jint method_index);
 820 
 821 /*
 822  * A structure used to a capture exception table entry in a Java method.
 823  */
 824 typedef struct {
 825     jint start_pc;
 826     jint end_pc;
 827     jint handler_pc;
 828     jint catchType;
 829 } JVM_ExceptionTableEntryType;
 830 
 831 /*
 832  * Returns the exception table entry at entry_index of a given method.
 833  * Places the result in the given buffer.
 834  *
 835  * The method is identified by method_index.
 836  */
 837 JNIEXPORT void JNICALL
 838 JVM_GetMethodIxExceptionTableEntry(JNIEnv *env, jclass cb, jint method_index,
 839                                    jint entry_index,
 840                                    JVM_ExceptionTableEntryType *entry);
 841 
 842 /*
 843  * Returns the length of the exception table of a given method.
 844  * The method is identified by method_index.
 845  */
 846 JNIEXPORT jint JNICALL
 847 JVM_GetMethodIxExceptionTableLength(JNIEnv *env, jclass cb, int index);
 848 
 849 /*
 850  * Returns the modifiers of a given field.
 851  * The field is identified by field_index.
 852  */
 853 JNIEXPORT jint JNICALL
 854 JVM_GetFieldIxModifiers(JNIEnv *env, jclass cb, int index);
 855 
 856 /*
 857  * Returns the modifiers of a given method.
 858  * The method is identified by method_index.
 859  */
 860 JNIEXPORT jint JNICALL
 861 JVM_GetMethodIxModifiers(JNIEnv *env, jclass cb, int index);
 862 
 863 /*
 864  * Returns the number of local variables of a given method.
 865  * The method is identified by method_index.
 866  */
 867 JNIEXPORT jint JNICALL
 868 JVM_GetMethodIxLocalsCount(JNIEnv *env, jclass cb, int index);
 869 
 870 /*
 871  * Returns the number of arguments (including this pointer) of a given method.
 872  * The method is identified by method_index.
 873  */
 874 JNIEXPORT jint JNICALL
 875 JVM_GetMethodIxArgsSize(JNIEnv *env, jclass cb, int index);
 876 
 877 /*
 878  * Returns the maximum amount of stack (in words) used by a given method.
 879  * The method is identified by method_index.
 880  */
 881 JNIEXPORT jint JNICALL
 882 JVM_GetMethodIxMaxStack(JNIEnv *env, jclass cb, int index);
 883 
 884 /*
 885  * Is a given method a constructor.
 886  * The method is identified by method_index.
 887  */
 888 JNIEXPORT jboolean JNICALL
 889 JVM_IsConstructorIx(JNIEnv *env, jclass cb, int index);
 890 
 891 /*
 892  * Is the given method generated by the VM.
 893  * The method is identified by method_index.
 894  */
 895 JNIEXPORT jboolean JNICALL
 896 JVM_IsVMGeneratedMethodIx(JNIEnv *env, jclass cb, int index);
 897 
 898 /*
 899  * Returns the name of a given method in UTF format.
 900  * The result remains valid until JVM_ReleaseUTF is called.
 901  *
 902  * The caller must treat the string as a constant and not modify it
 903  * in any way.
 904  */
 905 JNIEXPORT const char * JNICALL
 906 JVM_GetMethodIxNameUTF(JNIEnv *env, jclass cb, jint index);
 907 
 908 /*
 909  * Returns the signature of a given method in UTF format.
 910  * The result remains valid until JVM_ReleaseUTF is called.
 911  *
 912  * The caller must treat the string as a constant and not modify it
 913  * in any way.
 914  */
 915 JNIEXPORT const char * JNICALL
 916 JVM_GetMethodIxSignatureUTF(JNIEnv *env, jclass cb, jint index);
 917 
 918 /*
 919  * Returns the name of the field referred to at a given constant pool
 920  * index.
 921  *
 922  * The result is in UTF format and remains valid until JVM_ReleaseUTF
 923  * is called.
 924  *
 925  * The caller must treat the string as a constant and not modify it
 926  * in any way.
 927  */
 928 JNIEXPORT const char * JNICALL
 929 JVM_GetCPFieldNameUTF(JNIEnv *env, jclass cb, jint index);
 930 
 931 /*
 932  * Returns the name of the method referred to at a given constant pool
 933  * index.
 934  *
 935  * The result is in UTF format and remains valid until JVM_ReleaseUTF
 936  * is called.
 937  *
 938  * The caller must treat the string as a constant and not modify it
 939  * in any way.
 940  */
 941 JNIEXPORT const char * JNICALL
 942 JVM_GetCPMethodNameUTF(JNIEnv *env, jclass cb, jint index);
 943 
 944 /*
 945  * Returns the signature of the method referred to at a given constant pool
 946  * index.
 947  *
 948  * The result is in UTF format and remains valid until JVM_ReleaseUTF
 949  * is called.
 950  *
 951  * The caller must treat the string as a constant and not modify it
 952  * in any way.
 953  */
 954 JNIEXPORT const char * JNICALL
 955 JVM_GetCPMethodSignatureUTF(JNIEnv *env, jclass cb, jint index);
 956 
 957 /*
 958  * Returns the signature of the field referred to at a given constant pool
 959  * index.
 960  *
 961  * The result is in UTF format and remains valid until JVM_ReleaseUTF
 962  * is called.
 963  *
 964  * The caller must treat the string as a constant and not modify it
 965  * in any way.
 966  */
 967 JNIEXPORT const char * JNICALL
 968 JVM_GetCPFieldSignatureUTF(JNIEnv *env, jclass cb, jint index);
 969 
 970 /*
 971  * Returns the class name referred to at a given constant pool index.
 972  *
 973  * The result is in UTF format and remains valid until JVM_ReleaseUTF
 974  * is called.
 975  *
 976  * The caller must treat the string as a constant and not modify it
 977  * in any way.
 978  */
 979 JNIEXPORT const char * JNICALL
 980 JVM_GetCPClassNameUTF(JNIEnv *env, jclass cb, jint index);
 981 
 982 /*
 983  * Returns the class name referred to at a given constant pool index.
 984  *
 985  * The constant pool entry must refer to a CONSTANT_Fieldref.
 986  *
 987  * The result is in UTF format and remains valid until JVM_ReleaseUTF
 988  * is called.
 989  *
 990  * The caller must treat the string as a constant and not modify it
 991  * in any way.
 992  */
 993 JNIEXPORT const char * JNICALL
 994 JVM_GetCPFieldClassNameUTF(JNIEnv *env, jclass cb, jint index);
 995 
 996 /*
 997  * Returns the class name referred to at a given constant pool index.
 998  *
 999  * The constant pool entry must refer to CONSTANT_Methodref or
1000  * CONSTANT_InterfaceMethodref.
1001  *
1002  * The result is in UTF format and remains valid until JVM_ReleaseUTF
1003  * is called.
1004  *
1005  * The caller must treat the string as a constant and not modify it
1006  * in any way.
1007  */
1008 JNIEXPORT const char * JNICALL
1009 JVM_GetCPMethodClassNameUTF(JNIEnv *env, jclass cb, jint index);
1010 
1011 /*
1012  * Returns the modifiers of a field in calledClass. The field is
1013  * referred to in class cb at constant pool entry index.
1014  *
1015  * The caller must treat the string as a constant and not modify it
1016  * in any way.
1017  *
1018  * Returns -1 if the field does not exist in calledClass.
1019  */
1020 JNIEXPORT jint JNICALL
1021 JVM_GetCPFieldModifiers(JNIEnv *env, jclass cb, int index, jclass calledClass);
1022 
1023 /*
1024  * Returns the modifiers of a method in calledClass. The method is
1025  * referred to in class cb at constant pool entry index.
1026  *
1027  * Returns -1 if the method does not exist in calledClass.
1028  */
1029 JNIEXPORT jint JNICALL
1030 JVM_GetCPMethodModifiers(JNIEnv *env, jclass cb, int index, jclass calledClass);
1031 
1032 /*
1033  * Releases the UTF string obtained from the VM.
1034  */
1035 JNIEXPORT void JNICALL
1036 JVM_ReleaseUTF(const char *utf);
1037 
1038 /*
1039  * Compare if two classes are in the same package.
1040  */
1041 JNIEXPORT jboolean JNICALL
1042 JVM_IsSameClassPackage(JNIEnv *env, jclass class1, jclass class2);
1043 
1044 /* Get classfile constants */
1045 #include &quot;classfile_constants.h&quot;
1046 
1047 /*
1048  * A function defined by the byte-code verifier and called by the VM.
1049  * This is not a function implemented in the VM.
1050  *
1051  * Returns JNI_FALSE if verification fails. A detailed error message
1052  * will be places in msg_buf, whose length is specified by buf_len.
1053  */
1054 typedef jboolean (*verifier_fn_t)(JNIEnv *env,
1055                                   jclass cb,
1056                                   char * msg_buf,
1057                                   jint buf_len);
1058 
1059 
1060 /*
1061  * Support for a VM-independent class format checker.
1062  */
1063 typedef struct {
1064     unsigned long code;    /* byte code */
1065     unsigned long excs;    /* exceptions */
1066     unsigned long etab;    /* catch table */
1067     unsigned long lnum;    /* line number */
1068     unsigned long lvar;    /* local vars */
1069 } method_size_info;
1070 
1071 typedef struct {
1072     unsigned int constants;    /* constant pool */
1073     unsigned int fields;
1074     unsigned int methods;
1075     unsigned int interfaces;
1076     unsigned int fields2;      /* number of static 2-word fields */
1077     unsigned int innerclasses; /* # of records in InnerClasses attr */
1078 
1079     method_size_info clinit;   /* memory used in clinit */
1080     method_size_info main;     /* used everywhere else */
1081 } class_size_info;
1082 
1083 /*
1084  * Functions defined in libjava.so to perform string conversions.
1085  *
1086  */
1087 
1088 typedef jstring (*to_java_string_fn_t)(JNIEnv *env, char *str);
1089 
1090 typedef char *(*to_c_string_fn_t)(JNIEnv *env, jstring s, jboolean *b);
1091 
1092 /* This is the function defined in libjava.so that performs class
1093  * format checks. This functions fills in size information about
1094  * the class file and returns:
1095  *
1096  *   0: good
1097  *  -1: out of memory
1098  *  -2: bad format
1099  *  -3: unsupported version
1100  *  -4: bad class name
1101  */
1102 
1103 typedef jint (*check_format_fn_t)(char *class_name,
1104                                   unsigned char *data,
1105                                   unsigned int data_size,
1106                                   class_size_info *class_size,
1107                                   char *message_buffer,
1108                                   jint buffer_length,
1109                                   jboolean measure_only,
1110                                   jboolean check_relaxed);
1111 
1112 #define JVM_RECOGNIZED_CLASS_MODIFIERS (JVM_ACC_PUBLIC | \
1113                                         JVM_ACC_FINAL | \
1114                                         JVM_ACC_SUPER | \
1115                                         JVM_ACC_INTERFACE | \
1116                                         JVM_ACC_ABSTRACT | \
1117                                         JVM_ACC_ANNOTATION | \
1118                                         JVM_ACC_ENUM | \
1119                                         JVM_ACC_SYNTHETIC)
1120 
1121 #define JVM_RECOGNIZED_FIELD_MODIFIERS (JVM_ACC_PUBLIC | \
1122                                         JVM_ACC_PRIVATE | \
1123                                         JVM_ACC_PROTECTED | \
1124                                         JVM_ACC_STATIC | \
1125                                         JVM_ACC_FINAL | \
1126                                         JVM_ACC_VOLATILE | \
1127                                         JVM_ACC_TRANSIENT | \
1128                                         JVM_ACC_ENUM | \
1129                                         JVM_ACC_SYNTHETIC)
1130 
1131 #define JVM_RECOGNIZED_METHOD_MODIFIERS (JVM_ACC_PUBLIC | \
1132                                          JVM_ACC_PRIVATE | \
1133                                          JVM_ACC_PROTECTED | \
1134                                          JVM_ACC_STATIC | \
1135                                          JVM_ACC_FINAL | \
1136                                          JVM_ACC_SYNCHRONIZED | \
1137                                          JVM_ACC_BRIDGE | \
1138                                          JVM_ACC_VARARGS | \
1139                                          JVM_ACC_NATIVE | \
1140                                          JVM_ACC_ABSTRACT | \
1141                                          JVM_ACC_STRICT | \
1142                                          JVM_ACC_SYNTHETIC)
1143 
1144 /*
1145  * This is the function defined in libjava.so to perform path
1146  * canonicalization. VM call this function before opening jar files
1147  * to load system classes.
1148  *
1149  */
1150 
1151 typedef int (*canonicalize_fn_t)(JNIEnv *env, char *orig, char *out, int len);
1152 
1153 /*************************************************************************
1154  PART 3: I/O and Network Support
1155  ************************************************************************/
1156 
1157 /*
1158  * Convert a pathname into native format.  This function does syntactic
1159  * cleanup, such as removing redundant separator characters.  It modifies
1160  * the given pathname string in place.
1161  */
1162 JNIEXPORT char * JNICALL
1163 JVM_NativePath(char *);
1164 
1165 /*
1166  * The standard printing functions supported by the Java VM. (Should they
1167  * be renamed to JVM_* in the future?
1168  */
1169 
1170 /* jio_snprintf() and jio_vsnprintf() behave like snprintf(3) and vsnprintf(3),
1171  *  respectively, with the following differences:
1172  * - The string written to str is always zero-terminated, also in case of
1173  *   truncation (count is too small to hold the result string), unless count
1174  *   is 0. In case of truncation count-1 characters are written and &#39;\0&#39;
1175  *   appendend.
1176  * - If count is too small to hold the whole string, -1 is returned across
1177  *   all platforms. */
1178 
1179 JNIEXPORT int
1180 jio_vsnprintf(char *str, size_t count, const char *fmt, va_list args);
1181 
1182 JNIEXPORT int
1183 jio_snprintf(char *str, size_t count, const char *fmt, ...);
1184 
1185 JNIEXPORT int
1186 jio_fprintf(FILE *, const char *fmt, ...);
1187 
1188 JNIEXPORT int
1189 jio_vfprintf(FILE *, const char *fmt, va_list args);
1190 
1191 
1192 JNIEXPORT void * JNICALL
1193 JVM_RawMonitorCreate(void);
1194 
1195 JNIEXPORT void JNICALL
1196 JVM_RawMonitorDestroy(void *mon);
1197 
1198 JNIEXPORT jint JNICALL
1199 JVM_RawMonitorEnter(void *mon);
1200 
1201 JNIEXPORT void JNICALL
1202 JVM_RawMonitorExit(void *mon);
1203 
1204 /*
1205  * java.lang.management support
1206  */
1207 JNIEXPORT void* JNICALL
1208 JVM_GetManagement(jint version);
1209 
1210 /*
1211  * com.sun.tools.attach.VirtualMachine support
1212  *
1213  * Initialize the agent properties with the properties maintained in the VM.
1214  */
1215 JNIEXPORT jobject JNICALL
1216 JVM_InitAgentProperties(JNIEnv *env, jobject agent_props);
1217 
1218 JNIEXPORT jstring JNICALL
1219 JVM_GetTemporaryDirectory(JNIEnv *env);
1220 
1221 /* Generics reflection support.
1222  *
1223  * Returns information about the given class&#39;s EnclosingMethod
1224  * attribute, if present, or null if the class had no enclosing
1225  * method.
1226  *
1227  * If non-null, the returned array contains three elements. Element 0
1228  * is the java.lang.Class of which the enclosing method is a member,
1229  * and elements 1 and 2 are the java.lang.Strings for the enclosing
1230  * method&#39;s name and descriptor, respectively.
1231  */
1232 JNIEXPORT jobjectArray JNICALL
1233 JVM_GetEnclosingMethodInfo(JNIEnv* env, jclass ofClass);
1234 
1235 /* =========================================================================
1236  * The following defines a private JVM interface that the JDK can query
1237  * for the JVM version and capabilities.  sun.misc.Version defines
1238  * the methods for getting the VM version and its capabilities.
1239  *
1240  * When a new bit is added, the following should be updated to provide
1241  * access to the new capability:
1242  *    HS:   JVM_GetVersionInfo and Abstract_VM_Version class
1243  *    SDK:  Version class
1244  *
1245  * Similary, a private JDK interface JDK_GetVersionInfo0 is defined for
1246  * JVM to query for the JDK version and capabilities.
1247  *
1248  * When a new bit is added, the following should be updated to provide
1249  * access to the new capability:
1250  *    HS:   JDK_Version class
1251  *    SDK:  JDK_GetVersionInfo0
1252  *
1253  * ==========================================================================
1254  */
1255 typedef struct {
1256     unsigned int jvm_version;  /* Encoded $VNUM as specified by JEP-223 */
1257     unsigned int patch_version : 8; /* JEP-223 patch version */
1258     unsigned int reserved3 : 8;
1259     unsigned int reserved1 : 16;
1260     unsigned int reserved2;
1261 
1262     /* The following bits represents JVM supports that JDK has dependency on.
1263      * JDK can use these bits to determine which JVM version
1264      * and support it has to maintain runtime compatibility.
1265      *
1266      * When a new bit is added in a minor or update release, make sure
1267      * the new bit is also added in the main/baseline.
1268      */
1269     unsigned int is_attach_supported : 1;
1270     unsigned int : 31;
1271     unsigned int : 32;
1272     unsigned int : 32;
1273 } jvm_version_info;
1274 
1275 #define JVM_VERSION_MAJOR(version) ((version &amp; 0xFF000000) &gt;&gt; 24)
1276 #define JVM_VERSION_MINOR(version) ((version &amp; 0x00FF0000) &gt;&gt; 16)
1277 #define JVM_VERSION_SECURITY(version) ((version &amp; 0x0000FF00) &gt;&gt; 8)
1278 #define JVM_VERSION_BUILD(version) ((version &amp; 0x000000FF))
1279 
1280 JNIEXPORT void JNICALL
1281 JVM_GetVersionInfo(JNIEnv* env, jvm_version_info* info, size_t info_size);
1282 
1283 typedef struct {
1284     unsigned int jdk_version; /* Encoded $VNUM as specified by JEP-223 */
1285     unsigned int patch_version : 8; /* JEP-223 patch version */
1286     unsigned int reserved3 : 8;
1287     unsigned int reserved1 : 16;
1288     unsigned int reserved2;
1289 
1290     /* The following bits represents new JDK supports that VM has dependency on.
1291      * VM implementation can use these bits to determine which JDK version
1292      * and support it has to maintain runtime compatibility.
1293      *
1294      * When a new bit is added in a minor or update release, make sure
1295      * the new bit is also added in the main/baseline.
1296      */
1297     unsigned int thread_park_blocker : 1;
1298     unsigned int post_vm_init_hook_enabled : 1;
1299     unsigned int pending_list_uses_discovered_field : 1;
1300     unsigned int : 29;
1301     unsigned int : 32;
1302     unsigned int : 32;
1303 } jdk_version_info;
1304 
1305 #define JDK_VERSION_MAJOR(version) ((version &amp; 0xFF000000) &gt;&gt; 24)
1306 #define JDK_VERSION_MINOR(version) ((version &amp; 0x00FF0000) &gt;&gt; 16)
1307 #define JDK_VERSION_SECURITY(version) ((version &amp; 0x0000FF00) &gt;&gt; 8)
1308 #define JDK_VERSION_BUILD(version) ((version &amp; 0x000000FF))
1309 
1310 /*
1311  * This is the function JDK_GetVersionInfo0 defined in libjava.so
1312  * that is dynamically looked up by JVM.
1313  */
1314 typedef void (*jdk_version_info_fn_t)(jdk_version_info* info, size_t info_size);
1315 
1316 /*
1317  * This structure is used by the launcher to get the default thread
1318  * stack size from the VM using JNI_GetDefaultJavaVMInitArgs() with a
1319  * version of 1.1.  As it is not supported otherwise, it has been removed
1320  * from jni.h
1321  */
1322 typedef struct JDK1_1InitArgs {
1323     jint version;
1324 
1325     char **properties;
1326     jint checkSource;
1327     jint nativeStackSize;
1328     jint javaStackSize;
1329     jint minHeapSize;
1330     jint maxHeapSize;
1331     jint verifyMode;
1332     char *classpath;
1333 
1334     jint (JNICALL *vfprintf)(FILE *fp, const char *format, va_list args);
1335     void (JNICALL *exit)(jint code);
1336     void (JNICALL *abort)(void);
1337 
1338     jint enableClassGC;
1339     jint enableVerboseGC;
1340     jint disableAsyncGC;
1341     jint verbose;
1342     jboolean debugging;
1343     jint debugPort;
1344 } JDK1_1InitArgs;
1345 
1346 
1347 #ifdef __cplusplus
1348 } /* extern &quot;C&quot; */
1349 
1350 #endif /* __cplusplus */
1351 
1352 #endif /* !_JAVASOFT_JVM_H_ */
    </pre>
  </body>
</html>
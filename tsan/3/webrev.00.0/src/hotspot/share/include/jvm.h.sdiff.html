<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/include/jvm.h</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="../gc/shenandoah/shenandoahRootProcessor.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="../interpreter/interpreterRuntime.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/include/jvm.h</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 174 JVM_GetVmArguments(JNIEnv *env);
 175 
 176 JNIEXPORT void JNICALL
 177 JVM_InitializeFromArchive(JNIEnv* env, jclass cls);
 178 
 179 /*
 180  * java.lang.Throwable
 181  */
 182 JNIEXPORT void JNICALL
 183 JVM_FillInStackTrace(JNIEnv *env, jobject throwable);
 184 
 185 /*
 186  * java.lang.StackTraceElement
 187  */
 188 JNIEXPORT void JNICALL
 189 JVM_InitStackTraceElementArray(JNIEnv *env, jobjectArray elements, jobject throwable);
 190 
 191 JNIEXPORT void JNICALL
 192 JVM_InitStackTraceElement(JNIEnv* env, jobject element, jobject stackFrameInfo);
 193 







 194 /*
 195  * java.lang.StackWalker
 196  */
 197 enum {
 198   JVM_STACKWALK_FILL_CLASS_REFS_ONLY       = 0x2,
 199   JVM_STACKWALK_GET_CALLER_CLASS           = 0x04,
 200   JVM_STACKWALK_SHOW_HIDDEN_FRAMES         = 0x20,
 201   JVM_STACKWALK_FILL_LIVE_STACK_FRAMES     = 0x100
 202 };
 203 
 204 JNIEXPORT jobject JNICALL
 205 JVM_CallStackWalk(JNIEnv *env, jobject stackStream, jlong mode,
 206                   jint skip_frames, jint frame_count, jint start_index,
 207                   jobjectArray frames);
 208 
 209 JNIEXPORT jint JNICALL
 210 JVM_MoreStackWalk(JNIEnv *env, jobject stackStream, jlong mode, jlong anchor,
 211                   jint frame_count, jint start_index,
 212                   jobjectArray frames);
 213 
</pre>
<hr />
<pre>
 224 JVM_IsThreadAlive(JNIEnv *env, jobject thread);
 225 
 226 JNIEXPORT void JNICALL
 227 JVM_SuspendThread(JNIEnv *env, jobject thread);
 228 
 229 JNIEXPORT void JNICALL
 230 JVM_ResumeThread(JNIEnv *env, jobject thread);
 231 
 232 JNIEXPORT void JNICALL
 233 JVM_SetThreadPriority(JNIEnv *env, jobject thread, jint prio);
 234 
 235 JNIEXPORT void JNICALL
 236 JVM_Yield(JNIEnv *env, jclass threadClass);
 237 
 238 JNIEXPORT void JNICALL
 239 JVM_Sleep(JNIEnv *env, jclass threadClass, jlong millis);
 240 
 241 JNIEXPORT jobject JNICALL
 242 JVM_CurrentThread(JNIEnv *env, jclass threadClass);
 243 
<span class="line-removed"> 244 JNIEXPORT jint JNICALL</span>
<span class="line-removed"> 245 JVM_CountStackFrames(JNIEnv *env, jobject thread);</span>
<span class="line-removed"> 246 </span>
 247 JNIEXPORT void JNICALL
 248 JVM_Interrupt(JNIEnv *env, jobject thread);
 249 
<span class="line-removed"> 250 JNIEXPORT jboolean JNICALL</span>
<span class="line-removed"> 251 JVM_IsInterrupted(JNIEnv *env, jobject thread, jboolean clearInterrupted);</span>
<span class="line-removed"> 252 </span>
 253 JNIEXPORT jboolean JNICALL
 254 JVM_HoldsLock(JNIEnv *env, jclass threadClass, jobject obj);
 255 
 256 JNIEXPORT void JNICALL
 257 JVM_DumpAllStacks(JNIEnv *env, jclass unused);
 258 
 259 JNIEXPORT jobjectArray JNICALL
 260 JVM_GetAllThreads(JNIEnv *env, jclass dummy);
 261 
 262 JNIEXPORT void JNICALL
 263 JVM_SetNativeThreadName(JNIEnv *env, jobject jthread, jstring name);
 264 
 265 /* getStackTrace() and getAllStackTraces() method */
 266 JNIEXPORT jobjectArray JNICALL
 267 JVM_DumpThreads(JNIEnv *env, jclass threadClass, jobjectArray threads);
 268 
 269 /*
 270  * java.lang.SecurityManager
 271  */
 272 JNIEXPORT jobjectArray JNICALL
</pre>
<hr />
<pre>
 506 
 507 JNIEXPORT jbyteArray JNICALL
 508 JVM_GetFieldTypeAnnotations(JNIEnv *env, jobject field);
 509 
 510 JNIEXPORT jbyteArray JNICALL
 511 JVM_GetMethodTypeAnnotations(JNIEnv *env, jobject method);
 512 
 513 /*
 514  * New (JDK 1.4) reflection implementation
 515  */
 516 
 517 JNIEXPORT jobjectArray JNICALL
 518 JVM_GetClassDeclaredMethods(JNIEnv *env, jclass ofClass, jboolean publicOnly);
 519 
 520 JNIEXPORT jobjectArray JNICALL
 521 JVM_GetClassDeclaredFields(JNIEnv *env, jclass ofClass, jboolean publicOnly);
 522 
 523 JNIEXPORT jobjectArray JNICALL
 524 JVM_GetClassDeclaredConstructors(JNIEnv *env, jclass ofClass, jboolean publicOnly);
 525 

 526 /* Differs from JVM_GetClassModifiers in treatment of inner classes.
 527    This returns the access flags for the class as specified in the
 528    class file rather than searching the InnerClasses attribute (if
 529    present) to find the source-level access flags. Only the values of
 530    the low 13 bits (i.e., a mask of 0x1FFF) are guaranteed to be
 531    valid. */
 532 JNIEXPORT jint JNICALL
 533 JVM_GetClassAccessFlags(JNIEnv *env, jclass cls);
 534 
 535 /* Nestmates - since JDK 11 */
 536 
 537 JNIEXPORT jboolean JNICALL
 538 JVM_AreNestMates(JNIEnv *env, jclass current, jclass member);
 539 
 540 JNIEXPORT jclass JNICALL
 541 JVM_GetNestHost(JNIEnv *env, jclass current);
 542 
 543 JNIEXPORT jobjectArray JNICALL
 544 JVM_GetNestMembers(JNIEnv *env, jclass current);
 545 








 546 /* The following two reflection routines are still needed due to startup time issues */
 547 /*
 548  * java.lang.reflect.Method
 549  */
 550 JNIEXPORT jobject JNICALL
 551 JVM_InvokeMethod(JNIEnv *env, jobject method, jobject obj, jobjectArray args0);
 552 
 553 /*
 554  * java.lang.reflect.Constructor
 555  */
 556 JNIEXPORT jobject JNICALL
 557 JVM_NewInstanceFromConstructor(JNIEnv *env, jobject c, jobjectArray args0);
 558 
 559 /*
 560  * Constant pool access; currently used to implement reflective access to annotations (JDK 1.5)
 561  */
 562 
 563 JNIEXPORT jobject JNICALL
 564 JVM_GetClassConstantPool(JNIEnv *env, jclass cls);
 565 
</pre>
<hr />
<pre>
1027  * Returns -1 if the method does not exist in calledClass.
1028  */
1029 JNIEXPORT jint JNICALL
1030 JVM_GetCPMethodModifiers(JNIEnv *env, jclass cb, int index, jclass calledClass);
1031 
1032 /*
1033  * Releases the UTF string obtained from the VM.
1034  */
1035 JNIEXPORT void JNICALL
1036 JVM_ReleaseUTF(const char *utf);
1037 
1038 /*
1039  * Compare if two classes are in the same package.
1040  */
1041 JNIEXPORT jboolean JNICALL
1042 JVM_IsSameClassPackage(JNIEnv *env, jclass class1, jclass class2);
1043 
1044 /* Get classfile constants */
1045 #include &quot;classfile_constants.h&quot;
1046 
<span class="line-removed">1047 /*</span>
<span class="line-removed">1048  * A function defined by the byte-code verifier and called by the VM.</span>
<span class="line-removed">1049  * This is not a function implemented in the VM.</span>
<span class="line-removed">1050  *</span>
<span class="line-removed">1051  * Returns JNI_FALSE if verification fails. A detailed error message</span>
<span class="line-removed">1052  * will be places in msg_buf, whose length is specified by buf_len.</span>
<span class="line-removed">1053  */</span>
<span class="line-removed">1054 typedef jboolean (*verifier_fn_t)(JNIEnv *env,</span>
<span class="line-removed">1055                                   jclass cb,</span>
<span class="line-removed">1056                                   char * msg_buf,</span>
<span class="line-removed">1057                                   jint buf_len);</span>
<span class="line-removed">1058 </span>
<span class="line-removed">1059 </span>
1060 /*
1061  * Support for a VM-independent class format checker.
1062  */
1063 typedef struct {
1064     unsigned long code;    /* byte code */
1065     unsigned long excs;    /* exceptions */
1066     unsigned long etab;    /* catch table */
1067     unsigned long lnum;    /* line number */
1068     unsigned long lvar;    /* local vars */
1069 } method_size_info;
1070 
1071 typedef struct {
1072     unsigned int constants;    /* constant pool */
1073     unsigned int fields;
1074     unsigned int methods;
1075     unsigned int interfaces;
1076     unsigned int fields2;      /* number of static 2-word fields */
1077     unsigned int innerclasses; /* # of records in InnerClasses attr */
1078 
1079     method_size_info clinit;   /* memory used in clinit */
1080     method_size_info main;     /* used everywhere else */
1081 } class_size_info;
1082 
<span class="line-removed">1083 /*</span>
<span class="line-removed">1084  * Functions defined in libjava.so to perform string conversions.</span>
<span class="line-removed">1085  *</span>
<span class="line-removed">1086  */</span>
<span class="line-removed">1087 </span>
<span class="line-removed">1088 typedef jstring (*to_java_string_fn_t)(JNIEnv *env, char *str);</span>
<span class="line-removed">1089 </span>
<span class="line-removed">1090 typedef char *(*to_c_string_fn_t)(JNIEnv *env, jstring s, jboolean *b);</span>
<span class="line-removed">1091 </span>
<span class="line-removed">1092 /* This is the function defined in libjava.so that performs class</span>
<span class="line-removed">1093  * format checks. This functions fills in size information about</span>
<span class="line-removed">1094  * the class file and returns:</span>
<span class="line-removed">1095  *</span>
<span class="line-removed">1096  *   0: good</span>
<span class="line-removed">1097  *  -1: out of memory</span>
<span class="line-removed">1098  *  -2: bad format</span>
<span class="line-removed">1099  *  -3: unsupported version</span>
<span class="line-removed">1100  *  -4: bad class name</span>
<span class="line-removed">1101  */</span>
<span class="line-removed">1102 </span>
<span class="line-removed">1103 typedef jint (*check_format_fn_t)(char *class_name,</span>
<span class="line-removed">1104                                   unsigned char *data,</span>
<span class="line-removed">1105                                   unsigned int data_size,</span>
<span class="line-removed">1106                                   class_size_info *class_size,</span>
<span class="line-removed">1107                                   char *message_buffer,</span>
<span class="line-removed">1108                                   jint buffer_length,</span>
<span class="line-removed">1109                                   jboolean measure_only,</span>
<span class="line-removed">1110                                   jboolean check_relaxed);</span>
<span class="line-removed">1111 </span>
1112 #define JVM_RECOGNIZED_CLASS_MODIFIERS (JVM_ACC_PUBLIC | \
1113                                         JVM_ACC_FINAL | \
1114                                         JVM_ACC_SUPER | \
1115                                         JVM_ACC_INTERFACE | \
1116                                         JVM_ACC_ABSTRACT | \
1117                                         JVM_ACC_ANNOTATION | \
1118                                         JVM_ACC_ENUM | \
1119                                         JVM_ACC_SYNTHETIC)
1120 
1121 #define JVM_RECOGNIZED_FIELD_MODIFIERS (JVM_ACC_PUBLIC | \
1122                                         JVM_ACC_PRIVATE | \
1123                                         JVM_ACC_PROTECTED | \
1124                                         JVM_ACC_STATIC | \
1125                                         JVM_ACC_FINAL | \
1126                                         JVM_ACC_VOLATILE | \
1127                                         JVM_ACC_TRANSIENT | \
1128                                         JVM_ACC_ENUM | \
1129                                         JVM_ACC_SYNTHETIC)
1130 
1131 #define JVM_RECOGNIZED_METHOD_MODIFIERS (JVM_ACC_PUBLIC | \
1132                                          JVM_ACC_PRIVATE | \
1133                                          JVM_ACC_PROTECTED | \
1134                                          JVM_ACC_STATIC | \
1135                                          JVM_ACC_FINAL | \
1136                                          JVM_ACC_SYNCHRONIZED | \
1137                                          JVM_ACC_BRIDGE | \
1138                                          JVM_ACC_VARARGS | \
1139                                          JVM_ACC_NATIVE | \
1140                                          JVM_ACC_ABSTRACT | \
1141                                          JVM_ACC_STRICT | \
1142                                          JVM_ACC_SYNTHETIC)
1143 
<span class="line-removed">1144 /*</span>
<span class="line-removed">1145  * This is the function defined in libjava.so to perform path</span>
<span class="line-removed">1146  * canonicalization. VM call this function before opening jar files</span>
<span class="line-removed">1147  * to load system classes.</span>
<span class="line-removed">1148  *</span>
<span class="line-removed">1149  */</span>
<span class="line-removed">1150 </span>
<span class="line-removed">1151 typedef int (*canonicalize_fn_t)(JNIEnv *env, char *orig, char *out, int len);</span>
1152 
1153 /*************************************************************************
1154  PART 3: I/O and Network Support
1155  ************************************************************************/
1156 
1157 /*
1158  * Convert a pathname into native format.  This function does syntactic
1159  * cleanup, such as removing redundant separator characters.  It modifies
1160  * the given pathname string in place.
1161  */
1162 JNIEXPORT char * JNICALL
1163 JVM_NativePath(char *);
1164 
1165 /*
1166  * The standard printing functions supported by the Java VM. (Should they
1167  * be renamed to JVM_* in the future?
1168  */
1169 
1170 /* jio_snprintf() and jio_vsnprintf() behave like snprintf(3) and vsnprintf(3),
1171  *  respectively, with the following differences:
</pre>
<hr />
<pre>
1215 JNIEXPORT jobject JNICALL
1216 JVM_InitAgentProperties(JNIEnv *env, jobject agent_props);
1217 
1218 JNIEXPORT jstring JNICALL
1219 JVM_GetTemporaryDirectory(JNIEnv *env);
1220 
1221 /* Generics reflection support.
1222  *
1223  * Returns information about the given class&#39;s EnclosingMethod
1224  * attribute, if present, or null if the class had no enclosing
1225  * method.
1226  *
1227  * If non-null, the returned array contains three elements. Element 0
1228  * is the java.lang.Class of which the enclosing method is a member,
1229  * and elements 1 and 2 are the java.lang.Strings for the enclosing
1230  * method&#39;s name and descriptor, respectively.
1231  */
1232 JNIEXPORT jobjectArray JNICALL
1233 JVM_GetEnclosingMethodInfo(JNIEnv* env, jclass ofClass);
1234 
<span class="line-removed">1235 /* =========================================================================</span>
<span class="line-removed">1236  * The following defines a private JVM interface that the JDK can query</span>
<span class="line-removed">1237  * for the JVM version and capabilities.  sun.misc.Version defines</span>
<span class="line-removed">1238  * the methods for getting the VM version and its capabilities.</span>
<span class="line-removed">1239  *</span>
<span class="line-removed">1240  * When a new bit is added, the following should be updated to provide</span>
<span class="line-removed">1241  * access to the new capability:</span>
<span class="line-removed">1242  *    HS:   JVM_GetVersionInfo and Abstract_VM_Version class</span>
<span class="line-removed">1243  *    SDK:  Version class</span>
<span class="line-removed">1244  *</span>
<span class="line-removed">1245  * Similary, a private JDK interface JDK_GetVersionInfo0 is defined for</span>
<span class="line-removed">1246  * JVM to query for the JDK version and capabilities.</span>
<span class="line-removed">1247  *</span>
<span class="line-removed">1248  * When a new bit is added, the following should be updated to provide</span>
<span class="line-removed">1249  * access to the new capability:</span>
<span class="line-removed">1250  *    HS:   JDK_Version class</span>
<span class="line-removed">1251  *    SDK:  JDK_GetVersionInfo0</span>
<span class="line-removed">1252  *</span>
<span class="line-removed">1253  * ==========================================================================</span>
<span class="line-removed">1254  */</span>
<span class="line-removed">1255 typedef struct {</span>
<span class="line-removed">1256     unsigned int jvm_version;  /* Encoded $VNUM as specified by JEP-223 */</span>
<span class="line-removed">1257     unsigned int patch_version : 8; /* JEP-223 patch version */</span>
<span class="line-removed">1258     unsigned int reserved3 : 8;</span>
<span class="line-removed">1259     unsigned int reserved1 : 16;</span>
<span class="line-removed">1260     unsigned int reserved2;</span>
<span class="line-removed">1261 </span>
<span class="line-removed">1262     /* The following bits represents JVM supports that JDK has dependency on.</span>
<span class="line-removed">1263      * JDK can use these bits to determine which JVM version</span>
<span class="line-removed">1264      * and support it has to maintain runtime compatibility.</span>
<span class="line-removed">1265      *</span>
<span class="line-removed">1266      * When a new bit is added in a minor or update release, make sure</span>
<span class="line-removed">1267      * the new bit is also added in the main/baseline.</span>
<span class="line-removed">1268      */</span>
<span class="line-removed">1269     unsigned int is_attach_supported : 1;</span>
<span class="line-removed">1270     unsigned int : 31;</span>
<span class="line-removed">1271     unsigned int : 32;</span>
<span class="line-removed">1272     unsigned int : 32;</span>
<span class="line-removed">1273 } jvm_version_info;</span>
<span class="line-removed">1274 </span>
<span class="line-removed">1275 #define JVM_VERSION_MAJOR(version) ((version &amp; 0xFF000000) &gt;&gt; 24)</span>
<span class="line-removed">1276 #define JVM_VERSION_MINOR(version) ((version &amp; 0x00FF0000) &gt;&gt; 16)</span>
<span class="line-removed">1277 #define JVM_VERSION_SECURITY(version) ((version &amp; 0x0000FF00) &gt;&gt; 8)</span>
<span class="line-removed">1278 #define JVM_VERSION_BUILD(version) ((version &amp; 0x000000FF))</span>
<span class="line-removed">1279 </span>
<span class="line-removed">1280 JNIEXPORT void JNICALL</span>
<span class="line-removed">1281 JVM_GetVersionInfo(JNIEnv* env, jvm_version_info* info, size_t info_size);</span>
<span class="line-removed">1282 </span>
<span class="line-removed">1283 typedef struct {</span>
<span class="line-removed">1284     unsigned int jdk_version; /* Encoded $VNUM as specified by JEP-223 */</span>
<span class="line-removed">1285     unsigned int patch_version : 8; /* JEP-223 patch version */</span>
<span class="line-removed">1286     unsigned int reserved3 : 8;</span>
<span class="line-removed">1287     unsigned int reserved1 : 16;</span>
<span class="line-removed">1288     unsigned int reserved2;</span>
<span class="line-removed">1289 </span>
<span class="line-removed">1290     /* The following bits represents new JDK supports that VM has dependency on.</span>
<span class="line-removed">1291      * VM implementation can use these bits to determine which JDK version</span>
<span class="line-removed">1292      * and support it has to maintain runtime compatibility.</span>
<span class="line-removed">1293      *</span>
<span class="line-removed">1294      * When a new bit is added in a minor or update release, make sure</span>
<span class="line-removed">1295      * the new bit is also added in the main/baseline.</span>
<span class="line-removed">1296      */</span>
<span class="line-removed">1297     unsigned int thread_park_blocker : 1;</span>
<span class="line-removed">1298     unsigned int post_vm_init_hook_enabled : 1;</span>
<span class="line-removed">1299     unsigned int pending_list_uses_discovered_field : 1;</span>
<span class="line-removed">1300     unsigned int : 29;</span>
<span class="line-removed">1301     unsigned int : 32;</span>
<span class="line-removed">1302     unsigned int : 32;</span>
<span class="line-removed">1303 } jdk_version_info;</span>
<span class="line-removed">1304 </span>
<span class="line-removed">1305 #define JDK_VERSION_MAJOR(version) ((version &amp; 0xFF000000) &gt;&gt; 24)</span>
<span class="line-removed">1306 #define JDK_VERSION_MINOR(version) ((version &amp; 0x00FF0000) &gt;&gt; 16)</span>
<span class="line-removed">1307 #define JDK_VERSION_SECURITY(version) ((version &amp; 0x0000FF00) &gt;&gt; 8)</span>
<span class="line-removed">1308 #define JDK_VERSION_BUILD(version) ((version &amp; 0x000000FF))</span>
<span class="line-removed">1309 </span>
<span class="line-removed">1310 /*</span>
<span class="line-removed">1311  * This is the function JDK_GetVersionInfo0 defined in libjava.so</span>
<span class="line-removed">1312  * that is dynamically looked up by JVM.</span>
<span class="line-removed">1313  */</span>
<span class="line-removed">1314 typedef void (*jdk_version_info_fn_t)(jdk_version_info* info, size_t info_size);</span>
<span class="line-removed">1315 </span>
1316 /*
1317  * This structure is used by the launcher to get the default thread
1318  * stack size from the VM using JNI_GetDefaultJavaVMInitArgs() with a
1319  * version of 1.1.  As it is not supported otherwise, it has been removed
1320  * from jni.h
1321  */
1322 typedef struct JDK1_1InitArgs {
1323     jint version;
1324 
1325     char **properties;
1326     jint checkSource;
1327     jint nativeStackSize;
1328     jint javaStackSize;
1329     jint minHeapSize;
1330     jint maxHeapSize;
1331     jint verifyMode;
1332     char *classpath;
1333 
1334     jint (JNICALL *vfprintf)(FILE *fp, const char *format, va_list args);
1335     void (JNICALL *exit)(jint code);
</pre>
</td>
<td>
<hr />
<pre>
 174 JVM_GetVmArguments(JNIEnv *env);
 175 
 176 JNIEXPORT void JNICALL
 177 JVM_InitializeFromArchive(JNIEnv* env, jclass cls);
 178 
 179 /*
 180  * java.lang.Throwable
 181  */
 182 JNIEXPORT void JNICALL
 183 JVM_FillInStackTrace(JNIEnv *env, jobject throwable);
 184 
 185 /*
 186  * java.lang.StackTraceElement
 187  */
 188 JNIEXPORT void JNICALL
 189 JVM_InitStackTraceElementArray(JNIEnv *env, jobjectArray elements, jobject throwable);
 190 
 191 JNIEXPORT void JNICALL
 192 JVM_InitStackTraceElement(JNIEnv* env, jobject element, jobject stackFrameInfo);
 193 
<span class="line-added"> 194 /*</span>
<span class="line-added"> 195  * java.lang.NullPointerException</span>
<span class="line-added"> 196  */</span>
<span class="line-added"> 197 </span>
<span class="line-added"> 198 JNIEXPORT jstring JNICALL</span>
<span class="line-added"> 199 JVM_GetExtendedNPEMessage(JNIEnv *env, jthrowable throwable);</span>
<span class="line-added"> 200 </span>
 201 /*
 202  * java.lang.StackWalker
 203  */
 204 enum {
 205   JVM_STACKWALK_FILL_CLASS_REFS_ONLY       = 0x2,
 206   JVM_STACKWALK_GET_CALLER_CLASS           = 0x04,
 207   JVM_STACKWALK_SHOW_HIDDEN_FRAMES         = 0x20,
 208   JVM_STACKWALK_FILL_LIVE_STACK_FRAMES     = 0x100
 209 };
 210 
 211 JNIEXPORT jobject JNICALL
 212 JVM_CallStackWalk(JNIEnv *env, jobject stackStream, jlong mode,
 213                   jint skip_frames, jint frame_count, jint start_index,
 214                   jobjectArray frames);
 215 
 216 JNIEXPORT jint JNICALL
 217 JVM_MoreStackWalk(JNIEnv *env, jobject stackStream, jlong mode, jlong anchor,
 218                   jint frame_count, jint start_index,
 219                   jobjectArray frames);
 220 
</pre>
<hr />
<pre>
 231 JVM_IsThreadAlive(JNIEnv *env, jobject thread);
 232 
 233 JNIEXPORT void JNICALL
 234 JVM_SuspendThread(JNIEnv *env, jobject thread);
 235 
 236 JNIEXPORT void JNICALL
 237 JVM_ResumeThread(JNIEnv *env, jobject thread);
 238 
 239 JNIEXPORT void JNICALL
 240 JVM_SetThreadPriority(JNIEnv *env, jobject thread, jint prio);
 241 
 242 JNIEXPORT void JNICALL
 243 JVM_Yield(JNIEnv *env, jclass threadClass);
 244 
 245 JNIEXPORT void JNICALL
 246 JVM_Sleep(JNIEnv *env, jclass threadClass, jlong millis);
 247 
 248 JNIEXPORT jobject JNICALL
 249 JVM_CurrentThread(JNIEnv *env, jclass threadClass);
 250 



 251 JNIEXPORT void JNICALL
 252 JVM_Interrupt(JNIEnv *env, jobject thread);
 253 



 254 JNIEXPORT jboolean JNICALL
 255 JVM_HoldsLock(JNIEnv *env, jclass threadClass, jobject obj);
 256 
 257 JNIEXPORT void JNICALL
 258 JVM_DumpAllStacks(JNIEnv *env, jclass unused);
 259 
 260 JNIEXPORT jobjectArray JNICALL
 261 JVM_GetAllThreads(JNIEnv *env, jclass dummy);
 262 
 263 JNIEXPORT void JNICALL
 264 JVM_SetNativeThreadName(JNIEnv *env, jobject jthread, jstring name);
 265 
 266 /* getStackTrace() and getAllStackTraces() method */
 267 JNIEXPORT jobjectArray JNICALL
 268 JVM_DumpThreads(JNIEnv *env, jclass threadClass, jobjectArray threads);
 269 
 270 /*
 271  * java.lang.SecurityManager
 272  */
 273 JNIEXPORT jobjectArray JNICALL
</pre>
<hr />
<pre>
 507 
 508 JNIEXPORT jbyteArray JNICALL
 509 JVM_GetFieldTypeAnnotations(JNIEnv *env, jobject field);
 510 
 511 JNIEXPORT jbyteArray JNICALL
 512 JVM_GetMethodTypeAnnotations(JNIEnv *env, jobject method);
 513 
 514 /*
 515  * New (JDK 1.4) reflection implementation
 516  */
 517 
 518 JNIEXPORT jobjectArray JNICALL
 519 JVM_GetClassDeclaredMethods(JNIEnv *env, jclass ofClass, jboolean publicOnly);
 520 
 521 JNIEXPORT jobjectArray JNICALL
 522 JVM_GetClassDeclaredFields(JNIEnv *env, jclass ofClass, jboolean publicOnly);
 523 
 524 JNIEXPORT jobjectArray JNICALL
 525 JVM_GetClassDeclaredConstructors(JNIEnv *env, jclass ofClass, jboolean publicOnly);
 526 
<span class="line-added"> 527 </span>
 528 /* Differs from JVM_GetClassModifiers in treatment of inner classes.
 529    This returns the access flags for the class as specified in the
 530    class file rather than searching the InnerClasses attribute (if
 531    present) to find the source-level access flags. Only the values of
 532    the low 13 bits (i.e., a mask of 0x1FFF) are guaranteed to be
 533    valid. */
 534 JNIEXPORT jint JNICALL
 535 JVM_GetClassAccessFlags(JNIEnv *env, jclass cls);
 536 
 537 /* Nestmates - since JDK 11 */
 538 
 539 JNIEXPORT jboolean JNICALL
 540 JVM_AreNestMates(JNIEnv *env, jclass current, jclass member);
 541 
 542 JNIEXPORT jclass JNICALL
 543 JVM_GetNestHost(JNIEnv *env, jclass current);
 544 
 545 JNIEXPORT jobjectArray JNICALL
 546 JVM_GetNestMembers(JNIEnv *env, jclass current);
 547 
<span class="line-added"> 548 /* Records - since JDK 14 */</span>
<span class="line-added"> 549 </span>
<span class="line-added"> 550 JNIEXPORT jboolean JNICALL</span>
<span class="line-added"> 551 JVM_IsRecord(JNIEnv *env, jclass cls);</span>
<span class="line-added"> 552 </span>
<span class="line-added"> 553 JNIEXPORT jobjectArray JNICALL</span>
<span class="line-added"> 554 JVM_GetRecordComponents(JNIEnv *env, jclass ofClass);</span>
<span class="line-added"> 555 </span>
 556 /* The following two reflection routines are still needed due to startup time issues */
 557 /*
 558  * java.lang.reflect.Method
 559  */
 560 JNIEXPORT jobject JNICALL
 561 JVM_InvokeMethod(JNIEnv *env, jobject method, jobject obj, jobjectArray args0);
 562 
 563 /*
 564  * java.lang.reflect.Constructor
 565  */
 566 JNIEXPORT jobject JNICALL
 567 JVM_NewInstanceFromConstructor(JNIEnv *env, jobject c, jobjectArray args0);
 568 
 569 /*
 570  * Constant pool access; currently used to implement reflective access to annotations (JDK 1.5)
 571  */
 572 
 573 JNIEXPORT jobject JNICALL
 574 JVM_GetClassConstantPool(JNIEnv *env, jclass cls);
 575 
</pre>
<hr />
<pre>
1037  * Returns -1 if the method does not exist in calledClass.
1038  */
1039 JNIEXPORT jint JNICALL
1040 JVM_GetCPMethodModifiers(JNIEnv *env, jclass cb, int index, jclass calledClass);
1041 
1042 /*
1043  * Releases the UTF string obtained from the VM.
1044  */
1045 JNIEXPORT void JNICALL
1046 JVM_ReleaseUTF(const char *utf);
1047 
1048 /*
1049  * Compare if two classes are in the same package.
1050  */
1051 JNIEXPORT jboolean JNICALL
1052 JVM_IsSameClassPackage(JNIEnv *env, jclass class1, jclass class2);
1053 
1054 /* Get classfile constants */
1055 #include &quot;classfile_constants.h&quot;
1056 













1057 /*
1058  * Support for a VM-independent class format checker.
1059  */
1060 typedef struct {
1061     unsigned long code;    /* byte code */
1062     unsigned long excs;    /* exceptions */
1063     unsigned long etab;    /* catch table */
1064     unsigned long lnum;    /* line number */
1065     unsigned long lvar;    /* local vars */
1066 } method_size_info;
1067 
1068 typedef struct {
1069     unsigned int constants;    /* constant pool */
1070     unsigned int fields;
1071     unsigned int methods;
1072     unsigned int interfaces;
1073     unsigned int fields2;      /* number of static 2-word fields */
1074     unsigned int innerclasses; /* # of records in InnerClasses attr */
1075 
1076     method_size_info clinit;   /* memory used in clinit */
1077     method_size_info main;     /* used everywhere else */
1078 } class_size_info;
1079 





























1080 #define JVM_RECOGNIZED_CLASS_MODIFIERS (JVM_ACC_PUBLIC | \
1081                                         JVM_ACC_FINAL | \
1082                                         JVM_ACC_SUPER | \
1083                                         JVM_ACC_INTERFACE | \
1084                                         JVM_ACC_ABSTRACT | \
1085                                         JVM_ACC_ANNOTATION | \
1086                                         JVM_ACC_ENUM | \
1087                                         JVM_ACC_SYNTHETIC)
1088 
1089 #define JVM_RECOGNIZED_FIELD_MODIFIERS (JVM_ACC_PUBLIC | \
1090                                         JVM_ACC_PRIVATE | \
1091                                         JVM_ACC_PROTECTED | \
1092                                         JVM_ACC_STATIC | \
1093                                         JVM_ACC_FINAL | \
1094                                         JVM_ACC_VOLATILE | \
1095                                         JVM_ACC_TRANSIENT | \
1096                                         JVM_ACC_ENUM | \
1097                                         JVM_ACC_SYNTHETIC)
1098 
1099 #define JVM_RECOGNIZED_METHOD_MODIFIERS (JVM_ACC_PUBLIC | \
1100                                          JVM_ACC_PRIVATE | \
1101                                          JVM_ACC_PROTECTED | \
1102                                          JVM_ACC_STATIC | \
1103                                          JVM_ACC_FINAL | \
1104                                          JVM_ACC_SYNCHRONIZED | \
1105                                          JVM_ACC_BRIDGE | \
1106                                          JVM_ACC_VARARGS | \
1107                                          JVM_ACC_NATIVE | \
1108                                          JVM_ACC_ABSTRACT | \
1109                                          JVM_ACC_STRICT | \
1110                                          JVM_ACC_SYNTHETIC)
1111 








1112 
1113 /*************************************************************************
1114  PART 3: I/O and Network Support
1115  ************************************************************************/
1116 
1117 /*
1118  * Convert a pathname into native format.  This function does syntactic
1119  * cleanup, such as removing redundant separator characters.  It modifies
1120  * the given pathname string in place.
1121  */
1122 JNIEXPORT char * JNICALL
1123 JVM_NativePath(char *);
1124 
1125 /*
1126  * The standard printing functions supported by the Java VM. (Should they
1127  * be renamed to JVM_* in the future?
1128  */
1129 
1130 /* jio_snprintf() and jio_vsnprintf() behave like snprintf(3) and vsnprintf(3),
1131  *  respectively, with the following differences:
</pre>
<hr />
<pre>
1175 JNIEXPORT jobject JNICALL
1176 JVM_InitAgentProperties(JNIEnv *env, jobject agent_props);
1177 
1178 JNIEXPORT jstring JNICALL
1179 JVM_GetTemporaryDirectory(JNIEnv *env);
1180 
1181 /* Generics reflection support.
1182  *
1183  * Returns information about the given class&#39;s EnclosingMethod
1184  * attribute, if present, or null if the class had no enclosing
1185  * method.
1186  *
1187  * If non-null, the returned array contains three elements. Element 0
1188  * is the java.lang.Class of which the enclosing method is a member,
1189  * and elements 1 and 2 are the java.lang.Strings for the enclosing
1190  * method&#39;s name and descriptor, respectively.
1191  */
1192 JNIEXPORT jobjectArray JNICALL
1193 JVM_GetEnclosingMethodInfo(JNIEnv* env, jclass ofClass);
1194 

















































































1195 /*
1196  * This structure is used by the launcher to get the default thread
1197  * stack size from the VM using JNI_GetDefaultJavaVMInitArgs() with a
1198  * version of 1.1.  As it is not supported otherwise, it has been removed
1199  * from jni.h
1200  */
1201 typedef struct JDK1_1InitArgs {
1202     jint version;
1203 
1204     char **properties;
1205     jint checkSource;
1206     jint nativeStackSize;
1207     jint javaStackSize;
1208     jint minHeapSize;
1209     jint maxHeapSize;
1210     jint verifyMode;
1211     char *classpath;
1212 
1213     jint (JNICALL *vfprintf)(FILE *fp, const char *format, va_list args);
1214     void (JNICALL *exit)(jint code);
</pre>
</td>
</tr>
</table>
<center><a href="../gc/shenandoah/shenandoahRootProcessor.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="../interpreter/interpreterRuntime.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
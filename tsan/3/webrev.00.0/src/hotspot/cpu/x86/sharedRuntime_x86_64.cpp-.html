<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/hotspot/cpu/x86/sharedRuntime_x86_64.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 2003, 2018, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include &quot;precompiled.hpp&quot;
  26 #ifndef _WINDOWS
  27 #include &quot;alloca.h&quot;
  28 #endif
  29 #include &quot;asm/macroAssembler.hpp&quot;
  30 #include &quot;asm/macroAssembler.inline.hpp&quot;
  31 #include &quot;code/debugInfoRec.hpp&quot;
  32 #include &quot;code/icBuffer.hpp&quot;
  33 #include &quot;code/nativeInst.hpp&quot;
  34 #include &quot;code/vtableStubs.hpp&quot;
  35 #include &quot;gc/shared/collectedHeap.hpp&quot;
  36 #include &quot;gc/shared/gcLocker.hpp&quot;
  37 #include &quot;gc/shared/barrierSet.hpp&quot;
  38 #include &quot;gc/shared/barrierSetAssembler.hpp&quot;
  39 #include &quot;interpreter/interpreter.hpp&quot;
  40 #include &quot;logging/log.hpp&quot;
  41 #include &quot;memory/resourceArea.hpp&quot;
  42 #include &quot;oops/compiledICHolder.hpp&quot;
  43 #include &quot;runtime/safepointMechanism.hpp&quot;
  44 #include &quot;runtime/sharedRuntime.hpp&quot;
  45 #include &quot;runtime/vframeArray.hpp&quot;
  46 #include &quot;utilities/align.hpp&quot;
  47 #include &quot;utilities/formatBuffer.hpp&quot;
  48 #include &quot;vm_version_x86.hpp&quot;
  49 #include &quot;vmreg_x86.inline.hpp&quot;
  50 #ifdef COMPILER1
  51 #include &quot;c1/c1_Runtime1.hpp&quot;
  52 #endif
  53 #ifdef COMPILER2
  54 #include &quot;opto/runtime.hpp&quot;
  55 #endif
  56 #if INCLUDE_JVMCI
  57 #include &quot;jvmci/jvmciJavaClasses.hpp&quot;
  58 #endif
  59 
  60 #define __ masm-&gt;
  61 
  62 const int StackAlignmentInSlots = StackAlignmentInBytes / VMRegImpl::stack_slot_size;
  63 
  64 class SimpleRuntimeFrame {
  65 
  66   public:
  67 
  68   // Most of the runtime stubs have this simple frame layout.
  69   // This class exists to make the layout shared in one place.
  70   // Offsets are for compiler stack slots, which are jints.
  71   enum layout {
  72     // The frame sender code expects that rbp will be in the &quot;natural&quot; place and
  73     // will override any oopMap setting for it. We must therefore force the layout
  74     // so that it agrees with the frame sender code.
  75     rbp_off = frame::arg_reg_save_area_bytes/BytesPerInt,
  76     rbp_off2,
  77     return_off, return_off2,
  78     framesize
  79   };
  80 };
  81 
  82 class RegisterSaver {
  83   // Capture info about frame layout.  Layout offsets are in jint
  84   // units because compiler frame slots are jints.
  85 #define XSAVE_AREA_BEGIN 160
  86 #define XSAVE_AREA_YMM_BEGIN 576
  87 #define XSAVE_AREA_ZMM_BEGIN 1152
  88 #define XSAVE_AREA_UPPERBANK 1664
  89 #define DEF_XMM_OFFS(regnum) xmm ## regnum ## _off = xmm_off + (regnum)*16/BytesPerInt, xmm ## regnum ## H_off
  90 #define DEF_YMM_OFFS(regnum) ymm ## regnum ## _off = ymm_off + (regnum)*16/BytesPerInt, ymm ## regnum ## H_off
  91 #define DEF_ZMM_OFFS(regnum) zmm ## regnum ## _off = zmm_off + (regnum-16)*64/BytesPerInt, zmm ## regnum ## H_off
  92   enum layout {
  93     fpu_state_off = frame::arg_reg_save_area_bytes/BytesPerInt, // fxsave save area
  94     xmm_off       = fpu_state_off + XSAVE_AREA_BEGIN/BytesPerInt,            // offset in fxsave save area
  95     DEF_XMM_OFFS(0),
  96     DEF_XMM_OFFS(1),
  97     // 2..15 are implied in range usage
  98     ymm_off = xmm_off + (XSAVE_AREA_YMM_BEGIN - XSAVE_AREA_BEGIN)/BytesPerInt,
  99     DEF_YMM_OFFS(0),
 100     DEF_YMM_OFFS(1),
 101     // 2..15 are implied in range usage
 102     zmm_high = xmm_off + (XSAVE_AREA_ZMM_BEGIN - XSAVE_AREA_BEGIN)/BytesPerInt,
 103     zmm_off = xmm_off + (XSAVE_AREA_UPPERBANK - XSAVE_AREA_BEGIN)/BytesPerInt,
 104     DEF_ZMM_OFFS(16),
 105     DEF_ZMM_OFFS(17),
 106     // 18..31 are implied in range usage
 107     fpu_state_end = fpu_state_off + ((FPUStateSizeInWords-1)*wordSize / BytesPerInt),
 108     fpu_stateH_end,
 109     r15_off, r15H_off,
 110     r14_off, r14H_off,
 111     r13_off, r13H_off,
 112     r12_off, r12H_off,
 113     r11_off, r11H_off,
 114     r10_off, r10H_off,
 115     r9_off,  r9H_off,
 116     r8_off,  r8H_off,
 117     rdi_off, rdiH_off,
 118     rsi_off, rsiH_off,
 119     ignore_off, ignoreH_off,  // extra copy of rbp
 120     rsp_off, rspH_off,
 121     rbx_off, rbxH_off,
 122     rdx_off, rdxH_off,
 123     rcx_off, rcxH_off,
 124     rax_off, raxH_off,
 125     // 16-byte stack alignment fill word: see MacroAssembler::push/pop_IU_state
 126     align_off, alignH_off,
 127     flags_off, flagsH_off,
 128     // The frame sender code expects that rbp will be in the &quot;natural&quot; place and
 129     // will override any oopMap setting for it. We must therefore force the layout
 130     // so that it agrees with the frame sender code.
 131     rbp_off, rbpH_off,        // copy of rbp we will restore
 132     return_off, returnH_off,  // slot for return address
 133     reg_save_size             // size in compiler stack slots
 134   };
 135 
 136  public:
 137   static OopMap* save_live_registers(MacroAssembler* masm, int additional_frame_words, int* total_frame_words, bool save_vectors = false);
 138   static void restore_live_registers(MacroAssembler* masm, bool restore_vectors = false);
 139 
 140   // Offsets into the register save area
 141   // Used by deoptimization when it is managing result register
 142   // values on its own
 143 
 144   static int rax_offset_in_bytes(void)    { return BytesPerInt * rax_off; }
 145   static int rdx_offset_in_bytes(void)    { return BytesPerInt * rdx_off; }
 146   static int rbx_offset_in_bytes(void)    { return BytesPerInt * rbx_off; }
 147   static int xmm0_offset_in_bytes(void)   { return BytesPerInt * xmm0_off; }
 148   static int return_offset_in_bytes(void) { return BytesPerInt * return_off; }
 149 
 150   // During deoptimization only the result registers need to be restored,
 151   // all the other values have already been extracted.
 152   static void restore_result_registers(MacroAssembler* masm);
 153 };
 154 
 155 OopMap* RegisterSaver::save_live_registers(MacroAssembler* masm, int additional_frame_words, int* total_frame_words, bool save_vectors) {
 156   int off = 0;
 157   int num_xmm_regs = XMMRegisterImpl::number_of_registers;
 158   if (UseAVX &lt; 3) {
 159     num_xmm_regs = num_xmm_regs/2;
 160   }
 161 #if COMPILER2_OR_JVMCI
 162   if (save_vectors) {
 163     assert(UseAVX &gt; 0, &quot;Vectors larger than 16 byte long are supported only with AVX&quot;);
 164     assert(MaxVectorSize &lt;= 64, &quot;Only up to 64 byte long vectors are supported&quot;);
 165   }
 166 #else
 167   assert(!save_vectors, &quot;vectors are generated only by C2 and JVMCI&quot;);
 168 #endif
 169 
 170   // Always make the frame size 16-byte aligned, both vector and non vector stacks are always allocated
 171   int frame_size_in_bytes = align_up(reg_save_size*BytesPerInt, num_xmm_regs);
 172   // OopMap frame size is in compiler stack slots (jint&#39;s) not bytes or words
 173   int frame_size_in_slots = frame_size_in_bytes / BytesPerInt;
 174   // CodeBlob frame size is in words.
 175   int frame_size_in_words = frame_size_in_bytes / wordSize;
 176   *total_frame_words = frame_size_in_words;
 177 
 178   // Save registers, fpu state, and flags.
 179   // We assume caller has already pushed the return address onto the
 180   // stack, so rsp is 8-byte aligned here.
 181   // We push rpb twice in this sequence because we want the real rbp
 182   // to be under the return like a normal enter.
 183 
 184   __ enter();          // rsp becomes 16-byte aligned here
 185   __ push_CPU_state(); // Push a multiple of 16 bytes
 186 
 187   // push cpu state handles this on EVEX enabled targets
 188   if (save_vectors) {
 189     // Save upper half of YMM registers(0..15)
 190     int base_addr = XSAVE_AREA_YMM_BEGIN;
 191     for (int n = 0; n &lt; 16; n++) {
 192       __ vextractf128_high(Address(rsp, base_addr+n*16), as_XMMRegister(n));
 193     }
 194     if (VM_Version::supports_evex()) {
 195       // Save upper half of ZMM registers(0..15)
 196       base_addr = XSAVE_AREA_ZMM_BEGIN;
 197       for (int n = 0; n &lt; 16; n++) {
 198         __ vextractf64x4_high(Address(rsp, base_addr+n*32), as_XMMRegister(n));
 199       }
 200       // Save full ZMM registers(16..num_xmm_regs)
 201       base_addr = XSAVE_AREA_UPPERBANK;
 202       off = 0;
 203       int vector_len = Assembler::AVX_512bit;
 204       for (int n = 16; n &lt; num_xmm_regs; n++) {
 205         __ evmovdqul(Address(rsp, base_addr+(off++*64)), as_XMMRegister(n), vector_len);
 206       }
 207     }
 208   } else {
 209     if (VM_Version::supports_evex()) {
 210       // Save upper bank of ZMM registers(16..31) for double/float usage
 211       int base_addr = XSAVE_AREA_UPPERBANK;
 212       off = 0;
 213       for (int n = 16; n &lt; num_xmm_regs; n++) {
 214         __ movsd(Address(rsp, base_addr+(off++*64)), as_XMMRegister(n));
 215       }
 216     }
 217   }
 218   __ vzeroupper();
 219   if (frame::arg_reg_save_area_bytes != 0) {
 220     // Allocate argument register save area
 221     __ subptr(rsp, frame::arg_reg_save_area_bytes);
 222   }
 223 
 224   // Set an oopmap for the call site.  This oopmap will map all
 225   // oop-registers and debug-info registers as callee-saved.  This
 226   // will allow deoptimization at this safepoint to find all possible
 227   // debug-info recordings, as well as let GC find all oops.
 228 
 229   OopMapSet *oop_maps = new OopMapSet();
 230   OopMap* map = new OopMap(frame_size_in_slots, 0);
 231 
 232 #define STACK_OFFSET(x) VMRegImpl::stack2reg((x))
 233 
 234   map-&gt;set_callee_saved(STACK_OFFSET( rax_off ), rax-&gt;as_VMReg());
 235   map-&gt;set_callee_saved(STACK_OFFSET( rcx_off ), rcx-&gt;as_VMReg());
 236   map-&gt;set_callee_saved(STACK_OFFSET( rdx_off ), rdx-&gt;as_VMReg());
 237   map-&gt;set_callee_saved(STACK_OFFSET( rbx_off ), rbx-&gt;as_VMReg());
 238   // rbp location is known implicitly by the frame sender code, needs no oopmap
 239   // and the location where rbp was saved by is ignored
 240   map-&gt;set_callee_saved(STACK_OFFSET( rsi_off ), rsi-&gt;as_VMReg());
 241   map-&gt;set_callee_saved(STACK_OFFSET( rdi_off ), rdi-&gt;as_VMReg());
 242   map-&gt;set_callee_saved(STACK_OFFSET( r8_off  ), r8-&gt;as_VMReg());
 243   map-&gt;set_callee_saved(STACK_OFFSET( r9_off  ), r9-&gt;as_VMReg());
 244   map-&gt;set_callee_saved(STACK_OFFSET( r10_off ), r10-&gt;as_VMReg());
 245   map-&gt;set_callee_saved(STACK_OFFSET( r11_off ), r11-&gt;as_VMReg());
 246   map-&gt;set_callee_saved(STACK_OFFSET( r12_off ), r12-&gt;as_VMReg());
 247   map-&gt;set_callee_saved(STACK_OFFSET( r13_off ), r13-&gt;as_VMReg());
 248   map-&gt;set_callee_saved(STACK_OFFSET( r14_off ), r14-&gt;as_VMReg());
 249   map-&gt;set_callee_saved(STACK_OFFSET( r15_off ), r15-&gt;as_VMReg());
 250   // For both AVX and EVEX we will use the legacy FXSAVE area for xmm0..xmm15,
 251   // on EVEX enabled targets, we get it included in the xsave area
 252   off = xmm0_off;
 253   int delta = xmm1_off - off;
 254   for (int n = 0; n &lt; 16; n++) {
 255     XMMRegister xmm_name = as_XMMRegister(n);
 256     map-&gt;set_callee_saved(STACK_OFFSET(off), xmm_name-&gt;as_VMReg());
 257     off += delta;
 258   }
 259   if(UseAVX &gt; 2) {
 260     // Obtain xmm16..xmm31 from the XSAVE area on EVEX enabled targets
 261     off = zmm16_off;
 262     delta = zmm17_off - off;
 263     for (int n = 16; n &lt; num_xmm_regs; n++) {
 264       XMMRegister zmm_name = as_XMMRegister(n);
 265       map-&gt;set_callee_saved(STACK_OFFSET(off), zmm_name-&gt;as_VMReg());
 266       off += delta;
 267     }
 268   }
 269 
 270 #if COMPILER2_OR_JVMCI
 271   if (save_vectors) {
 272     off = ymm0_off;
 273     int delta = ymm1_off - off;
 274     for (int n = 0; n &lt; 16; n++) {
 275       XMMRegister ymm_name = as_XMMRegister(n);
 276       map-&gt;set_callee_saved(STACK_OFFSET(off), ymm_name-&gt;as_VMReg()-&gt;next(4));
 277       off += delta;
 278     }
 279   }
 280 #endif // COMPILER2_OR_JVMCI
 281 
 282   // %%% These should all be a waste but we&#39;ll keep things as they were for now
 283   if (true) {
 284     map-&gt;set_callee_saved(STACK_OFFSET( raxH_off ), rax-&gt;as_VMReg()-&gt;next());
 285     map-&gt;set_callee_saved(STACK_OFFSET( rcxH_off ), rcx-&gt;as_VMReg()-&gt;next());
 286     map-&gt;set_callee_saved(STACK_OFFSET( rdxH_off ), rdx-&gt;as_VMReg()-&gt;next());
 287     map-&gt;set_callee_saved(STACK_OFFSET( rbxH_off ), rbx-&gt;as_VMReg()-&gt;next());
 288     // rbp location is known implicitly by the frame sender code, needs no oopmap
 289     map-&gt;set_callee_saved(STACK_OFFSET( rsiH_off ), rsi-&gt;as_VMReg()-&gt;next());
 290     map-&gt;set_callee_saved(STACK_OFFSET( rdiH_off ), rdi-&gt;as_VMReg()-&gt;next());
 291     map-&gt;set_callee_saved(STACK_OFFSET( r8H_off  ), r8-&gt;as_VMReg()-&gt;next());
 292     map-&gt;set_callee_saved(STACK_OFFSET( r9H_off  ), r9-&gt;as_VMReg()-&gt;next());
 293     map-&gt;set_callee_saved(STACK_OFFSET( r10H_off ), r10-&gt;as_VMReg()-&gt;next());
 294     map-&gt;set_callee_saved(STACK_OFFSET( r11H_off ), r11-&gt;as_VMReg()-&gt;next());
 295     map-&gt;set_callee_saved(STACK_OFFSET( r12H_off ), r12-&gt;as_VMReg()-&gt;next());
 296     map-&gt;set_callee_saved(STACK_OFFSET( r13H_off ), r13-&gt;as_VMReg()-&gt;next());
 297     map-&gt;set_callee_saved(STACK_OFFSET( r14H_off ), r14-&gt;as_VMReg()-&gt;next());
 298     map-&gt;set_callee_saved(STACK_OFFSET( r15H_off ), r15-&gt;as_VMReg()-&gt;next());
 299     // For both AVX and EVEX we will use the legacy FXSAVE area for xmm0..xmm15,
 300     // on EVEX enabled targets, we get it included in the xsave area
 301     off = xmm0H_off;
 302     delta = xmm1H_off - off;
 303     for (int n = 0; n &lt; 16; n++) {
 304       XMMRegister xmm_name = as_XMMRegister(n);
 305       map-&gt;set_callee_saved(STACK_OFFSET(off), xmm_name-&gt;as_VMReg()-&gt;next());
 306       off += delta;
 307     }
 308     if (UseAVX &gt; 2) {
 309       // Obtain xmm16..xmm31 from the XSAVE area on EVEX enabled targets
 310       off = zmm16H_off;
 311       delta = zmm17H_off - off;
 312       for (int n = 16; n &lt; num_xmm_regs; n++) {
 313         XMMRegister zmm_name = as_XMMRegister(n);
 314         map-&gt;set_callee_saved(STACK_OFFSET(off), zmm_name-&gt;as_VMReg()-&gt;next());
 315         off += delta;
 316       }
 317     }
 318   }
 319 
 320   return map;
 321 }
 322 
 323 void RegisterSaver::restore_live_registers(MacroAssembler* masm, bool restore_vectors) {
 324   int num_xmm_regs = XMMRegisterImpl::number_of_registers;
 325   if (UseAVX &lt; 3) {
 326     num_xmm_regs = num_xmm_regs/2;
 327   }
 328   if (frame::arg_reg_save_area_bytes != 0) {
 329     // Pop arg register save area
 330     __ addptr(rsp, frame::arg_reg_save_area_bytes);
 331   }
 332 
 333 #if COMPILER2_OR_JVMCI
 334   if (restore_vectors) {
 335     assert(UseAVX &gt; 0, &quot;Vectors larger than 16 byte long are supported only with AVX&quot;);
 336     assert(MaxVectorSize &lt;= 64, &quot;Only up to 64 byte long vectors are supported&quot;);
 337   }
 338 #else
 339   assert(!restore_vectors, &quot;vectors are generated only by C2&quot;);
 340 #endif
 341 
 342   __ vzeroupper();
 343 
 344   // On EVEX enabled targets everything is handled in pop fpu state
 345   if (restore_vectors) {
 346     // Restore upper half of YMM registers (0..15)
 347     int base_addr = XSAVE_AREA_YMM_BEGIN;
 348     for (int n = 0; n &lt; 16; n++) {
 349       __ vinsertf128_high(as_XMMRegister(n), Address(rsp, base_addr+n*16));
 350     }
 351     if (VM_Version::supports_evex()) {
 352       // Restore upper half of ZMM registers (0..15)
 353       base_addr = XSAVE_AREA_ZMM_BEGIN;
 354       for (int n = 0; n &lt; 16; n++) {
 355         __ vinsertf64x4_high(as_XMMRegister(n), Address(rsp, base_addr+n*32));
 356       }
 357       // Restore full ZMM registers(16..num_xmm_regs)
 358       base_addr = XSAVE_AREA_UPPERBANK;
 359       int vector_len = Assembler::AVX_512bit;
 360       int off = 0;
 361       for (int n = 16; n &lt; num_xmm_regs; n++) {
 362         __ evmovdqul(as_XMMRegister(n), Address(rsp, base_addr+(off++*64)), vector_len);
 363       }
 364     }
 365   } else {
 366     if (VM_Version::supports_evex()) {
 367       // Restore upper bank of ZMM registers(16..31) for double/float usage
 368       int base_addr = XSAVE_AREA_UPPERBANK;
 369       int off = 0;
 370       for (int n = 16; n &lt; num_xmm_regs; n++) {
 371         __ movsd(as_XMMRegister(n), Address(rsp, base_addr+(off++*64)));
 372       }
 373     }
 374   }
 375 
 376   // Recover CPU state
 377   __ pop_CPU_state();
 378   // Get the rbp described implicitly by the calling convention (no oopMap)
 379   __ pop(rbp);
 380 }
 381 
 382 void RegisterSaver::restore_result_registers(MacroAssembler* masm) {
 383 
 384   // Just restore result register. Only used by deoptimization. By
 385   // now any callee save register that needs to be restored to a c2
 386   // caller of the deoptee has been extracted into the vframeArray
 387   // and will be stuffed into the c2i adapter we create for later
 388   // restoration so only result registers need to be restored here.
 389 
 390   // Restore fp result register
 391   __ movdbl(xmm0, Address(rsp, xmm0_offset_in_bytes()));
 392   // Restore integer result register
 393   __ movptr(rax, Address(rsp, rax_offset_in_bytes()));
 394   __ movptr(rdx, Address(rsp, rdx_offset_in_bytes()));
 395 
 396   // Pop all of the register save are off the stack except the return address
 397   __ addptr(rsp, return_offset_in_bytes());
 398 }
 399 
 400 // Is vector&#39;s size (in bytes) bigger than a size saved by default?
 401 // 16 bytes XMM registers are saved by default using fxsave/fxrstor instructions.
 402 bool SharedRuntime::is_wide_vector(int size) {
 403   return size &gt; 16;
 404 }
 405 
 406 size_t SharedRuntime::trampoline_size() {
 407   return 16;
 408 }
 409 
 410 void SharedRuntime::generate_trampoline(MacroAssembler *masm, address destination) {
 411   __ jump(RuntimeAddress(destination));
 412 }
 413 
 414 // The java_calling_convention describes stack locations as ideal slots on
 415 // a frame with no abi restrictions. Since we must observe abi restrictions
 416 // (like the placement of the register window) the slots must be biased by
 417 // the following value.
 418 static int reg2offset_in(VMReg r) {
 419   // Account for saved rbp and return address
 420   // This should really be in_preserve_stack_slots
 421   return (r-&gt;reg2stack() + 4) * VMRegImpl::stack_slot_size;
 422 }
 423 
 424 static int reg2offset_out(VMReg r) {
 425   return (r-&gt;reg2stack() + SharedRuntime::out_preserve_stack_slots()) * VMRegImpl::stack_slot_size;
 426 }
 427 
 428 // ---------------------------------------------------------------------------
 429 // Read the array of BasicTypes from a signature, and compute where the
 430 // arguments should go.  Values in the VMRegPair regs array refer to 4-byte
 431 // quantities.  Values less than VMRegImpl::stack0 are registers, those above
 432 // refer to 4-byte stack slots.  All stack slots are based off of the stack pointer
 433 // as framesizes are fixed.
 434 // VMRegImpl::stack0 refers to the first slot 0(sp).
 435 // and VMRegImpl::stack0+1 refers to the memory word 4-byes higher.  Register
 436 // up to RegisterImpl::number_of_registers) are the 64-bit
 437 // integer registers.
 438 
 439 // Note: the INPUTS in sig_bt are in units of Java argument words, which are
 440 // either 32-bit or 64-bit depending on the build.  The OUTPUTS are in 32-bit
 441 // units regardless of build. Of course for i486 there is no 64 bit build
 442 
 443 // The Java calling convention is a &quot;shifted&quot; version of the C ABI.
 444 // By skipping the first C ABI register we can call non-static jni methods
 445 // with small numbers of arguments without having to shuffle the arguments
 446 // at all. Since we control the java ABI we ought to at least get some
 447 // advantage out of it.
 448 
 449 int SharedRuntime::java_calling_convention(const BasicType *sig_bt,
 450                                            VMRegPair *regs,
 451                                            int total_args_passed,
 452                                            int is_outgoing) {
 453 
 454   // Create the mapping between argument positions and
 455   // registers.
 456   static const Register INT_ArgReg[Argument::n_int_register_parameters_j] = {
 457     j_rarg0, j_rarg1, j_rarg2, j_rarg3, j_rarg4, j_rarg5
 458   };
 459   static const XMMRegister FP_ArgReg[Argument::n_float_register_parameters_j] = {
 460     j_farg0, j_farg1, j_farg2, j_farg3,
 461     j_farg4, j_farg5, j_farg6, j_farg7
 462   };
 463 
 464 
 465   uint int_args = 0;
 466   uint fp_args = 0;
 467   uint stk_args = 0; // inc by 2 each time
 468 
 469   for (int i = 0; i &lt; total_args_passed; i++) {
 470     switch (sig_bt[i]) {
 471     case T_BOOLEAN:
 472     case T_CHAR:
 473     case T_BYTE:
 474     case T_SHORT:
 475     case T_INT:
 476       if (int_args &lt; Argument::n_int_register_parameters_j) {
 477         regs[i].set1(INT_ArgReg[int_args++]-&gt;as_VMReg());
 478       } else {
 479         regs[i].set1(VMRegImpl::stack2reg(stk_args));
 480         stk_args += 2;
 481       }
 482       break;
 483     case T_VOID:
 484       // halves of T_LONG or T_DOUBLE
 485       assert(i != 0 &amp;&amp; (sig_bt[i - 1] == T_LONG || sig_bt[i - 1] == T_DOUBLE), &quot;expecting half&quot;);
 486       regs[i].set_bad();
 487       break;
 488     case T_LONG:
 489       assert((i + 1) &lt; total_args_passed &amp;&amp; sig_bt[i + 1] == T_VOID, &quot;expecting half&quot;);
 490       // fall through
 491     case T_OBJECT:
 492     case T_ARRAY:
 493     case T_ADDRESS:
 494       if (int_args &lt; Argument::n_int_register_parameters_j) {
 495         regs[i].set2(INT_ArgReg[int_args++]-&gt;as_VMReg());
 496       } else {
 497         regs[i].set2(VMRegImpl::stack2reg(stk_args));
 498         stk_args += 2;
 499       }
 500       break;
 501     case T_FLOAT:
 502       if (fp_args &lt; Argument::n_float_register_parameters_j) {
 503         regs[i].set1(FP_ArgReg[fp_args++]-&gt;as_VMReg());
 504       } else {
 505         regs[i].set1(VMRegImpl::stack2reg(stk_args));
 506         stk_args += 2;
 507       }
 508       break;
 509     case T_DOUBLE:
 510       assert((i + 1) &lt; total_args_passed &amp;&amp; sig_bt[i + 1] == T_VOID, &quot;expecting half&quot;);
 511       if (fp_args &lt; Argument::n_float_register_parameters_j) {
 512         regs[i].set2(FP_ArgReg[fp_args++]-&gt;as_VMReg());
 513       } else {
 514         regs[i].set2(VMRegImpl::stack2reg(stk_args));
 515         stk_args += 2;
 516       }
 517       break;
 518     default:
 519       ShouldNotReachHere();
 520       break;
 521     }
 522   }
 523 
 524   return align_up(stk_args, 2);
 525 }
 526 
 527 // Patch the callers callsite with entry to compiled code if it exists.
 528 static void patch_callers_callsite(MacroAssembler *masm) {
 529   Label L;
 530   __ cmpptr(Address(rbx, in_bytes(Method::code_offset())), (int32_t)NULL_WORD);
 531   __ jcc(Assembler::equal, L);
 532 
 533   // Save the current stack pointer
 534   __ mov(r13, rsp);
 535   // Schedule the branch target address early.
 536   // Call into the VM to patch the caller, then jump to compiled callee
 537   // rax isn&#39;t live so capture return address while we easily can
 538   __ movptr(rax, Address(rsp, 0));
 539 
 540   // align stack so push_CPU_state doesn&#39;t fault
 541   __ andptr(rsp, -(StackAlignmentInBytes));
 542   __ push_CPU_state();
 543   __ vzeroupper();
 544   // VM needs caller&#39;s callsite
 545   // VM needs target method
 546   // This needs to be a long call since we will relocate this adapter to
 547   // the codeBuffer and it may not reach
 548 
 549   // Allocate argument register save area
 550   if (frame::arg_reg_save_area_bytes != 0) {
 551     __ subptr(rsp, frame::arg_reg_save_area_bytes);
 552   }
 553   __ mov(c_rarg0, rbx);
 554   __ mov(c_rarg1, rax);
 555   __ call(RuntimeAddress(CAST_FROM_FN_PTR(address, SharedRuntime::fixup_callers_callsite)));
 556 
 557   // De-allocate argument register save area
 558   if (frame::arg_reg_save_area_bytes != 0) {
 559     __ addptr(rsp, frame::arg_reg_save_area_bytes);
 560   }
 561 
 562   __ vzeroupper();
 563   __ pop_CPU_state();
 564   // restore sp
 565   __ mov(rsp, r13);
 566   __ bind(L);
 567 }
 568 
 569 
 570 static void gen_c2i_adapter(MacroAssembler *masm,
 571                             int total_args_passed,
 572                             int comp_args_on_stack,
 573                             const BasicType *sig_bt,
 574                             const VMRegPair *regs,
 575                             Label&amp; skip_fixup) {
 576   // Before we get into the guts of the C2I adapter, see if we should be here
 577   // at all.  We&#39;ve come from compiled code and are attempting to jump to the
 578   // interpreter, which means the caller made a static call to get here
 579   // (vcalls always get a compiled target if there is one).  Check for a
 580   // compiled target.  If there is one, we need to patch the caller&#39;s call.
 581   patch_callers_callsite(masm);
 582 
 583   __ bind(skip_fixup);
 584 
 585   // Since all args are passed on the stack, total_args_passed *
 586   // Interpreter::stackElementSize is the space we need. Plus 1 because
 587   // we also account for the return address location since
 588   // we store it first rather than hold it in rax across all the shuffling
 589 
 590   int extraspace = (total_args_passed * Interpreter::stackElementSize) + wordSize;
 591 
 592   // stack is aligned, keep it that way
 593   extraspace = align_up(extraspace, 2*wordSize);
 594 
 595   // Get return address
 596   __ pop(rax);
 597 
 598   // set senderSP value
 599   __ mov(r13, rsp);
 600 
 601   __ subptr(rsp, extraspace);
 602 
 603   // Store the return address in the expected location
 604   __ movptr(Address(rsp, 0), rax);
 605 
 606   // Now write the args into the outgoing interpreter space
 607   for (int i = 0; i &lt; total_args_passed; i++) {
 608     if (sig_bt[i] == T_VOID) {
 609       assert(i &gt; 0 &amp;&amp; (sig_bt[i-1] == T_LONG || sig_bt[i-1] == T_DOUBLE), &quot;missing half&quot;);
 610       continue;
 611     }
 612 
 613     // offset to start parameters
 614     int st_off   = (total_args_passed - i) * Interpreter::stackElementSize;
 615     int next_off = st_off - Interpreter::stackElementSize;
 616 
 617     // Say 4 args:
 618     // i   st_off
 619     // 0   32 T_LONG
 620     // 1   24 T_VOID
 621     // 2   16 T_OBJECT
 622     // 3    8 T_BOOL
 623     // -    0 return address
 624     //
 625     // However to make thing extra confusing. Because we can fit a long/double in
 626     // a single slot on a 64 bt vm and it would be silly to break them up, the interpreter
 627     // leaves one slot empty and only stores to a single slot. In this case the
 628     // slot that is occupied is the T_VOID slot. See I said it was confusing.
 629 
 630     VMReg r_1 = regs[i].first();
 631     VMReg r_2 = regs[i].second();
 632     if (!r_1-&gt;is_valid()) {
 633       assert(!r_2-&gt;is_valid(), &quot;&quot;);
 634       continue;
 635     }
 636     if (r_1-&gt;is_stack()) {
 637       // memory to memory use rax
 638       int ld_off = r_1-&gt;reg2stack() * VMRegImpl::stack_slot_size + extraspace;
 639       if (!r_2-&gt;is_valid()) {
 640         // sign extend??
 641         __ movl(rax, Address(rsp, ld_off));
 642         __ movptr(Address(rsp, st_off), rax);
 643 
 644       } else {
 645 
 646         __ movq(rax, Address(rsp, ld_off));
 647 
 648         // Two VMREgs|OptoRegs can be T_OBJECT, T_ADDRESS, T_DOUBLE, T_LONG
 649         // T_DOUBLE and T_LONG use two slots in the interpreter
 650         if ( sig_bt[i] == T_LONG || sig_bt[i] == T_DOUBLE) {
 651           // ld_off == LSW, ld_off+wordSize == MSW
 652           // st_off == MSW, next_off == LSW
 653           __ movq(Address(rsp, next_off), rax);
 654 #ifdef ASSERT
 655           // Overwrite the unused slot with known junk
 656           __ mov64(rax, CONST64(0xdeadffffdeadaaaa));
 657           __ movptr(Address(rsp, st_off), rax);
 658 #endif /* ASSERT */
 659         } else {
 660           __ movq(Address(rsp, st_off), rax);
 661         }
 662       }
 663     } else if (r_1-&gt;is_Register()) {
 664       Register r = r_1-&gt;as_Register();
 665       if (!r_2-&gt;is_valid()) {
 666         // must be only an int (or less ) so move only 32bits to slot
 667         // why not sign extend??
 668         __ movl(Address(rsp, st_off), r);
 669       } else {
 670         // Two VMREgs|OptoRegs can be T_OBJECT, T_ADDRESS, T_DOUBLE, T_LONG
 671         // T_DOUBLE and T_LONG use two slots in the interpreter
 672         if ( sig_bt[i] == T_LONG || sig_bt[i] == T_DOUBLE) {
 673           // long/double in gpr
 674 #ifdef ASSERT
 675           // Overwrite the unused slot with known junk
 676           __ mov64(rax, CONST64(0xdeadffffdeadaaab));
 677           __ movptr(Address(rsp, st_off), rax);
 678 #endif /* ASSERT */
 679           __ movq(Address(rsp, next_off), r);
 680         } else {
 681           __ movptr(Address(rsp, st_off), r);
 682         }
 683       }
 684     } else {
 685       assert(r_1-&gt;is_XMMRegister(), &quot;&quot;);
 686       if (!r_2-&gt;is_valid()) {
 687         // only a float use just part of the slot
 688         __ movflt(Address(rsp, st_off), r_1-&gt;as_XMMRegister());
 689       } else {
 690 #ifdef ASSERT
 691         // Overwrite the unused slot with known junk
 692         __ mov64(rax, CONST64(0xdeadffffdeadaaac));
 693         __ movptr(Address(rsp, st_off), rax);
 694 #endif /* ASSERT */
 695         __ movdbl(Address(rsp, next_off), r_1-&gt;as_XMMRegister());
 696       }
 697     }
 698   }
 699 
 700   // Schedule the branch target address early.
 701   __ movptr(rcx, Address(rbx, in_bytes(Method::interpreter_entry_offset())));
 702   __ jmp(rcx);
 703 }
 704 
 705 static void range_check(MacroAssembler* masm, Register pc_reg, Register temp_reg,
 706                         address code_start, address code_end,
 707                         Label&amp; L_ok) {
 708   Label L_fail;
 709   __ lea(temp_reg, ExternalAddress(code_start));
 710   __ cmpptr(pc_reg, temp_reg);
 711   __ jcc(Assembler::belowEqual, L_fail);
 712   __ lea(temp_reg, ExternalAddress(code_end));
 713   __ cmpptr(pc_reg, temp_reg);
 714   __ jcc(Assembler::below, L_ok);
 715   __ bind(L_fail);
 716 }
 717 
 718 void SharedRuntime::gen_i2c_adapter(MacroAssembler *masm,
 719                                     int total_args_passed,
 720                                     int comp_args_on_stack,
 721                                     const BasicType *sig_bt,
 722                                     const VMRegPair *regs) {
 723 
 724   // Note: r13 contains the senderSP on entry. We must preserve it since
 725   // we may do a i2c -&gt; c2i transition if we lose a race where compiled
 726   // code goes non-entrant while we get args ready.
 727   // In addition we use r13 to locate all the interpreter args as
 728   // we must align the stack to 16 bytes on an i2c entry else we
 729   // lose alignment we expect in all compiled code and register
 730   // save code can segv when fxsave instructions find improperly
 731   // aligned stack pointer.
 732 
 733   // Adapters can be frameless because they do not require the caller
 734   // to perform additional cleanup work, such as correcting the stack pointer.
 735   // An i2c adapter is frameless because the *caller* frame, which is interpreted,
 736   // routinely repairs its own stack pointer (from interpreter_frame_last_sp),
 737   // even if a callee has modified the stack pointer.
 738   // A c2i adapter is frameless because the *callee* frame, which is interpreted,
 739   // routinely repairs its caller&#39;s stack pointer (from sender_sp, which is set
 740   // up via the senderSP register).
 741   // In other words, if *either* the caller or callee is interpreted, we can
 742   // get the stack pointer repaired after a call.
 743   // This is why c2i and i2c adapters cannot be indefinitely composed.
 744   // In particular, if a c2i adapter were to somehow call an i2c adapter,
 745   // both caller and callee would be compiled methods, and neither would
 746   // clean up the stack pointer changes performed by the two adapters.
 747   // If this happens, control eventually transfers back to the compiled
 748   // caller, but with an uncorrected stack, causing delayed havoc.
 749 
 750   // Pick up the return address
 751   __ movptr(rax, Address(rsp, 0));
 752 
 753   if (VerifyAdapterCalls &amp;&amp;
 754       (Interpreter::code() != NULL || StubRoutines::code1() != NULL)) {
 755     // So, let&#39;s test for cascading c2i/i2c adapters right now.
 756     //  assert(Interpreter::contains($return_addr) ||
 757     //         StubRoutines::contains($return_addr),
 758     //         &quot;i2c adapter must return to an interpreter frame&quot;);
 759     __ block_comment(&quot;verify_i2c { &quot;);
 760     Label L_ok;
 761     if (Interpreter::code() != NULL)
 762       range_check(masm, rax, r11,
 763                   Interpreter::code()-&gt;code_start(), Interpreter::code()-&gt;code_end(),
 764                   L_ok);
 765     if (StubRoutines::code1() != NULL)
 766       range_check(masm, rax, r11,
 767                   StubRoutines::code1()-&gt;code_begin(), StubRoutines::code1()-&gt;code_end(),
 768                   L_ok);
 769     if (StubRoutines::code2() != NULL)
 770       range_check(masm, rax, r11,
 771                   StubRoutines::code2()-&gt;code_begin(), StubRoutines::code2()-&gt;code_end(),
 772                   L_ok);
 773     const char* msg = &quot;i2c adapter must return to an interpreter frame&quot;;
 774     __ block_comment(msg);
 775     __ stop(msg);
 776     __ bind(L_ok);
 777     __ block_comment(&quot;} verify_i2ce &quot;);
 778   }
 779 
 780   // Must preserve original SP for loading incoming arguments because
 781   // we need to align the outgoing SP for compiled code.
 782   __ movptr(r11, rsp);
 783 
 784   // Cut-out for having no stack args.  Since up to 2 int/oop args are passed
 785   // in registers, we will occasionally have no stack args.
 786   int comp_words_on_stack = 0;
 787   if (comp_args_on_stack) {
 788     // Sig words on the stack are greater-than VMRegImpl::stack0.  Those in
 789     // registers are below.  By subtracting stack0, we either get a negative
 790     // number (all values in registers) or the maximum stack slot accessed.
 791 
 792     // Convert 4-byte c2 stack slots to words.
 793     comp_words_on_stack = align_up(comp_args_on_stack*VMRegImpl::stack_slot_size, wordSize)&gt;&gt;LogBytesPerWord;
 794     // Round up to miminum stack alignment, in wordSize
 795     comp_words_on_stack = align_up(comp_words_on_stack, 2);
 796     __ subptr(rsp, comp_words_on_stack * wordSize);
 797   }
 798 
 799 
 800   // Ensure compiled code always sees stack at proper alignment
 801   __ andptr(rsp, -16);
 802 
 803   // push the return address and misalign the stack that youngest frame always sees
 804   // as far as the placement of the call instruction
 805   __ push(rax);
 806 
 807   // Put saved SP in another register
 808   const Register saved_sp = rax;
 809   __ movptr(saved_sp, r11);
 810 
 811   // Will jump to the compiled code just as if compiled code was doing it.
 812   // Pre-load the register-jump target early, to schedule it better.
 813   __ movptr(r11, Address(rbx, in_bytes(Method::from_compiled_offset())));
 814 
 815 #if INCLUDE_JVMCI
 816   if (EnableJVMCI || UseAOT) {
 817     // check if this call should be routed towards a specific entry point
 818     __ cmpptr(Address(r15_thread, in_bytes(JavaThread::jvmci_alternate_call_target_offset())), 0);
 819     Label no_alternative_target;
 820     __ jcc(Assembler::equal, no_alternative_target);
 821     __ movptr(r11, Address(r15_thread, in_bytes(JavaThread::jvmci_alternate_call_target_offset())));
 822     __ movptr(Address(r15_thread, in_bytes(JavaThread::jvmci_alternate_call_target_offset())), 0);
 823     __ bind(no_alternative_target);
 824   }
 825 #endif // INCLUDE_JVMCI
 826 
 827   // Now generate the shuffle code.  Pick up all register args and move the
 828   // rest through the floating point stack top.
 829   for (int i = 0; i &lt; total_args_passed; i++) {
 830     if (sig_bt[i] == T_VOID) {
 831       // Longs and doubles are passed in native word order, but misaligned
 832       // in the 32-bit build.
 833       assert(i &gt; 0 &amp;&amp; (sig_bt[i-1] == T_LONG || sig_bt[i-1] == T_DOUBLE), &quot;missing half&quot;);
 834       continue;
 835     }
 836 
 837     // Pick up 0, 1 or 2 words from SP+offset.
 838 
 839     assert(!regs[i].second()-&gt;is_valid() || regs[i].first()-&gt;next() == regs[i].second(),
 840             &quot;scrambled load targets?&quot;);
 841     // Load in argument order going down.
 842     int ld_off = (total_args_passed - i)*Interpreter::stackElementSize;
 843     // Point to interpreter value (vs. tag)
 844     int next_off = ld_off - Interpreter::stackElementSize;
 845     //
 846     //
 847     //
 848     VMReg r_1 = regs[i].first();
 849     VMReg r_2 = regs[i].second();
 850     if (!r_1-&gt;is_valid()) {
 851       assert(!r_2-&gt;is_valid(), &quot;&quot;);
 852       continue;
 853     }
 854     if (r_1-&gt;is_stack()) {
 855       // Convert stack slot to an SP offset (+ wordSize to account for return address )
 856       int st_off = regs[i].first()-&gt;reg2stack()*VMRegImpl::stack_slot_size + wordSize;
 857 
 858       // We can use r13 as a temp here because compiled code doesn&#39;t need r13 as an input
 859       // and if we end up going thru a c2i because of a miss a reasonable value of r13
 860       // will be generated.
 861       if (!r_2-&gt;is_valid()) {
 862         // sign extend???
 863         __ movl(r13, Address(saved_sp, ld_off));
 864         __ movptr(Address(rsp, st_off), r13);
 865       } else {
 866         //
 867         // We are using two optoregs. This can be either T_OBJECT, T_ADDRESS, T_LONG, or T_DOUBLE
 868         // the interpreter allocates two slots but only uses one for thr T_LONG or T_DOUBLE case
 869         // So we must adjust where to pick up the data to match the interpreter.
 870         //
 871         // Interpreter local[n] == MSW, local[n+1] == LSW however locals
 872         // are accessed as negative so LSW is at LOW address
 873 
 874         // ld_off is MSW so get LSW
 875         const int offset = (sig_bt[i]==T_LONG||sig_bt[i]==T_DOUBLE)?
 876                            next_off : ld_off;
 877         __ movq(r13, Address(saved_sp, offset));
 878         // st_off is LSW (i.e. reg.first())
 879         __ movq(Address(rsp, st_off), r13);
 880       }
 881     } else if (r_1-&gt;is_Register()) {  // Register argument
 882       Register r = r_1-&gt;as_Register();
 883       assert(r != rax, &quot;must be different&quot;);
 884       if (r_2-&gt;is_valid()) {
 885         //
 886         // We are using two VMRegs. This can be either T_OBJECT, T_ADDRESS, T_LONG, or T_DOUBLE
 887         // the interpreter allocates two slots but only uses one for thr T_LONG or T_DOUBLE case
 888         // So we must adjust where to pick up the data to match the interpreter.
 889 
 890         const int offset = (sig_bt[i]==T_LONG||sig_bt[i]==T_DOUBLE)?
 891                            next_off : ld_off;
 892 
 893         // this can be a misaligned move
 894         __ movq(r, Address(saved_sp, offset));
 895       } else {
 896         // sign extend and use a full word?
 897         __ movl(r, Address(saved_sp, ld_off));
 898       }
 899     } else {
 900       if (!r_2-&gt;is_valid()) {
 901         __ movflt(r_1-&gt;as_XMMRegister(), Address(saved_sp, ld_off));
 902       } else {
 903         __ movdbl(r_1-&gt;as_XMMRegister(), Address(saved_sp, next_off));
 904       }
 905     }
 906   }
 907 
 908   // 6243940 We might end up in handle_wrong_method if
 909   // the callee is deoptimized as we race thru here. If that
 910   // happens we don&#39;t want to take a safepoint because the
 911   // caller frame will look interpreted and arguments are now
 912   // &quot;compiled&quot; so it is much better to make this transition
 913   // invisible to the stack walking code. Unfortunately if
 914   // we try and find the callee by normal means a safepoint
 915   // is possible. So we stash the desired callee in the thread
 916   // and the vm will find there should this case occur.
 917 
 918   __ movptr(Address(r15_thread, JavaThread::callee_target_offset()), rbx);
 919 
 920   // put Method* where a c2i would expect should we end up there
 921   // only needed becaus eof c2 resolve stubs return Method* as a result in
 922   // rax
 923   __ mov(rax, rbx);
 924   __ jmp(r11);
 925 }
 926 
 927 // ---------------------------------------------------------------
 928 AdapterHandlerEntry* SharedRuntime::generate_i2c2i_adapters(MacroAssembler *masm,
 929                                                             int total_args_passed,
 930                                                             int comp_args_on_stack,
 931                                                             const BasicType *sig_bt,
 932                                                             const VMRegPair *regs,
 933                                                             AdapterFingerPrint* fingerprint) {
 934   address i2c_entry = __ pc();
 935 
 936   gen_i2c_adapter(masm, total_args_passed, comp_args_on_stack, sig_bt, regs);
 937 
 938   // -------------------------------------------------------------------------
 939   // Generate a C2I adapter.  On entry we know rbx holds the Method* during calls
 940   // to the interpreter.  The args start out packed in the compiled layout.  They
 941   // need to be unpacked into the interpreter layout.  This will almost always
 942   // require some stack space.  We grow the current (compiled) stack, then repack
 943   // the args.  We  finally end in a jump to the generic interpreter entry point.
 944   // On exit from the interpreter, the interpreter will restore our SP (lest the
 945   // compiled code, which relys solely on SP and not RBP, get sick).
 946 
 947   address c2i_unverified_entry = __ pc();
 948   Label skip_fixup;
 949   Label ok;
 950 
 951   Register holder = rax;
 952   Register receiver = j_rarg0;
 953   Register temp = rbx;
 954 
 955   {
 956     __ load_klass(temp, receiver);
 957     __ cmpptr(temp, Address(holder, CompiledICHolder::holder_klass_offset()));
 958     __ movptr(rbx, Address(holder, CompiledICHolder::holder_metadata_offset()));
 959     __ jcc(Assembler::equal, ok);
 960     __ jump(RuntimeAddress(SharedRuntime::get_ic_miss_stub()));
 961 
 962     __ bind(ok);
 963     // Method might have been compiled since the call site was patched to
 964     // interpreted if that is the case treat it as a miss so we can get
 965     // the call site corrected.
 966     __ cmpptr(Address(rbx, in_bytes(Method::code_offset())), (int32_t)NULL_WORD);
 967     __ jcc(Assembler::equal, skip_fixup);
 968     __ jump(RuntimeAddress(SharedRuntime::get_ic_miss_stub()));
 969   }
 970 
 971   address c2i_entry = __ pc();
 972 
 973   gen_c2i_adapter(masm, total_args_passed, comp_args_on_stack, sig_bt, regs, skip_fixup);
 974 
 975   __ flush();
 976   return AdapterHandlerLibrary::new_entry(fingerprint, i2c_entry, c2i_entry, c2i_unverified_entry);
 977 }
 978 
 979 int SharedRuntime::c_calling_convention(const BasicType *sig_bt,
 980                                          VMRegPair *regs,
 981                                          VMRegPair *regs2,
 982                                          int total_args_passed) {
 983   assert(regs2 == NULL, &quot;not needed on x86&quot;);
 984 // We return the amount of VMRegImpl stack slots we need to reserve for all
 985 // the arguments NOT counting out_preserve_stack_slots.
 986 
 987 // NOTE: These arrays will have to change when c1 is ported
 988 #ifdef _WIN64
 989     static const Register INT_ArgReg[Argument::n_int_register_parameters_c] = {
 990       c_rarg0, c_rarg1, c_rarg2, c_rarg3
 991     };
 992     static const XMMRegister FP_ArgReg[Argument::n_float_register_parameters_c] = {
 993       c_farg0, c_farg1, c_farg2, c_farg3
 994     };
 995 #else
 996     static const Register INT_ArgReg[Argument::n_int_register_parameters_c] = {
 997       c_rarg0, c_rarg1, c_rarg2, c_rarg3, c_rarg4, c_rarg5
 998     };
 999     static const XMMRegister FP_ArgReg[Argument::n_float_register_parameters_c] = {
1000       c_farg0, c_farg1, c_farg2, c_farg3,
1001       c_farg4, c_farg5, c_farg6, c_farg7
1002     };
1003 #endif // _WIN64
1004 
1005 
1006     uint int_args = 0;
1007     uint fp_args = 0;
1008     uint stk_args = 0; // inc by 2 each time
1009 
1010     for (int i = 0; i &lt; total_args_passed; i++) {
1011       switch (sig_bt[i]) {
1012       case T_BOOLEAN:
1013       case T_CHAR:
1014       case T_BYTE:
1015       case T_SHORT:
1016       case T_INT:
1017         if (int_args &lt; Argument::n_int_register_parameters_c) {
1018           regs[i].set1(INT_ArgReg[int_args++]-&gt;as_VMReg());
1019 #ifdef _WIN64
1020           fp_args++;
1021           // Allocate slots for callee to stuff register args the stack.
1022           stk_args += 2;
1023 #endif
1024         } else {
1025           regs[i].set1(VMRegImpl::stack2reg(stk_args));
1026           stk_args += 2;
1027         }
1028         break;
1029       case T_LONG:
1030         assert((i + 1) &lt; total_args_passed &amp;&amp; sig_bt[i + 1] == T_VOID, &quot;expecting half&quot;);
1031         // fall through
1032       case T_OBJECT:
1033       case T_ARRAY:
1034       case T_ADDRESS:
1035       case T_METADATA:
1036         if (int_args &lt; Argument::n_int_register_parameters_c) {
1037           regs[i].set2(INT_ArgReg[int_args++]-&gt;as_VMReg());
1038 #ifdef _WIN64
1039           fp_args++;
1040           stk_args += 2;
1041 #endif
1042         } else {
1043           regs[i].set2(VMRegImpl::stack2reg(stk_args));
1044           stk_args += 2;
1045         }
1046         break;
1047       case T_FLOAT:
1048         if (fp_args &lt; Argument::n_float_register_parameters_c) {
1049           regs[i].set1(FP_ArgReg[fp_args++]-&gt;as_VMReg());
1050 #ifdef _WIN64
1051           int_args++;
1052           // Allocate slots for callee to stuff register args the stack.
1053           stk_args += 2;
1054 #endif
1055         } else {
1056           regs[i].set1(VMRegImpl::stack2reg(stk_args));
1057           stk_args += 2;
1058         }
1059         break;
1060       case T_DOUBLE:
1061         assert((i + 1) &lt; total_args_passed &amp;&amp; sig_bt[i + 1] == T_VOID, &quot;expecting half&quot;);
1062         if (fp_args &lt; Argument::n_float_register_parameters_c) {
1063           regs[i].set2(FP_ArgReg[fp_args++]-&gt;as_VMReg());
1064 #ifdef _WIN64
1065           int_args++;
1066           // Allocate slots for callee to stuff register args the stack.
1067           stk_args += 2;
1068 #endif
1069         } else {
1070           regs[i].set2(VMRegImpl::stack2reg(stk_args));
1071           stk_args += 2;
1072         }
1073         break;
1074       case T_VOID: // Halves of longs and doubles
1075         assert(i != 0 &amp;&amp; (sig_bt[i - 1] == T_LONG || sig_bt[i - 1] == T_DOUBLE), &quot;expecting half&quot;);
1076         regs[i].set_bad();
1077         break;
1078       default:
1079         ShouldNotReachHere();
1080         break;
1081       }
1082     }
1083 #ifdef _WIN64
1084   // windows abi requires that we always allocate enough stack space
1085   // for 4 64bit registers to be stored down.
1086   if (stk_args &lt; 8) {
1087     stk_args = 8;
1088   }
1089 #endif // _WIN64
1090 
1091   return stk_args;
1092 }
1093 
1094 // On 64 bit we will store integer like items to the stack as
1095 // 64 bits items (sparc abi) even though java would only store
1096 // 32bits for a parameter. On 32bit it will simply be 32 bits
1097 // So this routine will do 32-&gt;32 on 32bit and 32-&gt;64 on 64bit
1098 static void move32_64(MacroAssembler* masm, VMRegPair src, VMRegPair dst) {
1099   if (src.first()-&gt;is_stack()) {
1100     if (dst.first()-&gt;is_stack()) {
1101       // stack to stack
1102       __ movslq(rax, Address(rbp, reg2offset_in(src.first())));
1103       __ movq(Address(rsp, reg2offset_out(dst.first())), rax);
1104     } else {
1105       // stack to reg
1106       __ movslq(dst.first()-&gt;as_Register(), Address(rbp, reg2offset_in(src.first())));
1107     }
1108   } else if (dst.first()-&gt;is_stack()) {
1109     // reg to stack
1110     // Do we really have to sign extend???
1111     // __ movslq(src.first()-&gt;as_Register(), src.first()-&gt;as_Register());
1112     __ movq(Address(rsp, reg2offset_out(dst.first())), src.first()-&gt;as_Register());
1113   } else {
1114     // Do we really have to sign extend???
1115     // __ movslq(dst.first()-&gt;as_Register(), src.first()-&gt;as_Register());
1116     if (dst.first() != src.first()) {
1117       __ movq(dst.first()-&gt;as_Register(), src.first()-&gt;as_Register());
1118     }
1119   }
1120 }
1121 
1122 static void move_ptr(MacroAssembler* masm, VMRegPair src, VMRegPair dst) {
1123   if (src.first()-&gt;is_stack()) {
1124     if (dst.first()-&gt;is_stack()) {
1125       // stack to stack
1126       __ movq(rax, Address(rbp, reg2offset_in(src.first())));
1127       __ movq(Address(rsp, reg2offset_out(dst.first())), rax);
1128     } else {
1129       // stack to reg
1130       __ movq(dst.first()-&gt;as_Register(), Address(rbp, reg2offset_in(src.first())));
1131     }
1132   } else if (dst.first()-&gt;is_stack()) {
1133     // reg to stack
1134     __ movq(Address(rsp, reg2offset_out(dst.first())), src.first()-&gt;as_Register());
1135   } else {
1136     if (dst.first() != src.first()) {
1137       __ movq(dst.first()-&gt;as_Register(), src.first()-&gt;as_Register());
1138     }
1139   }
1140 }
1141 
1142 // An oop arg. Must pass a handle not the oop itself
1143 static void object_move(MacroAssembler* masm,
1144                         OopMap* map,
1145                         int oop_handle_offset,
1146                         int framesize_in_slots,
1147                         VMRegPair src,
1148                         VMRegPair dst,
1149                         bool is_receiver,
1150                         int* receiver_offset) {
1151 
1152   // must pass a handle. First figure out the location we use as a handle
1153 
1154   Register rHandle = dst.first()-&gt;is_stack() ? rax : dst.first()-&gt;as_Register();
1155 
1156   // See if oop is NULL if it is we need no handle
1157 
1158   if (src.first()-&gt;is_stack()) {
1159 
1160     // Oop is already on the stack as an argument
1161     int offset_in_older_frame = src.first()-&gt;reg2stack() + SharedRuntime::out_preserve_stack_slots();
1162     map-&gt;set_oop(VMRegImpl::stack2reg(offset_in_older_frame + framesize_in_slots));
1163     if (is_receiver) {
1164       *receiver_offset = (offset_in_older_frame + framesize_in_slots) * VMRegImpl::stack_slot_size;
1165     }
1166 
1167     __ cmpptr(Address(rbp, reg2offset_in(src.first())), (int32_t)NULL_WORD);
1168     __ lea(rHandle, Address(rbp, reg2offset_in(src.first())));
1169     // conditionally move a NULL
1170     __ cmovptr(Assembler::equal, rHandle, Address(rbp, reg2offset_in(src.first())));
1171   } else {
1172 
1173     // Oop is in an a register we must store it to the space we reserve
1174     // on the stack for oop_handles and pass a handle if oop is non-NULL
1175 
1176     const Register rOop = src.first()-&gt;as_Register();
1177     int oop_slot;
1178     if (rOop == j_rarg0)
1179       oop_slot = 0;
1180     else if (rOop == j_rarg1)
1181       oop_slot = 1;
1182     else if (rOop == j_rarg2)
1183       oop_slot = 2;
1184     else if (rOop == j_rarg3)
1185       oop_slot = 3;
1186     else if (rOop == j_rarg4)
1187       oop_slot = 4;
1188     else {
1189       assert(rOop == j_rarg5, &quot;wrong register&quot;);
1190       oop_slot = 5;
1191     }
1192 
1193     oop_slot = oop_slot * VMRegImpl::slots_per_word + oop_handle_offset;
1194     int offset = oop_slot*VMRegImpl::stack_slot_size;
1195 
1196     map-&gt;set_oop(VMRegImpl::stack2reg(oop_slot));
1197     // Store oop in handle area, may be NULL
1198     __ movptr(Address(rsp, offset), rOop);
1199     if (is_receiver) {
1200       *receiver_offset = offset;
1201     }
1202 
1203     __ cmpptr(rOop, (int32_t)NULL_WORD);
1204     __ lea(rHandle, Address(rsp, offset));
1205     // conditionally move a NULL from the handle area where it was just stored
1206     __ cmovptr(Assembler::equal, rHandle, Address(rsp, offset));
1207   }
1208 
1209   // If arg is on the stack then place it otherwise it is already in correct reg.
1210   if (dst.first()-&gt;is_stack()) {
1211     __ movptr(Address(rsp, reg2offset_out(dst.first())), rHandle);
1212   }
1213 }
1214 
1215 // A float arg may have to do float reg int reg conversion
1216 static void float_move(MacroAssembler* masm, VMRegPair src, VMRegPair dst) {
1217   assert(!src.second()-&gt;is_valid() &amp;&amp; !dst.second()-&gt;is_valid(), &quot;bad float_move&quot;);
1218 
1219   // The calling conventions assures us that each VMregpair is either
1220   // all really one physical register or adjacent stack slots.
1221   // This greatly simplifies the cases here compared to sparc.
1222 
1223   if (src.first()-&gt;is_stack()) {
1224     if (dst.first()-&gt;is_stack()) {
1225       __ movl(rax, Address(rbp, reg2offset_in(src.first())));
1226       __ movptr(Address(rsp, reg2offset_out(dst.first())), rax);
1227     } else {
1228       // stack to reg
1229       assert(dst.first()-&gt;is_XMMRegister(), &quot;only expect xmm registers as parameters&quot;);
1230       __ movflt(dst.first()-&gt;as_XMMRegister(), Address(rbp, reg2offset_in(src.first())));
1231     }
1232   } else if (dst.first()-&gt;is_stack()) {
1233     // reg to stack
1234     assert(src.first()-&gt;is_XMMRegister(), &quot;only expect xmm registers as parameters&quot;);
1235     __ movflt(Address(rsp, reg2offset_out(dst.first())), src.first()-&gt;as_XMMRegister());
1236   } else {
1237     // reg to reg
1238     // In theory these overlap but the ordering is such that this is likely a nop
1239     if ( src.first() != dst.first()) {
1240       __ movdbl(dst.first()-&gt;as_XMMRegister(),  src.first()-&gt;as_XMMRegister());
1241     }
1242   }
1243 }
1244 
1245 // A long move
1246 static void long_move(MacroAssembler* masm, VMRegPair src, VMRegPair dst) {
1247 
1248   // The calling conventions assures us that each VMregpair is either
1249   // all really one physical register or adjacent stack slots.
1250   // This greatly simplifies the cases here compared to sparc.
1251 
1252   if (src.is_single_phys_reg() ) {
1253     if (dst.is_single_phys_reg()) {
1254       if (dst.first() != src.first()) {
1255         __ mov(dst.first()-&gt;as_Register(), src.first()-&gt;as_Register());
1256       }
1257     } else {
1258       assert(dst.is_single_reg(), &quot;not a stack pair&quot;);
1259       __ movq(Address(rsp, reg2offset_out(dst.first())), src.first()-&gt;as_Register());
1260     }
1261   } else if (dst.is_single_phys_reg()) {
1262     assert(src.is_single_reg(),  &quot;not a stack pair&quot;);
1263     __ movq(dst.first()-&gt;as_Register(), Address(rbp, reg2offset_out(src.first())));
1264   } else {
1265     assert(src.is_single_reg() &amp;&amp; dst.is_single_reg(), &quot;not stack pairs&quot;);
1266     __ movq(rax, Address(rbp, reg2offset_in(src.first())));
1267     __ movq(Address(rsp, reg2offset_out(dst.first())), rax);
1268   }
1269 }
1270 
1271 // A double move
1272 static void double_move(MacroAssembler* masm, VMRegPair src, VMRegPair dst) {
1273 
1274   // The calling conventions assures us that each VMregpair is either
1275   // all really one physical register or adjacent stack slots.
1276   // This greatly simplifies the cases here compared to sparc.
1277 
1278   if (src.is_single_phys_reg() ) {
1279     if (dst.is_single_phys_reg()) {
1280       // In theory these overlap but the ordering is such that this is likely a nop
1281       if ( src.first() != dst.first()) {
1282         __ movdbl(dst.first()-&gt;as_XMMRegister(), src.first()-&gt;as_XMMRegister());
1283       }
1284     } else {
1285       assert(dst.is_single_reg(), &quot;not a stack pair&quot;);
1286       __ movdbl(Address(rsp, reg2offset_out(dst.first())), src.first()-&gt;as_XMMRegister());
1287     }
1288   } else if (dst.is_single_phys_reg()) {
1289     assert(src.is_single_reg(),  &quot;not a stack pair&quot;);
1290     __ movdbl(dst.first()-&gt;as_XMMRegister(), Address(rbp, reg2offset_out(src.first())));
1291   } else {
1292     assert(src.is_single_reg() &amp;&amp; dst.is_single_reg(), &quot;not stack pairs&quot;);
1293     __ movq(rax, Address(rbp, reg2offset_in(src.first())));
1294     __ movq(Address(rsp, reg2offset_out(dst.first())), rax);
1295   }
1296 }
1297 
1298 
1299 void SharedRuntime::save_native_result(MacroAssembler *masm, BasicType ret_type, int frame_slots) {
1300   // We always ignore the frame_slots arg and just use the space just below frame pointer
1301   // which by this time is free to use
1302   switch (ret_type) {
1303   case T_FLOAT:
1304     __ movflt(Address(rbp, -wordSize), xmm0);
1305     break;
1306   case T_DOUBLE:
1307     __ movdbl(Address(rbp, -wordSize), xmm0);
1308     break;
1309   case T_VOID:  break;
1310   default: {
1311     __ movptr(Address(rbp, -wordSize), rax);
1312     }
1313   }
1314 }
1315 
1316 void SharedRuntime::restore_native_result(MacroAssembler *masm, BasicType ret_type, int frame_slots) {
1317   // We always ignore the frame_slots arg and just use the space just below frame pointer
1318   // which by this time is free to use
1319   switch (ret_type) {
1320   case T_FLOAT:
1321     __ movflt(xmm0, Address(rbp, -wordSize));
1322     break;
1323   case T_DOUBLE:
1324     __ movdbl(xmm0, Address(rbp, -wordSize));
1325     break;
1326   case T_VOID:  break;
1327   default: {
1328     __ movptr(rax, Address(rbp, -wordSize));
1329     }
1330   }
1331 }
1332 
1333 static void save_args(MacroAssembler *masm, int arg_count, int first_arg, VMRegPair *args) {
1334     for ( int i = first_arg ; i &lt; arg_count ; i++ ) {
1335       if (args[i].first()-&gt;is_Register()) {
1336         __ push(args[i].first()-&gt;as_Register());
1337       } else if (args[i].first()-&gt;is_XMMRegister()) {
1338         __ subptr(rsp, 2*wordSize);
1339         __ movdbl(Address(rsp, 0), args[i].first()-&gt;as_XMMRegister());
1340       }
1341     }
1342 }
1343 
1344 static void restore_args(MacroAssembler *masm, int arg_count, int first_arg, VMRegPair *args) {
1345     for ( int i = arg_count - 1 ; i &gt;= first_arg ; i-- ) {
1346       if (args[i].first()-&gt;is_Register()) {
1347         __ pop(args[i].first()-&gt;as_Register());
1348       } else if (args[i].first()-&gt;is_XMMRegister()) {
1349         __ movdbl(args[i].first()-&gt;as_XMMRegister(), Address(rsp, 0));
1350         __ addptr(rsp, 2*wordSize);
1351       }
1352     }
1353 }
1354 
1355 
1356 static void save_or_restore_arguments(MacroAssembler* masm,
1357                                       const int stack_slots,
1358                                       const int total_in_args,
1359                                       const int arg_save_area,
1360                                       OopMap* map,
1361                                       VMRegPair* in_regs,
1362                                       BasicType* in_sig_bt) {
1363   // if map is non-NULL then the code should store the values,
1364   // otherwise it should load them.
1365   int slot = arg_save_area;
1366   // Save down double word first
1367   for ( int i = 0; i &lt; total_in_args; i++) {
1368     if (in_regs[i].first()-&gt;is_XMMRegister() &amp;&amp; in_sig_bt[i] == T_DOUBLE) {
1369       int offset = slot * VMRegImpl::stack_slot_size;
1370       slot += VMRegImpl::slots_per_word;
1371       assert(slot &lt;= stack_slots, &quot;overflow&quot;);
1372       if (map != NULL) {
1373         __ movdbl(Address(rsp, offset), in_regs[i].first()-&gt;as_XMMRegister());
1374       } else {
1375         __ movdbl(in_regs[i].first()-&gt;as_XMMRegister(), Address(rsp, offset));
1376       }
1377     }
1378     if (in_regs[i].first()-&gt;is_Register() &amp;&amp;
1379         (in_sig_bt[i] == T_LONG || in_sig_bt[i] == T_ARRAY)) {
1380       int offset = slot * VMRegImpl::stack_slot_size;
1381       if (map != NULL) {
1382         __ movq(Address(rsp, offset), in_regs[i].first()-&gt;as_Register());
1383         if (in_sig_bt[i] == T_ARRAY) {
1384           map-&gt;set_oop(VMRegImpl::stack2reg(slot));;
1385         }
1386       } else {
1387         __ movq(in_regs[i].first()-&gt;as_Register(), Address(rsp, offset));
1388       }
1389       slot += VMRegImpl::slots_per_word;
1390     }
1391   }
1392   // Save or restore single word registers
1393   for ( int i = 0; i &lt; total_in_args; i++) {
1394     if (in_regs[i].first()-&gt;is_Register()) {
1395       int offset = slot * VMRegImpl::stack_slot_size;
1396       slot++;
1397       assert(slot &lt;= stack_slots, &quot;overflow&quot;);
1398 
1399       // Value is in an input register pass we must flush it to the stack
1400       const Register reg = in_regs[i].first()-&gt;as_Register();
1401       switch (in_sig_bt[i]) {
1402         case T_BOOLEAN:
1403         case T_CHAR:
1404         case T_BYTE:
1405         case T_SHORT:
1406         case T_INT:
1407           if (map != NULL) {
1408             __ movl(Address(rsp, offset), reg);
1409           } else {
1410             __ movl(reg, Address(rsp, offset));
1411           }
1412           break;
1413         case T_ARRAY:
1414         case T_LONG:
1415           // handled above
1416           break;
1417         case T_OBJECT:
1418         default: ShouldNotReachHere();
1419       }
1420     } else if (in_regs[i].first()-&gt;is_XMMRegister()) {
1421       if (in_sig_bt[i] == T_FLOAT) {
1422         int offset = slot * VMRegImpl::stack_slot_size;
1423         slot++;
1424         assert(slot &lt;= stack_slots, &quot;overflow&quot;);
1425         if (map != NULL) {
1426           __ movflt(Address(rsp, offset), in_regs[i].first()-&gt;as_XMMRegister());
1427         } else {
1428           __ movflt(in_regs[i].first()-&gt;as_XMMRegister(), Address(rsp, offset));
1429         }
1430       }
1431     } else if (in_regs[i].first()-&gt;is_stack()) {
1432       if (in_sig_bt[i] == T_ARRAY &amp;&amp; map != NULL) {
1433         int offset_in_older_frame = in_regs[i].first()-&gt;reg2stack() + SharedRuntime::out_preserve_stack_slots();
1434         map-&gt;set_oop(VMRegImpl::stack2reg(offset_in_older_frame + stack_slots));
1435       }
1436     }
1437   }
1438 }
1439 
1440 // Pin object, return pinned object or null in rax
1441 static void gen_pin_object(MacroAssembler* masm,
1442                            VMRegPair reg) {
1443   __ block_comment(&quot;gen_pin_object {&quot;);
1444 
1445   // rax always contains oop, either incoming or
1446   // pinned.
1447   Register tmp_reg = rax;
1448 
1449   Label is_null;
1450   VMRegPair tmp;
1451   VMRegPair in_reg = reg;
1452 
1453   tmp.set_ptr(tmp_reg-&gt;as_VMReg());
1454   if (reg.first()-&gt;is_stack()) {
1455     // Load the arg up from the stack
1456     move_ptr(masm, reg, tmp);
1457     reg = tmp;
1458   } else {
1459     __ movptr(rax, reg.first()-&gt;as_Register());
1460   }
1461   __ testptr(reg.first()-&gt;as_Register(), reg.first()-&gt;as_Register());
1462   __ jccb(Assembler::equal, is_null);
1463 
1464   if (reg.first()-&gt;as_Register() != c_rarg1) {
1465     __ movptr(c_rarg1, reg.first()-&gt;as_Register());
1466   }
1467 
1468   __ call_VM_leaf(
1469     CAST_FROM_FN_PTR(address, SharedRuntime::pin_object),
1470     r15_thread, c_rarg1);
1471 
1472   __ bind(is_null);
1473   __ block_comment(&quot;} gen_pin_object&quot;);
1474 }
1475 
1476 // Unpin object
1477 static void gen_unpin_object(MacroAssembler* masm,
1478                              VMRegPair reg) {
1479   __ block_comment(&quot;gen_unpin_object {&quot;);
1480   Label is_null;
1481 
1482   if (reg.first()-&gt;is_stack()) {
1483     __ movptr(c_rarg1, Address(rbp, reg2offset_in(reg.first())));
1484   } else if (reg.first()-&gt;as_Register() != c_rarg1) {
1485     __ movptr(c_rarg1, reg.first()-&gt;as_Register());
1486   }
1487 
1488   __ testptr(c_rarg1, c_rarg1);
1489   __ jccb(Assembler::equal, is_null);
1490 
1491   __ call_VM_leaf(
1492     CAST_FROM_FN_PTR(address, SharedRuntime::unpin_object),
1493     r15_thread, c_rarg1);
1494 
1495   __ bind(is_null);
1496   __ block_comment(&quot;} gen_unpin_object&quot;);
1497 }
1498 
1499 // Check GCLocker::needs_gc and enter the runtime if it&#39;s true.  This
1500 // keeps a new JNI critical region from starting until a GC has been
1501 // forced.  Save down any oops in registers and describe them in an
1502 // OopMap.
1503 static void check_needs_gc_for_critical_native(MacroAssembler* masm,
1504                                                int stack_slots,
1505                                                int total_c_args,
1506                                                int total_in_args,
1507                                                int arg_save_area,
1508                                                OopMapSet* oop_maps,
1509                                                VMRegPair* in_regs,
1510                                                BasicType* in_sig_bt) {
1511   __ block_comment(&quot;check GCLocker::needs_gc&quot;);
1512   Label cont;
1513   __ cmp8(ExternalAddress((address)GCLocker::needs_gc_address()), false);
1514   __ jcc(Assembler::equal, cont);
1515 
1516   // Save down any incoming oops and call into the runtime to halt for a GC
1517 
1518   OopMap* map = new OopMap(stack_slots * 2, 0 /* arg_slots*/);
1519   save_or_restore_arguments(masm, stack_slots, total_in_args,
1520                             arg_save_area, map, in_regs, in_sig_bt);
1521 
1522   address the_pc = __ pc();
1523   oop_maps-&gt;add_gc_map( __ offset(), map);
1524   __ set_last_Java_frame(rsp, noreg, the_pc);
1525 
1526   __ block_comment(&quot;block_for_jni_critical&quot;);
1527   __ movptr(c_rarg0, r15_thread);
1528   __ mov(r12, rsp); // remember sp
1529   __ subptr(rsp, frame::arg_reg_save_area_bytes); // windows
1530   __ andptr(rsp, -16); // align stack as required by ABI
1531   __ call(RuntimeAddress(CAST_FROM_FN_PTR(address, SharedRuntime::block_for_jni_critical)));
1532   __ mov(rsp, r12); // restore sp
1533   __ reinit_heapbase();
1534 
1535   __ reset_last_Java_frame(false);
1536 
1537   save_or_restore_arguments(masm, stack_slots, total_in_args,
1538                             arg_save_area, NULL, in_regs, in_sig_bt);
1539   __ bind(cont);
1540 #ifdef ASSERT
1541   if (StressCriticalJNINatives) {
1542     // Stress register saving
1543     OopMap* map = new OopMap(stack_slots * 2, 0 /* arg_slots*/);
1544     save_or_restore_arguments(masm, stack_slots, total_in_args,
1545                               arg_save_area, map, in_regs, in_sig_bt);
1546     // Destroy argument registers
1547     for (int i = 0; i &lt; total_in_args - 1; i++) {
1548       if (in_regs[i].first()-&gt;is_Register()) {
1549         const Register reg = in_regs[i].first()-&gt;as_Register();
1550         __ xorptr(reg, reg);
1551       } else if (in_regs[i].first()-&gt;is_XMMRegister()) {
1552         __ xorpd(in_regs[i].first()-&gt;as_XMMRegister(), in_regs[i].first()-&gt;as_XMMRegister());
1553       } else if (in_regs[i].first()-&gt;is_FloatRegister()) {
1554         ShouldNotReachHere();
1555       } else if (in_regs[i].first()-&gt;is_stack()) {
1556         // Nothing to do
1557       } else {
1558         ShouldNotReachHere();
1559       }
1560       if (in_sig_bt[i] == T_LONG || in_sig_bt[i] == T_DOUBLE) {
1561         i++;
1562       }
1563     }
1564 
1565     save_or_restore_arguments(masm, stack_slots, total_in_args,
1566                               arg_save_area, NULL, in_regs, in_sig_bt);
1567   }
1568 #endif
1569 }
1570 
1571 // Unpack an array argument into a pointer to the body and the length
1572 // if the array is non-null, otherwise pass 0 for both.
1573 static void unpack_array_argument(MacroAssembler* masm, VMRegPair reg, BasicType in_elem_type, VMRegPair body_arg, VMRegPair length_arg) {
1574   Register tmp_reg = rax;
1575   assert(!body_arg.first()-&gt;is_Register() || body_arg.first()-&gt;as_Register() != tmp_reg,
1576          &quot;possible collision&quot;);
1577   assert(!length_arg.first()-&gt;is_Register() || length_arg.first()-&gt;as_Register() != tmp_reg,
1578          &quot;possible collision&quot;);
1579 
1580   __ block_comment(&quot;unpack_array_argument {&quot;);
1581 
1582   // Pass the length, ptr pair
1583   Label is_null, done;
1584   VMRegPair tmp;
1585   tmp.set_ptr(tmp_reg-&gt;as_VMReg());
1586   if (reg.first()-&gt;is_stack()) {
1587     // Load the arg up from the stack
1588     move_ptr(masm, reg, tmp);
1589     reg = tmp;
1590   }
1591   __ testptr(reg.first()-&gt;as_Register(), reg.first()-&gt;as_Register());
1592   __ jccb(Assembler::equal, is_null);
1593   __ lea(tmp_reg, Address(reg.first()-&gt;as_Register(), arrayOopDesc::base_offset_in_bytes(in_elem_type)));
1594   move_ptr(masm, tmp, body_arg);
1595   // load the length relative to the body.
1596   __ movl(tmp_reg, Address(tmp_reg, arrayOopDesc::length_offset_in_bytes() -
1597                            arrayOopDesc::base_offset_in_bytes(in_elem_type)));
1598   move32_64(masm, tmp, length_arg);
1599   __ jmpb(done);
1600   __ bind(is_null);
1601   // Pass zeros
1602   __ xorptr(tmp_reg, tmp_reg);
1603   move_ptr(masm, tmp, body_arg);
1604   move32_64(masm, tmp, length_arg);
1605   __ bind(done);
1606 
1607   __ block_comment(&quot;} unpack_array_argument&quot;);
1608 }
1609 
1610 
1611 // Different signatures may require very different orders for the move
1612 // to avoid clobbering other arguments.  There&#39;s no simple way to
1613 // order them safely.  Compute a safe order for issuing stores and
1614 // break any cycles in those stores.  This code is fairly general but
1615 // it&#39;s not necessary on the other platforms so we keep it in the
1616 // platform dependent code instead of moving it into a shared file.
1617 // (See bugs 7013347 &amp; 7145024.)
1618 // Note that this code is specific to LP64.
1619 class ComputeMoveOrder: public StackObj {
1620   class MoveOperation: public ResourceObj {
1621     friend class ComputeMoveOrder;
1622    private:
1623     VMRegPair        _src;
1624     VMRegPair        _dst;
1625     int              _src_index;
1626     int              _dst_index;
1627     bool             _processed;
1628     MoveOperation*  _next;
1629     MoveOperation*  _prev;
1630 
1631     static int get_id(VMRegPair r) {
1632       return r.first()-&gt;value();
1633     }
1634 
1635    public:
1636     MoveOperation(int src_index, VMRegPair src, int dst_index, VMRegPair dst):
1637       _src(src)
1638     , _dst(dst)
1639     , _src_index(src_index)
1640     , _dst_index(dst_index)
1641     , _processed(false)
1642     , _next(NULL)
1643     , _prev(NULL) {
1644     }
1645 
1646     VMRegPair src() const              { return _src; }
1647     int src_id() const                 { return get_id(src()); }
1648     int src_index() const              { return _src_index; }
1649     VMRegPair dst() const              { return _dst; }
1650     void set_dst(int i, VMRegPair dst) { _dst_index = i, _dst = dst; }
1651     int dst_index() const              { return _dst_index; }
1652     int dst_id() const                 { return get_id(dst()); }
1653     MoveOperation* next() const       { return _next; }
1654     MoveOperation* prev() const       { return _prev; }
1655     void set_processed()               { _processed = true; }
1656     bool is_processed() const          { return _processed; }
1657 
1658     // insert
1659     void break_cycle(VMRegPair temp_register) {
1660       // create a new store following the last store
1661       // to move from the temp_register to the original
1662       MoveOperation* new_store = new MoveOperation(-1, temp_register, dst_index(), dst());
1663 
1664       // break the cycle of links and insert new_store at the end
1665       // break the reverse link.
1666       MoveOperation* p = prev();
1667       assert(p-&gt;next() == this, &quot;must be&quot;);
1668       _prev = NULL;
1669       p-&gt;_next = new_store;
1670       new_store-&gt;_prev = p;
1671 
1672       // change the original store to save it&#39;s value in the temp.
1673       set_dst(-1, temp_register);
1674     }
1675 
1676     void link(GrowableArray&lt;MoveOperation*&gt;&amp; killer) {
1677       // link this store in front the store that it depends on
1678       MoveOperation* n = killer.at_grow(src_id(), NULL);
1679       if (n != NULL) {
1680         assert(_next == NULL &amp;&amp; n-&gt;_prev == NULL, &quot;shouldn&#39;t have been set yet&quot;);
1681         _next = n;
1682         n-&gt;_prev = this;
1683       }
1684     }
1685   };
1686 
1687  private:
1688   GrowableArray&lt;MoveOperation*&gt; edges;
1689 
1690  public:
1691   ComputeMoveOrder(int total_in_args, VMRegPair* in_regs, int total_c_args, VMRegPair* out_regs,
1692                     BasicType* in_sig_bt, GrowableArray&lt;int&gt;&amp; arg_order, VMRegPair tmp_vmreg) {
1693     // Move operations where the dest is the stack can all be
1694     // scheduled first since they can&#39;t interfere with the other moves.
1695     for (int i = total_in_args - 1, c_arg = total_c_args - 1; i &gt;= 0; i--, c_arg--) {
1696       if (in_sig_bt[i] == T_ARRAY) {
1697         c_arg--;
1698         if (out_regs[c_arg].first()-&gt;is_stack() &amp;&amp;
1699             out_regs[c_arg + 1].first()-&gt;is_stack()) {
1700           arg_order.push(i);
1701           arg_order.push(c_arg);
1702         } else {
1703           if (out_regs[c_arg].first()-&gt;is_stack() ||
1704               in_regs[i].first() == out_regs[c_arg].first()) {
1705             add_edge(i, in_regs[i].first(), c_arg, out_regs[c_arg + 1]);
1706           } else {
1707             add_edge(i, in_regs[i].first(), c_arg, out_regs[c_arg]);
1708           }
1709         }
1710       } else if (in_sig_bt[i] == T_VOID) {
1711         arg_order.push(i);
1712         arg_order.push(c_arg);
1713       } else {
1714         if (out_regs[c_arg].first()-&gt;is_stack() ||
1715             in_regs[i].first() == out_regs[c_arg].first()) {
1716           arg_order.push(i);
1717           arg_order.push(c_arg);
1718         } else {
1719           add_edge(i, in_regs[i].first(), c_arg, out_regs[c_arg]);
1720         }
1721       }
1722     }
1723     // Break any cycles in the register moves and emit the in the
1724     // proper order.
1725     GrowableArray&lt;MoveOperation*&gt;* stores = get_store_order(tmp_vmreg);
1726     for (int i = 0; i &lt; stores-&gt;length(); i++) {
1727       arg_order.push(stores-&gt;at(i)-&gt;src_index());
1728       arg_order.push(stores-&gt;at(i)-&gt;dst_index());
1729     }
1730  }
1731 
1732   // Collected all the move operations
1733   void add_edge(int src_index, VMRegPair src, int dst_index, VMRegPair dst) {
1734     if (src.first() == dst.first()) return;
1735     edges.append(new MoveOperation(src_index, src, dst_index, dst));
1736   }
1737 
1738   // Walk the edges breaking cycles between moves.  The result list
1739   // can be walked in order to produce the proper set of loads
1740   GrowableArray&lt;MoveOperation*&gt;* get_store_order(VMRegPair temp_register) {
1741     // Record which moves kill which values
1742     GrowableArray&lt;MoveOperation*&gt; killer;
1743     for (int i = 0; i &lt; edges.length(); i++) {
1744       MoveOperation* s = edges.at(i);
1745       assert(killer.at_grow(s-&gt;dst_id(), NULL) == NULL, &quot;only one killer&quot;);
1746       killer.at_put_grow(s-&gt;dst_id(), s, NULL);
1747     }
1748     assert(killer.at_grow(MoveOperation::get_id(temp_register), NULL) == NULL,
1749            &quot;make sure temp isn&#39;t in the registers that are killed&quot;);
1750 
1751     // create links between loads and stores
1752     for (int i = 0; i &lt; edges.length(); i++) {
1753       edges.at(i)-&gt;link(killer);
1754     }
1755 
1756     // at this point, all the move operations are chained together
1757     // in a doubly linked list.  Processing it backwards finds
1758     // the beginning of the chain, forwards finds the end.  If there&#39;s
1759     // a cycle it can be broken at any point,  so pick an edge and walk
1760     // backward until the list ends or we end where we started.
1761     GrowableArray&lt;MoveOperation*&gt;* stores = new GrowableArray&lt;MoveOperation*&gt;();
1762     for (int e = 0; e &lt; edges.length(); e++) {
1763       MoveOperation* s = edges.at(e);
1764       if (!s-&gt;is_processed()) {
1765         MoveOperation* start = s;
1766         // search for the beginning of the chain or cycle
1767         while (start-&gt;prev() != NULL &amp;&amp; start-&gt;prev() != s) {
1768           start = start-&gt;prev();
1769         }
1770         if (start-&gt;prev() == s) {
1771           start-&gt;break_cycle(temp_register);
1772         }
1773         // walk the chain forward inserting to store list
1774         while (start != NULL) {
1775           stores-&gt;append(start);
1776           start-&gt;set_processed();
1777           start = start-&gt;next();
1778         }
1779       }
1780     }
1781     return stores;
1782   }
1783 };
1784 
1785 static void verify_oop_args(MacroAssembler* masm,
1786                             const methodHandle&amp; method,
1787                             const BasicType* sig_bt,
1788                             const VMRegPair* regs) {
1789   Register temp_reg = rbx;  // not part of any compiled calling seq
1790   if (VerifyOops) {
1791     for (int i = 0; i &lt; method-&gt;size_of_parameters(); i++) {
1792       if (sig_bt[i] == T_OBJECT ||
1793           sig_bt[i] == T_ARRAY) {
1794         VMReg r = regs[i].first();
1795         assert(r-&gt;is_valid(), &quot;bad oop arg&quot;);
1796         if (r-&gt;is_stack()) {
1797           __ movptr(temp_reg, Address(rsp, r-&gt;reg2stack() * VMRegImpl::stack_slot_size + wordSize));
1798           __ verify_oop(temp_reg);
1799         } else {
1800           __ verify_oop(r-&gt;as_Register());
1801         }
1802       }
1803     }
1804   }
1805 }
1806 
1807 static void gen_special_dispatch(MacroAssembler* masm,
1808                                  const methodHandle&amp; method,
1809                                  const BasicType* sig_bt,
1810                                  const VMRegPair* regs) {
1811   verify_oop_args(masm, method, sig_bt, regs);
1812   vmIntrinsics::ID iid = method-&gt;intrinsic_id();
1813 
1814   // Now write the args into the outgoing interpreter space
1815   bool     has_receiver   = false;
1816   Register receiver_reg   = noreg;
1817   int      member_arg_pos = -1;
1818   Register member_reg     = noreg;
1819   int      ref_kind       = MethodHandles::signature_polymorphic_intrinsic_ref_kind(iid);
1820   if (ref_kind != 0) {
1821     member_arg_pos = method-&gt;size_of_parameters() - 1;  // trailing MemberName argument
1822     member_reg = rbx;  // known to be free at this point
1823     has_receiver = MethodHandles::ref_kind_has_receiver(ref_kind);
1824   } else if (iid == vmIntrinsics::_invokeBasic) {
1825     has_receiver = true;
1826   } else {
1827     fatal(&quot;unexpected intrinsic id %d&quot;, iid);
1828   }
1829 
1830   if (member_reg != noreg) {
1831     // Load the member_arg into register, if necessary.
1832     SharedRuntime::check_member_name_argument_is_last_argument(method, sig_bt, regs);
1833     VMReg r = regs[member_arg_pos].first();
1834     if (r-&gt;is_stack()) {
1835       __ movptr(member_reg, Address(rsp, r-&gt;reg2stack() * VMRegImpl::stack_slot_size + wordSize));
1836     } else {
1837       // no data motion is needed
1838       member_reg = r-&gt;as_Register();
1839     }
1840   }
1841 
1842   if (has_receiver) {
1843     // Make sure the receiver is loaded into a register.
1844     assert(method-&gt;size_of_parameters() &gt; 0, &quot;oob&quot;);
1845     assert(sig_bt[0] == T_OBJECT, &quot;receiver argument must be an object&quot;);
1846     VMReg r = regs[0].first();
1847     assert(r-&gt;is_valid(), &quot;bad receiver arg&quot;);
1848     if (r-&gt;is_stack()) {
1849       // Porting note:  This assumes that compiled calling conventions always
1850       // pass the receiver oop in a register.  If this is not true on some
1851       // platform, pick a temp and load the receiver from stack.
1852       fatal(&quot;receiver always in a register&quot;);
1853       receiver_reg = j_rarg0;  // known to be free at this point
1854       __ movptr(receiver_reg, Address(rsp, r-&gt;reg2stack() * VMRegImpl::stack_slot_size + wordSize));
1855     } else {
1856       // no data motion is needed
1857       receiver_reg = r-&gt;as_Register();
1858     }
1859   }
1860 
1861   // Figure out which address we are really jumping to:
1862   MethodHandles::generate_method_handle_dispatch(masm, iid,
1863                                                  receiver_reg, member_reg, /*for_compiler_entry:*/ true);
1864 }
1865 
1866 // ---------------------------------------------------------------------------
1867 // Generate a native wrapper for a given method.  The method takes arguments
1868 // in the Java compiled code convention, marshals them to the native
1869 // convention (handlizes oops, etc), transitions to native, makes the call,
1870 // returns to java state (possibly blocking), unhandlizes any result and
1871 // returns.
1872 //
1873 // Critical native functions are a shorthand for the use of
1874 // GetPrimtiveArrayCritical and disallow the use of any other JNI
1875 // functions.  The wrapper is expected to unpack the arguments before
1876 // passing them to the callee and perform checks before and after the
1877 // native call to ensure that they GCLocker
1878 // lock_critical/unlock_critical semantics are followed.  Some other
1879 // parts of JNI setup are skipped like the tear down of the JNI handle
1880 // block and the check for pending exceptions it&#39;s impossible for them
1881 // to be thrown.
1882 //
1883 // They are roughly structured like this:
1884 //    if (GCLocker::needs_gc())
1885 //      SharedRuntime::block_for_jni_critical();
1886 //    tranistion to thread_in_native
1887 //    unpack arrray arguments and call native entry point
1888 //    check for safepoint in progress
1889 //    check if any thread suspend flags are set
1890 //      call into JVM and possible unlock the JNI critical
1891 //      if a GC was suppressed while in the critical native.
1892 //    transition back to thread_in_Java
1893 //    return to caller
1894 //
1895 nmethod* SharedRuntime::generate_native_wrapper(MacroAssembler* masm,
1896                                                 const methodHandle&amp; method,
1897                                                 int compile_id,
1898                                                 BasicType* in_sig_bt,
1899                                                 VMRegPair* in_regs,
1900                                                 BasicType ret_type) {
1901   if (method-&gt;is_method_handle_intrinsic()) {
1902     vmIntrinsics::ID iid = method-&gt;intrinsic_id();
1903     intptr_t start = (intptr_t)__ pc();
1904     int vep_offset = ((intptr_t)__ pc()) - start;
1905     gen_special_dispatch(masm,
1906                          method,
1907                          in_sig_bt,
1908                          in_regs);
1909     int frame_complete = ((intptr_t)__ pc()) - start;  // not complete, period
1910     __ flush();
1911     int stack_slots = SharedRuntime::out_preserve_stack_slots();  // no out slots at all, actually
1912     return nmethod::new_native_nmethod(method,
1913                                        compile_id,
1914                                        masm-&gt;code(),
1915                                        vep_offset,
1916                                        frame_complete,
1917                                        stack_slots / VMRegImpl::slots_per_word,
1918                                        in_ByteSize(-1),
1919                                        in_ByteSize(-1),
1920                                        (OopMapSet*)NULL);
1921   }
1922   bool is_critical_native = true;
1923   address native_func = method-&gt;critical_native_function();
1924   if (native_func == NULL) {
1925     native_func = method-&gt;native_function();
1926     is_critical_native = false;
1927   }
1928   assert(native_func != NULL, &quot;must have function&quot;);
1929 
1930   // An OopMap for lock (and class if static)
1931   OopMapSet *oop_maps = new OopMapSet();
1932   intptr_t start = (intptr_t)__ pc();
1933 
1934   // We have received a description of where all the java arg are located
1935   // on entry to the wrapper. We need to convert these args to where
1936   // the jni function will expect them. To figure out where they go
1937   // we convert the java signature to a C signature by inserting
1938   // the hidden arguments as arg[0] and possibly arg[1] (static method)
1939 
1940   const int total_in_args = method-&gt;size_of_parameters();
1941   int total_c_args = total_in_args;
1942   if (!is_critical_native) {
1943     total_c_args += 1;
1944     if (method-&gt;is_static()) {
1945       total_c_args++;
1946     }
1947   } else {
1948     for (int i = 0; i &lt; total_in_args; i++) {
1949       if (in_sig_bt[i] == T_ARRAY) {
1950         total_c_args++;
1951       }
1952     }
1953   }
1954 
1955   BasicType* out_sig_bt = NEW_RESOURCE_ARRAY(BasicType, total_c_args);
1956   VMRegPair* out_regs   = NEW_RESOURCE_ARRAY(VMRegPair, total_c_args);
1957   BasicType* in_elem_bt = NULL;
1958 
1959   int argc = 0;
1960   if (!is_critical_native) {
1961     out_sig_bt[argc++] = T_ADDRESS;
1962     if (method-&gt;is_static()) {
1963       out_sig_bt[argc++] = T_OBJECT;
1964     }
1965 
1966     for (int i = 0; i &lt; total_in_args ; i++ ) {
1967       out_sig_bt[argc++] = in_sig_bt[i];
1968     }
1969   } else {
1970     Thread* THREAD = Thread::current();
1971     in_elem_bt = NEW_RESOURCE_ARRAY(BasicType, total_in_args);
1972     SignatureStream ss(method-&gt;signature());
1973     for (int i = 0; i &lt; total_in_args ; i++ ) {
1974       if (in_sig_bt[i] == T_ARRAY) {
1975         // Arrays are passed as int, elem* pair
1976         out_sig_bt[argc++] = T_INT;
1977         out_sig_bt[argc++] = T_ADDRESS;
1978         Symbol* atype = ss.as_symbol(CHECK_NULL);
1979         const char* at = atype-&gt;as_C_string();
1980         if (strlen(at) == 2) {
1981           assert(at[0] == &#39;[&#39;, &quot;must be&quot;);
1982           switch (at[1]) {
1983             case &#39;B&#39;: in_elem_bt[i]  = T_BYTE; break;
1984             case &#39;C&#39;: in_elem_bt[i]  = T_CHAR; break;
1985             case &#39;D&#39;: in_elem_bt[i]  = T_DOUBLE; break;
1986             case &#39;F&#39;: in_elem_bt[i]  = T_FLOAT; break;
1987             case &#39;I&#39;: in_elem_bt[i]  = T_INT; break;
1988             case &#39;J&#39;: in_elem_bt[i]  = T_LONG; break;
1989             case &#39;S&#39;: in_elem_bt[i]  = T_SHORT; break;
1990             case &#39;Z&#39;: in_elem_bt[i]  = T_BOOLEAN; break;
1991             default: ShouldNotReachHere();
1992           }
1993         }
1994       } else {
1995         out_sig_bt[argc++] = in_sig_bt[i];
1996         in_elem_bt[i] = T_VOID;
1997       }
1998       if (in_sig_bt[i] != T_VOID) {
1999         assert(in_sig_bt[i] == ss.type(), &quot;must match&quot;);
2000         ss.next();
2001       }
2002     }
2003   }
2004 
2005   // Now figure out where the args must be stored and how much stack space
2006   // they require.
2007   int out_arg_slots;
2008   out_arg_slots = c_calling_convention(out_sig_bt, out_regs, NULL, total_c_args);
2009 
2010   // Compute framesize for the wrapper.  We need to handlize all oops in
2011   // incoming registers
2012 
2013   // Calculate the total number of stack slots we will need.
2014 
2015   // First count the abi requirement plus all of the outgoing args
2016   int stack_slots = SharedRuntime::out_preserve_stack_slots() + out_arg_slots;
2017 
2018   // Now the space for the inbound oop handle area
2019   int total_save_slots = 6 * VMRegImpl::slots_per_word;  // 6 arguments passed in registers
2020   if (is_critical_native) {
2021     // Critical natives may have to call out so they need a save area
2022     // for register arguments.
2023     int double_slots = 0;
2024     int single_slots = 0;
2025     for ( int i = 0; i &lt; total_in_args; i++) {
2026       if (in_regs[i].first()-&gt;is_Register()) {
2027         const Register reg = in_regs[i].first()-&gt;as_Register();
2028         switch (in_sig_bt[i]) {
2029           case T_BOOLEAN:
2030           case T_BYTE:
2031           case T_SHORT:
2032           case T_CHAR:
2033           case T_INT:  single_slots++; break;
2034           case T_ARRAY:  // specific to LP64 (7145024)
2035           case T_LONG: double_slots++; break;
2036           default:  ShouldNotReachHere();
2037         }
2038       } else if (in_regs[i].first()-&gt;is_XMMRegister()) {
2039         switch (in_sig_bt[i]) {
2040           case T_FLOAT:  single_slots++; break;
2041           case T_DOUBLE: double_slots++; break;
2042           default:  ShouldNotReachHere();
2043         }
2044       } else if (in_regs[i].first()-&gt;is_FloatRegister()) {
2045         ShouldNotReachHere();
2046       }
2047     }
2048     total_save_slots = double_slots * 2 + single_slots;
2049     // align the save area
2050     if (double_slots != 0) {
2051       stack_slots = align_up(stack_slots, 2);
2052     }
2053   }
2054 
2055   int oop_handle_offset = stack_slots;
2056   stack_slots += total_save_slots;
2057 
2058   // Now any space we need for handlizing a klass if static method
2059 
2060   int klass_slot_offset = 0;
2061   int klass_offset = -1;
2062   int lock_slot_offset = 0;
2063   bool is_static = false;
2064 
2065   if (method-&gt;is_static()) {
2066     klass_slot_offset = stack_slots;
2067     stack_slots += VMRegImpl::slots_per_word;
2068     klass_offset = klass_slot_offset * VMRegImpl::stack_slot_size;
2069     is_static = true;
2070   }
2071 
2072   // Plus a lock if needed
2073 
2074   if (method-&gt;is_synchronized()) {
2075     lock_slot_offset = stack_slots;
2076     stack_slots += VMRegImpl::slots_per_word;
2077   }
2078 
2079   // Now a place (+2) to save return values or temp during shuffling
2080   // + 4 for return address (which we own) and saved rbp
2081   stack_slots += 6;
2082 
2083   // Ok The space we have allocated will look like:
2084   //
2085   //
2086   // FP-&gt; |                     |
2087   //      |---------------------|
2088   //      | 2 slots for moves   |
2089   //      |---------------------|
2090   //      | lock box (if sync)  |
2091   //      |---------------------| &lt;- lock_slot_offset
2092   //      | klass (if static)   |
2093   //      |---------------------| &lt;- klass_slot_offset
2094   //      | oopHandle area      |
2095   //      |---------------------| &lt;- oop_handle_offset (6 java arg registers)
2096   //      | outbound memory     |
2097   //      | based arguments     |
2098   //      |                     |
2099   //      |---------------------|
2100   //      |                     |
2101   // SP-&gt; | out_preserved_slots |
2102   //
2103   //
2104 
2105 
2106   // Now compute actual number of stack words we need rounding to make
2107   // stack properly aligned.
2108   stack_slots = align_up(stack_slots, StackAlignmentInSlots);
2109 
2110   int stack_size = stack_slots * VMRegImpl::stack_slot_size;
2111 
2112   // First thing make an ic check to see if we should even be here
2113 
2114   // We are free to use all registers as temps without saving them and
2115   // restoring them except rbp. rbp is the only callee save register
2116   // as far as the interpreter and the compiler(s) are concerned.
2117 
2118 
2119   const Register ic_reg = rax;
2120   const Register receiver = j_rarg0;
2121 
2122   Label hit;
2123   Label exception_pending;
2124 
2125   assert_different_registers(ic_reg, receiver, rscratch1);
2126   __ verify_oop(receiver);
2127   __ load_klass(rscratch1, receiver);
2128   __ cmpq(ic_reg, rscratch1);
2129   __ jcc(Assembler::equal, hit);
2130 
2131   __ jump(RuntimeAddress(SharedRuntime::get_ic_miss_stub()));
2132 
2133   // Verified entry point must be aligned
2134   __ align(8);
2135 
2136   __ bind(hit);
2137 
2138   int vep_offset = ((intptr_t)__ pc()) - start;
2139 
2140 #ifdef COMPILER1
2141   // For Object.hashCode, System.identityHashCode try to pull hashCode from object header if available.
2142   if ((InlineObjectHash &amp;&amp; method-&gt;intrinsic_id() == vmIntrinsics::_hashCode) || (method-&gt;intrinsic_id() == vmIntrinsics::_identityHashCode)) {
2143     inline_check_hashcode_from_object_header(masm, method, j_rarg0 /*obj_reg*/, rax /*result*/);
2144   }
2145 #endif // COMPILER1
2146 
2147   // The instruction at the verified entry point must be 5 bytes or longer
2148   // because it can be patched on the fly by make_non_entrant. The stack bang
2149   // instruction fits that requirement.
2150 
2151   // Generate stack overflow check
2152 
2153   if (UseStackBanging) {
2154     __ bang_stack_with_offset((int)JavaThread::stack_shadow_zone_size());
2155   } else {
2156     // need a 5 byte instruction to allow MT safe patching to non-entrant
2157     __ fat_nop();
2158   }
2159 
2160   // Generate a new frame for the wrapper.
2161   __ enter();
2162   // -2 because return address is already present and so is saved rbp
2163   __ subptr(rsp, stack_size - 2*wordSize);
2164 
2165   BarrierSetAssembler* bs = BarrierSet::barrier_set()-&gt;barrier_set_assembler();
2166   bs-&gt;nmethod_entry_barrier(masm);
2167 
2168   // Frame is now completed as far as size and linkage.
2169   int frame_complete = ((intptr_t)__ pc()) - start;
2170 
2171     if (UseRTMLocking) {
2172       // Abort RTM transaction before calling JNI
2173       // because critical section will be large and will be
2174       // aborted anyway. Also nmethod could be deoptimized.
2175       __ xabort(0);
2176     }
2177 
2178 #ifdef ASSERT
2179     {
2180       Label L;
2181       __ mov(rax, rsp);
2182       __ andptr(rax, -16); // must be 16 byte boundary (see amd64 ABI)
2183       __ cmpptr(rax, rsp);
2184       __ jcc(Assembler::equal, L);
2185       __ stop(&quot;improperly aligned stack&quot;);
2186       __ bind(L);
2187     }
2188 #endif /* ASSERT */
2189 
2190 
2191   // We use r14 as the oop handle for the receiver/klass
2192   // It is callee save so it survives the call to native
2193 
2194   const Register oop_handle_reg = r14;
2195 
2196   if (is_critical_native &amp;&amp; !Universe::heap()-&gt;supports_object_pinning()) {
2197     check_needs_gc_for_critical_native(masm, stack_slots, total_c_args, total_in_args,
2198                                        oop_handle_offset, oop_maps, in_regs, in_sig_bt);
2199   }
2200 
2201   //
2202   // We immediately shuffle the arguments so that any vm call we have to
2203   // make from here on out (sync slow path, jvmti, etc.) we will have
2204   // captured the oops from our caller and have a valid oopMap for
2205   // them.
2206 
2207   // -----------------
2208   // The Grand Shuffle
2209 
2210   // The Java calling convention is either equal (linux) or denser (win64) than the
2211   // c calling convention. However the because of the jni_env argument the c calling
2212   // convention always has at least one more (and two for static) arguments than Java.
2213   // Therefore if we move the args from java -&gt; c backwards then we will never have
2214   // a register-&gt;register conflict and we don&#39;t have to build a dependency graph
2215   // and figure out how to break any cycles.
2216   //
2217 
2218   // Record esp-based slot for receiver on stack for non-static methods
2219   int receiver_offset = -1;
2220 
2221   // This is a trick. We double the stack slots so we can claim
2222   // the oops in the caller&#39;s frame. Since we are sure to have
2223   // more args than the caller doubling is enough to make
2224   // sure we can capture all the incoming oop args from the
2225   // caller.
2226   //
2227   OopMap* map = new OopMap(stack_slots * 2, 0 /* arg_slots*/);
2228 
2229   // Mark location of rbp (someday)
2230   // map-&gt;set_callee_saved(VMRegImpl::stack2reg( stack_slots - 2), stack_slots * 2, 0, vmreg(rbp));
2231 
2232   // Use eax, ebx as temporaries during any memory-memory moves we have to do
2233   // All inbound args are referenced based on rbp and all outbound args via rsp.
2234 
2235 
2236 #ifdef ASSERT
2237   bool reg_destroyed[RegisterImpl::number_of_registers];
2238   bool freg_destroyed[XMMRegisterImpl::number_of_registers];
2239   for ( int r = 0 ; r &lt; RegisterImpl::number_of_registers ; r++ ) {
2240     reg_destroyed[r] = false;
2241   }
2242   for ( int f = 0 ; f &lt; XMMRegisterImpl::number_of_registers ; f++ ) {
2243     freg_destroyed[f] = false;
2244   }
2245 
2246 #endif /* ASSERT */
2247 
2248   // This may iterate in two different directions depending on the
2249   // kind of native it is.  The reason is that for regular JNI natives
2250   // the incoming and outgoing registers are offset upwards and for
2251   // critical natives they are offset down.
2252   GrowableArray&lt;int&gt; arg_order(2 * total_in_args);
2253   // Inbound arguments that need to be pinned for critical natives
2254   GrowableArray&lt;int&gt; pinned_args(total_in_args);
2255   // Current stack slot for storing register based array argument
2256   int pinned_slot = oop_handle_offset;
2257 
2258   VMRegPair tmp_vmreg;
2259   tmp_vmreg.set2(rbx-&gt;as_VMReg());
2260 
2261   if (!is_critical_native) {
2262     for (int i = total_in_args - 1, c_arg = total_c_args - 1; i &gt;= 0; i--, c_arg--) {
2263       arg_order.push(i);
2264       arg_order.push(c_arg);
2265     }
2266   } else {
2267     // Compute a valid move order, using tmp_vmreg to break any cycles
2268     ComputeMoveOrder cmo(total_in_args, in_regs, total_c_args, out_regs, in_sig_bt, arg_order, tmp_vmreg);
2269   }
2270 
2271   int temploc = -1;
2272   for (int ai = 0; ai &lt; arg_order.length(); ai += 2) {
2273     int i = arg_order.at(ai);
2274     int c_arg = arg_order.at(ai + 1);
2275     __ block_comment(err_msg(&quot;move %d -&gt; %d&quot;, i, c_arg));
2276     if (c_arg == -1) {
2277       assert(is_critical_native, &quot;should only be required for critical natives&quot;);
2278       // This arg needs to be moved to a temporary
2279       __ mov(tmp_vmreg.first()-&gt;as_Register(), in_regs[i].first()-&gt;as_Register());
2280       in_regs[i] = tmp_vmreg;
2281       temploc = i;
2282       continue;
2283     } else if (i == -1) {
2284       assert(is_critical_native, &quot;should only be required for critical natives&quot;);
2285       // Read from the temporary location
2286       assert(temploc != -1, &quot;must be valid&quot;);
2287       i = temploc;
2288       temploc = -1;
2289     }
2290 #ifdef ASSERT
2291     if (in_regs[i].first()-&gt;is_Register()) {
2292       assert(!reg_destroyed[in_regs[i].first()-&gt;as_Register()-&gt;encoding()], &quot;destroyed reg!&quot;);
2293     } else if (in_regs[i].first()-&gt;is_XMMRegister()) {
2294       assert(!freg_destroyed[in_regs[i].first()-&gt;as_XMMRegister()-&gt;encoding()], &quot;destroyed reg!&quot;);
2295     }
2296     if (out_regs[c_arg].first()-&gt;is_Register()) {
2297       reg_destroyed[out_regs[c_arg].first()-&gt;as_Register()-&gt;encoding()] = true;
2298     } else if (out_regs[c_arg].first()-&gt;is_XMMRegister()) {
2299       freg_destroyed[out_regs[c_arg].first()-&gt;as_XMMRegister()-&gt;encoding()] = true;
2300     }
2301 #endif /* ASSERT */
2302     switch (in_sig_bt[i]) {
2303       case T_ARRAY:
2304         if (is_critical_native) {
2305           // pin before unpack
2306           if (Universe::heap()-&gt;supports_object_pinning()) {
2307             save_args(masm, total_c_args, 0, out_regs);
2308             gen_pin_object(masm, in_regs[i]);
2309             pinned_args.append(i);
2310             restore_args(masm, total_c_args, 0, out_regs);
2311 
2312             // rax has pinned array
2313             VMRegPair result_reg;
2314             result_reg.set_ptr(rax-&gt;as_VMReg());
2315             move_ptr(masm, result_reg, in_regs[i]);
2316             if (!in_regs[i].first()-&gt;is_stack()) {
2317               assert(pinned_slot &lt;= stack_slots, &quot;overflow&quot;);
2318               move_ptr(masm, result_reg, VMRegImpl::stack2reg(pinned_slot));
2319               pinned_slot += VMRegImpl::slots_per_word;
2320             }
2321           }
2322           unpack_array_argument(masm, in_regs[i], in_elem_bt[i], out_regs[c_arg + 1], out_regs[c_arg]);
2323           c_arg++;
2324 #ifdef ASSERT
2325           if (out_regs[c_arg].first()-&gt;is_Register()) {
2326             reg_destroyed[out_regs[c_arg].first()-&gt;as_Register()-&gt;encoding()] = true;
2327           } else if (out_regs[c_arg].first()-&gt;is_XMMRegister()) {
2328             freg_destroyed[out_regs[c_arg].first()-&gt;as_XMMRegister()-&gt;encoding()] = true;
2329           }
2330 #endif
2331           break;
2332         }
2333       case T_OBJECT:
2334         assert(!is_critical_native, &quot;no oop arguments&quot;);
2335         object_move(masm, map, oop_handle_offset, stack_slots, in_regs[i], out_regs[c_arg],
2336                     ((i == 0) &amp;&amp; (!is_static)),
2337                     &amp;receiver_offset);
2338         break;
2339       case T_VOID:
2340         break;
2341 
2342       case T_FLOAT:
2343         float_move(masm, in_regs[i], out_regs[c_arg]);
2344           break;
2345 
2346       case T_DOUBLE:
2347         assert( i + 1 &lt; total_in_args &amp;&amp;
2348                 in_sig_bt[i + 1] == T_VOID &amp;&amp;
2349                 out_sig_bt[c_arg+1] == T_VOID, &quot;bad arg list&quot;);
2350         double_move(masm, in_regs[i], out_regs[c_arg]);
2351         break;
2352 
2353       case T_LONG :
2354         long_move(masm, in_regs[i], out_regs[c_arg]);
2355         break;
2356 
2357       case T_ADDRESS: assert(false, &quot;found T_ADDRESS in java args&quot;);
2358 
2359       default:
2360         move32_64(masm, in_regs[i], out_regs[c_arg]);
2361     }
2362   }
2363 
2364   int c_arg;
2365 
2366   // Pre-load a static method&#39;s oop into r14.  Used both by locking code and
2367   // the normal JNI call code.
2368   if (!is_critical_native) {
2369     // point c_arg at the first arg that is already loaded in case we
2370     // need to spill before we call out
2371     c_arg = total_c_args - total_in_args;
2372 
2373     if (method-&gt;is_static()) {
2374 
2375       //  load oop into a register
2376       __ movoop(oop_handle_reg, JNIHandles::make_local(method-&gt;method_holder()-&gt;java_mirror()));
2377 
2378       // Now handlize the static class mirror it&#39;s known not-null.
2379       __ movptr(Address(rsp, klass_offset), oop_handle_reg);
2380       map-&gt;set_oop(VMRegImpl::stack2reg(klass_slot_offset));
2381 
2382       // Now get the handle
2383       __ lea(oop_handle_reg, Address(rsp, klass_offset));
2384       // store the klass handle as second argument
2385       __ movptr(c_rarg1, oop_handle_reg);
2386       // and protect the arg if we must spill
2387       c_arg--;
2388     }
2389   } else {
2390     // For JNI critical methods we need to save all registers in save_args.
2391     c_arg = 0;
2392   }
2393 
2394   // Change state to native (we save the return address in the thread, since it might not
2395   // be pushed on the stack when we do a a stack traversal). It is enough that the pc()
2396   // points into the right code segment. It does not have to be the correct return pc.
2397   // We use the same pc/oopMap repeatedly when we call out
2398 
2399   intptr_t the_pc = (intptr_t) __ pc();
2400   oop_maps-&gt;add_gc_map(the_pc - start, map);
2401 
2402   __ set_last_Java_frame(rsp, noreg, (address)the_pc);
2403 
2404 
2405   // We have all of the arguments setup at this point. We must not touch any register
2406   // argument registers at this point (what if we save/restore them there are no oop?
2407 
2408   {
2409     SkipIfEqual skip(masm, &amp;DTraceMethodProbes, false);
2410     // protect the args we&#39;ve loaded
2411     save_args(masm, total_c_args, c_arg, out_regs);
2412     __ mov_metadata(c_rarg1, method());
2413     __ call_VM_leaf(
2414       CAST_FROM_FN_PTR(address, SharedRuntime::dtrace_method_entry),
2415       r15_thread, c_rarg1);
2416     restore_args(masm, total_c_args, c_arg, out_regs);
2417   }
2418 
2419   TSAN_RUNTIME_ONLY(
2420     // protect the args we&#39;ve loaded
2421     save_args(masm, total_c_args, c_arg, out_regs);
2422     __ call_VM(noreg,
2423       CAST_FROM_FN_PTR(address, SharedRuntime::tsan_interp_method_entry),
2424       r15_thread);
2425     restore_args(masm, total_c_args, c_arg, out_regs);
2426   );
2427 
2428   // RedefineClasses() tracing support for obsolete method entry
2429   if (log_is_enabled(Trace, redefine, class, obsolete)) {
2430     // protect the args we&#39;ve loaded
2431     save_args(masm, total_c_args, c_arg, out_regs);
2432     __ mov_metadata(c_rarg1, method());
2433     __ call_VM_leaf(
2434       CAST_FROM_FN_PTR(address, SharedRuntime::rc_trace_method_entry),
2435       r15_thread, c_rarg1);
2436     restore_args(masm, total_c_args, c_arg, out_regs);
2437   }
2438 
2439   // Lock a synchronized method
2440 
2441   // Register definitions used by locking and unlocking
2442 
2443   const Register swap_reg = rax;  // Must use rax for cmpxchg instruction
2444   const Register obj_reg  = rbx;  // Will contain the oop
2445   const Register lock_reg = r13;  // Address of compiler lock object (BasicLock)
2446   const Register old_hdr  = r13;  // value of old header at unlock time
2447 
2448   Label slow_path_lock;
2449   Label lock_done;
2450 
2451   if (method-&gt;is_synchronized()) {
2452     assert(!is_critical_native, &quot;unhandled&quot;);
2453 
2454 
2455     const int mark_word_offset = BasicLock::displaced_header_offset_in_bytes();
2456 
2457     // Get the handle (the 2nd argument)
2458     __ mov(oop_handle_reg, c_rarg1);
2459 
2460     // Get address of the box
2461 
2462     __ lea(lock_reg, Address(rsp, lock_slot_offset * VMRegImpl::stack_slot_size));
2463 
2464     // Load the oop from the handle
2465     __ movptr(obj_reg, Address(oop_handle_reg, 0));
2466 
2467     __ resolve(IS_NOT_NULL, obj_reg);
2468     if (UseBiasedLocking) {
2469       __ biased_locking_enter(lock_reg, obj_reg, swap_reg, rscratch1, false, lock_done, &amp;slow_path_lock);
2470     }
2471 
2472     // Load immediate 1 into swap_reg %rax
2473     __ movl(swap_reg, 1);
2474 
2475     // Load (object-&gt;mark() | 1) into swap_reg %rax
2476     __ orptr(swap_reg, Address(obj_reg, oopDesc::mark_offset_in_bytes()));
2477 
2478     // Save (object-&gt;mark() | 1) into BasicLock&#39;s displaced header
2479     __ movptr(Address(lock_reg, mark_word_offset), swap_reg);
2480 
2481     // src -&gt; dest iff dest == rax else rax &lt;- dest
2482     __ lock();
2483     __ cmpxchgptr(lock_reg, Address(obj_reg, oopDesc::mark_offset_in_bytes()));
2484     __ jcc(Assembler::equal, lock_done);
2485 
2486     // Hmm should this move to the slow path code area???
2487 
2488     // Test if the oopMark is an obvious stack pointer, i.e.,
2489     //  1) (mark &amp; 3) == 0, and
2490     //  2) rsp &lt;= mark &lt; mark + os::pagesize()
2491     // These 3 tests can be done by evaluating the following
2492     // expression: ((mark - rsp) &amp; (3 - os::vm_page_size())),
2493     // assuming both stack pointer and pagesize have their
2494     // least significant 2 bits clear.
2495     // NOTE: the oopMark is in swap_reg %rax as the result of cmpxchg
2496 
2497     __ subptr(swap_reg, rsp);
2498     __ andptr(swap_reg, 3 - os::vm_page_size());
2499 
2500     // Save the test result, for recursive case, the result is zero
2501     __ movptr(Address(lock_reg, mark_word_offset), swap_reg);
2502     __ jcc(Assembler::notEqual, slow_path_lock);
2503 
2504     // Slow path will re-enter here
2505 
2506     __ bind(lock_done);
2507 
2508     TSAN_RUNTIME_ONLY(
2509       __ pusha();
2510       __ call_VM(noreg,
2511                  CAST_FROM_FN_PTR(address, SharedRuntime::tsan_oop_lock),
2512                  obj_reg);
2513       __ popa();
2514     );
2515   }
2516 
2517 
2518   // Finally just about ready to make the JNI call
2519 
2520 
2521   // get JNIEnv* which is first argument to native
2522   if (!is_critical_native) {
2523     __ lea(c_rarg0, Address(r15_thread, in_bytes(JavaThread::jni_environment_offset())));
2524   }
2525 
2526   // Now set thread in native
2527   __ movl(Address(r15_thread, JavaThread::thread_state_offset()), _thread_in_native);
2528 
2529   __ call(RuntimeAddress(native_func));
2530 
2531   // Verify or restore cpu control state after JNI call
2532   __ restore_cpu_control_state_after_jni();
2533 
2534   // Unpack native results.
2535   switch (ret_type) {
2536   case T_BOOLEAN: __ c2bool(rax);            break;
2537   case T_CHAR   : __ movzwl(rax, rax);      break;
2538   case T_BYTE   : __ sign_extend_byte (rax); break;
2539   case T_SHORT  : __ sign_extend_short(rax); break;
2540   case T_INT    : /* nothing to do */        break;
2541   case T_DOUBLE :
2542   case T_FLOAT  :
2543     // Result is in xmm0 we&#39;ll save as needed
2544     break;
2545   case T_ARRAY:                 // Really a handle
2546   case T_OBJECT:                // Really a handle
2547       break; // can&#39;t de-handlize until after safepoint check
2548   case T_VOID: break;
2549   case T_LONG: break;
2550   default       : ShouldNotReachHere();
2551   }
2552 
2553   // unpin pinned arguments
2554   pinned_slot = oop_handle_offset;
2555   if (pinned_args.length() &gt; 0) {
2556     // save return value that may be overwritten otherwise.
2557     save_native_result(masm, ret_type, stack_slots);
2558     for (int index = 0; index &lt; pinned_args.length(); index ++) {
2559       int i = pinned_args.at(index);
2560       assert(pinned_slot &lt;= stack_slots, &quot;overflow&quot;);
2561       if (!in_regs[i].first()-&gt;is_stack()) {
2562         int offset = pinned_slot * VMRegImpl::stack_slot_size;
2563         __ movq(in_regs[i].first()-&gt;as_Register(), Address(rsp, offset));
2564         pinned_slot += VMRegImpl::slots_per_word;
2565       }
2566       gen_unpin_object(masm, in_regs[i]);
2567     }
2568     restore_native_result(masm, ret_type, stack_slots);
2569   }
2570 
2571   // Switch thread to &quot;native transition&quot; state before reading the synchronization state.
2572   // This additional state is necessary because reading and testing the synchronization
2573   // state is not atomic w.r.t. GC, as this scenario demonstrates:
2574   //     Java thread A, in _thread_in_native state, loads _not_synchronized and is preempted.
2575   //     VM thread changes sync state to synchronizing and suspends threads for GC.
2576   //     Thread A is resumed to finish this native method, but doesn&#39;t block here since it
2577   //     didn&#39;t see any synchronization is progress, and escapes.
2578   __ movl(Address(r15_thread, JavaThread::thread_state_offset()), _thread_in_native_trans);
2579 
2580   // Force this write out before the read below
2581   __ membar(Assembler::Membar_mask_bits(
2582               Assembler::LoadLoad | Assembler::LoadStore |
2583               Assembler::StoreLoad | Assembler::StoreStore));
2584 
2585   Label after_transition;
2586 
2587   // check for safepoint operation in progress and/or pending suspend requests
2588   {
2589     Label Continue;
2590     Label slow_path;
2591 
2592     __ safepoint_poll(slow_path, r15_thread, rscratch1);
2593 
2594     __ cmpl(Address(r15_thread, JavaThread::suspend_flags_offset()), 0);
2595     __ jcc(Assembler::equal, Continue);
2596     __ bind(slow_path);
2597 
2598     // Don&#39;t use call_VM as it will see a possible pending exception and forward it
2599     // and never return here preventing us from clearing _last_native_pc down below.
2600     // Also can&#39;t use call_VM_leaf either as it will check to see if rsi &amp; rdi are
2601     // preserved and correspond to the bcp/locals pointers. So we do a runtime call
2602     // by hand.
2603     //
2604     __ vzeroupper();
2605     save_native_result(masm, ret_type, stack_slots);
2606     __ mov(c_rarg0, r15_thread);
2607     __ mov(r12, rsp); // remember sp
2608     __ subptr(rsp, frame::arg_reg_save_area_bytes); // windows
2609     __ andptr(rsp, -16); // align stack as required by ABI
2610     if (!is_critical_native) {
2611       __ call(RuntimeAddress(CAST_FROM_FN_PTR(address, JavaThread::check_special_condition_for_native_trans)));
2612     } else {
2613       __ call(RuntimeAddress(CAST_FROM_FN_PTR(address, JavaThread::check_special_condition_for_native_trans_and_transition)));
2614     }
2615     __ mov(rsp, r12); // restore sp
2616     __ reinit_heapbase();
2617     // Restore any method result value
2618     restore_native_result(masm, ret_type, stack_slots);
2619 
2620     if (is_critical_native) {
2621       // The call above performed the transition to thread_in_Java so
2622       // skip the transition logic below.
2623       __ jmpb(after_transition);
2624     }
2625 
2626     __ bind(Continue);
2627   }
2628 
2629   // change thread state
2630   __ movl(Address(r15_thread, JavaThread::thread_state_offset()), _thread_in_Java);
2631   __ bind(after_transition);
2632 
2633   Label reguard;
2634   Label reguard_done;
2635   __ cmpl(Address(r15_thread, JavaThread::stack_guard_state_offset()), JavaThread::stack_guard_yellow_reserved_disabled);
2636   __ jcc(Assembler::equal, reguard);
2637   __ bind(reguard_done);
2638 
2639   // native result if any is live
2640 
2641   // Unlock
2642   Label unlock_done;
2643   Label slow_path_unlock;
2644   if (method-&gt;is_synchronized()) {
2645 
2646     // Get locked oop from the handle we passed to jni
2647     __ movptr(obj_reg, Address(oop_handle_reg, 0));
2648     __ resolve(IS_NOT_NULL, obj_reg);
2649 
2650     TSAN_RUNTIME_ONLY(
2651       __ pusha();
2652       __ call_VM(noreg, CAST_FROM_FN_PTR(address,
2653                                          SharedRuntime::tsan_oop_unlock),
2654                  obj_reg);
2655       __ popa();
2656     );
2657 
2658     Label done;
2659 
2660     if (UseBiasedLocking) {
2661       __ biased_locking_exit(obj_reg, old_hdr, done);
2662     }
2663 
2664     // Simple recursive lock?
2665 
2666     __ cmpptr(Address(rsp, lock_slot_offset * VMRegImpl::stack_slot_size), (int32_t)NULL_WORD);
2667     __ jcc(Assembler::equal, done);
2668 
2669     // Must save rax if if it is live now because cmpxchg must use it
2670     if (ret_type != T_FLOAT &amp;&amp; ret_type != T_DOUBLE &amp;&amp; ret_type != T_VOID) {
2671       save_native_result(masm, ret_type, stack_slots);
2672     }
2673 
2674 
2675     // get address of the stack lock
2676     __ lea(rax, Address(rsp, lock_slot_offset * VMRegImpl::stack_slot_size));
2677     //  get old displaced header
2678     __ movptr(old_hdr, Address(rax, 0));
2679 
2680     // Atomic swap old header if oop still contains the stack lock
2681     __ lock();
2682     __ cmpxchgptr(old_hdr, Address(obj_reg, oopDesc::mark_offset_in_bytes()));
2683     __ jcc(Assembler::notEqual, slow_path_unlock);
2684 
2685     // slow path re-enters here
2686     __ bind(unlock_done);
2687     if (ret_type != T_FLOAT &amp;&amp; ret_type != T_DOUBLE &amp;&amp; ret_type != T_VOID) {
2688       restore_native_result(masm, ret_type, stack_slots);
2689     }
2690 
2691     __ bind(done);
2692 
2693   }
2694 
2695   TSAN_RUNTIME_ONLY(
2696     save_native_result(masm, ret_type, stack_slots);
2697     __ call_VM_leaf(
2698          CAST_FROM_FN_PTR(address, SharedRuntime::tsan_interp_method_exit));
2699     restore_native_result(masm, ret_type, stack_slots);
2700   );
2701 
2702   {
2703     SkipIfEqual skip(masm, &amp;DTraceMethodProbes, false);
2704     save_native_result(masm, ret_type, stack_slots);
2705     __ mov_metadata(c_rarg1, method());
2706     __ call_VM_leaf(
2707          CAST_FROM_FN_PTR(address, SharedRuntime::dtrace_method_exit),
2708          r15_thread, c_rarg1);
2709     restore_native_result(masm, ret_type, stack_slots);
2710   }
2711 
2712   __ reset_last_Java_frame(false);
2713 
2714   // Unbox oop result, e.g. JNIHandles::resolve value.
2715   if (ret_type == T_OBJECT || ret_type == T_ARRAY) {
2716     __ resolve_jobject(rax /* value */,
2717                        r15_thread /* thread */,
2718                        rcx /* tmp */);
2719   }
2720 
2721   if (CheckJNICalls) {
2722     // clear_pending_jni_exception_check
2723     __ movptr(Address(r15_thread, JavaThread::pending_jni_exception_check_fn_offset()), NULL_WORD);
2724   }
2725 
2726   if (!is_critical_native) {
2727     // reset handle block
2728     __ movptr(rcx, Address(r15_thread, JavaThread::active_handles_offset()));
2729     __ movl(Address(rcx, JNIHandleBlock::top_offset_in_bytes()), (int32_t)NULL_WORD);
2730   }
2731 
2732   // pop our frame
2733 
2734   __ leave();
2735 
2736   if (!is_critical_native) {
2737     // Any exception pending?
2738     __ cmpptr(Address(r15_thread, in_bytes(Thread::pending_exception_offset())), (int32_t)NULL_WORD);
2739     __ jcc(Assembler::notEqual, exception_pending);
2740   }
2741 
2742   // Return
2743 
2744   __ ret(0);
2745 
2746   // Unexpected paths are out of line and go here
2747 
2748   if (!is_critical_native) {
2749     // forward the exception
2750     __ bind(exception_pending);
2751 
2752     // and forward the exception
2753     __ jump(RuntimeAddress(StubRoutines::forward_exception_entry()));
2754   }
2755 
2756   // Slow path locking &amp; unlocking
2757   if (method-&gt;is_synchronized()) {
2758 
2759     // BEGIN Slow path lock
2760     __ bind(slow_path_lock);
2761 
2762     // has last_Java_frame setup. No exceptions so do vanilla call not call_VM
2763     // args are (oop obj, BasicLock* lock, JavaThread* thread)
2764 
2765     // protect the args we&#39;ve loaded
2766     save_args(masm, total_c_args, c_arg, out_regs);
2767 
2768     __ mov(c_rarg0, obj_reg);
2769     __ mov(c_rarg1, lock_reg);
2770     __ mov(c_rarg2, r15_thread);
2771 
2772     // Not a leaf but we have last_Java_frame setup as we want
2773     __ call_VM_leaf(CAST_FROM_FN_PTR(address, SharedRuntime::complete_monitor_locking_C), 3);
2774     restore_args(masm, total_c_args, c_arg, out_regs);
2775 
2776 #ifdef ASSERT
2777     { Label L;
2778     __ cmpptr(Address(r15_thread, in_bytes(Thread::pending_exception_offset())), (int32_t)NULL_WORD);
2779     __ jcc(Assembler::equal, L);
2780     __ stop(&quot;no pending exception allowed on exit from monitorenter&quot;);
2781     __ bind(L);
2782     }
2783 #endif
2784     __ jmp(lock_done);
2785 
2786     // END Slow path lock
2787 
2788     // BEGIN Slow path unlock
2789     __ bind(slow_path_unlock);
2790 
2791     // If we haven&#39;t already saved the native result we must save it now as xmm registers
2792     // are still exposed.
2793     __ vzeroupper();
2794     if (ret_type == T_FLOAT || ret_type == T_DOUBLE ) {
2795       save_native_result(masm, ret_type, stack_slots);
2796     }
2797 
2798     __ lea(c_rarg1, Address(rsp, lock_slot_offset * VMRegImpl::stack_slot_size));
2799 
2800     __ mov(c_rarg0, obj_reg);
2801     __ mov(c_rarg2, r15_thread);
2802     __ mov(r12, rsp); // remember sp
2803     __ subptr(rsp, frame::arg_reg_save_area_bytes); // windows
2804     __ andptr(rsp, -16); // align stack as required by ABI
2805 
2806     // Save pending exception around call to VM (which contains an EXCEPTION_MARK)
2807     // NOTE that obj_reg == rbx currently
2808     __ movptr(rbx, Address(r15_thread, in_bytes(Thread::pending_exception_offset())));
2809     __ movptr(Address(r15_thread, in_bytes(Thread::pending_exception_offset())), (int32_t)NULL_WORD);
2810 
2811     // args are (oop obj, BasicLock* lock, JavaThread* thread)
2812     __ call(RuntimeAddress(CAST_FROM_FN_PTR(address, SharedRuntime::complete_monitor_unlocking_C)));
2813     __ mov(rsp, r12); // restore sp
2814     __ reinit_heapbase();
2815 #ifdef ASSERT
2816     {
2817       Label L;
2818       __ cmpptr(Address(r15_thread, in_bytes(Thread::pending_exception_offset())), (int)NULL_WORD);
2819       __ jcc(Assembler::equal, L);
2820       __ stop(&quot;no pending exception allowed on exit complete_monitor_unlocking_C&quot;);
2821       __ bind(L);
2822     }
2823 #endif /* ASSERT */
2824 
2825     __ movptr(Address(r15_thread, in_bytes(Thread::pending_exception_offset())), rbx);
2826 
2827     if (ret_type == T_FLOAT || ret_type == T_DOUBLE ) {
2828       restore_native_result(masm, ret_type, stack_slots);
2829     }
2830     __ jmp(unlock_done);
2831 
2832     // END Slow path unlock
2833 
2834   } // synchronized
2835 
2836   // SLOW PATH Reguard the stack if needed
2837 
2838   __ bind(reguard);
2839   __ vzeroupper();
2840   save_native_result(masm, ret_type, stack_slots);
2841   __ mov(r12, rsp); // remember sp
2842   __ subptr(rsp, frame::arg_reg_save_area_bytes); // windows
2843   __ andptr(rsp, -16); // align stack as required by ABI
2844   __ call(RuntimeAddress(CAST_FROM_FN_PTR(address, SharedRuntime::reguard_yellow_pages)));
2845   __ mov(rsp, r12); // restore sp
2846   __ reinit_heapbase();
2847   restore_native_result(masm, ret_type, stack_slots);
2848   // and continue
2849   __ jmp(reguard_done);
2850 
2851 
2852 
2853   __ flush();
2854 
2855   nmethod *nm = nmethod::new_native_nmethod(method,
2856                                             compile_id,
2857                                             masm-&gt;code(),
2858                                             vep_offset,
2859                                             frame_complete,
2860                                             stack_slots / VMRegImpl::slots_per_word,
2861                                             (is_static ? in_ByteSize(klass_offset) : in_ByteSize(receiver_offset)),
2862                                             in_ByteSize(lock_slot_offset*VMRegImpl::stack_slot_size),
2863                                             oop_maps);
2864 
2865   if (is_critical_native) {
2866     nm-&gt;set_lazy_critical_native(true);
2867   }
2868 
2869   return nm;
2870 
2871 }
2872 
2873 // this function returns the adjust size (in number of words) to a c2i adapter
2874 // activation for use during deoptimization
2875 int Deoptimization::last_frame_adjust(int callee_parameters, int callee_locals ) {
2876   return (callee_locals - callee_parameters) * Interpreter::stackElementWords;
2877 }
2878 
2879 
2880 uint SharedRuntime::out_preserve_stack_slots() {
2881   return 0;
2882 }
2883 
2884 //------------------------------generate_deopt_blob----------------------------
2885 void SharedRuntime::generate_deopt_blob() {
2886   // Allocate space for the code
2887   ResourceMark rm;
2888   // Setup code generation tools
2889   int pad = 0;
2890 #if INCLUDE_JVMCI
2891   if (EnableJVMCI || UseAOT) {
2892     pad += 512; // Increase the buffer size when compiling for JVMCI
2893   }
2894 #endif
2895   CodeBuffer buffer(&quot;deopt_blob&quot;, 2048+pad, 1024);
2896   MacroAssembler* masm = new MacroAssembler(&amp;buffer);
2897   int frame_size_in_words;
2898   OopMap* map = NULL;
2899   OopMapSet *oop_maps = new OopMapSet();
2900 
2901   // -------------
2902   // This code enters when returning to a de-optimized nmethod.  A return
2903   // address has been pushed on the the stack, and return values are in
2904   // registers.
2905   // If we are doing a normal deopt then we were called from the patched
2906   // nmethod from the point we returned to the nmethod. So the return
2907   // address on the stack is wrong by NativeCall::instruction_size
2908   // We will adjust the value so it looks like we have the original return
2909   // address on the stack (like when we eagerly deoptimized).
2910   // In the case of an exception pending when deoptimizing, we enter
2911   // with a return address on the stack that points after the call we patched
2912   // into the exception handler. We have the following register state from,
2913   // e.g., the forward exception stub (see stubGenerator_x86_64.cpp).
2914   //    rax: exception oop
2915   //    rbx: exception handler
2916   //    rdx: throwing pc
2917   // So in this case we simply jam rdx into the useless return address and
2918   // the stack looks just like we want.
2919   //
2920   // At this point we need to de-opt.  We save the argument return
2921   // registers.  We call the first C routine, fetch_unroll_info().  This
2922   // routine captures the return values and returns a structure which
2923   // describes the current frame size and the sizes of all replacement frames.
2924   // The current frame is compiled code and may contain many inlined
2925   // functions, each with their own JVM state.  We pop the current frame, then
2926   // push all the new frames.  Then we call the C routine unpack_frames() to
2927   // populate these frames.  Finally unpack_frames() returns us the new target
2928   // address.  Notice that callee-save registers are BLOWN here; they have
2929   // already been captured in the vframeArray at the time the return PC was
2930   // patched.
2931   address start = __ pc();
2932   Label cont;
2933 
2934   // Prolog for non exception case!
2935 
2936   // Save everything in sight.
2937   map = RegisterSaver::save_live_registers(masm, 0, &amp;frame_size_in_words);
2938 
2939   // Normal deoptimization.  Save exec mode for unpack_frames.
2940   __ movl(r14, Deoptimization::Unpack_deopt); // callee-saved
2941   __ jmp(cont);
2942 
2943   int reexecute_offset = __ pc() - start;
2944 #if INCLUDE_JVMCI &amp;&amp; !defined(COMPILER1)
2945   if (EnableJVMCI &amp;&amp; UseJVMCICompiler) {
2946     // JVMCI does not use this kind of deoptimization
2947     __ should_not_reach_here();
2948   }
2949 #endif
2950 
2951   // Reexecute case
2952   // return address is the pc describes what bci to do re-execute at
2953 
2954   // No need to update map as each call to save_live_registers will produce identical oopmap
2955   (void) RegisterSaver::save_live_registers(masm, 0, &amp;frame_size_in_words);
2956 
2957   __ movl(r14, Deoptimization::Unpack_reexecute); // callee-saved
2958   __ jmp(cont);
2959 
2960 #if INCLUDE_JVMCI
2961   Label after_fetch_unroll_info_call;
2962   int implicit_exception_uncommon_trap_offset = 0;
2963   int uncommon_trap_offset = 0;
2964 
2965   if (EnableJVMCI || UseAOT) {
2966     implicit_exception_uncommon_trap_offset = __ pc() - start;
2967 
2968     __ pushptr(Address(r15_thread, in_bytes(JavaThread::jvmci_implicit_exception_pc_offset())));
2969     __ movptr(Address(r15_thread, in_bytes(JavaThread::jvmci_implicit_exception_pc_offset())), (int32_t)NULL_WORD);
2970 
2971     uncommon_trap_offset = __ pc() - start;
2972 
2973     // Save everything in sight.
2974     RegisterSaver::save_live_registers(masm, 0, &amp;frame_size_in_words);
2975     // fetch_unroll_info needs to call last_java_frame()
2976     __ set_last_Java_frame(noreg, noreg, NULL);
2977 
2978     __ movl(c_rarg1, Address(r15_thread, in_bytes(JavaThread::pending_deoptimization_offset())));
2979     __ movl(Address(r15_thread, in_bytes(JavaThread::pending_deoptimization_offset())), -1);
2980 
2981     __ movl(r14, (int32_t)Deoptimization::Unpack_reexecute);
2982     __ mov(c_rarg0, r15_thread);
2983     __ movl(c_rarg2, r14); // exec mode
2984     __ call(RuntimeAddress(CAST_FROM_FN_PTR(address, Deoptimization::uncommon_trap)));
2985     oop_maps-&gt;add_gc_map( __ pc()-start, map-&gt;deep_copy());
2986 
2987     __ reset_last_Java_frame(false);
2988 
2989     __ jmp(after_fetch_unroll_info_call);
2990   } // EnableJVMCI
2991 #endif // INCLUDE_JVMCI
2992 
2993   int exception_offset = __ pc() - start;
2994 
2995   // Prolog for exception case
2996 
2997   // all registers are dead at this entry point, except for rax, and
2998   // rdx which contain the exception oop and exception pc
2999   // respectively.  Set them in TLS and fall thru to the
3000   // unpack_with_exception_in_tls entry point.
3001 
3002   __ movptr(Address(r15_thread, JavaThread::exception_pc_offset()), rdx);
3003   __ movptr(Address(r15_thread, JavaThread::exception_oop_offset()), rax);
3004 
3005   int exception_in_tls_offset = __ pc() - start;
3006 
3007   // new implementation because exception oop is now passed in JavaThread
3008 
3009   // Prolog for exception case
3010   // All registers must be preserved because they might be used by LinearScan
3011   // Exceptiop oop and throwing PC are passed in JavaThread
3012   // tos: stack at point of call to method that threw the exception (i.e. only
3013   // args are on the stack, no return address)
3014 
3015   // make room on stack for the return address
3016   // It will be patched later with the throwing pc. The correct value is not
3017   // available now because loading it from memory would destroy registers.
3018   __ push(0);
3019 
3020   // Save everything in sight.
3021   map = RegisterSaver::save_live_registers(masm, 0, &amp;frame_size_in_words);
3022 
3023   // Now it is safe to overwrite any register
3024 
3025   // Deopt during an exception.  Save exec mode for unpack_frames.
3026   __ movl(r14, Deoptimization::Unpack_exception); // callee-saved
3027 
3028   // load throwing pc from JavaThread and patch it as the return address
3029   // of the current frame. Then clear the field in JavaThread
3030 
3031   __ movptr(rdx, Address(r15_thread, JavaThread::exception_pc_offset()));
3032   __ movptr(Address(rbp, wordSize), rdx);
3033   __ movptr(Address(r15_thread, JavaThread::exception_pc_offset()), (int32_t)NULL_WORD);
3034 
3035 #ifdef ASSERT
3036   // verify that there is really an exception oop in JavaThread
3037   __ movptr(rax, Address(r15_thread, JavaThread::exception_oop_offset()));
3038   __ verify_oop(rax);
3039 
3040   // verify that there is no pending exception
3041   Label no_pending_exception;
3042   __ movptr(rax, Address(r15_thread, Thread::pending_exception_offset()));
3043   __ testptr(rax, rax);
3044   __ jcc(Assembler::zero, no_pending_exception);
3045   __ stop(&quot;must not have pending exception here&quot;);
3046   __ bind(no_pending_exception);
3047 #endif
3048 
3049   __ bind(cont);
3050 
3051   // Call C code.  Need thread and this frame, but NOT official VM entry
3052   // crud.  We cannot block on this call, no GC can happen.
3053   //
3054   // UnrollBlock* fetch_unroll_info(JavaThread* thread)
3055 
3056   // fetch_unroll_info needs to call last_java_frame().
3057 
3058   __ set_last_Java_frame(noreg, noreg, NULL);
3059 #ifdef ASSERT
3060   { Label L;
3061     __ cmpptr(Address(r15_thread,
3062                     JavaThread::last_Java_fp_offset()),
3063             (int32_t)0);
3064     __ jcc(Assembler::equal, L);
3065     __ stop(&quot;SharedRuntime::generate_deopt_blob: last_Java_fp not cleared&quot;);
3066     __ bind(L);
3067   }
3068 #endif // ASSERT
3069   __ mov(c_rarg0, r15_thread);
3070   __ movl(c_rarg1, r14); // exec_mode
3071   __ call(RuntimeAddress(CAST_FROM_FN_PTR(address, Deoptimization::fetch_unroll_info)));
3072 
3073   // Need to have an oopmap that tells fetch_unroll_info where to
3074   // find any register it might need.
3075   oop_maps-&gt;add_gc_map(__ pc() - start, map);
3076 
3077   __ reset_last_Java_frame(false);
3078 
3079 #if INCLUDE_JVMCI
3080   if (EnableJVMCI || UseAOT) {
3081     __ bind(after_fetch_unroll_info_call);
3082   }
3083 #endif
3084 
3085   // Load UnrollBlock* into rdi
3086   __ mov(rdi, rax);
3087 
3088   __ movl(r14, Address(rdi, Deoptimization::UnrollBlock::unpack_kind_offset_in_bytes()));
3089    Label noException;
3090   __ cmpl(r14, Deoptimization::Unpack_exception);   // Was exception pending?
3091   __ jcc(Assembler::notEqual, noException);
3092   __ movptr(rax, Address(r15_thread, JavaThread::exception_oop_offset()));
3093   // QQQ this is useless it was NULL above
3094   __ movptr(rdx, Address(r15_thread, JavaThread::exception_pc_offset()));
3095   __ movptr(Address(r15_thread, JavaThread::exception_oop_offset()), (int32_t)NULL_WORD);
3096   __ movptr(Address(r15_thread, JavaThread::exception_pc_offset()), (int32_t)NULL_WORD);
3097 
3098   __ verify_oop(rax);
3099 
3100   // Overwrite the result registers with the exception results.
3101   __ movptr(Address(rsp, RegisterSaver::rax_offset_in_bytes()), rax);
3102   // I think this is useless
3103   __ movptr(Address(rsp, RegisterSaver::rdx_offset_in_bytes()), rdx);
3104 
3105   __ bind(noException);
3106 
3107   // Only register save data is on the stack.
3108   // Now restore the result registers.  Everything else is either dead
3109   // or captured in the vframeArray.
3110   RegisterSaver::restore_result_registers(masm);
3111 
3112   // All of the register save area has been popped of the stack. Only the
3113   // return address remains.
3114 
3115   // Pop all the frames we must move/replace.
3116   //
3117   // Frame picture (youngest to oldest)
3118   // 1: self-frame (no frame link)
3119   // 2: deopting frame  (no frame link)
3120   // 3: caller of deopting frame (could be compiled/interpreted).
3121   //
3122   // Note: by leaving the return address of self-frame on the stack
3123   // and using the size of frame 2 to adjust the stack
3124   // when we are done the return to frame 3 will still be on the stack.
3125 
3126   // Pop deoptimized frame
3127   __ movl(rcx, Address(rdi, Deoptimization::UnrollBlock::size_of_deoptimized_frame_offset_in_bytes()));
3128   __ addptr(rsp, rcx);
3129 
3130   // rsp should be pointing at the return address to the caller (3)
3131 
3132   // Pick up the initial fp we should save
3133   // restore rbp before stack bang because if stack overflow is thrown it needs to be pushed (and preserved)
3134   __ movptr(rbp, Address(rdi, Deoptimization::UnrollBlock::initial_info_offset_in_bytes()));
3135 
3136 #ifdef ASSERT
3137   // Compilers generate code that bang the stack by as much as the
3138   // interpreter would need. So this stack banging should never
3139   // trigger a fault. Verify that it does not on non product builds.
3140   if (UseStackBanging) {
3141     __ movl(rbx, Address(rdi, Deoptimization::UnrollBlock::total_frame_sizes_offset_in_bytes()));
3142     __ bang_stack_size(rbx, rcx);
3143   }
3144 #endif
3145 
3146   // Load address of array of frame pcs into rcx
3147   __ movptr(rcx, Address(rdi, Deoptimization::UnrollBlock::frame_pcs_offset_in_bytes()));
3148 
3149   // Trash the old pc
3150   __ addptr(rsp, wordSize);
3151 
3152   // Load address of array of frame sizes into rsi
3153   __ movptr(rsi, Address(rdi, Deoptimization::UnrollBlock::frame_sizes_offset_in_bytes()));
3154 
3155   // Load counter into rdx
3156   __ movl(rdx, Address(rdi, Deoptimization::UnrollBlock::number_of_frames_offset_in_bytes()));
3157 
3158   // Now adjust the caller&#39;s stack to make up for the extra locals
3159   // but record the original sp so that we can save it in the skeletal interpreter
3160   // frame and the stack walking of interpreter_sender will get the unextended sp
3161   // value and not the &quot;real&quot; sp value.
3162 
3163   const Register sender_sp = r8;
3164 
3165   __ mov(sender_sp, rsp);
3166   __ movl(rbx, Address(rdi,
3167                        Deoptimization::UnrollBlock::
3168                        caller_adjustment_offset_in_bytes()));
3169   __ subptr(rsp, rbx);
3170 
3171   // Push interpreter frames in a loop
3172   Label loop;
3173   __ bind(loop);
3174   __ movptr(rbx, Address(rsi, 0));      // Load frame size
3175   __ subptr(rbx, 2*wordSize);           // We&#39;ll push pc and ebp by hand
3176   __ pushptr(Address(rcx, 0));          // Save return address
3177   __ enter();                           // Save old &amp; set new ebp
3178   __ subptr(rsp, rbx);                  // Prolog
3179   // This value is corrected by layout_activation_impl
3180   __ movptr(Address(rbp, frame::interpreter_frame_last_sp_offset * wordSize), (int32_t)NULL_WORD );
3181   __ movptr(Address(rbp, frame::interpreter_frame_sender_sp_offset * wordSize), sender_sp); // Make it walkable
3182   __ mov(sender_sp, rsp);               // Pass sender_sp to next frame
3183   __ addptr(rsi, wordSize);             // Bump array pointer (sizes)
3184   __ addptr(rcx, wordSize);             // Bump array pointer (pcs)
3185   __ decrementl(rdx);                   // Decrement counter
3186   __ jcc(Assembler::notZero, loop);
3187   __ pushptr(Address(rcx, 0));          // Save final return address
3188 
3189   // Re-push self-frame
3190   __ enter();                           // Save old &amp; set new ebp
3191 
3192   // Allocate a full sized register save area.
3193   // Return address and rbp are in place, so we allocate two less words.
3194   __ subptr(rsp, (frame_size_in_words - 2) * wordSize);
3195 
3196   // Restore frame locals after moving the frame
3197   __ movdbl(Address(rsp, RegisterSaver::xmm0_offset_in_bytes()), xmm0);
3198   __ movptr(Address(rsp, RegisterSaver::rax_offset_in_bytes()), rax);
3199 
3200   // Call C code.  Need thread but NOT official VM entry
3201   // crud.  We cannot block on this call, no GC can happen.  Call should
3202   // restore return values to their stack-slots with the new SP.
3203   //
3204   // void Deoptimization::unpack_frames(JavaThread* thread, int exec_mode)
3205 
3206   // Use rbp because the frames look interpreted now
3207   // Save &quot;the_pc&quot; since it cannot easily be retrieved using the last_java_SP after we aligned SP.
3208   // Don&#39;t need the precise return PC here, just precise enough to point into this code blob.
3209   address the_pc = __ pc();
3210   __ set_last_Java_frame(noreg, rbp, the_pc);
3211 
3212   __ andptr(rsp, -(StackAlignmentInBytes));  // Fix stack alignment as required by ABI
3213   __ mov(c_rarg0, r15_thread);
3214   __ movl(c_rarg1, r14); // second arg: exec_mode
3215   __ call(RuntimeAddress(CAST_FROM_FN_PTR(address, Deoptimization::unpack_frames)));
3216   // Revert SP alignment after call since we&#39;re going to do some SP relative addressing below
3217   __ movptr(rsp, Address(r15_thread, JavaThread::last_Java_sp_offset()));
3218 
3219   // Set an oopmap for the call site
3220   // Use the same PC we used for the last java frame
3221   oop_maps-&gt;add_gc_map(the_pc - start,
3222                        new OopMap( frame_size_in_words, 0 ));
3223 
3224   // Clear fp AND pc
3225   __ reset_last_Java_frame(true);
3226 
3227   // Collect return values
3228   __ movdbl(xmm0, Address(rsp, RegisterSaver::xmm0_offset_in_bytes()));
3229   __ movptr(rax, Address(rsp, RegisterSaver::rax_offset_in_bytes()));
3230   // I think this is useless (throwing pc?)
3231   __ movptr(rdx, Address(rsp, RegisterSaver::rdx_offset_in_bytes()));
3232 
3233   // Pop self-frame.
3234   __ leave();                           // Epilog
3235 
3236   // Jump to interpreter
3237   __ ret(0);
3238 
3239   // Make sure all code is generated
3240   masm-&gt;flush();
3241 
3242   _deopt_blob = DeoptimizationBlob::create(&amp;buffer, oop_maps, 0, exception_offset, reexecute_offset, frame_size_in_words);
3243   _deopt_blob-&gt;set_unpack_with_exception_in_tls_offset(exception_in_tls_offset);
3244 #if INCLUDE_JVMCI
3245   if (EnableJVMCI || UseAOT) {
3246     _deopt_blob-&gt;set_uncommon_trap_offset(uncommon_trap_offset);
3247     _deopt_blob-&gt;set_implicit_exception_uncommon_trap_offset(implicit_exception_uncommon_trap_offset);
3248   }
3249 #endif
3250 }
3251 
3252 #ifdef COMPILER2
3253 //------------------------------generate_uncommon_trap_blob--------------------
3254 void SharedRuntime::generate_uncommon_trap_blob() {
3255   // Allocate space for the code
3256   ResourceMark rm;
3257   // Setup code generation tools
3258   CodeBuffer buffer(&quot;uncommon_trap_blob&quot;, 2048, 1024);
3259   MacroAssembler* masm = new MacroAssembler(&amp;buffer);
3260 
3261   assert(SimpleRuntimeFrame::framesize % 4 == 0, &quot;sp not 16-byte aligned&quot;);
3262 
3263   address start = __ pc();
3264 
3265   if (UseRTMLocking) {
3266     // Abort RTM transaction before possible nmethod deoptimization.
3267     __ xabort(0);
3268   }
3269 
3270   // Push self-frame.  We get here with a return address on the
3271   // stack, so rsp is 8-byte aligned until we allocate our frame.
3272   __ subptr(rsp, SimpleRuntimeFrame::return_off &lt;&lt; LogBytesPerInt); // Epilog!
3273 
3274   // No callee saved registers. rbp is assumed implicitly saved
3275   __ movptr(Address(rsp, SimpleRuntimeFrame::rbp_off &lt;&lt; LogBytesPerInt), rbp);
3276 
3277   // compiler left unloaded_class_index in j_rarg0 move to where the
3278   // runtime expects it.
3279   __ movl(c_rarg1, j_rarg0);
3280 
3281   __ set_last_Java_frame(noreg, noreg, NULL);
3282 
3283   // Call C code.  Need thread but NOT official VM entry
3284   // crud.  We cannot block on this call, no GC can happen.  Call should
3285   // capture callee-saved registers as well as return values.
3286   // Thread is in rdi already.
3287   //
3288   // UnrollBlock* uncommon_trap(JavaThread* thread, jint unloaded_class_index);
3289 
3290   __ mov(c_rarg0, r15_thread);
3291   __ movl(c_rarg2, Deoptimization::Unpack_uncommon_trap);
3292   __ call(RuntimeAddress(CAST_FROM_FN_PTR(address, Deoptimization::uncommon_trap)));
3293 
3294   // Set an oopmap for the call site
3295   OopMapSet* oop_maps = new OopMapSet();
3296   OopMap* map = new OopMap(SimpleRuntimeFrame::framesize, 0);
3297 
3298   // location of rbp is known implicitly by the frame sender code
3299 
3300   oop_maps-&gt;add_gc_map(__ pc() - start, map);
3301 
3302   __ reset_last_Java_frame(false);
3303 
3304   // Load UnrollBlock* into rdi
3305   __ mov(rdi, rax);
3306 
3307 #ifdef ASSERT
3308   { Label L;
3309     __ cmpptr(Address(rdi, Deoptimization::UnrollBlock::unpack_kind_offset_in_bytes()),
3310             (int32_t)Deoptimization::Unpack_uncommon_trap);
3311     __ jcc(Assembler::equal, L);
3312     __ stop(&quot;SharedRuntime::generate_deopt_blob: expected Unpack_uncommon_trap&quot;);
3313     __ bind(L);
3314   }
3315 #endif
3316 
3317   // Pop all the frames we must move/replace.
3318   //
3319   // Frame picture (youngest to oldest)
3320   // 1: self-frame (no frame link)
3321   // 2: deopting frame  (no frame link)
3322   // 3: caller of deopting frame (could be compiled/interpreted).
3323 
3324   // Pop self-frame.  We have no frame, and must rely only on rax and rsp.
3325   __ addptr(rsp, (SimpleRuntimeFrame::framesize - 2) &lt;&lt; LogBytesPerInt); // Epilog!
3326 
3327   // Pop deoptimized frame (int)
3328   __ movl(rcx, Address(rdi,
3329                        Deoptimization::UnrollBlock::
3330                        size_of_deoptimized_frame_offset_in_bytes()));
3331   __ addptr(rsp, rcx);
3332 
3333   // rsp should be pointing at the return address to the caller (3)
3334 
3335   // Pick up the initial fp we should save
3336   // restore rbp before stack bang because if stack overflow is thrown it needs to be pushed (and preserved)
3337   __ movptr(rbp, Address(rdi, Deoptimization::UnrollBlock::initial_info_offset_in_bytes()));
3338 
3339 #ifdef ASSERT
3340   // Compilers generate code that bang the stack by as much as the
3341   // interpreter would need. So this stack banging should never
3342   // trigger a fault. Verify that it does not on non product builds.
3343   if (UseStackBanging) {
3344     __ movl(rbx, Address(rdi ,Deoptimization::UnrollBlock::total_frame_sizes_offset_in_bytes()));
3345     __ bang_stack_size(rbx, rcx);
3346   }
3347 #endif
3348 
3349   // Load address of array of frame pcs into rcx (address*)
3350   __ movptr(rcx, Address(rdi, Deoptimization::UnrollBlock::frame_pcs_offset_in_bytes()));
3351 
3352   // Trash the return pc
3353   __ addptr(rsp, wordSize);
3354 
3355   // Load address of array of frame sizes into rsi (intptr_t*)
3356   __ movptr(rsi, Address(rdi, Deoptimization::UnrollBlock:: frame_sizes_offset_in_bytes()));
3357 
3358   // Counter
3359   __ movl(rdx, Address(rdi, Deoptimization::UnrollBlock:: number_of_frames_offset_in_bytes())); // (int)
3360 
3361   // Now adjust the caller&#39;s stack to make up for the extra locals but
3362   // record the original sp so that we can save it in the skeletal
3363   // interpreter frame and the stack walking of interpreter_sender
3364   // will get the unextended sp value and not the &quot;real&quot; sp value.
3365 
3366   const Register sender_sp = r8;
3367 
3368   __ mov(sender_sp, rsp);
3369   __ movl(rbx, Address(rdi, Deoptimization::UnrollBlock:: caller_adjustment_offset_in_bytes())); // (int)
3370   __ subptr(rsp, rbx);
3371 
3372   // Push interpreter frames in a loop
3373   Label loop;
3374   __ bind(loop);
3375   __ movptr(rbx, Address(rsi, 0)); // Load frame size
3376   __ subptr(rbx, 2 * wordSize);    // We&#39;ll push pc and rbp by hand
3377   __ pushptr(Address(rcx, 0));     // Save return address
3378   __ enter();                      // Save old &amp; set new rbp
3379   __ subptr(rsp, rbx);             // Prolog
3380   __ movptr(Address(rbp, frame::interpreter_frame_sender_sp_offset * wordSize),
3381             sender_sp);            // Make it walkable
3382   // This value is corrected by layout_activation_impl
3383   __ movptr(Address(rbp, frame::interpreter_frame_last_sp_offset * wordSize), (int32_t)NULL_WORD );
3384   __ mov(sender_sp, rsp);          // Pass sender_sp to next frame
3385   __ addptr(rsi, wordSize);        // Bump array pointer (sizes)
3386   __ addptr(rcx, wordSize);        // Bump array pointer (pcs)
3387   __ decrementl(rdx);              // Decrement counter
3388   __ jcc(Assembler::notZero, loop);
3389   __ pushptr(Address(rcx, 0));     // Save final return address
3390 
3391   // Re-push self-frame
3392   __ enter();                 // Save old &amp; set new rbp
3393   __ subptr(rsp, (SimpleRuntimeFrame::framesize - 4) &lt;&lt; LogBytesPerInt);
3394                               // Prolog
3395 
3396   // Use rbp because the frames look interpreted now
3397   // Save &quot;the_pc&quot; since it cannot easily be retrieved using the last_java_SP after we aligned SP.
3398   // Don&#39;t need the precise return PC here, just precise enough to point into this code blob.
3399   address the_pc = __ pc();
3400   __ set_last_Java_frame(noreg, rbp, the_pc);
3401 
3402   // Call C code.  Need thread but NOT official VM entry
3403   // crud.  We cannot block on this call, no GC can happen.  Call should
3404   // restore return values to their stack-slots with the new SP.
3405   // Thread is in rdi already.
3406   //
3407   // BasicType unpack_frames(JavaThread* thread, int exec_mode);
3408 
3409   __ andptr(rsp, -(StackAlignmentInBytes)); // Align SP as required by ABI
3410   __ mov(c_rarg0, r15_thread);
3411   __ movl(c_rarg1, Deoptimization::Unpack_uncommon_trap);
3412   __ call(RuntimeAddress(CAST_FROM_FN_PTR(address, Deoptimization::unpack_frames)));
3413 
3414   // Set an oopmap for the call site
3415   // Use the same PC we used for the last java frame
3416   oop_maps-&gt;add_gc_map(the_pc - start, new OopMap(SimpleRuntimeFrame::framesize, 0));
3417 
3418   // Clear fp AND pc
3419   __ reset_last_Java_frame(true);
3420 
3421   // Pop self-frame.
3422   __ leave();                 // Epilog
3423 
3424   // Jump to interpreter
3425   __ ret(0);
3426 
3427   // Make sure all code is generated
3428   masm-&gt;flush();
3429 
3430   _uncommon_trap_blob =  UncommonTrapBlob::create(&amp;buffer, oop_maps,
3431                                                  SimpleRuntimeFrame::framesize &gt;&gt; 1);
3432 }
3433 #endif // COMPILER2
3434 
3435 
3436 //------------------------------generate_handler_blob------
3437 //
3438 // Generate a special Compile2Runtime blob that saves all registers,
3439 // and setup oopmap.
3440 //
3441 SafepointBlob* SharedRuntime::generate_handler_blob(address call_ptr, int poll_type) {
3442   assert(StubRoutines::forward_exception_entry() != NULL,
3443          &quot;must be generated before&quot;);
3444 
3445   ResourceMark rm;
3446   OopMapSet *oop_maps = new OopMapSet();
3447   OopMap* map;
3448 
3449   // Allocate space for the code.  Setup code generation tools.
3450   CodeBuffer buffer(&quot;handler_blob&quot;, 2048, 1024);
3451   MacroAssembler* masm = new MacroAssembler(&amp;buffer);
3452 
3453   address start   = __ pc();
3454   address call_pc = NULL;
3455   int frame_size_in_words;
3456   bool cause_return = (poll_type == POLL_AT_RETURN);
3457   bool save_vectors = (poll_type == POLL_AT_VECTOR_LOOP);
3458 
3459   if (UseRTMLocking) {
3460     // Abort RTM transaction before calling runtime
3461     // because critical section will be large and will be
3462     // aborted anyway. Also nmethod could be deoptimized.
3463     __ xabort(0);
3464   }
3465 
3466   // Make room for return address (or push it again)
3467   if (!cause_return) {
3468     __ push(rbx);
3469   }
3470 
3471   // Save registers, fpu state, and flags
3472   map = RegisterSaver::save_live_registers(masm, 0, &amp;frame_size_in_words, save_vectors);
3473 
3474   // The following is basically a call_VM.  However, we need the precise
3475   // address of the call in order to generate an oopmap. Hence, we do all the
3476   // work outselves.
3477 
3478   __ set_last_Java_frame(noreg, noreg, NULL);
3479 
3480   // The return address must always be correct so that frame constructor never
3481   // sees an invalid pc.
3482 
3483   if (!cause_return) {
3484     // Get the return pc saved by the signal handler and stash it in its appropriate place on the stack.
3485     // Additionally, rbx is a callee saved register and we can look at it later to determine
3486     // if someone changed the return address for us!
3487     __ movptr(rbx, Address(r15_thread, JavaThread::saved_exception_pc_offset()));
3488     __ movptr(Address(rbp, wordSize), rbx);
3489   }
3490 
3491   // Do the call
3492   __ mov(c_rarg0, r15_thread);
3493   __ call(RuntimeAddress(call_ptr));
3494 
3495   // Set an oopmap for the call site.  This oopmap will map all
3496   // oop-registers and debug-info registers as callee-saved.  This
3497   // will allow deoptimization at this safepoint to find all possible
3498   // debug-info recordings, as well as let GC find all oops.
3499 
3500   oop_maps-&gt;add_gc_map( __ pc() - start, map);
3501 
3502   Label noException;
3503 
3504   __ reset_last_Java_frame(false);
3505 
3506   __ cmpptr(Address(r15_thread, Thread::pending_exception_offset()), (int32_t)NULL_WORD);
3507   __ jcc(Assembler::equal, noException);
3508 
3509   // Exception pending
3510 
3511   RegisterSaver::restore_live_registers(masm, save_vectors);
3512 
3513   __ jump(RuntimeAddress(StubRoutines::forward_exception_entry()));
3514 
3515   // No exception case
3516   __ bind(noException);
3517 
3518   Label no_adjust;
3519 #ifdef ASSERT
3520   Label bail;
3521 #endif
3522   if (SafepointMechanism::uses_thread_local_poll() &amp;&amp; !cause_return) {
3523     Label no_prefix, not_special;
3524 
3525     // If our stashed return pc was modified by the runtime we avoid touching it
3526     __ cmpptr(rbx, Address(rbp, wordSize));
3527     __ jccb(Assembler::notEqual, no_adjust);
3528 
3529     // Skip over the poll instruction.
3530     // See NativeInstruction::is_safepoint_poll()
3531     // Possible encodings:
3532     //      85 00       test   %eax,(%rax)
3533     //      85 01       test   %eax,(%rcx)
3534     //      85 02       test   %eax,(%rdx)
3535     //      85 03       test   %eax,(%rbx)
3536     //      85 06       test   %eax,(%rsi)
3537     //      85 07       test   %eax,(%rdi)
3538     //
3539     //   41 85 00       test   %eax,(%r8)
3540     //   41 85 01       test   %eax,(%r9)
3541     //   41 85 02       test   %eax,(%r10)
3542     //   41 85 03       test   %eax,(%r11)
3543     //   41 85 06       test   %eax,(%r14)
3544     //   41 85 07       test   %eax,(%r15)
3545     //
3546     //      85 04 24    test   %eax,(%rsp)
3547     //   41 85 04 24    test   %eax,(%r12)
3548     //      85 45 00    test   %eax,0x0(%rbp)
3549     //   41 85 45 00    test   %eax,0x0(%r13)
3550 
3551     __ cmpb(Address(rbx, 0), NativeTstRegMem::instruction_rex_b_prefix);
3552     __ jcc(Assembler::notEqual, no_prefix);
3553     __ addptr(rbx, 1);
3554     __ bind(no_prefix);
3555 #ifdef ASSERT
3556     __ movptr(rax, rbx); // remember where 0x85 should be, for verification below
3557 #endif
3558     // r12/r13/rsp/rbp base encoding takes 3 bytes with the following register values:
3559     // r12/rsp 0x04
3560     // r13/rbp 0x05
3561     __ movzbq(rcx, Address(rbx, 1));
3562     __ andptr(rcx, 0x07); // looking for 0x04 .. 0x05
3563     __ subptr(rcx, 4);    // looking for 0x00 .. 0x01
3564     __ cmpptr(rcx, 1);
3565     __ jcc(Assembler::above, not_special);
3566     __ addptr(rbx, 1);
3567     __ bind(not_special);
3568 #ifdef ASSERT
3569     // Verify the correct encoding of the poll we&#39;re about to skip.
3570     __ cmpb(Address(rax, 0), NativeTstRegMem::instruction_code_memXregl);
3571     __ jcc(Assembler::notEqual, bail);
3572     // Mask out the modrm bits
3573     __ testb(Address(rax, 1), NativeTstRegMem::modrm_mask);
3574     // rax encodes to 0, so if the bits are nonzero it&#39;s incorrect
3575     __ jcc(Assembler::notZero, bail);
3576 #endif
3577     // Adjust return pc forward to step over the safepoint poll instruction
3578     __ addptr(rbx, 2);
3579     __ movptr(Address(rbp, wordSize), rbx);
3580   }
3581 
3582   __ bind(no_adjust);
3583   // Normal exit, restore registers and exit.
3584   RegisterSaver::restore_live_registers(masm, save_vectors);
3585   __ ret(0);
3586 
3587 #ifdef ASSERT
3588   __ bind(bail);
3589   __ stop(&quot;Attempting to adjust pc to skip safepoint poll but the return point is not what we expected&quot;);
3590 #endif
3591 
3592   // Make sure all code is generated
3593   masm-&gt;flush();
3594 
3595   // Fill-out other meta info
3596   return SafepointBlob::create(&amp;buffer, oop_maps, frame_size_in_words);
3597 }
3598 
3599 //
3600 // generate_resolve_blob - call resolution (static/virtual/opt-virtual/ic-miss
3601 //
3602 // Generate a stub that calls into vm to find out the proper destination
3603 // of a java call. All the argument registers are live at this point
3604 // but since this is generic code we don&#39;t know what they are and the caller
3605 // must do any gc of the args.
3606 //
3607 RuntimeStub* SharedRuntime::generate_resolve_blob(address destination, const char* name) {
3608   assert (StubRoutines::forward_exception_entry() != NULL, &quot;must be generated before&quot;);
3609 
3610   // allocate space for the code
3611   ResourceMark rm;
3612 
3613   CodeBuffer buffer(name, 1000, 512);
3614   MacroAssembler* masm                = new MacroAssembler(&amp;buffer);
3615 
3616   int frame_size_in_words;
3617 
3618   OopMapSet *oop_maps = new OopMapSet();
3619   OopMap* map = NULL;
3620 
3621   int start = __ offset();
3622 
3623   map = RegisterSaver::save_live_registers(masm, 0, &amp;frame_size_in_words);
3624 
3625   int frame_complete = __ offset();
3626 
3627   __ set_last_Java_frame(noreg, noreg, NULL);
3628 
3629   __ mov(c_rarg0, r15_thread);
3630 
3631   __ call(RuntimeAddress(destination));
3632 
3633 
3634   // Set an oopmap for the call site.
3635   // We need this not only for callee-saved registers, but also for volatile
3636   // registers that the compiler might be keeping live across a safepoint.
3637 
3638   oop_maps-&gt;add_gc_map( __ offset() - start, map);
3639 
3640   // rax contains the address we are going to jump to assuming no exception got installed
3641 
3642   // clear last_Java_sp
3643   __ reset_last_Java_frame(false);
3644   // check for pending exceptions
3645   Label pending;
3646   __ cmpptr(Address(r15_thread, Thread::pending_exception_offset()), (int32_t)NULL_WORD);
3647   __ jcc(Assembler::notEqual, pending);
3648 
3649   // get the returned Method*
3650   __ get_vm_result_2(rbx, r15_thread);
3651   __ movptr(Address(rsp, RegisterSaver::rbx_offset_in_bytes()), rbx);
3652 
3653   __ movptr(Address(rsp, RegisterSaver::rax_offset_in_bytes()), rax);
3654 
3655   RegisterSaver::restore_live_registers(masm);
3656 
3657   // We are back the the original state on entry and ready to go.
3658 
3659   __ jmp(rax);
3660 
3661   // Pending exception after the safepoint
3662 
3663   __ bind(pending);
3664 
3665   RegisterSaver::restore_live_registers(masm);
3666 
3667   // exception pending =&gt; remove activation and forward to exception handler
3668 
3669   __ movptr(Address(r15_thread, JavaThread::vm_result_offset()), (int)NULL_WORD);
3670 
3671   __ movptr(rax, Address(r15_thread, Thread::pending_exception_offset()));
3672   __ jump(RuntimeAddress(StubRoutines::forward_exception_entry()));
3673 
3674   // -------------
3675   // make sure all code is generated
3676   masm-&gt;flush();
3677 
3678   // return the  blob
3679   // frame_size_words or bytes??
3680   return RuntimeStub::new_runtime_stub(name, &amp;buffer, frame_complete, frame_size_in_words, oop_maps, true);
3681 }
3682 
3683 
3684 //------------------------------Montgomery multiplication------------------------
3685 //
3686 
3687 #ifndef _WINDOWS
3688 
3689 #define ASM_SUBTRACT
3690 
3691 #ifdef ASM_SUBTRACT
3692 // Subtract 0:b from carry:a.  Return carry.
3693 static unsigned long
3694 sub(unsigned long a[], unsigned long b[], unsigned long carry, long len) {
3695   long i = 0, cnt = len;
3696   unsigned long tmp;
3697   asm volatile(&quot;clc; &quot;
3698                &quot;0: ; &quot;
3699                &quot;mov (%[b], %[i], 8), %[tmp]; &quot;
3700                &quot;sbb %[tmp], (%[a], %[i], 8); &quot;
3701                &quot;inc %[i]; dec %[cnt]; &quot;
3702                &quot;jne 0b; &quot;
3703                &quot;mov %[carry], %[tmp]; sbb $0, %[tmp]; &quot;
3704                : [i]&quot;+r&quot;(i), [cnt]&quot;+r&quot;(cnt), [tmp]&quot;=&amp;r&quot;(tmp)
3705                : [a]&quot;r&quot;(a), [b]&quot;r&quot;(b), [carry]&quot;r&quot;(carry)
3706                : &quot;memory&quot;);
3707   return tmp;
3708 }
3709 #else // ASM_SUBTRACT
3710 typedef int __attribute__((mode(TI))) int128;
3711 
3712 // Subtract 0:b from carry:a.  Return carry.
3713 static unsigned long
3714 sub(unsigned long a[], unsigned long b[], unsigned long carry, int len) {
3715   int128 tmp = 0;
3716   int i;
3717   for (i = 0; i &lt; len; i++) {
3718     tmp += a[i];
3719     tmp -= b[i];
3720     a[i] = tmp;
3721     tmp &gt;&gt;= 64;
3722     assert(-1 &lt;= tmp &amp;&amp; tmp &lt;= 0, &quot;invariant&quot;);
3723   }
3724   return tmp + carry;
3725 }
3726 #endif // ! ASM_SUBTRACT
3727 
3728 // Multiply (unsigned) Long A by Long B, accumulating the double-
3729 // length result into the accumulator formed of T0, T1, and T2.
3730 #define MACC(A, B, T0, T1, T2)                                  \
3731 do {                                                            \
3732   unsigned long hi, lo;                                         \
3733   __asm__ (&quot;mul %5; add %%rax, %2; adc %%rdx, %3; adc $0, %4&quot;   \
3734            : &quot;=&amp;d&quot;(hi), &quot;=a&quot;(lo), &quot;+r&quot;(T0), &quot;+r&quot;(T1), &quot;+g&quot;(T2)  \
3735            : &quot;r&quot;(A), &quot;a&quot;(B) : &quot;cc&quot;);                            \
3736  } while(0)
3737 
3738 // As above, but add twice the double-length result into the
3739 // accumulator.
3740 #define MACC2(A, B, T0, T1, T2)                                 \
3741 do {                                                            \
3742   unsigned long hi, lo;                                         \
3743   __asm__ (&quot;mul %5; add %%rax, %2; adc %%rdx, %3; adc $0, %4; &quot; \
3744            &quot;add %%rax, %2; adc %%rdx, %3; adc $0, %4&quot;           \
3745            : &quot;=&amp;d&quot;(hi), &quot;=a&quot;(lo), &quot;+r&quot;(T0), &quot;+r&quot;(T1), &quot;+g&quot;(T2)  \
3746            : &quot;r&quot;(A), &quot;a&quot;(B) : &quot;cc&quot;);                            \
3747  } while(0)
3748 
3749 // Fast Montgomery multiplication.  The derivation of the algorithm is
3750 // in  A Cryptographic Library for the Motorola DSP56000,
3751 // Dusse and Kaliski, Proc. EUROCRYPT 90, pp. 230-237.
3752 
3753 static void __attribute__((noinline))
3754 montgomery_multiply(unsigned long a[], unsigned long b[], unsigned long n[],
3755                     unsigned long m[], unsigned long inv, int len) {
3756   unsigned long t0 = 0, t1 = 0, t2 = 0; // Triple-precision accumulator
3757   int i;
3758 
3759   assert(inv * n[0] == -1UL, &quot;broken inverse in Montgomery multiply&quot;);
3760 
3761   for (i = 0; i &lt; len; i++) {
3762     int j;
3763     for (j = 0; j &lt; i; j++) {
3764       MACC(a[j], b[i-j], t0, t1, t2);
3765       MACC(m[j], n[i-j], t0, t1, t2);
3766     }
3767     MACC(a[i], b[0], t0, t1, t2);
3768     m[i] = t0 * inv;
3769     MACC(m[i], n[0], t0, t1, t2);
3770 
3771     assert(t0 == 0, &quot;broken Montgomery multiply&quot;);
3772 
3773     t0 = t1; t1 = t2; t2 = 0;
3774   }
3775 
3776   for (i = len; i &lt; 2*len; i++) {
3777     int j;
3778     for (j = i-len+1; j &lt; len; j++) {
3779       MACC(a[j], b[i-j], t0, t1, t2);
3780       MACC(m[j], n[i-j], t0, t1, t2);
3781     }
3782     m[i-len] = t0;
3783     t0 = t1; t1 = t2; t2 = 0;
3784   }
3785 
3786   while (t0)
3787     t0 = sub(m, n, t0, len);
3788 }
3789 
3790 // Fast Montgomery squaring.  This uses asymptotically 25% fewer
3791 // multiplies so it should be up to 25% faster than Montgomery
3792 // multiplication.  However, its loop control is more complex and it
3793 // may actually run slower on some machines.
3794 
3795 static void __attribute__((noinline))
3796 montgomery_square(unsigned long a[], unsigned long n[],
3797                   unsigned long m[], unsigned long inv, int len) {
3798   unsigned long t0 = 0, t1 = 0, t2 = 0; // Triple-precision accumulator
3799   int i;
3800 
3801   assert(inv * n[0] == -1UL, &quot;broken inverse in Montgomery multiply&quot;);
3802 
3803   for (i = 0; i &lt; len; i++) {
3804     int j;
3805     int end = (i+1)/2;
3806     for (j = 0; j &lt; end; j++) {
3807       MACC2(a[j], a[i-j], t0, t1, t2);
3808       MACC(m[j], n[i-j], t0, t1, t2);
3809     }
3810     if ((i &amp; 1) == 0) {
3811       MACC(a[j], a[j], t0, t1, t2);
3812     }
3813     for (; j &lt; i; j++) {
3814       MACC(m[j], n[i-j], t0, t1, t2);
3815     }
3816     m[i] = t0 * inv;
3817     MACC(m[i], n[0], t0, t1, t2);
3818 
3819     assert(t0 == 0, &quot;broken Montgomery square&quot;);
3820 
3821     t0 = t1; t1 = t2; t2 = 0;
3822   }
3823 
3824   for (i = len; i &lt; 2*len; i++) {
3825     int start = i-len+1;
3826     int end = start + (len - start)/2;
3827     int j;
3828     for (j = start; j &lt; end; j++) {
3829       MACC2(a[j], a[i-j], t0, t1, t2);
3830       MACC(m[j], n[i-j], t0, t1, t2);
3831     }
3832     if ((i &amp; 1) == 0) {
3833       MACC(a[j], a[j], t0, t1, t2);
3834     }
3835     for (; j &lt; len; j++) {
3836       MACC(m[j], n[i-j], t0, t1, t2);
3837     }
3838     m[i-len] = t0;
3839     t0 = t1; t1 = t2; t2 = 0;
3840   }
3841 
3842   while (t0)
3843     t0 = sub(m, n, t0, len);
3844 }
3845 
3846 // Swap words in a longword.
3847 static unsigned long swap(unsigned long x) {
3848   return (x &lt;&lt; 32) | (x &gt;&gt; 32);
3849 }
3850 
3851 // Copy len longwords from s to d, word-swapping as we go.  The
3852 // destination array is reversed.
3853 static void reverse_words(unsigned long *s, unsigned long *d, int len) {
3854   d += len;
3855   while(len-- &gt; 0) {
3856     d--;
3857     *d = swap(*s);
3858     s++;
3859   }
3860 }
3861 
3862 // The threshold at which squaring is advantageous was determined
3863 // experimentally on an i7-3930K (Ivy Bridge) CPU @ 3.5GHz.
3864 #define MONTGOMERY_SQUARING_THRESHOLD 64
3865 
3866 void SharedRuntime::montgomery_multiply(jint *a_ints, jint *b_ints, jint *n_ints,
3867                                         jint len, jlong inv,
3868                                         jint *m_ints) {
3869   assert(len % 2 == 0, &quot;array length in montgomery_multiply must be even&quot;);
3870   int longwords = len/2;
3871 
3872   // Make very sure we don&#39;t use so much space that the stack might
3873   // overflow.  512 jints corresponds to an 16384-bit integer and
3874   // will use here a total of 8k bytes of stack space.
3875   int total_allocation = longwords * sizeof (unsigned long) * 4;
3876   guarantee(total_allocation &lt;= 8192, &quot;must be&quot;);
3877   unsigned long *scratch = (unsigned long *)alloca(total_allocation);
3878 
3879   // Local scratch arrays
3880   unsigned long
3881     *a = scratch + 0 * longwords,
3882     *b = scratch + 1 * longwords,
3883     *n = scratch + 2 * longwords,
3884     *m = scratch + 3 * longwords;
3885 
3886   reverse_words((unsigned long *)a_ints, a, longwords);
3887   reverse_words((unsigned long *)b_ints, b, longwords);
3888   reverse_words((unsigned long *)n_ints, n, longwords);
3889 
3890   ::montgomery_multiply(a, b, n, m, (unsigned long)inv, longwords);
3891 
3892   reverse_words(m, (unsigned long *)m_ints, longwords);
3893 }
3894 
3895 void SharedRuntime::montgomery_square(jint *a_ints, jint *n_ints,
3896                                       jint len, jlong inv,
3897                                       jint *m_ints) {
3898   assert(len % 2 == 0, &quot;array length in montgomery_square must be even&quot;);
3899   int longwords = len/2;
3900 
3901   // Make very sure we don&#39;t use so much space that the stack might
3902   // overflow.  512 jints corresponds to an 16384-bit integer and
3903   // will use here a total of 6k bytes of stack space.
3904   int total_allocation = longwords * sizeof (unsigned long) * 3;
3905   guarantee(total_allocation &lt;= 8192, &quot;must be&quot;);
3906   unsigned long *scratch = (unsigned long *)alloca(total_allocation);
3907 
3908   // Local scratch arrays
3909   unsigned long
3910     *a = scratch + 0 * longwords,
3911     *n = scratch + 1 * longwords,
3912     *m = scratch + 2 * longwords;
3913 
3914   reverse_words((unsigned long *)a_ints, a, longwords);
3915   reverse_words((unsigned long *)n_ints, n, longwords);
3916 
3917   if (len &gt;= MONTGOMERY_SQUARING_THRESHOLD) {
3918     ::montgomery_square(a, n, m, (unsigned long)inv, longwords);
3919   } else {
3920     ::montgomery_multiply(a, a, n, m, (unsigned long)inv, longwords);
3921   }
3922 
3923   reverse_words(m, (unsigned long *)m_ints, longwords);
3924 }
3925 
3926 #endif // WINDOWS
3927 
3928 #ifdef COMPILER2
3929 // This is here instead of runtime_x86_64.cpp because it uses SimpleRuntimeFrame
3930 //
3931 //------------------------------generate_exception_blob---------------------------
3932 // creates exception blob at the end
3933 // Using exception blob, this code is jumped from a compiled method.
3934 // (see emit_exception_handler in x86_64.ad file)
3935 //
3936 // Given an exception pc at a call we call into the runtime for the
3937 // handler in this method. This handler might merely restore state
3938 // (i.e. callee save registers) unwind the frame and jump to the
3939 // exception handler for the nmethod if there is no Java level handler
3940 // for the nmethod.
3941 //
3942 // This code is entered with a jmp.
3943 //
3944 // Arguments:
3945 //   rax: exception oop
3946 //   rdx: exception pc
3947 //
3948 // Results:
3949 //   rax: exception oop
3950 //   rdx: exception pc in caller or ???
3951 //   destination: exception handler of caller
3952 //
3953 // Note: the exception pc MUST be at a call (precise debug information)
3954 //       Registers rax, rdx, rcx, rsi, rdi, r8-r11 are not callee saved.
3955 //
3956 
3957 void OptoRuntime::generate_exception_blob() {
3958   assert(!OptoRuntime::is_callee_saved_register(RDX_num), &quot;&quot;);
3959   assert(!OptoRuntime::is_callee_saved_register(RAX_num), &quot;&quot;);
3960   assert(!OptoRuntime::is_callee_saved_register(RCX_num), &quot;&quot;);
3961 
3962   assert(SimpleRuntimeFrame::framesize % 4 == 0, &quot;sp not 16-byte aligned&quot;);
3963 
3964   // Allocate space for the code
3965   ResourceMark rm;
3966   // Setup code generation tools
3967   CodeBuffer buffer(&quot;exception_blob&quot;, 2048, 1024);
3968   MacroAssembler* masm = new MacroAssembler(&amp;buffer);
3969 
3970 
3971   address start = __ pc();
3972 
3973   // Exception pc is &#39;return address&#39; for stack walker
3974   __ push(rdx);
3975   __ subptr(rsp, SimpleRuntimeFrame::return_off &lt;&lt; LogBytesPerInt); // Prolog
3976 
3977   // Save callee-saved registers.  See x86_64.ad.
3978 
3979   // rbp is an implicitly saved callee saved register (i.e., the calling
3980   // convention will save/restore it in the prolog/epilog). Other than that
3981   // there are no callee save registers now that adapter frames are gone.
3982 
3983   __ movptr(Address(rsp, SimpleRuntimeFrame::rbp_off &lt;&lt; LogBytesPerInt), rbp);
3984 
3985   // Store exception in Thread object. We cannot pass any arguments to the
3986   // handle_exception call, since we do not want to make any assumption
3987   // about the size of the frame where the exception happened in.
3988   // c_rarg0 is either rdi (Linux) or rcx (Windows).
3989   __ movptr(Address(r15_thread, JavaThread::exception_oop_offset()),rax);
3990   __ movptr(Address(r15_thread, JavaThread::exception_pc_offset()), rdx);
3991 
3992   // This call does all the hard work.  It checks if an exception handler
3993   // exists in the method.
3994   // If so, it returns the handler address.
3995   // If not, it prepares for stack-unwinding, restoring the callee-save
3996   // registers of the frame being removed.
3997   //
3998   // address OptoRuntime::handle_exception_C(JavaThread* thread)
3999 
4000   // At a method handle call, the stack may not be properly aligned
4001   // when returning with an exception.
4002   address the_pc = __ pc();
4003   __ set_last_Java_frame(noreg, noreg, the_pc);
4004   __ mov(c_rarg0, r15_thread);
4005   __ andptr(rsp, -(StackAlignmentInBytes));    // Align stack
4006   __ call(RuntimeAddress(CAST_FROM_FN_PTR(address, OptoRuntime::handle_exception_C)));
4007 
4008   // Set an oopmap for the call site.  This oopmap will only be used if we
4009   // are unwinding the stack.  Hence, all locations will be dead.
4010   // Callee-saved registers will be the same as the frame above (i.e.,
4011   // handle_exception_stub), since they were restored when we got the
4012   // exception.
4013 
4014   OopMapSet* oop_maps = new OopMapSet();
4015 
4016   oop_maps-&gt;add_gc_map(the_pc - start, new OopMap(SimpleRuntimeFrame::framesize, 0));
4017 
4018   __ reset_last_Java_frame(false);
4019 
4020   // Restore callee-saved registers
4021 
4022   // rbp is an implicitly saved callee-saved register (i.e., the calling
4023   // convention will save restore it in prolog/epilog) Other than that
4024   // there are no callee save registers now that adapter frames are gone.
4025 
4026   __ movptr(rbp, Address(rsp, SimpleRuntimeFrame::rbp_off &lt;&lt; LogBytesPerInt));
4027 
4028   __ addptr(rsp, SimpleRuntimeFrame::return_off &lt;&lt; LogBytesPerInt); // Epilog
4029   __ pop(rdx);                  // No need for exception pc anymore
4030 
4031   // rax: exception handler
4032 
4033   // We have a handler in rax (could be deopt blob).
4034   __ mov(r8, rax);
4035 
4036   // Get the exception oop
4037   __ movptr(rax, Address(r15_thread, JavaThread::exception_oop_offset()));
4038   // Get the exception pc in case we are deoptimized
4039   __ movptr(rdx, Address(r15_thread, JavaThread::exception_pc_offset()));
4040 #ifdef ASSERT
4041   __ movptr(Address(r15_thread, JavaThread::exception_handler_pc_offset()), (int)NULL_WORD);
4042   __ movptr(Address(r15_thread, JavaThread::exception_pc_offset()), (int)NULL_WORD);
4043 #endif
4044   // Clear the exception oop so GC no longer processes it as a root.
4045   __ movptr(Address(r15_thread, JavaThread::exception_oop_offset()), (int)NULL_WORD);
4046 
4047   // rax: exception oop
4048   // r8:  exception handler
4049   // rdx: exception pc
4050   // Jump to handler
4051 
4052   __ jmp(r8);
4053 
4054   // Make sure all code is generated
4055   masm-&gt;flush();
4056 
4057   // Set exception blob
4058   _exception_blob =  ExceptionBlob::create(&amp;buffer, oop_maps, SimpleRuntimeFrame::framesize &gt;&gt; 1);
4059 }
4060 #endif // COMPILER2
    </pre>
  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Udiff src/hotspot/cpu/x86/sharedRuntime_x86_64.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="interp_masm_x86.cpp.udiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="templateTable_x86.cpp.udiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/cpu/x86/sharedRuntime_x86_64.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-new-header">@@ -1,7 +1,7 @@</span>
  /*
<span class="udiff-line-modified-removed">-  * Copyright (c) 2003, 2018, Oracle and/or its affiliates. All rights reserved.</span>
<span class="udiff-line-modified-added">+  * Copyright (c) 2003, 2020, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -37,17 +37,19 @@</span>
  #include &quot;gc/shared/barrierSet.hpp&quot;
  #include &quot;gc/shared/barrierSetAssembler.hpp&quot;
  #include &quot;interpreter/interpreter.hpp&quot;
  #include &quot;logging/log.hpp&quot;
  #include &quot;memory/resourceArea.hpp&quot;
<span class="udiff-line-added">+ #include &quot;memory/universe.hpp&quot;</span>
  #include &quot;oops/compiledICHolder.hpp&quot;
<span class="udiff-line-added">+ #include &quot;oops/klass.inline.hpp&quot;</span>
  #include &quot;runtime/safepointMechanism.hpp&quot;
  #include &quot;runtime/sharedRuntime.hpp&quot;
  #include &quot;runtime/vframeArray.hpp&quot;
<span class="udiff-line-added">+ #include &quot;runtime/vm_version.hpp&quot;</span>
  #include &quot;utilities/align.hpp&quot;
  #include &quot;utilities/formatBuffer.hpp&quot;
<span class="udiff-line-removed">- #include &quot;vm_version_x86.hpp&quot;</span>
  #include &quot;vmreg_x86.inline.hpp&quot;
  #ifdef COMPILER1
  #include &quot;c1/c1_Runtime1.hpp&quot;
  #endif
  #ifdef COMPILER2
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -968,14 +970,40 @@</span>
      __ jump(RuntimeAddress(SharedRuntime::get_ic_miss_stub()));
    }
  
    address c2i_entry = __ pc();
  
<span class="udiff-line-added">+   // Class initialization barrier for static methods</span>
<span class="udiff-line-added">+   address c2i_no_clinit_check_entry = NULL;</span>
<span class="udiff-line-added">+   if (VM_Version::supports_fast_class_init_checks()) {</span>
<span class="udiff-line-added">+     Label L_skip_barrier;</span>
<span class="udiff-line-added">+     Register method = rbx;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     { // Bypass the barrier for non-static methods</span>
<span class="udiff-line-added">+       Register flags  = rscratch1;</span>
<span class="udiff-line-added">+       __ movl(flags, Address(method, Method::access_flags_offset()));</span>
<span class="udiff-line-added">+       __ testl(flags, JVM_ACC_STATIC);</span>
<span class="udiff-line-added">+       __ jcc(Assembler::zero, L_skip_barrier); // non-static</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     Register klass = rscratch1;</span>
<span class="udiff-line-added">+     __ load_method_holder(klass, method);</span>
<span class="udiff-line-added">+     __ clinit_barrier(klass, r15_thread, &amp;L_skip_barrier /*L_fast_path*/);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     __ jump(RuntimeAddress(SharedRuntime::get_handle_wrong_method_stub())); // slow path</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     __ bind(L_skip_barrier);</span>
<span class="udiff-line-added">+     c2i_no_clinit_check_entry = __ pc();</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   BarrierSetAssembler* bs = BarrierSet::barrier_set()-&gt;barrier_set_assembler();</span>
<span class="udiff-line-added">+   bs-&gt;c2i_entry_barrier(masm);</span>
<span class="udiff-line-added">+ </span>
    gen_c2i_adapter(masm, total_args_passed, comp_args_on_stack, sig_bt, regs, skip_fixup);
  
    __ flush();
<span class="udiff-line-modified-removed">-   return AdapterHandlerLibrary::new_entry(fingerprint, i2c_entry, c2i_entry, c2i_unverified_entry);</span>
<span class="udiff-line-modified-added">+   return AdapterHandlerLibrary::new_entry(fingerprint, i2c_entry, c2i_entry, c2i_unverified_entry, c2i_no_clinit_check_entry);</span>
  }
  
  int SharedRuntime::c_calling_convention(const BasicType *sig_bt,
                                           VMRegPair *regs,
                                           VMRegPair *regs2,
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1787,12 +1815,11 @@</span>
                              const BasicType* sig_bt,
                              const VMRegPair* regs) {
    Register temp_reg = rbx;  // not part of any compiled calling seq
    if (VerifyOops) {
      for (int i = 0; i &lt; method-&gt;size_of_parameters(); i++) {
<span class="udiff-line-modified-removed">-       if (sig_bt[i] == T_OBJECT ||</span>
<span class="udiff-line-removed">-           sig_bt[i] == T_ARRAY) {</span>
<span class="udiff-line-modified-added">+       if (is_reference_type(sig_bt[i])) {</span>
          VMReg r = regs[i].first();
          assert(r-&gt;is_valid(), &quot;bad oop arg&quot;);
          if (r-&gt;is_stack()) {
            __ movptr(temp_reg, Address(rsp, r-&gt;reg2stack() * VMRegImpl::stack_slot_size + wordSize));
            __ verify_oop(temp_reg);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1895,11 +1922,12 @@</span>
  nmethod* SharedRuntime::generate_native_wrapper(MacroAssembler* masm,
                                                  const methodHandle&amp; method,
                                                  int compile_id,
                                                  BasicType* in_sig_bt,
                                                  VMRegPair* in_regs,
<span class="udiff-line-modified-removed">-                                                 BasicType ret_type) {</span>
<span class="udiff-line-modified-added">+                                                 BasicType ret_type,</span>
<span class="udiff-line-added">+                                                 address critical_entry) {</span>
    if (method-&gt;is_method_handle_intrinsic()) {
      vmIntrinsics::ID iid = method-&gt;intrinsic_id();
      intptr_t start = (intptr_t)__ pc();
      int vep_offset = ((intptr_t)__ pc()) - start;
      gen_special_dispatch(masm,
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1918,11 +1946,11 @@</span>
                                         in_ByteSize(-1),
                                         in_ByteSize(-1),
                                         (OopMapSet*)NULL);
    }
    bool is_critical_native = true;
<span class="udiff-line-modified-removed">-   address native_func = method-&gt;critical_native_function();</span>
<span class="udiff-line-modified-added">+   address native_func = critical_entry;</span>
    if (native_func == NULL) {
      native_func = method-&gt;native_function();
      is_critical_native = false;
    }
    assert(native_func != NULL, &quot;must have function&quot;);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1965,40 +1993,27 @@</span>
  
      for (int i = 0; i &lt; total_in_args ; i++ ) {
        out_sig_bt[argc++] = in_sig_bt[i];
      }
    } else {
<span class="udiff-line-removed">-     Thread* THREAD = Thread::current();</span>
      in_elem_bt = NEW_RESOURCE_ARRAY(BasicType, total_in_args);
      SignatureStream ss(method-&gt;signature());
      for (int i = 0; i &lt; total_in_args ; i++ ) {
        if (in_sig_bt[i] == T_ARRAY) {
          // Arrays are passed as int, elem* pair
          out_sig_bt[argc++] = T_INT;
          out_sig_bt[argc++] = T_ADDRESS;
<span class="udiff-line-modified-removed">-         Symbol* atype = ss.as_symbol(CHECK_NULL);</span>
<span class="udiff-line-modified-removed">-         const char* at = atype-&gt;as_C_string();</span>
<span class="udiff-line-modified-removed">-         if (strlen(at) == 2) {</span>
<span class="udiff-line-removed">-           assert(at[0] == &#39;[&#39;, &quot;must be&quot;);</span>
<span class="udiff-line-removed">-           switch (at[1]) {</span>
<span class="udiff-line-removed">-             case &#39;B&#39;: in_elem_bt[i]  = T_BYTE; break;</span>
<span class="udiff-line-removed">-             case &#39;C&#39;: in_elem_bt[i]  = T_CHAR; break;</span>
<span class="udiff-line-removed">-             case &#39;D&#39;: in_elem_bt[i]  = T_DOUBLE; break;</span>
<span class="udiff-line-removed">-             case &#39;F&#39;: in_elem_bt[i]  = T_FLOAT; break;</span>
<span class="udiff-line-removed">-             case &#39;I&#39;: in_elem_bt[i]  = T_INT; break;</span>
<span class="udiff-line-removed">-             case &#39;J&#39;: in_elem_bt[i]  = T_LONG; break;</span>
<span class="udiff-line-removed">-             case &#39;S&#39;: in_elem_bt[i]  = T_SHORT; break;</span>
<span class="udiff-line-removed">-             case &#39;Z&#39;: in_elem_bt[i]  = T_BOOLEAN; break;</span>
<span class="udiff-line-removed">-             default: ShouldNotReachHere();</span>
<span class="udiff-line-removed">-           }</span>
<span class="udiff-line-removed">-         }</span>
<span class="udiff-line-modified-added">+         ss.skip_array_prefix(1);  // skip one &#39;[&#39;</span>
<span class="udiff-line-modified-added">+         assert(ss.is_primitive(), &quot;primitive type expected&quot;);</span>
<span class="udiff-line-modified-added">+         in_elem_bt[i] = ss.type();</span>
        } else {
          out_sig_bt[argc++] = in_sig_bt[i];
          in_elem_bt[i] = T_VOID;
        }
        if (in_sig_bt[i] != T_VOID) {
<span class="udiff-line-modified-removed">-         assert(in_sig_bt[i] == ss.type(), &quot;must match&quot;);</span>
<span class="udiff-line-modified-added">+         assert(in_sig_bt[i] == ss.type() ||</span>
<span class="udiff-line-added">+                in_sig_bt[i] == T_ARRAY, &quot;must match&quot;);</span>
          ss.next();
        }
      }
    }
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2135,10 +2150,21 @@</span>
  
    __ bind(hit);
  
    int vep_offset = ((intptr_t)__ pc()) - start;
  
<span class="udiff-line-added">+   if (VM_Version::supports_fast_class_init_checks() &amp;&amp; method-&gt;needs_clinit_barrier()) {</span>
<span class="udiff-line-added">+     Label L_skip_barrier;</span>
<span class="udiff-line-added">+     Register klass = r10;</span>
<span class="udiff-line-added">+     __ mov_metadata(klass, method-&gt;method_holder()); // InstanceKlass*</span>
<span class="udiff-line-added">+     __ clinit_barrier(klass, r15_thread, &amp;L_skip_barrier /*L_fast_path*/);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     __ jump(RuntimeAddress(SharedRuntime::get_handle_wrong_method_stub())); // slow path</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     __ bind(L_skip_barrier);</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+ </span>
  #ifdef COMPILER1
    // For Object.hashCode, System.identityHashCode try to pull hashCode from object header if available.
    if ((InlineObjectHash &amp;&amp; method-&gt;intrinsic_id() == vmIntrinsics::_hashCode) || (method-&gt;intrinsic_id() == vmIntrinsics::_identityHashCode)) {
      inline_check_hashcode_from_object_header(masm, method, j_rarg0 /*obj_reg*/, rax /*result*/);
    }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2710,11 +2736,11 @@</span>
    }
  
    __ reset_last_Java_frame(false);
  
    // Unbox oop result, e.g. JNIHandles::resolve value.
<span class="udiff-line-modified-removed">-   if (ret_type == T_OBJECT || ret_type == T_ARRAY) {</span>
<span class="udiff-line-modified-added">+   if (is_reference_type(ret_type)) {</span>
      __ resolve_jobject(rax /* value */,
                         r15_thread /* thread */,
                         rcx /* tmp */);
    }
  
</pre>
<center><a href="interp_masm_x86.cpp.udiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="templateTable_x86.cpp.udiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old test/jdk/tools/pack200/pack200-verifier/src/sun/tools/pack/verify/Globals.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2010, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 /*
 25  * A collection of useful global utilities commonly used.
 26  */
 27 package sun.tools.pack.verify;
 28 
 29 import java.io.*;
 30 import java.util.*;
 31 
 32 /*
 33  * @author ksrini
 34  */
 35 
 36 class Globals {
 37 
 38     private static int errors = 0;
 39     private static PrintWriter _pw = null;
 40     private static String _logFileName = null;
 41     private static final String DEFAULT_LOG_FILE = &quot;verifier.log&quot;;
 42     private static boolean _verbose = true;
 43     private static boolean _ignoreJarDirectories = false;
 44     private static boolean _checkJarClassOrdering = true;
 45     private static boolean _bitWiseClassCompare = false;
 46     // Ignore Deprecated, SourceFile and Synthetic
 47     private static boolean _ignoreCompileAttributes = false;
 48     // Ignore Debug Attributes LocalVariableTable, LocalVariableType,LineNumberTable
 49     private static boolean _ignoreDebugAttributes = false;
 50     private static boolean _ignoreUnknownAttributes = false;
 51     private static boolean _validateClass = true;
 52     private static Globals _instance = null;
 53 
 54     static Globals getInstance() {
 55         if (_instance == null) {
 56             _instance = new Globals();
 57             _verbose = (System.getProperty(&quot;sun.tools.pack.verify.verbose&quot;) == null)
 58                     ? false : true;
 59             _ignoreJarDirectories = (System.getProperty(&quot;ignoreJarDirectories&quot;) == null)
 60                     ? false : true;
 61         }
 62         return _instance;
 63     }
 64 
 65     static boolean ignoreCompileAttributes() {
 66         return _ignoreCompileAttributes;
 67     }
 68 
 69     static boolean ignoreDebugAttributes() {
 70         return _ignoreDebugAttributes;
 71     }
 72 
 73     static boolean ignoreUnknownAttributes() {
 74         return _ignoreUnknownAttributes;
 75     }
 76 
 77     static boolean ignoreJarDirectories() {
 78         return _ignoreJarDirectories;
 79     }
 80 
 81     static boolean validateClass() {
 82         return _validateClass;
 83     }
 84 
 85     static void setCheckJarClassOrdering(boolean flag) {
 86         _checkJarClassOrdering = flag;
 87     }
 88 
 89     static boolean checkJarClassOrdering() {
 90         return _checkJarClassOrdering;
 91     }
 92 
 93     static boolean bitWiseClassCompare() {
 94         return _bitWiseClassCompare;
 95     }
 96 
 97     static boolean setBitWiseClassCompare(boolean flag) {
 98         return _bitWiseClassCompare = flag;
 99     }
100 
101     public static boolean setIgnoreCompileAttributes(boolean flag) {
102         return _ignoreCompileAttributes = flag;
103     }
104 
105     static boolean setIgnoreDebugAttributes(boolean flag) {
106         return _ignoreDebugAttributes = flag;
107     }
108 
109     static boolean setIgnoreUnknownAttributes(boolean flag) {
110         return _ignoreUnknownAttributes = flag;
111     }
112 
113     static boolean setValidateClass(boolean flag) {
114         return _validateClass = flag;
115     }
116 
117     static int getErrors() {
118         return errors;
119     }
120 
121     static void trace(String s) {
122         if (_verbose) {
123             println(s);
124         }
125     }
126 
127     static void print(String s) {
128         _pw.print(s);
129     }
130 
131     static void println(String s) {
132         _pw.println(s);
133     }
134 
135     static void log(String s) {
136         errors++;
137         _pw.println(&quot;ERROR:&quot; + s);
138     }
139 
140     static void lognoln(String s) {
141         errors++;
142         _pw.print(s);
143     }
144 
145     private static PrintWriter openFile(String fileName) {
146         //Lets create the directory if it does not exist.
147         File f = new File(fileName);
148         File baseDir = f.getParentFile();
149         if (baseDir != null &amp;&amp; baseDir.exists() == false) {
150             baseDir.mkdirs();
151         }
152         try {
153             return new PrintWriter(new FileWriter(f), true);
154         } catch (Exception e) {
155             throw new RuntimeException(e);
156         }
157     }
158 
159     private static void closeFile() {
160         _pw.flush();
161         _pw.close();
162     }
163 
164     static void printPropsToLog() {
165         println(&quot;Log started &quot; + new Date(System.currentTimeMillis()));
166         print(System.getProperty(&quot;java.vm.version&quot;));
167         println(&quot;\t&quot; + System.getProperty(&quot;java.vm.name&quot;));
168 
169         println(&quot;System properties&quot;);
170         println(&quot;\tjava.home=&quot; + System.getProperty(&quot;java.home&quot;));
171         println(&quot;\tjava.class.version=&quot; + System.getProperty(&quot;java.class.version&quot;));
172         println(&quot;\tjava.class.path=&quot; + System.getProperty(&quot;java.class.path&quot;));
173         println(&quot;\tos.name=&quot; + System.getProperty(&quot;os.name&quot;));
174         println(&quot;\tos.arch=&quot; + System.getProperty(&quot;os.arch&quot;));
175         println(&quot;\tos.version=&quot; + System.getProperty(&quot;os.version&quot;));
176         println(&quot;\tuser.name=&quot; + System.getProperty(&quot;user.name&quot;));
177         println(&quot;\tuser.home=&quot; + System.getProperty(&quot;user.home&quot;));
178         println(&quot;\tuser.dir=&quot; + System.getProperty(&quot;user.dir&quot;));
179         println(&quot;\tLocale.getDefault=&quot; + Locale.getDefault());
180         println(&quot;System properties end&quot;);
181     }
182 
183     static void openLog(String s) {
184         _logFileName = (s != null) ? s : &quot;.&quot; + File.separator + DEFAULT_LOG_FILE;
185         _logFileName = (new File(_logFileName).isDirectory())
186                 ? _logFileName + File.separator + DEFAULT_LOG_FILE : _logFileName;
187         _pw = openFile(_logFileName);
188         printPropsToLog();
189     }
190 
191     static void closeLog() {
192         closeFile();
193     }
194 
195     static String getLogFileName() {
196         return _logFileName;
197     }
198 
199     static void diffCharData(String s1, String s2) {
200         boolean diff = false;
201         char[] c1 = s1.toCharArray();
202         char[] c2 = s2.toCharArray();
203         if (c1.length != c2.length) {
204             diff = true;
205             Globals.log(&quot;Length differs: &quot; + (c1.length - c2.length));
206         }
207         // Take the smaller of the two arrays to prevent Array...Exception
208         int minlen = (c1.length &lt; c2.length) ? c1.length : c2.length;
209         for (int i = 0; i &lt; c1.length; i++) {
210             if (c1[i] != c2[i]) {
211                 diff = true;
212                 Globals.lognoln(&quot;\t idx[&quot; + i + &quot;] 0x&quot; + Integer.toHexString(c1[i]) + &quot;&lt;&gt;&quot; + &quot;0x&quot; + Integer.toHexString(c2[i]));
213                 Globals.log(&quot; -&gt; &quot; + c1[i] + &quot;&lt;&gt;&quot; + c2[i]);
214             }
215         }
216     }
217 
218     static void diffByteData(String s1, String s2) {
219         boolean diff = false;
220         byte[] b1 = s1.getBytes();
221         byte[] b2 = s2.getBytes();
222 
223         if (b1.length != b2.length) {
224             diff = true;
225             //(+) b1 is greater, (-) b2 is greater
226             Globals.log(&quot;Length differs diff: &quot; + (b1.length - b2.length));
227         }
228         // Take the smaller of the two array to prevent Array...Exception
229         int minlen = (b1.length &lt; b2.length) ? b1.length : b2.length;
230         for (int i = 0; i &lt; b1.length; i++) {
231             if (b1[i] != b2[i]) {
232                 diff = true;
233                 Globals.log(&quot;\t&quot; + &quot;idx[&quot; + i + &quot;] 0x&quot; + Integer.toHexString(b1[i]) + &quot;&lt;&gt;&quot; + &quot;0x&quot; + Integer.toHexString(b2[i]));
234             }
235         }
236     }
237 
238     static void dumpToHex(String s) {
239         try {
240             dumpToHex(s.getBytes(&quot;UTF-8&quot;));
241         } catch (UnsupportedEncodingException uce) {
242             throw new RuntimeException(uce);
243         }
244     }
245 
246     static void dumpToHex(byte[] buffer) {
247         int linecount = 0;
248         byte[] b = new byte[16];
249         for (int i = 0; i &lt; buffer.length; i += 16) {
250             if (buffer.length - i &gt; 16) {
251                 System.arraycopy(buffer, i, b, 0, 16);
252                 print16Bytes(b, linecount);
253                 linecount += 16;
254             } else {
255                 System.arraycopy(buffer, i, b, 0, buffer.length - i);
256                 for (int n = buffer.length - (i + 1); n &lt; 16; n++) {
257                     b[n] = 0;
258                 }
259                 print16Bytes(b, linecount);
260                 linecount += 16;
261             }
262         }
263         Globals.log(&quot;-----------------------------------------------------------------&quot;);
264     }
265 
266     static void print16Bytes(byte[] buffer, int linecount) {
267         final int MAX = 4;
268         Globals.lognoln(paddedHexString(linecount, 4) + &quot; &quot;);
269 
270         for (int i = 0; i &lt; buffer.length; i += 2) {
271             int iOut = pack2Bytes2Int(buffer[i], buffer[i + 1]);
272             Globals.lognoln(paddedHexString(iOut, 4) + &quot; &quot;);
273         }
274 
275         Globals.lognoln(&quot;| &quot;);
276 
277         StringBuilder sb = new StringBuilder(new String(buffer));
278 
279         for (int i = 0; i &lt; buffer.length; i++) {
280             if (Character.isISOControl(sb.charAt(i))) {
281                 sb.setCharAt(i, &#39;.&#39;);
282             }
283         }
284         Globals.log(sb.toString());
285     }
286 
287     static int pack2Bytes2Int(byte b1, byte b2) {
288         int out = 0x0;
289         out += b1;
290         out &lt;&lt;= 8;
291         out &amp;= 0x0000ffff;
292         out |= 0x000000ff &amp; b2;
293         return out;
294     }
295 
296     static String paddedHexString(int n, int max) {
297         char[] c = Integer.toHexString(n).toCharArray();
298         char[] out = new char[max];
299 
300         for (int i = 0; i &lt; max; i++) {
301             out[i] = &#39;0&#39;;
302         }
303         int offset = (max - c.length &lt; 0) ? 0 : max - c.length;
304         for (int i = 0; i &lt; c.length; i++) {
305             out[offset + i] = c[i];
306         }
307         return new String(out);
308     }
309 }
    </pre>
  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old test/jdk/tools/pack200/pack200-verifier/src/xmlkit/ClassReader.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 2010, 2018, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  */
  23 package xmlkit; // -*- mode: java; indent-tabs-mode: nil -*-
  24 
  25 import com.sun.tools.classfile.AccessFlags;
  26 import com.sun.tools.classfile.Annotation;
  27 import com.sun.tools.classfile.Annotation.Annotation_element_value;
  28 import com.sun.tools.classfile.Annotation.Array_element_value;
  29 import com.sun.tools.classfile.Annotation.Class_element_value;
  30 import com.sun.tools.classfile.Annotation.Enum_element_value;
  31 import com.sun.tools.classfile.Annotation.Primitive_element_value;
  32 import com.sun.tools.classfile.AnnotationDefault_attribute;
  33 import com.sun.tools.classfile.Attribute;
  34 import com.sun.tools.classfile.Attributes;
  35 import com.sun.tools.classfile.BootstrapMethods_attribute;
  36 import com.sun.tools.classfile.CharacterRangeTable_attribute;
  37 import com.sun.tools.classfile.ClassFile;
  38 import com.sun.tools.classfile.Code_attribute;
  39 import com.sun.tools.classfile.CompilationID_attribute;
  40 import com.sun.tools.classfile.ConstantPool;
  41 import com.sun.tools.classfile.ConstantPool.CONSTANT_Class_info;
  42 import com.sun.tools.classfile.ConstantPool.CONSTANT_Module_info;
  43 import com.sun.tools.classfile.ConstantPool.CONSTANT_Package_info;
  44 import com.sun.tools.classfile.ConstantPool.CONSTANT_Double_info;
  45 import com.sun.tools.classfile.ConstantPool.CONSTANT_Fieldref_info;
  46 import com.sun.tools.classfile.ConstantPool.CONSTANT_Float_info;
  47 import com.sun.tools.classfile.ConstantPool.CONSTANT_Integer_info;
  48 import com.sun.tools.classfile.ConstantPool.CONSTANT_InterfaceMethodref_info;
  49 import com.sun.tools.classfile.ConstantPool.CONSTANT_InvokeDynamic_info;
  50 import com.sun.tools.classfile.ConstantPool.CONSTANT_Long_info;
  51 import com.sun.tools.classfile.ConstantPool.CONSTANT_MethodHandle_info;
  52 import com.sun.tools.classfile.ConstantPool.CONSTANT_MethodType_info;
  53 import com.sun.tools.classfile.ConstantPool.CONSTANT_Methodref_info;
  54 import com.sun.tools.classfile.ConstantPool.CONSTANT_NameAndType_info;
  55 import com.sun.tools.classfile.ConstantPool.CONSTANT_String_info;
  56 import com.sun.tools.classfile.ConstantPool.CONSTANT_Utf8_info;
  57 import com.sun.tools.classfile.ConstantPool.CPInfo;
  58 import com.sun.tools.classfile.ConstantPool.InvalidIndex;
  59 import com.sun.tools.classfile.ConstantPoolException;
  60 import com.sun.tools.classfile.ConstantValue_attribute;
  61 import com.sun.tools.classfile.DefaultAttribute;
  62 import com.sun.tools.classfile.Deprecated_attribute;
  63 import com.sun.tools.classfile.Descriptor.InvalidDescriptor;
  64 import com.sun.tools.classfile.EnclosingMethod_attribute;
  65 import com.sun.tools.classfile.Exceptions_attribute;
  66 import com.sun.tools.classfile.Field;
  67 import com.sun.tools.classfile.InnerClasses_attribute;
  68 import com.sun.tools.classfile.InnerClasses_attribute.Info;
  69 import com.sun.tools.classfile.Instruction;
  70 import com.sun.tools.classfile.Instruction.TypeKind;
  71 import com.sun.tools.classfile.LineNumberTable_attribute;
  72 import com.sun.tools.classfile.LocalVariableTable_attribute;
  73 import com.sun.tools.classfile.LocalVariableTypeTable_attribute;
  74 import com.sun.tools.classfile.Method;
  75 import com.sun.tools.classfile.MethodParameters_attribute;
  76 import com.sun.tools.classfile.Module_attribute;
  77 import com.sun.tools.classfile.Module_attribute.ExportsEntry;
  78 import com.sun.tools.classfile.Module_attribute.ProvidesEntry;
  79 import com.sun.tools.classfile.Module_attribute.RequiresEntry;
  80 import com.sun.tools.classfile.ModuleHashes_attribute;
  81 import com.sun.tools.classfile.ModuleHashes_attribute.Entry;
  82 import com.sun.tools.classfile.ModuleMainClass_attribute;
  83 import com.sun.tools.classfile.ModuleResolution_attribute;
  84 import com.sun.tools.classfile.ModuleTarget_attribute;
  85 import com.sun.tools.classfile.ModulePackages_attribute;
  86 import com.sun.tools.classfile.NestHost_attribute;
  87 import com.sun.tools.classfile.NestMembers_attribute;
  88 import com.sun.tools.classfile.Opcode;
  89 import com.sun.tools.classfile.RuntimeInvisibleAnnotations_attribute;
  90 import com.sun.tools.classfile.RuntimeInvisibleParameterAnnotations_attribute;
  91 import com.sun.tools.classfile.RuntimeInvisibleTypeAnnotations_attribute;
  92 import com.sun.tools.classfile.RuntimeVisibleAnnotations_attribute;
  93 import com.sun.tools.classfile.RuntimeVisibleParameterAnnotations_attribute;
  94 import com.sun.tools.classfile.RuntimeVisibleTypeAnnotations_attribute;
  95 import com.sun.tools.classfile.Signature_attribute;
  96 import com.sun.tools.classfile.SourceDebugExtension_attribute;
  97 import com.sun.tools.classfile.SourceFile_attribute;
  98 import com.sun.tools.classfile.SourceID_attribute;
  99 import com.sun.tools.classfile.StackMapTable_attribute;
 100 import com.sun.tools.classfile.StackMapTable_attribute.append_frame;
 101 import com.sun.tools.classfile.StackMapTable_attribute.chop_frame;
 102 import com.sun.tools.classfile.StackMapTable_attribute.full_frame;
 103 import com.sun.tools.classfile.StackMapTable_attribute.same_frame;
 104 import com.sun.tools.classfile.StackMapTable_attribute.same_frame_extended;
 105 import com.sun.tools.classfile.StackMapTable_attribute.same_locals_1_stack_item_frame;
 106 import com.sun.tools.classfile.StackMapTable_attribute.same_locals_1_stack_item_frame_extended;
 107 import com.sun.tools.classfile.StackMap_attribute;
 108 import com.sun.tools.classfile.Synthetic_attribute;
 109 import com.sun.tools.classfile.TypeAnnotation;
 110 import com.sun.tools.classfile.TypeAnnotation.Position;
 111 import static com.sun.tools.classfile.TypeAnnotation.TargetType.THROWS;
 112 import java.io.*;
 113 import java.util.*;
 114 import java.util.jar.JarEntry;
 115 import java.util.jar.JarFile;
 116 import xmlkit.XMLKit.Element;
 117 
 118 /*
 119  * @author jrose, ksrini
 120  */
 121 public class ClassReader {
 122 
 123     private static final CommandLineParser CLP = new CommandLineParser(&quot;&quot;
 124             + &quot;-source:     +&gt; = \n&quot;
 125             + &quot;-dest:       +&gt; = \n&quot;
 126             + &quot;-encoding:   +&gt; = \n&quot;
 127             + &quot;-jcov           $ \n   -nojcov         !-jcov        \n&quot;
 128             + &quot;-verbose        $ \n   -noverbose      !-verbose     \n&quot;
 129             + &quot;-keepPath       $ \n   -nokeepPath     !-keepPath    \n&quot;
 130             + &quot;-keepCP         $ \n   -nokeepCP       !-keepCP      \n&quot;
 131             + &quot;-keepOrder      $ \n   -nokeepOrder    !-keepOrder   \n&quot;
 132             + &quot;-continue       $ \n   -nocontinue     !-continue    \n&quot;
 133             + &quot;-@         &gt;-@  . \n&quot;
 134             + &quot;-              +? \n&quot;
 135             + &quot;\n&quot;);
 136 
 137 
 138     // Protected state for representing the class file.
 139     protected Element cfile;          // &lt;ClassFile ...&gt;
 140     protected Element cpool;          // &lt;ConstantPool ...&gt;
 141     protected Element klass;          // &lt;Class ...&gt;
 142     protected List&lt;String&gt; thePool;    // stringified flattened Constant Pool
 143 
 144     public static void main(String[] ava) throws IOException {
 145         ArrayList&lt;String&gt; av = new ArrayList&lt;&gt;(Arrays.asList(ava));
 146         HashMap&lt;String, String&gt; props = new HashMap&lt;&gt;();
 147         props.put(&quot;-encoding:&quot;, &quot;UTF8&quot;);  // default
 148         props.put(&quot;-keepOrder&quot;, null);    // CLI default
 149         props.put(&quot;-pretty&quot;, &quot;1&quot;);     // CLI default
 150         props.put(&quot;-continue&quot;, &quot;1&quot;);     // CLI default
 151         CLP.parse(av, props);
 152         //System.out.println(props+&quot; ++ &quot;+av);
 153         File source = asFile(props.get(&quot;-source:&quot;));
 154         File dest = asFile(props.get(&quot;-dest:&quot;));
 155         String encoding = props.get(&quot;-encoding:&quot;);
 156         boolean contError = props.containsKey(&quot;-continue&quot;);
 157         ClassReader options = new ClassReader();
 158         options.copyOptionsFrom(props);
 159         /*
 160         if (dest == null &amp;&amp; av.size() &gt; 1) {
 161         dest = File.createTempFile(&quot;TestOut&quot;, &quot;.dir&quot;, new File(&quot;.&quot;));
 162         dest.delete();
 163         if (!dest.mkdir())
 164         throw new RuntimeException(&quot;Cannot create &quot;+dest);
 165         System.out.println(&quot;Writing results to &quot;+dest);
 166         }
 167          */
 168         if (av.isEmpty()) {
 169             av.add(&quot;&quot;);  //to enter this loop
 170         }
 171         boolean readList = false;
 172         for (String a : av) {
 173             if (readList) {
 174                 readList = false;
 175                 InputStream fin;
 176                 if (a.equals(&quot;-&quot;)) {
 177                     fin = System.in;
 178                 } else {
 179                     fin = new FileInputStream(a);
 180                 }
 181 
 182                 BufferedReader files = makeReader(fin, encoding);
 183                 for (String file; (file = files.readLine()) != null;) {
 184                     doFile(file, source, dest, options, encoding, contError);
 185                 }
 186                 if (fin != System.in) {
 187                     fin.close();
 188                 }
 189             } else if (a.equals(&quot;-@&quot;)) {
 190                 readList = true;
 191             } else if (a.startsWith(&quot;-&quot;)) {
 192                 throw new RuntimeException(&quot;Bad flag argument: &quot; + a);
 193             } else if (source.getName().endsWith(&quot;.jar&quot;)) {
 194                 doJar(a, source, dest, options, encoding, contError);
 195             } else {
 196                 doFile(a, source, dest, options, encoding, contError);
 197             }
 198         }
 199     }
 200 
 201     private static File asFile(String str) {
 202         return (str == null) ? null : new File(str);
 203     }
 204 
 205     private static void doFile(String a,
 206             File source, File dest,
 207             ClassReader options, String encoding,
 208             boolean contError) throws IOException  {
 209         if (!contError) {
 210             doFile(a, source, dest, options, encoding);
 211         } else {
 212             try {
 213                 doFile(a, source, dest, options, encoding);
 214             } catch (Exception ee) {
 215                 System.out.println(&quot;Error processing &quot; + source + &quot;: &quot; + ee);
 216                 ee.printStackTrace();
 217             }
 218         }
 219     }
 220 
 221     private static void doJar(String a, File source, File dest,
 222                               ClassReader options, String encoding,
 223                               Boolean contError) throws IOException {
 224         try {
 225             JarFile jf = new JarFile(source);
 226             for (JarEntry je : Collections.list(jf.entries())) {
 227                 String name = je.getName();
 228                 if (!name.endsWith(&quot;.class&quot;)) {
 229                     continue;
 230                 }
 231                 try {
 232                     doStream(name, jf.getInputStream(je), dest, options, encoding);
 233                 } catch (Exception e) {
 234                     if (contError) {
 235                         System.out.println(&quot;Error processing &quot; + source + &quot;: &quot; + e);
 236                         e.printStackTrace();
 237                         continue;
 238                     }
 239                 }
 240             }
 241         } catch (IOException ioe) {
 242             throw ioe;
 243         }
 244     }
 245 
 246     private static void doStream(String a, InputStream in, File dest,
 247                                  ClassReader options, String encoding) throws IOException {
 248 
 249         File f = new File(a);
 250         ClassReader cr = new ClassReader(options);
 251         Element e;
 252         if (options.verbose) {
 253             System.out.println(&quot;Reading &quot; + f);
 254         }
 255         e = cr.readFrom(in);
 256 
 257         OutputStream out;
 258         if (dest == null) {
 259             out = System.out;
 260         } else {
 261             File outf = new File(dest, f.isAbsolute() ? f.getName() : f.getPath());
 262             String outName = outf.getName();
 263             File outSubdir = outf.getParentFile();
 264             outSubdir.mkdirs();
 265             int extPos = outName.lastIndexOf(&#39;.&#39;);
 266             if (extPos &gt; 0) {
 267                 outf = new File(outSubdir, outName.substring(0, extPos) + &quot;.xml&quot;);
 268             }
 269             out = new FileOutputStream(outf);
 270         }
 271 
 272         Writer outw = makeWriter(out, encoding);
 273         if (options.pretty || !options.keepOrder) {
 274             e.writePrettyTo(outw);
 275         } else {
 276             e.writeTo(outw);
 277         }
 278         if (out == System.out) {
 279             outw.write(&quot;\n&quot;);
 280             outw.flush();
 281         } else {
 282             outw.close();
 283         }
 284     }
 285 
 286     private static void doFile(String a,
 287             File source, File dest,
 288             ClassReader options, String encoding) throws IOException {
 289         File inf = new File(source, a);
 290         if (dest != null &amp;&amp; options.verbose) {
 291             System.out.println(&quot;Reading &quot; + inf);
 292         }
 293 
 294         BufferedInputStream in = new BufferedInputStream(new FileInputStream(inf));
 295 
 296         doStream(a, in, dest, options, encoding);
 297 
 298     }
 299 
 300     public static BufferedReader makeReader(InputStream in,
 301                                             String encoding) throws IOException {
 302         Reader inw;
 303         in = new BufferedInputStream(in);  // add buffering
 304         if (encoding == null) {
 305             inw = new InputStreamReader(in);
 306         } else {
 307             inw = new InputStreamReader(in, encoding);
 308         }
 309         return new BufferedReader(inw);  // add buffering
 310     }
 311 
 312     public static Writer makeWriter(OutputStream out,
 313                                     String encoding) throws IOException {
 314         Writer outw;
 315         if (encoding == null) {
 316             outw = new OutputStreamWriter(out);
 317         } else {
 318             outw = new OutputStreamWriter(out, encoding);
 319         }
 320         return new BufferedWriter(outw);  // add buffering
 321     }
 322 
 323     public Element result() {
 324         return cfile;
 325     }
 326 
 327     protected InputStream in;
 328     protected ByteArrayOutputStream buf = new ByteArrayOutputStream(1024);
 329     // input options
 330     public boolean pretty = false;
 331     public boolean verbose = false;
 332     public boolean keepPath = false;
 333     public boolean keepCP = false;
 334     public boolean keepBytes = false;
 335     public boolean parseBytes = true;
 336     public boolean resolveRefs = true;
 337     public boolean keepOrder = true;
 338     public boolean keepSizes = false;
 339 
 340     public ClassReader() {
 341         cfile = new Element(&quot;ClassFile&quot;);
 342     }
 343 
 344     public ClassReader(ClassReader options) {
 345         this();
 346         copyOptionsFrom(options);
 347     }
 348 
 349     public void copyOptionsFrom(ClassReader options) {
 350         pretty = options.pretty;
 351         verbose = options.verbose;
 352         keepPath = options.keepPath;
 353         keepCP = options.keepCP;
 354         keepOrder = options.keepOrder;
 355     }
 356 
 357     public void copyOptionsFrom(Map&lt;String, String&gt; options) {
 358         if (options.containsKey(&quot;-pretty&quot;)) {
 359             pretty = (options.get(&quot;-pretty&quot;) != null);
 360         }
 361         if (options.containsKey(&quot;-verbose&quot;)) {
 362             verbose = (options.get(&quot;-verbose&quot;) != null);
 363         }
 364         if (options.containsKey(&quot;-keepPath&quot;)) {
 365             keepPath = (options.get(&quot;-keepPath&quot;) != null);
 366         }
 367         if (options.containsKey(&quot;-keepCP&quot;)) {
 368             keepCP = (options.get(&quot;-keepCP&quot;) != null);
 369         }
 370         if (options.containsKey(&quot;-keepOrder&quot;)) {
 371             keepOrder = (options.get(&quot;-keepOrder&quot;) != null);
 372         }
 373     }
 374 
 375     protected String getCpString(int i) {
 376         return thePool.get(i);
 377     }
 378 
 379     public Element readFrom(InputStream in) throws IOException {
 380         try {
 381             this.in = in;
 382             ClassFile c = ClassFile.read(in);
 383             // read the file header
 384             if (c.magic != 0xCAFEBABE) {
 385                 throw new RuntimeException(&quot;bad magic number &quot; +
 386                         Integer.toHexString(c.magic));
 387             }
 388             cfile.setAttr(&quot;magic&quot;, &quot;&quot; + c.magic);
 389             int minver = c.minor_version;
 390             int majver = c.major_version;
 391             cfile.setAttr(&quot;minver&quot;, &quot;&quot; + minver);
 392             cfile.setAttr(&quot;majver&quot;, &quot;&quot; + majver);
 393             readCP(c);
 394             readClass(c);
 395             return result();
 396         } catch (InvalidDescriptor | ConstantPoolException ex) {
 397             throw new IOException(&quot;Fatal error&quot;, ex);
 398         }
 399     }
 400 
 401     public Element readFrom(File file) throws IOException {
 402         try (InputStream strm = new FileInputStream(file)) {
 403             Element e = readFrom(new BufferedInputStream(strm));
 404             if (keepPath) {
 405                 e.setAttr(&quot;path&quot;, file.toString());
 406             }
 407             return e;
 408         }
 409     }
 410 
 411     private void readClass(ClassFile c) throws IOException,
 412                                                ConstantPoolException,
 413                                                InvalidDescriptor {
 414         klass = new Element(&quot;Class&quot;);
 415         cfile.add(klass);
 416         String thisk = c.getName();
 417 
 418         klass.setAttr(&quot;name&quot;, thisk);
 419 
 420         AccessFlags af = new AccessFlags(c.access_flags.flags);
 421         klass.setAttr(&quot;flags&quot;, flagString(af, klass));
 422         if (!&quot;java/lang/Object&quot;.equals(thisk)) {
 423             if (c.super_class != 0) {
 424                 klass.setAttr(&quot;super&quot;, c.getSuperclassName());
 425             }
 426         }
 427         for (int i : c.interfaces) {
 428             klass.add(new Element(&quot;Interface&quot;, &quot;name&quot;, getCpString(i)));
 429         }
 430         readFields(c, klass);
 431         readMethods(c, klass);
 432         readAttributesFor(c, c.attributes, klass);
 433         klass.trimToSize();
 434     }
 435 
 436     private void readFields(ClassFile c, Element klass) throws IOException {
 437         int len = c.fields.length;
 438         Element fields = new Element(len);
 439         for (Field f : c.fields) {
 440             Element field = new Element(&quot;Field&quot;);
 441             field.setAttr(&quot;name&quot;, getCpString(f.name_index));
 442             field.setAttr(&quot;type&quot;, getCpString(f.descriptor.index));
 443             field.setAttr(&quot;flags&quot;, flagString(f.access_flags.flags, field));
 444             readAttributesFor(c, f.attributes, field);
 445 
 446             field.trimToSize();
 447             fields.add(field);
 448         }
 449         if (!keepOrder) {
 450             fields.sort();
 451         }
 452         klass.addAll(fields);
 453     }
 454 
 455 
 456     private void readMethods(ClassFile c, Element klass) throws IOException {
 457         int len = c.methods.length;
 458         Element methods = new Element(len);
 459         for (Method m : c.methods) {
 460             Element member = new Element(&quot;Method&quot;);
 461             member.setAttr(&quot;name&quot;, getCpString(m.name_index));
 462             member.setAttr(&quot;type&quot;, getCpString(m.descriptor.index));
 463             member.setAttr(&quot;flags&quot;, flagString(m.access_flags.flags, member));
 464             readAttributesFor(c, m.attributes, member);
 465 
 466             member.trimToSize();
 467             methods.add(member);
 468         }
 469         if (!keepOrder) {
 470             methods.sort();
 471         }
 472         klass.addAll(methods);
 473     }
 474 
 475     private AccessFlags.Kind getKind(Element e) {
 476         switch(e.getName()) {
 477             case &quot;Class&quot;:
 478                 return AccessFlags.Kind.Class;
 479             case &quot;InnerClass&quot;:
 480                 return AccessFlags.Kind.InnerClass;
 481             case &quot;Field&quot;:
 482                 return AccessFlags.Kind.Field ;
 483             case &quot;Method&quot;:
 484                 return AccessFlags.Kind.Method;
 485             default: throw new RuntimeException(&quot;should not reach here&quot;);
 486         }
 487     }
 488 
 489     protected String flagString(int flags, Element holder) {
 490         return flagString(new AccessFlags(flags), holder);
 491     }
 492     protected String flagString(AccessFlags af, Element holder) {
 493         return flagString(af, holder.getName());
 494     }
 495     protected String flagString(int flags, String kind) {
 496         return flagString(new AccessFlags(flags), kind);
 497     }
 498     protected String flagString(AccessFlags af, String kind) {
 499         Set&lt;String&gt; mods = null;
 500         switch (kind) {
 501             case &quot;Class&quot;:
 502                 mods = af.getClassFlags();
 503                 break;
 504             case &quot;InnerClass&quot;:
 505                 mods = af.getInnerClassFlags();
 506                 break;
 507             case &quot;Field&quot;:
 508                 mods = af.getFieldFlags();
 509                 break;
 510             case &quot;Method&quot;:
 511                 mods = af.getMethodFlags();
 512                 break;
 513             default:
 514                 throw new RuntimeException(&quot;should not reach here&quot;);
 515         }
 516         StringBuilder sb = new StringBuilder();
 517         for (String x : mods) {
 518             sb.append(x.substring(x.indexOf(&#39;_&#39;) + 1).toLowerCase()).append(&quot; &quot;);
 519         }
 520         return sb.toString().trim();
 521     }
 522 
 523 
 524     protected  void readAttributesFor(ClassFile c, Attributes attrs, Element x) {
 525         Element container = new Element();
 526         AttributeVisitor av = new AttributeVisitor(this, c);
 527         for (Attribute a : attrs) {
 528             av.visit(a, container);
 529         }
 530         if (!keepOrder) {
 531             container.sort();
 532         }
 533         x.addAll(container);
 534     }
 535 
 536     private int fileSize = 0;
 537     private HashMap&lt;String, int[]&gt; attrSizes = new HashMap&lt;&gt;();
 538 
 539     private void attachTo(Element x, Object aval0) {
 540         if (aval0 == null) {
 541             return;
 542         }
 543         if (!(aval0 instanceof Element)) {
 544             x.add(aval0);
 545             return;
 546         }
 547         Element aval = (Element) aval0;
 548         if (!aval.isAnonymous()) {
 549             x.add(aval);
 550             return;
 551         }
 552         for (int imax = aval.attrSize(), i = 0; i &lt; imax; i++) {
 553             //%%
 554             attachAttrTo(x, aval.getAttrName(i), aval.getAttr(i));
 555         }
 556         x.addAll(aval);
 557     }
 558 
 559     private void attachAttrTo(Element x, String aname, String aval) {
 560         String aval0 = x.getAttr(aname);
 561         if (aval0 != null) {
 562             aval = aval0 + &quot; &quot; + aval;
 563         }
 564         x.setAttr(aname, aval);
 565     }
 566 
 567     private void readCP(ClassFile c) throws IOException {
 568         cpool = new Element(&quot;ConstantPool&quot;, c.constant_pool.size());
 569         ConstantPoolVisitor cpv = new ConstantPoolVisitor(cpool, c,
 570                 c.constant_pool.size());
 571         for (int i = 1 ; i &lt; c.constant_pool.size() ; i++) {
 572             try {
 573                 cpv.visit(c.constant_pool.get(i), i);
 574             } catch (InvalidIndex ex) {
 575                 // can happen periodically when accessing doubles etc. ignore it
 576                 // ex.printStackTrace();
 577             }
 578         }
 579         thePool = cpv.getPoolList();
 580         if (verbose) {
 581             for (int i = 0; i &lt; thePool.size(); i++) {
 582                 System.out.println(&quot;[&quot; + i + &quot;]: &quot; + thePool.get(i));
 583             }
 584         }
 585         if (keepCP) {
 586             cfile.add(cpool);
 587         }
 588     }
 589 }
 590 
 591 class ConstantPoolVisitor implements ConstantPool.Visitor&lt;String, Integer&gt; {
 592     final List&lt;String&gt; slist;
 593     final Element xpool;
 594     final ClassFile cf;
 595     final ConstantPool cfpool;
 596     final List&lt;String&gt; bsmlist;
 597 
 598 
 599     public ConstantPoolVisitor(Element xpool, ClassFile cf, int size) {
 600         slist = new ArrayList&lt;&gt;(size);
 601         for (int i = 0 ; i &lt; size; i++) {
 602             slist.add(null);
 603         }
 604         this.xpool = xpool;
 605         this.cf = cf;
 606         this.cfpool = cf.constant_pool;
 607         bsmlist = readBSM();
 608     }
 609 
 610     public List&lt;String&gt; getPoolList() {
 611         return Collections.unmodifiableList(slist);
 612     }
 613 
 614     public List&lt;String&gt; getBSMList() {
 615         return Collections.unmodifiableList(bsmlist);
 616     }
 617 
 618     public String visit(CPInfo c, int index) {
 619         return c.accept(this, index);
 620     }
 621 
 622     private List&lt;String&gt; readBSM() {
 623         BootstrapMethods_attribute bsmAttr =
 624                 (BootstrapMethods_attribute) cf.getAttribute(Attribute.BootstrapMethods);
 625         if (bsmAttr != null) {
 626             List&lt;String&gt; out =
 627                     new ArrayList&lt;&gt;(bsmAttr.bootstrap_method_specifiers.length);
 628             for (BootstrapMethods_attribute.BootstrapMethodSpecifier bsms :
 629                     bsmAttr.bootstrap_method_specifiers) {
 630                 int index = bsms.bootstrap_method_ref;
 631                 try {
 632                     String value = slist.get(index);
 633                     String bsmStr = value;
 634                     if (value == null) {
 635                         value = visit(cfpool.get(index), index);
 636                         slist.set(index, value);
 637                     }
 638                     bsmStr = value;
 639                     for (int idx : bsms.bootstrap_arguments) {
 640                         value = slist.get(idx);
 641                         if (value == null) {
 642                             value = visit(cfpool.get(idx), idx);
 643                             slist.set(idx, value);
 644                         }
 645                         bsmStr = bsmStr.concat(&quot;,&quot; + value);
 646                     }
 647                     out.add(bsmStr);
 648                 } catch (InvalidIndex ex) {
 649                     ex.printStackTrace();
 650                 }
 651             }
 652             return out;
 653         }
 654         return new ArrayList&lt;&gt;(0);
 655     }
 656 
 657     @Override
 658     public String visitClass(CONSTANT_Class_info c, Integer p) {
 659         String value = slist.get(p);
 660         if (value == null) {
 661             try {
 662                 value = visit(cfpool.get(c.name_index), c.name_index);
 663                 slist.set(p, value);
 664                 xpool.add(new Element(&quot;CONSTANT_Class&quot;,
 665                         new String[]{&quot;id&quot;, p.toString()},
 666                         value));
 667             } catch (ConstantPoolException ex) {
 668                 ex.printStackTrace();
 669             }
 670         }
 671         return value;
 672     }
 673 
 674     @Override
 675     public String visitModule(CONSTANT_Module_info info, Integer p) {
 676         String value = slist.get(p);
 677         if (value == null) {
 678             try {
 679                 value = visit(cfpool.get(info.name_index), info.name_index);
 680                 slist.set(p, value);
 681                 xpool.add(new Element(&quot;CONSTANT_Module&quot;,
 682                         new String[]{&quot;id&quot;, p.toString()},
 683                         value));
 684             } catch (ConstantPoolException ex) {
 685                 ex.printStackTrace();
 686             }
 687         }
 688         return value;
 689     }
 690 
 691     @Override
 692     public String visitPackage(CONSTANT_Package_info info, Integer p) {
 693         String value = slist.get(p);
 694         if (value == null) {
 695             try {
 696                 value = visit(cfpool.get(info.name_index), info.name_index);
 697                 slist.set(p, value);
 698                 xpool.add(new Element(&quot;CONSTANT_Package&quot;,
 699                         new String[]{&quot;id&quot;, p.toString()},
 700                         value));
 701             } catch (ConstantPoolException ex) {
 702                 ex.printStackTrace();
 703             }
 704         }
 705         return value;
 706     }
 707 
 708     @Override
 709     public String visitDouble(CONSTANT_Double_info c, Integer p) {
 710         String value = slist.get(p);
 711         if (value == null) {
 712             value = Double.toString(c.value);
 713             slist.set(p, value);
 714             xpool.add(new Element(&quot;CONSTANT_Double&quot;,
 715                       new String[]{&quot;id&quot;, p.toString()},
 716                       value));
 717         }
 718         return value;
 719     }
 720 
 721     @Override
 722     public String visitFieldref(CONSTANT_Fieldref_info c, Integer p) {
 723     String value = slist.get(p);
 724         if (value == null) {
 725             try {
 726                 value = visit(cfpool.get(c.class_index), c.class_index);
 727                 value = value.concat(&quot; &quot; + visit(cfpool.get(c.name_and_type_index),
 728                                      c.name_and_type_index));
 729                 slist.set(p, value);
 730                 xpool.add(new Element(&quot;CONSTANT_Fieldref&quot;,
 731                           new String[]{&quot;id&quot;, p.toString()},
 732                           value));
 733             } catch (ConstantPoolException ex) {
 734                 ex.printStackTrace();
 735             }
 736         }
 737         return value;
 738     }
 739 
 740     @Override
 741     public String visitFloat(CONSTANT_Float_info c, Integer p) {
 742         String value = slist.get(p);
 743         if (value == null) {
 744             value = Float.toString(c.value);
 745             slist.set(p, value);
 746             xpool.add(new Element(&quot;CONSTANT_Float&quot;,
 747                       new String[]{&quot;id&quot;, p.toString()},
 748                       value));
 749         }
 750         return value;
 751     }
 752 
 753     @Override
 754     public String visitInteger(CONSTANT_Integer_info cnstnt, Integer p) {
 755         String value = slist.get(p);
 756         if (value == null) {
 757             value = Integer.toString(cnstnt.value);
 758             slist.set(p, value);
 759             xpool.add(new Element(&quot;CONSTANT_Integer&quot;,
 760                       new String[]{&quot;id&quot;, p.toString()},
 761                       value));
 762         }
 763         return value;
 764     }
 765 
 766     @Override
 767     public String visitInterfaceMethodref(CONSTANT_InterfaceMethodref_info c,
 768                                           Integer p) {
 769         String value = slist.get(p);
 770         if (value == null) {
 771             try {
 772                 value = visit(cfpool.get(c.class_index), c.class_index);
 773                 value = value.concat(&quot; &quot; +
 774                                      visit(cfpool.get(c.name_and_type_index),
 775                                      c.name_and_type_index));
 776                 slist.set(p, value);
 777                 xpool.add(new Element(&quot;CONSTANT_InterfaceMethodref&quot;,
 778                           new String[]{&quot;id&quot;, p.toString()},
 779                           value));
 780 
 781             } catch (ConstantPoolException ex) {
 782                 ex.printStackTrace();
 783             }
 784         }
 785         return value;
 786     }
 787 
 788     @Override
 789     public String visitInvokeDynamic(CONSTANT_InvokeDynamic_info c, Integer p) {
 790         String value = slist.get(p);
 791         if (value == null) {
 792             try {
 793                 value = bsmlist.get(c.bootstrap_method_attr_index) + &quot; &quot;
 794                         + visit(cfpool.get(c.name_and_type_index), c.name_and_type_index);
 795                 slist.set(p, value);
 796                 xpool.add(new Element(&quot;CONSTANT_InvokeDynamic&quot;,
 797                           new String[]{&quot;id&quot;, p.toString()},
 798                           value));
 799 
 800             } catch (ConstantPoolException ex) {
 801                 ex.printStackTrace();
 802             }
 803         }
 804         return value;
 805     }
 806 
 807     @Override
 808     public String visitDynamicConstant(ConstantPool.CONSTANT_Dynamic_info c, Integer p) {
 809         String value = slist.get(p);
 810         if (value == null) {
 811             try {
 812                 value = bsmlist.get(c.bootstrap_method_attr_index) + &quot; &quot;
 813                         + visit(cfpool.get(c.name_and_type_index), c.name_and_type_index);
 814                 slist.set(p, value);
 815                 xpool.add(new Element(&quot;CONSTANT_Dynamic&quot;,
 816                                       new String[]{&quot;id&quot;, p.toString()},
 817                                       value));
 818 
 819             } catch (ConstantPoolException ex) {
 820                 ex.printStackTrace();
 821             }
 822         }
 823         return value;
 824     }
 825 
 826     @Override
 827     public String visitLong(CONSTANT_Long_info c, Integer p) {
 828         String value = slist.get(p);
 829         if (value == null) {
 830             value = Long.toString(c.value);
 831             slist.set(p, value);
 832             xpool.add(new Element(&quot;CONSTANT_Long&quot;,
 833                       new String[]{&quot;id&quot;, p.toString()},
 834                       value));
 835         }
 836         return value;
 837     }
 838 
 839     @Override
 840     public String visitNameAndType(CONSTANT_NameAndType_info c, Integer p) {
 841         String value = slist.get(p);
 842         if (value == null) {
 843             try {
 844                 value = visit(cfpool.get(c.name_index), c.name_index);
 845                 value = value.concat(&quot; &quot; +
 846                         visit(cfpool.get(c.type_index), c.type_index));
 847                 slist.set(p, value);
 848                 xpool.add(new Element(&quot;CONSTANT_NameAndType&quot;,
 849                           new String[]{&quot;id&quot;, p.toString()},
 850                           value));
 851             } catch (InvalidIndex ex) {
 852                 ex.printStackTrace();
 853             }
 854         }
 855         return value;
 856     }
 857 
 858     @Override
 859     public String visitMethodref(CONSTANT_Methodref_info c, Integer p) {
 860         String value = slist.get(p);
 861         if (value == null) {
 862             try {
 863                 value = visit(cfpool.get(c.class_index), c.class_index);
 864                 value = value.concat(&quot; &quot; +
 865                                      visit(cfpool.get(c.name_and_type_index),
 866                                      c.name_and_type_index));
 867                 slist.set(p, value);
 868                 xpool.add(new Element(&quot;CONSTANT_Methodref&quot;,
 869                           new String[]{&quot;id&quot;, p.toString()},
 870                           value));
 871 
 872             } catch (ConstantPoolException ex) {
 873                 ex.printStackTrace();
 874             }
 875         }
 876         return value;
 877     }
 878 
 879     @Override
 880     public String visitMethodHandle(CONSTANT_MethodHandle_info c, Integer p) {
 881     String value = slist.get(p);
 882         if (value == null) {
 883             try {
 884                 value = c.reference_kind.name();
 885                 value = value.concat(&quot; &quot;
 886                         + visit(cfpool.get(c.reference_index), c.reference_index));
 887                 slist.set(p, value);
 888                 xpool.add(new Element(&quot;CONSTANT_MethodHandle&quot;,
 889                           new String[]{&quot;id&quot;, p.toString()},
 890                           value));
 891 
 892             } catch (ConstantPoolException ex) {
 893                 ex.printStackTrace();
 894             }
 895         }
 896         return value;
 897     }
 898 
 899     @Override
 900     public String visitMethodType(CONSTANT_MethodType_info c, Integer p) {
 901         String value = slist.get(p);
 902         if (value == null) {
 903             try {
 904                 value = visit(cfpool.get(c.descriptor_index), c.descriptor_index);
 905                 slist.set(p, value);
 906                 xpool.add(new Element(&quot;CONSTANT_MethodType&quot;,
 907                           new String[]{&quot;id&quot;, p.toString()},
 908                           value));
 909             } catch (ConstantPoolException ex) {
 910                 ex.printStackTrace();
 911             }
 912         }
 913         return value;
 914     }
 915 
 916     @Override
 917     public String visitString(CONSTANT_String_info c, Integer p) {
 918         try {
 919 
 920             String value = slist.get(p);
 921             if (value == null) {
 922                 value = c.getString();
 923                 slist.set(p, value);
 924                 xpool.add(new Element(&quot;CONSTANT_String&quot;,
 925                           new String[]{&quot;id&quot;, p.toString()},
 926                           value));
 927             }
 928             return value;
 929         } catch (ConstantPoolException ex) {
 930             throw new RuntimeException(&quot;Fatal error&quot;, ex);
 931         }
 932     }
 933 
 934     @Override
 935     public String  visitUtf8(CONSTANT_Utf8_info cnstnt, Integer p) {
 936         String value = slist.get(p);
 937         if (value == null) {
 938             value = cnstnt.value;
 939             slist.set(p, value);
 940             xpool.add(new Element(&quot;CONSTANT_Utf8&quot;,
 941                       new String[]{&quot;id&quot;, p.toString()},
 942                       value));
 943         }
 944         return value;
 945 
 946     }
 947 }
 948 
 949 class AttributeVisitor implements Attribute.Visitor&lt;Element, Element&gt; {
 950     final ClassFile cf;
 951     final ClassReader x;
 952     final AnnotationsElementVisitor aev;
 953     final InstructionVisitor iv;
 954 
 955     public AttributeVisitor(ClassReader x, ClassFile cf) {
 956         this.x = x;
 957         this.cf = cf;
 958         iv =  new InstructionVisitor(x, cf);
 959         aev = new AnnotationsElementVisitor(x, cf);
 960     }
 961 
 962     public void visit(Attribute a, Element parent) {
 963         a.accept(this, parent);
 964     }
 965 
 966     @Override
 967     public Element visitBootstrapMethods(BootstrapMethods_attribute bm, Element p) {
 968         Element e = new Element(x.getCpString(bm.attribute_name_index));
 969         for (BootstrapMethods_attribute.BootstrapMethodSpecifier bsm : bm.bootstrap_method_specifiers) {
 970             Element be = new Element(&quot;BootstrapMethodSpecifier&quot;);
 971             be.setAttr(&quot;ref&quot;, x.getCpString(bsm.bootstrap_method_ref));
 972             if (bsm.bootstrap_arguments.length &gt; 0) {
 973                 Element bme = new Element(&quot;MethodArguments&quot;);
 974                 for (int index : bsm.bootstrap_arguments) {
 975                     bme.add(x.getCpString(index));
 976                 }
 977                 bme.trimToSize();
 978                 be.add(bme);
 979             }
 980             be.trimToSize();
 981             e.add(be);
 982         }
 983         e.trimToSize();
 984         if (!x.keepOrder) {
 985             e.sort();
 986         }
 987         p.add(e);
 988         return null;
 989     }
 990 
 991     @Override
 992     public Element visitDefault(DefaultAttribute da, Element p) {
 993         Element e = new Element(x.getCpString(da.attribute_name_index));
 994         StringBuilder sb = new StringBuilder();
 995         for (byte x : da.info) {
 996             sb.append(&quot;0x&quot;).append(Integer.toHexString(x)).append(&quot; &quot;);
 997         }
 998         e.setAttr(&quot;bytes&quot;, sb.toString().trim());
 999         e.trimToSize();
1000         p.add(e);
1001         return null;
1002     }
1003 
1004     @Override
1005     public Element visitAnnotationDefault(AnnotationDefault_attribute ad, Element p) {
1006         Element e = new Element(x.getCpString(ad.attribute_name_index));
1007         e.setAttr(&quot;tag&quot;, &quot;&quot; + ad.default_value.tag);
1008         Element child = aev.visit(ad.default_value, e);
1009         if (child != null) {
1010             e.add(child);
1011         }
1012         e.trimToSize();
1013         p.add(e);
1014         return null;
1015     }
1016 
1017     @Override
1018     public Element visitCharacterRangeTable(CharacterRangeTable_attribute crt,
1019                                             Element p) {
1020         Element e = new Element(x.getCpString(crt.attribute_name_index));
1021         for (CharacterRangeTable_attribute.Entry ce : crt.character_range_table) {
1022             e.setAttr(&quot;start_pc&quot;, &quot;&quot; + ce.start_pc);
1023             e.setAttr(&quot;end_pc&quot;, &quot;&quot; + ce.end_pc);
1024             e.setAttr(&quot;range_start&quot;, &quot;&quot; + ce.character_range_start);
1025             e.setAttr(&quot;range_end&quot;, &quot;&quot; + ce.character_range_end);
1026             e.setAttr(&quot;flags&quot;, x.flagString(ce.flags, &quot;Method&quot;));
1027         }
1028         e.trimToSize();
1029         p.add(e);
1030         return null;
1031     }
1032 
1033     private Element instructions(Element code, Code_attribute c) {
1034         Element ielement = new Element(&quot;Instructions&quot;);
1035         for (Instruction ins : c.getInstructions()) {
1036             ielement.add(iv.visit(ins));
1037         }
1038         ielement.trimToSize();
1039         return ielement;
1040     }
1041 
1042     @Override
1043     public Element visitCode(Code_attribute c, Element p) {
1044         Element e = null;
1045 
1046         e = new Element(x.getCpString(c.attribute_name_index),
1047                 &quot;stack&quot;, &quot;&quot; + c.max_stack,
1048                 &quot;local&quot;, &quot;&quot; + c.max_locals);
1049 
1050         e.add(instructions(e, c));
1051 
1052         for (Code_attribute.Exception_data edata : c.exception_table) {
1053             e.add(new Element(&quot;Handler&quot;,
1054                     &quot;start&quot;, &quot;&quot; + edata.start_pc,
1055                     &quot;end&quot;, &quot;&quot; + edata.end_pc,
1056                     &quot;catch&quot;, &quot;&quot; + edata.handler_pc,
1057                     &quot;class&quot;, x.getCpString(edata.catch_type)));
1058 
1059         }
1060         this.x.readAttributesFor(cf, c.attributes, e);
1061         e.trimToSize();
1062         p.add(e);
1063         return null;
1064     }
1065 
1066     @Override
1067     public Element visitCompilationID(CompilationID_attribute cid, Element p) {
1068         Element e = new Element(x.getCpString(cid.attribute_name_index),
1069                 x.getCpString(cid.compilationID_index));
1070         p.add(e);
1071         return null;
1072     }
1073 
1074     @Override
1075     public Element visitModulePackages(ModulePackages_attribute attr, Element p) {
1076         Element e = new Element(x.getCpString(attr.attribute_name_index));
1077         for (int i : attr.packages_index) {
1078             Element ee = new Element(&quot;Package&quot;);
1079             String pkg = x.getCpString(i);
1080             ee.setAttr(&quot;package&quot;, pkg);
1081             e.add(ee);
1082         }
1083         e.trimToSize();
1084         e.sort();
1085         p.add(e);
1086         return null;
1087     }
1088 
1089     @Override
1090     public Element visitConstantValue(ConstantValue_attribute cv, Element p) {
1091         Element e = new Element(x.getCpString(cv.attribute_name_index));
1092         e.add(x.getCpString(cv.constantvalue_index));
1093         p.add(e);
1094         return null;
1095     }
1096 
1097     @Override
1098     public Element visitDeprecated(Deprecated_attribute d, Element p) {
1099         Element e = new Element(x.getCpString(d.attribute_name_index));
1100         p.add(e);
1101         return null;
1102     }
1103 
1104     @Override
1105     public Element visitEnclosingMethod(EnclosingMethod_attribute em, Element p) {
1106         Element e = new Element(x.getCpString(em.attribute_name_index));
1107         e.setAttr(&quot;class&quot;, x.getCpString(em.class_index));
1108         e.setAttr(&quot;desc&quot;, x.getCpString(em.method_index));
1109         e.trimToSize();
1110         p.add(e);
1111         return null;
1112     }
1113 
1114     @Override
1115     public Element visitExceptions(Exceptions_attribute e, Element p) {
1116         Element ee = new Element(x.getCpString(e.attribute_name_index));
1117         for (int idx : e.exception_index_table) {
1118             Element n = new Element(&quot;Item&quot;);
1119             n.setAttr(&quot;class&quot;, x.getCpString(idx));
1120             ee.add(n);
1121         }
1122         ee.trimToSize();
1123         p.add(ee);
1124         return null;
1125     }
1126 
1127     @Override
1128     public Element visitInnerClasses(InnerClasses_attribute ic, Element p) {
1129         for (Info info : ic.classes) {
1130             Element e = new Element(x.getCpString(ic.attribute_name_index));
1131             e.setAttr(&quot;class&quot;, x.getCpString(info.inner_class_info_index));
1132             e.setAttr(&quot;outer&quot;, x.getCpString(info.outer_class_info_index));
1133             e.setAttr(&quot;name&quot;, x.getCpString(info.inner_name_index));
1134             e.setAttr(&quot;flags&quot;, x.flagString(info.inner_class_access_flags,
1135                     &quot;InnerClass&quot;));
1136             e.trimToSize();
1137             p.add(e);
1138         }
1139         return null;
1140     }
1141 
1142     @Override
1143     public Element visitLineNumberTable(LineNumberTable_attribute lnt, Element p) {
1144         String name = x.getCpString(lnt.attribute_name_index);
1145         for (LineNumberTable_attribute.Entry e : lnt.line_number_table) {
1146             Element l = new Element(name);
1147             l.setAttr(&quot;bci&quot;, &quot;&quot; + e.start_pc);
1148             l.setAttr(&quot;line&quot;, &quot;&quot; + e.line_number);
1149             l.trimToSize();
1150             p.add(l);
1151         }
1152         return null; // already added to parent
1153     }
1154 
1155     @Override
1156     public Element visitLocalVariableTable(LocalVariableTable_attribute lvt,
1157                                                 Element p) {
1158         String name = x.getCpString(lvt.attribute_name_index);
1159         for (LocalVariableTable_attribute.Entry e : lvt.local_variable_table) {
1160             Element l = new Element(name);
1161             l.setAttr(&quot;bci&quot;, &quot;&quot; + e.start_pc);
1162             l.setAttr(&quot;span&quot;, &quot;&quot; + e.length);
1163             l.setAttr(&quot;name&quot;, x.getCpString(e.name_index));
1164             l.setAttr(&quot;type&quot;, x.getCpString(e.descriptor_index));
1165             l.setAttr(&quot;slot&quot;, &quot;&quot; + e.index);
1166             l.trimToSize();
1167             p.add(l);
1168         }
1169         return null; // already added to parent
1170     }
1171 
1172     private void parseModuleRequires(RequiresEntry[] res, Element p) {
1173         for (RequiresEntry re : res) {
1174             Element er = new Element(&quot;Requires&quot;);
1175             er.setAttr(&quot;module&quot;, x.getCpString(re.requires_index));
1176             er.setAttr(&quot;flags&quot;, Integer.toString(re.requires_flags));
1177             p.add(er);
1178         }
1179     }
1180 
1181     private void parseModuleExports(ExportsEntry[] exports, Element p) {
1182         Element ex = new Element(&quot;Exports&quot;);
1183         for (ExportsEntry export : exports) {
1184             Element exto = new Element(&quot;exports&quot;);
1185             exto.setAttr(&quot;package&quot;, x.getCpString(export.exports_index));
1186             for (int idx : export.exports_to_index) {
1187                 exto.setAttr(&quot;module&quot;, x.getCpString(idx));
1188             }
1189             ex.add(exto);
1190         }
1191         p.add(ex);
1192     }
1193 
1194     private void parseModuleProvides(ProvidesEntry[] provides, Element p) {
1195         Element ex = new Element(&quot;Provides&quot;);
1196         for (ProvidesEntry provide : provides) {
1197             ex.setAttr(&quot;provides&quot;, x.getCpString(provide.provides_index));
1198             for (int idx : provide.with_index) {
1199                 ex.setAttr(&quot;with&quot;, x.getCpString(idx));
1200             }
1201         }
1202         p.add(ex);
1203     }
1204 
1205     @Override
1206     public Element visitModule(Module_attribute m, Element p) {
1207         Element e = new Element(x.getCpString(m.attribute_name_index));
1208         parseModuleRequires(m.requires, e);
1209         parseModuleExports(m.exports, e);
1210         for (int idx : m.uses_index) {
1211             Element ei = new Element(&quot;Uses&quot;);
1212             ei.setAttr(&quot;used_class&quot;, x.getCpString(idx));
1213             e.add(ei);
1214         }
1215         parseModuleProvides(m.provides, e);
1216         p.add(e);
1217         return null;
1218     }
1219 
1220     @Override
1221     public Element visitLocalVariableTypeTable(LocalVariableTypeTable_attribute lvtt,
1222                                                     Element p) {
1223         String name = x.getCpString(lvtt.attribute_name_index);
1224         for (LocalVariableTypeTable_attribute.Entry e : lvtt.local_variable_table) {
1225             Element l = new Element(name);
1226             l.setAttr(&quot;bci&quot;, &quot;&quot; + e.start_pc);
1227             l.setAttr(&quot;span&quot;, &quot;&quot; + e.length);
1228             l.setAttr(&quot;name&quot;, x.getCpString(e.name_index));
1229             l.setAttr(&quot;type&quot;, x.getCpString(e.signature_index));
1230             l.setAttr(&quot;slot&quot;, &quot;&quot; + e.index);
1231             l.trimToSize();
1232             p.add(l);
1233         }
1234         return null; // already added to parent
1235     }
1236 
1237     @Override
1238     public Element visitMethodParameters(MethodParameters_attribute mp, Element p) {
1239         String name = x.getCpString(mp.attribute_name_index);
1240         for (MethodParameters_attribute.Entry e : mp.method_parameter_table) {
1241             Element l = new Element(name);
1242             l.setAttr(&quot;name&quot;, x.getCpString(e.name_index));
1243             l.setAttr(&quot;flag&quot;, &quot;&quot; + e.flags);
1244             l.trimToSize();
1245             p.add(l);
1246         }
1247         return null; // already added to parent
1248     }
1249     private void parseAnnotation(Annotation anno, Element p) {
1250         Element ea = new Element(&quot;Annotation&quot;);
1251         ea.setAttr(&quot;name&quot;, &quot;&quot; + x.getCpString(anno.type_index));
1252         for (Annotation.element_value_pair evp : anno.element_value_pairs) {
1253             Element evpe = new Element(&quot;Element&quot;);
1254             evpe.setAttr(&quot;tag&quot;, &quot;&quot; + evp.value.tag);
1255             evpe.setAttr(&quot;value&quot;, x.getCpString(evp.element_name_index));
1256             Element child = aev.visit(evp.value, evpe);
1257             if (child != null) {
1258                 evpe.add(child);
1259             }
1260             ea.add(evpe);
1261         }
1262         ea.trimToSize();
1263         p.add(ea);
1264     }
1265 
1266     private void parseAnnotations(Annotation[] ra, Element p) {
1267         for (Annotation anno : ra) {
1268             parseAnnotation(anno, p);
1269         }
1270     }
1271 
1272     @Override
1273     public Element visitRuntimeVisibleAnnotations(RuntimeVisibleAnnotations_attribute rva,
1274                                                   Element p) {
1275         Element e = new Element(x.getCpString(rva.attribute_name_index));
1276         parseAnnotations(rva.annotations, e);
1277         e.trimToSize();
1278         p.add(e);
1279         return null;
1280     }
1281 
1282     @Override
1283     public Element visitRuntimeInvisibleAnnotations(RuntimeInvisibleAnnotations_attribute ria,
1284                                                     Element p) {
1285         Element e = new Element(x.getCpString(ria.attribute_name_index));
1286         parseAnnotations(ria.annotations, e);
1287         e.trimToSize();
1288         p.add(e);
1289         return null;
1290     }
1291 
1292     @Override
1293     public Element visitRuntimeVisibleParameterAnnotations(RuntimeVisibleParameterAnnotations_attribute rvpa,
1294                                                            Element p) {
1295         Element e = new Element(x.getCpString(rvpa.attribute_name_index));
1296         for (Annotation[] pa : rvpa.parameter_annotations) {
1297            parseAnnotations(pa, e);
1298         }
1299         p.add(e);
1300         return null;
1301     }
1302 
1303     @Override
1304     public Element visitRuntimeInvisibleParameterAnnotations(RuntimeInvisibleParameterAnnotations_attribute ripa,
1305                                                              Element p) {
1306         Element e = new Element(x.getCpString(ripa.attribute_name_index));
1307         for (Annotation[] pa : ripa.parameter_annotations) {
1308             parseAnnotations(pa, e);
1309         }
1310         p.add(e);
1311         return null;
1312     }
1313 
1314     private void parsePosition(Position ap, Element p) {
1315         Element te = new Element();
1316         switch (ap.type) {
1317             case CLASS_TYPE_PARAMETER: // 0x00
1318                 te.setName(&quot;CLASS_TYPE_PARAMETER&quot;);
1319                 te.setAttr(&quot;idx&quot;, &quot;&quot; + ap.parameter_index);
1320                 break;
1321             case METHOD_TYPE_PARAMETER: // 0x01
1322                 te.setName(&quot;METHOD_TYPE_PARAMETER&quot;);
1323                 te.setAttr(&quot;idx&quot;, &quot;&quot; + ap.parameter_index);
1324                 break;
1325             case CLASS_EXTENDS: // 0x10
1326                 te.setName(&quot;CLASS_EXTENDS&quot;);
1327                 te.setAttr(&quot;idx&quot;, &quot;&quot; + ap.type_index);
1328                 break;
1329             case CLASS_TYPE_PARAMETER_BOUND: // 0x11
1330                 te.setName(&quot;CLASS_TYPE_PARAMETER_BOUND&quot;);
1331                 te.setAttr(&quot;idx1&quot;, &quot;&quot; + ap.parameter_index);
1332                 te.setAttr(&quot;idx2&quot;, &quot;&quot; + ap.bound_index);
1333                 break;
1334             case METHOD_TYPE_PARAMETER_BOUND: // 0x12
1335                 te.setName(&quot;METHOD_TYPE_PARAMETER_BOUND&quot;);
1336                 te.setAttr(&quot;idx1&quot;, &quot;&quot; + ap.parameter_index);
1337                 te.setAttr(&quot;idx2&quot;, &quot;&quot; + ap.bound_index);
1338                 break;
1339             case FIELD: // 0x13
1340                 te.setName(&quot;FIELD&quot;);
1341                 break;
1342             case METHOD_RETURN: // 0x14
1343                 te.setName(&quot;METHOD_RETURN&quot;);
1344                 break;
1345             case METHOD_RECEIVER: // 0x15
1346                 te.setName(&quot;METHOD_RECEIVER&quot;);
1347                 break;
1348             case METHOD_FORMAL_PARAMETER: // 0x16
1349                 te.setName(&quot;METHOD_FORMAL_PARAMETER&quot;);
1350                 te.setAttr(&quot;idx&quot;, &quot;&quot; + ap.parameter_index);
1351                 break;
1352             case THROWS: // 0x17
1353                 te.setName(&quot;THROWS&quot;);
1354                 te.setAttr(&quot;idx&quot;, &quot;&quot; + ap.type_index);
1355                 break;
1356             case LOCAL_VARIABLE: // 0x40
1357                 te.setName(&quot;LOCAL_VARIABLE&quot;);
1358                 for (int i = 0; i &lt; ap.lvarIndex.length; i++) {
1359                     te.setAttr(&quot;lvar_idx_&quot; + i, &quot;&quot; + ap.lvarIndex[i]);
1360                     te.setAttr(&quot;lvar_len_&quot; + i, &quot;&quot; + ap.lvarLength[i]);
1361                     te.setAttr(&quot;lvar_off_&quot; + i, &quot;&quot; + ap.lvarOffset[i]);
1362                 }
1363                 break;
1364             case RESOURCE_VARIABLE: // 0x41
1365                 te.setName(&quot;RESOURCE_VARIABLE&quot;);
1366                 for (int i = 0; i &lt; ap.lvarIndex.length ; i++) {
1367                     te.setAttr(&quot;lvar_idx_&quot; + i, &quot;&quot; + ap.lvarIndex[i]);
1368                     te.setAttr(&quot;lvar_len_&quot; + i, &quot;&quot; + ap.lvarLength[i]);
1369                     te.setAttr(&quot;lvar_off_&quot; + i, &quot;&quot; + ap.lvarOffset[i]);
1370                 }
1371                 break;
1372             case EXCEPTION_PARAMETER: // 0x42
1373                 te.setName(&quot;EXCEPTION_PARAMETER&quot;);
1374                 te.setAttr(&quot;idx&quot;, &quot;&quot; + ap.exception_index);
1375                 break;
1376             case INSTANCEOF: // 0x43
1377                 te.setName(&quot;INSTANCE_OF&quot;);
1378                 te.setAttr(&quot;off&quot;, &quot;&quot; + ap.offset);
1379                 break;
1380             case NEW: // 0x44
1381                 te.setName(&quot;NEW&quot;);
1382                 te.setAttr(&quot;off&quot;, &quot;&quot; + ap.offset);
1383                 break;
1384             case CONSTRUCTOR_REFERENCE: // 0x45
1385                 te.setName(&quot;CONSTRUCTOR_REFERENCE_RECEIVER&quot;);
1386                 te.setAttr(&quot;off&quot;, &quot;&quot; + ap.offset);
1387                 break;
1388             case METHOD_REFERENCE: // 0x46
1389                 te.setName(&quot;METHOD_REFERENCE_RECEIVER&quot;);
1390                 te.setAttr(&quot;off&quot;, &quot;&quot; + ap.offset);
1391                 break;
1392             case CAST: // 0x47
1393                 te.setName(&quot;CAST&quot;);
1394                 te.setAttr(&quot;off&quot;, &quot;&quot; + ap.offset);
1395                 te.setAttr(&quot;idx&quot;, &quot;&quot; + ap.type_index);
1396                 break;
1397             case CONSTRUCTOR_INVOCATION_TYPE_ARGUMENT: // 0x48
1398                 te.setName(&quot;CONSTRUCTOR_INVOCATION_TYPE_ARGUMENT&quot;);
1399                 te.setAttr(&quot;off&quot;, &quot;&quot; + ap.offset);
1400                 te.setAttr(&quot;idx&quot;, &quot;&quot; + ap.type_index);
1401                 break;
1402             case METHOD_INVOCATION_TYPE_ARGUMENT: // 0x49
1403                 te.setName(&quot;METHOD_INVOCATION_TYPE_ARGUMENT&quot;);
1404                 te.setAttr(&quot;off&quot;, &quot;&quot; + ap.offset);
1405                 te.setAttr(&quot;idx&quot;, &quot;&quot; + ap.type_index);
1406                 break;
1407             case CONSTRUCTOR_REFERENCE_TYPE_ARGUMENT: // 0x4A
1408                 te.setName(&quot;CONSTRUCTOR_REFERENCE_TYPE_ARGUMENT&quot;);
1409                 te.setAttr(&quot;off&quot;, &quot;&quot; + ap.offset);
1410                 te.setAttr(&quot;idx&quot;, &quot;&quot; + ap.type_index);
1411                 break;
1412             case METHOD_REFERENCE_TYPE_ARGUMENT: // 0x4B
1413                 te.setName(&quot;METHOD_REFERENCE_TYPE_ARGUMENT&quot;);
1414                 te.setAttr(&quot;off&quot;, &quot;&quot; + ap.offset);
1415                 te.setAttr(&quot;idx&quot;, &quot;&quot; + ap.type_index);
1416                 break;
1417             default:
1418                 throw new RuntimeException(&quot;not implemented&quot;);
1419         }
1420         te.trimToSize();
1421         p.add(te);
1422     }
1423     private void parseTypeAnnotations(TypeAnnotation pa, Element p) {
1424         Element pta = new Element(&quot;RuntimeVisibleTypeAnnotation&quot;);
1425         p.add(pta);
1426         Position pos = pa.position;
1427         parsePosition(pos, pta);
1428         parseAnnotation(pa.annotation, pta);
1429     }
1430 
1431     @Override
1432     public Element visitRuntimeVisibleTypeAnnotations(RuntimeVisibleTypeAnnotations_attribute rvta, Element p) {
1433         Element e = new Element(x.getCpString(rvta.attribute_name_index));
1434         for (TypeAnnotation pa : rvta.annotations) {
1435             parseTypeAnnotations(pa, e);
1436         }
1437         e.sort();
1438         p.add(e);
1439         return null;
1440     }
1441 
1442     @Override
1443     public Element visitRuntimeInvisibleTypeAnnotations(RuntimeInvisibleTypeAnnotations_attribute rita, Element p) {
1444         Element e = new Element(x.getCpString(rita.attribute_name_index));
1445         for (TypeAnnotation pa : rita.annotations) {
1446             parseTypeAnnotations(pa, e);
1447         }
1448         e.sort();
1449         p.add(e);
1450         return null;
1451     }
1452 
1453     @Override
1454     public Element visitSignature(Signature_attribute s, Element p) {
1455         String aname = x.getCpString(s.attribute_name_index);
1456         String sname = x.getCpString(s.signature_index);
1457         Element se = new Element(aname);
1458         se.add(sname);
1459         se.trimToSize();
1460         p.add(se);
1461         return null;
1462     }
1463 
1464     @Override
1465     public Element visitSourceDebugExtension(SourceDebugExtension_attribute sde,
1466                                                 Element p) {
1467         String aname = x.getCpString(sde.attribute_name_index);
1468         Element se = new Element(aname);
1469         se.setAttr(&quot;val&quot;, sde.getValue());
1470         se.trimToSize();
1471         p.add(se);
1472         return null;
1473     }
1474 
1475     @Override
1476     public Element visitSourceFile(SourceFile_attribute sf, Element p) {
1477         String aname = x.getCpString(sf.attribute_name_index);
1478         String sname = x.getCpString(sf.sourcefile_index);
1479         Element se = new Element(aname);
1480         se.add(sname);
1481         se.trimToSize();
1482         p.add(se);
1483         return null;
1484     }
1485 
1486     @Override
1487     public Element visitSourceID(SourceID_attribute sid, Element p) {
1488         Element e = new Element(x.getCpString(sid.attribute_name_index));
1489         e.add(x.getCpString(sid.sourceID_index));
1490         e.trimToSize();
1491         p.add(e);
1492         return null;
1493     }
1494 
1495     @Override
1496     public Element visitStackMap(StackMap_attribute sm, Element p) {
1497         throw new UnsupportedOperationException(&quot;Not supported yet.&quot;);
1498     }
1499 
1500     @Override
1501     public Element visitStackMapTable(StackMapTable_attribute smt, Element p) {
1502         Element stackmap = new Element(x.getCpString(smt.attribute_name_index));
1503         for (StackMapTable_attribute.stack_map_frame f : smt.entries) {
1504            StackMapVisitor smv = new StackMapVisitor(x, cf, stackmap);
1505            stackmap.add(smv.visit(f));
1506         }
1507         stackmap.trimToSize();
1508         p.add(stackmap);
1509         return null;
1510     }
1511 
1512     @Override
1513     public Element visitSynthetic(Synthetic_attribute s, Element p) {
1514         Element e = new Element(x.getCpString(s.attribute_name_index));
1515         e.trimToSize();
1516         p.add(e);
1517         return null;
1518     }
1519 
1520     @Override
1521     public Element visitModuleHashes(ModuleHashes_attribute attr, Element p) {
1522         Element e = new Element(x.getCpString(attr.attribute_name_index));
1523         e.setAttr(&quot;Algorithm&quot;, x.getCpString(attr.algorithm_index));
1524         for (Entry entry : attr.hashes_table) {
1525             Element ee = new Element(&quot;Entry&quot;);
1526             String mn = x.getCpString(entry.module_name_index);
1527             ee.setAttr(&quot;module_name&quot;, mn);
1528             ee.setAttr(&quot;hash_length&quot;, &quot;&quot; + entry.hash.length);
1529             StringBuilder sb = new StringBuilder();
1530             for (byte b: entry.hash) {
1531                 sb.append(String.format(&quot;%02x&quot;, b &amp; 0xff));
1532             }
1533             ee.setAttr(&quot;hash&quot;, sb.toString());
1534             ee.trimToSize();
1535             e.add(ee);
1536         }
1537         e.trimToSize();
1538         e.sort();
1539         p.add(e);
1540         return null;
1541     }
1542 
1543     @Override
1544     public Element visitModuleMainClass(ModuleMainClass_attribute attr, Element p) {
1545         Element e = new Element(x.getCpString(attr.attribute_name_index));
1546         e.add(x.getCpString(attr.main_class_index));
1547         e.trimToSize();
1548         p.add(e);
1549         return null;
1550     }
1551 
1552     @Override
1553     public Element visitModuleResolution(ModuleResolution_attribute attr, Element p) {
1554         Element e = new Element(&quot;ModuleResolution&quot;);
1555         e.setAttr(&quot;flags&quot;, Integer.toString(attr.resolution_flags));
1556         e.trimToSize();
1557         p.add(e);
1558         return null;
1559     }
1560 
1561     @Override
1562     public Element visitModuleTarget(ModuleTarget_attribute attr, Element p) {
1563         Element e = new Element(x.getCpString(attr.attribute_name_index));
1564         e.add(x.getCpString(attr.target_platform_index));
1565         e.trimToSize();
1566         p.add(e);
1567         return null;
1568     }
1569 
1570     @Override
1571     public Element visitNestHost(NestHost_attribute attr, Element p) {
1572         String aname = x.getCpString(attr.attribute_name_index);
1573         String hname = x.getCpString(attr.top_index);
1574         Element se = new Element(aname);
1575         se.add(hname);
1576         se.trimToSize();
1577         p.add(se);
1578         return null;
1579     }
1580 
1581     @Override
1582     public Element visitNestMembers(NestMembers_attribute attr, Element p) {
1583         Element ee = new Element(x.getCpString(attr.attribute_name_index));
1584         for (int idx : attr.members_indexes) {
1585             Element n = new Element(&quot;Item&quot;);
1586             n.setAttr(&quot;class&quot;, x.getCpString(idx));
1587             ee.add(n);
1588         }
1589         ee.trimToSize();
1590         p.add(ee);
1591         return null;
1592     }
1593 }
1594 
1595 class StackMapVisitor implements StackMapTable_attribute.stack_map_frame.Visitor&lt;Element, Void&gt; {
1596 
1597     final ClassFile cf;
1598     final ClassReader x;
1599     final Element parent;
1600 
1601     public StackMapVisitor(ClassReader x, ClassFile cf, Element parent) {
1602         this.x = x;
1603         this.cf = cf;
1604         this.parent = parent;
1605     }
1606 
1607     public Element visit(StackMapTable_attribute.stack_map_frame frame) {
1608         return frame.accept(this, null);
1609     }
1610 
1611     @Override
1612     public Element visit_same_frame(same_frame sm_frm, Void p) {
1613         Element e = new Element(&quot;SameFrame&quot;);
1614         e.setAttr(&quot;tag&quot;, &quot;&quot; + sm_frm.frame_type);
1615         return e;
1616     }
1617 
1618     @Override
1619     public Element visit_same_locals_1_stack_item_frame(same_locals_1_stack_item_frame s, Void p) {
1620         Element e = new Element(&quot;SameLocals1StackItemFrame&quot;);
1621         e.setAttr(&quot;tag&quot;, &quot;&quot; + s.frame_type);
1622         e.addAll(getVerificationTypeInfo(&quot;Stack&quot;, s.stack));
1623         e.trimToSize();
1624         return e;
1625     }
1626 
1627     @Override
1628     public Element visit_same_locals_1_stack_item_frame_extended(same_locals_1_stack_item_frame_extended s, Void p) {
1629         Element e = new Element(&quot;SameLocals1StackItemFrameExtended&quot;);
1630         e.setAttr(&quot;tag&quot;, &quot;&quot; + s.frame_type);
1631         e.addAll(getVerificationTypeInfo(&quot;Stack&quot;, s.stack));
1632         e.trimToSize();
1633         return e;
1634     }
1635 
1636     @Override
1637     public Element visit_chop_frame(chop_frame c, Void p) {
1638         Element e = new Element(&quot;Chop&quot; + (251 - c.frame_type));
1639         e.setAttr(&quot;tag&quot;, &quot;&quot; + c.frame_type);
1640         e.setAttr(&quot;offset&quot;, &quot;&quot; + c.offset_delta);
1641         return e;
1642     }
1643 
1644     @Override
1645     public Element visit_same_frame_extended(same_frame_extended s, Void p) {
1646         Element e = new Element(&quot;SameFrameExtended&quot;);
1647         e.setAttr(&quot;tag&quot;, &quot;&quot; + s.frame_type);
1648         e.setAttr(&quot;offset&quot;, &quot;&quot; + s.offset_delta);
1649         return e;
1650     }
1651 
1652     @Override
1653     public Element visit_append_frame(append_frame a, Void p) {
1654        Element e = new Element(&quot;AppendFrame&quot; + (a.frame_type - 251));
1655        e.setAttr(&quot;tag&quot;, &quot;&quot; + a.frame_type);
1656        e.addAll(getVerificationTypeInfo(&quot;Local&quot;, a.locals));
1657        e.trimToSize();
1658        return e;
1659     }
1660 
1661     @Override
1662     public Element visit_full_frame(full_frame fl_frm, Void p) {
1663          Element e = new Element(&quot;FullFrame&quot;);
1664          e.setAttr(&quot;tag&quot;, &quot;&quot; + fl_frm.frame_type);
1665          e.addAll(getVerificationTypeInfo(&quot;Local&quot;, fl_frm.locals));
1666          e.trimToSize();
1667          return e;
1668     }
1669 
1670     private Element getVerificationTypeInfo(String kind,
1671             StackMapTable_attribute.verification_type_info velems[]) {
1672         Element container = new Element(velems.length);
1673         for (StackMapTable_attribute.verification_type_info v : velems) {
1674             Element ve = null;
1675             int offset = 0;
1676             int index = 0;
1677             switch (v.tag) {
1678                 case StackMapTable_attribute.verification_type_info.ITEM_Top:
1679                     ve = new Element(&quot;ITEM_Top&quot;);
1680                     break;
1681                 case StackMapTable_attribute.verification_type_info.ITEM_Integer:
1682                     ve = new Element(&quot;ITEM_Integer&quot;);
1683                     break;
1684                 case StackMapTable_attribute.verification_type_info.ITEM_Float:
1685                     ve = new Element(&quot;ITEM_Float&quot;);
1686                     break;
1687                 case StackMapTable_attribute.verification_type_info.ITEM_Long:
1688                     ve = new Element(&quot;ITEM_Long&quot;);
1689                     break;
1690                 case StackMapTable_attribute.verification_type_info.ITEM_Double:
1691                     ve = new Element(&quot;ITEM_Double&quot;);
1692                     break;
1693                 case StackMapTable_attribute.verification_type_info.ITEM_Null:
1694                     ve = new Element(&quot;ITEM_Null&quot;);
1695                     break;
1696                 case StackMapTable_attribute.verification_type_info.ITEM_Uninitialized:
1697                     ve = new Element(&quot;ITEM_Uninitialized&quot;);
1698                     offset = ((StackMapTable_attribute.Uninitialized_variable_info) v).offset;
1699                     ve.setAttr(&quot;offset&quot;, &quot;&quot; + offset);
1700                     break;
1701                 case StackMapTable_attribute.verification_type_info.ITEM_UninitializedThis:
1702                     ve = new Element(&quot;ITEM_UnitializedtThis&quot;);
1703                     break;
1704                 case StackMapTable_attribute.verification_type_info.ITEM_Object:
1705                     ve = new Element(&quot;ITEM_Object&quot;);
1706                     index = ((StackMapTable_attribute.Object_variable_info) v).cpool_index;
1707                     ve.setAttr(&quot;class&quot;, x.getCpString(index));
1708                     break;
1709                 default:
1710                     ve = new Element(&quot;Unknown&quot;);
1711             }
1712             Element kindE = new Element(kind);
1713             kindE.setAttr(&quot;tag&quot;, &quot;&quot; + v.tag);
1714             container.add(kindE);
1715             kindE.add(ve);
1716         }
1717         container.trimToSize();
1718         return container;
1719     }
1720 }
1721 
1722 class InstructionVisitor implements Instruction.KindVisitor&lt;Element, Void&gt; {
1723 
1724     final ClassReader x;
1725     final ClassFile cf;
1726 
1727     public InstructionVisitor(ClassReader x, ClassFile cf) {
1728         this.x = x;
1729         this.cf = cf;
1730     }
1731 
1732     public Element visit(Instruction i) {
1733         Element ie =  i.accept(this, null);
1734         ie.trimToSize();
1735         return ie;
1736     }
1737 
1738     @Override
1739     public Element visitNoOperands(Instruction i, Void p) {
1740         Opcode o = i.getOpcode();
1741         Element e = new Element(i.getMnemonic());
1742         if (o.opcode &gt; 0xab &amp;&amp; o.opcode &lt;= 0xb1) {
1743             e.setAttr(&quot;pc&quot;, &quot;&quot; + i.getPC());
1744         }
1745         return e;
1746     }
1747 
1748     @Override
1749     public Element visitArrayType(Instruction i, TypeKind tk, Void p) {
1750         Element ie = new Element(i.getMnemonic());
1751         ie.setAttr(&quot;num&quot;, &quot;&quot; + tk.value);
1752         ie.setAttr(&quot;val&quot;, tk.name);
1753         return ie;
1754     }
1755 
1756     @Override
1757     public Element visitBranch(Instruction i, int i1, Void p) {
1758         Element ie = new Element(i.getMnemonic());
1759         ie.setAttr(&quot;lab&quot;, &quot;&quot; + (i.getPC() + i1));
1760         return ie;
1761     }
1762 
1763     @Override
1764     public Element visitConstantPoolRef(Instruction i, int i1, Void p) {
1765         Element ie = new Element(i.getMnemonic());
1766         ie.setAttr(&quot;ref&quot;, x.getCpString(i1));
1767         return ie;
1768     }
1769 
1770     @Override
1771     public Element visitConstantPoolRefAndValue(Instruction i, int i1, int i2, Void p) {
1772         // workaround for a potential bug in classfile
1773         Element ie = new Element(i.getMnemonic());
1774         if (i.getOpcode().equals(Opcode.IINC_W)) {
1775             ie.setAttr(&quot;loc&quot;, &quot;&quot; + i1);
1776             ie.setAttr(&quot;num&quot;, &quot;&quot; + i2);
1777         } else {
1778             ie.setAttr(&quot;ref&quot;, x.getCpString(i1));
1779             ie.setAttr(&quot;val&quot;, &quot;&quot; + i2);
1780         }
1781         return ie;
1782     }
1783 
1784     @Override
1785     public Element visitLocal(Instruction i, int i1, Void p) {
1786         Element ie = new Element(i.getMnemonic());
1787         ie.setAttr(&quot;loc&quot;, &quot;&quot; + i1);
1788         return ie;
1789     }
1790 
1791     @Override
1792     public Element visitLocalAndValue(Instruction i, int i1, int i2, Void p) {
1793         Element ie = new Element(i.getMnemonic());
1794         ie.setAttr(&quot;loc&quot;, &quot;&quot; + i1);
1795         ie.setAttr(&quot;num&quot;, &quot;&quot; + i2);
1796         return ie;
1797     }
1798 
1799     @Override
1800     public Element visitLookupSwitch(Instruction i, int i1, int i2, int[] ints,
1801                                      int[] ints1, Void p) {
1802         Element ie = new Element(i.getMnemonic());
1803         int pc = i.getPC();
1804         ie.setAttr(&quot;lab&quot;, &quot;&quot; + (pc + i1));
1805         for (int k = 0 ; k &lt; i2 ; k++) {
1806             Element c = new Element(&quot;Case&quot;);
1807             c.setAttr(&quot;num&quot;, &quot;&quot; + (ints[k]));
1808             c.setAttr(&quot;lab&quot;, &quot;&quot; + (pc + ints1[k]));
1809             c.trimToSize();
1810             ie.add(c);
1811         }
1812         return ie;
1813     }
1814 
1815     @Override
1816     public Element visitTableSwitch(Instruction i, int i1, int i2, int i3,
1817                                     int[] ints, Void p) {
1818         Element ie = new Element(i.getMnemonic());
1819         int pc = i.getPC();
1820         ie.setAttr(&quot;lab&quot;, &quot;&quot; + (pc + i1));
1821         for (int k : ints) {
1822             Element c = new Element(&quot;Case&quot;);
1823             c.setAttr(&quot;num&quot;, &quot;&quot; + (k + i2));
1824             c.setAttr(&quot;lab&quot;, &quot;&quot; + (pc + k));
1825             c.trimToSize();
1826             ie.add(c);
1827         }
1828         return ie;
1829     }
1830 
1831     @Override
1832     public Element visitValue(Instruction i, int i1, Void p) {
1833         Element ie = new Element(i.getMnemonic());
1834         ie.setAttr(&quot;num&quot;, &quot;&quot; + i1);
1835         return ie;
1836     }
1837 
1838     @Override
1839     public Element visitUnknown(Instruction i, Void p) {
1840         Element e = new Element(i.getMnemonic());
1841         e.setAttr(&quot;pc&quot;, &quot;&quot; + i.getPC());
1842         e.setAttr(&quot;opcode&quot;, &quot;&quot; + i.getOpcode().opcode);
1843         return e;
1844     }
1845 }
1846 
1847 class AnnotationsElementVisitor implements Annotation.element_value.Visitor&lt;Element, Element&gt; {
1848     final ClassReader x;
1849     final ClassFile cf;
1850 
1851     public AnnotationsElementVisitor(ClassReader x, ClassFile cf) {
1852         this.x = x;
1853         this.cf = cf;
1854     }
1855 
1856     public Element visit(Annotation.element_value v, Element p) {
1857         return v.accept(this, p);
1858     }
1859 
1860     @Override
1861     public Element visitPrimitive(Primitive_element_value e, Element p) {
1862         Element el = new Element(&quot;String&quot;);
1863         el.setAttr(&quot;val&quot;, x.getCpString(e.const_value_index));
1864         el.trimToSize();
1865         return el;
1866     }
1867 
1868     @Override
1869     public Element visitEnum(Enum_element_value e, Element p) {
1870         Element el = new Element(&quot;Enum&quot;);
1871         el.setAttr(&quot;name&quot;, x.getCpString(e.const_name_index));
1872         el.setAttr(&quot;type&quot;, x.getCpString(e.type_name_index));
1873         el.trimToSize();
1874         return el;
1875     }
1876 
1877     @Override
1878     public Element visitClass(Class_element_value c, Element p) {
1879         Element el = new Element(&quot;Class&quot;);
1880         el.setAttr(&quot;name&quot;, x.getCpString(c.class_info_index));
1881         el.trimToSize();
1882         return el;
1883     }
1884 
1885     @Override
1886     public Element visitAnnotation(Annotation_element_value a, Element p) {
1887         Element el = new Element(&quot;Annotation&quot;);
1888         Annotation anno = a.annotation_value;
1889         for (Annotation.element_value_pair evp : anno.element_value_pairs) {
1890             Element child = visit(evp.value, el);
1891             if (child != null) {
1892                 el.add(child);
1893             }
1894         }
1895         el.trimToSize();
1896         return el;
1897     }
1898 
1899     @Override
1900     public Element visitArray(Array_element_value a, Element p) {
1901         Element el = new Element(&quot;Array&quot;);
1902         for (Annotation.element_value v : a.values) {
1903            Element child = visit(v, el);
1904            if (child != null) {
1905                el.add(child);
1906            }
1907         }
1908         el.trimToSize();
1909         return el;
1910     }
1911 }
    </pre>
  </body>
</html>
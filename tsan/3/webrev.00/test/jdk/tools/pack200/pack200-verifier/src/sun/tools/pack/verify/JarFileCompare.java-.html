<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old test/jdk/tools/pack200/pack200-verifier/src/sun/tools/pack/verify/JarFileCompare.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2010, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 package sun.tools.pack.verify;
 24 
 25 import java.io.*;
 26 import java.util.*;
 27 import java.util.jar.*;
 28 
 29 class JarFileCompare {
 30     /*
 31      * @author ksrini
 32      */
 33 
 34     private static VerifyTreeSet getVerifyTreeSet(String jarPath) {
 35         VerifyTreeSet vts = new VerifyTreeSet();
 36         try {
 37             JarFile j = new JarFile(jarPath);
 38             for (JarEntry je : Collections.list((Enumeration&lt;JarEntry&gt;) j.entries())) {
 39                 if (!je.isDirectory()) { // totally ignore directories
 40                     vts.add(je.getName());
 41                 }
 42             }
 43         } catch (IOException ioe) {
 44             throw new RuntimeException(ioe);
 45         }
 46         return vts;
 47     }
 48 
 49     private static LinkedList getListOfClasses(String jarPath) {
 50         LinkedList l = new LinkedList();
 51         try {
 52             JarFile j = new JarFile(jarPath);
 53             for (JarEntry je : Collections.list((Enumeration&lt;JarEntry&gt;) j.entries())) {
 54                 if (!je.isDirectory() &amp;&amp; je.getName().endsWith(&quot;.class&quot;)) {
 55                     l.add(je.getName());
 56                 }
 57             }
 58         } catch (IOException ioe) {
 59             throw new RuntimeException(ioe);
 60         }
 61         return l;
 62     }
 63 
 64     private static void jarDirectoryCompare(String jarPath1, String jarPath2) {
 65         VerifyTreeSet vts1 = getVerifyTreeSet(jarPath1);
 66         VerifyTreeSet vts2 = getVerifyTreeSet(jarPath2);
 67 
 68         TreeSet diff1 = vts1.diff(vts2);
 69         if (diff1.size() &gt; 0) {
 70             Globals.log(&quot;Left has the following entries that right does not have&quot;);
 71             Globals.log(diff1.toString());
 72         }
 73         TreeSet diff2 = vts2.diff(vts1);
 74         if (diff2.size() &gt; 0) {
 75             Globals.log(&quot;Right has the following entries that left does not have&quot;);
 76             Globals.log(diff2.toString());
 77         }
 78         if (Globals.checkJarClassOrdering()) {
 79             boolean error = false;
 80             Globals.println(&quot;Checking Class Ordering&quot;);
 81             LinkedList l1 = getListOfClasses(jarPath1);
 82             LinkedList l2 = getListOfClasses(jarPath2);
 83             if (l1.size() != l2.size()) {
 84                 error = true;
 85                 Globals.log(&quot;The number of classes differs&quot;);
 86                 Globals.log(&quot;\t&quot; + l1.size() + &quot;&lt;&gt;&quot; + l2.size());
 87             }
 88             for (int i = 0; i &lt; l1.size(); i++) {
 89                 String s1 = (String) l1.get(i);
 90                 String s2 = (String) l2.get(i);
 91                 if (s1.compareTo(s2) != 0) {
 92                     error = true;
 93                     Globals.log(&quot;Ordering differs at[&quot; + i + &quot;] = &quot; + s1);
 94                     Globals.log(&quot;\t&quot; + s2);
 95                 }
 96             }
 97         }
 98     }
 99 
100     /*
101      * Returns true if the two Streams are bit identical, and false if they
102      * are not, no further diagnostics
103      */
104     static boolean compareStreams(InputStream is1, InputStream is2) {
105 
106         BufferedInputStream bis1 = new BufferedInputStream(is1, 8192);
107         BufferedInputStream bis2 = new BufferedInputStream(is2, 8192);
108         try {
109             int i1, i2;
110             int count = 0;
111             while ((i1 = bis1.read()) == (i2 = bis2.read())) {
112                 count++;
113                 if (i1 &lt; 0) {
114                     // System.out.println(&quot;bytes read &quot; + count);
115                     return true;  // got all the way to EOF
116                 }
117             }
118             return false;  // reads returned dif
119 
120         } catch (IOException ioe) {
121             throw new RuntimeException(ioe);
122         }
123     }
124 
125     private static void checkEntry(JarFile jf1, JarFile jf2, JarEntry je) throws IOException {
126         InputStream is1 = jf1.getInputStream(je);
127         InputStream is2 = jf2.getInputStream(je);
128         if (is1 != null &amp;&amp; is2 != null) {
129             if (!compareStreams(jf1.getInputStream(je), jf2.getInputStream(je))) {
130                 Globals.println(&quot;+++&quot; + je.getName() + &quot;+++&quot;);
131                 Globals.log(&quot;Error: File:&quot; + je.getName()
132                         + &quot; differs, use a diff util for further diagnostics&quot;);
133             }
134         } else {
135             Globals.println(&quot;+++&quot; + je.getName() + &quot;+++&quot;);
136             Globals.log(&quot;Error: File:&quot; + je.getName() + &quot; not found in &quot; + jf2.getName());
137         }
138     }
139 
140     /*
141      * Given two jar files we compare and see if the jarfiles have all the
142      * entries. The property ignoreJarDirectories is set to true by default
143      * which means that Directory entries in a jar may be ignore.
144      */
145     static void jarCompare(String jarPath1, String jarPath2) {
146         jarDirectoryCompare(jarPath1, jarPath2);
147 
148         try {
149             JarFile jf1 = new JarFile(jarPath1);
150             JarFile jf2 = new JarFile(jarPath2);
151 
152             int nclasses = 0;
153             int nentries = 0;
154             int entries_checked = 0;
155             int classes_checked = 0;
156 
157             for (JarEntry je : Collections.list((Enumeration&lt;JarEntry&gt;) jf1.entries())) {
158                 if (!je.isDirectory() &amp;&amp; !je.getName().endsWith(&quot;.class&quot;)) {
159                     nentries++;
160                 } else if (je.getName().endsWith(&quot;.class&quot;)) {
161                     nclasses++;
162                 }
163             }
164 
165             for (JarEntry je : Collections.list((Enumeration&lt;JarEntry&gt;) jf1.entries())) {
166                 if (je.isDirectory()) {
167                     continue;  // Ignore directories
168                 }
169                 if (!je.getName().endsWith(&quot;.class&quot;)) {
170                     entries_checked++;
171                     if (je.getName().compareTo(&quot;META-INF/MANIFEST.MF&quot;) == 0) {
172                         Manifest mf1 = new Manifest(jf1.getInputStream(je));
173                         Manifest mf2 = new Manifest(jf2.getInputStream(je));
174                         if (!mf1.equals(mf2)) {
175                             Globals.log(&quot;Error: Manifests differ&quot;);
176                             Globals.log(&quot;Manifest1&quot;);
177                             Globals.log(mf1.getMainAttributes().entrySet().toString());
178                             Globals.log(&quot;Manifest2&quot;);
179                             Globals.log(mf2.getMainAttributes().entrySet().toString());
180                         }
181                     } else {
182                         checkEntry(jf1, jf2, je);
183                     }
184                 } else if (Globals.bitWiseClassCompare() == true) {
185                     checkEntry(jf1, jf2, je);
186                     classes_checked++;
187                 }
188             }
189             if (Globals.bitWiseClassCompare()) {
190                 Globals.println(&quot;Class entries checked (byte wise)/Total Class entries = &quot;
191                         + classes_checked + &quot;/&quot; + nclasses);
192             }
193             Globals.println(&quot;Non-class entries checked/Total non-class entries = &quot;
194                     + entries_checked + &quot;/&quot; + nentries);
195         } catch (IOException ioe) {
196             throw new RuntimeException(ioe);
197         }
198     }
199 }
    </pre>
  </body>
</html>
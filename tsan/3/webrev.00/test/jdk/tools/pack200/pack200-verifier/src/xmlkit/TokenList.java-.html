<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old test/jdk/tools/pack200/pack200-verifier/src/xmlkit/TokenList.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2010, 2018, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 package xmlkit; // -*- mode: java; indent-tabs-mode: nil -*-
 24 
 25 import java.util.*;
 26 
 27 /**
 28  * A List of Strings each representing a word or token.
 29  * This object itself is a CharSequence whose characters consist
 30  * of all the tokens, separated by blanks.
 31  *
 32  * @author jrose
 33  */
 34 public class TokenList extends ArrayList&lt;String&gt; implements CharSequence {
 35 
 36     protected String separator;
 37     protected boolean frozen;
 38 
 39     public TokenList() {
 40         this.separator = &quot; &quot;;
 41     }
 42 
 43     public TokenList(Collection&lt;? extends Object&gt; tokens) {
 44         super(tokens.size());
 45         this.separator = &quot; &quot;;
 46         addTokens(tokens);
 47     }
 48 
 49     public TokenList(Collection&lt;? extends Object&gt; tokens, String separator) {
 50         super(tokens.size());
 51         this.separator = separator;
 52         addTokens(tokens);
 53     }
 54 
 55     public TokenList(Object[] tokens) {
 56         super(tokens.length);
 57         this.separator = &quot; &quot;;
 58         addTokens(tokens, 0, tokens.length);
 59     }
 60 
 61     public TokenList(Object[] tokens, int beg, int end) {
 62         super(end - beg);  // capacity
 63         this.separator = &quot; &quot;;
 64         addTokens(tokens, beg, end);
 65     }
 66 
 67     public TokenList(Object[] tokens, int beg, int end, String separator) {
 68         super(end - beg);  // capacity
 69         this.separator = separator;
 70         addTokens(tokens, beg, end);
 71     }
 72 
 73     public TokenList(String tokenStr) {
 74         this(tokenStr, &quot; &quot;, false);
 75     }
 76 
 77     public TokenList(String tokenStr, String separator) {
 78         this(tokenStr, separator, true);
 79     }
 80 
 81     public TokenList(String tokenStr, String separator, boolean allowNulls) {
 82         super(tokenStr.length() / 5);
 83         this.separator = separator;
 84         addTokens(tokenStr, allowNulls);
 85     }
 86     static public final TokenList EMPTY;
 87 
 88     static {
 89         TokenList tl = new TokenList(new Object[0]);
 90         tl.freeze();
 91         EMPTY = tl;
 92     }
 93 
 94     public void freeze() {
 95         if (!frozen) {
 96             for (ListIterator&lt;String&gt; i = listIterator(); i.hasNext();) {
 97                 i.set(i.next().toString());
 98             }
 99             trimToSize();
100             frozen = true;
101         }
102     }
103 
104     public boolean isFrozen() {
105         return frozen;
106     }
107 
108     void checkNotFrozen() {
109         if (isFrozen()) {
110             throw new UnsupportedOperationException(&quot;cannot modify frozen TokenList&quot;);
111         }
112     }
113 
114     public String getSeparator() {
115         return separator;
116     }
117 
118     public void setSeparator(String separator) {
119         checkNotFrozen();
120         this.separator = separator;
121     }
122 
123     /// All normal List mutators must check the frozen bit:
124     public String set(int index, String o) {
125         checkNotFrozen();
126         return super.set(index, o);
127     }
128 
129     public boolean add(String o) {
130         checkNotFrozen();
131         return super.add(o);
132     }
133 
134     public void add(int index, String o) {
135         checkNotFrozen();
136         super.add(index, o);
137     }
138 
139     public boolean addAll(Collection&lt;? extends String&gt; c) {
140         checkNotFrozen();
141         return super.addAll(c);
142     }
143 
144     public boolean addAll(int index, Collection&lt;? extends String&gt; c) {
145         checkNotFrozen();
146         return super.addAll(index, c);
147     }
148 
149     public boolean remove(Object o) {
150         checkNotFrozen();
151         return super.remove(o);
152     }
153 
154     public String remove(int index) {
155         checkNotFrozen();
156         return super.remove(index);
157     }
158 
159     public void clear() {
160         checkNotFrozen();
161         super.clear();
162     }
163 
164     /** Add a collection of tokens to the list, applying toString to each. */
165     public boolean addTokens(Collection&lt;? extends Object&gt; tokens) {
166         // Note that if this sequence is empty, no tokens are added.
167         // This is different from adding a null string, which is
168         // a single token.
169         boolean added = false;
170         for (Object token : tokens) {
171             add(token.toString());
172             added = true;
173         }
174         return added;
175     }
176 
177     public boolean addTokens(Object[] tokens, int beg, int end) {
178         boolean added = false;
179         for (int i = beg; i &lt; end; i++) {
180             add(tokens[i].toString());
181             added = true;
182         }
183         return added;
184     }
185 
186     public boolean addTokens(String tokenStr) {
187         return addTokens(tokenStr, false);
188     }
189 
190     public boolean addTokens(String tokenStr, boolean allowNulls) {
191         boolean added = false;
192         int pos = 0, limit = tokenStr.length(), sep = limit;
193         while (pos &lt; limit) {
194             sep = tokenStr.indexOf(separator, pos);
195             if (sep &lt; 0) {
196                 sep = limit;
197             }
198             if (sep == pos) {
199                 if (allowNulls) {
200                     add(&quot;&quot;);
201                     added = true;
202                 }
203                 pos += separator.length();
204             } else {
205                 add(tokenStr.substring(pos, sep));
206                 added = true;
207                 pos = sep + separator.length();
208             }
209         }
210         if (allowNulls &amp;&amp; sep &lt; limit) {
211             // Input was something like &quot;tok1 tok2 &quot;.
212             add(&quot;&quot;);
213             added = true;
214         }
215         return added;
216     }
217 
218     public boolean addToken(Object token) {
219         return add(token.toString());
220     }
221 
222     /** Format the token string, using quotes and escapes.
223      *  Quotes must contain an odd number of 3 or more elements,
224      *  a sequence of begin/end quote pairs, plus a superquote.
225      *  For each token, the first begin/end pair is used for
226      *  which the end quote does not occur in the token.
227      *  If the token contains all end quotes, the last pair
228      *  is used, with all occurrences of the end quote replaced
229      *  by the superquote.  If an end quote is the empty string,
230      *  the separator is used instead.
231      */
232     public String format(String separator, String[] quotes) {
233         return &quot;&quot;; //@@
234     }
235     protected int[] lengths;
236     protected static final int MODC = 0, HINT = 1, BEG0 = 2, END0 = 3;
237 
238     // Layout of lengths:
239     //   { modCount, hint, -1==beg[0], end[0]==beg[1], ..., length }
240     // Note that each beg[i]..end[i] span includes a leading separator,
241     // which is not part of the corresponding token.
242     protected final CharSequence getCS(int i) {
243         return (CharSequence) get(i);
244     }
245 
246     // Produce (and cache) an table of indexes for each token.
247     protected int[] getLengths() {
248         int[] lengths = this.lengths;
249         ;
250         int sepLength = separator.length();
251         if (lengths == null || lengths[MODC] != modCount) {
252             int size = this.size();
253             lengths = new int[END0 + size + (size == 0 ? 1 : 0)];
254             lengths[MODC] = modCount;
255             int end = -sepLength;  // cancels leading separator
256             lengths[BEG0] = end;
257             for (int i = 0; i &lt; size; i++) {
258                 end += sepLength;  // count leading separator
259                 end += getCS(i).length();
260                 lengths[END0 + i] = end;
261             }
262             this.lengths = lengths;
263         }
264         return lengths;
265     }
266 
267     public int length() {
268         int[] lengths = getLengths();
269         return lengths[lengths.length - 1];
270     }
271 
272     // Which token does the given index belong to?
273     protected int which(int i) {
274         if (i &lt; 0) {
275             return -1;
276         }
277         int[] lengths = getLengths();
278         for (int hint = lengths[HINT];; hint = 0) {
279             for (int wh = hint; wh &lt; lengths.length - END0; wh++) {
280                 int beg = lengths[BEG0 + wh];
281                 int end = lengths[END0 + wh];
282                 if (i &gt;= beg &amp;&amp; i &lt; end) {
283                     lengths[HINT] = wh;
284                     return wh;
285                 }
286             }
287             if (hint == 0) {
288                 return size();  // end of the line
289             }
290         }
291     }
292 
293     public char charAt(int i) {
294         if (i &lt; 0) {
295             return &quot;&quot;.charAt(i);
296         }
297         int wh = which(i);
298         int beg = lengths[BEG0 + wh];
299         int j = i - beg;
300         int sepLength = separator.length();
301         if (j &lt; sepLength) {
302             return separator.charAt(j);
303         }
304         return getCS(wh).charAt(j - sepLength);
305     }
306 
307     public CharSequence subSequence(int beg, int end) {
308         //System.out.println(&quot;i: &quot;+beg+&quot;..&quot;+end);
309         if (beg == end) {
310             return &quot;&quot;;
311         }
312         if (beg &lt; 0) {
313             charAt(beg);  // raise exception
314         }
315         if (beg &gt; end) {
316             charAt(-1);   // raise exception
317         }
318         int begWh = which(beg);
319         int endWh = which(end);
320         if (endWh == size() || end == lengths[BEG0 + endWh]) {
321             --endWh;
322         }
323         //System.out.println(&quot;wh: &quot;+begWh+&quot;..&quot;+endWh);
324         int begBase = lengths[BEG0 + begWh];
325         int endBase = lengths[BEG0 + endWh];
326         int sepLength = separator.length();
327         int begFrag = 0;
328         if ((beg - begBase) &lt; sepLength) {
329             begFrag = sepLength - (beg - begBase);
330             beg += begFrag;
331         }
332         int endFrag = 0;
333         if ((end - endBase) &lt; sepLength) {
334             endFrag = (end - endBase);
335             end = endBase;
336             endBase = lengths[BEG0 + --endWh];
337         }
338         if (false) {
339             System.out.print(&quot;beg[wbf]end[wbf]&quot;);
340             int pr[] = {begWh, begBase, begFrag, beg, endWh, endBase, endFrag, end};
341             for (int k = 0; k &lt; pr.length; k++) {
342                 System.out.print((k == 4 ? &quot;   &quot; : &quot; &quot;) + (pr[k]));
343             }
344             System.out.println();
345         }
346         if (begFrag &gt; 0 &amp;&amp; (end + endFrag) - begBase &lt;= sepLength) {
347             // Special case:  Slice the separator.
348             beg -= begFrag;
349             end += endFrag;
350             return separator.substring(beg - begBase, end - begBase);
351         }
352         if (begWh == endWh &amp;&amp; (begFrag + endFrag) == 0) {
353             // Special case:  Slice a single token.
354             return getCS(begWh).subSequence(beg - begBase - sepLength,
355                     end - endBase - sepLength);
356         }
357         Object[] subTokens = new Object[1 + (endWh - begWh) + 1];
358         int fillp = 0;
359         if (begFrag == sepLength) {
360             // Insert a leading null token to force an initial separator.
361             subTokens[fillp++] = &quot;&quot;;
362             begFrag = 0;
363         }
364         for (int wh = begWh; wh &lt;= endWh; wh++) {
365             CharSequence cs = getCS(wh);
366             if (wh == begWh || wh == endWh) {
367                 // Slice it.
368                 int csBeg = (wh == begWh) ? (beg - begBase) - sepLength : 0;
369                 int csEnd = (wh == endWh) ? (end - endBase) - sepLength : cs.length();
370                 cs = cs.subSequence(csBeg, csEnd);
371                 if (begFrag &gt; 0 &amp;&amp; wh == begWh) {
372                     cs = separator.substring(sepLength - begFrag) + cs;
373                 }
374                 if (endFrag &gt; 0 &amp;&amp; wh == endWh) {
375                     cs = cs.toString() + separator.substring(0, endFrag);
376                 }
377             }
378             subTokens[fillp++] = cs;
379         }
380         return new TokenList(subTokens, 0, fillp, separator);
381     }
382 
383     /** Returns the concatenation of all tokens,
384      *  with intervening separator characters.
385      */
386     public String toString() {
387         StringBuilder buf = new StringBuilder(length());
388         int size = this.size();
389         for (int i = 0; i &lt; size; i++) {
390             if (i &gt; 0) {
391                 buf.append(separator);
392             }
393             buf.append(get(i));
394         }
395         return buf.toString();
396     }
397 
398     /*---- TESTING CODE ----
399     public static void main(String[] av) {
400     if (av.length == 0)  av = new String[]{&quot;one&quot;, &quot;2&quot;, &quot;&quot;, &quot;four&quot;};
401     TokenList ts = new TokenList();
402     final String SEP = &quot;, &quot;;
403     ts.setSeparator(SEP);
404     for (int i = -1; i &lt; av.length; i++) {
405     if (i &gt;= 0)  ts.addToken(av[i]);
406     {
407     TokenList tsCopy = new TokenList(ts.toString(), SEP);
408     if (!tsCopy.equals(ts)) {
409     tsCopy.setSeparator(&quot;)(&quot;);
410     System.out.println(&quot;!= (&quot;+tsCopy+&quot;)&quot;);
411     }
412     }
413     {
414     TokenList tsBar = new TokenList(ts, &quot;|&quot;);
415     tsBar.add(0, &quot;[&quot;);
416     tsBar.add(&quot;]&quot;);
417     System.out.println(tsBar);
418     }
419     if (false) {
420     int[] ls = ts.getLengths();
421     System.out.println(&quot;ts: &quot;+ts);
422     System.out.print(&quot;ls: {&quot;);
423     for (int j = 0; j &lt; ls.length; j++)  System.out.print(&quot; &quot;+ls[j]);
424     System.out.println(&quot; }&quot;);
425     }
426     assert0(ts.size() == i+1);
427     assert0(i &lt; 0 || ts.get(i) == av[i]);
428     String tss = ts.toString();
429     int tslen = tss.length();
430     assert0(ts.length() == tss.length());
431     for (int n = 0; n &lt; tslen; n++) {
432     assert0(ts.charAt(n) == tss.charAt(n));
433     }
434     for (int j = 0; j &lt; tslen; j++) {
435     for (int k = tslen; k &gt;= j; k--) {
436     CharSequence sub = ts.subSequence(j, k);
437     //System.out.println(&quot;|&quot;+sub+&quot;|&quot;);
438     assert0(sub.toString().equals(tss.substring(j, k)));
439     }
440     }
441     }
442     }
443     static void assert0(boolean z) {
444     if (!z)  throw new RuntimeException(&quot;assert failed&quot;);
445     }
446     // ---- TESTING CODE ----*/
447 }
    </pre>
  </body>
</html>
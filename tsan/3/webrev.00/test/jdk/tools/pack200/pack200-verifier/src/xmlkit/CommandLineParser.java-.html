<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old test/jdk/tools/pack200/pack200-verifier/src/xmlkit/CommandLineParser.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2010, 2018, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 package xmlkit; // -*- mode: java; indent-tabs-mode: nil -*-
 24 
 25 import java.util.*;
 26 /*
 27  * @author jrose
 28  */
 29 public class CommandLineParser {
 30 
 31     public CommandLineParser(String optionString) {
 32         setOptionMap(optionString);
 33     }
 34     TreeMap&lt;String, String[]&gt; optionMap;
 35 
 36     public void setOptionMap(String options) {
 37         // Convert options string into optLines dictionary.
 38         TreeMap&lt;String, String[]&gt; optmap = new TreeMap&lt;String, String[]&gt;();
 39         loadOptmap:
 40         for (String optline : options.split(&quot;\n&quot;)) {
 41             String[] words = optline.split(&quot;\\p{Space}+&quot;);
 42             if (words.length == 0) {
 43                 continue loadOptmap;
 44             }
 45             String opt = words[0];
 46             words[0] = &quot;&quot;;  // initial word is not a spec
 47             if (opt.length() == 0 &amp;&amp; words.length &gt;= 1) {
 48                 opt = words[1];  // initial &quot;word&quot; is empty due to leading &#39; &#39;
 49                 words[1] = &quot;&quot;;
 50             }
 51             if (opt.length() == 0) {
 52                 continue loadOptmap;
 53             }
 54             String[] prevWords = optmap.put(opt, words);
 55             if (prevWords != null) {
 56                 throw new RuntimeException(&quot;duplicate option: &quot;
 57                         + optline.trim());
 58             }
 59         }
 60         optionMap = optmap;
 61     }
 62 
 63     public String getOptionMap() {
 64         TreeMap&lt;String, String[]&gt; optmap = optionMap;
 65         StringBuffer sb = new StringBuffer();
 66         for (String opt : optmap.keySet()) {
 67             sb.append(opt);
 68             for (String spec : optmap.get(opt)) {
 69                 sb.append(&#39; &#39;).append(spec);
 70             }
 71             sb.append(&#39;\n&#39;);
 72         }
 73         return sb.toString();
 74     }
 75 
 76     /**
 77      * Remove a set of command-line options from args,
 78      * storing them in the properties map in a canonicalized form.
 79      */
 80     public String parse(List&lt;String&gt; args, Map&lt;String, String&gt; properties) {
 81         //System.out.println(args+&quot; // &quot;+properties);
 82 
 83         String resultString = null;
 84         TreeMap&lt;String, String[]&gt; optmap = optionMap;
 85 
 86         // State machine for parsing a command line.
 87         ListIterator&lt;String&gt; argp = args.listIterator();
 88         ListIterator&lt;String&gt; pbp = new ArrayList&lt;String&gt;().listIterator();
 89         doArgs:
 90         for (;;) {
 91             // One trip through this loop per argument.
 92             // Multiple trips per option only if several options per argument.
 93             String arg;
 94             if (pbp.hasPrevious()) {
 95                 arg = pbp.previous();
 96                 pbp.remove();
 97             } else if (argp.hasNext()) {
 98                 arg = argp.next();
 99             } else {
100                 // No more arguments at all.
101                 break doArgs;
102             }
103             tryOpt:
104             for (int optlen = arg.length();; optlen--) {
105                 // One time through this loop for each matching arg prefix.
106                 String opt;
107                 // Match some prefix of the argument to a key in optmap.
108                 findOpt:
109                 for (;;) {
110                     opt = arg.substring(0, optlen);
111                     if (optmap.containsKey(opt)) {
112                         break findOpt;
113                     }
114                     if (optlen == 0) {
115                         break tryOpt;
116                     }
117                     // Decide on a smaller prefix to search for.
118                     SortedMap&lt;String, String[]&gt; pfxmap = optmap.headMap(opt);
119                     // pfxmap.lastKey is no shorter than any prefix in optmap.
120                     int len = pfxmap.isEmpty() ? 0 : pfxmap.lastKey().length();
121                     optlen = Math.min(len, optlen - 1);
122                     opt = arg.substring(0, optlen);
123                     // (Note:  We could cut opt down to its common prefix with
124                     // pfxmap.lastKey, but that wouldn&#39;t save many cycles.)
125                 }
126                 opt = opt.intern();
127                 assert (arg.startsWith(opt));
128                 assert (opt.length() == optlen);
129                 String val = arg.substring(optlen);  // arg == opt+val
130 
131                 // Execute the option processing specs for this opt.
132                 // If no actions are taken, then look for a shorter prefix.
133                 boolean didAction = false;
134                 boolean isError = false;
135 
136                 int pbpMark = pbp.nextIndex();  // in case of backtracking
137                 String[] specs = optmap.get(opt);
138                 eachSpec:
139                 for (String spec : specs) {
140                     if (spec.length() == 0) {
141                         continue eachSpec;
142                     }
143                     if (spec.startsWith(&quot;#&quot;)) {
144                         break eachSpec;
145                     }
146                     int sidx = 0;
147                     char specop = spec.charAt(sidx++);
148 
149                     // Deal with &#39;+&#39;/&#39;*&#39; prefixes (spec conditions).
150                     boolean ok;
151                     switch (specop) {
152                         case &#39;+&#39;:
153                             // + means we want an non-empty val suffix.
154                             ok = (val.length() != 0);
155                             specop = spec.charAt(sidx++);
156                             break;
157                         case &#39;*&#39;:
158                             // * means we accept empty or non-empty
159                             ok = true;
160                             specop = spec.charAt(sidx++);
161                             break;
162                         default:
163                             // No condition prefix means we require an exact
164                             // match, as indicated by an empty val suffix.
165                             ok = (val.length() == 0);
166                             break;
167                     }
168                     if (!ok) {
169                         continue eachSpec;
170                     }
171 
172                     String specarg = spec.substring(sidx);
173                     switch (specop) {
174                         case &#39;.&#39;:  // terminate the option sequence
175                             resultString = (specarg.length() != 0) ? specarg.intern() : opt;
176                             break doArgs;
177                         case &#39;?&#39;:  // abort the option sequence
178                             resultString = (specarg.length() != 0) ? specarg.intern() : arg;
179                             isError = true;
180                             break eachSpec;
181                         case &#39;@&#39;:  // change the effective opt name
182                             opt = specarg.intern();
183                             break;
184                         case &#39;&gt;&#39;:  // shift remaining arg val to next arg
185                             pbp.add(specarg + val);  // push a new argument
186                             val = &quot;&quot;;
187                             break;
188                         case &#39;!&#39;:  // negation option
189                             String negopt = (specarg.length() != 0) ? specarg.intern() : opt;
190                             properties.remove(negopt);
191                             properties.put(negopt, null);  // leave placeholder
192                             didAction = true;
193                             break;
194                         case &#39;$&#39;:  // normal &quot;boolean&quot; option
195                             String boolval;
196                             if (specarg.length() != 0) {
197                                 // If there is a given spec token, store it.
198                                 boolval = specarg;
199                             } else {
200                                 String old = properties.get(opt);
201                                 if (old == null || old.length() == 0) {
202                                     boolval = &quot;1&quot;;
203                                 } else {
204                                     // Increment any previous value as a numeral.
205                                     boolval = &quot;&quot; + (1 + Integer.parseInt(old));
206                                 }
207                             }
208                             properties.put(opt, boolval);
209                             didAction = true;
210                             break;
211                         case &#39;=&#39;:  // &quot;string&quot; option
212                         case &#39;&amp;&#39;:  // &quot;collection&quot; option
213                             // Read an option.
214                             boolean append = (specop == &#39;&amp;&#39;);
215                             String strval;
216                             if (pbp.hasPrevious()) {
217                                 strval = pbp.previous();
218                                 pbp.remove();
219                             } else if (argp.hasNext()) {
220                                 strval = argp.next();
221                             } else {
222                                 resultString = arg + &quot; ?&quot;;
223                                 isError = true;
224                                 break eachSpec;
225                             }
226                             if (append) {
227                                 String old = properties.get(opt);
228                                 if (old != null) {
229                                     // Append new val to old with embedded delim.
230                                     String delim = specarg;
231                                     if (delim.length() == 0) {
232                                         delim = &quot; &quot;;
233                                     }
234                                     strval = old + specarg + strval;
235                                 }
236                             }
237                             properties.put(opt, strval);
238                             didAction = true;
239                             break;
240                         default:
241                             throw new RuntimeException(&quot;bad spec for &quot;
242                                     + opt + &quot;: &quot; + spec);
243                     }
244                 }
245 
246                 // Done processing specs.
247                 if (didAction &amp;&amp; !isError) {
248                     continue doArgs;
249                 }
250 
251                 // The specs should have done something, but did not.
252                 while (pbp.nextIndex() &gt; pbpMark) {
253                     // Remove anything pushed during these specs.
254                     pbp.previous();
255                     pbp.remove();
256                 }
257 
258                 if (isError) {
259                     throw new IllegalArgumentException(resultString);
260                 }
261 
262                 if (optlen == 0) {
263                     // We cannot try a shorter matching option.
264                     break tryOpt;
265                 }
266             }
267 
268             // If we come here, there was no matching option.
269             // So, push back the argument, and return to caller.
270             pbp.add(arg);
271             break doArgs;
272         }
273         // Report number of arguments consumed.
274         args.subList(0, argp.nextIndex()).clear();
275         // Report any unconsumed partial argument.
276         while (pbp.hasPrevious()) {
277             args.add(0, pbp.previous());
278         }
279         //System.out.println(args+&quot; // &quot;+properties+&quot; -&gt; &quot;+resultString);
280         return resultString;
281     }
282 }
    </pre>
  </body>
</html>
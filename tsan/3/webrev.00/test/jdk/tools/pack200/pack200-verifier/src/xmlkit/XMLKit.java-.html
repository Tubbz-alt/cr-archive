<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old test/jdk/tools/pack200/pack200-verifier/src/xmlkit/XMLKit.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 2010, 2018, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  */
  23 package xmlkit; // -*- mode: java; indent-tabs-mode: nil -*-
  24 
  25 // XML Implementation packages:
  26 import java.util.*;
  27 
  28 import java.io.Reader;
  29 import java.io.Writer;
  30 import java.io.OutputStream;
  31 import java.io.InputStreamReader;
  32 import java.io.OutputStreamWriter;
  33 import java.io.BufferedReader;
  34 import java.io.PrintWriter;
  35 import java.io.StringWriter;
  36 import java.io.StringReader;
  37 
  38 import java.io.IOException;
  39 
  40 import org.xml.sax.XMLReader;
  41 import org.xml.sax.InputSource;
  42 import org.xml.sax.ContentHandler;
  43 import org.xml.sax.SAXException;
  44 import org.xml.sax.SAXParseException;
  45 import org.xml.sax.Attributes;
  46 import org.xml.sax.ext.LexicalHandler;
  47 import org.xml.sax.helpers.AttributesImpl;
  48 
  49 /**
  50  * A kit of methods and classes useful for manipulating XML trees in
  51  * memory. They are very compact and easy to use. An XML element
  52  * occupies six pointers of overhead (like two arrays) plus a pointer
  53  * for its name, each attribute name and value, and each sub-element.
  54  * Many useful XML operations (or Lisp-like calls) can be accomplished
  55  * with a single method call on an element itself.
  56  * &lt;p&gt;
  57  * There is strong integration with the Java collection classes.
  58  * There are viewing and conversion operators to and from various
  59  * collection types. Elements directly support list iterators.
  60  * Most &lt;tt&gt;List&lt;/tt&gt; methods work analogously on elements.
  61  * &lt;p&gt;
  62  * Because of implementation compromises, these XML trees are less
  63  * functional than many standard XML classes.
  64  * &lt;ul&gt;
  65  * &lt;li&gt;There are no parent or sibling pointers in the tree.&lt;/li&gt;
  66  * &lt;li&gt;Attribute names are simple strings, with no namespaces.&lt;/li&gt;
  67  * &lt;li&gt;There is no internal support for schemas or validation.&lt;/li&gt;
  68  * &lt;/ul&gt;
  69  * &lt;p&gt;
  70  * Here is a summary of functionality in &lt;tt&gt;XMLKit&lt;/tt&gt;.
  71  * (Overloaded groups of methods are summarized by marking some
  72  * arguments optional with their default values. Some overloaded
  73  * arguments are marked with their alternative types separated by
  74  * a bar &quot;|&quot;. Arguments or return values for which a null is
  75  * specially significant are marked by an alternative &quot;|null&quot;.
  76  * Accessors which have corresponding setters are marked
  77  * by &quot;/set&quot;. Removers which have corresponding retainers are marked
  78  * by &quot;/retain&quot;.)
  79  * &lt;pre&gt;
  80  * --- element construction
  81  * new Element(int elemCapacity=4), String name=&quot;&quot;
  82  * new Element(String name, String[] attrs={}, Element[] elems={}, int elemCapacity=4)
  83  * new Element(String name, String[] attrs, Object[] elems, int elemCapacity=4)
  84  * new Element(Element original) // shallow copy
  85  * new Element(String name=&quot;&quot;, Collection elems) // coercion
  86  *
  87  * Element shallowCopy()
  88  * Element shallowFreeze() // side-effecting
  89  * Element deepCopy()
  90  * Element deepFreeze() // not side-effecting
  91  *
  92  * EMPTY // frozen empty anonymous element
  93  * void ensureExtraCapacity(int)
  94  * void trimToSize()
  95  * void sortAttrs() // sort by key
  96  *
  97  * --- field accessors
  98  * String getName()/set
  99  * int size()
 100  * boolean isEmpty()
 101  * boolean isFrozen()
 102  * boolean isAnonymous()
 103  * int getExtraCapacity()/set
 104  * int attrSize()
 105  *
 106  * --- attribute accessors
 107  * String getAttr(int i)/set
 108  * String getAttrName(int i)
 109  *
 110  * String getAttr(String key)/set
 111  * List getAttrList(String key)/set
 112  * Number getAttrNumber(String key)/set
 113  * long getAttrLong(String key)/set
 114  * double getAttrDouble(String key)/set
 115  *
 116  * String getAttr(String key, String dflt=null)
 117  * long getAttrLong(String key, long dflt=0)
 118  * double getAttrDouble(String key, double dflt=0)
 119  *
 120  * Element copyAttrsOnly()
 121  * Element getAttrs()/set =&amp;gt; &lt;em&gt;&amp;lt;&amp;gt;&amp;lt;key&amp;gt;value&amp;lt;/key&amp;gt;...&amp;lt;/&amp;gt;&lt;/em&gt;
 122  * void addAttrs(Element attrs)
 123  *
 124  * void removeAttr(int i)
 125  * void clearAttrs()
 126  *
 127  * --- element accessors
 128  * Object get(int i)/set
 129  * Object getLast() | null
 130  * Object[] toArray()
 131  * Element copyContentOnly()
 132  *
 133  * void add(int i=0, Object subElem)
 134  * int addAll(int i=0, Collection | Element elems)
 135  * int addContent(int i=0, TokenList|Element|Object|null)
 136  * void XMLKit.addContent(TokenList|Element|Object|null, Collection sink|null)
 137  *
 138  * void clear(int beg=0, int end=size)
 139  * void sort(Comparator=contentOrder())
 140  * void reverse()
 141  * void shuffle(Random rnd=(anonymous))
 142  * void rotate(int distance)
 143  * Object min/max(Comparator=contentOrder())
 144  *
 145  * --- text accessors
 146  * CharSequence getText()/set
 147  * CharSequence getUnmarkedText()
 148  * int addText(int i=size, CharSequence)
 149  * void trimText();
 150  *
 151  * --- views
 152  * List asList() // element view
 153  * ListIterator iterator()
 154  * PrintWriter asWriter()
 155  * Map asAttrMap()
 156  * Iterable&lt;CharSequence&gt; texts()
 157  * Iterable&lt;Element&gt; elements()
 158  * Iterable&lt;T&gt; partsOnly(Class&lt;T&gt;)
 159  * String[] toStrings()
 160  *
 161  * --- queries
 162  * boolean equals(Element | Object)
 163  * int compareTo(Element | Object)
 164  * boolean equalAttrs(Element)
 165  * int hashCode()
 166  * boolean isText() // every sub-elem is CharSequence
 167  * boolean hasText() // some sub-elem is CharSequence
 168  *
 169  * boolean contains(Object)
 170  * boolean containsAttr(String)
 171  *
 172  * int indexOf(Object)
 173  * int indexOf(Filter, int fromIndex=0)
 174  * int lastIndexOf(Object)
 175  * int lastIndexOf(Filter, int fromIndex=size-1)
 176  *
 177  * int indexOfAttr(String)
 178  *
 179  * // finders, removers, and replacers do addContent of each filtered value
 180  * // (i.e., TokenLists and anonymous Elements are broken out into their parts)
 181  * boolean matches(Filter)
 182  *
 183  * Object find(Filter, int fromIndex=0)
 184  * Object findLast(Filter, int fromIndex=size-1)
 185  * Element findAll(Filter, int fromIndex=0 &amp;amp; int toIndex=size)
 186  * int findAll(Filter, Collection sink | null, int fromIndex=0 &amp;amp; int toIndex=size)
 187  *
 188  * Element removeAllInTree(Filter)/retain
 189  * int findAllInTree(Filter, Collection sink | null)
 190  * int countAllInTree(Filter)
 191  * Element removeAllInTree(Filter)/retain
 192  * int removeAllInTree(Filter, Collection sink | null)/retain
 193  * void replaceAllInTree(Filter)
 194  *
 195  * Element findElement(String name=any)
 196  * Element findAllElements(String name=any)
 197  *
 198  * Element findWithAttr(String key, String value=any)
 199  * Element findAllWithAttr(String key, String value=any)
 200  *
 201  * Element removeElement(String name=any)
 202  * Element removeAllElements(String name=any)/retain
 203  *
 204  * Element removeWithAttr(String key, String value=any)
 205  * Element removeAllWithAttr(String key, String value=any)/retain
 206  *
 207  * //countAll is the same as findAll but with null sink
 208  * int countAll(Filter)
 209  * int countAllElements(String name=any)
 210  * int countAllWithAttr(String key, String value=any)
 211  *
 212  * void replaceAll(Filter, int fromIndex=0 &amp;amp; int toIndex=size)
 213  * void replaceAllInTree(Filter)
 214  * void XMLKit.replaceAll(Filter, List target) //if(fx){remove x;addContent fx}
 215  *
 216  * --- element mutators
 217  * boolean remove(Object)
 218  * Object remove(int)
 219  * Object removeLast() | null
 220  *
 221  * Object remove(Filter, int fromIndex=0)
 222  * Object removeLast(Filter, int fromIndex=size-1)
 223  * Element sink = removeAll(Filter, int fromIndex=0 &amp;amp; int toIndex=size)/retain
 224  * int count = removeAll(Filter, int fromIndex=0 &amp;amp; int toIndex=size, Collection sink | null)/retain
 225  *
 226  * Element removeAllElements(String name=any)
 227  *
 228  * --- attribute mutators
 229  * ??int addAllAttrsFrom(Element attrSource)
 230  *
 231  * --- parsing and printing
 232  * void tokenize(String delims=whitespace, returnDelims=false)
 233  * void writeTo(Writer)
 234  * void writePrettyTo(Writer)
 235  * String prettyString()
 236  * String toString()
 237  *
 238  * ContentHandler XMLKit.makeBuilder(Collection sink, tokenizing=false, makeFrozen=false) // for standard XML parser
 239  * Element XMLKit.readFrom(Reader, tokenizing=false, makeFrozen=false)
 240  * void XMLKit.prettyPrintTo(Writer | OutputStream, Element)
 241  * class XMLKit.Printer(Writer) { void print/Recursive(Element) }
 242  * void XMLKit.output(Object elem, ContentHandler, LexicalHandler=null)
 243  * void XMLKit.writeToken(String, char quote, Writer)
 244  * void XMLKit.writeCData(String, Writer)
 245  * Number XMLKit.convertToNumber(String, Number dflt=null)
 246  * long XMLKit.convertToLong(String, long dflt=0)
 247  * double XMLKit.convertToDouble(String, double dflt=0)
 248  *
 249  * --- filters
 250  * XMLKit.ElementFilter { Element filter(Element) }
 251  * XMLKit.elementFilter(String name=any | Collection nameSet)
 252  * XMLKit.AttrFilter(String key) { boolean test(String value) }
 253  * XMLKit.attrFilter(String key, String value=any)
 254  * XMLKit.attrFilter(Element matchThis, String key)
 255  * XMLKit.classFilter(Class)
 256  * XMLKit.textFilter() // matches any CharSequence
 257  * XMLKit.specialFilter() // matches any Special element
 258  * XMLKit.methodFilter(Method m, Object[] args=null, falseResult=null)
 259  * XMLKit.testMethodFilter(Method m, Object[] args=null)
 260  * XMLKit.not(Filter) // inverts sense of Filter
 261  * XMLKit.and(Filter&amp;amp;Filter | Filter[])
 262  * XMLKit.or(Filter&amp;amp;Filter | Filter[])
 263  * XMLKit.stack(Filter&amp;amp;Filter | Filter[]) // result is (fx &amp;&amp; g(fx))
 264  * XMLKit.content(Filter, Collection sink) // copies content to sink
 265  * XMLKit.replaceInTree(Filter pre, Filter post=null) // pre-replace else recur
 266  * XMLKit.findInTree(Filter pre, Collection sink=null) // pre-find else recur
 267  * XMLKit.nullFilter() // ignores input, always returns null (i.e., false)
 268  * XMLKit.selfFilter( ) // always returns input (i.e., true)
 269  * XMLKit.emptyFilter() // ignores input, always returns EMPTY
 270  * XMLKit.constantFilter(Object) // ignores input, always returns constant
 271  *
 272  * --- misc
 273  * Comparator XMLKit.contentOrder() // for comparing/sorting mixed content
 274  * Method XMLKit.Element.method(String name) // returns Element method
 275  * &lt;/pre&gt;
 276  *
 277  * @author jrose
 278  */
 279 public abstract class XMLKit {
 280 
 281     private XMLKit() {
 282     }
 283     // We need at least this much slop if the element is to stay unfrozen.
 284     static final int NEED_SLOP = 1;
 285     static final Object[] noPartsFrozen = {};
 286     static final Object[] noPartsNotFrozen = new Object[NEED_SLOP];
 287     static final String WHITESPACE_CHARS = &quot; \t\n\r\f&quot;;
 288     static final String ANON_NAME = new String(&quot;*&quot;);  // unique copy of &quot;*&quot;
 289 
 290     public static final class Element implements Comparable&lt;Element&gt;, Iterable&lt;Object&gt; {
 291         // Note:  Does not implement List, because it has more
 292         // significant parts besides its sub-elements.  Therefore,
 293         // hashCode and equals must be more distinctive than Lists.
 294 
 295         // &lt;name&gt; of element
 296         String name;
 297         // number of child elements, in parts[0..size-1]
 298         int size;
 299         // The parts start with child elements::  {e0, e1, e2, ...}.
 300         // Following that are optional filler elements, all null.
 301         // Following that are attributes as key/value pairs.
 302         // They are in reverse: {...key2, val2, key1, val1, key0, val0}.
 303         // Child elements and attr keys and values are never null.
 304         Object[] parts;
 305 
 306         // Build a partially-constructed node.
 307         // Caller is responsible for initializing promised attributes.
 308         Element(String name, int size, int capacity) {
 309             this.name = name.toString();
 310             this.size = size;
 311             assert (size &lt;= capacity);
 312             this.parts = capacity &gt; 0 ? new Object[capacity] : noPartsFrozen;
 313         }
 314 
 315         /** An anonymous, empty element.
 316          *  Optional elemCapacity argument is expected number of sub-elements.
 317          */
 318         public Element() {
 319             this(ANON_NAME, 0, NEED_SLOP + 4);
 320         }
 321 
 322         public Element(int extraCapacity) {
 323             this(ANON_NAME, 0, NEED_SLOP + Math.max(0, extraCapacity));
 324         }
 325 
 326         /** An empty element with the given name.
 327          *  Optional extraCapacity argument is expected number of sub-elements.
 328          */
 329         public Element(String name) {
 330             this(name, 0, NEED_SLOP + 4);
 331         }
 332 
 333         public Element(String name, int extraCapacity) {
 334             this(name, 0, NEED_SLOP + Math.max(0, extraCapacity));
 335         }
 336 
 337         /** An empty element with the given name and attributes.
 338          *  Optional extraCapacity argument is expected number of sub-elements.
 339          */
 340         public Element(String name, String... attrs) {
 341             this(name, attrs, (Element[]) null, 0);
 342         }
 343 
 344         public Element(String name, String[] attrs, int extraCapacity) {
 345             this(name, attrs, (Element[]) null, extraCapacity);
 346         }
 347 
 348         /** An empty element with the given name and sub-elements.
 349          *  Optional extraCapacity argument is expected extra sub-elements.
 350          */
 351         public Element(String name, Element... elems) {
 352             this(name, (String[]) null, elems, 0);
 353         }
 354 
 355         public Element(String name, Element[] elems, int extraCapacity) {
 356             this(name, (String[]) null, elems, extraCapacity);
 357         }
 358 
 359         /** An empty element with the given name, attributes, and sub-elements.
 360          *  Optional extraCapacity argument is expected extra sub-elements.
 361          */
 362         public Element(String name, String[] attrs, Object... elems) {
 363             this(name, attrs, elems, 0);
 364         }
 365 
 366         public Element(String name, String[] attrs, Object[] elems, int extraCapacity) {
 367             this(name, 0,
 368                     ((elems == null) ? 0 : elems.length)
 369                     + Math.max(0, extraCapacity)
 370                     + NEED_SLOP
 371                     + ((attrs == null) ? 0 : attrs.length));
 372             int ne = ((elems == null) ? 0 : elems.length);
 373             int na = ((attrs == null) ? 0 : attrs.length);
 374             int fillp = 0;
 375             for (int i = 0; i &lt; ne; i++) {
 376                 if (elems[i] != null) {
 377                     parts[fillp++] = elems[i];
 378                 }
 379             }
 380             size = fillp;
 381             for (int i = 0; i &lt; na; i += 2) {
 382                 setAttr(attrs[i + 0], attrs[i + 1]);
 383             }
 384         }
 385 
 386         public Element(Collection c) {
 387             this(c.size());
 388             addAll(c);
 389         }
 390 
 391         public Element(String name, Collection c) {
 392             this(name, c.size());
 393             addAll(c);
 394         }
 395 
 396         /** Shallow copy.  Same as old.shallowCopy().
 397          *  Optional extraCapacity argument is expected extra sub-elements.
 398          */
 399         public Element(Element old) {
 400             this(old, 0);
 401         }
 402 
 403         public Element(Element old, int extraCapacity) {
 404             this(old.name, old.size,
 405                     old.size
 406                     + Math.max(0, extraCapacity) + NEED_SLOP
 407                     + old.attrLength());
 408             // copy sub-elements
 409             System.arraycopy(old.parts, 0, parts, 0, size);
 410             int alen = parts.length
 411                     - (size + Math.max(0, extraCapacity) + NEED_SLOP);
 412             // copy attributes
 413             System.arraycopy(old.parts, old.parts.length - alen,
 414                     parts, parts.length - alen,
 415                     alen);
 416             assert (!isFrozen());
 417         }
 418 
 419         /** Shallow copy.  Same as new Element(this). */
 420         public Element shallowCopy() {
 421             return new Element(this);
 422         }
 423         static public final Element EMPTY = new Element(ANON_NAME, 0, 0);
 424 
 425         Element deepFreezeOrCopy(boolean makeFrozen) {
 426             if (makeFrozen &amp;&amp; isFrozen()) {
 427                 return this;  // no need to copy it
 428             }
 429             int alen = attrLength();
 430             int plen = size + (makeFrozen ? 0 : NEED_SLOP) + alen;
 431             Element copy = new Element(name, size, plen);
 432             // copy attributes
 433             System.arraycopy(parts, parts.length - alen, copy.parts, plen - alen, alen);
 434             // copy sub-elements
 435             for (int i = 0; i &lt; size; i++) {
 436                 Object e = parts[i];
 437                 String str;
 438                 if (e instanceof Element) {  // recursion is common case
 439                     e = ((Element) e).deepFreezeOrCopy(makeFrozen);
 440                 } else if (makeFrozen) {
 441                     // Freeze StringBuffers, etc.
 442                     e = fixupString(e);
 443                 }
 444                 copy.setRaw(i, e);
 445             }
 446             return copy;
 447         }
 448 
 449         /** Returns new Element(this), and also recursively copies sub-elements. */
 450         public Element deepCopy() {
 451             return deepFreezeOrCopy(false);
 452         }
 453 
 454         /** Returns frozen version of deepCopy. */
 455         public Element deepFreeze() {
 456             return deepFreezeOrCopy(true);
 457         }
 458 
 459         /** Freeze this element.
 460          *  Throw an IllegalArgumentException if any sub-element is not already frozen.
 461          *  (Use deepFreeze() to make a frozen copy of an entire element tree.)
 462          */
 463         public void shallowFreeze() {
 464             if (isFrozen()) {
 465                 return;
 466             }
 467             int alen = attrLength();
 468             Object[] nparts = new Object[size + alen];
 469             // copy attributes
 470             System.arraycopy(parts, parts.length - alen, nparts, size, alen);
 471             // copy sub-elements
 472             for (int i = 0; i &lt; size; i++) {
 473                 Object e = parts[i];
 474                 String str;
 475                 if (e instanceof Element) {  // recursion is common case
 476                     if (!((Element) e).isFrozen()) {
 477                         throw new IllegalArgumentException(&quot;Sub-element must be frozen.&quot;);
 478                     }
 479                 } else {
 480                     // Freeze StringBuffers, etc.
 481                     e = fixupString(e);
 482                 }
 483                 nparts[i] = e;
 484             }
 485             parts = nparts;
 486             assert (isFrozen());
 487         }
 488 
 489         /** Return the name of this element. */
 490         public String getName() {
 491             return name;
 492         }
 493 
 494         /** Change the name of this element. */
 495         public void setName(String name) {
 496             checkNotFrozen();
 497             this.name = name.toString();
 498         }
 499 
 500         /** Reports if the element&#39;s name is a particular string (spelled &quot;*&quot;).
 501          *  Such elements are created by the nullary Element constructor,
 502          *  and by query functions which return multiple values,
 503          *  such as &lt;tt&gt;findAll&lt;/tt&gt;.
 504          */
 505         public boolean isAnonymous() {
 506             return name == ANON_NAME;
 507         }
 508 
 509         /** Return number of elements.  (Does not include attributes.) */
 510         public int size() {
 511             return size;
 512         }
 513 
 514         /** True if no elements.  (Does not consider attributes.) */
 515         public boolean isEmpty() {
 516             return size == 0;
 517         }
 518 
 519         /** True if this element does not allow modification. */
 520         public boolean isFrozen() {
 521             // It is frozen iff there is no slop space.
 522             return !hasNulls(NEED_SLOP);
 523         }
 524 
 525         void checkNotFrozen() {
 526             if (isFrozen()) {
 527                 throw new UnsupportedOperationException(&quot;cannot modify frozen element&quot;);
 528             }
 529         }
 530 
 531         /** Remove specified elements.  (Does not affect attributes.) */
 532         public void clear() {
 533             clear(0, size);
 534         }
 535 
 536         public void clear(int beg) {
 537             clear(beg, size);
 538         }
 539 
 540         public void clear(int beg, int end) {
 541             if (end &gt; size) {
 542                 badIndex(end);
 543             }
 544             if (beg &lt; 0 || beg &gt; end) {
 545                 badIndex(beg);
 546             }
 547             if (beg == end) {
 548                 return;
 549             }
 550             checkNotFrozen();
 551             if (end == size) {
 552                 if (beg == 0
 553                         &amp;&amp; parts.length &gt; 0 &amp;&amp; parts[parts.length - 1] == null) {
 554                     // If no attributes, free the parts array.
 555                     parts = noPartsNotFrozen;
 556                     size = 0;
 557                 } else {
 558                     clearParts(beg, size);
 559                     size = beg;
 560                 }
 561             } else {
 562                 close(beg, end - beg);
 563             }
 564         }
 565 
 566         void clearParts(int beg, int end) {
 567             for (int i = beg; i &lt; end; i++) {
 568                 parts[i] = null;
 569             }
 570         }
 571 
 572         /** True if name, attributes, and elements are the same. */
 573         public boolean equals(Element that) {
 574             if (!this.name.equals(that.name)) {
 575                 return false;
 576             }
 577             if (this.size != that.size) {
 578                 return false;
 579             }
 580             // elements must be equal and ordered
 581             Object[] thisParts = this.parts;
 582             Object[] thatParts = that.parts;
 583             for (int i = 0; i &lt; size; i++) {
 584                 Object thisPart = thisParts[i];
 585                 Object thatPart = thatParts[i];
 586 
 587                 if (thisPart instanceof Element) { // recursion is common case
 588                     if (!thisPart.equals(thatPart)) {
 589                         return false;
 590                     }
 591                 } else {
 592                     // If either is a non-string char sequence, normalize it.
 593                     thisPart = fixupString(thisPart);
 594                     thatPart = fixupString(thatPart);
 595                     if (!thisPart.equals(thatPart)) {
 596                         return false;
 597                     }
 598                 }
 599             }
 600             // finally, attributes must be equal (unordered)
 601             return this.equalAttrs(that);
 602         }
 603         // bridge method
 604 
 605         public boolean equals(Object o) {
 606             if (!(o instanceof Element)) {
 607                 return false;
 608             }
 609             return equals((Element) o);
 610         }
 611 
 612         public int hashCode() {
 613             int hc = 0;
 614             int alen = attrLength();
 615             for (int i = parts.length - alen; i &lt; parts.length; i += 2) {
 616                 hc += (parts[i + 0].hashCode() ^ parts[i + 1].hashCode());
 617             }
 618             hc ^= hc &lt;&lt; 11;
 619             hc += name.hashCode();
 620             for (int i = 0; i &lt; size; i++) {
 621                 hc ^= hc &lt;&lt; 7;
 622                 Object p = parts[i];
 623                 if (p instanceof Element) {
 624                     hc += p.hashCode();  // recursion is common case
 625                 } else {
 626                     hc += fixupString(p).hashCode();
 627                 }
 628             }
 629             hc ^= hc &gt;&gt;&gt; 19;
 630             return hc;
 631         }
 632 
 633         /** Compare lexicographically.  Earlier-spelled attrs are more sigificant. */
 634         public int compareTo(Element that) {
 635             int r;
 636             // Primary key is element name.
 637             r = this.name.compareTo(that.name);
 638             if (r != 0) {
 639                 return r;
 640             }
 641 
 642             // Secondary key is attributes, as if in normal key order.
 643             // The key/value pairs are sorted as a token sequence.
 644             int thisAlen = this.attrLength();
 645             int thatAlen = that.attrLength();
 646             if (thisAlen != 0 || thatAlen != 0) {
 647                 r = compareAttrs(thisAlen, that, thatAlen, true);
 648                 assert (assertAttrCompareOK(r, that));
 649                 if (r != 0) {
 650                     return r;
 651                 }
 652             }
 653 
 654             // Finally, elements should be equal and ordered,
 655             // and the first difference rules.
 656             Object[] thisParts = this.parts;
 657             Object[] thatParts = that.parts;
 658             int minSize = this.size;
 659             if (minSize &gt; that.size) {
 660                 minSize = that.size;
 661             }
 662             Comparator&lt;Object&gt; cc = contentOrder();
 663             for (int i = 0; i &lt; minSize; i++) {
 664                 r = cc.compare(thisParts[i], thatParts[i]);
 665                 if (r != 0) {
 666                     return r;
 667                 }
 668             }
 669             //if (this.size &lt; that.size)  return -1;
 670             return this.size - that.size;
 671         }
 672 
 673         private boolean assertAttrCompareOK(int r, Element that) {
 674             Element e0 = this.copyAttrsOnly();
 675             Element e1 = that.copyAttrsOnly();
 676             e0.sortAttrs();
 677             e1.sortAttrs();
 678             int r2;
 679             for (int k = 0;; k++) {
 680                 boolean con0 = e0.containsAttr(k);
 681                 boolean con1 = e1.containsAttr(k);
 682                 if (con0 != con1) {
 683                     if (!con0) {
 684                         r2 = 0 - 1;
 685                         break;
 686                     }
 687                     if (!con1) {
 688                         r2 = 1 - 0;
 689                         break;
 690                     }
 691                 }
 692                 if (!con0) {
 693                     r2 = 0;
 694                     break;
 695                 }
 696                 String k0 = e0.getAttrName(k);
 697                 String k1 = e1.getAttrName(k);
 698                 r2 = k0.compareTo(k1);
 699                 if (r2 != 0) {
 700                     break;
 701                 }
 702                 String v0 = e0.getAttr(k);
 703                 String v1 = e1.getAttr(k);
 704                 r2 = v0.compareTo(v1);
 705                 if (r2 != 0) {
 706                     break;
 707                 }
 708             }
 709             if (r != 0) {
 710                 r = (r &gt; 0) ? 1 : -1;
 711             }
 712             if (r2 != 0) {
 713                 r2 = (r2 &gt; 0) ? 1 : -1;
 714             }
 715             if (r != r2) {
 716                 System.out.println(&quot;*** wrong attr compare, &quot; + r + &quot; != &quot; + r2);
 717                 System.out.println(&quot; this = &quot; + this);
 718                 System.out.println(&quot;  attr-&gt;&quot; + e0);
 719                 System.out.println(&quot; that = &quot; + that);
 720                 System.out.println(&quot;  attr-&gt;&quot; + e1);
 721             }
 722             return r == r2;
 723         }
 724 
 725         private void badIndex(int i) {
 726             Object badRef = (new Object[0])[i];
 727         }
 728 
 729         public Object get(int i) {
 730             if (i &gt;= size) {
 731                 badIndex(i);
 732             }
 733             return parts[i];
 734         }
 735 
 736         public Object set(int i, Object e) {
 737             if (i &gt;= size) {
 738                 badIndex(i);
 739             }
 740             Objects.requireNonNull(e);
 741             checkNotFrozen();
 742             Object old = parts[i];
 743             setRaw(i, e);
 744             return old;
 745         }
 746 
 747         void setRaw(int i, Object e) {
 748             parts[i] = e;
 749         }
 750 
 751         public boolean remove(Object e) {
 752             int i = indexOf(e);
 753             if (i &lt; 0) {
 754                 return false;
 755             }
 756             close(i, 1);
 757             return true;
 758         }
 759 
 760         public Object remove(int i) {
 761             if (i &gt;= size) {
 762                 badIndex(i);
 763             }
 764             Object e = parts[i];
 765             close(i, 1);
 766             return e;
 767         }
 768 
 769         public Object removeLast() {
 770             if (size == 0) {
 771                 return null;
 772             }
 773             return remove(size - 1);
 774         }
 775 
 776         /** Remove the first element matching the given filter.
 777          *  Return the filtered value.
 778          */
 779         public Object remove(Filter f) {
 780             return findOrRemove(f, 0, true);
 781         }
 782 
 783         public Object remove(Filter f, int fromIndex) {
 784             if (fromIndex &lt; 0) {
 785                 fromIndex = 0;
 786             }
 787             return findOrRemove(f, fromIndex, true);
 788         }
 789 
 790         /** Remove the last element matching the given filter.
 791          *  Return the filtered value.
 792          */
 793         public Object removeLast(Filter f) {
 794             return findOrRemoveLast(f, size - 1, true);
 795         }
 796 
 797         public Object removeLast(Filter f, int fromIndex) {
 798             if (fromIndex &gt;= size) {
 799                 fromIndex = size - 1;
 800             }
 801             return findOrRemoveLast(f, fromIndex, true);
 802         }
 803 
 804         /** Remove all elements matching the given filter.
 805          *  If there is a non-null collection given as a sink,
 806          *  transfer removed elements to the given collection.
 807          *  The int result is the number of removed elements.
 808          *  If there is a null sink given, the removed elements
 809          *  are discarded.  If there is no sink given, the removed
 810          *  elements are returned in an anonymous container element.
 811          */
 812         public Element removeAll(Filter f) {
 813             Element result = new Element();
 814             findOrRemoveAll(f, false, 0, size, result.asList(), true);
 815             return result;
 816         }
 817 
 818         public Element removeAll(Filter f, int fromIndex, int toIndex) {
 819             Element result = new Element();
 820             findOrRemoveAll(f, true, fromIndex, toIndex, result.asList(), true);
 821             return result;
 822         }
 823 
 824         public int removeAll(Filter f, Collection&lt;Object&gt; sink) {
 825             return findOrRemoveAll(f, false, 0, size, sink, true);
 826         }
 827 
 828         public int removeAll(Filter f, int fromIndex, int toIndex, Collection&lt;Object&gt; sink) {
 829             return findOrRemoveAll(f, false, fromIndex, toIndex, sink, true);
 830         }
 831 
 832         /** Remove all elements not matching the given filter.
 833          *  If there is a non-null collection given as a sink,
 834          *  transfer removed elements to the given collection.
 835          *  The int result is the number of removed elements.
 836          *  If there is a null sink given, the removed elements
 837          *  are discarded.  If there is no sink given, the removed
 838          *  elements are returned in an anonymous container element.
 839          */
 840         public Element retainAll(Filter f) {
 841             Element result = new Element();
 842             findOrRemoveAll(f, true, 0, size, result.asList(), true);
 843             return result;
 844         }
 845 
 846         public Element retainAll(Filter f, int fromIndex, int toIndex) {
 847             Element result = new Element();
 848             findOrRemoveAll(f, true, fromIndex, toIndex, result.asList(), true);
 849             return result;
 850         }
 851 
 852         public int retainAll(Filter f, Collection&lt;Object&gt; sink) {
 853             return findOrRemoveAll(f, true, 0, size, sink, true);
 854         }
 855 
 856         public int retainAll(Filter f, int fromIndex, int toIndex, Collection&lt;Object&gt; sink) {
 857             return findOrRemoveAll(f, true, fromIndex, toIndex, sink, true);
 858         }
 859 
 860         public void add(int i, Object e) {
 861             // (The shape of this method is tweaked for common cases.)
 862             Objects.requireNonNull(e);
 863             if (hasNulls(1 + NEED_SLOP)) {
 864                 // Common case:  Have some slop space.
 865                 if (i == size) {
 866                     // Most common case:  Append.
 867                     setRaw(i, e);
 868                     size++;
 869                     return;
 870                 }
 871                 if (i &gt; size) {
 872                     badIndex(i);
 873                 }
 874                 // Second most common case:  Shift right by one.
 875                 open(i, 1);
 876                 setRaw(i, e);
 877                 return;
 878             }
 879             // Ran out of space.  Do something complicated.
 880             size = expand(i, 1);
 881             setRaw(i, e);
 882         }
 883 
 884         public boolean add(Object e) {
 885             add(size, e);
 886             return true;
 887         }
 888 
 889         public Object getLast() {
 890             return size == 0 ? null : parts[size - 1];
 891         }
 892 
 893         /** Returns the text of this Element.
 894          *  All sub-elements of this Element must be of type CharSequence.
 895          *  A ClassCastException is raised if there are non-character sub-elements.
 896          *  If there is one sub-element, return it.
 897          *  Otherwise, returns a TokenList of all sub-elements.
 898          *  This results in a space being placed between each adjacent pair of sub-elements.
 899          */
 900         public CharSequence getText() {
 901             checkTextOnly();
 902             if (size == 1) {
 903                 return parts[0].toString();
 904             } else {
 905                 return new TokenList(parts, 0, size);
 906             }
 907         }
 908 
 909         /** Provides an iterable view of this object as a series of texts.
 910          *  All sub-elements of this Element must be of type CharSequence.
 911          *  A ClassCastException is raised if there are non-character sub-elements.
 912          */
 913         public Iterable&lt;CharSequence&gt; texts() {
 914             checkTextOnly();
 915             return (Iterable&lt;CharSequence&gt;) (Iterable) this;
 916         }
 917 
 918         /** Returns an array of strings derived from the sub-elements of this object.
 919          *  All sub-elements of this Element must be of type CharSequence.
 920          *  A ClassCastException is raised if there are non-character sub-elements.
 921          */
 922         public String[] toStrings() {
 923             //checkTextOnly();
 924             String[] result = new String[size];
 925             for (int i = 0; i &lt; size; i++) {
 926                 result[i] = ((CharSequence) parts[i]).toString();
 927             }
 928             return result;
 929         }
 930 
 931         /** Like getText, except that it disregards non-text elements.
 932          *  Non-text elements are replaced by their textual contents, if any.
 933          *  Text elements which were separated only by non-text element
 934          *  boundaries are merged into single tokens.
 935          *  &lt;p&gt;
 936          *  There is no corresponding setter, since this accessor does
 937          *  not report the full state of the element.
 938          */
 939         public CharSequence getFlatText() {
 940             if (size == 1) {
 941                 // Simple cases.
 942                 if (parts[0] instanceof CharSequence) {
 943                     return parts[0].toString();
 944                 } else {
 945                     return new TokenList();
 946                 }
 947             }
 948             if (isText()) {
 949                 return getText();
 950             }
 951             // Filter and merge.
 952             Element result = new Element(size);
 953             boolean merge = false;
 954             for (int i = 0; i &lt; size; i++) {
 955                 Object text = parts[i];
 956                 if (!(text instanceof CharSequence)) {
 957                     // Skip, but erase this boundary.
 958                     if (text instanceof Element) {
 959                         Element te = (Element) text;
 960                         if (!te.isEmpty()) {
 961                             result.addText(te.getFlatText());
 962                         }
 963                     }
 964                     merge = true;
 965                     continue;
 966                 }
 967                 if (merge) {
 968                     // Merge w/ previous token.
 969                     result.addText((CharSequence) text);
 970                     merge = false;
 971                 } else {
 972                     result.add(text);
 973                 }
 974             }
 975             if (result.size() == 1) {
 976                 return (CharSequence) result.parts[0];
 977             } else {
 978                 return result.getText();
 979             }
 980         }
 981 
 982         /** Return true if all sub-elements are of type CharSequence. */
 983         public boolean isText() {
 984             for (int i = 0; i &lt; size; i++) {
 985                 if (!(parts[i] instanceof CharSequence)) {
 986                     return false;
 987                 }
 988             }
 989             return true;
 990         }
 991 
 992         /** Return true if at least one sub-element is of type CharSequence. */
 993         public boolean hasText() {
 994             for (int i = 0; i &lt; size; i++) {
 995                 if (parts[i] instanceof CharSequence) {
 996                     return true;
 997                 }
 998             }
 999             return false;
1000         }
1001 
1002         /** Raise a ClassCastException if !isText. */
1003         public void checkTextOnly() {
1004             for (int i = 0; i &lt; size; i++) {
1005                 ((CharSequence) parts[i]).getClass();
1006             }
1007         }
1008 
1009         /** Clears out all sub-elements, and replaces them by the given text.
1010          *  A ClassCastException is raised if there are non-character sub-elements,
1011          *  either before or after the change.
1012          */
1013         public void setText(CharSequence text) {
1014             checkTextOnly();
1015             clear();
1016             if (text instanceof TokenList) {
1017                 // TL&#39;s contain only strings
1018                 addAll(0, (TokenList) text);
1019             } else {
1020                 add(text);
1021             }
1022         }
1023 
1024         /** Add text at the given position, merging with any previous
1025          *  text element, but preserving token boundaries where possible.
1026          *  &lt;p&gt;
1027          *  In all cases, the new value of getText() is the string
1028          *  concatenation of the old value of getText() plus the new text.
1029          *  &lt;p&gt;
1030          *  The total effect is to concatenate the given text to any
1031          *  pre-existing text, and to do so efficiently even if there
1032          *  are many such concatenations.  Also, getText calls which
1033          *  return multiple tokens (in a TokenList) are respected.
1034          *  For example, if x is empty, x.addText(y.getText()) puts
1035          *  an exact structural copy of y&#39;s text into x.
1036          *  &lt;p&gt;
1037          *  Internal token boundaries in the original text, and in the new
1038          *  text (i.e., if it is a TokenList), are preserved.  However,
1039          *  at the point where new text joins old text, a StringBuffer
1040          *  or new String may be created to join the last old and first
1041          *  new token.
1042          *  &lt;p&gt;
1043          *  If the given text is a TokenList, add the tokens as
1044          *  separate sub-elements, possibly merging the first token to
1045          *  a previous text item (to avoid making a new token boundary).
1046          *  &lt;p&gt;
1047          *  If the element preceding position i is a StringBuffer,
1048          *  append the first new token to it.
1049          *  &lt;p&gt;
1050          *  If the preceding element is a CharSequence, replace it by a
1051          *  StringBuffer containing both its and the first new token.
1052          *  &lt;p&gt;
1053          *  If tokens are added after a StringBuffer, freeze it into a String.
1054          *  &lt;p&gt;
1055          *  Every token not merged into a previous CharSequence is added
1056          *  as a new sub-element, starting at position i.
1057          *  &lt;p&gt;
1058          *  Returns the number of elements added, which is useful
1059          *  for further calls to addText.  This number is zero
1060          *  if the input string was null, or was successfully
1061          *  merged into a StringBuffer at position i-1.
1062          *  &lt;p&gt;
1063          *  By contrast, calling add(text) always adds a new sub-element.
1064          *  In that case, if there is a previous string, a separating
1065          *  space is virtually present also, and will be observed if
1066          *  getText() is used to return all the text together.
1067          */
1068         public int addText(int i, CharSequence text) {
1069             if (text instanceof String) {
1070                 return addText(i, (String) text);
1071             } else if (text instanceof TokenList) {
1072                 // Text is a list of tokens.
1073                 TokenList tl = (TokenList) text;
1074                 int tlsize = tl.size();
1075                 if (tlsize == 0) {
1076                     return 0;
1077                 }
1078                 String token0 = tl.get(0).toString();
1079                 if (tlsize == 1) {
1080                     return addText(i, token0);
1081                 }
1082                 if (mergeWithPrev(i, token0, false)) {
1083                     // Add the n-1 remaining tokens.
1084                     addAll(i, tl.subList(1, tlsize));
1085                     return tlsize - 1;
1086                 } else {
1087                     addAll(i, (Collection) tl);
1088                     return tlsize;
1089                 }
1090             } else {
1091                 return addText(i, text.toString());
1092             }
1093         }
1094 
1095         public int addText(CharSequence text) {
1096             return addText(size, text);
1097         }
1098 
1099         private // no reason to make this helper public
1100                 int addText(int i, String text) {
1101             if (text.length() == 0) {
1102                 return 0;  // Trivial success.
1103             }
1104             if (mergeWithPrev(i, text, true)) {
1105                 return 0;  // Merged with previous token.
1106             }
1107             // No previous token.
1108             add(i, text);
1109             return 1;
1110         }
1111 
1112         // Tries to merge token with previous contents.
1113         // Returns true if token is successfully disposed of.
1114         // If keepSB is false, any previous StringBuffer is frozen.
1115         // If keepSB is true, a StringBuffer may be created to hold
1116         // the merged token.
1117         private boolean mergeWithPrev(int i, String token, boolean keepSB) {
1118             if (i == 0) // Trivial success if the token is length zero.
1119             {
1120                 return (token.length() == 0);
1121             }
1122             Object prev = parts[i - 1];
1123             if (prev instanceof StringBuffer) {
1124                 StringBuffer psb = (StringBuffer) prev;
1125                 psb.append(token);
1126                 if (!keepSB) {
1127                     parts[i - 1] = psb.toString();
1128                 }
1129                 return true;
1130             }
1131             if (token.length() == 0) {
1132                 return true;  // Trivial success.
1133             }
1134             if (prev instanceof CharSequence) {
1135                 // Must concatenate.
1136                 StringBuffer psb = new StringBuffer(prev.toString());
1137                 psb.append(token);
1138                 if (keepSB) {
1139                     parts[i - 1] = psb;
1140                 } else {
1141                     parts[i - 1] = psb.toString();
1142                 }
1143                 return true;
1144             }
1145             return false;
1146         }
1147 
1148         /** Trim all strings, using String.trim().
1149          *  Remove empty strings.
1150          *  Normalize CharSequences to Strings.
1151          */
1152         public void trimText() {
1153             checkNotFrozen();
1154             int fillp = 0;
1155             int size = this.size;
1156             Object[] parts = this.parts;
1157             for (int i = 0; i &lt; size; i++) {
1158                 Object e = parts[i];
1159                 if (e instanceof CharSequence) {
1160                     String tt = e.toString().trim();
1161                     if (tt.length() == 0) {
1162                         continue;
1163                     }
1164                     e = tt;
1165                 }
1166                 parts[fillp++] = e;
1167             }
1168             while (size &gt; fillp) {
1169                 parts[--size] = null;
1170             }
1171             this.size = fillp;
1172         }
1173 
1174         /** Add one or more subelements at the given position.
1175          *  If the object reference is null, nothing happens.
1176          *  If the object is an anonymous Element, addAll is called.
1177          *  If the object is a TokenList, addAll is called (to add the tokens).
1178          *  Otherwise, add is called, adding a single subelement or string.
1179          *  The net effect is to add zero or more tokens.
1180          *  The returned value is the number of added elements.
1181          *  &lt;p&gt;
1182          *  Note that getText() can return a TokenList which preserves
1183          *  token boundaries in the text source.  Such a text will be
1184          *  added as multiple text sub-elements.
1185          *  &lt;p&gt;
1186          *  If a text string is added adjacent to an immediately
1187          *  preceding string, there will be a token boundary between
1188          *  the strings, which will print as an extra space.
1189          */
1190         public int addContent(int i, Object e) {
1191             if (e == null) {
1192                 return 0;
1193             } else if (e instanceof TokenList) {
1194                 return addAll(i, (Collection) e);
1195             } else if (e instanceof Element
1196                     &amp;&amp; ((Element) e).isAnonymous()) {
1197                 return addAll(i, (Element) e);
1198             } else {
1199                 add(i, e);
1200                 return 1;
1201             }
1202         }
1203 
1204         public int addContent(Object e) {
1205             return addContent(size, e);
1206         }
1207 
1208         public Object[] toArray() {
1209             Object[] result = new Object[size];
1210             System.arraycopy(parts, 0, result, 0, size);
1211             return result;
1212         }
1213 
1214         public Element copyContentOnly() {
1215             Element content = new Element(size);
1216             System.arraycopy(parts, 0, content.parts, 0, size);
1217             content.size = size;
1218             return content;
1219         }
1220 
1221         public void sort(Comparator&lt;Object&gt; c) {
1222             Arrays.sort(parts, 0, size, c);
1223         }
1224 
1225         public void sort() {
1226             sort(CONTENT_ORDER);
1227         }
1228 
1229         /** Equivalent to Collections.reverse(this.asList()). */
1230         public void reverse() {
1231             for (int i = 0, mid = size &gt;&gt; 1, j = size - 1; i &lt; mid; i++, j--) {
1232                 Object p = parts[i];
1233                 parts[i] = parts[j];
1234                 parts[j] = p;
1235             }
1236         }
1237 
1238         /** Equivalent to Collections.shuffle(this.asList() [, rnd]). */
1239         public void shuffle() {
1240             Collections.shuffle(this.asList());
1241         }
1242 
1243         public void shuffle(Random rnd) {
1244             Collections.shuffle(this.asList(), rnd);
1245         }
1246 
1247         /** Equivalent to Collections.rotate(this.asList(), dist). */
1248         public void rotate(int dist) {
1249             Collections.rotate(this.asList(), dist);
1250         }
1251 
1252         /** Equivalent to Collections.min(this.asList(), c). */
1253         public Object min(Comparator&lt;Object&gt; c) {
1254             return Collections.min(this.asList(), c);
1255         }
1256 
1257         public Object min() {
1258             return min(CONTENT_ORDER);
1259         }
1260 
1261         /** Equivalent to Collections.max(this.asList(), c). */
1262         public Object max(Comparator&lt;Object&gt; c) {
1263             return Collections.max(this.asList(), c);
1264         }
1265 
1266         public Object max() {
1267             return max(CONTENT_ORDER);
1268         }
1269 
1270         public int addAll(int i, Collection c) {
1271             if (c instanceof LView) {
1272                 return addAll(i, ((LView) c).asElement());
1273             } else {
1274                 int csize = c.size();
1275                 if (csize == 0) {
1276                     return 0;
1277                 }
1278                 openOrExpand(i, csize);
1279                 int fill = i;
1280                 for (Object part : c) {
1281                     parts[fill++] = part;
1282                 }
1283                 return csize;
1284             }
1285         }
1286 
1287         public int addAll(int i, Element e) {
1288             int esize = e.size;
1289             if (esize == 0) {
1290                 return 0;
1291             }
1292             openOrExpand(i, esize);
1293             System.arraycopy(e.parts, 0, parts, i, esize);
1294             return esize;
1295         }
1296 
1297         public int addAll(Collection c) {
1298             return addAll(size, c);
1299         }
1300 
1301         public int addAll(Element e) {
1302             return addAll(size, e);
1303         }
1304 
1305         public int addAllAttrsFrom(Element e) {
1306             int added = 0;
1307             for (int k = 0; e.containsAttr(k); k++) {
1308                 String old = setAttr(e.getAttrName(k), e.getAttr(k));
1309                 if (old == null) {
1310                     added += 1;
1311                 }
1312             }
1313             // Return number of added (not merely changed) attrs.
1314             return added;
1315         }
1316 
1317         // Search.
1318         public boolean matches(Filter f) {
1319             return f.filter(this) != null;
1320         }
1321 
1322         public Object find(Filter f) {
1323             return findOrRemove(f, 0, false);
1324         }
1325 
1326         public Object find(Filter f, int fromIndex) {
1327             if (fromIndex &lt; 0) {
1328                 fromIndex = 0;
1329             }
1330             return findOrRemove(f, fromIndex, false);
1331         }
1332 
1333         /** Find the last element matching the given filter.
1334          *  Return the filtered value.
1335          */
1336         public Object findLast(Filter f) {
1337             return findOrRemoveLast(f, size - 1, false);
1338         }
1339 
1340         public Object findLast(Filter f, int fromIndex) {
1341             if (fromIndex &gt;= size) {
1342                 fromIndex = size - 1;
1343             }
1344             return findOrRemoveLast(f, fromIndex, false);
1345         }
1346 
1347         /** Find all elements matching the given filter.
1348          *  If there is a non-null collection given as a sink,
1349          *  transfer matching elements to the given collection.
1350          *  The int result is the number of matching elements.
1351          *  If there is a null sink given, the matching elements are
1352          *  not collected.  If there is no sink given, the matching
1353          *  elements are returned in an anonymous container element.
1354          *  In no case is the receiver element changed.
1355          *  &lt;p&gt;
1356          *  Note that a simple count of matching elements can be
1357          *  obtained by passing a null collection argument.
1358          */
1359         public Element findAll(Filter f) {
1360             Element result = new Element();
1361             findOrRemoveAll(f, false, 0, size, result.asList(), false);
1362             return result;
1363         }
1364 
1365         public Element findAll(Filter f, int fromIndex, int toIndex) {
1366             Element result = new Element(name);
1367             findOrRemoveAll(f, false, fromIndex, toIndex, result.asList(), false);
1368             return result;
1369         }
1370 
1371         public int findAll(Filter f, Collection&lt;Object&gt; sink) {
1372             return findOrRemoveAll(f, false, 0, size, sink, false);
1373         }
1374 
1375         public int findAll(Filter f, int fromIndex, int toIndex, Collection&lt;Object&gt; sink) {
1376             return findOrRemoveAll(f, false, fromIndex, toIndex, sink, false);
1377         }
1378 
1379         /// Driver routines.
1380         private Object findOrRemove(Filter f, int fromIndex, boolean remove) {
1381             for (int i = fromIndex; i &lt; size; i++) {
1382                 Object x = f.filter(parts[i]);
1383                 if (x != null) {
1384                     if (remove) {
1385                         close(i, 1);
1386                     }
1387                     return x;
1388                 }
1389             }
1390             return null;
1391         }
1392 
1393         private Object findOrRemoveLast(Filter f, int fromIndex, boolean remove) {
1394             for (int i = fromIndex; i &gt;= 0; i--) {
1395                 Object x = f.filter(parts[i]);
1396                 if (x != null) {
1397                     if (remove) {
1398                         close(i, 1);
1399                     }
1400                     return x;
1401                 }
1402             }
1403             return null;
1404         }
1405 
1406         private int findOrRemoveAll(Filter f, boolean fInvert,
1407                 int fromIndex, int toIndex,
1408                 Collection&lt;Object&gt; sink, boolean remove) {
1409             if (fromIndex &lt; 0) {
1410                 badIndex(fromIndex);
1411             }
1412             if (toIndex &gt; size) {
1413                 badIndex(toIndex);
1414             }
1415             int found = 0;
1416             for (int i = fromIndex; i &lt; toIndex; i++) {
1417                 Object p = parts[i];
1418                 Object x = f.filter(p);
1419                 if (fInvert ? (x == null) : (x != null)) {
1420                     if (remove) {
1421                         close(i--, 1);
1422                         toIndex--;
1423                     }
1424                     found += XMLKit.addContent(fInvert ? p : x, sink);
1425                 }
1426             }
1427             return found;
1428         }
1429 
1430         public void replaceAll(Filter f) {
1431             XMLKit.replaceAll(f, this.asList());
1432         }
1433 
1434         public void replaceAll(Filter f, int fromIndex, int toIndex) {
1435             XMLKit.replaceAll(f, this.asList().subList(fromIndex, toIndex));
1436         }
1437 
1438         /// Recursive walks.
1439         // findAllInTree(f)     == findAll(findInTree(f,S)), S.toElement
1440         // findAllInTree(f,S)   == findAll(findInTree(content(f,S)))
1441         // removeAllInTree(f)   == replaceAll(replaceInTree(and(f,emptyF)))
1442         // removeAllInTree(f,S) == replaceAll(replaceInTree(and(content(f,S),emptyF)))
1443         // retainAllInTree(f)   == removeAllInTree(not(f))
1444         // replaceAllInTree(f)  == replaceAll(replaceInTree(f))
1445         public Element findAllInTree(Filter f) {
1446             Element result = new Element();
1447             findAllInTree(f, result.asList());
1448             return result;
1449         }
1450 
1451         public int findAllInTree(Filter f, Collection&lt;Object&gt; sink) {
1452             int found = 0;
1453             int size = this.size;  // cache copy
1454             for (int i = 0; i &lt; size; i++) {
1455                 Object p = parts[i];
1456                 Object x = f.filter(p);
1457                 if (x != null) {
1458                     found += XMLKit.addContent(x, sink);
1459                 } else if (p instanceof Element) {
1460                     found += ((Element) p).findAllInTree(f, sink);
1461                 }
1462             }
1463             return found;
1464         }
1465 
1466         public int countAllInTree(Filter f) {
1467             return findAllInTree(f, null);
1468         }
1469 
1470         public int removeAllInTree(Filter f, Collection&lt;Object&gt; sink) {
1471             if (sink == null) {
1472                 sink = newCounterColl();
1473             }
1474             replaceAll(replaceInTree(and(content(f, sink), emptyFilter())));
1475             return sink.size();
1476         }
1477 
1478         public Element removeAllInTree(Filter f) {
1479             Element result = new Element();
1480             removeAllInTree(f, result.asList());
1481             return result;
1482         }
1483 
1484         public int retainAllInTree(Filter f, Collection&lt;Object&gt; sink) {
1485             return removeAllInTree(not(f), sink);
1486         }
1487 
1488         public Element retainAllInTree(Filter f) {
1489             Element result = new Element();
1490             retainAllInTree(f, result.asList());
1491             return result;
1492         }
1493 
1494         public void replaceAllInTree(Filter f) {
1495             replaceAll(replaceInTree(f));
1496         }
1497 
1498         /** Raise a ClassCastException if any subelements are the wrong type. */
1499         public void checkPartsOnly(Class&lt;?&gt; elementClass) {
1500             for (int i = 0; i &lt; size; i++) {
1501                 elementClass.cast(parts[i]).getClass();
1502             }
1503         }
1504 
1505         /** Return true if all sub-elements are of the given type. */
1506         public boolean isPartsOnly(Class&lt;?&gt; elementClass) {
1507             for (int i = 0; i &lt; size; i++) {
1508                 if (!elementClass.isInstance(parts[i])) {
1509                     return false;
1510                 }
1511             }
1512             return true;
1513         }
1514 
1515         /** Provides an iterable view of this object as a series of elements.
1516          *  All sub-elements of this Element must be of type Element.
1517          *  A ClassCastException is raised if there are non-Element sub-elements.
1518          */
1519         public &lt;T&gt; Iterable&lt;T&gt; partsOnly(Class&lt;T&gt; elementClass) {
1520             checkPartsOnly(elementClass);
1521             return (Iterable&lt;T&gt;) (Iterable) this;
1522         }
1523 
1524         public Iterable&lt;Element&gt; elements() {
1525             return partsOnly(Element.class);
1526         }
1527 
1528         /// Useful shorthands.
1529         // Finding or removing elements w/o regard to their type or content.
1530         public Element findElement() {
1531             return (Element) find(elementFilter());
1532         }
1533 
1534         public Element findAllElements() {
1535             return findAll(elementFilter());
1536         }
1537 
1538         public Element removeElement() {
1539             return (Element) remove(elementFilter());
1540         }
1541 
1542         public Element removeAllElements() {
1543             return (Element) removeAll(elementFilter());
1544         }
1545 
1546         // Finding or removing by element tag or selected attribute,
1547         // as if by elementFilter(name) or attrFilter(name, value).
1548         // Roughly akin to Common Lisp ASSOC.
1549         public Element findElement(String name) {
1550             return (Element) find(elementFilter(name));
1551         }
1552 
1553         public Element removeElement(String name) {
1554             return (Element) remove(elementFilter(name));
1555         }
1556 
1557         public Element findWithAttr(String key) {
1558             return (Element) find(attrFilter(name));
1559         }
1560 
1561         public Element findWithAttr(String key, String value) {
1562             return (Element) find(attrFilter(name, value));
1563         }
1564 
1565         public Element removeWithAttr(String key) {
1566             return (Element) remove(attrFilter(name));
1567         }
1568 
1569         public Element removeWithAttr(String key, String value) {
1570             return (Element) remove(attrFilter(name, value));
1571         }
1572 
1573         public Element findAllElements(String name) {
1574             return findAll(elementFilter(name));
1575         }
1576 
1577         public Element removeAllElements(String name) {
1578             return removeAll(elementFilter(name));
1579         }
1580 
1581         public Element retainAllElements(String name) {
1582             return retainAll(elementFilter(name));
1583         }
1584 
1585         public Element findAllWithAttr(String key) {
1586             return findAll(attrFilter(key));
1587         }
1588 
1589         public Element removeAllWithAttr(String key) {
1590             return removeAll(attrFilter(key));
1591         }
1592 
1593         public Element retainAllWithAttr(String key) {
1594             return retainAll(attrFilter(key));
1595         }
1596 
1597         public Element findAllWithAttr(String key, String value) {
1598             return findAll(attrFilter(key, value));
1599         }
1600 
1601         public Element removeAllWithAttr(String key, String value) {
1602             return removeAll(attrFilter(key, value));
1603         }
1604 
1605         public Element retainAllWithAttr(String key, String value) {
1606             return retainAll(attrFilter(key, value));
1607         }
1608 
1609         public int countAll(Filter f) {
1610             return findAll(f, null);
1611         }
1612 
1613         public int countAllElements() {
1614             return countAll(elementFilter());
1615         }
1616 
1617         public int countAllElements(String name) {
1618             return countAll(elementFilter(name));
1619         }
1620 
1621         public int countAllWithAttr(String key) {
1622             return countAll(attrFilter(name));
1623         }
1624 
1625         public int countAllWithAttr(String key, String value) {
1626             return countAll(attrFilter(key, value));
1627         }
1628 
1629         public int indexOf(Object e) {
1630             for (int i = 0; i &lt; size; i++) {
1631                 if (e.equals(parts[i])) {
1632                     return i;
1633                 }
1634             }
1635             return -1;
1636         }
1637 
1638         public int lastIndexOf(Object e) {
1639             for (int i = size - 1; i &gt;= 0; i--) {
1640                 if (e.equals(parts[i])) {
1641                     return i;
1642                 }
1643             }
1644             return -1;
1645         }
1646 
1647         /** Remove the first element matching the given filter.
1648          *  Return the filtered value.
1649          */
1650         public int indexOf(Filter f) {
1651             return indexOf(f, 0);
1652         }
1653 
1654         public int indexOf(Filter f, int fromIndex) {
1655             if (fromIndex &lt; 0) {
1656                 fromIndex = 0;
1657             }
1658             for (int i = fromIndex; i &lt; size; i++) {
1659                 Object x = f.filter(parts[i]);
1660                 if (x != null) {
1661                     return i;
1662                 }
1663             }
1664             return -1;
1665         }
1666 
1667         /** Remove the last element matching the given filter.
1668          *  Return the filtered value.
1669          */
1670         public int lastIndexOf(Filter f) {
1671             return lastIndexOf(f, size - 1);
1672         }
1673 
1674         public int lastIndexOf(Filter f, int fromIndex) {
1675             if (fromIndex &gt;= size) {
1676                 fromIndex = size - 1;
1677             }
1678             for (int i = fromIndex; i &gt;= 0; i--) {
1679                 Object x = f.filter(parts[i]);
1680                 if (x != null) {
1681                     return i;
1682                 }
1683             }
1684             return -1;
1685         }
1686 
1687         public boolean contains(Object e) {
1688             return indexOf(e) &gt;= 0;
1689         }
1690 
1691         // attributes
1692         private int findOrCreateAttr(String key, boolean create) {
1693             key.toString();  // null check
1694             int attrBase = parts.length;
1695             for (int i = parts.length - 2; i &gt;= size; i -= 2) {
1696                 String akey = (String) parts[i + 0];
1697                 if (akey == null) {
1698                     if (!create) {
1699                         return -1;
1700                     }
1701                     if (i == size) {
1702                         break;  // NEED_SLOP
1703                     }
1704                     parts[i + 0] = key;
1705                     //parts[i+1] = &quot;&quot;; //caller responsibility
1706                     return i;
1707                 }
1708                 attrBase = i;
1709                 if (akey.equals(key)) {
1710                     return i;
1711                 }
1712             }
1713             // If we fell through, we ran into an element part.
1714             // Therefore we have run out of empty slots.
1715             if (!create) {
1716                 return -1;
1717             }
1718             assert (!isFrozen());
1719             int alen = parts.length - attrBase;
1720             expand(size, 2); // generally expands by more than 2
1721             // since there was a reallocation, the garbage slots are really null
1722             assert (parts[size + 0] == null &amp;&amp; parts[size + 1] == null);
1723             alen += 2;
1724             int i = parts.length - alen;
1725             parts[i + 0] = key;
1726             //parts[i+1] = &quot;&quot;; //caller responsibility
1727             return i;
1728         }
1729 
1730         public int attrSize() {
1731             return attrLength() &gt;&gt;&gt; 1;
1732         }
1733 
1734         public int indexOfAttr(String key) {
1735             return findOrCreateAttr(key, false);
1736         }
1737 
1738         public boolean containsAttr(String key) {
1739             return indexOfAttr(key) &gt;= 0;
1740         }
1741 
1742         public String getAttr(String key) {
1743             return getAttr(key, null);
1744         }
1745 
1746         public String getAttr(String key, String dflt) {
1747             int i = findOrCreateAttr(key, false);
1748             return (i &lt; 0) ? dflt : (String) parts[i + 1];
1749         }
1750 
1751         public TokenList getAttrList(String key) {
1752             return convertToList(getAttr(key));
1753         }
1754 
1755         public Number getAttrNumber(String key) {
1756             return convertToNumber(getAttr(key));
1757         }
1758 
1759         public long getAttrLong(String key) {
1760             return getAttrLong(key, 0);
1761         }
1762 
1763         public double getAttrDouble(String key) {
1764             return getAttrDouble(key, 0.0);
1765         }
1766 
1767         public long getAttrLong(String key, long dflt) {
1768             return convertToLong(getAttr(key), dflt);
1769         }
1770 
1771         public double getAttrDouble(String key, double dflt) {
1772             return convertToDouble(getAttr(key), dflt);
1773         }
1774 
1775         int indexAttr(int k) {
1776             int i = parts.length - (k * 2) - 2;
1777             if (i &lt; size || parts[i] == null) {
1778                 return -2;  // always oob
1779             }
1780             return i;
1781         }
1782 
1783         public boolean containsAttr(int k) {
1784             return indexAttr(k) &gt;= 0;
1785         }
1786 
1787         public String getAttr(int k) {
1788             return (String) parts[indexAttr(k) + 1];
1789         }
1790 
1791         public String getAttrName(int k) {
1792             return (String) parts[indexAttr(k) + 0];
1793         }
1794 
1795         public Iterable&lt;String&gt; attrNames() {
1796             //return asAttrMap().keySet();
1797             return new Iterable&lt;String&gt;() {
1798 
1799                 public Iterator&lt;String&gt; iterator() {
1800                     return new ANItr();
1801                 }
1802             };
1803         }
1804 
1805         // Hand-inlined replacement for asAttrMap().keySet().iterator():
1806         class ANItr implements Iterator&lt;String&gt; {
1807 
1808             boolean lastRet;
1809             int cursor = -2;  // pointer from end of parts
1810 
1811             public boolean hasNext() {
1812                 int i = cursor + parts.length;
1813                 return i &gt;= size &amp;&amp; parts[i] == null;
1814             }
1815 
1816             public String next() {
1817                 int i = cursor + parts.length;
1818                 Object x;
1819                 if (i &lt; size || (x = parts[i]) == null) {
1820                     nsee();
1821                     return null;
1822                 }
1823                 cursor -= 2;
1824                 lastRet = true;
1825                 return (String) x;
1826             }
1827 
1828             public void remove() {
1829                 if (!lastRet) {
1830                     throw new IllegalStateException();
1831                 }
1832                 Element.this.removeAttr((-4 - cursor) / 2);
1833                 cursor += 2;
1834                 lastRet = false;
1835             }
1836 
1837             Exception nsee() {
1838                 throw new NoSuchElementException(&quot;attribute &quot; + (-2 - cursor) / 2);
1839             }
1840         }
1841 
1842         /** Return an anonymous copy of self, but only with attributes.
1843          */
1844         public Element copyAttrsOnly() {
1845             int alen = attrLength();
1846             Element attrs = new Element(alen);
1847             Object[] attrParts = attrs.parts;
1848             assert (attrParts.length == NEED_SLOP + alen);
1849             System.arraycopy(parts, parts.length - alen,
1850                     attrParts, NEED_SLOP,
1851                     alen);
1852             return attrs;
1853         }
1854 
1855         /** Get all attributes, represented as an element with sub-elements.
1856          *  The name of each sub-element is the attribute key, and the text
1857          *  This is a fresh copy, and can be updated with affecting the original.
1858          *  of each sub-element is the corresponding attribute value.
1859          *  See also asAttrMap() for a &quot;live&quot; view of all the attributes as a Map.
1860          */
1861         public Element getAttrs() {
1862             int asize = attrSize();
1863             Element attrs = new Element(ANON_NAME, asize, NEED_SLOP + asize);
1864             for (int i = 0; i &lt; asize; i++) {
1865                 Element attr = new Element(getAttrName(i), 1, NEED_SLOP + 1);
1866                 // %%% normalize attrs to token lists?
1867                 attr.setRaw(0, getAttr(i));
1868                 attrs.setRaw(i, attr);
1869             }
1870             return attrs;
1871         }
1872 
1873         public void setAttrs(Element attrs) {
1874             int alen = attrLength();
1875             clearParts(parts.length - alen, alen);
1876             if (!hasNulls(NEED_SLOP + attrs.size * 2)) {
1877                 expand(size, attrs.size * 2);
1878             }
1879             addAttrs(attrs);
1880         }
1881 
1882         public void addAttrs(Element attrs) {
1883             for (int i = 0; i &lt; attrs.size; i++) {
1884                 Element attr = (Element) attrs.get(i);
1885                 setAttr(attr.name, attr.getText().toString());
1886             }
1887         }
1888 
1889         public void removeAttr(int i) {
1890             checkNotFrozen();
1891             while ((i -= 2) &gt;= size) {
1892                 Object k = parts[i + 0];
1893                 Object v = parts[i + 1];
1894                 if (k == null) {
1895                     break;
1896                 }
1897                 parts[i + 2] = k;
1898                 parts[i + 3] = v;
1899             }
1900             parts[i + 2] = null;
1901             parts[i + 3] = null;
1902         }
1903 
1904         public void clearAttrs() {
1905             if (parts.length == 0 || parts[parts.length - 1] == null) {
1906                 return;  // no attrs to clear
1907             }
1908             checkNotFrozen();
1909             if (size == 0) {
1910                 // If no elements, free the parts array.
1911                 parts = noPartsNotFrozen;
1912                 return;
1913             }
1914             for (int i = parts.length - 1; parts[i] != null; i--) {
1915                 assert (i &gt;= size);
1916                 parts[i] = null;
1917             }
1918         }
1919 
1920         public String setAttr(String key, String value) {
1921             String old;
1922             if (value == null) {
1923                 int i = findOrCreateAttr(key, false);
1924                 if (i &gt;= 0) {
1925                     old = (String) parts[i + 1];
1926                     removeAttr(i);
1927                 } else {
1928                     old = null;
1929                 }
1930             } else {
1931                 checkNotFrozen();
1932                 int i = findOrCreateAttr(key, true);
1933                 old = (String) parts[i + 1];
1934                 parts[i + 1] = value;
1935             }
1936             return old;
1937         }
1938 
1939         public String setAttrList(String key, List&lt;String&gt; l) {
1940             if (l == null) {
1941                 return setAttr(key, null);
1942             }
1943             if (!(l instanceof TokenList)) {
1944                 l = new TokenList(l);
1945             }
1946             return setAttr(key, l.toString());
1947         }
1948 
1949         public String setAttrNumber(String key, Number n) {
1950             return setAttr(key, (n == null) ? null : n.toString());
1951         }
1952 
1953         public String setAttrLong(String key, long n) {
1954             return setAttr(key, (n == 0) ? null : String.valueOf(n));
1955         }
1956 
1957         public String setAttrDouble(String key, double n) {
1958             return setAttr(key, (n == 0) ? null : String.valueOf(n));
1959         }
1960 
1961         public String setAttr(int k, String value) {
1962             int i = indexAttr(k);
1963             String old = (String) parts[i + 1];
1964             if (value == null) {
1965                 removeAttr(i);
1966             } else {
1967                 checkNotFrozen();
1968                 parts[i + 1] = value;
1969             }
1970             return old;
1971         }
1972 
1973         int attrLength() {
1974             return parts.length - attrBase();
1975         }
1976 
1977         /** Are the attributes of the two two elements equal?
1978          *  Disregards name, sub-elements, and ordering of attributes.
1979          */
1980         public boolean equalAttrs(Element that) {
1981             int alen = this.attrLength();
1982             if (alen != that.attrLength()) {
1983                 return false;
1984             }
1985             if (alen == 0) {
1986                 return true;
1987             }
1988             return compareAttrs(alen, that, alen, false) == 0;
1989         }
1990 
1991         private int compareAttrs(int thisAlen,
1992                 Element that, int thatAlen,
1993                 boolean fullCompare) {
1994             Object[] thisParts = this.parts;
1995             Object[] thatParts = that.parts;
1996             int thisBase = thisParts.length - thisAlen;
1997             int thatBase = thatParts.length - thatAlen;
1998             // search indexes into unmatched parts of this.attrs:
1999             int firstI = 0;
2000             // search indexes into unmatched parts of that.attrs:
2001             int firstJ = 0;
2002             int lastJ = thatAlen - 2;
2003             // try to find the mismatch with the first key:
2004             String firstKey = null;
2005             int firstKeyValCmp = 0;
2006             int foundKeys = 0;
2007             for (int i = 0; i &lt; thisAlen; i += 2) {
2008                 String key = (String) thisParts[thisBase + i + 0];
2009                 String val = (String) thisParts[thisBase + i + 1];
2010                 String otherVal = null;
2011                 for (int j = firstJ; j &lt;= lastJ; j += 2) {
2012                     if (key.equals(thatParts[thatBase + j + 0])) {
2013                         foundKeys += 1;
2014                         otherVal = (String) thatParts[thatBase + j + 1];
2015                         // Optimization:  Narrow subsequent searches when easy.
2016                         if (j == lastJ) {
2017                             lastJ -= 2;
2018                         } else if (j == firstJ) {
2019                             firstJ += 2;
2020                         }
2021                         if (i == firstI) {
2022                             firstI += 2;
2023                         }
2024                         break;
2025                     }
2026                 }
2027                 int valCmp;
2028                 if (otherVal != null) {
2029                     // The key was found.
2030                     if (!fullCompare) {
2031                         if (!val.equals(otherVal)) {
2032                             return 1 - 0; //arb.
2033                         }
2034                         continue;
2035                     }
2036                     valCmp = val.compareTo(otherVal);
2037                 } else {
2038                     // Found the key in this but not that.
2039                     // Such a mismatch puts the guy missing the key last.
2040                     valCmp = 0 - 1;
2041                 }
2042                 if (valCmp != 0) {
2043                     // found a mismatch, key present in both elems
2044                     if (firstKey == null
2045                             || firstKey.compareTo(key) &gt; 0) {
2046                         // found a better key
2047                         firstKey = key;
2048                         firstKeyValCmp = valCmp;
2049                     }
2050                 }
2051             }
2052             // We have located the first mismatch of all keys in this.attrs.
2053             // In general we must also look for keys in that.attrs but missing
2054             // from this.attrs; such missing keys, if earlier than firstKey,
2055             // rule the comparison.
2056 
2057             // We can sometimes prove quickly there is no missing key.
2058             if (foundKeys == thatAlen / 2) {
2059                 // Exhausted all keys in that.attrs.
2060                 return firstKeyValCmp;
2061             }
2062 
2063             // Search for a missing key in that.attrs earlier than firstKey.
2064             findMissingKey:
2065             for (int j = firstJ; j &lt;= lastJ; j += 2) {
2066                 String otherKey = (String) thatParts[thatBase + j + 0];
2067                 if (firstKey == null
2068                         || firstKey.compareTo(otherKey) &gt; 0) {
2069                     // Found a better key; is it missing?
2070                     for (int i = firstI; i &lt; thisAlen; i += 2) {
2071                         if (otherKey.equals(thisParts[thisBase + i + 0])) {
2072                             continue findMissingKey;
2073                         }
2074                     }
2075                     // If we get here, there was no match in this.attrs.
2076                     return 1 - 0;
2077                 }
2078             }
2079 
2080             // No missing key.  Previous comparison value rules.
2081             return firstKeyValCmp;
2082         }
2083 
2084         // Binary search looking for first non-null after size.
2085         int attrBase() {
2086             // Smallest &amp; largest possible attribute indexes:
2087             int kmin = 0;
2088             int kmax = (parts.length - size) &gt;&gt;&gt; 1;
2089             // earlist possible attribute position:
2090             int abase = parts.length - (kmax * 2);
2091             // binary search using scaled indexes:
2092             while (kmin != kmax) {
2093                 int kmid = kmin + ((kmax - kmin) &gt;&gt;&gt; 1);
2094                 if (parts[abase + (kmid * 2)] == null) {
2095                     kmin = kmid + 1;
2096                 } else {
2097                     kmax = kmid;
2098                 }
2099                 assert (kmin &lt;= kmax);
2100             }
2101             return abase + (kmax * 2);
2102         }
2103 
2104         /** Sort attributes by name. */
2105         public void sortAttrs() {
2106             checkNotFrozen();
2107             int abase = attrBase();
2108             int alen = parts.length - abase;
2109             String[] buf = new String[alen];
2110             // collect keys
2111             for (int k = 0; k &lt; alen / 2; k++) {
2112                 String akey = (String) parts[abase + (k * 2) + 0];
2113                 buf[k] = akey;
2114             }
2115             Arrays.sort(buf, 0, alen / 2);
2116             // collect values
2117             for (int k = 0; k &lt; alen / 2; k++) {
2118                 String akey = buf[k];
2119                 buf[k + alen / 2] = getAttr(akey);
2120             }
2121             // reorder keys and values
2122             int fillp = parts.length;
2123             for (int k = 0; k &lt; alen / 2; k++) {
2124                 String akey = buf[k];
2125                 String aval = buf[k + alen / 2];
2126                 fillp -= 2;
2127                 parts[fillp + 0] = akey;
2128                 parts[fillp + 1] = aval;
2129             }
2130             assert (fillp == abase);
2131         }
2132 
2133         /*
2134         Notes on whitespace and tokenization.
2135         On input, never split CDATA blocks.  They remain single tokens.
2136         ?Try to treat encoded characters as CDATA-quoted, also?
2137 
2138         Internally, each String sub-element is logically a token.
2139         However, if there was no token-splitting on input,
2140         consecutive strings are merged by the parser.
2141 
2142         Internally, we need addToken (intervening blank) and addText
2143         (hard concatenation).
2144 
2145         Optionally on input, tokenize unquoted text into words.
2146         Between each adjacent word pair, elide either one space
2147         or all space.
2148 
2149         On output, we always add spaces between tokens.
2150         The Element(&quot;a&quot;, {&quot;b&quot;, &quot;c&quot;, Element(&quot;d&quot;), &quot;e    f&quot;})
2151         outputs as &quot;&lt;a&gt;b c&lt;d/&gt;e    f&lt;/a&gt;&quot;
2152          */
2153         /** Split strings into tokens, using a StringTokenizer. */
2154         public void tokenize(String delims, boolean returnDelims) {
2155             checkNotFrozen();
2156             if (delims == null) {
2157                 delims = WHITESPACE_CHARS;  // StringTokenizer default
2158             }
2159             for (int i = 0; i &lt; size; i++) {
2160                 if (!(parts[i] instanceof CharSequence)) {
2161                     continue;
2162                 }
2163                 int osize = size;
2164                 String str = parts[i].toString();
2165                 StringTokenizer st = new StringTokenizer(str, delims, returnDelims);
2166                 int nstrs = st.countTokens();
2167                 switch (nstrs) {
2168                     case 0:
2169                         close(i--, 1);
2170                         break;
2171                     case 1:
2172                         parts[i] = st.nextToken();
2173                         break;
2174                     default:
2175                         openOrExpand(i + 1, nstrs - 1);
2176                         for (int j = 0; j &lt; nstrs; j++) {
2177                             parts[i + j] = st.nextToken();
2178                         }
2179                         i += nstrs - 1;
2180                         break;
2181                 }
2182             }
2183         }
2184 
2185         public void tokenize(String delims) {
2186             tokenize(delims, false);
2187         }
2188 
2189         public void tokenize() {
2190             tokenize(null, false);
2191         }
2192 
2193         // views
2194         class LView extends AbstractList&lt;Object&gt; {
2195 
2196             Element asElement() {
2197                 return Element.this;
2198             }
2199 
2200             public int size() {
2201                 return Element.this.size();
2202             }
2203 
2204             public Object get(int i) {
2205                 return Element.this.get(i);
2206             }
2207 
2208             @Override
2209             public boolean contains(Object e) {
2210                 return Element.this.contains(e);
2211             }
2212 
2213             @Override
2214             public Object[] toArray() {
2215                 return Element.this.toArray();
2216             }
2217 
2218             @Override
2219             public int indexOf(Object e) {
2220                 return Element.this.indexOf(e);
2221             }
2222 
2223             @Override
2224             public int lastIndexOf(Object e) {
2225                 return Element.this.lastIndexOf(e);
2226             }
2227 
2228             @Override
2229             public void add(int i, Object e) {
2230                 ++modCount;
2231                 Element.this.add(i, e);
2232             }
2233 
2234             @Override
2235             public boolean addAll(int i, Collection&lt;? extends Object&gt; c) {
2236                 ++modCount;
2237                 return Element.this.addAll(i, c) &gt; 0;
2238             }
2239 
2240             @Override
2241             public boolean addAll(Collection&lt;? extends Object&gt; c) {
2242                 ++modCount;
2243                 return Element.this.addAll(c) &gt; 0;
2244             }
2245 
2246             @Override
2247             public Object remove(int i) {
2248                 ++modCount;
2249                 return Element.this.remove(i);
2250             }
2251 
2252             @Override
2253             public Object set(int i, Object e) {
2254                 ++modCount;
2255                 return Element.this.set(i, e);
2256             }
2257 
2258             @Override
2259             public void clear() {
2260                 ++modCount;
2261                 Element.this.clear();
2262             }
2263             // Others: toArray(Object[]), containsAll, removeAll, retainAll
2264         }
2265 
2266         /** Produce a list view of sub-elements.
2267          *  (The list view does not provide access to the element&#39;s
2268          *  name or attributes.)
2269          *  Changes to this view are immediately reflected in the
2270          *  element itself.
2271          */
2272         public List&lt;Object&gt; asList() {
2273             return new LView();
2274         }
2275 
2276         /** Produce a list iterator on all sub-elements. */
2277         public ListIterator&lt;Object&gt; iterator() {
2278             //return asList().listIterator();
2279             return new Itr();
2280         }
2281 
2282         // Hand-inlined replacement for LView.listIterator():
2283         class Itr implements ListIterator&lt;Object&gt; {
2284 
2285             int lastRet = -1;
2286             int cursor = 0;
2287 
2288             public boolean hasNext() {
2289                 return cursor &lt; size;
2290             }
2291 
2292             public boolean hasPrevious() {
2293                 return cursor &gt; 0 &amp;&amp; cursor &lt;= size;
2294             }
2295 
2296             public Object next() {
2297                 if (!hasNext()) {
2298                     nsee();
2299                 }
2300                 return parts[lastRet = cursor++];
2301             }
2302 
2303             public Object previous() {
2304                 if (!hasPrevious()) {
2305                     nsee();
2306                 }
2307                 return parts[--cursor];
2308             }
2309 
2310             public int nextIndex() {
2311                 return cursor;
2312             }
2313 
2314             public int previousIndex() {
2315                 return cursor - 1;
2316             }
2317 
2318             public void set(Object x) {
2319                 parts[lastRet] = x;
2320             }
2321 
2322             public void add(Object x) {
2323                 lastRet = -1;
2324                 Element.this.add(cursor++, x);
2325             }
2326 
2327             public void remove() {
2328                 if (lastRet &lt; 0) {
2329                     throw new IllegalStateException();
2330                 }
2331                 Element.this.remove(lastRet);
2332                 if (lastRet &lt; cursor) {
2333                     --cursor;
2334                 }
2335                 lastRet = -1;
2336             }
2337 
2338             void nsee() {
2339                 throw new NoSuchElementException(&quot;element &quot; + cursor);
2340             }
2341         }
2342 
2343         /** A PrintWriter which always appends as if by addText.
2344          *  Use of this stream may insert a StringBuffer at the end
2345          *  of the Element.  The user must not directly modify this
2346          *  StringBuffer, or use it in other data structures.
2347          *  From time to time, the StringBuffer may be replaced by a
2348          *  constant string as a result of using the PrintWriter.
2349          */
2350         public PrintWriter asWriter() {
2351             return new ElemW();
2352         }
2353 
2354         class ElemW extends PrintWriter {
2355 
2356             ElemW() {
2357                 super(new StringWriter());
2358             }
2359             final StringBuffer buf = ((StringWriter) out).getBuffer();
2360 
2361             {
2362                 lock = buf;
2363             }  // synchronize on this buffer
2364 
2365             @Override
2366             public void println() {
2367                 synchronized (buf) {
2368                     ensureCursor();
2369                     super.println();
2370                 }
2371             }
2372 
2373             @Override
2374             public void write(int ch) {
2375                 synchronized (buf) {
2376                     ensureCursor();
2377                     //buf.append(ch);
2378                     super.write(ch);
2379                 }
2380             }
2381 
2382             @Override
2383             public void write(char buf[], int off, int len) {
2384                 synchronized (buf) {
2385                     ensureCursor();
2386                     super.write(buf, off, len);
2387                 }
2388             }
2389 
2390             @Override
2391             public void write(String s, int off, int len) {
2392                 synchronized (buf) {
2393                     ensureCursor();
2394                     //buf.append(s.substring(off, off+len));
2395                     super.write(s, off, len);
2396                 }
2397             }
2398 
2399             @Override
2400             public void write(String s) {
2401                 synchronized (buf) {
2402                     ensureCursor();
2403                     //buf.append(s);
2404                     super.write(s);
2405                 }
2406             }
2407 
2408             private void ensureCursor() {
2409                 checkNotFrozen();
2410                 if (getLast() != buf) {
2411                     int pos = indexOf(buf);
2412                     if (pos &gt;= 0) {
2413                         // Freeze the pre-existing use of buf.
2414                         setRaw(pos, buf.toString());
2415                     }
2416                     add(buf);
2417                 }
2418             }
2419         }
2420 
2421         /** Produce a map view of attributes, in which the attribute
2422          *  name strings are the keys.
2423          *  (The map view does not provide access to the element&#39;s
2424          *  name or sub-elements.)
2425          *  Changes to this view are immediately reflected in the
2426          *  element itself.
2427          */
2428         public Map&lt;String, String&gt; asAttrMap() {
2429             class Entry implements Map.Entry&lt;String, String&gt; {
2430 
2431                 final int k;
2432 
2433                 Entry(int k) {
2434                     this.k = k;
2435                     assert (((String) getKey()).toString() != null);  // check, fail-fast
2436                 }
2437 
2438                 public String getKey() {
2439                     return Element.this.getAttrName(k);
2440                 }
2441 
2442                 public String getValue() {
2443                     return Element.this.getAttr(k);
2444                 }
2445 
2446                 public String setValue(String v) {
2447                     return Element.this.setAttr(k, v.toString());
2448                 }
2449 
2450                 @Override
2451                 public boolean equals(Object o) {
2452                     if (!(o instanceof Map.Entry)) {
2453                         return false;
2454                     }
2455                     Map.Entry that = (Map.Entry) o;
2456                     return (this.getKey().equals(that.getKey())
2457                             &amp;&amp; this.getValue().equals(that.getValue()));
2458                 }
2459 
2460                 @Override
2461                 public int hashCode() {
2462                     return getKey().hashCode() ^ getValue().hashCode();
2463                 }
2464             }
2465             class EIter implements Iterator&lt;Map.Entry&lt;String, String&gt;&gt; {
2466 
2467                 int k = 0;  // index of pending next() attribute
2468 
2469                 public boolean hasNext() {
2470                     return Element.this.containsAttr(k);
2471                 }
2472 
2473                 public Map.Entry&lt;String, String&gt; next() {
2474                     return new Entry(k++);
2475                 }
2476 
2477                 public void remove() {
2478                     Element.this.removeAttr(--k);
2479                 }
2480             }
2481             class ESet extends AbstractSet&lt;Map.Entry&lt;String, String&gt;&gt; {
2482 
2483                 public int size() {
2484                     return Element.this.attrSize();
2485                 }
2486 
2487                 public Iterator&lt;Map.Entry&lt;String, String&gt;&gt; iterator() {
2488                     return new EIter();
2489                 }
2490 
2491                 @Override
2492                 public void clear() {
2493                     Element.this.clearAttrs();
2494                 }
2495             }
2496             class AView extends AbstractMap&lt;String, String&gt; {
2497 
2498                 private transient Set&lt;Map.Entry&lt;String, String&gt;&gt; eSet;
2499 
2500                 public Set&lt;Map.Entry&lt;String, String&gt;&gt; entrySet() {
2501                     if (eSet == null) {
2502                         eSet = new ESet();
2503                     }
2504                     return eSet;
2505                 }
2506 
2507                 @Override
2508                 public int size() {
2509                     return Element.this.attrSize();
2510                 }
2511 
2512                 public boolean containsKey(String k) {
2513                     return Element.this.containsAttr(k);
2514                 }
2515 
2516                 public String get(String k) {
2517                     return Element.this.getAttr(k);
2518                 }
2519 
2520                 @Override
2521                 public String put(String k, String v) {
2522                     return Element.this.setAttr(k, v.toString());
2523                 }
2524 
2525                 public String remove(String k) {
2526                     return Element.this.setAttr(k, null);
2527                 }
2528             }
2529             return new AView();
2530         }
2531 
2532         /** Reports number of additional elements this object can accommodate
2533          *  without reallocation.
2534          */
2535         public int getExtraCapacity() {
2536             int abase = attrBase();
2537             return Math.max(0, abase - size - NEED_SLOP);
2538         }
2539 
2540         /** Ensures that at least the given number of additional elements
2541          *  can be added to this object without reallocation.
2542          */
2543         public void ensureExtraCapacity(int cap) {
2544             if (cap == 0 || hasNulls(cap + NEED_SLOP)) {
2545                 return;
2546             }
2547             setExtraCapacity(cap);
2548         }
2549 
2550         /**
2551          * Trim excess capacity to zero, or do nothing if frozen.
2552          * This minimizes the space occupied by this Element,
2553          * at the expense of a reallocation if sub-elements or attributes
2554          * are added later.
2555          */
2556         public void trimToSize() {
2557             if (isFrozen()) {
2558                 return;
2559             }
2560             setExtraCapacity(0);
2561         }
2562 
2563         /** Changes the number of additional elements this object can accommodate
2564          *  without reallocation.
2565          */
2566         public void setExtraCapacity(int cap) {
2567             checkNotFrozen();
2568             int abase = attrBase();
2569             int alen = parts.length - abase;  // slots allocated for attrs
2570             int nlen = size + cap + NEED_SLOP + alen;
2571             if (nlen != parts.length) {
2572                 Object[] nparts = new Object[nlen];
2573                 // copy attributes
2574                 System.arraycopy(parts, abase, nparts, nlen - alen, alen);
2575                 // copy sub-elements
2576                 System.arraycopy(parts, 0, nparts, 0, size);
2577                 parts = nparts;
2578             }
2579             assert (cap == getExtraCapacity());
2580         }
2581 
2582         // Return true if there are at least len nulls of slop available.
2583         boolean hasNulls(int len) {
2584             if (len == 0) {
2585                 return true;
2586             }
2587             int lastNull = size + len - 1;
2588             if (lastNull &gt;= parts.length) {
2589                 return false;
2590             }
2591             return (parts[lastNull] == null);
2592         }
2593 
2594         // Opens up parts array at pos by len spaces.
2595         void open(int pos, int len) {
2596             assert (pos &lt; size);
2597             assert (hasNulls(len + NEED_SLOP));
2598             checkNotFrozen();
2599             int nsize = size + len;
2600             int tlen = size - pos;
2601             System.arraycopy(parts, pos, parts, pos + len, tlen);
2602             size = nsize;
2603         }
2604 
2605         // Reallocate and open up at parts[pos] to at least len empty places.
2606         // Shift anything after pos right by len.  Reallocate if necessary.
2607         // If pos &lt; size, caller must fill it in with non-null values.
2608         // Returns incremented size; caller is responsible for storing it
2609         // down, if desired.
2610         int expand(int pos, int len) {
2611             assert (pos &lt;= size);
2612             // There must be at least len nulls between elems and attrs.
2613             assert (!hasNulls(NEED_SLOP + len));  // caller responsibility
2614             checkNotFrozen();
2615             int nsize = size + len;  // length of all elements
2616             int tlen = size - pos;   // length of elements in post-pos tail
2617             int abase = attrBase();
2618             int alen = parts.length - abase;  // slots allocated for attrs
2619             int nlen = nsize + alen + NEED_SLOP;
2620             nlen += (nlen &gt;&gt;&gt; 1);  // add new slop!
2621             Object[] nparts = new Object[nlen];
2622             // copy head of sub-elements
2623             System.arraycopy(parts, 0, nparts, 0, pos);
2624             // copy tail of sub-elements
2625             System.arraycopy(parts, pos, nparts, pos + len, tlen);
2626             // copy attributes
2627             System.arraycopy(parts, abase, nparts, nlen - alen, alen);
2628             // update self
2629             parts = nparts;
2630             //assert(hasNulls(len));  &lt;- not yet true, since size != nsize
2631             return nsize;
2632         }
2633 
2634         // Open or expand at the given position, as appropriate.
2635         boolean openOrExpand(int pos, int len) {
2636             if (pos &lt; 0 || pos &gt; size) {
2637                 badIndex(pos);
2638             }
2639             if (hasNulls(len + NEED_SLOP)) {
2640                 if (pos == size) {
2641                     size += len;
2642                 } else {
2643                     open(pos, len);
2644                 }
2645                 return false;
2646             } else {
2647                 size = expand(pos, len);
2648                 return true;
2649             }
2650         }
2651 
2652         // Close up at parts[pos] len old places.
2653         // Shift anything after pos left by len.
2654         // Fill unused end of parts with null.
2655         void close(int pos, int len) {
2656             assert (len &gt; 0);
2657             assert ((size - pos) &gt;= len);
2658             checkNotFrozen();
2659             int tlen = (size - pos) - len;   // length of elements in post-pos tail
2660             int nsize = size - len;
2661             System.arraycopy(parts, pos + len, parts, pos, tlen);
2662             // reinitialize the unoccupied slots to null
2663             clearParts(nsize, nsize + len);
2664             // update self
2665             size = nsize;
2666             assert (hasNulls(len));
2667         }
2668 
2669         public void writeTo(Writer w) throws IOException {
2670             new Printer(w).print(this);
2671         }
2672 
2673         public void writePrettyTo(Writer w) throws IOException {
2674             prettyPrintTo(w, this);
2675         }
2676 
2677         public String prettyString() {
2678             StringWriter sw = new StringWriter();
2679             try {
2680                 writePrettyTo(sw);
2681             } catch (IOException ee) {
2682                 throw new Error(ee);  // should not happen
2683             }
2684             return sw.toString();
2685         }
2686 
2687         @Override
2688         public String toString() {
2689             StringWriter sw = new StringWriter();
2690             try {
2691                 writeTo(sw);
2692             } catch (IOException ee) {
2693                 throw new Error(ee);  // should not happen
2694             }
2695             return sw.toString();
2696         }
2697 
2698         public String dump() {
2699             // For debugging only.  Reveals internal layout.
2700             StringBuilder buf = new StringBuilder();
2701             buf.append(&quot;&lt;&quot;).append(name).append(&quot;[&quot;).append(size).append(&quot;]&quot;);
2702             for (int i = 0; i &lt; parts.length; i++) {
2703                 Object p = parts[i];
2704                 if (p == null) {
2705                     buf.append(&quot; null&quot;);
2706                 } else {
2707                     buf.append(&quot; {&quot;);
2708                     String cname = p.getClass().getName();
2709                     cname = cname.substring(1 + cname.indexOf(&#39;/&#39;));
2710                     cname = cname.substring(1 + cname.indexOf(&#39;$&#39;));
2711                     cname = cname.substring(1 + cname.indexOf(&#39;#&#39;));
2712                     if (!cname.equals(&quot;String&quot;)) {
2713                         buf.append(cname).append(&quot;:&quot;);
2714                     }
2715                     buf.append(p);
2716                     buf.append(&quot;}&quot;);
2717                 }
2718             }
2719             return buf.append(&quot;&gt;&quot;).toString();
2720         }
2721 
2722         public static java.lang.reflect.Method method(String name) {
2723             HashMap allM = allMethods;
2724             if (allM == null) {
2725                 allM = makeAllMethods();
2726             }
2727             java.lang.reflect.Method res = (java.lang.reflect.Method) allMethods.get(name);
2728             if (res == null) {
2729                 throw new IllegalArgumentException(name);
2730             }
2731             return res;
2732         }
2733         private static HashMap allMethods;
2734 
2735         private static synchronized HashMap makeAllMethods() {
2736             if (allMethods != null) {
2737                 return allMethods;
2738             }
2739             java.lang.reflect.Method[] methods = Element.class.getMethods();
2740             HashMap&lt;String, java.lang.reflect.Method&gt; allM = new HashMap&lt;String, java.lang.reflect.Method&gt;(),
2741                     ambig = new HashMap&lt;String, java.lang.reflect.Method&gt;();
2742             for (int i = 0; i &lt; methods.length; i++) {
2743                 java.lang.reflect.Method m = methods[i];
2744                 Class[] args = m.getParameterTypes();
2745                 String name = m.getName();
2746                 assert (java.lang.reflect.Modifier.isPublic(m.getModifiers()));
2747                 if (name.startsWith(&quot;notify&quot;)) {
2748                     continue;
2749                 }
2750                 if (name.endsWith(&quot;Attr&quot;)
2751                         &amp;&amp; args.length &gt; 0 &amp;&amp; args[0] == int.class) // ignore getAttr(int), etc.
2752                 {
2753                     continue;
2754                 }
2755                 if (name.endsWith(&quot;All&quot;)
2756                         &amp;&amp; args.length &gt; 1 &amp;&amp; args[0] == Filter.class) // ignore findAll(Filter, int...), etc.
2757                 {
2758                     continue;
2759                 }
2760                 java.lang.reflect.Method pm = allM.put(name, m);
2761                 if (pm != null) {
2762                     Class[] pargs = pm.getParameterTypes();
2763                     if (pargs.length &gt; args.length) {
2764                         allM.put(name, pm);   // put it back
2765                     } else if (pargs.length == args.length) {
2766                         ambig.put(name, pm);  // make a note of it
2767                     }
2768                 }
2769             }
2770             // Delete ambiguous methods.
2771             for (Map.Entry&lt;String, java.lang.reflect.Method&gt; e : ambig.entrySet()) {
2772                 String name = e.getKey();
2773                 java.lang.reflect.Method pm = e.getValue();
2774                 java.lang.reflect.Method m = allM.get(name);
2775                 Class[] args = m.getParameterTypes();
2776                 Class[] pargs = pm.getParameterTypes();
2777                 if (pargs.length == args.length) {
2778                     //System.out.println(&quot;ambig: &quot;+pm);
2779                     //System.out.println(&quot; with: &quot;+m);
2780                     //ambig: int addAll(int,Element)
2781                     // with: int addAll(int,Collection)
2782                     allM.put(name, null);  // get rid of
2783                 }
2784             }
2785             //System.out.println(&quot;allM: &quot;+allM);
2786             return allMethods = allM;
2787         }
2788     }
2789 
2790     static Object fixupString(Object part) {
2791         if (part instanceof CharSequence &amp;&amp; !(part instanceof String)) {
2792             return part.toString();
2793         } else {
2794             return part;
2795         }
2796     }
2797 
2798     public static final class Special implements Comparable&lt;Special&gt; {
2799 
2800         String kind;
2801         Object value;
2802 
2803         public Special(String kind, Object value) {
2804             this.kind = kind;
2805             this.value = value;
2806         }
2807 
2808         public String getKind() {
2809             return kind;
2810         }
2811 
2812         public Object getValue() {
2813             return value;
2814         }
2815 
2816         @Override
2817         public boolean equals(Object o) {
2818             if (!(o instanceof Special)) {
2819                 return false;
2820             }
2821             Special that = (Special) o;
2822             return this.kind.equals(that.kind) &amp;&amp; this.value.equals(that.value);
2823         }
2824 
2825         @Override
2826         public int hashCode() {
2827             return kind.hashCode() * 65 + value.hashCode();
2828         }
2829 
2830         public int compareTo(Special that) {
2831             int r = this.kind.compareTo(that.kind);
2832             if (r != 0) {
2833                 return r;
2834             }
2835             return ((Comparable) this.value).compareTo(that.value);
2836         }
2837 
2838         @Override
2839         public String toString() {
2840             int split = kind.indexOf(&#39; &#39;);
2841             String pref = kind.substring(0, split &lt; 0 ? 0 : split);
2842             String post = kind.substring(split + 1);
2843             return pref + value + post;
2844         }
2845     }
2846 
2847     /** Supports sorting of mixed content.  Sorts strings first,
2848      *  then Elements, then everything else (as Comparable).
2849      */
2850     public static Comparator&lt;Object&gt; contentOrder() {
2851         return CONTENT_ORDER;
2852     }
2853     private static Comparator&lt;Object&gt; CONTENT_ORDER = new ContentComparator();
2854 
2855     private static class ContentComparator implements Comparator&lt;Object&gt; {
2856 
2857         public int compare(Object o1, Object o2) {
2858             boolean cs1 = (o1 instanceof CharSequence);
2859             boolean cs2 = (o2 instanceof CharSequence);
2860             if (cs1 &amp;&amp; cs2) {
2861                 String s1 = (String) fixupString(o1);
2862                 String s2 = (String) fixupString(o2);
2863                 return s1.compareTo(s2);
2864             }
2865             if (cs1) {
2866                 return 0 - 1;
2867             }
2868             if (cs2) {
2869                 return 1 - 0;
2870             }
2871             boolean el1 = (o1 instanceof Element);
2872             boolean el2 = (o2 instanceof Element);
2873             if (el1 &amp;&amp; el2) {
2874                 return ((Element) o1).compareTo((Element) o2);
2875             }
2876             if (el1) {
2877                 return 0 - 1;
2878             }
2879             if (el2) {
2880                 return 1 - 0;
2881             }
2882             return ((Comparable) o1).compareTo(o2);
2883         }
2884     }
2885 
2886     /** Used to find, filter, or transform sub-elements.
2887      *  When used as a predicate, the filter returns a null
2888      *  value for false, and the original object value for true.
2889      *  When used as a transformer, the filter may return
2890      *  null, for no values, the original object, a new object,
2891      *  or an anonymous Element (meaning multiple results).
2892      */
2893     public interface Filter {
2894 
2895         Object filter(Object value);
2896     }
2897 
2898     /** Use this to find an element, perhaps with a given name. */
2899     public static class ElementFilter implements Filter {
2900 
2901         /** Subclasses may override this to implement better value tests.
2902          *  By default, it returns the element itself, thus recognizing
2903          *  all elements, regardless of name.
2904          */
2905         public Element filter(Element elem) {
2906             return elem;  // override this
2907         }
2908 
2909         public final Object filter(Object value) {
2910             if (!(value instanceof Element)) {
2911                 return null;
2912             }
2913             return filter((Element) value);
2914         }
2915 
2916         @Override
2917         public String toString() {
2918             return &quot;&lt;ElementFilter name=&#39;*&#39;/&gt;&quot;;
2919         }
2920     }
2921     private static Filter elementFilter;
2922 
2923     public static Filter elementFilter() {
2924         return (elementFilter != null) ? elementFilter : (elementFilter = new ElementFilter());
2925     }
2926 
2927     public static Filter elementFilter(final String name) {
2928         name.toString();  // null check
2929         return new ElementFilter() {
2930 
2931             @Override
2932             public Element filter(Element elem) {
2933                 return name.equals(elem.name) ? elem : null;
2934             }
2935 
2936             @Override
2937             public String toString() {
2938                 return &quot;&lt;ElementFilter name=&#39;&quot; + name + &quot;&#39;/&gt;&quot;;
2939             }
2940         };
2941     }
2942 
2943     public static Filter elementFilter(final Collection nameSet) {
2944         Objects.requireNonNull(nameSet);
2945         return new ElementFilter() {
2946 
2947             @Override
2948             public Element filter(Element elem) {
2949                 return nameSet.contains(elem.name) ? elem : null;
2950             }
2951 
2952             @Override
2953             public String toString() {
2954                 return &quot;&lt;ElementFilter name=&#39;&quot; + nameSet + &quot;&#39;/&gt;&quot;;
2955             }
2956         };
2957     }
2958 
2959     public static Filter elementFilter(String... nameSet) {
2960         Collection&lt;String&gt; ncoll = Arrays.asList(nameSet);
2961         if (nameSet.length &gt; 10) {
2962             ncoll = new HashSet&lt;String&gt;(ncoll);
2963         }
2964         return elementFilter(ncoll);
2965     }
2966 
2967     /** Use this to find an element with a named attribute,
2968      *  possibly with a particular value.
2969      *  (Note that an attribute is missing if and only if its value is null.)
2970      */
2971     public static class AttrFilter extends ElementFilter {
2972 
2973         protected final String attrName;
2974 
2975         public AttrFilter(String attrName) {
2976             this.attrName = attrName.toString();
2977         }
2978 
2979         /** Subclasses may override this to implement better value tests.
2980          *  By default, it returns true for any non-null value, thus
2981          *  recognizing any attribute of the given name, regardless of value.
2982          */
2983         public boolean test(String attrVal) {
2984             return attrVal != null;  // override this
2985         }
2986 
2987         @Override
2988         public final Element filter(Element elem) {
2989             return test(elem.getAttr(attrName)) ? elem : null;
2990         }
2991 
2992         @Override
2993         public String toString() {
2994             return &quot;&lt;AttrFilter name=&#39;&quot; + attrName + &quot;&#39; value=&#39;*&#39;/&gt;&quot;;
2995         }
2996     }
2997 
2998     public static Filter attrFilter(String attrName) {
2999         return new AttrFilter(attrName);
3000     }
3001 
3002     public static Filter attrFilter(String attrName, final String attrVal) {
3003         if (attrVal == null) {
3004             return not(attrFilter(attrName));
3005         }
3006         return new AttrFilter(attrName) {
3007 
3008             @Override
3009             public boolean test(String attrVal2) {
3010                 return attrVal.equals(attrVal2);
3011             }
3012 
3013             @Override
3014             public String toString() {
3015                 return &quot;&lt;AttrFilter name=&#39;&quot; + attrName + &quot;&#39; value=&#39;&quot; + attrVal + &quot;&#39;/&gt;&quot;;
3016             }
3017         };
3018     }
3019 
3020     public static Filter attrFilter(Element matchThis, String attrName) {
3021         return attrFilter(attrName, matchThis.getAttr(attrName));
3022     }
3023 
3024     /** Use this to find a sub-element of a given class. */
3025     public static Filter classFilter(final Class clazz) {
3026         return new Filter() {
3027 
3028             public Object filter(Object value) {
3029                 return clazz.isInstance(value) ? value : null;
3030             }
3031 
3032             @Override
3033             public String toString() {
3034                 return &quot;&lt;ClassFilter class=&#39;&quot; + clazz.getName() + &quot;&#39;/&gt;&quot;;
3035             }
3036         };
3037     }
3038     private static Filter textFilter;
3039 
3040     public static Filter textFilter() {
3041         return (textFilter != null) ? textFilter : (textFilter = classFilter(CharSequence.class));
3042     }
3043     private static Filter specialFilter;
3044 
3045     public static Filter specialFilter() {
3046         return (specialFilter != null) ? specialFilter : (specialFilter = classFilter(Special.class));
3047     }
3048     private static Filter selfFilter;
3049 
3050     /** This filter always returns its own argument. */
3051     public static Filter selfFilter() {
3052         if (selfFilter != null) {
3053             return selfFilter;
3054         }
3055         return selfFilter = new Filter() {
3056 
3057             public Object filter(Object value) {
3058                 return value;
3059             }
3060 
3061             @Override
3062             public String toString() {
3063                 return &quot;&lt;Self/&gt;&quot;;
3064             }
3065         };
3066     }
3067 
3068     /** This filter always returns a fixed value, regardless of argument. */
3069     public static Filter constantFilter(final Object value) {
3070         return new Filter() {
3071 
3072             public Object filter(Object ignore) {
3073                 return value;
3074             }
3075 
3076             @Override
3077             public String toString() {
3078                 return &quot;&lt;Constant&gt;&quot; + value + &quot;&lt;/Constant&gt;&quot;;
3079             }
3080         };
3081     }
3082     private static Filter nullFilter;
3083 
3084     public static Filter nullFilter() {
3085         return (nullFilter != null) ? nullFilter : (nullFilter = constantFilter(null));
3086     }
3087     private static Filter emptyFilter;
3088 
3089     public static Filter emptyFilter() {
3090         return (emptyFilter != null) ? emptyFilter : (emptyFilter = constantFilter(Element.EMPTY));
3091     }
3092 
3093     /** Use this to invert the logical sense of the given filter. */
3094     public static Filter not(final Filter f) {
3095         return new Filter() {
3096 
3097             public Object filter(Object value) {
3098                 return f.filter(value) == null ? value : null;
3099             }
3100 
3101             @Override
3102             public String toString() {
3103                 return &quot;&lt;Not&gt;&quot; + f + &quot;&lt;/Not&gt;&quot;;
3104             }
3105         };
3106     }
3107 
3108     /** Use this to combine several filters with logical AND.
3109      *  Returns either the first null or the last non-null value.
3110      */
3111     public static Filter and(final Filter f0, final Filter f1) {
3112         return and(new Filter[]{f0, f1});
3113     }
3114 
3115     public static Filter and(final Filter... fs) {
3116         switch (fs.length) {
3117             case 0:
3118                 return selfFilter();  // always true (on non-null inputs)
3119             case 1:
3120                 return fs[0];
3121         }
3122         return new Filter() {
3123 
3124             public Object filter(Object value) {
3125                 Object res = fs[0].filter(value);
3126                 if (res != null) {
3127                     res = fs[1].filter(value);
3128                     for (int i = 2; res != null &amp;&amp; i &lt; fs.length; i++) {
3129                         res = fs[i].filter(value);
3130                     }
3131                 }
3132                 return res;
3133             }
3134 
3135             @Override
3136             public String toString() {
3137                 return opToString(&quot;&lt;And&gt;&quot;, fs, &quot;&lt;/And&gt;&quot;);
3138             }
3139         };
3140     }
3141 
3142     /** Use this to combine several filters with logical OR.
3143      *  Returns either the first non-null or the last null value.
3144      */
3145     public static Filter or(final Filter f0, final Filter f1) {
3146         return or(new Filter[]{f0, f1});
3147     }
3148 
3149     public static Filter or(final Filter... fs) {
3150         switch (fs.length) {
3151             case 0:
3152                 return nullFilter();
3153             case 1:
3154                 return fs[0];
3155         }
3156         return new Filter() {
3157 
3158             public Object filter(Object value) {
3159                 Object res = fs[0].filter(value);
3160                 if (res == null) {
3161                     res = fs[1].filter(value);
3162                     for (int i = 2; res == null &amp;&amp; i &lt; fs.length; i++) {
3163                         res = fs[i].filter(value);
3164                     }
3165                 }
3166                 return res;
3167             }
3168 
3169             @Override
3170             public String toString() {
3171                 return opToString(&quot;&lt;Or&gt;&quot;, fs, &quot;&lt;/Or&gt;&quot;);
3172             }
3173         };
3174     }
3175 
3176     /** Use this to combine several filters with logical AND,
3177      *  and where each non-null result is passed as the argument
3178      *  to the next filter.
3179      *  Returns either the first null or the last non-null value.
3180      */
3181     public static Filter stack(final Filter f0, final Filter f1) {
3182         return stack(new Filter[]{f0, f1});
3183     }
3184 
3185     public static Filter stack(final Filter... fs) {
3186         switch (fs.length) {
3187             case 0:
3188                 return nullFilter();
3189             case 1:
3190                 return fs[0];
3191         }
3192         return new Filter() {
3193 
3194             public Object filter(Object value) {
3195                 Object res = fs[0].filter(value);
3196                 if (res != null) {
3197                     res = fs[1].filter(res);
3198                     for (int i = 2; res != null &amp;&amp; i &lt; fs.length; i++) {
3199                         res = fs[i].filter(res);
3200                     }
3201                 }
3202                 return res;
3203             }
3204 
3205             @Override
3206             public String toString() {
3207                 return opToString(&quot;&lt;Stack&gt;&quot;, fs, &quot;&lt;/Stack&gt;&quot;);
3208             }
3209         };
3210     }
3211 
3212     /** Copy everything produced by f to sink, using addContent. */
3213     public static Filter content(final Filter f, final Collection&lt;Object&gt; sink) {
3214         return new Filter() {
3215 
3216             public Object filter(Object value) {
3217                 Object res = f.filter(value);
3218                 addContent(res, sink);
3219                 return res;
3220             }
3221 
3222             @Override
3223             public String toString() {
3224                 return opToString(&quot;&lt;addContent&gt;&quot;, new Object[]{f, sink},
3225                         &quot;&lt;/addContent&gt;&quot;);
3226             }
3227         };
3228     }
3229 
3230     /** Look down the tree using f, collecting fx, else recursing into x.
3231      *  Identities:
3232      *  &lt;code&gt;
3233      *     findInTree(f, s) == findInTree(content(f, s))
3234      *     findInTree(f)    == replaceInTree(and(f, selfFilter())).
3235      *  &lt;/code&gt;
3236      */
3237     public static Filter findInTree(Filter f, Collection&lt;Object&gt; sink) {
3238         if (sink != null) {
3239             f = content(f, sink);
3240         }
3241         return findInTree(f);
3242     }
3243 
3244     /** Look down the tree using f, recursing into x unless fx. */
3245     public static Filter findInTree(final Filter f) {
3246         return new Filter() {
3247 
3248             public Object filter(Object value) {
3249                 Object res = f.filter(value);
3250                 if (res != null) {
3251                     return res;
3252                 }
3253                 if (value instanceof Element) {
3254                     // recurse
3255                     return ((Element) value).find(this);
3256                 }
3257                 return null;
3258             }
3259 
3260             @Override
3261             public String toString() {
3262                 return opToString(&quot;&lt;FindInTree&gt;&quot;, new Object[]{f},
3263                         &quot;&lt;/FindInTree&gt;&quot;);
3264             }
3265         };
3266     }
3267 
3268     /** Look down the tree using f.  Replace each x with fx, else recurse.
3269      *  If post filter g is given, optionally replace with gx after recursion.
3270      */
3271     public static Filter replaceInTree(final Filter f, final Filter g) {
3272         return new Filter() {
3273 
3274             public Object filter(Object value) {
3275                 Object res = (f == null) ? null : f.filter(value);
3276                 if (res != null) {
3277                     return res;
3278                 }
3279                 if (value instanceof Element) {
3280                     // recurse
3281                     ((Element) value).replaceAll(this);
3282                     // Optional postorder traversal:
3283                     if (g != null) {
3284                         res = g.filter(value);
3285                     }
3286                 }
3287                 return res;  // usually null, meaning no replacement
3288             }
3289 
3290             @Override
3291             public String toString() {
3292                 return opToString(&quot;&lt;ReplaceInTree&gt;&quot;,
3293                         new Object[]{f, g},
3294                         &quot;&lt;/ReplaceInTree&gt;&quot;);
3295             }
3296         };
3297     }
3298 
3299     public static Filter replaceInTree(Filter f) {
3300         Objects.requireNonNull(f);
3301         return replaceInTree(f, null);
3302     }
3303 
3304     /** Make a filter which calls this method on the given element.
3305      *  If the method is static, the first argument is passed the
3306      *  the subtree value being filtered.
3307      *  If the method is non-static, the receiver is the subtree value itself.
3308      *  &lt;p&gt;
3309      *  Optionally, additional arguments may be specified.
3310      *  &lt;p&gt;
3311      *  If the filtered value does not match the receiver class
3312      *  (or else the first argument type, if the method is static),
3313      *  the filter returns null without invoking the method.
3314      *  &lt;p&gt;
3315      *  The returned filter value is the result returned from the method.
3316      *  Optionally, a non-null special false result value may be specified.
3317      *  If the result returned from the method is equal to that false value,
3318      *  the filter will return null.
3319      */
3320     public static Filter methodFilter(java.lang.reflect.Method m, Object[] extraArgs,
3321             Object falseResult) {
3322         return methodFilter(m, false, extraArgs, falseResult);
3323     }
3324 
3325     public static Filter methodFilter(java.lang.reflect.Method m,
3326             Object[] args) {
3327         return methodFilter(m, args, null);
3328     }
3329 
3330     public static Filter methodFilter(java.lang.reflect.Method m) {
3331         return methodFilter(m, null, null);
3332     }
3333 
3334     public static Filter testMethodFilter(java.lang.reflect.Method m, Object[] extraArgs,
3335             Object falseResult) {
3336         return methodFilter(m, true, extraArgs, falseResult);
3337     }
3338 
3339     public static Filter testMethodFilter(java.lang.reflect.Method m, Object[] extraArgs) {
3340         return methodFilter(m, true, extraArgs, zeroArgs.get(m.getReturnType()));
3341     }
3342 
3343     public static Filter testMethodFilter(java.lang.reflect.Method m) {
3344         return methodFilter(m, true, null, zeroArgs.get(m.getReturnType()));
3345     }
3346 
3347     private static Filter methodFilter(final java.lang.reflect.Method m,
3348             final boolean isTest,
3349             Object[] extraArgs, final Object falseResult) {
3350         Class[] params = m.getParameterTypes();
3351         final boolean isStatic = java.lang.reflect.Modifier.isStatic(m.getModifiers());
3352         int insertLen = (isStatic ? 1 : 0);
3353         if (insertLen + (extraArgs == null ? 0 : extraArgs.length) &gt; params.length) {
3354             throw new IllegalArgumentException(&quot;too many arguments&quot;);
3355         }
3356         final Object[] args = (params.length == insertLen) ? null
3357                 : new Object[params.length];
3358         final Class valueType = !isStatic ? m.getDeclaringClass() : params[0];
3359         if (valueType.isPrimitive()) {
3360             throw new IllegalArgumentException(&quot;filtered value must be reference type&quot;);
3361         }
3362         int fillp = insertLen;
3363         if (extraArgs != null) {
3364             for (int i = 0; i &lt; extraArgs.length; i++) {
3365                 args[fillp++] = extraArgs[i];
3366             }
3367         }
3368         if (args != null) {
3369             while (fillp &lt; args.length) {
3370                 Class param = params[fillp];
3371                 args[fillp++] = param.isPrimitive() ? zeroArgs.get(param) : null;
3372             }
3373         }
3374         final Thread curt = Thread.currentThread();
3375         class MFilt implements Filter {
3376 
3377             public Object filter(Object value) {
3378                 if (!valueType.isInstance(value)) {
3379                     return null;  // filter fails quickly
3380                 }
3381                 Object[] args1 = args;
3382                 if (isStatic) {
3383                     if (args1 == null) {
3384                         args1 = new Object[1];
3385                     } else if (curt != Thread.currentThread()) // Dirty hack to curtail array copying in common case.
3386                     {
3387                         args1 = (Object[]) args1.clone();
3388                     }
3389                     args1[0] = value;
3390                 }
3391                 Object res;
3392                 try {
3393                     res = m.invoke(value, args1);
3394                 } catch (java.lang.reflect.InvocationTargetException te) {
3395                     Throwable ee = te.getCause();
3396                     if (ee instanceof RuntimeException) {
3397                         throw (RuntimeException) ee;
3398                     }
3399                     if (ee instanceof Error) {
3400                         throw (Error) ee;
3401                     }
3402                     throw new RuntimeException(&quot;throw in filter&quot;, ee);
3403                 } catch (IllegalAccessException ee) {
3404                     throw new RuntimeException(&quot;access error in filter&quot;, ee);
3405                 }
3406                 if (res == null) {
3407                     if (!isTest &amp;&amp; m.getReturnType() == Void.TYPE) {
3408                         // Void methods return self by convention.
3409                         // (But void &quot;tests&quot; always return false.)
3410                         res = value;
3411                     }
3412                 } else {
3413                     if (falseResult != null &amp;&amp; falseResult.equals(res)) {
3414                         res = null;
3415                     } else if (isTest) {
3416                         // Tests return self by convention.
3417                         res = value;
3418                     }
3419                 }
3420                 return res;
3421             }
3422 
3423             @Override
3424             public String toString() {
3425                 return &quot;&lt;Method&gt;&quot; + m + &quot;&lt;/Method&gt;&quot;;
3426             }
3427         }
3428         return new MFilt();
3429     }
3430     private static HashMap&lt;Class, Object&gt; zeroArgs = new HashMap&lt;Class, Object&gt;();
3431 
3432     static {
3433         zeroArgs.put(Boolean.TYPE, Boolean.FALSE);
3434         zeroArgs.put(Character.TYPE, new Character((char) 0));
3435         zeroArgs.put(Byte.TYPE, new Byte((byte) 0));
3436         zeroArgs.put(Short.TYPE, new Short((short) 0));
3437         zeroArgs.put(Integer.TYPE, new Integer(0));
3438         zeroArgs.put(Float.TYPE, new Float(0));
3439         zeroArgs.put(Long.TYPE, new Long(0));
3440         zeroArgs.put(Double.TYPE, new Double(0));
3441     }
3442 
3443     private static String opToString(String s1, Object[] s2, String s3) {
3444         StringBuilder buf = new StringBuilder(s1);
3445         for (int i = 0; i &lt; s2.length; i++) {
3446             if (s2[i] != null) {
3447                 buf.append(s2[i]);
3448             }
3449         }
3450         buf.append(s3);
3451         return buf.toString();
3452     }
3453 
3454     /** Call the filter on each list element x, and replace x with the
3455      *  resulting filter value e, or its parts.
3456      *  If e is null, keep x.  (This eases use of partial-domain filters.)
3457      *  If e is a TokenList or an anonymous Element, add e&#39;s parts
3458      *  to the list instead of x.
3459      *  Otherwise, replace x by e.
3460      *  &lt;p&gt;
3461      *  The effect at each list position &lt;code&gt;n&lt;/code&gt; may be expressed
3462      *  in terms of XMLKit.addContent as follows:
3463      *  &lt;pre&gt;
3464      *     Object e = f.filter(target.get(n));
3465      *     if (e != null) {
3466      *         target.remove(n);
3467      *         addContent(e, target.subList(n,n));
3468      *     }
3469      *  &lt;/pre&gt;
3470      *  &lt;p&gt;
3471      *  Note:  To force deletion of x, simply have the filter return
3472      *  Element.EMPTY or TokenList.EMPTY.
3473      *  To force null filter values to have this effect,
3474      *  use the expression: &lt;code&gt;or(f, emptyFilter())&lt;/code&gt;.
3475      */
3476     public static void replaceAll(Filter f, List&lt;Object&gt; target) {
3477         for (ListIterator&lt;Object&gt; i = target.listIterator(); i.hasNext();) {
3478             Object x = i.next();
3479             Object fx = f.filter(x);
3480             if (fx == null) {
3481                 // Unliked addContent, a null is a no-op here.
3482                 // i.remove();
3483             } else if (fx instanceof TokenList) {
3484                 TokenList tl = (TokenList) fx;
3485                 if (tl.size() == 1) {
3486                     i.set(tl);
3487                 } else {
3488                     i.remove();
3489                     for (String part : tl) {
3490                         i.add(part);
3491                     }
3492                 }
3493             } else if (fx instanceof Element
3494                     &amp;&amp; ((Element) fx).isAnonymous()) {
3495                 Element anon = (Element) fx;
3496                 if (anon.size() == 1) {
3497                     i.set(anon);
3498                 } else {
3499                     i.remove();
3500                     for (Object part : anon) {
3501                         i.add(part);
3502                     }
3503                 }
3504             } else if (x != fx) {
3505                 i.set(fx);
3506             }
3507         }
3508     }
3509 
3510     /** If e is null, return zero.
3511      *  If e is a TokenList or an anonymous Element, add e&#39;s parts
3512      *  to the collection, and return the number of parts.
3513      *  Otherwise, add e to the collection, and return one.
3514      *  If the collection reference is null, the result is as if
3515      *  a throwaway collection were used.
3516      */
3517     public static int addContent(Object e, Collection&lt;Object&gt; sink) {
3518         if (e == null) {
3519             return 0;
3520         } else if (e instanceof TokenList) {
3521             TokenList tl = (TokenList) e;
3522             if (sink != null) {
3523                 sink.addAll(tl);
3524             }
3525             return tl.size();
3526         } else if (e instanceof Element
3527                 &amp;&amp; ((Element) e).isAnonymous()) {
3528             Element anon = (Element) e;
3529             if (sink != null) {
3530                 sink.addAll(anon.asList());
3531             }
3532             return anon.size();
3533         } else {
3534             if (sink != null) {
3535                 sink.add(e);
3536             }
3537             return 1;
3538         }
3539     }
3540 
3541     static Collection&lt;Object&gt; newCounterColl() {
3542         return new AbstractCollection&lt;Object&gt;() {
3543 
3544             int size;
3545 
3546             public int size() {
3547                 return size;
3548             }
3549 
3550             @Override
3551             public boolean add(Object o) {
3552                 ++size;
3553                 return true;
3554             }
3555 
3556             public Iterator&lt;Object&gt; iterator() {
3557                 throw new UnsupportedOperationException();
3558             }
3559         };
3560     }
3561 
3562     /** SAX2 document handler for building Element trees. */
3563     private static class Builder implements ContentHandler, LexicalHandler {
3564         /*, EntityResolver, DTDHandler, ErrorHandler*/
3565 
3566         Collection&lt;Object&gt; sink;
3567         boolean makeFrozen;
3568         boolean tokenizing;
3569 
3570         Builder(Collection&lt;Object&gt; sink, boolean tokenizing, boolean makeFrozen) {
3571             this.sink = sink;
3572             this.tokenizing = tokenizing;
3573             this.makeFrozen = makeFrozen;
3574         }
3575         Object[] parts = new Object[30];
3576         int nparts = 0;
3577         int[] attrBases = new int[10];  // index into parts
3578         int[] elemBases = new int[10];  // index into parts
3579         int depth = -1;  // index into attrBases, elemBases
3580         // Parts is organized this way:
3581         // | name0 | akey aval ... | subelem ... | name1 | ... |
3582         // The position of the first &quot;akey&quot; after name0 is attrBases[0].
3583         // The position of the first &quot;subelem&quot; after name0 is elemBases[0].
3584         // The position after the last part is always nparts.
3585         int mergeableToken = -1;  // index into parts of recent CharSequence
3586         boolean inCData = false;
3587 
3588         void addPart(Object x) {
3589             //System.out.println(&quot;addPart &quot;+x);
3590             if (nparts == parts.length) {
3591                 Object[] newParts = new Object[parts.length * 2];
3592                 System.arraycopy(parts, 0, newParts, 0, parts.length);
3593                 parts = newParts;
3594             }
3595             parts[nparts++] = x;
3596         }
3597 
3598         Object getMergeableToken() {
3599             if (mergeableToken == nparts - 1) {
3600                 assert (parts[mergeableToken] instanceof CharSequence);
3601                 return parts[nparts - 1];
3602             } else {
3603                 return null;
3604             }
3605         }
3606 
3607         void clearMergeableToken() {
3608             if (mergeableToken &gt;= 0) {
3609                 // Freeze temporary StringBuffers into strings.
3610                 assert (parts[mergeableToken] instanceof CharSequence);
3611                 parts[mergeableToken] = parts[mergeableToken].toString();
3612                 mergeableToken = -1;
3613             }
3614         }
3615 
3616         void setMergeableToken() {
3617             if (mergeableToken != nparts - 1) {
3618                 clearMergeableToken();
3619                 mergeableToken = nparts - 1;
3620                 assert (parts[mergeableToken] instanceof CharSequence);
3621             }
3622         }
3623 
3624         // ContentHandler callbacks
3625         public void startElement(String ns, String localName, String name, Attributes atts) {
3626             clearMergeableToken();
3627             addPart(name.intern());
3628             ++depth;
3629             if (depth == attrBases.length) {
3630                 int oldlen = depth;
3631                 int newlen = depth * 2;
3632                 int[] newAB = new int[newlen];
3633                 int[] newEB = new int[newlen];
3634                 System.arraycopy(attrBases, 0, newAB, 0, oldlen);
3635                 System.arraycopy(elemBases, 0, newEB, 0, oldlen);
3636                 attrBases = newAB;
3637                 elemBases = newEB;
3638             }
3639             attrBases[depth] = nparts;
3640             // Collect attributes.
3641             int na = atts.getLength();
3642             for (int k = 0; k &lt; na; k++) {
3643                 addPart(atts.getQName(k).intern());
3644                 addPart(atts.getValue(k));
3645             }
3646             // Get ready to collect elements.
3647             elemBases[depth] = nparts;
3648         }
3649 
3650         public void endElement(String ns, String localName, String name) {
3651             assert (depth &gt;= 0);
3652             clearMergeableToken();
3653             int ebase = elemBases[depth];
3654             int elen = nparts - ebase;
3655             int abase = attrBases[depth];
3656             int alen = ebase - abase;
3657             int nbase = abase - 1;
3658             int cap = alen + (makeFrozen ? 0 : NEED_SLOP) + elen;
3659             Element e = new Element((String) parts[nbase], elen, cap);
3660             // Set up attributes.
3661             for (int k = 0; k &lt; alen; k += 2) {
3662                 e.parts[cap - k - 2] = parts[abase + k + 0];
3663                 e.parts[cap - k - 1] = parts[abase + k + 1];
3664             }
3665             // Set up sub-elements.
3666             System.arraycopy(parts, ebase, e.parts, 0, elen);
3667             // Back out of this level.
3668             --depth;
3669             nparts = nbase;
3670             assert (e.isFrozen() == makeFrozen);
3671             assert (e.size() == elen);
3672             assert (e.attrSize() * 2 == alen);
3673             if (depth &gt;= 0) {
3674                 addPart(e);
3675             } else {
3676                 sink.add(e);
3677             }
3678         }
3679 
3680         public void startCDATA() {
3681             inCData = true;
3682         }
3683 
3684         public void endCDATA() {
3685             inCData = false;
3686         }
3687 
3688         public void characters(char[] buf, int off, int len) {
3689             boolean headSpace = false;
3690             boolean tailSpace = false;
3691             int firstLen;
3692             if (tokenizing &amp;&amp; !inCData) {
3693                 // Strip unquoted blanks.
3694                 while (len &gt; 0 &amp;&amp; isWhitespace(buf[off])) {
3695                     headSpace = true;
3696                     ++off;
3697                     --len;
3698                 }
3699                 if (len == 0) {
3700                     tailSpace = true;  // it is all space
3701                 }
3702                 while (len &gt; 0 &amp;&amp; isWhitespace(buf[off + len - 1])) {
3703                     tailSpace = true;
3704                     --len;
3705                 }
3706                 firstLen = 0;
3707                 while (firstLen &lt; len &amp;&amp; !isWhitespace(buf[off + firstLen])) {
3708                     ++firstLen;
3709                 }
3710             } else {
3711                 firstLen = len;
3712             }
3713             if (headSpace) {
3714                 clearMergeableToken();
3715             }
3716             boolean mergeAtEnd = !tailSpace;
3717             // If buffer was empty, or had only ignorable blanks, do nothing.
3718             if (len == 0) {
3719                 return;
3720             }
3721             // Decide whether to merge some of these chars into a previous token.
3722             Object prev = getMergeableToken();
3723             if (prev instanceof StringBuffer) {
3724                 ((StringBuffer) prev).append(buf, off, firstLen);
3725             } else if (prev == null) {
3726                 addPart(new String(buf, off, firstLen));
3727             } else {
3728                 // Merge two strings.
3729                 String prevStr = prev.toString();
3730                 StringBuffer prevBuf = new StringBuffer(prevStr.length() + firstLen);
3731                 prevBuf.append(prevStr);
3732                 prevBuf.append(buf, off, firstLen);
3733                 if (mergeAtEnd &amp;&amp; len == firstLen) {
3734                     // Replace previous string with new StringBuffer.
3735                     parts[nparts - 1] = prevBuf;
3736                 } else {
3737                     // Freeze it now.
3738                     parts[nparts - 1] = prevBuf.toString();
3739                 }
3740             }
3741             off += firstLen;
3742             len -= firstLen;
3743             if (len &gt; 0) {
3744                 // Appended only the first token.
3745                 clearMergeableToken();
3746                 // Add the rest as separate parts.
3747                 while (len &gt; 0) {
3748                     while (len &gt; 0 &amp;&amp; isWhitespace(buf[off])) {
3749                         ++off;
3750                         --len;
3751                     }
3752                     int nextLen = 0;
3753                     while (nextLen &lt; len &amp;&amp; !isWhitespace(buf[off + nextLen])) {
3754                         ++nextLen;
3755                     }
3756                     assert (nextLen &gt; 0);
3757                     addPart(new String(buf, off, nextLen));
3758                     off += nextLen;
3759                     len -= nextLen;
3760                 }
3761             }
3762             if (mergeAtEnd) {
3763                 setMergeableToken();
3764             }
3765         }
3766 
3767         public void ignorableWhitespace(char[] buf, int off, int len) {
3768             clearMergeableToken();
3769             if (false) {
3770                 characters(buf, off, len);
3771                 clearMergeableToken();
3772             }
3773         }
3774 
3775         public void comment(char[] buf, int off, int len) {
3776             addPart(new Special(&quot;&lt;!-- --&gt;&quot;, new String(buf, off, len)));
3777         }
3778 
3779         public void processingInstruction(String name, String instruction) {
3780             Element pi = new Element(name);
3781             pi.add(instruction);
3782             addPart(new Special(&quot;&lt;? ?&gt;&quot;, pi));
3783         }
3784 
3785         public void skippedEntity(String name) {
3786         }
3787 
3788         public void startDTD(String name, String publicId, String systemId) {
3789         }
3790 
3791         public void endDTD() {
3792         }
3793 
3794         public void startEntity(String name) {
3795         }
3796 
3797         public void endEntity(String name) {
3798         }
3799 
3800         public void setDocumentLocator(org.xml.sax.Locator locator) {
3801         }
3802 
3803         public void startDocument() {
3804         }
3805 
3806         public void endDocument() {
3807         }
3808 
3809         public void startPrefixMapping(String prefix, String uri) {
3810         }
3811 
3812         public void endPrefixMapping(String prefix) {
3813         }
3814     }
3815 
3816     /** Produce a ContentHandler for use with an XML parser.
3817      *  The object is &lt;em&gt;also&lt;/em&gt; a LexicalHandler.
3818      *  Every top-level Element produced will get added to sink.
3819      *  All elements will be frozen iff makeFrozen is true.
3820      */
3821     public static ContentHandler makeBuilder(Collection&lt;Object&gt; sink, boolean tokenizing, boolean makeFrozen) {
3822         return new Builder(sink, tokenizing, makeFrozen);
3823     }
3824 
3825     public static ContentHandler makeBuilder(Collection&lt;Object&gt; sink, boolean tokenizing) {
3826         return new Builder(sink, tokenizing, false);
3827     }
3828 
3829     public static ContentHandler makeBuilder(Collection&lt;Object&gt; sink) {
3830         return makeBuilder(sink, false, false);
3831     }
3832 
3833     public static Element readFrom(Reader in, boolean tokenizing, boolean makeFrozen) throws IOException {
3834         Element sink = new Element();
3835         ContentHandler b = makeBuilder(sink.asList(), tokenizing, makeFrozen);
3836         XMLReader parser;
3837         try {
3838             parser = org.xml.sax.helpers.XMLReaderFactory.createXMLReader();
3839         } catch (SAXException ee) {
3840             throw new Error(ee);
3841         }
3842         //parser.setFastStandalone(true);
3843         parser.setContentHandler(b);
3844         try {
3845             parser.setProperty(&quot;http://xml.org/sax/properties/lexical-handler&quot;,
3846                     (LexicalHandler) b);
3847         } catch (SAXException ee) {
3848             // Ignore.  We will miss the comments and whitespace.
3849         }
3850         try {
3851             parser.parse(new InputSource(in));
3852         } catch (SAXParseException ee) {
3853             throw new RuntimeException(&quot;line &quot; + ee.getLineNumber() + &quot; col &quot; + ee.getColumnNumber() + &quot;: &quot;, ee);
3854         } catch (SAXException ee) {
3855             throw new RuntimeException(ee);
3856         }
3857         switch (sink.size()) {
3858             case 0:
3859                 return null;
3860             case 1:
3861                 if (sink.get(0) instanceof Element) {
3862                     return (Element) sink.get(0);
3863                 }
3864             // fall through
3865             default:
3866                 if (makeFrozen) {
3867                     sink.shallowFreeze();
3868                 }
3869                 return sink;
3870         }
3871     }
3872 
3873     public static Element readFrom(Reader in, boolean tokenizing) throws IOException {
3874         return readFrom(in, tokenizing, false);
3875     }
3876 
3877     public static Element readFrom(Reader in) throws IOException {
3878         return readFrom(in, false, false);
3879     }
3880 
3881     public static void prettyPrintTo(OutputStream out, Element e) throws IOException {
3882         prettyPrintTo(new OutputStreamWriter(out), e);
3883     }
3884 
3885     public static void prettyPrintTo(Writer out, Element e) throws IOException {
3886         Printer pr = new Printer(out);
3887         pr.pretty = true;
3888         pr.print(e);
3889     }
3890 
3891     static class Outputter {
3892 
3893         ContentHandler ch;
3894         LexicalHandler lh;
3895 
3896         Outputter(ContentHandler ch, LexicalHandler lh) {
3897             this.ch = ch;
3898             this.lh = lh;
3899         }
3900         AttributesImpl atts = new AttributesImpl();  // handy
3901 
3902         void output(Object x) throws SAXException {
3903             // Cf. jdom.org/jdom-b8/src/java/org/jdom/output/SAXOutputter.java
3904             if (x instanceof Element) {
3905                 Element e = (Element) x;
3906                 atts.clear();
3907                 for (int asize = e.attrSize(), k = 0; k &lt; asize; k++) {
3908                     String key = e.getAttrName(k);
3909                     String val = e.getAttr(k);
3910                     atts.addAttribute(&quot;&quot;, &quot;&quot;, key, &quot;CDATA&quot;, val);
3911                 }
3912                 ch.startElement(&quot;&quot;, &quot;&quot;, e.getName(), atts);
3913                 for (int i = 0; i &lt; e.size(); i++) {
3914                     output(e.get(i));
3915                 }
3916                 ch.endElement(&quot;&quot;, &quot;&quot;, e.getName());
3917             } else if (x instanceof Special) {
3918                 Special sp = (Special) x;
3919                 if (sp.kind.startsWith(&quot;&lt;!--&quot;)) {
3920                     char[] chars = sp.value.toString().toCharArray();
3921                     lh.comment(chars, 0, chars.length);
3922                 } else if (sp.kind.startsWith(&quot;&lt;?&quot;)) {
3923                     Element nameInstr = (Element) sp.value;
3924                     ch.processingInstruction(nameInstr.name,
3925                             nameInstr.get(0).toString());
3926                 } else {
3927                     // drop silently
3928                 }
3929             } else {
3930                 char[] chars = x.toString().toCharArray();
3931                 ch.characters(chars, 0, chars.length);
3932             }
3933         }
3934     }
3935 
3936     public static class Printer {
3937 
3938         public Writer w;
3939         public boolean tokenizing;
3940         public boolean pretty;
3941         public boolean abbreviated;  // nonstandard format cuts down on noise
3942         int depth = 0;
3943         boolean prevStr;
3944         int tabStop = 2;
3945 
3946         public Printer(Writer w) {
3947             this.w = w;
3948         }
3949 
3950         public Printer() {
3951             StringWriter sw = new StringWriter();
3952             this.w = sw;
3953 
3954         }
3955 
3956         public String nextString() {
3957             StringBuffer sb = ((StringWriter) w).getBuffer();
3958             String next = sb.toString();
3959             sb.setLength(0);  // reset
3960             return next;
3961         }
3962 
3963         void indent(int depth) throws IOException {
3964             if (depth &gt; 0) {
3965                 w.write(&quot;\n&quot;);
3966             }
3967             int nsp = tabStop * depth;
3968             while (nsp &gt; 0) {
3969                 String s = &quot;                &quot;;
3970                 String t = s.substring(0, nsp &lt; s.length() ? nsp : s.length());
3971                 w.write(t);
3972                 nsp -= t.length();
3973             }
3974         }
3975 
3976         public void print(Element e) throws IOException {
3977             if (e.isAnonymous()) {
3978                 printParts(e);
3979                 return;
3980             }
3981             printRecursive(e);
3982         }
3983 
3984         public void println(Element e) throws IOException {
3985             print(e);
3986             w.write(&quot;\n&quot;);
3987             w.flush();
3988         }
3989 
3990         public void printRecursive(Element e) throws IOException {
3991             boolean indented = false;
3992             if (pretty &amp;&amp; !prevStr &amp;&amp; e.size() + e.attrSize() &gt; 0) {
3993                 indent(depth);
3994                 indented = true;
3995             }
3996             w.write(&quot;&lt;&quot;);
3997             w.write(e.name);
3998             for (int asize = e.attrSize(), k = 0; k &lt; asize; k++) {
3999                 String key = e.getAttrName(k);
4000                 String val = e.getAttr(k);
4001                 w.write(&quot; &quot;);
4002                 w.write(key);
4003                 w.write(&quot;=&quot;);
4004                 if (val == null) {
4005                     w.write(&quot;null&quot;);  // Should not happen....
4006                 } else if (val.indexOf(&quot;\&quot;&quot;) &lt; 0) {
4007                     w.write(&quot;\&quot;&quot;);
4008                     writeToken(val, &#39;&quot;&#39;, w);
4009                     w.write(&quot;\&quot;&quot;);
4010                 } else {
4011                     w.write(&quot;&#39;&quot;);
4012                     writeToken(val, &#39;\&#39;&#39;, w);
4013                     w.write(&quot;&#39;&quot;);
4014                 }
4015             }
4016             if (e.size() == 0) {
4017                 w.write(&quot;/&gt;&quot;);
4018             } else {
4019                 ++depth;
4020                 if (abbreviated) {
4021                     w.write(&quot;/&quot;);
4022                 } else {
4023                     w.write(&quot;&gt;&quot;);
4024                 }
4025                 prevStr = false;
4026                 printParts(e);
4027                 if (abbreviated) {
4028                     w.write(&quot;&gt;&quot;);
4029                 } else {
4030                     if (indented &amp;&amp; !prevStr) {
4031                         indent(depth - 1);
4032                     }
4033                     w.write(&quot;&lt;/&quot;);
4034                     w.write(e.name);
4035                     w.write(&quot;&gt;&quot;);
4036                 }
4037                 prevStr = false;
4038                 --depth;
4039             }
4040         }
4041 
4042         private void printParts(Element e) throws IOException {
4043             for (int i = 0; i &lt; e.size(); i++) {
4044                 Object x = e.get(i);
4045                 if (x instanceof Element) {
4046                     printRecursive((Element) x);
4047                     prevStr = false;
4048                 } else if (x instanceof Special) {
4049                     w.write(((Special) x).toString());
4050                     prevStr = false;
4051                 } else {
4052                     String s = String.valueOf(x);
4053                     if (pretty) {
4054                         s = s.trim();
4055                         if (s.length() == 0) {
4056                             continue;
4057                         }
4058                     }
4059                     if (prevStr) {
4060                         w.write(&#39; &#39;);
4061                     }
4062                     writeToken(s, tokenizing ? &#39; &#39; : (char) -1, w);
4063                     prevStr = true;
4064                 }
4065                 if (pretty &amp;&amp; depth == 0) {
4066                     w.write(&quot;\n&quot;);
4067                     prevStr = false;
4068                 }
4069             }
4070         }
4071     }
4072 
4073     public static void output(Object e, ContentHandler ch, LexicalHandler lh) throws SAXException {
4074         new Outputter(ch, lh).output(e);
4075     }
4076 
4077     public static void output(Object e, ContentHandler ch) throws SAXException {
4078         if (ch instanceof LexicalHandler) {
4079             output(e, ch, (LexicalHandler) ch);
4080         } else {
4081             output(e, ch, null);
4082         }
4083     }
4084 
4085     public static void writeToken(String val, char quote, Writer w) throws IOException {
4086         int len = val.length();
4087         boolean canUseCData = (quote != &#39;&quot;&#39; &amp;&amp; quote != &#39;\&#39;&#39;);
4088         int vpos = 0;
4089         for (int i = 0; i &lt; len; i++) {
4090             char ch = val.charAt(i);
4091             if ((ch == &#39;&lt;&#39; || ch == &#39;&amp;&#39; || ch == &#39;&gt;&#39; || ch == quote)
4092                     || (quote == &#39; &#39; &amp;&amp; isWhitespace(ch))) {
4093                 if (canUseCData) {
4094                     assert (vpos == 0);
4095                     writeCData(val, w);
4096                     return;
4097                 } else {
4098                     if (vpos &lt; i) {
4099                         w.write(val, vpos, i - vpos);
4100                     }
4101                     String esc;
4102                     switch (ch) {
4103                         case &#39;&amp;&#39;:
4104                             esc = &quot;&amp;amp;&quot;;
4105                             break;
4106                         case &#39;&lt;&#39;:
4107                             esc = &quot;&amp;lt;&quot;;
4108                             break;
4109                         case &#39;\&#39;&#39;:
4110                             esc = &quot;&amp;apos;&quot;;
4111                             break;
4112                         case &#39;&quot;&#39;:
4113                             esc = &quot;&amp;quot;&quot;;
4114                             break;
4115                         case &#39;&gt;&#39;:
4116                             esc = &quot;&amp;gt;&quot;;
4117                             break;
4118                         default:
4119                             esc = &quot;&amp;#&quot; + (int) ch + &quot;;&quot;;
4120                             break;
4121                     }
4122                     w.write(esc);
4123                     vpos = i + 1;  // skip escaped char
4124                 }
4125             }
4126         }
4127         // write the unquoted tail
4128         w.write(val, vpos, val.length() - vpos);
4129     }
4130 
4131     public static void writeCData(String val, Writer w) throws IOException {
4132         String begCData = &quot;&lt;![CDATA[&quot;;
4133         String endCData = &quot;]]&gt;&quot;;
4134         w.write(begCData);
4135         for (int vpos = 0, split;; vpos = split) {
4136             split = val.indexOf(endCData, vpos);
4137             if (split &lt; 0) {
4138                 w.write(val, vpos, val.length() - vpos);
4139                 w.write(endCData);
4140                 return;
4141             }
4142             split += 2; // bisect the &quot;]]&gt;&quot; goo
4143             w.write(val, vpos, split - vpos);
4144             w.write(endCData);
4145             w.write(begCData);
4146         }
4147     }
4148 
4149     public static TokenList convertToList(String str) {
4150         if (str == null) {
4151             return null;
4152         }
4153         return new TokenList(str);
4154     }
4155 
4156     /** If str is null, empty, or blank, returns null.
4157      *  Otherwise, return a Double if str spells a double value and contains &#39;.&#39; or &#39;e&#39;.
4158      *  Otherwise, return an Integer if str spells an int value.
4159      *  Otherwise, return a Long if str spells a long value.
4160      *  Otherwise, return a BigInteger for the string.
4161      *  Otherwise, throw NumberFormatException.
4162      */
4163     public static Number convertToNumber(String str) {
4164         if (str == null) {
4165             return null;
4166         }
4167         str = str.trim();
4168         if (str.length() == 0) {
4169             return null;
4170         }
4171         if (str.indexOf(&#39;.&#39;) &gt;= 0
4172                 || str.indexOf(&#39;e&#39;) &gt;= 0
4173                 || str.indexOf(&#39;E&#39;) &gt;= 0) {
4174             return Double.valueOf(str);
4175         }
4176         try {
4177             long lval = Long.parseLong(str);
4178             if (lval == (int) lval) {
4179                 // Narrow to Integer, if possible.
4180                 return new Integer((int) lval);
4181             }
4182             return new Long(lval);
4183         } catch (NumberFormatException ee) {
4184             // Could not represent it as a long.
4185             return new java.math.BigInteger(str, 10);
4186         }
4187     }
4188 
4189     public static Number convertToNumber(String str, Number dflt) {
4190         Number n = convertToNumber(str);
4191         return (n == null) ? dflt : n;
4192     }
4193 
4194     public static long convertToLong(String str) {
4195         return convertToLong(str, 0);
4196     }
4197 
4198     public static long convertToLong(String str, long dflt) {
4199         Number n = convertToNumber(str);
4200         return (n == null) ? dflt : n.longValue();
4201     }
4202 
4203     public static double convertToDouble(String str) {
4204         return convertToDouble(str, 0);
4205     }
4206 
4207     public static double convertToDouble(String str, double dflt) {
4208         Number n = convertToNumber(str);
4209         return (n == null) ? dflt : n.doubleValue();
4210     }
4211 
4212     // Testing:
4213     public static void main(String... av) throws Exception {
4214         Element.method(&quot;getAttr&quot;);
4215         //new org.jdom.input.SAXBuilder().build(file).getRootElement();
4216         //jdom.org/jdom-b8/src/java/org/jdom/input/SAXBuilder.java
4217         //Document build(InputSource in) throws JDOMException
4218 
4219         int reps = 0;
4220 
4221         boolean tokenizing = false;
4222         boolean makeFrozen = false;
4223         if (av.length &gt; 0) {
4224             tokenizing = true;
4225             try {
4226                 reps = Integer.parseInt(av[0]);
4227             } catch (NumberFormatException ee) {
4228             }
4229         }
4230         Reader inR = new BufferedReader(new InputStreamReader(System.in));
4231         String inS = null;
4232         if (reps &gt; 1) {
4233             StringWriter inBufR = new StringWriter(1 &lt;&lt; 14);
4234             char[] cbuf = new char[1024];
4235             for (int nr; (nr = inR.read(cbuf)) &gt;= 0;) {
4236                 inBufR.write(cbuf, 0, nr);
4237             }
4238             inS = inBufR.toString();
4239             inR = new StringReader(inS);
4240         }
4241         Element e = XMLKit.readFrom(inR, tokenizing, makeFrozen);
4242         System.out.println(&quot;transform = &quot; + e.findAll(methodFilter(Element.method(&quot;prettyString&quot;))));
4243         System.out.println(&quot;transform = &quot; + e.findAll(testMethodFilter(Element.method(&quot;hasText&quot;))));
4244         long tm0 = 0;
4245         int warmup = 10;
4246         for (int i = 1; i &lt; reps; i++) {
4247             inR = new StringReader(inS);
4248             readFrom(inR, tokenizing, makeFrozen);
4249             if (i == warmup) {
4250                 System.out.println(&quot;Start timing...&quot;);
4251                 tm0 = System.currentTimeMillis();
4252             }
4253         }
4254         if (tm0 != 0) {
4255             long tm1 = System.currentTimeMillis();
4256             System.out.println((reps - warmup) + &quot; in &quot; + (tm1 - tm0) + &quot; ms&quot;);
4257         }
4258         System.out.println(&quot;hashCode = &quot; + e.hashCode());
4259         String eStr = e.toString();
4260         System.out.println(eStr);
4261         Element e2 = readFrom(new StringReader(eStr), tokenizing, !makeFrozen);
4262         System.out.println(&quot;hashCode = &quot; + e2.hashCode());
4263         if (!e.equals(e2)) {
4264             System.out.println(&quot;**** NOT EQUAL 1\n&quot; + e2);
4265         }
4266         e = e.deepCopy();
4267         System.out.println(&quot;hashCode = &quot; + e.hashCode());
4268         if (!e.equals(e2)) {
4269             System.out.println(&quot;**** NOT EQUAL 2&quot;);
4270         }
4271         e2.shallowFreeze();
4272         System.out.println(&quot;hashCode = &quot; + e2.hashCode());
4273         if (!e.equals(e2)) {
4274             System.out.println(&quot;**** NOT EQUAL 3&quot;);
4275         }
4276         if (false) {
4277             System.out.println(e);
4278         } else {
4279             prettyPrintTo(new OutputStreamWriter(System.out), e);
4280         }
4281         System.out.println(&quot;Flat text:|&quot; + e.getFlatText() + &quot;|&quot;);
4282         {
4283             System.out.println(&quot;&lt;!--- Sorted: ---&gt;&quot;);
4284             Element ce = e.copyContentOnly();
4285             ce.sort();
4286             prettyPrintTo(new OutputStreamWriter(System.out), ce);
4287         }
4288         {
4289             System.out.println(&quot;&lt;!--- Trimmed: ---&gt;&quot;);
4290             Element tr = e.deepCopy();
4291             findInTree(testMethodFilter(Element.method(&quot;trimText&quot;))).filter(tr);
4292             System.out.println(tr);
4293         }
4294         {
4295             System.out.println(&quot;&lt;!--- Unstrung: ---&gt;&quot;);
4296             Element us = e.deepCopy();
4297             int nr = us.retainAllInTree(elementFilter(), null);
4298             System.out.println(&quot;nr=&quot; + nr);
4299             System.out.println(us);
4300         }
4301         {
4302             System.out.println(&quot;&lt;!--- Rollup: ---&gt;&quot;);
4303             Element ru = e.deepCopy();
4304             Filter makeAnonF =
4305                     methodFilter(Element.method(&quot;setName&quot;),
4306                     new Object[]{ANON_NAME});
4307             Filter testSizeF =
4308                     testMethodFilter(Element.method(&quot;size&quot;));
4309             Filter walk =
4310                     replaceInTree(and(not(elementFilter()), emptyFilter()),
4311                     and(testSizeF, makeAnonF));
4312             ru = (Element) walk.filter(ru);
4313             //System.out.println(ru);
4314             prettyPrintTo(new OutputStreamWriter(System.out), ru);
4315         }
4316     }
4317 
4318     static boolean isWhitespace(char c) {
4319         switch (c) {
4320             case 0x20:
4321             case 0x09:
4322             case 0x0D:
4323             case 0x0A:
4324                 return true;
4325         }
4326         return false;
4327     }
4328 }
    </pre>
  </body>
</html>
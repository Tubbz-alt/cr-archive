<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old test/jdk/tools/pack200/Pack200Test.java</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2007, 2018, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24  /*
 25   * @test
 26   * @bug 6521334 6712743 8007902 8151901
 27   * @requires (sun.arch.data.model == &quot;64&quot; &amp; os.maxMemory &gt;= 4g)
 28   * @summary test general packer/unpacker functionality
 29   *          using native and java unpackers
 30   * @modules jdk.management
 31   *          jdk.zipfs
 32   * @compile -XDignore.symbol.file Utils.java Pack200Test.java
 33   * @run main/othervm/timeout=1200 -Xmx1280m -Xshare:off Pack200Test
 34   */
 35 
 36 import java.util.*;
 37 import java.io.*;
 38 import java.lang.management.ManagementFactory;
 39 import java.lang.management.MemoryMXBean;
 40 import java.util.jar.*;
 41 
 42 /**
 43  * Tests the packing/unpacking via the APIs.
 44  */
 45 public class Pack200Test {
 46 
 47     private static ArrayList &lt;File&gt; jarList = new ArrayList&lt;File&gt;();
 48     static final MemoryMXBean mmxbean = ManagementFactory.getMemoryMXBean();
 49     static final long m0 = getUsedMemory();
 50     static final int LEAK_TOLERANCE = 21000; // OS and GC related variations.
 51     // enable leak checks only if required, GC charecteristics vary on
 52     // platforms and this may not yield consistent results
 53     static final boolean LEAK_CHECK = Boolean.getBoolean(&quot;Pack200Test.enableLeakCheck&quot;);
 54 
 55     /** Creates a new instance of Pack200Test */
 56     private Pack200Test() {}
 57 
 58     static long getUsedMemory() {
 59         mmxbean.gc();
 60         mmxbean.gc();
 61         mmxbean.gc();
 62         return mmxbean.getHeapMemoryUsage().getUsed()/1024;
 63     }
 64 
 65     private static void leakCheck() throws Exception {
 66         if (!LEAK_CHECK)
 67             return;
 68         long diff = getUsedMemory() - m0;
 69         System.out.println(&quot;  Info: memory diff = &quot; + diff + &quot;K&quot;);
 70         if (diff &gt; LEAK_TOLERANCE) {
 71             throw new Exception(&quot;memory leak detected &quot; + diff);
 72         }
 73     }
 74 
 75     private static void doPackUnpack() throws IOException {
 76         for (File in : jarList) {
 77             JarOutputStream javaUnpackerStream = null;
 78             JarOutputStream nativeUnpackerStream = null;
 79             JarFile jarFile = null;
 80             try {
 81                 jarFile = new JarFile(in);
 82 
 83                 // Write out to a jtreg scratch area
 84                 File packFile = new File(in.getName() + Utils.PACK_FILE_EXT);
 85 
 86                 System.out.println(&quot;Packing [&quot; + in.toString() + &quot;]&quot;);
 87                 // Call the packer
 88                 Utils.pack(jarFile, packFile);
 89                 System.out.println(&quot;Done Packing [&quot; + in.toString() + &quot;]&quot;);
 90                 jarFile.close();
 91                 System.out.println(&quot;Start leak check&quot;);
 92                 leakCheck();
 93 
 94                 System.out.println(&quot;  Unpacking using java unpacker&quot;);
 95                 File javaUnpackedJar = new File(&quot;java-&quot; + in.getName());
 96                 // Write out to current directory, jtreg will setup a scratch area
 97                 javaUnpackerStream = new JarOutputStream(
 98                         new FileOutputStream(javaUnpackedJar));
 99                 Utils.unpackj(packFile, javaUnpackerStream);
100                 javaUnpackerStream.close();
101                 System.out.println(&quot;  Testing...java unpacker&quot;);
102                 leakCheck();
103                 // Ok we have unpacked the file, lets test it.
104                 Utils.doCompareVerify(in.getAbsoluteFile(), javaUnpackedJar);
105 
106                 System.out.println(&quot;  Unpacking using native unpacker&quot;);
107                 // Write out to current directory
108                 File nativeUnpackedJar = new File(&quot;native-&quot; + in.getName());
109                 nativeUnpackerStream = new JarOutputStream(
110                         new FileOutputStream(nativeUnpackedJar));
111                 Utils.unpackn(packFile, nativeUnpackerStream);
112                 nativeUnpackerStream.close();
113                 System.out.println(&quot;  Testing...native unpacker&quot;);
114                 leakCheck();
115                 // the unpackers (native and java) should produce identical bits
116                 // so we use use bit wise compare, the verification compare is
117                 // very expensive wrt. time.
118                 Utils.doCompareBitWise(javaUnpackedJar, nativeUnpackedJar);
119                 System.out.println(&quot;Done.&quot;);
120             } catch (Exception e) {
121                 throw new RuntimeException(e);
122             } finally {
123                 Utils.close(nativeUnpackerStream);
124                 Utils.close(javaUnpackerStream);
125                 Utils.close((Closeable) jarFile);
126             }
127         }
128         Utils.cleanup(); // cleanup artifacts, if successful run
129     }
130 
131     /**
132      * @param args the command line arguments
133      */
134     public static void main(String[] args) throws Exception {
135         // select the jars carefully, adding more jars will increase the
136         // testing time.
137         jarList.add(Utils.createRtJar());
138         jarList.add(Utils.getGoldenJar());
139         System.out.println(jarList);
140         doPackUnpack();
141     }
142 }
    </pre>
  </body>
</html>
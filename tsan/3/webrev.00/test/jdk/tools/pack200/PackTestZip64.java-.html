<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old test/jdk/tools/pack200/PackTestZip64.java</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2014, 2015, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 import java.io.*;
 24 import java.util.ArrayList;
 25 import java.util.Collections;
 26 import java.util.Enumeration;
 27 import java.util.List;
 28 import java.util.jar.JarEntry;
 29 import java.util.jar.JarFile;
 30 import java.util.jar.JarInputStream;
 31 import java.util.jar.JarOutputStream;
 32 import java.util.zip.ZipEntry;
 33 /*
 34  * @test
 35  * @bug 8029646
 36  * @summary tests that native unpacker produces the same result as Java one
 37  * @compile -XDignore.symbol.file Utils.java PackTestZip64.java
 38  * @run main PackTestZip64
 39  * @author kizune
 40  */
 41 
 42 public class PackTestZip64 {
 43 
 44     private static final boolean bigJarEnabled
 45             = Boolean.getBoolean(&quot;PackTestZip64.enableBigJar&quot;);
 46 
 47     public static void main(String... args) throws Exception {
 48         testPacking();
 49         Utils.cleanup();
 50     }
 51 
 52     // 1KB buffer is enough to copy jar content
 53     private static final byte[] BUFFER = new byte[1024];
 54 
 55     static void testPacking() throws IOException {
 56         File testFile = new File(&quot;tools_java.jar&quot;);
 57         if (bigJarEnabled) {
 58             // Add a large number of small files to the golden jar
 59             generateLargeJar(testFile, Utils.getGoldenJar());
 60         } else {
 61             // make a copy of the test specimen to local directory
 62             Utils.copyFile(Utils.getGoldenJar(), testFile);
 63         }
 64 
 65         List&lt;String&gt; cmdsList = new ArrayList&lt;&gt;();
 66 
 67         // Repack file to get the Java-based result
 68         cmdsList.add(Utils.getPack200Cmd());
 69         cmdsList.add(&quot;--repack&quot;);
 70         cmdsList.add(testFile.getName());
 71         Utils.runExec(cmdsList);
 72         cmdsList.clear();
 73 
 74         // Pack file with pack200 and unpack in with unpack200
 75         File packedFile = new File(&quot;tools.pack.gz&quot;);
 76         cmdsList.add(Utils.getPack200Cmd());
 77         cmdsList.add(packedFile.getName());
 78         cmdsList.add(testFile.getName());
 79         Utils.runExec(cmdsList);
 80         cmdsList.clear();
 81 
 82         File unpackedFile = new File(&quot;tools_native.jar&quot;);
 83         cmdsList.add(Utils.getUnpack200Cmd());
 84         cmdsList.add(packedFile.getName());
 85         cmdsList.add(unpackedFile.getName());
 86         Utils.runExec(cmdsList);
 87 
 88         // Compare files binary
 89         compareTwoFiles(testFile, unpackedFile);
 90 
 91         // Cleaning up generated files
 92         testFile.delete();
 93         packedFile.delete();
 94         unpackedFile.delete();
 95     }
 96 
 97     static void compareTwoFiles(File src, File dst) throws IOException {
 98         if (!src.exists()) {
 99             throw new IOException(&quot;File &quot; + src.getName() + &quot; does not exist!&quot;);
100         }
101 
102         if(!dst.exists()) {
103             throw new IOException(&quot;File &quot; + dst.getName() + &quot; does not exist!&quot;);
104         }
105 
106         BufferedInputStream srcis, dstis;
107         srcis = new BufferedInputStream(new FileInputStream(src));
108         dstis = new BufferedInputStream(new FileInputStream(dst));
109 
110         int s = 0, d, pos = 0;
111         while (s != -1) { // Checking of just one result for EOF is enough
112             s = srcis.read();
113             d = dstis.read();
114 
115             if (s != d) {
116                 throw new IOException(&quot;Files are differ starting at position: &quot;
117                 + Integer.toHexString(pos));
118             }
119 
120             pos++;
121         }
122 
123         srcis.close();
124         dstis.close();
125     }
126 
127     static void generateLargeJar(File result, File source) throws IOException {
128         if (result.exists()) {
129             result.delete();
130         }
131 
132         try (JarOutputStream copyTo = new JarOutputStream(new FileOutputStream(result));
133              JarFile srcJar = new JarFile(source)) {
134 
135             for (JarEntry je : Collections.list(srcJar.entries())) {
136                 copyTo.putNextEntry(je);
137                 if (!je.isDirectory()) {
138                     copyStream(srcJar.getInputStream(je), copyTo);
139                 }
140                 copyTo.closeEntry();
141             }
142 
143             int many = Short.MAX_VALUE * 2 + 2;
144 
145             for (int i = 0 ; i &lt; many ; i++) {
146                 JarEntry e = new JarEntry(&quot;F-&quot; + i + &quot;.txt&quot;);
147                 copyTo.putNextEntry(e);
148             }
149             copyTo.flush();
150             copyTo.close();
151         }
152     }
153 
154     static void copyStream(InputStream in, OutputStream out) throws IOException {
155         int bytesRead;
156         while ((bytesRead = in.read(BUFFER))!= -1) {
157             out.write(BUFFER, 0, bytesRead);
158         }
159     }
160 }
    </pre>
  </body>
</html>
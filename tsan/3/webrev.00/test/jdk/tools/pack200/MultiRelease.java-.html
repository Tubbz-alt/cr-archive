<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old test/jdk/tools/pack200/MultiRelease.java</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2015, 2016, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 import java.io.File;
 24 import java.io.IOException;
 25 import java.util.ArrayList;
 26 import java.util.List;
 27 
 28 /*
 29  * @test
 30  * @bug 8066272
 31  * @summary tests a simple multi-versioned jar file
 32  * @compile -XDignore.symbol.file Utils.java MultiRelease.java
 33  * @run main MultiRelease
 34  * @author ksrini
 35  */
 36 
 37 public class MultiRelease {
 38     private static final File cwd = new File(&quot;.&quot;);
 39     private static int pass = 0;
 40     private static int fail = 0;
 41     // specify alternate name via arguments to verify
 42     // if permanent fix works
 43 
 44     private static final String PropKey = &quot;pack200.MultiRelease.META-INF&quot;;
 45     private static final String MetaInfName = System.getProperty(PropKey, &quot;META-INF&quot;);
 46 
 47     public static void main(String... args) throws Exception {
 48         new MultiRelease().run();
 49     }
 50 
 51     void run() throws Exception {
 52         List&lt;TestCase&gt; testCases = new ArrayList&lt;&gt;();
 53         testCases.add(new TestCase1());
 54         testCases.add(new TestCase2());
 55         for (TestCase tc : testCases) {
 56             tc.run();
 57         }
 58         if (fail &gt; 0) {
 59             throw new Exception(fail + &quot;/&quot; + testCases.size() + &quot; tests fails&quot;);
 60         } else {
 61             System.out.println(&quot;All tests(&quot; + pass + &quot;) passes&quot;);
 62         }
 63         Utils.cleanup();
 64     }
 65 
 66     /*
 67      * An abstract class to eliminate test boiler plating.
 68      */
 69     static abstract class TestCase {
 70         final File tcwd;
 71         final File metaInfDir;
 72         final File versionsDir;
 73         final File manifestFile;
 74 
 75         TestCase(String directory) throws IOException {
 76             System.out.println(&quot;initializing directories&quot;);
 77             tcwd = new File(cwd, directory);
 78             metaInfDir = mkdir(new File(tcwd, MetaInfName));
 79             versionsDir = mkdir(new File(metaInfDir, &quot;versions&quot;));
 80             manifestFile = new File(tcwd, &quot;manifest.tmp&quot;);
 81             List&lt;String&gt; scratch = new ArrayList&lt;&gt;();
 82             scratch.add(&quot;Multi-Release: true&quot;);
 83             Utils.createFile(manifestFile, scratch);
 84         }
 85 
 86         File mkdir(File f) throws IOException {
 87             if (f.exists() &amp;&amp; f.isDirectory() &amp;&amp; f.canRead() &amp;&amp; f.canWrite()) {
 88                 return f;
 89             }
 90             if (!f.mkdirs()) {
 91                throw new IOException(&quot;mkdirs failed: &quot; + f.getAbsolutePath());
 92             }
 93             return f;
 94         }
 95 
 96         abstract void emitClassFiles() throws Exception;
 97 
 98         void run() {
 99             try {
100                 emitClassFiles();
101                 // jar the file up
102                 File testFile = new File(tcwd, &quot;test&quot; + Utils.JAR_FILE_EXT);
103                 Utils.jar(&quot;cvfm&quot;,
104                         testFile.getAbsolutePath(),
105                         manifestFile.getAbsolutePath(),
106                         &quot;-C&quot;,
107                         tcwd.getAbsolutePath(),
108                         &quot;.&quot;);
109                 File outFile = new File(tcwd, &quot;test-repacked&quot; + Utils.JAR_FILE_EXT);
110                 List&lt;String&gt; cmdsList = new ArrayList&lt;&gt;();
111 
112                 cmdsList.add(Utils.getPack200Cmd());
113                 cmdsList.add(&quot;-J-ea&quot;);
114                 cmdsList.add(&quot;-J-esa&quot;);
115                 cmdsList.add(&quot;-v&quot;);
116                 cmdsList.add(&quot;--repack&quot;);
117                 cmdsList.add(outFile.getAbsolutePath());
118                 cmdsList.add(testFile.getAbsolutePath());
119                 List&lt;String&gt; output = Utils.runExec(cmdsList);
120                 Utils.doCompareVerify(testFile.getAbsoluteFile(), outFile.getAbsoluteFile());
121                 pass++;
122             } catch (Exception e) {
123                 e.printStackTrace(System.err);
124                 fail++;
125             }
126         }
127     }
128 
129     static class TestCase1 extends TestCase {
130         private TestCase1(String directory) throws IOException {
131             super(directory);
132         }
133 
134         public TestCase1() throws Exception {
135             this(&quot;case1&quot;);
136         }
137 
138         @Override
139         void emitClassFiles() throws Exception {
140             emitClassFile(&quot;&quot;);
141             emitClassFile(&quot;7&quot;);
142             emitClassFile(&quot;8&quot;);
143             emitClassFile(&quot;9&quot;);
144         }
145 
146         /*
147          * Adds different variants of types
148          */
149         void emitClassFile(String version) throws IOException {
150             final File outDir = mkdir(version.isEmpty()
151                     ? tcwd
152                     : new File(versionsDir, version));
153 
154             final File srcDir = mkdir(version.isEmpty()
155                             ? new File(tcwd, &quot;src&quot;)
156                             : new File(new File(versionsDir, version), &quot;src&quot;));
157 
158             final String fname = &quot;Foo&quot;;
159             final File srcFile = new File(srcDir, fname + Utils.JAVA_FILE_EXT);
160             List&lt;String&gt; scratch = new ArrayList&lt;&gt;();
161 
162             scratch.add(&quot;package pkg;&quot;);
163             switch (version) {
164                 case &quot;7&quot;:
165                     scratch.add(&quot;public class Foo {&quot;);
166                     scratch.add(&quot;public static final class Bar {}&quot;);
167                     break;
168                 case &quot;8&quot;:
169                     scratch.add(&quot;public abstract class Foo {&quot;);
170                     scratch.add(&quot;public final class Bar {}&quot;);
171                     break;
172                 case &quot;9&quot;:
173                     scratch.add(&quot;public interface Foo {&quot;);
174                     scratch.add(&quot;public final class Bar {}&quot;);
175                     break;
176                 default:
177                     scratch.add(&quot;public class Foo {&quot;);
178                     scratch.add(&quot;public final class Bar {}&quot;);
179                     break;
180             }
181             scratch.add(&quot;}&quot;);
182 
183             Utils.createFile(srcFile, scratch);
184             Utils.compiler(&quot;-d&quot;,
185                     outDir.getAbsolutePath(),
186                     srcFile.getAbsolutePath());
187         }
188     }
189 
190     static class TestCase2 extends TestCase {
191         private TestCase2(String directory) throws IOException {
192             super(directory);
193         }
194 
195         TestCase2() throws Exception {
196             this(&quot;case2&quot;);
197         }
198 
199         @Override
200         void emitClassFiles() throws Exception {
201             emitClassFile(&quot;&quot;);
202             emitClassFile(&quot;8&quot;);
203         }
204 
205         /*
206          * Adds different variants of types and tries to invoke an
207          * interface or concrete method defined by them.
208          */
209         void emitClassFile(String version) throws IOException {
210 
211             final File outDir = mkdir(version.isEmpty()
212                     ? tcwd
213                     : new File(versionsDir, version));
214 
215             final File srcDir = mkdir(version.isEmpty()
216                     ? new File(tcwd, &quot;src&quot;)
217                     : new File(new File(versionsDir, version), &quot;src&quot;));
218 
219             List&lt;String&gt; scratch = new ArrayList&lt;&gt;();
220             final String fname1 = &quot;Ab&quot;;
221             final File srcFile1 = new File(srcDir, fname1 + Utils.JAVA_FILE_EXT);
222 
223             final String fname2 = &quot;AbNormal&quot;;
224             final File srcFile2 = new File(srcDir, fname2 + Utils.JAVA_FILE_EXT);
225             switch (version) {
226                 case &quot;8&quot;:
227                     scratch.clear();
228                     scratch.add(&quot;import java.io.IOException;&quot;);
229                     scratch.add(&quot;public interface &quot; + fname1 + &quot;{&quot;);
230                     scratch.add(&quot;    public abstract void close() throws IOException ;&quot;);
231                     scratch.add(&quot;}&quot;);
232                     Utils.createFile(srcFile1, scratch);
233                     break;
234                 default:
235                     scratch.clear();
236                     scratch.add(&quot;import java.io.IOException;&quot;);
237                     scratch.add(&quot;public abstract class &quot; + fname1 + &quot;{&quot;);
238                     scratch.add(&quot;    public abstract void close() throws IOException ;&quot;);
239                     scratch.add(&quot;}&quot;);
240                     Utils.createFile(srcFile1, scratch);
241             }
242 
243             scratch.clear();
244             scratch.add(&quot;import java.io.IOException;&quot;);
245             scratch.add(&quot;public class &quot; + fname2 + &quot;{&quot;);
246             scratch.add(&quot;    public void doSomething(Ab ab) throws IOException {&quot;);
247             scratch.add(&quot;       ab.close();&quot;);
248             scratch.add(&quot;    }&quot;);
249             scratch.add(&quot;}&quot;);
250 
251             Utils.createFile(srcFile2, scratch);
252             Utils.compiler(&quot;-d&quot;,
253                     outDir.getAbsolutePath(),
254                     srcFile1.getAbsolutePath(),
255                     srcFile2.getAbsolutePath());
256         }
257     }
258 }
    </pre>
  </body>
</html>
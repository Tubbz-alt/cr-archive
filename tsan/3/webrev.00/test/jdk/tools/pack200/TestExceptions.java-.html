<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old test/jdk/tools/pack200/TestExceptions.java</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2010, 2018, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 import java.io.ByteArrayOutputStream;
 25 import java.io.Closeable;
 26 import java.io.File;
 27 import java.io.FileInputStream;
 28 import java.io.IOException;
 29 import java.io.InputStream;
 30 import java.io.OutputStream;
 31 import java.util.ArrayList;
 32 import java.util.List;
 33 import java.util.jar.JarFile;
 34 import java.util.jar.JarInputStream;
 35 import java.util.jar.JarOutputStream;
 36 import java.util.jar.Pack200;
 37 
 38 /*
 39  * @test
 40  * @bug 6985763
 41  * @summary verify that proper exceptions are thrown
 42  * @compile -XDignore.symbol.file Utils.java TestExceptions.java
 43  * @run main TestExceptions
 44  * @author ksrini
 45  */
 46 
 47 public class TestExceptions {
 48 
 49     static final File testJar = new File(&quot;test.jar&quot;);
 50     static final File testPackFile = new File(&quot;test.pack&quot;);
 51 
 52     static void init() {
 53         Utils.jar(&quot;cvf&quot;, testJar.getAbsolutePath(), &quot;.&quot;);
 54         JarFile jf = null;
 55         try {
 56             jf = new JarFile(testJar);
 57             Utils.pack(jf, testPackFile);
 58         } catch (IOException ioe) {
 59             throw new Error(&quot;Initialization error&quot;, ioe);
 60         } finally {
 61             Utils.close(jf);
 62         }
 63     }
 64 
 65     // a test that closes the input jarFile.
 66     static void pack200Test1() {
 67         PackTestInput ti = null;
 68         // setup the scenario
 69         try {
 70             ti = new PackTestInput(new JarFile(testJar), new ByteArrayOutputStream());
 71         } catch (Exception e) {
 72             throw new Error(&quot;Initialization error&quot;, e);
 73         } finally {
 74             Utils.close(ti.getJarFile());
 75         }
 76         // test the scenario
 77         try {
 78             System.out.println(ti);
 79             Pack200.Packer p = Pack200.newPacker();
 80             p.pack(ti.getJarFile(), ti.getOutputStream());
 81         } catch (Exception e) {
 82             ti.checkException(e);
 83         } finally {
 84             if (ti != null) {
 85                 ti.close();
 86             }
 87         }
 88     }
 89 
 90     // test the Pack200.pack(JarFile, OutputStream);
 91     static void pack200Test2() {
 92         List&lt;PackTestInput&gt; tlist = new ArrayList&lt;PackTestInput&gt;();
 93         try {
 94             // setup the test scenarios
 95             try {
 96                 tlist.add(new PackTestInput((JarFile)null, null));
 97                 tlist.add(new PackTestInput(new JarFile(testJar), null));
 98                 tlist.add(new PackTestInput((JarFile)null, new ByteArrayOutputStream()));
 99             } catch (Exception e) {
100                 throw new Error(&quot;Initialization error&quot;, e);
101             }
102 
103             // test the scenarios
104             for (PackTestInput ti : tlist) {
105                 System.out.println(ti);
106                 try {
107                     Pack200.Packer p = Pack200.newPacker();
108                     p.pack(ti.getJarFile(), ti.getOutputStream());
109                 } catch (Exception e) {
110                     ti.checkException(e);
111                 }
112             }
113         } finally { // clean up
114             for (TestInput ti : tlist) {
115                 if (ti != null) {
116                     ti.close();
117                 }
118             }
119         }
120     }
121 
122     // test the Pack200.pack(JarInputStream, OutputStream);
123     static void pack200Test3() {
124         List&lt;PackTestJarInputStream&gt; tlist = new ArrayList&lt;PackTestJarInputStream&gt;();
125         try {
126             // setup the test scenarios
127             try {
128                 tlist.add(new PackTestJarInputStream((JarInputStream)null, null));
129                 tlist.add(new PackTestJarInputStream((JarInputStream)null,
130                         new ByteArrayOutputStream()));
131                 tlist.add(new PackTestJarInputStream(
132                         new JarInputStream(new FileInputStream(testJar)), null));
133 
134             } catch (Exception e) {
135                 throw new Error(&quot;Initialization error&quot;, e);
136             }
137             for (PackTestJarInputStream ti : tlist) {
138                 System.out.println(ti);
139                 try {
140                     Pack200.Packer p = Pack200.newPacker();
141                     p.pack(ti.getJarInputStream(), ti.getOutputStream());
142                 } catch (Exception e) {
143                     ti.checkException(e);
144                 }
145             }
146         } finally { // clean up
147             for (PackTestJarInputStream ti : tlist) {
148                 if (ti != null) {
149                     ti.close();
150                 }
151             }
152         }
153     }
154 
155     // test the Pack200.unpack(InputStream, OutputStream);
156     static void unpack200Test1() {
157         List&lt;UnpackTestInput&gt; tlist = new ArrayList&lt;UnpackTestInput&gt;();
158         try {
159             // setup the test scenarios
160             try {
161                 tlist.add(new UnpackTestInput((InputStream)null, null));
162                 tlist.add(new UnpackTestInput(new FileInputStream(testPackFile),
163                         null));
164                 tlist.add(new UnpackTestInput((InputStream) null,
165                         new JarOutputStream(new ByteArrayOutputStream())));
166             } catch (Exception e) {
167                 throw new Error(&quot;Initialization error&quot;, e);
168             }
169 
170             // test the scenarios
171             for (UnpackTestInput ti : tlist) {
172                 System.out.println(ti);
173                 try {
174                     Pack200.Unpacker unpacker = Pack200.newUnpacker();
175                     unpacker.unpack(ti.getInputStream(), ti.getJarOutputStream());
176                 } catch (Exception e) {
177                     ti.checkException(e);
178                 }
179             }
180         } finally { // clean up
181             for (TestInput ti : tlist) {
182                 if (ti != null) {
183                     ti.close();
184                 }
185             }
186         }
187     }
188 
189     // test the Pack200.unpack(File, OutputStream);
190     static void unpack200Test2() {
191         List&lt;UnpackTestFileInput&gt; tlist = new ArrayList&lt;UnpackTestFileInput&gt;();
192         try {
193             // setup the test scenarios
194             try {
195                 tlist.add(new UnpackTestFileInput((File)null, null));
196                 tlist.add(new UnpackTestFileInput(testPackFile, null));
197                 tlist.add(new UnpackTestFileInput((File)null,
198                         new JarOutputStream(new ByteArrayOutputStream())));
199             } catch (Exception e) {
200                 throw new Error(&quot;Initialization error&quot;, e);
201             }
202 
203             // test the scenarios
204             for (UnpackTestFileInput ti : tlist) {
205                 System.out.println(ti);
206                 try {
207                     Pack200.Unpacker unpacker = Pack200.newUnpacker();
208                     unpacker.unpack(ti.getInputFile(), ti.getJarOutputStream());
209                 } catch (Exception e) {
210                     ti.checkException(e);
211                 }
212             }
213         } finally { // clean up
214             for (TestInput ti : tlist) {
215                 if (ti != null) {
216                     ti.close();
217                 }
218             }
219         }
220     }
221 
222     public static void main(String... args) throws IOException {
223         init();
224         pack200Test1();
225         pack200Test2();
226         pack200Test3();
227         unpack200Test1();
228         Utils.cleanup();
229     }
230 
231     // containers for test inputs and management
232     static abstract class TestInput {
233 
234         private final Object in;
235         private final Object out;
236         final boolean shouldNPE;
237         final String testname;
238 
239         public TestInput(String name, Object in, Object out) {
240             this.testname = name;
241             this.in = in;
242             this.out = out;
243             shouldNPE = (in == null || out == null);
244         }
245 
246         @Override
247         public String toString() {
248             StringBuilder outStr = new StringBuilder(testname);
249             outStr.append(&quot;, input:&quot;).append(in);
250             outStr.append(&quot;, output:&quot;).append(this.out);
251             outStr.append(&quot;, should NPE:&quot;).append(shouldNPE);
252             return outStr.toString();
253         }
254 
255         void close() {
256             if (in != null &amp;&amp; (in instanceof Closeable)) {
257                 Utils.close((Closeable) in);
258             }
259             if (out != null &amp;&amp; (out instanceof Closeable)) {
260                 Utils.close((Closeable) out);
261             }
262         }
263 
264         void checkException(Throwable t) {
265             if (shouldNPE) {
266                 if (t instanceof NullPointerException) {
267                     System.out.println(&quot;Got expected exception&quot;);
268                     return;
269                 } else {
270                     throw new RuntimeException(&quot;Expected NPE, but got &quot;, t);
271                 }
272             }
273             if (t instanceof IOException) {
274                 System.out.println(&quot;Got expected exception&quot;);
275                 return;
276             } else {
277                 throw new RuntimeException(&quot;Expected IOException but got &quot;, t);
278             }
279         }
280     }
281 
282     static class PackTestInput extends TestInput {
283 
284         public PackTestInput(JarFile jf, OutputStream out) {
285             super(&quot;PackTestInput&quot;, jf, out);
286         }
287 
288         JarFile getJarFile() {
289             return (JarFile) super.in;
290         }
291 
292         OutputStream getOutputStream() {
293             return (OutputStream) super.out;
294         }
295     };
296 
297     static class PackTestJarInputStream extends TestInput {
298 
299         public PackTestJarInputStream(JarInputStream in, OutputStream out) {
300             super(&quot;PackTestJarInputStream&quot;, in, out);
301         }
302 
303         JarInputStream getJarInputStream() {
304             return (JarInputStream) super.in;
305         }
306 
307         OutputStream getOutputStream() {
308             return (OutputStream) super.out;
309         }
310     };
311 
312     static class UnpackTestInput extends TestInput {
313 
314         public UnpackTestInput(InputStream in, JarOutputStream out) {
315             super(&quot;UnpackTestInput&quot;, in, out);
316         }
317 
318         InputStream getInputStream() {
319             return (InputStream) super.in;
320         }
321 
322         JarOutputStream getJarOutputStream() {
323             return (JarOutputStream) super.out;
324         }
325     };
326 
327     static class UnpackTestFileInput extends TestInput {
328 
329         public UnpackTestFileInput(File in, JarOutputStream out) {
330             super(&quot;UnpackTestInput&quot;, in, out);
331         }
332 
333         File getInputFile() {
334             return (File) super.in;
335         }
336 
337         JarOutputStream getJarOutputStream() {
338             return (JarOutputStream) super.out;
339         }
340     };
341 }
    </pre>
  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New test/jdk/tools/launcher/Arrrghs.java</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2007, 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 /**
 25  * @test
 26  * @bug 5030233 6214916 6356475 6571029 6684582 6742159 4459600 6758881 6753938
 27  *      6894719 6968053 7151434 7146424 8007333 8077822 8143640 8132379 8218547
 28  * @summary Argument parsing validation.
 29  * @modules jdk.compiler
 30  *          jdk.zipfs
 31  * @compile -XDignore.symbol.file Arrrghs.java
 32  * @run main/othervm Arrrghs
 33  */
 34 
 35 
 36 import java.io.File;
 37 import java.io.FileNotFoundException;
 38 import java.io.IOException;
 39 import java.nio.file.Files;
 40 import java.nio.file.Paths;
 41 import java.nio.file.Path;
 42 import java.util.ArrayList;
 43 import java.util.Arrays;
 44 import java.util.HashMap;
 45 import java.util.List;
 46 import java.util.Map;
 47 import java.util.regex.Matcher;
 48 import java.util.regex.Pattern;
 49 
 50 public class Arrrghs extends TestHelper {
 51     private Arrrghs(){}
 52     /**
 53      * This class provides various tests for arguments processing.
 54      *
 55      * History: these set of tests  were part of Arrrghs.sh. The MKS shell
 56      * implementations were notoriously buggy. Implementing these tests purely
 57      * in Java is not only portable but also robust.
 58      *
 59      */
 60 
 61     // the pattern we hope to see in the output
 62     static final Pattern ArgPattern = Pattern.compile(&quot;\\s*argv\\[[0-9]*\\].*=.*&quot;);
 63 
 64     void checkArgumentParsing(String inArgs, String... expArgs) throws IOException {
 65         List&lt;String&gt; scratchpad = new ArrayList&lt;&gt;();
 66         scratchpad.add(&quot;set &quot; + JLDEBUG_KEY + &quot;=true&quot;);
 67         // GAK, -version needs to be added so that windows can flush its stderr
 68         // exiting the process prematurely can terminate the stderr.
 69         scratchpad.add(javaCmd + &quot; -version &quot; + inArgs);
 70         File batFile = new File(&quot;atest.bat&quot;);
 71         createAFile(batFile, scratchpad);
 72 
 73         TestResult tr = doExec(batFile.getName());
 74 
 75         ArrayList&lt;String&gt; expList = new ArrayList&lt;&gt;();
 76         expList.add(javaCmd);
 77         expList.add(&quot;-version&quot;);
 78         expList.addAll(Arrays.asList(expArgs));
 79 
 80         List&lt;String&gt; gotList = new ArrayList&lt;&gt;();
 81         for (String x : tr.testOutput) {
 82             Matcher m = ArgPattern.matcher(x);
 83             if (m.matches()) {
 84                 String a[] = x.split(&quot;=&quot;);
 85                 gotList.add(a[a.length - 1].trim());
 86             }
 87         }
 88         if (!gotList.equals(expList)) {
 89             System.out.println(tr);
 90             System.out.println(&quot;Expected args:&quot;);
 91             System.out.println(expList);
 92             System.out.println(&quot;Obtained args:&quot;);
 93             System.out.println(gotList);
 94             throw new RuntimeException(&quot;Error: args do not match&quot;);
 95         }
 96         System.out.println(&quot;\&#39;&quot; + inArgs + &quot;\&#39;&quot; + &quot; - Test passed&quot;);
 97     }
 98 
 99     /*
100      * This tests general quoting and are specific to Windows, *nixes
101      * need not worry about this, these have been tested with Windows
102      * implementation and those that are known to work are used against
103      * the java implementation. Note that the ProcessBuilder gets in the
104      * way when testing some of these arguments, therefore we need to
105      * create and execute a .bat file containing the arguments.
106      */
107     @Test
108     void testArgumentParsing() throws IOException {
109         if (!isWindows)
110             return;
111         // no quotes
112         checkArgumentParsing(&quot;a b c d&quot;, &quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;);
113 
114         // single quotes
115         checkArgumentParsing(&quot;\&quot;a b c d\&quot;&quot;, &quot;a b c d&quot;);
116 
117         //double quotes
118         checkArgumentParsing(&quot;\&quot;\&quot;a b c d\&quot;\&quot;&quot;, &quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;);
119 
120         // triple quotes
121         checkArgumentParsing(&quot;\&quot;\&quot;\&quot;a b c d\&quot;\&quot;\&quot;&quot;, &quot;\&quot;a b c d\&quot;&quot;);
122 
123         // a literal within single quotes
124         checkArgumentParsing(&quot;\&quot;a\&quot;b c d\&quot;e\&quot;&quot;, &quot;ab&quot;, &quot;c&quot;, &quot;de&quot;);
125 
126         // a literal within double quotes
127         checkArgumentParsing(&quot;\&quot;\&quot;a\&quot;b c d\&quot;e\&quot;\&quot;&quot;, &quot;ab c de&quot;);
128 
129         // a literal quote
130         checkArgumentParsing(&quot;a\\\&quot;b&quot;, &quot;a\&quot;b&quot;);
131 
132         // double back-slash
133         checkArgumentParsing(&quot;\&quot;a b c d\\\\\&quot;&quot;, &quot;a b c d\\&quot;);
134 
135         // triple back-slash
136         checkArgumentParsing(&quot;a\\\\\\\&quot;b&quot;, &quot;a\\\&quot;b&quot;);
137 
138         // dangling quote
139         checkArgumentParsing(&quot;\&quot;a b c\&quot;\&quot;&quot;, &quot;a b c\&quot;&quot;);
140 
141         // expansions of white space separators
142         checkArgumentParsing(&quot;a b&quot;, &quot;a&quot;, &quot;b&quot;);
143         checkArgumentParsing(&quot;a\tb&quot;, &quot;a&quot;, &quot;b&quot;);
144         checkArgumentParsing(&quot;a \t b&quot;, &quot;a&quot;, &quot;b&quot;);
145 
146         checkArgumentParsing(&quot;\&quot;C:\\TEST A\\\\\&quot;&quot;, &quot;C:\\TEST A\\&quot;);
147         checkArgumentParsing(&quot;\&quot;\&quot;C:\\TEST A\\\\\&quot;\&quot;&quot;, &quot;C:\\TEST&quot;, &quot;A\\&quot;);
148 
149         // MS Windows tests
150         // triple back-slash
151         checkArgumentParsing(&quot;a\\\\\\d&quot;, &quot;a\\\\\\d&quot;);
152 
153         // triple back-slash in quotes
154         checkArgumentParsing(&quot;\&quot;a\\\\\\d\&quot;&quot;, &quot;a\\\\\\d&quot;);
155 
156         // slashes separating characters
157         checkArgumentParsing(&quot;X\\Y\\Z&quot;, &quot;X\\Y\\Z&quot;);
158         checkArgumentParsing(&quot;\\X\\Y\\Z&quot;, &quot;\\X\\Y\\Z&quot;);
159 
160         // literals within dangling quotes, etc.
161         checkArgumentParsing(&quot;\&quot;a b c\&quot; d e&quot;, &quot;a b c&quot;, &quot;d&quot;, &quot;e&quot;);
162         checkArgumentParsing(&quot;\&quot;ab\\\&quot;c\&quot;  \&quot;\\\\\&quot;  d&quot;, &quot;ab\&quot;c&quot;, &quot;\\&quot;, &quot;d&quot;);
163         checkArgumentParsing(&quot;a\\\\\\c d\&quot;e f\&quot;g h&quot;, &quot;a\\\\\\c&quot;, &quot;de fg&quot;, &quot;h&quot;);
164         checkArgumentParsing(&quot;a\\\\\\\&quot;b c d&quot;, &quot;a\\\&quot;b&quot;, &quot;c&quot;, &quot;d&quot;);
165         checkArgumentParsing(&quot;a\\\\\\\\\&quot;g c\&quot; d e&quot;, &quot;a\\\\g c&quot;, &quot;d&quot;, &quot;e&quot;);
166 
167         // treatment of back-slashes
168         checkArgumentParsing(&quot;*\\&quot;, &quot;*\\&quot;);
169         checkArgumentParsing(&quot;*/&quot;, &quot;*/&quot;);
170         checkArgumentParsing(&quot;.\\*&quot;, &quot;.\\*&quot;);
171         checkArgumentParsing(&quot;./*&quot;, &quot;./*&quot;);
172         checkArgumentParsing(&quot;..\\..\\*&quot;, &quot;..\\..\\*&quot;);
173         checkArgumentParsing(&quot;../../*&quot;, &quot;../../*&quot;);
174         checkArgumentParsing(&quot;..\\..\\&quot;, &quot;..\\..\\&quot;);
175         checkArgumentParsing(&quot;../../&quot;, &quot;../../&quot;);
176         checkArgumentParsing(&quot;a b\\ c&quot;, &quot;a&quot;, &quot;b\\&quot;, &quot;c&quot;);
177         // 2 back-slashes
178         checkArgumentParsing(&quot;\\\\?&quot;, &quot;\\\\?&quot;);
179         // 3 back-slashes
180         checkArgumentParsing(&quot;\\\\\\?&quot;, &quot;\\\\\\?&quot;);
181         // 4 back-slashes
182         checkArgumentParsing(&quot;\\\\\\\\?&quot;, &quot;\\\\\\\\?&quot;);
183         // 5 back-slashes
184         checkArgumentParsing(&quot;\\\\\\\\\\?&quot;, &quot;\\\\\\\\\\?&quot;);
185         // 6 back-slashes
186         checkArgumentParsing(&quot;\\\\\\\\\\\\?&quot;, &quot;\\\\\\\\\\\\?&quot;);
187 
188         // more treatment of  mixed slashes
189         checkArgumentParsing(&quot;f1/ f3\\ f4/&quot;, &quot;f1/&quot;, &quot;f3\\&quot;, &quot;f4/&quot;);
190         checkArgumentParsing(&quot;f1/ f2\&#39; &#39; f3/ f4/&quot;, &quot;f1/&quot;, &quot;f2\&#39;&quot;, &quot;&#39;&quot;, &quot;f3/&quot;, &quot;f4/&quot;);
191 
192         checkArgumentParsing(&quot;a\\*\\b&quot;, &quot;a\\*\\b&quot;);
193     }
194 
195     private void initEmptyDir(File emptyDir) throws IOException {
196         if (emptyDir.exists()) {
197             recursiveDelete(emptyDir);
198         }
199         emptyDir.mkdir();
200     }
201 
202     private void initDirWithJavaFiles(File libDir) throws IOException {
203 
204         if (libDir.exists()) {
205             recursiveDelete(libDir);
206         }
207         libDir.mkdirs();
208         ArrayList&lt;String&gt; scratchpad = new ArrayList&lt;&gt;();
209         scratchpad.add(&quot;package lib;&quot;);
210         scratchpad.add(&quot;public class Fbo {&quot;);
211         scratchpad.add(&quot;public static void main(String... args){Foo.f();}&quot;);
212         scratchpad.add(&quot;public static void f(){}&quot;);
213         scratchpad.add(&quot;}&quot;);
214         createFile(new File(libDir, &quot;Fbo.java&quot;), scratchpad);
215 
216         scratchpad.clear();
217         scratchpad.add(&quot;package lib;&quot;);
218         scratchpad.add(&quot;public class Foo {&quot;);
219         scratchpad.add(&quot;public static void main(String... args){&quot;);
220         scratchpad.add(&quot;for (String x : args) {&quot;);
221         scratchpad.add(&quot;System.out.println(x);&quot;);
222         scratchpad.add(&quot;}&quot;);
223         scratchpad.add(&quot;Fbo.f();&quot;);
224         scratchpad.add(&quot;}&quot;);
225         scratchpad.add(&quot;public static void f(){}&quot;);
226         scratchpad.add(&quot;}&quot;);
227         createFile(new File(libDir, &quot;Foo.java&quot;), scratchpad);
228     }
229 
230     void checkArgumentWildcard(String inArgs, String... expArgs) throws IOException {
231         String[] in = {inArgs};
232         checkArgumentWildcard(in, expArgs);
233 
234         // now add arbitrary arguments before and after
235         String[] outInArgs = { &quot;-Q&quot;, inArgs, &quot;-R&quot;};
236 
237         String[] outExpArgs = new String[expArgs.length + 2];
238         outExpArgs[0] = &quot;-Q&quot;;
239         System.arraycopy(expArgs, 0, outExpArgs, 1, expArgs.length);
240         outExpArgs[expArgs.length + 1] = &quot;-R&quot;;
241         checkArgumentWildcard(outInArgs, outExpArgs);
242     }
243 
244     void checkArgumentWildcard(String[] inArgs, String[] expArgs) throws IOException {
245         ArrayList&lt;String&gt; argList = new ArrayList&lt;&gt;();
246         argList.add(javaCmd);
247         argList.add(&quot;-cp&quot;);
248         argList.add(&quot;lib&quot; + File.separator + &quot;*&quot;);
249         argList.add(&quot;lib.Foo&quot;);
250         argList.addAll(Arrays.asList(inArgs));
251         String[] cmds = new String[argList.size()];
252         argList.toArray(cmds);
253         TestResult tr = doExec(cmds);
254         if (!tr.isOK()) {
255             System.out.println(tr);
256             throw new RuntimeException(&quot;Error: classpath single entry wildcard entry&quot;);
257         }
258 
259         ArrayList&lt;String&gt; expList = new ArrayList&lt;&gt;();
260         expList.addAll(Arrays.asList(expArgs));
261 
262         List&lt;String&gt; gotList = new ArrayList&lt;&gt;();
263         for (String x : tr.testOutput) {
264             gotList.add(x.trim());
265         }
266         if (!gotList.equals(expList)) {
267             System.out.println(tr);
268             System.out.println(&quot;Expected args:&quot;);
269             System.out.println(expList);
270             System.out.println(&quot;Obtained args:&quot;);
271             System.out.println(gotList);
272             throw new RuntimeException(&quot;Error: args do not match&quot;);
273         }
274         System.out.print(&quot;\&#39;&quot;);
275         for (String x : inArgs) {
276             System.out.print(x + &quot; &quot;);
277         }
278         System.out.println(&quot;\&#39;&quot; + &quot; - Test passed&quot;);
279     }
280 
281     /*
282      * These tests are not expected to work on *nixes, and are ignored.
283      */
284     @Test
285     void testWildCardArgumentProcessing() throws IOException {
286         if (!isWindows)
287             return;
288         File cwd = new File(&quot;.&quot;);
289         File libDir = new File(cwd, &quot;lib&quot;);
290         initDirWithJavaFiles(libDir);
291         initEmptyDir(new File(cwd, &quot;empty&quot;));
292 
293         // test if javac (the command) can compile *.java
294         TestResult tr = doExec(javacCmd, libDir.getName() + File.separator + &quot;*.java&quot;);
295         if (!tr.isOK()) {
296             System.out.println(tr);
297             throw new RuntimeException(&quot;Error: compiling java wildcards&quot;);
298         }
299 
300         // test if javac (the command) can compile *.java with a vmoption
301         tr = doExec(javacCmd, &quot;-cp&quot;, &quot;.&quot;,
302                     &quot;-J-showversion&quot;, &quot;-J-Dsomeproperty=foo&quot;,
303                     libDir.getName() + File.separator + &quot;*.java&quot;);
304         if (!tr.isOK()) {
305             System.out.println(tr);
306             throw new RuntimeException(&quot;Error: compiling java wildcards with vmoptions&quot;);
307         }
308 
309 
310         // use the jar cmd to create jars using the ? wildcard
311         File jarFoo = new File(libDir, &quot;Foo.jar&quot;);
312         tr = doExec(jarCmd, &quot;cvf&quot;, jarFoo.getAbsolutePath(), &quot;lib&quot; + File.separator + &quot;F?o.class&quot;);
313         if (!tr.isOK()) {
314             System.out.println(tr);
315             throw new RuntimeException(&quot;Error: creating jar with wildcards&quot;);
316         }
317 
318         // now the litmus test!, this should work
319         checkArgumentWildcard(&quot;a&quot;, &quot;a&quot;);
320 
321         // test for basic expansion
322         checkArgumentWildcard(&quot;lib\\F*java&quot;, &quot;lib\\Fbo.java&quot;, &quot;lib\\Foo.java&quot;);
323 
324         // basic expansion in quotes
325         checkArgumentWildcard(&quot;\&quot;lib\\F*java\&quot;&quot;, &quot;lib\\F*java&quot;);
326 
327         checkArgumentWildcard(&quot;lib\\**&quot;, &quot;lib\\Fbo.class&quot;, &quot;lib\\Fbo.java&quot;,
328                               &quot;lib\\Foo.class&quot;, &quot;lib\\Foo.jar&quot;, &quot;lib\\Foo.java&quot;);
329 
330         checkArgumentWildcard(&quot;lib\\*?&quot;, &quot;lib\\Fbo.class&quot;, &quot;lib\\Fbo.java&quot;,
331                               &quot;lib\\Foo.class&quot;, &quot;lib\\Foo.jar&quot;, &quot;lib\\Foo.java&quot;);
332 
333         checkArgumentWildcard(&quot;lib\\?*&quot;, &quot;lib\\Fbo.class&quot;, &quot;lib\\Fbo.java&quot;,
334                 &quot;lib\\Foo.class&quot;, &quot;lib\\Foo.jar&quot;, &quot;lib\\Foo.java&quot;);
335 
336         checkArgumentWildcard(&quot;lib\\?&quot;, &quot;lib\\?&quot;);
337 
338         // test for basic expansion
339         checkArgumentWildcard(&quot;lib\\*java&quot;, &quot;lib\\Fbo.java&quot;, &quot;lib\\Foo.java&quot;);
340 
341         // basic expansion in quotes
342         checkArgumentWildcard(&quot;\&quot;lib\\*.java\&quot;&quot;, &quot;lib\\*.java&quot;);
343 
344         // suffix expansion
345         checkArgumentWildcard(&quot;lib\\*.class&quot;, &quot;lib\\Fbo.class&quot;, &quot;lib\\Foo.class&quot;);
346 
347         // suffix expansion in quotes
348         checkArgumentWildcard(&quot;\&quot;lib\\*.class\&quot;&quot;, &quot;lib\\*.class&quot;);
349 
350         // check for ? expansion now
351         checkArgumentWildcard(&quot;lib\\F?o.java&quot;, &quot;lib\\Fbo.java&quot;, &quot;lib\\Foo.java&quot;);
352 
353         // check ? in quotes
354         checkArgumentWildcard(&quot;\&quot;lib\\F?o.java\&quot;&quot;, &quot;lib\\F?o.java&quot;);
355 
356         // check ? as suffixes
357         checkArgumentWildcard(&quot;lib\\F?o.????&quot;, &quot;lib\\Fbo.java&quot;, &quot;lib\\Foo.java&quot;);
358 
359         // check ? in a leading role
360         checkArgumentWildcard(&quot;lib\\???.java&quot;, &quot;lib\\Fbo.java&quot;, &quot;lib\\Foo.java&quot;);
361         checkArgumentWildcard(&quot;\&quot;lib\\???.java\&quot;&quot;, &quot;lib\\???.java&quot;);
362 
363         // check ? prefixed with -
364         checkArgumentWildcard(&quot;-?&quot;, &quot;-?&quot;);
365 
366         // check * prefixed with -
367         checkArgumentWildcard(&quot;-*&quot;, &quot;-*&quot;);
368 
369         // check on empty directory
370         checkArgumentWildcard(&quot;empty\\*&quot;, &quot;empty\\*&quot;);
371         checkArgumentWildcard(&quot;empty\\**&quot;, &quot;empty\\**&quot;);
372         checkArgumentWildcard(&quot;empty\\?&quot;, &quot;empty\\?&quot;);
373         checkArgumentWildcard(&quot;empty\\??&quot;, &quot;empty\\??&quot;);
374         checkArgumentWildcard(&quot;empty\\*?&quot;, &quot;empty\\*?&quot;);
375         checkArgumentWildcard(&quot;empty\\?*&quot;, &quot;empty\\?*&quot;);
376 
377         // 8132379: java should not filter out -J options for application
378         String[] args = { &quot;-J-one&quot;, &quot;-Jtwo&quot;, &quot;lib\\???.java&quot;, &quot;-J-Dsomething&quot;,
379            &quot;a&quot;, &quot;-J-Dlast.arg&quot; };
380         String[] expected = { &quot;-J-one&quot;, &quot;-Jtwo&quot;, &quot;lib\\Fbo.java&quot;,
381            &quot;lib\\Foo.java&quot;, &quot;-J-Dsomething&quot;, &quot;a&quot;, &quot;-J-Dlast.arg&quot; };
382         checkArgumentWildcard(args, expected);
383     }
384 
385     void doArgumentCheck(String inArgs, String... expArgs) {
386         Map&lt;String, String&gt; env = new HashMap&lt;&gt;();
387         env.put(JLDEBUG_KEY, &quot;true&quot;);
388         TestResult tr = doExec(env, javaCmd, inArgs);
389         System.out.println(tr);
390         int sindex = tr.testOutput.indexOf(&quot;Command line args:&quot;);
391         if (sindex &lt; 0) {
392             System.out.println(tr);
393             throw new RuntimeException(&quot;Error: no output&quot;);
394         }
395         sindex++; // skip over the tag
396         List&lt;String&gt; gotList = new ArrayList&lt;&gt;();
397         for (String x : tr.testOutput.subList(sindex, sindex + expArgs.length)) {
398             String a[] = x.split(&quot;=&quot;);
399             gotList.add(a[a.length - 1].trim());
400         }
401         List&lt;String&gt; expList = Arrays.asList(expArgs);
402         if (!gotList.equals(expList)) {
403             System.out.println(tr);
404             System.out.println(&quot;Expected args:&quot;);
405             System.out.println(expList);
406             System.out.println(&quot;Obtained args:&quot;);
407             System.out.println(gotList);
408             throw new RuntimeException(&quot;Error: args do not match&quot;);
409         }
410     }
411 
412 
413     /*
414      * These tests are usually run on non-existent targets to check error results
415      */
416     @Test
417     void testBasicErrorMessages() {
418         // Tests for 5030233
419         TestResult tr = doExec(javaCmd, &quot;-cp&quot;);
420         tr.checkNegative();
421         tr.isNotZeroOutput();
422         if (!tr.testStatus)
423             System.out.println(tr);
424 
425         tr = doExec(javaCmd, &quot;-classpath&quot;);
426         tr.checkNegative();
427         tr.isNotZeroOutput();
428         if (!tr.testStatus)
429             System.out.println(tr);
430 
431         tr = doExec(javaCmd, &quot;-jar&quot;);
432         tr.checkNegative();
433         tr.isNotZeroOutput();
434         if (!tr.testStatus)
435             System.out.println(tr);
436 
437         tr = doExec(javacCmd, &quot;-cp&quot;);
438         tr.checkNegative();
439         tr.isNotZeroOutput();
440         if (!tr.testStatus)
441             System.out.println(tr);
442 
443         // Test for 6356475 &quot;REGRESSION:&quot;java -X&quot; from cmdline fails&quot;
444         tr = doExec(javaCmd, &quot;-X&quot;);
445         tr.checkPositive();
446         tr.isNotZeroOutput();
447         if (!tr.testStatus)
448             System.out.println(tr);
449 
450         tr = doExec(javaCmd, &quot;-help&quot;);
451         tr.checkPositive();
452         tr.isNotZeroOutput();
453         if (!tr.testStatus)
454             System.out.println(tr);
455 
456         // 6753938, test for non-negative exit value for an incorrectly formed
457         // command line,  &#39;% java&#39;
458         tr = doExec(javaCmd);
459         tr.checkNegative();
460         tr.isNotZeroOutput();
461         if (!tr.testStatus)
462             System.out.println(tr);
463 
464         // 6753938, test for non-negative exit value for an incorrectly formed
465         // command line,  &#39;% java -Xcomp&#39;
466         tr = doExec(javaCmd, &quot;-Xcomp&quot;);
467         tr.checkNegative();
468         tr.isNotZeroOutput();
469         if (!tr.testStatus)
470             System.out.println(tr);
471 
472         // 7151434, test for non-negative exit value for an incorrectly formed
473         // command line, &#39;% java -jar -W&#39;, note the bogus -W
474         tr = doExec(javaCmd, &quot;-jar&quot;, &quot;-W&quot;);
475         tr.checkNegative();
476         tr.contains(&quot;Unrecognized option: -W&quot;);
477         if (!tr.testStatus)
478             System.out.println(tr);
479     }
480 
481     /*
482      * Tests -jar command on a jar file with &quot;long&quot; (&gt; 260 chars) full path on Windows
483      */
484     @Test
485     void testLongPathJarFile() throws IOException {
486         if (!isWindows) {
487             return;
488         }
489         // put the jar file to a location with long path
490         String longPathPart = &quot;longpathtest_longpathtest/&quot;;
491         String longPathStr = longPathPart.repeat(15);
492         Path longPath = Paths.get(longPathStr);
493         Path jarPath = Files.createDirectories(longPath).resolve(&quot;elp.jar&quot;);
494         File elp = jarPath.toFile();
495         createJar(elp, new File(&quot;Foo&quot;), &quot;public static void main(String[] args){ System.out.println(\&quot;Hello from ELP\&quot;); }&quot;);
496         System.out.println(&quot;execute &quot; + elp.getAbsolutePath());
497         TestResult tr = doExec(javaCmd, &quot;-jar&quot;, elp.getAbsolutePath());
498         tr.checkPositive();
499         tr.contains(&quot;Hello from ELP&quot;);
500     }
501 
502     /*
503      * Tests various dispositions of the main method, these tests are limited
504      * to English locales as they check for error messages that are localized.
505      */
506     @Test
507     void testMainMethod() throws FileNotFoundException {
508         if (!isEnglishLocale()) {
509             return;
510         }
511 
512         TestResult tr;
513 
514         // a missing class
515         createJar(&quot;MIA&quot;, new File(&quot;some.jar&quot;), new File(&quot;Foo&quot;),
516                 (String[])null);
517         tr = doExec(javaCmd, &quot;-jar&quot;, &quot;some.jar&quot;);
518         tr.contains(&quot;Error: Could not find or load main class MIA&quot;);
519         if (!tr.testStatus)
520             System.out.println(tr);
521         // use classpath to check
522         tr = doExec(javaCmd, &quot;-cp&quot;, &quot;some.jar&quot;, &quot;MIA&quot;);
523         tr.contains(&quot;Error: Could not find or load main class MIA&quot;);
524         if (!tr.testStatus)
525             System.out.println(tr);
526 
527         // incorrect method access
528         createJar(new File(&quot;some.jar&quot;), new File(&quot;Foo&quot;),
529                 &quot;private static void main(String[] args){}&quot;);
530         tr = doExec(javaCmd, &quot;-jar&quot;, &quot;some.jar&quot;);
531         tr.contains(&quot;Error: Main method not found in class Foo&quot;);
532         if (!tr.testStatus)
533             System.out.println(tr);
534         // use classpath to check
535         tr = doExec(javaCmd, &quot;-cp&quot;, &quot;some.jar&quot;, &quot;Foo&quot;);
536         tr.contains(&quot;Error: Main method not found in class Foo&quot;);
537         if (!tr.testStatus)
538             System.out.println(tr);
539 
540         // incorrect return type
541         createJar(new File(&quot;some.jar&quot;), new File(&quot;Foo&quot;),
542                 &quot;public static int main(String[] args){return 1;}&quot;);
543         tr = doExec(javaCmd, &quot;-jar&quot;, &quot;some.jar&quot;);
544         tr.contains(&quot;Error: Main method must return a value of type void in class Foo&quot;);
545         if (!tr.testStatus)
546             System.out.println(tr);
547         // use classpath to check
548         tr = doExec(javaCmd, &quot;-cp&quot;, &quot;some.jar&quot;, &quot;Foo&quot;);
549         tr.contains(&quot;Error: Main method must return a value of type void in class Foo&quot;);
550         if (!tr.testStatus)
551             System.out.println(tr);
552 
553         // incorrect parameter type
554         createJar(new File(&quot;some.jar&quot;), new File(&quot;Foo&quot;),
555                 &quot;public static void main(Object[] args){}&quot;);
556         tr = doExec(javaCmd, &quot;-jar&quot;, &quot;some.jar&quot;);
557         tr.contains(&quot;Error: Main method not found in class Foo&quot;);
558         if (!tr.testStatus)
559             System.out.println(tr);
560         // use classpath to check
561         tr = doExec(javaCmd, &quot;-cp&quot;, &quot;some.jar&quot;, &quot;Foo&quot;);
562         tr.contains(&quot;Error: Main method not found in class Foo&quot;);
563         if (!tr.testStatus)
564             System.out.println(tr);
565 
566         // incorrect method type - non-static
567          createJar(new File(&quot;some.jar&quot;), new File(&quot;Foo&quot;),
568                 &quot;public void main(String[] args){}&quot;);
569         tr = doExec(javaCmd, &quot;-jar&quot;, &quot;some.jar&quot;);
570         tr.contains(&quot;Error: Main method is not static in class Foo&quot;);
571         if (!tr.testStatus)
572             System.out.println(tr);
573         // use classpath to check
574         tr = doExec(javaCmd, &quot;-cp&quot;, &quot;some.jar&quot;, &quot;Foo&quot;);
575         tr.contains(&quot;Error: Main method is not static in class Foo&quot;);
576         if (!tr.testStatus)
577             System.out.println(tr);
578 
579         // amongst a potpourri of kindred main methods, is the right one chosen ?
580         createJar(new File(&quot;some.jar&quot;), new File(&quot;Foo&quot;),
581             &quot;void main(Object[] args){}&quot;,
582             &quot;int  main(Float[] args){return 1;}&quot;,
583             &quot;private void main() {}&quot;,
584             &quot;private static void main(int x) {}&quot;,
585             &quot;public int main(int argc, String[] argv) {return 1;}&quot;,
586             &quot;public static void main(String[] args) {System.out.println(\&quot;THE_CHOSEN_ONE\&quot;);}&quot;);
587         tr = doExec(javaCmd, &quot;-jar&quot;, &quot;some.jar&quot;);
588         tr.contains(&quot;THE_CHOSEN_ONE&quot;);
589         if (!tr.testStatus)
590             System.out.println(tr);
591         // use classpath to check
592         tr = doExec(javaCmd, &quot;-cp&quot;, &quot;some.jar&quot;, &quot;Foo&quot;);
593         tr.contains(&quot;THE_CHOSEN_ONE&quot;);
594         if (!tr.testStatus)
595             System.out.println(tr);
596 
597         // test for extraneous whitespace in the Main-Class attribute
598         createJar(&quot; Foo &quot;, new File(&quot;some.jar&quot;), new File(&quot;Foo&quot;),
599                 &quot;public static void main(String... args){}&quot;);
600         tr = doExec(javaCmd, &quot;-jar&quot;, &quot;some.jar&quot;);
601         tr.checkPositive();
602         if (!tr.testStatus)
603             System.out.println(tr);
604     }
605     /*
606      * tests 6968053, ie. we turn on the -Xdiag (for now) flag and check if
607      * the suppressed stack traces are exposed, ignore these tests for localized
608      * locales, limiting to English only.
609      */
610     @Test
611     void testDiagOptions() throws FileNotFoundException {
612         if (!isEnglishLocale()) { // only english version
613             return;
614         }
615         TestResult tr;
616         // a missing class
617         createJar(&quot;MIA&quot;, new File(&quot;some.jar&quot;), new File(&quot;Foo&quot;),
618                 (String[])null);
619         tr = doExec(javaCmd, &quot;-Xdiag&quot;, &quot;-jar&quot;, &quot;some.jar&quot;);
620         tr.contains(&quot;Error: Could not find or load main class MIA&quot;);
621         tr.contains(&quot;java.lang.ClassNotFoundException: MIA&quot;);
622         if (!tr.testStatus)
623             System.out.println(tr);
624 
625         // use classpath to check
626         tr = doExec(javaCmd,  &quot;-Xdiag&quot;, &quot;-cp&quot;, &quot;some.jar&quot;, &quot;MIA&quot;);
627         tr.contains(&quot;Error: Could not find or load main class MIA&quot;);
628         tr.contains(&quot;java.lang.ClassNotFoundException: MIA&quot;);
629         if (!tr.testStatus)
630             System.out.println(tr);
631 
632         // a missing class on the classpath
633         tr = doExec(javaCmd, &quot;-Xdiag&quot;, &quot;NonExistentClass&quot;);
634         tr.contains(&quot;Error: Could not find or load main class NonExistentClass&quot;);
635         tr.contains(&quot;java.lang.ClassNotFoundException: NonExistentClass&quot;);
636         if (!tr.testStatus)
637             System.out.println(tr);
638     }
639 
640     /**
641      * @param args the command line arguments
642      * @throws java.io.FileNotFoundException
643      */
644     public static void main(String[] args) throws Exception {
645         if (debug) {
646             System.out.println(&quot;Starting Arrrghs tests&quot;);
647         }
648         Arrrghs a = new Arrrghs();
649         a.run(args);
650         if (testExitValue &gt; 0) {
651             System.out.println(&quot;Total of &quot; + testExitValue + &quot; failed&quot;);
652             System.exit(1);
653         } else {
654             System.out.println(&quot;All tests pass&quot;);
655         }
656     }
657 }
    </pre>
  </body>
</html>
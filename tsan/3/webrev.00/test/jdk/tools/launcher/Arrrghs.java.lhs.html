<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames test/jdk/tools/launcher/Arrrghs.java</title>
    <link rel="stylesheet" href="../../../../style.css" />
    <script type="text/javascript" src="../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
<a name="1" id="anc1"></a><span class="line-modified">  2  * Copyright (c) 2007, 2015, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 /**
 25  * @test
 26  * @bug 5030233 6214916 6356475 6571029 6684582 6742159 4459600 6758881 6753938
<a name="2" id="anc2"></a><span class="line-modified"> 27  *      6894719 6968053 7151434 7146424 8007333 8077822 8143640 8132379</span>
 28  * @summary Argument parsing validation.
 29  * @modules jdk.compiler
 30  *          jdk.zipfs
 31  * @compile -XDignore.symbol.file Arrrghs.java
 32  * @run main/othervm Arrrghs
 33  */
 34 
 35 
 36 import java.io.File;
 37 import java.io.FileNotFoundException;
 38 import java.io.IOException;
<a name="3" id="anc3"></a>


 39 import java.util.ArrayList;
 40 import java.util.Arrays;
 41 import java.util.HashMap;
 42 import java.util.List;
 43 import java.util.Map;
 44 import java.util.regex.Matcher;
 45 import java.util.regex.Pattern;
 46 
 47 public class Arrrghs extends TestHelper {
 48     private Arrrghs(){}
 49     /**
 50      * This class provides various tests for arguments processing.
 51      *
 52      * History: these set of tests  were part of Arrrghs.sh. The MKS shell
 53      * implementations were notoriously buggy. Implementing these tests purely
 54      * in Java is not only portable but also robust.
 55      *
 56      */
 57 
<a name="4" id="anc4"></a><span class="line-removed"> 58     /*</span>
<span class="line-removed"> 59      * SIGH, On Windows all strings are quoted, we need to unwrap it</span>
<span class="line-removed"> 60      */</span>
<span class="line-removed"> 61     private static String removeExtraQuotes(String in) {</span>
<span class="line-removed"> 62         if (isWindows) {</span>
<span class="line-removed"> 63             // Trim the string and remove the enclosed quotes if any.</span>
<span class="line-removed"> 64             in = in.trim();</span>
<span class="line-removed"> 65             if (in.startsWith(&quot;\&quot;&quot;) &amp;&amp; in.endsWith(&quot;\&quot;&quot;)) {</span>
<span class="line-removed"> 66                 return in.substring(1, in.length()-1);</span>
<span class="line-removed"> 67             }</span>
<span class="line-removed"> 68         }</span>
<span class="line-removed"> 69         return in;</span>
<span class="line-removed"> 70     }</span>
<span class="line-removed"> 71 </span>
 72     // the pattern we hope to see in the output
 73     static final Pattern ArgPattern = Pattern.compile(&quot;\\s*argv\\[[0-9]*\\].*=.*&quot;);
 74 
 75     void checkArgumentParsing(String inArgs, String... expArgs) throws IOException {
 76         List&lt;String&gt; scratchpad = new ArrayList&lt;&gt;();
 77         scratchpad.add(&quot;set &quot; + JLDEBUG_KEY + &quot;=true&quot;);
 78         // GAK, -version needs to be added so that windows can flush its stderr
 79         // exiting the process prematurely can terminate the stderr.
 80         scratchpad.add(javaCmd + &quot; -version &quot; + inArgs);
 81         File batFile = new File(&quot;atest.bat&quot;);
 82         createAFile(batFile, scratchpad);
 83 
 84         TestResult tr = doExec(batFile.getName());
 85 
 86         ArrayList&lt;String&gt; expList = new ArrayList&lt;&gt;();
 87         expList.add(javaCmd);
 88         expList.add(&quot;-version&quot;);
 89         expList.addAll(Arrays.asList(expArgs));
 90 
 91         List&lt;String&gt; gotList = new ArrayList&lt;&gt;();
 92         for (String x : tr.testOutput) {
 93             Matcher m = ArgPattern.matcher(x);
 94             if (m.matches()) {
 95                 String a[] = x.split(&quot;=&quot;);
 96                 gotList.add(a[a.length - 1].trim());
 97             }
 98         }
 99         if (!gotList.equals(expList)) {
100             System.out.println(tr);
101             System.out.println(&quot;Expected args:&quot;);
102             System.out.println(expList);
103             System.out.println(&quot;Obtained args:&quot;);
104             System.out.println(gotList);
105             throw new RuntimeException(&quot;Error: args do not match&quot;);
106         }
107         System.out.println(&quot;\&#39;&quot; + inArgs + &quot;\&#39;&quot; + &quot; - Test passed&quot;);
108     }
109 
110     /*
111      * This tests general quoting and are specific to Windows, *nixes
112      * need not worry about this, these have been tested with Windows
113      * implementation and those that are known to work are used against
114      * the java implementation. Note that the ProcessBuilder gets in the
115      * way when testing some of these arguments, therefore we need to
116      * create and execute a .bat file containing the arguments.
117      */
118     @Test
119     void testArgumentParsing() throws IOException {
120         if (!isWindows)
121             return;
122         // no quotes
123         checkArgumentParsing(&quot;a b c d&quot;, &quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;);
124 
125         // single quotes
126         checkArgumentParsing(&quot;\&quot;a b c d\&quot;&quot;, &quot;a b c d&quot;);
127 
128         //double quotes
129         checkArgumentParsing(&quot;\&quot;\&quot;a b c d\&quot;\&quot;&quot;, &quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;);
130 
131         // triple quotes
132         checkArgumentParsing(&quot;\&quot;\&quot;\&quot;a b c d\&quot;\&quot;\&quot;&quot;, &quot;\&quot;a b c d\&quot;&quot;);
133 
134         // a literal within single quotes
135         checkArgumentParsing(&quot;\&quot;a\&quot;b c d\&quot;e\&quot;&quot;, &quot;ab&quot;, &quot;c&quot;, &quot;de&quot;);
136 
137         // a literal within double quotes
138         checkArgumentParsing(&quot;\&quot;\&quot;a\&quot;b c d\&quot;e\&quot;\&quot;&quot;, &quot;ab c de&quot;);
139 
140         // a literal quote
141         checkArgumentParsing(&quot;a\\\&quot;b&quot;, &quot;a\&quot;b&quot;);
142 
143         // double back-slash
144         checkArgumentParsing(&quot;\&quot;a b c d\\\\\&quot;&quot;, &quot;a b c d\\&quot;);
145 
146         // triple back-slash
147         checkArgumentParsing(&quot;a\\\\\\\&quot;b&quot;, &quot;a\\\&quot;b&quot;);
148 
149         // dangling quote
150         checkArgumentParsing(&quot;\&quot;a b c\&quot;\&quot;&quot;, &quot;a b c\&quot;&quot;);
151 
152         // expansions of white space separators
153         checkArgumentParsing(&quot;a b&quot;, &quot;a&quot;, &quot;b&quot;);
154         checkArgumentParsing(&quot;a\tb&quot;, &quot;a&quot;, &quot;b&quot;);
155         checkArgumentParsing(&quot;a \t b&quot;, &quot;a&quot;, &quot;b&quot;);
156 
157         checkArgumentParsing(&quot;\&quot;C:\\TEST A\\\\\&quot;&quot;, &quot;C:\\TEST A\\&quot;);
158         checkArgumentParsing(&quot;\&quot;\&quot;C:\\TEST A\\\\\&quot;\&quot;&quot;, &quot;C:\\TEST&quot;, &quot;A\\&quot;);
159 
160         // MS Windows tests
161         // triple back-slash
162         checkArgumentParsing(&quot;a\\\\\\d&quot;, &quot;a\\\\\\d&quot;);
163 
164         // triple back-slash in quotes
165         checkArgumentParsing(&quot;\&quot;a\\\\\\d\&quot;&quot;, &quot;a\\\\\\d&quot;);
166 
167         // slashes separating characters
168         checkArgumentParsing(&quot;X\\Y\\Z&quot;, &quot;X\\Y\\Z&quot;);
169         checkArgumentParsing(&quot;\\X\\Y\\Z&quot;, &quot;\\X\\Y\\Z&quot;);
170 
171         // literals within dangling quotes, etc.
172         checkArgumentParsing(&quot;\&quot;a b c\&quot; d e&quot;, &quot;a b c&quot;, &quot;d&quot;, &quot;e&quot;);
173         checkArgumentParsing(&quot;\&quot;ab\\\&quot;c\&quot;  \&quot;\\\\\&quot;  d&quot;, &quot;ab\&quot;c&quot;, &quot;\\&quot;, &quot;d&quot;);
174         checkArgumentParsing(&quot;a\\\\\\c d\&quot;e f\&quot;g h&quot;, &quot;a\\\\\\c&quot;, &quot;de fg&quot;, &quot;h&quot;);
175         checkArgumentParsing(&quot;a\\\\\\\&quot;b c d&quot;, &quot;a\\\&quot;b&quot;, &quot;c&quot;, &quot;d&quot;);
176         checkArgumentParsing(&quot;a\\\\\\\\\&quot;g c\&quot; d e&quot;, &quot;a\\\\g c&quot;, &quot;d&quot;, &quot;e&quot;);
177 
178         // treatment of back-slashes
179         checkArgumentParsing(&quot;*\\&quot;, &quot;*\\&quot;);
180         checkArgumentParsing(&quot;*/&quot;, &quot;*/&quot;);
181         checkArgumentParsing(&quot;.\\*&quot;, &quot;.\\*&quot;);
182         checkArgumentParsing(&quot;./*&quot;, &quot;./*&quot;);
183         checkArgumentParsing(&quot;..\\..\\*&quot;, &quot;..\\..\\*&quot;);
184         checkArgumentParsing(&quot;../../*&quot;, &quot;../../*&quot;);
185         checkArgumentParsing(&quot;..\\..\\&quot;, &quot;..\\..\\&quot;);
186         checkArgumentParsing(&quot;../../&quot;, &quot;../../&quot;);
187         checkArgumentParsing(&quot;a b\\ c&quot;, &quot;a&quot;, &quot;b\\&quot;, &quot;c&quot;);
188         // 2 back-slashes
189         checkArgumentParsing(&quot;\\\\?&quot;, &quot;\\\\?&quot;);
190         // 3 back-slashes
191         checkArgumentParsing(&quot;\\\\\\?&quot;, &quot;\\\\\\?&quot;);
192         // 4 back-slashes
193         checkArgumentParsing(&quot;\\\\\\\\?&quot;, &quot;\\\\\\\\?&quot;);
194         // 5 back-slashes
195         checkArgumentParsing(&quot;\\\\\\\\\\?&quot;, &quot;\\\\\\\\\\?&quot;);
196         // 6 back-slashes
197         checkArgumentParsing(&quot;\\\\\\\\\\\\?&quot;, &quot;\\\\\\\\\\\\?&quot;);
198 
199         // more treatment of  mixed slashes
200         checkArgumentParsing(&quot;f1/ f3\\ f4/&quot;, &quot;f1/&quot;, &quot;f3\\&quot;, &quot;f4/&quot;);
201         checkArgumentParsing(&quot;f1/ f2\&#39; &#39; f3/ f4/&quot;, &quot;f1/&quot;, &quot;f2\&#39;&quot;, &quot;&#39;&quot;, &quot;f3/&quot;, &quot;f4/&quot;);
202 
203         checkArgumentParsing(&quot;a\\*\\b&quot;, &quot;a\\*\\b&quot;);
204     }
205 
206     private void initEmptyDir(File emptyDir) throws IOException {
207         if (emptyDir.exists()) {
208             recursiveDelete(emptyDir);
209         }
210         emptyDir.mkdir();
211     }
212 
213     private void initDirWithJavaFiles(File libDir) throws IOException {
214 
215         if (libDir.exists()) {
216             recursiveDelete(libDir);
217         }
218         libDir.mkdirs();
219         ArrayList&lt;String&gt; scratchpad = new ArrayList&lt;&gt;();
220         scratchpad.add(&quot;package lib;&quot;);
221         scratchpad.add(&quot;public class Fbo {&quot;);
222         scratchpad.add(&quot;public static void main(String... args){Foo.f();}&quot;);
223         scratchpad.add(&quot;public static void f(){}&quot;);
224         scratchpad.add(&quot;}&quot;);
225         createFile(new File(libDir, &quot;Fbo.java&quot;), scratchpad);
226 
227         scratchpad.clear();
228         scratchpad.add(&quot;package lib;&quot;);
229         scratchpad.add(&quot;public class Foo {&quot;);
230         scratchpad.add(&quot;public static void main(String... args){&quot;);
231         scratchpad.add(&quot;for (String x : args) {&quot;);
232         scratchpad.add(&quot;System.out.println(x);&quot;);
233         scratchpad.add(&quot;}&quot;);
234         scratchpad.add(&quot;Fbo.f();&quot;);
235         scratchpad.add(&quot;}&quot;);
236         scratchpad.add(&quot;public static void f(){}&quot;);
237         scratchpad.add(&quot;}&quot;);
238         createFile(new File(libDir, &quot;Foo.java&quot;), scratchpad);
239     }
240 
241     void checkArgumentWildcard(String inArgs, String... expArgs) throws IOException {
242         String[] in = {inArgs};
243         checkArgumentWildcard(in, expArgs);
244 
245         // now add arbitrary arguments before and after
246         String[] outInArgs = { &quot;-Q&quot;, inArgs, &quot;-R&quot;};
247 
248         String[] outExpArgs = new String[expArgs.length + 2];
249         outExpArgs[0] = &quot;-Q&quot;;
250         System.arraycopy(expArgs, 0, outExpArgs, 1, expArgs.length);
251         outExpArgs[expArgs.length + 1] = &quot;-R&quot;;
252         checkArgumentWildcard(outInArgs, outExpArgs);
253     }
254 
255     void checkArgumentWildcard(String[] inArgs, String[] expArgs) throws IOException {
256         ArrayList&lt;String&gt; argList = new ArrayList&lt;&gt;();
257         argList.add(javaCmd);
258         argList.add(&quot;-cp&quot;);
259         argList.add(&quot;lib&quot; + File.separator + &quot;*&quot;);
260         argList.add(&quot;lib.Foo&quot;);
261         argList.addAll(Arrays.asList(inArgs));
262         String[] cmds = new String[argList.size()];
263         argList.toArray(cmds);
264         TestResult tr = doExec(cmds);
265         if (!tr.isOK()) {
266             System.out.println(tr);
267             throw new RuntimeException(&quot;Error: classpath single entry wildcard entry&quot;);
268         }
269 
270         ArrayList&lt;String&gt; expList = new ArrayList&lt;&gt;();
271         expList.addAll(Arrays.asList(expArgs));
272 
273         List&lt;String&gt; gotList = new ArrayList&lt;&gt;();
274         for (String x : tr.testOutput) {
275             gotList.add(x.trim());
276         }
277         if (!gotList.equals(expList)) {
278             System.out.println(tr);
279             System.out.println(&quot;Expected args:&quot;);
280             System.out.println(expList);
281             System.out.println(&quot;Obtained args:&quot;);
282             System.out.println(gotList);
283             throw new RuntimeException(&quot;Error: args do not match&quot;);
284         }
285         System.out.print(&quot;\&#39;&quot;);
286         for (String x : inArgs) {
287             System.out.print(x + &quot; &quot;);
288         }
289         System.out.println(&quot;\&#39;&quot; + &quot; - Test passed&quot;);
290     }
291 
292     /*
293      * These tests are not expected to work on *nixes, and are ignored.
294      */
295     @Test
296     void testWildCardArgumentProcessing() throws IOException {
297         if (!isWindows)
298             return;
299         File cwd = new File(&quot;.&quot;);
300         File libDir = new File(cwd, &quot;lib&quot;);
301         initDirWithJavaFiles(libDir);
302         initEmptyDir(new File(cwd, &quot;empty&quot;));
303 
304         // test if javac (the command) can compile *.java
305         TestResult tr = doExec(javacCmd, libDir.getName() + File.separator + &quot;*.java&quot;);
306         if (!tr.isOK()) {
307             System.out.println(tr);
308             throw new RuntimeException(&quot;Error: compiling java wildcards&quot;);
309         }
310 
311         // test if javac (the command) can compile *.java with a vmoption
312         tr = doExec(javacCmd, &quot;-cp&quot;, &quot;.&quot;,
313                     &quot;-J-showversion&quot;, &quot;-J-Dsomeproperty=foo&quot;,
314                     libDir.getName() + File.separator + &quot;*.java&quot;);
315         if (!tr.isOK()) {
316             System.out.println(tr);
317             throw new RuntimeException(&quot;Error: compiling java wildcards with vmoptions&quot;);
318         }
319 
320 
321         // use the jar cmd to create jars using the ? wildcard
322         File jarFoo = new File(libDir, &quot;Foo.jar&quot;);
323         tr = doExec(jarCmd, &quot;cvf&quot;, jarFoo.getAbsolutePath(), &quot;lib&quot; + File.separator + &quot;F?o.class&quot;);
324         if (!tr.isOK()) {
325             System.out.println(tr);
326             throw new RuntimeException(&quot;Error: creating jar with wildcards&quot;);
327         }
328 
329         // now the litmus test!, this should work
330         checkArgumentWildcard(&quot;a&quot;, &quot;a&quot;);
331 
332         // test for basic expansion
333         checkArgumentWildcard(&quot;lib\\F*java&quot;, &quot;lib\\Fbo.java&quot;, &quot;lib\\Foo.java&quot;);
334 
335         // basic expansion in quotes
336         checkArgumentWildcard(&quot;\&quot;lib\\F*java\&quot;&quot;, &quot;lib\\F*java&quot;);
337 
338         checkArgumentWildcard(&quot;lib\\**&quot;, &quot;lib\\Fbo.class&quot;, &quot;lib\\Fbo.java&quot;,
339                               &quot;lib\\Foo.class&quot;, &quot;lib\\Foo.jar&quot;, &quot;lib\\Foo.java&quot;);
340 
341         checkArgumentWildcard(&quot;lib\\*?&quot;, &quot;lib\\Fbo.class&quot;, &quot;lib\\Fbo.java&quot;,
342                               &quot;lib\\Foo.class&quot;, &quot;lib\\Foo.jar&quot;, &quot;lib\\Foo.java&quot;);
343 
344         checkArgumentWildcard(&quot;lib\\?*&quot;, &quot;lib\\Fbo.class&quot;, &quot;lib\\Fbo.java&quot;,
345                 &quot;lib\\Foo.class&quot;, &quot;lib\\Foo.jar&quot;, &quot;lib\\Foo.java&quot;);
346 
347         checkArgumentWildcard(&quot;lib\\?&quot;, &quot;lib\\?&quot;);
348 
349         // test for basic expansion
350         checkArgumentWildcard(&quot;lib\\*java&quot;, &quot;lib\\Fbo.java&quot;, &quot;lib\\Foo.java&quot;);
351 
352         // basic expansion in quotes
353         checkArgumentWildcard(&quot;\&quot;lib\\*.java\&quot;&quot;, &quot;lib\\*.java&quot;);
354 
355         // suffix expansion
356         checkArgumentWildcard(&quot;lib\\*.class&quot;, &quot;lib\\Fbo.class&quot;, &quot;lib\\Foo.class&quot;);
357 
358         // suffix expansion in quotes
359         checkArgumentWildcard(&quot;\&quot;lib\\*.class\&quot;&quot;, &quot;lib\\*.class&quot;);
360 
361         // check for ? expansion now
362         checkArgumentWildcard(&quot;lib\\F?o.java&quot;, &quot;lib\\Fbo.java&quot;, &quot;lib\\Foo.java&quot;);
363 
364         // check ? in quotes
365         checkArgumentWildcard(&quot;\&quot;lib\\F?o.java\&quot;&quot;, &quot;lib\\F?o.java&quot;);
366 
367         // check ? as suffixes
368         checkArgumentWildcard(&quot;lib\\F?o.????&quot;, &quot;lib\\Fbo.java&quot;, &quot;lib\\Foo.java&quot;);
369 
370         // check ? in a leading role
371         checkArgumentWildcard(&quot;lib\\???.java&quot;, &quot;lib\\Fbo.java&quot;, &quot;lib\\Foo.java&quot;);
372         checkArgumentWildcard(&quot;\&quot;lib\\???.java\&quot;&quot;, &quot;lib\\???.java&quot;);
373 
374         // check ? prefixed with -
375         checkArgumentWildcard(&quot;-?&quot;, &quot;-?&quot;);
376 
377         // check * prefixed with -
378         checkArgumentWildcard(&quot;-*&quot;, &quot;-*&quot;);
379 
380         // check on empty directory
381         checkArgumentWildcard(&quot;empty\\*&quot;, &quot;empty\\*&quot;);
382         checkArgumentWildcard(&quot;empty\\**&quot;, &quot;empty\\**&quot;);
383         checkArgumentWildcard(&quot;empty\\?&quot;, &quot;empty\\?&quot;);
384         checkArgumentWildcard(&quot;empty\\??&quot;, &quot;empty\\??&quot;);
385         checkArgumentWildcard(&quot;empty\\*?&quot;, &quot;empty\\*?&quot;);
386         checkArgumentWildcard(&quot;empty\\?*&quot;, &quot;empty\\?*&quot;);
387 
388         // 8132379: java should not filter out -J options for application
389         String[] args = { &quot;-J-one&quot;, &quot;-Jtwo&quot;, &quot;lib\\???.java&quot;, &quot;-J-Dsomething&quot;,
390            &quot;a&quot;, &quot;-J-Dlast.arg&quot; };
391         String[] expected = { &quot;-J-one&quot;, &quot;-Jtwo&quot;, &quot;lib\\Fbo.java&quot;,
392            &quot;lib\\Foo.java&quot;, &quot;-J-Dsomething&quot;, &quot;a&quot;, &quot;-J-Dlast.arg&quot; };
393         checkArgumentWildcard(args, expected);
394     }
395 
396     void doArgumentCheck(String inArgs, String... expArgs) {
397         Map&lt;String, String&gt; env = new HashMap&lt;&gt;();
398         env.put(JLDEBUG_KEY, &quot;true&quot;);
399         TestResult tr = doExec(env, javaCmd, inArgs);
400         System.out.println(tr);
401         int sindex = tr.testOutput.indexOf(&quot;Command line args:&quot;);
402         if (sindex &lt; 0) {
403             System.out.println(tr);
404             throw new RuntimeException(&quot;Error: no output&quot;);
405         }
406         sindex++; // skip over the tag
407         List&lt;String&gt; gotList = new ArrayList&lt;&gt;();
408         for (String x : tr.testOutput.subList(sindex, sindex + expArgs.length)) {
409             String a[] = x.split(&quot;=&quot;);
410             gotList.add(a[a.length - 1].trim());
411         }
412         List&lt;String&gt; expList = Arrays.asList(expArgs);
413         if (!gotList.equals(expList)) {
414             System.out.println(tr);
415             System.out.println(&quot;Expected args:&quot;);
416             System.out.println(expList);
417             System.out.println(&quot;Obtained args:&quot;);
418             System.out.println(gotList);
419             throw new RuntimeException(&quot;Error: args do not match&quot;);
420         }
421     }
422 
423 
424     /*
425      * These tests are usually run on non-existent targets to check error results
426      */
427     @Test
428     void testBasicErrorMessages() {
429         // Tests for 5030233
430         TestResult tr = doExec(javaCmd, &quot;-cp&quot;);
431         tr.checkNegative();
432         tr.isNotZeroOutput();
433         if (!tr.testStatus)
434             System.out.println(tr);
435 
436         tr = doExec(javaCmd, &quot;-classpath&quot;);
437         tr.checkNegative();
438         tr.isNotZeroOutput();
439         if (!tr.testStatus)
440             System.out.println(tr);
441 
442         tr = doExec(javaCmd, &quot;-jar&quot;);
443         tr.checkNegative();
444         tr.isNotZeroOutput();
445         if (!tr.testStatus)
446             System.out.println(tr);
447 
448         tr = doExec(javacCmd, &quot;-cp&quot;);
449         tr.checkNegative();
450         tr.isNotZeroOutput();
451         if (!tr.testStatus)
452             System.out.println(tr);
453 
454         // Test for 6356475 &quot;REGRESSION:&quot;java -X&quot; from cmdline fails&quot;
455         tr = doExec(javaCmd, &quot;-X&quot;);
456         tr.checkPositive();
457         tr.isNotZeroOutput();
458         if (!tr.testStatus)
459             System.out.println(tr);
460 
461         tr = doExec(javaCmd, &quot;-help&quot;);
462         tr.checkPositive();
463         tr.isNotZeroOutput();
464         if (!tr.testStatus)
465             System.out.println(tr);
466 
467         // 6753938, test for non-negative exit value for an incorrectly formed
468         // command line,  &#39;% java&#39;
469         tr = doExec(javaCmd);
470         tr.checkNegative();
471         tr.isNotZeroOutput();
472         if (!tr.testStatus)
473             System.out.println(tr);
474 
475         // 6753938, test for non-negative exit value for an incorrectly formed
476         // command line,  &#39;% java -Xcomp&#39;
477         tr = doExec(javaCmd, &quot;-Xcomp&quot;);
478         tr.checkNegative();
479         tr.isNotZeroOutput();
480         if (!tr.testStatus)
481             System.out.println(tr);
482 
483         // 7151434, test for non-negative exit value for an incorrectly formed
484         // command line, &#39;% java -jar -W&#39;, note the bogus -W
485         tr = doExec(javaCmd, &quot;-jar&quot;, &quot;-W&quot;);
486         tr.checkNegative();
487         tr.contains(&quot;Unrecognized option: -W&quot;);
488         if (!tr.testStatus)
489             System.out.println(tr);
490     }
491 
<a name="5" id="anc5"></a>




















492     /*
493      * Tests various dispositions of the main method, these tests are limited
494      * to English locales as they check for error messages that are localized.
495      */
496     @Test
497     void testMainMethod() throws FileNotFoundException {
498         if (!isEnglishLocale()) {
499             return;
500         }
501 
502         TestResult tr;
503 
504         // a missing class
505         createJar(&quot;MIA&quot;, new File(&quot;some.jar&quot;), new File(&quot;Foo&quot;),
506                 (String[])null);
507         tr = doExec(javaCmd, &quot;-jar&quot;, &quot;some.jar&quot;);
508         tr.contains(&quot;Error: Could not find or load main class MIA&quot;);
509         if (!tr.testStatus)
510             System.out.println(tr);
511         // use classpath to check
512         tr = doExec(javaCmd, &quot;-cp&quot;, &quot;some.jar&quot;, &quot;MIA&quot;);
513         tr.contains(&quot;Error: Could not find or load main class MIA&quot;);
514         if (!tr.testStatus)
515             System.out.println(tr);
516 
517         // incorrect method access
518         createJar(new File(&quot;some.jar&quot;), new File(&quot;Foo&quot;),
519                 &quot;private static void main(String[] args){}&quot;);
520         tr = doExec(javaCmd, &quot;-jar&quot;, &quot;some.jar&quot;);
521         tr.contains(&quot;Error: Main method not found in class Foo&quot;);
522         if (!tr.testStatus)
523             System.out.println(tr);
524         // use classpath to check
525         tr = doExec(javaCmd, &quot;-cp&quot;, &quot;some.jar&quot;, &quot;Foo&quot;);
526         tr.contains(&quot;Error: Main method not found in class Foo&quot;);
527         if (!tr.testStatus)
528             System.out.println(tr);
529 
530         // incorrect return type
531         createJar(new File(&quot;some.jar&quot;), new File(&quot;Foo&quot;),
532                 &quot;public static int main(String[] args){return 1;}&quot;);
533         tr = doExec(javaCmd, &quot;-jar&quot;, &quot;some.jar&quot;);
534         tr.contains(&quot;Error: Main method must return a value of type void in class Foo&quot;);
535         if (!tr.testStatus)
536             System.out.println(tr);
537         // use classpath to check
538         tr = doExec(javaCmd, &quot;-cp&quot;, &quot;some.jar&quot;, &quot;Foo&quot;);
539         tr.contains(&quot;Error: Main method must return a value of type void in class Foo&quot;);
540         if (!tr.testStatus)
541             System.out.println(tr);
542 
543         // incorrect parameter type
544         createJar(new File(&quot;some.jar&quot;), new File(&quot;Foo&quot;),
545                 &quot;public static void main(Object[] args){}&quot;);
546         tr = doExec(javaCmd, &quot;-jar&quot;, &quot;some.jar&quot;);
547         tr.contains(&quot;Error: Main method not found in class Foo&quot;);
548         if (!tr.testStatus)
549             System.out.println(tr);
550         // use classpath to check
551         tr = doExec(javaCmd, &quot;-cp&quot;, &quot;some.jar&quot;, &quot;Foo&quot;);
552         tr.contains(&quot;Error: Main method not found in class Foo&quot;);
553         if (!tr.testStatus)
554             System.out.println(tr);
555 
556         // incorrect method type - non-static
557          createJar(new File(&quot;some.jar&quot;), new File(&quot;Foo&quot;),
558                 &quot;public void main(String[] args){}&quot;);
559         tr = doExec(javaCmd, &quot;-jar&quot;, &quot;some.jar&quot;);
560         tr.contains(&quot;Error: Main method is not static in class Foo&quot;);
561         if (!tr.testStatus)
562             System.out.println(tr);
563         // use classpath to check
564         tr = doExec(javaCmd, &quot;-cp&quot;, &quot;some.jar&quot;, &quot;Foo&quot;);
565         tr.contains(&quot;Error: Main method is not static in class Foo&quot;);
566         if (!tr.testStatus)
567             System.out.println(tr);
568 
569         // amongst a potpourri of kindred main methods, is the right one chosen ?
570         createJar(new File(&quot;some.jar&quot;), new File(&quot;Foo&quot;),
571             &quot;void main(Object[] args){}&quot;,
572             &quot;int  main(Float[] args){return 1;}&quot;,
573             &quot;private void main() {}&quot;,
574             &quot;private static void main(int x) {}&quot;,
575             &quot;public int main(int argc, String[] argv) {return 1;}&quot;,
576             &quot;public static void main(String[] args) {System.out.println(\&quot;THE_CHOSEN_ONE\&quot;);}&quot;);
577         tr = doExec(javaCmd, &quot;-jar&quot;, &quot;some.jar&quot;);
578         tr.contains(&quot;THE_CHOSEN_ONE&quot;);
579         if (!tr.testStatus)
580             System.out.println(tr);
581         // use classpath to check
582         tr = doExec(javaCmd, &quot;-cp&quot;, &quot;some.jar&quot;, &quot;Foo&quot;);
583         tr.contains(&quot;THE_CHOSEN_ONE&quot;);
584         if (!tr.testStatus)
585             System.out.println(tr);
586 
587         // test for extraneous whitespace in the Main-Class attribute
588         createJar(&quot; Foo &quot;, new File(&quot;some.jar&quot;), new File(&quot;Foo&quot;),
589                 &quot;public static void main(String... args){}&quot;);
590         tr = doExec(javaCmd, &quot;-jar&quot;, &quot;some.jar&quot;);
591         tr.checkPositive();
592         if (!tr.testStatus)
593             System.out.println(tr);
594     }
595     /*
596      * tests 6968053, ie. we turn on the -Xdiag (for now) flag and check if
597      * the suppressed stack traces are exposed, ignore these tests for localized
598      * locales, limiting to English only.
599      */
600     @Test
601     void testDiagOptions() throws FileNotFoundException {
602         if (!isEnglishLocale()) { // only english version
603             return;
604         }
605         TestResult tr;
606         // a missing class
607         createJar(&quot;MIA&quot;, new File(&quot;some.jar&quot;), new File(&quot;Foo&quot;),
608                 (String[])null);
609         tr = doExec(javaCmd, &quot;-Xdiag&quot;, &quot;-jar&quot;, &quot;some.jar&quot;);
610         tr.contains(&quot;Error: Could not find or load main class MIA&quot;);
611         tr.contains(&quot;java.lang.ClassNotFoundException: MIA&quot;);
612         if (!tr.testStatus)
613             System.out.println(tr);
614 
615         // use classpath to check
616         tr = doExec(javaCmd,  &quot;-Xdiag&quot;, &quot;-cp&quot;, &quot;some.jar&quot;, &quot;MIA&quot;);
617         tr.contains(&quot;Error: Could not find or load main class MIA&quot;);
618         tr.contains(&quot;java.lang.ClassNotFoundException: MIA&quot;);
619         if (!tr.testStatus)
620             System.out.println(tr);
621 
622         // a missing class on the classpath
623         tr = doExec(javaCmd, &quot;-Xdiag&quot;, &quot;NonExistentClass&quot;);
624         tr.contains(&quot;Error: Could not find or load main class NonExistentClass&quot;);
625         tr.contains(&quot;java.lang.ClassNotFoundException: NonExistentClass&quot;);
626         if (!tr.testStatus)
627             System.out.println(tr);
628     }
629 
630     /**
631      * @param args the command line arguments
632      * @throws java.io.FileNotFoundException
633      */
634     public static void main(String[] args) throws Exception {
635         if (debug) {
636             System.out.println(&quot;Starting Arrrghs tests&quot;);
637         }
638         Arrrghs a = new Arrrghs();
639         a.run(args);
640         if (testExitValue &gt; 0) {
641             System.out.println(&quot;Total of &quot; + testExitValue + &quot; failed&quot;);
642             System.exit(1);
643         } else {
644             System.out.println(&quot;All tests pass&quot;);
645         }
646     }
647 }
<a name="6" id="anc6"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="6" type="hidden" />
</body>
</html>
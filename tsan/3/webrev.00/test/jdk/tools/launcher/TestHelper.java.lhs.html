<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames test/jdk/tools/launcher/TestHelper.java</title>
    <link rel="stylesheet" href="../../../../style.css" />
    <script type="text/javascript" src="../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (c) 2008, 2014, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 import java.io.OutputStream;
 25 import java.io.InputStream;
 26 import java.lang.annotation.ElementType;
 27 import java.lang.annotation.Retention;
 28 import java.lang.annotation.RetentionPolicy;
 29 import java.lang.annotation.Target;
 30 import java.lang.reflect.Method;
 31 import java.util.regex.Pattern;
 32 import java.io.StringWriter;
 33 import java.io.PrintWriter;
 34 import java.util.Set;
 35 import java.io.BufferedReader;
 36 import java.io.File;
 37 import java.io.FileFilter;
 38 import java.io.FileNotFoundException;
 39 import java.io.FileOutputStream;
 40 import java.io.IOException;
 41 import java.io.InputStreamReader;
 42 import java.io.PrintStream;
 43 import java.nio.charset.Charset;
 44 import java.nio.file.attribute.BasicFileAttributes;
 45 import java.nio.file.Files;
 46 import java.nio.file.FileVisitResult;
 47 import java.nio.file.SimpleFileVisitor;
 48 import java.nio.file.Path;
 49 import java.util.ArrayList;
 50 import java.util.List;
 51 import java.util.Locale;
 52 import java.util.Map;
 53 import java.util.Arrays;
 54 import java.util.spi.ToolProvider;
 55 
 56 import static java.nio.file.StandardCopyOption.*;
 57 import static java.nio.file.StandardOpenOption.*;
 58 
 59 /**
 60  * This class provides some common utilities for the launcher tests.
 61  */
 62 public class TestHelper {
 63     // commonly used jtreg constants
 64     static final File TEST_CLASSES_DIR;
 65     static final File TEST_SOURCES_DIR;
 66 
 67     static final String JAVAHOME = System.getProperty(&quot;java.home&quot;);
 68     static final String JAVA_BIN;
 69     static final String JAVA_LIB;
 70     static final String javaCmd;
 71     static final String javawCmd;
 72     static final String javacCmd;
 73     static final String jarCmd;
 74     static final boolean haveServerVM;
 75     static final boolean haveClientVM;
 76 
 77     static final ToolProvider compiler = ToolProvider.findFirst(&quot;javac&quot;).orElse(null);
 78 
 79     static final boolean debug = Boolean.getBoolean(&quot;TestHelper.Debug&quot;);
 80     static final boolean isWindows =
 81             System.getProperty(&quot;os.name&quot;, &quot;unknown&quot;).startsWith(&quot;Windows&quot;);
 82     static final boolean isMacOSX =
 83             System.getProperty(&quot;os.name&quot;, &quot;unknown&quot;).contains(&quot;OS X&quot;);
 84     static final boolean is64Bit =
 85             System.getProperty(&quot;sun.arch.data.model&quot;).equals(&quot;64&quot;);
 86     static final boolean is32Bit =
 87             System.getProperty(&quot;sun.arch.data.model&quot;).equals(&quot;32&quot;);
 88     static final boolean isSolaris =
 89             System.getProperty(&quot;os.name&quot;, &quot;unknown&quot;).startsWith(&quot;SunOS&quot;);
 90     static final boolean isLinux =
 91             System.getProperty(&quot;os.name&quot;, &quot;unknown&quot;).startsWith(&quot;Linux&quot;);
 92     static final boolean isAIX =
 93             System.getProperty(&quot;os.name&quot;, &quot;unknown&quot;).startsWith(&quot;AIX&quot;);
 94     static final String LIBJVM = isWindows
 95                         ? &quot;jvm.dll&quot;
 96                         : &quot;libjvm&quot; + (isMacOSX ? &quot;.dylib&quot; : &quot;.so&quot;);
 97 
 98     static final boolean isSparc = System.getProperty(&quot;os.arch&quot;).startsWith(&quot;sparc&quot;);
 99 
100     // make a note of the golden default locale
101     static final Locale DefaultLocale = Locale.getDefault();
102 
103     static final String JAVA_FILE_EXT  = &quot;.java&quot;;
104     static final String CLASS_FILE_EXT = &quot;.class&quot;;
105     static final String JAR_FILE_EXT   = &quot;.jar&quot;;
106     static final String EXE_FILE_EXT   = &quot;.exe&quot;;
107     static final String JLDEBUG_KEY     = &quot;_JAVA_LAUNCHER_DEBUG&quot;;
108     static final String EXPECTED_MARKER = &quot;TRACER_MARKER:About to EXEC&quot;;
109     static final String TEST_PREFIX     = &quot;###TestError###: &quot;;
110 
111     static int testExitValue = 0;
112 
113     static {
114         String tmp = System.getProperty(&quot;test.classes&quot;, null);
115         if (tmp == null) {
116             throw new Error(&quot;property test.classes not defined ??&quot;);
117         }
118         TEST_CLASSES_DIR = new File(tmp).getAbsoluteFile();
119 
120         tmp = System.getProperty(&quot;test.src&quot;, null);
121         if (tmp == null) {
122             throw new Error(&quot;property test.src not defined ??&quot;);
123         }
124         TEST_SOURCES_DIR = new File(tmp).getAbsoluteFile();
125 
126         if (is64Bit &amp;&amp; is32Bit) {
127             throw new RuntimeException(&quot;arch model cannot be both 32 and 64 bit&quot;);
128         }
129         if (!is64Bit &amp;&amp; !is32Bit) {
130             throw new RuntimeException(&quot;arch model is not 32 or 64 bit ?&quot;);
131         }
132 
133         File binDir = new File(JAVAHOME, &quot;bin&quot;);
134         JAVA_BIN = binDir.getAbsolutePath();
135         File libDir = new File(JAVAHOME, &quot;lib&quot;);
136         JAVA_LIB = libDir.getAbsolutePath();
137 
138         File javaCmdFile = (isWindows)
139                 ? new File(binDir, &quot;java.exe&quot;)
140                 : new File(binDir, &quot;java&quot;);
141         javaCmd = javaCmdFile.getAbsolutePath();
142         if (!javaCmdFile.canExecute()) {
143             throw new RuntimeException(&quot;java &lt;&quot; + TestHelper.javaCmd +
144                     &quot;&gt; must exist and should be executable&quot;);
145         }
146 
147         File javacCmdFile = (isWindows)
148                 ? new File(binDir, &quot;javac.exe&quot;)
149                 : new File(binDir, &quot;javac&quot;);
150         javacCmd = javacCmdFile.getAbsolutePath();
151 
152         File jarCmdFile = (isWindows)
153                 ? new File(binDir, &quot;jar.exe&quot;)
154                 : new File(binDir, &quot;jar&quot;);
155         jarCmd = jarCmdFile.getAbsolutePath();
156         if (!jarCmdFile.canExecute()) {
157             throw new RuntimeException(&quot;java &lt;&quot; + TestHelper.jarCmd +
158                     &quot;&gt; must exist and should be executable&quot;);
159         }
160 
161         if (isWindows) {
162             File javawCmdFile = new File(binDir, &quot;javaw.exe&quot;);
163             javawCmd = javawCmdFile.getAbsolutePath();
164             if (!javawCmdFile.canExecute()) {
165                 throw new RuntimeException(&quot;java &lt;&quot; + javawCmd +
166                         &quot;&gt; must exist and should be executable&quot;);
167             }
168         } else {
169             javawCmd = null;
170         }
171 
172         if (!javacCmdFile.canExecute()) {
173             throw new RuntimeException(&quot;java &lt;&quot; + javacCmd +
174                     &quot;&gt; must exist and should be executable&quot;);
175         }
176 
177         haveClientVM = haveVmVariant(&quot;client&quot;);
178         haveServerVM = haveVmVariant(&quot;server&quot;);
179     }
180     private static boolean haveVmVariant(String type) {
181         if (isWindows) {
182             File vmDir = new File(JAVA_BIN, type);
183             File jvmFile = new File(vmDir, LIBJVM);
184             return jvmFile.exists();
185         } else {
186             File vmDir = new File(JAVA_LIB, type);
187             File jvmFile = new File(vmDir, LIBJVM);
188             return jvmFile.exists();
189         }
190     }
191     void run(String[] args) throws Exception {
192         int passed = 0, failed = 0;
193         final Pattern p = (args != null &amp;&amp; args.length &gt; 0)
194                 ? Pattern.compile(args[0])
195                 : null;
196         for (Method m : this.getClass().getDeclaredMethods()) {
197             boolean selected = (p == null)
198                     ? m.isAnnotationPresent(Test.class)
199                     : p.matcher(m.getName()).matches();
200             if (selected) {
201                 try {
202                     m.invoke(this, (Object[]) null);
203                     System.out.println(m.getName() + &quot;: OK&quot;);
204                     passed++;
205                     System.out.printf(&quot;Passed: %d, Failed: %d, ExitValue: %d%n&quot;,
206                                       passed, failed, testExitValue);
207                 } catch (Throwable ex) {
208                     System.out.printf(&quot;Test %s failed: %s %n&quot;, m, ex);
209                     System.out.println(&quot;----begin detailed exceptions----&quot;);
210                     ex.printStackTrace(System.out);
211                     for (Throwable t : ex.getSuppressed()) {
212                         t.printStackTrace(System.out);
213                     }
214                     System.out.println(&quot;----end detailed exceptions----&quot;);
215                     failed++;
216                 }
217             }
218         }
219         System.out.printf(&quot;Total: Passed: %d, Failed %d%n&quot;, passed, failed);
220         if (failed &gt; 0) {
221             throw new RuntimeException(&quot;Tests failed: &quot; + failed);
222         }
223         if (passed == 0 &amp;&amp; failed == 0) {
224             throw new AssertionError(&quot;No test(s) selected: passed = &quot; +
225                     passed + &quot;, failed = &quot; + failed + &quot; ??????????&quot;);
226         }
227     }
228 
229     /*
230      * usually the jre/lib/arch-name is the same as os.arch, except for x86.
231      */
232     static String getJreArch() {
233         String arch = System.getProperty(&quot;os.arch&quot;);
234         return arch.equals(&quot;x86&quot;) ? &quot;i386&quot; : arch;
235     }
236     static String getArch() {
237         return System.getProperty(&quot;os.arch&quot;);
238     }
239     static File getClassFile(File javaFile) {
240         String s = javaFile.getAbsolutePath().replace(JAVA_FILE_EXT, CLASS_FILE_EXT);
241         return new File(s);
242     }
243 
244     static File getJavaFile(File classFile) {
245         String s = classFile.getAbsolutePath().replace(CLASS_FILE_EXT, JAVA_FILE_EXT);
246         return new File(s);
247     }
248 
249     static String baseName(File f) {
250         String s = f.getName();
251         return s.substring(0, s.indexOf(&quot;.&quot;));
252     }
253 
254     /*
255      * A convenience method to create a jar with jar file name and defs
256      */
257     static void createJar(File jarName, String... mainDefs)
258             throws FileNotFoundException{
259         createJar(null, jarName, new File(&quot;Foo&quot;), mainDefs);
260     }
261 
262     /*
263      * A convenience method to create a java file, compile and jar it up, using
264      * the sole class file name in the jar, as the Main-Class attribute value.
265      */
266     static void createJar(File jarName, File mainClass, String... mainDefs)
267             throws FileNotFoundException {
268             createJar(null, jarName, mainClass, mainDefs);
269     }
270 
271     /*
272      * A convenience method to compile java files.
273      */
274     static void compile(String... compilerArgs) {
275         if (compiler.run(System.out, System.err, compilerArgs) != 0) {
276             String sarg = &quot;&quot;;
277             for (String x : compilerArgs) {
278                 sarg.concat(x + &quot; &quot;);
279             }
280             throw new Error(&quot;compilation failed: &quot; + sarg);
281         }
282     }
283 
284     /*
285      * A generic jar file creator to create a java file, compile it
286      * and jar it up, a specific Main-Class entry name in the
287      * manifest can be specified or a null to use the sole class file name
288      * as the Main-Class attribute value.
289      */
290     static void createJar(String mEntry, File jarName, File mainClass,
291             String... mainDefs) throws FileNotFoundException {
292         if (jarName.exists()) {
293             jarName.delete();
294         }
295         try (PrintStream ps = new PrintStream(new FileOutputStream(mainClass + &quot;.java&quot;))) {
296             ps.println(&quot;public class Foo {&quot;);
297             if (mainDefs != null) {
298                 for (String x : mainDefs) {
299                     ps.println(x);
300                 }
301             }
302             ps.println(&quot;}&quot;);
303         }
304 
305         String compileArgs[] = {
306             mainClass + &quot;.java&quot;
307         };
308         if (compiler.run(System.out, System.err, compileArgs) != 0) {
309             throw new RuntimeException(&quot;compilation failed &quot; + mainClass + &quot;.java&quot;);
310         }
311         if (mEntry == null) {
312             mEntry = mainClass.getName();
313         }
314         String jarArgs[] = {
315             (debug) ? &quot;cvfe&quot; : &quot;cfe&quot;,
316             jarName.getAbsolutePath(),
317             mEntry,
318             mainClass.getName() + &quot;.class&quot;
319         };
320         createJar(jarArgs);
321     }
322 
323    static void createJar(String... args) {
324         List&lt;String&gt; cmdList = new ArrayList&lt;&gt;();
325         cmdList.add(jarCmd);
326         cmdList.addAll(Arrays.asList(args));
327         doExec(cmdList.toArray(new String[cmdList.size()]));
328    }
329 
330    static void copyStream(InputStream in, OutputStream out) throws IOException {
331         byte[] buf = new byte[8192];
332         int n = in.read(buf);
333         while (n &gt; 0) {
334             out.write(buf, 0, n);
335             n = in.read(buf);
336         }
337     }
338 
339    static void copyFile(File src, File dst) throws IOException {
340         Path parent = dst.toPath().getParent();
341         if (parent != null) {
342             Files.createDirectories(parent);
343         }
344         Files.copy(src.toPath(), dst.toPath(), COPY_ATTRIBUTES, REPLACE_EXISTING);
345     }
346 
347     /**
348      * Attempt to create a file at the given location. If an IOException
349      * occurs then back off for a moment and try again. When a number of
350      * attempts fail, give up and throw an exception.
351      */
<a name="1" id="anc1"></a><span class="line-modified">352     void createAFile(File aFile, List&lt;String&gt; contents) throws IOException {</span>




353         IOException cause = null;
354         for (int attempts = 0; attempts &lt; 10; attempts++) {
355             try {
<a name="2" id="anc2"></a><span class="line-modified">356                 Files.write(aFile.getAbsoluteFile().toPath(), contents,</span>
<span class="line-modified">357                     Charset.defaultCharset(), CREATE, TRUNCATE_EXISTING, WRITE);</span>







358                 if (cause != null) {
359                     /*
360                      * report attempts and errors that were encountered
361                      * for diagnostic purposes
362                      */
363                     System.err.println(&quot;Created batch file &quot; +
364                                         aFile + &quot; in &quot; + (attempts + 1) +
365                                         &quot; attempts&quot;);
366                     System.err.println(&quot;Errors encountered: &quot; + cause);
367                     cause.printStackTrace();
368                 }
369                 return;
370             } catch (IOException ioe) {
371                 if (cause != null) {
372                     // chain the exceptions so they all get reported for diagnostics
373                     cause.addSuppressed(ioe);
374                 } else {
375                     cause = ioe;
376                 }
377             }
378 
379             try {
380                 Thread.sleep(500);
381             } catch (InterruptedException ie) {
382                 if (cause != null) {
383                     // cause should alway be non-null here
384                     ie.addSuppressed(cause);
385                 }
386                 throw new RuntimeException(&quot;Interrupted while creating batch file&quot;, ie);
387             }
388         }
389         throw new RuntimeException(&quot;Unable to create batch file&quot;, cause);
390     }
391 
392     static void createFile(File outFile, List&lt;String&gt; content) throws IOException {
393         Files.write(outFile.getAbsoluteFile().toPath(), content,
394                 Charset.defaultCharset(), CREATE_NEW);
395     }
396 
397     static void recursiveDelete(File target) throws IOException {
398         if (!target.exists()) {
399             return;
400         }
401         Files.walkFileTree(target.toPath(), new SimpleFileVisitor&lt;Path&gt;() {
402             @Override
403             public FileVisitResult postVisitDirectory(Path dir, IOException exc) {
404                 try {
405                     Files.deleteIfExists(dir);
406                 } catch (IOException ex) {
407                     System.out.println(&quot;Error: could not delete: &quot; + dir.toString());
408                     System.out.println(ex.getMessage());
409                     return FileVisitResult.TERMINATE;
410                 }
411                 return FileVisitResult.CONTINUE;
412             }
413             @Override
414             public FileVisitResult visitFile(Path file, BasicFileAttributes attrs) {
415                 try {
416                     Files.deleteIfExists(file);
417                 } catch (IOException ex) {
418                     System.out.println(&quot;Error: could not delete: &quot; + file.toString());
419                     System.out.println(ex.getMessage());
420                     return FileVisitResult.TERMINATE;
421                 }
422                 return FileVisitResult.CONTINUE;
423             }
424         });
425     }
426 
427     static TestResult doExec(String...cmds) {
428         return doExec(null, null, cmds);
429     }
430 
431     static TestResult doExec(Map&lt;String, String&gt; envToSet, String...cmds) {
432         return doExec(envToSet, null, cmds);
433     }
434     /*
435      * A method which executes a java cmd and returns the results in a container
436      */
437     static TestResult doExec(Map&lt;String, String&gt; envToSet,
438                              Set&lt;String&gt; envToRemove, String...cmds) {
439         String cmdStr = &quot;&quot;;
440         for (String x : cmds) {
441             cmdStr = cmdStr.concat(x + &quot; &quot;);
442         }
443         ProcessBuilder pb = new ProcessBuilder(cmds);
444         Map&lt;String, String&gt; env = pb.environment();
445         if (envToRemove != null) {
446             for (String key : envToRemove) {
447                 env.remove(key);
448             }
449         }
450         if (envToSet != null) {
451             env.putAll(envToSet);
452         }
453         BufferedReader rdr = null;
454         try {
455             List&lt;String&gt; outputList = new ArrayList&lt;&gt;();
456             pb.redirectErrorStream(true);
457             Process p = pb.start();
458             rdr = new BufferedReader(new InputStreamReader(p.getInputStream()));
459             String in = rdr.readLine();
460             while (in != null) {
461                 outputList.add(in);
462                 in = rdr.readLine();
463             }
464             p.waitFor();
465             p.destroy();
466 
467             return new TestHelper.TestResult(cmdStr, p.exitValue(), outputList,
468                     env, new Throwable(&quot;current stack of the test&quot;));
469         } catch (Exception ex) {
470             ex.printStackTrace();
471             throw new RuntimeException(ex.getMessage());
472         }
473     }
474 
475     static FileFilter createFilter(final String extension) {
476         return new FileFilter() {
477             @Override
478             public boolean accept(File pathname) {
479                 String name = pathname.getName();
480                 if (name.endsWith(extension)) {
481                     return true;
482                 }
483                 return false;
484             }
485         };
486     }
487 
488     static boolean isEnglishLocale() {
489         return Locale.getDefault().getLanguage().equals(&quot;en&quot;);
490     }
491 
<a name="3" id="anc3"></a>

































492     /*
493      * A class to encapsulate the test results and stuff, with some ease
494      * of use methods to check the test results.
495      */
496     static class TestResult {
497         PrintWriter status;
498         StringWriter sw;
499         int exitValue;
500         List&lt;String&gt; testOutput;
501         Map&lt;String, String&gt; env;
502         Throwable t;
503         boolean testStatus;
504 
505         public TestResult(String str, int rv, List&lt;String&gt; oList,
506                 Map&lt;String, String&gt; env, Throwable t) {
507             sw = new StringWriter();
508             status = new PrintWriter(sw);
509             status.println(&quot;Executed command: &quot; + str + &quot;\n&quot;);
510             exitValue = rv;
511             testOutput = oList;
512             this.env = env;
513             this.t = t;
514             testStatus = true;
515         }
516 
517         void appendError(String x) {
518             testStatus = false;
519             testExitValue++;
520             status.println(TEST_PREFIX + x);
521         }
522 
523         void indentStatus(String x) {
524             status.println(&quot;  &quot; + x);
525         }
526 
527         void checkNegative() {
528             if (exitValue == 0) {
529                 appendError(&quot;test must not return 0 exit value&quot;);
530             }
531         }
532 
533         void checkPositive() {
534             if (exitValue != 0) {
535                 appendError(&quot;test did not return 0 exit value&quot;);
536             }
537         }
538 
539         boolean isOK() {
540             return exitValue == 0;
541         }
542 
543         boolean isZeroOutput() {
544             if (!testOutput.isEmpty()) {
545                 appendError(&quot;No message from cmd please&quot;);
546                 return false;
547             }
548             return true;
549         }
550 
551         boolean isNotZeroOutput() {
552             if (testOutput.isEmpty()) {
553                 appendError(&quot;Missing message&quot;);
554                 return false;
555             }
556             return true;
557         }
558 
559         @Override
560         public String toString() {
561             status.println(&quot;++++Begin Test Info++++&quot;);
562             status.println(&quot;Test Status: &quot; + (testStatus ? &quot;PASS&quot; : &quot;FAIL&quot;));
563             status.println(&quot;++++Test Environment++++&quot;);
564             for (String x : env.keySet()) {
565                 indentStatus(x + &quot;=&quot; + env.get(x));
566             }
567             status.println(&quot;++++Test Output++++&quot;);
568             for (String x : testOutput) {
569                 indentStatus(x);
570             }
571             status.println(&quot;++++Test Stack Trace++++&quot;);
572             status.println(t.toString());
573             for (StackTraceElement e : t.getStackTrace()) {
574                 indentStatus(e.toString());
575             }
576             status.println(&quot;++++End of Test Info++++&quot;);
577             status.flush();
578             String out = sw.toString();
579             status.close();
580             return out;
581         }
582 
583         boolean contains(String str) {
584             for (String x : testOutput) {
585                 if (x.contains(str)) {
586                     return true;
587                 }
588             }
589             appendError(&quot;string &lt;&quot; + str + &quot;&gt; not found&quot;);
590             return false;
591         }
592 
593         boolean notContains(String str) {
594             for (String x : testOutput) {
595                 if (x.contains(str)) {
596                     appendError(&quot;string &lt;&quot; + str + &quot;&gt; found&quot;);
597                     return false;
598                 }
599             }
600             return true;
601         }
602 
603         boolean matches(String regexToMatch) {
604             for (String x : testOutput) {
605                 if (x.matches(regexToMatch)) {
606                     return true;
607                 }
608             }
609             appendError(&quot;regex &lt;&quot; + regexToMatch + &quot;&gt; not matched&quot;);
610             return false;
611         }
612 
613         boolean notMatches(String regexToMatch) {
614             for (String x : testOutput) {
615                 if (!x.matches(regexToMatch)) {
616                     return true;
617                 }
618             }
619             appendError(&quot;regex &lt;&quot; + regexToMatch + &quot;&gt; matched&quot;);
620             return false;
621         }
622     }
623     /**
624     * Indicates that the annotated method is a test method.
625     */
626     @Retention(RetentionPolicy.RUNTIME)
627     @Target(ElementType.METHOD)
628     public @interface Test {}
629 }
<a name="4" id="anc4"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="4" type="hidden" />
</body>
</html>
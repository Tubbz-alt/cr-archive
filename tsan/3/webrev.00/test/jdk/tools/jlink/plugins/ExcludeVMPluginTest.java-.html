<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old test/jdk/tools/jlink/plugins/ExcludeVMPluginTest.java</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2015, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24  /*
 25  * @test
 26  * @summary Test exclude VM plugin
 27  * @author Jean-Francois Denise
 28  * @modules jdk.jlink/jdk.tools.jlink.internal
 29  *          jdk.jlink/jdk.tools.jlink.internal.plugins
 30  *          jdk.jlink/jdk.tools.jlink.plugin
 31  * @run main ExcludeVMPluginTest
 32  */
 33 import java.io.ByteArrayInputStream;
 34 import java.net.URI;
 35 import java.nio.file.Path;
 36 import java.nio.file.Paths;
 37 import java.util.HashMap;
 38 import java.util.Map;
 39 import jdk.tools.jlink.internal.ResourcePoolManager;
 40 
 41 import jdk.tools.jlink.internal.plugins.ExcludeVMPlugin;
 42 import jdk.tools.jlink.plugin.Plugin;
 43 import jdk.tools.jlink.plugin.ResourcePool;
 44 import jdk.tools.jlink.plugin.ResourcePoolEntry;
 45 
 46 public class ExcludeVMPluginTest {
 47 
 48     private static final String TAG = &quot;# orig in test\n&quot;;
 49 
 50     private static final String[] ARCHITECTURES = {&quot;/&quot;, &quot;/amd64/&quot;, &quot;/i386/&quot;, &quot;/arm/&quot;,
 51         &quot;/aarch64/&quot;, &quot;/toto/&quot;};
 52 
 53     private static final String[] CLIENT = {&quot;client/&quot; + jvmlib(),};
 54     private static final String[] SERVER = {&quot;server/&quot; + jvmlib()};
 55     private static final String[] MINIMAL = {&quot;minimal/&quot; + jvmlib()};
 56     private static final String[] ALL = {CLIENT[0], SERVER[0], MINIMAL[0]};
 57     private static final String JVM_CFG_ALL = TAG + &quot;-server KNOWN\n-client KNOWN\n-minimal KNOWN\n&quot;;
 58     private static final String JVM_CFG_CLIENT = TAG + &quot;-client KNOWN\n&quot;;
 59     private static final String JVM_CFG_SERVER = TAG + &quot;-server KNOWN\n&quot;;
 60     private static final String JVM_CFG_SERVER_ALIAS_OTHERS = TAG + &quot;-server KNOWN\n-client ALIASED_TO -server\n-minimal ALIASED_TO -server\n&quot;;
 61     private static final String JVM_CFG_CLIENT_ALIAS_OTHERS = TAG + &quot;-client KNOWN\n-server ALIASED_TO -client\n-minimal ALIASED_TO -client\n&quot;;
 62     private static final String JVM_CFG_MINIMAL_ALIAS_OTHERS = TAG + &quot;-minimal KNOWN\n-server ALIASED_TO -minimal\n-client ALIASED_TO -minimal\n&quot;;
 63     private static final String JVM_CFG_MINIMAL = TAG + &quot;-minimal KNOWN\n&quot;;
 64 
 65     public static void main(String[] args) throws Exception {
 66         new ExcludeVMPluginTest().test();
 67     }
 68 
 69     public void test() throws Exception {
 70         boolean failed = false;
 71 
 72         try {
 73             checkVM(&quot;toto&quot;, ALL, JVM_CFG_ALL, ALL, JVM_CFG_ALL);
 74             failed = true;
 75             throw new Exception(&quot;Should have failed&quot;);
 76         } catch (Exception ex) {
 77             if (failed) {
 78                 throw ex;
 79             }
 80         }
 81 
 82         checkVM(&quot;all&quot;, ALL, JVM_CFG_ALL, ALL, JVM_CFG_ALL);
 83         checkVM(&quot;all&quot;, CLIENT, JVM_CFG_CLIENT, CLIENT, JVM_CFG_CLIENT);
 84         checkVM(&quot;all&quot;, SERVER, JVM_CFG_SERVER, SERVER, JVM_CFG_SERVER);
 85         checkVM(&quot;all&quot;, MINIMAL, JVM_CFG_MINIMAL, MINIMAL, JVM_CFG_MINIMAL);
 86 
 87         checkVM(&quot;server&quot;, ALL, JVM_CFG_ALL, SERVER, JVM_CFG_SERVER_ALIAS_OTHERS);
 88         checkVM(&quot;server&quot;, SERVER, JVM_CFG_SERVER, SERVER, JVM_CFG_SERVER);
 89         try {
 90             checkVM(&quot;server&quot;, CLIENT, JVM_CFG_CLIENT, SERVER, JVM_CFG_SERVER);
 91             failed = true;
 92             throw new Exception(&quot;Should have failed&quot;);
 93         } catch (Exception ex) {
 94             if (failed) {
 95                 throw ex;
 96             }
 97         }
 98         try {
 99             checkVM(&quot;server&quot;, MINIMAL, JVM_CFG_MINIMAL, SERVER, JVM_CFG_SERVER);
100             failed = true;
101             throw new Exception(&quot;Should have failed&quot;);
102         } catch (Exception ex) {
103             if (failed) {
104                 throw ex;
105             }
106         }
107 
108         checkVM(&quot;client&quot;, ALL, JVM_CFG_ALL, CLIENT, JVM_CFG_CLIENT_ALIAS_OTHERS);
109         checkVM(&quot;client&quot;, CLIENT, JVM_CFG_CLIENT, CLIENT, JVM_CFG_CLIENT);
110         try {
111             checkVM(&quot;client&quot;, SERVER, JVM_CFG_SERVER, CLIENT, JVM_CFG_CLIENT);
112             failed = true;
113             throw new Exception(&quot;Should have failed&quot;);
114         } catch (Exception ex) {
115             if (failed) {
116                 throw ex;
117             }
118         }
119         try {
120             checkVM(&quot;client&quot;, MINIMAL, JVM_CFG_MINIMAL, CLIENT, JVM_CFG_CLIENT);
121             failed = true;
122             throw new Exception(&quot;Should have failed&quot;);
123         } catch (Exception ex) {
124             if (failed) {
125                 throw ex;
126             }
127         }
128 
129         checkVM(&quot;minimal&quot;, ALL, JVM_CFG_ALL, MINIMAL, JVM_CFG_MINIMAL_ALIAS_OTHERS);
130         checkVM(&quot;minimal&quot;, MINIMAL, JVM_CFG_MINIMAL, MINIMAL, JVM_CFG_MINIMAL);
131         try {
132             checkVM(&quot;minimal&quot;, SERVER, JVM_CFG_SERVER, MINIMAL, JVM_CFG_MINIMAL);
133             failed = true;
134             throw new Exception(&quot;Should have failed&quot;);
135         } catch (Exception ex) {
136             if (failed) {
137                 throw ex;
138             }
139         }
140         try {
141             checkVM(&quot;minimal&quot;, CLIENT, JVM_CFG_CLIENT, MINIMAL, JVM_CFG_MINIMAL);
142             failed = true;
143             throw new Exception(&quot;Should have failed&quot;);
144         } catch (Exception ex) {
145             if (failed) {
146                 throw ex;
147             }
148         }
149 
150     }
151 
152     public void checkVM(String vm, String[] input, String jvmcfg, String[] expectedOutput, String expectdJvmCfg) throws Exception {
153 
154         for (String arch : ARCHITECTURES) {
155             String[] winput = new String[input.length];
156             String[] woutput = new String[expectedOutput.length];
157             for (int i = 0; i &lt; input.length; i++) {
158                 winput[i] = &quot;/java.base/lib&quot; + arch + input[i];
159             }
160             for (int i = 0; i &lt; expectedOutput.length; i++) {
161                 woutput[i] = &quot;/java.base/lib&quot; + arch + expectedOutput[i];
162             }
163             doCheckVM(vm, winput, jvmcfg, woutput, expectdJvmCfg);
164         }
165     }
166 
167     private void doCheckVM(String vm, String[] input, String jvmcfg, String[] expectedOutput, String expectdJvmCfg) throws Exception {
168         // Create a pool with jvm.cfg and the input paths.
169         byte[] jvmcfgContent = jvmcfg.getBytes();
170         ResourcePoolManager poolMgr = new ResourcePoolManager();
171         poolMgr.add(
172             ResourcePoolEntry.create(&quot;/java.base/lib/jvm.cfg&quot;,
173                 ResourcePoolEntry.Type.NATIVE_LIB, jvmcfgContent));
174 
175         // java.base/module-info.class is used by exclude vm plugin
176         // to get current osName(). We read it from jrt-fs and add a
177         // ResourcePoolEntry
178         poolMgr.add(
179             ResourcePoolEntry.create(&quot;/java.base/module-info.class&quot;,
180                 ResourcePoolEntry.Type.CLASS_OR_RESOURCE, getJavaBaseModuleInfo()));
181         for (String in : input) {
182             poolMgr.add(ResourcePoolEntry.create(in,
183                     ResourcePoolEntry.Type.NATIVE_LIB, new byte[0]));
184         }
185         ResourcePoolManager outMgr = new ResourcePoolManager();
186 
187         Plugin p = new ExcludeVMPlugin();
188         Map&lt;String, String&gt; config = new HashMap&lt;&gt;();
189         if (vm != null) {
190             config.put(ExcludeVMPlugin.NAME, vm);
191         }
192         p.configure(config);
193         ResourcePool out = p.transform(poolMgr.resourcePool(), outMgr.resourcePoolBuilder());
194 
195         String newContent = new String(out.findEntry(&quot;/java.base/lib/jvm.cfg&quot;).get().contentBytes());
196 
197         if (!expectdJvmCfg.equals(newContent)) {
198             throw new Exception(&quot;Got content &quot; + newContent + &quot; expected &quot; + expectdJvmCfg);
199         }
200 
201         // Apart from native resources, we should find jvm.cfg and
202         // java.base/module-info.class. So, we add 2 here to the
203         // expected count!
204         if (out.entryCount() != (expectedOutput.length + 2)) {
205             out.entries().forEach(m -&gt; {
206                 System.err.println(m.path());
207             });
208             throw new Exception(&quot;Invalid output size &quot; + out.entryCount() + &quot; expected &quot; + (expectedOutput.length + 2));
209         }
210 
211         out.entries().forEach(md -&gt; {
212             if (md.path().equals(&quot;/java.base/lib/jvm.cfg&quot;) ||
213                 md.path().equals(&quot;/java.base/module-info.class&quot;)) {
214                 return;
215             }
216             boolean contained = false;
217             for (String o : expectedOutput) {
218                 if (md.path().equals(o)) {
219                     contained = true;
220                     break;
221                 }
222             }
223             if (!contained) {
224                 throw new RuntimeException(md.path() + &quot; not expected&quot;);
225             }
226         });
227     }
228 
229     // read java.base/module-info.class from jrt-fs
230     private static Path getJavaBaseModuleInfo() {
231         return Paths.get(URI.create(&quot;jrt:/modules/java.base/module-info.class&quot;));
232     }
233 
234     private static boolean isWindows() {
235         return System.getProperty(&quot;os.name&quot;).startsWith(&quot;Windows&quot;);
236     }
237 
238     private static boolean isMac() {
239         return System.getProperty(&quot;os.name&quot;).startsWith(&quot;Mac OS&quot;);
240     }
241 
242     private static String jvmlib() {
243         String lib = &quot;libjvm.so&quot;;
244         if (isWindows()) {
245             lib = &quot;jvm.dll&quot;;
246         } else if (isMac()) {
247             lib = &quot;libjvm.dylib&quot;;
248         }
249         return lib;
250     }
251 }
    </pre>
  </body>
</html>
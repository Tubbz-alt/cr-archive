<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New test/jdk/tools/jpackage/helpers/jdk/jpackage/test/Executor.java</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 package jdk.jpackage.test;
 24 
 25 import java.io.BufferedReader;
 26 import java.io.ByteArrayOutputStream;
 27 import java.io.IOException;
 28 import java.io.InputStreamReader;
 29 import java.io.OutputStream;
 30 import java.io.PrintStream;
 31 import java.io.StringReader;
 32 import java.nio.file.Path;
 33 import java.util.*;
 34 import java.util.regex.Pattern;
 35 import java.util.spi.ToolProvider;
 36 import java.util.stream.Collectors;
 37 import java.util.stream.Stream;
 38 import jdk.jpackage.test.Functional.ThrowingSupplier;
 39 
 40 public final class Executor extends CommandArguments&lt;Executor&gt; {
 41 
 42     public static Executor of(String... cmdline) {
 43         return new Executor().setExecutable(cmdline[0]).addArguments(
 44                 Arrays.copyOfRange(cmdline, 1, cmdline.length));
 45     }
 46 
 47     public Executor() {
 48         saveOutputType = new HashSet&lt;&gt;(Set.of(SaveOutputType.NONE));
 49     }
 50 
 51     public Executor setExecutable(String v) {
 52         return setExecutable(Path.of(v));
 53     }
 54 
 55     public Executor setExecutable(Path v) {
 56         executable = Objects.requireNonNull(v);
 57         toolProvider = null;
 58         return this;
 59     }
 60 
 61     public Executor setToolProvider(ToolProvider v) {
 62         toolProvider = Objects.requireNonNull(v);
 63         executable = null;
 64         return this;
 65     }
 66 
 67     public Executor setToolProvider(JavaTool v) {
 68         return setToolProvider(v.asToolProvider());
 69     }
 70 
 71     public Executor setDirectory(Path v) {
 72         directory = v;
 73         return this;
 74     }
 75 
 76     public Executor setExecutable(JavaTool v) {
 77         return setExecutable(v.getPath());
 78     }
 79 
 80     /**
 81      * Configures this instance to save full output that command will produce.
 82      * This function is mutual exclusive with
 83      * saveFirstLineOfOutput() function.
 84      *
 85      * @return this
 86      */
 87     public Executor saveOutput() {
 88         saveOutputType.remove(SaveOutputType.FIRST_LINE);
 89         saveOutputType.add(SaveOutputType.FULL);
 90         return this;
 91     }
 92 
 93     /**
 94      * Configures how to save output that command will produce. If
 95      * &lt;code&gt;v&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;, the function call is equivalent to
 96      * &lt;code&gt;saveOutput()&lt;/code&gt; call. If &lt;code&gt;v&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;,
 97      * the function will result in not preserving command output.
 98      *
 99      * @return this
100      */
101     public Executor saveOutput(boolean v) {
102         if (v) {
103             saveOutput();
104         } else {
105             saveOutputType.remove(SaveOutputType.FIRST_LINE);
106             saveOutputType.remove(SaveOutputType.FULL);
107         }
108         return this;
109     }
110 
111     /**
112      * Configures this instance to save only the first line out output that
113      * command will produce. This function is mutual exclusive with
114      * saveOutput() function.
115      *
116      * @return this
117      */
118     public Executor saveFirstLineOfOutput() {
119         saveOutputType.add(SaveOutputType.FIRST_LINE);
120         saveOutputType.remove(SaveOutputType.FULL);
121         return this;
122     }
123 
124     /**
125      * Configures this instance to dump all output that command will produce to
126      * System.out and System.err. Can be used together with saveOutput() and
127      * saveFirstLineOfOutput() to save command output and also copy it in the
128      * default output streams.
129      *
130      * @return this
131      */
132     public Executor dumpOutput() {
133         return dumpOutput(true);
134     }
135 
136     public Executor dumpOutput(boolean v) {
137         if (v) {
138             saveOutputType.add(SaveOutputType.DUMP);
139         } else {
140             saveOutputType.remove(SaveOutputType.DUMP);
141         }
142         return this;
143     }
144 
145     public class Result {
146 
147         Result(int exitCode) {
148             this.exitCode = exitCode;
149         }
150 
151         public String getFirstLineOfOutput() {
152             return output.get(0);
153         }
154 
155         public List&lt;String&gt; getOutput() {
156             return output;
157         }
158 
159         public String getPrintableCommandLine() {
160             return Executor.this.getPrintableCommandLine();
161         }
162 
163         public Result assertExitCodeIs(int expectedExitCode) {
164             TKit.assertEquals(expectedExitCode, exitCode, String.format(
165                     &quot;Check command %s exited with %d code&quot;,
166                     getPrintableCommandLine(), expectedExitCode));
167             return this;
168         }
169 
170         public Result assertExitCodeIsZero() {
171             return assertExitCodeIs(0);
172         }
173 
174         final int exitCode;
175         private List&lt;String&gt; output;
176     }
177 
178     public Result executeWithoutExitCodeCheck() {
179         if (toolProvider != null &amp;&amp; directory != null) {
180             throw new IllegalArgumentException(
181                     &quot;Can&#39;t change directory when using tool provider&quot;);
182         }
183 
184         return ThrowingSupplier.toSupplier(() -&gt; {
185             if (toolProvider != null) {
186                 return runToolProvider();
187             }
188 
189             if (executable != null) {
190                 return runExecutable();
191             }
192 
193             throw new IllegalStateException(&quot;No command to execute&quot;);
194         }).get();
195     }
196 
197     public Result execute(int expectedCode) {
198         return executeWithoutExitCodeCheck().assertExitCodeIs(expectedCode);
199     }
200 
201     public Result execute() {
202         return execute(0);
203     }
204 
205     public String executeAndGetFirstLineOfOutput() {
206         return saveFirstLineOfOutput().execute().getFirstLineOfOutput();
207     }
208 
209     public List&lt;String&gt; executeAndGetOutput() {
210         return saveOutput().execute().getOutput();
211     }
212 
213     private boolean withSavedOutput() {
214         return saveOutputType.contains(SaveOutputType.FULL) || saveOutputType.contains(
215                 SaveOutputType.FIRST_LINE);
216     }
217 
218     private Path executablePath() {
219         if (directory == null
220                 || executable.isAbsolute()
221                 || !Set.of(&quot;.&quot;, &quot;..&quot;).contains(executable.getName(0).toString())) {
222             return executable;
223         }
224 
225         // If relative path to executable is used it seems to be broken when
226         // ProcessBuilder changes the directory. On Windows it changes the
227         // directory first and on Linux it looks up for executable before
228         // changing the directory. So to stay of safe side, use absolute path
229         // to executable.
230         return executable.toAbsolutePath();
231     }
232 
233     private Result runExecutable() throws IOException, InterruptedException {
234         List&lt;String&gt; command = new ArrayList&lt;&gt;();
235         command.add(executablePath().toString());
236         command.addAll(args);
237         ProcessBuilder builder = new ProcessBuilder(command);
238         StringBuilder sb = new StringBuilder(getPrintableCommandLine());
239         if (withSavedOutput()) {
240             builder.redirectErrorStream(true);
241             sb.append(&quot;; save output&quot;);
242         } else if (saveOutputType.contains(SaveOutputType.DUMP)) {
243             builder.inheritIO();
244             sb.append(&quot;; inherit I/O&quot;);
245         } else {
246             builder.redirectError(ProcessBuilder.Redirect.DISCARD);
247             builder.redirectOutput(ProcessBuilder.Redirect.DISCARD);
248             sb.append(&quot;; discard I/O&quot;);
249         }
250         if (directory != null) {
251             builder.directory(directory.toFile());
252             sb.append(String.format(&quot;; in directory [%s]&quot;, directory));
253         }
254 
255         trace(&quot;Execute &quot; + sb.toString() + &quot;...&quot;);
256         Process process = builder.start();
257 
258         List&lt;String&gt; outputLines = null;
259         if (withSavedOutput()) {
260             try (BufferedReader outReader = new BufferedReader(
261                     new InputStreamReader(process.getInputStream()))) {
262                 if (saveOutputType.contains(SaveOutputType.DUMP)
263                         || saveOutputType.contains(SaveOutputType.FULL)) {
264                     outputLines = outReader.lines().collect(Collectors.toList());
265                 } else {
266                     outputLines = Arrays.asList(
267                             outReader.lines().findFirst().orElse(null));
268                 }
269             } finally {
270                 if (saveOutputType.contains(SaveOutputType.DUMP) &amp;&amp; outputLines != null) {
271                     outputLines.stream().forEach(System.out::println);
272                     if (saveOutputType.contains(SaveOutputType.FIRST_LINE)) {
273                         // Pick the first line of saved output if there is one
274                         for (String line: outputLines) {
275                             outputLines = List.of(line);
276                             break;
277                         }
278                     }
279                 }
280             }
281         }
282 
283         Result reply = new Result(process.waitFor());
284         trace(&quot;Done. Exit code: &quot; + reply.exitCode);
285 
286         if (outputLines != null) {
287             reply.output = Collections.unmodifiableList(outputLines);
288         }
289         return reply;
290     }
291 
292     private Result runToolProvider(PrintStream out, PrintStream err) {
293         trace(&quot;Execute &quot; + getPrintableCommandLine() + &quot;...&quot;);
294         Result reply = new Result(toolProvider.run(out, err, args.toArray(
295                 String[]::new)));
296         trace(&quot;Done. Exit code: &quot; + reply.exitCode);
297         return reply;
298     }
299 
300 
301     private Result runToolProvider() throws IOException {
302         if (!withSavedOutput()) {
303             if (saveOutputType.contains(SaveOutputType.DUMP)) {
304                 return runToolProvider(System.out, System.err);
305             }
306 
307             PrintStream nullPrintStream = new PrintStream(new OutputStream() {
308                 @Override
309                 public void write(int b) {
310                     // Nop
311                 }
312             });
313             return runToolProvider(nullPrintStream, nullPrintStream);
314         }
315 
316         try (ByteArrayOutputStream buf = new ByteArrayOutputStream();
317                 PrintStream ps = new PrintStream(buf)) {
318             Result reply = runToolProvider(ps, ps);
319             ps.flush();
320             try (BufferedReader bufReader = new BufferedReader(new StringReader(
321                     buf.toString()))) {
322                 if (saveOutputType.contains(SaveOutputType.FIRST_LINE)) {
323                     String firstLine = bufReader.lines().findFirst().orElse(null);
324                     if (firstLine != null) {
325                         reply.output = List.of(firstLine);
326                     }
327                 } else if (saveOutputType.contains(SaveOutputType.FULL)) {
328                     reply.output = bufReader.lines().collect(
329                             Collectors.toUnmodifiableList());
330                 }
331 
332                 if (saveOutputType.contains(SaveOutputType.DUMP)) {
333                     Stream&lt;String&gt; lines;
334                     if (saveOutputType.contains(SaveOutputType.FULL)) {
335                         lines = reply.output.stream();
336                     } else {
337                         lines = bufReader.lines();
338                     }
339                     lines.forEach(System.out::println);
340                 }
341             }
342             return reply;
343         }
344     }
345 
346     public String getPrintableCommandLine() {
347         final String exec;
348         String format = &quot;[%s](%d)&quot;;
349         if (toolProvider == null &amp;&amp; executable == null) {
350             exec = &quot;&lt;null&gt;&quot;;
351         } else if (toolProvider != null) {
352             format = &quot;tool provider &quot; + format;
353             exec = toolProvider.name();
354         } else {
355             exec = executablePath().toString();
356         }
357 
358         return String.format(format, printCommandLine(exec, args),
359                 args.size() + 1);
360     }
361 
362     private static String printCommandLine(String executable, List&lt;String&gt; args) {
363         // Want command line printed in a way it can be easily copy/pasted
364         // to be executed manally
365         Pattern regex = Pattern.compile(&quot;\\s&quot;);
366         return Stream.concat(Stream.of(executable), args.stream()).map(
367                 v -&gt; (v.isEmpty() || regex.matcher(v).find()) ? &quot;\&quot;&quot; + v + &quot;\&quot;&quot; : v).collect(
368                         Collectors.joining(&quot; &quot;));
369     }
370 
371     private static void trace(String msg) {
372         TKit.trace(String.format(&quot;exec: %s&quot;, msg));
373     }
374 
375     private ToolProvider toolProvider;
376     private Path executable;
377     private Set&lt;SaveOutputType&gt; saveOutputType;
378     private Path directory;
379 
380     private static enum SaveOutputType {
381         NONE, FULL, FIRST_LINE, DUMP
382     };
383 }
    </pre>
  </body>
</html>
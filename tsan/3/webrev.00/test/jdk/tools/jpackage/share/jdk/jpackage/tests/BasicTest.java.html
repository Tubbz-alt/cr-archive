<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New test/jdk/tools/jpackage/share/jdk/jpackage/tests/BasicTest.java</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 package jdk.jpackage.tests;
 25 
 26 import java.io.IOException;
 27 import java.nio.file.Files;
 28 import java.nio.file.Path;
 29 import java.util.List;
 30 import java.util.ArrayList;
 31 import java.util.function.Function;
 32 import java.util.function.Predicate;
 33 import java.util.function.Supplier;
 34 import java.util.regex.Pattern;
 35 import java.util.stream.Collectors;
 36 import java.util.stream.Stream;
 37 import jdk.jpackage.test.*;
 38 import jdk.jpackage.test.Functional.ThrowingConsumer;
 39 import jdk.jpackage.test.Annotations.*;
 40 
 41 /*
 42  * @test
 43  * @summary jpackage basic testing
 44  * @library ../../../../helpers
 45  * @build jdk.jpackage.test.*
 46  * @modules jdk.incubator.jpackage/jdk.incubator.jpackage.internal
 47  * @compile BasicTest.java
 48  * @run main/othervm/timeout=720 -Xmx512m jdk.jpackage.test.Main
 49  *  --jpt-run=jdk.jpackage.tests.BasicTest
 50  */
 51 
 52 public final class BasicTest {
 53     @Test
 54     public void testNoArgs() {
 55         List&lt;String&gt; output =
 56                 getJPackageToolProvider().executeAndGetOutput();
 57         TKit.assertStringListEquals(List.of(&quot;Usage: jpackage &lt;options&gt;&quot;,
 58                 &quot;Use jpackage --help (or -h) for a list of possible options&quot;),
 59                 output, &quot;Check jpackage output&quot;);
 60     }
 61 
 62     @Test
 63     public void testVersion() {
 64         List&lt;String&gt; output =
 65                 getJPackageToolProvider()
 66                         .addArgument(&quot;--version&quot;)
 67                         .executeAndGetOutput();
 68         TKit.assertStringListEquals(List.of(System.getProperty(&quot;java.version&quot;)),
 69                 output, &quot;Check jpackage output&quot;);
 70     }
 71 
 72     @Test
 73     public void testHelp() {
 74         List&lt;String&gt; hOutput = getJPackageToolProvider()
 75                 .addArgument(&quot;-h&quot;).executeAndGetOutput();
 76         List&lt;String&gt; helpOutput = getJPackageToolProvider()
 77                 .addArgument(&quot;--help&quot;).executeAndGetOutput();
 78 
 79         TKit.assertStringListEquals(hOutput, helpOutput,
 80                 &quot;Check -h and --help parameters produce the same output&quot;);
 81 
 82         final String windowsPrefix = &quot;--win-&quot;;
 83         final String linuxPrefix = &quot;--linux-&quot;;
 84         final String osxPrefix = &quot;--mac-&quot;;
 85 
 86         final String expectedPrefix;
 87         final List&lt;String&gt; unexpectedPrefixes;
 88 
 89         if (TKit.isWindows()) {
 90             expectedPrefix = windowsPrefix;
 91             unexpectedPrefixes = List.of(osxPrefix, linuxPrefix);
 92         } else if (TKit.isLinux()) {
 93             expectedPrefix = linuxPrefix;
 94             unexpectedPrefixes = List.of(windowsPrefix, osxPrefix);
 95         } else if (TKit.isOSX()) {
 96             expectedPrefix = osxPrefix;
 97             unexpectedPrefixes = List.of(linuxPrefix,  windowsPrefix);
 98         } else {
 99             throw TKit.throwUnknownPlatformError();
100         }
101 
102         Function&lt;String, Predicate&lt;String&gt;&gt; createPattern = (prefix) -&gt; {
103             return Pattern.compile(&quot;^  &quot; + prefix).asPredicate();
104         };
105 
106         Function&lt;List&lt;String&gt;, Long&gt; countStrings = (prefixes) -&gt; {
107             return hOutput.stream().filter(
108                     prefixes.stream().map(createPattern).reduce(x -&gt; false,
109                             Predicate::or)).peek(TKit::trace).count();
110         };
111 
112         TKit.trace(&quot;Check parameters in help text&quot;);
113         TKit.assertNotEquals(0, countStrings.apply(List.of(expectedPrefix)),
114                 &quot;Check help text contains plaform specific parameters&quot;);
115         TKit.assertEquals(0, countStrings.apply(unexpectedPrefixes),
116                 &quot;Check help text doesn&#39;t contain unexpected parameters&quot;);
117     }
118 
119     @Test
120     @SuppressWarnings(&quot;unchecked&quot;)
121     public void testVerbose() {
122         JPackageCommand cmd = JPackageCommand.helloAppImage()
123                 // Disable default logic adding `--verbose` option
124                 // to jpackage command line.
125                 .ignoreDefaultVerbose(true)
126                 .saveConsoleOutput(true)
127                 .setFakeRuntime().executePrerequisiteActions();
128 
129         List&lt;String&gt; expectedVerboseOutputStrings = new ArrayList&lt;&gt;();
130         expectedVerboseOutputStrings.add(&quot;Creating app package:&quot;);
131         if (TKit.isWindows()) {
132             expectedVerboseOutputStrings.add(&quot;Result application bundle:&quot;);
133             expectedVerboseOutputStrings.add(
134                     &quot;Succeeded in building Windows Application Image package&quot;);
135         } else if (TKit.isLinux()) {
136             expectedVerboseOutputStrings.add(
137                     &quot;Succeeded in building Linux Application Image package&quot;);
138         } else if (TKit.isOSX()) {
139             expectedVerboseOutputStrings.add(&quot;Preparing Info.plist:&quot;);
140             expectedVerboseOutputStrings.add(
141                     &quot;Succeeded in building Mac Application Image package&quot;);
142         } else {
143             TKit.throwUnknownPlatformError();
144         }
145 
146         TKit.deleteDirectoryContentsRecursive(cmd.outputDir());
147         List&lt;String&gt; nonVerboseOutput = cmd.execute().getOutput();
148         List&lt;String&gt;[] verboseOutput = (List&lt;String&gt;[])new List&lt;?&gt;[1];
149 
150         // Directory clean up is not 100% reliable on Windows because of
151         // antivirus software that can lock .exe files. Setup
152         // different output directory instead of cleaning the default one for
153         // verbose jpackage run.
154         TKit.withTempDirectory(&quot;verbose-output&quot;, tempDir -&gt; {
155             cmd.setArgumentValue(&quot;--dest&quot;, tempDir);
156             cmd.addArgument(&quot;--verbose&quot;);
157             verboseOutput[0] = cmd.execute().getOutput();
158         });
159 
160         TKit.assertTrue(nonVerboseOutput.size() &lt; verboseOutput[0].size(),
161                 &quot;Check verbose output is longer than regular&quot;);
162 
163         expectedVerboseOutputStrings.forEach(str -&gt; {
164             TKit.assertTextStream(str).label(&quot;regular output&quot;)
165                     .predicate(String::contains).negate()
166                     .apply(nonVerboseOutput.stream());
167         });
168 
169         expectedVerboseOutputStrings.forEach(str -&gt; {
170             TKit.assertTextStream(str).label(&quot;verbose output&quot;)
171                     .apply(verboseOutput[0].stream());
172         });
173     }
174 
175     @Test
176     public void testNoName() {
177         final String mainClassName = &quot;Greetings&quot;;
178 
179         JPackageCommand cmd = JPackageCommand.helloAppImage(mainClassName)
180                 .removeArgumentWithValue(&quot;--name&quot;);
181 
182         Path expectedImageDir = cmd.outputDir().resolve(mainClassName);
183         if (TKit.isOSX()) {
184             expectedImageDir = expectedImageDir.getParent().resolve(
185                     expectedImageDir.getFileName().toString() + &quot;.app&quot;);
186         }
187 
188         cmd.executeAndAssertHelloAppImageCreated();
189         TKit.assertEquals(expectedImageDir.toAbsolutePath().normalize().toString(),
190                 cmd.outputBundle().toAbsolutePath().normalize().toString(),
191                 String.format(
192                         &quot;Check [%s] directory is filled with application image data&quot;,
193                         expectedImageDir));
194     }
195 
196     @Test
197     // Regular app
198     @Parameter(&quot;Hello&quot;)
199     // Modular app in .jar file
200     @Parameter(&quot;com.other/com.other.Hello&quot;)
201     // Modular app in .jmod file
202     @Parameter(&quot;hello.jmod:com.other/com.other.Hello&quot;)
203     public void testApp(String javaAppDesc) {
204         JavaAppDesc appDesc = JavaAppDesc.parse(javaAppDesc);
205         JPackageCommand cmd = JPackageCommand.helloAppImage(appDesc);
206         if (appDesc.jmodFileName() != null) {
207             // .jmod files are not supported at run-time. They should be
208             // bundled in Java run-time with jlink command, so disable
209             // use of external Java run-time if any configured.
210             cmd.ignoreDefaultRuntime(true);
211         }
212         cmd.executeAndAssertHelloAppImageCreated();
213     }
214 
215     @Test
216     public void testWhitespaceInPaths() {
217         JPackageCommand.helloAppImage(&quot;a/b c.jar:Hello&quot;)
218         .setArgumentValue(&quot;--input&quot;, TKit.workDir().resolve(&quot;The quick brown fox&quot;))
219         .setArgumentValue(&quot;--dest&quot;, TKit.workDir().resolve(&quot;jumps over the lazy dog&quot;))
220         .executeAndAssertHelloAppImageCreated();
221     }
222 
223     @Test
224     @Parameter(&quot;ALL-MODULE-PATH&quot;)
225     @Parameter(&quot;ALL-DEFAULT&quot;)
226     @Parameter(&quot;java.desktop&quot;)
227     @Parameter(&quot;java.desktop,jdk.jartool&quot;)
228     @Parameter({ &quot;java.desktop&quot;, &quot;jdk.jartool&quot; })
229     public void testAddModules(String... addModulesArg) {
230         JPackageCommand cmd = JPackageCommand
231                 .helloAppImage(&quot;goodbye.jar:com.other/com.other.Hello&quot;);
232         Stream.of(addModulesArg).map(v -&gt; Stream.of(&quot;--add-modules&quot;, v)).flatMap(
233                 s -&gt; s).forEachOrdered(cmd::addArgument);
234         cmd.executeAndAssertHelloAppImageCreated();
235     }
236 
237     /**
238      * Test --temp option. Doesn&#39;t make much sense for app image as temporary
239      * directory is used only on Windows. Test it in packaging mode.
240      * @throws IOException
241      */
242     @Test
243     public void testTemp() throws IOException {
244         final Path tempRoot = TKit.createTempDirectory(&quot;temp-root&quot;);
245 
246         Function&lt;JPackageCommand, Path&gt; getTempDir = cmd -&gt; {
247             return tempRoot.resolve(cmd.outputBundle().getFileName());
248         };
249 
250         Supplier&lt;PackageTest&gt; createTest = () -&gt; {
251             return new PackageTest()
252             .configureHelloApp()
253             // Force save of package bundle in test work directory.
254             .addInitializer(JPackageCommand::setDefaultInputOutput)
255             .addInitializer(cmd -&gt; {
256                 Path tempDir = getTempDir.apply(cmd);
257                 Files.createDirectories(tempDir);
258                 cmd.addArguments(&quot;--temp&quot;, tempDir);
259             });
260         };
261 
262         createTest.get()
263         .addBundleVerifier(cmd -&gt; {
264             // Check jpackage actually used the supplied directory.
265             Path tempDir = getTempDir.apply(cmd);
266             TKit.assertNotEquals(0, tempDir.toFile().list().length,
267                     String.format(
268                             &quot;Check jpackage wrote some data in the supplied temporary directory [%s]&quot;,
269                             tempDir));
270         })
271         .run(PackageTest.Action.CREATE);
272 
273         createTest.get()
274         .addInitializer(cmd -&gt; {
275             // Clean output from the previus jpackage run.
276             Files.delete(cmd.outputBundle());
277         })
278         // Temporary directory should not be empty,
279         // jpackage should exit with error.
280         .setExpectedExitCode(1)
281         .run(PackageTest.Action.CREATE);
282     }
283 
284     @Test
285     public void testAtFile() throws IOException {
286         JPackageCommand cmd = JPackageCommand
287                 .helloAppImage()
288                 .setArgumentValue(&quot;--dest&quot;, TKit.createTempDirectory(&quot;output&quot;));
289 
290         // Init options file with the list of options configured
291         // for JPackageCommand instance.
292         final Path optionsFile = TKit.createTempFile(Path.of(&quot;options&quot;));
293         Files.write(optionsFile,
294                 List.of(String.join(&quot; &quot;, cmd.getAllArguments())));
295 
296         // Build app jar file.
297         cmd.executePrerequisiteActions();
298 
299         // Instead of running jpackage command through configured
300         // JPackageCommand instance, run vanilla jpackage command with @ file.
301         getJPackageToolProvider()
302                 .addArgument(String.format(&quot;@%s&quot;, optionsFile))
303                 .execute();
304 
305         // Verify output of jpackage command.
306         cmd.assertImageCreated();
307         HelloApp.executeLauncherAndVerifyOutput(cmd);
308     }
309 
310     @Parameter(&quot;Hello&quot;)
311     @Parameter(&quot;com.foo/com.foo.main.Aloha&quot;)
312     @Test
313     public void testJLinkRuntime(String javaAppDesc) throws IOException {
314         JavaAppDesc appDesc = JavaAppDesc.parse(javaAppDesc);
315 
316         JPackageCommand cmd = JPackageCommand.helloAppImage(appDesc);
317 
318         final String moduleName = appDesc.moduleName();
319 
320         if (moduleName != null) {
321             // Build module jar.
322             cmd.executePrerequisiteActions();
323         }
324 
325         final Path runtimeDir = TKit.createTempDirectory(&quot;runtime&quot;).resolve(&quot;data&quot;);
326 
327         // List of modules required for test app.
328         final var modules = new String[] {
329             &quot;java.base&quot;,
330             &quot;java.desktop&quot;
331         };
332 
333         Executor jlink = getToolProvider(JavaTool.JLINK)
334         .saveOutput(false)
335         .addArguments(
336                 &quot;--add-modules&quot;, String.join(&quot;,&quot;, modules),
337                 &quot;--output&quot;, runtimeDir.toString(),
338                 &quot;--strip-debug&quot;,
339                 &quot;--no-header-files&quot;,
340                 &quot;--no-man-pages&quot;);
341 
342         if (moduleName != null) {
343             jlink.addArguments(&quot;--add-modules&quot;, moduleName, &quot;--module-path&quot;,
344                     Path.of(cmd.getArgumentValue(&quot;--module-path&quot;)).resolve(
345                             &quot;hello.jar&quot;).toString());
346         }
347 
348         jlink.execute();
349 
350         cmd.addArguments(&quot;--runtime-image&quot;, runtimeDir);
351         cmd.executeAndAssertHelloAppImageCreated();
352     }
353 
354     private static Executor getJPackageToolProvider() {
355         return getToolProvider(JavaTool.JPACKAGE);
356     }
357 
358     private static Executor getToolProvider(JavaTool tool) {
359         return new Executor().dumpOutput().saveOutput().setToolProvider(tool);
360     }
361 }
    </pre>
  </body>
</html>
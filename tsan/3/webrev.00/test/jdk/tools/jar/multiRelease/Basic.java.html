<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New test/jdk/tools/jar/multiRelease/Basic.java</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2016, 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 /*
 25  * @test
 26  # @bug 8186087 8196748 8212807
 27  * @library /test/lib
 28  * @modules java.base/jdk.internal.misc
 29  *          jdk.compiler
 30  *          jdk.jartool
 31  * @build jdk.test.lib.util.FileUtils
 32  *        jdk.test.lib.Utils
 33  *        jdk.test.lib.Asserts
 34  *        jdk.test.lib.JDKToolFinder
 35  *        jdk.test.lib.JDKToolLauncher
 36  *        jdk.test.lib.Platform
 37  *        jdk.test.lib.process.*
 38  *        MRTestBase
 39  * @run testng Basic
 40  */
 41 
 42 import jdk.test.lib.util.FileUtils;
 43 import org.testng.annotations.*;
 44 
 45 import java.io.File;
 46 import java.nio.file.Files;
 47 import java.nio.file.Path;
 48 import java.nio.file.Paths;
 49 import java.util.List;
 50 import java.util.Map;
 51 import java.util.jar.JarFile;
 52 import java.util.zip.ZipFile;
 53 
 54 import static org.testng.Assert.*;
 55 
 56 public class Basic extends MRTestBase {
 57 
 58     @Test
 59     // create a regular, non-multi-release jar
 60     public void test00() throws Throwable {
 61         String jarfile = &quot;test.jar&quot;;
 62 
 63         compile(&quot;test01&quot;);  //use same data as test01
 64 
 65         Path classes = Paths.get(&quot;classes&quot;);
 66         jarTool(&quot;cf&quot;, jarfile, &quot;-C&quot;, classes.resolve(&quot;base&quot;).toString(), &quot;.&quot;)
 67                 .shouldHaveExitValue(SUCCESS);
 68 
 69         checkMultiRelease(jarfile, false);
 70 
 71         Map&lt;String, String[]&gt; names = Map.of(
 72                 &quot;version/Main.class&quot;,
 73                 new String[]{&quot;base&quot;, &quot;version&quot;, &quot;Main.class&quot;},
 74 
 75                 &quot;version/Version.class&quot;,
 76                 new String[]{&quot;base&quot;, &quot;version&quot;, &quot;Version.class&quot;}
 77         );
 78 
 79         compare(jarfile, names);
 80 
 81         FileUtils.deleteFileIfExistsWithRetry(Paths.get(jarfile));
 82         FileUtils.deleteFileTreeWithRetry(Paths.get(usr, &quot;classes&quot;));
 83     }
 84 
 85     @Test
 86     // create a multi-release jar
 87     public void test01() throws Throwable {
 88         String jarfile = &quot;test.jar&quot;;
 89 
 90         compile(&quot;test01&quot;);
 91 
 92         Path classes = Paths.get(&quot;classes&quot;);
 93         jarTool(&quot;cf&quot;, jarfile, &quot;-C&quot;, classes.resolve(&quot;base&quot;).toString(), &quot;.&quot;,
 94                 &quot;--release&quot;, &quot;9&quot;, &quot;-C&quot;, classes.resolve(&quot;v9&quot;).toString(), &quot;.&quot;,
 95                 &quot;--release&quot;, &quot;10&quot;, &quot;-C&quot;, classes.resolve(&quot;v10&quot;).toString(), &quot;.&quot;)
 96                 .shouldHaveExitValue(SUCCESS);
 97 
 98         checkMultiRelease(jarfile, true);
 99 
100         Map&lt;String, String[]&gt; names = Map.of(
101                 &quot;version/Main.class&quot;,
102                 new String[]{&quot;base&quot;, &quot;version&quot;, &quot;Main.class&quot;},
103 
104                 &quot;version/Version.class&quot;,
105                 new String[]{&quot;base&quot;, &quot;version&quot;, &quot;Version.class&quot;},
106 
107                 &quot;META-INF/versions/9/version/Version.class&quot;,
108                 new String[]{&quot;v9&quot;, &quot;version&quot;, &quot;Version.class&quot;},
109 
110                 &quot;META-INF/versions/10/version/Version.class&quot;,
111                 new String[]{&quot;v10&quot;, &quot;version&quot;, &quot;Version.class&quot;}
112         );
113 
114         compare(jarfile, names);
115 
116         FileUtils.deleteFileIfExistsWithRetry(Paths.get(jarfile));
117         FileUtils.deleteFileTreeWithRetry(Paths.get(usr, &quot;classes&quot;));
118     }
119 
120     @Test
121     public void versionFormat() throws Throwable {
122         String jarfile = &quot;test.jar&quot;;
123 
124         compile(&quot;test01&quot;);
125 
126         Path classes = Paths.get(&quot;classes&quot;);
127 
128         // valid
129         for (String release : List.of(&quot;10000&quot;, &quot;09&quot;, &quot;00010&quot;, &quot;10&quot;)) {
130             jarTool(&quot;cf&quot;, jarfile, &quot;-C&quot;, classes.resolve(&quot;base&quot;).toString(), &quot;.&quot;,
131                     &quot;--release&quot;, release, &quot;-C&quot;, classes.resolve(&quot;v10&quot;).toString(), &quot;.&quot;)
132                     .shouldHaveExitValue(SUCCESS)
133                     .shouldBeEmptyIgnoreVMWarnings();
134         }
135         // invalid
136         for (String release : List.of(&quot;9.0&quot;, &quot;8&quot;, &quot;v9&quot;,
137                 &quot;9v&quot;, &quot;0&quot;, &quot;-10&quot;)) {
138             jarTool(&quot;cf&quot;, jarfile, &quot;-C&quot;, classes.resolve(&quot;base&quot;).toString(), &quot;.&quot;,
139                     &quot;--release&quot;, release, &quot;-C&quot;, classes.resolve(&quot;v10&quot;).toString(), &quot;.&quot;)
140                     .shouldNotHaveExitValue(SUCCESS)
141                     .shouldContain(&quot;release &quot; + release + &quot; not valid&quot;);
142         }
143         FileUtils.deleteFileIfExistsWithRetry(Paths.get(jarfile));
144         FileUtils.deleteFileTreeWithRetry(Paths.get(usr, &quot;classes&quot;));
145     }
146 
147     @Test
148     // update a regular jar to a multi-release jar
149     public void test02() throws Throwable {
150         String jarfile = &quot;test.jar&quot;;
151 
152         compile(&quot;test01&quot;);  //use same data as test01
153 
154         Path classes = Paths.get(&quot;classes&quot;);
155         jarTool(&quot;cf&quot;, jarfile, &quot;-C&quot;, classes.resolve(&quot;base&quot;).toString(), &quot;.&quot;)
156                 .shouldHaveExitValue(SUCCESS);
157 
158         checkMultiRelease(jarfile, false);
159 
160         jarTool(&quot;uf&quot;, jarfile,
161                 &quot;--release&quot;, &quot;9&quot;, &quot;-C&quot;, classes.resolve(&quot;v9&quot;).toString(), &quot;.&quot;)
162                 .shouldHaveExitValue(SUCCESS);
163 
164         checkMultiRelease(jarfile, true);
165 
166         Map&lt;String, String[]&gt; names = Map.of(
167                 &quot;version/Main.class&quot;,
168                 new String[]{&quot;base&quot;, &quot;version&quot;, &quot;Main.class&quot;},
169 
170                 &quot;version/Version.class&quot;,
171                 new String[]{&quot;base&quot;, &quot;version&quot;, &quot;Version.class&quot;},
172 
173                 &quot;META-INF/versions/9/version/Version.class&quot;,
174                 new String[]{&quot;v9&quot;, &quot;version&quot;, &quot;Version.class&quot;}
175         );
176 
177         compare(jarfile, names);
178 
179         FileUtils.deleteFileIfExistsWithRetry(Paths.get(jarfile));
180         FileUtils.deleteFileTreeWithRetry(Paths.get(usr, &quot;classes&quot;));
181     }
182 
183     @Test
184     // replace a base entry and a versioned entry
185     public void test03() throws Throwable {
186         String jarfile = &quot;test.jar&quot;;
187 
188         compile(&quot;test01&quot;);  //use same data as test01
189 
190         Path classes = Paths.get(&quot;classes&quot;);
191         jarTool(&quot;cf&quot;, jarfile, &quot;-C&quot;, classes.resolve(&quot;base&quot;).toString(), &quot;.&quot;,
192                 &quot;--release&quot;, &quot;9&quot;, &quot;-C&quot;, classes.resolve(&quot;v9&quot;).toString(), &quot;.&quot;)
193                 .shouldHaveExitValue(SUCCESS);
194 
195         checkMultiRelease(jarfile, true);
196 
197         Map&lt;String, String[]&gt; names = Map.of(
198                 &quot;version/Main.class&quot;,
199                 new String[]{&quot;base&quot;, &quot;version&quot;, &quot;Main.class&quot;},
200 
201                 &quot;version/Version.class&quot;,
202                 new String[]{&quot;base&quot;, &quot;version&quot;, &quot;Version.class&quot;},
203 
204                 &quot;META-INF/versions/9/version/Version.class&quot;,
205                 new String[]{&quot;v9&quot;, &quot;version&quot;, &quot;Version.class&quot;}
206         );
207 
208         compare(jarfile, names);
209 
210         // write the v9 version/Version.class entry in base and the v10
211         // version/Version.class entry in versions/9 section
212         jarTool(&quot;uf&quot;, jarfile, &quot;-C&quot;, classes.resolve(&quot;v9&quot;).toString(), &quot;version&quot;,
213                 &quot;--release&quot;, &quot;9&quot;, &quot;-C&quot;, classes.resolve(&quot;v10&quot;).toString(), &quot;.&quot;)
214                 .shouldHaveExitValue(SUCCESS);
215 
216         checkMultiRelease(jarfile, true);
217 
218         names = Map.of(
219                 &quot;version/Main.class&quot;,
220                 new String[]{&quot;base&quot;, &quot;version&quot;, &quot;Main.class&quot;},
221 
222                 &quot;version/Version.class&quot;,
223                 new String[]{&quot;v9&quot;, &quot;version&quot;, &quot;Version.class&quot;},
224 
225                 &quot;META-INF/versions/9/version/Version.class&quot;,
226                 new String[]{&quot;v10&quot;, &quot;version&quot;, &quot;Version.class&quot;}
227         );
228 
229         compare(jarfile, names);
230 
231         FileUtils.deleteFileIfExistsWithRetry(Paths.get(jarfile));
232         FileUtils.deleteFileTreeWithRetry(Paths.get(usr, &quot;classes&quot;));
233     }
234 
235     /*
236      * The following tests exercise the jar validator
237      */
238 
239     @Test
240     // META-INF/versions/9 class has different api than base class
241     public void test04() throws Throwable {
242         String jarfile = &quot;test.jar&quot;;
243 
244         compile(&quot;test01&quot;);  //use same data as test01
245 
246         Path classes = Paths.get(&quot;classes&quot;);
247 
248         // replace the v9 class
249         Path source = Paths.get(src, &quot;data&quot;, &quot;test04&quot;, &quot;v9&quot;, &quot;version&quot;);
250         javac(classes.resolve(&quot;v9&quot;), source.resolve(&quot;Version.java&quot;));
251 
252         jarTool(&quot;cf&quot;, jarfile, &quot;-C&quot;, classes.resolve(&quot;base&quot;).toString(), &quot;.&quot;,
253                 &quot;--release&quot;, &quot;9&quot;, &quot;-C&quot;, classes.resolve(&quot;v9&quot;).toString(), &quot;.&quot;)
254                 .shouldNotHaveExitValue(SUCCESS)
255                 .shouldContain(&quot;different api from earlier&quot;);
256 
257         FileUtils.deleteFileIfExistsWithRetry(Paths.get(jarfile));
258         FileUtils.deleteFileTreeWithRetry(Paths.get(usr, &quot;classes&quot;));
259     }
260 
261     @Test
262     // META-INF/versions/9 contains an extra public class
263     public void test05() throws Throwable {
264         String jarfile = &quot;test.jar&quot;;
265 
266         compile(&quot;test01&quot;);  //use same data as test01
267 
268         Path classes = Paths.get(&quot;classes&quot;);
269 
270         // add the new v9 class
271         Path source = Paths.get(src, &quot;data&quot;, &quot;test05&quot;, &quot;v9&quot;, &quot;version&quot;);
272         javac(classes.resolve(&quot;v9&quot;), source.resolve(&quot;Extra.java&quot;));
273 
274         jarTool(&quot;cf&quot;, jarfile, &quot;-C&quot;, classes.resolve(&quot;base&quot;).toString(), &quot;.&quot;,
275                 &quot;--release&quot;, &quot;9&quot;, &quot;-C&quot;, classes.resolve(&quot;v9&quot;).toString(), &quot;.&quot;)
276                 .shouldNotHaveExitValue(SUCCESS)
277                 .shouldContain(&quot;contains a new public class&quot;);
278 
279         FileUtils.deleteFileIfExistsWithRetry(Paths.get(jarfile));
280         FileUtils.deleteFileTreeWithRetry(Paths.get(usr, &quot;classes&quot;));
281     }
282 
283     @Test
284     // META-INF/versions/9 contains an extra package private class -- this is okay
285     public void test06() throws Throwable {
286         String jarfile = &quot;test.jar&quot;;
287 
288         compile(&quot;test01&quot;);  //use same data as test01
289 
290         Path classes = Paths.get(&quot;classes&quot;);
291 
292         // add the new v9 class
293         Path source = Paths.get(src, &quot;data&quot;, &quot;test06&quot;, &quot;v9&quot;, &quot;version&quot;);
294         javac(classes.resolve(&quot;v9&quot;), source.resolve(&quot;Extra.java&quot;));
295 
296         jarTool(&quot;cf&quot;, jarfile, &quot;-C&quot;, classes.resolve(&quot;base&quot;).toString(), &quot;.&quot;,
297                 &quot;--release&quot;, &quot;9&quot;, &quot;-C&quot;, classes.resolve(&quot;v9&quot;).toString(), &quot;.&quot;)
298                 .shouldHaveExitValue(SUCCESS);
299 
300         FileUtils.deleteFileIfExistsWithRetry(Paths.get(jarfile));
301         FileUtils.deleteFileTreeWithRetry(Paths.get(usr, &quot;classes&quot;));
302     }
303 
304     @Test
305     // META-INF/versions/9 contains an identical class to base entry class
306     // this is okay but produces warning
307     public void test07() throws Throwable {
308         String jarfile = &quot;test.jar&quot;;
309 
310         compile(&quot;test01&quot;);  //use same data as test01
311 
312         Path classes = Paths.get(&quot;classes&quot;);
313 
314         // add the new v9 class
315         Path source = Paths.get(src, &quot;data&quot;, &quot;test01&quot;, &quot;base&quot;, &quot;version&quot;);
316         javac(classes.resolve(&quot;v9&quot;), source.resolve(&quot;Version.java&quot;));
317 
318         jarTool(&quot;cf&quot;, jarfile, &quot;-C&quot;, classes.resolve(&quot;base&quot;).toString(), &quot;.&quot;,
319                 &quot;--release&quot;, &quot;9&quot;, &quot;-C&quot;, classes.resolve(&quot;v9&quot;).toString(), &quot;.&quot;)
320                 .shouldHaveExitValue(SUCCESS)
321                 .shouldContain(&quot;contains a class that&quot;)
322                 .shouldContain(&quot;is identical&quot;);
323 
324         FileUtils.deleteFileIfExistsWithRetry(Paths.get(jarfile));
325         FileUtils.deleteFileTreeWithRetry(Paths.get(usr, &quot;classes&quot;));
326     }
327 
328     @Test
329     // META-INF/versions/9 contains an identical class to previous version entry class
330     // this is okay but produces warning
331     public void identicalClassToPreviousVersion() throws Throwable {
332         String jarfile = &quot;test.jar&quot;;
333 
334         compile(&quot;test01&quot;);  //use same data as test01
335 
336         Path classes = Paths.get(&quot;classes&quot;);
337 
338         jarTool(&quot;cf&quot;, jarfile, &quot;-C&quot;, classes.resolve(&quot;base&quot;).toString(), &quot;.&quot;,
339                 &quot;--release&quot;, &quot;9&quot;, &quot;-C&quot;, classes.resolve(&quot;v9&quot;).toString(), &quot;.&quot;)
340                 .shouldHaveExitValue(SUCCESS)
341                 .shouldBeEmptyIgnoreVMWarnings();
342         jarTool(&quot;uf&quot;, jarfile,
343                 &quot;--release&quot;, &quot;10&quot;, &quot;-C&quot;, classes.resolve(&quot;v9&quot;).toString(), &quot;.&quot;)
344                 .shouldHaveExitValue(SUCCESS)
345                 .shouldContain(&quot;contains a class that&quot;)
346                 .shouldContain(&quot;is identical&quot;);
347 
348         FileUtils.deleteFileIfExistsWithRetry(Paths.get(jarfile));
349         FileUtils.deleteFileTreeWithRetry(Paths.get(usr, &quot;classes&quot;));
350     }
351 
352     @Test
353     // a class with an internal name different from the external name
354     public void test09() throws Throwable {
355         String jarfile = &quot;test.jar&quot;;
356 
357         compile(&quot;test01&quot;);  //use same data as test01
358 
359         Path classes = Paths.get(&quot;classes&quot;);
360 
361         Path base = classes.resolve(&quot;base&quot;).resolve(&quot;version&quot;);
362 
363         Files.copy(base.resolve(&quot;Main.class&quot;), base.resolve(&quot;Foo.class&quot;));
364 
365         jarTool(&quot;cf&quot;, jarfile, &quot;-C&quot;, classes.resolve(&quot;base&quot;).toString(), &quot;.&quot;,
366                 &quot;--release&quot;, &quot;9&quot;, &quot;-C&quot;, classes.resolve(&quot;v9&quot;).toString(), &quot;.&quot;)
367                 .shouldNotHaveExitValue(SUCCESS)
368                 .shouldContain(&quot;names do not match&quot;);
369 
370         FileUtils.deleteFileIfExistsWithRetry(Paths.get(jarfile));
371         FileUtils.deleteFileTreeWithRetry(Paths.get(usr, &quot;classes&quot;));
372     }
373 
374     @Test
375     // assure that basic nested classes are acceptable
376     public void test10() throws Throwable {
377         String jarfile = &quot;test.jar&quot;;
378 
379         compile(&quot;test01&quot;);  //use same data as test01
380 
381         Path classes = Paths.get(&quot;classes&quot;);
382 
383         // add a base class with a nested class
384         Path source = Paths.get(src, &quot;data&quot;, &quot;test10&quot;, &quot;base&quot;, &quot;version&quot;);
385         javac(classes.resolve(&quot;base&quot;), source.resolve(&quot;Nested.java&quot;));
386 
387         // add a versioned class with a nested class
388         source = Paths.get(src, &quot;data&quot;, &quot;test10&quot;, &quot;v9&quot;, &quot;version&quot;);
389         javac(classes.resolve(&quot;v9&quot;), source.resolve(&quot;Nested.java&quot;));
390 
391         jarTool(&quot;cf&quot;, jarfile, &quot;-C&quot;, classes.resolve(&quot;base&quot;).toString(), &quot;.&quot;,
392                 &quot;--release&quot;, &quot;9&quot;, &quot;-C&quot;, classes.resolve(&quot;v9&quot;).toString(), &quot;.&quot;)
393                 .shouldHaveExitValue(SUCCESS);
394 
395         FileUtils.deleteFileIfExistsWithRetry(Paths.get(jarfile));
396         FileUtils.deleteFileTreeWithRetry(Paths.get(usr, &quot;classes&quot;));
397     }
398 
399     @Test
400     // a base entry contains a nested class that doesn&#39;t have a matching top level class
401     public void test11() throws Throwable {
402         String jarfile = &quot;test.jar&quot;;
403 
404         compile(&quot;test01&quot;);  //use same data as test01
405 
406         Path classes = Paths.get(&quot;classes&quot;);
407 
408         // add a base class with a nested class
409         Path source = Paths.get(src, &quot;data&quot;, &quot;test10&quot;, &quot;base&quot;, &quot;version&quot;);
410         javac(classes.resolve(&quot;base&quot;), source.resolve(&quot;Nested.java&quot;));
411 
412         // remove the top level class, thus isolating the nested class
413         Files.delete(classes.resolve(&quot;base&quot;).resolve(&quot;version&quot;).resolve(&quot;Nested.class&quot;));
414 
415         // add a versioned class with a nested class
416         source = Paths.get(src, &quot;data&quot;, &quot;test10&quot;, &quot;v9&quot;, &quot;version&quot;);
417         javac(classes.resolve(&quot;v9&quot;), source.resolve(&quot;Nested.java&quot;));
418 
419         List&lt;String&gt; output = jarTool(&quot;cf&quot;, jarfile,
420                 &quot;-C&quot;, classes.resolve(&quot;base&quot;).toString(), &quot;.&quot;,
421                 &quot;--release&quot;, &quot;9&quot;, &quot;-C&quot;, classes.resolve(&quot;v9&quot;).toString(), &quot;.&quot;)
422                 .shouldNotHaveExitValue(SUCCESS)
423                 .asLinesWithoutVMWarnings();
424 
425         /* &quot;META-INF/versions/9/version/Nested$nested.class&quot; is really NOT isolated
426         assertTrue(output.size() == 4);
427         assertTrue(output.size() == 3);
428         assertTrue(output.get(0).contains(&quot;an isolated nested class&quot;),
429                 output.get(0));
430         assertTrue(output.get(1).contains(&quot;contains a new public class&quot;),
431                 output.get(1));
432         assertTrue(output.get(2).contains(&quot;an isolated nested class&quot;),
433                 output.get(2));
434         assertTrue(output.get(3).contains(&quot;invalid multi-release jar file&quot;),
435                 output.get(3));
436         assertTrue(output.get(2).contains(&quot;invalid multi-release jar file&quot;),
437                output.get(2));
438         */
439 
440         assertTrue(output.size() == 3);
441         assertTrue(output.get(0).contains(&quot;an isolated nested class&quot;),
442                 output.get(0));
443         assertTrue(output.get(1).contains(&quot;contains a new public class&quot;),
444                 output.get(1));
445         assertTrue(output.get(2).contains(&quot;invalid multi-release jar file&quot;),
446                output.get(2));
447 
448         FileUtils.deleteFileIfExistsWithRetry(Paths.get(jarfile));
449         FileUtils.deleteFileTreeWithRetry(Paths.get(usr, &quot;classes&quot;));
450     }
451 
452     @Test
453     // a versioned entry contains a nested class that doesn&#39;t have a matching top level class
454     public void test12() throws Throwable {
455         String jarfile = &quot;test.jar&quot;;
456 
457         compile(&quot;test01&quot;);  //use same data as test01
458 
459         Path classes = Paths.get(&quot;classes&quot;);
460 
461         // add a base class with a nested class
462         Path source = Paths.get(src, &quot;data&quot;, &quot;test10&quot;, &quot;base&quot;, &quot;version&quot;);
463         javac(classes.resolve(&quot;base&quot;), source.resolve(&quot;Nested.java&quot;));
464 
465         // add a versioned class with a nested class
466         source = Paths.get(src, &quot;data&quot;, &quot;test10&quot;, &quot;v9&quot;, &quot;version&quot;);
467         javac(classes.resolve(&quot;v9&quot;), source.resolve(&quot;Nested.java&quot;));
468 
469         // remove the top level class, thus isolating the nested class
470         Files.delete(classes.resolve(&quot;v9&quot;).resolve(&quot;version&quot;).resolve(&quot;Nested.class&quot;));
471 
472         jarTool(&quot;cf&quot;, jarfile, &quot;-C&quot;, classes.resolve(&quot;base&quot;).toString(), &quot;.&quot;,
473                 &quot;--release&quot;, &quot;9&quot;, &quot;-C&quot;, classes.resolve(&quot;v9&quot;).toString(), &quot;.&quot;)
474                 .shouldNotHaveExitValue(SUCCESS)
475                 .shouldContain(&quot;an isolated nested class&quot;);
476 
477         FileUtils.deleteFileIfExistsWithRetry(Paths.get(jarfile));
478         FileUtils.deleteFileTreeWithRetry(Paths.get(usr, &quot;classes&quot;));
479     }
480 
481     @Test
482     // assure the nested-nested classes are acceptable
483     public void test13() throws Throwable {
484         String jarfile = &quot;test.jar&quot;;
485 
486         compile(&quot;test01&quot;);  //use same data as test01
487 
488         Path classes = Paths.get(&quot;classes&quot;);
489 
490         // add a base class with a nested and nested-nested class
491         Path source = Paths.get(src, &quot;data&quot;, &quot;test13&quot;, &quot;base&quot;, &quot;version&quot;);
492         javac(classes.resolve(&quot;base&quot;), source.resolve(&quot;Nested.java&quot;));
493 
494         // add a versioned class with a nested and nested-nested class
495         source = Paths.get(src, &quot;data&quot;, &quot;test13&quot;, &quot;v10&quot;, &quot;version&quot;);
496         javac(classes.resolve(&quot;v10&quot;), source.resolve(&quot;Nested.java&quot;));
497 
498         jarTool(&quot;cf&quot;, jarfile, &quot;-C&quot;, classes.resolve(&quot;base&quot;).toString(), &quot;.&quot;,
499                 &quot;--release&quot;, &quot;10&quot;, &quot;-C&quot;, classes.resolve(&quot;v10&quot;).toString(), &quot;.&quot;)
500                 .shouldHaveExitValue(SUCCESS);
501 
502         FileUtils.deleteFileIfExistsWithRetry(Paths.get(jarfile));
503         FileUtils.deleteFileTreeWithRetry(Paths.get(usr, &quot;classes&quot;));
504     }
505 
506     @Test
507     public void testCustomManifest() throws Throwable {
508         String jarfile = &quot;test.jar&quot;;
509 
510         compile(&quot;test01&quot;);
511 
512         Path classes = Paths.get(&quot;classes&quot;);
513         Path manifest = Paths.get(&quot;Manifest.txt&quot;);
514 
515         // create
516         Files.write(manifest, &quot;Class-Path: MyUtils.jar\n&quot;.getBytes());
517 
518         jarTool(&quot;cfm&quot;, jarfile, manifest.toString(),
519                 &quot;-C&quot;, classes.resolve(&quot;base&quot;).toString(), &quot;.&quot;,
520                 &quot;--release&quot;, &quot;10&quot;, &quot;-C&quot;, classes.resolve(&quot;v10&quot;).toString(), &quot;.&quot;)
521                 .shouldHaveExitValue(SUCCESS)
522                 .shouldBeEmptyIgnoreVMWarnings();
523 
524         try (JarFile jf = new JarFile(new File(jarfile), true,
525                 ZipFile.OPEN_READ, JarFile.runtimeVersion())) {
526             assertTrue(jf.isMultiRelease(), &quot;Not multi-release jar&quot;);
527             assertEquals(jf.getManifest()
528                             .getMainAttributes()
529                             .getValue(&quot;Class-Path&quot;),
530                     &quot;MyUtils.jar&quot;);
531         }
532 
533         // update
534         Files.write(manifest, &quot;Multi-release: false\n&quot;.getBytes());
535 
536         jar(&quot;ufm&quot;, jarfile, manifest.toString(),
537                 &quot;-C&quot;, classes.resolve(&quot;base&quot;).toString(), &quot;.&quot;,
538                 &quot;--release&quot;, &quot;9&quot;, &quot;-C&quot;, classes.resolve(&quot;v10&quot;).toString(), &quot;.&quot;)
539                 .shouldHaveExitValue(SUCCESS)
540                 .shouldContain(&quot;WARNING: Duplicate name in Manifest: Multi-release.&quot;);
541 
542         try (JarFile jf = new JarFile(new File(jarfile), true,
543                 ZipFile.OPEN_READ, JarFile.runtimeVersion())) {
544             assertTrue(jf.isMultiRelease(), &quot;Not multi-release jar&quot;);
545             assertEquals(jf.getManifest()
546                             .getMainAttributes()
547                             .getValue(&quot;Class-Path&quot;),
548                     &quot;MyUtils.jar&quot;);
549         }
550 
551         FileUtils.deleteFileIfExistsWithRetry(Paths.get(jarfile));
552         FileUtils.deleteFileTreeWithRetry(Paths.get(usr, &quot;classes&quot;));
553     }
554 }
    </pre>
  </body>
</html>
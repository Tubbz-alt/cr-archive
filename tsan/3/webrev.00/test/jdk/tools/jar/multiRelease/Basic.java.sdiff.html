<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff test/jdk/tools/jar/multiRelease/Basic.java</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
<body>
<center><a href="../modularJar/Basic.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="MRTestBase.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>test/jdk/tools/jar/multiRelease/Basic.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2016, 2017, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 /*
 25  * @test
<span class="line-modified"> 26  # @bug 8186087 8196748</span>
 27  * @library /test/lib
 28  * @modules java.base/jdk.internal.misc
 29  *          jdk.compiler
 30  *          jdk.jartool
 31  * @build jdk.test.lib.util.FileUtils
 32  *        jdk.test.lib.Utils
 33  *        jdk.test.lib.Asserts
 34  *        jdk.test.lib.JDKToolFinder
 35  *        jdk.test.lib.JDKToolLauncher
 36  *        jdk.test.lib.Platform
 37  *        jdk.test.lib.process.*
 38  *        MRTestBase
 39  * @run testng Basic
 40  */
 41 
<span class="line-removed"> 42 import static org.testng.Assert.*;</span>
<span class="line-removed"> 43 </span>
 44 import jdk.test.lib.util.FileUtils;
 45 import org.testng.annotations.*;
 46 
 47 import java.io.File;
<span class="line-modified"> 48 import java.nio.file.*;</span>
<span class="line-modified"> 49 import java.util.*;</span>



 50 import java.util.jar.JarFile;
 51 import java.util.zip.ZipFile;
 52 


 53 public class Basic extends MRTestBase {
 54 
 55     @Test
 56     // create a regular, non-multi-release jar
 57     public void test00() throws Throwable {
 58         String jarfile = &quot;test.jar&quot;;
 59 
 60         compile(&quot;test01&quot;);  //use same data as test01
 61 
 62         Path classes = Paths.get(&quot;classes&quot;);
<span class="line-modified"> 63         jar(&quot;cf&quot;, jarfile, &quot;-C&quot;, classes.resolve(&quot;base&quot;).toString(), &quot;.&quot;)</span>
 64                 .shouldHaveExitValue(SUCCESS);
 65 
 66         checkMultiRelease(jarfile, false);
 67 
 68         Map&lt;String, String[]&gt; names = Map.of(
 69                 &quot;version/Main.class&quot;,
 70                 new String[]{&quot;base&quot;, &quot;version&quot;, &quot;Main.class&quot;},
 71 
 72                 &quot;version/Version.class&quot;,
 73                 new String[]{&quot;base&quot;, &quot;version&quot;, &quot;Version.class&quot;}
 74         );
 75 
 76         compare(jarfile, names);
 77 
 78         FileUtils.deleteFileIfExistsWithRetry(Paths.get(jarfile));
 79         FileUtils.deleteFileTreeWithRetry(Paths.get(usr, &quot;classes&quot;));
 80     }
 81 
 82     @Test
 83     // create a multi-release jar
 84     public void test01() throws Throwable {
 85         String jarfile = &quot;test.jar&quot;;
 86 
 87         compile(&quot;test01&quot;);
 88 
 89         Path classes = Paths.get(&quot;classes&quot;);
<span class="line-modified"> 90         jar(&quot;cf&quot;, jarfile, &quot;-C&quot;, classes.resolve(&quot;base&quot;).toString(), &quot;.&quot;,</span>
 91                 &quot;--release&quot;, &quot;9&quot;, &quot;-C&quot;, classes.resolve(&quot;v9&quot;).toString(), &quot;.&quot;,
 92                 &quot;--release&quot;, &quot;10&quot;, &quot;-C&quot;, classes.resolve(&quot;v10&quot;).toString(), &quot;.&quot;)
 93                 .shouldHaveExitValue(SUCCESS);
 94 
 95         checkMultiRelease(jarfile, true);
 96 
 97         Map&lt;String, String[]&gt; names = Map.of(
 98                 &quot;version/Main.class&quot;,
 99                 new String[]{&quot;base&quot;, &quot;version&quot;, &quot;Main.class&quot;},
100 
101                 &quot;version/Version.class&quot;,
102                 new String[]{&quot;base&quot;, &quot;version&quot;, &quot;Version.class&quot;},
103 
104                 &quot;META-INF/versions/9/version/Version.class&quot;,
105                 new String[]{&quot;v9&quot;, &quot;version&quot;, &quot;Version.class&quot;},
106 
107                 &quot;META-INF/versions/10/version/Version.class&quot;,
108                 new String[]{&quot;v10&quot;, &quot;version&quot;, &quot;Version.class&quot;}
109         );
110 
111         compare(jarfile, names);
112 
113         FileUtils.deleteFileIfExistsWithRetry(Paths.get(jarfile));
114         FileUtils.deleteFileTreeWithRetry(Paths.get(usr, &quot;classes&quot;));
115     }
116 
117     @Test
118     public void versionFormat() throws Throwable {
119         String jarfile = &quot;test.jar&quot;;
120 
121         compile(&quot;test01&quot;);
122 
123         Path classes = Paths.get(&quot;classes&quot;);
124 
125         // valid
126         for (String release : List.of(&quot;10000&quot;, &quot;09&quot;, &quot;00010&quot;, &quot;10&quot;)) {
<span class="line-modified">127             jar(&quot;cf&quot;, jarfile, &quot;-C&quot;, classes.resolve(&quot;base&quot;).toString(), &quot;.&quot;,</span>
128                     &quot;--release&quot;, release, &quot;-C&quot;, classes.resolve(&quot;v10&quot;).toString(), &quot;.&quot;)
129                     .shouldHaveExitValue(SUCCESS)
130                     .shouldBeEmptyIgnoreVMWarnings();
131         }
132         // invalid
133         for (String release : List.of(&quot;9.0&quot;, &quot;8&quot;, &quot;v9&quot;,
134                 &quot;9v&quot;, &quot;0&quot;, &quot;-10&quot;)) {
<span class="line-modified">135             jar(&quot;cf&quot;, jarfile, &quot;-C&quot;, classes.resolve(&quot;base&quot;).toString(), &quot;.&quot;,</span>
136                     &quot;--release&quot;, release, &quot;-C&quot;, classes.resolve(&quot;v10&quot;).toString(), &quot;.&quot;)
137                     .shouldNotHaveExitValue(SUCCESS)
138                     .shouldContain(&quot;release &quot; + release + &quot; not valid&quot;);
139         }
140         FileUtils.deleteFileIfExistsWithRetry(Paths.get(jarfile));
141         FileUtils.deleteFileTreeWithRetry(Paths.get(usr, &quot;classes&quot;));
142     }
143 
144     @Test
145     // update a regular jar to a multi-release jar
146     public void test02() throws Throwable {
147         String jarfile = &quot;test.jar&quot;;
148 
149         compile(&quot;test01&quot;);  //use same data as test01
150 
151         Path classes = Paths.get(&quot;classes&quot;);
<span class="line-modified">152         jar(&quot;cf&quot;, jarfile, &quot;-C&quot;, classes.resolve(&quot;base&quot;).toString(), &quot;.&quot;)</span>
153                 .shouldHaveExitValue(SUCCESS);
154 
155         checkMultiRelease(jarfile, false);
156 
<span class="line-modified">157         jar(&quot;uf&quot;, jarfile,</span>
158                 &quot;--release&quot;, &quot;9&quot;, &quot;-C&quot;, classes.resolve(&quot;v9&quot;).toString(), &quot;.&quot;)
159                 .shouldHaveExitValue(SUCCESS);
160 
161         checkMultiRelease(jarfile, true);
162 
163         Map&lt;String, String[]&gt; names = Map.of(
164                 &quot;version/Main.class&quot;,
165                 new String[]{&quot;base&quot;, &quot;version&quot;, &quot;Main.class&quot;},
166 
167                 &quot;version/Version.class&quot;,
168                 new String[]{&quot;base&quot;, &quot;version&quot;, &quot;Version.class&quot;},
169 
170                 &quot;META-INF/versions/9/version/Version.class&quot;,
171                 new String[]{&quot;v9&quot;, &quot;version&quot;, &quot;Version.class&quot;}
172         );
173 
174         compare(jarfile, names);
175 
176         FileUtils.deleteFileIfExistsWithRetry(Paths.get(jarfile));
177         FileUtils.deleteFileTreeWithRetry(Paths.get(usr, &quot;classes&quot;));
178     }
179 
180     @Test
181     // replace a base entry and a versioned entry
182     public void test03() throws Throwable {
183         String jarfile = &quot;test.jar&quot;;
184 
185         compile(&quot;test01&quot;);  //use same data as test01
186 
187         Path classes = Paths.get(&quot;classes&quot;);
<span class="line-modified">188         jar(&quot;cf&quot;, jarfile, &quot;-C&quot;, classes.resolve(&quot;base&quot;).toString(), &quot;.&quot;,</span>
189                 &quot;--release&quot;, &quot;9&quot;, &quot;-C&quot;, classes.resolve(&quot;v9&quot;).toString(), &quot;.&quot;)
190                 .shouldHaveExitValue(SUCCESS);
191 
192         checkMultiRelease(jarfile, true);
193 
194         Map&lt;String, String[]&gt; names = Map.of(
195                 &quot;version/Main.class&quot;,
196                 new String[]{&quot;base&quot;, &quot;version&quot;, &quot;Main.class&quot;},
197 
198                 &quot;version/Version.class&quot;,
199                 new String[]{&quot;base&quot;, &quot;version&quot;, &quot;Version.class&quot;},
200 
201                 &quot;META-INF/versions/9/version/Version.class&quot;,
202                 new String[]{&quot;v9&quot;, &quot;version&quot;, &quot;Version.class&quot;}
203         );
204 
205         compare(jarfile, names);
206 
207         // write the v9 version/Version.class entry in base and the v10
208         // version/Version.class entry in versions/9 section
<span class="line-modified">209         jar(&quot;uf&quot;, jarfile, &quot;-C&quot;, classes.resolve(&quot;v9&quot;).toString(), &quot;version&quot;,</span>
210                 &quot;--release&quot;, &quot;9&quot;, &quot;-C&quot;, classes.resolve(&quot;v10&quot;).toString(), &quot;.&quot;)
211                 .shouldHaveExitValue(SUCCESS);
212 
213         checkMultiRelease(jarfile, true);
214 
215         names = Map.of(
216                 &quot;version/Main.class&quot;,
217                 new String[]{&quot;base&quot;, &quot;version&quot;, &quot;Main.class&quot;},
218 
219                 &quot;version/Version.class&quot;,
220                 new String[]{&quot;v9&quot;, &quot;version&quot;, &quot;Version.class&quot;},
221 
222                 &quot;META-INF/versions/9/version/Version.class&quot;,
223                 new String[]{&quot;v10&quot;, &quot;version&quot;, &quot;Version.class&quot;}
224         );
225 
226         compare(jarfile, names);
227 
228         FileUtils.deleteFileIfExistsWithRetry(Paths.get(jarfile));
229         FileUtils.deleteFileTreeWithRetry(Paths.get(usr, &quot;classes&quot;));
230     }
231 
232     /*
233      * The following tests exercise the jar validator
234      */
235 
236     @Test
237     // META-INF/versions/9 class has different api than base class
238     public void test04() throws Throwable {
239         String jarfile = &quot;test.jar&quot;;
240 
241         compile(&quot;test01&quot;);  //use same data as test01
242 
243         Path classes = Paths.get(&quot;classes&quot;);
244 
245         // replace the v9 class
246         Path source = Paths.get(src, &quot;data&quot;, &quot;test04&quot;, &quot;v9&quot;, &quot;version&quot;);
247         javac(classes.resolve(&quot;v9&quot;), source.resolve(&quot;Version.java&quot;));
248 
<span class="line-modified">249         jar(&quot;cf&quot;, jarfile, &quot;-C&quot;, classes.resolve(&quot;base&quot;).toString(), &quot;.&quot;,</span>
250                 &quot;--release&quot;, &quot;9&quot;, &quot;-C&quot;, classes.resolve(&quot;v9&quot;).toString(), &quot;.&quot;)
251                 .shouldNotHaveExitValue(SUCCESS)
252                 .shouldContain(&quot;different api from earlier&quot;);
253 
254         FileUtils.deleteFileIfExistsWithRetry(Paths.get(jarfile));
255         FileUtils.deleteFileTreeWithRetry(Paths.get(usr, &quot;classes&quot;));
256     }
257 
258     @Test
259     // META-INF/versions/9 contains an extra public class
260     public void test05() throws Throwable {
261         String jarfile = &quot;test.jar&quot;;
262 
263         compile(&quot;test01&quot;);  //use same data as test01
264 
265         Path classes = Paths.get(&quot;classes&quot;);
266 
267         // add the new v9 class
268         Path source = Paths.get(src, &quot;data&quot;, &quot;test05&quot;, &quot;v9&quot;, &quot;version&quot;);
269         javac(classes.resolve(&quot;v9&quot;), source.resolve(&quot;Extra.java&quot;));
270 
<span class="line-modified">271         jar(&quot;cf&quot;, jarfile, &quot;-C&quot;, classes.resolve(&quot;base&quot;).toString(), &quot;.&quot;,</span>
272                 &quot;--release&quot;, &quot;9&quot;, &quot;-C&quot;, classes.resolve(&quot;v9&quot;).toString(), &quot;.&quot;)
273                 .shouldNotHaveExitValue(SUCCESS)
274                 .shouldContain(&quot;contains a new public class&quot;);
275 
276         FileUtils.deleteFileIfExistsWithRetry(Paths.get(jarfile));
277         FileUtils.deleteFileTreeWithRetry(Paths.get(usr, &quot;classes&quot;));
278     }
279 
280     @Test
281     // META-INF/versions/9 contains an extra package private class -- this is okay
282     public void test06() throws Throwable {
283         String jarfile = &quot;test.jar&quot;;
284 
285         compile(&quot;test01&quot;);  //use same data as test01
286 
287         Path classes = Paths.get(&quot;classes&quot;);
288 
289         // add the new v9 class
290         Path source = Paths.get(src, &quot;data&quot;, &quot;test06&quot;, &quot;v9&quot;, &quot;version&quot;);
291         javac(classes.resolve(&quot;v9&quot;), source.resolve(&quot;Extra.java&quot;));
292 
<span class="line-modified">293         jar(&quot;cf&quot;, jarfile, &quot;-C&quot;, classes.resolve(&quot;base&quot;).toString(), &quot;.&quot;,</span>
294                 &quot;--release&quot;, &quot;9&quot;, &quot;-C&quot;, classes.resolve(&quot;v9&quot;).toString(), &quot;.&quot;)
295                 .shouldHaveExitValue(SUCCESS);
296 
297         FileUtils.deleteFileIfExistsWithRetry(Paths.get(jarfile));
298         FileUtils.deleteFileTreeWithRetry(Paths.get(usr, &quot;classes&quot;));
299     }
300 
301     @Test
302     // META-INF/versions/9 contains an identical class to base entry class
303     // this is okay but produces warning
304     public void test07() throws Throwable {
305         String jarfile = &quot;test.jar&quot;;
306 
307         compile(&quot;test01&quot;);  //use same data as test01
308 
309         Path classes = Paths.get(&quot;classes&quot;);
310 
311         // add the new v9 class
312         Path source = Paths.get(src, &quot;data&quot;, &quot;test01&quot;, &quot;base&quot;, &quot;version&quot;);
313         javac(classes.resolve(&quot;v9&quot;), source.resolve(&quot;Version.java&quot;));
314 
<span class="line-modified">315         jar(&quot;cf&quot;, jarfile, &quot;-C&quot;, classes.resolve(&quot;base&quot;).toString(), &quot;.&quot;,</span>
316                 &quot;--release&quot;, &quot;9&quot;, &quot;-C&quot;, classes.resolve(&quot;v9&quot;).toString(), &quot;.&quot;)
317                 .shouldHaveExitValue(SUCCESS)
318                 .shouldContain(&quot;contains a class that&quot;)
319                 .shouldContain(&quot;is identical&quot;);
320 
321         FileUtils.deleteFileIfExistsWithRetry(Paths.get(jarfile));
322         FileUtils.deleteFileTreeWithRetry(Paths.get(usr, &quot;classes&quot;));
323     }
324 
325     @Test
326     // META-INF/versions/9 contains an identical class to previous version entry class
327     // this is okay but produces warning
328     public void identicalClassToPreviousVersion() throws Throwable {
329         String jarfile = &quot;test.jar&quot;;
330 
331         compile(&quot;test01&quot;);  //use same data as test01
332 
333         Path classes = Paths.get(&quot;classes&quot;);
334 
<span class="line-modified">335         jar(&quot;cf&quot;, jarfile, &quot;-C&quot;, classes.resolve(&quot;base&quot;).toString(), &quot;.&quot;,</span>
336                 &quot;--release&quot;, &quot;9&quot;, &quot;-C&quot;, classes.resolve(&quot;v9&quot;).toString(), &quot;.&quot;)
337                 .shouldHaveExitValue(SUCCESS)
338                 .shouldBeEmptyIgnoreVMWarnings();
<span class="line-modified">339         jar(&quot;uf&quot;, jarfile,</span>
340                 &quot;--release&quot;, &quot;10&quot;, &quot;-C&quot;, classes.resolve(&quot;v9&quot;).toString(), &quot;.&quot;)
341                 .shouldHaveExitValue(SUCCESS)
342                 .shouldContain(&quot;contains a class that&quot;)
343                 .shouldContain(&quot;is identical&quot;);
344 
345         FileUtils.deleteFileIfExistsWithRetry(Paths.get(jarfile));
346         FileUtils.deleteFileTreeWithRetry(Paths.get(usr, &quot;classes&quot;));
347     }
348 
349     @Test
350     // a class with an internal name different from the external name
351     public void test09() throws Throwable {
352         String jarfile = &quot;test.jar&quot;;
353 
354         compile(&quot;test01&quot;);  //use same data as test01
355 
356         Path classes = Paths.get(&quot;classes&quot;);
357 
358         Path base = classes.resolve(&quot;base&quot;).resolve(&quot;version&quot;);
359 
360         Files.copy(base.resolve(&quot;Main.class&quot;), base.resolve(&quot;Foo.class&quot;));
361 
<span class="line-modified">362         jar(&quot;cf&quot;, jarfile, &quot;-C&quot;, classes.resolve(&quot;base&quot;).toString(), &quot;.&quot;,</span>
363                 &quot;--release&quot;, &quot;9&quot;, &quot;-C&quot;, classes.resolve(&quot;v9&quot;).toString(), &quot;.&quot;)
364                 .shouldNotHaveExitValue(SUCCESS)
365                 .shouldContain(&quot;names do not match&quot;);
366 
367         FileUtils.deleteFileIfExistsWithRetry(Paths.get(jarfile));
368         FileUtils.deleteFileTreeWithRetry(Paths.get(usr, &quot;classes&quot;));
369     }
370 
371     @Test
372     // assure that basic nested classes are acceptable
373     public void test10() throws Throwable {
374         String jarfile = &quot;test.jar&quot;;
375 
376         compile(&quot;test01&quot;);  //use same data as test01
377 
378         Path classes = Paths.get(&quot;classes&quot;);
379 
380         // add a base class with a nested class
381         Path source = Paths.get(src, &quot;data&quot;, &quot;test10&quot;, &quot;base&quot;, &quot;version&quot;);
382         javac(classes.resolve(&quot;base&quot;), source.resolve(&quot;Nested.java&quot;));
383 
384         // add a versioned class with a nested class
385         source = Paths.get(src, &quot;data&quot;, &quot;test10&quot;, &quot;v9&quot;, &quot;version&quot;);
386         javac(classes.resolve(&quot;v9&quot;), source.resolve(&quot;Nested.java&quot;));
387 
<span class="line-modified">388         jar(&quot;cf&quot;, jarfile, &quot;-C&quot;, classes.resolve(&quot;base&quot;).toString(), &quot;.&quot;,</span>
389                 &quot;--release&quot;, &quot;9&quot;, &quot;-C&quot;, classes.resolve(&quot;v9&quot;).toString(), &quot;.&quot;)
390                 .shouldHaveExitValue(SUCCESS);
391 
392         FileUtils.deleteFileIfExistsWithRetry(Paths.get(jarfile));
393         FileUtils.deleteFileTreeWithRetry(Paths.get(usr, &quot;classes&quot;));
394     }
395 
396     @Test
397     // a base entry contains a nested class that doesn&#39;t have a matching top level class
398     public void test11() throws Throwable {
399         String jarfile = &quot;test.jar&quot;;
400 
401         compile(&quot;test01&quot;);  //use same data as test01
402 
403         Path classes = Paths.get(&quot;classes&quot;);
404 
405         // add a base class with a nested class
406         Path source = Paths.get(src, &quot;data&quot;, &quot;test10&quot;, &quot;base&quot;, &quot;version&quot;);
407         javac(classes.resolve(&quot;base&quot;), source.resolve(&quot;Nested.java&quot;));
408 
409         // remove the top level class, thus isolating the nested class
410         Files.delete(classes.resolve(&quot;base&quot;).resolve(&quot;version&quot;).resolve(&quot;Nested.class&quot;));
411 
412         // add a versioned class with a nested class
413         source = Paths.get(src, &quot;data&quot;, &quot;test10&quot;, &quot;v9&quot;, &quot;version&quot;);
414         javac(classes.resolve(&quot;v9&quot;), source.resolve(&quot;Nested.java&quot;));
415 
<span class="line-modified">416         List&lt;String&gt; output = jar(&quot;cf&quot;, jarfile,</span>
417                 &quot;-C&quot;, classes.resolve(&quot;base&quot;).toString(), &quot;.&quot;,
418                 &quot;--release&quot;, &quot;9&quot;, &quot;-C&quot;, classes.resolve(&quot;v9&quot;).toString(), &quot;.&quot;)
419                 .shouldNotHaveExitValue(SUCCESS)
420                 .asLinesWithoutVMWarnings();
421 
422         /* &quot;META-INF/versions/9/version/Nested$nested.class&quot; is really NOT isolated
423         assertTrue(output.size() == 4);
424         assertTrue(output.size() == 3);
425         assertTrue(output.get(0).contains(&quot;an isolated nested class&quot;),
426                 output.get(0));
427         assertTrue(output.get(1).contains(&quot;contains a new public class&quot;),
428                 output.get(1));
429         assertTrue(output.get(2).contains(&quot;an isolated nested class&quot;),
430                 output.get(2));
431         assertTrue(output.get(3).contains(&quot;invalid multi-release jar file&quot;),
432                 output.get(3));
433         assertTrue(output.get(2).contains(&quot;invalid multi-release jar file&quot;),
434                output.get(2));
435         */
436 
</pre>
<hr />
<pre>
449     @Test
450     // a versioned entry contains a nested class that doesn&#39;t have a matching top level class
451     public void test12() throws Throwable {
452         String jarfile = &quot;test.jar&quot;;
453 
454         compile(&quot;test01&quot;);  //use same data as test01
455 
456         Path classes = Paths.get(&quot;classes&quot;);
457 
458         // add a base class with a nested class
459         Path source = Paths.get(src, &quot;data&quot;, &quot;test10&quot;, &quot;base&quot;, &quot;version&quot;);
460         javac(classes.resolve(&quot;base&quot;), source.resolve(&quot;Nested.java&quot;));
461 
462         // add a versioned class with a nested class
463         source = Paths.get(src, &quot;data&quot;, &quot;test10&quot;, &quot;v9&quot;, &quot;version&quot;);
464         javac(classes.resolve(&quot;v9&quot;), source.resolve(&quot;Nested.java&quot;));
465 
466         // remove the top level class, thus isolating the nested class
467         Files.delete(classes.resolve(&quot;v9&quot;).resolve(&quot;version&quot;).resolve(&quot;Nested.class&quot;));
468 
<span class="line-modified">469         jar(&quot;cf&quot;, jarfile, &quot;-C&quot;, classes.resolve(&quot;base&quot;).toString(), &quot;.&quot;,</span>
470                 &quot;--release&quot;, &quot;9&quot;, &quot;-C&quot;, classes.resolve(&quot;v9&quot;).toString(), &quot;.&quot;)
471                 .shouldNotHaveExitValue(SUCCESS)
472                 .shouldContain(&quot;an isolated nested class&quot;);
473 
474         FileUtils.deleteFileIfExistsWithRetry(Paths.get(jarfile));
475         FileUtils.deleteFileTreeWithRetry(Paths.get(usr, &quot;classes&quot;));
476     }
477 
478     @Test
479     // assure the nested-nested classes are acceptable
480     public void test13() throws Throwable {
481         String jarfile = &quot;test.jar&quot;;
482 
483         compile(&quot;test01&quot;);  //use same data as test01
484 
485         Path classes = Paths.get(&quot;classes&quot;);
486 
487         // add a base class with a nested and nested-nested class
488         Path source = Paths.get(src, &quot;data&quot;, &quot;test13&quot;, &quot;base&quot;, &quot;version&quot;);
489         javac(classes.resolve(&quot;base&quot;), source.resolve(&quot;Nested.java&quot;));
490 
491         // add a versioned class with a nested and nested-nested class
492         source = Paths.get(src, &quot;data&quot;, &quot;test13&quot;, &quot;v10&quot;, &quot;version&quot;);
493         javac(classes.resolve(&quot;v10&quot;), source.resolve(&quot;Nested.java&quot;));
494 
<span class="line-modified">495         jar(&quot;cf&quot;, jarfile, &quot;-C&quot;, classes.resolve(&quot;base&quot;).toString(), &quot;.&quot;,</span>
496                 &quot;--release&quot;, &quot;10&quot;, &quot;-C&quot;, classes.resolve(&quot;v10&quot;).toString(), &quot;.&quot;)
497                 .shouldHaveExitValue(SUCCESS);
498 
499         FileUtils.deleteFileIfExistsWithRetry(Paths.get(jarfile));
500         FileUtils.deleteFileTreeWithRetry(Paths.get(usr, &quot;classes&quot;));
501     }
502 
503     @Test
504     public void testCustomManifest() throws Throwable {
505         String jarfile = &quot;test.jar&quot;;
506 
507         compile(&quot;test01&quot;);
508 
509         Path classes = Paths.get(&quot;classes&quot;);
510         Path manifest = Paths.get(&quot;Manifest.txt&quot;);
511 
512         // create
513         Files.write(manifest, &quot;Class-Path: MyUtils.jar\n&quot;.getBytes());
514 
<span class="line-modified">515         jar(&quot;cfm&quot;, jarfile, manifest.toString(),</span>
516                 &quot;-C&quot;, classes.resolve(&quot;base&quot;).toString(), &quot;.&quot;,
517                 &quot;--release&quot;, &quot;10&quot;, &quot;-C&quot;, classes.resolve(&quot;v10&quot;).toString(), &quot;.&quot;)
518                 .shouldHaveExitValue(SUCCESS)
519                 .shouldBeEmptyIgnoreVMWarnings();
520 
521         try (JarFile jf = new JarFile(new File(jarfile), true,
522                 ZipFile.OPEN_READ, JarFile.runtimeVersion())) {
523             assertTrue(jf.isMultiRelease(), &quot;Not multi-release jar&quot;);
524             assertEquals(jf.getManifest()
525                             .getMainAttributes()
526                             .getValue(&quot;Class-Path&quot;),
527                     &quot;MyUtils.jar&quot;);
528         }
529 
530         // update
531         Files.write(manifest, &quot;Multi-release: false\n&quot;.getBytes());
532 
533         jar(&quot;ufm&quot;, jarfile, manifest.toString(),
534                 &quot;-C&quot;, classes.resolve(&quot;base&quot;).toString(), &quot;.&quot;,
535                 &quot;--release&quot;, &quot;9&quot;, &quot;-C&quot;, classes.resolve(&quot;v10&quot;).toString(), &quot;.&quot;)
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2016, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 /*
 25  * @test
<span class="line-modified"> 26  # @bug 8186087 8196748 8212807</span>
 27  * @library /test/lib
 28  * @modules java.base/jdk.internal.misc
 29  *          jdk.compiler
 30  *          jdk.jartool
 31  * @build jdk.test.lib.util.FileUtils
 32  *        jdk.test.lib.Utils
 33  *        jdk.test.lib.Asserts
 34  *        jdk.test.lib.JDKToolFinder
 35  *        jdk.test.lib.JDKToolLauncher
 36  *        jdk.test.lib.Platform
 37  *        jdk.test.lib.process.*
 38  *        MRTestBase
 39  * @run testng Basic
 40  */
 41 


 42 import jdk.test.lib.util.FileUtils;
 43 import org.testng.annotations.*;
 44 
 45 import java.io.File;
<span class="line-modified"> 46 import java.nio.file.Files;</span>
<span class="line-modified"> 47 import java.nio.file.Path;</span>
<span class="line-added"> 48 import java.nio.file.Paths;</span>
<span class="line-added"> 49 import java.util.List;</span>
<span class="line-added"> 50 import java.util.Map;</span>
 51 import java.util.jar.JarFile;
 52 import java.util.zip.ZipFile;
 53 
<span class="line-added"> 54 import static org.testng.Assert.*;</span>
<span class="line-added"> 55 </span>
 56 public class Basic extends MRTestBase {
 57 
 58     @Test
 59     // create a regular, non-multi-release jar
 60     public void test00() throws Throwable {
 61         String jarfile = &quot;test.jar&quot;;
 62 
 63         compile(&quot;test01&quot;);  //use same data as test01
 64 
 65         Path classes = Paths.get(&quot;classes&quot;);
<span class="line-modified"> 66         jarTool(&quot;cf&quot;, jarfile, &quot;-C&quot;, classes.resolve(&quot;base&quot;).toString(), &quot;.&quot;)</span>
 67                 .shouldHaveExitValue(SUCCESS);
 68 
 69         checkMultiRelease(jarfile, false);
 70 
 71         Map&lt;String, String[]&gt; names = Map.of(
 72                 &quot;version/Main.class&quot;,
 73                 new String[]{&quot;base&quot;, &quot;version&quot;, &quot;Main.class&quot;},
 74 
 75                 &quot;version/Version.class&quot;,
 76                 new String[]{&quot;base&quot;, &quot;version&quot;, &quot;Version.class&quot;}
 77         );
 78 
 79         compare(jarfile, names);
 80 
 81         FileUtils.deleteFileIfExistsWithRetry(Paths.get(jarfile));
 82         FileUtils.deleteFileTreeWithRetry(Paths.get(usr, &quot;classes&quot;));
 83     }
 84 
 85     @Test
 86     // create a multi-release jar
 87     public void test01() throws Throwable {
 88         String jarfile = &quot;test.jar&quot;;
 89 
 90         compile(&quot;test01&quot;);
 91 
 92         Path classes = Paths.get(&quot;classes&quot;);
<span class="line-modified"> 93         jarTool(&quot;cf&quot;, jarfile, &quot;-C&quot;, classes.resolve(&quot;base&quot;).toString(), &quot;.&quot;,</span>
 94                 &quot;--release&quot;, &quot;9&quot;, &quot;-C&quot;, classes.resolve(&quot;v9&quot;).toString(), &quot;.&quot;,
 95                 &quot;--release&quot;, &quot;10&quot;, &quot;-C&quot;, classes.resolve(&quot;v10&quot;).toString(), &quot;.&quot;)
 96                 .shouldHaveExitValue(SUCCESS);
 97 
 98         checkMultiRelease(jarfile, true);
 99 
100         Map&lt;String, String[]&gt; names = Map.of(
101                 &quot;version/Main.class&quot;,
102                 new String[]{&quot;base&quot;, &quot;version&quot;, &quot;Main.class&quot;},
103 
104                 &quot;version/Version.class&quot;,
105                 new String[]{&quot;base&quot;, &quot;version&quot;, &quot;Version.class&quot;},
106 
107                 &quot;META-INF/versions/9/version/Version.class&quot;,
108                 new String[]{&quot;v9&quot;, &quot;version&quot;, &quot;Version.class&quot;},
109 
110                 &quot;META-INF/versions/10/version/Version.class&quot;,
111                 new String[]{&quot;v10&quot;, &quot;version&quot;, &quot;Version.class&quot;}
112         );
113 
114         compare(jarfile, names);
115 
116         FileUtils.deleteFileIfExistsWithRetry(Paths.get(jarfile));
117         FileUtils.deleteFileTreeWithRetry(Paths.get(usr, &quot;classes&quot;));
118     }
119 
120     @Test
121     public void versionFormat() throws Throwable {
122         String jarfile = &quot;test.jar&quot;;
123 
124         compile(&quot;test01&quot;);
125 
126         Path classes = Paths.get(&quot;classes&quot;);
127 
128         // valid
129         for (String release : List.of(&quot;10000&quot;, &quot;09&quot;, &quot;00010&quot;, &quot;10&quot;)) {
<span class="line-modified">130             jarTool(&quot;cf&quot;, jarfile, &quot;-C&quot;, classes.resolve(&quot;base&quot;).toString(), &quot;.&quot;,</span>
131                     &quot;--release&quot;, release, &quot;-C&quot;, classes.resolve(&quot;v10&quot;).toString(), &quot;.&quot;)
132                     .shouldHaveExitValue(SUCCESS)
133                     .shouldBeEmptyIgnoreVMWarnings();
134         }
135         // invalid
136         for (String release : List.of(&quot;9.0&quot;, &quot;8&quot;, &quot;v9&quot;,
137                 &quot;9v&quot;, &quot;0&quot;, &quot;-10&quot;)) {
<span class="line-modified">138             jarTool(&quot;cf&quot;, jarfile, &quot;-C&quot;, classes.resolve(&quot;base&quot;).toString(), &quot;.&quot;,</span>
139                     &quot;--release&quot;, release, &quot;-C&quot;, classes.resolve(&quot;v10&quot;).toString(), &quot;.&quot;)
140                     .shouldNotHaveExitValue(SUCCESS)
141                     .shouldContain(&quot;release &quot; + release + &quot; not valid&quot;);
142         }
143         FileUtils.deleteFileIfExistsWithRetry(Paths.get(jarfile));
144         FileUtils.deleteFileTreeWithRetry(Paths.get(usr, &quot;classes&quot;));
145     }
146 
147     @Test
148     // update a regular jar to a multi-release jar
149     public void test02() throws Throwable {
150         String jarfile = &quot;test.jar&quot;;
151 
152         compile(&quot;test01&quot;);  //use same data as test01
153 
154         Path classes = Paths.get(&quot;classes&quot;);
<span class="line-modified">155         jarTool(&quot;cf&quot;, jarfile, &quot;-C&quot;, classes.resolve(&quot;base&quot;).toString(), &quot;.&quot;)</span>
156                 .shouldHaveExitValue(SUCCESS);
157 
158         checkMultiRelease(jarfile, false);
159 
<span class="line-modified">160         jarTool(&quot;uf&quot;, jarfile,</span>
161                 &quot;--release&quot;, &quot;9&quot;, &quot;-C&quot;, classes.resolve(&quot;v9&quot;).toString(), &quot;.&quot;)
162                 .shouldHaveExitValue(SUCCESS);
163 
164         checkMultiRelease(jarfile, true);
165 
166         Map&lt;String, String[]&gt; names = Map.of(
167                 &quot;version/Main.class&quot;,
168                 new String[]{&quot;base&quot;, &quot;version&quot;, &quot;Main.class&quot;},
169 
170                 &quot;version/Version.class&quot;,
171                 new String[]{&quot;base&quot;, &quot;version&quot;, &quot;Version.class&quot;},
172 
173                 &quot;META-INF/versions/9/version/Version.class&quot;,
174                 new String[]{&quot;v9&quot;, &quot;version&quot;, &quot;Version.class&quot;}
175         );
176 
177         compare(jarfile, names);
178 
179         FileUtils.deleteFileIfExistsWithRetry(Paths.get(jarfile));
180         FileUtils.deleteFileTreeWithRetry(Paths.get(usr, &quot;classes&quot;));
181     }
182 
183     @Test
184     // replace a base entry and a versioned entry
185     public void test03() throws Throwable {
186         String jarfile = &quot;test.jar&quot;;
187 
188         compile(&quot;test01&quot;);  //use same data as test01
189 
190         Path classes = Paths.get(&quot;classes&quot;);
<span class="line-modified">191         jarTool(&quot;cf&quot;, jarfile, &quot;-C&quot;, classes.resolve(&quot;base&quot;).toString(), &quot;.&quot;,</span>
192                 &quot;--release&quot;, &quot;9&quot;, &quot;-C&quot;, classes.resolve(&quot;v9&quot;).toString(), &quot;.&quot;)
193                 .shouldHaveExitValue(SUCCESS);
194 
195         checkMultiRelease(jarfile, true);
196 
197         Map&lt;String, String[]&gt; names = Map.of(
198                 &quot;version/Main.class&quot;,
199                 new String[]{&quot;base&quot;, &quot;version&quot;, &quot;Main.class&quot;},
200 
201                 &quot;version/Version.class&quot;,
202                 new String[]{&quot;base&quot;, &quot;version&quot;, &quot;Version.class&quot;},
203 
204                 &quot;META-INF/versions/9/version/Version.class&quot;,
205                 new String[]{&quot;v9&quot;, &quot;version&quot;, &quot;Version.class&quot;}
206         );
207 
208         compare(jarfile, names);
209 
210         // write the v9 version/Version.class entry in base and the v10
211         // version/Version.class entry in versions/9 section
<span class="line-modified">212         jarTool(&quot;uf&quot;, jarfile, &quot;-C&quot;, classes.resolve(&quot;v9&quot;).toString(), &quot;version&quot;,</span>
213                 &quot;--release&quot;, &quot;9&quot;, &quot;-C&quot;, classes.resolve(&quot;v10&quot;).toString(), &quot;.&quot;)
214                 .shouldHaveExitValue(SUCCESS);
215 
216         checkMultiRelease(jarfile, true);
217 
218         names = Map.of(
219                 &quot;version/Main.class&quot;,
220                 new String[]{&quot;base&quot;, &quot;version&quot;, &quot;Main.class&quot;},
221 
222                 &quot;version/Version.class&quot;,
223                 new String[]{&quot;v9&quot;, &quot;version&quot;, &quot;Version.class&quot;},
224 
225                 &quot;META-INF/versions/9/version/Version.class&quot;,
226                 new String[]{&quot;v10&quot;, &quot;version&quot;, &quot;Version.class&quot;}
227         );
228 
229         compare(jarfile, names);
230 
231         FileUtils.deleteFileIfExistsWithRetry(Paths.get(jarfile));
232         FileUtils.deleteFileTreeWithRetry(Paths.get(usr, &quot;classes&quot;));
233     }
234 
235     /*
236      * The following tests exercise the jar validator
237      */
238 
239     @Test
240     // META-INF/versions/9 class has different api than base class
241     public void test04() throws Throwable {
242         String jarfile = &quot;test.jar&quot;;
243 
244         compile(&quot;test01&quot;);  //use same data as test01
245 
246         Path classes = Paths.get(&quot;classes&quot;);
247 
248         // replace the v9 class
249         Path source = Paths.get(src, &quot;data&quot;, &quot;test04&quot;, &quot;v9&quot;, &quot;version&quot;);
250         javac(classes.resolve(&quot;v9&quot;), source.resolve(&quot;Version.java&quot;));
251 
<span class="line-modified">252         jarTool(&quot;cf&quot;, jarfile, &quot;-C&quot;, classes.resolve(&quot;base&quot;).toString(), &quot;.&quot;,</span>
253                 &quot;--release&quot;, &quot;9&quot;, &quot;-C&quot;, classes.resolve(&quot;v9&quot;).toString(), &quot;.&quot;)
254                 .shouldNotHaveExitValue(SUCCESS)
255                 .shouldContain(&quot;different api from earlier&quot;);
256 
257         FileUtils.deleteFileIfExistsWithRetry(Paths.get(jarfile));
258         FileUtils.deleteFileTreeWithRetry(Paths.get(usr, &quot;classes&quot;));
259     }
260 
261     @Test
262     // META-INF/versions/9 contains an extra public class
263     public void test05() throws Throwable {
264         String jarfile = &quot;test.jar&quot;;
265 
266         compile(&quot;test01&quot;);  //use same data as test01
267 
268         Path classes = Paths.get(&quot;classes&quot;);
269 
270         // add the new v9 class
271         Path source = Paths.get(src, &quot;data&quot;, &quot;test05&quot;, &quot;v9&quot;, &quot;version&quot;);
272         javac(classes.resolve(&quot;v9&quot;), source.resolve(&quot;Extra.java&quot;));
273 
<span class="line-modified">274         jarTool(&quot;cf&quot;, jarfile, &quot;-C&quot;, classes.resolve(&quot;base&quot;).toString(), &quot;.&quot;,</span>
275                 &quot;--release&quot;, &quot;9&quot;, &quot;-C&quot;, classes.resolve(&quot;v9&quot;).toString(), &quot;.&quot;)
276                 .shouldNotHaveExitValue(SUCCESS)
277                 .shouldContain(&quot;contains a new public class&quot;);
278 
279         FileUtils.deleteFileIfExistsWithRetry(Paths.get(jarfile));
280         FileUtils.deleteFileTreeWithRetry(Paths.get(usr, &quot;classes&quot;));
281     }
282 
283     @Test
284     // META-INF/versions/9 contains an extra package private class -- this is okay
285     public void test06() throws Throwable {
286         String jarfile = &quot;test.jar&quot;;
287 
288         compile(&quot;test01&quot;);  //use same data as test01
289 
290         Path classes = Paths.get(&quot;classes&quot;);
291 
292         // add the new v9 class
293         Path source = Paths.get(src, &quot;data&quot;, &quot;test06&quot;, &quot;v9&quot;, &quot;version&quot;);
294         javac(classes.resolve(&quot;v9&quot;), source.resolve(&quot;Extra.java&quot;));
295 
<span class="line-modified">296         jarTool(&quot;cf&quot;, jarfile, &quot;-C&quot;, classes.resolve(&quot;base&quot;).toString(), &quot;.&quot;,</span>
297                 &quot;--release&quot;, &quot;9&quot;, &quot;-C&quot;, classes.resolve(&quot;v9&quot;).toString(), &quot;.&quot;)
298                 .shouldHaveExitValue(SUCCESS);
299 
300         FileUtils.deleteFileIfExistsWithRetry(Paths.get(jarfile));
301         FileUtils.deleteFileTreeWithRetry(Paths.get(usr, &quot;classes&quot;));
302     }
303 
304     @Test
305     // META-INF/versions/9 contains an identical class to base entry class
306     // this is okay but produces warning
307     public void test07() throws Throwable {
308         String jarfile = &quot;test.jar&quot;;
309 
310         compile(&quot;test01&quot;);  //use same data as test01
311 
312         Path classes = Paths.get(&quot;classes&quot;);
313 
314         // add the new v9 class
315         Path source = Paths.get(src, &quot;data&quot;, &quot;test01&quot;, &quot;base&quot;, &quot;version&quot;);
316         javac(classes.resolve(&quot;v9&quot;), source.resolve(&quot;Version.java&quot;));
317 
<span class="line-modified">318         jarTool(&quot;cf&quot;, jarfile, &quot;-C&quot;, classes.resolve(&quot;base&quot;).toString(), &quot;.&quot;,</span>
319                 &quot;--release&quot;, &quot;9&quot;, &quot;-C&quot;, classes.resolve(&quot;v9&quot;).toString(), &quot;.&quot;)
320                 .shouldHaveExitValue(SUCCESS)
321                 .shouldContain(&quot;contains a class that&quot;)
322                 .shouldContain(&quot;is identical&quot;);
323 
324         FileUtils.deleteFileIfExistsWithRetry(Paths.get(jarfile));
325         FileUtils.deleteFileTreeWithRetry(Paths.get(usr, &quot;classes&quot;));
326     }
327 
328     @Test
329     // META-INF/versions/9 contains an identical class to previous version entry class
330     // this is okay but produces warning
331     public void identicalClassToPreviousVersion() throws Throwable {
332         String jarfile = &quot;test.jar&quot;;
333 
334         compile(&quot;test01&quot;);  //use same data as test01
335 
336         Path classes = Paths.get(&quot;classes&quot;);
337 
<span class="line-modified">338         jarTool(&quot;cf&quot;, jarfile, &quot;-C&quot;, classes.resolve(&quot;base&quot;).toString(), &quot;.&quot;,</span>
339                 &quot;--release&quot;, &quot;9&quot;, &quot;-C&quot;, classes.resolve(&quot;v9&quot;).toString(), &quot;.&quot;)
340                 .shouldHaveExitValue(SUCCESS)
341                 .shouldBeEmptyIgnoreVMWarnings();
<span class="line-modified">342         jarTool(&quot;uf&quot;, jarfile,</span>
343                 &quot;--release&quot;, &quot;10&quot;, &quot;-C&quot;, classes.resolve(&quot;v9&quot;).toString(), &quot;.&quot;)
344                 .shouldHaveExitValue(SUCCESS)
345                 .shouldContain(&quot;contains a class that&quot;)
346                 .shouldContain(&quot;is identical&quot;);
347 
348         FileUtils.deleteFileIfExistsWithRetry(Paths.get(jarfile));
349         FileUtils.deleteFileTreeWithRetry(Paths.get(usr, &quot;classes&quot;));
350     }
351 
352     @Test
353     // a class with an internal name different from the external name
354     public void test09() throws Throwable {
355         String jarfile = &quot;test.jar&quot;;
356 
357         compile(&quot;test01&quot;);  //use same data as test01
358 
359         Path classes = Paths.get(&quot;classes&quot;);
360 
361         Path base = classes.resolve(&quot;base&quot;).resolve(&quot;version&quot;);
362 
363         Files.copy(base.resolve(&quot;Main.class&quot;), base.resolve(&quot;Foo.class&quot;));
364 
<span class="line-modified">365         jarTool(&quot;cf&quot;, jarfile, &quot;-C&quot;, classes.resolve(&quot;base&quot;).toString(), &quot;.&quot;,</span>
366                 &quot;--release&quot;, &quot;9&quot;, &quot;-C&quot;, classes.resolve(&quot;v9&quot;).toString(), &quot;.&quot;)
367                 .shouldNotHaveExitValue(SUCCESS)
368                 .shouldContain(&quot;names do not match&quot;);
369 
370         FileUtils.deleteFileIfExistsWithRetry(Paths.get(jarfile));
371         FileUtils.deleteFileTreeWithRetry(Paths.get(usr, &quot;classes&quot;));
372     }
373 
374     @Test
375     // assure that basic nested classes are acceptable
376     public void test10() throws Throwable {
377         String jarfile = &quot;test.jar&quot;;
378 
379         compile(&quot;test01&quot;);  //use same data as test01
380 
381         Path classes = Paths.get(&quot;classes&quot;);
382 
383         // add a base class with a nested class
384         Path source = Paths.get(src, &quot;data&quot;, &quot;test10&quot;, &quot;base&quot;, &quot;version&quot;);
385         javac(classes.resolve(&quot;base&quot;), source.resolve(&quot;Nested.java&quot;));
386 
387         // add a versioned class with a nested class
388         source = Paths.get(src, &quot;data&quot;, &quot;test10&quot;, &quot;v9&quot;, &quot;version&quot;);
389         javac(classes.resolve(&quot;v9&quot;), source.resolve(&quot;Nested.java&quot;));
390 
<span class="line-modified">391         jarTool(&quot;cf&quot;, jarfile, &quot;-C&quot;, classes.resolve(&quot;base&quot;).toString(), &quot;.&quot;,</span>
392                 &quot;--release&quot;, &quot;9&quot;, &quot;-C&quot;, classes.resolve(&quot;v9&quot;).toString(), &quot;.&quot;)
393                 .shouldHaveExitValue(SUCCESS);
394 
395         FileUtils.deleteFileIfExistsWithRetry(Paths.get(jarfile));
396         FileUtils.deleteFileTreeWithRetry(Paths.get(usr, &quot;classes&quot;));
397     }
398 
399     @Test
400     // a base entry contains a nested class that doesn&#39;t have a matching top level class
401     public void test11() throws Throwable {
402         String jarfile = &quot;test.jar&quot;;
403 
404         compile(&quot;test01&quot;);  //use same data as test01
405 
406         Path classes = Paths.get(&quot;classes&quot;);
407 
408         // add a base class with a nested class
409         Path source = Paths.get(src, &quot;data&quot;, &quot;test10&quot;, &quot;base&quot;, &quot;version&quot;);
410         javac(classes.resolve(&quot;base&quot;), source.resolve(&quot;Nested.java&quot;));
411 
412         // remove the top level class, thus isolating the nested class
413         Files.delete(classes.resolve(&quot;base&quot;).resolve(&quot;version&quot;).resolve(&quot;Nested.class&quot;));
414 
415         // add a versioned class with a nested class
416         source = Paths.get(src, &quot;data&quot;, &quot;test10&quot;, &quot;v9&quot;, &quot;version&quot;);
417         javac(classes.resolve(&quot;v9&quot;), source.resolve(&quot;Nested.java&quot;));
418 
<span class="line-modified">419         List&lt;String&gt; output = jarTool(&quot;cf&quot;, jarfile,</span>
420                 &quot;-C&quot;, classes.resolve(&quot;base&quot;).toString(), &quot;.&quot;,
421                 &quot;--release&quot;, &quot;9&quot;, &quot;-C&quot;, classes.resolve(&quot;v9&quot;).toString(), &quot;.&quot;)
422                 .shouldNotHaveExitValue(SUCCESS)
423                 .asLinesWithoutVMWarnings();
424 
425         /* &quot;META-INF/versions/9/version/Nested$nested.class&quot; is really NOT isolated
426         assertTrue(output.size() == 4);
427         assertTrue(output.size() == 3);
428         assertTrue(output.get(0).contains(&quot;an isolated nested class&quot;),
429                 output.get(0));
430         assertTrue(output.get(1).contains(&quot;contains a new public class&quot;),
431                 output.get(1));
432         assertTrue(output.get(2).contains(&quot;an isolated nested class&quot;),
433                 output.get(2));
434         assertTrue(output.get(3).contains(&quot;invalid multi-release jar file&quot;),
435                 output.get(3));
436         assertTrue(output.get(2).contains(&quot;invalid multi-release jar file&quot;),
437                output.get(2));
438         */
439 
</pre>
<hr />
<pre>
452     @Test
453     // a versioned entry contains a nested class that doesn&#39;t have a matching top level class
454     public void test12() throws Throwable {
455         String jarfile = &quot;test.jar&quot;;
456 
457         compile(&quot;test01&quot;);  //use same data as test01
458 
459         Path classes = Paths.get(&quot;classes&quot;);
460 
461         // add a base class with a nested class
462         Path source = Paths.get(src, &quot;data&quot;, &quot;test10&quot;, &quot;base&quot;, &quot;version&quot;);
463         javac(classes.resolve(&quot;base&quot;), source.resolve(&quot;Nested.java&quot;));
464 
465         // add a versioned class with a nested class
466         source = Paths.get(src, &quot;data&quot;, &quot;test10&quot;, &quot;v9&quot;, &quot;version&quot;);
467         javac(classes.resolve(&quot;v9&quot;), source.resolve(&quot;Nested.java&quot;));
468 
469         // remove the top level class, thus isolating the nested class
470         Files.delete(classes.resolve(&quot;v9&quot;).resolve(&quot;version&quot;).resolve(&quot;Nested.class&quot;));
471 
<span class="line-modified">472         jarTool(&quot;cf&quot;, jarfile, &quot;-C&quot;, classes.resolve(&quot;base&quot;).toString(), &quot;.&quot;,</span>
473                 &quot;--release&quot;, &quot;9&quot;, &quot;-C&quot;, classes.resolve(&quot;v9&quot;).toString(), &quot;.&quot;)
474                 .shouldNotHaveExitValue(SUCCESS)
475                 .shouldContain(&quot;an isolated nested class&quot;);
476 
477         FileUtils.deleteFileIfExistsWithRetry(Paths.get(jarfile));
478         FileUtils.deleteFileTreeWithRetry(Paths.get(usr, &quot;classes&quot;));
479     }
480 
481     @Test
482     // assure the nested-nested classes are acceptable
483     public void test13() throws Throwable {
484         String jarfile = &quot;test.jar&quot;;
485 
486         compile(&quot;test01&quot;);  //use same data as test01
487 
488         Path classes = Paths.get(&quot;classes&quot;);
489 
490         // add a base class with a nested and nested-nested class
491         Path source = Paths.get(src, &quot;data&quot;, &quot;test13&quot;, &quot;base&quot;, &quot;version&quot;);
492         javac(classes.resolve(&quot;base&quot;), source.resolve(&quot;Nested.java&quot;));
493 
494         // add a versioned class with a nested and nested-nested class
495         source = Paths.get(src, &quot;data&quot;, &quot;test13&quot;, &quot;v10&quot;, &quot;version&quot;);
496         javac(classes.resolve(&quot;v10&quot;), source.resolve(&quot;Nested.java&quot;));
497 
<span class="line-modified">498         jarTool(&quot;cf&quot;, jarfile, &quot;-C&quot;, classes.resolve(&quot;base&quot;).toString(), &quot;.&quot;,</span>
499                 &quot;--release&quot;, &quot;10&quot;, &quot;-C&quot;, classes.resolve(&quot;v10&quot;).toString(), &quot;.&quot;)
500                 .shouldHaveExitValue(SUCCESS);
501 
502         FileUtils.deleteFileIfExistsWithRetry(Paths.get(jarfile));
503         FileUtils.deleteFileTreeWithRetry(Paths.get(usr, &quot;classes&quot;));
504     }
505 
506     @Test
507     public void testCustomManifest() throws Throwable {
508         String jarfile = &quot;test.jar&quot;;
509 
510         compile(&quot;test01&quot;);
511 
512         Path classes = Paths.get(&quot;classes&quot;);
513         Path manifest = Paths.get(&quot;Manifest.txt&quot;);
514 
515         // create
516         Files.write(manifest, &quot;Class-Path: MyUtils.jar\n&quot;.getBytes());
517 
<span class="line-modified">518         jarTool(&quot;cfm&quot;, jarfile, manifest.toString(),</span>
519                 &quot;-C&quot;, classes.resolve(&quot;base&quot;).toString(), &quot;.&quot;,
520                 &quot;--release&quot;, &quot;10&quot;, &quot;-C&quot;, classes.resolve(&quot;v10&quot;).toString(), &quot;.&quot;)
521                 .shouldHaveExitValue(SUCCESS)
522                 .shouldBeEmptyIgnoreVMWarnings();
523 
524         try (JarFile jf = new JarFile(new File(jarfile), true,
525                 ZipFile.OPEN_READ, JarFile.runtimeVersion())) {
526             assertTrue(jf.isMultiRelease(), &quot;Not multi-release jar&quot;);
527             assertEquals(jf.getManifest()
528                             .getMainAttributes()
529                             .getValue(&quot;Class-Path&quot;),
530                     &quot;MyUtils.jar&quot;);
531         }
532 
533         // update
534         Files.write(manifest, &quot;Multi-release: false\n&quot;.getBytes());
535 
536         jar(&quot;ufm&quot;, jarfile, manifest.toString(),
537                 &quot;-C&quot;, classes.resolve(&quot;base&quot;).toString(), &quot;.&quot;,
538                 &quot;--release&quot;, &quot;9&quot;, &quot;-C&quot;, classes.resolve(&quot;v10&quot;).toString(), &quot;.&quot;)
</pre>
</td>
</tr>
</table>
<center><a href="../modularJar/Basic.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="MRTestBase.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
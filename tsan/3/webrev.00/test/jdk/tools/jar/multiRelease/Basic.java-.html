<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old test/jdk/tools/jar/multiRelease/Basic.java</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2016, 2017, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 /*
 25  * @test
 26  # @bug 8186087 8196748
 27  * @library /test/lib
 28  * @modules java.base/jdk.internal.misc
 29  *          jdk.compiler
 30  *          jdk.jartool
 31  * @build jdk.test.lib.util.FileUtils
 32  *        jdk.test.lib.Utils
 33  *        jdk.test.lib.Asserts
 34  *        jdk.test.lib.JDKToolFinder
 35  *        jdk.test.lib.JDKToolLauncher
 36  *        jdk.test.lib.Platform
 37  *        jdk.test.lib.process.*
 38  *        MRTestBase
 39  * @run testng Basic
 40  */
 41 
 42 import static org.testng.Assert.*;
 43 
 44 import jdk.test.lib.util.FileUtils;
 45 import org.testng.annotations.*;
 46 
 47 import java.io.File;
 48 import java.nio.file.*;
 49 import java.util.*;
 50 import java.util.jar.JarFile;
 51 import java.util.zip.ZipFile;
 52 
 53 public class Basic extends MRTestBase {
 54 
 55     @Test
 56     // create a regular, non-multi-release jar
 57     public void test00() throws Throwable {
 58         String jarfile = &quot;test.jar&quot;;
 59 
 60         compile(&quot;test01&quot;);  //use same data as test01
 61 
 62         Path classes = Paths.get(&quot;classes&quot;);
 63         jar(&quot;cf&quot;, jarfile, &quot;-C&quot;, classes.resolve(&quot;base&quot;).toString(), &quot;.&quot;)
 64                 .shouldHaveExitValue(SUCCESS);
 65 
 66         checkMultiRelease(jarfile, false);
 67 
 68         Map&lt;String, String[]&gt; names = Map.of(
 69                 &quot;version/Main.class&quot;,
 70                 new String[]{&quot;base&quot;, &quot;version&quot;, &quot;Main.class&quot;},
 71 
 72                 &quot;version/Version.class&quot;,
 73                 new String[]{&quot;base&quot;, &quot;version&quot;, &quot;Version.class&quot;}
 74         );
 75 
 76         compare(jarfile, names);
 77 
 78         FileUtils.deleteFileIfExistsWithRetry(Paths.get(jarfile));
 79         FileUtils.deleteFileTreeWithRetry(Paths.get(usr, &quot;classes&quot;));
 80     }
 81 
 82     @Test
 83     // create a multi-release jar
 84     public void test01() throws Throwable {
 85         String jarfile = &quot;test.jar&quot;;
 86 
 87         compile(&quot;test01&quot;);
 88 
 89         Path classes = Paths.get(&quot;classes&quot;);
 90         jar(&quot;cf&quot;, jarfile, &quot;-C&quot;, classes.resolve(&quot;base&quot;).toString(), &quot;.&quot;,
 91                 &quot;--release&quot;, &quot;9&quot;, &quot;-C&quot;, classes.resolve(&quot;v9&quot;).toString(), &quot;.&quot;,
 92                 &quot;--release&quot;, &quot;10&quot;, &quot;-C&quot;, classes.resolve(&quot;v10&quot;).toString(), &quot;.&quot;)
 93                 .shouldHaveExitValue(SUCCESS);
 94 
 95         checkMultiRelease(jarfile, true);
 96 
 97         Map&lt;String, String[]&gt; names = Map.of(
 98                 &quot;version/Main.class&quot;,
 99                 new String[]{&quot;base&quot;, &quot;version&quot;, &quot;Main.class&quot;},
100 
101                 &quot;version/Version.class&quot;,
102                 new String[]{&quot;base&quot;, &quot;version&quot;, &quot;Version.class&quot;},
103 
104                 &quot;META-INF/versions/9/version/Version.class&quot;,
105                 new String[]{&quot;v9&quot;, &quot;version&quot;, &quot;Version.class&quot;},
106 
107                 &quot;META-INF/versions/10/version/Version.class&quot;,
108                 new String[]{&quot;v10&quot;, &quot;version&quot;, &quot;Version.class&quot;}
109         );
110 
111         compare(jarfile, names);
112 
113         FileUtils.deleteFileIfExistsWithRetry(Paths.get(jarfile));
114         FileUtils.deleteFileTreeWithRetry(Paths.get(usr, &quot;classes&quot;));
115     }
116 
117     @Test
118     public void versionFormat() throws Throwable {
119         String jarfile = &quot;test.jar&quot;;
120 
121         compile(&quot;test01&quot;);
122 
123         Path classes = Paths.get(&quot;classes&quot;);
124 
125         // valid
126         for (String release : List.of(&quot;10000&quot;, &quot;09&quot;, &quot;00010&quot;, &quot;10&quot;)) {
127             jar(&quot;cf&quot;, jarfile, &quot;-C&quot;, classes.resolve(&quot;base&quot;).toString(), &quot;.&quot;,
128                     &quot;--release&quot;, release, &quot;-C&quot;, classes.resolve(&quot;v10&quot;).toString(), &quot;.&quot;)
129                     .shouldHaveExitValue(SUCCESS)
130                     .shouldBeEmptyIgnoreVMWarnings();
131         }
132         // invalid
133         for (String release : List.of(&quot;9.0&quot;, &quot;8&quot;, &quot;v9&quot;,
134                 &quot;9v&quot;, &quot;0&quot;, &quot;-10&quot;)) {
135             jar(&quot;cf&quot;, jarfile, &quot;-C&quot;, classes.resolve(&quot;base&quot;).toString(), &quot;.&quot;,
136                     &quot;--release&quot;, release, &quot;-C&quot;, classes.resolve(&quot;v10&quot;).toString(), &quot;.&quot;)
137                     .shouldNotHaveExitValue(SUCCESS)
138                     .shouldContain(&quot;release &quot; + release + &quot; not valid&quot;);
139         }
140         FileUtils.deleteFileIfExistsWithRetry(Paths.get(jarfile));
141         FileUtils.deleteFileTreeWithRetry(Paths.get(usr, &quot;classes&quot;));
142     }
143 
144     @Test
145     // update a regular jar to a multi-release jar
146     public void test02() throws Throwable {
147         String jarfile = &quot;test.jar&quot;;
148 
149         compile(&quot;test01&quot;);  //use same data as test01
150 
151         Path classes = Paths.get(&quot;classes&quot;);
152         jar(&quot;cf&quot;, jarfile, &quot;-C&quot;, classes.resolve(&quot;base&quot;).toString(), &quot;.&quot;)
153                 .shouldHaveExitValue(SUCCESS);
154 
155         checkMultiRelease(jarfile, false);
156 
157         jar(&quot;uf&quot;, jarfile,
158                 &quot;--release&quot;, &quot;9&quot;, &quot;-C&quot;, classes.resolve(&quot;v9&quot;).toString(), &quot;.&quot;)
159                 .shouldHaveExitValue(SUCCESS);
160 
161         checkMultiRelease(jarfile, true);
162 
163         Map&lt;String, String[]&gt; names = Map.of(
164                 &quot;version/Main.class&quot;,
165                 new String[]{&quot;base&quot;, &quot;version&quot;, &quot;Main.class&quot;},
166 
167                 &quot;version/Version.class&quot;,
168                 new String[]{&quot;base&quot;, &quot;version&quot;, &quot;Version.class&quot;},
169 
170                 &quot;META-INF/versions/9/version/Version.class&quot;,
171                 new String[]{&quot;v9&quot;, &quot;version&quot;, &quot;Version.class&quot;}
172         );
173 
174         compare(jarfile, names);
175 
176         FileUtils.deleteFileIfExistsWithRetry(Paths.get(jarfile));
177         FileUtils.deleteFileTreeWithRetry(Paths.get(usr, &quot;classes&quot;));
178     }
179 
180     @Test
181     // replace a base entry and a versioned entry
182     public void test03() throws Throwable {
183         String jarfile = &quot;test.jar&quot;;
184 
185         compile(&quot;test01&quot;);  //use same data as test01
186 
187         Path classes = Paths.get(&quot;classes&quot;);
188         jar(&quot;cf&quot;, jarfile, &quot;-C&quot;, classes.resolve(&quot;base&quot;).toString(), &quot;.&quot;,
189                 &quot;--release&quot;, &quot;9&quot;, &quot;-C&quot;, classes.resolve(&quot;v9&quot;).toString(), &quot;.&quot;)
190                 .shouldHaveExitValue(SUCCESS);
191 
192         checkMultiRelease(jarfile, true);
193 
194         Map&lt;String, String[]&gt; names = Map.of(
195                 &quot;version/Main.class&quot;,
196                 new String[]{&quot;base&quot;, &quot;version&quot;, &quot;Main.class&quot;},
197 
198                 &quot;version/Version.class&quot;,
199                 new String[]{&quot;base&quot;, &quot;version&quot;, &quot;Version.class&quot;},
200 
201                 &quot;META-INF/versions/9/version/Version.class&quot;,
202                 new String[]{&quot;v9&quot;, &quot;version&quot;, &quot;Version.class&quot;}
203         );
204 
205         compare(jarfile, names);
206 
207         // write the v9 version/Version.class entry in base and the v10
208         // version/Version.class entry in versions/9 section
209         jar(&quot;uf&quot;, jarfile, &quot;-C&quot;, classes.resolve(&quot;v9&quot;).toString(), &quot;version&quot;,
210                 &quot;--release&quot;, &quot;9&quot;, &quot;-C&quot;, classes.resolve(&quot;v10&quot;).toString(), &quot;.&quot;)
211                 .shouldHaveExitValue(SUCCESS);
212 
213         checkMultiRelease(jarfile, true);
214 
215         names = Map.of(
216                 &quot;version/Main.class&quot;,
217                 new String[]{&quot;base&quot;, &quot;version&quot;, &quot;Main.class&quot;},
218 
219                 &quot;version/Version.class&quot;,
220                 new String[]{&quot;v9&quot;, &quot;version&quot;, &quot;Version.class&quot;},
221 
222                 &quot;META-INF/versions/9/version/Version.class&quot;,
223                 new String[]{&quot;v10&quot;, &quot;version&quot;, &quot;Version.class&quot;}
224         );
225 
226         compare(jarfile, names);
227 
228         FileUtils.deleteFileIfExistsWithRetry(Paths.get(jarfile));
229         FileUtils.deleteFileTreeWithRetry(Paths.get(usr, &quot;classes&quot;));
230     }
231 
232     /*
233      * The following tests exercise the jar validator
234      */
235 
236     @Test
237     // META-INF/versions/9 class has different api than base class
238     public void test04() throws Throwable {
239         String jarfile = &quot;test.jar&quot;;
240 
241         compile(&quot;test01&quot;);  //use same data as test01
242 
243         Path classes = Paths.get(&quot;classes&quot;);
244 
245         // replace the v9 class
246         Path source = Paths.get(src, &quot;data&quot;, &quot;test04&quot;, &quot;v9&quot;, &quot;version&quot;);
247         javac(classes.resolve(&quot;v9&quot;), source.resolve(&quot;Version.java&quot;));
248 
249         jar(&quot;cf&quot;, jarfile, &quot;-C&quot;, classes.resolve(&quot;base&quot;).toString(), &quot;.&quot;,
250                 &quot;--release&quot;, &quot;9&quot;, &quot;-C&quot;, classes.resolve(&quot;v9&quot;).toString(), &quot;.&quot;)
251                 .shouldNotHaveExitValue(SUCCESS)
252                 .shouldContain(&quot;different api from earlier&quot;);
253 
254         FileUtils.deleteFileIfExistsWithRetry(Paths.get(jarfile));
255         FileUtils.deleteFileTreeWithRetry(Paths.get(usr, &quot;classes&quot;));
256     }
257 
258     @Test
259     // META-INF/versions/9 contains an extra public class
260     public void test05() throws Throwable {
261         String jarfile = &quot;test.jar&quot;;
262 
263         compile(&quot;test01&quot;);  //use same data as test01
264 
265         Path classes = Paths.get(&quot;classes&quot;);
266 
267         // add the new v9 class
268         Path source = Paths.get(src, &quot;data&quot;, &quot;test05&quot;, &quot;v9&quot;, &quot;version&quot;);
269         javac(classes.resolve(&quot;v9&quot;), source.resolve(&quot;Extra.java&quot;));
270 
271         jar(&quot;cf&quot;, jarfile, &quot;-C&quot;, classes.resolve(&quot;base&quot;).toString(), &quot;.&quot;,
272                 &quot;--release&quot;, &quot;9&quot;, &quot;-C&quot;, classes.resolve(&quot;v9&quot;).toString(), &quot;.&quot;)
273                 .shouldNotHaveExitValue(SUCCESS)
274                 .shouldContain(&quot;contains a new public class&quot;);
275 
276         FileUtils.deleteFileIfExistsWithRetry(Paths.get(jarfile));
277         FileUtils.deleteFileTreeWithRetry(Paths.get(usr, &quot;classes&quot;));
278     }
279 
280     @Test
281     // META-INF/versions/9 contains an extra package private class -- this is okay
282     public void test06() throws Throwable {
283         String jarfile = &quot;test.jar&quot;;
284 
285         compile(&quot;test01&quot;);  //use same data as test01
286 
287         Path classes = Paths.get(&quot;classes&quot;);
288 
289         // add the new v9 class
290         Path source = Paths.get(src, &quot;data&quot;, &quot;test06&quot;, &quot;v9&quot;, &quot;version&quot;);
291         javac(classes.resolve(&quot;v9&quot;), source.resolve(&quot;Extra.java&quot;));
292 
293         jar(&quot;cf&quot;, jarfile, &quot;-C&quot;, classes.resolve(&quot;base&quot;).toString(), &quot;.&quot;,
294                 &quot;--release&quot;, &quot;9&quot;, &quot;-C&quot;, classes.resolve(&quot;v9&quot;).toString(), &quot;.&quot;)
295                 .shouldHaveExitValue(SUCCESS);
296 
297         FileUtils.deleteFileIfExistsWithRetry(Paths.get(jarfile));
298         FileUtils.deleteFileTreeWithRetry(Paths.get(usr, &quot;classes&quot;));
299     }
300 
301     @Test
302     // META-INF/versions/9 contains an identical class to base entry class
303     // this is okay but produces warning
304     public void test07() throws Throwable {
305         String jarfile = &quot;test.jar&quot;;
306 
307         compile(&quot;test01&quot;);  //use same data as test01
308 
309         Path classes = Paths.get(&quot;classes&quot;);
310 
311         // add the new v9 class
312         Path source = Paths.get(src, &quot;data&quot;, &quot;test01&quot;, &quot;base&quot;, &quot;version&quot;);
313         javac(classes.resolve(&quot;v9&quot;), source.resolve(&quot;Version.java&quot;));
314 
315         jar(&quot;cf&quot;, jarfile, &quot;-C&quot;, classes.resolve(&quot;base&quot;).toString(), &quot;.&quot;,
316                 &quot;--release&quot;, &quot;9&quot;, &quot;-C&quot;, classes.resolve(&quot;v9&quot;).toString(), &quot;.&quot;)
317                 .shouldHaveExitValue(SUCCESS)
318                 .shouldContain(&quot;contains a class that&quot;)
319                 .shouldContain(&quot;is identical&quot;);
320 
321         FileUtils.deleteFileIfExistsWithRetry(Paths.get(jarfile));
322         FileUtils.deleteFileTreeWithRetry(Paths.get(usr, &quot;classes&quot;));
323     }
324 
325     @Test
326     // META-INF/versions/9 contains an identical class to previous version entry class
327     // this is okay but produces warning
328     public void identicalClassToPreviousVersion() throws Throwable {
329         String jarfile = &quot;test.jar&quot;;
330 
331         compile(&quot;test01&quot;);  //use same data as test01
332 
333         Path classes = Paths.get(&quot;classes&quot;);
334 
335         jar(&quot;cf&quot;, jarfile, &quot;-C&quot;, classes.resolve(&quot;base&quot;).toString(), &quot;.&quot;,
336                 &quot;--release&quot;, &quot;9&quot;, &quot;-C&quot;, classes.resolve(&quot;v9&quot;).toString(), &quot;.&quot;)
337                 .shouldHaveExitValue(SUCCESS)
338                 .shouldBeEmptyIgnoreVMWarnings();
339         jar(&quot;uf&quot;, jarfile,
340                 &quot;--release&quot;, &quot;10&quot;, &quot;-C&quot;, classes.resolve(&quot;v9&quot;).toString(), &quot;.&quot;)
341                 .shouldHaveExitValue(SUCCESS)
342                 .shouldContain(&quot;contains a class that&quot;)
343                 .shouldContain(&quot;is identical&quot;);
344 
345         FileUtils.deleteFileIfExistsWithRetry(Paths.get(jarfile));
346         FileUtils.deleteFileTreeWithRetry(Paths.get(usr, &quot;classes&quot;));
347     }
348 
349     @Test
350     // a class with an internal name different from the external name
351     public void test09() throws Throwable {
352         String jarfile = &quot;test.jar&quot;;
353 
354         compile(&quot;test01&quot;);  //use same data as test01
355 
356         Path classes = Paths.get(&quot;classes&quot;);
357 
358         Path base = classes.resolve(&quot;base&quot;).resolve(&quot;version&quot;);
359 
360         Files.copy(base.resolve(&quot;Main.class&quot;), base.resolve(&quot;Foo.class&quot;));
361 
362         jar(&quot;cf&quot;, jarfile, &quot;-C&quot;, classes.resolve(&quot;base&quot;).toString(), &quot;.&quot;,
363                 &quot;--release&quot;, &quot;9&quot;, &quot;-C&quot;, classes.resolve(&quot;v9&quot;).toString(), &quot;.&quot;)
364                 .shouldNotHaveExitValue(SUCCESS)
365                 .shouldContain(&quot;names do not match&quot;);
366 
367         FileUtils.deleteFileIfExistsWithRetry(Paths.get(jarfile));
368         FileUtils.deleteFileTreeWithRetry(Paths.get(usr, &quot;classes&quot;));
369     }
370 
371     @Test
372     // assure that basic nested classes are acceptable
373     public void test10() throws Throwable {
374         String jarfile = &quot;test.jar&quot;;
375 
376         compile(&quot;test01&quot;);  //use same data as test01
377 
378         Path classes = Paths.get(&quot;classes&quot;);
379 
380         // add a base class with a nested class
381         Path source = Paths.get(src, &quot;data&quot;, &quot;test10&quot;, &quot;base&quot;, &quot;version&quot;);
382         javac(classes.resolve(&quot;base&quot;), source.resolve(&quot;Nested.java&quot;));
383 
384         // add a versioned class with a nested class
385         source = Paths.get(src, &quot;data&quot;, &quot;test10&quot;, &quot;v9&quot;, &quot;version&quot;);
386         javac(classes.resolve(&quot;v9&quot;), source.resolve(&quot;Nested.java&quot;));
387 
388         jar(&quot;cf&quot;, jarfile, &quot;-C&quot;, classes.resolve(&quot;base&quot;).toString(), &quot;.&quot;,
389                 &quot;--release&quot;, &quot;9&quot;, &quot;-C&quot;, classes.resolve(&quot;v9&quot;).toString(), &quot;.&quot;)
390                 .shouldHaveExitValue(SUCCESS);
391 
392         FileUtils.deleteFileIfExistsWithRetry(Paths.get(jarfile));
393         FileUtils.deleteFileTreeWithRetry(Paths.get(usr, &quot;classes&quot;));
394     }
395 
396     @Test
397     // a base entry contains a nested class that doesn&#39;t have a matching top level class
398     public void test11() throws Throwable {
399         String jarfile = &quot;test.jar&quot;;
400 
401         compile(&quot;test01&quot;);  //use same data as test01
402 
403         Path classes = Paths.get(&quot;classes&quot;);
404 
405         // add a base class with a nested class
406         Path source = Paths.get(src, &quot;data&quot;, &quot;test10&quot;, &quot;base&quot;, &quot;version&quot;);
407         javac(classes.resolve(&quot;base&quot;), source.resolve(&quot;Nested.java&quot;));
408 
409         // remove the top level class, thus isolating the nested class
410         Files.delete(classes.resolve(&quot;base&quot;).resolve(&quot;version&quot;).resolve(&quot;Nested.class&quot;));
411 
412         // add a versioned class with a nested class
413         source = Paths.get(src, &quot;data&quot;, &quot;test10&quot;, &quot;v9&quot;, &quot;version&quot;);
414         javac(classes.resolve(&quot;v9&quot;), source.resolve(&quot;Nested.java&quot;));
415 
416         List&lt;String&gt; output = jar(&quot;cf&quot;, jarfile,
417                 &quot;-C&quot;, classes.resolve(&quot;base&quot;).toString(), &quot;.&quot;,
418                 &quot;--release&quot;, &quot;9&quot;, &quot;-C&quot;, classes.resolve(&quot;v9&quot;).toString(), &quot;.&quot;)
419                 .shouldNotHaveExitValue(SUCCESS)
420                 .asLinesWithoutVMWarnings();
421 
422         /* &quot;META-INF/versions/9/version/Nested$nested.class&quot; is really NOT isolated
423         assertTrue(output.size() == 4);
424         assertTrue(output.size() == 3);
425         assertTrue(output.get(0).contains(&quot;an isolated nested class&quot;),
426                 output.get(0));
427         assertTrue(output.get(1).contains(&quot;contains a new public class&quot;),
428                 output.get(1));
429         assertTrue(output.get(2).contains(&quot;an isolated nested class&quot;),
430                 output.get(2));
431         assertTrue(output.get(3).contains(&quot;invalid multi-release jar file&quot;),
432                 output.get(3));
433         assertTrue(output.get(2).contains(&quot;invalid multi-release jar file&quot;),
434                output.get(2));
435         */
436 
437         assertTrue(output.size() == 3);
438         assertTrue(output.get(0).contains(&quot;an isolated nested class&quot;),
439                 output.get(0));
440         assertTrue(output.get(1).contains(&quot;contains a new public class&quot;),
441                 output.get(1));
442         assertTrue(output.get(2).contains(&quot;invalid multi-release jar file&quot;),
443                output.get(2));
444 
445         FileUtils.deleteFileIfExistsWithRetry(Paths.get(jarfile));
446         FileUtils.deleteFileTreeWithRetry(Paths.get(usr, &quot;classes&quot;));
447     }
448 
449     @Test
450     // a versioned entry contains a nested class that doesn&#39;t have a matching top level class
451     public void test12() throws Throwable {
452         String jarfile = &quot;test.jar&quot;;
453 
454         compile(&quot;test01&quot;);  //use same data as test01
455 
456         Path classes = Paths.get(&quot;classes&quot;);
457 
458         // add a base class with a nested class
459         Path source = Paths.get(src, &quot;data&quot;, &quot;test10&quot;, &quot;base&quot;, &quot;version&quot;);
460         javac(classes.resolve(&quot;base&quot;), source.resolve(&quot;Nested.java&quot;));
461 
462         // add a versioned class with a nested class
463         source = Paths.get(src, &quot;data&quot;, &quot;test10&quot;, &quot;v9&quot;, &quot;version&quot;);
464         javac(classes.resolve(&quot;v9&quot;), source.resolve(&quot;Nested.java&quot;));
465 
466         // remove the top level class, thus isolating the nested class
467         Files.delete(classes.resolve(&quot;v9&quot;).resolve(&quot;version&quot;).resolve(&quot;Nested.class&quot;));
468 
469         jar(&quot;cf&quot;, jarfile, &quot;-C&quot;, classes.resolve(&quot;base&quot;).toString(), &quot;.&quot;,
470                 &quot;--release&quot;, &quot;9&quot;, &quot;-C&quot;, classes.resolve(&quot;v9&quot;).toString(), &quot;.&quot;)
471                 .shouldNotHaveExitValue(SUCCESS)
472                 .shouldContain(&quot;an isolated nested class&quot;);
473 
474         FileUtils.deleteFileIfExistsWithRetry(Paths.get(jarfile));
475         FileUtils.deleteFileTreeWithRetry(Paths.get(usr, &quot;classes&quot;));
476     }
477 
478     @Test
479     // assure the nested-nested classes are acceptable
480     public void test13() throws Throwable {
481         String jarfile = &quot;test.jar&quot;;
482 
483         compile(&quot;test01&quot;);  //use same data as test01
484 
485         Path classes = Paths.get(&quot;classes&quot;);
486 
487         // add a base class with a nested and nested-nested class
488         Path source = Paths.get(src, &quot;data&quot;, &quot;test13&quot;, &quot;base&quot;, &quot;version&quot;);
489         javac(classes.resolve(&quot;base&quot;), source.resolve(&quot;Nested.java&quot;));
490 
491         // add a versioned class with a nested and nested-nested class
492         source = Paths.get(src, &quot;data&quot;, &quot;test13&quot;, &quot;v10&quot;, &quot;version&quot;);
493         javac(classes.resolve(&quot;v10&quot;), source.resolve(&quot;Nested.java&quot;));
494 
495         jar(&quot;cf&quot;, jarfile, &quot;-C&quot;, classes.resolve(&quot;base&quot;).toString(), &quot;.&quot;,
496                 &quot;--release&quot;, &quot;10&quot;, &quot;-C&quot;, classes.resolve(&quot;v10&quot;).toString(), &quot;.&quot;)
497                 .shouldHaveExitValue(SUCCESS);
498 
499         FileUtils.deleteFileIfExistsWithRetry(Paths.get(jarfile));
500         FileUtils.deleteFileTreeWithRetry(Paths.get(usr, &quot;classes&quot;));
501     }
502 
503     @Test
504     public void testCustomManifest() throws Throwable {
505         String jarfile = &quot;test.jar&quot;;
506 
507         compile(&quot;test01&quot;);
508 
509         Path classes = Paths.get(&quot;classes&quot;);
510         Path manifest = Paths.get(&quot;Manifest.txt&quot;);
511 
512         // create
513         Files.write(manifest, &quot;Class-Path: MyUtils.jar\n&quot;.getBytes());
514 
515         jar(&quot;cfm&quot;, jarfile, manifest.toString(),
516                 &quot;-C&quot;, classes.resolve(&quot;base&quot;).toString(), &quot;.&quot;,
517                 &quot;--release&quot;, &quot;10&quot;, &quot;-C&quot;, classes.resolve(&quot;v10&quot;).toString(), &quot;.&quot;)
518                 .shouldHaveExitValue(SUCCESS)
519                 .shouldBeEmptyIgnoreVMWarnings();
520 
521         try (JarFile jf = new JarFile(new File(jarfile), true,
522                 ZipFile.OPEN_READ, JarFile.runtimeVersion())) {
523             assertTrue(jf.isMultiRelease(), &quot;Not multi-release jar&quot;);
524             assertEquals(jf.getManifest()
525                             .getMainAttributes()
526                             .getValue(&quot;Class-Path&quot;),
527                     &quot;MyUtils.jar&quot;);
528         }
529 
530         // update
531         Files.write(manifest, &quot;Multi-release: false\n&quot;.getBytes());
532 
533         jar(&quot;ufm&quot;, jarfile, manifest.toString(),
534                 &quot;-C&quot;, classes.resolve(&quot;base&quot;).toString(), &quot;.&quot;,
535                 &quot;--release&quot;, &quot;9&quot;, &quot;-C&quot;, classes.resolve(&quot;v10&quot;).toString(), &quot;.&quot;)
536                 .shouldHaveExitValue(SUCCESS)
537                 .shouldContain(&quot;WARNING: Duplicate name in Manifest: Multi-release.&quot;);
538 
539         try (JarFile jf = new JarFile(new File(jarfile), true,
540                 ZipFile.OPEN_READ, JarFile.runtimeVersion())) {
541             assertTrue(jf.isMultiRelease(), &quot;Not multi-release jar&quot;);
542             assertEquals(jf.getManifest()
543                             .getMainAttributes()
544                             .getValue(&quot;Class-Path&quot;),
545                     &quot;MyUtils.jar&quot;);
546         }
547 
548         FileUtils.deleteFileIfExistsWithRetry(Paths.get(jarfile));
549         FileUtils.deleteFileTreeWithRetry(Paths.get(usr, &quot;classes&quot;));
550     }
551 }
    </pre>
  </body>
</html>
diff a/test/jdk/tools/jar/modularJar/Basic.java b/test/jdk/tools/jar/modularJar/Basic.java
--- a/test/jdk/tools/jar/modularJar/Basic.java
+++ b/test/jdk/tools/jar/modularJar/Basic.java
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2015, 2018, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2015, 2019, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.
@@ -22,18 +22,21 @@
  */
 
 import java.io.*;
 import java.lang.module.ModuleDescriptor;
 import java.lang.reflect.Method;
-import java.nio.file.*;
+import java.nio.file.Files;
+import java.nio.file.Path;
+import java.nio.file.Paths;
 import java.util.*;
 import java.util.function.Consumer;
 import java.util.jar.JarEntry;
 import java.util.jar.JarFile;
 import java.util.jar.JarInputStream;
 import java.util.jar.Manifest;
 import java.util.regex.Pattern;
+import java.util.spi.ToolProvider;
 import java.util.stream.Collectors;
 import java.util.stream.Stream;
 
 import jdk.test.lib.util.FileUtils;
 import jdk.test.lib.JDKToolFinder;
@@ -57,10 +60,20 @@
  * @run testng Basic
  * @summary Tests for plain Modular jars & Multi-Release Modular jars
  */
 
 public class Basic {
+
+    private static final ToolProvider JAR_TOOL = ToolProvider.findFirst("jar")
+            .orElseThrow(()
+                    -> new RuntimeException("jar tool not found")
+            );
+    private static final ToolProvider JAVAC_TOOL = ToolProvider.findFirst("javac")
+            .orElseThrow(()
+                    -> new RuntimeException("javac tool not found")
+            );
+
     static final Path TEST_SRC = Paths.get(System.getProperty("test.src", "."));
     static final Path TEST_CLASSES = Paths.get(System.getProperty("test.classes", "."));
     static final Path MODULE_CLASSES = TEST_CLASSES.resolve("build");
     static final Path MRJAR_DIR = MODULE_CLASSES.resolve("mrjar");
 
@@ -975,17 +988,18 @@
         if (!TOOL_VM_OPTIONS.isEmpty()) {
             commands.addAll(Arrays.asList(TOOL_VM_OPTIONS.split("\\s+", -1)));
         }
         Stream.of(args).forEach(commands::add);
         ProcessBuilder p = new ProcessBuilder(commands);
-        if (stdinSource != null)
+        if (stdinSource != null) {
             p.redirectInput(stdinSource);
+        }
         return run(p);
     }
 
     static Result jar(String... args) {
-        return jarWithStdin(null, args);
+        return run(JAR_TOOL, args);
     }
 
     static Path compileModule(String mn) throws IOException {
         return compileModule(mn, null);
     }
@@ -1069,14 +1083,12 @@
     }
 
     static void javac(Path dest, Path modulePath, Path... sourceFiles)
         throws IOException
     {
-        String javac = getJDKTool("javac");
 
         List<String> commands = new ArrayList<>();
-        commands.add(javac);
         if (!TOOL_VM_OPTIONS.isEmpty()) {
             commands.addAll(Arrays.asList(TOOL_VM_OPTIONS.split("\\s+", -1)));
         }
         commands.add("-d");
         commands.add(dest.toString());
@@ -1090,11 +1102,17 @@
             commands.add("--module-path");
             commands.add(modulePath.toString());
         }
         Stream.of(sourceFiles).map(Object::toString).forEach(x -> commands.add(x));
 
-        quickFail(run(new ProcessBuilder(commands)));
+        StringWriter sw = new StringWriter();
+        try (PrintWriter pw = new PrintWriter(sw)) {
+            int rc = JAVAC_TOOL.run(pw, pw, commands.toArray(new String[0]));
+            if(rc != 0) {
+                throw new RuntimeException(sw.toString());
+            }
+        }
     }
 
     static Result java(Path modulePath, String entryPoint, String... args) {
         String java = getJDKTool("java");
 
@@ -1136,13 +1154,17 @@
                 return true;
         }
         return false;
     }
 
-    static void quickFail(Result r) {
-        if (r.ec != 0)
-            throw new RuntimeException(r.output);
+    static Result run(ToolProvider tp, String[] commands) {
+        int rc = 0;
+        StringWriter sw = new StringWriter();
+        try (PrintWriter pw = new PrintWriter(sw)) {
+            rc = tp.run(pw, pw, commands);
+        }
+        return new Result(rc, sw.toString());
     }
 
     static Result run(ProcessBuilder pb) {
         Process p;
         out.printf("Running: %s%n", pb.command());

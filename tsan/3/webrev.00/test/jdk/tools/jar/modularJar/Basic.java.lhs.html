<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames test/jdk/tools/jar/modularJar/Basic.java</title>
    <link rel="stylesheet" href="../../../../../style.css" />
    <script type="text/javascript" src="../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
<a name="1" id="anc1"></a><span class="line-modified">   2  * Copyright (c) 2015, 2018, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  */
  23 
  24 import java.io.*;
  25 import java.lang.module.ModuleDescriptor;
  26 import java.lang.reflect.Method;
<a name="2" id="anc2"></a><span class="line-modified">  27 import java.nio.file.*;</span>


  28 import java.util.*;
  29 import java.util.function.Consumer;
  30 import java.util.jar.JarEntry;
  31 import java.util.jar.JarFile;
  32 import java.util.jar.JarInputStream;
  33 import java.util.jar.Manifest;
  34 import java.util.regex.Pattern;
<a name="3" id="anc3"></a>
  35 import java.util.stream.Collectors;
  36 import java.util.stream.Stream;
  37 
  38 import jdk.test.lib.util.FileUtils;
  39 import jdk.test.lib.JDKToolFinder;
  40 import org.testng.annotations.BeforeTest;
  41 import org.testng.annotations.DataProvider;
  42 import org.testng.annotations.Test;
  43 
  44 import static java.lang.String.format;
  45 import static java.lang.System.out;
  46 
  47 /*
  48  * @test
  49  * @bug 8167328 8171830 8165640 8174248 8176772 8196748 8191533 8210454
  50  * @library /test/lib
  51  * @modules jdk.compiler
  52  *          jdk.jartool
  53  * @build jdk.test.lib.Platform
  54  *        jdk.test.lib.util.FileUtils
  55  *        jdk.test.lib.JDKToolFinder
  56  * @compile Basic.java
  57  * @run testng Basic
  58  * @summary Tests for plain Modular jars &amp; Multi-Release Modular jars
  59  */
  60 
  61 public class Basic {
<a name="4" id="anc4"></a>









  62     static final Path TEST_SRC = Paths.get(System.getProperty(&quot;test.src&quot;, &quot;.&quot;));
  63     static final Path TEST_CLASSES = Paths.get(System.getProperty(&quot;test.classes&quot;, &quot;.&quot;));
  64     static final Path MODULE_CLASSES = TEST_CLASSES.resolve(&quot;build&quot;);
  65     static final Path MRJAR_DIR = MODULE_CLASSES.resolve(&quot;mrjar&quot;);
  66 
  67     static final String VM_OPTIONS = System.getProperty(&quot;test.vm.opts&quot;, &quot;&quot;);
  68     static final String TOOL_VM_OPTIONS = System.getProperty(&quot;test.tool.vm.opts&quot;, &quot;&quot;);
  69     static final String JAVA_OPTIONS = System.getProperty(&quot;test.java.opts&quot;, &quot;&quot;);
  70 
  71     // Details based on the checked in module source
  72     static TestModuleData FOO = new TestModuleData(&quot;foo&quot;,
  73                                                    &quot;1.123&quot;,
  74                                                    &quot;jdk.test.foo.Foo&quot;,
  75                                                    &quot;Hello World!!!&quot;,
  76                                                    null, // no hashes
  77                                                    Set.of(&quot;java.base&quot;),
  78                                                    Set.of(&quot;jdk.test.foo&quot;),
  79                                                    null, // no uses
  80                                                    null, // no provides
  81                                                    Set.of(&quot;jdk.test.foo.internal&quot;,
  82                                                           &quot;jdk.test.foo.resources&quot;));
  83     static TestModuleData BAR = new TestModuleData(&quot;bar&quot;,
  84                                                    &quot;4.5.6.7&quot;,
  85                                                    &quot;jdk.test.bar.Bar&quot;,
  86                                                    &quot;Hello from Bar!&quot;,
  87                                                    null, // no hashes
  88                                                    Set.of(&quot;java.base&quot;, &quot;foo&quot;),
  89                                                    null, // no exports
  90                                                    null, // no uses
  91                                                    null, // no provides
  92                                                    Set.of(&quot;jdk.test.bar&quot;,
  93                                                           &quot;jdk.test.bar.internal&quot;));
  94 
  95     static class TestModuleData {
  96         final String moduleName;
  97         final Set&lt;String&gt; requires;
  98         final Set&lt;String&gt; exports;
  99         final Set&lt;String&gt; uses;
 100         final Set&lt;String&gt; provides;
 101         final String mainClass;
 102         final String version;
 103         final String message;
 104         final String hashes;
 105         final Set&lt;String&gt; packages;
 106 
 107         TestModuleData(String mn, String v, String mc, String m, String h,
 108                        Set&lt;String&gt; requires, Set&lt;String&gt; exports, Set&lt;String&gt; uses,
 109                        Set&lt;String&gt; provides, Set&lt;String&gt; contains) {
 110             moduleName = mn; mainClass = mc; version = v; message = m; hashes = h;
 111             this.requires = requires != null ? requires : Collections.emptySet();
 112             this.exports = exports != null ? exports : Collections.emptySet();
 113             this.uses = uses != null ? uses : Collections.emptySet();;
 114             this.provides = provides != null ? provides : Collections.emptySet();
 115             this.packages = Stream.concat(this.exports.stream(), contains.stream())
 116                                   .collect(Collectors.toSet());
 117         }
 118         static TestModuleData from(String s) {
 119             try {
 120                 BufferedReader reader = new BufferedReader(new StringReader(s));
 121                 String line;
 122                 String message = null;
 123                 String name = null, version = null, mainClass = null;
 124                 String hashes = null;
 125                 Set&lt;String&gt; requires, exports, uses, provides, conceals;
 126                 requires = exports = uses = provides = conceals = null;
 127                 while ((line = reader.readLine()) != null) {
 128                     if (line.startsWith(&quot;message:&quot;)) {
 129                         message = line.substring(&quot;message:&quot;.length());
 130                     } else if (line.startsWith(&quot;nameAndVersion:&quot;)) {
 131                         line = line.substring(&quot;nameAndVersion:&quot;.length());
 132                         int i = line.indexOf(&#39;@&#39;);
 133                         if (i != -1) {
 134                             name = line.substring(0, i);
 135                             version = line.substring(i + 1, line.length());
 136                         } else {
 137                             name = line;
 138                         }
 139                     } else if (line.startsWith(&quot;mainClass:&quot;)) {
 140                         mainClass = line.substring(&quot;mainClass:&quot;.length());
 141                     } else if (line.startsWith(&quot;requires:&quot;)) {
 142                         line = line.substring(&quot;requires:&quot;.length());
 143                         requires = stringToSet(line);
 144                     } else if (line.startsWith(&quot;exports:&quot;)) {
 145                         line = line.substring(&quot;exports:&quot;.length());
 146                         exports = stringToSet(line);
 147                     } else if (line.startsWith(&quot;uses:&quot;)) {
 148                         line = line.substring(&quot;uses:&quot;.length());
 149                         uses = stringToSet(line);
 150                     } else if (line.startsWith(&quot;provides:&quot;)) {
 151                         line = line.substring(&quot;provides:&quot;.length());
 152                         provides = stringToSet(line);
 153                     } else if (line.startsWith(&quot;hashes:&quot;)) {
 154                         hashes = line.substring(&quot;hashes:&quot;.length());
 155                     } else if (line.startsWith(&quot;contains:&quot;)) {
 156                         line = line.substring(&quot;contains:&quot;.length());
 157                         conceals = stringToSet(line);
 158                     } else if (line.contains(&quot;VM warning:&quot;)) {
 159                         continue;  // ignore server vm warning see#8196748
 160                     } else {
 161                         throw new AssertionError(&quot;Unknown value &quot; + line);
 162                     }
 163                 }
 164 
 165                 return new TestModuleData(name, version, mainClass, message,
 166                                           hashes, requires, exports, uses,
 167                                           provides, conceals);
 168             } catch (IOException x) {
 169                 throw new UncheckedIOException(x);
 170             }
 171         }
 172         static Set&lt;String&gt; stringToSet(String commaList) {
 173             Set&lt;String&gt; s = new HashSet&lt;&gt;();
 174             int i = commaList.indexOf(&#39;,&#39;);
 175             if (i != -1) {
 176                 String[] p = commaList.split(&quot;,&quot;);
 177                 Stream.of(p).forEach(s::add);
 178             } else {
 179                 s.add(commaList);
 180             }
 181             return s;
 182         }
 183     }
 184 
 185     static void assertModuleData(Result r, TestModuleData expected) {
 186         //out.printf(&quot;%s%n&quot;, r.output);
 187         TestModuleData received = TestModuleData.from(r.output);
 188         if (expected.message != null)
 189             assertTrue(expected.message.equals(received.message),
 190                        &quot;Expected message:&quot;, expected.message, &quot;, got:&quot;, received.message);
 191         assertTrue(expected.moduleName.equals(received.moduleName),
 192                    &quot;Expected moduleName: &quot;, expected.moduleName, &quot;, got:&quot;, received.moduleName);
 193         assertTrue(expected.version.equals(received.version),
 194                    &quot;Expected version: &quot;, expected.version, &quot;, got:&quot;, received.version);
 195         assertTrue(expected.mainClass.equals(received.mainClass),
 196                    &quot;Expected mainClass: &quot;, expected.mainClass, &quot;, got:&quot;, received.mainClass);
 197         assertSetsEqual(expected.requires, received.requires);
 198         assertSetsEqual(expected.exports, received.exports);
 199         assertSetsEqual(expected.uses, received.uses);
 200         assertSetsEqual(expected.provides, received.provides);
 201         assertSetsEqual(expected.packages, received.packages);
 202     }
 203 
 204     static void assertSetsEqual(Set&lt;String&gt; s1, Set&lt;String&gt; s2) {
 205         if (!s1.equals(s2)) {
 206             org.testng.Assert.assertTrue(false, s1 + &quot; vs &quot; + s2);
 207         }
 208      }
 209 
 210     @BeforeTest
 211     public void compileModules() throws Exception {
 212         compileModule(FOO.moduleName);
 213         compileModule(BAR.moduleName, MODULE_CLASSES);
 214         compileModule(&quot;baz&quot;);  // for service provider consistency checking
 215 
 216         // copy resources
 217         copyResource(TEST_SRC.resolve(&quot;src&quot;).resolve(FOO.moduleName),
 218                      MODULE_CLASSES.resolve(FOO.moduleName),
 219                      &quot;jdk/test/foo/resources/foo.properties&quot;);
 220 
 221         setupMRJARModuleInfo(FOO.moduleName);
 222         setupMRJARModuleInfo(BAR.moduleName);
 223         setupMRJARModuleInfo(&quot;baz&quot;);
 224     }
 225 
 226     @Test
 227     public void createFoo() throws IOException {
 228         Path mp = Paths.get(&quot;createFoo&quot;);
 229         createTestDir(mp);
 230         Path modClasses = MODULE_CLASSES.resolve(FOO.moduleName);
 231         Path modularJar = mp.resolve(FOO.moduleName + &quot;.jar&quot;);
 232 
 233         jar(&quot;--create&quot;,
 234             &quot;--file=&quot; + modularJar.toString(),
 235             &quot;--main-class=&quot; + FOO.mainClass,
 236             &quot;--module-version=&quot; + FOO.version,
 237             &quot;--no-manifest&quot;,
 238             &quot;-C&quot;, modClasses.toString(), &quot;.&quot;)
 239             .assertSuccess();
 240 
 241         assertSetsEqual(readPackagesAttribute(modularJar),
 242                         Set.of(&quot;jdk.test.foo&quot;,
 243                                &quot;jdk.test.foo.resources&quot;,
 244                                &quot;jdk.test.foo.internal&quot;));
 245 
 246         java(mp, FOO.moduleName + &quot;/&quot; + FOO.mainClass)
 247             .assertSuccess()
 248             .resultChecker(r -&gt; assertModuleData(r, FOO));
 249         try (InputStream fis = Files.newInputStream(modularJar);
 250              JarInputStream jis = new JarInputStream(fis)) {
 251             assertTrue(!jarContains(jis, &quot;./&quot;),
 252                        &quot;Unexpected ./ found in &quot;, modularJar.toString());
 253         }
 254     }
 255 
 256     /** Similar to createFoo, but with a Multi-Release Modular jar. */
 257     @Test
 258     public void createMRMJarFoo() throws IOException {
 259         Path mp = Paths.get(&quot;createMRMJarFoo&quot;);
 260         createTestDir(mp);
 261         Path modClasses = MODULE_CLASSES.resolve(FOO.moduleName);
 262         Path mrjarDir = MRJAR_DIR.resolve(FOO.moduleName);
 263         Path modularJar = mp.resolve(FOO.moduleName + &quot;.jar&quot;);
 264 
 265         // Positive test, create
 266         jar(&quot;--create&quot;,
 267             &quot;--file=&quot; + modularJar.toString(),
 268             &quot;--main-class=&quot; + FOO.mainClass,
 269             &quot;--module-version=&quot; + FOO.version,
 270             &quot;-m&quot;, mrjarDir.resolve(&quot;META-INF/MANIFEST.MF&quot;).toRealPath().toString(),
 271             &quot;-C&quot;, mrjarDir.toString(), &quot;META-INF/versions/9/module-info.class&quot;,
 272             &quot;-C&quot;, modClasses.toString(), &quot;.&quot;)
 273             .assertSuccess();
 274         java(mp, FOO.moduleName + &quot;/&quot; + FOO.mainClass)
 275             .assertSuccess()
 276             .resultChecker(r -&gt; assertModuleData(r, FOO));
 277     }
 278 
 279 
 280     @Test
 281     public void updateFoo() throws IOException {
 282         Path mp = Paths.get(&quot;updateFoo&quot;);
 283         createTestDir(mp);
 284         Path modClasses = MODULE_CLASSES.resolve(FOO.moduleName);
 285         Path modularJar = mp.resolve(FOO.moduleName + &quot;.jar&quot;);
 286 
 287         jar(&quot;--create&quot;,
 288             &quot;--file=&quot; + modularJar.toString(),
 289             &quot;--no-manifest&quot;,
 290             &quot;-C&quot;, modClasses.toString(), &quot;jdk&quot;)
 291             .assertSuccess();
 292         jar(&quot;--update&quot;,
 293             &quot;--file=&quot; + modularJar.toString(),
 294             &quot;--main-class=&quot; + FOO.mainClass,
 295             &quot;--module-version=&quot; + FOO.version,
 296             &quot;--no-manifest&quot;,
 297             &quot;-C&quot;, modClasses.toString(), &quot;module-info.class&quot;)
 298             .assertSuccess();
 299         java(mp, FOO.moduleName + &quot;/&quot; + FOO.mainClass)
 300             .assertSuccess()
 301             .resultChecker(r -&gt; assertModuleData(r, FOO));
 302     }
 303 
 304     @Test
 305     public void updateMRMJarFoo() throws IOException {
 306         Path mp = Paths.get(&quot;updateMRMJarFoo&quot;);
 307         createTestDir(mp);
 308         Path modClasses = MODULE_CLASSES.resolve(FOO.moduleName);
 309         Path mrjarDir = MRJAR_DIR.resolve(FOO.moduleName);
 310         Path modularJar = mp.resolve(FOO.moduleName + &quot;.jar&quot;);
 311 
 312         jar(&quot;--create&quot;,
 313             &quot;--file=&quot; + modularJar.toString(),
 314             &quot;--no-manifest&quot;,
 315             &quot;-C&quot;, modClasses.toString(), &quot;jdk&quot;)
 316             .assertSuccess();
 317         jar(&quot;--update&quot;,
 318             &quot;--file=&quot; + modularJar.toString(),
 319             &quot;--main-class=&quot; + FOO.mainClass,
 320             &quot;--module-version=&quot; + FOO.version,
 321             &quot;-m&quot;, mrjarDir.resolve(&quot;META-INF/MANIFEST.MF&quot;).toRealPath().toString(),
 322             &quot;-C&quot;, mrjarDir.toString(), &quot;META-INF/versions/9/module-info.class&quot;,
 323             &quot;-C&quot;, modClasses.toString(), &quot;module-info.class&quot;)
 324             .assertSuccess();
 325         java(mp, FOO.moduleName + &quot;/&quot; + FOO.mainClass)
 326             .assertSuccess()
 327             .resultChecker(r -&gt; assertModuleData(r, FOO));
 328     }
 329 
 330     @Test
 331     public void partialUpdateFooMainClass() throws IOException {
 332         Path mp = Paths.get(&quot;partialUpdateFooMainClass&quot;);
 333         createTestDir(mp);
 334         Path modClasses = MODULE_CLASSES.resolve(FOO.moduleName);
 335         Path modularJar = mp.resolve(FOO.moduleName + &quot;.jar&quot;);
 336 
 337         // A &quot;bad&quot; main class in first create ( and no version )
 338         jar(&quot;--create&quot;,
 339             &quot;--file=&quot; + modularJar.toString(),
 340             &quot;--main-class=&quot; + &quot;jdk.test.foo.IAmNotTheEntryPoint&quot;,
 341             &quot;--no-manifest&quot;,
 342             &quot;-C&quot;, modClasses.toString(), &quot;.&quot;)  // includes module-info.class
 343            .assertSuccess();
 344         jar(&quot;--update&quot;,
 345             &quot;--file=&quot; + modularJar.toString(),
 346             &quot;--main-class=&quot; + FOO.mainClass,
 347             &quot;--module-version=&quot; + FOO.version,
 348             &quot;--no-manifest&quot;)
 349             .assertSuccess();
 350         java(mp, FOO.moduleName + &quot;/&quot; + FOO.mainClass)
 351             .assertSuccess()
 352             .resultChecker(r -&gt; assertModuleData(r, FOO));
 353     }
 354 
 355     @Test
 356     public void partialUpdateFooVersion() throws IOException {
 357         Path mp = Paths.get(&quot;partialUpdateFooVersion&quot;);
 358         createTestDir(mp);
 359         Path modClasses = MODULE_CLASSES.resolve(FOO.moduleName);
 360         Path modularJar = mp.resolve(FOO.moduleName + &quot;.jar&quot;);
 361 
 362         // A &quot;bad&quot; version in first create ( and no main class )
 363         jar(&quot;--create&quot;,
 364             &quot;--file=&quot; + modularJar.toString(),
 365             &quot;--module-version=&quot; + &quot;100000000&quot;,
 366             &quot;--no-manifest&quot;,
 367             &quot;-C&quot;, modClasses.toString(), &quot;.&quot;)  // includes module-info.class
 368             .assertSuccess();
 369         jar(&quot;--update&quot;,
 370             &quot;--file=&quot; + modularJar.toString(),
 371             &quot;--main-class=&quot; + FOO.mainClass,
 372             &quot;--module-version=&quot; + FOO.version,
 373             &quot;--no-manifest&quot;)
 374             .assertSuccess();
 375         java(mp, FOO.moduleName + &quot;/&quot; + FOO.mainClass)
 376             .assertSuccess()
 377             .resultChecker(r -&gt; assertModuleData(r, FOO));
 378     }
 379 
 380     @Test
 381     public void partialUpdateFooNotAllFiles() throws IOException {
 382         Path mp = Paths.get(&quot;partialUpdateFooNotAllFiles&quot;);
 383         createTestDir(mp);
 384         Path modClasses = MODULE_CLASSES.resolve(FOO.moduleName);
 385         Path modularJar = mp.resolve(FOO.moduleName + &quot;.jar&quot;);
 386 
 387         // Not all files, and none from non-exported packages,
 388         // i.e. no concealed list in first create
 389         jar(&quot;--create&quot;,
 390             &quot;--file=&quot; + modularJar.toString(),
 391             &quot;--no-manifest&quot;,
 392             &quot;-C&quot;, modClasses.toString(), &quot;module-info.class&quot;,
 393             &quot;-C&quot;, modClasses.toString(), &quot;jdk/test/foo/Foo.class&quot;,
 394             &quot;-C&quot;, modClasses.toString(), &quot;jdk/test/foo/resources/foo.properties&quot;)
 395             .assertSuccess();
 396         jar(&quot;--update&quot;,
 397             &quot;--file=&quot; + modularJar.toString(),
 398             &quot;--main-class=&quot; + FOO.mainClass,
 399             &quot;--module-version=&quot; + FOO.version,
 400             &quot;--no-manifest&quot;,
 401             &quot;-C&quot;, modClasses.toString(), &quot;jdk/test/foo/internal/Message.class&quot;)
 402             .assertSuccess();
 403         java(mp, FOO.moduleName + &quot;/&quot; + FOO.mainClass)
 404             .assertSuccess()
 405             .resultChecker(r -&gt; assertModuleData(r, FOO));
 406     }
 407 
 408     @Test
 409     public void partialUpdateMRMJarFooNotAllFiles() throws IOException {
 410         Path mp = Paths.get(&quot;partialUpdateMRMJarFooNotAllFiles&quot;);
 411         createTestDir(mp);
 412         Path modClasses = MODULE_CLASSES.resolve(FOO.moduleName);
 413         Path mrjarDir = MRJAR_DIR.resolve(FOO.moduleName);
 414         Path modularJar = mp.resolve(FOO.moduleName + &quot;.jar&quot;);
 415 
 416         jar(&quot;--create&quot;,
 417             &quot;--file=&quot; + modularJar.toString(),
 418             &quot;--module-version=&quot; + FOO.version,
 419             &quot;-C&quot;, modClasses.toString(), &quot;.&quot;)
 420             .assertSuccess();
 421         jar(&quot;--update&quot;,
 422             &quot;--file=&quot; + modularJar.toString(),
 423             &quot;--main-class=&quot; + FOO.mainClass,
 424             &quot;--module-version=&quot; + FOO.version,
 425             &quot;-m&quot;, mrjarDir.resolve(&quot;META-INF/MANIFEST.MF&quot;).toRealPath().toString(),
 426             &quot;-C&quot;, mrjarDir.toString(), &quot;META-INF/versions/9/module-info.class&quot;)
 427             .assertSuccess();
 428         java(mp, FOO.moduleName + &quot;/&quot; + FOO.mainClass)
 429             .assertSuccess()
 430             .resultChecker(r -&gt; assertModuleData(r, FOO));
 431     }
 432 
 433     @Test
 434     public void partialUpdateFooAllFilesAndAttributes() throws IOException {
 435         Path mp = Paths.get(&quot;partialUpdateFooAllFilesAndAttributes&quot;);
 436         createTestDir(mp);
 437         Path modClasses = MODULE_CLASSES.resolve(FOO.moduleName);
 438         Path modularJar = mp.resolve(FOO.moduleName + &quot;.jar&quot;);
 439 
 440         // all attributes and files
 441         jar(&quot;--create&quot;,
 442             &quot;--file=&quot; + modularJar.toString(),
 443             &quot;--main-class=&quot; + FOO.mainClass,
 444             &quot;--module-version=&quot; + FOO.version,
 445             &quot;--no-manifest&quot;,
 446             &quot;-C&quot;, modClasses.toString(), &quot;.&quot;)
 447             .assertSuccess();
 448         jar(&quot;--update&quot;,
 449             &quot;--file=&quot; + modularJar.toString(),
 450             &quot;--main-class=&quot; + FOO.mainClass,
 451             &quot;--module-version=&quot; + FOO.version,
 452             &quot;--no-manifest&quot;,
 453             &quot;-C&quot;, modClasses.toString(), &quot;.&quot;)
 454             .assertSuccess();
 455         java(mp, FOO.moduleName + &quot;/&quot; + FOO.mainClass)
 456             .assertSuccess()
 457             .resultChecker(r -&gt; assertModuleData(r, FOO));
 458     }
 459 
 460     @Test
 461     public void partialUpdateFooModuleInfo() throws IOException {
 462         Path mp = Paths.get(&quot;partialUpdateFooModuleInfo&quot;);
 463         createTestDir(mp);
 464         Path modClasses = MODULE_CLASSES.resolve(FOO.moduleName);
 465         Path modularJar = mp.resolve(FOO.moduleName + &quot;.jar&quot;);
 466         Path barModInfo = MODULE_CLASSES.resolve(BAR.moduleName);
 467 
 468         jar(&quot;--create&quot;,
 469             &quot;--file=&quot; + modularJar.toString(),
 470             &quot;--main-class=&quot; + FOO.mainClass,
 471             &quot;--module-version=&quot; + FOO.version,
 472             &quot;--no-manifest&quot;,
 473             &quot;-C&quot;, modClasses.toString(), &quot;.&quot;)
 474             .assertSuccess();
 475         jar(&quot;--update&quot;,
 476             &quot;--file=&quot; + modularJar.toString(),
 477             &quot;--no-manifest&quot;,
 478             &quot;-C&quot;, barModInfo.toString(), &quot;module-info.class&quot;)  // stuff in bar&#39;s info
 479             .assertSuccess();
 480         jar(&quot;-d&quot;,
 481             &quot;--file=&quot; + modularJar.toString())
 482             .assertSuccess()
 483             .resultChecker(r -&gt; {
 484                 // Expect &quot;bar jar:file:/.../!module-info.class&quot;
 485                 // conceals jdk.test.foo, conceals jdk.test.foo.internal&quot;
 486                 String uri = &quot;jar:&quot; + modularJar.toUri().toString() + &quot;/!module-info.class&quot;;
 487                 assertTrue(r.output.contains(&quot;bar &quot; + uri),
 488                            &quot;Expecting to find \&quot;bar &quot; + uri + &quot;\&quot;&quot;,
 489                            &quot;in output, but did not: [&quot; + r.output + &quot;]&quot;);
 490                 Pattern p = Pattern.compile(
 491                         &quot;contains\\s+jdk.test.foo\\s+contains\\s+jdk.test.foo.internal&quot;);
 492                 assertTrue(p.matcher(r.output).find(),
 493                            &quot;Expecting to find \&quot;contains jdk.test.foo,...\&quot;&quot;,
 494                            &quot;in output, but did not: [&quot; + r.output + &quot;]&quot;);
 495             });
 496     }
 497 
 498 
 499     @Test
 500     public void partialUpdateFooPackagesAttribute() throws IOException {
 501         Path mp = Paths.get(&quot;partialUpdateFooPackagesAttribute&quot;);
 502         createTestDir(mp);
 503         Path modClasses = MODULE_CLASSES.resolve(FOO.moduleName);
 504         Path modularJar = mp.resolve(FOO.moduleName + &quot;.jar&quot;);
 505 
 506         // Not all files, and none from non-exported packages,
 507         // i.e. no concealed list in first create
 508         jar(&quot;--create&quot;,
 509             &quot;--file=&quot; + modularJar.toString(),
 510             &quot;--no-manifest&quot;,
 511             &quot;-C&quot;, modClasses.toString(), &quot;module-info.class&quot;,
 512             &quot;-C&quot;, modClasses.toString(), &quot;jdk/test/foo/Foo.class&quot;)
 513             .assertSuccess();
 514 
 515         assertSetsEqual(readPackagesAttribute(modularJar),
 516                         Set.of(&quot;jdk.test.foo&quot;));
 517 
 518         jar(&quot;--update&quot;,
 519             &quot;--file=&quot; + modularJar.toString(),
 520             &quot;-C&quot;, modClasses.toString(), &quot;jdk/test/foo/resources/foo.properties&quot;)
 521             .assertSuccess();
 522 
 523         assertSetsEqual(readPackagesAttribute(modularJar),
 524                         Set.of(&quot;jdk.test.foo&quot;, &quot;jdk.test.foo.resources&quot;));
 525 
 526         jar(&quot;--update&quot;,
 527             &quot;--file=&quot; + modularJar.toString(),
 528             &quot;--main-class=&quot; + FOO.mainClass,
 529             &quot;--module-version=&quot; + FOO.version,
 530             &quot;--no-manifest&quot;,
 531             &quot;-C&quot;, modClasses.toString(), &quot;jdk/test/foo/internal/Message.class&quot;)
 532             .assertSuccess();
 533 
 534         assertSetsEqual(readPackagesAttribute(modularJar),
 535                         Set.of(&quot;jdk.test.foo&quot;,
 536                                &quot;jdk.test.foo.resources&quot;,
 537                                &quot;jdk.test.foo.internal&quot;));
 538 
 539         java(mp, FOO.moduleName + &quot;/&quot; + FOO.mainClass)
 540             .assertSuccess()
 541             .resultChecker(r -&gt; assertModuleData(r, FOO));
 542     }
 543 
 544     private Set&lt;String&gt; readPackagesAttribute(Path jar) {
 545         return getModuleDescriptor(jar).packages();
 546     }
 547 
 548     @Test
 549     public void hashBarInFooModule() throws IOException {
 550         Path mp = Paths.get(&quot;dependencesFooBar&quot;);
 551         createTestDir(mp);
 552 
 553         Path modClasses = MODULE_CLASSES.resolve(BAR.moduleName);
 554         Path modularJar = mp.resolve(BAR.moduleName + &quot;.jar&quot;);
 555         jar(&quot;--create&quot;,
 556             &quot;--file=&quot; + modularJar.toString(),
 557             &quot;--main-class=&quot; + BAR.mainClass,
 558             &quot;--module-version=&quot; + BAR.version,
 559             &quot;--no-manifest&quot;,
 560             &quot;-C&quot;, modClasses.toString(), &quot;.&quot;)
 561             .assertSuccess();
 562 
 563         modClasses = MODULE_CLASSES.resolve(FOO.moduleName);
 564         modularJar = mp.resolve(FOO.moduleName + &quot;.jar&quot;);
 565         jar(&quot;--create&quot;,
 566             &quot;--file=&quot; + modularJar.toString(),
 567             &quot;--main-class=&quot; + FOO.mainClass,
 568             &quot;--module-version=&quot; + FOO.version,
 569             &quot;--module-path=&quot; + mp.toString(),
 570             &quot;--hash-modules=&quot; + &quot;bar&quot;,
 571             &quot;--no-manifest&quot;,
 572             &quot;-C&quot;, modClasses.toString(), &quot;.&quot;)
 573             .assertSuccess();
 574 
 575         java(mp, BAR.moduleName + &quot;/&quot; + BAR.mainClass,
 576              &quot;--add-exports&quot;, &quot;java.base/jdk.internal.misc=bar&quot;,
 577              &quot;--add-exports&quot;, &quot;java.base/jdk.internal.module=bar&quot;)
 578             .assertSuccess()
 579             .resultChecker(r -&gt; {
 580                 assertModuleData(r, BAR);
 581                 TestModuleData received = TestModuleData.from(r.output);
 582                 assertTrue(received.hashes != null, &quot;Expected non-null hashes value.&quot;);
 583             });
 584     }
 585 
 586     @Test
 587     public void invalidHashInFooModule() throws IOException {
 588         Path mp = Paths.get(&quot;badDependencyFooBar&quot;);
 589         createTestDir(mp);
 590 
 591         Path barClasses = MODULE_CLASSES.resolve(BAR.moduleName);
 592         Path barJar = mp.resolve(BAR.moduleName + &quot;.jar&quot;);
 593         jar(&quot;--create&quot;,
 594             &quot;--file=&quot; + barJar.toString(),
 595             &quot;--main-class=&quot; + BAR.mainClass,
 596             &quot;--module-version=&quot; + BAR.version,
 597             &quot;--no-manifest&quot;,
 598             &quot;-C&quot;, barClasses.toString(), &quot;.&quot;).assertSuccess();
 599 
 600         Path fooClasses = MODULE_CLASSES.resolve(FOO.moduleName);
 601         Path fooJar = mp.resolve(FOO.moduleName + &quot;.jar&quot;);
 602         jar(&quot;--create&quot;,
 603             &quot;--file=&quot; + fooJar.toString(),
 604             &quot;--main-class=&quot; + FOO.mainClass,
 605             &quot;--module-version=&quot; + FOO.version,
 606             &quot;-p&quot;, mp.toString(),  // test short-form
 607             &quot;--hash-modules=&quot; + &quot;bar&quot;,
 608             &quot;--no-manifest&quot;,
 609             &quot;-C&quot;, fooClasses.toString(), &quot;.&quot;).assertSuccess();
 610 
 611         // Rebuild bar.jar with a change that will cause its hash to be different
 612         FileUtils.deleteFileWithRetry(barJar);
 613         jar(&quot;--create&quot;,
 614             &quot;--file=&quot; + barJar.toString(),
 615             &quot;--main-class=&quot; + BAR.mainClass,
 616             &quot;--module-version=&quot; + BAR.version + &quot;.1&quot;, // a newer version
 617             &quot;--no-manifest&quot;,
 618             &quot;-C&quot;, barClasses.toString(), &quot;.&quot;).assertSuccess();
 619 
 620         java(mp, BAR.moduleName + &quot;/&quot; + BAR.mainClass,
 621              &quot;--add-exports&quot;, &quot;java.base/jdk.internal.misc=bar&quot;,
 622              &quot;--add-exports&quot;, &quot;java.base/jdk.internal.module=bar&quot;)
 623             .assertFailure()
 624             .resultChecker(r -&gt; {
 625                 // Expect similar output: &quot;java.lang.module.ResolutionException: Hash
 626                 // of bar (WdktSIQSkd4+CEacpOZoeDrCosMATNrIuNub9b5yBeo=) differs to
 627                 // expected hash (iepvdv8xTeVrFgMtUhcFnmetSub6qQHCHc92lSaSEg0=)&quot;
 628                 Pattern p = Pattern.compile(&quot;.*Hash of bar.*differs to expected hash.*&quot;);
 629                 assertTrue(p.matcher(r.output).find(),
 630                       &quot;Expecting error message containing \&quot;Hash of bar ... differs to&quot;
 631                               + &quot; expected hash...\&quot; but got: [&quot;, r.output + &quot;]&quot;);
 632             });
 633     }
 634 
 635     @Test
 636     public void badOptionsFoo() throws IOException {
 637         Path mp = Paths.get(&quot;badOptionsFoo&quot;);
 638         createTestDir(mp);
 639         Path modClasses = MODULE_CLASSES.resolve(FOO.moduleName);
 640         Path modularJar = mp.resolve(FOO.moduleName + &quot;.jar&quot;);
 641 
 642         jar(&quot;--create&quot;,
 643             &quot;--file=&quot; + modularJar.toString(),
 644             &quot;--module-version=&quot; + 1.1,   // no module-info.class
 645             &quot;-C&quot;, modClasses.toString(), &quot;jdk&quot;)
 646             .assertFailure();      // TODO: expected failure message
 647 
 648          jar(&quot;--create&quot;,
 649              &quot;--file=&quot; + modularJar.toString(),
 650              &quot;--hash-modules=&quot; + &quot;.*&quot;,   // no module-info.class
 651              &quot;-C&quot;, modClasses.toString(), &quot;jdk&quot;)
 652              .assertFailure();      // TODO: expected failure message
 653     }
 654 
 655     @Test
 656     public void servicesCreateWithoutFailure() throws IOException {
 657         Path mp = Paths.get(&quot;servicesCreateWithoutFailure&quot;);
 658         createTestDir(mp);
 659         Path modClasses = MODULE_CLASSES.resolve(&quot;baz&quot;);
 660         Path modularJar = mp.resolve(&quot;baz&quot; + &quot;.jar&quot;);
 661 
 662         // Positive test, create
 663         jar(&quot;--create&quot;,
 664             &quot;--file=&quot; + modularJar.toString(),
 665             &quot;-C&quot;, modClasses.toString(), &quot;module-info.class&quot;,
 666             &quot;-C&quot;, modClasses.toString(), &quot;jdk/test/baz/BazService.class&quot;,
 667             &quot;-C&quot;, modClasses.toString(), &quot;jdk/test/baz/internal/BazServiceImpl.class&quot;)
 668             .assertSuccess();
 669 
 670         for (String option : new String[]  {&quot;--describe-module&quot;, &quot;-d&quot; }) {
 671             jar(option,
 672                 &quot;--file=&quot; + modularJar.toString())
 673                 .assertSuccess()
 674                 .resultChecker(r -&gt;
 675                     assertTrue(r.output.contains(&quot;provides jdk.test.baz.BazService with jdk.test.baz.internal.BazServiceImpl&quot;),
 676                                &quot;Expected to find &quot;, &quot;provides jdk.test.baz.BazService with jdk.test.baz.internal.BazServiceImpl&quot;,
 677                                &quot; in [&quot;, r.output, &quot;]&quot;)
 678                 );
 679         }
 680     }
 681 
 682     @Test
 683     public void servicesCreateWithoutServiceImpl() throws IOException {
 684         Path mp = Paths.get(&quot;servicesWithoutServiceImpl&quot;);
 685         createTestDir(mp);
 686         Path modClasses = MODULE_CLASSES.resolve(&quot;baz&quot;);
 687         Path modularJar = mp.resolve(&quot;baz&quot; + &quot;.jar&quot;);
 688 
 689         // Omit service impl
 690         jar(&quot;--create&quot;,
 691             &quot;--file=&quot; + modularJar.toString(),
 692             &quot;-C&quot;, modClasses.toString(), &quot;module-info.class&quot;,
 693             &quot;-C&quot;, modClasses.toString(), &quot;jdk/test/baz/BazService.class&quot;)
 694             .assertFailure();
 695     }
 696 
 697     @Test
 698     public void servicesUpdateWithoutFailure() throws IOException {
 699         Path mp = Paths.get(&quot;servicesUpdateWithoutFailure&quot;);
 700         createTestDir(mp);
 701         Path modClasses = MODULE_CLASSES.resolve(&quot;baz&quot;);
 702         Path modularJar = mp.resolve(&quot;baz&quot; + &quot;.jar&quot;);
 703 
 704         // Positive test, update
 705         jar(&quot;--create&quot;,
 706             &quot;--file=&quot; + modularJar.toString(),
 707             &quot;-C&quot;, modClasses.toString(), &quot;jdk/test/baz/BazService.class&quot;,
 708             &quot;-C&quot;, modClasses.toString(), &quot;jdk/test/baz/internal/BazServiceImpl.class&quot;)
 709             .assertSuccess();
 710         jar(&quot;--update&quot;,
 711             &quot;--file=&quot; + modularJar.toString(),
 712             &quot;-C&quot;, modClasses.toString(), &quot;module-info.class&quot;)
 713             .assertSuccess();
 714     }
 715 
 716     @Test
 717     public void servicesUpdateWithoutServiceImpl() throws IOException {
 718         Path mp = Paths.get(&quot;servicesUpdateWithoutServiceImpl&quot;);
 719         createTestDir(mp);
 720         Path modClasses = MODULE_CLASSES.resolve(&quot;baz&quot;);
 721         Path modularJar = mp.resolve(&quot;baz&quot; + &quot;.jar&quot;);
 722 
 723         // Omit service impl
 724         jar(&quot;--create&quot;,
 725             &quot;--file=&quot; + modularJar.toString(),
 726             &quot;-C&quot;, modClasses.toString(), &quot;jdk/test/baz/BazService.class&quot;)
 727             .assertSuccess();
 728         jar(&quot;--update&quot;,
 729             &quot;--file=&quot; + modularJar.toString(),
 730             &quot;-C&quot;, modClasses.toString(), &quot;module-info.class&quot;)
 731             .assertFailure();
 732     }
 733 
 734     @Test
 735     public void servicesCreateWithoutFailureMRMJAR() throws IOException {
 736         Path mp = Paths.get(&quot;servicesCreateWithoutFailureMRMJAR&quot;);
 737         createTestDir(mp);
 738         Path modClasses = MODULE_CLASSES.resolve(&quot;baz&quot;);
 739         Path mrjarDir = MRJAR_DIR.resolve(&quot;baz&quot;);
 740         Path modularJar = mp.resolve(&quot;baz&quot; + &quot;.jar&quot;);
 741 
 742         jar(&quot;--create&quot;,
 743             &quot;--file=&quot; + modularJar.toString(),
 744             &quot;-m&quot;, mrjarDir.resolve(&quot;META-INF/MANIFEST.MF&quot;).toRealPath().toString(),
 745             &quot;-C&quot;, modClasses.toString(), &quot;module-info.class&quot;,
 746             &quot;-C&quot;, mrjarDir.toString(), &quot;META-INF/versions/9/module-info.class&quot;,
 747             &quot;-C&quot;, modClasses.toString(), &quot;jdk/test/baz/BazService.class&quot;,
 748             &quot;-C&quot;, modClasses.toString(), &quot;jdk/test/baz/internal/BazServiceImpl.class&quot;)
 749             .assertSuccess();
 750     }
 751 
 752     @Test
 753     public void servicesCreateWithoutFailureNonRootMRMJAR() throws IOException {
 754         // without a root module-info.class
 755         Path mp = Paths.get(&quot;servicesCreateWithoutFailureNonRootMRMJAR&quot;);
 756         createTestDir(mp);
 757         Path modClasses = MODULE_CLASSES.resolve(&quot;baz&quot;);
 758         Path mrjarDir = MRJAR_DIR.resolve(&quot;baz&quot;);
 759         Path modularJar = mp.resolve(&quot;baz.jar&quot;);
 760 
 761         jar(&quot;--create&quot;,
 762             &quot;--file=&quot; + modularJar.toString(),
 763             &quot;--main-class=&quot; + &quot;jdk.test.baz.Baz&quot;,
 764             &quot;-m&quot;, mrjarDir.resolve(&quot;META-INF/MANIFEST.MF&quot;).toRealPath().toString(),
 765             &quot;-C&quot;, mrjarDir.toString(), &quot;META-INF/versions/9/module-info.class&quot;,
 766             &quot;-C&quot;, modClasses.toString(), &quot;jdk/test/baz/BazService.class&quot;,
 767             &quot;-C&quot;, modClasses.toString(), &quot;jdk/test/baz/Baz.class&quot;,
 768             &quot;-C&quot;, modClasses.toString(), &quot;jdk/test/baz/internal/BazServiceImpl.class&quot;)
 769             .assertSuccess();
 770 
 771 
 772         for (String option : new String[]  {&quot;--describe-module&quot;, &quot;-d&quot; }) {
 773 
 774             jar(option,
 775                 &quot;--file=&quot; + modularJar.toString(),
 776                 &quot;--release&quot;, &quot;9&quot;)
 777                 .assertSuccess()
 778                 .resultChecker(r -&gt;
 779                     assertTrue(r.output.contains(&quot;main-class jdk.test.baz.Baz&quot;),
 780                               &quot;Expected to find &quot;, &quot;main-class jdk.test.baz.Baz&quot;,
 781                                &quot; in [&quot;, r.output, &quot;]&quot;));
 782 
 783             jarWithStdin(modularJar.toFile(), option, &quot;--release&quot;, &quot;9&quot;)
 784                 .assertSuccess()
 785                 .resultChecker(r -&gt;
 786                     assertTrue(r.output.contains(&quot;main-class jdk.test.baz.Baz&quot;),
 787                               &quot;Expected to find &quot;, &quot;main-class jdk.test.baz.Baz&quot;,
 788                                &quot; in [&quot;, r.output, &quot;]&quot;));
 789 
 790         }
 791         // run module main class
 792         java(mp, &quot;baz/jdk.test.baz.Baz&quot;)
 793             .assertSuccess()
 794             .resultChecker(r -&gt;
 795                assertTrue(r.output.contains(&quot;mainClass:jdk.test.baz.Baz&quot;),
 796                           &quot;Expected to find &quot;, &quot;mainClass:jdk.test.baz.Baz&quot;,
 797                           &quot; in [&quot;, r.output, &quot;]&quot;));
 798     }
 799 
 800     @Test
 801     public void exportCreateWithMissingPkg() throws IOException {
 802 
 803         Path foobar = TEST_SRC.resolve(&quot;src&quot;).resolve(&quot;foobar&quot;);
 804         Path dst = Files.createDirectories(MODULE_CLASSES.resolve(&quot;foobar&quot;));
 805         javac(dst, null, sourceList(foobar));
 806 
 807         Path mp = Paths.get(&quot;exportWithMissingPkg&quot;);
 808         createTestDir(mp);
 809         Path modClasses = dst;
 810         Path modularJar = mp.resolve(&quot;foofoo.jar&quot;);
 811 
 812         jar(&quot;--create&quot;,
 813             &quot;--file=&quot; + modularJar.toString(),
 814             &quot;-C&quot;, modClasses.toString(), &quot;module-info.class&quot;,
 815             &quot;-C&quot;, modClasses.toString(), &quot;jdk/test/foo/Foo.class&quot;)
 816             .assertFailure();
 817     }
 818 
 819     @Test
 820     public void describeModuleFoo() throws IOException {
 821         Path mp = Paths.get(&quot;describeModuleFoo&quot;);
 822         createTestDir(mp);
 823         Path modClasses = MODULE_CLASSES.resolve(FOO.moduleName);
 824         Path modularJar = mp.resolve(FOO.moduleName + &quot;.jar&quot;);
 825 
 826         jar(&quot;--create&quot;,
 827             &quot;--file=&quot; + modularJar.toString(),
 828             &quot;--main-class=&quot; + FOO.mainClass,
 829             &quot;--module-version=&quot; + FOO.version,
 830             &quot;--no-manifest&quot;,
 831             &quot;-C&quot;, modClasses.toString(), &quot;.&quot;)
 832             .assertSuccess();
 833 
 834         for (String option : new String[]  {&quot;--describe-module&quot;, &quot;-d&quot; }) {
 835             jar(option,
 836                 &quot;--file=&quot; + modularJar.toString())
 837                 .assertSuccess()
 838                 .resultChecker(r -&gt;
 839                     assertTrue(r.output.contains(FOO.moduleName + &quot;@&quot; + FOO.version),
 840                                &quot;Expected to find &quot;, FOO.moduleName + &quot;@&quot; + FOO.version,
 841                                &quot; in [&quot;, r.output, &quot;]&quot;)
 842                 );
 843 
 844             jar(option,
 845                 &quot;--file=&quot; + modularJar.toString(),
 846                 modularJar.toString())
 847             .assertFailure();
 848 
 849             jar(option, modularJar.toString())
 850             .assertFailure();
 851         }
 852     }
 853 
 854     @Test
 855     public void describeModuleFooFromStdin() throws IOException {
 856         Path mp = Paths.get(&quot;describeModuleFooFromStdin&quot;);
 857         createTestDir(mp);
 858         Path modClasses = MODULE_CLASSES.resolve(FOO.moduleName);
 859         Path modularJar = mp.resolve(FOO.moduleName + &quot;.jar&quot;);
 860 
 861         jar(&quot;--create&quot;,
 862             &quot;--file=&quot; + modularJar.toString(),
 863             &quot;--main-class=&quot; + FOO.mainClass,
 864             &quot;--module-version=&quot; + FOO.version,
 865             &quot;--no-manifest&quot;,
 866             &quot;-C&quot;, modClasses.toString(), &quot;.&quot;)
 867             .assertSuccess();
 868 
 869         for (String option : new String[]  {&quot;--describe-module&quot;, &quot;-d&quot; }) {
 870             jarWithStdin(modularJar.toFile(),
 871                          option)
 872                          .assertSuccess()
 873                          .resultChecker(r -&gt;
 874                              assertTrue(r.output.contains(FOO.moduleName + &quot;@&quot; + FOO.version),
 875                                 &quot;Expected to find &quot;, FOO.moduleName + &quot;@&quot; + FOO.version,
 876                                 &quot; in [&quot;, r.output, &quot;]&quot;)
 877                 );
 878         }
 879     }
 880 
 881     /**
 882      * Validate that you can update a jar only specifying --module-version
 883      * @throws IOException
 884      */
 885     @Test
 886     public void updateFooModuleVersion() throws IOException {
 887         Path mp = Paths.get(&quot;updateFooModuleVersion&quot;);
 888         createTestDir(mp);
 889         Path modClasses = MODULE_CLASSES.resolve(FOO.moduleName);
 890         Path modularJar = mp.resolve(FOO.moduleName + &quot;.jar&quot;);
 891         String newFooVersion = &quot;87.0&quot;;
 892 
 893         jar(&quot;--create&quot;,
 894             &quot;--file=&quot; + modularJar.toString(),
 895             &quot;--main-class=&quot; + FOO.mainClass,
 896             &quot;--module-version=&quot; + FOO.version,
 897             &quot;--no-manifest&quot;,
 898             &quot;-C&quot;, modClasses.toString(), &quot;.&quot;)
 899             .assertSuccess();
 900 
 901         jarWithStdin(modularJar.toFile(), &quot;--describe-module&quot;)
 902                 .assertSuccess()
 903                 .resultChecker(r -&gt;
 904                         assertTrue(r.output.contains(FOO.moduleName + &quot;@&quot; + FOO.version),
 905                                 &quot;Expected to find &quot;, FOO.moduleName + &quot;@&quot; + FOO.version,
 906                                 &quot; in [&quot;, r.output, &quot;]&quot;)
 907                 );
 908 
 909         jar(&quot;--update&quot;,
 910             &quot;--file=&quot; + modularJar.toString(),
 911             &quot;--module-version=&quot; + newFooVersion)
 912             .assertSuccess();
 913 
 914         for (String option : new String[]  {&quot;--describe-module&quot;, &quot;-d&quot; }) {
 915             jarWithStdin(modularJar.toFile(),
 916                          option)
 917                          .assertSuccess()
 918                          .resultChecker(r -&gt;
 919                              assertTrue(r.output.contains(FOO.moduleName + &quot;@&quot; + newFooVersion),
 920                                 &quot;Expected to find &quot;, FOO.moduleName + &quot;@&quot; + newFooVersion,
 921                                 &quot; in [&quot;, r.output, &quot;]&quot;)
 922                 );
 923         }
 924     }
 925 
 926     @DataProvider(name = &quot;autoNames&quot;)
 927     public Object[][] autoNames() {
 928         return new Object[][] {
 929             // JAR file name                module-name[@version]
 930             { &quot;foo.jar&quot;,                    &quot;foo&quot; },
 931             { &quot;foo1.jar&quot;,                   &quot;foo1&quot; },
 932             { &quot;foo4j.jar&quot;,                  &quot;foo4j&quot;, },
 933             { &quot;foo-1.2.3.4.jar&quot;,            &quot;foo@1.2.3.4&quot; },
 934             { &quot;foo-bar.jar&quot;,                &quot;foo.bar&quot; },
 935             { &quot;foo-1.2-SNAPSHOT.jar&quot;,       &quot;foo@1.2-SNAPSHOT&quot; },
 936         };
 937     }
 938 
 939     @Test(dataProvider = &quot;autoNames&quot;)
 940     public void describeAutomaticModule(String jarName, String mid)
 941         throws IOException
 942     {
 943         Path mp = Paths.get(&quot;describeAutomaticModule&quot;);
 944         createTestDir(mp);
 945         Path regularJar = mp.resolve(jarName);
 946         Path t = Paths.get(&quot;t&quot;);
 947         if (Files.notExists(t))
 948             Files.createFile(t);
 949 
 950         jar(&quot;--create&quot;,
 951             &quot;--file=&quot; + regularJar.toString(),
 952             t.toString())
 953             .assertSuccess();
 954 
 955         for (String option : new String[]  {&quot;--describe-module&quot;, &quot;-d&quot; }) {
 956             jar(option,
 957                 &quot;--file=&quot; + regularJar.toString())
 958                 .assertSuccess()
 959                 .resultChecker(r -&gt; {
 960                     assertTrue(r.output.contains(&quot;No module descriptor found&quot;));
 961                     assertTrue(r.output.contains(&quot;Derived automatic module&quot;));
 962                     assertTrue(r.output.contains(mid + &quot; automatic&quot;),
 963                                &quot;Expected [&quot;, &quot;module &quot; + mid,&quot;] in [&quot;, r.output, &quot;]&quot;);
 964                     }
 965                 );
 966         }
 967     }
 968 
 969     // -- Infrastructure
 970 
 971     static Result jarWithStdin(File stdinSource, String... args) {
 972         String jar = getJDKTool(&quot;jar&quot;);
 973         List&lt;String&gt; commands = new ArrayList&lt;&gt;();
 974         commands.add(jar);
 975         if (!TOOL_VM_OPTIONS.isEmpty()) {
 976             commands.addAll(Arrays.asList(TOOL_VM_OPTIONS.split(&quot;\\s+&quot;, -1)));
 977         }
 978         Stream.of(args).forEach(commands::add);
 979         ProcessBuilder p = new ProcessBuilder(commands);
<a name="5" id="anc5"></a><span class="line-modified"> 980         if (stdinSource != null)</span>
 981             p.redirectInput(stdinSource);
<a name="6" id="anc6"></a>
 982         return run(p);
 983     }
 984 
 985     static Result jar(String... args) {
<a name="7" id="anc7"></a><span class="line-modified"> 986         return jarWithStdin(null, args);</span>
 987     }
 988 
 989     static Path compileModule(String mn) throws IOException {
 990         return compileModule(mn, null);
 991     }
 992 
 993     static Path compileModule(String mn, Path mp)
 994         throws IOException
 995     {
 996         Path sourcePath = TEST_SRC.resolve(&quot;src&quot;).resolve(mn);
 997         Path build = Files.createDirectories(MODULE_CLASSES.resolve(mn));
 998         javac(build, mp, sourceList(sourcePath));
 999         return build;
1000     }
1001 
1002     static void copyResource(Path srcDir, Path dir, String resource)
1003         throws IOException
1004     {
1005         Path dest = dir.resolve(resource);
1006         Files.deleteIfExists(dest);
1007 
1008         Files.createDirectories(dest.getParent());
1009         Files.copy(srcDir.resolve(resource), dest);
1010     }
1011 
1012     static void setupMRJARModuleInfo(String moduleName) throws IOException {
1013         Path modClasses = MODULE_CLASSES.resolve(moduleName);
1014         Path metaInfDir = MRJAR_DIR.resolve(moduleName).resolve(&quot;META-INF&quot;);
1015         Path versionSection = metaInfDir.resolve(&quot;versions&quot;).resolve(&quot;9&quot;);
1016         createTestDir(versionSection);
1017 
1018         Path versionModuleInfo = versionSection.resolve(&quot;module-info.class&quot;);
1019         System.out.println(&quot;copying &quot; + modClasses.resolve(&quot;module-info.class&quot;) + &quot; to &quot; + versionModuleInfo);
1020         Files.copy(modClasses.resolve(&quot;module-info.class&quot;), versionModuleInfo);
1021 
1022         Manifest manifest = new Manifest();
1023         manifest.getMainAttributes().putValue(&quot;Manifest-Version&quot;, &quot;1.0&quot;);
1024         manifest.getMainAttributes().putValue(&quot;Multi-Release&quot;, &quot;true&quot;);
1025         try (OutputStream os = Files.newOutputStream(metaInfDir.resolve(&quot;MANIFEST.MF&quot;))) {
1026             manifest.write(os);
1027         }
1028     }
1029 
1030     static ModuleDescriptor getModuleDescriptor(Path jar) {
1031         ClassLoader cl = ClassLoader.getSystemClassLoader();
1032         try (JarFile jf = new JarFile(jar.toFile())) {
1033             JarEntry entry = jf.getJarEntry(&quot;module-info.class&quot;);
1034             try (InputStream in = jf.getInputStream(entry)) {
1035                 return ModuleDescriptor.read(in);
1036             }
1037         } catch (IOException ioe) {
1038             throw new UncheckedIOException(ioe);
1039         }
1040     }
1041 
1042     // Re-enable when there is support in javax.tools for module path
1043 //    static void javac(Path dest, Path... sourceFiles) throws IOException {
1044 //        out.printf(&quot;Compiling %d source files %s%n&quot;, sourceFiles.length,
1045 //                   Arrays.asList(sourceFiles));
1046 //        JavaCompiler compiler = ToolProvider.getSystemJavaCompiler();
1047 //        try (StandardJavaFileManager fileManager =
1048 //                     compiler.getStandardFileManager(null, null, null)) {
1049 //
1050 //            List&lt;File&gt; files = Stream.of(sourceFiles)
1051 //                                     .map(p -&gt; p.toFile())
1052 //                                     .collect(Collectors.toList());
1053 //            List&lt;File&gt; dests = Stream.of(dest)
1054 //                                     .map(p -&gt; p.toFile())
1055 //                                     .collect(Collectors.toList());
1056 //            Iterable&lt;? extends JavaFileObject&gt; compilationUnits =
1057 //                    fileManager.getJavaFileObjectsFromFiles(files);
1058 //            fileManager.setLocation(StandardLocation.CLASS_OUTPUT, dests);
1059 //            JavaCompiler.CompilationTask task =
1060 //                    compiler.getTask(null, fileManager, null, null, null, compilationUnits);
1061 //            boolean passed = task.call();
1062 //            if (!passed)
1063 //                throw new RuntimeException(&quot;Error compiling &quot; + files);
1064 //        }
1065 //    }
1066 
1067     static void javac(Path dest, Path... sourceFiles) throws IOException {
1068         javac(dest, null, sourceFiles);
1069     }
1070 
1071     static void javac(Path dest, Path modulePath, Path... sourceFiles)
1072         throws IOException
1073     {
<a name="8" id="anc8"></a><span class="line-removed">1074         String javac = getJDKTool(&quot;javac&quot;);</span>
1075 
1076         List&lt;String&gt; commands = new ArrayList&lt;&gt;();
<a name="9" id="anc9"></a><span class="line-removed">1077         commands.add(javac);</span>
1078         if (!TOOL_VM_OPTIONS.isEmpty()) {
1079             commands.addAll(Arrays.asList(TOOL_VM_OPTIONS.split(&quot;\\s+&quot;, -1)));
1080         }
1081         commands.add(&quot;-d&quot;);
1082         commands.add(dest.toString());
1083         if (dest.toString().contains(&quot;bar&quot;)) {
1084             commands.add(&quot;--add-exports&quot;);
1085             commands.add(&quot;java.base/jdk.internal.misc=bar&quot;);
1086             commands.add(&quot;--add-exports&quot;);
1087             commands.add(&quot;java.base/jdk.internal.module=bar&quot;);
1088         }
1089         if (modulePath != null) {
1090             commands.add(&quot;--module-path&quot;);
1091             commands.add(modulePath.toString());
1092         }
1093         Stream.of(sourceFiles).map(Object::toString).forEach(x -&gt; commands.add(x));
1094 
<a name="10" id="anc10"></a><span class="line-modified">1095         quickFail(run(new ProcessBuilder(commands)));</span>






1096     }
1097 
1098     static Result java(Path modulePath, String entryPoint, String... args) {
1099         String java = getJDKTool(&quot;java&quot;);
1100 
1101         List&lt;String&gt; commands = new ArrayList&lt;&gt;();
1102         commands.add(java);
1103         if (!VM_OPTIONS.isEmpty()) {
1104             commands.addAll(Arrays.asList(VM_OPTIONS.split(&quot;\\s+&quot;, -1)));
1105         }
1106         if (!JAVA_OPTIONS.isEmpty()) {
1107             commands.addAll(Arrays.asList(JAVA_OPTIONS.split(&quot;\\s+&quot;, -1)));
1108         }
1109         Stream.of(args).forEach(x -&gt; commands.add(x));
1110         commands.add(&quot;--module-path&quot;);
1111         commands.add(modulePath.toString());
1112         commands.add(&quot;-m&quot;);
1113         commands.add(entryPoint);
1114 
1115         return run(new ProcessBuilder(commands));
1116     }
1117 
1118     static Path[] sourceList(Path directory) throws IOException {
1119         return Files.find(directory, Integer.MAX_VALUE,
1120                           (file, attrs) -&gt; (file.toString().endsWith(&quot;.java&quot;)))
1121                     .toArray(Path[]::new);
1122     }
1123 
1124     static void createTestDir(Path p) throws IOException{
1125         if (Files.exists(p))
1126             FileUtils.deleteFileTreeWithRetry(p);
1127         Files.createDirectories(p);
1128     }
1129 
1130     static boolean jarContains(JarInputStream jis, String entryName)
1131         throws IOException
1132     {
1133         JarEntry e;
1134         while((e = jis.getNextJarEntry()) != null) {
1135             if (e.getName().equals(entryName))
1136                 return true;
1137         }
1138         return false;
1139     }
1140 
<a name="11" id="anc11"></a><span class="line-modified">1141     static void quickFail(Result r) {</span>
<span class="line-modified">1142         if (r.ec != 0)</span>
<span class="line-modified">1143             throw new RuntimeException(r.output);</span>




1144     }
1145 
1146     static Result run(ProcessBuilder pb) {
1147         Process p;
1148         out.printf(&quot;Running: %s%n&quot;, pb.command());
1149         try {
1150             p = pb.start();
1151         } catch (IOException e) {
1152             throw new RuntimeException(
1153                     format(&quot;Couldn&#39;t start process &#39;%s&#39;&quot;, pb.command()), e);
1154         }
1155 
1156         String output;
1157         try {
1158             output = toString(p.getInputStream(), p.getErrorStream());
1159         } catch (IOException e) {
1160             throw new RuntimeException(
1161                     format(&quot;Couldn&#39;t read process output &#39;%s&#39;&quot;, pb.command()), e);
1162         }
1163 
1164         try {
1165             p.waitFor();
1166         } catch (InterruptedException e) {
1167             throw new RuntimeException(
1168                     format(&quot;Process hasn&#39;t finished &#39;%s&#39;&quot;, pb.command()), e);
1169         }
1170         return new Result(p.exitValue(), output);
1171     }
1172 
1173     static final String DEFAULT_IMAGE_BIN = System.getProperty(&quot;java.home&quot;)
1174             + File.separator + &quot;bin&quot; + File.separator;
1175 
1176     static String getJDKTool(String name) {
1177         try {
1178             return JDKToolFinder.getJDKTool(name);
1179         } catch (Exception x) {
1180             return DEFAULT_IMAGE_BIN + name;
1181         }
1182     }
1183 
1184     static String toString(InputStream in1, InputStream in2) throws IOException {
1185         try (ByteArrayOutputStream dst = new ByteArrayOutputStream();
1186              InputStream concatenated = new SequenceInputStream(in1, in2)) {
1187             concatenated.transferTo(dst);
1188             return new String(dst.toByteArray(), &quot;UTF-8&quot;);
1189         }
1190     }
1191 
1192     static class Result {
1193         final int ec;
1194         final String output;
1195 
1196         private Result(int ec, String output) {
1197             this.ec = ec;
1198             this.output = output;
1199         }
1200         Result assertSuccess() {
1201             assertTrue(ec == 0, &quot;Expected ec 0, got: &quot;, ec, &quot; , output [&quot;, output, &quot;]&quot;);
1202             return this;
1203         }
1204         Result assertFailure() {
1205             assertTrue(ec != 0, &quot;Expected ec != 0, got:&quot;, ec, &quot; , output [&quot;, output, &quot;]&quot;);
1206             return this;
1207         }
1208         Result resultChecker(Consumer&lt;Result&gt; r) { r.accept(this); return this; }
1209     }
1210 
1211     static void assertTrue(boolean cond, Object ... failedArgs) {
1212         if (cond)
1213             return;
1214         StringBuilder sb = new StringBuilder();
1215         for (Object o : failedArgs)
1216             sb.append(o);
1217         org.testng.Assert.assertTrue(false, sb.toString());
1218     }
1219 
1220     // Standalone entry point.
1221     public static void main(String[] args) throws Throwable {
1222         Basic test = new Basic();
1223         test.compileModules();
1224         for (Method m : Basic.class.getDeclaredMethods()) {
1225             if (m.getAnnotation(Test.class) != null) {
1226                 System.out.println(&quot;Invoking &quot; + m.getName());
1227                 m.invoke(test);
1228             }
1229         }
1230     }
1231 }
<a name="12" id="anc12"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="12" type="hidden" />
</body>
</html>
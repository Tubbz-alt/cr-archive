<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff test/jdk/tools/jar/modularJar/Basic.java</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
<body>
<center><a href="../../../sun/util/resources/cldr/TimeZoneNamesTest.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="../multiRelease/Basic.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>test/jdk/tools/jar/modularJar/Basic.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 2015, 2018, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  */
  23 
  24 import java.io.*;
  25 import java.lang.module.ModuleDescriptor;
  26 import java.lang.reflect.Method;
<span class="line-modified">  27 import java.nio.file.*;</span>


  28 import java.util.*;
  29 import java.util.function.Consumer;
  30 import java.util.jar.JarEntry;
  31 import java.util.jar.JarFile;
  32 import java.util.jar.JarInputStream;
  33 import java.util.jar.Manifest;
  34 import java.util.regex.Pattern;

  35 import java.util.stream.Collectors;
  36 import java.util.stream.Stream;
  37 
  38 import jdk.test.lib.util.FileUtils;
  39 import jdk.test.lib.JDKToolFinder;
  40 import org.testng.annotations.BeforeTest;
  41 import org.testng.annotations.DataProvider;
  42 import org.testng.annotations.Test;
  43 
  44 import static java.lang.String.format;
  45 import static java.lang.System.out;
  46 
  47 /*
  48  * @test
  49  * @bug 8167328 8171830 8165640 8174248 8176772 8196748 8191533 8210454
  50  * @library /test/lib
  51  * @modules jdk.compiler
  52  *          jdk.jartool
  53  * @build jdk.test.lib.Platform
  54  *        jdk.test.lib.util.FileUtils
  55  *        jdk.test.lib.JDKToolFinder
  56  * @compile Basic.java
  57  * @run testng Basic
  58  * @summary Tests for plain Modular jars &amp; Multi-Release Modular jars
  59  */
  60 
  61 public class Basic {










  62     static final Path TEST_SRC = Paths.get(System.getProperty(&quot;test.src&quot;, &quot;.&quot;));
  63     static final Path TEST_CLASSES = Paths.get(System.getProperty(&quot;test.classes&quot;, &quot;.&quot;));
  64     static final Path MODULE_CLASSES = TEST_CLASSES.resolve(&quot;build&quot;);
  65     static final Path MRJAR_DIR = MODULE_CLASSES.resolve(&quot;mrjar&quot;);
  66 
  67     static final String VM_OPTIONS = System.getProperty(&quot;test.vm.opts&quot;, &quot;&quot;);
  68     static final String TOOL_VM_OPTIONS = System.getProperty(&quot;test.tool.vm.opts&quot;, &quot;&quot;);
  69     static final String JAVA_OPTIONS = System.getProperty(&quot;test.java.opts&quot;, &quot;&quot;);
  70 
  71     // Details based on the checked in module source
  72     static TestModuleData FOO = new TestModuleData(&quot;foo&quot;,
  73                                                    &quot;1.123&quot;,
  74                                                    &quot;jdk.test.foo.Foo&quot;,
  75                                                    &quot;Hello World!!!&quot;,
  76                                                    null, // no hashes
  77                                                    Set.of(&quot;java.base&quot;),
  78                                                    Set.of(&quot;jdk.test.foo&quot;),
  79                                                    null, // no uses
  80                                                    null, // no provides
  81                                                    Set.of(&quot;jdk.test.foo.internal&quot;,
</pre>
<hr />
<pre>
 960                     assertTrue(r.output.contains(&quot;No module descriptor found&quot;));
 961                     assertTrue(r.output.contains(&quot;Derived automatic module&quot;));
 962                     assertTrue(r.output.contains(mid + &quot; automatic&quot;),
 963                                &quot;Expected [&quot;, &quot;module &quot; + mid,&quot;] in [&quot;, r.output, &quot;]&quot;);
 964                     }
 965                 );
 966         }
 967     }
 968 
 969     // -- Infrastructure
 970 
 971     static Result jarWithStdin(File stdinSource, String... args) {
 972         String jar = getJDKTool(&quot;jar&quot;);
 973         List&lt;String&gt; commands = new ArrayList&lt;&gt;();
 974         commands.add(jar);
 975         if (!TOOL_VM_OPTIONS.isEmpty()) {
 976             commands.addAll(Arrays.asList(TOOL_VM_OPTIONS.split(&quot;\\s+&quot;, -1)));
 977         }
 978         Stream.of(args).forEach(commands::add);
 979         ProcessBuilder p = new ProcessBuilder(commands);
<span class="line-modified"> 980         if (stdinSource != null)</span>
 981             p.redirectInput(stdinSource);

 982         return run(p);
 983     }
 984 
 985     static Result jar(String... args) {
<span class="line-modified"> 986         return jarWithStdin(null, args);</span>
 987     }
 988 
 989     static Path compileModule(String mn) throws IOException {
 990         return compileModule(mn, null);
 991     }
 992 
 993     static Path compileModule(String mn, Path mp)
 994         throws IOException
 995     {
 996         Path sourcePath = TEST_SRC.resolve(&quot;src&quot;).resolve(mn);
 997         Path build = Files.createDirectories(MODULE_CLASSES.resolve(mn));
 998         javac(build, mp, sourceList(sourcePath));
 999         return build;
1000     }
1001 
1002     static void copyResource(Path srcDir, Path dir, String resource)
1003         throws IOException
1004     {
1005         Path dest = dir.resolve(resource);
1006         Files.deleteIfExists(dest);
</pre>
<hr />
<pre>
1054 //                                     .map(p -&gt; p.toFile())
1055 //                                     .collect(Collectors.toList());
1056 //            Iterable&lt;? extends JavaFileObject&gt; compilationUnits =
1057 //                    fileManager.getJavaFileObjectsFromFiles(files);
1058 //            fileManager.setLocation(StandardLocation.CLASS_OUTPUT, dests);
1059 //            JavaCompiler.CompilationTask task =
1060 //                    compiler.getTask(null, fileManager, null, null, null, compilationUnits);
1061 //            boolean passed = task.call();
1062 //            if (!passed)
1063 //                throw new RuntimeException(&quot;Error compiling &quot; + files);
1064 //        }
1065 //    }
1066 
1067     static void javac(Path dest, Path... sourceFiles) throws IOException {
1068         javac(dest, null, sourceFiles);
1069     }
1070 
1071     static void javac(Path dest, Path modulePath, Path... sourceFiles)
1072         throws IOException
1073     {
<span class="line-removed">1074         String javac = getJDKTool(&quot;javac&quot;);</span>
1075 
1076         List&lt;String&gt; commands = new ArrayList&lt;&gt;();
<span class="line-removed">1077         commands.add(javac);</span>
1078         if (!TOOL_VM_OPTIONS.isEmpty()) {
1079             commands.addAll(Arrays.asList(TOOL_VM_OPTIONS.split(&quot;\\s+&quot;, -1)));
1080         }
1081         commands.add(&quot;-d&quot;);
1082         commands.add(dest.toString());
1083         if (dest.toString().contains(&quot;bar&quot;)) {
1084             commands.add(&quot;--add-exports&quot;);
1085             commands.add(&quot;java.base/jdk.internal.misc=bar&quot;);
1086             commands.add(&quot;--add-exports&quot;);
1087             commands.add(&quot;java.base/jdk.internal.module=bar&quot;);
1088         }
1089         if (modulePath != null) {
1090             commands.add(&quot;--module-path&quot;);
1091             commands.add(modulePath.toString());
1092         }
1093         Stream.of(sourceFiles).map(Object::toString).forEach(x -&gt; commands.add(x));
1094 
<span class="line-modified">1095         quickFail(run(new ProcessBuilder(commands)));</span>






1096     }
1097 
1098     static Result java(Path modulePath, String entryPoint, String... args) {
1099         String java = getJDKTool(&quot;java&quot;);
1100 
1101         List&lt;String&gt; commands = new ArrayList&lt;&gt;();
1102         commands.add(java);
1103         if (!VM_OPTIONS.isEmpty()) {
1104             commands.addAll(Arrays.asList(VM_OPTIONS.split(&quot;\\s+&quot;, -1)));
1105         }
1106         if (!JAVA_OPTIONS.isEmpty()) {
1107             commands.addAll(Arrays.asList(JAVA_OPTIONS.split(&quot;\\s+&quot;, -1)));
1108         }
1109         Stream.of(args).forEach(x -&gt; commands.add(x));
1110         commands.add(&quot;--module-path&quot;);
1111         commands.add(modulePath.toString());
1112         commands.add(&quot;-m&quot;);
1113         commands.add(entryPoint);
1114 
1115         return run(new ProcessBuilder(commands));
</pre>
<hr />
<pre>
1121                     .toArray(Path[]::new);
1122     }
1123 
1124     static void createTestDir(Path p) throws IOException{
1125         if (Files.exists(p))
1126             FileUtils.deleteFileTreeWithRetry(p);
1127         Files.createDirectories(p);
1128     }
1129 
1130     static boolean jarContains(JarInputStream jis, String entryName)
1131         throws IOException
1132     {
1133         JarEntry e;
1134         while((e = jis.getNextJarEntry()) != null) {
1135             if (e.getName().equals(entryName))
1136                 return true;
1137         }
1138         return false;
1139     }
1140 
<span class="line-modified">1141     static void quickFail(Result r) {</span>
<span class="line-modified">1142         if (r.ec != 0)</span>
<span class="line-modified">1143             throw new RuntimeException(r.output);</span>




1144     }
1145 
1146     static Result run(ProcessBuilder pb) {
1147         Process p;
1148         out.printf(&quot;Running: %s%n&quot;, pb.command());
1149         try {
1150             p = pb.start();
1151         } catch (IOException e) {
1152             throw new RuntimeException(
1153                     format(&quot;Couldn&#39;t start process &#39;%s&#39;&quot;, pb.command()), e);
1154         }
1155 
1156         String output;
1157         try {
1158             output = toString(p.getInputStream(), p.getErrorStream());
1159         } catch (IOException e) {
1160             throw new RuntimeException(
1161                     format(&quot;Couldn&#39;t read process output &#39;%s&#39;&quot;, pb.command()), e);
1162         }
1163 
</pre>
</td>
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 2015, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  */
  23 
  24 import java.io.*;
  25 import java.lang.module.ModuleDescriptor;
  26 import java.lang.reflect.Method;
<span class="line-modified">  27 import java.nio.file.Files;</span>
<span class="line-added">  28 import java.nio.file.Path;</span>
<span class="line-added">  29 import java.nio.file.Paths;</span>
  30 import java.util.*;
  31 import java.util.function.Consumer;
  32 import java.util.jar.JarEntry;
  33 import java.util.jar.JarFile;
  34 import java.util.jar.JarInputStream;
  35 import java.util.jar.Manifest;
  36 import java.util.regex.Pattern;
<span class="line-added">  37 import java.util.spi.ToolProvider;</span>
  38 import java.util.stream.Collectors;
  39 import java.util.stream.Stream;
  40 
  41 import jdk.test.lib.util.FileUtils;
  42 import jdk.test.lib.JDKToolFinder;
  43 import org.testng.annotations.BeforeTest;
  44 import org.testng.annotations.DataProvider;
  45 import org.testng.annotations.Test;
  46 
  47 import static java.lang.String.format;
  48 import static java.lang.System.out;
  49 
  50 /*
  51  * @test
  52  * @bug 8167328 8171830 8165640 8174248 8176772 8196748 8191533 8210454
  53  * @library /test/lib
  54  * @modules jdk.compiler
  55  *          jdk.jartool
  56  * @build jdk.test.lib.Platform
  57  *        jdk.test.lib.util.FileUtils
  58  *        jdk.test.lib.JDKToolFinder
  59  * @compile Basic.java
  60  * @run testng Basic
  61  * @summary Tests for plain Modular jars &amp; Multi-Release Modular jars
  62  */
  63 
  64 public class Basic {
<span class="line-added">  65 </span>
<span class="line-added">  66     private static final ToolProvider JAR_TOOL = ToolProvider.findFirst(&quot;jar&quot;)</span>
<span class="line-added">  67             .orElseThrow(()</span>
<span class="line-added">  68                     -&gt; new RuntimeException(&quot;jar tool not found&quot;)</span>
<span class="line-added">  69             );</span>
<span class="line-added">  70     private static final ToolProvider JAVAC_TOOL = ToolProvider.findFirst(&quot;javac&quot;)</span>
<span class="line-added">  71             .orElseThrow(()</span>
<span class="line-added">  72                     -&gt; new RuntimeException(&quot;javac tool not found&quot;)</span>
<span class="line-added">  73             );</span>
<span class="line-added">  74 </span>
  75     static final Path TEST_SRC = Paths.get(System.getProperty(&quot;test.src&quot;, &quot;.&quot;));
  76     static final Path TEST_CLASSES = Paths.get(System.getProperty(&quot;test.classes&quot;, &quot;.&quot;));
  77     static final Path MODULE_CLASSES = TEST_CLASSES.resolve(&quot;build&quot;);
  78     static final Path MRJAR_DIR = MODULE_CLASSES.resolve(&quot;mrjar&quot;);
  79 
  80     static final String VM_OPTIONS = System.getProperty(&quot;test.vm.opts&quot;, &quot;&quot;);
  81     static final String TOOL_VM_OPTIONS = System.getProperty(&quot;test.tool.vm.opts&quot;, &quot;&quot;);
  82     static final String JAVA_OPTIONS = System.getProperty(&quot;test.java.opts&quot;, &quot;&quot;);
  83 
  84     // Details based on the checked in module source
  85     static TestModuleData FOO = new TestModuleData(&quot;foo&quot;,
  86                                                    &quot;1.123&quot;,
  87                                                    &quot;jdk.test.foo.Foo&quot;,
  88                                                    &quot;Hello World!!!&quot;,
  89                                                    null, // no hashes
  90                                                    Set.of(&quot;java.base&quot;),
  91                                                    Set.of(&quot;jdk.test.foo&quot;),
  92                                                    null, // no uses
  93                                                    null, // no provides
  94                                                    Set.of(&quot;jdk.test.foo.internal&quot;,
</pre>
<hr />
<pre>
 973                     assertTrue(r.output.contains(&quot;No module descriptor found&quot;));
 974                     assertTrue(r.output.contains(&quot;Derived automatic module&quot;));
 975                     assertTrue(r.output.contains(mid + &quot; automatic&quot;),
 976                                &quot;Expected [&quot;, &quot;module &quot; + mid,&quot;] in [&quot;, r.output, &quot;]&quot;);
 977                     }
 978                 );
 979         }
 980     }
 981 
 982     // -- Infrastructure
 983 
 984     static Result jarWithStdin(File stdinSource, String... args) {
 985         String jar = getJDKTool(&quot;jar&quot;);
 986         List&lt;String&gt; commands = new ArrayList&lt;&gt;();
 987         commands.add(jar);
 988         if (!TOOL_VM_OPTIONS.isEmpty()) {
 989             commands.addAll(Arrays.asList(TOOL_VM_OPTIONS.split(&quot;\\s+&quot;, -1)));
 990         }
 991         Stream.of(args).forEach(commands::add);
 992         ProcessBuilder p = new ProcessBuilder(commands);
<span class="line-modified"> 993         if (stdinSource != null) {</span>
 994             p.redirectInput(stdinSource);
<span class="line-added"> 995         }</span>
 996         return run(p);
 997     }
 998 
 999     static Result jar(String... args) {
<span class="line-modified">1000         return run(JAR_TOOL, args);</span>
1001     }
1002 
1003     static Path compileModule(String mn) throws IOException {
1004         return compileModule(mn, null);
1005     }
1006 
1007     static Path compileModule(String mn, Path mp)
1008         throws IOException
1009     {
1010         Path sourcePath = TEST_SRC.resolve(&quot;src&quot;).resolve(mn);
1011         Path build = Files.createDirectories(MODULE_CLASSES.resolve(mn));
1012         javac(build, mp, sourceList(sourcePath));
1013         return build;
1014     }
1015 
1016     static void copyResource(Path srcDir, Path dir, String resource)
1017         throws IOException
1018     {
1019         Path dest = dir.resolve(resource);
1020         Files.deleteIfExists(dest);
</pre>
<hr />
<pre>
1068 //                                     .map(p -&gt; p.toFile())
1069 //                                     .collect(Collectors.toList());
1070 //            Iterable&lt;? extends JavaFileObject&gt; compilationUnits =
1071 //                    fileManager.getJavaFileObjectsFromFiles(files);
1072 //            fileManager.setLocation(StandardLocation.CLASS_OUTPUT, dests);
1073 //            JavaCompiler.CompilationTask task =
1074 //                    compiler.getTask(null, fileManager, null, null, null, compilationUnits);
1075 //            boolean passed = task.call();
1076 //            if (!passed)
1077 //                throw new RuntimeException(&quot;Error compiling &quot; + files);
1078 //        }
1079 //    }
1080 
1081     static void javac(Path dest, Path... sourceFiles) throws IOException {
1082         javac(dest, null, sourceFiles);
1083     }
1084 
1085     static void javac(Path dest, Path modulePath, Path... sourceFiles)
1086         throws IOException
1087     {

1088 
1089         List&lt;String&gt; commands = new ArrayList&lt;&gt;();

1090         if (!TOOL_VM_OPTIONS.isEmpty()) {
1091             commands.addAll(Arrays.asList(TOOL_VM_OPTIONS.split(&quot;\\s+&quot;, -1)));
1092         }
1093         commands.add(&quot;-d&quot;);
1094         commands.add(dest.toString());
1095         if (dest.toString().contains(&quot;bar&quot;)) {
1096             commands.add(&quot;--add-exports&quot;);
1097             commands.add(&quot;java.base/jdk.internal.misc=bar&quot;);
1098             commands.add(&quot;--add-exports&quot;);
1099             commands.add(&quot;java.base/jdk.internal.module=bar&quot;);
1100         }
1101         if (modulePath != null) {
1102             commands.add(&quot;--module-path&quot;);
1103             commands.add(modulePath.toString());
1104         }
1105         Stream.of(sourceFiles).map(Object::toString).forEach(x -&gt; commands.add(x));
1106 
<span class="line-modified">1107         StringWriter sw = new StringWriter();</span>
<span class="line-added">1108         try (PrintWriter pw = new PrintWriter(sw)) {</span>
<span class="line-added">1109             int rc = JAVAC_TOOL.run(pw, pw, commands.toArray(new String[0]));</span>
<span class="line-added">1110             if(rc != 0) {</span>
<span class="line-added">1111                 throw new RuntimeException(sw.toString());</span>
<span class="line-added">1112             }</span>
<span class="line-added">1113         }</span>
1114     }
1115 
1116     static Result java(Path modulePath, String entryPoint, String... args) {
1117         String java = getJDKTool(&quot;java&quot;);
1118 
1119         List&lt;String&gt; commands = new ArrayList&lt;&gt;();
1120         commands.add(java);
1121         if (!VM_OPTIONS.isEmpty()) {
1122             commands.addAll(Arrays.asList(VM_OPTIONS.split(&quot;\\s+&quot;, -1)));
1123         }
1124         if (!JAVA_OPTIONS.isEmpty()) {
1125             commands.addAll(Arrays.asList(JAVA_OPTIONS.split(&quot;\\s+&quot;, -1)));
1126         }
1127         Stream.of(args).forEach(x -&gt; commands.add(x));
1128         commands.add(&quot;--module-path&quot;);
1129         commands.add(modulePath.toString());
1130         commands.add(&quot;-m&quot;);
1131         commands.add(entryPoint);
1132 
1133         return run(new ProcessBuilder(commands));
</pre>
<hr />
<pre>
1139                     .toArray(Path[]::new);
1140     }
1141 
1142     static void createTestDir(Path p) throws IOException{
1143         if (Files.exists(p))
1144             FileUtils.deleteFileTreeWithRetry(p);
1145         Files.createDirectories(p);
1146     }
1147 
1148     static boolean jarContains(JarInputStream jis, String entryName)
1149         throws IOException
1150     {
1151         JarEntry e;
1152         while((e = jis.getNextJarEntry()) != null) {
1153             if (e.getName().equals(entryName))
1154                 return true;
1155         }
1156         return false;
1157     }
1158 
<span class="line-modified">1159     static Result run(ToolProvider tp, String[] commands) {</span>
<span class="line-modified">1160         int rc = 0;</span>
<span class="line-modified">1161         StringWriter sw = new StringWriter();</span>
<span class="line-added">1162         try (PrintWriter pw = new PrintWriter(sw)) {</span>
<span class="line-added">1163             rc = tp.run(pw, pw, commands);</span>
<span class="line-added">1164         }</span>
<span class="line-added">1165         return new Result(rc, sw.toString());</span>
1166     }
1167 
1168     static Result run(ProcessBuilder pb) {
1169         Process p;
1170         out.printf(&quot;Running: %s%n&quot;, pb.command());
1171         try {
1172             p = pb.start();
1173         } catch (IOException e) {
1174             throw new RuntimeException(
1175                     format(&quot;Couldn&#39;t start process &#39;%s&#39;&quot;, pb.command()), e);
1176         }
1177 
1178         String output;
1179         try {
1180             output = toString(p.getInputStream(), p.getErrorStream());
1181         } catch (IOException e) {
1182             throw new RuntimeException(
1183                     format(&quot;Couldn&#39;t read process output &#39;%s&#39;&quot;, pb.command()), e);
1184         }
1185 
</pre>
</td>
</tr>
</table>
<center><a href="../../../sun/util/resources/cldr/TimeZoneNamesTest.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="../multiRelease/Basic.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
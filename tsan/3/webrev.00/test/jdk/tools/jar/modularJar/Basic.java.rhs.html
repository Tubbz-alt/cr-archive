<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames test/jdk/tools/jar/modularJar/Basic.java</title>
    <link rel="stylesheet" href="../../../../../style.css" />
    <script type="text/javascript" src="../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
<a name="1" id="anc1"></a><span class="line-modified">   2  * Copyright (c) 2015, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  */
  23 
  24 import java.io.*;
  25 import java.lang.module.ModuleDescriptor;
  26 import java.lang.reflect.Method;
<a name="2" id="anc2"></a><span class="line-modified">  27 import java.nio.file.Files;</span>
<span class="line-added">  28 import java.nio.file.Path;</span>
<span class="line-added">  29 import java.nio.file.Paths;</span>
  30 import java.util.*;
  31 import java.util.function.Consumer;
  32 import java.util.jar.JarEntry;
  33 import java.util.jar.JarFile;
  34 import java.util.jar.JarInputStream;
  35 import java.util.jar.Manifest;
  36 import java.util.regex.Pattern;
<a name="3" id="anc3"></a><span class="line-added">  37 import java.util.spi.ToolProvider;</span>
  38 import java.util.stream.Collectors;
  39 import java.util.stream.Stream;
  40 
  41 import jdk.test.lib.util.FileUtils;
  42 import jdk.test.lib.JDKToolFinder;
  43 import org.testng.annotations.BeforeTest;
  44 import org.testng.annotations.DataProvider;
  45 import org.testng.annotations.Test;
  46 
  47 import static java.lang.String.format;
  48 import static java.lang.System.out;
  49 
  50 /*
  51  * @test
  52  * @bug 8167328 8171830 8165640 8174248 8176772 8196748 8191533 8210454
  53  * @library /test/lib
  54  * @modules jdk.compiler
  55  *          jdk.jartool
  56  * @build jdk.test.lib.Platform
  57  *        jdk.test.lib.util.FileUtils
  58  *        jdk.test.lib.JDKToolFinder
  59  * @compile Basic.java
  60  * @run testng Basic
  61  * @summary Tests for plain Modular jars &amp; Multi-Release Modular jars
  62  */
  63 
  64 public class Basic {
<a name="4" id="anc4"></a><span class="line-added">  65 </span>
<span class="line-added">  66     private static final ToolProvider JAR_TOOL = ToolProvider.findFirst(&quot;jar&quot;)</span>
<span class="line-added">  67             .orElseThrow(()</span>
<span class="line-added">  68                     -&gt; new RuntimeException(&quot;jar tool not found&quot;)</span>
<span class="line-added">  69             );</span>
<span class="line-added">  70     private static final ToolProvider JAVAC_TOOL = ToolProvider.findFirst(&quot;javac&quot;)</span>
<span class="line-added">  71             .orElseThrow(()</span>
<span class="line-added">  72                     -&gt; new RuntimeException(&quot;javac tool not found&quot;)</span>
<span class="line-added">  73             );</span>
<span class="line-added">  74 </span>
  75     static final Path TEST_SRC = Paths.get(System.getProperty(&quot;test.src&quot;, &quot;.&quot;));
  76     static final Path TEST_CLASSES = Paths.get(System.getProperty(&quot;test.classes&quot;, &quot;.&quot;));
  77     static final Path MODULE_CLASSES = TEST_CLASSES.resolve(&quot;build&quot;);
  78     static final Path MRJAR_DIR = MODULE_CLASSES.resolve(&quot;mrjar&quot;);
  79 
  80     static final String VM_OPTIONS = System.getProperty(&quot;test.vm.opts&quot;, &quot;&quot;);
  81     static final String TOOL_VM_OPTIONS = System.getProperty(&quot;test.tool.vm.opts&quot;, &quot;&quot;);
  82     static final String JAVA_OPTIONS = System.getProperty(&quot;test.java.opts&quot;, &quot;&quot;);
  83 
  84     // Details based on the checked in module source
  85     static TestModuleData FOO = new TestModuleData(&quot;foo&quot;,
  86                                                    &quot;1.123&quot;,
  87                                                    &quot;jdk.test.foo.Foo&quot;,
  88                                                    &quot;Hello World!!!&quot;,
  89                                                    null, // no hashes
  90                                                    Set.of(&quot;java.base&quot;),
  91                                                    Set.of(&quot;jdk.test.foo&quot;),
  92                                                    null, // no uses
  93                                                    null, // no provides
  94                                                    Set.of(&quot;jdk.test.foo.internal&quot;,
  95                                                           &quot;jdk.test.foo.resources&quot;));
  96     static TestModuleData BAR = new TestModuleData(&quot;bar&quot;,
  97                                                    &quot;4.5.6.7&quot;,
  98                                                    &quot;jdk.test.bar.Bar&quot;,
  99                                                    &quot;Hello from Bar!&quot;,
 100                                                    null, // no hashes
 101                                                    Set.of(&quot;java.base&quot;, &quot;foo&quot;),
 102                                                    null, // no exports
 103                                                    null, // no uses
 104                                                    null, // no provides
 105                                                    Set.of(&quot;jdk.test.bar&quot;,
 106                                                           &quot;jdk.test.bar.internal&quot;));
 107 
 108     static class TestModuleData {
 109         final String moduleName;
 110         final Set&lt;String&gt; requires;
 111         final Set&lt;String&gt; exports;
 112         final Set&lt;String&gt; uses;
 113         final Set&lt;String&gt; provides;
 114         final String mainClass;
 115         final String version;
 116         final String message;
 117         final String hashes;
 118         final Set&lt;String&gt; packages;
 119 
 120         TestModuleData(String mn, String v, String mc, String m, String h,
 121                        Set&lt;String&gt; requires, Set&lt;String&gt; exports, Set&lt;String&gt; uses,
 122                        Set&lt;String&gt; provides, Set&lt;String&gt; contains) {
 123             moduleName = mn; mainClass = mc; version = v; message = m; hashes = h;
 124             this.requires = requires != null ? requires : Collections.emptySet();
 125             this.exports = exports != null ? exports : Collections.emptySet();
 126             this.uses = uses != null ? uses : Collections.emptySet();;
 127             this.provides = provides != null ? provides : Collections.emptySet();
 128             this.packages = Stream.concat(this.exports.stream(), contains.stream())
 129                                   .collect(Collectors.toSet());
 130         }
 131         static TestModuleData from(String s) {
 132             try {
 133                 BufferedReader reader = new BufferedReader(new StringReader(s));
 134                 String line;
 135                 String message = null;
 136                 String name = null, version = null, mainClass = null;
 137                 String hashes = null;
 138                 Set&lt;String&gt; requires, exports, uses, provides, conceals;
 139                 requires = exports = uses = provides = conceals = null;
 140                 while ((line = reader.readLine()) != null) {
 141                     if (line.startsWith(&quot;message:&quot;)) {
 142                         message = line.substring(&quot;message:&quot;.length());
 143                     } else if (line.startsWith(&quot;nameAndVersion:&quot;)) {
 144                         line = line.substring(&quot;nameAndVersion:&quot;.length());
 145                         int i = line.indexOf(&#39;@&#39;);
 146                         if (i != -1) {
 147                             name = line.substring(0, i);
 148                             version = line.substring(i + 1, line.length());
 149                         } else {
 150                             name = line;
 151                         }
 152                     } else if (line.startsWith(&quot;mainClass:&quot;)) {
 153                         mainClass = line.substring(&quot;mainClass:&quot;.length());
 154                     } else if (line.startsWith(&quot;requires:&quot;)) {
 155                         line = line.substring(&quot;requires:&quot;.length());
 156                         requires = stringToSet(line);
 157                     } else if (line.startsWith(&quot;exports:&quot;)) {
 158                         line = line.substring(&quot;exports:&quot;.length());
 159                         exports = stringToSet(line);
 160                     } else if (line.startsWith(&quot;uses:&quot;)) {
 161                         line = line.substring(&quot;uses:&quot;.length());
 162                         uses = stringToSet(line);
 163                     } else if (line.startsWith(&quot;provides:&quot;)) {
 164                         line = line.substring(&quot;provides:&quot;.length());
 165                         provides = stringToSet(line);
 166                     } else if (line.startsWith(&quot;hashes:&quot;)) {
 167                         hashes = line.substring(&quot;hashes:&quot;.length());
 168                     } else if (line.startsWith(&quot;contains:&quot;)) {
 169                         line = line.substring(&quot;contains:&quot;.length());
 170                         conceals = stringToSet(line);
 171                     } else if (line.contains(&quot;VM warning:&quot;)) {
 172                         continue;  // ignore server vm warning see#8196748
 173                     } else {
 174                         throw new AssertionError(&quot;Unknown value &quot; + line);
 175                     }
 176                 }
 177 
 178                 return new TestModuleData(name, version, mainClass, message,
 179                                           hashes, requires, exports, uses,
 180                                           provides, conceals);
 181             } catch (IOException x) {
 182                 throw new UncheckedIOException(x);
 183             }
 184         }
 185         static Set&lt;String&gt; stringToSet(String commaList) {
 186             Set&lt;String&gt; s = new HashSet&lt;&gt;();
 187             int i = commaList.indexOf(&#39;,&#39;);
 188             if (i != -1) {
 189                 String[] p = commaList.split(&quot;,&quot;);
 190                 Stream.of(p).forEach(s::add);
 191             } else {
 192                 s.add(commaList);
 193             }
 194             return s;
 195         }
 196     }
 197 
 198     static void assertModuleData(Result r, TestModuleData expected) {
 199         //out.printf(&quot;%s%n&quot;, r.output);
 200         TestModuleData received = TestModuleData.from(r.output);
 201         if (expected.message != null)
 202             assertTrue(expected.message.equals(received.message),
 203                        &quot;Expected message:&quot;, expected.message, &quot;, got:&quot;, received.message);
 204         assertTrue(expected.moduleName.equals(received.moduleName),
 205                    &quot;Expected moduleName: &quot;, expected.moduleName, &quot;, got:&quot;, received.moduleName);
 206         assertTrue(expected.version.equals(received.version),
 207                    &quot;Expected version: &quot;, expected.version, &quot;, got:&quot;, received.version);
 208         assertTrue(expected.mainClass.equals(received.mainClass),
 209                    &quot;Expected mainClass: &quot;, expected.mainClass, &quot;, got:&quot;, received.mainClass);
 210         assertSetsEqual(expected.requires, received.requires);
 211         assertSetsEqual(expected.exports, received.exports);
 212         assertSetsEqual(expected.uses, received.uses);
 213         assertSetsEqual(expected.provides, received.provides);
 214         assertSetsEqual(expected.packages, received.packages);
 215     }
 216 
 217     static void assertSetsEqual(Set&lt;String&gt; s1, Set&lt;String&gt; s2) {
 218         if (!s1.equals(s2)) {
 219             org.testng.Assert.assertTrue(false, s1 + &quot; vs &quot; + s2);
 220         }
 221      }
 222 
 223     @BeforeTest
 224     public void compileModules() throws Exception {
 225         compileModule(FOO.moduleName);
 226         compileModule(BAR.moduleName, MODULE_CLASSES);
 227         compileModule(&quot;baz&quot;);  // for service provider consistency checking
 228 
 229         // copy resources
 230         copyResource(TEST_SRC.resolve(&quot;src&quot;).resolve(FOO.moduleName),
 231                      MODULE_CLASSES.resolve(FOO.moduleName),
 232                      &quot;jdk/test/foo/resources/foo.properties&quot;);
 233 
 234         setupMRJARModuleInfo(FOO.moduleName);
 235         setupMRJARModuleInfo(BAR.moduleName);
 236         setupMRJARModuleInfo(&quot;baz&quot;);
 237     }
 238 
 239     @Test
 240     public void createFoo() throws IOException {
 241         Path mp = Paths.get(&quot;createFoo&quot;);
 242         createTestDir(mp);
 243         Path modClasses = MODULE_CLASSES.resolve(FOO.moduleName);
 244         Path modularJar = mp.resolve(FOO.moduleName + &quot;.jar&quot;);
 245 
 246         jar(&quot;--create&quot;,
 247             &quot;--file=&quot; + modularJar.toString(),
 248             &quot;--main-class=&quot; + FOO.mainClass,
 249             &quot;--module-version=&quot; + FOO.version,
 250             &quot;--no-manifest&quot;,
 251             &quot;-C&quot;, modClasses.toString(), &quot;.&quot;)
 252             .assertSuccess();
 253 
 254         assertSetsEqual(readPackagesAttribute(modularJar),
 255                         Set.of(&quot;jdk.test.foo&quot;,
 256                                &quot;jdk.test.foo.resources&quot;,
 257                                &quot;jdk.test.foo.internal&quot;));
 258 
 259         java(mp, FOO.moduleName + &quot;/&quot; + FOO.mainClass)
 260             .assertSuccess()
 261             .resultChecker(r -&gt; assertModuleData(r, FOO));
 262         try (InputStream fis = Files.newInputStream(modularJar);
 263              JarInputStream jis = new JarInputStream(fis)) {
 264             assertTrue(!jarContains(jis, &quot;./&quot;),
 265                        &quot;Unexpected ./ found in &quot;, modularJar.toString());
 266         }
 267     }
 268 
 269     /** Similar to createFoo, but with a Multi-Release Modular jar. */
 270     @Test
 271     public void createMRMJarFoo() throws IOException {
 272         Path mp = Paths.get(&quot;createMRMJarFoo&quot;);
 273         createTestDir(mp);
 274         Path modClasses = MODULE_CLASSES.resolve(FOO.moduleName);
 275         Path mrjarDir = MRJAR_DIR.resolve(FOO.moduleName);
 276         Path modularJar = mp.resolve(FOO.moduleName + &quot;.jar&quot;);
 277 
 278         // Positive test, create
 279         jar(&quot;--create&quot;,
 280             &quot;--file=&quot; + modularJar.toString(),
 281             &quot;--main-class=&quot; + FOO.mainClass,
 282             &quot;--module-version=&quot; + FOO.version,
 283             &quot;-m&quot;, mrjarDir.resolve(&quot;META-INF/MANIFEST.MF&quot;).toRealPath().toString(),
 284             &quot;-C&quot;, mrjarDir.toString(), &quot;META-INF/versions/9/module-info.class&quot;,
 285             &quot;-C&quot;, modClasses.toString(), &quot;.&quot;)
 286             .assertSuccess();
 287         java(mp, FOO.moduleName + &quot;/&quot; + FOO.mainClass)
 288             .assertSuccess()
 289             .resultChecker(r -&gt; assertModuleData(r, FOO));
 290     }
 291 
 292 
 293     @Test
 294     public void updateFoo() throws IOException {
 295         Path mp = Paths.get(&quot;updateFoo&quot;);
 296         createTestDir(mp);
 297         Path modClasses = MODULE_CLASSES.resolve(FOO.moduleName);
 298         Path modularJar = mp.resolve(FOO.moduleName + &quot;.jar&quot;);
 299 
 300         jar(&quot;--create&quot;,
 301             &quot;--file=&quot; + modularJar.toString(),
 302             &quot;--no-manifest&quot;,
 303             &quot;-C&quot;, modClasses.toString(), &quot;jdk&quot;)
 304             .assertSuccess();
 305         jar(&quot;--update&quot;,
 306             &quot;--file=&quot; + modularJar.toString(),
 307             &quot;--main-class=&quot; + FOO.mainClass,
 308             &quot;--module-version=&quot; + FOO.version,
 309             &quot;--no-manifest&quot;,
 310             &quot;-C&quot;, modClasses.toString(), &quot;module-info.class&quot;)
 311             .assertSuccess();
 312         java(mp, FOO.moduleName + &quot;/&quot; + FOO.mainClass)
 313             .assertSuccess()
 314             .resultChecker(r -&gt; assertModuleData(r, FOO));
 315     }
 316 
 317     @Test
 318     public void updateMRMJarFoo() throws IOException {
 319         Path mp = Paths.get(&quot;updateMRMJarFoo&quot;);
 320         createTestDir(mp);
 321         Path modClasses = MODULE_CLASSES.resolve(FOO.moduleName);
 322         Path mrjarDir = MRJAR_DIR.resolve(FOO.moduleName);
 323         Path modularJar = mp.resolve(FOO.moduleName + &quot;.jar&quot;);
 324 
 325         jar(&quot;--create&quot;,
 326             &quot;--file=&quot; + modularJar.toString(),
 327             &quot;--no-manifest&quot;,
 328             &quot;-C&quot;, modClasses.toString(), &quot;jdk&quot;)
 329             .assertSuccess();
 330         jar(&quot;--update&quot;,
 331             &quot;--file=&quot; + modularJar.toString(),
 332             &quot;--main-class=&quot; + FOO.mainClass,
 333             &quot;--module-version=&quot; + FOO.version,
 334             &quot;-m&quot;, mrjarDir.resolve(&quot;META-INF/MANIFEST.MF&quot;).toRealPath().toString(),
 335             &quot;-C&quot;, mrjarDir.toString(), &quot;META-INF/versions/9/module-info.class&quot;,
 336             &quot;-C&quot;, modClasses.toString(), &quot;module-info.class&quot;)
 337             .assertSuccess();
 338         java(mp, FOO.moduleName + &quot;/&quot; + FOO.mainClass)
 339             .assertSuccess()
 340             .resultChecker(r -&gt; assertModuleData(r, FOO));
 341     }
 342 
 343     @Test
 344     public void partialUpdateFooMainClass() throws IOException {
 345         Path mp = Paths.get(&quot;partialUpdateFooMainClass&quot;);
 346         createTestDir(mp);
 347         Path modClasses = MODULE_CLASSES.resolve(FOO.moduleName);
 348         Path modularJar = mp.resolve(FOO.moduleName + &quot;.jar&quot;);
 349 
 350         // A &quot;bad&quot; main class in first create ( and no version )
 351         jar(&quot;--create&quot;,
 352             &quot;--file=&quot; + modularJar.toString(),
 353             &quot;--main-class=&quot; + &quot;jdk.test.foo.IAmNotTheEntryPoint&quot;,
 354             &quot;--no-manifest&quot;,
 355             &quot;-C&quot;, modClasses.toString(), &quot;.&quot;)  // includes module-info.class
 356            .assertSuccess();
 357         jar(&quot;--update&quot;,
 358             &quot;--file=&quot; + modularJar.toString(),
 359             &quot;--main-class=&quot; + FOO.mainClass,
 360             &quot;--module-version=&quot; + FOO.version,
 361             &quot;--no-manifest&quot;)
 362             .assertSuccess();
 363         java(mp, FOO.moduleName + &quot;/&quot; + FOO.mainClass)
 364             .assertSuccess()
 365             .resultChecker(r -&gt; assertModuleData(r, FOO));
 366     }
 367 
 368     @Test
 369     public void partialUpdateFooVersion() throws IOException {
 370         Path mp = Paths.get(&quot;partialUpdateFooVersion&quot;);
 371         createTestDir(mp);
 372         Path modClasses = MODULE_CLASSES.resolve(FOO.moduleName);
 373         Path modularJar = mp.resolve(FOO.moduleName + &quot;.jar&quot;);
 374 
 375         // A &quot;bad&quot; version in first create ( and no main class )
 376         jar(&quot;--create&quot;,
 377             &quot;--file=&quot; + modularJar.toString(),
 378             &quot;--module-version=&quot; + &quot;100000000&quot;,
 379             &quot;--no-manifest&quot;,
 380             &quot;-C&quot;, modClasses.toString(), &quot;.&quot;)  // includes module-info.class
 381             .assertSuccess();
 382         jar(&quot;--update&quot;,
 383             &quot;--file=&quot; + modularJar.toString(),
 384             &quot;--main-class=&quot; + FOO.mainClass,
 385             &quot;--module-version=&quot; + FOO.version,
 386             &quot;--no-manifest&quot;)
 387             .assertSuccess();
 388         java(mp, FOO.moduleName + &quot;/&quot; + FOO.mainClass)
 389             .assertSuccess()
 390             .resultChecker(r -&gt; assertModuleData(r, FOO));
 391     }
 392 
 393     @Test
 394     public void partialUpdateFooNotAllFiles() throws IOException {
 395         Path mp = Paths.get(&quot;partialUpdateFooNotAllFiles&quot;);
 396         createTestDir(mp);
 397         Path modClasses = MODULE_CLASSES.resolve(FOO.moduleName);
 398         Path modularJar = mp.resolve(FOO.moduleName + &quot;.jar&quot;);
 399 
 400         // Not all files, and none from non-exported packages,
 401         // i.e. no concealed list in first create
 402         jar(&quot;--create&quot;,
 403             &quot;--file=&quot; + modularJar.toString(),
 404             &quot;--no-manifest&quot;,
 405             &quot;-C&quot;, modClasses.toString(), &quot;module-info.class&quot;,
 406             &quot;-C&quot;, modClasses.toString(), &quot;jdk/test/foo/Foo.class&quot;,
 407             &quot;-C&quot;, modClasses.toString(), &quot;jdk/test/foo/resources/foo.properties&quot;)
 408             .assertSuccess();
 409         jar(&quot;--update&quot;,
 410             &quot;--file=&quot; + modularJar.toString(),
 411             &quot;--main-class=&quot; + FOO.mainClass,
 412             &quot;--module-version=&quot; + FOO.version,
 413             &quot;--no-manifest&quot;,
 414             &quot;-C&quot;, modClasses.toString(), &quot;jdk/test/foo/internal/Message.class&quot;)
 415             .assertSuccess();
 416         java(mp, FOO.moduleName + &quot;/&quot; + FOO.mainClass)
 417             .assertSuccess()
 418             .resultChecker(r -&gt; assertModuleData(r, FOO));
 419     }
 420 
 421     @Test
 422     public void partialUpdateMRMJarFooNotAllFiles() throws IOException {
 423         Path mp = Paths.get(&quot;partialUpdateMRMJarFooNotAllFiles&quot;);
 424         createTestDir(mp);
 425         Path modClasses = MODULE_CLASSES.resolve(FOO.moduleName);
 426         Path mrjarDir = MRJAR_DIR.resolve(FOO.moduleName);
 427         Path modularJar = mp.resolve(FOO.moduleName + &quot;.jar&quot;);
 428 
 429         jar(&quot;--create&quot;,
 430             &quot;--file=&quot; + modularJar.toString(),
 431             &quot;--module-version=&quot; + FOO.version,
 432             &quot;-C&quot;, modClasses.toString(), &quot;.&quot;)
 433             .assertSuccess();
 434         jar(&quot;--update&quot;,
 435             &quot;--file=&quot; + modularJar.toString(),
 436             &quot;--main-class=&quot; + FOO.mainClass,
 437             &quot;--module-version=&quot; + FOO.version,
 438             &quot;-m&quot;, mrjarDir.resolve(&quot;META-INF/MANIFEST.MF&quot;).toRealPath().toString(),
 439             &quot;-C&quot;, mrjarDir.toString(), &quot;META-INF/versions/9/module-info.class&quot;)
 440             .assertSuccess();
 441         java(mp, FOO.moduleName + &quot;/&quot; + FOO.mainClass)
 442             .assertSuccess()
 443             .resultChecker(r -&gt; assertModuleData(r, FOO));
 444     }
 445 
 446     @Test
 447     public void partialUpdateFooAllFilesAndAttributes() throws IOException {
 448         Path mp = Paths.get(&quot;partialUpdateFooAllFilesAndAttributes&quot;);
 449         createTestDir(mp);
 450         Path modClasses = MODULE_CLASSES.resolve(FOO.moduleName);
 451         Path modularJar = mp.resolve(FOO.moduleName + &quot;.jar&quot;);
 452 
 453         // all attributes and files
 454         jar(&quot;--create&quot;,
 455             &quot;--file=&quot; + modularJar.toString(),
 456             &quot;--main-class=&quot; + FOO.mainClass,
 457             &quot;--module-version=&quot; + FOO.version,
 458             &quot;--no-manifest&quot;,
 459             &quot;-C&quot;, modClasses.toString(), &quot;.&quot;)
 460             .assertSuccess();
 461         jar(&quot;--update&quot;,
 462             &quot;--file=&quot; + modularJar.toString(),
 463             &quot;--main-class=&quot; + FOO.mainClass,
 464             &quot;--module-version=&quot; + FOO.version,
 465             &quot;--no-manifest&quot;,
 466             &quot;-C&quot;, modClasses.toString(), &quot;.&quot;)
 467             .assertSuccess();
 468         java(mp, FOO.moduleName + &quot;/&quot; + FOO.mainClass)
 469             .assertSuccess()
 470             .resultChecker(r -&gt; assertModuleData(r, FOO));
 471     }
 472 
 473     @Test
 474     public void partialUpdateFooModuleInfo() throws IOException {
 475         Path mp = Paths.get(&quot;partialUpdateFooModuleInfo&quot;);
 476         createTestDir(mp);
 477         Path modClasses = MODULE_CLASSES.resolve(FOO.moduleName);
 478         Path modularJar = mp.resolve(FOO.moduleName + &quot;.jar&quot;);
 479         Path barModInfo = MODULE_CLASSES.resolve(BAR.moduleName);
 480 
 481         jar(&quot;--create&quot;,
 482             &quot;--file=&quot; + modularJar.toString(),
 483             &quot;--main-class=&quot; + FOO.mainClass,
 484             &quot;--module-version=&quot; + FOO.version,
 485             &quot;--no-manifest&quot;,
 486             &quot;-C&quot;, modClasses.toString(), &quot;.&quot;)
 487             .assertSuccess();
 488         jar(&quot;--update&quot;,
 489             &quot;--file=&quot; + modularJar.toString(),
 490             &quot;--no-manifest&quot;,
 491             &quot;-C&quot;, barModInfo.toString(), &quot;module-info.class&quot;)  // stuff in bar&#39;s info
 492             .assertSuccess();
 493         jar(&quot;-d&quot;,
 494             &quot;--file=&quot; + modularJar.toString())
 495             .assertSuccess()
 496             .resultChecker(r -&gt; {
 497                 // Expect &quot;bar jar:file:/.../!module-info.class&quot;
 498                 // conceals jdk.test.foo, conceals jdk.test.foo.internal&quot;
 499                 String uri = &quot;jar:&quot; + modularJar.toUri().toString() + &quot;/!module-info.class&quot;;
 500                 assertTrue(r.output.contains(&quot;bar &quot; + uri),
 501                            &quot;Expecting to find \&quot;bar &quot; + uri + &quot;\&quot;&quot;,
 502                            &quot;in output, but did not: [&quot; + r.output + &quot;]&quot;);
 503                 Pattern p = Pattern.compile(
 504                         &quot;contains\\s+jdk.test.foo\\s+contains\\s+jdk.test.foo.internal&quot;);
 505                 assertTrue(p.matcher(r.output).find(),
 506                            &quot;Expecting to find \&quot;contains jdk.test.foo,...\&quot;&quot;,
 507                            &quot;in output, but did not: [&quot; + r.output + &quot;]&quot;);
 508             });
 509     }
 510 
 511 
 512     @Test
 513     public void partialUpdateFooPackagesAttribute() throws IOException {
 514         Path mp = Paths.get(&quot;partialUpdateFooPackagesAttribute&quot;);
 515         createTestDir(mp);
 516         Path modClasses = MODULE_CLASSES.resolve(FOO.moduleName);
 517         Path modularJar = mp.resolve(FOO.moduleName + &quot;.jar&quot;);
 518 
 519         // Not all files, and none from non-exported packages,
 520         // i.e. no concealed list in first create
 521         jar(&quot;--create&quot;,
 522             &quot;--file=&quot; + modularJar.toString(),
 523             &quot;--no-manifest&quot;,
 524             &quot;-C&quot;, modClasses.toString(), &quot;module-info.class&quot;,
 525             &quot;-C&quot;, modClasses.toString(), &quot;jdk/test/foo/Foo.class&quot;)
 526             .assertSuccess();
 527 
 528         assertSetsEqual(readPackagesAttribute(modularJar),
 529                         Set.of(&quot;jdk.test.foo&quot;));
 530 
 531         jar(&quot;--update&quot;,
 532             &quot;--file=&quot; + modularJar.toString(),
 533             &quot;-C&quot;, modClasses.toString(), &quot;jdk/test/foo/resources/foo.properties&quot;)
 534             .assertSuccess();
 535 
 536         assertSetsEqual(readPackagesAttribute(modularJar),
 537                         Set.of(&quot;jdk.test.foo&quot;, &quot;jdk.test.foo.resources&quot;));
 538 
 539         jar(&quot;--update&quot;,
 540             &quot;--file=&quot; + modularJar.toString(),
 541             &quot;--main-class=&quot; + FOO.mainClass,
 542             &quot;--module-version=&quot; + FOO.version,
 543             &quot;--no-manifest&quot;,
 544             &quot;-C&quot;, modClasses.toString(), &quot;jdk/test/foo/internal/Message.class&quot;)
 545             .assertSuccess();
 546 
 547         assertSetsEqual(readPackagesAttribute(modularJar),
 548                         Set.of(&quot;jdk.test.foo&quot;,
 549                                &quot;jdk.test.foo.resources&quot;,
 550                                &quot;jdk.test.foo.internal&quot;));
 551 
 552         java(mp, FOO.moduleName + &quot;/&quot; + FOO.mainClass)
 553             .assertSuccess()
 554             .resultChecker(r -&gt; assertModuleData(r, FOO));
 555     }
 556 
 557     private Set&lt;String&gt; readPackagesAttribute(Path jar) {
 558         return getModuleDescriptor(jar).packages();
 559     }
 560 
 561     @Test
 562     public void hashBarInFooModule() throws IOException {
 563         Path mp = Paths.get(&quot;dependencesFooBar&quot;);
 564         createTestDir(mp);
 565 
 566         Path modClasses = MODULE_CLASSES.resolve(BAR.moduleName);
 567         Path modularJar = mp.resolve(BAR.moduleName + &quot;.jar&quot;);
 568         jar(&quot;--create&quot;,
 569             &quot;--file=&quot; + modularJar.toString(),
 570             &quot;--main-class=&quot; + BAR.mainClass,
 571             &quot;--module-version=&quot; + BAR.version,
 572             &quot;--no-manifest&quot;,
 573             &quot;-C&quot;, modClasses.toString(), &quot;.&quot;)
 574             .assertSuccess();
 575 
 576         modClasses = MODULE_CLASSES.resolve(FOO.moduleName);
 577         modularJar = mp.resolve(FOO.moduleName + &quot;.jar&quot;);
 578         jar(&quot;--create&quot;,
 579             &quot;--file=&quot; + modularJar.toString(),
 580             &quot;--main-class=&quot; + FOO.mainClass,
 581             &quot;--module-version=&quot; + FOO.version,
 582             &quot;--module-path=&quot; + mp.toString(),
 583             &quot;--hash-modules=&quot; + &quot;bar&quot;,
 584             &quot;--no-manifest&quot;,
 585             &quot;-C&quot;, modClasses.toString(), &quot;.&quot;)
 586             .assertSuccess();
 587 
 588         java(mp, BAR.moduleName + &quot;/&quot; + BAR.mainClass,
 589              &quot;--add-exports&quot;, &quot;java.base/jdk.internal.misc=bar&quot;,
 590              &quot;--add-exports&quot;, &quot;java.base/jdk.internal.module=bar&quot;)
 591             .assertSuccess()
 592             .resultChecker(r -&gt; {
 593                 assertModuleData(r, BAR);
 594                 TestModuleData received = TestModuleData.from(r.output);
 595                 assertTrue(received.hashes != null, &quot;Expected non-null hashes value.&quot;);
 596             });
 597     }
 598 
 599     @Test
 600     public void invalidHashInFooModule() throws IOException {
 601         Path mp = Paths.get(&quot;badDependencyFooBar&quot;);
 602         createTestDir(mp);
 603 
 604         Path barClasses = MODULE_CLASSES.resolve(BAR.moduleName);
 605         Path barJar = mp.resolve(BAR.moduleName + &quot;.jar&quot;);
 606         jar(&quot;--create&quot;,
 607             &quot;--file=&quot; + barJar.toString(),
 608             &quot;--main-class=&quot; + BAR.mainClass,
 609             &quot;--module-version=&quot; + BAR.version,
 610             &quot;--no-manifest&quot;,
 611             &quot;-C&quot;, barClasses.toString(), &quot;.&quot;).assertSuccess();
 612 
 613         Path fooClasses = MODULE_CLASSES.resolve(FOO.moduleName);
 614         Path fooJar = mp.resolve(FOO.moduleName + &quot;.jar&quot;);
 615         jar(&quot;--create&quot;,
 616             &quot;--file=&quot; + fooJar.toString(),
 617             &quot;--main-class=&quot; + FOO.mainClass,
 618             &quot;--module-version=&quot; + FOO.version,
 619             &quot;-p&quot;, mp.toString(),  // test short-form
 620             &quot;--hash-modules=&quot; + &quot;bar&quot;,
 621             &quot;--no-manifest&quot;,
 622             &quot;-C&quot;, fooClasses.toString(), &quot;.&quot;).assertSuccess();
 623 
 624         // Rebuild bar.jar with a change that will cause its hash to be different
 625         FileUtils.deleteFileWithRetry(barJar);
 626         jar(&quot;--create&quot;,
 627             &quot;--file=&quot; + barJar.toString(),
 628             &quot;--main-class=&quot; + BAR.mainClass,
 629             &quot;--module-version=&quot; + BAR.version + &quot;.1&quot;, // a newer version
 630             &quot;--no-manifest&quot;,
 631             &quot;-C&quot;, barClasses.toString(), &quot;.&quot;).assertSuccess();
 632 
 633         java(mp, BAR.moduleName + &quot;/&quot; + BAR.mainClass,
 634              &quot;--add-exports&quot;, &quot;java.base/jdk.internal.misc=bar&quot;,
 635              &quot;--add-exports&quot;, &quot;java.base/jdk.internal.module=bar&quot;)
 636             .assertFailure()
 637             .resultChecker(r -&gt; {
 638                 // Expect similar output: &quot;java.lang.module.ResolutionException: Hash
 639                 // of bar (WdktSIQSkd4+CEacpOZoeDrCosMATNrIuNub9b5yBeo=) differs to
 640                 // expected hash (iepvdv8xTeVrFgMtUhcFnmetSub6qQHCHc92lSaSEg0=)&quot;
 641                 Pattern p = Pattern.compile(&quot;.*Hash of bar.*differs to expected hash.*&quot;);
 642                 assertTrue(p.matcher(r.output).find(),
 643                       &quot;Expecting error message containing \&quot;Hash of bar ... differs to&quot;
 644                               + &quot; expected hash...\&quot; but got: [&quot;, r.output + &quot;]&quot;);
 645             });
 646     }
 647 
 648     @Test
 649     public void badOptionsFoo() throws IOException {
 650         Path mp = Paths.get(&quot;badOptionsFoo&quot;);
 651         createTestDir(mp);
 652         Path modClasses = MODULE_CLASSES.resolve(FOO.moduleName);
 653         Path modularJar = mp.resolve(FOO.moduleName + &quot;.jar&quot;);
 654 
 655         jar(&quot;--create&quot;,
 656             &quot;--file=&quot; + modularJar.toString(),
 657             &quot;--module-version=&quot; + 1.1,   // no module-info.class
 658             &quot;-C&quot;, modClasses.toString(), &quot;jdk&quot;)
 659             .assertFailure();      // TODO: expected failure message
 660 
 661          jar(&quot;--create&quot;,
 662              &quot;--file=&quot; + modularJar.toString(),
 663              &quot;--hash-modules=&quot; + &quot;.*&quot;,   // no module-info.class
 664              &quot;-C&quot;, modClasses.toString(), &quot;jdk&quot;)
 665              .assertFailure();      // TODO: expected failure message
 666     }
 667 
 668     @Test
 669     public void servicesCreateWithoutFailure() throws IOException {
 670         Path mp = Paths.get(&quot;servicesCreateWithoutFailure&quot;);
 671         createTestDir(mp);
 672         Path modClasses = MODULE_CLASSES.resolve(&quot;baz&quot;);
 673         Path modularJar = mp.resolve(&quot;baz&quot; + &quot;.jar&quot;);
 674 
 675         // Positive test, create
 676         jar(&quot;--create&quot;,
 677             &quot;--file=&quot; + modularJar.toString(),
 678             &quot;-C&quot;, modClasses.toString(), &quot;module-info.class&quot;,
 679             &quot;-C&quot;, modClasses.toString(), &quot;jdk/test/baz/BazService.class&quot;,
 680             &quot;-C&quot;, modClasses.toString(), &quot;jdk/test/baz/internal/BazServiceImpl.class&quot;)
 681             .assertSuccess();
 682 
 683         for (String option : new String[]  {&quot;--describe-module&quot;, &quot;-d&quot; }) {
 684             jar(option,
 685                 &quot;--file=&quot; + modularJar.toString())
 686                 .assertSuccess()
 687                 .resultChecker(r -&gt;
 688                     assertTrue(r.output.contains(&quot;provides jdk.test.baz.BazService with jdk.test.baz.internal.BazServiceImpl&quot;),
 689                                &quot;Expected to find &quot;, &quot;provides jdk.test.baz.BazService with jdk.test.baz.internal.BazServiceImpl&quot;,
 690                                &quot; in [&quot;, r.output, &quot;]&quot;)
 691                 );
 692         }
 693     }
 694 
 695     @Test
 696     public void servicesCreateWithoutServiceImpl() throws IOException {
 697         Path mp = Paths.get(&quot;servicesWithoutServiceImpl&quot;);
 698         createTestDir(mp);
 699         Path modClasses = MODULE_CLASSES.resolve(&quot;baz&quot;);
 700         Path modularJar = mp.resolve(&quot;baz&quot; + &quot;.jar&quot;);
 701 
 702         // Omit service impl
 703         jar(&quot;--create&quot;,
 704             &quot;--file=&quot; + modularJar.toString(),
 705             &quot;-C&quot;, modClasses.toString(), &quot;module-info.class&quot;,
 706             &quot;-C&quot;, modClasses.toString(), &quot;jdk/test/baz/BazService.class&quot;)
 707             .assertFailure();
 708     }
 709 
 710     @Test
 711     public void servicesUpdateWithoutFailure() throws IOException {
 712         Path mp = Paths.get(&quot;servicesUpdateWithoutFailure&quot;);
 713         createTestDir(mp);
 714         Path modClasses = MODULE_CLASSES.resolve(&quot;baz&quot;);
 715         Path modularJar = mp.resolve(&quot;baz&quot; + &quot;.jar&quot;);
 716 
 717         // Positive test, update
 718         jar(&quot;--create&quot;,
 719             &quot;--file=&quot; + modularJar.toString(),
 720             &quot;-C&quot;, modClasses.toString(), &quot;jdk/test/baz/BazService.class&quot;,
 721             &quot;-C&quot;, modClasses.toString(), &quot;jdk/test/baz/internal/BazServiceImpl.class&quot;)
 722             .assertSuccess();
 723         jar(&quot;--update&quot;,
 724             &quot;--file=&quot; + modularJar.toString(),
 725             &quot;-C&quot;, modClasses.toString(), &quot;module-info.class&quot;)
 726             .assertSuccess();
 727     }
 728 
 729     @Test
 730     public void servicesUpdateWithoutServiceImpl() throws IOException {
 731         Path mp = Paths.get(&quot;servicesUpdateWithoutServiceImpl&quot;);
 732         createTestDir(mp);
 733         Path modClasses = MODULE_CLASSES.resolve(&quot;baz&quot;);
 734         Path modularJar = mp.resolve(&quot;baz&quot; + &quot;.jar&quot;);
 735 
 736         // Omit service impl
 737         jar(&quot;--create&quot;,
 738             &quot;--file=&quot; + modularJar.toString(),
 739             &quot;-C&quot;, modClasses.toString(), &quot;jdk/test/baz/BazService.class&quot;)
 740             .assertSuccess();
 741         jar(&quot;--update&quot;,
 742             &quot;--file=&quot; + modularJar.toString(),
 743             &quot;-C&quot;, modClasses.toString(), &quot;module-info.class&quot;)
 744             .assertFailure();
 745     }
 746 
 747     @Test
 748     public void servicesCreateWithoutFailureMRMJAR() throws IOException {
 749         Path mp = Paths.get(&quot;servicesCreateWithoutFailureMRMJAR&quot;);
 750         createTestDir(mp);
 751         Path modClasses = MODULE_CLASSES.resolve(&quot;baz&quot;);
 752         Path mrjarDir = MRJAR_DIR.resolve(&quot;baz&quot;);
 753         Path modularJar = mp.resolve(&quot;baz&quot; + &quot;.jar&quot;);
 754 
 755         jar(&quot;--create&quot;,
 756             &quot;--file=&quot; + modularJar.toString(),
 757             &quot;-m&quot;, mrjarDir.resolve(&quot;META-INF/MANIFEST.MF&quot;).toRealPath().toString(),
 758             &quot;-C&quot;, modClasses.toString(), &quot;module-info.class&quot;,
 759             &quot;-C&quot;, mrjarDir.toString(), &quot;META-INF/versions/9/module-info.class&quot;,
 760             &quot;-C&quot;, modClasses.toString(), &quot;jdk/test/baz/BazService.class&quot;,
 761             &quot;-C&quot;, modClasses.toString(), &quot;jdk/test/baz/internal/BazServiceImpl.class&quot;)
 762             .assertSuccess();
 763     }
 764 
 765     @Test
 766     public void servicesCreateWithoutFailureNonRootMRMJAR() throws IOException {
 767         // without a root module-info.class
 768         Path mp = Paths.get(&quot;servicesCreateWithoutFailureNonRootMRMJAR&quot;);
 769         createTestDir(mp);
 770         Path modClasses = MODULE_CLASSES.resolve(&quot;baz&quot;);
 771         Path mrjarDir = MRJAR_DIR.resolve(&quot;baz&quot;);
 772         Path modularJar = mp.resolve(&quot;baz.jar&quot;);
 773 
 774         jar(&quot;--create&quot;,
 775             &quot;--file=&quot; + modularJar.toString(),
 776             &quot;--main-class=&quot; + &quot;jdk.test.baz.Baz&quot;,
 777             &quot;-m&quot;, mrjarDir.resolve(&quot;META-INF/MANIFEST.MF&quot;).toRealPath().toString(),
 778             &quot;-C&quot;, mrjarDir.toString(), &quot;META-INF/versions/9/module-info.class&quot;,
 779             &quot;-C&quot;, modClasses.toString(), &quot;jdk/test/baz/BazService.class&quot;,
 780             &quot;-C&quot;, modClasses.toString(), &quot;jdk/test/baz/Baz.class&quot;,
 781             &quot;-C&quot;, modClasses.toString(), &quot;jdk/test/baz/internal/BazServiceImpl.class&quot;)
 782             .assertSuccess();
 783 
 784 
 785         for (String option : new String[]  {&quot;--describe-module&quot;, &quot;-d&quot; }) {
 786 
 787             jar(option,
 788                 &quot;--file=&quot; + modularJar.toString(),
 789                 &quot;--release&quot;, &quot;9&quot;)
 790                 .assertSuccess()
 791                 .resultChecker(r -&gt;
 792                     assertTrue(r.output.contains(&quot;main-class jdk.test.baz.Baz&quot;),
 793                               &quot;Expected to find &quot;, &quot;main-class jdk.test.baz.Baz&quot;,
 794                                &quot; in [&quot;, r.output, &quot;]&quot;));
 795 
 796             jarWithStdin(modularJar.toFile(), option, &quot;--release&quot;, &quot;9&quot;)
 797                 .assertSuccess()
 798                 .resultChecker(r -&gt;
 799                     assertTrue(r.output.contains(&quot;main-class jdk.test.baz.Baz&quot;),
 800                               &quot;Expected to find &quot;, &quot;main-class jdk.test.baz.Baz&quot;,
 801                                &quot; in [&quot;, r.output, &quot;]&quot;));
 802 
 803         }
 804         // run module main class
 805         java(mp, &quot;baz/jdk.test.baz.Baz&quot;)
 806             .assertSuccess()
 807             .resultChecker(r -&gt;
 808                assertTrue(r.output.contains(&quot;mainClass:jdk.test.baz.Baz&quot;),
 809                           &quot;Expected to find &quot;, &quot;mainClass:jdk.test.baz.Baz&quot;,
 810                           &quot; in [&quot;, r.output, &quot;]&quot;));
 811     }
 812 
 813     @Test
 814     public void exportCreateWithMissingPkg() throws IOException {
 815 
 816         Path foobar = TEST_SRC.resolve(&quot;src&quot;).resolve(&quot;foobar&quot;);
 817         Path dst = Files.createDirectories(MODULE_CLASSES.resolve(&quot;foobar&quot;));
 818         javac(dst, null, sourceList(foobar));
 819 
 820         Path mp = Paths.get(&quot;exportWithMissingPkg&quot;);
 821         createTestDir(mp);
 822         Path modClasses = dst;
 823         Path modularJar = mp.resolve(&quot;foofoo.jar&quot;);
 824 
 825         jar(&quot;--create&quot;,
 826             &quot;--file=&quot; + modularJar.toString(),
 827             &quot;-C&quot;, modClasses.toString(), &quot;module-info.class&quot;,
 828             &quot;-C&quot;, modClasses.toString(), &quot;jdk/test/foo/Foo.class&quot;)
 829             .assertFailure();
 830     }
 831 
 832     @Test
 833     public void describeModuleFoo() throws IOException {
 834         Path mp = Paths.get(&quot;describeModuleFoo&quot;);
 835         createTestDir(mp);
 836         Path modClasses = MODULE_CLASSES.resolve(FOO.moduleName);
 837         Path modularJar = mp.resolve(FOO.moduleName + &quot;.jar&quot;);
 838 
 839         jar(&quot;--create&quot;,
 840             &quot;--file=&quot; + modularJar.toString(),
 841             &quot;--main-class=&quot; + FOO.mainClass,
 842             &quot;--module-version=&quot; + FOO.version,
 843             &quot;--no-manifest&quot;,
 844             &quot;-C&quot;, modClasses.toString(), &quot;.&quot;)
 845             .assertSuccess();
 846 
 847         for (String option : new String[]  {&quot;--describe-module&quot;, &quot;-d&quot; }) {
 848             jar(option,
 849                 &quot;--file=&quot; + modularJar.toString())
 850                 .assertSuccess()
 851                 .resultChecker(r -&gt;
 852                     assertTrue(r.output.contains(FOO.moduleName + &quot;@&quot; + FOO.version),
 853                                &quot;Expected to find &quot;, FOO.moduleName + &quot;@&quot; + FOO.version,
 854                                &quot; in [&quot;, r.output, &quot;]&quot;)
 855                 );
 856 
 857             jar(option,
 858                 &quot;--file=&quot; + modularJar.toString(),
 859                 modularJar.toString())
 860             .assertFailure();
 861 
 862             jar(option, modularJar.toString())
 863             .assertFailure();
 864         }
 865     }
 866 
 867     @Test
 868     public void describeModuleFooFromStdin() throws IOException {
 869         Path mp = Paths.get(&quot;describeModuleFooFromStdin&quot;);
 870         createTestDir(mp);
 871         Path modClasses = MODULE_CLASSES.resolve(FOO.moduleName);
 872         Path modularJar = mp.resolve(FOO.moduleName + &quot;.jar&quot;);
 873 
 874         jar(&quot;--create&quot;,
 875             &quot;--file=&quot; + modularJar.toString(),
 876             &quot;--main-class=&quot; + FOO.mainClass,
 877             &quot;--module-version=&quot; + FOO.version,
 878             &quot;--no-manifest&quot;,
 879             &quot;-C&quot;, modClasses.toString(), &quot;.&quot;)
 880             .assertSuccess();
 881 
 882         for (String option : new String[]  {&quot;--describe-module&quot;, &quot;-d&quot; }) {
 883             jarWithStdin(modularJar.toFile(),
 884                          option)
 885                          .assertSuccess()
 886                          .resultChecker(r -&gt;
 887                              assertTrue(r.output.contains(FOO.moduleName + &quot;@&quot; + FOO.version),
 888                                 &quot;Expected to find &quot;, FOO.moduleName + &quot;@&quot; + FOO.version,
 889                                 &quot; in [&quot;, r.output, &quot;]&quot;)
 890                 );
 891         }
 892     }
 893 
 894     /**
 895      * Validate that you can update a jar only specifying --module-version
 896      * @throws IOException
 897      */
 898     @Test
 899     public void updateFooModuleVersion() throws IOException {
 900         Path mp = Paths.get(&quot;updateFooModuleVersion&quot;);
 901         createTestDir(mp);
 902         Path modClasses = MODULE_CLASSES.resolve(FOO.moduleName);
 903         Path modularJar = mp.resolve(FOO.moduleName + &quot;.jar&quot;);
 904         String newFooVersion = &quot;87.0&quot;;
 905 
 906         jar(&quot;--create&quot;,
 907             &quot;--file=&quot; + modularJar.toString(),
 908             &quot;--main-class=&quot; + FOO.mainClass,
 909             &quot;--module-version=&quot; + FOO.version,
 910             &quot;--no-manifest&quot;,
 911             &quot;-C&quot;, modClasses.toString(), &quot;.&quot;)
 912             .assertSuccess();
 913 
 914         jarWithStdin(modularJar.toFile(), &quot;--describe-module&quot;)
 915                 .assertSuccess()
 916                 .resultChecker(r -&gt;
 917                         assertTrue(r.output.contains(FOO.moduleName + &quot;@&quot; + FOO.version),
 918                                 &quot;Expected to find &quot;, FOO.moduleName + &quot;@&quot; + FOO.version,
 919                                 &quot; in [&quot;, r.output, &quot;]&quot;)
 920                 );
 921 
 922         jar(&quot;--update&quot;,
 923             &quot;--file=&quot; + modularJar.toString(),
 924             &quot;--module-version=&quot; + newFooVersion)
 925             .assertSuccess();
 926 
 927         for (String option : new String[]  {&quot;--describe-module&quot;, &quot;-d&quot; }) {
 928             jarWithStdin(modularJar.toFile(),
 929                          option)
 930                          .assertSuccess()
 931                          .resultChecker(r -&gt;
 932                              assertTrue(r.output.contains(FOO.moduleName + &quot;@&quot; + newFooVersion),
 933                                 &quot;Expected to find &quot;, FOO.moduleName + &quot;@&quot; + newFooVersion,
 934                                 &quot; in [&quot;, r.output, &quot;]&quot;)
 935                 );
 936         }
 937     }
 938 
 939     @DataProvider(name = &quot;autoNames&quot;)
 940     public Object[][] autoNames() {
 941         return new Object[][] {
 942             // JAR file name                module-name[@version]
 943             { &quot;foo.jar&quot;,                    &quot;foo&quot; },
 944             { &quot;foo1.jar&quot;,                   &quot;foo1&quot; },
 945             { &quot;foo4j.jar&quot;,                  &quot;foo4j&quot;, },
 946             { &quot;foo-1.2.3.4.jar&quot;,            &quot;foo@1.2.3.4&quot; },
 947             { &quot;foo-bar.jar&quot;,                &quot;foo.bar&quot; },
 948             { &quot;foo-1.2-SNAPSHOT.jar&quot;,       &quot;foo@1.2-SNAPSHOT&quot; },
 949         };
 950     }
 951 
 952     @Test(dataProvider = &quot;autoNames&quot;)
 953     public void describeAutomaticModule(String jarName, String mid)
 954         throws IOException
 955     {
 956         Path mp = Paths.get(&quot;describeAutomaticModule&quot;);
 957         createTestDir(mp);
 958         Path regularJar = mp.resolve(jarName);
 959         Path t = Paths.get(&quot;t&quot;);
 960         if (Files.notExists(t))
 961             Files.createFile(t);
 962 
 963         jar(&quot;--create&quot;,
 964             &quot;--file=&quot; + regularJar.toString(),
 965             t.toString())
 966             .assertSuccess();
 967 
 968         for (String option : new String[]  {&quot;--describe-module&quot;, &quot;-d&quot; }) {
 969             jar(option,
 970                 &quot;--file=&quot; + regularJar.toString())
 971                 .assertSuccess()
 972                 .resultChecker(r -&gt; {
 973                     assertTrue(r.output.contains(&quot;No module descriptor found&quot;));
 974                     assertTrue(r.output.contains(&quot;Derived automatic module&quot;));
 975                     assertTrue(r.output.contains(mid + &quot; automatic&quot;),
 976                                &quot;Expected [&quot;, &quot;module &quot; + mid,&quot;] in [&quot;, r.output, &quot;]&quot;);
 977                     }
 978                 );
 979         }
 980     }
 981 
 982     // -- Infrastructure
 983 
 984     static Result jarWithStdin(File stdinSource, String... args) {
 985         String jar = getJDKTool(&quot;jar&quot;);
 986         List&lt;String&gt; commands = new ArrayList&lt;&gt;();
 987         commands.add(jar);
 988         if (!TOOL_VM_OPTIONS.isEmpty()) {
 989             commands.addAll(Arrays.asList(TOOL_VM_OPTIONS.split(&quot;\\s+&quot;, -1)));
 990         }
 991         Stream.of(args).forEach(commands::add);
 992         ProcessBuilder p = new ProcessBuilder(commands);
<a name="5" id="anc5"></a><span class="line-modified"> 993         if (stdinSource != null) {</span>
 994             p.redirectInput(stdinSource);
<a name="6" id="anc6"></a><span class="line-added"> 995         }</span>
 996         return run(p);
 997     }
 998 
 999     static Result jar(String... args) {
<a name="7" id="anc7"></a><span class="line-modified">1000         return run(JAR_TOOL, args);</span>
1001     }
1002 
1003     static Path compileModule(String mn) throws IOException {
1004         return compileModule(mn, null);
1005     }
1006 
1007     static Path compileModule(String mn, Path mp)
1008         throws IOException
1009     {
1010         Path sourcePath = TEST_SRC.resolve(&quot;src&quot;).resolve(mn);
1011         Path build = Files.createDirectories(MODULE_CLASSES.resolve(mn));
1012         javac(build, mp, sourceList(sourcePath));
1013         return build;
1014     }
1015 
1016     static void copyResource(Path srcDir, Path dir, String resource)
1017         throws IOException
1018     {
1019         Path dest = dir.resolve(resource);
1020         Files.deleteIfExists(dest);
1021 
1022         Files.createDirectories(dest.getParent());
1023         Files.copy(srcDir.resolve(resource), dest);
1024     }
1025 
1026     static void setupMRJARModuleInfo(String moduleName) throws IOException {
1027         Path modClasses = MODULE_CLASSES.resolve(moduleName);
1028         Path metaInfDir = MRJAR_DIR.resolve(moduleName).resolve(&quot;META-INF&quot;);
1029         Path versionSection = metaInfDir.resolve(&quot;versions&quot;).resolve(&quot;9&quot;);
1030         createTestDir(versionSection);
1031 
1032         Path versionModuleInfo = versionSection.resolve(&quot;module-info.class&quot;);
1033         System.out.println(&quot;copying &quot; + modClasses.resolve(&quot;module-info.class&quot;) + &quot; to &quot; + versionModuleInfo);
1034         Files.copy(modClasses.resolve(&quot;module-info.class&quot;), versionModuleInfo);
1035 
1036         Manifest manifest = new Manifest();
1037         manifest.getMainAttributes().putValue(&quot;Manifest-Version&quot;, &quot;1.0&quot;);
1038         manifest.getMainAttributes().putValue(&quot;Multi-Release&quot;, &quot;true&quot;);
1039         try (OutputStream os = Files.newOutputStream(metaInfDir.resolve(&quot;MANIFEST.MF&quot;))) {
1040             manifest.write(os);
1041         }
1042     }
1043 
1044     static ModuleDescriptor getModuleDescriptor(Path jar) {
1045         ClassLoader cl = ClassLoader.getSystemClassLoader();
1046         try (JarFile jf = new JarFile(jar.toFile())) {
1047             JarEntry entry = jf.getJarEntry(&quot;module-info.class&quot;);
1048             try (InputStream in = jf.getInputStream(entry)) {
1049                 return ModuleDescriptor.read(in);
1050             }
1051         } catch (IOException ioe) {
1052             throw new UncheckedIOException(ioe);
1053         }
1054     }
1055 
1056     // Re-enable when there is support in javax.tools for module path
1057 //    static void javac(Path dest, Path... sourceFiles) throws IOException {
1058 //        out.printf(&quot;Compiling %d source files %s%n&quot;, sourceFiles.length,
1059 //                   Arrays.asList(sourceFiles));
1060 //        JavaCompiler compiler = ToolProvider.getSystemJavaCompiler();
1061 //        try (StandardJavaFileManager fileManager =
1062 //                     compiler.getStandardFileManager(null, null, null)) {
1063 //
1064 //            List&lt;File&gt; files = Stream.of(sourceFiles)
1065 //                                     .map(p -&gt; p.toFile())
1066 //                                     .collect(Collectors.toList());
1067 //            List&lt;File&gt; dests = Stream.of(dest)
1068 //                                     .map(p -&gt; p.toFile())
1069 //                                     .collect(Collectors.toList());
1070 //            Iterable&lt;? extends JavaFileObject&gt; compilationUnits =
1071 //                    fileManager.getJavaFileObjectsFromFiles(files);
1072 //            fileManager.setLocation(StandardLocation.CLASS_OUTPUT, dests);
1073 //            JavaCompiler.CompilationTask task =
1074 //                    compiler.getTask(null, fileManager, null, null, null, compilationUnits);
1075 //            boolean passed = task.call();
1076 //            if (!passed)
1077 //                throw new RuntimeException(&quot;Error compiling &quot; + files);
1078 //        }
1079 //    }
1080 
1081     static void javac(Path dest, Path... sourceFiles) throws IOException {
1082         javac(dest, null, sourceFiles);
1083     }
1084 
1085     static void javac(Path dest, Path modulePath, Path... sourceFiles)
1086         throws IOException
1087     {
<a name="8" id="anc8"></a>
1088 
1089         List&lt;String&gt; commands = new ArrayList&lt;&gt;();
<a name="9" id="anc9"></a>
1090         if (!TOOL_VM_OPTIONS.isEmpty()) {
1091             commands.addAll(Arrays.asList(TOOL_VM_OPTIONS.split(&quot;\\s+&quot;, -1)));
1092         }
1093         commands.add(&quot;-d&quot;);
1094         commands.add(dest.toString());
1095         if (dest.toString().contains(&quot;bar&quot;)) {
1096             commands.add(&quot;--add-exports&quot;);
1097             commands.add(&quot;java.base/jdk.internal.misc=bar&quot;);
1098             commands.add(&quot;--add-exports&quot;);
1099             commands.add(&quot;java.base/jdk.internal.module=bar&quot;);
1100         }
1101         if (modulePath != null) {
1102             commands.add(&quot;--module-path&quot;);
1103             commands.add(modulePath.toString());
1104         }
1105         Stream.of(sourceFiles).map(Object::toString).forEach(x -&gt; commands.add(x));
1106 
<a name="10" id="anc10"></a><span class="line-modified">1107         StringWriter sw = new StringWriter();</span>
<span class="line-added">1108         try (PrintWriter pw = new PrintWriter(sw)) {</span>
<span class="line-added">1109             int rc = JAVAC_TOOL.run(pw, pw, commands.toArray(new String[0]));</span>
<span class="line-added">1110             if(rc != 0) {</span>
<span class="line-added">1111                 throw new RuntimeException(sw.toString());</span>
<span class="line-added">1112             }</span>
<span class="line-added">1113         }</span>
1114     }
1115 
1116     static Result java(Path modulePath, String entryPoint, String... args) {
1117         String java = getJDKTool(&quot;java&quot;);
1118 
1119         List&lt;String&gt; commands = new ArrayList&lt;&gt;();
1120         commands.add(java);
1121         if (!VM_OPTIONS.isEmpty()) {
1122             commands.addAll(Arrays.asList(VM_OPTIONS.split(&quot;\\s+&quot;, -1)));
1123         }
1124         if (!JAVA_OPTIONS.isEmpty()) {
1125             commands.addAll(Arrays.asList(JAVA_OPTIONS.split(&quot;\\s+&quot;, -1)));
1126         }
1127         Stream.of(args).forEach(x -&gt; commands.add(x));
1128         commands.add(&quot;--module-path&quot;);
1129         commands.add(modulePath.toString());
1130         commands.add(&quot;-m&quot;);
1131         commands.add(entryPoint);
1132 
1133         return run(new ProcessBuilder(commands));
1134     }
1135 
1136     static Path[] sourceList(Path directory) throws IOException {
1137         return Files.find(directory, Integer.MAX_VALUE,
1138                           (file, attrs) -&gt; (file.toString().endsWith(&quot;.java&quot;)))
1139                     .toArray(Path[]::new);
1140     }
1141 
1142     static void createTestDir(Path p) throws IOException{
1143         if (Files.exists(p))
1144             FileUtils.deleteFileTreeWithRetry(p);
1145         Files.createDirectories(p);
1146     }
1147 
1148     static boolean jarContains(JarInputStream jis, String entryName)
1149         throws IOException
1150     {
1151         JarEntry e;
1152         while((e = jis.getNextJarEntry()) != null) {
1153             if (e.getName().equals(entryName))
1154                 return true;
1155         }
1156         return false;
1157     }
1158 
<a name="11" id="anc11"></a><span class="line-modified">1159     static Result run(ToolProvider tp, String[] commands) {</span>
<span class="line-modified">1160         int rc = 0;</span>
<span class="line-modified">1161         StringWriter sw = new StringWriter();</span>
<span class="line-added">1162         try (PrintWriter pw = new PrintWriter(sw)) {</span>
<span class="line-added">1163             rc = tp.run(pw, pw, commands);</span>
<span class="line-added">1164         }</span>
<span class="line-added">1165         return new Result(rc, sw.toString());</span>
1166     }
1167 
1168     static Result run(ProcessBuilder pb) {
1169         Process p;
1170         out.printf(&quot;Running: %s%n&quot;, pb.command());
1171         try {
1172             p = pb.start();
1173         } catch (IOException e) {
1174             throw new RuntimeException(
1175                     format(&quot;Couldn&#39;t start process &#39;%s&#39;&quot;, pb.command()), e);
1176         }
1177 
1178         String output;
1179         try {
1180             output = toString(p.getInputStream(), p.getErrorStream());
1181         } catch (IOException e) {
1182             throw new RuntimeException(
1183                     format(&quot;Couldn&#39;t read process output &#39;%s&#39;&quot;, pb.command()), e);
1184         }
1185 
1186         try {
1187             p.waitFor();
1188         } catch (InterruptedException e) {
1189             throw new RuntimeException(
1190                     format(&quot;Process hasn&#39;t finished &#39;%s&#39;&quot;, pb.command()), e);
1191         }
1192         return new Result(p.exitValue(), output);
1193     }
1194 
1195     static final String DEFAULT_IMAGE_BIN = System.getProperty(&quot;java.home&quot;)
1196             + File.separator + &quot;bin&quot; + File.separator;
1197 
1198     static String getJDKTool(String name) {
1199         try {
1200             return JDKToolFinder.getJDKTool(name);
1201         } catch (Exception x) {
1202             return DEFAULT_IMAGE_BIN + name;
1203         }
1204     }
1205 
1206     static String toString(InputStream in1, InputStream in2) throws IOException {
1207         try (ByteArrayOutputStream dst = new ByteArrayOutputStream();
1208              InputStream concatenated = new SequenceInputStream(in1, in2)) {
1209             concatenated.transferTo(dst);
1210             return new String(dst.toByteArray(), &quot;UTF-8&quot;);
1211         }
1212     }
1213 
1214     static class Result {
1215         final int ec;
1216         final String output;
1217 
1218         private Result(int ec, String output) {
1219             this.ec = ec;
1220             this.output = output;
1221         }
1222         Result assertSuccess() {
1223             assertTrue(ec == 0, &quot;Expected ec 0, got: &quot;, ec, &quot; , output [&quot;, output, &quot;]&quot;);
1224             return this;
1225         }
1226         Result assertFailure() {
1227             assertTrue(ec != 0, &quot;Expected ec != 0, got:&quot;, ec, &quot; , output [&quot;, output, &quot;]&quot;);
1228             return this;
1229         }
1230         Result resultChecker(Consumer&lt;Result&gt; r) { r.accept(this); return this; }
1231     }
1232 
1233     static void assertTrue(boolean cond, Object ... failedArgs) {
1234         if (cond)
1235             return;
1236         StringBuilder sb = new StringBuilder();
1237         for (Object o : failedArgs)
1238             sb.append(o);
1239         org.testng.Assert.assertTrue(false, sb.toString());
1240     }
1241 
1242     // Standalone entry point.
1243     public static void main(String[] args) throws Throwable {
1244         Basic test = new Basic();
1245         test.compileModules();
1246         for (Method m : Basic.class.getDeclaredMethods()) {
1247             if (m.getAnnotation(Test.class) != null) {
1248                 System.out.println(&quot;Invoking &quot; + m.getName());
1249                 m.invoke(test);
1250             }
1251         }
1252     }
1253 }
<a name="12" id="anc12"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="12" type="hidden" />
</body>
</html>
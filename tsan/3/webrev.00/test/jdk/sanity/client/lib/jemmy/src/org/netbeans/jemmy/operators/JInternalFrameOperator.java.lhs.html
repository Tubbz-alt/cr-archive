<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames test/jdk/sanity/client/lib/jemmy/src/org/netbeans/jemmy/operators/JInternalFrameOperator.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
<a name="1" id="anc1"></a><span class="line-modified">   2  * Copyright (c) 1997, 2018, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation. Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 package org.netbeans.jemmy.operators;
  26 
  27 import java.awt.Component;
  28 import java.awt.Container;
  29 import java.awt.Dimension;
  30 import java.awt.Point;
  31 import java.awt.Rectangle;
  32 import java.beans.PropertyVetoException;
  33 import java.util.Hashtable;
  34 
  35 import javax.swing.Icon;
  36 import javax.swing.JDesktopPane;
  37 import javax.swing.JInternalFrame;
  38 import javax.swing.JInternalFrame.JDesktopIcon;
  39 import javax.swing.JLayeredPane;
  40 import javax.swing.JMenuBar;
  41 import javax.swing.JScrollPane;
  42 import javax.swing.UIManager;
  43 import javax.swing.event.InternalFrameListener;
  44 import javax.swing.plaf.InternalFrameUI;
  45 
  46 import org.netbeans.jemmy.ComponentChooser;
  47 import org.netbeans.jemmy.ComponentSearcher;
  48 import org.netbeans.jemmy.JemmyInputException;
  49 import org.netbeans.jemmy.JemmyProperties;
  50 import org.netbeans.jemmy.Outputable;
  51 import org.netbeans.jemmy.TestOut;
  52 import org.netbeans.jemmy.TimeoutExpiredException;
  53 import org.netbeans.jemmy.Timeoutable;
  54 import org.netbeans.jemmy.Timeouts;
  55 import org.netbeans.jemmy.drivers.DriverManager;
  56 import org.netbeans.jemmy.drivers.FrameDriver;
  57 import org.netbeans.jemmy.drivers.InternalFrameDriver;
  58 import org.netbeans.jemmy.drivers.WindowDriver;
  59 import org.netbeans.jemmy.util.EmptyVisualizer;
<a name="2" id="anc2"></a>
  60 import org.netbeans.jemmy.util.Platform;
  61 
  62 /**
  63  * Class provides necessary functionality to operate with
  64  * javax.swing.JInternalFrame component.
  65  *
  66  * Some methods can throw WrongInternalFrameStateException exception.
  67  *
  68  * &lt;BR&gt;&lt;BR&gt;Timeouts used: &lt;BR&gt;
  69  * ComponentOperator.WaitComponentTimeout - time to wait component displayed
  70  * &lt;BR&gt;
  71  * ComponentOperator.MouseClickTimeout - time between mouse pressing and
  72  * releasing &lt;BR&gt;
  73  * AbstractButtonOperator.PushButtonTimeout - time between button pressing and
  74  * releasing&lt;BR&gt;
  75  * JScrollBarOperator.WholeScrollTimeout - time for the whole scrolling &lt;BR&gt;.
  76  *
  77  * @see org.netbeans.jemmy.Timeouts
  78  * @see WrongInternalFrameStateException
  79  * @author Alexandre Iline (alexandre.iline@oracle.com)
  80  */
  81 public class JInternalFrameOperator extends JComponentOperator
  82         implements Outputable, Timeoutable {
  83 
  84     /**
  85      * Identifier for a &quot;title&quot; property.
  86      *
  87      * @see #getDump
  88      */
  89     public static final String TITLE_DPROP = &quot;Title&quot;;
  90 
  91     /**
  92      * Identifier for a &quot;state&quot; property.
  93      *
  94      * @see #getDump
  95      */
  96     public static final String STATE_DPROP = &quot;State&quot;;
  97 
  98     /**
  99      * Identifier for a &quot;normal&quot; value of &quot;state&quot; property.
 100      *
 101      * @see #getDump
 102      */
 103     public static final String STATE_NORMAL_DPROP_VALUE = &quot;NORMAL&quot;;
 104 
 105     /**
 106      * Identifier for a &quot;closed&quot; value of &quot;state&quot; property.
 107      *
 108      * @see #getDump
 109      */
 110     public static final String STATE_CLOSED_DPROP_VALUE = &quot;CLOSED&quot;;
 111 
 112     /**
 113      * Identifier for a &quot;iconified&quot; value of &quot;state&quot; property.
 114      *
 115      * @see #getDump
 116      */
 117     public static final String STATE_ICONIFIED_DPROP_VALUE = &quot;ICONIFIED&quot;;
 118 
 119     /**
 120      * Identifier for a &quot;maximized&quot; value of &quot;state&quot; property.
 121      *
 122      * @see #getDump
 123      */
 124     public static final String STATE_MAXIMAZED_DPROP_VALUE = &quot;MAXIMIZED&quot;;
 125 
 126     /**
 127      * Identifier for a &quot;resizable&quot; property.
 128      *
 129      * @see #getDump
 130      */
 131     public static final String IS_RESIZABLE_DPROP = &quot;Resizable&quot;;
 132 
 133     /**
 134      * Identifier for a &quot;selected&quot; property.
 135      *
 136      * @see #getDump
 137      */
 138     public static final String IS_SELECTED_DPROP = &quot;Selected&quot;;
 139 
 140     /**
 141      * Maximize button tool tip key
 142      */
 143     public static final String MAXIMIZE_BUTTON_TOOLTIP =
 144             UIManager.getString(&quot;InternalFrame.maxButtonToolTip&quot;);
 145 
 146     /**
 147      * Close button tool tip key
 148      */
 149     public static final String CLOSE_BUTTON_TOOLTIP =
 150             UIManager.getString(&quot;InternalFrame.closeButtonToolTip&quot;);
 151 
 152     /**
 153      * Minimize button tool tip key
 154      */
 155     public static final String MINIMIZE_BUTTON_TOOLTIP =
 156             UIManager.getString(&quot;InternalFrame.iconButtonToolTip&quot;);
 157 
 158     /**
 159      * A minimizing button.
 160      */
 161     protected JButtonOperator minOper = null;
 162 
 163     /**
 164      * A maximizing button.
 165      */
 166     protected JButtonOperator maxOper = null;
 167 
 168     /**
 169      * A close button.
 170      */
 171     protected JButtonOperator closeOper = null;
 172 
 173     protected JButtonOperator popupButtonOper = null;
 174 
 175     /**
 176      * A title operator.
 177      */
 178     protected ContainerOperator&lt;?&gt; titleOperator = null;
 179     private TestOut output;
 180     private Timeouts timeouts;
 181     private JDesktopIconOperator iconOperator;
 182 
 183     WindowDriver wDriver;
 184     FrameDriver fDriver;
 185     InternalFrameDriver iDriver;
 186 
 187     /**
 188      * Constructor.
 189      *
 190      * @param b a component
 191      */
 192     public JInternalFrameOperator(JInternalFrame b) {
 193         super(b);
 194         wDriver = DriverManager.getWindowDriver(getClass());
 195         fDriver = DriverManager.getFrameDriver(getClass());
 196         iDriver = DriverManager.getInternalFrameDriver(getClass());
 197     }
 198 
 199     /**
 200      * Constructs a JInternalFrameOperator object.
 201      *
 202      * @param cont a container
 203      * @param chooser a component chooser specifying searching criteria.
 204      * @param index an index between appropriate ones.
 205      */
 206     public JInternalFrameOperator(ContainerOperator&lt;?&gt; cont, ComponentChooser chooser, int index) {
 207         this(waitJInternalFrame((Container)cont.getSource(),
 208                 chooser, index));
 209         copyEnvironment(cont);
 210     }
 211 
 212     /**
 213      * Constructs a JInternalFrameOperator object.
 214      *
 215      * @param cont a container
 216      * @param chooser a component chooser specifying searching criteria.
 217      */
 218     public JInternalFrameOperator(ContainerOperator&lt;?&gt; cont, ComponentChooser chooser) {
 219         this(cont, chooser, 0);
 220     }
 221 
 222     /**
 223      * Constructor. Waits component in container first. Uses cont&#39;s timeout and
 224      * output for waiting and to init operator.
 225      *
 226      * @param cont a container
 227      * @param text Button text.
 228      * @param index Ordinal component index.
 229      * @see ComponentOperator#isCaptionEqual(String, String, boolean, boolean)
 230      *
 231      */
 232     public JInternalFrameOperator(ContainerOperator&lt;?&gt; cont, String text, int index) {
 233         this(findOne(cont, text, index));
 234         copyEnvironment(cont);
 235     }
 236 
 237     /**
 238      * Constructor. Waits component in container first. Uses cont&#39;s timeout and
 239      * output for waiting and to init operator.
 240      *
 241      * @param cont a container
 242      * @param text Button text.
 243      * @see ComponentOperator#isCaptionEqual(String, String, boolean, boolean)
 244      *
 245      */
 246     public JInternalFrameOperator(ContainerOperator&lt;?&gt; cont, String text) {
 247         this(cont, text, 0);
 248     }
 249 
 250     /**
 251      * Constructor. Waits component in container first. Uses cont&#39;s timeout and
 252      * output for waiting and to init operator.
 253      *
 254      * @param cont a container
 255      * @param index Ordinal component index.
 256      *
 257      */
 258     public JInternalFrameOperator(ContainerOperator&lt;?&gt; cont, int index) {
 259         this(waitJInternalFrame((Container)cont.getSource(),
 260                 new JInternalFrameFinder(),
 261                 index));
 262         copyEnvironment(cont);
 263     }
 264 
 265     /**
 266      * Constructor. Waits component in container first. Uses cont&#39;s timeout and
 267      * output for waiting and to init operator.
 268      *
 269      * @param cont a container
 270      *
 271      */
 272     public JInternalFrameOperator(ContainerOperator&lt;?&gt; cont) {
 273         this(cont, 0);
 274     }
 275 
 276     /**
 277      * Searches JInternalframe in container.
 278      *
 279      * @param cont Container to search component in.
 280      * @param chooser a component chooser specifying searching criteria.
 281      * @param index Ordinal component index.
 282      * @return JInternalframe instance or null if component was not found.
 283      */
 284     public static JInternalFrame findJInternalFrame(Container cont, ComponentChooser chooser, int index) {
 285         Component res = findComponent(cont, new JInternalFrameFinder(chooser), index);
 286         if (res instanceof JInternalFrame) {
 287             return (JInternalFrame) res;
 288         } else if (res instanceof JInternalFrame.JDesktopIcon) {
 289             return ((JInternalFrame.JDesktopIcon) res).getInternalFrame();
 290         } else {
 291             return null;
 292         }
 293     }
 294 
 295     /**
 296      * Searches JInternalframe in container.
 297      *
 298      * @param cont Container to search component in.
 299      * @param chooser a component chooser specifying searching criteria.
 300      * @return JInternalframe instance or null if component was not found.
 301      */
 302     public static JInternalFrame findJInternalFrame(Container cont, ComponentChooser chooser) {
 303         return findJInternalFrame(cont, chooser, 0);
 304     }
 305 
 306     /**
 307      * Searches JInternalframe by title.
 308      *
 309      * @param cont Container to search component in.
 310      * @param text Component text.
 311      * @param ce Compare text exactly.
 312      * @param ccs Compare text case sensitively.
 313      * @param index Ordinal component index.
 314      * @return JInternalframe instance or null if component was not found.
 315      * @see ComponentOperator#isCaptionEqual(String, String, boolean, boolean)
 316      */
 317     public static JInternalFrame findJInternalFrame(Container cont, String text, boolean ce, boolean ccs, int index) {
 318         return (findJInternalFrame(cont,
 319                 new JInternalFrameByTitleFinder(text,
 320                         new DefaultStringComparator(ce, ccs)),
 321                 index));
 322     }
 323 
 324     /**
 325      * Searches JInternalframe by title.
 326      *
 327      * @param cont Container to search component in.
 328      * @param text Component text.
 329      * @param ce Compare text exactly.
 330      * @param ccs Compare text case sensitively.
 331      * @return JInternalframe instance or null if component was not found.
 332      * @see ComponentOperator#isCaptionEqual(String, String, boolean, boolean)
 333      */
 334     public static JInternalFrame findJInternalFrame(Container cont, String text, boolean ce, boolean ccs) {
 335         return findJInternalFrame(cont, text, ce, ccs, 0);
 336     }
 337 
 338     /**
 339      * Searches JInternalFrame object which component lies on.
 340      *
 341      * @param comp Component to find JInternalFrame under.
 342      * @param chooser org.netbeans.jemmy.ComponentChooser implementation.
 343      * @return JInternalFrame instance or null if component was not found.
 344      */
 345     public static JInternalFrame findJInternalFrameUnder(Component comp, ComponentChooser chooser) {
 346         return (JInternalFrame) findContainerUnder(comp, new JInternalFrameFinder(chooser));
 347     }
 348 
 349     /**
 350      * Searches JInternalFrame object which component lies on.
 351      *
 352      * @param comp Component to find JInternalFrame under.
 353      * @return JInternalFrame instance or null if component was not found.
 354      */
 355     public static JInternalFrame findJInternalFrameUnder(Component comp) {
 356         return findJInternalFrameUnder(comp, new JInternalFrameFinder());
 357     }
 358 
 359     /**
 360      * Waits JInternalframe in container.
 361      *
 362      * @param cont Container to search component in.
 363      * @param chooser a component chooser specifying searching criteria.
 364      * @param index Ordinal component index.
 365      * @return JInternalframe instance.
 366      *
 367      */
 368     public static JInternalFrame waitJInternalFrame(final Container cont, final ComponentChooser chooser, final int index) {
 369         Component res = waitComponent(cont, new JInternalFrameFinder(chooser), index);
 370         if (res instanceof JInternalFrame) {
 371             return (JInternalFrame) res;
 372         } else if (res instanceof JInternalFrame.JDesktopIcon) {
 373             return ((JInternalFrame.JDesktopIcon) res).getInternalFrame();
 374         } else {
 375             throw (new TimeoutExpiredException(chooser.getDescription()));
 376         }
 377     }
 378 
 379     /**
 380      * Waits JInternalframe in container.
 381      *
 382      * @param cont Container to search component in.
 383      * @param chooser a component chooser specifying searching criteria.
 384      * @return JInternalframe instance.
 385      *
 386      */
 387     public static JInternalFrame waitJInternalFrame(Container cont, ComponentChooser chooser) {
 388         return waitJInternalFrame(cont, chooser, 0);
 389     }
 390 
 391     /**
 392      * Waits JInternalframe by title.
 393      *
 394      * @param cont Container to search component in.
 395      * @param text Component text.
 396      * @param ce Compare text exactly.
 397      * @param ccs Compare text case sensitively.
 398      * @param index Ordinal component index.
 399      * @return JInternalframe instance.
 400      * @see ComponentOperator#isCaptionEqual(String, String, boolean, boolean)
 401      *
 402      */
 403     public static JInternalFrame waitJInternalFrame(Container cont, String text, boolean ce, boolean ccs, int index) {
 404         return (waitJInternalFrame(cont,
 405                 new JInternalFrameByTitleFinder(text,
 406                         new DefaultStringComparator(ce, ccs)),
 407                 index));
 408     }
 409 
 410     /**
 411      * Waits JInternalframe by title.
 412      *
 413      * @param cont Container to search component in.
 414      * @param text Component text.
 415      * @param ce Compare text exactly.
 416      * @param ccs Compare text case sensitively.
 417      * @return JInternalframe instance.
 418      * @see ComponentOperator#isCaptionEqual(String, String, boolean, boolean)
 419      *
 420      */
 421     public static JInternalFrame waitJInternalFrame(Container cont, String text, boolean ce, boolean ccs) {
 422         return waitJInternalFrame(cont, text, ce, ccs, 0);
 423     }
 424 
 425     @Override
 426     public void setOutput(TestOut out) {
 427         output = out;
 428         super.setOutput(output.createErrorOutput());
 429     }
 430 
 431     @Override
 432     public TestOut getOutput() {
 433         return output;
 434     }
 435 
 436     @Override
 437     public void setTimeouts(Timeouts times) {
 438         timeouts = times;
 439         super.setTimeouts(timeouts);
 440     }
 441 
 442     @Override
 443     public Timeouts getTimeouts() {
 444         return timeouts;
 445     }
 446 
 447     /**
 448      * Iconifies frame. Note: frame should not be iconified and should be
 449      * iconifiable.
 450      *
 451      * @throws WrongInternalFrameStateException
 452      *
 453      */
 454     public void iconify() {
 455         output.printLine(&quot;Iconify JInternalFrame\n    : &quot; + toStringSource());
 456         output.printGolden(&quot;Iconify JInternalFrame \&quot;&quot; + getTitle() + &quot;\&quot;&quot;);
 457         checkIconified(false);
 458         makeComponentVisible();
 459         fDriver.iconify(this);
 460         if (getVerification()) {
 461             waitIcon(true);
 462         }
 463     }
 464 
 465     /**
 466      * Deiconifies frame. Note: frame should be iconified.
 467      *
 468      * @throws WrongInternalFrameStateException
 469      *
 470      */
 471     public void deiconify() {
 472         output.printLine(&quot;Deiconify JInternalFrame\n    : &quot; + toStringSource());
 473         output.printGolden(&quot;Deiconify JInternalFrame \&quot;&quot; + getTitle() + &quot;\&quot;&quot;);
 474         checkIconified(true);
 475         fDriver.deiconify(this);
 476         if (getVerification()) {
 477             waitIcon(false);
 478         }
 479     }
 480 
 481     /**
 482      * Maximizes frame. Note: frame should not be iconified.
 483      *
 484      * @throws WrongInternalFrameStateException
 485      */
 486     public void maximize() {
 487         output.printLine(&quot;Maximize JInternalFrame\n    : &quot; + toStringSource());
 488         output.printGolden(&quot;Maximize JInternalFrame \&quot;&quot; + getTitle() + &quot;\&quot;&quot;);
 489         checkIconified(false);
 490         makeComponentVisible();
 491         fDriver.maximize(this);
 492         if (getVerification()) {
 493             waitMaximum(true);
 494         }
 495     }
 496 
 497     /**
 498      * Demaximizes frame. Note: frame should not be iconified.
 499      *
 500      * @throws WrongInternalFrameStateException
 501      */
 502     public void demaximize() {
 503         output.printLine(&quot;Demaximize JInternalFrame\n    : &quot; + toStringSource());
 504         output.printGolden(&quot;Demaximize JInternalFrame \&quot;&quot; + getTitle() + &quot;\&quot;&quot;);
 505         checkIconified(false);
 506         makeComponentVisible();
 507         fDriver.demaximize(this);
 508         if (getVerification()) {
 509             waitMaximum(false);
 510         }
 511     }
 512 
 513     /**
 514      * Moves frame to new location. Note: frame should not be iconified.
 515      *
 516      * @param x X coordinate of a new frame location.
 517      * @param y Y coordinate of a new frame location.
 518      * @throws WrongInternalFrameStateException
 519      */
 520     public void move(int x, int y) {
 521         checkIconified(false);
 522         output.printLine(&quot;Move JInternalFrame to (&quot;
 523                 + Integer.toString(x) + &quot;,&quot;
 524                 + Integer.toString(y) + &quot;)&quot;
 525                 + &quot; position\n    : &quot; + toStringSource());
 526         output.printGolden(&quot;Move &quot; + getTitle()
 527                 + &quot; JInternalFrame to (&quot;
 528                 + Integer.toString(x) + &quot;,&quot;
 529                 + Integer.toString(y) + &quot;)&quot;
 530                 + &quot; position&quot;);
 531         checkIconified(false);
 532         wDriver.move(this, x, y);
 533         if (getVerification()) {
 534             waitComponentLocation(new Point(x, y));
 535         }
 536     }
 537 
 538     /**
 539      * Resizes frame. Note: frame should not be iconified.
 540      *
 541      * @param width New frame width.
 542      * @param height New frame height.
 543      * @throws WrongInternalFrameStateException
 544      */
 545     public void resize(int width, int height) {
 546         output.printLine(&quot;Resize JInternalFrame to (&quot;
 547                 + Integer.toString(width) + &quot;,&quot;
 548                 + Integer.toString(height) + &quot;)&quot;
 549                 + &quot; size\n    : &quot; + toStringSource());
 550         output.printGolden(&quot;Resize &quot; + getTitle()
 551                 + &quot; JInternalFrame to (&quot;
 552                 + Integer.toString(width) + &quot;,&quot;
 553                 + Integer.toString(height) + &quot;)&quot;
 554                 + &quot; size&quot;);
 555         checkIconified(false);
 556         wDriver.resize(this, width, height);
 557         if (getVerification()) {
 558             waitComponentSize(new Dimension(width, height));
 559         }
 560     }
 561 
 562     /**
 563      * Activates frame. Note: frame should not be iconified.
 564      *
 565      * @throws WrongInternalFrameStateException
 566      */
 567     public void activate() {
 568         checkIconified(false);
 569         wDriver.activate(this);
 570         if (getVerification()) {
 571             waitActivate(true);
 572         }
 573     }
 574 
 575     /**
 576      * Closes the frame.
 577      */
 578     public void close() {
 579         checkIconified(false);
 580         wDriver.requestClose(this);
 581         if (getVerification()) {
 582             waitClosed();
 583         }
 584     }
 585 
 586     /**
 587      * Scrolls to internal frame&#39;s rectangle.
 588      *
 589      * @param x Horizontal rectangle coordinate
 590      * @param y Vertical rectangle coordinate
 591      * @param width rectangle width
 592      * @param height rectangle height
 593      *
 594      */
 595     public void scrollToRectangle(int x, int y, int width, int height) {
 596         output.printTrace(&quot;Scroll desktop pane to make \&quot;&quot; + getTitle() + &quot;\&quot; internal frame visible&quot;);
 597         output.printGolden(&quot;Scroll desktop pane to make \&quot;&quot; + getTitle() + &quot;\&quot; internal frame visible&quot;);
 598         makeComponentVisible();
 599         //try to find JScrollPane under.
 600         JScrollPane scroll;
 601         if (isIcon()) {
 602             scroll
 603                     = (JScrollPane) iconOperator.getContainer(new JScrollPaneOperator.JScrollPaneFinder(ComponentSearcher.
 604                             getTrueChooser(&quot;JScrollPane&quot;)));
 605         } else {
 606             scroll
 607                     = (JScrollPane) getContainer(new JScrollPaneOperator.JScrollPaneFinder(ComponentSearcher.
 608                             getTrueChooser(&quot;JScrollPane&quot;)));
 609         }
 610         if (scroll == null) {
 611             return;
 612         }
 613         JScrollPaneOperator scroller = new JScrollPaneOperator(scroll);
 614         scroller.copyEnvironment(this);
 615         scroller.setVisualizer(new EmptyVisualizer());
 616         scroller.scrollToComponentRectangle(isIcon() ? iconOperator.getSource() : getSource(),
 617                 x, y, width, height);
 618     }
 619 
 620     /**
 621      * Scrolls to internal frame&#39;s rectangle.
 622      *
 623      * @param rect a rectangle to scroll to.
 624      */
 625     public void scrollToRectangle(Rectangle rect) {
 626         scrollToRectangle(rect.x, rect.y, rect.width, rect.height);
 627     }
 628 
 629     /**
 630      * Scrolls to internal frame.
 631      *
 632      */
 633     public void scrollToFrame() {
 634         if (isIcon()) {
 635             scrollToRectangle(0, 0, iconOperator.getWidth(), iconOperator.getHeight());
 636         } else {
 637             scrollToRectangle(0, 0, getWidth(), getHeight());
 638         }
 639     }
 640 
 641     /**
 642      * Waits for a minimize button inside the title pane.
 643      *
 644      * @return a button operator
 645      */
 646     public JButtonOperator getMinimizeButton() {
 647         initOperators();
 648         return minOper;
 649     }
 650 
 651     /**
 652      * Waits for a maximize button inside the title pane.
 653      *
 654      * @return a button operator
 655      */
 656     public JButtonOperator getMaximizeButton() {
 657         initOperators();
 658         return maxOper;
 659     }
 660 
 661     /**
 662      * Waits for a close button inside the title pane.
 663      *
 664      * @return a button operator
 665      */
 666     public JButtonOperator getCloseButton() {
 667         initOperators();
 668         return closeOper;
 669     }
 670 
 671     public JButtonOperator getPopupButton() {
 672         initOperators();
 673         return popupButtonOper;
 674     }
 675 
 676     /**
 677      * Waits for the title pane.
 678      *
 679      * @return a button operator
 680      */
 681     public ContainerOperator&lt;?&gt; getTitleOperator() {
 682         initOperators();
 683         return titleOperator;
 684     }
 685 
 686     /**
 687      * Creates an operator for an desktop icon.
 688      *
 689      * @return an icon operator.
 690      */
 691     public JDesktopIconOperator getIconOperator() {
 692         if(Platform.isOSX()) {
 693             initIconOperator();
 694         } else {
 695             initOperators();
 696         }
 697         return iconOperator;
 698     }
 699 
 700     /**
 701      * Waits for the frame to be iconified or deiconified.
 702      *
 703      * @param isIconified whether the frame needs to be iconified or deiconified.
 704      */
 705     public void waitIcon(final boolean isIconified) {
 706         waitStateOnQueue(new ComponentChooser() {
 707             @Override
 708             public boolean checkComponent(Component comp) {
 709                 return isIcon() == isIconified;
 710             }
 711 
 712             @Override
 713             public String getDescription() {
 714                 return &quot;Internal Frame is &quot; + (isIconified ? &quot;iconified&quot; : &quot;deiconified&quot;);
 715             }
 716 
 717             @Override
 718             public String toString() {
 719                 return &quot;JInternalFrameOperator.waitIcon.ComponentChooser{description = &quot; + getDescription() + &#39;}&#39;;
 720             }
 721         });
 722     }
 723 
 724     /**
 725      * Waits for the frame to be activated or deactivated.
 726      *
 727      * @param isActivate whether the frame needs to be activated or deactivated.
 728      */
 729     public void waitActivate(final boolean isActivate) {
 730         waitStateOnQueue(new ComponentChooser() {
 731             @Override
 732             public boolean checkComponent(Component comp) {
 733                 return isSelected() == isActivate;
 734             }
 735 
 736             @Override
 737             public String getDescription() {
 738                 return &quot;Internal Frame is &quot; + (isActivate ? &quot;activated&quot; : &quot;deactivated&quot;);
 739             }
 740 
 741             @Override
 742             public String toString() {
 743                 return &quot;JInternalFrameOperator.waitActivate.ComponentChooser{description = &quot; + getDescription() + &#39;}&#39;;
 744             }
 745         });
 746     }
 747 
 748     /**
 749      * Waits for the frame to be closed.
 750      */
 751     public void waitClosed() {
 752         waitStateOnQueue(new ComponentChooser() {
 753             @Override
 754             public boolean checkComponent(Component comp) {
 755                 return isClosed();
 756             }
 757 
 758             @Override
 759             public String getDescription() {
 760                 return &quot;Internal Frame is closed&quot;;
 761             }
 762 
 763             @Override
 764             public String toString() {
 765                 return &quot;JInternalFrameOperator.waitClosed.ComponentChooser{description = &quot; + getDescription() + &#39;}&#39;;
 766             }
 767         });
 768     }
 769 
 770     /**
 771      * Waits for the frame to be maximized or demaximized.
 772      *
 773      * @param isMaximum whether the frame needs to be maximized or demaximized.
 774      */
 775     public void waitMaximum(final boolean isMaximum) {
 776         waitStateOnQueue(new ComponentChooser() {
 777             @Override
 778             public boolean checkComponent(Component comp) {
 779                 return isMaximum() == isMaximum;
 780             }
 781 
 782             @Override
 783             public String getDescription() {
 784                 return &quot;Internal Frame is &quot; + (isMaximum ? &quot;maximizied&quot; : &quot;demaximizied&quot;);
 785             }
 786 
 787             @Override
 788             public String toString() {
 789                 return &quot;JInternalFrameOperator.waitMaximum.ComponentChooser{description = &quot; + getDescription() + &#39;}&#39;;
 790             }
 791         });
 792     }
 793 
 794     /**
 795      * Returns information about component.
 796      */
 797     @Override
 798     public Hashtable&lt;String, Object&gt; getDump() {
 799         Hashtable&lt;String, Object&gt; result = super.getDump();
 800         result.put(TITLE_DPROP, ((JInternalFrame) getSource()).getTitle());
 801         String state = STATE_NORMAL_DPROP_VALUE;
 802         if (((JInternalFrame) getSource()).isClosed()) {
 803             state = STATE_CLOSED_DPROP_VALUE;
 804         } else if (((JInternalFrame) getSource()).isIcon()) {
 805             state = STATE_ICONIFIED_DPROP_VALUE;
 806         } else if (((JInternalFrame) getSource()).isMaximum()) {
 807             state = STATE_MAXIMAZED_DPROP_VALUE;
 808         }
 809         result.put(STATE_DPROP, state);
 810         result.put(IS_RESIZABLE_DPROP, ((JInternalFrame) getSource()).isResizable() ? &quot;true&quot; : &quot;false&quot;);
 811         result.put(IS_SELECTED_DPROP, ((JInternalFrame) getSource()).isSelected() ? &quot;true&quot; : &quot;false&quot;);
 812         return result;
 813     }
 814 
 815     ////////////////////////////////////////////////////////
 816     //Mapping                                             //
 817     /**
 818      * Maps
 819      * {@code JInternalFrame.addInternalFrameListener(InternalFrameListener)}
 820      * through queue
 821      */
 822     public void addInternalFrameListener(final InternalFrameListener internalFrameListener) {
 823         runMapping(new MapVoidAction(&quot;addInternalFrameListener&quot;) {
 824             @Override
 825             public void map() {
 826                 ((JInternalFrame) getSource()).addInternalFrameListener(internalFrameListener);
 827             }
 828         });
 829     }
 830 
 831     /**
 832      * Maps {@code JInternalFrame.dispose()} through queue
 833      */
 834     public void dispose() {
 835         runMapping(new MapVoidAction(&quot;dispose&quot;) {
 836             @Override
 837             public void map() {
 838                 ((JInternalFrame) getSource()).dispose();
 839             }
 840         });
 841     }
 842 
 843     /**
 844      * Maps {@code JInternalFrame.getContentPane()} through queue
 845      */
 846     public Container getContentPane() {
 847         return (runMapping(new MapAction&lt;Container&gt;(&quot;getContentPane&quot;) {
 848             @Override
 849             public Container map() {
 850                 return ((JInternalFrame) getSource()).getContentPane();
 851             }
 852         }));
 853     }
 854 
 855     /**
 856      * Maps {@code JInternalFrame.getDefaultCloseOperation()} through queue
 857      */
 858     public int getDefaultCloseOperation() {
 859         return (runMapping(new MapIntegerAction(&quot;getDefaultCloseOperation&quot;) {
 860             @Override
 861             public int map() {
 862                 return ((JInternalFrame) getSource()).getDefaultCloseOperation();
 863             }
 864         }));
 865     }
 866 
 867     /**
 868      * Maps {@code JInternalFrame.getDesktopIcon()} through queue
 869      */
 870     public JDesktopIcon getDesktopIcon() {
 871         return (runMapping(new MapAction&lt;JDesktopIcon&gt;(&quot;getDesktopIcon&quot;) {
 872             @Override
 873             public JDesktopIcon map() {
 874                 return ((JInternalFrame) getSource()).getDesktopIcon();
 875             }
 876         }));
 877     }
 878 
 879     /**
 880      * Maps {@code JInternalFrame.getDesktopPane()} through queue
 881      */
 882     public JDesktopPane getDesktopPane() {
 883         return (runMapping(new MapAction&lt;JDesktopPane&gt;(&quot;getDesktopPane&quot;) {
 884             @Override
 885             public JDesktopPane map() {
 886                 return ((JInternalFrame) getSource()).getDesktopPane();
 887             }
 888         }));
 889     }
 890 
 891     /**
 892      * Maps {@code JInternalFrame.getFrameIcon()} through queue
 893      */
 894     public Icon getFrameIcon() {
 895         return (runMapping(new MapAction&lt;Icon&gt;(&quot;getFrameIcon&quot;) {
 896             @Override
 897             public Icon map() {
 898                 return ((JInternalFrame) getSource()).getFrameIcon();
 899             }
 900         }));
 901     }
 902 
 903     /**
 904      * Maps {@code JInternalFrame.getGlassPane()} through queue
 905      */
 906     public Component getGlassPane() {
 907         return (runMapping(new MapAction&lt;Component&gt;(&quot;getGlassPane&quot;) {
 908             @Override
 909             public Component map() {
 910                 return ((JInternalFrame) getSource()).getGlassPane();
 911             }
 912         }));
 913     }
 914 
 915     /**
 916      * Maps {@code JInternalFrame.getJMenuBar()} through queue
 917      */
 918     public JMenuBar getJMenuBar() {
 919         return (runMapping(new MapAction&lt;JMenuBar&gt;(&quot;getJMenuBar&quot;) {
 920             @Override
 921             public JMenuBar map() {
 922                 return ((JInternalFrame) getSource()).getJMenuBar();
 923             }
 924         }));
 925     }
 926 
 927     /**
 928      * Maps {@code JInternalFrame.getLayer()} through queue
 929      */
 930     public int getLayer() {
 931         return (runMapping(new MapIntegerAction(&quot;getLayer&quot;) {
 932             @Override
 933             public int map() {
 934                 return ((JInternalFrame) getSource()).getLayer();
 935             }
 936         }));
 937     }
 938 
 939     /**
 940      * Maps {@code JInternalFrame.getLayeredPane()} through queue
 941      */
 942     public JLayeredPane getLayeredPane() {
 943         return (runMapping(new MapAction&lt;JLayeredPane&gt;(&quot;getLayeredPane&quot;) {
 944             @Override
 945             public JLayeredPane map() {
 946                 return ((JInternalFrame) getSource()).getLayeredPane();
 947             }
 948         }));
 949     }
 950 
 951     /**
 952      * Maps {@code JInternalFrame.getTitle()} through queue
 953      */
 954     public String getTitle() {
 955         return (runMapping(new MapAction&lt;String&gt;(&quot;getTitle&quot;) {
 956             @Override
 957             public String map() {
 958                 return ((JInternalFrame) getSource()).getTitle();
 959             }
 960         }));
 961     }
 962 
 963     /**
 964      * Maps {@code JInternalFrame.getUI()} through queue
 965      */
 966     public InternalFrameUI getUI() {
 967         return (runMapping(new MapAction&lt;InternalFrameUI&gt;(&quot;getUI&quot;) {
 968             @Override
 969             public InternalFrameUI map() {
 970                 return ((JInternalFrame) getSource()).getUI();
 971             }
 972         }));
 973     }
 974 
 975     /**
 976      * Maps {@code JInternalFrame.getWarningString()} through queue
 977      */
 978     public String getWarningString() {
 979         return (runMapping(new MapAction&lt;String&gt;(&quot;getWarningString&quot;) {
 980             @Override
 981             public String map() {
 982                 return ((JInternalFrame) getSource()).getWarningString();
 983             }
 984         }));
 985     }
 986 
 987     /**
 988      * Maps {@code JInternalFrame.isClosable()} through queue
 989      */
 990     public boolean isClosable() {
 991         return (runMapping(new MapBooleanAction(&quot;isClosable&quot;) {
 992             @Override
 993             public boolean map() {
 994                 return ((JInternalFrame) getSource()).isClosable();
 995             }
 996         }));
 997     }
 998 
 999     /**
1000      * Maps {@code JInternalFrame.isClosed()} through queue
1001      */
1002     public boolean isClosed() {
1003         return (runMapping(new MapBooleanAction(&quot;isClosed&quot;) {
1004             @Override
1005             public boolean map() {
1006                 return ((JInternalFrame) getSource()).isClosed();
1007             }
1008         }));
1009     }
1010 
1011     /**
1012      * Maps {@code JInternalFrame.isIcon()} through queue
1013      */
1014     public boolean isIcon() {
1015         return (runMapping(new MapBooleanAction(&quot;isIcon&quot;) {
1016             @Override
1017             public boolean map() {
1018                 return ((JInternalFrame) getSource()).isIcon();
1019             }
1020         }));
1021     }
1022 
1023     /**
1024      * Maps {@code JInternalFrame.isIconifiable()} through queue
1025      */
1026     public boolean isIconifiable() {
1027         return (runMapping(new MapBooleanAction(&quot;isIconifiable&quot;) {
1028             @Override
1029             public boolean map() {
1030                 return ((JInternalFrame) getSource()).isIconifiable();
1031             }
1032         }));
1033     }
1034 
1035     /**
1036      * Maps {@code JInternalFrame.isMaximizable()} through queue
1037      */
1038     public boolean isMaximizable() {
1039         return (runMapping(new MapBooleanAction(&quot;isMaximizable&quot;) {
1040             @Override
1041             public boolean map() {
1042                 return ((JInternalFrame) getSource()).isMaximizable();
1043             }
1044         }));
1045     }
1046 
1047     /**
1048      * Maps {@code JInternalFrame.isMaximum()} through queue
1049      */
1050     public boolean isMaximum() {
1051         return (runMapping(new MapBooleanAction(&quot;isMaximum&quot;) {
1052             @Override
1053             public boolean map() {
1054                 return ((JInternalFrame) getSource()).isMaximum();
1055             }
1056         }));
1057     }
1058 
1059     /**
1060      * Maps {@code JInternalFrame.isResizable()} through queue
1061      */
1062     public boolean isResizable() {
1063         return (runMapping(new MapBooleanAction(&quot;isResizable&quot;) {
1064             @Override
1065             public boolean map() {
1066                 return ((JInternalFrame) getSource()).isResizable();
1067             }
1068         }));
1069     }
1070 
1071     /**
1072      * Maps {@code JInternalFrame.isSelected()} through queue
1073      */
1074     public boolean isSelected() {
1075         return (runMapping(new MapBooleanAction(&quot;isSelected&quot;) {
1076             @Override
1077             public boolean map() {
1078                 return ((JInternalFrame) getSource()).isSelected();
1079             }
1080         }));
1081     }
1082 
1083     /**
1084      * Maps {@code JInternalFrame.moveToBack()} through queue
1085      */
1086     public void moveToBack() {
1087         runMapping(new MapVoidAction(&quot;moveToBack&quot;) {
1088             @Override
1089             public void map() {
1090                 ((JInternalFrame) getSource()).moveToBack();
1091             }
1092         });
1093     }
1094 
1095     /**
1096      * Maps {@code JInternalFrame.moveToFront()} through queue
1097      */
1098     public void moveToFront() {
1099         runMapping(new MapVoidAction(&quot;moveToFront&quot;) {
1100             @Override
1101             public void map() {
1102                 ((JInternalFrame) getSource()).moveToFront();
1103             }
1104         });
1105     }
1106 
1107     /**
1108      * Maps {@code JInternalFrame.pack()} through queue
1109      */
1110     public void pack() {
1111         runMapping(new MapVoidAction(&quot;pack&quot;) {
1112             @Override
1113             public void map() {
1114                 ((JInternalFrame) getSource()).pack();
1115             }
1116         });
1117     }
1118 
1119     /**
1120      * Maps
1121      * {@code JInternalFrame.removeInternalFrameListener(InternalFrameListener)}
1122      * through queue
1123      */
1124     public void removeInternalFrameListener(final InternalFrameListener internalFrameListener) {
1125         runMapping(new MapVoidAction(&quot;removeInternalFrameListener&quot;) {
1126             @Override
1127             public void map() {
1128                 ((JInternalFrame) getSource()).removeInternalFrameListener(internalFrameListener);
1129             }
1130         });
1131     }
1132 
1133     /**
1134      * Maps {@code JInternalFrame.setClosable(boolean)} through queue
1135      */
1136     public void setClosable(final boolean b) {
1137         runMapping(new MapVoidAction(&quot;setClosable&quot;) {
1138             @Override
1139             public void map() {
1140                 ((JInternalFrame) getSource()).setClosable(b);
1141             }
1142         });
1143     }
1144 
1145     /**
1146      * Maps {@code JInternalFrame.setClosed(boolean)} through queue
1147      */
1148     public void setClosed(final boolean b) {
1149         runMapping(new MapVoidAction(&quot;setClosed&quot;) {
1150             @Override
1151             public void map() throws PropertyVetoException {
1152                 ((JInternalFrame) getSource()).setClosed(b);
1153             }
1154         });
1155     }
1156 
1157     /**
1158      * Maps {@code JInternalFrame.setContentPane(Container)} through queue
1159      */
1160     public void setContentPane(final Container container) {
1161         runMapping(new MapVoidAction(&quot;setContentPane&quot;) {
1162             @Override
1163             public void map() {
1164                 ((JInternalFrame) getSource()).setContentPane(container);
1165             }
1166         });
1167     }
1168 
1169     /**
1170      * Maps {@code JInternalFrame.setDefaultCloseOperation(int)} through queue
1171      */
1172     public void setDefaultCloseOperation(final int i) {
1173         runMapping(new MapVoidAction(&quot;setDefaultCloseOperation&quot;) {
1174             @Override
1175             public void map() {
1176                 ((JInternalFrame) getSource()).setDefaultCloseOperation(i);
1177             }
1178         });
1179     }
1180 
1181     /**
1182      * Maps {@code JInternalFrame.setDesktopIcon(JDesktopIcon)} through queue
1183      */
1184     public void setDesktopIcon(final JDesktopIcon jDesktopIcon) {
1185         runMapping(new MapVoidAction(&quot;setDesktopIcon&quot;) {
1186             @Override
1187             public void map() {
1188                 ((JInternalFrame) getSource()).setDesktopIcon(jDesktopIcon);
1189             }
1190         });
1191     }
1192 
1193     /**
1194      * Maps {@code JInternalFrame.setFrameIcon(Icon)} through queue
1195      */
1196     public void setFrameIcon(final Icon icon) {
1197         runMapping(new MapVoidAction(&quot;setFrameIcon&quot;) {
1198             @Override
1199             public void map() {
1200                 ((JInternalFrame) getSource()).setFrameIcon(icon);
1201             }
1202         });
1203     }
1204 
1205     /**
1206      * Maps {@code JInternalFrame.setGlassPane(Component)} through queue
1207      */
1208     public void setGlassPane(final Component component) {
1209         runMapping(new MapVoidAction(&quot;setGlassPane&quot;) {
1210             @Override
1211             public void map() {
1212                 ((JInternalFrame) getSource()).setGlassPane(component);
1213             }
1214         });
1215     }
1216 
1217     /**
1218      * Maps {@code JInternalFrame.setIcon(boolean)} through queue
1219      */
1220     public void setIcon(final boolean b) {
1221         runMapping(new MapVoidAction(&quot;setIcon&quot;) {
1222             @Override
1223             public void map() throws PropertyVetoException {
1224                 ((JInternalFrame) getSource()).setIcon(b);
1225             }
1226         });
1227     }
1228 
1229     /**
1230      * Maps {@code JInternalFrame.setIconifiable(boolean)} through queue
1231      */
1232     public void setIconifiable(final boolean b) {
1233         runMapping(new MapVoidAction(&quot;setIconifiable&quot;) {
1234             @Override
1235             public void map() {
1236                 ((JInternalFrame) getSource()).setIconifiable(b);
1237             }
1238         });
1239     }
1240 
1241     /**
1242      * Maps {@code JInternalFrame.setJMenuBar(JMenuBar)} through queue
1243      */
1244     public void setJMenuBar(final JMenuBar jMenuBar) {
1245         runMapping(new MapVoidAction(&quot;setJMenuBar&quot;) {
1246             @Override
1247             public void map() {
1248                 ((JInternalFrame) getSource()).setJMenuBar(jMenuBar);
1249             }
1250         });
1251     }
1252 
1253     /**
1254      * Maps {@code JInternalFrame.setLayer(Integer)} through queue
1255      */
1256     public void setLayer(final Integer integer) {
1257         runMapping(new MapVoidAction(&quot;setLayer&quot;) {
1258             @Override
1259             public void map() {
1260                 ((JInternalFrame) getSource()).setLayer(integer);
1261             }
1262         });
1263     }
1264 
1265     /**
1266      * Maps {@code JInternalFrame.setLayeredPane(JLayeredPane)} through queue
1267      */
1268     public void setLayeredPane(final JLayeredPane jLayeredPane) {
1269         runMapping(new MapVoidAction(&quot;setLayeredPane&quot;) {
1270             @Override
1271             public void map() {
1272                 ((JInternalFrame) getSource()).setLayeredPane(jLayeredPane);
1273             }
1274         });
1275     }
1276 
1277     /**
1278      * Maps {@code JInternalFrame.setMaximizable(boolean)} through queue
1279      */
1280     public void setMaximizable(final boolean b) {
1281         runMapping(new MapVoidAction(&quot;setMaximizable&quot;) {
1282             @Override
1283             public void map() {
1284                 ((JInternalFrame) getSource()).setMaximizable(b);
1285             }
1286         });
1287     }
1288 
1289     /**
1290      * Maps {@code JInternalFrame.setMaximum(boolean)} through queue
1291      */
1292     public void setMaximum(final boolean b) {
1293         runMapping(new MapVoidAction(&quot;setMaximum&quot;) {
1294             @Override
1295             public void map() throws PropertyVetoException {
1296                 ((JInternalFrame) getSource()).setMaximum(b);
1297             }
1298         });
1299     }
1300 
1301     /**
1302      * Maps {@code JInternalFrame.setResizable(boolean)} through queue
1303      */
1304     public void setResizable(final boolean b) {
1305         runMapping(new MapVoidAction(&quot;setResizable&quot;) {
1306             @Override
1307             public void map() {
1308                 ((JInternalFrame) getSource()).setResizable(b);
1309             }
1310         });
1311     }
1312 
1313     /**
1314      * Maps {@code JInternalFrame.setSelected(boolean)} through queue
1315      */
1316     public void setSelected(final boolean b) {
1317         runMapping(new MapVoidAction(&quot;setSelected&quot;) {
1318             @Override
1319             public void map() throws PropertyVetoException {
1320                 ((JInternalFrame) getSource()).setSelected(b);
1321             }
1322         });
1323     }
1324 
1325     /**
1326      * Maps {@code JInternalFrame.setTitle(String)} through queue
1327      */
1328     public void setTitle(final String string) {
1329         runMapping(new MapVoidAction(&quot;setTitle&quot;) {
1330             @Override
1331             public void map() {
1332                 ((JInternalFrame) getSource()).setTitle(string);
1333             }
1334         });
1335     }
1336 
1337     /**
1338      * Maps {@code JInternalFrame.setUI(InternalFrameUI)} through queue
1339      */
1340     public void setUI(final InternalFrameUI internalFrameUI) {
1341         runMapping(new MapVoidAction(&quot;setUI&quot;) {
1342             @Override
1343             public void map() {
1344                 ((JInternalFrame) getSource()).setUI(internalFrameUI);
1345             }
1346         });
1347     }
1348 
1349     /**
1350      * Maps {@code JInternalFrame.toBack()} through queue
1351      */
1352     public void toBack() {
1353         runMapping(new MapVoidAction(&quot;toBack&quot;) {
1354             @Override
1355             public void map() {
1356                 ((JInternalFrame) getSource()).toBack();
1357             }
1358         });
1359     }
1360 
1361     /**
1362      * Maps {@code JInternalFrame.toFront()} through queue
1363      */
1364     public void toFront() {
1365         runMapping(new MapVoidAction(&quot;toFront&quot;) {
1366             @Override
1367             public void map() {
1368                 ((JInternalFrame) getSource()).toFront();
1369             }
1370         });
1371     }
1372 
1373     //End of mapping                                      //
1374     ////////////////////////////////////////////////////////
1375     /**
1376      * Uses InternalframeDriver to get a title pane.
1377      *
1378      * @return a title pane.
1379      */
1380     protected Container findTitlePane() {
1381         return (Container) iDriver.getTitlePane(this);
1382     }
1383 
1384     /**
1385      * Initialize icon operator
1386      */
1387     protected void initIconOperator() {
1388         iconOperator = new JDesktopIconOperator(((JInternalFrame) getSource()).getDesktopIcon());
1389         iconOperator.copyEnvironment(this);
1390     }
1391 
1392     /**
1393      * Initiaites suboperators.
1394      */
1395     protected void initOperators() {
1396         initIconOperator();
1397         if(Platform.isOSX()) {
1398             throw new UnsupportedOperationException(
1399                     &quot;Jemmy doesn&#39;t support getting or initializing title&quot;
1400                     + &quot; related operators on Mac OSx&quot;);
1401         } else {
1402             Container titlePane = findTitlePane();
1403             if (!isIcon() &amp;&amp; titlePane != null) {
1404                 if (titleOperator == null) {
1405                     titleOperator = new ContainerOperator&lt;&gt;(titlePane);
1406                     if (getContainer(new ComponentChooser() {
1407                         @Override
1408                         public boolean checkComponent(Component comp) {
1409                             return comp instanceof JDesktopPane;
1410                         }
1411 
1412                     @Override
1413                     public String getDescription() {
1414                         return &quot;Desktop pane&quot;;
1415                     }
1416 
1417                     @Override
1418                     public String toString() {
1419                         return &quot;JInternalFrameOperator.initOperators.ComponentChooser{description = &quot; + getDescription() + &#39;}&#39;;
1420                     }
1421                 }) != null) {
<a name="3" id="anc3"></a><span class="line-modified">1422                     if(&quot;Motif&quot;.equals(UIManager.getLookAndFeel().getID())) {</span>
1423                         popupButtonOper = new JButtonOperator(titleOperator, 0);
1424                     } else {
1425                         minOper = new JButtonOperator(titleOperator,
1426                             new JComponentByTipFinder(MINIMIZE_BUTTON_TOOLTIP));
1427                         if (((JInternalFrame) getSource()).isMaximizable()) {
1428                             maxOper = new JButtonOperator(titleOperator,
1429                                 new JComponentByTipFinder(MAXIMIZE_BUTTON_TOOLTIP));
1430                         } else {
1431                             maxOper = null;
1432                         }
1433                     }
1434                 } else {
1435                     minOper = null;
1436                     maxOper = null;
1437                 }
1438                 if (isClosable()) {
<a name="4" id="anc4"></a><span class="line-modified">1439                     if(!&quot;Motif&quot;.equals(UIManager.getLookAndFeel().getID())) {</span>
1440                         closeOper = new JButtonOperator(titleOperator,
1441                             new JComponentByTipFinder(CLOSE_BUTTON_TOOLTIP));
1442                     }
1443                 } else {
1444                     closeOper = null;
1445                 }
1446             }
1447         } else {
1448             titleOperator = null;
1449             minOper = null;
1450             maxOper = null;
1451             closeOper = null;
1452             }
1453         }
1454     }
1455 
1456     //throw exception if state is wrong
1457     private void checkIconified(boolean shouldBeIconified) {
1458         if (shouldBeIconified &amp;&amp; !isIcon()
1459                 || !shouldBeIconified &amp;&amp; isIcon()) {
1460             throw (new WrongInternalFrameStateException(&quot;JInternal frame should &quot;
1461                     + (shouldBeIconified ? &quot;&quot; : &quot;not&quot;)
1462                     + &quot; be iconified to produce this operation&quot;,
1463                     getSource()));
1464         }
1465     }
1466 
1467     private static JInternalFrame findOne(ContainerOperator&lt;?&gt; cont, String text, int index) {
1468         Component source = waitComponent(cont,
1469                 new JInternalFrameByTitleFinder(text,
1470                         cont.getComparator()),
1471                 index);
1472         if (source instanceof JInternalFrame) {
1473             return (JInternalFrame) source;
1474         } else if (source instanceof JInternalFrame.JDesktopIcon) {
1475             return ((JInternalFrame.JDesktopIcon) source).getInternalFrame();
1476         } else {
1477             throw (new TimeoutExpiredException(&quot;No internal frame was found&quot;));
1478         }
1479     }
1480 
1481     /**
1482      * Exception can be throwht if as a result of an attempt to produce
1483      * operation for the frame in incorrect state. Like activate iconified
1484      * frame, for example.
1485      */
1486     public static class WrongInternalFrameStateException extends JemmyInputException {
1487 
1488         private static final long serialVersionUID = 42L;
1489 
1490         /**
1491          * Constructs a JInternalFrameOperator$WrongInternalFrameStateException
1492          * object.
1493          *
1494          * @param message an exception message.
1495          * @param comp an internal frame.
1496          */
1497         public WrongInternalFrameStateException(String message, Component comp) {
1498             super(message, comp);
1499         }
1500     }
1501 
1502     /**
1503      * Allows to find component by title.
1504      */
1505     public static class JInternalFrameByTitleFinder implements ComponentChooser {
1506 
1507         String label;
1508         StringComparator comparator;
1509 
1510         /**
1511          * Constructs JInternalFrameByTitleFinder.
1512          *
1513          * @param lb a text pattern
1514          * @param comparator specifies string comparision algorithm.
1515          */
1516         public JInternalFrameByTitleFinder(String lb, StringComparator comparator) {
1517             label = lb;
1518             this.comparator = comparator;
1519         }
1520 
1521         /**
1522          * Constructs JInternalFrameByTitleFinder.
1523          *
1524          * @param lb a text pattern
1525          */
1526         public JInternalFrameByTitleFinder(String lb) {
1527             this(lb, Operator.getDefaultStringComparator());
1528         }
1529 
1530         @Override
1531         public boolean checkComponent(Component comp) {
1532             if (comp instanceof JInternalFrame || comp instanceof JInternalFrame.JDesktopIcon) {
1533                 JInternalFrame frame = null;
1534                 if (comp instanceof JInternalFrame) {
1535                     frame = (JInternalFrame) comp;
1536                 } else {
1537                     JDesktopIconOperator io = new JDesktopIconOperator((JInternalFrame.JDesktopIcon) comp);
1538                     frame = io.getInternalFrame();
1539                 }
1540                 if (frame.getTitle() != null) {
1541                     return (comparator.equals(frame.getTitle(),
1542                             label));
1543                 }
1544             }
1545             return false;
1546         }
1547 
1548         @Override
1549         public String getDescription() {
1550             return &quot;JInternalFrame with title \&quot;&quot; + label + &quot;\&quot;&quot;;
1551         }
1552 
1553         @Override
1554         public String toString() {
1555             return &quot;JInternalFrameByTitleFinder{&quot; + &quot;label=&quot; + label + &quot;, comparator=&quot; + comparator + &#39;}&#39;;
1556         }
1557     }
1558 
1559     /**
1560      * Class to operate with javax.swing.JInternalFrame.JDesktopIconOperator
1561      * component.
1562      */
1563     public static class JDesktopIconOperator extends JComponentOperator
1564             implements Outputable, Timeoutable {
1565 
1566         private TestOut output;
1567         private Timeouts timeouts;
1568 
1569         /**
1570          * Constructs JDesktopIconOperator.
1571          *
1572          * @param b a component
1573          */
1574         public JDesktopIconOperator(JInternalFrame.JDesktopIcon b) {
1575             super(b);
1576             setOutput(JemmyProperties.getCurrentOutput());
1577             setTimeouts(JemmyProperties.getCurrentTimeouts());
1578         }
1579 
1580         @Override
1581         public void setOutput(TestOut out) {
1582             output = out;
1583             super.setOutput(output.createErrorOutput());
1584         }
1585 
1586         @Override
1587         public TestOut getOutput() {
1588             return output;
1589         }
1590 
1591         @Override
1592         public void setTimeouts(Timeouts times) {
1593             timeouts = times;
1594             super.setTimeouts(timeouts);
1595         }
1596 
1597         @Override
1598         public Timeouts getTimeouts() {
1599             return timeouts;
1600         }
1601 
1602         /**
1603          * Creates an operator for the correspondent internal frame.
1604          *
1605          * @return an operator.
1606          */
1607         public JInternalFrame getInternalFrame() {
1608             return (runMapping(new MapAction&lt;JInternalFrame&gt;(&quot;getInternalFrame&quot;) {
1609                 @Override
1610                 public JInternalFrame map() {
1611                     return ((JInternalFrame.JDesktopIcon) getSource()).getInternalFrame();
1612                 }
1613             }));
1614         }
1615 
1616         /**
1617          * Pushs the deiconifying button.
1618          */
1619         public void pushButton() {
1620             this.clickMouse(2);
1621         }
1622     }
1623 
1624     /**
1625      * Checks component type.
1626      */
1627     public static class JInternalFrameFinder implements ComponentChooser {
1628 
1629         ComponentChooser sf = null;
1630 
1631         /**
1632          * Constructs JInternalFrameFinder.
1633          *
1634          * @param sf other searching criteria.
1635          */
1636         public JInternalFrameFinder(ComponentChooser sf) {
1637             this.sf = sf;
1638         }
1639 
1640         /**
1641          * Constructs JInternalFrameFinder.
1642          */
1643         public JInternalFrameFinder() {
1644             this(ComponentSearcher.getTrueChooser(&quot;JInternalFrame or JInternalFrame.JDesktopIcon&quot;));
1645         }
1646 
1647         @Override
1648         public boolean checkComponent(Component comp) {
1649             return ((comp instanceof JInternalFrame || comp instanceof JInternalFrame.JDesktopIcon)
1650                     &amp;&amp; sf.checkComponent(comp));
1651         }
1652 
1653         @Override
1654         public String getDescription() {
1655             return sf.getDescription();
1656         }
1657 
1658         @Override
1659         public String toString() {
1660             return &quot;JInternalFrameFinder{&quot; + &quot;sf=&quot; + sf + &#39;}&#39;;
1661         }
1662     }
1663 
1664 }
<a name="5" id="anc5"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="5" type="hidden" />
</body>
</html>
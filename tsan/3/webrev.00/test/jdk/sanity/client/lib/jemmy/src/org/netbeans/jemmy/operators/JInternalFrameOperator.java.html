<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New test/jdk/sanity/client/lib/jemmy/src/org/netbeans/jemmy/operators/JInternalFrameOperator.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 1997, 2019, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation. Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 package org.netbeans.jemmy.operators;
  26 
  27 import java.awt.Component;
  28 import java.awt.Container;
  29 import java.awt.Dimension;
  30 import java.awt.Point;
  31 import java.awt.Rectangle;
  32 import java.beans.PropertyVetoException;
  33 import java.util.Hashtable;
  34 
  35 import javax.swing.Icon;
  36 import javax.swing.JDesktopPane;
  37 import javax.swing.JInternalFrame;
  38 import javax.swing.JInternalFrame.JDesktopIcon;
  39 import javax.swing.JLayeredPane;
  40 import javax.swing.JMenuBar;
  41 import javax.swing.JScrollPane;
  42 import javax.swing.UIManager;
  43 import javax.swing.event.InternalFrameListener;
  44 import javax.swing.plaf.InternalFrameUI;
  45 
  46 import org.netbeans.jemmy.ComponentChooser;
  47 import org.netbeans.jemmy.ComponentSearcher;
  48 import org.netbeans.jemmy.JemmyInputException;
  49 import org.netbeans.jemmy.JemmyProperties;
  50 import org.netbeans.jemmy.Outputable;
  51 import org.netbeans.jemmy.TestOut;
  52 import org.netbeans.jemmy.TimeoutExpiredException;
  53 import org.netbeans.jemmy.Timeoutable;
  54 import org.netbeans.jemmy.Timeouts;
  55 import org.netbeans.jemmy.drivers.DriverManager;
  56 import org.netbeans.jemmy.drivers.FrameDriver;
  57 import org.netbeans.jemmy.drivers.InternalFrameDriver;
  58 import org.netbeans.jemmy.drivers.WindowDriver;
  59 import org.netbeans.jemmy.util.EmptyVisualizer;
  60 import org.netbeans.jemmy.util.LookAndFeel;
  61 import org.netbeans.jemmy.util.Platform;
  62 
  63 /**
  64  * Class provides necessary functionality to operate with
  65  * javax.swing.JInternalFrame component.
  66  *
  67  * Some methods can throw WrongInternalFrameStateException exception.
  68  *
  69  * &lt;BR&gt;&lt;BR&gt;Timeouts used: &lt;BR&gt;
  70  * ComponentOperator.WaitComponentTimeout - time to wait component displayed
  71  * &lt;BR&gt;
  72  * ComponentOperator.MouseClickTimeout - time between mouse pressing and
  73  * releasing &lt;BR&gt;
  74  * AbstractButtonOperator.PushButtonTimeout - time between button pressing and
  75  * releasing&lt;BR&gt;
  76  * JScrollBarOperator.WholeScrollTimeout - time for the whole scrolling &lt;BR&gt;.
  77  *
  78  * @see org.netbeans.jemmy.Timeouts
  79  * @see WrongInternalFrameStateException
  80  * @author Alexandre Iline (alexandre.iline@oracle.com)
  81  */
  82 public class JInternalFrameOperator extends JComponentOperator
  83         implements Outputable, Timeoutable {
  84 
  85     /**
  86      * Identifier for a &quot;title&quot; property.
  87      *
  88      * @see #getDump
  89      */
  90     public static final String TITLE_DPROP = &quot;Title&quot;;
  91 
  92     /**
  93      * Identifier for a &quot;state&quot; property.
  94      *
  95      * @see #getDump
  96      */
  97     public static final String STATE_DPROP = &quot;State&quot;;
  98 
  99     /**
 100      * Identifier for a &quot;normal&quot; value of &quot;state&quot; property.
 101      *
 102      * @see #getDump
 103      */
 104     public static final String STATE_NORMAL_DPROP_VALUE = &quot;NORMAL&quot;;
 105 
 106     /**
 107      * Identifier for a &quot;closed&quot; value of &quot;state&quot; property.
 108      *
 109      * @see #getDump
 110      */
 111     public static final String STATE_CLOSED_DPROP_VALUE = &quot;CLOSED&quot;;
 112 
 113     /**
 114      * Identifier for a &quot;iconified&quot; value of &quot;state&quot; property.
 115      *
 116      * @see #getDump
 117      */
 118     public static final String STATE_ICONIFIED_DPROP_VALUE = &quot;ICONIFIED&quot;;
 119 
 120     /**
 121      * Identifier for a &quot;maximized&quot; value of &quot;state&quot; property.
 122      *
 123      * @see #getDump
 124      */
 125     public static final String STATE_MAXIMAZED_DPROP_VALUE = &quot;MAXIMIZED&quot;;
 126 
 127     /**
 128      * Identifier for a &quot;resizable&quot; property.
 129      *
 130      * @see #getDump
 131      */
 132     public static final String IS_RESIZABLE_DPROP = &quot;Resizable&quot;;
 133 
 134     /**
 135      * Identifier for a &quot;selected&quot; property.
 136      *
 137      * @see #getDump
 138      */
 139     public static final String IS_SELECTED_DPROP = &quot;Selected&quot;;
 140 
 141     /**
 142      * Maximize button tool tip key
 143      */
 144     public static final String MAXIMIZE_BUTTON_TOOLTIP =
 145             UIManager.getString(&quot;InternalFrame.maxButtonToolTip&quot;);
 146 
 147     /**
 148      * Close button tool tip key
 149      */
 150     public static final String CLOSE_BUTTON_TOOLTIP =
 151             UIManager.getString(&quot;InternalFrame.closeButtonToolTip&quot;);
 152 
 153     /**
 154      * Minimize button tool tip key
 155      */
 156     public static final String MINIMIZE_BUTTON_TOOLTIP =
 157             UIManager.getString(&quot;InternalFrame.iconButtonToolTip&quot;);
 158 
 159     /**
 160      * A minimizing button.
 161      */
 162     protected JButtonOperator minOper = null;
 163 
 164     /**
 165      * A maximizing button.
 166      */
 167     protected JButtonOperator maxOper = null;
 168 
 169     /**
 170      * A close button.
 171      */
 172     protected JButtonOperator closeOper = null;
 173 
 174     protected JButtonOperator popupButtonOper = null;
 175 
 176     /**
 177      * A title operator.
 178      */
 179     protected ContainerOperator&lt;?&gt; titleOperator = null;
 180     private TestOut output;
 181     private Timeouts timeouts;
 182     private JDesktopIconOperator iconOperator;
 183 
 184     WindowDriver wDriver;
 185     FrameDriver fDriver;
 186     InternalFrameDriver iDriver;
 187 
 188     /**
 189      * Constructor.
 190      *
 191      * @param b a component
 192      */
 193     public JInternalFrameOperator(JInternalFrame b) {
 194         super(b);
 195         wDriver = DriverManager.getWindowDriver(getClass());
 196         fDriver = DriverManager.getFrameDriver(getClass());
 197         iDriver = DriverManager.getInternalFrameDriver(getClass());
 198     }
 199 
 200     /**
 201      * Constructs a JInternalFrameOperator object.
 202      *
 203      * @param cont a container
 204      * @param chooser a component chooser specifying searching criteria.
 205      * @param index an index between appropriate ones.
 206      */
 207     public JInternalFrameOperator(ContainerOperator&lt;?&gt; cont, ComponentChooser chooser, int index) {
 208         this(waitJInternalFrame((Container)cont.getSource(),
 209                 chooser, index));
 210         copyEnvironment(cont);
 211     }
 212 
 213     /**
 214      * Constructs a JInternalFrameOperator object.
 215      *
 216      * @param cont a container
 217      * @param chooser a component chooser specifying searching criteria.
 218      */
 219     public JInternalFrameOperator(ContainerOperator&lt;?&gt; cont, ComponentChooser chooser) {
 220         this(cont, chooser, 0);
 221     }
 222 
 223     /**
 224      * Constructor. Waits component in container first. Uses cont&#39;s timeout and
 225      * output for waiting and to init operator.
 226      *
 227      * @param cont a container
 228      * @param text Button text.
 229      * @param index Ordinal component index.
 230      * @see ComponentOperator#isCaptionEqual(String, String, boolean, boolean)
 231      *
 232      */
 233     public JInternalFrameOperator(ContainerOperator&lt;?&gt; cont, String text, int index) {
 234         this(findOne(cont, text, index));
 235         copyEnvironment(cont);
 236     }
 237 
 238     /**
 239      * Constructor. Waits component in container first. Uses cont&#39;s timeout and
 240      * output for waiting and to init operator.
 241      *
 242      * @param cont a container
 243      * @param text Button text.
 244      * @see ComponentOperator#isCaptionEqual(String, String, boolean, boolean)
 245      *
 246      */
 247     public JInternalFrameOperator(ContainerOperator&lt;?&gt; cont, String text) {
 248         this(cont, text, 0);
 249     }
 250 
 251     /**
 252      * Constructor. Waits component in container first. Uses cont&#39;s timeout and
 253      * output for waiting and to init operator.
 254      *
 255      * @param cont a container
 256      * @param index Ordinal component index.
 257      *
 258      */
 259     public JInternalFrameOperator(ContainerOperator&lt;?&gt; cont, int index) {
 260         this(waitJInternalFrame((Container)cont.getSource(),
 261                 new JInternalFrameFinder(),
 262                 index));
 263         copyEnvironment(cont);
 264     }
 265 
 266     /**
 267      * Constructor. Waits component in container first. Uses cont&#39;s timeout and
 268      * output for waiting and to init operator.
 269      *
 270      * @param cont a container
 271      *
 272      */
 273     public JInternalFrameOperator(ContainerOperator&lt;?&gt; cont) {
 274         this(cont, 0);
 275     }
 276 
 277     /**
 278      * Searches JInternalframe in container.
 279      *
 280      * @param cont Container to search component in.
 281      * @param chooser a component chooser specifying searching criteria.
 282      * @param index Ordinal component index.
 283      * @return JInternalframe instance or null if component was not found.
 284      */
 285     public static JInternalFrame findJInternalFrame(Container cont, ComponentChooser chooser, int index) {
 286         Component res = findComponent(cont, new JInternalFrameFinder(chooser), index);
 287         if (res instanceof JInternalFrame) {
 288             return (JInternalFrame) res;
 289         } else if (res instanceof JInternalFrame.JDesktopIcon) {
 290             return ((JInternalFrame.JDesktopIcon) res).getInternalFrame();
 291         } else {
 292             return null;
 293         }
 294     }
 295 
 296     /**
 297      * Searches JInternalframe in container.
 298      *
 299      * @param cont Container to search component in.
 300      * @param chooser a component chooser specifying searching criteria.
 301      * @return JInternalframe instance or null if component was not found.
 302      */
 303     public static JInternalFrame findJInternalFrame(Container cont, ComponentChooser chooser) {
 304         return findJInternalFrame(cont, chooser, 0);
 305     }
 306 
 307     /**
 308      * Searches JInternalframe by title.
 309      *
 310      * @param cont Container to search component in.
 311      * @param text Component text.
 312      * @param ce Compare text exactly.
 313      * @param ccs Compare text case sensitively.
 314      * @param index Ordinal component index.
 315      * @return JInternalframe instance or null if component was not found.
 316      * @see ComponentOperator#isCaptionEqual(String, String, boolean, boolean)
 317      */
 318     public static JInternalFrame findJInternalFrame(Container cont, String text, boolean ce, boolean ccs, int index) {
 319         return (findJInternalFrame(cont,
 320                 new JInternalFrameByTitleFinder(text,
 321                         new DefaultStringComparator(ce, ccs)),
 322                 index));
 323     }
 324 
 325     /**
 326      * Searches JInternalframe by title.
 327      *
 328      * @param cont Container to search component in.
 329      * @param text Component text.
 330      * @param ce Compare text exactly.
 331      * @param ccs Compare text case sensitively.
 332      * @return JInternalframe instance or null if component was not found.
 333      * @see ComponentOperator#isCaptionEqual(String, String, boolean, boolean)
 334      */
 335     public static JInternalFrame findJInternalFrame(Container cont, String text, boolean ce, boolean ccs) {
 336         return findJInternalFrame(cont, text, ce, ccs, 0);
 337     }
 338 
 339     /**
 340      * Searches JInternalFrame object which component lies on.
 341      *
 342      * @param comp Component to find JInternalFrame under.
 343      * @param chooser org.netbeans.jemmy.ComponentChooser implementation.
 344      * @return JInternalFrame instance or null if component was not found.
 345      */
 346     public static JInternalFrame findJInternalFrameUnder(Component comp, ComponentChooser chooser) {
 347         return (JInternalFrame) findContainerUnder(comp, new JInternalFrameFinder(chooser));
 348     }
 349 
 350     /**
 351      * Searches JInternalFrame object which component lies on.
 352      *
 353      * @param comp Component to find JInternalFrame under.
 354      * @return JInternalFrame instance or null if component was not found.
 355      */
 356     public static JInternalFrame findJInternalFrameUnder(Component comp) {
 357         return findJInternalFrameUnder(comp, new JInternalFrameFinder());
 358     }
 359 
 360     /**
 361      * Waits JInternalframe in container.
 362      *
 363      * @param cont Container to search component in.
 364      * @param chooser a component chooser specifying searching criteria.
 365      * @param index Ordinal component index.
 366      * @return JInternalframe instance.
 367      *
 368      */
 369     public static JInternalFrame waitJInternalFrame(final Container cont, final ComponentChooser chooser, final int index) {
 370         Component res = waitComponent(cont, new JInternalFrameFinder(chooser), index);
 371         if (res instanceof JInternalFrame) {
 372             return (JInternalFrame) res;
 373         } else if (res instanceof JInternalFrame.JDesktopIcon) {
 374             return ((JInternalFrame.JDesktopIcon) res).getInternalFrame();
 375         } else {
 376             throw (new TimeoutExpiredException(chooser.getDescription()));
 377         }
 378     }
 379 
 380     /**
 381      * Waits JInternalframe in container.
 382      *
 383      * @param cont Container to search component in.
 384      * @param chooser a component chooser specifying searching criteria.
 385      * @return JInternalframe instance.
 386      *
 387      */
 388     public static JInternalFrame waitJInternalFrame(Container cont, ComponentChooser chooser) {
 389         return waitJInternalFrame(cont, chooser, 0);
 390     }
 391 
 392     /**
 393      * Waits JInternalframe by title.
 394      *
 395      * @param cont Container to search component in.
 396      * @param text Component text.
 397      * @param ce Compare text exactly.
 398      * @param ccs Compare text case sensitively.
 399      * @param index Ordinal component index.
 400      * @return JInternalframe instance.
 401      * @see ComponentOperator#isCaptionEqual(String, String, boolean, boolean)
 402      *
 403      */
 404     public static JInternalFrame waitJInternalFrame(Container cont, String text, boolean ce, boolean ccs, int index) {
 405         return (waitJInternalFrame(cont,
 406                 new JInternalFrameByTitleFinder(text,
 407                         new DefaultStringComparator(ce, ccs)),
 408                 index));
 409     }
 410 
 411     /**
 412      * Waits JInternalframe by title.
 413      *
 414      * @param cont Container to search component in.
 415      * @param text Component text.
 416      * @param ce Compare text exactly.
 417      * @param ccs Compare text case sensitively.
 418      * @return JInternalframe instance.
 419      * @see ComponentOperator#isCaptionEqual(String, String, boolean, boolean)
 420      *
 421      */
 422     public static JInternalFrame waitJInternalFrame(Container cont, String text, boolean ce, boolean ccs) {
 423         return waitJInternalFrame(cont, text, ce, ccs, 0);
 424     }
 425 
 426     @Override
 427     public void setOutput(TestOut out) {
 428         output = out;
 429         super.setOutput(output.createErrorOutput());
 430     }
 431 
 432     @Override
 433     public TestOut getOutput() {
 434         return output;
 435     }
 436 
 437     @Override
 438     public void setTimeouts(Timeouts times) {
 439         timeouts = times;
 440         super.setTimeouts(timeouts);
 441     }
 442 
 443     @Override
 444     public Timeouts getTimeouts() {
 445         return timeouts;
 446     }
 447 
 448     /**
 449      * Iconifies frame. Note: frame should not be iconified and should be
 450      * iconifiable.
 451      *
 452      * @throws WrongInternalFrameStateException
 453      *
 454      */
 455     public void iconify() {
 456         output.printLine(&quot;Iconify JInternalFrame\n    : &quot; + toStringSource());
 457         output.printGolden(&quot;Iconify JInternalFrame \&quot;&quot; + getTitle() + &quot;\&quot;&quot;);
 458         checkIconified(false);
 459         makeComponentVisible();
 460         fDriver.iconify(this);
 461         if (getVerification()) {
 462             waitIcon(true);
 463         }
 464     }
 465 
 466     /**
 467      * Deiconifies frame. Note: frame should be iconified.
 468      *
 469      * @throws WrongInternalFrameStateException
 470      *
 471      */
 472     public void deiconify() {
 473         output.printLine(&quot;Deiconify JInternalFrame\n    : &quot; + toStringSource());
 474         output.printGolden(&quot;Deiconify JInternalFrame \&quot;&quot; + getTitle() + &quot;\&quot;&quot;);
 475         checkIconified(true);
 476         fDriver.deiconify(this);
 477         if (getVerification()) {
 478             waitIcon(false);
 479         }
 480     }
 481 
 482     /**
 483      * Maximizes frame. Note: frame should not be iconified.
 484      *
 485      * @throws WrongInternalFrameStateException
 486      */
 487     public void maximize() {
 488         output.printLine(&quot;Maximize JInternalFrame\n    : &quot; + toStringSource());
 489         output.printGolden(&quot;Maximize JInternalFrame \&quot;&quot; + getTitle() + &quot;\&quot;&quot;);
 490         checkIconified(false);
 491         makeComponentVisible();
 492         fDriver.maximize(this);
 493         if (getVerification()) {
 494             waitMaximum(true);
 495         }
 496     }
 497 
 498     /**
 499      * Demaximizes frame. Note: frame should not be iconified.
 500      *
 501      * @throws WrongInternalFrameStateException
 502      */
 503     public void demaximize() {
 504         output.printLine(&quot;Demaximize JInternalFrame\n    : &quot; + toStringSource());
 505         output.printGolden(&quot;Demaximize JInternalFrame \&quot;&quot; + getTitle() + &quot;\&quot;&quot;);
 506         checkIconified(false);
 507         makeComponentVisible();
 508         fDriver.demaximize(this);
 509         if (getVerification()) {
 510             waitMaximum(false);
 511         }
 512     }
 513 
 514     /**
 515      * Moves frame to new location. Note: frame should not be iconified.
 516      *
 517      * @param x X coordinate of a new frame location.
 518      * @param y Y coordinate of a new frame location.
 519      * @throws WrongInternalFrameStateException
 520      */
 521     public void move(int x, int y) {
 522         checkIconified(false);
 523         output.printLine(&quot;Move JInternalFrame to (&quot;
 524                 + Integer.toString(x) + &quot;,&quot;
 525                 + Integer.toString(y) + &quot;)&quot;
 526                 + &quot; position\n    : &quot; + toStringSource());
 527         output.printGolden(&quot;Move &quot; + getTitle()
 528                 + &quot; JInternalFrame to (&quot;
 529                 + Integer.toString(x) + &quot;,&quot;
 530                 + Integer.toString(y) + &quot;)&quot;
 531                 + &quot; position&quot;);
 532         checkIconified(false);
 533         wDriver.move(this, x, y);
 534         if (getVerification()) {
 535             waitComponentLocation(new Point(x, y));
 536         }
 537     }
 538 
 539     /**
 540      * Resizes frame. Note: frame should not be iconified.
 541      *
 542      * @param width New frame width.
 543      * @param height New frame height.
 544      * @throws WrongInternalFrameStateException
 545      */
 546     public void resize(int width, int height) {
 547         output.printLine(&quot;Resize JInternalFrame to (&quot;
 548                 + Integer.toString(width) + &quot;,&quot;
 549                 + Integer.toString(height) + &quot;)&quot;
 550                 + &quot; size\n    : &quot; + toStringSource());
 551         output.printGolden(&quot;Resize &quot; + getTitle()
 552                 + &quot; JInternalFrame to (&quot;
 553                 + Integer.toString(width) + &quot;,&quot;
 554                 + Integer.toString(height) + &quot;)&quot;
 555                 + &quot; size&quot;);
 556         checkIconified(false);
 557         wDriver.resize(this, width, height);
 558         if (getVerification()) {
 559             waitComponentSize(new Dimension(width, height));
 560         }
 561     }
 562 
 563     /**
 564      * Activates frame. Note: frame should not be iconified.
 565      *
 566      * @throws WrongInternalFrameStateException
 567      */
 568     public void activate() {
 569         checkIconified(false);
 570         wDriver.activate(this);
 571         if (getVerification()) {
 572             waitActivate(true);
 573         }
 574     }
 575 
 576     /**
 577      * Closes the frame.
 578      */
 579     public void close() {
 580         checkIconified(false);
 581         wDriver.requestClose(this);
 582         if (getVerification()) {
 583             waitClosed();
 584         }
 585     }
 586 
 587     /**
 588      * Scrolls to internal frame&#39;s rectangle.
 589      *
 590      * @param x Horizontal rectangle coordinate
 591      * @param y Vertical rectangle coordinate
 592      * @param width rectangle width
 593      * @param height rectangle height
 594      *
 595      */
 596     public void scrollToRectangle(int x, int y, int width, int height) {
 597         output.printTrace(&quot;Scroll desktop pane to make \&quot;&quot; + getTitle() + &quot;\&quot; internal frame visible&quot;);
 598         output.printGolden(&quot;Scroll desktop pane to make \&quot;&quot; + getTitle() + &quot;\&quot; internal frame visible&quot;);
 599         makeComponentVisible();
 600         //try to find JScrollPane under.
 601         JScrollPane scroll;
 602         if (isIcon()) {
 603             scroll
 604                     = (JScrollPane) iconOperator.getContainer(new JScrollPaneOperator.JScrollPaneFinder(ComponentSearcher.
 605                             getTrueChooser(&quot;JScrollPane&quot;)));
 606         } else {
 607             scroll
 608                     = (JScrollPane) getContainer(new JScrollPaneOperator.JScrollPaneFinder(ComponentSearcher.
 609                             getTrueChooser(&quot;JScrollPane&quot;)));
 610         }
 611         if (scroll == null) {
 612             return;
 613         }
 614         JScrollPaneOperator scroller = new JScrollPaneOperator(scroll);
 615         scroller.copyEnvironment(this);
 616         scroller.setVisualizer(new EmptyVisualizer());
 617         scroller.scrollToComponentRectangle(isIcon() ? iconOperator.getSource() : getSource(),
 618                 x, y, width, height);
 619     }
 620 
 621     /**
 622      * Scrolls to internal frame&#39;s rectangle.
 623      *
 624      * @param rect a rectangle to scroll to.
 625      */
 626     public void scrollToRectangle(Rectangle rect) {
 627         scrollToRectangle(rect.x, rect.y, rect.width, rect.height);
 628     }
 629 
 630     /**
 631      * Scrolls to internal frame.
 632      *
 633      */
 634     public void scrollToFrame() {
 635         if (isIcon()) {
 636             scrollToRectangle(0, 0, iconOperator.getWidth(), iconOperator.getHeight());
 637         } else {
 638             scrollToRectangle(0, 0, getWidth(), getHeight());
 639         }
 640     }
 641 
 642     /**
 643      * Waits for a minimize button inside the title pane.
 644      *
 645      * @return a button operator
 646      */
 647     public JButtonOperator getMinimizeButton() {
 648         initOperators();
 649         return minOper;
 650     }
 651 
 652     /**
 653      * Waits for a maximize button inside the title pane.
 654      *
 655      * @return a button operator
 656      */
 657     public JButtonOperator getMaximizeButton() {
 658         initOperators();
 659         return maxOper;
 660     }
 661 
 662     /**
 663      * Waits for a close button inside the title pane.
 664      *
 665      * @return a button operator
 666      */
 667     public JButtonOperator getCloseButton() {
 668         initOperators();
 669         return closeOper;
 670     }
 671 
 672     public JButtonOperator getPopupButton() {
 673         initOperators();
 674         return popupButtonOper;
 675     }
 676 
 677     /**
 678      * Waits for the title pane.
 679      *
 680      * @return a button operator
 681      */
 682     public ContainerOperator&lt;?&gt; getTitleOperator() {
 683         initOperators();
 684         return titleOperator;
 685     }
 686 
 687     /**
 688      * Creates an operator for an desktop icon.
 689      *
 690      * @return an icon operator.
 691      */
 692     public JDesktopIconOperator getIconOperator() {
 693         if(Platform.isOSX()) {
 694             initIconOperator();
 695         } else {
 696             initOperators();
 697         }
 698         return iconOperator;
 699     }
 700 
 701     /**
 702      * Waits for the frame to be iconified or deiconified.
 703      *
 704      * @param isIconified whether the frame needs to be iconified or deiconified.
 705      */
 706     public void waitIcon(final boolean isIconified) {
 707         waitStateOnQueue(new ComponentChooser() {
 708             @Override
 709             public boolean checkComponent(Component comp) {
 710                 return isIcon() == isIconified;
 711             }
 712 
 713             @Override
 714             public String getDescription() {
 715                 return &quot;Internal Frame is &quot; + (isIconified ? &quot;iconified&quot; : &quot;deiconified&quot;);
 716             }
 717 
 718             @Override
 719             public String toString() {
 720                 return &quot;JInternalFrameOperator.waitIcon.ComponentChooser{description = &quot; + getDescription() + &#39;}&#39;;
 721             }
 722         });
 723     }
 724 
 725     /**
 726      * Waits for the frame to be activated or deactivated.
 727      *
 728      * @param isActivate whether the frame needs to be activated or deactivated.
 729      */
 730     public void waitActivate(final boolean isActivate) {
 731         waitStateOnQueue(new ComponentChooser() {
 732             @Override
 733             public boolean checkComponent(Component comp) {
 734                 return isSelected() == isActivate;
 735             }
 736 
 737             @Override
 738             public String getDescription() {
 739                 return &quot;Internal Frame is &quot; + (isActivate ? &quot;activated&quot; : &quot;deactivated&quot;);
 740             }
 741 
 742             @Override
 743             public String toString() {
 744                 return &quot;JInternalFrameOperator.waitActivate.ComponentChooser{description = &quot; + getDescription() + &#39;}&#39;;
 745             }
 746         });
 747     }
 748 
 749     /**
 750      * Waits for the frame to be closed.
 751      */
 752     public void waitClosed() {
 753         waitStateOnQueue(new ComponentChooser() {
 754             @Override
 755             public boolean checkComponent(Component comp) {
 756                 return isClosed();
 757             }
 758 
 759             @Override
 760             public String getDescription() {
 761                 return &quot;Internal Frame is closed&quot;;
 762             }
 763 
 764             @Override
 765             public String toString() {
 766                 return &quot;JInternalFrameOperator.waitClosed.ComponentChooser{description = &quot; + getDescription() + &#39;}&#39;;
 767             }
 768         });
 769     }
 770 
 771     /**
 772      * Waits for the frame to be maximized or demaximized.
 773      *
 774      * @param isMaximum whether the frame needs to be maximized or demaximized.
 775      */
 776     public void waitMaximum(final boolean isMaximum) {
 777         waitStateOnQueue(new ComponentChooser() {
 778             @Override
 779             public boolean checkComponent(Component comp) {
 780                 return isMaximum() == isMaximum;
 781             }
 782 
 783             @Override
 784             public String getDescription() {
 785                 return &quot;Internal Frame is &quot; + (isMaximum ? &quot;maximizied&quot; : &quot;demaximizied&quot;);
 786             }
 787 
 788             @Override
 789             public String toString() {
 790                 return &quot;JInternalFrameOperator.waitMaximum.ComponentChooser{description = &quot; + getDescription() + &#39;}&#39;;
 791             }
 792         });
 793     }
 794 
 795     /**
 796      * Returns information about component.
 797      */
 798     @Override
 799     public Hashtable&lt;String, Object&gt; getDump() {
 800         Hashtable&lt;String, Object&gt; result = super.getDump();
 801         result.put(TITLE_DPROP, ((JInternalFrame) getSource()).getTitle());
 802         String state = STATE_NORMAL_DPROP_VALUE;
 803         if (((JInternalFrame) getSource()).isClosed()) {
 804             state = STATE_CLOSED_DPROP_VALUE;
 805         } else if (((JInternalFrame) getSource()).isIcon()) {
 806             state = STATE_ICONIFIED_DPROP_VALUE;
 807         } else if (((JInternalFrame) getSource()).isMaximum()) {
 808             state = STATE_MAXIMAZED_DPROP_VALUE;
 809         }
 810         result.put(STATE_DPROP, state);
 811         result.put(IS_RESIZABLE_DPROP, ((JInternalFrame) getSource()).isResizable() ? &quot;true&quot; : &quot;false&quot;);
 812         result.put(IS_SELECTED_DPROP, ((JInternalFrame) getSource()).isSelected() ? &quot;true&quot; : &quot;false&quot;);
 813         return result;
 814     }
 815 
 816     ////////////////////////////////////////////////////////
 817     //Mapping                                             //
 818     /**
 819      * Maps
 820      * {@code JInternalFrame.addInternalFrameListener(InternalFrameListener)}
 821      * through queue
 822      */
 823     public void addInternalFrameListener(final InternalFrameListener internalFrameListener) {
 824         runMapping(new MapVoidAction(&quot;addInternalFrameListener&quot;) {
 825             @Override
 826             public void map() {
 827                 ((JInternalFrame) getSource()).addInternalFrameListener(internalFrameListener);
 828             }
 829         });
 830     }
 831 
 832     /**
 833      * Maps {@code JInternalFrame.dispose()} through queue
 834      */
 835     public void dispose() {
 836         runMapping(new MapVoidAction(&quot;dispose&quot;) {
 837             @Override
 838             public void map() {
 839                 ((JInternalFrame) getSource()).dispose();
 840             }
 841         });
 842     }
 843 
 844     /**
 845      * Maps {@code JInternalFrame.getContentPane()} through queue
 846      */
 847     public Container getContentPane() {
 848         return (runMapping(new MapAction&lt;Container&gt;(&quot;getContentPane&quot;) {
 849             @Override
 850             public Container map() {
 851                 return ((JInternalFrame) getSource()).getContentPane();
 852             }
 853         }));
 854     }
 855 
 856     /**
 857      * Maps {@code JInternalFrame.getDefaultCloseOperation()} through queue
 858      */
 859     public int getDefaultCloseOperation() {
 860         return (runMapping(new MapIntegerAction(&quot;getDefaultCloseOperation&quot;) {
 861             @Override
 862             public int map() {
 863                 return ((JInternalFrame) getSource()).getDefaultCloseOperation();
 864             }
 865         }));
 866     }
 867 
 868     /**
 869      * Maps {@code JInternalFrame.getDesktopIcon()} through queue
 870      */
 871     public JDesktopIcon getDesktopIcon() {
 872         return (runMapping(new MapAction&lt;JDesktopIcon&gt;(&quot;getDesktopIcon&quot;) {
 873             @Override
 874             public JDesktopIcon map() {
 875                 return ((JInternalFrame) getSource()).getDesktopIcon();
 876             }
 877         }));
 878     }
 879 
 880     /**
 881      * Maps {@code JInternalFrame.getDesktopPane()} through queue
 882      */
 883     public JDesktopPane getDesktopPane() {
 884         return (runMapping(new MapAction&lt;JDesktopPane&gt;(&quot;getDesktopPane&quot;) {
 885             @Override
 886             public JDesktopPane map() {
 887                 return ((JInternalFrame) getSource()).getDesktopPane();
 888             }
 889         }));
 890     }
 891 
 892     /**
 893      * Maps {@code JInternalFrame.getFrameIcon()} through queue
 894      */
 895     public Icon getFrameIcon() {
 896         return (runMapping(new MapAction&lt;Icon&gt;(&quot;getFrameIcon&quot;) {
 897             @Override
 898             public Icon map() {
 899                 return ((JInternalFrame) getSource()).getFrameIcon();
 900             }
 901         }));
 902     }
 903 
 904     /**
 905      * Maps {@code JInternalFrame.getGlassPane()} through queue
 906      */
 907     public Component getGlassPane() {
 908         return (runMapping(new MapAction&lt;Component&gt;(&quot;getGlassPane&quot;) {
 909             @Override
 910             public Component map() {
 911                 return ((JInternalFrame) getSource()).getGlassPane();
 912             }
 913         }));
 914     }
 915 
 916     /**
 917      * Maps {@code JInternalFrame.getJMenuBar()} through queue
 918      */
 919     public JMenuBar getJMenuBar() {
 920         return (runMapping(new MapAction&lt;JMenuBar&gt;(&quot;getJMenuBar&quot;) {
 921             @Override
 922             public JMenuBar map() {
 923                 return ((JInternalFrame) getSource()).getJMenuBar();
 924             }
 925         }));
 926     }
 927 
 928     /**
 929      * Maps {@code JInternalFrame.getLayer()} through queue
 930      */
 931     public int getLayer() {
 932         return (runMapping(new MapIntegerAction(&quot;getLayer&quot;) {
 933             @Override
 934             public int map() {
 935                 return ((JInternalFrame) getSource()).getLayer();
 936             }
 937         }));
 938     }
 939 
 940     /**
 941      * Maps {@code JInternalFrame.getLayeredPane()} through queue
 942      */
 943     public JLayeredPane getLayeredPane() {
 944         return (runMapping(new MapAction&lt;JLayeredPane&gt;(&quot;getLayeredPane&quot;) {
 945             @Override
 946             public JLayeredPane map() {
 947                 return ((JInternalFrame) getSource()).getLayeredPane();
 948             }
 949         }));
 950     }
 951 
 952     /**
 953      * Maps {@code JInternalFrame.getTitle()} through queue
 954      */
 955     public String getTitle() {
 956         return (runMapping(new MapAction&lt;String&gt;(&quot;getTitle&quot;) {
 957             @Override
 958             public String map() {
 959                 return ((JInternalFrame) getSource()).getTitle();
 960             }
 961         }));
 962     }
 963 
 964     /**
 965      * Maps {@code JInternalFrame.getUI()} through queue
 966      */
 967     public InternalFrameUI getUI() {
 968         return (runMapping(new MapAction&lt;InternalFrameUI&gt;(&quot;getUI&quot;) {
 969             @Override
 970             public InternalFrameUI map() {
 971                 return ((JInternalFrame) getSource()).getUI();
 972             }
 973         }));
 974     }
 975 
 976     /**
 977      * Maps {@code JInternalFrame.getWarningString()} through queue
 978      */
 979     public String getWarningString() {
 980         return (runMapping(new MapAction&lt;String&gt;(&quot;getWarningString&quot;) {
 981             @Override
 982             public String map() {
 983                 return ((JInternalFrame) getSource()).getWarningString();
 984             }
 985         }));
 986     }
 987 
 988     /**
 989      * Maps {@code JInternalFrame.isClosable()} through queue
 990      */
 991     public boolean isClosable() {
 992         return (runMapping(new MapBooleanAction(&quot;isClosable&quot;) {
 993             @Override
 994             public boolean map() {
 995                 return ((JInternalFrame) getSource()).isClosable();
 996             }
 997         }));
 998     }
 999 
1000     /**
1001      * Maps {@code JInternalFrame.isClosed()} through queue
1002      */
1003     public boolean isClosed() {
1004         return (runMapping(new MapBooleanAction(&quot;isClosed&quot;) {
1005             @Override
1006             public boolean map() {
1007                 return ((JInternalFrame) getSource()).isClosed();
1008             }
1009         }));
1010     }
1011 
1012     /**
1013      * Maps {@code JInternalFrame.isIcon()} through queue
1014      */
1015     public boolean isIcon() {
1016         return (runMapping(new MapBooleanAction(&quot;isIcon&quot;) {
1017             @Override
1018             public boolean map() {
1019                 return ((JInternalFrame) getSource()).isIcon();
1020             }
1021         }));
1022     }
1023 
1024     /**
1025      * Maps {@code JInternalFrame.isIconifiable()} through queue
1026      */
1027     public boolean isIconifiable() {
1028         return (runMapping(new MapBooleanAction(&quot;isIconifiable&quot;) {
1029             @Override
1030             public boolean map() {
1031                 return ((JInternalFrame) getSource()).isIconifiable();
1032             }
1033         }));
1034     }
1035 
1036     /**
1037      * Maps {@code JInternalFrame.isMaximizable()} through queue
1038      */
1039     public boolean isMaximizable() {
1040         return (runMapping(new MapBooleanAction(&quot;isMaximizable&quot;) {
1041             @Override
1042             public boolean map() {
1043                 return ((JInternalFrame) getSource()).isMaximizable();
1044             }
1045         }));
1046     }
1047 
1048     /**
1049      * Maps {@code JInternalFrame.isMaximum()} through queue
1050      */
1051     public boolean isMaximum() {
1052         return (runMapping(new MapBooleanAction(&quot;isMaximum&quot;) {
1053             @Override
1054             public boolean map() {
1055                 return ((JInternalFrame) getSource()).isMaximum();
1056             }
1057         }));
1058     }
1059 
1060     /**
1061      * Maps {@code JInternalFrame.isResizable()} through queue
1062      */
1063     public boolean isResizable() {
1064         return (runMapping(new MapBooleanAction(&quot;isResizable&quot;) {
1065             @Override
1066             public boolean map() {
1067                 return ((JInternalFrame) getSource()).isResizable();
1068             }
1069         }));
1070     }
1071 
1072     /**
1073      * Maps {@code JInternalFrame.isSelected()} through queue
1074      */
1075     public boolean isSelected() {
1076         return (runMapping(new MapBooleanAction(&quot;isSelected&quot;) {
1077             @Override
1078             public boolean map() {
1079                 return ((JInternalFrame) getSource()).isSelected();
1080             }
1081         }));
1082     }
1083 
1084     /**
1085      * Maps {@code JInternalFrame.moveToBack()} through queue
1086      */
1087     public void moveToBack() {
1088         runMapping(new MapVoidAction(&quot;moveToBack&quot;) {
1089             @Override
1090             public void map() {
1091                 ((JInternalFrame) getSource()).moveToBack();
1092             }
1093         });
1094     }
1095 
1096     /**
1097      * Maps {@code JInternalFrame.moveToFront()} through queue
1098      */
1099     public void moveToFront() {
1100         runMapping(new MapVoidAction(&quot;moveToFront&quot;) {
1101             @Override
1102             public void map() {
1103                 ((JInternalFrame) getSource()).moveToFront();
1104             }
1105         });
1106     }
1107 
1108     /**
1109      * Maps {@code JInternalFrame.pack()} through queue
1110      */
1111     public void pack() {
1112         runMapping(new MapVoidAction(&quot;pack&quot;) {
1113             @Override
1114             public void map() {
1115                 ((JInternalFrame) getSource()).pack();
1116             }
1117         });
1118     }
1119 
1120     /**
1121      * Maps
1122      * {@code JInternalFrame.removeInternalFrameListener(InternalFrameListener)}
1123      * through queue
1124      */
1125     public void removeInternalFrameListener(final InternalFrameListener internalFrameListener) {
1126         runMapping(new MapVoidAction(&quot;removeInternalFrameListener&quot;) {
1127             @Override
1128             public void map() {
1129                 ((JInternalFrame) getSource()).removeInternalFrameListener(internalFrameListener);
1130             }
1131         });
1132     }
1133 
1134     /**
1135      * Maps {@code JInternalFrame.setClosable(boolean)} through queue
1136      */
1137     public void setClosable(final boolean b) {
1138         runMapping(new MapVoidAction(&quot;setClosable&quot;) {
1139             @Override
1140             public void map() {
1141                 ((JInternalFrame) getSource()).setClosable(b);
1142             }
1143         });
1144     }
1145 
1146     /**
1147      * Maps {@code JInternalFrame.setClosed(boolean)} through queue
1148      */
1149     public void setClosed(final boolean b) {
1150         runMapping(new MapVoidAction(&quot;setClosed&quot;) {
1151             @Override
1152             public void map() throws PropertyVetoException {
1153                 ((JInternalFrame) getSource()).setClosed(b);
1154             }
1155         });
1156     }
1157 
1158     /**
1159      * Maps {@code JInternalFrame.setContentPane(Container)} through queue
1160      */
1161     public void setContentPane(final Container container) {
1162         runMapping(new MapVoidAction(&quot;setContentPane&quot;) {
1163             @Override
1164             public void map() {
1165                 ((JInternalFrame) getSource()).setContentPane(container);
1166             }
1167         });
1168     }
1169 
1170     /**
1171      * Maps {@code JInternalFrame.setDefaultCloseOperation(int)} through queue
1172      */
1173     public void setDefaultCloseOperation(final int i) {
1174         runMapping(new MapVoidAction(&quot;setDefaultCloseOperation&quot;) {
1175             @Override
1176             public void map() {
1177                 ((JInternalFrame) getSource()).setDefaultCloseOperation(i);
1178             }
1179         });
1180     }
1181 
1182     /**
1183      * Maps {@code JInternalFrame.setDesktopIcon(JDesktopIcon)} through queue
1184      */
1185     public void setDesktopIcon(final JDesktopIcon jDesktopIcon) {
1186         runMapping(new MapVoidAction(&quot;setDesktopIcon&quot;) {
1187             @Override
1188             public void map() {
1189                 ((JInternalFrame) getSource()).setDesktopIcon(jDesktopIcon);
1190             }
1191         });
1192     }
1193 
1194     /**
1195      * Maps {@code JInternalFrame.setFrameIcon(Icon)} through queue
1196      */
1197     public void setFrameIcon(final Icon icon) {
1198         runMapping(new MapVoidAction(&quot;setFrameIcon&quot;) {
1199             @Override
1200             public void map() {
1201                 ((JInternalFrame) getSource()).setFrameIcon(icon);
1202             }
1203         });
1204     }
1205 
1206     /**
1207      * Maps {@code JInternalFrame.setGlassPane(Component)} through queue
1208      */
1209     public void setGlassPane(final Component component) {
1210         runMapping(new MapVoidAction(&quot;setGlassPane&quot;) {
1211             @Override
1212             public void map() {
1213                 ((JInternalFrame) getSource()).setGlassPane(component);
1214             }
1215         });
1216     }
1217 
1218     /**
1219      * Maps {@code JInternalFrame.setIcon(boolean)} through queue
1220      */
1221     public void setIcon(final boolean b) {
1222         runMapping(new MapVoidAction(&quot;setIcon&quot;) {
1223             @Override
1224             public void map() throws PropertyVetoException {
1225                 ((JInternalFrame) getSource()).setIcon(b);
1226             }
1227         });
1228     }
1229 
1230     /**
1231      * Maps {@code JInternalFrame.setIconifiable(boolean)} through queue
1232      */
1233     public void setIconifiable(final boolean b) {
1234         runMapping(new MapVoidAction(&quot;setIconifiable&quot;) {
1235             @Override
1236             public void map() {
1237                 ((JInternalFrame) getSource()).setIconifiable(b);
1238             }
1239         });
1240     }
1241 
1242     /**
1243      * Maps {@code JInternalFrame.setJMenuBar(JMenuBar)} through queue
1244      */
1245     public void setJMenuBar(final JMenuBar jMenuBar) {
1246         runMapping(new MapVoidAction(&quot;setJMenuBar&quot;) {
1247             @Override
1248             public void map() {
1249                 ((JInternalFrame) getSource()).setJMenuBar(jMenuBar);
1250             }
1251         });
1252     }
1253 
1254     /**
1255      * Maps {@code JInternalFrame.setLayer(Integer)} through queue
1256      */
1257     public void setLayer(final Integer integer) {
1258         runMapping(new MapVoidAction(&quot;setLayer&quot;) {
1259             @Override
1260             public void map() {
1261                 ((JInternalFrame) getSource()).setLayer(integer);
1262             }
1263         });
1264     }
1265 
1266     /**
1267      * Maps {@code JInternalFrame.setLayeredPane(JLayeredPane)} through queue
1268      */
1269     public void setLayeredPane(final JLayeredPane jLayeredPane) {
1270         runMapping(new MapVoidAction(&quot;setLayeredPane&quot;) {
1271             @Override
1272             public void map() {
1273                 ((JInternalFrame) getSource()).setLayeredPane(jLayeredPane);
1274             }
1275         });
1276     }
1277 
1278     /**
1279      * Maps {@code JInternalFrame.setMaximizable(boolean)} through queue
1280      */
1281     public void setMaximizable(final boolean b) {
1282         runMapping(new MapVoidAction(&quot;setMaximizable&quot;) {
1283             @Override
1284             public void map() {
1285                 ((JInternalFrame) getSource()).setMaximizable(b);
1286             }
1287         });
1288     }
1289 
1290     /**
1291      * Maps {@code JInternalFrame.setMaximum(boolean)} through queue
1292      */
1293     public void setMaximum(final boolean b) {
1294         runMapping(new MapVoidAction(&quot;setMaximum&quot;) {
1295             @Override
1296             public void map() throws PropertyVetoException {
1297                 ((JInternalFrame) getSource()).setMaximum(b);
1298             }
1299         });
1300     }
1301 
1302     /**
1303      * Maps {@code JInternalFrame.setResizable(boolean)} through queue
1304      */
1305     public void setResizable(final boolean b) {
1306         runMapping(new MapVoidAction(&quot;setResizable&quot;) {
1307             @Override
1308             public void map() {
1309                 ((JInternalFrame) getSource()).setResizable(b);
1310             }
1311         });
1312     }
1313 
1314     /**
1315      * Maps {@code JInternalFrame.setSelected(boolean)} through queue
1316      */
1317     public void setSelected(final boolean b) {
1318         runMapping(new MapVoidAction(&quot;setSelected&quot;) {
1319             @Override
1320             public void map() throws PropertyVetoException {
1321                 ((JInternalFrame) getSource()).setSelected(b);
1322             }
1323         });
1324     }
1325 
1326     /**
1327      * Maps {@code JInternalFrame.setTitle(String)} through queue
1328      */
1329     public void setTitle(final String string) {
1330         runMapping(new MapVoidAction(&quot;setTitle&quot;) {
1331             @Override
1332             public void map() {
1333                 ((JInternalFrame) getSource()).setTitle(string);
1334             }
1335         });
1336     }
1337 
1338     /**
1339      * Maps {@code JInternalFrame.setUI(InternalFrameUI)} through queue
1340      */
1341     public void setUI(final InternalFrameUI internalFrameUI) {
1342         runMapping(new MapVoidAction(&quot;setUI&quot;) {
1343             @Override
1344             public void map() {
1345                 ((JInternalFrame) getSource()).setUI(internalFrameUI);
1346             }
1347         });
1348     }
1349 
1350     /**
1351      * Maps {@code JInternalFrame.toBack()} through queue
1352      */
1353     public void toBack() {
1354         runMapping(new MapVoidAction(&quot;toBack&quot;) {
1355             @Override
1356             public void map() {
1357                 ((JInternalFrame) getSource()).toBack();
1358             }
1359         });
1360     }
1361 
1362     /**
1363      * Maps {@code JInternalFrame.toFront()} through queue
1364      */
1365     public void toFront() {
1366         runMapping(new MapVoidAction(&quot;toFront&quot;) {
1367             @Override
1368             public void map() {
1369                 ((JInternalFrame) getSource()).toFront();
1370             }
1371         });
1372     }
1373 
1374     //End of mapping                                      //
1375     ////////////////////////////////////////////////////////
1376     /**
1377      * Uses InternalframeDriver to get a title pane.
1378      *
1379      * @return a title pane.
1380      */
1381     protected Container findTitlePane() {
1382         return (Container) iDriver.getTitlePane(this);
1383     }
1384 
1385     /**
1386      * Initialize icon operator
1387      */
1388     protected void initIconOperator() {
1389         iconOperator = new JDesktopIconOperator(((JInternalFrame) getSource()).getDesktopIcon());
1390         iconOperator.copyEnvironment(this);
1391     }
1392 
1393     /**
1394      * Initiaites suboperators.
1395      */
1396     protected void initOperators() {
1397         initIconOperator();
1398         if(Platform.isOSX()) {
1399             throw new UnsupportedOperationException(
1400                     &quot;Jemmy doesn&#39;t support getting or initializing title&quot;
1401                     + &quot; related operators on Mac OSx&quot;);
1402         } else {
1403             Container titlePane = findTitlePane();
1404             if (!isIcon() &amp;&amp; titlePane != null) {
1405                 if (titleOperator == null) {
1406                     titleOperator = new ContainerOperator&lt;&gt;(titlePane);
1407                     if (getContainer(new ComponentChooser() {
1408                         @Override
1409                         public boolean checkComponent(Component comp) {
1410                             return comp instanceof JDesktopPane;
1411                         }
1412 
1413                     @Override
1414                     public String getDescription() {
1415                         return &quot;Desktop pane&quot;;
1416                     }
1417 
1418                     @Override
1419                     public String toString() {
1420                         return &quot;JInternalFrameOperator.initOperators.ComponentChooser{description = &quot; + getDescription() + &#39;}&#39;;
1421                     }
1422                 }) != null) {
1423                     if(LookAndFeel.isMotif()) {
1424                         popupButtonOper = new JButtonOperator(titleOperator, 0);
1425                     } else {
1426                         minOper = new JButtonOperator(titleOperator,
1427                             new JComponentByTipFinder(MINIMIZE_BUTTON_TOOLTIP));
1428                         if (((JInternalFrame) getSource()).isMaximizable()) {
1429                             maxOper = new JButtonOperator(titleOperator,
1430                                 new JComponentByTipFinder(MAXIMIZE_BUTTON_TOOLTIP));
1431                         } else {
1432                             maxOper = null;
1433                         }
1434                     }
1435                 } else {
1436                     minOper = null;
1437                     maxOper = null;
1438                 }
1439                 if (isClosable()) {
1440                     if(!LookAndFeel.isMotif()) {
1441                         closeOper = new JButtonOperator(titleOperator,
1442                             new JComponentByTipFinder(CLOSE_BUTTON_TOOLTIP));
1443                     }
1444                 } else {
1445                     closeOper = null;
1446                 }
1447             }
1448         } else {
1449             titleOperator = null;
1450             minOper = null;
1451             maxOper = null;
1452             closeOper = null;
1453             }
1454         }
1455     }
1456 
1457     //throw exception if state is wrong
1458     private void checkIconified(boolean shouldBeIconified) {
1459         if (shouldBeIconified &amp;&amp; !isIcon()
1460                 || !shouldBeIconified &amp;&amp; isIcon()) {
1461             throw (new WrongInternalFrameStateException(&quot;JInternal frame should &quot;
1462                     + (shouldBeIconified ? &quot;&quot; : &quot;not&quot;)
1463                     + &quot; be iconified to produce this operation&quot;,
1464                     getSource()));
1465         }
1466     }
1467 
1468     private static JInternalFrame findOne(ContainerOperator&lt;?&gt; cont, String text, int index) {
1469         Component source = waitComponent(cont,
1470                 new JInternalFrameByTitleFinder(text,
1471                         cont.getComparator()),
1472                 index);
1473         if (source instanceof JInternalFrame) {
1474             return (JInternalFrame) source;
1475         } else if (source instanceof JInternalFrame.JDesktopIcon) {
1476             return ((JInternalFrame.JDesktopIcon) source).getInternalFrame();
1477         } else {
1478             throw (new TimeoutExpiredException(&quot;No internal frame was found&quot;));
1479         }
1480     }
1481 
1482     /**
1483      * Exception can be throwht if as a result of an attempt to produce
1484      * operation for the frame in incorrect state. Like activate iconified
1485      * frame, for example.
1486      */
1487     public static class WrongInternalFrameStateException extends JemmyInputException {
1488 
1489         private static final long serialVersionUID = 42L;
1490 
1491         /**
1492          * Constructs a JInternalFrameOperator$WrongInternalFrameStateException
1493          * object.
1494          *
1495          * @param message an exception message.
1496          * @param comp an internal frame.
1497          */
1498         public WrongInternalFrameStateException(String message, Component comp) {
1499             super(message, comp);
1500         }
1501     }
1502 
1503     /**
1504      * Allows to find component by title.
1505      */
1506     public static class JInternalFrameByTitleFinder implements ComponentChooser {
1507 
1508         String label;
1509         StringComparator comparator;
1510 
1511         /**
1512          * Constructs JInternalFrameByTitleFinder.
1513          *
1514          * @param lb a text pattern
1515          * @param comparator specifies string comparision algorithm.
1516          */
1517         public JInternalFrameByTitleFinder(String lb, StringComparator comparator) {
1518             label = lb;
1519             this.comparator = comparator;
1520         }
1521 
1522         /**
1523          * Constructs JInternalFrameByTitleFinder.
1524          *
1525          * @param lb a text pattern
1526          */
1527         public JInternalFrameByTitleFinder(String lb) {
1528             this(lb, Operator.getDefaultStringComparator());
1529         }
1530 
1531         @Override
1532         public boolean checkComponent(Component comp) {
1533             if (comp instanceof JInternalFrame || comp instanceof JInternalFrame.JDesktopIcon) {
1534                 JInternalFrame frame = null;
1535                 if (comp instanceof JInternalFrame) {
1536                     frame = (JInternalFrame) comp;
1537                 } else {
1538                     JDesktopIconOperator io = new JDesktopIconOperator((JInternalFrame.JDesktopIcon) comp);
1539                     frame = io.getInternalFrame();
1540                 }
1541                 if (frame.getTitle() != null) {
1542                     return (comparator.equals(frame.getTitle(),
1543                             label));
1544                 }
1545             }
1546             return false;
1547         }
1548 
1549         @Override
1550         public String getDescription() {
1551             return &quot;JInternalFrame with title \&quot;&quot; + label + &quot;\&quot;&quot;;
1552         }
1553 
1554         @Override
1555         public String toString() {
1556             return &quot;JInternalFrameByTitleFinder{&quot; + &quot;label=&quot; + label + &quot;, comparator=&quot; + comparator + &#39;}&#39;;
1557         }
1558     }
1559 
1560     /**
1561      * Class to operate with javax.swing.JInternalFrame.JDesktopIconOperator
1562      * component.
1563      */
1564     public static class JDesktopIconOperator extends JComponentOperator
1565             implements Outputable, Timeoutable {
1566 
1567         private TestOut output;
1568         private Timeouts timeouts;
1569 
1570         /**
1571          * Constructs JDesktopIconOperator.
1572          *
1573          * @param b a component
1574          */
1575         public JDesktopIconOperator(JInternalFrame.JDesktopIcon b) {
1576             super(b);
1577             setOutput(JemmyProperties.getCurrentOutput());
1578             setTimeouts(JemmyProperties.getCurrentTimeouts());
1579         }
1580 
1581         @Override
1582         public void setOutput(TestOut out) {
1583             output = out;
1584             super.setOutput(output.createErrorOutput());
1585         }
1586 
1587         @Override
1588         public TestOut getOutput() {
1589             return output;
1590         }
1591 
1592         @Override
1593         public void setTimeouts(Timeouts times) {
1594             timeouts = times;
1595             super.setTimeouts(timeouts);
1596         }
1597 
1598         @Override
1599         public Timeouts getTimeouts() {
1600             return timeouts;
1601         }
1602 
1603         /**
1604          * Creates an operator for the correspondent internal frame.
1605          *
1606          * @return an operator.
1607          */
1608         public JInternalFrame getInternalFrame() {
1609             return (runMapping(new MapAction&lt;JInternalFrame&gt;(&quot;getInternalFrame&quot;) {
1610                 @Override
1611                 public JInternalFrame map() {
1612                     return ((JInternalFrame.JDesktopIcon) getSource()).getInternalFrame();
1613                 }
1614             }));
1615         }
1616 
1617         /**
1618          * Pushs the deiconifying button.
1619          */
1620         public void pushButton() {
1621             this.clickMouse(2);
1622         }
1623     }
1624 
1625     /**
1626      * Checks component type.
1627      */
1628     public static class JInternalFrameFinder implements ComponentChooser {
1629 
1630         ComponentChooser sf = null;
1631 
1632         /**
1633          * Constructs JInternalFrameFinder.
1634          *
1635          * @param sf other searching criteria.
1636          */
1637         public JInternalFrameFinder(ComponentChooser sf) {
1638             this.sf = sf;
1639         }
1640 
1641         /**
1642          * Constructs JInternalFrameFinder.
1643          */
1644         public JInternalFrameFinder() {
1645             this(ComponentSearcher.getTrueChooser(&quot;JInternalFrame or JInternalFrame.JDesktopIcon&quot;));
1646         }
1647 
1648         @Override
1649         public boolean checkComponent(Component comp) {
1650             return ((comp instanceof JInternalFrame || comp instanceof JInternalFrame.JDesktopIcon)
1651                     &amp;&amp; sf.checkComponent(comp));
1652         }
1653 
1654         @Override
1655         public String getDescription() {
1656             return sf.getDescription();
1657         }
1658 
1659         @Override
1660         public String toString() {
1661             return &quot;JInternalFrameFinder{&quot; + &quot;sf=&quot; + sf + &#39;}&#39;;
1662         }
1663     }
1664 
1665 }
    </pre>
  </body>
</html>
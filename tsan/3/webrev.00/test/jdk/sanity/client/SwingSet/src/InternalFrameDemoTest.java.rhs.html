<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames test/jdk/sanity/client/SwingSet/src/InternalFrameDemoTest.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (c) 2018, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 import static com.sun.swingset3.demos.internalframe.InternalFrameDemo.CLOSABLE_LABEL;
 25 import static com.sun.swingset3.demos.internalframe.InternalFrameDemo.DEMO_TITLE;
 26 import static com.sun.swingset3.demos.internalframe.InternalFrameDemo.FRAME0_X;
 27 import static com.sun.swingset3.demos.internalframe.InternalFrameDemo.FRAME0_Y;
 28 import static com.sun.swingset3.demos.internalframe.InternalFrameDemo.FRAME_GAP;
 29 import static com.sun.swingset3.demos.internalframe.InternalFrameDemo.FRAME_HEIGHT;
 30 import static com.sun.swingset3.demos.internalframe.InternalFrameDemo.FRAME_WIDTH;
 31 import static com.sun.swingset3.demos.internalframe.InternalFrameDemo.ICONIFIABLE_LABEL;
 32 import static com.sun.swingset3.demos.internalframe.InternalFrameDemo.INTERNAL_FRAME_LABEL;
 33 import static com.sun.swingset3.demos.internalframe.InternalFrameDemo.MAXIMIZABLE_LABEL;
 34 import static com.sun.swingset3.demos.internalframe.InternalFrameDemo.PALETTE_HEIGHT;
 35 import static com.sun.swingset3.demos.internalframe.InternalFrameDemo.PALETTE_LABEL;
 36 import static com.sun.swingset3.demos.internalframe.InternalFrameDemo.PALETTE_WIDTH;
 37 import static com.sun.swingset3.demos.internalframe.InternalFrameDemo.PALETTE_X;
 38 import static com.sun.swingset3.demos.internalframe.InternalFrameDemo.PALETTE_Y;
 39 import static com.sun.swingset3.demos.internalframe.InternalFrameDemo.RESIZABLE_LABEL;
 40 import static org.jemmy2ext.JemmyExt.EXACT_STRING_COMPARATOR;
 41 import static org.testng.AssertJUnit.assertFalse;
 42 
 43 import java.awt.Dimension;
 44 import java.awt.Point;
 45 
 46 import javax.swing.JDesktopPane;
 47 import javax.swing.JInternalFrame;
 48 import javax.swing.UIManager;
 49 
 50 import org.jemmy2ext.JemmyExt;
 51 import org.jtregext.GuiTestListener;
 52 import org.netbeans.jemmy.ClassReference;
 53 import org.netbeans.jemmy.JemmyProperties;
 54 import org.netbeans.jemmy.operators.ComponentOperator;
 55 import org.netbeans.jemmy.operators.JButtonOperator;
 56 import org.netbeans.jemmy.operators.JCheckBoxOperator;
 57 import org.netbeans.jemmy.operators.JFrameOperator;
 58 import org.netbeans.jemmy.operators.JInternalFrameOperator;
 59 import org.netbeans.jemmy.operators.JTextFieldOperator;
 60 import org.testng.annotations.Listeners;
 61 import org.testng.annotations.Test;
 62 
 63 import com.sun.swingset3.demos.internalframe.InternalFrameDemo;
 64 
 65 /*
 66  * @test
<a name="1" id="anc1"></a><span class="line-added"> 67  * @bug 8211703</span>
 68  * @key headful
 69  * @summary Verifies SwingSet3 InternalFrameDemo page by checking the different
 70  *  actions on the parent frame, internal frame and creating internal frame
 71  *  with different properties
 72  *
 73  * @library /sanity/client/lib/jemmy/src
 74  * @library /sanity/client/lib/Extensions/src
 75  * @library /sanity/client/lib/SwingSet3/src
 76  * @modules java.desktop
 77  *          java.logging
 78  * @build org.jemmy2ext.JemmyExt
 79  * @build com.sun.swingset3.demos.internalframe.InternalFrameDemo
 80  * @run testng/timeout=600 InternalFrameDemoTest
 81  */
 82 @Listeners(GuiTestListener.class)
 83 public class InternalFrameDemoTest {
 84 
 85     private final static int PARENT_FRAME_NEW_SIZE_DELTA = 300;
 86     private final static int PARENT_FRAME_NEW_LOCATION_DELTA = 200;
 87     private final static Dimension INTERNAL_FRAME_NEW_SIZE = new Dimension(400, 400);
 88     private final static Point INTERNAL_FRAME_NEW_LOCATION = new Point(390, 120);
 89     private final static int DELAY = 500;
 90     private final static String INTERNAL_FRAME_NEW_NAME = &quot;New Internal Frame&quot;;
 91 
 92     /**
 93      * Testing the different actions on the parent frame, internal frame and
 94      * creating internal frame with different properties
 95      *
 96      * @throws Exception
 97      */
 98     @Test(dataProvider = &quot;availableLookAndFeels&quot;, dataProviderClass = TestHelpers.class)
 99     public void test(String lookAndFeel) throws Exception {
100         UIManager.setLookAndFeel(lookAndFeel);
101         // initializing internal frame driver for each L&amp;F
102         JemmyProperties.setCurrentDispatchingModel(
103                 JemmyProperties.getCurrentDispatchingModel());
104 
105         new ClassReference(InternalFrameDemo.class.getCanonicalName()).startApplication();
106 
107         JFrameOperator frameOperator = new JFrameOperator(DEMO_TITLE);
108         frameOperator.setComparator(EXACT_STRING_COMPARATOR);
109         frameOperator.setVerification(true);
110 
111         // verifying internal frame primary properties
112         JInternalFrameOperator internalFrameOperator = new JInternalFrameOperator(
113                 frameOperator, getInternalFrameName(INTERNAL_FRAME_LABEL, 0));
114         internalFrameOperator.setVerification(true);
115         checkInternalFramePrimaryProps(internalFrameOperator,
116                 new Point(FRAME0_X, FRAME0_Y), new Dimension(FRAME_WIDTH, FRAME_HEIGHT));
117 
118         // Verifying the internal frame properties after doing different
119         // actions on parent frame
120         checkParentFrameAction(frameOperator, internalFrameOperator);
121 
122         // Verifying different actions on the internal frame
123         checkInternalFrameAction(internalFrameOperator);
124 
125         // Creating internal frames with different action properties
126         // and verifying their properties
127         checkPaletteFrameAction(frameOperator);
128     }
129 
130     /**
131      * Verifying the internal frame properties after doing different actions on
132      * parent frame, it should not affect internal frame.
133      *
134      * @param parentFrameOperator : parent fame operator
135      * @param internalFrameOperator : internal fame operator
136      * @throws InterruptedException
137      */
138     private void checkParentFrameAction(JFrameOperator parentFrameOperator,
139             JInternalFrameOperator internalFrameOperator) throws InterruptedException {
140 
141         // Resizing the parent frame and verifying the size of the internal
142         // frame(it should not be resized)
143         Dimension orignalSize = parentFrameOperator.getSize();
144         Dimension newSize = new Dimension(orignalSize.width - PARENT_FRAME_NEW_SIZE_DELTA,
145                 orignalSize.height - PARENT_FRAME_NEW_SIZE_DELTA);
146         parentFrameOperator.resize(newSize.width, newSize.height);
147         parentFrameOperator.waitComponentSize(newSize);
148         // TODO This is a workaround for JDK-8210638, this delay has to remove
149         // after fixing this bug, this is an unstable code.
150         TestHelpers.delayBetweenFrameStateChange();
151         // keeping some delay before checking the internal frame property
152         // as it is a negative scenario
153         Thread.sleep(DELAY);
154         internalFrameOperator.waitComponentSize(new Dimension(FRAME_WIDTH, FRAME_HEIGHT));
155         // Resizing parent frame back to original size
156         parentFrameOperator.resize(orignalSize.width, orignalSize.height);
157         parentFrameOperator.waitComponentSize(orignalSize);
158         // TODO This is a workaround for JDK-8210638, this delay has to remove
159         // after fixing this bug, this is an unstable code.
160         TestHelpers.delayBetweenFrameStateChange();
161 
162         // Iconifying the parent frame and verifying the iconified status of the internal
163         // frame(it should not be iconified)
164         parentFrameOperator.iconify();
165         // TODO This is a workaround for JDK-8210638, this delay has to remove
166         // after fixing this bug, this is an unstable code.
167         TestHelpers.delayBetweenFrameStateChange();
168         // keeping some delay before checking the internal frame property
169         // as it is a negative scenario
170         Thread.sleep(DELAY);
171         assertFalse(&quot;Internal Frame should not be iconified when parent frame&quot;
172                 + &quot; alone is iconified.&quot;, internalFrameOperator.isIcon());
173         parentFrameOperator.deiconify();
174         // TODO This is a workaround for JDK-8210638, this delay has to remove
175         // after fixing this bug, this is an unstable code.
176         TestHelpers.delayBetweenFrameStateChange();
177 
178         // Maximizing the parent frame and verifying the maximized status of the internal
179         // frame(it should not be maximized)
180         parentFrameOperator.maximize();
181         // TODO This is a workaround for JDK-8210638, this delay has to remove
182         // after fixing this bug, this is an unstable code.
183         TestHelpers.delayBetweenFrameStateChange();
184         // keeping some delay before checking the internal frame property
185         // as it is a negative scenario
186         Thread.sleep(DELAY);
187         assertFalse(&quot;Internal Frame should not be maximized when parent frame&quot;
188                 + &quot; alone is maximized.&quot;, internalFrameOperator.isMaximum());
189         parentFrameOperator.demaximize();
190         // TODO This is a workaround for JDK-8210638, this delay has to remove
191         // after fixing this bug, this is an unstable code.
192         TestHelpers.delayBetweenFrameStateChange();
193 
194         // Relocating the parent frame and verifying the location of the internal
195         // frame(it should not be changed the location)
196         Point orignalLocation = parentFrameOperator.getLocation();
197         Point newLocation = new Point((orignalLocation.x - PARENT_FRAME_NEW_LOCATION_DELTA),
198                 (orignalLocation.y + PARENT_FRAME_NEW_LOCATION_DELTA));
199         parentFrameOperator.move(newLocation.x, newLocation.y);
200         parentFrameOperator.waitComponentLocation(newLocation);
201         // TODO This is a workaround for JDK-8210638, this delay has to remove
202         // after fixing this bug, this is an unstable code.
203         TestHelpers.delayBetweenFrameStateChange();
204         // keeping some delay before checking the internal frame property
205         // as it is a negative scenario
206         Thread.sleep(DELAY);
207         internalFrameOperator.waitComponentLocation(new Point(FRAME0_X, FRAME0_Y));
208         // Moving back parent frame to original location
209         parentFrameOperator.move(orignalLocation.x, orignalLocation.y);
210         parentFrameOperator.waitComponentLocation(orignalLocation);
211         // TODO This is a workaround for JDK-8210638, this delay has to remove
212         // after fixing this bug, this is an unstable code.
213         TestHelpers.delayBetweenFrameStateChange();
214     }
215 
216     /**
217      * Verifying different actions on the internal frame.
218      *
219      * @param internalFrameOperator : internal fame operator
220      * @throws InterruptedException
221      */
222     private void checkInternalFrameAction(JInternalFrameOperator
223             internalFrameOperator) throws InterruptedException {
224         // Verifying maximize and demaximize actions
225         internalFrameOperator.waitStateOnQueue(comp
226                 -&gt; ((JInternalFrame)comp).isMaximizable());
227         internalFrameOperator.maximize();
228         internalFrameOperator.demaximize();
229 
230         // Verifying iconify and deiconify actions
231         internalFrameOperator.waitStateOnQueue(comp
232                 -&gt; ((JInternalFrame)comp).isIconifiable());
233         internalFrameOperator.iconify();
234         internalFrameOperator.deiconify();
235 
236         // Verifying resize action
237         internalFrameOperator.waitStateOnQueue(comp
238                 -&gt; ((JInternalFrame)comp).isResizable());
239         TestHelpers.checkChangeSize(internalFrameOperator,
240                 INTERNAL_FRAME_NEW_SIZE);
241 
242         // Verifying move action
243         TestHelpers.checkChangeLocation(internalFrameOperator,
244                 INTERNAL_FRAME_NEW_LOCATION);
245 
246         // Verifying close action
247         internalFrameOperator.waitStateOnQueue(comp
248                 -&gt; ((JInternalFrame)comp).isClosable());
249         internalFrameOperator.close();
250     }
251 
252     /**
253      * Creating internal frames with different action properties and verifying
254      * their properties
255      *
256      * @param frameOperator : parent frame operator
257      */
258     private void checkPaletteFrameAction(JFrameOperator frameOperator) {
259         // Getting palette frame and checking the properties of it
260         JInternalFrameOperator paletteFrameOperator =
261                 new JInternalFrameOperator(frameOperator, PALETTE_LABEL);
262         paletteFrameOperator.setComparator(EXACT_STRING_COMPARATOR);
263         checkInternalFramePrimaryProps(paletteFrameOperator,
264                 new Point(PALETTE_X, PALETTE_Y),
265                 new Dimension(PALETTE_WIDTH, PALETTE_HEIGHT));
266 
267         // Getting all check boxes to set/reset frame properties
268         JCheckBoxOperator closableOperator =
269                 new JCheckBoxOperator(paletteFrameOperator, CLOSABLE_LABEL);
270         JCheckBoxOperator iconifiableOperator =
271                 new JCheckBoxOperator(paletteFrameOperator, ICONIFIABLE_LABEL);
272         JCheckBoxOperator maximizableOperator =
273                 new JCheckBoxOperator(paletteFrameOperator, MAXIMIZABLE_LABEL);
274         JCheckBoxOperator resizableOperator =
275                 new JCheckBoxOperator(paletteFrameOperator, RESIZABLE_LABEL);
276         JCheckBoxOperator[] checkBoxes = {closableOperator, iconifiableOperator,
277                 maximizableOperator, resizableOperator};
278 
279         // Verifying internal frame with all action properties set to false
280         checkFrameProps(frameOperator, paletteFrameOperator,
281                 getInternalFrameName(INTERNAL_FRAME_LABEL, 1), 1, checkBoxes, false);
282 
283         // Verifying internal frame with all action properties set to true and setting title
284         JTextFieldOperator frameTitle = new JTextFieldOperator(paletteFrameOperator);
285         frameTitle.setText(INTERNAL_FRAME_NEW_NAME);
286         checkFrameProps(frameOperator, paletteFrameOperator,
287                 getInternalFrameName(INTERNAL_FRAME_NEW_NAME), 2, checkBoxes, true);
288     }
289 
290     /**
291      * Verifying internal frame properties
292      *
293      * @param frameOperator : parent frame operator
294      * @param paletteFrameOperator : palette frame operator
295      * @param title : title of the internal frame
296      * @param index : index of the internal frame
297      * @param checkBoxes : array of check boxes
298      * @param checkBoxStatus : status of check box
299      */
300     private void checkFrameProps(JFrameOperator frameOperator,
301             JInternalFrameOperator paletteFrameOperator,
302             String title, int index, JCheckBoxOperator[] checkBoxes,
303             boolean checkBoxStatus) {
304 
305         pushCheckBoxes(checkBoxes, checkBoxStatus);
306         JButtonOperator button = new JButtonOperator(paletteFrameOperator, (index -1));
307         button.push();
308         JInternalFrameOperator internalFrameOperator =
309                 new JInternalFrameOperator(frameOperator, title);
310         int gap = FRAME_GAP * index;
311         checkInternalFramePrimaryProps(internalFrameOperator,
312                 new Point(FRAME0_X + gap, FRAME0_Y + gap),
313                 new Dimension(FRAME_WIDTH, FRAME_HEIGHT));
314         checkFrameActionProps(internalFrameOperator, checkBoxStatus);
315         ComponentOperator desktopOperator = new ComponentOperator(
316                 frameOperator, new JemmyExt.ByClassChooser(JDesktopPane.class));
317         frameOperator.waitStateOnQueue(comp -&gt; ((JDesktopPane)desktopOperator.
318                 getSource()).getAllFrames().length == index + 1);
319     }
320 
321     /**
322      * Verifying internal frame primary properties like showing status, location and size
323      * @param internalFrameOperator
324      * @param location
325      * @param size
326      */
327     private void checkInternalFramePrimaryProps(JInternalFrameOperator internalFrameOperator,
328             Point location, Dimension size) {
329         internalFrameOperator.waitComponentShowing(true);
330         internalFrameOperator.waitComponentLocation(location);
331         internalFrameOperator.waitComponentSize(size);
332     }
333 
334     /**
335      * Verifying internal frame action status
336      *
337      * @param internalFrameOperator : internal frame operator
338      * @param propertyStatus : status to check
339      */
340     private void checkFrameActionProps(JInternalFrameOperator internalFrameOperator,
341             boolean propertyStatus) {
342         internalFrameOperator.waitStateOnQueue(comp
343                 -&gt; ((JInternalFrame)comp).isClosable() == propertyStatus);
344         internalFrameOperator.waitStateOnQueue(comp
345                 -&gt; ((JInternalFrame)comp).isIconifiable() == propertyStatus);
346         internalFrameOperator.waitStateOnQueue(comp
347                 -&gt; ((JInternalFrame)comp).isMaximizable() == propertyStatus);
348         internalFrameOperator.waitStateOnQueue(comp
349                 -&gt; ((JInternalFrame)comp).isResizable() == propertyStatus);
350     }
351 
352     /**
353      * To set/reset check boxes
354      *
355      * @param checkBoxes : array of check boxes
356      * @param select : set/reset
357      */
358     private void pushCheckBoxes(JCheckBoxOperator []checkBoxes, boolean select){
359         for (JCheckBoxOperator checkBox : checkBoxes) {
360             checkBox.push();
361             checkBox.waitSelected(select);
362         }
363     }
364 
365     /**
366      * Gets the internal frame name
367      * @param frameLabel
368      * @return
369      */
370     private String getInternalFrameName(String frameLabel) {
371         return (frameLabel+ &quot;  &quot;);
372     }
373 
374     /**
375      * Gets the internal frame name
376      * @param frameLabel
377      * @param index
378      * @return
379      */
380     private String getInternalFrameName(String frameLabel, int index) {
381         return getInternalFrameName(frameLabel+ &quot; &quot; + index);
382     }
383 
384 }
<a name="2" id="anc2"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="2" type="hidden" />
</body>
</html>
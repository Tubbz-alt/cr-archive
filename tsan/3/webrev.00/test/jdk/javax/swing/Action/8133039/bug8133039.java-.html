<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old test/jdk/javax/swing/Action/8133039/bug8133039.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2015, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 import java.awt.Robot;
 25 import java.awt.event.ActionEvent;
 26 import java.awt.event.KeyEvent;
 27 import javax.swing.AbstractAction;
 28 import javax.swing.Action;
 29 import javax.swing.JComboBox;
 30 import javax.swing.JFrame;
 31 import javax.swing.JLabel;
 32 import javax.swing.KeyStroke;
 33 import javax.swing.SwingUtilities;
 34 import sun.swing.UIAction;
 35 
 36 /**
 37  * @test
 38  * @key headful
 39  * @bug 8133039
 40  * @summary Provide public API to sun.swing.UIAction#isEnabled(Object)
 41  * @modules java.desktop/sun.swing
 42  * @author Alexander Scherbatiy
 43  */
 44 public class bug8133039 {
 45 
 46     private static volatile int ACTION_PERFORMED_CALLS = 0;
 47     private static volatile int ACTION_ACCEPTED_CALLS = 0;
 48 
 49     public static void main(String[] args) throws Exception {
 50         testActionNotification();
 51         testPopupAction();
 52     }
 53 
 54     private static void testActionNotification() {
 55 
 56         KeyEvent keyEvent = new KeyEvent(new JLabel(&quot;Test&quot;), 0, 0, 0, 0, &#39;A&#39;);
 57         SenderObject rejectedSenderObject = new SenderObject();
 58         SwingUtilities.notifyAction(new TestAction(false), null, keyEvent,
 59                 rejectedSenderObject, 0);
 60 
 61         if (rejectedSenderObject.accepted) {
 62             throw new RuntimeException(&quot;The sender is incorrectly accepted!&quot;);
 63         }
 64 
 65         if (rejectedSenderObject.performed) {
 66             throw new RuntimeException(&quot;The action is incorrectly performed!&quot;);
 67         }
 68 
 69         SenderObject acceptedSenderObject = new SenderObject();
 70         SwingUtilities.notifyAction(new TestAction(true), null, keyEvent,
 71                 acceptedSenderObject, 0);
 72 
 73         if (!acceptedSenderObject.accepted) {
 74             throw new RuntimeException(&quot;The sender is not accepted!&quot;);
 75         }
 76 
 77         if (!acceptedSenderObject.performed) {
 78             throw new RuntimeException(&quot;The action is not performed!&quot;);
 79         }
 80     }
 81 
 82     private static void testPopupAction() throws Exception {
 83 
 84         SwingUtilities.invokeAndWait(bug8133039::createAndShowGUI);
 85 
 86         Robot robot = new Robot();
 87         robot.setAutoDelay(50);
 88         robot.waitForIdle();
 89 
 90         robot.keyPress(KeyEvent.VK_A);
 91         robot.keyRelease(KeyEvent.VK_A);
 92         robot.waitForIdle();
 93 
 94         if (ACTION_ACCEPTED_CALLS != 1) {
 95             throw new RuntimeException(&quot;Method accept is not invoked!&quot;);
 96         }
 97 
 98         if (ACTION_PERFORMED_CALLS != 1) {
 99             throw new RuntimeException(&quot;Method actionPerformed is not invoked!&quot;);
100         }
101 
102         robot.keyPress(KeyEvent.VK_A);
103         robot.keyRelease(KeyEvent.VK_A);
104         robot.waitForIdle();
105 
106         if (ACTION_ACCEPTED_CALLS != 2) {
107             throw new RuntimeException(&quot;Method accept is not invoked!&quot;);
108         }
109 
110         if (ACTION_PERFORMED_CALLS != 1) {
111             throw new RuntimeException(&quot;Method actionPerformed is invoked twice!&quot;);
112         }
113     }
114 
115     private static void createAndShowGUI() {
116 
117         JFrame frame = new JFrame();
118         frame.setSize(300, 300);
119         frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
120 
121         JComboBox&lt;String&gt; comboBox = new JComboBox&lt;&gt;(new String[]{&quot;1&quot;, &quot;2&quot;, &quot;3&quot;});
122 
123         Action showPopupAction = new ShowPopupAction();
124         comboBox.getInputMap().put(KeyStroke.getKeyStroke(&quot;A&quot;), &quot;showPopup&quot;);
125         comboBox.getActionMap().put(&quot;showPopup&quot;, showPopupAction);
126 
127         frame.getContentPane().add(comboBox);
128         frame.setVisible(true);
129     }
130 
131     private static class ShowPopupAction extends UIAction {
132 
133         public ShowPopupAction() {
134             super(&quot;showPopup&quot;);
135         }
136 
137         @Override
138         public void actionPerformed(ActionEvent e) {
139             ACTION_PERFORMED_CALLS++;
140             Object src = e.getSource();
141             if (src instanceof JComboBox) {
142                 ((JComboBox) src).showPopup();
143             }
144         }
145 
146         @Override
147         public boolean accept(Object sender) {
148             ACTION_ACCEPTED_CALLS++;
149             if (sender instanceof JComboBox) {
150                 JComboBox c = (JComboBox) sender;
151                 return !c.isPopupVisible();
152             }
153             return false;
154         }
155     }
156 
157     private static class SenderObject {
158 
159         private boolean accepted;
160         private boolean performed;
161     }
162 
163     private static class TestAction extends AbstractAction {
164 
165         private final boolean acceptSender;
166 
167         public TestAction(boolean acceptSender) {
168             this.acceptSender = acceptSender;
169         }
170 
171         @Override
172         public boolean accept(Object sender) {
173             ((SenderObject) sender).accepted = acceptSender;
174             return acceptSender;
175         }
176 
177         @Override
178         public void actionPerformed(ActionEvent e) {
179             ((SenderObject) e.getSource()).performed = true;
180         }
181     }
182 }
    </pre>
  </body>
</html>
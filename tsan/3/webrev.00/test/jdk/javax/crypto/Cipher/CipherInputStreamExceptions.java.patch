diff a/test/jdk/javax/crypto/Cipher/CipherInputStreamExceptions.java b/test/jdk/javax/crypto/Cipher/CipherInputStreamExceptions.java
--- a/test/jdk/javax/crypto/Cipher/CipherInputStreamExceptions.java
+++ b/test/jdk/javax/crypto/Cipher/CipherInputStreamExceptions.java
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2015, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2015, 2019, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.
@@ -53,22 +53,22 @@
     static IvParameterSpec iv = new IvParameterSpec(new byte[16]);
     static boolean failure = false;
 
     /* Full read stream, check that getMoreData() is throwing an exception
      * This test
-     *   1) Encrypt 100 bytes with AES/GCM/PKCS5Padding
+     *   1) Encrypt 100 bytes with AES/GCM/NoPadding
      *   2) Changes the last byte to invalidate the authetication tag.
      *   3) Fully reads CipherInputStream to decrypt the message and closes
      */
 
     static void gcm_AEADBadTag() throws Exception {
         Cipher c;
         byte[] read = new byte[200];
 
         System.out.println("Running gcm_AEADBadTag");
 
-        // Encrypt 100 bytes with AES/GCM/PKCS5Padding
+        // Encrypt 100 bytes with AES/GCM/NoPadding
         byte[] ct = encryptedText("GCM", 100);
         // Corrupt the encrypted message
         ct = corruptGCM(ct);
         // Create stream for decryption
         CipherInputStream in = getStream("GCM", ct);
@@ -90,11 +90,11 @@
         }
     }
 
     /* Short read stream,
      * This test
-     *   1) Encrypt 100 bytes with AES/GCM/PKCS5Padding
+     *   1) Encrypt 100 bytes with AES/GCM/NoPadding
      *   2) Reads 100 bytes from stream to decrypt the message and closes
      *   3) Make sure no value is returned by read()
      *   4) Make sure no exception is thrown
      */
 
@@ -104,11 +104,11 @@
 
         System.out.println("Running gcm_shortReadAEAD");
 
         byte[] pt = new byte[600];
         pt[0] = 1;
-        // Encrypt provided 600 bytes with AES/GCM/PKCS5Padding
+        // Encrypt provided 600 bytes with AES/GCM/NoPadding
         byte[] ct = encryptedText("GCM", pt);
         // Create stream for decryption
         CipherInputStream in = getStream("GCM", ct);
 
         int size = 0;
@@ -132,11 +132,11 @@
 
     /*
      * Verify doFinal() exception is suppressed when input stream is not
      * read before it is closed.
      * This test:
-     *   1) Encrypt 100 bytes with AES/GCM/PKCS5Padding
+     *   1) Encrypt 100 bytes with AES/GCM/NoPadding
      *   2) Changes the last byte to invalidate the authetication tag.
      *   3) Opens a CipherInputStream and the closes it. Never reads from it.
      *
      * There should be no exception thrown.
      */
@@ -144,11 +144,11 @@
         Cipher c;
         byte[] read = new byte[200];
 
         System.out.println("Running supressUnreadCorrupt test");
 
-        // Encrypt 100 bytes with AES/GCM/PKCS5Padding
+        // Encrypt 100 bytes with AES/GCM/NoPadding
         byte[] ct = encryptedText("GCM", 100);
         // Corrupt the encrypted message
         ct = corruptGCM(ct);
         // Create stream for decryption
         CipherInputStream in = getStream("GCM", ct);
@@ -164,19 +164,19 @@
 
     /*
      * Verify noexception thrown when 1 byte is read from a GCM stream
      * and then closed
      * This test:
-     *   1) Encrypt 100 bytes with AES/GCM/PKCS5Padding
+     *   1) Encrypt 100 bytes with AES/GCM/NoPadding
      *   2) Read one byte from the stream, expect no exception thrown.
      *   4) Close stream,expect no exception thrown.
      */
     static void gcm_oneReadByte() throws Exception {
 
         System.out.println("Running gcm_oneReadByte test");
 
-        // Encrypt 100 bytes with AES/GCM/PKCS5Padding
+        // Encrypt 100 bytes with AES/GCM/NoPadding
         byte[] ct = encryptedText("GCM", 100);
         // Create stream for decryption
         CipherInputStream in = getStream("GCM", ct);
 
         try {
@@ -190,20 +190,20 @@
 
     /*
      * Verify exception thrown when 1 byte is read from a corrupted GCM stream
      * and then closed
      * This test:
-     *   1) Encrypt 100 bytes with AES/GCM/PKCS5Padding
+     *   1) Encrypt 100 bytes with AES/GCM/NoPadding
      *   2) Changes the last byte to invalidate the authetication tag.
      *   3) Read one byte from the stream, expect exception thrown.
      *   4) Close stream,expect no exception thrown.
      */
     static void gcm_oneReadByteCorrupt() throws Exception {
 
         System.out.println("Running gcm_oneReadByteCorrupt test");
 
-        // Encrypt 100 bytes with AES/GCM/PKCS5Padding
+        // Encrypt 100 bytes with AES/GCM/NoPadding
         byte[] ct = encryptedText("GCM", 100);
         // Corrupt the encrypted message
         ct = corruptGCM(ct);
         // Create stream for decryption
         CipherInputStream in = getStream("GCM", ct);
@@ -355,11 +355,11 @@
 
     /* Generic method to create encrypted text */
     static byte[] encryptedText(String mode, byte[] pt) throws Exception{
         Cipher c;
         if (mode.compareTo("GCM") == 0) {
-            c = Cipher.getInstance("AES/GCM/PKCS5Padding", "SunJCE");
+            c = Cipher.getInstance("AES/GCM/NoPadding", "SunJCE");
             c.init(Cipher.ENCRYPT_MODE, key, gcmspec);
         } else if (mode.compareTo("CBC") == 0) {
             c = Cipher.getInstance("AES/CBC/PKCS5Padding", "SunJCE");
             c.init(Cipher.ENCRYPT_MODE, key, iv);
         } else {
@@ -378,11 +378,11 @@
     static CipherInputStream getStream(String mode, byte[] ct, int length)
             throws Exception {
         Cipher c;
 
         if (mode.compareTo("GCM") == 0) {
-            c = Cipher.getInstance("AES/GCM/PKCS5Padding", "SunJCE");
+            c = Cipher.getInstance("AES/GCM/NoPadding", "SunJCE");
             c.init(Cipher.DECRYPT_MODE, key, gcmspec);
         } else if (mode.compareTo("CBC") == 0) {
             c = Cipher.getInstance("AES/CBC/PKCS5Padding", "SunJCE");
             c.init(Cipher.DECRYPT_MODE, key, iv);
         } else {

<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New test/jdk/javax/sql/testng/test/rowset/spi/SyncProviderExceptionTests.java</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2014, 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 package test.rowset.spi;
 24 
 25 import com.sun.rowset.internal.SyncResolverImpl;
 26 import java.sql.SQLException;
 27 import javax.sql.rowset.spi.SyncProviderException;
 28 import javax.sql.rowset.spi.SyncResolver;
 29 
 30 import static org.testng.Assert.*;
 31 import org.testng.annotations.AfterClass;
 32 import org.testng.annotations.BeforeClass;
 33 import org.testng.annotations.BeforeMethod;
 34 import org.testng.annotations.Test;
 35 import util.BaseTest;
 36 import util.StubSyncResolver;
 37 
 38 public class SyncProviderExceptionTests extends BaseTest {
 39 
 40     // Used by SyncProviderException::getSyncResolver tests
 41     private SyncResolver resolver;
 42 
 43     @BeforeClass
 44     public static void setUpClass() throws Exception {
 45         System.out.println(System.getProperty(&quot;java.naming.factory.initial&quot;));
 46     }
 47 
 48     @AfterClass
 49     public static void tearDownClass() throws Exception {
 50     }
 51 
 52     @BeforeMethod
 53     public void setupTest() {
 54         resolver = new SyncProviderException().getSyncResolver();
 55     }
 56 
 57     /*
 58      * Create SyncProviderException with no-arg constructor
 59      */
 60     @Test
 61     public void test() {
 62         SyncProviderException ex = new SyncProviderException();
 63         assertTrue(ex.getMessage() == null
 64                 &amp;&amp; ex.getSQLState() == null
 65                 &amp;&amp; ex.getCause() == null
 66                 &amp;&amp; ex.getErrorCode() == 0
 67                 &amp;&amp; ex.getSyncResolver() instanceof SyncResolverImpl);
 68     }
 69 
 70     /*
 71      * Create SyncProviderException with no-arg constructor and
 72      * call setSyncResolver to indicate the SyncResolver to use
 73      */
 74     @Test
 75     public void test01() {
 76         SyncProviderException ex = new SyncProviderException();
 77         ex.setSyncResolver(new StubSyncResolver());
 78         assertTrue(ex.getMessage() == null
 79                 &amp;&amp; ex.getSQLState() == null
 80                 &amp;&amp; ex.getCause() == null
 81                 &amp;&amp; ex.getErrorCode() == 0
 82                 &amp;&amp; ex.getSyncResolver() instanceof StubSyncResolver);
 83     }
 84 
 85     /*
 86      * Create SyncProviderException with message
 87      */
 88     @Test
 89     public void test02() {
 90         SyncProviderException ex = new SyncProviderException(reason);
 91         assertTrue(ex.getMessage().equals(reason)
 92                 &amp;&amp; ex.getSQLState() == null
 93                 &amp;&amp; ex.getCause() == null
 94                 &amp;&amp; ex.getErrorCode() == 0
 95                 &amp;&amp; ex.getSyncResolver() instanceof SyncResolverImpl);
 96     }
 97 
 98     /*
 99      * Create SyncProviderException with message and
100      * call setSyncResolver to indicate the SyncResolver to use
101      */
102     @Test
103     public void test03() {
104         SyncProviderException ex = new SyncProviderException(reason);
105         ex.setSyncResolver(new StubSyncResolver());
106 
107         assertTrue(ex.getMessage().equals(reason)
108                 &amp;&amp; ex.getSQLState() == null
109                 &amp;&amp; ex.getCause() == null
110                 &amp;&amp; ex.getErrorCode() == 0
111                 &amp;&amp; ex.getSyncResolver() instanceof StubSyncResolver);
112     }
113 
114     /*
115      * Create SyncProviderException with and specify the SyncResolver to use
116      */
117     @Test
118     public void test04() {
119         SyncProviderException ex = new SyncProviderException(new StubSyncResolver());
120         assertTrue(ex.getMessage() == null
121                 &amp;&amp; ex.getSQLState() == null
122                 &amp;&amp; ex.getCause() == null
123                 &amp;&amp; ex.getErrorCode() == 0
124                 &amp;&amp; ex.getSyncResolver() instanceof StubSyncResolver);
125     }
126 
127     /*
128      * Validate that the ordering of the returned Exceptions is correct using
129      * for-each loop
130      */
131     @Test
132     public void test05() {
133         SyncProviderException ex = new SyncProviderException(&quot;Exception 1&quot;);
134         ex.initCause(t1);
135         SyncProviderException ex1 = new SyncProviderException(&quot;Exception 2&quot;);
136         SyncProviderException ex2 = new SyncProviderException(&quot;Exception 3&quot;);
137         ex2.initCause(t2);
138         ex.setNextException(ex1);
139         ex.setNextException(ex2);
140         int num = 0;
141         for (Throwable e : ex) {
142             assertTrue(msgs[num++].equals(e.getMessage()));
143         }
144     }
145 
146     /*
147      * Validate that the ordering of the returned Exceptions is correct using
148      * traditional while loop
149      */
150     @Test
151     public void test06() {
152         SQLException ex = new SyncProviderException(&quot;Exception 1&quot;);
153         ex.initCause(t1);
154         SyncProviderException ex1 = new SyncProviderException(&quot;Exception 2&quot;);
155         SyncProviderException ex2 = new SyncProviderException(&quot;Exception 3&quot;);
156         ex2.initCause(t2);
157         ex.setNextException(ex1);
158         ex.setNextException(ex2);
159         int num = 0;
160         while (ex != null) {
161             assertTrue(msgs[num++].equals(ex.getMessage()));
162             Throwable c = ex.getCause();
163             while (c != null) {
164                 assertTrue(msgs[num++].equals(c.getMessage()));
165                 c = c.getCause();
166             }
167             ex = ex.getNextException();
168         }
169     }
170 
171     /*
172      * Serialize a SyncProviderException and make sure you can read it back properly
173      */
174     @Test
175     public void test07() throws Exception {
176         SyncProviderException e = new SyncProviderException(reason);
177         SyncProviderException ex1 = createSerializedException(e);
178         assertTrue(ex1.getMessage().equals(reason)
179                 &amp;&amp; ex1.getSQLState() == null
180                 &amp;&amp; ex1.getCause() == null
181                 &amp;&amp; ex1.getErrorCode() == 0
182                 &amp;&amp; ex1.getSyncResolver() instanceof SyncResolverImpl, ex1.getSyncResolver().getClass().getName());
183     }
184 
185     /*
186      * Serialize a SyncProviderException and make sure you can read it back properly
187      */
188     @Test
189     public void test08() throws Exception {
190         SyncProviderException e = new SyncProviderException(reason);
191         e.setSyncResolver(new StubSyncResolver());
192 
193         SyncProviderException ex1 = createSerializedException(e);
194         assertTrue(ex1.getMessage().equals(reason)
195                 &amp;&amp; ex1.getSQLState() == null
196                 &amp;&amp; ex1.getCause() == null
197                 &amp;&amp; ex1.getErrorCode() == 0
198                 &amp;&amp; ex1.getSyncResolver() instanceof StubSyncResolver);
199     }
200 
201     /*
202      * Validate SyncResolver::getStatus() succeeds
203      */
204     @Test
205     public void testgetStatus() {
206         int status = resolver.getStatus();
207     }
208 
209     /*
210      * Validate SyncResolver::nextConflict() succeeds
211      */
212     @Test
213     public void testnextConflict() throws SQLException {
214          boolean result = resolver.nextConflict();
215     }
216 
217     /*
218      * Validate SyncResolver::previousConflict() succeeds
219      */
220     @Test
221     public void testPreviousConflict() throws SQLException {
222         boolean result =  resolver.previousConflict();
223     }
224 
225     /*
226      * Validate SyncResolver::getConflictValue() throws a SQLException
227      */
228     @Test
229     public void testConflictedValueByInt() throws SQLException {
230         assertThrows(SQLException.class, () -&gt;resolver.getConflictValue(1));
231     }
232 
233     /*
234      * Validate SyncResolver::getConflictValue() throws a SQLException
235      */
236     @Test
237     public void testConflictedValueByName() throws SQLException {
238         assertThrows(SQLException.class, () -&gt; resolver.getConflictValue(&quot;foo&quot;));
239     }
240 
241     /*
242      * Validate SyncResolver::setResolvedValue() throws a SQLException
243      */
244     @Test
245     public void testSetResolvedValueByInt() throws SQLException {
246         assertThrows(SQLException.class, () -&gt; resolver.setResolvedValue(1, &quot;foo&quot;));
247     }
248 
249     /*
250      * Validate SyncResolver::getConflictValue() throws a SQLException
251      */
252     @Test
253     public void testSetResolvedValueByName() throws SQLException {
254         assertThrows(SQLException.class, () -&gt; resolver.setResolvedValue(&quot;foo&quot;, &quot;bar&quot;));
255     }
256 }
    </pre>
  </body>
</html>
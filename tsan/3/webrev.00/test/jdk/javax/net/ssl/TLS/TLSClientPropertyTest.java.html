<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New test/jdk/javax/net/ssl/TLS/TLSClientPropertyTest.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2014, 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 /*
 25  * @test
 26  * @bug 8049432 8069038 8234723
 27  * @summary New tests for TLS property jdk.tls.client.protocols
 28  * @summary javax/net/ssl/TLS/TLSClientPropertyTest.java needs to be
 29  *     updated for JDK-8061210
 30  * @modules java.security.jgss
 31  *          java.security.jgss/sun.security.jgss.krb5
 32  *          java.security.jgss/sun.security.krb5:+open
 33  *          java.security.jgss/sun.security.krb5.internal:+open
 34  *          java.security.jgss/sun.security.krb5.internal.ccache
 35  *          java.security.jgss/sun.security.krb5.internal.crypto
 36  *          java.security.jgss/sun.security.krb5.internal.ktab
 37  *          java.base/sun.security.util
 38  * @run main/othervm TLSClientPropertyTest NoProperty
 39  * @run main/othervm TLSClientPropertyTest SSLv3
 40  * @run main/othervm TLSClientPropertyTest TLSv1
 41  * @run main/othervm TLSClientPropertyTest TLSv11
 42  * @run main/othervm TLSClientPropertyTest TLSv12
 43  * @run main/othervm TLSClientPropertyTest TLSv13
 44  * @run main/othervm TLSClientPropertyTest TLS
 45  * @run main/othervm TLSClientPropertyTest WrongProperty
 46  */
 47 
 48 import java.security.KeyManagementException;
 49 import java.security.NoSuchAlgorithmException;
 50 import java.util.Arrays;
 51 import java.util.List;
 52 import javax.net.ssl.SSLContext;
 53 
 54 /**
 55  * Sets the property jdk.tls.client.protocols to one of this protocols:
 56  * SSLv3,TLSv1,TLSv1.1,TLSv1.2 and TLSV(invalid) or removes this
 57  * property (if any),then validates the default, supported and current
 58  * protocols in the SSLContext.
 59  */
 60 public class TLSClientPropertyTest {
 61     private final String[] expectedSupportedProtos = new String[] {
 62             &quot;SSLv2Hello&quot;, &quot;SSLv3&quot;, &quot;TLSv1&quot;, &quot;TLSv1.1&quot;, &quot;TLSv1.2&quot;, &quot;TLSv1.3&quot;
 63     };
 64 
 65     public static void main(String[] args) throws Exception {
 66 
 67         if (args.length &lt; 1) {
 68             throw new RuntimeException(
 69                     &quot;Incorrect arguments,expected arguments: testCase&quot;);
 70         }
 71 
 72         String[] expectedDefaultProtos;
 73         String testCase = args[0];
 74         String contextProtocol;
 75         switch (testCase) {
 76         case &quot;NoProperty&quot;:
 77             if (System.getProperty(&quot;jdk.tls.client.protocols&quot;) != null) {
 78                 System.getProperties().remove(&quot;jdk.tls.client.protocols&quot;);
 79             }
 80             contextProtocol = null;
 81             expectedDefaultProtos = new String[] {
 82                     &quot;TLSv1&quot;, &quot;TLSv1.1&quot;, &quot;TLSv1.2&quot;, &quot;TLSv1.3&quot;
 83             };
 84             break;
 85         case &quot;SSLv3&quot;:
 86             contextProtocol = &quot;SSLv3&quot;;
 87             expectedDefaultProtos = new String[] {
 88             };
 89             break;
 90         case &quot;TLSv1&quot;:
 91             contextProtocol = &quot;TLSv1&quot;;
 92             expectedDefaultProtos = new String[] {
 93                     &quot;TLSv1&quot;
 94             };
 95             break;
 96         case &quot;TLSv11&quot;:
 97             contextProtocol = &quot;TLSv1.1&quot;;
 98             expectedDefaultProtos = new String[] {
 99                     &quot;TLSv1&quot;, &quot;TLSv1.1&quot;
100             };
101             break;
102         case &quot;TLSv12&quot;:
103             contextProtocol = &quot;TLSv1.2&quot;;
104             expectedDefaultProtos = new String[] {
105                     &quot;TLSv1&quot;, &quot;TLSv1.1&quot;, &quot;TLSv1.2&quot;
106             };
107             break;
108         case &quot;TLSv13&quot;:
109         case &quot;TLS&quot;:
110             contextProtocol = &quot;TLSv1.3&quot;;
111             expectedDefaultProtos = new String[] {
112                     &quot;TLSv1&quot;, &quot;TLSv1.1&quot;, &quot;TLSv1.2&quot;, &quot;TLSv1.3&quot;
113             };
114             break;
115         case &quot;WrongProperty&quot;:
116             expectedDefaultProtos = new String[] {};
117             contextProtocol = &quot;TLSV&quot;;
118             break;
119         default:
120             throw new RuntimeException(&quot;test case is wrong&quot;);
121         }
122         if (contextProtocol != null) {
123             System.setProperty(&quot;jdk.tls.client.protocols&quot;, contextProtocol);
124         }
125         try {
126             TLSClientPropertyTest test = new TLSClientPropertyTest();
127             test.test(contextProtocol, expectedDefaultProtos);
128             if (testCase.equals(&quot;WrongProperty&quot;)) {
129                 throw new RuntimeException(
130                         &quot;Test failed: NoSuchAlgorithmException &quot; +
131                         &quot;is expected when input wrong protocol&quot;);
132             } else {
133                 System.out.println(&quot;Test &quot; + contextProtocol + &quot; passed&quot;);
134             }
135         } catch (NoSuchAlgorithmException nsae) {
136             if (testCase.equals(&quot;WrongProperty&quot;)) {
137                 System.out.println(&quot;NoSuchAlgorithmException is expected,&quot;
138                         + contextProtocol + &quot; test passed&quot;);
139             } else {
140                 throw nsae;
141             }
142         }
143 
144     }
145 
146     /**
147      * The parameter passed is the user enforced protocol. Does not catch
148      * NoSuchAlgorithmException, WrongProperty test will use it.
149      */
150     public void test(String expectedContextProto,
151             String[] expectedDefaultProtos) throws NoSuchAlgorithmException {
152 
153         SSLContext context = null;
154         try {
155             if (expectedContextProto != null) {
156                 context = SSLContext.getInstance(expectedContextProto);
157                 context.init(null, null, null);
158             } else {
159                 context = SSLContext.getDefault();
160             }
161             printContextDetails(context);
162         } catch (KeyManagementException ex) {
163             error(null, ex);
164         }
165 
166         validateContext(expectedContextProto, expectedDefaultProtos, context);
167     }
168 
169     /**
170      * Simple print utility for SSLContext&#39;s protocol details.
171      */
172     private void printContextDetails(SSLContext context) {
173         System.out.println(&quot;Default   Protocols: &quot;
174                 + Arrays.toString(context.getDefaultSSLParameters()
175                         .getProtocols()));
176         System.out.println(&quot;Supported Protocols: &quot;
177                 + Arrays.toString(context.getSupportedSSLParameters()
178                         .getProtocols()));
179         System.out.println(&quot;Current   Protocol : &quot; + context.getProtocol());
180 
181     }
182 
183     /**
184      * Error handler.
185      */
186     private void error(String msg, Throwable tble) {
187         String finalMsg = &quot;FAILED &quot; + (msg != null ? msg : &quot;&quot;);
188         if (tble != null) {
189             throw new RuntimeException(finalMsg, tble);
190         }
191         throw new RuntimeException(finalMsg);
192     }
193 
194     /**
195      * Validates the SSLContext&#39;s protocols against the user enforced protocol.
196      */
197     private void validateContext(String expectedProto,
198             String[] expectedDefaultProtos, SSLContext context) {
199         if (expectedProto == null) {
200             expectedProto = &quot;Default&quot;;
201         }
202         if (!context.getProtocol().equals(expectedProto)) {
203             error(&quot;Invalid current protocol: &quot; + context.getProtocol()
204                     + &quot;, Expected:&quot; + expectedProto, null);
205         }
206         List&lt;String&gt; actualDefaultProtos = Arrays.asList(context
207                 .getDefaultSSLParameters().getProtocols());
208         for (String p : expectedDefaultProtos) {
209             if (!actualDefaultProtos.contains(p)) {
210                 error(&quot;Default protocol &quot; + p + &quot;missing&quot;, null);
211             }
212         }
213         List&lt;String&gt; actualSupportedProtos = Arrays.asList(context
214                 .getSupportedSSLParameters().getProtocols());
215 
216         for (String p : expectedSupportedProtos) {
217             if (!actualSupportedProtos.contains(p)) {
218                 error(&quot;Expected to support protocol:&quot; + p, null);
219             }
220         }
221     }
222 }
    </pre>
  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old test/jdk/javax/net/ssl/SSLSession/SSLCtxAccessToSessCtx.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2001, 2016, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 /*
 25  * @test
 26  * @bug 4473210
 27  * @summary SSLSessionContext should be accessible from SSLContext
 28  * @run main/othervm SSLCtxAccessToSessCtx
 29  *
 30  *     SunJSSE does not support dynamic system properties, no way to re-use
 31  *     system properties in samevm/agentvm mode.
 32  */
 33 
 34 import java.io.*;
 35 import java.net.*;
 36 import javax.net.ssl.*;
 37 import java.util.*;
 38 import java.util.concurrent.atomic.AtomicInteger;
 39 import java.security.KeyStore;
 40 
 41 public class SSLCtxAccessToSessCtx  {
 42 
 43     /*
 44      * =============================================================
 45      * Set the various variables needed for the tests, then
 46      * specify what tests to run on each side.
 47      */
 48 
 49     /*
 50      * Should we run the client or server in a separate thread?
 51      * Both sides can throw exceptions, but do you have a preference
 52      * as to which side should be the main thread.
 53      */
 54     static boolean separateServerThread = true;
 55 
 56     /*
 57      * Where do we find the keystores?
 58      */
 59     static String pathToStores = &quot;../etc&quot;;
 60     static String keyStoreFile = &quot;keystore&quot;;
 61     static String trustStoreFile = &quot;truststore&quot;;
 62     static String passwd = &quot;passphrase&quot;;
 63 
 64     /*
 65      * Is the server ready to serve?
 66      */
 67     AtomicInteger serverReady = new AtomicInteger(1);   // only one port now
 68 
 69     /*
 70      * Turn on SSL debugging?
 71      */
 72     static boolean debug = false;
 73 
 74     /*
 75      * If the client or server is doing some kind of object creation
 76      * that the other side depends on, and that thread prematurely
 77      * exits, you may experience a hang.  The test harness will
 78      * terminate all hung threads after its timeout has expired,
 79      * currently 3 minutes by default, but you might try to be
 80      * smart about it....
 81      */
 82 
 83     /*
 84      * Define the server side of the test.
 85      *
 86      * If the server prematurely exits, serverReady will be set to true
 87      * to avoid infinite hangs.
 88      */
 89     void doServerSide(int serverPort) throws Exception {
 90 
 91         SSLServerSocket sslServerSocket =
 92             (SSLServerSocket) sslssf.createServerSocket(serverPort);
 93         int slot = createdPorts.getAndIncrement();
 94         serverPorts[slot] = sslServerSocket.getLocalPort();
 95 
 96         /*
 97          * Signal Client, we&#39;re ready for his connect.
 98          */
 99         serverReady.getAndDecrement();
100         int read = 0;
101         SSLSocket sslSocket = (SSLSocket) sslServerSocket.accept();
102         InputStream sslIS = sslSocket.getInputStream();
103         OutputStream sslOS = sslSocket.getOutputStream();
104         read = sslIS.read();
105         SSLSessionContext sslctxCache = sslctx.getServerSessionContext();
106         SSLSessionContext sessCache = sslSocket.getSession().
107                                 getSessionContext();
108         if (sessCache != sslctxCache)
109             throw new Exception(&quot;Test failed, session_cache != sslctx_cache&quot;);
110         sslOS.write(85);
111         sslOS.flush();
112         sslSocket.close();
113     }
114 
115     /*
116      * Define the client side of the test.
117      *
118      * If the server prematurely exits, serverReady will be set to true
119      * to avoid infinite hangs.
120      */
121     void doClientSide() throws Exception {
122 
123         /*
124          * Wait for server to get started.
125          */
126         while (serverReady.get() &gt; 0) {
127             Thread.sleep(50);
128         }
129         /*
130          * first connection to serverPorts[0] -- a new session, session11
131          * gets created, and is cached.
132          */
133         SSLSocket sslSocket;
134         sslSocket = (SSLSocket) sslsf.
135                 createSocket(&quot;localhost&quot;, serverPorts[0]);
136         InputStream sslIS = sslSocket.getInputStream();
137         OutputStream sslOS = sslSocket.getOutputStream();
138         sslOS.write(237);
139         sslOS.flush();
140 
141         SSLSession sess = sslSocket.getSession();
142         SSLSessionContext sessCache = sess.getSessionContext();
143         SSLSessionContext sslctxCache = sslctx.getClientSessionContext();
144         if (sessCache != sslctxCache)
145             throw new Exception(&quot;Test failed, session_cache != sslctx_cache&quot;);
146 
147         int read = sslIS.read();
148         sslSocket.close();
149     }
150 
151     /*
152      * =============================================================
153      * The remainder is just support stuff
154      */
155 
156     int serverPorts[] = new int[]{0};           // only one port at present
157     AtomicInteger createdPorts = new AtomicInteger(0);
158     static SSLServerSocketFactory sslssf;
159     static SSLSocketFactory sslsf;
160     static SSLContext sslctx;
161 
162     volatile Exception serverException = null;
163     volatile Exception clientException = null;
164 
165     public static void main(String[] args) throws Exception {
166         String keyFilename =
167             System.getProperty(&quot;test.src&quot;, &quot;./&quot;) + &quot;/&quot; + pathToStores +
168                 &quot;/&quot; + keyStoreFile;
169         String trustFilename =
170             System.getProperty(&quot;test.src&quot;, &quot;./&quot;) + &quot;/&quot; + pathToStores +
171                 &quot;/&quot; + trustStoreFile;
172 
173         System.setProperty(&quot;javax.net.ssl.keyStore&quot;, keyFilename);
174         System.setProperty(&quot;javax.net.ssl.keyStorePassword&quot;, passwd);
175         System.setProperty(&quot;javax.net.ssl.trustStore&quot;, trustFilename);
176         System.setProperty(&quot;javax.net.ssl.trustStorePassword&quot;, passwd);
177 
178         sslctx = SSLContext.getInstance(&quot;TLS&quot;);
179         KeyManagerFactory kmf = KeyManagerFactory.getInstance(&quot;SunX509&quot;);
180         KeyStore ks = KeyStore.getInstance(&quot;JKS&quot;);
181         ks.load(new FileInputStream(keyFilename), passwd.toCharArray());
182         kmf.init(ks, passwd.toCharArray());
183         sslctx.init(kmf.getKeyManagers(), null, null);
184 
185         sslssf = (SSLServerSocketFactory) sslctx.getServerSocketFactory();
186         sslsf = (SSLSocketFactory) sslctx.getSocketFactory();
187 
188         if (debug)
189             System.setProperty(&quot;javax.net.debug&quot;, &quot;all&quot;);
190 
191         /*
192          * Start the tests.
193          */
194         new SSLCtxAccessToSessCtx();
195     }
196 
197     Thread clientThread = null;
198     Thread serverThread = null;
199 
200     /*
201      * Primary constructor, used to drive remainder of the test.
202      *
203      * Fork off the other side, then do your work.
204      */
205     SSLCtxAccessToSessCtx() throws Exception {
206 
207         /*
208          * create the SSLServerSocket and SSLSocket factories
209          */
210         if (separateServerThread) {
211             for (int i = 0; i &lt; serverPorts.length; i++) {
212                 startServer(serverPorts[i], true);
213             }
214             startClient(false);
215         } else {
216             startClient(true);
217             for (int i = 0; i &lt; serverPorts.length; i++) {
218                 startServer(serverPorts[i], false);
219             }
220         }
221 
222         /*
223          * Wait for other side to close down.
224          */
225         if (separateServerThread) {
226             serverThread.join();
227         } else {
228             clientThread.join();
229         }
230 
231         /*
232          * When we get here, the test is pretty much over.
233          *
234          * If the main thread excepted, that propagates back
235          * immediately.  If the other thread threw an exception, we
236          * should report back.
237          */
238         if (serverException != null)
239             throw serverException;
240         if (clientException != null)
241             throw clientException;
242         System.out.println(&quot;The Session context tests passed&quot;);
243     }
244 
245     void startServer(final int port,
246                         boolean newThread) throws Exception {
247         if (newThread) {
248             serverThread = new Thread() {
249                 public void run() {
250                     try {
251                         doServerSide(port);
252                     } catch (Exception e) {
253                         /*
254                          * Our server thread just died.
255                          *
256                          * Release the client, if not active already...
257                          */
258                         System.err.println(&quot;Server died...&quot;);
259                         e.printStackTrace();
260                         serverReady.set(0);
261                         serverException = e;
262                     }
263                 }
264             };
265             serverThread.start();
266         } else {
267             try {
268                 doServerSide(port);
269             } catch (Exception e) {
270                 serverException = e;
271             } finally {
272                 serverReady.set(0);
273             }
274         }
275     }
276 
277     void startClient(boolean newThread)
278                  throws Exception {
279         if (newThread) {
280             clientThread = new Thread() {
281                 public void run() {
282                     try {
283                         doClientSide();
284                     } catch (Exception e) {
285                         /*
286                          * Our client thread just died.
287                          */
288                         System.err.println(&quot;Client died...&quot;);
289                         clientException = e;
290                     }
291                 }
292             };
293             clientThread.start();
294         } else {
295             try {
296                 doClientSide();
297             } catch (Exception e) {
298                 clientException = e;
299             }
300         }
301     }
302 }
    </pre>
  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff test/jdk/javax/net/ssl/templates/SSLSocketSSLEngineTemplate.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
<body>
<center><a href="../sanity/interop/JSSEServer.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="SSLSocketTemplate.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>test/jdk/javax/net/ssl/templates/SSLSocketSSLEngineTemplate.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2011, 2016, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 //
 25 // SunJSSE does not support dynamic system properties, no way to re-use
 26 // system properties in samevm/agentvm mode.
 27 //
 28 
 29 /*
 30  * @test
 31  * @bug 7105780
 32  * @summary Add SSLSocket client/SSLEngine server to templates directory.
<span class="line-modified"> 33  * @run main/othervm SSLSocketSSLEngineTemplate</span>



 34  */
 35 
 36 /**
 37  * A SSLSocket/SSLEngine interop test case.  This is not the way to
 38  * code SSLEngine-based servers, but works for what we need to do here,
 39  * which is to make sure that SSLEngine/SSLSockets can talk to each other.
 40  * SSLEngines can use direct or indirect buffers, and different code
 41  * is used to get at the buffer contents internally, so we test that here.
 42  *
 43  * The test creates one SSLSocket (client) and one SSLEngine (server).
 44  * The SSLSocket talks to a raw ServerSocket, and the server code
 45  * does the translation between byte [] and ByteBuffers that the SSLEngine
 46  * can use.  The &quot;transport&quot; layer consists of a Socket Input/OutputStream
 47  * and two byte buffers for the SSLEngines:  think of them
 48  * as directly connected pipes.
 49  *
 50  * Again, this is a *very* simple example: real code will be much more
 51  * involved.  For example, different threading and I/O models could be
 52  * used, transport mechanisms could close unexpectedly, and so on.
 53  *
</pre>
<hr />
<pre>
 83 
 84 public class SSLSocketSSLEngineTemplate {
 85 
 86     /*
 87      * Enables logging of the SSL/TLS operations.
 88      */
 89     private static final boolean logging = true;
 90 
 91     /*
 92      * Enables the JSSE system debugging system property:
 93      *
 94      *     -Djavax.net.debug=all
 95      *
 96      * This gives a lot of low-level information about operations underway,
 97      * including specific handshake messages, and might be best examined
 98      * after gaining some familiarity with this application.
 99      */
100     private static final boolean debug = false;
101     private final SSLContext sslc;
102     private SSLEngine serverEngine;     // server-side SSLEngine

103 
104     private final byte[] serverMsg =
105         &quot;Hi there Client, I&#39;m a Server.&quot;.getBytes();
106     private final byte[] clientMsg =
<span class="line-modified">107         &quot;Hello Server, I&#39;m a Client!  Pleased to meet you!&quot;.getBytes();</span>
108 
109     private ByteBuffer serverOut;       // write side of serverEngine
110     private ByteBuffer serverIn;        // read side of serverEngine
111 
112     private volatile Exception clientException;
113     private volatile Exception serverException;
114 
115     /*
116      * For data transport, this example uses local ByteBuffers.
117      */
118     private ByteBuffer cTOs;            // &quot;reliable&quot; transport client-&gt;server
119     private ByteBuffer sTOc;            // &quot;reliable&quot; transport server-&gt;client
120 
121     /*
122      * The following is to set up the keystores/trust material.
123      */
124     private static final String pathToStores = &quot;../etc&quot;;
125     private static final String keyStoreFile = &quot;keystore&quot;;
126     private static final String trustStoreFile = &quot;truststore&quot;;
<span class="line-removed">127     private static final String passwd = &quot;passphrase&quot;;</span>
128     private static final String keyFilename =
129             System.getProperty(&quot;test.src&quot;, &quot;.&quot;) + &quot;/&quot; + pathToStores
130             + &quot;/&quot; + keyStoreFile;
131     private static final String trustFilename =
132             System.getProperty(&quot;test.src&quot;, &quot;.&quot;) + &quot;/&quot; + pathToStores
133             + &quot;/&quot; + trustStoreFile;
134 
135     /*
136      * Main entry point for this test.
137      */
138     public static void main(String args[]) throws Exception {


139         // reset security properties to make sure that the algorithms
140         // and keys used in this test are not disabled.
141         Security.setProperty(&quot;jdk.tls.disabledAlgorithms&quot;, &quot;&quot;);
142         Security.setProperty(&quot;jdk.certpath.disabledAlgorithms&quot;, &quot;&quot;);
143 
144         if (debug) {
145             System.setProperty(&quot;javax.net.debug&quot;, &quot;all&quot;);
146         }
147 
<span class="line-modified">148         String [] protocols = new String [] {</span>
<span class="line-modified">149             &quot;SSLv3&quot;, &quot;TLSv1&quot;, &quot;TLSv1.1&quot;, &quot;TLSv1.2&quot; };</span>
<span class="line-modified">150 </span>
<span class="line-modified">151         for (String protocol : protocols) {</span>
<span class="line-modified">152             log(&quot;Testing &quot; + protocol);</span>
<span class="line-modified">153             /*</span>
<span class="line-modified">154              * Run the tests with direct and indirect buffers.</span>
<span class="line-modified">155              */</span>
<span class="line-modified">156             SSLSocketSSLEngineTemplate test =</span>
<span class="line-modified">157                 new SSLSocketSSLEngineTemplate(protocol);</span>
<span class="line-modified">158             log(&quot;-------------------------------------&quot;);</span>
<span class="line-modified">159             log(&quot;Testing &quot; + protocol + &quot; for direct buffers ...&quot;);</span>
<span class="line-removed">160             test.runTest(true);</span>
<span class="line-removed">161 </span>
<span class="line-removed">162             log(&quot;---------------------------------------&quot;);</span>
<span class="line-removed">163             log(&quot;Testing &quot; + protocol + &quot; for indirect buffers ...&quot;);</span>
<span class="line-removed">164             test.runTest(false);</span>
<span class="line-removed">165         }</span>
166 
<span class="line-modified">167         System.out.println(&quot;Test Passed.&quot;);</span>
168     }
169 
170     /*
171      * Create an initialized SSLContext to use for these tests.
172      */
173     public SSLSocketSSLEngineTemplate(String protocol) throws Exception {
174 
175         KeyStore ks = KeyStore.getInstance(&quot;JKS&quot;);
176         KeyStore ts = KeyStore.getInstance(&quot;JKS&quot;);
177 
178         char[] passphrase = &quot;passphrase&quot;.toCharArray();
179 
180         try (FileInputStream keyFile = new FileInputStream(keyFilename);
181                 FileInputStream trustFile = new FileInputStream(trustFilename)) {
182             ks.load(keyFile, passphrase);
183             ts.load(trustFile, passphrase);
184         }
185 
186         KeyManagerFactory kmf = KeyManagerFactory.getInstance(&quot;SunX509&quot;);
187         kmf.init(ks, passphrase);
</pre>
<hr />
<pre>
197     }
198 
199     /*
200      * Run the test.
201      *
202      * Sit in a tight loop, with the server engine calling wrap/unwrap
203      * regardless of whether data is available or not.  We do this until
204      * we get the application data.  Then we shutdown and go to the next one.
205      *
206      * The main loop handles all of the I/O phases of the SSLEngine&#39;s
207      * lifetime:
208      *
209      *     initial handshaking
210      *     application data transfer
211      *     engine closing
212      *
213      * One could easily separate these phases into separate
214      * sections of code.
215      */
216     private void runTest(boolean direct) throws Exception {

217         boolean serverClose = direct;
218 
219         // generates the server-side Socket
220         try (ServerSocket serverSocket = new ServerSocket()) {
221             serverSocket.setReuseAddress(false);
222             serverSocket.bind(null);
223             int port = serverSocket.getLocalPort();

224             Thread thread = createClientThread(port, serverClose);
225 
226             createSSLEngine();
227             createBuffers(direct);
228 
229             // server-side socket that will read
230             try (Socket socket = serverSocket.accept()) {
231                 socket.setSoTimeout(500);
232 
233                 boolean closed = false;
234                 // will try to read one more time in case client message
235                 // is fragmented to multiple pieces
236                 boolean retry = true;
237 
238                 InputStream is = socket.getInputStream();
239                 OutputStream os = socket.getOutputStream();
240 
241                 SSLEngineResult serverResult;   // results from last operation
242 
243                 /*
244                  * Examining the SSLEngineResults could be much more involved,
245                  * and may alter the overall flow of the application.
246                  *
247                  * For example, if we received a BUFFER_OVERFLOW when trying
248                  * to write to the output pipe, we could reallocate a larger
249                  * pipe, but instead we wait for the peer to drain it.
250                  */
251                 byte[] inbound = new byte[8192];
252                 byte[] outbound = new byte[8192];
253 
254                 while (!isEngineClosed(serverEngine)) {
255                     int len;
256 
257                     // Inbound data
258                     log(&quot;================&quot;);
259 
260                     // Read from the Client side.
261                     try {
262                         len = is.read(inbound);
263                         if (len == -1) {
<span class="line-modified">264                             throw new Exception(&quot;Unexpected EOF&quot;);</span>







265                         }
266                         cTOs.put(inbound, 0, len);
267                     } catch (SocketTimeoutException ste) {
<span class="line-modified">268                         // swallow.  Nothing yet, probably waiting on us.</span>
269                     }
270 
271                     cTOs.flip();
272 
273                     serverResult = serverEngine.unwrap(cTOs, serverIn);
274                     log(&quot;server unwrap: &quot;, serverResult);
275                     runDelegatedTasks(serverResult, serverEngine);
276                     cTOs.compact();
277 
278                     // Outbound data
279                     log(&quot;----&quot;);
280 
281                     serverResult = serverEngine.wrap(serverOut, sTOc);
282                     log(&quot;server wrap: &quot;, serverResult);
283                     runDelegatedTasks(serverResult, serverEngine);
284 
285                     sTOc.flip();
286 
287                     if ((len = sTOc.remaining()) != 0) {
288                         sTOc.get(outbound, 0, len);
</pre>
<hr />
<pre>
351                 }
352                 throw clientException;
353             }
354         }
355     }
356 
357     /*
358      * Create a client thread which does simple SSLSocket operations.
359      * We&#39;ll write and read one data packet.
360      */
361     private Thread createClientThread(final int port,
362             final boolean serverClose) throws Exception {
363 
364         Thread t = new Thread(&quot;ClientThread&quot;) {
365 
366             @Override
367             public void run() {
368                 // client-side socket
369                 try (SSLSocket sslSocket = (SSLSocket)sslc.getSocketFactory().
370                             createSocket(&quot;localhost&quot;, port)) {


371                     OutputStream os = sslSocket.getOutputStream();
372                     InputStream is = sslSocket.getInputStream();
373 
374                     // write(byte[]) goes in one shot.
375                     os.write(clientMsg);
376 
377                     byte[] inbound = new byte[2048];
378                     int pos = 0;
379 
380                     int len;
381                     while ((len = is.read(inbound, pos, 2048 - pos)) != -1) {
382                         pos += len;
383                         // Let the client do the closing.
384                         if ((pos == serverMsg.length) &amp;&amp; !serverClose) {
385                             sslSocket.close();
386                             break;
387                         }
388                     }
389 
390                     if (pos != serverMsg.length) {
</pre>
<hr />
<pre>
459 
460         if (result.getHandshakeStatus() == HandshakeStatus.NEED_TASK) {
461             Runnable runnable;
462             while ((runnable = engine.getDelegatedTask()) != null) {
463                 log(&quot;\trunning delegated task...&quot;);
464                 runnable.run();
465             }
466             HandshakeStatus hsStatus = engine.getHandshakeStatus();
467             if (hsStatus == HandshakeStatus.NEED_TASK) {
468                 throw new Exception(
469                         &quot;handshake shouldn&#39;t need additional tasks&quot;);
470             }
471             log(&quot;\tnew HandshakeStatus: &quot; + hsStatus);
472         }
473     }
474 
475     private static boolean isEngineClosed(SSLEngine engine) {
476         return (engine.isOutboundDone() &amp;&amp; engine.isInboundDone());
477     }
478 









479     /*
480      * Logging code
481      */
482     private static boolean resultOnce = true;
483 
484     private static void log(String str, SSLEngineResult result) {
485         if (!logging) {
486             return;
487         }
488         if (resultOnce) {
489             resultOnce = false;
<span class="line-modified">490             System.out.println(&quot;The format of the SSLEngineResult is: \n&quot;</span>
491                     + &quot;\t\&quot;getStatus() / getHandshakeStatus()\&quot; +\n&quot;
492                     + &quot;\t\&quot;bytesConsumed() / bytesProduced()\&quot;\n&quot;);
493         }
494         HandshakeStatus hsStatus = result.getHandshakeStatus();
495         log(str
496                 + result.getStatus() + &quot;/&quot; + hsStatus + &quot;, &quot;
497                 + result.bytesConsumed() + &quot;/&quot; + result.bytesProduced()
498                 + &quot; bytes&quot;);
499         if (hsStatus == HandshakeStatus.FINISHED) {
500             log(&quot;\t...ready for application data&quot;);
501         }
502     }
503 
504     private static void log(String str) {
505         if (logging) {
<span class="line-modified">506             System.out.println(str);</span>




507         }
508     }
509 }
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2011, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 //
 25 // SunJSSE does not support dynamic system properties, no way to re-use
 26 // system properties in samevm/agentvm mode.
 27 //
 28 
 29 /*
 30  * @test
 31  * @bug 7105780
 32  * @summary Add SSLSocket client/SSLEngine server to templates directory.
<span class="line-modified"> 33  * @run main/othervm SSLSocketSSLEngineTemplate TLSv1</span>
<span class="line-added"> 34  * @run main/othervm SSLSocketSSLEngineTemplate TLSv1.1</span>
<span class="line-added"> 35  * @run main/othervm SSLSocketSSLEngineTemplate TLSv1.2</span>
<span class="line-added"> 36  * @run main/othervm SSLSocketSSLEngineTemplate TLSv1.3</span>
 37  */
 38 
 39 /**
 40  * A SSLSocket/SSLEngine interop test case.  This is not the way to
 41  * code SSLEngine-based servers, but works for what we need to do here,
 42  * which is to make sure that SSLEngine/SSLSockets can talk to each other.
 43  * SSLEngines can use direct or indirect buffers, and different code
 44  * is used to get at the buffer contents internally, so we test that here.
 45  *
 46  * The test creates one SSLSocket (client) and one SSLEngine (server).
 47  * The SSLSocket talks to a raw ServerSocket, and the server code
 48  * does the translation between byte [] and ByteBuffers that the SSLEngine
 49  * can use.  The &quot;transport&quot; layer consists of a Socket Input/OutputStream
 50  * and two byte buffers for the SSLEngines:  think of them
 51  * as directly connected pipes.
 52  *
 53  * Again, this is a *very* simple example: real code will be much more
 54  * involved.  For example, different threading and I/O models could be
 55  * used, transport mechanisms could close unexpectedly, and so on.
 56  *
</pre>
<hr />
<pre>
 86 
 87 public class SSLSocketSSLEngineTemplate {
 88 
 89     /*
 90      * Enables logging of the SSL/TLS operations.
 91      */
 92     private static final boolean logging = true;
 93 
 94     /*
 95      * Enables the JSSE system debugging system property:
 96      *
 97      *     -Djavax.net.debug=all
 98      *
 99      * This gives a lot of low-level information about operations underway,
100      * including specific handshake messages, and might be best examined
101      * after gaining some familiarity with this application.
102      */
103     private static final boolean debug = false;
104     private final SSLContext sslc;
105     private SSLEngine serverEngine;     // server-side SSLEngine
<span class="line-added">106     private SSLSocket clientSocket;</span>
107 
108     private final byte[] serverMsg =
109         &quot;Hi there Client, I&#39;m a Server.&quot;.getBytes();
110     private final byte[] clientMsg =
<span class="line-modified">111         &quot;Hello Server, I&#39;m a Client! Pleased to meet you!&quot;.getBytes();</span>
112 
113     private ByteBuffer serverOut;       // write side of serverEngine
114     private ByteBuffer serverIn;        // read side of serverEngine
115 
116     private volatile Exception clientException;
117     private volatile Exception serverException;
118 
119     /*
120      * For data transport, this example uses local ByteBuffers.
121      */
122     private ByteBuffer cTOs;            // &quot;reliable&quot; transport client-&gt;server
123     private ByteBuffer sTOc;            // &quot;reliable&quot; transport server-&gt;client
124 
125     /*
126      * The following is to set up the keystores/trust material.
127      */
128     private static final String pathToStores = &quot;../etc&quot;;
129     private static final String keyStoreFile = &quot;keystore&quot;;
130     private static final String trustStoreFile = &quot;truststore&quot;;

131     private static final String keyFilename =
132             System.getProperty(&quot;test.src&quot;, &quot;.&quot;) + &quot;/&quot; + pathToStores
133             + &quot;/&quot; + keyStoreFile;
134     private static final String trustFilename =
135             System.getProperty(&quot;test.src&quot;, &quot;.&quot;) + &quot;/&quot; + pathToStores
136             + &quot;/&quot; + trustStoreFile;
137 
138     /*
139      * Main entry point for this test.
140      */
141     public static void main(String args[]) throws Exception {
<span class="line-added">142         String protocol = args[0];</span>
<span class="line-added">143 </span>
144         // reset security properties to make sure that the algorithms
145         // and keys used in this test are not disabled.
146         Security.setProperty(&quot;jdk.tls.disabledAlgorithms&quot;, &quot;&quot;);
147         Security.setProperty(&quot;jdk.certpath.disabledAlgorithms&quot;, &quot;&quot;);
148 
149         if (debug) {
150             System.setProperty(&quot;javax.net.debug&quot;, &quot;all&quot;);
151         }
152 
<span class="line-modified">153         /*</span>
<span class="line-modified">154          * Run the tests with direct and indirect buffers.</span>
<span class="line-modified">155          */</span>
<span class="line-modified">156         SSLSocketSSLEngineTemplate test =</span>
<span class="line-modified">157             new SSLSocketSSLEngineTemplate(protocol);</span>
<span class="line-modified">158         log(&quot;-------------------------------------&quot;);</span>
<span class="line-modified">159         log(&quot;Testing &quot; + protocol + &quot; for direct buffers ...&quot;);</span>
<span class="line-modified">160         test.runTest(true);</span>
<span class="line-modified">161 </span>
<span class="line-modified">162         log(&quot;---------------------------------------&quot;);</span>
<span class="line-modified">163         log(&quot;Testing &quot; + protocol + &quot; for indirect buffers ...&quot;);</span>
<span class="line-modified">164         test.runTest(false);</span>






165 
<span class="line-modified">166         log(&quot;Test Passed.&quot;);</span>
167     }
168 
169     /*
170      * Create an initialized SSLContext to use for these tests.
171      */
172     public SSLSocketSSLEngineTemplate(String protocol) throws Exception {
173 
174         KeyStore ks = KeyStore.getInstance(&quot;JKS&quot;);
175         KeyStore ts = KeyStore.getInstance(&quot;JKS&quot;);
176 
177         char[] passphrase = &quot;passphrase&quot;.toCharArray();
178 
179         try (FileInputStream keyFile = new FileInputStream(keyFilename);
180                 FileInputStream trustFile = new FileInputStream(trustFilename)) {
181             ks.load(keyFile, passphrase);
182             ts.load(trustFile, passphrase);
183         }
184 
185         KeyManagerFactory kmf = KeyManagerFactory.getInstance(&quot;SunX509&quot;);
186         kmf.init(ks, passphrase);
</pre>
<hr />
<pre>
196     }
197 
198     /*
199      * Run the test.
200      *
201      * Sit in a tight loop, with the server engine calling wrap/unwrap
202      * regardless of whether data is available or not.  We do this until
203      * we get the application data.  Then we shutdown and go to the next one.
204      *
205      * The main loop handles all of the I/O phases of the SSLEngine&#39;s
206      * lifetime:
207      *
208      *     initial handshaking
209      *     application data transfer
210      *     engine closing
211      *
212      * One could easily separate these phases into separate
213      * sections of code.
214      */
215     private void runTest(boolean direct) throws Exception {
<span class="line-added">216         clientSocket = null;</span>
217         boolean serverClose = direct;
218 
219         // generates the server-side Socket
220         try (ServerSocket serverSocket = new ServerSocket()) {
221             serverSocket.setReuseAddress(false);
222             serverSocket.bind(null);
223             int port = serverSocket.getLocalPort();
<span class="line-added">224             log(&quot;Port: &quot; + port);</span>
225             Thread thread = createClientThread(port, serverClose);
226 
227             createSSLEngine();
228             createBuffers(direct);
229 
230             // server-side socket that will read
231             try (Socket socket = serverSocket.accept()) {
232                 socket.setSoTimeout(500);
233 
234                 boolean closed = false;
235                 // will try to read one more time in case client message
236                 // is fragmented to multiple pieces
237                 boolean retry = true;
238 
239                 InputStream is = socket.getInputStream();
240                 OutputStream os = socket.getOutputStream();
241 
242                 SSLEngineResult serverResult;   // results from last operation
243 
244                 /*
245                  * Examining the SSLEngineResults could be much more involved,
246                  * and may alter the overall flow of the application.
247                  *
248                  * For example, if we received a BUFFER_OVERFLOW when trying
249                  * to write to the output pipe, we could reallocate a larger
250                  * pipe, but instead we wait for the peer to drain it.
251                  */
252                 byte[] inbound = new byte[8192];
253                 byte[] outbound = new byte[8192];
254 
255                 while (!isEngineClosed(serverEngine)) {
256                     int len;
257 
258                     // Inbound data
259                     log(&quot;================&quot;);
260 
261                     // Read from the Client side.
262                     try {
263                         len = is.read(inbound);
264                         if (len == -1) {
<span class="line-modified">265                             logSocketStatus(clientSocket);</span>
<span class="line-added">266                             if (clientSocket.isClosed()</span>
<span class="line-added">267                                     || clientSocket.isOutputShutdown()) {</span>
<span class="line-added">268                                 log(&quot;Client socket was closed or shutdown output&quot;);</span>
<span class="line-added">269                                 break;</span>
<span class="line-added">270                             } else {</span>
<span class="line-added">271                                 throw new Exception(&quot;Unexpected EOF&quot;);</span>
<span class="line-added">272                             }</span>
273                         }
274                         cTOs.put(inbound, 0, len);
275                     } catch (SocketTimeoutException ste) {
<span class="line-modified">276                         // swallow. Nothing yet, probably waiting on us.</span>
277                     }
278 
279                     cTOs.flip();
280 
281                     serverResult = serverEngine.unwrap(cTOs, serverIn);
282                     log(&quot;server unwrap: &quot;, serverResult);
283                     runDelegatedTasks(serverResult, serverEngine);
284                     cTOs.compact();
285 
286                     // Outbound data
287                     log(&quot;----&quot;);
288 
289                     serverResult = serverEngine.wrap(serverOut, sTOc);
290                     log(&quot;server wrap: &quot;, serverResult);
291                     runDelegatedTasks(serverResult, serverEngine);
292 
293                     sTOc.flip();
294 
295                     if ((len = sTOc.remaining()) != 0) {
296                         sTOc.get(outbound, 0, len);
</pre>
<hr />
<pre>
359                 }
360                 throw clientException;
361             }
362         }
363     }
364 
365     /*
366      * Create a client thread which does simple SSLSocket operations.
367      * We&#39;ll write and read one data packet.
368      */
369     private Thread createClientThread(final int port,
370             final boolean serverClose) throws Exception {
371 
372         Thread t = new Thread(&quot;ClientThread&quot;) {
373 
374             @Override
375             public void run() {
376                 // client-side socket
377                 try (SSLSocket sslSocket = (SSLSocket)sslc.getSocketFactory().
378                             createSocket(&quot;localhost&quot;, port)) {
<span class="line-added">379                     clientSocket = sslSocket;</span>
<span class="line-added">380 </span>
381                     OutputStream os = sslSocket.getOutputStream();
382                     InputStream is = sslSocket.getInputStream();
383 
384                     // write(byte[]) goes in one shot.
385                     os.write(clientMsg);
386 
387                     byte[] inbound = new byte[2048];
388                     int pos = 0;
389 
390                     int len;
391                     while ((len = is.read(inbound, pos, 2048 - pos)) != -1) {
392                         pos += len;
393                         // Let the client do the closing.
394                         if ((pos == serverMsg.length) &amp;&amp; !serverClose) {
395                             sslSocket.close();
396                             break;
397                         }
398                     }
399 
400                     if (pos != serverMsg.length) {
</pre>
<hr />
<pre>
469 
470         if (result.getHandshakeStatus() == HandshakeStatus.NEED_TASK) {
471             Runnable runnable;
472             while ((runnable = engine.getDelegatedTask()) != null) {
473                 log(&quot;\trunning delegated task...&quot;);
474                 runnable.run();
475             }
476             HandshakeStatus hsStatus = engine.getHandshakeStatus();
477             if (hsStatus == HandshakeStatus.NEED_TASK) {
478                 throw new Exception(
479                         &quot;handshake shouldn&#39;t need additional tasks&quot;);
480             }
481             log(&quot;\tnew HandshakeStatus: &quot; + hsStatus);
482         }
483     }
484 
485     private static boolean isEngineClosed(SSLEngine engine) {
486         return (engine.isOutboundDone() &amp;&amp; engine.isInboundDone());
487     }
488 
<span class="line-added">489     private static void logSocketStatus(Socket socket) {</span>
<span class="line-added">490         log(&quot;##### &quot; + socket + &quot; #####&quot;);</span>
<span class="line-added">491         log(&quot;isBound: &quot; + socket.isBound());</span>
<span class="line-added">492         log(&quot;isConnected: &quot; + socket.isConnected());</span>
<span class="line-added">493         log(&quot;isClosed: &quot; + socket.isClosed());</span>
<span class="line-added">494         log(&quot;isInputShutdown: &quot; + socket.isInputShutdown());</span>
<span class="line-added">495         log(&quot;isOutputShutdown: &quot; + socket.isOutputShutdown());</span>
<span class="line-added">496     }</span>
<span class="line-added">497 </span>
498     /*
499      * Logging code
500      */
501     private static boolean resultOnce = true;
502 
503     private static void log(String str, SSLEngineResult result) {
504         if (!logging) {
505             return;
506         }
507         if (resultOnce) {
508             resultOnce = false;
<span class="line-modified">509             log(&quot;The format of the SSLEngineResult is: \n&quot;</span>
510                     + &quot;\t\&quot;getStatus() / getHandshakeStatus()\&quot; +\n&quot;
511                     + &quot;\t\&quot;bytesConsumed() / bytesProduced()\&quot;\n&quot;);
512         }
513         HandshakeStatus hsStatus = result.getHandshakeStatus();
514         log(str
515                 + result.getStatus() + &quot;/&quot; + hsStatus + &quot;, &quot;
516                 + result.bytesConsumed() + &quot;/&quot; + result.bytesProduced()
517                 + &quot; bytes&quot;);
518         if (hsStatus == HandshakeStatus.FINISHED) {
519             log(&quot;\t...ready for application data&quot;);
520         }
521     }
522 
523     private static void log(String str) {
524         if (logging) {
<span class="line-modified">525             if (debug) {</span>
<span class="line-added">526                 System.err.println(str);</span>
<span class="line-added">527             } else {</span>
<span class="line-added">528                 System.out.println(str);</span>
<span class="line-added">529             }</span>
530         }
531     }
532 }
</pre>
</td>
</tr>
</table>
<center><a href="../sanity/interop/JSSEServer.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="SSLSocketTemplate.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
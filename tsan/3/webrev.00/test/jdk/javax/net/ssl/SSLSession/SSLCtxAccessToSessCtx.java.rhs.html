<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames test/jdk/javax/net/ssl/SSLSession/SSLCtxAccessToSessCtx.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
<a name="1" id="anc1"></a><span class="line-modified">  2  * Copyright (c) 2001, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 /*
 25  * @test
 26  * @bug 4473210
 27  * @summary SSLSessionContext should be accessible from SSLContext
<a name="2" id="anc2"></a><span class="line-modified"> 28  * @run main/othervm -Djdk.tls.server.enableSessionTicketExtension=false</span>
<span class="line-added"> 29  *   SSLCtxAccessToSessCtx</span>
<span class="line-added"> 30  *</span>
 31  *
 32  *     SunJSSE does not support dynamic system properties, no way to re-use
 33  *     system properties in samevm/agentvm mode.
 34  */
 35 
 36 import java.io.*;
 37 import java.net.*;
 38 import javax.net.ssl.*;
 39 import java.util.*;
 40 import java.util.concurrent.atomic.AtomicInteger;
 41 import java.security.KeyStore;
 42 
 43 public class SSLCtxAccessToSessCtx  {
 44 
 45     /*
 46      * =============================================================
 47      * Set the various variables needed for the tests, then
 48      * specify what tests to run on each side.
 49      */
 50 
 51     /*
 52      * Should we run the client or server in a separate thread?
 53      * Both sides can throw exceptions, but do you have a preference
 54      * as to which side should be the main thread.
 55      */
 56     static boolean separateServerThread = true;
 57 
 58     /*
 59      * Where do we find the keystores?
 60      */
 61     static String pathToStores = &quot;../etc&quot;;
 62     static String keyStoreFile = &quot;keystore&quot;;
 63     static String trustStoreFile = &quot;truststore&quot;;
 64     static String passwd = &quot;passphrase&quot;;
 65 
 66     /*
 67      * Is the server ready to serve?
 68      */
 69     AtomicInteger serverReady = new AtomicInteger(1);   // only one port now
 70 
 71     /*
 72      * Turn on SSL debugging?
 73      */
 74     static boolean debug = false;
 75 
 76     /*
 77      * If the client or server is doing some kind of object creation
 78      * that the other side depends on, and that thread prematurely
 79      * exits, you may experience a hang.  The test harness will
 80      * terminate all hung threads after its timeout has expired,
 81      * currently 3 minutes by default, but you might try to be
 82      * smart about it....
 83      */
 84 
 85     /*
 86      * Define the server side of the test.
 87      *
 88      * If the server prematurely exits, serverReady will be set to true
 89      * to avoid infinite hangs.
 90      */
 91     void doServerSide(int serverPort) throws Exception {
 92 
 93         SSLServerSocket sslServerSocket =
 94             (SSLServerSocket) sslssf.createServerSocket(serverPort);
 95         int slot = createdPorts.getAndIncrement();
 96         serverPorts[slot] = sslServerSocket.getLocalPort();
 97 
 98         /*
 99          * Signal Client, we&#39;re ready for his connect.
100          */
101         serverReady.getAndDecrement();
102         int read = 0;
103         SSLSocket sslSocket = (SSLSocket) sslServerSocket.accept();
104         InputStream sslIS = sslSocket.getInputStream();
105         OutputStream sslOS = sslSocket.getOutputStream();
106         read = sslIS.read();
107         SSLSessionContext sslctxCache = sslctx.getServerSessionContext();
108         SSLSessionContext sessCache = sslSocket.getSession().
109                                 getSessionContext();
110         if (sessCache != sslctxCache)
111             throw new Exception(&quot;Test failed, session_cache != sslctx_cache&quot;);
112         sslOS.write(85);
113         sslOS.flush();
114         sslSocket.close();
115     }
116 
117     /*
118      * Define the client side of the test.
119      *
120      * If the server prematurely exits, serverReady will be set to true
121      * to avoid infinite hangs.
122      */
123     void doClientSide() throws Exception {
124 
125         /*
126          * Wait for server to get started.
127          */
128         while (serverReady.get() &gt; 0) {
129             Thread.sleep(50);
130         }
131         /*
132          * first connection to serverPorts[0] -- a new session, session11
133          * gets created, and is cached.
134          */
135         SSLSocket sslSocket;
136         sslSocket = (SSLSocket) sslsf.
137                 createSocket(&quot;localhost&quot;, serverPorts[0]);
138         InputStream sslIS = sslSocket.getInputStream();
139         OutputStream sslOS = sslSocket.getOutputStream();
140         sslOS.write(237);
141         sslOS.flush();
142 
143         SSLSession sess = sslSocket.getSession();
144         SSLSessionContext sessCache = sess.getSessionContext();
145         SSLSessionContext sslctxCache = sslctx.getClientSessionContext();
146         if (sessCache != sslctxCache)
147             throw new Exception(&quot;Test failed, session_cache != sslctx_cache&quot;);
148 
149         int read = sslIS.read();
150         sslSocket.close();
151     }
152 
153     /*
154      * =============================================================
155      * The remainder is just support stuff
156      */
157 
158     int serverPorts[] = new int[]{0};           // only one port at present
159     AtomicInteger createdPorts = new AtomicInteger(0);
160     static SSLServerSocketFactory sslssf;
161     static SSLSocketFactory sslsf;
162     static SSLContext sslctx;
163 
164     volatile Exception serverException = null;
165     volatile Exception clientException = null;
166 
167     public static void main(String[] args) throws Exception {
168         String keyFilename =
169             System.getProperty(&quot;test.src&quot;, &quot;./&quot;) + &quot;/&quot; + pathToStores +
170                 &quot;/&quot; + keyStoreFile;
171         String trustFilename =
172             System.getProperty(&quot;test.src&quot;, &quot;./&quot;) + &quot;/&quot; + pathToStores +
173                 &quot;/&quot; + trustStoreFile;
174 
175         System.setProperty(&quot;javax.net.ssl.keyStore&quot;, keyFilename);
176         System.setProperty(&quot;javax.net.ssl.keyStorePassword&quot;, passwd);
177         System.setProperty(&quot;javax.net.ssl.trustStore&quot;, trustFilename);
178         System.setProperty(&quot;javax.net.ssl.trustStorePassword&quot;, passwd);
179 
180         sslctx = SSLContext.getInstance(&quot;TLS&quot;);
181         KeyManagerFactory kmf = KeyManagerFactory.getInstance(&quot;SunX509&quot;);
182         KeyStore ks = KeyStore.getInstance(&quot;JKS&quot;);
183         ks.load(new FileInputStream(keyFilename), passwd.toCharArray());
184         kmf.init(ks, passwd.toCharArray());
185         sslctx.init(kmf.getKeyManagers(), null, null);
186 
187         sslssf = (SSLServerSocketFactory) sslctx.getServerSocketFactory();
188         sslsf = (SSLSocketFactory) sslctx.getSocketFactory();
189 
190         if (debug)
191             System.setProperty(&quot;javax.net.debug&quot;, &quot;all&quot;);
192 
193         /*
194          * Start the tests.
195          */
196         new SSLCtxAccessToSessCtx();
197     }
198 
199     Thread clientThread = null;
200     Thread serverThread = null;
201 
202     /*
203      * Primary constructor, used to drive remainder of the test.
204      *
205      * Fork off the other side, then do your work.
206      */
207     SSLCtxAccessToSessCtx() throws Exception {
208 
209         /*
210          * create the SSLServerSocket and SSLSocket factories
211          */
212         if (separateServerThread) {
213             for (int i = 0; i &lt; serverPorts.length; i++) {
214                 startServer(serverPorts[i], true);
215             }
216             startClient(false);
217         } else {
218             startClient(true);
219             for (int i = 0; i &lt; serverPorts.length; i++) {
220                 startServer(serverPorts[i], false);
221             }
222         }
223 
224         /*
225          * Wait for other side to close down.
226          */
227         if (separateServerThread) {
228             serverThread.join();
229         } else {
230             clientThread.join();
231         }
232 
233         /*
234          * When we get here, the test is pretty much over.
235          *
236          * If the main thread excepted, that propagates back
237          * immediately.  If the other thread threw an exception, we
238          * should report back.
239          */
240         if (serverException != null)
241             throw serverException;
242         if (clientException != null)
243             throw clientException;
244         System.out.println(&quot;The Session context tests passed&quot;);
245     }
246 
247     void startServer(final int port,
248                         boolean newThread) throws Exception {
249         if (newThread) {
250             serverThread = new Thread() {
251                 public void run() {
252                     try {
253                         doServerSide(port);
254                     } catch (Exception e) {
255                         /*
256                          * Our server thread just died.
257                          *
258                          * Release the client, if not active already...
259                          */
260                         System.err.println(&quot;Server died...&quot;);
261                         e.printStackTrace();
262                         serverReady.set(0);
263                         serverException = e;
264                     }
265                 }
266             };
267             serverThread.start();
268         } else {
269             try {
270                 doServerSide(port);
271             } catch (Exception e) {
272                 serverException = e;
273             } finally {
274                 serverReady.set(0);
275             }
276         }
277     }
278 
279     void startClient(boolean newThread)
280                  throws Exception {
281         if (newThread) {
282             clientThread = new Thread() {
283                 public void run() {
284                     try {
285                         doClientSide();
286                     } catch (Exception e) {
287                         /*
288                          * Our client thread just died.
289                          */
290                         System.err.println(&quot;Client died...&quot;);
291                         clientException = e;
292                     }
293                 }
294             };
295             clientThread.start();
296         } else {
297             try {
298                 doClientSide();
299             } catch (Exception e) {
300                 clientException = e;
301             }
302         }
303     }
304 }
<a name="3" id="anc3"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="3" type="hidden" />
</body>
</html>
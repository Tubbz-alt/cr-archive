<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old test/jdk/javax/net/ssl/templates/SSLSocketSSLEngineTemplate.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2011, 2016, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 //
 25 // SunJSSE does not support dynamic system properties, no way to re-use
 26 // system properties in samevm/agentvm mode.
 27 //
 28 
 29 /*
 30  * @test
 31  * @bug 7105780
 32  * @summary Add SSLSocket client/SSLEngine server to templates directory.
 33  * @run main/othervm SSLSocketSSLEngineTemplate
 34  */
 35 
 36 /**
 37  * A SSLSocket/SSLEngine interop test case.  This is not the way to
 38  * code SSLEngine-based servers, but works for what we need to do here,
 39  * which is to make sure that SSLEngine/SSLSockets can talk to each other.
 40  * SSLEngines can use direct or indirect buffers, and different code
 41  * is used to get at the buffer contents internally, so we test that here.
 42  *
 43  * The test creates one SSLSocket (client) and one SSLEngine (server).
 44  * The SSLSocket talks to a raw ServerSocket, and the server code
 45  * does the translation between byte [] and ByteBuffers that the SSLEngine
 46  * can use.  The &quot;transport&quot; layer consists of a Socket Input/OutputStream
 47  * and two byte buffers for the SSLEngines:  think of them
 48  * as directly connected pipes.
 49  *
 50  * Again, this is a *very* simple example: real code will be much more
 51  * involved.  For example, different threading and I/O models could be
 52  * used, transport mechanisms could close unexpectedly, and so on.
 53  *
 54  * When this application runs, notice that several messages
 55  * (wrap/unwrap) pass before any application data is consumed or
 56  * produced.  (For more information, please see the SSL/TLS
 57  * specifications.)  There may several steps for a successful handshake,
 58  * so it&#39;s typical to see the following series of operations:
 59  *
 60  *      client          server          message
 61  *      ======          ======          =======
 62  *      write()         ...             ClientHello
 63  *      ...             unwrap()        ClientHello
 64  *      ...             wrap()          ServerHello/Certificate
 65  *      read()          ...             ServerHello/Certificate
 66  *      write()         ...             ClientKeyExchange
 67  *      write()         ...             ChangeCipherSpec
 68  *      write()         ...             Finished
 69  *      ...             unwrap()        ClientKeyExchange
 70  *      ...             unwrap()        ChangeCipherSpec
 71  *      ...             unwrap()        Finished
 72  *      ...             wrap()          ChangeCipherSpec
 73  *      ...             wrap()          Finished
 74  *      read()          ...             ChangeCipherSpec
 75  *      read()          ...             Finished
 76  */
 77 import javax.net.ssl.*;
 78 import javax.net.ssl.SSLEngineResult.*;
 79 import java.io.*;
 80 import java.net.*;
 81 import java.security.*;
 82 import java.nio.*;
 83 
 84 public class SSLSocketSSLEngineTemplate {
 85 
 86     /*
 87      * Enables logging of the SSL/TLS operations.
 88      */
 89     private static final boolean logging = true;
 90 
 91     /*
 92      * Enables the JSSE system debugging system property:
 93      *
 94      *     -Djavax.net.debug=all
 95      *
 96      * This gives a lot of low-level information about operations underway,
 97      * including specific handshake messages, and might be best examined
 98      * after gaining some familiarity with this application.
 99      */
100     private static final boolean debug = false;
101     private final SSLContext sslc;
102     private SSLEngine serverEngine;     // server-side SSLEngine
103 
104     private final byte[] serverMsg =
105         &quot;Hi there Client, I&#39;m a Server.&quot;.getBytes();
106     private final byte[] clientMsg =
107         &quot;Hello Server, I&#39;m a Client!  Pleased to meet you!&quot;.getBytes();
108 
109     private ByteBuffer serverOut;       // write side of serverEngine
110     private ByteBuffer serverIn;        // read side of serverEngine
111 
112     private volatile Exception clientException;
113     private volatile Exception serverException;
114 
115     /*
116      * For data transport, this example uses local ByteBuffers.
117      */
118     private ByteBuffer cTOs;            // &quot;reliable&quot; transport client-&gt;server
119     private ByteBuffer sTOc;            // &quot;reliable&quot; transport server-&gt;client
120 
121     /*
122      * The following is to set up the keystores/trust material.
123      */
124     private static final String pathToStores = &quot;../etc&quot;;
125     private static final String keyStoreFile = &quot;keystore&quot;;
126     private static final String trustStoreFile = &quot;truststore&quot;;
127     private static final String passwd = &quot;passphrase&quot;;
128     private static final String keyFilename =
129             System.getProperty(&quot;test.src&quot;, &quot;.&quot;) + &quot;/&quot; + pathToStores
130             + &quot;/&quot; + keyStoreFile;
131     private static final String trustFilename =
132             System.getProperty(&quot;test.src&quot;, &quot;.&quot;) + &quot;/&quot; + pathToStores
133             + &quot;/&quot; + trustStoreFile;
134 
135     /*
136      * Main entry point for this test.
137      */
138     public static void main(String args[]) throws Exception {
139         // reset security properties to make sure that the algorithms
140         // and keys used in this test are not disabled.
141         Security.setProperty(&quot;jdk.tls.disabledAlgorithms&quot;, &quot;&quot;);
142         Security.setProperty(&quot;jdk.certpath.disabledAlgorithms&quot;, &quot;&quot;);
143 
144         if (debug) {
145             System.setProperty(&quot;javax.net.debug&quot;, &quot;all&quot;);
146         }
147 
148         String [] protocols = new String [] {
149             &quot;SSLv3&quot;, &quot;TLSv1&quot;, &quot;TLSv1.1&quot;, &quot;TLSv1.2&quot; };
150 
151         for (String protocol : protocols) {
152             log(&quot;Testing &quot; + protocol);
153             /*
154              * Run the tests with direct and indirect buffers.
155              */
156             SSLSocketSSLEngineTemplate test =
157                 new SSLSocketSSLEngineTemplate(protocol);
158             log(&quot;-------------------------------------&quot;);
159             log(&quot;Testing &quot; + protocol + &quot; for direct buffers ...&quot;);
160             test.runTest(true);
161 
162             log(&quot;---------------------------------------&quot;);
163             log(&quot;Testing &quot; + protocol + &quot; for indirect buffers ...&quot;);
164             test.runTest(false);
165         }
166 
167         System.out.println(&quot;Test Passed.&quot;);
168     }
169 
170     /*
171      * Create an initialized SSLContext to use for these tests.
172      */
173     public SSLSocketSSLEngineTemplate(String protocol) throws Exception {
174 
175         KeyStore ks = KeyStore.getInstance(&quot;JKS&quot;);
176         KeyStore ts = KeyStore.getInstance(&quot;JKS&quot;);
177 
178         char[] passphrase = &quot;passphrase&quot;.toCharArray();
179 
180         try (FileInputStream keyFile = new FileInputStream(keyFilename);
181                 FileInputStream trustFile = new FileInputStream(trustFilename)) {
182             ks.load(keyFile, passphrase);
183             ts.load(trustFile, passphrase);
184         }
185 
186         KeyManagerFactory kmf = KeyManagerFactory.getInstance(&quot;SunX509&quot;);
187         kmf.init(ks, passphrase);
188 
189         TrustManagerFactory tmf = TrustManagerFactory.getInstance(&quot;SunX509&quot;);
190         tmf.init(ts);
191 
192         SSLContext sslCtx = SSLContext.getInstance(protocol);
193 
194         sslCtx.init(kmf.getKeyManagers(), tmf.getTrustManagers(), null);
195 
196         sslc = sslCtx;
197     }
198 
199     /*
200      * Run the test.
201      *
202      * Sit in a tight loop, with the server engine calling wrap/unwrap
203      * regardless of whether data is available or not.  We do this until
204      * we get the application data.  Then we shutdown and go to the next one.
205      *
206      * The main loop handles all of the I/O phases of the SSLEngine&#39;s
207      * lifetime:
208      *
209      *     initial handshaking
210      *     application data transfer
211      *     engine closing
212      *
213      * One could easily separate these phases into separate
214      * sections of code.
215      */
216     private void runTest(boolean direct) throws Exception {
217         boolean serverClose = direct;
218 
219         // generates the server-side Socket
220         try (ServerSocket serverSocket = new ServerSocket()) {
221             serverSocket.setReuseAddress(false);
222             serverSocket.bind(null);
223             int port = serverSocket.getLocalPort();
224             Thread thread = createClientThread(port, serverClose);
225 
226             createSSLEngine();
227             createBuffers(direct);
228 
229             // server-side socket that will read
230             try (Socket socket = serverSocket.accept()) {
231                 socket.setSoTimeout(500);
232 
233                 boolean closed = false;
234                 // will try to read one more time in case client message
235                 // is fragmented to multiple pieces
236                 boolean retry = true;
237 
238                 InputStream is = socket.getInputStream();
239                 OutputStream os = socket.getOutputStream();
240 
241                 SSLEngineResult serverResult;   // results from last operation
242 
243                 /*
244                  * Examining the SSLEngineResults could be much more involved,
245                  * and may alter the overall flow of the application.
246                  *
247                  * For example, if we received a BUFFER_OVERFLOW when trying
248                  * to write to the output pipe, we could reallocate a larger
249                  * pipe, but instead we wait for the peer to drain it.
250                  */
251                 byte[] inbound = new byte[8192];
252                 byte[] outbound = new byte[8192];
253 
254                 while (!isEngineClosed(serverEngine)) {
255                     int len;
256 
257                     // Inbound data
258                     log(&quot;================&quot;);
259 
260                     // Read from the Client side.
261                     try {
262                         len = is.read(inbound);
263                         if (len == -1) {
264                             throw new Exception(&quot;Unexpected EOF&quot;);
265                         }
266                         cTOs.put(inbound, 0, len);
267                     } catch (SocketTimeoutException ste) {
268                         // swallow.  Nothing yet, probably waiting on us.
269                     }
270 
271                     cTOs.flip();
272 
273                     serverResult = serverEngine.unwrap(cTOs, serverIn);
274                     log(&quot;server unwrap: &quot;, serverResult);
275                     runDelegatedTasks(serverResult, serverEngine);
276                     cTOs.compact();
277 
278                     // Outbound data
279                     log(&quot;----&quot;);
280 
281                     serverResult = serverEngine.wrap(serverOut, sTOc);
282                     log(&quot;server wrap: &quot;, serverResult);
283                     runDelegatedTasks(serverResult, serverEngine);
284 
285                     sTOc.flip();
286 
287                     if ((len = sTOc.remaining()) != 0) {
288                         sTOc.get(outbound, 0, len);
289                         os.write(outbound, 0, len);
290                         // Give the other side a chance to process
291                     }
292 
293                     sTOc.compact();
294 
295                     if (!closed &amp;&amp; (serverOut.remaining() == 0)) {
296                         closed = true;
297 
298                         /*
299                          * We&#39;ll alternate initiatating the shutdown.
300                          * When the server initiates, it will take one more
301                          * loop, but tests the orderly shutdown.
302                          */
303                         if (serverClose) {
304                             serverEngine.closeOutbound();
305                         }
306                         serverIn.flip();
307 
308                         /*
309                          * A sanity check to ensure we got what was sent.
310                          */
311                         if (serverIn.remaining() !=  clientMsg.length) {
312                             if (retry &amp;&amp;
313                                     serverIn.remaining() &lt; clientMsg.length) {
314                                 log(&quot;Need to read more from client&quot;);
315                                 serverIn.compact();
316                                 retry = false;
317                                 continue;
318                             } else {
319                                 throw new Exception(
320                                         &quot;Client: Data length error&quot;);
321                             }
322                         }
323 
324                         for (int i = 0; i &lt; clientMsg.length; i++) {
325                             if (clientMsg[i] != serverIn.get()) {
326                                 throw new Exception(
327                                         &quot;Client: Data content error&quot;);
328                             }
329                         }
330                         serverIn.compact();
331                     }
332                 }
333             } catch (Exception e) {
334                 serverException = e;
335             } finally {
336                 // Wait for the client to join up with us.
337                 if (thread != null) {
338                     thread.join();
339                 }
340             }
341         } finally {
342             if (serverException != null) {
343                 if (clientException != null) {
344                     serverException.initCause(clientException);
345                 }
346                 throw serverException;
347             }
348             if (clientException != null) {
349                 if (serverException != null) {
350                     clientException.initCause(serverException);
351                 }
352                 throw clientException;
353             }
354         }
355     }
356 
357     /*
358      * Create a client thread which does simple SSLSocket operations.
359      * We&#39;ll write and read one data packet.
360      */
361     private Thread createClientThread(final int port,
362             final boolean serverClose) throws Exception {
363 
364         Thread t = new Thread(&quot;ClientThread&quot;) {
365 
366             @Override
367             public void run() {
368                 // client-side socket
369                 try (SSLSocket sslSocket = (SSLSocket)sslc.getSocketFactory().
370                             createSocket(&quot;localhost&quot;, port)) {
371                     OutputStream os = sslSocket.getOutputStream();
372                     InputStream is = sslSocket.getInputStream();
373 
374                     // write(byte[]) goes in one shot.
375                     os.write(clientMsg);
376 
377                     byte[] inbound = new byte[2048];
378                     int pos = 0;
379 
380                     int len;
381                     while ((len = is.read(inbound, pos, 2048 - pos)) != -1) {
382                         pos += len;
383                         // Let the client do the closing.
384                         if ((pos == serverMsg.length) &amp;&amp; !serverClose) {
385                             sslSocket.close();
386                             break;
387                         }
388                     }
389 
390                     if (pos != serverMsg.length) {
391                         throw new Exception(&quot;Client:  Data length error&quot;);
392                     }
393 
394                     for (int i = 0; i &lt; serverMsg.length; i++) {
395                         if (inbound[i] != serverMsg[i]) {
396                             throw new Exception(&quot;Client:  Data content error&quot;);
397                         }
398                     }
399                 } catch (Exception e) {
400                     clientException = e;
401                 }
402             }
403         };
404         t.start();
405         return t;
406     }
407 
408     /*
409      * Using the SSLContext created during object creation,
410      * create/configure the SSLEngines we&#39;ll use for this test.
411      */
412     private void createSSLEngine() throws Exception {
413         /*
414          * Configure the serverEngine to act as a server in the SSL/TLS
415          * handshake.
416          */
417         serverEngine = sslc.createSSLEngine();
418         serverEngine.setUseClientMode(false);
419         serverEngine.getNeedClientAuth();
420     }
421 
422     /*
423      * Create and size the buffers appropriately.
424      */
425     private void createBuffers(boolean direct) {
426 
427         SSLSession session = serverEngine.getSession();
428         int appBufferMax = session.getApplicationBufferSize();
429         int netBufferMax = session.getPacketBufferSize();
430 
431         /*
432          * We&#39;ll make the input buffers a bit bigger than the max needed
433          * size, so that unwrap()s following a successful data transfer
434          * won&#39;t generate BUFFER_OVERFLOWS.
435          *
436          * We&#39;ll use a mix of direct and indirect ByteBuffers for
437          * tutorial purposes only.  In reality, only use direct
438          * ByteBuffers when they give a clear performance enhancement.
439          */
440         if (direct) {
441             serverIn = ByteBuffer.allocateDirect(appBufferMax + 50);
442             cTOs = ByteBuffer.allocateDirect(netBufferMax);
443             sTOc = ByteBuffer.allocateDirect(netBufferMax);
444         } else {
445             serverIn = ByteBuffer.allocate(appBufferMax + 50);
446             cTOs = ByteBuffer.allocate(netBufferMax);
447             sTOc = ByteBuffer.allocate(netBufferMax);
448         }
449 
450         serverOut = ByteBuffer.wrap(serverMsg);
451     }
452 
453     /*
454      * If the result indicates that we have outstanding tasks to do,
455      * go ahead and run them in this thread.
456      */
457     private static void runDelegatedTasks(SSLEngineResult result,
458             SSLEngine engine) throws Exception {
459 
460         if (result.getHandshakeStatus() == HandshakeStatus.NEED_TASK) {
461             Runnable runnable;
462             while ((runnable = engine.getDelegatedTask()) != null) {
463                 log(&quot;\trunning delegated task...&quot;);
464                 runnable.run();
465             }
466             HandshakeStatus hsStatus = engine.getHandshakeStatus();
467             if (hsStatus == HandshakeStatus.NEED_TASK) {
468                 throw new Exception(
469                         &quot;handshake shouldn&#39;t need additional tasks&quot;);
470             }
471             log(&quot;\tnew HandshakeStatus: &quot; + hsStatus);
472         }
473     }
474 
475     private static boolean isEngineClosed(SSLEngine engine) {
476         return (engine.isOutboundDone() &amp;&amp; engine.isInboundDone());
477     }
478 
479     /*
480      * Logging code
481      */
482     private static boolean resultOnce = true;
483 
484     private static void log(String str, SSLEngineResult result) {
485         if (!logging) {
486             return;
487         }
488         if (resultOnce) {
489             resultOnce = false;
490             System.out.println(&quot;The format of the SSLEngineResult is: \n&quot;
491                     + &quot;\t\&quot;getStatus() / getHandshakeStatus()\&quot; +\n&quot;
492                     + &quot;\t\&quot;bytesConsumed() / bytesProduced()\&quot;\n&quot;);
493         }
494         HandshakeStatus hsStatus = result.getHandshakeStatus();
495         log(str
496                 + result.getStatus() + &quot;/&quot; + hsStatus + &quot;, &quot;
497                 + result.bytesConsumed() + &quot;/&quot; + result.bytesProduced()
498                 + &quot; bytes&quot;);
499         if (hsStatus == HandshakeStatus.FINISHED) {
500             log(&quot;\t...ready for application data&quot;);
501         }
502     }
503 
504     private static void log(String str) {
505         if (logging) {
506             System.out.println(str);
507         }
508     }
509 }
    </pre>
  </body>
</html>
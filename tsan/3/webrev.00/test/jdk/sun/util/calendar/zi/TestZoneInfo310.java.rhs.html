<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames test/jdk/sun/util/calendar/zi/TestZoneInfo310.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
<a name="1" id="anc1"></a><span class="line-modified">  2  * Copyright (c) 2012, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 /*
 25  * @test
<a name="2" id="anc2"></a><span class="line-modified"> 26  * @bug 8007572 8008161 8157792 8212970 8224560</span>
 27  * @summary Test whether the TimeZone generated from JSR310 tzdb is the same
 28  * as the one from the tz data from javazic
 29  * @modules java.base/sun.util.calendar:+open
 30  * @build BackEnd Checksum DayOfWeek Gen GenDoc Main Mappings Month
 31  *        Rule RuleDay RuleRec Simple TestZoneInfo310 Time Timezone
 32  *        TzIDOldMapping Zone ZoneInfoFile ZoneInfoOld ZoneRec Zoneinfo
 33  * @run main TestZoneInfo310
 34  */
 35 
 36 import java.io.File;
 37 import java.lang.reflect.*;
 38 import java.nio.file.*;
 39 import java.util.*;
 40 import java.util.regex.*;
 41 import java.time.zone.*;
 42 import java.time.ZoneId;
 43 
 44 public class TestZoneInfo310 {
 45 
 46     public static void main(String[] args) throws Throwable {
 47 
 48         String TESTDIR = System.getProperty(&quot;test.dir&quot;, &quot;.&quot;);
<a name="3" id="anc3"></a><span class="line-modified"> 49         Path tzdir = Paths.get(System.getProperty(&quot;test.root&quot;),</span>
<span class="line-modified"> 50             &quot;..&quot;, &quot;..&quot;, &quot;make&quot;, &quot;data&quot;, &quot;tzdata&quot;);</span>
<span class="line-modified"> 51         String tzfiles = &quot;africa antarctica asia australasia europe northamerica pacificnew southamerica backward etcetera systemv gmt&quot;;</span>
<span class="line-modified"> 52         Path jdk_tzdir = Paths.get(System.getProperty(&quot;test.src&quot;), &quot;tzdata_jdk&quot;);</span>
<span class="line-modified"> 53         String jdk_tzfiles = &quot;jdk11_backward&quot;;</span>
 54         String zidir = TESTDIR + File.separator + &quot;zi&quot;;
 55         File fZidir = new File(zidir);
 56         if (!fZidir.exists()) {
 57             fZidir.mkdirs();
 58         }
 59         Matcher m = Pattern.compile(&quot;tzdata(?&lt;ver&gt;[0-9]{4}[A-z])&quot;)
<a name="4" id="anc4"></a><span class="line-modified"> 60                            .matcher(new String(Files.readAllBytes(tzdir.resolve(&quot;VERSION&quot;)), &quot;ascii&quot;));</span>
 61         String ver = m.find() ? m.group(&quot;ver&quot;) : &quot;NULL&quot;;
 62 
 63         ArrayList&lt;String&gt; alist = new ArrayList&lt;&gt;();
 64         alist.add(&quot;-V&quot;);
 65         alist.add(ver);
 66         alist.add(&quot;-d&quot;);
 67         alist.add(zidir);
 68         for (String f : tzfiles.split(&quot; &quot;)) {
<a name="5" id="anc5"></a><span class="line-modified"> 69             alist.add(tzdir.resolve(f).toString());</span>
 70         }
 71         for (String f : jdk_tzfiles.split(&quot; &quot;)) {
<a name="6" id="anc6"></a><span class="line-modified"> 72             alist.add(jdk_tzdir.resolve(f).toString());</span>
 73         }
 74         System.out.println(&quot;Compiling tz files!&quot;);
 75         Main.main(alist.toArray(new String[alist.size()]));
 76 
 77         //////////////////////////////////
 78         System.out.println(&quot;testing!&quot;);
 79         ZoneInfoFile.ziDir = zidir;
 80         long t0, t1;
 81 
 82         t0 = System.nanoTime();
 83         ZoneInfoOld.getTimeZone(&quot;America/Los_Angeles&quot;);
 84         t1 = System.nanoTime();
 85         System.out.printf(&quot;OLD.getZoneInfoOld()[1]=%d%n&quot;, (t1 - t0) / 1000);
 86 
 87         t0 = System.nanoTime();
 88         ZoneInfoOld.getTimeZone(&quot;America/New_York&quot;);
 89         t1 = System.nanoTime();
 90         System.out.printf(&quot;OLD.getZoneInfoOld()[2]=%d%n&quot;, (t1 - t0) / 1000);
 91 
 92         t0 = System.nanoTime();
 93         ZoneInfoOld.getTimeZone(&quot;America/Denver&quot;);
 94         t1 = System.nanoTime();
 95         System.out.printf(&quot;OLD.getZoneInfoOld()[3]=%d%n&quot;, (t1 - t0) / 1000);
 96 
 97         t0 = System.nanoTime();
 98         String[] zids_old = ZoneInfoOld.getAvailableIDs();
 99         t1 = System.nanoTime();
100         System.out.printf(&quot;OLD.getAvailableIDs()=%d, total=%d%n&quot;,
101                           (t1 - t0) / 1000, zids_old.length);
102         Arrays.sort(zids_old);
103 
104         t0 = System.nanoTime();
105         String[] alias_old = ZoneInfoOld.getAliasTable()
106                                  .keySet().toArray(new String[0]);
107         t1 = System.nanoTime();
108         System.out.printf(&quot;OLD.getAliasTable()=%d, total=%d%n&quot;,
109                           (t1 - t0) / 1000, alias_old.length);
110         Arrays.sort(alias_old);
111 
112         t0 = System.currentTimeMillis();
113         for (String zid : zids_old) {
114             ZoneInfoOld.getTimeZone(zid);
115         }
116         t1 = System.currentTimeMillis();
117         System.out.printf(&quot;OLD.TotalTZ()=%d (ms)%n&quot;, t1 - t0);
118 
119 /*
120         t0 = System.nanoTime();
121         ZoneId.of(&quot;America/Los_Angeles&quot;).getRules();
122         t1 = System.nanoTime();
123         System.out.printf(&quot;NEW.ZoneId.of()[1]=%d%n&quot;, (t1 - t0) / 1000);
124 */
125         t0 = System.nanoTime();
126         TimeZone tz = TimeZone.getTimeZone(&quot;America/Los_Angeles&quot;);
127         t1 = System.nanoTime();
128         System.out.printf(&quot;NEW.getTimeZone()[1]=%d%n&quot;, (t1 - t0) / 1000);
129 
130         t0 = System.nanoTime();
131         tz = TimeZone.getTimeZone(&quot;America/New_York&quot;);
132         t1 = System.nanoTime();
133         System.out.printf(&quot;NEW.getTimeZone()[2]=%d%n&quot;, (t1 - t0) / 1000);
134 
135         t0 = System.nanoTime();
136         tz = TimeZone.getTimeZone(&quot;America/Denver&quot;);
137         t1 = System.nanoTime();
138         System.out.printf(&quot;NEW.getTimeZone()[3]=%d%n&quot;, (t1 - t0) / 1000);
139 
140         t0 = System.nanoTime();
141         String[] zids_new = TimeZone.getAvailableIDs();
142         t1 = System.nanoTime();
143         System.out.printf(&quot;NEW.getAvailableIDs()=%d, total=%d%n&quot;,
144                           (t1 - t0) / 1000, zids_new.length);
145         Arrays.sort(zids_new);
146 
147         t0 = System.nanoTime();
148         String[] alias_new = sun.util.calendar.ZoneInfo.getAliasTable()
149                                  .keySet().toArray(new String[0]);
150         t1 = System.nanoTime();
151         System.out.printf(&quot;NEW.getAliasTable()=%d, total=%d%n&quot;,
152                           (t1 - t0) / 1000, alias_new.length);
153         Arrays.sort(alias_new);
154 
155         t0 = System.currentTimeMillis();
156         for (String zid : zids_new) {
157             TimeZone.getTimeZone(zid);
158         }
159         t1 = System.currentTimeMillis();
160         System.out.printf(&quot;NEW.TotalTZ()=%d (ms)%n&quot;, t1 - t0);
161 
162         if (!Arrays.equals(zids_old, zids_new)) {
163             throw new RuntimeException(&quot;  FAILED:  availableIds don&#39;t match&quot;);
164         }
165 
166         if (!Arrays.equals(alias_old, alias_new)) {
167             throw new RuntimeException(&quot;  FAILED:  aliases don&#39;t match&quot;);
168         }
169 
170         for (String zid : zids_new) {
171             ZoneInfoOld zi = toZoneInfoOld(TimeZone.getTimeZone(zid));
172             ZoneInfoOld ziOLD = (ZoneInfoOld)ZoneInfoOld.getTimeZone(zid);
<a name="7" id="anc7"></a><span class="line-added">173             /*</span>
<span class="line-added">174              * Temporary ignoring the failing TimeZones which are having zone</span>
<span class="line-added">175              * rules defined till year 2037 and/or above and have negative DST</span>
<span class="line-added">176              * save time in IANA tzdata. This bug is tracked via JDK-8223388.</span>
<span class="line-added">177              *</span>
<span class="line-added">178              * These are the zones/rules that employ negative DST in vanguard</span>
<span class="line-added">179              * format (as of 2019a):</span>
<span class="line-added">180              *</span>
<span class="line-added">181              *  - Rule &quot;Eire&quot;</span>
<span class="line-added">182              *  - Rule &quot;Morocco&quot;</span>
<span class="line-added">183              *  - Rule &quot;Namibia&quot;</span>
<span class="line-added">184              *  - Zone &quot;Europe/Prague&quot;</span>
<span class="line-added">185              *</span>
<span class="line-added">186              * Tehran/Iran rule has rules beyond 2037, in which javazic assumes</span>
<span class="line-added">187              * to be the last year. Thus javazic&#39;s rule is based on year 2037</span>
<span class="line-added">188              * (Mar 20th/Sep 20th are the cutover dates), while the real rule</span>
<span class="line-added">189              * has year 2087 where Mar 21st/Sep 21st are the cutover dates.</span>
<span class="line-added">190              */</span>
<span class="line-added">191             if (zid.equals(&quot;Africa/Casablanca&quot;) || // uses &quot;Morocco&quot; rule</span>
<span class="line-added">192                 zid.equals(&quot;Africa/El_Aaiun&quot;) || // uses &quot;Morocco&quot; rule</span>
<span class="line-added">193                 zid.equals(&quot;Africa/Windhoek&quot;) || // uses &quot;Namibia&quot; rule</span>
<span class="line-added">194                 zid.equals(&quot;Eire&quot;) ||</span>
<span class="line-added">195                 zid.equals(&quot;Europe/Bratislava&quot;) || // link to &quot;Europe/Prague&quot;</span>
<span class="line-added">196                 zid.equals(&quot;Europe/Dublin&quot;) || // uses &quot;Eire&quot; rule</span>
<span class="line-added">197                 zid.equals(&quot;Europe/Prague&quot;) ||</span>
<span class="line-added">198                 zid.equals(&quot;Asia/Tehran&quot;) || // last rule mismatch</span>
<span class="line-added">199                 zid.equals(&quot;Iran&quot;)) { // last rule mismatch</span>
<span class="line-added">200                     continue;</span>
<span class="line-added">201             }</span>
202             if (! zi.equalsTo(ziOLD)) {
203                 System.out.println(zi.diffsTo(ziOLD));
204                 throw new RuntimeException(&quot;  FAILED:  &quot; + zid);
205             }
206         }
207         delete(fZidir);
208 
209         // test tzdb version
210         if (!ver.equals(sun.util.calendar.ZoneInfoFile.getVersion())) {
211             System.out.printf(&quot;  FAILED:  ver=%s, expected=%s%n&quot;,
212                               sun.util.calendar.ZoneInfoFile.getVersion(), ver);
213             throw new RuntimeException(&quot;Version test failed&quot;);
214         }
215 
216         // test getAvailableIDs(raw);
217         zids_new = TimeZone.getAvailableIDs(-8 * 60 * 60 * 1000);
218         //Arrays.sort(zids_new);
219         zids_old = ZoneInfoOld.getAvailableIDs(-8 * 60 * 60 * 1000);
220         if (!Arrays.equals(zids_new, zids_old)) {
221             System.out.println(&quot;------------------------&quot;);
222             System.out.println(&quot;NEW.getAvailableIDs(-8:00)&quot;);
223             for (String zid : zids_new) {
224                 System.out.println(zid);
225             }
226             System.out.println(&quot;------------------------&quot;);
227             System.out.println(&quot;OLD.getAvailableIDs(-8:00)&quot;);
228             for (String zid : zids_old) {
229                 System.out.println(zid);
230             }
231             throw new RuntimeException(&quot;  FAILED:  availableIds(offset) don&#39;t match&quot;);
232         }
233     }
234 
235     private static void delete(File f) {
236         if (f.isDirectory()) {
237             for (File f0 : f.listFiles()) {
238                delete(f0);
239             }
240         }
241         f.delete();
242      }
243 
244     // to access sun.util.calendar.ZoneInfo&#39;s private fields
245     static Class&lt;?&gt; ziClz;
246     static Field rawOffset;
247     static Field checksum;
248     static Field dstSavings;
249     static Field transitions;
250     static Field offsets;
251     static Field simpleTimeZoneParams;
252     static Field willGMTOffsetChange;
253     static {
254         try {
255             ziClz = Class.forName(&quot;sun.util.calendar.ZoneInfo&quot;);
256             rawOffset = ziClz.getDeclaredField(&quot;rawOffset&quot;);
257             checksum = ziClz.getDeclaredField(&quot;checksum&quot;);
258             dstSavings = ziClz.getDeclaredField(&quot;dstSavings&quot;);
259             transitions = ziClz.getDeclaredField(&quot;transitions&quot;);
260             offsets = ziClz.getDeclaredField(&quot;offsets&quot;);
261             simpleTimeZoneParams = ziClz.getDeclaredField(&quot;simpleTimeZoneParams&quot;);
262             willGMTOffsetChange = ziClz.getDeclaredField(&quot;willGMTOffsetChange&quot;);
263             rawOffset.setAccessible(true);
264             checksum.setAccessible(true);
265             dstSavings.setAccessible(true);
266             transitions.setAccessible(true);
267             offsets.setAccessible(true);
268             simpleTimeZoneParams.setAccessible(true);
269             willGMTOffsetChange.setAccessible(true);
270         } catch (Exception x) {
271             throw new RuntimeException(x);
272         }
273     }
274 
275     private static ZoneInfoOld toZoneInfoOld(TimeZone tz) throws Exception {
276         return new ZoneInfoOld(tz.getID(),
277                                rawOffset.getInt(tz),
278                                dstSavings.getInt(tz),
279                                checksum.getInt(tz),
280                                (long[])transitions.get(tz),
281                                (int[])offsets.get(tz),
282                                (int[])simpleTimeZoneParams.get(tz),
283                                willGMTOffsetChange.getBoolean(tz));
284     }
285 
286 
287 }
<a name="8" id="anc8"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="8" type="hidden" />
</body>
</html>
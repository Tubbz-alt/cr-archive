<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames test/jdk/sun/misc/SunMiscSignalTest.java</title>
    <link rel="stylesheet" href="../../../../style.css" />
    <script type="text/javascript" src="../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
<a name="1" id="anc1"></a><span class="line-modified">  2  * Copyright (c) 2016, 2018, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 import java.util.ArrayList;
 27 import java.util.List;
 28 import java.util.Objects;
 29 import java.util.concurrent.Semaphore;
 30 import java.util.concurrent.TimeUnit;
 31 
 32 import org.testng.Assert;
 33 import org.testng.TestNG;
 34 import org.testng.annotations.Test;
 35 import org.testng.annotations.BeforeSuite;
 36 import org.testng.annotations.DataProvider;
 37 
 38 import jdk.test.lib.Platform;
 39 import jdk.test.lib.Utils;
 40 
 41 import sun.misc.Signal;
 42 import sun.misc.SignalHandler;
 43 
 44 /*
 45  * @test
 46  * @library /test/lib
 47  * @modules jdk.unsupported
 48  *          java.base/jdk.internal.misc
 49  * @build jdk.test.lib.Utils
 50  *        jdk.test.lib.Asserts
 51  *        jdk.test.lib.JDKToolFinder
 52  *        jdk.test.lib.JDKToolLauncher
 53  *        jdk.test.lib.Platform
 54  *        jdk.test.lib.process.*
 55  * @run testng/othervm -Xrs -DXrs=true SunMiscSignalTest
 56  * @run testng/othervm SunMiscSignalTest
 57  * @summary sun.misc.Signal test
 58  */
 59 
 60 @Test
 61 public class SunMiscSignalTest {
 62 
 63     // Set to true to enable additional debug output
 64     static boolean debug = true;
 65 
 66     // True to test while running with -Xrs
 67     static boolean RUNNING_WITH_Xrs = Boolean.getBoolean(&quot;Xrs&quot;);
 68 
 69     /**
 70      * Print a debug message if enabled.
 71      *
 72      * @param format the format
 73      * @param args   the arguments
 74      */
 75     static void printf(String format, Object... args) {
 76         if (debug) {
 77             System.out.printf(&quot;    &quot; + format, args);
 78         }
 79     }
 80 
 81     enum IsSupported {NO, YES}
 82 
 83     enum CanRegister {NO, YES}
 84 
 85     enum CanRaise {NO, YES}
 86 
 87     enum Invoked {NO, YES}
 88 
 89     enum RestrictedSignals {NORMAL, XRS}
 90 
 91     @BeforeSuite
 92     static void setup() {
 93         System.out.printf(&quot;-Xrs: %s%n&quot;, RUNNING_WITH_Xrs);
 94     }
 95 
 96     // Provider of signals to be tested with variations for -Xrs and
 97     // platform dependencies
 98     // -Xrs restricted signals signals the VM will not handle SIGINT, SIGTERM, SIGHUP and others
 99     @DataProvider(name = &quot;supportedSignals&quot;)
100     static Object[][] supportedSignals() {
101         RestrictedSignals rs = RUNNING_WITH_Xrs ? RestrictedSignals.XRS : RestrictedSignals.NORMAL;
102         CanRegister registerXrs = RUNNING_WITH_Xrs ? CanRegister.NO : CanRegister.YES;
103         CanRaise raiseXrs = RUNNING_WITH_Xrs ? CanRaise.NO : CanRaise.YES;
104         Invoked invokedXrs = RUNNING_WITH_Xrs ? Invoked.NO : Invoked.YES;
105 
106         Object[][] commonSignals = new Object[][]{
107                 {&quot;INT&quot;,  IsSupported.YES, registerXrs, raiseXrs, invokedXrs},
108                 {&quot;TERM&quot;, IsSupported.YES, registerXrs, raiseXrs, invokedXrs},
109                 {&quot;ABRT&quot;, IsSupported.YES, CanRegister.YES, CanRaise.YES, invokedXrs},
110         };
111 
112         Object[][] posixSignals = {
113                 {&quot;HUP&quot;,  IsSupported.YES, registerXrs, raiseXrs, invokedXrs},
114                 {&quot;QUIT&quot;, IsSupported.YES, CanRegister.NO, CanRaise.NO, Invoked.NO},
115                 {&quot;USR1&quot;, IsSupported.YES, CanRegister.YES, CanRaise.YES, invokedXrs},
116                 {&quot;USR2&quot;, IsSupported.YES, CanRegister.YES, CanRaise.YES, invokedXrs},
117                 {&quot;PIPE&quot;, IsSupported.YES, CanRegister.YES, CanRaise.YES, invokedXrs},
118                 {&quot;ALRM&quot;, IsSupported.YES, CanRegister.YES, CanRaise.YES, invokedXrs},
119                 {&quot;CHLD&quot;, IsSupported.YES, CanRegister.YES, CanRaise.YES, invokedXrs},
120                 {&quot;CONT&quot;, IsSupported.YES, CanRegister.YES, CanRaise.YES, invokedXrs},
121                 {&quot;TSTP&quot;, IsSupported.YES, CanRegister.YES, CanRaise.YES, invokedXrs},
122                 {&quot;TTIN&quot;, IsSupported.YES, CanRegister.YES, CanRaise.YES, invokedXrs},
123                 {&quot;TTOU&quot;, IsSupported.YES, CanRegister.YES, CanRaise.YES, invokedXrs},
124                 {&quot;URG&quot;,  IsSupported.YES, CanRegister.YES, CanRaise.YES, invokedXrs},
125                 {&quot;XCPU&quot;, IsSupported.YES, CanRegister.YES, CanRaise.YES, invokedXrs},
126                 {&quot;XFSZ&quot;, IsSupported.YES, CanRegister.YES, CanRaise.YES, invokedXrs},
127                 {&quot;VTALRM&quot;, IsSupported.YES, CanRegister.YES, CanRaise.YES, invokedXrs},
128                 {&quot;PROF&quot;, IsSupported.YES, CanRegister.YES, CanRaise.YES, invokedXrs},
129                 {&quot;WINCH&quot;, IsSupported.YES, CanRegister.YES, CanRaise.YES, invokedXrs},
130                 {&quot;IO&quot;,   IsSupported.YES, CanRegister.YES, CanRaise.YES, invokedXrs},
131                 {&quot;SYS&quot;,   IsSupported.YES, CanRegister.YES, CanRaise.YES, invokedXrs},
132         };
133 
134         Object[][] posixNonOSXSignals = {
135                 {&quot;BUS&quot;,  IsSupported.YES, CanRegister.YES, CanRaise.YES, invokedXrs},
<a name="2" id="anc2"></a>
136         };
137 
138         Object[][] posixOSXSignals = {
139                 {&quot;BUS&quot;,  IsSupported.YES, CanRegister.NO, CanRaise.NO, Invoked.NO},
<a name="3" id="anc3"></a>
140         };
141 
142         Object[][] windowsSignals = {
143                 {&quot;HUP&quot;,  IsSupported.NO, CanRegister.NO, CanRaise.NO, Invoked.NO},
144                 {&quot;QUIT&quot;, IsSupported.NO, CanRegister.NO, CanRaise.NO, Invoked.NO},
145                 {&quot;BUS&quot;,  IsSupported.NO, CanRegister.NO, CanRaise.NO, Invoked.NO},
146                 {&quot;USR1&quot;, IsSupported.NO, CanRegister.NO, CanRaise.NO, Invoked.NO},
147                 {&quot;USR2&quot;, IsSupported.NO, CanRegister.NO, CanRaise.NO, Invoked.NO},
148                 {&quot;PIPE&quot;, IsSupported.NO, CanRegister.NO, CanRaise.NO, Invoked.NO},
149                 {&quot;ALRM&quot;, IsSupported.NO, CanRegister.NO, CanRaise.NO, Invoked.NO},
150                 {&quot;CHLD&quot;, IsSupported.NO, CanRegister.NO, CanRaise.NO, Invoked.NO},
151                 {&quot;CONT&quot;, IsSupported.NO, CanRegister.NO, CanRaise.NO, Invoked.NO},
152                 {&quot;TSTP&quot;, IsSupported.NO, CanRegister.NO, CanRaise.NO, Invoked.NO},
153                 {&quot;TTIN&quot;, IsSupported.NO, CanRegister.NO, CanRaise.NO, Invoked.NO},
154                 {&quot;TTOU&quot;, IsSupported.NO, CanRegister.NO, CanRaise.NO, Invoked.NO},
155                 {&quot;URG&quot;,  IsSupported.NO, CanRegister.NO, CanRaise.NO, Invoked.NO},
156                 {&quot;XCPU&quot;, IsSupported.NO, CanRegister.NO, CanRaise.NO, Invoked.NO},
157                 {&quot;XFSZ&quot;, IsSupported.NO, CanRegister.NO, CanRaise.NO, Invoked.NO},
158                 {&quot;VTALRM&quot;, IsSupported.NO, CanRegister.NO, CanRaise.NO, Invoked.NO},
159                 {&quot;PROF&quot;, IsSupported.NO, CanRegister.NO, CanRaise.NO, Invoked.NO},
160                 {&quot;WINCH&quot;, IsSupported.NO, CanRegister.NO, CanRaise.NO, Invoked.NO},
161                 {&quot;IO&quot;,   IsSupported.NO, CanRegister.NO, CanRaise.NO, Invoked.NO},
162                 {&quot;SYS&quot;,  IsSupported.NO, CanRegister.NO, CanRaise.NO, Invoked.NO},
163         };
164 
165         Object[][] combinedPosixSignals = concatArrays(posixSignals,
166                                                        (Platform.isOSX() ? posixOSXSignals : posixNonOSXSignals));
167         return concatArrays(commonSignals, (Platform.isWindows() ? windowsSignals : combinedPosixSignals));
168     }
169 
170     // Provider of invalid signal names
171     @DataProvider(name = &quot;invalidSunMiscSignalNames&quot;)
172     Object[][] invalidSunMiscSignalNames() {
173         return new Object[][]{
174                 {&quot;&quot;},
175                 {&quot;I&quot;},
176                 {&quot;SIG&quot;},
177                 {&quot;SIGabc&quot;},
178                 {&quot;SIGINT&quot;},     // prefix not allowed
179                 {&quot;abc&quot;},
180         };
181     }
182 
183     static Object[][] concatArrays(Object[][]... arrays) {
184         int l = 0;
185         for (Object[][] a : arrays) {
186             l += a.length;
187         }
188 
189         Object[][] newArray = new Object[l][];
190         l = 0;
191         for (int i = 0; i &lt; arrays.length; i++) {
192             System.arraycopy(arrays[i], 0, newArray, l, arrays[i].length);
193             l += arrays[i].length;
194         }
195 
196         return newArray;
197     }
198 
199     // Return true if the signal is one of the shutdown signals known to the VM
200     private static boolean isShutdownSignal(Signal signal) {
201         String name = signal.getName();
202         return name.equals(&quot;INT&quot;) || name.equals(&quot;HUP&quot;) || name.equals(&quot;TERM&quot;);
203     }
204 
205     /**
206      * Quick verification of supported signals using sun.misc.Signal.
207      *
208      * @param name the signal name
209      * @throws InterruptedException would be an error if thrown
210      */
211     @Test(dataProvider = &quot;supportedSignals&quot;)
212     static void testSunMisc(String name, IsSupported supported, CanRegister register,
213                             CanRaise raise, Invoked invoked) throws InterruptedException {
214         Handler h = new Handler();
215         SignalHandler orig = null;
216         Signal signal = null;
217         try {
218             signal = new Signal(name);
219             Assert.assertEquals(supported, IsSupported.YES, &quot;Unexpected support for &quot; + name);
220 
221             Assert.assertEquals(signal.getName(), name, &quot;getName() mismatch, &quot;);
222 
223             Assert.assertEquals(signal.toString(), &quot;SIG&quot; + name, &quot;toString() mismatch, &quot;);
224 
225             try {
226                 orig = Signal.handle(signal, h);
227                 printf(&quot;oldHandler: %s%n&quot;, orig);
228                 Assert.assertEquals(CanRegister.YES, register, &quot;Unexpected handle succeeded &quot; + name);
229                 try {
230                     Signal.raise(signal);
231                     Assert.assertEquals(CanRaise.YES, raise, &quot;Unexpected raise success for &quot; + name);
232                     Invoked inv = h.semaphore().tryAcquire(Utils.adjustTimeout(100L),
233                             TimeUnit.MILLISECONDS) ? Invoked.YES : Invoked.NO;
234                     if (!isShutdownSignal(signal)) {
235                         // Normal case
236                         Assert.assertEquals(inv, invoked, &quot;handler not invoked;&quot;);
237                     } else {
238                         if (orig == SignalHandler.SIG_IGN) {
239                             Assert.assertEquals(inv, Invoked.NO, &quot;handler should not be invoked&quot;);
240                         } else {
241                             Assert.assertEquals(inv, invoked, &quot;handler not invoked;&quot;);
242                         }
243                     }
244                 } catch (IllegalArgumentException uoe3) {
245                     Assert.assertNotEquals(CanRaise.YES, raise, &quot;raise failed for &quot; + name +
246                             &quot;: &quot; + uoe3.getMessage());
247                 }
248             } catch (IllegalArgumentException uoe2) {
249                 Assert.assertNotEquals(CanRegister.YES, register, &quot;handle failed for: &quot; + name +
250                         &quot;: &quot; + uoe2.getMessage());
251             }
252         } catch (IllegalArgumentException uoe) {
253             Assert.assertNotEquals(IsSupported.YES, supported, &quot;Support missing for &quot; + name +
254                     &quot;: &quot; + uoe.getMessage());
255             return;
256         } finally {
257             // Restore original signal handler
258             if (orig != null &amp;&amp; signal != null) {
259                 Signal.handle(signal, orig);
260             }
261         }
262     }
263 
264     // Test Signal is equal to itself and not equals to others
265     @Test(dataProvider = &quot;supportedSignals&quot;)
266     static void testEquals(String name, IsSupported supported, CanRegister register,
267                            CanRaise raise, Invoked invoked) {
268         Object[][] data = supportedSignals();
269         for (int i = 0; i &lt; data.length; i++) {
270             IsSupported otherSupported = (IsSupported) data[i][1];
271             if (supported == IsSupported.NO || otherSupported == IsSupported.NO) {
272                 continue;
273             }
274             String otherName = (String) data[i][0];
275 
276             Signal sig1 = new Signal(name);
277             Signal sig2 = new Signal(otherName);
278             if (name.equals(otherName)) {
279                 Assert.assertEquals(sig1, sig2, &quot;Equals failed; &quot;);
280                 Assert.assertEquals(sig1.hashCode(), sig2.hashCode(), &quot;HashCode wrong; &quot;);
281             } else {
282                 Assert.assertNotEquals(sig1, sig2, &quot;NotEquals failed; &quot;);
283                 Assert.assertNotEquals(sig1.hashCode(), sig2.hashCode(), &quot;HashCode wrong; &quot;);
284             }
285         }
286     }
287 
288     @Test(dataProvider = &quot;invalidSunMiscSignalNames&quot;)
289     static void testSunMiscIAE(String name) {
290         try {
291             new Signal(name);
292             Assert.fail(&quot;Should have thrown IAE for signal: &quot; + name);
293         } catch (IllegalArgumentException iae) {
294             Assert.assertEquals(iae.getMessage(), &quot;Unknown signal: &quot; + name, &quot;getMessage() incorrect; &quot;);
295         }
296     }
297 
298     // Note: JDK 8 did not check/throw NPE, passing null resulted in a segv
299     @Test(expectedExceptions = NullPointerException.class)
300     static void nullSignal() {
301         new Signal(null);
302     }
303 
304     // Test expected exception when raising a signal when no handler defined
305     @Test
306     static void testRaiseNoConsumer() {
307         Signal signal = new Signal(&quot;INT&quot;);
308         SignalHandler orig = null;
309         try {
310             orig = Signal.handle(signal, SignalHandler.SIG_DFL);
311             printf(&quot;oldHandler: %s%n&quot;, orig);
312             if (orig == SignalHandler.SIG_IGN) {
313                 // SIG_IGN for TERM means it cannot be handled
314                 return;
315             }
316             Signal.raise(signal);
317             Assert.fail(&quot;Should have thrown IllegalArgumentException&quot;);
318         } catch (IllegalArgumentException iae) {
319             printf(&quot;IAE message: %s%n&quot;, iae.getMessage());
320         } finally {
321             // Restore original signal handler
322             if (orig != null &amp;&amp; signal != null) {
323                 Signal.handle(signal, orig);
324             }
325         }
326     }
327 
328     /**
329      * The thread that runs the handler for sun.misc.Signal should be a
330      * Daemon thread.
331      */
332     @Test
333     static void isDaemonThread() throws InterruptedException {
334         if (RUNNING_WITH_Xrs) {
335             return;
336         }
337         Handler handler = new Handler();
338         Signal signal = new Signal(&quot;INT&quot;);
339         SignalHandler orig = Signal.handle(signal, handler);
340         printf(&quot;oldHandler: %s%n&quot;, orig);
341         if (orig == SignalHandler.SIG_IGN) {
342             // SIG_IGN for INT means it cannot be handled
343             return;
344         }
345 
346         Signal.raise(signal);
347         boolean handled = handler.semaphore()
348                 .tryAcquire(Utils.adjustTimeout(100L), TimeUnit.MILLISECONDS);
349         if (!handled) {
350             // For debug try again
351             printf(&quot;Second try to see signal&quot;);
352             handled = handler.semaphore()
353                     .tryAcquire(Utils.adjustTimeout(2L), TimeUnit.SECONDS);
354         }
355         Assert.assertEquals(handled, !RUNNING_WITH_Xrs,
356                 &quot;raising s.m.Signal did not get a callback;&quot;);
357 
358         Assert.assertTrue(handler.wasDaemon(), &quot;Thread.isDaemon running the handler; &quot;);
359     }
360 
361     // Check that trying to invoke SIG_DFL.handle throws UnsupportedOperationException.
362     @Test(expectedExceptions = UnsupportedOperationException.class)
363     static void cannotHandleSIGDFL() {
364         Signal signal = new Signal(&quot;INT&quot;);
365         Assert.assertNotNull(SignalHandler.SIG_DFL, &quot;SIG_DFL null; &quot;);
366         SignalHandler.SIG_DFL.handle(signal);
367     }
368 
369     // Check that trying to invoke SIG_IGN.handle throws UnsupportedOperationException.
370     @Test(expectedExceptions = UnsupportedOperationException.class)
371     static void cannotHandleSIGIGN() {
372         Signal signal = new Signal(&quot;INT&quot;);
373         Assert.assertNotNull(SignalHandler.SIG_IGN, &quot;SIG_IGN null; &quot;);
374         SignalHandler.SIG_IGN.handle(signal);
375     }
376 
377     // Check that setting a Signal handler returns the previous handler.
378     @Test()
379     static void checkLastHandler() {
380         if (RUNNING_WITH_Xrs) {
381             return;
382         }
383         Signal signal = new Signal(&quot;TERM&quot;);
384         Handler h1 = new Handler();
385         Handler h2 = new Handler();
386         SignalHandler orig = Signal.handle(signal, h1);
387         if (orig == SignalHandler.SIG_IGN) {
388             // SIG_IGN for TERM means it cannot be handled
389             return;
390         }
391 
392         try {
393             SignalHandler prev = Signal.handle(signal, h2);
394             Assert.assertSame(prev, h1, &quot;prev handler mismatch&quot;);
395 
396             prev = Signal.handle(signal, h1);
397             Assert.assertSame(prev, h2, &quot;prev handler mismatch&quot;);
398         } finally {
399             if (orig != null &amp;&amp; signal != null) {
400                 Signal.handle(signal, orig);
401             }
402         }
403     }
404 
405     /**
406      * Test Handler, a SignalHandler for Signal notifications.
407      * Signals a semaphore when invoked and records whether
408      * the thread calling the Handler was a daemon.
409      */
410     static class Handler implements SignalHandler {
411         // A semaphore to check for accept being called
412         Semaphore sema = new Semaphore(0);
413 
414         Boolean wasDaemon = null;
415 
416         Semaphore semaphore() {
417             return sema;
418         }
419 
420         synchronized Boolean wasDaemon() {
421             return wasDaemon;
422         }
423 
424         /**
425          * Releases the semaphore when called as SignalHandler.handle.
426          *
427          * @param signal the Signal that occurred
428          */
429         @Override
430         public void handle(Signal signal) {
431             synchronized (this) {
432                 wasDaemon = Thread.currentThread().isDaemon();
433             }
434             sema.release();
435             printf(&quot;sun.misc.handle sig: %s, num: %d%n&quot;, signal.getName(), signal.getNumber());
436         }
437 
438         public String toString() {
439             return &quot;Handler: sem: &quot; + sema.getQueueLength() +
440                     &quot;, wasDaemon: &quot; + Objects.toString(wasDaemon());
441         }
442     }
443 
444     // Main can be used to run the tests from the command line with only testng.jar.
445     @SuppressWarnings(&quot;raw_types&quot;)
446     @Test(enabled = false)
447     public static void main(String[] args) {
448         Class&lt;?&gt;[] testclass = {SunMiscSignalTest.class};
449         TestNG testng = new TestNG();
450         testng.setTestClasses(testclass);
451         testng.run();
452     }
453 
454 }
<a name="4" id="anc4"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="4" type="hidden" />
</body>
</html>
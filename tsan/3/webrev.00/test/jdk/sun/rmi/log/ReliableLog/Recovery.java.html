<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New test/jdk/sun/rmi/log/ReliableLog/Recovery.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 1998, 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 /*
 25  * @summary sanity test for log sudden-death and recovery
 26  * @run ignore Requires special hooks in ReliableLog not yet putback.
 27  */
 28 
 29 /* The ReliableLog uses three filenames and renaming to effect atomic
 30  * versionFile updates.  First, a newVersionFile (an intention list)
 31  * is written.  Next, the current versionFile is renamed to an
 32  * oldVersionFile (an undo list).  Finally, the newVersionFile is
 33  * renamed to the current versionFile, and the undo list is discarded.
 34  * If the current version file does not exist on restart, then
 35  * stability can always be restored by reading the oldVersionFile.
 36  *
 37  * This test uses little conditional bombs.  When a switch is flipped
 38  * in ReliableLog, the code will abort with an InternalError at a
 39  * particular point.  We then pretend to have come up from scratch and
 40  * recover from the bombed situation.
 41  */
 42 
 43 import java.io.File;
 44 import java.io.IOException;
 45 import java.io.PrintStream;
 46 import java.io.Serializable;
 47 import sun.rmi.log.LogHandler;
 48 import sun.rmi.log.ReliableLog;
 49 
 50 //import javasoft.sqe.harness.Status;
 51 //import javasoft.sqe.harness.Test;
 52 
 53 public class Recovery
 54     extends LogHandler
 55     implements Serializable //, Test
 56 {
 57     static private final String dir = &quot;./recovery_tmp&quot;;
 58 
 59     static public void main (String[] argv)
 60     {
 61         Recovery test = new Recovery();
 62         //Status status = test.run (argv, System.err, System.out);
 63         //status.exit();
 64         test.run (argv, System.err, System.out);
 65     }
 66 
 67     //public Status run (String argv[], PrintStream log, PrintStream out)
 68     public void run (String argv[], PrintStream lg, PrintStream out)
 69     {
 70         try {
 71             int size;
 72             int deathpoint;
 73             for (size = 1; size &lt; 256; size *= 2) {
 74                 for (deathpoint = 0; deathpoint &lt;= 8; deathpoint++) {
 75                     // Trash the log directory
 76                     try {
 77                         (new File(dir,&quot;Version_Number&quot;)).delete();
 78                     } catch (Exception e) {
 79                     }
 80                     try {
 81                         (new File(dir,&quot;New_Version_Number&quot;)).delete();
 82                     } catch (Exception e) {
 83                     }
 84                     try {
 85                         (new File(dir,&quot;Old_Version_Number&quot;)).delete();
 86                     } catch (Exception e) {
 87                     }
 88 
 89                     Recovery handler = new Recovery();
 90                     ReliableLog log;
 91                     log = new ReliableLog(dir, handler);
 92 
 93                     // Generate a number of updates (size - 1) until failing
 94                     int i;
 95                     StringBuffer writ = new StringBuffer();
 96                     char[] u = new char[1];
 97                     for (i = 1; i &lt; size; i++) {
 98                         u[0] = (char)(64 + (i % 26));
 99                         String update = new String(u);
100                         handler.basicUpdate(update);
101                         log.update(update, true);
102                         writ.append(update);
103                     }
104 
105                     // Fail
106                     String f = (&quot;FALL&quot; + deathpoint);
107                     boolean failed_as_desired = false;
108                     try {
109                         ReliableLog.fallOverPoint = deathpoint;
110                         handler.basicUpdate(f);
111                         log.update(f, true);
112                         log.snapshot(handler);
113                     } catch (InternalError e) {
114                         if (!e.getMessage().equals(f))
115                             throw e; // oops, not ours
116                         failed_as_desired = true;
117                     } finally {
118                         ReliableLog.fallOverPoint = 0;
119                         try {
120                             log.close();
121                         } catch (IOException ign) {
122                         }
123                     }
124 
125                     // deathpoint == 0 means that there is no deathpoint and we are testing
126                     // undisastered behaviour.
127                     if (!failed_as_desired &amp;&amp; deathpoint != 0) {
128                         System.err.println (&quot;sun.rmi.log.ReliableLog is not instrumented for&quot; +
129                                             &quot; this test; test skipped&quot;);
130                         return;
131                     }
132 
133                     // Now try to recover.
134                     Recovery laz = new Recovery();
135                     ReliableLog carbon = new ReliableLog(dir, laz);
136                     Recovery thingy;
137                     thingy = (Recovery)carbon.recover();
138                     try {
139                         carbon.close();
140                     } catch (IOException ign) {
141                     }
142 
143                     // Recovered thingy must be equal to writ or to writ + f, but nothing
144                     // else (or in between).
145                     String recovered = thingy.contents;
146                     String sacr = writ.toString();
147                     if (recovered.length() == sacr.length()
148                         &amp;&amp; recovered.compareTo(sacr) == 0)
149                     {
150                         lg.println(&quot;Passed test &quot; + size + &quot;/&quot; + deathpoint
151                                    + &quot;: rolled back to v1&quot;);
152                     } else if (recovered.length() == (sacr.length() + f.length())
153                                &amp;&amp; recovered.compareTo(sacr + f) == 0)
154                     {
155                         lg.println(&quot;Passed test &quot; + size + &quot;/&quot; + deathpoint
156                                    + &quot;: committed to v2&quot;);
157                     } else {
158                         final String q = &quot;\&quot;&quot;;
159                         lg.println(&quot;Wrote &quot; + sacr.length() + &quot;: &quot; + q + sacr + q);
160                         lg.println(&quot;Simulated failure during write &quot;
161                                    + f.length() + &quot;: &quot; + q + f + q);
162                         lg.println(&quot;Recovered &quot; + recovered.length() + &quot;: &quot; + q + recovered + q);
163                         throw new InternalError(&quot;Failed test &quot; + size + &quot;/&quot; + deathpoint
164                                    + &quot; (size/deathpoint):&quot;);
165                     }
166                 }
167             }
168         } catch (Exception e) {
169             e.printStackTrace(lg);
170             //return (Status.failed
171             throw (new RuntimeException
172                     (&quot;Exception in sanity test for sun.rmi.log.ReliableLog&quot;));
173         }
174         //return (Status.passed (&quot;OKAY&quot;));
175     }
176 
177     private String contents;
178     transient private StringBuffer trc = null;
179 
180     public Recovery()
181     {
182         super();
183         if (this.contents == null)
184             this.contents = &quot;?&quot;;
185     }
186 
187     // implements LogHandler.initialSnapshot()
188     public Object initialSnapshot()
189         throws Exception
190     {
191         this.contents = &quot;&quot;;
192         return (this);
193     }
194 
195     // implements LogHandler.applyUpdate()
196     public Object applyUpdate (Object update, Object state)
197         throws Exception
198     {
199         // basicUpdate appends the string
200         ((Recovery)state).basicUpdate ((String)update);
201         return (state);
202     }
203 
204     // an &quot;update&quot; is a short string to append to this.contents (must ignore state)
205     public void basicUpdate (String extra)
206     {
207         this.contents = this.contents + extra;
208     }
209 }
    </pre>
  </body>
</html>
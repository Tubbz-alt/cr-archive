<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff test/jdk/sun/java2d/marlin/ClipShapeTest.java</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
<body>
<center><a href="../cmm/ColorConvertOp/ConstructorsNullTest/ConstructorsNullTest.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="../pipe/hw/RSLAPITest/RSLAPITest.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>test/jdk/sun/java2d/marlin/ClipShapeTest.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  */
  23 import java.awt.BasicStroke;
  24 import java.awt.Color;
  25 import java.awt.Graphics2D;
  26 import java.awt.RenderingHints;
<span class="line-removed">  27 import java.awt.Shape;</span>
  28 import java.awt.Stroke;


  29 import java.awt.geom.Ellipse2D;

  30 import java.awt.geom.Path2D;
  31 import java.awt.geom.PathIterator;

  32 import java.awt.image.BufferedImage;
  33 import java.awt.image.DataBufferInt;
  34 import java.io.File;
  35 import java.io.FileOutputStream;
  36 import java.io.IOException;
  37 import java.util.Arrays;
  38 import java.util.Iterator;
  39 import java.util.Locale;
  40 import java.util.Random;
  41 import java.util.concurrent.atomic.AtomicBoolean;
  42 import java.util.concurrent.atomic.AtomicInteger;
  43 import java.util.logging.Handler;
  44 import java.util.logging.LogRecord;
  45 import java.util.logging.Logger;
  46 import javax.imageio.IIOImage;
  47 import javax.imageio.ImageIO;
  48 import javax.imageio.ImageWriteParam;
  49 import javax.imageio.ImageWriter;
  50 import javax.imageio.stream.ImageOutputStream;
  51 
  52 /**
  53  * @test
  54  * @bug 8191814
  55  * @summary Verifies that Marlin rendering generates the same
  56  * images with and without clipping optimization with all possible
  57  * stroke (cap/join) and/or dashes or fill modes (EO rules)
  58  * for paths made of either 9 lines, 4 quads, 2 cubics (random)
  59  * Note: Use the argument -slow to run more intensive tests (too much time)
  60  *
  61  * @run main/othervm/timeout=300 -Dsun.java2d.renderer=sun.java2d.marlin.MarlinRenderingEngine ClipShapeTest -poly
  62  * @run main/othervm/timeout=300 -Dsun.java2d.renderer=sun.java2d.marlin.MarlinRenderingEngine ClipShapeTest -poly -doDash
  63  * @run main/othervm/timeout=300 -Dsun.java2d.renderer=sun.java2d.marlin.MarlinRenderingEngine ClipShapeTest -cubic
  64  * @run main/othervm/timeout=300 -Dsun.java2d.renderer=sun.java2d.marlin.MarlinRenderingEngine ClipShapeTest -cubic -doDash
  65  * @run main/othervm/timeout=300 -Dsun.java2d.renderer=sun.java2d.marlin.DMarlinRenderingEngine ClipShapeTest -poly
  66  * @run main/othervm/timeout=300 -Dsun.java2d.renderer=sun.java2d.marlin.DMarlinRenderingEngine ClipShapeTest -poly -doDash
  67  * @run main/othervm/timeout=300 -Dsun.java2d.renderer=sun.java2d.marlin.DMarlinRenderingEngine ClipShapeTest -cubic
  68  * @run main/othervm/timeout=300 -Dsun.java2d.renderer=sun.java2d.marlin.DMarlinRenderingEngine ClipShapeTest -cubic -doDash
  69 */
  70 public final class ClipShapeTest {
  71 
<span class="line-modified">  72     static boolean TX_SCALE = false;</span>
<span class="line-modified">  73     static boolean TX_SHEAR = false;</span>












  74 
  75     static final boolean TEST_STROKER = true;
  76     static final boolean TEST_FILLER = true;
  77 
<span class="line-modified">  78     // complementary tests in slow mode:</span>
<span class="line-modified">  79     static boolean USE_DASHES = false;</span>
<span class="line-modified">  80     static boolean USE_VAR_STROKE = false;</span>
  81 
<span class="line-removed">  82     static int NUM_TESTS = 5000;</span>
  83     static final int TESTW = 100;
  84     static final int TESTH = 100;
  85 
<span class="line-removed">  86     // shape settings:</span>
<span class="line-removed">  87     static ShapeMode SHAPE_MODE = ShapeMode.NINE_LINE_POLYS;</span>
<span class="line-removed">  88 </span>
<span class="line-removed">  89     static int THRESHOLD_DELTA;</span>
<span class="line-removed">  90     static long THRESHOLD_NBPIX;</span>
<span class="line-removed">  91 </span>
<span class="line-removed">  92     static final boolean SHAPE_REPEAT = true;</span>
<span class="line-removed">  93 </span>
  94     // dump path on console:
  95     static final boolean DUMP_SHAPE = true;
  96 
  97     static final boolean SHOW_DETAILS = false; // disabled
  98     static final boolean SHOW_OUTLINE = true;
  99     static final boolean SHOW_POINTS = true;
 100     static final boolean SHOW_INFO = false;
 101 
 102     static final int MAX_SHOW_FRAMES = 10;
 103     static final int MAX_SAVE_FRAMES = 100;
 104 
 105     // use fixed seed to reproduce always same polygons between tests
<span class="line-modified"> 106     static final boolean FIXED_SEED = false;</span>

 107     static final double RAND_SCALE = 3.0;
 108     static final double RANDW = TESTW * RAND_SCALE;
 109     static final double OFFW = (TESTW - RANDW) / 2.0;
 110     static final double RANDH = TESTH * RAND_SCALE;
 111     static final double OFFH = (TESTH - RANDH) / 2.0;
 112 
 113     static enum ShapeMode {
 114         TWO_CUBICS,
 115         FOUR_QUADS,
 116         FIVE_LINE_POLYS,
 117         NINE_LINE_POLYS,
 118         FIFTY_LINE_POLYS,
 119         MIXED
 120     }
 121 
 122     static final long SEED = 1666133789L;
 123     // Fixed seed to avoid any difference between runs:
 124     static final Random RANDOM = new Random(SEED);
 125 
 126     static final File OUTPUT_DIR = new File(&quot;.&quot;);
 127 
 128     static final AtomicBoolean isMarlin = new AtomicBoolean();

 129     static final AtomicBoolean isClipRuntime = new AtomicBoolean();
 130 
 131     static {
 132         Locale.setDefault(Locale.US);
 133 
 134         // FIRST: Get Marlin runtime state from its log:
 135 
 136         // initialize j.u.l Looger:
 137         final Logger log = Logger.getLogger(&quot;sun.java2d.marlin&quot;);
 138         log.addHandler(new Handler() {
 139             @Override
 140             public void publish(LogRecord record) {
 141                 final String msg = record.getMessage();
 142                 if (msg != null) {
 143                     // last space to avoid matching other settings:
 144                     if (msg.startsWith(&quot;sun.java2d.renderer &quot;)) {
 145                         isMarlin.set(msg.contains(&quot;MarlinRenderingEngine&quot;));

 146                     }
 147                     if (msg.startsWith(&quot;sun.java2d.renderer.clip.runtime.enable&quot;)) {
 148                         isClipRuntime.set(msg.contains(&quot;true&quot;));
 149                     }
 150                 }
 151 
 152                 final Throwable th = record.getThrown();
 153                 // detect any Throwable:
 154                 if (th != null) {
 155                     System.out.println(&quot;Test failed:\n&quot; + record.getMessage());
 156                     th.printStackTrace(System.out);
 157 
 158                     throw new RuntimeException(&quot;Test failed: &quot;, th);
 159                 }
 160             }
 161 
 162             @Override
 163             public void flush() {
 164             }
 165 
</pre>
<hr />
<pre>
 169         });
 170 
 171         // enable Marlin logging &amp; internal checks:
 172         System.setProperty(&quot;sun.java2d.renderer.log&quot;, &quot;true&quot;);
 173         System.setProperty(&quot;sun.java2d.renderer.useLogger&quot;, &quot;true&quot;);
 174 
 175         // disable static clipping setting:
 176         System.setProperty(&quot;sun.java2d.renderer.clip&quot;, &quot;false&quot;);
 177         System.setProperty(&quot;sun.java2d.renderer.clip.runtime.enable&quot;, &quot;true&quot;);
 178 
 179         // enable subdivider:
 180         System.setProperty(&quot;sun.java2d.renderer.clip.subdivider&quot;, &quot;true&quot;);
 181 
 182         // disable min length check: always subdivide curves at clip edges
 183         System.setProperty(&quot;sun.java2d.renderer.clip.subdivider.minLength&quot;, &quot;-1&quot;);
 184 
 185         // If any curve, increase curve accuracy:
 186         // curve length max error:
 187         System.setProperty(&quot;sun.java2d.renderer.curve_len_err&quot;, &quot;1e-4&quot;);
 188 




 189         // quad max error:
 190         System.setProperty(&quot;sun.java2d.renderer.quad_dec_d2&quot;, &quot;5e-4&quot;);

 191 
<span class="line-modified"> 192         // cubic min/max error:</span>
<span class="line-modified"> 193         System.setProperty(&quot;sun.java2d.renderer.cubic_dec_d2&quot;, &quot;1e-3&quot;);</span>
<span class="line-modified"> 194         System.setProperty(&quot;sun.java2d.renderer.cubic_inc_d1&quot;, &quot;1e-4&quot;); // or disabled ~ 1e-6</span>





 195     }
 196 
 197     /**
 198      * Test
 199      * @param args
 200      */
 201     public static void main(String[] args) {
























 202         boolean runSlowTests = false;
 203 
 204         for (String arg : args) {
 205             if (&quot;-slow&quot;.equals(arg)) {
<span class="line-removed"> 206                 System.out.println(&quot;slow: enabled.&quot;);</span>
 207                 runSlowTests = true;
<span class="line-removed"> 208             } else if (&quot;-doScale&quot;.equals(arg)) {</span>
<span class="line-removed"> 209                 System.out.println(&quot;doScale: enabled.&quot;);</span>
<span class="line-removed"> 210                 TX_SCALE = true;</span>
<span class="line-removed"> 211             } else if (&quot;-doShear&quot;.equals(arg)) {</span>
<span class="line-removed"> 212                 System.out.println(&quot;doShear: enabled.&quot;);</span>
<span class="line-removed"> 213                 TX_SHEAR = true;</span>
 214             } else if (&quot;-doDash&quot;.equals(arg)) {
<span class="line-removed"> 215                 System.out.println(&quot;doDash: enabled.&quot;);</span>
 216                 USE_DASHES = true;
 217             } else if (&quot;-doVarStroke&quot;.equals(arg)) {
<span class="line-removed"> 218                 System.out.println(&quot;doVarStroke: enabled.&quot;);</span>
 219                 USE_VAR_STROKE = true;
<span class="line-modified"> 220             }</span>
<span class="line-modified"> 221             // shape mode:</span>
<span class="line-modified"> 222             else if (arg.equalsIgnoreCase(&quot;-poly&quot;)) {</span>
<span class="line-modified"> 223                 SHAPE_MODE = ShapeMode.NINE_LINE_POLYS;</span>
<span class="line-modified"> 224             } else if (arg.equalsIgnoreCase(&quot;-bigpoly&quot;)) {</span>
<span class="line-modified"> 225                 SHAPE_MODE = ShapeMode.FIFTY_LINE_POLYS;</span>
<span class="line-modified"> 226             } else if (arg.equalsIgnoreCase(&quot;-quad&quot;)) {</span>
<span class="line-modified"> 227                 SHAPE_MODE = ShapeMode.FOUR_QUADS;</span>
<span class="line-modified"> 228             } else if (arg.equalsIgnoreCase(&quot;-cubic&quot;)) {</span>
<span class="line-modified"> 229                 SHAPE_MODE = ShapeMode.TWO_CUBICS;</span>
<span class="line-modified"> 230             } else if (arg.equalsIgnoreCase(&quot;-mixed&quot;)) {</span>
<span class="line-modified"> 231                 SHAPE_MODE = ShapeMode.MIXED;</span>

 232             }
 233         }
 234 
 235         System.out.println(&quot;Shape mode: &quot; + SHAPE_MODE);
 236 
 237         // adjust image comparison thresholds:
<span class="line-modified"> 238         switch(SHAPE_MODE) {</span>
 239             case TWO_CUBICS:
 240                 // Define uncertainty for curves:
<span class="line-modified"> 241                 THRESHOLD_DELTA = 32; //  / 256</span>
<span class="line-modified"> 242                 THRESHOLD_NBPIX = 128; //  / 10000</span>



 243                 break;
 244             case FOUR_QUADS:
 245             case MIXED:
 246                 // Define uncertainty for quads:
 247                 // curve subdivision causes curves to be smaller
 248                 // then curve offsets are different (more accurate)
<span class="line-modified"> 249                 THRESHOLD_DELTA = 64;  // 64 / 256</span>
<span class="line-modified"> 250                 THRESHOLD_NBPIX = 256; // 256 / 10000</span>



 251                 break;
 252             default:
 253                 // Define uncertainty for lines:
 254                 // float variant have higher uncertainty
<span class="line-modified"> 255                 THRESHOLD_DELTA = 8;</span>
<span class="line-modified"> 256                 THRESHOLD_NBPIX = 8;</span>



 257         }
 258 
<span class="line-modified"> 259         System.out.println(&quot;THRESHOLD_DELTA: &quot;+THRESHOLD_DELTA);</span>
<span class="line-modified"> 260         System.out.println(&quot;THRESHOLD_NBPIX: &quot;+THRESHOLD_NBPIX);</span>



 261 
 262         if (runSlowTests) {
 263             NUM_TESTS = 10000; // or 100000 (very slow)
<span class="line-removed"> 264             USE_DASHES = true;</span>
 265             USE_VAR_STROKE = true;
 266         }
 267 
<span class="line-modified"> 268         System.out.println(&quot;ClipShapeTests: image = &quot; + TESTW + &quot; x &quot; + TESTH);</span>















 269 
 270         int failures = 0;
 271         final long start = System.nanoTime();
 272         try {
<span class="line-removed"> 273             // TODO: test affine transforms ?</span>
<span class="line-removed"> 274 </span>
 275             if (TEST_STROKER) {
 276                 final float[][] dashArrays = (USE_DASHES) ?
 277 // small
 278 //                        new float[][]{new float[]{1f, 2f}}
 279 // normal
 280                         new float[][]{new float[]{13f, 7f}}
 281 // large (prime)
 282 //                        new float[][]{new float[]{41f, 7f}}
 283 // none
 284                         : new float[][]{null};
 285 
 286                 System.out.println(&quot;dashes: &quot; + Arrays.deepToString(dashArrays));
 287 
 288                 final float[] strokeWidths = (USE_VAR_STROKE)
 289                                                 ? new float[5] :
 290                                                   new float[]{10f};
 291 
 292                 int nsw = 0;
 293                 if (USE_VAR_STROKE) {
<span class="line-modified"> 294                     for (float width = 0.1f; width &lt; 110f; width *= 5f) {</span>
 295                         strokeWidths[nsw++] = width;
 296                     }
 297                 } else {
 298                     nsw = 1;
 299                 }
 300 
 301                 System.out.println(&quot;stroke widths: &quot; + Arrays.toString(strokeWidths));
 302 
 303                 // Stroker tests:
 304                 for (int w = 0; w &lt; nsw; w++) {
 305                     final float width = strokeWidths[w];
 306 
 307                     for (float[] dashes : dashArrays) {
 308 
 309                         for (int cap = 0; cap &lt;= 2; cap++) {
 310 
 311                             for (int join = 0; join &lt;= 2; join++) {
 312 
<span class="line-modified"> 313                                 failures += paintPaths(new TestSetup(SHAPE_MODE, false, width, cap, join, dashes));</span>
<span class="line-modified"> 314                                 failures += paintPaths(new TestSetup(SHAPE_MODE, true, width, cap, join, dashes));</span>
 315                             }
 316                         }
 317                     }
 318                 }
 319             }
 320 
 321             if (TEST_FILLER) {
 322                 // Filler tests:
<span class="line-modified"> 323                 failures += paintPaths(new TestSetup(SHAPE_MODE, false, Path2D.WIND_NON_ZERO));</span>
<span class="line-modified"> 324                 failures += paintPaths(new TestSetup(SHAPE_MODE, true, Path2D.WIND_NON_ZERO));</span>
 325 
<span class="line-modified"> 326                 failures += paintPaths(new TestSetup(SHAPE_MODE, false, Path2D.WIND_EVEN_ODD));</span>
<span class="line-modified"> 327                 failures += paintPaths(new TestSetup(SHAPE_MODE, true, Path2D.WIND_EVEN_ODD));</span>
 328             }
 329         } catch (IOException ioe) {
 330             throw new RuntimeException(ioe);
 331         }
 332         System.out.println(&quot;main: duration= &quot; + (1e-6 * (System.nanoTime() - start)) + &quot; ms.&quot;);
 333 
<span class="line-modified"> 334         if (!isMarlin.get()) {</span>
<span class="line-modified"> 335             throw new RuntimeException(&quot;Marlin renderer not used at runtime !&quot;);</span>
<span class="line-modified"> 336         }</span>
<span class="line-modified"> 337         if (!isClipRuntime.get()) {</span>
<span class="line-removed"> 338             throw new RuntimeException(&quot;Marlin clipping not enabled at runtime !&quot;);</span>
<span class="line-removed"> 339         }</span>
<span class="line-removed"> 340         if (failures != 0) {</span>
 341             throw new RuntimeException(&quot;Clip test failures : &quot; + failures);
 342         }
 343     }
 344 
<span class="line-modified"> 345     static int paintPaths(final TestSetup ts) throws IOException {</span>
 346         final long start = System.nanoTime();
 347 
 348         if (FIXED_SEED) {
 349             // Reset seed for random numbers:
 350             RANDOM.setSeed(SEED);
 351         }
 352 
 353         System.out.println(&quot;paintPaths: &quot; + NUM_TESTS
 354                 + &quot; paths (&quot; + SHAPE_MODE + &quot;) - setup: &quot; + ts);
 355 
 356         final boolean fill = !ts.isStroke();
 357         final Path2D p2d = new Path2D.Double(ts.windingRule);
 358 


 359         final BufferedImage imgOn = newImage(TESTW, TESTH);
<span class="line-modified"> 360         final Graphics2D g2dOn = initialize(imgOn, ts);</span>
 361 
 362         final BufferedImage imgOff = newImage(TESTW, TESTH);
<span class="line-modified"> 363         final Graphics2D g2dOff = initialize(imgOff, ts);</span>
 364 
 365         final BufferedImage imgDiff = newImage(TESTW, TESTH);
 366 
<span class="line-modified"> 367         final DiffContext globalCtx = new DiffContext(&quot;All tests&quot;);</span>


 368 
 369         int nd = 0;
 370         try {
 371             final DiffContext testCtx = new DiffContext(&quot;Test&quot;);

 372             BufferedImage diffImage;
 373 
 374             for (int n = 0; n &lt; NUM_TESTS; n++) {
 375                 genShape(p2d, ts);
 376 
 377                 // Runtime clip setting OFF:
 378                 paintShape(p2d, g2dOff, fill, false);
 379 
 380                 // Runtime clip setting ON:
 381                 paintShape(p2d, g2dOn, fill, true);
 382 
 383                 /* compute image difference if possible */
<span class="line-modified"> 384                 diffImage = computeDiffImage(testCtx, imgOn, imgOff, imgDiff, globalCtx);</span>
<span class="line-removed"> 385 </span>
<span class="line-removed"> 386                 final String testName = &quot;Setup_&quot; + ts.id + &quot;_test_&quot; + n;</span>
 387 











 388                 if (diffImage != null) {
 389                     nd++;
 390 
<span class="line-modified"> 391                     final double ratio = (100.0 * testCtx.histPix.count) / testCtx.histAll.count;</span>
<span class="line-modified"> 392                     System.out.println(&quot;Diff ratio: &quot; + testName + &quot; = &quot; + trimTo3Digits(ratio) + &quot; %&quot;);</span>
 393 
 394                     if (nd &lt; MAX_SHOW_FRAMES) {
 395                         if (SHOW_DETAILS) {
 396                             paintShapeDetails(g2dOff, p2d);
 397                             paintShapeDetails(g2dOn, p2d);
 398                         }
 399 
 400                         if (nd &lt; MAX_SAVE_FRAMES) {
 401                             if (DUMP_SHAPE) {
 402                                 dumpShape(p2d);
 403                             }



 404                             saveImage(imgOff, OUTPUT_DIR, testName + &quot;-off.png&quot;);
 405                             saveImage(imgOn, OUTPUT_DIR, testName + &quot;-on.png&quot;);
<span class="line-modified"> 406                             saveImage(diffImage, OUTPUT_DIR, testName + &quot;-diff.png&quot;);</span>
 407                         }
 408                     }
 409                 }
 410             }
 411         } finally {
 412             g2dOff.dispose();
 413             g2dOn.dispose();
 414 
 415             if (nd != 0) {
 416                 System.out.println(&quot;paintPaths: &quot; + NUM_TESTS + &quot; paths - &quot;
 417                         + &quot;Number of differences = &quot; + nd
 418                         + &quot; ratio = &quot; + (100f * nd) / NUM_TESTS + &quot; %&quot;);
 419             }
 420 
<span class="line-modified"> 421             globalCtx.dump();</span>












 422         }
 423         System.out.println(&quot;paintPaths: duration= &quot; + (1e-6 * (System.nanoTime() - start)) + &quot; ms.&quot;);
 424         return nd;
 425     }
 426 
<span class="line-modified"> 427     private static void paintShape(final Path2D p2d, final Graphics2D g2d,</span>
 428                                    final boolean fill, final boolean clip) {
 429         reset(g2d);
 430 
 431         setClip(g2d, clip);
 432 
 433         if (fill) {
 434             g2d.fill(p2d);
 435         } else {
 436             g2d.draw(p2d);
 437         }
 438     }
 439 
 440     private static Graphics2D initialize(final BufferedImage img,
<span class="line-modified"> 441                                          final TestSetup ts) {</span>
 442         final Graphics2D g2d = (Graphics2D) img.getGraphics();
 443         g2d.setRenderingHint(RenderingHints.KEY_RENDERING,
 444                 RenderingHints.VALUE_RENDER_QUALITY);
 445         g2d.setRenderingHint(RenderingHints.KEY_STROKE_CONTROL,
<span class="line-modified"> 446                 RenderingHints.VALUE_STROKE_PURE);</span>



 447 
<span class="line-modified"> 448         if (ts.isStroke()) {</span>
<span class="line-modified"> 449             g2d.setStroke(createStroke(ts));</span>
<span class="line-removed"> 450         }</span>
<span class="line-removed"> 451         g2d.setColor(Color.GRAY);</span>
<span class="line-removed"> 452 </span>
<span class="line-removed"> 453         // Test scale</span>
<span class="line-removed"> 454         if (TX_SCALE) {</span>
<span class="line-removed"> 455             g2d.scale(1.2, 1.2);</span>
<span class="line-removed"> 456         }</span>
<span class="line-removed"> 457         // Test shear</span>
<span class="line-removed"> 458         if (TX_SHEAR) {</span>
<span class="line-removed"> 459             g2d.shear(0.1, 0.2);</span>
 460         }

 461 
 462         return g2d;
 463     }
 464 
 465     private static void reset(final Graphics2D g2d) {
 466         // Disable antialiasing:
 467         g2d.setRenderingHint(RenderingHints.KEY_ANTIALIASING,
 468                 RenderingHints.VALUE_ANTIALIAS_OFF);
 469         g2d.setBackground(Color.WHITE);
 470         g2d.clearRect(0, 0, TESTW, TESTH);
 471     }
 472 
 473     private static void setClip(final Graphics2D g2d, final boolean clip) {
 474         // Enable antialiasing:
 475         g2d.setRenderingHint(RenderingHints.KEY_ANTIALIASING,
 476                 RenderingHints.VALUE_ANTIALIAS_ON);
 477 
 478         // Enable or Disable clipping:
 479         System.setProperty(&quot;sun.java2d.renderer.clip.runtime&quot;, (clip) ? &quot;true&quot; : &quot;false&quot;);
 480     }
 481 
 482     static void genShape(final Path2D p2d, final TestSetup ts) {
 483         p2d.reset();
 484 
<span class="line-modified"> 485         final int end = (SHAPE_REPEAT) ? 2 : 1;</span>









 486 
 487         for (int p = 0; p &lt; end; p++) {
<span class="line-modified"> 488             p2d.moveTo(randX(), randY());</span>




 489 
 490             switch (ts.shapeMode) {
 491                 case MIXED:
<span class="line-removed"> 492                 case FIFTY_LINE_POLYS:</span>
<span class="line-removed"> 493                 case NINE_LINE_POLYS:</span>
 494                 case FIVE_LINE_POLYS:


 495                     p2d.lineTo(randX(), randY());
 496                     p2d.lineTo(randX(), randY());
 497                     p2d.lineTo(randX(), randY());
 498                     p2d.lineTo(randX(), randY());


 499                     if (ts.shapeMode == ShapeMode.FIVE_LINE_POLYS) {
 500                         // And an implicit close makes 5 lines
 501                         break;
 502                     }
 503                     p2d.lineTo(randX(), randY());
 504                     p2d.lineTo(randX(), randY());
 505                     p2d.lineTo(randX(), randY());
<span class="line-modified"> 506                     p2d.lineTo(randX(), randY());</span>

 507                     if (ts.shapeMode == ShapeMode.NINE_LINE_POLYS) {
 508                         // And an implicit close makes 9 lines
 509                         break;
 510                     }
 511                     if (ts.shapeMode == ShapeMode.FIFTY_LINE_POLYS) {
 512                         for (int i = 0; i &lt; 41; i++) {
<span class="line-modified"> 513                             p2d.lineTo(randX(), randY());</span>

 514                         }
 515                         // And an implicit close makes 50 lines
 516                         break;
 517                     }
 518                 case TWO_CUBICS:
<span class="line-modified"> 519                     p2d.curveTo(randX(), randY(), randX(), randY(), randX(), randY());</span>
<span class="line-modified"> 520                     p2d.curveTo(randX(), randY(), randX(), randY(), randX(), randY());</span>

















 521                     if (ts.shapeMode == ShapeMode.TWO_CUBICS) {
 522                         break;
 523                     }
 524                 case FOUR_QUADS:
<span class="line-modified"> 525                     p2d.quadTo(randX(), randY(), randX(), randY());</span>
<span class="line-modified"> 526                     p2d.quadTo(randX(), randY(), randX(), randY());</span>
<span class="line-modified"> 527                     p2d.quadTo(randX(), randY(), randX(), randY());</span>
<span class="line-modified"> 528                     p2d.quadTo(randX(), randY(), randX(), randY());</span>



























 529                     if (ts.shapeMode == ShapeMode.FOUR_QUADS) {
 530                         break;
 531                     }
 532                 default:
 533             }
 534 
 535             if (ts.closed) {
 536                 p2d.closePath();









































































































 537             }
 538         }
 539     }
 540 
 541     static final float POINT_RADIUS = 2f;
 542     static final float LINE_WIDTH = 1f;
 543 
 544     static final Stroke OUTLINE_STROKE = new BasicStroke(LINE_WIDTH);
 545     static final int COLOR_ALPHA = 128;
 546     static final Color COLOR_MOVETO = new Color(255, 0, 0, COLOR_ALPHA);
 547     static final Color COLOR_LINETO_ODD = new Color(0, 0, 255, COLOR_ALPHA);
 548     static final Color COLOR_LINETO_EVEN = new Color(0, 255, 0, COLOR_ALPHA);
 549 
 550     static final Ellipse2D.Float ELL_POINT = new Ellipse2D.Float();
 551 
 552     private static void paintShapeDetails(final Graphics2D g2d, final Shape shape) {
 553 
 554         final Stroke oldStroke = g2d.getStroke();
 555         final Color oldColor = g2d.getColor();
 556 
</pre>
<hr />
<pre>
 737 
 738         private static String getWindingRule(final int rule) {
 739             switch (rule) {
 740                 case PathIterator.WIND_EVEN_ODD:
 741                     return &quot;WIND_EVEN_ODD&quot;;
 742                 case PathIterator.WIND_NON_ZERO:
 743                     return &quot;WIND_NON_ZERO&quot;;
 744                 default:
 745                     return &quot;&quot;;
 746             }
 747         }
 748     }
 749 
 750     // --- utilities ---
 751     private static final int DCM_ALPHA_MASK = 0xff000000;
 752 
 753     public static BufferedImage newImage(final int w, final int h) {
 754         return new BufferedImage(w, h, BufferedImage.TYPE_INT_ARGB_PRE);
 755     }
 756 
<span class="line-modified"> 757     public static BufferedImage computeDiffImage(final DiffContext localCtx,</span>

 758                                                  final BufferedImage tstImage,
 759                                                  final BufferedImage refImage,
<span class="line-modified"> 760                                                  final BufferedImage diffImage,</span>
<span class="line-removed"> 761                                                  final DiffContext globalCtx) {</span>
 762 
 763         final int[] aRefPix = ((DataBufferInt) refImage.getRaster().getDataBuffer()).getData();
 764         final int[] aTstPix = ((DataBufferInt) tstImage.getRaster().getDataBuffer()).getData();
 765         final int[] aDifPix = ((DataBufferInt) diffImage.getRaster().getDataBuffer()).getData();
 766 
<span class="line-modified"> 767         // reset local diff context:</span>
<span class="line-modified"> 768         localCtx.reset();</span>

 769 
 770         int ref, tst, dg, v;
 771         for (int i = 0, len = aRefPix.length; i &lt; len; i++) {
 772             ref = aRefPix[i];
 773             tst = aTstPix[i];
 774 
 775             // grayscale diff:
 776             dg = (r(ref) + g(ref) + b(ref)) - (r(tst) + g(tst) + b(tst));
 777 
 778             // max difference on grayscale values:
 779             v = (int) Math.ceil(Math.abs(dg / 3.0));
<span class="line-removed"> 780 </span>
<span class="line-removed"> 781 // TODO: count warnings</span>
 782             if (v &lt;= THRESHOLD_DELTA) {
 783                 aDifPix[i] = 0;
 784             } else {
 785                 aDifPix[i] = toInt(v, v, v);


 786 
<span class="line-modified"> 787                 localCtx.add(v);</span>

 788             }
<span class="line-removed"> 789             globalCtx.add(v);</span>
 790         }
 791 
<span class="line-modified"> 792         if (!localCtx.isDiff() || (localCtx.histPix.count &lt;= THRESHOLD_NBPIX)) {</span>


 793             return null;
 794         }
 795 
<span class="line-removed"> 796         localCtx.dump();</span>
<span class="line-removed"> 797 </span>
 798         return diffImage;
 799     }
 800 
 801     static void saveImage(final BufferedImage image, final File resDirectory, final String imageFileName) throws IOException {
 802         final Iterator&lt;ImageWriter&gt; itWriters = ImageIO.getImageWritersByFormatName(&quot;PNG&quot;);
 803         if (itWriters.hasNext()) {
 804             final ImageWriter writer = itWriters.next();
 805 
 806             final ImageWriteParam writerParams = writer.getDefaultWriteParam();
 807             writerParams.setProgressiveMode(ImageWriteParam.MODE_DISABLED);
 808 
 809             final File imgFile = new File(resDirectory, imageFileName);
 810 
 811             if (!imgFile.exists() || imgFile.canWrite()) {
 812                 System.out.println(&quot;saveImage: saving image as PNG [&quot; + imgFile + &quot;]...&quot;);
 813                 imgFile.delete();
 814 
 815                 // disable cache in temporary files:
 816                 ImageIO.setUseCache(false);
 817 
</pre>
<hr />
<pre>
 878             sum += val;
 879             if (val &lt; min) {
 880                 min = val;
 881             }
 882             if (val &gt; max) {
 883                 max = val;
 884             }
 885         }
 886 
 887         void add(long val) {
 888             count++;
 889             sum += val;
 890             if (val &lt; min) {
 891                 min = val;
 892             }
 893             if (val &gt; max) {
 894                 max = val;
 895             }
 896         }
 897 











 898         public final double average() {
 899             return ((double) sum) / count;
 900         }
 901 
 902         @Override
 903         public String toString() {
 904             final StringBuilder sb = new StringBuilder(128);
 905             toString(sb);
 906             return sb.toString();
 907         }
 908 
 909         public final StringBuilder toString(final StringBuilder sb) {
 910             sb.append(name).append(&quot;[n: &quot;).append(count);
<span class="line-modified"> 911             sb.append(&quot;] sum: &quot;).append(sum).append(&quot; avg: &quot;).append(trimTo3Digits(average()));</span>
<span class="line-modified"> 912             sb.append(&quot; [&quot;).append(min).append(&quot; | &quot;).append(max).append(&quot;]&quot;);</span>



 913             return sb;
 914         }
 915 
 916     }
 917 
 918     final static class Histogram extends StatInteger {
 919 
 920         static final int BUCKET = 2;
 921         static final int MAX = 20;
 922         static final int LAST = MAX - 1;
 923         static final int[] STEPS = new int[MAX];

 924 
 925         static {
 926             STEPS[0] = 0;
 927             STEPS[1] = 1;
 928 
 929             for (int i = 2; i &lt; MAX; i++) {
 930                 STEPS[i] = STEPS[i - 1] * BUCKET;
 931             }
 932 //            System.out.println(&quot;Histogram.STEPS = &quot; + Arrays.toString(STEPS));






 933         }
 934 
 935         static int bucket(int val) {
 936             for (int i = 1; i &lt; MAX; i++) {
 937                 if (val &lt; STEPS[i]) {
 938                     return i - 1;
 939                 }
 940             }
 941             return LAST;
 942         }
 943 
 944         private final StatInteger[] stats = new StatInteger[MAX];
 945 
 946         public Histogram(String name) {
 947             super(name);
 948             for (int i = 0; i &lt; MAX; i++) {
 949                 stats[i] = new StatInteger(String.format(&quot;%5s .. %5s&quot;, STEPS[i], ((i + 1 &lt; MAX) ? STEPS[i + 1] : &quot;~&quot;)));
 950             }
 951         }
 952 
 953         @Override
 954         final void reset() {
 955             super.reset();
 956             for (int i = 0; i &lt; MAX; i++) {
 957                 stats[i].reset();
 958             }
 959         }
 960 
 961         @Override
 962         final void add(int val) {
 963             super.add(val);
 964             stats[bucket(val)].add(val);
 965         }
 966 
 967         @Override
 968         final void add(long val) {
 969             add((int) val);
 970         }
 971 































 972         @Override
 973         public final String toString() {
 974             final StringBuilder sb = new StringBuilder(2048);
 975             super.toString(sb).append(&quot; { &quot;);
 976 
 977             for (int i = 0; i &lt; MAX; i++) {
 978                 if (stats[i].count != 0l) {
 979                     sb.append(&quot;\n        &quot;).append(stats[i].toString());
 980                 }
 981             }
 982 
 983             return sb.append(&quot; }&quot;).toString();
 984         }
 985     }
 986 
 987     /**
 988      * Adjust the given double value to keep only 3 decimal digits
 989      * @param value value to adjust
 990      * @return double value with only 3 decimal digits
 991      */
 992     static double trimTo3Digits(final double value) {
 993         return ((long) (1e3d * value)) / 1e3d;
 994     }
 995 
 996     static final class DiffContext {
 997 
<span class="line-removed"> 998         public final Histogram histAll;</span>
 999         public final Histogram histPix;
1000 


1001         DiffContext(String name) {
<span class="line-removed">1002             histAll = new Histogram(&quot;All  Pixels [&quot; + name + &quot;]&quot;);</span>
1003             histPix = new Histogram(&quot;Diff Pixels [&quot; + name + &quot;]&quot;);

1004         }
1005 
1006         void reset() {
<span class="line-removed">1007             histAll.reset();</span>
1008             histPix.reset();

1009         }
1010 
1011         void dump() {
1012             if (isDiff()) {
<span class="line-modified">1013                 System.out.println(&quot;Differences [&quot; + histAll.name + &quot;]:&quot;);</span>
<span class="line-modified">1014                 System.out.println(&quot;Total [all pixels]:\n&quot; + histAll.toString());</span>
<span class="line-modified">1015                 System.out.println(&quot;Total [different pixels]:\n&quot; + histPix.toString());</span>

1016             } else {
<span class="line-modified">1017                 System.out.println(&quot;No difference for [&quot; + histAll.name + &quot;].&quot;);</span>
1018             }
1019         }
1020 
1021         void add(int val) {
<span class="line-modified">1022             histAll.add(val);</span>
<span class="line-modified">1023             if (val != 0) {</span>
<span class="line-modified">1024                 histPix.add(val);</span>




1025             }
1026         }
1027 















1028         boolean isDiff() {
<span class="line-modified">1029             return histAll.sum != 0l;</span>
1030         }
1031     }





























1032 }
</pre>
</td>
<td>
<hr />
<pre>
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  */
  23 import java.awt.BasicStroke;
  24 import java.awt.Color;
  25 import java.awt.Graphics2D;
  26 import java.awt.RenderingHints;

  27 import java.awt.Stroke;
<span class="line-added">  28 import java.awt.Shape;</span>
<span class="line-added">  29 import java.awt.geom.CubicCurve2D;</span>
  30 import java.awt.geom.Ellipse2D;
<span class="line-added">  31 import java.awt.geom.Line2D;</span>
  32 import java.awt.geom.Path2D;
  33 import java.awt.geom.PathIterator;
<span class="line-added">  34 import java.awt.geom.QuadCurve2D;</span>
  35 import java.awt.image.BufferedImage;
  36 import java.awt.image.DataBufferInt;
  37 import java.io.File;
  38 import java.io.FileOutputStream;
  39 import java.io.IOException;
  40 import java.util.Arrays;
  41 import java.util.Iterator;
  42 import java.util.Locale;
  43 import java.util.Random;
  44 import java.util.concurrent.atomic.AtomicBoolean;
  45 import java.util.concurrent.atomic.AtomicInteger;
  46 import java.util.logging.Handler;
  47 import java.util.logging.LogRecord;
  48 import java.util.logging.Logger;
  49 import javax.imageio.IIOImage;
  50 import javax.imageio.ImageIO;
  51 import javax.imageio.ImageWriteParam;
  52 import javax.imageio.ImageWriter;
  53 import javax.imageio.stream.ImageOutputStream;
  54 
  55 /**
  56  * @test
  57  * @bug 8191814
  58  * @summary Verifies that Marlin rendering generates the same
  59  * images with and without clipping optimization with all possible
  60  * stroke (cap/join) and/or dashes or fill modes (EO rules)
  61  * for paths made of either 9 lines, 4 quads, 2 cubics (random)
  62  * Note: Use the argument -slow to run more intensive tests (too much time)
  63  *
  64  * @run main/othervm/timeout=300 -Dsun.java2d.renderer=sun.java2d.marlin.MarlinRenderingEngine ClipShapeTest -poly
  65  * @run main/othervm/timeout=300 -Dsun.java2d.renderer=sun.java2d.marlin.MarlinRenderingEngine ClipShapeTest -poly -doDash
  66  * @run main/othervm/timeout=300 -Dsun.java2d.renderer=sun.java2d.marlin.MarlinRenderingEngine ClipShapeTest -cubic
  67  * @run main/othervm/timeout=300 -Dsun.java2d.renderer=sun.java2d.marlin.MarlinRenderingEngine ClipShapeTest -cubic -doDash
  68  * @run main/othervm/timeout=300 -Dsun.java2d.renderer=sun.java2d.marlin.DMarlinRenderingEngine ClipShapeTest -poly
  69  * @run main/othervm/timeout=300 -Dsun.java2d.renderer=sun.java2d.marlin.DMarlinRenderingEngine ClipShapeTest -poly -doDash
  70  * @run main/othervm/timeout=300 -Dsun.java2d.renderer=sun.java2d.marlin.DMarlinRenderingEngine ClipShapeTest -cubic
  71  * @run main/othervm/timeout=300 -Dsun.java2d.renderer=sun.java2d.marlin.DMarlinRenderingEngine ClipShapeTest -cubic -doDash
  72 */
  73 public final class ClipShapeTest {
  74 
<span class="line-modified">  75     // test options:</span>
<span class="line-modified">  76     static int NUM_TESTS;</span>
<span class="line-added">  77 </span>
<span class="line-added">  78     // shape settings:</span>
<span class="line-added">  79     static ShapeMode SHAPE_MODE;</span>
<span class="line-added">  80 </span>
<span class="line-added">  81     static boolean USE_DASHES;</span>
<span class="line-added">  82     static boolean USE_VAR_STROKE;</span>
<span class="line-added">  83 </span>
<span class="line-added">  84     static int THRESHOLD_DELTA;</span>
<span class="line-added">  85     static long THRESHOLD_NBPIX;</span>
<span class="line-added">  86 </span>
<span class="line-added">  87     // constants:</span>
<span class="line-added">  88     static final boolean DO_FAIL = Boolean.valueOf(System.getProperty(&quot;ClipShapeTest.fail&quot;, &quot;true&quot;));</span>
  89 
  90     static final boolean TEST_STROKER = true;
  91     static final boolean TEST_FILLER = true;
  92 
<span class="line-modified">  93     static final boolean SUBDIVIDE_CURVE = true;</span>
<span class="line-modified">  94     static final double SUBDIVIDE_LEN_TH = 50.0;</span>
<span class="line-modified">  95     static final boolean TRACE_SUBDIVIDE_CURVE = false;</span>
  96 

  97     static final int TESTW = 100;
  98     static final int TESTH = 100;
  99 








 100     // dump path on console:
 101     static final boolean DUMP_SHAPE = true;
 102 
 103     static final boolean SHOW_DETAILS = false; // disabled
 104     static final boolean SHOW_OUTLINE = true;
 105     static final boolean SHOW_POINTS = true;
 106     static final boolean SHOW_INFO = false;
 107 
 108     static final int MAX_SHOW_FRAMES = 10;
 109     static final int MAX_SAVE_FRAMES = 100;
 110 
 111     // use fixed seed to reproduce always same polygons between tests
<span class="line-modified"> 112     static final boolean FIXED_SEED = true;</span>
<span class="line-added"> 113 </span>
 114     static final double RAND_SCALE = 3.0;
 115     static final double RANDW = TESTW * RAND_SCALE;
 116     static final double OFFW = (TESTW - RANDW) / 2.0;
 117     static final double RANDH = TESTH * RAND_SCALE;
 118     static final double OFFH = (TESTH - RANDH) / 2.0;
 119 
 120     static enum ShapeMode {
 121         TWO_CUBICS,
 122         FOUR_QUADS,
 123         FIVE_LINE_POLYS,
 124         NINE_LINE_POLYS,
 125         FIFTY_LINE_POLYS,
 126         MIXED
 127     }
 128 
 129     static final long SEED = 1666133789L;
 130     // Fixed seed to avoid any difference between runs:
 131     static final Random RANDOM = new Random(SEED);
 132 
 133     static final File OUTPUT_DIR = new File(&quot;.&quot;);
 134 
 135     static final AtomicBoolean isMarlin = new AtomicBoolean();
<span class="line-added"> 136     static final AtomicBoolean isMarlinFloat = new AtomicBoolean();</span>
 137     static final AtomicBoolean isClipRuntime = new AtomicBoolean();
 138 
 139     static {
 140         Locale.setDefault(Locale.US);
 141 
 142         // FIRST: Get Marlin runtime state from its log:
 143 
 144         // initialize j.u.l Looger:
 145         final Logger log = Logger.getLogger(&quot;sun.java2d.marlin&quot;);
 146         log.addHandler(new Handler() {
 147             @Override
 148             public void publish(LogRecord record) {
 149                 final String msg = record.getMessage();
 150                 if (msg != null) {
 151                     // last space to avoid matching other settings:
 152                     if (msg.startsWith(&quot;sun.java2d.renderer &quot;)) {
 153                         isMarlin.set(msg.contains(&quot;MarlinRenderingEngine&quot;));
<span class="line-added"> 154                         isMarlinFloat.set(!msg.contains(&quot;DMarlinRenderingEngine&quot;));</span>
 155                     }
 156                     if (msg.startsWith(&quot;sun.java2d.renderer.clip.runtime.enable&quot;)) {
 157                         isClipRuntime.set(msg.contains(&quot;true&quot;));
 158                     }
 159                 }
 160 
 161                 final Throwable th = record.getThrown();
 162                 // detect any Throwable:
 163                 if (th != null) {
 164                     System.out.println(&quot;Test failed:\n&quot; + record.getMessage());
 165                     th.printStackTrace(System.out);
 166 
 167                     throw new RuntimeException(&quot;Test failed: &quot;, th);
 168                 }
 169             }
 170 
 171             @Override
 172             public void flush() {
 173             }
 174 
</pre>
<hr />
<pre>
 178         });
 179 
 180         // enable Marlin logging &amp; internal checks:
 181         System.setProperty(&quot;sun.java2d.renderer.log&quot;, &quot;true&quot;);
 182         System.setProperty(&quot;sun.java2d.renderer.useLogger&quot;, &quot;true&quot;);
 183 
 184         // disable static clipping setting:
 185         System.setProperty(&quot;sun.java2d.renderer.clip&quot;, &quot;false&quot;);
 186         System.setProperty(&quot;sun.java2d.renderer.clip.runtime.enable&quot;, &quot;true&quot;);
 187 
 188         // enable subdivider:
 189         System.setProperty(&quot;sun.java2d.renderer.clip.subdivider&quot;, &quot;true&quot;);
 190 
 191         // disable min length check: always subdivide curves at clip edges
 192         System.setProperty(&quot;sun.java2d.renderer.clip.subdivider.minLength&quot;, &quot;-1&quot;);
 193 
 194         // If any curve, increase curve accuracy:
 195         // curve length max error:
 196         System.setProperty(&quot;sun.java2d.renderer.curve_len_err&quot;, &quot;1e-4&quot;);
 197 
<span class="line-added"> 198         // cubic min/max error:</span>
<span class="line-added"> 199         System.setProperty(&quot;sun.java2d.renderer.cubic_dec_d2&quot;, &quot;1e-3&quot;);</span>
<span class="line-added"> 200         System.setProperty(&quot;sun.java2d.renderer.cubic_inc_d1&quot;, &quot;1e-4&quot;);</span>
<span class="line-added"> 201 </span>
 202         // quad max error:
 203         System.setProperty(&quot;sun.java2d.renderer.quad_dec_d2&quot;, &quot;5e-4&quot;);
<span class="line-added"> 204     }</span>
 205 
<span class="line-modified"> 206     private static void resetOptions() {</span>
<span class="line-modified"> 207         NUM_TESTS = Integer.getInteger(&quot;ClipShapeTest.numTests&quot;, 5000);</span>
<span class="line-modified"> 208 </span>
<span class="line-added"> 209         // shape settings:</span>
<span class="line-added"> 210         SHAPE_MODE = ShapeMode.NINE_LINE_POLYS;</span>
<span class="line-added"> 211 </span>
<span class="line-added"> 212         USE_DASHES = false;</span>
<span class="line-added"> 213         USE_VAR_STROKE = false;</span>
 214     }
 215 
 216     /**
 217      * Test
 218      * @param args
 219      */
 220     public static void main(String[] args) {
<span class="line-added"> 221         {</span>
<span class="line-added"> 222             // Bootstrap: init Renderer now:</span>
<span class="line-added"> 223             final BufferedImage img = newImage(TESTW, TESTH);</span>
<span class="line-added"> 224             final Graphics2D g2d = initialize(img, null);</span>
<span class="line-added"> 225 </span>
<span class="line-added"> 226             try {</span>
<span class="line-added"> 227                 paintShape(new Line2D.Double(0,0,100,100), g2d, true, false);</span>
<span class="line-added"> 228             } finally {</span>
<span class="line-added"> 229                 g2d.dispose();</span>
<span class="line-added"> 230             }</span>
<span class="line-added"> 231 </span>
<span class="line-added"> 232             if (!isMarlin.get()) {</span>
<span class="line-added"> 233                 throw new RuntimeException(&quot;Marlin renderer not used at runtime !&quot;);</span>
<span class="line-added"> 234             }</span>
<span class="line-added"> 235             if (!isClipRuntime.get()) {</span>
<span class="line-added"> 236                 throw new RuntimeException(&quot;Marlin clipping not enabled at runtime !&quot;);</span>
<span class="line-added"> 237             }</span>
<span class="line-added"> 238         }</span>
<span class="line-added"> 239 </span>
<span class="line-added"> 240         System.out.println(&quot;---------------------------------------&quot;);</span>
<span class="line-added"> 241         System.out.println(&quot;ClipShapeTest: image = &quot; + TESTW + &quot; x &quot; + TESTH);</span>
<span class="line-added"> 242 </span>
<span class="line-added"> 243         resetOptions();</span>
<span class="line-added"> 244 </span>
 245         boolean runSlowTests = false;
 246 
 247         for (String arg : args) {
 248             if (&quot;-slow&quot;.equals(arg)) {

 249                 runSlowTests = true;






 250             } else if (&quot;-doDash&quot;.equals(arg)) {

 251                 USE_DASHES = true;
 252             } else if (&quot;-doVarStroke&quot;.equals(arg)) {

 253                 USE_VAR_STROKE = true;
<span class="line-modified"> 254             } else {</span>
<span class="line-modified"> 255                 // shape mode:</span>
<span class="line-modified"> 256                 if (arg.equalsIgnoreCase(&quot;-poly&quot;)) {</span>
<span class="line-modified"> 257                     SHAPE_MODE = ShapeMode.NINE_LINE_POLYS;</span>
<span class="line-modified"> 258                 } else if (arg.equalsIgnoreCase(&quot;-bigpoly&quot;)) {</span>
<span class="line-modified"> 259                     SHAPE_MODE = ShapeMode.FIFTY_LINE_POLYS;</span>
<span class="line-modified"> 260                 } else if (arg.equalsIgnoreCase(&quot;-quad&quot;)) {</span>
<span class="line-modified"> 261                     SHAPE_MODE = ShapeMode.FOUR_QUADS;</span>
<span class="line-modified"> 262                 } else if (arg.equalsIgnoreCase(&quot;-cubic&quot;)) {</span>
<span class="line-modified"> 263                     SHAPE_MODE = ShapeMode.TWO_CUBICS;</span>
<span class="line-modified"> 264                 } else if (arg.equalsIgnoreCase(&quot;-mixed&quot;)) {</span>
<span class="line-modified"> 265                     SHAPE_MODE = ShapeMode.MIXED;</span>
<span class="line-added"> 266                 }</span>
 267             }
 268         }
 269 
 270         System.out.println(&quot;Shape mode: &quot; + SHAPE_MODE);
 271 
 272         // adjust image comparison thresholds:
<span class="line-modified"> 273         switch (SHAPE_MODE) {</span>
 274             case TWO_CUBICS:
 275                 // Define uncertainty for curves:
<span class="line-modified"> 276                 THRESHOLD_DELTA = 32;</span>
<span class="line-modified"> 277                 THRESHOLD_NBPIX = (USE_DASHES) ? 50 : 200;</span>
<span class="line-added"> 278                 if (SUBDIVIDE_CURVE) {</span>
<span class="line-added"> 279                     THRESHOLD_NBPIX = 4;</span>
<span class="line-added"> 280                 }</span>
 281                 break;
 282             case FOUR_QUADS:
 283             case MIXED:
 284                 // Define uncertainty for quads:
 285                 // curve subdivision causes curves to be smaller
 286                 // then curve offsets are different (more accurate)
<span class="line-modified"> 287                 THRESHOLD_DELTA = 64;</span>
<span class="line-modified"> 288                 THRESHOLD_NBPIX = (USE_DASHES) ? 40 : 420;</span>
<span class="line-added"> 289                 if (SUBDIVIDE_CURVE) {</span>
<span class="line-added"> 290                     THRESHOLD_NBPIX = 10;</span>
<span class="line-added"> 291                 }</span>
 292                 break;
 293             default:
 294                 // Define uncertainty for lines:
 295                 // float variant have higher uncertainty
<span class="line-modified"> 296                 THRESHOLD_DELTA = 2;</span>
<span class="line-modified"> 297                 THRESHOLD_NBPIX = (USE_DASHES) ?</span>
<span class="line-added"> 298                     // float variant have higher uncertainty</span>
<span class="line-added"> 299                     ((isMarlinFloat.get()) ? 30 : 6) // low for double</span>
<span class="line-added"> 300                     : (isMarlinFloat.get()) ? 10 : 0;</span>
 301         }
 302 
<span class="line-modified"> 303 // Visual inspection (low threshold):</span>
<span class="line-modified"> 304 //        THRESHOLD_NBPIX = 2;</span>
<span class="line-added"> 305 </span>
<span class="line-added"> 306         System.out.println(&quot;THRESHOLD_DELTA: &quot; + THRESHOLD_DELTA);</span>
<span class="line-added"> 307         System.out.println(&quot;THRESHOLD_NBPIX: &quot; + THRESHOLD_NBPIX);</span>
 308 
 309         if (runSlowTests) {
 310             NUM_TESTS = 10000; // or 100000 (very slow)

 311             USE_VAR_STROKE = true;
 312         }
 313 
<span class="line-modified"> 314         System.out.println(&quot;NUM_TESTS: &quot; + NUM_TESTS);</span>
<span class="line-added"> 315 </span>
<span class="line-added"> 316         if (USE_DASHES) {</span>
<span class="line-added"> 317             System.out.println(&quot;USE_DASHES: enabled.&quot;);</span>
<span class="line-added"> 318         }</span>
<span class="line-added"> 319         if (USE_VAR_STROKE) {</span>
<span class="line-added"> 320             System.out.println(&quot;USE_VAR_STROKE: enabled.&quot;);</span>
<span class="line-added"> 321         }</span>
<span class="line-added"> 322         if (!DO_FAIL) {</span>
<span class="line-added"> 323             System.out.println(&quot;DO_FAIL: disabled.&quot;);</span>
<span class="line-added"> 324         }</span>
<span class="line-added"> 325 </span>
<span class="line-added"> 326         System.out.println(&quot;---------------------------------------&quot;);</span>
<span class="line-added"> 327 </span>
<span class="line-added"> 328         final DiffContext allCtx = new DiffContext(&quot;All Test setups&quot;);</span>
<span class="line-added"> 329         final DiffContext allWorstCtx = new DiffContext(&quot;Worst(All Test setups)&quot;);</span>
 330 
 331         int failures = 0;
 332         final long start = System.nanoTime();
 333         try {


 334             if (TEST_STROKER) {
 335                 final float[][] dashArrays = (USE_DASHES) ?
 336 // small
 337 //                        new float[][]{new float[]{1f, 2f}}
 338 // normal
 339                         new float[][]{new float[]{13f, 7f}}
 340 // large (prime)
 341 //                        new float[][]{new float[]{41f, 7f}}
 342 // none
 343                         : new float[][]{null};
 344 
 345                 System.out.println(&quot;dashes: &quot; + Arrays.deepToString(dashArrays));
 346 
 347                 final float[] strokeWidths = (USE_VAR_STROKE)
 348                                                 ? new float[5] :
 349                                                   new float[]{10f};
 350 
 351                 int nsw = 0;
 352                 if (USE_VAR_STROKE) {
<span class="line-modified"> 353                     for (float width = 0.25f; width &lt; 110f; width *= 5f) {</span>
 354                         strokeWidths[nsw++] = width;
 355                     }
 356                 } else {
 357                     nsw = 1;
 358                 }
 359 
 360                 System.out.println(&quot;stroke widths: &quot; + Arrays.toString(strokeWidths));
 361 
 362                 // Stroker tests:
 363                 for (int w = 0; w &lt; nsw; w++) {
 364                     final float width = strokeWidths[w];
 365 
 366                     for (float[] dashes : dashArrays) {
 367 
 368                         for (int cap = 0; cap &lt;= 2; cap++) {
 369 
 370                             for (int join = 0; join &lt;= 2; join++) {
 371 
<span class="line-modified"> 372                                 failures += paintPaths(allCtx, allWorstCtx, new TestSetup(SHAPE_MODE, false, width, cap, join, dashes));</span>
<span class="line-modified"> 373                                 failures += paintPaths(allCtx, allWorstCtx, new TestSetup(SHAPE_MODE, true, width, cap, join, dashes));</span>
 374                             }
 375                         }
 376                     }
 377                 }
 378             }
 379 
 380             if (TEST_FILLER) {
 381                 // Filler tests:
<span class="line-modified"> 382                 failures += paintPaths(allCtx, allWorstCtx, new TestSetup(SHAPE_MODE, false, Path2D.WIND_NON_ZERO));</span>
<span class="line-modified"> 383                 failures += paintPaths(allCtx, allWorstCtx, new TestSetup(SHAPE_MODE, true, Path2D.WIND_NON_ZERO));</span>
 384 
<span class="line-modified"> 385                 failures += paintPaths(allCtx, allWorstCtx, new TestSetup(SHAPE_MODE, false, Path2D.WIND_EVEN_ODD));</span>
<span class="line-modified"> 386                 failures += paintPaths(allCtx, allWorstCtx, new TestSetup(SHAPE_MODE, true, Path2D.WIND_EVEN_ODD));</span>
 387             }
 388         } catch (IOException ioe) {
 389             throw new RuntimeException(ioe);
 390         }
 391         System.out.println(&quot;main: duration= &quot; + (1e-6 * (System.nanoTime() - start)) + &quot; ms.&quot;);
 392 
<span class="line-modified"> 393         allWorstCtx.dump();</span>
<span class="line-modified"> 394         allCtx.dump();</span>
<span class="line-modified"> 395 </span>
<span class="line-modified"> 396         if (DO_FAIL &amp;&amp; (failures != 0)) {</span>



 397             throw new RuntimeException(&quot;Clip test failures : &quot; + failures);
 398         }
 399     }
 400 
<span class="line-modified"> 401     static int paintPaths(final DiffContext allCtx, final DiffContext allWorstCtx, final TestSetup ts) throws IOException {</span>
 402         final long start = System.nanoTime();
 403 
 404         if (FIXED_SEED) {
 405             // Reset seed for random numbers:
 406             RANDOM.setSeed(SEED);
 407         }
 408 
 409         System.out.println(&quot;paintPaths: &quot; + NUM_TESTS
 410                 + &quot; paths (&quot; + SHAPE_MODE + &quot;) - setup: &quot; + ts);
 411 
 412         final boolean fill = !ts.isStroke();
 413         final Path2D p2d = new Path2D.Double(ts.windingRule);
 414 
<span class="line-added"> 415         final Stroke stroke = (!fill) ? createStroke(ts) : null;</span>
<span class="line-added"> 416 </span>
 417         final BufferedImage imgOn = newImage(TESTW, TESTH);
<span class="line-modified"> 418         final Graphics2D g2dOn = initialize(imgOn, stroke);</span>
 419 
 420         final BufferedImage imgOff = newImage(TESTW, TESTH);
<span class="line-modified"> 421         final Graphics2D g2dOff = initialize(imgOff, stroke);</span>
 422 
 423         final BufferedImage imgDiff = newImage(TESTW, TESTH);
 424 
<span class="line-modified"> 425         final DiffContext testSetupCtx = new DiffContext(&quot;Test setup&quot;);</span>
<span class="line-added"> 426         final DiffContext testWorstCtx = new DiffContext(&quot;Worst&quot;);</span>
<span class="line-added"> 427         final DiffContext testWorstThCtx = new DiffContext(&quot;Worst(&gt;threshold)&quot;);</span>
 428 
 429         int nd = 0;
 430         try {
 431             final DiffContext testCtx = new DiffContext(&quot;Test&quot;);
<span class="line-added"> 432             final DiffContext testThCtx = new DiffContext(&quot;Test(&gt;threshold)&quot;);</span>
 433             BufferedImage diffImage;
 434 
 435             for (int n = 0; n &lt; NUM_TESTS; n++) {
 436                 genShape(p2d, ts);
 437 
 438                 // Runtime clip setting OFF:
 439                 paintShape(p2d, g2dOff, fill, false);
 440 
 441                 // Runtime clip setting ON:
 442                 paintShape(p2d, g2dOn, fill, true);
 443 
 444                 /* compute image difference if possible */
<span class="line-modified"> 445                 diffImage = computeDiffImage(testCtx, testThCtx, imgOn, imgOff, imgDiff);</span>


 446 
<span class="line-added"> 447                 // Worst (total)</span>
<span class="line-added"> 448                 if (testCtx.isDiff()) {</span>
<span class="line-added"> 449                     if (testWorstCtx.isWorse(testCtx, false)) {</span>
<span class="line-added"> 450                         testWorstCtx.set(testCtx);</span>
<span class="line-added"> 451                     }</span>
<span class="line-added"> 452                     if (testWorstThCtx.isWorse(testCtx, true)) {</span>
<span class="line-added"> 453                         testWorstThCtx.set(testCtx);</span>
<span class="line-added"> 454                     }</span>
<span class="line-added"> 455                     // accumulate data:</span>
<span class="line-added"> 456                     testSetupCtx.add(testCtx);</span>
<span class="line-added"> 457                 }</span>
 458                 if (diffImage != null) {
 459                     nd++;
 460 
<span class="line-modified"> 461                     testThCtx.dump();</span>
<span class="line-modified"> 462                     testCtx.dump();</span>
 463 
 464                     if (nd &lt; MAX_SHOW_FRAMES) {
 465                         if (SHOW_DETAILS) {
 466                             paintShapeDetails(g2dOff, p2d);
 467                             paintShapeDetails(g2dOn, p2d);
 468                         }
 469 
 470                         if (nd &lt; MAX_SAVE_FRAMES) {
 471                             if (DUMP_SHAPE) {
 472                                 dumpShape(p2d);
 473                             }
<span class="line-added"> 474 </span>
<span class="line-added"> 475                             final String testName = &quot;Setup_&quot; + ts.id + &quot;_test_&quot; + n;</span>
<span class="line-added"> 476 </span>
 477                             saveImage(imgOff, OUTPUT_DIR, testName + &quot;-off.png&quot;);
 478                             saveImage(imgOn, OUTPUT_DIR, testName + &quot;-on.png&quot;);
<span class="line-modified"> 479                             saveImage(imgDiff, OUTPUT_DIR, testName + &quot;-diff.png&quot;);</span>
 480                         }
 481                     }
 482                 }
 483             }
 484         } finally {
 485             g2dOff.dispose();
 486             g2dOn.dispose();
 487 
 488             if (nd != 0) {
 489                 System.out.println(&quot;paintPaths: &quot; + NUM_TESTS + &quot; paths - &quot;
 490                         + &quot;Number of differences = &quot; + nd
 491                         + &quot; ratio = &quot; + (100f * nd) / NUM_TESTS + &quot; %&quot;);
 492             }
 493 
<span class="line-modified"> 494             if (testWorstCtx.isDiff()) {</span>
<span class="line-added"> 495                 testWorstCtx.dump();</span>
<span class="line-added"> 496                 if (testWorstThCtx.isDiff() &amp;&amp; testWorstThCtx.histPix.sum != testWorstCtx.histPix.sum) {</span>
<span class="line-added"> 497                     testWorstThCtx.dump();</span>
<span class="line-added"> 498                 }</span>
<span class="line-added"> 499                 if (allWorstCtx.isWorse(testWorstThCtx, true)) {</span>
<span class="line-added"> 500                     allWorstCtx.set(testWorstThCtx);</span>
<span class="line-added"> 501                 }</span>
<span class="line-added"> 502             }</span>
<span class="line-added"> 503             testSetupCtx.dump();</span>
<span class="line-added"> 504 </span>
<span class="line-added"> 505             // accumulate data:</span>
<span class="line-added"> 506             allCtx.add(testSetupCtx);</span>
 507         }
 508         System.out.println(&quot;paintPaths: duration= &quot; + (1e-6 * (System.nanoTime() - start)) + &quot; ms.&quot;);
 509         return nd;
 510     }
 511 
<span class="line-modified"> 512     private static void paintShape(final Shape p2d, final Graphics2D g2d,</span>
 513                                    final boolean fill, final boolean clip) {
 514         reset(g2d);
 515 
 516         setClip(g2d, clip);
 517 
 518         if (fill) {
 519             g2d.fill(p2d);
 520         } else {
 521             g2d.draw(p2d);
 522         }
 523     }
 524 
 525     private static Graphics2D initialize(final BufferedImage img,
<span class="line-modified"> 526                                          final Stroke s) {</span>
 527         final Graphics2D g2d = (Graphics2D) img.getGraphics();
 528         g2d.setRenderingHint(RenderingHints.KEY_RENDERING,
 529                 RenderingHints.VALUE_RENDER_QUALITY);
 530         g2d.setRenderingHint(RenderingHints.KEY_STROKE_CONTROL,
<span class="line-modified"> 531 // Test normalize:</span>
<span class="line-added"> 532 //                RenderingHints.VALUE_STROKE_NORMALIZE</span>
<span class="line-added"> 533                 RenderingHints.VALUE_STROKE_PURE</span>
<span class="line-added"> 534         );</span>
 535 
<span class="line-modified"> 536         if (s != null) {</span>
<span class="line-modified"> 537             g2d.setStroke(s);</span>










 538         }
<span class="line-added"> 539         g2d.setColor(Color.BLACK);</span>
 540 
 541         return g2d;
 542     }
 543 
 544     private static void reset(final Graphics2D g2d) {
 545         // Disable antialiasing:
 546         g2d.setRenderingHint(RenderingHints.KEY_ANTIALIASING,
 547                 RenderingHints.VALUE_ANTIALIAS_OFF);
 548         g2d.setBackground(Color.WHITE);
 549         g2d.clearRect(0, 0, TESTW, TESTH);
 550     }
 551 
 552     private static void setClip(final Graphics2D g2d, final boolean clip) {
 553         // Enable antialiasing:
 554         g2d.setRenderingHint(RenderingHints.KEY_ANTIALIASING,
 555                 RenderingHints.VALUE_ANTIALIAS_ON);
 556 
 557         // Enable or Disable clipping:
 558         System.setProperty(&quot;sun.java2d.renderer.clip.runtime&quot;, (clip) ? &quot;true&quot; : &quot;false&quot;);
 559     }
 560 
 561     static void genShape(final Path2D p2d, final TestSetup ts) {
 562         p2d.reset();
 563 
<span class="line-modified"> 564         /*</span>
<span class="line-added"> 565             Test closed path:</span>
<span class="line-added"> 566             0: moveTo + (draw)To + closePath</span>
<span class="line-added"> 567             1: (draw)To + closePath (closePath + (draw)To sequence)</span>
<span class="line-added"> 568         */</span>
<span class="line-added"> 569         final int end  = (ts.closed) ? 2 : 1;</span>
<span class="line-added"> 570 </span>
<span class="line-added"> 571         final double[] in = new double[8];</span>
<span class="line-added"> 572 </span>
<span class="line-added"> 573         double sx0 = 0.0, sy0 = 0.0, x0 = 0.0, y0 = 0.0;</span>
 574 
 575         for (int p = 0; p &lt; end; p++) {
<span class="line-modified"> 576             if (p &lt;= 0) {</span>
<span class="line-added"> 577                 x0 = randX(); y0 = randY();</span>
<span class="line-added"> 578                 p2d.moveTo(x0, y0);</span>
<span class="line-added"> 579                 sx0 = x0; sy0 = y0;</span>
<span class="line-added"> 580             }</span>
 581 
 582             switch (ts.shapeMode) {
 583                 case MIXED:


 584                 case FIVE_LINE_POLYS:
<span class="line-added"> 585                 case NINE_LINE_POLYS:</span>
<span class="line-added"> 586                 case FIFTY_LINE_POLYS:</span>
 587                     p2d.lineTo(randX(), randY());
 588                     p2d.lineTo(randX(), randY());
 589                     p2d.lineTo(randX(), randY());
 590                     p2d.lineTo(randX(), randY());
<span class="line-added"> 591                     x0 = randX(); y0 = randY();</span>
<span class="line-added"> 592                     p2d.lineTo(x0, y0);</span>
 593                     if (ts.shapeMode == ShapeMode.FIVE_LINE_POLYS) {
 594                         // And an implicit close makes 5 lines
 595                         break;
 596                     }
 597                     p2d.lineTo(randX(), randY());
 598                     p2d.lineTo(randX(), randY());
 599                     p2d.lineTo(randX(), randY());
<span class="line-modified"> 600                     x0 = randX(); y0 = randY();</span>
<span class="line-added"> 601                     p2d.lineTo(x0, y0);</span>
 602                     if (ts.shapeMode == ShapeMode.NINE_LINE_POLYS) {
 603                         // And an implicit close makes 9 lines
 604                         break;
 605                     }
 606                     if (ts.shapeMode == ShapeMode.FIFTY_LINE_POLYS) {
 607                         for (int i = 0; i &lt; 41; i++) {
<span class="line-modified"> 608                             x0 = randX(); y0 = randY();</span>
<span class="line-added"> 609                             p2d.lineTo(x0, y0);</span>
 610                         }
 611                         // And an implicit close makes 50 lines
 612                         break;
 613                     }
 614                 case TWO_CUBICS:
<span class="line-modified"> 615                     if (SUBDIVIDE_CURVE) {</span>
<span class="line-modified"> 616                         in[0] = x0; in[1] = y0;</span>
<span class="line-added"> 617                         in[2] = randX(); in[3] = randY();</span>
<span class="line-added"> 618                         in[4] = randX(); in[5] = randY();</span>
<span class="line-added"> 619                         x0 = randX(); y0 = randY();</span>
<span class="line-added"> 620                         in[6] = x0; in[7] = y0;</span>
<span class="line-added"> 621                         subdivide(p2d, 8, in);</span>
<span class="line-added"> 622                         in[0] = x0; in[1] = y0;</span>
<span class="line-added"> 623                         in[2] = randX(); in[3] = randY();</span>
<span class="line-added"> 624                         in[4] = randX(); in[5] = randY();</span>
<span class="line-added"> 625                         x0 = randX(); y0 = randY();</span>
<span class="line-added"> 626                         in[6] = x0; in[7] = y0;</span>
<span class="line-added"> 627                         subdivide(p2d, 8, in);</span>
<span class="line-added"> 628                     } else {</span>
<span class="line-added"> 629                         x0 = randX(); y0 = randY();</span>
<span class="line-added"> 630                         p2d.curveTo(randX(), randY(), randX(), randY(), x0, y0);</span>
<span class="line-added"> 631                         x0 = randX(); y0 = randY();</span>
<span class="line-added"> 632                         p2d.curveTo(randX(), randY(), randX(), randY(), x0, y0);</span>
<span class="line-added"> 633                     }</span>
 634                     if (ts.shapeMode == ShapeMode.TWO_CUBICS) {
 635                         break;
 636                     }
 637                 case FOUR_QUADS:
<span class="line-modified"> 638                     if (SUBDIVIDE_CURVE) {</span>
<span class="line-modified"> 639                         in[0] = x0; in[1] = y0;</span>
<span class="line-modified"> 640                         in[2] = randX(); in[3] = randY();</span>
<span class="line-modified"> 641                         x0 = randX(); y0 = randY();</span>
<span class="line-added"> 642                         in[4] = x0; in[5] = y0;</span>
<span class="line-added"> 643                         subdivide(p2d, 6, in);</span>
<span class="line-added"> 644                         in[0] = x0; in[1] = y0;</span>
<span class="line-added"> 645                         in[2] = randX(); in[3] = randY();</span>
<span class="line-added"> 646                         x0 = randX(); y0 = randY();</span>
<span class="line-added"> 647                         in[4] = x0; in[5] = y0;</span>
<span class="line-added"> 648                         subdivide(p2d, 6, in);</span>
<span class="line-added"> 649                         in[0] = x0; in[1] = y0;</span>
<span class="line-added"> 650                         in[2] = randX(); in[3] = randY();</span>
<span class="line-added"> 651                         x0 = randX(); y0 = randY();</span>
<span class="line-added"> 652                         in[4] = x0; in[5] = y0;</span>
<span class="line-added"> 653                         subdivide(p2d, 6, in);</span>
<span class="line-added"> 654                         in[0] = x0; in[1] = y0;</span>
<span class="line-added"> 655                         in[2] = randX(); in[3] = randY();</span>
<span class="line-added"> 656                         x0 = randX(); y0 = randY();</span>
<span class="line-added"> 657                         in[4] = x0; in[5] = y0;</span>
<span class="line-added"> 658                         subdivide(p2d, 6, in);</span>
<span class="line-added"> 659                     } else {</span>
<span class="line-added"> 660                         x0 = randX(); y0 = randY();</span>
<span class="line-added"> 661                         p2d.quadTo(randX(), randY(), x0, y0);</span>
<span class="line-added"> 662                         x0 = randX(); y0 = randY();</span>
<span class="line-added"> 663                         p2d.quadTo(randX(), randY(), x0, y0);</span>
<span class="line-added"> 664                         x0 = randX(); y0 = randY();</span>
<span class="line-added"> 665                         p2d.quadTo(randX(), randY(), x0, y0);</span>
<span class="line-added"> 666                         x0 = randX(); y0 = randY();</span>
<span class="line-added"> 667                         p2d.quadTo(randX(), randY(), x0, y0);</span>
<span class="line-added"> 668                     }</span>
 669                     if (ts.shapeMode == ShapeMode.FOUR_QUADS) {
 670                         break;
 671                     }
 672                 default:
 673             }
 674 
 675             if (ts.closed) {
 676                 p2d.closePath();
<span class="line-added"> 677                 x0 = sx0; y0 = sy0;</span>
<span class="line-added"> 678             }</span>
<span class="line-added"> 679         }</span>
<span class="line-added"> 680     }</span>
<span class="line-added"> 681 </span>
<span class="line-added"> 682     static final int SUBDIVIDE_LIMIT = 5;</span>
<span class="line-added"> 683     static final double[][] SUBDIVIDE_CURVES = new double[SUBDIVIDE_LIMIT + 1][];</span>
<span class="line-added"> 684 </span>
<span class="line-added"> 685     static {</span>
<span class="line-added"> 686         for (int i = 0, n = 1; i &lt; SUBDIVIDE_LIMIT; i++, n *= 2) {</span>
<span class="line-added"> 687             SUBDIVIDE_CURVES[i] = new double[8 * n];</span>
<span class="line-added"> 688         }</span>
<span class="line-added"> 689     }</span>
<span class="line-added"> 690 </span>
<span class="line-added"> 691     static void subdivide(final Path2D p2d, final int type, final double[] in) {</span>
<span class="line-added"> 692         if (TRACE_SUBDIVIDE_CURVE) {</span>
<span class="line-added"> 693             System.out.println(&quot;subdivide: &quot; + Arrays.toString(Arrays.copyOf(in, type)));</span>
<span class="line-added"> 694         }</span>
<span class="line-added"> 695 </span>
<span class="line-added"> 696         double curveLen = ((type == 8)</span>
<span class="line-added"> 697                 ? curvelen(in[0], in[1], in[2], in[3], in[4], in[5], in[6], in[7])</span>
<span class="line-added"> 698                 : quadlen(in[0], in[1], in[2], in[3], in[4], in[5]));</span>
<span class="line-added"> 699 </span>
<span class="line-added"> 700         if (curveLen &gt; SUBDIVIDE_LEN_TH) {</span>
<span class="line-added"> 701             if (TRACE_SUBDIVIDE_CURVE) {</span>
<span class="line-added"> 702                 System.out.println(&quot;curvelen: &quot; + curveLen);</span>
<span class="line-added"> 703             }</span>
<span class="line-added"> 704 </span>
<span class="line-added"> 705             System.arraycopy(in, 0, SUBDIVIDE_CURVES[0], 0, 8);</span>
<span class="line-added"> 706 </span>
<span class="line-added"> 707             int level = 0;</span>
<span class="line-added"> 708             while (curveLen &gt;= SUBDIVIDE_LEN_TH) {</span>
<span class="line-added"> 709                 level++;</span>
<span class="line-added"> 710                 curveLen /= 2.0;</span>
<span class="line-added"> 711                 if (TRACE_SUBDIVIDE_CURVE) {</span>
<span class="line-added"> 712                     System.out.println(&quot;curvelen: &quot; + curveLen);</span>
<span class="line-added"> 713                 }</span>
<span class="line-added"> 714             }</span>
<span class="line-added"> 715 </span>
<span class="line-added"> 716             if (TRACE_SUBDIVIDE_CURVE) {</span>
<span class="line-added"> 717                 System.out.println(&quot;level: &quot; + level);</span>
<span class="line-added"> 718             }</span>
<span class="line-added"> 719 </span>
<span class="line-added"> 720             if (level &gt; SUBDIVIDE_LIMIT) {</span>
<span class="line-added"> 721                 if (TRACE_SUBDIVIDE_CURVE) {</span>
<span class="line-added"> 722                     System.out.println(&quot;max level reached : &quot; + level);</span>
<span class="line-added"> 723                 }</span>
<span class="line-added"> 724                 level = SUBDIVIDE_LIMIT;</span>
<span class="line-added"> 725             }</span>
<span class="line-added"> 726 </span>
<span class="line-added"> 727             for (int l = 0; l &lt; level; l++) {</span>
<span class="line-added"> 728                 if (TRACE_SUBDIVIDE_CURVE) {</span>
<span class="line-added"> 729                     System.out.println(&quot;level: &quot; + l);</span>
<span class="line-added"> 730                 }</span>
<span class="line-added"> 731 </span>
<span class="line-added"> 732                 double[] src = SUBDIVIDE_CURVES[l];</span>
<span class="line-added"> 733                 double[] dst = SUBDIVIDE_CURVES[l + 1];</span>
<span class="line-added"> 734 </span>
<span class="line-added"> 735                 for (int i = 0, j = 0; i &lt; src.length; i += 8, j += 16) {</span>
<span class="line-added"> 736                     if (TRACE_SUBDIVIDE_CURVE) {</span>
<span class="line-added"> 737                         System.out.println(&quot;subdivide: &quot; + Arrays.toString(Arrays.copyOfRange(src, i, i + type)));</span>
<span class="line-added"> 738                     }</span>
<span class="line-added"> 739                     if (type == 8) {</span>
<span class="line-added"> 740                         CubicCurve2D.subdivide(src, i, dst, j, dst, j + 8);</span>
<span class="line-added"> 741                     } else {</span>
<span class="line-added"> 742                         QuadCurve2D.subdivide(src, i, dst, j, dst, j + 8);</span>
<span class="line-added"> 743                     }</span>
<span class="line-added"> 744                     if (TRACE_SUBDIVIDE_CURVE) {</span>
<span class="line-added"> 745                         System.out.println(&quot;left: &quot; + Arrays.toString(Arrays.copyOfRange(dst, j, j + type)));</span>
<span class="line-added"> 746                         System.out.println(&quot;right: &quot; + Arrays.toString(Arrays.copyOfRange(dst, j + 8, j + 8 + type)));</span>
<span class="line-added"> 747                     }</span>
<span class="line-added"> 748                 }</span>
<span class="line-added"> 749             }</span>
<span class="line-added"> 750 </span>
<span class="line-added"> 751             // Emit curves at last level:</span>
<span class="line-added"> 752             double[] src = SUBDIVIDE_CURVES[level];</span>
<span class="line-added"> 753 </span>
<span class="line-added"> 754             double len = 0.0;</span>
<span class="line-added"> 755 </span>
<span class="line-added"> 756             for (int i = 0; i &lt; src.length; i += 8) {</span>
<span class="line-added"> 757                 if (TRACE_SUBDIVIDE_CURVE) {</span>
<span class="line-added"> 758                     System.out.println(&quot;curve: &quot; + Arrays.toString(Arrays.copyOfRange(src, i, i + type)));</span>
<span class="line-added"> 759                 }</span>
<span class="line-added"> 760 </span>
<span class="line-added"> 761                 if (type == 8) {</span>
<span class="line-added"> 762                     if (TRACE_SUBDIVIDE_CURVE) {</span>
<span class="line-added"> 763                         len += curvelen(src[i + 0], src[i + 1], src[i + 2], src[i + 3], src[i + 4], src[i + 5], src[i + 6], src[i + 7]);</span>
<span class="line-added"> 764                     }</span>
<span class="line-added"> 765                     p2d.curveTo(src[i + 2], src[i + 3], src[i + 4], src[i + 5], src[i + 6], src[i + 7]);</span>
<span class="line-added"> 766                 } else {</span>
<span class="line-added"> 767                     if (TRACE_SUBDIVIDE_CURVE) {</span>
<span class="line-added"> 768                         len += quadlen(src[i + 0], src[i + 1], src[i + 2], src[i + 3], src[i + 4], src[i + 5]);</span>
<span class="line-added"> 769                     }</span>
<span class="line-added"> 770                     p2d.quadTo(src[i + 2], src[i + 3], src[i + 4], src[i + 5]);</span>
<span class="line-added"> 771                 }</span>
<span class="line-added"> 772             }</span>
<span class="line-added"> 773 </span>
<span class="line-added"> 774             if (TRACE_SUBDIVIDE_CURVE) {</span>
<span class="line-added"> 775                 System.out.println(&quot;curveLen (final) = &quot; + len);</span>
<span class="line-added"> 776             }</span>
<span class="line-added"> 777         } else {</span>
<span class="line-added"> 778             if (type == 8) {</span>
<span class="line-added"> 779                 p2d.curveTo(in[2], in[3], in[4], in[5], in[6], in[7]);</span>
<span class="line-added"> 780             } else {</span>
<span class="line-added"> 781                 p2d.quadTo(in[2], in[3], in[4], in[5]);</span>
 782             }
 783         }
 784     }
 785 
 786     static final float POINT_RADIUS = 2f;
 787     static final float LINE_WIDTH = 1f;
 788 
 789     static final Stroke OUTLINE_STROKE = new BasicStroke(LINE_WIDTH);
 790     static final int COLOR_ALPHA = 128;
 791     static final Color COLOR_MOVETO = new Color(255, 0, 0, COLOR_ALPHA);
 792     static final Color COLOR_LINETO_ODD = new Color(0, 0, 255, COLOR_ALPHA);
 793     static final Color COLOR_LINETO_EVEN = new Color(0, 255, 0, COLOR_ALPHA);
 794 
 795     static final Ellipse2D.Float ELL_POINT = new Ellipse2D.Float();
 796 
 797     private static void paintShapeDetails(final Graphics2D g2d, final Shape shape) {
 798 
 799         final Stroke oldStroke = g2d.getStroke();
 800         final Color oldColor = g2d.getColor();
 801 
</pre>
<hr />
<pre>
 982 
 983         private static String getWindingRule(final int rule) {
 984             switch (rule) {
 985                 case PathIterator.WIND_EVEN_ODD:
 986                     return &quot;WIND_EVEN_ODD&quot;;
 987                 case PathIterator.WIND_NON_ZERO:
 988                     return &quot;WIND_NON_ZERO&quot;;
 989                 default:
 990                     return &quot;&quot;;
 991             }
 992         }
 993     }
 994 
 995     // --- utilities ---
 996     private static final int DCM_ALPHA_MASK = 0xff000000;
 997 
 998     public static BufferedImage newImage(final int w, final int h) {
 999         return new BufferedImage(w, h, BufferedImage.TYPE_INT_ARGB_PRE);
1000     }
1001 
<span class="line-modified">1002     public static BufferedImage computeDiffImage(final DiffContext testCtx,</span>
<span class="line-added">1003                                                  final DiffContext testThCtx,</span>
1004                                                  final BufferedImage tstImage,
1005                                                  final BufferedImage refImage,
<span class="line-modified">1006                                                  final BufferedImage diffImage) {</span>

1007 
1008         final int[] aRefPix = ((DataBufferInt) refImage.getRaster().getDataBuffer()).getData();
1009         final int[] aTstPix = ((DataBufferInt) tstImage.getRaster().getDataBuffer()).getData();
1010         final int[] aDifPix = ((DataBufferInt) diffImage.getRaster().getDataBuffer()).getData();
1011 
<span class="line-modified">1012         // reset diff contexts:</span>
<span class="line-modified">1013         testCtx.reset();</span>
<span class="line-added">1014         testThCtx.reset();</span>
1015 
1016         int ref, tst, dg, v;
1017         for (int i = 0, len = aRefPix.length; i &lt; len; i++) {
1018             ref = aRefPix[i];
1019             tst = aTstPix[i];
1020 
1021             // grayscale diff:
1022             dg = (r(ref) + g(ref) + b(ref)) - (r(tst) + g(tst) + b(tst));
1023 
1024             // max difference on grayscale values:
1025             v = (int) Math.ceil(Math.abs(dg / 3.0));


1026             if (v &lt;= THRESHOLD_DELTA) {
1027                 aDifPix[i] = 0;
1028             } else {
1029                 aDifPix[i] = toInt(v, v, v);
<span class="line-added">1030                 testThCtx.add(v);</span>
<span class="line-added">1031             }</span>
1032 
<span class="line-modified">1033             if (v != 0) {</span>
<span class="line-added">1034                 testCtx.add(v);</span>
1035             }

1036         }
1037 
<span class="line-modified">1038         testCtx.addNbPix(testThCtx.histPix.count);</span>
<span class="line-added">1039 </span>
<span class="line-added">1040         if (!testThCtx.isDiff() || (testThCtx.histPix.count &lt;= THRESHOLD_NBPIX)) {</span>
1041             return null;
1042         }
1043 


1044         return diffImage;
1045     }
1046 
1047     static void saveImage(final BufferedImage image, final File resDirectory, final String imageFileName) throws IOException {
1048         final Iterator&lt;ImageWriter&gt; itWriters = ImageIO.getImageWritersByFormatName(&quot;PNG&quot;);
1049         if (itWriters.hasNext()) {
1050             final ImageWriter writer = itWriters.next();
1051 
1052             final ImageWriteParam writerParams = writer.getDefaultWriteParam();
1053             writerParams.setProgressiveMode(ImageWriteParam.MODE_DISABLED);
1054 
1055             final File imgFile = new File(resDirectory, imageFileName);
1056 
1057             if (!imgFile.exists() || imgFile.canWrite()) {
1058                 System.out.println(&quot;saveImage: saving image as PNG [&quot; + imgFile + &quot;]...&quot;);
1059                 imgFile.delete();
1060 
1061                 // disable cache in temporary files:
1062                 ImageIO.setUseCache(false);
1063 
</pre>
<hr />
<pre>
1124             sum += val;
1125             if (val &lt; min) {
1126                 min = val;
1127             }
1128             if (val &gt; max) {
1129                 max = val;
1130             }
1131         }
1132 
1133         void add(long val) {
1134             count++;
1135             sum += val;
1136             if (val &lt; min) {
1137                 min = val;
1138             }
1139             if (val &gt; max) {
1140                 max = val;
1141             }
1142         }
1143 
<span class="line-added">1144         void add(StatInteger stat) {</span>
<span class="line-added">1145             count += stat.count;</span>
<span class="line-added">1146             sum += stat.sum;</span>
<span class="line-added">1147             if (stat.min &lt; min) {</span>
<span class="line-added">1148                 min = stat.min;</span>
<span class="line-added">1149             }</span>
<span class="line-added">1150             if (stat.max &gt; max) {</span>
<span class="line-added">1151                 max = stat.max;</span>
<span class="line-added">1152             }</span>
<span class="line-added">1153         }</span>
<span class="line-added">1154 </span>
1155         public final double average() {
1156             return ((double) sum) / count;
1157         }
1158 
1159         @Override
1160         public String toString() {
1161             final StringBuilder sb = new StringBuilder(128);
1162             toString(sb);
1163             return sb.toString();
1164         }
1165 
1166         public final StringBuilder toString(final StringBuilder sb) {
1167             sb.append(name).append(&quot;[n: &quot;).append(count);
<span class="line-modified">1168             sb.append(&quot;] &quot;);</span>
<span class="line-modified">1169             if (count != 0) {</span>
<span class="line-added">1170                 sb.append(&quot;sum: &quot;).append(sum).append(&quot; avg: &quot;).append(trimTo3Digits(average()));</span>
<span class="line-added">1171                 sb.append(&quot; [&quot;).append(min).append(&quot; | &quot;).append(max).append(&quot;]&quot;);</span>
<span class="line-added">1172             }</span>
1173             return sb;
1174         }
1175 
1176     }
1177 
1178     final static class Histogram extends StatInteger {
1179 
1180         static final int BUCKET = 2;
1181         static final int MAX = 20;
1182         static final int LAST = MAX - 1;
1183         static final int[] STEPS = new int[MAX];
<span class="line-added">1184         static final int BUCKET_TH;</span>
1185 
1186         static {
1187             STEPS[0] = 0;
1188             STEPS[1] = 1;
1189 
1190             for (int i = 2; i &lt; MAX; i++) {
1191                 STEPS[i] = STEPS[i - 1] * BUCKET;
1192             }
1193 //            System.out.println(&quot;Histogram.STEPS = &quot; + Arrays.toString(STEPS));
<span class="line-added">1194 </span>
<span class="line-added">1195             if (THRESHOLD_DELTA % 2 != 0) {</span>
<span class="line-added">1196                 throw new IllegalStateException(&quot;THRESHOLD_DELTA must be odd&quot;);</span>
<span class="line-added">1197             }</span>
<span class="line-added">1198 </span>
<span class="line-added">1199             BUCKET_TH = bucket(THRESHOLD_DELTA);</span>
1200         }
1201 
1202         static int bucket(int val) {
1203             for (int i = 1; i &lt; MAX; i++) {
1204                 if (val &lt; STEPS[i]) {
1205                     return i - 1;
1206                 }
1207             }
1208             return LAST;
1209         }
1210 
1211         private final StatInteger[] stats = new StatInteger[MAX];
1212 
1213         public Histogram(String name) {
1214             super(name);
1215             for (int i = 0; i &lt; MAX; i++) {
1216                 stats[i] = new StatInteger(String.format(&quot;%5s .. %5s&quot;, STEPS[i], ((i + 1 &lt; MAX) ? STEPS[i + 1] : &quot;~&quot;)));
1217             }
1218         }
1219 
1220         @Override
1221         final void reset() {
1222             super.reset();
1223             for (int i = 0; i &lt; MAX; i++) {
1224                 stats[i].reset();
1225             }
1226         }
1227 
1228         @Override
1229         final void add(int val) {
1230             super.add(val);
1231             stats[bucket(val)].add(val);
1232         }
1233 
1234         @Override
1235         final void add(long val) {
1236             add((int) val);
1237         }
1238 
<span class="line-added">1239         void add(Histogram hist) {</span>
<span class="line-added">1240             super.add(hist);</span>
<span class="line-added">1241             for (int i = 0; i &lt; MAX; i++) {</span>
<span class="line-added">1242                 stats[i].add(hist.stats[i]);</span>
<span class="line-added">1243             }</span>
<span class="line-added">1244         }</span>
<span class="line-added">1245 </span>
<span class="line-added">1246         boolean isWorse(Histogram hist, boolean useTh) {</span>
<span class="line-added">1247             boolean worst = false;</span>
<span class="line-added">1248             if (!useTh &amp;&amp; (hist.sum &gt; sum)) {</span>
<span class="line-added">1249                 worst = true;</span>
<span class="line-added">1250             } else {</span>
<span class="line-added">1251                 long sumLoc = 0l;</span>
<span class="line-added">1252                 long sumHist = 0l;</span>
<span class="line-added">1253                 // use running sum:</span>
<span class="line-added">1254                 for (int i = MAX - 1; i &gt;= BUCKET_TH; i--) {</span>
<span class="line-added">1255                     sumLoc += stats[i].sum;</span>
<span class="line-added">1256                     sumHist += hist.stats[i].sum;</span>
<span class="line-added">1257                 }</span>
<span class="line-added">1258                 if (sumHist &gt; sumLoc) {</span>
<span class="line-added">1259                     worst = true;</span>
<span class="line-added">1260                 }</span>
<span class="line-added">1261             }</span>
<span class="line-added">1262             /*</span>
<span class="line-added">1263             System.out.println(&quot;running sum worst:&quot;);</span>
<span class="line-added">1264             System.out.println(&quot;this ? &quot; + toString());</span>
<span class="line-added">1265             System.out.println(&quot;worst ? &quot; + hist.toString());</span>
<span class="line-added">1266              */</span>
<span class="line-added">1267             return worst;</span>
<span class="line-added">1268         }</span>
<span class="line-added">1269 </span>
1270         @Override
1271         public final String toString() {
1272             final StringBuilder sb = new StringBuilder(2048);
1273             super.toString(sb).append(&quot; { &quot;);
1274 
1275             for (int i = 0; i &lt; MAX; i++) {
1276                 if (stats[i].count != 0l) {
1277                     sb.append(&quot;\n        &quot;).append(stats[i].toString());
1278                 }
1279             }
1280 
1281             return sb.append(&quot; }&quot;).toString();
1282         }
1283     }
1284 
1285     /**
1286      * Adjust the given double value to keep only 3 decimal digits
1287      * @param value value to adjust
1288      * @return double value with only 3 decimal digits
1289      */
1290     static double trimTo3Digits(final double value) {
1291         return ((long) (1e3d * value)) / 1e3d;
1292     }
1293 
1294     static final class DiffContext {
1295 

1296         public final Histogram histPix;
1297 
<span class="line-added">1298         public final StatInteger nbPix;</span>
<span class="line-added">1299 </span>
1300         DiffContext(String name) {

1301             histPix = new Histogram(&quot;Diff Pixels [&quot; + name + &quot;]&quot;);
<span class="line-added">1302             nbPix = new StatInteger(&quot;NbPixels [&quot; + name + &quot;]&quot;);</span>
1303         }
1304 
1305         void reset() {

1306             histPix.reset();
<span class="line-added">1307             nbPix.reset();</span>
1308         }
1309 
1310         void dump() {
1311             if (isDiff()) {
<span class="line-modified">1312                 System.out.println(&quot;Differences [&quot; + histPix.name + &quot;]:\n&quot;</span>
<span class="line-modified">1313                         + ((nbPix.count != 0) ? (nbPix.toString() + &quot;\n&quot;) : &quot;&quot;)</span>
<span class="line-modified">1314                         + histPix.toString()</span>
<span class="line-added">1315                 );</span>
1316             } else {
<span class="line-modified">1317                 System.out.println(&quot;No difference for [&quot; + histPix.name + &quot;].&quot;);</span>
1318             }
1319         }
1320 
1321         void add(int val) {
<span class="line-modified">1322             histPix.add(val);</span>
<span class="line-modified">1323         }</span>
<span class="line-modified">1324 </span>
<span class="line-added">1325         void add(DiffContext ctx) {</span>
<span class="line-added">1326             histPix.add(ctx.histPix);</span>
<span class="line-added">1327             if (ctx.nbPix.count != 0L) {</span>
<span class="line-added">1328                 nbPix.add(ctx.nbPix);</span>
1329             }
1330         }
1331 
<span class="line-added">1332         void addNbPix(long val) {</span>
<span class="line-added">1333             if (val != 0L) {</span>
<span class="line-added">1334                 nbPix.add(val);</span>
<span class="line-added">1335             }</span>
<span class="line-added">1336         }</span>
<span class="line-added">1337 </span>
<span class="line-added">1338         void set(DiffContext ctx) {</span>
<span class="line-added">1339             reset();</span>
<span class="line-added">1340             add(ctx);</span>
<span class="line-added">1341         }</span>
<span class="line-added">1342 </span>
<span class="line-added">1343         boolean isWorse(DiffContext ctx, boolean useTh) {</span>
<span class="line-added">1344             return histPix.isWorse(ctx.histPix, useTh);</span>
<span class="line-added">1345         }</span>
<span class="line-added">1346 </span>
1347         boolean isDiff() {
<span class="line-modified">1348             return histPix.sum != 0l;</span>
1349         }
1350     }
<span class="line-added">1351 </span>
<span class="line-added">1352 </span>
<span class="line-added">1353     static double linelen(final double x0, final double y0,</span>
<span class="line-added">1354                           final double x1, final double y1)</span>
<span class="line-added">1355     {</span>
<span class="line-added">1356         final double dx = x1 - x0;</span>
<span class="line-added">1357         final double dy = y1 - y0;</span>
<span class="line-added">1358         return Math.sqrt(dx * dx + dy * dy);</span>
<span class="line-added">1359     }</span>
<span class="line-added">1360 </span>
<span class="line-added">1361     static double quadlen(final double x0, final double y0,</span>
<span class="line-added">1362                           final double x1, final double y1,</span>
<span class="line-added">1363                           final double x2, final double y2)</span>
<span class="line-added">1364     {</span>
<span class="line-added">1365         return (linelen(x0, y0, x1, y1)</span>
<span class="line-added">1366                 + linelen(x1, y1, x2, y2)</span>
<span class="line-added">1367                 + linelen(x0, y0, x2, y2)) / 2.0d;</span>
<span class="line-added">1368     }</span>
<span class="line-added">1369 </span>
<span class="line-added">1370     static double curvelen(final double x0, final double y0,</span>
<span class="line-added">1371                            final double x1, final double y1,</span>
<span class="line-added">1372                            final double x2, final double y2,</span>
<span class="line-added">1373                            final double x3, final double y3)</span>
<span class="line-added">1374     {</span>
<span class="line-added">1375         return (linelen(x0, y0, x1, y1)</span>
<span class="line-added">1376               + linelen(x1, y1, x2, y2)</span>
<span class="line-added">1377               + linelen(x2, y2, x3, y3)</span>
<span class="line-added">1378               + linelen(x0, y0, x3, y3)) / 2.0d;</span>
<span class="line-added">1379     }</span>
1380 }
</pre>
</td>
</tr>
</table>
<center><a href="../cmm/ColorConvertOp/ConstructorsNullTest/ConstructorsNullTest.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="../pipe/hw/RSLAPITest/RSLAPITest.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
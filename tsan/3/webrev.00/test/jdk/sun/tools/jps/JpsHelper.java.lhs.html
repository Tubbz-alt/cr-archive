<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames test/jdk/sun/tools/jps/JpsHelper.java</title>
    <link rel="stylesheet" href="../../../../../style.css" />
    <script type="text/javascript" src="../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
<a name="1" id="anc1"></a><span class="line-modified">  2  * Copyright (c) 2014, 2018, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 import static jdk.test.lib.Asserts.assertGreaterThan;
 25 import static jdk.test.lib.Asserts.assertTrue;
 26 
 27 import java.io.BufferedWriter;
 28 import java.io.File;
 29 import java.io.FileWriter;
 30 import java.io.IOException;
 31 import java.nio.file.Files;
 32 import java.nio.file.Path;
 33 import java.nio.file.Paths;
 34 import java.util.ArrayList;
 35 import java.util.Arrays;
 36 import java.util.List;
 37 
 38 import jdk.test.lib.JDKToolLauncher;
 39 import jdk.test.lib.process.OutputAnalyzer;
 40 import jdk.test.lib.process.ProcessTools;
 41 import jdk.test.lib.Asserts;
 42 import jdk.test.lib.Utils;
 43 
 44 /**
 45  * The helper class for running jps utility and verifying output from it
 46  */
 47 public final class JpsHelper {
 48 
 49     /**
 50      * Helper class for handling jps arguments
 51      */
 52     public enum JpsArg {
 53         q,
 54         l,
 55         m,
 56         v,
 57         V;
 58 
 59         /**
 60          * Generate all possible combinations of {@link JpsArg}
 61          * (31 argument combinations and no arguments case)
 62          */
 63         public static List&lt;List&lt;JpsArg&gt;&gt; generateCombinations() {
 64             final int argCount = JpsArg.values().length;
 65             // If there are more than 30 args this algorithm will overflow.
 66             Asserts.assertLessThan(argCount, 31, &quot;Too many args&quot;);
 67 
 68             List&lt;List&lt;JpsArg&gt;&gt; combinations = new ArrayList&lt;&gt;();
 69             int combinationCount = (int) Math.pow(2, argCount);
 70             for (int currCombo = 0; currCombo &lt; combinationCount; ++currCombo) {
 71                 List&lt;JpsArg&gt; combination = new ArrayList&lt;&gt;();
 72                 for (int position = 0; position &lt; argCount; ++position) {
 73                     int bit = 1 &lt;&lt; position;
 74                     if ((bit &amp; currCombo) != 0) {
 75                         combination.add(JpsArg.values()[position]);
 76                     }
 77                 }
 78                 combinations.add(combination);
 79             }
 80             return combinations;
 81         }
 82 
 83         /**
 84          *  Return combination of {@link JpsArg} as a String array
 85          */
 86         public static String[] asCmdArray(List&lt;JpsArg&gt; jpsArgs) {
 87             List&lt;String&gt; list = new ArrayList&lt;&gt;();
 88             for (JpsArg jpsArg : jpsArgs) {
 89                 list.add(&quot;-&quot; + jpsArg.toString());
 90             }
 91             return list.toArray(new String[list.size()]);
 92         }
 93 
 94     }
 95 
<a name="2" id="anc2"></a><span class="line-removed"> 96     /**</span>
<span class="line-removed"> 97      * VM arguments to start test application with.</span>
<span class="line-removed"> 98      * -XX:+UsePerfData is required for running the tests on embedded platforms.</span>
<span class="line-removed"> 99      */</span>
<span class="line-removed">100     public static final String[] VM_ARGS = {</span>
<span class="line-removed">101         &quot;-XX:+UsePerfData&quot;, &quot;-Xmx512m&quot;, &quot;-Xlog:gc&quot;,</span>
<span class="line-removed">102         &quot;-Dmultiline.prop=value1\nvalue2\r\nvalue3&quot;</span>
<span class="line-removed">103     };</span>
104     /**
105      * VM flag to start test application with
106      */
107     public static final String VM_FLAG = &quot;+DisableExplicitGC&quot;;
108 
109     private static File vmFlagsFile = null;
<a name="3" id="anc3"></a><span class="line-modified">110     private static List&lt;String&gt; testVmArgs = null;</span>







111     private static File manifestFile = null;
112 
113     /**
114      * Create a file containing VM_FLAG in the working directory
115      */
116     public static File getVmFlagsFile() throws IOException {
117         if (vmFlagsFile == null) {
118             vmFlagsFile = new File(&quot;vmflags&quot;);
119             try (BufferedWriter output = new BufferedWriter(new FileWriter(vmFlagsFile))) {
120                 output.write(VM_FLAG);
121             }
122             vmFlagsFile.deleteOnExit();
123         }
124         return vmFlagsFile;
125     }
126 
127     /**
128      * Return a list of VM arguments
129      */
<a name="4" id="anc4"></a><span class="line-modified">130     public static List&lt;String&gt; getVmArgs() throws IOException {</span>
<span class="line-modified">131         if (testVmArgs == null) {</span>
<span class="line-modified">132             testVmArgs = new ArrayList&lt;&gt;();</span>
<span class="line-removed">133             testVmArgs.addAll(Arrays.asList(VM_ARGS));</span>
<span class="line-removed">134             testVmArgs.add(&quot;-XX:Flags=&quot; + getVmFlagsFile().getAbsolutePath());</span>
135         }
136         return testVmArgs;
137     }
138 
139     /**
140      * Start jps utility without any arguments
141      */
142     public static OutputAnalyzer jps() throws Exception {
143         return jps(null, null);
144     }
145 
146     /**
147      * Start jps utility with tool arguments
148      */
149     public static OutputAnalyzer jps(String... toolArgs) throws Exception {
150         return jps(null, Arrays.asList(toolArgs));
151     }
152 
153     /**
154      * Start jps utility with VM args and tool arguments
155      */
156     public static OutputAnalyzer jps(List&lt;String&gt; vmArgs, List&lt;String&gt; toolArgs) throws Exception {
157         JDKToolLauncher launcher = JDKToolLauncher.createUsingTestJDK(&quot;jps&quot;);
158         launcher.addVMArg(&quot;-XX:+UsePerfData&quot;);
159         if (vmArgs != null) {
160             for (String vmArg : vmArgs) {
161                 launcher.addVMArg(vmArg);
162             }
163         }
164         if (toolArgs != null) {
165             for (String toolArg : toolArgs) {
166                 launcher.addToolArg(toolArg);
167             }
168         }
169 
170         ProcessBuilder processBuilder = new ProcessBuilder(launcher.getCommand());
171         System.out.println(Arrays.toString(processBuilder.command().toArray()).replace(&quot;,&quot;, &quot;&quot;));
172         OutputAnalyzer output = ProcessTools.executeProcess(processBuilder);
173         System.out.println(output.getOutput());
174 
175         return output;
176     }
177 
178     /**
179      * Verify jps stdout contains only pids and programs&#39; name information.
180      * jps stderr may contain VM warning messages which will be ignored.
181      *
182      * The output can look like:
183      * 35536 Jps
184      * 35417 Main
185      * 31103 org.eclipse.equinox.launcher_1.3.0.v20120522-1813.jar
186      */
187     public static void verifyJpsOutput(OutputAnalyzer output, String regex) {
188         output.shouldHaveExitValue(0);
189         output.stdoutShouldMatchByLine(regex);
190         output.stderrShouldNotMatch(&quot;[E|e]xception&quot;);
191         output.stderrShouldNotMatch(&quot;[E|e]rror&quot;);
192     }
193 
194     /**
195      * Compare jps output with a content in a file line by line
196      */
197     public static void verifyOutputAgainstFile(OutputAnalyzer output) throws IOException {
198         String testSrc = System.getProperty(&quot;test.src&quot;, &quot;?&quot;);
199         Path path = Paths.get(testSrc, &quot;usage.out&quot;);
200         List&lt;String&gt; fileOutput = Files.readAllLines(path);
201         List&lt;String&gt; outputAsLines = output.asLines();
202         assertTrue(outputAsLines.containsAll(fileOutput),
203                 &quot;The ouput should contain all content of &quot; + path.toAbsolutePath());
204     }
205 
206     public static void runJpsVariants(Long pid, String processName, String fullProcessName, String argument) throws Exception {
207         System.out.printf(&quot;INFO: user.dir:  &#39;%s&#39;&#39;\n&quot;, System.getProperty(&quot;user.dir&quot;));
208         List&lt;List&lt;JpsHelper.JpsArg&gt;&gt; combinations = JpsHelper.JpsArg.generateCombinations();
209         for (List&lt;JpsHelper.JpsArg&gt; combination : combinations) {
210             OutputAnalyzer output = JpsHelper.jps(JpsHelper.JpsArg.asCmdArray(combination));
211             output.shouldHaveExitValue(0);
212 
213             boolean isQuiet = false;
214             boolean isFull = false;
215             String pattern;
216             for (JpsHelper.JpsArg jpsArg : combination) {
217                 switch (jpsArg) {
218                 case q:
219                     // If &#39;-q&#39; is specified output should contain only a list of local VM identifiers:
220                     // 30673
221                     isQuiet = true;
222                     JpsHelper.verifyJpsOutput(output, &quot;^\\d+$&quot;);
223                     output.shouldContain(Long.toString(pid));
224                     break;
225                 case l:
226                     // If &#39;-l&#39; is specified output should contain the full package name for the application&#39;s main class
227                     // or the full path name to the application&#39;s JAR file:
228                     // 30673 /tmp/jtreg/jtreg-workdir/scratch/LingeredAppForJps.jar ...
229                     isFull = true;
230                     pattern = &quot;^&quot; + pid + &quot;\\s+&quot; + replaceSpecialChars(fullProcessName) + &quot;.*&quot;;
231                     output.shouldMatch(pattern);
232                     break;
233                 case m:
234                     // If &#39;-m&#39; is specified output should contain the arguments passed to the main method:
235                     // 30673 LingeredAppForJps lockfilename ...
236                     pattern = &quot;^&quot; + pid + &quot;.*&quot; + replaceSpecialChars(argument) + &quot;.*&quot;;
237                     output.shouldMatch(pattern);
238                     break;
239                 case v:
240                     // If &#39;-v&#39; is specified output should contain VM arguments:
241                     // 30673 LingeredAppForJps -Xmx512m -XX:+UseParallelGC -XX:Flags=/tmp/jtreg/jtreg-workdir/scratch/vmflags ...
242                     for (String vmArg : JpsHelper.getVmArgs()) {
243                         pattern = &quot;^&quot; + pid + &quot;.*&quot; + replaceSpecialChars(vmArg) + &quot;.*&quot;;
244                         output.shouldMatch(pattern);
245                     }
246                     break;
247                 case V:
248                     // If &#39;-V&#39; is specified output should contain VM flags:
249                     // 30673 LingeredAppForJps +DisableExplicitGC ...
250                     pattern = &quot;^&quot; + pid + &quot;.*&quot; + replaceSpecialChars(JpsHelper.VM_FLAG) + &quot;.*&quot;;
251                     output.shouldMatch(pattern);
252                     break;
253                 }
254 
255                 if (isQuiet) {
256                     break;
257                 }
258             }
259 
260             if (!isQuiet) {
261                 // Verify output line by line.
262                 // Output should only contain lines with pids after the first line with pid.
263                 JpsHelper.verifyJpsOutput(output, &quot;^\\d+\\s+.*&quot;);
264                 if (!isFull) {
265                     pattern = &quot;^&quot; + pid + &quot;\\s+&quot; + replaceSpecialChars(processName);
266                     if (combination.isEmpty()) {
267                         // If no arguments are specified output should only contain
268                         // pid and process name
269                         pattern += &quot;$&quot;;
270                     } else {
271                         pattern += &quot;.*&quot;;
272                     }
273                     output.shouldMatch(pattern);
274                 }
275             }
276         }
277     }
278 
279     private static String replaceSpecialChars(String str) {
280         String tmp = str.replace(&quot;\\&quot;, &quot;\\\\&quot;);
281         tmp = tmp.replace(&quot;+&quot;, &quot;\\+&quot;);
282         tmp = tmp.replace(&quot;.&quot;, &quot;\\.&quot;);
283         tmp = tmp.replace(&quot;\n&quot;, &quot;\\\\n&quot;);
284         tmp = tmp.replace(&quot;\r&quot;, &quot;\\\\r&quot;);
285         return tmp;
286     }
287 }
<a name="5" id="anc5"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="5" type="hidden" />
</body>
</html>
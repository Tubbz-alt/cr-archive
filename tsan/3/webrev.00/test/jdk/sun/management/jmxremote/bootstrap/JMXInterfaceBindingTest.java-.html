<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old test/jdk/sun/management/jmxremote/bootstrap/JMXInterfaceBindingTest.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2015, Red Hat Inc
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 import java.io.File;
 25 import java.net.InetAddress;
 26 import java.net.NetworkInterface;
 27 import java.net.UnknownHostException;
 28 import java.net.SocketException;
 29 import java.util.ArrayList;
 30 import java.util.List;
 31 import java.util.stream.Collectors;
 32 
 33 import jdk.test.lib.thread.ProcessThread;
 34 import jdk.test.lib.process.ProcessTools;
 35 
 36 /**
 37  * @test
 38  * @bug     6425769
 39  * @summary Test JMX agent host address binding. Same ports but different
 40  *          interfaces to bind to (selecting plain or SSL sockets at random
 41  * @key intermittent
 42  *
 43  * @library /test/lib
 44  * @modules java.management.rmi
 45  *
 46  * @build JMXAgentInterfaceBinding
 47  * @run main/timeout=60 JMXInterfaceBindingTest
 48  */
 49 public class JMXInterfaceBindingTest {
 50 
 51     public static final int COMMUNICATION_ERROR_EXIT_VAL = 1;
 52     public static final int STOP_PROCESS_EXIT_VAL = 10;
 53     public static final int JMX_PORT_RANGE_LOWER = 9100;
 54     public static final int JMX_PORT_RANGE_UPPER = 9200;
 55     public static final int JMX_PORT = getRandomPortInRange(JMX_PORT_RANGE_LOWER,
 56                                                             JMX_PORT_RANGE_UPPER);
 57     public static final int JMX_PORT_RANGE_LOWER_SSL = 9201; // 9200 might be RMI Port
 58     public static final int JMX_PORT_RANGE_UPPER_SSL = 9300;
 59     public static final int JMX_PORT_SSL = getRandomPortInRange(JMX_PORT_RANGE_LOWER_SSL,
 60                                                                 JMX_PORT_RANGE_UPPER_SSL);
 61     public static final int RMI_PORT = JMX_PORT + 1;
 62     public static final int RMI_PORT_SSL = JMX_PORT_SSL + 1;
 63     public static final String READY_MSG = &quot;MainThread: Ready for connections&quot;;
 64     public static final String TEST_CLASS = JMXAgentInterfaceBinding.class.getSimpleName();
 65     public static final String KEYSTORE_LOC = System.getProperty(&quot;test.src&quot;, &quot;.&quot;) +
 66                                               File.separator +
 67                                               &quot;ssl&quot; +
 68                                               File.separator +
 69                                               &quot;keystore&quot;;
 70     public static final String TRUSTSTORE_LOC = System.getProperty(&quot;test.src&quot;, &quot;.&quot;) +
 71                                                 File.separator +
 72                                                 &quot;ssl&quot; +
 73                                                 File.separator +
 74                                                 &quot;truststore&quot;;
 75     public static final String TEST_CLASSPATH = System.getProperty(&quot;test.classes&quot;, &quot;.&quot;);
 76 
 77     public void run(List&lt;InetAddress&gt; addrs) {
 78         System.out.println(&quot;DEBUG: Running tests with plain sockets.&quot;);
 79         runTests(addrs, false);
 80         System.out.println(&quot;DEBUG: Running tests with SSL sockets.&quot;);
 81         runTests(addrs, true);
 82     }
 83 
 84     private void runTests(List&lt;InetAddress&gt; addrs, boolean useSSL) {
 85         List&lt;ProcessThread&gt; jvms = new ArrayList&lt;&gt;(addrs.size());
 86         int i = 1;
 87         for (InetAddress addr : addrs) {
 88             String address = JMXAgentInterfaceBinding.wrapAddress(addr.getHostAddress());
 89             System.out.println();
 90             String msg = String.format(&quot;DEBUG: Launching java tester for triplet (HOSTNAME,JMX_PORT,RMI_PORT) == (%s,%d,%d)&quot;,
 91                     address,
 92                     useSSL ? JMX_PORT_SSL : JMX_PORT,
 93                     useSSL ? RMI_PORT_SSL : RMI_PORT);
 94             System.out.println(msg);
 95             ProcessThread jvm = runJMXBindingTest(address, useSSL);
 96             jvms.add(jvm);
 97             jvm.start();
 98             System.out.println(&quot;DEBUG: Started &quot; + (i++) + &quot; Process(es).&quot;);
 99         }
100         int failedProcesses = 0;
101         for (ProcessThread pt: jvms) {
102             try {
103                 pt.sendMessage(&quot;Exit: &quot; + STOP_PROCESS_EXIT_VAL);
104                 pt.join();
105             } catch (Throwable e) {
106                 System.err.println(&quot;Failed to stop process: &quot; + pt.getName());
107                 throw new RuntimeException(&quot;Test failed&quot;, e);
108             }
109             int exitValue = pt.getOutput().getExitValue();
110             // If there is a communication error (the case we care about)
111             // we get a exit code of 1
112             if (exitValue == COMMUNICATION_ERROR_EXIT_VAL) {
113                 // Failure case since the java processes should still be
114                 // running.
115                 System.err.println(&quot;Test FAILURE on &quot; + pt.getName());
116                 failedProcesses++;
117             } else if (exitValue == STOP_PROCESS_EXIT_VAL) {
118                 System.out.println(&quot;DEBUG: OK. Spawned java process terminated with expected exit code of &quot; + STOP_PROCESS_EXIT_VAL);
119             } else {
120                 System.err.println(&quot;Test FAILURE on &quot; + pt.getName() + &quot; reason: Unexpected exit code =&gt; &quot; + exitValue);
121                 failedProcesses++;
122             }
123         }
124         if (failedProcesses &gt; 0) {
125             throw new RuntimeException(&quot;Test FAILED. &quot; + failedProcesses + &quot; out of &quot; + addrs.size() + &quot; process(es) failed to start the JMX agent.&quot;);
126         }
127     }
128 
129     private ProcessThread runJMXBindingTest(String address, boolean useSSL) {
130         List&lt;String&gt; args = new ArrayList&lt;&gt;();
131         args.add(&quot;-classpath&quot;);
132         args.add(TEST_CLASSPATH);
133         args.add(&quot;-Dcom.sun.management.jmxremote.host=&quot; + address);
134         args.add(&quot;-Dcom.sun.management.jmxremote.port=&quot; + (useSSL ? JMX_PORT_SSL : JMX_PORT));
135         args.add(&quot;-Dcom.sun.management.jmxremote.rmi.port=&quot; + (useSSL ? RMI_PORT_SSL : RMI_PORT));
136         args.add(&quot;-Dcom.sun.management.jmxremote.authenticate=false&quot;);
137         args.add(&quot;-Dcom.sun.management.jmxremote.ssl=&quot; + Boolean.toString(useSSL));
138         // This is needed for testing on loopback
139         args.add(&quot;-Djava.rmi.server.hostname=&quot; + address);
140         if (useSSL) {
141             args.add(&quot;-Dcom.sun.management.jmxremote.registry.ssl=true&quot;);
142             args.add(&quot;-Djavax.net.ssl.keyStore=&quot; + KEYSTORE_LOC);
143             args.add(&quot;-Djavax.net.ssl.trustStore=&quot; + TRUSTSTORE_LOC);
144             args.add(&quot;-Djavax.net.ssl.keyStorePassword=password&quot;);
145             args.add(&quot;-Djavax.net.ssl.trustStorePassword=trustword&quot;);
146         }
147         args.add(TEST_CLASS);
148         args.add(address);
149         args.add(Integer.toString(useSSL ? JMX_PORT_SSL : JMX_PORT));
150         args.add(Integer.toString(useSSL ? RMI_PORT_SSL : RMI_PORT));
151         args.add(Boolean.toString(useSSL));
152         try {
153             ProcessBuilder builder = ProcessTools.createJavaProcessBuilder(args.toArray(new String[] {}));
154             System.out.println(ProcessTools.getCommandLine(builder));
155             ProcessThread jvm = new ProcessThread(&quot;JMX-Tester-&quot; + address, JMXInterfaceBindingTest::isJMXAgentResponseAvailable, builder);
156             return jvm;
157         } catch (Exception e) {
158             throw new RuntimeException(&quot;Test failed&quot;, e);
159         }
160 
161     }
162 
163     private static boolean isJMXAgentResponseAvailable(String line) {
164         if (line.equals(READY_MSG)) {
165             System.out.println(&quot;DEBUG: Found expected READY_MSG.&quot;);
166             return true;
167         } else if (line.startsWith(&quot;Error:&quot;)) {
168             // Allow for a JVM process that exits with
169             // &quot;Error: JMX connector server communication error: ...&quot;
170             // to continue as well since we handle that case elsewhere.
171             // This has the effect that the test does not timeout and
172             // fails with an exception in the test.
173             System.err.println(&quot;PROBLEM: JMX agent of target JVM did not start as it should.&quot;);
174             return true;
175         } else {
176             return false;
177         }
178     }
179 
180     private static int getRandomPortInRange(int lower, int upper) {
181         if (upper &lt;= lower) {
182             throw new IllegalArgumentException(&quot;upper &lt;= lower&quot;);
183         }
184         int range = upper - lower;
185         int randPort = lower + (int)(Math.random() * range);
186         return randPort;
187     }
188 
189     public static void main(String[] args) {
190         List&lt;InetAddress&gt; addrs = getNonLoopbackAddressesForLocalHost();
191         if (addrs.isEmpty()) {
192             System.out.println(&quot;Ignoring test since no non-loopback IPs are available to bind to &quot; +
193                                &quot;in addition to the loopback interface.&quot;);
194             return;
195         }
196         JMXInterfaceBindingTest test = new JMXInterfaceBindingTest();
197         // Add loopback interface too as we&#39;d like to verify whether it&#39;s
198         // possible to bind to multiple addresses on the same host. This
199         // wasn&#39;t possible prior JDK-6425769. It used to bind to *all* local
200         // interfaces. We add loopback here, since that eases test setup.
201         addrs.add(InetAddress.getLoopbackAddress());
202         test.run(addrs);
203         System.out.println(&quot;All tests PASSED.&quot;);
204     }
205 
206     private static List&lt;InetAddress&gt; getNonLoopbackAddressesForLocalHost() {
207         List&lt;InetAddress&gt; addrs = new ArrayList&lt;&gt;();
208         try {
209             InetAddress localHost = InetAddress.getLocalHost();
210             if (!localHost.isLoopbackAddress()) {
211                 addrs.add(localHost);
212             }
213             return addrs;
214         } catch (UnknownHostException e) {
215             throw new RuntimeException(&quot;Test failed&quot;, e);
216         }
217     }
218 }
    </pre>
  </body>
</html>
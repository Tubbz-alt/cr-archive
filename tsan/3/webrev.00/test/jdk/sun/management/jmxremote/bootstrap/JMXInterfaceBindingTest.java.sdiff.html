<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff test/jdk/sun/management/jmxremote/bootstrap/JMXInterfaceBindingTest.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
<body>
<center><a href="GeneratePropertyPassword.sh.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="LocalManagementTest.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>test/jdk/sun/management/jmxremote/bootstrap/JMXInterfaceBindingTest.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 import java.io.File;

 25 import java.net.InetAddress;
<span class="line-removed"> 26 import java.net.NetworkInterface;</span>
 27 import java.net.UnknownHostException;
<span class="line-removed"> 28 import java.net.SocketException;</span>
 29 import java.util.ArrayList;
 30 import java.util.List;
<span class="line-modified"> 31 import java.util.stream.Collectors;</span>
 32 
<span class="line-modified"> 33 import jdk.test.lib.thread.ProcessThread;</span>
 34 import jdk.test.lib.process.ProcessTools;
 35 
 36 /**
 37  * @test
 38  * @bug     6425769
 39  * @summary Test JMX agent host address binding. Same ports but different
<span class="line-modified"> 40  *          interfaces to bind to (selecting plain or SSL sockets at random</span>
<span class="line-removed"> 41  * @key intermittent</span>
 42  *
 43  * @library /test/lib
 44  * @modules java.management.rmi
 45  *
 46  * @build JMXAgentInterfaceBinding
 47  * @run main/timeout=60 JMXInterfaceBindingTest
 48  */
 49 public class JMXInterfaceBindingTest {
 50 
 51     public static final int COMMUNICATION_ERROR_EXIT_VAL = 1;
 52     public static final int STOP_PROCESS_EXIT_VAL = 10;
 53     public static final int JMX_PORT_RANGE_LOWER = 9100;
 54     public static final int JMX_PORT_RANGE_UPPER = 9200;
<span class="line-removed"> 55     public static final int JMX_PORT = getRandomPortInRange(JMX_PORT_RANGE_LOWER,</span>
<span class="line-removed"> 56                                                             JMX_PORT_RANGE_UPPER);</span>
 57     public static final int JMX_PORT_RANGE_LOWER_SSL = 9201; // 9200 might be RMI Port
 58     public static final int JMX_PORT_RANGE_UPPER_SSL = 9300;
<span class="line-modified"> 59     public static final int JMX_PORT_SSL = getRandomPortInRange(JMX_PORT_RANGE_LOWER_SSL,</span>
<span class="line-removed"> 60                                                                 JMX_PORT_RANGE_UPPER_SSL);</span>
<span class="line-removed"> 61     public static final int RMI_PORT = JMX_PORT + 1;</span>
<span class="line-removed"> 62     public static final int RMI_PORT_SSL = JMX_PORT_SSL + 1;</span>
 63     public static final String READY_MSG = &quot;MainThread: Ready for connections&quot;;
 64     public static final String TEST_CLASS = JMXAgentInterfaceBinding.class.getSimpleName();
 65     public static final String KEYSTORE_LOC = System.getProperty(&quot;test.src&quot;, &quot;.&quot;) +
 66                                               File.separator +
 67                                               &quot;ssl&quot; +
 68                                               File.separator +
 69                                               &quot;keystore&quot;;
 70     public static final String TRUSTSTORE_LOC = System.getProperty(&quot;test.src&quot;, &quot;.&quot;) +
 71                                                 File.separator +
 72                                                 &quot;ssl&quot; +
 73                                                 File.separator +
 74                                                 &quot;truststore&quot;;
 75     public static final String TEST_CLASSPATH = System.getProperty(&quot;test.classes&quot;, &quot;.&quot;);
 76 
 77     public void run(List&lt;InetAddress&gt; addrs) {
 78         System.out.println(&quot;DEBUG: Running tests with plain sockets.&quot;);
 79         runTests(addrs, false);
 80         System.out.println(&quot;DEBUG: Running tests with SSL sockets.&quot;);
 81         runTests(addrs, true);
 82     }
 83 
 84     private void runTests(List&lt;InetAddress&gt; addrs, boolean useSSL) {
<span class="line-modified"> 85         List&lt;ProcessThread&gt; jvms = new ArrayList&lt;&gt;(addrs.size());</span>
<span class="line-modified"> 86         int i = 1;</span>
 87         for (InetAddress addr : addrs) {
 88             String address = JMXAgentInterfaceBinding.wrapAddress(addr.getHostAddress());
<span class="line-modified"> 89             System.out.println();</span>
<span class="line-modified"> 90             String msg = String.format(&quot;DEBUG: Launching java tester for triplet (HOSTNAME,JMX_PORT,RMI_PORT) == (%s,%d,%d)&quot;,</span>
<span class="line-modified"> 91                     address,</span>
<span class="line-removed"> 92                     useSSL ? JMX_PORT_SSL : JMX_PORT,</span>
<span class="line-removed"> 93                     useSSL ? RMI_PORT_SSL : RMI_PORT);</span>
<span class="line-removed"> 94             System.out.println(msg);</span>
<span class="line-removed"> 95             ProcessThread jvm = runJMXBindingTest(address, useSSL);</span>
<span class="line-removed"> 96             jvms.add(jvm);</span>
<span class="line-removed"> 97             jvm.start();</span>
<span class="line-removed"> 98             System.out.println(&quot;DEBUG: Started &quot; + (i++) + &quot; Process(es).&quot;);</span>
<span class="line-removed"> 99         }</span>
<span class="line-removed">100         int failedProcesses = 0;</span>
<span class="line-removed">101         for (ProcessThread pt: jvms) {</span>
<span class="line-removed">102             try {</span>
<span class="line-removed">103                 pt.sendMessage(&quot;Exit: &quot; + STOP_PROCESS_EXIT_VAL);</span>
<span class="line-removed">104                 pt.join();</span>
<span class="line-removed">105             } catch (Throwable e) {</span>
<span class="line-removed">106                 System.err.println(&quot;Failed to stop process: &quot; + pt.getName());</span>
<span class="line-removed">107                 throw new RuntimeException(&quot;Test failed&quot;, e);</span>
<span class="line-removed">108             }</span>
<span class="line-removed">109             int exitValue = pt.getOutput().getExitValue();</span>
<span class="line-removed">110             // If there is a communication error (the case we care about)</span>
<span class="line-removed">111             // we get a exit code of 1</span>
<span class="line-removed">112             if (exitValue == COMMUNICATION_ERROR_EXIT_VAL) {</span>
<span class="line-removed">113                 // Failure case since the java processes should still be</span>
<span class="line-removed">114                 // running.</span>
<span class="line-removed">115                 System.err.println(&quot;Test FAILURE on &quot; + pt.getName());</span>
<span class="line-removed">116                 failedProcesses++;</span>
<span class="line-removed">117             } else if (exitValue == STOP_PROCESS_EXIT_VAL) {</span>
<span class="line-removed">118                 System.out.println(&quot;DEBUG: OK. Spawned java process terminated with expected exit code of &quot; + STOP_PROCESS_EXIT_VAL);</span>
<span class="line-removed">119             } else {</span>
<span class="line-removed">120                 System.err.println(&quot;Test FAILURE on &quot; + pt.getName() + &quot; reason: Unexpected exit code =&gt; &quot; + exitValue);</span>
<span class="line-removed">121                 failedProcesses++;</span>
<span class="line-removed">122             }</span>
<span class="line-removed">123         }</span>
<span class="line-removed">124         if (failedProcesses &gt; 0) {</span>
<span class="line-removed">125             throw new RuntimeException(&quot;Test FAILED. &quot; + failedProcesses + &quot; out of &quot; + addrs.size() + &quot; process(es) failed to start the JMX agent.&quot;);</span>
<span class="line-removed">126         }</span>
<span class="line-removed">127     }</span>
<span class="line-removed">128 </span>
<span class="line-removed">129     private ProcessThread runJMXBindingTest(String address, boolean useSSL) {</span>
<span class="line-removed">130         List&lt;String&gt; args = new ArrayList&lt;&gt;();</span>
<span class="line-removed">131         args.add(&quot;-classpath&quot;);</span>
<span class="line-removed">132         args.add(TEST_CLASSPATH);</span>
<span class="line-removed">133         args.add(&quot;-Dcom.sun.management.jmxremote.host=&quot; + address);</span>
<span class="line-removed">134         args.add(&quot;-Dcom.sun.management.jmxremote.port=&quot; + (useSSL ? JMX_PORT_SSL : JMX_PORT));</span>
<span class="line-removed">135         args.add(&quot;-Dcom.sun.management.jmxremote.rmi.port=&quot; + (useSSL ? RMI_PORT_SSL : RMI_PORT));</span>
<span class="line-removed">136         args.add(&quot;-Dcom.sun.management.jmxremote.authenticate=false&quot;);</span>
<span class="line-removed">137         args.add(&quot;-Dcom.sun.management.jmxremote.ssl=&quot; + Boolean.toString(useSSL));</span>
<span class="line-removed">138         // This is needed for testing on loopback</span>
<span class="line-removed">139         args.add(&quot;-Djava.rmi.server.hostname=&quot; + address);</span>
<span class="line-removed">140         if (useSSL) {</span>
<span class="line-removed">141             args.add(&quot;-Dcom.sun.management.jmxremote.registry.ssl=true&quot;);</span>
<span class="line-removed">142             args.add(&quot;-Djavax.net.ssl.keyStore=&quot; + KEYSTORE_LOC);</span>
<span class="line-removed">143             args.add(&quot;-Djavax.net.ssl.trustStore=&quot; + TRUSTSTORE_LOC);</span>
<span class="line-removed">144             args.add(&quot;-Djavax.net.ssl.keyStorePassword=password&quot;);</span>
<span class="line-removed">145             args.add(&quot;-Djavax.net.ssl.trustStorePassword=trustword&quot;);</span>
146         }
<span class="line-removed">147         args.add(TEST_CLASS);</span>
<span class="line-removed">148         args.add(address);</span>
<span class="line-removed">149         args.add(Integer.toString(useSSL ? JMX_PORT_SSL : JMX_PORT));</span>
<span class="line-removed">150         args.add(Integer.toString(useSSL ? RMI_PORT_SSL : RMI_PORT));</span>
<span class="line-removed">151         args.add(Boolean.toString(useSSL));</span>
152         try {
<span class="line-modified">153             ProcessBuilder builder = ProcessTools.createJavaProcessBuilder(args.toArray(new String[] {}));</span>
<span class="line-modified">154             System.out.println(ProcessTools.getCommandLine(builder));</span>
<span class="line-modified">155             ProcessThread jvm = new ProcessThread(&quot;JMX-Tester-&quot; + address, JMXInterfaceBindingTest::isJMXAgentResponseAvailable, builder);</span>
<span class="line-removed">156             return jvm;</span>
<span class="line-removed">157         } catch (Exception e) {</span>
158             throw new RuntimeException(&quot;Test failed&quot;, e);
159         }
160 
<span class="line-modified">161     }</span>
<span class="line-modified">162 </span>
<span class="line-modified">163     private static boolean isJMXAgentResponseAvailable(String line) {</span>
<span class="line-modified">164         if (line.equals(READY_MSG)) {</span>
<span class="line-removed">165             System.out.println(&quot;DEBUG: Found expected READY_MSG.&quot;);</span>
<span class="line-removed">166             return true;</span>
<span class="line-removed">167         } else if (line.startsWith(&quot;Error:&quot;)) {</span>
<span class="line-removed">168             // Allow for a JVM process that exits with</span>
<span class="line-removed">169             // &quot;Error: JMX connector server communication error: ...&quot;</span>
<span class="line-removed">170             // to continue as well since we handle that case elsewhere.</span>
<span class="line-removed">171             // This has the effect that the test does not timeout and</span>
<span class="line-removed">172             // fails with an exception in the test.</span>
<span class="line-removed">173             System.err.println(&quot;PROBLEM: JMX agent of target JVM did not start as it should.&quot;);</span>
<span class="line-removed">174             return true;</span>
<span class="line-removed">175         } else {</span>
<span class="line-removed">176             return false;</span>
177         }
178     }
179 
180     private static int getRandomPortInRange(int lower, int upper) {
181         if (upper &lt;= lower) {
182             throw new IllegalArgumentException(&quot;upper &lt;= lower&quot;);
183         }
184         int range = upper - lower;
185         int randPort = lower + (int)(Math.random() * range);
186         return randPort;
187     }
188 
189     public static void main(String[] args) {
190         List&lt;InetAddress&gt; addrs = getNonLoopbackAddressesForLocalHost();
191         if (addrs.isEmpty()) {
192             System.out.println(&quot;Ignoring test since no non-loopback IPs are available to bind to &quot; +
193                                &quot;in addition to the loopback interface.&quot;);
194             return;
195         }
196         JMXInterfaceBindingTest test = new JMXInterfaceBindingTest();
</pre>
<hr />
<pre>
198         // possible to bind to multiple addresses on the same host. This
199         // wasn&#39;t possible prior JDK-6425769. It used to bind to *all* local
200         // interfaces. We add loopback here, since that eases test setup.
201         addrs.add(InetAddress.getLoopbackAddress());
202         test.run(addrs);
203         System.out.println(&quot;All tests PASSED.&quot;);
204     }
205 
206     private static List&lt;InetAddress&gt; getNonLoopbackAddressesForLocalHost() {
207         List&lt;InetAddress&gt; addrs = new ArrayList&lt;&gt;();
208         try {
209             InetAddress localHost = InetAddress.getLocalHost();
210             if (!localHost.isLoopbackAddress()) {
211                 addrs.add(localHost);
212             }
213             return addrs;
214         } catch (UnknownHostException e) {
215             throw new RuntimeException(&quot;Test failed&quot;, e);
216         }
217     }




























































































































218 }
</pre>
</td>
<td>
<hr />
<pre>
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 import java.io.File;
<span class="line-added"> 25 import java.io.PrintWriter;</span>
 26 import java.net.InetAddress;

 27 import java.net.UnknownHostException;

 28 import java.util.ArrayList;
 29 import java.util.List;
<span class="line-modified"> 30 import java.util.concurrent.CountDownLatch;</span>
 31 
<span class="line-modified"> 32 import jdk.test.lib.process.OutputAnalyzer;</span>
 33 import jdk.test.lib.process.ProcessTools;
 34 
 35 /**
 36  * @test
 37  * @bug     6425769
 38  * @summary Test JMX agent host address binding. Same ports but different
<span class="line-modified"> 39  *          interfaces to bind to (selecting plain or SSL sockets at random)</span>

 40  *
 41  * @library /test/lib
 42  * @modules java.management.rmi
 43  *
 44  * @build JMXAgentInterfaceBinding
 45  * @run main/timeout=60 JMXInterfaceBindingTest
 46  */
 47 public class JMXInterfaceBindingTest {
 48 
 49     public static final int COMMUNICATION_ERROR_EXIT_VAL = 1;
 50     public static final int STOP_PROCESS_EXIT_VAL = 10;
 51     public static final int JMX_PORT_RANGE_LOWER = 9100;
 52     public static final int JMX_PORT_RANGE_UPPER = 9200;


 53     public static final int JMX_PORT_RANGE_LOWER_SSL = 9201; // 9200 might be RMI Port
 54     public static final int JMX_PORT_RANGE_UPPER_SSL = 9300;
<span class="line-modified"> 55     private static final int MAX_RETRY_ATTEMTS = 10;</span>



 56     public static final String READY_MSG = &quot;MainThread: Ready for connections&quot;;
 57     public static final String TEST_CLASS = JMXAgentInterfaceBinding.class.getSimpleName();
 58     public static final String KEYSTORE_LOC = System.getProperty(&quot;test.src&quot;, &quot;.&quot;) +
 59                                               File.separator +
 60                                               &quot;ssl&quot; +
 61                                               File.separator +
 62                                               &quot;keystore&quot;;
 63     public static final String TRUSTSTORE_LOC = System.getProperty(&quot;test.src&quot;, &quot;.&quot;) +
 64                                                 File.separator +
 65                                                 &quot;ssl&quot; +
 66                                                 File.separator +
 67                                                 &quot;truststore&quot;;
 68     public static final String TEST_CLASSPATH = System.getProperty(&quot;test.classes&quot;, &quot;.&quot;);
 69 
 70     public void run(List&lt;InetAddress&gt; addrs) {
 71         System.out.println(&quot;DEBUG: Running tests with plain sockets.&quot;);
 72         runTests(addrs, false);
 73         System.out.println(&quot;DEBUG: Running tests with SSL sockets.&quot;);
 74         runTests(addrs, true);
 75     }
 76 
 77     private void runTests(List&lt;InetAddress&gt; addrs, boolean useSSL) {
<span class="line-modified"> 78         List&lt;TestProcessThread&gt; testThreads = new ArrayList&lt;&gt;(addrs.size());</span>
<span class="line-modified"> 79         CountDownLatch latch = new CountDownLatch(addrs.size());</span>
 80         for (InetAddress addr : addrs) {
 81             String address = JMXAgentInterfaceBinding.wrapAddress(addr.getHostAddress());
<span class="line-modified"> 82             TestProcessThread t = new TestProcessThread(address, useSSL, latch);</span>
<span class="line-modified"> 83             testThreads.add(t);</span>
<span class="line-modified"> 84             t.start();</span>






















































 85         }





 86         try {
<span class="line-modified"> 87             latch.await();</span>
<span class="line-modified"> 88         } catch (InterruptedException e) {</span>
<span class="line-modified"> 89             System.err.println(&quot;Failed to wait for the test threads to complete&quot;);</span>


 90             throw new RuntimeException(&quot;Test failed&quot;, e);
 91         }
 92 
<span class="line-modified"> 93         long failedProcesses = testThreads.stream().filter(TestProcessThread::isTestFailed).count();</span>
<span class="line-modified"> 94         if (failedProcesses &gt; 0) {</span>
<span class="line-modified"> 95             throw new RuntimeException(&quot;Test FAILED. &quot; + failedProcesses + &quot; out of &quot; + addrs.size() +</span>
<span class="line-modified"> 96                     &quot; process(es) failed to start the JMX agent.&quot;);</span>












 97         }
 98     }
 99 
100     private static int getRandomPortInRange(int lower, int upper) {
101         if (upper &lt;= lower) {
102             throw new IllegalArgumentException(&quot;upper &lt;= lower&quot;);
103         }
104         int range = upper - lower;
105         int randPort = lower + (int)(Math.random() * range);
106         return randPort;
107     }
108 
109     public static void main(String[] args) {
110         List&lt;InetAddress&gt; addrs = getNonLoopbackAddressesForLocalHost();
111         if (addrs.isEmpty()) {
112             System.out.println(&quot;Ignoring test since no non-loopback IPs are available to bind to &quot; +
113                                &quot;in addition to the loopback interface.&quot;);
114             return;
115         }
116         JMXInterfaceBindingTest test = new JMXInterfaceBindingTest();
</pre>
<hr />
<pre>
118         // possible to bind to multiple addresses on the same host. This
119         // wasn&#39;t possible prior JDK-6425769. It used to bind to *all* local
120         // interfaces. We add loopback here, since that eases test setup.
121         addrs.add(InetAddress.getLoopbackAddress());
122         test.run(addrs);
123         System.out.println(&quot;All tests PASSED.&quot;);
124     }
125 
126     private static List&lt;InetAddress&gt; getNonLoopbackAddressesForLocalHost() {
127         List&lt;InetAddress&gt; addrs = new ArrayList&lt;&gt;();
128         try {
129             InetAddress localHost = InetAddress.getLocalHost();
130             if (!localHost.isLoopbackAddress()) {
131                 addrs.add(localHost);
132             }
133             return addrs;
134         } catch (UnknownHostException e) {
135             throw new RuntimeException(&quot;Test failed&quot;, e);
136         }
137     }
<span class="line-added">138 </span>
<span class="line-added">139     private static class TestProcessThread extends Thread {</span>
<span class="line-added">140         private final String name;</span>
<span class="line-added">141         private final String address;</span>
<span class="line-added">142         private final boolean useSSL;</span>
<span class="line-added">143         private final CountDownLatch latch;</span>
<span class="line-added">144         private volatile boolean testFailed = false;</span>
<span class="line-added">145         private OutputAnalyzer output;</span>
<span class="line-added">146 </span>
<span class="line-added">147         public TestProcessThread(String address, boolean useSSL, CountDownLatch latch) {</span>
<span class="line-added">148             this.address = address;</span>
<span class="line-added">149             this.useSSL = useSSL;</span>
<span class="line-added">150             this.name = &quot;JMX-Tester-&quot; + address;</span>
<span class="line-added">151             this.latch = latch;</span>
<span class="line-added">152         }</span>
<span class="line-added">153 </span>
<span class="line-added">154         @Override</span>
<span class="line-added">155         public void run() {</span>
<span class="line-added">156             int attempts = 0;</span>
<span class="line-added">157             boolean needRetry = false;</span>
<span class="line-added">158             do {</span>
<span class="line-added">159                 if (needRetry) {</span>
<span class="line-added">160                     System.err.println(&quot;Retrying the test for &quot; + name);</span>
<span class="line-added">161                 }</span>
<span class="line-added">162                 needRetry = runTest();</span>
<span class="line-added">163             } while (needRetry &amp;&amp; (attempts++ &lt; MAX_RETRY_ATTEMTS));</span>
<span class="line-added">164 </span>
<span class="line-added">165             if (testFailed) {</span>
<span class="line-added">166                 int exitValue = output.getExitValue();</span>
<span class="line-added">167                 if (needRetry) {</span>
<span class="line-added">168                     System.err.println(&quot;Test FAILURE on &quot; + name + &quot; reason: run out of retries to to pick free ports&quot;);</span>
<span class="line-added">169                 } else if (exitValue == COMMUNICATION_ERROR_EXIT_VAL) {</span>
<span class="line-added">170                     // Failure case since the java processes should still be</span>
<span class="line-added">171                     // running.</span>
<span class="line-added">172                     System.err.println(&quot;Test FAILURE on &quot; + name);</span>
<span class="line-added">173                 } else if (exitValue == STOP_PROCESS_EXIT_VAL) {</span>
<span class="line-added">174                     System.out.println(&quot;Test FAILURE on &quot; + name + &quot; reason: The expected line \&quot;&quot; + READY_MSG</span>
<span class="line-added">175                             + &quot;\&quot; is not present in the process output&quot;);</span>
<span class="line-added">176                 } else {</span>
<span class="line-added">177                     System.err.println(&quot;Test FAILURE on &quot; + name + &quot; reason: Unexpected exit code =&gt; &quot; + exitValue);</span>
<span class="line-added">178                 }</span>
<span class="line-added">179                 output.reportDiagnosticSummary();</span>
<span class="line-added">180             }</span>
<span class="line-added">181             latch.countDown();</span>
<span class="line-added">182         }</span>
<span class="line-added">183 </span>
<span class="line-added">184         public boolean isTestFailed() {</span>
<span class="line-added">185             return testFailed;</span>
<span class="line-added">186         }</span>
<span class="line-added">187 </span>
<span class="line-added">188         private int getJMXPort() {</span>
<span class="line-added">189             return useSSL ?</span>
<span class="line-added">190                     getRandomPortInRange(JMX_PORT_RANGE_LOWER_SSL, JMX_PORT_RANGE_UPPER_SSL) :</span>
<span class="line-added">191                     getRandomPortInRange(JMX_PORT_RANGE_LOWER, JMX_PORT_RANGE_UPPER);</span>
<span class="line-added">192         }</span>
<span class="line-added">193 </span>
<span class="line-added">194         private Process createTestProcess() {</span>
<span class="line-added">195             int jmxPort = getJMXPort();</span>
<span class="line-added">196             int rmiPort = jmxPort + 1;</span>
<span class="line-added">197             String msg = String.format(&quot;DEBUG: Launching java tester for triplet (HOSTNAME,JMX_PORT,RMI_PORT)&quot; +</span>
<span class="line-added">198                             &quot; == (%s,%d,%d)&quot;, address, jmxPort, rmiPort);</span>
<span class="line-added">199             System.out.println(msg);</span>
<span class="line-added">200             List&lt;String&gt; args = new ArrayList&lt;&gt;();</span>
<span class="line-added">201             args.add(&quot;-classpath&quot;);</span>
<span class="line-added">202             args.add(TEST_CLASSPATH);</span>
<span class="line-added">203             args.add(&quot;-Dcom.sun.management.jmxremote.host=&quot; + address);</span>
<span class="line-added">204             args.add(&quot;-Dcom.sun.management.jmxremote.port=&quot; + jmxPort);</span>
<span class="line-added">205             args.add(&quot;-Dcom.sun.management.jmxremote.rmi.port=&quot; + rmiPort);</span>
<span class="line-added">206             args.add(&quot;-Dcom.sun.management.jmxremote.authenticate=false&quot;);</span>
<span class="line-added">207             args.add(&quot;-Dcom.sun.management.jmxremote.ssl=&quot; + Boolean.toString(useSSL));</span>
<span class="line-added">208             // This is needed for testing on loopback</span>
<span class="line-added">209             args.add(&quot;-Djava.rmi.server.hostname=&quot; + address);</span>
<span class="line-added">210             if (useSSL) {</span>
<span class="line-added">211                 args.add(&quot;-Dcom.sun.management.jmxremote.registry.ssl=true&quot;);</span>
<span class="line-added">212                 args.add(&quot;-Djavax.net.ssl.keyStore=&quot; + KEYSTORE_LOC);</span>
<span class="line-added">213                 args.add(&quot;-Djavax.net.ssl.trustStore=&quot; + TRUSTSTORE_LOC);</span>
<span class="line-added">214                 args.add(&quot;-Djavax.net.ssl.keyStorePassword=password&quot;);</span>
<span class="line-added">215                 args.add(&quot;-Djavax.net.ssl.trustStorePassword=trustword&quot;);</span>
<span class="line-added">216             }</span>
<span class="line-added">217             args.add(TEST_CLASS);</span>
<span class="line-added">218             args.add(address);</span>
<span class="line-added">219             args.add(Integer.toString(jmxPort));</span>
<span class="line-added">220             args.add(Integer.toString(rmiPort));</span>
<span class="line-added">221             args.add(Boolean.toString(useSSL));</span>
<span class="line-added">222 </span>
<span class="line-added">223             try {</span>
<span class="line-added">224                 ProcessBuilder builder = ProcessTools.createJavaProcessBuilder(args.toArray(new String[]{}));</span>
<span class="line-added">225                 System.out.println(ProcessTools.getCommandLine(builder));</span>
<span class="line-added">226                 Process process = builder.start();</span>
<span class="line-added">227                 output = new OutputAnalyzer(process);</span>
<span class="line-added">228                 return process;</span>
<span class="line-added">229             } catch (Exception e) {</span>
<span class="line-added">230                 throw new RuntimeException(&quot;Test failed&quot;, e);</span>
<span class="line-added">231             }</span>
<span class="line-added">232         }</span>
<span class="line-added">233 </span>
<span class="line-added">234         // Returns true if the test failed due to &quot;Port already in use&quot; error.</span>
<span class="line-added">235         private boolean runTest() {</span>
<span class="line-added">236             testFailed = true;</span>
<span class="line-added">237             Process process = createTestProcess();</span>
<span class="line-added">238             try {</span>
<span class="line-added">239                 sendMessageToProcess(process, &quot;Exit: &quot; + STOP_PROCESS_EXIT_VAL);</span>
<span class="line-added">240                 process.waitFor();</span>
<span class="line-added">241             } catch (Throwable e) {</span>
<span class="line-added">242                 System.err.println(&quot;Failed to stop process: &quot; + name);</span>
<span class="line-added">243                 throw new RuntimeException(&quot;Test failed&quot;, e);</span>
<span class="line-added">244             }</span>
<span class="line-added">245             if (output.getExitValue() == STOP_PROCESS_EXIT_VAL &amp;&amp; output.getStdout().contains(READY_MSG)) {</span>
<span class="line-added">246                 testFailed = false;</span>
<span class="line-added">247             } else if (output.getStderr().contains(&quot;Port already in use&quot;)) {</span>
<span class="line-added">248                 System.out.println(&quot;The test attempt for the test &quot; + name +&quot; failed due to the bind error&quot;);</span>
<span class="line-added">249                 // Need to retry</span>
<span class="line-added">250                 return true;</span>
<span class="line-added">251             }</span>
<span class="line-added">252             return false;</span>
<span class="line-added">253         }</span>
<span class="line-added">254 </span>
<span class="line-added">255         private static void sendMessageToProcess(Process process, String message) {</span>
<span class="line-added">256             try (PrintWriter pw = new PrintWriter(process.getOutputStream())) {</span>
<span class="line-added">257                 pw.println(message);</span>
<span class="line-added">258                 pw.flush();</span>
<span class="line-added">259             }</span>
<span class="line-added">260         }</span>
<span class="line-added">261     }</span>
262 }
</pre>
</td>
</tr>
</table>
<center><a href="GeneratePropertyPassword.sh.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="LocalManagementTest.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
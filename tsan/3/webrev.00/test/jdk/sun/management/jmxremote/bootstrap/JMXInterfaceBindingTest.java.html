<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New test/jdk/sun/management/jmxremote/bootstrap/JMXInterfaceBindingTest.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2015, Red Hat Inc
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 import java.io.File;
 25 import java.io.PrintWriter;
 26 import java.net.InetAddress;
 27 import java.net.UnknownHostException;
 28 import java.util.ArrayList;
 29 import java.util.List;
 30 import java.util.concurrent.CountDownLatch;
 31 
 32 import jdk.test.lib.process.OutputAnalyzer;
 33 import jdk.test.lib.process.ProcessTools;
 34 
 35 /**
 36  * @test
 37  * @bug     6425769
 38  * @summary Test JMX agent host address binding. Same ports but different
 39  *          interfaces to bind to (selecting plain or SSL sockets at random)
 40  *
 41  * @library /test/lib
 42  * @modules java.management.rmi
 43  *
 44  * @build JMXAgentInterfaceBinding
 45  * @run main/timeout=60 JMXInterfaceBindingTest
 46  */
 47 public class JMXInterfaceBindingTest {
 48 
 49     public static final int COMMUNICATION_ERROR_EXIT_VAL = 1;
 50     public static final int STOP_PROCESS_EXIT_VAL = 10;
 51     public static final int JMX_PORT_RANGE_LOWER = 9100;
 52     public static final int JMX_PORT_RANGE_UPPER = 9200;
 53     public static final int JMX_PORT_RANGE_LOWER_SSL = 9201; // 9200 might be RMI Port
 54     public static final int JMX_PORT_RANGE_UPPER_SSL = 9300;
 55     private static final int MAX_RETRY_ATTEMTS = 10;
 56     public static final String READY_MSG = &quot;MainThread: Ready for connections&quot;;
 57     public static final String TEST_CLASS = JMXAgentInterfaceBinding.class.getSimpleName();
 58     public static final String KEYSTORE_LOC = System.getProperty(&quot;test.src&quot;, &quot;.&quot;) +
 59                                               File.separator +
 60                                               &quot;ssl&quot; +
 61                                               File.separator +
 62                                               &quot;keystore&quot;;
 63     public static final String TRUSTSTORE_LOC = System.getProperty(&quot;test.src&quot;, &quot;.&quot;) +
 64                                                 File.separator +
 65                                                 &quot;ssl&quot; +
 66                                                 File.separator +
 67                                                 &quot;truststore&quot;;
 68     public static final String TEST_CLASSPATH = System.getProperty(&quot;test.classes&quot;, &quot;.&quot;);
 69 
 70     public void run(List&lt;InetAddress&gt; addrs) {
 71         System.out.println(&quot;DEBUG: Running tests with plain sockets.&quot;);
 72         runTests(addrs, false);
 73         System.out.println(&quot;DEBUG: Running tests with SSL sockets.&quot;);
 74         runTests(addrs, true);
 75     }
 76 
 77     private void runTests(List&lt;InetAddress&gt; addrs, boolean useSSL) {
 78         List&lt;TestProcessThread&gt; testThreads = new ArrayList&lt;&gt;(addrs.size());
 79         CountDownLatch latch = new CountDownLatch(addrs.size());
 80         for (InetAddress addr : addrs) {
 81             String address = JMXAgentInterfaceBinding.wrapAddress(addr.getHostAddress());
 82             TestProcessThread t = new TestProcessThread(address, useSSL, latch);
 83             testThreads.add(t);
 84             t.start();
 85         }
 86         try {
 87             latch.await();
 88         } catch (InterruptedException e) {
 89             System.err.println(&quot;Failed to wait for the test threads to complete&quot;);
 90             throw new RuntimeException(&quot;Test failed&quot;, e);
 91         }
 92 
 93         long failedProcesses = testThreads.stream().filter(TestProcessThread::isTestFailed).count();
 94         if (failedProcesses &gt; 0) {
 95             throw new RuntimeException(&quot;Test FAILED. &quot; + failedProcesses + &quot; out of &quot; + addrs.size() +
 96                     &quot; process(es) failed to start the JMX agent.&quot;);
 97         }
 98     }
 99 
100     private static int getRandomPortInRange(int lower, int upper) {
101         if (upper &lt;= lower) {
102             throw new IllegalArgumentException(&quot;upper &lt;= lower&quot;);
103         }
104         int range = upper - lower;
105         int randPort = lower + (int)(Math.random() * range);
106         return randPort;
107     }
108 
109     public static void main(String[] args) {
110         List&lt;InetAddress&gt; addrs = getNonLoopbackAddressesForLocalHost();
111         if (addrs.isEmpty()) {
112             System.out.println(&quot;Ignoring test since no non-loopback IPs are available to bind to &quot; +
113                                &quot;in addition to the loopback interface.&quot;);
114             return;
115         }
116         JMXInterfaceBindingTest test = new JMXInterfaceBindingTest();
117         // Add loopback interface too as we&#39;d like to verify whether it&#39;s
118         // possible to bind to multiple addresses on the same host. This
119         // wasn&#39;t possible prior JDK-6425769. It used to bind to *all* local
120         // interfaces. We add loopback here, since that eases test setup.
121         addrs.add(InetAddress.getLoopbackAddress());
122         test.run(addrs);
123         System.out.println(&quot;All tests PASSED.&quot;);
124     }
125 
126     private static List&lt;InetAddress&gt; getNonLoopbackAddressesForLocalHost() {
127         List&lt;InetAddress&gt; addrs = new ArrayList&lt;&gt;();
128         try {
129             InetAddress localHost = InetAddress.getLocalHost();
130             if (!localHost.isLoopbackAddress()) {
131                 addrs.add(localHost);
132             }
133             return addrs;
134         } catch (UnknownHostException e) {
135             throw new RuntimeException(&quot;Test failed&quot;, e);
136         }
137     }
138 
139     private static class TestProcessThread extends Thread {
140         private final String name;
141         private final String address;
142         private final boolean useSSL;
143         private final CountDownLatch latch;
144         private volatile boolean testFailed = false;
145         private OutputAnalyzer output;
146 
147         public TestProcessThread(String address, boolean useSSL, CountDownLatch latch) {
148             this.address = address;
149             this.useSSL = useSSL;
150             this.name = &quot;JMX-Tester-&quot; + address;
151             this.latch = latch;
152         }
153 
154         @Override
155         public void run() {
156             int attempts = 0;
157             boolean needRetry = false;
158             do {
159                 if (needRetry) {
160                     System.err.println(&quot;Retrying the test for &quot; + name);
161                 }
162                 needRetry = runTest();
163             } while (needRetry &amp;&amp; (attempts++ &lt; MAX_RETRY_ATTEMTS));
164 
165             if (testFailed) {
166                 int exitValue = output.getExitValue();
167                 if (needRetry) {
168                     System.err.println(&quot;Test FAILURE on &quot; + name + &quot; reason: run out of retries to to pick free ports&quot;);
169                 } else if (exitValue == COMMUNICATION_ERROR_EXIT_VAL) {
170                     // Failure case since the java processes should still be
171                     // running.
172                     System.err.println(&quot;Test FAILURE on &quot; + name);
173                 } else if (exitValue == STOP_PROCESS_EXIT_VAL) {
174                     System.out.println(&quot;Test FAILURE on &quot; + name + &quot; reason: The expected line \&quot;&quot; + READY_MSG
175                             + &quot;\&quot; is not present in the process output&quot;);
176                 } else {
177                     System.err.println(&quot;Test FAILURE on &quot; + name + &quot; reason: Unexpected exit code =&gt; &quot; + exitValue);
178                 }
179                 output.reportDiagnosticSummary();
180             }
181             latch.countDown();
182         }
183 
184         public boolean isTestFailed() {
185             return testFailed;
186         }
187 
188         private int getJMXPort() {
189             return useSSL ?
190                     getRandomPortInRange(JMX_PORT_RANGE_LOWER_SSL, JMX_PORT_RANGE_UPPER_SSL) :
191                     getRandomPortInRange(JMX_PORT_RANGE_LOWER, JMX_PORT_RANGE_UPPER);
192         }
193 
194         private Process createTestProcess() {
195             int jmxPort = getJMXPort();
196             int rmiPort = jmxPort + 1;
197             String msg = String.format(&quot;DEBUG: Launching java tester for triplet (HOSTNAME,JMX_PORT,RMI_PORT)&quot; +
198                             &quot; == (%s,%d,%d)&quot;, address, jmxPort, rmiPort);
199             System.out.println(msg);
200             List&lt;String&gt; args = new ArrayList&lt;&gt;();
201             args.add(&quot;-classpath&quot;);
202             args.add(TEST_CLASSPATH);
203             args.add(&quot;-Dcom.sun.management.jmxremote.host=&quot; + address);
204             args.add(&quot;-Dcom.sun.management.jmxremote.port=&quot; + jmxPort);
205             args.add(&quot;-Dcom.sun.management.jmxremote.rmi.port=&quot; + rmiPort);
206             args.add(&quot;-Dcom.sun.management.jmxremote.authenticate=false&quot;);
207             args.add(&quot;-Dcom.sun.management.jmxremote.ssl=&quot; + Boolean.toString(useSSL));
208             // This is needed for testing on loopback
209             args.add(&quot;-Djava.rmi.server.hostname=&quot; + address);
210             if (useSSL) {
211                 args.add(&quot;-Dcom.sun.management.jmxremote.registry.ssl=true&quot;);
212                 args.add(&quot;-Djavax.net.ssl.keyStore=&quot; + KEYSTORE_LOC);
213                 args.add(&quot;-Djavax.net.ssl.trustStore=&quot; + TRUSTSTORE_LOC);
214                 args.add(&quot;-Djavax.net.ssl.keyStorePassword=password&quot;);
215                 args.add(&quot;-Djavax.net.ssl.trustStorePassword=trustword&quot;);
216             }
217             args.add(TEST_CLASS);
218             args.add(address);
219             args.add(Integer.toString(jmxPort));
220             args.add(Integer.toString(rmiPort));
221             args.add(Boolean.toString(useSSL));
222 
223             try {
224                 ProcessBuilder builder = ProcessTools.createJavaProcessBuilder(args.toArray(new String[]{}));
225                 System.out.println(ProcessTools.getCommandLine(builder));
226                 Process process = builder.start();
227                 output = new OutputAnalyzer(process);
228                 return process;
229             } catch (Exception e) {
230                 throw new RuntimeException(&quot;Test failed&quot;, e);
231             }
232         }
233 
234         // Returns true if the test failed due to &quot;Port already in use&quot; error.
235         private boolean runTest() {
236             testFailed = true;
237             Process process = createTestProcess();
238             try {
239                 sendMessageToProcess(process, &quot;Exit: &quot; + STOP_PROCESS_EXIT_VAL);
240                 process.waitFor();
241             } catch (Throwable e) {
242                 System.err.println(&quot;Failed to stop process: &quot; + name);
243                 throw new RuntimeException(&quot;Test failed&quot;, e);
244             }
245             if (output.getExitValue() == STOP_PROCESS_EXIT_VAL &amp;&amp; output.getStdout().contains(READY_MSG)) {
246                 testFailed = false;
247             } else if (output.getStderr().contains(&quot;Port already in use&quot;)) {
248                 System.out.println(&quot;The test attempt for the test &quot; + name +&quot; failed due to the bind error&quot;);
249                 // Need to retry
250                 return true;
251             }
252             return false;
253         }
254 
255         private static void sendMessageToProcess(Process process, String message) {
256             try (PrintWriter pw = new PrintWriter(process.getOutputStream())) {
257                 pw.println(message);
258                 pw.flush();
259             }
260         }
261     }
262 }
    </pre>
  </body>
</html>
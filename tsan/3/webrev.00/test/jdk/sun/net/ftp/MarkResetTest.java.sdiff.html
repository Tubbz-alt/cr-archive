<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff test/jdk/sun/net/ftp/MarkResetTest.java</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
<body>
<center><a href="FtpURLConnectionLeak.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="TestFtpClientNameListWithNull.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>test/jdk/sun/net/ftp/MarkResetTest.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2002, 2017, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 /*
 25  * @test
 26  * @bug 4673103

 27  * @run main/othervm/timeout=140 MarkResetTest
 28  * @summary URLConnection.getContent() hangs over FTP for DOC, PPT, XLS files
 29  */
 30 
 31 import java.io.BufferedReader;
 32 import java.io.File;
 33 import java.io.FileInputStream;
 34 import java.io.IOException;
 35 import java.io.InputStream;
 36 import java.io.InputStreamReader;
 37 import java.io.OutputStream;
 38 import java.io.PrintWriter;

 39 import java.net.InetAddress;


 40 import java.net.ServerSocket;
 41 import java.net.Socket;
 42 import java.net.URL;
 43 import java.net.URLConnection;
 44 import java.nio.file.Files;
 45 import java.nio.file.Paths;
 46 


 47 public class MarkResetTest {
 48     private static final String FILE_NAME = &quot;EncDec.doc&quot;;
 49 
 50     /**
 51      * A class that simulates, on a separate, an FTP server.
 52      */
 53     private class FtpServer extends Thread {
<span class="line-modified"> 54         private ServerSocket    server;</span>
<span class="line-modified"> 55         private int port;</span>
<span class="line-removed"> 56         private boolean done = false;</span>
 57         private boolean pasvEnabled = true;
 58         private boolean portEnabled = true;
 59         private boolean extendedEnabled = true;
 60 
 61         /**
 62          * This Inner class will handle ONE client at a time.
 63          * That&#39;s where 99% of the protocol handling is done.
 64          */
 65 
 66         private class FtpServerHandler extends Thread {
 67             BufferedReader in;
 68             PrintWriter out;
 69             Socket client;
 70             private final int ERROR = 0;
 71             private final int USER = 1;
 72             private final int PASS = 2;
 73             private final int CWD =  3;
 74             private final int TYPE = 4;
 75             private final int RETR = 5;
 76             private final int PASV = 6;
</pre>
<hr />
<pre>
156                         Socket s = pasv.accept();
157                         return s.getInputStream();
158                     }
159                     if (data_addr != null) {
160                         Socket s = new Socket(data_addr, data_port);
161                         data_addr = null;
162                         data_port = 0;
163                         return s.getInputStream();
164                     }
165                 } catch (Exception e) {
166                     e.printStackTrace();
167                 }
168                 return null;
169             }
170 
171             /**
172              * Handles the protocol exchange with the client.
173              */
174 
175             public void run() {
<span class="line-modified">176                 boolean done = false;</span>
177                 String str;
178                 int res;
179                 boolean logged = false;
180                 boolean waitpass = false;
181 
182                 try {
183                     in = new BufferedReader(new InputStreamReader(
184                                                 client.getInputStream()));
185                     out = new PrintWriter(client.getOutputStream(), true);
186                     out.println(&quot;220 tatooine FTP server (SunOS 5.8) ready.&quot;);
187                 } catch (Exception ex) {
188                     return;
189                 }
190                 while (!done) {
191                     try {
192                         str = in.readLine();
193                         res = parseCmd(str);
194                         if ((res &gt; PASS &amp;&amp; res != QUIT) &amp;&amp; !logged) {
195                             out.println(&quot;530 Not logged in.&quot;);
196                             continue;
</pre>
<hr />
<pre>
227                                 pasv.close();
228                             done = true;
229                             break;
230                         case TYPE:
231                             out.println(&quot;200 Type set to &quot; + arg + &quot;.&quot;);
232                             break;
233                         case CWD:
234                             out.println(&quot;250 CWD command successful.&quot;);
235                             break;
236                         case EPSV:
237                             if (!extendedEnabled || !pasvEnabled) {
238                                 out.println(&quot;500 EPSV is disabled, &quot; +
239                                                 &quot;use PORT instead.&quot;);
240                                 continue;
241                             }
242                             if (&quot;all&quot;.equalsIgnoreCase(arg)) {
243                                 out.println(&quot;200 EPSV ALL command successful.&quot;);
244                                 continue;
245                             }
246                             try {
<span class="line-modified">247                                 if (pasv == null)</span>
<span class="line-modified">248                                     pasv = new ServerSocket(0);</span>


249                                 int port = pasv.getLocalPort();
250                                 out.println(&quot;229 Entering Extended&quot; +
251                                         &quot; Passive Mode (|||&quot; + port + &quot;|)&quot;);
252                             } catch (IOException ssex) {
253                                 out.println(&quot;425 Can&#39;t build data connection:&quot; +
254                                                 &quot; Connection refused.&quot;);
255                             }
256                             break;
257 
258                         case PASV:
259                             if (!pasvEnabled) {
260                                 out.println(&quot;500 PASV is disabled, &quot; +
261                                                 &quot;use PORT instead.&quot;);
262                                 continue;
263                             }
264                             try {
<span class="line-modified">265                                 if (pasv == null)</span>
<span class="line-modified">266                                     pasv = new ServerSocket(0);</span>


267                                 int port = pasv.getLocalPort();
268 
269                                 // Parenthesis are optional, so let&#39;s be
270                                 // nasty and don&#39;t put them
271                                 out.println(&quot;227 Entering Passive Mode&quot; +
272                                                 &quot; 127,0,0,1,&quot; +
273                                             (port &gt;&gt; 8) + &quot;,&quot; + (port &amp; 0xff));
274                             } catch (IOException ssex) {
275                                 out.println(&quot;425 Can&#39;t build data connection:&quot; +
276                                                  &quot;Connection refused.&quot;);
277                             }
278                             break;
279                         case PORT:
280                             if (!portEnabled) {
281                                 out.println(&quot;500 PORT is disabled, &quot; +
282                                                 &quot;use PASV instead&quot;);
283                                 continue;
284                             }
285                             StringBuffer host;
286                             int i = 0, j = 4;
</pre>
<hr />
<pre>
347                                 } else {
348                                     out.println(&quot;425 Can&#39;t build data&quot; +
349                                         &quot; connection: Connection refused.&quot;);
350                                 }
351                             }
352                             break;
353                         }
354                     } catch (IOException ioe) {
355                         ioe.printStackTrace();
356                         try {
357                             out.close();
358                         } catch (Exception ex2) {
359                         }
360                         done = true;
361                     }
362                 }
363             }
364         }
365 
366         public FtpServer(int port) {
<span class="line-modified">367             this.port = port;</span>













368         }
369 
370         public FtpServer() {
<span class="line-modified">371             this(21);</span>
372         }
373 
374         public int getPort() {
<span class="line-modified">375             if (server != null)</span>
<span class="line-removed">376                 return server.getLocalPort();</span>
<span class="line-removed">377             return 0;</span>
378         }
379 
380         /**
381          * A way to tell the server that it can stop.
382          */
383         synchronized public void terminate() {
384             done = true;
385         }
386 
387 
388         /*
389          * All we got to do here is create a ServerSocket and wait for a
390          * connection. When a connection happens, we just have to create
391          * a thread that will handle it.
392          */
393         public void run() {
394             try {
<span class="line-modified">395                 server = new ServerSocket(port);</span>

396                 Socket client;
397                 client = server.accept();
398                 (new FtpServerHandler(client)).start();
399                 server.close();
400             } catch (Exception e) {
401             }
402         }
403     }
404 
405     public static void main(String[] args) throws Exception {
406         Files.copy(Paths.get(System.getProperty(&quot;test.src&quot;), FILE_NAME),
407                 Paths.get(&quot;.&quot;, FILE_NAME));
408         new MarkResetTest();
409     }
410 
411     public MarkResetTest() {
412         FtpServer server = null;
413         try {
414             server = new FtpServer(0);
415             server.start();
416             int port = 0;
417             while (port == 0) {
418                 Thread.sleep(500);
419                 port = server.getPort();
420             }
421 






422 
<span class="line-modified">423             URL url = new URL(&quot;ftp://localhost:&quot; + port + &quot;/&quot; + FILE_NAME);</span>
<span class="line-removed">424 </span>
<span class="line-removed">425             URLConnection con = url.openConnection();</span>
426             System.out.println(&quot;getContent: &quot; + con.getContent());
427             System.out.println(&quot;getContent-length: &quot; + con.getContentLength());
428 
429             InputStream is = con.getInputStream();
430 
431             /**
432              * guessContentTypeFromStream method calls mark and reset methods
433              * on the given stream. Make sure that calling
434              * guessContentTypeFromStream repeatedly does not affect
435              * reading from the stream afterwards
436              */
437             System.out.println(&quot;Call GuessContentTypeFromStream()&quot; +
438                                 &quot; several times..&quot;);
439             for (int i = 0; i &lt; 5; i++) {
440                 System.out.println((i + 1) + &quot; mime-type: &quot; +
441                         con.guessContentTypeFromStream(is));
442             }
443 
444             int len = 0;
445             int c;
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2002, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 /*
 25  * @test
 26  * @bug 4673103
<span class="line-added"> 27  * @library /test/lib</span>
 28  * @run main/othervm/timeout=140 MarkResetTest
 29  * @summary URLConnection.getContent() hangs over FTP for DOC, PPT, XLS files
 30  */
 31 
 32 import java.io.BufferedReader;
 33 import java.io.File;
 34 import java.io.FileInputStream;
 35 import java.io.IOException;
 36 import java.io.InputStream;
 37 import java.io.InputStreamReader;
 38 import java.io.OutputStream;
 39 import java.io.PrintWriter;
<span class="line-added"> 40 import java.io.UncheckedIOException;</span>
 41 import java.net.InetAddress;
<span class="line-added"> 42 import java.net.InetSocketAddress;</span>
<span class="line-added"> 43 import java.net.Proxy;</span>
 44 import java.net.ServerSocket;
 45 import java.net.Socket;
 46 import java.net.URL;
 47 import java.net.URLConnection;
 48 import java.nio.file.Files;
 49 import java.nio.file.Paths;
 50 
<span class="line-added"> 51 import jdk.test.lib.net.URIBuilder;</span>
<span class="line-added"> 52 </span>
 53 public class MarkResetTest {
 54     private static final String FILE_NAME = &quot;EncDec.doc&quot;;
 55 
 56     /**
 57      * A class that simulates, on a separate, an FTP server.
 58      */
 59     private class FtpServer extends Thread {
<span class="line-modified"> 60         private final ServerSocket server;</span>
<span class="line-modified"> 61         private volatile boolean done = false;</span>

 62         private boolean pasvEnabled = true;
 63         private boolean portEnabled = true;
 64         private boolean extendedEnabled = true;
 65 
 66         /**
 67          * This Inner class will handle ONE client at a time.
 68          * That&#39;s where 99% of the protocol handling is done.
 69          */
 70 
 71         private class FtpServerHandler extends Thread {
 72             BufferedReader in;
 73             PrintWriter out;
 74             Socket client;
 75             private final int ERROR = 0;
 76             private final int USER = 1;
 77             private final int PASS = 2;
 78             private final int CWD =  3;
 79             private final int TYPE = 4;
 80             private final int RETR = 5;
 81             private final int PASV = 6;
</pre>
<hr />
<pre>
161                         Socket s = pasv.accept();
162                         return s.getInputStream();
163                     }
164                     if (data_addr != null) {
165                         Socket s = new Socket(data_addr, data_port);
166                         data_addr = null;
167                         data_port = 0;
168                         return s.getInputStream();
169                     }
170                 } catch (Exception e) {
171                     e.printStackTrace();
172                 }
173                 return null;
174             }
175 
176             /**
177              * Handles the protocol exchange with the client.
178              */
179 
180             public void run() {
<span class="line-modified">181                 done = false;</span>
182                 String str;
183                 int res;
184                 boolean logged = false;
185                 boolean waitpass = false;
186 
187                 try {
188                     in = new BufferedReader(new InputStreamReader(
189                                                 client.getInputStream()));
190                     out = new PrintWriter(client.getOutputStream(), true);
191                     out.println(&quot;220 tatooine FTP server (SunOS 5.8) ready.&quot;);
192                 } catch (Exception ex) {
193                     return;
194                 }
195                 while (!done) {
196                     try {
197                         str = in.readLine();
198                         res = parseCmd(str);
199                         if ((res &gt; PASS &amp;&amp; res != QUIT) &amp;&amp; !logged) {
200                             out.println(&quot;530 Not logged in.&quot;);
201                             continue;
</pre>
<hr />
<pre>
232                                 pasv.close();
233                             done = true;
234                             break;
235                         case TYPE:
236                             out.println(&quot;200 Type set to &quot; + arg + &quot;.&quot;);
237                             break;
238                         case CWD:
239                             out.println(&quot;250 CWD command successful.&quot;);
240                             break;
241                         case EPSV:
242                             if (!extendedEnabled || !pasvEnabled) {
243                                 out.println(&quot;500 EPSV is disabled, &quot; +
244                                                 &quot;use PORT instead.&quot;);
245                                 continue;
246                             }
247                             if (&quot;all&quot;.equalsIgnoreCase(arg)) {
248                                 out.println(&quot;200 EPSV ALL command successful.&quot;);
249                                 continue;
250                             }
251                             try {
<span class="line-modified">252                                 if (pasv == null) {</span>
<span class="line-modified">253                                     pasv = new ServerSocket();</span>
<span class="line-added">254                                     pasv.bind(new InetSocketAddress(server.getInetAddress(), 0));</span>
<span class="line-added">255                                 }</span>
256                                 int port = pasv.getLocalPort();
257                                 out.println(&quot;229 Entering Extended&quot; +
258                                         &quot; Passive Mode (|||&quot; + port + &quot;|)&quot;);
259                             } catch (IOException ssex) {
260                                 out.println(&quot;425 Can&#39;t build data connection:&quot; +
261                                                 &quot; Connection refused.&quot;);
262                             }
263                             break;
264 
265                         case PASV:
266                             if (!pasvEnabled) {
267                                 out.println(&quot;500 PASV is disabled, &quot; +
268                                                 &quot;use PORT instead.&quot;);
269                                 continue;
270                             }
271                             try {
<span class="line-modified">272                                 if (pasv == null) {</span>
<span class="line-modified">273                                     pasv = new ServerSocket();</span>
<span class="line-added">274                                     pasv.bind(new InetSocketAddress(&quot;127.0.0.1&quot;, 0));</span>
<span class="line-added">275                                 }</span>
276                                 int port = pasv.getLocalPort();
277 
278                                 // Parenthesis are optional, so let&#39;s be
279                                 // nasty and don&#39;t put them
280                                 out.println(&quot;227 Entering Passive Mode&quot; +
281                                                 &quot; 127,0,0,1,&quot; +
282                                             (port &gt;&gt; 8) + &quot;,&quot; + (port &amp; 0xff));
283                             } catch (IOException ssex) {
284                                 out.println(&quot;425 Can&#39;t build data connection:&quot; +
285                                                  &quot;Connection refused.&quot;);
286                             }
287                             break;
288                         case PORT:
289                             if (!portEnabled) {
290                                 out.println(&quot;500 PORT is disabled, &quot; +
291                                                 &quot;use PASV instead&quot;);
292                                 continue;
293                             }
294                             StringBuffer host;
295                             int i = 0, j = 4;
</pre>
<hr />
<pre>
356                                 } else {
357                                     out.println(&quot;425 Can&#39;t build data&quot; +
358                                         &quot; connection: Connection refused.&quot;);
359                                 }
360                             }
361                             break;
362                         }
363                     } catch (IOException ioe) {
364                         ioe.printStackTrace();
365                         try {
366                             out.close();
367                         } catch (Exception ex2) {
368                         }
369                         done = true;
370                     }
371                 }
372             }
373         }
374 
375         public FtpServer(int port) {
<span class="line-modified">376             this(InetAddress.getLoopbackAddress(), port);</span>
<span class="line-added">377         }</span>
<span class="line-added">378 </span>
<span class="line-added">379         public FtpServer(InetAddress address, int port) {</span>
<span class="line-added">380             try {</span>
<span class="line-added">381                 if (address == null) {</span>
<span class="line-added">382                     server = new ServerSocket(port);</span>
<span class="line-added">383                 } else {</span>
<span class="line-added">384                     server = new ServerSocket();</span>
<span class="line-added">385                     server.bind(new InetSocketAddress(address, port));</span>
<span class="line-added">386                 }</span>
<span class="line-added">387             } catch (IOException e) {</span>
<span class="line-added">388                 throw new UncheckedIOException(e);</span>
<span class="line-added">389             }</span>
390         }
391 
392         public FtpServer() {
<span class="line-modified">393             this(null, 21);</span>
394         }
395 
396         public int getPort() {
<span class="line-modified">397             return server.getLocalPort();</span>


398         }
399 
400         /**
401          * A way to tell the server that it can stop.
402          */
403         synchronized public void terminate() {
404             done = true;
405         }
406 
407 
408         /*
409          * All we got to do here is create a ServerSocket and wait for a
410          * connection. When a connection happens, we just have to create
411          * a thread that will handle it.
412          */
413         public void run() {
414             try {
<span class="line-modified">415                 System.out.println(&quot;FTP server waiting for connections at: &quot;</span>
<span class="line-added">416                         + server.getLocalSocketAddress());</span>
417                 Socket client;
418                 client = server.accept();
419                 (new FtpServerHandler(client)).start();
420                 server.close();
421             } catch (Exception e) {
422             }
423         }
424     }
425 
426     public static void main(String[] args) throws Exception {
427         Files.copy(Paths.get(System.getProperty(&quot;test.src&quot;), FILE_NAME),
428                 Paths.get(&quot;.&quot;, FILE_NAME));
429         new MarkResetTest();
430     }
431 
432     public MarkResetTest() {
433         FtpServer server = null;
434         try {
435             server = new FtpServer(0);
436             server.start();
437             int port = 0;
438             while (port == 0) {
439                 Thread.sleep(500);
440                 port = server.getPort();
441             }
442 
<span class="line-added">443             URL url = URIBuilder.newBuilder()</span>
<span class="line-added">444                     .scheme(&quot;ftp&quot;)</span>
<span class="line-added">445                     .loopback()</span>
<span class="line-added">446                     .port(port)</span>
<span class="line-added">447                     .path(&quot;/&quot; + FILE_NAME)</span>
<span class="line-added">448                     .toURL();</span>
449 
<span class="line-modified">450             URLConnection con = url.openConnection(Proxy.NO_PROXY);</span>


451             System.out.println(&quot;getContent: &quot; + con.getContent());
452             System.out.println(&quot;getContent-length: &quot; + con.getContentLength());
453 
454             InputStream is = con.getInputStream();
455 
456             /**
457              * guessContentTypeFromStream method calls mark and reset methods
458              * on the given stream. Make sure that calling
459              * guessContentTypeFromStream repeatedly does not affect
460              * reading from the stream afterwards
461              */
462             System.out.println(&quot;Call GuessContentTypeFromStream()&quot; +
463                                 &quot; several times..&quot;);
464             for (int i = 0; i &lt; 5; i++) {
465                 System.out.println((i + 1) + &quot; mime-type: &quot; +
466                         con.guessContentTypeFromStream(is));
467             }
468 
469             int len = 0;
470             int c;
</pre>
</td>
</tr>
</table>
<center><a href="FtpURLConnectionLeak.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="TestFtpClientNameListWithNull.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
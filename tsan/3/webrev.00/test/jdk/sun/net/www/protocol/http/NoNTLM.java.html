<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New test/jdk/sun/net/www/protocol/http/NoNTLM.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2013, 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 /* @test
 25  * @bug 8004502
 26  * @library /test/lib
 27  * @summary Sanity check that NTLM will not be selected by the http protocol
 28  *    handler when running on a profile that does not support NTLM
 29  * @modules java.base/sun.net.www
 30  *          java.base/sun.net.www.protocol.http:open
 31  * @run main/othervm NoNTLM
 32  * @run main/othervm -Djava.net.preferIPv6Addresses=true NoNTLM
 33  */
 34 
 35 import java.io.IOException;
 36 import java.lang.reflect.Field;
 37 import java.net.Authenticator;
 38 import java.net.HttpURLConnection;
 39 import java.net.InetAddress;
 40 import java.net.PasswordAuthentication;
 41 import java.net.Proxy;
 42 import java.net.ServerSocket;
 43 import java.net.Socket;
 44 import java.net.URL;
 45 import jdk.test.lib.net.URIBuilder;
 46 import sun.net.www.MessageHeader;
 47 
 48 public class NoNTLM {
 49 
 50     static final String CRLF = &quot;\r\n&quot;;
 51 
 52     static final String OKAY =
 53         &quot;HTTP/1.1 200&quot; + CRLF +
 54         &quot;Content-Length: 0&quot; + CRLF +
 55         &quot;Connection: close&quot; + CRLF +
 56         CRLF;
 57 
 58     static class Client implements Runnable {
 59         private final URL url;
 60         private volatile IOException ioe;
 61         private volatile int respCode;
 62 
 63         Client(int port) throws IOException {
 64             this.url = URIBuilder.newBuilder()
 65                 .scheme(&quot;http&quot;)
 66                 .loopback()
 67                 .port(port)
 68                 .path(&quot;/foo.html&quot;)
 69                 .toURLUnchecked();
 70             System.out.println(&quot;Client URL: &quot; + this.url);
 71         }
 72 
 73         public void run() {
 74             try {
 75                 HttpURLConnection uc =
 76                     (HttpURLConnection)url.openConnection(Proxy.NO_PROXY);
 77                 try {
 78                     uc.getInputStream();
 79                 } catch (IOException x) {
 80                     respCode = uc.getResponseCode();
 81                     throw x;
 82                 }
 83                 uc.disconnect();
 84             } catch (IOException x) {
 85                 if (respCode == 0)
 86                     respCode = -1;
 87                 ioe = x;
 88             }
 89         }
 90 
 91         IOException ioException() {
 92             return ioe;
 93         }
 94 
 95         int respCode() {
 96             return respCode;
 97         }
 98 
 99         static void start(int port) throws IOException {
100             Client client = new Client(port);
101             new Thread(client).start();
102         }
103     }
104 
105     /**
106      * Return the http response with WWW-Authenticate headers for the given
107      * authentication schemes.
108      */
109     static String authReplyFor(String... schemes) {
110         // construct the server reply
111         String reply = &quot;HTTP/1.1 401 Unauthorized&quot; + CRLF +
112                        &quot;Content-Length: 0&quot;+ CRLF +
113                        &quot;Connection: close&quot; + CRLF;
114         for (String s: schemes) {
115             switch (s) {
116                 case &quot;Basic&quot; :
117                     reply += &quot;WWW-Authenticate: Basic realm=\&quot;wallyworld\&quot;&quot; + CRLF;
118                     break;
119                 case &quot;Digest&quot; :
120                     reply += &quot;WWW-Authenticate: Digest&quot; +
121                              &quot; realm=\&quot;wallyworld\&quot;&quot; +
122                              &quot; domain=/&quot; +
123                              &quot; nonce=\&quot;abcdefghijklmnopqrstuvwxyz\&quot;&quot; +
124                              &quot; qop=\&quot;auth\&quot;&quot; + CRLF;
125                     break;
126                 case &quot;NTLM&quot; :
127                     reply += &quot;WWW-Authenticate: NTLM&quot; + CRLF;
128                     break;
129                 default :
130                     throw new RuntimeException(&quot;Should not get here&quot;);
131             }
132         }
133         reply += CRLF;
134         return reply;
135     }
136 
137     /**
138      * Test the http protocol handler with the given authentication schemes
139      * in the WWW-Authenticate header.
140      */
141     static void test(String... schemes) throws IOException {
142 
143         // the authentication scheme that the client is expected to choose
144         String expected = null;
145         for (String s: schemes) {
146             if (expected == null) {
147                 expected = s;
148             } else if (s.equals(&quot;Digest&quot;)) {
149                 expected = s;
150             }
151         }
152 
153         // server reply
154         String reply = authReplyFor(schemes);
155 
156         System.out.println(&quot;====================================&quot;);
157         System.out.println(&quot;Expect client to choose: &quot; + expected);
158         System.out.println(reply);
159         InetAddress loopback = InetAddress.getLoopbackAddress();
160         try (ServerSocket ss = new ServerSocket(0, 0, loopback)) {
161             Client.start(ss.getLocalPort());
162 
163             // client ---- GET ---&gt; server
164             // client &lt;--- 401 ---- server
165             try (Socket s = ss.accept()) {
166                 new MessageHeader().parseHeader(s.getInputStream());
167                 s.getOutputStream().write(reply.getBytes(&quot;US-ASCII&quot;));
168             }
169 
170             // client ---- GET ---&gt; server
171             // client &lt;--- 200 ---- server
172             String auth;
173             try (Socket s = ss.accept()) {
174                 MessageHeader mh = new MessageHeader();
175                 mh.parseHeader(s.getInputStream());
176                 s.getOutputStream().write(OKAY.getBytes(&quot;US-ASCII&quot;));
177                 auth = mh.findValue(&quot;Authorization&quot;);
178             }
179 
180             // check Authorization header
181             if (auth == null)
182                 throw new RuntimeException(&quot;Authorization header not found&quot;);
183             System.out.println(&quot;Server received Authorization header: &quot; + auth);
184             String[] values = auth.split(&quot; &quot;);
185             if (!values[0].equals(expected))
186                 throw new RuntimeException(&quot;Unexpected value&quot;);
187         }
188     }
189 
190     /**
191      * Test the http protocol handler with one WWW-Authenticate header with
192      * the value &quot;NTLM&quot;.
193      */
194     static void testNTLM() throws Exception {
195         // server reply
196         String reply = authReplyFor(&quot;NTLM&quot;);
197 
198         System.out.println(&quot;====================================&quot;);
199         System.out.println(&quot;Expect client to fail with 401 Unauthorized&quot;);
200         System.out.println(reply);
201 
202         InetAddress loopback = InetAddress.getLoopbackAddress();
203         try (ServerSocket ss = new ServerSocket(0, 0, loopback)) {
204             Client client = new Client(ss.getLocalPort());
205             Thread thr = new Thread(client);
206             thr.start();
207 
208             // client ---- GET ---&gt; server
209             // client &lt;--- 401 ---- client
210             try (Socket s = ss.accept()) {
211                 new MessageHeader().parseHeader(s.getInputStream());
212                 s.getOutputStream().write(reply.getBytes(&quot;US-ASCII&quot;));
213             }
214 
215             // the client should fail with 401
216             System.out.println(&quot;Waiting for client to terminate&quot;);
217             thr.join();
218             IOException ioe = client.ioException();
219             if (ioe != null)
220                 System.out.println(&quot;Client failed: &quot; + ioe);
221             int respCode = client.respCode();
222             if (respCode != 0 &amp;&amp; respCode != -1)
223                 System.out.println(&quot;Client received HTTP response code: &quot; + respCode);
224             if (respCode != HttpURLConnection.HTTP_UNAUTHORIZED)
225                 throw new RuntimeException(&quot;Unexpected response code&quot;);
226         }
227     }
228 
229     public static void main(String[] args) throws Exception {
230         boolean ntlmSupported = false;
231         try {
232             Class&lt;?&gt; ntlmProxyClass = Class.forName(&quot;sun.net.www.protocol.http.NTLMAuthenticationProxy&quot;, true, NoNTLM.class.getClassLoader());
233             Field ntlmSupportedField = ntlmProxyClass.getDeclaredField(&quot;supported&quot;);
234             ntlmSupportedField.setAccessible(true);
235             if (ntlmSupportedField.getBoolean(null)) {
236                 System.out.println(&quot;NTLM is supported.&quot;);
237                 ntlmSupported = true;
238             }
239         } catch (ClassNotFoundException okay) { }
240 
241         // setup Authenticator
242         Authenticator.setDefault(new Authenticator() {
243             @Override
244             protected PasswordAuthentication getPasswordAuthentication() {
245                 return new PasswordAuthentication(&quot;user&quot;, &quot;pass&quot;.toCharArray());
246             }
247         });
248 
249         // test combinations of authentication schemes
250         test(&quot;Basic&quot;);
251         test(&quot;Digest&quot;);
252         test(&quot;Basic&quot;, &quot;Digest&quot;);
253 
254         if (ntlmSupported) {
255             System.out.println(&quot;====================================&quot;);
256             System.out.println(&quot;NTLM is supported: client would select NTLM: skipping `test(\&quot;Basic\&quot;, \&quot;NTLM\&quot;)`..&quot;);
257         } else {
258             test(&quot;Basic&quot;, &quot;NTLM&quot;);
259         }
260 
261         test(&quot;Digest&quot;, &quot;NTLM&quot;);
262         test(&quot;Basic&quot;, &quot;Digest&quot;, &quot;NTLM&quot;);
263 
264         if (ntlmSupported) {
265             System.out.println(&quot;====================================&quot;);
266             System.out.println(&quot;NTLM is supported: client would select NTLM: skipping `testNTLM()`..&quot;);
267         } else {
268             // test NTLM only, this should fail with &quot;401 Unauthorized&quot;
269             testNTLM();
270         }
271 
272         System.out.println();
273         System.out.println(&quot;TEST PASSED&quot;);
274     }
275 }
    </pre>
  </body>
</html>
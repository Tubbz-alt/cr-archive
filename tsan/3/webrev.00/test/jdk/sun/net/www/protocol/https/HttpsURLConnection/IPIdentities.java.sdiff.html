<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff test/jdk/sun/net/www/protocol/https/HttpsURLConnection/IPIdentities.java</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="IPAddressIPIdentities.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="Identities.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>test/jdk/sun/net/www/protocol/https/HttpsURLConnection/IPIdentities.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 //
 25 // SunJSSE does not support dynamic system properties, no way to re-use
 26 // system properties in samevm/agentvm mode.
 27 //
 28 
 29 /* @test
 30  * @summary X509 certificate hostname checking is broken in JDK1.6.0_10
 31  * @bug 6766775

 32  * @run main/othervm IPIdentities
 33  * @author Xuelei Fan
 34  */
 35 
 36 import java.net.*;
 37 import java.util.*;
 38 import java.io.*;
 39 import javax.net.ssl.*;
 40 import java.security.Security;
 41 import java.security.KeyStore;
 42 import java.security.KeyFactory;
 43 import java.security.cert.Certificate;
 44 import java.security.cert.CertificateFactory;
 45 import java.security.spec.*;
 46 import java.security.interfaces.*;
 47 import java.math.BigInteger;

 48 
 49 /*
 50  * Certificates and key used in the test.
 51  *
 52  * TLS server certificate:
 53  * server private key:
 54  * -----BEGIN RSA PRIVATE KEY-----
 55  * Proc-Type: 4,ENCRYPTED
 56  * DEK-Info: DES-EDE3-CBC,D9AE407F6D0E389A
 57  *
 58  * WPrA7TFol/cQCcp9oHnXWNpYlvRbbIcQj0m+RKT2Iuzfus+DHt3Zadf8nJpKfX2e
 59  * h2rnhlzCN9M7djRDooZKDOPCsdBn51Au7HlZF3S3Opgo7D8XFM1a8t1Je4ke14oI
 60  * nw6QKYsBblRziPnP2PZ0zvX24nOv7bbY8beynlJHGs00VWSFdoH2DS0aE1p6D+3n
 61  * ptJuJ75dVfZFK4X7162APlNXevX8D6PEQpSiRw1rjjGGcnvQ4HdWk3BxDVDcCNJb
 62  * Y1aGNRxsjTDvPi3R9Qx2M+W03QzEPx4SR3ZHVskeSJHaetM0TM/w/45Paq4GokXP
 63  * ZeTnbEx1xmjkA7h+t4doLL4watx5F6yLsJzu8xB3lt/1EtmkYtLz1t7X4BetPAXz
 64  * zS69X/VwhKfsOI3qXBWuL2oHPyhDmT1gcaUQwEPSV6ogHEEQEDXdiUS8heNK13KF
 65  * TCQYFkETvV2BLxUhV1hypPzRQ6tUpJiAbD5KmoK2lD9slshG2QtvKQq0/bgkDY5J
 66  * LhDHV2dtcZ3kDPkkZXpbcJQvoeH3d09C5sIsuTFo2zgNR6oETHUc5TzP6FY2YYRa
 67  * QcK5HcmtsRRiXFm01ac+aMejJUIujjFt84SiKWT/73vC8AmY4tYcJBLjCg4XIxSH
</pre>
<hr />
<pre>
635     volatile static boolean closeReady = false;
636 
637     /*
638      * Turn on SSL debugging?
639      */
640     static boolean debug = false;
641 
642     private SSLServerSocket sslServerSocket = null;
643 
644     /*
645      * Define the server side of the test.
646      *
647      * If the server prematurely exits, serverReady will be set to true
648      * to avoid infinite hangs.
649      */
650     void doServerSide() throws Exception {
651         SSLContext context = getSSLContext(trusedCertStr, serverCertStr,
652             serverModulus, serverPrivateExponent, passphrase);
653         SSLServerSocketFactory sslssf = context.getServerSocketFactory();
654 




655         sslServerSocket =
<span class="line-modified">656             (SSLServerSocket) sslssf.createServerSocket(serverPort);</span>

657         serverPort = sslServerSocket.getLocalPort();
658 
659         /*
660          * Signal Client, we&#39;re ready for his connect.
661          */
662         serverReady = true;
663 
664         SSLSocket sslSocket = (SSLSocket) sslServerSocket.accept();
665         sslSocket.setNeedClientAuth(true);
666 
667         PrintStream out =
668                 new PrintStream(sslSocket.getOutputStream());
669 
670         try {
671             // ignore request data
672 
673             // send the response
674             out.print(&quot;HTTP/1.1 200 OK\r\n&quot;);
675             out.print(&quot;Content-Type: text/html; charset=iso-8859-1\r\n&quot;);
676             out.print(&quot;Content-Length: &quot;+ 9 +&quot;\r\n&quot;);
</pre>
<hr />
<pre>
696      * If the server prematurely exits, serverReady will be set to true
697      * to avoid infinite hangs.
698      */
699     void doClientSide() throws Exception {
700         SSLContext reservedSSLContext = SSLContext.getDefault();
701         try {
702             SSLContext context = getSSLContext(trusedCertStr, clientCertStr,
703                 clientModulus, clientPrivateExponent, passphrase);
704             SSLContext.setDefault(context);
705 
706             /*
707              * Wait for server to get started.
708              */
709             while (!serverReady) {
710                 Thread.sleep(50);
711             }
712 
713             HttpsURLConnection http = null;
714 
715             /* establish http connection to server */
<span class="line-modified">716             URL url = new URL(&quot;https://localhost:&quot; + serverPort+&quot;/&quot;);</span>





717             System.out.println(&quot;url is &quot;+url.toString());
718 
719             try {
<span class="line-modified">720                 http = (HttpsURLConnection)url.openConnection();</span>
721 
722                 int respCode = http.getResponseCode();
723                 System.out.println(&quot;respCode = &quot;+respCode);
724             } finally {
725                 if (http != null) {
726                     http.disconnect();
727                 }
728                 closeReady = true;
729             }
730         } finally {
731             SSLContext.setDefault(reservedSSLContext);
732         }
733     }
734 
735     /*
736      * =============================================================
737      * The remainder is just support stuff
738      */
739 
740     // use any free port by default
</pre>
</td>
<td>
<hr />
<pre>
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 //
 25 // SunJSSE does not support dynamic system properties, no way to re-use
 26 // system properties in samevm/agentvm mode.
 27 //
 28 
 29 /* @test
 30  * @summary X509 certificate hostname checking is broken in JDK1.6.0_10
 31  * @bug 6766775
<span class="line-added"> 32  * @library /test/lib</span>
 33  * @run main/othervm IPIdentities
 34  * @author Xuelei Fan
 35  */
 36 
 37 import java.net.*;
 38 import java.util.*;
 39 import java.io.*;
 40 import javax.net.ssl.*;
 41 import java.security.Security;
 42 import java.security.KeyStore;
 43 import java.security.KeyFactory;
 44 import java.security.cert.Certificate;
 45 import java.security.cert.CertificateFactory;
 46 import java.security.spec.*;
 47 import java.security.interfaces.*;
 48 import java.math.BigInteger;
<span class="line-added"> 49 import jdk.test.lib.net.URIBuilder;</span>
 50 
 51 /*
 52  * Certificates and key used in the test.
 53  *
 54  * TLS server certificate:
 55  * server private key:
 56  * -----BEGIN RSA PRIVATE KEY-----
 57  * Proc-Type: 4,ENCRYPTED
 58  * DEK-Info: DES-EDE3-CBC,D9AE407F6D0E389A
 59  *
 60  * WPrA7TFol/cQCcp9oHnXWNpYlvRbbIcQj0m+RKT2Iuzfus+DHt3Zadf8nJpKfX2e
 61  * h2rnhlzCN9M7djRDooZKDOPCsdBn51Au7HlZF3S3Opgo7D8XFM1a8t1Je4ke14oI
 62  * nw6QKYsBblRziPnP2PZ0zvX24nOv7bbY8beynlJHGs00VWSFdoH2DS0aE1p6D+3n
 63  * ptJuJ75dVfZFK4X7162APlNXevX8D6PEQpSiRw1rjjGGcnvQ4HdWk3BxDVDcCNJb
 64  * Y1aGNRxsjTDvPi3R9Qx2M+W03QzEPx4SR3ZHVskeSJHaetM0TM/w/45Paq4GokXP
 65  * ZeTnbEx1xmjkA7h+t4doLL4watx5F6yLsJzu8xB3lt/1EtmkYtLz1t7X4BetPAXz
 66  * zS69X/VwhKfsOI3qXBWuL2oHPyhDmT1gcaUQwEPSV6ogHEEQEDXdiUS8heNK13KF
 67  * TCQYFkETvV2BLxUhV1hypPzRQ6tUpJiAbD5KmoK2lD9slshG2QtvKQq0/bgkDY5J
 68  * LhDHV2dtcZ3kDPkkZXpbcJQvoeH3d09C5sIsuTFo2zgNR6oETHUc5TzP6FY2YYRa
 69  * QcK5HcmtsRRiXFm01ac+aMejJUIujjFt84SiKWT/73vC8AmY4tYcJBLjCg4XIxSH
</pre>
<hr />
<pre>
637     volatile static boolean closeReady = false;
638 
639     /*
640      * Turn on SSL debugging?
641      */
642     static boolean debug = false;
643 
644     private SSLServerSocket sslServerSocket = null;
645 
646     /*
647      * Define the server side of the test.
648      *
649      * If the server prematurely exits, serverReady will be set to true
650      * to avoid infinite hangs.
651      */
652     void doServerSide() throws Exception {
653         SSLContext context = getSSLContext(trusedCertStr, serverCertStr,
654             serverModulus, serverPrivateExponent, passphrase);
655         SSLServerSocketFactory sslssf = context.getServerSocketFactory();
656 
<span class="line-added">657         // doClientSide() connects to the loopback address</span>
<span class="line-added">658         InetAddress loopback = InetAddress.getLoopbackAddress();</span>
<span class="line-added">659         InetSocketAddress address = new InetSocketAddress(loopback, serverPort);</span>
<span class="line-added">660 </span>
661         sslServerSocket =
<span class="line-modified">662             (SSLServerSocket) sslssf.createServerSocket();</span>
<span class="line-added">663         sslServerSocket.bind(address);</span>
664         serverPort = sslServerSocket.getLocalPort();
665 
666         /*
667          * Signal Client, we&#39;re ready for his connect.
668          */
669         serverReady = true;
670 
671         SSLSocket sslSocket = (SSLSocket) sslServerSocket.accept();
672         sslSocket.setNeedClientAuth(true);
673 
674         PrintStream out =
675                 new PrintStream(sslSocket.getOutputStream());
676 
677         try {
678             // ignore request data
679 
680             // send the response
681             out.print(&quot;HTTP/1.1 200 OK\r\n&quot;);
682             out.print(&quot;Content-Type: text/html; charset=iso-8859-1\r\n&quot;);
683             out.print(&quot;Content-Length: &quot;+ 9 +&quot;\r\n&quot;);
</pre>
<hr />
<pre>
703      * If the server prematurely exits, serverReady will be set to true
704      * to avoid infinite hangs.
705      */
706     void doClientSide() throws Exception {
707         SSLContext reservedSSLContext = SSLContext.getDefault();
708         try {
709             SSLContext context = getSSLContext(trusedCertStr, clientCertStr,
710                 clientModulus, clientPrivateExponent, passphrase);
711             SSLContext.setDefault(context);
712 
713             /*
714              * Wait for server to get started.
715              */
716             while (!serverReady) {
717                 Thread.sleep(50);
718             }
719 
720             HttpsURLConnection http = null;
721 
722             /* establish http connection to server */
<span class="line-modified">723             URL url = URIBuilder.newBuilder()</span>
<span class="line-added">724                 .scheme(&quot;https&quot;)</span>
<span class="line-added">725                 .loopback()</span>
<span class="line-added">726                 .port(serverPort)</span>
<span class="line-added">727                 .path(&quot;/&quot;)</span>
<span class="line-added">728                 .toURL();</span>
729             System.out.println(&quot;url is &quot;+url.toString());
730 
731             try {
<span class="line-modified">732                 http = (HttpsURLConnection)url.openConnection(Proxy.NO_PROXY);</span>
733 
734                 int respCode = http.getResponseCode();
735                 System.out.println(&quot;respCode = &quot;+respCode);
736             } finally {
737                 if (http != null) {
738                     http.disconnect();
739                 }
740                 closeReady = true;
741             }
742         } finally {
743             SSLContext.setDefault(reservedSSLContext);
744         }
745     }
746 
747     /*
748      * =============================================================
749      * The remainder is just support stuff
750      */
751 
752     // use any free port by default
</pre>
</td>
</tr>
</table>
<center><a href="IPAddressIPIdentities.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="Identities.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
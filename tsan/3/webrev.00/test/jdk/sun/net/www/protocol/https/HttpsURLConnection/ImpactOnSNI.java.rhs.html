<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames test/jdk/sun/net/www/protocol/https/HttpsURLConnection/ImpactOnSNI.java</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
<a name="1" id="anc1"></a><span class="line-modified">  2  * Copyright (c) 2016, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 //
 25 // SunJSSE does not support dynamic system properties, no way to re-use
 26 // system properties in samevm/agentvm mode.
 27 //
 28 
 29 /*
 30  * @test
 31  * @bug 8144566
 32  * @summary Custom HostnameVerifier disables SNI extension
 33  * @run main/othervm ImpactOnSNI
 34  */
 35 
 36 import java.io.*;
 37 import java.net.*;
 38 import javax.net.ssl.*;
 39 
 40 public class ImpactOnSNI {
 41 
 42     /*
 43      * =============================================================
 44      * Set the various variables needed for the tests, then
 45      * specify what tests to run on each side.
 46      */
 47 
 48     /*
 49      * Should we run the client or server in a separate thread?
 50      * Both sides can throw exceptions, but do you have a preference
 51      * as to which side should be the main thread.
 52      */
 53     private static final boolean separateServerThread = true;
 54 
 55     /*
 56      * Where do we find the keystores?
 57      */
 58     private static final String pathToStores =
 59                                         &quot;../../../../../../javax/net/ssl/etc&quot;;
 60     private static final String keyStoreFile = &quot;keystore&quot;;
 61     private static final String trustStoreFile = &quot;truststore&quot;;
 62     private static final String passwd = &quot;passphrase&quot;;
 63 
 64     /*
 65      * Is the server ready to serve?
 66      */
 67     private static volatile boolean serverReady = false;
 68 
 69     /*
 70      * Is the connection ready to close?
 71      */
 72     private static volatile boolean closeReady = false;
 73 
 74     /*
 75      * Turn on SSL debugging?
 76      */
 77     private static final boolean debug = false;
 78 
 79     /*
 80      * Message posted
 81      */
 82     private static final String postMsg = &quot;HTTP post on a https server&quot;;
 83 
 84     /*
 85      * the fully qualified domain name of localhost
 86      */
 87     private static String hostname = null;
 88 
 89     /*
 90      * If the client or server is doing some kind of object creation
 91      * that the other side depends on, and that thread prematurely
 92      * exits, you may experience a hang.  The test harness will
 93      * terminate all hung threads after its timeout has expired,
 94      * currently 3 minutes by default, but you might try to be
 95      * smart about it....
 96      */
 97 
<a name="2" id="anc2"></a><span class="line-added"> 98     private SSLServerSocket createServerSocket(SSLServerSocketFactory sslssf)</span>
<span class="line-added"> 99         throws Exception {</span>
<span class="line-added">100         SSLServerSocket sslServerSocket =</span>
<span class="line-added">101             (SSLServerSocket)sslssf.createServerSocket();</span>
<span class="line-added">102         InetAddress localHost = InetAddress.getLocalHost();</span>
<span class="line-added">103         InetSocketAddress address = new InetSocketAddress(localHost, serverPort);</span>
<span class="line-added">104         sslServerSocket.bind(address);</span>
<span class="line-added">105         return sslServerSocket;</span>
<span class="line-added">106     }</span>
<span class="line-added">107 </span>
108     /*
109      * Define the server side of the test.
110      *
111      * If the server prematurely exits, serverReady will be set to true
112      * to avoid infinite hangs.
113      */
114     private void doServerSide() throws Exception {
115         SSLServerSocketFactory sslssf =
116             (SSLServerSocketFactory)SSLServerSocketFactory.getDefault();
<a name="3" id="anc3"></a><span class="line-modified">117         try (SSLServerSocket sslServerSocket = createServerSocket(sslssf)) {</span>

118 
119             serverPort = sslServerSocket.getLocalPort();
120 
121             /*
122              * Signal Client, we&#39;re ready for his connect.
123              */
124             serverReady = true;
125 
126             /*
127              * Accept connections
128              */
129             try (SSLSocket sslSocket = (SSLSocket)sslServerSocket.accept()) {
130                 InputStream sslIS = sslSocket.getInputStream();
131                 OutputStream sslOS = sslSocket.getOutputStream();
132                 BufferedReader br =
133                         new BufferedReader(new InputStreamReader(sslIS));
134                 PrintStream ps = new PrintStream(sslOS);
135 
136                 // process HTTP POST request from client
137                 System.out.println(&quot;status line: &quot; + br.readLine());
138                 String msg = null;
139                 while ((msg = br.readLine()) != null &amp;&amp; msg.length() &gt; 0);
140 
141                 msg = br.readLine();
142                 if (msg.equals(postMsg)) {
143                     ps.println(&quot;HTTP/1.1 200 OK\n\n&quot;);
144                 } else {
145                     ps.println(&quot;HTTP/1.1 500 Not OK\n\n&quot;);
146                 }
147                 ps.flush();
148 
149                 ExtendedSSLSession session =
150                         (ExtendedSSLSession)sslSocket.getSession();
151                 if (session.getRequestedServerNames().isEmpty()) {
152                     throw new Exception(&quot;No expected Server Name Indication&quot;);
153                 }
154 
155                 // close the socket
156                 while (!closeReady) {
157                     Thread.sleep(50);
158                 }
159             }
160         }
161     }
162 
163     /*
164      * Define the client side of the test.
165      *
166      * If the server prematurely exits, serverReady will be set to true
167      * to avoid infinite hangs.
168      */
169     private void doClientSide() throws Exception {
170         /*
171          * Wait for server to get started.
172          */
173         while (!serverReady) {
174             Thread.sleep(50);
175         }
176 
177         // Send HTTP POST request to server
178         URL url = new URL(&quot;https://&quot; + hostname + &quot;:&quot; + serverPort);
179 
180         HttpsURLConnection.setDefaultHostnameVerifier(new NameVerifier());
181         HttpsURLConnection http = (HttpsURLConnection)url.openConnection();
182         http.setDoOutput(true);
183 
184         http.setRequestMethod(&quot;POST&quot;);
185         PrintStream ps = new PrintStream(http.getOutputStream());
186         try {
187             ps.println(postMsg);
188             ps.flush();
189             if (http.getResponseCode() != 200) {
190                 throw new RuntimeException(&quot;test Failed&quot;);
191             }
192         } finally {
193             ps.close();
194             http.disconnect();
195             closeReady = true;
196         }
197     }
198 
199     private static class NameVerifier implements HostnameVerifier {
200         public boolean verify(String hostname, SSLSession session) {
201             return true;
202         }
203     }
204 
205     /*
206      * =============================================================
207      * The remainder is just support stuff
208      */
209 
210     // use any free port by default
211     private volatile int serverPort = 0;
212 
213     private volatile Exception serverException = null;
214     private volatile Exception clientException = null;
215 
216     public static void main(String[] args) throws Exception {
217         String keyFilename =
218             System.getProperty(&quot;test.src&quot;, &quot;./&quot;) + &quot;/&quot; + pathToStores +
219                 &quot;/&quot; + keyStoreFile;
220         String trustFilename =
221             System.getProperty(&quot;test.src&quot;, &quot;./&quot;) + &quot;/&quot; + pathToStores +
222                 &quot;/&quot; + trustStoreFile;
223 
224         System.setProperty(&quot;javax.net.ssl.keyStore&quot;, keyFilename);
225         System.setProperty(&quot;javax.net.ssl.keyStorePassword&quot;, passwd);
226         System.setProperty(&quot;javax.net.ssl.trustStore&quot;, trustFilename);
227         System.setProperty(&quot;javax.net.ssl.trustStorePassword&quot;, passwd);
228 
229         if (debug) {
230             System.setProperty(&quot;javax.net.debug&quot;, &quot;all&quot;);
231         }
232 
233         try {
234             hostname = InetAddress.getLocalHost().getCanonicalHostName();
235         } catch (UnknownHostException uhe) {
236             System.out.println(
237                 &quot;Ignore the test as the local hostname cannot be determined&quot;);
238 
239             return;
240         }
241 
242         System.out.println(
243                 &quot;The fully qualified domain name of the local host is &quot; +
244                 hostname);
245         // Ignore the test if the hostname does not sound like a domain name.
246         if ((hostname == null) || hostname.isEmpty() ||
247                 !hostname.contains(&quot;.&quot;) || hostname.endsWith(&quot;.&quot;) ||
248                 hostname.startsWith(&quot;localhost&quot;) ||
249                 Character.isDigit(hostname.charAt(hostname.length() - 1))) {
250 
251             System.out.println(&quot;Ignore the test as the local hostname &quot; +
252                     &quot;cannot be determined as fully qualified domain name&quot;);
253 
254             return;
255         }
256 
257         /*
258          * Start the tests.
259          */
260         new ImpactOnSNI();
261     }
262 
263     private Thread clientThread = null;
264     private Thread serverThread = null;
265 
266     /*
267      * Primary constructor, used to drive remainder of the test.
268      *
269      * Fork off the other side, then do your work.
270      */
271     ImpactOnSNI() throws Exception {
272         Exception startException = null;
273         try {
274             if (separateServerThread) {
275                 startServer(true);
276                 startClient(false);
277             } else {
278                 startClient(true);
279                 startServer(false);
280             }
281         } catch (Exception e) {
282             startException = e;
283         }
284 
285         /*
286          * Wait for other side to close down.
287          */
288         if (separateServerThread) {
289             if (serverThread != null) {
290                 serverThread.join();
291             }
292         } else {
293             if (clientThread != null) {
294                 clientThread.join();
295             }
296         }
297 
298         /*
299          * When we get here, the test is pretty much over.
300          * Which side threw the error?
301          */
302         Exception local;
303         Exception remote;
304 
305         if (separateServerThread) {
306             remote = serverException;
307             local = clientException;
308         } else {
309             remote = clientException;
310             local = serverException;
311         }
312 
313         Exception exception = null;
314 
315         /*
316          * Check various exception conditions.
317          */
318         if ((local != null) &amp;&amp; (remote != null)) {
319             // If both failed, return the curthread&#39;s exception.
320             local.initCause(remote);
321             exception = local;
322         } else if (local != null) {
323             exception = local;
324         } else if (remote != null) {
325             exception = remote;
326         } else if (startException != null) {
327             exception = startException;
328         }
329 
330         /*
331          * If there was an exception *AND* a startException,
332          * output it.
333          */
334         if (exception != null) {
335             if (exception != startException &amp;&amp; startException != null) {
336                 exception.addSuppressed(startException);
337             }
338             throw exception;
339         }
340 
341         // Fall-through: no exception to throw!
342     }
343 
344     private void startServer(boolean newThread) throws Exception {
345         if (newThread) {
346             serverThread = new Thread() {
347                 @Override
348                 public void run() {
349                     try {
350                         doServerSide();
351                     } catch (Exception e) {
352                         /*
353                          * Our server thread just died.
354                          *
355                          * Release the client, if not active already...
356                          */
357                         System.err.println(&quot;Server died...&quot;);
358                         serverReady = true;
359                         serverException = e;
360                     }
361                 }
362             };
363             serverThread.start();
364         } else {
365             try {
366                 doServerSide();
367             } catch (Exception e) {
368                 serverException = e;
369             } finally {
370                 serverReady = true;
371             }
372         }
373     }
374 
375     private void startClient(boolean newThread) throws Exception {
376         if (newThread) {
377             clientThread = new Thread() {
378                 @Override
379                 public void run() {
380                     try {
381                         doClientSide();
382                     } catch (Exception e) {
383                         /*
384                          * Our client thread just died.
385                          */
386                         System.err.println(&quot;Client died...&quot;);
387                         clientException = e;
388                     }
389                 }
390             };
391             clientThread.start();
392         } else {
393             try {
394                 doClientSide();
395             } catch (Exception e) {
396                 clientException = e;
397             }
398         }
399     }
400 }
<a name="4" id="anc4"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="4" type="hidden" />
</body>
</html>
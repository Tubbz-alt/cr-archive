<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames test/jdk/sun/net/www/protocol/http/ProxyTunnelServer.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
<a name="1" id="anc1"></a><span class="line-modified">  2  * Copyright (c) 2002, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 /**
 25  *
 26  * This class includes a proxy server that processes HTTP CONNECT requests,
 27  * and tunnels the data from the client to the server, once the CONNECT
 28  * request is accepted.
 29  * It is used by the TunnelThroughProxy test.
 30  */
 31 
 32 import java.io.*;
 33 import java.net.*;
 34 import java.util.Base64;
 35 import javax.net.ssl.*;
 36 import javax.net.ServerSocketFactory;
 37 import sun.net.www.*;
 38 
 39 public class ProxyTunnelServer extends Thread {
 40 
 41     private final ServerSocket ss;
 42     /*
 43      * holds the registered user&#39;s username and password
 44      * only one such entry is maintained
 45      */
 46     private volatile String userPlusPass;
 47 
 48     // client requesting for a tunnel
 49     private volatile Socket clientSocket = null;
 50 
 51     /*
 52      * Origin server&#39;s address and port that the client
 53      * wants to establish the tunnel for communication.
 54      */
 55     private volatile InetAddress serverInetAddr;
 56     private volatile int serverPort;
 57 
 58     /*
 59      * denote whether the proxy needs to authorize
 60      * CONNECT requests.
 61      */
 62 
 63     volatile boolean needAuth = false;
 64 
 65     public ProxyTunnelServer() throws IOException {
 66         ss = new ServerSocket(0);
 67     }
 68 
<a name="2" id="anc2"></a><span class="line-added"> 69     public ProxyTunnelServer(InetAddress address) throws IOException {</span>
<span class="line-added"> 70         ss = new ServerSocket(0, 0, address);</span>
<span class="line-added"> 71     }</span>
<span class="line-added"> 72 </span>
 73     static private void close(Closeable c) {
 74         try {
 75             if (c != null)
 76                 c.close();
 77         } catch (IOException e) {
 78             e.printStackTrace();
 79         }
 80     }
 81 
 82     public void needUserAuth(boolean auth) {
 83         needAuth = auth;
 84     }
 85 
 86     public void terminate() {
 87         close(ss);
 88         close(clientSocket);
 89     }
 90 
 91     /*
 92      * register users with the proxy, by providing username and
 93      * password. The username and password are used for authorizing the
 94      * user when a CONNECT request is made and needAuth is set to true.
 95      */
 96     public void setUserAuth(String uname, String passwd) {
 97         userPlusPass = uname + &quot;:&quot; + passwd;
 98     }
 99 
100     volatile boolean makeTunnel;
101 
102     public void doTunnel(boolean tunnel) {
103         makeTunnel = tunnel;
104     }
105 
106     public void run() {
107         try {
108             clientSocket = ss.accept();
109             processRequests(makeTunnel);
110         } catch (Exception e) {
111             System.out.println(&quot;Proxy Failed: &quot; + e);
112             e.printStackTrace();
113             try {
114                 ss.close();
115             }
116             catch (IOException excep) {
117                 System.out.println(&quot;ProxyServer close error: &quot; + excep);
118                 excep.printStackTrace();
119             }
120           }
121     }
122 
123     /*
124      * Processes the CONNECT requests, if needAuth is set to true, then
125      * the name and password are extracted from the Proxy-Authorization header
126      * of the request. They are checked against the one that is registered,
127      * if there is a match, connection is set in tunneling mode. If
128      * needAuth is set to false, Proxy-Authorization checks are not made
129      */
130     private void processRequests(boolean makeTunnel) throws Exception {
<a name="3" id="anc3"></a>
131         InputStream in = clientSocket.getInputStream();
132         MessageHeader mheader = new MessageHeader(in);
133         String statusLine = mheader.getValue(0);
134 
<a name="4" id="anc4"></a><span class="line-added">135         System.out.printf(&quot;Proxy: Processing request from &#39;%s&#39;%n&quot;, clientSocket);</span>
<span class="line-added">136 </span>
137         if (statusLine.startsWith(&quot;CONNECT&quot;)) {
138             // retrieve the host and port info from the status-line
139             // retrieveConnectInfo(statusLine);
140             if (needAuth) {
141                 String authInfo;
142                 if ((authInfo = mheader.findValue(&quot;Proxy-Authorization&quot;))
143                                          != null) {
144                    if (authenticate(authInfo)) {
145                         needAuth = false;
146                         System.out.println(
147                                 &quot;Proxy: client authentication successful&quot;);
148                    }
149                 }
150             }
151 
152             if (makeTunnel) {
153                 retrieveConnectInfo(statusLine);
154                 doTunnel();
155                 return;
156             }
157 
158             respondForConnect(needAuth);
159 
160             // connection set to the tunneling mode
161             if (!needAuth) {
162                 // doTunnel();
163                 /*
164                  * done with tunneling, we process only one successful
165                  * tunneling request
166                  */
167                 ss.close();
168             } else {
169                 // we may get another request with Proxy-Authorization set
170                 in.close();
171                 clientSocket.close();
172                 restart();
173             }
174         } else {
175             System.out.println(&quot;proxy server: processes only &quot;
176                                    + &quot;CONNECT method requests, recieved: &quot;
177                                    + statusLine);
178         }
179     }
180 
181     private void respondForConnect(boolean needAuth) throws Exception {
182 
183         OutputStream out = clientSocket.getOutputStream();
184         PrintWriter pout = new PrintWriter(out);
185 
186         if (needAuth) {
187             pout.println(&quot;HTTP/1.1 407 Proxy Auth Required&quot;);
188             pout.println(&quot;Proxy-Authenticate: Basic realm=\&quot;WallyWorld\&quot;&quot;);
189             pout.println();
190             pout.flush();
191             out.close();
192         } else {
193             pout.println(&quot;HTTP/1.1 500 Server Error&quot;);
194             pout.println();
195             pout.flush();
196             out.close();
197         }
198     }
199 
200     private void restart() throws IOException {
201          (new Thread(this)).start();
202     }
203 
204     /*sc
205      * note: Tunneling has to be provided in both directions, i.e
206      * from client-&gt;server and server-&gt;client, even if the application
207      * data may be unidirectional, SSL handshaking data flows in either
208      * direction.
209      */
210     private void doTunnel() throws Exception {
211         OutputStream out = clientSocket.getOutputStream();
212         out.write(&quot;HTTP/1.1 200 OK\r\n\r\n&quot;.getBytes());
213         out.flush();
214 
215         Socket serverSocket = new Socket(serverInetAddr, serverPort);
216         ProxyTunnel clientToServer = new ProxyTunnel(
217                                 clientSocket, serverSocket);
218         ProxyTunnel serverToClient = new ProxyTunnel(
219                                 serverSocket, clientSocket);
220         clientToServer.start();
221         serverToClient.start();
222         System.out.println(&quot;Proxy: Started tunneling.......&quot;);
223 
224         clientToServer.join();
225         serverToClient.join();
226         System.out.println(&quot;Proxy: Finished tunneling........&quot;);
227 
228         clientToServer.close();
229         serverToClient.close();
230     }
231 
232     /*
233      * This inner class provides unidirectional data flow through the sockets
234      * by continuously copying bytes from the input socket onto the output
235      * socket, until both sockets are open and EOF has not been received.
236      */
237     class ProxyTunnel extends Thread {
238         final Socket sockIn;
239         final Socket sockOut;
240         final InputStream input;
241         final OutputStream output;
242 
243         public ProxyTunnel(Socket sockIn, Socket sockOut)
244         throws Exception {
245             this.sockIn = sockIn;
246             this.sockOut = sockOut;
247             input = sockIn.getInputStream();
248             output = sockOut.getOutputStream();
249         }
250 
251         public void run() {
252             int BUFFER_SIZE = 400;
253             byte[] buf = new byte[BUFFER_SIZE];
254             int bytesRead = 0;
255             int count = 0;  // keep track of the amount of data transfer
256 
257             try {
258                 while ((bytesRead = input.read(buf)) &gt;= 0) {
259                     output.write(buf, 0, bytesRead);
260                     output.flush();
261                     count += bytesRead;
262                 }
263             } catch (IOException e) {
264                 /*
265                  * The peer end has closed the connection
266                  * we will close the tunnel
267                  */
268                 close();
269               }
270         }
271 
272         public void close() {
273             try {
274                 if (!sockIn.isClosed())
275                     sockIn.close();
276                 if (!sockOut.isClosed())
277                     sockOut.close();
278             } catch (IOException ignored) { }
279         }
280     }
281 
282     /*
283      ***************************************************************
284      *                  helper methods follow
285      ***************************************************************
286      */
287 
288     /*
289      * This method retrieves the hostname and port of the destination
290      * that the connect request wants to establish a tunnel for
291      * communication.
292      * The input, connectStr is of the form:
293      *                          CONNECT server-name:server-port HTTP/1.x
294      */
295     private void retrieveConnectInfo(String connectStr) throws Exception {
296         int starti;
297         int endi;
298         String connectInfo;
299         String serverName = null;
300         try {
301             starti = connectStr.indexOf(&#39; &#39;);
302             endi = connectStr.lastIndexOf(&#39; &#39;);
303             connectInfo = connectStr.substring(starti+1, endi).trim();
304             // retrieve server name and port
305             endi = connectInfo.indexOf(&#39;:&#39;);
306             serverName = connectInfo.substring(0, endi);
307             serverPort = Integer.parseInt(connectInfo.substring(endi+1));
308         } catch (Exception e) {
309             throw new IOException(&quot;Proxy recieved a request: &quot;
310                                         + connectStr);
311           }
312         serverInetAddr = InetAddress.getByName(serverName);
313     }
314 
315     public int getPort() {
316         return ss.getLocalPort();
317     }
318 
<a name="5" id="anc5"></a><span class="line-added">319     public InetAddress getInetAddress() {</span>
<span class="line-added">320         return ss.getInetAddress();</span>
<span class="line-added">321     }</span>
<span class="line-added">322 </span>
323     /*
324      * do &quot;basic&quot; authentication, authInfo is of the form:
325      *                                  Basic &lt;encoded username&quot;:&quot;password&gt;
326      * reference RFC 2617
327      */
328     private boolean authenticate(String authInfo) throws IOException {
329         boolean matched = false;
330         try {
331             authInfo.trim();
332             int ind = authInfo.indexOf(&#39; &#39;);
333             String recvdUserPlusPass = authInfo.substring(ind + 1).trim();
334             // extract encoded (username:passwd
335             if (userPlusPass.equals(
336                                 new String(Base64.getDecoder().decode(recvdUserPlusPass))
337                                 )) {
338                 matched = true;
339             }
340         } catch (Exception e) {
341               throw new IOException(
342                 &quot;Proxy received invalid Proxy-Authorization value: &quot;
343                  + authInfo);
344           }
345         return matched;
346     }
347 }
<a name="6" id="anc6"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="6" type="hidden" />
</body>
</html>
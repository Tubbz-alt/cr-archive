<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff test/jdk/sun/net/www/protocol/https/TestHttpsServer.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
<body>
<center><a href="NewImpl/JavaxHostnameVerifier.java.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="../jar/B4957695.java.cdiff.html" target="_top">next &gt;</a></center>    <h2>test/jdk/sun/net/www/protocol/https/TestHttpsServer.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 1,7 ***</span>
  /*
<span class="line-modified">!  * Copyright (c) 2002, 2012, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.
<span class="line-new-header">--- 1,7 ---</span>
  /*
<span class="line-modified">!  * Copyright (c) 2002, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 68,12 ***</span>
       * and up to ten TCP connections will be handled simultaneously.
       * @param cb the callback object which is invoked to handle each
       *  incoming request
       */
  
<span class="line-modified">!     public TestHttpsServer (HttpCallback cb) throws IOException {</span>
<span class="line-modified">!         this (cb, 1, 10, 0);</span>
      }
  
      /**
       * Create a &lt;code&gt;TestHttpsServer&lt;code&gt; instance with the specified number of
       * threads and maximum number of connections per thread. This functions
<span class="line-new-header">--- 68,12 ---</span>
       * and up to ten TCP connections will be handled simultaneously.
       * @param cb the callback object which is invoked to handle each
       *  incoming request
       */
  
<span class="line-modified">!     public TestHttpsServer(HttpCallback cb) throws IOException {</span>
<span class="line-modified">!         this(cb, 1, 10, 0);</span>
      }
  
      /**
       * Create a &lt;code&gt;TestHttpsServer&lt;code&gt; instance with the specified number of
       * threads and maximum number of connections per thread. This functions
</pre>
<hr />
<pre>
<span class="line-old-header">*** 84,13 ***</span>
       *     in parallel
       * @param cperthread the number of simultaneous TCP connections to
       *     handle per thread
       */
  
<span class="line-modified">!     public TestHttpsServer (HttpCallback cb, int threads, int cperthread)</span>
          throws IOException {
<span class="line-modified">!         this (cb, threads, cperthread, 0);</span>
      }
  
      /**
       * Create a &lt;code&gt;TestHttpsServer&lt;code&gt; instance with the specified number
       * of threads and maximum number of connections per thread and running on
<span class="line-new-header">--- 84,13 ---</span>
       *     in parallel
       * @param cperthread the number of simultaneous TCP connections to
       *     handle per thread
       */
  
<span class="line-modified">!     public TestHttpsServer(HttpCallback cb, int threads, int cperthread)</span>
          throws IOException {
<span class="line-modified">!         this(cb, threads, cperthread, 0);</span>
      }
  
      /**
       * Create a &lt;code&gt;TestHttpsServer&lt;code&gt; instance with the specified number
       * of threads and maximum number of connections per thread and running on
</pre>
<hr />
<pre>
<span class="line-old-header">*** 104,16 ***</span>
       * @param cperthread the number of simultaneous TCP connections
       *  to handle per thread
       * @param port the port number to bind the server to. &lt;code&gt;Zero&lt;/code&gt;
       *  means choose any free port.
       */
  
<span class="line-modified">!     public TestHttpsServer (HttpCallback cb, int threads, int cperthread, int port)</span>
          throws IOException {
<span class="line-modified">!         schan = ServerSocketChannel.open ();</span>
<span class="line-modified">!         InetSocketAddress addr = new InetSocketAddress (port);</span>
<span class="line-modified">!         schan.socket().bind (addr);</span>
          this.threads = threads;
          this.cb = cb;
          this.cperthread = cperthread;
  
          try {
<span class="line-new-header">--- 104,38 ---</span>
       * @param cperthread the number of simultaneous TCP connections
       *  to handle per thread
       * @param port the port number to bind the server to. &lt;code&gt;Zero&lt;/code&gt;
       *  means choose any free port.
       */
<span class="line-added">+     public TestHttpsServer(HttpCallback cb, int threads, int cperthread, int port)</span>
<span class="line-added">+         throws IOException {</span>
<span class="line-added">+         this(cb, threads, cperthread, null, port);</span>
<span class="line-added">+     }</span>
  
<span class="line-modified">!     /**</span>
<span class="line-added">+      * Create a &lt;code&gt;TestHttpsServer&lt;code&gt; instance with the specified number</span>
<span class="line-added">+      * of threads and maximum number of connections per thread and running on</span>
<span class="line-added">+      * the specified port. The specified number of threads are created to</span>
<span class="line-added">+      * handle incoming requests, and each thread is allowed</span>
<span class="line-added">+      * to handle a number of simultaneous TCP connections.</span>
<span class="line-added">+      * @param cb the callback object which is invoked to handle</span>
<span class="line-added">+      *  each incoming request</span>
<span class="line-added">+      * @param threads the number of threads to create to handle</span>
<span class="line-added">+      *  requests in parallel</span>
<span class="line-added">+      * @param cperthread the number of simultaneous TCP connections</span>
<span class="line-added">+      *  to handle per thread</span>
<span class="line-added">+      * @param address the InetAddress to bind to. {@code Null} means the</span>
<span class="line-added">+      *  wildcard address.</span>
<span class="line-added">+      * @param port the port number to bind the server to. {@code Zero}</span>
<span class="line-added">+      *  means choose any free port.</span>
<span class="line-added">+      */</span>
<span class="line-added">+ </span>
<span class="line-added">+     public TestHttpsServer(HttpCallback cb, int threads, int cperthread, InetAddress address, int port)</span>
          throws IOException {
<span class="line-modified">!         schan = ServerSocketChannel.open();</span>
<span class="line-modified">!         InetSocketAddress addr = new InetSocketAddress(address, port);</span>
<span class="line-modified">!         schan.socket().bind(addr);</span>
          this.threads = threads;
          this.cb = cb;
          this.cperthread = cperthread;
  
          try {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 133,13 ***</span>
  
              sslCtx = SSLContext.getInstance(&quot;TLS&quot;);
  
              sslCtx.init(kmf.getKeyManagers(), tmf.getTrustManagers(), null);
  
<span class="line-modified">!             servers = new Server [threads];</span>
              for (int i=0; i&lt;threads; i++) {
<span class="line-modified">!                 servers[i] = new Server (cb, schan, cperthread);</span>
                  servers[i].start();
              }
          } catch (Exception ex) {
              throw new RuntimeException(&quot;test failed. cause: &quot;+ex.getMessage());
          }
<span class="line-new-header">--- 155,13 ---</span>
  
              sslCtx = SSLContext.getInstance(&quot;TLS&quot;);
  
              sslCtx.init(kmf.getKeyManagers(), tmf.getTrustManagers(), null);
  
<span class="line-modified">!             servers = new Server[threads];</span>
              for (int i=0; i&lt;threads; i++) {
<span class="line-modified">!                 servers[i] = new Server(cb, schan, cperthread);</span>
                  servers[i].start();
              }
          } catch (Exception ex) {
              throw new RuntimeException(&quot;test failed. cause: &quot;+ex.getMessage());
          }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 148,11 ***</span>
      /** Tell all threads in the server to exit within 5 seconds.
       *  This is an abortive termination. Just prior to the thread exiting
       *  all channels in that thread waiting to be closed are forceably closed.
       */
  
<span class="line-modified">!     public void terminate () {</span>
          for (int i=0; i&lt;threads; i++) {
              servers[i].terminate ();
          }
      }
  
<span class="line-new-header">--- 170,11 ---</span>
      /** Tell all threads in the server to exit within 5 seconds.
       *  This is an abortive termination. Just prior to the thread exiting
       *  all channels in that thread waiting to be closed are forceably closed.
       */
  
<span class="line-modified">!     public void terminate() {</span>
          for (int i=0; i&lt;threads; i++) {
              servers[i].terminate ();
          }
      }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 163,10 ***</span>
<span class="line-new-header">--- 185,18 ---</span>
  
      public int getLocalPort () {
          return schan.socket().getLocalPort ();
      }
  
<span class="line-added">+     public String getAuthority() {</span>
<span class="line-added">+         InetAddress address = schan.socket().getInetAddress();</span>
<span class="line-added">+         String hostaddr = address.getHostAddress();</span>
<span class="line-added">+         if (address.isAnyLocalAddress()) hostaddr = &quot;localhost&quot;;</span>
<span class="line-added">+         if (hostaddr.indexOf(&#39;:&#39;) &gt; -1) hostaddr = &quot;[&quot; + hostaddr + &quot;]&quot;;</span>
<span class="line-added">+         return hostaddr + &quot;:&quot; + getLocalPort();</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
      static class Server extends Thread {
  
          ServerSocketChannel schan;
          Selector selector;
          SelectionKey listenerKey;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 176,69 ***</span>
          int maxconn;
          int nconn;
          ClosedChannelList clist;
          boolean shutdown;
  
<span class="line-modified">!         Server (HttpCallback cb, ServerSocketChannel schan, int maxconn) {</span>
              this.schan = schan;
              this.maxconn = maxconn;
              this.cb = cb;
              nconn = 0;
<span class="line-modified">!             consumeBuffer = ByteBuffer.allocate (512);</span>
<span class="line-modified">!             clist = new ClosedChannelList ();</span>
              try {
<span class="line-modified">!                 selector = Selector.open ();</span>
<span class="line-modified">!                 schan.configureBlocking (false);</span>
<span class="line-modified">!                 listenerKey = schan.register (selector, SelectionKey.OP_ACCEPT);</span>
              } catch (IOException e) {
<span class="line-modified">!                 System.err.println (&quot;Server could not start: &quot; + e);</span>
              }
          }
  
          /* Stop the thread as soon as possible */
<span class="line-modified">!         public synchronized void terminate () {</span>
              shutdown = true;
          }
  
<span class="line-modified">!         public void run ()  {</span>
              try {
                  while (true) {
<span class="line-modified">!                     selector.select (1000);</span>
                      Set selected = selector.selectedKeys();
                      Iterator iter = selected.iterator();
                      while (iter.hasNext()) {
                          key = (SelectionKey)iter.next();
                          if (key.equals (listenerKey)) {
<span class="line-modified">!                             SocketChannel sock = schan.accept ();</span>
                              if (sock == null) {
                                  /* false notification */
                                  iter.remove();
                                  continue;
                              }
<span class="line-modified">!                             sock.configureBlocking (true);</span>
                              SSLEngine sslEng = sslCtx.createSSLEngine();
                              sslEng.setUseClientMode(false);
                              new ServerWorker(cb, sock, sslEng).start();
                              nconn ++;
                              if (nconn == maxconn) {
                                  /* deregister */
<span class="line-modified">!                                 listenerKey.cancel ();</span>
                                  listenerKey = null;
                              }
                          } else {
                              if (key.isReadable()) {
                                  boolean closed = false;
<span class="line-modified">!                                 SocketChannel chan = (SocketChannel) key.channel();</span>
                                  if (key.attachment() != null) {
<span class="line-modified">!                                     closed = consume (chan);</span>
                                  }
  
                                  if (closed) {
<span class="line-modified">!                                     chan.close ();</span>
<span class="line-modified">!                                     key.cancel ();</span>
                                      if (nconn == maxconn) {
<span class="line-modified">!                                         listenerKey = schan.register (selector, SelectionKey.OP_ACCEPT);</span>
                                      }
                                      nconn --;
                                  }
                              }
                          }
<span class="line-new-header">--- 206,69 ---</span>
          int maxconn;
          int nconn;
          ClosedChannelList clist;
          boolean shutdown;
  
<span class="line-modified">!         Server(HttpCallback cb, ServerSocketChannel schan, int maxconn) {</span>
              this.schan = schan;
              this.maxconn = maxconn;
              this.cb = cb;
              nconn = 0;
<span class="line-modified">!             consumeBuffer = ByteBuffer.allocate(512);</span>
<span class="line-modified">!             clist = new ClosedChannelList();</span>
              try {
<span class="line-modified">!                 selector = Selector.open();</span>
<span class="line-modified">!                 schan.configureBlocking(false);</span>
<span class="line-modified">!                 listenerKey = schan.register(selector, SelectionKey.OP_ACCEPT);</span>
              } catch (IOException e) {
<span class="line-modified">!                 System.err.println(&quot;Server could not start: &quot; + e);</span>
              }
          }
  
          /* Stop the thread as soon as possible */
<span class="line-modified">!         public synchronized void terminate() {</span>
              shutdown = true;
          }
  
<span class="line-modified">!         public void run()  {</span>
              try {
                  while (true) {
<span class="line-modified">!                     selector.select(1000);</span>
                      Set selected = selector.selectedKeys();
                      Iterator iter = selected.iterator();
                      while (iter.hasNext()) {
                          key = (SelectionKey)iter.next();
                          if (key.equals (listenerKey)) {
<span class="line-modified">!                             SocketChannel sock = schan.accept();</span>
                              if (sock == null) {
                                  /* false notification */
                                  iter.remove();
                                  continue;
                              }
<span class="line-modified">!                             sock.configureBlocking(true);</span>
                              SSLEngine sslEng = sslCtx.createSSLEngine();
                              sslEng.setUseClientMode(false);
                              new ServerWorker(cb, sock, sslEng).start();
                              nconn ++;
                              if (nconn == maxconn) {
                                  /* deregister */
<span class="line-modified">!                                 listenerKey.cancel();</span>
                                  listenerKey = null;
                              }
                          } else {
                              if (key.isReadable()) {
                                  boolean closed = false;
<span class="line-modified">!                                 SocketChannel chan = (SocketChannel)key.channel();</span>
                                  if (key.attachment() != null) {
<span class="line-modified">!                                     closed = consume(chan);</span>
                                  }
  
                                  if (closed) {
<span class="line-modified">!                                     chan.close();</span>
<span class="line-modified">!                                     key.cancel();</span>
                                      if (nconn == maxconn) {
<span class="line-modified">!                                         listenerKey = schan.register(selector, SelectionKey.OP_ACCEPT);</span>
                                      }
                                      nconn --;
                                  }
                              }
                          }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 246,28 ***</span>
                      }
                      clist.check();
  
                      synchronized (this) {
                          if (shutdown) {
<span class="line-modified">!                             clist.terminate ();</span>
                              return;
                          }
                      }
                  }
              } catch (IOException e) {
<span class="line-modified">!                 System.out.println (&quot;Server exception: &quot; + e);</span>
                  // TODO finish
              }
          }
  
          /* read all the data off the channel without looking at it
<span class="line-modified">!              * return true if connection closed</span>
<span class="line-modified">!              */</span>
<span class="line-modified">!         boolean consume (SocketChannel chan) {</span>
              try {
<span class="line-modified">!                 consumeBuffer.clear ();</span>
<span class="line-modified">!                 int c = chan.read (consumeBuffer);</span>
                  if (c == -1)
                      return true;
              } catch (IOException e) {
                  return true;
              }
<span class="line-new-header">--- 276,28 ---</span>
                      }
                      clist.check();
  
                      synchronized (this) {
                          if (shutdown) {
<span class="line-modified">!                             clist.terminate();</span>
                              return;
                          }
                      }
                  }
              } catch (IOException e) {
<span class="line-modified">!                 System.out.println(&quot;Server exception: &quot; + e);</span>
                  // TODO finish
              }
          }
  
          /* read all the data off the channel without looking at it
<span class="line-modified">!          * return true if connection closed</span>
<span class="line-modified">!          */</span>
<span class="line-modified">!         boolean consume(SocketChannel chan) {</span>
              try {
<span class="line-modified">!                 consumeBuffer.clear();</span>
<span class="line-modified">!                 int c = chan.read(consumeBuffer);</span>
                  if (c == -1)
                      return true;
              } catch (IOException e) {
                  return true;
              }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 284,10 ***</span>
<span class="line-new-header">--- 314,11 ---</span>
          SSLEngine sslEng;
          SocketChannel schan;
          HttpCallback cb;
          HandshakeStatus currentHSStatus;
          boolean initialHSComplete;
<span class="line-added">+         boolean handshakeStarted;</span>
          /*
           * All inbound data goes through this buffer.
           *
           * It might be nice to use a cache of ByteBuffers so we&#39;re
           * not alloc/dealloc&#39;ing all over the place.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 296,11 ***</span>
          /*
           * Application buffers, also used for handshaking
           */
          private int appBBSize;
  
<span class="line-modified">!         ServerWorker (HttpCallback cb, SocketChannel schan, SSLEngine sslEng) {</span>
              this.sslEng = sslEng;
              this.schan = schan;
              this.cb = cb;
              currentHSStatus = HandshakeStatus.NEED_UNWRAP;
              initialHSComplete = false;
<span class="line-new-header">--- 327,11 ---</span>
          /*
           * Application buffers, also used for handshaking
           */
          private int appBBSize;
  
<span class="line-modified">!         ServerWorker(HttpCallback cb, SocketChannel schan, SSLEngine sslEng) {</span>
              this.sslEng = sslEng;
              this.schan = schan;
              this.cb = cb;
              currentHSStatus = HandshakeStatus.NEED_UNWRAP;
              initialHSComplete = false;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 332,10 ***</span>
<span class="line-new-header">--- 363,29 ---</span>
  
                      switch (currentHSStatus) {
  
                      case NEED_UNWRAP:
                          int bytes = schan.read(inNetBB);
<span class="line-added">+                         if (!handshakeStarted &amp;&amp; bytes &gt; 0) {</span>
<span class="line-added">+                             handshakeStarted = true;</span>
<span class="line-added">+                             int byte0 = inNetBB.get(0);</span>
<span class="line-added">+                             if (byte0 != 0x16) {</span>
<span class="line-added">+                                 // first byte of a TLS connection is supposed to be</span>
<span class="line-added">+                                 // 0x16. If not it may be a plain text connection.</span>
<span class="line-added">+                                 //</span>
<span class="line-added">+                                 // Sometime a rogue client may try to open a plain</span>
<span class="line-added">+                                 // connection with our server. Calling this method</span>
<span class="line-added">+                                 // gives a chance to the test logic to ignore such</span>
<span class="line-added">+                                 // rogue connections.</span>
<span class="line-added">+                                 //</span>
<span class="line-added">+                                 if (cb.dropPlainTextConnections()) {</span>
<span class="line-added">+                                     try { schan.close(); } catch (IOException x) { };</span>
<span class="line-added">+                                     return;</span>
<span class="line-added">+                                 }</span>
<span class="line-added">+                                 // else sslEng.unwrap will throw later on...</span>
<span class="line-added">+                             }</span>
<span class="line-added">+                         }</span>
  
  needIO:
                          while (currentHSStatus == HandshakeStatus.NEED_UNWRAP) {
                              /*
                               * Don&#39;t need to resize requestBB, since no app data should
</pre>
<hr />
<pre>
<span class="line-old-header">*** 429,49 ***</span>
              }
          }
  
          /* return true if the connection is closed, false otherwise */
  
<span class="line-modified">!         private boolean read (SocketChannel chan, SSLEngine sslEng) {</span>
              HttpTransaction msg;
              boolean res;
              try {
<span class="line-modified">!                 InputStream is = new BufferedInputStream (new NioInputStream (chan, sslEng, inNetBB, inAppBB));</span>
<span class="line-modified">!                 String requestline = readLine (is);</span>
<span class="line-modified">!                 MessageHeader mhead = new MessageHeader (is);</span>
<span class="line-modified">!                 String clen = mhead.findValue (&quot;Content-Length&quot;);</span>
<span class="line-modified">!                 String trferenc = mhead.findValue (&quot;Transfer-Encoding&quot;);</span>
                  String data = null;
<span class="line-modified">!                 if (trferenc != null &amp;&amp; trferenc.equals (&quot;chunked&quot;))</span>
<span class="line-modified">!                     data = new String (readChunkedData (is));</span>
                  else if (clen != null)
<span class="line-modified">!                     data = new String (readNormalData (is, Integer.parseInt (clen)));</span>
<span class="line-modified">!                 String[] req = requestline.split (&quot; &quot;);</span>
                  if (req.length &lt; 2) {
                      /* invalid request line */
                      return false;
                  }
                  String cmd = req[0];
                  URI uri = null;
                  try {
<span class="line-modified">!                     uri = new URI (req[1]);</span>
<span class="line-modified">!                     msg = new HttpTransaction (this, cmd, uri, mhead, data, null, chan);</span>
<span class="line-modified">!                     cb.request (msg);</span>
                  } catch (URISyntaxException e) {
                      System.err.println (&quot;Invalid URI: &quot; + e);
<span class="line-modified">!                     msg = new HttpTransaction (this, cmd, null, null, null, null, chan);</span>
<span class="line-modified">!                     msg.sendResponse (501, &quot;Whatever&quot;);</span>
                  }
                  res = false;
              } catch (IOException e) {
                  res = true;
              }
              return res;
          }
  
<span class="line-modified">!         byte[] readNormalData (InputStream is, int len) throws IOException {</span>
<span class="line-modified">!             byte [] buf  = new byte [len];</span>
              int c, off=0, remain=len;
              while (remain &gt; 0 &amp;&amp; ((c=is.read (buf, off, remain))&gt;0)) {
                  remain -= c;
                  off += c;
              }
<span class="line-new-header">--- 479,49 ---</span>
              }
          }
  
          /* return true if the connection is closed, false otherwise */
  
<span class="line-modified">!         private boolean read(SocketChannel chan, SSLEngine sslEng) {</span>
              HttpTransaction msg;
              boolean res;
              try {
<span class="line-modified">!                 InputStream is = new BufferedInputStream(new NioInputStream(chan, sslEng, inNetBB, inAppBB));</span>
<span class="line-modified">!                 String requestline = readLine(is);</span>
<span class="line-modified">!                 MessageHeader mhead = new MessageHeader(is);</span>
<span class="line-modified">!                 String clen = mhead.findValue(&quot;Content-Length&quot;);</span>
<span class="line-modified">!                 String trferenc = mhead.findValue(&quot;Transfer-Encoding&quot;);</span>
                  String data = null;
<span class="line-modified">!                 if (trferenc != null &amp;&amp; trferenc.equals(&quot;chunked&quot;))</span>
<span class="line-modified">!                     data = new String(readChunkedData(is));</span>
                  else if (clen != null)
<span class="line-modified">!                     data = new String(readNormalData(is, Integer.parseInt(clen)));</span>
<span class="line-modified">!                 String[] req = requestline.split(&quot; &quot;);</span>
                  if (req.length &lt; 2) {
                      /* invalid request line */
                      return false;
                  }
                  String cmd = req[0];
                  URI uri = null;
                  try {
<span class="line-modified">!                     uri = new URI(req[1]);</span>
<span class="line-modified">!                     msg = new HttpTransaction(this, cmd, uri, mhead, data, null, chan);</span>
<span class="line-modified">!                     cb.request(msg);</span>
                  } catch (URISyntaxException e) {
                      System.err.println (&quot;Invalid URI: &quot; + e);
<span class="line-modified">!                     msg = new HttpTransaction(this, cmd, null, null, null, null, chan);</span>
<span class="line-modified">!                     msg.sendResponse(501, &quot;Whatever&quot;);</span>
                  }
                  res = false;
              } catch (IOException e) {
                  res = true;
              }
              return res;
          }
  
<span class="line-modified">!         byte[] readNormalData(InputStream is, int len) throws IOException {</span>
<span class="line-modified">!             byte[] buf  = new byte[len];</span>
              int c, off=0, remain=len;
              while (remain &gt; 0 &amp;&amp; ((c=is.read (buf, off, remain))&gt;0)) {
                  remain -= c;
                  off += c;
              }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 487,35 ***</span>
                  throw new IOException(
                      &quot;Expected &lt;CR&gt;&lt;LF&gt;:  got &#39;&quot; + cr + &quot;/&quot; + lf + &quot;&#39;&quot;);
              }
          }
  
<span class="line-modified">!         byte[] readChunkedData (InputStream is) throws IOException {</span>
<span class="line-modified">!             LinkedList l = new LinkedList ();</span>
              int total = 0;
              for (int len=readChunkLen(is); len!=0; len=readChunkLen(is)) {
<span class="line-modified">!                 l.add (readNormalData(is, len));</span>
                  total += len;
                  readCRLF(is); // CRLF at end of chunk
              }
              readCRLF(is); // CRLF at end of Chunked Stream.
<span class="line-modified">!             byte[] buf = new byte [total];</span>
              Iterator i = l.iterator();
              int x = 0;
              while (i.hasNext()) {
                  byte[] b = (byte[])i.next();
<span class="line-modified">!                 System.arraycopy (b, 0, buf, x, b.length);</span>
                  x += b.length;
              }
              return buf;
          }
  
<span class="line-modified">!         private int readChunkLen (InputStream is) throws IOException {</span>
              int c, len=0;
              boolean done=false, readCR=false;
              while (!done) {
<span class="line-modified">!                 c = is.read ();</span>
                  if (c == &#39;\n&#39; &amp;&amp; readCR) {
                      done = true;
                  } else {
                      if (c == &#39;\r&#39; &amp;&amp; !readCR) {
                          readCR = true;
<span class="line-new-header">--- 537,35 ---</span>
                  throw new IOException(
                      &quot;Expected &lt;CR&gt;&lt;LF&gt;:  got &#39;&quot; + cr + &quot;/&quot; + lf + &quot;&#39;&quot;);
              }
          }
  
<span class="line-modified">!         byte[] readChunkedData(InputStream is) throws IOException {</span>
<span class="line-modified">!             LinkedList l = new LinkedList();</span>
              int total = 0;
              for (int len=readChunkLen(is); len!=0; len=readChunkLen(is)) {
<span class="line-modified">!                 l.add(readNormalData(is, len));</span>
                  total += len;
                  readCRLF(is); // CRLF at end of chunk
              }
              readCRLF(is); // CRLF at end of Chunked Stream.
<span class="line-modified">!             byte[] buf = new byte[total];</span>
              Iterator i = l.iterator();
              int x = 0;
              while (i.hasNext()) {
                  byte[] b = (byte[])i.next();
<span class="line-modified">!                 System.arraycopy(b, 0, buf, x, b.length);</span>
                  x += b.length;
              }
              return buf;
          }
  
<span class="line-modified">!         private int readChunkLen(InputStream is) throws IOException {</span>
              int c, len=0;
              boolean done=false, readCR=false;
              while (!done) {
<span class="line-modified">!                 c = is.read();</span>
                  if (c == &#39;\n&#39; &amp;&amp; readCR) {
                      done = true;
                  } else {
                      if (c == &#39;\r&#39; &amp;&amp; !readCR) {
                          readCR = true;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 533,43 ***</span>
                  }
              }
              return len;
          }
  
<span class="line-modified">!         private String readLine (InputStream is) throws IOException {</span>
              boolean done=false, readCR=false;
<span class="line-modified">!             byte[] b = new byte [512];</span>
              int c, l = 0;
  
              while (!done) {
<span class="line-modified">!                 c = is.read ();</span>
                  if (c == &#39;\n&#39; &amp;&amp; readCR) {
                      done = true;
                  } else {
                      if (c == &#39;\r&#39; &amp;&amp; !readCR) {
                          readCR = true;
                      } else {
                          b[l++] = (byte)c;
                      }
                  }
              }
<span class="line-modified">!             return new String (b);</span>
          }
  
          /** close the channel associated with the current key by:
           * 1. shutdownOutput (send a FIN)
           * 2. mark the key so that incoming data is to be consumed and discarded
           * 3. After a period, close the socket
           */
  
<span class="line-modified">!         synchronized void orderlyCloseChannel (SocketChannel ch) throws IOException {</span>
              ch.socket().shutdownOutput();
          }
  
<span class="line-modified">!         synchronized void abortiveCloseChannel (SocketChannel ch) throws IOException {</span>
<span class="line-modified">!             Socket s = ch.socket ();</span>
<span class="line-modified">!             s.setSoLinger (true, 0);</span>
              ch.close();
          }
      }
  
  
<span class="line-new-header">--- 583,43 ---</span>
                  }
              }
              return len;
          }
  
<span class="line-modified">!         private String readLine(InputStream is) throws IOException {</span>
              boolean done=false, readCR=false;
<span class="line-modified">!             byte[] b = new byte[512];</span>
              int c, l = 0;
  
              while (!done) {
<span class="line-modified">!                 c = is.read();</span>
                  if (c == &#39;\n&#39; &amp;&amp; readCR) {
                      done = true;
                  } else {
                      if (c == &#39;\r&#39; &amp;&amp; !readCR) {
                          readCR = true;
                      } else {
                          b[l++] = (byte)c;
                      }
                  }
              }
<span class="line-modified">!             return new String(b);</span>
          }
  
          /** close the channel associated with the current key by:
           * 1. shutdownOutput (send a FIN)
           * 2. mark the key so that incoming data is to be consumed and discarded
           * 3. After a period, close the socket
           */
  
<span class="line-modified">!         synchronized void orderlyCloseChannel(SocketChannel ch) throws IOException {</span>
              ch.socket().shutdownOutput();
          }
  
<span class="line-modified">!         synchronized void abortiveCloseChannel(SocketChannel ch) throws IOException {</span>
<span class="line-modified">!             Socket s = ch.socket();</span>
<span class="line-modified">!             s.setSoLinger(true, 0);</span>
              ch.close();
          }
      }
  
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 590,77 ***</span>
          ByteBuffer markBuf; /* reads may be satisifed from this buffer */
          boolean marked;
          boolean reset;
          int readlimit;
  
<span class="line-modified">!         public NioInputStream (SocketChannel chan, SSLEngine sslEng, ByteBuffer inNetBB, ByteBuffer inAppBB) throws IOException {</span>
              this.sslEng = sslEng;
              this.channel = chan;
              selector = Selector.open();
              this.inNetBB = inNetBB;
              this.inAppBB = inAppBB;
<span class="line-modified">!             key = chan.register (selector, SelectionKey.OP_READ);</span>
              available = 0;
              one = new byte[1];
              closed = marked = reset = false;
          }
  
<span class="line-modified">!         public synchronized int read (byte[] b) throws IOException {</span>
<span class="line-modified">!             return read (b, 0, b.length);</span>
          }
  
<span class="line-modified">!         public synchronized int read () throws IOException {</span>
<span class="line-modified">!             return read (one, 0, 1);</span>
          }
  
<span class="line-modified">!         public synchronized int read (byte[] b, int off, int srclen) throws IOException {</span>
  
              int canreturn, willreturn;
  
              if (closed)
                  return -1;
  
              if (reset) { /* satisfy from markBuf */
<span class="line-modified">!                 canreturn = markBuf.remaining ();</span>
<span class="line-modified">!                 willreturn = canreturn&gt;srclen ? srclen : canreturn;</span>
                  markBuf.get(b, off, willreturn);
                  if (canreturn == willreturn) {
                      reset = false;
                  }
              } else { /* satisfy from channel */
                  canreturn = available();
                  if (canreturn == 0) {
<span class="line-modified">!                     block ();</span>
                      canreturn = available();
                  }
<span class="line-modified">!                 willreturn = canreturn&gt;srclen ? srclen : canreturn;</span>
                  inAppBB.get(b, off, willreturn);
                  available -= willreturn;
  
                  if (marked) { /* copy into markBuf */
                      try {
<span class="line-modified">!                         markBuf.put (b, off, willreturn);</span>
                      } catch (BufferOverflowException e) {
                          marked = false;
                      }
                  }
              }
              return willreturn;
          }
  
<span class="line-modified">!         public synchronized int available () throws IOException {</span>
              if (closed)
<span class="line-modified">!                 throw new IOException (&quot;Stream is closed&quot;);</span>
  
              if (reset)
                  return markBuf.remaining();
  
              if (available &gt; 0)
                  return available;
  
<span class="line-modified">!             inAppBB.clear ();</span>
<span class="line-modified">!             int bytes = channel.read (inNetBB);</span>
  
              int needed = sslEng.getSession().getApplicationBufferSize();
              if (needed &gt; inAppBB.remaining()) {
                  inAppBB = ByteBuffer.allocate(needed);
              }
<span class="line-new-header">--- 640,77 ---</span>
          ByteBuffer markBuf; /* reads may be satisifed from this buffer */
          boolean marked;
          boolean reset;
          int readlimit;
  
<span class="line-modified">!         public NioInputStream(SocketChannel chan, SSLEngine sslEng, ByteBuffer inNetBB, ByteBuffer inAppBB) throws IOException {</span>
              this.sslEng = sslEng;
              this.channel = chan;
              selector = Selector.open();
              this.inNetBB = inNetBB;
              this.inAppBB = inAppBB;
<span class="line-modified">!             key = chan.register(selector, SelectionKey.OP_READ);</span>
              available = 0;
              one = new byte[1];
              closed = marked = reset = false;
          }
  
<span class="line-modified">!         public synchronized int read(byte[] b) throws IOException {</span>
<span class="line-modified">!             return read(b, 0, b.length);</span>
          }
  
<span class="line-modified">!         public synchronized int read() throws IOException {</span>
<span class="line-modified">!             return read(one, 0, 1);</span>
          }
  
<span class="line-modified">!         public synchronized int read(byte[] b, int off, int srclen) throws IOException {</span>
  
              int canreturn, willreturn;
  
              if (closed)
                  return -1;
  
              if (reset) { /* satisfy from markBuf */
<span class="line-modified">!                 canreturn = markBuf.remaining();</span>
<span class="line-modified">!                 willreturn = canreturn &gt; srclen ? srclen : canreturn;</span>
                  markBuf.get(b, off, willreturn);
                  if (canreturn == willreturn) {
                      reset = false;
                  }
              } else { /* satisfy from channel */
                  canreturn = available();
                  if (canreturn == 0) {
<span class="line-modified">!                     block();</span>
                      canreturn = available();
                  }
<span class="line-modified">!                 willreturn = canreturn &gt; srclen ? srclen : canreturn;</span>
                  inAppBB.get(b, off, willreturn);
                  available -= willreturn;
  
                  if (marked) { /* copy into markBuf */
                      try {
<span class="line-modified">!                         markBuf.put(b, off, willreturn);</span>
                      } catch (BufferOverflowException e) {
                          marked = false;
                      }
                  }
              }
              return willreturn;
          }
  
<span class="line-modified">!         public synchronized int available() throws IOException {</span>
              if (closed)
<span class="line-modified">!                 throw new IOException(&quot;Stream is closed&quot;);</span>
  
              if (reset)
                  return markBuf.remaining();
  
              if (available &gt; 0)
                  return available;
  
<span class="line-modified">!             inAppBB.clear();</span>
<span class="line-modified">!             int bytes = channel.read(inNetBB);</span>
  
              int needed = sslEng.getSession().getApplicationBufferSize();
              if (needed &gt; inAppBB.remaining()) {
                  inAppBB = ByteBuffer.allocate(needed);
              }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 670,49 ***</span>
              available = result.bytesProduced();
  
              if (available &gt; 0)
                  inAppBB.flip();
              else if (available == -1)
<span class="line-modified">!                 throw new IOException (&quot;Stream is closed&quot;);</span>
              return available;
          }
  
          /**
           * block() only called when available==0 and buf is empty
           */
<span class="line-modified">!         private synchronized void block () throws IOException {</span>
              //assert available == 0;
<span class="line-modified">!             int n = selector.select ();</span>
              //assert n == 1;
              selector.selectedKeys().clear();
<span class="line-modified">!             available ();</span>
          }
  
<span class="line-modified">!         public void close () throws IOException {</span>
              if (closed)
                  return;
<span class="line-modified">!             channel.close ();</span>
              closed = true;
          }
  
<span class="line-modified">!         public synchronized void mark (int readlimit) {</span>
              if (closed)
                  return;
              this.readlimit = readlimit;
<span class="line-modified">!             markBuf = ByteBuffer.allocate (readlimit);</span>
              marked = true;
              reset = false;
          }
  
<span class="line-modified">!         public synchronized void reset () throws IOException {</span>
              if (closed )
                  return;
              if (!marked)
<span class="line-modified">!                 throw new IOException (&quot;Stream not marked&quot;);</span>
              marked = false;
              reset = true;
<span class="line-modified">!             markBuf.flip ();</span>
          }
      }
  
      static class NioOutputStream extends OutputStream {
          SSLEngine sslEng;
<span class="line-new-header">--- 720,49 ---</span>
              available = result.bytesProduced();
  
              if (available &gt; 0)
                  inAppBB.flip();
              else if (available == -1)
<span class="line-modified">!                 throw new IOException(&quot;Stream is closed&quot;);</span>
              return available;
          }
  
          /**
           * block() only called when available==0 and buf is empty
           */
<span class="line-modified">!         private synchronized void block() throws IOException {</span>
              //assert available == 0;
<span class="line-modified">!             int n = selector.select();</span>
              //assert n == 1;
              selector.selectedKeys().clear();
<span class="line-modified">!             available();</span>
          }
  
<span class="line-modified">!         public void close() throws IOException {</span>
              if (closed)
                  return;
<span class="line-modified">!             channel.close();</span>
              closed = true;
          }
  
<span class="line-modified">!         public synchronized void mark(int readlimit) {</span>
              if (closed)
                  return;
              this.readlimit = readlimit;
<span class="line-modified">!             markBuf = ByteBuffer.allocate(readlimit);</span>
              marked = true;
              reset = false;
          }
  
<span class="line-modified">!         public synchronized void reset() throws IOException {</span>
              if (closed )
                  return;
              if (!marked)
<span class="line-modified">!                 throw new IOException(&quot;Stream not marked&quot;);</span>
              marked = false;
              reset = true;
<span class="line-modified">!             markBuf.flip();</span>
          }
      }
  
      static class NioOutputStream extends OutputStream {
          SSLEngine sslEng;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 722,37 ***</span>
          SelectionKey key;
          Selector selector;
          boolean closed;
          byte[] one;
  
<span class="line-modified">!         public NioOutputStream (SocketChannel channel, SSLEngine sslEng, ByteBuffer outNetBB, ByteBuffer outAppBB) throws IOException {</span>
              this.sslEng = sslEng;
              this.channel = channel;
              this.outNetBB = outNetBB;
              this.outAppBB = outAppBB;
<span class="line-modified">!             selector = Selector.open ();</span>
<span class="line-modified">!             key = channel.register (selector, SelectionKey.OP_WRITE);</span>
              closed = false;
<span class="line-modified">!             one = new byte [1];</span>
          }
  
<span class="line-modified">!         public synchronized void write (int b) throws IOException {</span>
              one[0] = (byte)b;
<span class="line-modified">!             write (one, 0, 1);</span>
          }
  
<span class="line-modified">!         public synchronized void write (byte[] b) throws IOException {</span>
<span class="line-modified">!             write (b, 0, b.length);</span>
          }
  
<span class="line-modified">!         public synchronized void write (byte[] b, int off, int len) throws IOException {</span>
              if (closed)
<span class="line-modified">!                 throw new IOException (&quot;stream is closed&quot;);</span>
  
<span class="line-modified">!             outAppBB = ByteBuffer.allocate (len);</span>
<span class="line-modified">!             outAppBB.put (b, off, len);</span>
<span class="line-modified">!             outAppBB.flip ();</span>
              int n;
              outNetBB.clear();
              int needed = sslEng.getSession().getPacketBufferSize();
              if (outNetBB.capacity() &lt; needed) {
                  outNetBB = ByteBuffer.allocate(needed);
<span class="line-new-header">--- 772,37 ---</span>
          SelectionKey key;
          Selector selector;
          boolean closed;
          byte[] one;
  
<span class="line-modified">!         public NioOutputStream(SocketChannel channel, SSLEngine sslEng, ByteBuffer outNetBB, ByteBuffer outAppBB) throws IOException {</span>
              this.sslEng = sslEng;
              this.channel = channel;
              this.outNetBB = outNetBB;
              this.outAppBB = outAppBB;
<span class="line-modified">!             selector = Selector.open();</span>
<span class="line-modified">!             key = channel.register(selector, SelectionKey.OP_WRITE);</span>
              closed = false;
<span class="line-modified">!             one = new byte[1];</span>
          }
  
<span class="line-modified">!         public synchronized void write(int b) throws IOException {</span>
              one[0] = (byte)b;
<span class="line-modified">!             write(one, 0, 1);</span>
          }
  
<span class="line-modified">!         public synchronized void write(byte[] b) throws IOException {</span>
<span class="line-modified">!             write(b, 0, b.length);</span>
          }
  
<span class="line-modified">!         public synchronized void write(byte[] b, int off, int len) throws IOException {</span>
              if (closed)
<span class="line-modified">!                 throw new IOException(&quot;stream is closed&quot;);</span>
  
<span class="line-modified">!             outAppBB = ByteBuffer.allocate(len);</span>
<span class="line-modified">!             outAppBB.put(b, off, len);</span>
<span class="line-modified">!             outAppBB.flip();</span>
              int n;
              outNetBB.clear();
              int needed = sslEng.getSession().getPacketBufferSize();
              if (outNetBB.capacity() &lt; needed) {
                  outNetBB = ByteBuffer.allocate(needed);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 762,19 ***</span>
              int newLen = ret.bytesProduced();
              while ((n = channel.write (outNetBB)) &lt; newLen) {
                  newLen -= n;
                  if (newLen == 0)
                      return;
<span class="line-modified">!                 selector.select ();</span>
<span class="line-modified">!                 selector.selectedKeys().clear ();</span>
              }
          }
  
<span class="line-modified">!         public void close () throws IOException {</span>
              if (closed)
                  return;
<span class="line-modified">!             channel.close ();</span>
              closed = true;
          }
      }
  
      /**
<span class="line-new-header">--- 812,19 ---</span>
              int newLen = ret.bytesProduced();
              while ((n = channel.write (outNetBB)) &lt; newLen) {
                  newLen -= n;
                  if (newLen == 0)
                      return;
<span class="line-modified">!                 selector.select();</span>
<span class="line-modified">!                 selector.selectedKeys().clear();</span>
              }
          }
  
<span class="line-modified">!         public void close() throws IOException {</span>
              if (closed)
                  return;
<span class="line-modified">!             channel.close();</span>
              closed = true;
          }
      }
  
      /**
</pre>
<hr />
<pre>
<span class="line-old-header">*** 800,22 ***</span>
      /*
       * Modifiable int object
       */
      private static class IValue {
          int v;
<span class="line-modified">!         IValue (int i) {</span>
              v =i;
          }
      }
  
  
<span class="line-modified">!     private static BValue getCond (String condition) {</span>
          synchronized (conditions) {
<span class="line-modified">!             BValue cond = (BValue) conditions.get (condition);</span>
              if (cond == null) {
                  cond = new BValue();
<span class="line-modified">!                 conditions.put (condition, cond);</span>
              }
              return cond;
          }
      }
  
<span class="line-new-header">--- 850,22 ---</span>
      /*
       * Modifiable int object
       */
      private static class IValue {
          int v;
<span class="line-modified">!         IValue(int i) {</span>
              v =i;
          }
      }
  
  
<span class="line-modified">!     private static BValue getCond(String condition) {</span>
          synchronized (conditions) {
<span class="line-modified">!             BValue cond = (BValue) conditions.get(condition);</span>
              if (cond == null) {
                  cond = new BValue();
<span class="line-modified">!                 conditions.put(condition, cond);</span>
              }
              return cond;
          }
      }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 825,12 ***</span>
       * Threads that subsequently call waitForCondition() will not block.
       * If the named condition did not exist prior to the call, then it is created
       * first.
       */
  
<span class="line-modified">!     public static void setCondition (String condition) {</span>
<span class="line-modified">!         BValue cond = getCond (condition);</span>
          synchronized (cond) {
              if (cond.v) {
                  return;
              }
              cond.v = true;
<span class="line-new-header">--- 875,12 ---</span>
       * Threads that subsequently call waitForCondition() will not block.
       * If the named condition did not exist prior to the call, then it is created
       * first.
       */
  
<span class="line-modified">!     public static void setCondition(String condition) {</span>
<span class="line-modified">!         BValue cond = getCond(condition);</span>
          synchronized (cond) {
              if (cond.v) {
                  return;
              }
              cond.v = true;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 844,12 ***</span>
       * is false, then the thread blocks until another thread sets the condition.
       * If the condition exists and is already set to true, then this call returns
       * immediately without blocking.
       */
  
<span class="line-modified">!     public static void waitForCondition (String condition) {</span>
<span class="line-modified">!         BValue cond = getCond (condition);</span>
          synchronized (cond) {
              if (!cond.v) {
                  try {
                      cond.wait();
                  } catch (InterruptedException e) {}
<span class="line-new-header">--- 894,12 ---</span>
       * is false, then the thread blocks until another thread sets the condition.
       * If the condition exists and is already set to true, then this call returns
       * immediately without blocking.
       */
  
<span class="line-modified">!     public static void waitForCondition(String condition) {</span>
<span class="line-modified">!         BValue cond = getCond(condition);</span>
          synchronized (cond) {
              if (!cond.v) {
                  try {
                      cond.wait();
                  } catch (InterruptedException e) {}
</pre>
<hr />
<pre>
<span class="line-old-header">*** 870,42 ***</span>
       * &lt;P&gt;
       * Obviously, if fewer than N threads make the rendezvous then the result
       * will be a hang.
       */
  
<span class="line-modified">!     public static void rendezvous (String condition, int N) {</span>
          BValue cond;
          IValue iv;
          String name = &quot;RV_&quot;+condition;
  
          /* get the condition */
  
          synchronized (conditions) {
<span class="line-modified">!             cond = (BValue)conditions.get (name);</span>
              if (cond == null) {
                  /* we are first caller */
                  if (N &lt; 2) {
<span class="line-modified">!                     throw new RuntimeException (&quot;rendezvous must be called with N &gt;= 2&quot;);</span>
                  }
<span class="line-modified">!                 cond = new BValue ();</span>
<span class="line-modified">!                 conditions.put (name, cond);</span>
<span class="line-modified">!                 iv = new IValue (N-1);</span>
<span class="line-modified">!                 rv.put (name, iv);</span>
              } else {
                  /* already initialised, just decrement the counter */
<span class="line-modified">!                 iv = (IValue) rv.get (name);</span>
<span class="line-modified">!                 iv.v --;</span>
              }
          }
  
          if (iv.v &gt; 0) {
<span class="line-modified">!             waitForCondition (name);</span>
          } else {
<span class="line-modified">!             setCondition (name);</span>
              synchronized (conditions) {
<span class="line-modified">!                 clearCondition (name);</span>
<span class="line-modified">!                 rv.remove (name);</span>
              }
          }
      }
  
      /**
<span class="line-new-header">--- 920,42 ---</span>
       * &lt;P&gt;
       * Obviously, if fewer than N threads make the rendezvous then the result
       * will be a hang.
       */
  
<span class="line-modified">!     public static void rendezvous(String condition, int N) {</span>
          BValue cond;
          IValue iv;
          String name = &quot;RV_&quot;+condition;
  
          /* get the condition */
  
          synchronized (conditions) {
<span class="line-modified">!             cond = (BValue)conditions.get(name);</span>
              if (cond == null) {
                  /* we are first caller */
                  if (N &lt; 2) {
<span class="line-modified">!                     throw new RuntimeException(&quot;rendezvous must be called with N &gt;= 2&quot;);</span>
                  }
<span class="line-modified">!                 cond = new BValue();</span>
<span class="line-modified">!                 conditions.put(name, cond);</span>
<span class="line-modified">!                 iv = new IValue(N-1);</span>
<span class="line-modified">!                 rv.put(name, iv);</span>
              } else {
                  /* already initialised, just decrement the counter */
<span class="line-modified">!                 iv = (IValue) rv.get(name);</span>
<span class="line-modified">!                 iv.v--;</span>
              }
          }
  
          if (iv.v &gt; 0) {
<span class="line-modified">!             waitForCondition(name);</span>
          } else {
<span class="line-modified">!             setCondition(name);</span>
              synchronized (conditions) {
<span class="line-modified">!                 clearCondition(name);</span>
<span class="line-modified">!                 rv.remove(name);</span>
              }
          }
      }
  
      /**
</pre>
<hr />
<pre>
<span class="line-old-header">*** 917,17 ***</span>
       */
  
      public static void clearCondition(String condition) {
          BValue cond;
          synchronized (conditions) {
<span class="line-modified">!             cond = (BValue) conditions.get (condition);</span>
              if (cond == null) {
                  return;
              }
              synchronized (cond) {
                  if (cond.v) {
<span class="line-modified">!                     conditions.remove (condition);</span>
                  }
              }
          }
      }
  }
<span class="line-new-header">--- 967,17 ---</span>
       */
  
      public static void clearCondition(String condition) {
          BValue cond;
          synchronized (conditions) {
<span class="line-modified">!             cond = (BValue) conditions.get(condition);</span>
              if (cond == null) {
                  return;
              }
              synchronized (cond) {
                  if (cond.v) {
<span class="line-modified">!                     conditions.remove(condition);</span>
                  }
              }
          }
      }
  }
</pre>
<center><a href="NewImpl/JavaxHostnameVerifier.java.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="../jar/B4957695.java.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old test/jdk/sun/net/www/protocol/https/HttpsURLConnection/ProxyTunnelServer.java</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2001, 2016, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 /**
 25  *
 26  * This class includes a proxy server that processes HTTP CONNECT requests,
 27  * and tunnels the data from the client to the server, once the CONNECT
 28  * request is accepted.
 29  * The proxy server processes only one transaction, i.e  a CONNECT request
 30  * followed by the corresponding tunnel data.
 31  */
 32 
 33 import java.io.*;
 34 import java.net.*;
 35 import javax.net.ServerSocketFactory;
 36 import sun.net.www.*;
 37 import java.util.Base64;
 38 
 39 public class ProxyTunnelServer extends Thread {
 40 
 41     private static final int TIMEOUT = 30000;
 42 
 43     private static ServerSocket ss = null;
 44     /*
 45      * holds the registered user&#39;s username and password
 46      * only one such entry is maintained
 47      */
 48     private String userPlusPass;
 49 
 50     // client requesting for a tunnel
 51     private Socket clientSocket = null;
 52 
 53     /*
 54      * Origin server&#39;s address and port that the client
 55      * wants to establish the tunnel for communication.
 56      */
 57     private InetAddress serverInetAddr;
 58     private int serverPort;
 59 
 60     /*
 61      * denote whether the proxy needs to authorize
 62      * CONNECT requests.
 63      */
 64     static boolean needAuth = false;
 65 
 66     public ProxyTunnelServer() throws IOException {
 67         if (ss == null) {
 68             ss = (ServerSocket) ServerSocketFactory.getDefault()
 69                     .createServerSocket(0);
 70             ss.setSoTimeout(TIMEOUT);
 71         }
 72     }
 73 
 74     public void needUserAuth(boolean auth) {
 75         needAuth = auth;
 76     }
 77 
 78     /*
 79      * register users with the proxy, by providing username and
 80      * password. The username and password are used for authorizing the
 81      * user when a CONNECT request is made and needAuth is set to true.
 82      */
 83     public void setUserAuth(String uname, String passwd) {
 84         userPlusPass = uname + &quot;:&quot; + passwd;
 85     }
 86 
 87     public void run() {
 88         try {
 89             clientSocket = ss.accept();
 90             processRequests();
 91         } catch (SocketTimeoutException e) {
 92             System.out.println(
 93                     &quot;Proxy can not get response in time: &quot; + e.getMessage());
 94         } catch (Exception e) {
 95             System.out.println(&quot;Proxy Failed: &quot; + e);
 96             e.printStackTrace();
 97             try {
 98                 ss.close();
 99             }
100             catch (IOException excep) {
101                 System.out.println(&quot;ProxyServer close error: &quot; + excep);
102                 excep.printStackTrace();
103             }
104           }
105     }
106 
107     /*
108      * Processes the CONNECT requests, if needAuth is set to true, then
109      * the name and password are extracted from the Proxy-Authorization header
110      * of the request. They are checked against the one that is registered,
111      * if there is a match, connection is set in tunneling mode. If
112      * needAuth is set to false, Proxy-Authorization checks are not made
113      */
114     private void processRequests() throws Exception {
115 
116         InputStream in = clientSocket.getInputStream();
117         MessageHeader mheader = new MessageHeader(in);
118         String statusLine = mheader.getValue(0);
119 
120         if (statusLine.startsWith(&quot;CONNECT&quot;)) {
121             // retrieve the host and port info from the status-line
122             retrieveConnectInfo(statusLine);
123             if (needAuth) {
124                 String authInfo;
125                 if ((authInfo = mheader.findValue(&quot;Proxy-Authorization&quot;))
126                                          != null) {
127                    if (authenticate(authInfo)) {
128                         needAuth = false;
129                         System.out.println(
130                                 &quot;Proxy: client authentication successful&quot;);
131                    }
132                 }
133             }
134             respondForConnect(needAuth);
135 
136             // connection set to the tunneling mode
137             if (!needAuth) {
138                 doTunnel();
139                 /*
140                  * done with tunneling, we process only one successful
141                  * tunneling request
142                  */
143                 ss.close();
144             } else {
145                 // we may get another request with Proxy-Authorization set
146                 in.close();
147                 clientSocket.close();
148                 restart();
149             }
150         } else {
151             System.out.println(&quot;proxy server: processes only &quot;
152                                    + &quot;CONNECT method requests, recieved: &quot;
153                                    + statusLine);
154         }
155     }
156 
157     private void respondForConnect(boolean needAuth) throws Exception {
158 
159         OutputStream out = clientSocket.getOutputStream();
160         PrintWriter pout = new PrintWriter(out);
161 
162         if (needAuth) {
163             pout.println(&quot;HTTP/1.1 407 Proxy Auth Required&quot;);
164             pout.println(&quot;Proxy-Authenticate: Basic realm=\&quot;WallyWorld\&quot;&quot;);
165             pout.println();
166             pout.flush();
167             out.close();
168         } else {
169             pout.println(&quot;HTTP/1.1 200 OK&quot;);
170             pout.println();
171             pout.flush();
172         }
173     }
174 
175     private void restart() throws IOException {
176          (new Thread(this)).start();
177     }
178 
179     /*
180      * note: Tunneling has to be provided in both directions, i.e
181      * from client-&gt;server and server-&gt;client, even if the application
182      * data may be unidirectional, SSL handshaking data flows in either
183      * direction.
184      */
185     private void doTunnel() throws Exception {
186 
187         Socket serverSocket = new Socket(serverInetAddr, serverPort);
188         ProxyTunnel clientToServer = new ProxyTunnel(
189                                 clientSocket, serverSocket);
190         ProxyTunnel serverToClient = new ProxyTunnel(
191                                 serverSocket, clientSocket);
192         clientToServer.start();
193         serverToClient.start();
194         System.out.println(&quot;Proxy: Started tunneling.......&quot;);
195 
196         clientToServer.join(TIMEOUT);
197         serverToClient.join(TIMEOUT);
198         System.out.println(&quot;Proxy: Finished tunneling........&quot;);
199 
200         clientToServer.close();
201         serverToClient.close();
202     }
203 
204     /*
205      * This inner class provides unidirectional data flow through the sockets
206      * by continuously copying bytes from the input socket onto the output
207      * socket, until both sockets are open and EOF has not been received.
208      */
209     class ProxyTunnel extends Thread {
210         Socket sockIn;
211         Socket sockOut;
212         InputStream input;
213         OutputStream output;
214 
215         public ProxyTunnel(Socket sockIn, Socket sockOut)
216         throws Exception {
217             this.sockIn = sockIn;
218             this.sockOut = sockOut;
219             input = sockIn.getInputStream();
220             output = sockOut.getOutputStream();
221         }
222 
223         public void run() {
224             int BUFFER_SIZE = 400;
225             byte[] buf = new byte[BUFFER_SIZE];
226             int bytesRead = 0;
227 
228             try {
229                 while ((bytesRead = input.read(buf)) &gt;= 0) {
230                     output.write(buf, 0, bytesRead);
231                     output.flush();
232                 }
233             } catch (IOException e) {
234                 /*
235                  * The peer end has closed the connection
236                  * we will close the tunnel
237                  */
238                 close();
239               }
240         }
241 
242         private void close() {
243             try {
244                 if (!sockIn.isClosed())
245                     sockIn.close();
246                 if (!sockOut.isClosed())
247                     sockOut.close();
248             } catch (IOException ignored) { }
249         }
250     }
251 
252     /*
253      ***************************************************************
254      *                  helper methods follow
255      ***************************************************************
256      */
257 
258     /*
259      * This method retrieves the hostname and port of the destination
260      * that the connect request wants to establish a tunnel for
261      * communication.
262      * The input, connectStr is of the form:
263      *                          CONNECT server-name:server-port HTTP/1.x
264      */
265     private void retrieveConnectInfo(String connectStr) throws Exception {
266 
267         int starti;
268         int endi;
269         String connectInfo;
270         String serverName = null;
271         try {
272             starti = connectStr.indexOf(&#39; &#39;);
273             endi = connectStr.lastIndexOf(&#39; &#39;);
274             connectInfo = connectStr.substring(starti+1, endi).trim();
275             // retrieve server name and port
276             endi = connectInfo.indexOf(&#39;:&#39;);
277             serverName = connectInfo.substring(0, endi);
278             serverPort = Integer.parseInt(connectInfo.substring(endi+1));
279         } catch (Exception e) {
280             throw new IOException(&quot;Proxy recieved a request: &quot;
281                                         + connectStr, e);
282           }
283         serverInetAddr = InetAddress.getByName(serverName);
284     }
285 
286     public int getPort() {
287         return ss.getLocalPort();
288     }
289 
290     /*
291      * do &quot;basic&quot; authentication, authInfo is of the form:
292      *                                  Basic &lt;encoded username&quot;:&quot;password&gt;
293      * reference RFC 2617
294      */
295     private boolean authenticate(String authInfo) throws IOException {
296         boolean matched = false;
297         try {
298             authInfo.trim();
299             int ind = authInfo.indexOf(&#39; &#39;);
300             String recvdUserPlusPass = authInfo.substring(ind + 1).trim();
301             // extract encoded (username:passwd
302             if (userPlusPass.equals(
303                             new String( Base64.getMimeDecoder()
304                                         .decode(recvdUserPlusPass))))
305             {
306                 matched = true;
307             }
308         } catch (Exception e) {
309               throw new IOException(
310                 &quot;Proxy received invalid Proxy-Authorization value: &quot;
311                  + authInfo);
312           }
313         return matched;
314     }
315 }
    </pre>
  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames test/jdk/sun/net/www/ftptest/FtpCommandHandler.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
<a name="1" id="anc1"></a><span class="line-modified">  2  * Copyright (c) 2006, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 import java.net.*;
 25 import java.io.*;
 26 import java.util.regex.*;
 27 import java.security.*;
 28 import javax.net.ssl.*;
 29 
 30 /*
 31  * This class handles one client connection. It will interpret and act on the
 32  * commands (like USER, GET, PUT etc...) sent through the socket passed to
 33  * the constructor.
 34  *
 35  * To function it needs to be provided 2 handlers, one for the filesystem
 36  * and one for authentication.
 37  * @see FileSystemHandler
 38  * @see AuthHandler
 39  * @see #setHandlers(FtpFileSystemHandler,FtpAuthHandler)
 40  */
 41 
 42 public class FtpCommandHandler extends Thread {
 43     private FtpServer parent = null;
 44     private Socket cmd = null;
 45     private Socket oldCmd = null;
 46     private InetAddress clientAddr = null;
 47     private ServerSocket pasv = null;
 48 
 49     private BufferedReader in = null;
 50 
 51     private PrintStream out = null;
 52 
 53     private FtpFileSystemHandler fsh = null;
 54     private FtpAuthHandler auth = null;
 55 
 56     private boolean done = false;
 57 
 58     private String username = null;
 59     private String password = null;
 60     private String account = null;
 61     private boolean logged = false;
 62     private boolean epsvAll = false;
 63     private int dataPort = 0;
 64     private InetAddress dataAddress = null;
 65     private boolean pasvEnabled = true;
 66     private boolean portEnabled = true;
 67     private boolean extendedEnabled = true;
 68     private boolean binary = true;
 69     private String renameFrom = null;
 70     private long restart = 0;
 71     private boolean useCrypto = false;
 72     private boolean useDataCrypto = false;
 73     private SSLSocketFactory sslFact = null;
 74 
 75     private final int ERROR = -1;
 76     private final int QUIT = 0;
 77     private final int USER = 1;
 78     private final int PASS = 2;
 79     private final int CWD = 3;
 80     private final int CDUP = 4;
 81     private final int PWD = 5;
 82     private final int TYPE = 6;
 83     private final int NOOP = 7;
 84     private final int RETR = 8;
 85     private final int PORT = 9;
 86     private final int PASV = 10;
 87     private final int EPSV = 11;
 88     private final int EPRT = 12;
 89     private final int SYST = 13;
 90     private final int STOR = 14;
 91     private final int STOU = 15;
 92     private final int LIST = 16;
 93     private final int NLST = 17;
 94     private final int RNFR = 18;
 95     private final int RNTO = 19;
 96     private final int DELE = 20;
 97     private final int REST = 21;
 98     private final int AUTH = 22;
 99     private final int FEAT = 23;
100     private final int CCC = 24;
101     private final int PROT = 25;
102     private final int PBSZ = 26;
103 
104     private String[] commands =
105     { &quot;QUIT&quot;, &quot;USER&quot;, &quot;PASS&quot;, &quot;CWD&quot;, &quot;CDUP&quot;, &quot;PWD&quot;, &quot;TYPE&quot;, &quot;NOOP&quot;, &quot;RETR&quot;,
106       &quot;PORT&quot;, &quot;PASV&quot;, &quot;EPSV&quot;, &quot;EPRT&quot;, &quot;SYST&quot;, &quot;STOR&quot;, &quot;STOU&quot;, &quot;LIST&quot;, &quot;NLST&quot;,
107       &quot;RNFR&quot;, &quot;RNTO&quot;, &quot;DELE&quot;, &quot;REST&quot;, &quot;AUTH&quot;, &quot;FEAT&quot;, &quot;CCC&quot;, &quot;PROT&quot;, &quot;PBSZ&quot;
108     };
109 
110     private boolean isPasvSet() {
111         if (pasv != null &amp;&amp; !pasvEnabled) {
112             try {
113                 pasv.close();
114             } catch ( IOException e) {
115 
116             }
117             pasv = null;
118         }
119         if (pasvEnabled &amp;&amp; pasv != null)
120             return true;
121         return false;
122     }
123 
124     private OutputStream getOutDataStream() throws IOException {
125         if (isPasvSet()) {
126             Socket s = pasv.accept();
127             if (useCrypto &amp;&amp; useDataCrypto) {
128                 SSLSocket ssl = (SSLSocket) sslFact.createSocket(s, clientAddr.getHostName(), s.getPort(), true);
129                 ssl.setUseClientMode(false);
130                 s = ssl;
131             }
132             return s.getOutputStream();
133         }
134         if (dataAddress != null) {
135             Socket s;
136             if (useCrypto) {
137                 s = sslFact.createSocket(dataAddress, dataPort);
138             } else
139                 s = new Socket(dataAddress, dataPort);
140             dataAddress = null;
141             dataPort = 0;
142             return s.getOutputStream();
143         }
144         return null;
145     }
146 
147     private InputStream getInDataStream() throws IOException {
148         if (isPasvSet()) {
149             Socket s = pasv.accept();
150             if (useCrypto &amp;&amp; useDataCrypto) {
151                 SSLSocket ssl = (SSLSocket) sslFact.createSocket(s, clientAddr.getHostName(), s.getPort(), true);
152                 ssl.setUseClientMode(false);
153                 s = ssl;
154             }
155             return s.getInputStream();
156         }
157         if (dataAddress != null) {
158             Socket s;
159             if (useCrypto) {
160                 s = sslFact.createSocket(dataAddress, dataPort);
161             } else
162                 s = new Socket(dataAddress, dataPort);
163             dataAddress = null;
164             dataPort = 0;
165             return s.getInputStream();
166         }
167         return null;
168     }
169 
170     private void parsePort(String port_arg) throws IOException {
171         if (epsvAll) {
172             out.println(&quot;501 PORT not allowed after EPSV ALL.&quot;);
173             return;
174         }
175         if (!portEnabled) {
176             out.println(&quot;500 PORT command is disabled, please use PASV.&quot;);
177             return;
178         }
179         StringBuffer host;
180         int i = 0, j = 4;
181         while (j &gt; 0) {
182             i = port_arg.indexOf(&#39;,&#39;, i + 1);
183             if (i &lt; 0)
184                 break;
185             j--;
186         }
187         if (j != 0) {
188             out.println(&quot;500 &#39;&quot; + port_arg + &quot;&#39;: command not understood.&quot;);
189             return;
190         }
191         try {
192             host = new StringBuffer(port_arg.substring(0, i));
193             for (j = 0; j &lt; host.length(); j++)
194                 if (host.charAt(j) == &#39;,&#39;)
195                     host.setCharAt(j, &#39;.&#39;);
196             String ports = port_arg.substring(i + 1);
197             i = ports.indexOf(&#39;,&#39;);
198             dataPort = Integer.parseInt(ports.substring(0, i)) &lt;&lt; 8;
199             dataPort += (Integer.parseInt(ports.substring(i + 1)));
200             dataAddress = InetAddress.getByName(host.toString());
201             out.println(&quot;200 Command okay.&quot;);
202         } catch (Exception ex3) {
203             dataPort = 0;
204             dataAddress = null;
205             out.println(&quot;500 &#39;&quot; + port_arg + &quot;&#39;: command not understood.&quot;);
206         }
207     }
208 
209     private void parseEprt(String arg) {
210         if (epsvAll) {
211             out.println(&quot;501 PORT not allowed after EPSV ALL&quot;);
212             return;
213         }
214         if (!extendedEnabled || !portEnabled) {
215             out.println(&quot;500 EPRT is disabled, use PASV instead&quot;);
216             return;
217         }
218         Pattern p = Pattern.compile(&quot;\\|(\\d)\\|(.*)\\|(\\d+)\\|&quot;);
219         Matcher m = p.matcher(arg);
220         if (!m.find()) {
221             out.println(&quot;500 &#39;&quot; + arg + &quot;&#39;: command not understood.&quot;);
222             return;
223         }
224         try {
225             dataAddress = InetAddress.getByName(m.group(2));
226         } catch (UnknownHostException e) {
227             out.println(&quot;500 &quot; + arg + &quot;: invalid address.&quot;);
228             dataAddress = null;
229             return;
230         }
231         dataPort = Integer.parseInt(m.group(3));
232         out.println(&quot;200 Command okay.&quot;);
233     }
234 
235     private void doPasv() {
236         if (!pasvEnabled) {
237             out.println(&quot;500 PASV is disabled, use PORT.&quot;);
238             return;
239         }
240         try {
<a name="2" id="anc2"></a>


241             InetAddress rAddress = cmd.getLocalAddress();
242             if (rAddress instanceof Inet6Address) {
243                 out.println(&quot;500 PASV illegal over IPv6 addresses, use EPSV.&quot;);
244                 return;
245             }
<a name="3" id="anc3"></a><span class="line-added">246             if (pasv == null)</span>
<span class="line-added">247                 pasv = new ServerSocket(0, 0, rAddress);</span>
<span class="line-added">248             int port = pasv.getLocalPort();</span>
249             byte[] a = rAddress.getAddress();
250             out.println(&quot;227 Entering Passive Mode &quot; + a[0] + &quot;,&quot; + a[1] + &quot;,&quot; + a[2] + &quot;,&quot; + a[3] + &quot;,&quot; +
251                         (port &gt;&gt; 8) + &quot;,&quot; + (port &amp; 0xff) );
252         } catch (IOException e) {
253             out.println(&quot;425 can&#39;t build data connection: Connection refused.&quot;);
254         }
255     }
256 
257     private void doEpsv(String arg) {
258         if (!extendedEnabled || !pasvEnabled) {
259             out.println(&quot;500 EPSV disabled, use PORT or PASV.&quot;);
260             return;
261         }
262         if (&quot;all&quot;.equalsIgnoreCase(arg)) {
263             out.println(&quot;200 EPSV ALL Command successful.&quot;);
264             epsvAll = true;
265             return;
266         }
267         try {
268             if (pasv == null)
<a name="4" id="anc4"></a><span class="line-modified">269                 pasv = new ServerSocket(0, 0, parent.getInetAddress());</span>
270             int port = pasv.getLocalPort();
271             out.println(&quot;229 Entering Extended Passive Mode (|||&quot; + port + &quot;|)&quot;);
272         } catch (IOException e) {
273             out.println(&quot;500 Can&#39;t create data connection.&quot;);
274         }
275     }
276 
277     private void doRetr(String arg) {
278         try {
279             OutputStream dOut = getOutDataStream();
280             if (dOut != null) {
281                 InputStream dIn = fsh.getFile(arg);
282                 if (dIn == null) {
283                     out.println(&quot;550 File not found.&quot;);
284                     dOut.close();
285                     return;
286                 }
287                 out.println(&quot;150 Opening &quot; + (binary ? &quot;BINARY &quot; : &quot;ASCII &quot;) + &quot; data connection for file &quot; + arg +
288                             &quot;(&quot; + fsh.getFileSize(arg) + &quot; bytes).&quot;);
289                 if (binary) {
290                     byte[] buf = new byte[2048];
291                     dOut = new BufferedOutputStream(dOut);
292                     int count;
293                     if (restart &gt; 0) {
294                         dIn.skip(restart);
295                         restart = 0;
296                     }
297                     do {
298                         count = dIn.read(buf);
299                         if (count &gt; 0)
300                             dOut.write(buf, 0, count);
301                     } while (count &gt;= 0);
302                     dOut.close();
303                     dIn.close();
304                     out.println(&quot;226 Transfer complete.&quot;);
305                 }
306             }
307         } catch (IOException e) {
308 
309         }
310     }
311 
312     private void doStor(String arg, boolean unique) {
313         try {
314             InputStream dIn = getInDataStream();
315             if (dIn != null) {
316                 OutputStream dOut = fsh.putFile(arg);
317                 if (dOut == null) {
318                     out.println(&quot;500 Can&#39;t create file &quot; + arg);
319                     dIn.close();
320                     return;
321                 }
322                 out.println(&quot;150 Opening &quot; + (binary ? &quot;BINARY &quot; : &quot;ASCII &quot;) + &quot; data connection for file &quot; + arg);
323                 if (binary) {
324                     byte[] buf = new byte[2048];
325                     dOut = new BufferedOutputStream(dOut);
326                     int count;
327                     do {
328                         count = dIn.read(buf);
329                         if (count &gt; 0)
330                             dOut.write(buf, 0, count);
331                     } while (count &gt;= 0);
332                     dOut.close();
333                     dIn.close();
334                     out.println(&quot;226 Transfer complete.&quot;);
335                 }
336             }
337         } catch (IOException e) {
338 
339         }
340     }
341 
342     private void doList() {
343         try {
344             OutputStream dOut = getOutDataStream();
345             if (dOut != null) {
346                 InputStream dIn = fsh.listCurrentDir();
347                 if (dIn == null) {
348                     out.println(&quot;550 File not found.&quot;);
349                     dOut.close();
350                     return;
351                 }
352                 out.println(&quot;150 Opening ASCII data connection for file list&quot;);
353                 byte[] buf = new byte[2048];
354                 dOut = new BufferedOutputStream(dOut);
355                 int count;
356                 do {
357                     count = dIn.read(buf);
358                     if (count &gt; 0)
359                         dOut.write(buf, 0, count);
360                 } while (count &gt;= 0);
361                 dOut.close();
362                 dIn.close();
363                 out.println(&quot;226 Transfer complete.&quot;);
364             }
365         } catch (IOException e) {
366 
367         }
368     }
369 
370     private boolean useTLS() {
371         if (sslFact == null) {
372             sslFact = (SSLSocketFactory) SSLSocketFactory.getDefault();
373         }
374         if (sslFact == null)
375             return false;
376         return true;
377     }
378 
379     private void stopTLS() {
380         if (useCrypto) {
381             SSLSocket ssl = (SSLSocket) cmd;
382             try {
383                 ssl.close();
384             } catch (IOException e) {
385                 // nada
386             }
387             cmd = oldCmd;
388             oldCmd = null;
389             try {
390                 in = new BufferedReader(new InputStreamReader(cmd.getInputStream()));
391                 out = new PrintStream(cmd.getOutputStream(), true, &quot;ISO8859_1&quot;);
392             } catch (Exception ex) {
393 
394             }
395         }
396     }
397 
398     public void setHandlers(FtpFileSystemHandler f, FtpAuthHandler a) {
399         fsh = f;
400         auth = a;
401     }
402 
403     public FtpCommandHandler(Socket cl, FtpServer p) {
404         parent = p;
405         cmd = cl;
406         clientAddr = cl.getInetAddress();
407     }
408 
409     public void terminate() {
410         done = true;
411     }
412 
413     private int parseCmd(StringBuffer cmd) {
414 
415         if (cmd == null || cmd.length() &lt; 3) // Shortest command is 3 char long
416             return ERROR;
417         int blank = cmd.indexOf(&quot; &quot;);
418         if (blank &lt; 0)
419             blank = cmd.length();
420         if (blank &lt; 3)
421             return ERROR;
422         String s = cmd.substring(0,blank);
423         cmd.delete(0, blank + 1);
424         System.out.println(&quot;parse: cmd = &quot; + s + &quot; arg = &quot; +cmd.toString());
425         for (int i = 0; i &lt; commands.length; i++)
426             if (s.equalsIgnoreCase(commands[i]))
427                 return i;
428         // Unknown command
429         return ERROR;
430     }
431 
432     private boolean checkLogged() {
433         if (!logged) {
434             out.println(&quot;530 Not logged in.&quot;);
435             return false;
436         }
437         return true;
438     }
439 
440     public void run() {
441         try {
442             // cmd.setSoTimeout(2000);
443             in = new BufferedReader(new InputStreamReader(cmd.getInputStream()));
444             out = new PrintStream(cmd.getOutputStream(), true, &quot;ISO8859_1&quot;);
445             // Below corrupted message style was intentional to test 8151586, please
446             // make sure each message line not broken ftp communication (such as for
447             // message line lenght &gt;=4, the 4th char required &#39;-&#39; to allow
448             // implementation thinks that it has seen multi-line reply &#39;###-&#39;
449             // sequence), otherwise it will affect normal ftp tests which depends
450             // on this.
451             out.println(&quot;---------------------------------\n220 Java FTP test server&quot;
452                     + &quot; (j2se 6.0) ready.\n \n   -            Please send commands\n&quot;
453                     + &quot;-----------------------------\n\n\n&quot;);
454             out.flush();
455             if (auth.authType() == 0) // No auth needed
456                 logged = true;
457         } catch (IOException e) {
458             e.printStackTrace();
459             return;
460         }
461 
462         String str;
463         StringBuffer buf;
464         int res;
465         while (!done) {
466             try {
467                 str = in.readLine();
468                 System.out.println(&quot;line: &quot; + str);
<a name="5" id="anc5"></a><span class="line-added">469                 if (str == null) {</span>
<span class="line-added">470                     System.out.println(&quot;EOF read from input&quot;);</span>
<span class="line-added">471                     break;</span>
<span class="line-added">472                 }</span>
473                 buf = new StringBuffer(str);
474                 res = parseCmd(buf);
475                 switch (res) {
476                 case ERROR:
477                     out.println(&quot;500 &#39;&quot; + str +&quot;&#39;: command not understood.&quot;);
478                     break;
479                 case QUIT:
480                     out.println(&quot;221 Goodbye.&quot;);
481                     done = true;
482                     break;
483                 case USER:
484                     logged = false;
485                     username = buf.toString();
486                     if (auth.authType() &gt; 1)
487                         out.println(&quot;331 User name okay, need password.&quot;);
488                     else {
489                         if (auth.authenticate(username, null)) {
490                             out.println(&quot;230 User logged in, proceed.&quot;);
491                             logged = true;
492                         } else {
493                             out.println(&quot;331 User name okay, need password.&quot;);
494                         }
495                     }
496                     break;
497                 case PASS:
498                     if (logged || (username == null)) {
499                         out.println(&quot;503 Login with USER first.&quot;);
500                         break;
501                     }
502                     password = buf.toString();
503                     if (auth.authType() == 3) {
504                         out.println(&quot;332 Need account for login.&quot;);
505                         break;
506                     }
507                     if (auth.authenticate(username, password)) {
508                         logged = true;
509                         out.println(&quot;230 User &quot; + username + &quot; logged in.&quot;);
510                         break;
511                     }
512                     out.println(&quot;530 Login incorrect.&quot;);
513                     username = null;
514                     break;
515                 case CWD:
516                     if (checkLogged()) {
517                         String path = buf.toString();
518                         if (fsh.cd(path)) {
519                             out.println(&quot;250 CWD command successful.&quot;);
520                         } else {
521                             out.println(&quot;550 &quot; + path + &quot;: no such file or directory.&quot;);
522                         }
523                     }
524                     break;
525                 case CDUP:
526                     if (checkLogged()) {
527                         if (fsh.cdUp())
528                             out.println(&quot;250 CWD command successful.&quot;);
529                         else
530                             out.println(&quot;550 invalid path.&quot;);
531                     }
532                     break;
533                 case PWD:
534                     if (checkLogged()) {
535                         String s = fsh.pwd();
536                         out.println(&quot;257 \&quot;&quot; + s + &quot;\&quot; is current directory&quot;);
537                     }
538                     break;
539                 case NOOP:
540                     if (checkLogged()) {
541                         out.println(&quot;200 NOOP command successful.&quot;);
542                     }
543                     break;
544                 case PORT:
545                     if (checkLogged()) {
546                         parsePort(buf.toString());
547                     }
548                     break;
549                 case EPRT:
550                     if (checkLogged()) {
551                         parseEprt(buf.toString());
552                     }
553                     break;
554                 case PASV:
555                     if (checkLogged())
556                         doPasv();
557                     break;
558                 case EPSV:
559                     if (checkLogged())
560                         doEpsv(buf.toString());
561                     break;
562                 case RETR:
563                     if (checkLogged()) {
564                         doRetr(buf.toString());
565                     }
566                     break;
567                 case SYST:
568                     if (checkLogged()) {
569                         out.println(&quot;215 UNIX Type: L8 Version: Java 6.0&quot;);
570                     }
571                     break;
572                 case TYPE:
573                     if (checkLogged()) {
574                         String arg = buf.toString();
575                         if (arg.length() != 1 || &quot;AIE&quot;.indexOf(arg.charAt(0)) &lt; 0) {
576                             out.println(&quot;500 &#39;TYPE &quot; + arg + &quot;&#39; command not understood.&quot;);
577                             continue;
578                         }
579                         out.println(&quot;200 Type set to &quot; + buf.toString() + &quot;.&quot;);
580                         if (arg.charAt(0) == &#39;I&#39;)
581                             binary = true;
582                         else
583                             binary = false;
584                     }
585                     break;
586                 case STOR:
587                 case STOU:
588                     // TODO: separate STOR and STOU (Store Unique)
589                     if (checkLogged()) {
590                         doStor(buf.toString(), false);
591                     }
592                     break;
593                 case LIST:
594                     if (checkLogged()) {
595                         doList();
596                     }
597                     break;
598                 case NLST:
599                     // TODO: implememt
600                     break;
601                 case DELE:
602                     if (checkLogged()) {
603                         String arg = buf.toString();
604                         if (fsh.removeFile(arg)) {
605                             out.println(&quot;250 file &quot; + arg + &quot; deleted.&quot;);
606                             break;
607                         }
608                         out.println(&quot;550 &quot; + arg + &quot;: no such file or directory.&quot;);
609                     }
610                     break;
611                 case RNFR:
612                     if (checkLogged()) {
613                         if (renameFrom != null) {
614                             out.println(&quot;503 Bad sequence of commands.&quot;);
615                             break;
616                         }
617                         renameFrom = buf.toString();
618                         if (fsh.fileExists(renameFrom)) {
619                             out.println(&quot;350 File or directory exists, ready for destination name.&quot;);
620                         } else {
621                             out.println(&quot;550 &quot; + renameFrom + &quot;: no such file or directory&quot;);
622                             renameFrom = null;
623                         }
624                     }
625                     break;
626                 case RNTO:
627                     if (checkLogged()) {
628                         if (renameFrom == null) {
629                             out.println(&quot;503 Bad sequence of commands.&quot;);
630                             break;
631                         }
632                         if (fsh.rename(renameFrom, buf.toString())) {
633                             out.println(&quot;250 Rename successful&quot;);
634                         } else {
635                             out.println(&quot;550 Rename &quot;);
636                         }
637                         renameFrom = null;
638                     }
639                     break;
640                 case REST:
641                     if (checkLogged()) {
642                         String arg = buf.toString();
643                         restart = Long.parseLong(arg);
644                         if (restart &gt; 0)
645                             out.println(&quot;350 Restarting at &quot; + restart + &quot;. Send STORE or RETRIEVE to initiate transfer&quot;);
646                         else
647                             out.println(&quot;501 Syntax error in command of arguments.&quot;);
648                     }
649                     break;
650                 case FEAT:
651                     out.println(&quot;211-Features:&quot;);
652                     out.println(&quot; REST STREAM&quot;);
653                     out.println(&quot; PBSZ&quot;);
654                     out.println(&quot; AUTH TLS&quot;);
655                     out.println(&quot; PROT P&quot;);
656                     out.println(&quot; CCC&quot;);
657                     out.println(&quot;211 End&quot;);
658                     break;
659                 case AUTH:
660                     if (&quot;TLS&quot;.equalsIgnoreCase(buf.toString()) &amp;&amp; useTLS()) {
661                         out.println(&quot;234 TLS Authentication OK.&quot;);
662                         out.flush();
663                         SSLSocket ssl;
664                         String[] suites = sslFact.getSupportedCipherSuites();
665                         try {
666                             ssl = (SSLSocket) sslFact.createSocket(cmd, cmd.getInetAddress().getHostName(), cmd.getPort(), false);
667                             ssl.setUseClientMode(false);
668                             ssl.setEnabledCipherSuites(suites);
669                             ssl.startHandshake();
670                         } catch (IOException ioe) {
671                             ioe.printStackTrace();
672                             out.println(&quot;550 Unable to create secure channel.&quot;);
673                             break;
674                         }
675                         oldCmd = cmd;
676                         cmd = ssl;
677                         out = new PrintStream(cmd.getOutputStream(), true, &quot;ISO8859_1&quot;);
678                         in = new BufferedReader(new InputStreamReader(cmd.getInputStream()));
679                         System.out.println(&quot;Secure socket created!&quot;);
680                         useCrypto = true;
681                         break;
682                     }
683                     out.println(&quot;501 Unknown or unsupported AUTH type&quot;);
684                     break;
685                 case CCC:
686                     out.println(&quot;200 Command OK.&quot;);
687                     stopTLS();
688                     break;
689                 case PROT:
690                     String arg = buf.toString();
691                     if (&quot;C&quot;.equalsIgnoreCase(arg)) {
692                         // PROT C : Clear protection level
693                         // No protection on data channel;
694                         useDataCrypto = false;
695                         out.println(&quot;200 Command OK.&quot;);
696                         break;
697                     }
698                     if (&quot;P&quot;.equalsIgnoreCase(arg)) {
699                         // PROT P : Private protection level
700                         // Data channel is integrity and confidentiality protected
701                         useDataCrypto = true;
702                         out.println(&quot;200 Command OK.&quot;);
703                         break;
704                     }
705                     out.println(&quot;537 Requested PROT level not supported by security mechanism.&quot;);
706                     break;
707                 case PBSZ:
708                     // TODO: finish
709                     out.println(&quot;200 Command OK.&quot;);
710                     break;
711 
712                 }
713 
714             } catch (InterruptedIOException ie) {
715                 // loop
716             } catch (IOException e) {
717                 e.printStackTrace();
718                 return;
719             }
720         }
721         try {
722             in.close();
723             out.close();
724             cmd.close();
725         } catch (IOException e) {
726         }
727         parent.removeClient(this);
728     }
729 }
<a name="6" id="anc6"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="6" type="hidden" />
</body>
</html>
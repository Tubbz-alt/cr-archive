<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames test/jdk/sun/net/www/protocol/http/ProxyTunnelServer.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
<a name="1" id="anc1"></a><span class="line-modified">  2  * Copyright (c) 2002, 2013, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 /**
 25  *
 26  * This class includes a proxy server that processes HTTP CONNECT requests,
 27  * and tunnels the data from the client to the server, once the CONNECT
 28  * request is accepted.
 29  * It is used by the TunnelThroughProxy test.
 30  */
 31 
 32 import java.io.*;
 33 import java.net.*;
 34 import java.util.Base64;
 35 import javax.net.ssl.*;
 36 import javax.net.ServerSocketFactory;
 37 import sun.net.www.*;
 38 
 39 public class ProxyTunnelServer extends Thread {
 40 
 41     private final ServerSocket ss;
 42     /*
 43      * holds the registered user&#39;s username and password
 44      * only one such entry is maintained
 45      */
 46     private volatile String userPlusPass;
 47 
 48     // client requesting for a tunnel
 49     private volatile Socket clientSocket = null;
 50 
 51     /*
 52      * Origin server&#39;s address and port that the client
 53      * wants to establish the tunnel for communication.
 54      */
 55     private volatile InetAddress serverInetAddr;
 56     private volatile int serverPort;
 57 
 58     /*
 59      * denote whether the proxy needs to authorize
 60      * CONNECT requests.
 61      */
 62 
 63     volatile boolean needAuth = false;
 64 
 65     public ProxyTunnelServer() throws IOException {
 66         ss = new ServerSocket(0);
 67     }
 68 
<a name="2" id="anc2"></a>



 69     static private void close(Closeable c) {
 70         try {
 71             if (c != null)
 72                 c.close();
 73         } catch (IOException e) {
 74             e.printStackTrace();
 75         }
 76     }
 77 
 78     public void needUserAuth(boolean auth) {
 79         needAuth = auth;
 80     }
 81 
 82     public void terminate() {
 83         close(ss);
 84         close(clientSocket);
 85     }
 86 
 87     /*
 88      * register users with the proxy, by providing username and
 89      * password. The username and password are used for authorizing the
 90      * user when a CONNECT request is made and needAuth is set to true.
 91      */
 92     public void setUserAuth(String uname, String passwd) {
 93         userPlusPass = uname + &quot;:&quot; + passwd;
 94     }
 95 
 96     volatile boolean makeTunnel;
 97 
 98     public void doTunnel(boolean tunnel) {
 99         makeTunnel = tunnel;
100     }
101 
102     public void run() {
103         try {
104             clientSocket = ss.accept();
105             processRequests(makeTunnel);
106         } catch (Exception e) {
107             System.out.println(&quot;Proxy Failed: &quot; + e);
108             e.printStackTrace();
109             try {
110                 ss.close();
111             }
112             catch (IOException excep) {
113                 System.out.println(&quot;ProxyServer close error: &quot; + excep);
114                 excep.printStackTrace();
115             }
116           }
117     }
118 
119     /*
120      * Processes the CONNECT requests, if needAuth is set to true, then
121      * the name and password are extracted from the Proxy-Authorization header
122      * of the request. They are checked against the one that is registered,
123      * if there is a match, connection is set in tunneling mode. If
124      * needAuth is set to false, Proxy-Authorization checks are not made
125      */
126     private void processRequests(boolean makeTunnel) throws Exception {
<a name="3" id="anc3"></a><span class="line-removed">127 </span>
128         InputStream in = clientSocket.getInputStream();
129         MessageHeader mheader = new MessageHeader(in);
130         String statusLine = mheader.getValue(0);
131 
<a name="4" id="anc4"></a>

132         if (statusLine.startsWith(&quot;CONNECT&quot;)) {
133             // retrieve the host and port info from the status-line
134             // retrieveConnectInfo(statusLine);
135             if (needAuth) {
136                 String authInfo;
137                 if ((authInfo = mheader.findValue(&quot;Proxy-Authorization&quot;))
138                                          != null) {
139                    if (authenticate(authInfo)) {
140                         needAuth = false;
141                         System.out.println(
142                                 &quot;Proxy: client authentication successful&quot;);
143                    }
144                 }
145             }
146 
147             if (makeTunnel) {
148                 retrieveConnectInfo(statusLine);
149                 doTunnel();
150                 return;
151             }
152 
153             respondForConnect(needAuth);
154 
155             // connection set to the tunneling mode
156             if (!needAuth) {
157                 // doTunnel();
158                 /*
159                  * done with tunneling, we process only one successful
160                  * tunneling request
161                  */
162                 ss.close();
163             } else {
164                 // we may get another request with Proxy-Authorization set
165                 in.close();
166                 clientSocket.close();
167                 restart();
168             }
169         } else {
170             System.out.println(&quot;proxy server: processes only &quot;
171                                    + &quot;CONNECT method requests, recieved: &quot;
172                                    + statusLine);
173         }
174     }
175 
176     private void respondForConnect(boolean needAuth) throws Exception {
177 
178         OutputStream out = clientSocket.getOutputStream();
179         PrintWriter pout = new PrintWriter(out);
180 
181         if (needAuth) {
182             pout.println(&quot;HTTP/1.1 407 Proxy Auth Required&quot;);
183             pout.println(&quot;Proxy-Authenticate: Basic realm=\&quot;WallyWorld\&quot;&quot;);
184             pout.println();
185             pout.flush();
186             out.close();
187         } else {
188             pout.println(&quot;HTTP/1.1 500 Server Error&quot;);
189             pout.println();
190             pout.flush();
191             out.close();
192         }
193     }
194 
195     private void restart() throws IOException {
196          (new Thread(this)).start();
197     }
198 
199     /*sc
200      * note: Tunneling has to be provided in both directions, i.e
201      * from client-&gt;server and server-&gt;client, even if the application
202      * data may be unidirectional, SSL handshaking data flows in either
203      * direction.
204      */
205     private void doTunnel() throws Exception {
206         OutputStream out = clientSocket.getOutputStream();
207         out.write(&quot;HTTP/1.1 200 OK\r\n\r\n&quot;.getBytes());
208         out.flush();
209 
210         Socket serverSocket = new Socket(serverInetAddr, serverPort);
211         ProxyTunnel clientToServer = new ProxyTunnel(
212                                 clientSocket, serverSocket);
213         ProxyTunnel serverToClient = new ProxyTunnel(
214                                 serverSocket, clientSocket);
215         clientToServer.start();
216         serverToClient.start();
217         System.out.println(&quot;Proxy: Started tunneling.......&quot;);
218 
219         clientToServer.join();
220         serverToClient.join();
221         System.out.println(&quot;Proxy: Finished tunneling........&quot;);
222 
223         clientToServer.close();
224         serverToClient.close();
225     }
226 
227     /*
228      * This inner class provides unidirectional data flow through the sockets
229      * by continuously copying bytes from the input socket onto the output
230      * socket, until both sockets are open and EOF has not been received.
231      */
232     class ProxyTunnel extends Thread {
233         final Socket sockIn;
234         final Socket sockOut;
235         final InputStream input;
236         final OutputStream output;
237 
238         public ProxyTunnel(Socket sockIn, Socket sockOut)
239         throws Exception {
240             this.sockIn = sockIn;
241             this.sockOut = sockOut;
242             input = sockIn.getInputStream();
243             output = sockOut.getOutputStream();
244         }
245 
246         public void run() {
247             int BUFFER_SIZE = 400;
248             byte[] buf = new byte[BUFFER_SIZE];
249             int bytesRead = 0;
250             int count = 0;  // keep track of the amount of data transfer
251 
252             try {
253                 while ((bytesRead = input.read(buf)) &gt;= 0) {
254                     output.write(buf, 0, bytesRead);
255                     output.flush();
256                     count += bytesRead;
257                 }
258             } catch (IOException e) {
259                 /*
260                  * The peer end has closed the connection
261                  * we will close the tunnel
262                  */
263                 close();
264               }
265         }
266 
267         public void close() {
268             try {
269                 if (!sockIn.isClosed())
270                     sockIn.close();
271                 if (!sockOut.isClosed())
272                     sockOut.close();
273             } catch (IOException ignored) { }
274         }
275     }
276 
277     /*
278      ***************************************************************
279      *                  helper methods follow
280      ***************************************************************
281      */
282 
283     /*
284      * This method retrieves the hostname and port of the destination
285      * that the connect request wants to establish a tunnel for
286      * communication.
287      * The input, connectStr is of the form:
288      *                          CONNECT server-name:server-port HTTP/1.x
289      */
290     private void retrieveConnectInfo(String connectStr) throws Exception {
291         int starti;
292         int endi;
293         String connectInfo;
294         String serverName = null;
295         try {
296             starti = connectStr.indexOf(&#39; &#39;);
297             endi = connectStr.lastIndexOf(&#39; &#39;);
298             connectInfo = connectStr.substring(starti+1, endi).trim();
299             // retrieve server name and port
300             endi = connectInfo.indexOf(&#39;:&#39;);
301             serverName = connectInfo.substring(0, endi);
302             serverPort = Integer.parseInt(connectInfo.substring(endi+1));
303         } catch (Exception e) {
304             throw new IOException(&quot;Proxy recieved a request: &quot;
305                                         + connectStr);
306           }
307         serverInetAddr = InetAddress.getByName(serverName);
308     }
309 
310     public int getPort() {
311         return ss.getLocalPort();
312     }
313 
<a name="5" id="anc5"></a>



314     /*
315      * do &quot;basic&quot; authentication, authInfo is of the form:
316      *                                  Basic &lt;encoded username&quot;:&quot;password&gt;
317      * reference RFC 2617
318      */
319     private boolean authenticate(String authInfo) throws IOException {
320         boolean matched = false;
321         try {
322             authInfo.trim();
323             int ind = authInfo.indexOf(&#39; &#39;);
324             String recvdUserPlusPass = authInfo.substring(ind + 1).trim();
325             // extract encoded (username:passwd
326             if (userPlusPass.equals(
327                                 new String(Base64.getDecoder().decode(recvdUserPlusPass))
328                                 )) {
329                 matched = true;
330             }
331         } catch (Exception e) {
332               throw new IOException(
333                 &quot;Proxy received invalid Proxy-Authorization value: &quot;
334                  + authInfo);
335           }
336         return matched;
337     }
338 }
<a name="6" id="anc6"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="6" type="hidden" />
</body>
</html>
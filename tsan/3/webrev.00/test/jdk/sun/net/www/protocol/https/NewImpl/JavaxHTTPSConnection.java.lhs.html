<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames test/jdk/sun/net/www/protocol/https/NewImpl/JavaxHTTPSConnection.java</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
<a name="1" id="anc1"></a><span class="line-modified">  2  * Copyright (c) 2001, 2011, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 /*
 25  * @test
 26  * @bug 4474255
 27  * @summary Can no longer obtain a com.sun.net.ssl.HttpsURLConnection
<a name="2" id="anc2"></a>
 28  * @run main/othervm JavaxHTTPSConnection
<a name="3" id="anc3"></a>
 29  *
 30  *     SunJSSE does not support dynamic system properties, no way to re-use
 31  *     system properties in samevm/agentvm mode.
 32  * @author Brad Wetmore
 33  */
 34 
 35 import java.io.*;
 36 import java.net.*;
 37 import java.security.cert.*;
 38 import javax.net.ssl.*;
<a name="4" id="anc4"></a>
 39 
 40 /**
 41  * See if we can obtain a javax.net.ssl.HttpsURLConnection,
 42  * and then play with it a bit.
 43  */
 44 public class JavaxHTTPSConnection {
 45 
 46     /*
 47      * =============================================================
 48      * Set the various variables needed for the tests, then
 49      * specify what tests to run on each side.
 50      */
 51 
 52     /*
 53      * Should we run the client or server in a separate thread?
 54      * Both sides can throw exceptions, but do you have a preference
 55      * as to which side should be the main thread.
 56      */
 57     static boolean separateServerThread = true;
 58 
 59     /*
 60      * Where do we find the keystores?
 61      */
 62     static String pathToStores = &quot;../../../../../../javax/net/ssl/etc&quot;;
 63     static String keyStoreFile = &quot;keystore&quot;;
 64     static String trustStoreFile = &quot;truststore&quot;;
 65     static String passwd = &quot;passphrase&quot;;
 66 
 67     /*
 68      * Is the server ready to serve?
 69      */
 70     volatile static boolean serverReady = false;
 71 
 72     /*
 73      * Turn on SSL debugging?
 74      */
 75     static boolean debug = false;
 76 
 77     /*
 78      * If the client or server is doing some kind of object creation
 79      * that the other side depends on, and that thread prematurely
 80      * exits, you may experience a hang.  The test harness will
 81      * terminate all hung threads after its timeout has expired,
 82      * currently 3 minutes by default, but you might try to be
 83      * smart about it....
 84      */
 85 
 86     /**
 87      * Returns the path to the file obtained from
 88      * parsing the HTML header.
 89      */
 90     private static String getPath(DataInputStream in)
 91         throws IOException
 92     {
 93         String line = in.readLine();
 94         String path = &quot;&quot;;
 95         // extract class from GET line
 96         if (line.startsWith(&quot;GET /&quot;)) {
 97             line = line.substring(5, line.length()-1).trim();
 98             int index = line.indexOf(&#39; &#39;);
 99             if (index != -1) {
100                 path = line.substring(0, index);
101             }
102         }
103 
104         // eat the rest of header
105         do {
106             line = in.readLine();
107         } while ((line.length() != 0) &amp;&amp;
108                  (line.charAt(0) != &#39;\r&#39;) &amp;&amp; (line.charAt(0) != &#39;\n&#39;));
109 
110         if (path.length() != 0) {
111             return path;
112         } else {
113             throw new IOException(&quot;Malformed Header&quot;);
114         }
115     }
116 
117     /**
118      * Returns an array of bytes containing the bytes for
119      * the file represented by the argument &lt;b&gt;path&lt;/b&gt;.
120      *
121      * In our case, we just pretend to send something back.
122      *
123      * @return the bytes for the file
124      * @exception FileNotFoundException if the file corresponding
125      * to &lt;b&gt;path&lt;/b&gt; could not be loaded.
126      */
127     private byte[] getBytes(String path)
128         throws IOException
129     {
130         return &quot;Hello world, I am here&quot;.getBytes();
131     }
132 
133     /*
134      * Define the server side of the test.
135      *
136      * If the server prematurely exits, serverReady will be set to true
137      * to avoid infinite hangs.
138      */
139     void doServerSide() throws Exception {
140 
<a name="5" id="anc5"></a>

141         SSLServerSocketFactory sslssf =
142           (SSLServerSocketFactory) SSLServerSocketFactory.getDefault();
143         SSLServerSocket sslServerSocket =
<a name="6" id="anc6"></a><span class="line-modified">144             (SSLServerSocket) sslssf.createServerSocket(serverPort);</span>

145         serverPort = sslServerSocket.getLocalPort();
146 
147         /*
148          * Signal Client, we&#39;re ready for his connect.
149          */
150         serverReady = true;
151 
152         SSLSocket sslSocket = (SSLSocket) sslServerSocket.accept();
153         DataOutputStream out =
154                 new DataOutputStream(sslSocket.getOutputStream());
155 
156         try {
157              // get path to class file from header
158              DataInputStream in =
159                         new DataInputStream(sslSocket.getInputStream());
160              String path = getPath(in);
161              // retrieve bytecodes
162              byte[] bytecodes = getBytes(path);
163              // send bytecodes in response (assumes HTTP/1.0 or later)
164              try {
165                 out.writeBytes(&quot;HTTP/1.0 200 OK\r\n&quot;);
166                 out.writeBytes(&quot;Content-Length: &quot; + bytecodes.length + &quot;\r\n&quot;);
167                 out.writeBytes(&quot;Content-Type: text/html\r\n\r\n&quot;);
168                 out.write(bytecodes);
169                 out.flush();
170              } catch (IOException ie) {
171                 ie.printStackTrace();
172                 return;
173              }
174 
175         } catch (Exception e) {
176              e.printStackTrace();
177              // write out error response
178              out.writeBytes(&quot;HTTP/1.0 400 &quot; + e.getMessage() + &quot;\r\n&quot;);
179              out.writeBytes(&quot;Content-Type: text/html\r\n\r\n&quot;);
180              out.flush();
181         } finally {
182              // close the socket
183              System.out.println(&quot;Server closing socket&quot;);
184              sslSocket.close();
185              serverReady = false;
186         }
187     }
188 
189     /*
190      * Define the client side of the test.
191      *
192      * If the server prematurely exits, serverReady will be set to true
193      * to avoid infinite hangs.
194      */
195     void doClientSide() throws Exception {
196         HostnameVerifier reservedHV =
197             HttpsURLConnection.getDefaultHostnameVerifier();
198         try {
199             /*
200              * Wait for server to get started.
201              */
202             while (!serverReady) {
203                 Thread.sleep(50);
204             }
205 
206             HttpsURLConnection.setDefaultHostnameVerifier(new NameVerifier());
<a name="7" id="anc7"></a><span class="line-modified">207             URL url = new URL(&quot;https://&quot; + &quot;localhost:&quot; + serverPort +</span>
<span class="line-modified">208                                     &quot;/etc/hosts&quot;);</span>
<span class="line-modified">209             URLConnection urlc = url.openConnection();</span>





210 
211             if (!(urlc instanceof javax.net.ssl.HttpsURLConnection)) {
212                 throw new Exception(&quot;URLConnection ! instanceof &quot; +
213                                     &quot;javax.net.ssl.HttpsURLConnection&quot;);
214             }
215 
216             BufferedReader in = null;
217             try {
218                 in = new BufferedReader(new InputStreamReader(
219                                    urlc.getInputStream()));
220                 String inputLine;
221                 System.out.print(&quot;Client reading... &quot;);
222                 while ((inputLine = in.readLine()) != null)
223                     System.out.println(inputLine);
224 
225                 System.out.println(&quot;Cipher Suite: &quot; +
226                     ((HttpsURLConnection)urlc).getCipherSuite());
227                 Certificate[] certs =
228                     ((HttpsURLConnection)urlc).getServerCertificates();
229                 for (int i = 0; i &lt; certs.length; i++) {
230                     System.out.println(certs[0]);
231                 }
232 
233                 in.close();
234             } catch (SSLException e) {
235                 if (in != null)
236                     in.close();
237                 throw e;
238             }
239             System.out.println(&quot;Client reports:  SUCCESS&quot;);
240         } finally {
241             HttpsURLConnection.setDefaultHostnameVerifier(reservedHV);
242         }
243     }
244 
245     static class NameVerifier implements HostnameVerifier {
246         public boolean verify(String hostname, SSLSession session) {
247             System.out.println(
248                 &quot;HostnameVerifier: returning true&quot;);
249             return true;
250         }
251     }
252 
253     /*
254      * =============================================================
255      * The remainder is just support stuff
256      */
257 
258     // use any free port by default
259     volatile int serverPort = 0;
260 
261     volatile Exception serverException = null;
262     volatile Exception clientException = null;
263 
264     public static void main(String[] args) throws Exception {
265         String keyFilename =
266             System.getProperty(&quot;test.src&quot;, &quot;./&quot;) + &quot;/&quot; + pathToStores +
267                 &quot;/&quot; + keyStoreFile;
268         String trustFilename =
269             System.getProperty(&quot;test.src&quot;, &quot;./&quot;) + &quot;/&quot; + pathToStores +
270                 &quot;/&quot; + trustStoreFile;
271 
272         System.setProperty(&quot;javax.net.ssl.keyStore&quot;, keyFilename);
273         System.setProperty(&quot;javax.net.ssl.keyStorePassword&quot;, passwd);
274         System.setProperty(&quot;javax.net.ssl.trustStore&quot;, trustFilename);
275         System.setProperty(&quot;javax.net.ssl.trustStorePassword&quot;, passwd);
276 
277         if (debug)
278             System.setProperty(&quot;javax.net.debug&quot;, &quot;all&quot;);
279 
280         /*
281          * Start the tests.
282          */
283         new JavaxHTTPSConnection();
284     }
285 
286     Thread clientThread = null;
287     Thread serverThread = null;
288 
289     /*
290      * Primary constructor, used to drive remainder of the test.
291      *
292      * Fork off the other side, then do your work.
293      */
294     JavaxHTTPSConnection() throws Exception {
295         if (separateServerThread) {
296             startServer(true);
297             startClient(false);
298         } else {
299             startClient(true);
300             startServer(false);
301         }
302 
303         /*
304          * Wait for other side to close down.
305          */
306         if (separateServerThread) {
307             serverThread.join();
308         } else {
309             clientThread.join();
310         }
311 
312         /*
313          * When we get here, the test is pretty much over.
314          *
315          * If the main thread excepted, that propagates back
316          * immediately.  If the other thread threw an exception, we
317          * should report back.
318          */
319         if (serverException != null) {
320             System.out.print(&quot;Server Exception:&quot;);
321             throw serverException;
322         }
323         if (clientException != null) {
324             System.out.print(&quot;Client Exception:&quot;);
325             throw clientException;
326         }
327     }
328 
329     void startServer(boolean newThread) throws Exception {
330         if (newThread) {
331             serverThread = new Thread() {
332                 public void run() {
333                     try {
334                         doServerSide();
335                     } catch (Exception e) {
336                         /*
337                          * Our server thread just died.
338                          *
339                          * Release the client, if not active already...
340                          */
341                         System.err.println(&quot;Server died...&quot;);
342                         serverReady = true;
343                         serverException = e;
344                     }
345                 }
346             };
347             serverThread.start();
348         } else {
349             doServerSide();
350         }
351     }
352 
353     void startClient(boolean newThread) throws Exception {
354         if (newThread) {
355             clientThread = new Thread() {
356                 public void run() {
357                     try {
358                         doClientSide();
359                     } catch (Exception e) {
360                         /*
361                          * Our client thread just died.
362                          */
363                         System.err.println(&quot;Client died...&quot;);
364                         clientException = e;
365                     }
366                 }
367             };
368             clientThread.start();
369         } else {
370             doClientSide();
371         }
372     }
373 }
<a name="8" id="anc8"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="8" type="hidden" />
</body>
</html>
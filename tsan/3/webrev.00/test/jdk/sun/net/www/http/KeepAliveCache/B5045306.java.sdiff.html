<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff test/jdk/sun/net/www/http/KeepAliveCache/B5045306.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
<body>
<center><a href="../HttpURLConnection/PostOnDelete.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="KeepAliveTimerThread.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>test/jdk/sun/net/www/http/KeepAliveCache/B5045306.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2005, 2012, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
</pre>
<hr />
<pre>
 45  * first call then that means that the connection is being reused.
 46  *
 47  * Part 2:
 48  * Test buggy webserver that sends less data than it specifies in its
 49  * Content-length header.
 50  */
 51 
 52 public class B5045306
 53 {
 54     static SimpleHttpTransaction httpTrans;
 55     static TestHttpServer server;
 56 
 57     public static void main(String[] args) throws Exception {
 58         startHttpServer();
 59         clientHttpCalls();
 60     }
 61 
 62     public static void startHttpServer() {
 63         try {
 64             httpTrans = new SimpleHttpTransaction();
<span class="line-modified"> 65             server = new TestHttpServer(httpTrans, 1, 10, 0);</span>
 66         } catch (IOException e) {
 67             e.printStackTrace();
 68         }
 69     }
 70 
 71     public static void clientHttpCalls() {
 72         try {
 73             System.out.println(&quot;http server listen on: &quot; + server.getLocalPort());
<span class="line-modified"> 74             String baseURLStr = &quot;http://&quot; + InetAddress.getLocalHost().getHostAddress() + &quot;:&quot; +</span>
<span class="line-modified"> 75                                   server.getLocalPort() + &quot;/&quot;;</span>

 76 
 77             URL bigDataURL = new URL (baseURLStr + &quot;firstCall&quot;);
 78             URL smallDataURL = new URL (baseURLStr + &quot;secondCall&quot;);
 79 
<span class="line-modified"> 80             HttpURLConnection uc = (HttpURLConnection)bigDataURL.openConnection();</span>
 81 
 82             //Only read 1 byte of response data and close the stream
 83             InputStream is = uc.getInputStream();
 84             byte[] ba = new byte[1];
 85             is.read(ba);
 86             is.close();
 87 
 88             // Allow the KeepAliveStreamCleaner thread to read the data left behind and cache the connection.
 89             try { Thread.sleep(2000); } catch (Exception e) {}
 90 
<span class="line-modified"> 91             uc = (HttpURLConnection)smallDataURL.openConnection();</span>
 92             uc.getResponseCode();
 93 
 94             if (SimpleHttpTransaction.failed)
 95                 throw new RuntimeException(&quot;Failed: Initial Keep Alive Connection is not being reused&quot;);
 96 
 97             // Part 2
 98             URL part2Url = new URL (baseURLStr + &quot;part2&quot;);
<span class="line-modified"> 99             uc = (HttpURLConnection)part2Url.openConnection();</span>
100             is = uc.getInputStream();
101             is.close();
102 
103             // Allow the KeepAliveStreamCleaner thread to try and read the data left behind and cache the connection.
104             try { Thread.sleep(2000); } catch (Exception e) {}
105 
106             ThreadMXBean threadMXBean = ManagementFactory.getThreadMXBean();
107             if (threadMXBean.isThreadCpuTimeSupported()) {
108                 long[] threads = threadMXBean.getAllThreadIds();
109                 ThreadInfo[] threadInfo = threadMXBean.getThreadInfo(threads);
110                 for (int i=0; i&lt;threadInfo.length; i++) {
111                     if (threadInfo[i].getThreadName().equals(&quot;Keep-Alive-SocketCleaner&quot;))  {
112                         System.out.println(&quot;Found Keep-Alive-SocketCleaner thread&quot;);
113                         long threadID = threadInfo[i].getThreadId();
114                         long before = threadMXBean.getThreadCpuTime(threadID);
115                         try { Thread.sleep(2000); } catch (Exception e) {}
116                         long after = threadMXBean.getThreadCpuTime(threadID);
117 
118                         if (before ==-1 || after == -1)
119                             break;  // thread has died, OK
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2005, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
</pre>
<hr />
<pre>
 45  * first call then that means that the connection is being reused.
 46  *
 47  * Part 2:
 48  * Test buggy webserver that sends less data than it specifies in its
 49  * Content-length header.
 50  */
 51 
 52 public class B5045306
 53 {
 54     static SimpleHttpTransaction httpTrans;
 55     static TestHttpServer server;
 56 
 57     public static void main(String[] args) throws Exception {
 58         startHttpServer();
 59         clientHttpCalls();
 60     }
 61 
 62     public static void startHttpServer() {
 63         try {
 64             httpTrans = new SimpleHttpTransaction();
<span class="line-modified"> 65             server = new TestHttpServer(httpTrans, 1, 10, InetAddress.getLocalHost(), 0);</span>
 66         } catch (IOException e) {
 67             e.printStackTrace();
 68         }
 69     }
 70 
 71     public static void clientHttpCalls() {
 72         try {
 73             System.out.println(&quot;http server listen on: &quot; + server.getLocalPort());
<span class="line-modified"> 74             String hostAddr =  InetAddress.getLocalHost().getHostAddress();</span>
<span class="line-modified"> 75             if (hostAddr.indexOf(&#39;:&#39;) &gt; -1) hostAddr = &quot;[&quot; + hostAddr + &quot;]&quot;;</span>
<span class="line-added"> 76             String baseURLStr = &quot;http://&quot; + hostAddr + &quot;:&quot; + server.getLocalPort() + &quot;/&quot;;</span>
 77 
 78             URL bigDataURL = new URL (baseURLStr + &quot;firstCall&quot;);
 79             URL smallDataURL = new URL (baseURLStr + &quot;secondCall&quot;);
 80 
<span class="line-modified"> 81             HttpURLConnection uc = (HttpURLConnection)bigDataURL.openConnection(Proxy.NO_PROXY);</span>
 82 
 83             //Only read 1 byte of response data and close the stream
 84             InputStream is = uc.getInputStream();
 85             byte[] ba = new byte[1];
 86             is.read(ba);
 87             is.close();
 88 
 89             // Allow the KeepAliveStreamCleaner thread to read the data left behind and cache the connection.
 90             try { Thread.sleep(2000); } catch (Exception e) {}
 91 
<span class="line-modified"> 92             uc = (HttpURLConnection)smallDataURL.openConnection(Proxy.NO_PROXY);</span>
 93             uc.getResponseCode();
 94 
 95             if (SimpleHttpTransaction.failed)
 96                 throw new RuntimeException(&quot;Failed: Initial Keep Alive Connection is not being reused&quot;);
 97 
 98             // Part 2
 99             URL part2Url = new URL (baseURLStr + &quot;part2&quot;);
<span class="line-modified">100             uc = (HttpURLConnection)part2Url.openConnection(Proxy.NO_PROXY);</span>
101             is = uc.getInputStream();
102             is.close();
103 
104             // Allow the KeepAliveStreamCleaner thread to try and read the data left behind and cache the connection.
105             try { Thread.sleep(2000); } catch (Exception e) {}
106 
107             ThreadMXBean threadMXBean = ManagementFactory.getThreadMXBean();
108             if (threadMXBean.isThreadCpuTimeSupported()) {
109                 long[] threads = threadMXBean.getAllThreadIds();
110                 ThreadInfo[] threadInfo = threadMXBean.getThreadInfo(threads);
111                 for (int i=0; i&lt;threadInfo.length; i++) {
112                     if (threadInfo[i].getThreadName().equals(&quot;Keep-Alive-SocketCleaner&quot;))  {
113                         System.out.println(&quot;Found Keep-Alive-SocketCleaner thread&quot;);
114                         long threadID = threadInfo[i].getThreadId();
115                         long before = threadMXBean.getThreadCpuTime(threadID);
116                         try { Thread.sleep(2000); } catch (Exception e) {}
117                         long after = threadMXBean.getThreadCpuTime(threadID);
118 
119                         if (before ==-1 || after == -1)
120                             break;  // thread has died, OK
</pre>
</td>
</tr>
</table>
<center><a href="../HttpURLConnection/PostOnDelete.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="KeepAliveTimerThread.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
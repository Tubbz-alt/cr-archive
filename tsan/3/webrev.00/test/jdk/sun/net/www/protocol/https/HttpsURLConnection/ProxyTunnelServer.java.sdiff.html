<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff test/jdk/sun/net/www/protocol/https/HttpsURLConnection/ProxyTunnelServer.java</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="PostThruProxyWithAuth.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="ReadTimeout.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>test/jdk/sun/net/www/protocol/https/HttpsURLConnection/ProxyTunnelServer.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2001, 2016, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
</pre>
<hr />
<pre>
 46      * only one such entry is maintained
 47      */
 48     private String userPlusPass;
 49 
 50     // client requesting for a tunnel
 51     private Socket clientSocket = null;
 52 
 53     /*
 54      * Origin server&#39;s address and port that the client
 55      * wants to establish the tunnel for communication.
 56      */
 57     private InetAddress serverInetAddr;
 58     private int serverPort;
 59 
 60     /*
 61      * denote whether the proxy needs to authorize
 62      * CONNECT requests.
 63      */
 64     static boolean needAuth = false;
 65 


 66     public ProxyTunnelServer() throws IOException {
 67         if (ss == null) {
 68             ss = (ServerSocket) ServerSocketFactory.getDefault()
 69                     .createServerSocket(0);
 70             ss.setSoTimeout(TIMEOUT);










 71         }
 72     }
 73 
 74     public void needUserAuth(boolean auth) {
 75         needAuth = auth;
 76     }
 77 
 78     /*
 79      * register users with the proxy, by providing username and
 80      * password. The username and password are used for authorizing the
 81      * user when a CONNECT request is made and needAuth is set to true.
 82      */
 83     public void setUserAuth(String uname, String passwd) {
 84         userPlusPass = uname + &quot;:&quot; + passwd;
 85     }
 86 
 87     public void run() {
 88         try {

 89             clientSocket = ss.accept();

 90             processRequests();
 91         } catch (SocketTimeoutException e) {
 92             System.out.println(
 93                     &quot;Proxy can not get response in time: &quot; + e.getMessage());
 94         } catch (Exception e) {
 95             System.out.println(&quot;Proxy Failed: &quot; + e);
 96             e.printStackTrace();
 97             try {
 98                 ss.close();
 99             }
100             catch (IOException excep) {
101                 System.out.println(&quot;ProxyServer close error: &quot; + excep);
102                 excep.printStackTrace();
103             }
<span class="line-modified">104           }</span>


105     }
106 
107     /*
108      * Processes the CONNECT requests, if needAuth is set to true, then
109      * the name and password are extracted from the Proxy-Authorization header
110      * of the request. They are checked against the one that is registered,
111      * if there is a match, connection is set in tunneling mode. If
112      * needAuth is set to false, Proxy-Authorization checks are not made
113      */
114     private void processRequests() throws Exception {
115 
116         InputStream in = clientSocket.getInputStream();
117         MessageHeader mheader = new MessageHeader(in);
118         String statusLine = mheader.getValue(0);
119 
120         if (statusLine.startsWith(&quot;CONNECT&quot;)) {

121             // retrieve the host and port info from the status-line
122             retrieveConnectInfo(statusLine);
123             if (needAuth) {
124                 String authInfo;
125                 if ((authInfo = mheader.findValue(&quot;Proxy-Authorization&quot;))
126                                          != null) {
127                    if (authenticate(authInfo)) {
128                         needAuth = false;
129                         System.out.println(
130                                 &quot;Proxy: client authentication successful&quot;);
131                    }
132                 }
133             }
134             respondForConnect(needAuth);
135 
136             // connection set to the tunneling mode
137             if (!needAuth) {
138                 doTunnel();
139                 /*
140                  * done with tunneling, we process only one successful
141                  * tunneling request
142                  */
143                 ss.close();
144             } else {
145                 // we may get another request with Proxy-Authorization set
146                 in.close();
147                 clientSocket.close();
148                 restart();
149             }
150         } else {
151             System.out.println(&quot;proxy server: processes only &quot;
152                                    + &quot;CONNECT method requests, recieved: &quot;
153                                    + statusLine);
154         }
155     }
156 




157     private void respondForConnect(boolean needAuth) throws Exception {
158 
159         OutputStream out = clientSocket.getOutputStream();
160         PrintWriter pout = new PrintWriter(out);
161 
162         if (needAuth) {
163             pout.println(&quot;HTTP/1.1 407 Proxy Auth Required&quot;);
164             pout.println(&quot;Proxy-Authenticate: Basic realm=\&quot;WallyWorld\&quot;&quot;);
165             pout.println();
166             pout.flush();
167             out.close();
168         } else {
169             pout.println(&quot;HTTP/1.1 200 OK&quot;);
170             pout.println();
171             pout.flush();
172         }
173     }
174 
175     private void restart() throws IOException {
176          (new Thread(this)).start();
</pre>
<hr />
<pre>
256      */
257 
258     /*
259      * This method retrieves the hostname and port of the destination
260      * that the connect request wants to establish a tunnel for
261      * communication.
262      * The input, connectStr is of the form:
263      *                          CONNECT server-name:server-port HTTP/1.x
264      */
265     private void retrieveConnectInfo(String connectStr) throws Exception {
266 
267         int starti;
268         int endi;
269         String connectInfo;
270         String serverName = null;
271         try {
272             starti = connectStr.indexOf(&#39; &#39;);
273             endi = connectStr.lastIndexOf(&#39; &#39;);
274             connectInfo = connectStr.substring(starti+1, endi).trim();
275             // retrieve server name and port
<span class="line-modified">276             endi = connectInfo.indexOf(&#39;:&#39;);</span>
<span class="line-modified">277             serverName = connectInfo.substring(0, endi);</span>






278             serverPort = Integer.parseInt(connectInfo.substring(endi+1));
279         } catch (Exception e) {
280             throw new IOException(&quot;Proxy recieved a request: &quot;
281                                         + connectStr, e);
<span class="line-modified">282           }</span>
283         serverInetAddr = InetAddress.getByName(serverName);
284     }
285 
286     public int getPort() {
287         return ss.getLocalPort();
288     }
289 
290     /*
291      * do &quot;basic&quot; authentication, authInfo is of the form:
292      *                                  Basic &lt;encoded username&quot;:&quot;password&gt;
293      * reference RFC 2617
294      */
295     private boolean authenticate(String authInfo) throws IOException {
296         boolean matched = false;
297         try {
298             authInfo.trim();
299             int ind = authInfo.indexOf(&#39; &#39;);
300             String recvdUserPlusPass = authInfo.substring(ind + 1).trim();
301             // extract encoded (username:passwd
302             if (userPlusPass.equals(
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2001, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
</pre>
<hr />
<pre>
 46      * only one such entry is maintained
 47      */
 48     private String userPlusPass;
 49 
 50     // client requesting for a tunnel
 51     private Socket clientSocket = null;
 52 
 53     /*
 54      * Origin server&#39;s address and port that the client
 55      * wants to establish the tunnel for communication.
 56      */
 57     private InetAddress serverInetAddr;
 58     private int serverPort;
 59 
 60     /*
 61      * denote whether the proxy needs to authorize
 62      * CONNECT requests.
 63      */
 64     static boolean needAuth = false;
 65 
<span class="line-added"> 66     volatile long connectCount;</span>
<span class="line-added"> 67 </span>
 68     public ProxyTunnelServer() throws IOException {
 69         if (ss == null) {
 70             ss = (ServerSocket) ServerSocketFactory.getDefault()
 71                     .createServerSocket(0);
 72             ss.setSoTimeout(TIMEOUT);
<span class="line-added"> 73             System.out.println(&quot;Proxy server created: &quot; + ss);</span>
<span class="line-added"> 74         }</span>
<span class="line-added"> 75     }</span>
<span class="line-added"> 76 </span>
<span class="line-added"> 77     public ProxyTunnelServer(InetAddress address) throws IOException {</span>
<span class="line-added"> 78         if (ss == null) {</span>
<span class="line-added"> 79             ss = (ServerSocket) ServerSocketFactory.getDefault()</span>
<span class="line-added"> 80                     .createServerSocket(0, 0, address);</span>
<span class="line-added"> 81             ss.setSoTimeout(TIMEOUT);</span>
<span class="line-added"> 82             System.out.println(&quot;Proxy server created: &quot; + ss);</span>
 83         }
 84     }
 85 
 86     public void needUserAuth(boolean auth) {
 87         needAuth = auth;
 88     }
 89 
 90     /*
 91      * register users with the proxy, by providing username and
 92      * password. The username and password are used for authorizing the
 93      * user when a CONNECT request is made and needAuth is set to true.
 94      */
 95     public void setUserAuth(String uname, String passwd) {
 96         userPlusPass = uname + &quot;:&quot; + passwd;
 97     }
 98 
 99     public void run() {
100         try {
<span class="line-added">101             System.out.println(&quot;Proxy server listening at: &quot; + ss);</span>
102             clientSocket = ss.accept();
<span class="line-added">103             System.out.println(&quot;Proxy server accepted connection: &quot; + clientSocket);</span>
104             processRequests();
105         } catch (SocketTimeoutException e) {
106             System.out.println(
107                     &quot;Proxy can not get response in time: &quot; + e.getMessage());
108         } catch (Exception e) {
109             System.out.println(&quot;Proxy Failed: &quot; + e);
110             e.printStackTrace();
111             try {
112                 ss.close();
113             }
114             catch (IOException excep) {
115                 System.out.println(&quot;ProxyServer close error: &quot; + excep);
116                 excep.printStackTrace();
117             }
<span class="line-modified">118          } finally {</span>
<span class="line-added">119             System.out.println(&quot;Proxy server: request served&quot;);</span>
<span class="line-added">120          }</span>
121     }
122 
123     /*
124      * Processes the CONNECT requests, if needAuth is set to true, then
125      * the name and password are extracted from the Proxy-Authorization header
126      * of the request. They are checked against the one that is registered,
127      * if there is a match, connection is set in tunneling mode. If
128      * needAuth is set to false, Proxy-Authorization checks are not made
129      */
130     private void processRequests() throws Exception {
131 
132         InputStream in = clientSocket.getInputStream();
133         MessageHeader mheader = new MessageHeader(in);
134         String statusLine = mheader.getValue(0);
135 
136         if (statusLine.startsWith(&quot;CONNECT&quot;)) {
<span class="line-added">137             synchronized(this) { connectCount++; }</span>
138             // retrieve the host and port info from the status-line
139             retrieveConnectInfo(statusLine);
140             if (needAuth) {
141                 String authInfo;
142                 if ((authInfo = mheader.findValue(&quot;Proxy-Authorization&quot;))
143                                          != null) {
144                    if (authenticate(authInfo)) {
145                         needAuth = false;
146                         System.out.println(
147                                 &quot;Proxy: client authentication successful&quot;);
148                    }
149                 }
150             }
151             respondForConnect(needAuth);
152 
153             // connection set to the tunneling mode
154             if (!needAuth) {
155                 doTunnel();
156                 /*
157                  * done with tunneling, we process only one successful
158                  * tunneling request
159                  */
160                 ss.close();
161             } else {
162                 // we may get another request with Proxy-Authorization set
163                 in.close();
164                 clientSocket.close();
165                 restart();
166             }
167         } else {
168             System.out.println(&quot;proxy server: processes only &quot;
169                                    + &quot;CONNECT method requests, recieved: &quot;
170                                    + statusLine);
171         }
172     }
173 
<span class="line-added">174     public long getConnectCount() {</span>
<span class="line-added">175         return connectCount;</span>
<span class="line-added">176     }</span>
<span class="line-added">177 </span>
178     private void respondForConnect(boolean needAuth) throws Exception {
179 
180         OutputStream out = clientSocket.getOutputStream();
181         PrintWriter pout = new PrintWriter(out);
182 
183         if (needAuth) {
184             pout.println(&quot;HTTP/1.1 407 Proxy Auth Required&quot;);
185             pout.println(&quot;Proxy-Authenticate: Basic realm=\&quot;WallyWorld\&quot;&quot;);
186             pout.println();
187             pout.flush();
188             out.close();
189         } else {
190             pout.println(&quot;HTTP/1.1 200 OK&quot;);
191             pout.println();
192             pout.flush();
193         }
194     }
195 
196     private void restart() throws IOException {
197          (new Thread(this)).start();
</pre>
<hr />
<pre>
277      */
278 
279     /*
280      * This method retrieves the hostname and port of the destination
281      * that the connect request wants to establish a tunnel for
282      * communication.
283      * The input, connectStr is of the form:
284      *                          CONNECT server-name:server-port HTTP/1.x
285      */
286     private void retrieveConnectInfo(String connectStr) throws Exception {
287 
288         int starti;
289         int endi;
290         String connectInfo;
291         String serverName = null;
292         try {
293             starti = connectStr.indexOf(&#39; &#39;);
294             endi = connectStr.lastIndexOf(&#39; &#39;);
295             connectInfo = connectStr.substring(starti+1, endi).trim();
296             // retrieve server name and port
<span class="line-modified">297             if (connectInfo.charAt(0) == &#39;[&#39;) {</span>
<span class="line-modified">298                  endi = connectInfo.indexOf(&#39;]&#39;);</span>
<span class="line-added">299                  serverName = connectInfo.substring(1, endi++);</span>
<span class="line-added">300                  assert connectInfo.charAt(endi) == &#39;:&#39; : &quot;Expected [IPv6]:port&quot;;</span>
<span class="line-added">301             } else {</span>
<span class="line-added">302                  endi = connectInfo.indexOf(&#39;:&#39;);</span>
<span class="line-added">303                  serverName = connectInfo.substring(0, endi);</span>
<span class="line-added">304             }</span>
305             serverPort = Integer.parseInt(connectInfo.substring(endi+1));
306         } catch (Exception e) {
307             throw new IOException(&quot;Proxy recieved a request: &quot;
308                                         + connectStr, e);
<span class="line-modified">309         }</span>
310         serverInetAddr = InetAddress.getByName(serverName);
311     }
312 
313     public int getPort() {
314         return ss.getLocalPort();
315     }
316 
317     /*
318      * do &quot;basic&quot; authentication, authInfo is of the form:
319      *                                  Basic &lt;encoded username&quot;:&quot;password&gt;
320      * reference RFC 2617
321      */
322     private boolean authenticate(String authInfo) throws IOException {
323         boolean matched = false;
324         try {
325             authInfo.trim();
326             int ind = authInfo.indexOf(&#39; &#39;);
327             String recvdUserPlusPass = authInfo.substring(ind + 1).trim();
328             // extract encoded (username:passwd
329             if (userPlusPass.equals(
</pre>
</td>
</tr>
</table>
<center><a href="PostThruProxyWithAuth.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="ReadTimeout.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
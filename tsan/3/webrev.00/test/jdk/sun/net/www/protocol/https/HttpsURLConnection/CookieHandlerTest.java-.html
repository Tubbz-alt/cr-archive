<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old test/jdk/sun/net/www/protocol/https/HttpsURLConnection/CookieHandlerTest.java</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2003, 2011, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 /* @test
 25  * @bug 4696506 4942650
 26  * @summary Unit test for java.net.CookieHandler
 27  * @run main/othervm CookieHandlerTest
 28  *
 29  *     SunJSSE does not support dynamic system properties, no way to re-use
 30  *     system properties in samevm/agentvm mode.
 31  * @author Yingxian Wang
 32  */
 33 
 34 import java.net.*;
 35 import java.util.*;
 36 import java.io.*;
 37 import javax.net.ssl.*;
 38 
 39 public class CookieHandlerTest {
 40     static Map&lt;String,String&gt; cookies;
 41     ServerSocket ss;
 42 
 43     /*
 44      * =============================================================
 45      * Set the various variables needed for the tests, then
 46      * specify what tests to run on each side.
 47      */
 48 
 49     /*
 50      * Should we run the client or server in a separate thread?
 51      * Both sides can throw exceptions, but do you have a preference
 52      * as to which side should be the main thread.
 53      */
 54     static boolean separateServerThread = true;
 55 
 56     /*
 57      * Where do we find the keystores?
 58      */
 59     static String pathToStores = &quot;../../../../../../javax/net/ssl/etc&quot;;
 60     static String keyStoreFile = &quot;keystore&quot;;
 61     static String trustStoreFile = &quot;truststore&quot;;
 62     static String passwd = &quot;passphrase&quot;;
 63 
 64     /*
 65      * Is the server ready to serve?
 66      */
 67     volatile static boolean serverReady = false;
 68 
 69     /*
 70      * Turn on SSL debugging?
 71      */
 72     static boolean debug = false;
 73 
 74     /*
 75      * Define the server side of the test.
 76      *
 77      * If the server prematurely exits, serverReady will be set to true
 78      * to avoid infinite hangs.
 79      */
 80     void doServerSide() throws Exception {
 81         SSLServerSocketFactory sslssf =
 82             (SSLServerSocketFactory) SSLServerSocketFactory.getDefault();
 83         SSLServerSocket sslServerSocket =
 84             (SSLServerSocket) sslssf.createServerSocket(serverPort);
 85         serverPort = sslServerSocket.getLocalPort();
 86 
 87         /*
 88          * Signal Client, we&#39;re ready for his connect.
 89          */
 90         serverReady = true;
 91         SSLSocket sslSocket = null;
 92         try {
 93             sslSocket = (SSLSocket) sslServerSocket.accept();
 94 
 95             // check request contains &quot;Cookie&quot;
 96             InputStream is = sslSocket.getInputStream ();
 97             BufferedReader r = new BufferedReader(new InputStreamReader(is));
 98             boolean flag = false;
 99             String x;
100             while ((x=r.readLine()) != null) {
101                 if (x.length() ==0) {
102                     break;
103                 }
104                 String header = &quot;Cookie: &quot;;
105                 if (x.startsWith(header)) {
106                     if (x.equals(&quot;Cookie: &quot;+((String)cookies.get(&quot;Cookie&quot;)))) {
107                         flag = true;
108                     }
109                 }
110             }
111             if (!flag) {
112                 throw new RuntimeException(&quot;server should see cookie in request&quot;);
113             }
114 
115             PrintStream out = new PrintStream(
116                                  new BufferedOutputStream(
117                                     sslSocket.getOutputStream() ));
118 
119             /* send the header */
120             out.print(&quot;HTTP/1.1 200 OK\r\n&quot;);
121             out.print(&quot;Set-Cookie2: &quot;+((String)cookies.get(&quot;Set-Cookie2&quot;)+&quot;\r\n&quot;));
122             out.print(&quot;Content-Type: text/html; charset=iso-8859-1\r\n&quot;);
123             out.print(&quot;Connection: close\r\n&quot;);
124             out.print(&quot;\r\n&quot;);
125             out.print(&quot;&lt;HTML&gt;&quot;);
126             out.print(&quot;&lt;HEAD&gt;&lt;TITLE&gt;Testing cookie&lt;/TITLE&gt;&lt;/HEAD&gt;&quot;);
127             out.print(&quot;&lt;BODY&gt;OK.&lt;/BODY&gt;&quot;);
128             out.print(&quot;&lt;/HTML&gt;&quot;);
129             out.flush();
130 
131             sslSocket.close();
132             sslServerSocket.close();
133         } catch (Exception e) {
134             e.printStackTrace();
135         }
136     }
137 
138     /*
139      * Define the client side of the test.
140      *
141      * If the server prematurely exits, serverReady will be set to true
142      * to avoid infinite hangs.
143      */
144     void doClientSide() throws Exception {
145 
146         /*
147          * Wait for server to get started.
148          */
149         while (!serverReady) {
150             Thread.sleep(50);
151         }
152         HttpsURLConnection http = null;
153         /* establish http connection to server */
154         String uri = &quot;https://localhost:&quot; + +serverPort ;
155         URL url = new URL(uri);
156         HttpsURLConnection.setDefaultHostnameVerifier(new NameVerifier());
157         http = (HttpsURLConnection)url.openConnection();
158 
159         int respCode = http.getResponseCode();
160         http.disconnect();
161 
162     }
163 
164     static class NameVerifier implements HostnameVerifier {
165         public boolean verify(String hostname, SSLSession session) {
166             return true;
167         }
168     }
169 
170     /*
171      * =============================================================
172      * The remainder is just support stuff
173      */
174 
175     // use any free port by default
176     volatile int serverPort = 0;
177 
178     volatile Exception serverException = null;
179     volatile Exception clientException = null;
180 
181     public static void main(String args[]) throws Exception {
182         String keyFilename =
183             System.getProperty(&quot;test.src&quot;, &quot;./&quot;) + &quot;/&quot; + pathToStores +
184                 &quot;/&quot; + keyStoreFile;
185         String trustFilename =
186             System.getProperty(&quot;test.src&quot;, &quot;./&quot;) + &quot;/&quot; + pathToStores +
187                 &quot;/&quot; + trustStoreFile;
188 
189         CookieHandler reservedCookieHandler = CookieHandler.getDefault();
190         HostnameVerifier reservedHV =
191             HttpsURLConnection.getDefaultHostnameVerifier();
192         try {
193             System.setProperty(&quot;javax.net.ssl.keyStore&quot;, keyFilename);
194             System.setProperty(&quot;javax.net.ssl.keyStorePassword&quot;, passwd);
195             System.setProperty(&quot;javax.net.ssl.trustStore&quot;, trustFilename);
196             System.setProperty(&quot;javax.net.ssl.trustStorePassword&quot;, passwd);
197 
198             if (debug)
199                 System.setProperty(&quot;javax.net.debug&quot;, &quot;all&quot;);
200 
201             /*
202              * Start the tests.
203              */
204             cookies = new HashMap&lt;String, String&gt;();
205             cookies.put(&quot;Cookie&quot;,
206                 &quot;$Version=\&quot;1\&quot;; Customer=\&quot;WILE_E_COYOTE\&quot;; $Path=\&quot;/acme\&quot;&quot;);
207             cookies.put(&quot;Set-Cookie2&quot;,
208               &quot;$Version=\&quot;1\&quot;; Part_Number=\&quot;Riding_Rocket_0023\&quot;; &quot; +
209               &quot;$Path=\&quot;/acme/ammo\&quot;; Part_Number=\&quot;Rocket_Launcher_0001\&quot;; &quot;+
210               &quot;$Path=\&quot;/acme\&quot;&quot;);
211             CookieHandler.setDefault(new MyCookieHandler());
212             new CookieHandlerTest();
213         } finally {
214             HttpsURLConnection.setDefaultHostnameVerifier(reservedHV);
215             CookieHandler.setDefault(reservedCookieHandler);
216         }
217     }
218 
219     Thread clientThread = null;
220     Thread serverThread = null;
221     /*
222      * Primary constructor, used to drive remainder of the test.
223      *
224      * Fork off the other side, then do your work.
225      */
226     CookieHandlerTest() throws Exception {
227         if (separateServerThread) {
228             startServer(true);
229             startClient(false);
230         } else {
231             startClient(true);
232             startServer(false);
233         }
234 
235         /*
236          * Wait for other side to close down.
237          */
238         if (separateServerThread) {
239             serverThread.join();
240         } else {
241             clientThread.join();
242         }
243 
244         /*
245          * When we get here, the test is pretty much over.
246          *
247          * If the main thread excepted, that propagates back
248          * immediately.  If the other thread threw an exception, we
249          * should report back.
250          */
251         if (serverException != null)
252             throw serverException;
253         if (clientException != null)
254             throw clientException;
255 
256         if (!getCalled || !putCalled) {
257             throw new RuntimeException (&quot;Either get or put method is not called&quot;);
258         }
259     }
260 
261     void startServer(boolean newThread) throws Exception {
262         if (newThread) {
263             serverThread = new Thread() {
264                 public void run() {
265                     try {
266                         doServerSide();
267                     } catch (Exception e) {
268                         /*
269                          * Our server thread just died.
270                          *
271                          * Release the client, if not active already...
272                          */
273                         System.err.println(&quot;Server died...&quot;);
274                         serverReady = true;
275                         serverException = e;
276                     }
277                 }
278             };
279             serverThread.start();
280         } else {
281             doServerSide();
282         }
283     }
284 
285     void startClient(boolean newThread) throws Exception {
286         if (newThread) {
287             clientThread = new Thread() {
288                 public void run() {
289                     try {
290                         doClientSide();
291                     } catch (Exception e) {
292                         /*
293                          * Our client thread just died.
294                          */
295                         System.err.println(&quot;Client died...&quot;);
296                         clientException = e;
297                     }
298                 }
299             };
300             clientThread.start();
301         } else {
302             doClientSide();
303         }
304     }
305 
306     static boolean getCalled = false, putCalled = false;
307 
308     static class MyCookieHandler extends CookieHandler {
309         public Map&lt;String,List&lt;String&gt;&gt;
310             get(URI uri, Map&lt;String,List&lt;String&gt;&gt; requestHeaders)
311             throws IOException {
312             getCalled = true;
313             // returns cookies[0]
314             // they will be include in request
315             Map&lt;String,List&lt;String&gt;&gt; map = new HashMap&lt;&gt;();
316             List&lt;String&gt; l = new ArrayList&lt;&gt;();
317             l.add(cookies.get(&quot;Cookie&quot;));
318             map.put(&quot;Cookie&quot;,l);
319             return Collections.unmodifiableMap(map);
320         }
321 
322         public void
323             put(URI uri, Map&lt;String,List&lt;String&gt;&gt; responseHeaders)
324             throws IOException {
325             putCalled = true;
326             // check response has cookies[1]
327             List&lt;String&gt; l = responseHeaders.get(&quot;Set-Cookie2&quot;);
328             String value = l.get(0);
329             if (!value.equals((String)cookies.get(&quot;Set-Cookie2&quot;))) {
330                 throw new RuntimeException(&quot;cookie should be available for handle to put into cache&quot;);
331                }
332         }
333     }
334 
335 }
    </pre>
  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New test/jdk/sun/net/www/protocol/https/NewImpl/JavaxHostnameVerifier.java</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2001, 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 // SunJSSE does not support dynamic system properties, no way to re-use
 25 // system properties in samevm/agentvm mode.
 26 
 27 /*
 28  * @test
 29  * @bug 4474255 4484246
 30  * @summary When an application enables anonymous SSL cipher suite,
 31  *        Hostname verification is not required
 32  * @run main/othervm JavaxHostnameVerifier
 33  */
 34 
 35 import java.io.*;
 36 import java.net.*;
 37 import java.security.Security;
 38 import java.security.cert.*;
 39 import javax.net.ssl.*;
 40 
 41 /**
 42  * Use javax.net.ssl.HostnameVerifier
 43  */
 44 public class JavaxHostnameVerifier {
 45 
 46     /*
 47      * =============================================================
 48      * Set the various variables needed for the tests, then
 49      * specify what tests to run on each side.
 50      */
 51 
 52     /*
 53      * Should we run the client or server in a separate thread?
 54      * Both sides can throw exceptions, but do you have a preference
 55      * as to which side should be the main thread.
 56      */
 57     static boolean separateServerThread = true;
 58 
 59     /*
 60      * Is the server ready to serve?
 61      */
 62     volatile static boolean serverReady = false;
 63 
 64     /*
 65      * Turn on SSL debugging?
 66      */
 67     static boolean debug = false;
 68 
 69     /*
 70      * If the client or server is doing some kind of object creation
 71      * that the other side depends on, and that thread prematurely
 72      * exits, you may experience a hang.  The test harness will
 73      * terminate all hung threads after its timeout has expired,
 74      * currently 3 minutes by default, but you might try to be
 75      * smart about it....
 76      */
 77 
 78     /**
 79      * Returns the path to the file obtained from
 80      * parsing the HTML header.
 81      */
 82     private static String getPath(DataInputStream in)
 83         throws IOException
 84     {
 85         String line = in.readLine();
 86         String path = &quot;&quot;;
 87         // extract class from GET line
 88         if (line == null)
 89                 return null;
 90 
 91         if (line.startsWith(&quot;GET /&quot;)) {
 92             line = line.substring(5, line.length()-1).trim();
 93             int index = line.indexOf(&#39; &#39;);
 94             if (index != -1) {
 95                 path = line.substring(0, index);
 96             }
 97         }
 98 
 99         // eat the rest of header
100         do {
101             line = in.readLine();
102         } while ((line.length() != 0) &amp;&amp;
103                  (line.charAt(0) != &#39;\r&#39;) &amp;&amp; (line.charAt(0) != &#39;\n&#39;));
104 
105         if (path.length() != 0) {
106             return path;
107         } else {
108             throw new IOException(&quot;Malformed Header&quot;);
109         }
110     }
111 
112     /**
113      * Returns an array of bytes containing the bytes for
114      * the file represented by the argument &lt;b&gt;path&lt;/b&gt;.
115      *
116      * In our case, we just pretend to send something back.
117      *
118      * @return the bytes for the file
119      * @exception FileNotFoundException if the file corresponding
120      * to &lt;b&gt;path&lt;/b&gt; could not be loaded.
121      */
122     private byte[] getBytes(String path)
123         throws IOException
124     {
125         return &quot;Hello world, I am here&quot;.getBytes();
126     }
127 
128     /*
129      * Define the server side of the test.
130      *
131      * If the server prematurely exits, serverReady will be set to true
132      * to avoid infinite hangs.
133      */
134     void doServerSide() throws Exception {
135 
136         SSLServerSocketFactory sslssf =
137           (SSLServerSocketFactory) SSLServerSocketFactory.getDefault();
138 
139         // doClientSide() connects to &quot;localhost&quot;
140         InetAddress localHost = InetAddress.getByName(&quot;localhost&quot;);
141         InetSocketAddress address = new InetSocketAddress(localHost, serverPort);
142 
143         SSLServerSocket sslServerSocket =
144             (SSLServerSocket) sslssf.createServerSocket();
145         sslServerSocket.bind(address);
146         serverPort = sslServerSocket.getLocalPort();
147 
148         String ciphers[]= { &quot;SSL_DH_anon_WITH_3DES_EDE_CBC_SHA&quot; };
149         sslServerSocket.setEnabledCipherSuites(ciphers);
150 
151         /*
152          * Signal Client, we&#39;re ready for his connect.
153          */
154         serverReady = true;
155 
156         SSLSocket sslSocket = (SSLSocket) sslServerSocket.accept();
157         DataOutputStream out =
158                 new DataOutputStream(sslSocket.getOutputStream());
159 
160         try {
161              // get path to class file from header
162              DataInputStream in =
163                         new DataInputStream(sslSocket.getInputStream());
164              String path = getPath(in);
165              // retrieve bytecodes
166              byte[] bytecodes = getBytes(path);
167              // send bytecodes in response (assumes HTTP/1.0 or later)
168              try {
169                 out.writeBytes(&quot;HTTP/1.0 200 OK\r\n&quot;);
170                 out.writeBytes(&quot;Content-Length: &quot; + bytecodes.length + &quot;\r\n&quot;);
171                 out.writeBytes(&quot;Content-Type: text/html\r\n\r\n&quot;);
172                 out.write(bytecodes);
173                 out.flush();
174              } catch (IOException ie) {
175                 ie.printStackTrace();
176                 return;
177              }
178 
179         } catch (Exception e) {
180              e.printStackTrace();
181              // write out error response
182              out.writeBytes(&quot;HTTP/1.0 400 &quot; + e.getMessage() + &quot;\r\n&quot;);
183              out.writeBytes(&quot;Content-Type: text/html\r\n\r\n&quot;);
184              out.flush();
185         } finally {
186              // close the socket
187              System.out.println(&quot;Server closing socket&quot;);
188              sslSocket.close();
189              serverReady = false;
190         }
191     }
192 
193     /*
194      * Define the client side of the test.
195      *
196      * If the server prematurely exits, serverReady will be set to true
197      * to avoid infinite hangs.
198      */
199     void doClientSide() throws Exception {
200         /*
201          * Wait for server to get started.
202          */
203         while (!serverReady) {
204             Thread.sleep(50);
205         }
206 
207         System.setProperty(&quot;https.cipherSuites&quot;,
208                 &quot;SSL_DH_anon_WITH_3DES_EDE_CBC_SHA&quot;);
209 
210         // use the default hostname verifier
211 
212         URL url = new URL(&quot;https://&quot; + &quot;localhost:&quot; + serverPort +
213                                 &quot;/etc/hosts&quot;);
214         URLConnection urlc = url.openConnection(Proxy.NO_PROXY);
215 
216         if (!(urlc instanceof javax.net.ssl.HttpsURLConnection)) {
217             throw new Exception(
218                 &quot;URLConnection ! instanceof javax.net.ssl.HttpsURLConnection&quot;);
219         }
220 
221         BufferedReader in = null;
222         try {
223             in = new BufferedReader(new InputStreamReader(
224                                urlc.getInputStream()));
225             String inputLine;
226             System.out.print(&quot;Client reading... &quot;);
227             while ((inputLine = in.readLine()) != null)
228                 System.out.println(inputLine);
229             System.out.println(&quot;Cipher Suite: &quot; +
230                 ((HttpsURLConnection)urlc).getCipherSuite());
231             in.close();
232         } catch (SSLException e) {
233             if (in != null)
234                 in.close();
235             throw e;
236         }
237         System.out.println(&quot;Client reports:  SUCCESS&quot;);
238     }
239 
240     /*
241      * =============================================================
242      * The remainder is just support stuff
243      */
244 
245     // use any free port by default
246     volatile int serverPort = 0;
247 
248     volatile Exception serverException = null;
249     volatile Exception clientException = null;
250 
251     public static void main(String[] args) throws Exception {
252         // re-enable 3DES
253         Security.setProperty(&quot;jdk.tls.disabledAlgorithms&quot;, &quot;&quot;);
254 
255         if (debug)
256             System.setProperty(&quot;javax.net.debug&quot;, &quot;all&quot;);
257 
258         /*
259          * Start the tests.
260          */
261         new JavaxHostnameVerifier();
262     }
263 
264     Thread clientThread = null;
265     Thread serverThread = null;
266 
267     /*
268      * Primary constructor, used to drive remainder of the test.
269      *
270      * Fork off the other side, then do your work.
271      */
272     JavaxHostnameVerifier() throws Exception {
273         if (separateServerThread) {
274             startServer(true);
275             startClient(false);
276         } else {
277             startClient(true);
278             startServer(false);
279         }
280 
281         /*
282          * Wait for other side to close down.
283          */
284         if (separateServerThread) {
285             serverThread.join();
286         } else {
287             clientThread.join();
288         }
289 
290         /*
291          * When we get here, the test is pretty much over.
292          *
293          * If the main thread excepted, that propagates back
294          * immediately.  If the other thread threw an exception, we
295          * should report back.
296          */
297         if (serverException != null) {
298             System.out.print(&quot;Server Exception:&quot;);
299             throw serverException;
300         }
301         if (clientException != null) {
302             System.out.print(&quot;Client Exception:&quot;);
303             throw clientException;
304         }
305     }
306 
307     void startServer(boolean newThread) throws Exception {
308         if (newThread) {
309             serverThread = new Thread() {
310                 public void run() {
311                     try {
312                         doServerSide();
313                     } catch (Exception e) {
314                         /*
315                          * Our server thread just died.
316                          *
317                          * Release the client, if not active already...
318                          */
319                         System.err.println(&quot;Server died...&quot;);
320                         serverReady = true;
321                         serverException = e;
322                     }
323                 }
324             };
325             serverThread.start();
326         } else {
327             doServerSide();
328         }
329     }
330 
331     void startClient(boolean newThread) throws Exception {
332         if (newThread) {
333             clientThread = new Thread() {
334                 public void run() {
335                     try {
336                         doClientSide();
337                     } catch (Exception e) {
338                         /*
339                          * Our client thread just died.
340                          */
341                         System.err.println(&quot;Client died...&quot;);
342                         clientException = e;
343                     }
344                 }
345             };
346             clientThread.start();
347         } else {
348             doClientSide();
349         }
350     }
351 }
    </pre>
  </body>
</html>
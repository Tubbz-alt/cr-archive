<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old test/jdk/sun/net/www/protocol/jar/MultiReleaseJarURLConnection.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2015, 2018, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 /*
 25  * @test
 26  * @bug 8132734 8144062 8159785 8194070
 27  * @summary Test that URL connections to multi-release jars can be runtime versioned
 28  * @library /lib/testlibrary/java/util/jar
 29  * @modules jdk.compiler
 30  *          jdk.httpserver
 31  *          jdk.jartool
 32  * @build Compiler JarBuilder CreateMultiReleaseTestJars SimpleHttpServer
 33  * @run testng MultiReleaseJarURLConnection
 34  */
 35 
 36 import java.io.IOException;
 37 import java.io.InputStream;
 38 import java.lang.invoke.MethodHandle;
 39 import java.lang.invoke.MethodHandles;
 40 import java.lang.invoke.MethodType;
 41 import java.net.JarURLConnection;
 42 import java.net.URL;
 43 import java.net.URLClassLoader;
 44 import java.net.URLConnection;
 45 import java.nio.file.Files;
 46 import java.nio.file.Paths;
 47 import java.util.Enumeration;
 48 import java.util.jar.JarFile;
 49 
 50 import org.testng.Assert;
 51 import org.testng.annotations.AfterClass;
 52 import org.testng.annotations.BeforeClass;
 53 import org.testng.annotations.DataProvider;
 54 import org.testng.annotations.Test;
 55 
 56 public class MultiReleaseJarURLConnection {
 57     String userdir = System.getProperty(&quot;user.dir&quot;,&quot;.&quot;);
 58     String unversioned = userdir + &quot;/unversioned.jar&quot;;
 59     String unsigned = userdir + &quot;/multi-release.jar&quot;;
 60     String signed = userdir + &quot;/signed-multi-release.jar&quot;;
 61     SimpleHttpServer server;
 62 
 63     @BeforeClass
 64     public void initialize() throws Exception {
 65         CreateMultiReleaseTestJars creator = new CreateMultiReleaseTestJars();
 66         creator.compileEntries();
 67         creator.buildUnversionedJar();
 68         creator.buildMultiReleaseJar();
 69         creator.buildSignedMultiReleaseJar();
 70 
 71         server = new SimpleHttpServer();
 72         server.start();
 73 
 74     }
 75 
 76     @AfterClass
 77     public void close() throws IOException {
 78         // Windows requires server to stop before file is deleted
 79         if (server != null)
 80             server.stop();
 81         Files.delete(Paths.get(unversioned));
 82         Files.delete(Paths.get(unsigned));
 83         Files.delete(Paths.get(signed));
 84     }
 85 
 86     @DataProvider(name = &quot;data&quot;)
 87     public Object[][] createData() {
 88         return new Object[][]{
 89                 {&quot;unversioned&quot;, unversioned},
 90                 {&quot;unsigned&quot;, unsigned},
 91                 {&quot;signed&quot;, signed}
 92         };
 93     }
 94 
 95     @Test(dataProvider = &quot;data&quot;)
 96     public void testRuntimeVersioning(String style, String file) throws Exception {
 97         String urlFile = &quot;jar:file:&quot; + file + &quot;!/&quot;;
 98         String baseUrlEntry = urlFile + &quot;version/Version.java&quot;;
 99         String rtreturn = &quot;return &quot; + Runtime.version().major();
100 
101         Assert.assertTrue(readAndCompare(new URL(baseUrlEntry), &quot;return 8&quot;));
102         // #runtime is &quot;magic&quot; for a multi-release jar, but not for unversioned jar
103         Assert.assertTrue(readAndCompare(new URL(baseUrlEntry + &quot;#runtime&quot;),
104                 style.equals(&quot;unversioned&quot;) ? &quot;return 8&quot; : rtreturn));
105         // #fragment or any other fragment is not magic
106         Assert.assertTrue(readAndCompare(new URL(baseUrlEntry + &quot;#fragment&quot;), &quot;return 8&quot;));
107         // cached entities not affected
108         Assert.assertTrue(readAndCompare(new URL(baseUrlEntry), &quot;return 8&quot;));
109 
110         // the following tests will not work with unversioned jars
111         if (style.equals(&quot;unversioned&quot;))
112             return;
113 
114         // direct access to versioned entry
115         String versUrlEntry = urlFile + &quot;META-INF/versions/&quot; + Runtime.version().major()
116                 + &quot;/version/Version.java&quot;;
117         Assert.assertTrue(readAndCompare(new URL(versUrlEntry), rtreturn));
118         // adding any fragment does not change things
119         Assert.assertTrue(readAndCompare(new URL(versUrlEntry + &quot;#runtime&quot;), rtreturn));
120         Assert.assertTrue(readAndCompare(new URL(versUrlEntry + &quot;#fragment&quot;), rtreturn));
121     }
122 
123     @Test(dataProvider = &quot;data&quot;)
124     public void testCachedJars(String style, String file) throws Exception {
125         String urlFile = &quot;jar:file:&quot; + file + &quot;!/&quot;;
126 
127         URL rootUrl = new URL(urlFile);
128         JarURLConnection juc = (JarURLConnection)rootUrl.openConnection();
129         JarFile rootJar = juc.getJarFile();
130         Runtime.Version root = rootJar.getVersion();
131 
132         URL runtimeUrl = new URL(urlFile + &quot;#runtime&quot;);
133         juc = (JarURLConnection)runtimeUrl.openConnection();
134         JarFile runtimeJar = juc.getJarFile();
135         Runtime.Version runtime = runtimeJar.getVersion();
136         if (style.equals(&quot;unversioned&quot;)) {
137             Assert.assertEquals(root, runtime);
138         } else {
139             Assert.assertNotEquals(root, runtime);
140         }
141 
142         juc = (JarURLConnection)rootUrl.openConnection();
143         JarFile jar = juc.getJarFile();
144         Assert.assertEquals(jar.getVersion(), root);
145         Assert.assertEquals(jar, rootJar);
146 
147         juc = (JarURLConnection)runtimeUrl.openConnection();
148         jar = juc.getJarFile();
149         Assert.assertEquals(jar.getVersion(), runtime);
150         Assert.assertEquals(jar, runtimeJar);
151 
152         rootJar.close();
153         runtimeJar.close();
154         jar.close(); // probably not needed
155     }
156 
157     @DataProvider(name = &quot;resourcedata&quot;)
158     public Object[][] createResourceData() throws Exception {
159         return new Object[][]{
160                 {&quot;unversioned&quot;, Paths.get(unversioned).toUri().toURL()},
161                 {&quot;unsigned&quot;, Paths.get(unsigned).toUri().toURL()},
162                 {&quot;signed&quot;, Paths.get(signed).toUri().toURL()},
163                 {&quot;unversioned&quot;, new URL(&quot;file:&quot; + unversioned)},
164                 {&quot;unsigned&quot;, new URL(&quot;file:&quot; + unsigned)},
165                 {&quot;signed&quot;, new URL(&quot;file:&quot; + signed)},
166                 {&quot;unversioned&quot;, new URL(&quot;jar:file:&quot; + unversioned + &quot;!/&quot;)},
167                 {&quot;unsigned&quot;, new URL(&quot;jar:file:&quot; + unsigned + &quot;!/&quot;)},
168                 {&quot;signed&quot;, new URL(&quot;jar:file:&quot; + signed + &quot;!/&quot;)},
169                 // external jar received via http protocol
170                 {&quot;http&quot;, new URL(&quot;jar:http://localhost:&quot; + server.getPort() + &quot;/multi-release.jar!/&quot;)},
171                 {&quot;http&quot;, new URL(&quot;http://localhost:&quot; + server.getPort() + &quot;/multi-release.jar&quot;)},
172 
173         };
174     }
175 
176     @Test(dataProvider = &quot;resourcedata&quot;)
177     public void testResources(String style, URL url) throws Throwable {
178         //System.out.println(&quot;  testing &quot; + style + &quot; url: &quot; + url);
179         URL[] urls = {url};
180         URLClassLoader cldr = new URLClassLoader(urls);
181         Class&lt;?&gt; vcls = cldr.loadClass(&quot;version.Version&quot;);
182 
183         // verify we are loading a runtime versioned class
184         MethodType mt = MethodType.methodType(int.class);
185         MethodHandle mh = MethodHandles.lookup().findVirtual(vcls, &quot;getVersion&quot;, mt);
186         Assert.assertEquals((int)mh.invoke(vcls.newInstance()),
187                 style.equals(&quot;unversioned&quot;) ? 8 : Runtime.version().major());
188 
189         // now get a resource and verify that we don&#39;t have a fragment attached
190         Enumeration&lt;URL&gt; vclsUrlEnum = cldr.getResources(&quot;version/Version.class&quot;);
191         Assert.assertTrue(vclsUrlEnum.hasMoreElements());
192         URL vclsUrls[] = new URL[] {
193             vcls.getResource(&quot;/version/Version.class&quot;),
194             vcls.getResource(&quot;Version.class&quot;),
195             cldr.getResource(&quot;version/Version.class&quot;),
196             vclsUrlEnum.nextElement()
197         };
198         Assert.assertFalse(vclsUrlEnum.hasMoreElements());
199         for (URL vclsUrl : vclsUrls) {
200             String fragment = vclsUrl.getRef();
201             Assert.assertNull(fragment);
202 
203             // and verify that the the url is a reified pointer to the runtime entry
204             String rep = vclsUrl.toString();
205             //System.out.println(&quot;    getResource(\&quot;/version/Version.class\&quot;) returned: &quot; + rep);
206             if (style.equals(&quot;http&quot;)) {
207                 Assert.assertTrue(rep.startsWith(&quot;jar:http:&quot;));
208             } else {
209                 Assert.assertTrue(rep.startsWith(&quot;jar:file:&quot;));
210             }
211             String suffix;
212             if (style.equals(&quot;unversioned&quot;)) {
213                 suffix = &quot;.jar!/version/Version.class&quot;;
214             } else {
215                 suffix = &quot;.jar!/META-INF/versions/&quot; + Runtime.version().major()
216                         + &quot;/version/Version.class&quot;;
217             }
218             Assert.assertTrue(rep.endsWith(suffix));
219         }
220         cldr.close();
221     }
222 
223     private boolean readAndCompare(URL url, String match) throws Exception {
224         boolean result;
225         // necessary to do it this way, instead of openStream(), so we can
226         // close underlying JarFile, otherwise windows can&#39;t delete the file
227         URLConnection conn = url.openConnection();
228         try (InputStream is = conn.getInputStream()) {
229             byte[] bytes = is.readAllBytes();
230             result = (new String(bytes)).contains(match);
231         }
232         if (conn instanceof JarURLConnection) {
233             ((JarURLConnection)conn).getJarFile().close();
234         }
235         return result;
236     }
237 }
    </pre>
  </body>
</html>
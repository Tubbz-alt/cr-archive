<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff test/jdk/sun/net/www/protocol/https/HttpsURLConnection/IPAddressIPIdentities.java</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="IPAddressDNSIdentities.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="IPIdentities.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>test/jdk/sun/net/www/protocol/https/HttpsURLConnection/IPAddressIPIdentities.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2010, 2015, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 //
 25 // SunJSSE does not support dynamic system properties, no way to re-use
 26 // system properties in samevm/agentvm mode.
 27 //
 28 
 29 /* @test
 30  * @summary X509 certificate hostname checking is broken in JDK1.6.0_10

 31  * @bug 6766775
 32  * @run main/othervm IPAddressIPIdentities
 33  * @author Xuelei Fan
 34  */
 35 
 36 import java.net.*;
 37 import java.util.*;
 38 import java.io.*;
 39 import javax.net.ssl.*;
 40 import java.security.Security;
 41 import java.security.KeyStore;
 42 import java.security.KeyFactory;
 43 import java.security.cert.Certificate;
 44 import java.security.cert.CertificateFactory;
 45 import java.security.spec.*;
 46 import java.security.interfaces.*;
 47 import java.math.BigInteger;

 48 
 49 /*
 50  * Certificates and key used in the test.
 51  *
 52  * TLS server certificate:
 53  * server private key:
 54  * -----BEGIN RSA PRIVATE KEY-----
 55  * Proc-Type: 4,ENCRYPTED
 56  * DEK-Info: DES-EDE3-CBC,D9AE407F6D0E389A
 57  *
 58  * WPrA7TFol/cQCcp9oHnXWNpYlvRbbIcQj0m+RKT2Iuzfus+DHt3Zadf8nJpKfX2e
 59  * h2rnhlzCN9M7djRDooZKDOPCsdBn51Au7HlZF3S3Opgo7D8XFM1a8t1Je4ke14oI
 60  * nw6QKYsBblRziPnP2PZ0zvX24nOv7bbY8beynlJHGs00VWSFdoH2DS0aE1p6D+3n
 61  * ptJuJ75dVfZFK4X7162APlNXevX8D6PEQpSiRw1rjjGGcnvQ4HdWk3BxDVDcCNJb
 62  * Y1aGNRxsjTDvPi3R9Qx2M+W03QzEPx4SR3ZHVskeSJHaetM0TM/w/45Paq4GokXP
 63  * ZeTnbEx1xmjkA7h+t4doLL4watx5F6yLsJzu8xB3lt/1EtmkYtLz1t7X4BetPAXz
 64  * zS69X/VwhKfsOI3qXBWuL2oHPyhDmT1gcaUQwEPSV6ogHEEQEDXdiUS8heNK13KF
 65  * TCQYFkETvV2BLxUhV1hypPzRQ6tUpJiAbD5KmoK2lD9slshG2QtvKQq0/bgkDY5J
 66  * LhDHV2dtcZ3kDPkkZXpbcJQvoeH3d09C5sIsuTFo2zgNR6oETHUc5TzP6FY2YYRa
 67  * QcK5HcmtsRRiXFm01ac+aMejJUIujjFt84SiKWT/73vC8AmY4tYcJBLjCg4XIxSH
</pre>
<hr />
<pre>
635     volatile static boolean closeReady = false;
636 
637     /*
638      * Turn on SSL debugging?
639      */
640     static boolean debug = false;
641 
642     private SSLServerSocket sslServerSocket = null;
643 
644     /*
645      * Define the server side of the test.
646      *
647      * If the server prematurely exits, serverReady will be set to true
648      * to avoid infinite hangs.
649      */
650     void doServerSide() throws Exception {
651         SSLContext context = getSSLContext(trusedCertStr, serverCertStr,
652             serverModulus, serverPrivateExponent, passphrase);
653         SSLServerSocketFactory sslssf = context.getServerSocketFactory();
654 




655         sslServerSocket =
<span class="line-modified">656             (SSLServerSocket) sslssf.createServerSocket(serverPort);</span>

657         serverPort = sslServerSocket.getLocalPort();
658 
659         /*
660          * Signal Client, we&#39;re ready for his connect.
661          */
662         serverReady = true;
663 
664         SSLSocket sslSocket = (SSLSocket) sslServerSocket.accept();
665         sslSocket.setNeedClientAuth(true);
666 
667         PrintStream out =
668                 new PrintStream(sslSocket.getOutputStream());
669 
670         try {
671             // ignore request data
672 
673             // send the response
674             out.print(&quot;HTTP/1.1 200 OK\r\n&quot;);
675             out.print(&quot;Content-Type: text/html; charset=iso-8859-1\r\n&quot;);
676             out.print(&quot;Content-Length: &quot;+ 9 +&quot;\r\n&quot;);
</pre>
<hr />
<pre>
697      * to avoid infinite hangs.
698      */
699     void doClientSide() throws Exception {
700         SSLContext reservedSSLContext = SSLContext.getDefault();
701         try {
702             SSLContext context = getSSLContext(trusedCertStr, clientCertStr,
703                 clientModulus, clientPrivateExponent, passphrase);
704 
705             SSLContext.setDefault(context);
706 
707             /*
708              * Wait for server to get started.
709              */
710             while (!serverReady) {
711                 Thread.sleep(50);
712             }
713 
714             HttpsURLConnection http = null;
715 
716             /* establish http connection to server */
<span class="line-modified">717             URL url = new URL(&quot;https://127.0.0.1:&quot; + serverPort+&quot;/&quot;);</span>





718             System.out.println(&quot;url is &quot;+url.toString());
719 
720             try {
<span class="line-modified">721                 http = (HttpsURLConnection)url.openConnection();</span>
722 
723                 int respCode = http.getResponseCode();
724                 System.out.println(&quot;respCode = &quot;+respCode);
725             } finally {
726                 if (http != null) {
727                     http.disconnect();
728                 }
729                 closeReady = true;
730             }
731         } finally {
732             SSLContext.setDefault(reservedSSLContext);
733         }
734     }
735 
736     /*
737      * =============================================================
738      * The remainder is just support stuff
739      */
740 
741     // use any free port by default
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2010, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 //
 25 // SunJSSE does not support dynamic system properties, no way to re-use
 26 // system properties in samevm/agentvm mode.
 27 //
 28 
 29 /* @test
 30  * @summary X509 certificate hostname checking is broken in JDK1.6.0_10
<span class="line-added"> 31  * @library /test/lib</span>
 32  * @bug 6766775
 33  * @run main/othervm IPAddressIPIdentities
 34  * @author Xuelei Fan
 35  */
 36 
 37 import java.net.*;
 38 import java.util.*;
 39 import java.io.*;
 40 import javax.net.ssl.*;
 41 import java.security.Security;
 42 import java.security.KeyStore;
 43 import java.security.KeyFactory;
 44 import java.security.cert.Certificate;
 45 import java.security.cert.CertificateFactory;
 46 import java.security.spec.*;
 47 import java.security.interfaces.*;
 48 import java.math.BigInteger;
<span class="line-added"> 49 import jdk.test.lib.net.URIBuilder;</span>
 50 
 51 /*
 52  * Certificates and key used in the test.
 53  *
 54  * TLS server certificate:
 55  * server private key:
 56  * -----BEGIN RSA PRIVATE KEY-----
 57  * Proc-Type: 4,ENCRYPTED
 58  * DEK-Info: DES-EDE3-CBC,D9AE407F6D0E389A
 59  *
 60  * WPrA7TFol/cQCcp9oHnXWNpYlvRbbIcQj0m+RKT2Iuzfus+DHt3Zadf8nJpKfX2e
 61  * h2rnhlzCN9M7djRDooZKDOPCsdBn51Au7HlZF3S3Opgo7D8XFM1a8t1Je4ke14oI
 62  * nw6QKYsBblRziPnP2PZ0zvX24nOv7bbY8beynlJHGs00VWSFdoH2DS0aE1p6D+3n
 63  * ptJuJ75dVfZFK4X7162APlNXevX8D6PEQpSiRw1rjjGGcnvQ4HdWk3BxDVDcCNJb
 64  * Y1aGNRxsjTDvPi3R9Qx2M+W03QzEPx4SR3ZHVskeSJHaetM0TM/w/45Paq4GokXP
 65  * ZeTnbEx1xmjkA7h+t4doLL4watx5F6yLsJzu8xB3lt/1EtmkYtLz1t7X4BetPAXz
 66  * zS69X/VwhKfsOI3qXBWuL2oHPyhDmT1gcaUQwEPSV6ogHEEQEDXdiUS8heNK13KF
 67  * TCQYFkETvV2BLxUhV1hypPzRQ6tUpJiAbD5KmoK2lD9slshG2QtvKQq0/bgkDY5J
 68  * LhDHV2dtcZ3kDPkkZXpbcJQvoeH3d09C5sIsuTFo2zgNR6oETHUc5TzP6FY2YYRa
 69  * QcK5HcmtsRRiXFm01ac+aMejJUIujjFt84SiKWT/73vC8AmY4tYcJBLjCg4XIxSH
</pre>
<hr />
<pre>
637     volatile static boolean closeReady = false;
638 
639     /*
640      * Turn on SSL debugging?
641      */
642     static boolean debug = false;
643 
644     private SSLServerSocket sslServerSocket = null;
645 
646     /*
647      * Define the server side of the test.
648      *
649      * If the server prematurely exits, serverReady will be set to true
650      * to avoid infinite hangs.
651      */
652     void doServerSide() throws Exception {
653         SSLContext context = getSSLContext(trusedCertStr, serverCertStr,
654             serverModulus, serverPrivateExponent, passphrase);
655         SSLServerSocketFactory sslssf = context.getServerSocketFactory();
656 
<span class="line-added">657         // doClientSide() connects to the loopback address</span>
<span class="line-added">658         InetAddress loopback = InetAddress.getLoopbackAddress();</span>
<span class="line-added">659         InetSocketAddress address = new InetSocketAddress(loopback, serverPort);</span>
<span class="line-added">660 </span>
661         sslServerSocket =
<span class="line-modified">662             (SSLServerSocket) sslssf.createServerSocket();</span>
<span class="line-added">663         sslServerSocket.bind(address);</span>
664         serverPort = sslServerSocket.getLocalPort();
665 
666         /*
667          * Signal Client, we&#39;re ready for his connect.
668          */
669         serverReady = true;
670 
671         SSLSocket sslSocket = (SSLSocket) sslServerSocket.accept();
672         sslSocket.setNeedClientAuth(true);
673 
674         PrintStream out =
675                 new PrintStream(sslSocket.getOutputStream());
676 
677         try {
678             // ignore request data
679 
680             // send the response
681             out.print(&quot;HTTP/1.1 200 OK\r\n&quot;);
682             out.print(&quot;Content-Type: text/html; charset=iso-8859-1\r\n&quot;);
683             out.print(&quot;Content-Length: &quot;+ 9 +&quot;\r\n&quot;);
</pre>
<hr />
<pre>
704      * to avoid infinite hangs.
705      */
706     void doClientSide() throws Exception {
707         SSLContext reservedSSLContext = SSLContext.getDefault();
708         try {
709             SSLContext context = getSSLContext(trusedCertStr, clientCertStr,
710                 clientModulus, clientPrivateExponent, passphrase);
711 
712             SSLContext.setDefault(context);
713 
714             /*
715              * Wait for server to get started.
716              */
717             while (!serverReady) {
718                 Thread.sleep(50);
719             }
720 
721             HttpsURLConnection http = null;
722 
723             /* establish http connection to server */
<span class="line-modified">724             URL url = URIBuilder.newBuilder()</span>
<span class="line-added">725                 .scheme(&quot;https&quot;)</span>
<span class="line-added">726                 .loopback()</span>
<span class="line-added">727                 .port(serverPort)</span>
<span class="line-added">728                 .path(&quot;/&quot;)</span>
<span class="line-added">729                 .toURL();</span>
730             System.out.println(&quot;url is &quot;+url.toString());
731 
732             try {
<span class="line-modified">733                 http = (HttpsURLConnection)url.openConnection(Proxy.NO_PROXY);</span>
734 
735                 int respCode = http.getResponseCode();
736                 System.out.println(&quot;respCode = &quot;+respCode);
737             } finally {
738                 if (http != null) {
739                     http.disconnect();
740                 }
741                 closeReady = true;
742             }
743         } finally {
744             SSLContext.setDefault(reservedSSLContext);
745         }
746     }
747 
748     /*
749      * =============================================================
750      * The remainder is just support stuff
751      */
752 
753     // use any free port by default
</pre>
</td>
</tr>
</table>
<center><a href="IPAddressDNSIdentities.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="IPIdentities.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
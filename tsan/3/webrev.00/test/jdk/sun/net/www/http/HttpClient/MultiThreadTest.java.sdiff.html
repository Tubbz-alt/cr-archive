<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff test/jdk/sun/net/www/http/HttpClient/MultiThreadTest.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
<body>
<center><a href="IsKeepingAlive.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="OpenServer.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>test/jdk/sun/net/www/http/HttpClient/MultiThreadTest.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2002, 2018, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
</pre>
<hr />
<pre>
 25  * @test
 26  * @bug 4636628
 27  * @summary HttpURLConnection duplicates HTTP GET requests when used with multiple threads
 28 */
 29 
 30 /*
 31  * This tests keep-alive behavior using chunkedinputstreams
 32  * It checks that keep-alive connections are used and also
 33  * that requests are not being repeated (due to errors)
 34  *
 35  * It also checks that the keepalive connections are closed eventually
 36  * because the test will not terminate if the connections
 37  * are not closed by the keep-alive timer.
 38  */
 39 
 40 import java.net.*;
 41 import java.io.*;
 42 import java.time.Duration;
 43 import java.util.Queue;
 44 import java.util.concurrent.ConcurrentLinkedQueue;

 45 
 46 public class MultiThreadTest extends Thread {
 47 
 48     /*
 49      * Is debugging enabled - start with -d to enable.
 50      */
 51     static boolean debug = true; // disable debug once stability proven
 52 
 53     static Object threadlock = new Object ();
 54     static int threadCounter = 0;
 55 
 56     static Object getLock() { return threadlock; }
 57 
 58     static void debug(String msg) {
 59         if (debug)
 60             System.out.println(msg);
 61     }
 62 
<span class="line-modified"> 63     static int reqnum = 0;</span>
 64 
 65     void doRequest(String uri) throws Exception {
<span class="line-modified"> 66         URL url = new URL(uri + &quot;?foo=&quot;+reqnum);</span>
<span class="line-removed"> 67         reqnum ++;</span>
 68         HttpURLConnection http = (HttpURLConnection)url.openConnection();
<span class="line-removed"> 69 </span>
 70         InputStream in = http.getInputStream();
 71         byte b[] = new byte[100];
 72         int total = 0;
 73         int n;
 74         do {
 75             n = in.read(b);
 76             if (n &gt; 0) total += n;
 77         } while (n &gt; 0);
 78         debug (&quot;client: read &quot; + total + &quot; bytes&quot;);
 79         in.close();
 80         http.disconnect();
 81     }
 82 
 83     String uri;
 84     byte[] b;
 85     int requests;
 86 
<span class="line-modified"> 87     MultiThreadTest(int port, int requests) throws Exception {</span>
<span class="line-modified"> 88         uri = &quot;http://localhost:&quot; + port + &quot;/foo.html&quot;;</span>
 89 
 90         b = new byte [256];
 91         this.requests = requests;
 92 
 93         synchronized (threadlock) {
 94             threadCounter ++;
 95         }
 96     }
 97 
 98     public void run() {
 99         long start = System.nanoTime();
100 
101         try {
102             for (int i=0; i&lt;requests; i++) {
103                 doRequest (uri);
104             }
105         } catch (Exception e) {
106             throw new RuntimeException (e.getMessage());
107         } finally {
108             synchronized (threadlock) {
</pre>
<hr />
<pre>
117 
118     static int threads=5;
119 
120     public static void main(String args[]) throws Exception {
121         long start = System.nanoTime();
122 
123         int x = 0, arg_len = args.length;
124         int requests = 20;
125 
126         if (arg_len &gt; 0 &amp;&amp; args[0].equals(&quot;-d&quot;)) {
127             debug = true;
128             x = 1;
129             arg_len --;
130         }
131         if (arg_len &gt; 0) {
132             threads = Integer.parseInt (args[x]);
133             requests = Integer.parseInt (args[x+1]);
134         }
135 
136         /* start the server */
<span class="line-modified">137         ServerSocket ss = new ServerSocket(0);</span>


138         Server svr = new Server(ss);
139         svr.start();
140 
141         Object lock = MultiThreadTest.getLock();
142         synchronized (lock) {
143             for (int i=0; i&lt;threads; i++) {
<span class="line-modified">144                 MultiThreadTest t = new MultiThreadTest(ss.getLocalPort(), requests);</span>
145                 t.start ();
146             }
147             try {
148                 lock.wait();
149             } catch (InterruptedException e) {}
150         }
151 
152         // shutdown server - we&#39;re done.
153         svr.shutdown();
154 
155         int cnt = svr.connectionCount();
156         MultiThreadTest.debug(&quot;Connections = &quot; + cnt);
157         int reqs = Worker.getRequests ();
158         MultiThreadTest.debug(&quot;Requests = &quot; + reqs);
159         System.out.println (&quot;Connection count = &quot; + cnt + &quot; Request count = &quot; + reqs);
<span class="line-modified">160         if (cnt &gt; threads) { // could be less</span>
<span class="line-modified">161             throw new RuntimeException (&quot;Expected &quot;+threads + &quot; connections: used &quot; +cnt);</span>
























162         }
<span class="line-modified">163         if  (reqs != threads*requests) {</span>
164             throw new RuntimeException (&quot;Expected &quot;+ threads*requests+ &quot; requests: got &quot; +reqs);
165         }

166         for (Thread worker : svr.workers()) {
167             worker.join(60_000);
168         }
169 
170         debug(&quot;main thread end - &quot; + Duration.ofNanos(System.nanoTime() - start));
171     }
172 }
173 
174     /*
175      * Server thread to accept connection and create worker threads
176      * to service each connection.
177      */
178     class Server extends Thread {
179         ServerSocket ss;
180         int connectionCount;
181         boolean shutdown = false;
<span class="line-modified">182         private Queue&lt;Worker&gt; workers = new ConcurrentLinkedQueue&lt;&gt;();</span>
183 
184         Server(ServerSocket ss) {
185             this.ss = ss;
186         }
187 










188         public Queue&lt;Worker&gt; workers() {
189             return workers;
190         }
191 
192         public synchronized int connectionCount() {
193             return connectionCount;
194         }
195 
196         public synchronized void shutdown() {
197             shutdown = true;
198         }
199 
200         public void run() {
201             try {
202                 ss.setSoTimeout(2000);
203 
204                 for (;;) {
205                     Socket s;
206                     try {
207                         MultiThreadTest.debug(&quot;server: calling accept.&quot;);
</pre>
<hr />
<pre>
229                     MultiThreadTest.debug(&quot;server: Started worker &quot; + id);
230                 }
231 
232             } catch (Exception e) {
233                 e.printStackTrace();
234             } finally {
235                 try {
236                     ss.close();
237                 } catch (Exception e) { }
238             }
239         }
240     }
241 
242     /*
243      * Worker thread to service single connection - can service
244      * multiple http requests on same connection.
245      */
246     class Worker extends Thread {
247         Socket s;
248         int id;

249 
250         Worker(Socket s, int id) {

251             this.s = s;
252             this.id = id;
253         }
254 
255         static int requests = 0;
256         static final Object rlock = new Object();
257 
258         public static int getRequests () {
259             synchronized (rlock) {
260                 return requests;
261             }
262         }

263         public static void incRequests () {
264             synchronized (rlock) {
265                 requests++;
266             }
267         }
268 
<span class="line-modified">269         int readUntil(InputStream in, char[] seq) throws IOException {</span>
270             int i=0, count=0;
271             while (true) {
272                 int c = in.read();
273                 if (c == -1)
274                     return -1;

275                 count++;
276                 if (c == seq[i]) {
277                     i++;
278                     if (i == seq.length)
279                         return count;
280                     continue;
281                 } else {
282                     i = 0;
283                 }
284             }
285         }
286 
287         public void run() {
288             long start = System.nanoTime();
289 
290             try {
291                 int max = 400;
292                 byte b[] = new byte[1000];
293                 InputStream in = new BufferedInputStream(s.getInputStream());
294                 // response to client
295                 PrintStream out = new PrintStream(
296                                     new BufferedOutputStream(
297                                                 s.getOutputStream() ));
298 
299                 for (;;) {
300 
301                     // read entire request from client
302                     int n=0;
<span class="line-modified">303 </span>
<span class="line-modified">304                     n = readUntil(in, new char[] {&#39;\r&#39;,&#39;\n&#39;, &#39;\r&#39;,&#39;\n&#39;});</span>
<span class="line-removed">305 </span>
306                     if (n &lt;= 0) {
307                         MultiThreadTest.debug(&quot;worker: &quot; + id + &quot;: Shutdown&quot;);
308                         s.close();
309                         return;
310                     }





311 
312                     MultiThreadTest.debug(&quot;worker &quot; + id +
313                         &quot;: Read request from client &quot; +
314                         &quot;(&quot; + n + &quot; bytes).&quot;);
315 
316                     incRequests();
317                     out.print(&quot;HTTP/1.1 200 OK\r\n&quot;);
318                     out.print(&quot;Transfer-Encoding: chunked\r\n&quot;);
319                     out.print(&quot;Content-Type: text/html\r\n&quot;);
320                     out.print(&quot;Connection: Keep-Alive\r\n&quot;);
321                     out.print(&quot;Keep-Alive: timeout=15, max=&quot;+max+&quot;\r\n&quot;);
322                     out.print(&quot;\r\n&quot;);
323                     out.print(&quot;6\r\nHello \r\n&quot;);
324                     out.print(&quot;5\r\nWorld\r\n&quot;);
325                     out.print(&quot;0\r\n\r\n&quot;);
326                     out.flush();
327 
328                     if (--max == 0) {
329                         s.close();
330                         return;
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2002, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
</pre>
<hr />
<pre>
 25  * @test
 26  * @bug 4636628
 27  * @summary HttpURLConnection duplicates HTTP GET requests when used with multiple threads
 28 */
 29 
 30 /*
 31  * This tests keep-alive behavior using chunkedinputstreams
 32  * It checks that keep-alive connections are used and also
 33  * that requests are not being repeated (due to errors)
 34  *
 35  * It also checks that the keepalive connections are closed eventually
 36  * because the test will not terminate if the connections
 37  * are not closed by the keep-alive timer.
 38  */
 39 
 40 import java.net.*;
 41 import java.io.*;
 42 import java.time.Duration;
 43 import java.util.Queue;
 44 import java.util.concurrent.ConcurrentLinkedQueue;
<span class="line-added"> 45 import java.util.concurrent.atomic.AtomicInteger;</span>
 46 
 47 public class MultiThreadTest extends Thread {
 48 
 49     /*
 50      * Is debugging enabled - start with -d to enable.
 51      */
 52     static boolean debug = true; // disable debug once stability proven
 53 
 54     static Object threadlock = new Object ();
 55     static int threadCounter = 0;
 56 
 57     static Object getLock() { return threadlock; }
 58 
 59     static void debug(String msg) {
 60         if (debug)
 61             System.out.println(msg);
 62     }
 63 
<span class="line-modified"> 64     static final AtomicInteger reqnum = new AtomicInteger();</span>
 65 
 66     void doRequest(String uri) throws Exception {
<span class="line-modified"> 67         URL url = new URL(uri + &quot;?foo=&quot;+reqnum.getAndIncrement());</span>

 68         HttpURLConnection http = (HttpURLConnection)url.openConnection();

 69         InputStream in = http.getInputStream();
 70         byte b[] = new byte[100];
 71         int total = 0;
 72         int n;
 73         do {
 74             n = in.read(b);
 75             if (n &gt; 0) total += n;
 76         } while (n &gt; 0);
 77         debug (&quot;client: read &quot; + total + &quot; bytes&quot;);
 78         in.close();
 79         http.disconnect();
 80     }
 81 
 82     String uri;
 83     byte[] b;
 84     int requests;
 85 
<span class="line-modified"> 86     MultiThreadTest(String authority, int requests) throws Exception {</span>
<span class="line-modified"> 87         uri = &quot;http://&quot; + authority + &quot;/foo.html&quot;;</span>
 88 
 89         b = new byte [256];
 90         this.requests = requests;
 91 
 92         synchronized (threadlock) {
 93             threadCounter ++;
 94         }
 95     }
 96 
 97     public void run() {
 98         long start = System.nanoTime();
 99 
100         try {
101             for (int i=0; i&lt;requests; i++) {
102                 doRequest (uri);
103             }
104         } catch (Exception e) {
105             throw new RuntimeException (e.getMessage());
106         } finally {
107             synchronized (threadlock) {
</pre>
<hr />
<pre>
116 
117     static int threads=5;
118 
119     public static void main(String args[]) throws Exception {
120         long start = System.nanoTime();
121 
122         int x = 0, arg_len = args.length;
123         int requests = 20;
124 
125         if (arg_len &gt; 0 &amp;&amp; args[0].equals(&quot;-d&quot;)) {
126             debug = true;
127             x = 1;
128             arg_len --;
129         }
130         if (arg_len &gt; 0) {
131             threads = Integer.parseInt (args[x]);
132             requests = Integer.parseInt (args[x+1]);
133         }
134 
135         /* start the server */
<span class="line-modified">136         InetAddress loopback = InetAddress.getLoopbackAddress();</span>
<span class="line-added">137         ServerSocket ss = new ServerSocket();</span>
<span class="line-added">138         ss.bind(new InetSocketAddress(loopback, 0));</span>
139         Server svr = new Server(ss);
140         svr.start();
141 
142         Object lock = MultiThreadTest.getLock();
143         synchronized (lock) {
144             for (int i=0; i&lt;threads; i++) {
<span class="line-modified">145                 MultiThreadTest t = new MultiThreadTest(svr.getAuthority(), requests);</span>
146                 t.start ();
147             }
148             try {
149                 lock.wait();
150             } catch (InterruptedException e) {}
151         }
152 
153         // shutdown server - we&#39;re done.
154         svr.shutdown();
155 
156         int cnt = svr.connectionCount();
157         MultiThreadTest.debug(&quot;Connections = &quot; + cnt);
158         int reqs = Worker.getRequests ();
159         MultiThreadTest.debug(&quot;Requests = &quot; + reqs);
160         System.out.println (&quot;Connection count = &quot; + cnt + &quot; Request count = &quot; + reqs);
<span class="line-modified">161 </span>
<span class="line-modified">162         // We may have received traffic from something else than</span>
<span class="line-added">163         // our client. We should only count those workers for which</span>
<span class="line-added">164         // the expected header has been found.</span>
<span class="line-added">165         int validConnections = 0;</span>
<span class="line-added">166         for (Worker w : svr.workers()) {</span>
<span class="line-added">167             if (w.headerFound) validConnections++;</span>
<span class="line-added">168         }</span>
<span class="line-added">169 </span>
<span class="line-added">170         if (validConnections &gt; threads + 1 || validConnections == 0) { // could be less</span>
<span class="line-added">171             throw new RuntimeException (&quot;Expected &quot; + threads + &quot; connections: used &quot; + validConnections);</span>
<span class="line-added">172         }</span>
<span class="line-added">173 </span>
<span class="line-added">174         // Sometimes the client drops a connection after a while and</span>
<span class="line-added">175         // spawns a new one. Why this is happening is not clear,</span>
<span class="line-added">176         // and JDK-8223783 is logged to follow up on this. For the sake</span>
<span class="line-added">177         // of test stabilization we don&#39;t fail on `threads + 1` connections</span>
<span class="line-added">178         // but log a warning instead.</span>
<span class="line-added">179         if (validConnections == threads + 1) {</span>
<span class="line-added">180             debug(&quot;WARNING: &quot; + validConnections</span>
<span class="line-added">181                 + &quot; have been used, where only &quot; + threads</span>
<span class="line-added">182                 + &quot; were expected!&quot;);</span>
<span class="line-added">183         }</span>
<span class="line-added">184 </span>
<span class="line-added">185         if (validConnections != cnt) {</span>
<span class="line-added">186             debug(&quot;WARNING: got &quot; + (cnt - validConnections) + &quot; unexpected connections!&quot;);</span>
187         }
<span class="line-modified">188         if  (validConnections == cnt &amp;&amp; reqs != threads*requests) {</span>
189             throw new RuntimeException (&quot;Expected &quot;+ threads*requests+ &quot; requests: got &quot; +reqs);
190         }
<span class="line-added">191 </span>
192         for (Thread worker : svr.workers()) {
193             worker.join(60_000);
194         }
195 
196         debug(&quot;main thread end - &quot; + Duration.ofNanos(System.nanoTime() - start));
197     }
198 }
199 
200     /*
201      * Server thread to accept connection and create worker threads
202      * to service each connection.
203      */
204     class Server extends Thread {
205         ServerSocket ss;
206         int connectionCount;
207         boolean shutdown = false;
<span class="line-modified">208         private final Queue&lt;Worker&gt; workers = new ConcurrentLinkedQueue&lt;&gt;();</span>
209 
210         Server(ServerSocket ss) {
211             this.ss = ss;
212         }
213 
<span class="line-added">214         public String getAuthority() {</span>
<span class="line-added">215             InetAddress address = ss.getInetAddress();</span>
<span class="line-added">216             String hostaddr = address.isAnyLocalAddress()</span>
<span class="line-added">217                 ? &quot;localhost&quot; : address.getHostAddress();</span>
<span class="line-added">218             if (hostaddr.indexOf(&#39;:&#39;) &gt; -1) {</span>
<span class="line-added">219                 hostaddr = &quot;[&quot; + hostaddr + &quot;]&quot;;</span>
<span class="line-added">220             }</span>
<span class="line-added">221             return hostaddr + &quot;:&quot; + ss.getLocalPort();</span>
<span class="line-added">222         }</span>
<span class="line-added">223 </span>
224         public Queue&lt;Worker&gt; workers() {
225             return workers;
226         }
227 
228         public synchronized int connectionCount() {
229             return connectionCount;
230         }
231 
232         public synchronized void shutdown() {
233             shutdown = true;
234         }
235 
236         public void run() {
237             try {
238                 ss.setSoTimeout(2000);
239 
240                 for (;;) {
241                     Socket s;
242                     try {
243                         MultiThreadTest.debug(&quot;server: calling accept.&quot;);
</pre>
<hr />
<pre>
265                     MultiThreadTest.debug(&quot;server: Started worker &quot; + id);
266                 }
267 
268             } catch (Exception e) {
269                 e.printStackTrace();
270             } finally {
271                 try {
272                     ss.close();
273                 } catch (Exception e) { }
274             }
275         }
276     }
277 
278     /*
279      * Worker thread to service single connection - can service
280      * multiple http requests on same connection.
281      */
282     class Worker extends Thread {
283         Socket s;
284         int id;
<span class="line-added">285         volatile boolean headerFound;</span>
286 
287         Worker(Socket s, int id) {
<span class="line-added">288             super(&quot;Worker-&quot; + id);</span>
289             this.s = s;
290             this.id = id;
291         }
292 
293         static int requests = 0;
294         static final Object rlock = new Object();
295 
296         public static int getRequests () {
297             synchronized (rlock) {
298                 return requests;
299             }
300         }
<span class="line-added">301 </span>
302         public static void incRequests () {
303             synchronized (rlock) {
304                 requests++;
305             }
306         }
307 
<span class="line-modified">308         int readUntil(InputStream in, StringBuilder headers, char[] seq) throws IOException {</span>
309             int i=0, count=0;
310             while (true) {
311                 int c = in.read();
312                 if (c == -1)
313                     return -1;
<span class="line-added">314                 headers.append((char)c);</span>
315                 count++;
316                 if (c == seq[i]) {
317                     i++;
318                     if (i == seq.length)
319                         return count;
320                     continue;
321                 } else {
322                     i = 0;
323                 }
324             }
325         }
326 
327         public void run() {
328             long start = System.nanoTime();
329 
330             try {
331                 int max = 400;
332                 byte b[] = new byte[1000];
333                 InputStream in = new BufferedInputStream(s.getInputStream());
334                 // response to client
335                 PrintStream out = new PrintStream(
336                                     new BufferedOutputStream(
337                                                 s.getOutputStream() ));
338 
339                 for (;;) {
340 
341                     // read entire request from client
342                     int n=0;
<span class="line-modified">343                     StringBuilder headers = new StringBuilder();</span>
<span class="line-modified">344                     n = readUntil(in, headers, new char[] {&#39;\r&#39;,&#39;\n&#39;, &#39;\r&#39;,&#39;\n&#39;});</span>

345                     if (n &lt;= 0) {
346                         MultiThreadTest.debug(&quot;worker: &quot; + id + &quot;: Shutdown&quot;);
347                         s.close();
348                         return;
349                     }
<span class="line-added">350                     if (headers.toString().contains(&quot;/foo.html?foo=&quot;)) {</span>
<span class="line-added">351                         headerFound = true;</span>
<span class="line-added">352                     } else {</span>
<span class="line-added">353                         MultiThreadTest.debug(&quot;worker: &quot; + id + &quot;: Unexpected request received: &quot; + headers);</span>
<span class="line-added">354                     }</span>
355 
356                     MultiThreadTest.debug(&quot;worker &quot; + id +
357                         &quot;: Read request from client &quot; +
358                         &quot;(&quot; + n + &quot; bytes).&quot;);
359 
360                     incRequests();
361                     out.print(&quot;HTTP/1.1 200 OK\r\n&quot;);
362                     out.print(&quot;Transfer-Encoding: chunked\r\n&quot;);
363                     out.print(&quot;Content-Type: text/html\r\n&quot;);
364                     out.print(&quot;Connection: Keep-Alive\r\n&quot;);
365                     out.print(&quot;Keep-Alive: timeout=15, max=&quot;+max+&quot;\r\n&quot;);
366                     out.print(&quot;\r\n&quot;);
367                     out.print(&quot;6\r\nHello \r\n&quot;);
368                     out.print(&quot;5\r\nWorld\r\n&quot;);
369                     out.print(&quot;0\r\n\r\n&quot;);
370                     out.flush();
371 
372                     if (--max == 0) {
373                         s.close();
374                         return;
</pre>
</td>
</tr>
</table>
<center><a href="IsKeepingAlive.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="OpenServer.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
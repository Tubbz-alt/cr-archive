<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old test/jdk/sun/net/www/protocol/https/HttpsURLConnection/ImpactOnSNI.java</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2016, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 //
 25 // SunJSSE does not support dynamic system properties, no way to re-use
 26 // system properties in samevm/agentvm mode.
 27 //
 28 
 29 /*
 30  * @test
 31  * @bug 8144566
 32  * @summary Custom HostnameVerifier disables SNI extension
 33  * @run main/othervm ImpactOnSNI
 34  */
 35 
 36 import java.io.*;
 37 import java.net.*;
 38 import javax.net.ssl.*;
 39 
 40 public class ImpactOnSNI {
 41 
 42     /*
 43      * =============================================================
 44      * Set the various variables needed for the tests, then
 45      * specify what tests to run on each side.
 46      */
 47 
 48     /*
 49      * Should we run the client or server in a separate thread?
 50      * Both sides can throw exceptions, but do you have a preference
 51      * as to which side should be the main thread.
 52      */
 53     private static final boolean separateServerThread = true;
 54 
 55     /*
 56      * Where do we find the keystores?
 57      */
 58     private static final String pathToStores =
 59                                         &quot;../../../../../../javax/net/ssl/etc&quot;;
 60     private static final String keyStoreFile = &quot;keystore&quot;;
 61     private static final String trustStoreFile = &quot;truststore&quot;;
 62     private static final String passwd = &quot;passphrase&quot;;
 63 
 64     /*
 65      * Is the server ready to serve?
 66      */
 67     private static volatile boolean serverReady = false;
 68 
 69     /*
 70      * Is the connection ready to close?
 71      */
 72     private static volatile boolean closeReady = false;
 73 
 74     /*
 75      * Turn on SSL debugging?
 76      */
 77     private static final boolean debug = false;
 78 
 79     /*
 80      * Message posted
 81      */
 82     private static final String postMsg = &quot;HTTP post on a https server&quot;;
 83 
 84     /*
 85      * the fully qualified domain name of localhost
 86      */
 87     private static String hostname = null;
 88 
 89     /*
 90      * If the client or server is doing some kind of object creation
 91      * that the other side depends on, and that thread prematurely
 92      * exits, you may experience a hang.  The test harness will
 93      * terminate all hung threads after its timeout has expired,
 94      * currently 3 minutes by default, but you might try to be
 95      * smart about it....
 96      */
 97 
 98     /*
 99      * Define the server side of the test.
100      *
101      * If the server prematurely exits, serverReady will be set to true
102      * to avoid infinite hangs.
103      */
104     private void doServerSide() throws Exception {
105         SSLServerSocketFactory sslssf =
106             (SSLServerSocketFactory)SSLServerSocketFactory.getDefault();
107         try (SSLServerSocket sslServerSocket =
108                 (SSLServerSocket)sslssf.createServerSocket(serverPort)) {
109 
110             serverPort = sslServerSocket.getLocalPort();
111 
112             /*
113              * Signal Client, we&#39;re ready for his connect.
114              */
115             serverReady = true;
116 
117             /*
118              * Accept connections
119              */
120             try (SSLSocket sslSocket = (SSLSocket)sslServerSocket.accept()) {
121                 InputStream sslIS = sslSocket.getInputStream();
122                 OutputStream sslOS = sslSocket.getOutputStream();
123                 BufferedReader br =
124                         new BufferedReader(new InputStreamReader(sslIS));
125                 PrintStream ps = new PrintStream(sslOS);
126 
127                 // process HTTP POST request from client
128                 System.out.println(&quot;status line: &quot; + br.readLine());
129                 String msg = null;
130                 while ((msg = br.readLine()) != null &amp;&amp; msg.length() &gt; 0);
131 
132                 msg = br.readLine();
133                 if (msg.equals(postMsg)) {
134                     ps.println(&quot;HTTP/1.1 200 OK\n\n&quot;);
135                 } else {
136                     ps.println(&quot;HTTP/1.1 500 Not OK\n\n&quot;);
137                 }
138                 ps.flush();
139 
140                 ExtendedSSLSession session =
141                         (ExtendedSSLSession)sslSocket.getSession();
142                 if (session.getRequestedServerNames().isEmpty()) {
143                     throw new Exception(&quot;No expected Server Name Indication&quot;);
144                 }
145 
146                 // close the socket
147                 while (!closeReady) {
148                     Thread.sleep(50);
149                 }
150             }
151         }
152     }
153 
154     /*
155      * Define the client side of the test.
156      *
157      * If the server prematurely exits, serverReady will be set to true
158      * to avoid infinite hangs.
159      */
160     private void doClientSide() throws Exception {
161         /*
162          * Wait for server to get started.
163          */
164         while (!serverReady) {
165             Thread.sleep(50);
166         }
167 
168         // Send HTTP POST request to server
169         URL url = new URL(&quot;https://&quot; + hostname + &quot;:&quot; + serverPort);
170 
171         HttpsURLConnection.setDefaultHostnameVerifier(new NameVerifier());
172         HttpsURLConnection http = (HttpsURLConnection)url.openConnection();
173         http.setDoOutput(true);
174 
175         http.setRequestMethod(&quot;POST&quot;);
176         PrintStream ps = new PrintStream(http.getOutputStream());
177         try {
178             ps.println(postMsg);
179             ps.flush();
180             if (http.getResponseCode() != 200) {
181                 throw new RuntimeException(&quot;test Failed&quot;);
182             }
183         } finally {
184             ps.close();
185             http.disconnect();
186             closeReady = true;
187         }
188     }
189 
190     private static class NameVerifier implements HostnameVerifier {
191         public boolean verify(String hostname, SSLSession session) {
192             return true;
193         }
194     }
195 
196     /*
197      * =============================================================
198      * The remainder is just support stuff
199      */
200 
201     // use any free port by default
202     private volatile int serverPort = 0;
203 
204     private volatile Exception serverException = null;
205     private volatile Exception clientException = null;
206 
207     public static void main(String[] args) throws Exception {
208         String keyFilename =
209             System.getProperty(&quot;test.src&quot;, &quot;./&quot;) + &quot;/&quot; + pathToStores +
210                 &quot;/&quot; + keyStoreFile;
211         String trustFilename =
212             System.getProperty(&quot;test.src&quot;, &quot;./&quot;) + &quot;/&quot; + pathToStores +
213                 &quot;/&quot; + trustStoreFile;
214 
215         System.setProperty(&quot;javax.net.ssl.keyStore&quot;, keyFilename);
216         System.setProperty(&quot;javax.net.ssl.keyStorePassword&quot;, passwd);
217         System.setProperty(&quot;javax.net.ssl.trustStore&quot;, trustFilename);
218         System.setProperty(&quot;javax.net.ssl.trustStorePassword&quot;, passwd);
219 
220         if (debug) {
221             System.setProperty(&quot;javax.net.debug&quot;, &quot;all&quot;);
222         }
223 
224         try {
225             hostname = InetAddress.getLocalHost().getCanonicalHostName();
226         } catch (UnknownHostException uhe) {
227             System.out.println(
228                 &quot;Ignore the test as the local hostname cannot be determined&quot;);
229 
230             return;
231         }
232 
233         System.out.println(
234                 &quot;The fully qualified domain name of the local host is &quot; +
235                 hostname);
236         // Ignore the test if the hostname does not sound like a domain name.
237         if ((hostname == null) || hostname.isEmpty() ||
238                 !hostname.contains(&quot;.&quot;) || hostname.endsWith(&quot;.&quot;) ||
239                 hostname.startsWith(&quot;localhost&quot;) ||
240                 Character.isDigit(hostname.charAt(hostname.length() - 1))) {
241 
242             System.out.println(&quot;Ignore the test as the local hostname &quot; +
243                     &quot;cannot be determined as fully qualified domain name&quot;);
244 
245             return;
246         }
247 
248         /*
249          * Start the tests.
250          */
251         new ImpactOnSNI();
252     }
253 
254     private Thread clientThread = null;
255     private Thread serverThread = null;
256 
257     /*
258      * Primary constructor, used to drive remainder of the test.
259      *
260      * Fork off the other side, then do your work.
261      */
262     ImpactOnSNI() throws Exception {
263         Exception startException = null;
264         try {
265             if (separateServerThread) {
266                 startServer(true);
267                 startClient(false);
268             } else {
269                 startClient(true);
270                 startServer(false);
271             }
272         } catch (Exception e) {
273             startException = e;
274         }
275 
276         /*
277          * Wait for other side to close down.
278          */
279         if (separateServerThread) {
280             if (serverThread != null) {
281                 serverThread.join();
282             }
283         } else {
284             if (clientThread != null) {
285                 clientThread.join();
286             }
287         }
288 
289         /*
290          * When we get here, the test is pretty much over.
291          * Which side threw the error?
292          */
293         Exception local;
294         Exception remote;
295 
296         if (separateServerThread) {
297             remote = serverException;
298             local = clientException;
299         } else {
300             remote = clientException;
301             local = serverException;
302         }
303 
304         Exception exception = null;
305 
306         /*
307          * Check various exception conditions.
308          */
309         if ((local != null) &amp;&amp; (remote != null)) {
310             // If both failed, return the curthread&#39;s exception.
311             local.initCause(remote);
312             exception = local;
313         } else if (local != null) {
314             exception = local;
315         } else if (remote != null) {
316             exception = remote;
317         } else if (startException != null) {
318             exception = startException;
319         }
320 
321         /*
322          * If there was an exception *AND* a startException,
323          * output it.
324          */
325         if (exception != null) {
326             if (exception != startException &amp;&amp; startException != null) {
327                 exception.addSuppressed(startException);
328             }
329             throw exception;
330         }
331 
332         // Fall-through: no exception to throw!
333     }
334 
335     private void startServer(boolean newThread) throws Exception {
336         if (newThread) {
337             serverThread = new Thread() {
338                 @Override
339                 public void run() {
340                     try {
341                         doServerSide();
342                     } catch (Exception e) {
343                         /*
344                          * Our server thread just died.
345                          *
346                          * Release the client, if not active already...
347                          */
348                         System.err.println(&quot;Server died...&quot;);
349                         serverReady = true;
350                         serverException = e;
351                     }
352                 }
353             };
354             serverThread.start();
355         } else {
356             try {
357                 doServerSide();
358             } catch (Exception e) {
359                 serverException = e;
360             } finally {
361                 serverReady = true;
362             }
363         }
364     }
365 
366     private void startClient(boolean newThread) throws Exception {
367         if (newThread) {
368             clientThread = new Thread() {
369                 @Override
370                 public void run() {
371                     try {
372                         doClientSide();
373                     } catch (Exception e) {
374                         /*
375                          * Our client thread just died.
376                          */
377                         System.err.println(&quot;Client died...&quot;);
378                         clientException = e;
379                     }
380                 }
381             };
382             clientThread.start();
383         } else {
384             try {
385                 doClientSide();
386             } catch (Exception e) {
387                 clientException = e;
388             }
389         }
390     }
391 }
    </pre>
  </body>
</html>
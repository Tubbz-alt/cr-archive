<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New test/jdk/sun/net/www/protocol/https/NewImpl/JavaxHTTPSConnection.java</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2001, 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 /*
 25  * @test
 26  * @bug 4474255
 27  * @summary Can no longer obtain a com.sun.net.ssl.HttpsURLConnection
 28  * @library /test/lib
 29  * @run main/othervm JavaxHTTPSConnection
 30  * @run main/othervm -Djava.net.preferIPv6Addresses=true JavaxHTTPSConnection
 31  *
 32  *     SunJSSE does not support dynamic system properties, no way to re-use
 33  *     system properties in samevm/agentvm mode.
 34  * @author Brad Wetmore
 35  */
 36 
 37 import java.io.*;
 38 import java.net.*;
 39 import java.security.cert.*;
 40 import javax.net.ssl.*;
 41 import jdk.test.lib.net.URIBuilder;
 42 
 43 /**
 44  * See if we can obtain a javax.net.ssl.HttpsURLConnection,
 45  * and then play with it a bit.
 46  */
 47 public class JavaxHTTPSConnection {
 48 
 49     /*
 50      * =============================================================
 51      * Set the various variables needed for the tests, then
 52      * specify what tests to run on each side.
 53      */
 54 
 55     /*
 56      * Should we run the client or server in a separate thread?
 57      * Both sides can throw exceptions, but do you have a preference
 58      * as to which side should be the main thread.
 59      */
 60     static boolean separateServerThread = true;
 61 
 62     /*
 63      * Where do we find the keystores?
 64      */
 65     static String pathToStores = &quot;../../../../../../javax/net/ssl/etc&quot;;
 66     static String keyStoreFile = &quot;keystore&quot;;
 67     static String trustStoreFile = &quot;truststore&quot;;
 68     static String passwd = &quot;passphrase&quot;;
 69 
 70     /*
 71      * Is the server ready to serve?
 72      */
 73     volatile static boolean serverReady = false;
 74 
 75     /*
 76      * Turn on SSL debugging?
 77      */
 78     static boolean debug = false;
 79 
 80     /*
 81      * If the client or server is doing some kind of object creation
 82      * that the other side depends on, and that thread prematurely
 83      * exits, you may experience a hang.  The test harness will
 84      * terminate all hung threads after its timeout has expired,
 85      * currently 3 minutes by default, but you might try to be
 86      * smart about it....
 87      */
 88 
 89     /**
 90      * Returns the path to the file obtained from
 91      * parsing the HTML header.
 92      */
 93     private static String getPath(DataInputStream in)
 94         throws IOException
 95     {
 96         String line = in.readLine();
 97         String path = &quot;&quot;;
 98         // extract class from GET line
 99         if (line.startsWith(&quot;GET /&quot;)) {
100             line = line.substring(5, line.length()-1).trim();
101             int index = line.indexOf(&#39; &#39;);
102             if (index != -1) {
103                 path = line.substring(0, index);
104             }
105         }
106 
107         // eat the rest of header
108         do {
109             line = in.readLine();
110         } while ((line.length() != 0) &amp;&amp;
111                  (line.charAt(0) != &#39;\r&#39;) &amp;&amp; (line.charAt(0) != &#39;\n&#39;));
112 
113         if (path.length() != 0) {
114             return path;
115         } else {
116             throw new IOException(&quot;Malformed Header&quot;);
117         }
118     }
119 
120     /**
121      * Returns an array of bytes containing the bytes for
122      * the file represented by the argument &lt;b&gt;path&lt;/b&gt;.
123      *
124      * In our case, we just pretend to send something back.
125      *
126      * @return the bytes for the file
127      * @exception FileNotFoundException if the file corresponding
128      * to &lt;b&gt;path&lt;/b&gt; could not be loaded.
129      */
130     private byte[] getBytes(String path)
131         throws IOException
132     {
133         return &quot;Hello world, I am here&quot;.getBytes();
134     }
135 
136     /*
137      * Define the server side of the test.
138      *
139      * If the server prematurely exits, serverReady will be set to true
140      * to avoid infinite hangs.
141      */
142     void doServerSide() throws Exception {
143 
144         InetAddress loopback = InetAddress.getLoopbackAddress();
145         InetSocketAddress serverAddress = new InetSocketAddress(loopback, serverPort);
146         SSLServerSocketFactory sslssf =
147           (SSLServerSocketFactory) SSLServerSocketFactory.getDefault();
148         SSLServerSocket sslServerSocket =
149             (SSLServerSocket) sslssf.createServerSocket();
150         sslServerSocket.bind(serverAddress);
151         serverPort = sslServerSocket.getLocalPort();
152 
153         /*
154          * Signal Client, we&#39;re ready for his connect.
155          */
156         serverReady = true;
157 
158         SSLSocket sslSocket = (SSLSocket) sslServerSocket.accept();
159         DataOutputStream out =
160                 new DataOutputStream(sslSocket.getOutputStream());
161 
162         try {
163              // get path to class file from header
164              DataInputStream in =
165                         new DataInputStream(sslSocket.getInputStream());
166              String path = getPath(in);
167              // retrieve bytecodes
168              byte[] bytecodes = getBytes(path);
169              // send bytecodes in response (assumes HTTP/1.0 or later)
170              try {
171                 out.writeBytes(&quot;HTTP/1.0 200 OK\r\n&quot;);
172                 out.writeBytes(&quot;Content-Length: &quot; + bytecodes.length + &quot;\r\n&quot;);
173                 out.writeBytes(&quot;Content-Type: text/html\r\n\r\n&quot;);
174                 out.write(bytecodes);
175                 out.flush();
176              } catch (IOException ie) {
177                 ie.printStackTrace();
178                 return;
179              }
180 
181         } catch (Exception e) {
182              e.printStackTrace();
183              // write out error response
184              out.writeBytes(&quot;HTTP/1.0 400 &quot; + e.getMessage() + &quot;\r\n&quot;);
185              out.writeBytes(&quot;Content-Type: text/html\r\n\r\n&quot;);
186              out.flush();
187         } finally {
188              // close the socket
189              System.out.println(&quot;Server closing socket&quot;);
190              sslSocket.close();
191              serverReady = false;
192         }
193     }
194 
195     /*
196      * Define the client side of the test.
197      *
198      * If the server prematurely exits, serverReady will be set to true
199      * to avoid infinite hangs.
200      */
201     void doClientSide() throws Exception {
202         HostnameVerifier reservedHV =
203             HttpsURLConnection.getDefaultHostnameVerifier();
204         try {
205             /*
206              * Wait for server to get started.
207              */
208             while (!serverReady) {
209                 Thread.sleep(50);
210             }
211 
212             HttpsURLConnection.setDefaultHostnameVerifier(new NameVerifier());
213             URL url = URIBuilder.newBuilder()
214                 .scheme(&quot;https&quot;)
215                 .loopback()
216                 .port(serverPort)
217                 .path(&quot;/etc/hosts&quot;)
218                 .toURL();
219             System.out.println(&quot;Client opening: &quot; + url);
220             URLConnection urlc = url.openConnection(Proxy.NO_PROXY);
221 
222             if (!(urlc instanceof javax.net.ssl.HttpsURLConnection)) {
223                 throw new Exception(&quot;URLConnection ! instanceof &quot; +
224                                     &quot;javax.net.ssl.HttpsURLConnection&quot;);
225             }
226 
227             BufferedReader in = null;
228             try {
229                 in = new BufferedReader(new InputStreamReader(
230                                    urlc.getInputStream()));
231                 String inputLine;
232                 System.out.print(&quot;Client reading... &quot;);
233                 while ((inputLine = in.readLine()) != null)
234                     System.out.println(inputLine);
235 
236                 System.out.println(&quot;Cipher Suite: &quot; +
237                     ((HttpsURLConnection)urlc).getCipherSuite());
238                 Certificate[] certs =
239                     ((HttpsURLConnection)urlc).getServerCertificates();
240                 for (int i = 0; i &lt; certs.length; i++) {
241                     System.out.println(certs[0]);
242                 }
243 
244                 in.close();
245             } catch (SSLException e) {
246                 if (in != null)
247                     in.close();
248                 throw e;
249             }
250             System.out.println(&quot;Client reports:  SUCCESS&quot;);
251         } finally {
252             HttpsURLConnection.setDefaultHostnameVerifier(reservedHV);
253         }
254     }
255 
256     static class NameVerifier implements HostnameVerifier {
257         public boolean verify(String hostname, SSLSession session) {
258             System.out.println(
259                 &quot;HostnameVerifier: returning true&quot;);
260             return true;
261         }
262     }
263 
264     /*
265      * =============================================================
266      * The remainder is just support stuff
267      */
268 
269     // use any free port by default
270     volatile int serverPort = 0;
271 
272     volatile Exception serverException = null;
273     volatile Exception clientException = null;
274 
275     public static void main(String[] args) throws Exception {
276         String keyFilename =
277             System.getProperty(&quot;test.src&quot;, &quot;./&quot;) + &quot;/&quot; + pathToStores +
278                 &quot;/&quot; + keyStoreFile;
279         String trustFilename =
280             System.getProperty(&quot;test.src&quot;, &quot;./&quot;) + &quot;/&quot; + pathToStores +
281                 &quot;/&quot; + trustStoreFile;
282 
283         System.setProperty(&quot;javax.net.ssl.keyStore&quot;, keyFilename);
284         System.setProperty(&quot;javax.net.ssl.keyStorePassword&quot;, passwd);
285         System.setProperty(&quot;javax.net.ssl.trustStore&quot;, trustFilename);
286         System.setProperty(&quot;javax.net.ssl.trustStorePassword&quot;, passwd);
287 
288         if (debug)
289             System.setProperty(&quot;javax.net.debug&quot;, &quot;all&quot;);
290 
291         /*
292          * Start the tests.
293          */
294         new JavaxHTTPSConnection();
295     }
296 
297     Thread clientThread = null;
298     Thread serverThread = null;
299 
300     /*
301      * Primary constructor, used to drive remainder of the test.
302      *
303      * Fork off the other side, then do your work.
304      */
305     JavaxHTTPSConnection() throws Exception {
306         if (separateServerThread) {
307             startServer(true);
308             startClient(false);
309         } else {
310             startClient(true);
311             startServer(false);
312         }
313 
314         /*
315          * Wait for other side to close down.
316          */
317         if (separateServerThread) {
318             serverThread.join();
319         } else {
320             clientThread.join();
321         }
322 
323         /*
324          * When we get here, the test is pretty much over.
325          *
326          * If the main thread excepted, that propagates back
327          * immediately.  If the other thread threw an exception, we
328          * should report back.
329          */
330         if (serverException != null) {
331             System.out.print(&quot;Server Exception:&quot;);
332             throw serverException;
333         }
334         if (clientException != null) {
335             System.out.print(&quot;Client Exception:&quot;);
336             throw clientException;
337         }
338     }
339 
340     void startServer(boolean newThread) throws Exception {
341         if (newThread) {
342             serverThread = new Thread() {
343                 public void run() {
344                     try {
345                         doServerSide();
346                     } catch (Exception e) {
347                         /*
348                          * Our server thread just died.
349                          *
350                          * Release the client, if not active already...
351                          */
352                         System.err.println(&quot;Server died...&quot;);
353                         serverReady = true;
354                         serverException = e;
355                     }
356                 }
357             };
358             serverThread.start();
359         } else {
360             doServerSide();
361         }
362     }
363 
364     void startClient(boolean newThread) throws Exception {
365         if (newThread) {
366             clientThread = new Thread() {
367                 public void run() {
368                     try {
369                         doClientSide();
370                     } catch (Exception e) {
371                         /*
372                          * Our client thread just died.
373                          */
374                         System.err.println(&quot;Client died...&quot;);
375                         clientException = e;
376                     }
377                 }
378             };
379             clientThread.start();
380         } else {
381             doClientSide();
382         }
383     }
384 }
    </pre>
  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New test/jdk/sun/net/www/protocol/http/ChunkedErrorStream.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2006, 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 /*
 25  * @test
 26  * @bug 6488669 6595324 6993490
 27  * @library /test/lib
 28  * @modules jdk.httpserver
 29  * @run main/othervm ChunkedErrorStream
 30  * @summary Chunked ErrorStream tests
 31  */
 32 
 33 import java.net.*;
 34 import java.io.*;
 35 import com.sun.net.httpserver.*;
 36 import jdk.test.lib.net.URIBuilder;
 37 
 38 /**
 39  * Part 1: 6488669
 40  * 1) Http server that responds with an error code (&gt;=400)
 41  *    and a chunked response body. It also indicates that
 42  *    the connection will be closed.
 43  * 2) Client sends request to server and tries to
 44  *    getErrorStream(). Some data must be able to be read
 45  *    from the errorStream.
 46  *
 47  * Part 2: 6595324
 48  * 1) Http server that responds with an error code (&gt;=400)
 49  *    and a chunked response body greater than
 50  *    sun.net.http.errorstream.bufferSize, 4K + 10 bytes.
 51  * 2) Client sends request to server and tries to
 52  *    getErrorStream(). 4K + 10 bytes must be read from
 53  *    the errorStream.
 54  *
 55  * Part 3: 6993490
 56  *    Reuse persistent connection from part 2, the error stream
 57  *    buffering will have set a reduced timeout on the socket and
 58  *    tried to reset it to the default, infinity. Client must not
 59  *    throw a timeout exception. If it does, it indicates that the
 60  *    default timeout was not reset correctly.
 61  *    If no timeout exception is thrown, it does not guarantee that
 62  *    the timeout was reset correctly, as there is a potential race
 63  *    between the sleeping server and the client thread. Typically,
 64  *    1000 millis has been enought to reliable reproduce this problem
 65  *    since the error stream buffering sets the timeout to 60 millis.
 66  */
 67 
 68 public class ChunkedErrorStream
 69 {
 70     com.sun.net.httpserver.HttpServer httpServer;
 71 
 72     static {
 73         // Enable ErrorStream buffering
 74         System.getProperties().setProperty(&quot;sun.net.http.errorstream.enableBuffering&quot;, &quot;true&quot;);
 75 
 76         // No need to set this as 4K is the default
 77         // System.getProperties().setProperty(&quot;sun.net.http.errorstream.bufferSize&quot;, &quot;4096&quot;);
 78     }
 79 
 80     public static void main(String[] args) {
 81         new ChunkedErrorStream();
 82     }
 83 
 84     public ChunkedErrorStream() {
 85         try {
 86             startHttpServer();
 87             doClient();
 88         } catch (IOException ioe) {
 89             ioe.printStackTrace();
 90         }  finally {
 91             httpServer.stop(1);
 92         }
 93     }
 94 
 95     void doClient() {
 96         for (int times=0; times&lt;3; times++) {
 97             HttpURLConnection uc = null;
 98             try {
 99                 String path = &quot;/test/&quot;;
100                 if (times == 0) {
101                     path += &quot;first&quot;;
102                 } else {
103                     path += &quot;second&quot;;
104                 }
105 
106                 URL url = URIBuilder.newBuilder()
107                         .scheme(&quot;http&quot;)
108                         .host(httpServer.getAddress().getAddress())
109                         .port(httpServer.getAddress().getPort())
110                         .path(path)
111                         .toURLUnchecked();
112 
113                 System.out.println(&quot;Trying &quot; + url);
114                 uc = (HttpURLConnection)url.openConnection();
115                 uc.getInputStream();
116 
117                 throw new RuntimeException(&quot;Failed: getInputStream should throw and IOException&quot;);
118             }  catch (IOException e) {
119                 if (e instanceof SocketTimeoutException) {
120                     e.printStackTrace();
121                     throw new RuntimeException(&quot;Failed: SocketTimeoutException should not happen&quot;);
122                 }
123 
124                 // This is what we expect to happen.
125                 InputStream es = uc.getErrorStream();
126                 byte[] ba = new byte[1024];
127                 int count = 0, ret;
128                 try {
129                     while ((ret = es.read(ba)) != -1)
130                         count += ret;
131                     es.close();
132                 } catch  (IOException ioe) {
133                     ioe.printStackTrace();
134                 }
135 
136                 if (count == 0)
137                     throw new RuntimeException(&quot;Failed: ErrorStream returning 0 bytes&quot;);
138 
139                 if (times &gt;= 1 &amp;&amp; count != (4096+10))
140                     throw new RuntimeException(&quot;Failed: ErrorStream returning &quot; + count +
141                                                  &quot; bytes. Expecting &quot; + (4096+10));
142 
143                 System.out.println(&quot;Read &quot; + count + &quot; bytes from the errorStream&quot;);
144             }
145         }
146     }
147 
148     /**
149      * Http Server
150      */
151     void startHttpServer() throws IOException {
152         InetAddress lba = InetAddress.getLoopbackAddress();
153         InetSocketAddress addr = new InetSocketAddress(lba, 0);
154         httpServer = com.sun.net.httpserver.HttpServer.create(addr, 0);
155 
156         // create HttpServer context
157         httpServer.createContext(&quot;/test/first&quot;, new FirstHandler());
158         httpServer.createContext(&quot;/test/second&quot;, new SecondHandler());
159 
160         httpServer.start();
161     }
162 
163     class FirstHandler implements HttpHandler {
164         public void handle(HttpExchange t) throws IOException {
165             InputStream is = t.getRequestBody();
166             byte[] ba = new byte[1024];
167             while (is.read(ba) != -1);
168             is.close();
169 
170             Headers resHeaders = t.getResponseHeaders();
171             resHeaders.add(&quot;Connection&quot;, &quot;close&quot;);
172             t.sendResponseHeaders(404, 0);
173             OutputStream os = t.getResponseBody();
174 
175             // actual data doesn&#39;t matter. Just send 2K worth.
176             byte b = &#39;a&#39;;
177             for (int i=0; i&lt;2048; i++)
178                 os.write(b);
179 
180             os.close();
181             t.close();
182         }
183     }
184 
185     static class SecondHandler implements HttpHandler {
186         /* count greater than 0, slow response */
187         static int count = 0;
188 
189         public void handle(HttpExchange t) throws IOException {
190             InputStream is = t.getRequestBody();
191             byte[] ba = new byte[1024];
192             while (is.read(ba) != -1);
193             is.close();
194 
195             if (count &gt; 0) {
196                 System.out.println(&quot;server sleeping...&quot;);
197                 try { Thread.sleep(1000); } catch(InterruptedException e) {}
198             }
199             count++;
200 
201             t.sendResponseHeaders(404, 0);
202             OutputStream os = t.getResponseBody();
203 
204             // actual data doesn&#39;t matter. Just send more than 4K worth
205             byte b = &#39;a&#39;;
206             for (int i=0; i&lt;(4096+10); i++)
207                 os.write(b);
208 
209             os.close();
210             t.close();
211         }
212     }
213 }
    </pre>
  </body>
</html>
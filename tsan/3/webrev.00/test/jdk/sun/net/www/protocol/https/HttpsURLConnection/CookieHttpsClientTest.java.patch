diff a/test/jdk/sun/net/www/protocol/https/HttpsURLConnection/CookieHttpsClientTest.java b/test/jdk/sun/net/www/protocol/https/HttpsURLConnection/CookieHttpsClientTest.java
--- a/test/jdk/sun/net/www/protocol/https/HttpsURLConnection/CookieHttpsClientTest.java
+++ b/test/jdk/sun/net/www/protocol/https/HttpsURLConnection/CookieHttpsClientTest.java
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2012, 2013, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2012, 2019, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.
@@ -27,25 +27,29 @@
 /*
  * @test
  * @bug 7129083
  * @summary Cookiemanager does not store cookies if url is read
  *          before setting cookiemanager
+ * @library /test/lib
  * @run main/othervm CookieHttpsClientTest
  */
 
 import java.net.CookieHandler;
 import java.net.CookieManager;
 import java.net.CookiePolicy;
+import java.net.InetAddress;
 import java.net.URL;
 import java.io.InputStream;
 import java.io.IOException;
 import javax.net.ssl.HostnameVerifier;
 import javax.net.ssl.HttpsURLConnection;
+import javax.net.ssl.SSLHandshakeException;
 import javax.net.ssl.SSLServerSocket;
 import javax.net.ssl.SSLServerSocketFactory;
 import javax.net.ssl.SSLSession;
 import javax.net.ssl.SSLSocket;
+import jdk.test.lib.net.URIBuilder;
 
 public class CookieHttpsClientTest {
     static final int TIMEOUT = 10 * 1000;
 
     static final String replyString = "HTTP/1.1 200 OK\r\n" +
@@ -89,14 +93,15 @@
      *
      * If the server prematurely exits, serverReady will be set to true
      * to avoid infinite hangs.
      */
     void doServerSide() throws Exception {
+        InetAddress loopback = InetAddress.getLoopbackAddress();
         SSLServerSocketFactory sslssf =
             (SSLServerSocketFactory) SSLServerSocketFactory.getDefault();
         SSLServerSocket sslServerSocket =
-            (SSLServerSocket) sslssf.createServerSocket(serverPort);
+            (SSLServerSocket) sslssf.createServerSocket(serverPort, 0, loopback);
         serverPort = sslServerSocket.getLocalPort();
 
         /*
          * Signal Client, we're ready for his connect.
          */
@@ -135,14 +140,21 @@
         HttpsURLConnection.setDefaultHostnameVerifier(new HostnameVerifier() {
             public boolean verify(String hostname, SSLSession session) {
                 return true;
             }});
 
-        URL url = new URL("https://localhost:" + serverPort +"/");
+        URL url = URIBuilder.newBuilder()
+                  .scheme("https")
+                  .loopback()
+                  .port(serverPort)
+                  .path("/")
+                  .toURL();
+
+        System.out.println("Client ready to connect to: " + url);
 
         // Run without a CookieHandler first
-        InputStream in = url.openConnection().getInputStream();
+        InputStream in = url.openConnection(java.net.Proxy.NO_PROXY).getInputStream();
         while (in.read() != -1);  // read response body so connection can be reused
 
         // Set a CookeHandler and retest using the HttpClient from the KAC
         CookieManager manager = new CookieManager(null, CookiePolicy.ACCEPT_ALL);
         CookieHandler.setDefault(manager);
@@ -181,10 +193,14 @@
     volatile int serverPort = 0;
 
     volatile Exception serverException = null;
     volatile Exception clientException = null;
 
+    private boolean sslConnectionFailed() {
+        return clientException instanceof SSLHandshakeException;
+    }
+
     public static void main(String args[]) throws Exception {
         String keyFilename =
             System.getProperty("test.src", ".") + "/" + pathToStores +
                 "/" + keyStoreFile;
         String trustFilename =
@@ -227,11 +243,15 @@
         /*
          * Wait for other side to close down.
          */
         if (separateServerThread) {
             if (serverThread != null) {
-                serverThread.join();
+                // don't join the server thread if the
+                // client failed to connect
+                if (!sslConnectionFailed()) {
+                    serverThread.join();
+                }
             }
         } else {
             if (clientThread != null) {
                 clientThread.join();
             }
@@ -257,11 +277,11 @@
         /*
          * Check various exception conditions.
          */
         if ((local != null) && (remote != null)) {
             // If both failed, return the curthread's exception.
-            local.initCause(remote);
+            local.addSuppressed(remote);
             exception = local;
         } else if (local != null) {
             exception = local;
         } else if (remote != null) {
             exception = remote;
@@ -272,11 +292,11 @@
         /*
          * If there was an exception *AND* a startException,
          * output it.
          */
         if (exception != null) {
-            if (exception != startException) {
+            if (exception != startException && startException != null) {
                 exception.addSuppressed(startException);
             }
             throw exception;
         }
 
@@ -321,20 +341,21 @@
                         doClientSide();
                     } catch (Exception e) {
                         /*
                          * Our client thread just died.
                          */
-                        System.err.println("Client died...");
+                        System.err.println("Client died: " + e);
                         clientException = e;
                     }
                 }
             };
             clientThread.start();
         } else {
             try {
                 doClientSide();
             } catch (Exception e) {
+                System.err.println("Client died: " + e);
                 clientException = e;
             }
         }
     }
 }

<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old test/jdk/sun/net/www/protocol/https/NewImpl/JavaxHostnameVerifier.java</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2001, 2018, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 // SunJSSE does not support dynamic system properties, no way to re-use
 25 // system properties in samevm/agentvm mode.
 26 
 27 /*
 28  * @test
 29  * @bug 4474255 4484246
 30  * @summary When an application enables anonymous SSL cipher suite,
 31  *        Hostname verification is not required
 32  * @run main/othervm JavaxHostnameVerifier
 33  */
 34 
 35 import java.io.*;
 36 import java.net.*;
 37 import java.security.Security;
 38 import java.security.cert.*;
 39 import javax.net.ssl.*;
 40 
 41 /**
 42  * Use javax.net.ssl.HostnameVerifier
 43  */
 44 public class JavaxHostnameVerifier {
 45 
 46     /*
 47      * =============================================================
 48      * Set the various variables needed for the tests, then
 49      * specify what tests to run on each side.
 50      */
 51 
 52     /*
 53      * Should we run the client or server in a separate thread?
 54      * Both sides can throw exceptions, but do you have a preference
 55      * as to which side should be the main thread.
 56      */
 57     static boolean separateServerThread = true;
 58 
 59     /*
 60      * Is the server ready to serve?
 61      */
 62     volatile static boolean serverReady = false;
 63 
 64     /*
 65      * Turn on SSL debugging?
 66      */
 67     static boolean debug = false;
 68 
 69     /*
 70      * If the client or server is doing some kind of object creation
 71      * that the other side depends on, and that thread prematurely
 72      * exits, you may experience a hang.  The test harness will
 73      * terminate all hung threads after its timeout has expired,
 74      * currently 3 minutes by default, but you might try to be
 75      * smart about it....
 76      */
 77 
 78     /**
 79      * Returns the path to the file obtained from
 80      * parsing the HTML header.
 81      */
 82     private static String getPath(DataInputStream in)
 83         throws IOException
 84     {
 85         String line = in.readLine();
 86         String path = &quot;&quot;;
 87         // extract class from GET line
 88         if (line == null)
 89                 return null;
 90 
 91         if (line.startsWith(&quot;GET /&quot;)) {
 92             line = line.substring(5, line.length()-1).trim();
 93             int index = line.indexOf(&#39; &#39;);
 94             if (index != -1) {
 95                 path = line.substring(0, index);
 96             }
 97         }
 98 
 99         // eat the rest of header
100         do {
101             line = in.readLine();
102         } while ((line.length() != 0) &amp;&amp;
103                  (line.charAt(0) != &#39;\r&#39;) &amp;&amp; (line.charAt(0) != &#39;\n&#39;));
104 
105         if (path.length() != 0) {
106             return path;
107         } else {
108             throw new IOException(&quot;Malformed Header&quot;);
109         }
110     }
111 
112     /**
113      * Returns an array of bytes containing the bytes for
114      * the file represented by the argument &lt;b&gt;path&lt;/b&gt;.
115      *
116      * In our case, we just pretend to send something back.
117      *
118      * @return the bytes for the file
119      * @exception FileNotFoundException if the file corresponding
120      * to &lt;b&gt;path&lt;/b&gt; could not be loaded.
121      */
122     private byte[] getBytes(String path)
123         throws IOException
124     {
125         return &quot;Hello world, I am here&quot;.getBytes();
126     }
127 
128     /*
129      * Define the server side of the test.
130      *
131      * If the server prematurely exits, serverReady will be set to true
132      * to avoid infinite hangs.
133      */
134     void doServerSide() throws Exception {
135 
136         SSLServerSocketFactory sslssf =
137           (SSLServerSocketFactory) SSLServerSocketFactory.getDefault();
138         SSLServerSocket sslServerSocket =
139             (SSLServerSocket) sslssf.createServerSocket(serverPort);
140         serverPort = sslServerSocket.getLocalPort();
141 
142         String ciphers[]= { &quot;SSL_DH_anon_WITH_3DES_EDE_CBC_SHA&quot; };
143         sslServerSocket.setEnabledCipherSuites(ciphers);
144 
145         /*
146          * Signal Client, we&#39;re ready for his connect.
147          */
148         serverReady = true;
149 
150         SSLSocket sslSocket = (SSLSocket) sslServerSocket.accept();
151         DataOutputStream out =
152                 new DataOutputStream(sslSocket.getOutputStream());
153 
154         try {
155              // get path to class file from header
156              DataInputStream in =
157                         new DataInputStream(sslSocket.getInputStream());
158              String path = getPath(in);
159              // retrieve bytecodes
160              byte[] bytecodes = getBytes(path);
161              // send bytecodes in response (assumes HTTP/1.0 or later)
162              try {
163                 out.writeBytes(&quot;HTTP/1.0 200 OK\r\n&quot;);
164                 out.writeBytes(&quot;Content-Length: &quot; + bytecodes.length + &quot;\r\n&quot;);
165                 out.writeBytes(&quot;Content-Type: text/html\r\n\r\n&quot;);
166                 out.write(bytecodes);
167                 out.flush();
168              } catch (IOException ie) {
169                 ie.printStackTrace();
170                 return;
171              }
172 
173         } catch (Exception e) {
174              e.printStackTrace();
175              // write out error response
176              out.writeBytes(&quot;HTTP/1.0 400 &quot; + e.getMessage() + &quot;\r\n&quot;);
177              out.writeBytes(&quot;Content-Type: text/html\r\n\r\n&quot;);
178              out.flush();
179         } finally {
180              // close the socket
181              System.out.println(&quot;Server closing socket&quot;);
182              sslSocket.close();
183              serverReady = false;
184         }
185     }
186 
187     /*
188      * Define the client side of the test.
189      *
190      * If the server prematurely exits, serverReady will be set to true
191      * to avoid infinite hangs.
192      */
193     void doClientSide() throws Exception {
194         /*
195          * Wait for server to get started.
196          */
197         while (!serverReady) {
198             Thread.sleep(50);
199         }
200 
201         System.setProperty(&quot;https.cipherSuites&quot;,
202                 &quot;SSL_DH_anon_WITH_3DES_EDE_CBC_SHA&quot;);
203 
204         // use the default hostname verifier
205 
206         URL url = new URL(&quot;https://&quot; + &quot;localhost:&quot; + serverPort +
207                                 &quot;/etc/hosts&quot;);
208         URLConnection urlc = url.openConnection();
209 
210         if (!(urlc instanceof javax.net.ssl.HttpsURLConnection)) {
211             throw new Exception(
212                 &quot;URLConnection ! instanceof javax.net.ssl.HttpsURLConnection&quot;);
213         }
214 
215         BufferedReader in = null;
216         try {
217             in = new BufferedReader(new InputStreamReader(
218                                urlc.getInputStream()));
219             String inputLine;
220             System.out.print(&quot;Client reading... &quot;);
221             while ((inputLine = in.readLine()) != null)
222                 System.out.println(inputLine);
223             System.out.println(&quot;Cipher Suite: &quot; +
224                 ((HttpsURLConnection)urlc).getCipherSuite());
225             in.close();
226         } catch (SSLException e) {
227             if (in != null)
228                 in.close();
229             throw e;
230         }
231         System.out.println(&quot;Client reports:  SUCCESS&quot;);
232     }
233 
234     /*
235      * =============================================================
236      * The remainder is just support stuff
237      */
238 
239     // use any free port by default
240     volatile int serverPort = 0;
241 
242     volatile Exception serverException = null;
243     volatile Exception clientException = null;
244 
245     public static void main(String[] args) throws Exception {
246         // re-enable 3DES
247         Security.setProperty(&quot;jdk.tls.disabledAlgorithms&quot;, &quot;&quot;);
248 
249         if (debug)
250             System.setProperty(&quot;javax.net.debug&quot;, &quot;all&quot;);
251 
252         /*
253          * Start the tests.
254          */
255         new JavaxHostnameVerifier();
256     }
257 
258     Thread clientThread = null;
259     Thread serverThread = null;
260 
261     /*
262      * Primary constructor, used to drive remainder of the test.
263      *
264      * Fork off the other side, then do your work.
265      */
266     JavaxHostnameVerifier() throws Exception {
267         if (separateServerThread) {
268             startServer(true);
269             startClient(false);
270         } else {
271             startClient(true);
272             startServer(false);
273         }
274 
275         /*
276          * Wait for other side to close down.
277          */
278         if (separateServerThread) {
279             serverThread.join();
280         } else {
281             clientThread.join();
282         }
283 
284         /*
285          * When we get here, the test is pretty much over.
286          *
287          * If the main thread excepted, that propagates back
288          * immediately.  If the other thread threw an exception, we
289          * should report back.
290          */
291         if (serverException != null) {
292             System.out.print(&quot;Server Exception:&quot;);
293             throw serverException;
294         }
295         if (clientException != null) {
296             System.out.print(&quot;Client Exception:&quot;);
297             throw clientException;
298         }
299     }
300 
301     void startServer(boolean newThread) throws Exception {
302         if (newThread) {
303             serverThread = new Thread() {
304                 public void run() {
305                     try {
306                         doServerSide();
307                     } catch (Exception e) {
308                         /*
309                          * Our server thread just died.
310                          *
311                          * Release the client, if not active already...
312                          */
313                         System.err.println(&quot;Server died...&quot;);
314                         serverReady = true;
315                         serverException = e;
316                     }
317                 }
318             };
319             serverThread.start();
320         } else {
321             doServerSide();
322         }
323     }
324 
325     void startClient(boolean newThread) throws Exception {
326         if (newThread) {
327             clientThread = new Thread() {
328                 public void run() {
329                     try {
330                         doClientSide();
331                     } catch (Exception e) {
332                         /*
333                          * Our client thread just died.
334                          */
335                         System.err.println(&quot;Client died...&quot;);
336                         clientException = e;
337                     }
338                 }
339             };
340             clientThread.start();
341         } else {
342             doClientSide();
343         }
344     }
345 }
    </pre>
  </body>
</html>
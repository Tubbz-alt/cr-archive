<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old test/jdk/sun/net/www/httptest/TestHttpServer.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2002, 2012, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 import java.net.*;
 25 import java.io.*;
 26 import java.nio.*;
 27 import java.nio.channels.*;
 28 import sun.net.www.MessageHeader;
 29 import java.util.*;
 30 
 31 /**
 32  * This class implements a simple HTTP server. It uses multiple threads to
 33  * handle connections in parallel, and also multiple connections/requests
 34  * can be handled per thread.
 35  * &lt;p&gt;
 36  * It must be instantiated with a {@link HttpCallback} object to which
 37  * requests are given and must be handled.
 38  * &lt;p&gt;
 39  * Simple synchronization between the client(s) and server can be done
 40  * using the {@link #waitForCondition(String)}, {@link #setCondition(String)} and
 41  * {@link #rendezvous(String,int)} methods.
 42  *
 43  * NOTE NOTE NOTE NOTE NOTE NOTE NOTE
 44  *
 45  * If changes are made here, please sure they are propagated to
 46  * the HTTPS equivalent in the JSSE regression test suite.
 47  *
 48  * NOTE NOTE NOTE NOTE NOTE NOTE NOTE
 49  */
 50 
 51 public class TestHttpServer {
 52 
 53     ServerSocketChannel schan;
 54     int threads;
 55     int cperthread;
 56     HttpCallback cb;
 57     Server[] servers;
 58 
 59     /**
 60      * Create a &lt;code&gt;TestHttpServer&lt;code&gt; instance with the specified callback object
 61      * for handling requests. One thread is created to handle requests,
 62      * and up to ten TCP connections will be handled simultaneously.
 63      * @param cb the callback object which is invoked to handle each
 64      *  incoming request
 65      */
 66 
 67     public TestHttpServer (HttpCallback cb) throws IOException {
 68         this (cb, 1, 10, 0);
 69     }
 70 
 71     /**
 72      * Create a &lt;code&gt;TestHttpServer&lt;code&gt; instance with the specified number of
 73      * threads and maximum number of connections per thread. This functions
 74      * the same as the 4 arg constructor, where the port argument is set to zero.
 75      * @param cb the callback object which is invoked to handle each
 76      *     incoming request
 77      * @param threads the number of threads to create to handle requests
 78      *     in parallel
 79      * @param cperthread the number of simultaneous TCP connections to
 80      *     handle per thread
 81      */
 82 
 83     public TestHttpServer (HttpCallback cb, int threads, int cperthread)
 84         throws IOException {
 85         this (cb, threads, cperthread, 0);
 86     }
 87 
 88     /**
 89      * Create a &lt;code&gt;TestHttpServer&lt;code&gt; instance with the specified number
 90      * of threads and maximum number of connections per thread and running on
 91      * the specified port. The specified number of threads are created to
 92      * handle incoming requests, and each thread is allowed
 93      * to handle a number of simultaneous TCP connections.
 94      * @param cb the callback object which is invoked to handle
 95      *  each incoming request
 96      * @param threads the number of threads to create to handle
 97      *  requests in parallel
 98      * @param cperthread the number of simultaneous TCP connections
 99      *  to handle per thread
100      * @param port the port number to bind the server to. &lt;code&gt;Zero&lt;/code&gt;
101      *  means choose any free port.
102      */
103 
104     public TestHttpServer (HttpCallback cb, int threads, int cperthread, int port)
105         throws IOException {
106         schan = ServerSocketChannel.open ();
107         InetSocketAddress addr = new InetSocketAddress (port);
108         schan.socket().bind (addr);
109         this.threads = threads;
110         this.cb = cb;
111         this.cperthread = cperthread;
112         servers = new Server [threads];
113         for (int i=0; i&lt;threads; i++) {
114             servers[i] = new Server (cb, schan, cperthread);
115             servers[i].start();
116         }
117     }
118 
119     /**
120      * Tell all threads in the server to exit within 5 seconds.
121      * This is an abortive termination. Just prior to the thread exiting
122      * all channels in that thread waiting to be closed are forceably closed.
123      * @throws InterruptedException
124      */
125 
126     public void terminate () {
127         for (int i=0; i&lt;threads; i++) {
128             servers[i].terminate ();
129         }
130 
131         for (int i = 0; i &lt; threads; i++) {
132             try {
133                 servers[i].join();
134             } catch (InterruptedException e) {
135                 System.err.println(&quot;Unexpected InterruptedException during terminating server&quot;);
136                 throw new RuntimeException(e);
137             }
138         }
139     }
140 
141     /**
142      * return the local port number to which the server is bound.
143      * @return the local port number
144      */
145 
146     public int getLocalPort () {
147         return schan.socket().getLocalPort ();
148     }
149 
150     static class Server extends Thread {
151 
152         ServerSocketChannel schan;
153         Selector selector;
154         SelectionKey listenerKey;
155         SelectionKey key; /* the current key being processed */
156         HttpCallback cb;
157         ByteBuffer consumeBuffer;
158         int maxconn;
159         int nconn;
160         ClosedChannelList clist;
161         volatile boolean shutdown;
162 
163         Server (HttpCallback cb, ServerSocketChannel schan, int maxconn) {
164             this.schan = schan;
165             this.maxconn = maxconn;
166             this.cb = cb;
167             nconn = 0;
168             consumeBuffer = ByteBuffer.allocate (512);
169             clist = new ClosedChannelList ();
170             try {
171                 selector = Selector.open ();
172                 schan.configureBlocking (false);
173                 listenerKey = schan.register (selector, SelectionKey.OP_ACCEPT);
174             } catch (IOException e) {
175                 System.err.println (&quot;Server could not start: &quot; + e);
176             }
177         }
178 
179         /* Stop the thread as soon as possible */
180         public void terminate () {
181             shutdown = true;
182         }
183 
184         public void run ()  {
185             try {
186                 while (true) {
187                     selector.select(1000);
188                     Set&lt;SelectionKey&gt; selected = selector.selectedKeys();
189                     Iterator&lt;SelectionKey&gt; iter = selected.iterator();
190                     while (iter.hasNext()) {
191                         key = iter.next();
192                         if (key.equals (listenerKey)) {
193                             SocketChannel sock = schan.accept ();
194                             if (sock == null) {
195                                 /* false notification */
196                                 iter.remove();
197                                 continue;
198                             }
199                             sock.configureBlocking (false);
200                             sock.register (selector, SelectionKey.OP_READ);
201                             nconn ++;
202                             System.out.println(&quot;SERVER: new connection. chan[&quot; + sock + &quot;]&quot;);
203                             if (nconn == maxconn) {
204                                 /* deregister */
205                                 listenerKey.cancel ();
206                                 listenerKey = null;
207                             }
208                         } else {
209                             if (key.isReadable()) {
210                                 boolean closed;
211                                 SocketChannel chan = (SocketChannel) key.channel();
212                                 System.out.println(&quot;SERVER: connection readable. chan[&quot; + chan + &quot;]&quot;);
213                                 if (key.attachment() != null) {
214                                     System.out.println(&quot;Server: consume&quot;);
215                                     closed = consume (chan);
216                                 } else {
217                                     closed = read (chan, key);
218                                 }
219                                 if (closed) {
220                                     chan.close ();
221                                     key.cancel ();
222                                     if (nconn == maxconn) {
223                                         listenerKey = schan.register (selector, SelectionKey.OP_ACCEPT);
224                                     }
225                                     nconn --;
226                                 }
227                             }
228                         }
229                         iter.remove();
230                     }
231                     clist.check();
232                     if (shutdown) {
233                         System.out.println(&quot;Force to Shutdown&quot;);
234                         SelectionKey sKey = schan.keyFor(selector);
235                         if (sKey != null) {
236                             sKey.cancel();
237                         }
238 
239                         clist.terminate ();
240                         selector.close();
241                         schan.socket().close();
242                         schan.close();
243                         return;
244                     }
245                 }
246             } catch (IOException e) {
247                 System.out.println (&quot;Server exception: &quot; + e);
248                 // TODO finish
249             }
250         }
251 
252         /* read all the data off the channel without looking at it
253              * return true if connection closed
254              */
255         boolean consume (SocketChannel chan) {
256             try {
257                 consumeBuffer.clear ();
258                 int c = chan.read (consumeBuffer);
259                 if (c == -1)
260                     return true;
261             } catch (IOException e) {
262                 return true;
263             }
264             return false;
265         }
266 
267         /* return true if the connection is closed, false otherwise */
268 
269         private boolean read (SocketChannel chan, SelectionKey key) {
270             HttpTransaction msg;
271             boolean res;
272             try {
273                 InputStream is = new BufferedInputStream (new NioInputStream (chan));
274                 String requestline = readLine (is);
275                 MessageHeader mhead = new MessageHeader (is);
276                 String clen = mhead.findValue (&quot;Content-Length&quot;);
277                 String trferenc = mhead.findValue (&quot;Transfer-Encoding&quot;);
278                 String data = null;
279                 if (trferenc != null &amp;&amp; trferenc.equals (&quot;chunked&quot;))
280                     data = new String (readChunkedData (is));
281                 else if (clen != null)
282                     data = new String (readNormalData (is, Integer.parseInt (clen)));
283                 String[] req = requestline.split (&quot; &quot;);
284                 if (req.length &lt; 2) {
285                     /* invalid request line */
286                     return false;
287                 }
288                 String cmd = req[0];
289                 URI uri = null;
290                 try {
291                     uri = new URI (req[1]);
292                     msg = new HttpTransaction (this, cmd, uri, mhead, data, null, key);
293                     cb.request (msg);
294                 } catch (URISyntaxException e) {
295                     System.err.println (&quot;Invalid URI: &quot; + e);
296                     msg = new HttpTransaction (this, cmd, null, null, null, null, key);
297                     msg.sendResponse (501, &quot;Whatever&quot;);
298                 }
299                 res = false;
300             } catch (IOException e) {
301                 res = true;
302             }
303             return res;
304         }
305 
306         byte[] readNormalData (InputStream is, int len) throws IOException {
307             byte [] buf  = new byte [len];
308             int c, off=0, remain=len;
309             while (remain &gt; 0 &amp;&amp; ((c=is.read (buf, off, remain))&gt;0)) {
310                 remain -= c;
311                 off += c;
312             }
313             return buf;
314         }
315 
316         private void readCRLF(InputStream is) throws IOException {
317             int cr = is.read();
318             int lf = is.read();
319 
320             if (((cr &amp; 0xff) != 0x0d) ||
321                 ((lf &amp; 0xff) != 0x0a)) {
322                 throw new IOException(
323                     &quot;Expected &lt;CR&gt;&lt;LF&gt;:  got &#39;&quot; + cr + &quot;/&quot; + lf + &quot;&#39;&quot;);
324             }
325         }
326 
327         byte[] readChunkedData (InputStream is) throws IOException {
328             LinkedList l = new LinkedList ();
329             int total = 0;
330             for (int len=readChunkLen(is); len!=0; len=readChunkLen(is)) {
331                 l.add (readNormalData(is, len));
332                 total += len;
333                 readCRLF(is);  // CRLF at end of chunk
334             }
335             readCRLF(is); // CRLF at end of Chunked Stream.
336             byte[] buf = new byte [total];
337             Iterator i = l.iterator();
338             int x = 0;
339             while (i.hasNext()) {
340                 byte[] b = (byte[])i.next();
341                 System.arraycopy (b, 0, buf, x, b.length);
342                 x += b.length;
343             }
344             return buf;
345         }
346 
347         private int readChunkLen (InputStream is) throws IOException {
348             int c, len=0;
349             boolean done=false, readCR=false;
350             while (!done) {
351                 c = is.read ();
352                 if (c == &#39;\n&#39; &amp;&amp; readCR) {
353                     done = true;
354                 } else {
355                     if (c == &#39;\r&#39; &amp;&amp; !readCR) {
356                         readCR = true;
357                     } else {
358                         int x=0;
359                         if (c &gt;= &#39;a&#39; &amp;&amp; c &lt;= &#39;f&#39;) {
360                             x = c - &#39;a&#39; + 10;
361                         } else if (c &gt;= &#39;A&#39; &amp;&amp; c &lt;= &#39;F&#39;) {
362                             x = c - &#39;A&#39; + 10;
363                         } else if (c &gt;= &#39;0&#39; &amp;&amp; c &lt;= &#39;9&#39;) {
364                             x = c - &#39;0&#39;;
365                         }
366                         len = len * 16 + x;
367                     }
368                 }
369             }
370             return len;
371         }
372 
373         private String readLine (InputStream is) throws IOException {
374             boolean done=false, readCR=false;
375             byte[] b = new byte [512];
376             int c, l = 0;
377 
378             while (!done) {
379                 c = is.read ();
380                 if (c == &#39;\n&#39; &amp;&amp; readCR) {
381                     done = true;
382                 } else {
383                     if (c == &#39;\r&#39; &amp;&amp; !readCR) {
384                         readCR = true;
385                     } else {
386                         b[l++] = (byte)c;
387                     }
388                 }
389             }
390             return new String (b);
391         }
392 
393         /** close the channel associated with the current key by:
394          * 1. shutdownOutput (send a FIN)
395          * 2. mark the key so that incoming data is to be consumed and discarded
396          * 3. After a period, close the socket
397          */
398 
399         synchronized void orderlyCloseChannel (SelectionKey key) throws IOException {
400             SocketChannel ch = (SocketChannel)key.channel ();
401             System.out.println(&quot;SERVER: orderlyCloseChannel chan[&quot; + ch + &quot;]&quot;);
402             ch.socket().shutdownOutput();
403             key.attach (this);
404             clist.add (key);
405         }
406 
407         synchronized void abortiveCloseChannel (SelectionKey key) throws IOException {
408             SocketChannel ch = (SocketChannel)key.channel ();
409             System.out.println(&quot;SERVER: abortiveCloseChannel chan[&quot; + ch + &quot;]&quot;);
410 
411             Socket s = ch.socket ();
412             s.setSoLinger (true, 0);
413             ch.close();
414         }
415     }
416 
417 
418     /**
419      * Implements blocking reading semantics on top of a non-blocking channel
420      */
421 
422     static class NioInputStream extends InputStream {
423         SocketChannel channel;
424         Selector selector;
425         ByteBuffer chanbuf;
426         SelectionKey key;
427         int available;
428         byte[] one;
429         boolean closed;
430         ByteBuffer markBuf; /* reads may be satisifed from this buffer */
431         boolean marked;
432         boolean reset;
433         int readlimit;
434 
435         public NioInputStream (SocketChannel chan) throws IOException {
436             this.channel = chan;
437             selector = Selector.open();
438             chanbuf = ByteBuffer.allocate (1024);
439             key = chan.register (selector, SelectionKey.OP_READ);
440             available = 0;
441             one = new byte[1];
442             closed = marked = reset = false;
443         }
444 
445         public synchronized int read (byte[] b) throws IOException {
446             return read (b, 0, b.length);
447         }
448 
449         public synchronized int read () throws IOException {
450             return read (one, 0, 1);
451         }
452 
453         public synchronized int read (byte[] b, int off, int srclen) throws IOException {
454 
455             int canreturn, willreturn;
456 
457             if (closed)
458                 return -1;
459 
460             if (reset) { /* satisfy from markBuf */
461                 canreturn = markBuf.remaining ();
462                 willreturn = canreturn&gt;srclen ? srclen : canreturn;
463                 markBuf.get(b, off, willreturn);
464                 if (canreturn == willreturn) {
465                     reset = false;
466                 }
467             } else { /* satisfy from channel */
468                 canreturn = available();
469                 if (canreturn == 0) {
470                     block ();
471                     canreturn = available();
472                 }
473                 willreturn = canreturn&gt;srclen ? srclen : canreturn;
474                 chanbuf.get(b, off, willreturn);
475                 available -= willreturn;
476 
477                 if (marked) { /* copy into markBuf */
478                     try {
479                         markBuf.put (b, off, willreturn);
480                     } catch (BufferOverflowException e) {
481                         marked = false;
482                     }
483                 }
484             }
485             return willreturn;
486         }
487 
488         public synchronized int available () throws IOException {
489             if (closed)
490                 throw new IOException (&quot;Stream is closed&quot;);
491 
492             if (reset)
493                 return markBuf.remaining();
494 
495             if (available &gt; 0)
496                 return available;
497 
498             chanbuf.clear ();
499             available = channel.read (chanbuf);
500             if (available &gt; 0)
501                 chanbuf.flip();
502             else if (available == -1)
503                 throw new IOException (&quot;Stream is closed&quot;);
504             return available;
505         }
506 
507         /**
508          * block() only called when available==0 and buf is empty
509          */
510         private synchronized void block () throws IOException {
511             //assert available == 0;
512             int n = selector.select ();
513             //assert n == 1;
514             selector.selectedKeys().clear();
515             available ();
516         }
517 
518         public void close () throws IOException {
519             if (closed)
520                 return;
521             channel.close ();
522             closed = true;
523         }
524 
525         public synchronized void mark (int readlimit) {
526             if (closed)
527                 return;
528             this.readlimit = readlimit;
529             markBuf = ByteBuffer.allocate (readlimit);
530             marked = true;
531             reset = false;
532         }
533 
534         public synchronized void reset () throws IOException {
535             if (closed )
536                 return;
537             if (!marked)
538                 throw new IOException (&quot;Stream not marked&quot;);
539             marked = false;
540             reset = true;
541             markBuf.flip ();
542         }
543     }
544 
545     static class NioOutputStream extends OutputStream {
546         SocketChannel channel;
547         ByteBuffer buf;
548         SelectionKey key;
549         Selector selector;
550         boolean closed;
551         byte[] one;
552 
553         public NioOutputStream (SocketChannel channel) throws IOException {
554             this.channel = channel;
555             selector = Selector.open ();
556             key = channel.register (selector, SelectionKey.OP_WRITE);
557             closed = false;
558             one = new byte [1];
559         }
560 
561         public synchronized void write (int b) throws IOException {
562             one[0] = (byte)b;
563             write (one, 0, 1);
564         }
565 
566         public synchronized void write (byte[] b) throws IOException {
567             write (b, 0, b.length);
568         }
569 
570         public synchronized void write (byte[] b, int off, int len) throws IOException {
571             if (closed)
572                 throw new IOException (&quot;stream is closed&quot;);
573 
574             buf = ByteBuffer.allocate (len);
575             buf.put (b, off, len);
576             buf.flip ();
577             int n;
578             while ((n = channel.write (buf)) &lt; len) {
579                 len -= n;
580                 if (len == 0)
581                     return;
582                 selector.select ();
583                 selector.selectedKeys().clear ();
584             }
585         }
586 
587         public void close () throws IOException {
588             if (closed)
589                 return;
590             channel.close ();
591             closed = true;
592         }
593     }
594 
595     /**
596      * Utilities for synchronization. A condition is
597      * identified by a string name, and is initialized
598      * upon first use (ie. setCondition() or waitForCondition()). Threads
599      * are blocked until some thread calls (or has called) setCondition() for the same
600      * condition.
601      * &lt;P&gt;
602      * A rendezvous built on a condition is also provided for synchronizing
603      * N threads.
604      */
605 
606     private static HashMap conditions = new HashMap();
607 
608     /*
609      * Modifiable boolean object
610      */
611     private static class BValue {
612         boolean v;
613     }
614 
615     /*
616      * Modifiable int object
617      */
618     private static class IValue {
619         int v;
620         IValue (int i) {
621             v =i;
622         }
623     }
624 
625 
626     private static BValue getCond (String condition) {
627         synchronized (conditions) {
628             BValue cond = (BValue) conditions.get (condition);
629             if (cond == null) {
630                 cond = new BValue();
631                 conditions.put (condition, cond);
632             }
633             return cond;
634         }
635     }
636 
637     /**
638      * Set the condition to true. Any threads that are currently blocked
639      * waiting on the condition, will be unblocked and allowed to continue.
640      * Threads that subsequently call waitForCondition() will not block.
641      * If the named condition did not exist prior to the call, then it is created
642      * first.
643      */
644 
645     public static void setCondition (String condition) {
646         BValue cond = getCond (condition);
647         synchronized (cond) {
648             if (cond.v) {
649                 return;
650             }
651             cond.v = true;
652             cond.notifyAll();
653         }
654     }
655 
656     /**
657      * If the named condition does not exist, then it is created and initialized
658      * to false. If the condition exists or has just been created and its value
659      * is false, then the thread blocks until another thread sets the condition.
660      * If the condition exists and is already set to true, then this call returns
661      * immediately without blocking.
662      */
663 
664     public static void waitForCondition (String condition) {
665         BValue cond = getCond (condition);
666         synchronized (cond) {
667             if (!cond.v) {
668                 try {
669                     cond.wait();
670                 } catch (InterruptedException e) {}
671             }
672         }
673     }
674 
675     /* conditions must be locked when accessing this */
676     static HashMap rv = new HashMap();
677 
678     /**
679      * Force N threads to rendezvous (ie. wait for each other) before proceeding.
680      * The first thread(s) to call are blocked until the last
681      * thread makes the call. Then all threads continue.
682      * &lt;p&gt;
683      * All threads that call with the same condition name, must use the same value
684      * for N (or the results may be not be as expected).
685      * &lt;P&gt;
686      * Obviously, if fewer than N threads make the rendezvous then the result
687      * will be a hang.
688      */
689 
690     public static void rendezvous (String condition, int N) {
691         BValue cond;
692         IValue iv;
693         String name = &quot;RV_&quot;+condition;
694 
695         /* get the condition */
696 
697         synchronized (conditions) {
698             cond = (BValue)conditions.get (name);
699             if (cond == null) {
700                 /* we are first caller */
701                 if (N &lt; 2) {
702                     throw new RuntimeException (&quot;rendezvous must be called with N &gt;= 2&quot;);
703                 }
704                 cond = new BValue ();
705                 conditions.put (name, cond);
706                 iv = new IValue (N-1);
707                 rv.put (name, iv);
708             } else {
709                 /* already initialised, just decrement the counter */
710                 iv = (IValue) rv.get (name);
711                 iv.v --;
712             }
713         }
714 
715         if (iv.v &gt; 0) {
716             waitForCondition (name);
717         } else {
718             setCondition (name);
719             synchronized (conditions) {
720                 clearCondition (name);
721                 rv.remove (name);
722             }
723         }
724     }
725 
726     /**
727      * If the named condition exists and is set then remove it, so it can
728      * be re-initialized and used again. If the condition does not exist, or
729      * exists but is not set, then the call returns without doing anything.
730      * Note, some higher level synchronization
731      * may be needed between clear and the other operations.
732      */
733 
734     public static void clearCondition(String condition) {
735         BValue cond;
736         synchronized (conditions) {
737             cond = (BValue) conditions.get (condition);
738             if (cond == null) {
739                 return;
740             }
741             synchronized (cond) {
742                 if (cond.v) {
743                     conditions.remove (condition);
744                 }
745             }
746         }
747     }
748 }
749 
    </pre>
  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New test/jdk/sun/net/www/B8185898.java</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 /**
 25  * @test
 26  * @bug 8185898
 27  * @modules java.base/sun.net.www
 28  * @library /test/lib
 29  * @run main/othervm B8185898
 30  * @summary setRequestProperty(key, null) results in HTTP header without colon in request
 31  */
 32 
 33 import java.io.*;
 34 import java.net.*;
 35 import java.util.Arrays;
 36 import java.util.List;
 37 import java.util.Map;
 38 import java.util.concurrent.ExecutorService;
 39 import java.util.concurrent.Executors;
 40 import java.util.stream.Collectors;
 41 
 42 import jdk.test.lib.net.URIBuilder;
 43 import sun.net.www.MessageHeader;
 44 import com.sun.net.httpserver.HttpContext;
 45 import com.sun.net.httpserver.HttpExchange;
 46 import com.sun.net.httpserver.HttpHandler;
 47 import com.sun.net.httpserver.HttpServer;
 48 
 49 import static java.nio.charset.StandardCharsets.ISO_8859_1;
 50 import static java.nio.charset.StandardCharsets.UTF_8;
 51 
 52 /*
 53  * Test checks that MessageHeader with key != null and value == null is set correctly
 54  * and printed according to HTTP standard in the format &lt;key&gt;: &lt;value&gt;
 55  * */
 56 public class B8185898 {
 57 
 58     static HttpServer server;
 59     static final String RESPONSE_BODY = &quot;Test response body&quot;;
 60     static final String H1 = &quot;X-header1&quot;;
 61     static final String H2 = &quot;X-header2&quot;;
 62     static final String VALUE = &quot;This test value should appear&quot;;
 63     static int port;
 64     static URL url;
 65     static volatile Map&lt;String, List&lt;String&gt;&gt; headers;
 66 
 67     static class Handler implements HttpHandler {
 68 
 69         public void handle(HttpExchange t) throws IOException {
 70             InputStream is = t.getRequestBody();
 71             InetSocketAddress rem = t.getRemoteAddress();
 72             headers = t.getRequestHeaders();    // Get request headers on the server side
 73             is.readAllBytes();
 74             is.close();
 75 
 76             OutputStream os = t.getResponseBody();
 77             t.sendResponseHeaders(200, RESPONSE_BODY.length());
 78             os.write(RESPONSE_BODY.getBytes(UTF_8));
 79             t.close();
 80         }
 81     }
 82 
 83     public static void main(String[] args) throws Exception {
 84         ExecutorService exec = Executors.newCachedThreadPool();
 85         InetAddress loopback = InetAddress.getLoopbackAddress();
 86 
 87         try {
 88             InetSocketAddress addr = new InetSocketAddress(loopback, 0);
 89             server = HttpServer.create(addr, 100);
 90             HttpHandler handler = new Handler();
 91             HttpContext context = server.createContext(&quot;/&quot;, handler);
 92             server.setExecutor(exec);
 93             server.start();
 94 
 95             port = server.getAddress().getPort();
 96             System.out.println(&quot;Server on port: &quot; + port);
 97             url = URIBuilder.newBuilder()
 98                     .scheme(&quot;http&quot;)
 99                     .loopback()
100                     .port(port)
101                     .path(&quot;/foo&quot;)
102                     .toURLUnchecked();
103             System.out.println(&quot;URL: &quot; + url);
104             testMessageHeader();
105             testMessageHeaderMethods();
106             testURLConnectionMethods();
107         } finally {
108             server.stop(0);
109             System.out.println(&quot;After server shutdown&quot;);
110             exec.shutdown();
111         }
112     }
113 
114     // Test message header with malformed message header and fake request line
115     static void testMessageHeader() {
116         final String badHeader = &quot;This is not a request line for HTTP/1.1&quot;;
117         final String fakeRequestLine = &quot;This /is/a/fake/status/line HTTP/2.0&quot;;
118         final String expectedHeaders = fakeRequestLine + &quot;\r\n&quot;
119                 + H1 + &quot;: &quot; + VALUE + &quot;\r\n&quot;
120                 + H2 + &quot;: &quot; + VALUE + &quot;\r\n&quot;
121                 + badHeader + &quot;:\r\n\r\n&quot;;
122 
123         MessageHeader header = new MessageHeader();
124         header.add(H1, VALUE);
125         header.add(H2, VALUE);
126         header.add(badHeader, null);
127         header.prepend(fakeRequestLine, null);
128         ByteArrayOutputStream out = new ByteArrayOutputStream();
129         header.print(new PrintStream(out));
130 
131         if (!out.toString().equals(expectedHeaders)) {
132             throw new AssertionError(&quot;FAILED: expected: &quot;
133                     + expectedHeaders + &quot;\nReceived: &quot; + out.toString());
134         } else {
135             System.out.println(&quot;PASSED: ::print returned correct &quot;
136                     + &quot;status line and headers:\n&quot; + out.toString());
137         }
138     }
139 
140     // Test MessageHeader::print, ::toString, implicitly testing that
141     // MessageHeader::mergeHeader formats headers correctly for responses
142     static void testMessageHeaderMethods() throws IOException {
143         // {{inputString1, expectedToString1, expectedPrint1}, {...}}
144         String[][] strings = {
145                 {&quot;HTTP/1.1 200 OK\r\n&quot;
146                         + &quot;Accept: text/html, image/gif, image/jpeg, *; q=.2, */*; q=.2\r\n&quot;
147                         + &quot;Connection: keep-alive\r\n&quot;
148                         + &quot;Host: 127.0.0.1:12345\r\n&quot;
149                         + &quot;User-agent: Java/12\r\n\r\nfoooo&quot;,
150                 &quot;pairs: {null: HTTP/1.1 200 OK}&quot;
151                         + &quot;{Accept: text/html, image/gif, image/jpeg, *; q=.2, */*; q=.2}&quot;
152                         + &quot;{Connection: keep-alive}&quot;
153                         + &quot;{Host: 127.0.0.1:12345}&quot;
154                         + &quot;{User-agent: Java/12}&quot;,
155                 &quot;Accept: text/html, image/gif, image/jpeg, *; q=.2, */*; q=.2\r\n&quot;
156                         + &quot;Connection: keep-alive\r\n&quot;
157                         + &quot;Host: 127.0.0.1:12345\r\n&quot;
158                         + &quot;User-agent: Java/12\r\n\r\n&quot;},
159                 {&quot;HTTP/1.1 200 OK\r\n&quot;
160                         + &quot;Accept: text/html, image/gif, image/jpeg, *; q=.2, */*; q=.2\r\n&quot;
161                         + &quot;Connection: keep-alive\r\n&quot;
162                         + &quot;Host: 127.0.0.1:12345\r\n&quot;
163                         + &quot;User-agent: Java/12\r\n&quot;
164                         + &quot;X-Header:\r\n\r\n&quot;,
165                 &quot;pairs: {null: HTTP/1.1 200 OK}&quot;
166                         + &quot;{Accept: text/html, image/gif, image/jpeg, *; q=.2, */*; q=.2}&quot;
167                         + &quot;{Connection: keep-alive}&quot;
168                         + &quot;{Host: 127.0.0.1:12345}&quot;
169                         + &quot;{User-agent: Java/12}&quot;
170                         + &quot;{X-Header: }&quot;,
171                 &quot;Accept: text/html, image/gif, image/jpeg, *; q=.2, */*; q=.2\r\n&quot;
172                         + &quot;Connection: keep-alive\r\n&quot;
173                         + &quot;Host: 127.0.0.1:12345\r\n&quot;
174                         + &quot;User-agent: Java/12\r\n&quot;
175                         + &quot;X-Header: \r\n\r\n&quot;},
176         };
177 
178         System.out.println(&quot;Test custom message headers&quot;);
179         for (String[] s : strings) {
180             // Test MessageHeader::toString
181             MessageHeader header = new MessageHeader(
182                     new ByteArrayInputStream(s[0].getBytes(ISO_8859_1)));
183             if (!header.toString().endsWith(s[1])) {
184                 throw new AssertionError(&quot;FAILED: expected: &quot;
185                         + s[1] + &quot;\nReceived: &quot; + header);
186             } else {
187                 System.out.println(&quot;PASSED: ::toString returned correct &quot;
188                         + &quot;status line and headers:\n&quot; + header);
189             }
190 
191             // Test MessageHeader::print
192             ByteArrayOutputStream out = new ByteArrayOutputStream();
193             header.print(new PrintStream(out));
194             if (!out.toString().equals(s[2])) {
195                 throw new AssertionError(&quot;FAILED: expected: &quot;
196                         + s[2] + &quot;\nReceived: &quot; + out.toString());
197             } else {
198                 System.out.println(&quot;PASSED: ::print returned correct &quot;
199                         + &quot;status line and headers:\n&quot; + out.toString());
200             }
201         }
202     }
203 
204     // Test methods URLConnection::getRequestProperties,
205     // ::getHeaderField, ::getHeaderFieldKey
206     static void testURLConnectionMethods() throws IOException {
207         HttpURLConnection urlConn = (HttpURLConnection) url.openConnection(Proxy.NO_PROXY);
208         urlConn.setRequestProperty(H1, &quot;&quot;);
209         urlConn.setRequestProperty(H1, VALUE);
210         urlConn.setRequestProperty(H2, null);    // Expected to contain &#39;:&#39; between key and value
211         Map&lt;String, List&lt;String&gt;&gt; props = urlConn.getRequestProperties();
212         Map&lt;String, List&lt;String&gt;&gt; expectedMap = Map.of(
213                 H1, List.of(VALUE),
214                 H2, Arrays.asList((String) null));
215 
216         // Test request properties
217         System.out.println(&quot;Client request properties&quot;);
218         StringBuilder sb = new StringBuilder();
219         props.forEach((k, v) -&gt; sb.append(k + &quot;: &quot;
220                 + v.stream().collect(Collectors.joining()) + &quot;\n&quot;));
221         System.out.println(sb);
222 
223         if (!props.equals(expectedMap)) {
224             throw new AssertionError(&quot;Unexpected properties returned: &quot;
225                     + props);
226         } else {
227             System.out.println(&quot;Properties returned as expected&quot;);
228         }
229 
230         // Test header fields
231         String headerField = urlConn.getHeaderField(0);
232         if (!headerField.contains(&quot;200 OK&quot;)) {
233             throw new AssertionError(&quot;Expected headerField[0]: status line. &quot;
234                     + &quot;Received: &quot; + headerField);
235         } else {
236             System.out.println(&quot;PASSED: headerField[0] contains status line: &quot;
237                     + headerField);
238         }
239 
240         String headerFieldKey = urlConn.getHeaderFieldKey(0);
241         if (headerFieldKey != null) {
242             throw new AssertionError(&quot;Expected headerFieldKey[0]: null. &quot;
243                     + &quot;Received: &quot; + headerFieldKey);
244         } else {
245             System.out.println(&quot;PASSED: headerFieldKey[0] is null&quot;);
246         }
247 
248         // Check that test request headers are included with correct format
249         try (
250                 BufferedReader in = new BufferedReader(
251                         new InputStreamReader(urlConn.getInputStream()))
252         ) {
253             if (!headers.keySet().contains(H1)) {
254                 throw new AssertionError(&quot;Expected key not found: &quot;
255                         + H1 + &quot;: &quot; + VALUE);
256             } else if (!headers.get(H1).equals(List.of(VALUE))) {
257                 throw new AssertionError(&quot;Unexpected key-value pair: &quot;
258                         + H1 + &quot;: &quot; + headers.get(H1));
259             } else {
260                 System.out.println(&quot;PASSED: &quot; + H1 + &quot; included in request headers&quot;);
261             }
262 
263             if (!headers.keySet().contains(H2)) {
264                 throw new AssertionError(&quot;Expected key not found: &quot;
265                         + H2 + &quot;: &quot;);
266                 // Check that empty list is returned
267             } else if (!headers.get(H2).equals(List.of(&quot;&quot;))) {
268                 throw new AssertionError(&quot;Unexpected key-value pair: &quot;
269                         + H2 + &quot;: &quot; + headers.get(H2));
270             } else {
271                 System.out.println(&quot;PASSED: &quot; + H2 + &quot; included in request headers&quot;);
272             }
273 
274             String inputLine;
275             while ((inputLine = in.readLine()) != null) {
276                 System.out.println(inputLine);
277             }
278         }
279     }
280 }
    </pre>
  </body>
</html>
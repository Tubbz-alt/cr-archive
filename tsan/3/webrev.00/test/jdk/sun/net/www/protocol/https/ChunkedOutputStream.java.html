<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New test/jdk/sun/net/www/protocol/https/ChunkedOutputStream.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2004, 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 /**
 25  * @test
 26  * @bug 5026745
 27  * @modules java.base/sun.net.www
 28  * @build TestHttpsServer HttpCallback
 29  * @run main/othervm ChunkedOutputStream
 30  * @run main/othervm -Djava.net.preferIPv6Addresses=true ChunkedOutputStream
 31  *
 32  *     SunJSSE does not support dynamic system properties, no way to re-use
 33  *     system properties in samevm/agentvm mode.
 34  * @summary Cannot flush output stream when writing to an HttpUrlConnection
 35  */
 36 
 37 import java.io.*;
 38 import java.net.*;
 39 import javax.net.ssl.*;
 40 import java.util.concurrent.atomic.AtomicInteger;
 41 
 42 public class ChunkedOutputStream implements HttpCallback {
 43     /*
 44      * Where do we find the keystores for ssl?
 45      */
 46     static String pathToStores = &quot;../../../../../javax/net/ssl/etc&quot;;
 47     static String keyStoreFile = &quot;keystore&quot;;
 48     static String trustStoreFile = &quot;truststore&quot;;
 49     static String passwd = &quot;passphrase&quot;;
 50     static int count = 0;
 51     static final AtomicInteger rogueCount = new AtomicInteger();
 52 
 53     static final String str1 = &quot;Helloworld1234567890abcdefghijklmnopqrstuvwxyz&quot;+
 54                                 &quot;1234567890abcdefkjsdlkjflkjsldkfjlsdkjflkj&quot;+
 55                                 &quot;1434567890abcdefkjsdlkjflkjsldkfjlsdkjflkj&quot;;
 56 
 57     static final String str2 = &quot;Helloworld1234567890abcdefghijklmnopqrstuvwxyz&quot;+
 58                                 &quot;1234567890&quot;;
 59 
 60     public void request(HttpTransaction req) {
 61         try {
 62             // this is needed (count++ doesn&#39;t work), &#39;cause we
 63             // are doing concurrent tests
 64             String path = req.getRequestURI().getPath();
 65             if (path.equals(&quot;/d0&quot;)) {
 66                 count = 0;
 67             } else if (path.equals(&quot;/d01&quot;)) {
 68                 count = 1;
 69             } else if (path.equals(&quot;/d3&quot;)) {
 70                 count = 2;
 71             } else if (path.equals(&quot;/d4&quot;) || path.equals(&quot;/d5&quot;)) {
 72                 count = 3;
 73             } else if (path.equals(&quot;/d6&quot;)) {
 74                 count = 3;
 75             }  else if (path.equals(&quot;/d7&quot;)) {
 76                 count = 4;
 77             }  else if (path.equals(&quot;/d8&quot;)) {
 78                 count = 5;
 79             }
 80 
 81             switch (count) {
 82             case 0: /* test1 -- keeps conn alive */
 83             case 1: /* test2 -- closes conn */
 84                 String reqbody = req.getRequestEntityBody();
 85                 if (!reqbody.equals(str1)) {
 86                     req.sendResponse(500, &quot;Internal server error&quot;);
 87                     req.orderlyClose();
 88                 }
 89                 String chunk = req.getRequestHeader(&quot;Transfer-encoding&quot;);
 90                 if (!&quot;chunked&quot;.equals(chunk)) {
 91                     req.sendResponse(501, &quot;Internal server error&quot;);
 92                     req.orderlyClose();
 93                 }
 94                 req.setResponseEntityBody(reqbody);
 95                 if (count == 1) {
 96                     req.setResponseHeader(&quot;Connection&quot;, &quot;close&quot;);
 97                 }
 98                 req.sendResponse(200, &quot;OK&quot;);
 99                 if (count == 1) {
100                     req.orderlyClose();
101                 }
102                 break;
103             case 2: /* test 3 */
104                 reqbody = req.getRequestEntityBody();
105                 if (!reqbody.equals(str2)) {
106                     req.sendResponse(500, &quot;Internal server error&quot;);
107                     req.orderlyClose();
108                 }
109                 int clen = Integer.parseInt (
110                         req.getRequestHeader(&quot;Content-length&quot;));
111                 if (clen != str2.length()) {
112                     req.sendResponse(501, &quot;Internal server error&quot;);
113                     req.orderlyClose();
114                 }
115                 req.setResponseEntityBody (reqbody);
116                 req.setResponseHeader(&quot;Connection&quot;, &quot;close&quot;);
117                 req.sendResponse(200, &quot;OK&quot;);
118                 req.orderlyClose();
119                 break;
120             case 3: /* test 6 */
121                 req.setResponseHeader(&quot;Location&quot;, &quot;https://foo.bar/&quot;);
122                 req.setResponseHeader(&quot;Connection&quot;, &quot;close&quot;);
123                 req.sendResponse(307, &quot;Temporary Redirect&quot;);
124                 req.orderlyClose();
125                 break;
126             case 4: /* test 7 */
127             case 5: /* test 8 */
128                 reqbody = req.getRequestEntityBody();
129                 if (reqbody != null &amp;&amp; !&quot;&quot;.equals(reqbody)) {
130                     req.sendResponse(501, &quot;Internal server error&quot;);
131                     req.orderlyClose();
132                 }
133                 req.setResponseHeader(&quot;Connection&quot;, &quot;close&quot;);
134                 req.sendResponse(200, &quot;OK&quot;);
135                 req.orderlyClose();
136                 break;
137             default:
138                 req.sendResponse(404, &quot;Not Found&quot;);
139                 req.orderlyClose();
140                 break;
141             }
142         } catch (IOException e) {
143             e.printStackTrace();
144         }
145     }
146 
147     public boolean dropPlainTextConnections() {
148         System.out.println(&quot;Unrecognized SSL message, plaintext connection?&quot;);
149         System.out.println(&quot;TestHttpsServer receveived rogue connection: ignoring it.&quot;);
150         rogueCount.incrementAndGet();
151         return true;
152     }
153 
154     static void readAndCompare(InputStream is, String cmp) throws IOException {
155         int c;
156         byte buf[] = new byte[1024];
157         int off = 0;
158         int len = 1024;
159         while ((c=is.read(buf, off, len)) != -1) {
160             off += c;
161             len -= c;
162         }
163         String s1 = new String(buf, 0, off, &quot;ISO8859_1&quot;);
164         if (!cmp.equals(s1)) {
165             throw new IOException(&quot;strings not same&quot;);
166         }
167     }
168 
169     /* basic smoke test: verify that server drops plain connections */
170     static void testPlainText(String authority) throws Exception {
171         URL url = new URL(&quot;http://&quot; + authority + &quot;/Donauschiffsgesellschaftskapitaenskajuete&quot;);
172         System.out.println(&quot;client opening connection to: &quot; + url);
173         HttpURLConnection urlc = (HttpURLConnection)url.openConnection(Proxy.NO_PROXY);
174         int rogue = rogueCount.get();
175         try {
176             int code  = urlc.getResponseCode();
177             System.out.println(&quot;Unexpected response: &quot; + code);
178             throw new AssertionError(&quot;Unexpected response: &quot; + code);
179         } catch (SocketException x) {
180             // we expect that the server will drop the connection and
181             // close the accepted socket, so we should get a SocketException
182             // on the client side, and confirm that this::dropPlainTextConnections
183             // has ben called.
184             if (rogueCount.get() == rogue) throw x;
185             System.out.println(&quot;Got expected exception: &quot; + x);
186         }
187     }
188 
189     /* basic chunked test (runs twice) */
190 
191     static void test1(String u) throws Exception {
192         URL url = new URL(u);
193         System.out.println(&quot;client opening connection to: &quot; + u);
194         HttpURLConnection urlc = (HttpURLConnection)url.openConnection(Proxy.NO_PROXY);
195         urlc.setChunkedStreamingMode(20);
196         urlc.setDoOutput(true);
197         urlc.setRequestMethod(&quot;POST&quot;);
198         OutputStream os = urlc.getOutputStream();
199         os.write(str1.getBytes());
200         os.close();
201         InputStream is = urlc.getInputStream();
202         readAndCompare(is, str1);
203         is.close();
204     }
205 
206     /* basic fixed length test */
207 
208     static void test3(String u) throws Exception {
209         URL url = new URL(u);
210         System.out.println(&quot;client opening connection to: &quot; + u);
211         HttpURLConnection urlc = (HttpURLConnection)url.openConnection(Proxy.NO_PROXY);
212         urlc.setFixedLengthStreamingMode(str2.length());
213         urlc.setDoOutput(true);
214         urlc.setRequestMethod(&quot;POST&quot;);
215         OutputStream os = urlc.getOutputStream();
216         os.write (str2.getBytes());
217         os.close();
218         InputStream is = urlc.getInputStream();
219         readAndCompare(is, str2);
220         is.close();
221     }
222 
223     /* write too few bytes */
224 
225     static void test4(String u) throws Exception {
226         URL url = new URL(u);
227         System.out.println(&quot;client opening connection to: &quot; + u);
228         HttpURLConnection urlc = (HttpURLConnection)url.openConnection(Proxy.NO_PROXY);
229         urlc.setFixedLengthStreamingMode(str2.length()+1);
230         urlc.setDoOutput(true);
231         urlc.setRequestMethod(&quot;POST&quot;);
232         OutputStream os = urlc.getOutputStream();
233         os.write(str2.getBytes());
234         try {
235             os.close();
236             throw new Exception(&quot;should have thrown IOException&quot;);
237         } catch (IOException e) {}
238     }
239 
240     /* write too many bytes */
241 
242     static void test5(String u) throws Exception {
243         URL url = new URL(u);
244         System.out.println(&quot;client opening connection to: &quot; + u);
245         HttpURLConnection urlc = (HttpURLConnection)url.openConnection(Proxy.NO_PROXY);
246         urlc.setFixedLengthStreamingMode(str2.length()-1);
247         urlc.setDoOutput(true);
248         urlc.setRequestMethod(&quot;POST&quot;);
249         OutputStream os = urlc.getOutputStream();
250         try {
251             os.write(str2.getBytes());
252             throw new Exception(&quot;should have thrown IOException&quot;);
253         } catch (IOException e) {}
254     }
255 
256     /* check for HttpRetryException on redirection */
257 
258     static void test6(String u) throws Exception {
259         URL url = new URL(u);
260         System.out.println(&quot;client opening connection to: &quot; + u);
261         HttpURLConnection urlc = (HttpURLConnection)url.openConnection(Proxy.NO_PROXY);
262         urlc.setChunkedStreamingMode(20);
263         urlc.setDoOutput(true);
264         urlc.setRequestMethod(&quot;POST&quot;);
265         OutputStream os = urlc.getOutputStream();
266         os.write(str1.getBytes());
267         os.close();
268         try {
269             InputStream is = urlc.getInputStream();
270             throw new Exception(&quot;should have gotten HttpRetryException&quot;);
271         } catch (HttpRetryException e) {
272             if (e.responseCode() != 307) {
273                 throw new Exception(&quot;Wrong response code &quot; + e.responseCode());
274             }
275             if (!e.getLocation().equals(&quot;https://foo.bar/&quot;)) {
276                 throw new Exception(&quot;Wrong location &quot; + e.getLocation());
277             }
278         }
279     }
280 
281     /* next two tests send zero length posts */
282 
283     static void test7(String u) throws Exception {
284         URL url = new URL(u);
285         System.out.println(&quot;client opening connection to: &quot; + u);
286         HttpURLConnection urlc = (HttpURLConnection)url.openConnection(Proxy.NO_PROXY);
287         urlc.setChunkedStreamingMode(20);
288         urlc.setDoOutput(true);
289         urlc.setRequestMethod(&quot;POST&quot;);
290         OutputStream os = urlc.getOutputStream();
291         os.close();
292         int ret = urlc.getResponseCode();
293         if (ret != 200) {
294             throw new Exception(&quot;Expected 200: got &quot; + ret);
295         }
296     }
297 
298     static void test8(String u) throws Exception {
299         URL url = new URL(u);
300         System.out.println(&quot;client opening connection to: &quot; + u);
301         HttpURLConnection urlc = (HttpURLConnection)url.openConnection(Proxy.NO_PROXY);
302         urlc.setFixedLengthStreamingMode(0);
303         urlc.setDoOutput(true);
304         urlc.setRequestMethod(&quot;POST&quot;);
305         OutputStream os = urlc.getOutputStream();
306         os.close();
307         int ret = urlc.getResponseCode();
308         if (ret != 200) {
309             throw new Exception(&quot;Expected 200: got &quot; + ret);
310         }
311     }
312 
313     static TestHttpsServer server;
314 
315     public static void main(String[] args) throws Exception {
316         // setup properties to do ssl
317         String keyFilename =
318             System.getProperty(&quot;test.src&quot;, &quot;./&quot;) + &quot;/&quot; + pathToStores +
319                 &quot;/&quot; + keyStoreFile;
320         String trustFilename =
321             System.getProperty(&quot;test.src&quot;, &quot;./&quot;) + &quot;/&quot; + pathToStores +
322                 &quot;/&quot; + trustStoreFile;
323 
324         InetAddress loopback = InetAddress.getLoopbackAddress();
325 
326         HostnameVerifier reservedHV =
327             HttpsURLConnection.getDefaultHostnameVerifier();
328         try {
329             System.setProperty(&quot;javax.net.ssl.keyStore&quot;, keyFilename);
330             System.setProperty(&quot;javax.net.ssl.keyStorePassword&quot;, passwd);
331             System.setProperty(&quot;javax.net.ssl.trustStore&quot;, trustFilename);
332             System.setProperty(&quot;javax.net.ssl.trustStorePassword&quot;, passwd);
333             HttpsURLConnection.setDefaultHostnameVerifier(new NameVerifier());
334 
335             try {
336                 server = new TestHttpsServer(
337                         new ChunkedOutputStream(), 1, 10, loopback, 0);
338                 System.out.println(&quot;Server started: listening on: &quot; + server.getAuthority());
339                 testPlainText(server.getAuthority());
340                 // the test server doesn&#39;t support keep-alive yet
341                 // test1(&quot;http://&quot; + server.getAuthority() + &quot;/d0&quot;);
342                 test1(&quot;https://&quot; + server.getAuthority() + &quot;/d01&quot;);
343                 test3(&quot;https://&quot; + server.getAuthority() + &quot;/d3&quot;);
344                 test4(&quot;https://&quot; + server.getAuthority() + &quot;/d4&quot;);
345                 test5(&quot;https://&quot; + server.getAuthority() + &quot;/d5&quot;);
346                 test6(&quot;https://&quot; + server.getAuthority() + &quot;/d6&quot;);
347                 test7(&quot;https://&quot; + server.getAuthority() + &quot;/d7&quot;);
348                 test8(&quot;https://&quot; + server.getAuthority() + &quot;/d8&quot;);
349             } catch (Exception e) {
350                 if (server != null) {
351                     server.terminate();
352                 }
353                 throw e;
354             }
355             server.terminate();
356         } finally {
357             HttpsURLConnection.setDefaultHostnameVerifier(reservedHV);
358         }
359     }
360 
361     static class NameVerifier implements HostnameVerifier {
362         public boolean verify(String hostname, SSLSession session) {
363             return true;
364         }
365     }
366 
367     public static void except(String s) {
368         server.terminate();
369         throw new RuntimeException(s);
370     }
371 }
    </pre>
  </body>
</html>
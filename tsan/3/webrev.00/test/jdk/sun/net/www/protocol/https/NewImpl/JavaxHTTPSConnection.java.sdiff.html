<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff test/jdk/sun/net/www/protocol/https/NewImpl/JavaxHTTPSConnection.java</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="../HttpsURLConnection/TunnelProxy.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="JavaxHostnameVerifier.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>test/jdk/sun/net/www/protocol/https/NewImpl/JavaxHTTPSConnection.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2001, 2011, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 /*
 25  * @test
 26  * @bug 4474255
 27  * @summary Can no longer obtain a com.sun.net.ssl.HttpsURLConnection

 28  * @run main/othervm JavaxHTTPSConnection

 29  *
 30  *     SunJSSE does not support dynamic system properties, no way to re-use
 31  *     system properties in samevm/agentvm mode.
 32  * @author Brad Wetmore
 33  */
 34 
 35 import java.io.*;
 36 import java.net.*;
 37 import java.security.cert.*;
 38 import javax.net.ssl.*;

 39 
 40 /**
 41  * See if we can obtain a javax.net.ssl.HttpsURLConnection,
 42  * and then play with it a bit.
 43  */
 44 public class JavaxHTTPSConnection {
 45 
 46     /*
 47      * =============================================================
 48      * Set the various variables needed for the tests, then
 49      * specify what tests to run on each side.
 50      */
 51 
 52     /*
 53      * Should we run the client or server in a separate thread?
 54      * Both sides can throw exceptions, but do you have a preference
 55      * as to which side should be the main thread.
 56      */
 57     static boolean separateServerThread = true;
 58 
</pre>
<hr />
<pre>
121      * In our case, we just pretend to send something back.
122      *
123      * @return the bytes for the file
124      * @exception FileNotFoundException if the file corresponding
125      * to &lt;b&gt;path&lt;/b&gt; could not be loaded.
126      */
127     private byte[] getBytes(String path)
128         throws IOException
129     {
130         return &quot;Hello world, I am here&quot;.getBytes();
131     }
132 
133     /*
134      * Define the server side of the test.
135      *
136      * If the server prematurely exits, serverReady will be set to true
137      * to avoid infinite hangs.
138      */
139     void doServerSide() throws Exception {
140 


141         SSLServerSocketFactory sslssf =
142           (SSLServerSocketFactory) SSLServerSocketFactory.getDefault();
143         SSLServerSocket sslServerSocket =
<span class="line-modified">144             (SSLServerSocket) sslssf.createServerSocket(serverPort);</span>

145         serverPort = sslServerSocket.getLocalPort();
146 
147         /*
148          * Signal Client, we&#39;re ready for his connect.
149          */
150         serverReady = true;
151 
152         SSLSocket sslSocket = (SSLSocket) sslServerSocket.accept();
153         DataOutputStream out =
154                 new DataOutputStream(sslSocket.getOutputStream());
155 
156         try {
157              // get path to class file from header
158              DataInputStream in =
159                         new DataInputStream(sslSocket.getInputStream());
160              String path = getPath(in);
161              // retrieve bytecodes
162              byte[] bytecodes = getBytes(path);
163              // send bytecodes in response (assumes HTTP/1.0 or later)
164              try {
</pre>
<hr />
<pre>
187     }
188 
189     /*
190      * Define the client side of the test.
191      *
192      * If the server prematurely exits, serverReady will be set to true
193      * to avoid infinite hangs.
194      */
195     void doClientSide() throws Exception {
196         HostnameVerifier reservedHV =
197             HttpsURLConnection.getDefaultHostnameVerifier();
198         try {
199             /*
200              * Wait for server to get started.
201              */
202             while (!serverReady) {
203                 Thread.sleep(50);
204             }
205 
206             HttpsURLConnection.setDefaultHostnameVerifier(new NameVerifier());
<span class="line-modified">207             URL url = new URL(&quot;https://&quot; + &quot;localhost:&quot; + serverPort +</span>
<span class="line-modified">208                                     &quot;/etc/hosts&quot;);</span>
<span class="line-modified">209             URLConnection urlc = url.openConnection();</span>





210 
211             if (!(urlc instanceof javax.net.ssl.HttpsURLConnection)) {
212                 throw new Exception(&quot;URLConnection ! instanceof &quot; +
213                                     &quot;javax.net.ssl.HttpsURLConnection&quot;);
214             }
215 
216             BufferedReader in = null;
217             try {
218                 in = new BufferedReader(new InputStreamReader(
219                                    urlc.getInputStream()));
220                 String inputLine;
221                 System.out.print(&quot;Client reading... &quot;);
222                 while ((inputLine = in.readLine()) != null)
223                     System.out.println(inputLine);
224 
225                 System.out.println(&quot;Cipher Suite: &quot; +
226                     ((HttpsURLConnection)urlc).getCipherSuite());
227                 Certificate[] certs =
228                     ((HttpsURLConnection)urlc).getServerCertificates();
229                 for (int i = 0; i &lt; certs.length; i++) {
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2001, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 /*
 25  * @test
 26  * @bug 4474255
 27  * @summary Can no longer obtain a com.sun.net.ssl.HttpsURLConnection
<span class="line-added"> 28  * @library /test/lib</span>
 29  * @run main/othervm JavaxHTTPSConnection
<span class="line-added"> 30  * @run main/othervm -Djava.net.preferIPv6Addresses=true JavaxHTTPSConnection</span>
 31  *
 32  *     SunJSSE does not support dynamic system properties, no way to re-use
 33  *     system properties in samevm/agentvm mode.
 34  * @author Brad Wetmore
 35  */
 36 
 37 import java.io.*;
 38 import java.net.*;
 39 import java.security.cert.*;
 40 import javax.net.ssl.*;
<span class="line-added"> 41 import jdk.test.lib.net.URIBuilder;</span>
 42 
 43 /**
 44  * See if we can obtain a javax.net.ssl.HttpsURLConnection,
 45  * and then play with it a bit.
 46  */
 47 public class JavaxHTTPSConnection {
 48 
 49     /*
 50      * =============================================================
 51      * Set the various variables needed for the tests, then
 52      * specify what tests to run on each side.
 53      */
 54 
 55     /*
 56      * Should we run the client or server in a separate thread?
 57      * Both sides can throw exceptions, but do you have a preference
 58      * as to which side should be the main thread.
 59      */
 60     static boolean separateServerThread = true;
 61 
</pre>
<hr />
<pre>
124      * In our case, we just pretend to send something back.
125      *
126      * @return the bytes for the file
127      * @exception FileNotFoundException if the file corresponding
128      * to &lt;b&gt;path&lt;/b&gt; could not be loaded.
129      */
130     private byte[] getBytes(String path)
131         throws IOException
132     {
133         return &quot;Hello world, I am here&quot;.getBytes();
134     }
135 
136     /*
137      * Define the server side of the test.
138      *
139      * If the server prematurely exits, serverReady will be set to true
140      * to avoid infinite hangs.
141      */
142     void doServerSide() throws Exception {
143 
<span class="line-added">144         InetAddress loopback = InetAddress.getLoopbackAddress();</span>
<span class="line-added">145         InetSocketAddress serverAddress = new InetSocketAddress(loopback, serverPort);</span>
146         SSLServerSocketFactory sslssf =
147           (SSLServerSocketFactory) SSLServerSocketFactory.getDefault();
148         SSLServerSocket sslServerSocket =
<span class="line-modified">149             (SSLServerSocket) sslssf.createServerSocket();</span>
<span class="line-added">150         sslServerSocket.bind(serverAddress);</span>
151         serverPort = sslServerSocket.getLocalPort();
152 
153         /*
154          * Signal Client, we&#39;re ready for his connect.
155          */
156         serverReady = true;
157 
158         SSLSocket sslSocket = (SSLSocket) sslServerSocket.accept();
159         DataOutputStream out =
160                 new DataOutputStream(sslSocket.getOutputStream());
161 
162         try {
163              // get path to class file from header
164              DataInputStream in =
165                         new DataInputStream(sslSocket.getInputStream());
166              String path = getPath(in);
167              // retrieve bytecodes
168              byte[] bytecodes = getBytes(path);
169              // send bytecodes in response (assumes HTTP/1.0 or later)
170              try {
</pre>
<hr />
<pre>
193     }
194 
195     /*
196      * Define the client side of the test.
197      *
198      * If the server prematurely exits, serverReady will be set to true
199      * to avoid infinite hangs.
200      */
201     void doClientSide() throws Exception {
202         HostnameVerifier reservedHV =
203             HttpsURLConnection.getDefaultHostnameVerifier();
204         try {
205             /*
206              * Wait for server to get started.
207              */
208             while (!serverReady) {
209                 Thread.sleep(50);
210             }
211 
212             HttpsURLConnection.setDefaultHostnameVerifier(new NameVerifier());
<span class="line-modified">213             URL url = URIBuilder.newBuilder()</span>
<span class="line-modified">214                 .scheme(&quot;https&quot;)</span>
<span class="line-modified">215                 .loopback()</span>
<span class="line-added">216                 .port(serverPort)</span>
<span class="line-added">217                 .path(&quot;/etc/hosts&quot;)</span>
<span class="line-added">218                 .toURL();</span>
<span class="line-added">219             System.out.println(&quot;Client opening: &quot; + url);</span>
<span class="line-added">220             URLConnection urlc = url.openConnection(Proxy.NO_PROXY);</span>
221 
222             if (!(urlc instanceof javax.net.ssl.HttpsURLConnection)) {
223                 throw new Exception(&quot;URLConnection ! instanceof &quot; +
224                                     &quot;javax.net.ssl.HttpsURLConnection&quot;);
225             }
226 
227             BufferedReader in = null;
228             try {
229                 in = new BufferedReader(new InputStreamReader(
230                                    urlc.getInputStream()));
231                 String inputLine;
232                 System.out.print(&quot;Client reading... &quot;);
233                 while ((inputLine = in.readLine()) != null)
234                     System.out.println(inputLine);
235 
236                 System.out.println(&quot;Cipher Suite: &quot; +
237                     ((HttpsURLConnection)urlc).getCipherSuite());
238                 Certificate[] certs =
239                     ((HttpsURLConnection)urlc).getServerCertificates();
240                 for (int i = 0; i &lt; certs.length; i++) {
</pre>
</td>
</tr>
</table>
<center><a href="../HttpsURLConnection/TunnelProxy.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="JavaxHostnameVerifier.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
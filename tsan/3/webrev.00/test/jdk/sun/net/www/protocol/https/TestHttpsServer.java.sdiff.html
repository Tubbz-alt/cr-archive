<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff test/jdk/sun/net/www/protocol/https/TestHttpsServer.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
<body>
<center><a href="NewImpl/JavaxHostnameVerifier.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="../jar/B4957695.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>test/jdk/sun/net/www/protocol/https/TestHttpsServer.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2002, 2012, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
</pre>
<hr />
<pre>
 53 
 54 public class TestHttpsServer {
 55 
 56     ServerSocketChannel schan;
 57     int threads;
 58     int cperthread;
 59     HttpCallback cb;
 60     Server[] servers;
 61 
 62     // ssl related fields
 63     static SSLContext sslCtx;
 64 
 65     /**
 66      * Create a &lt;code&gt;TestHttpsServer&lt;code&gt; instance with the specified callback object
 67      * for handling requests. One thread is created to handle requests,
 68      * and up to ten TCP connections will be handled simultaneously.
 69      * @param cb the callback object which is invoked to handle each
 70      *  incoming request
 71      */
 72 
<span class="line-modified"> 73     public TestHttpsServer (HttpCallback cb) throws IOException {</span>
<span class="line-modified"> 74         this (cb, 1, 10, 0);</span>
 75     }
 76 
 77     /**
 78      * Create a &lt;code&gt;TestHttpsServer&lt;code&gt; instance with the specified number of
 79      * threads and maximum number of connections per thread. This functions
 80      * the same as the 4 arg constructor, where the port argument is set to zero.
 81      * @param cb the callback object which is invoked to handle each
 82      *     incoming request
 83      * @param threads the number of threads to create to handle requests
 84      *     in parallel
 85      * @param cperthread the number of simultaneous TCP connections to
 86      *     handle per thread
 87      */
 88 
<span class="line-modified"> 89     public TestHttpsServer (HttpCallback cb, int threads, int cperthread)</span>
 90         throws IOException {
<span class="line-modified"> 91         this (cb, threads, cperthread, 0);</span>
 92     }
 93 
 94     /**
 95      * Create a &lt;code&gt;TestHttpsServer&lt;code&gt; instance with the specified number
 96      * of threads and maximum number of connections per thread and running on
 97      * the specified port. The specified number of threads are created to
 98      * handle incoming requests, and each thread is allowed
 99      * to handle a number of simultaneous TCP connections.
100      * @param cb the callback object which is invoked to handle
101      *  each incoming request
102      * @param threads the number of threads to create to handle
103      *  requests in parallel
104      * @param cperthread the number of simultaneous TCP connections
105      *  to handle per thread
106      * @param port the port number to bind the server to. &lt;code&gt;Zero&lt;/code&gt;
107      *  means choose any free port.
108      */




109 
<span class="line-modified">110     public TestHttpsServer (HttpCallback cb, int threads, int cperthread, int port)</span>


















111         throws IOException {
<span class="line-modified">112         schan = ServerSocketChannel.open ();</span>
<span class="line-modified">113         InetSocketAddress addr = new InetSocketAddress (port);</span>
<span class="line-modified">114         schan.socket().bind (addr);</span>
115         this.threads = threads;
116         this.cb = cb;
117         this.cperthread = cperthread;
118 
119         try {
120             // create and initialize a SSLContext
121             KeyStore ks = KeyStore.getInstance(&quot;JKS&quot;);
122             KeyStore ts = KeyStore.getInstance(&quot;JKS&quot;);
123             char[] passphrase = &quot;passphrase&quot;.toCharArray();
124 
125             ks.load(new FileInputStream(System.getProperty(&quot;javax.net.ssl.keyStore&quot;)), passphrase);
126             ts.load(new FileInputStream(System.getProperty(&quot;javax.net.ssl.trustStore&quot;)), passphrase);
127 
128             KeyManagerFactory kmf = KeyManagerFactory.getInstance(&quot;SunX509&quot;);
129             kmf.init(ks, passphrase);
130 
131             TrustManagerFactory tmf = TrustManagerFactory.getInstance(&quot;SunX509&quot;);
132             tmf.init(ts);
133 
134             sslCtx = SSLContext.getInstance(&quot;TLS&quot;);
135 
136             sslCtx.init(kmf.getKeyManagers(), tmf.getTrustManagers(), null);
137 
<span class="line-modified">138             servers = new Server [threads];</span>
139             for (int i=0; i&lt;threads; i++) {
<span class="line-modified">140                 servers[i] = new Server (cb, schan, cperthread);</span>
141                 servers[i].start();
142             }
143         } catch (Exception ex) {
144             throw new RuntimeException(&quot;test failed. cause: &quot;+ex.getMessage());
145         }
146     }
147 
148     /** Tell all threads in the server to exit within 5 seconds.
149      *  This is an abortive termination. Just prior to the thread exiting
150      *  all channels in that thread waiting to be closed are forceably closed.
151      */
152 
<span class="line-modified">153     public void terminate () {</span>
154         for (int i=0; i&lt;threads; i++) {
155             servers[i].terminate ();
156         }
157     }
158 
159     /**
160      * return the local port number to which the server is bound.
161      * @return the local port number
162      */
163 
164     public int getLocalPort () {
165         return schan.socket().getLocalPort ();
166     }
167 








168     static class Server extends Thread {
169 
170         ServerSocketChannel schan;
171         Selector selector;
172         SelectionKey listenerKey;
173         SelectionKey key; /* the current key being processed */
174         HttpCallback cb;
175         ByteBuffer consumeBuffer;
176         int maxconn;
177         int nconn;
178         ClosedChannelList clist;
179         boolean shutdown;
180 
<span class="line-modified">181         Server (HttpCallback cb, ServerSocketChannel schan, int maxconn) {</span>
182             this.schan = schan;
183             this.maxconn = maxconn;
184             this.cb = cb;
185             nconn = 0;
<span class="line-modified">186             consumeBuffer = ByteBuffer.allocate (512);</span>
<span class="line-modified">187             clist = new ClosedChannelList ();</span>
188             try {
<span class="line-modified">189                 selector = Selector.open ();</span>
<span class="line-modified">190                 schan.configureBlocking (false);</span>
<span class="line-modified">191                 listenerKey = schan.register (selector, SelectionKey.OP_ACCEPT);</span>
192             } catch (IOException e) {
<span class="line-modified">193                 System.err.println (&quot;Server could not start: &quot; + e);</span>
194             }
195         }
196 
197         /* Stop the thread as soon as possible */
<span class="line-modified">198         public synchronized void terminate () {</span>
199             shutdown = true;
200         }
201 
<span class="line-modified">202         public void run ()  {</span>
203             try {
204                 while (true) {
<span class="line-modified">205                     selector.select (1000);</span>
206                     Set selected = selector.selectedKeys();
207                     Iterator iter = selected.iterator();
208                     while (iter.hasNext()) {
209                         key = (SelectionKey)iter.next();
210                         if (key.equals (listenerKey)) {
<span class="line-modified">211                             SocketChannel sock = schan.accept ();</span>
212                             if (sock == null) {
213                                 /* false notification */
214                                 iter.remove();
215                                 continue;
216                             }
<span class="line-modified">217                             sock.configureBlocking (true);</span>
218                             SSLEngine sslEng = sslCtx.createSSLEngine();
219                             sslEng.setUseClientMode(false);
220                             new ServerWorker(cb, sock, sslEng).start();
221                             nconn ++;
222                             if (nconn == maxconn) {
223                                 /* deregister */
<span class="line-modified">224                                 listenerKey.cancel ();</span>
225                                 listenerKey = null;
226                             }
227                         } else {
228                             if (key.isReadable()) {
229                                 boolean closed = false;
<span class="line-modified">230                                 SocketChannel chan = (SocketChannel) key.channel();</span>
231                                 if (key.attachment() != null) {
<span class="line-modified">232                                     closed = consume (chan);</span>
233                                 }
234 
235                                 if (closed) {
<span class="line-modified">236                                     chan.close ();</span>
<span class="line-modified">237                                     key.cancel ();</span>
238                                     if (nconn == maxconn) {
<span class="line-modified">239                                         listenerKey = schan.register (selector, SelectionKey.OP_ACCEPT);</span>
240                                     }
241                                     nconn --;
242                                 }
243                             }
244                         }
245                         iter.remove();
246                     }
247                     clist.check();
248 
249                     synchronized (this) {
250                         if (shutdown) {
<span class="line-modified">251                             clist.terminate ();</span>
252                             return;
253                         }
254                     }
255                 }
256             } catch (IOException e) {
<span class="line-modified">257                 System.out.println (&quot;Server exception: &quot; + e);</span>
258                 // TODO finish
259             }
260         }
261 
262         /* read all the data off the channel without looking at it
<span class="line-modified">263              * return true if connection closed</span>
<span class="line-modified">264              */</span>
<span class="line-modified">265         boolean consume (SocketChannel chan) {</span>
266             try {
<span class="line-modified">267                 consumeBuffer.clear ();</span>
<span class="line-modified">268                 int c = chan.read (consumeBuffer);</span>
269                 if (c == -1)
270                     return true;
271             } catch (IOException e) {
272                 return true;
273             }
274             return false;
275         }
276     }
277 
278     static class ServerWorker extends Thread {
279         private ByteBuffer inNetBB;
280         private ByteBuffer outNetBB;
281         private ByteBuffer inAppBB;
282         private ByteBuffer outAppBB;
283 
284         SSLEngine sslEng;
285         SocketChannel schan;
286         HttpCallback cb;
287         HandshakeStatus currentHSStatus;
288         boolean initialHSComplete;

289         /*
290          * All inbound data goes through this buffer.
291          *
292          * It might be nice to use a cache of ByteBuffers so we&#39;re
293          * not alloc/dealloc&#39;ing all over the place.
294          */
295 
296         /*
297          * Application buffers, also used for handshaking
298          */
299         private int appBBSize;
300 
<span class="line-modified">301         ServerWorker (HttpCallback cb, SocketChannel schan, SSLEngine sslEng) {</span>
302             this.sslEng = sslEng;
303             this.schan = schan;
304             this.cb = cb;
305             currentHSStatus = HandshakeStatus.NEED_UNWRAP;
306             initialHSComplete = false;
307             int netBBSize = sslEng.getSession().getPacketBufferSize();
308             inNetBB =  ByteBuffer.allocate(netBBSize);
309             outNetBB = ByteBuffer.allocate(netBBSize);
310             appBBSize = sslEng.getSession().getApplicationBufferSize();
311             inAppBB = ByteBuffer.allocate(appBBSize);
312             outAppBB = ByteBuffer.allocate(appBBSize);
313         }
314 
315         public SSLEngine getSSLEngine() {
316             return sslEng;
317         }
318 
319         public ByteBuffer outNetBB() {
320             return outNetBB;
321         }
322 
323         public ByteBuffer outAppBB() {
324             return outAppBB;
325         }
326 
327         public void run () {
328             try {
329                 SSLEngineResult result;
330 
331                 while (!initialHSComplete) {
332 
333                     switch (currentHSStatus) {
334 
335                     case NEED_UNWRAP:
336                         int bytes = schan.read(inNetBB);



















337 
338 needIO:
339                         while (currentHSStatus == HandshakeStatus.NEED_UNWRAP) {
340                             /*
341                              * Don&#39;t need to resize requestBB, since no app data should
342                              * be generated here.
343                              */
344                             inNetBB.flip();
345                             result = sslEng.unwrap(inNetBB, inAppBB);
346                             inNetBB.compact();
347                             currentHSStatus = result.getHandshakeStatus();
348 
349                             switch (result.getStatus()) {
350 
351                             case OK:
352                                 switch (currentHSStatus) {
353                                 case NOT_HANDSHAKING:
354                                     throw new IOException(
355                                                           &quot;Not handshaking during initial handshake&quot;);
356 
</pre>
<hr />
<pre>
414                         break;
415 
416                     case FINISHED:
417                         initialHSComplete = true;
418                         break;
419                     default: // NOT_HANDSHAKING/NEED_TASK
420                         throw new RuntimeException(&quot;Invalid Handshaking State&quot; +
421                                                    currentHSStatus);
422                     } // switch
423                 }
424                 // read the application data; using non-blocking mode
425                 schan.configureBlocking(false);
426                 read(schan, sslEng);
427             } catch (Exception ex) {
428                 throw new RuntimeException(ex);
429             }
430         }
431 
432         /* return true if the connection is closed, false otherwise */
433 
<span class="line-modified">434         private boolean read (SocketChannel chan, SSLEngine sslEng) {</span>
435             HttpTransaction msg;
436             boolean res;
437             try {
<span class="line-modified">438                 InputStream is = new BufferedInputStream (new NioInputStream (chan, sslEng, inNetBB, inAppBB));</span>
<span class="line-modified">439                 String requestline = readLine (is);</span>
<span class="line-modified">440                 MessageHeader mhead = new MessageHeader (is);</span>
<span class="line-modified">441                 String clen = mhead.findValue (&quot;Content-Length&quot;);</span>
<span class="line-modified">442                 String trferenc = mhead.findValue (&quot;Transfer-Encoding&quot;);</span>
443                 String data = null;
<span class="line-modified">444                 if (trferenc != null &amp;&amp; trferenc.equals (&quot;chunked&quot;))</span>
<span class="line-modified">445                     data = new String (readChunkedData (is));</span>
446                 else if (clen != null)
<span class="line-modified">447                     data = new String (readNormalData (is, Integer.parseInt (clen)));</span>
<span class="line-modified">448                 String[] req = requestline.split (&quot; &quot;);</span>
449                 if (req.length &lt; 2) {
450                     /* invalid request line */
451                     return false;
452                 }
453                 String cmd = req[0];
454                 URI uri = null;
455                 try {
<span class="line-modified">456                     uri = new URI (req[1]);</span>
<span class="line-modified">457                     msg = new HttpTransaction (this, cmd, uri, mhead, data, null, chan);</span>
<span class="line-modified">458                     cb.request (msg);</span>
459                 } catch (URISyntaxException e) {
460                     System.err.println (&quot;Invalid URI: &quot; + e);
<span class="line-modified">461                     msg = new HttpTransaction (this, cmd, null, null, null, null, chan);</span>
<span class="line-modified">462                     msg.sendResponse (501, &quot;Whatever&quot;);</span>
463                 }
464                 res = false;
465             } catch (IOException e) {
466                 res = true;
467             }
468             return res;
469         }
470 
<span class="line-modified">471         byte[] readNormalData (InputStream is, int len) throws IOException {</span>
<span class="line-modified">472             byte [] buf  = new byte [len];</span>
473             int c, off=0, remain=len;
474             while (remain &gt; 0 &amp;&amp; ((c=is.read (buf, off, remain))&gt;0)) {
475                 remain -= c;
476                 off += c;
477             }
478             return buf;
479         }
480 
481         private void readCRLF(InputStream is) throws IOException {
482             int cr = is.read();
483             int lf = is.read();
484 
485             if (((cr &amp; 0xff) != 0x0d) ||
486                 ((lf &amp; 0xff) != 0x0a)) {
487                 throw new IOException(
488                     &quot;Expected &lt;CR&gt;&lt;LF&gt;:  got &#39;&quot; + cr + &quot;/&quot; + lf + &quot;&#39;&quot;);
489             }
490         }
491 
<span class="line-modified">492         byte[] readChunkedData (InputStream is) throws IOException {</span>
<span class="line-modified">493             LinkedList l = new LinkedList ();</span>
494             int total = 0;
495             for (int len=readChunkLen(is); len!=0; len=readChunkLen(is)) {
<span class="line-modified">496                 l.add (readNormalData(is, len));</span>
497                 total += len;
498                 readCRLF(is); // CRLF at end of chunk
499             }
500             readCRLF(is); // CRLF at end of Chunked Stream.
<span class="line-modified">501             byte[] buf = new byte [total];</span>
502             Iterator i = l.iterator();
503             int x = 0;
504             while (i.hasNext()) {
505                 byte[] b = (byte[])i.next();
<span class="line-modified">506                 System.arraycopy (b, 0, buf, x, b.length);</span>
507                 x += b.length;
508             }
509             return buf;
510         }
511 
<span class="line-modified">512         private int readChunkLen (InputStream is) throws IOException {</span>
513             int c, len=0;
514             boolean done=false, readCR=false;
515             while (!done) {
<span class="line-modified">516                 c = is.read ();</span>
517                 if (c == &#39;\n&#39; &amp;&amp; readCR) {
518                     done = true;
519                 } else {
520                     if (c == &#39;\r&#39; &amp;&amp; !readCR) {
521                         readCR = true;
522                     } else {
523                         int x=0;
524                         if (c &gt;= &#39;a&#39; &amp;&amp; c &lt;= &#39;f&#39;) {
525                             x = c - &#39;a&#39; + 10;
526                         } else if (c &gt;= &#39;A&#39; &amp;&amp; c &lt;= &#39;F&#39;) {
527                             x = c - &#39;A&#39; + 10;
528                         } else if (c &gt;= &#39;0&#39; &amp;&amp; c &lt;= &#39;9&#39;) {
529                             x = c - &#39;0&#39;;
530                         }
531                         len = len * 16 + x;
532                     }
533                 }
534             }
535             return len;
536         }
537 
<span class="line-modified">538         private String readLine (InputStream is) throws IOException {</span>
539             boolean done=false, readCR=false;
<span class="line-modified">540             byte[] b = new byte [512];</span>
541             int c, l = 0;
542 
543             while (!done) {
<span class="line-modified">544                 c = is.read ();</span>
545                 if (c == &#39;\n&#39; &amp;&amp; readCR) {
546                     done = true;
547                 } else {
548                     if (c == &#39;\r&#39; &amp;&amp; !readCR) {
549                         readCR = true;
550                     } else {
551                         b[l++] = (byte)c;
552                     }
553                 }
554             }
<span class="line-modified">555             return new String (b);</span>
556         }
557 
558         /** close the channel associated with the current key by:
559          * 1. shutdownOutput (send a FIN)
560          * 2. mark the key so that incoming data is to be consumed and discarded
561          * 3. After a period, close the socket
562          */
563 
<span class="line-modified">564         synchronized void orderlyCloseChannel (SocketChannel ch) throws IOException {</span>
565             ch.socket().shutdownOutput();
566         }
567 
<span class="line-modified">568         synchronized void abortiveCloseChannel (SocketChannel ch) throws IOException {</span>
<span class="line-modified">569             Socket s = ch.socket ();</span>
<span class="line-modified">570             s.setSoLinger (true, 0);</span>
571             ch.close();
572         }
573     }
574 
575 
576     /**
577      * Implements blocking reading semantics on top of a non-blocking channel
578      */
579 
580     static class NioInputStream extends InputStream {
581         SSLEngine sslEng;
582         SocketChannel channel;
583         Selector selector;
584         ByteBuffer inNetBB;
585         ByteBuffer inAppBB;
586         SelectionKey key;
587         int available;
588         byte[] one;
589         boolean closed;
590         ByteBuffer markBuf; /* reads may be satisifed from this buffer */
591         boolean marked;
592         boolean reset;
593         int readlimit;
594 
<span class="line-modified">595         public NioInputStream (SocketChannel chan, SSLEngine sslEng, ByteBuffer inNetBB, ByteBuffer inAppBB) throws IOException {</span>
596             this.sslEng = sslEng;
597             this.channel = chan;
598             selector = Selector.open();
599             this.inNetBB = inNetBB;
600             this.inAppBB = inAppBB;
<span class="line-modified">601             key = chan.register (selector, SelectionKey.OP_READ);</span>
602             available = 0;
603             one = new byte[1];
604             closed = marked = reset = false;
605         }
606 
<span class="line-modified">607         public synchronized int read (byte[] b) throws IOException {</span>
<span class="line-modified">608             return read (b, 0, b.length);</span>
609         }
610 
<span class="line-modified">611         public synchronized int read () throws IOException {</span>
<span class="line-modified">612             return read (one, 0, 1);</span>
613         }
614 
<span class="line-modified">615         public synchronized int read (byte[] b, int off, int srclen) throws IOException {</span>
616 
617             int canreturn, willreturn;
618 
619             if (closed)
620                 return -1;
621 
622             if (reset) { /* satisfy from markBuf */
<span class="line-modified">623                 canreturn = markBuf.remaining ();</span>
<span class="line-modified">624                 willreturn = canreturn&gt;srclen ? srclen : canreturn;</span>
625                 markBuf.get(b, off, willreturn);
626                 if (canreturn == willreturn) {
627                     reset = false;
628                 }
629             } else { /* satisfy from channel */
630                 canreturn = available();
631                 if (canreturn == 0) {
<span class="line-modified">632                     block ();</span>
633                     canreturn = available();
634                 }
<span class="line-modified">635                 willreturn = canreturn&gt;srclen ? srclen : canreturn;</span>
636                 inAppBB.get(b, off, willreturn);
637                 available -= willreturn;
638 
639                 if (marked) { /* copy into markBuf */
640                     try {
<span class="line-modified">641                         markBuf.put (b, off, willreturn);</span>
642                     } catch (BufferOverflowException e) {
643                         marked = false;
644                     }
645                 }
646             }
647             return willreturn;
648         }
649 
<span class="line-modified">650         public synchronized int available () throws IOException {</span>
651             if (closed)
<span class="line-modified">652                 throw new IOException (&quot;Stream is closed&quot;);</span>
653 
654             if (reset)
655                 return markBuf.remaining();
656 
657             if (available &gt; 0)
658                 return available;
659 
<span class="line-modified">660             inAppBB.clear ();</span>
<span class="line-modified">661             int bytes = channel.read (inNetBB);</span>
662 
663             int needed = sslEng.getSession().getApplicationBufferSize();
664             if (needed &gt; inAppBB.remaining()) {
665                 inAppBB = ByteBuffer.allocate(needed);
666             }
667             inNetBB.flip();
668             SSLEngineResult result = sslEng.unwrap(inNetBB, inAppBB);
669             inNetBB.compact();
670             available = result.bytesProduced();
671 
672             if (available &gt; 0)
673                 inAppBB.flip();
674             else if (available == -1)
<span class="line-modified">675                 throw new IOException (&quot;Stream is closed&quot;);</span>
676             return available;
677         }
678 
679         /**
680          * block() only called when available==0 and buf is empty
681          */
<span class="line-modified">682         private synchronized void block () throws IOException {</span>
683             //assert available == 0;
<span class="line-modified">684             int n = selector.select ();</span>
685             //assert n == 1;
686             selector.selectedKeys().clear();
<span class="line-modified">687             available ();</span>
688         }
689 
<span class="line-modified">690         public void close () throws IOException {</span>
691             if (closed)
692                 return;
<span class="line-modified">693             channel.close ();</span>
694             closed = true;
695         }
696 
<span class="line-modified">697         public synchronized void mark (int readlimit) {</span>
698             if (closed)
699                 return;
700             this.readlimit = readlimit;
<span class="line-modified">701             markBuf = ByteBuffer.allocate (readlimit);</span>
702             marked = true;
703             reset = false;
704         }
705 
<span class="line-modified">706         public synchronized void reset () throws IOException {</span>
707             if (closed )
708                 return;
709             if (!marked)
<span class="line-modified">710                 throw new IOException (&quot;Stream not marked&quot;);</span>
711             marked = false;
712             reset = true;
<span class="line-modified">713             markBuf.flip ();</span>
714         }
715     }
716 
717     static class NioOutputStream extends OutputStream {
718         SSLEngine sslEng;
719         SocketChannel channel;
720         ByteBuffer outNetBB;
721         ByteBuffer outAppBB;
722         SelectionKey key;
723         Selector selector;
724         boolean closed;
725         byte[] one;
726 
<span class="line-modified">727         public NioOutputStream (SocketChannel channel, SSLEngine sslEng, ByteBuffer outNetBB, ByteBuffer outAppBB) throws IOException {</span>
728             this.sslEng = sslEng;
729             this.channel = channel;
730             this.outNetBB = outNetBB;
731             this.outAppBB = outAppBB;
<span class="line-modified">732             selector = Selector.open ();</span>
<span class="line-modified">733             key = channel.register (selector, SelectionKey.OP_WRITE);</span>
734             closed = false;
<span class="line-modified">735             one = new byte [1];</span>
736         }
737 
<span class="line-modified">738         public synchronized void write (int b) throws IOException {</span>
739             one[0] = (byte)b;
<span class="line-modified">740             write (one, 0, 1);</span>
741         }
742 
<span class="line-modified">743         public synchronized void write (byte[] b) throws IOException {</span>
<span class="line-modified">744             write (b, 0, b.length);</span>
745         }
746 
<span class="line-modified">747         public synchronized void write (byte[] b, int off, int len) throws IOException {</span>
748             if (closed)
<span class="line-modified">749                 throw new IOException (&quot;stream is closed&quot;);</span>
750 
<span class="line-modified">751             outAppBB = ByteBuffer.allocate (len);</span>
<span class="line-modified">752             outAppBB.put (b, off, len);</span>
<span class="line-modified">753             outAppBB.flip ();</span>
754             int n;
755             outNetBB.clear();
756             int needed = sslEng.getSession().getPacketBufferSize();
757             if (outNetBB.capacity() &lt; needed) {
758                 outNetBB = ByteBuffer.allocate(needed);
759             }
760             SSLEngineResult ret = sslEng.wrap(outAppBB, outNetBB);
761             outNetBB.flip();
762             int newLen = ret.bytesProduced();
763             while ((n = channel.write (outNetBB)) &lt; newLen) {
764                 newLen -= n;
765                 if (newLen == 0)
766                     return;
<span class="line-modified">767                 selector.select ();</span>
<span class="line-modified">768                 selector.selectedKeys().clear ();</span>
769             }
770         }
771 
<span class="line-modified">772         public void close () throws IOException {</span>
773             if (closed)
774                 return;
<span class="line-modified">775             channel.close ();</span>
776             closed = true;
777         }
778     }
779 
780     /**
781      * Utilities for synchronization. A condition is
782      * identified by a string name, and is initialized
783      * upon first use (ie. setCondition() or waitForCondition()). Threads
784      * are blocked until some thread calls (or has called) setCondition() for the same
785      * condition.
786      * &lt;P&gt;
787      * A rendezvous built on a condition is also provided for synchronizing
788      * N threads.
789      */
790 
791     private static HashMap conditions = new HashMap();
792 
793     /*
794      * Modifiable boolean object
795      */
796     private static class BValue {
797         boolean v;
798     }
799 
800     /*
801      * Modifiable int object
802      */
803     private static class IValue {
804         int v;
<span class="line-modified">805         IValue (int i) {</span>
806             v =i;
807         }
808     }
809 
810 
<span class="line-modified">811     private static BValue getCond (String condition) {</span>
812         synchronized (conditions) {
<span class="line-modified">813             BValue cond = (BValue) conditions.get (condition);</span>
814             if (cond == null) {
815                 cond = new BValue();
<span class="line-modified">816                 conditions.put (condition, cond);</span>
817             }
818             return cond;
819         }
820     }
821 
822     /**
823      * Set the condition to true. Any threads that are currently blocked
824      * waiting on the condition, will be unblocked and allowed to continue.
825      * Threads that subsequently call waitForCondition() will not block.
826      * If the named condition did not exist prior to the call, then it is created
827      * first.
828      */
829 
<span class="line-modified">830     public static void setCondition (String condition) {</span>
<span class="line-modified">831         BValue cond = getCond (condition);</span>
832         synchronized (cond) {
833             if (cond.v) {
834                 return;
835             }
836             cond.v = true;
837             cond.notifyAll();
838         }
839     }
840 
841     /**
842      * If the named condition does not exist, then it is created and initialized
843      * to false. If the condition exists or has just been created and its value
844      * is false, then the thread blocks until another thread sets the condition.
845      * If the condition exists and is already set to true, then this call returns
846      * immediately without blocking.
847      */
848 
<span class="line-modified">849     public static void waitForCondition (String condition) {</span>
<span class="line-modified">850         BValue cond = getCond (condition);</span>
851         synchronized (cond) {
852             if (!cond.v) {
853                 try {
854                     cond.wait();
855                 } catch (InterruptedException e) {}
856             }
857         }
858     }
859 
860     /* conditions must be locked when accessing this */
861     static HashMap rv = new HashMap();
862 
863     /**
864      * Force N threads to rendezvous (ie. wait for each other) before proceeding.
865      * The first thread(s) to call are blocked until the last
866      * thread makes the call. Then all threads continue.
867      * &lt;p&gt;
868      * All threads that call with the same condition name, must use the same value
869      * for N (or the results may be not be as expected).
870      * &lt;P&gt;
871      * Obviously, if fewer than N threads make the rendezvous then the result
872      * will be a hang.
873      */
874 
<span class="line-modified">875     public static void rendezvous (String condition, int N) {</span>
876         BValue cond;
877         IValue iv;
878         String name = &quot;RV_&quot;+condition;
879 
880         /* get the condition */
881 
882         synchronized (conditions) {
<span class="line-modified">883             cond = (BValue)conditions.get (name);</span>
884             if (cond == null) {
885                 /* we are first caller */
886                 if (N &lt; 2) {
<span class="line-modified">887                     throw new RuntimeException (&quot;rendezvous must be called with N &gt;= 2&quot;);</span>
888                 }
<span class="line-modified">889                 cond = new BValue ();</span>
<span class="line-modified">890                 conditions.put (name, cond);</span>
<span class="line-modified">891                 iv = new IValue (N-1);</span>
<span class="line-modified">892                 rv.put (name, iv);</span>
893             } else {
894                 /* already initialised, just decrement the counter */
<span class="line-modified">895                 iv = (IValue) rv.get (name);</span>
<span class="line-modified">896                 iv.v --;</span>
897             }
898         }
899 
900         if (iv.v &gt; 0) {
<span class="line-modified">901             waitForCondition (name);</span>
902         } else {
<span class="line-modified">903             setCondition (name);</span>
904             synchronized (conditions) {
<span class="line-modified">905                 clearCondition (name);</span>
<span class="line-modified">906                 rv.remove (name);</span>
907             }
908         }
909     }
910 
911     /**
912      * If the named condition exists and is set then remove it, so it can
913      * be re-initialized and used again. If the condition does not exist, or
914      * exists but is not set, then the call returns without doing anything.
915      * Note, some higher level synchronization
916      * may be needed between clear and the other operations.
917      */
918 
919     public static void clearCondition(String condition) {
920         BValue cond;
921         synchronized (conditions) {
<span class="line-modified">922             cond = (BValue) conditions.get (condition);</span>
923             if (cond == null) {
924                 return;
925             }
926             synchronized (cond) {
927                 if (cond.v) {
<span class="line-modified">928                     conditions.remove (condition);</span>
929                 }
930             }
931         }
932     }
933 }
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2002, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
</pre>
<hr />
<pre>
 53 
 54 public class TestHttpsServer {
 55 
 56     ServerSocketChannel schan;
 57     int threads;
 58     int cperthread;
 59     HttpCallback cb;
 60     Server[] servers;
 61 
 62     // ssl related fields
 63     static SSLContext sslCtx;
 64 
 65     /**
 66      * Create a &lt;code&gt;TestHttpsServer&lt;code&gt; instance with the specified callback object
 67      * for handling requests. One thread is created to handle requests,
 68      * and up to ten TCP connections will be handled simultaneously.
 69      * @param cb the callback object which is invoked to handle each
 70      *  incoming request
 71      */
 72 
<span class="line-modified"> 73     public TestHttpsServer(HttpCallback cb) throws IOException {</span>
<span class="line-modified"> 74         this(cb, 1, 10, 0);</span>
 75     }
 76 
 77     /**
 78      * Create a &lt;code&gt;TestHttpsServer&lt;code&gt; instance with the specified number of
 79      * threads and maximum number of connections per thread. This functions
 80      * the same as the 4 arg constructor, where the port argument is set to zero.
 81      * @param cb the callback object which is invoked to handle each
 82      *     incoming request
 83      * @param threads the number of threads to create to handle requests
 84      *     in parallel
 85      * @param cperthread the number of simultaneous TCP connections to
 86      *     handle per thread
 87      */
 88 
<span class="line-modified"> 89     public TestHttpsServer(HttpCallback cb, int threads, int cperthread)</span>
 90         throws IOException {
<span class="line-modified"> 91         this(cb, threads, cperthread, 0);</span>
 92     }
 93 
 94     /**
 95      * Create a &lt;code&gt;TestHttpsServer&lt;code&gt; instance with the specified number
 96      * of threads and maximum number of connections per thread and running on
 97      * the specified port. The specified number of threads are created to
 98      * handle incoming requests, and each thread is allowed
 99      * to handle a number of simultaneous TCP connections.
100      * @param cb the callback object which is invoked to handle
101      *  each incoming request
102      * @param threads the number of threads to create to handle
103      *  requests in parallel
104      * @param cperthread the number of simultaneous TCP connections
105      *  to handle per thread
106      * @param port the port number to bind the server to. &lt;code&gt;Zero&lt;/code&gt;
107      *  means choose any free port.
108      */
<span class="line-added">109     public TestHttpsServer(HttpCallback cb, int threads, int cperthread, int port)</span>
<span class="line-added">110         throws IOException {</span>
<span class="line-added">111         this(cb, threads, cperthread, null, port);</span>
<span class="line-added">112     }</span>
113 
<span class="line-modified">114     /**</span>
<span class="line-added">115      * Create a &lt;code&gt;TestHttpsServer&lt;code&gt; instance with the specified number</span>
<span class="line-added">116      * of threads and maximum number of connections per thread and running on</span>
<span class="line-added">117      * the specified port. The specified number of threads are created to</span>
<span class="line-added">118      * handle incoming requests, and each thread is allowed</span>
<span class="line-added">119      * to handle a number of simultaneous TCP connections.</span>
<span class="line-added">120      * @param cb the callback object which is invoked to handle</span>
<span class="line-added">121      *  each incoming request</span>
<span class="line-added">122      * @param threads the number of threads to create to handle</span>
<span class="line-added">123      *  requests in parallel</span>
<span class="line-added">124      * @param cperthread the number of simultaneous TCP connections</span>
<span class="line-added">125      *  to handle per thread</span>
<span class="line-added">126      * @param address the InetAddress to bind to. {@code Null} means the</span>
<span class="line-added">127      *  wildcard address.</span>
<span class="line-added">128      * @param port the port number to bind the server to. {@code Zero}</span>
<span class="line-added">129      *  means choose any free port.</span>
<span class="line-added">130      */</span>
<span class="line-added">131 </span>
<span class="line-added">132     public TestHttpsServer(HttpCallback cb, int threads, int cperthread, InetAddress address, int port)</span>
133         throws IOException {
<span class="line-modified">134         schan = ServerSocketChannel.open();</span>
<span class="line-modified">135         InetSocketAddress addr = new InetSocketAddress(address, port);</span>
<span class="line-modified">136         schan.socket().bind(addr);</span>
137         this.threads = threads;
138         this.cb = cb;
139         this.cperthread = cperthread;
140 
141         try {
142             // create and initialize a SSLContext
143             KeyStore ks = KeyStore.getInstance(&quot;JKS&quot;);
144             KeyStore ts = KeyStore.getInstance(&quot;JKS&quot;);
145             char[] passphrase = &quot;passphrase&quot;.toCharArray();
146 
147             ks.load(new FileInputStream(System.getProperty(&quot;javax.net.ssl.keyStore&quot;)), passphrase);
148             ts.load(new FileInputStream(System.getProperty(&quot;javax.net.ssl.trustStore&quot;)), passphrase);
149 
150             KeyManagerFactory kmf = KeyManagerFactory.getInstance(&quot;SunX509&quot;);
151             kmf.init(ks, passphrase);
152 
153             TrustManagerFactory tmf = TrustManagerFactory.getInstance(&quot;SunX509&quot;);
154             tmf.init(ts);
155 
156             sslCtx = SSLContext.getInstance(&quot;TLS&quot;);
157 
158             sslCtx.init(kmf.getKeyManagers(), tmf.getTrustManagers(), null);
159 
<span class="line-modified">160             servers = new Server[threads];</span>
161             for (int i=0; i&lt;threads; i++) {
<span class="line-modified">162                 servers[i] = new Server(cb, schan, cperthread);</span>
163                 servers[i].start();
164             }
165         } catch (Exception ex) {
166             throw new RuntimeException(&quot;test failed. cause: &quot;+ex.getMessage());
167         }
168     }
169 
170     /** Tell all threads in the server to exit within 5 seconds.
171      *  This is an abortive termination. Just prior to the thread exiting
172      *  all channels in that thread waiting to be closed are forceably closed.
173      */
174 
<span class="line-modified">175     public void terminate() {</span>
176         for (int i=0; i&lt;threads; i++) {
177             servers[i].terminate ();
178         }
179     }
180 
181     /**
182      * return the local port number to which the server is bound.
183      * @return the local port number
184      */
185 
186     public int getLocalPort () {
187         return schan.socket().getLocalPort ();
188     }
189 
<span class="line-added">190     public String getAuthority() {</span>
<span class="line-added">191         InetAddress address = schan.socket().getInetAddress();</span>
<span class="line-added">192         String hostaddr = address.getHostAddress();</span>
<span class="line-added">193         if (address.isAnyLocalAddress()) hostaddr = &quot;localhost&quot;;</span>
<span class="line-added">194         if (hostaddr.indexOf(&#39;:&#39;) &gt; -1) hostaddr = &quot;[&quot; + hostaddr + &quot;]&quot;;</span>
<span class="line-added">195         return hostaddr + &quot;:&quot; + getLocalPort();</span>
<span class="line-added">196     }</span>
<span class="line-added">197 </span>
198     static class Server extends Thread {
199 
200         ServerSocketChannel schan;
201         Selector selector;
202         SelectionKey listenerKey;
203         SelectionKey key; /* the current key being processed */
204         HttpCallback cb;
205         ByteBuffer consumeBuffer;
206         int maxconn;
207         int nconn;
208         ClosedChannelList clist;
209         boolean shutdown;
210 
<span class="line-modified">211         Server(HttpCallback cb, ServerSocketChannel schan, int maxconn) {</span>
212             this.schan = schan;
213             this.maxconn = maxconn;
214             this.cb = cb;
215             nconn = 0;
<span class="line-modified">216             consumeBuffer = ByteBuffer.allocate(512);</span>
<span class="line-modified">217             clist = new ClosedChannelList();</span>
218             try {
<span class="line-modified">219                 selector = Selector.open();</span>
<span class="line-modified">220                 schan.configureBlocking(false);</span>
<span class="line-modified">221                 listenerKey = schan.register(selector, SelectionKey.OP_ACCEPT);</span>
222             } catch (IOException e) {
<span class="line-modified">223                 System.err.println(&quot;Server could not start: &quot; + e);</span>
224             }
225         }
226 
227         /* Stop the thread as soon as possible */
<span class="line-modified">228         public synchronized void terminate() {</span>
229             shutdown = true;
230         }
231 
<span class="line-modified">232         public void run()  {</span>
233             try {
234                 while (true) {
<span class="line-modified">235                     selector.select(1000);</span>
236                     Set selected = selector.selectedKeys();
237                     Iterator iter = selected.iterator();
238                     while (iter.hasNext()) {
239                         key = (SelectionKey)iter.next();
240                         if (key.equals (listenerKey)) {
<span class="line-modified">241                             SocketChannel sock = schan.accept();</span>
242                             if (sock == null) {
243                                 /* false notification */
244                                 iter.remove();
245                                 continue;
246                             }
<span class="line-modified">247                             sock.configureBlocking(true);</span>
248                             SSLEngine sslEng = sslCtx.createSSLEngine();
249                             sslEng.setUseClientMode(false);
250                             new ServerWorker(cb, sock, sslEng).start();
251                             nconn ++;
252                             if (nconn == maxconn) {
253                                 /* deregister */
<span class="line-modified">254                                 listenerKey.cancel();</span>
255                                 listenerKey = null;
256                             }
257                         } else {
258                             if (key.isReadable()) {
259                                 boolean closed = false;
<span class="line-modified">260                                 SocketChannel chan = (SocketChannel)key.channel();</span>
261                                 if (key.attachment() != null) {
<span class="line-modified">262                                     closed = consume(chan);</span>
263                                 }
264 
265                                 if (closed) {
<span class="line-modified">266                                     chan.close();</span>
<span class="line-modified">267                                     key.cancel();</span>
268                                     if (nconn == maxconn) {
<span class="line-modified">269                                         listenerKey = schan.register(selector, SelectionKey.OP_ACCEPT);</span>
270                                     }
271                                     nconn --;
272                                 }
273                             }
274                         }
275                         iter.remove();
276                     }
277                     clist.check();
278 
279                     synchronized (this) {
280                         if (shutdown) {
<span class="line-modified">281                             clist.terminate();</span>
282                             return;
283                         }
284                     }
285                 }
286             } catch (IOException e) {
<span class="line-modified">287                 System.out.println(&quot;Server exception: &quot; + e);</span>
288                 // TODO finish
289             }
290         }
291 
292         /* read all the data off the channel without looking at it
<span class="line-modified">293          * return true if connection closed</span>
<span class="line-modified">294          */</span>
<span class="line-modified">295         boolean consume(SocketChannel chan) {</span>
296             try {
<span class="line-modified">297                 consumeBuffer.clear();</span>
<span class="line-modified">298                 int c = chan.read(consumeBuffer);</span>
299                 if (c == -1)
300                     return true;
301             } catch (IOException e) {
302                 return true;
303             }
304             return false;
305         }
306     }
307 
308     static class ServerWorker extends Thread {
309         private ByteBuffer inNetBB;
310         private ByteBuffer outNetBB;
311         private ByteBuffer inAppBB;
312         private ByteBuffer outAppBB;
313 
314         SSLEngine sslEng;
315         SocketChannel schan;
316         HttpCallback cb;
317         HandshakeStatus currentHSStatus;
318         boolean initialHSComplete;
<span class="line-added">319         boolean handshakeStarted;</span>
320         /*
321          * All inbound data goes through this buffer.
322          *
323          * It might be nice to use a cache of ByteBuffers so we&#39;re
324          * not alloc/dealloc&#39;ing all over the place.
325          */
326 
327         /*
328          * Application buffers, also used for handshaking
329          */
330         private int appBBSize;
331 
<span class="line-modified">332         ServerWorker(HttpCallback cb, SocketChannel schan, SSLEngine sslEng) {</span>
333             this.sslEng = sslEng;
334             this.schan = schan;
335             this.cb = cb;
336             currentHSStatus = HandshakeStatus.NEED_UNWRAP;
337             initialHSComplete = false;
338             int netBBSize = sslEng.getSession().getPacketBufferSize();
339             inNetBB =  ByteBuffer.allocate(netBBSize);
340             outNetBB = ByteBuffer.allocate(netBBSize);
341             appBBSize = sslEng.getSession().getApplicationBufferSize();
342             inAppBB = ByteBuffer.allocate(appBBSize);
343             outAppBB = ByteBuffer.allocate(appBBSize);
344         }
345 
346         public SSLEngine getSSLEngine() {
347             return sslEng;
348         }
349 
350         public ByteBuffer outNetBB() {
351             return outNetBB;
352         }
353 
354         public ByteBuffer outAppBB() {
355             return outAppBB;
356         }
357 
358         public void run () {
359             try {
360                 SSLEngineResult result;
361 
362                 while (!initialHSComplete) {
363 
364                     switch (currentHSStatus) {
365 
366                     case NEED_UNWRAP:
367                         int bytes = schan.read(inNetBB);
<span class="line-added">368                         if (!handshakeStarted &amp;&amp; bytes &gt; 0) {</span>
<span class="line-added">369                             handshakeStarted = true;</span>
<span class="line-added">370                             int byte0 = inNetBB.get(0);</span>
<span class="line-added">371                             if (byte0 != 0x16) {</span>
<span class="line-added">372                                 // first byte of a TLS connection is supposed to be</span>
<span class="line-added">373                                 // 0x16. If not it may be a plain text connection.</span>
<span class="line-added">374                                 //</span>
<span class="line-added">375                                 // Sometime a rogue client may try to open a plain</span>
<span class="line-added">376                                 // connection with our server. Calling this method</span>
<span class="line-added">377                                 // gives a chance to the test logic to ignore such</span>
<span class="line-added">378                                 // rogue connections.</span>
<span class="line-added">379                                 //</span>
<span class="line-added">380                                 if (cb.dropPlainTextConnections()) {</span>
<span class="line-added">381                                     try { schan.close(); } catch (IOException x) { };</span>
<span class="line-added">382                                     return;</span>
<span class="line-added">383                                 }</span>
<span class="line-added">384                                 // else sslEng.unwrap will throw later on...</span>
<span class="line-added">385                             }</span>
<span class="line-added">386                         }</span>
387 
388 needIO:
389                         while (currentHSStatus == HandshakeStatus.NEED_UNWRAP) {
390                             /*
391                              * Don&#39;t need to resize requestBB, since no app data should
392                              * be generated here.
393                              */
394                             inNetBB.flip();
395                             result = sslEng.unwrap(inNetBB, inAppBB);
396                             inNetBB.compact();
397                             currentHSStatus = result.getHandshakeStatus();
398 
399                             switch (result.getStatus()) {
400 
401                             case OK:
402                                 switch (currentHSStatus) {
403                                 case NOT_HANDSHAKING:
404                                     throw new IOException(
405                                                           &quot;Not handshaking during initial handshake&quot;);
406 
</pre>
<hr />
<pre>
464                         break;
465 
466                     case FINISHED:
467                         initialHSComplete = true;
468                         break;
469                     default: // NOT_HANDSHAKING/NEED_TASK
470                         throw new RuntimeException(&quot;Invalid Handshaking State&quot; +
471                                                    currentHSStatus);
472                     } // switch
473                 }
474                 // read the application data; using non-blocking mode
475                 schan.configureBlocking(false);
476                 read(schan, sslEng);
477             } catch (Exception ex) {
478                 throw new RuntimeException(ex);
479             }
480         }
481 
482         /* return true if the connection is closed, false otherwise */
483 
<span class="line-modified">484         private boolean read(SocketChannel chan, SSLEngine sslEng) {</span>
485             HttpTransaction msg;
486             boolean res;
487             try {
<span class="line-modified">488                 InputStream is = new BufferedInputStream(new NioInputStream(chan, sslEng, inNetBB, inAppBB));</span>
<span class="line-modified">489                 String requestline = readLine(is);</span>
<span class="line-modified">490                 MessageHeader mhead = new MessageHeader(is);</span>
<span class="line-modified">491                 String clen = mhead.findValue(&quot;Content-Length&quot;);</span>
<span class="line-modified">492                 String trferenc = mhead.findValue(&quot;Transfer-Encoding&quot;);</span>
493                 String data = null;
<span class="line-modified">494                 if (trferenc != null &amp;&amp; trferenc.equals(&quot;chunked&quot;))</span>
<span class="line-modified">495                     data = new String(readChunkedData(is));</span>
496                 else if (clen != null)
<span class="line-modified">497                     data = new String(readNormalData(is, Integer.parseInt(clen)));</span>
<span class="line-modified">498                 String[] req = requestline.split(&quot; &quot;);</span>
499                 if (req.length &lt; 2) {
500                     /* invalid request line */
501                     return false;
502                 }
503                 String cmd = req[0];
504                 URI uri = null;
505                 try {
<span class="line-modified">506                     uri = new URI(req[1]);</span>
<span class="line-modified">507                     msg = new HttpTransaction(this, cmd, uri, mhead, data, null, chan);</span>
<span class="line-modified">508                     cb.request(msg);</span>
509                 } catch (URISyntaxException e) {
510                     System.err.println (&quot;Invalid URI: &quot; + e);
<span class="line-modified">511                     msg = new HttpTransaction(this, cmd, null, null, null, null, chan);</span>
<span class="line-modified">512                     msg.sendResponse(501, &quot;Whatever&quot;);</span>
513                 }
514                 res = false;
515             } catch (IOException e) {
516                 res = true;
517             }
518             return res;
519         }
520 
<span class="line-modified">521         byte[] readNormalData(InputStream is, int len) throws IOException {</span>
<span class="line-modified">522             byte[] buf  = new byte[len];</span>
523             int c, off=0, remain=len;
524             while (remain &gt; 0 &amp;&amp; ((c=is.read (buf, off, remain))&gt;0)) {
525                 remain -= c;
526                 off += c;
527             }
528             return buf;
529         }
530 
531         private void readCRLF(InputStream is) throws IOException {
532             int cr = is.read();
533             int lf = is.read();
534 
535             if (((cr &amp; 0xff) != 0x0d) ||
536                 ((lf &amp; 0xff) != 0x0a)) {
537                 throw new IOException(
538                     &quot;Expected &lt;CR&gt;&lt;LF&gt;:  got &#39;&quot; + cr + &quot;/&quot; + lf + &quot;&#39;&quot;);
539             }
540         }
541 
<span class="line-modified">542         byte[] readChunkedData(InputStream is) throws IOException {</span>
<span class="line-modified">543             LinkedList l = new LinkedList();</span>
544             int total = 0;
545             for (int len=readChunkLen(is); len!=0; len=readChunkLen(is)) {
<span class="line-modified">546                 l.add(readNormalData(is, len));</span>
547                 total += len;
548                 readCRLF(is); // CRLF at end of chunk
549             }
550             readCRLF(is); // CRLF at end of Chunked Stream.
<span class="line-modified">551             byte[] buf = new byte[total];</span>
552             Iterator i = l.iterator();
553             int x = 0;
554             while (i.hasNext()) {
555                 byte[] b = (byte[])i.next();
<span class="line-modified">556                 System.arraycopy(b, 0, buf, x, b.length);</span>
557                 x += b.length;
558             }
559             return buf;
560         }
561 
<span class="line-modified">562         private int readChunkLen(InputStream is) throws IOException {</span>
563             int c, len=0;
564             boolean done=false, readCR=false;
565             while (!done) {
<span class="line-modified">566                 c = is.read();</span>
567                 if (c == &#39;\n&#39; &amp;&amp; readCR) {
568                     done = true;
569                 } else {
570                     if (c == &#39;\r&#39; &amp;&amp; !readCR) {
571                         readCR = true;
572                     } else {
573                         int x=0;
574                         if (c &gt;= &#39;a&#39; &amp;&amp; c &lt;= &#39;f&#39;) {
575                             x = c - &#39;a&#39; + 10;
576                         } else if (c &gt;= &#39;A&#39; &amp;&amp; c &lt;= &#39;F&#39;) {
577                             x = c - &#39;A&#39; + 10;
578                         } else if (c &gt;= &#39;0&#39; &amp;&amp; c &lt;= &#39;9&#39;) {
579                             x = c - &#39;0&#39;;
580                         }
581                         len = len * 16 + x;
582                     }
583                 }
584             }
585             return len;
586         }
587 
<span class="line-modified">588         private String readLine(InputStream is) throws IOException {</span>
589             boolean done=false, readCR=false;
<span class="line-modified">590             byte[] b = new byte[512];</span>
591             int c, l = 0;
592 
593             while (!done) {
<span class="line-modified">594                 c = is.read();</span>
595                 if (c == &#39;\n&#39; &amp;&amp; readCR) {
596                     done = true;
597                 } else {
598                     if (c == &#39;\r&#39; &amp;&amp; !readCR) {
599                         readCR = true;
600                     } else {
601                         b[l++] = (byte)c;
602                     }
603                 }
604             }
<span class="line-modified">605             return new String(b);</span>
606         }
607 
608         /** close the channel associated with the current key by:
609          * 1. shutdownOutput (send a FIN)
610          * 2. mark the key so that incoming data is to be consumed and discarded
611          * 3. After a period, close the socket
612          */
613 
<span class="line-modified">614         synchronized void orderlyCloseChannel(SocketChannel ch) throws IOException {</span>
615             ch.socket().shutdownOutput();
616         }
617 
<span class="line-modified">618         synchronized void abortiveCloseChannel(SocketChannel ch) throws IOException {</span>
<span class="line-modified">619             Socket s = ch.socket();</span>
<span class="line-modified">620             s.setSoLinger(true, 0);</span>
621             ch.close();
622         }
623     }
624 
625 
626     /**
627      * Implements blocking reading semantics on top of a non-blocking channel
628      */
629 
630     static class NioInputStream extends InputStream {
631         SSLEngine sslEng;
632         SocketChannel channel;
633         Selector selector;
634         ByteBuffer inNetBB;
635         ByteBuffer inAppBB;
636         SelectionKey key;
637         int available;
638         byte[] one;
639         boolean closed;
640         ByteBuffer markBuf; /* reads may be satisifed from this buffer */
641         boolean marked;
642         boolean reset;
643         int readlimit;
644 
<span class="line-modified">645         public NioInputStream(SocketChannel chan, SSLEngine sslEng, ByteBuffer inNetBB, ByteBuffer inAppBB) throws IOException {</span>
646             this.sslEng = sslEng;
647             this.channel = chan;
648             selector = Selector.open();
649             this.inNetBB = inNetBB;
650             this.inAppBB = inAppBB;
<span class="line-modified">651             key = chan.register(selector, SelectionKey.OP_READ);</span>
652             available = 0;
653             one = new byte[1];
654             closed = marked = reset = false;
655         }
656 
<span class="line-modified">657         public synchronized int read(byte[] b) throws IOException {</span>
<span class="line-modified">658             return read(b, 0, b.length);</span>
659         }
660 
<span class="line-modified">661         public synchronized int read() throws IOException {</span>
<span class="line-modified">662             return read(one, 0, 1);</span>
663         }
664 
<span class="line-modified">665         public synchronized int read(byte[] b, int off, int srclen) throws IOException {</span>
666 
667             int canreturn, willreturn;
668 
669             if (closed)
670                 return -1;
671 
672             if (reset) { /* satisfy from markBuf */
<span class="line-modified">673                 canreturn = markBuf.remaining();</span>
<span class="line-modified">674                 willreturn = canreturn &gt; srclen ? srclen : canreturn;</span>
675                 markBuf.get(b, off, willreturn);
676                 if (canreturn == willreturn) {
677                     reset = false;
678                 }
679             } else { /* satisfy from channel */
680                 canreturn = available();
681                 if (canreturn == 0) {
<span class="line-modified">682                     block();</span>
683                     canreturn = available();
684                 }
<span class="line-modified">685                 willreturn = canreturn &gt; srclen ? srclen : canreturn;</span>
686                 inAppBB.get(b, off, willreturn);
687                 available -= willreturn;
688 
689                 if (marked) { /* copy into markBuf */
690                     try {
<span class="line-modified">691                         markBuf.put(b, off, willreturn);</span>
692                     } catch (BufferOverflowException e) {
693                         marked = false;
694                     }
695                 }
696             }
697             return willreturn;
698         }
699 
<span class="line-modified">700         public synchronized int available() throws IOException {</span>
701             if (closed)
<span class="line-modified">702                 throw new IOException(&quot;Stream is closed&quot;);</span>
703 
704             if (reset)
705                 return markBuf.remaining();
706 
707             if (available &gt; 0)
708                 return available;
709 
<span class="line-modified">710             inAppBB.clear();</span>
<span class="line-modified">711             int bytes = channel.read(inNetBB);</span>
712 
713             int needed = sslEng.getSession().getApplicationBufferSize();
714             if (needed &gt; inAppBB.remaining()) {
715                 inAppBB = ByteBuffer.allocate(needed);
716             }
717             inNetBB.flip();
718             SSLEngineResult result = sslEng.unwrap(inNetBB, inAppBB);
719             inNetBB.compact();
720             available = result.bytesProduced();
721 
722             if (available &gt; 0)
723                 inAppBB.flip();
724             else if (available == -1)
<span class="line-modified">725                 throw new IOException(&quot;Stream is closed&quot;);</span>
726             return available;
727         }
728 
729         /**
730          * block() only called when available==0 and buf is empty
731          */
<span class="line-modified">732         private synchronized void block() throws IOException {</span>
733             //assert available == 0;
<span class="line-modified">734             int n = selector.select();</span>
735             //assert n == 1;
736             selector.selectedKeys().clear();
<span class="line-modified">737             available();</span>
738         }
739 
<span class="line-modified">740         public void close() throws IOException {</span>
741             if (closed)
742                 return;
<span class="line-modified">743             channel.close();</span>
744             closed = true;
745         }
746 
<span class="line-modified">747         public synchronized void mark(int readlimit) {</span>
748             if (closed)
749                 return;
750             this.readlimit = readlimit;
<span class="line-modified">751             markBuf = ByteBuffer.allocate(readlimit);</span>
752             marked = true;
753             reset = false;
754         }
755 
<span class="line-modified">756         public synchronized void reset() throws IOException {</span>
757             if (closed )
758                 return;
759             if (!marked)
<span class="line-modified">760                 throw new IOException(&quot;Stream not marked&quot;);</span>
761             marked = false;
762             reset = true;
<span class="line-modified">763             markBuf.flip();</span>
764         }
765     }
766 
767     static class NioOutputStream extends OutputStream {
768         SSLEngine sslEng;
769         SocketChannel channel;
770         ByteBuffer outNetBB;
771         ByteBuffer outAppBB;
772         SelectionKey key;
773         Selector selector;
774         boolean closed;
775         byte[] one;
776 
<span class="line-modified">777         public NioOutputStream(SocketChannel channel, SSLEngine sslEng, ByteBuffer outNetBB, ByteBuffer outAppBB) throws IOException {</span>
778             this.sslEng = sslEng;
779             this.channel = channel;
780             this.outNetBB = outNetBB;
781             this.outAppBB = outAppBB;
<span class="line-modified">782             selector = Selector.open();</span>
<span class="line-modified">783             key = channel.register(selector, SelectionKey.OP_WRITE);</span>
784             closed = false;
<span class="line-modified">785             one = new byte[1];</span>
786         }
787 
<span class="line-modified">788         public synchronized void write(int b) throws IOException {</span>
789             one[0] = (byte)b;
<span class="line-modified">790             write(one, 0, 1);</span>
791         }
792 
<span class="line-modified">793         public synchronized void write(byte[] b) throws IOException {</span>
<span class="line-modified">794             write(b, 0, b.length);</span>
795         }
796 
<span class="line-modified">797         public synchronized void write(byte[] b, int off, int len) throws IOException {</span>
798             if (closed)
<span class="line-modified">799                 throw new IOException(&quot;stream is closed&quot;);</span>
800 
<span class="line-modified">801             outAppBB = ByteBuffer.allocate(len);</span>
<span class="line-modified">802             outAppBB.put(b, off, len);</span>
<span class="line-modified">803             outAppBB.flip();</span>
804             int n;
805             outNetBB.clear();
806             int needed = sslEng.getSession().getPacketBufferSize();
807             if (outNetBB.capacity() &lt; needed) {
808                 outNetBB = ByteBuffer.allocate(needed);
809             }
810             SSLEngineResult ret = sslEng.wrap(outAppBB, outNetBB);
811             outNetBB.flip();
812             int newLen = ret.bytesProduced();
813             while ((n = channel.write (outNetBB)) &lt; newLen) {
814                 newLen -= n;
815                 if (newLen == 0)
816                     return;
<span class="line-modified">817                 selector.select();</span>
<span class="line-modified">818                 selector.selectedKeys().clear();</span>
819             }
820         }
821 
<span class="line-modified">822         public void close() throws IOException {</span>
823             if (closed)
824                 return;
<span class="line-modified">825             channel.close();</span>
826             closed = true;
827         }
828     }
829 
830     /**
831      * Utilities for synchronization. A condition is
832      * identified by a string name, and is initialized
833      * upon first use (ie. setCondition() or waitForCondition()). Threads
834      * are blocked until some thread calls (or has called) setCondition() for the same
835      * condition.
836      * &lt;P&gt;
837      * A rendezvous built on a condition is also provided for synchronizing
838      * N threads.
839      */
840 
841     private static HashMap conditions = new HashMap();
842 
843     /*
844      * Modifiable boolean object
845      */
846     private static class BValue {
847         boolean v;
848     }
849 
850     /*
851      * Modifiable int object
852      */
853     private static class IValue {
854         int v;
<span class="line-modified">855         IValue(int i) {</span>
856             v =i;
857         }
858     }
859 
860 
<span class="line-modified">861     private static BValue getCond(String condition) {</span>
862         synchronized (conditions) {
<span class="line-modified">863             BValue cond = (BValue) conditions.get(condition);</span>
864             if (cond == null) {
865                 cond = new BValue();
<span class="line-modified">866                 conditions.put(condition, cond);</span>
867             }
868             return cond;
869         }
870     }
871 
872     /**
873      * Set the condition to true. Any threads that are currently blocked
874      * waiting on the condition, will be unblocked and allowed to continue.
875      * Threads that subsequently call waitForCondition() will not block.
876      * If the named condition did not exist prior to the call, then it is created
877      * first.
878      */
879 
<span class="line-modified">880     public static void setCondition(String condition) {</span>
<span class="line-modified">881         BValue cond = getCond(condition);</span>
882         synchronized (cond) {
883             if (cond.v) {
884                 return;
885             }
886             cond.v = true;
887             cond.notifyAll();
888         }
889     }
890 
891     /**
892      * If the named condition does not exist, then it is created and initialized
893      * to false. If the condition exists or has just been created and its value
894      * is false, then the thread blocks until another thread sets the condition.
895      * If the condition exists and is already set to true, then this call returns
896      * immediately without blocking.
897      */
898 
<span class="line-modified">899     public static void waitForCondition(String condition) {</span>
<span class="line-modified">900         BValue cond = getCond(condition);</span>
901         synchronized (cond) {
902             if (!cond.v) {
903                 try {
904                     cond.wait();
905                 } catch (InterruptedException e) {}
906             }
907         }
908     }
909 
910     /* conditions must be locked when accessing this */
911     static HashMap rv = new HashMap();
912 
913     /**
914      * Force N threads to rendezvous (ie. wait for each other) before proceeding.
915      * The first thread(s) to call are blocked until the last
916      * thread makes the call. Then all threads continue.
917      * &lt;p&gt;
918      * All threads that call with the same condition name, must use the same value
919      * for N (or the results may be not be as expected).
920      * &lt;P&gt;
921      * Obviously, if fewer than N threads make the rendezvous then the result
922      * will be a hang.
923      */
924 
<span class="line-modified">925     public static void rendezvous(String condition, int N) {</span>
926         BValue cond;
927         IValue iv;
928         String name = &quot;RV_&quot;+condition;
929 
930         /* get the condition */
931 
932         synchronized (conditions) {
<span class="line-modified">933             cond = (BValue)conditions.get(name);</span>
934             if (cond == null) {
935                 /* we are first caller */
936                 if (N &lt; 2) {
<span class="line-modified">937                     throw new RuntimeException(&quot;rendezvous must be called with N &gt;= 2&quot;);</span>
938                 }
<span class="line-modified">939                 cond = new BValue();</span>
<span class="line-modified">940                 conditions.put(name, cond);</span>
<span class="line-modified">941                 iv = new IValue(N-1);</span>
<span class="line-modified">942                 rv.put(name, iv);</span>
943             } else {
944                 /* already initialised, just decrement the counter */
<span class="line-modified">945                 iv = (IValue) rv.get(name);</span>
<span class="line-modified">946                 iv.v--;</span>
947             }
948         }
949 
950         if (iv.v &gt; 0) {
<span class="line-modified">951             waitForCondition(name);</span>
952         } else {
<span class="line-modified">953             setCondition(name);</span>
954             synchronized (conditions) {
<span class="line-modified">955                 clearCondition(name);</span>
<span class="line-modified">956                 rv.remove(name);</span>
957             }
958         }
959     }
960 
961     /**
962      * If the named condition exists and is set then remove it, so it can
963      * be re-initialized and used again. If the condition does not exist, or
964      * exists but is not set, then the call returns without doing anything.
965      * Note, some higher level synchronization
966      * may be needed between clear and the other operations.
967      */
968 
969     public static void clearCondition(String condition) {
970         BValue cond;
971         synchronized (conditions) {
<span class="line-modified">972             cond = (BValue) conditions.get(condition);</span>
973             if (cond == null) {
974                 return;
975             }
976             synchronized (cond) {
977                 if (cond.v) {
<span class="line-modified">978                     conditions.remove(condition);</span>
979                 }
980             }
981         }
982     }
983 }
</pre>
</td>
</tr>
</table>
<center><a href="NewImpl/JavaxHostnameVerifier.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="../jar/B4957695.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
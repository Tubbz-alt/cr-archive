<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames test/jdk/sun/net/www/http/HttpURLConnection/DigestAuth.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
<a name="1" id="anc1"></a><span class="line-modified">  2  * Copyright (c) 2016, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 import com.sun.net.httpserver.HttpExchange;
 25 import com.sun.net.httpserver.HttpHandler;
 26 import com.sun.net.httpserver.HttpServer;
 27 import java.io.BufferedReader;
 28 import java.io.InputStreamReader;
 29 import java.io.IOException;
 30 import java.io.InputStream;
 31 import java.net.Authenticator;
<a name="2" id="anc2"></a><span class="line-added"> 32 import java.net.InetAddress;</span>
 33 import java.net.InetSocketAddress;
 34 import java.net.PasswordAuthentication;
 35 import java.net.URL;
 36 import java.net.URLConnection;
 37 import java.util.List;
 38 
 39 /*
 40  * @test
 41  * @bug 8138990
 42  * @summary Tests for HTTP Digest auth
 43  *          The impl maintains a cache for auth info,
 44  *          the testcases run in a separate JVM to avoid cache hits
 45  * @modules jdk.httpserver
 46  * @run main/othervm DigestAuth good
 47  * @run main/othervm DigestAuth only_nonce
 48  * @run main/othervm DigestAuth sha1
 49  * @run main/othervm DigestAuth no_header
 50  * @run main/othervm DigestAuth no_nonce
 51  * @run main/othervm DigestAuth no_qop
 52  * @run main/othervm DigestAuth invalid_alg
 53  * @run main/othervm DigestAuth validate_server
 54  * @run main/othervm DigestAuth validate_server_no_qop
 55  */
 56 public class DigestAuth {
 57 
<a name="3" id="anc3"></a>
 58     static final String EXPECT_FAILURE = null;
 59     static final String EXPECT_DIGEST = &quot;Digest&quot;;
 60     static final String REALM = &quot;testrealm@host.com&quot;;
 61     static final String NEXT_NONCE = &quot;40f2e879449675f288476d772627370a&quot;;
 62 
 63     static final String GOOD_WWW_AUTH_HEADER = &quot;Digest &quot;
 64             + &quot;realm=\&quot;testrealm@host.com\&quot;, &quot;
 65             + &quot;qop=\&quot;auth,auth-int\&quot;, &quot;
 66             + &quot;nonce=\&quot;dcd98b7102dd2f0e8b11d0f600bfb0c093\&quot;, &quot;
 67             + &quot;opaque=\&quot;5ccc069c403ebaf9f0171e9517f40e41\&quot;&quot;;
 68 
 69     static final String GOOD_WWW_AUTH_HEADER_NO_QOP = &quot;Digest &quot;
 70             + &quot;realm=\&quot;testrealm@host.com\&quot;, &quot;
 71             + &quot;nonce=\&quot;dcd98b7102dd2f0e8b11d0f600bfb0c093\&quot;, &quot;
 72             + &quot;opaque=\&quot;5ccc069c403ebaf9f0171e9517f40e41\&quot;&quot;;
 73 
 74     static final String WWW_AUTH_HEADER_NO_NONCE = &quot;Digest &quot;
 75             + &quot;realm=\&quot;testrealm@host.com\&quot;, &quot;
 76             + &quot;qop=\&quot;auth,auth-int\&quot;, &quot;
 77             + &quot;opaque=\&quot;5ccc069c403ebaf9f0171e9517f40e41\&quot;&quot;;
 78 
 79     static final String WWW_AUTH_HEADER_NO_QOP = &quot;Digest &quot;
 80             + &quot;realm=\&quot;testrealm@host.com\&quot;, &quot;
 81             + &quot;nonce=\&quot;dcd98b7102dd2f0e8b11d0f600bfb0c093\&quot;, &quot;
 82             + &quot;opaque=\&quot;5ccc069c403ebaf9f0171e9517f40e41\&quot;&quot;;
 83 
 84     static final String WWW_AUTH_HEADER_ONLY_NONCE = &quot;Digest &quot;
 85             + &quot;nonce=\&quot;dcd98b7102dd2f0e8b11d0f600bfb0c093\&quot;&quot;;
 86 
 87     static final String WWW_AUTH_HEADER_SHA1 = &quot;Digest &quot;
 88             + &quot;nonce=\&quot;dcd98b7102dd2f0e8b11d0f600bfb0c093\&quot;, &quot;
 89             + &quot;algorithm=\&quot;SHA1\&quot;&quot;;
 90 
 91     static final String WWW_AUTH_HEADER_INVALID_ALGORITHM = &quot;Digest &quot;
 92             + &quot;nonce=\&quot;dcd98b7102dd2f0e8b11d0f600bfb0c093\&quot;, &quot;
 93             + &quot;algorithm=\&quot;SHA123\&quot;&quot;;
 94 
 95     static final String AUTH_INFO_HEADER_NO_QOP_FIRST =
 96               &quot;nextnonce=\&quot;&quot; + NEXT_NONCE + &quot;\&quot;, &quot;
 97             + &quot;rspauth=\&quot;ee85bc4315d8b18757809f1a8b9382d8\&quot;&quot;;
 98 
 99     static final String AUTH_INFO_HEADER_NO_QOP_SECOND =
100               &quot;rspauth=\&quot;12f2fa12841b3775b6054576722446b2\&quot;&quot;;
101 
102     static final String AUTH_INFO_HEADER_WRONG_DIGEST =
103               &quot;nextnonce=\&quot;&quot; + NEXT_NONCE + &quot;\&quot;, &quot;
104             + &quot;rspauth=\&quot;7327570c586207eca2afae94fc20903d\&quot;, &quot;
105             + &quot;cnonce=\&quot;0a4f113b\&quot;, &quot;
106             + &quot;nc=00000001, &quot;
107             + &quot;qop=auth&quot;;
108 
109     public static void main(String[] args) throws Exception {
110         if (args.length == 0) {
111             throw new RuntimeException(&quot;No testcase specified&quot;);
112         }
113         String testcase = args[0];
114 
115         // start a local HTTP server
116         try (LocalHttpServer server = LocalHttpServer.startServer()) {
117 
118             // set authenticator
119             AuthenticatorImpl auth = new AuthenticatorImpl();
120             Authenticator.setDefault(auth);
121 
<a name="4" id="anc4"></a><span class="line-modified">122             String url = String.format(&quot;http://%s/test/&quot;, server.getAuthority());</span>

123 
124             boolean success = true;
125             switch (testcase) {
126                 case &quot;good&quot;:
127                     // server returns a good WWW-Authenticate header
128                     server.setWWWAuthHeader(GOOD_WWW_AUTH_HEADER);
129                     success = testAuth(url, auth, EXPECT_DIGEST);
130                     if (auth.lastRequestedPrompt == null ||
131                             !auth.lastRequestedPrompt.equals(REALM)) {
132                         System.out.println(&quot;Unexpected realm: &quot;
133                                 + auth.lastRequestedPrompt);
134                         success = false;
135                     }
136                     break;
137                 case &quot;validate_server&quot;:
138                     // enable processing Authentication-Info headers
139                     System.setProperty(&quot;http.auth.digest.validateServer&quot;,
140                             &quot;true&quot;);
141 
142                     /* Server returns good WWW-Authenticate
143                      * and Authentication-Info headers with wrong digest
144                      */
145                     server.setWWWAuthHeader(GOOD_WWW_AUTH_HEADER);
146                     server.setAuthInfoHeader(AUTH_INFO_HEADER_WRONG_DIGEST);
147                     success = testAuth(url, auth, EXPECT_FAILURE);
148                     if (auth.lastRequestedPrompt == null ||
149                             !auth.lastRequestedPrompt.equals(REALM)) {
150                         System.out.println(&quot;Unexpected realm: &quot;
151                                 + auth.lastRequestedPrompt);
152                         success = false;
153                     }
154                     break;
155                 case &quot;validate_server_no_qop&quot;:
156                     // enable processing Authentication-Info headers
157                     System.setProperty(&quot;http.auth.digest.validateServer&quot;,
158                             &quot;true&quot;);
159 
160                     /* Server returns good both WWW-Authenticate
161                      * and Authentication-Info headers without any qop field,
162                      * so that client-nonce should not be taked into account,
163                      * and connection should succeed.
164                      */
165                     server.setWWWAuthHeader(GOOD_WWW_AUTH_HEADER_NO_QOP);
166                     server.setAuthInfoHeader(AUTH_INFO_HEADER_NO_QOP_FIRST);
167                     success = testAuth(url, auth, EXPECT_DIGEST);
168                     if (auth.lastRequestedPrompt == null ||
169                             !auth.lastRequestedPrompt.equals(REALM)) {
170                         System.out.println(&quot;Unexpected realm: &quot;
171                                 + auth.lastRequestedPrompt);
172                         success = false;
173                     }
174 
175                     // connect again and check if nextnonce was used
176                     server.setAuthInfoHeader(AUTH_INFO_HEADER_NO_QOP_SECOND);
177                     success &amp;= testAuth(url, auth, EXPECT_DIGEST);
178                     if (!NEXT_NONCE.equals(server.lastRequestedNonce)) {
179                         System.out.println(&quot;Unexpected next nonce: &quot;
180                                 + server.lastRequestedNonce);
181                         success = false;
182                     }
183                     break;
184                 case &quot;only_nonce&quot;:
185                     /* Server returns a good WWW-Authenticate header
186                      * which contains only nonce (no realm set).
187                      *
188                      * Realm from  WWW-Authenticate header is passed to
189                      * authenticator which can use it as a prompt
190                      * when it asks a user for credentials.
191                      *
192                      * It&#39;s fine if an HTTP client doesn&#39;t fail if no realm set,
193                      * and delegates making a decision to authenticator/user.
194                      */
195                     server.setWWWAuthHeader(WWW_AUTH_HEADER_ONLY_NONCE);
196                     success = testAuth(url, auth, EXPECT_DIGEST);
197                     if (auth.lastRequestedPrompt != null &amp;&amp;
198                             !auth.lastRequestedPrompt.trim().isEmpty()) {
199                         System.out.println(&quot;Unexpected realm: &quot;
200                                 + auth.lastRequestedPrompt);
201                         success = false;
202                     }
203                     break;
204                 case &quot;sha1&quot;:
205                     // server returns a good WWW-Authenticate header with SHA-1
206                     server.setWWWAuthHeader(WWW_AUTH_HEADER_SHA1);
207                     success = testAuth(url, auth, EXPECT_DIGEST);
208                     break;
209                 case &quot;no_header&quot;:
210                     // server returns no WWW-Authenticate header
211                     success = testAuth(url, auth, EXPECT_FAILURE);
212                     if (auth.lastRequestedScheme != null) {
213                         System.out.println(&quot;Unexpected scheme: &quot;
214                                 + auth.lastRequestedScheme);
215                         success = false;
216                     }
217                     break;
218                 case &quot;no_nonce&quot;:
219                     // server returns a wrong WWW-Authenticate header (no nonce)
220                     server.setWWWAuthHeader(WWW_AUTH_HEADER_NO_NONCE);
221                     success = testAuth(url, auth, EXPECT_FAILURE);
222                     break;
223                 case &quot;invalid_alg&quot;:
224                     // server returns a wrong WWW-Authenticate header
225                     // (invalid hash algorithm)
226                     server.setWWWAuthHeader(WWW_AUTH_HEADER_INVALID_ALGORITHM);
227                     success = testAuth(url, auth, EXPECT_FAILURE);
228                     break;
229                 case &quot;no_qop&quot;:
230                     // server returns a good WWW-Authenticate header
231                     // without QOPs
232                     server.setWWWAuthHeader(WWW_AUTH_HEADER_NO_QOP);
233                     success = testAuth(url, auth, EXPECT_DIGEST);
234                     break;
235                 default:
236                     throw new RuntimeException(&quot;Unexpected testcase: &quot;
237                             + testcase);
238             }
239 
240             if (!success) {
241                 throw new RuntimeException(&quot;Test failed&quot;);
242             }
243         }
244 
245         System.out.println(&quot;Test passed&quot;);
246     }
247 
248     static boolean testAuth(String url, AuthenticatorImpl auth,
249             String expectedScheme) {
250 
251         try {
252             System.out.printf(&quot;Connect to %s, expected auth scheme is &#39;%s&#39;%n&quot;,
253                     url, expectedScheme);
254             load(url);
255 
256             if (expectedScheme == null) {
257                 System.out.println(&quot;Unexpected successful connection&quot;);
258                 return false;
259             }
260 
261             System.out.printf(&quot;Actual auth scheme is &#39;%s&#39;%n&quot;,
262                     auth.lastRequestedScheme);
263             if (!expectedScheme.equalsIgnoreCase(auth.lastRequestedScheme)) {
264                 System.out.println(&quot;Unexpected auth scheme&quot;);
265                 return false;
266             }
267         } catch (IOException e) {
268             if (expectedScheme != null) {
269                 System.out.println(&quot;Unexpected exception: &quot; + e);
270                 e.printStackTrace(System.out);
271                 return false;
272             }
273             System.out.println(&quot;Expected exception: &quot; + e);
274         }
275 
276         return true;
277     }
278 
279     static void load(String url) throws IOException {
280         URLConnection conn = new URL(url).openConnection();
281         conn.setUseCaches(false);
282         try (BufferedReader reader = new BufferedReader(
283                 new InputStreamReader(conn.getInputStream()))) {
284 
285             String line = reader.readLine();
286             if (line == null) {
287                 throw new IOException(&quot;Couldn&#39;t read response&quot;);
288             }
289             do {
290                 System.out.println(line);
291             } while ((line = reader.readLine()) != null);
292         }
293     }
294 
295     private static class AuthenticatorImpl extends Authenticator {
296 
297         private String lastRequestedScheme;
298         private String lastRequestedPrompt;
299 
300         @Override
301         public PasswordAuthentication getPasswordAuthentication() {
302             lastRequestedScheme = getRequestingScheme();
303             lastRequestedPrompt = getRequestingPrompt();
304             System.out.println(&quot;AuthenticatorImpl: requested &quot;
305                     + lastRequestedScheme);
306 
307             return new PasswordAuthentication(&quot;Mufasa&quot;,
308                     &quot;Circle Of Life&quot;.toCharArray());
309         }
310     }
311 
312     // local HTTP server which pretends to support HTTP Digest auth
313     static class LocalHttpServer implements HttpHandler, AutoCloseable {
314 
315         private final HttpServer server;
316         private volatile String wwwAuthHeader = null;
317         private volatile String authInfoHeader = null;
318         private volatile String lastRequestedNonce;
319 
320         private LocalHttpServer(HttpServer server) {
321             this.server = server;
322         }
323 
<a name="5" id="anc5"></a><span class="line-added">324         public String getAuthority() {</span>
<span class="line-added">325             InetAddress address = server.getAddress().getAddress();</span>
<span class="line-added">326             String hostaddr = address.isAnyLocalAddress()</span>
<span class="line-added">327                 ? &quot;localhost&quot; : address.getHostAddress();</span>
<span class="line-added">328             if (hostaddr.indexOf(&#39;:&#39;) &gt; -1) {</span>
<span class="line-added">329                 hostaddr = &quot;[&quot; + hostaddr + &quot;]&quot;;</span>
<span class="line-added">330             }</span>
<span class="line-added">331             return hostaddr + &quot;:&quot; + getPort();</span>
<span class="line-added">332         }</span>
<span class="line-added">333 </span>
334         void setWWWAuthHeader(String wwwAuthHeader) {
335             this.wwwAuthHeader = wwwAuthHeader;
336         }
337 
338         void setAuthInfoHeader(String authInfoHeader) {
339             this.authInfoHeader = authInfoHeader;
340         }
341 
342         static LocalHttpServer startServer() throws IOException {
<a name="6" id="anc6"></a><span class="line-added">343             InetAddress loopback = InetAddress.getLoopbackAddress();</span>
344             HttpServer httpServer = HttpServer.create(
<a name="7" id="anc7"></a><span class="line-modified">345                     new InetSocketAddress(loopback, 0), 0);</span>
346             LocalHttpServer localHttpServer = new LocalHttpServer(httpServer);
347             localHttpServer.start();
348 
349             return localHttpServer;
350         }
351 
352         void start() {
353             server.createContext(&quot;/test&quot;, this);
354             server.start();
<a name="8" id="anc8"></a><span class="line-modified">355             System.out.println(&quot;HttpServer: started on port &quot; + getAuthority());</span>
356         }
357 
358         void stop() {
359             server.stop(0);
360             System.out.println(&quot;HttpServer: stopped&quot;);
361         }
362 
363         int getPort() {
364             return server.getAddress().getPort();
365         }
366 
367         @Override
368         public void handle(HttpExchange t) throws IOException {
369             System.out.println(&quot;HttpServer: handle connection&quot;);
370 
371             // read a request
372             try (InputStream is = t.getRequestBody()) {
373                 while (is.read() &gt; 0);
374             }
375 
376             try {
377                 List&lt;String&gt; headers = t.getRequestHeaders()
378                         .get(&quot;Authorization&quot;);
379                 String header = &quot;&quot;;
380                 if (headers != null &amp;&amp; !headers.isEmpty()) {
381                     header = headers.get(0).trim().toLowerCase();
382                 }
383                 if (header.startsWith(&quot;digest&quot;)) {
384                     if (authInfoHeader != null) {
385                         t.getResponseHeaders().add(&quot;Authentication-Info&quot;,
386                                 authInfoHeader);
387                     }
388                     lastRequestedNonce = findParameter(header, &quot;nonce&quot;);
389                     byte[] output = &quot;hello&quot;.getBytes();
390                     t.sendResponseHeaders(200, output.length);
391                     t.getResponseBody().write(output);
392                     System.out.println(&quot;HttpServer: return 200&quot;);
393                 } else {
394                     if (wwwAuthHeader != null) {
395                         t.getResponseHeaders().add(
396                                 &quot;WWW-Authenticate&quot;, wwwAuthHeader);
397                     }
398                     byte[] output = &quot;forbidden&quot;.getBytes();
399                     t.sendResponseHeaders(401, output.length);
400                     t.getResponseBody().write(output);
401                     System.out.println(&quot;HttpServer: return 401&quot;);
402                 }
403             } catch (IOException e) {
404                 System.out.println(&quot;HttpServer: exception: &quot; + e);
405                 System.out.println(&quot;HttpServer: return 500&quot;);
406                 t.sendResponseHeaders(500, 0);
407             } finally {
408                 t.close();
409             }
410         }
411 
412         private static String findParameter(String header, String name) {
413             name = name.toLowerCase();
414             if (header != null) {
415                 String[] params = header.split(&quot;\\s&quot;);
416                 for (String param : params) {
417                     param = param.trim().toLowerCase();
418                     if (param.startsWith(name)) {
419                         String[] parts = param.split(&quot;=&quot;);
420                         if (parts.length &gt; 1) {
421                             return parts[1]
422                                     .replaceAll(&quot;\&quot;&quot;, &quot;&quot;).replaceAll(&quot;,&quot;, &quot;&quot;);
423                         }
424                     }
425                 }
426             }
427             return null;
428         }
429 
430         @Override
431         public void close() {
432             stop();
433         }
434     }
435 }
<a name="9" id="anc9"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="9" type="hidden" />
</body>
</html>
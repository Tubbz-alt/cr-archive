<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames test/jdk/sun/net/www/protocol/https/TestHttpsServer.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
<a name="1" id="anc1"></a><span class="line-modified">  2  * Copyright (c) 2002, 2012, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 import java.net.*;
 25 import java.io.*;
 26 import java.nio.*;
 27 import java.nio.channels.*;
 28 import sun.net.www.MessageHeader;
 29 import java.util.*;
 30 import javax.net.ssl.*;
 31 import javax.net.ssl.SSLEngineResult.*;
 32 import java.security.*;
 33 
 34 /**
 35  * This class implements a simple HTTPS server. It uses multiple threads to
 36  * handle connections in parallel, and will spin off a new thread to handle
 37  * each request. (this is easier to implement with SSLEngine)
 38  * &lt;p&gt;
 39  * It must be instantiated with a {@link HttpCallback} object to which
 40  * requests are given and must be handled.
 41  * &lt;p&gt;
 42  * Simple synchronization between the client(s) and server can be done
 43  * using the {@link #waitForCondition(String)}, {@link #setCondition(String)} and
 44  * {@link #rendezvous(String,int)} methods.
 45  *
 46  * NOTE NOTE NOTE NOTE NOTE NOTE NOTE
 47  *
 48  * If you make a change in here, please don&#39;t forget to make the
 49  * corresponding change in the J2SE equivalent.
 50  *
 51  * NOTE NOTE NOTE NOTE NOTE NOTE NOTE
 52  */
 53 
 54 public class TestHttpsServer {
 55 
 56     ServerSocketChannel schan;
 57     int threads;
 58     int cperthread;
 59     HttpCallback cb;
 60     Server[] servers;
 61 
 62     // ssl related fields
 63     static SSLContext sslCtx;
 64 
 65     /**
 66      * Create a &lt;code&gt;TestHttpsServer&lt;code&gt; instance with the specified callback object
 67      * for handling requests. One thread is created to handle requests,
 68      * and up to ten TCP connections will be handled simultaneously.
 69      * @param cb the callback object which is invoked to handle each
 70      *  incoming request
 71      */
 72 
<a name="2" id="anc2"></a><span class="line-modified"> 73     public TestHttpsServer (HttpCallback cb) throws IOException {</span>
<span class="line-modified"> 74         this (cb, 1, 10, 0);</span>
 75     }
 76 
 77     /**
 78      * Create a &lt;code&gt;TestHttpsServer&lt;code&gt; instance with the specified number of
 79      * threads and maximum number of connections per thread. This functions
 80      * the same as the 4 arg constructor, where the port argument is set to zero.
 81      * @param cb the callback object which is invoked to handle each
 82      *     incoming request
 83      * @param threads the number of threads to create to handle requests
 84      *     in parallel
 85      * @param cperthread the number of simultaneous TCP connections to
 86      *     handle per thread
 87      */
 88 
<a name="3" id="anc3"></a><span class="line-modified"> 89     public TestHttpsServer (HttpCallback cb, int threads, int cperthread)</span>
 90         throws IOException {
<a name="4" id="anc4"></a><span class="line-modified"> 91         this (cb, threads, cperthread, 0);</span>
 92     }
 93 
 94     /**
 95      * Create a &lt;code&gt;TestHttpsServer&lt;code&gt; instance with the specified number
 96      * of threads and maximum number of connections per thread and running on
 97      * the specified port. The specified number of threads are created to
 98      * handle incoming requests, and each thread is allowed
 99      * to handle a number of simultaneous TCP connections.
100      * @param cb the callback object which is invoked to handle
101      *  each incoming request
102      * @param threads the number of threads to create to handle
103      *  requests in parallel
104      * @param cperthread the number of simultaneous TCP connections
105      *  to handle per thread
106      * @param port the port number to bind the server to. &lt;code&gt;Zero&lt;/code&gt;
107      *  means choose any free port.
108      */
<a name="5" id="anc5"></a>



109 
<a name="6" id="anc6"></a><span class="line-modified">110     public TestHttpsServer (HttpCallback cb, int threads, int cperthread, int port)</span>


















111         throws IOException {
<a name="7" id="anc7"></a><span class="line-modified">112         schan = ServerSocketChannel.open ();</span>
<span class="line-modified">113         InetSocketAddress addr = new InetSocketAddress (port);</span>
<span class="line-modified">114         schan.socket().bind (addr);</span>
115         this.threads = threads;
116         this.cb = cb;
117         this.cperthread = cperthread;
118 
119         try {
120             // create and initialize a SSLContext
121             KeyStore ks = KeyStore.getInstance(&quot;JKS&quot;);
122             KeyStore ts = KeyStore.getInstance(&quot;JKS&quot;);
123             char[] passphrase = &quot;passphrase&quot;.toCharArray();
124 
125             ks.load(new FileInputStream(System.getProperty(&quot;javax.net.ssl.keyStore&quot;)), passphrase);
126             ts.load(new FileInputStream(System.getProperty(&quot;javax.net.ssl.trustStore&quot;)), passphrase);
127 
128             KeyManagerFactory kmf = KeyManagerFactory.getInstance(&quot;SunX509&quot;);
129             kmf.init(ks, passphrase);
130 
131             TrustManagerFactory tmf = TrustManagerFactory.getInstance(&quot;SunX509&quot;);
132             tmf.init(ts);
133 
134             sslCtx = SSLContext.getInstance(&quot;TLS&quot;);
135 
136             sslCtx.init(kmf.getKeyManagers(), tmf.getTrustManagers(), null);
137 
<a name="8" id="anc8"></a><span class="line-modified">138             servers = new Server [threads];</span>
139             for (int i=0; i&lt;threads; i++) {
<a name="9" id="anc9"></a><span class="line-modified">140                 servers[i] = new Server (cb, schan, cperthread);</span>
141                 servers[i].start();
142             }
143         } catch (Exception ex) {
144             throw new RuntimeException(&quot;test failed. cause: &quot;+ex.getMessage());
145         }
146     }
147 
148     /** Tell all threads in the server to exit within 5 seconds.
149      *  This is an abortive termination. Just prior to the thread exiting
150      *  all channels in that thread waiting to be closed are forceably closed.
151      */
152 
<a name="10" id="anc10"></a><span class="line-modified">153     public void terminate () {</span>
154         for (int i=0; i&lt;threads; i++) {
155             servers[i].terminate ();
156         }
157     }
158 
159     /**
160      * return the local port number to which the server is bound.
161      * @return the local port number
162      */
163 
164     public int getLocalPort () {
165         return schan.socket().getLocalPort ();
166     }
167 
<a name="11" id="anc11"></a>







168     static class Server extends Thread {
169 
170         ServerSocketChannel schan;
171         Selector selector;
172         SelectionKey listenerKey;
173         SelectionKey key; /* the current key being processed */
174         HttpCallback cb;
175         ByteBuffer consumeBuffer;
176         int maxconn;
177         int nconn;
178         ClosedChannelList clist;
179         boolean shutdown;
180 
<a name="12" id="anc12"></a><span class="line-modified">181         Server (HttpCallback cb, ServerSocketChannel schan, int maxconn) {</span>
182             this.schan = schan;
183             this.maxconn = maxconn;
184             this.cb = cb;
185             nconn = 0;
<a name="13" id="anc13"></a><span class="line-modified">186             consumeBuffer = ByteBuffer.allocate (512);</span>
<span class="line-modified">187             clist = new ClosedChannelList ();</span>
188             try {
<a name="14" id="anc14"></a><span class="line-modified">189                 selector = Selector.open ();</span>
<span class="line-modified">190                 schan.configureBlocking (false);</span>
<span class="line-modified">191                 listenerKey = schan.register (selector, SelectionKey.OP_ACCEPT);</span>
192             } catch (IOException e) {
<a name="15" id="anc15"></a><span class="line-modified">193                 System.err.println (&quot;Server could not start: &quot; + e);</span>
194             }
195         }
196 
197         /* Stop the thread as soon as possible */
<a name="16" id="anc16"></a><span class="line-modified">198         public synchronized void terminate () {</span>
199             shutdown = true;
200         }
201 
<a name="17" id="anc17"></a><span class="line-modified">202         public void run ()  {</span>
203             try {
204                 while (true) {
<a name="18" id="anc18"></a><span class="line-modified">205                     selector.select (1000);</span>
206                     Set selected = selector.selectedKeys();
207                     Iterator iter = selected.iterator();
208                     while (iter.hasNext()) {
209                         key = (SelectionKey)iter.next();
210                         if (key.equals (listenerKey)) {
<a name="19" id="anc19"></a><span class="line-modified">211                             SocketChannel sock = schan.accept ();</span>
212                             if (sock == null) {
213                                 /* false notification */
214                                 iter.remove();
215                                 continue;
216                             }
<a name="20" id="anc20"></a><span class="line-modified">217                             sock.configureBlocking (true);</span>
218                             SSLEngine sslEng = sslCtx.createSSLEngine();
219                             sslEng.setUseClientMode(false);
220                             new ServerWorker(cb, sock, sslEng).start();
221                             nconn ++;
222                             if (nconn == maxconn) {
223                                 /* deregister */
<a name="21" id="anc21"></a><span class="line-modified">224                                 listenerKey.cancel ();</span>
225                                 listenerKey = null;
226                             }
227                         } else {
228                             if (key.isReadable()) {
229                                 boolean closed = false;
<a name="22" id="anc22"></a><span class="line-modified">230                                 SocketChannel chan = (SocketChannel) key.channel();</span>
231                                 if (key.attachment() != null) {
<a name="23" id="anc23"></a><span class="line-modified">232                                     closed = consume (chan);</span>
233                                 }
234 
235                                 if (closed) {
<a name="24" id="anc24"></a><span class="line-modified">236                                     chan.close ();</span>
<span class="line-modified">237                                     key.cancel ();</span>
238                                     if (nconn == maxconn) {
<a name="25" id="anc25"></a><span class="line-modified">239                                         listenerKey = schan.register (selector, SelectionKey.OP_ACCEPT);</span>
240                                     }
241                                     nconn --;
242                                 }
243                             }
244                         }
245                         iter.remove();
246                     }
247                     clist.check();
248 
249                     synchronized (this) {
250                         if (shutdown) {
<a name="26" id="anc26"></a><span class="line-modified">251                             clist.terminate ();</span>
252                             return;
253                         }
254                     }
255                 }
256             } catch (IOException e) {
<a name="27" id="anc27"></a><span class="line-modified">257                 System.out.println (&quot;Server exception: &quot; + e);</span>
258                 // TODO finish
259             }
260         }
261 
262         /* read all the data off the channel without looking at it
<a name="28" id="anc28"></a><span class="line-modified">263              * return true if connection closed</span>
<span class="line-modified">264              */</span>
<span class="line-modified">265         boolean consume (SocketChannel chan) {</span>
266             try {
<a name="29" id="anc29"></a><span class="line-modified">267                 consumeBuffer.clear ();</span>
<span class="line-modified">268                 int c = chan.read (consumeBuffer);</span>
269                 if (c == -1)
270                     return true;
271             } catch (IOException e) {
272                 return true;
273             }
274             return false;
275         }
276     }
277 
278     static class ServerWorker extends Thread {
279         private ByteBuffer inNetBB;
280         private ByteBuffer outNetBB;
281         private ByteBuffer inAppBB;
282         private ByteBuffer outAppBB;
283 
284         SSLEngine sslEng;
285         SocketChannel schan;
286         HttpCallback cb;
287         HandshakeStatus currentHSStatus;
288         boolean initialHSComplete;
<a name="30" id="anc30"></a>
289         /*
290          * All inbound data goes through this buffer.
291          *
292          * It might be nice to use a cache of ByteBuffers so we&#39;re
293          * not alloc/dealloc&#39;ing all over the place.
294          */
295 
296         /*
297          * Application buffers, also used for handshaking
298          */
299         private int appBBSize;
300 
<a name="31" id="anc31"></a><span class="line-modified">301         ServerWorker (HttpCallback cb, SocketChannel schan, SSLEngine sslEng) {</span>
302             this.sslEng = sslEng;
303             this.schan = schan;
304             this.cb = cb;
305             currentHSStatus = HandshakeStatus.NEED_UNWRAP;
306             initialHSComplete = false;
307             int netBBSize = sslEng.getSession().getPacketBufferSize();
308             inNetBB =  ByteBuffer.allocate(netBBSize);
309             outNetBB = ByteBuffer.allocate(netBBSize);
310             appBBSize = sslEng.getSession().getApplicationBufferSize();
311             inAppBB = ByteBuffer.allocate(appBBSize);
312             outAppBB = ByteBuffer.allocate(appBBSize);
313         }
314 
315         public SSLEngine getSSLEngine() {
316             return sslEng;
317         }
318 
319         public ByteBuffer outNetBB() {
320             return outNetBB;
321         }
322 
323         public ByteBuffer outAppBB() {
324             return outAppBB;
325         }
326 
327         public void run () {
328             try {
329                 SSLEngineResult result;
330 
331                 while (!initialHSComplete) {
332 
333                     switch (currentHSStatus) {
334 
335                     case NEED_UNWRAP:
336                         int bytes = schan.read(inNetBB);
<a name="32" id="anc32"></a>


















337 
338 needIO:
339                         while (currentHSStatus == HandshakeStatus.NEED_UNWRAP) {
340                             /*
341                              * Don&#39;t need to resize requestBB, since no app data should
342                              * be generated here.
343                              */
344                             inNetBB.flip();
345                             result = sslEng.unwrap(inNetBB, inAppBB);
346                             inNetBB.compact();
347                             currentHSStatus = result.getHandshakeStatus();
348 
349                             switch (result.getStatus()) {
350 
351                             case OK:
352                                 switch (currentHSStatus) {
353                                 case NOT_HANDSHAKING:
354                                     throw new IOException(
355                                                           &quot;Not handshaking during initial handshake&quot;);
356 
357                                 case NEED_TASK:
358                                     Runnable task;
359                                     while ((task = sslEng.getDelegatedTask()) != null) {
360                                         task.run();
361                                         currentHSStatus = sslEng.getHandshakeStatus();
362                                     }
363                                     break;
364                                 }
365 
366                                 break;
367 
368                             case BUFFER_UNDERFLOW:
369                                 break needIO;
370 
371                             default: // BUFFER_OVERFLOW/CLOSED:
372                                 throw new IOException(&quot;Received&quot; + result.getStatus() +
373                                                       &quot;during initial handshaking&quot;);
374                             }
375                         }
376 
377                         /*
378                          * Just transitioned from read to write.
379                          */
380                         if (currentHSStatus != HandshakeStatus.NEED_WRAP) {
381                             break;
382                         }
383 
384                         // Fall through and fill the write buffer.
385 
386                     case NEED_WRAP:
387                         /*
388                          * The flush above guarantees the out buffer to be empty
389                          */
390                         outNetBB.clear();
391                         result = sslEng.wrap(inAppBB, outNetBB);
392                         outNetBB.flip();
393                         schan.write (outNetBB);
394                         outNetBB.compact();
395                         currentHSStatus = result.getHandshakeStatus();
396 
397                         switch (result.getStatus()) {
398                         case OK:
399 
400                             if (currentHSStatus == HandshakeStatus.NEED_TASK) {
401                                 Runnable task;
402                                 while ((task = sslEng.getDelegatedTask()) != null) {
403                                     task.run();
404                                     currentHSStatus = sslEng.getHandshakeStatus();
405                                 }
406                             }
407 
408                             break;
409 
410                         default: // BUFFER_OVERFLOW/BUFFER_UNDERFLOW/CLOSED:
411                             throw new IOException(&quot;Received&quot; + result.getStatus() +
412                                                   &quot;during initial handshaking&quot;);
413                         }
414                         break;
415 
416                     case FINISHED:
417                         initialHSComplete = true;
418                         break;
419                     default: // NOT_HANDSHAKING/NEED_TASK
420                         throw new RuntimeException(&quot;Invalid Handshaking State&quot; +
421                                                    currentHSStatus);
422                     } // switch
423                 }
424                 // read the application data; using non-blocking mode
425                 schan.configureBlocking(false);
426                 read(schan, sslEng);
427             } catch (Exception ex) {
428                 throw new RuntimeException(ex);
429             }
430         }
431 
432         /* return true if the connection is closed, false otherwise */
433 
<a name="33" id="anc33"></a><span class="line-modified">434         private boolean read (SocketChannel chan, SSLEngine sslEng) {</span>
435             HttpTransaction msg;
436             boolean res;
437             try {
<a name="34" id="anc34"></a><span class="line-modified">438                 InputStream is = new BufferedInputStream (new NioInputStream (chan, sslEng, inNetBB, inAppBB));</span>
<span class="line-modified">439                 String requestline = readLine (is);</span>
<span class="line-modified">440                 MessageHeader mhead = new MessageHeader (is);</span>
<span class="line-modified">441                 String clen = mhead.findValue (&quot;Content-Length&quot;);</span>
<span class="line-modified">442                 String trferenc = mhead.findValue (&quot;Transfer-Encoding&quot;);</span>
443                 String data = null;
<a name="35" id="anc35"></a><span class="line-modified">444                 if (trferenc != null &amp;&amp; trferenc.equals (&quot;chunked&quot;))</span>
<span class="line-modified">445                     data = new String (readChunkedData (is));</span>
446                 else if (clen != null)
<a name="36" id="anc36"></a><span class="line-modified">447                     data = new String (readNormalData (is, Integer.parseInt (clen)));</span>
<span class="line-modified">448                 String[] req = requestline.split (&quot; &quot;);</span>
449                 if (req.length &lt; 2) {
450                     /* invalid request line */
451                     return false;
452                 }
453                 String cmd = req[0];
454                 URI uri = null;
455                 try {
<a name="37" id="anc37"></a><span class="line-modified">456                     uri = new URI (req[1]);</span>
<span class="line-modified">457                     msg = new HttpTransaction (this, cmd, uri, mhead, data, null, chan);</span>
<span class="line-modified">458                     cb.request (msg);</span>
459                 } catch (URISyntaxException e) {
460                     System.err.println (&quot;Invalid URI: &quot; + e);
<a name="38" id="anc38"></a><span class="line-modified">461                     msg = new HttpTransaction (this, cmd, null, null, null, null, chan);</span>
<span class="line-modified">462                     msg.sendResponse (501, &quot;Whatever&quot;);</span>
463                 }
464                 res = false;
465             } catch (IOException e) {
466                 res = true;
467             }
468             return res;
469         }
470 
<a name="39" id="anc39"></a><span class="line-modified">471         byte[] readNormalData (InputStream is, int len) throws IOException {</span>
<span class="line-modified">472             byte [] buf  = new byte [len];</span>
473             int c, off=0, remain=len;
474             while (remain &gt; 0 &amp;&amp; ((c=is.read (buf, off, remain))&gt;0)) {
475                 remain -= c;
476                 off += c;
477             }
478             return buf;
479         }
480 
481         private void readCRLF(InputStream is) throws IOException {
482             int cr = is.read();
483             int lf = is.read();
484 
485             if (((cr &amp; 0xff) != 0x0d) ||
486                 ((lf &amp; 0xff) != 0x0a)) {
487                 throw new IOException(
488                     &quot;Expected &lt;CR&gt;&lt;LF&gt;:  got &#39;&quot; + cr + &quot;/&quot; + lf + &quot;&#39;&quot;);
489             }
490         }
491 
<a name="40" id="anc40"></a><span class="line-modified">492         byte[] readChunkedData (InputStream is) throws IOException {</span>
<span class="line-modified">493             LinkedList l = new LinkedList ();</span>
494             int total = 0;
495             for (int len=readChunkLen(is); len!=0; len=readChunkLen(is)) {
<a name="41" id="anc41"></a><span class="line-modified">496                 l.add (readNormalData(is, len));</span>
497                 total += len;
498                 readCRLF(is); // CRLF at end of chunk
499             }
500             readCRLF(is); // CRLF at end of Chunked Stream.
<a name="42" id="anc42"></a><span class="line-modified">501             byte[] buf = new byte [total];</span>
502             Iterator i = l.iterator();
503             int x = 0;
504             while (i.hasNext()) {
505                 byte[] b = (byte[])i.next();
<a name="43" id="anc43"></a><span class="line-modified">506                 System.arraycopy (b, 0, buf, x, b.length);</span>
507                 x += b.length;
508             }
509             return buf;
510         }
511 
<a name="44" id="anc44"></a><span class="line-modified">512         private int readChunkLen (InputStream is) throws IOException {</span>
513             int c, len=0;
514             boolean done=false, readCR=false;
515             while (!done) {
<a name="45" id="anc45"></a><span class="line-modified">516                 c = is.read ();</span>
517                 if (c == &#39;\n&#39; &amp;&amp; readCR) {
518                     done = true;
519                 } else {
520                     if (c == &#39;\r&#39; &amp;&amp; !readCR) {
521                         readCR = true;
522                     } else {
523                         int x=0;
524                         if (c &gt;= &#39;a&#39; &amp;&amp; c &lt;= &#39;f&#39;) {
525                             x = c - &#39;a&#39; + 10;
526                         } else if (c &gt;= &#39;A&#39; &amp;&amp; c &lt;= &#39;F&#39;) {
527                             x = c - &#39;A&#39; + 10;
528                         } else if (c &gt;= &#39;0&#39; &amp;&amp; c &lt;= &#39;9&#39;) {
529                             x = c - &#39;0&#39;;
530                         }
531                         len = len * 16 + x;
532                     }
533                 }
534             }
535             return len;
536         }
537 
<a name="46" id="anc46"></a><span class="line-modified">538         private String readLine (InputStream is) throws IOException {</span>
539             boolean done=false, readCR=false;
<a name="47" id="anc47"></a><span class="line-modified">540             byte[] b = new byte [512];</span>
541             int c, l = 0;
542 
543             while (!done) {
<a name="48" id="anc48"></a><span class="line-modified">544                 c = is.read ();</span>
545                 if (c == &#39;\n&#39; &amp;&amp; readCR) {
546                     done = true;
547                 } else {
548                     if (c == &#39;\r&#39; &amp;&amp; !readCR) {
549                         readCR = true;
550                     } else {
551                         b[l++] = (byte)c;
552                     }
553                 }
554             }
<a name="49" id="anc49"></a><span class="line-modified">555             return new String (b);</span>
556         }
557 
558         /** close the channel associated with the current key by:
559          * 1. shutdownOutput (send a FIN)
560          * 2. mark the key so that incoming data is to be consumed and discarded
561          * 3. After a period, close the socket
562          */
563 
<a name="50" id="anc50"></a><span class="line-modified">564         synchronized void orderlyCloseChannel (SocketChannel ch) throws IOException {</span>
565             ch.socket().shutdownOutput();
566         }
567 
<a name="51" id="anc51"></a><span class="line-modified">568         synchronized void abortiveCloseChannel (SocketChannel ch) throws IOException {</span>
<span class="line-modified">569             Socket s = ch.socket ();</span>
<span class="line-modified">570             s.setSoLinger (true, 0);</span>
571             ch.close();
572         }
573     }
574 
575 
576     /**
577      * Implements blocking reading semantics on top of a non-blocking channel
578      */
579 
580     static class NioInputStream extends InputStream {
581         SSLEngine sslEng;
582         SocketChannel channel;
583         Selector selector;
584         ByteBuffer inNetBB;
585         ByteBuffer inAppBB;
586         SelectionKey key;
587         int available;
588         byte[] one;
589         boolean closed;
590         ByteBuffer markBuf; /* reads may be satisifed from this buffer */
591         boolean marked;
592         boolean reset;
593         int readlimit;
594 
<a name="52" id="anc52"></a><span class="line-modified">595         public NioInputStream (SocketChannel chan, SSLEngine sslEng, ByteBuffer inNetBB, ByteBuffer inAppBB) throws IOException {</span>
596             this.sslEng = sslEng;
597             this.channel = chan;
598             selector = Selector.open();
599             this.inNetBB = inNetBB;
600             this.inAppBB = inAppBB;
<a name="53" id="anc53"></a><span class="line-modified">601             key = chan.register (selector, SelectionKey.OP_READ);</span>
602             available = 0;
603             one = new byte[1];
604             closed = marked = reset = false;
605         }
606 
<a name="54" id="anc54"></a><span class="line-modified">607         public synchronized int read (byte[] b) throws IOException {</span>
<span class="line-modified">608             return read (b, 0, b.length);</span>
609         }
610 
<a name="55" id="anc55"></a><span class="line-modified">611         public synchronized int read () throws IOException {</span>
<span class="line-modified">612             return read (one, 0, 1);</span>
613         }
614 
<a name="56" id="anc56"></a><span class="line-modified">615         public synchronized int read (byte[] b, int off, int srclen) throws IOException {</span>
616 
617             int canreturn, willreturn;
618 
619             if (closed)
620                 return -1;
621 
622             if (reset) { /* satisfy from markBuf */
<a name="57" id="anc57"></a><span class="line-modified">623                 canreturn = markBuf.remaining ();</span>
<span class="line-modified">624                 willreturn = canreturn&gt;srclen ? srclen : canreturn;</span>
625                 markBuf.get(b, off, willreturn);
626                 if (canreturn == willreturn) {
627                     reset = false;
628                 }
629             } else { /* satisfy from channel */
630                 canreturn = available();
631                 if (canreturn == 0) {
<a name="58" id="anc58"></a><span class="line-modified">632                     block ();</span>
633                     canreturn = available();
634                 }
<a name="59" id="anc59"></a><span class="line-modified">635                 willreturn = canreturn&gt;srclen ? srclen : canreturn;</span>
636                 inAppBB.get(b, off, willreturn);
637                 available -= willreturn;
638 
639                 if (marked) { /* copy into markBuf */
640                     try {
<a name="60" id="anc60"></a><span class="line-modified">641                         markBuf.put (b, off, willreturn);</span>
642                     } catch (BufferOverflowException e) {
643                         marked = false;
644                     }
645                 }
646             }
647             return willreturn;
648         }
649 
<a name="61" id="anc61"></a><span class="line-modified">650         public synchronized int available () throws IOException {</span>
651             if (closed)
<a name="62" id="anc62"></a><span class="line-modified">652                 throw new IOException (&quot;Stream is closed&quot;);</span>
653 
654             if (reset)
655                 return markBuf.remaining();
656 
657             if (available &gt; 0)
658                 return available;
659 
<a name="63" id="anc63"></a><span class="line-modified">660             inAppBB.clear ();</span>
<span class="line-modified">661             int bytes = channel.read (inNetBB);</span>
662 
663             int needed = sslEng.getSession().getApplicationBufferSize();
664             if (needed &gt; inAppBB.remaining()) {
665                 inAppBB = ByteBuffer.allocate(needed);
666             }
667             inNetBB.flip();
668             SSLEngineResult result = sslEng.unwrap(inNetBB, inAppBB);
669             inNetBB.compact();
670             available = result.bytesProduced();
671 
672             if (available &gt; 0)
673                 inAppBB.flip();
674             else if (available == -1)
<a name="64" id="anc64"></a><span class="line-modified">675                 throw new IOException (&quot;Stream is closed&quot;);</span>
676             return available;
677         }
678 
679         /**
680          * block() only called when available==0 and buf is empty
681          */
<a name="65" id="anc65"></a><span class="line-modified">682         private synchronized void block () throws IOException {</span>
683             //assert available == 0;
<a name="66" id="anc66"></a><span class="line-modified">684             int n = selector.select ();</span>
685             //assert n == 1;
686             selector.selectedKeys().clear();
<a name="67" id="anc67"></a><span class="line-modified">687             available ();</span>
688         }
689 
<a name="68" id="anc68"></a><span class="line-modified">690         public void close () throws IOException {</span>
691             if (closed)
692                 return;
<a name="69" id="anc69"></a><span class="line-modified">693             channel.close ();</span>
694             closed = true;
695         }
696 
<a name="70" id="anc70"></a><span class="line-modified">697         public synchronized void mark (int readlimit) {</span>
698             if (closed)
699                 return;
700             this.readlimit = readlimit;
<a name="71" id="anc71"></a><span class="line-modified">701             markBuf = ByteBuffer.allocate (readlimit);</span>
702             marked = true;
703             reset = false;
704         }
705 
<a name="72" id="anc72"></a><span class="line-modified">706         public synchronized void reset () throws IOException {</span>
707             if (closed )
708                 return;
709             if (!marked)
<a name="73" id="anc73"></a><span class="line-modified">710                 throw new IOException (&quot;Stream not marked&quot;);</span>
711             marked = false;
712             reset = true;
<a name="74" id="anc74"></a><span class="line-modified">713             markBuf.flip ();</span>
714         }
715     }
716 
717     static class NioOutputStream extends OutputStream {
718         SSLEngine sslEng;
719         SocketChannel channel;
720         ByteBuffer outNetBB;
721         ByteBuffer outAppBB;
722         SelectionKey key;
723         Selector selector;
724         boolean closed;
725         byte[] one;
726 
<a name="75" id="anc75"></a><span class="line-modified">727         public NioOutputStream (SocketChannel channel, SSLEngine sslEng, ByteBuffer outNetBB, ByteBuffer outAppBB) throws IOException {</span>
728             this.sslEng = sslEng;
729             this.channel = channel;
730             this.outNetBB = outNetBB;
731             this.outAppBB = outAppBB;
<a name="76" id="anc76"></a><span class="line-modified">732             selector = Selector.open ();</span>
<span class="line-modified">733             key = channel.register (selector, SelectionKey.OP_WRITE);</span>
734             closed = false;
<a name="77" id="anc77"></a><span class="line-modified">735             one = new byte [1];</span>
736         }
737 
<a name="78" id="anc78"></a><span class="line-modified">738         public synchronized void write (int b) throws IOException {</span>
739             one[0] = (byte)b;
<a name="79" id="anc79"></a><span class="line-modified">740             write (one, 0, 1);</span>
741         }
742 
<a name="80" id="anc80"></a><span class="line-modified">743         public synchronized void write (byte[] b) throws IOException {</span>
<span class="line-modified">744             write (b, 0, b.length);</span>
745         }
746 
<a name="81" id="anc81"></a><span class="line-modified">747         public synchronized void write (byte[] b, int off, int len) throws IOException {</span>
748             if (closed)
<a name="82" id="anc82"></a><span class="line-modified">749                 throw new IOException (&quot;stream is closed&quot;);</span>
750 
<a name="83" id="anc83"></a><span class="line-modified">751             outAppBB = ByteBuffer.allocate (len);</span>
<span class="line-modified">752             outAppBB.put (b, off, len);</span>
<span class="line-modified">753             outAppBB.flip ();</span>
754             int n;
755             outNetBB.clear();
756             int needed = sslEng.getSession().getPacketBufferSize();
757             if (outNetBB.capacity() &lt; needed) {
758                 outNetBB = ByteBuffer.allocate(needed);
759             }
760             SSLEngineResult ret = sslEng.wrap(outAppBB, outNetBB);
761             outNetBB.flip();
762             int newLen = ret.bytesProduced();
763             while ((n = channel.write (outNetBB)) &lt; newLen) {
764                 newLen -= n;
765                 if (newLen == 0)
766                     return;
<a name="84" id="anc84"></a><span class="line-modified">767                 selector.select ();</span>
<span class="line-modified">768                 selector.selectedKeys().clear ();</span>
769             }
770         }
771 
<a name="85" id="anc85"></a><span class="line-modified">772         public void close () throws IOException {</span>
773             if (closed)
774                 return;
<a name="86" id="anc86"></a><span class="line-modified">775             channel.close ();</span>
776             closed = true;
777         }
778     }
779 
780     /**
781      * Utilities for synchronization. A condition is
782      * identified by a string name, and is initialized
783      * upon first use (ie. setCondition() or waitForCondition()). Threads
784      * are blocked until some thread calls (or has called) setCondition() for the same
785      * condition.
786      * &lt;P&gt;
787      * A rendezvous built on a condition is also provided for synchronizing
788      * N threads.
789      */
790 
791     private static HashMap conditions = new HashMap();
792 
793     /*
794      * Modifiable boolean object
795      */
796     private static class BValue {
797         boolean v;
798     }
799 
800     /*
801      * Modifiable int object
802      */
803     private static class IValue {
804         int v;
<a name="87" id="anc87"></a><span class="line-modified">805         IValue (int i) {</span>
806             v =i;
807         }
808     }
809 
810 
<a name="88" id="anc88"></a><span class="line-modified">811     private static BValue getCond (String condition) {</span>
812         synchronized (conditions) {
<a name="89" id="anc89"></a><span class="line-modified">813             BValue cond = (BValue) conditions.get (condition);</span>
814             if (cond == null) {
815                 cond = new BValue();
<a name="90" id="anc90"></a><span class="line-modified">816                 conditions.put (condition, cond);</span>
817             }
818             return cond;
819         }
820     }
821 
822     /**
823      * Set the condition to true. Any threads that are currently blocked
824      * waiting on the condition, will be unblocked and allowed to continue.
825      * Threads that subsequently call waitForCondition() will not block.
826      * If the named condition did not exist prior to the call, then it is created
827      * first.
828      */
829 
<a name="91" id="anc91"></a><span class="line-modified">830     public static void setCondition (String condition) {</span>
<span class="line-modified">831         BValue cond = getCond (condition);</span>
832         synchronized (cond) {
833             if (cond.v) {
834                 return;
835             }
836             cond.v = true;
837             cond.notifyAll();
838         }
839     }
840 
841     /**
842      * If the named condition does not exist, then it is created and initialized
843      * to false. If the condition exists or has just been created and its value
844      * is false, then the thread blocks until another thread sets the condition.
845      * If the condition exists and is already set to true, then this call returns
846      * immediately without blocking.
847      */
848 
<a name="92" id="anc92"></a><span class="line-modified">849     public static void waitForCondition (String condition) {</span>
<span class="line-modified">850         BValue cond = getCond (condition);</span>
851         synchronized (cond) {
852             if (!cond.v) {
853                 try {
854                     cond.wait();
855                 } catch (InterruptedException e) {}
856             }
857         }
858     }
859 
860     /* conditions must be locked when accessing this */
861     static HashMap rv = new HashMap();
862 
863     /**
864      * Force N threads to rendezvous (ie. wait for each other) before proceeding.
865      * The first thread(s) to call are blocked until the last
866      * thread makes the call. Then all threads continue.
867      * &lt;p&gt;
868      * All threads that call with the same condition name, must use the same value
869      * for N (or the results may be not be as expected).
870      * &lt;P&gt;
871      * Obviously, if fewer than N threads make the rendezvous then the result
872      * will be a hang.
873      */
874 
<a name="93" id="anc93"></a><span class="line-modified">875     public static void rendezvous (String condition, int N) {</span>
876         BValue cond;
877         IValue iv;
878         String name = &quot;RV_&quot;+condition;
879 
880         /* get the condition */
881 
882         synchronized (conditions) {
<a name="94" id="anc94"></a><span class="line-modified">883             cond = (BValue)conditions.get (name);</span>
884             if (cond == null) {
885                 /* we are first caller */
886                 if (N &lt; 2) {
<a name="95" id="anc95"></a><span class="line-modified">887                     throw new RuntimeException (&quot;rendezvous must be called with N &gt;= 2&quot;);</span>
888                 }
<a name="96" id="anc96"></a><span class="line-modified">889                 cond = new BValue ();</span>
<span class="line-modified">890                 conditions.put (name, cond);</span>
<span class="line-modified">891                 iv = new IValue (N-1);</span>
<span class="line-modified">892                 rv.put (name, iv);</span>
893             } else {
894                 /* already initialised, just decrement the counter */
<a name="97" id="anc97"></a><span class="line-modified">895                 iv = (IValue) rv.get (name);</span>
<span class="line-modified">896                 iv.v --;</span>
897             }
898         }
899 
900         if (iv.v &gt; 0) {
<a name="98" id="anc98"></a><span class="line-modified">901             waitForCondition (name);</span>
902         } else {
<a name="99" id="anc99"></a><span class="line-modified">903             setCondition (name);</span>
904             synchronized (conditions) {
<a name="100" id="anc100"></a><span class="line-modified">905                 clearCondition (name);</span>
<span class="line-modified">906                 rv.remove (name);</span>
907             }
908         }
909     }
910 
911     /**
912      * If the named condition exists and is set then remove it, so it can
913      * be re-initialized and used again. If the condition does not exist, or
914      * exists but is not set, then the call returns without doing anything.
915      * Note, some higher level synchronization
916      * may be needed between clear and the other operations.
917      */
918 
919     public static void clearCondition(String condition) {
920         BValue cond;
921         synchronized (conditions) {
<a name="101" id="anc101"></a><span class="line-modified">922             cond = (BValue) conditions.get (condition);</span>
923             if (cond == null) {
924                 return;
925             }
926             synchronized (cond) {
927                 if (cond.v) {
<a name="102" id="anc102"></a><span class="line-modified">928                     conditions.remove (condition);</span>
929                 }
930             }
931         }
932     }
933 }
<a name="103" id="anc103"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="103" type="hidden" />
</body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff test/jdk/sun/net/www/protocol/https/HttpsURLConnection/RetryHttps.java</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="Redirect.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="TunnelProxy.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>test/jdk/sun/net/www/protocol/https/HttpsURLConnection/RetryHttps.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2003, 2015, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 /* @test
 25  * @bug 4799427
 26  * @summary Https can not retry request

 27  * @run main/othervm RetryHttps

 28  *
 29  *     SunJSSE does not support dynamic system properties, no way to re-use
 30  *     system properties in samevm/agentvm mode.
 31  * @author Yingxian Wang
 32  */
 33 
 34 import java.net.*;
 35 import java.util.*;
 36 import java.io.*;
 37 import javax.net.ssl.*;

 38 
 39 public class RetryHttps {
 40     static Map cookies;
 41     ServerSocket ss;
 42 
 43     /*
 44      * =============================================================
 45      * Set the various variables needed for the tests, then
 46      * specify what tests to run on each side.
 47      */
 48 
 49     /*
 50      * Should we run the client or server in a separate thread?
 51      * Both sides can throw exceptions, but do you have a preference
 52      * as to which side should be the main thread.
 53      */
 54     static boolean separateServerThread = true;
 55 
 56     /*
 57      * Where do we find the keystores?
</pre>
<hr />
<pre>
 63 
 64     /*
 65      * Is the server ready to serve?
 66      */
 67     volatile static boolean serverReady = false;
 68 
 69     /*
 70      * Turn on SSL debugging?
 71      */
 72     static boolean debug = true;
 73 
 74     private SSLServerSocket sslServerSocket = null;
 75 
 76     /*
 77      * Define the server side of the test.
 78      *
 79      * If the server prematurely exits, serverReady will be set to true
 80      * to avoid infinite hangs.
 81      */
 82     void doServerSide() throws Exception {

 83         SSLServerSocketFactory sslssf =
 84             (SSLServerSocketFactory) SSLServerSocketFactory.getDefault();
 85         sslServerSocket =
<span class="line-modified"> 86             (SSLServerSocket) sslssf.createServerSocket(serverPort);</span>
 87         serverPort = sslServerSocket.getLocalPort();
 88 




 89         /*
 90          * Signal Client, we&#39;re ready for his connect.
 91          */
 92         serverReady = true;
 93         SSLSocket sslSocket = null;
 94         try {
 95             for (int i = 0; i &lt; 2; i++) {
 96             sslSocket = (SSLSocket) sslServerSocket.accept();
 97             // read request
 98             InputStream is = sslSocket.getInputStream ();
 99             BufferedReader r = new BufferedReader(new InputStreamReader(is));
100             boolean flag = false;
101             String x;
102             while ((x=r.readLine()) != null) {
103                 if (x.length() ==0) {
104                     break;
105                 }
106             }
107 
108             PrintStream out = new PrintStream(
</pre>
<hr />
<pre>
128 
129     /*
130      * Define the client side of the test.
131      *
132      * If the server prematurely exits, serverReady will be set to true
133      * to avoid infinite hangs.
134      */
135     void doClientSide() throws Exception {
136         HostnameVerifier reservedHV =
137             HttpsURLConnection.getDefaultHostnameVerifier();
138         try {
139             /*
140              * Wait for server to get started.
141              */
142             while (!serverReady) {
143                 Thread.sleep(50);
144             }
145             try {
146                 HttpsURLConnection http = null;
147                 /* establish http connection to server */
<span class="line-modified">148                 URL url = new URL(&quot;https://localhost:&quot; + serverPort+&quot;/file1&quot;);</span>





149                 System.out.println(&quot;url is &quot;+url.toString());
150                 HttpsURLConnection.setDefaultHostnameVerifier(
151                                                         new NameVerifier());
<span class="line-modified">152                 http = (HttpsURLConnection)url.openConnection();</span>
153                 int respCode = http.getResponseCode();
154                 int cl = http.getContentLength();
155                 InputStream is = http.getInputStream ();
156                 int count = 0;
157                 while (is.read() != -1 &amp;&amp; count++ &lt; cl);
158                 System.out.println(&quot;respCode1 = &quot;+respCode);
159                 Thread.sleep(2000);
<span class="line-modified">160                 url = new URL(&quot;https://localhost:&quot; + serverPort+&quot;/file2&quot;);</span>
<span class="line-modified">161                 http = (HttpsURLConnection)url.openConnection();</span>





162                 respCode = http.getResponseCode();
163                 System.out.println(&quot;respCode2 = &quot;+respCode);
164             } catch (IOException ioex) {
165                 if (sslServerSocket != null)
166                     sslServerSocket.close();
167                 throw ioex;
168             }
169         } finally {
170             HttpsURLConnection.setDefaultHostnameVerifier(reservedHV);
171         }
172     }
173 
174     static class NameVerifier implements HostnameVerifier {
175         public boolean verify(String hostname, SSLSession session) {
176             return true;
177         }
178     }
179 
180     /*
181      * =============================================================
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2003, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 /* @test
 25  * @bug 4799427
 26  * @summary Https can not retry request
<span class="line-added"> 27  * @library /test/lib</span>
 28  * @run main/othervm RetryHttps
<span class="line-added"> 29  * @run main/othervm -Djava.net.preferIPv6Addresses=true RetryHttps</span>
 30  *
 31  *     SunJSSE does not support dynamic system properties, no way to re-use
 32  *     system properties in samevm/agentvm mode.
 33  * @author Yingxian Wang
 34  */
 35 
 36 import java.net.*;
 37 import java.util.*;
 38 import java.io.*;
 39 import javax.net.ssl.*;
<span class="line-added"> 40 import jdk.test.lib.net.URIBuilder;</span>
 41 
 42 public class RetryHttps {
 43     static Map cookies;
 44     ServerSocket ss;
 45 
 46     /*
 47      * =============================================================
 48      * Set the various variables needed for the tests, then
 49      * specify what tests to run on each side.
 50      */
 51 
 52     /*
 53      * Should we run the client or server in a separate thread?
 54      * Both sides can throw exceptions, but do you have a preference
 55      * as to which side should be the main thread.
 56      */
 57     static boolean separateServerThread = true;
 58 
 59     /*
 60      * Where do we find the keystores?
</pre>
<hr />
<pre>
 66 
 67     /*
 68      * Is the server ready to serve?
 69      */
 70     volatile static boolean serverReady = false;
 71 
 72     /*
 73      * Turn on SSL debugging?
 74      */
 75     static boolean debug = true;
 76 
 77     private SSLServerSocket sslServerSocket = null;
 78 
 79     /*
 80      * Define the server side of the test.
 81      *
 82      * If the server prematurely exits, serverReady will be set to true
 83      * to avoid infinite hangs.
 84      */
 85     void doServerSide() throws Exception {
<span class="line-added"> 86         InetAddress loopback = InetAddress.getLoopbackAddress();</span>
 87         SSLServerSocketFactory sslssf =
 88             (SSLServerSocketFactory) SSLServerSocketFactory.getDefault();
 89         sslServerSocket =
<span class="line-modified"> 90             (SSLServerSocket) sslssf.createServerSocket(serverPort, 0, loopback);</span>
 91         serverPort = sslServerSocket.getLocalPort();
 92 
<span class="line-added"> 93         System.out.println(&quot;Starting server at: &quot;</span>
<span class="line-added"> 94                             +  sslServerSocket.getInetAddress()</span>
<span class="line-added"> 95                             + &quot;:&quot; + serverPort);</span>
<span class="line-added"> 96 </span>
 97         /*
 98          * Signal Client, we&#39;re ready for his connect.
 99          */
100         serverReady = true;
101         SSLSocket sslSocket = null;
102         try {
103             for (int i = 0; i &lt; 2; i++) {
104             sslSocket = (SSLSocket) sslServerSocket.accept();
105             // read request
106             InputStream is = sslSocket.getInputStream ();
107             BufferedReader r = new BufferedReader(new InputStreamReader(is));
108             boolean flag = false;
109             String x;
110             while ((x=r.readLine()) != null) {
111                 if (x.length() ==0) {
112                     break;
113                 }
114             }
115 
116             PrintStream out = new PrintStream(
</pre>
<hr />
<pre>
136 
137     /*
138      * Define the client side of the test.
139      *
140      * If the server prematurely exits, serverReady will be set to true
141      * to avoid infinite hangs.
142      */
143     void doClientSide() throws Exception {
144         HostnameVerifier reservedHV =
145             HttpsURLConnection.getDefaultHostnameVerifier();
146         try {
147             /*
148              * Wait for server to get started.
149              */
150             while (!serverReady) {
151                 Thread.sleep(50);
152             }
153             try {
154                 HttpsURLConnection http = null;
155                 /* establish http connection to server */
<span class="line-modified">156                URL url = URIBuilder.newBuilder()</span>
<span class="line-added">157                       .scheme(&quot;https&quot;)</span>
<span class="line-added">158                       .loopback()</span>
<span class="line-added">159                       .port(serverPort)</span>
<span class="line-added">160                       .path(&quot;/file1&quot;)</span>
<span class="line-added">161                       .toURL();</span>
162                 System.out.println(&quot;url is &quot;+url.toString());
163                 HttpsURLConnection.setDefaultHostnameVerifier(
164                                                         new NameVerifier());
<span class="line-modified">165                 http = (HttpsURLConnection)url.openConnection(Proxy.NO_PROXY);</span>
166                 int respCode = http.getResponseCode();
167                 int cl = http.getContentLength();
168                 InputStream is = http.getInputStream ();
169                 int count = 0;
170                 while (is.read() != -1 &amp;&amp; count++ &lt; cl);
171                 System.out.println(&quot;respCode1 = &quot;+respCode);
172                 Thread.sleep(2000);
<span class="line-modified">173                 url = URIBuilder.newBuilder()</span>
<span class="line-modified">174                       .scheme(&quot;https&quot;)</span>
<span class="line-added">175                       .loopback()</span>
<span class="line-added">176                       .port(serverPort)</span>
<span class="line-added">177                       .path(&quot;/file2&quot;)</span>
<span class="line-added">178                       .toURL();</span>
<span class="line-added">179                 http = (HttpsURLConnection)url.openConnection(Proxy.NO_PROXY);</span>
180                 respCode = http.getResponseCode();
181                 System.out.println(&quot;respCode2 = &quot;+respCode);
182             } catch (IOException ioex) {
183                 if (sslServerSocket != null)
184                     sslServerSocket.close();
185                 throw ioex;
186             }
187         } finally {
188             HttpsURLConnection.setDefaultHostnameVerifier(reservedHV);
189         }
190     }
191 
192     static class NameVerifier implements HostnameVerifier {
193         public boolean verify(String hostname, SSLSession session) {
194             return true;
195         }
196     }
197 
198     /*
199      * =============================================================
</pre>
</td>
</tr>
</table>
<center><a href="Redirect.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="TunnelProxy.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames test/jdk/sun/net/www/protocol/https/HttpsURLConnection/RetryHttps.java</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
<a name="1" id="anc1"></a><span class="line-modified">  2  * Copyright (c) 2003, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 /* @test
 25  * @bug 4799427
 26  * @summary Https can not retry request
<a name="2" id="anc2"></a><span class="line-added"> 27  * @library /test/lib</span>
 28  * @run main/othervm RetryHttps
<a name="3" id="anc3"></a><span class="line-added"> 29  * @run main/othervm -Djava.net.preferIPv6Addresses=true RetryHttps</span>
 30  *
 31  *     SunJSSE does not support dynamic system properties, no way to re-use
 32  *     system properties in samevm/agentvm mode.
 33  * @author Yingxian Wang
 34  */
 35 
 36 import java.net.*;
 37 import java.util.*;
 38 import java.io.*;
 39 import javax.net.ssl.*;
<a name="4" id="anc4"></a><span class="line-added"> 40 import jdk.test.lib.net.URIBuilder;</span>
 41 
 42 public class RetryHttps {
 43     static Map cookies;
 44     ServerSocket ss;
 45 
 46     /*
 47      * =============================================================
 48      * Set the various variables needed for the tests, then
 49      * specify what tests to run on each side.
 50      */
 51 
 52     /*
 53      * Should we run the client or server in a separate thread?
 54      * Both sides can throw exceptions, but do you have a preference
 55      * as to which side should be the main thread.
 56      */
 57     static boolean separateServerThread = true;
 58 
 59     /*
 60      * Where do we find the keystores?
 61      */
 62     static String pathToStores = &quot;../../../../../../javax/net/ssl/etc&quot;;
 63     static String keyStoreFile = &quot;keystore&quot;;
 64     static String trustStoreFile = &quot;truststore&quot;;
 65     static String passwd = &quot;passphrase&quot;;
 66 
 67     /*
 68      * Is the server ready to serve?
 69      */
 70     volatile static boolean serverReady = false;
 71 
 72     /*
 73      * Turn on SSL debugging?
 74      */
 75     static boolean debug = true;
 76 
 77     private SSLServerSocket sslServerSocket = null;
 78 
 79     /*
 80      * Define the server side of the test.
 81      *
 82      * If the server prematurely exits, serverReady will be set to true
 83      * to avoid infinite hangs.
 84      */
 85     void doServerSide() throws Exception {
<a name="5" id="anc5"></a><span class="line-added"> 86         InetAddress loopback = InetAddress.getLoopbackAddress();</span>
 87         SSLServerSocketFactory sslssf =
 88             (SSLServerSocketFactory) SSLServerSocketFactory.getDefault();
 89         sslServerSocket =
<a name="6" id="anc6"></a><span class="line-modified"> 90             (SSLServerSocket) sslssf.createServerSocket(serverPort, 0, loopback);</span>
 91         serverPort = sslServerSocket.getLocalPort();
 92 
<a name="7" id="anc7"></a><span class="line-added"> 93         System.out.println(&quot;Starting server at: &quot;</span>
<span class="line-added"> 94                             +  sslServerSocket.getInetAddress()</span>
<span class="line-added"> 95                             + &quot;:&quot; + serverPort);</span>
<span class="line-added"> 96 </span>
 97         /*
 98          * Signal Client, we&#39;re ready for his connect.
 99          */
100         serverReady = true;
101         SSLSocket sslSocket = null;
102         try {
103             for (int i = 0; i &lt; 2; i++) {
104             sslSocket = (SSLSocket) sslServerSocket.accept();
105             // read request
106             InputStream is = sslSocket.getInputStream ();
107             BufferedReader r = new BufferedReader(new InputStreamReader(is));
108             boolean flag = false;
109             String x;
110             while ((x=r.readLine()) != null) {
111                 if (x.length() ==0) {
112                     break;
113                 }
114             }
115 
116             PrintStream out = new PrintStream(
117                                  new BufferedOutputStream(
118                                     sslSocket.getOutputStream() ));
119 
120             /* send the header */
121             out.print(&quot;HTTP/1.1 200 OK\r\n&quot;);
122             out.print(&quot;Content-Type: text/html; charset=iso-8859-1\r\n&quot;);
123             out.print(&quot;Content-Length: &quot;+10+&quot;\r\n&quot;);
124             out.print(&quot;\r\n&quot;);
125             out.print(&quot;Testing&quot;+i+&quot;\r\n&quot;);
126             out.flush();
127             sslSocket.close();
128             }
129 
130 
131             sslServerSocket.close();
132         } catch (Exception e) {
133             e.printStackTrace();
134         }
135     }
136 
137     /*
138      * Define the client side of the test.
139      *
140      * If the server prematurely exits, serverReady will be set to true
141      * to avoid infinite hangs.
142      */
143     void doClientSide() throws Exception {
144         HostnameVerifier reservedHV =
145             HttpsURLConnection.getDefaultHostnameVerifier();
146         try {
147             /*
148              * Wait for server to get started.
149              */
150             while (!serverReady) {
151                 Thread.sleep(50);
152             }
153             try {
154                 HttpsURLConnection http = null;
155                 /* establish http connection to server */
<a name="8" id="anc8"></a><span class="line-modified">156                URL url = URIBuilder.newBuilder()</span>
<span class="line-added">157                       .scheme(&quot;https&quot;)</span>
<span class="line-added">158                       .loopback()</span>
<span class="line-added">159                       .port(serverPort)</span>
<span class="line-added">160                       .path(&quot;/file1&quot;)</span>
<span class="line-added">161                       .toURL();</span>
162                 System.out.println(&quot;url is &quot;+url.toString());
163                 HttpsURLConnection.setDefaultHostnameVerifier(
164                                                         new NameVerifier());
<a name="9" id="anc9"></a><span class="line-modified">165                 http = (HttpsURLConnection)url.openConnection(Proxy.NO_PROXY);</span>
166                 int respCode = http.getResponseCode();
167                 int cl = http.getContentLength();
168                 InputStream is = http.getInputStream ();
169                 int count = 0;
170                 while (is.read() != -1 &amp;&amp; count++ &lt; cl);
171                 System.out.println(&quot;respCode1 = &quot;+respCode);
172                 Thread.sleep(2000);
<a name="10" id="anc10"></a><span class="line-modified">173                 url = URIBuilder.newBuilder()</span>
<span class="line-modified">174                       .scheme(&quot;https&quot;)</span>
<span class="line-added">175                       .loopback()</span>
<span class="line-added">176                       .port(serverPort)</span>
<span class="line-added">177                       .path(&quot;/file2&quot;)</span>
<span class="line-added">178                       .toURL();</span>
<span class="line-added">179                 http = (HttpsURLConnection)url.openConnection(Proxy.NO_PROXY);</span>
180                 respCode = http.getResponseCode();
181                 System.out.println(&quot;respCode2 = &quot;+respCode);
182             } catch (IOException ioex) {
183                 if (sslServerSocket != null)
184                     sslServerSocket.close();
185                 throw ioex;
186             }
187         } finally {
188             HttpsURLConnection.setDefaultHostnameVerifier(reservedHV);
189         }
190     }
191 
192     static class NameVerifier implements HostnameVerifier {
193         public boolean verify(String hostname, SSLSession session) {
194             return true;
195         }
196     }
197 
198     /*
199      * =============================================================
200      * The remainder is just support stuff
201      */
202 
203     // use any free port by default
204     volatile int serverPort = 0;
205 
206     volatile Exception serverException = null;
207     volatile Exception clientException = null;
208 
209     public static void main(String args[]) throws Exception {
210         String keyFilename =
211             System.getProperty(&quot;test.src&quot;, &quot;./&quot;) + &quot;/&quot; + pathToStores +
212                 &quot;/&quot; + keyStoreFile;
213         String trustFilename =
214             System.getProperty(&quot;test.src&quot;, &quot;./&quot;) + &quot;/&quot; + pathToStores +
215                 &quot;/&quot; + trustStoreFile;
216 
217         System.setProperty(&quot;javax.net.ssl.keyStore&quot;, keyFilename);
218         System.setProperty(&quot;javax.net.ssl.keyStorePassword&quot;, passwd);
219         System.setProperty(&quot;javax.net.ssl.trustStore&quot;, trustFilename);
220         System.setProperty(&quot;javax.net.ssl.trustStorePassword&quot;, passwd);
221 
222         if (debug)
223             System.setProperty(&quot;javax.net.debug&quot;, &quot;all&quot;);
224 
225         /*
226          * Start the tests.
227          */
228         new RetryHttps();
229     }
230 
231     Thread clientThread = null;
232     Thread serverThread = null;
233     /*
234      * Primary constructor, used to drive remainder of the test.
235      *
236      * Fork off the other side, then do your work.
237      */
238     RetryHttps() throws Exception {
239         if (separateServerThread) {
240             startServer(true);
241             startClient(false);
242         } else {
243             startClient(true);
244             startServer(false);
245         }
246 
247         /*
248          * Wait for other side to close down.
249          */
250         if (separateServerThread) {
251             serverThread.join();
252         } else {
253             clientThread.join();
254         }
255 
256         /*
257          * When we get here, the test is pretty much over.
258          *
259          * If the main thread excepted, that propagates back
260          * immediately.  If the other thread threw an exception, we
261          * should report back.
262          */
263         if (serverException != null)
264             throw serverException;
265         if (clientException != null)
266             throw clientException;
267     }
268 
269     void startServer(boolean newThread) throws Exception {
270         if (newThread) {
271             serverThread = new Thread() {
272                 public void run() {
273                     try {
274                         doServerSide();
275                     } catch (Exception e) {
276                         /*
277                          * Our server thread just died.
278                          *
279                          * Release the client, if not active already...
280                          */
281                         System.err.println(&quot;Server died...&quot;);
282                         serverReady = true;
283                         serverException = e;
284                     }
285                 }
286             };
287             serverThread.start();
288         } else {
289             doServerSide();
290         }
291     }
292 
293     void startClient(boolean newThread) throws Exception {
294         if (newThread) {
295             clientThread = new Thread() {
296                 public void run() {
297                     try {
298                         doClientSide();
299                     } catch (Exception e) {
300                         /*
301                          * Our client thread just died.
302                          */
303                         System.err.println(&quot;Client died...&quot;);
304                         clientException = e;
305                     }
306                 }
307             };
308             clientThread.start();
309         } else {
310             doClientSide();
311         }
312     }
313 }
<a name="11" id="anc11"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="11" type="hidden" />
</body>
</html>
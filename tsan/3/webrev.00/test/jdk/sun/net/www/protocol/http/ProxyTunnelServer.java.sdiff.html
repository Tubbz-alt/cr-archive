<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff test/jdk/sun/net/www/protocol/http/ProxyTunnelServer.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
<body>
<center><a href="NoNTLM.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="RedirectOnPost.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>test/jdk/sun/net/www/protocol/http/ProxyTunnelServer.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2002, 2013, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
</pre>
<hr />
<pre>
 49     private volatile Socket clientSocket = null;
 50 
 51     /*
 52      * Origin server&#39;s address and port that the client
 53      * wants to establish the tunnel for communication.
 54      */
 55     private volatile InetAddress serverInetAddr;
 56     private volatile int serverPort;
 57 
 58     /*
 59      * denote whether the proxy needs to authorize
 60      * CONNECT requests.
 61      */
 62 
 63     volatile boolean needAuth = false;
 64 
 65     public ProxyTunnelServer() throws IOException {
 66         ss = new ServerSocket(0);
 67     }
 68 




 69     static private void close(Closeable c) {
 70         try {
 71             if (c != null)
 72                 c.close();
 73         } catch (IOException e) {
 74             e.printStackTrace();
 75         }
 76     }
 77 
 78     public void needUserAuth(boolean auth) {
 79         needAuth = auth;
 80     }
 81 
 82     public void terminate() {
 83         close(ss);
 84         close(clientSocket);
 85     }
 86 
 87     /*
 88      * register users with the proxy, by providing username and
</pre>
<hr />
<pre>
107             System.out.println(&quot;Proxy Failed: &quot; + e);
108             e.printStackTrace();
109             try {
110                 ss.close();
111             }
112             catch (IOException excep) {
113                 System.out.println(&quot;ProxyServer close error: &quot; + excep);
114                 excep.printStackTrace();
115             }
116           }
117     }
118 
119     /*
120      * Processes the CONNECT requests, if needAuth is set to true, then
121      * the name and password are extracted from the Proxy-Authorization header
122      * of the request. They are checked against the one that is registered,
123      * if there is a match, connection is set in tunneling mode. If
124      * needAuth is set to false, Proxy-Authorization checks are not made
125      */
126     private void processRequests(boolean makeTunnel) throws Exception {
<span class="line-removed">127 </span>
128         InputStream in = clientSocket.getInputStream();
129         MessageHeader mheader = new MessageHeader(in);
130         String statusLine = mheader.getValue(0);
131 


132         if (statusLine.startsWith(&quot;CONNECT&quot;)) {
133             // retrieve the host and port info from the status-line
134             // retrieveConnectInfo(statusLine);
135             if (needAuth) {
136                 String authInfo;
137                 if ((authInfo = mheader.findValue(&quot;Proxy-Authorization&quot;))
138                                          != null) {
139                    if (authenticate(authInfo)) {
140                         needAuth = false;
141                         System.out.println(
142                                 &quot;Proxy: client authentication successful&quot;);
143                    }
144                 }
145             }
146 
147             if (makeTunnel) {
148                 retrieveConnectInfo(statusLine);
149                 doTunnel();
150                 return;
151             }
</pre>
<hr />
<pre>
294         String serverName = null;
295         try {
296             starti = connectStr.indexOf(&#39; &#39;);
297             endi = connectStr.lastIndexOf(&#39; &#39;);
298             connectInfo = connectStr.substring(starti+1, endi).trim();
299             // retrieve server name and port
300             endi = connectInfo.indexOf(&#39;:&#39;);
301             serverName = connectInfo.substring(0, endi);
302             serverPort = Integer.parseInt(connectInfo.substring(endi+1));
303         } catch (Exception e) {
304             throw new IOException(&quot;Proxy recieved a request: &quot;
305                                         + connectStr);
306           }
307         serverInetAddr = InetAddress.getByName(serverName);
308     }
309 
310     public int getPort() {
311         return ss.getLocalPort();
312     }
313 




314     /*
315      * do &quot;basic&quot; authentication, authInfo is of the form:
316      *                                  Basic &lt;encoded username&quot;:&quot;password&gt;
317      * reference RFC 2617
318      */
319     private boolean authenticate(String authInfo) throws IOException {
320         boolean matched = false;
321         try {
322             authInfo.trim();
323             int ind = authInfo.indexOf(&#39; &#39;);
324             String recvdUserPlusPass = authInfo.substring(ind + 1).trim();
325             // extract encoded (username:passwd
326             if (userPlusPass.equals(
327                                 new String(Base64.getDecoder().decode(recvdUserPlusPass))
328                                 )) {
329                 matched = true;
330             }
331         } catch (Exception e) {
332               throw new IOException(
333                 &quot;Proxy received invalid Proxy-Authorization value: &quot;
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2002, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
</pre>
<hr />
<pre>
 49     private volatile Socket clientSocket = null;
 50 
 51     /*
 52      * Origin server&#39;s address and port that the client
 53      * wants to establish the tunnel for communication.
 54      */
 55     private volatile InetAddress serverInetAddr;
 56     private volatile int serverPort;
 57 
 58     /*
 59      * denote whether the proxy needs to authorize
 60      * CONNECT requests.
 61      */
 62 
 63     volatile boolean needAuth = false;
 64 
 65     public ProxyTunnelServer() throws IOException {
 66         ss = new ServerSocket(0);
 67     }
 68 
<span class="line-added"> 69     public ProxyTunnelServer(InetAddress address) throws IOException {</span>
<span class="line-added"> 70         ss = new ServerSocket(0, 0, address);</span>
<span class="line-added"> 71     }</span>
<span class="line-added"> 72 </span>
 73     static private void close(Closeable c) {
 74         try {
 75             if (c != null)
 76                 c.close();
 77         } catch (IOException e) {
 78             e.printStackTrace();
 79         }
 80     }
 81 
 82     public void needUserAuth(boolean auth) {
 83         needAuth = auth;
 84     }
 85 
 86     public void terminate() {
 87         close(ss);
 88         close(clientSocket);
 89     }
 90 
 91     /*
 92      * register users with the proxy, by providing username and
</pre>
<hr />
<pre>
111             System.out.println(&quot;Proxy Failed: &quot; + e);
112             e.printStackTrace();
113             try {
114                 ss.close();
115             }
116             catch (IOException excep) {
117                 System.out.println(&quot;ProxyServer close error: &quot; + excep);
118                 excep.printStackTrace();
119             }
120           }
121     }
122 
123     /*
124      * Processes the CONNECT requests, if needAuth is set to true, then
125      * the name and password are extracted from the Proxy-Authorization header
126      * of the request. They are checked against the one that is registered,
127      * if there is a match, connection is set in tunneling mode. If
128      * needAuth is set to false, Proxy-Authorization checks are not made
129      */
130     private void processRequests(boolean makeTunnel) throws Exception {

131         InputStream in = clientSocket.getInputStream();
132         MessageHeader mheader = new MessageHeader(in);
133         String statusLine = mheader.getValue(0);
134 
<span class="line-added">135         System.out.printf(&quot;Proxy: Processing request from &#39;%s&#39;%n&quot;, clientSocket);</span>
<span class="line-added">136 </span>
137         if (statusLine.startsWith(&quot;CONNECT&quot;)) {
138             // retrieve the host and port info from the status-line
139             // retrieveConnectInfo(statusLine);
140             if (needAuth) {
141                 String authInfo;
142                 if ((authInfo = mheader.findValue(&quot;Proxy-Authorization&quot;))
143                                          != null) {
144                    if (authenticate(authInfo)) {
145                         needAuth = false;
146                         System.out.println(
147                                 &quot;Proxy: client authentication successful&quot;);
148                    }
149                 }
150             }
151 
152             if (makeTunnel) {
153                 retrieveConnectInfo(statusLine);
154                 doTunnel();
155                 return;
156             }
</pre>
<hr />
<pre>
299         String serverName = null;
300         try {
301             starti = connectStr.indexOf(&#39; &#39;);
302             endi = connectStr.lastIndexOf(&#39; &#39;);
303             connectInfo = connectStr.substring(starti+1, endi).trim();
304             // retrieve server name and port
305             endi = connectInfo.indexOf(&#39;:&#39;);
306             serverName = connectInfo.substring(0, endi);
307             serverPort = Integer.parseInt(connectInfo.substring(endi+1));
308         } catch (Exception e) {
309             throw new IOException(&quot;Proxy recieved a request: &quot;
310                                         + connectStr);
311           }
312         serverInetAddr = InetAddress.getByName(serverName);
313     }
314 
315     public int getPort() {
316         return ss.getLocalPort();
317     }
318 
<span class="line-added">319     public InetAddress getInetAddress() {</span>
<span class="line-added">320         return ss.getInetAddress();</span>
<span class="line-added">321     }</span>
<span class="line-added">322 </span>
323     /*
324      * do &quot;basic&quot; authentication, authInfo is of the form:
325      *                                  Basic &lt;encoded username&quot;:&quot;password&gt;
326      * reference RFC 2617
327      */
328     private boolean authenticate(String authInfo) throws IOException {
329         boolean matched = false;
330         try {
331             authInfo.trim();
332             int ind = authInfo.indexOf(&#39; &#39;);
333             String recvdUserPlusPass = authInfo.substring(ind + 1).trim();
334             // extract encoded (username:passwd
335             if (userPlusPass.equals(
336                                 new String(Base64.getDecoder().decode(recvdUserPlusPass))
337                                 )) {
338                 matched = true;
339             }
340         } catch (Exception e) {
341               throw new IOException(
342                 &quot;Proxy received invalid Proxy-Authorization value: &quot;
</pre>
</td>
</tr>
</table>
<center><a href="NoNTLM.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="RedirectOnPost.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
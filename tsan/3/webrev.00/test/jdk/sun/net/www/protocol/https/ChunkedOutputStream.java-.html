<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old test/jdk/sun/net/www/protocol/https/ChunkedOutputStream.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2004, 2012, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 /**
 25  * @test
 26  * @bug 5026745
 27  * @modules java.base/sun.net.www
 28  * @build TestHttpsServer HttpCallback
 29  * @run main/othervm ChunkedOutputStream
 30  *
 31  *     SunJSSE does not support dynamic system properties, no way to re-use
 32  *     system properties in samevm/agentvm mode.
 33  * @summary Cannot flush output stream when writing to an HttpUrlConnection
 34  */
 35 
 36 import java.io.*;
 37 import java.net.*;
 38 import javax.net.ssl.*;
 39 
 40 public class ChunkedOutputStream implements HttpCallback {
 41     /*
 42      * Where do we find the keystores for ssl?
 43      */
 44     static String pathToStores = &quot;../../../../../javax/net/ssl/etc&quot;;
 45     static String keyStoreFile = &quot;keystore&quot;;
 46     static String trustStoreFile = &quot;truststore&quot;;
 47     static String passwd = &quot;passphrase&quot;;
 48     static int count = 0;
 49 
 50     static final String str1 = &quot;Helloworld1234567890abcdefghijklmnopqrstuvwxyz&quot;+
 51                                 &quot;1234567890abcdefkjsdlkjflkjsldkfjlsdkjflkj&quot;+
 52                                 &quot;1434567890abcdefkjsdlkjflkjsldkfjlsdkjflkj&quot;;
 53 
 54     static final String str2 = &quot;Helloworld1234567890abcdefghijklmnopqrstuvwxyz&quot;+
 55                                 &quot;1234567890&quot;;
 56 
 57     public void request (HttpTransaction req) {
 58         try {
 59             // this is needed (count++ doesn&#39;t work), &#39;cause we
 60             // are doing concurrent tests
 61             String path = req.getRequestURI().getPath();
 62             if (path.equals(&quot;/d0&quot;)) {
 63                 count = 0;
 64             } else if (path.equals(&quot;/d01&quot;)) {
 65                 count = 1;
 66             } else if (path.equals(&quot;/d3&quot;)) {
 67                 count = 2;
 68             } else if (path.equals(&quot;/d4&quot;) || path.equals(&quot;/d5&quot;)) {
 69                 count = 3;
 70             } else if (path.equals(&quot;/d6&quot;)) {
 71                 count = 3;
 72             }  else if (path.equals(&quot;/d7&quot;)) {
 73                 count = 4;
 74             }  else if (path.equals(&quot;/d8&quot;)) {
 75                 count = 5;
 76             }
 77 
 78             switch (count) {
 79             case 0: /* test1 -- keeps conn alive */
 80             case 1: /* test2 -- closes conn */
 81                 String reqbody = req.getRequestEntityBody();
 82                 if (!reqbody.equals(str1)) {
 83                     req.sendResponse (500, &quot;Internal server error&quot;);
 84                     req.orderlyClose();
 85                 }
 86                 String chunk = req.getRequestHeader (&quot;Transfer-encoding&quot;);
 87                 if (!&quot;chunked&quot;.equals (chunk)) {
 88                     req.sendResponse (501, &quot;Internal server error&quot;);
 89                     req.orderlyClose();
 90                 }
 91                 req.setResponseEntityBody (reqbody);
 92                 if (count == 1) {
 93                     req.setResponseHeader (&quot;Connection&quot;, &quot;close&quot;);
 94                 }
 95                 req.sendResponse (200, &quot;OK&quot;);
 96                 if (count == 1) {
 97                     req.orderlyClose();
 98                 }
 99                 break;
100             case 2: /* test 3 */
101                 reqbody = req.getRequestEntityBody();
102                 if (!reqbody.equals(str2)) {
103                     req.sendResponse (500, &quot;Internal server error&quot;);
104                     req.orderlyClose();
105                 }
106                 int clen = Integer.parseInt (
107                         req.getRequestHeader (&quot;Content-length&quot;));
108                 if (clen != str2.length()) {
109                     req.sendResponse (501, &quot;Internal server error&quot;);
110                     req.orderlyClose();
111                 }
112                 req.setResponseEntityBody (reqbody);
113                 req.setResponseHeader (&quot;Connection&quot;, &quot;close&quot;);
114                 req.sendResponse (200, &quot;OK&quot;);
115                 req.orderlyClose();
116                 break;
117             case 3: /* test 6 */
118                 req.setResponseHeader (&quot;Location&quot;, &quot;https://foo.bar/&quot;);
119                 req.setResponseHeader (&quot;Connection&quot;, &quot;close&quot;);
120                 req.sendResponse (307, &quot;Temporary Redirect&quot;);
121                 req.orderlyClose();
122                 break;
123             case 4: /* test 7 */
124             case 5: /* test 8 */
125                 reqbody = req.getRequestEntityBody();
126                 if (reqbody != null &amp;&amp; !&quot;&quot;.equals (reqbody)) {
127                     req.sendResponse (501, &quot;Internal server error&quot;);
128                     req.orderlyClose();
129                 }
130                 req.setResponseHeader (&quot;Connection&quot;, &quot;close&quot;);
131                 req.sendResponse (200, &quot;OK&quot;);
132                 req.orderlyClose();
133                 break;
134             }
135         } catch (IOException e) {
136             e.printStackTrace();
137         }
138     }
139 
140     static void readAndCompare (InputStream is, String cmp) throws IOException {
141         int c;
142         byte buf[] = new byte [1024];
143         int off = 0;
144         int len = 1024;
145         while ((c=is.read(buf, off, len)) != -1) {
146             off += c;
147             len -= c;
148         }
149         String s1 = new String (buf, 0, off, &quot;ISO8859_1&quot;);
150         if (!cmp.equals(s1)) {
151             throw new IOException (&quot;strings not same&quot;);
152         }
153     }
154 
155     /* basic chunked test (runs twice) */
156 
157     static void test1 (String u) throws Exception {
158         URL url = new URL (u);
159         System.out.println (&quot;client opening connection to: &quot; + u);
160         HttpURLConnection urlc = (HttpURLConnection)url.openConnection ();
161         urlc.setChunkedStreamingMode (20);
162         urlc.setDoOutput(true);
163         urlc.setRequestMethod (&quot;POST&quot;);
164         OutputStream os = urlc.getOutputStream ();
165         os.write (str1.getBytes());
166         os.close();
167         InputStream is = urlc.getInputStream();
168         readAndCompare (is, str1);
169         is.close();
170     }
171 
172     /* basic fixed length test */
173 
174     static void test3 (String u) throws Exception {
175         URL url = new URL (u);
176         System.out.println (&quot;client opening connection to: &quot; + u);
177         HttpURLConnection urlc = (HttpURLConnection)url.openConnection ();
178         urlc.setFixedLengthStreamingMode (str2.length());
179         urlc.setDoOutput(true);
180         urlc.setRequestMethod (&quot;POST&quot;);
181         OutputStream os = urlc.getOutputStream ();
182         os.write (str2.getBytes());
183         os.close();
184         InputStream is = urlc.getInputStream();
185         readAndCompare (is, str2);
186         is.close();
187     }
188 
189     /* write too few bytes */
190 
191     static void test4 (String u) throws Exception {
192         URL url = new URL (u);
193         System.out.println (&quot;client opening connection to: &quot; + u);
194         HttpURLConnection urlc = (HttpURLConnection)url.openConnection ();
195         urlc.setFixedLengthStreamingMode (str2.length()+1);
196         urlc.setDoOutput(true);
197         urlc.setRequestMethod (&quot;POST&quot;);
198         OutputStream os = urlc.getOutputStream ();
199         os.write (str2.getBytes());
200         try {
201             os.close();
202             throw new Exception (&quot;should have thrown IOException&quot;);
203         } catch (IOException e) {}
204     }
205 
206     /* write too many bytes */
207 
208     static void test5 (String u) throws Exception {
209         URL url = new URL (u);
210         System.out.println (&quot;client opening connection to: &quot; + u);
211         HttpURLConnection urlc = (HttpURLConnection)url.openConnection ();
212         urlc.setFixedLengthStreamingMode (str2.length()-1);
213         urlc.setDoOutput(true);
214         urlc.setRequestMethod (&quot;POST&quot;);
215         OutputStream os = urlc.getOutputStream ();
216         try {
217             os.write (str2.getBytes());
218             throw new Exception (&quot;should have thrown IOException&quot;);
219         } catch (IOException e) {}
220     }
221 
222     /* check for HttpRetryException on redirection */
223 
224     static void test6 (String u) throws Exception {
225         URL url = new URL (u);
226         System.out.println (&quot;client opening connection to: &quot; + u);
227         HttpURLConnection urlc = (HttpURLConnection)url.openConnection ();
228         urlc.setChunkedStreamingMode (20);
229         urlc.setDoOutput(true);
230         urlc.setRequestMethod (&quot;POST&quot;);
231         OutputStream os = urlc.getOutputStream ();
232         os.write (str1.getBytes());
233         os.close();
234         try {
235             InputStream is = urlc.getInputStream();
236             throw new Exception (&quot;should have gotten HttpRetryException&quot;);
237         } catch (HttpRetryException e) {
238             if (e.responseCode() != 307) {
239                 throw new Exception (&quot;Wrong response code &quot; + e.responseCode());
240             }
241             if (!e.getLocation().equals (&quot;https://foo.bar/&quot;)) {
242                 throw new Exception (&quot;Wrong location &quot; + e.getLocation());
243             }
244         }
245     }
246 
247     /* next two tests send zero length posts */
248 
249     static void test7 (String u) throws Exception {
250         URL url = new URL (u);
251         System.out.println (&quot;client opening connection to: &quot; + u);
252         HttpURLConnection urlc = (HttpURLConnection)url.openConnection ();
253         urlc.setChunkedStreamingMode (20);
254         urlc.setDoOutput(true);
255         urlc.setRequestMethod (&quot;POST&quot;);
256         OutputStream os = urlc.getOutputStream ();
257         os.close();
258         int ret = urlc.getResponseCode();
259         if (ret != 200) {
260             throw new Exception (&quot;Expected 200: got &quot; + ret);
261         }
262     }
263 
264     static void test8 (String u) throws Exception {
265         URL url = new URL (u);
266         System.out.println (&quot;client opening connection to: &quot; + u);
267         HttpURLConnection urlc = (HttpURLConnection)url.openConnection ();
268         urlc.setFixedLengthStreamingMode (0);
269         urlc.setDoOutput(true);
270         urlc.setRequestMethod (&quot;POST&quot;);
271         OutputStream os = urlc.getOutputStream ();
272         os.close();
273         int ret = urlc.getResponseCode();
274         if (ret != 200) {
275             throw new Exception (&quot;Expected 200: got &quot; + ret);
276         }
277     }
278 
279     static TestHttpsServer server;
280 
281     public static void main (String[] args) throws Exception {
282         // setup properties to do ssl
283         String keyFilename =
284             System.getProperty(&quot;test.src&quot;, &quot;./&quot;) + &quot;/&quot; + pathToStores +
285                 &quot;/&quot; + keyStoreFile;
286         String trustFilename =
287             System.getProperty(&quot;test.src&quot;, &quot;./&quot;) + &quot;/&quot; + pathToStores +
288                 &quot;/&quot; + trustStoreFile;
289 
290         HostnameVerifier reservedHV =
291             HttpsURLConnection.getDefaultHostnameVerifier();
292         try {
293             System.setProperty(&quot;javax.net.ssl.keyStore&quot;, keyFilename);
294             System.setProperty(&quot;javax.net.ssl.keyStorePassword&quot;, passwd);
295             System.setProperty(&quot;javax.net.ssl.trustStore&quot;, trustFilename);
296             System.setProperty(&quot;javax.net.ssl.trustStorePassword&quot;, passwd);
297             HttpsURLConnection.setDefaultHostnameVerifier(new NameVerifier());
298 
299             try {
300                 server = new TestHttpsServer(
301                         new ChunkedOutputStream(), 1, 10, 0);
302                 System.out.println (&quot;Server started: listening on port: &quot; + server.getLocalPort());
303                 // the test server doesn&#39;t support keep-alive yet
304                 // test1(&quot;http://localhost:&quot;+server.getLocalPort()+&quot;/d0&quot;);
305                 test1(&quot;https://localhost:&quot;+server.getLocalPort()+&quot;/d01&quot;);
306                 test3(&quot;https://localhost:&quot;+server.getLocalPort()+&quot;/d3&quot;);
307                 test4(&quot;https://localhost:&quot;+server.getLocalPort()+&quot;/d4&quot;);
308                 test5(&quot;https://localhost:&quot;+server.getLocalPort()+&quot;/d5&quot;);
309                 test6(&quot;https://localhost:&quot;+server.getLocalPort()+&quot;/d6&quot;);
310                 test7(&quot;https://localhost:&quot;+server.getLocalPort()+&quot;/d7&quot;);
311                 test8(&quot;https://localhost:&quot;+server.getLocalPort()+&quot;/d8&quot;);
312             } catch (Exception e) {
313                 if (server != null) {
314                     server.terminate();
315                 }
316                 throw e;
317             }
318             server.terminate();
319         } finally {
320             HttpsURLConnection.setDefaultHostnameVerifier(reservedHV);
321         }
322     }
323 
324     static class NameVerifier implements HostnameVerifier {
325         public boolean verify(String hostname, SSLSession session) {
326             return true;
327         }
328     }
329 
330     public static void except (String s) {
331         server.terminate();
332         throw new RuntimeException (s);
333     }
334 }
    </pre>
  </body>
</html>
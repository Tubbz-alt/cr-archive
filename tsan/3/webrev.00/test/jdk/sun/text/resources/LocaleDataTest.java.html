<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New test/jdk/sun/text/resources/LocaleDataTest.java</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2007, 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 /*
 24  * @test
 25  * @bug 4052473 4052679 4055602 4066550 4067619 4068012 4068073 4070174 4070452
 26  *      4070178 4070450 4070695 4070725 4070795 4071003 4071183 4071782 4072013
 27  *      4072388 4072773 4075404 4084356 4087238 4092361 4094033 4094371 4098518
 28  *      4099810 4103218 4103220 4103861 4112136 4113638 4113654 4117054 4122468
 29  *      4122840 4139860 4156708 4175306 4215747 4209960 4290801 4900884 4942982
 30  *      4518811 4945388 4936845 4794068 4461740 4965260 4984277 4826794 5032580
 31  *      5102005 5074431 6182685 6208712 6277020 6245766 6351682 6386647 6379382
 32  *      6414459 6455680 6498742 6558863 6488119 6547501 6497154 6558856 6481177
 33  *      6379214 6485516 6486607 4225362 4494727 6533691 6531591 6531593 6570259
 34  *      6509039 6609737 6610748 6645271 6507067 6873931 6450945 6645268 6646611
 35  *      6645405 6650730 6910489 6573250 6870908 6585666 6716626 6914413 6916787
 36  *      6919624 6998391 7019267 7020960 7025837 7020583 7036905 7066203 7101495
 37  *      7003124 7085757 7028073 7171028 7189611 8000983 7195759 8004489 8006509
 38  *      7114053 7074882 7040556 8008577 8013836 8021121 6192407 6931564 8027695
 39  *      8017142 8037343 8055222 8042126 8074791 8075173 8080774 8129361 8134916
 40  *      8145136 8145952 8164784 8037111 8081643 7037368 8178872 8185841 8190918
 41  *      8187946 8195478 8181157 8179071 8193552 8202026 8204269 8202537 8208746
 42  *      8209775 8221432 8227127 8230284 8231273 8233579 8234288
 43  * @summary Verify locale data
 44  * @modules java.base/sun.util.resources
 45  * @modules jdk.localedata
 46  * @run main LocaleDataTest
 47  * @run main LocaleDataTest -cldr
 48  *
 49  */
 50 
 51 /*
 52  *
 53  * (C) Copyright Taligent, Inc. 1996, 1997 - All Rights Reserved
 54  * (C) Copyright IBM Corp. 1996 - 1998 - All Rights Reserved
 55  *
 56  * Portions copyright (c) 2007 Sun Microsystems, Inc.
 57  * All Rights Reserved.
 58  *
 59  * The original version of this source code and documentation
 60  * is copyrighted and owned by Taligent, Inc., a wholly-owned
 61  * subsidiary of IBM. These materials are provided under terms
 62  * of a License Agreement between Taligent and Sun. This technology
 63  * is protected by multiple US and International patents.
 64  *
 65  * This notice and attribution to Taligent may not be removed.
 66  * Taligent is a registered trademark of Taligent, Inc.
 67  *
 68  * Permission to use, copy, modify, and distribute this software
 69  * and its documentation for NON-COMMERCIAL purposes and without
 70  * fee is hereby granted provided that this copyright notice
 71  * appears in all copies. Please refer to the file &quot;copyright.html&quot;
 72  * for further important copyright and licensing information.
 73  *
 74  * SUN MAKES NO REPRESENTATIONS OR WARRANTIES ABOUT THE SUITABILITY OF
 75  * THE SOFTWARE, EITHER EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED
 76  * TO THE IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS FOR A
 77  * PARTICULAR PURPOSE, OR NON-INFRINGEMENT. SUN SHALL NOT BE LIABLE FOR
 78  * ANY DAMAGES SUFFERED BY LICENSEE AS A RESULT OF USING, MODIFYING OR
 79  * DISTRIBUTING THIS SOFTWARE OR ITS DERIVATIVES.
 80  *
 81  */
 82 
 83 /*    This test is a generalized test for verifying changes to the locale data.
 84  *    It is driven by an external file that specifies the particular pieces of locale
 85  *    data to check.  That file is in .properties file format: a series of key/value
 86  *    pairs delimited by newline characters, with the keys separated from the values
 87  *    by = signs.  The keys are similar in syntax to a Unix pathname, with keys at
 88  *    successive levels of containment in the resource-data hierarchy separated by
 89  *    slashes.  The file is in ISO 8859-1 encoding, with control characters and
 90  *    non-ASCII characters denoted with backslash-u escape sequences.  The program also allows
 91  *    blank lines and comment lines to be interspersed with the data.  Comment lines
 92  *    begin with &#39;#&#39;.
 93  *
 94  *    A data file for this test would look something like this:&lt;pre&gt;
 95  *        FormatData//MonthNames/0=January
 96  *        FormatData//MonthNames/1=February
 97  *        LocaleNames//US=United States
 98  *        LocaleNames//FR=France
 99  *        FormatData/fr_FR/MonthNames/0=janvier
100  *        FormatData/fr_FR/MonthNames/1=f\u00e9vrier
101  *        LocaleNames/fr_FR/US=\u00c9tats-Unis
102  *        LocaleNames/fr_FR/FR=France&lt;/pre&gt;
103  *
104  *    Second field which designates locale is in the form of:
105  *    1) Legacy locale notation using &#39;_&#39; as a locale component(language/country/variant) separator.
106  *    language is a mandatory component. country and variant are optional, however,
107  *    variant cannot exist without country. So for example, while &quot;ja&quot;/&quot;ja_JP&quot;/&quot;ja_JP_JP&quot; are valid,
108  *    &quot;_JP&quot;/&quot;ja__JP&quot; are invalid.
109  *
110  *    2) BCP47 language tag notation in which we can specify language tag with &#39;-&#39; as a subtag
111  *       separator. Language tag can be specified with &#39;-&#39; in locale field like this:
112  *       &lt;pre&gt;LocaleNames/sr-Latn/SR=Surinam
113  *        FormatData/sr-Latn-BA/DayNames/2=utorak&lt;/pre&gt;
114  *
115  *    The command-line syntax of this test is
116  *        &lt;tt&gt;java LocaleDataTest [-w] [{ -s | &lt;filename&gt; }] [-cldr]&lt;/tt&gt;
117  *
118  *    This program always sends its results to standard output.   If -w is not specified,
119  *    this program prints out only the differences between the data file and the actual
120  *    resource data.  If -w is specified, the program prints out every entry, comment,
121  *    and blank line from the data file.  Where there is a difference between the data
122  *    file and the resource data, the data is the data from the resources.  This feature
123  *    can be used to quickly generate a new data file.
124  *
125  *    The user can specify an optional filename or -s.  If the user specifies a filename,
126  *    the program uses that file as the data file.  If the user specifies -s, the program
127  *    reads its input from standard input rather than from a file.  If the user specifies
128  *    neither, the program reads its input from a file called LocaleData in the same
129  *    directory the program itself resides in.
130  *
131  *    The -nothrow option prevents the program from throwing an exception when it
132  *    gets an error.  -w implies -nothrow.
133  *
134  *    -cldr option specifies to test CLDR locale data. The default data file name for this
135  *    option is &quot;LocaleData.cldr&quot;.
136  *
137  *    Other command-line options can be specified, but are ignored.
138  *
139  *    It&#39;s important to note what this test will NOT test.  Certain changes to the locale
140  *    data are meant to have certain effects on the internationalization frameworks.  For
141  *    instance, we could ensure round-trip formatting/parsing integrity for the full
142  *    date/time format of SimpleDateFormat by making sure that the full date and time
143  *    patterns include sufficient data.  The test of this is not whether changes were
144  *    made to the locale data; it&#39;s whether using this data gives round-trip integrity.
145  *    Likewise, changing the currency patterns to use \u00a4 instead of local currency
146  *    symbols isn&#39;t something that can be tested by this test; instead, you want to
147  *    actually format currency values and make sure the proper currency symbol was used.
148  *
149  *    This test by itself doesn&#39;t do an exhaustive comparison of locale data.  It is
150  *    possible to do this manually, however:  Use the GenerateKeyList tool to produce
151  *    a complete list of keys for the two versions of the locales you want to compare,
152  *    and then diff them.  This will flag additions and deletions.  Generate a data file
153  *    for the base version of the data using the -w option and the output from
154  *    GenerateKeyList, and then use the resultant file as the data file when you run
155  *    this test against the new version of the data.
156  */
157 
158 import java.io.BufferedReader;
159 import java.io.File;
160 import java.io.FileInputStream;
161 import java.io.FilterReader;
162 import java.io.FilterWriter;
163 import java.io.IOException;
164 import java.io.InputStreamReader;
165 import java.io.OutputStreamWriter;
166 import java.io.PrintWriter;
167 import java.io.Reader;
168 import java.io.Writer;
169 import java.util.Locale;
170 import java.util.MissingResourceException;
171 import java.util.ResourceBundle;
172 import sun.util.resources.LocaleData;
173 
174 public class LocaleDataTest
175 {
176     static final String TEXT_RESOURCES_PACKAGE =&quot;sun.text.resources&quot;;
177     static final String UTIL_RESOURCES_PACKAGE =&quot;sun.util.resources&quot;;
178     static final String DEFAULT_DATAFILE =&quot;LocaleData&quot;;
179     static String cldrSuffix = &quot;&quot;;
180 
181     public static void main(String[] args) throws Exception {
182 
183         // set up our flags and our input and output streams based on the
184         // command-line arguments (exceptions generated here will propagate out
185         // to the environment)
186         BufferedReader in = null;
187         PrintWriter out = null;
188         boolean writeNewFile = false;
189         boolean doThrow = true;
190 
191         for (int i = 0; i &lt; args.length; i++) {
192             if (args[i].equals(&quot;-w&quot;)) {
193                 writeNewFile = true;
194                 doThrow = false;
195             }
196 
197             else if (args[i].equals(&quot;-nothrow&quot;))
198                 doThrow = false;
199 
200             else if (args[i].equals(&quot;-cldr&quot;)) {
201                 cldrSuffix = &quot;.cldr&quot;;
202             }
203 
204             else if (args[i].equals(&quot;-s&quot;) &amp;&amp; in == null)
205                 in = new BufferedReader(new EscapeReader(new InputStreamReader(System.in,
206                                 &quot;ISO8859_1&quot;)));
207             else if (!args[i].startsWith(&quot;-&quot;) &amp;&amp; in == null)
208                 in = new BufferedReader(new EscapeReader(new InputStreamReader(new
209                                 FileInputStream(args[i]), &quot;ISO8859_1&quot;)));
210         }
211         if (in == null) {
212             File localeData = new File(System.getProperty(&quot;test.src&quot;, &quot;.&quot;), DEFAULT_DATAFILE + cldrSuffix);
213             in = new BufferedReader(new EscapeReader(new InputStreamReader(new
214                             FileInputStream(localeData), &quot;ISO8859_1&quot;)));
215         }
216         out = new PrintWriter(new EscapeWriter(new OutputStreamWriter(System.out,
217                         &quot;ISO8859_1&quot;)), true);
218 
219         // perform the actual test
220         int errorCount = doTest(in, out, writeNewFile);
221 
222         // write out the error count, and throw an exception out into the environment
223         // if there were any errors
224         if (errorCount != 0) {
225             if (!writeNewFile)
226                 out.println(&quot;Test failed.  &quot; + errorCount + &quot; errors.&quot;);
227             if (doThrow)
228                 throw new Exception(&quot;Test failed.  &quot; + errorCount + &quot; errors.&quot;);
229         }
230         else if (!writeNewFile)
231             out.println(&quot;Test passed.&quot;);
232 
233         in.close();
234         out.close();
235     }
236 
237     static int doTest(BufferedReader in, PrintWriter out, boolean writeNewFile)
238                     throws Exception {
239         int errorCount = 0;
240 
241         String key = null;
242         String expectedValue = null;
243         String line = in.readLine();
244         while (line != null) {
245             if (line.startsWith(&quot;#&quot;) || line.length() == 0) {
246                 if (writeNewFile)
247                     out.println(line);
248             }
249 
250             else {
251                 int index  = line.indexOf(&quot;=&quot;);
252                 if (index == -1) {
253                     key = line;
254                     expectedValue = &quot;&quot;;
255                 }
256                 else {
257                     key = line.substring(0, index);
258                     if (index + 1 == line.length())
259                         expectedValue = &quot;&quot;;
260                     else
261                         expectedValue = line.substring(index + 1);
262                 }
263                 if (!processLine(key, expectedValue, out, writeNewFile))
264                     ++errorCount;
265             }
266             line = in.readLine();
267         }
268         return errorCount;
269     }
270 
271     static boolean processLine(String key, String expectedValue, PrintWriter out,
272                     boolean writeNewFile) throws Exception {
273         String rbName, localeName, resTag, qualifier;
274         String language = &quot;&quot;, country = &quot;&quot;, variant = &quot;&quot;;
275         int index, oldIndex;
276 
277         index = key.indexOf(&quot;/&quot;);
278         if (index == -1 || index + 1 == key.length())
279             throw new Exception(&quot;Malformed input file: no slashes in \&quot;&quot; + key + &quot;\&quot;&quot;);
280         rbName = key.substring(0, index);
281 
282         oldIndex = index + 1;
283         index = key.indexOf(&quot;/&quot;, oldIndex);
284         if (index == -1 || index + 1 == key.length())
285             throw new Exception(&quot;Malformed input file: \&quot;&quot; + key + &quot;\&quot; is missing locale name&quot;);
286         localeName = key.substring(oldIndex, index);
287         boolean use_tag = localeName.indexOf(&quot;-&quot;) != -1;
288         if (use_tag == false &amp;&amp; localeName.length() &gt; 0) {
289             String[] locDetails = localeName.split(&quot;_&quot;);
290             switch (locDetails.length) {
291                 case 1:
292                     language = locDetails[0];
293                     break;
294                 case 2:
295                     language = locDetails[0];
296                     country = locDetails[1];
297                     break;
298                 case 3:
299                     language = locDetails[0];
300                     country = locDetails[1];
301                     variant = locDetails[2];
302                     break;
303                 default:
304                     throw new Exception(&quot;locale not specified properly &quot; + locDetails);
305             }
306         }
307         oldIndex = index + 1;
308         index = key.indexOf(&quot;/&quot;, oldIndex);
309         if (index == -1)
310             index = key.length();
311         resTag = key.substring(oldIndex, index);
312 
313         // TimeZone name may have &quot;/&quot; in it, for example &quot;Asia/Taipei&quot;, so use &quot;Asia\/Taipei in LocaleData.
314         if(resTag.endsWith(&quot;\\&quot;)) {
315             resTag = resTag.substring(0, resTag.length() - 1);
316             oldIndex = index;
317             index = key.indexOf(&quot;/&quot;, oldIndex + 1);
318             if (index == -1) index = key.length();
319             resTag += key.substring(oldIndex, index);
320         }
321 
322         if (index &lt; key.length() - 1)
323             qualifier = key.substring(index + 1);
324         else
325             qualifier = &quot;&quot;;
326 
327         String retrievedValue = null;
328         Object resource = null;
329         try {
330             String fullName = null;
331             if (rbName.equals(&quot;CalendarData&quot;)
332                     || rbName.equals(&quot;CurrencyNames&quot;)
333                     || rbName.equals(&quot;LocaleNames&quot;)
334                     || rbName.equals(&quot;TimeZoneNames&quot;)) {
335                 fullName = UTIL_RESOURCES_PACKAGE + cldrSuffix + &quot;.&quot; + rbName;
336             } else {
337                 fullName = TEXT_RESOURCES_PACKAGE + cldrSuffix + &quot;.&quot; + rbName;
338             }
339             Locale locale;
340             if (use_tag) {
341                 locale = Locale.forLanguageTag(localeName);
342             } else {
343                 locale = new Locale(language, country, variant);
344             }
345             ResourceBundle bundle = LocaleData.getBundle(fullName, locale);
346             resource = bundle.getObject(resTag);
347         }
348         catch (MissingResourceException e) {
349         }
350 
351         if (resource != null) {
352             if (resource instanceof String) {
353                 retrievedValue = (String)resource;
354             }
355             else if (resource instanceof String[]) {
356                 int element = Integer.valueOf(qualifier).intValue();
357                 String[] stringList = (String[])resource;
358                 if (element &gt;= 0 &amp;&amp; element &lt; stringList.length)
359                     retrievedValue = stringList[element];
360             }
361             else if (resource instanceof String[][]) {
362                 String[][] stringArray = (String[][])resource;
363                 int slash = qualifier.indexOf(&quot;/&quot;);
364                 if (slash == -1) {
365                     for (int i = 0; i &lt; stringArray.length; i++) {
366                         if (stringArray[i][0].equals(qualifier))
367                             retrievedValue = stringArray[i][1];
368                     }
369                 }
370                 else {
371                     int row = Integer.valueOf(qualifier.substring(0, slash)).intValue();
372                     int column = Integer.valueOf(qualifier.substring(slash + 1)).intValue();
373                     if (row &gt;= 0 &amp;&amp; row &lt; stringArray.length &amp;&amp; column &gt;= 0 &amp;&amp; column &lt;
374                                     stringArray[row].length)
375                         retrievedValue = stringArray[row][column];
376                 }
377             }
378         }
379 
380         if (retrievedValue == null || !retrievedValue.equals(expectedValue)) {
381             if (retrievedValue == null)
382                 retrievedValue = &quot;&lt;MISSING!&gt;&quot;;
383 
384             if (writeNewFile)
385                 out.println(key + &quot;=&quot; + retrievedValue);
386             else {
387                 out.println(&quot;Mismatch in &quot; + key + &quot;:&quot;);
388                 out.println(&quot;  file = \&quot;&quot; + expectedValue + &quot;\&quot;&quot;);
389                 out.println(&quot;   jvm = \&quot;&quot; + retrievedValue + &quot;\&quot;&quot;);
390             }
391             return false;
392         }
393         else {
394             if (writeNewFile)
395                 out.println(key + &quot;=&quot; + expectedValue);
396         }
397         return true;
398     }
399 }
400 
401 class EscapeReader extends FilterReader {
402     public EscapeReader(Reader in) {
403         super(in);
404     }
405 
406     public int read() throws IOException {
407         if (buffer != null) {
408             String b = buffer.toString();
409             int result = b.charAt(0);
410             if (b.length() &gt; 1)
411                 buffer = new StringBuffer(b.substring(1));
412             else
413                 buffer = null;
414             return result;
415         }
416         else {
417             int result = super.read();
418             if (result != &#39;\\&#39;)
419                 return result;
420             else {
421                 buffer = new StringBuffer();
422                 result = super.read();
423                 buffer.append((char)result);
424                 if (result == &#39;u&#39;) {
425                     for (int i = 0; i &lt; 4; i++) {
426                         result = super.read();
427                         if (result == -1)
428                             break;
429                         buffer.append((char)result);
430                     }
431                     String number = buffer.toString().substring(1);
432                     result = Integer.parseInt(number, 16);
433                     buffer = null;
434                     return result;
435                 }
436                 return &#39;\\&#39;;
437             }
438         }
439     }
440 
441     public int read(char[] cbuf, int start, int len) throws IOException {
442         int p = start;
443         int end = start + len;
444         int c = 0;
445         while (c != -1 &amp;&amp; p &lt; end) {
446             c = read();
447             if (c != -1)
448                 cbuf[p++] = (char)c;
449         }
450         if (c == -1 &amp;&amp; p == start)
451             return -1;
452         else
453             return p - start;
454     }
455 
456     private StringBuffer buffer = null;
457 }
458 
459 class EscapeWriter extends FilterWriter {
460     public EscapeWriter(Writer out) {
461         super(out);
462     }
463 
464     public void write(int c) throws IOException {
465         if ((c &gt;= &#39; &#39; &amp;&amp; c &lt;= &#39;\u007e&#39;) || c == &#39;\r&#39; || c == &#39;\n&#39;)
466             super.write(c);
467         else {
468             super.write(&#39;\\&#39;);
469             super.write(&#39;u&#39;);
470             String number = Integer.toHexString(c);
471             if (number.length() &lt; 4)
472                 number = zeros.substring(0, 4 - number.length()) + number;
473             super.write(number.charAt(0));
474             super.write(number.charAt(1));
475             super.write(number.charAt(2));
476             super.write(number.charAt(3));
477         }
478     }
479 
480     public void write(char[] cbuf, int off, int len) throws IOException {
481         int end = off + len;
482         while (off &lt; end)
483             write(cbuf[off++]);
484     }
485 
486     public void write(String str, int off, int len) throws IOException {
487         int end = off + len;
488         while (off &lt; end)
489             write(str.charAt(off++));
490     }
491 
492     private static String zeros = &quot;0000&quot;;
493 }
    </pre>
  </body>
</html>
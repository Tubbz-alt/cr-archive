<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames test/jdk/sun/security/ssl/DHKeyExchange/DHEKeySizing.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (c) 2013, 2017, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 //
 25 // SunJSSE does not support dynamic system properties, no way to re-use
 26 // system properties in samevm/agentvm mode.
 27 //
 28 
 29 /*
 30  * @test
 31  * @bug 6956398
 32  * @summary make ephemeral DH key match the length of the certificate key
<a name="1" id="anc1"></a><span class="line-modified"> 33  * @run main/othervm -Djdk.tls.client.enableSessionTicketExtension=false</span>
 34  *      DHEKeySizing TLS_DHE_RSA_WITH_AES_128_CBC_SHA  false 1643 267
 35  * @run main/othervm -Djsse.enableFFDHE=false
<a name="2" id="anc2"></a><span class="line-added"> 36  *      -Djdk.tls.client.enableSessionTicketExtension=false</span>
 37  *      DHEKeySizing SSL_DHE_RSA_EXPORT_WITH_DES40_CBC_SHA true 1259 75
 38  * @run main/othervm -Djsse.enableFFDHE=false
 39  *      -Djdk.tls.ephemeralDHKeySize=matched
<a name="3" id="anc3"></a><span class="line-added"> 40  *      -Djdk.tls.client.enableSessionTicketExtension=false</span>
 41  *      DHEKeySizing SSL_DHE_RSA_EXPORT_WITH_DES40_CBC_SHA true 1259 75
 42  * @run main/othervm -Djsse.enableFFDHE=false
 43  *      -Djdk.tls.ephemeralDHKeySize=legacy
<a name="4" id="anc4"></a><span class="line-added"> 44  *      -Djdk.tls.client.enableSessionTicketExtension=false</span>
 45  *      DHEKeySizing SSL_DHE_RSA_EXPORT_WITH_DES40_CBC_SHA true 1259 75
 46  * @run main/othervm -Djsse.enableFFDHE=false
 47  *      -Djdk.tls.ephemeralDHKeySize=1024
<a name="5" id="anc5"></a><span class="line-added"> 48  *      -Djdk.tls.client.enableSessionTicketExtension=false</span>
 49  *      DHEKeySizing SSL_DHE_RSA_EXPORT_WITH_DES40_CBC_SHA true 1259 75
 50  *
 51  * @run main/othervm -Djsse.enableFFDHE=false
<a name="6" id="anc6"></a><span class="line-added"> 52  *      -Djdk.tls.client.enableSessionTicketExtension=false</span>
 53  *      DHEKeySizing SSL_DH_anon_EXPORT_WITH_DES40_CBC_SHA true 233 75
 54  *
 55  * @run main/othervm -Djsse.enableFFDHE=false
<a name="7" id="anc7"></a><span class="line-added"> 56  *      -Djdk.tls.client.enableSessionTicketExtension=false</span>
 57  *      DHEKeySizing TLS_DHE_RSA_WITH_AES_128_CBC_SHA  false 1387 139
 58  * @run main/othervm -Djsse.enableFFDHE=false
 59  *      -Djdk.tls.ephemeralDHKeySize=legacy
<a name="8" id="anc8"></a><span class="line-added"> 60  *      -Djdk.tls.client.enableSessionTicketExtension=false</span>
 61  *      DHEKeySizing TLS_DHE_RSA_WITH_AES_128_CBC_SHA  false 1323 107
 62  * @run main/othervm -Djsse.enableFFDHE=false
 63  *      -Djdk.tls.ephemeralDHKeySize=matched
<a name="9" id="anc9"></a><span class="line-added"> 64  *      -Djdk.tls.client.enableSessionTicketExtension=false</span>
 65  *      DHEKeySizing TLS_DHE_RSA_WITH_AES_128_CBC_SHA  false 1643 267
 66  * @run main/othervm -Djsse.enableFFDHE=false
 67  *      -Djdk.tls.ephemeralDHKeySize=1024
<a name="10" id="anc10"></a><span class="line-added"> 68  *      -Djdk.tls.client.enableSessionTicketExtension=false</span>
 69  *      DHEKeySizing TLS_DHE_RSA_WITH_AES_128_CBC_SHA  false 1387 139
 70  *
 71  * @run main/othervm -Djsse.enableFFDHE=false
<a name="11" id="anc11"></a><span class="line-added"> 72  *      -Djdk.tls.client.enableSessionTicketExtension=false</span>
 73  *      DHEKeySizing SSL_DH_anon_WITH_RC4_128_MD5  false 361 139
 74  * @run main/othervm -Djsse.enableFFDHE=false
<a name="12" id="anc12"></a><span class="line-added"> 75  *      -Djdk.tls.client.enableSessionTicketExtension=false</span>
 76  *      -Djdk.tls.ephemeralDHKeySize=legacy
 77  *      DHEKeySizing SSL_DH_anon_WITH_RC4_128_MD5  false 297 107
 78  * @run main/othervm -Djsse.enableFFDHE=false
<a name="13" id="anc13"></a><span class="line-added"> 79  *      -Djdk.tls.client.enableSessionTicketExtension=false</span>
 80  *      -Djdk.tls.ephemeralDHKeySize=matched
 81  *      DHEKeySizing SSL_DH_anon_WITH_RC4_128_MD5  false 361 139
 82  * @run main/othervm -Djsse.enableFFDHE=false
<a name="14" id="anc14"></a><span class="line-added"> 83  *      -Djdk.tls.client.enableSessionTicketExtension=false</span>
 84  *      -Djdk.tls.ephemeralDHKeySize=1024
 85  *      DHEKeySizing SSL_DH_anon_WITH_RC4_128_MD5  false 361 139
 86  */
 87 
 88 /*
 89  * This is a simple hack to test key sizes of Diffie-Hellman key exchanging
 90  * during SSL/TLS handshaking.
 91  *
 92  * The record length of DH ServerKeyExchange and ClientKeyExchange.
 93  * ServerKeyExchange message are wrapped in ServerHello series messages, which
 94  * contains ServerHello, Certificate and ServerKeyExchange message.
 95  *
 96  *    struct {
 97  *        opaque dh_p&lt;1..2^16-1&gt;;
 98  *        opaque dh_g&lt;1..2^16-1&gt;;
 99  *        opaque dh_Ys&lt;1..2^16-1&gt;;
100  *    } ServerDHParams;     // Ephemeral DH parameters
101  *
102  *    struct {
103  *        select (PublicValueEncoding) {
104  *            case implicit: struct { };
105  *            case explicit: opaque dh_Yc&lt;1..2^16-1&gt;;
106  *        } dh_public;
107  *    } ClientDiffieHellmanPublic;
108  *
109  * Fomr above structures, it is clear that if the DH key size increasing 128
110  * bits (16 bytes), the ServerHello series messages increases 48 bytes
111  * (becuase dh_p, dh_g and dh_Ys each increase 16 bytes) and ClientKeyExchange
112  * increases 16 bytes (because of the size increasing of dh_Yc).
113  *
114  * Here is a summary of the record length in the test case.
115  *
116  *            |  ServerHello Series  |  ClientKeyExchange | ServerHello Anon
117  *   512-bit  |          1259 bytes  |           75 bytes |        233 bytes
118  *   768-bit  |          1323 bytes  |          107 bytes |        297 bytes
119  *  1024-bit  |          1387 bytes  |          139 bytes |        361 bytes
120  *  2048-bit  |          1643 bytes  |          267 bytes |        361 bytes
121  */
122 
123 import javax.net.ssl.*;
124 import javax.net.ssl.SSLEngineResult.*;
125 import java.io.*;
126 import java.nio.*;
127 import java.security.KeyStore;
128 import java.security.KeyFactory;
129 import java.security.Security;
130 import java.security.cert.Certificate;
131 import java.security.cert.CertificateFactory;
132 import java.security.spec.PKCS8EncodedKeySpec;
133 import java.security.interfaces.*;
134 import java.util.Base64;
135 
136 public class DHEKeySizing {
137 
138     private final static boolean debug = true;
139 
140     // key length bias because of the stripping of leading zero bytes of
141     // negotiated DH keys.
142     //
143     // This is an effort to mimum intermittent failure when we cannot
144     // estimate what&#39;s the exact number of leading zero bytes of
145     // negotiated DH keys.
146     private final static int KEY_LEN_BIAS = 6;
147 
148     private SSLContext sslc;
149     private SSLEngine ssle1;    // client
150     private SSLEngine ssle2;    // server
151 
152     private ByteBuffer appOut1;         // write side of ssle1
153     private ByteBuffer appIn1;          // read side of ssle1
154     private ByteBuffer appOut2;         // write side of ssle2
155     private ByteBuffer appIn2;          // read side of ssle2
156 
157     private ByteBuffer oneToTwo;        // &quot;reliable&quot; transport ssle1-&gt;ssle2
158     private ByteBuffer twoToOne;        // &quot;reliable&quot; transport ssle2-&gt;ssle1
159 
160     /*
161      * Where do we find the keystores?
162      */
163     // Certificates and key used in the test.
164     static String trustedCertStr =
165         &quot;-----BEGIN CERTIFICATE-----\n&quot; +
166         &quot;MIIC8jCCAdqgAwIBAgIEUjkuRzANBgkqhkiG9w0BAQUFADA7MR0wGwYDVQQLExRT\n&quot; +
167         &quot;dW5KU1NFIFRlc3QgU2VyaXZjZTENMAsGA1UEChMESmF2YTELMAkGA1UEBhMCVVMw\n&quot; +
168         &quot;HhcNMTMwOTE4MDQzODMxWhcNMTMxMjE3MDQzODMxWjA7MR0wGwYDVQQLExRTdW5K\n&quot; +
169         &quot;U1NFIFRlc3QgU2VyaXZjZTENMAsGA1UEChMESmF2YTELMAkGA1UEBhMCVVMwggEi\n&quot; +
170         &quot;MA0GCSqGSIb3DQEBAQUAA4IBDwAwggEKAoIBAQCO+IGeaskJAvEcYc7pCl9neK3E\n&quot; +
171         &quot;a28fwWLtChufYNaC9hQfZlUdETWYjV7fZJVJKT/oLzdDNMWuVA0LKXArpI3thLNK\n&quot; +
172         &quot;QLXisdF9hKPlZRDazACL9kWUUtJ0FzpEySK4e8wW/z9FuU6e6iO19FbjxAfInJqk\n&quot; +
173         &quot;3EDiEhB5g73S2vtvPCxgq2DvWw9TDl/LIqdKG2JCS93koXCCaHmQ7MrIOqHPd+8r\n&quot; +
174         &quot;RbGpatXT9qyHKppUv9ATxVygO4rA794mgCFxpT+fkhz+NEB0twTkM65T1hnnOv5n\n&quot; +
175         &quot;ZIxkcjBggt85UlZtnP3b9P7SYxsWIa46Oc38Od2f3YejfVg6B+PqPgWNl3+/AgMB\n&quot; +
176         &quot;AAEwDQYJKoZIhvcNAQEFBQADggEBAAlrP6DFLRPSy0IgQhcI2i56tR/na8pezSte\n&quot; +
177         &quot;ZHcCdaCZPDy4UP8mpLJ9QCjEB5VJv8hPm4xdK7ULnKGOGHgYqDpV2ZHvQlhV1woQ\n&quot; +
178         &quot;TZGb/LM3c6kAs0j4j9KM2fq3iYUYexjIkS1KzsziflxMM6igS9BRMBR2LQyU+cYq\n&quot; +
179         &quot;YEsFzkF7Aj2ET4v/+tgot9mRr2NioJcaJkdsPDpMU3IKB1cczfu+OuLQ/GCG0Fqu\n&quot; +
180         &quot;6ijCeCqfnaAbemHbJeVZZ6Qgka3uC2YMntLBmLkhqEo1d9zGYLoh7oWL77y5ibQZ\n&quot; +
181         &quot;LK5/H/zikcu579TWjlDHcqL3arCwBcrtsjSaPrRSWMrWV/6c0qw=\n&quot; +
182         &quot;-----END CERTIFICATE-----&quot;;
183 
184     // Private key in the format of PKCS#8
185     static String targetPrivateKey =
186         &quot;MIIEvQIBADANBgkqhkiG9w0BAQEFAASCBKcwggSjAgEAAoIBAQCO+IGeaskJAvEc\n&quot; +
187         &quot;Yc7pCl9neK3Ea28fwWLtChufYNaC9hQfZlUdETWYjV7fZJVJKT/oLzdDNMWuVA0L\n&quot; +
188         &quot;KXArpI3thLNKQLXisdF9hKPlZRDazACL9kWUUtJ0FzpEySK4e8wW/z9FuU6e6iO1\n&quot; +
189         &quot;9FbjxAfInJqk3EDiEhB5g73S2vtvPCxgq2DvWw9TDl/LIqdKG2JCS93koXCCaHmQ\n&quot; +
190         &quot;7MrIOqHPd+8rRbGpatXT9qyHKppUv9ATxVygO4rA794mgCFxpT+fkhz+NEB0twTk\n&quot; +
191         &quot;M65T1hnnOv5nZIxkcjBggt85UlZtnP3b9P7SYxsWIa46Oc38Od2f3YejfVg6B+Pq\n&quot; +
192         &quot;PgWNl3+/AgMBAAECggEAPdb5Ycc4m4A9QBSCRcRpzbyiFLKPh0HDg1n65q4hOtYr\n&quot; +
193         &quot;kAVYTVFTSF/lqGS+Ob3w2YIKujQKSUQrvCc5UHdFuHXMgxKIWbymK0+DAMb9SlYw\n&quot; +
194         &quot;6lkkcWp9gx9E4dnJ/df2SAAxovvrKMuHlL1SFASHhVtPfH2URvSfUaANLDXxyYOs\n&quot; +
195         &quot;8BX0Nr6wazhWjLjXo9yIGnKSvFfB8XisYcA78kEgas43zhmIGCDPqaYyyffOfRbx\n&quot; +
196         &quot;pM1KNwGmlN86iWR1CbwA/wwhcMySWQueS+s7cHbpRqZIYJF9jEeELiwi0vxjealS\n&quot; +
197         &quot;EMuHYedIRFMWaDIq9XyjrvXamHb0Z25jlXBNZHaM0QKBgQDE9adl+zAezR/n79vw\n&quot; +
198         &quot;0XiX2Fx1UEo3ApZHuoA2Q/PcBk+rlKqqQ3IwTcy6Wo648wK7v6Nq7w5nEWcsf0dU\n&quot; +
199         &quot;QA2Ng/AJEev/IfF34x7sKGYxtk1gcE0EuSBA3R+ocEZxnNw1Ryd5nUU24s8d4jCP\n&quot; +
200         &quot;Mkothnyaim+zE2raDlEtVc0CaQKBgQC509av+02Uq5oMjzbQp5PBJfQFjATOQT15\n&quot; +
201         &quot;eefYnVYurkQ1kcVfixkrO2ORhg4SjmI2Z5hJDgGtXdwgidpzkad+R2epS5qLMyno\n&quot; +
202         &quot;lQVpY6bMpEZ7Mos0yQygxnm8uNohEcTExOe+nP5fNJVpzBsGmfeyYOhnPQlf6oqf\n&quot; +
203         &quot;0cHizedb5wKBgQC/l5LyMil6HOGHlhzmIm3jj7VI7QR0hJC5T6N+phVml8ESUDjA\n&quot; +
204         &quot;DYHbmSKouISTRtkG14FY+RiSjCxH7bvuKazFV2289PETquogTA/9e8MFYqfcQwG4\n&quot; +
205         &quot;sXi9gBxWlnj/9a2EKiYtOB5nKLR/BlNkSHA93tAA6N+FXEMZwMmYhxk42QKBgAuY\n&quot; +
206         &quot;HQgD3PZOsqDf+qKQIhbmAFCsSMx5o5VFtuJ8BpmJA/Z3ruHkMuDQpsi4nX4o5hXQ\n&quot; +
207         &quot;5t6AAjjH52kcUMXvK40kdWJJtk3DFnVNfvXxYsHX6hHbuHXFqYUKfSP6QJnZmvZP\n&quot; +
208         &quot;9smcz/4usLfWJUWHK740b6upUkFqx9Vq5/b3s9y3AoGAdM5TW7LkkOFsdMGVAUzR\n&quot; +
209         &quot;9iXmCWElHTK2Pcp/3yqDBHSfiQx6Yp5ANyPnE9NBM0yauCfOyBB2oxLO4Rdv3Rqk\n&quot; +
210         &quot;9V9kyR/YAGr7dJaPcQ7pZX0OpkzgueAOJYPrx5VUzPYUtklYV1ycFZTfKlpFCxT+\n&quot; +
211         &quot;Ei6KUo0NXSdUIcB4yib1J10=&quot;;
212 
213     static char passphrase[] = &quot;passphrase&quot;.toCharArray();
214 
215     /*
216      * Majority of the test case is here, setup is done below.
217      */
218 
219     private void createSSLEngines() throws Exception {
220         ssle1 = sslc.createSSLEngine(&quot;client&quot;, 1);
221         ssle1.setUseClientMode(true);
222 
223         ssle2 = sslc.createSSLEngine(&quot;server&quot;, 2);
224         ssle2.setUseClientMode(false);
225     }
226 
227     private boolean isHandshaking(SSLEngine e) {
228         return (e.getHandshakeStatus() != HandshakeStatus.NOT_HANDSHAKING);
229     }
230 
231     private void checkResult(ByteBuffer bbIn, ByteBuffer bbOut,
232             SSLEngineResult result,
233             Status status, HandshakeStatus hsStatus,
234             int consumed, int produced)
235             throws Exception {
236 
237         if ((status != null) &amp;&amp; (result.getStatus() != status)) {
238             throw new Exception(&quot;Unexpected Status: need = &quot; + status +
239                 &quot; got = &quot; + result.getStatus());
240         }
241 
242         if ((hsStatus != null) &amp;&amp; (result.getHandshakeStatus() != hsStatus)) {
243             throw new Exception(&quot;Unexpected hsStatus: need = &quot; + hsStatus +
244                 &quot; got = &quot; + result.getHandshakeStatus());
245         }
246 
247         if ((consumed != -1) &amp;&amp; (consumed != result.bytesConsumed())) {
248             throw new Exception(&quot;Unexpected consumed: need = &quot; + consumed +
249                 &quot; got = &quot; + result.bytesConsumed());
250         }
251 
252         if ((produced != -1) &amp;&amp; (produced != result.bytesProduced())) {
253             throw new Exception(&quot;Unexpected produced: need = &quot; + produced +
254                 &quot; got = &quot; + result.bytesProduced());
255         }
256 
257         if ((consumed != -1) &amp;&amp; (bbIn.position() != result.bytesConsumed())) {
258             throw new Exception(&quot;Consumed &quot; + bbIn.position() +
259                 &quot; != &quot; + consumed);
260         }
261 
262         if ((produced != -1) &amp;&amp; (bbOut.position() != result.bytesProduced())) {
263             throw new Exception(&quot;produced &quot; + bbOut.position() +
264                 &quot; != &quot; + produced);
265         }
266     }
267 
268     private void test(String cipherSuite, boolean exportable,
269             int lenServerKeyEx, int lenClientKeyEx) throws Exception {
270 
271         createSSLEngines();
272         createBuffers();
273 
274         SSLEngineResult result1;        // ssle1&#39;s results from last operation
275         SSLEngineResult result2;        // ssle2&#39;s results from last operation
276 
277         String[] suites = new String [] {cipherSuite};
278 
279         ssle1.setEnabledCipherSuites(suites);
280         ssle2.setEnabledCipherSuites(suites);
281 
282         log(&quot;======================================&quot;);
283         log(&quot;===================&quot;);
284         log(&quot;client hello&quot;);
285         result1 = ssle1.wrap(appOut1, oneToTwo);
286         checkResult(appOut1, oneToTwo, result1,
287             Status.OK, HandshakeStatus.NEED_UNWRAP, 0, -1);
288         oneToTwo.flip();
289 
290         result2 = ssle2.unwrap(oneToTwo, appIn2);
291         checkResult(oneToTwo, appIn2, result2,
292             Status.OK, HandshakeStatus.NEED_TASK, result1.bytesProduced(), 0);
293         runDelegatedTasks(ssle2);
294         oneToTwo.compact();
295 
296         log(&quot;===================&quot;);
297         log(&quot;ServerHello&quot;);
298         result2 = ssle2.wrap(appOut2, twoToOne);
299         checkResult(appOut2, twoToOne, result2,
300             Status.OK, HandshakeStatus.NEED_UNWRAP, 0, -1);
301         twoToOne.flip();
302 
303         log(&quot;Message length of ServerHello series: &quot; + twoToOne.remaining());
304         if (twoToOne.remaining() &lt; (lenServerKeyEx - KEY_LEN_BIAS) ||
305                 twoToOne.remaining() &gt; lenServerKeyEx) {
306             throw new Exception(
307                 &quot;Expected to generate ServerHello series messages of &quot; +
308                 lenServerKeyEx + &quot; bytes, but not &quot; + twoToOne.remaining());
309         }
310 
311         result1 = ssle1.unwrap(twoToOne, appIn1);
312         checkResult(twoToOne, appIn1, result1,
313             Status.OK, HandshakeStatus.NEED_TASK, result2.bytesProduced(), 0);
314         runDelegatedTasks(ssle1);
315         twoToOne.compact();
316 
317         log(&quot;===================&quot;);
318         log(&quot;Key Exchange&quot;);
319         result1 = ssle1.wrap(appOut1, oneToTwo);
320         checkResult(appOut1, oneToTwo, result1,
321             Status.OK, HandshakeStatus.NEED_WRAP, 0, -1);
322         oneToTwo.flip();
323 
324         log(&quot;Message length of ClientKeyExchange: &quot; + oneToTwo.remaining());
325         if (oneToTwo.remaining() &lt; (lenClientKeyEx - KEY_LEN_BIAS) ||
326                 oneToTwo.remaining() &gt; lenClientKeyEx) {
327             throw new Exception(
328                 &quot;Expected to generate ClientKeyExchange message of &quot; +
329                 lenClientKeyEx + &quot; bytes, but not &quot; + oneToTwo.remaining());
330         }
331         result2 = ssle2.unwrap(oneToTwo, appIn2);
332         checkResult(oneToTwo, appIn2, result2,
333             Status.OK, HandshakeStatus.NEED_TASK, result1.bytesProduced(), 0);
334         runDelegatedTasks(ssle2);
335         oneToTwo.compact();
336 
337         log(&quot;===================&quot;);
338         log(&quot;Client CCS&quot;);
339         result1 = ssle1.wrap(appOut1, oneToTwo);
340         checkResult(appOut1, oneToTwo, result1,
341             Status.OK, HandshakeStatus.NEED_WRAP, 0, -1);
342         oneToTwo.flip();
343 
344         result2 = ssle2.unwrap(oneToTwo, appIn2);
345         checkResult(oneToTwo, appIn2, result2,
346             Status.OK, HandshakeStatus.NEED_UNWRAP,
347             result1.bytesProduced(), 0);
348         oneToTwo.compact();
349 
350         log(&quot;===================&quot;);
351         log(&quot;Client Finished&quot;);
352         result1 = ssle1.wrap(appOut1, oneToTwo);
353         checkResult(appOut1, oneToTwo, result1,
354             Status.OK, HandshakeStatus.NEED_UNWRAP, 0, -1);
355         oneToTwo.flip();
356 
357         result2 = ssle2.unwrap(oneToTwo, appIn2);
358         checkResult(oneToTwo, appIn2, result2,
359             Status.OK, HandshakeStatus.NEED_WRAP,
360             result1.bytesProduced(), 0);
361         oneToTwo.compact();
362 
363         log(&quot;===================&quot;);
364         log(&quot;Server CCS&quot;);
365         result2 = ssle2.wrap(appOut2, twoToOne);
366         checkResult(appOut2, twoToOne, result2,
367             Status.OK, HandshakeStatus.NEED_WRAP, 0, -1);
368         twoToOne.flip();
369 
370         result1 = ssle1.unwrap(twoToOne, appIn1);
371         checkResult(twoToOne, appIn1, result1,
372             Status.OK, HandshakeStatus.NEED_UNWRAP, result2.bytesProduced(), 0);
373         twoToOne.compact();
374 
375         log(&quot;===================&quot;);
376         log(&quot;Server Finished&quot;);
377         result2 = ssle2.wrap(appOut2, twoToOne);
378         checkResult(appOut2, twoToOne, result2,
379             Status.OK, HandshakeStatus.FINISHED, 0, -1);
380         twoToOne.flip();
381 
382         result1 = ssle1.unwrap(twoToOne, appIn1);
383         checkResult(twoToOne, appIn1, result1,
384             Status.OK, HandshakeStatus.FINISHED, result2.bytesProduced(), 0);
385         twoToOne.compact();
386 
387         log(&quot;===================&quot;);
388         log(&quot;Check Session/Ciphers&quot;);
389         String cs = ssle1.getSession().getCipherSuite();
390         if (!cs.equals(suites[0])) {
391             throw new Exception(&quot;suites not equal: &quot; + cs + &quot;/&quot; + suites[0]);
392         }
393 
394         cs = ssle2.getSession().getCipherSuite();
395         if (!cs.equals(suites[0])) {
396             throw new Exception(&quot;suites not equal: &quot; + cs + &quot;/&quot; + suites[0]);
397         }
398 
399         log(&quot;===================&quot;);
400         log(&quot;Done with SSL/TLS handshaking&quot;);
401     }
402 
403     public static void main(String args[]) throws Exception {
404         // reset security properties to make sure that the algorithms
405         // and keys used in this test are not disabled.
406         Security.setProperty(&quot;jdk.tls.disabledAlgorithms&quot;, &quot;&quot;);
407         Security.setProperty(&quot;jdk.certpath.disabledAlgorithms&quot;, &quot;&quot;);
408 
409         if (args.length != 4) {
410             System.out.println(
411                 &quot;Usage: java DHEKeySizing cipher-suite &quot; +
412                 &quot;exportable(true|false)\n&quot; +
413                 &quot;    size-of-server-hello-record size-of-client-key-exchange&quot;);
414             throw new Exception(&quot;Incorrect usage!&quot;);
415         }
416 
417         (new DHEKeySizing()).test(args[0],
418                 Boolean.parseBoolean(args[1]),
419                 Integer.parseInt(args[2]),
420                 Integer.parseInt(args[3]));
421         System.out.println(&quot;Test Passed.&quot;);
422     }
423 
424     /*
425      * **********************************************************
426      * Majority of the test case is above, below is just setup stuff
427      * **********************************************************
428      */
429 
430     public DHEKeySizing() throws Exception {
431         sslc = getSSLContext();
432     }
433 
434     /*
435      * Create an initialized SSLContext to use for this test.
436      */
437     private SSLContext getSSLContext() throws Exception {
438 
439         // generate certificate from cert string
440         CertificateFactory cf = CertificateFactory.getInstance(&quot;X.509&quot;);
441 
442         // create a key store
443         KeyStore ts = KeyStore.getInstance(&quot;JKS&quot;);
444         KeyStore ks = KeyStore.getInstance(&quot;JKS&quot;);
445         ts.load(null, null);
446         ks.load(null, null);
447 
448         // import the trused cert
449         ByteArrayInputStream is =
450                     new ByteArrayInputStream(trustedCertStr.getBytes());
451         Certificate trusedCert = cf.generateCertificate(is);
452         is.close();
453         ts.setCertificateEntry(&quot;rsa-trusted-2048&quot;, trusedCert);
454 
455         // generate the private key.
456         String keySpecStr = targetPrivateKey;
457         PKCS8EncodedKeySpec priKeySpec = new PKCS8EncodedKeySpec(
458                             Base64.getMimeDecoder().decode(keySpecStr));
459         KeyFactory kf = KeyFactory.getInstance(&quot;RSA&quot;);
460         RSAPrivateKey priKey = (RSAPrivateKey)kf.generatePrivate(priKeySpec);
461 
462         Certificate[] chain = new Certificate[1];
463         chain[0] = trusedCert;
464 
465         // import the key entry.
466         ks.setKeyEntry(&quot;rsa-key-2048&quot;, priKey, passphrase, chain);
467 
468         // create SSL context
469         KeyManagerFactory kmf = KeyManagerFactory.getInstance(&quot;SunX509&quot;);
470         kmf.init(ks, passphrase);
471 
472         TrustManagerFactory tmf = TrustManagerFactory.getInstance(&quot;SunX509&quot;);
473         tmf.init(ts);
474 
475         SSLContext sslCtx = SSLContext.getInstance(&quot;TLSv1&quot;);
476         sslCtx.init(kmf.getKeyManagers(), tmf.getTrustManagers(), null);
477 
478         return sslCtx;
479     }
480 
481     private void createBuffers() {
482         // Size the buffers as appropriate.
483 
484         SSLSession session = ssle1.getSession();
485         int appBufferMax = session.getApplicationBufferSize();
486         int netBufferMax = session.getPacketBufferSize();
487 
488         appIn1 = ByteBuffer.allocateDirect(appBufferMax + 50);
489         appIn2 = ByteBuffer.allocateDirect(appBufferMax + 50);
490 
491         oneToTwo = ByteBuffer.allocateDirect(netBufferMax);
492         twoToOne = ByteBuffer.allocateDirect(netBufferMax);
493 
494         appOut1 = ByteBuffer.wrap(&quot;Hi Engine2, I&#39;m SSLEngine1&quot;.getBytes());
495         appOut2 = ByteBuffer.wrap(&quot;Hello Engine1, I&#39;m SSLEngine2&quot;.getBytes());
496 
497         log(&quot;AppOut1 = &quot; + appOut1);
498         log(&quot;AppOut2 = &quot; + appOut2);
499         log(&quot;&quot;);
500     }
501 
502     private static void runDelegatedTasks(SSLEngine engine) throws Exception {
503 
504         Runnable runnable;
505         while ((runnable = engine.getDelegatedTask()) != null) {
506             log(&quot;running delegated task...&quot;);
507             runnable.run();
508         }
509     }
510 
511     private static void log(String str) {
512         if (debug) {
513             System.out.println(str);
514         }
515     }
516 }
<a name="15" id="anc15"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="15" type="hidden" />
</body>
</html>
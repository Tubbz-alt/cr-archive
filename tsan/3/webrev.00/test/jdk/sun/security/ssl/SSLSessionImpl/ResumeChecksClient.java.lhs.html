<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames test/jdk/sun/security/ssl/SSLSessionImpl/ResumeChecksClient.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
<a name="1" id="anc1"></a><span class="line-modified">  2  * Copyright (c) 2018, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 /*
 25  * @test
 26  * @bug 8206929 8212885
 27  * @summary ensure that client only resumes a session if certain properties
 28  *    of the session are compatible with the new connection
<a name="2" id="anc2"></a><span class="line-modified"> 29  * @run main/othervm -Djdk.tls.client.protocols=TLSv1.2 ResumeChecksClient BASIC</span>
<span class="line-modified"> 30  * @run main/othervm -Djdk.tls.client.protocols=TLSv1.3 ResumeChecksClient BASIC</span>
<span class="line-modified"> 31  * @run main/othervm ResumeChecksClient BASIC</span>
<span class="line-modified"> 32  * @run main/othervm ResumeChecksClient VERSION_2_TO_3</span>
<span class="line-modified"> 33  * @run main/othervm ResumeChecksClient VERSION_3_TO_2</span>
<span class="line-modified"> 34  * @run main/othervm -Djdk.tls.client.protocols=TLSv1.3 ResumeChecksClient CIPHER_SUITE</span>
<span class="line-modified"> 35  * @run main/othervm -Djdk.tls.client.protocols=TLSv1.3 ResumeChecksClient SIGNATURE_SCHEME</span>




 36  *
 37  */
 38 
 39 import javax.net.*;
 40 import javax.net.ssl.*;
 41 import java.io.*;
 42 import java.security.*;
 43 import java.net.*;
 44 import java.util.*;
 45 
 46 public class ResumeChecksClient {
 47 
 48     static String pathToStores = &quot;../../../../javax/net/ssl/etc&quot;;
 49     static String keyStoreFile = &quot;keystore&quot;;
 50     static String trustStoreFile = &quot;truststore&quot;;
 51     static String passwd = &quot;passphrase&quot;;
 52 
 53     enum TestMode {
 54         BASIC,
 55         VERSION_2_TO_3,
 56         VERSION_3_TO_2,
 57         CIPHER_SUITE,
 58         SIGNATURE_SCHEME
 59     }
 60 
 61     public static void main(String[] args) throws Exception {
 62 
 63         TestMode mode = TestMode.valueOf(args[0]);
 64 
 65         String keyFilename =
 66             System.getProperty(&quot;test.src&quot;, &quot;./&quot;) + &quot;/&quot; + pathToStores +
 67                 &quot;/&quot; + keyStoreFile;
 68         String trustFilename =
 69             System.getProperty(&quot;test.src&quot;, &quot;./&quot;) + &quot;/&quot; + pathToStores +
 70                 &quot;/&quot; + trustStoreFile;
 71 
 72         System.setProperty(&quot;javax.net.ssl.keyStore&quot;, keyFilename);
 73         System.setProperty(&quot;javax.net.ssl.keyStorePassword&quot;, passwd);
 74         System.setProperty(&quot;javax.net.ssl.trustStore&quot;, trustFilename);
 75         System.setProperty(&quot;javax.net.ssl.trustStorePassword&quot;, passwd);
 76 
 77         Server server = startServer();
 78         server.signal();
 79         SSLContext sslContext = SSLContext.getDefault();
 80         while (!server.started) {
 81             Thread.yield();
 82         }
 83         SSLSession firstSession = connect(sslContext, server.port, mode, false);
 84 
 85         server.signal();
 86         long secondStartTime = System.currentTimeMillis();
 87         Thread.sleep(10);
 88         SSLSession secondSession = connect(sslContext, server.port, mode, true);
 89 
 90         server.go = false;
 91         server.signal();
 92 
 93         switch (mode) {
 94         case BASIC:
 95             // fail if session is not resumed
 96             checkResumedSession(firstSession, secondSession);
 97             break;
 98         case VERSION_2_TO_3:
 99         case VERSION_3_TO_2:
100         case CIPHER_SUITE:
101         case SIGNATURE_SCHEME:
102             // fail if a new session is not created
103             if (secondSession.getCreationTime() &lt;= secondStartTime) {
104                 throw new RuntimeException(&quot;Existing session was used&quot;);
105             }
106             break;
107         default:
108             throw new RuntimeException(&quot;unknown mode: &quot; + mode);
109         }
110     }
111 
112     private static class NoSig implements AlgorithmConstraints {
113 
114         private final String alg;
115 
116         NoSig(String alg) {
117             this.alg = alg;
118         }
119 
120 
121         private boolean test(String a) {
122             return !a.toLowerCase().contains(alg.toLowerCase());
123         }
124 
125         @Override
126         public boolean permits(Set&lt;CryptoPrimitive&gt; primitives, Key key) {
127             return true;
128         }
129         @Override
130         public boolean permits(Set&lt;CryptoPrimitive&gt; primitives,
131             String algorithm, AlgorithmParameters parameters) {
132 
133             return test(algorithm);
134         }
135         @Override
136         public boolean permits(Set&lt;CryptoPrimitive&gt; primitives,
137             String algorithm, Key key, AlgorithmParameters parameters) {
138 
139             return test(algorithm);
140         }
141     }
142 
143     private static SSLSession connect(SSLContext sslContext, int port,
144         TestMode mode, boolean second) {
145 
146         try {
147             SSLSocket sock = (SSLSocket)
148                 sslContext.getSocketFactory().createSocket();
149             SSLParameters params = sock.getSSLParameters();
150 
151             switch (mode) {
152             case BASIC:
153                 // do nothing to ensure resumption works
154                 break;
155             case VERSION_2_TO_3:
156                 if (second) {
157                     params.setProtocols(new String[] {&quot;TLSv1.3&quot;});
158                 } else {
159                     params.setProtocols(new String[] {&quot;TLSv1.2&quot;});
160                 }
161                 break;
162             case VERSION_3_TO_2:
163                 if (second) {
164                     params.setProtocols(new String[] {&quot;TLSv1.2&quot;});
165                 } else {
166                     params.setProtocols(new String[] {&quot;TLSv1.3&quot;});
167                 }
168                 break;
169             case CIPHER_SUITE:
170                 if (second) {
171                     params.setCipherSuites(
172                         new String[] {&quot;TLS_AES_256_GCM_SHA384&quot;});
173                 } else {
174                     params.setCipherSuites(
175                         new String[] {&quot;TLS_AES_128_GCM_SHA256&quot;});
176                 }
177                 break;
178             case SIGNATURE_SCHEME:
179                 AlgorithmConstraints constraints =
180                     params.getAlgorithmConstraints();
181                 if (second) {
182                     params.setAlgorithmConstraints(new NoSig(&quot;ecdsa&quot;));
183                 } else {
184                     params.setAlgorithmConstraints(new NoSig(&quot;rsa&quot;));
185                 }
186                 break;
187             default:
188                 throw new RuntimeException(&quot;unknown mode: &quot; + mode);
189             }
190             sock.setSSLParameters(params);
191             sock.connect(new InetSocketAddress(&quot;localhost&quot;, port));
192             PrintWriter out = new PrintWriter(
193                 new OutputStreamWriter(sock.getOutputStream()));
194             out.println(&quot;message&quot;);
195             out.flush();
196             BufferedReader reader = new BufferedReader(
197                 new InputStreamReader(sock.getInputStream()));
198             String inMsg = reader.readLine();
199             System.out.println(&quot;Client received: &quot; + inMsg);
200             SSLSession result = sock.getSession();
201             sock.close();
202             return result;
203         } catch (Exception ex) {
204             // unexpected exception
205             throw new RuntimeException(ex);
206         }
207     }
208 
209     private static void checkResumedSession(SSLSession initSession,
210             SSLSession resSession) throws Exception {
211         StringBuilder diffLog = new StringBuilder();
212 
213         // Initial and resumed SSLSessions should have the same creation
214         // times so they get invalidated together.
215         long initCt = initSession.getCreationTime();
216         long resumeCt = resSession.getCreationTime();
217         if (initCt != resumeCt) {
218             diffLog.append(&quot;Session creation time is different. Initial: &quot;).
219                     append(initCt).append(&quot;, Resumed: &quot;).append(resumeCt).
220                     append(&quot;\n&quot;);
221         }
222 
223         // Ensure that peer and local certificate lists are preserved
224         if (!Arrays.equals(initSession.getLocalCertificates(),
225                 resSession.getLocalCertificates())) {
226             diffLog.append(&quot;Local certificate mismatch between initial &quot; +
227                     &quot;and resumed sessions\n&quot;);
228         }
229 
230         if (!Arrays.equals(initSession.getPeerCertificates(),
231                 resSession.getPeerCertificates())) {
232             diffLog.append(&quot;Peer certificate mismatch between initial &quot; +
233                     &quot;and resumed sessions\n&quot;);
234         }
235 
236         // Buffer sizes should also be the same
237         if (initSession.getApplicationBufferSize() !=
238                 resSession.getApplicationBufferSize()) {
239             diffLog.append(String.format(
240                     &quot;App Buffer sizes differ: Init: %d, Res: %d\n&quot;,
241                     initSession.getApplicationBufferSize(),
242                     resSession.getApplicationBufferSize()));
243         }
244 
245         if (initSession.getPacketBufferSize() !=
246                 resSession.getPacketBufferSize()) {
247             diffLog.append(String.format(
248                     &quot;Packet Buffer sizes differ: Init: %d, Res: %d\n&quot;,
249                     initSession.getPacketBufferSize(),
250                     resSession.getPacketBufferSize()));
251         }
252 
253         // Cipher suite should match
254         if (!initSession.getCipherSuite().equals(
255                 resSession.getCipherSuite())) {
256             diffLog.append(String.format(
257                     &quot;CipherSuite does not match - Init: %s, Res: %s\n&quot;,
258                     initSession.getCipherSuite(), resSession.getCipherSuite()));
259         }
260 
261         // Peer host/port should match
262         if (!initSession.getPeerHost().equals(resSession.getPeerHost()) ||
263                 initSession.getPeerPort() != resSession.getPeerPort()) {
264             diffLog.append(String.format(
265                     &quot;Host/Port mismatch - Init: %s/%d, Res: %s/%d\n&quot;,
266                     initSession.getPeerHost(), initSession.getPeerPort(),
267                     resSession.getPeerHost(), resSession.getPeerPort()));
268         }
269 
270         // Check protocol
271         if (!initSession.getProtocol().equals(resSession.getProtocol())) {
272             diffLog.append(String.format(
273                     &quot;Protocol mismatch - Init: %s, Res: %s\n&quot;,
274                     initSession.getProtocol(), resSession.getProtocol()));
275         }
276 
277         // If the StringBuilder has any data in it then one of the checks
278         // above failed and we should throw an exception.
279         if (diffLog.length() &gt; 0) {
280             throw new RuntimeException(diffLog.toString());
281         }
282     }
283 
284     private static Server startServer() {
285         Server server = new Server();
286         new Thread(server).start();
287         return server;
288     }
289 
290     private static class Server implements Runnable {
291 
292         public volatile boolean go = true;
293         private boolean signal = false;
294         public volatile int port = 0;
295         public volatile boolean started = false;
296 
297         private synchronized void waitForSignal() {
298             while (!signal) {
299                 try {
300                     wait();
301                 } catch (InterruptedException ex) {
302                     // do nothing
303                 }
304             }
305             signal = false;
306         }
307         public synchronized void signal() {
308             signal = true;
309             notify();
310         }
311 
312         @Override
313         public void run() {
314             try {
315 
316                 SSLContext sc = SSLContext.getDefault();
317                 ServerSocketFactory fac = sc.getServerSocketFactory();
318                 SSLServerSocket ssock = (SSLServerSocket)
319                     fac.createServerSocket(0);
320                 this.port = ssock.getLocalPort();
321 
322                 waitForSignal();
323                 started = true;
324                 while (go) {
325                     try {
326                         System.out.println(&quot;Waiting for connection&quot;);
327                         Socket sock = ssock.accept();
328                         BufferedReader reader = new BufferedReader(
329                             new InputStreamReader(sock.getInputStream()));
330                         String line = reader.readLine();
331                         System.out.println(&quot;server read: &quot; + line);
332                         PrintWriter out = new PrintWriter(
333                             new OutputStreamWriter(sock.getOutputStream()));
334                         out.println(line);
335                         out.flush();
336                         waitForSignal();
337                     } catch (Exception ex) {
338                         ex.printStackTrace();
339                     }
340                 }
341             } catch (Exception ex) {
342                 throw new RuntimeException(ex);
343             }
344         }
345     }
346 }
<a name="3" id="anc3"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="3" type="hidden" />
</body>
</html>
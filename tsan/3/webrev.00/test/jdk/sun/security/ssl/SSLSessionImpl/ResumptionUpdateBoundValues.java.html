<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New test/jdk/sun/security/ssl/SSLSessionImpl/ResumptionUpdateBoundValues.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 /*
 25  * @test
 26  * @library /test/lib
 27  * @summary Test that a New Session Ticket will be generated when a
 28  * SSLSessionBindingListener is set (boundValues)
 29  * @run main/othervm ResumptionUpdateBoundValues
 30  */
 31 
 32 import java.io.InputStream;
 33 import java.io.OutputStream;
 34 import java.lang.ref.Reference;
 35 import java.lang.ref.WeakReference;
 36 import java.util.concurrent.ArrayBlockingQueue;
 37 
 38 import javax.net.ssl.SSLServerSocket;
 39 import javax.net.ssl.SSLServerSocketFactory;
 40 import javax.net.ssl.SSLSession;
 41 import javax.net.ssl.SSLSessionBindingEvent;
 42 import javax.net.ssl.SSLSessionBindingListener;
 43 import javax.net.ssl.SSLSocket;
 44 import javax.net.ssl.SSLSocketFactory;
 45 
 46 import jdk.test.lib.process.OutputAnalyzer;
 47 import jdk.test.lib.process.ProcessTools;
 48 import jdk.test.lib.Utils;
 49 
 50 public class ResumptionUpdateBoundValues {
 51 
 52     static boolean separateServerThread = true;
 53 
 54     /*
 55      * Where do we find the keystores?
 56      */
 57     static String pathToStores = &quot;../../../../javax/net/ssl/etc/&quot;;
 58     static String keyStoreFile = &quot;keystore&quot;;
 59     static String trustStoreFile = &quot;truststore&quot;;
 60     static String passwd = &quot;passphrase&quot;;
 61 
 62     /*
 63      * Is the server ready to serve?
 64      */
 65     volatile static boolean serverReady = false;
 66 
 67     /*
 68      * Turn on SSL debugging?
 69      */
 70     static boolean debug = false;
 71 
 72     /*
 73      * Define the server side of the test.
 74      *
 75      * If the server prematurely exits, serverReady will be set to true
 76      * to avoid infinite hangs.
 77      */
 78     void doServerSide() throws Exception {
 79         SSLServerSocketFactory sslssf =
 80             (SSLServerSocketFactory) SSLServerSocketFactory.getDefault();
 81         SSLServerSocket sslServerSocket =
 82             (SSLServerSocket) sslssf.createServerSocket(serverPort);
 83         serverPort = sslServerSocket.getLocalPort();
 84 
 85         /*
 86          * Signal Client, we&#39;re ready for his connect.
 87          */
 88         serverReady = true;
 89 
 90         while (serverReady) {
 91             SSLSocket sslSocket = (SSLSocket) sslServerSocket.accept();
 92             InputStream sslIS = sslSocket.getInputStream();
 93             OutputStream sslOS = sslSocket.getOutputStream();
 94 
 95             sslIS.read();
 96             sslOS.write(85);
 97             sslOS.flush();
 98             SSLSession sslSession = sslSocket.getSession();
 99             SBListener sbListener = new SBListener(sslSession);
100             sslSession.putValue(&quot;x&quot;, sbListener);
101 
102             sslIS.read();
103             sslOS.write(85);
104             sslOS.flush();
105 
106             sslSocket.close();
107         }
108     }
109 
110     /*
111      * Define the client side of the test.
112      *
113      * If the server prematurely exits, serverReady will be set to true
114      * to avoid infinite hangs.
115      */
116     SBListener doClientSide() throws Exception {
117 
118         /*
119          * Wait for server to get started.
120          */
121         while (!serverReady) {
122             Thread.sleep(50);
123         }
124 
125         SSLSocketFactory sslsf =
126             (SSLSocketFactory) SSLSocketFactory.getDefault();
127 
128         try {
129                 SSLSocket sslSocket = (SSLSocket)
130                     sslsf.createSocket(&quot;localhost&quot;, serverPort);
131                 InputStream sslIS = sslSocket.getInputStream();
132                 OutputStream sslOS = sslSocket.getOutputStream();
133 
134             sslOS.write(280);
135             sslOS.flush();
136             sslIS.read();
137 
138             SSLSession sslSession = sslSocket.getSession();
139             System.out.printf(&quot; sslSession: %s %n   %s%n&quot;, sslSession, sslSession.getClass());
140             SBListener sbListener = new SBListener(sslSession);
141 
142             sslOS.write(280);
143             sslOS.flush();
144             sslIS.read();
145 
146             sslOS.write(280);
147             sslOS.flush();
148             sslIS.read();
149 
150             sslOS.close();
151             sslIS.close();
152             sslSocket.close();
153 
154             sslOS = null;
155             sslIS = null;
156             sslSession = null;
157             sslSocket = null;
158             Reference.reachabilityFence(sslOS);
159             Reference.reachabilityFence(sslIS);
160             Reference.reachabilityFence(sslSession);
161             Reference.reachabilityFence(sslSocket);
162 
163             return sbListener;
164         } catch (Exception ex) {
165             ex.printStackTrace();
166             throw ex;
167         }
168     }
169 
170     /*
171      * =============================================================
172      * The remainder is just support stuff
173      */
174 
175     // use any free port by default
176     volatile int serverPort = 0;
177 
178     volatile Exception serverException = null;
179     volatile Exception clientException = null;
180 
181     public static void main(String[] args) throws Exception {
182 
183         if (args.length == 0) {
184             System.setProperty(&quot;test.java.opts&quot;,
185                     &quot;-Dtest.src=&quot; + System.getProperty(&quot;test.src&quot;) +
186                             &quot; -Dtest.jdk=&quot; + System.getProperty(&quot;test.jdk&quot;) +
187                             &quot; -Djavax.net.debug=ssl,handshake&quot;);
188 
189             System.out.println(&quot;test.java.opts: &quot; +
190                     System.getProperty(&quot;test.java.opts&quot;));
191 
192             ProcessBuilder pb = ProcessTools.createJavaProcessBuilder(true,
193                     Utils.addTestJavaOpts(&quot;ResumptionUpdateBoundValues&quot;, &quot;p&quot;));
194 
195             OutputAnalyzer output = ProcessTools.executeProcess(pb);
196             try {
197                 output.shouldContain(&quot;trigger new session ticket&quot;);
198                 System.out.println(&quot;Found NST in debugging&quot;);
199             } catch (Exception e) {
200                 throw e;
201             } finally {
202                 System.out.println(&quot;-- BEGIN Stdout:&quot;);
203                 System.out.println(output.getStdout());
204                 System.out.println(&quot;-- END Stdout&quot;);
205                 System.out.println(&quot;-- BEGIN Stderr:&quot;);
206                 System.out.println(output.getStderr());
207                 System.out.println(&quot;-- END Stderr&quot;);
208             }
209             return;
210         }
211 
212         String keyFilename =
213             System.getProperty(&quot;test.src&quot;, &quot;./&quot;) + &quot;/&quot; + pathToStores +
214                 &quot;/&quot; + keyStoreFile;
215         String trustFilename =
216             System.getProperty(&quot;test.src&quot;, &quot;./&quot;) + &quot;/&quot; + pathToStores +
217                 &quot;/&quot; + trustStoreFile;
218         System.setProperty(&quot;javax.net.ssl.keyStore&quot;, keyFilename);
219         System.setProperty(&quot;javax.net.ssl.keyStorePassword&quot;, passwd);
220         System.setProperty(&quot;javax.net.ssl.trustStore&quot;, trustFilename);
221         System.setProperty(&quot;javax.net.ssl.trustStorePassword&quot;, passwd);
222 
223         if (debug)
224             System.setProperty(&quot;javax.net.debug&quot;, &quot;all&quot;);
225 
226         /*
227          * Start the tests.
228          */
229 
230         new ResumptionUpdateBoundValues();
231     }
232 
233     ArrayBlockingQueue&lt;Thread&gt; threads = new ArrayBlockingQueue&lt;Thread&gt;(100);
234 
235     ArrayBlockingQueue&lt;SBListener&gt; sbListeners = new ArrayBlockingQueue&lt;&gt;(100);
236 
237     /*
238      * Primary constructor, used to drive remainder of the test.
239      *
240      * Fork off the other side, then do your work.
241      */
242     ResumptionUpdateBoundValues() throws Exception {
243         final int count = 1;
244         if (separateServerThread) {
245             startServer(true);
246             startClients(true, count);
247         } else {
248             startClients(true, count);
249             startServer(true);
250         }
251 
252         /*
253          * Wait for other side to close down.
254          */
255         Thread t;
256         while ((t = threads.take()) != Thread.currentThread()) {
257             System.out.printf(&quot;  joining: %s%n&quot;, t);
258             t.join(1000L);
259         }
260         serverReady = false;
261         System.gc();
262         System.gc();
263 
264 
265         SBListener listener = null;
266         while ((listener = sbListeners.poll()) != null) {
267             if (!listener.check()) {
268                 System.out.printf(&quot;  sbListener not called on finalize: %s%n&quot;,
269                         listener);
270             }
271         }
272 
273         /*
274          * When we get here, the test is pretty much over.
275          *
276          * If the main thread excepted, that propagates back
277          * immediately.  If the other thread threw an exception, we
278          * should report back.
279          */
280         if (serverException != null) {
281             System.out.print(&quot;Server Exception:&quot;);
282             throw serverException;
283         }
284         if (clientException != null) {
285             System.out.print(&quot;Client Exception:&quot;);
286             throw clientException;
287         }
288     }
289 
290     void startServer(boolean newThread) throws Exception {
291         if (newThread) {
292             Thread t = new Thread(&quot;Server&quot;) {
293                 public void run() {
294                     try {
295                         doServerSide();
296                     } catch (Exception e) {
297                         /*
298                          * Our server thread just died.
299                          *
300                          * Release the client, if not active already...
301                          */
302                         System.err.println(&quot;Server died...&quot; + e);
303                         serverReady = true;
304                         serverException = e;
305                     }
306                 }
307             };
308             threads.add(t);
309             t.setDaemon(true);
310             t.start();
311         } else {
312             doServerSide();
313         }
314     }
315 
316     void startClients(boolean newThread, int count) throws Exception {
317         for (int i = 0; i &lt; count; i++) {
318             System.out.printf(&quot; newClient: %d%n&quot;, i);
319             startClient(newThread);
320         }
321         serverReady = false;
322 
323         threads.add(Thread.currentThread());    // add ourselves at the &#39;end&#39;
324     }
325     void startClient(boolean newThread) throws Exception {
326         if (newThread) {
327             Thread t = new Thread(&quot;Client&quot;) {
328                 public void run() {
329                     try {
330                         sbListeners.add(doClientSide());
331                     } catch (Exception e) {
332                         /*
333                          * Our client thread just died.
334                          */
335                         System.err.println(&quot;Client died...&quot; + e);
336                         clientException = e;
337                     }
338                 }
339             };
340             System.out.printf(&quot; starting: %s%n&quot;, t);
341             threads.add(t);
342             t.start();
343         } else {
344             sbListeners.add(doClientSide());
345         }
346     }
347 
348 
349     static class SBListener implements SSLSessionBindingListener {
350         private volatile int unboundNotified;
351         private final WeakReference&lt;SSLSession&gt; session;
352 
353         SBListener(SSLSession session) {
354             this.unboundNotified = 0;
355             this.session = new WeakReference&lt;SSLSession&gt;(session);
356         }
357 
358         boolean check() {
359             System.out.printf(&quot;  check: %s%n&quot;, this);
360             return unboundNotified &gt; 0 &amp;&amp; session.get() == null;
361         }
362 
363         @Override
364         public void valueBound(SSLSessionBindingEvent event) {
365             System.out.printf(&quot; valueBound: %s%n&quot;, event.getName());
366         }
367 
368         @Override
369         public void valueUnbound(SSLSessionBindingEvent event) {
370             System.out.printf(&quot; valueUnbound: %s%n&quot;, event.getName());
371             unboundNotified++;
372         }
373 
374         public String toString() {
375             return &quot;count: &quot; + unboundNotified +
376                     &quot;, ref: &quot; + session.get();
377         }
378     }
379 }
380 
    </pre>
  </body>
</html>
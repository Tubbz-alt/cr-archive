<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff test/jdk/sun/security/util/FilePermCompat/CompatImpact.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
<body>
<center><a href="../DerValue/BadValue.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="Flag.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>test/jdk/sun/security/util/FilePermCompat/CompatImpact.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2016, 2017, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
</pre>
<hr />
<pre>
 73                 Files.copy(Paths.get(cp, &quot;CompatImpact$DoPrivInner.class&quot;),
 74                         Paths.get(&quot;inner&quot;, &quot;CompatImpact$DoPrivInner.class&quot;));
 75                 break;
 76             // default policy always covered, user-defined depends on
 77             // system property jdk.security.filePermCompact.
 78             case &quot;builtin&quot;:
 79             case &quot;mine&quot;:
 80                 cp = System.getProperty(&quot;test.classes&quot;);
 81                 Proc p;
 82                 String failed = &quot;&quot;;
 83                 String testcase = &quot;&quot;;
 84                 String cwd = System.getProperty(&quot;user.dir&quot;);
 85 
 86                 // Granting a FilePermission on an absolute path
 87                 testcase = &quot;PonA&quot;;
 88                 p = p(args[0], cwd + &quot;/f&quot;)
 89                         .args(&quot;f&quot;, cwd + &quot;/f&quot;)
 90                         .debug(testcase)
 91                         .start();
 92                 if (p.waitFor() != 0) {
<span class="line-modified"> 93                     Files.copy(Paths.get(&quot;stderr.&quot; + testcase), System.out);</span>
 94                     failed += testcase + &quot; &quot;;
 95                 }
 96 
 97                 // Granting a FilePermission on a relative path
 98                 testcase = &quot;PonR&quot;;
 99                 p = p(args[0], &quot;f&quot;)
100                         .args(&quot;f&quot;, cwd + &quot;/f&quot;)
101                         .debug(testcase)
102                         .start();
103                 if (p.waitFor() != 0) {
<span class="line-modified">104                     Files.copy(Paths.get(&quot;stderr.&quot; + testcase), System.out);</span>
105                     failed += testcase + &quot; &quot;;
106                 }
107 
108                 // Reading file on classpath, not cwd
109                 testcase = &quot;cp&quot;;
110                 String cprel = Paths.get(cwd).relativize(Paths.get(cp))
111                         .normalize().toString();
112                 p = p(args[0], &quot;x&quot;)
113                         .args(cp + &quot;/f&quot;, cprel + &quot;/f&quot;)
114                         .debug(testcase)
115                         .start();
116                 if (p.waitFor() != 0) {
<span class="line-modified">117                     Files.copy(Paths.get(&quot;stderr.&quot; + testcase), System.out);</span>
118                     failed += testcase + &quot; &quot;;
119                 }
120 
121                 // Reading file on classpath, cwd
122                 testcase = &quot;cpHere&quot;;
123                 p = p(args[0], &quot;x&quot;)
124                         .args(cwd + &quot;/f&quot;, &quot;f&quot;, &quot;RES&quot;)
125                         .cp(&quot;.&quot;)   // Must! cancel the old CLASSPATH.
126                         .debug(testcase)
127                         .start();
128                 if (p.waitFor() != 0) {
<span class="line-modified">129                     Files.copy(Paths.get(&quot;stderr.&quot; + testcase), System.out);</span>
130                     failed += testcase + &quot; &quot;;
131                 }
132 
133                 // Reading file on classpath, cwd
134                 testcase = &quot;cpSub&quot;;
135                 p = p(args[0], &quot;x&quot;)
136                         .args(cwd + &quot;/sub/f&quot;, &quot;sub/f&quot;, &quot;RES&quot;)
137                         .cp(&quot;sub&quot;)   // Must! There&#39;s CLASSPATH.
138                         .debug(testcase)
139                         .start();
140                 if (p.waitFor() != 0) {
<span class="line-modified">141                     Files.copy(Paths.get(&quot;stderr.&quot; + testcase), System.out);</span>
142                     failed += testcase + &quot; &quot;;
143                 }
144 
145                 if (!failed.isEmpty()) {
146                     throw new Exception(failed + &quot;failed&quot;);
147                 }
148                 break;
149             // test &lt;policy_type&gt; &lt;grant&gt; &lt;read...&gt;
150             case &quot;test&quot;:
151                 if (args[1].equals(&quot;mine&quot;)) {
152                     Policy.setPolicy(new MP(args[2]));
153                 }
154                 Exception e = null;
155                 for (int i = 3; i &lt; args.length; i++) {
156                     try {
157                         System.out.println(args[i]);
158                         if (args[i].equals(&quot;RES&quot;)) {
159                             CompatImpact.class.getResourceAsStream(&quot;f&quot;)
160                                     .close();
161                         } else {
</pre>
<hr />
<pre>
221         }
222     }
223 
224     // Return a Proc object for different policy types
225     private static Proc p(String type, String f) throws Exception {
226         Proc p = Proc.create(&quot;CompatImpact&quot;)
227                 .prop(&quot;java.security.manager&quot;, &quot;&quot;)
228                 .inheritProp(&quot;jdk.security.filePermCompat&quot;);
229         p.args(&quot;test&quot;, type);
230         switch (type) {
231             case &quot;builtin&quot;:
232                 // For builtin policy, reading access to f can be
233                 // granted as a permission
234                 p.perm(new FilePermission(f, &quot;read&quot;));
235                 p.args(&quot;-&quot;);
236                 break;
237             case &quot;mine&quot;:
238                 // For my policy, f is passed into test and new MP(f)
239                 // will be set as new policy
240                 p.perm(new SecurityPermission(&quot;setPolicy&quot;));

241                 p.args(f);
242                 break;
243             default:
244                 throw new Exception(&quot;unknown &quot; + type);
245         }
246         return p;
247     }
248 
249     // My own Policy impl, with only one granted permission, also not smart
250     // enough to know whether ProtectionDomain grants any permission
251     static class MP extends Policy {

252         final PermissionCollection pc;

253         MP(String f) {
254             FilePermission p = new FilePermission(f, &quot;read&quot;);
255             pc = p.newPermissionCollection();
256             pc.add(p);
257         }
258         @Override
259         public PermissionCollection getPermissions(CodeSource codesource) {
260             return pc;
261         }
262 
263         @Override
264         public PermissionCollection getPermissions(ProtectionDomain domain) {
265             return pc;
266         }
267 
268         @Override
269         public boolean implies(ProtectionDomain domain, Permission permission) {
<span class="line-modified">270             return pc.implies(permission);</span>
271         }
272     }
273 }
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2016, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
</pre>
<hr />
<pre>
 73                 Files.copy(Paths.get(cp, &quot;CompatImpact$DoPrivInner.class&quot;),
 74                         Paths.get(&quot;inner&quot;, &quot;CompatImpact$DoPrivInner.class&quot;));
 75                 break;
 76             // default policy always covered, user-defined depends on
 77             // system property jdk.security.filePermCompact.
 78             case &quot;builtin&quot;:
 79             case &quot;mine&quot;:
 80                 cp = System.getProperty(&quot;test.classes&quot;);
 81                 Proc p;
 82                 String failed = &quot;&quot;;
 83                 String testcase = &quot;&quot;;
 84                 String cwd = System.getProperty(&quot;user.dir&quot;);
 85 
 86                 // Granting a FilePermission on an absolute path
 87                 testcase = &quot;PonA&quot;;
 88                 p = p(args[0], cwd + &quot;/f&quot;)
 89                         .args(&quot;f&quot;, cwd + &quot;/f&quot;)
 90                         .debug(testcase)
 91                         .start();
 92                 if (p.waitFor() != 0) {
<span class="line-modified"> 93                     Files.copy(Paths.get(testcase + &quot;.stderr&quot;), System.out);</span>
 94                     failed += testcase + &quot; &quot;;
 95                 }
 96 
 97                 // Granting a FilePermission on a relative path
 98                 testcase = &quot;PonR&quot;;
 99                 p = p(args[0], &quot;f&quot;)
100                         .args(&quot;f&quot;, cwd + &quot;/f&quot;)
101                         .debug(testcase)
102                         .start();
103                 if (p.waitFor() != 0) {
<span class="line-modified">104                     Files.copy(Paths.get(testcase + &quot;.stderr&quot;), System.out);</span>
105                     failed += testcase + &quot; &quot;;
106                 }
107 
108                 // Reading file on classpath, not cwd
109                 testcase = &quot;cp&quot;;
110                 String cprel = Paths.get(cwd).relativize(Paths.get(cp))
111                         .normalize().toString();
112                 p = p(args[0], &quot;x&quot;)
113                         .args(cp + &quot;/f&quot;, cprel + &quot;/f&quot;)
114                         .debug(testcase)
115                         .start();
116                 if (p.waitFor() != 0) {
<span class="line-modified">117                     Files.copy(Paths.get(testcase + &quot;.stderr&quot;), System.out);</span>
118                     failed += testcase + &quot; &quot;;
119                 }
120 
121                 // Reading file on classpath, cwd
122                 testcase = &quot;cpHere&quot;;
123                 p = p(args[0], &quot;x&quot;)
124                         .args(cwd + &quot;/f&quot;, &quot;f&quot;, &quot;RES&quot;)
125                         .cp(&quot;.&quot;)   // Must! cancel the old CLASSPATH.
126                         .debug(testcase)
127                         .start();
128                 if (p.waitFor() != 0) {
<span class="line-modified">129                     Files.copy(Paths.get(testcase + &quot;.stderr&quot;), System.out);</span>
130                     failed += testcase + &quot; &quot;;
131                 }
132 
133                 // Reading file on classpath, cwd
134                 testcase = &quot;cpSub&quot;;
135                 p = p(args[0], &quot;x&quot;)
136                         .args(cwd + &quot;/sub/f&quot;, &quot;sub/f&quot;, &quot;RES&quot;)
137                         .cp(&quot;sub&quot;)   // Must! There&#39;s CLASSPATH.
138                         .debug(testcase)
139                         .start();
140                 if (p.waitFor() != 0) {
<span class="line-modified">141                     Files.copy(Paths.get(testcase + &quot;.stderr&quot;), System.out);</span>
142                     failed += testcase + &quot; &quot;;
143                 }
144 
145                 if (!failed.isEmpty()) {
146                     throw new Exception(failed + &quot;failed&quot;);
147                 }
148                 break;
149             // test &lt;policy_type&gt; &lt;grant&gt; &lt;read...&gt;
150             case &quot;test&quot;:
151                 if (args[1].equals(&quot;mine&quot;)) {
152                     Policy.setPolicy(new MP(args[2]));
153                 }
154                 Exception e = null;
155                 for (int i = 3; i &lt; args.length; i++) {
156                     try {
157                         System.out.println(args[i]);
158                         if (args[i].equals(&quot;RES&quot;)) {
159                             CompatImpact.class.getResourceAsStream(&quot;f&quot;)
160                                     .close();
161                         } else {
</pre>
<hr />
<pre>
221         }
222     }
223 
224     // Return a Proc object for different policy types
225     private static Proc p(String type, String f) throws Exception {
226         Proc p = Proc.create(&quot;CompatImpact&quot;)
227                 .prop(&quot;java.security.manager&quot;, &quot;&quot;)
228                 .inheritProp(&quot;jdk.security.filePermCompat&quot;);
229         p.args(&quot;test&quot;, type);
230         switch (type) {
231             case &quot;builtin&quot;:
232                 // For builtin policy, reading access to f can be
233                 // granted as a permission
234                 p.perm(new FilePermission(f, &quot;read&quot;));
235                 p.args(&quot;-&quot;);
236                 break;
237             case &quot;mine&quot;:
238                 // For my policy, f is passed into test and new MP(f)
239                 // will be set as new policy
240                 p.perm(new SecurityPermission(&quot;setPolicy&quot;));
<span class="line-added">241                 p.perm(new SecurityPermission(&quot;getPolicy&quot;));</span>
242                 p.args(f);
243                 break;
244             default:
245                 throw new Exception(&quot;unknown &quot; + type);
246         }
247         return p;
248     }
249 
250     // My own Policy impl, with only one granted permission, also not smart
251     // enough to know whether ProtectionDomain grants any permission
252     static class MP extends Policy {
<span class="line-added">253         static final Policy DEFAULT_POLICY = Policy.getPolicy();</span>
254         final PermissionCollection pc;
<span class="line-added">255 </span>
256         MP(String f) {
257             FilePermission p = new FilePermission(f, &quot;read&quot;);
258             pc = p.newPermissionCollection();
259             pc.add(p);
260         }
261         @Override
262         public PermissionCollection getPermissions(CodeSource codesource) {
263             return pc;
264         }
265 
266         @Override
267         public PermissionCollection getPermissions(ProtectionDomain domain) {
268             return pc;
269         }
270 
271         @Override
272         public boolean implies(ProtectionDomain domain, Permission permission) {
<span class="line-modified">273             return pc.implies(permission) || DEFAULT_POLICY.implies(domain, permission);</span>
274         }
275     }
276 }
</pre>
</td>
</tr>
</table>
<center><a href="../DerValue/BadValue.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="Flag.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New test/jdk/sun/security/pkcs11/Signature/SignatureTestPSS.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 import java.security.*;
 24 import java.security.interfaces.*;
 25 import java.security.spec.*;
 26 import java.util.stream.IntStream;
 27 
 28 /**
 29  * @test
 30  * @bug 8080462 8226651
 31  * @summary Generate a RSASSA-PSS signature and verify it using PKCS11 provider
 32  * @library /test/lib ..
 33  * @modules jdk.crypto.cryptoki
 34  * @run main SignatureTestPSS
 35  */
 36 public class SignatureTestPSS extends PKCS11Test {
 37 
 38     // PKCS11 does not support RSASSA-PSS keys yet
 39     private static final String KEYALG = &quot;RSA&quot;;
 40     private static final String SIGALG = &quot;RSASSA-PSS&quot;;
 41 
 42     private static final int[] KEYSIZES = { 2048, 3072 };
 43     private static final String[] DIGESTS = { &quot;SHA-224&quot;, &quot;SHA-256&quot;,
 44             &quot;SHA-384&quot; , &quot;SHA-512&quot; };
 45     private Provider prov;
 46 
 47     /**
 48      * How much times signature updated.
 49      */
 50     private static final int UPDATE_TIMES_FIFTY = 50;
 51 
 52     /**
 53      * How much times signature initial updated.
 54      */
 55     private static final int UPDATE_TIMES_HUNDRED = 100;
 56 
 57     public static void main(String[] args) throws Exception {
 58         main(new SignatureTestPSS(), args);
 59     }
 60 
 61     @Override
 62     public void main(Provider p) throws Exception {
 63         Signature sig;
 64         try {
 65             sig = Signature.getInstance(SIGALG, p);
 66         } catch (NoSuchAlgorithmException e) {
 67             System.out.println(&quot;Skip testing RSASSA-PSS&quot; +
 68                 &quot; due to no support&quot;);
 69             return;
 70         }
 71         this.prov = p;
 72         for (int i : KEYSIZES) {
 73             runTest(i);
 74         }
 75     }
 76 
 77     private void runTest(int keySize) throws Exception {
 78         byte[] data = new byte[100];
 79         IntStream.range(0, data.length).forEach(j -&gt; {
 80             data[j] = (byte) j;
 81         });
 82         System.out.println(&quot;[KEYSIZE = &quot; + keySize + &quot;]&quot;);
 83 
 84         // create a key pair
 85         KeyPair kpair = generateKeys(KEYALG, keySize);
 86         test(DIGESTS, kpair.getPrivate(), kpair.getPublic(), data);
 87     }
 88 
 89     private void test(String[] digestAlgs, PrivateKey privKey,
 90             PublicKey pubKey, byte[] data) throws RuntimeException {
 91         // For signature algorithm, create and verify a signature
 92         for (String hash : digestAlgs) {
 93             for (String mgfHash : digestAlgs) {
 94                 try {
 95                     checkSignature(data, pubKey, privKey, hash, mgfHash);
 96                 } catch (NoSuchAlgorithmException | InvalidKeyException |
 97                          SignatureException | NoSuchProviderException ex) {
 98                     throw new RuntimeException(ex);
 99                 } catch (InvalidAlgorithmParameterException ex2) {
100                     System.out.println(&quot;Skip test due to &quot; + ex2);
101                 }
102             }
103         };
104     }
105 
106     private KeyPair generateKeys(String keyalg, int size)
107             throws NoSuchAlgorithmException {
108         KeyPairGenerator kpg = KeyPairGenerator.getInstance(keyalg, prov);
109         kpg.initialize(size);
110         return kpg.generateKeyPair();
111     }
112 
113     private void checkSignature(byte[] data, PublicKey pub,
114             PrivateKey priv, String hash, String mgfHash)
115             throws NoSuchAlgorithmException, InvalidKeyException,
116             SignatureException, NoSuchProviderException,
117             InvalidAlgorithmParameterException {
118         System.out.println(&quot;Testing against &quot; + hash + &quot; and MGF1_&quot; + mgfHash);
119         Signature sig = Signature.getInstance(SIGALG, prov);
120         AlgorithmParameterSpec params = new PSSParameterSpec(
121             hash, &quot;MGF1&quot;, new MGF1ParameterSpec(mgfHash), 0, 1);
122         sig.setParameter(params);
123         sig.initSign(priv);
124         for (int i = 0; i &lt; UPDATE_TIMES_HUNDRED; i++) {
125             sig.update(data);
126         }
127         byte[] signedData = sig.sign();
128 
129         // Make sure signature verifies with original data
130         // do we need to call sig.setParameter(params) again?
131         sig.initVerify(pub);
132         for (int i = 0; i &lt; UPDATE_TIMES_HUNDRED; i++) {
133             sig.update(data);
134         }
135         if (!sig.verify(signedData)) {
136             throw new RuntimeException(&quot;Failed to verify signature&quot;);
137         }
138 
139         // Make sure signature does NOT verify when the original data
140         // has changed
141         sig.initVerify(pub);
142         for (int i = 0; i &lt; UPDATE_TIMES_FIFTY; i++) {
143             sig.update(data);
144         }
145 
146         if (sig.verify(signedData)) {
147             throw new RuntimeException(&quot;Failed to detect bad signature&quot;);
148         }
149     }
150 }
    </pre>
  </body>
</html>
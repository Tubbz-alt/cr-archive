<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old test/jdk/sun/security/pkcs11/PKCS11Test.java</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2003, 2018, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 
 25 // common infrastructure for SunPKCS11 tests
 26 
 27 import java.io.BufferedReader;
 28 import java.io.ByteArrayOutputStream;
 29 import java.io.File;
 30 import java.io.IOException;
 31 import java.io.InputStream;
 32 import java.io.InputStreamReader;
 33 import java.io.StringReader;
 34 import java.nio.charset.StandardCharsets;
 35 import java.nio.file.Files;
 36 import java.nio.file.Path;
 37 import java.nio.file.Paths;
 38 import java.security.AlgorithmParameters;
 39 import java.security.InvalidAlgorithmParameterException;
 40 import java.security.KeyPairGenerator;
 41 import java.security.NoSuchProviderException;
 42 import java.security.Provider;
 43 import java.security.ProviderException;
 44 import java.security.Security;
 45 import java.security.spec.ECGenParameterSpec;
 46 import java.security.spec.ECParameterSpec;
 47 import java.util.ArrayList;
 48 import java.util.Arrays;
 49 import java.util.HashMap;
 50 import java.util.Iterator;
 51 import java.util.List;
 52 import java.util.Map;
 53 import java.util.Optional;
 54 import java.util.Properties;
 55 import java.util.ServiceConfigurationError;
 56 import java.util.ServiceLoader;
 57 import java.util.Set;
 58 
 59 import jdk.test.lib.artifacts.Artifact;
 60 import jdk.test.lib.artifacts.ArtifactResolver;
 61 import jdk.test.lib.artifacts.ArtifactResolverException;
 62 
 63 public abstract class PKCS11Test {
 64 
 65     private boolean enableSM = false;
 66 
 67     static final Properties props = System.getProperties();
 68 
 69     static final String PKCS11 = &quot;PKCS11&quot;;
 70 
 71     // directory of the test source
 72     static final String BASE = System.getProperty(&quot;test.src&quot;, &quot;.&quot;);
 73 
 74     static final char SEP = File.separatorChar;
 75 
 76     private static final String DEFAULT_POLICY =
 77             BASE + SEP + &quot;..&quot; + SEP + &quot;policy&quot;;
 78 
 79     // directory corresponding to BASE in the /closed hierarchy
 80     static final String CLOSED_BASE;
 81 
 82     static {
 83         // hack
 84         String absBase = new File(BASE).getAbsolutePath();
 85         int k = absBase.indexOf(SEP + &quot;test&quot; + SEP + &quot;sun&quot; + SEP);
 86         if (k &lt; 0) k = 0;
 87         String p1 = absBase.substring(0, k + 6);
 88         String p2 = absBase.substring(k + 5);
 89         CLOSED_BASE = p1 + &quot;closed&quot; + p2;
 90 
 91         // set it as a system property to make it available in policy file
 92         System.setProperty(&quot;closed.base&quot;, CLOSED_BASE);
 93     }
 94 
 95     // NSS version info
 96     public static enum ECCState { None, Basic, Extended };
 97     static double nss_version = -1;
 98     static ECCState nss_ecc_status = ECCState.Extended;
 99 
100     // The NSS library we need to search for in getNSSLibDir()
101     // Default is &quot;libsoftokn3.so&quot;, listed as &quot;softokn3&quot;
102     // The other is &quot;libnss3.so&quot;, listed as &quot;nss3&quot;.
103     static String nss_library = &quot;softokn3&quot;;
104 
105     // NSS versions of each library.  It is simplier to keep nss_version
106     // for quick checking for generic testing than many if-else statements.
107     static double softoken3_version = -1;
108     static double nss3_version = -1;
109     static Provider pkcs11;
110 
111     // Goes through ServiceLoader instead of Provider.getInstance() since it
112     // works on all platforms
113     static {
114         ServiceLoader sl = ServiceLoader.load(java.security.Provider.class);
115         Iterator&lt;Provider&gt; iter = sl.iterator();
116         Provider p = null;
117         boolean found = false;
118         while (iter.hasNext()) {
119             try {
120                 p = iter.next();
121                 if (p.getName().equals(&quot;SunPKCS11&quot;)) {
122                     found = true;
123                     break;
124                 }
125             } catch (Exception | ServiceConfigurationError e) {
126                 // ignore and move on to the next one
127             }
128         }
129         // Nothing found through ServiceLoader; fall back to reflection
130         if (!found) {
131             try {
132                 Class clazz = Class.forName(&quot;sun.security.pkcs11.SunPKCS11&quot;);
133                 p = (Provider) clazz.newInstance();
134             } catch (Exception ex) {
135                 ex.printStackTrace();
136             }
137         }
138         pkcs11 = p;
139     }
140 
141     /*
142      * Use Solaris SPARC 11.2 or later to avoid an intermittent failure
143      * when running SunPKCS11-Solaris (8044554)
144      */
145     static boolean isBadSolarisSparc(Provider p) {
146         if (&quot;SunPKCS11-Solaris&quot;.equals(p.getName()) &amp;&amp; badSolarisSparc) {
147             System.out.println(&quot;SunPKCS11-Solaris provider requires &quot; +
148                 &quot;Solaris SPARC 11.2 or later, skipping&quot;);
149             return true;
150         }
151         return false;
152     }
153 
154     // Return a SunPKCS11 provider configured with the specified config file
155     static Provider getSunPKCS11(String config) throws Exception {
156         if (pkcs11 == null) {
157             throw new NoSuchProviderException(&quot;No PKCS11 provider available&quot;);
158         }
159         return pkcs11.configure(config);
160     }
161 
162     public abstract void main(Provider p) throws Exception;
163 
164     protected boolean skipTest(Provider p) {
165         return false;
166     }
167 
168     private void premain(Provider p) throws Exception {
169         if (skipTest(p)) {
170             return;
171         }
172 
173         // set a security manager and policy before a test case runs,
174         // and disable them after the test case finished
175         try {
176             if (enableSM) {
177                 System.setSecurityManager(new SecurityManager());
178             }
179             long start = System.currentTimeMillis();
180             System.out.printf(
181                     &quot;Running test with provider %s (security manager %s) ...%n&quot;,
182                         p.getName(), enableSM ? &quot;enabled&quot; : &quot;disabled&quot;);
183             main(p);
184             long stop = System.currentTimeMillis();
185             System.out.println(&quot;Completed test with provider &quot; + p.getName() +
186                 &quot; (&quot; + (stop - start) + &quot; ms).&quot;);
187         } finally {
188             if (enableSM) {
189                 System.setSecurityManager(null);
190             }
191         }
192     }
193 
194     public static void main(PKCS11Test test) throws Exception {
195         main(test, null);
196     }
197 
198     public static void main(PKCS11Test test, String[] args) throws Exception {
199         if (args != null) {
200             if (args.length &gt; 0) {
201                 if (&quot;sm&quot;.equals(args[0])) {
202                     test.enableSM = true;
203                 } else {
204                     throw new RuntimeException(&quot;Unknown Command, use &#39;sm&#39; as &quot;
205                             + &quot;first arguemtn to enable security manager&quot;);
206                 }
207             }
208             if (test.enableSM) {
209                 System.setProperty(&quot;java.security.policy&quot;,
210                         (args.length &gt; 1) ? BASE + SEP + args[1]
211                                 : DEFAULT_POLICY);
212             }
213         }
214 
215         Provider[] oldProviders = Security.getProviders();
216         try {
217             System.out.println(&quot;Beginning test run &quot; + test.getClass().getName() + &quot;...&quot;);
218             testDefault(test);
219             testNSS(test);
220             testDeimos(test);
221         } finally {
222             // NOTE: Do not place a &#39;return&#39; in any finally block
223             // as it will suppress exceptions and hide test failures.
224             Provider[] newProviders = Security.getProviders();
225             boolean found = true;
226             // Do not restore providers if nothing changed. This is especailly
227             // useful for ./Provider/Login.sh, where a SecurityManager exists.
228             if (oldProviders.length == newProviders.length) {
229                 found = false;
230                 for (int i = 0; i&lt;oldProviders.length; i++) {
231                     if (oldProviders[i] != newProviders[i]) {
232                         found = true;
233                         break;
234                     }
235                 }
236             }
237             if (found) {
238                 for (Provider p: newProviders) {
239                     Security.removeProvider(p.getName());
240                 }
241                 for (Provider p: oldProviders) {
242                     Security.addProvider(p);
243                 }
244             }
245         }
246     }
247 
248     public static void testDeimos(PKCS11Test test) throws Exception {
249         if (new File(&quot;/opt/SUNWconn/lib/libpkcs11.so&quot;).isFile() == false ||
250             &quot;true&quot;.equals(System.getProperty(&quot;NO_DEIMOS&quot;))) {
251             return;
252         }
253         String base = getBase();
254         String p11config = base + SEP + &quot;nss&quot; + SEP + &quot;p11-deimos.txt&quot;;
255         Provider p = getSunPKCS11(p11config);
256         test.premain(p);
257     }
258 
259     public static void testDefault(PKCS11Test test) throws Exception {
260         // run test for default configured PKCS11 providers (if any)
261 
262         if (&quot;true&quot;.equals(System.getProperty(&quot;NO_DEFAULT&quot;))) {
263             return;
264         }
265 
266         Provider[] providers = Security.getProviders();
267         for (int i = 0; i &lt; providers.length; i++) {
268             Provider p = providers[i];
269             if (p.getName().startsWith(&quot;SunPKCS11-&quot;)) {
270                 test.premain(p);
271             }
272         }
273     }
274 
275     private static String PKCS11_BASE;
276     static {
277         try {
278             PKCS11_BASE = getBase();
279         } catch (Exception e) {
280             // ignore
281         }
282     }
283 
284     private final static String PKCS11_REL_PATH = &quot;sun/security/pkcs11&quot;;
285 
286     public static String getBase() throws Exception {
287         if (PKCS11_BASE != null) {
288             return PKCS11_BASE;
289         }
290         File cwd = new File(System.getProperty(&quot;test.src&quot;, &quot;.&quot;)).getCanonicalFile();
291         while (true) {
292             File file = new File(cwd, &quot;TEST.ROOT&quot;);
293             if (file.isFile()) {
294                 break;
295             }
296             cwd = cwd.getParentFile();
297             if (cwd == null) {
298                 throw new Exception(&quot;Test root directory not found&quot;);
299             }
300         }
301         PKCS11_BASE = new File(cwd, PKCS11_REL_PATH.replace(&#39;/&#39;, SEP)).getAbsolutePath();
302         return PKCS11_BASE;
303     }
304 
305     public static String getNSSLibDir() throws Exception {
306         return getNSSLibDir(nss_library);
307     }
308 
309     static String getNSSLibDir(String library) throws Exception {
310         Path libPath = getNSSLibPath(library);
311         if (libPath == null) {
312             return null;
313         }
314 
315         String libDir = String.valueOf(libPath.getParent()) + File.separatorChar;
316         System.out.println(&quot;nssLibDir: &quot; + libDir);
317         System.setProperty(&quot;pkcs11test.nss.libdir&quot;, libDir);
318         return libDir;
319     }
320 
321     private static Path getNSSLibPath() throws Exception {
322         return getNSSLibPath(nss_library);
323     }
324 
325     static Path getNSSLibPath(String library) throws Exception {
326         String osid = getOsId();
327         String[] nssLibDirs = getNssLibPaths(osid);
328         if (nssLibDirs == null) {
329             System.out.println(&quot;Warning: unsupported OS: &quot; + osid
330                     + &quot;, please initialize NSS librarys location firstly, skipping test&quot;);
331             return null;
332         }
333         if (nssLibDirs.length == 0) {
334             System.out.println(&quot;Warning: NSS not supported on this platform, skipping test&quot;);
335             return null;
336         }
337 
338         Path nssLibPath = null;
339         for (String dir : nssLibDirs) {
340             Path libPath = Paths.get(dir).resolve(System.mapLibraryName(library));
341             if (Files.exists(libPath)) {
342                 nssLibPath = libPath;
343                 break;
344             }
345         }
346         if (nssLibPath == null) {
347             System.out.println(&quot;Warning: can&#39;t find NSS librarys on this machine, skipping test&quot;);
348             return null;
349         }
350         return nssLibPath;
351     }
352 
353     private static String getOsId() {
354         String osName = props.getProperty(&quot;os.name&quot;);
355         if (osName.startsWith(&quot;Win&quot;)) {
356             osName = &quot;Windows&quot;;
357         } else if (osName.equals(&quot;Mac OS X&quot;)) {
358             osName = &quot;MacOSX&quot;;
359         }
360         String osid = osName + &quot;-&quot; + props.getProperty(&quot;os.arch&quot;) + &quot;-&quot;
361                 + props.getProperty(&quot;sun.arch.data.model&quot;);
362         return osid;
363     }
364 
365     static boolean isBadNSSVersion(Provider p) {
366         double nssVersion = getNSSVersion();
367         if (isNSS(p) &amp;&amp; nssVersion &gt;= 3.11 &amp;&amp; nssVersion &lt; 3.12) {
368             System.out.println(&quot;NSS 3.11 has a DER issue that recent &quot; +
369                     &quot;version do not, skipping&quot;);
370             return true;
371         }
372         return false;
373     }
374 
375     protected static void safeReload(String lib) throws Exception {
376         try {
377             System.load(lib);
378         } catch (UnsatisfiedLinkError e) {
379             if (e.getMessage().contains(&quot;already loaded&quot;)) {
380                 return;
381             }
382         }
383     }
384 
385     static boolean loadNSPR(String libdir) throws Exception {
386         // load NSS softoken dependencies in advance to avoid resolver issues
387         safeReload(libdir + System.mapLibraryName(&quot;nspr4&quot;));
388         safeReload(libdir + System.mapLibraryName(&quot;plc4&quot;));
389         safeReload(libdir + System.mapLibraryName(&quot;plds4&quot;));
390         safeReload(libdir + System.mapLibraryName(&quot;sqlite3&quot;));
391         safeReload(libdir + System.mapLibraryName(&quot;nssutil3&quot;));
392         return true;
393     }
394 
395     // Check the provider being used is NSS
396     public static boolean isNSS(Provider p) {
397         return p.getName().toUpperCase().equals(&quot;SUNPKCS11-NSS&quot;);
398     }
399 
400     static double getNSSVersion() {
401         if (nss_version == -1)
402             getNSSInfo();
403         return nss_version;
404     }
405 
406     static ECCState getNSSECC() {
407         if (nss_version == -1)
408             getNSSInfo();
409         return nss_ecc_status;
410     }
411 
412     public static double getLibsoftokn3Version() {
413         if (softoken3_version == -1)
414             return getNSSInfo(&quot;softokn3&quot;);
415         return softoken3_version;
416     }
417 
418     public static double getLibnss3Version() {
419         if (nss3_version == -1)
420             return getNSSInfo(&quot;nss3&quot;);
421         return nss3_version;
422     }
423 
424     /* Read the library to find out the verison */
425     static void getNSSInfo() {
426         getNSSInfo(nss_library);
427     }
428 
429     // Try to parse the version for the specified library.
430     // Assuming the library contains either of the following patterns:
431     // $Header: NSS &lt;version&gt;
432     // Version: NSS &lt;version&gt;
433     // Here, &lt;version&gt; stands for NSS version.
434     static double getNSSInfo(String library) {
435         // look for two types of headers in NSS libraries
436         String nssHeader1 = &quot;$Header: NSS&quot;;
437         String nssHeader2 = &quot;Version: NSS&quot;;
438         boolean found = false;
439         String s = null;
440         int i = 0;
441         Path libfile = null;
442 
443         if (library.compareTo(&quot;softokn3&quot;) == 0 &amp;&amp; softoken3_version &gt; -1)
444             return softoken3_version;
445         if (library.compareTo(&quot;nss3&quot;) == 0 &amp;&amp; nss3_version &gt; -1)
446             return nss3_version;
447 
448         try {
449             libfile = getNSSLibPath();
450             if (libfile == null) {
451                 return 0.0;
452             }
453             try (InputStream is = Files.newInputStream(libfile)) {
454                 byte[] data = new byte[1000];
455                 int read = 0;
456 
457                 while (is.available() &gt; 0) {
458                     if (read == 0) {
459                         read = is.read(data, 0, 1000);
460                     } else {
461                         // Prepend last 100 bytes in case the header was split
462                         // between the reads.
463                         System.arraycopy(data, 900, data, 0, 100);
464                         read = 100 + is.read(data, 100, 900);
465                     }
466 
467                     s = new String(data, 0, read, StandardCharsets.US_ASCII);
468                     i = s.indexOf(nssHeader1);
469                     if (i &gt; 0 || (i = s.indexOf(nssHeader2)) &gt; 0) {
470                         found = true;
471                         // If the nssHeader is before 920 we can break, otherwise
472                         // we may not have the whole header so do another read.  If
473                         // no bytes are in the stream, that is ok, found is true.
474                         if (i &lt; 920) {
475                             break;
476                         }
477                     }
478                 }
479             }
480         } catch (Exception e) {
481             e.printStackTrace();
482         }
483 
484         if (!found) {
485             System.out.println(&quot;lib&quot; + library +
486                     &quot; version not found, set to 0.0: &quot; + libfile);
487             nss_version = 0.0;
488             return nss_version;
489         }
490 
491         // the index after whitespace after nssHeader
492         int afterheader = s.indexOf(&quot;NSS&quot;, i) + 4;
493         String version = String.valueOf(s.charAt(afterheader));
494         for (char c = s.charAt(++afterheader);
495                 c == &#39;.&#39; || (c &gt;= &#39;0&#39; &amp;&amp; c &lt;= &#39;9&#39;);
496                 c = s.charAt(++afterheader)) {
497             version += c;
498         }
499 
500         // If a &quot;dot dot&quot; release, strip the extra dots for double parsing
501         String[] dot = version.split(&quot;\\.&quot;);
502         if (dot.length &gt; 2) {
503             version = dot[0]+&quot;.&quot;+dot[1];
504             for (int j = 2; dot.length &gt; j; j++) {
505                 version += dot[j];
506             }
507         }
508 
509         // Convert to double for easier version value checking
510         try {
511             nss_version = Double.parseDouble(version);
512         } catch (NumberFormatException e) {
513             System.out.println(&quot;===== Content start =====&quot;);
514             System.out.println(s);
515             System.out.println(&quot;===== Content end =====&quot;);
516             System.out.println(&quot;Failed to parse lib&quot; + library +
517                     &quot; version. Set to 0.0&quot;);
518             e.printStackTrace();
519         }
520 
521         System.out.print(&quot;lib&quot; + library + &quot; version = &quot;+version+&quot;.  &quot;);
522 
523         // Check for ECC
524         if (s.indexOf(&quot;Basic&quot;) &gt; 0) {
525             nss_ecc_status = ECCState.Basic;
526             System.out.println(&quot;ECC Basic.&quot;);
527         } else if (s.indexOf(&quot;Extended&quot;) &gt; 0) {
528             nss_ecc_status = ECCState.Extended;
529             System.out.println(&quot;ECC Extended.&quot;);
530         } else {
531             System.out.println(&quot;ECC None.&quot;);
532         }
533 
534         if (library.compareTo(&quot;softokn3&quot;) == 0) {
535             softoken3_version = nss_version;
536         } else if (library.compareTo(&quot;nss3&quot;) == 0) {
537             nss3_version = nss_version;
538         }
539 
540         return nss_version;
541     }
542 
543     // Used to set the nss_library file to search for libsoftokn3.so
544     public static void useNSS() {
545         nss_library = &quot;nss3&quot;;
546     }
547 
548     public static void testNSS(PKCS11Test test) throws Exception {
549         String libdir = getNSSLibDir();
550         if (libdir == null) {
551             return;
552         }
553         String base = getBase();
554 
555         if (loadNSPR(libdir) == false) {
556             return;
557         }
558 
559         String libfile = libdir + System.mapLibraryName(nss_library);
560 
561         String customDBdir = System.getProperty(&quot;CUSTOM_DB_DIR&quot;);
562         String dbdir = (customDBdir != null) ?
563                                 customDBdir :
564                                 base + SEP + &quot;nss&quot; + SEP + &quot;db&quot;;
565         // NSS always wants forward slashes for the config path
566         dbdir = dbdir.replace(&#39;\\&#39;, &#39;/&#39;);
567 
568         String customConfig = System.getProperty(&quot;CUSTOM_P11_CONFIG&quot;);
569         String customConfigName = System.getProperty(&quot;CUSTOM_P11_CONFIG_NAME&quot;, &quot;p11-nss.txt&quot;);
570         String p11config = (customConfig != null) ?
571                                 customConfig :
572                                 base + SEP + &quot;nss&quot; + SEP + customConfigName;
573 
574         System.setProperty(&quot;pkcs11test.nss.lib&quot;, libfile);
575         System.setProperty(&quot;pkcs11test.nss.db&quot;, dbdir);
576         Provider p = getSunPKCS11(p11config);
577         test.premain(p);
578     }
579 
580     // Generate a vector of supported elliptic curves of a given provider
581     static List&lt;ECParameterSpec&gt; getKnownCurves(Provider p) throws Exception {
582         int index;
583         int begin;
584         int end;
585         String curve;
586 
587         List&lt;ECParameterSpec&gt; results = new ArrayList&lt;&gt;();
588         // Get Curves to test from SunEC.
589         String kcProp = Security.getProvider(&quot;SunEC&quot;).
590                 getProperty(&quot;AlgorithmParameters.EC SupportedCurves&quot;);
591 
592         if (kcProp == null) {
593             throw new RuntimeException(
594             &quot;\&quot;AlgorithmParameters.EC SupportedCurves property\&quot; not found&quot;);
595         }
596 
597         System.out.println(&quot;Finding supported curves using list from SunEC\n&quot;);
598         index = 0;
599         for (;;) {
600             // Each set of curve names is enclosed with brackets.
601             begin = kcProp.indexOf(&#39;[&#39;, index);
602             end = kcProp.indexOf(&#39;]&#39;, index);
603             if (begin == -1 || end == -1) {
604                 break;
605             }
606 
607             /*
608              * Each name is separated by a comma.
609              * Just get the first name in the set.
610              */
611             index = end + 1;
612             begin++;
613             end = kcProp.indexOf(&#39;,&#39;, begin);
614             if (end == -1) {
615                 // Only one name in the set.
616                 end = index -1;
617             }
618 
619             curve = kcProp.substring(begin, end);
620             getSupportedECParameterSpec(curve, p)
621                 .ifPresent(spec -&gt; results.add(spec));
622         }
623 
624         if (results.size() == 0) {
625             throw new RuntimeException(&quot;No supported EC curves found&quot;);
626         }
627 
628         return results;
629     }
630 
631     static Optional&lt;ECParameterSpec&gt; getSupportedECParameterSpec(String curve,
632             Provider p) throws Exception {
633         ECParameterSpec e = getECParameterSpec(p, curve);
634         System.out.print(&quot;\t &quot;+ curve + &quot;: &quot;);
635         try {
636             KeyPairGenerator kpg = KeyPairGenerator.getInstance(&quot;EC&quot;, p);
637             kpg.initialize(e);
638             kpg.generateKeyPair();
639             System.out.println(&quot;Supported&quot;);
640             return Optional.of(e);
641         } catch (ProviderException ex) {
642             System.out.println(&quot;Unsupported: PKCS11: &quot; +
643                     ex.getCause().getMessage());
644             return Optional.empty();
645         } catch (InvalidAlgorithmParameterException ex) {
646             System.out.println(&quot;Unsupported: Key Length: &quot; +
647                     ex.getMessage());
648             return Optional.empty();
649         }
650     }
651 
652     private static ECParameterSpec getECParameterSpec(Provider p, String name)
653             throws Exception {
654 
655         AlgorithmParameters parameters =
656             AlgorithmParameters.getInstance(&quot;EC&quot;, p);
657 
658         parameters.init(new ECGenParameterSpec(name));
659 
660         return parameters.getParameterSpec(ECParameterSpec.class);
661     }
662 
663     // Check support for a curve with a provided Vector of EC support
664     boolean checkSupport(List&lt;ECParameterSpec&gt; supportedEC,
665             ECParameterSpec curve) {
666         for (ECParameterSpec ec: supportedEC) {
667             if (ec.equals(curve)) {
668                 return true;
669             }
670         }
671         return false;
672     }
673 
674     private static Map&lt;String,String[]&gt; osMap;
675 
676     // Location of the NSS libraries on each supported platform
677     private static Map&lt;String, String[]&gt; getOsMap() {
678         if (osMap != null) {
679             return osMap;
680         }
681 
682         osMap = new HashMap&lt;&gt;();
683         osMap.put(&quot;SunOS-sparc-32&quot;, new String[] { &quot;/usr/lib/mps/&quot; });
684         osMap.put(&quot;SunOS-sparcv9-64&quot;, new String[] { &quot;/usr/lib/mps/64/&quot; });
685         osMap.put(&quot;SunOS-x86-32&quot;, new String[] { &quot;/usr/lib/mps/&quot; });
686         osMap.put(&quot;SunOS-amd64-64&quot;, new String[] { &quot;/usr/lib/mps/64/&quot; });
687         osMap.put(&quot;Linux-i386-32&quot;, new String[] {
688                 &quot;/usr/lib/i386-linux-gnu/&quot;,
689                 &quot;/usr/lib32/&quot;,
690                 &quot;/usr/lib/&quot; });
691         osMap.put(&quot;Linux-amd64-64&quot;, new String[] {
692                 &quot;/usr/lib/x86_64-linux-gnu/&quot;,
693                 &quot;/usr/lib/x86_64-linux-gnu/nss/&quot;,
694                 &quot;/usr/lib64/&quot; });
695         osMap.put(&quot;Linux-ppc64-64&quot;, new String[] { &quot;/usr/lib64/&quot; });
696         osMap.put(&quot;Linux-ppc64le-64&quot;, new String[] { &quot;/usr/lib64/&quot; });
697         osMap.put(&quot;Linux-s390x-64&quot;, new String[] { &quot;/usr/lib64/&quot; });
698         osMap.put(&quot;Windows-x86-32&quot;, new String[] {});
699         osMap.put(&quot;Windows-amd64-64&quot;, new String[] {});
700         osMap.put(&quot;MacOSX-x86_64-64&quot;, new String[] {});
701         osMap.put(&quot;Linux-arm-32&quot;, new String[] {
702                 &quot;/usr/lib/arm-linux-gnueabi/nss/&quot;,
703                 &quot;/usr/lib/arm-linux-gnueabihf/nss/&quot; });
704         osMap.put(&quot;Linux-aarch64-64&quot;, new String[] {
705                 &quot;/usr/lib/aarch64-linux-gnu/&quot;,
706                 &quot;/usr/lib/aarch64-linux-gnu/nss/&quot; });
707         return osMap;
708     }
709 
710     private static String[] getNssLibPaths(String osId) {
711         String[] preferablePaths = getPreferableNssLibPaths(osId);
712         if (preferablePaths.length != 0) {
713             return preferablePaths;
714         } else {
715             return getOsMap().get(osId);
716         }
717     }
718 
719     private static String[] getPreferableNssLibPaths(String osId) {
720         List&lt;String&gt; nssLibPaths = new ArrayList&lt;&gt;();
721 
722         String customNssLibPaths = System.getProperty(&quot;test.nss.lib.paths&quot;);
723         if (customNssLibPaths == null) {
724             // If custom local NSS lib path is not provided,
725             // try to download NSS libs from artifactory
726             String path = fetchNssLib(osId);
727             if (path != null) {
728                 nssLibPaths.add(path);
729             }
730         } else {
731             String[] paths = customNssLibPaths.split(&quot;,&quot;);
732             for (String path : paths) {
733                 if (!path.endsWith(File.separator)) {
734                     nssLibPaths.add(path + File.separator);
735                 } else {
736                     nssLibPaths.add(path);
737                 }
738             }
739         }
740 
741         return nssLibPaths.toArray(new String[nssLibPaths.size()]);
742     }
743 
744     private final static char[] hexDigits = &quot;0123456789abcdef&quot;.toCharArray();
745 
746     private static final String distro = distro();
747 
748     static final boolean badSolarisSparc =
749             System.getProperty(&quot;os.name&quot;).equals(&quot;SunOS&quot;) &amp;&amp;
750             System.getProperty(&quot;os.arch&quot;).equals(&quot;sparcv9&quot;) &amp;&amp;
751             System.getProperty(&quot;os.version&quot;).compareTo(&quot;5.11&quot;) &lt;= 0 &amp;&amp;
752             getDistro().compareTo(&quot;11.2&quot;) &lt; 0;
753 
754     public static String toString(byte[] b) {
755         if (b == null) {
756             return &quot;(null)&quot;;
757         }
758         StringBuilder sb = new StringBuilder(b.length * 3);
759         for (int i = 0; i &lt; b.length; i++) {
760             int k = b[i] &amp; 0xff;
761             if (i != 0) {
762                 sb.append(&#39;:&#39;);
763             }
764             sb.append(hexDigits[k &gt;&gt;&gt; 4]);
765             sb.append(hexDigits[k &amp; 0xf]);
766         }
767         return sb.toString();
768     }
769 
770     public static byte[] parse(String s) {
771         if (s.equals(&quot;(null)&quot;)) {
772             return null;
773         }
774         try {
775             int n = s.length();
776             ByteArrayOutputStream out = new ByteArrayOutputStream(n / 3);
777             StringReader r = new StringReader(s);
778             while (true) {
779                 int b1 = nextNibble(r);
780                 if (b1 &lt; 0) {
781                     break;
782                 }
783                 int b2 = nextNibble(r);
784                 if (b2 &lt; 0) {
785                     throw new RuntimeException(&quot;Invalid string &quot; + s);
786                 }
787                 int b = (b1 &lt;&lt; 4) | b2;
788                 out.write(b);
789             }
790             return out.toByteArray();
791         } catch (IOException e) {
792             throw new RuntimeException(e);
793         }
794     }
795 
796     private static int nextNibble(StringReader r) throws IOException {
797         while (true) {
798             int ch = r.read();
799             if (ch == -1) {
800                 return -1;
801             } else if ((ch &gt;= &#39;0&#39;) &amp;&amp; (ch &lt;= &#39;9&#39;)) {
802                 return ch - &#39;0&#39;;
803             } else if ((ch &gt;= &#39;a&#39;) &amp;&amp; (ch &lt;= &#39;f&#39;)) {
804                 return ch - &#39;a&#39; + 10;
805             } else if ((ch &gt;= &#39;A&#39;) &amp;&amp; (ch &lt;= &#39;F&#39;)) {
806                 return ch - &#39;A&#39; + 10;
807             }
808         }
809     }
810 
811     &lt;T&gt; T[] concat(T[] a, T[] b) {
812         if ((b == null) || (b.length == 0)) {
813             return a;
814         }
815         T[] r = Arrays.copyOf(a, a.length + b.length);
816         System.arraycopy(b, 0, r, a.length, b.length);
817         return r;
818     }
819 
820     /**
821      * Returns supported algorithms of specified type.
822      */
823     static List&lt;String&gt; getSupportedAlgorithms(String type, String alg,
824             Provider p) {
825         // prepare a list of supported algorithms
826         List&lt;String&gt; algorithms = new ArrayList&lt;&gt;();
827         Set&lt;Provider.Service&gt; services = p.getServices();
828         for (Provider.Service service : services) {
829             if (service.getType().equals(type)
830                     &amp;&amp; service.getAlgorithm().startsWith(alg)) {
831                 algorithms.add(service.getAlgorithm());
832             }
833         }
834         return algorithms;
835     }
836 
837     /**
838      * Get the identifier for the operating system distribution
839      */
840     static String getDistro() {
841         return distro;
842     }
843 
844     private static String distro() {
845         if (props.getProperty(&quot;os.name&quot;).equals(&quot;SunOS&quot;)) {
846             try (BufferedReader in =
847                          new BufferedReader(new InputStreamReader(
848                                  Runtime.getRuntime().exec(&quot;uname -v&quot;).getInputStream()))) {
849 
850                 return in.readLine();
851             } catch (Exception e) {
852                 throw new RuntimeException(&quot;Failed to determine distro.&quot;, e);
853             }
854         } else {
855             // Not used outside Solaris
856             return null;
857         }
858     }
859 
860     static byte[] generateData(int length) {
861         byte data[] = new byte[length];
862         for (int i=0; i&lt;data.length; i++) {
863             data[i] = (byte) (i % 256);
864         }
865         return data;
866     }
867 
868     private static String fetchNssLib(String osId) {
869         switch (osId) {
870         case &quot;Windows-x86-32&quot;:
871             return fetchNssLib(WINDOWS_X86.class);
872 
873         case &quot;Windows-amd64-64&quot;:
874             return fetchNssLib(WINDOWS_X64.class);
875 
876         case &quot;MacOSX-x86_64-64&quot;:
877             return fetchNssLib(MACOSX_X64.class);
878 
879         default:
880             return null;
881         }
882     }
883 
884     private static String fetchNssLib(Class&lt;?&gt; clazz) {
885         String path = null;
886         try {
887             path = ArtifactResolver.resolve(clazz).entrySet().stream()
888                     .findAny().get().getValue() + File.separator + &quot;nsslib&quot;
889                     + File.separator;
890         } catch (ArtifactResolverException e) {
891             Throwable cause = e.getCause();
892             if (cause == null) {
893                 System.out.println(&quot;Cannot resolve artifact, &quot;
894                         + &quot;please check if JIB jar is present in classpath.&quot;);
895             } else {
896                 throw new RuntimeException(&quot;Fetch artifact failed: &quot; + clazz
897                         + &quot;\nPlease make sure the artifact is available.&quot;);
898             }
899         }
900         return path;
901     }
902 
903     @Artifact(
904             organization = &quot;jpg.tests.jdk.nsslib&quot;,
905             name = &quot;nsslib-windows_x64&quot;,
906             revision = &quot;3.35&quot;,
907             extension = &quot;zip&quot;)
908     private static class WINDOWS_X64 { }
909 
910     @Artifact(
911             organization = &quot;jpg.tests.jdk.nsslib&quot;,
912             name = &quot;nsslib-windows_x86&quot;,
913             revision = &quot;3.35&quot;,
914             extension = &quot;zip&quot;)
915     private static class WINDOWS_X86 { }
916 
917     @Artifact(
918             organization = &quot;jpg.tests.jdk.nsslib&quot;,
919             name = &quot;nsslib-macosx_x64&quot;,
920             revision = &quot;3.35&quot;,
921             extension = &quot;zip&quot;)
922     private static class MACOSX_X64 { }
923 }
    </pre>
  </body>
</html>
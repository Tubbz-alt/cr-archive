<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff test/jdk/sun/security/krb5/auto/KDC.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
<body>
<center><a href="../../../rmi/log/ReliableLog/Recovery.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="../../lib/cacerts/VerifyCACerts.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>test/jdk/sun/security/krb5/auto/KDC.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 148 
 149     // Under the hood.
 150 
 151     // Principal db. principal -&gt; pass. A case-insensitive TreeMap is used
 152     // so that even if the client provides a name with different case, the KDC
 153     // can still locate the principal and give back correct salt.
 154     private TreeMap&lt;String,char[]&gt; passwords = new TreeMap&lt;&gt;
 155             (String.CASE_INSENSITIVE_ORDER);
 156 
 157     // Non default salts. Precisely, there should be different salts for
 158     // different etypes, pretend they are the same at the moment.
 159     private TreeMap&lt;String,String&gt; salts = new TreeMap&lt;&gt;
 160             (String.CASE_INSENSITIVE_ORDER);
 161 
 162     // Non default s2kparams for newer etypes. Precisely, there should be
 163     // different s2kparams for different etypes, pretend they are the same
 164     // at the moment.
 165     private TreeMap&lt;String,byte[]&gt; s2kparamses = new TreeMap&lt;&gt;
 166             (String.CASE_INSENSITIVE_ORDER);
 167 








 168     // Realm name
 169     private String realm;
 170     // KDC
 171     private String kdc;
 172     // Service port number
 173     private int port;
 174     // The request/response job queue
 175     private BlockingQueue&lt;Job&gt; q = new ArrayBlockingQueue&lt;&gt;(100);
 176     // Options
 177     private Map&lt;Option,Object&gt; options = new HashMap&lt;&gt;();
 178     // Realm-specific krb5.conf settings
 179     private List&lt;String&gt; conf = new ArrayList&lt;&gt;();
 180 
 181     private Thread thread1, thread2, thread3;
 182     private volatile boolean udpConsumerReady = false;
 183     private volatile boolean tcpConsumerReady = false;
 184     private volatile boolean dispatcherReady = false;
 185     DatagramSocket u1 = null;
 186     ServerSocket t1 = null;
 187 
</pre>
<hr />
<pre>
 536             }
 537         }
 538         sb.append(&quot;\n[realms]\n&quot;);
 539         sb.append(kdc.realmLine());
 540         for (Object o : more) {
 541             if (o instanceof KDC) {
 542                 sb.append(((KDC) o).realmLine());
 543             }
 544         }
 545         Files.write(Paths.get(file), sb.toString().getBytes());
 546     }
 547 
 548     /**
 549      * Returns the service port of the KDC server.
 550      * @return the KDC service port
 551      */
 552     public int getPort() {
 553         return port;
 554     }
 555 























 556     // Private helper methods
 557 
 558     /**
 559      * Private constructor, cannot be called outside.
 560      * @param realm
 561      */
 562     private KDC(String realm, String kdc) {
 563         this.realm = realm;
 564         this.kdc = kdc;
 565         this.nativeKdc = null;
 566     }
 567 
 568     /**
 569      * A constructor that starts the KDC service also.
 570      */
 571     protected KDC(String realm, String kdc, int port, boolean asDaemon)
 572             throws IOException {
 573         this.realm = realm;
 574         this.kdc = kdc;
 575         this.nativeKdc = NativeKdc.get(this);
</pre>
<hr />
<pre>
 672                     return s2kparamses.get(pn);
 673                 }
 674                 if (etype &lt; EncryptedData.ETYPE_AES128_CTS_HMAC_SHA256_128) {
 675                     return new byte[]{0, 0, 0x10, 0};
 676                 } else {
 677                     return new byte[]{0, 0, (byte) 0x80, 0};
 678                 }
 679             default:
 680                 return null;
 681         }
 682     }
 683 
 684     /**
 685      * Returns the key for a given principal of the given encryption type
 686      * @param p the principal
 687      * @param etype the encryption type
 688      * @param server looking for a server principal?
 689      * @return the key
 690      * @throws sun.security.krb5.KrbException for unknown/unsupported etype
 691      */
<span class="line-modified"> 692     private EncryptionKey keyForUser(PrincipalName p, int etype, boolean server)</span>
 693             throws KrbException {
 694         try {
 695             // Do not call EncryptionKey.acquireSecretKeys(), otherwise
 696             // the krb5.conf config file would be loaded.
 697             Integer kvno = null;
 698             // For service whose password ending with a number, use it as kvno.
 699             // Kvno must be postive.
 700             if (p.toString().indexOf(&#39;/&#39;) &gt; 0) {
 701                 char[] pass = getPassword(p, server);
 702                 if (Character.isDigit(pass[pass.length-1])) {
 703                     kvno = pass[pass.length-1] - &#39;0&#39;;
 704                 }
 705             }
 706             return genKey0(getPassword(p, server), getSalt(p),
 707                     getParams(p, etype), etype, kvno);
 708         } catch (KrbException ke) {
 709             throw ke;
 710         } catch (Exception e) {
 711             throw new RuntimeException(e);  // should not happen
 712         }
</pre>
<hr />
<pre>
 753      */
 754     protected byte[] processTgsReq(byte[] in) throws Exception {
 755         TGSReq tgsReq = new TGSReq(in);
 756         PrincipalName service = tgsReq.reqBody.sname;
 757         if (options.containsKey(KDC.Option.RESP_NT)) {
 758             service = new PrincipalName((int)options.get(KDC.Option.RESP_NT),
 759                     service.getNameStrings(), service.getRealm());
 760         }
 761         try {
 762             System.out.println(realm + &quot;&gt; &quot; + tgsReq.reqBody.cname +
 763                     &quot; sends TGS-REQ for &quot; +
 764                     service + &quot;, &quot; + tgsReq.reqBody.kdcOptions);
 765             KDCReqBody body = tgsReq.reqBody;
 766             int[] eTypes = filterSupported(KDCReqBodyDotEType(body));
 767             if (eTypes.length == 0) {
 768                 throw new KrbException(Krb5.KDC_ERR_ETYPE_NOSUPP);
 769             }
 770             int e2 = eTypes[0];     // etype for outgoing session key
 771             int e3 = eTypes[0];     // etype for outgoing ticket
 772 
<span class="line-modified"> 773             PAData[] pas = KDCReqDotPAData(tgsReq);</span>
 774 
 775             Ticket tkt = null;
 776             EncTicketPart etp = null;
 777 
 778             PrincipalName cname = null;
 779             boolean allowForwardable = true;
















 780 
 781             if (pas == null || pas.length == 0) {
 782                 throw new KrbException(Krb5.KDC_ERR_PADATA_TYPE_NOSUPP);
 783             } else {
 784                 PrincipalName forUserCName = null;
 785                 for (PAData pa: pas) {
 786                     if (pa.getType() == Krb5.PA_TGS_REQ) {
 787                         APReq apReq = new APReq(pa.getValue());
<span class="line-removed"> 788                         EncryptedData ed = apReq.authenticator;</span>
 789                         tkt = apReq.ticket;
 790                         int te = tkt.encPart.getEType();
 791                         EncryptionKey kkey = keyForUser(tkt.sname, te, true);
 792                         byte[] bb = tkt.encPart.decrypt(kkey, KeyUsage.KU_TICKET);
 793                         DerInputStream derIn = new DerInputStream(bb);
 794                         DerValue der = derIn.getDerValue();
 795                         etp = new EncTicketPart(der.toByteArray());
 796                         // Finally, cname will be overwritten by PA-FOR-USER
 797                         // if it exists.
 798                         cname = etp.cname;
 799                         System.out.println(realm + &quot;&gt; presenting a ticket of &quot;
 800                                 + etp.cname + &quot; to &quot; + tkt.sname);
 801                     } else if (pa.getType() == Krb5.PA_FOR_USER) {
 802                         if (options.containsKey(Option.ALLOW_S4U2SELF)) {
 803                             PAForUserEnc p4u = new PAForUserEnc(
 804                                     new DerValue(pa.getValue()), null);
 805                             forUserCName = p4u.name;
 806                             System.out.println(realm + &quot;&gt; See PA_FOR_USER &quot;
 807                                     + &quot; in the name of &quot; + p4u.name);
 808                         }
</pre>
<hr />
<pre>
 947             }
 948             Ticket t = new Ticket(
 949                     System.getProperty(&quot;test.kdc.diff.sname&quot;) != null ?
 950                         new PrincipalName(&quot;xx&quot; + service.toString()) :
 951                         service,
 952                     new EncryptedData(skey, enc.asn1Encode(), KeyUsage.KU_TICKET)
 953             );
 954             EncTGSRepPart enc_part = new EncTGSRepPart(
 955                     key,
 956                     new LastReq(new LastReqEntry[] {
 957                         new LastReqEntry(0, timeAfter(-10))
 958                     }),
 959                     body.getNonce(),    // TODO: detect replay
 960                     timeAfter(3600 * 24),
 961                     // Next 5 and last MUST be same with ticket
 962                     tFlags,
 963                     timeAfter(0),
 964                     from,
 965                     till, renewTill,
 966                     service,
<span class="line-modified"> 967                     body.addresses</span>

 968                     );
 969             EncryptedData edata = new EncryptedData(ckey, enc_part.asn1Encode(),
 970                     KeyUsage.KU_ENC_TGS_REP_PART_SESSKEY);
 971             TGSRep tgsRep = new TGSRep(null,
 972                     cname,
 973                     t,
 974                     edata);
 975             System.out.println(&quot;     Return &quot; + tgsRep.cname
 976                     + &quot; ticket for &quot; + tgsRep.ticket.sname + &quot;, flags &quot;
 977                     + tFlags);
 978 
 979             DerOutputStream out = new DerOutputStream();
 980             out.write(DerValue.createTag(DerValue.TAG_APPLICATION,
 981                     true, (byte)Krb5.KRB_TGS_REP), tgsRep.asn1Encode());
 982             return out.toByteArray();
 983         } catch (KrbException ke) {
 984             ke.printStackTrace(System.out);
 985             KRBError kerr = ke.getError();
 986             KDCReqBody body = tgsReq.reqBody;
 987             System.out.println(&quot;     Error &quot; + ke.returnCode()
</pre>
<hr />
<pre>
 991                         timeAfter(0),
 992                         0,
 993                         ke.returnCode(),
 994                         body.cname,
 995                         service,
 996                         KrbException.errorMessage(ke.returnCode()),
 997                         null);
 998             }
 999             return kerr.asn1Encode();
1000         }
1001     }
1002 
1003     /**
1004      * Processes a AS_REQ and generates a AS_REP (or KRB_ERROR)
1005      * @param in the request
1006      * @return the response
1007      * @throws java.lang.Exception for various errors
1008      */
1009     protected byte[] processAsReq(byte[] in) throws Exception {
1010         ASReq asReq = new ASReq(in);

1011         int[] eTypes = null;
1012         List&lt;PAData&gt; outPAs = new ArrayList&lt;&gt;();
1013 
1014         PrincipalName service = asReq.reqBody.sname;
1015         if (options.containsKey(KDC.Option.RESP_NT)) {
1016             service = new PrincipalName((int)options.get(KDC.Option.RESP_NT),
1017                     service.getNameStrings(),
1018                     Realm.getDefault());
1019         }
1020         try {
1021             System.out.println(realm + &quot;&gt; &quot; + asReq.reqBody.cname +
1022                     &quot; sends AS-REQ for &quot; +
1023                     service + &quot;, &quot; + asReq.reqBody.kdcOptions);
1024 
1025             KDCReqBody body = asReq.reqBody;
1026 
1027             eTypes = filterSupported(KDCReqBodyDotEType(body));
1028             if (eTypes.length == 0) {
1029                 throw new KrbException(Krb5.KDC_ERR_ETYPE_NOSUPP);
1030             }
1031             int eType = eTypes[0];
1032 

















1033             EncryptionKey ckey = keyForUser(body.cname, eType, false);
1034             EncryptionKey skey = keyForUser(service, eType, true);
1035 
1036             if (options.containsKey(KDC.Option.ONLY_RC4_TGT)) {
1037                 int tgtEType = EncryptedData.ETYPE_ARCFOUR_HMAC;
1038                 boolean found = false;
1039                 for (int i=0; i&lt;eTypes.length; i++) {
1040                     if (eTypes[i] == tgtEType) {
1041                         found = true;
1042                         break;
1043                     }
1044                 }
1045                 if (!found) {
1046                     throw new KrbException(Krb5.KDC_ERR_ETYPE_NOSUPP);
1047                 }
1048                 skey = keyForUser(service, tgtEType, true);
1049             }
1050             if (ckey == null) {
1051                 throw new KrbException(Krb5.KDC_ERR_ETYPE_NOSUPP);
1052             }
</pre>
<hr />
<pre>
1193                                 epas[i],
1194                                 epas[i] == EncryptedData.ETYPE_ARCFOUR_HMAC ?
1195                                     null : getSalt(body.cname)
1196                                 ).asn1Encode());
1197                     }
1198                 }
1199             }
1200 
1201             DerOutputStream eid;
1202             if (pas2 != null) {
1203                 eid = new DerOutputStream();
1204                 eid.putSequence(pas2);
1205                 outPAs.add(new PAData(Krb5.PA_ETYPE_INFO2, eid.toByteArray()));
1206             }
1207             if (pas != null) {
1208                 eid = new DerOutputStream();
1209                 eid.putSequence(pas);
1210                 outPAs.add(new PAData(Krb5.PA_ETYPE_INFO, eid.toByteArray()));
1211             }
1212 
<span class="line-modified">1213             PAData[] inPAs = KDCReqDotPAData(asReq);</span>
<span class="line-modified">1214             if (inPAs == null || inPAs.length == 0) {</span>











1215                 Object preauth = options.get(Option.PREAUTH_REQUIRED);
1216                 if (preauth == null || preauth.equals(Boolean.TRUE)) {
1217                     throw new KrbException(Krb5.KDC_ERR_PREAUTH_REQUIRED);
1218                 }
1219             } else {

1220                 try {
1221                     EncryptedData data = newEncryptedData(
<span class="line-modified">1222                             new DerValue(inPAs[0].getValue()));</span>
<span class="line-modified">1223                     EncryptionKey pakey</span>
<span class="line-removed">1224                             = keyForUser(body.cname, data.getEType(), false);</span>
1225                     data.decrypt(pakey, KeyUsage.KU_PA_ENC_TS);
1226                 } catch (Exception e) {
1227                     KrbException ke = new KrbException(Krb5.KDC_ERR_PREAUTH_FAILED);
1228                     ke.initCause(e);
1229                     throw ke;
1230                 }
1231                 bFlags[Krb5.TKT_OPTS_PRE_AUTHENT] = true;











1232             }
1233 
1234             TicketFlags tFlags = new TicketFlags(bFlags);
1235             EncTicketPart enc = new EncTicketPart(
1236                     tFlags,
1237                     key,
1238                     body.cname,
1239                     new TransitedEncoding(1, new byte[0]),
1240                     timeAfter(0),
1241                     from,
1242                     till, rtime,
1243                     body.addresses,
1244                     null);
1245             Ticket t = new Ticket(
1246                     service,
1247                     new EncryptedData(skey, enc.asn1Encode(), KeyUsage.KU_TICKET)
1248             );
1249             EncASRepPart enc_part = new EncASRepPart(
1250                     key,
1251                     new LastReq(new LastReqEntry[]{
1252                         new LastReqEntry(0, timeAfter(-10))
1253                     }),
1254                     body.getNonce(),    // TODO: detect replay?
1255                     timeAfter(3600 * 24),
1256                     // Next 5 and last MUST be same with ticket
1257                     tFlags,
1258                     timeAfter(0),
1259                     from,
1260                     till, rtime,
1261                     service,
<span class="line-modified">1262                     body.addresses</span>

1263                     );
1264             EncryptedData edata = new EncryptedData(ckey, enc_part.asn1Encode(),
1265                     KeyUsage.KU_ENC_AS_REP_PART);
1266             ASRep asRep = new ASRep(
1267                     outPAs.toArray(new PAData[outPAs.size()]),
1268                     body.cname,
1269                     t,
1270                     edata);
1271 
1272             System.out.println(&quot;     Return &quot; + asRep.cname
1273                     + &quot; ticket for &quot; + asRep.ticket.sname + &quot;, flags &quot;
1274                     + tFlags);
1275 
1276             DerOutputStream out = new DerOutputStream();
1277             out.write(DerValue.createTag(DerValue.TAG_APPLICATION,
1278                     true, (byte)Krb5.KRB_AS_REP), asRep.asn1Encode());
1279             byte[] result = out.toByteArray();
1280 
1281             // Added feature:
1282             // Write the current issuing TGT into a ccache file specified
</pre>
<hr />
<pre>
1290                     CredentialsCache.create(asReq.reqBody.cname, ccache);
1291                 if (cache == null) {
1292                    throw new IOException(&quot;Unable to create the cache file &quot; +
1293                                          ccache);
1294                 }
1295                 cache.update(credentials);
1296                 cache.save();
1297             }
1298 
1299             return result;
1300         } catch (KrbException ke) {
1301             ke.printStackTrace(System.out);
1302             KRBError kerr = ke.getError();
1303             KDCReqBody body = asReq.reqBody;
1304             System.out.println(&quot;     Error &quot; + ke.returnCode()
1305                     + &quot; &quot; +ke.returnCodeMessage());
1306             byte[] eData = null;
1307             if (kerr == null) {
1308                 if (ke.returnCode() == Krb5.KDC_ERR_PREAUTH_REQUIRED ||
1309                         ke.returnCode() == Krb5.KDC_ERR_PREAUTH_FAILED) {



1310                     DerOutputStream bytes = new DerOutputStream();
<span class="line-removed">1311                     bytes.write(new PAData(Krb5.PA_ENC_TIMESTAMP, new byte[0]).asn1Encode());</span>
1312                     for (PAData p: outPAs) {
1313                         bytes.write(p.asn1Encode());
1314                     }
1315                     DerOutputStream temp = new DerOutputStream();
1316                     temp.write(DerValue.tag_Sequence, bytes);
1317                     eData = temp.toByteArray();
1318                 }
1319                 kerr = new KRBError(null, null, null,
1320                         timeAfter(0),
1321                         0,
1322                         ke.returnCode(),
1323                         body.cname,
1324                         service,
1325                         KrbException.errorMessage(ke.returnCode()),
1326                         eData);
1327             }
1328             return kerr.asn1Encode();
1329         }
1330     }
1331 
</pre>
<hr />
<pre>
1880                         &quot;\n[logging]&quot;,
1881                         &quot;kdc = FILE:&quot; + base + &quot;/krb5kdc.log&quot;
1882                 ));
1883             } catch (IOException e) {
1884                 throw new UncheckedIOException(e);
1885             }
1886         }
1887 
1888         @Override
1889         void kinit(String user, String ccache) {
1890             String tmpName = base + &quot;/&quot; + user + &quot;.&quot; +
1891                     System.identityHashCode(this) + &quot;.keytab&quot;;
1892             ktadd(user, tmpName);
1893             run(true, nativePath +
1894                     (install ? &quot;/bin/&quot; : &quot;/clients/kinit/&quot;) + &quot;kinit&quot;,
1895                     &quot;-f&quot;, &quot;-t&quot;, tmpName, &quot;-c&quot;, ccache, user);
1896         }
1897     }
1898 
1899     // Calling private methods thru reflections
<span class="line-removed">1900     private static final Field getPADataField;</span>
1901     private static final Field getEType;
1902     private static final Constructor&lt;EncryptedData&gt; ctorEncryptedData;
1903     private static final Method stringToKey;
1904     private static final Field getAddlTkt;
1905 
1906     static {
1907         try {
1908             ctorEncryptedData = EncryptedData.class.getDeclaredConstructor(DerValue.class);
1909             ctorEncryptedData.setAccessible(true);
<span class="line-removed">1910             getPADataField = KDCReq.class.getDeclaredField(&quot;pAData&quot;);</span>
<span class="line-removed">1911             getPADataField.setAccessible(true);</span>
1912             getEType = KDCReqBody.class.getDeclaredField(&quot;eType&quot;);
1913             getEType.setAccessible(true);
1914             stringToKey = EncryptionKey.class.getDeclaredMethod(
1915                     &quot;stringToKey&quot;,
1916                     char[].class, String.class, byte[].class, Integer.TYPE);
1917             stringToKey.setAccessible(true);
1918             getAddlTkt = KDCReqBody.class.getDeclaredField(&quot;additionalTickets&quot;);
1919             getAddlTkt.setAccessible(true);
1920         } catch (NoSuchFieldException nsfe) {
1921             throw new AssertionError(nsfe);
1922         } catch (NoSuchMethodException nsme) {
1923             throw new AssertionError(nsme);
1924         }
1925     }
1926     private EncryptedData newEncryptedData(DerValue der) {
1927         try {
1928             return ctorEncryptedData.newInstance(der);
1929         } catch (Exception e) {
1930             throw new AssertionError(e);
1931         }
1932     }
<span class="line-removed">1933     private static PAData[] KDCReqDotPAData(KDCReq req) {</span>
<span class="line-removed">1934         try {</span>
<span class="line-removed">1935             return (PAData[])getPADataField.get(req);</span>
<span class="line-removed">1936         } catch (Exception e) {</span>
<span class="line-removed">1937             throw new AssertionError(e);</span>
<span class="line-removed">1938         }</span>
<span class="line-removed">1939     }</span>
1940     private static int[] KDCReqBodyDotEType(KDCReqBody body) {
1941         try {
1942             return (int[]) getEType.get(body);
1943         } catch (Exception e) {
1944             throw new AssertionError(e);
1945         }
1946     }
1947     private static byte[] EncryptionKeyDotStringToKey(char[] password, String salt,
1948             byte[] s2kparams, int keyType) throws KrbCryptoException {
1949         try {
1950             return (byte[])stringToKey.invoke(
1951                     null, password, salt, s2kparams, keyType);
1952         } catch (InvocationTargetException ex) {
1953             throw (KrbCryptoException)ex.getCause();
1954         } catch (Exception e) {
1955             throw new AssertionError(e);
1956         }
1957     }
1958     private static Ticket KDCReqBodyDotFirstAdditionalTicket(KDCReqBody body) {
1959         try {
</pre>
</td>
<td>
<hr />
<pre>
 148 
 149     // Under the hood.
 150 
 151     // Principal db. principal -&gt; pass. A case-insensitive TreeMap is used
 152     // so that even if the client provides a name with different case, the KDC
 153     // can still locate the principal and give back correct salt.
 154     private TreeMap&lt;String,char[]&gt; passwords = new TreeMap&lt;&gt;
 155             (String.CASE_INSENSITIVE_ORDER);
 156 
 157     // Non default salts. Precisely, there should be different salts for
 158     // different etypes, pretend they are the same at the moment.
 159     private TreeMap&lt;String,String&gt; salts = new TreeMap&lt;&gt;
 160             (String.CASE_INSENSITIVE_ORDER);
 161 
 162     // Non default s2kparams for newer etypes. Precisely, there should be
 163     // different s2kparams for different etypes, pretend they are the same
 164     // at the moment.
 165     private TreeMap&lt;String,byte[]&gt; s2kparamses = new TreeMap&lt;&gt;
 166             (String.CASE_INSENSITIVE_ORDER);
 167 
<span class="line-added"> 168     // Alias for referrals.</span>
<span class="line-added"> 169     private TreeMap&lt;String,KDC&gt; aliasReferrals = new TreeMap&lt;&gt;</span>
<span class="line-added"> 170             (String.CASE_INSENSITIVE_ORDER);</span>
<span class="line-added"> 171 </span>
<span class="line-added"> 172     // Alias for local resolution.</span>
<span class="line-added"> 173     private TreeMap&lt;String,PrincipalName&gt; alias2Principals = new TreeMap&lt;&gt;</span>
<span class="line-added"> 174             (String.CASE_INSENSITIVE_ORDER);</span>
<span class="line-added"> 175 </span>
 176     // Realm name
 177     private String realm;
 178     // KDC
 179     private String kdc;
 180     // Service port number
 181     private int port;
 182     // The request/response job queue
 183     private BlockingQueue&lt;Job&gt; q = new ArrayBlockingQueue&lt;&gt;(100);
 184     // Options
 185     private Map&lt;Option,Object&gt; options = new HashMap&lt;&gt;();
 186     // Realm-specific krb5.conf settings
 187     private List&lt;String&gt; conf = new ArrayList&lt;&gt;();
 188 
 189     private Thread thread1, thread2, thread3;
 190     private volatile boolean udpConsumerReady = false;
 191     private volatile boolean tcpConsumerReady = false;
 192     private volatile boolean dispatcherReady = false;
 193     DatagramSocket u1 = null;
 194     ServerSocket t1 = null;
 195 
</pre>
<hr />
<pre>
 544             }
 545         }
 546         sb.append(&quot;\n[realms]\n&quot;);
 547         sb.append(kdc.realmLine());
 548         for (Object o : more) {
 549             if (o instanceof KDC) {
 550                 sb.append(((KDC) o).realmLine());
 551             }
 552         }
 553         Files.write(Paths.get(file), sb.toString().getBytes());
 554     }
 555 
 556     /**
 557      * Returns the service port of the KDC server.
 558      * @return the KDC service port
 559      */
 560     public int getPort() {
 561         return port;
 562     }
 563 
<span class="line-added"> 564     /**</span>
<span class="line-added"> 565      * Register an alias name to be referred to a different KDC for</span>
<span class="line-added"> 566      * resolution, according to RFC 6806.</span>
<span class="line-added"> 567      * @param alias Alias name (i.e. user@REALM.COM).</span>
<span class="line-added"> 568      * @param referredKDC KDC to which the alias is referred for resolution.</span>
<span class="line-added"> 569      */</span>
<span class="line-added"> 570     public void registerAlias(String alias, KDC referredKDC) {</span>
<span class="line-added"> 571         aliasReferrals.remove(alias);</span>
<span class="line-added"> 572         aliasReferrals.put(alias, referredKDC);</span>
<span class="line-added"> 573     }</span>
<span class="line-added"> 574 </span>
<span class="line-added"> 575     /**</span>
<span class="line-added"> 576      * Register an alias to be resolved to a Principal Name locally,</span>
<span class="line-added"> 577      * according to RFC 6806.</span>
<span class="line-added"> 578      * @param alias Alias name (i.e. user@REALM.COM).</span>
<span class="line-added"> 579      * @param user Principal Name to which the alias is resolved.</span>
<span class="line-added"> 580      */</span>
<span class="line-added"> 581     public void registerAlias(String alias, String user)</span>
<span class="line-added"> 582             throws RealmException {</span>
<span class="line-added"> 583         alias2Principals.remove(alias);</span>
<span class="line-added"> 584         alias2Principals.put(alias, new PrincipalName(user));</span>
<span class="line-added"> 585     }</span>
<span class="line-added"> 586 </span>
 587     // Private helper methods
 588 
 589     /**
 590      * Private constructor, cannot be called outside.
 591      * @param realm
 592      */
 593     private KDC(String realm, String kdc) {
 594         this.realm = realm;
 595         this.kdc = kdc;
 596         this.nativeKdc = null;
 597     }
 598 
 599     /**
 600      * A constructor that starts the KDC service also.
 601      */
 602     protected KDC(String realm, String kdc, int port, boolean asDaemon)
 603             throws IOException {
 604         this.realm = realm;
 605         this.kdc = kdc;
 606         this.nativeKdc = NativeKdc.get(this);
</pre>
<hr />
<pre>
 703                     return s2kparamses.get(pn);
 704                 }
 705                 if (etype &lt; EncryptedData.ETYPE_AES128_CTS_HMAC_SHA256_128) {
 706                     return new byte[]{0, 0, 0x10, 0};
 707                 } else {
 708                     return new byte[]{0, 0, (byte) 0x80, 0};
 709                 }
 710             default:
 711                 return null;
 712         }
 713     }
 714 
 715     /**
 716      * Returns the key for a given principal of the given encryption type
 717      * @param p the principal
 718      * @param etype the encryption type
 719      * @param server looking for a server principal?
 720      * @return the key
 721      * @throws sun.security.krb5.KrbException for unknown/unsupported etype
 722      */
<span class="line-modified"> 723     EncryptionKey keyForUser(PrincipalName p, int etype, boolean server)</span>
 724             throws KrbException {
 725         try {
 726             // Do not call EncryptionKey.acquireSecretKeys(), otherwise
 727             // the krb5.conf config file would be loaded.
 728             Integer kvno = null;
 729             // For service whose password ending with a number, use it as kvno.
 730             // Kvno must be postive.
 731             if (p.toString().indexOf(&#39;/&#39;) &gt; 0) {
 732                 char[] pass = getPassword(p, server);
 733                 if (Character.isDigit(pass[pass.length-1])) {
 734                     kvno = pass[pass.length-1] - &#39;0&#39;;
 735                 }
 736             }
 737             return genKey0(getPassword(p, server), getSalt(p),
 738                     getParams(p, etype), etype, kvno);
 739         } catch (KrbException ke) {
 740             throw ke;
 741         } catch (Exception e) {
 742             throw new RuntimeException(e);  // should not happen
 743         }
</pre>
<hr />
<pre>
 784      */
 785     protected byte[] processTgsReq(byte[] in) throws Exception {
 786         TGSReq tgsReq = new TGSReq(in);
 787         PrincipalName service = tgsReq.reqBody.sname;
 788         if (options.containsKey(KDC.Option.RESP_NT)) {
 789             service = new PrincipalName((int)options.get(KDC.Option.RESP_NT),
 790                     service.getNameStrings(), service.getRealm());
 791         }
 792         try {
 793             System.out.println(realm + &quot;&gt; &quot; + tgsReq.reqBody.cname +
 794                     &quot; sends TGS-REQ for &quot; +
 795                     service + &quot;, &quot; + tgsReq.reqBody.kdcOptions);
 796             KDCReqBody body = tgsReq.reqBody;
 797             int[] eTypes = filterSupported(KDCReqBodyDotEType(body));
 798             if (eTypes.length == 0) {
 799                 throw new KrbException(Krb5.KDC_ERR_ETYPE_NOSUPP);
 800             }
 801             int e2 = eTypes[0];     // etype for outgoing session key
 802             int e3 = eTypes[0];     // etype for outgoing ticket
 803 
<span class="line-modified"> 804             PAData[] pas = tgsReq.pAData;</span>
 805 
 806             Ticket tkt = null;
 807             EncTicketPart etp = null;
 808 
 809             PrincipalName cname = null;
 810             boolean allowForwardable = true;
<span class="line-added"> 811             boolean isReferral = false;</span>
<span class="line-added"> 812             if (body.kdcOptions.get(KDCOptions.CANONICALIZE)) {</span>
<span class="line-added"> 813                 System.out.println(realm + &quot;&gt; verifying referral for &quot; +</span>
<span class="line-added"> 814                         body.sname.getNameString());</span>
<span class="line-added"> 815                 KDC referral = aliasReferrals.get(body.sname.getNameString());</span>
<span class="line-added"> 816                 if (referral != null) {</span>
<span class="line-added"> 817                     service = new PrincipalName(</span>
<span class="line-added"> 818                             PrincipalName.TGS_DEFAULT_SRV_NAME +</span>
<span class="line-added"> 819                             PrincipalName.NAME_COMPONENT_SEPARATOR_STR +</span>
<span class="line-added"> 820                             referral.getRealm(), PrincipalName.KRB_NT_SRV_INST,</span>
<span class="line-added"> 821                             this.getRealm());</span>
<span class="line-added"> 822                     System.out.println(realm + &quot;&gt; referral to &quot; +</span>
<span class="line-added"> 823                             referral.getRealm());</span>
<span class="line-added"> 824                     isReferral = true;</span>
<span class="line-added"> 825                 }</span>
<span class="line-added"> 826             }</span>
 827 
 828             if (pas == null || pas.length == 0) {
 829                 throw new KrbException(Krb5.KDC_ERR_PADATA_TYPE_NOSUPP);
 830             } else {
 831                 PrincipalName forUserCName = null;
 832                 for (PAData pa: pas) {
 833                     if (pa.getType() == Krb5.PA_TGS_REQ) {
 834                         APReq apReq = new APReq(pa.getValue());

 835                         tkt = apReq.ticket;
 836                         int te = tkt.encPart.getEType();
 837                         EncryptionKey kkey = keyForUser(tkt.sname, te, true);
 838                         byte[] bb = tkt.encPart.decrypt(kkey, KeyUsage.KU_TICKET);
 839                         DerInputStream derIn = new DerInputStream(bb);
 840                         DerValue der = derIn.getDerValue();
 841                         etp = new EncTicketPart(der.toByteArray());
 842                         // Finally, cname will be overwritten by PA-FOR-USER
 843                         // if it exists.
 844                         cname = etp.cname;
 845                         System.out.println(realm + &quot;&gt; presenting a ticket of &quot;
 846                                 + etp.cname + &quot; to &quot; + tkt.sname);
 847                     } else if (pa.getType() == Krb5.PA_FOR_USER) {
 848                         if (options.containsKey(Option.ALLOW_S4U2SELF)) {
 849                             PAForUserEnc p4u = new PAForUserEnc(
 850                                     new DerValue(pa.getValue()), null);
 851                             forUserCName = p4u.name;
 852                             System.out.println(realm + &quot;&gt; See PA_FOR_USER &quot;
 853                                     + &quot; in the name of &quot; + p4u.name);
 854                         }
</pre>
<hr />
<pre>
 993             }
 994             Ticket t = new Ticket(
 995                     System.getProperty(&quot;test.kdc.diff.sname&quot;) != null ?
 996                         new PrincipalName(&quot;xx&quot; + service.toString()) :
 997                         service,
 998                     new EncryptedData(skey, enc.asn1Encode(), KeyUsage.KU_TICKET)
 999             );
1000             EncTGSRepPart enc_part = new EncTGSRepPart(
1001                     key,
1002                     new LastReq(new LastReqEntry[] {
1003                         new LastReqEntry(0, timeAfter(-10))
1004                     }),
1005                     body.getNonce(),    // TODO: detect replay
1006                     timeAfter(3600 * 24),
1007                     // Next 5 and last MUST be same with ticket
1008                     tFlags,
1009                     timeAfter(0),
1010                     from,
1011                     till, renewTill,
1012                     service,
<span class="line-modified">1013                     body.addresses,</span>
<span class="line-added">1014                     null</span>
1015                     );
1016             EncryptedData edata = new EncryptedData(ckey, enc_part.asn1Encode(),
1017                     KeyUsage.KU_ENC_TGS_REP_PART_SESSKEY);
1018             TGSRep tgsRep = new TGSRep(null,
1019                     cname,
1020                     t,
1021                     edata);
1022             System.out.println(&quot;     Return &quot; + tgsRep.cname
1023                     + &quot; ticket for &quot; + tgsRep.ticket.sname + &quot;, flags &quot;
1024                     + tFlags);
1025 
1026             DerOutputStream out = new DerOutputStream();
1027             out.write(DerValue.createTag(DerValue.TAG_APPLICATION,
1028                     true, (byte)Krb5.KRB_TGS_REP), tgsRep.asn1Encode());
1029             return out.toByteArray();
1030         } catch (KrbException ke) {
1031             ke.printStackTrace(System.out);
1032             KRBError kerr = ke.getError();
1033             KDCReqBody body = tgsReq.reqBody;
1034             System.out.println(&quot;     Error &quot; + ke.returnCode()
</pre>
<hr />
<pre>
1038                         timeAfter(0),
1039                         0,
1040                         ke.returnCode(),
1041                         body.cname,
1042                         service,
1043                         KrbException.errorMessage(ke.returnCode()),
1044                         null);
1045             }
1046             return kerr.asn1Encode();
1047         }
1048     }
1049 
1050     /**
1051      * Processes a AS_REQ and generates a AS_REP (or KRB_ERROR)
1052      * @param in the request
1053      * @return the response
1054      * @throws java.lang.Exception for various errors
1055      */
1056     protected byte[] processAsReq(byte[] in) throws Exception {
1057         ASReq asReq = new ASReq(in);
<span class="line-added">1058         byte[] asReqbytes = asReq.asn1Encode();</span>
1059         int[] eTypes = null;
1060         List&lt;PAData&gt; outPAs = new ArrayList&lt;&gt;();
1061 
1062         PrincipalName service = asReq.reqBody.sname;
1063         if (options.containsKey(KDC.Option.RESP_NT)) {
1064             service = new PrincipalName((int)options.get(KDC.Option.RESP_NT),
1065                     service.getNameStrings(),
1066                     Realm.getDefault());
1067         }
1068         try {
1069             System.out.println(realm + &quot;&gt; &quot; + asReq.reqBody.cname +
1070                     &quot; sends AS-REQ for &quot; +
1071                     service + &quot;, &quot; + asReq.reqBody.kdcOptions);
1072 
1073             KDCReqBody body = asReq.reqBody;
1074 
1075             eTypes = filterSupported(KDCReqBodyDotEType(body));
1076             if (eTypes.length == 0) {
1077                 throw new KrbException(Krb5.KDC_ERR_ETYPE_NOSUPP);
1078             }
1079             int eType = eTypes[0];
1080 
<span class="line-added">1081             if (body.kdcOptions.get(KDCOptions.CANONICALIZE)) {</span>
<span class="line-added">1082                 PrincipalName principal = alias2Principals.get(</span>
<span class="line-added">1083                         body.cname.getNameString());</span>
<span class="line-added">1084                 if (principal != null) {</span>
<span class="line-added">1085                     body.cname = principal;</span>
<span class="line-added">1086                 } else {</span>
<span class="line-added">1087                     KDC referral = aliasReferrals.get(body.cname.getNameString());</span>
<span class="line-added">1088                     if (referral != null) {</span>
<span class="line-added">1089                         body.cname = new PrincipalName(</span>
<span class="line-added">1090                                 PrincipalName.TGS_DEFAULT_SRV_NAME,</span>
<span class="line-added">1091                                 PrincipalName.KRB_NT_SRV_INST,</span>
<span class="line-added">1092                                 referral.getRealm());</span>
<span class="line-added">1093                         throw new KrbException(Krb5.KRB_ERR_WRONG_REALM);</span>
<span class="line-added">1094                     }</span>
<span class="line-added">1095                 }</span>
<span class="line-added">1096             }</span>
<span class="line-added">1097 </span>
1098             EncryptionKey ckey = keyForUser(body.cname, eType, false);
1099             EncryptionKey skey = keyForUser(service, eType, true);
1100 
1101             if (options.containsKey(KDC.Option.ONLY_RC4_TGT)) {
1102                 int tgtEType = EncryptedData.ETYPE_ARCFOUR_HMAC;
1103                 boolean found = false;
1104                 for (int i=0; i&lt;eTypes.length; i++) {
1105                     if (eTypes[i] == tgtEType) {
1106                         found = true;
1107                         break;
1108                     }
1109                 }
1110                 if (!found) {
1111                     throw new KrbException(Krb5.KDC_ERR_ETYPE_NOSUPP);
1112                 }
1113                 skey = keyForUser(service, tgtEType, true);
1114             }
1115             if (ckey == null) {
1116                 throw new KrbException(Krb5.KDC_ERR_ETYPE_NOSUPP);
1117             }
</pre>
<hr />
<pre>
1258                                 epas[i],
1259                                 epas[i] == EncryptedData.ETYPE_ARCFOUR_HMAC ?
1260                                     null : getSalt(body.cname)
1261                                 ).asn1Encode());
1262                     }
1263                 }
1264             }
1265 
1266             DerOutputStream eid;
1267             if (pas2 != null) {
1268                 eid = new DerOutputStream();
1269                 eid.putSequence(pas2);
1270                 outPAs.add(new PAData(Krb5.PA_ETYPE_INFO2, eid.toByteArray()));
1271             }
1272             if (pas != null) {
1273                 eid = new DerOutputStream();
1274                 eid.putSequence(pas);
1275                 outPAs.add(new PAData(Krb5.PA_ETYPE_INFO, eid.toByteArray()));
1276             }
1277 
<span class="line-modified">1278             PAData[] inPAs = asReq.pAData;</span>
<span class="line-modified">1279             List&lt;PAData&gt; enc_outPAs = new ArrayList&lt;&gt;();</span>
<span class="line-added">1280 </span>
<span class="line-added">1281             byte[] paEncTimestamp = null;</span>
<span class="line-added">1282             if (inPAs != null) {</span>
<span class="line-added">1283                 for (PAData inPA : inPAs) {</span>
<span class="line-added">1284                     if (inPA.getType() == Krb5.PA_ENC_TIMESTAMP) {</span>
<span class="line-added">1285                         paEncTimestamp = inPA.getValue();</span>
<span class="line-added">1286                     }</span>
<span class="line-added">1287                 }</span>
<span class="line-added">1288             }</span>
<span class="line-added">1289 </span>
<span class="line-added">1290             if (paEncTimestamp == null) {</span>
1291                 Object preauth = options.get(Option.PREAUTH_REQUIRED);
1292                 if (preauth == null || preauth.equals(Boolean.TRUE)) {
1293                     throw new KrbException(Krb5.KDC_ERR_PREAUTH_REQUIRED);
1294                 }
1295             } else {
<span class="line-added">1296                 EncryptionKey pakey = null;</span>
1297                 try {
1298                     EncryptedData data = newEncryptedData(
<span class="line-modified">1299                             new DerValue(paEncTimestamp));</span>
<span class="line-modified">1300                     pakey = keyForUser(body.cname, data.getEType(), false);</span>

1301                     data.decrypt(pakey, KeyUsage.KU_PA_ENC_TS);
1302                 } catch (Exception e) {
1303                     KrbException ke = new KrbException(Krb5.KDC_ERR_PREAUTH_FAILED);
1304                     ke.initCause(e);
1305                     throw ke;
1306                 }
1307                 bFlags[Krb5.TKT_OPTS_PRE_AUTHENT] = true;
<span class="line-added">1308                 for (PAData pa : inPAs) {</span>
<span class="line-added">1309                     if (pa.getType() == Krb5.PA_REQ_ENC_PA_REP) {</span>
<span class="line-added">1310                         Checksum ckSum = new Checksum(</span>
<span class="line-added">1311                                 Checksum.CKSUMTYPE_HMAC_SHA1_96_AES128,</span>
<span class="line-added">1312                                 asReqbytes, ckey, KeyUsage.KU_AS_REQ);</span>
<span class="line-added">1313                         enc_outPAs.add(new PAData(Krb5.PA_REQ_ENC_PA_REP,</span>
<span class="line-added">1314                                 ckSum.asn1Encode()));</span>
<span class="line-added">1315                         bFlags[Krb5.TKT_OPTS_ENC_PA_REP] = true;</span>
<span class="line-added">1316                         break;</span>
<span class="line-added">1317                     }</span>
<span class="line-added">1318                 }</span>
1319             }
1320 
1321             TicketFlags tFlags = new TicketFlags(bFlags);
1322             EncTicketPart enc = new EncTicketPart(
1323                     tFlags,
1324                     key,
1325                     body.cname,
1326                     new TransitedEncoding(1, new byte[0]),
1327                     timeAfter(0),
1328                     from,
1329                     till, rtime,
1330                     body.addresses,
1331                     null);
1332             Ticket t = new Ticket(
1333                     service,
1334                     new EncryptedData(skey, enc.asn1Encode(), KeyUsage.KU_TICKET)
1335             );
1336             EncASRepPart enc_part = new EncASRepPart(
1337                     key,
1338                     new LastReq(new LastReqEntry[]{
1339                         new LastReqEntry(0, timeAfter(-10))
1340                     }),
1341                     body.getNonce(),    // TODO: detect replay?
1342                     timeAfter(3600 * 24),
1343                     // Next 5 and last MUST be same with ticket
1344                     tFlags,
1345                     timeAfter(0),
1346                     from,
1347                     till, rtime,
1348                     service,
<span class="line-modified">1349                     body.addresses,</span>
<span class="line-added">1350                     enc_outPAs.toArray(new PAData[enc_outPAs.size()])</span>
1351                     );
1352             EncryptedData edata = new EncryptedData(ckey, enc_part.asn1Encode(),
1353                     KeyUsage.KU_ENC_AS_REP_PART);
1354             ASRep asRep = new ASRep(
1355                     outPAs.toArray(new PAData[outPAs.size()]),
1356                     body.cname,
1357                     t,
1358                     edata);
1359 
1360             System.out.println(&quot;     Return &quot; + asRep.cname
1361                     + &quot; ticket for &quot; + asRep.ticket.sname + &quot;, flags &quot;
1362                     + tFlags);
1363 
1364             DerOutputStream out = new DerOutputStream();
1365             out.write(DerValue.createTag(DerValue.TAG_APPLICATION,
1366                     true, (byte)Krb5.KRB_AS_REP), asRep.asn1Encode());
1367             byte[] result = out.toByteArray();
1368 
1369             // Added feature:
1370             // Write the current issuing TGT into a ccache file specified
</pre>
<hr />
<pre>
1378                     CredentialsCache.create(asReq.reqBody.cname, ccache);
1379                 if (cache == null) {
1380                    throw new IOException(&quot;Unable to create the cache file &quot; +
1381                                          ccache);
1382                 }
1383                 cache.update(credentials);
1384                 cache.save();
1385             }
1386 
1387             return result;
1388         } catch (KrbException ke) {
1389             ke.printStackTrace(System.out);
1390             KRBError kerr = ke.getError();
1391             KDCReqBody body = asReq.reqBody;
1392             System.out.println(&quot;     Error &quot; + ke.returnCode()
1393                     + &quot; &quot; +ke.returnCodeMessage());
1394             byte[] eData = null;
1395             if (kerr == null) {
1396                 if (ke.returnCode() == Krb5.KDC_ERR_PREAUTH_REQUIRED ||
1397                         ke.returnCode() == Krb5.KDC_ERR_PREAUTH_FAILED) {
<span class="line-added">1398                     outPAs.add(new PAData(Krb5.PA_ENC_TIMESTAMP, new byte[0]));</span>
<span class="line-added">1399                 }</span>
<span class="line-added">1400                 if (outPAs.size() &gt; 0) {</span>
1401                     DerOutputStream bytes = new DerOutputStream();

1402                     for (PAData p: outPAs) {
1403                         bytes.write(p.asn1Encode());
1404                     }
1405                     DerOutputStream temp = new DerOutputStream();
1406                     temp.write(DerValue.tag_Sequence, bytes);
1407                     eData = temp.toByteArray();
1408                 }
1409                 kerr = new KRBError(null, null, null,
1410                         timeAfter(0),
1411                         0,
1412                         ke.returnCode(),
1413                         body.cname,
1414                         service,
1415                         KrbException.errorMessage(ke.returnCode()),
1416                         eData);
1417             }
1418             return kerr.asn1Encode();
1419         }
1420     }
1421 
</pre>
<hr />
<pre>
1970                         &quot;\n[logging]&quot;,
1971                         &quot;kdc = FILE:&quot; + base + &quot;/krb5kdc.log&quot;
1972                 ));
1973             } catch (IOException e) {
1974                 throw new UncheckedIOException(e);
1975             }
1976         }
1977 
1978         @Override
1979         void kinit(String user, String ccache) {
1980             String tmpName = base + &quot;/&quot; + user + &quot;.&quot; +
1981                     System.identityHashCode(this) + &quot;.keytab&quot;;
1982             ktadd(user, tmpName);
1983             run(true, nativePath +
1984                     (install ? &quot;/bin/&quot; : &quot;/clients/kinit/&quot;) + &quot;kinit&quot;,
1985                     &quot;-f&quot;, &quot;-t&quot;, tmpName, &quot;-c&quot;, ccache, user);
1986         }
1987     }
1988 
1989     // Calling private methods thru reflections

1990     private static final Field getEType;
1991     private static final Constructor&lt;EncryptedData&gt; ctorEncryptedData;
1992     private static final Method stringToKey;
1993     private static final Field getAddlTkt;
1994 
1995     static {
1996         try {
1997             ctorEncryptedData = EncryptedData.class.getDeclaredConstructor(DerValue.class);
1998             ctorEncryptedData.setAccessible(true);


1999             getEType = KDCReqBody.class.getDeclaredField(&quot;eType&quot;);
2000             getEType.setAccessible(true);
2001             stringToKey = EncryptionKey.class.getDeclaredMethod(
2002                     &quot;stringToKey&quot;,
2003                     char[].class, String.class, byte[].class, Integer.TYPE);
2004             stringToKey.setAccessible(true);
2005             getAddlTkt = KDCReqBody.class.getDeclaredField(&quot;additionalTickets&quot;);
2006             getAddlTkt.setAccessible(true);
2007         } catch (NoSuchFieldException nsfe) {
2008             throw new AssertionError(nsfe);
2009         } catch (NoSuchMethodException nsme) {
2010             throw new AssertionError(nsme);
2011         }
2012     }
2013     private EncryptedData newEncryptedData(DerValue der) {
2014         try {
2015             return ctorEncryptedData.newInstance(der);
2016         } catch (Exception e) {
2017             throw new AssertionError(e);
2018         }
2019     }







2020     private static int[] KDCReqBodyDotEType(KDCReqBody body) {
2021         try {
2022             return (int[]) getEType.get(body);
2023         } catch (Exception e) {
2024             throw new AssertionError(e);
2025         }
2026     }
2027     private static byte[] EncryptionKeyDotStringToKey(char[] password, String salt,
2028             byte[] s2kparams, int keyType) throws KrbCryptoException {
2029         try {
2030             return (byte[])stringToKey.invoke(
2031                     null, password, salt, s2kparams, keyType);
2032         } catch (InvocationTargetException ex) {
2033             throw (KrbCryptoException)ex.getCause();
2034         } catch (Exception e) {
2035             throw new AssertionError(e);
2036         }
2037     }
2038     private static Ticket KDCReqBodyDotFirstAdditionalTicket(KDCReqBody body) {
2039         try {
</pre>
</td>
</tr>
</table>
<center><a href="../../../rmi/log/ReliableLog/Recovery.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="../../lib/cacerts/VerifyCACerts.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
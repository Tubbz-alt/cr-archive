<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New test/jdk/sun/security/tools/jarsigner/compatibility/Compatibility.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 2017, 2019, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  */
  23 
  24 /*
  25  * @test
  26  * @bug 8217375
  27  * @summary This test is used to verify the compatibility of jarsigner across
  28  *     different JDK releases. It also can be used to check jar signing (w/
  29  *     and w/o TSA) and to verify some specific signing and digest algorithms.
  30  *     Note that this is a manual test. For more details about the test and
  31  *     its usages, please look through the README.
  32  *
  33  * @library /test/lib ../warnings
  34  * @compile -source 1.7 -target 1.7 JdkUtils.java
  35  * @run main/manual/othervm Compatibility
  36  */
  37 
  38 import static java.nio.charset.StandardCharsets.UTF_8;
  39 
  40 import java.io.BufferedReader;
  41 import java.io.File;
  42 import java.io.FileOutputStream;
  43 import java.io.FileReader;
  44 import java.io.FileWriter;
  45 import java.io.IOException;
  46 import java.io.OutputStream;
  47 import java.io.PrintStream;
  48 import java.nio.file.Files;
  49 import java.nio.file.Path;
  50 import java.text.DateFormat;
  51 import java.text.SimpleDateFormat;
  52 import java.util.ArrayList;
  53 import java.util.Arrays;
  54 import java.util.Calendar;
  55 import java.util.Date;
  56 import java.util.HashMap;
  57 import java.util.HashSet;
  58 import java.util.List;
  59 import java.util.Locale;
  60 import java.util.Map;
  61 import java.util.Set;
  62 import java.util.concurrent.TimeUnit;
  63 import java.util.function.Consumer;
  64 import java.util.function.Function;
  65 import java.util.jar.Attributes.Name;
  66 import java.util.jar.Manifest;
  67 import java.util.stream.Collectors;
  68 import java.util.stream.IntStream;
  69 
  70 import jdk.test.lib.process.OutputAnalyzer;
  71 import jdk.test.lib.process.ProcessTools;
  72 import jdk.test.lib.util.JarUtils;
  73 
  74 public class Compatibility {
  75 
  76     private static final String TEST_SRC = System.getProperty(&quot;test.src&quot;);
  77     private static final String TEST_CLASSES = System.getProperty(&quot;test.classes&quot;);
  78     private static final String TEST_JDK = System.getProperty(&quot;test.jdk&quot;);
  79     private static JdkInfo TEST_JDK_INFO;
  80 
  81     private static final String PROXY_HOST = System.getProperty(&quot;proxyHost&quot;);
  82     private static final String PROXY_PORT = System.getProperty(&quot;proxyPort&quot;, &quot;80&quot;);
  83 
  84     // An alternative security properties file.
  85     // The test provides a default one, which only contains two lines:
  86     // jdk.certpath.disabledAlgorithms=MD2, MD5
  87     // jdk.jar.disabledAlgorithms=MD2, MD5
  88     private static final String JAVA_SECURITY = System.getProperty(
  89             &quot;javaSecurityFile&quot;, TEST_SRC + &quot;/java.security&quot;);
  90 
  91     private static final String PASSWORD = &quot;testpass&quot;;
  92     private static final String KEYSTORE = &quot;testKeystore.jks&quot;;
  93 
  94     private static final String RSA = &quot;RSA&quot;;
  95     private static final String DSA = &quot;DSA&quot;;
  96     private static final String EC = &quot;EC&quot;;
  97     private static String[] KEY_ALGORITHMS;
  98     private static final String[] DEFAULT_KEY_ALGORITHMS = new String[] {
  99             RSA,
 100             DSA,
 101             EC};
 102 
 103     private static final String SHA1 = &quot;SHA-1&quot;;
 104     private static final String SHA256 = &quot;SHA-256&quot;;
 105     private static final String SHA384 = &quot;SHA-384&quot;;
 106     private static final String SHA512 = &quot;SHA-512&quot;;
 107     private static final String DEFAULT = &quot;DEFAULT&quot;;
 108     private static String[] DIGEST_ALGORITHMS;
 109     private static final String[] DEFAULT_DIGEST_ALGORITHMS = new String[] {
 110             SHA1,
 111             SHA256,
 112             SHA384,
 113             SHA512, // note: digests break onto continuation line in manifest
 114             DEFAULT};
 115 
 116     private static final boolean[] EXPIRED =
 117             Boolean.valueOf(System.getProperty(&quot;expired&quot;, &quot;true&quot;)) ?
 118                     new boolean[] { false, true } : new boolean[] { false };
 119 
 120     private static final boolean TEST_COMPREHENSIVE_JAR_CONTENTS =
 121             Boolean.valueOf(System.getProperty(
 122                     &quot;testComprehensiveJarContents&quot;, &quot;false&quot;));
 123 
 124     private static final boolean TEST_JAR_UPDATE =
 125             Boolean.valueOf(System.getProperty(&quot;testJarUpdate&quot;, &quot;false&quot;));
 126 
 127     private static final boolean STRICT =
 128             Boolean.valueOf(System.getProperty(&quot;strict&quot;, &quot;false&quot;));
 129 
 130     private static final Calendar CALENDAR = Calendar.getInstance();
 131     private static final DateFormat DATE_FORMAT
 132             = new SimpleDateFormat(&quot;yyyy/MM/dd HH:mm:ss&quot;);
 133 
 134     // The certificate validity period in minutes. The default value is 1440
 135     // minutes, namely 1 day.
 136     private static final int CERT_VALIDITY
 137             = Integer.valueOf(System.getProperty(&quot;certValidity&quot;, &quot;1440&quot;));
 138     static {
 139         if (CERT_VALIDITY &lt; 1 || CERT_VALIDITY &gt; 1440) {
 140             throw new RuntimeException(
 141                     &quot;certValidity out of range [1, 1440]: &quot; + CERT_VALIDITY);
 142         }
 143     }
 144 
 145     // If true, an additional verifying will be triggered after all of
 146     // valid certificates expire. The default value is false.
 147     public static final boolean DELAY_VERIFY
 148             = Boolean.valueOf(System.getProperty(&quot;delayVerify&quot;, &quot;false&quot;));
 149 
 150     private static long lastCertStartTime;
 151 
 152     private static DetailsOutputStream detailsOutput;
 153 
 154     private static int sigfileCounter;
 155 
 156     private static String nextSigfileName(String alias, String u, String s) {
 157         String sigfileName = &quot;&quot; + (++sigfileCounter);
 158         System.out.println(&quot;using sigfile &quot; + sigfileName + &quot; for alias &quot;
 159                     + alias + &quot; signing &quot; + u + &quot;.jar to &quot; + s + &quot;.jar&quot;);
 160         return sigfileName;
 161     }
 162 
 163     public static void main(String... args) throws Throwable {
 164         // Backups stdout and stderr.
 165         PrintStream origStdOut = System.out;
 166         PrintStream origStdErr = System.err;
 167 
 168         detailsOutput = new DetailsOutputStream(outfile());
 169 
 170         // Redirects the system output to a custom one.
 171         PrintStream printStream = new PrintStream(detailsOutput);
 172         System.setOut(printStream);
 173         System.setErr(printStream);
 174 
 175         TEST_JDK_INFO = new JdkInfo(TEST_JDK);
 176 
 177         List&lt;TsaInfo&gt; tsaList = tsaInfoList();
 178         List&lt;JdkInfo&gt; jdkInfoList = jdkInfoList();
 179         List&lt;CertInfo&gt; certList = createCertificates(jdkInfoList);
 180         List&lt;SignItem&gt; signItems =
 181                 test(jdkInfoList, tsaList, certList, createJars());
 182 
 183         boolean failed = generateReport(jdkInfoList, tsaList, signItems);
 184 
 185         // Restores the original stdout and stderr.
 186         System.setOut(origStdOut);
 187         System.setErr(origStdErr);
 188 
 189         if (failed) {
 190             throw new RuntimeException(&quot;At least one test case failed. &quot;
 191                     + &quot;Please check the failed row(s) in report.html &quot;
 192                     + &quot;or failedReport.html.&quot;);
 193         }
 194     }
 195 
 196     private static SignItem createJarFile(String jar, Manifest m,
 197             String... files) throws IOException {
 198         JarUtils.createJarFile(Path.of(jar), m, Path.of(&quot;.&quot;),
 199                 Arrays.stream(files).map(Path::of).toArray(Path[]::new));
 200         return SignItem.build()
 201                 .signedJar(jar.replaceAll(&quot;[.]jar$&quot;, &quot;&quot;))
 202             .addContentFiles(Arrays.stream(files).collect(Collectors.toList()));
 203     }
 204 
 205     private static String createDummyFile(String name) throws IOException {
 206         if (name.contains(&quot;/&quot;)) new File(name).getParentFile().mkdir();
 207         try (OutputStream fos = new FileOutputStream(name)) {
 208             fos.write(name.getBytes(UTF_8));
 209         }
 210         return name;
 211     }
 212 
 213     // Creates one or more jar files to test
 214     private static List&lt;SignItem&gt; createJars() throws IOException {
 215         List&lt;SignItem&gt; jarList = new ArrayList&lt;&gt;();
 216 
 217         Manifest m = new Manifest();
 218         m.getMainAttributes().put(Name.MANIFEST_VERSION, &quot;1.0&quot;);
 219 
 220         // creates a jar file that contains a dummy file
 221         jarList.add(createJarFile(&quot;test.jar&quot;, m, createDummyFile(&quot;dummy&quot;)));
 222 
 223         if (TEST_COMPREHENSIVE_JAR_CONTENTS) {
 224 
 225             // empty jar file so that jarsigner will add a default manifest
 226             jarList.add(createJarFile(&quot;empty.jar&quot;, m));
 227 
 228             // jar file that contains only an empty manifest with empty main
 229             // attributes (due to missing &quot;Manifest-Version&quot; header)
 230             JarUtils.createJar(&quot;nomainatts.jar&quot;);
 231             jarList.add(SignItem.build().signedJar(&quot;nomainatts&quot;));
 232 
 233             // creates a jar file that contains several files.
 234             jarList.add(createJarFile(&quot;files.jar&quot;, m,
 235                     IntStream.range(1, 9).boxed().map(i -&gt; {
 236                         try {
 237                             return createDummyFile(&quot;dummy&quot; + i);
 238                         } catch (IOException e) {
 239                             throw new RuntimeException(e);
 240                         }
 241                     }).toArray(String[]::new)
 242             ));
 243 
 244             // forces a line break by exceeding the line width limit of 72 bytes
 245             // in the filename and hence manifest entry name
 246             jarList.add(createJarFile(&quot;longfilename.jar&quot;, m,
 247                     createDummyFile(&quot;test&quot;.repeat(20))));
 248 
 249             // another interesting case is with different digest algorithms
 250             // resulting in digests broken across line breaks onto continuation
 251             // lines. these however are set with the &#39;digestAlgs&#39; option or
 252             // include all digest algorithms by default, see SignTwice.java.
 253         }
 254 
 255         return jarList;
 256     }
 257 
 258     // updates a signed jar file by adding another file
 259     private static List&lt;SignItem&gt; updateJar(SignItem prev) throws IOException {
 260         List&lt;SignItem&gt; jarList = new ArrayList&lt;&gt;();
 261 
 262         // sign unmodified jar again
 263         Files.copy(Path.of(prev.signedJar + &quot;.jar&quot;),
 264                 Path.of(prev.signedJar + &quot;-signagainunmodified.jar&quot;));
 265         jarList.add(SignItem.build(prev)
 266                 .signedJar(prev.signedJar + &quot;-signagainunmodified&quot;));
 267 
 268         String oldJar = prev.signedJar;
 269         String newJar = oldJar + &quot;-addfile&quot;;
 270         String triggerUpdateFile = &quot;addfile&quot;;
 271         JarUtils.updateJar(oldJar + &quot;.jar&quot;, newJar + &quot;.jar&quot;, triggerUpdateFile);
 272         jarList.add(SignItem.build(prev).signedJar(newJar)
 273                 .addContentFiles(Arrays.asList(triggerUpdateFile)));
 274 
 275         return jarList;
 276     }
 277 
 278     // Creates a key store that includes a set of valid/expired certificates
 279     // with various algorithms.
 280     private static List&lt;CertInfo&gt; createCertificates(List&lt;JdkInfo&gt; jdkInfoList)
 281             throws Throwable {
 282         List&lt;CertInfo&gt; certList = new ArrayList&lt;&gt;();
 283         Set&lt;String&gt; expiredCertFilter = new HashSet&lt;&gt;();
 284 
 285         for (JdkInfo jdkInfo : jdkInfoList) {
 286             for (String keyAlgorithm : keyAlgs()) {
 287                 if (!jdkInfo.supportsKeyAlg(keyAlgorithm)) continue;
 288                 for (int keySize : keySizes(keyAlgorithm)) {
 289                     for (String digestAlgorithm : digestAlgs()) {
 290                         for(boolean expired : EXPIRED) {
 291                             // It creates only one expired certificate for one
 292                             // key algorithm.
 293                             if (expired
 294                                     &amp;&amp; !expiredCertFilter.add(keyAlgorithm)) {
 295                                 continue;
 296                             }
 297 
 298                             CertInfo certInfo = new CertInfo(
 299                                     jdkInfo,
 300                                     keyAlgorithm,
 301                                     digestAlgorithm,
 302                                     keySize,
 303                                     expired);
 304                             // If the signature algorithm is not supported by the
 305                             // JDK, it cannot try to sign jar with this algorithm.
 306                             String sigalg = certInfo.sigalg();
 307                             if (sigalg != null &amp;&amp;
 308                                     !jdkInfo.isSupportedSigalg(sigalg)) {
 309                                 continue;
 310                             }
 311                             createCertificate(jdkInfo, certInfo);
 312                             certList.add(certInfo);
 313                         }
 314                     }
 315                 }
 316             }
 317         }
 318 
 319         System.out.println(&quot;the keystore contents:&quot;);
 320         for (JdkInfo jdkInfo : jdkInfoList) {
 321             execTool(jdkInfo.jdkPath + &quot;/bin/keytool&quot;, new String[] {
 322                     &quot;-v&quot;,
 323                     &quot;-storetype&quot;,
 324                     &quot;jks&quot;,
 325                     &quot;-storepass&quot;,
 326                     PASSWORD,
 327                     &quot;-keystore&quot;,
 328                     KEYSTORE,
 329                     &quot;-list&quot;
 330             });
 331         }
 332 
 333         return certList;
 334     }
 335 
 336     // Creates/Updates a key store that adds a certificate with specific algorithm.
 337     private static void createCertificate(JdkInfo jdkInfo, CertInfo certInfo)
 338             throws Throwable {
 339         List&lt;String&gt; arguments = new ArrayList&lt;&gt;();
 340         arguments.add(&quot;-J-Djava.security.properties=&quot; + JAVA_SECURITY);
 341         arguments.add(&quot;-v&quot;);
 342         arguments.add(&quot;-debug&quot;);
 343         arguments.add(&quot;-storetype&quot;);
 344         arguments.add(&quot;jks&quot;);
 345         arguments.add(&quot;-keystore&quot;);
 346         arguments.add(KEYSTORE);
 347         arguments.add(&quot;-storepass&quot;);
 348         arguments.add(PASSWORD);
 349         arguments.add(jdkInfo.majorVersion &lt; 6 ? &quot;-genkey&quot; : &quot;-genkeypair&quot;);
 350         arguments.add(&quot;-keyalg&quot;);
 351         arguments.add(certInfo.keyAlgorithm);
 352         String sigalg = certInfo.sigalg();
 353         if (sigalg != null) {
 354             arguments.add(&quot;-sigalg&quot;);
 355             arguments.add(sigalg);
 356         }
 357         if (certInfo.keySize != 0) {
 358             arguments.add(&quot;-keysize&quot;);
 359             arguments.add(certInfo.keySize + &quot;&quot;);
 360         }
 361         arguments.add(&quot;-dname&quot;);
 362         arguments.add(&quot;CN=&quot; + certInfo);
 363         arguments.add(&quot;-alias&quot;);
 364         arguments.add(certInfo.alias());
 365         arguments.add(&quot;-keypass&quot;);
 366         arguments.add(PASSWORD);
 367 
 368         arguments.add(&quot;-startdate&quot;);
 369         arguments.add(startDate(certInfo.expired));
 370         arguments.add(&quot;-validity&quot;);
 371 //        arguments.add(DELAY_VERIFY ? &quot;1&quot; : &quot;222&quot;); // &gt; six months no warn
 372         arguments.add(&quot;1&quot;);
 373 
 374         OutputAnalyzer outputAnalyzer = execTool(
 375                 jdkInfo.jdkPath + &quot;/bin/keytool&quot;,
 376                 arguments.toArray(new String[arguments.size()]));
 377         if (outputAnalyzer.getExitValue() != 0
 378                 || outputAnalyzer.getOutput().matches(&quot;[Ee]xception&quot;)
 379                 || outputAnalyzer.getOutput().matches(Test.ERROR + &quot; ?&quot;)) {
 380             System.out.println(outputAnalyzer.getOutput());
 381             throw new Exception(&quot;error generating a key pair: &quot; + arguments);
 382         }
 383     }
 384 
 385     // The validity period of a certificate always be 1 day. For creating an
 386     // expired certificate, the start date is the time before 1 day, then the
 387     // certificate expires immediately. And for creating a valid certificate,
 388     // the start date is the time before (1 day - CERT_VALIDITY minutes), then
 389     // the certificate will expires in CERT_VALIDITY minutes.
 390     private static String startDate(boolean expiredCert) {
 391         CALENDAR.setTime(new Date());
 392         if (DELAY_VERIFY || expiredCert) {
 393             // corresponds to &#39;-validity 1&#39;
 394             CALENDAR.add(Calendar.DAY_OF_MONTH, -1);
 395         }
 396         if (DELAY_VERIFY &amp;&amp; !expiredCert) {
 397             CALENDAR.add(Calendar.MINUTE, CERT_VALIDITY);
 398         }
 399         Date startDate = CALENDAR.getTime();
 400         if (!expiredCert) {
 401             lastCertStartTime = startDate.getTime();
 402         }
 403         return DATE_FORMAT.format(startDate);
 404     }
 405 
 406     private static String outfile() {
 407         return System.getProperty(&quot;o&quot;);
 408     }
 409 
 410     // Retrieves JDK info from the file which is specified by property
 411     // jdkListFile, or from property jdkList if jdkListFile is not available.
 412     private static List&lt;JdkInfo&gt; jdkInfoList() throws Throwable {
 413         String[] jdkList = list(&quot;jdkList&quot;);
 414         if (jdkList.length == 0) {
 415             jdkList = new String[] { &quot;TEST_JDK&quot; };
 416         }
 417 
 418         List&lt;JdkInfo&gt; jdkInfoList = new ArrayList&lt;&gt;();
 419         int index = 0;
 420         for (String jdkPath : jdkList) {
 421             JdkInfo jdkInfo = &quot;TEST_JDK&quot;.equalsIgnoreCase(jdkPath) ?
 422                     TEST_JDK_INFO : new JdkInfo(jdkPath);
 423             // The JDK version must be unique.
 424             if (!jdkInfoList.contains(jdkInfo)) {
 425                 jdkInfo.index = index++;
 426                 jdkInfo.version = String.format(
 427                         &quot;%s(%d)&quot;, jdkInfo.version, jdkInfo.index);
 428                 jdkInfoList.add(jdkInfo);
 429             } else {
 430                 System.out.println(&quot;The JDK version is duplicate: &quot; + jdkPath);
 431             }
 432         }
 433         return jdkInfoList;
 434     }
 435 
 436     private static List&lt;String&gt; keyAlgs() throws IOException {
 437         if (KEY_ALGORITHMS == null) KEY_ALGORITHMS = list(&quot;keyAlgs&quot;);
 438         if (KEY_ALGORITHMS.length == 0)
 439             return Arrays.asList(DEFAULT_KEY_ALGORITHMS);
 440         return Arrays.stream(KEY_ALGORITHMS).map(a -&gt; a.split(&quot;;&quot;)[0])
 441                 .collect(Collectors.toList());
 442     }
 443 
 444     // Return key sizes according to the specified key algorithm.
 445     private static int[] keySizes(String keyAlgorithm) throws IOException {
 446         if (KEY_ALGORITHMS == null) KEY_ALGORITHMS = list(&quot;keyAlgs&quot;);
 447         for (String keyAlg : KEY_ALGORITHMS) {
 448             String[] split = (keyAlg + &quot; &quot;).split(&quot;;&quot;);
 449             if (keyAlgorithm.equals(split[0].trim()) &amp;&amp; split.length &gt; 1) {
 450                 int sizes[] = new int[split.length - 1];
 451                 for (int i = 1; i &lt;= sizes.length; i++)
 452                     sizes[i - 1] = split[i].isBlank() ? 0 : // default
 453                         Integer.parseInt(split[i].trim());
 454                 return sizes;
 455             }
 456         }
 457 
 458         // defaults
 459         if (RSA.equals(keyAlgorithm) || DSA.equals(keyAlgorithm)) {
 460             return new int[] { 1024, 2048, 0 }; // 0 is no keysize specified
 461         } else if (EC.equals(keyAlgorithm)) {
 462             return new int[] { 384, 571, 0 }; // 0 is no keysize specified
 463         } else {
 464             throw new RuntimeException(&quot;problem determining key sizes&quot;);
 465         }
 466     }
 467 
 468     private static List&lt;String&gt; digestAlgs() throws IOException {
 469         if (DIGEST_ALGORITHMS == null) DIGEST_ALGORITHMS = list(&quot;digestAlgs&quot;);
 470         if (DIGEST_ALGORITHMS.length == 0)
 471             return Arrays.asList(DEFAULT_DIGEST_ALGORITHMS);
 472         return Arrays.asList(DIGEST_ALGORITHMS);
 473     }
 474 
 475     // Retrieves TSA info from the file which is specified by property tsaListFile,
 476     // or from property tsaList if tsaListFile is not available.
 477     private static List&lt;TsaInfo&gt; tsaInfoList() throws IOException {
 478         String[] tsaList = list(&quot;tsaList&quot;);
 479 
 480         List&lt;TsaInfo&gt; tsaInfoList = new ArrayList&lt;&gt;();
 481         for (int i = 0; i &lt; tsaList.length; i++) {
 482             String[] values = tsaList[i].split(&quot;;digests=&quot;);
 483 
 484             String[] digests = new String[0];
 485             if (values.length == 2) {
 486                 digests = values[1].split(&quot;,&quot;);
 487             }
 488 
 489             String tsaUrl = values[0];
 490             if (tsaUrl.isEmpty() || tsaUrl.equalsIgnoreCase(&quot;notsa&quot;)) {
 491                 tsaUrl = null;
 492             }
 493             TsaInfo bufTsa = new TsaInfo(i, tsaUrl);
 494             for (String digest : digests) {
 495                 bufTsa.addDigest(digest.toUpperCase());
 496             }
 497             tsaInfoList.add(bufTsa);
 498         }
 499 
 500         if (tsaInfoList.size() == 0) {
 501             throw new RuntimeException(&quot;TSA service is mandatory unless &quot;
 502                     + &quot;&#39;notsa&#39; specified explicitly.&quot;);
 503         }
 504         return tsaInfoList;
 505     }
 506 
 507     private static String[] list(String listProp) throws IOException {
 508         String listFileProp = listProp + &quot;File&quot;;
 509         String listFile = System.getProperty(listFileProp);
 510         if (!isEmpty(listFile)) {
 511             System.out.println(listFileProp + &quot;=&quot; + listFile);
 512             List&lt;String&gt; list = new ArrayList&lt;&gt;();
 513             BufferedReader reader = new BufferedReader(
 514                     new FileReader(listFile));
 515             String line;
 516             while ((line = reader.readLine()) != null) {
 517                 String item = line.trim();
 518                 if (!item.isEmpty()) {
 519                     list.add(item);
 520                 }
 521             }
 522             reader.close();
 523             return list.toArray(new String[list.size()]);
 524         }
 525 
 526         String list = System.getProperty(listProp);
 527         System.out.println(listProp + &quot;=&quot; + list);
 528         return !isEmpty(list) ? list.split(&quot;#&quot;) : new String[0];
 529     }
 530 
 531     private static boolean isEmpty(String str) {
 532         return str == null || str.isEmpty();
 533     }
 534 
 535     // A JDK (signer) signs a jar with a variety of algorithms, and then all of
 536     // JDKs (verifiers), including the signer itself, try to verify the signed
 537     // jars respectively.
 538     private static List&lt;SignItem&gt; test(List&lt;JdkInfo&gt; jdkInfoList,
 539             List&lt;TsaInfo&gt; tsaInfoList, List&lt;CertInfo&gt; certList,
 540             List&lt;SignItem&gt; jars) throws Throwable {
 541         detailsOutput.transferPhase();
 542         List&lt;SignItem&gt; signItems = new ArrayList&lt;&gt;();
 543         signItems.addAll(signing(jdkInfoList, tsaInfoList, certList, jars));
 544         if (TEST_JAR_UPDATE) {
 545             signItems.addAll(signing(jdkInfoList, tsaInfoList, certList,
 546                     updating(signItems.stream().filter(
 547                             x -&gt; x.status != Status.ERROR)
 548                     .collect(Collectors.toList()))));
 549         }
 550 
 551         detailsOutput.transferPhase();
 552         for (SignItem signItem : signItems) {
 553             for (JdkInfo verifierInfo : jdkInfoList) {
 554                 if (!verifierInfo.supportsKeyAlg(
 555                         signItem.certInfo.keyAlgorithm)) continue;
 556                 VerifyItem verifyItem = VerifyItem.build(verifierInfo);
 557                 verifyItem.addSignerCertInfos(signItem);
 558                 signItem.addVerifyItem(verifyItem);
 559                 verifying(signItem, verifyItem);
 560             }
 561         }
 562 
 563         // if lastCertExpirationTime passed already now, probably some
 564         // certificate was already expired during jar signature verification
 565         // (jarsigner -verify) and the test should probably be repeated with an
 566         // increased validity period -DcertValidity CERT_VALIDITY
 567         long lastCertExpirationTime = lastCertStartTime + 24 * 60 * 60 * 1000;
 568         if (lastCertExpirationTime &lt; System.currentTimeMillis()) {
 569             throw new AssertionError(&quot;CERT_VALIDITY (&quot; + CERT_VALIDITY
 570                     + &quot; [minutes]) was too short. &quot;
 571                     + &quot;Creating and signing the jars took longer, &quot;
 572                     + &quot;presumably at least &quot;
 573                     + ((lastCertExpirationTime - System.currentTimeMillis())
 574                             / 60 * 1000 + CERT_VALIDITY) + &quot; [minutes].&quot;);
 575         }
 576 
 577         if (DELAY_VERIFY) {
 578             detailsOutput.transferPhase();
 579             System.out.print(&quot;Waiting for delay verifying&quot;);
 580             while (System.currentTimeMillis() &lt; lastCertExpirationTime) {
 581                 TimeUnit.SECONDS.sleep(30);
 582                 System.out.print(&quot;.&quot;);
 583             }
 584             System.out.println();
 585 
 586             System.out.println(&quot;Delay verifying starts&quot;);
 587             for (SignItem signItem : signItems) {
 588                 for (VerifyItem verifyItem : signItem.verifyItems) {
 589                     verifying(signItem, verifyItem);
 590                 }
 591             }
 592         }
 593 
 594         detailsOutput.transferPhase();
 595         return signItems;
 596     }
 597 
 598     private static List&lt;SignItem&gt; signing(List&lt;JdkInfo&gt; jdkInfos,
 599             List&lt;TsaInfo&gt; tsaList, List&lt;CertInfo&gt; certList,
 600             List&lt;SignItem&gt; unsignedJars) throws Throwable {
 601         List&lt;SignItem&gt; signItems = new ArrayList&lt;&gt;();
 602 
 603         for (CertInfo certInfo : certList) {
 604             JdkInfo signerInfo = certInfo.jdkInfo;
 605             String keyAlgorithm = certInfo.keyAlgorithm;
 606             String sigDigestAlgorithm = certInfo.digestAlgorithm;
 607             int keySize = certInfo.keySize;
 608             boolean expired = certInfo.expired;
 609 
 610             for (String jarDigestAlgorithm : digestAlgs()) {
 611                 if (DEFAULT.equals(jarDigestAlgorithm)) {
 612                     jarDigestAlgorithm = null;
 613                 }
 614 
 615                 for (TsaInfo tsaInfo : tsaList) {
 616                     String tsaUrl = tsaInfo.tsaUrl;
 617 
 618                     List&lt;String&gt; tsaDigestAlgs = digestAlgs();
 619                     // no point in specifying a tsa digest algorithm
 620                     // for no TSA, except maybe it would issue a warning.
 621                     if (tsaUrl == null) tsaDigestAlgs = Arrays.asList(DEFAULT);
 622                     // If the JDK doesn&#39;t support option -tsadigestalg, the
 623                     // associated cases can just be ignored.
 624                     if (!signerInfo.supportsTsadigestalg) {
 625                         tsaDigestAlgs = Arrays.asList(DEFAULT);
 626                     }
 627                     for (String tsaDigestAlg : tsaDigestAlgs) {
 628                         if (DEFAULT.equals(tsaDigestAlg)) {
 629                             tsaDigestAlg = null;
 630                         } else if (!tsaInfo.isDigestSupported(tsaDigestAlg)) {
 631                             // It has to ignore the digest algorithm, which
 632                             // is not supported by the TSA server.
 633                             continue;
 634                         }
 635 
 636                         if (tsaUrl != null &amp;&amp; TsaFilter.filter(
 637                                 signerInfo.version,
 638                                 tsaDigestAlg,
 639                                 expired,
 640                                 tsaInfo.index)) {
 641                             continue;
 642                         }
 643 
 644                         for (SignItem prevSign : unsignedJars) {
 645                             String unsignedJar = prevSign.signedJar;
 646 
 647                             SignItem signItem = SignItem.build(prevSign)
 648                                     .certInfo(certInfo)
 649                                     .jdkInfo(signerInfo);
 650                             String signedJar = unsignedJar + &quot;-&quot; + &quot;JDK_&quot; + (
 651                                     signerInfo.version + &quot;-CERT_&quot; + certInfo).
 652                                     replaceAll(&quot;[^a-z_0-9A-Z.]+&quot;, &quot;-&quot;);
 653 
 654                             if (jarDigestAlgorithm != null) {
 655                                 signedJar += &quot;-DIGESTALG_&quot; + jarDigestAlgorithm;
 656                                 signItem.digestAlgorithm(jarDigestAlgorithm);
 657                             }
 658                             if (tsaUrl == null) {
 659                                 signItem.tsaIndex(-1);
 660                             } else {
 661                                 signedJar += &quot;-TSA_&quot; + tsaInfo.index;
 662                                 signItem.tsaIndex(tsaInfo.index);
 663                                 if (tsaDigestAlg != null) {
 664                                     signedJar += &quot;-TSADIGALG_&quot; + tsaDigestAlg;
 665                                     signItem.tsaDigestAlgorithm(tsaDigestAlg);
 666                                 }
 667                             }
 668                             signItem.signedJar(signedJar);
 669 
 670                             String signingId = signingId(signItem);
 671                             detailsOutput.writeAnchorName(signingId,
 672                                     &quot;Signing: &quot; + signingId);
 673 
 674                             OutputAnalyzer signOA = signJar(
 675                                     signerInfo.jarsignerPath,
 676                                     certInfo.sigalg(),
 677                                     jarDigestAlgorithm,
 678                                     tsaDigestAlg,
 679                                     tsaUrl,
 680                                     certInfo.alias(),
 681                                     unsignedJar,
 682                                     signedJar);
 683                             Status signingStatus = signingStatus(signOA,
 684                                     tsaUrl != null);
 685                             signItem.status(signingStatus);
 686                             signItems.add(signItem);
 687                         }
 688                     }
 689                 }
 690             }
 691         }
 692 
 693         return signItems;
 694     }
 695 
 696     private static List&lt;SignItem&gt; updating(List&lt;SignItem&gt; prevSignItems)
 697             throws IOException {
 698         List&lt;SignItem&gt; updateItems = new ArrayList&lt;&gt;();
 699         for (SignItem prevSign : prevSignItems) {
 700             updateItems.addAll(updateJar(prevSign));
 701         }
 702         return updateItems;
 703     }
 704 
 705     private static void verifying(SignItem signItem, VerifyItem verifyItem)
 706             throws Throwable {
 707         // TODO: how will be ensured that the first verification is not after valid period expired which is only one minute?
 708         boolean delayVerify = verifyItem.status != Status.NONE;
 709         String verifyingId = verifyingId(signItem, verifyItem, delayVerify);
 710         detailsOutput.writeAnchorName(verifyingId, &quot;Verifying: &quot; + verifyingId);
 711         OutputAnalyzer verifyOA = verifyJar(verifyItem.jdkInfo.jarsignerPath,
 712                 signItem.signedJar, verifyItem.certInfo == null ? null :
 713                 verifyItem.certInfo.alias());
 714         Status verifyingStatus = verifyingStatus(signItem, verifyItem, verifyOA);
 715 
 716         try {
 717             String match = &quot;^  (&quot;
 718                     + &quot;  Signature algorithm: &quot; + signItem.certInfo.
 719                             expectedSigalg() + &quot;, &quot; + signItem.certInfo.
 720                             expectedKeySize() + &quot;-bit key&quot;
 721                     + &quot;)|(&quot;
 722                     + &quot;  Digest algorithm: &quot; + signItem.expectedDigestAlg()
 723                     + (signItem.tsaIndex &lt; 0 ? &quot;&quot; :
 724                       &quot;)|(&quot;
 725                     + &quot;Timestamped by \&quot;.+\&quot; on .*&quot;
 726                     + &quot;)|(&quot;
 727                     + &quot;  Timestamp digest algorithm: &quot;
 728                             + signItem.expectedTsaDigestAlg()
 729                     + &quot;)|(&quot;
 730                     + &quot;  Timestamp signature algorithm: .*&quot;
 731                       )
 732                     + &quot;)$&quot;;
 733             verifyOA.stdoutShouldMatchByLine(
 734                     &quot;^- Signed by \&quot;CN=&quot; +  signItem.certInfo.toString()
 735                             .replaceAll(&quot;[.]&quot;, &quot;[.]&quot;) + &quot;\&quot;$&quot;,
 736                     &quot;^(- Signed by \&quot;CN=.+\&quot;)?$&quot;,
 737                     match);
 738         } catch (Throwable e) {
 739             e.printStackTrace();
 740             verifyingStatus = Status.ERROR;
 741         }
 742 
 743         if (!delayVerify) {
 744             verifyItem.status(verifyingStatus);
 745         } else {
 746             verifyItem.delayStatus(verifyingStatus);
 747         }
 748 
 749         if (verifyItem.prevVerify != null) {
 750             verifying(signItem, verifyItem.prevVerify);
 751         }
 752     }
 753 
 754     // Determines the status of signing.
 755     private static Status signingStatus(OutputAnalyzer outputAnalyzer,
 756             boolean tsa) {
 757         if (outputAnalyzer.getExitValue() != 0) {
 758             return Status.ERROR;
 759         }
 760         if (!outputAnalyzer.getOutput().contains(Test.JAR_SIGNED)) {
 761             return Status.ERROR;
 762         }
 763 
 764         boolean warning = false;
 765         for (String line : outputAnalyzer.getOutput().lines()
 766                 .toArray(String[]::new)) {
 767             if (line.matches(Test.ERROR + &quot; ?&quot;)) return Status.ERROR;
 768             if (line.matches(Test.WARNING + &quot; ?&quot;)) warning = true;
 769         }
 770         return warning ? Status.WARNING : Status.NORMAL;
 771     }
 772 
 773     // Determines the status of verifying.
 774     private static Status verifyingStatus(SignItem signItem, VerifyItem
 775             verifyItem, OutputAnalyzer outputAnalyzer) {
 776         List&lt;String&gt; expectedSignedContent = new ArrayList&lt;&gt;();
 777         if (verifyItem.certInfo == null) {
 778             expectedSignedContent.addAll(signItem.jarContents);
 779         } else {
 780             SignItem i = signItem;
 781             while (i != null) {
 782                 if (i.certInfo != null &amp;&amp; i.certInfo.equals(verifyItem.certInfo)) {
 783                     expectedSignedContent.addAll(i.jarContents);
 784                 }
 785                 i = i.prevSign;
 786             }
 787         }
 788         List&lt;String&gt; expectedUnsignedContent =
 789                 new ArrayList&lt;&gt;(signItem.jarContents);
 790         expectedUnsignedContent.removeAll(expectedSignedContent);
 791 
 792         int expectedExitCode = !STRICT || expectedUnsignedContent.isEmpty() ? 0 : 32;
 793         if (outputAnalyzer.getExitValue() != expectedExitCode) {
 794             System.out.println(&quot;verifyingStatus: error: exit code != &quot; + expectedExitCode + &quot;: &quot; + outputAnalyzer.getExitValue() + &quot; != &quot; + expectedExitCode);
 795             return Status.ERROR;
 796         }
 797         String expectedSuccessMessage = expectedUnsignedContent.isEmpty() ?
 798                 Test.JAR_VERIFIED : Test.JAR_VERIFIED_WITH_SIGNER_ERRORS;
 799         if (!outputAnalyzer.getOutput().contains(expectedSuccessMessage)) {
 800             System.out.println(&quot;verifyingStatus: error: expectedSuccessMessage not found: &quot; + expectedSuccessMessage);
 801             return Status.ERROR;
 802         }
 803 
 804         boolean tsa = signItem.tsaIndex &gt;= 0;
 805         boolean warning = false;
 806         for (String line : outputAnalyzer.getOutput().lines()
 807                 .toArray(String[]::new)) {
 808             if (line.isBlank()) continue;
 809             if (Test.JAR_VERIFIED.equals(line)) continue;
 810             if (line.matches(Test.ERROR + &quot; ?&quot;) &amp;&amp; expectedExitCode == 0) {
 811                 System.out.println(&quot;verifyingStatus: error: line.matches(&quot; + Test.ERROR + &quot;\&quot; ?\&quot;): &quot; + line);
 812                 return Status.ERROR;
 813             }
 814             if (line.matches(Test.WARNING + &quot; ?&quot;)) {
 815                 warning = true;
 816                 continue;
 817             }
 818             if (!warning) continue;
 819             line = line.strip();
 820             if (Test.NOT_YET_VALID_CERT_SIGNING_WARNING.equals(line)) continue;
 821             if (Test.HAS_EXPIRING_CERT_SIGNING_WARNING.equals(line)) continue;
 822             if (Test.HAS_EXPIRING_CERT_VERIFYING_WARNING.equals(line)) continue;
 823             if (line.matches(&quot;^&quot; + Test.NO_TIMESTAMP_SIGNING_WARN_TEMPLATE
 824                     .replaceAll(
 825                         &quot;\\(%1\\$tY-%1\\$tm-%1\\$td\\)&quot;, &quot;\\\\([^\\\\)]+\\\\)&quot;
 826                         + &quot;( or after any future revocation date)?&quot;)
 827                     .replaceAll(&quot;[.]&quot;, &quot;[.]&quot;) + &quot;$&quot;) &amp;&amp; !tsa) continue;
 828             if (line.matches(&quot;^&quot; + Test.NO_TIMESTAMP_VERIFYING_WARN_TEMPLATE
 829                     .replaceAll(&quot;\\(as early as %1\\$tY-%1\\$tm-%1\\$td\\)&quot;,
 830                         &quot;\\\\([^\\\\)]+\\\\)&quot;
 831                         + &quot;( or after any future revocation date)?&quot;)
 832                     .replaceAll(&quot;[.]&quot;, &quot;[.]&quot;) + &quot;$&quot;) &amp;&amp; !tsa) continue;
 833             if (line.matches(&quot;^This jar contains signatures that do(es)? not &quot;
 834                     + &quot;include a timestamp[.] Without a timestamp, users may &quot;
 835                     + &quot;not be able to validate this jar after the signer &quot;
 836                     + &quot;certificate&#39;s expiration date \\([^\\)]+\\) or after &quot;
 837                     + &quot;any future revocation date[.]&quot;) &amp;&amp; !tsa) continue;
 838             if (Test.CERTIFICATE_SELF_SIGNED.equals(line)) continue;
 839             if (Test.HAS_EXPIRED_CERT_VERIFYING_WARNING.equals(line)
 840                     &amp;&amp; signItem.certInfo.expired) continue;
 841             System.out.println(&quot;verifyingStatus: unexpected line: &quot; + line);
 842             return Status.ERROR; // treat unexpected warnings as error
 843         }
 844         return warning ? Status.WARNING : Status.NORMAL;
 845     }
 846 
 847     // Using specified jarsigner to sign the pre-created jar with specified
 848     // algorithms.
 849     private static OutputAnalyzer signJar(String jarsignerPath, String sigalg,
 850             String jarDigestAlgorithm,
 851             String tsadigestalg, String tsa, String alias, String unsignedJar,
 852             String signedJar) throws Throwable {
 853         List&lt;String&gt; arguments = new ArrayList&lt;&gt;();
 854 
 855         if (PROXY_HOST != null &amp;&amp; PROXY_PORT != null) {
 856             arguments.add(&quot;-J-Dhttp.proxyHost=&quot; + PROXY_HOST);
 857             arguments.add(&quot;-J-Dhttp.proxyPort=&quot; + PROXY_PORT);
 858             arguments.add(&quot;-J-Dhttps.proxyHost=&quot; + PROXY_HOST);
 859             arguments.add(&quot;-J-Dhttps.proxyPort=&quot; + PROXY_PORT);
 860         }
 861         arguments.add(&quot;-J-Djava.security.properties=&quot; + JAVA_SECURITY);
 862         arguments.add(&quot;-debug&quot;);
 863         arguments.add(&quot;-verbose&quot;);
 864         if (jarDigestAlgorithm != null) {
 865             arguments.add(&quot;-digestalg&quot;);
 866             arguments.add(jarDigestAlgorithm);
 867         }
 868         if (sigalg != null) {
 869             arguments.add(&quot;-sigalg&quot;);
 870             arguments.add(sigalg);
 871         }
 872         if (tsa != null) {
 873             arguments.add(&quot;-tsa&quot;);
 874             arguments.add(tsa);
 875         }
 876         if (tsadigestalg != null) {
 877             arguments.add(&quot;-tsadigestalg&quot;);
 878             arguments.add(tsadigestalg);
 879         }
 880         arguments.add(&quot;-keystore&quot;);
 881         arguments.add(KEYSTORE);
 882         arguments.add(&quot;-storepass&quot;);
 883         arguments.add(PASSWORD);
 884         arguments.add(&quot;-sigfile&quot;);
 885         arguments.add(nextSigfileName(alias, unsignedJar, signedJar));
 886         arguments.add(&quot;-signedjar&quot;);
 887         arguments.add(signedJar + &quot;.jar&quot;);
 888         arguments.add(unsignedJar + &quot;.jar&quot;);
 889         arguments.add(alias);
 890 
 891         OutputAnalyzer outputAnalyzer = execTool(jarsignerPath,
 892                 arguments.toArray(new String[arguments.size()]));
 893         return outputAnalyzer;
 894     }
 895 
 896     // Using specified jarsigner to verify the signed jar.
 897     private static OutputAnalyzer verifyJar(String jarsignerPath,
 898             String signedJar, String alias) throws Throwable {
 899         List&lt;String&gt; arguments = new ArrayList&lt;&gt;();
 900         arguments.add(&quot;-J-Djava.security.properties=&quot; + JAVA_SECURITY);
 901         arguments.add(&quot;-debug&quot;);
 902         arguments.add(&quot;-verbose&quot;);
 903         arguments.add(&quot;-certs&quot;);
 904         arguments.add(&quot;-keystore&quot;);
 905         arguments.add(KEYSTORE);
 906         arguments.add(&quot;-verify&quot;);
 907         if (STRICT) arguments.add(&quot;-strict&quot;);
 908         arguments.add(signedJar + &quot;.jar&quot;);
 909         if (alias != null) arguments.add(alias);
 910         OutputAnalyzer outputAnalyzer = execTool(jarsignerPath,
 911                 arguments.toArray(new String[arguments.size()]));
 912         return outputAnalyzer;
 913     }
 914 
 915     // Generates the test result report.
 916     private static boolean generateReport(List&lt;JdkInfo&gt; jdkList, List&lt;TsaInfo&gt; tsaList,
 917             List&lt;SignItem&gt; signItems) throws IOException {
 918         System.out.println(&quot;Report is being generated...&quot;);
 919 
 920         StringBuilder report = new StringBuilder();
 921         report.append(HtmlHelper.startHtml());
 922         report.append(HtmlHelper.startPre());
 923 
 924         // Generates JDK list
 925         report.append(&quot;JDK list:\n&quot;);
 926         for(JdkInfo jdkInfo : jdkList) {
 927             report.append(String.format(&quot;%d=%s%n&quot;,
 928                     jdkInfo.index,
 929                     jdkInfo.runtimeVersion));
 930         }
 931 
 932         // Generates TSA URLs
 933         report.append(&quot;TSA list:\n&quot;);
 934         for(TsaInfo tsaInfo : tsaList) {
 935             report.append(
 936                     String.format(&quot;%d=%s%n&quot;, tsaInfo.index,
 937                             tsaInfo.tsaUrl == null ? &quot;notsa&quot; : tsaInfo.tsaUrl));
 938         }
 939         report.append(HtmlHelper.endPre());
 940 
 941         report.append(HtmlHelper.startTable());
 942         // Generates report headers.
 943         List&lt;String&gt; headers = new ArrayList&lt;&gt;();
 944         headers.add(&quot;[Jarfile]&quot;);
 945         headers.add(&quot;[Signing Certificate]&quot;);
 946         headers.add(&quot;[Signer JDK]&quot;);
 947         headers.add(&quot;[Signature Algorithm]&quot;);
 948         headers.add(&quot;[Jar Digest Algorithm]&quot;);
 949         headers.add(&quot;[TSA Digest Algorithm]&quot;);
 950         headers.add(&quot;[TSA]&quot;);
 951         headers.add(&quot;[Signing Status]&quot;);
 952         headers.add(&quot;[Verifier JDK]&quot;);
 953         headers.add(&quot;[Verifying Certificate]&quot;);
 954         headers.add(&quot;[Verifying Status]&quot;);
 955         if (DELAY_VERIFY) {
 956             headers.add(&quot;[Delay Verifying Status]&quot;);
 957         }
 958         headers.add(&quot;[Failed]&quot;);
 959         report.append(HtmlHelper.htmlRow(
 960                 headers.toArray(new String[headers.size()])));
 961 
 962         StringBuilder failedReport = new StringBuilder(report.toString());
 963 
 964         boolean failed = signItems.isEmpty();
 965 
 966         // Generates report rows.
 967         for (SignItem signItem : signItems) {
 968             failed = failed || signItem.verifyItems.isEmpty();
 969             for (VerifyItem verifyItem : signItem.verifyItems) {
 970                 String reportRow = reportRow(signItem, verifyItem);
 971                 report.append(reportRow);
 972                 boolean isFailedCase = isFailed(signItem, verifyItem);
 973                 if (isFailedCase) {
 974                     failedReport.append(reportRow);
 975                 }
 976                 failed = failed || isFailedCase;
 977             }
 978         }
 979 
 980         report.append(HtmlHelper.endTable());
 981         report.append(HtmlHelper.endHtml());
 982         generateFile(&quot;report.html&quot;, report.toString());
 983         if (failed) {
 984             failedReport.append(HtmlHelper.endTable());
 985             failedReport.append(HtmlHelper.endPre());
 986             failedReport.append(HtmlHelper.endHtml());
 987             generateFile(&quot;failedReport.html&quot;, failedReport.toString());
 988         }
 989 
 990         System.out.println(&quot;Report is generated.&quot;);
 991         return failed;
 992     }
 993 
 994     private static void generateFile(String path, String content)
 995             throws IOException {
 996         FileWriter writer = new FileWriter(new File(path));
 997         writer.write(content);
 998         writer.close();
 999     }
1000 
1001     private static String jarsignerPath(String jdkPath) {
1002         return jdkPath + &quot;/bin/jarsigner&quot;;
1003     }
1004 
1005     // Executes the specified function on JdkUtils by the specified JDK.
1006     private static String execJdkUtils(String jdkPath, String method,
1007             String... args) throws Throwable {
1008         String[] cmd = new String[args.length + 5];
1009         cmd[0] = jdkPath + &quot;/bin/java&quot;;
1010         cmd[1] = &quot;-cp&quot;;
1011         cmd[2] = TEST_CLASSES;
1012         cmd[3] = JdkUtils.class.getName();
1013         cmd[4] = method;
1014         System.arraycopy(args, 0, cmd, 5, args.length);
1015         return ProcessTools.executeCommand(cmd).getOutput();
1016     }
1017 
1018     // Executes the specified JDK tools, such as keytool and jarsigner, and
1019     // ensures the output is in US English.
1020     private static OutputAnalyzer execTool(String toolPath, String... args)
1021             throws Throwable {
1022         long start = System.currentTimeMillis();
1023         try {
1024 
1025             String[] cmd = new String[args.length + 4];
1026             cmd[0] = toolPath;
1027             cmd[1] = &quot;-J-Duser.language=en&quot;;
1028             cmd[2] = &quot;-J-Duser.country=US&quot;;
1029             cmd[3] = &quot;-J-Djava.security.egd=file:/dev/./urandom&quot;;
1030             System.arraycopy(args, 0, cmd, 4, args.length);
1031             return ProcessTools.executeCommand(cmd);
1032 
1033         } finally {
1034             long end = System.currentTimeMillis();
1035             System.out.println(&quot;child process duration [ms]: &quot; + (end - start));
1036         }
1037     }
1038 
1039     private static class JdkInfo {
1040 
1041         private int index;
1042         private final String jdkPath;
1043         private final String jarsignerPath;
1044         private final String runtimeVersion;
1045         private String version;
1046         private final int majorVersion;
1047         private final boolean supportsTsadigestalg;
1048 
1049         private Map&lt;String, Boolean&gt; sigalgMap = new HashMap&lt;&gt;();
1050 
1051         private JdkInfo(String jdkPath) throws Throwable {
1052             this.jdkPath = jdkPath;
1053             jarsignerPath = jarsignerPath(jdkPath);
1054             runtimeVersion = execJdkUtils(jdkPath, JdkUtils.M_JAVA_RUNTIME_VERSION);
1055             if (runtimeVersion == null || runtimeVersion.isBlank()) {
1056                 throw new RuntimeException(
1057                         &quot;Cannot determine the JDK version: &quot; + jdkPath);
1058             }
1059             version = execJdkUtils(jdkPath, JdkUtils.M_JAVA_VERSION);
1060             majorVersion = Integer.parseInt((runtimeVersion.matches(&quot;^1[.].*&quot;) ?
1061                     runtimeVersion.substring(2) : runtimeVersion).replaceAll(&quot;[^0-9].*$&quot;, &quot;&quot;));
1062             supportsTsadigestalg = execTool(jarsignerPath, &quot;-help&quot;)
1063                     .getOutput().contains(&quot;-tsadigestalg&quot;);
1064         }
1065 
1066         private boolean isSupportedSigalg(String sigalg) throws Throwable {
1067             if (!sigalgMap.containsKey(sigalg)) {
1068                 boolean isSupported = Boolean.parseBoolean(
1069                         execJdkUtils(
1070                                 jdkPath,
1071                                 JdkUtils.M_IS_SUPPORTED_SIGALG,
1072                                 sigalg));
1073                 sigalgMap.put(sigalg, isSupported);
1074             }
1075 
1076             return sigalgMap.get(sigalg);
1077         }
1078 
1079         private boolean isAtLeastMajorVersion(int minVersion) {
1080             return majorVersion &gt;= minVersion;
1081         }
1082 
1083         private boolean supportsKeyAlg(String keyAlgorithm) {
1084             // JDK 6 doesn&#39;t support EC
1085             return isAtLeastMajorVersion(6) || !EC.equals(keyAlgorithm);
1086         }
1087 
1088         @Override
1089         public int hashCode() {
1090             final int prime = 31;
1091             int result = 1;
1092             result = prime * result
1093                     + ((runtimeVersion == null) ? 0 : runtimeVersion.hashCode());
1094             return result;
1095         }
1096 
1097         @Override
1098         public boolean equals(Object obj) {
1099             if (this == obj)
1100                 return true;
1101             if (obj == null)
1102                 return false;
1103             if (getClass() != obj.getClass())
1104                 return false;
1105             JdkInfo other = (JdkInfo) obj;
1106             if (runtimeVersion == null) {
1107                 if (other.runtimeVersion != null)
1108                     return false;
1109             } else if (!runtimeVersion.equals(other.runtimeVersion))
1110                 return false;
1111             return true;
1112         }
1113 
1114         @Override
1115         public String toString() {
1116             return &quot;JdkInfo[&quot; + runtimeVersion + &quot;, &quot; + jdkPath + &quot;]&quot;;
1117         }
1118     }
1119 
1120     private static class TsaInfo {
1121 
1122         private final int index;
1123         private final String tsaUrl;
1124         private Set&lt;String&gt; digestList = new HashSet&lt;&gt;();
1125 
1126         private TsaInfo(int index, String tsa) {
1127             this.index = index;
1128             this.tsaUrl = tsa;
1129         }
1130 
1131         private void addDigest(String digest) {
1132             digestList.add(digest);
1133         }
1134 
1135         private boolean isDigestSupported(String digest) {
1136             return digest == null || digestList.isEmpty()
1137                     || digestList.contains(digest);
1138         }
1139 
1140         @Override
1141         public String toString() {
1142             return &quot;TsaInfo[&quot; + index + &quot;, &quot; + tsaUrl + &quot;]&quot;;
1143         }
1144     }
1145 
1146     private static class CertInfo {
1147 
1148         private static int certCounter;
1149 
1150         // nr distinguishes cert CNs in jarsigner -verify output
1151         private final int nr = ++certCounter;
1152         private final JdkInfo jdkInfo;
1153         private final String keyAlgorithm;
1154         private final String digestAlgorithm;
1155         private final int keySize;
1156         private final boolean expired;
1157 
1158         private CertInfo(JdkInfo jdkInfo, String keyAlgorithm,
1159                 String digestAlgorithm, int keySize, boolean expired) {
1160             this.jdkInfo = jdkInfo;
1161             this.keyAlgorithm = keyAlgorithm;
1162             this.digestAlgorithm = digestAlgorithm;
1163             this.keySize = keySize;
1164             this.expired = expired;
1165         }
1166 
1167         private String sigalg() {
1168             return DEFAULT.equals(digestAlgorithm) ? null : expectedSigalg();
1169         }
1170 
1171         private String expectedSigalg() {
1172             return (DEFAULT.equals(this.digestAlgorithm) ? this.digestAlgorithm
1173                     : &quot;SHA-256&quot;).replace(&quot;-&quot;, &quot;&quot;) + &quot;with&quot; +
1174                     keyAlgorithm + (EC.equals(keyAlgorithm) ? &quot;DSA&quot; : &quot;&quot;);
1175         }
1176 
1177         private int expectedKeySize() {
1178             if (keySize != 0) return keySize;
1179 
1180             // defaults
1181             if (RSA.equals(keyAlgorithm) || DSA.equals(keyAlgorithm)) {
1182                 return 2048;
1183             } else if (EC.equals(keyAlgorithm)) {
1184                 return 256;
1185             } else {
1186                 throw new RuntimeException(&quot;problem determining key size&quot;);
1187             }
1188         }
1189 
1190         @Override
1191         public int hashCode() {
1192             final int prime = 31;
1193             int result = 1;
1194             result = prime * result
1195                     + (digestAlgorithm == null ? 0 : digestAlgorithm.hashCode());
1196             result = prime * result + (expired ? 1231 : 1237);
1197             result = prime * result
1198                     + (jdkInfo == null ? 0 : jdkInfo.hashCode());
1199             result = prime * result
1200                     + (keyAlgorithm == null ? 0 : keyAlgorithm.hashCode());
1201             result = prime * result + keySize;
1202             return result;
1203         }
1204 
1205         @Override
1206         public boolean equals(Object obj) {
1207             if (this == obj)
1208                 return true;
1209             if (obj == null)
1210                 return false;
1211             if (getClass() != obj.getClass())
1212                 return false;
1213             CertInfo other = (CertInfo) obj;
1214             if (digestAlgorithm == null) {
1215                 if (other.digestAlgorithm != null)
1216                     return false;
1217             } else if (!digestAlgorithm.equals(other.digestAlgorithm))
1218                 return false;
1219             if (expired != other.expired)
1220                 return false;
1221             if (jdkInfo == null) {
1222                 if (other.jdkInfo != null)
1223                     return false;
1224             } else if (!jdkInfo.equals(other.jdkInfo))
1225                 return false;
1226             if (keyAlgorithm == null) {
1227                 if (other.keyAlgorithm != null)
1228                     return false;
1229             } else if (!keyAlgorithm.equals(other.keyAlgorithm))
1230                 return false;
1231             if (keySize != other.keySize)
1232                 return false;
1233             return true;
1234         }
1235 
1236         private String alias() {
1237             return (jdkInfo.version + &quot;_&quot; + toString())
1238                     // lower case for jks due to
1239                     // sun.security.provider.JavaKeyStore.JDK.convertAlias
1240                     .toLowerCase(Locale.ENGLISH);
1241         }
1242 
1243         @Override
1244         public String toString() {
1245             return &quot;nr&quot; + nr + &quot;_&quot;
1246                     + keyAlgorithm + &quot;_&quot; + digestAlgorithm
1247                     + (keySize == 0 ? &quot;&quot; : &quot;_&quot; + keySize)
1248                     + (expired ? &quot;_Expired&quot; : &quot;&quot;);
1249         }
1250     }
1251 
1252     // It does only one timestamping for the same JDK, digest algorithm and
1253     // TSA service with an arbitrary valid/expired certificate.
1254     private static class TsaFilter {
1255 
1256         private static final Set&lt;Condition&gt; SET = new HashSet&lt;&gt;();
1257 
1258         private static boolean filter(String signerVersion,
1259                 String digestAlgorithm, boolean expiredCert, int tsaIndex) {
1260             return !SET.add(new Condition(signerVersion, digestAlgorithm,
1261                     expiredCert, tsaIndex));
1262         }
1263 
1264         private static class Condition {
1265 
1266             private final String signerVersion;
1267             private final String digestAlgorithm;
1268             private final boolean expiredCert;
1269             private final int tsaIndex;
1270 
1271             private Condition(String signerVersion, String digestAlgorithm,
1272                     boolean expiredCert, int tsaIndex) {
1273                 this.signerVersion = signerVersion;
1274                 this.digestAlgorithm = digestAlgorithm;
1275                 this.expiredCert = expiredCert;
1276                 this.tsaIndex = tsaIndex;
1277             }
1278 
1279             @Override
1280             public int hashCode() {
1281                 final int prime = 31;
1282                 int result = 1;
1283                 result = prime * result
1284                         + ((digestAlgorithm == null) ? 0 : digestAlgorithm.hashCode());
1285                 result = prime * result + (expiredCert ? 1231 : 1237);
1286                 result = prime * result
1287                         + ((signerVersion == null) ? 0 : signerVersion.hashCode());
1288                 result = prime * result + tsaIndex;
1289                 return result;
1290             }
1291 
1292             @Override
1293             public boolean equals(Object obj) {
1294                 if (this == obj)
1295                     return true;
1296                 if (obj == null)
1297                     return false;
1298                 if (getClass() != obj.getClass())
1299                     return false;
1300                 Condition other = (Condition) obj;
1301                 if (digestAlgorithm == null) {
1302                     if (other.digestAlgorithm != null)
1303                         return false;
1304                 } else if (!digestAlgorithm.equals(other.digestAlgorithm))
1305                     return false;
1306                 if (expiredCert != other.expiredCert)
1307                     return false;
1308                 if (signerVersion == null) {
1309                     if (other.signerVersion != null)
1310                         return false;
1311                 } else if (!signerVersion.equals(other.signerVersion))
1312                     return false;
1313                 if (tsaIndex != other.tsaIndex)
1314                     return false;
1315                 return true;
1316             }
1317         }}
1318 
1319     private static enum Status {
1320 
1321         // No action due to pre-action fails.
1322         NONE,
1323 
1324         // jar is signed/verified with error
1325         ERROR,
1326 
1327         // jar is signed/verified with warning
1328         WARNING,
1329 
1330         // jar is signed/verified without any warning and error
1331         NORMAL
1332     }
1333 
1334     private static class SignItem {
1335 
1336         private SignItem prevSign;
1337         private CertInfo certInfo;
1338         private JdkInfo jdkInfo;
1339         private String digestAlgorithm;
1340         private String tsaDigestAlgorithm;
1341         private int tsaIndex;
1342         private Status status;
1343         private String unsignedJar;
1344         private String signedJar;
1345         private List&lt;String&gt; jarContents = new ArrayList&lt;&gt;();
1346 
1347         private List&lt;VerifyItem&gt; verifyItems = new ArrayList&lt;&gt;();
1348 
1349         private static SignItem build() {
1350             return new SignItem()
1351                     .addContentFiles(Arrays.asList(&quot;META-INF/MANIFEST.MF&quot;));
1352         }
1353 
1354         private static SignItem build(SignItem prevSign) {
1355             return build().prevSign(prevSign).unsignedJar(prevSign.signedJar)
1356                     .addContentFiles(prevSign.jarContents);
1357         }
1358 
1359         private SignItem prevSign(SignItem prevSign) {
1360             this.prevSign = prevSign;
1361             return this;
1362         }
1363 
1364         private SignItem certInfo(CertInfo certInfo) {
1365             this.certInfo = certInfo;
1366             return this;
1367         }
1368 
1369         private SignItem jdkInfo(JdkInfo jdkInfo) {
1370             this.jdkInfo = jdkInfo;
1371             return this;
1372         }
1373 
1374         private SignItem digestAlgorithm(String digestAlgorithm) {
1375             this.digestAlgorithm = digestAlgorithm;
1376             return this;
1377         }
1378 
1379         String expectedDigestAlg() {
1380             return digestAlgorithm != null ? digestAlgorithm : &quot;SHA-256&quot;;
1381         }
1382 
1383         private SignItem tsaDigestAlgorithm(String tsaDigestAlgorithm) {
1384             this.tsaDigestAlgorithm = tsaDigestAlgorithm;
1385             return this;
1386         }
1387 
1388         String expectedTsaDigestAlg() {
1389             return tsaDigestAlgorithm != null ? tsaDigestAlgorithm : &quot;SHA-256&quot;;
1390         }
1391 
1392         private SignItem tsaIndex(int tsaIndex) {
1393             this.tsaIndex = tsaIndex;
1394             return this;
1395         }
1396 
1397         private SignItem status(Status status) {
1398             this.status = status;
1399             return this;
1400         }
1401 
1402         private SignItem unsignedJar(String unsignedJar) {
1403             this.unsignedJar = unsignedJar;
1404             return this;
1405         }
1406 
1407         private SignItem signedJar(String signedJar) {
1408             this.signedJar = signedJar;
1409             return this;
1410         }
1411 
1412         private SignItem addContentFiles(List&lt;String&gt; files) {
1413             this.jarContents.addAll(files);
1414             return this;
1415         }
1416 
1417         private void addVerifyItem(VerifyItem verifyItem) {
1418             verifyItems.add(verifyItem);
1419         }
1420 
1421         private boolean isErrorInclPrev() {
1422             if (prevSign != null &amp;&amp; prevSign.isErrorInclPrev()) {
1423                 System.out.println(&quot;SignItem.isErrorInclPrev: returning true from previous&quot;);
1424                 return true;
1425             }
1426 
1427             return status == Status.ERROR;
1428         }
1429         private List&lt;String&gt; toStringWithPrev(Function&lt;SignItem,String&gt; toStr) {
1430             List&lt;String&gt; s = new ArrayList&lt;&gt;();
1431             if (prevSign != null) {
1432                 s.addAll(prevSign.toStringWithPrev(toStr));
1433             }
1434             if (status != null) { // no status means jar creation or update item
1435                 s.add(toStr.apply(this));
1436             }
1437             return s;
1438         }
1439     }
1440 
1441     private static class VerifyItem {
1442 
1443         private VerifyItem prevVerify;
1444         private CertInfo certInfo;
1445         private JdkInfo jdkInfo;
1446         private Status status = Status.NONE;
1447         private Status delayStatus = Status.NONE;
1448 
1449         private static VerifyItem build(JdkInfo jdkInfo) {
1450             VerifyItem verifyItem = new VerifyItem();
1451             verifyItem.jdkInfo = jdkInfo;
1452             return verifyItem;
1453         }
1454 
1455         private VerifyItem certInfo(CertInfo certInfo) {
1456             this.certInfo = certInfo;
1457             return this;
1458         }
1459 
1460         private void addSignerCertInfos(SignItem signItem) {
1461             VerifyItem prevVerify = this;
1462             CertInfo lastCertInfo = null;
1463             while (signItem != null) {
1464                 // (signItem.certInfo == null) means create or update jar step
1465                 if (signItem.certInfo != null
1466                         &amp;&amp; !signItem.certInfo.equals(lastCertInfo)) {
1467                     lastCertInfo = signItem.certInfo;
1468                     prevVerify = prevVerify.prevVerify =
1469                             build(jdkInfo).certInfo(signItem.certInfo);
1470                 }
1471                 signItem = signItem.prevSign;
1472             }
1473         }
1474 
1475         private VerifyItem status(Status status) {
1476             this.status = status;
1477             return this;
1478         }
1479 
1480         private boolean isErrorInclPrev() {
1481             if (prevVerify != null &amp;&amp; prevVerify.isErrorInclPrev()) {
1482                 System.out.println(&quot;VerifyItem.isErrorInclPrev: returning true from previous&quot;);
1483                 return true;
1484             }
1485 
1486             return status == Status.ERROR || delayStatus == Status.ERROR;
1487         }
1488 
1489         private VerifyItem delayStatus(Status status) {
1490             this.delayStatus = status;
1491             return this;
1492         }
1493 
1494         private List&lt;String&gt; toStringWithPrev(
1495                 Function&lt;VerifyItem,String&gt; toStr) {
1496             List&lt;String&gt; s = new ArrayList&lt;&gt;();
1497             if (prevVerify != null) {
1498                 s.addAll(prevVerify.toStringWithPrev(toStr));
1499             }
1500             s.add(toStr.apply(this));
1501             return s;
1502         }
1503     }
1504 
1505     // The identifier for a specific signing.
1506     private static String signingId(SignItem signItem) {
1507         return signItem.signedJar;
1508     }
1509 
1510     // The identifier for a specific verifying.
1511     private static String verifyingId(SignItem signItem, VerifyItem verifyItem,
1512             boolean delayVerify) {
1513         return signingId(signItem) + (delayVerify ? &quot;-DV&quot; : &quot;-V&quot;)
1514                 + &quot;_&quot; + verifyItem.jdkInfo.version +
1515                 (verifyItem.certInfo == null ? &quot;&quot; : &quot;_&quot; + verifyItem.certInfo);
1516     }
1517 
1518     private static String reportRow(SignItem signItem, VerifyItem verifyItem) {
1519         List&lt;String&gt; values = new ArrayList&lt;&gt;();
1520         Consumer&lt;Function&lt;SignItem, String&gt;&gt; s_values_add = f -&gt; {
1521             values.add(String.join(&quot;&lt;br/&gt;&lt;br/&gt;&quot;, signItem.toStringWithPrev(f)));
1522         };
1523         Consumer&lt;Function&lt;VerifyItem, String&gt;&gt; v_values_add = f -&gt; {
1524             values.add(String.join(&quot;&lt;br/&gt;&lt;br/&gt;&quot;, verifyItem.toStringWithPrev(f)));
1525         };
1526         s_values_add.accept(i -&gt; i.unsignedJar + &quot; -&gt; &quot; + i.signedJar);
1527         s_values_add.accept(i -&gt; i.certInfo.toString());
1528         s_values_add.accept(i -&gt; i.jdkInfo.version);
1529         s_values_add.accept(i -&gt; i.certInfo.expectedSigalg());
1530         s_values_add.accept(i -&gt;
1531                 null2Default(i.digestAlgorithm, i.expectedDigestAlg()));
1532         s_values_add.accept(i -&gt; i.tsaIndex == -1 ? &quot;&quot; :
1533                 null2Default(i.tsaDigestAlgorithm, i.expectedTsaDigestAlg()));
1534         s_values_add.accept(i -&gt; i.tsaIndex == -1 ? &quot;&quot; : i.tsaIndex + &quot;&quot;);
1535         s_values_add.accept(i -&gt; HtmlHelper.anchorLink(
1536                 PhaseOutputStream.fileName(PhaseOutputStream.Phase.SIGNING),
1537                 signingId(i),
1538                 &quot;&quot; + i.status));
1539         values.add(verifyItem.jdkInfo.version);
1540         v_values_add.accept(i -&gt;
1541                 i.certInfo == null ? &quot;no alias&quot; : &quot;&quot; + i.certInfo);
1542         v_values_add.accept(i -&gt; HtmlHelper.anchorLink(
1543                 PhaseOutputStream.fileName(PhaseOutputStream.Phase.VERIFYING),
1544                 verifyingId(signItem, i, false),
1545                 &quot;&quot; + i.status.toString()));
1546         if (DELAY_VERIFY) {
1547             v_values_add.accept(i -&gt; HtmlHelper.anchorLink(
1548                     PhaseOutputStream.fileName(
1549                             PhaseOutputStream.Phase.DELAY_VERIFYING),
1550                     verifyingId(signItem, verifyItem, true),
1551                     verifyItem.delayStatus.toString()));
1552         }
1553         values.add(isFailed(signItem, verifyItem) ? &quot;X&quot; : &quot;&quot;);
1554         return HtmlHelper.htmlRow(values.toArray(new String[values.size()]));
1555     }
1556 
1557     private static boolean isFailed(SignItem signItem, VerifyItem verifyItem) {
1558         System.out.println(&quot;isFailed: signItem = &quot; + signItem + &quot;, verifyItem = &quot; + verifyItem);
1559         // TODO: except known failing cases
1560 
1561         // Note about isAtLeastMajorVersion in the following conditions:
1562         // signItem.jdkInfo is the jdk which signed the jar last and
1563         // signItem.prevSign.jdkInfo is the jdk which signed the jar first
1564         // assuming only two successive signatures as there actually are now.
1565         // the first signature always works and always has. subject here is
1566         // the update of an already signed jar. the following conditions always
1567         // depend on the second jdk that updated the jar with another signature
1568         // and the first one (signItem(.prevSign)+.jdkInfo) can be ignored.
1569         // this is different for verifyItem. verifyItem.prevVerify refers to
1570         // the first signature created by signItem(.prevSign)+.jdkInfo.
1571         // all verifyItem(.prevVerify)+.jdkInfo however point always to the same
1572         // jdk, only their certInfo is different. the same signatures are
1573         // verified with different jdks in different top-level VerifyItems
1574         // attached directly to signItem.verifyItems and not to
1575         // verifyItem.prevVerify.
1576 
1577         // ManifestDigester fails to parse manifests ending in &#39;\r&#39; with
1578         // IndexOutOfBoundsException at ManifestDigester.java:87 before 8217375
1579         if (signItem.signedJar.startsWith(&quot;eofr&quot;)
1580                 &amp;&amp; !signItem.jdkInfo.isAtLeastMajorVersion(13)
1581                 &amp;&amp; !verifyItem.jdkInfo.isAtLeastMajorVersion(13)) return false;
1582 
1583         // if there is no blank line after main attributes, JarSigner adds
1584         // individual sections nevertheless without being properly delimited
1585         // in JarSigner.java:777..790 without checking for blank line
1586         // before 8217375
1587 //        if (signItem.signedJar.startsWith(&quot;eofn-&quot;)
1588 //                &amp;&amp; signItem.signedJar.contains(&quot;-addfile-&quot;)
1589 //                &amp;&amp; !signItem.jdkInfo.isAtLeastMajorVersion(13)
1590 //                &amp;&amp; !verifyItem.jdkInfo.isAtLeastMajorVersion(13)) return false; // FIXME
1591 
1592 //        System.out.println(&quot;isFailed: signItem.isErrorInclPrev() &quot; + signItem.isErrorInclPrev());
1593 //        System.out.println(&quot;isFailed: verifyItem.isErrorInclPrev() &quot; + verifyItem.isErrorInclPrev());
1594         boolean isFailed = signItem.isErrorInclPrev() || verifyItem.isErrorInclPrev();
1595         System.out.println(&quot;isFailed: returning &quot; + isFailed);
1596         return isFailed;
1597     }
1598 
1599     // If a value is null, then displays the default value or N/A.
1600     private static String null2Default(String value, String defaultValue) {
1601         return value != null ? value :
1602                DEFAULT + &quot;(&quot; + (defaultValue == null
1603                                   ? &quot;N/A&quot;
1604                                   : defaultValue) + &quot;)&quot;;
1605     }
1606 
1607 }
    </pre>
  </body>
</html>
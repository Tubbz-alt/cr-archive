<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New test/jdk/sun/security/tools/jarsigner/InsufficientSectionDelimiter.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 import java.io.File;
 25 import java.io.IOException;
 26 import java.io.OutputStream;
 27 import java.nio.file.Files;
 28 import java.nio.file.Path;
 29 import java.util.Map;
 30 import java.util.stream.Stream;
 31 import java.util.jar.Attributes.Name;
 32 import java.util.jar.Manifest;
 33 import jdk.test.lib.util.JarUtils;
 34 import jdk.test.lib.SecurityTools;
 35 import org.testng.annotations.BeforeTest;
 36 import org.testng.annotations.BeforeMethod;
 37 import org.testng.annotations.DataProvider;
 38 import org.testng.annotations.Factory;
 39 import org.testng.annotations.Test;
 40 
 41 import static java.nio.charset.StandardCharsets.UTF_8;
 42 
 43 /**
 44  * @test
 45  * @bug 8217375
 46  * @library /test/lib
 47  * @run testng InsufficientSectionDelimiter
 48  * @summary Checks some cases signing a jar the manifest of which has no or
 49  * only one line break at the end and no proper delimiting blank line does not
 50  * result in an invalid signed jar without jarsigner noticing and failing.
 51  *
 52  * &lt;p&gt;See also&lt;ul&gt;
 53  * &lt;li&gt;{@link PreserveRawManifestEntryAndDigest} with an update of a signed
 54  * jar with a different signer whereas this test just signs with one signer
 55  * &lt;/li&gt;
 56  * &lt;li&gt;{@link WasSignedByOtherSigner} for a test that detects if
 57  * {@code wasSigned} in {@link jdk.security.jarsigner.JarSigner#sign0} was set
 58  * correctly determining whether or not to re-write the manifest, and&lt;/li&gt;
 59  * &lt;li&gt;{@code diffend.sh} for another similar test&lt;/li&gt;&lt;/ul&gt;
 60  */
 61 public class InsufficientSectionDelimiter {
 62 
 63     static final String KEYSTORE_FILENAME = &quot;test.jks&quot;;
 64 
 65     @BeforeTest
 66     public void prepareCertificate() throws Exception {
 67         SecurityTools.keytool(&quot;-genkeypair -keyalg EC -keystore &quot;
 68                 + KEYSTORE_FILENAME + &quot; -storepass changeit -keypass changeit&quot;
 69                 + &quot; -alias a -dname CN=A&quot;).shouldHaveExitValue(0);
 70     }
 71 
 72     @BeforeTest
 73     public void prepareFakeSfFile() throws IOException {
 74         new File(&quot;META-INF&quot;).mkdir();
 75         Files.write(Path.of(&quot;META-INF/.SF&quot;), (
 76                 Name.SIGNATURE_VERSION + &quot;: 1.0\r\n&quot; +
 77                 &quot;-Digest-Manifest: \r\n\r\n&quot;).getBytes(UTF_8));
 78     }
 79 
 80     @DataProvider(name = &quot;parameters&quot;)
 81     public static Object[][] parameters() {
 82         return new String[][] { { &quot;&quot; }, { &quot;\n&quot; }, { &quot;\r&quot; }, { &quot;\r\n&quot; } };
 83     }
 84 
 85     @Factory(dataProvider = &quot;parameters&quot;)
 86     public static Object[] createTests(String lineBreak) {
 87         return new Object[] { new InsufficientSectionDelimiter(lineBreak) };
 88     }
 89 
 90     final String lineBreak;
 91     final String jarFilenameSuffix;
 92 
 93     InsufficientSectionDelimiter(String lineBreak) {
 94         this.lineBreak = lineBreak;
 95         jarFilenameSuffix = Utils.escapeStringWithNumbers(lineBreak);
 96     }
 97 
 98     @BeforeMethod
 99     public void verbose() {
100         System.out.println(&quot;lineBreak = &quot;
101                 + Utils.escapeStringWithNumbers(lineBreak));
102     }
103 
104     void test(String jarFilenamePrefix, String... files) throws Exception {
105         String jarFilename = jarFilenamePrefix + jarFilenameSuffix + &quot;.jar&quot;;
106         JarUtils.createJarFile(Path.of(jarFilename), new Manifest() {
107             @Override public void write(OutputStream out) throws IOException {
108                 out.write((Name.MANIFEST_VERSION + &quot;: 1.0&quot; +
109                         lineBreak).getBytes(UTF_8));
110             }
111         }, Path.of(&quot;.&quot;), Stream.of(files).map(Path::of).toArray(Path[]::new)
112         );
113         Utils.echoManifest(Utils.readJarManifestBytes(
114                 jarFilename), &quot;unsigned jar&quot;);
115         try {
116             SecurityTools.jarsigner(&quot;-keystore &quot; + KEYSTORE_FILENAME +
117                     &quot; -storepass changeit -verbose -debug &quot; + jarFilename +
118                     &quot; a&quot;).shouldHaveExitValue(0);
119             Utils.echoManifest(Utils.readJarManifestBytes(
120                     jarFilename), &quot;signed jar&quot;);
121         } catch (Exception e) {
122             if (lineBreak.isEmpty()) {
123                 return; // invalid manifest without trailing line break
124             }
125             throw e;
126         }
127 
128         // remove META-INF/.SF from signed jar which would not validate
129         // (not added in all the test cases)
130         JarUtils.updateJar(jarFilename, &quot;verify-&quot; + jarFilename,
131                 Map.of(&quot;META-INF/.SF&quot;, false));
132         SecurityTools.jarsigner(&quot;-verify -strict -keystore &quot; +
133                 KEYSTORE_FILENAME + &quot; -storepass changeit -debug -verbose &quot; +
134                 &quot;verify-&quot; + jarFilename + &quot; a&quot;).shouldHaveExitValue(0);
135     }
136 
137     /**
138      * Test that signing a jar which has never been signed yet and contains
139      * no signature related files with a manifest that ends immediately after
140      * the last main attributes value byte or only one line break and no blank
141      * line produces a valid signed jar or an error if the manifest ends
142      * without line break.
143      */
144     @Test
145     public void testOnlyMainAttrs() throws Exception {
146         test(&quot;testOnlyMainAttrs&quot;);
147     }
148 
149     /**
150      * Test that signing a jar with a manifest that ends immediately after
151      * the last main attributes value byte or with too few line break
152      * characters to properly delimit an individual section and has a fake
153      * signing related file to trigger a signature update or more specifically
154      * wasSigned in JarSigner.sign0 to become true produces a valid signed jar
155      * or an error if the manifest ends without line break.
156      * &lt;p&gt;
157      * Only one line break and hence no blank line (&#39;\r&#39;, &#39;\n&#39;, or &#39;\r\n&#39;)
158      * after last main attributes value byte is too little to delimit an
159      * individual section to hold a file&#39;s digest but acceptable if no
160      * individual section has to be added because no contained file has to be
161      * signed as is the case in this test.
162      *
163      * @see #testMainAttrsWasSignedAddFile
164      */
165     @Test
166     public void testMainAttrsWasSigned() throws Exception {
167         test(&quot;testMainAttrsWasSigned&quot;, &quot;META-INF/.SF&quot;);
168     }
169 
170     /**
171      * Test that signing a jar with a manifest that ends immediately after
172      * the last main attributes value byte or with too few line break
173      * characters to properly delimit an individual section and has a fake
174      * signing related file to trigger a signature update or more specifically
175      * wasSigned in JarSigner.sign0 to become true produces no invalid signed
176      * jar or an error if the manifest ends without line break.
177      * &lt;p&gt;
178      * Only one line break and hence no blank line (&#39;\r&#39;, &#39;\n&#39;, or &#39;\r\n&#39;)
179      * after the last main attributes value byte is too little to delimit an
180      * individual section which would be required here to save the digest of a
181      * contained file to be signed.
182      * &lt;p&gt;
183      * Changing the delimiters after the main attributes changes the main
184      * attributes digest but
185      * {@link SignatureFileVerifier#verifyManifestMainAttrs} and
186      * {@link ManifestDigester#digestWorkaround} work around it.
187      */
188     @Test
189     public void testMainAttrsWasSignedAddFile() throws Exception {
190         Files.write(Path.of(&quot;test.txt&quot;), &quot;test.txt&quot;.getBytes(UTF_8));
191         test(&quot;testMainAttrsWasSignedAddFile&quot;, &quot;META-INF/.SF&quot;, &quot;test.txt&quot;);
192     }
193 
194 }
    </pre>
  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff test/jdk/sun/security/tools/jarsigner/compatibility/Compatibility.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
<body>
<center><a href="../Warning.java.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="DetailsOutputStream.java.cdiff.html" target="_top">next &gt;</a></center>    <h2>test/jdk/sun/security/tools/jarsigner/compatibility/Compatibility.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 1,7 ***</span>
  /*
<span class="line-modified">!  * Copyright (c) 2017, 2018, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.
<span class="line-new-header">--- 1,7 ---</span>
  /*
<span class="line-modified">!  * Copyright (c) 2017, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 21,59 ***</span>
   * questions.
   */
  
  /*
   * @test
<span class="line-modified">!  * @summary This test is used to verify the compatibility on jarsigner cross</span>
   *     different JDK releases. It also can be used to check jar signing (w/
<span class="line-modified">!  *     and w/o TSA) and verifying on some specific key algorithms and digest</span>
<span class="line-modified">!  *     algorithms.</span>
<span class="line-modified">!  *     Note that, this is a manual test. For more details about the test and</span>
<span class="line-removed">-  *     its usages, please look through README.</span>
   *
<span class="line-modified">!  * @modules java.base/sun.security.pkcs</span>
<span class="line-removed">-  *          java.base/sun.security.timestamp</span>
<span class="line-removed">-  *          java.base/sun.security.tools.keytool</span>
<span class="line-removed">-  *          java.base/sun.security.util</span>
<span class="line-removed">-  *          java.base/sun.security.x509</span>
<span class="line-removed">-  * @library /test/lib /lib/testlibrary ../warnings</span>
   * @compile -source 1.7 -target 1.7 JdkUtils.java
   * @run main/manual/othervm Compatibility
   */
  
  import java.io.BufferedReader;
  import java.io.File;
  import java.io.FileReader;
  import java.io.FileWriter;
  import java.io.IOException;
  import java.io.PrintStream;
  import java.text.DateFormat;
  import java.text.SimpleDateFormat;
  import java.util.ArrayList;
  import java.util.Calendar;
  import java.util.Date;
  import java.util.HashMap;
  import java.util.HashSet;
  import java.util.List;
  import java.util.Map;
  import java.util.Set;
  import java.util.concurrent.TimeUnit;
<span class="line-modified">! import java.util.regex.Matcher;</span>
<span class="line-modified">! import java.util.regex.Pattern;</span>
  
  import jdk.test.lib.process.OutputAnalyzer;
  import jdk.test.lib.process.ProcessTools;
  import jdk.test.lib.util.JarUtils;
  
  public class Compatibility {
  
<span class="line-removed">-     private static final String TEST_JAR_NAME = &quot;test.jar&quot;;</span>
<span class="line-removed">- </span>
      private static final String TEST_SRC = System.getProperty(&quot;test.src&quot;);
      private static final String TEST_CLASSES = System.getProperty(&quot;test.classes&quot;);
      private static final String TEST_JDK = System.getProperty(&quot;test.jdk&quot;);
<span class="line-modified">!     private static final String TEST_JARSIGNER = jarsignerPath(TEST_JDK);</span>
  
      private static final String PROXY_HOST = System.getProperty(&quot;proxyHost&quot;);
      private static final String PROXY_PORT = System.getProperty(&quot;proxyPort&quot;, &quot;80&quot;);
  
      // An alternative security properties file.
<span class="line-new-header">--- 21,64 ---</span>
   * questions.
   */
  
  /*
   * @test
<span class="line-modified">!  * @bug 8217375</span>
<span class="line-added">+  * @summary This test is used to verify the compatibility of jarsigner across</span>
   *     different JDK releases. It also can be used to check jar signing (w/
<span class="line-modified">!  *     and w/o TSA) and to verify some specific signing and digest algorithms.</span>
<span class="line-modified">!  *     Note that this is a manual test. For more details about the test and</span>
<span class="line-modified">!  *     its usages, please look through the README.</span>
   *
<span class="line-modified">!  * @library /test/lib ../warnings</span>
   * @compile -source 1.7 -target 1.7 JdkUtils.java
   * @run main/manual/othervm Compatibility
   */
  
<span class="line-added">+ import static java.nio.charset.StandardCharsets.UTF_8;</span>
<span class="line-added">+ </span>
  import java.io.BufferedReader;
  import java.io.File;
<span class="line-added">+ import java.io.FileOutputStream;</span>
  import java.io.FileReader;
  import java.io.FileWriter;
  import java.io.IOException;
<span class="line-added">+ import java.io.OutputStream;</span>
  import java.io.PrintStream;
<span class="line-added">+ import java.nio.file.Files;</span>
<span class="line-added">+ import java.nio.file.Path;</span>
  import java.text.DateFormat;
  import java.text.SimpleDateFormat;
  import java.util.ArrayList;
<span class="line-added">+ import java.util.Arrays;</span>
  import java.util.Calendar;
  import java.util.Date;
  import java.util.HashMap;
  import java.util.HashSet;
  import java.util.List;
<span class="line-added">+ import java.util.Locale;</span>
  import java.util.Map;
  import java.util.Set;
  import java.util.concurrent.TimeUnit;
<span class="line-modified">! import java.util.function.Consumer;</span>
<span class="line-modified">! import java.util.function.Function;</span>
<span class="line-added">+ import java.util.jar.Attributes.Name;</span>
<span class="line-added">+ import java.util.jar.Manifest;</span>
<span class="line-added">+ import java.util.stream.Collectors;</span>
<span class="line-added">+ import java.util.stream.IntStream;</span>
  
  import jdk.test.lib.process.OutputAnalyzer;
  import jdk.test.lib.process.ProcessTools;
  import jdk.test.lib.util.JarUtils;
  
  public class Compatibility {
  
      private static final String TEST_SRC = System.getProperty(&quot;test.src&quot;);
      private static final String TEST_CLASSES = System.getProperty(&quot;test.classes&quot;);
      private static final String TEST_JDK = System.getProperty(&quot;test.jdk&quot;);
<span class="line-modified">!     private static JdkInfo TEST_JDK_INFO;</span>
  
      private static final String PROXY_HOST = System.getProperty(&quot;proxyHost&quot;);
      private static final String PROXY_PORT = System.getProperty(&quot;proxyPort&quot;, &quot;80&quot;);
  
      // An alternative security properties file.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 82,33 ***</span>
      // jdk.jar.disabledAlgorithms=MD2, MD5
      private static final String JAVA_SECURITY = System.getProperty(
              &quot;javaSecurityFile&quot;, TEST_SRC + &quot;/java.security&quot;);
  
      private static final String PASSWORD = &quot;testpass&quot;;
<span class="line-modified">!     private static final String KEYSTORE = &quot;testKeystore&quot;;</span>
  
      private static final String RSA = &quot;RSA&quot;;
      private static final String DSA = &quot;DSA&quot;;
      private static final String EC = &quot;EC&quot;;
<span class="line-modified">!     private static final String[] KEY_ALGORITHMS = new String[] {</span>
              RSA,
              DSA,
              EC};
  
      private static final String SHA1 = &quot;SHA-1&quot;;
      private static final String SHA256 = &quot;SHA-256&quot;;
      private static final String SHA512 = &quot;SHA-512&quot;;
      private static final String DEFAULT = &quot;DEFAULT&quot;;
<span class="line-modified">!     private static final String[] DIGEST_ALGORITHMS = new String[] {</span>
              SHA1,
              SHA256,
<span class="line-modified">!             SHA512,</span>
              DEFAULT};
  
<span class="line-modified">!     private static final boolean[] EXPIRED = new boolean[] {</span>
<span class="line-modified">!             false,</span>
<span class="line-modified">!             true};</span>
  
      private static final Calendar CALENDAR = Calendar.getInstance();
      private static final DateFormat DATE_FORMAT
              = new SimpleDateFormat(&quot;yyyy/MM/dd HH:mm:ss&quot;);
  
<span class="line-new-header">--- 87,47 ---</span>
      // jdk.jar.disabledAlgorithms=MD2, MD5
      private static final String JAVA_SECURITY = System.getProperty(
              &quot;javaSecurityFile&quot;, TEST_SRC + &quot;/java.security&quot;);
  
      private static final String PASSWORD = &quot;testpass&quot;;
<span class="line-modified">!     private static final String KEYSTORE = &quot;testKeystore.jks&quot;;</span>
  
      private static final String RSA = &quot;RSA&quot;;
      private static final String DSA = &quot;DSA&quot;;
      private static final String EC = &quot;EC&quot;;
<span class="line-modified">!     private static String[] KEY_ALGORITHMS;</span>
<span class="line-added">+     private static final String[] DEFAULT_KEY_ALGORITHMS = new String[] {</span>
              RSA,
              DSA,
              EC};
  
      private static final String SHA1 = &quot;SHA-1&quot;;
      private static final String SHA256 = &quot;SHA-256&quot;;
<span class="line-added">+     private static final String SHA384 = &quot;SHA-384&quot;;</span>
      private static final String SHA512 = &quot;SHA-512&quot;;
      private static final String DEFAULT = &quot;DEFAULT&quot;;
<span class="line-modified">!     private static String[] DIGEST_ALGORITHMS;</span>
<span class="line-added">+     private static final String[] DEFAULT_DIGEST_ALGORITHMS = new String[] {</span>
              SHA1,
              SHA256,
<span class="line-modified">!             SHA384,</span>
<span class="line-added">+             SHA512, // note: digests break onto continuation line in manifest</span>
              DEFAULT};
  
<span class="line-modified">!     private static final boolean[] EXPIRED =</span>
<span class="line-modified">!             Boolean.valueOf(System.getProperty(&quot;expired&quot;, &quot;true&quot;)) ?</span>
<span class="line-modified">!                     new boolean[] { false, true } : new boolean[] { false };</span>
<span class="line-added">+ </span>
<span class="line-added">+     private static final boolean TEST_COMPREHENSIVE_JAR_CONTENTS =</span>
<span class="line-added">+             Boolean.valueOf(System.getProperty(</span>
<span class="line-added">+                     &quot;testComprehensiveJarContents&quot;, &quot;false&quot;));</span>
<span class="line-added">+ </span>
<span class="line-added">+     private static final boolean TEST_JAR_UPDATE =</span>
<span class="line-added">+             Boolean.valueOf(System.getProperty(&quot;testJarUpdate&quot;, &quot;false&quot;));</span>
<span class="line-added">+ </span>
<span class="line-added">+     private static final boolean STRICT =</span>
<span class="line-added">+             Boolean.valueOf(System.getProperty(&quot;strict&quot;, &quot;false&quot;));</span>
  
      private static final Calendar CALENDAR = Calendar.getInstance();
      private static final DateFormat DATE_FORMAT
              = new SimpleDateFormat(&quot;yyyy/MM/dd HH:mm:ss&quot;);
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 117,11 ***</span>
      private static final int CERT_VALIDITY
              = Integer.valueOf(System.getProperty(&quot;certValidity&quot;, &quot;1440&quot;));
      static {
          if (CERT_VALIDITY &lt; 1 || CERT_VALIDITY &gt; 1440) {
              throw new RuntimeException(
<span class="line-modified">!                     &quot;certValidity if out of range [1, 1440]: &quot; + CERT_VALIDITY);</span>
          }
      }
  
      // If true, an additional verifying will be triggered after all of
      // valid certificates expire. The default value is false.
<span class="line-new-header">--- 136,11 ---</span>
      private static final int CERT_VALIDITY
              = Integer.valueOf(System.getProperty(&quot;certValidity&quot;, &quot;1440&quot;));
      static {
          if (CERT_VALIDITY &lt; 1 || CERT_VALIDITY &gt; 1440) {
              throw new RuntimeException(
<span class="line-modified">!                     &quot;certValidity out of range [1, 1440]: &quot; + CERT_VALIDITY);</span>
          }
      }
  
      // If true, an additional verifying will be triggered after all of
      // valid certificates expire. The default value is false.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 130,33 ***</span>
  
      private static long lastCertStartTime;
  
      private static DetailsOutputStream detailsOutput;
  
<span class="line-modified">!     public static void main(String[] args) throws Throwable {</span>
          // Backups stdout and stderr.
          PrintStream origStdOut = System.out;
          PrintStream origStdErr = System.err;
  
<span class="line-modified">!         detailsOutput = new DetailsOutputStream();</span>
  
          // Redirects the system output to a custom one.
          PrintStream printStream = new PrintStream(detailsOutput);
          System.setOut(printStream);
          System.setErr(printStream);
  
<span class="line-modified">!         List&lt;TsaInfo&gt; tsaList = tsaInfoList();</span>
<span class="line-removed">-         if (tsaList.size() == 0) {</span>
<span class="line-removed">-             throw new RuntimeException(&quot;TSA service is mandatory.&quot;);</span>
<span class="line-removed">-         }</span>
  
          List&lt;JdkInfo&gt; jdkInfoList = jdkInfoList();
          List&lt;CertInfo&gt; certList = createCertificates(jdkInfoList);
<span class="line-modified">!         createJar();</span>
<span class="line-modified">!         List&lt;SignItem&gt; signItems = test(jdkInfoList, tsaList, certList);</span>
  
<span class="line-modified">!         boolean failed = generateReport(tsaList, signItems);</span>
  
          // Restores the original stdout and stderr.
          System.setOut(origStdOut);
          System.setErr(origStdErr);
  
<span class="line-new-header">--- 149,40 ---</span>
  
      private static long lastCertStartTime;
  
      private static DetailsOutputStream detailsOutput;
  
<span class="line-modified">!     private static int sigfileCounter;</span>
<span class="line-added">+ </span>
<span class="line-added">+     private static String nextSigfileName(String alias, String u, String s) {</span>
<span class="line-added">+         String sigfileName = &quot;&quot; + (++sigfileCounter);</span>
<span class="line-added">+         System.out.println(&quot;using sigfile &quot; + sigfileName + &quot; for alias &quot;</span>
<span class="line-added">+                     + alias + &quot; signing &quot; + u + &quot;.jar to &quot; + s + &quot;.jar&quot;);</span>
<span class="line-added">+         return sigfileName;</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     public static void main(String... args) throws Throwable {</span>
          // Backups stdout and stderr.
          PrintStream origStdOut = System.out;
          PrintStream origStdErr = System.err;
  
<span class="line-modified">!         detailsOutput = new DetailsOutputStream(outfile());</span>
  
          // Redirects the system output to a custom one.
          PrintStream printStream = new PrintStream(detailsOutput);
          System.setOut(printStream);
          System.setErr(printStream);
  
<span class="line-modified">!         TEST_JDK_INFO = new JdkInfo(TEST_JDK);</span>
  
<span class="line-added">+         List&lt;TsaInfo&gt; tsaList = tsaInfoList();</span>
          List&lt;JdkInfo&gt; jdkInfoList = jdkInfoList();
          List&lt;CertInfo&gt; certList = createCertificates(jdkInfoList);
<span class="line-modified">!         List&lt;SignItem&gt; signItems =</span>
<span class="line-modified">!                 test(jdkInfoList, tsaList, certList, createJars());</span>
  
<span class="line-modified">!         boolean failed = generateReport(jdkInfoList, tsaList, signItems);</span>
  
          // Restores the original stdout and stderr.
          System.setOut(origStdOut);
          System.setErr(origStdErr);
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 165,186 ***</span>
                      + &quot;Please check the failed row(s) in report.html &quot;
                      + &quot;or failedReport.html.&quot;);
          }
      }
  
<span class="line-modified">!     // Creates a jar file that contains an empty file.</span>
<span class="line-modified">!     private static void createJar() throws IOException {</span>
<span class="line-modified">!         String testFile = &quot;test&quot;;</span>
<span class="line-modified">!         new File(testFile).createNewFile();</span>
<span class="line-modified">!         JarUtils.createJar(TEST_JAR_NAME, testFile);</span>
      }
  
      // Creates a key store that includes a set of valid/expired certificates
      // with various algorithms.
      private static List&lt;CertInfo&gt; createCertificates(List&lt;JdkInfo&gt; jdkInfoList)
              throws Throwable {
<span class="line-modified">!         List&lt;CertInfo&gt; certList = new ArrayList&lt;CertInfo&gt;();</span>
<span class="line-modified">!         Set&lt;String&gt; expiredCertFilter = new HashSet&lt;String&gt;();</span>
<span class="line-modified">! </span>
<span class="line-modified">!         for(JdkInfo jdkInfo : jdkInfoList) {</span>
<span class="line-modified">!             for(String keyAlgorithm : KEY_ALGORITHMS) {</span>
<span class="line-modified">!                 for(String digestAlgorithm : DIGEST_ALGORITHMS) {</span>
<span class="line-modified">!                     for(int keySize : keySizes(keyAlgorithm)) {</span>
                          for(boolean expired : EXPIRED) {
                              // It creates only one expired certificate for one
                              // key algorithm.
                              if (expired
                                      &amp;&amp; !expiredCertFilter.add(keyAlgorithm)) {
                                  continue;
                              }
  
                              CertInfo certInfo = new CertInfo(
<span class="line-modified">!                                     jdkInfo.version,</span>
                                      keyAlgorithm,
                                      digestAlgorithm,
                                      keySize,
                                      expired);
<span class="line-modified">!                             if (!certList.contains(certInfo)) {</span>
<span class="line-modified">!                                 String alias = createCertificate(</span>
<span class="line-modified">!                                         jdkInfo.jdkPath, certInfo);</span>
<span class="line-modified">!                                 if (alias != null) {</span>
<span class="line-modified">!                                     certList.add(certInfo);</span>
<span class="line-modified">!                                 }</span>
                              }
                          }
                      }
                  }
              }
          }
  
          return certList;
      }
  
      // Creates/Updates a key store that adds a certificate with specific algorithm.
<span class="line-modified">!     private static String createCertificate(String jdkPath, CertInfo certInfo)</span>
              throws Throwable {
<span class="line-modified">!         String alias = certInfo.alias();</span>
<span class="line-removed">- </span>
<span class="line-removed">-         List&lt;String&gt; arguments = new ArrayList&lt;String&gt;();</span>
          arguments.add(&quot;-J-Djava.security.properties=&quot; + JAVA_SECURITY);
          arguments.add(&quot;-v&quot;);
          arguments.add(&quot;-storetype&quot;);
          arguments.add(&quot;jks&quot;);
<span class="line-modified">!         arguments.add(&quot;-genkey&quot;);</span>
          arguments.add(&quot;-keyalg&quot;);
          arguments.add(certInfo.keyAlgorithm);
<span class="line-modified">!         String sigalg = sigalg(certInfo.digestAlgorithm, certInfo.keyAlgorithm);</span>
          if (sigalg != null) {
              arguments.add(&quot;-sigalg&quot;);
              arguments.add(sigalg);
          }
          if (certInfo.keySize != 0) {
              arguments.add(&quot;-keysize&quot;);
              arguments.add(certInfo.keySize + &quot;&quot;);
          }
          arguments.add(&quot;-dname&quot;);
<span class="line-modified">!         arguments.add(&quot;CN=Test&quot;);</span>
          arguments.add(&quot;-alias&quot;);
<span class="line-modified">!         arguments.add(alias);</span>
          arguments.add(&quot;-keypass&quot;);
          arguments.add(PASSWORD);
<span class="line-removed">-         arguments.add(&quot;-storepass&quot;);</span>
<span class="line-removed">-         arguments.add(PASSWORD);</span>
  
          arguments.add(&quot;-startdate&quot;);
          arguments.add(startDate(certInfo.expired));
          arguments.add(&quot;-validity&quot;);
          arguments.add(&quot;1&quot;);
<span class="line-removed">-         arguments.add(&quot;-keystore&quot;);</span>
<span class="line-removed">-         arguments.add(KEYSTORE);</span>
  
          OutputAnalyzer outputAnalyzer = execTool(
<span class="line-modified">!                 jdkPath + &quot;/bin/keytool&quot;,</span>
                  arguments.toArray(new String[arguments.size()]));
<span class="line-modified">!         if (outputAnalyzer.getExitValue() == 0</span>
<span class="line-modified">!                 &amp;&amp; !outputAnalyzer.getOutput().matches(&quot;[Ee]xception&quot;)) {</span>
<span class="line-modified">!             return alias;</span>
<span class="line-modified">!         } else {</span>
<span class="line-modified">!             return null;</span>
          }
      }
  
<span class="line-removed">-     private static String sigalg(String digestAlgorithm, String keyAlgorithm) {</span>
<span class="line-removed">-         if (digestAlgorithm == DEFAULT) {</span>
<span class="line-removed">-             return null;</span>
<span class="line-removed">-         }</span>
<span class="line-removed">- </span>
<span class="line-removed">-         String keyName = keyAlgorithm == EC ? &quot;ECDSA&quot; : keyAlgorithm;</span>
<span class="line-removed">-         return digestAlgorithm.replace(&quot;-&quot;, &quot;&quot;) + &quot;with&quot; + keyName;</span>
<span class="line-removed">-     }</span>
<span class="line-removed">- </span>
      // The validity period of a certificate always be 1 day. For creating an
      // expired certificate, the start date is the time before 1 day, then the
      // certificate expires immediately. And for creating a valid certificate,
      // the start date is the time before (1 day - CERT_VALIDITY minutes), then
      // the certificate will expires in CERT_VALIDITY minutes.
      private static String startDate(boolean expiredCert) {
          CALENDAR.setTime(new Date());
<span class="line-modified">!         CALENDAR.add(Calendar.DAY_OF_MONTH, -1);</span>
<span class="line-modified">!         if (!expiredCert) {</span>
              CALENDAR.add(Calendar.MINUTE, CERT_VALIDITY);
          }
          Date startDate = CALENDAR.getTime();
<span class="line-modified">!         lastCertStartTime = startDate.getTime();</span>
          return DATE_FORMAT.format(startDate);
      }
  
<span class="line-modified">!     // Retrieves JDK info from the file which is specified by property jdkListFile,</span>
<span class="line-modified">!     // or from property jdkList if jdkListFile is not available.</span>
      private static List&lt;JdkInfo&gt; jdkInfoList() throws Throwable {
          String[] jdkList = list(&quot;jdkList&quot;);
          if (jdkList.length == 0) {
<span class="line-modified">!             jdkList = new String[] { TEST_JDK };</span>
          }
  
<span class="line-modified">!         List&lt;JdkInfo&gt; jdkInfoList = new ArrayList&lt;JdkInfo&gt;();</span>
          for (String jdkPath : jdkList) {
<span class="line-modified">!             JdkInfo jdkInfo = new JdkInfo(jdkPath);</span>
              // The JDK version must be unique.
              if (!jdkInfoList.contains(jdkInfo)) {
                  jdkInfoList.add(jdkInfo);
              } else {
                  System.out.println(&quot;The JDK version is duplicate: &quot; + jdkPath);
              }
          }
          return jdkInfoList;
      }
  
      // Retrieves TSA info from the file which is specified by property tsaListFile,
      // or from property tsaList if tsaListFile is not available.
      private static List&lt;TsaInfo&gt; tsaInfoList() throws IOException {
          String[] tsaList = list(&quot;tsaList&quot;);
  
<span class="line-modified">!         List&lt;TsaInfo&gt; tsaInfoList = new ArrayList&lt;TsaInfo&gt;();</span>
          for (int i = 0; i &lt; tsaList.length; i++) {
              String[] values = tsaList[i].split(&quot;;digests=&quot;);
  
              String[] digests = new String[0];
              if (values.length == 2) {
                  digests = values[1].split(&quot;,&quot;);
              }
  
<span class="line-modified">!             TsaInfo bufTsa = new TsaInfo(i, values[0]);</span>
<span class="line-modified">! </span>
              for (String digest : digests) {
<span class="line-modified">!                 bufTsa.addDigest(digest);</span>
              }
<span class="line-removed">- </span>
              tsaInfoList.add(bufTsa);
          }
  
          return tsaInfoList;
      }
  
<span class="line-modified">!     private static String[] list(String listProp)</span>
<span class="line-removed">-             throws IOException {</span>
          String listFileProp = listProp + &quot;File&quot;;
          String listFile = System.getProperty(listFileProp);
          if (!isEmpty(listFile)) {
              System.out.println(listFileProp + &quot;=&quot; + listFile);
<span class="line-modified">!             List&lt;String&gt; list = new ArrayList&lt;String&gt;();</span>
              BufferedReader reader = new BufferedReader(
                      new FileReader(listFile));
              String line;
              while ((line = reader.readLine()) != null) {
                  String item = line.trim();
<span class="line-new-header">--- 191,327 ---</span>
                      + &quot;Please check the failed row(s) in report.html &quot;
                      + &quot;or failedReport.html.&quot;);
          }
      }
  
<span class="line-modified">!     private static SignItem createJarFile(String jar, Manifest m,</span>
<span class="line-modified">!             String... files) throws IOException {</span>
<span class="line-modified">!         JarUtils.createJarFile(Path.of(jar), m, Path.of(&quot;.&quot;),</span>
<span class="line-modified">!                 Arrays.stream(files).map(Path::of).toArray(Path[]::new));</span>
<span class="line-modified">!         return SignItem.build()</span>
<span class="line-added">+                 .signedJar(jar.replaceAll(&quot;[.]jar$&quot;, &quot;&quot;))</span>
<span class="line-added">+             .addContentFiles(Arrays.stream(files).collect(Collectors.toList()));</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     private static String createDummyFile(String name) throws IOException {</span>
<span class="line-added">+         if (name.contains(&quot;/&quot;)) new File(name).getParentFile().mkdir();</span>
<span class="line-added">+         try (OutputStream fos = new FileOutputStream(name)) {</span>
<span class="line-added">+             fos.write(name.getBytes(UTF_8));</span>
<span class="line-added">+         }</span>
<span class="line-added">+         return name;</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     // Creates one or more jar files to test</span>
<span class="line-added">+     private static List&lt;SignItem&gt; createJars() throws IOException {</span>
<span class="line-added">+         List&lt;SignItem&gt; jarList = new ArrayList&lt;&gt;();</span>
<span class="line-added">+ </span>
<span class="line-added">+         Manifest m = new Manifest();</span>
<span class="line-added">+         m.getMainAttributes().put(Name.MANIFEST_VERSION, &quot;1.0&quot;);</span>
<span class="line-added">+ </span>
<span class="line-added">+         // creates a jar file that contains a dummy file</span>
<span class="line-added">+         jarList.add(createJarFile(&quot;test.jar&quot;, m, createDummyFile(&quot;dummy&quot;)));</span>
<span class="line-added">+ </span>
<span class="line-added">+         if (TEST_COMPREHENSIVE_JAR_CONTENTS) {</span>
<span class="line-added">+ </span>
<span class="line-added">+             // empty jar file so that jarsigner will add a default manifest</span>
<span class="line-added">+             jarList.add(createJarFile(&quot;empty.jar&quot;, m));</span>
<span class="line-added">+ </span>
<span class="line-added">+             // jar file that contains only an empty manifest with empty main</span>
<span class="line-added">+             // attributes (due to missing &quot;Manifest-Version&quot; header)</span>
<span class="line-added">+             JarUtils.createJar(&quot;nomainatts.jar&quot;);</span>
<span class="line-added">+             jarList.add(SignItem.build().signedJar(&quot;nomainatts&quot;));</span>
<span class="line-added">+ </span>
<span class="line-added">+             // creates a jar file that contains several files.</span>
<span class="line-added">+             jarList.add(createJarFile(&quot;files.jar&quot;, m,</span>
<span class="line-added">+                     IntStream.range(1, 9).boxed().map(i -&gt; {</span>
<span class="line-added">+                         try {</span>
<span class="line-added">+                             return createDummyFile(&quot;dummy&quot; + i);</span>
<span class="line-added">+                         } catch (IOException e) {</span>
<span class="line-added">+                             throw new RuntimeException(e);</span>
<span class="line-added">+                         }</span>
<span class="line-added">+                     }).toArray(String[]::new)</span>
<span class="line-added">+             ));</span>
<span class="line-added">+ </span>
<span class="line-added">+             // forces a line break by exceeding the line width limit of 72 bytes</span>
<span class="line-added">+             // in the filename and hence manifest entry name</span>
<span class="line-added">+             jarList.add(createJarFile(&quot;longfilename.jar&quot;, m,</span>
<span class="line-added">+                     createDummyFile(&quot;test&quot;.repeat(20))));</span>
<span class="line-added">+ </span>
<span class="line-added">+             // another interesting case is with different digest algorithms</span>
<span class="line-added">+             // resulting in digests broken across line breaks onto continuation</span>
<span class="line-added">+             // lines. these however are set with the &#39;digestAlgs&#39; option or</span>
<span class="line-added">+             // include all digest algorithms by default, see SignTwice.java.</span>
<span class="line-added">+         }</span>
<span class="line-added">+ </span>
<span class="line-added">+         return jarList;</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     // updates a signed jar file by adding another file</span>
<span class="line-added">+     private static List&lt;SignItem&gt; updateJar(SignItem prev) throws IOException {</span>
<span class="line-added">+         List&lt;SignItem&gt; jarList = new ArrayList&lt;&gt;();</span>
<span class="line-added">+ </span>
<span class="line-added">+         // sign unmodified jar again</span>
<span class="line-added">+         Files.copy(Path.of(prev.signedJar + &quot;.jar&quot;),</span>
<span class="line-added">+                 Path.of(prev.signedJar + &quot;-signagainunmodified.jar&quot;));</span>
<span class="line-added">+         jarList.add(SignItem.build(prev)</span>
<span class="line-added">+                 .signedJar(prev.signedJar + &quot;-signagainunmodified&quot;));</span>
<span class="line-added">+ </span>
<span class="line-added">+         String oldJar = prev.signedJar;</span>
<span class="line-added">+         String newJar = oldJar + &quot;-addfile&quot;;</span>
<span class="line-added">+         String triggerUpdateFile = &quot;addfile&quot;;</span>
<span class="line-added">+         JarUtils.updateJar(oldJar + &quot;.jar&quot;, newJar + &quot;.jar&quot;, triggerUpdateFile);</span>
<span class="line-added">+         jarList.add(SignItem.build(prev).signedJar(newJar)</span>
<span class="line-added">+                 .addContentFiles(Arrays.asList(triggerUpdateFile)));</span>
<span class="line-added">+ </span>
<span class="line-added">+         return jarList;</span>
      }
  
      // Creates a key store that includes a set of valid/expired certificates
      // with various algorithms.
      private static List&lt;CertInfo&gt; createCertificates(List&lt;JdkInfo&gt; jdkInfoList)
              throws Throwable {
<span class="line-modified">!         List&lt;CertInfo&gt; certList = new ArrayList&lt;&gt;();</span>
<span class="line-modified">!         Set&lt;String&gt; expiredCertFilter = new HashSet&lt;&gt;();</span>
<span class="line-modified">! </span>
<span class="line-modified">!         for (JdkInfo jdkInfo : jdkInfoList) {</span>
<span class="line-modified">!             for (String keyAlgorithm : keyAlgs()) {</span>
<span class="line-modified">!                 if (!jdkInfo.supportsKeyAlg(keyAlgorithm)) continue;</span>
<span class="line-modified">!                 for (int keySize : keySizes(keyAlgorithm)) {</span>
<span class="line-added">+                     for (String digestAlgorithm : digestAlgs()) {</span>
                          for(boolean expired : EXPIRED) {
                              // It creates only one expired certificate for one
                              // key algorithm.
                              if (expired
                                      &amp;&amp; !expiredCertFilter.add(keyAlgorithm)) {
                                  continue;
                              }
  
                              CertInfo certInfo = new CertInfo(
<span class="line-modified">!                                     jdkInfo,</span>
                                      keyAlgorithm,
                                      digestAlgorithm,
                                      keySize,
                                      expired);
<span class="line-modified">!                             // If the signature algorithm is not supported by the</span>
<span class="line-modified">!                             // JDK, it cannot try to sign jar with this algorithm.</span>
<span class="line-modified">!                             String sigalg = certInfo.sigalg();</span>
<span class="line-modified">!                             if (sigalg != null &amp;&amp;</span>
<span class="line-modified">!                                     !jdkInfo.isSupportedSigalg(sigalg)) {</span>
<span class="line-modified">!                                 continue;</span>
                              }
<span class="line-added">+                             createCertificate(jdkInfo, certInfo);</span>
<span class="line-added">+                             certList.add(certInfo);</span>
                          }
                      }
                  }
              }
          }
  
<span class="line-added">+         System.out.println(&quot;the keystore contents:&quot;);</span>
<span class="line-added">+         for (JdkInfo jdkInfo : jdkInfoList) {</span>
<span class="line-added">+             execTool(jdkInfo.jdkPath + &quot;/bin/keytool&quot;, new String[] {</span>
<span class="line-added">+                     &quot;-v&quot;,</span>
<span class="line-added">+                     &quot;-storetype&quot;,</span>
<span class="line-added">+                     &quot;jks&quot;,</span>
<span class="line-added">+                     &quot;-storepass&quot;,</span>
<span class="line-added">+                     PASSWORD,</span>
<span class="line-added">+                     &quot;-keystore&quot;,</span>
<span class="line-added">+                     KEYSTORE,</span>
<span class="line-added">+                     &quot;-list&quot;</span>
<span class="line-added">+             });</span>
<span class="line-added">+         }</span>
<span class="line-added">+ </span>
          return certList;
      }
  
      // Creates/Updates a key store that adds a certificate with specific algorithm.
<span class="line-modified">!     private static void createCertificate(JdkInfo jdkInfo, CertInfo certInfo)</span>
              throws Throwable {
<span class="line-modified">!         List&lt;String&gt; arguments = new ArrayList&lt;&gt;();</span>
          arguments.add(&quot;-J-Djava.security.properties=&quot; + JAVA_SECURITY);
          arguments.add(&quot;-v&quot;);
<span class="line-added">+         arguments.add(&quot;-debug&quot;);</span>
          arguments.add(&quot;-storetype&quot;);
          arguments.add(&quot;jks&quot;);
<span class="line-modified">!         arguments.add(&quot;-keystore&quot;);</span>
<span class="line-added">+         arguments.add(KEYSTORE);</span>
<span class="line-added">+         arguments.add(&quot;-storepass&quot;);</span>
<span class="line-added">+         arguments.add(PASSWORD);</span>
<span class="line-added">+         arguments.add(jdkInfo.majorVersion &lt; 6 ? &quot;-genkey&quot; : &quot;-genkeypair&quot;);</span>
          arguments.add(&quot;-keyalg&quot;);
          arguments.add(certInfo.keyAlgorithm);
<span class="line-modified">!         String sigalg = certInfo.sigalg();</span>
          if (sigalg != null) {
              arguments.add(&quot;-sigalg&quot;);
              arguments.add(sigalg);
          }
          if (certInfo.keySize != 0) {
              arguments.add(&quot;-keysize&quot;);
              arguments.add(certInfo.keySize + &quot;&quot;);
          }
          arguments.add(&quot;-dname&quot;);
<span class="line-modified">!         arguments.add(&quot;CN=&quot; + certInfo);</span>
          arguments.add(&quot;-alias&quot;);
<span class="line-modified">!         arguments.add(certInfo.alias());</span>
          arguments.add(&quot;-keypass&quot;);
          arguments.add(PASSWORD);
  
          arguments.add(&quot;-startdate&quot;);
          arguments.add(startDate(certInfo.expired));
          arguments.add(&quot;-validity&quot;);
<span class="line-added">+ //        arguments.add(DELAY_VERIFY ? &quot;1&quot; : &quot;222&quot;); // &gt; six months no warn</span>
          arguments.add(&quot;1&quot;);
  
          OutputAnalyzer outputAnalyzer = execTool(
<span class="line-modified">!                 jdkInfo.jdkPath + &quot;/bin/keytool&quot;,</span>
                  arguments.toArray(new String[arguments.size()]));
<span class="line-modified">!         if (outputAnalyzer.getExitValue() != 0</span>
<span class="line-modified">!                 || outputAnalyzer.getOutput().matches(&quot;[Ee]xception&quot;)</span>
<span class="line-modified">!                 || outputAnalyzer.getOutput().matches(Test.ERROR + &quot; ?&quot;)) {</span>
<span class="line-modified">!             System.out.println(outputAnalyzer.getOutput());</span>
<span class="line-modified">!             throw new Exception(&quot;error generating a key pair: &quot; + arguments);</span>
          }
      }
  
      // The validity period of a certificate always be 1 day. For creating an
      // expired certificate, the start date is the time before 1 day, then the
      // certificate expires immediately. And for creating a valid certificate,
      // the start date is the time before (1 day - CERT_VALIDITY minutes), then
      // the certificate will expires in CERT_VALIDITY minutes.
      private static String startDate(boolean expiredCert) {
          CALENDAR.setTime(new Date());
<span class="line-modified">!         if (DELAY_VERIFY || expiredCert) {</span>
<span class="line-modified">!             // corresponds to &#39;-validity 1&#39;</span>
<span class="line-added">+             CALENDAR.add(Calendar.DAY_OF_MONTH, -1);</span>
<span class="line-added">+         }</span>
<span class="line-added">+         if (DELAY_VERIFY &amp;&amp; !expiredCert) {</span>
              CALENDAR.add(Calendar.MINUTE, CERT_VALIDITY);
          }
          Date startDate = CALENDAR.getTime();
<span class="line-modified">!         if (!expiredCert) {</span>
<span class="line-added">+             lastCertStartTime = startDate.getTime();</span>
<span class="line-added">+         }</span>
          return DATE_FORMAT.format(startDate);
      }
  
<span class="line-modified">!     private static String outfile() {</span>
<span class="line-modified">!         return System.getProperty(&quot;o&quot;);</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     // Retrieves JDK info from the file which is specified by property</span>
<span class="line-added">+     // jdkListFile, or from property jdkList if jdkListFile is not available.</span>
      private static List&lt;JdkInfo&gt; jdkInfoList() throws Throwable {
          String[] jdkList = list(&quot;jdkList&quot;);
          if (jdkList.length == 0) {
<span class="line-modified">!             jdkList = new String[] { &quot;TEST_JDK&quot; };</span>
          }
  
<span class="line-modified">!         List&lt;JdkInfo&gt; jdkInfoList = new ArrayList&lt;&gt;();</span>
<span class="line-added">+         int index = 0;</span>
          for (String jdkPath : jdkList) {
<span class="line-modified">!             JdkInfo jdkInfo = &quot;TEST_JDK&quot;.equalsIgnoreCase(jdkPath) ?</span>
<span class="line-added">+                     TEST_JDK_INFO : new JdkInfo(jdkPath);</span>
              // The JDK version must be unique.
              if (!jdkInfoList.contains(jdkInfo)) {
<span class="line-added">+                 jdkInfo.index = index++;</span>
<span class="line-added">+                 jdkInfo.version = String.format(</span>
<span class="line-added">+                         &quot;%s(%d)&quot;, jdkInfo.version, jdkInfo.index);</span>
                  jdkInfoList.add(jdkInfo);
              } else {
                  System.out.println(&quot;The JDK version is duplicate: &quot; + jdkPath);
              }
          }
          return jdkInfoList;
      }
  
<span class="line-added">+     private static List&lt;String&gt; keyAlgs() throws IOException {</span>
<span class="line-added">+         if (KEY_ALGORITHMS == null) KEY_ALGORITHMS = list(&quot;keyAlgs&quot;);</span>
<span class="line-added">+         if (KEY_ALGORITHMS.length == 0)</span>
<span class="line-added">+             return Arrays.asList(DEFAULT_KEY_ALGORITHMS);</span>
<span class="line-added">+         return Arrays.stream(KEY_ALGORITHMS).map(a -&gt; a.split(&quot;;&quot;)[0])</span>
<span class="line-added">+                 .collect(Collectors.toList());</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     // Return key sizes according to the specified key algorithm.</span>
<span class="line-added">+     private static int[] keySizes(String keyAlgorithm) throws IOException {</span>
<span class="line-added">+         if (KEY_ALGORITHMS == null) KEY_ALGORITHMS = list(&quot;keyAlgs&quot;);</span>
<span class="line-added">+         for (String keyAlg : KEY_ALGORITHMS) {</span>
<span class="line-added">+             String[] split = (keyAlg + &quot; &quot;).split(&quot;;&quot;);</span>
<span class="line-added">+             if (keyAlgorithm.equals(split[0].trim()) &amp;&amp; split.length &gt; 1) {</span>
<span class="line-added">+                 int sizes[] = new int[split.length - 1];</span>
<span class="line-added">+                 for (int i = 1; i &lt;= sizes.length; i++)</span>
<span class="line-added">+                     sizes[i - 1] = split[i].isBlank() ? 0 : // default</span>
<span class="line-added">+                         Integer.parseInt(split[i].trim());</span>
<span class="line-added">+                 return sizes;</span>
<span class="line-added">+             }</span>
<span class="line-added">+         }</span>
<span class="line-added">+ </span>
<span class="line-added">+         // defaults</span>
<span class="line-added">+         if (RSA.equals(keyAlgorithm) || DSA.equals(keyAlgorithm)) {</span>
<span class="line-added">+             return new int[] { 1024, 2048, 0 }; // 0 is no keysize specified</span>
<span class="line-added">+         } else if (EC.equals(keyAlgorithm)) {</span>
<span class="line-added">+             return new int[] { 384, 571, 0 }; // 0 is no keysize specified</span>
<span class="line-added">+         } else {</span>
<span class="line-added">+             throw new RuntimeException(&quot;problem determining key sizes&quot;);</span>
<span class="line-added">+         }</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     private static List&lt;String&gt; digestAlgs() throws IOException {</span>
<span class="line-added">+         if (DIGEST_ALGORITHMS == null) DIGEST_ALGORITHMS = list(&quot;digestAlgs&quot;);</span>
<span class="line-added">+         if (DIGEST_ALGORITHMS.length == 0)</span>
<span class="line-added">+             return Arrays.asList(DEFAULT_DIGEST_ALGORITHMS);</span>
<span class="line-added">+         return Arrays.asList(DIGEST_ALGORITHMS);</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
      // Retrieves TSA info from the file which is specified by property tsaListFile,
      // or from property tsaList if tsaListFile is not available.
      private static List&lt;TsaInfo&gt; tsaInfoList() throws IOException {
          String[] tsaList = list(&quot;tsaList&quot;);
  
<span class="line-modified">!         List&lt;TsaInfo&gt; tsaInfoList = new ArrayList&lt;&gt;();</span>
          for (int i = 0; i &lt; tsaList.length; i++) {
              String[] values = tsaList[i].split(&quot;;digests=&quot;);
  
              String[] digests = new String[0];
              if (values.length == 2) {
                  digests = values[1].split(&quot;,&quot;);
              }
  
<span class="line-modified">!             String tsaUrl = values[0];</span>
<span class="line-modified">!             if (tsaUrl.isEmpty() || tsaUrl.equalsIgnoreCase(&quot;notsa&quot;)) {</span>
<span class="line-added">+                 tsaUrl = null;</span>
<span class="line-added">+             }</span>
<span class="line-added">+             TsaInfo bufTsa = new TsaInfo(i, tsaUrl);</span>
              for (String digest : digests) {
<span class="line-modified">!                 bufTsa.addDigest(digest.toUpperCase());</span>
              }
              tsaInfoList.add(bufTsa);
          }
  
<span class="line-added">+         if (tsaInfoList.size() == 0) {</span>
<span class="line-added">+             throw new RuntimeException(&quot;TSA service is mandatory unless &quot;</span>
<span class="line-added">+                     + &quot;&#39;notsa&#39; specified explicitly.&quot;);</span>
<span class="line-added">+         }</span>
          return tsaInfoList;
      }
  
<span class="line-modified">!     private static String[] list(String listProp) throws IOException {</span>
          String listFileProp = listProp + &quot;File&quot;;
          String listFile = System.getProperty(listFileProp);
          if (!isEmpty(listFile)) {
              System.out.println(listFileProp + &quot;=&quot; + listFile);
<span class="line-modified">!             List&lt;String&gt; list = new ArrayList&lt;&gt;();</span>
              BufferedReader reader = new BufferedReader(
                      new FileReader(listFile));
              String line;
              while ((line = reader.readLine()) != null) {
                  String item = line.trim();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 367,30 ***</span>
  
      // A JDK (signer) signs a jar with a variety of algorithms, and then all of
      // JDKs (verifiers), including the signer itself, try to verify the signed
      // jars respectively.
      private static List&lt;SignItem&gt; test(List&lt;JdkInfo&gt; jdkInfoList,
<span class="line-modified">!             List&lt;TsaInfo&gt; tsaInfoList, List&lt;CertInfo&gt; certList)</span>
<span class="line-modified">!             throws Throwable {</span>
          detailsOutput.transferPhase();
<span class="line-modified">!         List&lt;SignItem&gt; signItems = signing(jdkInfoList, tsaInfoList, certList);</span>
  
          detailsOutput.transferPhase();
          for (SignItem signItem : signItems) {
              for (JdkInfo verifierInfo : jdkInfoList) {
<span class="line-modified">!                 // JDK 6 doesn&#39;t support EC</span>
<span class="line-modified">!                 if (!verifierInfo.isJdk6()</span>
<span class="line-modified">!                         || signItem.certInfo.keyAlgorithm != EC) {</span>
<span class="line-modified">!                     verifying(signItem, VerifyItem.build(verifierInfo));</span>
<span class="line-modified">!                 }</span>
              }
          }
  
          if (DELAY_VERIFY) {
              detailsOutput.transferPhase();
              System.out.print(&quot;Waiting for delay verifying&quot;);
<span class="line-removed">-             long lastCertExpirationTime = lastCertStartTime + 24 * 60 * 60 * 1000;</span>
              while (System.currentTimeMillis() &lt; lastCertExpirationTime) {
                  TimeUnit.SECONDS.sleep(30);
                  System.out.print(&quot;.&quot;);
              }
              System.out.println();
<span class="line-new-header">--- 534,51 ---</span>
  
      // A JDK (signer) signs a jar with a variety of algorithms, and then all of
      // JDKs (verifiers), including the signer itself, try to verify the signed
      // jars respectively.
      private static List&lt;SignItem&gt; test(List&lt;JdkInfo&gt; jdkInfoList,
<span class="line-modified">!             List&lt;TsaInfo&gt; tsaInfoList, List&lt;CertInfo&gt; certList,</span>
<span class="line-modified">!             List&lt;SignItem&gt; jars) throws Throwable {</span>
          detailsOutput.transferPhase();
<span class="line-modified">!         List&lt;SignItem&gt; signItems = new ArrayList&lt;&gt;();</span>
<span class="line-added">+         signItems.addAll(signing(jdkInfoList, tsaInfoList, certList, jars));</span>
<span class="line-added">+         if (TEST_JAR_UPDATE) {</span>
<span class="line-added">+             signItems.addAll(signing(jdkInfoList, tsaInfoList, certList,</span>
<span class="line-added">+                     updating(signItems.stream().filter(</span>
<span class="line-added">+                             x -&gt; x.status != Status.ERROR)</span>
<span class="line-added">+                     .collect(Collectors.toList()))));</span>
<span class="line-added">+         }</span>
  
          detailsOutput.transferPhase();
          for (SignItem signItem : signItems) {
              for (JdkInfo verifierInfo : jdkInfoList) {
<span class="line-modified">!                 if (!verifierInfo.supportsKeyAlg(</span>
<span class="line-modified">!                         signItem.certInfo.keyAlgorithm)) continue;</span>
<span class="line-modified">!                 VerifyItem verifyItem = VerifyItem.build(verifierInfo);</span>
<span class="line-modified">!                 verifyItem.addSignerCertInfos(signItem);</span>
<span class="line-modified">!                 signItem.addVerifyItem(verifyItem);</span>
<span class="line-added">+                 verifying(signItem, verifyItem);</span>
              }
          }
  
<span class="line-added">+         // if lastCertExpirationTime passed already now, probably some</span>
<span class="line-added">+         // certificate was already expired during jar signature verification</span>
<span class="line-added">+         // (jarsigner -verify) and the test should probably be repeated with an</span>
<span class="line-added">+         // increased validity period -DcertValidity CERT_VALIDITY</span>
<span class="line-added">+         long lastCertExpirationTime = lastCertStartTime + 24 * 60 * 60 * 1000;</span>
<span class="line-added">+         if (lastCertExpirationTime &lt; System.currentTimeMillis()) {</span>
<span class="line-added">+             throw new AssertionError(&quot;CERT_VALIDITY (&quot; + CERT_VALIDITY</span>
<span class="line-added">+                     + &quot; [minutes]) was too short. &quot;</span>
<span class="line-added">+                     + &quot;Creating and signing the jars took longer, &quot;</span>
<span class="line-added">+                     + &quot;presumably at least &quot;</span>
<span class="line-added">+                     + ((lastCertExpirationTime - System.currentTimeMillis())</span>
<span class="line-added">+                             / 60 * 1000 + CERT_VALIDITY) + &quot; [minutes].&quot;);</span>
<span class="line-added">+         }</span>
<span class="line-added">+ </span>
          if (DELAY_VERIFY) {
              detailsOutput.transferPhase();
              System.out.print(&quot;Waiting for delay verifying&quot;);
              while (System.currentTimeMillis() &lt; lastCertExpirationTime) {
                  TimeUnit.SECONDS.sleep(30);
                  System.out.print(&quot;.&quot;);
              }
              System.out.println();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 402,239 ***</span>
                  }
              }
          }
  
          detailsOutput.transferPhase();
<span class="line-removed">- </span>
          return signItems;
      }
  
      private static List&lt;SignItem&gt; signing(List&lt;JdkInfo&gt; jdkInfos,
<span class="line-modified">!             List&lt;TsaInfo&gt; tsaList, List&lt;CertInfo&gt; certList) throws Throwable {</span>
<span class="line-modified">!         List&lt;SignItem&gt; signItems = new ArrayList&lt;SignItem&gt;();</span>
<span class="line-modified">! </span>
<span class="line-modified">!         Set&lt;String&gt; signFilter = new HashSet&lt;String&gt;();</span>
<span class="line-modified">! </span>
<span class="line-modified">!         for (JdkInfo signerInfo : jdkInfos) {</span>
<span class="line-modified">!             for (String keyAlgorithm : KEY_ALGORITHMS) {</span>
<span class="line-modified">!                 // JDK 6 doesn&#39;t support EC</span>
<span class="line-modified">!                 if (signerInfo.isJdk6() &amp;&amp; keyAlgorithm == EC) {</span>
<span class="line-modified">!                     continue;</span>
                  }
  
<span class="line-modified">!                 for (String digestAlgorithm : DIGEST_ALGORITHMS) {</span>
<span class="line-modified">!                     String sigalg = sigalg(digestAlgorithm, keyAlgorithm);</span>
<span class="line-removed">-                     // If the signature algorithm is not supported by the JDK,</span>
<span class="line-removed">-                     // it cannot try to sign jar with this algorithm.</span>
<span class="line-removed">-                     if (sigalg != null &amp;&amp; !signerInfo.isSupportedSigalg(sigalg)) {</span>
<span class="line-removed">-                         continue;</span>
<span class="line-removed">-                     }</span>
  
                      // If the JDK doesn&#39;t support option -tsadigestalg, the
<span class="line-modified">!                     // associated cases just be ignored.</span>
<span class="line-modified">!                     if (digestAlgorithm != DEFAULT</span>
<span class="line-modified">!                             &amp;&amp; !signerInfo.supportsTsadigestalg) {</span>
<span class="line-removed">-                         continue;</span>
                      }
  
<span class="line-modified">!                     for (int keySize : keySizes(keyAlgorithm)) {</span>
<span class="line-modified">!                         for (boolean expired : EXPIRED) {</span>
<span class="line-modified">!                             CertInfo certInfo = new CertInfo(</span>
<span class="line-modified">!                                     signerInfo.version,</span>
<span class="line-modified">!                                     keyAlgorithm,</span>
<span class="line-modified">!                                     digestAlgorithm,</span>
<span class="line-modified">!                                     keySize,</span>
<span class="line-removed">-                                     expired);</span>
<span class="line-removed">-                             if (!certList.contains(certInfo)) {</span>
<span class="line-removed">-                                 continue;</span>
<span class="line-removed">-                             }</span>
<span class="line-removed">- </span>
<span class="line-removed">-                             String tsadigestalg = digestAlgorithm != DEFAULT</span>
<span class="line-removed">-                                                 ? digestAlgorithm</span>
<span class="line-removed">-                                                 : null;</span>
<span class="line-removed">- </span>
<span class="line-removed">-                             for (TsaInfo tsaInfo : tsaList) {</span>
<span class="line-removed">-                                 // It has to ignore the digest algorithm, which</span>
<span class="line-removed">-                                 // is not supported by the TSA server.</span>
<span class="line-removed">-                                 if(!tsaInfo.isDigestSupported(tsadigestalg)) {</span>
<span class="line-removed">-                                     continue;</span>
<span class="line-removed">-                                 }</span>
<span class="line-removed">- </span>
<span class="line-removed">-                                 String tsaUrl = tsaInfo.tsaUrl;</span>
<span class="line-removed">-                                 if (TsaFilter.filter(</span>
<span class="line-removed">-                                         signerInfo.version,</span>
<span class="line-removed">-                                         digestAlgorithm,</span>
<span class="line-removed">-                                         expired,</span>
<span class="line-removed">-                                         tsaInfo.index)) {</span>
<span class="line-removed">-                                     tsaUrl = null;</span>
<span class="line-removed">-                                 }</span>
  
<span class="line-modified">!                                 String signedJar = &quot;JDK_&quot;</span>
<span class="line-modified">!                                         + signerInfo.version + &quot;-CERT_&quot;</span>
<span class="line-removed">-                                         + certInfo</span>
<span class="line-removed">-                                         + (tsaUrl == null</span>
<span class="line-removed">-                                            ? &quot;&quot;</span>
<span class="line-removed">-                                            : &quot;-TSA_&quot; + tsaInfo.index);</span>
  
<span class="line-modified">!                                 // It has to ignore the same jar signing.</span>
<span class="line-modified">!                                 if (!signFilter.add(signedJar)) {</span>
<span class="line-modified">!                                     continue;</span>
<span class="line-modified">!                                 }</span>
  
<span class="line-modified">!                                 SignItem signItem = SignItem.build()</span>
<span class="line-modified">!                                         .certInfo(certInfo)</span>
<span class="line-modified">!                                         .version(signerInfo.version)</span>
<span class="line-modified">!                                         .signatureAlgorithm(sigalg)</span>
<span class="line-modified">!                                         .tsaDigestAlgorithm(</span>
<span class="line-modified">!                                                 tsaUrl == null</span>
<span class="line-modified">!                                                 ? null</span>
<span class="line-modified">!                                                 : tsadigestalg)</span>
<span class="line-modified">!                                         .tsaIndex(</span>
<span class="line-modified">!                                                 tsaUrl == null</span>
<span class="line-modified">!                                                 ? -1</span>
<span class="line-modified">!                                                 : tsaInfo.index)</span>
<span class="line-removed">-                                         .signedJar(signedJar);</span>
<span class="line-removed">-                                 String signingId = signingId(signItem);</span>
<span class="line-removed">-                                 detailsOutput.writeAnchorName(signingId,</span>
<span class="line-removed">-                                         &quot;Signing: &quot; + signingId);</span>
<span class="line-removed">- </span>
<span class="line-removed">-                                 OutputAnalyzer signOA = signJar(</span>
<span class="line-removed">-                                         signerInfo.jarsignerPath,</span>
<span class="line-removed">-                                         sigalg,</span>
<span class="line-removed">-                                         tsadigestalg,</span>
<span class="line-removed">-                                         tsaUrl,</span>
<span class="line-removed">-                                         certInfo.alias(),</span>
<span class="line-removed">-                                         signedJar);</span>
<span class="line-removed">-                                 Status signingStatus = signingStatus(signOA);</span>
<span class="line-removed">-                                 signItem.status(signingStatus);</span>
<span class="line-removed">- </span>
<span class="line-removed">-                                 if (signingStatus != Status.ERROR) {</span>
<span class="line-removed">-                                     // Using the testing JDK, which is specified</span>
<span class="line-removed">-                                     // by jtreg option &quot;-jdk&quot;, to verify the</span>
<span class="line-removed">-                                     // signed jar and extract the signature</span>
<span class="line-removed">-                                     // algorithm and timestamp digest algorithm.</span>
<span class="line-removed">-                                     String output = verifyJar(TEST_JARSIGNER,</span>
<span class="line-removed">-                                             signedJar).getOutput();</span>
<span class="line-removed">-                                     signItem.extractedSignatureAlgorithm(</span>
<span class="line-removed">-                                             extract(output,</span>
<span class="line-removed">-                                                     &quot; *Signature algorithm.*&quot;,</span>
<span class="line-removed">-                                                     &quot;.*: |,.*&quot;));</span>
<span class="line-removed">-                                     signItem.extractedTsaDigestAlgorithm(</span>
<span class="line-removed">-                                             extract(output,</span>
<span class="line-removed">-                                                     &quot; *Timestamp digest algorithm.*&quot;,</span>
<span class="line-removed">-                                                     &quot;.*: &quot;));</span>
                                  }
<span class="line-removed">- </span>
<span class="line-removed">-                                 signItems.add(signItem);</span>
                              }
                          }
                      }
                  }
              }
          }
  
          return signItems;
      }
  
      private static void verifying(SignItem signItem, VerifyItem verifyItem)
              throws Throwable {
<span class="line-modified">!         boolean delayVerify = verifyItem.status == Status.NONE;</span>
<span class="line-modified">!         String verifyingId = verifyingId(signItem, verifyItem, !delayVerify);</span>
          detailsOutput.writeAnchorName(verifyingId, &quot;Verifying: &quot; + verifyingId);
<span class="line-removed">- </span>
          OutputAnalyzer verifyOA = verifyJar(verifyItem.jdkInfo.jarsignerPath,
<span class="line-modified">!                 signItem.signedJar);</span>
<span class="line-modified">!         Status verifyingStatus = verifyingStatus(verifyOA);</span>
<span class="line-modified">! </span>
<span class="line-modified">!         // It checks if the default timestamp digest algorithm is SHA-256.</span>
<span class="line-modified">!         if (verifyingStatus != Status.ERROR</span>
<span class="line-modified">!                 &amp;&amp; signItem.tsaDigestAlgorithm == null) {</span>
<span class="line-modified">!             verifyingStatus = signItem.extractedTsaDigestAlgorithm != null</span>
<span class="line-modified">!                                     &amp;&amp; !signItem.extractedTsaDigestAlgorithm.matches(&quot;SHA-?256&quot;)</span>
<span class="line-modified">!                             ? Status.ERROR</span>
<span class="line-modified">!                             : verifyingStatus;</span>
<span class="line-modified">!             if (verifyingStatus == Status.ERROR) {</span>
<span class="line-modified">!                 System.out.println(&quot;The default tsa digest is not SHA-256: &quot;</span>
<span class="line-modified">!                     + signItem.extractedTsaDigestAlgorithm);</span>
<span class="line-modified">!             }</span>
          }
  
<span class="line-modified">!         if (delayVerify) {</span>
<span class="line-modified">!             signItem.addVerifyItem(verifyItem.status(verifyingStatus));</span>
          } else {
              verifyItem.delayStatus(verifyingStatus);
          }
<span class="line-removed">-     }</span>
  
<span class="line-modified">!     // Return key sizes according to the specified key algorithm.</span>
<span class="line-modified">!     private static int[] keySizes(String keyAlgorithm) {</span>
<span class="line-removed">-         if (keyAlgorithm == RSA || keyAlgorithm == DSA) {</span>
<span class="line-removed">-             return new int[] { 1024, 2048, 0 };</span>
<span class="line-removed">-         } else if (keyAlgorithm == EC) {</span>
<span class="line-removed">-             return new int[] { 384, 571, 0 };</span>
          }
<span class="line-removed">- </span>
<span class="line-removed">-         return null;</span>
      }
  
      // Determines the status of signing.
<span class="line-modified">!     private static Status signingStatus(OutputAnalyzer outputAnalyzer) {</span>
<span class="line-modified">!         if (outputAnalyzer.getExitValue() == 0) {</span>
<span class="line-modified">!             if (outputAnalyzer.getOutput().contains(Test.WARNING)) {</span>
<span class="line-removed">-                 return Status.WARNING;</span>
<span class="line-removed">-             } else {</span>
<span class="line-removed">-                 return Status.NORMAL;</span>
<span class="line-removed">-             }</span>
<span class="line-removed">-         } else {</span>
              return Status.ERROR;
          }
      }
  
      // Determines the status of verifying.
<span class="line-modified">!     private static Status verifyingStatus(OutputAnalyzer outputAnalyzer) {</span>
<span class="line-modified">!         if (outputAnalyzer.getExitValue() == 0) {</span>
<span class="line-modified">!             String output = outputAnalyzer.getOutput();</span>
<span class="line-modified">!             if (!output.contains(Test.JAR_VERIFIED)) {</span>
<span class="line-modified">!                 return Status.ERROR;</span>
<span class="line-removed">-             } else if (output.contains(Test.WARNING)) {</span>
<span class="line-removed">-                 return Status.WARNING;</span>
<span class="line-removed">-             } else {</span>
<span class="line-removed">-                 return Status.NORMAL;</span>
<span class="line-removed">-             }</span>
          } else {
              return Status.ERROR;
          }
<span class="line-removed">-     }</span>
  
<span class="line-modified">!     // Extracts string from text by specified patterns.</span>
<span class="line-modified">!     private static String extract(String text, String linePattern,</span>
<span class="line-modified">!             String replacePattern) {</span>
<span class="line-modified">!         Matcher lineMatcher = Pattern.compile(linePattern).matcher(text);</span>
<span class="line-modified">!         if (lineMatcher.find()) {</span>
<span class="line-modified">!             String line = lineMatcher.group(0);</span>
<span class="line-modified">!             return line.replaceAll(replacePattern, &quot;&quot;);</span>
<span class="line-modified">!         } else {</span>
<span class="line-modified">!             return null;</span>
          }
      }
  
      // Using specified jarsigner to sign the pre-created jar with specified
      // algorithms.
      private static OutputAnalyzer signJar(String jarsignerPath, String sigalg,
<span class="line-modified">!             String tsadigestalg, String tsa, String alias, String signedJar)</span>
<span class="line-modified">!             throws Throwable {</span>
<span class="line-modified">!         List&lt;String&gt; arguments = new ArrayList&lt;String&gt;();</span>
  
          if (PROXY_HOST != null &amp;&amp; PROXY_PORT != null) {
              arguments.add(&quot;-J-Dhttp.proxyHost=&quot; + PROXY_HOST);
              arguments.add(&quot;-J-Dhttp.proxyPort=&quot; + PROXY_PORT);
              arguments.add(&quot;-J-Dhttps.proxyHost=&quot; + PROXY_HOST);
              arguments.add(&quot;-J-Dhttps.proxyPort=&quot; + PROXY_PORT);
          }
          arguments.add(&quot;-J-Djava.security.properties=&quot; + JAVA_SECURITY);
          arguments.add(&quot;-debug&quot;);
          arguments.add(&quot;-verbose&quot;);
          if (sigalg != null) {
              arguments.add(&quot;-sigalg&quot;);
              arguments.add(sigalg);
          }
          if (tsa != null) {
<span class="line-new-header">--- 590,283 ---</span>
                  }
              }
          }
  
          detailsOutput.transferPhase();
          return signItems;
      }
  
      private static List&lt;SignItem&gt; signing(List&lt;JdkInfo&gt; jdkInfos,
<span class="line-modified">!             List&lt;TsaInfo&gt; tsaList, List&lt;CertInfo&gt; certList,</span>
<span class="line-modified">!             List&lt;SignItem&gt; unsignedJars) throws Throwable {</span>
<span class="line-modified">!         List&lt;SignItem&gt; signItems = new ArrayList&lt;&gt;();</span>
<span class="line-modified">! </span>
<span class="line-modified">!         for (CertInfo certInfo : certList) {</span>
<span class="line-modified">!             JdkInfo signerInfo = certInfo.jdkInfo;</span>
<span class="line-modified">!             String keyAlgorithm = certInfo.keyAlgorithm;</span>
<span class="line-modified">!             String sigDigestAlgorithm = certInfo.digestAlgorithm;</span>
<span class="line-modified">!             int keySize = certInfo.keySize;</span>
<span class="line-modified">!             boolean expired = certInfo.expired;</span>
<span class="line-added">+ </span>
<span class="line-added">+             for (String jarDigestAlgorithm : digestAlgs()) {</span>
<span class="line-added">+                 if (DEFAULT.equals(jarDigestAlgorithm)) {</span>
<span class="line-added">+                     jarDigestAlgorithm = null;</span>
                  }
  
<span class="line-modified">!                 for (TsaInfo tsaInfo : tsaList) {</span>
<span class="line-modified">!                     String tsaUrl = tsaInfo.tsaUrl;</span>
  
<span class="line-added">+                     List&lt;String&gt; tsaDigestAlgs = digestAlgs();</span>
<span class="line-added">+                     // no point in specifying a tsa digest algorithm</span>
<span class="line-added">+                     // for no TSA, except maybe it would issue a warning.</span>
<span class="line-added">+                     if (tsaUrl == null) tsaDigestAlgs = Arrays.asList(DEFAULT);</span>
                      // If the JDK doesn&#39;t support option -tsadigestalg, the
<span class="line-modified">!                     // associated cases can just be ignored.</span>
<span class="line-modified">!                     if (!signerInfo.supportsTsadigestalg) {</span>
<span class="line-modified">!                         tsaDigestAlgs = Arrays.asList(DEFAULT);</span>
                      }
<span class="line-added">+                     for (String tsaDigestAlg : tsaDigestAlgs) {</span>
<span class="line-added">+                         if (DEFAULT.equals(tsaDigestAlg)) {</span>
<span class="line-added">+                             tsaDigestAlg = null;</span>
<span class="line-added">+                         } else if (!tsaInfo.isDigestSupported(tsaDigestAlg)) {</span>
<span class="line-added">+                             // It has to ignore the digest algorithm, which</span>
<span class="line-added">+                             // is not supported by the TSA server.</span>
<span class="line-added">+                             continue;</span>
<span class="line-added">+                         }</span>
  
<span class="line-modified">!                         if (tsaUrl != null &amp;&amp; TsaFilter.filter(</span>
<span class="line-modified">!                                 signerInfo.version,</span>
<span class="line-modified">!                                 tsaDigestAlg,</span>
<span class="line-modified">!                                 expired,</span>
<span class="line-modified">!                                 tsaInfo.index)) {</span>
<span class="line-modified">!                             continue;</span>
<span class="line-modified">!                         }</span>
  
<span class="line-modified">!                         for (SignItem prevSign : unsignedJars) {</span>
<span class="line-modified">!                             String unsignedJar = prevSign.signedJar;</span>
  
<span class="line-modified">!                             SignItem signItem = SignItem.build(prevSign)</span>
<span class="line-modified">!                                     .certInfo(certInfo)</span>
<span class="line-modified">!                                     .jdkInfo(signerInfo);</span>
<span class="line-modified">!                             String signedJar = unsignedJar + &quot;-&quot; + &quot;JDK_&quot; + (</span>
<span class="line-added">+                                     signerInfo.version + &quot;-CERT_&quot; + certInfo).</span>
<span class="line-added">+                                     replaceAll(&quot;[^a-z_0-9A-Z.]+&quot;, &quot;-&quot;);</span>
  
<span class="line-modified">!                             if (jarDigestAlgorithm != null) {</span>
<span class="line-modified">!                                 signedJar += &quot;-DIGESTALG_&quot; + jarDigestAlgorithm;</span>
<span class="line-modified">!                                 signItem.digestAlgorithm(jarDigestAlgorithm);</span>
<span class="line-modified">!                             }</span>
<span class="line-modified">!                             if (tsaUrl == null) {</span>
<span class="line-modified">!                                 signItem.tsaIndex(-1);</span>
<span class="line-modified">!                             } else {</span>
<span class="line-modified">!                                 signedJar += &quot;-TSA_&quot; + tsaInfo.index;</span>
<span class="line-modified">!                                 signItem.tsaIndex(tsaInfo.index);</span>
<span class="line-modified">!                                 if (tsaDigestAlg != null) {</span>
<span class="line-modified">!                                     signedJar += &quot;-TSADIGALG_&quot; + tsaDigestAlg;</span>
<span class="line-modified">!                                     signItem.tsaDigestAlgorithm(tsaDigestAlg);</span>
                                  }
                              }
<span class="line-added">+                             signItem.signedJar(signedJar);</span>
<span class="line-added">+ </span>
<span class="line-added">+                             String signingId = signingId(signItem);</span>
<span class="line-added">+                             detailsOutput.writeAnchorName(signingId,</span>
<span class="line-added">+                                     &quot;Signing: &quot; + signingId);</span>
<span class="line-added">+ </span>
<span class="line-added">+                             OutputAnalyzer signOA = signJar(</span>
<span class="line-added">+                                     signerInfo.jarsignerPath,</span>
<span class="line-added">+                                     certInfo.sigalg(),</span>
<span class="line-added">+                                     jarDigestAlgorithm,</span>
<span class="line-added">+                                     tsaDigestAlg,</span>
<span class="line-added">+                                     tsaUrl,</span>
<span class="line-added">+                                     certInfo.alias(),</span>
<span class="line-added">+                                     unsignedJar,</span>
<span class="line-added">+                                     signedJar);</span>
<span class="line-added">+                             Status signingStatus = signingStatus(signOA,</span>
<span class="line-added">+                                     tsaUrl != null);</span>
<span class="line-added">+                             signItem.status(signingStatus);</span>
<span class="line-added">+                             signItems.add(signItem);</span>
                          }
                      }
                  }
              }
          }
  
          return signItems;
      }
  
<span class="line-added">+     private static List&lt;SignItem&gt; updating(List&lt;SignItem&gt; prevSignItems)</span>
<span class="line-added">+             throws IOException {</span>
<span class="line-added">+         List&lt;SignItem&gt; updateItems = new ArrayList&lt;&gt;();</span>
<span class="line-added">+         for (SignItem prevSign : prevSignItems) {</span>
<span class="line-added">+             updateItems.addAll(updateJar(prevSign));</span>
<span class="line-added">+         }</span>
<span class="line-added">+         return updateItems;</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
      private static void verifying(SignItem signItem, VerifyItem verifyItem)
              throws Throwable {
<span class="line-modified">!         // TODO: how will be ensured that the first verification is not after valid period expired which is only one minute?</span>
<span class="line-modified">!         boolean delayVerify = verifyItem.status != Status.NONE;</span>
<span class="line-added">+         String verifyingId = verifyingId(signItem, verifyItem, delayVerify);</span>
          detailsOutput.writeAnchorName(verifyingId, &quot;Verifying: &quot; + verifyingId);
          OutputAnalyzer verifyOA = verifyJar(verifyItem.jdkInfo.jarsignerPath,
<span class="line-modified">!                 signItem.signedJar, verifyItem.certInfo == null ? null :</span>
<span class="line-modified">!                 verifyItem.certInfo.alias());</span>
<span class="line-modified">!         Status verifyingStatus = verifyingStatus(signItem, verifyItem, verifyOA);</span>
<span class="line-modified">! </span>
<span class="line-modified">!         try {</span>
<span class="line-modified">!             String match = &quot;^  (&quot;</span>
<span class="line-modified">!                     + &quot;  Signature algorithm: &quot; + signItem.certInfo.</span>
<span class="line-modified">!                             expectedSigalg() + &quot;, &quot; + signItem.certInfo.</span>
<span class="line-modified">!                             expectedKeySize() + &quot;-bit key&quot;</span>
<span class="line-modified">!                     + &quot;)|(&quot;</span>
<span class="line-modified">!                     + &quot;  Digest algorithm: &quot; + signItem.expectedDigestAlg()</span>
<span class="line-modified">!                     + (signItem.tsaIndex &lt; 0 ? &quot;&quot; :</span>
<span class="line-modified">!                       &quot;)|(&quot;</span>
<span class="line-modified">!                     + &quot;Timestamped by \&quot;.+\&quot; on .*&quot;</span>
<span class="line-added">+                     + &quot;)|(&quot;</span>
<span class="line-added">+                     + &quot;  Timestamp digest algorithm: &quot;</span>
<span class="line-added">+                             + signItem.expectedTsaDigestAlg()</span>
<span class="line-added">+                     + &quot;)|(&quot;</span>
<span class="line-added">+                     + &quot;  Timestamp signature algorithm: .*&quot;</span>
<span class="line-added">+                       )</span>
<span class="line-added">+                     + &quot;)$&quot;;</span>
<span class="line-added">+             verifyOA.stdoutShouldMatchByLine(</span>
<span class="line-added">+                     &quot;^- Signed by \&quot;CN=&quot; +  signItem.certInfo.toString()</span>
<span class="line-added">+                             .replaceAll(&quot;[.]&quot;, &quot;[.]&quot;) + &quot;\&quot;$&quot;,</span>
<span class="line-added">+                     &quot;^(- Signed by \&quot;CN=.+\&quot;)?$&quot;,</span>
<span class="line-added">+                     match);</span>
<span class="line-added">+         } catch (Throwable e) {</span>
<span class="line-added">+             e.printStackTrace();</span>
<span class="line-added">+             verifyingStatus = Status.ERROR;</span>
          }
  
<span class="line-modified">!         if (!delayVerify) {</span>
<span class="line-modified">!             verifyItem.status(verifyingStatus);</span>
          } else {
              verifyItem.delayStatus(verifyingStatus);
          }
  
<span class="line-modified">!         if (verifyItem.prevVerify != null) {</span>
<span class="line-modified">!             verifying(signItem, verifyItem.prevVerify);</span>
          }
      }
  
      // Determines the status of signing.
<span class="line-modified">!     private static Status signingStatus(OutputAnalyzer outputAnalyzer,</span>
<span class="line-modified">!             boolean tsa) {</span>
<span class="line-modified">!         if (outputAnalyzer.getExitValue() != 0) {</span>
              return Status.ERROR;
          }
<span class="line-added">+         if (!outputAnalyzer.getOutput().contains(Test.JAR_SIGNED)) {</span>
<span class="line-added">+             return Status.ERROR;</span>
<span class="line-added">+         }</span>
<span class="line-added">+ </span>
<span class="line-added">+         boolean warning = false;</span>
<span class="line-added">+         for (String line : outputAnalyzer.getOutput().lines()</span>
<span class="line-added">+                 .toArray(String[]::new)) {</span>
<span class="line-added">+             if (line.matches(Test.ERROR + &quot; ?&quot;)) return Status.ERROR;</span>
<span class="line-added">+             if (line.matches(Test.WARNING + &quot; ?&quot;)) warning = true;</span>
<span class="line-added">+         }</span>
<span class="line-added">+         return warning ? Status.WARNING : Status.NORMAL;</span>
      }
  
      // Determines the status of verifying.
<span class="line-modified">!     private static Status verifyingStatus(SignItem signItem, VerifyItem</span>
<span class="line-modified">!             verifyItem, OutputAnalyzer outputAnalyzer) {</span>
<span class="line-modified">!         List&lt;String&gt; expectedSignedContent = new ArrayList&lt;&gt;();</span>
<span class="line-modified">!         if (verifyItem.certInfo == null) {</span>
<span class="line-modified">!             expectedSignedContent.addAll(signItem.jarContents);</span>
          } else {
<span class="line-added">+             SignItem i = signItem;</span>
<span class="line-added">+             while (i != null) {</span>
<span class="line-added">+                 if (i.certInfo != null &amp;&amp; i.certInfo.equals(verifyItem.certInfo)) {</span>
<span class="line-added">+                     expectedSignedContent.addAll(i.jarContents);</span>
<span class="line-added">+                 }</span>
<span class="line-added">+                 i = i.prevSign;</span>
<span class="line-added">+             }</span>
<span class="line-added">+         }</span>
<span class="line-added">+         List&lt;String&gt; expectedUnsignedContent =</span>
<span class="line-added">+                 new ArrayList&lt;&gt;(signItem.jarContents);</span>
<span class="line-added">+         expectedUnsignedContent.removeAll(expectedSignedContent);</span>
<span class="line-added">+ </span>
<span class="line-added">+         int expectedExitCode = !STRICT || expectedUnsignedContent.isEmpty() ? 0 : 32;</span>
<span class="line-added">+         if (outputAnalyzer.getExitValue() != expectedExitCode) {</span>
<span class="line-added">+             System.out.println(&quot;verifyingStatus: error: exit code != &quot; + expectedExitCode + &quot;: &quot; + outputAnalyzer.getExitValue() + &quot; != &quot; + expectedExitCode);</span>
<span class="line-added">+             return Status.ERROR;</span>
<span class="line-added">+         }</span>
<span class="line-added">+         String expectedSuccessMessage = expectedUnsignedContent.isEmpty() ?</span>
<span class="line-added">+                 Test.JAR_VERIFIED : Test.JAR_VERIFIED_WITH_SIGNER_ERRORS;</span>
<span class="line-added">+         if (!outputAnalyzer.getOutput().contains(expectedSuccessMessage)) {</span>
<span class="line-added">+             System.out.println(&quot;verifyingStatus: error: expectedSuccessMessage not found: &quot; + expectedSuccessMessage);</span>
              return Status.ERROR;
          }
  
<span class="line-modified">!         boolean tsa = signItem.tsaIndex &gt;= 0;</span>
<span class="line-modified">!         boolean warning = false;</span>
<span class="line-modified">!         for (String line : outputAnalyzer.getOutput().lines()</span>
<span class="line-modified">!                 .toArray(String[]::new)) {</span>
<span class="line-modified">!             if (line.isBlank()) continue;</span>
<span class="line-modified">!             if (Test.JAR_VERIFIED.equals(line)) continue;</span>
<span class="line-modified">!             if (line.matches(Test.ERROR + &quot; ?&quot;) &amp;&amp; expectedExitCode == 0) {</span>
<span class="line-modified">!                 System.out.println(&quot;verifyingStatus: error: line.matches(&quot; + Test.ERROR + &quot;\&quot; ?\&quot;): &quot; + line);</span>
<span class="line-modified">!                 return Status.ERROR;</span>
<span class="line-added">+             }</span>
<span class="line-added">+             if (line.matches(Test.WARNING + &quot; ?&quot;)) {</span>
<span class="line-added">+                 warning = true;</span>
<span class="line-added">+                 continue;</span>
<span class="line-added">+             }</span>
<span class="line-added">+             if (!warning) continue;</span>
<span class="line-added">+             line = line.strip();</span>
<span class="line-added">+             if (Test.NOT_YET_VALID_CERT_SIGNING_WARNING.equals(line)) continue;</span>
<span class="line-added">+             if (Test.HAS_EXPIRING_CERT_SIGNING_WARNING.equals(line)) continue;</span>
<span class="line-added">+             if (Test.HAS_EXPIRING_CERT_VERIFYING_WARNING.equals(line)) continue;</span>
<span class="line-added">+             if (line.matches(&quot;^&quot; + Test.NO_TIMESTAMP_SIGNING_WARN_TEMPLATE</span>
<span class="line-added">+                     .replaceAll(</span>
<span class="line-added">+                         &quot;\\(%1\\$tY-%1\\$tm-%1\\$td\\)&quot;, &quot;\\\\([^\\\\)]+\\\\)&quot;</span>
<span class="line-added">+                         + &quot;( or after any future revocation date)?&quot;)</span>
<span class="line-added">+                     .replaceAll(&quot;[.]&quot;, &quot;[.]&quot;) + &quot;$&quot;) &amp;&amp; !tsa) continue;</span>
<span class="line-added">+             if (line.matches(&quot;^&quot; + Test.NO_TIMESTAMP_VERIFYING_WARN_TEMPLATE</span>
<span class="line-added">+                     .replaceAll(&quot;\\(as early as %1\\$tY-%1\\$tm-%1\\$td\\)&quot;,</span>
<span class="line-added">+                         &quot;\\\\([^\\\\)]+\\\\)&quot;</span>
<span class="line-added">+                         + &quot;( or after any future revocation date)?&quot;)</span>
<span class="line-added">+                     .replaceAll(&quot;[.]&quot;, &quot;[.]&quot;) + &quot;$&quot;) &amp;&amp; !tsa) continue;</span>
<span class="line-added">+             if (line.matches(&quot;^This jar contains signatures that do(es)? not &quot;</span>
<span class="line-added">+                     + &quot;include a timestamp[.] Without a timestamp, users may &quot;</span>
<span class="line-added">+                     + &quot;not be able to validate this jar after the signer &quot;</span>
<span class="line-added">+                     + &quot;certificate&#39;s expiration date \\([^\\)]+\\) or after &quot;</span>
<span class="line-added">+                     + &quot;any future revocation date[.]&quot;) &amp;&amp; !tsa) continue;</span>
<span class="line-added">+             if (Test.CERTIFICATE_SELF_SIGNED.equals(line)) continue;</span>
<span class="line-added">+             if (Test.HAS_EXPIRED_CERT_VERIFYING_WARNING.equals(line)</span>
<span class="line-added">+                     &amp;&amp; signItem.certInfo.expired) continue;</span>
<span class="line-added">+             System.out.println(&quot;verifyingStatus: unexpected line: &quot; + line);</span>
<span class="line-added">+             return Status.ERROR; // treat unexpected warnings as error</span>
          }
<span class="line-added">+         return warning ? Status.WARNING : Status.NORMAL;</span>
      }
  
      // Using specified jarsigner to sign the pre-created jar with specified
      // algorithms.
      private static OutputAnalyzer signJar(String jarsignerPath, String sigalg,
<span class="line-modified">!             String jarDigestAlgorithm,</span>
<span class="line-modified">!             String tsadigestalg, String tsa, String alias, String unsignedJar,</span>
<span class="line-modified">!             String signedJar) throws Throwable {</span>
<span class="line-added">+         List&lt;String&gt; arguments = new ArrayList&lt;&gt;();</span>
  
          if (PROXY_HOST != null &amp;&amp; PROXY_PORT != null) {
              arguments.add(&quot;-J-Dhttp.proxyHost=&quot; + PROXY_HOST);
              arguments.add(&quot;-J-Dhttp.proxyPort=&quot; + PROXY_PORT);
              arguments.add(&quot;-J-Dhttps.proxyHost=&quot; + PROXY_HOST);
              arguments.add(&quot;-J-Dhttps.proxyPort=&quot; + PROXY_PORT);
          }
          arguments.add(&quot;-J-Djava.security.properties=&quot; + JAVA_SECURITY);
          arguments.add(&quot;-debug&quot;);
          arguments.add(&quot;-verbose&quot;);
<span class="line-added">+         if (jarDigestAlgorithm != null) {</span>
<span class="line-added">+             arguments.add(&quot;-digestalg&quot;);</span>
<span class="line-added">+             arguments.add(jarDigestAlgorithm);</span>
<span class="line-added">+         }</span>
          if (sigalg != null) {
              arguments.add(&quot;-sigalg&quot;);
              arguments.add(sigalg);
          }
          if (tsa != null) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 647,75 ***</span>
          }
          arguments.add(&quot;-keystore&quot;);
          arguments.add(KEYSTORE);
          arguments.add(&quot;-storepass&quot;);
          arguments.add(PASSWORD);
          arguments.add(&quot;-signedjar&quot;);
          arguments.add(signedJar + &quot;.jar&quot;);
<span class="line-modified">!         arguments.add(TEST_JAR_NAME);</span>
          arguments.add(alias);
  
<span class="line-modified">!         OutputAnalyzer outputAnalyzer = execTool(</span>
<span class="line-removed">-                 jarsignerPath,</span>
                  arguments.toArray(new String[arguments.size()]));
          return outputAnalyzer;
      }
  
      // Using specified jarsigner to verify the signed jar.
      private static OutputAnalyzer verifyJar(String jarsignerPath,
<span class="line-modified">!             String signedJar) throws Throwable {</span>
<span class="line-modified">!         OutputAnalyzer outputAnalyzer = execTool(</span>
<span class="line-modified">!                 jarsignerPath,</span>
<span class="line-modified">!                 &quot;-J-Djava.security.properties=&quot; + JAVA_SECURITY,</span>
<span class="line-modified">!                 &quot;-debug&quot;,</span>
<span class="line-modified">!                 &quot;-verbose&quot;,</span>
<span class="line-modified">!                 &quot;-certs&quot;,</span>
<span class="line-modified">!                 &quot;-keystore&quot;, KEYSTORE,</span>
<span class="line-modified">!                 &quot;-verify&quot;, signedJar + &quot;.jar&quot;);</span>
          return outputAnalyzer;
      }
  
      // Generates the test result report.
<span class="line-modified">!     private static boolean generateReport(List&lt;TsaInfo&gt; tsaList,</span>
              List&lt;SignItem&gt; signItems) throws IOException {
          System.out.println(&quot;Report is being generated...&quot;);
  
          StringBuilder report = new StringBuilder();
          report.append(HtmlHelper.startHtml());
          report.append(HtmlHelper.startPre());
          // Generates TSA URLs
          report.append(&quot;TSA list:\n&quot;);
          for(TsaInfo tsaInfo : tsaList) {
              report.append(
<span class="line-modified">!                     String.format(&quot;%d=%s%n&quot;, tsaInfo.index, tsaInfo.tsaUrl));</span>
          }
          report.append(HtmlHelper.endPre());
  
          report.append(HtmlHelper.startTable());
          // Generates report headers.
<span class="line-modified">!         List&lt;String&gt; headers = new ArrayList&lt;String&gt;();</span>
<span class="line-modified">!         headers.add(&quot;[Certificate]&quot;);</span>
          headers.add(&quot;[Signer JDK]&quot;);
          headers.add(&quot;[Signature Algorithm]&quot;);
<span class="line-modified">!         headers.add(&quot;[TSA Digest]&quot;);</span>
          headers.add(&quot;[TSA]&quot;);
          headers.add(&quot;[Signing Status]&quot;);
          headers.add(&quot;[Verifier JDK]&quot;);
          headers.add(&quot;[Verifying Status]&quot;);
          if (DELAY_VERIFY) {
              headers.add(&quot;[Delay Verifying Status]&quot;);
          }
          headers.add(&quot;[Failed]&quot;);
          report.append(HtmlHelper.htmlRow(
                  headers.toArray(new String[headers.size()])));
  
          StringBuilder failedReport = new StringBuilder(report.toString());
  
<span class="line-modified">!         boolean failed = false;</span>
  
          // Generates report rows.
          for (SignItem signItem : signItems) {
              for (VerifyItem verifyItem : signItem.verifyItems) {
                  String reportRow = reportRow(signItem, verifyItem);
                  report.append(reportRow);
                  boolean isFailedCase = isFailed(signItem, verifyItem);
                  if (isFailedCase) {
<span class="line-new-header">--- 879,95 ---</span>
          }
          arguments.add(&quot;-keystore&quot;);
          arguments.add(KEYSTORE);
          arguments.add(&quot;-storepass&quot;);
          arguments.add(PASSWORD);
<span class="line-added">+         arguments.add(&quot;-sigfile&quot;);</span>
<span class="line-added">+         arguments.add(nextSigfileName(alias, unsignedJar, signedJar));</span>
          arguments.add(&quot;-signedjar&quot;);
          arguments.add(signedJar + &quot;.jar&quot;);
<span class="line-modified">!         arguments.add(unsignedJar + &quot;.jar&quot;);</span>
          arguments.add(alias);
  
<span class="line-modified">!         OutputAnalyzer outputAnalyzer = execTool(jarsignerPath,</span>
                  arguments.toArray(new String[arguments.size()]));
          return outputAnalyzer;
      }
  
      // Using specified jarsigner to verify the signed jar.
      private static OutputAnalyzer verifyJar(String jarsignerPath,
<span class="line-modified">!             String signedJar, String alias) throws Throwable {</span>
<span class="line-modified">!         List&lt;String&gt; arguments = new ArrayList&lt;&gt;();</span>
<span class="line-modified">!         arguments.add(&quot;-J-Djava.security.properties=&quot; + JAVA_SECURITY);</span>
<span class="line-modified">!         arguments.add(&quot;-debug&quot;);</span>
<span class="line-modified">!         arguments.add(&quot;-verbose&quot;);</span>
<span class="line-modified">!         arguments.add(&quot;-certs&quot;);</span>
<span class="line-modified">!         arguments.add(&quot;-keystore&quot;);</span>
<span class="line-modified">!         arguments.add(KEYSTORE);</span>
<span class="line-modified">!         arguments.add(&quot;-verify&quot;);</span>
<span class="line-added">+         if (STRICT) arguments.add(&quot;-strict&quot;);</span>
<span class="line-added">+         arguments.add(signedJar + &quot;.jar&quot;);</span>
<span class="line-added">+         if (alias != null) arguments.add(alias);</span>
<span class="line-added">+         OutputAnalyzer outputAnalyzer = execTool(jarsignerPath,</span>
<span class="line-added">+                 arguments.toArray(new String[arguments.size()]));</span>
          return outputAnalyzer;
      }
  
      // Generates the test result report.
<span class="line-modified">!     private static boolean generateReport(List&lt;JdkInfo&gt; jdkList, List&lt;TsaInfo&gt; tsaList,</span>
              List&lt;SignItem&gt; signItems) throws IOException {
          System.out.println(&quot;Report is being generated...&quot;);
  
          StringBuilder report = new StringBuilder();
          report.append(HtmlHelper.startHtml());
          report.append(HtmlHelper.startPre());
<span class="line-added">+ </span>
<span class="line-added">+         // Generates JDK list</span>
<span class="line-added">+         report.append(&quot;JDK list:\n&quot;);</span>
<span class="line-added">+         for(JdkInfo jdkInfo : jdkList) {</span>
<span class="line-added">+             report.append(String.format(&quot;%d=%s%n&quot;,</span>
<span class="line-added">+                     jdkInfo.index,</span>
<span class="line-added">+                     jdkInfo.runtimeVersion));</span>
<span class="line-added">+         }</span>
<span class="line-added">+ </span>
          // Generates TSA URLs
          report.append(&quot;TSA list:\n&quot;);
          for(TsaInfo tsaInfo : tsaList) {
              report.append(
<span class="line-modified">!                     String.format(&quot;%d=%s%n&quot;, tsaInfo.index,</span>
<span class="line-added">+                             tsaInfo.tsaUrl == null ? &quot;notsa&quot; : tsaInfo.tsaUrl));</span>
          }
          report.append(HtmlHelper.endPre());
  
          report.append(HtmlHelper.startTable());
          // Generates report headers.
<span class="line-modified">!         List&lt;String&gt; headers = new ArrayList&lt;&gt;();</span>
<span class="line-modified">!         headers.add(&quot;[Jarfile]&quot;);</span>
<span class="line-added">+         headers.add(&quot;[Signing Certificate]&quot;);</span>
          headers.add(&quot;[Signer JDK]&quot;);
          headers.add(&quot;[Signature Algorithm]&quot;);
<span class="line-modified">!         headers.add(&quot;[Jar Digest Algorithm]&quot;);</span>
<span class="line-added">+         headers.add(&quot;[TSA Digest Algorithm]&quot;);</span>
          headers.add(&quot;[TSA]&quot;);
          headers.add(&quot;[Signing Status]&quot;);
          headers.add(&quot;[Verifier JDK]&quot;);
<span class="line-added">+         headers.add(&quot;[Verifying Certificate]&quot;);</span>
          headers.add(&quot;[Verifying Status]&quot;);
          if (DELAY_VERIFY) {
              headers.add(&quot;[Delay Verifying Status]&quot;);
          }
          headers.add(&quot;[Failed]&quot;);
          report.append(HtmlHelper.htmlRow(
                  headers.toArray(new String[headers.size()])));
  
          StringBuilder failedReport = new StringBuilder(report.toString());
  
<span class="line-modified">!         boolean failed = signItems.isEmpty();</span>
  
          // Generates report rows.
          for (SignItem signItem : signItems) {
<span class="line-added">+             failed = failed || signItem.verifyItems.isEmpty();</span>
              for (VerifyItem verifyItem : signItem.verifyItems) {
                  String reportRow = reportRow(signItem, verifyItem);
                  report.append(reportRow);
                  boolean isFailedCase = isFailed(signItem, verifyItem);
                  if (isFailedCase) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 765,63 ***</span>
  
      // Executes the specified JDK tools, such as keytool and jarsigner, and
      // ensures the output is in US English.
      private static OutputAnalyzer execTool(String toolPath, String... args)
              throws Throwable {
<span class="line-modified">!         String[] cmd = new String[args.length + 4];</span>
<span class="line-modified">!         cmd[0] = toolPath;</span>
<span class="line-modified">!         cmd[1] = &quot;-J-Duser.language=en&quot;;</span>
<span class="line-modified">!         cmd[2] = &quot;-J-Duser.country=US&quot;;</span>
<span class="line-modified">!         cmd[3] = &quot;-J-Djava.security.egd=file:/dev/./urandom&quot;;</span>
<span class="line-modified">!         System.arraycopy(args, 0, cmd, 4, args.length);</span>
<span class="line-modified">!         return ProcessTools.executeCommand(cmd);</span>
      }
  
      private static class JdkInfo {
  
          private final String jdkPath;
          private final String jarsignerPath;
<span class="line-modified">!         private final String version;</span>
          private final boolean supportsTsadigestalg;
  
<span class="line-modified">!         private Map&lt;String, Boolean&gt; sigalgMap = new HashMap&lt;String, Boolean&gt;();</span>
  
          private JdkInfo(String jdkPath) throws Throwable {
              this.jdkPath = jdkPath;
<span class="line-modified">!             version = execJdkUtils(jdkPath, JdkUtils.M_JAVA_RUNTIME_VERSION);</span>
<span class="line-modified">!             if (version == null || version.trim().isEmpty()) {</span>
                  throw new RuntimeException(
                          &quot;Cannot determine the JDK version: &quot; + jdkPath);
              }
<span class="line-modified">!             jarsignerPath = jarsignerPath(jdkPath);</span>
              supportsTsadigestalg = execTool(jarsignerPath, &quot;-help&quot;)
                      .getOutput().contains(&quot;-tsadigestalg&quot;);
          }
  
          private boolean isSupportedSigalg(String sigalg) throws Throwable {
              if (!sigalgMap.containsKey(sigalg)) {
<span class="line-modified">!                 boolean isSupported = &quot;true&quot;.equalsIgnoreCase(</span>
                          execJdkUtils(
                                  jdkPath,
                                  JdkUtils.M_IS_SUPPORTED_SIGALG,
                                  sigalg));
                  sigalgMap.put(sigalg, isSupported);
              }
  
              return sigalgMap.get(sigalg);
          }
  
<span class="line-modified">!         private boolean isJdk6() {</span>
<span class="line-modified">!             return version.startsWith(&quot;1.6&quot;);</span>
          }
  
          @Override
          public int hashCode() {
              final int prime = 31;
              int result = 1;
              result = prime * result
<span class="line-modified">!                     + ((version == null) ? 0 : version.hashCode());</span>
              return result;
          }
  
          @Override
          public boolean equals(Object obj) {
<span class="line-new-header">--- 1017,82 ---</span>
  
      // Executes the specified JDK tools, such as keytool and jarsigner, and
      // ensures the output is in US English.
      private static OutputAnalyzer execTool(String toolPath, String... args)
              throws Throwable {
<span class="line-modified">!         long start = System.currentTimeMillis();</span>
<span class="line-modified">!         try {</span>
<span class="line-modified">! </span>
<span class="line-modified">!             String[] cmd = new String[args.length + 4];</span>
<span class="line-modified">!             cmd[0] = toolPath;</span>
<span class="line-modified">!             cmd[1] = &quot;-J-Duser.language=en&quot;;</span>
<span class="line-modified">!             cmd[2] = &quot;-J-Duser.country=US&quot;;</span>
<span class="line-added">+             cmd[3] = &quot;-J-Djava.security.egd=file:/dev/./urandom&quot;;</span>
<span class="line-added">+             System.arraycopy(args, 0, cmd, 4, args.length);</span>
<span class="line-added">+             return ProcessTools.executeCommand(cmd);</span>
<span class="line-added">+ </span>
<span class="line-added">+         } finally {</span>
<span class="line-added">+             long end = System.currentTimeMillis();</span>
<span class="line-added">+             System.out.println(&quot;child process duration [ms]: &quot; + (end - start));</span>
<span class="line-added">+         }</span>
      }
  
      private static class JdkInfo {
  
<span class="line-added">+         private int index;</span>
          private final String jdkPath;
          private final String jarsignerPath;
<span class="line-modified">!         private final String runtimeVersion;</span>
<span class="line-added">+         private String version;</span>
<span class="line-added">+         private final int majorVersion;</span>
          private final boolean supportsTsadigestalg;
  
<span class="line-modified">!         private Map&lt;String, Boolean&gt; sigalgMap = new HashMap&lt;&gt;();</span>
  
          private JdkInfo(String jdkPath) throws Throwable {
              this.jdkPath = jdkPath;
<span class="line-modified">!             jarsignerPath = jarsignerPath(jdkPath);</span>
<span class="line-modified">!             runtimeVersion = execJdkUtils(jdkPath, JdkUtils.M_JAVA_RUNTIME_VERSION);</span>
<span class="line-added">+             if (runtimeVersion == null || runtimeVersion.isBlank()) {</span>
                  throw new RuntimeException(
                          &quot;Cannot determine the JDK version: &quot; + jdkPath);
              }
<span class="line-modified">!             version = execJdkUtils(jdkPath, JdkUtils.M_JAVA_VERSION);</span>
<span class="line-added">+             majorVersion = Integer.parseInt((runtimeVersion.matches(&quot;^1[.].*&quot;) ?</span>
<span class="line-added">+                     runtimeVersion.substring(2) : runtimeVersion).replaceAll(&quot;[^0-9].*$&quot;, &quot;&quot;));</span>
              supportsTsadigestalg = execTool(jarsignerPath, &quot;-help&quot;)
                      .getOutput().contains(&quot;-tsadigestalg&quot;);
          }
  
          private boolean isSupportedSigalg(String sigalg) throws Throwable {
              if (!sigalgMap.containsKey(sigalg)) {
<span class="line-modified">!                 boolean isSupported = Boolean.parseBoolean(</span>
                          execJdkUtils(
                                  jdkPath,
                                  JdkUtils.M_IS_SUPPORTED_SIGALG,
                                  sigalg));
                  sigalgMap.put(sigalg, isSupported);
              }
  
              return sigalgMap.get(sigalg);
          }
  
<span class="line-modified">!         private boolean isAtLeastMajorVersion(int minVersion) {</span>
<span class="line-modified">!             return majorVersion &gt;= minVersion;</span>
<span class="line-added">+         }</span>
<span class="line-added">+ </span>
<span class="line-added">+         private boolean supportsKeyAlg(String keyAlgorithm) {</span>
<span class="line-added">+             // JDK 6 doesn&#39;t support EC</span>
<span class="line-added">+             return isAtLeastMajorVersion(6) || !EC.equals(keyAlgorithm);</span>
          }
  
          @Override
          public int hashCode() {
              final int prime = 31;
              int result = 1;
              result = prime * result
<span class="line-modified">!                     + ((runtimeVersion == null) ? 0 : runtimeVersion.hashCode());</span>
              return result;
          }
  
          @Override
          public boolean equals(Object obj) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 830,76 ***</span>
              if (obj == null)
                  return false;
              if (getClass() != obj.getClass())
                  return false;
              JdkInfo other = (JdkInfo) obj;
<span class="line-modified">!             if (version == null) {</span>
<span class="line-modified">!                 if (other.version != null)</span>
                      return false;
<span class="line-modified">!             } else if (!version.equals(other.version))</span>
                  return false;
              return true;
          }
      }
  
      private static class TsaInfo {
  
          private final int index;
          private final String tsaUrl;
<span class="line-modified">!         private Set&lt;String&gt; digestList = new HashSet&lt;String&gt;();</span>
  
          private TsaInfo(int index, String tsa) {
              this.index = index;
              this.tsaUrl = tsa;
          }
  
          private void addDigest(String digest) {
<span class="line-modified">!             if (!ignore(digest)) {</span>
<span class="line-removed">-                 digestList.add(digest);</span>
<span class="line-removed">-             }</span>
<span class="line-removed">-         }</span>
<span class="line-removed">- </span>
<span class="line-removed">-         private static boolean ignore(String digest) {</span>
<span class="line-removed">-             return !SHA1.equalsIgnoreCase(digest)</span>
<span class="line-removed">-                     &amp;&amp; !SHA256.equalsIgnoreCase(digest)</span>
<span class="line-removed">-                     &amp;&amp; !SHA512.equalsIgnoreCase(digest);</span>
          }
  
          private boolean isDigestSupported(String digest) {
              return digest == null || digestList.isEmpty()
                      || digestList.contains(digest);
          }
      }
  
      private static class CertInfo {
  
<span class="line-modified">!         private final String jdkVersion;</span>
          private final String keyAlgorithm;
          private final String digestAlgorithm;
          private final int keySize;
          private final boolean expired;
  
<span class="line-modified">!         private CertInfo(String jdkVersion, String keyAlgorithm,</span>
                  String digestAlgorithm, int keySize, boolean expired) {
<span class="line-modified">!             this.jdkVersion = jdkVersion;</span>
              this.keyAlgorithm = keyAlgorithm;
              this.digestAlgorithm = digestAlgorithm;
              this.keySize = keySize;
              this.expired = expired;
          }
  
          @Override
          public int hashCode() {
              final int prime = 31;
              int result = 1;
              result = prime * result
<span class="line-modified">!                     + ((digestAlgorithm == null) ? 0 : digestAlgorithm.hashCode());</span>
              result = prime * result + (expired ? 1231 : 1237);
              result = prime * result
<span class="line-modified">!                     + ((jdkVersion == null) ? 0 : jdkVersion.hashCode());</span>
              result = prime * result
<span class="line-modified">!                     + ((keyAlgorithm == null) ? 0 : keyAlgorithm.hashCode());</span>
              result = prime * result + keySize;
              return result;
          }
  
          @Override
<span class="line-new-header">--- 1101,105 ---</span>
              if (obj == null)
                  return false;
              if (getClass() != obj.getClass())
                  return false;
              JdkInfo other = (JdkInfo) obj;
<span class="line-modified">!             if (runtimeVersion == null) {</span>
<span class="line-modified">!                 if (other.runtimeVersion != null)</span>
                      return false;
<span class="line-modified">!             } else if (!runtimeVersion.equals(other.runtimeVersion))</span>
                  return false;
              return true;
          }
<span class="line-added">+ </span>
<span class="line-added">+         @Override</span>
<span class="line-added">+         public String toString() {</span>
<span class="line-added">+             return &quot;JdkInfo[&quot; + runtimeVersion + &quot;, &quot; + jdkPath + &quot;]&quot;;</span>
<span class="line-added">+         }</span>
      }
  
      private static class TsaInfo {
  
          private final int index;
          private final String tsaUrl;
<span class="line-modified">!         private Set&lt;String&gt; digestList = new HashSet&lt;&gt;();</span>
  
          private TsaInfo(int index, String tsa) {
              this.index = index;
              this.tsaUrl = tsa;
          }
  
          private void addDigest(String digest) {
<span class="line-modified">!             digestList.add(digest);</span>
          }
  
          private boolean isDigestSupported(String digest) {
              return digest == null || digestList.isEmpty()
                      || digestList.contains(digest);
          }
<span class="line-added">+ </span>
<span class="line-added">+         @Override</span>
<span class="line-added">+         public String toString() {</span>
<span class="line-added">+             return &quot;TsaInfo[&quot; + index + &quot;, &quot; + tsaUrl + &quot;]&quot;;</span>
<span class="line-added">+         }</span>
      }
  
      private static class CertInfo {
  
<span class="line-modified">!         private static int certCounter;</span>
<span class="line-added">+ </span>
<span class="line-added">+         // nr distinguishes cert CNs in jarsigner -verify output</span>
<span class="line-added">+         private final int nr = ++certCounter;</span>
<span class="line-added">+         private final JdkInfo jdkInfo;</span>
          private final String keyAlgorithm;
          private final String digestAlgorithm;
          private final int keySize;
          private final boolean expired;
  
<span class="line-modified">!         private CertInfo(JdkInfo jdkInfo, String keyAlgorithm,</span>
                  String digestAlgorithm, int keySize, boolean expired) {
<span class="line-modified">!             this.jdkInfo = jdkInfo;</span>
              this.keyAlgorithm = keyAlgorithm;
              this.digestAlgorithm = digestAlgorithm;
              this.keySize = keySize;
              this.expired = expired;
          }
  
<span class="line-added">+         private String sigalg() {</span>
<span class="line-added">+             return DEFAULT.equals(digestAlgorithm) ? null : expectedSigalg();</span>
<span class="line-added">+         }</span>
<span class="line-added">+ </span>
<span class="line-added">+         private String expectedSigalg() {</span>
<span class="line-added">+             return (DEFAULT.equals(this.digestAlgorithm) ? this.digestAlgorithm</span>
<span class="line-added">+                     : &quot;SHA-256&quot;).replace(&quot;-&quot;, &quot;&quot;) + &quot;with&quot; +</span>
<span class="line-added">+                     keyAlgorithm + (EC.equals(keyAlgorithm) ? &quot;DSA&quot; : &quot;&quot;);</span>
<span class="line-added">+         }</span>
<span class="line-added">+ </span>
<span class="line-added">+         private int expectedKeySize() {</span>
<span class="line-added">+             if (keySize != 0) return keySize;</span>
<span class="line-added">+ </span>
<span class="line-added">+             // defaults</span>
<span class="line-added">+             if (RSA.equals(keyAlgorithm) || DSA.equals(keyAlgorithm)) {</span>
<span class="line-added">+                 return 2048;</span>
<span class="line-added">+             } else if (EC.equals(keyAlgorithm)) {</span>
<span class="line-added">+                 return 256;</span>
<span class="line-added">+             } else {</span>
<span class="line-added">+                 throw new RuntimeException(&quot;problem determining key size&quot;);</span>
<span class="line-added">+             }</span>
<span class="line-added">+         }</span>
<span class="line-added">+ </span>
          @Override
          public int hashCode() {
              final int prime = 31;
              int result = 1;
              result = prime * result
<span class="line-modified">!                     + (digestAlgorithm == null ? 0 : digestAlgorithm.hashCode());</span>
              result = prime * result + (expired ? 1231 : 1237);
              result = prime * result
<span class="line-modified">!                     + (jdkInfo == null ? 0 : jdkInfo.hashCode());</span>
              result = prime * result
<span class="line-modified">!                     + (keyAlgorithm == null ? 0 : keyAlgorithm.hashCode());</span>
              result = prime * result + keySize;
              return result;
          }
  
          @Override
</pre>
<hr />
<pre>
<span class="line-old-header">*** 916,14 ***</span>
                      return false;
              } else if (!digestAlgorithm.equals(other.digestAlgorithm))
                  return false;
              if (expired != other.expired)
                  return false;
<span class="line-modified">!             if (jdkVersion == null) {</span>
<span class="line-modified">!                 if (other.jdkVersion != null)</span>
                      return false;
<span class="line-modified">!             } else if (!jdkVersion.equals(other.jdkVersion))</span>
                  return false;
              if (keyAlgorithm == null) {
                  if (other.keyAlgorithm != null)
                      return false;
              } else if (!keyAlgorithm.equals(other.keyAlgorithm))
<span class="line-new-header">--- 1216,14 ---</span>
                      return false;
              } else if (!digestAlgorithm.equals(other.digestAlgorithm))
                  return false;
              if (expired != other.expired)
                  return false;
<span class="line-modified">!             if (jdkInfo == null) {</span>
<span class="line-modified">!                 if (other.jdkInfo != null)</span>
                      return false;
<span class="line-modified">!             } else if (!jdkInfo.equals(other.jdkInfo))</span>
                  return false;
              if (keyAlgorithm == null) {
                  if (other.keyAlgorithm != null)
                      return false;
              } else if (!keyAlgorithm.equals(other.keyAlgorithm))
</pre>
<hr />
<pre>
<span class="line-old-header">*** 932,26 ***</span>
                  return false;
              return true;
          }
  
          private String alias() {
<span class="line-modified">!             return jdkVersion + &quot;_&quot; + toString();</span>
          }
  
          @Override
          public String toString() {
<span class="line-modified">!             return keyAlgorithm + &quot;_&quot; + digestAlgorithm</span>
                      + (keySize == 0 ? &quot;&quot; : &quot;_&quot; + keySize)
                      + (expired ? &quot;_Expired&quot; : &quot;&quot;);
          }
      }
  
      // It does only one timestamping for the same JDK, digest algorithm and
      // TSA service with an arbitrary valid/expired certificate.
      private static class TsaFilter {
  
<span class="line-modified">!         private static final Set&lt;Condition&gt; SET = new HashSet&lt;Condition&gt;();</span>
  
          private static boolean filter(String signerVersion,
                  String digestAlgorithm, boolean expiredCert, int tsaIndex) {
              return !SET.add(new Condition(signerVersion, digestAlgorithm,
                      expiredCert, tsaIndex));
<span class="line-new-header">--- 1232,30 ---</span>
                  return false;
              return true;
          }
  
          private String alias() {
<span class="line-modified">!             return (jdkInfo.version + &quot;_&quot; + toString())</span>
<span class="line-added">+                     // lower case for jks due to</span>
<span class="line-added">+                     // sun.security.provider.JavaKeyStore.JDK.convertAlias</span>
<span class="line-added">+                     .toLowerCase(Locale.ENGLISH);</span>
          }
  
          @Override
          public String toString() {
<span class="line-modified">!             return &quot;nr&quot; + nr + &quot;_&quot;</span>
<span class="line-added">+                     + keyAlgorithm + &quot;_&quot; + digestAlgorithm</span>
                      + (keySize == 0 ? &quot;&quot; : &quot;_&quot; + keySize)
                      + (expired ? &quot;_Expired&quot; : &quot;&quot;);
          }
      }
  
      // It does only one timestamping for the same JDK, digest algorithm and
      // TSA service with an arbitrary valid/expired certificate.
      private static class TsaFilter {
  
<span class="line-modified">!         private static final Set&lt;Condition&gt; SET = new HashSet&lt;&gt;();</span>
  
          private static boolean filter(String signerVersion,
                  String digestAlgorithm, boolean expiredCert, int tsaIndex) {
              return !SET.add(new Condition(signerVersion, digestAlgorithm,
                      expiredCert, tsaIndex));
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1027,58 ***</span>
          NORMAL
      }
  
      private static class SignItem {
  
          private CertInfo certInfo;
<span class="line-modified">!         private String version;</span>
<span class="line-modified">!         private String signatureAlgorithm;</span>
<span class="line-removed">-         // Signature algorithm that is extracted from verification output.</span>
<span class="line-removed">-         private String extractedSignatureAlgorithm;</span>
          private String tsaDigestAlgorithm;
<span class="line-removed">-         // TSA digest algorithm that is extracted from verification output.</span>
<span class="line-removed">-         private String extractedTsaDigestAlgorithm;</span>
          private int tsaIndex;
          private Status status;
          private String signedJar;
  
<span class="line-modified">!         private List&lt;VerifyItem&gt; verifyItems = new ArrayList&lt;VerifyItem&gt;();</span>
  
          private static SignItem build() {
<span class="line-modified">!             return new SignItem();</span>
          }
  
          private SignItem certInfo(CertInfo certInfo) {
              this.certInfo = certInfo;
              return this;
          }
  
<span class="line-modified">!         private SignItem version(String version) {</span>
<span class="line-modified">!             this.version = version;</span>
              return this;
          }
  
<span class="line-modified">!         private SignItem signatureAlgorithm(String signatureAlgorithm) {</span>
<span class="line-modified">!             this.signatureAlgorithm = signatureAlgorithm;</span>
              return this;
          }
  
<span class="line-modified">!         private SignItem extractedSignatureAlgorithm(</span>
<span class="line-modified">!                 String extractedSignatureAlgorithm) {</span>
<span class="line-removed">-             this.extractedSignatureAlgorithm = extractedSignatureAlgorithm;</span>
<span class="line-removed">-             return this;</span>
          }
  
          private SignItem tsaDigestAlgorithm(String tsaDigestAlgorithm) {
              this.tsaDigestAlgorithm = tsaDigestAlgorithm;
              return this;
          }
  
<span class="line-modified">!         private SignItem extractedTsaDigestAlgorithm(</span>
<span class="line-modified">!                 String extractedTsaDigestAlgorithm) {</span>
<span class="line-removed">-             this.extractedTsaDigestAlgorithm = extractedTsaDigestAlgorithm;</span>
<span class="line-removed">-             return this;</span>
          }
  
          private SignItem tsaIndex(int tsaIndex) {
              this.tsaIndex = tsaIndex;
              return this;
<span class="line-new-header">--- 1331,64 ---</span>
          NORMAL
      }
  
      private static class SignItem {
  
<span class="line-added">+         private SignItem prevSign;</span>
          private CertInfo certInfo;
<span class="line-modified">!         private JdkInfo jdkInfo;</span>
<span class="line-modified">!         private String digestAlgorithm;</span>
          private String tsaDigestAlgorithm;
          private int tsaIndex;
          private Status status;
<span class="line-added">+         private String unsignedJar;</span>
          private String signedJar;
<span class="line-added">+         private List&lt;String&gt; jarContents = new ArrayList&lt;&gt;();</span>
  
<span class="line-modified">!         private List&lt;VerifyItem&gt; verifyItems = new ArrayList&lt;&gt;();</span>
  
          private static SignItem build() {
<span class="line-modified">!             return new SignItem()</span>
<span class="line-added">+                     .addContentFiles(Arrays.asList(&quot;META-INF/MANIFEST.MF&quot;));</span>
<span class="line-added">+         }</span>
<span class="line-added">+ </span>
<span class="line-added">+         private static SignItem build(SignItem prevSign) {</span>
<span class="line-added">+             return build().prevSign(prevSign).unsignedJar(prevSign.signedJar)</span>
<span class="line-added">+                     .addContentFiles(prevSign.jarContents);</span>
<span class="line-added">+         }</span>
<span class="line-added">+ </span>
<span class="line-added">+         private SignItem prevSign(SignItem prevSign) {</span>
<span class="line-added">+             this.prevSign = prevSign;</span>
<span class="line-added">+             return this;</span>
          }
  
          private SignItem certInfo(CertInfo certInfo) {
              this.certInfo = certInfo;
              return this;
          }
  
<span class="line-modified">!         private SignItem jdkInfo(JdkInfo jdkInfo) {</span>
<span class="line-modified">!             this.jdkInfo = jdkInfo;</span>
              return this;
          }
  
<span class="line-modified">!         private SignItem digestAlgorithm(String digestAlgorithm) {</span>
<span class="line-modified">!             this.digestAlgorithm = digestAlgorithm;</span>
              return this;
          }
  
<span class="line-modified">!         String expectedDigestAlg() {</span>
<span class="line-modified">!             return digestAlgorithm != null ? digestAlgorithm : &quot;SHA-256&quot;;</span>
          }
  
          private SignItem tsaDigestAlgorithm(String tsaDigestAlgorithm) {
              this.tsaDigestAlgorithm = tsaDigestAlgorithm;
              return this;
          }
  
<span class="line-modified">!         String expectedTsaDigestAlg() {</span>
<span class="line-modified">!             return tsaDigestAlgorithm != null ? tsaDigestAlgorithm : &quot;SHA-256&quot;;</span>
          }
  
          private SignItem tsaIndex(int tsaIndex) {
              this.tsaIndex = tsaIndex;
              return this;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1087,97 ***</span>
          private SignItem status(Status status) {
              this.status = status;
              return this;
          }
  
          private SignItem signedJar(String signedJar) {
              this.signedJar = signedJar;
              return this;
          }
  
          private void addVerifyItem(VerifyItem verifyItem) {
              verifyItems.add(verifyItem);
          }
      }
  
      private static class VerifyItem {
  
          private JdkInfo jdkInfo;
          private Status status = Status.NONE;
          private Status delayStatus = Status.NONE;
  
          private static VerifyItem build(JdkInfo jdkInfo) {
              VerifyItem verifyItem = new VerifyItem();
              verifyItem.jdkInfo = jdkInfo;
              return verifyItem;
          }
  
          private VerifyItem status(Status status) {
              this.status = status;
              return this;
          }
  
          private VerifyItem delayStatus(Status status) {
              this.delayStatus = status;
              return this;
          }
      }
  
      // The identifier for a specific signing.
      private static String signingId(SignItem signItem) {
          return signItem.signedJar;
      }
  
      // The identifier for a specific verifying.
      private static String verifyingId(SignItem signItem, VerifyItem verifyItem,
              boolean delayVerify) {
<span class="line-modified">!         return &quot;S_&quot; + signingId(signItem) + &quot;-&quot; + (delayVerify ? &quot;DV&quot; : &quot;V&quot;)</span>
<span class="line-modified">!                 + &quot;_&quot; + verifyItem.jdkInfo.version;</span>
      }
  
      private static String reportRow(SignItem signItem, VerifyItem verifyItem) {
<span class="line-modified">!         List&lt;String&gt; values = new ArrayList&lt;String&gt;();</span>
<span class="line-modified">!         values.add(signItem.certInfo.toString());</span>
<span class="line-modified">!         values.add(signItem.version);</span>
<span class="line-modified">!         values.add(null2Default(signItem.signatureAlgorithm,</span>
<span class="line-modified">!                 signItem.extractedSignatureAlgorithm));</span>
<span class="line-modified">!         values.add(signItem.tsaIndex == -1</span>
<span class="line-modified">!                    ? &quot;&quot;</span>
<span class="line-modified">!                    : null2Default(signItem.tsaDigestAlgorithm,</span>
<span class="line-modified">!                         signItem.extractedTsaDigestAlgorithm));</span>
<span class="line-modified">!         values.add(signItem.tsaIndex == -1 ? &quot;&quot; : signItem.tsaIndex + &quot;&quot;);</span>
<span class="line-modified">!         values.add(HtmlHelper.anchorLink(</span>
                  PhaseOutputStream.fileName(PhaseOutputStream.Phase.SIGNING),
<span class="line-modified">!                 signingId(signItem),</span>
<span class="line-modified">!                 signItem.status.toString()));</span>
          values.add(verifyItem.jdkInfo.version);
<span class="line-modified">!         values.add(HtmlHelper.anchorLink(</span>
                  PhaseOutputStream.fileName(PhaseOutputStream.Phase.VERIFYING),
<span class="line-modified">!                 verifyingId(signItem, verifyItem, false),</span>
<span class="line-modified">!                 verifyItem.status.toString()));</span>
          if (DELAY_VERIFY) {
<span class="line-modified">!             values.add(HtmlHelper.anchorLink(</span>
                      PhaseOutputStream.fileName(
                              PhaseOutputStream.Phase.DELAY_VERIFYING),
                      verifyingId(signItem, verifyItem, true),
                      verifyItem.delayStatus.toString()));
          }
          values.add(isFailed(signItem, verifyItem) ? &quot;X&quot; : &quot;&quot;);
          return HtmlHelper.htmlRow(values.toArray(new String[values.size()]));
      }
  
<span class="line-modified">!     private static boolean isFailed(SignItem signItem,</span>
<span class="line-modified">!             VerifyItem verifyItem) {</span>
<span class="line-modified">!         return signItem.status == Status.ERROR</span>
<span class="line-modified">!                 || verifyItem.status == Status.ERROR</span>
<span class="line-modified">!                 || verifyItem.delayStatus == Status.ERROR;</span>
      }
  
      // If a value is null, then displays the default value or N/A.
      private static String null2Default(String value, String defaultValue) {
<span class="line-modified">!         return value == null</span>
<span class="line-modified">!                ? DEFAULT + &quot;(&quot; + (defaultValue == null</span>
                                    ? &quot;N/A&quot;
<span class="line-modified">!                                   : defaultValue) + &quot;)&quot;</span>
<span class="line-removed">-                : value;</span>
      }
  }
<span class="line-new-header">--- 1397,211 ---</span>
          private SignItem status(Status status) {
              this.status = status;
              return this;
          }
  
<span class="line-added">+         private SignItem unsignedJar(String unsignedJar) {</span>
<span class="line-added">+             this.unsignedJar = unsignedJar;</span>
<span class="line-added">+             return this;</span>
<span class="line-added">+         }</span>
<span class="line-added">+ </span>
          private SignItem signedJar(String signedJar) {
              this.signedJar = signedJar;
              return this;
          }
  
<span class="line-added">+         private SignItem addContentFiles(List&lt;String&gt; files) {</span>
<span class="line-added">+             this.jarContents.addAll(files);</span>
<span class="line-added">+             return this;</span>
<span class="line-added">+         }</span>
<span class="line-added">+ </span>
          private void addVerifyItem(VerifyItem verifyItem) {
              verifyItems.add(verifyItem);
          }
<span class="line-added">+ </span>
<span class="line-added">+         private boolean isErrorInclPrev() {</span>
<span class="line-added">+             if (prevSign != null &amp;&amp; prevSign.isErrorInclPrev()) {</span>
<span class="line-added">+                 System.out.println(&quot;SignItem.isErrorInclPrev: returning true from previous&quot;);</span>
<span class="line-added">+                 return true;</span>
<span class="line-added">+             }</span>
<span class="line-added">+ </span>
<span class="line-added">+             return status == Status.ERROR;</span>
<span class="line-added">+         }</span>
<span class="line-added">+         private List&lt;String&gt; toStringWithPrev(Function&lt;SignItem,String&gt; toStr) {</span>
<span class="line-added">+             List&lt;String&gt; s = new ArrayList&lt;&gt;();</span>
<span class="line-added">+             if (prevSign != null) {</span>
<span class="line-added">+                 s.addAll(prevSign.toStringWithPrev(toStr));</span>
<span class="line-added">+             }</span>
<span class="line-added">+             if (status != null) { // no status means jar creation or update item</span>
<span class="line-added">+                 s.add(toStr.apply(this));</span>
<span class="line-added">+             }</span>
<span class="line-added">+             return s;</span>
<span class="line-added">+         }</span>
      }
  
      private static class VerifyItem {
  
<span class="line-added">+         private VerifyItem prevVerify;</span>
<span class="line-added">+         private CertInfo certInfo;</span>
          private JdkInfo jdkInfo;
          private Status status = Status.NONE;
          private Status delayStatus = Status.NONE;
  
          private static VerifyItem build(JdkInfo jdkInfo) {
              VerifyItem verifyItem = new VerifyItem();
              verifyItem.jdkInfo = jdkInfo;
              return verifyItem;
          }
  
<span class="line-added">+         private VerifyItem certInfo(CertInfo certInfo) {</span>
<span class="line-added">+             this.certInfo = certInfo;</span>
<span class="line-added">+             return this;</span>
<span class="line-added">+         }</span>
<span class="line-added">+ </span>
<span class="line-added">+         private void addSignerCertInfos(SignItem signItem) {</span>
<span class="line-added">+             VerifyItem prevVerify = this;</span>
<span class="line-added">+             CertInfo lastCertInfo = null;</span>
<span class="line-added">+             while (signItem != null) {</span>
<span class="line-added">+                 // (signItem.certInfo == null) means create or update jar step</span>
<span class="line-added">+                 if (signItem.certInfo != null</span>
<span class="line-added">+                         &amp;&amp; !signItem.certInfo.equals(lastCertInfo)) {</span>
<span class="line-added">+                     lastCertInfo = signItem.certInfo;</span>
<span class="line-added">+                     prevVerify = prevVerify.prevVerify =</span>
<span class="line-added">+                             build(jdkInfo).certInfo(signItem.certInfo);</span>
<span class="line-added">+                 }</span>
<span class="line-added">+                 signItem = signItem.prevSign;</span>
<span class="line-added">+             }</span>
<span class="line-added">+         }</span>
<span class="line-added">+ </span>
          private VerifyItem status(Status status) {
              this.status = status;
              return this;
          }
  
<span class="line-added">+         private boolean isErrorInclPrev() {</span>
<span class="line-added">+             if (prevVerify != null &amp;&amp; prevVerify.isErrorInclPrev()) {</span>
<span class="line-added">+                 System.out.println(&quot;VerifyItem.isErrorInclPrev: returning true from previous&quot;);</span>
<span class="line-added">+                 return true;</span>
<span class="line-added">+             }</span>
<span class="line-added">+ </span>
<span class="line-added">+             return status == Status.ERROR || delayStatus == Status.ERROR;</span>
<span class="line-added">+         }</span>
<span class="line-added">+ </span>
          private VerifyItem delayStatus(Status status) {
              this.delayStatus = status;
              return this;
          }
<span class="line-added">+ </span>
<span class="line-added">+         private List&lt;String&gt; toStringWithPrev(</span>
<span class="line-added">+                 Function&lt;VerifyItem,String&gt; toStr) {</span>
<span class="line-added">+             List&lt;String&gt; s = new ArrayList&lt;&gt;();</span>
<span class="line-added">+             if (prevVerify != null) {</span>
<span class="line-added">+                 s.addAll(prevVerify.toStringWithPrev(toStr));</span>
<span class="line-added">+             }</span>
<span class="line-added">+             s.add(toStr.apply(this));</span>
<span class="line-added">+             return s;</span>
<span class="line-added">+         }</span>
      }
  
      // The identifier for a specific signing.
      private static String signingId(SignItem signItem) {
          return signItem.signedJar;
      }
  
      // The identifier for a specific verifying.
      private static String verifyingId(SignItem signItem, VerifyItem verifyItem,
              boolean delayVerify) {
<span class="line-modified">!         return signingId(signItem) + (delayVerify ? &quot;-DV&quot; : &quot;-V&quot;)</span>
<span class="line-modified">!                 + &quot;_&quot; + verifyItem.jdkInfo.version +</span>
<span class="line-added">+                 (verifyItem.certInfo == null ? &quot;&quot; : &quot;_&quot; + verifyItem.certInfo);</span>
      }
  
      private static String reportRow(SignItem signItem, VerifyItem verifyItem) {
<span class="line-modified">!         List&lt;String&gt; values = new ArrayList&lt;&gt;();</span>
<span class="line-modified">!         Consumer&lt;Function&lt;SignItem, String&gt;&gt; s_values_add = f -&gt; {</span>
<span class="line-modified">!             values.add(String.join(&quot;&lt;br/&gt;&lt;br/&gt;&quot;, signItem.toStringWithPrev(f)));</span>
<span class="line-modified">!         };</span>
<span class="line-modified">!         Consumer&lt;Function&lt;VerifyItem, String&gt;&gt; v_values_add = f -&gt; {</span>
<span class="line-modified">!             values.add(String.join(&quot;&lt;br/&gt;&lt;br/&gt;&quot;, verifyItem.toStringWithPrev(f)));</span>
<span class="line-modified">!         };</span>
<span class="line-modified">!         s_values_add.accept(i -&gt; i.unsignedJar + &quot; -&gt; &quot; + i.signedJar);</span>
<span class="line-modified">!         s_values_add.accept(i -&gt; i.certInfo.toString());</span>
<span class="line-modified">!         s_values_add.accept(i -&gt; i.jdkInfo.version);</span>
<span class="line-modified">!         s_values_add.accept(i -&gt; i.certInfo.expectedSigalg());</span>
<span class="line-added">+         s_values_add.accept(i -&gt;</span>
<span class="line-added">+                 null2Default(i.digestAlgorithm, i.expectedDigestAlg()));</span>
<span class="line-added">+         s_values_add.accept(i -&gt; i.tsaIndex == -1 ? &quot;&quot; :</span>
<span class="line-added">+                 null2Default(i.tsaDigestAlgorithm, i.expectedTsaDigestAlg()));</span>
<span class="line-added">+         s_values_add.accept(i -&gt; i.tsaIndex == -1 ? &quot;&quot; : i.tsaIndex + &quot;&quot;);</span>
<span class="line-added">+         s_values_add.accept(i -&gt; HtmlHelper.anchorLink(</span>
                  PhaseOutputStream.fileName(PhaseOutputStream.Phase.SIGNING),
<span class="line-modified">!                 signingId(i),</span>
<span class="line-modified">!                 &quot;&quot; + i.status));</span>
          values.add(verifyItem.jdkInfo.version);
<span class="line-modified">!         v_values_add.accept(i -&gt;</span>
<span class="line-added">+                 i.certInfo == null ? &quot;no alias&quot; : &quot;&quot; + i.certInfo);</span>
<span class="line-added">+         v_values_add.accept(i -&gt; HtmlHelper.anchorLink(</span>
                  PhaseOutputStream.fileName(PhaseOutputStream.Phase.VERIFYING),
<span class="line-modified">!                 verifyingId(signItem, i, false),</span>
<span class="line-modified">!                 &quot;&quot; + i.status.toString()));</span>
          if (DELAY_VERIFY) {
<span class="line-modified">!             v_values_add.accept(i -&gt; HtmlHelper.anchorLink(</span>
                      PhaseOutputStream.fileName(
                              PhaseOutputStream.Phase.DELAY_VERIFYING),
                      verifyingId(signItem, verifyItem, true),
                      verifyItem.delayStatus.toString()));
          }
          values.add(isFailed(signItem, verifyItem) ? &quot;X&quot; : &quot;&quot;);
          return HtmlHelper.htmlRow(values.toArray(new String[values.size()]));
      }
  
<span class="line-modified">!     private static boolean isFailed(SignItem signItem, VerifyItem verifyItem) {</span>
<span class="line-modified">!         System.out.println(&quot;isFailed: signItem = &quot; + signItem + &quot;, verifyItem = &quot; + verifyItem);</span>
<span class="line-modified">!         // TODO: except known failing cases</span>
<span class="line-modified">! </span>
<span class="line-modified">!         // Note about isAtLeastMajorVersion in the following conditions:</span>
<span class="line-added">+         // signItem.jdkInfo is the jdk which signed the jar last and</span>
<span class="line-added">+         // signItem.prevSign.jdkInfo is the jdk which signed the jar first</span>
<span class="line-added">+         // assuming only two successive signatures as there actually are now.</span>
<span class="line-added">+         // the first signature always works and always has. subject here is</span>
<span class="line-added">+         // the update of an already signed jar. the following conditions always</span>
<span class="line-added">+         // depend on the second jdk that updated the jar with another signature</span>
<span class="line-added">+         // and the first one (signItem(.prevSign)+.jdkInfo) can be ignored.</span>
<span class="line-added">+         // this is different for verifyItem. verifyItem.prevVerify refers to</span>
<span class="line-added">+         // the first signature created by signItem(.prevSign)+.jdkInfo.</span>
<span class="line-added">+         // all verifyItem(.prevVerify)+.jdkInfo however point always to the same</span>
<span class="line-added">+         // jdk, only their certInfo is different. the same signatures are</span>
<span class="line-added">+         // verified with different jdks in different top-level VerifyItems</span>
<span class="line-added">+         // attached directly to signItem.verifyItems and not to</span>
<span class="line-added">+         // verifyItem.prevVerify.</span>
<span class="line-added">+ </span>
<span class="line-added">+         // ManifestDigester fails to parse manifests ending in &#39;\r&#39; with</span>
<span class="line-added">+         // IndexOutOfBoundsException at ManifestDigester.java:87 before 8217375</span>
<span class="line-added">+         if (signItem.signedJar.startsWith(&quot;eofr&quot;)</span>
<span class="line-added">+                 &amp;&amp; !signItem.jdkInfo.isAtLeastMajorVersion(13)</span>
<span class="line-added">+                 &amp;&amp; !verifyItem.jdkInfo.isAtLeastMajorVersion(13)) return false;</span>
<span class="line-added">+ </span>
<span class="line-added">+         // if there is no blank line after main attributes, JarSigner adds</span>
<span class="line-added">+         // individual sections nevertheless without being properly delimited</span>
<span class="line-added">+         // in JarSigner.java:777..790 without checking for blank line</span>
<span class="line-added">+         // before 8217375</span>
<span class="line-added">+ //        if (signItem.signedJar.startsWith(&quot;eofn-&quot;)</span>
<span class="line-added">+ //                &amp;&amp; signItem.signedJar.contains(&quot;-addfile-&quot;)</span>
<span class="line-added">+ //                &amp;&amp; !signItem.jdkInfo.isAtLeastMajorVersion(13)</span>
<span class="line-added">+ //                &amp;&amp; !verifyItem.jdkInfo.isAtLeastMajorVersion(13)) return false; // FIXME</span>
<span class="line-added">+ </span>
<span class="line-added">+ //        System.out.println(&quot;isFailed: signItem.isErrorInclPrev() &quot; + signItem.isErrorInclPrev());</span>
<span class="line-added">+ //        System.out.println(&quot;isFailed: verifyItem.isErrorInclPrev() &quot; + verifyItem.isErrorInclPrev());</span>
<span class="line-added">+         boolean isFailed = signItem.isErrorInclPrev() || verifyItem.isErrorInclPrev();</span>
<span class="line-added">+         System.out.println(&quot;isFailed: returning &quot; + isFailed);</span>
<span class="line-added">+         return isFailed;</span>
      }
  
      // If a value is null, then displays the default value or N/A.
      private static String null2Default(String value, String defaultValue) {
<span class="line-modified">!         return value != null ? value :</span>
<span class="line-modified">!                DEFAULT + &quot;(&quot; + (defaultValue == null</span>
                                    ? &quot;N/A&quot;
<span class="line-modified">!                                   : defaultValue) + &quot;)&quot;;</span>
      }
<span class="line-added">+ </span>
  }
</pre>
<center><a href="../Warning.java.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="DetailsOutputStream.java.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames test/jdk/jdk/internal/jimage/JImageReadTest.java</title>
    <link rel="stylesheet" href="../../../../../style.css" />
    <script type="text/javascript" src="../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
<a name="1" id="anc1"></a><span class="line-modified">  2  * Copyright (c) 2015, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 /*
 25  * @test
 26  * @summary Unit test for libjimage JIMAGE_Open/Read/Close
 27  * @modules java.base/jdk.internal.jimage
<a name="2" id="anc2"></a><span class="line-added"> 28  * @run testng JImageReadTest</span>
 29  */
 30 
 31 import java.io.File;
 32 import java.io.FileWriter;
 33 import java.io.IOException;
 34 import java.nio.ByteBuffer;
 35 import java.nio.ByteOrder;
 36 import java.nio.file.Files;
 37 import java.nio.file.Path;
 38 import java.nio.file.Paths;
 39 import java.util.Arrays;
 40 
 41 import jdk.internal.jimage.BasicImageReader;
 42 import jdk.internal.jimage.ImageReader;
 43 import jdk.internal.jimage.ImageLocation;
 44 
 45 import org.testng.annotations.DataProvider;
 46 import org.testng.annotations.Optional;
 47 import org.testng.annotations.Parameters;
 48 import org.testng.annotations.Test;
 49 import org.testng.Assert;
 50 import org.testng.TestNG;
 51 
 52 @Test
 53 public class JImageReadTest {
 54 
 55     static String javaHome = System.getProperty(&quot;java.home&quot;);
 56     static Path imageFile = Paths.get(javaHome, &quot;lib&quot;, &quot;modules&quot;);
 57 
 58     @DataProvider(name=&quot;classes&quot;)
 59     static Object[][] loadClasses() {
 60         return new Object[][] {
 61                 {&quot;java.base&quot;, &quot;java/lang/String.class&quot;},
 62                 {&quot;java.base&quot;, &quot;java/lang/Object.class&quot;},
 63                 {&quot;java.base&quot;, &quot;sun/reflect/generics/tree/TypeArgument.class&quot;},
 64                 {&quot;java.base&quot;, &quot;sun/net/www/content-types.properties&quot;},
 65                 {&quot;java.logging&quot;, &quot;java/util/logging/Logger.class&quot;},
 66                 {&quot;java.base&quot;, &quot;java/NOSUCHCLASS/yyy.class&quot;},    // non-existent
 67                 {&quot;NOSUCHMODULE&quot;, &quot;java/lang/Class.class&quot;},    // non-existent
 68         };
 69     }
 70 
 71     /**
 72      * Test a class is correctly accessible from the image in a module.
 73      *
 74      * @param moduleName the module name
 75      * @param className the classname
 76      * @throws Exception is thrown if there is a test error
 77      */
 78     @Test(dataProvider=&quot;classes&quot;)
 79     public static void test1_ReadClasses(String moduleName, String className) throws Exception {
 80         final int classMagic = 0xCAFEBABE;
 81 
 82         if (!Files.exists(imageFile)) {
 83             System.out.printf(&quot;Test skipped; no jimage file&quot;);
 84             return;
 85         }
 86 
 87         BasicImageReader reader = BasicImageReader.open(imageFile);
 88         Assert.assertTrue(reader != null, &quot;JIMAGE_Open failed: &quot; + imageFile);
 89 
 90         ImageLocation location = reader.findLocation(moduleName, className);
 91 
 92         if (location != null &amp;&amp; !location.verify(&quot;/&quot; + moduleName + &quot;/&quot; + className)) {
 93             location = null;
 94         }
 95 
 96         long size = location != null ? location.getUncompressedSize() : 0;
 97 
 98         System.out.printf(&quot;reading: module: %s, path: %s, size: %d%n&quot;,
 99                 moduleName, className, size);
100         if (moduleName.contains(&quot;NOSUCH&quot;) || className.contains(&quot;NOSUCH&quot;)) {
101             Assert.assertTrue(location == null,
102                     &quot;location found for non-existing module: &quot;
103                     + moduleName
104                     + &quot;, or class: &quot; + className);
105             return;         // no more to test for non-existing class
106         } else {
107             Assert.assertTrue(location != null, &quot;location not found: &quot; + className);
108             Assert.assertTrue(size &gt; 0, &quot;size of should be &gt; 0: &quot; + className);
109         }
110 
111         // positive: read whole class
112         ByteBuffer buffer = reader.getResourceBuffer(location);
113         Assert.assertTrue(buffer != null, &quot;bytes read not equal bytes requested&quot;);
114 
115         if (className.endsWith(&quot;.class&quot;)) {
116             int m = buffer.getInt();
117             Assert.assertEquals(m, classMagic, &quot;Classfile has bad magic number&quot;);
118         }
119 
120         reader.close();
121     }
122 
123     /**
124      * For all the resource names, check the name and approximate count.
125      *
126      * @throws IOException thrown if an error occurs
127      */
128     @Test
129     static void test2_ImageResources() throws IOException {
130         if (!Files.exists(imageFile)) {
131             System.out.printf(&quot;Test skipped; no jimage file&quot;);
132             return;
133         }
134 
135         BasicImageReader reader = BasicImageReader.open(imageFile);
136         Assert.assertTrue(reader != null, &quot;JIMAGE_Open failed: &quot; + imageFile);
137 
138         String[] names = reader.getEntryNames();
139 
140         // Repeat with count available
141         int count = names.length;
142 
143         System.out.printf(&quot; count: %d, a class: %s\n&quot;, count, names[0]);
144 
145         int minEntryCount = 16000;
146         Assert.assertTrue(minEntryCount &lt; count,
147                 &quot;unexpected count of entries, count: &quot; + count
148                         + &quot;, min: &quot; + minEntryCount);
149         for (int i = 0; i &lt; count; i++) {
150             checkFullName(names[i]);
151         }
152 
153         reader.close();
154     }
155 
156     static void checkFullName(String path) {
157         if (path.startsWith(&quot;/packages&quot;) || path.startsWith(&quot;/modules&quot;)) {
158             return;
159         }
160 
161         int next = 0;
162         String m = null;
163         String p = null;
164         String b = null;
165         String e = null;
166         if (path.startsWith(&quot;/&quot;)) {
167             next = path.indexOf(&#39;/&#39;, 1);
168             m = path.substring(1, next);
169             next = next + 1;
170         }
171         int lastSlash = path.lastIndexOf(&#39;/&#39;);
172         if (lastSlash &gt; next) {
173             // has a parent
174             p = path.substring(next, lastSlash);
175             next = lastSlash + 1;
176         }
177         int period = path.indexOf(&#39;.&#39;, next);
178         if (period &gt; next) {
179             b = path.substring(next, period);
180             e = path.substring(period + 1);
181         } else {
182             b = path.substring(next);
183         }
184         Assert.assertNotNull(m, &quot;module must be non-empty&quot;);
185         Assert.assertNotNull(b, &quot;base name must be non-empty&quot;);
186     }
187 
188     /**
189      * Verify that all of the resource names from BasicImageReader
190      * match those returned from the native JIMAGE_Resources iterator.
191      * Names that start with /modules, /packages, and bootmodules.jdata
192      * must appear in the names from JIMAGE_Resource iterator;
193      * from the BasicImageReader they are ignored.
194      */
195     @Test
196     static void test3_verifyNames() {
197         if (!Files.exists(imageFile)) {
198             System.out.printf(&quot;Test skipped; no jimage file&quot;);
199             return;
200         }
201 
202         try {
203             String[] names = BasicImageReader_Names();
204             //writeNames(&quot;/tmp/basic-names.txt&quot;, names);              // debug
205 
206             // Read all the names from the native JIMAGE API
207             String[] nativeNames = JIMAGE_Names();
208             //writeNames(&quot;/tmp/native-names.txt&quot;, nativeNames);       // debug
209 
210 
211             int modCount = 0;
212             int pkgCount = 0;
213             int otherCount = 0;
214             for (String n : nativeNames) {
215                 if (n.startsWith(&quot;/modules/&quot;)) {
216                     modCount++;
217                 } else if (n.startsWith(&quot;/packages/&quot;)) {
218                     pkgCount++;
219                 } else {
220                     otherCount++;
221                 }
222             }
223             System.out.printf(&quot;native name count: %d, modCount: %d, pkgCount: %d, otherCount: %d%n&quot;,
224                     names.length, modCount, pkgCount, otherCount);
225 
226             // Sort and merge the two arrays.  Every name should appear exactly twice.
227             Arrays.sort(names);
228             Arrays.sort(nativeNames);
229             String[] combined = Arrays.copyOf(names, nativeNames.length + names.length);
230             System.arraycopy(nativeNames,0, combined, names.length, nativeNames.length);
231             Arrays.sort(combined);
232             int missing = 0;
233             for (int i = 0; i &lt; combined.length; i++) {
234                 String s = combined[i];
235                 if (isMetaName(s)) {
236                     // Ignore /modules and /packages in BasicImageReader names
237                     continue;
238                 }
239 
240                 if (i &lt; combined.length - 1 &amp;&amp; s.equals(combined[i + 1])) {
241                     i++;        // string appears in both java and native
242                     continue;
243                 }
244 
245                 missing++;
246                 int ndx = Arrays.binarySearch(names, s);
247                 String which = (ndx &gt;= 0) ? &quot;java BasicImageReader&quot; : &quot;native JIMAGE_Resources&quot;;
248                 System.out.printf(&quot;Missing Resource: %s found only via %s%n&quot;, s, which);
249             }
250             Assert.assertEquals(missing, 0, &quot;Resources missing&quot;);
251 
252         } catch (IOException ioe) {
253             Assert.fail(&quot;I/O exception&quot;, ioe);
254         }
255     }
256 
257     /**
258      * Return true if the name is one of the meta-data names
259      * @param name a name
260      * @return return true if starts with either /packages or /modules
261      */
262     static boolean isMetaName(String name) {
263         return name.startsWith(&quot;/modules&quot;)
264                 || name.startsWith(&quot;/packages&quot;)
265                 || name.startsWith(&quot;META-INF&quot;)
266                 || name.equals(&quot;bootmodules.jdata&quot;);
267     }
268 
269     /**
270      * Return all of the names from BasicImageReader.
271      * @return the names returned from BasicImageReader
272      */
273     static String[] BasicImageReader_Names() throws IOException {
274         String[] names = null;
275         try (BasicImageReader reader = BasicImageReader.open(imageFile)) {
276             names = reader.getEntryNames();
277         } catch (IOException ioe) {
278             Assert.fail(&quot;I/O exception&quot;, ioe);
279         }
280         return names;
281     }
282 
283     /**
284      * Returns an array of all of the names returned from JIMAGE_Resources
285      */
286     static String[] JIMAGE_Names() throws IOException {
287 
288         BasicImageReader reader = BasicImageReader.open(imageFile);
289         Assert.assertNotNull(reader, &quot;JIMAGE_Open failed: &quot; + imageFile);
290 
291         String[] names = reader.getEntryNames();
292 
293         reader.close();
294 
295         return names;
296     }
297 
298     // Write an array of names to a file for debugging
299     static void writeNames(String fname, String[] names) throws IOException {
300         try (FileWriter wr = new FileWriter(new File(fname))) {
301             for (String s : names) {
302                 wr.write(s);
303                 wr.write(&quot;\n&quot;);
304             }
305 
306         }
307         System.out.printf(&quot; %s: %d names%n&quot;, fname, names.length);
308     }
309 
310     //@Test
311     static void test4_nameTooLong() throws IOException {
312         long[] size = new long[1];
313         String moduleName = &quot;FictiousModuleName&quot;;
314         String className = String.format(&quot;A%09999d&quot;, 1);
315 
316         BasicImageReader reader = BasicImageReader.open(imageFile);
317         Assert.assertNotNull(reader, &quot;JIMAGE_Open failed: &quot; + imageFile);
318 
319         String name = &quot;/&quot; + moduleName + &quot;/&quot; + className;
320         ImageLocation location = reader.findLocation(name);
321 
322         if (location != null &amp;&amp; !location.verify(name)) {
323             location = null;
324         }
325         Assert.assertTrue(location == null, &quot;Too long name should have failed&quot;);
326 
327         reader.close();
328     }
329 
330     /**
331      * Verify that the ImageReader returned by ImageReader.open has the
332      * the requested endianness or fails with an IOException if not.
333      */
334     @Test
335     static void test5_imageReaderEndianness() throws IOException {
336         ImageReader nativeReader = ImageReader.open(imageFile);
337         Assert.assertEquals(nativeReader.getByteOrder(), ByteOrder.nativeOrder());
338 
339         try {
340             ImageReader leReader = ImageReader.open(imageFile, ByteOrder.LITTLE_ENDIAN);
341             Assert.assertEquals(leReader.getByteOrder(), ByteOrder.LITTLE_ENDIAN);
342             leReader.close();
343         } catch (IOException io) {
344             // IOException expected if LITTLE_ENDIAN not the nativeOrder()
345             Assert.assertNotEquals(ByteOrder.nativeOrder(), ByteOrder.LITTLE_ENDIAN);
346         }
347 
348         try {
349             ImageReader beReader = ImageReader.open(imageFile, ByteOrder.BIG_ENDIAN);
350             Assert.assertEquals(beReader.getByteOrder(), ByteOrder.BIG_ENDIAN);
351             beReader.close();
352         } catch (IOException io) {
353             // IOException expected if LITTLE_ENDIAN not the nativeOrder()
354             Assert.assertNotEquals(ByteOrder.nativeOrder(), ByteOrder.BIG_ENDIAN);
355         }
356 
357         nativeReader.close();
358     }
359     // main method to run standalone from jtreg
360 
361     @Test(enabled=false)
362     @Parameters({&quot;x&quot;})
363     @SuppressWarnings(&quot;raw_types&quot;)
364     public static void main(@Optional String[] args) {
365         Class&lt;?&gt;[] testclass = { JImageReadTest.class};
366         TestNG testng = new TestNG();
367         testng.setTestClasses(testclass);
368         testng.run();
369     }
370 
371 }
<a name="3" id="anc3"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="3" type="hidden" />
</body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames test/jdk/jdk/internal/jimage/JImageReadTest.java</title>
    <link rel="stylesheet" href="../../../../../style.css" />
    <script type="text/javascript" src="../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
<a name="1" id="anc1"></a><span class="line-modified">  2  * Copyright (c) 2015, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 /*
 25  * @test
 26  * @summary Unit test for libjimage JIMAGE_Open/Read/Close
 27  * @modules java.base/jdk.internal.jimage
<a name="2" id="anc2"></a>
 28  */
 29 
 30 import java.io.File;
 31 import java.io.FileWriter;
 32 import java.io.IOException;
 33 import java.nio.ByteBuffer;
 34 import java.nio.ByteOrder;
 35 import java.nio.file.Files;
 36 import java.nio.file.Path;
 37 import java.nio.file.Paths;
 38 import java.util.Arrays;
 39 
 40 import jdk.internal.jimage.BasicImageReader;
 41 import jdk.internal.jimage.ImageReader;
 42 import jdk.internal.jimage.ImageLocation;
 43 
 44 import org.testng.annotations.DataProvider;
 45 import org.testng.annotations.Optional;
 46 import org.testng.annotations.Parameters;
 47 import org.testng.annotations.Test;
 48 import org.testng.Assert;
 49 import org.testng.TestNG;
 50 
 51 @Test
 52 public class JImageReadTest {
 53 
 54     static String javaHome = System.getProperty(&quot;java.home&quot;);
 55     static Path imageFile = Paths.get(javaHome, &quot;lib&quot;, &quot;modules&quot;);
 56 
 57     @DataProvider(name=&quot;classes&quot;)
 58     static Object[][] loadClasses() {
 59         return new Object[][] {
 60                 {&quot;java.base&quot;, &quot;java/lang/String.class&quot;},
 61                 {&quot;java.base&quot;, &quot;java/lang/Object.class&quot;},
 62                 {&quot;java.base&quot;, &quot;sun/reflect/generics/tree/TypeArgument.class&quot;},
 63                 {&quot;java.base&quot;, &quot;sun/net/www/content-types.properties&quot;},
 64                 {&quot;java.logging&quot;, &quot;java/util/logging/Logger.class&quot;},
 65                 {&quot;java.base&quot;, &quot;java/NOSUCHCLASS/yyy.class&quot;},    // non-existent
 66                 {&quot;NOSUCHMODULE&quot;, &quot;java/lang/Class.class&quot;},    // non-existent
 67         };
 68     }
 69 
 70     /**
 71      * Test a class is correctly accessible from the image in a module.
 72      *
 73      * @param moduleName the module name
 74      * @param className the classname
 75      * @throws Exception is thrown if there is a test error
 76      */
 77     @Test(dataProvider=&quot;classes&quot;)
 78     public static void test1_ReadClasses(String moduleName, String className) throws Exception {
 79         final int classMagic = 0xCAFEBABE;
 80 
 81         if (!Files.exists(imageFile)) {
 82             System.out.printf(&quot;Test skipped; no jimage file&quot;);
 83             return;
 84         }
 85 
 86         BasicImageReader reader = BasicImageReader.open(imageFile);
 87         Assert.assertTrue(reader != null, &quot;JIMAGE_Open failed: &quot; + imageFile);
 88 
 89         ImageLocation location = reader.findLocation(moduleName, className);
 90 
 91         if (location != null &amp;&amp; !location.verify(&quot;/&quot; + moduleName + &quot;/&quot; + className)) {
 92             location = null;
 93         }
 94 
 95         long size = location != null ? location.getUncompressedSize() : 0;
 96 
 97         System.out.printf(&quot;reading: module: %s, path: %s, size: %d%n&quot;,
 98                 moduleName, className, size);
 99         if (moduleName.contains(&quot;NOSUCH&quot;) || className.contains(&quot;NOSUCH&quot;)) {
100             Assert.assertTrue(location == null,
101                     &quot;location found for non-existing module: &quot;
102                     + moduleName
103                     + &quot;, or class: &quot; + className);
104             return;         // no more to test for non-existing class
105         } else {
106             Assert.assertTrue(location != null, &quot;location not found: &quot; + className);
107             Assert.assertTrue(size &gt; 0, &quot;size of should be &gt; 0: &quot; + className);
108         }
109 
110         // positive: read whole class
111         ByteBuffer buffer = reader.getResourceBuffer(location);
112         Assert.assertTrue(buffer != null, &quot;bytes read not equal bytes requested&quot;);
113 
114         if (className.endsWith(&quot;.class&quot;)) {
115             int m = buffer.getInt();
116             Assert.assertEquals(m, classMagic, &quot;Classfile has bad magic number&quot;);
117         }
118 
119         reader.close();
120     }
121 
122     /**
123      * For all the resource names, check the name and approximate count.
124      *
125      * @throws IOException thrown if an error occurs
126      */
127     @Test
128     static void test2_ImageResources() throws IOException {
129         if (!Files.exists(imageFile)) {
130             System.out.printf(&quot;Test skipped; no jimage file&quot;);
131             return;
132         }
133 
134         BasicImageReader reader = BasicImageReader.open(imageFile);
135         Assert.assertTrue(reader != null, &quot;JIMAGE_Open failed: &quot; + imageFile);
136 
137         String[] names = reader.getEntryNames();
138 
139         // Repeat with count available
140         int count = names.length;
141 
142         System.out.printf(&quot; count: %d, a class: %s\n&quot;, count, names[0]);
143 
144         int minEntryCount = 16000;
145         Assert.assertTrue(minEntryCount &lt; count,
146                 &quot;unexpected count of entries, count: &quot; + count
147                         + &quot;, min: &quot; + minEntryCount);
148         for (int i = 0; i &lt; count; i++) {
149             checkFullName(names[i]);
150         }
151 
152         reader.close();
153     }
154 
155     static void checkFullName(String path) {
156         if (path.startsWith(&quot;/packages&quot;) || path.startsWith(&quot;/modules&quot;)) {
157             return;
158         }
159 
160         int next = 0;
161         String m = null;
162         String p = null;
163         String b = null;
164         String e = null;
165         if (path.startsWith(&quot;/&quot;)) {
166             next = path.indexOf(&#39;/&#39;, 1);
167             m = path.substring(1, next);
168             next = next + 1;
169         }
170         int lastSlash = path.lastIndexOf(&#39;/&#39;);
171         if (lastSlash &gt; next) {
172             // has a parent
173             p = path.substring(next, lastSlash);
174             next = lastSlash + 1;
175         }
176         int period = path.indexOf(&#39;.&#39;, next);
177         if (period &gt; next) {
178             b = path.substring(next, period);
179             e = path.substring(period + 1);
180         } else {
181             b = path.substring(next);
182         }
183         Assert.assertNotNull(m, &quot;module must be non-empty&quot;);
184         Assert.assertNotNull(b, &quot;base name must be non-empty&quot;);
185     }
186 
187     /**
188      * Verify that all of the resource names from BasicImageReader
189      * match those returned from the native JIMAGE_Resources iterator.
190      * Names that start with /modules, /packages, and bootmodules.jdata
191      * must appear in the names from JIMAGE_Resource iterator;
192      * from the BasicImageReader they are ignored.
193      */
194     @Test
195     static void test3_verifyNames() {
196         if (!Files.exists(imageFile)) {
197             System.out.printf(&quot;Test skipped; no jimage file&quot;);
198             return;
199         }
200 
201         try {
202             String[] names = BasicImageReader_Names();
203             //writeNames(&quot;/tmp/basic-names.txt&quot;, names);              // debug
204 
205             // Read all the names from the native JIMAGE API
206             String[] nativeNames = JIMAGE_Names();
207             //writeNames(&quot;/tmp/native-names.txt&quot;, nativeNames);       // debug
208 
209 
210             int modCount = 0;
211             int pkgCount = 0;
212             int otherCount = 0;
213             for (String n : nativeNames) {
214                 if (n.startsWith(&quot;/modules/&quot;)) {
215                     modCount++;
216                 } else if (n.startsWith(&quot;/packages/&quot;)) {
217                     pkgCount++;
218                 } else {
219                     otherCount++;
220                 }
221             }
222             System.out.printf(&quot;native name count: %d, modCount: %d, pkgCount: %d, otherCount: %d%n&quot;,
223                     names.length, modCount, pkgCount, otherCount);
224 
225             // Sort and merge the two arrays.  Every name should appear exactly twice.
226             Arrays.sort(names);
227             Arrays.sort(nativeNames);
228             String[] combined = Arrays.copyOf(names, nativeNames.length + names.length);
229             System.arraycopy(nativeNames,0, combined, names.length, nativeNames.length);
230             Arrays.sort(combined);
231             int missing = 0;
232             for (int i = 0; i &lt; combined.length; i++) {
233                 String s = combined[i];
234                 if (isMetaName(s)) {
235                     // Ignore /modules and /packages in BasicImageReader names
236                     continue;
237                 }
238 
239                 if (i &lt; combined.length - 1 &amp;&amp; s.equals(combined[i + 1])) {
240                     i++;        // string appears in both java and native
241                     continue;
242                 }
243 
244                 missing++;
245                 int ndx = Arrays.binarySearch(names, s);
246                 String which = (ndx &gt;= 0) ? &quot;java BasicImageReader&quot; : &quot;native JIMAGE_Resources&quot;;
247                 System.out.printf(&quot;Missing Resource: %s found only via %s%n&quot;, s, which);
248             }
249             Assert.assertEquals(missing, 0, &quot;Resources missing&quot;);
250 
251         } catch (IOException ioe) {
252             Assert.fail(&quot;I/O exception&quot;, ioe);
253         }
254     }
255 
256     /**
257      * Return true if the name is one of the meta-data names
258      * @param name a name
259      * @return return true if starts with either /packages or /modules
260      */
261     static boolean isMetaName(String name) {
262         return name.startsWith(&quot;/modules&quot;)
263                 || name.startsWith(&quot;/packages&quot;)
264                 || name.startsWith(&quot;META-INF&quot;)
265                 || name.equals(&quot;bootmodules.jdata&quot;);
266     }
267 
268     /**
269      * Return all of the names from BasicImageReader.
270      * @return the names returned from BasicImageReader
271      */
272     static String[] BasicImageReader_Names() throws IOException {
273         String[] names = null;
274         try (BasicImageReader reader = BasicImageReader.open(imageFile)) {
275             names = reader.getEntryNames();
276         } catch (IOException ioe) {
277             Assert.fail(&quot;I/O exception&quot;, ioe);
278         }
279         return names;
280     }
281 
282     /**
283      * Returns an array of all of the names returned from JIMAGE_Resources
284      */
285     static String[] JIMAGE_Names() throws IOException {
286 
287         BasicImageReader reader = BasicImageReader.open(imageFile);
288         Assert.assertNotNull(reader, &quot;JIMAGE_Open failed: &quot; + imageFile);
289 
290         String[] names = reader.getEntryNames();
291 
292         reader.close();
293 
294         return names;
295     }
296 
297     // Write an array of names to a file for debugging
298     static void writeNames(String fname, String[] names) throws IOException {
299         try (FileWriter wr = new FileWriter(new File(fname))) {
300             for (String s : names) {
301                 wr.write(s);
302                 wr.write(&quot;\n&quot;);
303             }
304 
305         }
306         System.out.printf(&quot; %s: %d names%n&quot;, fname, names.length);
307     }
308 
309     //@Test
310     static void test4_nameTooLong() throws IOException {
311         long[] size = new long[1];
312         String moduleName = &quot;FictiousModuleName&quot;;
313         String className = String.format(&quot;A%09999d&quot;, 1);
314 
315         BasicImageReader reader = BasicImageReader.open(imageFile);
316         Assert.assertNotNull(reader, &quot;JIMAGE_Open failed: &quot; + imageFile);
317 
318         String name = &quot;/&quot; + moduleName + &quot;/&quot; + className;
319         ImageLocation location = reader.findLocation(name);
320 
321         if (location != null &amp;&amp; !location.verify(name)) {
322             location = null;
323         }
324         Assert.assertTrue(location == null, &quot;Too long name should have failed&quot;);
325 
326         reader.close();
327     }
328 
329     /**
330      * Verify that the ImageReader returned by ImageReader.open has the
331      * the requested endianness or fails with an IOException if not.
332      */
333     @Test
334     static void test5_imageReaderEndianness() throws IOException {
335         ImageReader nativeReader = ImageReader.open(imageFile);
336         Assert.assertEquals(nativeReader.getByteOrder(), ByteOrder.nativeOrder());
337 
338         try {
339             ImageReader leReader = ImageReader.open(imageFile, ByteOrder.LITTLE_ENDIAN);
340             Assert.assertEquals(leReader.getByteOrder(), ByteOrder.LITTLE_ENDIAN);
341             leReader.close();
342         } catch (IOException io) {
343             // IOException expected if LITTLE_ENDIAN not the nativeOrder()
344             Assert.assertNotEquals(ByteOrder.nativeOrder(), ByteOrder.LITTLE_ENDIAN);
345         }
346 
347         try {
348             ImageReader beReader = ImageReader.open(imageFile, ByteOrder.BIG_ENDIAN);
349             Assert.assertEquals(beReader.getByteOrder(), ByteOrder.BIG_ENDIAN);
350             beReader.close();
351         } catch (IOException io) {
352             // IOException expected if LITTLE_ENDIAN not the nativeOrder()
353             Assert.assertNotEquals(ByteOrder.nativeOrder(), ByteOrder.BIG_ENDIAN);
354         }
355 
356         nativeReader.close();
357     }
358     // main method to run standalone from jtreg
359 
360     @Test(enabled=false)
361     @Parameters({&quot;x&quot;})
362     @SuppressWarnings(&quot;raw_types&quot;)
363     public static void main(@Optional String[] args) {
364         Class&lt;?&gt;[] testclass = { JImageReadTest.class};
365         TestNG testng = new TestNG();
366         testng.setTestClasses(testclass);
367         testng.run();
368     }
369 
370 }
<a name="3" id="anc3"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="3" type="hidden" />
</body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old test/jdk/jdk/internal/jrtfs/Basic.java</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2014, 2018, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 /*
 25  * @test
 26  * @summary Basic test of jrt file system provider
 27  * @run testng Basic
 28  */
 29 
 30 import java.io.InputStream;
 31 import java.io.IOException;
 32 import java.io.DataInputStream;
 33 import java.nio.file.DirectoryStream;
 34 import java.nio.file.InvalidPathException;
 35 import java.nio.file.Files;
 36 import java.nio.file.FileSystem;
 37 import java.nio.file.FileSystems;
 38 import java.nio.file.Path;
 39 import java.nio.file.PathMatcher;
 40 import java.nio.file.Paths;
 41 import java.net.URI;
 42 import java.util.Collections;
 43 import java.util.HashMap;
 44 import java.util.Iterator;
 45 import java.util.Map;
 46 import java.util.NoSuchElementException;
 47 import java.util.stream.Stream;
 48 
 49 import org.testng.annotations.AfterClass;
 50 import org.testng.annotations.BeforeClass;
 51 import org.testng.annotations.DataProvider;
 52 import org.testng.annotations.Test;
 53 
 54 import static org.testng.Assert.assertEquals;
 55 import static org.testng.Assert.assertNotEquals;
 56 import static org.testng.Assert.assertNotNull;
 57 import static org.testng.Assert.assertTrue;
 58 import static org.testng.Assert.assertFalse;
 59 
 60 /**
 61  * Basic tests for jrt:/ file system provider.
 62  */
 63 
 64 public class Basic {
 65 
 66     private FileSystem theFileSystem;
 67     private FileSystem fs;
 68     private boolean isExplodedBuild = false;
 69 
 70     @BeforeClass
 71     public void setup() {
 72         theFileSystem = FileSystems.getFileSystem(URI.create(&quot;jrt:/&quot;));
 73         Path modulesPath = Paths.get(System.getProperty(&quot;java.home&quot;),
 74                 &quot;lib&quot;, &quot;modules&quot;);
 75         isExplodedBuild = Files.notExists(modulesPath);
 76         if (isExplodedBuild) {
 77             System.out.printf(&quot;%s doesn&#39;t exist.&quot;, modulesPath.toString());
 78             System.out.println();
 79             System.out.println(&quot;It is most probably an exploded build.&quot;
 80                     + &quot; Skip non-default FileSystem testing.&quot;);
 81             return;
 82         }
 83 
 84         Map&lt;String, String&gt; env = new HashMap&lt;&gt;();
 85         // set java.home property to be underlying java.home
 86         // so that jrt-fs.jar loading is exercised.
 87         env.put(&quot;java.home&quot;, System.getProperty(&quot;java.home&quot;));
 88         try {
 89             fs = FileSystems.newFileSystem(URI.create(&quot;jrt:/&quot;), env);
 90         } catch (IOException ioExp) {
 91             throw new RuntimeException(ioExp);
 92         }
 93     }
 94 
 95     @AfterClass
 96     public void tearDown() {
 97         try {
 98             fs.close();
 99         } catch (Exception ignored) {}
100     }
101 
102     private FileSystem selectFileSystem(boolean theDefault) {
103         return theDefault? theFileSystem : fs;
104     }
105 
106     // Checks that the given FileSystem is a jrt file system.
107     private void checkFileSystem(FileSystem fs) {
108         assertTrue(fs.provider().getScheme().equalsIgnoreCase(&quot;jrt&quot;));
109         assertTrue(fs.isOpen());
110         assertTrue(fs.isReadOnly());
111         assertEquals(fs.getSeparator(), &quot;/&quot;);
112 
113         // one root
114         Iterator&lt;Path&gt; roots = fs.getRootDirectories().iterator();
115         assertTrue(roots.next().toString().equals(&quot;/&quot;));
116         assertFalse(roots.hasNext());
117     }
118 
119     @Test
120     public void testGetFileSystem() {
121         FileSystem fs = FileSystems.getFileSystem(URI.create(&quot;jrt:/&quot;));
122         checkFileSystem(fs);
123 
124         // getFileSystem should return the same object each time
125         assertTrue(fs == FileSystems.getFileSystem(URI.create(&quot;jrt:/&quot;)));
126     }
127 
128     @Test(expectedExceptions = UnsupportedOperationException.class)
129     public void testCloseFileSystem() throws Exception {
130         FileSystem fs = FileSystems.getFileSystem(URI.create(&quot;jrt:/&quot;));
131         fs.close(); // should throw UOE
132     }
133 
134     @Test
135     public void testNewFileSystem() throws Exception {
136         FileSystem theFileSystem = FileSystems.getFileSystem(URI.create(&quot;jrt:/&quot;));
137         Map&lt;String, ?&gt; env = Collections.emptyMap();
138         try (FileSystem fs = FileSystems.newFileSystem(URI.create(&quot;jrt:/&quot;), env)) {
139             checkFileSystem(fs);
140             assertTrue(fs != theFileSystem);
141         }
142     }
143 
144     @Test
145     public void testNewFileSystemWithJavaHome() throws Exception {
146         if (isExplodedBuild) {
147             System.out.println(&quot;Skip testNewFileSystemWithJavaHome&quot;
148                     + &quot; since this is an exploded build&quot;);
149             return;
150         }
151 
152         Map&lt;String, String&gt; env = new HashMap&lt;&gt;();
153         // set java.home property to be underlying java.home
154         // so that jrt-fs.jar loading is exercised.
155         env.put(&quot;java.home&quot;, System.getProperty(&quot;java.home&quot;));
156         try (FileSystem fs = FileSystems.newFileSystem(URI.create(&quot;jrt:/&quot;), env)) {
157             checkFileSystem(fs);
158             // jrt-fs.jar classes are loaded by another (non-boot) loader in this case
159             assertNotNull(fs.provider().getClass().getClassLoader());
160         }
161     }
162 
163     @DataProvider(name = &quot;knownClassFiles&quot;)
164     private Object[][] knownClassFiles() {
165         return new Object[][] {
166             { &quot;/modules/java.base/java/lang/Object.class&quot;, true },
167             { &quot;modules/java.base/java/lang/Object.class&quot;, true },
168             { &quot;/modules/java.base/java/lang/Object.class&quot;, false },
169             { &quot;modules/java.base/java/lang/Object.class&quot;, false },
170         };
171     }
172 
173     @Test(dataProvider = &quot;knownClassFiles&quot;)
174     public void testKnownClassFiles(String path, boolean theDefault) throws Exception {
175         if (isExplodedBuild &amp;&amp; !theDefault) {
176             System.out.println(&quot;Skip testKnownClassFiles with non-default FileSystem&quot;);
177             return;
178         }
179 
180         FileSystem fs = selectFileSystem(theDefault);
181         Path classFile = fs.getPath(path);
182 
183         assertTrue(Files.isRegularFile(classFile));
184         assertTrue(Files.size(classFile) &gt; 0L);
185 
186         // check magic number
187         try (InputStream in = Files.newInputStream(classFile)) {
188             int magic = new DataInputStream(in).readInt();
189             assertEquals(magic, 0xCAFEBABE);
190         }
191     }
192 
193     @DataProvider(name = &quot;knownDirectories&quot;)
194     private Object[][] knownDirectories() {
195         return new Object[][] {
196             { &quot;/&quot;, true                     },
197             { &quot;.&quot; , true                    },
198             { &quot;./&quot;, true                    },
199             { &quot;/.&quot;, true                    },
200             { &quot;/./&quot;, true                   },
201             { &quot;/modules/java.base/..&quot;, true         },
202             { &quot;/modules/java.base/../&quot;, true        },
203             { &quot;/modules/java.base/../.&quot;, true       },
204             { &quot;/modules/java.base&quot;, true            },
205             { &quot;/modules/java.base/java/lang&quot;, true  },
206             { &quot;modules/java.base/java/lang&quot;, true   },
207             { &quot;/modules/java.base/java/lang/&quot;, true },
208             { &quot;modules/java.base/java/lang/&quot;, true  },
209             { &quot;/&quot;, false                     },
210             { &quot;.&quot; , false                    },
211             { &quot;./&quot;, false                    },
212             { &quot;/.&quot;, false                    },
213             { &quot;/./&quot;, false                   },
214             { &quot;/modules/java.base/..&quot;, false         },
215             { &quot;/modules/java.base/../&quot;, false        },
216             { &quot;/modules/java.base/../.&quot;, false       },
217             { &quot;/modules/java.base&quot;, false            },
218             { &quot;/modules/java.base/java/lang&quot;, false  },
219             { &quot;modules/java.base/java/lang&quot;, false   },
220             { &quot;/modules/java.base/java/lang/&quot;, false },
221             { &quot;modules/java.base/java/lang/&quot;, false  },
222         };
223     }
224 
225     @Test(dataProvider = &quot;knownDirectories&quot;)
226     public void testKnownDirectories(String path, boolean theDefault) throws Exception {
227         if (isExplodedBuild &amp;&amp; !theDefault) {
228             System.out.println(&quot;Skip testKnownDirectories with non-default FileSystem&quot;);
229             return;
230         }
231 
232         FileSystem fs = selectFileSystem(theDefault);
233         Path dir = fs.getPath(path);
234 
235         assertTrue(Files.isDirectory(dir));
236 
237         // directory should not be empty
238         try (Stream&lt;Path&gt; stream = Files.list(dir)) {
239             assertTrue(stream.count() &gt; 0L);
240         }
241         try (Stream&lt;Path&gt; stream = Files.walk(dir)) {
242             assertTrue(stream.count() &gt; 0L);
243         }
244     }
245 
246     @DataProvider(name = &quot;topLevelPkgDirs&quot;)
247     private Object[][] topLevelPkgDirs() {
248         return new Object[][] {
249             { &quot;/java/lang&quot; },
250             { &quot;java/lang&quot;  },
251             { &quot;/java/util&quot; },
252             { &quot;java/util&quot;  },
253         };
254     }
255 
256     @Test(dataProvider = &quot;topLevelPkgDirs&quot;)
257     public void testNotExists(String path) throws Exception {
258         FileSystem fs = FileSystems.getFileSystem(URI.create(&quot;jrt:/&quot;));
259         Path dir = fs.getPath(path);
260 
261         // package directories should not be there at top level
262         assertTrue(Files.notExists(dir));
263     }
264 
265     /**
266      * Test the URI of every file in the jrt file system
267      */
268     @Test
269     public void testToAndFromUri() throws Exception {
270         FileSystem fs = FileSystems.getFileSystem(URI.create(&quot;jrt:/&quot;));
271         Path top = fs.getPath(&quot;/&quot;);
272         try (Stream&lt;Path&gt; stream = Files.walk(top)) {
273             stream.forEach(path -&gt; {
274                 URI u = path.toUri();
275                 assertTrue(u.getScheme().equalsIgnoreCase(&quot;jrt&quot;));
276                 assertFalse(u.isOpaque());
277                 assertTrue(u.getAuthority() == null);
278                 assertEquals(u.getPath(), path.toAbsolutePath().toString());
279                 Path p = Paths.get(u);
280                 assertEquals(p, path);
281             });
282         }
283     }
284 
285     @Test
286     public void testDirectoryNames() throws Exception {
287         FileSystem fs = FileSystems.getFileSystem(URI.create(&quot;jrt:/&quot;));
288         Path top = fs.getPath(&quot;/&quot;);
289         // check that directory names do not have trailing &#39;/&#39; char
290         try (Stream&lt;Path&gt; stream = Files.walk(top)) {
291             stream.skip(1).filter(Files::isDirectory).forEach(path -&gt; {
292                 assertFalse(path.toString().endsWith(&quot;/&quot;));
293             });
294         }
295     }
296 
297     @DataProvider(name = &quot;pathPrefixs&quot;)
298     private Object[][] pathPrefixes() {
299         return new Object[][] {
300             { &quot;/&quot;                       },
301             { &quot;modules/java.base/java/lang&quot;     },
302             { &quot;./modules/java.base/java/lang&quot;   },
303             { &quot;/modules/java.base/java/lang&quot;    },
304             { &quot;/./modules/java.base/java/lang&quot;  },
305             { &quot;modules/java.base/java/lang/&quot;    },
306             { &quot;./modules/java.base/java/lang/&quot;  },
307             { &quot;/./modules/java.base/java/lang/&quot; },
308         };
309     }
310 
311     // @Test(dataProvider = &quot;pathPrefixes&quot;)
312     public void testParentInDirList(String dir) throws Exception {
313         FileSystem fs = FileSystems.getFileSystem(URI.create(&quot;jrt:/&quot;));
314         Path base = fs.getPath(dir);
315         try (DirectoryStream&lt;Path&gt; stream = Files.newDirectoryStream(base)) {
316             for (Path entry: stream) {
317                 assertTrue( entry.getParent().equals(base),
318                     base.toString() + &quot;-&gt; &quot; + entry.toString() );
319             }
320         }
321     }
322 
323     @DataProvider(name = &quot;dirStreamStringFilterData&quot;)
324     private Object[][] dirStreamStringFilterData() {
325         return new Object[][] {
326             { &quot;/modules/java.base/java/lang&quot;, &quot;/reflect&quot;      },
327             { &quot;/modules/java.base/java/lang&quot;, &quot;/Object.class&quot; },
328             { &quot;/modules/java.base/java/util&quot;, &quot;/stream&quot;       },
329             { &quot;/modules/java.base/java/util&quot;, &quot;/List.class&quot;   },
330         };
331     }
332 
333     @Test(dataProvider = &quot;dirStreamStringFilterData&quot;)
334     public void testDirectoryStreamStringFilter(String dir, String filter) throws Exception {
335         FileSystem fs = FileSystems.getFileSystem(URI.create(&quot;jrt:/&quot;));
336         Path base = fs.getPath(dir);
337         try (DirectoryStream&lt;Path&gt; stream =
338                 Files.newDirectoryStream(base, p-&gt;!p.toString().endsWith(filter))) {
339             for (Path entry: stream) {
340                 assertFalse(entry.toString().contains(filter),
341                     &quot;filtered path seen: &quot; + filter);
342             }
343         }
344 
345         // make sure without filter, we do see that matching entry!
346         boolean seen = false;
347         try (DirectoryStream&lt;Path&gt; stream = Files.newDirectoryStream(base)) {
348             for (Path entry: stream) {
349                 if (entry.toString().endsWith(filter)) {
350                     seen = true;
351                     break;
352                 }
353             }
354         }
355 
356         assertTrue(seen, &quot;even without filter &quot; + filter + &quot; is missing&quot;);
357     }
358 
359     @DataProvider(name = &quot;dirStreamFilterData&quot;)
360     private Object[][] dirStreamFilterData() {
361         return new Object[][] {
362             {
363               &quot;/&quot;,
364               (DirectoryStream.Filter&lt;Path&gt;)(Files::isDirectory),
365               &quot;isDirectory&quot;
366             },
367             {
368               &quot;/modules/java.base/java/lang&quot;,
369               (DirectoryStream.Filter&lt;Path&gt;)(Files::isRegularFile),
370               &quot;isFile&quot;
371             }
372         };
373     }
374 
375     @Test(dataProvider = &quot;dirStreamFilterData&quot;)
376     private void testDirectoryStreamFilter(String dir, DirectoryStream.Filter filter,
377             String name) throws Exception {
378         FileSystem fs = FileSystems.getFileSystem(URI.create(&quot;jrt:/&quot;));
379         Path base = fs.getPath(dir);
380         try (DirectoryStream&lt;Path&gt; stream = Files.newDirectoryStream(base, filter)) {
381             for (Path entry: stream) {
382                 assertTrue(filter.accept(entry), &quot;filtered path seen: &quot; + name);
383             }
384         }
385 
386         // make sure without filter, we do see that matching entry!
387         boolean seen = false;
388         try (DirectoryStream&lt;Path&gt; stream = Files.newDirectoryStream(base)) {
389             for (Path entry: stream) {
390                 if (filter.accept(entry)) {
391                     seen = true;
392                     break;
393                 }
394             }
395         }
396 
397         assertTrue(seen, &quot;even without filter &quot; + name + &quot; is missing&quot;);
398     }
399 
400     @Test
401     private void testDirectoryStreamIterator() throws Exception {
402         // run the tests with null filter (no filter)
403         dirStreamIteratorTest(null);
404         // run the same tests with trivial &quot;accept all&quot; filter
405         dirStreamIteratorTest(p-&gt;true);
406         // two other non-trivial ones
407         dirStreamIteratorTest(Files::isDirectory);
408         dirStreamIteratorTest(Files::isRegularFile);
409     }
410 
411     private void dirStreamIteratorTest(DirectoryStream.Filter&lt;Path&gt; filter)
412             throws Exception {
413         FileSystem fs = FileSystems.getFileSystem(URI.create(&quot;jrt:/&quot;));
414         // This test assumes at least there are two elements in &quot;java/lang&quot;
415         // package with any filter passed. don&#39;t change to different path here!
416         Path dir = fs.getPath(&quot;/modules/java.base/java/lang&quot;);
417         try (DirectoryStream&lt;Path&gt; stream = Files.newDirectoryStream(dir, filter)) {
418             Iterator&lt;Path&gt; itr = stream.iterator();
419             itr.hasNext();
420             Path path1 = itr.next();
421             // missing second hasNext call
422             Path path2 = itr.next();
423             assertNotEquals(path1, path2);
424         }
425 
426         try (DirectoryStream&lt;Path&gt; stream = Files.newDirectoryStream(dir, filter)) {
427             Iterator&lt;Path&gt; itr = stream.iterator();
428             // no hasNext calls at all
429             Path path1 = itr.next();
430             Path path2 = itr.next();
431             assertNotEquals(path1, path2);
432         }
433 
434         int numEntries = 0;
435         try (DirectoryStream&lt;Path&gt; stream = Files.newDirectoryStream(dir, filter)) {
436             Iterator&lt;Path&gt; itr = stream.iterator();
437             while (itr.hasNext()) {
438                 numEntries++;
439                 itr.next();
440             }
441 
442             // reached EOF, next call should result in exception
443             try {
444                 itr.next();
445                 throw new AssertionError(&quot;should have thrown exception&quot;);
446             } catch (NoSuchElementException nsee) {
447                 System.out.println(&quot;got NoSuchElementException as expected&quot;);
448             }
449         }
450 
451         // redundant hasNext calls
452         try (DirectoryStream&lt;Path&gt; stream = Files.newDirectoryStream(dir, filter)) {
453             Iterator&lt;Path&gt; itr = stream.iterator();
454             // any number of hasNext should definitely stay at first element
455             for (int i = 0; i &lt; 2*numEntries; i++) {
456                 itr.hasNext();
457             }
458 
459             for (int j = 0; j &lt; numEntries; j++) {
460                 itr.next();
461             }
462             // exactly count number of entries!
463             assertFalse(itr.hasNext());
464         }
465     }
466 
467     @DataProvider(name = &quot;hiddenPaths&quot;)
468     private Object[][] hiddenPaths() {
469         return new Object[][] {
470             { &quot;/META-INF&quot; },
471             { &quot;/META-INF/services&quot; },
472             { &quot;/META-INF/services/java.nio.file.spi.FileSystemProvider&quot; },
473             { &quot;/modules/java.base/packages.offsets&quot; },
474             { &quot;/modules/java.instrument/packages.offsets&quot; },
475             { &quot;/modules/jdk.zipfs/packages.offsets&quot; },
476             { &quot;/modules/java.base/_the.java.base.vardeps&quot; },
477             { &quot;/modules/java.base/_the.java.base_batch&quot; },
478             { &quot;/java/lang&quot; },
479             { &quot;/java/util&quot; },
480         };
481     }
482 
483     @Test(dataProvider = &quot;hiddenPaths&quot;)
484     public void testHiddenPathsNotExposed(String path) throws Exception {
485         FileSystem fs = FileSystems.getFileSystem(URI.create(&quot;jrt:/&quot;));
486         assertTrue(Files.notExists(fs.getPath(path)), path + &quot; should not exist&quot;);
487     }
488 
489     @DataProvider(name = &quot;pathGlobPatterns&quot;)
490     private Object[][] pathGlobPatterns() {
491         return new Object[][] {
492             { &quot;/modules/*&quot;, &quot;/modules/java.base&quot;, true },
493             { &quot;/modules/*&quot;, &quot;/modules/java.base/java&quot;, false },
494             { &quot;/modules/j*&quot;, &quot;/modules/java.base&quot;, true },
495             { &quot;/modules/J*&quot;, &quot;/modules/java.base&quot;, false },
496             { &quot;**.class&quot;, &quot;/modules/java.base/java/lang/Object.class&quot;, true },
497             { &quot;**.java&quot;, &quot;/modules/java.base/java/lang/Object.class&quot;, false },
498             { &quot;**java/*&quot;, &quot;/modules/java.base/java/lang&quot;, true },
499             { &quot;**java/lang/ref*&quot;, &quot;/modules/java.base/java/lang/reflect&quot;, true },
500             { &quot;**java/lang/ref*&quot;, &quot;/modules/java.base/java/lang/ref&quot;, true },
501             { &quot;**java/lang/ref?&quot;, &quot;/modules/java.base/java/lang/ref&quot;, false },
502             { &quot;**java/lang/{ref,refl*}&quot;, &quot;/modules/java.base/java/lang/ref&quot;, true },
503             { &quot;**java/lang/{ref,refl*}&quot;, &quot;/modules/java.base/java/lang/reflect&quot;, true },
504             { &quot;**java/[a-u]?*/*.class&quot;, &quot;/modules/java.base/java/util/Map.class&quot;, true },
505             { &quot;**java/util/[a-z]*.class&quot;, &quot;/modules/java.base/java/util/TreeMap.class&quot;, false },
506         };
507     }
508 
509     @Test(dataProvider = &quot;pathGlobPatterns&quot;)
510     public void testGlobPathMatcher(String pattern, String path,
511             boolean expectMatch) throws Exception {
512         FileSystem fs = FileSystems.getFileSystem(URI.create(&quot;jrt:/&quot;));
513         PathMatcher pm = fs.getPathMatcher(&quot;glob:&quot; + pattern);
514         Path p = fs.getPath(path);
515         assertTrue(Files.exists(p), path);
516         assertTrue(!(pm.matches(p) ^ expectMatch),
517             p + (expectMatch? &quot; should match &quot; : &quot; should not match &quot;) +
518             pattern);
519     }
520 
521     @DataProvider(name = &quot;pathRegexPatterns&quot;)
522     private Object[][] pathRegexPatterns() {
523         return new Object[][] {
524             { &quot;/modules/.*&quot;, &quot;/modules/java.base&quot;, true },
525             { &quot;/modules/[^/]*&quot;, &quot;/modules/java.base/java&quot;, false },
526             { &quot;/modules/j.*&quot;, &quot;/modules/java.base&quot;, true },
527             { &quot;/modules/J.*&quot;, &quot;/modules/java.base&quot;, false },
528             { &quot;.*\\.class&quot;, &quot;/modules/java.base/java/lang/Object.class&quot;, true },
529             { &quot;.*\\.java&quot;, &quot;/modules/java.base/java/lang/Object.class&quot;, false },
530             { &quot;.*java/.*&quot;, &quot;/modules/java.base/java/lang&quot;, true },
531             { &quot;.*java/lang/ref.*&quot;, &quot;/modules/java.base/java/lang/reflect&quot;, true },
532             { &quot;.*java/lang/ref.*&quot;, &quot;/modules/java.base/java/lang/ref&quot;, true },
533             { &quot;.*/java/lang/ref.+&quot;, &quot;/modules/java.base/java/lang/ref&quot;, false },
534             { &quot;.*/java/lang/(ref|refl.*)&quot;, &quot;/modules/java.base/java/lang/ref&quot;, true },
535             { &quot;.*/java/lang/(ref|refl.*)&quot;, &quot;/modules/java.base/java/lang/reflect&quot;, true },
536             { &quot;.*/java/[a-u]?.*/.*\\.class&quot;, &quot;/modules/java.base/java/util/Map.class&quot;, true },
537             { &quot;.*/java/util/[a-z]*\\.class&quot;, &quot;/modules/java.base/java/util/TreeMap.class&quot;, false },
538         };
539     }
540 
541     @Test(dataProvider = &quot;pathRegexPatterns&quot;)
542     public void testRegexPathMatcher(String pattern, String path,
543             boolean expectMatch) throws Exception {
544         FileSystem fs = FileSystems.getFileSystem(URI.create(&quot;jrt:/&quot;));
545         PathMatcher pm = fs.getPathMatcher(&quot;regex:&quot; + pattern);
546         Path p = fs.getPath(path);
547         assertTrue(Files.exists(p), path);
548         assertTrue(!(pm.matches(p) ^ expectMatch),
549             p + (expectMatch? &quot; should match &quot; : &quot; should not match &quot;) +
550             pattern);
551     }
552 
553     @Test
554     public void testPackagesAndModules() throws Exception {
555         FileSystem fs = FileSystems.getFileSystem(URI.create(&quot;jrt:/&quot;));
556         assertTrue(Files.isDirectory(fs.getPath(&quot;/packages&quot;)));
557         assertTrue(Files.isDirectory(fs.getPath(&quot;/modules&quot;)));
558     }
559 
560     @DataProvider(name = &quot;packagesSubDirs&quot;)
561     private Object[][] packagesSubDirs() {
562         return new Object[][] {
563             { &quot;java.lang&quot; },
564             { &quot;java.util&quot; },
565             { &quot;java.nio&quot;  },
566             { &quot;jdk.nashorn.api.scripting&quot; }
567         };
568     }
569 
570     @Test(dataProvider = &quot;packagesSubDirs&quot;)
571     public void testPackagesSubDirs(String pkg) throws Exception {
572         FileSystem fs = FileSystems.getFileSystem(URI.create(&quot;jrt:/&quot;));
573         assertTrue(Files.isDirectory(fs.getPath(&quot;/packages/&quot; + pkg)),
574             pkg + &quot; missing&quot;);
575     }
576 
577     @DataProvider(name = &quot;packagesLinks&quot;)
578     private Object[][] packagesLinks() {
579         return new Object[][] {
580             { &quot;/packages/java.lang/java.base&quot; },
581             { &quot;/packages/java.lang/java.instrument&quot; },
582             { &quot;/packages/java/java.base&quot; },
583             { &quot;/packages/java/java.instrument&quot; },
584             { &quot;/packages/java/java.rmi&quot;  },
585             { &quot;/packages/java/java.sql&quot;  },
586             { &quot;/packages/javax/java.base&quot;  },
587             { &quot;/packages/javax/java.sql&quot;  },
588             { &quot;/packages/javax/java.xml&quot;  },
589             { &quot;/packages/javax/java.management&quot;  },
590             { &quot;/packages/java.util/java.base&quot; },
591             { &quot;/packages/jdk.nashorn.api.scripting/jdk.scripting.nashorn&quot; },
592         };
593     }
594 
595     @Test(dataProvider = &quot;packagesLinks&quot;)
596     public void testPackagesLinks(String link) throws Exception {
597         FileSystem fs = FileSystems.getFileSystem(URI.create(&quot;jrt:/&quot;));
598         Path path = fs.getPath(link);
599         assertTrue(Files.exists(path), link + &quot; missing&quot;);
600         assertTrue(Files.isSymbolicLink(path), path + &quot; is not a link&quot;);
601         path = Files.readSymbolicLink(path);
602         assertEquals(path.toString(), &quot;/modules&quot; + link.substring(link.lastIndexOf(&quot;/&quot;)));
603     }
604 
605     @DataProvider(name = &quot;modulesSubDirs&quot;)
606     private Object[][] modulesSubDirs() {
607         return new Object[][] {
608             { &quot;java.base&quot; },
609             { &quot;java.sql&quot; },
610             { &quot;jdk.scripting.nashorn&quot; },
611         };
612     }
613 
614     @Test(dataProvider = &quot;modulesSubDirs&quot;)
615     public void testModulesSubDirs(String module) throws Exception {
616         FileSystem fs = FileSystems.getFileSystem(URI.create(&quot;jrt:/&quot;));
617         Path path = fs.getPath(&quot;/modules/&quot; + module);
618         assertTrue(Files.isDirectory(path), module + &quot; missing&quot;);
619         assertTrue(!Files.isSymbolicLink(path), path + &quot; is a link&quot;);
620     }
621 
622     @DataProvider(name=&quot;linkChases&quot;)
623     private Object[][] linkChases() {
624         return new Object[][] {
625             { &quot;/modules/java.base/java/lang&quot; },
626             { &quot;/modules/java.base/java/util/Vector.class&quot; },
627             { &quot;/modules/jdk.scripting.nashorn/jdk/nashorn&quot; },
628             { &quot;/packages/java.lang/java.base/java/lang&quot; },
629             { &quot;/packages/java.util/java.base/java/util/Vector.class&quot; },
630         };
631     }
632 
633     @Test(dataProvider = &quot;linkChases&quot;)
634     public void testLinkChases(String link) throws Exception {
635         FileSystem fs = FileSystems.getFileSystem(URI.create(&quot;jrt:/&quot;));
636         Path path = fs.getPath(link);
637         assertTrue(Files.exists(path), link);
638     }
639 
640     @Test
641     public void testSymlinkDirList() throws Exception {
642         FileSystem fs = FileSystems.getFileSystem(URI.create(&quot;jrt:/&quot;));
643         Path path = fs.getPath(&quot;/packages/java.lang/java.base&quot;);
644         assertTrue(Files.isSymbolicLink(path));
645         assertTrue(Files.isDirectory(path));
646 
647         boolean javaSeen = false, javaxSeen = false;
648         try (DirectoryStream&lt;Path&gt; stream = Files.newDirectoryStream(path)) {
649             for (Path p : stream) {
650                 String str = p.toString();
651                 if (str.endsWith(&quot;/java&quot;)) {
652                     javaSeen = true;
653                 } else if (str.endsWith(&quot;javax&quot;)) {
654                     javaxSeen = true;
655                 }
656             }
657         }
658         assertTrue(javaSeen);
659         assertTrue(javaxSeen);
660     }
661 
662     @Test
663     public void invalidPathTest() {
664         FileSystem fs = FileSystems.getFileSystem(URI.create(&quot;jrt:/&quot;));
665         InvalidPathException ipe = null;
666         try {
667             boolean res = Files.exists(fs.getPath(&quot;/packages/\ud834\udd7b&quot;));
668             assertFalse(res);
669             return;
670         } catch (InvalidPathException e) {
671             ipe = e;
672         }
673         assertTrue(ipe != null);
674     }
675 
676     @DataProvider(name=&quot;packagesLinkedDirs&quot;)
677     private Object[][] packagesLinkedDirs() {
678         return new Object[][] {
679             { &quot;/packages/java.lang/java.base/java/lang/ref&quot;             },
680             { &quot;/./packages/java.lang/java.base/java/lang/ref&quot;           },
681             { &quot;packages/java.lang/java.base/java/lang/ref&quot;              },
682             { &quot;/packages/../packages/java.lang/java.base/java/lang/ref&quot; },
683             { &quot;/packages/java.lang/java.base/java/util/zip&quot;             },
684             { &quot;/./packages/java.lang/java.base/java/util/zip&quot;           },
685             { &quot;packages/java.lang/java.base/java/util/zip&quot;              },
686             { &quot;/packages/../packages/java.lang/java.base/java/util/zip&quot; },
687         };
688     }
689 
690     // @bug 8141521: jrt file system&#39;s DirectoryStream reports child paths
691     // with wrong paths for directories under /packages
692     @Test(dataProvider = &quot;packagesLinkedDirs&quot;)
693     public void dirStreamPackagesDirTest(String dirName) throws IOException {
694         FileSystem fs = FileSystems.getFileSystem(URI.create(&quot;jrt:/&quot;));
695         Path path = fs.getPath(dirName);
696 
697         int childCount = 0, dirPrefixOkayCount = 0;
698         try (DirectoryStream&lt;Path&gt; dirStream = Files.newDirectoryStream(path)) {
699             for (Path child : dirStream) {
700                 childCount++;
701                 if (child.toString().startsWith(dirName)) {
702                     dirPrefixOkayCount++;
703                 }
704             }
705         }
706 
707         assertTrue(childCount != 0);
708         assertEquals(dirPrefixOkayCount, childCount);
709     }
710 
711     @Test
712     public void objectClassSizeTest() throws Exception {
713         String path = &quot;/modules/java.base/java/lang/Object.class&quot;;
714         FileSystem fs = FileSystems.getFileSystem(URI.create(&quot;jrt:/&quot;));
715         Path classFile = fs.getPath(path);
716 
717         assertTrue(Files.size(classFile) &gt; 0L);
718     }
719 }
720 
    </pre>
  </body>
</html>
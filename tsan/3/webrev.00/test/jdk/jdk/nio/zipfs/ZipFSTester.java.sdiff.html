<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff test/jdk/jdk/nio/zipfs/ZipFSTester.java</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
<body>
<center><a href="PathOps.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="jarfs/JFSTester.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>test/jdk/jdk/nio/zipfs/ZipFSTester.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 2010, 2018, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  */
</pre>
<hr />
<pre>
  64 import java.util.zip.ZipFile;
  65 import java.util.zip.ZipOutputStream;
  66 
  67 import static java.nio.file.StandardOpenOption.*;
  68 import static java.nio.file.StandardCopyOption.*;
  69 
  70 /*
  71  * Tests various zipfs operations.
  72  *
  73  * @test
  74  * @bug 6990846 7009092 7009085 7015391 7014948 7005986 7017840 7007596
  75  *      7157656 8002390 7012868 7012856 8015728 8038500 8040059 8069211
  76  *      8131067 8034802 8210899
  77  * @summary Test Zip filesystem provider
  78  * @modules jdk.zipfs
  79  * @run main ZipFSTester
  80  * @run main/othervm/java.security.policy=test.policy ZipFSTester
  81  */
  82 
  83 public class ZipFSTester {
<span class="line-removed">  84 </span>
  85     public static void main(String[] args) throws Exception {
  86         // create JAR file for test, actual contents don&#39;t matter
  87         Path jarFile = Utils.createJarFile(&quot;tester.jar&quot;,
  88                 &quot;META-INF/MANIFEST.MF&quot;,
  89                 &quot;dir1/foo&quot;,
  90                 &quot;dir2/bar&quot;,
  91                 &quot;dir1/dir3/fooo&quot;);
  92 
  93         try (FileSystem fs = newZipFileSystem(jarFile, Collections.emptyMap())) {
  94             test0(fs);
  95             test1(fs);
  96             test2(fs);   // more tests
  97         }
  98         testStreamChannel();
  99         testTime(jarFile);
 100         test8069211();
 101         test8131067();
 102     }
 103 
 104     private static Random rdm = new Random();
</pre>
<hr />
<pre>
 129     {
 130         // prepare a src for testing
 131         Path src = getTempPath();
 132         String tmpName = src.toString();
 133         try (OutputStream os = Files.newOutputStream(src)) {
 134             byte[] bits = new byte[12345];
 135             rdm.nextBytes(bits);
 136             os.write(bits);
 137         }
 138 
 139         // clone a fs from fs0 and test on it
 140         Path tmpfsPath = getTempPath();
 141         Map&lt;String, Object&gt; env = new HashMap&lt;String, Object&gt;();
 142         env.put(&quot;create&quot;, &quot;true&quot;);
 143         try (FileSystem copy = newZipFileSystem(tmpfsPath, env)) {
 144             z2zcopy(fs0, copy, &quot;/&quot;, 0);
 145 
 146             // copy the test jar itself in
 147             Files.copy(Paths.get(fs0.toString()), copy.getPath(&quot;/foo.jar&quot;));
 148             Path zpath = copy.getPath(&quot;/foo.jar&quot;);
<span class="line-modified"> 149             try (FileSystem zzfs = FileSystems.newFileSystem(zpath, null)) {</span>
 150                 Files.copy(src, zzfs.getPath(&quot;/srcInjarjar&quot;));
 151             }
 152         }
 153 
 154         try (FileSystem fs = newZipFileSystem(tmpfsPath, new HashMap&lt;String, Object&gt;())) {
 155 
 156             FileSystemProvider provider = fs.provider();
 157             // newFileSystem(path...) should not throw exception
 158             try (FileSystem fsPath = provider.newFileSystem(tmpfsPath, new HashMap&lt;String, Object&gt;())){}
 159             try (FileSystem fsUri = provider.newFileSystem(
 160                      new URI(&quot;jar&quot;, tmpfsPath.toUri().toString(), null),
 161                      new HashMap&lt;String, Object&gt;()))
 162             {
 163                 throw new RuntimeException(&quot;newFileSystem(URI...) does not throw exception&quot;);
 164             } catch (FileSystemAlreadyExistsException fsaee) {}
 165 
 166             try {
 167                 provider.newFileSystem(new File(System.getProperty(&quot;test.src&quot;, &quot;.&quot;)).toPath(),
 168                                        new HashMap&lt;String, Object&gt;());
 169                 throw new RuntimeException(&quot;newFileSystem() opens a directory as zipfs&quot;);
</pre>
<hr />
<pre>
 212             if (Files.exists(dst4))
 213                 throw new RuntimeException(&quot;Failed!&quot;);
 214             Files.delete(dst3);
 215             if (Files.exists(dst3))
 216                 throw new RuntimeException(&quot;Failed!&quot;);
 217 
 218             // move (existing entry)
 219             Path dst5 = fs.getPath(&quot;META-INF/MANIFEST.MF&quot;);
 220             if (Files.exists(dst5)) {
 221                 Path dst6 = fs.getPath(&quot;META-INF/MANIFEST.MF_TMP&quot;);
 222                 Files.move(dst5, dst6);
 223                 walk(fs.getPath(&quot;/&quot;));
 224             }
 225 
 226             // newInputStream on dir
 227             Path parent = dst2.getParent();
 228             try {
 229                 Files.newInputStream(parent);
 230                 throw new RuntimeException(&quot;Failed&quot;);
 231             } catch (FileSystemException e) {
<span class="line-modified"> 232                 e.printStackTrace();    // expected fse</span>
 233             }
 234 
 235             // rmdirs
 236             try {
 237                 rmdirs(parent);
 238             } catch (IOException x) {
 239                 x.printStackTrace();
 240             }
 241 
 242             // newFileChannel() copy in, out and verify via fch
 243             fchCopy(src, dst);    // in
 244             checkEqual(src, dst);
 245             Path tmp = Paths.get(tmpName + &quot;_Tmp&quot;);
 246             fchCopy(dst, tmp);   //  out
 247             checkEqual(src, tmp);
 248             Files.delete(tmp);
 249 
 250             // test channels
 251             channel(fs, dst);
 252             Files.delete(dst);
 253 
 254             // test foo.jar in jar/zipfs #8034802
 255             Path jpath = fs.getPath(&quot;/foo.jar&quot;);
 256             System.out.println(&quot;walking: &quot; + jpath);
<span class="line-modified"> 257             try (FileSystem zzfs = FileSystems.newFileSystem(jpath, null)) {</span>
 258                 walk(zzfs.getPath(&quot;/&quot;));
 259                 // foojar:/srcInjarjar
 260                 checkEqual(src, zzfs.getPath(&quot;/srcInjarjar&quot;));
 261 
 262                 dst = getPathWithParents(zzfs, tmpName);
 263                 fchCopy(src, dst);
 264                 checkEqual(src, dst);
 265                 tmp = Paths.get(tmpName + &quot;_Tmp&quot;);
 266                 fchCopy(dst, tmp);   //  out
 267                 checkEqual(src, tmp);
 268                 Files.delete(tmp);
 269 
 270                 channel(zzfs, dst);
 271                 Files.delete(dst);
 272             }
 273         } finally {
 274             Files.deleteIfExists(tmpfsPath);
 275             Files.deleteIfExists(src);
 276         }
 277     }
</pre>
<hr />
<pre>
 404         System.out.println(&quot;checkEqual: fs vs fs4&quot;);
 405         for (String path : files2) {
 406             checkEqual(fs.getPath(path), fs4.getPath(path));
 407         }
 408         System.out.println(&quot;walking: fs4&quot;);
 409         walk(fs4.getPath(&quot;/&quot;));
 410         System.out.println(&quot;closing: fs4&quot;);
 411         fs4.close();
 412         System.out.printf(&quot;failed=%d%n&quot;, failed);
 413 
 414         Files.delete(fs1Path);
 415         Files.delete(fs2Path);
 416         Files.delete(fs3Path);
 417     }
 418 
 419     static final int METHOD_STORED     = 0;
 420     static final int METHOD_DEFLATED   = 8;
 421 
 422     static Object[][] getEntries() {
 423         Object[][] entries = new Object[10 + rdm.nextInt(20)][3];
<span class="line-modified"> 424         for (int i = 0; i &lt; entries.length; i++) {</span>








 425             entries[i][0] = &quot;entries&quot; + i;
 426             entries[i][1] = rdm.nextInt(10) % 2 == 0 ?
 427                 METHOD_STORED : METHOD_DEFLATED;
 428             entries[i][2] = new byte[rdm.nextInt(8192)];
 429             rdm.nextBytes((byte[])entries[i][2]);
 430         }
 431         return entries;
 432     }
 433 
 434     // check the content of read from zipfs is equal to the &quot;bytes&quot;
 435     private static void checkRead(Path path, byte[] expected) throws IOException {
 436 
 437         // fileAttribute
 438         CRC32 crc32 = new CRC32();
 439         crc32.update(expected);
 440 
 441         if (((Long)Files.getAttribute(path, &quot;zip:crc&quot;)).intValue() !=
 442             (int)crc32.getValue()) {
 443             System.out.printf(&quot; getAttribute.crc &lt;%s&gt; failed %x vs %x ...%n&quot;,
 444                               path.toString(),
</pre>
<hr />
<pre>
 516                  var zos = new ZipOutputStream(os)) {
 517                 for (Object[] entry : entries) {
 518                    var ze = new ZipEntry((String)entry[0]);
 519                    int method = (int)entry[1];
 520                    byte[] bytes = (byte[])entry[2];
 521                    if (method == METHOD_STORED) {
 522                        ze.setSize(bytes.length);
 523                        crc.reset();
 524                        crc.update(bytes);
 525                        ze.setCrc(crc.getValue());
 526                    }
 527                    ze.setMethod(method);
 528                    zos.putNextEntry(ze);
 529                    zos.write(bytes);
 530                    zos.closeEntry();
 531                 }
 532             }
 533             try (var zfs = newZipFileSystem(zpath, Collections.emptyMap())) {
 534                 for (Object[] e : entries) {
 535                     Path path = zfs.getPath((String)e[0]);
<span class="line-removed"> 536                     int method = (int)e[1];</span>
 537                     byte[] bytes = (byte[])e[2];
<span class="line-removed"> 538                     // System.out.printf(&quot;checking read [%s, %d, %d]%n&quot;,</span>
<span class="line-removed"> 539                     //                   path.toString(), bytes.length, method);</span>
 540                     checkRead(path, bytes);
 541                 }
 542             }
 543             Files.deleteIfExists(zpath);
 544 
 545             // [2] create zip via zfs.newByteChannel
 546             try (var zfs = newZipFileSystem(zpath, Map.of(&quot;create&quot;, &quot;true&quot;))) {
 547                 for (Object[] e : entries) {
 548                     //  tbd: method is not used
 549                     try (var sbc = Files.newByteChannel(zfs.getPath((String)e[0]),
 550                                                         CREATE_NEW, WRITE)) {
 551                         sbc.write(ByteBuffer.wrap((byte[])e[2]));
 552                     }
 553                 }
 554             }
 555             try (var zfs = newZipFileSystem(zpath, Collections.emptyMap())) {
 556                 for (Object[] e : entries) {
 557                     checkRead(zfs.getPath((String)e[0]), (byte[])e[2]);
 558                 }
 559             }
</pre>
</td>
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 2010, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  */
</pre>
<hr />
<pre>
  64 import java.util.zip.ZipFile;
  65 import java.util.zip.ZipOutputStream;
  66 
  67 import static java.nio.file.StandardOpenOption.*;
  68 import static java.nio.file.StandardCopyOption.*;
  69 
  70 /*
  71  * Tests various zipfs operations.
  72  *
  73  * @test
  74  * @bug 6990846 7009092 7009085 7015391 7014948 7005986 7017840 7007596
  75  *      7157656 8002390 7012868 7012856 8015728 8038500 8040059 8069211
  76  *      8131067 8034802 8210899
  77  * @summary Test Zip filesystem provider
  78  * @modules jdk.zipfs
  79  * @run main ZipFSTester
  80  * @run main/othervm/java.security.policy=test.policy ZipFSTester
  81  */
  82 
  83 public class ZipFSTester {

  84     public static void main(String[] args) throws Exception {
  85         // create JAR file for test, actual contents don&#39;t matter
  86         Path jarFile = Utils.createJarFile(&quot;tester.jar&quot;,
  87                 &quot;META-INF/MANIFEST.MF&quot;,
  88                 &quot;dir1/foo&quot;,
  89                 &quot;dir2/bar&quot;,
  90                 &quot;dir1/dir3/fooo&quot;);
  91 
  92         try (FileSystem fs = newZipFileSystem(jarFile, Collections.emptyMap())) {
  93             test0(fs);
  94             test1(fs);
  95             test2(fs);   // more tests
  96         }
  97         testStreamChannel();
  98         testTime(jarFile);
  99         test8069211();
 100         test8131067();
 101     }
 102 
 103     private static Random rdm = new Random();
</pre>
<hr />
<pre>
 128     {
 129         // prepare a src for testing
 130         Path src = getTempPath();
 131         String tmpName = src.toString();
 132         try (OutputStream os = Files.newOutputStream(src)) {
 133             byte[] bits = new byte[12345];
 134             rdm.nextBytes(bits);
 135             os.write(bits);
 136         }
 137 
 138         // clone a fs from fs0 and test on it
 139         Path tmpfsPath = getTempPath();
 140         Map&lt;String, Object&gt; env = new HashMap&lt;String, Object&gt;();
 141         env.put(&quot;create&quot;, &quot;true&quot;);
 142         try (FileSystem copy = newZipFileSystem(tmpfsPath, env)) {
 143             z2zcopy(fs0, copy, &quot;/&quot;, 0);
 144 
 145             // copy the test jar itself in
 146             Files.copy(Paths.get(fs0.toString()), copy.getPath(&quot;/foo.jar&quot;));
 147             Path zpath = copy.getPath(&quot;/foo.jar&quot;);
<span class="line-modified"> 148             try (FileSystem zzfs = FileSystems.newFileSystem(zpath)) {</span>
 149                 Files.copy(src, zzfs.getPath(&quot;/srcInjarjar&quot;));
 150             }
 151         }
 152 
 153         try (FileSystem fs = newZipFileSystem(tmpfsPath, new HashMap&lt;String, Object&gt;())) {
 154 
 155             FileSystemProvider provider = fs.provider();
 156             // newFileSystem(path...) should not throw exception
 157             try (FileSystem fsPath = provider.newFileSystem(tmpfsPath, new HashMap&lt;String, Object&gt;())){}
 158             try (FileSystem fsUri = provider.newFileSystem(
 159                      new URI(&quot;jar&quot;, tmpfsPath.toUri().toString(), null),
 160                      new HashMap&lt;String, Object&gt;()))
 161             {
 162                 throw new RuntimeException(&quot;newFileSystem(URI...) does not throw exception&quot;);
 163             } catch (FileSystemAlreadyExistsException fsaee) {}
 164 
 165             try {
 166                 provider.newFileSystem(new File(System.getProperty(&quot;test.src&quot;, &quot;.&quot;)).toPath(),
 167                                        new HashMap&lt;String, Object&gt;());
 168                 throw new RuntimeException(&quot;newFileSystem() opens a directory as zipfs&quot;);
</pre>
<hr />
<pre>
 211             if (Files.exists(dst4))
 212                 throw new RuntimeException(&quot;Failed!&quot;);
 213             Files.delete(dst3);
 214             if (Files.exists(dst3))
 215                 throw new RuntimeException(&quot;Failed!&quot;);
 216 
 217             // move (existing entry)
 218             Path dst5 = fs.getPath(&quot;META-INF/MANIFEST.MF&quot;);
 219             if (Files.exists(dst5)) {
 220                 Path dst6 = fs.getPath(&quot;META-INF/MANIFEST.MF_TMP&quot;);
 221                 Files.move(dst5, dst6);
 222                 walk(fs.getPath(&quot;/&quot;));
 223             }
 224 
 225             // newInputStream on dir
 226             Path parent = dst2.getParent();
 227             try {
 228                 Files.newInputStream(parent);
 229                 throw new RuntimeException(&quot;Failed&quot;);
 230             } catch (FileSystemException e) {
<span class="line-modified"> 231                 // expected fse</span>
 232             }
 233 
 234             // rmdirs
 235             try {
 236                 rmdirs(parent);
 237             } catch (IOException x) {
 238                 x.printStackTrace();
 239             }
 240 
 241             // newFileChannel() copy in, out and verify via fch
 242             fchCopy(src, dst);    // in
 243             checkEqual(src, dst);
 244             Path tmp = Paths.get(tmpName + &quot;_Tmp&quot;);
 245             fchCopy(dst, tmp);   //  out
 246             checkEqual(src, tmp);
 247             Files.delete(tmp);
 248 
 249             // test channels
 250             channel(fs, dst);
 251             Files.delete(dst);
 252 
 253             // test foo.jar in jar/zipfs #8034802
 254             Path jpath = fs.getPath(&quot;/foo.jar&quot;);
 255             System.out.println(&quot;walking: &quot; + jpath);
<span class="line-modified"> 256             try (FileSystem zzfs = FileSystems.newFileSystem(jpath)) {</span>
 257                 walk(zzfs.getPath(&quot;/&quot;));
 258                 // foojar:/srcInjarjar
 259                 checkEqual(src, zzfs.getPath(&quot;/srcInjarjar&quot;));
 260 
 261                 dst = getPathWithParents(zzfs, tmpName);
 262                 fchCopy(src, dst);
 263                 checkEqual(src, dst);
 264                 tmp = Paths.get(tmpName + &quot;_Tmp&quot;);
 265                 fchCopy(dst, tmp);   //  out
 266                 checkEqual(src, tmp);
 267                 Files.delete(tmp);
 268 
 269                 channel(zzfs, dst);
 270                 Files.delete(dst);
 271             }
 272         } finally {
 273             Files.deleteIfExists(tmpfsPath);
 274             Files.deleteIfExists(src);
 275         }
 276     }
</pre>
<hr />
<pre>
 403         System.out.println(&quot;checkEqual: fs vs fs4&quot;);
 404         for (String path : files2) {
 405             checkEqual(fs.getPath(path), fs4.getPath(path));
 406         }
 407         System.out.println(&quot;walking: fs4&quot;);
 408         walk(fs4.getPath(&quot;/&quot;));
 409         System.out.println(&quot;closing: fs4&quot;);
 410         fs4.close();
 411         System.out.printf(&quot;failed=%d%n&quot;, failed);
 412 
 413         Files.delete(fs1Path);
 414         Files.delete(fs2Path);
 415         Files.delete(fs3Path);
 416     }
 417 
 418     static final int METHOD_STORED     = 0;
 419     static final int METHOD_DEFLATED   = 8;
 420 
 421     static Object[][] getEntries() {
 422         Object[][] entries = new Object[10 + rdm.nextInt(20)][3];
<span class="line-modified"> 423         // first entries shall test the corner case of 0 bytes of data</span>
<span class="line-added"> 424         entries[0][0] = &quot;entries&quot; + 0;</span>
<span class="line-added"> 425         entries[0][1] = METHOD_STORED;</span>
<span class="line-added"> 426         entries[0][2] = new byte[0];</span>
<span class="line-added"> 427         entries[1][0] = &quot;entries&quot; + 1;</span>
<span class="line-added"> 428         entries[1][1] = METHOD_DEFLATED;</span>
<span class="line-added"> 429         entries[1][2] = new byte[0];</span>
<span class="line-added"> 430         // the rest is random data</span>
<span class="line-added"> 431         for (int i = 2; i &lt; entries.length; i++) {</span>
 432             entries[i][0] = &quot;entries&quot; + i;
 433             entries[i][1] = rdm.nextInt(10) % 2 == 0 ?
 434                 METHOD_STORED : METHOD_DEFLATED;
 435             entries[i][2] = new byte[rdm.nextInt(8192)];
 436             rdm.nextBytes((byte[])entries[i][2]);
 437         }
 438         return entries;
 439     }
 440 
 441     // check the content of read from zipfs is equal to the &quot;bytes&quot;
 442     private static void checkRead(Path path, byte[] expected) throws IOException {
 443 
 444         // fileAttribute
 445         CRC32 crc32 = new CRC32();
 446         crc32.update(expected);
 447 
 448         if (((Long)Files.getAttribute(path, &quot;zip:crc&quot;)).intValue() !=
 449             (int)crc32.getValue()) {
 450             System.out.printf(&quot; getAttribute.crc &lt;%s&gt; failed %x vs %x ...%n&quot;,
 451                               path.toString(),
</pre>
<hr />
<pre>
 523                  var zos = new ZipOutputStream(os)) {
 524                 for (Object[] entry : entries) {
 525                    var ze = new ZipEntry((String)entry[0]);
 526                    int method = (int)entry[1];
 527                    byte[] bytes = (byte[])entry[2];
 528                    if (method == METHOD_STORED) {
 529                        ze.setSize(bytes.length);
 530                        crc.reset();
 531                        crc.update(bytes);
 532                        ze.setCrc(crc.getValue());
 533                    }
 534                    ze.setMethod(method);
 535                    zos.putNextEntry(ze);
 536                    zos.write(bytes);
 537                    zos.closeEntry();
 538                 }
 539             }
 540             try (var zfs = newZipFileSystem(zpath, Collections.emptyMap())) {
 541                 for (Object[] e : entries) {
 542                     Path path = zfs.getPath((String)e[0]);

 543                     byte[] bytes = (byte[])e[2];


 544                     checkRead(path, bytes);
 545                 }
 546             }
 547             Files.deleteIfExists(zpath);
 548 
 549             // [2] create zip via zfs.newByteChannel
 550             try (var zfs = newZipFileSystem(zpath, Map.of(&quot;create&quot;, &quot;true&quot;))) {
 551                 for (Object[] e : entries) {
 552                     //  tbd: method is not used
 553                     try (var sbc = Files.newByteChannel(zfs.getPath((String)e[0]),
 554                                                         CREATE_NEW, WRITE)) {
 555                         sbc.write(ByteBuffer.wrap((byte[])e[2]));
 556                     }
 557                 }
 558             }
 559             try (var zfs = newZipFileSystem(zpath, Collections.emptyMap())) {
 560                 for (Object[] e : entries) {
 561                     checkRead(zfs.getPath((String)e[0]), (byte[])e[2]);
 562                 }
 563             }
</pre>
</td>
</tr>
</table>
<center><a href="PathOps.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="jarfs/JFSTester.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
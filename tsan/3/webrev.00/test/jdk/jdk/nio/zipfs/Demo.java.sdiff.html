<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff test/jdk/jdk/nio/zipfs/Demo.java</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
<body>
<center><a href="Basic.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="PathOps.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>test/jdk/jdk/nio/zipfs/Demo.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2010, 2014, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 import java.io.*;
 25 import java.nio.*;
 26 import java.nio.channels.*;
 27 import java.nio.file.*;
 28 import java.nio.file.spi.*;
 29 import java.nio.file.attribute.*;
<span class="line-removed"> 30 import java.net.*;</span>
 31 import java.text.DateFormat;
 32 import java.text.SimpleDateFormat;
 33 import java.util.*;
 34 
 35 import static java.nio.file.StandardOpenOption.*;
 36 import static java.nio.file.StandardCopyOption.*;
 37 
 38 /*
 39  * ZipFileSystem usage demo
 40  *
 41  * java Demo action ZipfileName [...]
 42  *
 43  * @author Xueming Shen
 44  */
 45 
 46 public class Demo {
 47 
 48     static enum Action {
 49         rename,          // &lt;java Demo rename zipfile src dst&gt;
 50                          // rename entry src to dst inside zipfile
</pre>
<hr />
<pre>
 81 
 82         attrs,           // &lt;java Demo attrs zipfile path&gt;
 83                          // printout the attributes of entry path
 84 
 85         attrsspace,      // &lt;java Demo attrsspace zipfile path&gt;
 86                          // printout the storespace attrs of entry path
 87 
 88         setmtime,        // &lt;java Demo setmtime zipfile &quot;MM/dd/yy-HH:mm:ss&quot; path...&gt;
 89                          // set the lastModifiedTime of entry path
 90 
 91         setatime,        // &lt;java Demo setatime zipfile &quot;MM/dd/yy-HH:mm:ss&quot; path...&gt;
 92         setctime,        // &lt;java Demo setctime zipfile &quot;MM/dd/yy-HH:mm:ss&quot; path...&gt;
 93 
 94         lsdir,           // &lt;java Demo lsdir zipfile dir&gt;
 95                          // list dir&#39;s direct child files/dirs
 96 
 97         mkdir,           // &lt;java Demo mkdir zipfile dir&gt;
 98 
 99         mkdirs,          // &lt;java Demo mkdirs zipfile dir&gt;
100 
<span class="line-removed">101         rmdirs,          // &lt;java Demo rmdirs zipfile dir&gt;</span>
<span class="line-removed">102 </span>
103         list,            // &lt;java Demo list zipfile [dir]&gt;
104                          // recursively list all entries of dir
105                          // via DirectoryStream
106 
107         tlist,           // &lt;java Demo tlist zipfile [dir]&gt;
108                          // list with buildDirTree=true
109 
110         vlist,           // &lt;java Demo vlist zipfile [dir]&gt;
111                          // recursively verbose list all entries of
112                          // dir via DirectoryStream
113 
114         walk,            // &lt;java Demo walk zipfile [dir]&gt;
115                          // recursively walk all entries of dir
116                          // via Files.walkFileTree
117 
118         twalk,           // &lt;java Demo twalk zipfile [dir]&gt;
119                          // walk with buildDirTree=true
120 
121         extract,         // &lt;java Demo extract zipfile file [...]&gt;
122 
</pre>
<hr />
<pre>
127         add,             // &lt;java Demo add zipfile file [...]&gt;
128 
129         create,          // &lt;java Demo create zipfile file [...]&gt;
130                          // create a new zipfile if it doesn&#39;t exit
131                          // and then add the file(s) into it.
132 
133         attrs2,          // &lt;java Demo attrs2 zipfile file [...]&gt;
134                          // test different ways to print attrs
135 
136         prof,
137     }
138 
139     public static void main(String[] args) throws Throwable {
140         FileSystemProvider provider = getZipFSProvider();
141         if (provider == null) {
142             System.err.println(&quot;ZIP filesystem provider is not installed&quot;);
143             System.exit(1);
144         }
145 
146         Action action = Action.valueOf(args[0]);
<span class="line-modified">147         Map&lt;String, Object&gt; env = env = new HashMap&lt;&gt;();</span>
148         if (action == Action.create)
149             env.put(&quot;create&quot;, &quot;true&quot;);
150         try (FileSystem fs = provider.newFileSystem(Paths.get(args[1]), env)) {
151             Path path, src, dst;
152             switch (action) {
153             case rename:
154                 src = fs.getPath(args[2]);
155                 dst = fs.getPath(args[3]);
156                 Files.move(src, dst);
157                 break;
158             case moveout:
159                 src = fs.getPath(args[2]);
160                 dst = Paths.get(args[3]);
161                 Files.move(src, dst);
162                 break;
163             case movein:
164                 src = Paths.get(args[2]);
165                 dst = fs.getPath(args[3]);
166                 Files.move(src, dst);
167                 break;
</pre>
<hr />
<pre>
517                     Files.delete(dir);
518                 } catch (IOException x) {
519                     //x.printStackTrace();
520                 }
521                 return FileVisitResult.CONTINUE;
522             }
523         });
524 
525     }
526 
527     private static void mkdirs(Path path) throws IOException {
528         path = path.toAbsolutePath();
529         Path parent = path.getParent();
530         if (parent != null) {
531             if (Files.notExists(parent))
532                 mkdirs(parent);
533         }
534         Files.createDirectory(path);
535     }
536 
<span class="line-removed">537     @SuppressWarnings(&quot;unused&quot;)</span>
538     /**
539      * Not used in demo, but included for demonstrational purposes.
540      */

541     private static void rmdirs(Path path) throws IOException {
542         while (path != null &amp;&amp; path.getNameCount() != 0) {
543             Files.delete(path);
544             path = path.getParent();
545         }
546     }
547 
548     private static void list(Path path, boolean verbose ) throws IOException {
549         if (!&quot;/&quot;.equals(path.toString())) {
550            System.out.printf(&quot;  %s%n&quot;, path.toString());
551            if (verbose)
552                 System.out.println(Files.readAttributes(path, BasicFileAttributes.class).toString());
553         }
554         if (Files.notExists(path))
555             return;
556         if (Files.isDirectory(path)) {
557             try (DirectoryStream&lt;Path&gt; ds = Files.newDirectoryStream(path)) {
558                 for (Path child : ds)
559                     list(child, verbose);
560             }
561         }
562     }
563 
<span class="line-removed">564     @SuppressWarnings(&quot;unused&quot;)</span>
565     /**
566      * Checks that the content of two paths are equal.
567      * Not used in demo, but included for demonstrational purposes.
568      */

569     private static void checkEqual(Path src, Path dst) throws IOException
570     {
571         //System.out.printf(&quot;checking &lt;%s&gt; vs &lt;%s&gt;...%n&quot;,
572         //                  src.toString(), dst.toString());
573 
574         //streams
575         byte[] bufSrc = new byte[8192];
576         byte[] bufDst = new byte[8192];
577         try (InputStream isSrc = Files.newInputStream(src);
578              InputStream isDst = Files.newInputStream(dst))
579         {
580             int nSrc = 0;
581             while ((nSrc = isSrc.read(bufSrc)) != -1) {
582                 int nDst = 0;
583                 while (nDst &lt; nSrc) {
584                     int n = isDst.read(bufDst, nDst, nSrc - nDst);
585                     if (n == -1) {
586                         System.out.printf(&quot;checking &lt;%s&gt; vs &lt;%s&gt;...%n&quot;,
587                                           src.toString(), dst.toString());
588                         throw new RuntimeException(&quot;CHECK FAILED!&quot;);
</pre>
<hr />
<pre>
621                     System.out.printf(&quot;checking &lt;%s&gt; vs &lt;%s&gt;...%n&quot;,
622                                       src.toString(), dst.toString());
623                     throw new RuntimeException(&quot;CHECK FAILED!&quot;);
624                 }
625                 while (--nSrc &gt;= 0) {
626                     if (bbSrc.get(nSrc) != bbDst.get(nSrc)) {
627                         System.out.printf(&quot;checking &lt;%s&gt; vs &lt;%s&gt;...%n&quot;,
628                                           src.toString(), dst.toString());
629                         throw new RuntimeException(&quot;CHECK FAILED!&quot;);
630                     }
631                     nSrc--;
632                 }
633                 bbSrc.flip();
634                 bbDst.flip();
635             }
636         } catch (IOException x) {
637             x.printStackTrace();
638         }
639     }
640 
<span class="line-modified">641     private static void fchCopy(Path src, Path dst) throws IOException</span>
<span class="line-modified">642     {</span>



643         Set&lt;OpenOption&gt; read = new HashSet&lt;&gt;();
644         read.add(READ);
645         Set&lt;OpenOption&gt; openwrite = new HashSet&lt;&gt;();
646         openwrite.add(CREATE_NEW);
647         openwrite.add(WRITE);
648 
649         try (FileChannel srcFc = src.getFileSystem().provider().newFileChannel(src, read);
650              FileChannel dstFc = dst.getFileSystem().provider().newFileChannel(dst, openwrite))
651         {
652             ByteBuffer bb = ByteBuffer.allocate(8192);
653             while (srcFc.read(bb) &gt;= 0) {
654                 bb.flip();
655                 dstFc.write(bb);
656                 bb.clear();
657             }
658         }
659     }
660 
<span class="line-modified">661     private static void chCopy(Path src, Path dst) throws IOException</span>
<span class="line-modified">662     {</span>



663         Set&lt;OpenOption&gt; read = new HashSet&lt;&gt;();
664         read.add(READ);
665         Set&lt;OpenOption&gt; openwrite = new HashSet&lt;&gt;();
666         openwrite.add(CREATE_NEW);
667         openwrite.add(WRITE);
668 
669         try (SeekableByteChannel srcCh = Files.newByteChannel(src, read);
670              SeekableByteChannel dstCh = Files.newByteChannel(dst, openwrite))
671         {
672             ByteBuffer bb = ByteBuffer.allocate(8192);
673             while (srcCh.read(bb) &gt;= 0) {
674                 bb.flip();
675                 dstCh.write(bb);
676                 bb.clear();
677             }
678         }
679     }
680 
<span class="line-modified">681     private static void streamCopy(Path src, Path dst) throws IOException</span>
<span class="line-modified">682     {</span>



683         byte[] buf = new byte[8192];
684         try (InputStream isSrc = Files.newInputStream(src);
685              OutputStream osDst = Files.newOutputStream(dst))
686         {
687             int n = 0;
688             while ((n = isSrc.read(buf)) != -1) {
689                 osDst.write(buf, 0, n);
690             }
691         }
692     }
693 }
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2010, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 import java.io.*;
 25 import java.nio.*;
 26 import java.nio.channels.*;
 27 import java.nio.file.*;
 28 import java.nio.file.spi.*;
 29 import java.nio.file.attribute.*;

 30 import java.text.DateFormat;
 31 import java.text.SimpleDateFormat;
 32 import java.util.*;
 33 
 34 import static java.nio.file.StandardOpenOption.*;
 35 import static java.nio.file.StandardCopyOption.*;
 36 
 37 /*
 38  * ZipFileSystem usage demo
 39  *
 40  * java Demo action ZipfileName [...]
 41  *
 42  * @author Xueming Shen
 43  */
 44 
 45 public class Demo {
 46 
 47     static enum Action {
 48         rename,          // &lt;java Demo rename zipfile src dst&gt;
 49                          // rename entry src to dst inside zipfile
</pre>
<hr />
<pre>
 80 
 81         attrs,           // &lt;java Demo attrs zipfile path&gt;
 82                          // printout the attributes of entry path
 83 
 84         attrsspace,      // &lt;java Demo attrsspace zipfile path&gt;
 85                          // printout the storespace attrs of entry path
 86 
 87         setmtime,        // &lt;java Demo setmtime zipfile &quot;MM/dd/yy-HH:mm:ss&quot; path...&gt;
 88                          // set the lastModifiedTime of entry path
 89 
 90         setatime,        // &lt;java Demo setatime zipfile &quot;MM/dd/yy-HH:mm:ss&quot; path...&gt;
 91         setctime,        // &lt;java Demo setctime zipfile &quot;MM/dd/yy-HH:mm:ss&quot; path...&gt;
 92 
 93         lsdir,           // &lt;java Demo lsdir zipfile dir&gt;
 94                          // list dir&#39;s direct child files/dirs
 95 
 96         mkdir,           // &lt;java Demo mkdir zipfile dir&gt;
 97 
 98         mkdirs,          // &lt;java Demo mkdirs zipfile dir&gt;
 99 


100         list,            // &lt;java Demo list zipfile [dir]&gt;
101                          // recursively list all entries of dir
102                          // via DirectoryStream
103 
104         tlist,           // &lt;java Demo tlist zipfile [dir]&gt;
105                          // list with buildDirTree=true
106 
107         vlist,           // &lt;java Demo vlist zipfile [dir]&gt;
108                          // recursively verbose list all entries of
109                          // dir via DirectoryStream
110 
111         walk,            // &lt;java Demo walk zipfile [dir]&gt;
112                          // recursively walk all entries of dir
113                          // via Files.walkFileTree
114 
115         twalk,           // &lt;java Demo twalk zipfile [dir]&gt;
116                          // walk with buildDirTree=true
117 
118         extract,         // &lt;java Demo extract zipfile file [...]&gt;
119 
</pre>
<hr />
<pre>
124         add,             // &lt;java Demo add zipfile file [...]&gt;
125 
126         create,          // &lt;java Demo create zipfile file [...]&gt;
127                          // create a new zipfile if it doesn&#39;t exit
128                          // and then add the file(s) into it.
129 
130         attrs2,          // &lt;java Demo attrs2 zipfile file [...]&gt;
131                          // test different ways to print attrs
132 
133         prof,
134     }
135 
136     public static void main(String[] args) throws Throwable {
137         FileSystemProvider provider = getZipFSProvider();
138         if (provider == null) {
139             System.err.println(&quot;ZIP filesystem provider is not installed&quot;);
140             System.exit(1);
141         }
142 
143         Action action = Action.valueOf(args[0]);
<span class="line-modified">144         Map&lt;String, Object&gt; env = new HashMap&lt;&gt;();</span>
145         if (action == Action.create)
146             env.put(&quot;create&quot;, &quot;true&quot;);
147         try (FileSystem fs = provider.newFileSystem(Paths.get(args[1]), env)) {
148             Path path, src, dst;
149             switch (action) {
150             case rename:
151                 src = fs.getPath(args[2]);
152                 dst = fs.getPath(args[3]);
153                 Files.move(src, dst);
154                 break;
155             case moveout:
156                 src = fs.getPath(args[2]);
157                 dst = Paths.get(args[3]);
158                 Files.move(src, dst);
159                 break;
160             case movein:
161                 src = Paths.get(args[2]);
162                 dst = fs.getPath(args[3]);
163                 Files.move(src, dst);
164                 break;
</pre>
<hr />
<pre>
514                     Files.delete(dir);
515                 } catch (IOException x) {
516                     //x.printStackTrace();
517                 }
518                 return FileVisitResult.CONTINUE;
519             }
520         });
521 
522     }
523 
524     private static void mkdirs(Path path) throws IOException {
525         path = path.toAbsolutePath();
526         Path parent = path.getParent();
527         if (parent != null) {
528             if (Files.notExists(parent))
529                 mkdirs(parent);
530         }
531         Files.createDirectory(path);
532     }
533 

534     /**
535      * Not used in demo, but included for demonstrational purposes.
536      */
<span class="line-added">537     @SuppressWarnings(&quot;unused&quot;)</span>
538     private static void rmdirs(Path path) throws IOException {
539         while (path != null &amp;&amp; path.getNameCount() != 0) {
540             Files.delete(path);
541             path = path.getParent();
542         }
543     }
544 
545     private static void list(Path path, boolean verbose ) throws IOException {
546         if (!&quot;/&quot;.equals(path.toString())) {
547            System.out.printf(&quot;  %s%n&quot;, path.toString());
548            if (verbose)
549                 System.out.println(Files.readAttributes(path, BasicFileAttributes.class).toString());
550         }
551         if (Files.notExists(path))
552             return;
553         if (Files.isDirectory(path)) {
554             try (DirectoryStream&lt;Path&gt; ds = Files.newDirectoryStream(path)) {
555                 for (Path child : ds)
556                     list(child, verbose);
557             }
558         }
559     }
560 

561     /**
562      * Checks that the content of two paths are equal.
563      * Not used in demo, but included for demonstrational purposes.
564      */
<span class="line-added">565     @SuppressWarnings(&quot;unused&quot;)</span>
566     private static void checkEqual(Path src, Path dst) throws IOException
567     {
568         //System.out.printf(&quot;checking &lt;%s&gt; vs &lt;%s&gt;...%n&quot;,
569         //                  src.toString(), dst.toString());
570 
571         //streams
572         byte[] bufSrc = new byte[8192];
573         byte[] bufDst = new byte[8192];
574         try (InputStream isSrc = Files.newInputStream(src);
575              InputStream isDst = Files.newInputStream(dst))
576         {
577             int nSrc = 0;
578             while ((nSrc = isSrc.read(bufSrc)) != -1) {
579                 int nDst = 0;
580                 while (nDst &lt; nSrc) {
581                     int n = isDst.read(bufDst, nDst, nSrc - nDst);
582                     if (n == -1) {
583                         System.out.printf(&quot;checking &lt;%s&gt; vs &lt;%s&gt;...%n&quot;,
584                                           src.toString(), dst.toString());
585                         throw new RuntimeException(&quot;CHECK FAILED!&quot;);
</pre>
<hr />
<pre>
618                     System.out.printf(&quot;checking &lt;%s&gt; vs &lt;%s&gt;...%n&quot;,
619                                       src.toString(), dst.toString());
620                     throw new RuntimeException(&quot;CHECK FAILED!&quot;);
621                 }
622                 while (--nSrc &gt;= 0) {
623                     if (bbSrc.get(nSrc) != bbDst.get(nSrc)) {
624                         System.out.printf(&quot;checking &lt;%s&gt; vs &lt;%s&gt;...%n&quot;,
625                                           src.toString(), dst.toString());
626                         throw new RuntimeException(&quot;CHECK FAILED!&quot;);
627                     }
628                     nSrc--;
629                 }
630                 bbSrc.flip();
631                 bbDst.flip();
632             }
633         } catch (IOException x) {
634             x.printStackTrace();
635         }
636     }
637 
<span class="line-modified">638     /**</span>
<span class="line-modified">639      * Not used in demo, but included for demonstrational purposes.</span>
<span class="line-added">640      */</span>
<span class="line-added">641     @SuppressWarnings(&quot;unused&quot;)</span>
<span class="line-added">642     private static void fchCopy(Path src, Path dst) throws IOException {</span>
643         Set&lt;OpenOption&gt; read = new HashSet&lt;&gt;();
644         read.add(READ);
645         Set&lt;OpenOption&gt; openwrite = new HashSet&lt;&gt;();
646         openwrite.add(CREATE_NEW);
647         openwrite.add(WRITE);
648 
649         try (FileChannel srcFc = src.getFileSystem().provider().newFileChannel(src, read);
650              FileChannel dstFc = dst.getFileSystem().provider().newFileChannel(dst, openwrite))
651         {
652             ByteBuffer bb = ByteBuffer.allocate(8192);
653             while (srcFc.read(bb) &gt;= 0) {
654                 bb.flip();
655                 dstFc.write(bb);
656                 bb.clear();
657             }
658         }
659     }
660 
<span class="line-modified">661     /**</span>
<span class="line-modified">662      * Not used in demo, but included for demonstrational purposes.</span>
<span class="line-added">663      */</span>
<span class="line-added">664     @SuppressWarnings(&quot;unused&quot;)</span>
<span class="line-added">665     private static void chCopy(Path src, Path dst) throws IOException {</span>
666         Set&lt;OpenOption&gt; read = new HashSet&lt;&gt;();
667         read.add(READ);
668         Set&lt;OpenOption&gt; openwrite = new HashSet&lt;&gt;();
669         openwrite.add(CREATE_NEW);
670         openwrite.add(WRITE);
671 
672         try (SeekableByteChannel srcCh = Files.newByteChannel(src, read);
673              SeekableByteChannel dstCh = Files.newByteChannel(dst, openwrite))
674         {
675             ByteBuffer bb = ByteBuffer.allocate(8192);
676             while (srcCh.read(bb) &gt;= 0) {
677                 bb.flip();
678                 dstCh.write(bb);
679                 bb.clear();
680             }
681         }
682     }
683 
<span class="line-modified">684     /**</span>
<span class="line-modified">685      * Not used in demo, but included for demonstrational purposes.</span>
<span class="line-added">686      */</span>
<span class="line-added">687     @SuppressWarnings(&quot;unused&quot;)</span>
<span class="line-added">688     private static void streamCopy(Path src, Path dst) throws IOException {</span>
689         byte[] buf = new byte[8192];
690         try (InputStream isSrc = Files.newInputStream(src);
691              OutputStream osDst = Files.newOutputStream(dst))
692         {
693             int n = 0;
694             while ((n = isSrc.read(buf)) != -1) {
695                 osDst.write(buf, 0, n);
696             }
697         }
698     }
699 }
</pre>
</td>
</tr>
</table>
<center><a href="Basic.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="PathOps.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
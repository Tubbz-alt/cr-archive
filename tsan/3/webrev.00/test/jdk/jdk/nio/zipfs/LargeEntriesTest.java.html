<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New test/jdk/jdk/nio/zipfs/LargeEntriesTest.java</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 import org.testng.annotations.*;
 26 
 27 import java.io.*;
 28 import java.nio.charset.StandardCharsets;
 29 import java.nio.file.FileSystem;
 30 import java.nio.file.*;
 31 import java.security.SecureRandom;
 32 import java.util.Arrays;
 33 import java.util.Map;
 34 import java.util.function.Consumer;
 35 import java.util.zip.ZipEntry;
 36 import java.util.zip.ZipFile;
 37 
 38 import static java.lang.Boolean.TRUE;
 39 import static java.lang.String.format;
 40 import static java.util.stream.Collectors.joining;
 41 import static org.testng.Assert.*;
 42 
 43 /**
 44  * @test
 45  * @bug 8230870
 46  * @summary Test ZIP Filesystem behavior with ~64k entries
 47  * @modules jdk.zipfs
 48  * @run testng LargeEntriesTest
 49  */
 50 public class LargeEntriesTest {
 51 
 52     private static final Path HERE = Path.of(&quot;.&quot;);
 53 
 54     /**
 55      * Number of ZIP entries which results in the use of ZIP64
 56      */
 57     private static final int ZIP64_ENTRIES = 65535;
 58 
 59     /**
 60      * Classes and MANIFEST attribute used for invoking Main via java -jar
 61      */
 62     private static final String MANIFEST_MAIN_CLASS = &quot;LargeEntriesTest$Main&quot;;
 63     private static final String MAIN_CLASS = &quot;LargeEntriesTest$Main.class&quot;;
 64     private static final String THIS_CLASS = &quot;LargeEntriesTest.class&quot;;
 65 
 66     /**
 67      * Number of entries included in the JAR file including  META-INF,
 68      * MANIFEST.MF, and the classes associated with this test
 69      */
 70     private static final int ADDITIONAL_JAR_ENTRIES = 4;
 71 
 72     /**
 73      * Value used for creating the required entries in a ZIP or JAR file
 74      */
 75     private static final String ZIP_FILE_VALUE = &quot;US Open 2019&quot;;
 76     private static final byte[] ZIP_FILE_ENTRY =
 77             ZIP_FILE_VALUE.getBytes(StandardCharsets.UTF_8);
 78 
 79     /**
 80      * Location of the classes to be added to the JAR file
 81      */
 82     static final Path TEST_CLASSES = Paths.get(System.getProperty(&quot;test.classes&quot;, &quot;.&quot;));
 83 
 84     private static final SecureRandom random = new SecureRandom();
 85 
 86     /**
 87      * Fields used for timing runs
 88      */
 89     private static int testNumberRunning;
 90     private static long runningTestTime;
 91     private static long startTestRunTime;
 92     private static final double NANOS_IN_SECOND = 1_000_000_000.0;
 93 
 94     @BeforeTest(enabled = false)
 95     public void beforeTest() {
 96         startTestRunTime = System.nanoTime();
 97     }
 98 
 99     @AfterTest(enabled = false)
100     public void afterTest() {
101         long endTestRunTime = System.nanoTime();
102         long duration = endTestRunTime - startTestRunTime;
103         System.out.printf(&quot;#### Completed test run, total running time: %.4f in seconds%n&quot;,
104                 duration / NANOS_IN_SECOND);
105     }
106 
107     @BeforeMethod(enabled = false)
108     public static void beforeMethod() {
109         runningTestTime = System.nanoTime();
110         System.out.printf(&quot;**** Starting test number: %s%n&quot;, testNumberRunning);
111     }
112 
113     @AfterMethod(enabled = false)
114     public void afterMethod() {
115         long endRunningTestTime = System.nanoTime();
116         long duration = endRunningTestTime - runningTestTime;
117         System.out.printf(&quot;**** Completed test number: %s, Time: %.4f%n&quot;,
118                 testNumberRunning, duration / NANOS_IN_SECOND);
119         testNumberRunning++;
120     }
121 
122     /**
123      * Validate that you can create a ZIP file with and without compression
124      * and that the ZIP file is created using ZIP64 if there are 65535 or
125      * more entries.
126      *
127      * @param env         Properties used for creating the ZIP Filesystem
128      * @param compression Indicates whether the files are DEFLATED(default)
129      *                    or STORED
130      * @throws Exception If an error occurs during the creation, verification or
131      *                   deletion of the ZIP file
132      */
133     @Test(dataProvider = &quot;zipfsMap&quot;, enabled = true)
134     public void testZip(Map&lt;String, String&gt; env, int compression) throws Exception {
135 
136         System.out.printf(&quot;ZIP FS Map = %s, Compression mode= %s%n &quot;,
137                 formatMap(env), compression);
138 
139         for (int entries = ZIP64_ENTRIES - 1; entries &lt; ZIP64_ENTRIES + 2; entries++) {
140             Path zipfile = generatePath(HERE, &quot;test&quot;, &quot;.zip&quot;);
141             Files.deleteIfExists(zipfile);
142             createZipFile(zipfile, env, entries);
143             verify(zipfile, compression, entries,
144                     isTrue(env, &quot;forceZIP64End&quot;), 0);
145             Files.deleteIfExists(zipfile);
146         }
147     }
148 
149     /**
150      * Validate that when the forceZIP64End property is set to true,
151      * that ZIP64 is used.
152      *
153      * @param env         Properties used for creating the ZIP Filesystem
154      * @param compression Indicates whether the files are DEFLATED(default)
155      *                    or STORED
156      * @throws Exception If an error occurs during the creation, verification or
157      *                   deletion of the ZIP file
158      */
159     @Test(dataProvider = &quot;zip64Map&quot;, enabled = true)
160     public void testForceZIP64End(Map&lt;String, String&gt; env, int compression) throws Exception {
161 
162         System.out.printf(&quot;ZIP FS Map = %s, Compression mode= %s%n &quot;,
163                 formatMap(env), compression);
164 
165         // Generate a ZIP file path
166         Path zipfile = generatePath(HERE, &quot;test&quot;, &quot;.zip&quot;);
167         Files.deleteIfExists(zipfile);
168         createZipFile(zipfile, env, 1);
169         verify(zipfile, compression, 1, isTrue(env, &quot;forceZIP64End&quot;), 0);
170         Files.deleteIfExists(zipfile);
171     }
172 
173     /**
174      * Validate that you can create a JAR file with and without compression
175      * and that the JAR file is created using ZIP64 if there are 65535 or
176      * more entries.
177      *
178      * @param env         Properties used for creating the ZIP Filesystem
179      * @param compression Indicates whether the files are DEFLATED(default)
180      *                    or STORED
181      * @throws Exception If an error occurs during the creation, verification or
182      *                   deletion of the JAR file
183      */
184     @Test(dataProvider = &quot;zipfsMap&quot;, enabled = true)
185     public void testJar(Map&lt;String, String&gt; env, int compression) throws Exception {
186         for (int entries = ZIP64_ENTRIES - 1; entries &lt; ZIP64_ENTRIES + 2; entries++) {
187             Path jar = generatePath(HERE, &quot;test&quot;, &quot;.jar&quot;);
188 
189             Files.deleteIfExists(jar);
190             createJarFile(jar, env, entries);
191 
192             // Now run the Main-Class specified the Manifest
193             runJar(jar.getFileName().toString()).assertSuccess()
194                     .validate(r -&gt; assertTrue(r.output.matches(&quot;\\AMain\\Z&quot;)));
195 
196             verify(jar, compression, entries, isTrue(env, &quot;forceZIP64End&quot;),
197                     ADDITIONAL_JAR_ENTRIES);
198             Files.deleteIfExists(jar);
199         }
200     }
201 
202     /**
203      * Create a ZIP File System using the specified properties and a ZIP file
204      * with the specified number of entries
205      *
206      * @param zipFile Path to the ZIP File to create
207      * @param env     Properties used for creating the ZIP Filesystem
208      * @param entries Number of entries to add to the ZIP File
209      * @throws IOException If an error occurs while creating the ZIP file
210      */
211     private void createZipFile(Path zipFile, Map&lt;String, String&gt; env,
212                                int entries) throws IOException {
213         System.out.printf(&quot;Creating file = %s%n&quot;, zipFile);
214         try (FileSystem zipfs =
215                      FileSystems.newFileSystem(zipFile, env)) {
216 
217             for (int i = 0; i &lt; entries; i++) {
218                 Files.writeString(zipfs.getPath(&quot;Entry-&quot; + i), ZIP_FILE_VALUE);
219             }
220         }
221     }
222 
223     /**
224      * Create a ZIP File System using the specified properties and a JAR file
225      * with the specified number of entries
226      *
227      * @param zipFile Path to the JAR File to create
228      * @param env     Properties used for creating the ZIP Filesystem
229      * @param entries Number of entries to add to the JAR File
230      * @throws IOException If an error occurs while creating the JAR file
231      */
232     private void createJarFile(Path zipFile, Map&lt;String, String&gt; env,
233                                int entries) throws IOException {
234         System.out.printf(&quot;Creating file = %s%n&quot;, zipFile);
235         String jdkVendor = System.getProperty(&quot;java.vendor&quot;);
236         String jdkVersion = System.getProperty(&quot;java.version&quot;);
237         String manifest = &quot;Manifest-Version: 1.0&quot;
238                 + System.lineSeparator()
239                 + &quot;Main-Class: &quot; + MANIFEST_MAIN_CLASS
240                 + System.lineSeparator()
241                 + &quot;Created-By: &quot; + jdkVersion + &quot; (&quot; + jdkVendor + &quot;)&quot;;
242 
243         try (FileSystem zipfs =
244                      FileSystems.newFileSystem(zipFile, env);
245              InputStream in = new ByteArrayInputStream(manifest.getBytes())) {
246 
247             // Get ZIP FS path to META-INF/MANIFEST.MF
248             Path metadir = zipfs.getPath(&quot;/&quot;, &quot;META-INF&quot;);
249             Path manifestFile = metadir.resolve(&quot;MANIFEST.MF&quot;);
250 
251             // Create META-INF directory if it does not already exist and
252             // add the MANIFEST.MF file
253             if (!Files.exists(metadir))
254                 Files.createDirectory(zipfs.getPath(&quot;/&quot;, &quot;META-INF&quot;));
255             Files.copy(in, manifestFile);
256 
257             // Add the needed test classes
258             Path target = zipfs.getPath(&quot;/&quot;);
259             Files.copy(TEST_CLASSES.resolve(MAIN_CLASS),
260                     target.resolve(MAIN_CLASS));
261             Files.copy(TEST_CLASSES.resolve(THIS_CLASS),
262                     target.resolve(THIS_CLASS));
263 
264             // Add the remaining entries that are required
265             for (int i = ADDITIONAL_JAR_ENTRIES; i &lt; entries; i++) {
266                 Files.writeString(zipfs.getPath(&quot;Entry-&quot; + i), ZIP_FILE_VALUE);
267             }
268         }
269     }
270 
271     /*
272      * DataProvider used to validate that you can create a ZIP file with and
273      * without compression.
274      */
275     @DataProvider(name = &quot;zipfsMap&quot;)
276     private Object[][] zipfsMap() {
277         return new Object[][]{
278                 {Map.of(&quot;create&quot;, &quot;true&quot;), ZipEntry.DEFLATED},
279                 {Map.of(&quot;create&quot;, &quot;true&quot;, &quot;noCompression&quot;, &quot;true&quot;),
280                         ZipEntry.STORED},
281                 {Map.of(&quot;create&quot;, &quot;true&quot;, &quot;noCompression&quot;, &quot;false&quot;),
282                         ZipEntry.DEFLATED}
283         };
284     }
285 
286     /*
287      * DataProvider used to validate that you can create a ZIP file with/without
288      * ZIP64 format extensions
289      */
290     @DataProvider(name = &quot;zip64Map&quot;)
291     private Object[][] zip64Map() {
292         return new Object[][]{
293                 {Map.of(&quot;create&quot;, &quot;true&quot;, &quot;forceZIP64End&quot;, &quot;true&quot;),
294                         ZipEntry.DEFLATED},
295                 {Map.of(&quot;create&quot;, &quot;true&quot;, &quot;noCompression&quot;, &quot;true&quot;,
296                         &quot;forceZIP64End&quot;, &quot;true&quot;), ZipEntry.STORED},
297                 {Map.of(&quot;create&quot;, &quot;true&quot;, &quot;noCompression&quot;, &quot;false&quot;,
298                         &quot;forceZIP64End&quot;, &quot;false&quot;), ZipEntry.DEFLATED},
299                 {Map.of(&quot;create&quot;, &quot;true&quot;, &quot;noCompression&quot;, &quot;true&quot;,
300                         &quot;forceZIP64End&quot;, &quot;false&quot;), ZipEntry.STORED}
301         };
302     }
303 
304     /**
305      * Verify that the given path is a ZIP file containing the
306      * expected entries.
307      *
308      * @param zipfile       ZIP file to be validated
309      * @param method        Expected Compression method: STORED or DEFLATED
310      * @param entries       Number of expected entries
311      * @param isZip64Forced true if ZIP64 use is being forced; false otherwise
312      * @param start         Starting number for verifying entries
313      * @throws Exception If an error occurs while examining the ZIP file
314      */
315     private static void verify(Path zipfile, int method, int entries,
316                                boolean isZip64Forced, int start) throws Exception {
317         // check entries with ZIP API
318         try (ZipFile zf = new ZipFile(zipfile.toFile())) {
319             // check entry count
320             assertEquals(entries, zf.size());
321 
322             // check compression method and content of each entry
323             for (int i = start; i &lt; entries; i++) {
324                 ZipEntry ze = zf.getEntry(&quot;Entry-&quot; + i);
325                 assertNotNull(ze);
326                 assertEquals(method, ze.getMethod());
327                 try (InputStream is = zf.getInputStream(ze)) {
328                     byte[] bytes = is.readAllBytes();
329                     assertTrue(Arrays.equals(bytes, ZIP_FILE_ENTRY));
330                 }
331             }
332         }
333         // check entries with FileSystem API
334         try (FileSystem fs = FileSystems.newFileSystem(zipfile)) {
335 
336             // check entry count
337             Path top = fs.getPath(&quot;/&quot;);
338             long count = Files.find(top, Integer.MAX_VALUE, (path, attrs) -&gt;
339                     attrs.isRegularFile() || (attrs.isDirectory() &amp;&amp;
340                             path.getFileName() != null &amp;&amp;
341                             path.getFileName().toString().equals(&quot;META-INF&quot;)))
342                     .count();
343             assertEquals(entries, count);
344 
345             // check content of each entry
346             for (int i = start; i &lt; entries; i++) {
347                 Path file = fs.getPath(&quot;Entry-&quot; + i);
348                 byte[] bytes = Files.readAllBytes(file);
349                 assertTrue(Arrays.equals(bytes, ZIP_FILE_ENTRY));
350             }
351         }
352 
353         // Check for a ZIP64 End of Central Directory Locator
354         boolean foundZip64 = usesZip64(zipfile.toFile());
355 
356         // Is ZIP64 required?
357         boolean requireZip64 = entries &gt;= ZIP64_ENTRIES || isZip64Forced;
358         System.out.printf(&quot; isZip64Forced = %s, foundZip64= %s, requireZip64= %s%n&quot;,
359                 isZip64Forced, foundZip64, requireZip64);
360         assertEquals(requireZip64, foundZip64);
361 
362 
363     }
364 
365     /**
366      * Determine if the specified property name=true/&quot;true&quot;
367      *
368      * @param env  ZIP Filesystem Map
369      * @param name property to validate
370      * @return true if the property value is set to true/&quot;true&quot;; false otherwise
371      */
372     private static boolean isTrue(Map&lt;String, ?&gt; env, String name) {
373         return &quot;true&quot;.equals(env.get(name)) || TRUE.equals(env.get(name));
374     }
375 
376     /**
377      * Check to see if the ZIP64 End of Central Directory Locator has been found
378      *
379      * @param b byte array to check for the locator in
380      * @param n starting offset for the search
381      * @return true if the Zip64 End of Central Directory Locator is found; false
382      * otherwise
383      */
384     private static boolean end64SigAt(byte[] b, int n) {
385         return b[n] == &#39;P&#39; &amp; b[n + 1] == &#39;K&#39; &amp; b[n + 2] == 6 &amp; b[n + 3] == 6;
386     }
387 
388     /**
389      * Utility method that checks the ZIP file for the use of the ZIP64
390      * End of Central Directory Locator
391      *
392      * @param zipFile ZIP file to check
393      * @return true if the ZIP64 End of Central Directory Locator is found; false
394      * otherwise
395      * * @throws Exception If an error occurs while traversing the file
396      */
397     private static boolean usesZip64(File zipFile) throws Exception {
398 
399         try (RandomAccessFile raf = new RandomAccessFile(zipFile, &quot;r&quot;)) {
400             byte[] buf = new byte[4096];
401             long seeklen = raf.length() - buf.length;
402 
403             if (seeklen &lt; 0)
404                 seeklen = 0;
405             raf.seek(seeklen);
406             raf.read(buf);
407             for (int i = 0; i &lt; buf.length - 4; i++) {
408                 // Is there a ZIP64 End of Central Directory Locator?
409                 if (end64SigAt(buf, i)) {
410                     return true;
411                 }
412             }
413         }
414         return false;
415     }
416 
417     /**
418      * Generate a temporary file Path
419      *
420      * @param dir    Directory used to create the path
421      * @param prefix The prefix string used to create the path
422      * @param suffix The suffix string used to create the path
423      * @return Path that was generated
424      */
425     private static Path generatePath(Path dir, String prefix, String suffix) {
426         long n = random.nextLong();
427         String s = prefix + Long.toUnsignedString(n) + suffix;
428         Path name = dir.getFileSystem().getPath(s);
429         // the generated name should be a simple file name
430         if (name.getParent() != null)
431             throw new IllegalArgumentException(&quot;Invalid prefix or suffix&quot;);
432         return dir.resolve(name);
433     }
434 
435     /**
436      * Utility method to return a formatted String of the key:value entries for
437      * a Map
438      *
439      * @param env Map to format
440      * @return Formatted string of the Map entries
441      */
442     private static String formatMap(Map&lt;String, String&gt; env) {
443         return env.entrySet().stream()
444                 .map(e -&gt; format(&quot;(%s:%s)&quot;, e.getKey(), e.getValue()))
445                 .collect(joining(&quot;, &quot;));
446     }
447 
448     /**
449      * Validates that a jar created using ZIP FS can be used by the java
450      * tool to run a program specified in the Main-Class Manifest attribute
451      *
452      * @param jarFile Name of the JAR file to specify to the -jar option
453      * @return A Result object representing the return code and output from the
454      * program that was invoked
455      */
456     private static Result runJar(String jarFile) {
457         String javaHome = System.getProperty(&quot;java.home&quot;);
458         String java = Paths.get(javaHome, &quot;bin&quot;, &quot;java&quot;).toString();
459         String[] cmd = {java, &quot;-jar&quot;, jarFile};
460         String output;
461         ProcessBuilder pb = new ProcessBuilder(cmd);
462         Process p;
463         try {
464             p = pb.start();
465             output = toString(p.getInputStream(), p.getErrorStream());
466             p.waitFor();
467         } catch (IOException | InterruptedException e) {
468             throw new RuntimeException(
469                     format(&quot;Error invoking: &#39;%s&#39;, Exception= %s&quot;, pb.command(), e));
470         }
471 
472         return new Result(p.exitValue(), output);
473     }
474 
475     /**
476      * Utility method to combine the output and error streams for the Process
477      * started by ProcessBuilder
478      *
479      * @param is  Process Outputstream
480      * @param is2 Process ErrorStream
481      * @return String representing the combination of the OutputStream &amp; ErrorStream
482      * @throws IOException If an error occurs while combining the streams
483      */
484     private static String toString(InputStream is, InputStream is2) throws IOException {
485         try (ByteArrayOutputStream dst = new ByteArrayOutputStream();
486              InputStream concatenated = new SequenceInputStream(is, is2)) {
487             concatenated.transferTo(dst);
488             return new String(dst.toByteArray(), StandardCharsets.UTF_8);
489         }
490     }
491 
492     /**
493      * Wrapper class used to verify the results from a ProcessBuilder invocation
494      */
495     private static class Result {
496         final int ec;         // Return code for command that was executed
497         final String output;  // Output from the command that was executed
498 
499         /**
500          * Constructor
501          *
502          * @param ec     Return code from the ProcessBuilder invocation
503          * @param output ProcessBuilder output to be validated
504          */
505         private Result(int ec, String output) {
506             this.ec = ec;
507             this.output = output;
508         }
509 
510         /**
511          * Validate that the command that was executed completed successfully
512          *
513          * @return This Result object
514          */
515         Result assertSuccess() {
516             assertEquals(ec, 0, format(&quot;Expected ec 0, received: %s, output [%s]&quot;, ec, output));
517             return this;
518         }
519 
520         /**
521          * Validate that the expected result is received
522          *
523          * @param r The operation to perform
524          * @return This Result object
525          */
526         Result validate(Consumer&lt;Result&gt; r) {
527             r.accept(this);
528             return this;
529         }
530     }
531 
532     /**
533      * Trivial class used to validate that a JAR created using ZIP FS
534      * can be successfully executed
535      */
536     public static class Main {
537         public static void main(String[] args) {
538             System.out.print(&quot;Main&quot;);
539         }
540     }
541 }
    </pre>
  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames test/jdk/jdk/nio/zipfs/Demo.java</title>
    <link rel="stylesheet" href="../../../../../style.css" />
    <script type="text/javascript" src="../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
<a name="1" id="anc1"></a><span class="line-modified">  2  * Copyright (c) 2010, 2014, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 import java.io.*;
 25 import java.nio.*;
 26 import java.nio.channels.*;
 27 import java.nio.file.*;
 28 import java.nio.file.spi.*;
 29 import java.nio.file.attribute.*;
<a name="2" id="anc2"></a><span class="line-removed"> 30 import java.net.*;</span>
 31 import java.text.DateFormat;
 32 import java.text.SimpleDateFormat;
 33 import java.util.*;
 34 
 35 import static java.nio.file.StandardOpenOption.*;
 36 import static java.nio.file.StandardCopyOption.*;
 37 
 38 /*
 39  * ZipFileSystem usage demo
 40  *
 41  * java Demo action ZipfileName [...]
 42  *
 43  * @author Xueming Shen
 44  */
 45 
 46 public class Demo {
 47 
 48     static enum Action {
 49         rename,          // &lt;java Demo rename zipfile src dst&gt;
 50                          // rename entry src to dst inside zipfile
 51 
 52         movein,          // &lt;java Demo movein zipfile src dst&gt;
 53                          // move an external src file into zipfile
 54                          // as entry dst
 55 
 56         moveout,         // &lt;java Demo moveout zipfile src dst&gt;
 57                          // move a zipfile entry src out to dst
 58 
 59         copy,            // &lt;java Demo copy zipfile src dst&gt;
 60                          // copy entry src to dst inside zipfile
 61 
 62         copyin,          // &lt;java Demo copyin zipfile src dst&gt;
 63                          // copy an external src file into zipfile
 64                          // as entry dst
 65 
 66         copyin_attrs,    // &lt;java Demo copyin_attrs zipfile src dst&gt;
 67                          // copy an external src file into zipfile
 68                          // as entry dst, with attributes (timestamp)
 69 
 70         copyout,         // &lt;java Demo copyout zipfile src dst&gt;
 71                          // copy zipfile entry src&quot; out to file dst
 72 
 73         copyout_attrs,   // &lt;java Demo copyout_attrs zipfile src dst&gt;
 74 
 75         zzmove,          // &lt;java Demo zzmove zfsrc zfdst path&gt;
 76                          // move entry path/dir from zfsrc to zfdst
 77 
 78         zzcopy,          // &lt;java Demo zzcopy zfsrc zfdst path&gt;
 79                          // copy path from zipfile zfsrc to zipfile
 80                          // zfdst
 81 
 82         attrs,           // &lt;java Demo attrs zipfile path&gt;
 83                          // printout the attributes of entry path
 84 
 85         attrsspace,      // &lt;java Demo attrsspace zipfile path&gt;
 86                          // printout the storespace attrs of entry path
 87 
 88         setmtime,        // &lt;java Demo setmtime zipfile &quot;MM/dd/yy-HH:mm:ss&quot; path...&gt;
 89                          // set the lastModifiedTime of entry path
 90 
 91         setatime,        // &lt;java Demo setatime zipfile &quot;MM/dd/yy-HH:mm:ss&quot; path...&gt;
 92         setctime,        // &lt;java Demo setctime zipfile &quot;MM/dd/yy-HH:mm:ss&quot; path...&gt;
 93 
 94         lsdir,           // &lt;java Demo lsdir zipfile dir&gt;
 95                          // list dir&#39;s direct child files/dirs
 96 
 97         mkdir,           // &lt;java Demo mkdir zipfile dir&gt;
 98 
 99         mkdirs,          // &lt;java Demo mkdirs zipfile dir&gt;
100 
<a name="3" id="anc3"></a><span class="line-removed">101         rmdirs,          // &lt;java Demo rmdirs zipfile dir&gt;</span>
<span class="line-removed">102 </span>
103         list,            // &lt;java Demo list zipfile [dir]&gt;
104                          // recursively list all entries of dir
105                          // via DirectoryStream
106 
107         tlist,           // &lt;java Demo tlist zipfile [dir]&gt;
108                          // list with buildDirTree=true
109 
110         vlist,           // &lt;java Demo vlist zipfile [dir]&gt;
111                          // recursively verbose list all entries of
112                          // dir via DirectoryStream
113 
114         walk,            // &lt;java Demo walk zipfile [dir]&gt;
115                          // recursively walk all entries of dir
116                          // via Files.walkFileTree
117 
118         twalk,           // &lt;java Demo twalk zipfile [dir]&gt;
119                          // walk with buildDirTree=true
120 
121         extract,         // &lt;java Demo extract zipfile file [...]&gt;
122 
123         update,          // &lt;java Demo extract zipfile file [...]&gt;
124 
125         delete,          // &lt;java Demo delete zipfile file [...]&gt;
126 
127         add,             // &lt;java Demo add zipfile file [...]&gt;
128 
129         create,          // &lt;java Demo create zipfile file [...]&gt;
130                          // create a new zipfile if it doesn&#39;t exit
131                          // and then add the file(s) into it.
132 
133         attrs2,          // &lt;java Demo attrs2 zipfile file [...]&gt;
134                          // test different ways to print attrs
135 
136         prof,
137     }
138 
139     public static void main(String[] args) throws Throwable {
140         FileSystemProvider provider = getZipFSProvider();
141         if (provider == null) {
142             System.err.println(&quot;ZIP filesystem provider is not installed&quot;);
143             System.exit(1);
144         }
145 
146         Action action = Action.valueOf(args[0]);
<a name="4" id="anc4"></a><span class="line-modified">147         Map&lt;String, Object&gt; env = env = new HashMap&lt;&gt;();</span>
148         if (action == Action.create)
149             env.put(&quot;create&quot;, &quot;true&quot;);
150         try (FileSystem fs = provider.newFileSystem(Paths.get(args[1]), env)) {
151             Path path, src, dst;
152             switch (action) {
153             case rename:
154                 src = fs.getPath(args[2]);
155                 dst = fs.getPath(args[3]);
156                 Files.move(src, dst);
157                 break;
158             case moveout:
159                 src = fs.getPath(args[2]);
160                 dst = Paths.get(args[3]);
161                 Files.move(src, dst);
162                 break;
163             case movein:
164                 src = Paths.get(args[2]);
165                 dst = fs.getPath(args[3]);
166                 Files.move(src, dst);
167                 break;
168             case copy:
169                 src = fs.getPath(args[2]);
170                 dst = fs.getPath(args[3]);
171                 Files.copy(src, dst);
172                 break;
173             case copyout:
174                 src = fs.getPath(args[2]);
175                 dst = Paths.get(args[3]);
176                 Files.copy(src, dst);
177                 break;
178             case copyin:
179                 src = Paths.get(args[2]);
180                 dst = fs.getPath(args[3]);
181                 Files.copy(src, dst);
182                 break;
183             case copyin_attrs:
184                 src = Paths.get(args[2]);
185                 dst = fs.getPath(args[3]);
186                 Files.copy(src, dst, COPY_ATTRIBUTES);
187                 break;
188             case copyout_attrs:
189                 src = fs.getPath(args[2]);
190                 dst = Paths.get(args[3]);
191                 Files.copy(src, dst, COPY_ATTRIBUTES);
192                 break;
193             case zzmove:
194                 try (FileSystem fs2 = provider.newFileSystem(Paths.get(args[2]), env)) {
195                     z2zmove(fs, fs2, args[3]);
196                 }
197                 break;
198             case zzcopy:
199                 try (FileSystem fs2 = provider.newFileSystem(Paths.get(args[2]), env)) {
200                     z2zcopy(fs, fs2, args[3]);
201                 }
202                 break;
203             case attrs:
204                 for (int i = 2; i &lt; args.length; i++) {
205                     path = fs.getPath(args[i]);
206                     System.out.println(path);
207                     System.out.println(
208                         Files.readAttributes(path, BasicFileAttributes.class).toString());
209                 }
210                 break;
211             case setmtime:
212                 DateFormat df = new SimpleDateFormat(&quot;MM/dd/yyyy-HH:mm:ss&quot;);
213                 Date newDatetime = df.parse(args[2]);
214                 for (int i = 3; i &lt; args.length; i++) {
215                     path = fs.getPath(args[i]);
216                     Files.setAttribute(path, &quot;lastModifiedTime&quot;,
217                                        FileTime.fromMillis(newDatetime.getTime()));
218                     System.out.println(
219                         Files.readAttributes(path, BasicFileAttributes.class).toString());
220                 }
221                 break;
222             case setctime:
223                 df = new SimpleDateFormat(&quot;MM/dd/yyyy-HH:mm:ss&quot;);
224                 newDatetime = df.parse(args[2]);
225                 for (int i = 3; i &lt; args.length; i++) {
226                     path = fs.getPath(args[i]);
227                     Files.setAttribute(path, &quot;creationTime&quot;,
228                                        FileTime.fromMillis(newDatetime.getTime()));
229                     System.out.println(
230                         Files.readAttributes(path, BasicFileAttributes.class).toString());
231                 }
232                 break;
233             case setatime:
234                 df = new SimpleDateFormat(&quot;MM/dd/yyyy-HH:mm:ss&quot;);
235                 newDatetime = df.parse(args[2]);
236                 for (int i = 3; i &lt; args.length; i++) {
237                     path = fs.getPath(args[i]);
238                     Files.setAttribute(path, &quot;lastAccessTime&quot;,
239                                        FileTime.fromMillis(newDatetime.getTime()));
240                     System.out.println(
241                         Files.readAttributes(path, BasicFileAttributes.class).toString());
242                 }
243                 break;
244             case attrsspace:
245                 path = fs.getPath(&quot;/&quot;);
246                 FileStore fstore = Files.getFileStore(path);
247                 System.out.printf(&quot;filestore[%s]%n&quot;, fstore.name());
248                 System.out.printf(&quot;    totalSpace: %d%n&quot;,
249                                   (Long)fstore.getAttribute(&quot;totalSpace&quot;));
250                 System.out.printf(&quot;   usableSpace: %d%n&quot;,
251                                   (Long)fstore.getAttribute(&quot;usableSpace&quot;));
252                 System.out.printf(&quot;  unallocSpace: %d%n&quot;,
253                                   (Long)fstore.getAttribute(&quot;unallocatedSpace&quot;));
254                 break;
255             case list:
256             case tlist:
257                 if (args.length &lt; 3)
258                     list(fs.getPath(&quot;/&quot;), false);
259                 else
260                     list(fs.getPath(args[2]), false);
261                 break;
262             case vlist:
263                 if (args.length &lt; 3)
264                     list(fs.getPath(&quot;/&quot;), true);
265                 else
266                     list(fs.getPath(args[2]), true);
267                 break;
268             case twalk:
269             case walk:
270                 walk(fs.getPath((args.length &gt; 2)? args[2] : &quot;/&quot;));
271                 break;
272             case extract:
273                 if (args.length == 2) {
274                      extract(fs, &quot;/&quot;);
275                 } else {
276                     for (int i = 2; i &lt; args.length; i++) {
277                         extract(fs, args[i]);
278                     }
279                 }
280                 break;
281             case delete:
282                 for (int i = 2; i &lt; args.length; i++)
283                     Files.delete(fs.getPath(args[i]));
284                 break;
285             case create:
286             case add:
287             case update:
288                 for (int i = 2; i &lt; args.length; i++) {
289                     update(fs, args[i]);
290                 }
291                 break;
292             case lsdir:
293                 path = fs.getPath(args[2]);
294                 final String fStr = (args.length &gt; 3)?args[3]:&quot;&quot;;
295                 try (DirectoryStream&lt;Path&gt; ds = Files.newDirectoryStream(path,
296                     new DirectoryStream.Filter&lt;Path&gt;() {
297                         @Override
298                         public boolean accept(Path path) {
299                             return path.toString().contains(fStr);
300                         }
301                     }))
302                 {
303                     for (Path p : ds)
304                         System.out.println(p);
305                 }
306                 break;
307             case mkdir:
308                 Files.createDirectory(fs.getPath(args[2]));
309                 break;
310             case mkdirs:
311                 mkdirs(fs.getPath(args[2]));
312                 break;
313             case attrs2:
314                 for (int i = 2; i &lt; args.length; i++) {
315                     path = fs.getPath(args[i]);
316                     System.out.printf(&quot;%n%s%n&quot;, path);
317                     System.out.println(&quot;-------(1)---------&quot;);
318                     System.out.println(
319                         Files.readAttributes(path, BasicFileAttributes.class).toString());
320                     System.out.println(&quot;-------(2)---------&quot;);
321                     Map&lt;String, Object&gt; map = Files.readAttributes(path, &quot;zip:*&quot;);
322                     for (Map.Entry&lt;String, Object&gt; e : map.entrySet()) {
323                         System.out.printf(&quot;    %s : %s%n&quot;, e.getKey(), e.getValue());
324                     }
325                     System.out.println(&quot;-------(3)---------&quot;);
326                     map = Files.readAttributes(path, &quot;size,lastModifiedTime,isDirectory&quot;);
327                     for (Map.Entry&lt;String, ?&gt; e : map.entrySet()) {
328                         System.out.printf(&quot;    %s : %s%n&quot;, e.getKey(), e.getValue());
329                     }
330                 }
331                 break;
332             case prof:
333                 list(fs.getPath(&quot;/&quot;), false);
334                 while (true) {
335                     Thread.sleep(10000);
336                     //list(fs.getPath(&quot;/&quot;), true);
337                     System.out.println(&quot;sleeping...&quot;);
338                 }
339             }
340         } catch (Exception x) {
341             x.printStackTrace();
342         }
343     }
344 
345     private static FileSystemProvider getZipFSProvider() {
346         for (FileSystemProvider provider : FileSystemProvider.installedProviders()) {
347             if (&quot;jar&quot;.equals(provider.getScheme()))
348                 return provider;
349         }
350         return null;
351     }
352 
353     @SuppressWarnings(&quot;unused&quot;)
354     /**
355      * Not used in demo, but included for demonstrational purposes.
356      */
357     private static byte[] getBytes(String name) {
358         return name.getBytes();
359     }
360 
361     @SuppressWarnings(&quot;unused&quot;)
362     /**
363      * Not used in demo, but included for demonstrational purposes.
364      */
365     private static String getString(byte[] name) {
366         return new String(name);
367     }
368 
369     private static void walk(Path path) throws IOException
370     {
371         Files.walkFileTree(
372             path,
373             new SimpleFileVisitor&lt;Path&gt;() {
374                 private int indent = 0;
375                 private void indent() {
376                     int n = 0;
377                     while (n++ &lt; indent)
378                         System.out.printf(&quot; &quot;);
379                 }
380 
381                 @Override
382                 public FileVisitResult visitFile(Path file,
383                                                  BasicFileAttributes attrs)
384                 {
385                     indent();
386                     System.out.printf(&quot;%s%n&quot;, file.getFileName().toString());
387                     return FileVisitResult.CONTINUE;
388                 }
389 
390                 @Override
391                 public FileVisitResult preVisitDirectory(Path dir,
392                                                          BasicFileAttributes attrs)
393                 {
394                     indent();
395                     System.out.printf(&quot;[%s]%n&quot;, dir.toString());
396                     indent += 2;
397                     return FileVisitResult.CONTINUE;
398                 }
399 
400                 @Override
401                 public FileVisitResult postVisitDirectory(Path dir,
402                                                           IOException ioe)
403                 {
404                     indent -= 2;
405                     return FileVisitResult.CONTINUE;
406                 }
407         });
408     }
409 
410     private static void update(FileSystem fs, String path) throws Throwable{
411         Path src = FileSystems.getDefault().getPath(path);
412         if (Files.isDirectory(src)) {
413             try (DirectoryStream&lt;Path&gt; ds = Files.newDirectoryStream(src)) {
414                 for (Path child : ds)
415                     update(fs, child.toString());
416             }
417         } else {
418             Path dst = fs.getPath(path);
419             Path parent = dst.getParent();
420             if (parent != null &amp;&amp; Files.notExists(parent))
421                 mkdirs(parent);
422             Files.copy(src, dst, REPLACE_EXISTING);
423         }
424     }
425 
426     private static void extract(FileSystem fs, String path) throws Throwable{
427         Path src = fs.getPath(path);
428         if (Files.isDirectory(src)) {
429             try (DirectoryStream&lt;Path&gt; ds = Files.newDirectoryStream(src)) {
430                 for (Path child : ds)
431                     extract(fs, child.toString());
432             }
433         } else {
434             if (path.startsWith(&quot;/&quot;))
435                 path = path.substring(1);
436             Path dst = FileSystems.getDefault().getPath(path);
437             Path parent = dst.getParent();
438             if (Files.notExists(parent))
439                 mkdirs(parent);
440             Files.copy(src, dst, REPLACE_EXISTING);
441         }
442     }
443 
444     // use DirectoryStream
445     private static void z2zcopy(FileSystem src, FileSystem dst, String path)
446         throws IOException
447     {
448         Path srcPath = src.getPath(path);
449         Path dstPath = dst.getPath(path);
450 
451         if (Files.isDirectory(srcPath)) {
452             if (!Files.exists(dstPath)) {
453                 try {
454                     mkdirs(dstPath);
455                 } catch (FileAlreadyExistsException x) {}
456             }
457             try (DirectoryStream&lt;Path&gt; ds = Files.newDirectoryStream(srcPath)) {
458                 for (Path child : ds) {
459                     z2zcopy(src, dst,
460                             path + (path.endsWith(&quot;/&quot;)?&quot;&quot;:&quot;/&quot;) + child.getFileName());
461                 }
462             }
463         } else {
464             //System.out.println(&quot;copying...&quot; + path);
465             Files.copy(srcPath, dstPath);
466         }
467     }
468 
469     // use TreeWalk to move
470     private static void z2zmove(FileSystem src, FileSystem dst, String path)
471         throws IOException
472     {
473         final Path srcPath = src.getPath(path).toAbsolutePath();
474         final Path dstPath = dst.getPath(path).toAbsolutePath();
475 
476         Files.walkFileTree(srcPath, new SimpleFileVisitor&lt;Path&gt;() {
477 
478             @Override
479             public FileVisitResult visitFile(Path file,
480                                             BasicFileAttributes attrs)
481             {
482                 Path dst = srcPath.relativize(file);
483                 dst = dstPath.resolve(dst);
484                 try {
485                     Path parent = dstPath.getParent();
486                     if (parent != null &amp;&amp; Files.notExists(parent))
487                         mkdirs(parent);
488                     Files.move(file, dst);
489                 } catch (IOException x) {
490                     x.printStackTrace();
491                 }
492                 return FileVisitResult.CONTINUE;
493             }
494 
495             @Override
496             public FileVisitResult preVisitDirectory(Path dir,
497                                                      BasicFileAttributes attrs)
498             {
499                 Path dst = srcPath.relativize(dir);
500                 dst = dstPath.resolve(dst);
501                 try {
502 
503                     if (Files.notExists(dst))
504                         mkdirs(dst);
505                 } catch (IOException x) {
506                     x.printStackTrace();
507                 }
508                 return FileVisitResult.CONTINUE;
509             }
510 
511             @Override
512             public FileVisitResult postVisitDirectory(Path dir,
513                                                       IOException ioe)
514                 throws IOException
515             {
516                 try {
517                     Files.delete(dir);
518                 } catch (IOException x) {
519                     //x.printStackTrace();
520                 }
521                 return FileVisitResult.CONTINUE;
522             }
523         });
524 
525     }
526 
527     private static void mkdirs(Path path) throws IOException {
528         path = path.toAbsolutePath();
529         Path parent = path.getParent();
530         if (parent != null) {
531             if (Files.notExists(parent))
532                 mkdirs(parent);
533         }
534         Files.createDirectory(path);
535     }
536 
<a name="5" id="anc5"></a><span class="line-removed">537     @SuppressWarnings(&quot;unused&quot;)</span>
538     /**
539      * Not used in demo, but included for demonstrational purposes.
540      */
<a name="6" id="anc6"></a>
541     private static void rmdirs(Path path) throws IOException {
542         while (path != null &amp;&amp; path.getNameCount() != 0) {
543             Files.delete(path);
544             path = path.getParent();
545         }
546     }
547 
548     private static void list(Path path, boolean verbose ) throws IOException {
549         if (!&quot;/&quot;.equals(path.toString())) {
550            System.out.printf(&quot;  %s%n&quot;, path.toString());
551            if (verbose)
552                 System.out.println(Files.readAttributes(path, BasicFileAttributes.class).toString());
553         }
554         if (Files.notExists(path))
555             return;
556         if (Files.isDirectory(path)) {
557             try (DirectoryStream&lt;Path&gt; ds = Files.newDirectoryStream(path)) {
558                 for (Path child : ds)
559                     list(child, verbose);
560             }
561         }
562     }
563 
<a name="7" id="anc7"></a><span class="line-removed">564     @SuppressWarnings(&quot;unused&quot;)</span>
565     /**
566      * Checks that the content of two paths are equal.
567      * Not used in demo, but included for demonstrational purposes.
568      */
<a name="8" id="anc8"></a>
569     private static void checkEqual(Path src, Path dst) throws IOException
570     {
571         //System.out.printf(&quot;checking &lt;%s&gt; vs &lt;%s&gt;...%n&quot;,
572         //                  src.toString(), dst.toString());
573 
574         //streams
575         byte[] bufSrc = new byte[8192];
576         byte[] bufDst = new byte[8192];
577         try (InputStream isSrc = Files.newInputStream(src);
578              InputStream isDst = Files.newInputStream(dst))
579         {
580             int nSrc = 0;
581             while ((nSrc = isSrc.read(bufSrc)) != -1) {
582                 int nDst = 0;
583                 while (nDst &lt; nSrc) {
584                     int n = isDst.read(bufDst, nDst, nSrc - nDst);
585                     if (n == -1) {
586                         System.out.printf(&quot;checking &lt;%s&gt; vs &lt;%s&gt;...%n&quot;,
587                                           src.toString(), dst.toString());
588                         throw new RuntimeException(&quot;CHECK FAILED!&quot;);
589                     }
590                     nDst += n;
591                 }
592                 while (--nSrc &gt;= 0) {
593                     if (bufSrc[nSrc] != bufDst[nSrc]) {
594                         System.out.printf(&quot;checking &lt;%s&gt; vs &lt;%s&gt;...%n&quot;,
595                                           src.toString(), dst.toString());
596                         throw new RuntimeException(&quot;CHECK FAILED!&quot;);
597                     }
598                     nSrc--;
599                 }
600             }
601         }
602 
603         // channels
604 
605         try (SeekableByteChannel chSrc = Files.newByteChannel(src);
606              SeekableByteChannel chDst = Files.newByteChannel(dst))
607         {
608             if (chSrc.size() != chDst.size()) {
609                 System.out.printf(&quot;src[%s].size=%d, dst[%s].size=%d%n&quot;,
610                                   chSrc.toString(), chSrc.size(),
611                                   chDst.toString(), chDst.size());
612                 throw new RuntimeException(&quot;CHECK FAILED!&quot;);
613             }
614             ByteBuffer bbSrc = ByteBuffer.allocate(8192);
615             ByteBuffer bbDst = ByteBuffer.allocate(8192);
616 
617             int nSrc = 0;
618             while ((nSrc = chSrc.read(bbSrc)) != -1) {
619                 int nDst = chDst.read(bbDst);
620                 if (nSrc != nDst) {
621                     System.out.printf(&quot;checking &lt;%s&gt; vs &lt;%s&gt;...%n&quot;,
622                                       src.toString(), dst.toString());
623                     throw new RuntimeException(&quot;CHECK FAILED!&quot;);
624                 }
625                 while (--nSrc &gt;= 0) {
626                     if (bbSrc.get(nSrc) != bbDst.get(nSrc)) {
627                         System.out.printf(&quot;checking &lt;%s&gt; vs &lt;%s&gt;...%n&quot;,
628                                           src.toString(), dst.toString());
629                         throw new RuntimeException(&quot;CHECK FAILED!&quot;);
630                     }
631                     nSrc--;
632                 }
633                 bbSrc.flip();
634                 bbDst.flip();
635             }
636         } catch (IOException x) {
637             x.printStackTrace();
638         }
639     }
640 
<a name="9" id="anc9"></a><span class="line-modified">641     private static void fchCopy(Path src, Path dst) throws IOException</span>
<span class="line-modified">642     {</span>



643         Set&lt;OpenOption&gt; read = new HashSet&lt;&gt;();
644         read.add(READ);
645         Set&lt;OpenOption&gt; openwrite = new HashSet&lt;&gt;();
646         openwrite.add(CREATE_NEW);
647         openwrite.add(WRITE);
648 
649         try (FileChannel srcFc = src.getFileSystem().provider().newFileChannel(src, read);
650              FileChannel dstFc = dst.getFileSystem().provider().newFileChannel(dst, openwrite))
651         {
652             ByteBuffer bb = ByteBuffer.allocate(8192);
653             while (srcFc.read(bb) &gt;= 0) {
654                 bb.flip();
655                 dstFc.write(bb);
656                 bb.clear();
657             }
658         }
659     }
660 
<a name="10" id="anc10"></a><span class="line-modified">661     private static void chCopy(Path src, Path dst) throws IOException</span>
<span class="line-modified">662     {</span>



663         Set&lt;OpenOption&gt; read = new HashSet&lt;&gt;();
664         read.add(READ);
665         Set&lt;OpenOption&gt; openwrite = new HashSet&lt;&gt;();
666         openwrite.add(CREATE_NEW);
667         openwrite.add(WRITE);
668 
669         try (SeekableByteChannel srcCh = Files.newByteChannel(src, read);
670              SeekableByteChannel dstCh = Files.newByteChannel(dst, openwrite))
671         {
672             ByteBuffer bb = ByteBuffer.allocate(8192);
673             while (srcCh.read(bb) &gt;= 0) {
674                 bb.flip();
675                 dstCh.write(bb);
676                 bb.clear();
677             }
678         }
679     }
680 
<a name="11" id="anc11"></a><span class="line-modified">681     private static void streamCopy(Path src, Path dst) throws IOException</span>
<span class="line-modified">682     {</span>



683         byte[] buf = new byte[8192];
684         try (InputStream isSrc = Files.newInputStream(src);
685              OutputStream osDst = Files.newOutputStream(dst))
686         {
687             int n = 0;
688             while ((n = isSrc.read(buf)) != -1) {
689                 osDst.write(buf, 0, n);
690             }
691         }
692     }
693 }
<a name="12" id="anc12"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="12" type="hidden" />
</body>
</html>
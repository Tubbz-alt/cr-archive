<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New test/jdk/jdk/nio/zipfs/Demo.java</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2010, 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 import java.io.*;
 25 import java.nio.*;
 26 import java.nio.channels.*;
 27 import java.nio.file.*;
 28 import java.nio.file.spi.*;
 29 import java.nio.file.attribute.*;
 30 import java.text.DateFormat;
 31 import java.text.SimpleDateFormat;
 32 import java.util.*;
 33 
 34 import static java.nio.file.StandardOpenOption.*;
 35 import static java.nio.file.StandardCopyOption.*;
 36 
 37 /*
 38  * ZipFileSystem usage demo
 39  *
 40  * java Demo action ZipfileName [...]
 41  *
 42  * @author Xueming Shen
 43  */
 44 
 45 public class Demo {
 46 
 47     static enum Action {
 48         rename,          // &lt;java Demo rename zipfile src dst&gt;
 49                          // rename entry src to dst inside zipfile
 50 
 51         movein,          // &lt;java Demo movein zipfile src dst&gt;
 52                          // move an external src file into zipfile
 53                          // as entry dst
 54 
 55         moveout,         // &lt;java Demo moveout zipfile src dst&gt;
 56                          // move a zipfile entry src out to dst
 57 
 58         copy,            // &lt;java Demo copy zipfile src dst&gt;
 59                          // copy entry src to dst inside zipfile
 60 
 61         copyin,          // &lt;java Demo copyin zipfile src dst&gt;
 62                          // copy an external src file into zipfile
 63                          // as entry dst
 64 
 65         copyin_attrs,    // &lt;java Demo copyin_attrs zipfile src dst&gt;
 66                          // copy an external src file into zipfile
 67                          // as entry dst, with attributes (timestamp)
 68 
 69         copyout,         // &lt;java Demo copyout zipfile src dst&gt;
 70                          // copy zipfile entry src&quot; out to file dst
 71 
 72         copyout_attrs,   // &lt;java Demo copyout_attrs zipfile src dst&gt;
 73 
 74         zzmove,          // &lt;java Demo zzmove zfsrc zfdst path&gt;
 75                          // move entry path/dir from zfsrc to zfdst
 76 
 77         zzcopy,          // &lt;java Demo zzcopy zfsrc zfdst path&gt;
 78                          // copy path from zipfile zfsrc to zipfile
 79                          // zfdst
 80 
 81         attrs,           // &lt;java Demo attrs zipfile path&gt;
 82                          // printout the attributes of entry path
 83 
 84         attrsspace,      // &lt;java Demo attrsspace zipfile path&gt;
 85                          // printout the storespace attrs of entry path
 86 
 87         setmtime,        // &lt;java Demo setmtime zipfile &quot;MM/dd/yy-HH:mm:ss&quot; path...&gt;
 88                          // set the lastModifiedTime of entry path
 89 
 90         setatime,        // &lt;java Demo setatime zipfile &quot;MM/dd/yy-HH:mm:ss&quot; path...&gt;
 91         setctime,        // &lt;java Demo setctime zipfile &quot;MM/dd/yy-HH:mm:ss&quot; path...&gt;
 92 
 93         lsdir,           // &lt;java Demo lsdir zipfile dir&gt;
 94                          // list dir&#39;s direct child files/dirs
 95 
 96         mkdir,           // &lt;java Demo mkdir zipfile dir&gt;
 97 
 98         mkdirs,          // &lt;java Demo mkdirs zipfile dir&gt;
 99 
100         list,            // &lt;java Demo list zipfile [dir]&gt;
101                          // recursively list all entries of dir
102                          // via DirectoryStream
103 
104         tlist,           // &lt;java Demo tlist zipfile [dir]&gt;
105                          // list with buildDirTree=true
106 
107         vlist,           // &lt;java Demo vlist zipfile [dir]&gt;
108                          // recursively verbose list all entries of
109                          // dir via DirectoryStream
110 
111         walk,            // &lt;java Demo walk zipfile [dir]&gt;
112                          // recursively walk all entries of dir
113                          // via Files.walkFileTree
114 
115         twalk,           // &lt;java Demo twalk zipfile [dir]&gt;
116                          // walk with buildDirTree=true
117 
118         extract,         // &lt;java Demo extract zipfile file [...]&gt;
119 
120         update,          // &lt;java Demo extract zipfile file [...]&gt;
121 
122         delete,          // &lt;java Demo delete zipfile file [...]&gt;
123 
124         add,             // &lt;java Demo add zipfile file [...]&gt;
125 
126         create,          // &lt;java Demo create zipfile file [...]&gt;
127                          // create a new zipfile if it doesn&#39;t exit
128                          // and then add the file(s) into it.
129 
130         attrs2,          // &lt;java Demo attrs2 zipfile file [...]&gt;
131                          // test different ways to print attrs
132 
133         prof,
134     }
135 
136     public static void main(String[] args) throws Throwable {
137         FileSystemProvider provider = getZipFSProvider();
138         if (provider == null) {
139             System.err.println(&quot;ZIP filesystem provider is not installed&quot;);
140             System.exit(1);
141         }
142 
143         Action action = Action.valueOf(args[0]);
144         Map&lt;String, Object&gt; env = new HashMap&lt;&gt;();
145         if (action == Action.create)
146             env.put(&quot;create&quot;, &quot;true&quot;);
147         try (FileSystem fs = provider.newFileSystem(Paths.get(args[1]), env)) {
148             Path path, src, dst;
149             switch (action) {
150             case rename:
151                 src = fs.getPath(args[2]);
152                 dst = fs.getPath(args[3]);
153                 Files.move(src, dst);
154                 break;
155             case moveout:
156                 src = fs.getPath(args[2]);
157                 dst = Paths.get(args[3]);
158                 Files.move(src, dst);
159                 break;
160             case movein:
161                 src = Paths.get(args[2]);
162                 dst = fs.getPath(args[3]);
163                 Files.move(src, dst);
164                 break;
165             case copy:
166                 src = fs.getPath(args[2]);
167                 dst = fs.getPath(args[3]);
168                 Files.copy(src, dst);
169                 break;
170             case copyout:
171                 src = fs.getPath(args[2]);
172                 dst = Paths.get(args[3]);
173                 Files.copy(src, dst);
174                 break;
175             case copyin:
176                 src = Paths.get(args[2]);
177                 dst = fs.getPath(args[3]);
178                 Files.copy(src, dst);
179                 break;
180             case copyin_attrs:
181                 src = Paths.get(args[2]);
182                 dst = fs.getPath(args[3]);
183                 Files.copy(src, dst, COPY_ATTRIBUTES);
184                 break;
185             case copyout_attrs:
186                 src = fs.getPath(args[2]);
187                 dst = Paths.get(args[3]);
188                 Files.copy(src, dst, COPY_ATTRIBUTES);
189                 break;
190             case zzmove:
191                 try (FileSystem fs2 = provider.newFileSystem(Paths.get(args[2]), env)) {
192                     z2zmove(fs, fs2, args[3]);
193                 }
194                 break;
195             case zzcopy:
196                 try (FileSystem fs2 = provider.newFileSystem(Paths.get(args[2]), env)) {
197                     z2zcopy(fs, fs2, args[3]);
198                 }
199                 break;
200             case attrs:
201                 for (int i = 2; i &lt; args.length; i++) {
202                     path = fs.getPath(args[i]);
203                     System.out.println(path);
204                     System.out.println(
205                         Files.readAttributes(path, BasicFileAttributes.class).toString());
206                 }
207                 break;
208             case setmtime:
209                 DateFormat df = new SimpleDateFormat(&quot;MM/dd/yyyy-HH:mm:ss&quot;);
210                 Date newDatetime = df.parse(args[2]);
211                 for (int i = 3; i &lt; args.length; i++) {
212                     path = fs.getPath(args[i]);
213                     Files.setAttribute(path, &quot;lastModifiedTime&quot;,
214                                        FileTime.fromMillis(newDatetime.getTime()));
215                     System.out.println(
216                         Files.readAttributes(path, BasicFileAttributes.class).toString());
217                 }
218                 break;
219             case setctime:
220                 df = new SimpleDateFormat(&quot;MM/dd/yyyy-HH:mm:ss&quot;);
221                 newDatetime = df.parse(args[2]);
222                 for (int i = 3; i &lt; args.length; i++) {
223                     path = fs.getPath(args[i]);
224                     Files.setAttribute(path, &quot;creationTime&quot;,
225                                        FileTime.fromMillis(newDatetime.getTime()));
226                     System.out.println(
227                         Files.readAttributes(path, BasicFileAttributes.class).toString());
228                 }
229                 break;
230             case setatime:
231                 df = new SimpleDateFormat(&quot;MM/dd/yyyy-HH:mm:ss&quot;);
232                 newDatetime = df.parse(args[2]);
233                 for (int i = 3; i &lt; args.length; i++) {
234                     path = fs.getPath(args[i]);
235                     Files.setAttribute(path, &quot;lastAccessTime&quot;,
236                                        FileTime.fromMillis(newDatetime.getTime()));
237                     System.out.println(
238                         Files.readAttributes(path, BasicFileAttributes.class).toString());
239                 }
240                 break;
241             case attrsspace:
242                 path = fs.getPath(&quot;/&quot;);
243                 FileStore fstore = Files.getFileStore(path);
244                 System.out.printf(&quot;filestore[%s]%n&quot;, fstore.name());
245                 System.out.printf(&quot;    totalSpace: %d%n&quot;,
246                                   (Long)fstore.getAttribute(&quot;totalSpace&quot;));
247                 System.out.printf(&quot;   usableSpace: %d%n&quot;,
248                                   (Long)fstore.getAttribute(&quot;usableSpace&quot;));
249                 System.out.printf(&quot;  unallocSpace: %d%n&quot;,
250                                   (Long)fstore.getAttribute(&quot;unallocatedSpace&quot;));
251                 break;
252             case list:
253             case tlist:
254                 if (args.length &lt; 3)
255                     list(fs.getPath(&quot;/&quot;), false);
256                 else
257                     list(fs.getPath(args[2]), false);
258                 break;
259             case vlist:
260                 if (args.length &lt; 3)
261                     list(fs.getPath(&quot;/&quot;), true);
262                 else
263                     list(fs.getPath(args[2]), true);
264                 break;
265             case twalk:
266             case walk:
267                 walk(fs.getPath((args.length &gt; 2)? args[2] : &quot;/&quot;));
268                 break;
269             case extract:
270                 if (args.length == 2) {
271                      extract(fs, &quot;/&quot;);
272                 } else {
273                     for (int i = 2; i &lt; args.length; i++) {
274                         extract(fs, args[i]);
275                     }
276                 }
277                 break;
278             case delete:
279                 for (int i = 2; i &lt; args.length; i++)
280                     Files.delete(fs.getPath(args[i]));
281                 break;
282             case create:
283             case add:
284             case update:
285                 for (int i = 2; i &lt; args.length; i++) {
286                     update(fs, args[i]);
287                 }
288                 break;
289             case lsdir:
290                 path = fs.getPath(args[2]);
291                 final String fStr = (args.length &gt; 3)?args[3]:&quot;&quot;;
292                 try (DirectoryStream&lt;Path&gt; ds = Files.newDirectoryStream(path,
293                     new DirectoryStream.Filter&lt;Path&gt;() {
294                         @Override
295                         public boolean accept(Path path) {
296                             return path.toString().contains(fStr);
297                         }
298                     }))
299                 {
300                     for (Path p : ds)
301                         System.out.println(p);
302                 }
303                 break;
304             case mkdir:
305                 Files.createDirectory(fs.getPath(args[2]));
306                 break;
307             case mkdirs:
308                 mkdirs(fs.getPath(args[2]));
309                 break;
310             case attrs2:
311                 for (int i = 2; i &lt; args.length; i++) {
312                     path = fs.getPath(args[i]);
313                     System.out.printf(&quot;%n%s%n&quot;, path);
314                     System.out.println(&quot;-------(1)---------&quot;);
315                     System.out.println(
316                         Files.readAttributes(path, BasicFileAttributes.class).toString());
317                     System.out.println(&quot;-------(2)---------&quot;);
318                     Map&lt;String, Object&gt; map = Files.readAttributes(path, &quot;zip:*&quot;);
319                     for (Map.Entry&lt;String, Object&gt; e : map.entrySet()) {
320                         System.out.printf(&quot;    %s : %s%n&quot;, e.getKey(), e.getValue());
321                     }
322                     System.out.println(&quot;-------(3)---------&quot;);
323                     map = Files.readAttributes(path, &quot;size,lastModifiedTime,isDirectory&quot;);
324                     for (Map.Entry&lt;String, ?&gt; e : map.entrySet()) {
325                         System.out.printf(&quot;    %s : %s%n&quot;, e.getKey(), e.getValue());
326                     }
327                 }
328                 break;
329             case prof:
330                 list(fs.getPath(&quot;/&quot;), false);
331                 while (true) {
332                     Thread.sleep(10000);
333                     //list(fs.getPath(&quot;/&quot;), true);
334                     System.out.println(&quot;sleeping...&quot;);
335                 }
336             }
337         } catch (Exception x) {
338             x.printStackTrace();
339         }
340     }
341 
342     private static FileSystemProvider getZipFSProvider() {
343         for (FileSystemProvider provider : FileSystemProvider.installedProviders()) {
344             if (&quot;jar&quot;.equals(provider.getScheme()))
345                 return provider;
346         }
347         return null;
348     }
349 
350     @SuppressWarnings(&quot;unused&quot;)
351     /**
352      * Not used in demo, but included for demonstrational purposes.
353      */
354     private static byte[] getBytes(String name) {
355         return name.getBytes();
356     }
357 
358     @SuppressWarnings(&quot;unused&quot;)
359     /**
360      * Not used in demo, but included for demonstrational purposes.
361      */
362     private static String getString(byte[] name) {
363         return new String(name);
364     }
365 
366     private static void walk(Path path) throws IOException
367     {
368         Files.walkFileTree(
369             path,
370             new SimpleFileVisitor&lt;Path&gt;() {
371                 private int indent = 0;
372                 private void indent() {
373                     int n = 0;
374                     while (n++ &lt; indent)
375                         System.out.printf(&quot; &quot;);
376                 }
377 
378                 @Override
379                 public FileVisitResult visitFile(Path file,
380                                                  BasicFileAttributes attrs)
381                 {
382                     indent();
383                     System.out.printf(&quot;%s%n&quot;, file.getFileName().toString());
384                     return FileVisitResult.CONTINUE;
385                 }
386 
387                 @Override
388                 public FileVisitResult preVisitDirectory(Path dir,
389                                                          BasicFileAttributes attrs)
390                 {
391                     indent();
392                     System.out.printf(&quot;[%s]%n&quot;, dir.toString());
393                     indent += 2;
394                     return FileVisitResult.CONTINUE;
395                 }
396 
397                 @Override
398                 public FileVisitResult postVisitDirectory(Path dir,
399                                                           IOException ioe)
400                 {
401                     indent -= 2;
402                     return FileVisitResult.CONTINUE;
403                 }
404         });
405     }
406 
407     private static void update(FileSystem fs, String path) throws Throwable{
408         Path src = FileSystems.getDefault().getPath(path);
409         if (Files.isDirectory(src)) {
410             try (DirectoryStream&lt;Path&gt; ds = Files.newDirectoryStream(src)) {
411                 for (Path child : ds)
412                     update(fs, child.toString());
413             }
414         } else {
415             Path dst = fs.getPath(path);
416             Path parent = dst.getParent();
417             if (parent != null &amp;&amp; Files.notExists(parent))
418                 mkdirs(parent);
419             Files.copy(src, dst, REPLACE_EXISTING);
420         }
421     }
422 
423     private static void extract(FileSystem fs, String path) throws Throwable{
424         Path src = fs.getPath(path);
425         if (Files.isDirectory(src)) {
426             try (DirectoryStream&lt;Path&gt; ds = Files.newDirectoryStream(src)) {
427                 for (Path child : ds)
428                     extract(fs, child.toString());
429             }
430         } else {
431             if (path.startsWith(&quot;/&quot;))
432                 path = path.substring(1);
433             Path dst = FileSystems.getDefault().getPath(path);
434             Path parent = dst.getParent();
435             if (Files.notExists(parent))
436                 mkdirs(parent);
437             Files.copy(src, dst, REPLACE_EXISTING);
438         }
439     }
440 
441     // use DirectoryStream
442     private static void z2zcopy(FileSystem src, FileSystem dst, String path)
443         throws IOException
444     {
445         Path srcPath = src.getPath(path);
446         Path dstPath = dst.getPath(path);
447 
448         if (Files.isDirectory(srcPath)) {
449             if (!Files.exists(dstPath)) {
450                 try {
451                     mkdirs(dstPath);
452                 } catch (FileAlreadyExistsException x) {}
453             }
454             try (DirectoryStream&lt;Path&gt; ds = Files.newDirectoryStream(srcPath)) {
455                 for (Path child : ds) {
456                     z2zcopy(src, dst,
457                             path + (path.endsWith(&quot;/&quot;)?&quot;&quot;:&quot;/&quot;) + child.getFileName());
458                 }
459             }
460         } else {
461             //System.out.println(&quot;copying...&quot; + path);
462             Files.copy(srcPath, dstPath);
463         }
464     }
465 
466     // use TreeWalk to move
467     private static void z2zmove(FileSystem src, FileSystem dst, String path)
468         throws IOException
469     {
470         final Path srcPath = src.getPath(path).toAbsolutePath();
471         final Path dstPath = dst.getPath(path).toAbsolutePath();
472 
473         Files.walkFileTree(srcPath, new SimpleFileVisitor&lt;Path&gt;() {
474 
475             @Override
476             public FileVisitResult visitFile(Path file,
477                                             BasicFileAttributes attrs)
478             {
479                 Path dst = srcPath.relativize(file);
480                 dst = dstPath.resolve(dst);
481                 try {
482                     Path parent = dstPath.getParent();
483                     if (parent != null &amp;&amp; Files.notExists(parent))
484                         mkdirs(parent);
485                     Files.move(file, dst);
486                 } catch (IOException x) {
487                     x.printStackTrace();
488                 }
489                 return FileVisitResult.CONTINUE;
490             }
491 
492             @Override
493             public FileVisitResult preVisitDirectory(Path dir,
494                                                      BasicFileAttributes attrs)
495             {
496                 Path dst = srcPath.relativize(dir);
497                 dst = dstPath.resolve(dst);
498                 try {
499 
500                     if (Files.notExists(dst))
501                         mkdirs(dst);
502                 } catch (IOException x) {
503                     x.printStackTrace();
504                 }
505                 return FileVisitResult.CONTINUE;
506             }
507 
508             @Override
509             public FileVisitResult postVisitDirectory(Path dir,
510                                                       IOException ioe)
511                 throws IOException
512             {
513                 try {
514                     Files.delete(dir);
515                 } catch (IOException x) {
516                     //x.printStackTrace();
517                 }
518                 return FileVisitResult.CONTINUE;
519             }
520         });
521 
522     }
523 
524     private static void mkdirs(Path path) throws IOException {
525         path = path.toAbsolutePath();
526         Path parent = path.getParent();
527         if (parent != null) {
528             if (Files.notExists(parent))
529                 mkdirs(parent);
530         }
531         Files.createDirectory(path);
532     }
533 
534     /**
535      * Not used in demo, but included for demonstrational purposes.
536      */
537     @SuppressWarnings(&quot;unused&quot;)
538     private static void rmdirs(Path path) throws IOException {
539         while (path != null &amp;&amp; path.getNameCount() != 0) {
540             Files.delete(path);
541             path = path.getParent();
542         }
543     }
544 
545     private static void list(Path path, boolean verbose ) throws IOException {
546         if (!&quot;/&quot;.equals(path.toString())) {
547            System.out.printf(&quot;  %s%n&quot;, path.toString());
548            if (verbose)
549                 System.out.println(Files.readAttributes(path, BasicFileAttributes.class).toString());
550         }
551         if (Files.notExists(path))
552             return;
553         if (Files.isDirectory(path)) {
554             try (DirectoryStream&lt;Path&gt; ds = Files.newDirectoryStream(path)) {
555                 for (Path child : ds)
556                     list(child, verbose);
557             }
558         }
559     }
560 
561     /**
562      * Checks that the content of two paths are equal.
563      * Not used in demo, but included for demonstrational purposes.
564      */
565     @SuppressWarnings(&quot;unused&quot;)
566     private static void checkEqual(Path src, Path dst) throws IOException
567     {
568         //System.out.printf(&quot;checking &lt;%s&gt; vs &lt;%s&gt;...%n&quot;,
569         //                  src.toString(), dst.toString());
570 
571         //streams
572         byte[] bufSrc = new byte[8192];
573         byte[] bufDst = new byte[8192];
574         try (InputStream isSrc = Files.newInputStream(src);
575              InputStream isDst = Files.newInputStream(dst))
576         {
577             int nSrc = 0;
578             while ((nSrc = isSrc.read(bufSrc)) != -1) {
579                 int nDst = 0;
580                 while (nDst &lt; nSrc) {
581                     int n = isDst.read(bufDst, nDst, nSrc - nDst);
582                     if (n == -1) {
583                         System.out.printf(&quot;checking &lt;%s&gt; vs &lt;%s&gt;...%n&quot;,
584                                           src.toString(), dst.toString());
585                         throw new RuntimeException(&quot;CHECK FAILED!&quot;);
586                     }
587                     nDst += n;
588                 }
589                 while (--nSrc &gt;= 0) {
590                     if (bufSrc[nSrc] != bufDst[nSrc]) {
591                         System.out.printf(&quot;checking &lt;%s&gt; vs &lt;%s&gt;...%n&quot;,
592                                           src.toString(), dst.toString());
593                         throw new RuntimeException(&quot;CHECK FAILED!&quot;);
594                     }
595                     nSrc--;
596                 }
597             }
598         }
599 
600         // channels
601 
602         try (SeekableByteChannel chSrc = Files.newByteChannel(src);
603              SeekableByteChannel chDst = Files.newByteChannel(dst))
604         {
605             if (chSrc.size() != chDst.size()) {
606                 System.out.printf(&quot;src[%s].size=%d, dst[%s].size=%d%n&quot;,
607                                   chSrc.toString(), chSrc.size(),
608                                   chDst.toString(), chDst.size());
609                 throw new RuntimeException(&quot;CHECK FAILED!&quot;);
610             }
611             ByteBuffer bbSrc = ByteBuffer.allocate(8192);
612             ByteBuffer bbDst = ByteBuffer.allocate(8192);
613 
614             int nSrc = 0;
615             while ((nSrc = chSrc.read(bbSrc)) != -1) {
616                 int nDst = chDst.read(bbDst);
617                 if (nSrc != nDst) {
618                     System.out.printf(&quot;checking &lt;%s&gt; vs &lt;%s&gt;...%n&quot;,
619                                       src.toString(), dst.toString());
620                     throw new RuntimeException(&quot;CHECK FAILED!&quot;);
621                 }
622                 while (--nSrc &gt;= 0) {
623                     if (bbSrc.get(nSrc) != bbDst.get(nSrc)) {
624                         System.out.printf(&quot;checking &lt;%s&gt; vs &lt;%s&gt;...%n&quot;,
625                                           src.toString(), dst.toString());
626                         throw new RuntimeException(&quot;CHECK FAILED!&quot;);
627                     }
628                     nSrc--;
629                 }
630                 bbSrc.flip();
631                 bbDst.flip();
632             }
633         } catch (IOException x) {
634             x.printStackTrace();
635         }
636     }
637 
638     /**
639      * Not used in demo, but included for demonstrational purposes.
640      */
641     @SuppressWarnings(&quot;unused&quot;)
642     private static void fchCopy(Path src, Path dst) throws IOException {
643         Set&lt;OpenOption&gt; read = new HashSet&lt;&gt;();
644         read.add(READ);
645         Set&lt;OpenOption&gt; openwrite = new HashSet&lt;&gt;();
646         openwrite.add(CREATE_NEW);
647         openwrite.add(WRITE);
648 
649         try (FileChannel srcFc = src.getFileSystem().provider().newFileChannel(src, read);
650              FileChannel dstFc = dst.getFileSystem().provider().newFileChannel(dst, openwrite))
651         {
652             ByteBuffer bb = ByteBuffer.allocate(8192);
653             while (srcFc.read(bb) &gt;= 0) {
654                 bb.flip();
655                 dstFc.write(bb);
656                 bb.clear();
657             }
658         }
659     }
660 
661     /**
662      * Not used in demo, but included for demonstrational purposes.
663      */
664     @SuppressWarnings(&quot;unused&quot;)
665     private static void chCopy(Path src, Path dst) throws IOException {
666         Set&lt;OpenOption&gt; read = new HashSet&lt;&gt;();
667         read.add(READ);
668         Set&lt;OpenOption&gt; openwrite = new HashSet&lt;&gt;();
669         openwrite.add(CREATE_NEW);
670         openwrite.add(WRITE);
671 
672         try (SeekableByteChannel srcCh = Files.newByteChannel(src, read);
673              SeekableByteChannel dstCh = Files.newByteChannel(dst, openwrite))
674         {
675             ByteBuffer bb = ByteBuffer.allocate(8192);
676             while (srcCh.read(bb) &gt;= 0) {
677                 bb.flip();
678                 dstCh.write(bb);
679                 bb.clear();
680             }
681         }
682     }
683 
684     /**
685      * Not used in demo, but included for demonstrational purposes.
686      */
687     @SuppressWarnings(&quot;unused&quot;)
688     private static void streamCopy(Path src, Path dst) throws IOException {
689         byte[] buf = new byte[8192];
690         try (InputStream isSrc = Files.newInputStream(src);
691              OutputStream osDst = Files.newOutputStream(dst))
692         {
693             int n = 0;
694             while ((n = isSrc.read(buf)) != -1) {
695                 osDst.write(buf, 0, n);
696             }
697         }
698     }
699 }
    </pre>
  </body>
</html>
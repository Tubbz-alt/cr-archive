<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New test/jdk/jdk/nio/zipfs/PathOps.java</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2009, 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 import java.io.IOException;
 25 import java.nio.file.FileSystem;
 26 import java.nio.file.FileSystems;
 27 import java.nio.file.Files;
 28 import java.nio.file.InvalidPathException;
 29 import java.nio.file.Path;
 30 import java.nio.file.Paths;
 31 import java.nio.file.ProviderMismatchException;
 32 
 33 /**
 34  *
 35  * @test
 36  * @bug 8038500 8040059 8139956 8146754 8172921 8186142
 37  * @summary Tests path operations for zip provider.
 38  *
 39  * @modules jdk.zipfs
 40  * @run main PathOps
 41  * @run main/othervm/java.security.policy=test.policy PathOps
 42  */
 43 
 44 public class PathOps {
 45 
 46     static final java.io.PrintStream out = System.out;
 47     static FileSystem fs;
 48 
 49     private Path path;
 50     private Exception exc;
 51 
 52     private PathOps(String first, String... more) {
 53         out.println();
 54         try {
 55             path = fs.getPath(first, more);
 56             out.format(&quot;%s -&gt; %s&quot;, first, path);
 57         } catch (Exception x) {
 58             exc = x;
 59             out.format(&quot;%s -&gt; %s&quot;, first, x);
 60         }
 61         out.println();
 62     }
 63 
 64     Path path() {
 65         return path;
 66     }
 67 
 68     void fail() {
 69         throw new RuntimeException(&quot;PathOps failed&quot;);
 70     }
 71 
 72     void checkPath() {
 73         if (path == null) {
 74             throw new InternalError(&quot;path is null&quot;);
 75         }
 76     }
 77 
 78     void check(Object result, String expected) {
 79         out.format(&quot;\tExpected: %s\n&quot;, expected);
 80         out.format(&quot;\tActual: %s\n&quot;,  result);
 81         if (result == null) {
 82             if (expected == null) return;
 83         } else {
 84             // compare string representations
 85             if (expected != null &amp;&amp; result.toString().equals(expected.toString()))
 86                 return;
 87         }
 88         fail();
 89     }
 90 
 91     void check(Object result, boolean expected) {
 92         check(result, Boolean.toString(expected));
 93     }
 94 
 95     PathOps root(String expected) {
 96         out.println(&quot;check root&quot;);
 97         checkPath();
 98         check(path.getRoot(), expected);
 99         return this;
100     }
101 
102     PathOps parent(String expected) {
103         out.println(&quot;check parent&quot;);
104         checkPath();
105         check(path.getParent(), expected);
106         return this;
107     }
108 
109     PathOps name(String expected) {
110         out.println(&quot;check name&quot;);
111         checkPath();
112         check(path.getFileName(), expected);
113         return this;
114     }
115 
116     PathOps element(int index, String expected) {
117         out.format(&quot;check element %d\n&quot;, index);
118         checkPath();
119         check(path.getName(index), expected);
120         return this;
121     }
122 
123     PathOps subpath(int startIndex, int endIndex, String expected) {
124         out.format(&quot;test subpath(%d,%d)\n&quot;, startIndex, endIndex);
125         checkPath();
126         check(path.subpath(startIndex, endIndex), expected);
127         return this;
128     }
129 
130     PathOps starts(String prefix) {
131         out.format(&quot;test startsWith with %s\n&quot;, prefix);
132         checkPath();
133         Path s = fs.getPath(prefix);
134         check(path.startsWith(s), true);
135         return this;
136     }
137 
138     PathOps notStarts(String prefix) {
139         out.format(&quot;test not startsWith with %s\n&quot;, prefix);
140         checkPath();
141         Path s = fs.getPath(prefix);
142         check(path.startsWith(s), false);
143         return this;
144     }
145 
146     PathOps ends(String suffix) {
147         out.format(&quot;test endsWith %s\n&quot;, suffix);
148         checkPath();
149         Path s = fs.getPath(suffix);
150         check(path.endsWith(s), true);
151         return this;
152     }
153 
154     PathOps notEnds(String suffix) {
155         out.format(&quot;test not endsWith %s\n&quot;, suffix);
156         checkPath();
157         Path s = fs.getPath(suffix);
158         check(path.endsWith(s), false);
159         return this;
160     }
161 
162     PathOps absolute() {
163         out.println(&quot;check path is absolute&quot;);
164         checkPath();
165         check(path.isAbsolute(), true);
166         return this;
167     }
168 
169     PathOps notAbsolute() {
170         out.println(&quot;check path is not absolute&quot;);
171         checkPath();
172         check(path.isAbsolute(), false);
173         return this;
174     }
175 
176     PathOps resolve(String other, String expected) {
177         out.format(&quot;test resolve %s\n&quot;, other);
178         checkPath();
179         check(path.resolve(other), expected);
180         return this;
181     }
182 
183     PathOps resolvePath(String other, String expected) {
184         out.format(&quot;test resolve %s\n&quot;, other);
185         checkPath();
186         check(path.resolve(fs.getPath(other)), expected);
187         return this;
188     }
189 
190     PathOps resolveSibling(String other, String expected) {
191         out.format(&quot;test resolveSibling %s\n&quot;, other);
192         checkPath();
193         check(path.resolveSibling(other), expected);
194         return this;
195     }
196 
197     PathOps relativize(String other, String expected) {
198         out.format(&quot;test relativize %s\n&quot;, other);
199         checkPath();
200         Path that = fs.getPath(other);
201         check(path.relativize(that), expected);
202         return this;
203     }
204 
205     PathOps normalize(String expected) {
206         out.println(&quot;check normalized path&quot;);
207         checkPath();
208         check(path.normalize(), expected);
209         return this;
210     }
211 
212     PathOps string(String expected) {
213         out.println(&quot;check string representation&quot;);
214         checkPath();
215         check(path, expected);
216         return this;
217     }
218 
219     PathOps isSameFile(String target) {
220         try {
221             out.println(&quot;check two paths are same&quot;);
222             checkPath();
223             check(Files.isSameFile(path, test(target).path()), true);
224         } catch (IOException ioe) {
225             fail();
226         }
227         return this;
228     }
229 
230     PathOps invalid() {
231         if (!(exc instanceof InvalidPathException)) {
232             out.println(&quot;InvalidPathException not thrown as expected&quot;);
233             fail();
234         }
235         return this;
236     }
237 
238     static PathOps test(String s) {
239         return new PathOps(s);
240     }
241 
242     static PathOps test(String first, String... more) {
243         return new PathOps(first, more);
244     }
245 
246     // -- PathOpss --
247 
248     static void header(String s) {
249         out.println();
250         out.println();
251         out.println(&quot;-- &quot; + s + &quot; --&quot;);
252     }
253 
254     static void doPathOpTests() {
255         header(&quot;Path operations&quot;);
256 
257         // construction
258         test(&quot;/&quot;)
259             .string(&quot;/&quot;);
260         test(&quot;/&quot;, &quot;&quot;)
261             .string(&quot;/&quot;);
262         test(&quot;/&quot;, &quot;foo&quot;)
263             .string(&quot;/foo&quot;);
264         test(&quot;/&quot;, &quot;/foo&quot;)
265             .string(&quot;/foo&quot;);
266         test(&quot;/&quot;, &quot;foo/&quot;)
267             .string(&quot;/foo&quot;);
268         test(&quot;foo&quot;, &quot;bar&quot;, &quot;gus&quot;)
269             .string(&quot;foo/bar/gus&quot;);
270         test(&quot;&quot;)
271             .string(&quot;&quot;);
272         test(&quot;&quot;, &quot;/&quot;)
273             .string(&quot;/&quot;);
274         test(&quot;&quot;, &quot;foo&quot;, &quot;&quot;, &quot;bar&quot;, &quot;&quot;, &quot;/gus&quot;)
275             .string(&quot;foo/bar/gus&quot;);
276 
277         // all components
278         test(&quot;/a/b/c&quot;)
279             .root(&quot;/&quot;)
280             .parent(&quot;/a/b&quot;)
281             .name(&quot;c&quot;);
282 
283         // root component only
284         test(&quot;/&quot;)
285             .root(&quot;/&quot;)
286             .parent(null)
287             .name(null);
288 
289         // no root component
290         test(&quot;a/b&quot;)
291             .root(null)
292             .parent(&quot;a&quot;)
293             .name(&quot;b&quot;);
294 
295         // name component only
296         test(&quot;foo&quot;)
297             .root(null)
298             .parent(null)
299             .name(&quot;foo&quot;);
300 
301         // startsWith
302         test(&quot;&quot;)
303             .starts(&quot;&quot;)
304             .notStarts(&quot;/&quot;);
305         test(&quot;/&quot;)
306             .starts(&quot;/&quot;)
307             .notStarts(&quot;/foo&quot;);
308         test(&quot;/foo&quot;)
309             .starts(&quot;/&quot;)
310             .starts(&quot;/foo&quot;)
311             .notStarts(&quot;/f&quot;)
312             .notStarts(&quot;&quot;);
313         test(&quot;/foo/bar&quot;)
314             .starts(&quot;/&quot;)
315             .starts(&quot;/foo&quot;)
316             .starts(&quot;/foo/&quot;)
317             .starts(&quot;/foo/bar&quot;)
318             .notStarts(&quot;/f&quot;)
319             .notStarts(&quot;foo&quot;)
320             .notStarts(&quot;foo/bar&quot;)
321             .notStarts(&quot;&quot;);
322         test(&quot;foo&quot;)
323             .starts(&quot;foo&quot;)
324             .notStarts(&quot;f&quot;);
325         test(&quot;foo/bar&quot;)
326             .starts(&quot;foo&quot;)
327             .starts(&quot;foo/&quot;)
328             .starts(&quot;foo/bar&quot;)
329             .notStarts(&quot;f&quot;)
330             .notStarts(&quot;/foo&quot;)
331             .notStarts(&quot;/foo/bar&quot;);
332 
333         // endsWith
334         test(&quot;&quot;)
335             .ends(&quot;&quot;)
336             .notEnds(&quot;/&quot;);
337         test(&quot;/&quot;)
338             .ends(&quot;/&quot;)
339             .notEnds(&quot;foo&quot;)
340             .notEnds(&quot;/foo&quot;);
341         test(&quot;/foo&quot;)
342             .ends(&quot;foo&quot;)
343             .ends(&quot;/foo&quot;)
344             .notEnds(&quot;/&quot;);
345         test(&quot;/foo/bar&quot;)
346             .ends(&quot;bar&quot;)
347             .ends(&quot;foo/bar&quot;)
348             .ends(&quot;foo/bar/&quot;)
349             .ends(&quot;/foo/bar&quot;)
350             .notEnds(&quot;/bar&quot;);
351         test(&quot;/foo/bar/&quot;)
352             .ends(&quot;bar&quot;)
353             .ends(&quot;foo/bar&quot;)
354             .ends(&quot;foo/bar/&quot;)
355             .ends(&quot;/foo/bar&quot;)
356             .notEnds(&quot;/bar&quot;);
357         test(&quot;foo&quot;)
358             .ends(&quot;foo&quot;);
359         test(&quot;foo/bar&quot;)
360             .ends(&quot;bar&quot;)
361             .ends(&quot;bar/&quot;)
362             .ends(&quot;foo/bar/&quot;)
363             .ends(&quot;foo/bar&quot;);
364 
365         // elements
366         test(&quot;a/b/c&quot;)
367             .element(0,&quot;a&quot;)
368             .element(1,&quot;b&quot;)
369             .element(2,&quot;c&quot;);
370 
371         // isAbsolute
372         test(&quot;/&quot;)
373             .absolute();
374         test(&quot;/tmp&quot;)
375             .absolute();
376         test(&quot;tmp&quot;)
377             .notAbsolute();
378         test(&quot;&quot;)
379             .notAbsolute();
380 
381         // resolve
382         test(&quot;/tmp&quot;)
383             .resolve(&quot;foo&quot;, &quot;/tmp/foo&quot;)
384             .resolve(&quot;/foo&quot;, &quot;/foo&quot;)
385             .resolve(&quot;&quot;, &quot;/tmp&quot;);
386         test(&quot;tmp&quot;)
387             .resolve(&quot;foo&quot;, &quot;tmp/foo&quot;)
388             .resolve(&quot;/foo&quot;, &quot;/foo&quot;)
389             .resolve(&quot;&quot;, &quot;tmp&quot;);
390         test(&quot;&quot;)
391             .resolve(&quot;&quot;, &quot;&quot;)
392             .resolve(&quot;foo&quot;, &quot;foo&quot;)
393             .resolve(&quot;/foo&quot;, &quot;/foo&quot;);
394         test(&quot;/&quot;)
395             .resolve(&quot;&quot;, &quot;/&quot;)
396             .resolve(&quot;foo&quot;, &quot;/foo&quot;)
397             .resolve(&quot;/foo&quot;, &quot;/foo&quot;)
398             .resolve(&quot;/foo/&quot;, &quot;/foo&quot;);
399 
400         // resolve(Path)
401         test(&quot;/tmp&quot;)
402             .resolvePath(&quot;foo&quot;, &quot;/tmp/foo&quot;)
403             .resolvePath(&quot;/foo&quot;, &quot;/foo&quot;)
404             .resolvePath(&quot;&quot;, &quot;/tmp&quot;);
405         test(&quot;tmp&quot;)
406             .resolvePath(&quot;foo&quot;, &quot;tmp/foo&quot;)
407             .resolvePath(&quot;/foo&quot;, &quot;/foo&quot;)
408             .resolvePath(&quot;&quot;, &quot;tmp&quot;);
409         test(&quot;&quot;)
410             .resolvePath(&quot;&quot;, &quot;&quot;)
411             .resolvePath(&quot;foo&quot;, &quot;foo&quot;)
412             .resolvePath(&quot;/foo&quot;, &quot;/foo&quot;);
413         test(&quot;/&quot;)
414             .resolvePath(&quot;&quot;, &quot;/&quot;)
415             .resolvePath(&quot;foo&quot;, &quot;/foo&quot;)
416             .resolvePath(&quot;/foo&quot;, &quot;/foo&quot;)
417             .resolvePath(&quot;/foo/&quot;, &quot;/foo&quot;);
418 
419         // resolveSibling
420         test(&quot;foo&quot;)
421             .resolveSibling(&quot;bar&quot;, &quot;bar&quot;)
422             .resolveSibling(&quot;/bar&quot;, &quot;/bar&quot;)
423             .resolveSibling(&quot;&quot;, &quot;&quot;);
424         test(&quot;foo/bar&quot;)
425             .resolveSibling(&quot;gus&quot;, &quot;foo/gus&quot;)
426             .resolveSibling(&quot;/gus&quot;, &quot;/gus&quot;)
427             .resolveSibling(&quot;&quot;, &quot;foo&quot;);
428         test(&quot;/foo&quot;)
429             .resolveSibling(&quot;gus&quot;, &quot;/gus&quot;)
430             .resolveSibling(&quot;/gus&quot;, &quot;/gus&quot;)
431             .resolveSibling(&quot;&quot;, &quot;/&quot;);
432         test(&quot;/foo/bar&quot;)
433             .resolveSibling(&quot;gus&quot;, &quot;/foo/gus&quot;)
434             .resolveSibling(&quot;/gus&quot;, &quot;/gus&quot;)
435             .resolveSibling(&quot;&quot;, &quot;/foo&quot;);
436         test(&quot;&quot;)
437             .resolveSibling(&quot;foo&quot;, &quot;foo&quot;)
438             .resolveSibling(&quot;/foo&quot;, &quot;/foo&quot;)
439             .resolve(&quot;&quot;, &quot;&quot;);
440 
441         // relativize
442         test(&quot;/a/b/c&quot;)
443             .relativize(&quot;/a/b/c&quot;, &quot;&quot;)
444             .relativize(&quot;/a/b/c/d/e&quot;, &quot;d/e&quot;)
445             .relativize(&quot;/a/x&quot;, &quot;../../x&quot;)
446             .relativize(&quot;/x&quot;, &quot;../../../x&quot;);
447         test(&quot;a/b/c&quot;)
448             .relativize(&quot;a/b/c/d&quot;, &quot;d&quot;)
449             .relativize(&quot;a/x&quot;, &quot;../../x&quot;)
450             .relativize(&quot;x&quot;, &quot;../../../x&quot;)
451             .relativize(&quot;&quot;, &quot;../../..&quot;);
452         test(&quot;&quot;)
453             .relativize(&quot;a&quot;, &quot;a&quot;)
454             .relativize(&quot;a/b/c&quot;, &quot;a/b/c&quot;)
455             .relativize(&quot;&quot;, &quot;&quot;);
456         test(&quot;/&quot;)
457             .relativize(&quot;/a&quot;, &quot;a&quot;)
458             .relativize(&quot;/a/c&quot;, &quot;a/c&quot;);
459         // 8146754
460         test(&quot;/tmp/path&quot;)
461             .relativize(&quot;/tmp/path/a.txt&quot;, &quot;a.txt&quot;);
462         test(&quot;/tmp/path/&quot;)
463             .relativize(&quot;/tmp/path/a.txt&quot;, &quot;a.txt&quot;);
464 
465         // normalize
466         test(&quot;/&quot;)
467             .normalize(&quot;/&quot;);
468         test(&quot;foo&quot;)
469             .normalize(&quot;foo&quot;);
470         test(&quot;/foo&quot;)
471             .normalize(&quot;/foo&quot;);
472         test(&quot;.&quot;)
473             .normalize(&quot;&quot;);
474         test(&quot;..&quot;)
475             .normalize(&quot;..&quot;);
476         test(&quot;/..&quot;)
477             .normalize(&quot;/&quot;);
478         test(&quot;/../..&quot;)
479             .normalize(&quot;/&quot;);
480         test(&quot;foo/.&quot;)
481             .normalize(&quot;foo&quot;);
482         test(&quot;./foo&quot;)
483             .normalize(&quot;foo&quot;);
484         test(&quot;foo/..&quot;)
485             .normalize(&quot;&quot;);
486         test(&quot;../foo&quot;)
487             .normalize(&quot;../foo&quot;);
488         test(&quot;../../foo&quot;)
489             .normalize(&quot;../../foo&quot;);
490         test(&quot;foo/bar/..&quot;)
491             .normalize(&quot;foo&quot;);
492         test(&quot;foo/bar/gus/../..&quot;)
493             .normalize(&quot;foo&quot;);
494         test(&quot;/foo/bar/gus/../..&quot;)
495             .normalize(&quot;/foo&quot;);
496         test(&quot;/./.&quot;)
497             .normalize(&quot;/&quot;);
498         test(&quot;/.&quot;)
499             .normalize(&quot;/&quot;);
500         test(&quot;/./abc&quot;)
501             .normalize(&quot;/abc&quot;);
502         // invalid
503         test(&quot;foo\u0000bar&quot;)
504             .invalid();
505         test(&quot;\u0000foo&quot;)
506             .invalid();
507         test(&quot;bar\u0000&quot;)
508             .invalid();
509         test(&quot;//foo\u0000bar&quot;)
510             .invalid();
511         test(&quot;//\u0000foo&quot;)
512             .invalid();
513         test(&quot;//bar\u0000&quot;)
514             .invalid();
515 
516         // normalization
517         test(&quot;//foo//bar&quot;)
518             .string(&quot;/foo/bar&quot;)
519             .root(&quot;/&quot;)
520             .parent(&quot;/foo&quot;)
521             .name(&quot;bar&quot;);
522 
523         // isSameFile
524         test(&quot;/fileDoesNotExist&quot;)
525             .isSameFile(&quot;/fileDoesNotExist&quot;);
526 
527         // 8139956
528         out.println(&quot;check getNameCount&quot;);
529         int nc = fs.getPath(&quot;/&quot;).relativize(fs.getPath(&quot;/&quot;)).getNameCount();
530         if (nc != 1) {
531             out.format(&quot;\tExpected: 1\n&quot;);
532             out.format(&quot;\tActual: %d\n&quot;,  nc);
533             throw new RuntimeException(&quot;getNameCount of empty path failed&quot;);
534         }
535      }
536 
537     static void npes() {
538         header(&quot;NullPointerException&quot;);
539 
540         Path path = fs.getPath(&quot;foo&quot;);
541 
542         try {
543             path.resolve((String)null);
544             throw new RuntimeException(&quot;NullPointerException not thrown&quot;);
545         } catch (NullPointerException npe) {
546         }
547 
548         try {
549             path.relativize(null);
550             throw new RuntimeException(&quot;NullPointerException not thrown&quot;);
551         } catch (NullPointerException npe) {
552         }
553 
554         try {
555             path.compareTo(null);
556             throw new RuntimeException(&quot;NullPointerException not thrown&quot;);
557         } catch (NullPointerException npe) {
558         }
559 
560         try {
561             path.startsWith((Path)null);
562             throw new RuntimeException(&quot;NullPointerException not thrown&quot;);
563         } catch (NullPointerException npe) {
564         }
565 
566         try {
567             path.endsWith((Path)null);
568             throw new RuntimeException(&quot;NullPointerException not thrown&quot;);
569         } catch (NullPointerException npe) {
570         }
571 
572     }
573 
574     static void mismatchedProviders() {
575         header(&quot;ProviderMismatchException&quot;);
576         Path path = fs.getPath(&quot;foo&quot;);
577         Path other = Paths.get(&quot;foo&quot;);
578         try {
579             path.compareTo(other);
580             throw new RuntimeException(&quot;ProviderMismatchException not thrown&quot;);
581         } catch (ProviderMismatchException pme) {}
582 
583         try {
584             path.resolve(other);
585             throw new RuntimeException(&quot;ProviderMismatchException not thrown&quot;);
586         } catch (ProviderMismatchException pme) {}
587 
588         try {
589             path.relativize(other);
590             throw new RuntimeException(&quot;ProviderMismatchException not thrown&quot;);
591         } catch (ProviderMismatchException pme) {}
592 
593         try {
594             if (path.startsWith(other))
595                 throw new RuntimeException(&quot;providerMismatched startsWith() returns true &quot;);
596             if (path.endsWith(other))
597                 throw new RuntimeException(&quot;providerMismatched endsWith() returns true &quot;);
598         } catch (ProviderMismatchException pme) {
599             throw new RuntimeException(&quot;ProviderMismatchException is thrown for starts/endsWith()&quot;);
600         }
601     }
602 
603     public static void main(String[] args) throws IOException {
604         // create empty JAR file, test doesn&#39;t require any contents
605         Path emptyJar = Utils.createJarFile(&quot;empty.jar&quot;);
606 
607         fs = FileSystems.newFileSystem(emptyJar);
608         try {
609             npes();
610             mismatchedProviders();
611             doPathOpTests();
612         } finally {
613             fs.close();
614         }
615     }
616 }
    </pre>
  </body>
</html>
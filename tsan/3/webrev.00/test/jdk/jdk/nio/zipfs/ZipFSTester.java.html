<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New test/jdk/jdk/nio/zipfs/ZipFSTester.java</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 2010, 2019, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  */
  23 
  24 import java.io.File;
  25 import java.io.IOException;
  26 import java.io.InputStream;
  27 import java.io.OutputStream;
  28 import java.net.URI;
  29 import java.net.URLDecoder;
  30 import java.nio.ByteBuffer;
  31 import java.nio.channels.Channels;
  32 import java.nio.channels.FileChannel;
  33 import java.nio.channels.SeekableByteChannel;
  34 import java.nio.file.DirectoryStream;
  35 import java.nio.file.FileAlreadyExistsException;
  36 import java.nio.file.FileSystem;
  37 import java.nio.file.FileSystemAlreadyExistsException;
  38 import java.nio.file.FileSystemException;
  39 import java.nio.file.FileSystems;
  40 import java.nio.file.FileVisitResult;
  41 import java.nio.file.Files;
  42 import java.nio.file.OpenOption;
  43 import java.nio.file.Path;
  44 import java.nio.file.Paths;
  45 import java.nio.file.SimpleFileVisitor;
  46 import java.nio.file.attribute.BasicFileAttributeView;
  47 import java.nio.file.attribute.BasicFileAttributes;
  48 import java.nio.file.spi.FileSystemProvider;
  49 import java.util.ArrayList;
  50 import java.util.Arrays;
  51 import java.util.Collections;
  52 import java.util.Enumeration;
  53 import java.util.HashMap;
  54 import java.util.HashSet;
  55 import java.util.Iterator;
  56 import java.util.LinkedList;
  57 import java.util.List;
  58 import java.util.Map;
  59 import java.util.Random;
  60 import java.util.Set;
  61 import java.util.concurrent.TimeUnit;
  62 import java.util.zip.CRC32;
  63 import java.util.zip.ZipEntry;
  64 import java.util.zip.ZipFile;
  65 import java.util.zip.ZipOutputStream;
  66 
  67 import static java.nio.file.StandardOpenOption.*;
  68 import static java.nio.file.StandardCopyOption.*;
  69 
  70 /*
  71  * Tests various zipfs operations.
  72  *
  73  * @test
  74  * @bug 6990846 7009092 7009085 7015391 7014948 7005986 7017840 7007596
  75  *      7157656 8002390 7012868 7012856 8015728 8038500 8040059 8069211
  76  *      8131067 8034802 8210899
  77  * @summary Test Zip filesystem provider
  78  * @modules jdk.zipfs
  79  * @run main ZipFSTester
  80  * @run main/othervm/java.security.policy=test.policy ZipFSTester
  81  */
  82 
  83 public class ZipFSTester {
  84     public static void main(String[] args) throws Exception {
  85         // create JAR file for test, actual contents don&#39;t matter
  86         Path jarFile = Utils.createJarFile(&quot;tester.jar&quot;,
  87                 &quot;META-INF/MANIFEST.MF&quot;,
  88                 &quot;dir1/foo&quot;,
  89                 &quot;dir2/bar&quot;,
  90                 &quot;dir1/dir3/fooo&quot;);
  91 
  92         try (FileSystem fs = newZipFileSystem(jarFile, Collections.emptyMap())) {
  93             test0(fs);
  94             test1(fs);
  95             test2(fs);   // more tests
  96         }
  97         testStreamChannel();
  98         testTime(jarFile);
  99         test8069211();
 100         test8131067();
 101     }
 102 
 103     private static Random rdm = new Random();
 104 
 105     static void test0(FileSystem fs)
 106         throws Exception
 107     {
 108         List&lt;String&gt; list = new LinkedList&lt;&gt;();
 109         try (ZipFile zf = new ZipFile(fs.toString())) {
 110             Enumeration&lt;? extends ZipEntry&gt; zes = zf.entries();
 111             while (zes.hasMoreElements()) {
 112                 list.add(zes.nextElement().getName());
 113             }
 114             for (String pname : list) {
 115                 Path path = fs.getPath(pname);
 116                 if (!Files.exists(path))
 117                     throw new RuntimeException(&quot;path existence check failed!&quot;);
 118                 while ((path = path.getParent()) != null) {
 119                     if (!Files.exists(path))
 120                         throw new RuntimeException(&quot;parent existence check failed!&quot;);
 121                 }
 122             }
 123         }
 124     }
 125 
 126     static void test1(FileSystem fs0)
 127         throws Exception
 128     {
 129         // prepare a src for testing
 130         Path src = getTempPath();
 131         String tmpName = src.toString();
 132         try (OutputStream os = Files.newOutputStream(src)) {
 133             byte[] bits = new byte[12345];
 134             rdm.nextBytes(bits);
 135             os.write(bits);
 136         }
 137 
 138         // clone a fs from fs0 and test on it
 139         Path tmpfsPath = getTempPath();
 140         Map&lt;String, Object&gt; env = new HashMap&lt;String, Object&gt;();
 141         env.put(&quot;create&quot;, &quot;true&quot;);
 142         try (FileSystem copy = newZipFileSystem(tmpfsPath, env)) {
 143             z2zcopy(fs0, copy, &quot;/&quot;, 0);
 144 
 145             // copy the test jar itself in
 146             Files.copy(Paths.get(fs0.toString()), copy.getPath(&quot;/foo.jar&quot;));
 147             Path zpath = copy.getPath(&quot;/foo.jar&quot;);
 148             try (FileSystem zzfs = FileSystems.newFileSystem(zpath)) {
 149                 Files.copy(src, zzfs.getPath(&quot;/srcInjarjar&quot;));
 150             }
 151         }
 152 
 153         try (FileSystem fs = newZipFileSystem(tmpfsPath, new HashMap&lt;String, Object&gt;())) {
 154 
 155             FileSystemProvider provider = fs.provider();
 156             // newFileSystem(path...) should not throw exception
 157             try (FileSystem fsPath = provider.newFileSystem(tmpfsPath, new HashMap&lt;String, Object&gt;())){}
 158             try (FileSystem fsUri = provider.newFileSystem(
 159                      new URI(&quot;jar&quot;, tmpfsPath.toUri().toString(), null),
 160                      new HashMap&lt;String, Object&gt;()))
 161             {
 162                 throw new RuntimeException(&quot;newFileSystem(URI...) does not throw exception&quot;);
 163             } catch (FileSystemAlreadyExistsException fsaee) {}
 164 
 165             try {
 166                 provider.newFileSystem(new File(System.getProperty(&quot;test.src&quot;, &quot;.&quot;)).toPath(),
 167                                        new HashMap&lt;String, Object&gt;());
 168                 throw new RuntimeException(&quot;newFileSystem() opens a directory as zipfs&quot;);
 169             } catch (UnsupportedOperationException uoe) {}
 170 
 171             try {
 172                 provider.newFileSystem(src, new HashMap&lt;String, Object&gt;());
 173                 throw new RuntimeException(&quot;newFileSystem() opens a non-zip file as zipfs&quot;);
 174             } catch (UnsupportedOperationException uoe) {}
 175 
 176             // walk
 177             walk(fs.getPath(&quot;/&quot;));
 178 
 179             // copyin
 180             Path dst = getPathWithParents(fs, tmpName);
 181             Files.copy(src, dst);
 182             checkEqual(src, dst);
 183 
 184             // copy
 185             Path dst2 = getPathWithParents(fs, &quot;/xyz&quot; + rdm.nextInt(100) +
 186                                            &quot;/efg&quot; + rdm.nextInt(100) + &quot;/foo.class&quot;);
 187             Files.copy(dst, dst2);
 188             //dst.moveTo(dst2);
 189             checkEqual(src, dst2);
 190 
 191             // delete
 192             Files.delete(dst);
 193             if (Files.exists(dst))
 194                 throw new RuntimeException(&quot;Failed!&quot;);
 195 
 196             // moveout
 197             Path dst3 = Paths.get(tmpName + &quot;_Tmp&quot;);
 198             Files.move(dst2, dst3);
 199             checkEqual(src, dst3);
 200             if (Files.exists(dst2))
 201                 throw new RuntimeException(&quot;Failed!&quot;);
 202 
 203             // copyback + move
 204             Files.copy(dst3, dst);
 205             Path dst4 = getPathWithParents(fs, tmpName + &quot;_Tmp0&quot;);
 206             Files.move(dst, dst4);
 207             checkEqual(src, dst4);
 208 
 209             // delete
 210             Files.delete(dst4);
 211             if (Files.exists(dst4))
 212                 throw new RuntimeException(&quot;Failed!&quot;);
 213             Files.delete(dst3);
 214             if (Files.exists(dst3))
 215                 throw new RuntimeException(&quot;Failed!&quot;);
 216 
 217             // move (existing entry)
 218             Path dst5 = fs.getPath(&quot;META-INF/MANIFEST.MF&quot;);
 219             if (Files.exists(dst5)) {
 220                 Path dst6 = fs.getPath(&quot;META-INF/MANIFEST.MF_TMP&quot;);
 221                 Files.move(dst5, dst6);
 222                 walk(fs.getPath(&quot;/&quot;));
 223             }
 224 
 225             // newInputStream on dir
 226             Path parent = dst2.getParent();
 227             try {
 228                 Files.newInputStream(parent);
 229                 throw new RuntimeException(&quot;Failed&quot;);
 230             } catch (FileSystemException e) {
 231                 // expected fse
 232             }
 233 
 234             // rmdirs
 235             try {
 236                 rmdirs(parent);
 237             } catch (IOException x) {
 238                 x.printStackTrace();
 239             }
 240 
 241             // newFileChannel() copy in, out and verify via fch
 242             fchCopy(src, dst);    // in
 243             checkEqual(src, dst);
 244             Path tmp = Paths.get(tmpName + &quot;_Tmp&quot;);
 245             fchCopy(dst, tmp);   //  out
 246             checkEqual(src, tmp);
 247             Files.delete(tmp);
 248 
 249             // test channels
 250             channel(fs, dst);
 251             Files.delete(dst);
 252 
 253             // test foo.jar in jar/zipfs #8034802
 254             Path jpath = fs.getPath(&quot;/foo.jar&quot;);
 255             System.out.println(&quot;walking: &quot; + jpath);
 256             try (FileSystem zzfs = FileSystems.newFileSystem(jpath)) {
 257                 walk(zzfs.getPath(&quot;/&quot;));
 258                 // foojar:/srcInjarjar
 259                 checkEqual(src, zzfs.getPath(&quot;/srcInjarjar&quot;));
 260 
 261                 dst = getPathWithParents(zzfs, tmpName);
 262                 fchCopy(src, dst);
 263                 checkEqual(src, dst);
 264                 tmp = Paths.get(tmpName + &quot;_Tmp&quot;);
 265                 fchCopy(dst, tmp);   //  out
 266                 checkEqual(src, tmp);
 267                 Files.delete(tmp);
 268 
 269                 channel(zzfs, dst);
 270                 Files.delete(dst);
 271             }
 272         } finally {
 273             Files.deleteIfExists(tmpfsPath);
 274             Files.deleteIfExists(src);
 275         }
 276     }
 277 
 278     static void test2(FileSystem fs) throws Exception {
 279 
 280         Path fs1Path = getTempPath();
 281         Path fs2Path = getTempPath();
 282         Path fs3Path = getTempPath();
 283 
 284         // create a new filesystem, copy everything from fs
 285         Map&lt;String, Object&gt; env = new HashMap&lt;String, Object&gt;();
 286         env.put(&quot;create&quot;, &quot;true&quot;);
 287         FileSystem fs0 = newZipFileSystem(fs1Path, env);
 288 
 289         final FileSystem fs2 = newZipFileSystem(fs2Path, env);
 290         final FileSystem fs3 = newZipFileSystem(fs3Path, env);
 291 
 292         System.out.println(&quot;copy src: fs -&gt; fs0...&quot;);
 293         z2zcopy(fs, fs0, &quot;/&quot;, 0);   // copy fs -&gt; fs1
 294         fs0.close();                // dump to file
 295 
 296         System.out.println(&quot;open fs0 as fs1&quot;);
 297         env = new HashMap&lt;String, Object&gt;();
 298         final FileSystem fs1 = newZipFileSystem(fs1Path, env);
 299 
 300         System.out.println(&quot;listing...&quot;);
 301         final ArrayList&lt;String&gt; files = new ArrayList&lt;&gt;();
 302         final ArrayList&lt;String&gt; dirs = new ArrayList&lt;&gt;();
 303         list(fs1.getPath(&quot;/&quot;), files, dirs);
 304 
 305         Thread t0 = new Thread(new Runnable() {
 306             public void run() {
 307                 List&lt;String&gt; list = new ArrayList&lt;&gt;(dirs);
 308                 Collections.shuffle(list);
 309                 for (String path : list) {
 310                     try {
 311                         z2zcopy(fs1, fs2, path, 0);
 312                     } catch (Exception x) {
 313                         x.printStackTrace();
 314                     }
 315                 }
 316             }
 317 
 318         });
 319 
 320         Thread t1 = new Thread(new Runnable() {
 321             public void run() {
 322                 List&lt;String&gt; list = new ArrayList&lt;&gt;(dirs);
 323                 Collections.shuffle(list);
 324                 for (String path : list) {
 325                     try {
 326                         z2zcopy(fs1, fs2, path, 1);
 327                     } catch (Exception x) {
 328                         x.printStackTrace();
 329                     }
 330                 }
 331             }
 332 
 333         });
 334 
 335         Thread t2 = new Thread(new Runnable() {
 336             public void run() {
 337                 List&lt;String&gt; list = new ArrayList&lt;&gt;(dirs);
 338                 Collections.shuffle(list);
 339                 for (String path : list) {
 340                     try {
 341                         z2zcopy(fs1, fs2, path, 2);
 342                     } catch (Exception x) {
 343                         x.printStackTrace();
 344                     }
 345                 }
 346             }
 347 
 348         });
 349 
 350         Thread t3 = new Thread(new Runnable() {
 351             public void run() {
 352                 List&lt;String&gt; list = new ArrayList&lt;&gt;(files);
 353                 Collections.shuffle(list);
 354                 while (!list.isEmpty()) {
 355                     Iterator&lt;String&gt; itr = list.iterator();
 356                     while (itr.hasNext()) {
 357                         String path = itr.next();
 358                         try {
 359                             if (Files.exists(fs2.getPath(path))) {
 360                                 z2zmove(fs2, fs3, path);
 361                                 itr.remove();
 362                             }
 363                         } catch (FileAlreadyExistsException x){
 364                             itr.remove();
 365                         } catch (Exception x) {
 366                             x.printStackTrace();
 367                         }
 368                     }
 369                 }
 370             }
 371 
 372         });
 373 
 374         System.out.println(&quot;copying/removing...&quot;);
 375         t0.start(); t1.start(); t2.start(); t3.start();
 376         t0.join(); t1.join(); t2.join(); t3.join();
 377 
 378         System.out.println(&quot;closing: fs1, fs2&quot;);
 379         fs1.close();
 380         fs2.close();
 381 
 382         int failed = 0;
 383         System.out.println(&quot;checkEqual: fs vs fs3&quot;);
 384         for (String path : files) {
 385             try {
 386                 checkEqual(fs.getPath(path), fs3.getPath(path));
 387             } catch (IOException x) {
 388                 //x.printStackTrace();
 389                 failed++;
 390             }
 391         }
 392         System.out.println(&quot;closing: fs3&quot;);
 393         fs3.close();
 394 
 395         System.out.println(&quot;opening: fs3 as fs4&quot;);
 396         FileSystem fs4 = newZipFileSystem(fs3Path, env);
 397 
 398 
 399         ArrayList&lt;String&gt; files2 = new ArrayList&lt;&gt;();
 400         ArrayList&lt;String&gt; dirs2 = new ArrayList&lt;&gt;();
 401         list(fs4.getPath(&quot;/&quot;), files2, dirs2);
 402 
 403         System.out.println(&quot;checkEqual: fs vs fs4&quot;);
 404         for (String path : files2) {
 405             checkEqual(fs.getPath(path), fs4.getPath(path));
 406         }
 407         System.out.println(&quot;walking: fs4&quot;);
 408         walk(fs4.getPath(&quot;/&quot;));
 409         System.out.println(&quot;closing: fs4&quot;);
 410         fs4.close();
 411         System.out.printf(&quot;failed=%d%n&quot;, failed);
 412 
 413         Files.delete(fs1Path);
 414         Files.delete(fs2Path);
 415         Files.delete(fs3Path);
 416     }
 417 
 418     static final int METHOD_STORED     = 0;
 419     static final int METHOD_DEFLATED   = 8;
 420 
 421     static Object[][] getEntries() {
 422         Object[][] entries = new Object[10 + rdm.nextInt(20)][3];
 423         // first entries shall test the corner case of 0 bytes of data
 424         entries[0][0] = &quot;entries&quot; + 0;
 425         entries[0][1] = METHOD_STORED;
 426         entries[0][2] = new byte[0];
 427         entries[1][0] = &quot;entries&quot; + 1;
 428         entries[1][1] = METHOD_DEFLATED;
 429         entries[1][2] = new byte[0];
 430         // the rest is random data
 431         for (int i = 2; i &lt; entries.length; i++) {
 432             entries[i][0] = &quot;entries&quot; + i;
 433             entries[i][1] = rdm.nextInt(10) % 2 == 0 ?
 434                 METHOD_STORED : METHOD_DEFLATED;
 435             entries[i][2] = new byte[rdm.nextInt(8192)];
 436             rdm.nextBytes((byte[])entries[i][2]);
 437         }
 438         return entries;
 439     }
 440 
 441     // check the content of read from zipfs is equal to the &quot;bytes&quot;
 442     private static void checkRead(Path path, byte[] expected) throws IOException {
 443 
 444         // fileAttribute
 445         CRC32 crc32 = new CRC32();
 446         crc32.update(expected);
 447 
 448         if (((Long)Files.getAttribute(path, &quot;zip:crc&quot;)).intValue() !=
 449             (int)crc32.getValue()) {
 450             System.out.printf(&quot; getAttribute.crc &lt;%s&gt; failed %x vs %x ...%n&quot;,
 451                               path.toString(),
 452                               ((Long)Files.getAttribute(path, &quot;zip:crc&quot;)).intValue(),
 453                               (int)crc32.getValue());
 454             throw new RuntimeException(&quot;CHECK FAILED!&quot;);
 455         }
 456 
 457         if (((Long)Files.getAttribute(path, &quot;zip:size&quot;)).intValue() != expected.length) {
 458             System.out.printf(&quot; getAttribute.size &lt;%s&gt; failed %x vs %x ...%n&quot;,
 459                               path.toString(),
 460                               ((Long)Files.getAttribute(path, &quot;zip:size&quot;)).intValue(),
 461                               expected.length);
 462             throw new RuntimeException(&quot;CHECK FAILED!&quot;);
 463         }
 464 
 465         //streams
 466         try (InputStream is = Files.newInputStream(path)) {
 467             if (!Arrays.equals(is.readAllBytes(), expected)) {
 468                 System.out.printf(&quot; newInputStream &lt;%s&gt; failed...%n&quot;, path.toString());
 469                 throw new RuntimeException(&quot;CHECK FAILED!&quot;);
 470             }
 471         }
 472 
 473         // channels -- via sun.nio.ch.ChannelInputStream
 474         try (SeekableByteChannel sbc = Files.newByteChannel(path);
 475             InputStream is = Channels.newInputStream(sbc)) {
 476 
 477             // check all bytes match
 478             if (!Arrays.equals(is.readAllBytes(), expected)) {
 479                 System.out.printf(&quot; newByteChannel &lt;%s&gt; failed...%n&quot;, path.toString());
 480                 throw new RuntimeException(&quot;CHECK FAILED!&quot;);
 481             }
 482 
 483             // Check if read position is at the end
 484             if (sbc.position() != expected.length) {
 485                 System.out.printf(&quot;pos [%s]: size=%d, position=%d%n&quot;,
 486                                   path.toString(), expected.length, sbc.position());
 487                 throw new RuntimeException(&quot;CHECK FAILED!&quot;);
 488             }
 489 
 490             // Check position(x) + read() at the random/specific pos/len
 491             byte[] buf = new byte[1024];
 492             ByteBuffer bb = ByteBuffer.wrap(buf);
 493             for (int i = 0; i &lt; 10; i++) {
 494                 int pos = 0;
 495                 int len = 0;
 496                 if (expected.length &gt; 0) {
 497                     pos = rdm.nextInt((int) sbc.size());
 498                     len = rdm.nextInt(Math.min(buf.length, expected.length - pos));
 499                 }
 500                 // System.out.printf(&quot;  --&gt; %d, %d%n&quot;, pos, len);
 501                 bb.position(0).limit(len);    // bb.flip().limit(len);
 502                 if (sbc.position(pos).position() != pos ||
 503                     sbc.read(bb) != len ||
 504                     !Arrays.equals(buf, 0, bb.position(), expected, pos, pos + len)) {
 505                     System.out.printf(&quot;read()/position() failed%n&quot;);
 506                 }
 507             }
 508         } catch (IOException x) {
 509             x.printStackTrace();
 510             throw new RuntimeException(&quot;CHECK FAILED!&quot;);
 511         }
 512     }
 513 
 514     // test entry stream/channel reading
 515     static void testStreamChannel() throws Exception {
 516         Path zpath = getTempPath();
 517         try {
 518             var crc = new CRC32();
 519             Object[][] entries = getEntries();
 520 
 521             // [1] create zip via ZipOutputStream
 522             try (var os = Files.newOutputStream(zpath);
 523                  var zos = new ZipOutputStream(os)) {
 524                 for (Object[] entry : entries) {
 525                    var ze = new ZipEntry((String)entry[0]);
 526                    int method = (int)entry[1];
 527                    byte[] bytes = (byte[])entry[2];
 528                    if (method == METHOD_STORED) {
 529                        ze.setSize(bytes.length);
 530                        crc.reset();
 531                        crc.update(bytes);
 532                        ze.setCrc(crc.getValue());
 533                    }
 534                    ze.setMethod(method);
 535                    zos.putNextEntry(ze);
 536                    zos.write(bytes);
 537                    zos.closeEntry();
 538                 }
 539             }
 540             try (var zfs = newZipFileSystem(zpath, Collections.emptyMap())) {
 541                 for (Object[] e : entries) {
 542                     Path path = zfs.getPath((String)e[0]);
 543                     byte[] bytes = (byte[])e[2];
 544                     checkRead(path, bytes);
 545                 }
 546             }
 547             Files.deleteIfExists(zpath);
 548 
 549             // [2] create zip via zfs.newByteChannel
 550             try (var zfs = newZipFileSystem(zpath, Map.of(&quot;create&quot;, &quot;true&quot;))) {
 551                 for (Object[] e : entries) {
 552                     //  tbd: method is not used
 553                     try (var sbc = Files.newByteChannel(zfs.getPath((String)e[0]),
 554                                                         CREATE_NEW, WRITE)) {
 555                         sbc.write(ByteBuffer.wrap((byte[])e[2]));
 556                     }
 557                 }
 558             }
 559             try (var zfs = newZipFileSystem(zpath, Collections.emptyMap())) {
 560                 for (Object[] e : entries) {
 561                     checkRead(zfs.getPath((String)e[0]), (byte[])e[2]);
 562                 }
 563             }
 564             Files.deleteIfExists(zpath);
 565 
 566             // [3] create zip via Files.write()/newoutputStream/
 567             try (var zfs = newZipFileSystem(zpath, Map.of(&quot;create&quot;, &quot;true&quot;))) {
 568                 for (Object[] e : entries) {
 569                     Files.write(zfs.getPath((String)e[0]), (byte[])e[2]);
 570                 }
 571             }
 572             try (var zfs = newZipFileSystem(zpath, Collections.emptyMap())) {
 573                 for (Object[] e : entries) {
 574                     checkRead(zfs.getPath((String)e[0]), (byte[])e[2]);
 575                 }
 576             }
 577             Files.deleteIfExists(zpath);
 578 
 579             // [4] create zip via zfs.newByteChannel, with &quot;method_stored&quot;
 580             try (var zfs = newZipFileSystem(zpath,
 581                     Map.of(&quot;create&quot;, true, &quot;noCompression&quot;, true))) {
 582                 for (Object[] e : entries) {
 583                     try (var sbc = Files.newByteChannel(zfs.getPath((String)e[0]),
 584                                                         CREATE_NEW, WRITE)) {
 585                         sbc.write(ByteBuffer.wrap((byte[])e[2]));
 586                     }
 587                 }
 588             }
 589             try (var zfs = newZipFileSystem(zpath, Collections.emptyMap())) {
 590                 for (Object[] e : entries) {
 591                     checkRead(zfs.getPath((String)e[0]), (byte[])e[2]);
 592                 }
 593             }
 594             Files.deleteIfExists(zpath);
 595 
 596         } finally {
 597             Files.deleteIfExists(zpath);
 598         }
 599     }
 600 
 601     // test file stamp
 602     static void testTime(Path src) throws Exception {
 603         BasicFileAttributes attrs = Files
 604                         .getFileAttributeView(src, BasicFileAttributeView.class)
 605                         .readAttributes();
 606         // create a new filesystem, copy this file into it
 607         Map&lt;String, Object&gt; env = new HashMap&lt;String, Object&gt;();
 608         env.put(&quot;create&quot;, &quot;true&quot;);
 609         Path fsPath = getTempPath();
 610         try (FileSystem fs = newZipFileSystem(fsPath, env)) {
 611             System.out.println(&quot;test copy with timestamps...&quot;);
 612             // copyin
 613             Path dst = getPathWithParents(fs, &quot;me&quot;);
 614             Files.copy(src, dst, COPY_ATTRIBUTES);
 615             checkEqual(src, dst);
 616             System.out.println(&quot;mtime: &quot; + attrs.lastModifiedTime());
 617             System.out.println(&quot;ctime: &quot; + attrs.creationTime());
 618             System.out.println(&quot;atime: &quot; + attrs.lastAccessTime());
 619             System.out.println(&quot; ==============&gt;&quot;);
 620             BasicFileAttributes dstAttrs = Files
 621                             .getFileAttributeView(dst, BasicFileAttributeView.class)
 622                             .readAttributes();
 623             System.out.println(&quot;mtime: &quot; + dstAttrs.lastModifiedTime());
 624             System.out.println(&quot;ctime: &quot; + dstAttrs.creationTime());
 625             System.out.println(&quot;atime: &quot; + dstAttrs.lastAccessTime());
 626 
 627             // 1-second granularity
 628             if (attrs.lastModifiedTime().to(TimeUnit.SECONDS) !=
 629                 dstAttrs.lastModifiedTime().to(TimeUnit.SECONDS) ||
 630                 attrs.lastAccessTime().to(TimeUnit.SECONDS) !=
 631                 dstAttrs.lastAccessTime().to(TimeUnit.SECONDS) ||
 632                 attrs.creationTime().to(TimeUnit.SECONDS) !=
 633                 dstAttrs.creationTime().to(TimeUnit.SECONDS)) {
 634                 throw new RuntimeException(&quot;Timestamp Copy Failed!&quot;);
 635             }
 636         } finally {
 637             Files.delete(fsPath);
 638         }
 639     }
 640 
 641     static void test8069211() throws Exception {
 642         // create a new filesystem, copy this file into it
 643         Map&lt;String, Object&gt; env = new HashMap&lt;String, Object&gt;();
 644         env.put(&quot;create&quot;, &quot;true&quot;);
 645         Path fsPath = getTempPath();
 646         try (FileSystem fs = newZipFileSystem(fsPath, env);) {
 647             OutputStream out = Files.newOutputStream(fs.getPath(&quot;/foo&quot;));
 648             out.write(&quot;hello&quot;.getBytes());
 649             out.close();
 650             out.close();
 651         }
 652         try (FileSystem fs = newZipFileSystem(fsPath, new HashMap&lt;String, Object&gt;())) {
 653             if (!Arrays.equals(Files.readAllBytes(fs.getPath(&quot;/foo&quot;)),
 654                                &quot;hello&quot;.getBytes())) {
 655                 throw new RuntimeException(&quot;entry close() failed&quot;);
 656             }
 657         } catch (Exception x) {
 658             throw new RuntimeException(&quot;entry close() failed&quot;, x);
 659         } finally {
 660             Files.delete(fsPath);
 661         }
 662     }
 663 
 664     static void test8131067() throws Exception {
 665         Map&lt;String, Object&gt; env = new HashMap&lt;String, Object&gt;();
 666         env.put(&quot;create&quot;, &quot;true&quot;);
 667 
 668         // file name with space character for URI to quote it
 669         File tmp = File.createTempFile(&quot;test zipfs&quot;, &quot;zip&quot;);
 670         tmp.delete();    // we need a clean path, no file
 671         Path fsPath = tmp.toPath();
 672         try (FileSystem fs = newZipFileSystem(fsPath, env);) {
 673             Files.write(fs.getPath(&quot;/foo&quot;), &quot;hello&quot;.getBytes());
 674             URI fooUri = fs.getPath(&quot;/foo&quot;).toUri();
 675             if (!Arrays.equals(Files.readAllBytes(Paths.get(fooUri)),
 676                                &quot;hello&quot;.getBytes())) {
 677                 throw new RuntimeException(&quot;entry close() failed&quot;);
 678             }
 679         } finally {
 680             Files.delete(fsPath);
 681         }
 682     }
 683 
 684     private static FileSystem newZipFileSystem(Path path, Map&lt;String, ?&gt; env)
 685         throws Exception
 686     {
 687         // Use URLDecoder (for test only) to remove the double escaped space
 688         // character
 689         return FileSystems.newFileSystem(
 690             new URI(&quot;jar&quot;, URLDecoder.decode(path.toUri().toString(), &quot;utf8&quot;),
 691                 null), env, null);
 692     }
 693 
 694     private static Path getTempPath() throws IOException
 695     {
 696         File tmp = File.createTempFile(&quot;testzipfs_&quot;, &quot;zip&quot;);
 697         tmp.delete();    // we need a clean path, no file
 698         return tmp.toPath();
 699     }
 700 
 701     private static void list(Path path, List&lt;String&gt; files, List&lt;String&gt; dirs )
 702         throws IOException
 703     {
 704         if (Files.isDirectory(path)) {
 705             try (DirectoryStream&lt;Path&gt; ds = Files.newDirectoryStream(path)) {
 706                 for (Path child : ds)
 707                     list(child, files, dirs);
 708             }
 709             dirs.add(path.toString());
 710         } else {
 711             files.add(path.toString());
 712         }
 713     }
 714 
 715     private static void z2zcopy(FileSystem src, FileSystem dst, String path,
 716                                 int method)
 717         throws IOException
 718     {
 719         Path srcPath = src.getPath(path);
 720         Path dstPath = dst.getPath(path);
 721 
 722         if (Files.isDirectory(srcPath)) {
 723             if (!Files.exists(dstPath)) {
 724                 try {
 725                     mkdirs(dstPath);
 726                 } catch (FileAlreadyExistsException x) {}
 727             }
 728             try (DirectoryStream&lt;Path&gt; ds = Files.newDirectoryStream(srcPath)) {
 729                 for (Path child : ds) {
 730                     z2zcopy(src, dst,
 731                            path + (path.endsWith(&quot;/&quot;)?&quot;&quot;:&quot;/&quot;) + child.getFileName(),
 732                            method);
 733                 }
 734             }
 735         } else {
 736             try {
 737                 if (Files.exists(dstPath))
 738                     return;
 739                 switch (method) {
 740                 case 0:
 741                     Files.copy(srcPath, dstPath);
 742                     break;
 743                 case 1:
 744                     chCopy(srcPath, dstPath);
 745                     break;
 746                 case 2:
 747                     //fchCopy(srcPath, dstPath);
 748                     streamCopy(srcPath, dstPath);
 749                     break;
 750                 }
 751             } catch (FileAlreadyExistsException x) {}
 752         }
 753     }
 754 
 755     private static void z2zmove(FileSystem src, FileSystem dst, String path)
 756         throws IOException
 757     {
 758         Path srcPath = src.getPath(path);
 759         Path dstPath = dst.getPath(path);
 760 
 761         if (Files.isDirectory(srcPath)) {
 762             if (!Files.exists(dstPath))
 763                 mkdirs(dstPath);
 764             try (DirectoryStream&lt;Path&gt; ds = Files.newDirectoryStream(srcPath)) {
 765                 for (Path child : ds) {
 766                     z2zmove(src, dst,
 767                             path + (path.endsWith(&quot;/&quot;)?&quot;&quot;:&quot;/&quot;) + child.getFileName());
 768                 }
 769             }
 770         } else {
 771             //System.out.println(&quot;moving...&quot; + path);
 772             Path parent = dstPath.getParent();
 773             if (parent != null &amp;&amp; Files.notExists(parent))
 774                 mkdirs(parent);
 775             Files.move(srcPath, dstPath);
 776         }
 777     }
 778 
 779     private static void walk(Path path) throws IOException
 780     {
 781         Files.walkFileTree(
 782             path,
 783             new SimpleFileVisitor&lt;Path&gt;() {
 784                 private int indent = 0;
 785                 private void indent() {
 786                     int n = 0;
 787                     while (n++ &lt; indent)
 788                         System.out.printf(&quot; &quot;);
 789                 }
 790 
 791                 @Override
 792                 public FileVisitResult visitFile(Path file,
 793                                                  BasicFileAttributes attrs)
 794                 {
 795                     indent();
 796                     System.out.printf(&quot;%s%n&quot;, file.getFileName().toString());
 797                     return FileVisitResult.CONTINUE;
 798                 }
 799 
 800                 @Override
 801                 public FileVisitResult preVisitDirectory(Path dir,
 802                                                          BasicFileAttributes attrs)
 803                 {
 804                     indent();
 805                     System.out.printf(&quot;[%s]%n&quot;, dir.toString());
 806                     indent += 2;
 807                     return FileVisitResult.CONTINUE;
 808                 }
 809 
 810                 @Override
 811                 public FileVisitResult postVisitDirectory(Path dir,
 812                                                           IOException ioe)
 813                     throws IOException
 814                 {
 815                     indent -= 2;
 816                     return FileVisitResult.CONTINUE;
 817                 }
 818         });
 819     }
 820 
 821     private static void mkdirs(Path path) throws IOException {
 822         if (Files.exists(path))
 823             return;
 824         path = path.toAbsolutePath();
 825         Path parent = path.getParent();
 826         if (parent != null) {
 827             if (Files.notExists(parent))
 828                 mkdirs(parent);
 829         }
 830         Files.createDirectory(path);
 831     }
 832 
 833     private static void rmdirs(Path path) throws IOException {
 834         while (path != null &amp;&amp; path.getNameCount() != 0) {
 835             Files.delete(path);
 836             path = path.getParent();
 837         }
 838     }
 839 
 840     // check the content of two paths are equal
 841     private static void checkEqual(Path src, Path dst) throws IOException
 842     {
 843         System.out.printf(&quot;checking &lt;%s&gt; vs &lt;%s&gt;...%n&quot;,
 844                           src.toString(), dst.toString());
 845 
 846         //streams
 847         byte[] bufSrc = new byte[8192];
 848         byte[] bufDst = new byte[8192];
 849         try (InputStream isSrc = Files.newInputStream(src);
 850              InputStream isDst = Files.newInputStream(dst))
 851         {
 852             int nSrc = 0;
 853             while ((nSrc = isSrc.read(bufSrc)) != -1) {
 854                 int nDst = 0;
 855                 while (nDst &lt; nSrc) {
 856                     int n = isDst.read(bufDst, nDst, nSrc - nDst);
 857                     if (n == -1) {
 858                         System.out.printf(&quot;checking &lt;%s&gt; vs &lt;%s&gt;...%n&quot;,
 859                                           src.toString(), dst.toString());
 860                         throw new RuntimeException(&quot;CHECK FAILED!&quot;);
 861                     }
 862                     nDst += n;
 863                 }
 864                 while (--nSrc &gt;= 0) {
 865                     if (bufSrc[nSrc] != bufDst[nSrc]) {
 866                         System.out.printf(&quot;checking &lt;%s&gt; vs &lt;%s&gt;...%n&quot;,
 867                                           src.toString(), dst.toString());
 868                         throw new RuntimeException(&quot;CHECK FAILED!&quot;);
 869                     }
 870                     nSrc--;
 871                 }
 872             }
 873         }
 874 
 875         // channels
 876         try (SeekableByteChannel chSrc = Files.newByteChannel(src);
 877              SeekableByteChannel chDst = Files.newByteChannel(dst))
 878         {
 879             if (chSrc.size() != chDst.size()) {
 880                 System.out.printf(&quot;src[%s].size=%d, dst[%s].size=%d%n&quot;,
 881                                   chSrc.toString(), chSrc.size(),
 882                                   chDst.toString(), chDst.size());
 883                 throw new RuntimeException(&quot;CHECK FAILED!&quot;);
 884             }
 885             ByteBuffer bbSrc = ByteBuffer.allocate(8192);
 886             ByteBuffer bbDst = ByteBuffer.allocate(8192);
 887 
 888             int nSrc = 0;
 889             while ((nSrc = chSrc.read(bbSrc)) != -1) {
 890                 int nDst = chDst.read(bbDst);
 891                 if (nSrc != nDst) {
 892                     System.out.printf(&quot;checking &lt;%s&gt; vs &lt;%s&gt;...%n&quot;,
 893                                       src.toString(), dst.toString());
 894                     throw new RuntimeException(&quot;CHECK FAILED!&quot;);
 895                 }
 896                 while (--nSrc &gt;= 0) {
 897                     if (bbSrc.get(nSrc) != bbDst.get(nSrc)) {
 898                         System.out.printf(&quot;checking &lt;%s&gt; vs &lt;%s&gt;...%n&quot;,
 899                                           src.toString(), dst.toString());
 900                         throw new RuntimeException(&quot;CHECK FAILED!&quot;);
 901                     }
 902                     nSrc--;
 903                 }
 904                 bbSrc.flip();
 905                 bbDst.flip();
 906             }
 907 
 908             // Check if source read position is at the end
 909             if (chSrc.position() != chSrc.size()) {
 910                 System.out.printf(&quot;src[%s]: size=%d, position=%d%n&quot;,
 911                                   chSrc.toString(), chSrc.size(), chSrc.position());
 912                 throw new RuntimeException(&quot;CHECK FAILED!&quot;);
 913             }
 914 
 915             // Check if destination read position is at the end
 916             if (chDst.position() != chDst.size()) {
 917                 System.out.printf(&quot;dst[%s]: size=%d, position=%d%n&quot;,
 918                                   chDst.toString(), chDst.size(), chDst.position());
 919                 throw new RuntimeException(&quot;CHECK FAILED!&quot;);
 920             }
 921 
 922             // Check position(x) + read() at the specific pos/len
 923             for (int i = 0; i &lt; 10; i++) {
 924                 int pos = rdm.nextInt((int)chSrc.size());
 925                 int limit = rdm.nextInt(1024);
 926                 if (chSrc.position(pos).position() != chDst.position(pos).position()) {
 927                     System.out.printf(&quot;dst/src.position(pos failed%n&quot;);
 928                 }
 929                 bbSrc.clear().limit(limit);
 930                 bbDst.clear().limit(limit);
 931                 if (chSrc.read(bbSrc) != chDst.read(bbDst) ||
 932                     !bbSrc.flip().equals(bbDst.flip())) {
 933                     System.out.printf(&quot;dst/src.read() failed%n&quot;);
 934                 }
 935             }
 936         } catch (IOException x) {
 937             x.printStackTrace();
 938         }
 939     }
 940 
 941     private static void fchCopy(Path src, Path dst) throws IOException
 942     {
 943         Set&lt;OpenOption&gt; read = new HashSet&lt;&gt;();
 944         read.add(READ);
 945         Set&lt;OpenOption&gt; openwrite = new HashSet&lt;&gt;();
 946         openwrite.add(CREATE_NEW);
 947         openwrite.add(WRITE);
 948 
 949         try (FileChannel srcFc = src.getFileSystem()
 950                                     .provider()
 951                                     .newFileChannel(src, read);
 952              FileChannel dstFc = dst.getFileSystem()
 953                                     .provider()
 954                                     .newFileChannel(dst, openwrite))
 955         {
 956             ByteBuffer bb = ByteBuffer.allocate(8192);
 957             while (srcFc.read(bb) &gt;= 0) {
 958                 bb.flip();
 959                 dstFc.write(bb);
 960                 bb.clear();
 961             }
 962         }
 963     }
 964 
 965     private static void chCopy(Path src, Path dst) throws IOException
 966     {
 967         Set&lt;OpenOption&gt; read = new HashSet&lt;&gt;();
 968         read.add(READ);
 969         Set&lt;OpenOption&gt; openwrite = new HashSet&lt;&gt;();
 970         openwrite.add(CREATE_NEW);
 971         openwrite.add(WRITE);
 972 
 973         try (SeekableByteChannel srcCh = Files.newByteChannel(src, read);
 974              SeekableByteChannel dstCh = Files.newByteChannel(dst, openwrite))
 975         {
 976 
 977             ByteBuffer bb = ByteBuffer.allocate(8192);
 978             while (srcCh.read(bb) &gt;= 0) {
 979                 bb.flip();
 980                 dstCh.write(bb);
 981                 bb.clear();
 982             }
 983 
 984             // Check if source read position is at the end
 985             if (srcCh.position() != srcCh.size()) {
 986                 System.out.printf(&quot;src[%s]: size=%d, position=%d%n&quot;,
 987                                   srcCh.toString(), srcCh.size(), srcCh.position());
 988                 throw new RuntimeException(&quot;CHECK FAILED!&quot;);
 989             }
 990 
 991             // Check if destination write position is at the end
 992             if (dstCh.position() != dstCh.size()) {
 993                 System.out.printf(&quot;dst[%s]: size=%d, position=%d%n&quot;,
 994                                   dstCh.toString(), dstCh.size(), dstCh.position());
 995                 throw new RuntimeException(&quot;CHECK FAILED!&quot;);
 996             }
 997         }
 998     }
 999 
1000     private static void streamCopy(Path src, Path dst) throws IOException
1001     {
1002         byte[] buf = new byte[8192];
1003         try (InputStream isSrc = Files.newInputStream(src);
1004              OutputStream osDst = Files.newOutputStream(dst))
1005         {
1006             int n = 0;
1007             while ((n = isSrc.read(buf)) != -1) {
1008                 osDst.write(buf, 0, n);
1009             }
1010         }
1011     }
1012 
1013     static void channel(FileSystem fs, Path path)
1014         throws Exception
1015     {
1016         System.out.println(&quot;test ByteChannel...&quot;);
1017         Set&lt;OpenOption&gt; read = new HashSet&lt;&gt;();
1018         read.add(READ);
1019         int n = 0;
1020         ByteBuffer bb = null;
1021         ByteBuffer bb2 = null;
1022         int N = 120;
1023 
1024         try (SeekableByteChannel sbc = Files.newByteChannel(path)) {
1025             System.out.printf(&quot;   sbc[0]: pos=%d, size=%d%n&quot;, sbc.position(), sbc.size());
1026             if (sbc.position() != 0) {
1027                 throw new RuntimeException(&quot;CHECK FAILED!&quot;);
1028             }
1029 
1030             bb = ByteBuffer.allocate((int)sbc.size());
1031             n = sbc.read(bb);
1032             System.out.printf(&quot;   sbc[1]: read=%d, pos=%d, size=%d%n&quot;,
1033                               n, sbc.position(), sbc.size());
1034             if (sbc.position() != sbc.size()) {
1035                 throw new RuntimeException(&quot;CHECK FAILED!&quot;);
1036             }
1037             bb2 = ByteBuffer.allocate((int)sbc.size());
1038         }
1039 
1040         // sbc.position(pos) is not supported in current version
1041         // try the FileChannel
1042         try (SeekableByteChannel sbc = fs.provider().newFileChannel(path, read)) {
1043             sbc.position(N);
1044             System.out.printf(&quot;   sbc[2]: pos=%d, size=%d%n&quot;,
1045                               sbc.position(), sbc.size());
1046             if (sbc.position() != N) {
1047                 throw new RuntimeException(&quot;CHECK FAILED!&quot;);
1048             }
1049             bb2.limit(100);
1050             n = sbc.read(bb2);
1051             System.out.printf(&quot;   sbc[3]: read=%d, pos=%d, size=%d%n&quot;,
1052                               n, sbc.position(), sbc.size());
1053             if (n &lt; 0 || sbc.position() != (N + n)) {
1054                 throw new RuntimeException(&quot;CHECK FAILED!&quot;);
1055             }
1056             System.out.printf(&quot;   sbc[4]: bb[%d]=%d, bb1[0]=%d%n&quot;,
1057                               N, bb.get(N) &amp; 0xff, bb2.get(0) &amp; 0xff);
1058         }
1059     }
1060 
1061     // create parents if does not exist
1062     static Path getPathWithParents(FileSystem fs, String name)
1063         throws Exception
1064     {
1065         Path path = fs.getPath(name);
1066         Path parent = path.getParent();
1067         if (parent != null &amp;&amp; Files.notExists(parent))
1068             mkdirs(parent);
1069         return path;
1070     }
1071 }
    </pre>
  </body>
</html>
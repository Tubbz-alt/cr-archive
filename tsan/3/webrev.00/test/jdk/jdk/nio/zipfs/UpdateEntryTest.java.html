<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New test/jdk/jdk/nio/zipfs/UpdateEntryTest.java</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 import org.testng.annotations.Test;
 26 
 27 import java.io.IOException;
 28 import java.io.InputStream;
 29 import java.io.OutputStream;
 30 import java.nio.charset.StandardCharsets;
 31 import java.nio.file.FileSystem;
 32 import java.nio.file.FileSystems;
 33 import java.nio.file.Files;
 34 import java.nio.file.Path;
 35 import java.util.Arrays;
 36 import java.util.Map;
 37 import java.util.spi.ToolProvider;
 38 import java.util.zip.CRC32;
 39 import java.util.zip.ZipEntry;
 40 import java.util.zip.ZipFile;
 41 import java.util.zip.ZipOutputStream;
 42 
 43 import static org.testng.Assert.*;
 44 
 45 /**
 46  * @test
 47  * @bug 8229887
 48  * @summary Validate ZIP FileSystem can replace existing STORED and DEFLATED entries
 49  * @modules jdk.zipfs
 50  * @run testng UpdateEntryTest
 51  */
 52 @Test
 53 public class UpdateEntryTest {
 54 
 55     private static final Path HERE = Path.of(&quot;.&quot;);
 56 
 57     // Use the ToolProvider interface for accessing the jar tool
 58     private static final ToolProvider JAR_TOOL = ToolProvider.findFirst(&quot;jar&quot;)
 59             .orElseThrow(() -&gt; new RuntimeException(&quot;jar tool not found&quot;)
 60             );
 61 
 62     /**
 63      * Represents an entry in a ZIP file. An entry encapsulates a name, a
 64      * compression method, and its contents/data.
 65      */
 66     static class Entry {
 67         private final String name;
 68         private final int method;
 69         private final byte[] bytes;
 70 
 71         Entry(String name, int method, String contents) {
 72             this.name = name;
 73             this.method = method;
 74             this.bytes = contents.getBytes(StandardCharsets.UTF_8);
 75         }
 76 
 77         static Entry of(String name, int method, String contents) {
 78             return new Entry(name, method, contents);
 79         }
 80 
 81         /**
 82          * Returns a new Entry with the same name and compression method as this
 83          * Entry but with the given content.
 84          */
 85         Entry content(String contents) {
 86             return new Entry(name, method, contents);
 87         }
 88 
 89         /**
 90          * Writes this entry to the given ZIP output stream.
 91          */
 92         ZipEntry put(ZipOutputStream zos) throws IOException {
 93             ZipEntry e = new ZipEntry(name);
 94             e.setMethod(method);
 95             e.setTime(System.currentTimeMillis());
 96             if (method == ZipEntry.STORED) {
 97                 var crc = new CRC32();
 98                 crc.update(bytes);
 99                 e.setCrc(crc.getValue());
100                 e.setSize(bytes.length);
101             }
102             zos.putNextEntry(e);
103             zos.write(bytes);
104             return e;
105         }
106     }
107 
108     /**
109      * Validate that you can replace an existing entry in a JAR file that
110      * was added with the STORED(no-compression) option
111      */
112     public void testReplaceStoredEntry() throws IOException {
113         String jarFileName = &quot;updateStoredEntry.jar&quot;;
114         String storedFileName = &quot;storedFile.txt&quot;;
115         String replacedValue = &quot;bar&quot;;
116         Path zipFile = Path.of(jarFileName);
117 
118         // Create JAR file with a STORED(non-compressed) entry
119         Files.writeString(Path.of(storedFileName), &quot;foobar&quot;);
120         JAR_TOOL.run(System.out, System.err,
121                 &quot;cM0vf&quot;, jarFileName, storedFileName);
122 
123         // Replace the STORED entry using the default(DEFLATED) compression
124         // method.
125         try (FileSystem fs = FileSystems.newFileSystem(zipFile)) {
126             Files.writeString(fs.getPath(storedFileName), replacedValue);
127         }
128         Entry e1 = Entry.of(storedFileName, ZipEntry.DEFLATED, replacedValue);
129         verify(zipFile, e1);
130     }
131 
132     /**
133      * Test updating an entry that is STORED (not compressed)
134      */
135     public void test1() throws IOException {
136         Entry e1 = Entry.of(&quot;foo&quot;, ZipEntry.STORED, &quot;hello&quot;);
137         Entry e2 = Entry.of(&quot;bar&quot;, ZipEntry.STORED, &quot;world&quot;);
138         test(e1, e2);
139     }
140 
141     /**
142      * Test updating an entry that is DEFLATED (compressed)
143      */
144     public void test2() throws IOException {
145         Entry e1 = Entry.of(&quot;foo&quot;, ZipEntry.DEFLATED, &quot;hello&quot;);
146         Entry e2 = Entry.of(&quot;bar&quot;, ZipEntry.STORED, &quot;world&quot;);
147         test(e1, e2);
148     }
149 
150     private void test(Entry e1, Entry e2) throws IOException {
151         Path zipfile = Files.createTempFile(HERE, &quot;test&quot;, &quot;zip&quot;);
152 
153         // create zip file
154         try (OutputStream out = Files.newOutputStream(zipfile);
155              ZipOutputStream zos = new ZipOutputStream(out)) {
156             e1.put(zos);
157             e2.put(zos);
158         }
159 
160         verify(zipfile, e1, e2);
161 
162         String newContents = &quot;hi&quot;;
163 
164         // Set the required compression method
165         Map&lt;String, Boolean&gt; map = Map.of(&quot;noCompression&quot;,
166                 e1.method != ZipEntry.DEFLATED);
167 
168         // replace contents of e1
169         try (FileSystem fs = FileSystems.newFileSystem(zipfile, map)) {
170             Path foo = fs.getPath(e1.name);
171             Files.writeString(foo, newContents);
172         }
173 
174         verify(zipfile, e1.content(newContents), e2);
175     }
176 
177 
178     /**
179      * Verify that the given path is a zip files containing exactly the
180      * given entries.
181      */
182     private static void verify(Path zipfile, Entry... entries) throws IOException {
183         // check entries with zip API
184         try (ZipFile zf = new ZipFile(zipfile.toFile())) {
185             // check entry count
186             assertTrue(zf.size() == entries.length);
187 
188             // check compression method and content of each entry
189             for (Entry e : entries) {
190                 ZipEntry ze = zf.getEntry(e.name);
191                 assertTrue(ze != null);
192                 assertTrue(ze.getMethod() == e.method);
193                 try (InputStream in = zf.getInputStream(ze)) {
194                     byte[] bytes = in.readAllBytes();
195                     assertTrue(Arrays.equals(bytes, e.bytes));
196                 }
197             }
198         }
199 
200         // check entries with FileSystem API
201         try (FileSystem fs = FileSystems.newFileSystem(zipfile)) {
202             // check entry count
203             Path top = fs.getPath(&quot;/&quot;);
204             long count = Files.find(top, Integer.MAX_VALUE,
205                     (path, attrs) -&gt; attrs.isRegularFile()).count();
206             assertTrue(count == entries.length);
207 
208             // check content of each entry
209             for (Entry e : entries) {
210                 Path file = fs.getPath(e.name);
211                 byte[] bytes = Files.readAllBytes(file);
212                 assertTrue(Arrays.equals(bytes, e.bytes));
213             }
214         }
215     }
216 }
    </pre>
  </body>
</html>
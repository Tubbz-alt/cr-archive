<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old test/jdk/jdk/nio/zipfs/MultiReleaseJarTest.java</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2015, 2018, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 /*
 25  * @test
 26  * @bug 8144355 8144062 8176709 8194070 8193802
 27  * @summary Test aliasing additions to ZipFileSystem for multi-release jar files
 28  * @library /lib/testlibrary/java/util/jar
 29  * @modules jdk.compiler
 30  *          jdk.jartool
 31  *          jdk.zipfs
 32  * @build Compiler JarBuilder CreateMultiReleaseTestJars
 33  * @run testng MultiReleaseJarTest
 34  */
 35 
 36 import java.io.IOException;
 37 import java.lang.invoke.MethodHandle;
 38 import java.lang.invoke.MethodHandles;
 39 import java.lang.invoke.MethodType;
 40 import java.lang.Runtime.Version;
 41 import java.net.URI;
 42 import java.nio.file.*;
 43 import java.util.HashMap;
 44 import java.util.Map;
 45 import java.util.concurrent.atomic.AtomicInteger;
 46 
 47 import org.testng.Assert;
 48 import org.testng.annotations.*;
 49 
 50 public class MultiReleaseJarTest {
 51     final private int MAJOR_VERSION = Runtime.version().major();
 52 
 53     final private String userdir = System.getProperty(&quot;user.dir&quot;,&quot;.&quot;);
 54     final private CreateMultiReleaseTestJars creator =  new CreateMultiReleaseTestJars();
 55     final private Map&lt;String,String&gt; stringEnv = new HashMap&lt;&gt;();
 56     final private Map&lt;String,Integer&gt; integerEnv = new HashMap&lt;&gt;();
 57     final private Map&lt;String,Version&gt; versionEnv = new HashMap&lt;&gt;();
 58     final private String className = &quot;version.Version&quot;;
 59     final private MethodType mt = MethodType.methodType(int.class);
 60 
 61     private String entryName;
 62     private URI uvuri;
 63     private URI mruri;
 64     private URI smruri;
 65 
 66     @BeforeClass
 67     public void initialize() throws Exception {
 68         creator.compileEntries();
 69         creator.buildUnversionedJar();
 70         creator.buildMultiReleaseJar();
 71         creator.buildShortMultiReleaseJar();
 72         String ssp = Paths.get(userdir, &quot;unversioned.jar&quot;).toUri().toString();
 73         uvuri = new URI(&quot;jar&quot;, ssp , null);
 74         ssp = Paths.get(userdir, &quot;multi-release.jar&quot;).toUri().toString();
 75         mruri = new URI(&quot;jar&quot;, ssp, null);
 76         ssp = Paths.get(userdir, &quot;short-multi-release.jar&quot;).toUri().toString();
 77         smruri = new URI(&quot;jar&quot;, ssp, null);
 78         entryName = className.replace(&#39;.&#39;, &#39;/&#39;) + &quot;.class&quot;;
 79     }
 80 
 81     public void close() throws IOException {
 82         Files.delete(Paths.get(userdir, &quot;unversioned.jar&quot;));
 83         Files.delete(Paths.get(userdir, &quot;multi-release.jar&quot;));
 84         Files.delete(Paths.get(userdir, &quot;short-multi-release.jar&quot;));
 85     }
 86 
 87     @DataProvider(name=&quot;strings&quot;)
 88     public Object[][] createStrings() {
 89         return new Object[][]{
 90                 {&quot;runtime&quot;, MAJOR_VERSION},
 91                 {&quot;-20&quot;, 8},
 92                 {&quot;0&quot;, 8},
 93                 {&quot;8&quot;, 8},
 94                 {&quot;9&quot;, 9},
 95                 {Integer.toString(MAJOR_VERSION), MAJOR_VERSION},
 96                 {Integer.toString(MAJOR_VERSION+1), MAJOR_VERSION},
 97                 {&quot;50&quot;, MAJOR_VERSION}
 98         };
 99     }
100 
101     @DataProvider(name=&quot;integers&quot;)
102     public Object[][] createIntegers() {
103         return new Object[][] {
104                 {new Integer(-5), 8},
105                 {new Integer(0), 8},
106                 {new Integer(8), 8},
107                 {new Integer(9), 9},
108                 {new Integer(MAJOR_VERSION), MAJOR_VERSION},
109                 {new Integer(MAJOR_VERSION + 1), MAJOR_VERSION},
110                 {new Integer(100), MAJOR_VERSION}
111         };
112     }
113 
114     @DataProvider(name=&quot;versions&quot;)
115     public Object[][] createVersions() {
116         return new Object[][] {
117                 {Version.parse(&quot;8&quot;),    8},
118                 {Version.parse(&quot;9&quot;),    9},
119                 {Version.parse(Integer.toString(MAJOR_VERSION)),  MAJOR_VERSION},
120                 {Version.parse(Integer.toString(MAJOR_VERSION) + 1),  MAJOR_VERSION},
121                 {Version.parse(&quot;100&quot;), MAJOR_VERSION}
122         };
123     }
124 
125     // Not the best test but all I can do since ZipFileSystem and JarFileSystem
126     // are not public, so I can&#39;t use (fs instanceof ...)
127     @Test
128     public void testNewFileSystem() throws Exception {
129         Map&lt;String,String&gt; env = new HashMap&lt;&gt;();
130         // no configuration, treat multi-release jar as unversioned
131         try (FileSystem fs = FileSystems.newFileSystem(mruri, env)) {
132             Assert.assertTrue(readAndCompare(fs, 8));
133         }
134         env.put(&quot;multi-release&quot;, &quot;runtime&quot;);
135         // a configuration and jar file is multi-release
136         try (FileSystem fs = FileSystems.newFileSystem(mruri, env)) {
137             Assert.assertTrue(readAndCompare(fs, MAJOR_VERSION));
138         }
139         // a configuration but jar file is unversioned
140         try (FileSystem fs = FileSystems.newFileSystem(uvuri, env)) {
141             Assert.assertTrue(readAndCompare(fs, 8));
142         }
143     }
144 
145     private boolean readAndCompare(FileSystem fs, int expected) throws IOException {
146         Path path = fs.getPath(&quot;version/Version.java&quot;);
147         String src = new String(Files.readAllBytes(path));
148         return src.contains(&quot;return &quot; + expected);
149     }
150 
151     @Test(dataProvider=&quot;strings&quot;)
152     public void testStrings(String value, int expected) throws Throwable {
153         stringEnv.put(&quot;multi-release&quot;, value);
154         runTest(stringEnv, expected);
155     }
156 
157     @Test(dataProvider=&quot;integers&quot;)
158     public void testIntegers(Integer value, int expected) throws Throwable {
159         integerEnv.put(&quot;multi-release&quot;, value);
160         runTest(integerEnv, expected);
161     }
162 
163     @Test(dataProvider=&quot;versions&quot;)
164     public void testVersions(Version value, int expected) throws Throwable {
165         versionEnv.put(&quot;multi-release&quot;, value);
166         runTest(versionEnv, expected);
167     }
168 
169     @Test
170     public void testShortJar() throws Throwable {
171         integerEnv.put(&quot;multi-release&quot;, Integer.valueOf(MAJOR_VERSION));
172         runTest(smruri, integerEnv, MAJOR_VERSION);
173         integerEnv.put(&quot;multi-release&quot;, Integer.valueOf(9));
174         runTest(smruri, integerEnv, 8);
175     }
176 
177     private void runTest(Map&lt;String,?&gt; env, int expected) throws Throwable {
178         runTest(mruri, env, expected);
179     }
180 
181     private void runTest(URI uri, Map&lt;String,?&gt; env, int expected) throws Throwable {
182         try (FileSystem fs = FileSystems.newFileSystem(uri, env)) {
183             Path version = fs.getPath(entryName);
184             byte [] bytes = Files.readAllBytes(version);
185             Class&lt;?&gt; vcls = (new ByteArrayClassLoader(fs)).defineClass(className, bytes);
186             MethodHandle mh = MethodHandles.lookup().findVirtual(vcls, &quot;getVersion&quot;, mt);
187             Assert.assertEquals((int)mh.invoke(vcls.newInstance()), expected);
188         }
189     }
190 
191     @Test
192     public void testIsMultiReleaseJar() throws Exception {
193         // Re-examine commented out tests as part of JDK-8176843
194         testCustomMultiReleaseValue(&quot;true&quot;, true);
195         testCustomMultiReleaseValue(&quot;true\r\nOther: value&quot;, true);
196         testCustomMultiReleaseValue(&quot;true\nOther: value&quot;, true);
197         //testCustomMultiReleaseValue(&quot;true\rOther: value&quot;, true);
198 
199         testCustomMultiReleaseValue(&quot;false&quot;, false);
200         testCustomMultiReleaseValue(&quot; true&quot;, false);
201         testCustomMultiReleaseValue(&quot;true &quot;, false);
202         //testCustomMultiReleaseValue(&quot;true\n &quot;, false);
203         //testCustomMultiReleaseValue(&quot;true\r &quot;, false);
204         //testCustomMultiReleaseValue(&quot;true\n true&quot;, false);
205         //testCustomMultiReleaseValue(&quot;true\r\n true&quot;, false);
206     }
207 
208     @Test
209     public void testMultiReleaseJarWithNonVersionDir() throws Exception {
210         String jfname = &quot;multi-release-non-ver.jar&quot;;
211         Path jfpath = Paths.get(jfname);
212         URI uri = new URI(&quot;jar&quot;, jfpath.toUri().toString() , null);
213         JarBuilder jb = new JarBuilder(jfname);
214         jb.addAttribute(&quot;Multi-Release&quot;, &quot;true&quot;);
215         jb.build();
216         Map&lt;String,String&gt; env = Map.of(&quot;multi-release&quot;, &quot;runtime&quot;);
217         try (FileSystem fs = FileSystems.newFileSystem(uri, env)) {
218             Assert.assertTrue(true);
219         }
220         Files.delete(jfpath);
221     }
222 
223     private static final AtomicInteger JAR_COUNT = new AtomicInteger(0);
224 
225     private void testCustomMultiReleaseValue(String value, boolean expected)
226             throws Exception {
227         String fileName = &quot;custom-mr&quot; + JAR_COUNT.incrementAndGet() + &quot;.jar&quot;;
228         creator.buildCustomMultiReleaseJar(fileName, value, Map.of(),
229                 /*addEntries*/true);
230 
231         Map&lt;String,String&gt; env = Map.of(&quot;multi-release&quot;, &quot;runtime&quot;);
232         Path filePath = Paths.get(userdir, fileName);
233         String ssp = filePath.toUri().toString();
234         URI customJar = new URI(&quot;jar&quot;, ssp , null);
235         try (FileSystem fs = FileSystems.newFileSystem(customJar, env)) {
236             if (expected) {
237                 Assert.assertTrue(readAndCompare(fs, MAJOR_VERSION));
238             } else {
239                 Assert.assertTrue(readAndCompare(fs, 8));
240             }
241         }
242         Files.delete(filePath);
243     }
244 
245     private static class ByteArrayClassLoader extends ClassLoader {
246         final private FileSystem fs;
247 
248         ByteArrayClassLoader(FileSystem fs) {
249             super(null);
250             this.fs = fs;
251         }
252 
253         @Override
254         public Class&lt;?&gt; loadClass(String name) throws ClassNotFoundException {
255             try {
256                 return super.loadClass(name);
257             } catch (ClassNotFoundException x) {}
258             Path cls = fs.getPath(name.replace(&#39;.&#39;, &#39;/&#39;) + &quot;.class&quot;);
259             try {
260                 byte[] bytes = Files.readAllBytes(cls);
261                 return defineClass(name, bytes);
262             } catch (IOException x) {
263                 throw new ClassNotFoundException(x.getMessage());
264             }
265         }
266 
267         public Class&lt;?&gt; defineClass(String name, byte[] bytes) throws ClassNotFoundException {
268             if (bytes == null) throw new ClassNotFoundException(&quot;No bytes for &quot; + name);
269             return defineClass(name, bytes, 0, bytes.length);
270         }
271     }
272 }
    </pre>
  </body>
</html>
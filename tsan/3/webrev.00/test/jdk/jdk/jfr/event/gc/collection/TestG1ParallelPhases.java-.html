<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old test/jdk/jdk/jfr/event/gc/collection/TestG1ParallelPhases.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2018, 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package jdk.jfr.event.gc.collection;
 27 
 28 import static java.lang.System.gc;
 29 import static java.lang.Thread.sleep;
 30 import static java.util.Set.of;
 31 import static java.util.stream.Collectors.joining;
 32 import static java.util.stream.Collectors.toList;
 33 import static java.util.stream.Collectors.toSet;
 34 import static java.util.stream.IntStream.range;
 35 import static jdk.jfr.event.gc.collection.Provoker.provokeMixedGC;
 36 import static jdk.test.lib.Asserts.assertEquals;
 37 import static jdk.test.lib.Asserts.assertTrue;
 38 import static jdk.test.lib.jfr.Events.fromRecording;
 39 import static sun.hotspot.WhiteBox.getWhiteBox;
 40 
 41 import java.io.IOException;
 42 import java.lang.ref.WeakReference;
 43 import java.math.BigDecimal;
 44 import java.util.ArrayList;
 45 import java.util.Collection;
 46 import java.util.List;
 47 import java.util.Set;
 48 
 49 import jdk.jfr.Recording;
 50 import jdk.test.lib.Asserts;
 51 import jdk.test.lib.jfr.EventNames;
 52 import sun.hotspot.WhiteBox;
 53 
 54 /**
 55  * @test
 56  * @key jfr
 57  * @requires vm.hasJFR
 58  * @requires vm.gc == &quot;G1&quot; | vm.gc == null
 59  * @library /test/lib /test/jdk
 60  * @build sun.hotspot.WhiteBox
 61  * @run main ClassFileInstaller sun.hotspot.WhiteBox
 62  * @run main/othervm -XX:+UnlockExperimentalVMOptions -XX:MaxTenuringThreshold=1 -Xms20M -Xmx20M
 63  *      -XX:G1MixedGCLiveThresholdPercent=100 -XX:G1HeapWastePercent=0 -XX:G1HeapRegionSize=1m
 64  *      -XX:+UseG1GC -XX:+UseStringDeduplication
 65  *      -Xbootclasspath/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI
 66  *      jdk.jfr.event.gc.collection.TestG1ParallelPhases
 67  */
 68 
 69 public class TestG1ParallelPhases {
 70     public static List&lt;WeakReference&lt;byte[]&gt;&gt; weakRefs;
 71 
 72     public static void main(String[] args) throws IOException {
 73         Recording recording = new Recording();
 74         recording.enable(EventNames.GCPhaseParallel);
 75         recording.start();
 76 
 77         // create more weak garbage than can fit in this heap (-Xmx20m), will force collection of weak references
 78         weakRefs = range(1, 100)
 79             .mapToObj(n -&gt; new WeakReference&lt;&gt;(new byte[1_000_000]))
 80             .collect(toList()); // force evaluation of lazy stream (all weak refs must be created)
 81 
 82         final var MEG = 1024 * 1024;
 83         provokeMixedGC(1 * MEG);
 84         recording.stop();
 85 
 86         Set&lt;String&gt; usedPhases = fromRecording(recording).stream()
 87             .map(e -&gt; e.getValue(&quot;name&quot;).toString())
 88             .collect(toSet());
 89 
 90         Set&lt;String&gt; allPhases = of(
 91             &quot;ExtRootScan&quot;,
 92             &quot;ThreadRoots&quot;,
 93             &quot;UniverseRoots&quot;,
 94             &quot;JNIRoots&quot;,
 95             &quot;ObjectSynchronizerRoots&quot;,
 96             &quot;ManagementRoots&quot;,
 97             &quot;SystemDictionaryRoots&quot;,
 98             &quot;CLDGRoots&quot;,
 99             &quot;JVMTIRoots&quot;,
100             &quot;CMRefRoots&quot;,
101             &quot;WaitForStrongCLD&quot;,
102             &quot;WeakCLDRoots&quot;,
103             &quot;SATBFiltering&quot;,
104             &quot;UpdateRS&quot;,
105             &quot;ScanHCC&quot;,
106             &quot;ScanRS&quot;,
107             &quot;CodeRoots&quot;,
108             &quot;ObjCopy&quot;,
109             &quot;Termination&quot;,
110             &quot;StringDedupQueueFixup&quot;,
111             &quot;StringDedupTableFixup&quot;,
112             &quot;RedirtyCards&quot;,
113        //     &quot;PreserveCMReferents&quot;,
114             &quot;NonYoungFreeCSet&quot;,
115             &quot;YoungFreeCSet&quot;
116         );
117 
118         assertTrue(usedPhases.equals(allPhases), &quot;Compare events expected and received&quot;
119             + &quot;, Not found phases: &quot; + allPhases.stream().filter(p -&gt; !usedPhases.contains(p)).collect(joining(&quot;, &quot;))
120             + &quot;, Not expected phases: &quot; + usedPhases.stream().filter(p -&gt; !allPhases.contains(p)).collect(joining(&quot;, &quot;)));
121     }
122 }
123 
124 /**
125  * Utility class to guarantee a mixed GC. The class allocates several arrays and
126  * promotes them to the oldgen. After that it tries to provoke mixed GC by
127  * allocating new objects.
128  */
129 class Provoker {
130     private static void allocateOldObjects(
131             List&lt;byte[]&gt; liveOldObjects,
132             int g1HeapRegionSize,
133             int arraySize) {
134 
135         var toUnreachable = new ArrayList&lt;byte[]&gt;();
136 
137         // Allocates buffer and promotes it to the old gen. Mix live and dead old objects.
138         // allocate about two regions of old memory. At least one full old region will guarantee
139         // mixed collection in the future
140         range(0, g1HeapRegionSize/arraySize).forEach(n -&gt; {
141             liveOldObjects.add(new byte[arraySize]);
142             toUnreachable.add(new byte[arraySize]);
143         });
144 
145         // Do two young collections, MaxTenuringThreshold=1 will force promotion.
146         getWhiteBox().youngGC();
147         getWhiteBox().youngGC();
148 
149         // Check it is promoted &amp; keep alive
150         Asserts.assertTrue(getWhiteBox().isObjectInOldGen(liveOldObjects), &quot;List of the objects is suppose to be in OldGen&quot;);
151         Asserts.assertTrue(getWhiteBox().isObjectInOldGen(toUnreachable), &quot;List of the objects is suppose to be in OldGen&quot;);
152     }
153 
154     private static void waitTillCMCFinished(int sleepTime) {
155         while (getWhiteBox().g1InConcurrentMark()) {
156               try {sleep(sleepTime);} catch (Exception e) {}
157         }
158     }
159 
160     /**
161     * The necessary condition for guaranteed mixed GC is running in VM with the following flags:
162     * -XX:+UnlockExperimentalVMOptions -XX:MaxTenuringThreshold=1 -Xms{HEAP_SIZE}M
163     * -Xmx{HEAP_SIZE}M -XX:G1MixedGCLiveThresholdPercent=100 -XX:G1HeapWastePercent=0
164     * -XX:G1HeapRegionSize={REGION_SIZE}m
165     *
166     * @param provokeSize The size to allocate to provoke the start of a mixed gc (half heap size?)
167     * @param g1HeapRegionSize The size of your regions in bytes
168     */
169     public static void provokeMixedGC(int g1HeapRegionSize) {
170         final var arraySize = 20_000;
171         var liveOldObjects = new ArrayList&lt;byte[]&gt;();
172         allocateOldObjects(liveOldObjects, g1HeapRegionSize, arraySize);
173         waitTillCMCFinished(10);
174         getWhiteBox().g1StartConcMarkCycle();
175         waitTillCMCFinished(10);
176         getWhiteBox().youngGC();
177         getWhiteBox().youngGC();
178 
179         // check that liveOldObjects still alive
180         assertTrue(getWhiteBox().isObjectInOldGen(liveOldObjects), &quot;List of the objects is suppose to be in OldGen&quot;);
181     }
182 }
    </pre>
  </body>
</html>
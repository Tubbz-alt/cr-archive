<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames test/jdk/jdk/jfr/event/gc/collection/GCEventAll.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
<a name="1" id="anc1"></a><span class="line-modified">  2  * Copyright (c) 2013, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package jdk.jfr.event.gc.collection;
 27 
 28 import java.lang.management.ManagementFactory;
 29 import java.time.Duration;
 30 import java.time.Instant;
 31 import java.util.ArrayList;
 32 import java.util.Arrays;
 33 import java.util.HashSet;
 34 import java.util.List;
 35 import java.util.Random;
 36 import java.util.Set;
 37 import java.util.stream.Collectors;
 38 
 39 import jdk.jfr.EventType;
 40 import jdk.jfr.FlightRecorder;
 41 import jdk.jfr.Recording;
 42 import jdk.jfr.consumer.RecordedEvent;
 43 import jdk.test.lib.Asserts;
 44 import jdk.test.lib.jfr.EventNames;
 45 import jdk.test.lib.jfr.Events;
 46 import jdk.test.lib.jfr.GCHelper;
 47 
 48 /**
 49  * Tests for event garbage_collection.
 50  * The test function is called from TestGCEvent*.java, with different worker threads.
 51  * Groups all events belonging to the same garbage collection (the same gcId).
 52  * The group of events belonging to the same GC is called a batch.
 53  *
 54  * This class contains the verifications done and the worker threads used to generate GCs.
 55  * The helper logic are in class GCHelper.
 56  *
 57  * Summary of verifications:
 58  *   All gcIds in garbage_collection event are unique.
 59  *
 60  *   All events in batch has the same gcId.
 61  *
 62  *   Number of garbage_collection events == GarbageCollectionMXBean.getCollectionCount()
 63  *
 64  *   garbage_collection.sum_pause_time approximately equals GarbageCollectionMXBean.getCollectionTime()
 65  *
 66  *   Batch contains expected events depending on garbage_collection.name
 67  *
 68  *   garbage_collection_start.timestamp == garbage_collection.startTime.
 69  *
 70  *   garbage_collection.timestamp &gt;= timestamp for all other events in batch.
 71  *
 72  *   The start_garbage_collection and garbage_collection events must be synchronized.
 73  *     This means that there may be multiple start_garbage_collection before a garbage_collection,
 74  *     but garbage_collection.gcId must be equal to latest start_garbage_collection.gcId.
 75  *
 76  *   start_garbage_collection must be the first event in the batch,
 77  *     that means no event with same gcId before garbage_collection_start event.
 78  *
 79  *   garbage_collection.name matches what is expected by the collectors specified in initial_configuration.
 80  *
 81  *   Duration for event &quot;vm/gc/phases/pause&quot; &gt;= 1. Duration for phase level events &gt;= 0.
 82  *
 83  *
 84  */
 85 public class GCEventAll {
 86     private String youngCollector = null;
 87     private String oldCollector = null;
 88 
 89     /**
 90      *  Trigger GC events by generating garbage and calling System.gc() concurrently.
 91      */
 92     public static void doTest() throws Throwable {
 93         // Trigger GC events by generating garbage and calling System.gc() concurrently.
 94         Thread[] workerThreads = new Thread[] {
 95                 new Thread(GCEventAll.GarbageRunner.create(10)),
 96                 new Thread(GCEventAll.SystemGcWaitRunner.create(10, 2, 1000))};
 97         GCEventAll test = new GCEventAll();
 98         test.doSingleTest(workerThreads);
 99     }
100 
101     /**
102      * Runs the test once with given worker threads.
103      * @param workerThreads Threads that generates GCs.
104      * @param gcIds Set of all used gcIds
105      * @throws Exception
106      */
107     private void doSingleTest(Thread[] workerThreads) throws Throwable {
108         Recording recording = new Recording();
109         enableAllGcEvents(recording);
110 
111         // Start with a full GC to minimize risk of getting extra GC between
112         // getBeanCollectionCount() and recording.start().
113         doSystemGc();
114         GCHelper.CollectionSummary startBeanCount = GCHelper.CollectionSummary.createFromMxBeans();
115         recording.start();
116 
117         for (Thread t : workerThreads) {
118             t.start();
119         }
120         for (Thread t : workerThreads) {
121             t.join();
122         }
123 
124         // End with a full GC to minimize risk of getting extra GC between
125         // recording.stop and getBeanCollectionCount().
126         doSystemGc();
127         // Add an extra System.gc() to make sure we get at least one full garbage_collection batch at
<a name="2" id="anc2"></a><span class="line-modified">128         // the end of the test. This extra System.gc() is only necessary when using &quot;+ExplicitGCInvokesConcurrent&quot;.</span>
129         doSystemGc();
130 
131         recording.stop();
132         GCHelper.CollectionSummary deltaBeanCount = GCHelper.CollectionSummary.createFromMxBeans();
133         deltaBeanCount = deltaBeanCount.calcDelta(startBeanCount);
134 
135         List&lt;RecordedEvent&gt; events = Events.fromRecording(recording).stream()
136             .filter(evt -&gt; EventNames.isGcEvent(evt.getEventType()))
137             .collect(Collectors.toList());
138         RecordedEvent configEvent = GCHelper.getConfigEvent(events);
139         youngCollector = Events.assertField(configEvent, &quot;youngCollector&quot;).notEmpty().getValue();
140         oldCollector = Events.assertField(configEvent, &quot;oldCollector&quot;).notEmpty().getValue();
141         verify(events, deltaBeanCount);
142     }
143 
144     private void enableAllGcEvents(Recording recording) {
145         FlightRecorder flightrecorder = FlightRecorder.getFlightRecorder();
146         for (EventType et : flightrecorder.getEventTypes()) {
147             if (EventNames.isGcEvent(et)) {
148                 recording.enable(et.getName());
149                 System.out.println(&quot;Enabled GC event: &quot; + et.getName());
150             }
151         }
152         System.out.println(&quot;All GC events enabled&quot;);
153     }
154 
155     private static synchronized void doSystemGc() {
156         System.gc();
157     }
158 
159     /**
160      * Does all verifications of the received events.
161      *
162      * @param events All flight recorder events.
163      * @param beanCounts Number of collections and sum pause time reported by GarbageCollectionMXBeans.
164      * @param gcIds All used gcIds. Must be unique.
165      * @throws Exception
166      */
167     private void verify(List&lt;RecordedEvent&gt; events, GCHelper.CollectionSummary beanCounts) throws Throwable {
168         List&lt;GCHelper.GcBatch&gt; gcBatches = null;
169         GCHelper.CollectionSummary eventCounts = null;
170 
171         // For some GC configurations, the JFR recording may have stopped before we received the last gc event.
172         try {
<a name="3" id="anc3"></a>
173             gcBatches = GCHelper.GcBatch.createFromEvents(events);
174             eventCounts = GCHelper.CollectionSummary.createFromEvents(gcBatches);
175 
176             verifyUniqueIds(gcBatches);
177             verifyCollectorNames(gcBatches);
178             verifyCollectionCause(gcBatches);
179             verifyCollectionCount(eventCounts, beanCounts);
180             verifyPhaseEvents(gcBatches);
181             verifySingleGcBatch(gcBatches);
182         } catch (Throwable t) {
183             log(events, gcBatches, eventCounts, beanCounts);
184             if (gcBatches != null) {
185                 for (GCHelper.GcBatch batch : gcBatches) {
186                     System.out.println(String.format(&quot;Batch:%n%s&quot;, batch.getLog()));
187                 }
188             }
189             throw t;
190         }
191     }
192 
<a name="4" id="anc4"></a>


































193     private boolean hasInputArgument(String arg) {
194         return ManagementFactory.getRuntimeMXBean().getInputArguments().contains(arg);
195     }
196 
197     private List&lt;RecordedEvent&gt; getEventsWithGcId(List&lt;RecordedEvent&gt; events, int gcId) {
198         List&lt;RecordedEvent&gt; batchEvents = new ArrayList&lt;&gt;();
199         for (RecordedEvent event : events) {
200             if (GCHelper.isGcEvent(event) &amp;&amp; GCHelper.getGcId(event) == gcId) {
201                 batchEvents.add(event);
202             }
203         }
204         return batchEvents;
205     }
206 
207     private boolean containsAnyPath(List&lt;RecordedEvent&gt; events, String[] paths) {
208         List&lt;String&gt; pathList = Arrays.asList(paths);
209         for (RecordedEvent event : events) {
210             if (pathList.contains(event.getEventType().getName())) {
211                 return true;
212             }
213         }
214         return false;
215     }
216 
217     private int getLastGcId(List&lt;RecordedEvent&gt; events) {
218         int lastGcId = -1;
219         for (RecordedEvent event : events) {
220             if (GCHelper.isGcEvent(event)) {
221                 int gcId = GCHelper.getGcId(event);
222                 if (gcId &gt; lastGcId) {
223                     lastGcId = gcId;
224                 }
225             }
226         }
227         Asserts.assertTrue(lastGcId != -1, &quot;No gcId found&quot;);
228         return lastGcId;
229     }
230 
231     /**
232      * Verifies collection count reported by flight recorder events against the values
233      * reported by GarbageCollectionMXBean.
234      * Number of collections should match exactly.
235      * Sum pause time are allowed some margin of error because of rounding errors in measurements.
236      */
237     private void verifyCollectionCount(GCHelper.CollectionSummary eventCounts, GCHelper.CollectionSummary beanCounts) {
238         verifyCollectionCount(youngCollector, eventCounts.collectionCountYoung, beanCounts.collectionCountYoung);
239         verifyCollectionCount(oldCollector, eventCounts.collectionCountOld, beanCounts.collectionCountOld);
240     }
241 
242     private void verifyCollectionCount(String collector, long eventCounts, long beanCounts) {
<a name="5" id="anc5"></a><span class="line-modified">243         if (GCHelper.gcG1Old.equals(oldCollector)) {</span>

244             // MXBean does not report old collections for G1Old, so we have nothing to compare with.
245             return;
246         }
247         // JFR events and GarbageCollectorMXBean events are not updated at the same time.
248         // This means that number of collections may diff.
249         // We allow a diff of +- 1 collection count.
250         long minCount = Math.max(0, beanCounts - 1);
251         long maxCount = beanCounts + 1;
252         Asserts.assertGreaterThanOrEqual(eventCounts, minCount, &quot;Too few event counts for collector &quot; + collector);
253         Asserts.assertLessThanOrEqual(eventCounts, maxCount, &quot;Too many event counts for collector &quot; + collector);
254     }
255 
256     /**
257      * Verifies that all events belonging to a single GC are ok.
258      * A GcBatch contains all flight recorder events that belong to a single GC.
259      */
260     private void verifySingleGcBatch(List&lt;GCHelper.GcBatch&gt; batches) {
261         for (GCHelper.GcBatch batch : batches) {
262             //System.out.println(&quot;batch:\r\n&quot; + batch.getLog());
263             try {
264                 RecordedEvent endEvent = batch.getEndEvent();
265                 Asserts.assertNotNull(endEvent, &quot;No end event in batch.&quot;);
266                 Asserts.assertNotNull(batch.getName(), &quot;No method name in end event.&quot;);
267                 long longestPause = Events.assertField(endEvent, &quot;longestPause&quot;).atLeast(0L).getValue();
268                 Events.assertField(endEvent, &quot;sumOfPauses&quot;).atLeast(longestPause).getValue();
269                 Instant batchStartTime = endEvent.getStartTime();
270                 Instant batchEndTime = endEvent.getEndTime();
271                 for (RecordedEvent event : batch.getEvents()) {
272                     if (event.getEventType().getName().contains(&quot;AllocationRequiringGC&quot;)) {
273                         // Unlike other events, these are sent *before* a GC.
274                         Asserts.assertLessThanOrEqual(event.getStartTime(), batchStartTime, &quot;Timestamp in event after start event, should be sent before GC start&quot;);
275                     } else {
276                         Asserts.assertGreaterThanOrEqual(event.getStartTime(), batchStartTime, &quot;startTime in event before batch start event, should be sent after GC start&quot;);
277                     }
278                     Asserts.assertLessThanOrEqual(event.getEndTime(), batchEndTime, &quot;endTime in event after batch end event, should be sent before GC end&quot;);
279                 }
280 
281                 // Verify that all required events has been received.
282                 String[] requiredEvents = GCHelper.requiredEvents.get(batch.getName());
283                 Asserts.assertNotNull(requiredEvents, &quot;No required events specified for &quot; + batch.getName());
284                 for (String requiredEvent : requiredEvents) {
285                     boolean b = batch.containsEvent(requiredEvent);
286                     Asserts.assertTrue(b, String.format(&quot;%s does not contain event %s&quot;, batch, requiredEvent));
287                 }
288 
289                 // Verify that we have exactly one heap_summary &quot;Before GC&quot; and one &quot;After GC&quot;.
290                 int countBeforeGc = 0;
291                 int countAfterGc = 0;
292                 for (RecordedEvent event : batch.getEvents()) {
293                     if (GCHelper.event_heap_summary.equals(event.getEventType().getName())) {
294                         String when = Events.assertField(event, &quot;when&quot;).notEmpty().getValue();
295                         if (&quot;Before GC&quot;.equals(when)) {
296                             countBeforeGc++;
297                         } else if (&quot;After GC&quot;.equals(when)) {
298                             countAfterGc++;
299                         } else {
300                             Asserts.fail(&quot;Unknown value for heap_summary.when: &#39;&quot; + when + &quot;&#39;&quot;);
301                         }
302                     }
303                 }
<a name="6" id="anc6"></a><span class="line-modified">304                 Asserts.assertEquals(1, countBeforeGc, &quot;Unexpected number of heap_summary.before_gc&quot;);</span>
<span class="line-modified">305                 Asserts.assertEquals(1, countAfterGc, &quot;Unexpected number of heap_summary.after_gc&quot;);</span>



306             } catch (Throwable e) {
307                 GCHelper.log(&quot;verifySingleGcBatch failed for gcEvent:&quot;);
308                 GCHelper.log(batch.getLog());
309                 throw e;
310             }
311         }
312     }
313 
314     private Set&lt;Integer&gt; verifyUniqueIds(List&lt;GCHelper.GcBatch&gt; batches) {
315         Set&lt;Integer&gt; gcIds = new HashSet&lt;&gt;();
316         for (GCHelper.GcBatch batch : batches) {
317             Integer gcId = new Integer(batch.getGcId());
318             Asserts.assertFalse(gcIds.contains(gcId), &quot;Duplicate gcId: &quot; + gcId);
319             gcIds.add(gcId);
320         }
321         return gcIds;
322     }
323 
324     private void verifyPhaseEvents(List&lt;GCHelper.GcBatch&gt; batches) {
325         for (GCHelper.GcBatch batch : batches) {
326             for(RecordedEvent event : batch.getEvents()) {
327                 if (event.getEventType().getName().contains(GCHelper.pauseLevelEvent)) {
328                     Instant batchStartTime = batch.getEndEvent().getStartTime();
329                     Asserts.assertGreaterThanOrEqual(
330                         event.getStartTime(), batchStartTime, &quot;Phase startTime &gt;= batch startTime. Event:&quot; + event);
331 
332                     // Duration for event &quot;vm/gc/phases/pause&quot; must be &gt;= 1. Other phase event durations must be &gt;= 0.
333                     Duration minDuration = Duration.ofNanos(GCHelper.event_phases_pause.equals(event.getEventType().getName()) ? 1 : 0);
334                     Duration duration = event.getDuration();
335                     Asserts.assertGreaterThanOrEqual(duration, minDuration, &quot;Wrong duration. Event:&quot; + event);
336                 }
337             }
338         }
339     }
340 
341     /**
342      * Verifies that the collector name in initial configuration matches the name in garbage configuration event.
343      * If the names are not equal, then we check if this is an expected collector override.
344      * For example, if old collector in initial config is &quot;G1Old&quot; we allow both event &quot;G1Old&quot; and &quot;SerialOld&quot;.
345      */
346     private void verifyCollectorNames(List&lt;GCHelper.GcBatch&gt; batches) {
347         for (GCHelper.GcBatch batch : batches) {
348             String name = batch.getName();
349             Asserts.assertNotNull(name, &quot;garbage_collection.name was null&quot;);
350             boolean isYoung = batch.isYoungCollection();
351             String expectedName = isYoung ? youngCollector : oldCollector;
352             if (!expectedName.equals(name)) {
353                 // Collector names not equal. Check if the collector has been overridden by an expected collector.
354                 String overrideKey = expectedName + &quot;.&quot; + name;
355                 boolean isOverride = GCHelper.collectorOverrides.contains(overrideKey);
356                 Asserts.assertTrue(isOverride, String.format(&quot;Unexpected event name(%s) for collectors(%s, %s)&quot;, name, youngCollector, oldCollector));
357             }
358         }
359     }
360 
361     /**
362      * Verifies field &quot;cause&quot; in garbage_collection event.
363      * Only check that at cause is not null and that at least 1 cause is &quot;System.gc()&quot;
364      * We might want to check more cause reasons later.
365      */
366     private void verifyCollectionCause(List&lt;GCHelper.GcBatch&gt; batches) {
367         int systemGcCount = 0;
368         for (GCHelper.GcBatch batch : batches) {
369             RecordedEvent endEvent = batch.getEndEvent();
370             String cause = Events.assertField(endEvent, &quot;cause&quot;).notEmpty().getValue();
371             // A System.GC() can be consolidated into a GCLocker GC
372             if (cause.equals(&quot;System.gc()&quot;) || cause.equals(&quot;GCLocker Initiated GC&quot;)) {
373                 systemGcCount++;
374             }
375             Asserts.assertNotNull(batch.getName(), &quot;garbage_collection.name was null&quot;);
376         }
377         final String msg = &quot;No event with cause=System.gc(), collectors(%s, %s)&quot;;
378         Asserts.assertTrue(systemGcCount &gt; 0, String.format(msg, youngCollector, oldCollector));
379     }
380 
381     private void log(List&lt;RecordedEvent&gt; events, List&lt;GCHelper.GcBatch&gt; batches,
382         GCHelper.CollectionSummary eventCounts, GCHelper.CollectionSummary beanCounts) {
383         GCHelper.log(&quot;EventCounts:&quot;);
384         if (eventCounts != null) {
385             GCHelper.log(eventCounts.toString());
386         }
387         GCHelper.log(&quot;BeanCounts:&quot;);
388         if (beanCounts != null) {
389             GCHelper.log(beanCounts.toString());
390         }
391     }
392 
393     /**
394      * Thread that does a number of System.gc().
395      */
396     public static class SystemGcRunner implements Runnable {
397         private final int totalCollections;
398 
399         public SystemGcRunner(int totalCollections) {
400             this.totalCollections = totalCollections;
401         }
402 
403         public static SystemGcRunner create(int totalCollections) {
404             return new SystemGcRunner(totalCollections);
405         }
406 
407         public void run() {
408             for (int i = 0; i &lt; totalCollections; i++) {
409                 GCEventAll.doSystemGc();
410             }
411         }
412     }
413 
414     /**
415      * Thread that creates garbage until a certain number of GCs has been run.
416      */
417     public static class GarbageRunner implements Runnable {
418         private final int totalCollections;
419         public byte[] dummyBuffer = null;
420 
421         public GarbageRunner(int totalCollections) {
422             this.totalCollections = totalCollections;
423         }
424 
425         public static GarbageRunner create(int totalCollections) {
426             return new GarbageRunner(totalCollections);
427         }
428 
429         public void run() {
430             long currCollections = GCHelper.CollectionSummary.createFromMxBeans().sum();
431             long endCollections = totalCollections + currCollections;
432             Random r = new Random(0);
433             while (true) {
434                 for (int i = 0; i &lt; 1000; i++) {
435                     dummyBuffer = new byte[r.nextInt(10000)];
436                 }
437                 if (GCHelper.CollectionSummary.createFromMxBeans().sum() &gt;= endCollections) {
438                     break;
439                 }
440             }
441         }
442     }
443 
444     /**
445      * Thread that runs System.gc() and then wait for a number of GCs or a maximum time.
446      */
447     public static class SystemGcWaitRunner implements Runnable {
448         private final int totalCollections;
449         private final int minWaitCollections;
450         private final long maxWaitMillis;
451 
452         public SystemGcWaitRunner(int totalCollections, int minWaitCollections, long maxWaitMillis) {
453             this.totalCollections = totalCollections;
454             this.minWaitCollections = minWaitCollections;
455             this.maxWaitMillis = maxWaitMillis;
456         }
457 
458         public static SystemGcWaitRunner create(int deltaCollections, int minWaitCollections, long maxWaitMillis) {
459             return new SystemGcWaitRunner(deltaCollections, minWaitCollections, maxWaitMillis);
460         }
461 
462         public void run() {
463             long currCount = GCHelper.CollectionSummary.createFromMxBeans().sum();
464             long endCount = totalCollections + currCount;
465             long nextSystemGcCount = currCount + minWaitCollections;
466             long now = System.currentTimeMillis();
467             long nextSystemGcMillis = now + maxWaitMillis;
468 
469             while (true) {
470                 if (currCount &gt;= nextSystemGcCount || System.currentTimeMillis() &gt; nextSystemGcMillis) {
471                     GCEventAll.doSystemGc();
472                     currCount = GCHelper.CollectionSummary.createFromMxBeans().sum();
473                     nextSystemGcCount = currCount + minWaitCollections;
474                 } else {
475                     try {
476                         Thread.sleep(20);
477                     } catch (InterruptedException e) {
478                         e.printStackTrace();
479                         break;
480                     }
481                 }
482                 currCount = GCHelper.CollectionSummary.createFromMxBeans().sum();
483                 if (currCount &gt;= endCount) {
484                     break;
485                 }
486             }
487         }
488     }
489 
490 }
<a name="7" id="anc7"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="7" type="hidden" />
</body>
</html>
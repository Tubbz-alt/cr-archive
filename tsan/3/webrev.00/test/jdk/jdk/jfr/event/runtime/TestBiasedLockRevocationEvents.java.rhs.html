<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames test/jdk/jdk/jfr/event/runtime/TestBiasedLockRevocationEvents.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
<a name="1" id="anc1"></a><span class="line-modified">  2  * Copyright (c) 2017, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package jdk.jfr.event.runtime;
 27 
 28 import jdk.jfr.Recording;
 29 import jdk.jfr.consumer.*;
 30 import jdk.test.lib.Asserts;
 31 import jdk.test.lib.dcmd.PidJcmdExecutor;
 32 import jdk.test.lib.jfr.EventNames;
 33 import jdk.test.lib.jfr.Events;
 34 import jdk.test.lib.process.OutputAnalyzer;
 35 
 36 import java.util.*;
 37 import java.util.concurrent.FutureTask;
 38 import java.util.stream.Collectors;
 39 
 40 /**
 41  * @test
 42  * @key jfr
 43  * @requires vm.hasJFR
 44  * @library /test/lib
 45  *
<a name="2" id="anc2"></a><span class="line-modified"> 46  * @run main/othervm -XX:+UseBiasedLocking jdk.jfr.event.runtime.TestBiasedLockRevocationEvents</span>
 47  */
 48 public class TestBiasedLockRevocationEvents {
 49 
 50     public static void main(String[] args) throws Throwable {
 51         testSingleRevocation();
 52         testBulkRevocation();
 53         testSelfRevocation();
 54         testExitedThreadRevocation();
 55         testBulkRevocationNoRebias();
 56         testRevocationSafepointIdCorrelation();
 57     }
 58 
 59     // Default value of BiasedLockingBulkRebiasThreshold is 20, and BiasedLockingBulkRevokeTreshold is 40.
 60     // Using a value that will hit the first threshold once, and the second one the next time.
 61     private static final int BULK_REVOKE_THRESHOLD = 25;
 62 
 63     static void touch(Object lock) {
 64         synchronized(lock) {
 65         }
 66     }
 67 
 68     static Thread triggerRevocation(int numRevokes, Class&lt;?&gt; lockClass) throws Throwable {
 69         Object[] locks = new Object[numRevokes];
 70         for (int i = 0; i &lt; locks.length; ++i) {
 71             locks[i] = lockClass.getDeclaredConstructor().newInstance();
 72             touch(locks[i]);
 73         }
 74 
 75         Thread biasBreaker = new Thread(&quot;BiasBreaker&quot;) {
 76             @Override
 77             public void run() {
 78                 for (Object lock : locks) {
 79                     touch(lock);
 80                 }
 81             }
 82         };
 83 
 84         biasBreaker.start();
 85         biasBreaker.join();
 86 
 87         return biasBreaker;
 88     }
 89 
 90     // Basic stack trace validation, checking the name of the leaf method
 91     static void validateStackTrace(RecordedStackTrace stackTrace, String leafMethodName) {
 92         List&lt;RecordedFrame&gt; frames = stackTrace.getFrames();
 93         Asserts.assertFalse(frames.isEmpty());
 94         String name = frames.get(0).getMethod().getName();
 95         Asserts.assertEquals(name, leafMethodName);
 96     }
 97 
 98     // Validates that the given stack trace refers to lock.touch(); in triggerRevocation
 99     static void validateStackTrace(RecordedStackTrace stackTrace) {
100         validateStackTrace(stackTrace, &quot;touch&quot;);
101     }
102 
103     // Retrieve all biased lock revocation events related to the provided lock class, sorted by start time
<a name="3" id="anc3"></a><span class="line-modified">104     static List&lt;RecordedEvent&gt; getRevocationEvents(Recording recording, String eventTypeName, String fieldName, Class&lt;?&gt; lockClass) throws Throwable {</span>
105         return Events.fromRecording(recording).stream()
<a name="4" id="anc4"></a><span class="line-added">106                 .filter(e -&gt; e.getEventType().getName().equals(eventTypeName))</span>
107                 .filter(e -&gt; ((RecordedClass)e.getValue(fieldName)).getName().equals(lockClass.getName()))
108                 .sorted(Comparator.comparing(RecordedEvent::getStartTime))
109                 .collect(Collectors.toList());
110     }
111 
112     static void testSingleRevocation() throws Throwable {
113         class MyLock {};
114 
115         Recording recording = new Recording();
116 
117         recording.enable(EventNames.BiasedLockRevocation);
118         recording.start();
119 
120         Thread biasBreaker = triggerRevocation(1, MyLock.class);
121 
122         recording.stop();
<a name="5" id="anc5"></a><span class="line-modified">123         List&lt;RecordedEvent&gt; events = getRevocationEvents(recording, EventNames.BiasedLockRevocation, &quot;lockClass&quot;, MyLock.class);</span>
124         Asserts.assertEQ(events.size(), 1);
125 
126         RecordedEvent event = events.get(0);
127         Events.assertEventThread(event, biasBreaker);
128         Events.assertEventThread(event, &quot;previousOwner&quot;, Thread.currentThread());
129 
130         RecordedClass lockClass = event.getValue(&quot;lockClass&quot;);
131         Asserts.assertEquals(lockClass.getName(), MyLock.class.getName());
132 
133         validateStackTrace(event.getStackTrace());
134     }
135 
136     static void testBulkRevocation() throws Throwable {
137         class MyLock {};
138 
139         Recording recording = new Recording();
140 
141         recording.enable(EventNames.BiasedLockClassRevocation);
142         recording.start();
143 
144         Thread biasBreaker = triggerRevocation(BULK_REVOKE_THRESHOLD, MyLock.class);
145 
146         recording.stop();
<a name="6" id="anc6"></a><span class="line-modified">147         List&lt;RecordedEvent&gt; events = getRevocationEvents(recording, EventNames.BiasedLockClassRevocation, &quot;revokedClass&quot;, MyLock.class);</span>
148         Asserts.assertEQ(events.size(), 1);
149 
150         RecordedEvent event = events.get(0);
151         Events.assertEventThread(event, biasBreaker);
152         Events.assertField(event, &quot;disableBiasing&quot;).equal(false);
153 
154         RecordedClass lockClass = event.getValue(&quot;revokedClass&quot;);
155         Asserts.assertEquals(lockClass.getName(), MyLock.class.getName());
156 
157         validateStackTrace(event.getStackTrace());
158     }
159 
160     static void testSelfRevocation() throws Throwable {
161         class MyLock {};
162 
163         Recording recording = new Recording();
164 
165         recording.enable(EventNames.BiasedLockSelfRevocation);
166         recording.start();
167 
168         MyLock l = new MyLock();
169         touch(l);
170         Thread.holdsLock(l);
171 
172         recording.stop();
<a name="7" id="anc7"></a><span class="line-modified">173         List&lt;RecordedEvent&gt; events = getRevocationEvents(recording, EventNames.BiasedLockSelfRevocation, &quot;lockClass&quot;, MyLock.class);</span>
174         Asserts.assertEQ(events.size(), 1);
175 
176         RecordedEvent event = events.get(0);
177         Events.assertEventThread(event, Thread.currentThread());
178 
179         validateStackTrace(event.getStackTrace(), &quot;holdsLock&quot;);
180     }
181 
182     static void testExitedThreadRevocation() throws Throwable {
183         class MyLock {};
184 
185         Recording recording = new Recording();
186 
187         recording.enable(EventNames.BiasedLockRevocation);
188         recording.start();
189 
190         FutureTask&lt;MyLock&gt; lockerTask = new FutureTask&lt;&gt;(() -&gt; {
191            MyLock l = new MyLock();
192            touch(l);
193            return l;
194         });
195 
196         Thread locker = new Thread(lockerTask, &quot;BiasLocker&quot;);
197         locker.start();
198         locker.join();
199 
200         // Even after joining, the VM has a bit more work to do before the thread is actually removed
201         // from the threads list. Ensure that this has happened before proceeding.
202         while (true) {
203             PidJcmdExecutor jcmd = new PidJcmdExecutor();
204             OutputAnalyzer oa = jcmd.execute(&quot;Thread.print&quot;, true);
205             String lockerThreadFound = oa.firstMatch(&quot;BiasLocker&quot;);
206             if (lockerThreadFound == null) {
207                 break;
208             }
209         };
210 
211         MyLock l = lockerTask.get();
212         touch(l);
213 
214         recording.stop();
<a name="8" id="anc8"></a><span class="line-modified">215         List&lt;RecordedEvent&gt; events = getRevocationEvents(recording, EventNames.BiasedLockRevocation, &quot;lockClass&quot;, MyLock.class);</span>
216         Asserts.assertEQ(events.size(), 1);
217 
218         RecordedEvent event = events.get(0);
219         Events.assertEventThread(event, Thread.currentThread());
220         // Previous owner will usually be null, but can also be a thread that
221         // was created after the BiasLocker thread exited due to address reuse.
222         RecordedThread prevOwner = event.getValue(&quot;previousOwner&quot;);
223         if (prevOwner != null) {
224             Asserts.assertNE(prevOwner.getJavaName(), &quot;BiasLocker&quot;);
225         }
226         validateStackTrace(event.getStackTrace());
227     }
228 
229     static void testBulkRevocationNoRebias() throws Throwable {
230         class MyLock {};
231 
232         Recording recording = new Recording();
233 
234         recording.enable(EventNames.BiasedLockClassRevocation);
235         recording.start();
236 
237         Thread biasBreaker0 = triggerRevocation(BULK_REVOKE_THRESHOLD, MyLock.class);
238         Thread biasBreaker1 = triggerRevocation(BULK_REVOKE_THRESHOLD, MyLock.class);
239 
240         recording.stop();
<a name="9" id="anc9"></a><span class="line-modified">241         List&lt;RecordedEvent&gt; events = getRevocationEvents(recording, EventNames.BiasedLockClassRevocation, &quot;revokedClass&quot;, MyLock.class);</span>
242         Asserts.assertEQ(events.size(), 2);
243 
244         // The rebias event should occur before the noRebias one
245         RecordedEvent eventRebias = events.get(0);
246         RecordedEvent eventNoRebias = events.get(1);
247 
248         Events.assertEventThread(eventRebias, biasBreaker0);
249         Events.assertField(eventRebias, &quot;disableBiasing&quot;).equal(false);
250 
251         Events.assertEventThread(eventNoRebias, biasBreaker1);
252         Events.assertField(eventNoRebias, &quot;disableBiasing&quot;).equal(true);
253 
254         RecordedClass lockClassRebias = eventRebias.getValue(&quot;revokedClass&quot;);
255         Asserts.assertEquals(lockClassRebias.getName(), MyLock.class.getName());
256         RecordedClass lockClassNoRebias = eventNoRebias.getValue(&quot;revokedClass&quot;);
257         Asserts.assertEquals(lockClassNoRebias.getName(), MyLock.class.getName());
258 
259         validateStackTrace(eventRebias.getStackTrace());
260         validateStackTrace(eventNoRebias.getStackTrace());
261     }
262 
263     static void testRevocationSafepointIdCorrelation() throws Throwable {
264         class MyLock {};
265 
266         Recording recording = new Recording();
267 
<a name="10" id="anc10"></a>
268         recording.enable(EventNames.BiasedLockClassRevocation);
269         recording.enable(EventNames.ExecuteVMOperation);
270         recording.start();
271 
272         triggerRevocation(BULK_REVOKE_THRESHOLD, MyLock.class);
273 
274         recording.stop();
275         List&lt;RecordedEvent&gt; events = Events.fromRecording(recording);
276 
<a name="11" id="anc11"></a><span class="line-modified">277         // Determine which safepoints included bulk revocation VM operations</span>

278         Set&lt;Long&gt; vmOperationsBulk = new HashSet&lt;&gt;();
279 
280         for (RecordedEvent event : events) {
281             if (event.getEventType().getName().equals(EventNames.ExecuteVMOperation)) {
282                 String operation = event.getValue(&quot;operation&quot;);
283                 Long safepointId = event.getValue(&quot;safepointId&quot;);
284 
<a name="12" id="anc12"></a><span class="line-modified">285                 if (operation.equals(&quot;BulkRevokeBias&quot;)) {</span>


286                     vmOperationsBulk.add(safepointId);
287                 }
288             }
289         }
290 
<a name="13" id="anc13"></a>
291         int bulkRevokeCount = 0;
292 
293         // Match all revoke events to a corresponding VMOperation event
294         for (RecordedEvent event : events) {
<a name="14" id="anc14"></a><span class="line-modified">295             if (event.getEventType().getName().equals(EventNames.BiasedLockClassRevocation)) {</span>







296                 Long safepointId = event.getValue(&quot;safepointId&quot;);
297                 String lockClass = ((RecordedClass)event.getValue(&quot;revokedClass&quot;)).getName();
298                 if (lockClass.toString().equals(MyLock.class.getName())) {
299                     Asserts.assertTrue(vmOperationsBulk.contains(safepointId));
300                     bulkRevokeCount++;
301                 }
302             }
303         }
304 
305         Asserts.assertGT(bulkRevokeCount, 0);
<a name="15" id="anc15"></a>
306     }
307 }
<a name="16" id="anc16"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="16" type="hidden" />
</body>
</html>
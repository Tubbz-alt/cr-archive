<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames test/jdk/jdk/jfr/event/gc/stacktrace/AllocationStackTrace.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
<a name="1" id="anc1"></a><span class="line-modified">  2  * Copyright (c) 2015, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 package jdk.jfr.event.gc.stacktrace;
 26 
 27 import javax.management.MBeanServer;
 28 import java.lang.management.ManagementFactory;
 29 import com.sun.management.GarbageCollectorMXBean;
 30 
 31 import jdk.jfr.Recording;
 32 import jdk.jfr.consumer.RecordedEvent;
 33 import jdk.jfr.consumer.RecordedStackTrace;
 34 import jdk.jfr.consumer.RecordedFrame;
 35 import jdk.jfr.consumer.RecordedMethod;
 36 import jdk.jfr.consumer.RecordedThread;
 37 import jdk.test.lib.jfr.EventNames;
 38 import jdk.test.lib.jfr.Events;
 39 
 40 import java.util.List;
 41 import java.util.ArrayList;
 42 
 43 import java.net.URL;
 44 import java.net.URLClassLoader;
 45 import java.lang.reflect.InvocationHandler;
 46 import java.lang.reflect.Method;
 47 import java.lang.reflect.Proxy;
 48 
 49 abstract class MemoryAllocator {
 50 
 51     public static final int KB = 1024;
 52     public static final int MB = 1024 * KB;
 53 
 54     public static Object garbage = null;
 55 
 56     abstract public void allocate();
 57     public void clear() {
 58         garbage = null;
 59     }
 60 }
 61 
 62 class EdenMemoryAllocator extends MemoryAllocator {
 63 
 64     @Override
 65     public void allocate() {
 66         garbage = new byte[10 * KB];
 67     }
 68 }
 69 
 70 class HumongousMemoryAllocator extends MemoryAllocator {
 71 
 72     @Override
 73     public void allocate() {
 74         garbage = new byte[5 * MB];
 75     }
 76 }
 77 
 78 /**
 79  * Attempts to fill up young gen and allocate in old gen
 80  */
 81 class OldGenMemoryAllocator extends MemoryAllocator {
 82 
 83     private List&lt;byte[]&gt; list = new ArrayList&lt;byte[]&gt;();
 84     private int counter = 6000;
 85 
 86     @Override
 87     public void allocate() {
 88         if (counter-- &gt; 0) {
 89             list.add(new byte[10 * KB]);
 90         } else {
 91             list = new ArrayList&lt;byte[]&gt;();
 92             counter = 6000;
 93         }
 94 
 95         garbage = list;
 96     }
 97 
 98     @Override
 99     public void clear(){
100         list = null;
101         super.clear();
102     }
103 }
104 
105 class MetaspaceMemoryAllocator extends MemoryAllocator {
106 
107     private static int counter = 0;
108 
109     /**
110      * Imitates class loading. Each invocation of this method causes a new class
111      * loader object is created and a new class is loaded by this class loader.
112      * Method throws OOM when run out of memory.
113      */
114     static protected void loadNewClass() {
115         try {
116             String jarUrl = &quot;file:&quot; + (counter++) + &quot;.jar&quot;;
117             URL[] urls = new URL[]{new URL(jarUrl)};
118             URLClassLoader cl = new URLClassLoader(urls);
119             Proxy.newProxyInstance(
120                     cl,
121                     new Class[]{Foo.class},
122                     new FooInvocationHandler(new FooBar()));
123         } catch (java.net.MalformedURLException badThing) {
124             // should never occur
125             System.err.println(&quot;Unexpected error: &quot; + badThing);
126             throw new RuntimeException(badThing);
127         }
128     }
129 
130     @Override
131     public void allocate() {
132         try {
133             loadNewClass();
134         } catch (OutOfMemoryError e) {
135             /* empty */
136         }
137     }
138 
139     public static interface Foo {
140     }
141 
142     public static class FooBar implements Foo {
143     }
144 
145     static class FooInvocationHandler implements InvocationHandler {
146 
147         private final Foo foo;
148 
149         FooInvocationHandler(Foo foo) {
150             this.foo = foo;
151         }
152 
153         @Override
154         public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
155             return method.invoke(foo, args);
156         }
157     }
158 }
159 
160 /**
161  * Utility class to peform JFR recording, GC provocation/detection and
162  * stacktrace verification for related JFR events
163  */
164 public class AllocationStackTrace {
165 
166     /**
167      * Tests event stacktrace for young GC if -XX:+UseSerialGC is used
168      */
169     public static void testDefNewAllocEvent() throws Exception {
170         GarbageCollectorMXBean bean = garbageCollectorMXBean(&quot;Copy&quot;);
171         MemoryAllocator memory = new EdenMemoryAllocator();
172 
173         String[] expectedStack = new String[]{
174             &quot;jdk.jfr.event.gc.stacktrace.AllocationStackTrace.testAllocEvent&quot;,
175             &quot;jdk.jfr.event.gc.stacktrace.AllocationStackTrace.testDefNewAllocEvent&quot;
176         };
177 
178         testAllocEvent(bean, memory, expectedStack);
179     }
180 
181     /**
182      * Tests event stacktrace for old GC if -XX:+UseSerialGC is used
183      */
184     public static void testMarkSweepCompactAllocEvent() throws Exception {
185         GarbageCollectorMXBean bean = garbageCollectorMXBean(&quot;MarkSweepCompact&quot;);
186         MemoryAllocator memory = new OldGenMemoryAllocator();
187 
188         String[] expectedStack = new String[]{
189             &quot;jdk.jfr.event.gc.stacktrace.AllocationStackTrace.testAllocEvent&quot;,
190             &quot;jdk.jfr.event.gc.stacktrace.AllocationStackTrace.testMarkSweepCompactAllocEvent&quot;
191         };
192 
193         testAllocEvent(bean, memory, expectedStack);
194     }
195 
196     /**
197      * Tests event stacktrace during metaspace GC threshold if -XX:+UseSerialGC
198      * is used
199      */
200     public static void testMetaspaceSerialGCAllocEvent() throws Exception {
201         GarbageCollectorMXBean bean = garbageCollectorMXBean(&quot;MarkSweepCompact&quot;);
202         MemoryAllocator memory = new MetaspaceMemoryAllocator();
203 
204         String[] expectedStack = new String[]{
205             &quot;jdk.jfr.event.gc.stacktrace.AllocationStackTrace.testAllocEvent&quot;,
206             &quot;jdk.jfr.event.gc.stacktrace.AllocationStackTrace.testMetaspaceSerialGCAllocEvent&quot;
207         };
208 
209         testAllocEvent(bean, memory, expectedStack);
210     }
211 
<a name="2" id="anc2"></a>













































212     /**
213      * Tests event stacktrace for young GC if -XX:+UseParallelGC is used
214      */
215     public static void testParallelScavengeAllocEvent() throws Exception {
216         GarbageCollectorMXBean bean = garbageCollectorMXBean(&quot;PS Scavenge&quot;);
217         MemoryAllocator memory = new EdenMemoryAllocator();
218 
219         String[] expectedStack = new String[]{
220             &quot;jdk.jfr.event.gc.stacktrace.AllocationStackTrace.testAllocEvent&quot;,
221             &quot;jdk.jfr.event.gc.stacktrace.AllocationStackTrace.testParallelScavengeAllocEvent&quot;
222         };
223 
224         testAllocEvent(bean, memory, expectedStack);
225     }
226 
227     /**
228      * Tests event stacktrace for old GC if -XX:+UseParallelGC is used
229      */
230     public static void testParallelMarkSweepAllocEvent() throws Exception {
231         GarbageCollectorMXBean bean = garbageCollectorMXBean(&quot;PS MarkSweep&quot;);
232         MemoryAllocator memory = new OldGenMemoryAllocator();
233 
234         String[] expectedStack = new String[]{
235             &quot;jdk.jfr.event.gc.stacktrace.AllocationStackTrace.testAllocEvent&quot;,
236             &quot;jdk.jfr.event.gc.stacktrace.AllocationStackTrace.testParallelMarkSweepAllocEvent&quot;
237         };
238 
239         testAllocEvent(bean, memory, expectedStack);
240     }
241 
242     /**
243      * Tests event stacktrace during metaspace GC threshold if
244      * -XX:+UseParallelGC is used
245      */
246     public static void testMetaspaceParallelGCAllocEvent() throws Exception {
247         GarbageCollectorMXBean bean = garbageCollectorMXBean(&quot;PS MarkSweep&quot;);
248         MemoryAllocator memory = new MetaspaceMemoryAllocator();
249 
250         String[] expectedStack = new String[]{
251             &quot;jdk.jfr.event.gc.stacktrace.AllocationStackTrace.testAllocEvent&quot;,
252             &quot;jdk.jfr.event.gc.stacktrace.AllocationStackTrace.testMetaspaceParallelGCAllocEvent&quot;
253         };
254 
255         testAllocEvent(bean, memory, expectedStack);
256     }
257 
258     /**
259      * Tests event stacktrace for young GC if -XX:+UseG1GC is used
260      */
261     public static void testG1YoungAllocEvent() throws Exception {
262         GarbageCollectorMXBean bean = garbageCollectorMXBean(&quot;G1 Young Generation&quot;);
263         MemoryAllocator memory = new EdenMemoryAllocator();
264 
265         String[] expectedStack = new String[]{
266             &quot;jdk.jfr.event.gc.stacktrace.AllocationStackTrace.testAllocEvent&quot;,
267             &quot;jdk.jfr.event.gc.stacktrace.AllocationStackTrace.testG1YoungAllocEvent&quot;
268         };
269 
270         testAllocEvent(bean, memory, expectedStack);
271     }
272 
273     /**
274      * Tests event stacktrace for old GC if -XX:+UseG1GC is used
275      */
276     public static void testG1OldAllocEvent() throws Exception {
277         GarbageCollectorMXBean bean = garbageCollectorMXBean(&quot;G1 Old Generation&quot;);
278         MemoryAllocator memory = new OldGenMemoryAllocator();
279 
280         String[] expectedStack = new String[]{
281             &quot;jdk.jfr.event.gc.stacktrace.AllocationStackTrace.testAllocEvent&quot;,
282             &quot;jdk.jfr.event.gc.stacktrace.AllocationStackTrace.testG1OldAllocEvent&quot;
283         };
284 
285         testAllocEvent(bean, memory, expectedStack);
286     }
287 
288     /**
289      * Tests event stacktrace during metaspace GC threshold if -XX:+UseG1GC is
290      * used
291      */
292     public static void testMetaspaceG1GCAllocEvent() throws Exception {
293         GarbageCollectorMXBean bean = garbageCollectorMXBean(&quot;G1 Young Generation&quot;);
294         MemoryAllocator memory = new MetaspaceMemoryAllocator();
295 
296         String[] expectedStack = new String[]{
297             &quot;jdk.jfr.event.gc.stacktrace.AllocationStackTrace.testAllocEvent&quot;,
298             &quot;jdk.jfr.event.gc.stacktrace.AllocationStackTrace.testMetaspaceG1GCAllocEvent&quot;
299         };
300 
301         testAllocEvent(bean, memory, expectedStack);
302     }
303 
304     /**
305      * Tests event stacktrace for GC caused by humongous allocations if
306      * -XX:+UseG1GC is used
307      */
308     public static void testG1HumonAllocEvent() throws Exception {
309         // G1 tries to reclaim humongous objects at every young collection
310         // after doing a conservative estimate of its liveness
311         GarbageCollectorMXBean bean = garbageCollectorMXBean(&quot;G1 Young Generation&quot;);
312         MemoryAllocator memory = new HumongousMemoryAllocator();
313 
314         String[] expectedStack = new String[]{
315             &quot;jdk.jfr.event.gc.stacktrace.AllocationStackTrace.testAllocEvent&quot;,
316             &quot;jdk.jfr.event.gc.stacktrace.AllocationStackTrace.testG1HumonAllocEvent&quot;
317         };
318 
319         testAllocEvent(bean, memory, expectedStack);
320     }
321 
322     private static GarbageCollectorMXBean garbageCollectorMXBean(String name) throws Exception {
323         MBeanServer server = ManagementFactory.getPlatformMBeanServer();
324         GarbageCollectorMXBean bean = ManagementFactory.newPlatformMXBeanProxy(
325                 server, &quot;java.lang:type=GarbageCollector,name=&quot; + name, GarbageCollectorMXBean.class);
326         return bean;
327     }
328 
329     /**
330      * Performs JFR recording, GC provocation/detection and stacktrace
331      * verification for JFR event. In case of verification failure
332      * repeats several times.
333      *
334      * @param bean MX bean for desired GC
335      * @param memory allocator for desired type of allocations
336      * @param expectedStack array of expected frames
337      */
338     private static void testAllocEvent(GarbageCollectorMXBean bean, MemoryAllocator memory, String[] expectedStack) throws Exception {
339         // The test checks the stacktrace of events and expects all the events are fired
340         // in the current thread. But compilation may also trigger GC.
341         // So to filter out such cases the test performs several iterations and expects
342         // that the memory allocations made by the test will produce the desired JFR event.
343         final int iterations = 5;
344         for (int i = 0; i &lt; iterations; i++) {
345             if (allocAndCheck(bean, memory, expectedStack)) {
346                 return;
347             } else {
348                 System.out.println(&quot;Attempt: &quot; + i + &quot; out of &quot; + iterations+&quot;: no matching stack trace found.&quot;);
349             }
350             memory.clear();
351         }
352         throw new AssertionError(&quot;No matching stack trace found&quot;);
353     }
354 
355     /**
356      * Performs JFR recording, GC provocation/detection and stacktrace
357      * verification for JFR event.
358      *
359      * @param bean MX bean for desired GC
360      * @param memory allocator for desired type of allocations
361      * @param expectedStack array of expected frames
362      * @throws Exception
363      */
364     private static boolean allocAndCheck(GarbageCollectorMXBean bean, MemoryAllocator memory,
365             String[] expectedStack) throws Exception {
366         String threadName = Thread.currentThread().getName();
367         String event = EventNames.AllocationRequiringGC;
368 
369         Recording r = new Recording();
370         r.enable(event).withStackTrace();
371         r.start();
372 
373         long prevCollectionCount = bean.getCollectionCount();
374         long collectionCount = -1;
375 
376         long iterationCount = 0;
377 
378         do {
379             memory.allocate();
380             collectionCount = bean.getCollectionCount();
381             iterationCount++;
382         } while (collectionCount == prevCollectionCount);
383 
384         System.out.println(&quot;Allocation num: &quot; + iterationCount);
385         System.out.println(&quot;GC detected: &quot; + collectionCount);
386 
387         r.stop();
388         List&lt;RecordedEvent&gt; events = Events.fromRecording(r);
389 
390         System.out.println(&quot;JFR GC events found: &quot; + events.size());
391 
392         // Find any event that matched the expected stack trace
393         for (RecordedEvent e : events) {
394             System.out.println(&quot;Event: &quot; + e);
395             RecordedThread thread = e.getThread();
396             String eventThreadName = thread.getJavaName();
397             if (!threadName.equals(eventThreadName)) {
398                 continue;
399             }
400             if (matchingStackTrace(e.getStackTrace(), expectedStack)) {
401                 return true;
402             }
403         }
404         return false;
405     }
406 
407     private static boolean matchingStackTrace(RecordedStackTrace stack, String[] expectedStack) {
408         if (stack == null) {
409             return false;
410         }
411 
412         List&lt;RecordedFrame&gt; frames = stack.getFrames();
413         int pos = findFramePos(frames, expectedStack[0]);
414 
415         if (pos == -1) {
416             return false;
417         }
418 
419         for (String expectedFrame : expectedStack) {
420             RecordedFrame f = frames.get(pos++);
421             String frame = frameToString(f);
422 
423             if (!frame.equals(expectedFrame)) {
424                 return false;
425             }
426         }
427 
428         return true;
429     }
430 
431     private static int findFramePos(List&lt;RecordedFrame&gt; frames, String frame) {
432         int pos = 0;
433 
434         for (RecordedFrame f : frames) {
435             if (frame.equals(frameToString(f))) {
436                 return pos;
437             }
438             pos++;
439         }
440 
441         return -1;
442     }
443 
444     private static String frameToString(RecordedFrame f) {
445         RecordedMethod m = f.getMethod();
446         String methodName = m.getName();
447         String className = m.getType().getName();
448         return className + &quot;.&quot; + methodName;
449     }
450 
451 }
<a name="3" id="anc3"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="3" type="hidden" />
</body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff test/jdk/jdk/jfr/event/gc/collection/GCEventAll.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
<body>
<center><a href="../../compiler/TestCompilerStats.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="TestG1ParallelPhases.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>test/jdk/jdk/jfr/event/gc/collection/GCEventAll.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2013, 2018, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
</pre>
<hr />
<pre>
108         Recording recording = new Recording();
109         enableAllGcEvents(recording);
110 
111         // Start with a full GC to minimize risk of getting extra GC between
112         // getBeanCollectionCount() and recording.start().
113         doSystemGc();
114         GCHelper.CollectionSummary startBeanCount = GCHelper.CollectionSummary.createFromMxBeans();
115         recording.start();
116 
117         for (Thread t : workerThreads) {
118             t.start();
119         }
120         for (Thread t : workerThreads) {
121             t.join();
122         }
123 
124         // End with a full GC to minimize risk of getting extra GC between
125         // recording.stop and getBeanCollectionCount().
126         doSystemGc();
127         // Add an extra System.gc() to make sure we get at least one full garbage_collection batch at
<span class="line-modified">128         // the end of the test. This extra System.gc() is only necessary when using &quot;UseConcMarkSweepGC&quot; and &quot;+ExplicitGCInvokesConcurrent&quot;.</span>
129         doSystemGc();
130 
131         recording.stop();
132         GCHelper.CollectionSummary deltaBeanCount = GCHelper.CollectionSummary.createFromMxBeans();
133         deltaBeanCount = deltaBeanCount.calcDelta(startBeanCount);
134 
135         List&lt;RecordedEvent&gt; events = Events.fromRecording(recording).stream()
136             .filter(evt -&gt; EventNames.isGcEvent(evt.getEventType()))
137             .collect(Collectors.toList());
138         RecordedEvent configEvent = GCHelper.getConfigEvent(events);
139         youngCollector = Events.assertField(configEvent, &quot;youngCollector&quot;).notEmpty().getValue();
140         oldCollector = Events.assertField(configEvent, &quot;oldCollector&quot;).notEmpty().getValue();
141         verify(events, deltaBeanCount);
142     }
143 
144     private void enableAllGcEvents(Recording recording) {
145         FlightRecorder flightrecorder = FlightRecorder.getFlightRecorder();
146         for (EventType et : flightrecorder.getEventTypes()) {
147             if (EventNames.isGcEvent(et)) {
148                 recording.enable(et.getName());
</pre>
<hr />
<pre>
153     }
154 
155     private static synchronized void doSystemGc() {
156         System.gc();
157     }
158 
159     /**
160      * Does all verifications of the received events.
161      *
162      * @param events All flight recorder events.
163      * @param beanCounts Number of collections and sum pause time reported by GarbageCollectionMXBeans.
164      * @param gcIds All used gcIds. Must be unique.
165      * @throws Exception
166      */
167     private void verify(List&lt;RecordedEvent&gt; events, GCHelper.CollectionSummary beanCounts) throws Throwable {
168         List&lt;GCHelper.GcBatch&gt; gcBatches = null;
169         GCHelper.CollectionSummary eventCounts = null;
170 
171         // For some GC configurations, the JFR recording may have stopped before we received the last gc event.
172         try {
<span class="line-removed">173             events = filterIncompleteGcBatch(events);</span>
174             gcBatches = GCHelper.GcBatch.createFromEvents(events);
175             eventCounts = GCHelper.CollectionSummary.createFromEvents(gcBatches);
176 
177             verifyUniqueIds(gcBatches);
178             verifyCollectorNames(gcBatches);
179             verifyCollectionCause(gcBatches);
180             verifyCollectionCount(eventCounts, beanCounts);
181             verifyPhaseEvents(gcBatches);
182             verifySingleGcBatch(gcBatches);
183         } catch (Throwable t) {
184             log(events, gcBatches, eventCounts, beanCounts);
185             if (gcBatches != null) {
186                 for (GCHelper.GcBatch batch : gcBatches) {
187                     System.out.println(String.format(&quot;Batch:%n%s&quot;, batch.getLog()));
188                 }
189             }
190             throw t;
191         }
192     }
193 
<span class="line-removed">194     /**</span>
<span class="line-removed">195      * When using collector ConcurrentMarkSweep with -XX:+ExplicitGCInvokesConcurrent, the JFR recording may</span>
<span class="line-removed">196      * stop before we have received the last garbage_collection event.</span>
<span class="line-removed">197      *</span>
<span class="line-removed">198      * This function does 3 things:</span>
<span class="line-removed">199      * 1. Check if the last batch is incomplete.</span>
<span class="line-removed">200      * 2. If it is incomplete, then asserts that incomplete batches are allowed for this configuration.</span>
<span class="line-removed">201      * 3. If incomplete batches are allowed, then the incomplete batch is removed.</span>
<span class="line-removed">202      *</span>
<span class="line-removed">203      * @param events All events</span>
<span class="line-removed">204      * @return All events with any incomplete batch removed.</span>
<span class="line-removed">205      * @throws Throwable</span>
<span class="line-removed">206      */</span>
<span class="line-removed">207     private List&lt;RecordedEvent&gt; filterIncompleteGcBatch(List&lt;RecordedEvent&gt; events) throws Throwable {</span>
<span class="line-removed">208         List&lt;RecordedEvent&gt; returnEvents = new ArrayList&lt;RecordedEvent&gt;(events);</span>
<span class="line-removed">209         int lastGcId = getLastGcId(events);</span>
<span class="line-removed">210         List&lt;RecordedEvent&gt; lastBatchEvents = getEventsWithGcId(events, lastGcId);</span>
<span class="line-removed">211         String[] endEvents = {GCHelper.event_garbage_collection, GCHelper.event_old_garbage_collection, GCHelper.event_young_garbage_collection};</span>
<span class="line-removed">212         boolean isComplete = containsAnyPath(lastBatchEvents, endEvents);</span>
<span class="line-removed">213         if (!isComplete) {</span>
<span class="line-removed">214             // The last GC batch does not contain an end event. The batch is incomplete.</span>
<span class="line-removed">215             // This is only allowed if we are using old_collector=&quot;ConcurrentMarkSweep&quot; and &quot;-XX:+ExplicitGCInvokesConcurrent&quot;</span>
<span class="line-removed">216             boolean isExplicitGCInvokesConcurrent = hasInputArgument(&quot;-XX:+ExplicitGCInvokesConcurrent&quot;);</span>
<span class="line-removed">217             boolean isConcurrentMarkSweep = GCHelper.gcConcurrentMarkSweep.equals(oldCollector);</span>
<span class="line-removed">218             String msg = String.format(</span>
<span class="line-removed">219                     &quot;Incomplete batch only allowed for &#39;%s&#39; with -XX:+ExplicitGCInvokesConcurrent&quot;,</span>
<span class="line-removed">220                     GCHelper.gcConcurrentMarkSweep);</span>
<span class="line-removed">221             Asserts.assertTrue(isConcurrentMarkSweep &amp;&amp; isExplicitGCInvokesConcurrent, msg);</span>
<span class="line-removed">222 </span>
<span class="line-removed">223             // Incomplete batch is allowed with the current settings. Remove incomplete batch.</span>
<span class="line-removed">224             returnEvents.removeAll(lastBatchEvents);</span>
<span class="line-removed">225         }</span>
<span class="line-removed">226         return returnEvents;</span>
<span class="line-removed">227     }</span>
<span class="line-removed">228 </span>
229     private boolean hasInputArgument(String arg) {
230         return ManagementFactory.getRuntimeMXBean().getInputArguments().contains(arg);
231     }
232 
233     private List&lt;RecordedEvent&gt; getEventsWithGcId(List&lt;RecordedEvent&gt; events, int gcId) {
234         List&lt;RecordedEvent&gt; batchEvents = new ArrayList&lt;&gt;();
235         for (RecordedEvent event : events) {
236             if (GCHelper.isGcEvent(event) &amp;&amp; GCHelper.getGcId(event) == gcId) {
237                 batchEvents.add(event);
238             }
239         }
240         return batchEvents;
241     }
242 
243     private boolean containsAnyPath(List&lt;RecordedEvent&gt; events, String[] paths) {
244         List&lt;String&gt; pathList = Arrays.asList(paths);
245         for (RecordedEvent event : events) {
246             if (pathList.contains(event.getEventType().getName())) {
247                 return true;
248             }
</pre>
<hr />
<pre>
259                     lastGcId = gcId;
260                 }
261             }
262         }
263         Asserts.assertTrue(lastGcId != -1, &quot;No gcId found&quot;);
264         return lastGcId;
265     }
266 
267     /**
268      * Verifies collection count reported by flight recorder events against the values
269      * reported by GarbageCollectionMXBean.
270      * Number of collections should match exactly.
271      * Sum pause time are allowed some margin of error because of rounding errors in measurements.
272      */
273     private void verifyCollectionCount(GCHelper.CollectionSummary eventCounts, GCHelper.CollectionSummary beanCounts) {
274         verifyCollectionCount(youngCollector, eventCounts.collectionCountYoung, beanCounts.collectionCountYoung);
275         verifyCollectionCount(oldCollector, eventCounts.collectionCountOld, beanCounts.collectionCountOld);
276     }
277 
278     private void verifyCollectionCount(String collector, long eventCounts, long beanCounts) {
<span class="line-modified">279         if (GCHelper.gcConcurrentMarkSweep.equals(collector) || GCHelper.gcG1Old.equals(oldCollector)) {</span>
<span class="line-removed">280             // ConcurrentMarkSweep mixes old and new collections. Not same values as in MXBean.</span>
281             // MXBean does not report old collections for G1Old, so we have nothing to compare with.
282             return;
283         }
284         // JFR events and GarbageCollectorMXBean events are not updated at the same time.
285         // This means that number of collections may diff.
286         // We allow a diff of +- 1 collection count.
287         long minCount = Math.max(0, beanCounts - 1);
288         long maxCount = beanCounts + 1;
289         Asserts.assertGreaterThanOrEqual(eventCounts, minCount, &quot;Too few event counts for collector &quot; + collector);
290         Asserts.assertLessThanOrEqual(eventCounts, maxCount, &quot;Too many event counts for collector &quot; + collector);
291     }
292 
293     /**
294      * Verifies that all events belonging to a single GC are ok.
295      * A GcBatch contains all flight recorder events that belong to a single GC.
296      */
297     private void verifySingleGcBatch(List&lt;GCHelper.GcBatch&gt; batches) {
298         for (GCHelper.GcBatch batch : batches) {
299             //System.out.println(&quot;batch:\r\n&quot; + batch.getLog());
300             try {
</pre>
<hr />
<pre>
321                 for (String requiredEvent : requiredEvents) {
322                     boolean b = batch.containsEvent(requiredEvent);
323                     Asserts.assertTrue(b, String.format(&quot;%s does not contain event %s&quot;, batch, requiredEvent));
324                 }
325 
326                 // Verify that we have exactly one heap_summary &quot;Before GC&quot; and one &quot;After GC&quot;.
327                 int countBeforeGc = 0;
328                 int countAfterGc = 0;
329                 for (RecordedEvent event : batch.getEvents()) {
330                     if (GCHelper.event_heap_summary.equals(event.getEventType().getName())) {
331                         String when = Events.assertField(event, &quot;when&quot;).notEmpty().getValue();
332                         if (&quot;Before GC&quot;.equals(when)) {
333                             countBeforeGc++;
334                         } else if (&quot;After GC&quot;.equals(when)) {
335                             countAfterGc++;
336                         } else {
337                             Asserts.fail(&quot;Unknown value for heap_summary.when: &#39;&quot; + when + &quot;&#39;&quot;);
338                         }
339                     }
340                 }
<span class="line-modified">341                 if (!GCHelper.gcConcurrentMarkSweep.equals(batch.getName())) {</span>
<span class="line-modified">342                     // We do not get heap_summary events for ConcurrentMarkSweep</span>
<span class="line-removed">343                     Asserts.assertEquals(1, countBeforeGc, &quot;Unexpected number of heap_summary.before_gc&quot;);</span>
<span class="line-removed">344                     Asserts.assertEquals(1, countAfterGc, &quot;Unexpected number of heap_summary.after_gc&quot;);</span>
<span class="line-removed">345                 }</span>
346             } catch (Throwable e) {
347                 GCHelper.log(&quot;verifySingleGcBatch failed for gcEvent:&quot;);
348                 GCHelper.log(batch.getLog());
349                 throw e;
350             }
351         }
352     }
353 
354     private Set&lt;Integer&gt; verifyUniqueIds(List&lt;GCHelper.GcBatch&gt; batches) {
355         Set&lt;Integer&gt; gcIds = new HashSet&lt;&gt;();
356         for (GCHelper.GcBatch batch : batches) {
357             Integer gcId = new Integer(batch.getGcId());
358             Asserts.assertFalse(gcIds.contains(gcId), &quot;Duplicate gcId: &quot; + gcId);
359             gcIds.add(gcId);
360         }
361         return gcIds;
362     }
363 
364     private void verifyPhaseEvents(List&lt;GCHelper.GcBatch&gt; batches) {
365         for (GCHelper.GcBatch batch : batches) {
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2013, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
</pre>
<hr />
<pre>
108         Recording recording = new Recording();
109         enableAllGcEvents(recording);
110 
111         // Start with a full GC to minimize risk of getting extra GC between
112         // getBeanCollectionCount() and recording.start().
113         doSystemGc();
114         GCHelper.CollectionSummary startBeanCount = GCHelper.CollectionSummary.createFromMxBeans();
115         recording.start();
116 
117         for (Thread t : workerThreads) {
118             t.start();
119         }
120         for (Thread t : workerThreads) {
121             t.join();
122         }
123 
124         // End with a full GC to minimize risk of getting extra GC between
125         // recording.stop and getBeanCollectionCount().
126         doSystemGc();
127         // Add an extra System.gc() to make sure we get at least one full garbage_collection batch at
<span class="line-modified">128         // the end of the test. This extra System.gc() is only necessary when using &quot;+ExplicitGCInvokesConcurrent&quot;.</span>
129         doSystemGc();
130 
131         recording.stop();
132         GCHelper.CollectionSummary deltaBeanCount = GCHelper.CollectionSummary.createFromMxBeans();
133         deltaBeanCount = deltaBeanCount.calcDelta(startBeanCount);
134 
135         List&lt;RecordedEvent&gt; events = Events.fromRecording(recording).stream()
136             .filter(evt -&gt; EventNames.isGcEvent(evt.getEventType()))
137             .collect(Collectors.toList());
138         RecordedEvent configEvent = GCHelper.getConfigEvent(events);
139         youngCollector = Events.assertField(configEvent, &quot;youngCollector&quot;).notEmpty().getValue();
140         oldCollector = Events.assertField(configEvent, &quot;oldCollector&quot;).notEmpty().getValue();
141         verify(events, deltaBeanCount);
142     }
143 
144     private void enableAllGcEvents(Recording recording) {
145         FlightRecorder flightrecorder = FlightRecorder.getFlightRecorder();
146         for (EventType et : flightrecorder.getEventTypes()) {
147             if (EventNames.isGcEvent(et)) {
148                 recording.enable(et.getName());
</pre>
<hr />
<pre>
153     }
154 
155     private static synchronized void doSystemGc() {
156         System.gc();
157     }
158 
159     /**
160      * Does all verifications of the received events.
161      *
162      * @param events All flight recorder events.
163      * @param beanCounts Number of collections and sum pause time reported by GarbageCollectionMXBeans.
164      * @param gcIds All used gcIds. Must be unique.
165      * @throws Exception
166      */
167     private void verify(List&lt;RecordedEvent&gt; events, GCHelper.CollectionSummary beanCounts) throws Throwable {
168         List&lt;GCHelper.GcBatch&gt; gcBatches = null;
169         GCHelper.CollectionSummary eventCounts = null;
170 
171         // For some GC configurations, the JFR recording may have stopped before we received the last gc event.
172         try {

173             gcBatches = GCHelper.GcBatch.createFromEvents(events);
174             eventCounts = GCHelper.CollectionSummary.createFromEvents(gcBatches);
175 
176             verifyUniqueIds(gcBatches);
177             verifyCollectorNames(gcBatches);
178             verifyCollectionCause(gcBatches);
179             verifyCollectionCount(eventCounts, beanCounts);
180             verifyPhaseEvents(gcBatches);
181             verifySingleGcBatch(gcBatches);
182         } catch (Throwable t) {
183             log(events, gcBatches, eventCounts, beanCounts);
184             if (gcBatches != null) {
185                 for (GCHelper.GcBatch batch : gcBatches) {
186                     System.out.println(String.format(&quot;Batch:%n%s&quot;, batch.getLog()));
187                 }
188             }
189             throw t;
190         }
191     }
192 



































193     private boolean hasInputArgument(String arg) {
194         return ManagementFactory.getRuntimeMXBean().getInputArguments().contains(arg);
195     }
196 
197     private List&lt;RecordedEvent&gt; getEventsWithGcId(List&lt;RecordedEvent&gt; events, int gcId) {
198         List&lt;RecordedEvent&gt; batchEvents = new ArrayList&lt;&gt;();
199         for (RecordedEvent event : events) {
200             if (GCHelper.isGcEvent(event) &amp;&amp; GCHelper.getGcId(event) == gcId) {
201                 batchEvents.add(event);
202             }
203         }
204         return batchEvents;
205     }
206 
207     private boolean containsAnyPath(List&lt;RecordedEvent&gt; events, String[] paths) {
208         List&lt;String&gt; pathList = Arrays.asList(paths);
209         for (RecordedEvent event : events) {
210             if (pathList.contains(event.getEventType().getName())) {
211                 return true;
212             }
</pre>
<hr />
<pre>
223                     lastGcId = gcId;
224                 }
225             }
226         }
227         Asserts.assertTrue(lastGcId != -1, &quot;No gcId found&quot;);
228         return lastGcId;
229     }
230 
231     /**
232      * Verifies collection count reported by flight recorder events against the values
233      * reported by GarbageCollectionMXBean.
234      * Number of collections should match exactly.
235      * Sum pause time are allowed some margin of error because of rounding errors in measurements.
236      */
237     private void verifyCollectionCount(GCHelper.CollectionSummary eventCounts, GCHelper.CollectionSummary beanCounts) {
238         verifyCollectionCount(youngCollector, eventCounts.collectionCountYoung, beanCounts.collectionCountYoung);
239         verifyCollectionCount(oldCollector, eventCounts.collectionCountOld, beanCounts.collectionCountOld);
240     }
241 
242     private void verifyCollectionCount(String collector, long eventCounts, long beanCounts) {
<span class="line-modified">243         if (GCHelper.gcG1Old.equals(oldCollector)) {</span>

244             // MXBean does not report old collections for G1Old, so we have nothing to compare with.
245             return;
246         }
247         // JFR events and GarbageCollectorMXBean events are not updated at the same time.
248         // This means that number of collections may diff.
249         // We allow a diff of +- 1 collection count.
250         long minCount = Math.max(0, beanCounts - 1);
251         long maxCount = beanCounts + 1;
252         Asserts.assertGreaterThanOrEqual(eventCounts, minCount, &quot;Too few event counts for collector &quot; + collector);
253         Asserts.assertLessThanOrEqual(eventCounts, maxCount, &quot;Too many event counts for collector &quot; + collector);
254     }
255 
256     /**
257      * Verifies that all events belonging to a single GC are ok.
258      * A GcBatch contains all flight recorder events that belong to a single GC.
259      */
260     private void verifySingleGcBatch(List&lt;GCHelper.GcBatch&gt; batches) {
261         for (GCHelper.GcBatch batch : batches) {
262             //System.out.println(&quot;batch:\r\n&quot; + batch.getLog());
263             try {
</pre>
<hr />
<pre>
284                 for (String requiredEvent : requiredEvents) {
285                     boolean b = batch.containsEvent(requiredEvent);
286                     Asserts.assertTrue(b, String.format(&quot;%s does not contain event %s&quot;, batch, requiredEvent));
287                 }
288 
289                 // Verify that we have exactly one heap_summary &quot;Before GC&quot; and one &quot;After GC&quot;.
290                 int countBeforeGc = 0;
291                 int countAfterGc = 0;
292                 for (RecordedEvent event : batch.getEvents()) {
293                     if (GCHelper.event_heap_summary.equals(event.getEventType().getName())) {
294                         String when = Events.assertField(event, &quot;when&quot;).notEmpty().getValue();
295                         if (&quot;Before GC&quot;.equals(when)) {
296                             countBeforeGc++;
297                         } else if (&quot;After GC&quot;.equals(when)) {
298                             countAfterGc++;
299                         } else {
300                             Asserts.fail(&quot;Unknown value for heap_summary.when: &#39;&quot; + when + &quot;&#39;&quot;);
301                         }
302                     }
303                 }
<span class="line-modified">304                 Asserts.assertEquals(1, countBeforeGc, &quot;Unexpected number of heap_summary.before_gc&quot;);</span>
<span class="line-modified">305                 Asserts.assertEquals(1, countAfterGc, &quot;Unexpected number of heap_summary.after_gc&quot;);</span>



306             } catch (Throwable e) {
307                 GCHelper.log(&quot;verifySingleGcBatch failed for gcEvent:&quot;);
308                 GCHelper.log(batch.getLog());
309                 throw e;
310             }
311         }
312     }
313 
314     private Set&lt;Integer&gt; verifyUniqueIds(List&lt;GCHelper.GcBatch&gt; batches) {
315         Set&lt;Integer&gt; gcIds = new HashSet&lt;&gt;();
316         for (GCHelper.GcBatch batch : batches) {
317             Integer gcId = new Integer(batch.getGcId());
318             Asserts.assertFalse(gcIds.contains(gcId), &quot;Duplicate gcId: &quot; + gcId);
319             gcIds.add(gcId);
320         }
321         return gcIds;
322     }
323 
324     private void verifyPhaseEvents(List&lt;GCHelper.GcBatch&gt; batches) {
325         for (GCHelper.GcBatch batch : batches) {
</pre>
</td>
</tr>
</table>
<center><a href="../../compiler/TestCompilerStats.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="TestG1ParallelPhases.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff test/jdk/jdk/jfr/event/runtime/TestBiasedLockRevocationEvents.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
<body>
<center><a href="../os/TestInitialEnvironmentVariable.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="TestClassLoadingStatisticsEvent.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>test/jdk/jdk/jfr/event/runtime/TestBiasedLockRevocationEvents.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2017, 2018, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
</pre>
<hr />
<pre>
 26 package jdk.jfr.event.runtime;
 27 
 28 import jdk.jfr.Recording;
 29 import jdk.jfr.consumer.*;
 30 import jdk.test.lib.Asserts;
 31 import jdk.test.lib.dcmd.PidJcmdExecutor;
 32 import jdk.test.lib.jfr.EventNames;
 33 import jdk.test.lib.jfr.Events;
 34 import jdk.test.lib.process.OutputAnalyzer;
 35 
 36 import java.util.*;
 37 import java.util.concurrent.FutureTask;
 38 import java.util.stream.Collectors;
 39 
 40 /**
 41  * @test
 42  * @key jfr
 43  * @requires vm.hasJFR
 44  * @library /test/lib
 45  *
<span class="line-modified"> 46  * @run main/othervm jdk.jfr.event.runtime.TestBiasedLockRevocationEvents</span>
 47  */
 48 public class TestBiasedLockRevocationEvents {
 49 
 50     public static void main(String[] args) throws Throwable {
 51         testSingleRevocation();
 52         testBulkRevocation();
 53         testSelfRevocation();
 54         testExitedThreadRevocation();
 55         testBulkRevocationNoRebias();
 56         testRevocationSafepointIdCorrelation();
 57     }
 58 
 59     // Default value of BiasedLockingBulkRebiasThreshold is 20, and BiasedLockingBulkRevokeTreshold is 40.
 60     // Using a value that will hit the first threshold once, and the second one the next time.
 61     private static final int BULK_REVOKE_THRESHOLD = 25;
 62 
 63     static void touch(Object lock) {
 64         synchronized(lock) {
 65         }
 66     }
</pre>
<hr />
<pre>
 84         biasBreaker.start();
 85         biasBreaker.join();
 86 
 87         return biasBreaker;
 88     }
 89 
 90     // Basic stack trace validation, checking the name of the leaf method
 91     static void validateStackTrace(RecordedStackTrace stackTrace, String leafMethodName) {
 92         List&lt;RecordedFrame&gt; frames = stackTrace.getFrames();
 93         Asserts.assertFalse(frames.isEmpty());
 94         String name = frames.get(0).getMethod().getName();
 95         Asserts.assertEquals(name, leafMethodName);
 96     }
 97 
 98     // Validates that the given stack trace refers to lock.touch(); in triggerRevocation
 99     static void validateStackTrace(RecordedStackTrace stackTrace) {
100         validateStackTrace(stackTrace, &quot;touch&quot;);
101     }
102 
103     // Retrieve all biased lock revocation events related to the provided lock class, sorted by start time
<span class="line-modified">104     static List&lt;RecordedEvent&gt; getRevocationEvents(Recording recording, String fieldName, Class&lt;?&gt; lockClass) throws Throwable {</span>
105         return Events.fromRecording(recording).stream()

106                 .filter(e -&gt; ((RecordedClass)e.getValue(fieldName)).getName().equals(lockClass.getName()))
107                 .sorted(Comparator.comparing(RecordedEvent::getStartTime))
108                 .collect(Collectors.toList());
109     }
110 
111     static void testSingleRevocation() throws Throwable {
112         class MyLock {};
113 
114         Recording recording = new Recording();
115 
116         recording.enable(EventNames.BiasedLockRevocation);
117         recording.start();
118 
119         Thread biasBreaker = triggerRevocation(1, MyLock.class);
120 
121         recording.stop();
<span class="line-modified">122         List&lt;RecordedEvent&gt; events = getRevocationEvents(recording, &quot;lockClass&quot;, MyLock.class);</span>
123         Asserts.assertEQ(events.size(), 1);
124 
125         RecordedEvent event = events.get(0);
126         Events.assertEventThread(event, biasBreaker);
127         Events.assertEventThread(event, &quot;previousOwner&quot;, Thread.currentThread());
128 
129         RecordedClass lockClass = event.getValue(&quot;lockClass&quot;);
130         Asserts.assertEquals(lockClass.getName(), MyLock.class.getName());
131 
132         validateStackTrace(event.getStackTrace());
133     }
134 
135     static void testBulkRevocation() throws Throwable {
136         class MyLock {};
137 
138         Recording recording = new Recording();
139 
140         recording.enable(EventNames.BiasedLockClassRevocation);
141         recording.start();
142 
143         Thread biasBreaker = triggerRevocation(BULK_REVOKE_THRESHOLD, MyLock.class);
144 
145         recording.stop();
<span class="line-modified">146         List&lt;RecordedEvent&gt; events = getRevocationEvents(recording, &quot;revokedClass&quot;, MyLock.class);</span>
147         Asserts.assertEQ(events.size(), 1);
148 
149         RecordedEvent event = events.get(0);
150         Events.assertEventThread(event, biasBreaker);
151         Events.assertField(event, &quot;disableBiasing&quot;).equal(false);
152 
153         RecordedClass lockClass = event.getValue(&quot;revokedClass&quot;);
154         Asserts.assertEquals(lockClass.getName(), MyLock.class.getName());
155 
156         validateStackTrace(event.getStackTrace());
157     }
158 
159     static void testSelfRevocation() throws Throwable {
160         class MyLock {};
161 
162         Recording recording = new Recording();
163 
164         recording.enable(EventNames.BiasedLockSelfRevocation);
165         recording.start();
166 
167         MyLock l = new MyLock();
168         touch(l);
169         Thread.holdsLock(l);
170 
171         recording.stop();
<span class="line-modified">172         List&lt;RecordedEvent&gt; events = getRevocationEvents(recording, &quot;lockClass&quot;, MyLock.class);</span>
173         Asserts.assertEQ(events.size(), 1);
174 
175         RecordedEvent event = events.get(0);
176         Events.assertEventThread(event, Thread.currentThread());
177 
178         validateStackTrace(event.getStackTrace(), &quot;holdsLock&quot;);
179     }
180 
181     static void testExitedThreadRevocation() throws Throwable {
182         class MyLock {};
183 
184         Recording recording = new Recording();
185 
186         recording.enable(EventNames.BiasedLockRevocation);
187         recording.start();
188 
189         FutureTask&lt;MyLock&gt; lockerTask = new FutureTask&lt;&gt;(() -&gt; {
190            MyLock l = new MyLock();
191            touch(l);
192            return l;
</pre>
<hr />
<pre>
194 
195         Thread locker = new Thread(lockerTask, &quot;BiasLocker&quot;);
196         locker.start();
197         locker.join();
198 
199         // Even after joining, the VM has a bit more work to do before the thread is actually removed
200         // from the threads list. Ensure that this has happened before proceeding.
201         while (true) {
202             PidJcmdExecutor jcmd = new PidJcmdExecutor();
203             OutputAnalyzer oa = jcmd.execute(&quot;Thread.print&quot;, true);
204             String lockerThreadFound = oa.firstMatch(&quot;BiasLocker&quot;);
205             if (lockerThreadFound == null) {
206                 break;
207             }
208         };
209 
210         MyLock l = lockerTask.get();
211         touch(l);
212 
213         recording.stop();
<span class="line-modified">214         List&lt;RecordedEvent&gt; events = getRevocationEvents(recording, &quot;lockClass&quot;, MyLock.class);</span>
215         Asserts.assertEQ(events.size(), 1);
216 
217         RecordedEvent event = events.get(0);
218         Events.assertEventThread(event, Thread.currentThread());
219         // Previous owner will usually be null, but can also be a thread that
220         // was created after the BiasLocker thread exited due to address reuse.
221         RecordedThread prevOwner = event.getValue(&quot;previousOwner&quot;);
222         if (prevOwner != null) {
223             Asserts.assertNE(prevOwner.getJavaName(), &quot;BiasLocker&quot;);
224         }
225         validateStackTrace(event.getStackTrace());
226     }
227 
228     static void testBulkRevocationNoRebias() throws Throwable {
229         class MyLock {};
230 
231         Recording recording = new Recording();
232 
233         recording.enable(EventNames.BiasedLockClassRevocation);
234         recording.start();
235 
236         Thread biasBreaker0 = triggerRevocation(BULK_REVOKE_THRESHOLD, MyLock.class);
237         Thread biasBreaker1 = triggerRevocation(BULK_REVOKE_THRESHOLD, MyLock.class);
238 
239         recording.stop();
<span class="line-modified">240         List&lt;RecordedEvent&gt; events = getRevocationEvents(recording, &quot;revokedClass&quot;, MyLock.class);</span>
241         Asserts.assertEQ(events.size(), 2);
242 
243         // The rebias event should occur before the noRebias one
244         RecordedEvent eventRebias = events.get(0);
245         RecordedEvent eventNoRebias = events.get(1);
246 
247         Events.assertEventThread(eventRebias, biasBreaker0);
248         Events.assertField(eventRebias, &quot;disableBiasing&quot;).equal(false);
249 
250         Events.assertEventThread(eventNoRebias, biasBreaker1);
251         Events.assertField(eventNoRebias, &quot;disableBiasing&quot;).equal(true);
252 
253         RecordedClass lockClassRebias = eventRebias.getValue(&quot;revokedClass&quot;);
254         Asserts.assertEquals(lockClassRebias.getName(), MyLock.class.getName());
255         RecordedClass lockClassNoRebias = eventNoRebias.getValue(&quot;revokedClass&quot;);
256         Asserts.assertEquals(lockClassNoRebias.getName(), MyLock.class.getName());
257 
258         validateStackTrace(eventRebias.getStackTrace());
259         validateStackTrace(eventNoRebias.getStackTrace());
260     }
261 
262     static void testRevocationSafepointIdCorrelation() throws Throwable {
263         class MyLock {};
264 
265         Recording recording = new Recording();
266 
<span class="line-removed">267         recording.enable(EventNames.BiasedLockRevocation);</span>
268         recording.enable(EventNames.BiasedLockClassRevocation);
269         recording.enable(EventNames.ExecuteVMOperation);
270         recording.start();
271 
272         triggerRevocation(BULK_REVOKE_THRESHOLD, MyLock.class);
273 
274         recording.stop();
275         List&lt;RecordedEvent&gt; events = Events.fromRecording(recording);
276 
<span class="line-modified">277         // Determine which safepoints included single and bulk revocation VM operations</span>
<span class="line-removed">278         Set&lt;Long&gt; vmOperationsSingle = new HashSet&lt;&gt;();</span>
279         Set&lt;Long&gt; vmOperationsBulk = new HashSet&lt;&gt;();
280 
281         for (RecordedEvent event : events) {
282             if (event.getEventType().getName().equals(EventNames.ExecuteVMOperation)) {
283                 String operation = event.getValue(&quot;operation&quot;);
284                 Long safepointId = event.getValue(&quot;safepointId&quot;);
285 
<span class="line-modified">286                 if (operation.equals(&quot;RevokeBias&quot;)) {</span>
<span class="line-removed">287                     vmOperationsSingle.add(safepointId);</span>
<span class="line-removed">288                 } else if (operation.equals(&quot;BulkRevokeBias&quot;)) {</span>
289                     vmOperationsBulk.add(safepointId);
290                 }
291             }
292         }
293 
<span class="line-removed">294         int revokeCount = 0;</span>
295         int bulkRevokeCount = 0;
296 
297         // Match all revoke events to a corresponding VMOperation event
298         for (RecordedEvent event : events) {
<span class="line-modified">299             if (event.getEventType().getName().equals(EventNames.BiasedLockRevocation)) {</span>
<span class="line-removed">300                 Long safepointId = event.getValue(&quot;safepointId&quot;);</span>
<span class="line-removed">301                 String lockClass = ((RecordedClass)event.getValue(&quot;lockClass&quot;)).getName();</span>
<span class="line-removed">302                 if (lockClass.equals(MyLock.class.getName())) {</span>
<span class="line-removed">303                     Asserts.assertTrue(vmOperationsSingle.contains(safepointId));</span>
<span class="line-removed">304                     revokeCount++;</span>
<span class="line-removed">305                 }</span>
<span class="line-removed">306             } else if (event.getEventType().getName().equals(EventNames.BiasedLockClassRevocation)) {</span>
307                 Long safepointId = event.getValue(&quot;safepointId&quot;);
308                 String lockClass = ((RecordedClass)event.getValue(&quot;revokedClass&quot;)).getName();
309                 if (lockClass.toString().equals(MyLock.class.getName())) {
310                     Asserts.assertTrue(vmOperationsBulk.contains(safepointId));
311                     bulkRevokeCount++;
312                 }
313             }
314         }
315 
316         Asserts.assertGT(bulkRevokeCount, 0);
<span class="line-removed">317         Asserts.assertGT(revokeCount, bulkRevokeCount);</span>
318     }
319 }
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2017, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
</pre>
<hr />
<pre>
 26 package jdk.jfr.event.runtime;
 27 
 28 import jdk.jfr.Recording;
 29 import jdk.jfr.consumer.*;
 30 import jdk.test.lib.Asserts;
 31 import jdk.test.lib.dcmd.PidJcmdExecutor;
 32 import jdk.test.lib.jfr.EventNames;
 33 import jdk.test.lib.jfr.Events;
 34 import jdk.test.lib.process.OutputAnalyzer;
 35 
 36 import java.util.*;
 37 import java.util.concurrent.FutureTask;
 38 import java.util.stream.Collectors;
 39 
 40 /**
 41  * @test
 42  * @key jfr
 43  * @requires vm.hasJFR
 44  * @library /test/lib
 45  *
<span class="line-modified"> 46  * @run main/othervm -XX:+UseBiasedLocking jdk.jfr.event.runtime.TestBiasedLockRevocationEvents</span>
 47  */
 48 public class TestBiasedLockRevocationEvents {
 49 
 50     public static void main(String[] args) throws Throwable {
 51         testSingleRevocation();
 52         testBulkRevocation();
 53         testSelfRevocation();
 54         testExitedThreadRevocation();
 55         testBulkRevocationNoRebias();
 56         testRevocationSafepointIdCorrelation();
 57     }
 58 
 59     // Default value of BiasedLockingBulkRebiasThreshold is 20, and BiasedLockingBulkRevokeTreshold is 40.
 60     // Using a value that will hit the first threshold once, and the second one the next time.
 61     private static final int BULK_REVOKE_THRESHOLD = 25;
 62 
 63     static void touch(Object lock) {
 64         synchronized(lock) {
 65         }
 66     }
</pre>
<hr />
<pre>
 84         biasBreaker.start();
 85         biasBreaker.join();
 86 
 87         return biasBreaker;
 88     }
 89 
 90     // Basic stack trace validation, checking the name of the leaf method
 91     static void validateStackTrace(RecordedStackTrace stackTrace, String leafMethodName) {
 92         List&lt;RecordedFrame&gt; frames = stackTrace.getFrames();
 93         Asserts.assertFalse(frames.isEmpty());
 94         String name = frames.get(0).getMethod().getName();
 95         Asserts.assertEquals(name, leafMethodName);
 96     }
 97 
 98     // Validates that the given stack trace refers to lock.touch(); in triggerRevocation
 99     static void validateStackTrace(RecordedStackTrace stackTrace) {
100         validateStackTrace(stackTrace, &quot;touch&quot;);
101     }
102 
103     // Retrieve all biased lock revocation events related to the provided lock class, sorted by start time
<span class="line-modified">104     static List&lt;RecordedEvent&gt; getRevocationEvents(Recording recording, String eventTypeName, String fieldName, Class&lt;?&gt; lockClass) throws Throwable {</span>
105         return Events.fromRecording(recording).stream()
<span class="line-added">106                 .filter(e -&gt; e.getEventType().getName().equals(eventTypeName))</span>
107                 .filter(e -&gt; ((RecordedClass)e.getValue(fieldName)).getName().equals(lockClass.getName()))
108                 .sorted(Comparator.comparing(RecordedEvent::getStartTime))
109                 .collect(Collectors.toList());
110     }
111 
112     static void testSingleRevocation() throws Throwable {
113         class MyLock {};
114 
115         Recording recording = new Recording();
116 
117         recording.enable(EventNames.BiasedLockRevocation);
118         recording.start();
119 
120         Thread biasBreaker = triggerRevocation(1, MyLock.class);
121 
122         recording.stop();
<span class="line-modified">123         List&lt;RecordedEvent&gt; events = getRevocationEvents(recording, EventNames.BiasedLockRevocation, &quot;lockClass&quot;, MyLock.class);</span>
124         Asserts.assertEQ(events.size(), 1);
125 
126         RecordedEvent event = events.get(0);
127         Events.assertEventThread(event, biasBreaker);
128         Events.assertEventThread(event, &quot;previousOwner&quot;, Thread.currentThread());
129 
130         RecordedClass lockClass = event.getValue(&quot;lockClass&quot;);
131         Asserts.assertEquals(lockClass.getName(), MyLock.class.getName());
132 
133         validateStackTrace(event.getStackTrace());
134     }
135 
136     static void testBulkRevocation() throws Throwable {
137         class MyLock {};
138 
139         Recording recording = new Recording();
140 
141         recording.enable(EventNames.BiasedLockClassRevocation);
142         recording.start();
143 
144         Thread biasBreaker = triggerRevocation(BULK_REVOKE_THRESHOLD, MyLock.class);
145 
146         recording.stop();
<span class="line-modified">147         List&lt;RecordedEvent&gt; events = getRevocationEvents(recording, EventNames.BiasedLockClassRevocation, &quot;revokedClass&quot;, MyLock.class);</span>
148         Asserts.assertEQ(events.size(), 1);
149 
150         RecordedEvent event = events.get(0);
151         Events.assertEventThread(event, biasBreaker);
152         Events.assertField(event, &quot;disableBiasing&quot;).equal(false);
153 
154         RecordedClass lockClass = event.getValue(&quot;revokedClass&quot;);
155         Asserts.assertEquals(lockClass.getName(), MyLock.class.getName());
156 
157         validateStackTrace(event.getStackTrace());
158     }
159 
160     static void testSelfRevocation() throws Throwable {
161         class MyLock {};
162 
163         Recording recording = new Recording();
164 
165         recording.enable(EventNames.BiasedLockSelfRevocation);
166         recording.start();
167 
168         MyLock l = new MyLock();
169         touch(l);
170         Thread.holdsLock(l);
171 
172         recording.stop();
<span class="line-modified">173         List&lt;RecordedEvent&gt; events = getRevocationEvents(recording, EventNames.BiasedLockSelfRevocation, &quot;lockClass&quot;, MyLock.class);</span>
174         Asserts.assertEQ(events.size(), 1);
175 
176         RecordedEvent event = events.get(0);
177         Events.assertEventThread(event, Thread.currentThread());
178 
179         validateStackTrace(event.getStackTrace(), &quot;holdsLock&quot;);
180     }
181 
182     static void testExitedThreadRevocation() throws Throwable {
183         class MyLock {};
184 
185         Recording recording = new Recording();
186 
187         recording.enable(EventNames.BiasedLockRevocation);
188         recording.start();
189 
190         FutureTask&lt;MyLock&gt; lockerTask = new FutureTask&lt;&gt;(() -&gt; {
191            MyLock l = new MyLock();
192            touch(l);
193            return l;
</pre>
<hr />
<pre>
195 
196         Thread locker = new Thread(lockerTask, &quot;BiasLocker&quot;);
197         locker.start();
198         locker.join();
199 
200         // Even after joining, the VM has a bit more work to do before the thread is actually removed
201         // from the threads list. Ensure that this has happened before proceeding.
202         while (true) {
203             PidJcmdExecutor jcmd = new PidJcmdExecutor();
204             OutputAnalyzer oa = jcmd.execute(&quot;Thread.print&quot;, true);
205             String lockerThreadFound = oa.firstMatch(&quot;BiasLocker&quot;);
206             if (lockerThreadFound == null) {
207                 break;
208             }
209         };
210 
211         MyLock l = lockerTask.get();
212         touch(l);
213 
214         recording.stop();
<span class="line-modified">215         List&lt;RecordedEvent&gt; events = getRevocationEvents(recording, EventNames.BiasedLockRevocation, &quot;lockClass&quot;, MyLock.class);</span>
216         Asserts.assertEQ(events.size(), 1);
217 
218         RecordedEvent event = events.get(0);
219         Events.assertEventThread(event, Thread.currentThread());
220         // Previous owner will usually be null, but can also be a thread that
221         // was created after the BiasLocker thread exited due to address reuse.
222         RecordedThread prevOwner = event.getValue(&quot;previousOwner&quot;);
223         if (prevOwner != null) {
224             Asserts.assertNE(prevOwner.getJavaName(), &quot;BiasLocker&quot;);
225         }
226         validateStackTrace(event.getStackTrace());
227     }
228 
229     static void testBulkRevocationNoRebias() throws Throwable {
230         class MyLock {};
231 
232         Recording recording = new Recording();
233 
234         recording.enable(EventNames.BiasedLockClassRevocation);
235         recording.start();
236 
237         Thread biasBreaker0 = triggerRevocation(BULK_REVOKE_THRESHOLD, MyLock.class);
238         Thread biasBreaker1 = triggerRevocation(BULK_REVOKE_THRESHOLD, MyLock.class);
239 
240         recording.stop();
<span class="line-modified">241         List&lt;RecordedEvent&gt; events = getRevocationEvents(recording, EventNames.BiasedLockClassRevocation, &quot;revokedClass&quot;, MyLock.class);</span>
242         Asserts.assertEQ(events.size(), 2);
243 
244         // The rebias event should occur before the noRebias one
245         RecordedEvent eventRebias = events.get(0);
246         RecordedEvent eventNoRebias = events.get(1);
247 
248         Events.assertEventThread(eventRebias, biasBreaker0);
249         Events.assertField(eventRebias, &quot;disableBiasing&quot;).equal(false);
250 
251         Events.assertEventThread(eventNoRebias, biasBreaker1);
252         Events.assertField(eventNoRebias, &quot;disableBiasing&quot;).equal(true);
253 
254         RecordedClass lockClassRebias = eventRebias.getValue(&quot;revokedClass&quot;);
255         Asserts.assertEquals(lockClassRebias.getName(), MyLock.class.getName());
256         RecordedClass lockClassNoRebias = eventNoRebias.getValue(&quot;revokedClass&quot;);
257         Asserts.assertEquals(lockClassNoRebias.getName(), MyLock.class.getName());
258 
259         validateStackTrace(eventRebias.getStackTrace());
260         validateStackTrace(eventNoRebias.getStackTrace());
261     }
262 
263     static void testRevocationSafepointIdCorrelation() throws Throwable {
264         class MyLock {};
265 
266         Recording recording = new Recording();
267 

268         recording.enable(EventNames.BiasedLockClassRevocation);
269         recording.enable(EventNames.ExecuteVMOperation);
270         recording.start();
271 
272         triggerRevocation(BULK_REVOKE_THRESHOLD, MyLock.class);
273 
274         recording.stop();
275         List&lt;RecordedEvent&gt; events = Events.fromRecording(recording);
276 
<span class="line-modified">277         // Determine which safepoints included bulk revocation VM operations</span>

278         Set&lt;Long&gt; vmOperationsBulk = new HashSet&lt;&gt;();
279 
280         for (RecordedEvent event : events) {
281             if (event.getEventType().getName().equals(EventNames.ExecuteVMOperation)) {
282                 String operation = event.getValue(&quot;operation&quot;);
283                 Long safepointId = event.getValue(&quot;safepointId&quot;);
284 
<span class="line-modified">285                 if (operation.equals(&quot;BulkRevokeBias&quot;)) {</span>


286                     vmOperationsBulk.add(safepointId);
287                 }
288             }
289         }
290 

291         int bulkRevokeCount = 0;
292 
293         // Match all revoke events to a corresponding VMOperation event
294         for (RecordedEvent event : events) {
<span class="line-modified">295             if (event.getEventType().getName().equals(EventNames.BiasedLockClassRevocation)) {</span>







296                 Long safepointId = event.getValue(&quot;safepointId&quot;);
297                 String lockClass = ((RecordedClass)event.getValue(&quot;revokedClass&quot;)).getName();
298                 if (lockClass.toString().equals(MyLock.class.getName())) {
299                     Asserts.assertTrue(vmOperationsBulk.contains(safepointId));
300                     bulkRevokeCount++;
301                 }
302             }
303         }
304 
305         Asserts.assertGT(bulkRevokeCount, 0);

306     }
307 }
</pre>
</td>
</tr>
</table>
<center><a href="../os/TestInitialEnvironmentVariable.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="TestClassLoadingStatisticsEvent.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
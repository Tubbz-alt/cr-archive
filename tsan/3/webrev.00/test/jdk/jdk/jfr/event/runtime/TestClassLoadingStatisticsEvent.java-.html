<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old test/jdk/jdk/jfr/event/runtime/TestClassLoadingStatisticsEvent.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2013, 2018, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package jdk.jfr.event.runtime;
 27 
 28 import java.util.List;
 29 
 30 import jdk.jfr.Recording;
 31 import jdk.jfr.consumer.RecordedEvent;
 32 import jdk.test.lib.Asserts;
 33 import jdk.test.lib.jfr.EventNames;
 34 import jdk.test.lib.jfr.Events;
 35 import jdk.test.lib.jfr.TestClassLoader;
 36 
 37 /**
 38  * @test
 39  * @key jfr
 40  * @requires vm.hasJFR
 41  * @library /test/lib /test/jdk
 42  * @build jdk.jfr.event.runtime.TestClasses
 43  * @run main/othervm jdk.jfr.event.runtime.TestClassLoadingStatisticsEvent
 44  */
 45 /**
 46  * This test will load a number of classes. After each load step we verify that
 47  * the loadedClassCount and unloadedClassCount attributes are correct.
 48  *
 49  * System.gc() will trigger class unloading if -XX:+ExplicitGCInvokesConcurrent
 50  * is NOT set. If this flag is set G1 will never unload classes on System.gc()
 51  * and CMS will not guarantee that all semantically dead classes will be
 52  * unloaded. As far as the &quot;jfr&quot; key guarantees no VM flags are set from the
 53  * outside it should be enough with System.gc().
 54  */
 55 public class TestClassLoadingStatisticsEvent {
 56 
 57     private final static String EVENT_PATH = EventNames.ClassLoadingStatistics;
 58     private final static String TESTCLASS_PUBLIC_STATIC =
 59                 &quot;jdk.jfr.event.runtime.TestClasses$TestClassPublicStatic&quot;;
 60     private final static String TESTCLASS_PUBLIC_STATIC_INNER =
 61                 &quot;jdk.jfr.event.runtime.TestClasses$TestClassPublicStatic$TestClassPublicStaticInner&quot;;
 62 
 63     // Declare unloadableClassLoader as &quot;public static&quot;
 64     // to prevent the compiler to optimize away all unread writes
 65     public static TestClassLoader unloadableClassLoader;
 66 
 67     public static void main(String[] args) throws Throwable {
 68         // Load twice to get more stable result.
 69         RecordedEvent event = getCurrentEvent();
 70         event = getCurrentEvent();
 71 
 72         // Declare class ClassLoadingStatisticsHelper.
 73         TestClasses[] helpers = new TestClasses[10];
 74         event = verifyCountDelta(event, 1, 0);
 75 
 76         // Should load classes TestClassPrivate and TestClassPrivateStatic.
 77         for (int c = 0; c &lt; helpers.length; c++) {
 78             helpers[c] = new TestClasses();
 79         }
 80         event = verifyCountDelta(event, 2, 0);
 81 
 82         // Load classes TestClassProtected and B2.
 83         helpers[0].new TestClassProtected();
 84         helpers[1].new TestClassProtected(); // This class is already loaded.
 85         new TestClasses.TestClassProtectedStatic();
 86         event = verifyCountDelta(event, 2, 0);
 87 
 88         // Load classes TestClassProtected1 and TestClassProtectedStatic1.
 89         for (int c = 0; c &lt; helpers.length; c++) {
 90             helpers[c].loadClasses();
 91         }
 92         event = verifyCountDelta(event, 2, 0);
 93 
 94         // Load the classes with separate class loader. Will be unloaded later.
 95         unloadableClassLoader = new TestClassLoader();
 96 
 97         unloadableClassLoader.loadClass(TESTCLASS_PUBLIC_STATIC_INNER);
 98         event = verifyCountDelta(event, 1, 0);
 99 
100         unloadableClassLoader.loadClass(TESTCLASS_PUBLIC_STATIC);
101         event = verifyCountDelta(event, 1, 0);
102 
103         // This System.gc() should not unload classes, since the
104         // unloadableClassLoader object is still active.
105         System.gc();
106         event = verifyCountDelta(event, 0, 0);
107 
108         // make classes are unloaded.
109         unloadableClassLoader = null;
110         System.gc();
111         event = verifyCountDelta(event, 0, 2);
112     }
113 
114     private static RecordedEvent getCurrentEvent() throws Throwable {
115         Recording recording = new Recording();
116         recording.enable(EVENT_PATH);
117         recording.start();
118         recording.stop();
119         List&lt;RecordedEvent&gt; events = Events.fromRecording(recording);
120         Asserts.assertFalse(events.isEmpty(), &quot;No events in recording&quot;);
121         RecordedEvent event = events.get(0);
122         return event;
123     }
124 
125     private static RecordedEvent verifyCountDelta(
126         RecordedEvent prevEvent, int loadDelta, int unloadDelta) throws Throwable {
127         RecordedEvent currEvent = null;
128         try {
129             long prevLoad = Events.assertField(prevEvent, &quot;loadedClassCount&quot;).getValue();
130             long prevUnload = Events.assertField(prevEvent, &quot;unloadedClassCount&quot;).getValue();
131 
132             currEvent = getCurrentEvent();
133             Events.assertField(currEvent, &quot;loadedClassCount&quot;).atLeast(prevLoad + loadDelta);
134             Events.assertField(currEvent, &quot;unloadedClassCount&quot;).atLeast(prevUnload + unloadDelta);
135             return currEvent;
136         } catch (Throwable t) {
137             System.out.println(&quot;verifyCountDelta failed. prevEvent=&quot; + prevEvent + &quot;, currEvent=&quot; + currEvent);
138             throw t;
139         }
140     }
141 
142 }
    </pre>
  </body>
</html>
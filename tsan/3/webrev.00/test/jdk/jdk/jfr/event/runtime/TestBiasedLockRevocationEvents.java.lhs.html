<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames test/jdk/jdk/jfr/event/runtime/TestBiasedLockRevocationEvents.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
<a name="1" id="anc1"></a><span class="line-modified">  2  * Copyright (c) 2017, 2018, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package jdk.jfr.event.runtime;
 27 
 28 import jdk.jfr.Recording;
 29 import jdk.jfr.consumer.*;
 30 import jdk.test.lib.Asserts;
 31 import jdk.test.lib.dcmd.PidJcmdExecutor;
 32 import jdk.test.lib.jfr.EventNames;
 33 import jdk.test.lib.jfr.Events;
 34 import jdk.test.lib.process.OutputAnalyzer;
 35 
 36 import java.util.*;
 37 import java.util.concurrent.FutureTask;
 38 import java.util.stream.Collectors;
 39 
 40 /**
 41  * @test
 42  * @key jfr
 43  * @requires vm.hasJFR
 44  * @library /test/lib
 45  *
<a name="2" id="anc2"></a><span class="line-modified"> 46  * @run main/othervm jdk.jfr.event.runtime.TestBiasedLockRevocationEvents</span>
 47  */
 48 public class TestBiasedLockRevocationEvents {
 49 
 50     public static void main(String[] args) throws Throwable {
 51         testSingleRevocation();
 52         testBulkRevocation();
 53         testSelfRevocation();
 54         testExitedThreadRevocation();
 55         testBulkRevocationNoRebias();
 56         testRevocationSafepointIdCorrelation();
 57     }
 58 
 59     // Default value of BiasedLockingBulkRebiasThreshold is 20, and BiasedLockingBulkRevokeTreshold is 40.
 60     // Using a value that will hit the first threshold once, and the second one the next time.
 61     private static final int BULK_REVOKE_THRESHOLD = 25;
 62 
 63     static void touch(Object lock) {
 64         synchronized(lock) {
 65         }
 66     }
 67 
 68     static Thread triggerRevocation(int numRevokes, Class&lt;?&gt; lockClass) throws Throwable {
 69         Object[] locks = new Object[numRevokes];
 70         for (int i = 0; i &lt; locks.length; ++i) {
 71             locks[i] = lockClass.getDeclaredConstructor().newInstance();
 72             touch(locks[i]);
 73         }
 74 
 75         Thread biasBreaker = new Thread(&quot;BiasBreaker&quot;) {
 76             @Override
 77             public void run() {
 78                 for (Object lock : locks) {
 79                     touch(lock);
 80                 }
 81             }
 82         };
 83 
 84         biasBreaker.start();
 85         biasBreaker.join();
 86 
 87         return biasBreaker;
 88     }
 89 
 90     // Basic stack trace validation, checking the name of the leaf method
 91     static void validateStackTrace(RecordedStackTrace stackTrace, String leafMethodName) {
 92         List&lt;RecordedFrame&gt; frames = stackTrace.getFrames();
 93         Asserts.assertFalse(frames.isEmpty());
 94         String name = frames.get(0).getMethod().getName();
 95         Asserts.assertEquals(name, leafMethodName);
 96     }
 97 
 98     // Validates that the given stack trace refers to lock.touch(); in triggerRevocation
 99     static void validateStackTrace(RecordedStackTrace stackTrace) {
100         validateStackTrace(stackTrace, &quot;touch&quot;);
101     }
102 
103     // Retrieve all biased lock revocation events related to the provided lock class, sorted by start time
<a name="3" id="anc3"></a><span class="line-modified">104     static List&lt;RecordedEvent&gt; getRevocationEvents(Recording recording, String fieldName, Class&lt;?&gt; lockClass) throws Throwable {</span>
105         return Events.fromRecording(recording).stream()
<a name="4" id="anc4"></a>
106                 .filter(e -&gt; ((RecordedClass)e.getValue(fieldName)).getName().equals(lockClass.getName()))
107                 .sorted(Comparator.comparing(RecordedEvent::getStartTime))
108                 .collect(Collectors.toList());
109     }
110 
111     static void testSingleRevocation() throws Throwable {
112         class MyLock {};
113 
114         Recording recording = new Recording();
115 
116         recording.enable(EventNames.BiasedLockRevocation);
117         recording.start();
118 
119         Thread biasBreaker = triggerRevocation(1, MyLock.class);
120 
121         recording.stop();
<a name="5" id="anc5"></a><span class="line-modified">122         List&lt;RecordedEvent&gt; events = getRevocationEvents(recording, &quot;lockClass&quot;, MyLock.class);</span>
123         Asserts.assertEQ(events.size(), 1);
124 
125         RecordedEvent event = events.get(0);
126         Events.assertEventThread(event, biasBreaker);
127         Events.assertEventThread(event, &quot;previousOwner&quot;, Thread.currentThread());
128 
129         RecordedClass lockClass = event.getValue(&quot;lockClass&quot;);
130         Asserts.assertEquals(lockClass.getName(), MyLock.class.getName());
131 
132         validateStackTrace(event.getStackTrace());
133     }
134 
135     static void testBulkRevocation() throws Throwable {
136         class MyLock {};
137 
138         Recording recording = new Recording();
139 
140         recording.enable(EventNames.BiasedLockClassRevocation);
141         recording.start();
142 
143         Thread biasBreaker = triggerRevocation(BULK_REVOKE_THRESHOLD, MyLock.class);
144 
145         recording.stop();
<a name="6" id="anc6"></a><span class="line-modified">146         List&lt;RecordedEvent&gt; events = getRevocationEvents(recording, &quot;revokedClass&quot;, MyLock.class);</span>
147         Asserts.assertEQ(events.size(), 1);
148 
149         RecordedEvent event = events.get(0);
150         Events.assertEventThread(event, biasBreaker);
151         Events.assertField(event, &quot;disableBiasing&quot;).equal(false);
152 
153         RecordedClass lockClass = event.getValue(&quot;revokedClass&quot;);
154         Asserts.assertEquals(lockClass.getName(), MyLock.class.getName());
155 
156         validateStackTrace(event.getStackTrace());
157     }
158 
159     static void testSelfRevocation() throws Throwable {
160         class MyLock {};
161 
162         Recording recording = new Recording();
163 
164         recording.enable(EventNames.BiasedLockSelfRevocation);
165         recording.start();
166 
167         MyLock l = new MyLock();
168         touch(l);
169         Thread.holdsLock(l);
170 
171         recording.stop();
<a name="7" id="anc7"></a><span class="line-modified">172         List&lt;RecordedEvent&gt; events = getRevocationEvents(recording, &quot;lockClass&quot;, MyLock.class);</span>
173         Asserts.assertEQ(events.size(), 1);
174 
175         RecordedEvent event = events.get(0);
176         Events.assertEventThread(event, Thread.currentThread());
177 
178         validateStackTrace(event.getStackTrace(), &quot;holdsLock&quot;);
179     }
180 
181     static void testExitedThreadRevocation() throws Throwable {
182         class MyLock {};
183 
184         Recording recording = new Recording();
185 
186         recording.enable(EventNames.BiasedLockRevocation);
187         recording.start();
188 
189         FutureTask&lt;MyLock&gt; lockerTask = new FutureTask&lt;&gt;(() -&gt; {
190            MyLock l = new MyLock();
191            touch(l);
192            return l;
193         });
194 
195         Thread locker = new Thread(lockerTask, &quot;BiasLocker&quot;);
196         locker.start();
197         locker.join();
198 
199         // Even after joining, the VM has a bit more work to do before the thread is actually removed
200         // from the threads list. Ensure that this has happened before proceeding.
201         while (true) {
202             PidJcmdExecutor jcmd = new PidJcmdExecutor();
203             OutputAnalyzer oa = jcmd.execute(&quot;Thread.print&quot;, true);
204             String lockerThreadFound = oa.firstMatch(&quot;BiasLocker&quot;);
205             if (lockerThreadFound == null) {
206                 break;
207             }
208         };
209 
210         MyLock l = lockerTask.get();
211         touch(l);
212 
213         recording.stop();
<a name="8" id="anc8"></a><span class="line-modified">214         List&lt;RecordedEvent&gt; events = getRevocationEvents(recording, &quot;lockClass&quot;, MyLock.class);</span>
215         Asserts.assertEQ(events.size(), 1);
216 
217         RecordedEvent event = events.get(0);
218         Events.assertEventThread(event, Thread.currentThread());
219         // Previous owner will usually be null, but can also be a thread that
220         // was created after the BiasLocker thread exited due to address reuse.
221         RecordedThread prevOwner = event.getValue(&quot;previousOwner&quot;);
222         if (prevOwner != null) {
223             Asserts.assertNE(prevOwner.getJavaName(), &quot;BiasLocker&quot;);
224         }
225         validateStackTrace(event.getStackTrace());
226     }
227 
228     static void testBulkRevocationNoRebias() throws Throwable {
229         class MyLock {};
230 
231         Recording recording = new Recording();
232 
233         recording.enable(EventNames.BiasedLockClassRevocation);
234         recording.start();
235 
236         Thread biasBreaker0 = triggerRevocation(BULK_REVOKE_THRESHOLD, MyLock.class);
237         Thread biasBreaker1 = triggerRevocation(BULK_REVOKE_THRESHOLD, MyLock.class);
238 
239         recording.stop();
<a name="9" id="anc9"></a><span class="line-modified">240         List&lt;RecordedEvent&gt; events = getRevocationEvents(recording, &quot;revokedClass&quot;, MyLock.class);</span>
241         Asserts.assertEQ(events.size(), 2);
242 
243         // The rebias event should occur before the noRebias one
244         RecordedEvent eventRebias = events.get(0);
245         RecordedEvent eventNoRebias = events.get(1);
246 
247         Events.assertEventThread(eventRebias, biasBreaker0);
248         Events.assertField(eventRebias, &quot;disableBiasing&quot;).equal(false);
249 
250         Events.assertEventThread(eventNoRebias, biasBreaker1);
251         Events.assertField(eventNoRebias, &quot;disableBiasing&quot;).equal(true);
252 
253         RecordedClass lockClassRebias = eventRebias.getValue(&quot;revokedClass&quot;);
254         Asserts.assertEquals(lockClassRebias.getName(), MyLock.class.getName());
255         RecordedClass lockClassNoRebias = eventNoRebias.getValue(&quot;revokedClass&quot;);
256         Asserts.assertEquals(lockClassNoRebias.getName(), MyLock.class.getName());
257 
258         validateStackTrace(eventRebias.getStackTrace());
259         validateStackTrace(eventNoRebias.getStackTrace());
260     }
261 
262     static void testRevocationSafepointIdCorrelation() throws Throwable {
263         class MyLock {};
264 
265         Recording recording = new Recording();
266 
<a name="10" id="anc10"></a><span class="line-removed">267         recording.enable(EventNames.BiasedLockRevocation);</span>
268         recording.enable(EventNames.BiasedLockClassRevocation);
269         recording.enable(EventNames.ExecuteVMOperation);
270         recording.start();
271 
272         triggerRevocation(BULK_REVOKE_THRESHOLD, MyLock.class);
273 
274         recording.stop();
275         List&lt;RecordedEvent&gt; events = Events.fromRecording(recording);
276 
<a name="11" id="anc11"></a><span class="line-modified">277         // Determine which safepoints included single and bulk revocation VM operations</span>
<span class="line-removed">278         Set&lt;Long&gt; vmOperationsSingle = new HashSet&lt;&gt;();</span>
279         Set&lt;Long&gt; vmOperationsBulk = new HashSet&lt;&gt;();
280 
281         for (RecordedEvent event : events) {
282             if (event.getEventType().getName().equals(EventNames.ExecuteVMOperation)) {
283                 String operation = event.getValue(&quot;operation&quot;);
284                 Long safepointId = event.getValue(&quot;safepointId&quot;);
285 
<a name="12" id="anc12"></a><span class="line-modified">286                 if (operation.equals(&quot;RevokeBias&quot;)) {</span>
<span class="line-removed">287                     vmOperationsSingle.add(safepointId);</span>
<span class="line-removed">288                 } else if (operation.equals(&quot;BulkRevokeBias&quot;)) {</span>
289                     vmOperationsBulk.add(safepointId);
290                 }
291             }
292         }
293 
<a name="13" id="anc13"></a><span class="line-removed">294         int revokeCount = 0;</span>
295         int bulkRevokeCount = 0;
296 
297         // Match all revoke events to a corresponding VMOperation event
298         for (RecordedEvent event : events) {
<a name="14" id="anc14"></a><span class="line-modified">299             if (event.getEventType().getName().equals(EventNames.BiasedLockRevocation)) {</span>
<span class="line-removed">300                 Long safepointId = event.getValue(&quot;safepointId&quot;);</span>
<span class="line-removed">301                 String lockClass = ((RecordedClass)event.getValue(&quot;lockClass&quot;)).getName();</span>
<span class="line-removed">302                 if (lockClass.equals(MyLock.class.getName())) {</span>
<span class="line-removed">303                     Asserts.assertTrue(vmOperationsSingle.contains(safepointId));</span>
<span class="line-removed">304                     revokeCount++;</span>
<span class="line-removed">305                 }</span>
<span class="line-removed">306             } else if (event.getEventType().getName().equals(EventNames.BiasedLockClassRevocation)) {</span>
307                 Long safepointId = event.getValue(&quot;safepointId&quot;);
308                 String lockClass = ((RecordedClass)event.getValue(&quot;revokedClass&quot;)).getName();
309                 if (lockClass.toString().equals(MyLock.class.getName())) {
310                     Asserts.assertTrue(vmOperationsBulk.contains(safepointId));
311                     bulkRevokeCount++;
312                 }
313             }
314         }
315 
316         Asserts.assertGT(bulkRevokeCount, 0);
<a name="15" id="anc15"></a><span class="line-removed">317         Asserts.assertGT(revokeCount, bulkRevokeCount);</span>
318     }
319 }
<a name="16" id="anc16"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="16" type="hidden" />
</body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames test/jdk/jdk/jfr/event/gc/collection/TestG1ParallelPhases.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
<a name="1" id="anc1"></a><span class="line-modified">  2  * Copyright (c) 2018, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package jdk.jfr.event.gc.collection;
 27 
 28 import static java.lang.System.gc;
 29 import static java.lang.Thread.sleep;
 30 import static java.util.Set.of;
 31 import static java.util.stream.Collectors.joining;
 32 import static java.util.stream.Collectors.toList;
 33 import static java.util.stream.Collectors.toSet;
 34 import static java.util.stream.IntStream.range;
<a name="2" id="anc2"></a><span class="line-removed"> 35 import static jdk.jfr.event.gc.collection.Provoker.provokeMixedGC;</span>
 36 import static jdk.test.lib.Asserts.assertEquals;
 37 import static jdk.test.lib.Asserts.assertTrue;
 38 import static jdk.test.lib.jfr.Events.fromRecording;
 39 import static sun.hotspot.WhiteBox.getWhiteBox;
 40 
 41 import java.io.IOException;
 42 import java.lang.ref.WeakReference;
 43 import java.math.BigDecimal;
 44 import java.util.ArrayList;
 45 import java.util.Collection;
 46 import java.util.List;
 47 import java.util.Set;
 48 
<a name="3" id="anc3"></a>
 49 import jdk.jfr.Recording;
 50 import jdk.test.lib.Asserts;
 51 import jdk.test.lib.jfr.EventNames;
 52 import sun.hotspot.WhiteBox;
 53 
 54 /**
 55  * @test
 56  * @key jfr
 57  * @requires vm.hasJFR
 58  * @requires vm.gc == &quot;G1&quot; | vm.gc == null
<a name="4" id="anc4"></a><span class="line-modified"> 59  * @library /test/lib /test/jdk</span>
 60  * @build sun.hotspot.WhiteBox
 61  * @run main ClassFileInstaller sun.hotspot.WhiteBox
<a name="5" id="anc5"></a><span class="line-modified"> 62  * @run main/othervm -XX:+UnlockExperimentalVMOptions -XX:MaxTenuringThreshold=1 -Xms20M -Xmx20M</span>

 63  *      -XX:G1MixedGCLiveThresholdPercent=100 -XX:G1HeapWastePercent=0 -XX:G1HeapRegionSize=1m
 64  *      -XX:+UseG1GC -XX:+UseStringDeduplication
 65  *      -Xbootclasspath/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI
 66  *      jdk.jfr.event.gc.collection.TestG1ParallelPhases
 67  */
 68 
 69 public class TestG1ParallelPhases {
 70     public static List&lt;WeakReference&lt;byte[]&gt;&gt; weakRefs;
 71 
 72     public static void main(String[] args) throws IOException {
 73         Recording recording = new Recording();
 74         recording.enable(EventNames.GCPhaseParallel);
 75         recording.start();
 76 
 77         // create more weak garbage than can fit in this heap (-Xmx20m), will force collection of weak references
<a name="6" id="anc6"></a><span class="line-modified"> 78         weakRefs = range(1, 100)</span>
 79             .mapToObj(n -&gt; new WeakReference&lt;&gt;(new byte[1_000_000]))
 80             .collect(toList()); // force evaluation of lazy stream (all weak refs must be created)
 81 
 82         final var MEG = 1024 * 1024;
<a name="7" id="anc7"></a><span class="line-modified"> 83         provokeMixedGC(1 * MEG);</span>
 84         recording.stop();
 85 
 86         Set&lt;String&gt; usedPhases = fromRecording(recording).stream()
 87             .map(e -&gt; e.getValue(&quot;name&quot;).toString())
 88             .collect(toSet());
 89 
 90         Set&lt;String&gt; allPhases = of(
 91             &quot;ExtRootScan&quot;,
 92             &quot;ThreadRoots&quot;,
 93             &quot;UniverseRoots&quot;,
 94             &quot;JNIRoots&quot;,
 95             &quot;ObjectSynchronizerRoots&quot;,
 96             &quot;ManagementRoots&quot;,
 97             &quot;SystemDictionaryRoots&quot;,
 98             &quot;CLDGRoots&quot;,
 99             &quot;JVMTIRoots&quot;,
100             &quot;CMRefRoots&quot;,
<a name="8" id="anc8"></a><span class="line-modified">101             &quot;WaitForStrongCLD&quot;,</span>
<span class="line-modified">102             &quot;WeakCLDRoots&quot;,</span>
<span class="line-modified">103             &quot;SATBFiltering&quot;,</span>
<span class="line-modified">104             &quot;UpdateRS&quot;,</span>
<span class="line-modified">105             &quot;ScanHCC&quot;,</span>
<span class="line-removed">106             &quot;ScanRS&quot;,</span>
107             &quot;CodeRoots&quot;,
108             &quot;ObjCopy&quot;,
109             &quot;Termination&quot;,
110             &quot;StringDedupQueueFixup&quot;,
111             &quot;StringDedupTableFixup&quot;,
112             &quot;RedirtyCards&quot;,
<a name="9" id="anc9"></a><span class="line-modified">113        //     &quot;PreserveCMReferents&quot;,</span>
114             &quot;NonYoungFreeCSet&quot;,
<a name="10" id="anc10"></a><span class="line-modified">115             &quot;YoungFreeCSet&quot;</span>

116         );
117 
<a name="11" id="anc11"></a>









118         assertTrue(usedPhases.equals(allPhases), &quot;Compare events expected and received&quot;
119             + &quot;, Not found phases: &quot; + allPhases.stream().filter(p -&gt; !usedPhases.contains(p)).collect(joining(&quot;, &quot;))
120             + &quot;, Not expected phases: &quot; + usedPhases.stream().filter(p -&gt; !allPhases.contains(p)).collect(joining(&quot;, &quot;)));
121     }
122 }
<a name="12" id="anc12"></a><span class="line-removed">123 </span>
<span class="line-removed">124 /**</span>
<span class="line-removed">125  * Utility class to guarantee a mixed GC. The class allocates several arrays and</span>
<span class="line-removed">126  * promotes them to the oldgen. After that it tries to provoke mixed GC by</span>
<span class="line-removed">127  * allocating new objects.</span>
<span class="line-removed">128  */</span>
<span class="line-removed">129 class Provoker {</span>
<span class="line-removed">130     private static void allocateOldObjects(</span>
<span class="line-removed">131             List&lt;byte[]&gt; liveOldObjects,</span>
<span class="line-removed">132             int g1HeapRegionSize,</span>
<span class="line-removed">133             int arraySize) {</span>
<span class="line-removed">134 </span>
<span class="line-removed">135         var toUnreachable = new ArrayList&lt;byte[]&gt;();</span>
<span class="line-removed">136 </span>
<span class="line-removed">137         // Allocates buffer and promotes it to the old gen. Mix live and dead old objects.</span>
<span class="line-removed">138         // allocate about two regions of old memory. At least one full old region will guarantee</span>
<span class="line-removed">139         // mixed collection in the future</span>
<span class="line-removed">140         range(0, g1HeapRegionSize/arraySize).forEach(n -&gt; {</span>
<span class="line-removed">141             liveOldObjects.add(new byte[arraySize]);</span>
<span class="line-removed">142             toUnreachable.add(new byte[arraySize]);</span>
<span class="line-removed">143         });</span>
<span class="line-removed">144 </span>
<span class="line-removed">145         // Do two young collections, MaxTenuringThreshold=1 will force promotion.</span>
<span class="line-removed">146         getWhiteBox().youngGC();</span>
<span class="line-removed">147         getWhiteBox().youngGC();</span>
<span class="line-removed">148 </span>
<span class="line-removed">149         // Check it is promoted &amp; keep alive</span>
<span class="line-removed">150         Asserts.assertTrue(getWhiteBox().isObjectInOldGen(liveOldObjects), &quot;List of the objects is suppose to be in OldGen&quot;);</span>
<span class="line-removed">151         Asserts.assertTrue(getWhiteBox().isObjectInOldGen(toUnreachable), &quot;List of the objects is suppose to be in OldGen&quot;);</span>
<span class="line-removed">152     }</span>
<span class="line-removed">153 </span>
<span class="line-removed">154     private static void waitTillCMCFinished(int sleepTime) {</span>
<span class="line-removed">155         while (getWhiteBox().g1InConcurrentMark()) {</span>
<span class="line-removed">156               try {sleep(sleepTime);} catch (Exception e) {}</span>
<span class="line-removed">157         }</span>
<span class="line-removed">158     }</span>
<span class="line-removed">159 </span>
<span class="line-removed">160     /**</span>
<span class="line-removed">161     * The necessary condition for guaranteed mixed GC is running in VM with the following flags:</span>
<span class="line-removed">162     * -XX:+UnlockExperimentalVMOptions -XX:MaxTenuringThreshold=1 -Xms{HEAP_SIZE}M</span>
<span class="line-removed">163     * -Xmx{HEAP_SIZE}M -XX:G1MixedGCLiveThresholdPercent=100 -XX:G1HeapWastePercent=0</span>
<span class="line-removed">164     * -XX:G1HeapRegionSize={REGION_SIZE}m</span>
<span class="line-removed">165     *</span>
<span class="line-removed">166     * @param provokeSize The size to allocate to provoke the start of a mixed gc (half heap size?)</span>
<span class="line-removed">167     * @param g1HeapRegionSize The size of your regions in bytes</span>
<span class="line-removed">168     */</span>
<span class="line-removed">169     public static void provokeMixedGC(int g1HeapRegionSize) {</span>
<span class="line-removed">170         final var arraySize = 20_000;</span>
<span class="line-removed">171         var liveOldObjects = new ArrayList&lt;byte[]&gt;();</span>
<span class="line-removed">172         allocateOldObjects(liveOldObjects, g1HeapRegionSize, arraySize);</span>
<span class="line-removed">173         waitTillCMCFinished(10);</span>
<span class="line-removed">174         getWhiteBox().g1StartConcMarkCycle();</span>
<span class="line-removed">175         waitTillCMCFinished(10);</span>
<span class="line-removed">176         getWhiteBox().youngGC();</span>
<span class="line-removed">177         getWhiteBox().youngGC();</span>
<span class="line-removed">178 </span>
<span class="line-removed">179         // check that liveOldObjects still alive</span>
<span class="line-removed">180         assertTrue(getWhiteBox().isObjectInOldGen(liveOldObjects), &quot;List of the objects is suppose to be in OldGen&quot;);</span>
<span class="line-removed">181     }</span>
<span class="line-removed">182 }</span>
<a name="13" id="anc13"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="13" type="hidden" />
</body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff test/jdk/jdk/jfr/event/runtime/TestThreadCpuTimeEvent.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
<body>
<center><a href="TestShutdownEvent.java.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="TestVMInfoEvent.java.cdiff.html" target="_top">next &gt;</a></center>    <h2>test/jdk/jdk/jfr/event/runtime/TestThreadCpuTimeEvent.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 23,11 ***</span>
   * questions.
   */
  
  package jdk.jfr.event.runtime;
  
<span class="line-removed">- import com.sun.management.ThreadMXBean;</span>
  import jdk.jfr.Recording;
  import jdk.jfr.consumer.RecordedEvent;
  import jdk.jfr.consumer.RecordedThread;
  import jdk.test.lib.Asserts;
  import jdk.test.lib.jfr.EventNames;
<span class="line-new-header">--- 23,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 58,11 ***</span>
   */
  public class TestThreadCpuTimeEvent {
  
      public static void main(String[] args) throws Throwable {
          testSimple();
<span class="line-removed">-         testCompareWithMXBean();</span>
          testEventAtThreadExit();
      }
  
      private static final long eventPeriodMillis = 50;
      private static final String cpuConsumerThreadName = &quot;cpuConsumer&quot;;
<span class="line-new-header">--- 57,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 105,11 ***</span>
                      barrier.await();
                  }
              } catch (BrokenBarrierException e) {
                  // Another thread has been interrupted - wait for us to be interrupted as well
                  while (!interrupted()) {
<span class="line-modified">!                     yield();</span>
                  }
              } catch (InterruptedException e) {
                  // Normal way of stopping the thread
              }
          }
<span class="line-new-header">--- 103,11 ---</span>
                      barrier.await();
                  }
              } catch (BrokenBarrierException e) {
                  // Another thread has been interrupted - wait for us to be interrupted as well
                  while (!interrupted()) {
<span class="line-modified">!                     Thread.yield();</span>
                  }
              } catch (InterruptedException e) {
                  // Normal way of stopping the thread
              }
          }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 133,36 ***</span>
  
              Asserts.assertLessThan(systemLoad + userLoad, 1.01f / numCpus); // 100% + rounding errors
          }
      }
  
<span class="line-removed">-     static Duration getAccumulatedTime(List&lt;RecordedEvent&gt; events, String threadName, String fieldName) {</span>
<span class="line-removed">-         List&lt;RecordedEvent&gt; filteredEvents = events.stream()</span>
<span class="line-removed">-                 .filter(e -&gt; e.getThread().getJavaName().equals(threadName))</span>
<span class="line-removed">-                 .sorted(Comparator.comparing(RecordedEvent::getStartTime))</span>
<span class="line-removed">-                 .collect(Collectors.toList());</span>
<span class="line-removed">- </span>
<span class="line-removed">-         int numCpus = Runtime.getRuntime().availableProcessors();</span>
<span class="line-removed">-         Iterator&lt;RecordedEvent&gt; i = filteredEvents.iterator();</span>
<span class="line-removed">-         RecordedEvent cur = i.next();</span>
<span class="line-removed">-         Duration totalTime = Duration.ZERO;</span>
<span class="line-removed">-         while (i.hasNext()) {</span>
<span class="line-removed">-             RecordedEvent prev = cur;</span>
<span class="line-removed">-             cur = i.next();</span>
<span class="line-removed">- </span>
<span class="line-removed">-             Duration sampleTime = Duration.between(prev.getStartTime(), cur.getStartTime());</span>
<span class="line-removed">-             Float load = (Float)cur.getValue(fieldName);</span>
<span class="line-removed">- </span>
<span class="line-removed">-             // Adjust load to be thread-relative (fully loaded thread would give 100%)</span>
<span class="line-removed">-             Float totalLoadForThread = load * numCpus;</span>
<span class="line-removed">-             Duration threadTime = Duration.ofMillis((long) (sampleTime.toMillis() * totalLoadForThread));</span>
<span class="line-removed">-             totalTime = totalTime.plus(threadTime);</span>
<span class="line-removed">-         }</span>
<span class="line-removed">- </span>
<span class="line-removed">-         return totalTime;</span>
<span class="line-removed">-     }</span>
<span class="line-removed">- </span>
      static List&lt;RecordedEvent&gt; generateEvents(int minimumEventCount, CyclicBarrier barrier) throws Throwable {
          int retryCount = 0;
  
          while (true) {
              Recording recording = new Recording();
<span class="line-new-header">--- 131,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 207,43 ***</span>
  
          thread.interrupt();
          thread.join();
      }
  
<span class="line-removed">-     static void testCompareWithMXBean() throws Throwable {</span>
<span class="line-removed">-         Duration testRunTime = Duration.ofMillis(eventPeriodMillis * cpuConsumerRunFactor);</span>
<span class="line-removed">-         CyclicBarrier barrier = new CyclicBarrier(2);</span>
<span class="line-removed">-         CpuConsumingThread thread = new CpuConsumingThread(testRunTime, barrier);</span>
<span class="line-removed">-         thread.start();</span>
<span class="line-removed">- </span>
<span class="line-removed">-         List&lt;RecordedEvent&gt; beforeEvents = generateEvents(2, barrier);</span>
<span class="line-removed">-         verifyPerThreadInvariant(beforeEvents, cpuConsumerThreadName);</span>
<span class="line-removed">- </span>
<span class="line-removed">-         // Run a second single pass</span>
<span class="line-removed">-         barrier.await();</span>
<span class="line-removed">-         barrier.await();</span>
<span class="line-removed">- </span>
<span class="line-removed">-         ThreadMXBean bean = (ThreadMXBean) ManagementFactory.getThreadMXBean();</span>
<span class="line-removed">-         Duration cpuTime = Duration.ofNanos(bean.getThreadCpuTime(thread.getId()));</span>
<span class="line-removed">-         Duration userTime = Duration.ofNanos(bean.getThreadUserTime(thread.getId()));</span>
<span class="line-removed">- </span>
<span class="line-removed">-         // Check something that should hold even in the presence of unfortunate scheduling</span>
<span class="line-removed">-         Asserts.assertGreaterThanOrEqual(cpuTime.toMillis(), eventPeriodMillis);</span>
<span class="line-removed">-         Asserts.assertGreaterThanOrEqual(userTime.toMillis(), eventPeriodMillis);</span>
<span class="line-removed">- </span>
<span class="line-removed">-         Duration systemTimeBefore = getAccumulatedTime(beforeEvents, cpuConsumerThreadName, &quot;system&quot;);</span>
<span class="line-removed">-         Duration userTimeBefore = getAccumulatedTime(beforeEvents, cpuConsumerThreadName, &quot;user&quot;);</span>
<span class="line-removed">-         Duration cpuTimeBefore = userTimeBefore.plus(systemTimeBefore);</span>
<span class="line-removed">- </span>
<span class="line-removed">-         Asserts.assertLessThan(cpuTimeBefore, cpuTime);</span>
<span class="line-removed">-         Asserts.assertLessThan(userTimeBefore, userTime);</span>
<span class="line-removed">-         Asserts.assertGreaterThan(cpuTimeBefore, Duration.ZERO);</span>
<span class="line-removed">- </span>
<span class="line-removed">-         thread.interrupt();</span>
<span class="line-removed">-         thread.join();</span>
<span class="line-removed">-     }</span>
<span class="line-removed">- </span>
      static void testEventAtThreadExit() throws Throwable {
          Recording recording = new Recording();
  
          recording.enable(EventNames.ThreadCPULoad).withPeriod(Duration.ofHours(10));
          recording.start();
<span class="line-new-header">--- 179,10 ---</span>
</pre>
<center><a href="TestShutdownEvent.java.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="TestVMInfoEvent.java.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
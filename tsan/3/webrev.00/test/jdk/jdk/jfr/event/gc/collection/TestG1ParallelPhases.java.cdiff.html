<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff test/jdk/jdk/jfr/event/gc/collection/TestG1ParallelPhases.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
<body>
<center><a href="GCEventAll.java.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="TestGCCauseWithParallelOld.java.cdiff.html" target="_top">next &gt;</a></center>    <h2>test/jdk/jdk/jfr/event/gc/collection/TestG1ParallelPhases.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 1,7 ***</span>
  /*
<span class="line-modified">!  * Copyright (c) 2018, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.  Oracle designates this
<span class="line-new-header">--- 1,7 ---</span>
  /*
<span class="line-modified">!  * Copyright (c) 2018, 2020, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.  Oracle designates this
</pre>
<hr />
<pre>
<span class="line-old-header">*** 30,11 ***</span>
  import static java.util.Set.of;
  import static java.util.stream.Collectors.joining;
  import static java.util.stream.Collectors.toList;
  import static java.util.stream.Collectors.toSet;
  import static java.util.stream.IntStream.range;
<span class="line-removed">- import static jdk.jfr.event.gc.collection.Provoker.provokeMixedGC;</span>
  import static jdk.test.lib.Asserts.assertEquals;
  import static jdk.test.lib.Asserts.assertTrue;
  import static jdk.test.lib.jfr.Events.fromRecording;
  import static sun.hotspot.WhiteBox.getWhiteBox;
  
<span class="line-new-header">--- 30,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 44,24 ***</span>
  import java.util.ArrayList;
  import java.util.Collection;
  import java.util.List;
  import java.util.Set;
  
  import jdk.jfr.Recording;
  import jdk.test.lib.Asserts;
  import jdk.test.lib.jfr.EventNames;
  import sun.hotspot.WhiteBox;
  
  /**
   * @test
   * @key jfr
   * @requires vm.hasJFR
   * @requires vm.gc == &quot;G1&quot; | vm.gc == null
<span class="line-modified">!  * @library /test/lib /test/jdk</span>
   * @build sun.hotspot.WhiteBox
   * @run main ClassFileInstaller sun.hotspot.WhiteBox
<span class="line-modified">!  * @run main/othervm -XX:+UnlockExperimentalVMOptions -XX:MaxTenuringThreshold=1 -Xms20M -Xmx20M</span>
   *      -XX:G1MixedGCLiveThresholdPercent=100 -XX:G1HeapWastePercent=0 -XX:G1HeapRegionSize=1m
   *      -XX:+UseG1GC -XX:+UseStringDeduplication
   *      -Xbootclasspath/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI
   *      jdk.jfr.event.gc.collection.TestG1ParallelPhases
   */
<span class="line-new-header">--- 43,26 ---</span>
  import java.util.ArrayList;
  import java.util.Collection;
  import java.util.List;
  import java.util.Set;
  
<span class="line-added">+ import gc.testlibrary.g1.MixedGCProvoker;</span>
  import jdk.jfr.Recording;
  import jdk.test.lib.Asserts;
  import jdk.test.lib.jfr.EventNames;
  import sun.hotspot.WhiteBox;
  
  /**
   * @test
   * @key jfr
   * @requires vm.hasJFR
   * @requires vm.gc == &quot;G1&quot; | vm.gc == null
<span class="line-modified">!  * @library /test/lib /test/jdk /test/hotspot/jtreg</span>
   * @build sun.hotspot.WhiteBox
   * @run main ClassFileInstaller sun.hotspot.WhiteBox
<span class="line-modified">!  * @run main/othervm -XX:+UnlockExperimentalVMOptions -XX:+AlwaysTenure</span>
<span class="line-added">+  *      -Xms20M -Xmx20M -Xlog:gc=debug,gc+heap*=debug,gc+ergo*=debug,gc+start=debug</span>
   *      -XX:G1MixedGCLiveThresholdPercent=100 -XX:G1HeapWastePercent=0 -XX:G1HeapRegionSize=1m
   *      -XX:+UseG1GC -XX:+UseStringDeduplication
   *      -Xbootclasspath/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI
   *      jdk.jfr.event.gc.collection.TestG1ParallelPhases
   */
</pre>
<hr />
<pre>
<span class="line-old-header">*** 73,16 ***</span>
          Recording recording = new Recording();
          recording.enable(EventNames.GCPhaseParallel);
          recording.start();
  
          // create more weak garbage than can fit in this heap (-Xmx20m), will force collection of weak references
<span class="line-modified">!         weakRefs = range(1, 100)</span>
              .mapToObj(n -&gt; new WeakReference&lt;&gt;(new byte[1_000_000]))
              .collect(toList()); // force evaluation of lazy stream (all weak refs must be created)
  
          final var MEG = 1024 * 1024;
<span class="line-modified">!         provokeMixedGC(1 * MEG);</span>
          recording.stop();
  
          Set&lt;String&gt; usedPhases = fromRecording(recording).stream()
              .map(e -&gt; e.getValue(&quot;name&quot;).toString())
              .collect(toSet());
<span class="line-new-header">--- 74,16 ---</span>
          Recording recording = new Recording();
          recording.enable(EventNames.GCPhaseParallel);
          recording.start();
  
          // create more weak garbage than can fit in this heap (-Xmx20m), will force collection of weak references
<span class="line-modified">!         weakRefs = range(1, 30)</span>
              .mapToObj(n -&gt; new WeakReference&lt;&gt;(new byte[1_000_000]))
              .collect(toList()); // force evaluation of lazy stream (all weak refs must be created)
  
          final var MEG = 1024 * 1024;
<span class="line-modified">!         MixedGCProvoker.allocateAndProvokeMixedGC(MEG);</span>
          recording.stop();
  
          Set&lt;String&gt; usedPhases = fromRecording(recording).stream()
              .map(e -&gt; e.getValue(&quot;name&quot;).toString())
              .collect(toSet());
</pre>
<hr />
<pre>
<span class="line-old-header">*** 96,87 ***</span>
              &quot;ManagementRoots&quot;,
              &quot;SystemDictionaryRoots&quot;,
              &quot;CLDGRoots&quot;,
              &quot;JVMTIRoots&quot;,
              &quot;CMRefRoots&quot;,
<span class="line-modified">!             &quot;WaitForStrongCLD&quot;,</span>
<span class="line-modified">!             &quot;WeakCLDRoots&quot;,</span>
<span class="line-modified">!             &quot;SATBFiltering&quot;,</span>
<span class="line-modified">!             &quot;UpdateRS&quot;,</span>
<span class="line-modified">!             &quot;ScanHCC&quot;,</span>
<span class="line-removed">-             &quot;ScanRS&quot;,</span>
              &quot;CodeRoots&quot;,
              &quot;ObjCopy&quot;,
              &quot;Termination&quot;,
              &quot;StringDedupQueueFixup&quot;,
              &quot;StringDedupTableFixup&quot;,
              &quot;RedirtyCards&quot;,
<span class="line-modified">!        //     &quot;PreserveCMReferents&quot;,</span>
              &quot;NonYoungFreeCSet&quot;,
<span class="line-modified">!             &quot;YoungFreeCSet&quot;</span>
          );
  
          assertTrue(usedPhases.equals(allPhases), &quot;Compare events expected and received&quot;
              + &quot;, Not found phases: &quot; + allPhases.stream().filter(p -&gt; !usedPhases.contains(p)).collect(joining(&quot;, &quot;))
              + &quot;, Not expected phases: &quot; + usedPhases.stream().filter(p -&gt; !allPhases.contains(p)).collect(joining(&quot;, &quot;)));
      }
  }
<span class="line-removed">- </span>
<span class="line-removed">- /**</span>
<span class="line-removed">-  * Utility class to guarantee a mixed GC. The class allocates several arrays and</span>
<span class="line-removed">-  * promotes them to the oldgen. After that it tries to provoke mixed GC by</span>
<span class="line-removed">-  * allocating new objects.</span>
<span class="line-removed">-  */</span>
<span class="line-removed">- class Provoker {</span>
<span class="line-removed">-     private static void allocateOldObjects(</span>
<span class="line-removed">-             List&lt;byte[]&gt; liveOldObjects,</span>
<span class="line-removed">-             int g1HeapRegionSize,</span>
<span class="line-removed">-             int arraySize) {</span>
<span class="line-removed">- </span>
<span class="line-removed">-         var toUnreachable = new ArrayList&lt;byte[]&gt;();</span>
<span class="line-removed">- </span>
<span class="line-removed">-         // Allocates buffer and promotes it to the old gen. Mix live and dead old objects.</span>
<span class="line-removed">-         // allocate about two regions of old memory. At least one full old region will guarantee</span>
<span class="line-removed">-         // mixed collection in the future</span>
<span class="line-removed">-         range(0, g1HeapRegionSize/arraySize).forEach(n -&gt; {</span>
<span class="line-removed">-             liveOldObjects.add(new byte[arraySize]);</span>
<span class="line-removed">-             toUnreachable.add(new byte[arraySize]);</span>
<span class="line-removed">-         });</span>
<span class="line-removed">- </span>
<span class="line-removed">-         // Do two young collections, MaxTenuringThreshold=1 will force promotion.</span>
<span class="line-removed">-         getWhiteBox().youngGC();</span>
<span class="line-removed">-         getWhiteBox().youngGC();</span>
<span class="line-removed">- </span>
<span class="line-removed">-         // Check it is promoted &amp; keep alive</span>
<span class="line-removed">-         Asserts.assertTrue(getWhiteBox().isObjectInOldGen(liveOldObjects), &quot;List of the objects is suppose to be in OldGen&quot;);</span>
<span class="line-removed">-         Asserts.assertTrue(getWhiteBox().isObjectInOldGen(toUnreachable), &quot;List of the objects is suppose to be in OldGen&quot;);</span>
<span class="line-removed">-     }</span>
<span class="line-removed">- </span>
<span class="line-removed">-     private static void waitTillCMCFinished(int sleepTime) {</span>
<span class="line-removed">-         while (getWhiteBox().g1InConcurrentMark()) {</span>
<span class="line-removed">-               try {sleep(sleepTime);} catch (Exception e) {}</span>
<span class="line-removed">-         }</span>
<span class="line-removed">-     }</span>
<span class="line-removed">- </span>
<span class="line-removed">-     /**</span>
<span class="line-removed">-     * The necessary condition for guaranteed mixed GC is running in VM with the following flags:</span>
<span class="line-removed">-     * -XX:+UnlockExperimentalVMOptions -XX:MaxTenuringThreshold=1 -Xms{HEAP_SIZE}M</span>
<span class="line-removed">-     * -Xmx{HEAP_SIZE}M -XX:G1MixedGCLiveThresholdPercent=100 -XX:G1HeapWastePercent=0</span>
<span class="line-removed">-     * -XX:G1HeapRegionSize={REGION_SIZE}m</span>
<span class="line-removed">-     *</span>
<span class="line-removed">-     * @param provokeSize The size to allocate to provoke the start of a mixed gc (half heap size?)</span>
<span class="line-removed">-     * @param g1HeapRegionSize The size of your regions in bytes</span>
<span class="line-removed">-     */</span>
<span class="line-removed">-     public static void provokeMixedGC(int g1HeapRegionSize) {</span>
<span class="line-removed">-         final var arraySize = 20_000;</span>
<span class="line-removed">-         var liveOldObjects = new ArrayList&lt;byte[]&gt;();</span>
<span class="line-removed">-         allocateOldObjects(liveOldObjects, g1HeapRegionSize, arraySize);</span>
<span class="line-removed">-         waitTillCMCFinished(10);</span>
<span class="line-removed">-         getWhiteBox().g1StartConcMarkCycle();</span>
<span class="line-removed">-         waitTillCMCFinished(10);</span>
<span class="line-removed">-         getWhiteBox().youngGC();</span>
<span class="line-removed">-         getWhiteBox().youngGC();</span>
<span class="line-removed">- </span>
<span class="line-removed">-         // check that liveOldObjects still alive</span>
<span class="line-removed">-         assertTrue(getWhiteBox().isObjectInOldGen(liveOldObjects), &quot;List of the objects is suppose to be in OldGen&quot;);</span>
<span class="line-removed">-     }</span>
<span class="line-removed">- }</span>
<span class="line-new-header">--- 97,37 ---</span>
              &quot;ManagementRoots&quot;,
              &quot;SystemDictionaryRoots&quot;,
              &quot;CLDGRoots&quot;,
              &quot;JVMTIRoots&quot;,
              &quot;CMRefRoots&quot;,
<span class="line-modified">!             &quot;MergeER&quot;,</span>
<span class="line-modified">!             &quot;MergeHCC&quot;,</span>
<span class="line-modified">!             &quot;MergeRS&quot;,</span>
<span class="line-modified">!             &quot;MergeLB&quot;,</span>
<span class="line-modified">!             &quot;ScanHR&quot;,</span>
              &quot;CodeRoots&quot;,
              &quot;ObjCopy&quot;,
              &quot;Termination&quot;,
              &quot;StringDedupQueueFixup&quot;,
              &quot;StringDedupTableFixup&quot;,
              &quot;RedirtyCards&quot;,
<span class="line-modified">!             &quot;ParFreeCSet&quot;,</span>
              &quot;NonYoungFreeCSet&quot;,
<span class="line-modified">!             &quot;YoungFreeCSet&quot;,</span>
<span class="line-added">+             &quot;RebuildFreeList&quot;</span>
          );
  
<span class="line-added">+         // Some GC phases may or may not occur depending on environment. Filter them out</span>
<span class="line-added">+         // since we can not reliably guarantee that they occur (or not).</span>
<span class="line-added">+         Set&lt;String&gt; optPhases = of(</span>
<span class="line-added">+             &quot;OptScanHR&quot;,</span>
<span class="line-added">+             &quot;OptMergeRS&quot;,</span>
<span class="line-added">+             &quot;OptCodeRoots&quot;,</span>
<span class="line-added">+             &quot;OptObjCopy&quot;</span>
<span class="line-added">+         );</span>
<span class="line-added">+         usedPhases.removeAll(optPhases);</span>
<span class="line-added">+ </span>
          assertTrue(usedPhases.equals(allPhases), &quot;Compare events expected and received&quot;
              + &quot;, Not found phases: &quot; + allPhases.stream().filter(p -&gt; !usedPhases.contains(p)).collect(joining(&quot;, &quot;))
              + &quot;, Not expected phases: &quot; + usedPhases.stream().filter(p -&gt; !allPhases.contains(p)).collect(joining(&quot;, &quot;)));
      }
  }
</pre>
<center><a href="GCEventAll.java.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="TestGCCauseWithParallelOld.java.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
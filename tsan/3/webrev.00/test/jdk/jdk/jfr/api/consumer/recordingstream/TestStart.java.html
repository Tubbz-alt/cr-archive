<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New test/jdk/jdk/jfr/api/consumer/recordingstream/TestStart.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package jdk.jfr.api.consumer.recordingstream;
 27 
 28 import java.util.concurrent.CountDownLatch;
 29 import java.util.concurrent.atomic.AtomicBoolean;
 30 
 31 import jdk.jfr.Event;
 32 import jdk.jfr.consumer.RecordingStream;
 33 
 34 /**
 35  * @test
 36  * @summary Tests RecordingStream::start()
 37  * @key jfr
 38  * @requires vm.hasJFR
 39  * @library /test/lib /test/jdk
 40  * @build jdk.jfr.api.consumer.recordingstream.EventProducer
 41  * @run main/othervm jdk.jfr.api.consumer.recordingstream.TestStart
 42  */
 43 public class TestStart {
 44     static class StartEvent extends Event {
 45     }
 46     public static void main(String... args) throws Exception {
 47         testStart();
 48         testStartOnEvent();
 49         testStartTwice();
 50         testStartClosed();
 51     }
 52 
 53     private static void testStartTwice() throws Exception {
 54         log(&quot;Entering testStartTwice()&quot;);
 55         CountDownLatch started = new CountDownLatch(1);
 56         try (RecordingStream rs = new RecordingStream()) {
 57             EventProducer t = new EventProducer();
 58             t.start();
 59             Thread thread = new Thread() {
 60                 public void run() {
 61                     rs.start();
 62                 }
 63             };
 64             thread.start();
 65             rs.onEvent(e -&gt; {
 66                 if (started.getCount() &gt; 0) {
 67                     started.countDown();
 68                 }
 69             });
 70             started.await();
 71             t.kill();
 72             try {
 73                 rs.start();
 74                 throw new AssertionError(&quot;Expected IllegalStateException if started twice&quot;);
 75             } catch (IllegalStateException ise) {
 76                 // OK, as expected
 77             }
 78         }
 79         log(&quot;Leaving testStartTwice()&quot;);
 80     }
 81 
 82     static void testStart() throws Exception {
 83         log(&quot;Entering testStart()&quot;);
 84         CountDownLatch started = new CountDownLatch(1);
 85         try (RecordingStream rs = new RecordingStream()) {
 86             rs.onEvent(e -&gt; {
 87                 started.countDown();
 88             });
 89             EventProducer t = new EventProducer();
 90             t.start();
 91             Thread thread = new Thread() {
 92                 public void run() {
 93                     rs.start();
 94                 }
 95             };
 96             thread.start();
 97             started.await();
 98             t.kill();
 99         }
100         log(&quot;Leaving testStart()&quot;);
101     }
102 
103     static void testStartOnEvent() throws Exception {
104         log(&quot;Entering testStartOnEvent()&quot;);
105         AtomicBoolean ISE = new AtomicBoolean(false);
106         CountDownLatch startedTwice = new CountDownLatch(1);
107         try (RecordingStream rs = new RecordingStream()) {
108             rs.onEvent(e -&gt; {
109                 try {
110                     rs.start(); // must not deadlock
111                 } catch (IllegalStateException ise) {
112                     if (!ISE.get())  {
113                         ISE.set(true);
114                         startedTwice.countDown();
115                     }
116                 }
117             });
118             EventProducer t = new EventProducer();
119             t.start();
120             Thread thread = new Thread() {
121                 public void run() {
122                     rs.start();
123                 }
124             };
125             thread.start();
126             startedTwice.await();
127             t.kill();
128             if (!ISE.get()) {
129                 throw new AssertionError(&quot;Expected IllegalStateException&quot;);
130             }
131         }
132         log(&quot;Leaving testStartOnEvent()&quot;);
133     }
134 
135     static void testStartClosed() {
136         log(&quot;Entering testStartClosed()&quot;);
137         RecordingStream rs = new RecordingStream();
138         rs.close();
139         try {
140             rs.start();
141             throw new AssertionError(&quot;Expected IllegalStateException&quot;);
142         } catch (IllegalStateException ise) {
143             // OK, as expected.
144         }
145         log(&quot;Leaving testStartClosed()&quot;);
146     }
147 
148     private static void log(String msg) {
149         System.out.println(msg);
150     }
151 }
    </pre>
  </body>
</html>
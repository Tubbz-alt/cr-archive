<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New test/jdk/jdk/jfr/api/consumer/recordingstream/TestRemove.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package jdk.jfr.api.consumer.recordingstream;
 27 
 28 import java.util.concurrent.CountDownLatch;
 29 import java.util.concurrent.atomic.AtomicBoolean;
 30 import java.util.concurrent.atomic.AtomicInteger;
 31 import java.util.function.Consumer;
 32 
 33 import jdk.jfr.Event;
 34 import jdk.jfr.consumer.RecordedEvent;
 35 import jdk.jfr.consumer.RecordingStream;
 36 
 37 /**
 38  * @test
 39  * @summary Tests RecordingStrream::remove(...)
 40  * @key jfr
 41  * @requires vm.hasJFR
 42  * @library /test/lib
 43  * @run main/othervm jdk.jfr.api.consumer.recordingstream.TestRemove
 44  */
 45 public class TestRemove {
 46 
 47     static class RemoveEvent extends Event {
 48 
 49     }
 50 
 51     public static void main(String... args) throws Exception {
 52         testRemoveNull();
 53         testRemoveOnFlush();
 54         testRemoveOnClose();
 55         testRemoveOnEvent();
 56     }
 57 
 58     private static void testRemoveNull() {
 59         log(&quot;Entering testRemoveNull()&quot;);
 60         try (RecordingStream rs = new RecordingStream()) {
 61            try {
 62                rs.remove(null);
 63                throw new AssertionError(&quot;Expected NullPointerException from remove(null&quot;);
 64            } catch (NullPointerException npe) {
 65                // OK; as expected
 66            }
 67         }
 68         log(&quot;Leaving testRemoveNull()&quot;);
 69      }
 70 
 71     private static void testRemoveOnEvent() throws Exception {
 72         log(&quot;Entering testRemoveOnEvent()&quot;);
 73         try (RecordingStream rs = new RecordingStream()) {
 74             AtomicInteger counter = new AtomicInteger(0);
 75             CountDownLatch events = new CountDownLatch(2);
 76             Consumer&lt;RecordedEvent&gt; c1 = e -&gt; {
 77                 counter.incrementAndGet();
 78             };
 79 
 80             Consumer&lt;RecordedEvent&gt; c2 = e -&gt; {
 81                 events.countDown();
 82             };
 83             rs.onEvent(c1);
 84             rs.onEvent(c2);
 85 
 86             rs.remove(c1);
 87             rs.startAsync();
 88             RemoveEvent r1 = new RemoveEvent();
 89             r1.commit();
 90             RemoveEvent r2 = new RemoveEvent();
 91             r2.commit();
 92             events.await();
 93             if (counter.get() &gt; 0) {
 94                 throw new AssertionError(&quot;OnEvent handler not removed!&quot;);
 95             }
 96         }
 97         log(&quot;Leaving testRemoveOnEvent()&quot;);
 98     }
 99 
100     private static void testRemoveOnClose() {
101         log(&quot;Entering testRemoveOnClose()&quot;);
102         try (RecordingStream rs = new RecordingStream()) {
103             AtomicBoolean onClose = new AtomicBoolean(false);
104             Runnable r = () -&gt; {
105                 onClose.set(true);
106             };
107             rs.onClose(r);
108             rs.remove(r);
109             rs.close();
110             if (onClose.get()) {
111                 throw new AssertionError(&quot;onClose handler not removed!&quot;);
112             }
113         }
114         log(&quot;Leaving testRemoveOnClose()&quot;);
115     }
116 
117     private static void testRemoveOnFlush() throws Exception {
118         log(&quot;Entering testRemoveOnFlush()&quot;);
119         try (RecordingStream rs = new RecordingStream()) {
120             AtomicInteger flushCount = new AtomicInteger(2);
121             AtomicBoolean removeExecuted = new AtomicBoolean(false);
122             Runnable onFlush1 = () -&gt; {
123                 removeExecuted.set(true);
124             };
125             Runnable onFlush2 = () -&gt; {
126                 flushCount.incrementAndGet();
127             };
128 
129             rs.onFlush(onFlush1);
130             rs.onFlush(onFlush2);
131             rs.remove(onFlush1);
132             rs.startAsync();
133             while (flushCount.get() &lt; 2) {
134                 RemoveEvent r = new RemoveEvent();
135                 r.commit();
136                 Thread.sleep(100);
137             }
138 
139             if (removeExecuted.get()) {
140                 throw new AssertionError(&quot;onFlush handler not removed!&quot;);
141             }
142         }
143         log(&quot;Leaving testRemoveOnFlush()&quot;);
144     }
145 
146     private static void log(String msg) {
147         System.out.println(msg);
148     }
149 }
    </pre>
  </body>
</html>
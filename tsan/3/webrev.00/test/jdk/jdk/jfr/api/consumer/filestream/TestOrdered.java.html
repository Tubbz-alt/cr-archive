<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New test/jdk/jdk/jfr/api/consumer/filestream/TestOrdered.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package jdk.jfr.api.consumer.filestream;
 27 
 28 import java.nio.file.Files;
 29 import java.nio.file.Path;
 30 import java.time.Instant;
 31 import java.util.ArrayList;
 32 import java.util.List;
 33 import java.util.concurrent.CyclicBarrier;
 34 import java.util.concurrent.atomic.AtomicBoolean;
 35 import java.util.concurrent.atomic.AtomicReference;
 36 
 37 import jdk.jfr.Event;
 38 import jdk.jfr.Recording;
 39 import jdk.jfr.consumer.EventStream;
 40 
 41 /**
 42  * @test
 43  * @summary Test EventStream::setOrdered(...)
 44  * @key jfr
 45  * @requires vm.hasJFR
 46  * @library /test/lib
 47  * @run main/othervm jdk.jfr.api.consumer.filestream.TestOrdered
 48  */
 49 public class TestOrdered {
 50 
 51     static class OrderedEvent extends Event {
 52     }
 53 
 54     static class Emitter extends Thread {
 55         private final CyclicBarrier barrier;
 56 
 57         public Emitter(CyclicBarrier barrier) {
 58             this.barrier = barrier;
 59         }
 60 
 61         @Override
 62         public void run() {
 63             OrderedEvent e1 = new OrderedEvent();
 64             e1.commit();
 65             try {
 66                 barrier.await();
 67             } catch (Exception e) {
 68                 e.printStackTrace();
 69                 throw new Error(&quot;Unexpected exception in barrier&quot;);
 70             }
 71             OrderedEvent e2 = new OrderedEvent();
 72             e2.commit();
 73         }
 74     }
 75 
 76     private static final int THREAD_COUNT = 4;
 77     private static final boolean[] BOOLEAN_STATES = { false, true };
 78 
 79     public static void main(String... args) throws Exception {
 80         Path p = makeUnorderedRecording();
 81 
 82         testSetOrderedTrue(p);
 83         testSetOrderedFalse(p);
 84     }
 85 
 86     private static void testSetOrderedTrue(Path p) throws Exception {
 87         for (boolean reuse : BOOLEAN_STATES) {
 88             AtomicReference&lt;Instant&gt; timestamp = new AtomicReference&lt;&gt;(Instant.MIN);
 89             try (EventStream es = EventStream.openFile(p)) {
 90                 es.setReuse(reuse);
 91                 es.setOrdered(true);
 92                 es.onEvent(e -&gt; {
 93                     Instant endTime = e.getEndTime();
 94                     if (endTime.isBefore(timestamp.get())) {
 95                         throw new Error(&quot;Events are not ordered! Reuse = &quot; + reuse);
 96                     }
 97                     timestamp.set(endTime);
 98                 });
 99                 es.start();
100             }
101         }
102     }
103 
104     private static void testSetOrderedFalse(Path p) throws Exception {
105         for (boolean reuse : BOOLEAN_STATES) {
106             AtomicReference&lt;Instant&gt; timestamp = new AtomicReference&lt;&gt;(Instant.MIN);
107             AtomicBoolean unoreded = new AtomicBoolean(false);
108             try (EventStream es = EventStream.openFile(p)) {
109                 es.setReuse(reuse);
110                 es.setOrdered(false);
111                 es.onEvent(e -&gt; {
112                     Instant endTime = e.getEndTime();
113                     if (endTime.isBefore(timestamp.get())) {
114                         unoreded.set(true);
115                         es.close();
116                     }
117                     timestamp.set(endTime);
118                 });
119                 es.start();
120                 if (!unoreded.get()) {
121                     throw new Exception(&quot;Expected at least some events to be out of order! Reuse = &quot; + reuse);
122                 }
123             }
124         }
125     }
126 
127     private static Path makeUnorderedRecording() throws Exception {
128         CyclicBarrier barrier = new CyclicBarrier(THREAD_COUNT + 1);
129 
130         try (Recording r = new Recording()) {
131             r.start();
132             List&lt;Emitter&gt; emitters = new ArrayList&lt;&gt;();
133             for (int i = 0; i &lt; THREAD_COUNT; i++) {
134                 Emitter e = new Emitter(barrier);
135                 e.start();
136                 emitters.add(e);
137             }
138             // Thread buffers should now have one event each
139             barrier.await();
140             // Add another event to each thread buffer, so
141             // events are bound to come out of order when they
142             // are flushed
143             for (Emitter e : emitters) {
144                 e.join();
145             }
146             r.stop();
147             Path p = Files.createTempFile(&quot;recording&quot;, &quot;.jfr&quot;);
148             r.dump(p);
149             return p;
150         }
151     }
152 }
    </pre>
  </body>
</html>
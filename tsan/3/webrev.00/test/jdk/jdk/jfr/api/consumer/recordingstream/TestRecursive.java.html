<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New test/jdk/jdk/jfr/api/consumer/recordingstream/TestRecursive.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package jdk.jfr.api.consumer.recordingstream;
 27 
 28 import java.util.List;
 29 import java.util.concurrent.CompletableFuture;
 30 import java.util.concurrent.CountDownLatch;
 31 import java.util.concurrent.atomic.AtomicBoolean;
 32 
 33 import jdk.jfr.Event;
 34 import jdk.jfr.Recording;
 35 import jdk.jfr.consumer.RecordedEvent;
 36 import jdk.jfr.consumer.RecordingStream;
 37 import jdk.test.lib.jfr.Events;
 38 
 39 /**
 40  * @test
 41  * @summary Tests that events are not emitted in handlers
 42  * @key jfr
 43  * @requires vm.hasJFR
 44  * @library /test/lib /test/jdk
 45  * @build jdk.jfr.api.consumer.recordingstream.EventProducer
 46  * @run main/othervm jdk.jfr.api.consumer.recordingstream.TestRecursive
 47  */
 48 public class TestRecursive {
 49 
 50     public static class NotRecorded extends Event {
 51     }
 52 
 53     public static class Recorded extends Event {
 54     }
 55 
 56     public static class Provoker extends Event {
 57     }
 58 
 59     public static void main(String... args) throws Exception {
 60         testSync();
 61         testAsync();
 62         testStreamInStream();
 63     }
 64 
 65     private static void testStreamInStream() throws Exception {
 66         CountDownLatch latch = new CountDownLatch(1);
 67         try (Recording r = new Recording()) {
 68             r.start();
 69             Recorded r1 = new Recorded(); // 1
 70             r1.commit();
 71             try (RecordingStream rs = new RecordingStream()) {
 72                 rs.onEvent(e1 -&gt; {
 73                     streamInStream();
 74                     latch.countDown();
 75                 });
 76                 rs.startAsync();
 77                 Recorded r2 = new Recorded(); // 2
 78                 r2.commit();
 79                 latch.await();
 80             }
 81             Recorded r3 = new Recorded(); // 2
 82             r3.commit();
 83             r.stop();
 84             List&lt;RecordedEvent&gt; events = Events.fromRecording(r);
 85             if (count(events, NotRecorded.class) != 0) {
 86                 throw new Exception(&quot;Expected 0 NotRecorded events&quot;);
 87             }
 88             if (count(events, Recorded.class) != 3) {
 89                 throw new Exception(&quot;Expected 3 Recorded events&quot;);
 90             }
 91         }
 92     }
 93 
 94     // No events should be recorded in this method
 95     private static void streamInStream() {
 96         NotRecorded nr1 = new NotRecorded();
 97         nr1.commit();
 98         CountDownLatch latch = new CountDownLatch(1);
 99         try (RecordingStream rs2 = new RecordingStream()) {
100             rs2.onEvent(e2 -&gt; {
101                 NotRecorded nr2 = new NotRecorded();
102                 nr2.commit();
103                 latch.countDown();
104             });
105             NotRecorded nr3 = new NotRecorded();
106             nr3.commit();
107             rs2.startAsync();
108             // run event in separate thread
109             CompletableFuture.runAsync(() -&gt; {
110                 Provoker p = new Provoker();
111                 p.commit();
112             });
113             try {
114                 latch.await();
115             } catch (InterruptedException e) {
116                 throw new Error(&quot;Unexpected interruption&quot;, e);
117             }
118         }
119         NotRecorded nr2 = new NotRecorded();
120         nr2.commit();
121     }
122 
123     private static void testSync() throws Exception {
124         try (Recording r = new Recording()) {
125             r.start();
126             EventProducer p = new EventProducer();
127             try (RecordingStream rs = new RecordingStream()) {
128                 Recorded e1 = new Recorded();
129                 e1.commit();
130                 rs.onEvent(e -&gt; {
131                     System.out.println(&quot;Emitting NotRecorded event&quot;);
132                     NotRecorded event = new NotRecorded();
133                     event.commit();
134                     System.out.println(&quot;Stopping event provoker&quot;);
135                     p.kill();
136                     System.out.println(&quot;Closing recording stream&quot;);
137                     rs.close();
138                     return;
139                 });
140                 p.start();
141                 rs.start();
142                 Recorded e2 = new Recorded();
143                 e2.commit();
144             }
145             r.stop();
146             List&lt;RecordedEvent&gt; events = Events.fromRecording(r);
147             System.out.println(events);
148             if (count(events, NotRecorded.class) != 0) {
149                 throw new Exception(&quot;Expected 0 NotRecorded events&quot;);
150             }
151             if (count(events, Recorded.class) != 2) {
152                 throw new Exception(&quot;Expected 2 Recorded events&quot;);
153             }
154         }
155     }
156 
157     private static int count(List&lt;RecordedEvent&gt; events, Class&lt;?&gt; eventClass) {
158         int count = 0;
159         for (RecordedEvent e : events) {
160             if (e.getEventType().getName().equals(eventClass.getName())) {
161                 count++;
162             }
163         }
164         System.out.println(count);
165         return count;
166     }
167 
168     private static void testAsync() throws InterruptedException, Exception {
169         CountDownLatch latchOne = new CountDownLatch(1);
170         CountDownLatch latchTwo = new CountDownLatch(2);
171         AtomicBoolean fail = new AtomicBoolean();
172         try (RecordingStream r = new RecordingStream()) {
173             r.onEvent(e -&gt; {
174                 System.out.println(e);
175                 NotRecorded event = new NotRecorded();
176                 event.commit();
177                 if (e.getEventType().getName().equals(Recorded.class.getName())) {
178                     latchOne.countDown();
179                     latchTwo.countDown();
180                 }
181                 if (e.getEventType().getName().equals(NotRecorded.class.getName())) {
182                     fail.set(true);
183                 }
184             });
185             r.startAsync();
186             Recorded e1 = new Recorded();
187             e1.commit();
188             latchOne.await();
189             Recorded e2 = new Recorded();
190             e2.commit();
191             latchTwo.await();
192             if (fail.get()) {
193                 throw new Exception(&quot;Unexpected event found&quot;);
194             }
195         }
196     }
197 }
    </pre>
  </body>
</html>
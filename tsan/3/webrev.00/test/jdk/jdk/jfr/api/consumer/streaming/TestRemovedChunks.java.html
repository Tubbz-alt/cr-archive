<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New test/jdk/jdk/jfr/api/consumer/streaming/TestRemovedChunks.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package jdk.jfr.api.consumer.streaming;
 27 
 28 import java.util.concurrent.CountDownLatch;
 29 
 30 import jdk.jfr.Event;
 31 import jdk.jfr.Recording;
 32 import jdk.jfr.consumer.RecordingStream;
 33 
 34 /**
 35  * @test
 36  * @summary Tests that a stream can gracefully handle chunk being removed
 37  * @key jfr
 38  * @requires vm.hasJFR
 39  * @library /test/lib
 40  * @run main/othervm -Xlog:jfr*=info jdk.jfr.api.consumer.streaming.TestRemovedChunks
 41  */
 42 public class TestRemovedChunks {
 43     private final static CountDownLatch parkLatch = new CountDownLatch(1);
 44     private final static CountDownLatch removalLatch = new CountDownLatch(1);
 45     private final static CountDownLatch IFeelFineLatch = new CountDownLatch(1);
 46 
 47     static class DataEvent extends Event {
 48         double double1;
 49         double double2;
 50         double double3;
 51         double double4;
 52         double double5;
 53     }
 54 
 55     static class ParkStream extends Event {
 56     }
 57 
 58     static class IFeelFine extends Event {
 59     }
 60 
 61     public static void main(String... args) throws Exception {
 62 
 63         try (RecordingStream s = new RecordingStream()) {
 64             s.setMaxSize(5_000_000);
 65             s.onEvent(ParkStream.class.getName(), e -&gt; {
 66                 parkLatch.countDown();
 67                 await(removalLatch);
 68 
 69             });
 70             s.onEvent(IFeelFine.class.getName(), e -&gt; {
 71                 IFeelFineLatch.countDown();
 72             });
 73             s.startAsync();
 74             // Fill first chunk with data
 75             emitData(1_000_000);
 76             // Park stream
 77             ParkStream ps = new ParkStream();
 78             ps.commit();
 79             await(parkLatch);
 80             // Rotate and emit data that exceeds maxSize
 81             for (int i = 0; i&lt; 10;i++) {
 82                 try (Recording r = new Recording()) {
 83                     r.start();
 84                     emitData(1_000_000);
 85                 }
 86             }
 87             // Emit final event
 88             IFeelFine i = new IFeelFine();
 89             i.commit();
 90             // Wake up parked stream
 91             removalLatch.countDown();
 92             // Await event things gone bad
 93             await(IFeelFineLatch);
 94         }
 95     }
 96 
 97     private static void await(CountDownLatch latch) throws Error {
 98         try {
 99             latch.await();
100         } catch (InterruptedException e1) {
101             throw new Error(&quot;Latch interupted&quot;);
102         }
103     }
104 
105     private static void emitData(int amount) throws InterruptedException {
106         int count = 0;
107         while (amount &gt; 0) {
108             DataEvent de = new DataEvent();
109             // 5 doubles are 40 bytes bytes
110             // and event size, event type, thread,
111             // start time, duration and stack trace about 15 bytes
112             de.double1 = 0.0;
113             de.double2 = 1.0;
114             de.double3 = 2.0;
115             de.double4 = 3.0;
116             de.double5 = 4.0;
117             de.commit();
118             amount -= 55;
119             count++;
120             //
121             if (count % 100_000 == 0) {
122                 Thread.sleep(10);
123             }
124         }
125     }
126 }
    </pre>
  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New test/jdk/jdk/jfr/api/consumer/streaming/TestLatestEvent.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package jdk.jfr.api.consumer.streaming;
 27 
 28 import java.nio.file.Path;
 29 import java.nio.file.Paths;
 30 import java.util.concurrent.CountDownLatch;
 31 import java.util.concurrent.TimeUnit;
 32 import java.util.concurrent.atomic.AtomicBoolean;
 33 
 34 import jdk.jfr.Event;
 35 import jdk.jfr.FlightRecorder;
 36 import jdk.jfr.Name;
 37 import jdk.jfr.Recording;
 38 import jdk.jfr.consumer.EventStream;
 39 import jdk.jfr.consumer.RecordingStream;
 40 
 41 /**
 42  * @test
 43  * @summary Verifies that EventStream::openRepository() read from the latest flush
 44  * @key jfr
 45  * @requires vm.hasJFR
 46  * @library /test/lib
 47  * @run main/othervm jdk.jfr.api.consumer.streaming.TestLatestEvent
 48  */
 49 public class TestLatestEvent {
 50 
 51     @Name(&quot;NotLatest&quot;)
 52     static class NotLatestEvent extends Event {
 53 
 54         public int id;
 55     }
 56 
 57     @Name(&quot;Latest&quot;)
 58     static class LatestEvent extends Event {
 59     }
 60 
 61     @Name(&quot;MakeChunks&quot;)
 62     static class MakeChunks extends Event {
 63     }
 64 
 65     public static void main(String... args) throws Exception {
 66         CountDownLatch notLatestEvent = new CountDownLatch(6);
 67         CountDownLatch beginChunks = new CountDownLatch(1);
 68 
 69         try (RecordingStream r = new RecordingStream()) {
 70             r.onEvent(&quot;MakeChunks&quot;, event-&gt; {
 71                 System.out.println(event);
 72                 beginChunks.countDown();
 73             });
 74             r.onEvent(&quot;NotLatest&quot;, event -&gt; {
 75                 System.out.println(event);
 76                 notLatestEvent.countDown();
 77             });
 78             r.startAsync();
 79             MakeChunks e = new MakeChunks();
 80             e.commit();
 81 
 82             System.out.println(&quot;Waiting for first chunk&quot;);
 83             beginChunks.await();
 84             // Create 5 chunks with events in the repository
 85             for (int i = 0; i &lt; 5; i++) {
 86                 System.out.println(&quot;Creating empty chunk&quot;);
 87                 try (Recording r1 = new Recording()) {
 88                     r1.start();
 89                     NotLatestEvent notLatest = new NotLatestEvent();
 90                     notLatest.id = i;
 91                     notLatest.commit();
 92                     r1.stop();
 93                 }
 94             }
 95             System.out.println(&quot;All empty chunks created&quot;);
 96 
 97             // Create event in new chunk
 98             NotLatestEvent notLatest = new NotLatestEvent();
 99             notLatest.id = 5;
100             notLatest.commit();
101 
102             // This latch ensures thatNotLatest has been
103             // flushed and a new valid position has been written
104             // to the chunk header
105             notLatestEvent.await(80, TimeUnit.SECONDS);
106             if (notLatestEvent.getCount() != 0) {
107                Recording rec =  FlightRecorder.getFlightRecorder().takeSnapshot();
108                Path p = Paths.get(&quot;error-not-latest.jfr&quot;).toAbsolutePath();
109                rec.dump(p);
110                System.out.println(&quot;Dumping repository as a file for inspection at &quot; + p);
111                throw new Exception(&quot;Timeout 80 s. Expected 6 event, but got &quot;  + notLatestEvent.getCount());
112             }
113 
114             try (EventStream s = EventStream.openRepository()) {
115                 System.out.println(&quot;EventStream opened&quot;);
116                 AtomicBoolean foundLatest = new AtomicBoolean();
117                 s.onEvent(event -&gt; {
118                     String name = event.getEventType().getName();
119                     System.out.println(&quot;Found event &quot; + name);
120                     foundLatest.set(name.equals(&quot;Latest&quot;));
121                 });
122                 s.startAsync();
123                 // Must loop here as there is no guarantee
124                 // that the parser thread starts before event
125                 // is flushed
126                 while (!foundLatest.get()) {
127                     LatestEvent latest = new LatestEvent();
128                     latest.commit();
129                     System.out.println(&quot;Latest event emitted. Waiting 1 s ...&quot;);
130                     Thread.sleep(1000);
131                 }
132             }
133         }
134     }
135 }
    </pre>
  </body>
</html>
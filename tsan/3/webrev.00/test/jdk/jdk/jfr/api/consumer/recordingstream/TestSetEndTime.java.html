<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New test/jdk/jdk/jfr/api/consumer/recordingstream/TestSetEndTime.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2019, 2020, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package jdk.jfr.api.consumer.recordingstream;
 27 
 28 import java.io.IOException;
 29 import java.nio.file.Path;
 30 import java.nio.file.Paths;
 31 import java.time.Duration;
 32 import java.time.Instant;
 33 import java.util.concurrent.CountDownLatch;
 34 import java.util.concurrent.atomic.AtomicBoolean;
 35 import java.util.concurrent.atomic.AtomicInteger;
 36 
 37 import jdk.jfr.Event;
 38 import jdk.jfr.Name;
 39 import jdk.jfr.Recording;
 40 import jdk.jfr.StackTrace;
 41 import jdk.jfr.consumer.EventStream;
 42 import jdk.jfr.consumer.RecordedEvent;
 43 import jdk.jfr.consumer.RecordingFile;
 44 import jdk.jfr.consumer.RecordingStream;
 45 
 46 /**
 47  * @test
 48  * @summary Tests EventStream::setEndTime
 49  * @key jfr
 50  * @requires vm.hasJFR
 51  * @library /test/lib
 52  * @run main/othervm jdk.jfr.api.consumer.recordingstream.TestSetEndTime
 53  */
 54 public final class TestSetEndTime {
 55 
 56     @Name(&quot;Mark&quot;)
 57     @StackTrace(false)
 58     public final static class Mark extends Event {
 59         public boolean include;
 60         public int id;
 61     }
 62 
 63     public static void main(String... args) throws Exception {
 64         testEventStream();
 65         testRecordingStream();
 66         testEmptyStream();
 67     }
 68 
 69     private static void testEmptyStream() {
 70         try (RecordingStream rs = new RecordingStream()) {
 71             rs.setEndTime(Instant.now().plusMillis(1100));
 72             rs.start();
 73         }
 74     }
 75 
 76     private static void testRecordingStream() throws Exception {
 77         while (true) {
 78             CountDownLatch closed = new CountDownLatch(1);
 79             AtomicInteger count = new AtomicInteger();
 80             try (RecordingStream rs = new RecordingStream()) {
 81                 rs.onEvent(e -&gt; {
 82                     count.incrementAndGet();
 83                 });
 84                 // when end is reached stream is closed
 85                 rs.onClose(() -&gt; {
 86                     closed.countDown();
 87                 });
 88                 Instant endTime = Instant.now().plus(Duration.ofMillis(100));
 89                 System.out.println(&quot;Setting end time: &quot; + endTime);
 90                 rs.setEndTime(endTime);
 91                 rs.startAsync();
 92                 for (int i = 0; i &lt; 50; i++) {
 93                     Mark m = new Mark();
 94                     m.commit();
 95                     Thread.sleep(10);
 96                 }
 97                 closed.await();
 98                 System.out.println(&quot;Found events: &quot; + count.get());
 99                 if (count.get() &gt; 0 &amp;&amp; count.get() &lt; 50) {
100                     return;
101                 }
102                 System.out.println(&quot;Retrying&quot;);
103                 System.out.println();
104             }
105         }
106     }
107 
108     static void testEventStream() throws InterruptedException, IOException, Exception {
109         while (true) {
110             try (Recording r = new Recording()) {
111                 r.start();
112 
113                 Mark event1 = new Mark();
114                 event1.id = 1;
115                 event1.include = false;
116                 event1.commit(); // start time
117 
118                 nap();
119 
120                 Mark event2 = new Mark();
121                 event2.id = 2;
122                 event2.include = true;
123                 event2.commit();
124 
125                 nap();
126 
127                 Mark event3 = new Mark();
128                 event3.id = 3;
129                 event3.include = false;
130                 event3.commit(); // end time
131 
132                 Path p = Paths.get(&quot;recording.jfr&quot;);
133                 r.dump(p);
134                 Instant start = null;
135                 Instant end = null;
136                 System.out.println(&quot;Find start and end time as instants:&quot;);
137                 for (RecordedEvent e : RecordingFile.readAllEvents(p)) {
138                     if (e.getInt(&quot;id&quot;) == 1) {
139                         start = e.getEndTime();
140                         System.out.println(&quot;Start  : &quot; + start);
141                     }
142                     if (e.getInt(&quot;id&quot;) == 2) {
143                         Instant middle = e.getEndTime();
144                         System.out.println(&quot;Middle : &quot; + middle);
145                     }
146                     if (e.getInt(&quot;id&quot;) == 3) {
147                         end = e.getEndTime();
148                         System.out.println(&quot;End    : &quot; + end);
149                     }
150                 }
151                 System.out.println();
152                 System.out.println(&quot;Opening stream between &quot; + start + &quot; and &quot; + end);
153                 AtomicBoolean success = new AtomicBoolean(false);
154                 AtomicInteger eventsCount = new AtomicInteger();
155                 try (EventStream d = EventStream.openRepository()) {
156                     d.setStartTime(start.plusNanos(1));
157                     // Stream should close when end is reached
158                     d.setEndTime(end.minusNanos(1));
159                     d.onEvent(e -&gt; {
160                         eventsCount.incrementAndGet();
161                         boolean include = e.getBoolean(&quot;include&quot;);
162                         System.out.println(&quot;Event &quot; + e.getEndTime() + &quot; include=&quot; + include);
163                         if (include) {
164                             success.set(true);
165                         }
166                     });
167                     d.start();
168                     if (eventsCount.get() == 1 &amp;&amp; success.get()) {
169                         return;
170                     }
171                 }
172             }
173         }
174 
175     }
176 
177     private static void nap() throws InterruptedException {
178         // Ensure we advance at least 1 ns with fast time
179         Thread.sleep(1);
180     }
181 
182 }
    </pre>
  </body>
</html>
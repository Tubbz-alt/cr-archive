<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New test/jdk/jdk/jfr/api/consumer/recordingstream/TestOnErrorSync.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package jdk.jfr.api.consumer.recordingstream;
 27 
 28 import java.util.Timer;
 29 import java.util.TimerTask;
 30 import java.util.concurrent.atomic.AtomicBoolean;
 31 import java.util.concurrent.atomic.AtomicInteger;
 32 
 33 import jdk.jfr.api.consumer.recordingstream.TestUtils.TestError;
 34 import jdk.jfr.api.consumer.recordingstream.TestUtils.TestException;
 35 import jdk.jfr.api.consumer.security.TestStreamingRemote.TestEvent;
 36 import jdk.jfr.consumer.RecordingStream;
 37 
 38 /**
 39  * @test
 40  * @summary Tests RecordingStream::onError(...) when using RecordingStream:start
 41  * @key jfr
 42  * @requires vm.hasJFR
 43  * @library /test/lib /test/jdk
 44  * @run main/othervm jdk.jfr.api.consumer.recordingstream.TestOnErrorSync
 45  */
 46 public class TestOnErrorSync {
 47     public static void main(String... args) throws Exception {
 48         testDefaultError();
 49         testCustomError();
 50         testDefaultException();
 51         testCustomException();
 52         testOnFlushSanity();
 53         testOnCloseSanity();
 54     }
 55 
 56     private static void testDefaultError() throws Exception {
 57         TestError error = new TestError();
 58         AtomicBoolean closed = new AtomicBoolean();
 59         Timer t = newEventEmitter();
 60         try (RecordingStream r = new RecordingStream()) {
 61             r.onEvent(e -&gt; {
 62                 throw error; // closes stream
 63             });
 64             r.onClose(() -&gt; {
 65                 closed.set(true);
 66             });
 67             try {
 68                 r.start();
 69                 throw new Exception(&quot;Expected TestError to be thrown&quot;);
 70             } catch (TestError te) {
 71                 // as expected
 72             }
 73             if (!closed.get()) {
 74                 throw new Exception(&quot;Expected stream to be closed&quot;);
 75             }
 76         } finally {
 77             t.cancel();
 78         }
 79     }
 80 
 81     private static void testCustomError() throws Exception {
 82         TestError error = new TestError();
 83         AtomicBoolean onError = new AtomicBoolean();
 84         AtomicBoolean closed = new AtomicBoolean();
 85         Timer t = newEventEmitter();
 86         try (RecordingStream r = new RecordingStream()) {
 87             r.onEvent(e -&gt; {
 88                 throw error; // closes stream
 89             });
 90             r.onError(e -&gt; {
 91                 onError.set(true);
 92             });
 93             r.onClose(() -&gt; {
 94                 closed.set(true);
 95             });
 96             try {
 97                 r.start();
 98                 throw new Exception(&quot;Expected TestError to be thrown&quot;);
 99             } catch (TestError terror) {
100                 // as expected
101             }
102             if (onError.get()) {
103                 throw new Exception(&quot;Expected onError(...) NOT to be invoked&quot;);
104             }
105             if (!closed.get()) {
106                 throw new Exception(&quot;Expected stream to be closed&quot;);
107             }
108         } finally {
109             t.cancel();
110         }
111     }
112 
113     private static void testDefaultException() throws Exception {
114         TestException exception = new TestException();
115         AtomicInteger counter = new AtomicInteger();
116         AtomicBoolean closed = new AtomicBoolean();
117         Timer t = newEventEmitter();
118         try (RecordingStream r = new RecordingStream()) {
119             r.onEvent(e -&gt; {
120                 if (counter.incrementAndGet() == 2) {
121                     // Only close if we get a second event after an exception
122                     r.close();
123                     return;
124                 }
125                 TestUtils.throwUnchecked(exception);
126             });
127             r.onClose(() -&gt; {
128                 closed.set(true);
129             });
130             try {
131                 r.start();
132             } catch (Exception e) {
133                 throw new Exception(&quot;Unexpected exception thrown from start()&quot;, e);
134             }
135             if (!exception.isPrinted()) {
136                 throw new Exception(&quot;Expected stack trace from Exception to be printed&quot;);
137             }
138             if (!closed.get()) {
139                 throw new Exception(&quot;Expected stream to be closed&quot;);
140             }
141         } finally {
142             t.cancel();
143         }
144     }
145 
146     private static void testCustomException() throws Exception {
147         TestException exception = new TestException();
148         AtomicInteger counter = new AtomicInteger();
149         AtomicBoolean onError = new AtomicBoolean();
150         AtomicBoolean closed = new AtomicBoolean();
151         AtomicBoolean received = new AtomicBoolean();
152         Timer t = newEventEmitter();
153         try (RecordingStream r = new RecordingStream()) {
154             r.onEvent(e -&gt; {
155                 if (counter.incrementAndGet() == 2) {
156                     // Only close if we get a second event after an exception
157                     r.close();
158                     return;
159                 }
160                 TestUtils.throwUnchecked(exception);
161             });
162             r.onError(e -&gt; {
163                 received.set(e == exception);
164                 onError.set(true);
165             });
166             r.onClose(() -&gt; {
167                 closed.set(true);
168             });
169             try {
170                 r.start();
171             } catch (Exception e) {
172                 throw new Exception(&quot;Unexpected exception thrown from start()&quot;, e);
173             }
174             if (!received.get()) {
175                 throw new Exception(&quot;Did not receive expected exception in onError(...)&quot;);
176             }
177             if (exception.isPrinted()) {
178                 throw new Exception(&quot;Expected stack trace from Exception NOT to be printed&quot;);
179             }
180             if (!onError.get()) {
181                 throw new Exception(&quot;Expected OnError(...) to be invoked&quot;);
182             }
183             if (!closed.get()) {
184                 throw new Exception(&quot;Expected stream to be closed&quot;);
185             }
186         } finally {
187             t.cancel();
188         }
189     }
190 
191     private static void testOnFlushSanity() throws Exception {
192         TestException exception = new TestException();
193         AtomicBoolean received = new AtomicBoolean();
194         try (RecordingStream r = new RecordingStream()) {
195             r.onFlush(() -&gt; {
196                 TestUtils.throwUnchecked(exception);
197             });
198             r.onError(t -&gt; {
199                 received.set(t == exception);
200                 r.close();
201             });
202             r.start();
203             if (!received.get()) {
204                 throw new Exception(&quot;Expected exception in OnFlush to propagate to onError&quot;);
205             }
206         }
207     }
208 
209     private static void testOnCloseSanity() throws Exception {
210         TestException exception = new TestException();
211         AtomicBoolean received = new AtomicBoolean();
212         try (RecordingStream r = new RecordingStream()) {
213             r.onFlush(() -&gt; {
214                 r.close(); // will trigger onClose
215             });
216             r.onClose(() -&gt; {
217                 TestUtils.throwUnchecked(exception); // will trigger onError
218             });
219             r.onError(t -&gt; {
220                 received.set(t == exception);
221             });
222             r.start();
223             if (!received.get()) {
224                 throw new Exception(&quot;Expected exception in OnFlush to propagate to onError&quot;);
225             }
226         }
227     }
228 
229     private static Timer newEventEmitter() {
230         Timer timer = new Timer();
231         TimerTask task = new TimerTask() {
232             @Override
233             public void run() {
234                 TestEvent event = new TestEvent();
235                 event.commit();
236             }
237         };
238         timer.schedule(task, 0, 100);
239         return timer;
240     }
241 }
    </pre>
  </body>
</html>
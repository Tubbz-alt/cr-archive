diff a/test/jdk/jdk/jfr/jvm/TestUnsupportedVM.java b/test/jdk/jdk/jfr/jvm/TestUnsupportedVM.java
--- a/test/jdk/jdk/jfr/jvm/TestUnsupportedVM.java
+++ b/test/jdk/jdk/jfr/jvm/TestUnsupportedVM.java
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2014, 2018, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2014, 2019, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.  Oracle designates this
@@ -28,12 +28,14 @@
 import java.io.FileReader;
 import java.io.IOException;
 import java.nio.file.Files;
 import java.nio.file.Path;
 import java.nio.file.Paths;
+import java.time.Duration;
 import java.util.ArrayList;
 import java.util.concurrent.Callable;
+import java.util.concurrent.atomic.AtomicBoolean;
 
 import jdk.jfr.AnnotationElement;
 import jdk.jfr.Configuration;
 import jdk.jfr.Description;
 import jdk.jfr.Event;
@@ -46,19 +48,21 @@
 import jdk.jfr.Label;
 import jdk.jfr.Recording;
 import jdk.jfr.RecordingState;
 import jdk.jfr.SettingControl;
 import jdk.jfr.ValueDescriptor;
+import jdk.jfr.consumer.EventStream;
 import jdk.jfr.consumer.RecordedClass;
 import jdk.jfr.consumer.RecordedEvent;
 import jdk.jfr.consumer.RecordedFrame;
 import jdk.jfr.consumer.RecordedMethod;
 import jdk.jfr.consumer.RecordedObject;
 import jdk.jfr.consumer.RecordedStackTrace;
 import jdk.jfr.consumer.RecordedThread;
 import jdk.jfr.consumer.RecordedThreadGroup;
 import jdk.jfr.consumer.RecordingFile;
+import jdk.jfr.consumer.RecordingStream;
 import jdk.management.jfr.ConfigurationInfo;
 import jdk.management.jfr.EventTypeInfo;
 import jdk.management.jfr.FlightRecorderMXBean;
 import jdk.management.jfr.RecordingInfo;
 import jdk.management.jfr.SettingDescriptorInfo;
@@ -104,13 +108,15 @@
             RecordingFile.class,
             RecordingInfo.class,
             RecordingState.class,
             SettingControl.class,
             SettingDescriptorInfo.class,
-            ValueDescriptor.class
+            ValueDescriptor.class,
+            EventStream.class,
+            RecordingStream.class
        };
-    // * @run main/othervm -Dprepare-recording=true jdk.jfr.jvm.TestUnsupportedVM
+
     @Label("My Event")
     @Description("My fine event")
     static class MyEvent extends Event {
         int myValue;
     }
@@ -123,21 +129,22 @@
             r.dump(RECORDING_FILE);
             r.close();
             return;
         }
 
-        System.out.println("jdk.jfr.unsupportedvm=" + System.getProperty("jdk.jfr.unsupportedvm"));
+        System.out.println("jfr.unsupported.vm=" + System.getProperty("jfr.unsupported.vm"));
         // Class FlightRecorder
         if (FlightRecorder.isAvailable()) {
             throw new AssertionError("JFR should not be available on an unsupported VM");
         }
 
         if (FlightRecorder.isInitialized()) {
             throw new AssertionError("JFR should not be initialized on an unsupported VM");
         }
 
         assertIllegalStateException(() -> FlightRecorder.getFlightRecorder());
+        assertIllegalStateException(() -> new RecordingStream());
         assertSwallow(() -> FlightRecorder.addListener(new FlightRecorderListener() {}));
         assertSwallow(() -> FlightRecorder.removeListener(new FlightRecorderListener() {}));
         assertSwallow(() -> FlightRecorder.register(MyEvent.class));
         assertSwallow(() -> FlightRecorder.unregister(MyEvent.class));
         assertSwallow(() -> FlightRecorder.addPeriodicEvent(MyEvent.class, new Runnable() { public void run() {} }));
@@ -172,12 +179,43 @@
 
         // jdk.jfr.consumer.*
         // Only run this part of tests if we are on VM
         // that can produce a recording file
         if (Files.exists(RECORDING_FILE)) {
+            boolean firstFileEvent = true;
             for(RecordedEvent re : RecordingFile.readAllEvents(RECORDING_FILE)) {
-                System.out.println(re);
+                // Print one event
+                if (firstFileEvent) {
+                    System.out.println(re);
+                    firstFileEvent = false;
+                }
+            }
+            AtomicBoolean firstStreamEvent = new AtomicBoolean(true);
+            try (EventStream es = EventStream.openFile(RECORDING_FILE)) {
+                es.onEvent(e -> {
+                    // Print one event
+                    if (firstStreamEvent.get()) {
+                        try {
+                            System.out.println(e);
+                            firstStreamEvent.set(false);
+                        } catch (Throwable t) {
+                            t.printStackTrace();
+                        }
+                    }
+                });
+                es.start();
+                if (firstStreamEvent.get()) {
+                    throw new AssertionError("Didn't print streaming event");
+                }
+            }
+
+            try (EventStream es = EventStream.openRepository()) {
+                es.onEvent(e -> {
+                    System.out.println(e);
+                });
+                es.startAsync();
+                es.awaitTermination(Duration.ofMillis(10));
             }
         }
     }
 
     private static void assertNoClassInitFailure(Class<?> clazz) {

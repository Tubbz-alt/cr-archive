<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New test/jdk/jdk/jfr/jvm/TestClearStaleConstants.java</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package jdk.jfr.jvm;
 27 
 28 import java.time.Duration;
 29 import java.util.List;
 30 
 31 import jdk.jfr.consumer.RecordedClass;
 32 import jdk.jfr.consumer.RecordedClassLoader;
 33 import jdk.jfr.consumer.RecordedEvent;
 34 import jdk.jfr.internal.JVM;
 35 import jdk.jfr.Recording;
 36 import jdk.test.lib.Asserts;
 37 import jdk.test.lib.jfr.EventNames;
 38 import jdk.test.lib.jfr.Events;
 39 import jdk.test.lib.jfr.TestClassLoader;
 40 
 41 /**
 42  * @test
 43  * @bug 8231081
 44  * @key jfr
 45  * @requires vm.hasJFR
 46  * @modules jdk.jfr/jdk.jfr.internal
 47  * @library /test/lib /test/jdk
 48  * @run main/othervm -Xlog:class+unload -Xlog:gc -Xmx16m jdk.jfr.jvm.TestClearStaleConstants
 49  */
 50 
 51 /**
 52  * System.gc() will trigger class unloading if -XX:+ExplicitGCInvokesConcurrent is NOT set.
 53  * If this flag is set G1 will never unload classes on System.gc() and
 54  * As far as the &quot;jfr&quot; key guarantees no VM flags are set from the outside
 55  * it should be enough with System.gc().
 56  */
 57 public final class TestClearStaleConstants {
 58     static class MyClass {
 59     }
 60     private final static String TEST_CLASS_NAME = &quot;jdk.jfr.jvm.TestClearStaleConstants$MyClass&quot;;
 61     private final static String EVENT_NAME = EventNames.ClassDefine;
 62 
 63     // to prevent the compiler to optimize away all unread writes
 64     public static TestClassLoader firstClassLoader;
 65     public static TestClassLoader secondClassLoader;
 66 
 67     public static void main(String... args) throws Exception {
 68         firstClassLoader = new TestClassLoader();
 69         // define a  class using a class loader under a recording
 70         Class&lt;?&gt; clz = recordClassDefinition(firstClassLoader);
 71         JVM jvm = JVM.getJVM();
 72         // we will now tag the defined and loaded clz as being in use (no recordings are running here)
 73         jvm.getClassIdNonIntrinsic(clz);
 74         // null out for unload to occur
 75         firstClassLoader = null;
 76         clz = null;
 77         // provoke unload
 78         System.gc();
 79         // try to define another class _with the same name_ using a different class loader
 80         secondClassLoader = new TestClassLoader();
 81         // this will throw a NPE for 8231081 because it will reuse the same class name
 82         // that symbol was  marked as already serialized by the unload, but since no recordings were running
 83         // it was not written to any chunk. This creates a reference to a non-existing symbol, leading to an NPE (no symbol at the expected location).
 84         recordClassDefinition(secondClassLoader);
 85     }
 86 
 87     private static Class&lt;?&gt; recordClassDefinition(TestClassLoader classLoader) throws Exception  {
 88         try (Recording recording = new Recording())  {
 89             recording.enable(EVENT_NAME);
 90             recording.start();
 91             Class&lt;?&gt; clz = classLoader.loadClass(TEST_CLASS_NAME);
 92             recording.stop();
 93             assertClassDefineEvent(recording);
 94             return clz;
 95         }
 96     }
 97 
 98     private static void assertClassDefineEvent(Recording recording) throws Exception {
 99         boolean isAnyFound = false;
100         for (RecordedEvent event : Events.fromRecording(recording)) {
101             System.out.println(event);
102             RecordedClass definedClass = event.getValue(&quot;definedClass&quot;);
103             if (TEST_CLASS_NAME.equals(definedClass.getName())) {
104                 RecordedClassLoader definingClassLoader = definedClass.getClassLoader();
105                 String definingName = definingClassLoader.getType().getName();
106                 String testName = TestClassLoader.class.getName();
107                 String errorMsg = &quot;Expected &quot; + testName + &quot;, got &quot; + definingName;
108                 Asserts.assertEquals(testName, definingName, errorMsg);
109                 Asserts.assertFalse(isAnyFound, &quot;Found more than 1 event&quot;);
110                 isAnyFound = true;
111             }
112         }
113         Asserts.assertTrue(isAnyFound, &quot;No events found&quot;);
114     }
115 }
    </pre>
  </body>
</html>
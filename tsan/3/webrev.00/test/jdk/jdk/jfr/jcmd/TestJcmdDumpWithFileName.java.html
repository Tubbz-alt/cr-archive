<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New test/jdk/jdk/jfr/jcmd/TestJcmdDumpWithFileName.java</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package jdk.jfr.jcmd;
 27 
 28 import java.io.IOException;
 29 import java.nio.file.Files;
 30 import java.nio.file.Path;
 31 import java.util.stream.Stream;
 32 
 33 import jdk.jfr.Recording;
 34 import jdk.test.lib.Asserts;
 35 
 36 /**
 37  * @test
 38  * @bug 8220657
 39  * @key jfr
 40  * @requires vm.hasJFR
 41  * @library /test/lib /test/jdk
 42  * @run main/othervm jdk.jfr.jcmd.TestJcmdDumpWithFileName
 43  */
 44 public class TestJcmdDumpWithFileName {
 45 
 46     public static void main(String[] args) throws Exception {
 47         testDumpAll();
 48         testDumpNamed();
 49         testDumpNamedWithFilename();
 50     }
 51 
 52     private static void testDumpAll() throws Exception {
 53         Path p = Path.of(&quot;testDumpAll.jfr&quot;).toAbsolutePath();
 54         try (Recording r = new Recording()) {
 55             r.setName(&quot;testDumpAll&quot;);
 56             r.setDestination(p);
 57             r.start();
 58 
 59             JcmdHelper.jcmd(&quot;JFR.dump&quot;);
 60 
 61             Asserts.assertFalse(namedFile(p), &quot;Unexpected file: &quot; + p.toString());
 62             Asserts.assertTrue(generatedFile(), &quot;Expected generated file&quot;);
 63         }
 64         cleanup();
 65     }
 66 
 67     private static void testDumpNamed() throws Exception {
 68         Path p = Path.of(&quot;testDumpNamed.jfr&quot;).toAbsolutePath();
 69         try (Recording r = new Recording()) {
 70             r.setName(&quot;testDumpNamed&quot;);
 71             r.setDestination(p);
 72             r.start();
 73 
 74             JcmdHelper.jcmd(&quot;JFR.dump&quot;, &quot;name=testDumpNamed&quot;);
 75 
 76             Asserts.assertTrue(namedFile(p), &quot;Expected file: &quot; + p.toString());
 77             Asserts.assertFalse(generatedFile(), &quot;Unexpected generated file&quot;);
 78         }
 79         cleanup();
 80     }
 81 
 82     private static void testDumpNamedWithFilename() throws Exception {
 83         Path p = Path.of(&quot;testDumpNamedWithFilename.jfr&quot;).toAbsolutePath();
 84         Path override = Path.of(&quot;override.jfr&quot;).toAbsolutePath();
 85         try (Recording r = new Recording()) {
 86             r.setName(&quot;testDumpNamedWithFilename&quot;);
 87             r.setDestination(p);
 88             r.start();
 89 
 90             JcmdHelper.jcmd(&quot;JFR.dump&quot;, &quot;name=testDumpNamedWithFilename&quot;, &quot;filename=&quot; + override.toString());
 91 
 92             Asserts.assertFalse(namedFile(p), &quot;Unexpected file: &quot; + p.toString());
 93             Asserts.assertTrue(namedFile(override), &quot;Expected file: &quot; + override.toString());
 94             Asserts.assertFalse(generatedFile(), &quot;Unexpected generated file&quot;);
 95         }
 96         cleanup();
 97     }
 98 
 99     private static boolean namedFile(Path dumpFile) throws IOException {
100         return Files.exists(dumpFile) &amp;&amp; (Files.size(dumpFile) &gt; 0);
101     }
102 
103     private static boolean generatedFile() throws IOException {
104         long pid = ProcessHandle.current().pid();
105         Stream&lt;Path&gt; stream = Files.find(Path.of(&quot;.&quot;), 1, (p, a) -&gt; p.toString()
106                                                                      .matches(&quot;^.*hotspot-pid-&quot; + pid + &quot;-[0-9_]+\\.jfr$&quot;) &amp;&amp; (a.size() &gt; 0L));
107         try (stream) {
108             return stream.findAny()
109                          .isPresent();
110         }
111     }
112 
113     private static void cleanup() throws IOException {
114         Stream&lt;Path&gt; stream = Files.find(Path.of(&quot;.&quot;), 1, (p, a) -&gt; p.toString().endsWith(&quot;.jfr&quot;));
115         try (stream) {
116             stream.forEach(p -&gt; p.toFile().delete());
117         }
118     }
119 
120 }
    </pre>
  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old test/jdk/java/security/SignedObject/Chain.java</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /**
  2  * Copyright (c) 2015, 2018, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 import java.security.Signature;
 25 import java.security.SignedObject;
 26 import java.security.KeyPairGenerator;
 27 import java.security.KeyPair;
 28 import java.security.NoSuchProviderException;
 29 import java.security.PrivateKey;
 30 import java.security.PublicKey;
 31 import java.security.spec.*;
 32 import java.util.*;
 33 import jdk.test.lib.SigTestUtil;
 34 import static jdk.test.lib.SigTestUtil.SignatureType;
 35 
 36 /*
 37  * @test
 38  * @bug 8050374 8181048 8146293
 39  * @summary Verify a chain of signed objects
 40  * @library /test/lib
 41  * @build jdk.test.lib.SigTestUtil
 42  * @run main Chain
 43  */
 44 public class Chain {
 45 
 46     static enum KeyAlg {
 47         RSA(&quot;RSA&quot;),
 48         DSA(&quot;DSA&quot;),
 49         EC(&quot;EC&quot;);
 50 
 51         final String name;
 52 
 53         KeyAlg(String alg) {
 54             this.name = alg;
 55         }
 56     }
 57 
 58     static enum Provider {
 59         Default(&quot;default&quot;),
 60         SunRsaSign(&quot;SunRsaSign&quot;),
 61         Sun(&quot;SUN&quot;),
 62         SunEC(&quot;SunEC&quot;),
 63         SunJSSE(&quot;SunJSSE&quot;),
 64         SunMSCAPI(&quot;SunMSCAPI&quot;);
 65 
 66         final String name;
 67 
 68         Provider(String name) {
 69             this.name = name;
 70         }
 71     }
 72 
 73     static enum SigAlg {
 74         MD2withRSA(&quot;MD2withRSA&quot;),
 75         MD5withRSA(&quot;md5withRSA&quot;),
 76 
 77         SHA1withDSA(&quot;SHA1withDSA&quot;),
 78         SHA224withDSA(&quot;SHA224withDSA&quot;),
 79         SHA256withDSA(&quot;SHA256withDSA&quot;),
 80 
 81         SHA1withRSA(&quot;Sha1withrSA&quot;),
 82         SHA224withRSA(&quot;SHA224withRSA&quot;),
 83         SHA256withRSA(&quot;SHA256withRSA&quot;),
 84         SHA384withRSA(&quot;SHA384withRSA&quot;),
 85         SHA512withRSA(&quot;SHA512withRSA&quot;),
 86         SHA512_224withRSA(&quot;SHA512/224withRSA&quot;),
 87         SHA512_256withRSA(&quot;SHA512/256withRSA&quot;),
 88 
 89         SHA1withECDSA(&quot;SHA1withECDSA&quot;),
 90         SHA256withECDSA(&quot;SHA256withECDSA&quot;),
 91         SHA224withECDSA(&quot;SHA224withECDSA&quot;),
 92         SHA384withECDSA(&quot;SHA384withECDSA&quot;),
 93         SHA512withECDSA(&quot;SHA512withECDSA&quot;),
 94 
 95         MD5andSHA1withRSA(&quot;MD5andSHA1withRSA&quot;),
 96 
 97         RSASSA_PSS(&quot;RSASSA-PSS&quot;);
 98 
 99         final String name;
100 
101         SigAlg(String name) {
102             this.name = name;
103         }
104     }
105 
106     static class Test {
107         final Provider provider;
108         final KeyAlg keyAlg;
109         final SigAlg sigAlg;
110         final int keySize;
111         final AlgorithmParameterSpec sigParams;
112 
113         Test(SigAlg sigAlg, KeyAlg keyAlg, Provider provider) {
114             this(sigAlg, keyAlg, provider, -1, null);
115         }
116 
117         Test(SigAlg sigAlg, KeyAlg keyAlg, Provider provider, int keySize) {
118             this(sigAlg, keyAlg, provider, keySize, null);
119         }
120 
121         Test(SigAlg sigAlg, KeyAlg keyAlg, Provider provider, int keySize,
122                 AlgorithmParameterSpec sigParams) {
123             this.provider = provider;
124             this.keyAlg = keyAlg;
125             this.sigAlg = sigAlg;
126             this.keySize = keySize;
127             this.sigParams = sigParams;
128         }
129 
130         private static String formatParams(AlgorithmParameterSpec aps) {
131             if (aps == null) return &quot;null&quot;;
132             if (aps instanceof PSSParameterSpec) {
133                 PSSParameterSpec p = (PSSParameterSpec) aps;
134                 return String.format(&quot;PSSParameterSpec (%s, %s, %s, %s)&quot;,
135                     p.getDigestAlgorithm(), formatParams(p.getMGFParameters()),
136                     p.getSaltLength(), p.getTrailerField());
137             } else if (aps instanceof MGF1ParameterSpec) {
138                 return &quot;MGF1&quot; +
139                     ((MGF1ParameterSpec)aps).getDigestAlgorithm();
140             } else {
141                 return aps.toString();
142             }
143         }
144 
145         public String toString() {
146             return String.format(&quot;Test: provider = %s, signature alg = %s, &quot;
147                 + &quot; w/ %s, key alg = %s&quot;, provider, sigAlg,
148                 formatParams(sigParams), keyAlg);
149         }
150     }
151 
152     private static final Test[] tests = {
153         new Test(SigAlg.SHA1withDSA, KeyAlg.DSA, Provider.Default, 1024),
154         new Test(SigAlg.MD2withRSA, KeyAlg.RSA, Provider.Default),
155         new Test(SigAlg.MD5withRSA, KeyAlg.RSA, Provider.Default),
156         new Test(SigAlg.SHA1withRSA, KeyAlg.RSA, Provider.Default),
157         new Test(SigAlg.SHA1withDSA, KeyAlg.DSA, Provider.Sun, 1024),
158         new Test(SigAlg.SHA224withDSA, KeyAlg.DSA, Provider.Sun, 2048),
159         new Test(SigAlg.SHA256withDSA, KeyAlg.DSA, Provider.Sun, 2048),
160     };
161 
162     private static final String str = &quot;to-be-signed&quot;;
163     private static final int N = 3;
164 
165     public static void main(String argv[]) {
166         boolean result = Arrays.stream(tests).allMatch((test) -&gt; runTest(test));
167         result &amp;= runTestPSS(2048);
168         if (result) {
169             System.out.println(&quot;All tests passed&quot;);
170         } else {
171             throw new RuntimeException(&quot;Some tests failed&quot;);
172         }
173     }
174 
175     private static boolean runTestPSS(int keysize) {
176         boolean result = true;
177         SigAlg pss = SigAlg.RSASSA_PSS;
178         Iterator&lt;String&gt; mdAlgs = SigTestUtil.getDigestAlgorithms
179             (SignatureType.RSASSA_PSS, keysize).iterator();
180         while (mdAlgs.hasNext()) {
181             result &amp;= runTest(new Test(pss, KeyAlg.RSA, Provider.SunRsaSign,
182                 keysize, SigTestUtil.generateDefaultParameter
183                     (SignatureType.RSASSA_PSS, mdAlgs.next())));
184         }
185         return result;
186     }
187 
188     static boolean runTest(Test test) {
189         System.out.println(test);
190         try {
191             // Generate all private/public key pairs
192             PrivateKey[] privKeys = new PrivateKey[N];
193             PublicKey[] pubKeys = new PublicKey[N];
194             PublicKey[] anotherPubKeys = new PublicKey[N];
195             Signature signature;
196             KeyPairGenerator kpg;
197             if (test.provider != Provider.Default) {
198                 signature = Signature.getInstance(test.sigAlg.name,
199                         test.provider.name);
200                 kpg = KeyPairGenerator.getInstance(
201                     test.keyAlg.name, test.provider.name);
202             } else {
203                 signature = Signature.getInstance(test.sigAlg.name);
204                 kpg = KeyPairGenerator.getInstance(test.keyAlg.name);
205             }
206             if (test.sigParams != null) {
207                 signature.setParameter(test.sigParams);
208             }
209 
210             for (int j=0; j &lt; N; j++) {
211                 if (test.keySize != -1) {
212                     kpg.initialize(test.keySize);
213                 }
214                 KeyPair kp = kpg.genKeyPair();
215                 KeyPair anotherKp = kpg.genKeyPair();
216                 privKeys[j] = kp.getPrivate();
217                 pubKeys[j] = kp.getPublic();
218                 anotherPubKeys[j] = anotherKp.getPublic();
219 
220                 if (Arrays.equals(pubKeys[j].getEncoded(),
221                         anotherPubKeys[j].getEncoded())) {
222                     System.out.println(&quot;Failed: it should not get &quot;
223                             + &quot;the same pair of public key&quot;);
224                     return false;
225                 }
226             }
227 
228             // Create a chain of signed objects
229             SignedObject[] objects = new SignedObject[N];
230             objects[0] = new SignedObject(str, privKeys[0], signature);
231             for (int j = 1; j &lt; N; j++) {
232                 objects[j] = new SignedObject(objects[j - 1], privKeys[j],
233                         signature);
234             }
235 
236             // Verify the chain
237             int n = objects.length - 1;
238             SignedObject object = objects[n];
239             do {
240                 if (!object.verify(pubKeys[n], signature)) {
241                     System.out.println(&quot;Failed: verification failed, n = &quot; + n);
242                     return false;
243                 }
244                 if (object.verify(anotherPubKeys[n], signature)) {
245                     System.out.println(&quot;Failed: verification should not &quot;
246                             + &quot;succeed with wrong public key, n = &quot; + n);
247                     return false;
248                 }
249 
250                 object = (SignedObject) object.getObject();
251                 n--;
252             } while (n &gt; 0);
253 
254             System.out.println(&quot;signed data: &quot; + object.getObject());
255             if (!str.equals(object.getObject())) {
256                 System.out.println(&quot;Failed: signed data is not equal to &quot;
257                         + &quot;original one&quot;);
258                 return false;
259             }
260 
261             System.out.println(&quot;Test passed&quot;);
262             return true;
263         } catch (NoSuchProviderException nspe) {
264             if (test.provider == Provider.SunMSCAPI
265                     &amp;&amp; !System.getProperty(&quot;os.name&quot;).startsWith(&quot;Windows&quot;)) {
266                 System.out.println(&quot;SunMSCAPI is available only on Windows: &quot;
267                         + nspe);
268                 return true;
269             }
270             System.out.println(&quot;Unexpected exception: &quot; + nspe);
271             return false;
272         } catch (Exception e) {
273             System.out.println(&quot;Unexpected exception: &quot; + e);
274             e.printStackTrace(System.out);
275             return false;
276         }
277     }
278 }
279 
    </pre>
  </body>
</html>
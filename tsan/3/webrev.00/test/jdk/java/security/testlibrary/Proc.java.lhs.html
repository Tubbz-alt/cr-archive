<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames test/jdk/java/security/testlibrary/Proc.java</title>
    <link rel="stylesheet" href="../../../../../style.css" />
    <script type="text/javascript" src="../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
<a name="1" id="anc1"></a><span class="line-modified">  2  * Copyright (c) 2013, 2018, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 import java.io.BufferedReader;
 25 import java.io.File;
 26 import java.io.IOException;
 27 import java.io.InputStreamReader;
<a name="2" id="anc2"></a>


 28 import java.nio.file.Files;
 29 import java.nio.file.Path;
 30 import java.nio.file.Paths;
 31 import java.security.Permission;
 32 import java.security.Principal;
 33 import java.util.ArrayList;
 34 import java.util.Arrays;
 35 import java.util.Base64;
 36 import java.util.Collections;
 37 import java.util.HashMap;
 38 import java.util.List;
 39 import java.util.Map;
 40 import java.util.Map.Entry;
 41 import java.util.stream.Collectors;
 42 import java.util.stream.Stream;
 43 
 44 /**
 45  * This is a test library that makes writing a Java test that spawns multiple
 46  * Java processes easily.
 47  *
 48  * Usage:
 49  *
 50  *    Proc.create(&quot;Clazz&quot;)      // The class to launch
 51  *        .args(&quot;x&quot;)            // with args
 52  *        .env(&quot;env&quot;, &quot;value&quot;)  // and an environment variable
 53  *        .prop(&quot;key&quot;,&quot;value&quot;)  // and a system property
 54  *        .grant(file)          // grant codes in this codebase
 55  *        .perm(perm)           // with the permission
 56  *        .start();             // and start
 57  *
 58  * create/start must be called, args/env/prop/perm can be called zero or
 59  * multiple times between create and start.
 60  *
 61  * The controller can call inheritIO to share its I/O to the process.
 62  * Otherwise, it can send data into a proc&#39;s stdin with write/println, and
 63  * read its stdout with readLine. stderr is always redirected to a file
 64  * unless nodump() is called. A protocol is designed to make
 65  * data exchange among the controller and the processes super easy, in which
 66  * useful data are always printed with a special prefix (&quot;PROCISFUN:&quot;).
 67  * If the data is binary, make it BASE64.
 68  *
 69  * For example:
 70  *
 71  * - A producer Proc calls Proc.binOut() or Proc.textOut() to send out data.
 72  *   This method would prints to the stdout something like
 73  *
 74  *      PROCISFUN:[raw text or base64 binary]
 75  *
 76  * - The controller calls producer.readData() to get the content. This method
 77  *   ignores all other output and only reads lines starting with &quot;PROCISFUN:&quot;.
 78  *
 79  * - The controller does not care if the context is text or base64, it simply
 80  *   feeds the data to a consumer Proc by calling consumer.println(data).
 81  *   This will be printed into System.in of the consumer process.
 82  *
 83  * - The consumer Proc calls Proc.binIn() or Proc.textIn() to read the data.
 84  *   The first method de-base64 the input and return a byte[] block.
 85  *
 86  * Please note only plain ASCII is supported in raw text at the moment.
 87  *
 88  * As the Proc objects are hidden so deeply, two static methods, d(String) and
 89  * d(Throwable) are provided to output info into stderr, where they will
 90  * normally be appended messages to a debug file (unless nodump() is called).
 91  * Developers can view the messages in real time by calling
 92  *
 93  *    {@code tail -f stderr.&lt;debug&gt;}
 94  *
 95  * TODO:
 96  *
 97  * . launch java tools, say, keytool
 98  * . launch another version of java
 99  * . start in another directory
100  * . start and finish using one method
101  *
102  * This is not a test, but is the core of
103  * JDK-8009977: A test library to launch multiple Java processes
104  */
105 public class Proc {
106     private Process p;
107     private BufferedReader br;      // the stdout of a process
108     private String launcher;        // Optional: the java program
109 
110     private List&lt;String&gt; args = new ArrayList&lt;&gt;();
111     private Map&lt;String,String&gt; env = new HashMap&lt;&gt;();
112     private Map&lt;String,String&gt; prop = new HashMap();
<a name="3" id="anc3"></a>
113     private boolean inheritIO = false;
114     private boolean noDump = false;
115 
116     private List&lt;String&gt; cp;        // user-provided classpath
117     private String clazz;           // Class to launch
118     private String debug;           // debug flag, controller will show data
119                                     // transfer between procs. If debug is set,
120                                     // it MUST be different between Procs.
121 
122     final private static String PREFIX = &quot;PROCISFUN:&quot;;
123 
124     // policy file
125     final private StringBuilder perms = new StringBuilder();
126     // temporary saving the grant line in a policy file
127     final private StringBuilder grant = new StringBuilder();
128 
129     // The following methods are called by controllers
130 
131     // Creates a Proc by the Java class name, launcher is an optional
132     // argument to specify the java program
133     public static Proc create(String clazz, String... launcher) {
134         Proc pc = new Proc();
135         pc.clazz = clazz;
136         if (launcher.length &gt; 0) {
137             pc.launcher = launcher[0];
138         }
139         return pc;
140     }
141     // Sets inheritIO flag to proc. If set, proc will same I/O channels as
142     // teh controller. Otherwise, its stdin/stdout is untouched, and its
143     // stderr is redirected to DFILE.
144     public Proc inheritIO() {
145         inheritIO = true;
146         return this;
147     }
148     // When called, stderr inherits parent stderr, otherwise, append to a file
149     public Proc nodump() {
150         noDump = true;
151         return this;
152     }
153     // Specifies some args. Can be called multiple times.
154     public Proc args(String... args) {
155         for (String c: args) {
156             this.args.add(c);
157         }
158         return this;
159     }
160     // Returns debug prefix
161     public String debug() {
162         return debug;
163     }
164     // Enables debug with prefix
165     public Proc debug(String title) {
166         debug = title;
167         return this;
168     }
169     // Specifies an env var. Can be called multiple times.
170     public Proc env(String a, String b) {
171         env.put(a, b);
172         return this;
173     }
174     // Specifies a Java system property. Can be called multiple times.
175     public Proc prop(String a, String b) {
176         prop.put(a, b);
177         return this;
178     }
<a name="4" id="anc4"></a>




179     // Inherit the value of a system property
180     public Proc inheritProp(String k) {
181         String v = System.getProperty(k);
182         if (v != null) {
183             prop.put(k, v);
184         }
185         return this;
186     }
187     // Sets classpath. If not called, Proc will choose a classpath. If called
188     // with no arg, no classpath will be used. Can be called multiple times.
189     public Proc cp(String... s) {
190         if (cp == null) {
191             cp = new ArrayList&lt;&gt;();
192         }
193         cp.addAll(Arrays.asList(s));
194         return this;
195     }
196     // Adds a permission to policy. Can be called multiple times.
197     // All perm() calls after a series of grant() calls are grouped into
198     // a single grant block. perm() calls before any grant() call are grouped
199     // into a grant block with no restriction.
200     // Please note that in order to make permissions effective, also call
201     // prop(&quot;java.security.manager&quot;, &quot;&quot;).
202     public Proc perm(Permission p) {
203         if (grant.length() != 0) {      // Right after grant(s)
204             if (perms.length() != 0) {  // Not first block
205                 perms.append(&quot;};\n&quot;);
206             }
207             perms.append(&quot;grant &quot;).append(grant).append(&quot; {\n&quot;);
208             grant.setLength(0);
209         } else {
210             if (perms.length() == 0) {  // First block w/o restriction
211                 perms.append(&quot;grant {\n&quot;);
212             }
213         }
214         if (p.getActions().isEmpty()) {
215             String s = String.format(&quot;%s \&quot;%s\&quot;&quot;,
216                     p.getClass().getCanonicalName(),
217                     p.getName()
218                             .replace(&quot;\\&quot;, &quot;\\\\&quot;).replace(&quot;\&quot;&quot;, &quot;\\\&quot;&quot;));
219             perms.append(&quot;    permission &quot;).append(s).append(&quot;;\n&quot;);
220         } else {
221             String s = String.format(&quot;%s \&quot;%s\&quot;, \&quot;%s\&quot;&quot;,
222                     p.getClass().getCanonicalName(),
223                     p.getName()
224                             .replace(&quot;\\&quot;, &quot;\\\\&quot;).replace(&quot;\&quot;&quot;, &quot;\\\&quot;&quot;),
225                     p.getActions());
226             perms.append(&quot;    permission &quot;).append(s).append(&quot;;\n&quot;);
227         }
228         return this;
229     }
230 
231     // Adds a grant option to policy. If called in a row, a single grant block
232     // with all options will be created. If there are perm() call(s) between
233     // grant() calls, they belong to different grant blocks
234 
235     // grant on a principal
236     public Proc grant(Principal p) {
237         grant.append(&quot;principal &quot;).append(p.getClass().getName())
238                 .append(&quot; \&quot;&quot;).append(p.getName()).append(&quot;\&quot;, &quot;);
239         return this;
240     }
241     // grant on a codebase
242     public Proc grant(File f) {
243         grant.append(&quot;codebase \&quot;&quot;).append(f.toURI()).append(&quot;\&quot;, &quot;);
244         return this;
245     }
246     // arbitrary grant
247     public Proc grant(String v) {
248         grant.append(v).append(&quot;, &quot;);
249         return this;
250     }
251     // Starts the proc
252     public Proc start() throws IOException {
253         List&lt;String&gt; cmd = new ArrayList&lt;&gt;();
254         boolean hasModules;
255         if (launcher != null) {
256             cmd.add(launcher);
257             File base = new File(launcher).getParentFile().getParentFile();
258             hasModules = new File(base, &quot;modules&quot;).exists() ||
259                     new File(base, &quot;jmods&quot;).exists();
260         } else {
261             cmd.add(new File(new File(System.getProperty(&quot;java.home&quot;), &quot;bin&quot;),
262                         &quot;java&quot;).getPath());
263             hasModules = true;
264         }
265 
266         if (hasModules) {
267             Stream.of(jdk.internal.misc.VM.getRuntimeArguments())
268                     .filter(arg -&gt; arg.startsWith(&quot;--add-exports=&quot;) ||
269                                    arg.startsWith(&quot;--add-opens=&quot;))
270                     .forEach(cmd::add);
271         }
272 
273         Collections.addAll(cmd, splitProperty(&quot;test.vm.opts&quot;));
274         Collections.addAll(cmd, splitProperty(&quot;test.java.opts&quot;));
275 
276         if (cp == null) {
277             cmd.add(&quot;-cp&quot;);
278             cmd.add(System.getProperty(&quot;test.class.path&quot;) + File.pathSeparator +
279                     System.getProperty(&quot;test.src.path&quot;));
280         } else if (!cp.isEmpty()) {
281             cmd.add(&quot;-cp&quot;);
282             cmd.add(cp.stream().collect(Collectors.joining(File.pathSeparator)));
283         }
284 
<a name="5" id="anc5"></a>










285         for (Entry&lt;String,String&gt; e: prop.entrySet()) {
286             cmd.add(&quot;-D&quot; + e.getKey() + &quot;=&quot; + e.getValue());
287         }
288         if (perms.length() &gt; 0) {
289             Path p = Paths.get(getId(&quot;policy&quot;)).toAbsolutePath();
290             perms.append(&quot;};\n&quot;);
291             Files.write(p, perms.toString().getBytes());
292             cmd.add(&quot;-Djava.security.policy=&quot; + p.toString());
293         }
294         cmd.add(clazz);
295         for (String s: args) {
296             cmd.add(s);
297         }
298         if (debug != null) {
299             System.out.println(&quot;PROC: &quot; + debug + &quot; cmdline: &quot; + cmd);
300             for (String e : env.keySet()) {
301                 System.out.print(e + &quot;=&quot; + env.get(e) + &quot; &quot;);
302             }
303             for (String c : cmd) {
304                 if (c.indexOf(&#39;\\&#39;) &gt;= 0 || c.indexOf(&#39; &#39;) &gt; 0) {
305                     System.out.print(&#39;\&#39;&#39; + c + &#39;\&#39;&#39;);
306                 } else {
307                     System.out.print(c);
308                 }
309                 System.out.print(&#39; &#39;);
310             }
311             System.out.println();
312         }
313         ProcessBuilder pb = new ProcessBuilder(cmd);
314         for (Entry&lt;String,String&gt; e: env.entrySet()) {
315             pb.environment().put(e.getKey(), e.getValue());
316         }
317         if (inheritIO) {
318             pb.inheritIO();
319         } else if (noDump) {
320             pb.redirectError(ProcessBuilder.Redirect.INHERIT);
321         } else {
322             pb.redirectError(ProcessBuilder.Redirect
323                     .appendTo(new File(getId(&quot;stderr&quot;))));
324         }
325         p = pb.start();
326         br = new BufferedReader(new InputStreamReader(p.getInputStream()));
327         return this;
328     }
329     String getId(String suffix) {
330         if (debug != null) {
331             return debug + &quot;.&quot; + suffix;
332         } else {
333             return System.identityHashCode(this) + &quot;.&quot; + suffix;
334         }
335     }
336     // Reads a line from stdout of proc
337     public String readLine() throws IOException {
338         String s = br.readLine();
339         if (debug != null) {
340             System.out.println(&quot;PROC: &quot; + debug + &quot; readline: &quot; +
341                     (s == null ? &quot;&lt;EOF&gt;&quot; : s));
342         }
343         return s;
344     }
345     // Reads a special line from stdout of proc
346     public String readData() throws Exception {
347         while (true) {
348             String s = readLine();
349             if (s == null) {
350                 if (p.waitFor() != 0) {
351                     throw new Exception(&quot;Proc abnormal end&quot;);
352                 } else {
353                     return s;
354                 }
355             }
356             if (s.startsWith(PREFIX)) {
357                 return s.substring(PREFIX.length());
358             }
359         }
360     }
361     // Writes text into stdin of proc
362     public void println(String s) throws IOException {
363         if (debug != null) {
364             System.out.println(&quot;PROC: &quot; + debug + &quot; println: &quot; + s);
365         }
366         write((s + &quot;\n&quot;).getBytes());
367     }
368     // Writes data into stdin of proc
369     public void write(byte[] b) throws IOException {
370         p.getOutputStream().write(b);
371         p.getOutputStream().flush();
372     }
373     // Reads all output and wait for process end
374     public int waitFor() throws Exception {
375         while (true) {
376             String s = readLine();
377             if (s == null) {
378                 break;
379             }
380         }
381         return p.waitFor();
382     }
<a name="6" id="anc6"></a>





383 
384     // The following methods are used inside a proc
385 
386     // Writes out a BASE64 binary with a prefix
387     public static void binOut(byte[] data) {
388         System.out.println(PREFIX + Base64.getEncoder().encodeToString(data));
389     }
390     // Reads in a line of BASE64 binary
391     public static byte[] binIn() throws Exception {
392         return Base64.getDecoder().decode(textIn());
393     }
394     // Writes out a text with a prefix
395     public static void textOut(String data) {
396         System.out.println(PREFIX + data);
397     }
398     // Reads in a line of text
399     public static String textIn() throws Exception {
400         StringBuilder sb = new StringBuilder();
401         boolean isEmpty = true;
402         while (true) {
403             int i = System.in.read();
404             if (i == -1) {
405                 break;
406             }
407             isEmpty = false;
408             if (i == &#39;\n&#39;) {
409                 break;
410             }
411             if (i != 13) {
412                 // Force it to a char, so only simple ASCII works.
413                 sb.append((char)i);
414             }
415         }
416         return isEmpty ? null : sb.toString();
417     }
418     // Sends string to stderr. If inheritIO is not called, they will
419     // be collected into DFILE
420     public static void d(String s) throws IOException {
421         System.err.println(s);
422     }
423     // Sends an exception to stderr
424     public static void d(Throwable e) throws IOException {
425         e.printStackTrace();
426     }
427 
428     private static String[] splitProperty(String prop) {
429         String s = System.getProperty(prop);
430         if (s == null || s.trim().isEmpty()) {
431             return new String[] {};
432         }
433         return s.trim().split(&quot;\\s+&quot;);
434     }
435 }
<a name="7" id="anc7"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="7" type="hidden" />
</body>
</html>
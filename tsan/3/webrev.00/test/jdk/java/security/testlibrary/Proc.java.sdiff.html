<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff test/jdk/java/security/testlibrary/Proc.java</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
<body>
<center><a href="../cert/X509Certificate/VerifyDefault.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="SimpleOCSPServer.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>test/jdk/java/security/testlibrary/Proc.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2013, 2018, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 import java.io.BufferedReader;
 25 import java.io.File;
 26 import java.io.IOException;
 27 import java.io.InputStreamReader;



 28 import java.nio.file.Files;
 29 import java.nio.file.Path;
 30 import java.nio.file.Paths;
 31 import java.security.Permission;
 32 import java.security.Principal;
 33 import java.util.ArrayList;
 34 import java.util.Arrays;
 35 import java.util.Base64;
 36 import java.util.Collections;
 37 import java.util.HashMap;
 38 import java.util.List;
 39 import java.util.Map;
 40 import java.util.Map.Entry;
 41 import java.util.stream.Collectors;
 42 import java.util.stream.Stream;
 43 
 44 /**
 45  * This is a test library that makes writing a Java test that spawns multiple
 46  * Java processes easily.
 47  *
</pre>
<hr />
<pre>
 93  *    {@code tail -f stderr.&lt;debug&gt;}
 94  *
 95  * TODO:
 96  *
 97  * . launch java tools, say, keytool
 98  * . launch another version of java
 99  * . start in another directory
100  * . start and finish using one method
101  *
102  * This is not a test, but is the core of
103  * JDK-8009977: A test library to launch multiple Java processes
104  */
105 public class Proc {
106     private Process p;
107     private BufferedReader br;      // the stdout of a process
108     private String launcher;        // Optional: the java program
109 
110     private List&lt;String&gt; args = new ArrayList&lt;&gt;();
111     private Map&lt;String,String&gt; env = new HashMap&lt;&gt;();
112     private Map&lt;String,String&gt; prop = new HashMap();

113     private boolean inheritIO = false;
114     private boolean noDump = false;
115 
116     private List&lt;String&gt; cp;        // user-provided classpath
117     private String clazz;           // Class to launch
118     private String debug;           // debug flag, controller will show data
119                                     // transfer between procs. If debug is set,
120                                     // it MUST be different between Procs.
121 
122     final private static String PREFIX = &quot;PROCISFUN:&quot;;
123 
124     // policy file
125     final private StringBuilder perms = new StringBuilder();
126     // temporary saving the grant line in a policy file
127     final private StringBuilder grant = new StringBuilder();
128 
129     // The following methods are called by controllers
130 
131     // Creates a Proc by the Java class name, launcher is an optional
132     // argument to specify the java program
</pre>
<hr />
<pre>
159     }
160     // Returns debug prefix
161     public String debug() {
162         return debug;
163     }
164     // Enables debug with prefix
165     public Proc debug(String title) {
166         debug = title;
167         return this;
168     }
169     // Specifies an env var. Can be called multiple times.
170     public Proc env(String a, String b) {
171         env.put(a, b);
172         return this;
173     }
174     // Specifies a Java system property. Can be called multiple times.
175     public Proc prop(String a, String b) {
176         prop.put(a, b);
177         return this;
178     }





179     // Inherit the value of a system property
180     public Proc inheritProp(String k) {
181         String v = System.getProperty(k);
182         if (v != null) {
183             prop.put(k, v);
184         }
185         return this;
186     }
187     // Sets classpath. If not called, Proc will choose a classpath. If called
188     // with no arg, no classpath will be used. Can be called multiple times.
189     public Proc cp(String... s) {
190         if (cp == null) {
191             cp = new ArrayList&lt;&gt;();
192         }
193         cp.addAll(Arrays.asList(s));
194         return this;
195     }
196     // Adds a permission to policy. Can be called multiple times.
197     // All perm() calls after a series of grant() calls are grouped into
198     // a single grant block. perm() calls before any grant() call are grouped
</pre>
<hr />
<pre>
265 
266         if (hasModules) {
267             Stream.of(jdk.internal.misc.VM.getRuntimeArguments())
268                     .filter(arg -&gt; arg.startsWith(&quot;--add-exports=&quot;) ||
269                                    arg.startsWith(&quot;--add-opens=&quot;))
270                     .forEach(cmd::add);
271         }
272 
273         Collections.addAll(cmd, splitProperty(&quot;test.vm.opts&quot;));
274         Collections.addAll(cmd, splitProperty(&quot;test.java.opts&quot;));
275 
276         if (cp == null) {
277             cmd.add(&quot;-cp&quot;);
278             cmd.add(System.getProperty(&quot;test.class.path&quot;) + File.pathSeparator +
279                     System.getProperty(&quot;test.src.path&quot;));
280         } else if (!cp.isEmpty()) {
281             cmd.add(&quot;-cp&quot;);
282             cmd.add(cp.stream().collect(Collectors.joining(File.pathSeparator)));
283         }
284 











285         for (Entry&lt;String,String&gt; e: prop.entrySet()) {
286             cmd.add(&quot;-D&quot; + e.getKey() + &quot;=&quot; + e.getValue());
287         }
288         if (perms.length() &gt; 0) {
289             Path p = Paths.get(getId(&quot;policy&quot;)).toAbsolutePath();
290             perms.append(&quot;};\n&quot;);
291             Files.write(p, perms.toString().getBytes());
292             cmd.add(&quot;-Djava.security.policy=&quot; + p.toString());
293         }
294         cmd.add(clazz);
295         for (String s: args) {
296             cmd.add(s);
297         }
298         if (debug != null) {
299             System.out.println(&quot;PROC: &quot; + debug + &quot; cmdline: &quot; + cmd);
300             for (String e : env.keySet()) {
301                 System.out.print(e + &quot;=&quot; + env.get(e) + &quot; &quot;);
302             }
303             for (String c : cmd) {
304                 if (c.indexOf(&#39;\\&#39;) &gt;= 0 || c.indexOf(&#39; &#39;) &gt; 0) {
</pre>
<hr />
<pre>
363         if (debug != null) {
364             System.out.println(&quot;PROC: &quot; + debug + &quot; println: &quot; + s);
365         }
366         write((s + &quot;\n&quot;).getBytes());
367     }
368     // Writes data into stdin of proc
369     public void write(byte[] b) throws IOException {
370         p.getOutputStream().write(b);
371         p.getOutputStream().flush();
372     }
373     // Reads all output and wait for process end
374     public int waitFor() throws Exception {
375         while (true) {
376             String s = readLine();
377             if (s == null) {
378                 break;
379             }
380         }
381         return p.waitFor();
382     }






383 
384     // The following methods are used inside a proc
385 
386     // Writes out a BASE64 binary with a prefix
387     public static void binOut(byte[] data) {
388         System.out.println(PREFIX + Base64.getEncoder().encodeToString(data));
389     }
390     // Reads in a line of BASE64 binary
391     public static byte[] binIn() throws Exception {
392         return Base64.getDecoder().decode(textIn());
393     }
394     // Writes out a text with a prefix
395     public static void textOut(String data) {
396         System.out.println(PREFIX + data);
397     }
398     // Reads in a line of text
399     public static String textIn() throws Exception {
400         StringBuilder sb = new StringBuilder();
401         boolean isEmpty = true;
402         while (true) {
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2013, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 import java.io.BufferedReader;
 25 import java.io.File;
 26 import java.io.IOException;
 27 import java.io.InputStreamReader;
<span class="line-added"> 28 import java.io.OutputStream;</span>
<span class="line-added"> 29 import java.io.PrintStream;</span>
<span class="line-added"> 30 import java.io.UncheckedIOException;</span>
 31 import java.nio.file.Files;
 32 import java.nio.file.Path;
 33 import java.nio.file.Paths;
 34 import java.security.Permission;
 35 import java.security.Principal;
 36 import java.util.ArrayList;
 37 import java.util.Arrays;
 38 import java.util.Base64;
 39 import java.util.Collections;
 40 import java.util.HashMap;
 41 import java.util.List;
 42 import java.util.Map;
 43 import java.util.Map.Entry;
 44 import java.util.stream.Collectors;
 45 import java.util.stream.Stream;
 46 
 47 /**
 48  * This is a test library that makes writing a Java test that spawns multiple
 49  * Java processes easily.
 50  *
</pre>
<hr />
<pre>
 96  *    {@code tail -f stderr.&lt;debug&gt;}
 97  *
 98  * TODO:
 99  *
100  * . launch java tools, say, keytool
101  * . launch another version of java
102  * . start in another directory
103  * . start and finish using one method
104  *
105  * This is not a test, but is the core of
106  * JDK-8009977: A test library to launch multiple Java processes
107  */
108 public class Proc {
109     private Process p;
110     private BufferedReader br;      // the stdout of a process
111     private String launcher;        // Optional: the java program
112 
113     private List&lt;String&gt; args = new ArrayList&lt;&gt;();
114     private Map&lt;String,String&gt; env = new HashMap&lt;&gt;();
115     private Map&lt;String,String&gt; prop = new HashMap();
<span class="line-added">116     private Map&lt;String,String&gt; secprop = new HashMap();</span>
117     private boolean inheritIO = false;
118     private boolean noDump = false;
119 
120     private List&lt;String&gt; cp;        // user-provided classpath
121     private String clazz;           // Class to launch
122     private String debug;           // debug flag, controller will show data
123                                     // transfer between procs. If debug is set,
124                                     // it MUST be different between Procs.
125 
126     final private static String PREFIX = &quot;PROCISFUN:&quot;;
127 
128     // policy file
129     final private StringBuilder perms = new StringBuilder();
130     // temporary saving the grant line in a policy file
131     final private StringBuilder grant = new StringBuilder();
132 
133     // The following methods are called by controllers
134 
135     // Creates a Proc by the Java class name, launcher is an optional
136     // argument to specify the java program
</pre>
<hr />
<pre>
163     }
164     // Returns debug prefix
165     public String debug() {
166         return debug;
167     }
168     // Enables debug with prefix
169     public Proc debug(String title) {
170         debug = title;
171         return this;
172     }
173     // Specifies an env var. Can be called multiple times.
174     public Proc env(String a, String b) {
175         env.put(a, b);
176         return this;
177     }
178     // Specifies a Java system property. Can be called multiple times.
179     public Proc prop(String a, String b) {
180         prop.put(a, b);
181         return this;
182     }
<span class="line-added">183     // Specifies a security property. Can be called multiple times.</span>
<span class="line-added">184     public Proc secprop(String a, String b) {</span>
<span class="line-added">185         secprop.put(a, b);</span>
<span class="line-added">186         return this;</span>
<span class="line-added">187     }</span>
188     // Inherit the value of a system property
189     public Proc inheritProp(String k) {
190         String v = System.getProperty(k);
191         if (v != null) {
192             prop.put(k, v);
193         }
194         return this;
195     }
196     // Sets classpath. If not called, Proc will choose a classpath. If called
197     // with no arg, no classpath will be used. Can be called multiple times.
198     public Proc cp(String... s) {
199         if (cp == null) {
200             cp = new ArrayList&lt;&gt;();
201         }
202         cp.addAll(Arrays.asList(s));
203         return this;
204     }
205     // Adds a permission to policy. Can be called multiple times.
206     // All perm() calls after a series of grant() calls are grouped into
207     // a single grant block. perm() calls before any grant() call are grouped
</pre>
<hr />
<pre>
274 
275         if (hasModules) {
276             Stream.of(jdk.internal.misc.VM.getRuntimeArguments())
277                     .filter(arg -&gt; arg.startsWith(&quot;--add-exports=&quot;) ||
278                                    arg.startsWith(&quot;--add-opens=&quot;))
279                     .forEach(cmd::add);
280         }
281 
282         Collections.addAll(cmd, splitProperty(&quot;test.vm.opts&quot;));
283         Collections.addAll(cmd, splitProperty(&quot;test.java.opts&quot;));
284 
285         if (cp == null) {
286             cmd.add(&quot;-cp&quot;);
287             cmd.add(System.getProperty(&quot;test.class.path&quot;) + File.pathSeparator +
288                     System.getProperty(&quot;test.src.path&quot;));
289         } else if (!cp.isEmpty()) {
290             cmd.add(&quot;-cp&quot;);
291             cmd.add(cp.stream().collect(Collectors.joining(File.pathSeparator)));
292         }
293 
<span class="line-added">294         if (!secprop.isEmpty()) {</span>
<span class="line-added">295             Path p = Path.of(getId(&quot;security&quot;));</span>
<span class="line-added">296             try (OutputStream fos = Files.newOutputStream(p);</span>
<span class="line-added">297                  PrintStream ps = new PrintStream(fos)) {</span>
<span class="line-added">298                 secprop.forEach((k,v) -&gt; ps.println(k + &quot;=&quot; + v));</span>
<span class="line-added">299             } catch (IOException e) {</span>
<span class="line-added">300                 throw new UncheckedIOException(e);</span>
<span class="line-added">301             }</span>
<span class="line-added">302             prop.put(&quot;java.security.properties&quot;, p.toString());</span>
<span class="line-added">303         }</span>
<span class="line-added">304 </span>
305         for (Entry&lt;String,String&gt; e: prop.entrySet()) {
306             cmd.add(&quot;-D&quot; + e.getKey() + &quot;=&quot; + e.getValue());
307         }
308         if (perms.length() &gt; 0) {
309             Path p = Paths.get(getId(&quot;policy&quot;)).toAbsolutePath();
310             perms.append(&quot;};\n&quot;);
311             Files.write(p, perms.toString().getBytes());
312             cmd.add(&quot;-Djava.security.policy=&quot; + p.toString());
313         }
314         cmd.add(clazz);
315         for (String s: args) {
316             cmd.add(s);
317         }
318         if (debug != null) {
319             System.out.println(&quot;PROC: &quot; + debug + &quot; cmdline: &quot; + cmd);
320             for (String e : env.keySet()) {
321                 System.out.print(e + &quot;=&quot; + env.get(e) + &quot; &quot;);
322             }
323             for (String c : cmd) {
324                 if (c.indexOf(&#39;\\&#39;) &gt;= 0 || c.indexOf(&#39; &#39;) &gt; 0) {
</pre>
<hr />
<pre>
383         if (debug != null) {
384             System.out.println(&quot;PROC: &quot; + debug + &quot; println: &quot; + s);
385         }
386         write((s + &quot;\n&quot;).getBytes());
387     }
388     // Writes data into stdin of proc
389     public void write(byte[] b) throws IOException {
390         p.getOutputStream().write(b);
391         p.getOutputStream().flush();
392     }
393     // Reads all output and wait for process end
394     public int waitFor() throws Exception {
395         while (true) {
396             String s = readLine();
397             if (s == null) {
398                 break;
399             }
400         }
401         return p.waitFor();
402     }
<span class="line-added">403     // Wait for process end with expected exit code</span>
<span class="line-added">404     public void waitFor(int expected) throws Exception {</span>
<span class="line-added">405         if (p.waitFor() != expected) {</span>
<span class="line-added">406             throw new RuntimeException(&quot;Exit code not &quot; + expected);</span>
<span class="line-added">407         }</span>
<span class="line-added">408     }</span>
409 
410     // The following methods are used inside a proc
411 
412     // Writes out a BASE64 binary with a prefix
413     public static void binOut(byte[] data) {
414         System.out.println(PREFIX + Base64.getEncoder().encodeToString(data));
415     }
416     // Reads in a line of BASE64 binary
417     public static byte[] binIn() throws Exception {
418         return Base64.getDecoder().decode(textIn());
419     }
420     // Writes out a text with a prefix
421     public static void textOut(String data) {
422         System.out.println(PREFIX + data);
423     }
424     // Reads in a line of text
425     public static String textIn() throws Exception {
426         StringBuilder sb = new StringBuilder();
427         boolean isEmpty = true;
428         while (true) {
</pre>
</td>
</tr>
</table>
<center><a href="../cert/X509Certificate/VerifyDefault.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="SimpleOCSPServer.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
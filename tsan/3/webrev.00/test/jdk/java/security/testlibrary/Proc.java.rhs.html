<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames test/jdk/java/security/testlibrary/Proc.java</title>
    <link rel="stylesheet" href="../../../../../style.css" />
    <script type="text/javascript" src="../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
<a name="1" id="anc1"></a><span class="line-modified">  2  * Copyright (c) 2013, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 import java.io.BufferedReader;
 25 import java.io.File;
 26 import java.io.IOException;
 27 import java.io.InputStreamReader;
<a name="2" id="anc2"></a><span class="line-added"> 28 import java.io.OutputStream;</span>
<span class="line-added"> 29 import java.io.PrintStream;</span>
<span class="line-added"> 30 import java.io.UncheckedIOException;</span>
 31 import java.nio.file.Files;
 32 import java.nio.file.Path;
 33 import java.nio.file.Paths;
 34 import java.security.Permission;
 35 import java.security.Principal;
 36 import java.util.ArrayList;
 37 import java.util.Arrays;
 38 import java.util.Base64;
 39 import java.util.Collections;
 40 import java.util.HashMap;
 41 import java.util.List;
 42 import java.util.Map;
 43 import java.util.Map.Entry;
 44 import java.util.stream.Collectors;
 45 import java.util.stream.Stream;
 46 
 47 /**
 48  * This is a test library that makes writing a Java test that spawns multiple
 49  * Java processes easily.
 50  *
 51  * Usage:
 52  *
 53  *    Proc.create(&quot;Clazz&quot;)      // The class to launch
 54  *        .args(&quot;x&quot;)            // with args
 55  *        .env(&quot;env&quot;, &quot;value&quot;)  // and an environment variable
 56  *        .prop(&quot;key&quot;,&quot;value&quot;)  // and a system property
 57  *        .grant(file)          // grant codes in this codebase
 58  *        .perm(perm)           // with the permission
 59  *        .start();             // and start
 60  *
 61  * create/start must be called, args/env/prop/perm can be called zero or
 62  * multiple times between create and start.
 63  *
 64  * The controller can call inheritIO to share its I/O to the process.
 65  * Otherwise, it can send data into a proc&#39;s stdin with write/println, and
 66  * read its stdout with readLine. stderr is always redirected to a file
 67  * unless nodump() is called. A protocol is designed to make
 68  * data exchange among the controller and the processes super easy, in which
 69  * useful data are always printed with a special prefix (&quot;PROCISFUN:&quot;).
 70  * If the data is binary, make it BASE64.
 71  *
 72  * For example:
 73  *
 74  * - A producer Proc calls Proc.binOut() or Proc.textOut() to send out data.
 75  *   This method would prints to the stdout something like
 76  *
 77  *      PROCISFUN:[raw text or base64 binary]
 78  *
 79  * - The controller calls producer.readData() to get the content. This method
 80  *   ignores all other output and only reads lines starting with &quot;PROCISFUN:&quot;.
 81  *
 82  * - The controller does not care if the context is text or base64, it simply
 83  *   feeds the data to a consumer Proc by calling consumer.println(data).
 84  *   This will be printed into System.in of the consumer process.
 85  *
 86  * - The consumer Proc calls Proc.binIn() or Proc.textIn() to read the data.
 87  *   The first method de-base64 the input and return a byte[] block.
 88  *
 89  * Please note only plain ASCII is supported in raw text at the moment.
 90  *
 91  * As the Proc objects are hidden so deeply, two static methods, d(String) and
 92  * d(Throwable) are provided to output info into stderr, where they will
 93  * normally be appended messages to a debug file (unless nodump() is called).
 94  * Developers can view the messages in real time by calling
 95  *
 96  *    {@code tail -f stderr.&lt;debug&gt;}
 97  *
 98  * TODO:
 99  *
100  * . launch java tools, say, keytool
101  * . launch another version of java
102  * . start in another directory
103  * . start and finish using one method
104  *
105  * This is not a test, but is the core of
106  * JDK-8009977: A test library to launch multiple Java processes
107  */
108 public class Proc {
109     private Process p;
110     private BufferedReader br;      // the stdout of a process
111     private String launcher;        // Optional: the java program
112 
113     private List&lt;String&gt; args = new ArrayList&lt;&gt;();
114     private Map&lt;String,String&gt; env = new HashMap&lt;&gt;();
115     private Map&lt;String,String&gt; prop = new HashMap();
<a name="3" id="anc3"></a><span class="line-added">116     private Map&lt;String,String&gt; secprop = new HashMap();</span>
117     private boolean inheritIO = false;
118     private boolean noDump = false;
119 
120     private List&lt;String&gt; cp;        // user-provided classpath
121     private String clazz;           // Class to launch
122     private String debug;           // debug flag, controller will show data
123                                     // transfer between procs. If debug is set,
124                                     // it MUST be different between Procs.
125 
126     final private static String PREFIX = &quot;PROCISFUN:&quot;;
127 
128     // policy file
129     final private StringBuilder perms = new StringBuilder();
130     // temporary saving the grant line in a policy file
131     final private StringBuilder grant = new StringBuilder();
132 
133     // The following methods are called by controllers
134 
135     // Creates a Proc by the Java class name, launcher is an optional
136     // argument to specify the java program
137     public static Proc create(String clazz, String... launcher) {
138         Proc pc = new Proc();
139         pc.clazz = clazz;
140         if (launcher.length &gt; 0) {
141             pc.launcher = launcher[0];
142         }
143         return pc;
144     }
145     // Sets inheritIO flag to proc. If set, proc will same I/O channels as
146     // teh controller. Otherwise, its stdin/stdout is untouched, and its
147     // stderr is redirected to DFILE.
148     public Proc inheritIO() {
149         inheritIO = true;
150         return this;
151     }
152     // When called, stderr inherits parent stderr, otherwise, append to a file
153     public Proc nodump() {
154         noDump = true;
155         return this;
156     }
157     // Specifies some args. Can be called multiple times.
158     public Proc args(String... args) {
159         for (String c: args) {
160             this.args.add(c);
161         }
162         return this;
163     }
164     // Returns debug prefix
165     public String debug() {
166         return debug;
167     }
168     // Enables debug with prefix
169     public Proc debug(String title) {
170         debug = title;
171         return this;
172     }
173     // Specifies an env var. Can be called multiple times.
174     public Proc env(String a, String b) {
175         env.put(a, b);
176         return this;
177     }
178     // Specifies a Java system property. Can be called multiple times.
179     public Proc prop(String a, String b) {
180         prop.put(a, b);
181         return this;
182     }
<a name="4" id="anc4"></a><span class="line-added">183     // Specifies a security property. Can be called multiple times.</span>
<span class="line-added">184     public Proc secprop(String a, String b) {</span>
<span class="line-added">185         secprop.put(a, b);</span>
<span class="line-added">186         return this;</span>
<span class="line-added">187     }</span>
188     // Inherit the value of a system property
189     public Proc inheritProp(String k) {
190         String v = System.getProperty(k);
191         if (v != null) {
192             prop.put(k, v);
193         }
194         return this;
195     }
196     // Sets classpath. If not called, Proc will choose a classpath. If called
197     // with no arg, no classpath will be used. Can be called multiple times.
198     public Proc cp(String... s) {
199         if (cp == null) {
200             cp = new ArrayList&lt;&gt;();
201         }
202         cp.addAll(Arrays.asList(s));
203         return this;
204     }
205     // Adds a permission to policy. Can be called multiple times.
206     // All perm() calls after a series of grant() calls are grouped into
207     // a single grant block. perm() calls before any grant() call are grouped
208     // into a grant block with no restriction.
209     // Please note that in order to make permissions effective, also call
210     // prop(&quot;java.security.manager&quot;, &quot;&quot;).
211     public Proc perm(Permission p) {
212         if (grant.length() != 0) {      // Right after grant(s)
213             if (perms.length() != 0) {  // Not first block
214                 perms.append(&quot;};\n&quot;);
215             }
216             perms.append(&quot;grant &quot;).append(grant).append(&quot; {\n&quot;);
217             grant.setLength(0);
218         } else {
219             if (perms.length() == 0) {  // First block w/o restriction
220                 perms.append(&quot;grant {\n&quot;);
221             }
222         }
223         if (p.getActions().isEmpty()) {
224             String s = String.format(&quot;%s \&quot;%s\&quot;&quot;,
225                     p.getClass().getCanonicalName(),
226                     p.getName()
227                             .replace(&quot;\\&quot;, &quot;\\\\&quot;).replace(&quot;\&quot;&quot;, &quot;\\\&quot;&quot;));
228             perms.append(&quot;    permission &quot;).append(s).append(&quot;;\n&quot;);
229         } else {
230             String s = String.format(&quot;%s \&quot;%s\&quot;, \&quot;%s\&quot;&quot;,
231                     p.getClass().getCanonicalName(),
232                     p.getName()
233                             .replace(&quot;\\&quot;, &quot;\\\\&quot;).replace(&quot;\&quot;&quot;, &quot;\\\&quot;&quot;),
234                     p.getActions());
235             perms.append(&quot;    permission &quot;).append(s).append(&quot;;\n&quot;);
236         }
237         return this;
238     }
239 
240     // Adds a grant option to policy. If called in a row, a single grant block
241     // with all options will be created. If there are perm() call(s) between
242     // grant() calls, they belong to different grant blocks
243 
244     // grant on a principal
245     public Proc grant(Principal p) {
246         grant.append(&quot;principal &quot;).append(p.getClass().getName())
247                 .append(&quot; \&quot;&quot;).append(p.getName()).append(&quot;\&quot;, &quot;);
248         return this;
249     }
250     // grant on a codebase
251     public Proc grant(File f) {
252         grant.append(&quot;codebase \&quot;&quot;).append(f.toURI()).append(&quot;\&quot;, &quot;);
253         return this;
254     }
255     // arbitrary grant
256     public Proc grant(String v) {
257         grant.append(v).append(&quot;, &quot;);
258         return this;
259     }
260     // Starts the proc
261     public Proc start() throws IOException {
262         List&lt;String&gt; cmd = new ArrayList&lt;&gt;();
263         boolean hasModules;
264         if (launcher != null) {
265             cmd.add(launcher);
266             File base = new File(launcher).getParentFile().getParentFile();
267             hasModules = new File(base, &quot;modules&quot;).exists() ||
268                     new File(base, &quot;jmods&quot;).exists();
269         } else {
270             cmd.add(new File(new File(System.getProperty(&quot;java.home&quot;), &quot;bin&quot;),
271                         &quot;java&quot;).getPath());
272             hasModules = true;
273         }
274 
275         if (hasModules) {
276             Stream.of(jdk.internal.misc.VM.getRuntimeArguments())
277                     .filter(arg -&gt; arg.startsWith(&quot;--add-exports=&quot;) ||
278                                    arg.startsWith(&quot;--add-opens=&quot;))
279                     .forEach(cmd::add);
280         }
281 
282         Collections.addAll(cmd, splitProperty(&quot;test.vm.opts&quot;));
283         Collections.addAll(cmd, splitProperty(&quot;test.java.opts&quot;));
284 
285         if (cp == null) {
286             cmd.add(&quot;-cp&quot;);
287             cmd.add(System.getProperty(&quot;test.class.path&quot;) + File.pathSeparator +
288                     System.getProperty(&quot;test.src.path&quot;));
289         } else if (!cp.isEmpty()) {
290             cmd.add(&quot;-cp&quot;);
291             cmd.add(cp.stream().collect(Collectors.joining(File.pathSeparator)));
292         }
293 
<a name="5" id="anc5"></a><span class="line-added">294         if (!secprop.isEmpty()) {</span>
<span class="line-added">295             Path p = Path.of(getId(&quot;security&quot;));</span>
<span class="line-added">296             try (OutputStream fos = Files.newOutputStream(p);</span>
<span class="line-added">297                  PrintStream ps = new PrintStream(fos)) {</span>
<span class="line-added">298                 secprop.forEach((k,v) -&gt; ps.println(k + &quot;=&quot; + v));</span>
<span class="line-added">299             } catch (IOException e) {</span>
<span class="line-added">300                 throw new UncheckedIOException(e);</span>
<span class="line-added">301             }</span>
<span class="line-added">302             prop.put(&quot;java.security.properties&quot;, p.toString());</span>
<span class="line-added">303         }</span>
<span class="line-added">304 </span>
305         for (Entry&lt;String,String&gt; e: prop.entrySet()) {
306             cmd.add(&quot;-D&quot; + e.getKey() + &quot;=&quot; + e.getValue());
307         }
308         if (perms.length() &gt; 0) {
309             Path p = Paths.get(getId(&quot;policy&quot;)).toAbsolutePath();
310             perms.append(&quot;};\n&quot;);
311             Files.write(p, perms.toString().getBytes());
312             cmd.add(&quot;-Djava.security.policy=&quot; + p.toString());
313         }
314         cmd.add(clazz);
315         for (String s: args) {
316             cmd.add(s);
317         }
318         if (debug != null) {
319             System.out.println(&quot;PROC: &quot; + debug + &quot; cmdline: &quot; + cmd);
320             for (String e : env.keySet()) {
321                 System.out.print(e + &quot;=&quot; + env.get(e) + &quot; &quot;);
322             }
323             for (String c : cmd) {
324                 if (c.indexOf(&#39;\\&#39;) &gt;= 0 || c.indexOf(&#39; &#39;) &gt; 0) {
325                     System.out.print(&#39;\&#39;&#39; + c + &#39;\&#39;&#39;);
326                 } else {
327                     System.out.print(c);
328                 }
329                 System.out.print(&#39; &#39;);
330             }
331             System.out.println();
332         }
333         ProcessBuilder pb = new ProcessBuilder(cmd);
334         for (Entry&lt;String,String&gt; e: env.entrySet()) {
335             pb.environment().put(e.getKey(), e.getValue());
336         }
337         if (inheritIO) {
338             pb.inheritIO();
339         } else if (noDump) {
340             pb.redirectError(ProcessBuilder.Redirect.INHERIT);
341         } else {
342             pb.redirectError(ProcessBuilder.Redirect
343                     .appendTo(new File(getId(&quot;stderr&quot;))));
344         }
345         p = pb.start();
346         br = new BufferedReader(new InputStreamReader(p.getInputStream()));
347         return this;
348     }
349     String getId(String suffix) {
350         if (debug != null) {
351             return debug + &quot;.&quot; + suffix;
352         } else {
353             return System.identityHashCode(this) + &quot;.&quot; + suffix;
354         }
355     }
356     // Reads a line from stdout of proc
357     public String readLine() throws IOException {
358         String s = br.readLine();
359         if (debug != null) {
360             System.out.println(&quot;PROC: &quot; + debug + &quot; readline: &quot; +
361                     (s == null ? &quot;&lt;EOF&gt;&quot; : s));
362         }
363         return s;
364     }
365     // Reads a special line from stdout of proc
366     public String readData() throws Exception {
367         while (true) {
368             String s = readLine();
369             if (s == null) {
370                 if (p.waitFor() != 0) {
371                     throw new Exception(&quot;Proc abnormal end&quot;);
372                 } else {
373                     return s;
374                 }
375             }
376             if (s.startsWith(PREFIX)) {
377                 return s.substring(PREFIX.length());
378             }
379         }
380     }
381     // Writes text into stdin of proc
382     public void println(String s) throws IOException {
383         if (debug != null) {
384             System.out.println(&quot;PROC: &quot; + debug + &quot; println: &quot; + s);
385         }
386         write((s + &quot;\n&quot;).getBytes());
387     }
388     // Writes data into stdin of proc
389     public void write(byte[] b) throws IOException {
390         p.getOutputStream().write(b);
391         p.getOutputStream().flush();
392     }
393     // Reads all output and wait for process end
394     public int waitFor() throws Exception {
395         while (true) {
396             String s = readLine();
397             if (s == null) {
398                 break;
399             }
400         }
401         return p.waitFor();
402     }
<a name="6" id="anc6"></a><span class="line-added">403     // Wait for process end with expected exit code</span>
<span class="line-added">404     public void waitFor(int expected) throws Exception {</span>
<span class="line-added">405         if (p.waitFor() != expected) {</span>
<span class="line-added">406             throw new RuntimeException(&quot;Exit code not &quot; + expected);</span>
<span class="line-added">407         }</span>
<span class="line-added">408     }</span>
409 
410     // The following methods are used inside a proc
411 
412     // Writes out a BASE64 binary with a prefix
413     public static void binOut(byte[] data) {
414         System.out.println(PREFIX + Base64.getEncoder().encodeToString(data));
415     }
416     // Reads in a line of BASE64 binary
417     public static byte[] binIn() throws Exception {
418         return Base64.getDecoder().decode(textIn());
419     }
420     // Writes out a text with a prefix
421     public static void textOut(String data) {
422         System.out.println(PREFIX + data);
423     }
424     // Reads in a line of text
425     public static String textIn() throws Exception {
426         StringBuilder sb = new StringBuilder();
427         boolean isEmpty = true;
428         while (true) {
429             int i = System.in.read();
430             if (i == -1) {
431                 break;
432             }
433             isEmpty = false;
434             if (i == &#39;\n&#39;) {
435                 break;
436             }
437             if (i != 13) {
438                 // Force it to a char, so only simple ASCII works.
439                 sb.append((char)i);
440             }
441         }
442         return isEmpty ? null : sb.toString();
443     }
444     // Sends string to stderr. If inheritIO is not called, they will
445     // be collected into DFILE
446     public static void d(String s) throws IOException {
447         System.err.println(s);
448     }
449     // Sends an exception to stderr
450     public static void d(Throwable e) throws IOException {
451         e.printStackTrace();
452     }
453 
454     private static String[] splitProperty(String prop) {
455         String s = System.getProperty(prop);
456         if (s == null || s.trim().isEmpty()) {
457             return new String[] {};
458         }
459         return s.trim().split(&quot;\\s+&quot;);
460     }
461 }
<a name="7" id="anc7"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="7" type="hidden" />
</body>
</html>
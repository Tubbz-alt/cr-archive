<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old test/jdk/java/security/Signature/Offsets.java</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2015, 2018, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 import java.security.*;
 25 import java.security.spec.*;
 26 import jdk.test.lib.RandomFactory;
 27 
 28 /*
 29  * @test
 30  * @bug 8050374 8181048 8146293
 31  * @key randomness
 32  * @summary This test validates signature verification
 33  *          Signature.verify(byte[], int, int). The test uses RandomFactory to
 34  *          get random set of clear text data to sign. After the signature
 35  *          generation, the test tries to verify signature with the above API
 36  *          and passing in different signature offset (0, 33, 66, 99).
 37  * @library /test/lib
 38  * @build jdk.test.lib.RandomFactory
 39  * @run main Offsets SUN NONEwithDSA
 40  * @run main Offsets SUN SHA1withDSA
 41  * @run main Offsets SUN SHA224withDSA
 42  * @run main Offsets SUN SHA256withDSA
 43  * @run main Offsets SunRsaSign SHA224withRSA
 44  * @run main Offsets SunRsaSign SHA256withRSA
 45  * @run main Offsets SunRsaSign SHA384withRSA
 46  * @run main Offsets SunRsaSign SHA512withRSA
 47  * @run main Offsets SunRsaSign SHA512/224withRSA
 48  * @run main Offsets SunRsaSign SHA512/256withRSA
 49  */
 50 public class Offsets {
 51 
 52     private final int size;
 53     private final byte[] cleartext;
 54     private final PublicKey pubkey;
 55     private final Signature signature;
 56     private final byte[] signed;
 57 
 58     private Offsets(Signature signature, PublicKey pubkey, PrivateKey privkey,
 59             int size, byte[] cleartext) throws InvalidKeyException,
 60                 SignatureException {
 61         System.out.println(&quot;Testing signature &quot; + signature.getAlgorithm());
 62         this.pubkey = pubkey;
 63         this.signature = signature;
 64         this.size = size;
 65         this.cleartext = cleartext;
 66 
 67         String sigAlg = signature.getAlgorithm();
 68         signature.initSign(privkey);
 69         signature.update(cleartext, 0, size);
 70         signed = signature.sign();
 71     }
 72 
 73     int getDataSize() {
 74         return size;
 75     }
 76 
 77     int getSignatureLength() {
 78         return signed.length;
 79     }
 80 
 81     byte[] shiftSignData(int offset) {
 82         byte[] testSignData = new byte[offset + signed.length];
 83         System.arraycopy(signed, 0, testSignData, offset,
 84                 signed.length);
 85         return testSignData;
 86     }
 87 
 88     boolean verifySignature(byte[] sigData, int sigOffset, int sigLength,
 89             int updateOffset, int updateLength)
 90             throws InvalidKeyException, SignatureException {
 91         signature.initVerify(pubkey);
 92         signature.update(cleartext, updateOffset, updateLength);
 93         return signature.verify(sigData, sigOffset, sigLength);
 94     }
 95 
 96     static Offsets init(String provider, String algorithm)
 97             throws NoSuchAlgorithmException, NoSuchProviderException,
 98             InvalidKeyException, SignatureException {
 99         // fill the cleartext data with random bytes
100         byte[] cleartext = new byte[100];
101         RandomFactory.getRandom().nextBytes(cleartext);
102 
103         // NONEwith requires input to be of 20 bytes
104         int size = algorithm.contains(&quot;NONEwith&quot;) ? 20 : 100;
105 
106         // create signature instance
107         Signature signature = Signature.getInstance(algorithm, provider);
108 
109         String keyAlgo;
110         int keySize = 2048;
111         if (algorithm.contains(&quot;RSA&quot;)) {
112             keyAlgo = &quot;RSA&quot;;
113         } else if (algorithm.contains(&quot;ECDSA&quot;)) {
114             keyAlgo = &quot;EC&quot;;
115             keySize = 256;
116         } else if (algorithm.contains(&quot;DSA&quot;)) {
117             keyAlgo = &quot;DSA&quot;;
118             if (algorithm.startsWith(&quot;SHAwith&quot;) ||
119                     algorithm.startsWith(&quot;SHA1with&quot;)) {
120                 keySize = 1024;
121             }
122         } else {
123             throw new RuntimeException(&quot;Test doesn&#39;t support this signature &quot;
124                     + &quot;algorithm: &quot; + algorithm);
125         }
126 
127         KeyPairGenerator kpg = KeyPairGenerator.getInstance(keyAlgo, provider);
128         kpg.initialize(keySize);
129         KeyPair kp = kpg.generateKeyPair();
130         PublicKey pubkey = kp.getPublic();
131         PrivateKey privkey = kp.getPrivate();
132 
133         return new Offsets(signature, pubkey, privkey, size, cleartext);
134     }
135 
136     public static void main(String[] args) throws NoSuchAlgorithmException,
137             InvalidKeyException, SignatureException {
138         if (args.length &lt; 2) {
139             throw new RuntimeException(&quot;Wrong parameters&quot;);
140         }
141 
142         boolean result = true;
143         try {
144             Offsets test = init(args[0], args[1]);
145 
146             // We are trying 3 different offsets, data size has nothing to do
147             // with signature length
148             for (int chunk = 3; chunk &gt; 0; chunk--) {
149                 int signOffset = test.getDataSize() / chunk;
150 
151                 System.out.println(&quot;Running test with offset &quot; + signOffset);
152                 byte[] signData = test.shiftSignData(signOffset);
153 
154                 boolean success = test.verifySignature(signData, signOffset,
155                         test.getSignatureLength(), 0, test.getDataSize());
156 
157                 if (success) {
158                     System.out.println(&quot;Successfully verified with offset &quot;
159                             + signOffset);
160                 } else {
161                     System.out.println(&quot;Verification failed with offset &quot;
162                             + signOffset);
163                     result = false;
164                 }
165             }
166 
167             // save signature to offset 0
168             byte[] signData = test.shiftSignData(0);
169 
170             // Negative tests
171 
172             // Test signature offset 0.
173             // Wrong test data will be passed to update,
174             // so signature verification should fail.
175             for (int chunk = 3; chunk &gt; 0; chunk--) {
176                 int dataOffset = (test.getDataSize() - 1) / chunk;
177                 boolean success;
178                 try {
179                     success = test.verifySignature(signData, 0,
180                             test.getSignatureLength(), dataOffset,
181                             (test.getDataSize() - dataOffset));
182                 } catch (SignatureException e) {
183                     // Since we are trying different data size, it can throw
184                     // SignatureException
185                     success = false;
186                 }
187 
188                 if (!success) {
189                     System.out.println(&quot;Signature verification failed &quot;
190                             + &quot;as expected, with data offset &quot; + dataOffset
191                             + &quot; and length &quot;
192                             + (test.getDataSize() - dataOffset));
193                 } else {
194                     System.out.println(&quot;Signature verification &quot;
195                             + &quot;should not succeed, with data offset &quot;
196                             + dataOffset + &quot; and length &quot;
197                             + (test.getDataSize() - dataOffset));
198                     result = false;
199                 }
200             }
201 
202             // Tests with manipulating offset and length
203             result &amp;= Offsets.checkFailure(test, signData, -1,
204                     test.getSignatureLength());
205 
206             result &amp;= Offsets.checkFailure(test, signData, 0,
207                     test.getSignatureLength() - 1);
208 
209             result &amp;= Offsets.checkFailure(test, signData,
210                     test.getSignatureLength() + 1, test.getSignatureLength());
211 
212             result &amp;= Offsets.checkFailure(test, signData, 0,
213                     test.getSignatureLength() + 1);
214 
215             result &amp;= Offsets.checkFailure(test, signData, 0, 0);
216 
217             result &amp;= Offsets.checkFailure(test, signData, 0, -1);
218 
219             result &amp;= Offsets.checkFailure(test, signData,
220                     2147483646, test.getSignatureLength());
221 
222             result &amp;= Offsets.checkFailure(test, null, 0,
223                     test.getSignatureLength());
224         } catch (NoSuchProviderException nspe) {
225             System.out.println(&quot;No such provider: &quot; + nspe);
226         }
227 
228         if (!result) {
229             throw new RuntimeException(&quot;Some test cases failed&quot;);
230         }
231     }
232 
233     static boolean checkFailure(Offsets test, byte[] signData, int offset,
234             int length) {
235         boolean success;
236         try {
237             success = test.verifySignature(signData, offset, length, 0,
238                     test.getDataSize());
239         } catch (IllegalArgumentException | SignatureException e) {
240             System.out.println(&quot;Expected exception: &quot; + e);
241             success = false;
242         } catch (InvalidKeyException e) {
243             System.out.println(&quot;Unexpected exception: &quot; + e);
244             return false;
245         }
246 
247         if (!success) {
248             System.out.println(&quot;Signature verification failed as expected, &quot;
249                     + &quot;with signature offset &quot; + offset + &quot; and length &quot;
250                     + length);
251             return true;
252         } else {
253             System.out.println(&quot;Signature verification should not succeed, &quot;
254                     + &quot;with signature offset &quot; + offset + &quot; and length &quot;
255                     + length);
256             return false;
257         }
258     }
259 
260 }
    </pre>
  </body>
</html>
diff a/test/jdk/java/net/ServerSocket/AcceptCauseFileDescriptorLeak.java b/test/jdk/java/net/ServerSocket/AcceptCauseFileDescriptorLeak.java
--- a/test/jdk/java/net/ServerSocket/AcceptCauseFileDescriptorLeak.java
+++ b/test/jdk/java/net/ServerSocket/AcceptCauseFileDescriptorLeak.java
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2006, 2016, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2006, 2019, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.
@@ -24,25 +24,31 @@
 /*
  * author Edward Wang
  *
  * @test
  * @bug 6368984
+ * @key intermittent
  * @summary Configuring unconnected Socket before passing to implAccept
- *          can cause fd leak
+ *          can cause fd leak.
+ *          This test may fail intermittently if foreign processes will
+ *          try to establish connection to the test server socket.
  * @requires (os.family != "windows")
  * @library /test/lib
  * @build jdk.test.lib.Utils
  *        jdk.test.lib.Asserts
  *        jdk.test.lib.JDKToolFinder
  *        jdk.test.lib.JDKToolLauncher
  *        jdk.test.lib.Platform
  *        jdk.test.lib.process.*
  *        AcceptCauseFileDescriptorLeak
  * @run main/othervm AcceptCauseFileDescriptorLeak root
+ * @run main/othervm -Djdk.net.usePlainSocketImpl AcceptCauseFileDescriptorLeak root
  */
 
 import java.io.IOException;
+import java.net.InetAddress;
+import java.net.InetSocketAddress;
 import java.net.ServerSocket;
 import java.net.Socket;
 import java.util.List;
 
 import jdk.test.lib.JDKToolFinder;
@@ -78,36 +84,42 @@
                     return;
                 }
             }
         }
 
-        final ServerSocket ss = new ServerSocket(0) {
+        final ServerSocket ss = new ServerSocket() {
             public Socket accept() throws IOException {
                 Socket s = new Socket() {
                 };
                 s.setSoTimeout(10000);
                 implAccept(s);
                 return s;
             }
         };
+        ss.bind(new InetSocketAddress(InetAddress.getLoopbackAddress(), 0));
         Thread t = new Thread(new Runnable() {
             public void run() {
+                int repsCompleted = 0;
                 try {
-                    for (int i = 0; i < REPS; i++) {
-                        (new Socket("localhost", ss.getLocalPort())).close();
+                    for (; repsCompleted < REPS; repsCompleted++) {
+                        (new Socket(InetAddress.getLoopbackAddress(), ss.getLocalPort())).close();
                     }
                 } catch (IOException e) {
                     e.printStackTrace();
+                } finally {
+                    System.out.println("Client iterations completed:" + repsCompleted);
                 }
             }
         });
         t.start();
+        int repsCompleted = 0;
         try {
-            for (int i = 0; i < REPS; i++) {
+            for (; repsCompleted < REPS; repsCompleted++) {
                 ss.accept().close();
             }
         } finally {
+            System.out.println("Server iterations completed:" + repsCompleted);
             ss.close();
         }
         t.join();
     }
 

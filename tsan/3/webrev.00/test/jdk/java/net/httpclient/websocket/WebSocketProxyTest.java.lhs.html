<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames test/jdk/java/net/httpclient/websocket/WebSocketProxyTest.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
<a name="1" id="anc1"></a><span class="line-modified">  2  * Copyright (c) 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 /*
 25  * @test
<a name="2" id="anc2"></a><span class="line-modified"> 26  * @bug 8217429</span>
 27  * @summary WebSocket proxy tunneling tests
<a name="3" id="anc3"></a><span class="line-modified"> 28  * @compile DummyWebSocketServer.java ../ProxyServer.java</span>


 29  * @run testng/othervm
<a name="4" id="anc4"></a>


 30  *         -Djdk.http.auth.tunneling.disabledSchemes=
 31  *         WebSocketProxyTest
 32  */
 33 
 34 import java.io.IOException;
 35 import java.io.UncheckedIOException;
 36 import java.net.Authenticator;
 37 import java.net.InetAddress;
 38 import java.net.InetSocketAddress;
 39 import java.net.PasswordAuthentication;
 40 import java.net.ProxySelector;
 41 import java.net.http.HttpResponse;
 42 import java.net.http.WebSocket;
 43 import java.net.http.WebSocketHandshakeException;
 44 import java.nio.ByteBuffer;
 45 import java.nio.charset.StandardCharsets;
 46 import java.util.ArrayList;
 47 import java.util.Base64;
 48 import java.util.List;
 49 import java.util.concurrent.CompletableFuture;
 50 import java.util.concurrent.CompletionException;
 51 import java.util.concurrent.CompletionStage;
 52 import java.util.function.Function;
 53 import java.util.function.Supplier;
 54 import java.util.stream.Collectors;
<a name="5" id="anc5"></a>

 55 import org.testng.annotations.BeforeMethod;
 56 import org.testng.annotations.DataProvider;
 57 import org.testng.annotations.Test;
<a name="6" id="anc6"></a>


 58 import static java.net.http.HttpClient.newBuilder;
 59 import static java.nio.charset.StandardCharsets.UTF_8;
 60 import static org.testng.Assert.assertEquals;
 61 import static org.testng.FileAssert.fail;
 62 
 63 public class WebSocketProxyTest {
 64 
 65     // Used to verify a proxy/websocket server requiring Authentication
 66     private static final String USERNAME = &quot;wally&quot;;
 67     private static final String PASSWORD = &quot;xyz987&quot;;
 68 
<a name="7" id="anc7"></a>







 69     static class WSAuthenticator extends Authenticator {
 70         @Override
 71         protected PasswordAuthentication getPasswordAuthentication() {
 72             return new PasswordAuthentication(USERNAME, PASSWORD.toCharArray());
 73         }
 74     }
 75 
<a name="8" id="anc8"></a><span class="line-modified"> 76     static final Function&lt;int[],DummyWebSocketServer&gt; SERVER_WITH_CANNED_DATA =</span>
 77         new Function&lt;&gt;() {
<a name="9" id="anc9"></a><span class="line-modified"> 78             @Override public DummyWebSocketServer apply(int[] data) {</span>
<span class="line-modified"> 79                 return Support.serverWithCannedData(data); }</span>
 80             @Override public String toString() { return &quot;SERVER_WITH_CANNED_DATA&quot;; }
 81         };
 82 
<a name="10" id="anc10"></a><span class="line-modified"> 83     static final Function&lt;int[],DummyWebSocketServer&gt; AUTH_SERVER_WITH_CANNED_DATA =</span>







 84         new Function&lt;&gt;() {
<a name="11" id="anc11"></a><span class="line-modified"> 85             @Override public DummyWebSocketServer apply(int[] data) {</span>
<span class="line-modified"> 86                 return Support.serverWithCannedDataAndAuthentication(USERNAME, PASSWORD, data); }</span>
 87             @Override public String toString() { return &quot;AUTH_SERVER_WITH_CANNED_DATA&quot;; }
 88         };
 89 
<a name="12" id="anc12"></a>






 90     static final Supplier&lt;ProxyServer&gt; TUNNELING_PROXY_SERVER =
 91         new Supplier&lt;&gt;() {
 92             @Override public ProxyServer get() {
 93                 try { return new ProxyServer(0, true);}
 94                 catch(IOException e) { throw new UncheckedIOException(e); } }
 95             @Override public String toString() { return &quot;TUNNELING_PROXY_SERVER&quot;; }
 96         };
 97     static final Supplier&lt;ProxyServer&gt; AUTH_TUNNELING_PROXY_SERVER =
 98         new Supplier&lt;&gt;() {
 99             @Override public ProxyServer get() {
100                 try { return new ProxyServer(0, true, USERNAME, PASSWORD);}
101                 catch(IOException e) { throw new UncheckedIOException(e); } }
102             @Override public String toString() { return &quot;AUTH_TUNNELING_PROXY_SERVER&quot;; }
103         };
104 
105     @DataProvider(name = &quot;servers&quot;)
106     public Object[][] servers() {
107         return new Object[][] {
<a name="13" id="anc13"></a><span class="line-modified">108             { SERVER_WITH_CANNED_DATA,      TUNNELING_PROXY_SERVER      },</span>
<span class="line-modified">109             { SERVER_WITH_CANNED_DATA,      AUTH_TUNNELING_PROXY_SERVER },</span>
<span class="line-modified">110             { AUTH_SERVER_WITH_CANNED_DATA, TUNNELING_PROXY_SERVER      },</span>





111         };
112     }
113 
114     @Test(dataProvider = &quot;servers&quot;)
115     public void simpleAggregatingBinaryMessages
<a name="14" id="anc14"></a><span class="line-modified">116             (Function&lt;int[],DummyWebSocketServer&gt; serverSupplier,</span>
117              Supplier&lt;ProxyServer&gt; proxyServerSupplier)
118         throws IOException
119     {
120         List&lt;byte[]&gt; expected = List.of(&quot;hello&quot;, &quot;chegar&quot;)
121                 .stream()
122                 .map(s -&gt; s.getBytes(StandardCharsets.US_ASCII))
123                 .collect(Collectors.toList());
124         int[] binary = new int[]{
125                 0x82, 0x05, 0x68, 0x65, 0x6C, 0x6C, 0x6F,       // hello
126                 0x82, 0x06, 0x63, 0x68, 0x65, 0x67, 0x61, 0x72, // chegar
127                 0x88, 0x00                                      // &lt;CLOSE&gt;
128         };
129         CompletableFuture&lt;List&lt;byte[]&gt;&gt; actual = new CompletableFuture&lt;&gt;();
130 
131         try (var proxyServer = proxyServerSupplier.get();
132              var server = serverSupplier.apply(binary)) {
133 
134             InetSocketAddress proxyAddress = new InetSocketAddress(
135                     InetAddress.getLoopbackAddress(), proxyServer.getPort());
136             server.open();
<a name="15" id="anc15"></a>

137 
138             WebSocket.Listener listener = new WebSocket.Listener() {
139 
140                 List&lt;byte[]&gt; collectedBytes = new ArrayList&lt;&gt;();
141                 ByteBuffer buffer = ByteBuffer.allocate(1024);
142 
143                 @Override
144                 public CompletionStage&lt;?&gt; onBinary(WebSocket webSocket,
145                                                    ByteBuffer message,
146                                                    boolean last) {
147                     System.out.printf(&quot;onBinary(%s, %s)%n&quot;, message, last);
148                     webSocket.request(1);
149 
150                     append(message);
151                     if (last) {
152                         buffer.flip();
153                         byte[] bytes = new byte[buffer.remaining()];
154                         buffer.get(bytes);
155                         buffer.clear();
156                         processWholeBinary(bytes);
157                     }
158                     return null;
159                 }
160 
161                 private void append(ByteBuffer message) {
162                     if (buffer.remaining() &lt; message.remaining()) {
163                         assert message.remaining() &gt; 0;
164                         int cap = (buffer.capacity() + message.remaining()) * 2;
165                         ByteBuffer b = ByteBuffer.allocate(cap);
166                         b.put(buffer.flip());
167                         buffer = b;
168                     }
169                     buffer.put(message);
170                 }
171 
172                 private void processWholeBinary(byte[] bytes) {
173                     String stringBytes = new String(bytes, UTF_8);
174                     System.out.println(&quot;processWholeBinary: &quot; + stringBytes);
175                     collectedBytes.add(bytes);
176                 }
177 
178                 @Override
179                 public CompletionStage&lt;?&gt; onClose(WebSocket webSocket,
180                                                   int statusCode,
181                                                   String reason) {
182                     actual.complete(collectedBytes);
183                     return null;
184                 }
185 
186                 @Override
187                 public void onError(WebSocket webSocket, Throwable error) {
188                     actual.completeExceptionally(error);
189                 }
190             };
191 
192             var webSocket = newBuilder()
193                     .proxy(ProxySelector.of(proxyAddress))
194                     .authenticator(new WSAuthenticator())
195                     .build().newWebSocketBuilder()
196                     .buildAsync(server.getURI(), listener)
197                     .join();
198 
199             List&lt;byte[]&gt; a = actual.join();
200             assertEquals(a, expected);
201         }
202     }
203 
204     // -- authentication specific tests
205 
206     /*
207      * Ensures authentication succeeds when an Authenticator set on client builder.
208      */
209     @Test
210     public void clientAuthenticate() throws IOException  {
211         try (var proxyServer = AUTH_TUNNELING_PROXY_SERVER.get();
<a name="16" id="anc16"></a><span class="line-modified">212              var server = new DummyWebSocketServer()){</span>
213             server.open();
214             InetSocketAddress proxyAddress = new InetSocketAddress(
215                     InetAddress.getLoopbackAddress(), proxyServer.getPort());
216 
217             var webSocket = newBuilder()
218                     .proxy(ProxySelector.of(proxyAddress))
219                     .authenticator(new WSAuthenticator())
220                     .build()
221                     .newWebSocketBuilder()
222                     .buildAsync(server.getURI(), new WebSocket.Listener() { })
223                     .join();
224         }
225     }
226 
227     /*
228      * Ensures authentication succeeds when an `Authorization` header is explicitly set.
229      */
230     @Test
231     public void explicitAuthenticate() throws IOException  {
232         try (var proxyServer = AUTH_TUNNELING_PROXY_SERVER.get();
<a name="17" id="anc17"></a><span class="line-modified">233              var server = new DummyWebSocketServer()) {</span>























234             server.open();
235             InetSocketAddress proxyAddress = new InetSocketAddress(
236                     InetAddress.getLoopbackAddress(), proxyServer.getPort());
237 
238             String hv = &quot;Basic &quot; + Base64.getEncoder().encodeToString(
239                     (USERNAME + &quot;:&quot; + PASSWORD).getBytes(UTF_8));
240 
241             var webSocket = newBuilder()
242                     .proxy(ProxySelector.of(proxyAddress)).build()
243                     .newWebSocketBuilder()
244                     .header(&quot;Proxy-Authorization&quot;, hv)
<a name="18" id="anc18"></a>
245                     .buildAsync(server.getURI(), new WebSocket.Listener() { })
246                     .join();
247         }
248     }
249 
250     /*
251      * Ensures authentication does not succeed when no authenticator is present.
252      */
253     @Test
254     public void failNoAuthenticator() throws IOException  {
255         try (var proxyServer = AUTH_TUNNELING_PROXY_SERVER.get();
<a name="19" id="anc19"></a><span class="line-modified">256              var server = new DummyWebSocketServer(USERNAME, PASSWORD)) {</span>
257             server.open();
258             InetSocketAddress proxyAddress = new InetSocketAddress(
259                     InetAddress.getLoopbackAddress(), proxyServer.getPort());
260 
261             CompletableFuture&lt;WebSocket&gt; cf = newBuilder()
262                     .proxy(ProxySelector.of(proxyAddress)).build()
263                     .newWebSocketBuilder()
264                     .buildAsync(server.getURI(), new WebSocket.Listener() { });
265 
266             try {
267                 var webSocket = cf.join();
268                 fail(&quot;Expected exception not thrown&quot;);
269             } catch (CompletionException expected) {
270                 WebSocketHandshakeException e = (WebSocketHandshakeException)expected.getCause();
271                 HttpResponse&lt;?&gt; response = e.getResponse();
272                 assertEquals(response.statusCode(), 407);
273             }
274         }
275     }
276 
277     /*
278      * Ensures authentication does not succeed when the authenticator presents
279      * unauthorized credentials.
280      */
281     @Test
282     public void failBadCredentials() throws IOException  {
283         try (var proxyServer = AUTH_TUNNELING_PROXY_SERVER.get();
<a name="20" id="anc20"></a><span class="line-modified">284              var server = new DummyWebSocketServer(USERNAME, PASSWORD)) {</span>
285             server.open();
286             InetSocketAddress proxyAddress = new InetSocketAddress(
287                     InetAddress.getLoopbackAddress(), proxyServer.getPort());
288 
289             Authenticator authenticator = new Authenticator() {
290                 @Override protected PasswordAuthentication getPasswordAuthentication() {
291                     return new PasswordAuthentication(&quot;BAD&quot;+USERNAME, &quot;&quot;.toCharArray());
292                 }
293             };
294 
295             CompletableFuture&lt;WebSocket&gt; cf = newBuilder()
296                     .proxy(ProxySelector.of(proxyAddress))
297                     .authenticator(authenticator)
298                     .build()
299                     .newWebSocketBuilder()
300                     .buildAsync(server.getURI(), new WebSocket.Listener() { });
301 
302             try {
303                 var webSocket = cf.join();
304                 fail(&quot;Expected exception not thrown&quot;);
305             } catch (CompletionException expected) {
306                 System.out.println(&quot;caught expected exception:&quot; + expected);
307             }
308         }
309     }
310 
311     @BeforeMethod
312     public void breakBetweenTests() {
313         System.out.println(&quot;\n-------\n&quot;);
314     }
315 }
<a name="21" id="anc21"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="21" type="hidden" />
</body>
</html>
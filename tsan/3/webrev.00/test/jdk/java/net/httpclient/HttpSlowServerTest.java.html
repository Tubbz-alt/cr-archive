<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New test/jdk/java/net/httpclient/HttpSlowServerTest.java</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 import com.sun.net.httpserver.HttpServer;
 24 import com.sun.net.httpserver.HttpsConfigurator;
 25 import com.sun.net.httpserver.HttpsServer;
 26 import jdk.test.lib.net.SimpleSSLContext;
 27 
 28 import javax.net.ssl.SSLContext;
 29 import java.io.IOException;
 30 import java.io.InputStream;
 31 import java.io.OutputStream;
 32 import java.net.InetAddress;
 33 import java.net.InetSocketAddress;
 34 import java.net.Proxy;
 35 import java.net.ProxySelector;
 36 import java.net.SocketAddress;
 37 import java.net.URI;
 38 import java.net.http.HttpClient;
 39 import java.net.http.HttpRequest;
 40 import java.net.http.HttpResponse;
 41 import java.nio.charset.StandardCharsets;
 42 import java.time.Duration;
 43 import java.util.List;
 44 import java.util.Set;
 45 import java.util.concurrent.CompletableFuture;
 46 import java.util.concurrent.CopyOnWriteArrayList;
 47 import java.util.concurrent.CopyOnWriteArraySet;
 48 import java.util.concurrent.ExecutorService;
 49 import java.util.concurrent.LinkedBlockingQueue;
 50 import java.util.concurrent.ThreadPoolExecutor;
 51 import java.util.concurrent.TimeUnit;
 52 import java.util.concurrent.atomic.AtomicLong;
 53 
 54 /**
 55  * @test
 56  * @summary This test verifies that the HttpClient works correctly when connected to a
 57  *          slow server.
 58  * @library /test/lib http2/server
 59  * @build jdk.test.lib.net.SimpleSSLContext HttpServerAdapters DigestEchoServer HttpSlowServerTest
 60  * @modules java.net.http/jdk.internal.net.http.common
 61  *          java.net.http/jdk.internal.net.http.frame
 62  *          java.net.http/jdk.internal.net.http.hpack
 63  *          java.logging
 64  *          java.base/sun.net.www.http
 65  *          java.base/sun.net.www
 66  *          java.base/sun.net
 67  * @run main/othervm -Dtest.requiresHost=true
 68  *                   -Djdk.httpclient.HttpClient.log=headers
 69  *                   -Djdk.internal.httpclient.debug=false
 70  *                   HttpSlowServerTest
 71  *
 72  */
 73 public class HttpSlowServerTest implements HttpServerAdapters {
 74     static final List&lt;String&gt; data = List.of(
 75             &quot;Lorem ipsum&quot;,
 76             &quot;dolor sit amet&quot;,
 77             &quot;consectetur adipiscing elit, sed do eiusmod tempor&quot;,
 78             &quot;quis nostrud exercitation ullamco&quot;,
 79             &quot;laboris nisi&quot;,
 80             &quot;ut&quot;,
 81             &quot;aliquip ex ea commodo consequat.&quot;,
 82             &quot;Duis aute irure dolor in reprehenderit in voluptate velit esse&quot;,
 83             &quot;cillum dolore eu fugiat nulla pariatur.&quot;,
 84             &quot;Excepteur sint occaecat cupidatat non proident.&quot;
 85     );
 86 
 87     static final SSLContext context;
 88     static {
 89         try {
 90             context = new SimpleSSLContext().get();
 91             SSLContext.setDefault(context);
 92         } catch (Exception x) {
 93             throw new ExceptionInInitializerError(x);
 94         }
 95     }
 96 
 97     final AtomicLong requestCounter = new AtomicLong();
 98     final AtomicLong responseCounter = new AtomicLong();
 99     HttpTestServer http1Server;
100     HttpTestServer http2Server;
101     HttpTestServer https1Server;
102     HttpTestServer https2Server;
103     DigestEchoServer.TunnelingProxy proxy;
104 
105     URI http1URI;
106     URI https1URI;
107     URI http2URI;
108     URI https2URI;
109     InetSocketAddress proxyAddress;
110     ProxySelector proxySelector;
111     HttpClient client;
112     List&lt;CompletableFuture&lt;?&gt;&gt;  futures = new CopyOnWriteArrayList&lt;&gt;();
113     Set&lt;URI&gt; pending = new CopyOnWriteArraySet&lt;&gt;();
114 
115     final ExecutorService executor = new ThreadPoolExecutor(12, 60, 10,
116             TimeUnit.SECONDS, new LinkedBlockingQueue&lt;&gt;()); // Shared by HTTP/1.1 servers
117     final ExecutorService clientexec = new ThreadPoolExecutor(6, 12, 1,
118             TimeUnit.SECONDS, new LinkedBlockingQueue&lt;&gt;()); // Used by the client
119 
120     public HttpClient newHttpClient(ProxySelector ps) {
121         HttpClient.Builder builder = HttpClient
122                 .newBuilder()
123                 .sslContext(context)
124                 .executor(clientexec)
125                 .proxy(ps);
126         return builder.build();
127     }
128 
129     public void setUp() throws Exception {
130         try {
131             InetSocketAddress sa = new InetSocketAddress(InetAddress.getLoopbackAddress(), 0);
132 
133             // HTTP/1.1
134             HttpServer server1 = HttpServer.create(sa, 0);
135             server1.setExecutor(executor);
136             http1Server = HttpTestServer.of(server1);
137             http1Server.addHandler(new HttpTestSlowHandler(), &quot;/HttpSlowServerTest/http1/&quot;);
138             http1Server.start();
139             http1URI = new URI(&quot;http://&quot; + http1Server.serverAuthority() + &quot;/HttpSlowServerTest/http1/&quot;);
140 
141 
142             // HTTPS/1.1
143             HttpsServer sserver1 = HttpsServer.create(sa, 100);
144             sserver1.setExecutor(executor);
145             sserver1.setHttpsConfigurator(new HttpsConfigurator(context));
146             https1Server = HttpTestServer.of(sserver1);
147             https1Server.addHandler(new HttpTestSlowHandler(), &quot;/HttpSlowServerTest/https1/&quot;);
148             https1Server.start();
149             https1URI = new URI(&quot;https://&quot; + https1Server.serverAuthority() + &quot;/HttpSlowServerTest/https1/&quot;);
150 
151             // HTTP/2.0
152             http2Server = HttpTestServer.of(
153                     new Http2TestServer(&quot;localhost&quot;, false, 0));
154             http2Server.addHandler(new HttpTestSlowHandler(), &quot;/HttpSlowServerTest/http2/&quot;);
155             http2Server.start();
156             http2URI = new URI(&quot;http://&quot; + http2Server.serverAuthority() + &quot;/HttpSlowServerTest/http2/&quot;);
157 
158             // HTTPS/2.0
159             https2Server = HttpTestServer.of(
160                     new Http2TestServer(&quot;localhost&quot;, true, 0));
161             https2Server.addHandler(new HttpTestSlowHandler(), &quot;/HttpSlowServerTest/https2/&quot;);
162             https2Server.start();
163             https2URI = new URI(&quot;https://&quot; + https2Server.serverAuthority() + &quot;/HttpSlowServerTest/https2/&quot;);
164 
165             proxy = DigestEchoServer.createHttpsProxyTunnel(
166                     DigestEchoServer.HttpAuthSchemeType.NONE);
167             proxyAddress = proxy.getProxyAddress();
168             proxySelector = new HttpProxySelector(proxyAddress);
169             client = newHttpClient(proxySelector);
170             System.out.println(&quot;Setup: done&quot;);
171         } catch (Exception x) {
172             tearDown(); throw x;
173         } catch (Error e) {
174             tearDown(); throw e;
175         }
176     }
177 
178     public static void main(String[] args) throws Exception {
179         HttpSlowServerTest test = new HttpSlowServerTest();
180         test.setUp();
181         long start = System.nanoTime();
182         try {
183             test.run(args);
184         } finally {
185             try {
186                 long elapsed = System.nanoTime() - start;
187                 System.out.println(&quot;*** Elapsed: &quot; + Duration.ofNanos(elapsed));
188             } finally {
189                 test.tearDown();
190             }
191         }
192     }
193 
194     public void run(String... args) throws Exception {
195         List&lt;URI&gt; serverURIs = List.of(http1URI, http2URI, https1URI, https2URI);
196         for (int i=0; i&lt;20; i++) {
197             for (URI base : serverURIs) {
198                 if (base.getScheme().equalsIgnoreCase(&quot;https&quot;)) {
199                     URI proxy = i % 1 == 0 ? base.resolve(URI.create(&quot;proxy/foo?n=&quot;+requestCounter.incrementAndGet()))
200                     : base.resolve(URI.create(&quot;direct/foo?n=&quot;+requestCounter.incrementAndGet()));
201                     test(proxy);
202                 }
203             }
204             for (URI base : serverURIs) {
205                 URI direct = base.resolve(URI.create(&quot;direct/foo?n=&quot;+requestCounter.incrementAndGet()));
206                 test(direct);
207             }
208         }
209         CompletableFuture.allOf(futures.toArray(new CompletableFuture[0])).join();
210     }
211 
212     public void test(URI uri) throws Exception {
213         System.out.println(&quot;Testing with &quot; + uri);
214         pending.add(uri);
215         HttpRequest request = HttpRequest.newBuilder(uri).build();
216         CompletableFuture&lt;HttpResponse&lt;String&gt;&gt; resp =
217                 client.sendAsync(request, HttpResponse.BodyHandlers.ofString())
218                 .whenComplete((r, t) -&gt; this.requestCompleted(request, r, t));
219         futures.add(resp);
220     }
221 
222     private void requestCompleted(HttpRequest request, HttpResponse&lt;?&gt; r, Throwable t) {
223         responseCounter.incrementAndGet();
224         pending.remove(request.uri());
225         System.out.println(request + &quot; -&gt; &quot; + (t == null ? r : t)
226                 + &quot; [still pending: &quot; + (requestCounter.get() - responseCounter.get()) +&quot;]&quot;);
227         if (pending.size() &lt; 5 &amp;&amp; requestCounter.get() &gt; 100) {
228             pending.forEach(u -&gt; System.out.println(&quot;\tpending: &quot; + u));
229         }
230     }
231 
232     public void tearDown() {
233         proxy = stop(proxy, DigestEchoServer.TunnelingProxy::stop);
234         http1Server = stop(http1Server, HttpTestServer::stop);
235         https1Server = stop(https1Server, HttpTestServer::stop);
236         http2Server = stop(http2Server, HttpTestServer::stop);
237         https2Server = stop(https2Server, HttpTestServer::stop);
238         client = null;
239         try {
240             executor.awaitTermination(2000, TimeUnit.MILLISECONDS);
241         } catch (Throwable x) {
242         } finally {
243             executor.shutdownNow();
244         }
245         try {
246             clientexec.awaitTermination(2000, TimeUnit.MILLISECONDS);
247         } catch (Throwable x) {
248         } finally {
249             clientexec.shutdownNow();
250         }
251         System.out.println(&quot;Teardown: done&quot;);
252     }
253 
254     private interface Stoppable&lt;T&gt; { public void stop(T service) throws Exception; }
255 
256     static &lt;T&gt;  T stop(T service, Stoppable&lt;T&gt; stop) {
257         try { if (service != null) stop.stop(service); } catch (Throwable x) { };
258         return null;
259     }
260 
261     static class HttpProxySelector extends ProxySelector {
262         private static final List&lt;Proxy&gt; NO_PROXY = List.of(Proxy.NO_PROXY);
263         private final List&lt;Proxy&gt; proxyList;
264         HttpProxySelector(InetSocketAddress proxyAddress) {
265             proxyList = List.of(new Proxy(Proxy.Type.HTTP, proxyAddress));
266         }
267 
268         @Override
269         public List&lt;Proxy&gt; select(URI uri) {
270             // our proxy only supports tunneling
271             if (uri.getScheme().equalsIgnoreCase(&quot;https&quot;)) {
272                 if (uri.getPath().contains(&quot;/proxy/&quot;)) {
273                     return proxyList;
274                 }
275             }
276             return NO_PROXY;
277         }
278 
279         @Override
280         public void connectFailed(URI uri, SocketAddress sa, IOException ioe) {
281             System.err.println(&quot;Connection to proxy failed: &quot; + ioe);
282             System.err.println(&quot;Proxy: &quot; + sa);
283             System.err.println(&quot;\tURI: &quot; + uri);
284             ioe.printStackTrace();
285         }
286     }
287 
288     public static class HttpTestSlowHandler implements HttpTestHandler {
289         static final AtomicLong respCounter = new AtomicLong();
290         @Override
291         public void handle(HttpTestExchange t) throws IOException {
292             try (InputStream is = t.getRequestBody();
293                  OutputStream os = t.getResponseBody()) {
294                 byte[] bytes = is.readAllBytes();
295                 assert bytes.length == 0;
296                 URI u = t.getRequestURI();
297                 long responseID = Long.parseLong(u.getQuery().substring(2));
298                 System.out.println(&quot;Server &quot; + t.getRequestURI() + &quot; sending response &quot; + responseID);
299                 t.sendResponseHeaders(200, -1);
300                 for (String part : data) {
301                     bytes = part.getBytes(StandardCharsets.UTF_8);
302                     os.write(bytes);
303                     os.flush();
304                     System.out.println(&quot;\tresp:&quot; + responseID + &quot;: wrote &quot; + bytes.length + &quot; bytes&quot;);
305                     // wait...
306                     try { Thread.sleep(300); } catch (InterruptedException x) {};
307                 }
308                 System.out.println(&quot;\tresp:&quot; + responseID + &quot;: done&quot;);
309             }
310         }
311     }
312 
313 }
    </pre>
  </body>
</html>
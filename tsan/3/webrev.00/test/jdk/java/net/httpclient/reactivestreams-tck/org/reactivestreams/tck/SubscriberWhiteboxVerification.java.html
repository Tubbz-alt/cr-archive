<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New test/jdk/java/net/httpclient/reactivestreams-tck/org/reactivestreams/tck/SubscriberWhiteboxVerification.java</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 package org.reactivestreams.tck;
 25 
 26 import org.reactivestreams.Publisher;
 27 import org.reactivestreams.Subscriber;
 28 import org.reactivestreams.Subscription;
 29 import org.reactivestreams.tck.TestEnvironment.*;
 30 import org.reactivestreams.tck.flow.support.Optional;
 31 import org.reactivestreams.tck.flow.support.SubscriberWhiteboxVerificationRules;
 32 import org.reactivestreams.tck.flow.support.TestException;
 33 import org.testng.SkipException;
 34 import org.testng.annotations.AfterClass;
 35 import org.testng.annotations.BeforeClass;
 36 import org.testng.annotations.BeforeMethod;
 37 import org.testng.annotations.Test;
 38 
 39 import java.util.concurrent.ExecutorService;
 40 import java.util.concurrent.Executors;
 41 
 42 import static org.testng.Assert.assertTrue;
 43 
 44 /**
 45  * Provides whitebox style tests for verifying {@link org.reactivestreams.Subscriber}
 46  * and {@link org.reactivestreams.Subscription} specification rules.
 47  *
 48  * @see org.reactivestreams.Subscriber
 49  * @see org.reactivestreams.Subscription
 50  */
 51 public abstract class SubscriberWhiteboxVerification&lt;T&gt; extends WithHelperPublisher&lt;T&gt;
 52   implements SubscriberWhiteboxVerificationRules {
 53 
 54   private final TestEnvironment env;
 55 
 56   protected SubscriberWhiteboxVerification(TestEnvironment env) {
 57     this.env = env;
 58   }
 59 
 60   // USER API
 61 
 62   /**
 63    * This is the main method you must implement in your test incarnation.
 64    * It must create a new {@link org.reactivestreams.Subscriber} instance to be subjected to the testing logic.
 65    *
 66    * In order to be meaningfully testable your Subscriber must inform the given
 67    * `WhiteboxSubscriberProbe` of the respective events having been received.
 68    */
 69   public abstract Subscriber&lt;T&gt; createSubscriber(WhiteboxSubscriberProbe&lt;T&gt; probe);
 70 
 71   // ENV SETUP
 72 
 73   /**
 74    * Executor service used by the default provided asynchronous Publisher.
 75    * @see #createHelperPublisher(long)
 76    */
 77   private ExecutorService publisherExecutor;
 78   @BeforeClass public void startPublisherExecutorService() { publisherExecutor = Executors.newFixedThreadPool(4); }
 79   @AfterClass public void shutdownPublisherExecutorService() { if (publisherExecutor != null) publisherExecutor.shutdown(); }
 80   @Override public ExecutorService publisherExecutorService() { return publisherExecutor; }
 81 
 82   ////////////////////// TEST ENV CLEANUP /////////////////////////////////////
 83 
 84   @BeforeMethod
 85   public void setUp() throws Exception {
 86     env.clearAsyncErrors();
 87   }
 88 
 89   ////////////////////// TEST SETUP VERIFICATION //////////////////////////////
 90 
 91   @Test
 92   public void required_exerciseWhiteboxHappyPath() throws Throwable {
 93     subscriberTest(new TestStageTestRun() {
 94       @Override
 95       public void run(WhiteboxTestStage stage) throws InterruptedException {
 96         stage.puppet().triggerRequest(1);
 97         stage.puppet().triggerRequest(1);
 98 
 99         long receivedRequests = stage.expectRequest();
100 
101         stage.signalNext();
102         stage.probe.expectNext(stage.lastT);
103 
104         stage.puppet().triggerRequest(1);
105         if (receivedRequests == 1) {
106           stage.expectRequest();
107         }
108 
109         stage.signalNext();
110         stage.probe.expectNext(stage.lastT);
111 
112         stage.puppet().signalCancel();
113         stage.expectCancelling();
114 
115         stage.verifyNoAsyncErrors();
116       }
117     });
118   }
119 
120   ////////////////////// SPEC RULE VERIFICATION ///////////////////////////////
121 
122   // Verifies rule: https://github.com/reactive-streams/reactive-streams-jvm#2.1
123   @Override @Test
124   public void required_spec201_mustSignalDemandViaSubscriptionRequest() throws Throwable {
125     subscriberTest(new TestStageTestRun() {
126       @Override
127       public void run(WhiteboxTestStage stage) throws InterruptedException {
128         stage.puppet().triggerRequest(1);
129         stage.expectRequest();
130 
131         stage.signalNext();
132       }
133     });
134   }
135 
136   // Verifies rule: https://github.com/reactive-streams/reactive-streams-jvm#2.2
137   @Override @Test
138   public void untested_spec202_shouldAsynchronouslyDispatch() throws Exception {
139     notVerified(); // cannot be meaningfully tested, or can it?
140   }
141 
142   // Verifies rule: https://github.com/reactive-streams/reactive-streams-jvm#2.3
143   @Override @Test
144   public void required_spec203_mustNotCallMethodsOnSubscriptionOrPublisherInOnComplete() throws Throwable {
145     subscriberTestWithoutSetup(new TestStageTestRun() {
146       @Override
147       public void run(WhiteboxTestStage stage) throws Throwable {
148         final Subscription subs = new Subscription() {
149           @Override
150           public void request(long n) {
151             final Optional&lt;StackTraceElement&gt; onCompleteStackTraceElement = env.findCallerMethodInStackTrace(&quot;onComplete&quot;);
152             if (onCompleteStackTraceElement.isDefined()) {
153               final StackTraceElement stackElem = onCompleteStackTraceElement.get();
154               env.flop(String.format(&quot;Subscription::request MUST NOT be called from Subscriber::onComplete (Rule 2.3)! (Caller: %s::%s line %d)&quot;,
155                                      stackElem.getClassName(), stackElem.getMethodName(), stackElem.getLineNumber()));
156             }
157           }
158 
159           @Override
160           public void cancel() {
161             final Optional&lt;StackTraceElement&gt; onCompleteStackElement = env.findCallerMethodInStackTrace(&quot;onComplete&quot;);
162             if (onCompleteStackElement.isDefined()) {
163               final StackTraceElement stackElem = onCompleteStackElement.get();
164               env.flop(String.format(&quot;Subscription::cancel MUST NOT be called from Subscriber::onComplete (Rule 2.3)! (Caller: %s::%s line %d)&quot;,
165                                      stackElem.getClassName(), stackElem.getMethodName(), stackElem.getLineNumber()));
166             }
167           }
168         };
169 
170         stage.probe = stage.createWhiteboxSubscriberProbe(env);
171         final Subscriber&lt;T&gt; sub = createSubscriber(stage.probe);
172 
173         sub.onSubscribe(subs);
174         sub.onComplete();
175 
176         env.verifyNoAsyncErrorsNoDelay();
177       }
178     });
179   }
180 
181   // Verifies rule: https://github.com/reactive-streams/reactive-streams-jvm#2.3
182   @Override @Test
183   public void required_spec203_mustNotCallMethodsOnSubscriptionOrPublisherInOnError() throws Throwable {
184     subscriberTestWithoutSetup(new TestStageTestRun() {
185       @Override
186       public void run(WhiteboxTestStage stage) throws Throwable {
187         final Subscription subs = new Subscription() {
188           @Override
189           public void request(long n) {
190             Throwable thr = new Throwable();
191             for (StackTraceElement stackElem : thr.getStackTrace()) {
192               if (stackElem.getMethodName().equals(&quot;onError&quot;)) {
193                 env.flop(String.format(&quot;Subscription::request MUST NOT be called from Subscriber::onError (Rule 2.3)! (Caller: %s::%s line %d)&quot;,
194                                        stackElem.getClassName(), stackElem.getMethodName(), stackElem.getLineNumber()));
195               }
196             }
197           }
198 
199           @Override
200           public void cancel() {
201             Throwable thr = new Throwable();
202             for (StackTraceElement stackElem : thr.getStackTrace()) {
203               if (stackElem.getMethodName().equals(&quot;onError&quot;)) {
204                 env.flop(String.format(&quot;Subscription::cancel MUST NOT be called from Subscriber::onError (Rule 2.3)! (Caller: %s::%s line %d)&quot;,
205                                        stackElem.getClassName(), stackElem.getMethodName(), stackElem.getLineNumber()));
206               }
207             }
208           }
209         };
210 
211         stage.probe = stage.createWhiteboxSubscriberProbe(env);
212         final Subscriber&lt;T&gt; sub = createSubscriber(stage.probe);
213 
214         sub.onSubscribe(subs);
215         sub.onError(new TestException());
216 
217         env.verifyNoAsyncErrorsNoDelay();
218       }
219     });
220   }
221 
222   // Verifies rule: https://github.com/reactive-streams/reactive-streams-jvm#2.4
223   @Override @Test
224   public void untested_spec204_mustConsiderTheSubscriptionAsCancelledInAfterRecievingOnCompleteOrOnError() throws Exception {
225     notVerified(); // cannot be meaningfully tested, or can it?
226   }
227 
228   // Verifies rule: https://github.com/reactive-streams/reactive-streams-jvm#2.5
229   @Override @Test
230   public void required_spec205_mustCallSubscriptionCancelIfItAlreadyHasAnSubscriptionAndReceivesAnotherOnSubscribeSignal() throws Throwable {
231     subscriberTest(new TestStageTestRun() {
232       @Override
233       public void run(WhiteboxTestStage stage) throws Throwable {
234         // try to subscribe another time, if the subscriber calls `probe.registerOnSubscribe` the test will fail
235         final Latch secondSubscriptionCancelled = new Latch(env);
236         final Subscriber&lt;? super T&gt; sub = stage.sub();
237         final Subscription subscription = new Subscription() {
238           @Override
239           public void request(long elements) {
240             // ignore...
241           }
242 
243           @Override
244           public void cancel() {
245             secondSubscriptionCancelled.close();
246           }
247 
248           @Override
249           public String toString() {
250             return &quot;SecondSubscription(should get cancelled)&quot;;
251           }
252         };
253         sub.onSubscribe(subscription);
254 
255         secondSubscriptionCancelled.expectClose(&quot;Expected 2nd Subscription given to subscriber to be cancelled, but `Subscription.cancel()` was not called&quot;);
256         env.verifyNoAsyncErrors();
257       }
258     });
259   }
260 
261   // Verifies rule: https://github.com/reactive-streams/reactive-streams-jvm#2.6
262   @Override @Test
263   public void untested_spec206_mustCallSubscriptionCancelIfItIsNoLongerValid() throws Exception {
264     notVerified(); // cannot be meaningfully tested, or can it?
265   }
266 
267   // Verifies rule: https://github.com/reactive-streams/reactive-streams-jvm#2.7
268   @Override @Test
269   public void untested_spec207_mustEnsureAllCallsOnItsSubscriptionTakePlaceFromTheSameThreadOrTakeCareOfSynchronization() throws Exception {
270     notVerified(); // cannot be meaningfully tested, or can it?
271     // the same thread part of the clause can be verified but that is not very useful, or is it?
272   }
273 
274   // Verifies rule: https://github.com/reactive-streams/reactive-streams-jvm#2.8
275   @Override @Test
276   public void required_spec208_mustBePreparedToReceiveOnNextSignalsAfterHavingCalledSubscriptionCancel() throws Throwable {
277     subscriberTest(new TestStageTestRun() {
278       @Override
279       public void run(WhiteboxTestStage stage) throws InterruptedException {
280         stage.puppet().triggerRequest(1);
281         stage.expectRequest();
282         stage.puppet().signalCancel();
283         stage.expectCancelling();
284         stage.signalNext();
285 
286         stage.puppet().triggerRequest(1);
287         stage.puppet().triggerRequest(1);
288 
289         stage.verifyNoAsyncErrors();
290       }
291     });
292   }
293 
294   // Verifies rule: https://github.com/reactive-streams/reactive-streams-jvm#2.9
295   @Override @Test
296   public void required_spec209_mustBePreparedToReceiveAnOnCompleteSignalWithPrecedingRequestCall() throws Throwable {
297     subscriberTest(new TestStageTestRun() {
298       @Override
299       public void run(WhiteboxTestStage stage) throws InterruptedException {
300         stage.puppet().triggerRequest(1);
301         stage.sendCompletion();
302         stage.probe.expectCompletion();
303 
304         stage.verifyNoAsyncErrors();
305       }
306     });
307   }
308 
309   // Verifies rule: https://github.com/reactive-streams/reactive-streams-jvm#2.9
310   @Override @Test
311   public void required_spec209_mustBePreparedToReceiveAnOnCompleteSignalWithoutPrecedingRequestCall() throws Throwable {
312     subscriberTest(new TestStageTestRun() {
313       @Override
314       public void run(WhiteboxTestStage stage) throws InterruptedException {
315         stage.sendCompletion();
316         stage.probe.expectCompletion();
317 
318         stage.verifyNoAsyncErrors();
319       }
320     });
321   }
322 
323   // Verifies rule: https://github.com/reactive-streams/reactive-streams-jvm#2.10
324   @Override @Test
325   public void required_spec210_mustBePreparedToReceiveAnOnErrorSignalWithPrecedingRequestCall() throws Throwable {
326     subscriberTest(new TestStageTestRun() {
327       @Override
328       public void run(WhiteboxTestStage stage) throws InterruptedException {
329         stage.puppet().triggerRequest(1);
330         stage.puppet().triggerRequest(1);
331 
332         Exception ex = new TestException();
333         stage.sendError(ex);
334         stage.probe.expectError(ex);
335 
336         env.verifyNoAsyncErrorsNoDelay();
337       }
338     });
339   }
340 
341   // Verifies rule: https://github.com/reactive-streams/reactive-streams-jvm#2.10
342   @Override @Test
343   public void required_spec210_mustBePreparedToReceiveAnOnErrorSignalWithoutPrecedingRequestCall() throws Throwable {
344     subscriberTest(new TestStageTestRun() {
345       @Override
346       public void run(WhiteboxTestStage stage) throws InterruptedException {
347         Exception ex = new TestException();
348         stage.sendError(ex);
349         stage.probe.expectError(ex);
350 
351         env.verifyNoAsyncErrorsNoDelay();
352       }
353     });
354   }
355 
356   // Verifies rule: https://github.com/reactive-streams/reactive-streams-jvm#2.11
357   @Override @Test
358   public void untested_spec211_mustMakeSureThatAllCallsOnItsMethodsHappenBeforeTheProcessingOfTheRespectiveEvents() throws Exception {
359     notVerified(); // cannot be meaningfully tested, or can it?
360   }
361 
362   // Verifies rule: https://github.com/reactive-streams/reactive-streams-jvm#2.12
363   @Override @Test
364   public void untested_spec212_mustNotCallOnSubscribeMoreThanOnceBasedOnObjectEquality_specViolation() throws Throwable {
365     notVerified(); // cannot be meaningfully tested, or can it?
366   }
367 
368   // Verifies rule: https://github.com/reactive-streams/reactive-streams-jvm#2.13
369   @Override @Test
370   public void untested_spec213_failingOnSignalInvocation() throws Exception {
371     notVerified(); // cannot be meaningfully tested, or can it?
372   }
373 
374   // Verifies rule: https://github.com/reactive-streams/reactive-streams-jvm#2.13
375   @Override @Test
376   public void required_spec213_onSubscribe_mustThrowNullPointerExceptionWhenParametersAreNull() throws Throwable {
377     subscriberTest(new TestStageTestRun() {
378       @Override
379       public void run(WhiteboxTestStage stage) throws Throwable {
380 
381         final Subscriber&lt;? super T&gt; sub = stage.sub();
382         boolean gotNPE = false;
383         try {
384           sub.onSubscribe(null);
385         } catch (final NullPointerException expected) {
386           gotNPE = true;
387         }
388 
389         assertTrue(gotNPE, &quot;onSubscribe(null) did not throw NullPointerException&quot;);
390         env.verifyNoAsyncErrorsNoDelay();
391       }
392     });
393   }
394 
395   // Verifies rule: https://github.com/reactive-streams/reactive-streams-jvm#2.13
396   @Override @Test
397   public void required_spec213_onNext_mustThrowNullPointerExceptionWhenParametersAreNull() throws Throwable {
398     subscriberTest(new TestStageTestRun() {
399       @Override
400       public void run(WhiteboxTestStage stage) throws Throwable {
401 
402         final Subscriber&lt;? super T&gt; sub = stage.sub();
403         boolean gotNPE = false;
404         try {
405           sub.onNext(null);
406         } catch (final NullPointerException expected) {
407           gotNPE = true;
408         }
409 
410         assertTrue(gotNPE, &quot;onNext(null) did not throw NullPointerException&quot;);
411         env.verifyNoAsyncErrorsNoDelay();
412       }
413     });
414   }
415 
416   // Verifies rule: https://github.com/reactive-streams/reactive-streams-jvm#2.13
417   @Override @Test
418   public void required_spec213_onError_mustThrowNullPointerExceptionWhenParametersAreNull() throws Throwable {
419     subscriberTest(new TestStageTestRun() {
420       @Override
421       public void run(WhiteboxTestStage stage) throws Throwable {
422 
423           final Subscriber&lt;? super T&gt; sub = stage.sub();
424           boolean gotNPE = false;
425           try {
426             sub.onError(null);
427           } catch (final NullPointerException expected) {
428             gotNPE = true;
429           } finally {
430             assertTrue(gotNPE, &quot;onError(null) did not throw NullPointerException&quot;);
431           }
432 
433         env.verifyNoAsyncErrorsNoDelay();
434       }
435     });
436   }
437 
438 
439   ////////////////////// SUBSCRIPTION SPEC RULE VERIFICATION //////////////////
440 
441   // Verifies rule: https://github.com/reactive-streams/reactive-streams-jvm#3.1
442   @Override @Test
443   public void untested_spec301_mustNotBeCalledOutsideSubscriberContext() throws Exception {
444     notVerified(); // cannot be meaningfully tested, or can it?
445   }
446 
447   // Verifies rule: https://github.com/reactive-streams/reactive-streams-jvm#3.8
448   @Override @Test
449   public void required_spec308_requestMustRegisterGivenNumberElementsToBeProduced() throws Throwable {
450     subscriberTest(new TestStageTestRun() {
451       @Override
452       public void run(WhiteboxTestStage stage) throws InterruptedException {
453         stage.puppet().triggerRequest(2);
454         long requestedElements = stage.expectRequest();
455         stage.probe.expectNext(stage.signalNext());
456         // Some subscribers may only request one element at a time.
457         if (requestedElements &lt; 2) {
458           stage.expectRequest();
459         }
460         stage.probe.expectNext(stage.signalNext());
461 
462         stage.probe.expectNone();
463         stage.puppet().triggerRequest(3);
464 
465         stage.verifyNoAsyncErrors();
466       }
467     });
468   }
469 
470   // Verifies rule: https://github.com/reactive-streams/reactive-streams-jvm#3.10
471   @Override @Test
472   public void untested_spec310_requestMaySynchronouslyCallOnNextOnSubscriber() throws Exception {
473     notVerified(); // cannot be meaningfully tested, or can it?
474   }
475 
476   // Verifies rule: https://github.com/reactive-streams/reactive-streams-jvm#3.11
477   @Override @Test
478   public void untested_spec311_requestMaySynchronouslyCallOnCompleteOrOnError() throws Exception {
479     notVerified(); // cannot be meaningfully tested, or can it?
480   }
481 
482   // Verifies rule: https://github.com/reactive-streams/reactive-streams-jvm#3.14
483   @Override @Test
484   public void untested_spec314_cancelMayCauseThePublisherToShutdownIfNoOtherSubscriptionExists() throws Exception {
485     notVerified(); // cannot be meaningfully tested, or can it?
486   }
487 
488   // Verifies rule: https://github.com/reactive-streams/reactive-streams-jvm#3.15
489   @Override @Test
490   public void untested_spec315_cancelMustNotThrowExceptionAndMustSignalOnError() throws Exception {
491     notVerified(); // cannot be meaningfully tested, or can it?
492   }
493 
494   // Verifies rule: https://github.com/reactive-streams/reactive-streams-jvm#3.16
495   @Override @Test
496   public void untested_spec316_requestMustNotThrowExceptionAndMustOnErrorTheSubscriber() throws Exception {
497     notVerified(); // cannot be meaningfully tested, or can it?
498   }
499 
500   /////////////////////// ADDITIONAL &quot;COROLLARY&quot; TESTS ////////////////////////
501 
502   /////////////////////// TEST INFRASTRUCTURE /////////////////////////////////
503 
504   abstract class TestStageTestRun {
505     public abstract void run(WhiteboxTestStage stage) throws Throwable;
506   }
507 
508   /**
509    * Prepares subscriber and publisher pair (by subscribing the first to the latter),
510    * and then hands over the tests {@link WhiteboxTestStage} over to the test.
511    *
512    * The test stage is, like in a puppet show, used to orchestrate what each participant should do.
513    * Since this is a whitebox test, this allows the stage to completely control when and how to signal / expect signals.
514    */
515   public void subscriberTest(TestStageTestRun body) throws Throwable {
516     WhiteboxTestStage stage = new WhiteboxTestStage(env, true);
517     body.run(stage);
518   }
519 
520   /**
521    * Provides a {@link WhiteboxTestStage} without performing any additional setup,
522    * like the {@link #subscriberTest(SubscriberWhiteboxVerification.TestStageTestRun)} would.
523    *
524    * Use this method to write tests in which you need full control over when and how the initial {@code subscribe} is signalled.
525    */
526   public void subscriberTestWithoutSetup(TestStageTestRun body) throws Throwable {
527     WhiteboxTestStage stage = new WhiteboxTestStage(env, false);
528     body.run(stage);
529   }
530 
531   /**
532    * Test for feature that MAY be implemented. This test will be marked as SKIPPED if it fails.
533    */
534   public void optionalSubscriberTestWithoutSetup(TestStageTestRun body) throws Throwable {
535     try {
536       subscriberTestWithoutSetup(body);
537     } catch (Exception ex) {
538       notVerified(&quot;Skipped because tested publisher does NOT implement this OPTIONAL requirement.&quot;);
539     }
540   }
541 
542   public class WhiteboxTestStage extends ManualPublisher&lt;T&gt; {
543     public Publisher&lt;T&gt; pub;
544     public ManualSubscriber&lt;T&gt; tees; // gives us access to a stream T values
545     public WhiteboxSubscriberProbe&lt;T&gt; probe;
546 
547     public T lastT = null;
548 
549     public WhiteboxTestStage(TestEnvironment env) throws InterruptedException {
550       this(env, true);
551     }
552 
553     public WhiteboxTestStage(TestEnvironment env, boolean runDefaultInit) throws InterruptedException {
554       super(env);
555       if (runDefaultInit) {
556         pub = this.createHelperPublisher(Long.MAX_VALUE);
557         tees = env.newManualSubscriber(pub);
558         probe = new WhiteboxSubscriberProbe&lt;T&gt;(env, subscriber);
559         subscribe(createSubscriber(probe));
560         probe.puppet.expectCompletion(env.defaultTimeoutMillis(), String.format(&quot;Subscriber %s did not `registerOnSubscribe`&quot;, sub()));
561         env.verifyNoAsyncErrorsNoDelay();
562       }
563     }
564 
565     public Subscriber&lt;? super T&gt; sub() {
566       return subscriber.value();
567     }
568 
569     public SubscriberPuppet puppet() {
570       return probe.puppet();
571     }
572 
573     public WhiteboxSubscriberProbe&lt;T&gt; probe() {
574       return probe;
575     }
576 
577     public Publisher&lt;T&gt; createHelperPublisher(long elements) {
578       return SubscriberWhiteboxVerification.this.createHelperPublisher(elements);
579     }
580 
581     public WhiteboxSubscriberProbe&lt;T&gt; createWhiteboxSubscriberProbe(TestEnvironment env) {
582       return new WhiteboxSubscriberProbe&lt;T&gt;(env, subscriber);
583     }
584 
585     public T signalNext() throws InterruptedException {
586       return signalNext(nextT());
587     }
588 
589     private T signalNext(T element) throws InterruptedException {
590       sendNext(element);
591       return element;
592     }
593 
594     public T nextT() throws InterruptedException {
595       lastT = tees.requestNextElement();
596       return lastT;
597     }
598 
599     public void verifyNoAsyncErrors() {
600       env.verifyNoAsyncErrors();
601     }
602   }
603 
604   /**
605    * This class is intented to be used as {@code Subscriber} decorator and should be used in {@code pub.subscriber(...)} calls,
606    * in order to allow intercepting calls on the underlying {@code Subscriber}.
607    * This delegation allows the proxy to implement {@link BlackboxProbe} assertions.
608    */
609   public static class BlackboxSubscriberProxy&lt;T&gt; extends BlackboxProbe&lt;T&gt; implements Subscriber&lt;T&gt; {
610 
611     public BlackboxSubscriberProxy(TestEnvironment env, Subscriber&lt;T&gt; subscriber) {
612       super(env, Promise.&lt;Subscriber&lt;? super T&gt;&gt;completed(env, subscriber));
613     }
614 
615     @Override
616     public void onSubscribe(Subscription s) {
617       sub().onSubscribe(s);
618     }
619 
620     @Override
621     public void onNext(T t) {
622       registerOnNext(t);
623       sub().onNext(t);
624     }
625 
626     @Override
627     public void onError(Throwable cause) {
628       registerOnError(cause);
629       sub().onError(cause);
630     }
631 
632     @Override
633     public void onComplete() {
634       registerOnComplete();
635       sub().onComplete();
636     }
637   }
638 
639   public static class BlackboxProbe&lt;T&gt; implements SubscriberProbe&lt;T&gt; {
640     protected final TestEnvironment env;
641     protected final Promise&lt;Subscriber&lt;? super T&gt;&gt; subscriber;
642 
643     protected final Receptacle&lt;T&gt; elements;
644     protected final Promise&lt;Throwable&gt; error;
645 
646     public BlackboxProbe(TestEnvironment env, Promise&lt;Subscriber&lt;? super T&gt;&gt; subscriber) {
647       this.env = env;
648       this.subscriber = subscriber;
649       elements = new Receptacle&lt;T&gt;(env);
650       error = new Promise&lt;Throwable&gt;(env);
651     }
652 
653     @Override
654     public void registerOnNext(T element) {
655       elements.add(element);
656     }
657 
658     @Override
659     public void registerOnComplete() {
660       try {
661         elements.complete();
662       } catch (IllegalStateException ex) {
663         // &quot;Queue full&quot;, onComplete was already called
664         env.flop(&quot;subscriber::onComplete was called a second time, which is illegal according to Rule 1.7&quot;);
665       }
666     }
667 
668     @Override
669     public void registerOnError(Throwable cause) {
670       try {
671         error.complete(cause);
672       } catch (IllegalStateException ex) {
673         // &quot;Queue full&quot;, onError was already called
674         env.flop(&quot;subscriber::onError was called a second time, which is illegal according to Rule 1.7&quot;);
675       }
676     }
677 
678     public T expectNext() throws InterruptedException {
679       return elements.next(env.defaultTimeoutMillis(), String.format(&quot;Subscriber %s did not call `registerOnNext(_)`&quot;, sub()));
680     }
681 
682     public void expectNext(T expected) throws InterruptedException {
683       expectNext(expected, env.defaultTimeoutMillis());
684     }
685 
686     public void expectNext(T expected, long timeoutMillis) throws InterruptedException {
687       T received = elements.next(timeoutMillis, String.format(&quot;Subscriber %s did not call `registerOnNext(%s)`&quot;, sub(), expected));
688       if (!received.equals(expected)) {
689         env.flop(String.format(&quot;Subscriber %s called `registerOnNext(%s)` rather than `registerOnNext(%s)`&quot;, sub(), received, expected));
690       }
691     }
692 
693     public Subscriber&lt;? super T&gt; sub() {
694       return subscriber.value();
695     }
696 
697     public void expectCompletion() throws InterruptedException {
698       expectCompletion(env.defaultTimeoutMillis());
699     }
700 
701     public void expectCompletion(long timeoutMillis) throws InterruptedException {
702       expectCompletion(timeoutMillis, String.format(&quot;Subscriber %s did not call `registerOnComplete()`&quot;, sub()));
703     }
704 
705     public void expectCompletion(long timeoutMillis, String msg) throws InterruptedException {
706       elements.expectCompletion(timeoutMillis, msg);
707     }
708 
709     @SuppressWarnings(&quot;ThrowableResultOfMethodCallIgnored&quot;)
710     public &lt;E extends Throwable&gt; void expectErrorWithMessage(Class&lt;E&gt; expected, String requiredMessagePart) throws InterruptedException {
711       final E err = expectError(expected);
712       String message = err.getMessage();
713       assertTrue(message.contains(requiredMessagePart),
714         String.format(&quot;Got expected exception %s but missing message [%s], was: %s&quot;, err.getClass(), requiredMessagePart, expected));
715     }
716 
717     public &lt;E extends Throwable&gt; E expectError(Class&lt;E&gt; expected) throws InterruptedException {
718       return expectError(expected, env.defaultTimeoutMillis());
719     }
720 
721     @SuppressWarnings({&quot;unchecked&quot;, &quot;ThrowableResultOfMethodCallIgnored&quot;})
722     public &lt;E extends Throwable&gt; E expectError(Class&lt;E&gt; expected, long timeoutMillis) throws InterruptedException {
723       error.expectCompletion(timeoutMillis, String.format(&quot;Subscriber %s did not call `registerOnError(%s)`&quot;, sub(), expected));
724       if (error.value() == null) {
725         return env.flopAndFail(String.format(&quot;Subscriber %s did not call `registerOnError(%s)`&quot;, sub(), expected));
726       } else if (expected.isInstance(error.value())) {
727         return (E) error.value();
728       } else {
729         return env.flopAndFail(String.format(&quot;Subscriber %s called `registerOnError(%s)` rather than `registerOnError(%s)`&quot;, sub(), error.value(), expected));
730       }
731     }
732 
733     public void expectError(Throwable expected) throws InterruptedException {
734       expectError(expected, env.defaultTimeoutMillis());
735     }
736 
737     @SuppressWarnings(&quot;ThrowableResultOfMethodCallIgnored&quot;)
738     public void expectError(Throwable expected, long timeoutMillis) throws InterruptedException {
739       error.expectCompletion(timeoutMillis, String.format(&quot;Subscriber %s did not call `registerOnError(%s)`&quot;, sub(), expected));
740       if (error.value() != expected) {
741         env.flop(String.format(&quot;Subscriber %s called `registerOnError(%s)` rather than `registerOnError(%s)`&quot;, sub(), error.value(), expected));
742       }
743     }
744 
745     public void expectNone() throws InterruptedException {
746       expectNone(env.defaultNoSignalsTimeoutMillis());
747     }
748 
749     public void expectNone(long withinMillis) throws InterruptedException {
750       elements.expectNone(withinMillis, &quot;Expected nothing&quot;);
751     }
752 
753   }
754 
755   public static class WhiteboxSubscriberProbe&lt;T&gt; extends BlackboxProbe&lt;T&gt; implements SubscriberPuppeteer {
756     protected Promise&lt;SubscriberPuppet&gt; puppet;
757 
758     public WhiteboxSubscriberProbe(TestEnvironment env, Promise&lt;Subscriber&lt;? super T&gt;&gt; subscriber) {
759       super(env, subscriber);
760       puppet = new Promise&lt;SubscriberPuppet&gt;(env);
761     }
762 
763     private SubscriberPuppet puppet() {
764       return puppet.value();
765     }
766 
767     @Override
768     public void registerOnSubscribe(SubscriberPuppet p) {
769       if (!puppet.isCompleted()) {
770         puppet.complete(p);
771       }
772     }
773 
774   }
775 
776   public interface SubscriberPuppeteer {
777 
778     /**
779      * Must be called by the test subscriber when it has successfully registered a subscription
780      * inside the `onSubscribe` method.
781      */
782     void registerOnSubscribe(SubscriberPuppet puppet);
783   }
784 
785   public interface SubscriberProbe&lt;T&gt; {
786 
787     /**
788      * Must be called by the test subscriber when it has received an`onNext` event.
789      */
790     void registerOnNext(T element);
791 
792     /**
793      * Must be called by the test subscriber when it has received an `onComplete` event.
794      */
795     void registerOnComplete();
796 
797     /**
798      * Must be called by the test subscriber when it has received an `onError` event.
799      */
800     void registerOnError(Throwable cause);
801 
802   }
803 
804   /**
805    * Implement this puppet in your Whitebox style tests.
806    * The test suite will invoke the specific trigger/signal methods requesting you to execute the specific action.
807    * Since this is a whitebox style test, you&#39;re allowed and expected to use knowladge about your implementation to
808    * make implement these calls.
809    */
810   public interface SubscriberPuppet {
811 
812     /**
813      * Ensure that at least {@code elements} are eventually requested by your {@link Subscriber}, if it hasn&#39;t already
814      * requested that many elements.
815      * &lt;p&gt;
816      * This does not necessarily have to correlate 1:1 with a {@code Subscription.request(elements)} call, but the sum
817      * of the elements requested by your {@code Subscriber} must eventually be at least the the sum of the elements
818      * triggered to be requested by all the invocations of this method.
819      * &lt;p&gt;
820      * Additionally, subscribers are permitted to delay requesting elements until previous requests for elements have
821      * been fulfilled. For example, a subscriber that only requests one element at a time may fulfill the request made
822      * by this method by requesting one element {@code elements} times, waiting for each element to arrive before the
823      * next request is made.
824      * &lt;p&gt;
825      * Before sending any element to the subscriber, the TCK must wait for the subscriber to request that element, and
826      * must be prepared for the subscriber to only request one element at a time, it is not enough for the TCK to
827      * simply invoke this method before sending elements.
828      * &lt;p&gt;
829      * An invocation of {@link #signalCancel()} may be coalesced into any elements that have not yet been requested,
830      * such that only a cancel signal is emitted.
831      */
832     void triggerRequest(long elements);
833 
834     /**
835      * Trigger {@code cancel()} on your {@link Subscriber}.
836      * &lt;p&gt;
837      * An invocation of this method may be coalesced into any outstanding requests, as requested by
838      *{@link #triggerRequest(long)}, such that only a cancel signal is emitted.
839      */
840     void signalCancel();
841   }
842 
843   public void notVerified() {
844     throw new SkipException(&quot;Not verified using this TCK.&quot;);
845   }
846 
847   public void notVerified(String msg) {
848     throw new SkipException(msg);
849   }
850 }
    </pre>
  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New test/jdk/java/net/httpclient/websocket/AutomaticPong.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2018, 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 /*
 25  * @test
 26  * @build DummyWebSocketServer
 27  * @run testng/othervm
 28  *      -Djdk.internal.httpclient.websocket.debug=true
 29  *       AutomaticPong
 30  */
 31 import org.testng.annotations.DataProvider;
 32 import org.testng.annotations.Test;
 33 
 34 import java.io.IOException;
 35 import java.net.http.WebSocket;
 36 import java.nio.ByteBuffer;
 37 import java.nio.charset.StandardCharsets;
 38 import java.util.List;
 39 
 40 import static java.net.http.HttpClient.newHttpClient;
 41 import static org.testng.Assert.assertEquals;
 42 import static org.testng.Assert.assertFalse;
 43 import static org.testng.Assert.assertTrue;
 44 import static org.testng.Assert.fail;
 45 
 46 public class AutomaticPong {
 47     /*
 48      * The sendClose method has been invoked and a Ping comes from the server.
 49      * Naturally, the client cannot reply with a Pong (the output has been
 50      * closed). However, this MUST not be treated as an error.
 51      * At this stage the server either has received or pretty soon will receive
 52      * the Close message sent by the sendClose. Thus, the server will know the
 53      * client cannot send further messages and it&#39;s up to the server to decide
 54      * how to react on the corresponding Pong not being received.
 55      */
 56     @Test
 57     public void sendCloseThenAutomaticPong() throws IOException {
 58         int[] bytes = {
 59                 0x89, 0x00,                                     // ping
 60                 0x89, 0x06, 0x68, 0x65, 0x6c, 0x6c, 0x6f, 0x3f, // ping hello?
 61                 0x88, 0x00,                                     // close
 62         };
 63         try (var server = Support.serverWithCannedData(bytes)) {
 64             server.open();
 65             MockListener listener = new MockListener() {
 66                 @Override
 67                 protected void onOpen0(WebSocket webSocket) {
 68                     /* request nothing */
 69                 }
 70             };
 71             var webSocket = newHttpClient()
 72                     .newWebSocketBuilder()
 73                     .buildAsync(server.getURI(), listener)
 74                     .join();
 75             try {
 76                 webSocket.sendClose(WebSocket.NORMAL_CLOSURE, &quot;ok&quot;).join();
 77                 // now request all messages available
 78                 webSocket.request(Long.MAX_VALUE);
 79                 List&lt;MockListener.Invocation&gt; actual = listener.invocations();
 80                 ByteBuffer hello = ByteBuffer.wrap(&quot;hello?&quot;.getBytes(StandardCharsets.UTF_8));
 81                 ByteBuffer empty = ByteBuffer.allocate(0);
 82                 List&lt;MockListener.Invocation&gt; expected = List.of(
 83                         MockListener.Invocation.onOpen(webSocket),
 84                         MockListener.Invocation.onPing(webSocket, empty),
 85                         MockListener.Invocation.onPing(webSocket, hello),
 86                         MockListener.Invocation.onClose(webSocket, 1005, &quot;&quot;)
 87                 );
 88                 assertEquals(actual, expected);
 89             } finally {
 90                 webSocket.abort();
 91             }
 92         }
 93     }
 94 
 95     /*
 96      * The server sends a number of contiguous Ping messages. The client replies
 97      * to these messages automatically. According to RFC 6455 a WebSocket client
 98      * is free to reply only to the most recent Pings.
 99      *
100      * What is checked here is that:
101      *
102      *     a) the order of Pong replies corresponds to the Pings received,
103      *     b) the last Pong corresponds to the last Ping
104      *     c) there are no unrelated Pongs
105      */
106     @Test(dataProvider = &quot;nPings&quot;)
107     public void automaticPongs(int nPings) throws Exception {
108         // big enough to not bother with resize
109         ByteBuffer buffer = ByteBuffer.allocate(65536);
110         Frame.HeaderWriter w = new Frame.HeaderWriter();
111         for (int i = 0; i &lt; nPings; i++) {
112             w.fin(true)
113              .opcode(Frame.Opcode.PING)
114              .noMask()
115              .payloadLen(4)    // the length of the number of the Ping (int)
116              .write(buffer);
117             buffer.putInt(i);  // the number of the Ping (int)
118         }
119         w.fin(true)
120          .opcode(Frame.Opcode.CLOSE)
121          .noMask()
122          .payloadLen(2)
123         .write(buffer);
124         buffer.putChar((char) 1000);
125         buffer.flip();
126         try (var server = Support.serverWithCannedData(buffer.array())) {
127             server.open();
128             MockListener listener = new MockListener();
129             var webSocket = newHttpClient()
130                     .newWebSocketBuilder()
131                     .buildAsync(server.getURI(), listener)
132                     .join();
133             try {
134                 List&lt;MockListener.Invocation&gt; inv = listener.invocations();
135                 assertEquals(inv.size(), nPings + 2); // n * onPing + onOpen + onClose
136 
137                 ByteBuffer data = server.read();
138                 Frame.Reader reader = new Frame.Reader();
139 
140                 Frame.Consumer consumer = new Frame.Consumer() {
141 
142                     ByteBuffer number = ByteBuffer.allocate(4);
143                     Frame.Masker masker = new Frame.Masker();
144                     int i = -1;
145                     boolean closed;
146 
147                     @Override
148                     public void fin(boolean value) {
149                         assertTrue(value);
150                     }
151 
152                     @Override
153                     public void rsv1(boolean value) {
154                         assertFalse(value);
155                     }
156 
157                     @Override
158                     public void rsv2(boolean value) {
159                         assertFalse(value);
160                     }
161 
162                     @Override
163                     public void rsv3(boolean value) {
164                         assertFalse(value);
165                     }
166 
167                     @Override
168                     public void opcode(Frame.Opcode value) {
169                         if (value == Frame.Opcode.CLOSE) {
170                             closed = true;
171                             return;
172                         }
173                         assertEquals(value, Frame.Opcode.PONG);
174                     }
175 
176                     @Override
177                     public void mask(boolean value) {
178                         assertTrue(value);
179                     }
180 
181                     @Override
182                     public void payloadLen(long value) {
183                         if (!closed)
184                             assertEquals(value, 4);
185                     }
186 
187                     @Override
188                     public void maskingKey(int value) {
189                         masker.mask(value);
190                     }
191 
192                     @Override
193                     public void payloadData(ByteBuffer src) {
194                         masker.transferMasking(src, number);
195                         if (closed) {
196                             return;
197                         }
198                         number.flip();
199                         int n = number.getInt();
200                         System.out.printf(&quot;pong number=%s%n&quot;, n);
201                         number.clear();
202                         // a Pong with the number less than the maximum of Pongs already
203                         // received MUST never be received
204                         if (i &gt;= n) {
205                             fail(String.format(&quot;i=%s, n=%s&quot;, i, n));
206                         }
207                         i = n;
208                     }
209 
210                     @Override
211                     public void endFrame() {
212                     }
213                 };
214                 while (data.hasRemaining()) {
215                     reader.readFrame(data, consumer);
216                 }
217             } finally {
218                 webSocket.abort();
219             }
220         }
221     }
222 
223 
224     @DataProvider(name = &quot;nPings&quot;)
225     public Object[][] nPings() {
226         return new Object[][]{{1}, {2}, {4}, {8}, {9}, {256}};
227     }
228 }
    </pre>
  </body>
</html>
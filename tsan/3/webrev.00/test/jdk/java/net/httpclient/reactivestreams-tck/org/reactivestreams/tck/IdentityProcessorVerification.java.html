<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New test/jdk/java/net/httpclient/reactivestreams-tck/org/reactivestreams/tck/IdentityProcessorVerification.java</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 package org.reactivestreams.tck;
 25 
 26 import org.reactivestreams.Processor;
 27 import org.reactivestreams.Publisher;
 28 import org.reactivestreams.Subscriber;
 29 import org.reactivestreams.Subscription;
 30 import org.reactivestreams.tck.TestEnvironment.ManualPublisher;
 31 import org.reactivestreams.tck.TestEnvironment.ManualSubscriber;
 32 import org.reactivestreams.tck.TestEnvironment.ManualSubscriberWithSubscriptionSupport;
 33 import org.reactivestreams.tck.TestEnvironment.Promise;
 34 import org.reactivestreams.tck.flow.support.Function;
 35 import org.reactivestreams.tck.flow.support.SubscriberWhiteboxVerificationRules;
 36 import org.reactivestreams.tck.flow.support.PublisherVerificationRules;
 37 import org.testng.annotations.BeforeMethod;
 38 import org.testng.annotations.Test;
 39 
 40 import java.util.HashSet;
 41 import java.util.Set;
 42 
 43 public abstract class IdentityProcessorVerification&lt;T&gt; extends WithHelperPublisher&lt;T&gt;
 44   implements SubscriberWhiteboxVerificationRules, PublisherVerificationRules {
 45 
 46   private final TestEnvironment env;
 47 
 48   ////////////////////// DELEGATED TO SPECS //////////////////////
 49 
 50   // for delegating tests
 51   private final SubscriberWhiteboxVerification&lt;T&gt; subscriberVerification;
 52 
 53   // for delegating tests
 54   private final PublisherVerification&lt;T&gt; publisherVerification;
 55 
 56   ////////////////// END OF DELEGATED TO SPECS //////////////////
 57 
 58   // number of elements the processor under test must be able ot buffer,
 59   // without dropping elements. Defaults to `TestEnvironment.TEST_BUFFER_SIZE`.
 60   private final int processorBufferSize;
 61 
 62   /**
 63    * Test class must specify the expected time it takes for the publisher to
 64    * shut itself down when the the last downstream {@code Subscription} is cancelled.
 65    *
 66    * The processor will be required to be able to buffer {@code TestEnvironment.TEST_BUFFER_SIZE} elements.
 67    */
 68   @SuppressWarnings(&quot;unused&quot;)
 69   public IdentityProcessorVerification(final TestEnvironment env) {
 70     this(env, PublisherVerification.envPublisherReferenceGCTimeoutMillis(), TestEnvironment.TEST_BUFFER_SIZE);
 71   }
 72 
 73   /**
 74    * Test class must specify the expected time it takes for the publisher to
 75    * shut itself down when the the last downstream {@code Subscription} is cancelled.
 76    *
 77    * The processor will be required to be able to buffer {@code TestEnvironment.TEST_BUFFER_SIZE} elements.
 78    *
 79    * @param publisherReferenceGCTimeoutMillis used to determine after how much time a reference to a Subscriber should be already dropped by the Publisher.
 80    */
 81   @SuppressWarnings(&quot;unused&quot;)
 82   public IdentityProcessorVerification(final TestEnvironment env, long publisherReferenceGCTimeoutMillis) {
 83     this(env, publisherReferenceGCTimeoutMillis, TestEnvironment.TEST_BUFFER_SIZE);
 84   }
 85 
 86   /**
 87    * Test class must specify the expected time it takes for the publisher to
 88    * shut itself down when the the last downstream {@code Subscription} is cancelled.
 89    *
 90    * @param publisherReferenceGCTimeoutMillis used to determine after how much time a reference to a Subscriber should be already dropped by the Publisher.
 91    * @param processorBufferSize            number of elements the processor is required to be able to buffer.
 92    */
 93   public IdentityProcessorVerification(final TestEnvironment env, long publisherReferenceGCTimeoutMillis, int processorBufferSize) {
 94     this.env = env;
 95     this.processorBufferSize = processorBufferSize;
 96 
 97     this.subscriberVerification = new SubscriberWhiteboxVerification&lt;T&gt;(env) {
 98       @Override
 99       public Subscriber&lt;T&gt; createSubscriber(WhiteboxSubscriberProbe&lt;T&gt; probe) {
100         return IdentityProcessorVerification.this.createSubscriber(probe);
101       }
102 
103       @Override public T createElement(int element) {
104         return IdentityProcessorVerification.this.createElement(element);
105       }
106 
107       @Override
108       public Publisher&lt;T&gt; createHelperPublisher(long elements) {
109         return IdentityProcessorVerification.this.createHelperPublisher(elements);
110       }
111     };
112 
113     publisherVerification = new PublisherVerification&lt;T&gt;(env, publisherReferenceGCTimeoutMillis) {
114       @Override
115       public Publisher&lt;T&gt; createPublisher(long elements) {
116         return IdentityProcessorVerification.this.createPublisher(elements);
117       }
118 
119       @Override
120       public Publisher&lt;T&gt; createFailedPublisher() {
121         return IdentityProcessorVerification.this.createFailedPublisher();
122       }
123 
124       @Override
125       public long maxElementsFromPublisher() {
126         return IdentityProcessorVerification.this.maxElementsFromPublisher();
127       }
128 
129       @Override
130       public long boundedDepthOfOnNextAndRequestRecursion() {
131         return IdentityProcessorVerification.this.boundedDepthOfOnNextAndRequestRecursion();
132       }
133 
134       @Override
135       public boolean skipStochasticTests() {
136         return IdentityProcessorVerification.this.skipStochasticTests();
137       }
138     };
139   }
140 
141   /**
142    * This is the main method you must implement in your test incarnation.
143    * It must create a {@link Processor}, which simply forwards all stream elements from its upstream
144    * to its downstream. It must be able to internally buffer the given number of elements.
145    *
146    * @param bufferSize number of elements the processor is required to be able to buffer.
147    */
148   public abstract Processor&lt;T, T&gt; createIdentityProcessor(int bufferSize);
149 
150   /**
151    * By implementing this method, additional TCK tests concerning a &quot;failed&quot; publishers will be run.
152    *
153    * The expected behaviour of the {@link Publisher} returned by this method is hand out a subscription,
154    * followed by signalling {@code onError} on it, as specified by Rule 1.9.
155    *
156    * If you want to ignore these additional tests, return {@code null} from this method.
157    */
158   public abstract Publisher&lt;T&gt; createFailedPublisher();
159 
160   /**
161    * Override and return lower value if your Publisher is only able to produce a known number of elements.
162    * For example, if it is designed to return at-most-one element, return {@code 1} from this method.
163    *
164    * Defaults to {@code Long.MAX_VALUE - 1}, meaning that the Publisher can be produce a huge but NOT an unbounded number of elements.
165    *
166    * To mark your Publisher will *never* signal an {@code onComplete} override this method and return {@code Long.MAX_VALUE},
167    * which will result in *skipping all tests which require an onComplete to be triggered* (!).
168    */
169   public long maxElementsFromPublisher() {
170     return Long.MAX_VALUE - 1;
171   }
172 
173   /**
174    * In order to verify rule 3.3 of the reactive streams spec, this number will be used to check if a
175    * {@code Subscription} actually solves the &quot;unbounded recursion&quot; problem by not allowing the number of
176    * recursive calls to exceed the number returned by this method.
177    *
178    * @see &lt;a href=&quot;https://github.com/reactive-streams/reactive-streams-jvm#3.3&quot;&gt;reactive streams spec, rule 3.3&lt;/a&gt;
179    * @see PublisherVerification#required_spec303_mustNotAllowUnboundedRecursion()
180    */
181   public long boundedDepthOfOnNextAndRequestRecursion() {
182     return 1;
183   }
184 
185   /**
186    * Override and return {@code true} in order to skip executing tests marked as {@code Stochastic}.
187    * Stochastic in this case means that the Rule is impossible or infeasible to deterministically verify—
188    * usually this means that this test case can yield false positives (&quot;be green&quot;) even if for some case,
189    * the given implementation may violate the tested behaviour.
190    */
191   public boolean skipStochasticTests() {
192     return false;
193   }
194 
195   /**
196    * Describes the tested implementation in terms of how many subscribers they can support.
197    * Some tests require the {@code Publisher} under test to support multiple Subscribers,
198    * yet the spec does not require all publishers to be able to do so, thus – if an implementation
199    * supports only a limited number of subscribers (e.g. only 1 subscriber, also known as &quot;no fanout&quot;)
200    * you MUST return that number from this method by overriding it.
201    */
202   public long maxSupportedSubscribers() {
203       return Long.MAX_VALUE;
204   }
205 
206   /**
207    * Override this method and return {@code true} if the {@link Processor} returned by the
208    * {@link #createIdentityProcessor(int)} coordinates its {@link Subscriber}s
209    * request amounts and only delivers onNext signals if all Subscribers have
210    * indicated (via their Subscription#request(long)) they are ready to receive elements.
211    */
212   public boolean doesCoordinatedEmission() {
213     return false;
214   }
215 
216   ////////////////////// TEST ENV CLEANUP /////////////////////////////////////
217 
218   @BeforeMethod
219   public void setUp() throws Exception {
220     publisherVerification.setUp();
221     subscriberVerification.setUp();
222   }
223 
224   ////////////////////// PUBLISHER RULES VERIFICATION ///////////////////////////
225 
226   // A Processor
227   //   must obey all Publisher rules on its publishing side
228   public Publisher&lt;T&gt; createPublisher(long elements) {
229     final Processor&lt;T, T&gt; processor = createIdentityProcessor(processorBufferSize);
230     final Publisher&lt;T&gt; pub = createHelperPublisher(elements);
231     pub.subscribe(processor);
232     return processor; // we run the PublisherVerification against this
233   }
234 
235   @Override @Test
236   public void required_validate_maxElementsFromPublisher() throws Exception {
237     publisherVerification.required_validate_maxElementsFromPublisher();
238   }
239 
240   @Override @Test
241   public void required_validate_boundedDepthOfOnNextAndRequestRecursion() throws Exception {
242     publisherVerification.required_validate_boundedDepthOfOnNextAndRequestRecursion();
243   }
244 
245   /////////////////////// DELEGATED TESTS, A PROCESSOR &quot;IS A&quot; PUBLISHER //////////////////////
246   // Verifies rule: https://github.com/reactive-streams/reactive-streams-jvm#4.1
247 
248   @Test
249   public void required_createPublisher1MustProduceAStreamOfExactly1Element() throws Throwable {
250     publisherVerification.required_createPublisher1MustProduceAStreamOfExactly1Element();
251   }
252 
253   @Test
254   public void required_createPublisher3MustProduceAStreamOfExactly3Elements() throws Throwable {
255     publisherVerification.required_createPublisher3MustProduceAStreamOfExactly3Elements();
256   }
257 
258   @Override @Test
259   public void required_spec101_subscriptionRequestMustResultInTheCorrectNumberOfProducedElements() throws Throwable {
260     publisherVerification.required_spec101_subscriptionRequestMustResultInTheCorrectNumberOfProducedElements();
261   }
262 
263   @Override @Test
264   public void required_spec102_maySignalLessThanRequestedAndTerminateSubscription() throws Throwable {
265     publisherVerification.required_spec102_maySignalLessThanRequestedAndTerminateSubscription();
266   }
267 
268   @Override @Test
269   public void stochastic_spec103_mustSignalOnMethodsSequentially() throws Throwable {
270     publisherVerification.stochastic_spec103_mustSignalOnMethodsSequentially();
271   }
272 
273   @Override @Test
274   public void optional_spec104_mustSignalOnErrorWhenFails() throws Throwable {
275     publisherVerification.optional_spec104_mustSignalOnErrorWhenFails();
276   }
277 
278   @Override @Test
279   public void required_spec105_mustSignalOnCompleteWhenFiniteStreamTerminates() throws Throwable {
280     publisherVerification.required_spec105_mustSignalOnCompleteWhenFiniteStreamTerminates();
281   }
282 
283   @Override @Test
284   public void optional_spec105_emptyStreamMustTerminateBySignallingOnComplete() throws Throwable {
285     publisherVerification.optional_spec105_emptyStreamMustTerminateBySignallingOnComplete();
286   }
287 
288   @Override @Test
289   public void untested_spec106_mustConsiderSubscriptionCancelledAfterOnErrorOrOnCompleteHasBeenCalled() throws Throwable {
290     publisherVerification.untested_spec106_mustConsiderSubscriptionCancelledAfterOnErrorOrOnCompleteHasBeenCalled();
291   }
292 
293   @Override @Test
294   public void required_spec107_mustNotEmitFurtherSignalsOnceOnCompleteHasBeenSignalled() throws Throwable {
295     publisherVerification.required_spec107_mustNotEmitFurtherSignalsOnceOnCompleteHasBeenSignalled();
296   }
297 
298   @Override @Test
299   public void untested_spec107_mustNotEmitFurtherSignalsOnceOnErrorHasBeenSignalled() throws Throwable {
300     publisherVerification.untested_spec107_mustNotEmitFurtherSignalsOnceOnErrorHasBeenSignalled();
301   }
302 
303   @Override @Test
304   public void untested_spec108_possiblyCanceledSubscriptionShouldNotReceiveOnErrorOrOnCompleteSignals() throws Throwable {
305     publisherVerification.untested_spec108_possiblyCanceledSubscriptionShouldNotReceiveOnErrorOrOnCompleteSignals();
306   }
307 
308   @Override @Test
309   public void untested_spec109_subscribeShouldNotThrowNonFatalThrowable() throws Throwable {
310     publisherVerification.untested_spec109_subscribeShouldNotThrowNonFatalThrowable();
311   }
312 
313   @Override @Test
314   public void required_spec109_subscribeThrowNPEOnNullSubscriber() throws Throwable {
315     publisherVerification.required_spec109_subscribeThrowNPEOnNullSubscriber();
316   }
317 
318   @Override @Test
319   public void required_spec109_mayRejectCallsToSubscribeIfPublisherIsUnableOrUnwillingToServeThemRejectionMustTriggerOnErrorAfterOnSubscribe() throws Throwable {
320     publisherVerification.required_spec109_mayRejectCallsToSubscribeIfPublisherIsUnableOrUnwillingToServeThemRejectionMustTriggerOnErrorAfterOnSubscribe();
321   }
322 
323   @Override @Test
324   public void required_spec109_mustIssueOnSubscribeForNonNullSubscriber() throws Throwable {
325     publisherVerification.required_spec109_mustIssueOnSubscribeForNonNullSubscriber();
326   }
327 
328   @Override @Test
329   public void untested_spec110_rejectASubscriptionRequestIfTheSameSubscriberSubscribesTwice() throws Throwable {
330     publisherVerification.untested_spec110_rejectASubscriptionRequestIfTheSameSubscriberSubscribesTwice();
331   }
332 
333   @Override @Test
334   public void optional_spec111_maySupportMultiSubscribe() throws Throwable {
335     publisherVerification.optional_spec111_maySupportMultiSubscribe();
336   }
337 
338   @Override @Test
339   public void optional_spec111_registeredSubscribersMustReceiveOnNextOrOnCompleteSignals() throws Throwable {
340     publisherVerification.optional_spec111_registeredSubscribersMustReceiveOnNextOrOnCompleteSignals();
341   }
342 
343   @Override @Test
344   public void optional_spec111_multicast_mustProduceTheSameElementsInTheSameSequenceToAllOfItsSubscribersWhenRequestingOneByOne() throws Throwable {
345     publisherVerification.optional_spec111_multicast_mustProduceTheSameElementsInTheSameSequenceToAllOfItsSubscribersWhenRequestingOneByOne();
346   }
347 
348   @Override @Test
349   public void optional_spec111_multicast_mustProduceTheSameElementsInTheSameSequenceToAllOfItsSubscribersWhenRequestingManyUpfront() throws Throwable {
350     publisherVerification.optional_spec111_multicast_mustProduceTheSameElementsInTheSameSequenceToAllOfItsSubscribersWhenRequestingManyUpfront();
351   }
352 
353   @Override @Test
354   public void optional_spec111_multicast_mustProduceTheSameElementsInTheSameSequenceToAllOfItsSubscribersWhenRequestingManyUpfrontAndCompleteAsExpected() throws Throwable {
355     publisherVerification.optional_spec111_multicast_mustProduceTheSameElementsInTheSameSequenceToAllOfItsSubscribersWhenRequestingManyUpfrontAndCompleteAsExpected();
356   }
357 
358   @Override @Test
359   public void required_spec302_mustAllowSynchronousRequestCallsFromOnNextAndOnSubscribe() throws Throwable {
360     publisherVerification.required_spec302_mustAllowSynchronousRequestCallsFromOnNextAndOnSubscribe();
361   }
362 
363   @Override @Test
364   public void required_spec303_mustNotAllowUnboundedRecursion() throws Throwable {
365     publisherVerification.required_spec303_mustNotAllowUnboundedRecursion();
366   }
367 
368   @Override @Test
369   public void untested_spec304_requestShouldNotPerformHeavyComputations() throws Exception {
370     publisherVerification.untested_spec304_requestShouldNotPerformHeavyComputations();
371   }
372 
373   @Override @Test
374   public void untested_spec305_cancelMustNotSynchronouslyPerformHeavyComputation() throws Exception {
375     publisherVerification.untested_spec305_cancelMustNotSynchronouslyPerformHeavyComputation();
376   }
377 
378   @Override @Test
379   public void required_spec306_afterSubscriptionIsCancelledRequestMustBeNops() throws Throwable {
380     publisherVerification.required_spec306_afterSubscriptionIsCancelledRequestMustBeNops();
381   }
382 
383   @Override @Test
384   public void required_spec307_afterSubscriptionIsCancelledAdditionalCancelationsMustBeNops() throws Throwable {
385     publisherVerification.required_spec307_afterSubscriptionIsCancelledAdditionalCancelationsMustBeNops();
386   }
387 
388   @Override @Test
389   public void required_spec309_requestZeroMustSignalIllegalArgumentException() throws Throwable {
390     publisherVerification.required_spec309_requestZeroMustSignalIllegalArgumentException();
391   }
392 
393   @Override @Test
394   public void required_spec309_requestNegativeNumberMustSignalIllegalArgumentException() throws Throwable {
395     publisherVerification.required_spec309_requestNegativeNumberMustSignalIllegalArgumentException();
396   }
397 
398   @Override @Test
399   public void optional_spec309_requestNegativeNumberMaySignalIllegalArgumentExceptionWithSpecificMessage() throws Throwable {
400     publisherVerification.optional_spec309_requestNegativeNumberMaySignalIllegalArgumentExceptionWithSpecificMessage();
401   }
402 
403   @Override @Test
404   public void required_spec312_cancelMustMakeThePublisherToEventuallyStopSignaling() throws Throwable {
405     publisherVerification.required_spec312_cancelMustMakeThePublisherToEventuallyStopSignaling();
406   }
407 
408   @Override @Test
409   public void required_spec313_cancelMustMakeThePublisherEventuallyDropAllReferencesToTheSubscriber() throws Throwable {
410     publisherVerification.required_spec313_cancelMustMakeThePublisherEventuallyDropAllReferencesToTheSubscriber();
411   }
412 
413   @Override @Test
414   public void required_spec317_mustSupportAPendingElementCountUpToLongMaxValue() throws Throwable {
415     publisherVerification.required_spec317_mustSupportAPendingElementCountUpToLongMaxValue();
416   }
417 
418   @Override @Test
419   public void required_spec317_mustSupportACumulativePendingElementCountUpToLongMaxValue() throws Throwable {
420     publisherVerification.required_spec317_mustSupportACumulativePendingElementCountUpToLongMaxValue();
421   }
422 
423   @Override @Test
424   public void required_spec317_mustNotSignalOnErrorWhenPendingAboveLongMaxValue() throws Throwable {
425     publisherVerification.required_spec317_mustNotSignalOnErrorWhenPendingAboveLongMaxValue();
426   }
427 
428 
429   /**
430    * Asks for a {@code Processor} that supports at least 2 {@code Subscriber}s at once and checks if two {@code Subscriber}s
431    * receive the same items and a terminal {@code Exception}.
432    * &lt;p&gt;
433    * If the {@code Processor} requests and/or emits items only when all of its {@code Subscriber}s have requested,
434    * override {@link #doesCoordinatedEmission()} and return {@code true} to indicate this property.
435    * &lt;p&gt;
436    * &lt;b&gt;Verifies rule:&lt;/b&gt; &lt;a href=&#39;https://github.com/reactive-streams/reactive-streams-jvm#1.4&#39;&gt;1.4&lt;/a&gt; with multiple
437    * {@code Subscriber}s.
438    * &lt;p&gt;
439    * The test is not executed if {@link IdentityProcessorVerification#maxSupportedSubscribers()} is less than 2.
440    * &lt;p&gt;
441    * If this test fails, the following could be checked within the {@code Processor} implementation:
442    * &lt;ul&gt;
443    * &lt;li&gt;The {@code TestEnvironment} has large enough timeout specified in case the {@code Processor} has some time-delay behavior.&lt;/li&gt;
444    * &lt;li&gt;The {@code Processor} is able to fulfill requests of its {@code Subscriber}s independently of each other&#39;s requests or
445    * else override {@link #doesCoordinatedEmission()} and return {@code true} to indicate the test {@code Subscriber}s
446    * both have to request first.&lt;/li&gt;
447    * &lt;/ul&gt;
448    */
449   @Test
450   public void required_spec104_mustCallOnErrorOnAllItsSubscribersIfItEncountersANonRecoverableError() throws Throwable {
451     optionalMultipleSubscribersTest(2, new Function&lt;Long,TestSetup&gt;() {
452       @Override
453       public TestSetup apply(Long aLong) throws Throwable {
454         return new TestSetup(env, processorBufferSize) {{
455           final ManualSubscriberWithErrorCollection&lt;T&gt; sub1 = new ManualSubscriberWithErrorCollection&lt;T&gt;(env);
456           env.subscribe(processor, sub1);
457 
458           final ManualSubscriberWithErrorCollection&lt;T&gt; sub2 = new ManualSubscriberWithErrorCollection&lt;T&gt;(env);
459           env.subscribe(processor, sub2);
460 
461           final Exception ex = new RuntimeException(&quot;Test exception&quot;);
462 
463           if (doesCoordinatedEmission()) {
464             sub1.request(1);
465             sub2.request(1);
466 
467             expectRequest();
468 
469             final T x = sendNextTFromUpstream();
470 
471             expectNextElement(sub1, x);
472             expectNextElement(sub2, x);
473 
474             sub1.request(1);
475             sub2.request(1);
476           } else {
477             sub1.request(1);
478 
479             expectRequest(env.defaultTimeoutMillis(),
480                     &quot;If the Processor coordinates requests/emissions when having multiple Subscribers&quot;
481                     + &quot; at once, please override doesCoordinatedEmission() to return true in this &quot;
482                     + &quot;IdentityProcessorVerification to allow this test to pass.&quot;);
483 
484             final T x = sendNextTFromUpstream();
485             expectNextElement(sub1, x,
486                     &quot;If the Processor coordinates requests/emissions when having multiple Subscribers&quot;
487                             + &quot; at once, please override doesCoordinatedEmission() to return true in this &quot;
488                             + &quot;IdentityProcessorVerification to allow this test to pass.&quot;);
489 
490             sub1.request(1);
491 
492             // sub1 has received one element, and has one demand pending
493             // sub2 has not yet requested anything
494           }
495           sendError(ex);
496 
497           sub1.expectError(ex);
498           sub2.expectError(ex);
499 
500           env.verifyNoAsyncErrorsNoDelay();
501         }};
502       }
503     });
504   }
505 
506   ////////////////////// SUBSCRIBER RULES VERIFICATION ///////////////////////////
507   // Verifies rule: https://github.com/reactive-streams/reactive-streams-jvm#4.1
508 
509   // A Processor
510   //   must obey all Subscriber rules on its consuming side
511   public Subscriber&lt;T&gt; createSubscriber(final SubscriberWhiteboxVerification.WhiteboxSubscriberProbe&lt;T&gt; probe) {
512     final Processor&lt;T, T&gt; processor = createIdentityProcessor(processorBufferSize);
513     processor.subscribe(
514         new Subscriber&lt;T&gt;() {
515           private final Promise&lt;Subscription&gt; subs = new Promise&lt;Subscription&gt;(env);
516 
517           @Override
518           public void onSubscribe(final Subscription subscription) {
519             if (env.debugEnabled()) {
520               env.debug(String.format(&quot;whiteboxSubscriber::onSubscribe(%s)&quot;, subscription));
521             }
522             if (subs.isCompleted()) subscription.cancel(); // the Probe must also pass subscriber verification
523 
524             probe.registerOnSubscribe(new SubscriberWhiteboxVerification.SubscriberPuppet() {
525 
526               @Override
527               public void triggerRequest(long elements) {
528                 subscription.request(elements);
529               }
530 
531               @Override
532               public void signalCancel() {
533                 subscription.cancel();
534               }
535             });
536           }
537 
538           @Override
539           public void onNext(T element) {
540             if (env.debugEnabled()) {
541               env.debug(String.format(&quot;whiteboxSubscriber::onNext(%s)&quot;, element));
542             }
543             probe.registerOnNext(element);
544           }
545 
546           @Override
547           public void onComplete() {
548             if (env.debugEnabled()) {
549               env.debug(&quot;whiteboxSubscriber::onComplete()&quot;);
550             }
551             probe.registerOnComplete();
552           }
553 
554           @Override
555           public void onError(Throwable cause) {
556             if (env.debugEnabled()) {
557               env.debug(String.format(&quot;whiteboxSubscriber::onError(%s)&quot;, cause));
558             }
559             probe.registerOnError(cause);
560           }
561         });
562 
563     return processor; // we run the SubscriberVerification against this
564   }
565 
566   ////////////////////// OTHER RULE VERIFICATION ///////////////////////////
567 
568   // A Processor
569   //   must immediately pass on `onError` events received from its upstream to its downstream
570   @Test
571   public void mustImmediatelyPassOnOnErrorEventsReceivedFromItsUpstreamToItsDownstream() throws Exception {
572     new TestSetup(env, processorBufferSize) {{
573       final ManualSubscriberWithErrorCollection&lt;T&gt; sub = new ManualSubscriberWithErrorCollection&lt;T&gt;(env);
574       env.subscribe(processor, sub);
575 
576       final Exception ex = new RuntimeException(&quot;Test exception&quot;);
577       sendError(ex);
578       sub.expectError(ex); // &quot;immediately&quot;, i.e. without a preceding request
579 
580       env.verifyNoAsyncErrorsNoDelay();
581     }};
582   }
583 
584   /////////////////////// DELEGATED TESTS, A PROCESSOR &quot;IS A&quot; SUBSCRIBER //////////////////////
585   // Verifies rule: https://github.com/reactive-streams/reactive-streams-jvm#4.1
586 
587   @Test
588   public void required_exerciseWhiteboxHappyPath() throws Throwable {
589     subscriberVerification.required_exerciseWhiteboxHappyPath();
590   }
591 
592   @Override @Test
593   public void required_spec201_mustSignalDemandViaSubscriptionRequest() throws Throwable {
594     subscriberVerification.required_spec201_mustSignalDemandViaSubscriptionRequest();
595   }
596 
597   @Override @Test
598   public void untested_spec202_shouldAsynchronouslyDispatch() throws Exception {
599     subscriberVerification.untested_spec202_shouldAsynchronouslyDispatch();
600   }
601 
602   @Override @Test
603   public void required_spec203_mustNotCallMethodsOnSubscriptionOrPublisherInOnComplete() throws Throwable {
604     subscriberVerification.required_spec203_mustNotCallMethodsOnSubscriptionOrPublisherInOnComplete();
605   }
606 
607   @Override @Test
608   public void required_spec203_mustNotCallMethodsOnSubscriptionOrPublisherInOnError() throws Throwable {
609     subscriberVerification.required_spec203_mustNotCallMethodsOnSubscriptionOrPublisherInOnError();
610   }
611 
612   @Override @Test
613   public void untested_spec204_mustConsiderTheSubscriptionAsCancelledInAfterRecievingOnCompleteOrOnError() throws Exception {
614     subscriberVerification.untested_spec204_mustConsiderTheSubscriptionAsCancelledInAfterRecievingOnCompleteOrOnError();
615   }
616 
617   @Override @Test
618   public void required_spec205_mustCallSubscriptionCancelIfItAlreadyHasAnSubscriptionAndReceivesAnotherOnSubscribeSignal() throws Throwable {
619     subscriberVerification.required_spec205_mustCallSubscriptionCancelIfItAlreadyHasAnSubscriptionAndReceivesAnotherOnSubscribeSignal();
620   }
621 
622   @Override @Test
623   public void untested_spec206_mustCallSubscriptionCancelIfItIsNoLongerValid() throws Exception {
624     subscriberVerification.untested_spec206_mustCallSubscriptionCancelIfItIsNoLongerValid();
625   }
626 
627   @Override @Test
628   public void untested_spec207_mustEnsureAllCallsOnItsSubscriptionTakePlaceFromTheSameThreadOrTakeCareOfSynchronization() throws Exception {
629     subscriberVerification.untested_spec207_mustEnsureAllCallsOnItsSubscriptionTakePlaceFromTheSameThreadOrTakeCareOfSynchronization();
630   }
631 
632   @Override @Test
633   public void required_spec208_mustBePreparedToReceiveOnNextSignalsAfterHavingCalledSubscriptionCancel() throws Throwable {
634     subscriberVerification.required_spec208_mustBePreparedToReceiveOnNextSignalsAfterHavingCalledSubscriptionCancel();
635   }
636 
637   @Override @Test
638   public void required_spec209_mustBePreparedToReceiveAnOnCompleteSignalWithPrecedingRequestCall() throws Throwable {
639     subscriberVerification.required_spec209_mustBePreparedToReceiveAnOnCompleteSignalWithPrecedingRequestCall();
640   }
641 
642   @Override @Test
643   public void required_spec209_mustBePreparedToReceiveAnOnCompleteSignalWithoutPrecedingRequestCall() throws Throwable {
644     subscriberVerification.required_spec209_mustBePreparedToReceiveAnOnCompleteSignalWithoutPrecedingRequestCall();
645   }
646 
647   @Override @Test
648   public void required_spec210_mustBePreparedToReceiveAnOnErrorSignalWithPrecedingRequestCall() throws Throwable {
649     subscriberVerification.required_spec210_mustBePreparedToReceiveAnOnErrorSignalWithPrecedingRequestCall();
650   }
651 
652   @Override @Test
653   public void required_spec210_mustBePreparedToReceiveAnOnErrorSignalWithoutPrecedingRequestCall() throws Throwable {
654     subscriberVerification.required_spec210_mustBePreparedToReceiveAnOnErrorSignalWithoutPrecedingRequestCall();
655   }
656 
657   @Override @Test
658   public void untested_spec211_mustMakeSureThatAllCallsOnItsMethodsHappenBeforeTheProcessingOfTheRespectiveEvents() throws Exception {
659     subscriberVerification.untested_spec211_mustMakeSureThatAllCallsOnItsMethodsHappenBeforeTheProcessingOfTheRespectiveEvents();
660   }
661 
662   @Override @Test
663   public void untested_spec212_mustNotCallOnSubscribeMoreThanOnceBasedOnObjectEquality_specViolation() throws Throwable {
664     subscriberVerification.untested_spec212_mustNotCallOnSubscribeMoreThanOnceBasedOnObjectEquality_specViolation();
665   }
666 
667   @Override @Test
668   public void untested_spec213_failingOnSignalInvocation() throws Exception {
669     subscriberVerification.untested_spec213_failingOnSignalInvocation();
670   }
671 
672   @Override @Test
673   public void required_spec213_onSubscribe_mustThrowNullPointerExceptionWhenParametersAreNull() throws Throwable {
674     subscriberVerification.required_spec213_onSubscribe_mustThrowNullPointerExceptionWhenParametersAreNull();
675   }
676   @Override @Test
677   public void required_spec213_onNext_mustThrowNullPointerExceptionWhenParametersAreNull() throws Throwable {
678     subscriberVerification.required_spec213_onNext_mustThrowNullPointerExceptionWhenParametersAreNull();
679   }
680   @Override @Test
681   public void required_spec213_onError_mustThrowNullPointerExceptionWhenParametersAreNull() throws Throwable {
682     subscriberVerification.required_spec213_onError_mustThrowNullPointerExceptionWhenParametersAreNull();
683   }
684 
685   @Override @Test
686   public void untested_spec301_mustNotBeCalledOutsideSubscriberContext() throws Exception {
687     subscriberVerification.untested_spec301_mustNotBeCalledOutsideSubscriberContext();
688   }
689 
690   @Override @Test
691   public void required_spec308_requestMustRegisterGivenNumberElementsToBeProduced() throws Throwable {
692     subscriberVerification.required_spec308_requestMustRegisterGivenNumberElementsToBeProduced();
693   }
694 
695   @Override @Test
696   public void untested_spec310_requestMaySynchronouslyCallOnNextOnSubscriber() throws Exception {
697     subscriberVerification.untested_spec310_requestMaySynchronouslyCallOnNextOnSubscriber();
698   }
699 
700   @Override @Test
701   public void untested_spec311_requestMaySynchronouslyCallOnCompleteOrOnError() throws Exception {
702     subscriberVerification.untested_spec311_requestMaySynchronouslyCallOnCompleteOrOnError();
703   }
704 
705   @Override @Test
706   public void untested_spec314_cancelMayCauseThePublisherToShutdownIfNoOtherSubscriptionExists() throws Exception {
707     subscriberVerification.untested_spec314_cancelMayCauseThePublisherToShutdownIfNoOtherSubscriptionExists();
708   }
709 
710   @Override @Test
711   public void untested_spec315_cancelMustNotThrowExceptionAndMustSignalOnError() throws Exception {
712     subscriberVerification.untested_spec315_cancelMustNotThrowExceptionAndMustSignalOnError();
713   }
714 
715   @Override @Test
716   public void untested_spec316_requestMustNotThrowExceptionAndMustOnErrorTheSubscriber() throws Exception {
717     subscriberVerification.untested_spec316_requestMustNotThrowExceptionAndMustOnErrorTheSubscriber();
718   }
719 
720   /////////////////////// ADDITIONAL &quot;COROLLARY&quot; TESTS //////////////////////
721 
722   /**
723    * Asks for a {@code Processor} that supports at least 2 {@code Subscriber}s at once and checks requests
724    * from {@code Subscriber}s will eventually lead to requests towards the upstream of the {@code Processor}.
725    * &lt;p&gt;
726    * If the {@code Processor} requests and/or emits items only when all of its {@code Subscriber}s have requested,
727    * override {@link #doesCoordinatedEmission()} and return {@code true} to indicate this property.
728    * &lt;p&gt;
729    * &lt;b&gt;Verifies rule:&lt;/b&gt; &lt;a href=&#39;https://github.com/reactive-streams/reactive-streams-jvm#1.4&#39;&gt;2.1&lt;/a&gt; with multiple
730    * {@code Subscriber}s.
731    * &lt;p&gt;
732    * The test is not executed if {@link IdentityProcessorVerification#maxSupportedSubscribers()} is less than 2.
733    * &lt;p&gt;
734    * If this test fails, the following could be checked within the {@code Processor} implementation:
735    * &lt;ul&gt;
736    * &lt;li&gt;The {@code TestEnvironment} has large enough timeout specified in case the {@code Processor} has some time-delay behavior.&lt;/li&gt;
737    * &lt;li&gt;The {@code Processor} is able to fulfill requests of its {@code Subscriber}s independently of each other&#39;s requests or
738    * else override {@link #doesCoordinatedEmission()} and return {@code true} to indicate the test {@code Subscriber}s
739    * both have to request first.&lt;/li&gt;
740    * &lt;/ul&gt;
741    */
742   @Test
743   public void required_mustRequestFromUpstreamForElementsThatHaveBeenRequestedLongAgo() throws Throwable {
744     optionalMultipleSubscribersTest(2, new Function&lt;Long,TestSetup&gt;() {
745       @Override
746       public TestSetup apply(Long subscribers) throws Throwable {
747         return new TestSetup(env, processorBufferSize) {{
748           ManualSubscriber&lt;T&gt; sub1 = newSubscriber();
749           sub1.request(20);
750 
751           long totalRequests = expectRequest();
752           final T x = sendNextTFromUpstream();
753           expectNextElement(sub1, x);
754 
755           if (totalRequests == 1) {
756             totalRequests += expectRequest();
757           }
758           final T y = sendNextTFromUpstream();
759           expectNextElement(sub1, y);
760 
761           if (totalRequests == 2) {
762             totalRequests += expectRequest();
763           }
764 
765           final ManualSubscriber&lt;T&gt; sub2 = newSubscriber();
766 
767           // sub1 now has 18 pending
768           // sub2 has 0 pending
769 
770           if (doesCoordinatedEmission()) {
771             sub2.expectNone(); // since sub2 hasn&#39;t requested anything yet
772 
773             sub2.request(1);
774 
775             final T z = sendNextTFromUpstream();
776             expectNextElement(sub1, z);
777             expectNextElement(sub2, z);
778           } else {
779             final T z = sendNextTFromUpstream();
780             expectNextElement(sub1, z,
781                     &quot;If the Processor coordinates requests/emissions when having multiple Subscribers&quot;
782                             + &quot; at once, please override doesCoordinatedEmission() to return true in this &quot;
783                             + &quot;IdentityProcessorVerification to allow this test to pass.&quot;);
784             sub2.expectNone(); // since sub2 hasn&#39;t requested anything yet
785 
786             sub2.request(1);
787             expectNextElement(sub2, z);
788           }
789           if (totalRequests == 3) {
790             expectRequest();
791           }
792 
793           // to avoid error messages during test harness shutdown
794           sendCompletion();
795           sub1.expectCompletion(env.defaultTimeoutMillis());
796           sub2.expectCompletion(env.defaultTimeoutMillis());
797 
798           env.verifyNoAsyncErrorsNoDelay();
799         }};
800       }
801     });
802   }
803 
804   /////////////////////// TEST INFRASTRUCTURE //////////////////////
805 
806   public void notVerified() {
807     publisherVerification.notVerified();
808   }
809 
810   public void notVerified(String message) {
811     publisherVerification.notVerified(message);
812   }
813 
814   /**
815    * Test for feature that REQUIRES multiple subscribers to be supported by Publisher.
816    */
817   public void optionalMultipleSubscribersTest(long requiredSubscribersSupport, Function&lt;Long, TestSetup&gt; body) throws Throwable {
818     if (requiredSubscribersSupport &gt; maxSupportedSubscribers())
819       notVerified(String.format(&quot;The Publisher under test only supports %d subscribers, while this test requires at least %d to run.&quot;,
820                                 maxSupportedSubscribers(), requiredSubscribersSupport));
821     else body.apply(requiredSubscribersSupport);
822   }
823 
824   public abstract class TestSetup extends ManualPublisher&lt;T&gt; {
825     final private ManualSubscriber&lt;T&gt; tees; // gives us access to an infinite stream of T values
826     private Set&lt;T&gt; seenTees = new HashSet&lt;T&gt;();
827 
828     final Processor&lt;T, T&gt; processor;
829 
830     public TestSetup(TestEnvironment env, int testBufferSize) throws InterruptedException {
831       super(env);
832       tees = env.newManualSubscriber(createHelperPublisher(Long.MAX_VALUE));
833       processor = createIdentityProcessor(testBufferSize);
834       subscribe(processor);
835     }
836 
837     public ManualSubscriber&lt;T&gt; newSubscriber() throws InterruptedException {
838       return env.newManualSubscriber(processor);
839     }
840 
841     public T nextT() throws InterruptedException {
842       final T t = tees.requestNextElement();
843       if (seenTees.contains(t)) {
844         env.flop(String.format(&quot;Helper publisher illegally produced the same element %s twice&quot;, t));
845       }
846       seenTees.add(t);
847       return t;
848     }
849 
850     public void expectNextElement(ManualSubscriber&lt;T&gt; sub, T expected) throws InterruptedException {
851       final T elem = sub.nextElement(String.format(&quot;timeout while awaiting %s&quot;, expected));
852       if (!elem.equals(expected)) {
853         env.flop(String.format(&quot;Received `onNext(%s)` on downstream but expected `onNext(%s)`&quot;, elem, expected));
854       }
855     }
856 
857     public void expectNextElement(ManualSubscriber&lt;T&gt; sub, T expected, String errorMessageAddendum) throws InterruptedException {
858       final T elem = sub.nextElement(String.format(&quot;timeout while awaiting %s. %s&quot;, expected, errorMessageAddendum));
859       if (!elem.equals(expected)) {
860         env.flop(String.format(&quot;Received `onNext(%s)` on downstream but expected `onNext(%s)`&quot;, elem, expected));
861       }
862     }
863 
864     public T sendNextTFromUpstream() throws InterruptedException {
865       final T x = nextT();
866       sendNext(x);
867       return x;
868     }
869   }
870 
871   public class ManualSubscriberWithErrorCollection&lt;A&gt; extends ManualSubscriberWithSubscriptionSupport&lt;A&gt; {
872     Promise&lt;Throwable&gt; error;
873 
874     public ManualSubscriberWithErrorCollection(TestEnvironment env) {
875       super(env);
876       error = new Promise&lt;Throwable&gt;(env);
877     }
878 
879     @Override
880     public void onError(Throwable cause) {
881       error.complete(cause);
882     }
883 
884     public void expectError(Throwable cause) throws InterruptedException {
885       expectError(cause, env.defaultTimeoutMillis());
886     }
887 
888     @SuppressWarnings(&quot;ThrowableResultOfMethodCallIgnored&quot;)
889     public void expectError(Throwable cause, long timeoutMillis) throws InterruptedException {
890       error.expectCompletion(timeoutMillis, &quot;Did not receive expected error on downstream&quot;);
891       if (!cause.equals(error.value())) {
892         env.flop(String.format(&quot;Expected error %s but got %s&quot;, cause, error.value()));
893       }
894     }
895   }
896 }
    </pre>
  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New test/jdk/java/net/httpclient/websocket/WebSocketTest.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2018, 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 /*
 25  * @test
 26  * @bug 8217429
 27  * @build DummyWebSocketServer
 28  * @run testng/othervm
 29  *       WebSocketTest
 30  */
 31 
 32 import org.testng.annotations.DataProvider;
 33 import org.testng.annotations.Test;
 34 
 35 import java.io.IOException;
 36 import java.net.Authenticator;
 37 import java.net.PasswordAuthentication;
 38 import java.net.http.HttpResponse;
 39 import java.net.http.WebSocket;
 40 import java.net.http.WebSocketHandshakeException;
 41 import java.nio.ByteBuffer;
 42 import java.nio.charset.StandardCharsets;
 43 import java.util.ArrayList;
 44 import java.util.Base64;
 45 import java.util.List;
 46 import java.util.concurrent.CompletableFuture;
 47 import java.util.concurrent.CompletionException;
 48 import java.util.concurrent.CompletionStage;
 49 import java.util.concurrent.TimeUnit;
 50 import java.util.concurrent.atomic.AtomicBoolean;
 51 import java.util.function.Function;
 52 import java.util.function.Supplier;
 53 import java.util.stream.Collectors;
 54 
 55 import static java.net.http.HttpClient.Builder.NO_PROXY;
 56 import static java.net.http.HttpClient.newBuilder;
 57 import static java.net.http.WebSocket.NORMAL_CLOSURE;
 58 import static java.nio.charset.StandardCharsets.UTF_8;
 59 import static org.testng.Assert.assertEquals;
 60 import static org.testng.Assert.assertThrows;
 61 import static org.testng.Assert.fail;
 62 
 63 public class WebSocketTest {
 64 
 65     private static final Class&lt;IllegalArgumentException&gt; IAE = IllegalArgumentException.class;
 66     private static final Class&lt;IllegalStateException&gt; ISE = IllegalStateException.class;
 67     private static final Class&lt;IOException&gt; IOE = IOException.class;
 68 
 69     /* shortcut */
 70     private static void assertFails(Class&lt;? extends Throwable&gt; clazz,
 71                                     CompletionStage&lt;?&gt; stage) {
 72         Support.assertCompletesExceptionally(clazz, stage);
 73     }
 74 
 75     @Test
 76     public void illegalArgument() throws IOException {
 77         try (var server = new DummyWebSocketServer()) {
 78             server.open();
 79             var webSocket = newBuilder().proxy(NO_PROXY).build()
 80                     .newWebSocketBuilder()
 81                     .buildAsync(server.getURI(), new WebSocket.Listener() { })
 82                     .join();
 83             try {
 84                 assertFails(IAE, webSocket.sendPing(ByteBuffer.allocate(126)));
 85                 assertFails(IAE, webSocket.sendPing(ByteBuffer.allocate(127)));
 86                 assertFails(IAE, webSocket.sendPing(ByteBuffer.allocate(128)));
 87                 assertFails(IAE, webSocket.sendPing(ByteBuffer.allocate(129)));
 88                 assertFails(IAE, webSocket.sendPing(ByteBuffer.allocate(256)));
 89 
 90                 assertFails(IAE, webSocket.sendPong(ByteBuffer.allocate(126)));
 91                 assertFails(IAE, webSocket.sendPong(ByteBuffer.allocate(127)));
 92                 assertFails(IAE, webSocket.sendPong(ByteBuffer.allocate(128)));
 93                 assertFails(IAE, webSocket.sendPong(ByteBuffer.allocate(129)));
 94                 assertFails(IAE, webSocket.sendPong(ByteBuffer.allocate(256)));
 95 
 96                 assertFails(IOE, webSocket.sendText(Support.incompleteString(), true));
 97                 assertFails(IOE, webSocket.sendText(Support.incompleteString(), false));
 98                 assertFails(IOE, webSocket.sendText(Support.malformedString(), true));
 99                 assertFails(IOE, webSocket.sendText(Support.malformedString(), false));
100 
101                 assertFails(IAE, webSocket.sendClose(NORMAL_CLOSURE, Support.stringWithNBytes(124)));
102                 assertFails(IAE, webSocket.sendClose(NORMAL_CLOSURE, Support.stringWithNBytes(125)));
103                 assertFails(IAE, webSocket.sendClose(NORMAL_CLOSURE, Support.stringWithNBytes(128)));
104                 assertFails(IAE, webSocket.sendClose(NORMAL_CLOSURE, Support.stringWithNBytes(256)));
105                 assertFails(IAE, webSocket.sendClose(NORMAL_CLOSURE, Support.stringWithNBytes(257)));
106                 assertFails(IAE, webSocket.sendClose(NORMAL_CLOSURE, Support.stringWith2NBytes((123 / 2) + 1)));
107                 assertFails(IAE, webSocket.sendClose(NORMAL_CLOSURE, Support.malformedString()));
108                 assertFails(IAE, webSocket.sendClose(NORMAL_CLOSURE, Support.incompleteString()));
109 
110                 assertFails(IAE, webSocket.sendClose(-2, &quot;a reason&quot;));
111                 assertFails(IAE, webSocket.sendClose(-1, &quot;a reason&quot;));
112                 assertFails(IAE, webSocket.sendClose(0, &quot;a reason&quot;));
113                 assertFails(IAE, webSocket.sendClose(1, &quot;a reason&quot;));
114                 assertFails(IAE, webSocket.sendClose(500, &quot;a reason&quot;));
115                 assertFails(IAE, webSocket.sendClose(998, &quot;a reason&quot;));
116                 assertFails(IAE, webSocket.sendClose(999, &quot;a reason&quot;));
117                 assertFails(IAE, webSocket.sendClose(1002, &quot;a reason&quot;));
118                 assertFails(IAE, webSocket.sendClose(1003, &quot;a reason&quot;));
119                 assertFails(IAE, webSocket.sendClose(1006, &quot;a reason&quot;));
120                 assertFails(IAE, webSocket.sendClose(1007, &quot;a reason&quot;));
121                 assertFails(IAE, webSocket.sendClose(1009, &quot;a reason&quot;));
122                 assertFails(IAE, webSocket.sendClose(1010, &quot;a reason&quot;));
123                 assertFails(IAE, webSocket.sendClose(1012, &quot;a reason&quot;));
124                 assertFails(IAE, webSocket.sendClose(1013, &quot;a reason&quot;));
125                 assertFails(IAE, webSocket.sendClose(1015, &quot;a reason&quot;));
126                 assertFails(IAE, webSocket.sendClose(5000, &quot;a reason&quot;));
127                 assertFails(IAE, webSocket.sendClose(32768, &quot;a reason&quot;));
128                 assertFails(IAE, webSocket.sendClose(65535, &quot;a reason&quot;));
129                 assertFails(IAE, webSocket.sendClose(65536, &quot;a reason&quot;));
130                 assertFails(IAE, webSocket.sendClose(Integer.MAX_VALUE, &quot;a reason&quot;));
131                 assertFails(IAE, webSocket.sendClose(Integer.MIN_VALUE, &quot;a reason&quot;));
132 
133                 assertThrows(IAE, () -&gt; webSocket.request(Integer.MIN_VALUE));
134                 assertThrows(IAE, () -&gt; webSocket.request(Long.MIN_VALUE));
135                 assertThrows(IAE, () -&gt; webSocket.request(-1));
136                 assertThrows(IAE, () -&gt; webSocket.request(0));
137 
138             } finally {
139                 webSocket.abort();
140             }
141         }
142     }
143 
144     @Test
145     public void partialBinaryThenText() throws IOException {
146         try (var server = new DummyWebSocketServer()) {
147             server.open();
148             var webSocket = newBuilder().proxy(NO_PROXY).build().newWebSocketBuilder()
149                     .buildAsync(server.getURI(), new WebSocket.Listener() { })
150                     .join();
151             try {
152                 webSocket.sendBinary(ByteBuffer.allocate(16), false).join();
153                 assertFails(ISE, webSocket.sendText(&quot;text&quot;, false));
154                 assertFails(ISE, webSocket.sendText(&quot;text&quot;, true));
155                 // Pings &amp; Pongs are fine
156                 webSocket.sendPing(ByteBuffer.allocate(125)).join();
157                 webSocket.sendPong(ByteBuffer.allocate(125)).join();
158             } finally {
159                 webSocket.abort();
160             }
161         }
162     }
163 
164     @Test
165     public void partialTextThenBinary() throws IOException {
166         try (var server = new DummyWebSocketServer()) {
167             server.open();
168             var webSocket = newBuilder().proxy(NO_PROXY).build().newWebSocketBuilder()
169                     .buildAsync(server.getURI(), new WebSocket.Listener() { })
170                     .join();
171             try {
172                 webSocket.sendText(&quot;text&quot;, false).join();
173                 assertFails(ISE, webSocket.sendBinary(ByteBuffer.allocate(16), false));
174                 assertFails(ISE, webSocket.sendBinary(ByteBuffer.allocate(16), true));
175                 // Pings &amp; Pongs are fine
176                 webSocket.sendPing(ByteBuffer.allocate(125)).join();
177                 webSocket.sendPong(ByteBuffer.allocate(125)).join();
178             } finally {
179                 webSocket.abort();
180             }
181         }
182     }
183 
184     @Test
185     public void sendMethodsThrowIOE1() throws IOException {
186         try (var server = new DummyWebSocketServer()) {
187             server.open();
188             var webSocket = newBuilder().proxy(NO_PROXY).build()
189                     .newWebSocketBuilder()
190                     .buildAsync(server.getURI(), new WebSocket.Listener() { })
191                     .join();
192             try {
193                 webSocket.sendClose(NORMAL_CLOSURE, &quot;ok&quot;).join();
194 
195                 assertFails(IOE, webSocket.sendClose(WebSocket.NORMAL_CLOSURE, &quot;ok&quot;));
196 
197                 assertFails(IOE, webSocket.sendText(&quot;&quot;, true));
198                 assertFails(IOE, webSocket.sendText(&quot;&quot;, false));
199                 assertFails(IOE, webSocket.sendText(&quot;abc&quot;, true));
200                 assertFails(IOE, webSocket.sendText(&quot;abc&quot;, false));
201                 assertFails(IOE, webSocket.sendBinary(ByteBuffer.allocate(0), true));
202                 assertFails(IOE, webSocket.sendBinary(ByteBuffer.allocate(0), false));
203                 assertFails(IOE, webSocket.sendBinary(ByteBuffer.allocate(1), true));
204                 assertFails(IOE, webSocket.sendBinary(ByteBuffer.allocate(1), false));
205 
206                 assertFails(IOE, webSocket.sendPing(ByteBuffer.allocate(125)));
207                 assertFails(IOE, webSocket.sendPing(ByteBuffer.allocate(124)));
208                 assertFails(IOE, webSocket.sendPing(ByteBuffer.allocate(1)));
209                 assertFails(IOE, webSocket.sendPing(ByteBuffer.allocate(0)));
210 
211                 assertFails(IOE, webSocket.sendPong(ByteBuffer.allocate(125)));
212                 assertFails(IOE, webSocket.sendPong(ByteBuffer.allocate(124)));
213                 assertFails(IOE, webSocket.sendPong(ByteBuffer.allocate(1)));
214                 assertFails(IOE, webSocket.sendPong(ByteBuffer.allocate(0)));
215             } finally {
216                 webSocket.abort();
217             }
218         }
219     }
220 
221     @DataProvider(name = &quot;sequence&quot;)
222     public Object[][] data1() {
223         int[] CLOSE = {
224                 0x81, 0x00, // &quot;&quot;
225                 0x82, 0x00, // []
226                 0x89, 0x00, // &lt;PING&gt;
227                 0x8a, 0x00, // &lt;PONG&gt;
228                 0x88, 0x00, // &lt;CLOSE&gt;
229         };
230         int[] ERROR = {
231                 0x81, 0x00, // &quot;&quot;
232                 0x82, 0x00, // []
233                 0x89, 0x00, // &lt;PING&gt;
234                 0x8a, 0x00, // &lt;PONG&gt;
235                 0x8b, 0x00, // 0xB control frame (causes an error)
236         };
237         return new Object[][]{
238                 {CLOSE, 1},
239                 {CLOSE, 3},
240                 {CLOSE, 4},
241                 {CLOSE, Long.MAX_VALUE},
242                 {ERROR, 1},
243                 {ERROR, 3},
244                 {ERROR, 4},
245                 {ERROR, Long.MAX_VALUE},
246         };
247     }
248 
249     @Test(dataProvider = &quot;sequence&quot;)
250     public void listenerSequentialOrder(int[] binary, long requestSize)
251             throws IOException
252     {
253         try (var server = Support.serverWithCannedData(binary)) {
254             server.open();
255 
256             CompletableFuture&lt;Void&gt; violation = new CompletableFuture&lt;&gt;();
257 
258             MockListener listener = new MockListener(requestSize) {
259 
260                 final AtomicBoolean guard = new AtomicBoolean();
261 
262                 private &lt;T&gt; T checkRunExclusively(Supplier&lt;T&gt; action) {
263                     if (guard.getAndSet(true)) {
264                         violation.completeExceptionally(new RuntimeException());
265                     }
266                     try {
267                         return action.get();
268                     } finally {
269                         if (!guard.getAndSet(false)) {
270                             violation.completeExceptionally(new RuntimeException());
271                         }
272                     }
273                 }
274 
275                 @Override
276                 public void onOpen(WebSocket webSocket) {
277                     checkRunExclusively(() -&gt; {
278                         super.onOpen(webSocket);
279                         return null;
280                     });
281                 }
282 
283                 @Override
284                 public CompletionStage&lt;?&gt; onText(WebSocket webSocket,
285                                                  CharSequence data,
286                                                  boolean last) {
287                     return checkRunExclusively(
288                             () -&gt; super.onText(webSocket, data, last));
289                 }
290 
291                 @Override
292                 public CompletionStage&lt;?&gt; onBinary(WebSocket webSocket,
293                                                    ByteBuffer data,
294                                                    boolean last) {
295                     return checkRunExclusively(
296                             () -&gt; super.onBinary(webSocket, data, last));
297                 }
298 
299                 @Override
300                 public CompletionStage&lt;?&gt; onPing(WebSocket webSocket,
301                                                  ByteBuffer message) {
302                     return checkRunExclusively(
303                             () -&gt; super.onPing(webSocket, message));
304                 }
305 
306                 @Override
307                 public CompletionStage&lt;?&gt; onPong(WebSocket webSocket,
308                                                  ByteBuffer message) {
309                     return checkRunExclusively(
310                             () -&gt; super.onPong(webSocket, message));
311                 }
312 
313                 @Override
314                 public CompletionStage&lt;?&gt; onClose(WebSocket webSocket,
315                                                   int statusCode,
316                                                   String reason) {
317                     return checkRunExclusively(
318                             () -&gt; super.onClose(webSocket, statusCode, reason));
319                 }
320 
321                 @Override
322                 public void onError(WebSocket webSocket, Throwable error) {
323                     checkRunExclusively(() -&gt; {
324                         super.onError(webSocket, error);
325                         return null;
326                     });
327                 }
328             };
329 
330             var webSocket = newBuilder().proxy(NO_PROXY).build().newWebSocketBuilder()
331                     .buildAsync(server.getURI(), listener)
332                     .join();
333             try {
334                 listener.invocations();
335                 violation.complete(null); // won&#39;t affect if completed exceptionally
336                 violation.join();
337             } finally {
338                 webSocket.abort();
339             }
340         }
341     }
342 
343     @Test
344     public void sendMethodsThrowIOE2() throws Exception {
345         try (var server = Support.serverWithCannedData(0x88, 0x00)) {
346             server.open();
347 
348             CompletableFuture&lt;Void&gt; onCloseCalled = new CompletableFuture&lt;&gt;();
349             CompletableFuture&lt;Void&gt; canClose = new CompletableFuture&lt;&gt;();
350 
351             WebSocket.Listener listener = new WebSocket.Listener() {
352                 @Override
353                 public CompletionStage&lt;?&gt; onClose(WebSocket webSocket,
354                                                   int statusCode,
355                                                   String reason) {
356                     System.out.printf(&quot;onClose(%s, &#39;%s&#39;)%n&quot;, statusCode, reason);
357                     onCloseCalled.complete(null);
358                     return canClose;
359                 }
360 
361                 @Override
362                 public void onError(WebSocket webSocket, Throwable error) {
363                     System.out.println(&quot;onError(&quot; + error + &quot;)&quot;);
364                     onCloseCalled.completeExceptionally(error);
365                 }
366             };
367 
368             var webSocket = newBuilder().proxy(NO_PROXY).build().newWebSocketBuilder()
369                     .buildAsync(server.getURI(), listener)
370                     .join();
371             try {
372                 onCloseCalled.join();      // Wait for onClose to be called
373                 canClose.complete(null);   // Signal to the WebSocket it can close the output
374                 TimeUnit.SECONDS.sleep(5); // Give canClose some time to reach the WebSocket
375 
376                 assertFails(IOE, webSocket.sendClose(WebSocket.NORMAL_CLOSURE, &quot;ok&quot;));
377 
378                 assertFails(IOE, webSocket.sendText(&quot;&quot;, true));
379                 assertFails(IOE, webSocket.sendText(&quot;&quot;, false));
380                 assertFails(IOE, webSocket.sendText(&quot;abc&quot;, true));
381                 assertFails(IOE, webSocket.sendText(&quot;abc&quot;, false));
382                 assertFails(IOE, webSocket.sendBinary(ByteBuffer.allocate(0), true));
383                 assertFails(IOE, webSocket.sendBinary(ByteBuffer.allocate(0), false));
384                 assertFails(IOE, webSocket.sendBinary(ByteBuffer.allocate(1), true));
385                 assertFails(IOE, webSocket.sendBinary(ByteBuffer.allocate(1), false));
386 
387                 assertFails(IOE, webSocket.sendPing(ByteBuffer.allocate(125)));
388                 assertFails(IOE, webSocket.sendPing(ByteBuffer.allocate(124)));
389                 assertFails(IOE, webSocket.sendPing(ByteBuffer.allocate(1)));
390                 assertFails(IOE, webSocket.sendPing(ByteBuffer.allocate(0)));
391 
392                 assertFails(IOE, webSocket.sendPong(ByteBuffer.allocate(125)));
393                 assertFails(IOE, webSocket.sendPong(ByteBuffer.allocate(124)));
394                 assertFails(IOE, webSocket.sendPong(ByteBuffer.allocate(1)));
395                 assertFails(IOE, webSocket.sendPong(ByteBuffer.allocate(0)));
396             } finally {
397                 webSocket.abort();
398             }
399         }
400     }
401 
402     // Used to verify a server requiring Authentication
403     private static final String USERNAME = &quot;chegar&quot;;
404     private static final String PASSWORD = &quot;a1b2c3&quot;;
405 
406     static class WSAuthenticator extends Authenticator {
407         @Override
408         protected PasswordAuthentication getPasswordAuthentication() {
409             return new PasswordAuthentication(USERNAME, PASSWORD.toCharArray());
410         }
411     }
412 
413     static final Function&lt;int[],DummyWebSocketServer&gt; SERVER_WITH_CANNED_DATA =
414         new Function&lt;&gt;() {
415             @Override public DummyWebSocketServer apply(int[] data) {
416                 return Support.serverWithCannedData(data); }
417             @Override public String toString() { return &quot;SERVER_WITH_CANNED_DATA&quot;; }
418         };
419 
420     static final Function&lt;int[],DummyWebSocketServer&gt; AUTH_SERVER_WITH_CANNED_DATA =
421         new Function&lt;&gt;() {
422             @Override public DummyWebSocketServer apply(int[] data) {
423                 return Support.serverWithCannedDataAndAuthentication(USERNAME, PASSWORD, data); }
424             @Override public String toString() { return &quot;AUTH_SERVER_WITH_CANNED_DATA&quot;; }
425         };
426 
427     @DataProvider(name = &quot;servers&quot;)
428     public Object[][] servers() {
429         return new Object[][] {
430             { SERVER_WITH_CANNED_DATA },
431             { AUTH_SERVER_WITH_CANNED_DATA },
432         };
433     }
434 
435     @Test(dataProvider = &quot;servers&quot;)
436     public void simpleAggregatingBinaryMessages
437             (Function&lt;int[],DummyWebSocketServer&gt; serverSupplier)
438         throws IOException
439     {
440         List&lt;byte[]&gt; expected = List.of(&quot;alpha&quot;, &quot;beta&quot;, &quot;gamma&quot;, &quot;delta&quot;)
441                 .stream()
442                 .map(s -&gt; s.getBytes(StandardCharsets.US_ASCII))
443                 .collect(Collectors.toList());
444         int[] binary = new int[]{
445                 0x82, 0x05, 0x61, 0x6c, 0x70, 0x68, 0x61, // [alpha]
446                 0x02, 0x02, 0x62, 0x65,                   // [be
447                 0x80, 0x02, 0x74, 0x61,                   // ta]
448                 0x02, 0x01, 0x67,                         // [g
449                 0x00, 0x01, 0x61,                         // a
450                 0x00, 0x00,                               //
451                 0x00, 0x00,                               //
452                 0x00, 0x01, 0x6d,                         // m
453                 0x00, 0x01, 0x6d,                         // m
454                 0x80, 0x01, 0x61,                         // a]
455                 0x8a, 0x00,                               // &lt;PONG&gt;
456                 0x02, 0x04, 0x64, 0x65, 0x6c, 0x74,       // [delt
457                 0x00, 0x01, 0x61,                         // a
458                 0x80, 0x00,                               // ]
459                 0x88, 0x00                                // &lt;CLOSE&gt;
460         };
461         CompletableFuture&lt;List&lt;byte[]&gt;&gt; actual = new CompletableFuture&lt;&gt;();
462 
463         try (var server = serverSupplier.apply(binary)) {
464             server.open();
465 
466             WebSocket.Listener listener = new WebSocket.Listener() {
467 
468                 List&lt;byte[]&gt; collectedBytes = new ArrayList&lt;&gt;();
469                 ByteBuffer buffer = ByteBuffer.allocate(1024);
470 
471                 @Override
472                 public CompletionStage&lt;?&gt; onBinary(WebSocket webSocket,
473                                                    ByteBuffer message,
474                                                    boolean last) {
475                     System.out.printf(&quot;onBinary(%s, %s)%n&quot;, message, last);
476                     webSocket.request(1);
477 
478                     append(message);
479                     if (last) {
480                         buffer.flip();
481                         byte[] bytes = new byte[buffer.remaining()];
482                         buffer.get(bytes);
483                         buffer.clear();
484                         processWholeBinary(bytes);
485                     }
486                     return null;
487                 }
488 
489                 private void append(ByteBuffer message) {
490                     if (buffer.remaining() &lt; message.remaining()) {
491                         assert message.remaining() &gt; 0;
492                         int cap = (buffer.capacity() + message.remaining()) * 2;
493                         ByteBuffer b = ByteBuffer.allocate(cap);
494                         b.put(buffer.flip());
495                         buffer = b;
496                     }
497                     buffer.put(message);
498                 }
499 
500                 private void processWholeBinary(byte[] bytes) {
501                     String stringBytes = new String(bytes, UTF_8);
502                     System.out.println(&quot;processWholeBinary: &quot; + stringBytes);
503                     collectedBytes.add(bytes);
504                 }
505 
506                 @Override
507                 public CompletionStage&lt;?&gt; onClose(WebSocket webSocket,
508                                                   int statusCode,
509                                                   String reason) {
510                     actual.complete(collectedBytes);
511                     return null;
512                 }
513 
514                 @Override
515                 public void onError(WebSocket webSocket, Throwable error) {
516                     actual.completeExceptionally(error);
517                 }
518             };
519 
520             var webSocket = newBuilder()
521                     .proxy(NO_PROXY)
522                     .authenticator(new WSAuthenticator())
523                     .build().newWebSocketBuilder()
524                     .buildAsync(server.getURI(), listener)
525                     .join();
526             try {
527                 List&lt;byte[]&gt; a = actual.join();
528                 assertEquals(a, expected);
529             } finally {
530                 webSocket.abort();
531             }
532         }
533     }
534 
535     @Test(dataProvider = &quot;servers&quot;)
536     public void simpleAggregatingTextMessages
537             (Function&lt;int[],DummyWebSocketServer&gt; serverSupplier)
538         throws IOException
539     {
540         List&lt;String&gt; expected = List.of(&quot;alpha&quot;, &quot;beta&quot;, &quot;gamma&quot;, &quot;delta&quot;);
541 
542         int[] binary = new int[]{
543                 0x81, 0x05, 0x61, 0x6c, 0x70, 0x68, 0x61, // &quot;alpha&quot;
544                 0x01, 0x02, 0x62, 0x65,                   // &quot;be
545                 0x80, 0x02, 0x74, 0x61,                   // ta&quot;
546                 0x01, 0x01, 0x67,                         // &quot;g
547                 0x00, 0x01, 0x61,                         // a
548                 0x00, 0x00,                               //
549                 0x00, 0x00,                               //
550                 0x00, 0x01, 0x6d,                         // m
551                 0x00, 0x01, 0x6d,                         // m
552                 0x80, 0x01, 0x61,                         // a&quot;
553                 0x8a, 0x00,                               // &lt;PONG&gt;
554                 0x01, 0x04, 0x64, 0x65, 0x6c, 0x74,       // &quot;delt
555                 0x00, 0x01, 0x61,                         // a
556                 0x80, 0x00,                               // &quot;
557                 0x88, 0x00                                // &lt;CLOSE&gt;
558         };
559         CompletableFuture&lt;List&lt;String&gt;&gt; actual = new CompletableFuture&lt;&gt;();
560 
561         try (var server = serverSupplier.apply(binary)) {
562             server.open();
563 
564             WebSocket.Listener listener = new WebSocket.Listener() {
565 
566                 List&lt;String&gt; collectedStrings = new ArrayList&lt;&gt;();
567                 StringBuilder text = new StringBuilder();
568 
569                 @Override
570                 public CompletionStage&lt;?&gt; onText(WebSocket webSocket,
571                                                  CharSequence message,
572                                                  boolean last) {
573                     System.out.printf(&quot;onText(%s, %s)%n&quot;, message, last);
574                     webSocket.request(1);
575                     text.append(message);
576                     if (last) {
577                         String str = text.toString();
578                         text.setLength(0);
579                         processWholeText(str);
580                     }
581                     return null;
582                 }
583 
584                 private void processWholeText(String string) {
585                     System.out.println(string);
586                     collectedStrings.add(string);
587                 }
588 
589                 @Override
590                 public CompletionStage&lt;?&gt; onClose(WebSocket webSocket,
591                                                   int statusCode,
592                                                   String reason) {
593                     actual.complete(collectedStrings);
594                     return null;
595                 }
596 
597                 @Override
598                 public void onError(WebSocket webSocket, Throwable error) {
599                     actual.completeExceptionally(error);
600                 }
601             };
602 
603             var webSocket = newBuilder()
604                     .proxy(NO_PROXY)
605                     .authenticator(new WSAuthenticator())
606                     .build().newWebSocketBuilder()
607                     .buildAsync(server.getURI(), listener)
608                     .join();
609             try {
610                 List&lt;String&gt; a = actual.join();
611                 assertEquals(a, expected);
612             } finally {
613                 webSocket.abort();
614             }
615         }
616     }
617 
618     /*
619      * Exercises the scenario where requests for more messages are made prior to
620      * completing the returned CompletionStage instances.
621      */
622     @Test(dataProvider = &quot;servers&quot;)
623     public void aggregatingTextMessages
624         (Function&lt;int[],DummyWebSocketServer&gt; serverSupplier)
625         throws IOException
626     {
627         List&lt;String&gt; expected = List.of(&quot;alpha&quot;, &quot;beta&quot;, &quot;gamma&quot;, &quot;delta&quot;);
628 
629         int[] binary = new int[]{
630                 0x81, 0x05, 0x61, 0x6c, 0x70, 0x68, 0x61, // &quot;alpha&quot;
631                 0x01, 0x02, 0x62, 0x65,                   // &quot;be
632                 0x80, 0x02, 0x74, 0x61,                   // ta&quot;
633                 0x01, 0x01, 0x67,                         // &quot;g
634                 0x00, 0x01, 0x61,                         // a
635                 0x00, 0x00,                               //
636                 0x00, 0x00,                               //
637                 0x00, 0x01, 0x6d,                         // m
638                 0x00, 0x01, 0x6d,                         // m
639                 0x80, 0x01, 0x61,                         // a&quot;
640                 0x8a, 0x00,                               // &lt;PONG&gt;
641                 0x01, 0x04, 0x64, 0x65, 0x6c, 0x74,       // &quot;delt
642                 0x00, 0x01, 0x61,                         // a
643                 0x80, 0x00,                               // &quot;
644                 0x88, 0x00                                // &lt;CLOSE&gt;
645         };
646         CompletableFuture&lt;List&lt;String&gt;&gt; actual = new CompletableFuture&lt;&gt;();
647 
648         try (var server = serverSupplier.apply(binary)) {
649             server.open();
650 
651             WebSocket.Listener listener = new WebSocket.Listener() {
652 
653                 List&lt;CharSequence&gt; parts = new ArrayList&lt;&gt;();
654                 /*
655                  * A CompletableFuture which will complete once the current
656                  * message has been fully assembled. Until then the listener
657                  * returns this instance for every call.
658                  */
659                 CompletableFuture&lt;?&gt; currentCf = new CompletableFuture&lt;&gt;();
660                 List&lt;String&gt; collected = new ArrayList&lt;&gt;();
661 
662                 @Override
663                 public CompletionStage&lt;?&gt; onText(WebSocket webSocket,
664                                                  CharSequence message,
665                                                  boolean last) {
666                     parts.add(message);
667                     if (!last) {
668                         webSocket.request(1);
669                     } else {
670                         this.currentCf.thenRun(() -&gt; webSocket.request(1));
671                         CompletableFuture&lt;?&gt; refCf = this.currentCf;
672                         processWholeMessage(new ArrayList&lt;&gt;(parts), refCf);
673                         currentCf = new CompletableFuture&lt;&gt;();
674                         parts.clear();
675                         return refCf;
676                     }
677                     return currentCf;
678                 }
679 
680                 @Override
681                 public CompletionStage&lt;?&gt; onClose(WebSocket webSocket,
682                                                   int statusCode,
683                                                   String reason) {
684                     actual.complete(collected);
685                     return null;
686                 }
687 
688                 @Override
689                 public void onError(WebSocket webSocket, Throwable error) {
690                     actual.completeExceptionally(error);
691                 }
692 
693                 public void processWholeMessage(List&lt;CharSequence&gt; data,
694                                                 CompletableFuture&lt;?&gt; cf) {
695                     StringBuilder b = new StringBuilder();
696                     data.forEach(b::append);
697                     String s = b.toString();
698                     System.out.println(s);
699                     cf.complete(null);
700                     collected.add(s);
701                 }
702             };
703 
704             var webSocket = newBuilder()
705                     .proxy(NO_PROXY)
706                     .authenticator(new WSAuthenticator())
707                     .build().newWebSocketBuilder()
708                     .buildAsync(server.getURI(), listener)
709                     .join();
710             try {
711                 List&lt;String&gt; a = actual.join();
712                 assertEquals(a, expected);
713             } finally {
714                 webSocket.abort();
715             }
716         }
717     }
718 
719     // -- authentication specific tests
720 
721     /*
722      * Ensures authentication succeeds when an Authenticator set on client builder.
723      */
724     @Test
725     public void clientAuthenticate() throws IOException  {
726         try (var server = new DummyWebSocketServer(USERNAME, PASSWORD)){
727             server.open();
728 
729             var webSocket = newBuilder()
730                     .proxy(NO_PROXY)
731                     .authenticator(new WSAuthenticator())
732                     .build()
733                     .newWebSocketBuilder()
734                     .buildAsync(server.getURI(), new WebSocket.Listener() { })
735                     .join();
736             webSocket.abort();
737         }
738     }
739 
740     /*
741      * Ensures authentication succeeds when an `Authorization` header is explicitly set.
742      */
743     @Test
744     public void explicitAuthenticate() throws IOException  {
745         try (var server = new DummyWebSocketServer(USERNAME, PASSWORD)) {
746             server.open();
747 
748             String hv = &quot;Basic &quot; + Base64.getEncoder().encodeToString(
749                     (USERNAME + &quot;:&quot; + PASSWORD).getBytes(UTF_8));
750 
751             var webSocket = newBuilder()
752                     .proxy(NO_PROXY).build()
753                     .newWebSocketBuilder()
754                     .header(&quot;Authorization&quot;, hv)
755                     .buildAsync(server.getURI(), new WebSocket.Listener() { })
756                     .join();
757             webSocket.abort();
758         }
759     }
760 
761     /*
762      * Ensures authentication does not succeed when no authenticator is present.
763      */
764     @Test
765     public void failNoAuthenticator() throws IOException  {
766         try (var server = new DummyWebSocketServer(USERNAME, PASSWORD)) {
767             server.open();
768 
769             CompletableFuture&lt;WebSocket&gt; cf = newBuilder()
770                     .proxy(NO_PROXY).build()
771                     .newWebSocketBuilder()
772                     .buildAsync(server.getURI(), new WebSocket.Listener() { });
773 
774             try {
775                 var webSocket = cf.join();
776                 silentAbort(webSocket);
777                 fail(&quot;Expected exception not thrown&quot;);
778             } catch (CompletionException expected) {
779                 WebSocketHandshakeException e = (WebSocketHandshakeException)expected.getCause();
780                 HttpResponse&lt;?&gt; response = e.getResponse();
781                 assertEquals(response.statusCode(), 401);
782             }
783         }
784     }
785 
786     /*
787      * Ensures authentication does not succeed when the authenticator presents
788      * unauthorized credentials.
789      */
790     @Test
791     public void failBadCredentials() throws IOException  {
792         try (var server = new DummyWebSocketServer(USERNAME, PASSWORD)) {
793             server.open();
794 
795             Authenticator authenticator = new Authenticator() {
796                 @Override protected PasswordAuthentication getPasswordAuthentication() {
797                     return new PasswordAuthentication(&quot;BAD&quot; + USERNAME, &quot;&quot;.toCharArray());
798                 }
799             };
800 
801             CompletableFuture&lt;WebSocket&gt; cf = newBuilder()
802                     .proxy(NO_PROXY)
803                     .authenticator(authenticator)
804                     .build()
805                     .newWebSocketBuilder()
806                     .buildAsync(server.getURI(), new WebSocket.Listener() { });
807 
808             try {
809                 var webSocket = cf.join();
810                 silentAbort(webSocket);
811                 fail(&quot;Expected exception not thrown&quot;);
812             } catch (CompletionException expected) {
813                 System.out.println(&quot;caught expected exception:&quot; + expected);
814             }
815         }
816     }
817     private static void silentAbort(WebSocket ws) {
818         try {
819             ws.abort();
820         } catch (Throwable t) { }
821     }
822 }
    </pre>
  </body>
</html>
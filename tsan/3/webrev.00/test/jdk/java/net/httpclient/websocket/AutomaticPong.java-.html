<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old test/jdk/java/net/httpclient/websocket/AutomaticPong.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2018, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 /*
 25  * @test
 26  * @build DummyWebSocketServer
 27  * @run testng/othervm
 28  *      -Djdk.internal.httpclient.websocket.debug=true
 29  *       AutomaticPong
 30  */
 31 
 32 import org.testng.annotations.AfterTest;
 33 import org.testng.annotations.DataProvider;
 34 import org.testng.annotations.Test;
 35 
 36 import java.io.IOException;
 37 import java.net.http.WebSocket;
 38 import java.nio.ByteBuffer;
 39 import java.nio.charset.StandardCharsets;
 40 import java.util.List;
 41 
 42 import static java.net.http.HttpClient.newHttpClient;
 43 import static org.testng.Assert.assertEquals;
 44 import static org.testng.Assert.assertFalse;
 45 import static org.testng.Assert.assertTrue;
 46 import static org.testng.Assert.fail;
 47 
 48 public class AutomaticPong {
 49 
 50     private DummyWebSocketServer server;
 51     private WebSocket webSocket;
 52 
 53     @AfterTest
 54     public void cleanup() {
 55         server.close();
 56         webSocket.abort();
 57     }
 58 
 59     /*
 60      * The sendClose method has been invoked and a Ping comes from the server.
 61      * Naturally, the client cannot reply with a Pong (the output has been
 62      * closed). However, this MUST not be treated as an error.
 63      * At this stage the server either has received or pretty soon will receive
 64      * the Close message sent by the sendClose. Thus, the server will know the
 65      * client cannot send further messages and it&#39;s up to the server to decide
 66      * how to react on the corresponding Pong not being received.
 67      */
 68     @Test
 69     public void sendCloseThenAutomaticPong() throws IOException {
 70         int[] bytes = {
 71                 0x89, 0x00,                                     // ping
 72                 0x89, 0x06, 0x68, 0x65, 0x6c, 0x6c, 0x6f, 0x3f, // ping hello?
 73                 0x88, 0x00,                                     // close
 74         };
 75         server = Support.serverWithCannedData(bytes);
 76         server.open();
 77         MockListener listener = new MockListener() {
 78             @Override
 79             protected void onOpen0(WebSocket webSocket) {
 80                 /* request nothing */
 81             }
 82         };
 83         webSocket = newHttpClient()
 84                 .newWebSocketBuilder()
 85                 .buildAsync(server.getURI(), listener)
 86                 .join();
 87 
 88         webSocket.sendClose(WebSocket.NORMAL_CLOSURE, &quot;ok&quot;).join();
 89         // now request all messages available
 90         webSocket.request(Long.MAX_VALUE);
 91         List&lt;MockListener.Invocation&gt; actual = listener.invocations();
 92         ByteBuffer hello = ByteBuffer.wrap(&quot;hello?&quot;.getBytes(StandardCharsets.UTF_8));
 93         ByteBuffer empty = ByteBuffer.allocate(0);
 94         List&lt;MockListener.Invocation&gt; expected = List.of(
 95                 MockListener.Invocation.onOpen(webSocket),
 96                 MockListener.Invocation.onPing(webSocket, empty),
 97                 MockListener.Invocation.onPing(webSocket, hello),
 98                 MockListener.Invocation.onClose(webSocket, 1005, &quot;&quot;)
 99         );
100         assertEquals(actual, expected);
101     }
102 
103     /*
104      * The server sends a number of contiguous Ping messages. The client replies
105      * to these messages automatically. According to RFC 6455 a WebSocket client
106      * is free to reply only to the most recent Pings.
107      *
108      * What is checked here is that:
109      *
110      *     a) the order of Pong replies corresponds to the Pings received,
111      *     b) the last Pong corresponds to the last Ping
112      *     c) there are no unrelated Pongs
113      */
114     @Test(dataProvider = &quot;nPings&quot;)
115     public void automaticPongs(int nPings) throws Exception {
116         // big enough to not bother with resize
117         ByteBuffer buffer = ByteBuffer.allocate(65536);
118         Frame.HeaderWriter w = new Frame.HeaderWriter();
119         for (int i = 0; i &lt; nPings; i++) {
120             w.fin(true)
121              .opcode(Frame.Opcode.PING)
122              .noMask()
123              .payloadLen(4)    // the length of the number of the Ping (int)
124              .write(buffer);
125             buffer.putInt(i);  // the number of the Ping (int)
126         }
127         w.fin(true)
128          .opcode(Frame.Opcode.CLOSE)
129          .noMask()
130          .payloadLen(2)
131         .write(buffer);
132         buffer.putChar((char) 1000);
133         buffer.flip();
134         server = Support.serverWithCannedData(buffer.array());
135         server.open();
136         MockListener listener = new MockListener();
137         webSocket = newHttpClient()
138                 .newWebSocketBuilder()
139                 .buildAsync(server.getURI(), listener)
140                 .join();
141         List&lt;MockListener.Invocation&gt; inv = listener.invocations();
142         assertEquals(inv.size(), nPings + 2); // n * onPing + onOpen + onClose
143 
144         ByteBuffer data = server.read();
145         Frame.Reader reader = new Frame.Reader();
146 
147         Frame.Consumer consumer = new Frame.Consumer() {
148 
149             ByteBuffer number = ByteBuffer.allocate(4);
150             Frame.Masker masker = new Frame.Masker();
151             int i = -1;
152             boolean closed;
153 
154             @Override
155             public void fin(boolean value) { assertTrue(value); }
156 
157             @Override
158             public void rsv1(boolean value) { assertFalse(value); }
159 
160             @Override
161             public void rsv2(boolean value) { assertFalse(value); }
162 
163             @Override
164             public void rsv3(boolean value) { assertFalse(value); }
165 
166             @Override
167             public void opcode(Frame.Opcode value) {
168                 if (value == Frame.Opcode.CLOSE) {
169                     closed = true;
170                     return;
171                 }
172                 assertEquals(value, Frame.Opcode.PONG);
173             }
174 
175             @Override
176             public void mask(boolean value) { assertTrue(value); }
177 
178             @Override
179             public void payloadLen(long value) {
180                 if (!closed)
181                     assertEquals(value, 4);
182             }
183 
184             @Override
185             public void maskingKey(int value) {
186                 masker.mask(value);
187             }
188 
189             @Override
190             public void payloadData(ByteBuffer src) {
191                 masker.transferMasking(src, number);
192                 if (closed) {
193                     return;
194                 }
195                 number.flip();
196                 int n = number.getInt();
197                 System.out.printf(&quot;pong number=%s%n&quot;, n);
198                 number.clear();
199                 // a Pong with the number less than the maximum of Pongs already
200                 // received MUST never be received
201                 if (i &gt;= n) {
202                     fail(String.format(&quot;i=%s, n=%s&quot;, i, n));
203                 }
204                 i = n;
205             }
206 
207             @Override
208             public void endFrame() { }
209         };
210         while (data.hasRemaining()) {
211             reader.readFrame(data, consumer);
212         }
213     }
214 
215 
216     @DataProvider(name = &quot;nPings&quot;)
217     public Object[][] nPings() {
218         return new Object[][]{{1}, {2}, {4}, {8}, {9}, {256}};
219     }
220 }
    </pre>
  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames test/jdk/java/net/httpclient/whitebox/java.net.http/jdk/internal/net/http/ConnectionPoolTest.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
<a name="1" id="anc1"></a><span class="line-modified">  2  * Copyright (c) 2017, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 package jdk.internal.net.http;
 25 
 26 import java.io.IOException;
 27 import java.lang.management.ManagementFactory;
<a name="2" id="anc2"></a><span class="line-added"> 28 import java.lang.ref.Reference;</span>
 29 import java.net.Authenticator;
 30 import java.net.CookieHandler;
 31 import java.net.InetSocketAddress;
 32 import java.net.ProxySelector;
<a name="3" id="anc3"></a><span class="line-added"> 33 import java.net.Socket;</span>
<span class="line-added"> 34 import java.net.SocketAddress;</span>
<span class="line-added"> 35 import java.net.SocketOption;</span>
<span class="line-added"> 36 import java.net.http.HttpHeaders;</span>
 37 import java.nio.ByteBuffer;
 38 import java.nio.channels.SocketChannel;
<a name="4" id="anc4"></a><span class="line-added"> 39 import java.nio.channels.spi.SelectorProvider;</span>
 40 import java.time.Duration;
<a name="5" id="anc5"></a><span class="line-modified"> 41 import java.util.HashMap;</span>
 42 import java.util.List;
<a name="6" id="anc6"></a><span class="line-added"> 43 import java.util.Map;</span>
 44 import java.util.Optional;
 45 import java.util.Random;
<a name="7" id="anc7"></a><span class="line-added"> 46 import java.util.Set;</span>
 47 import java.util.concurrent.CompletableFuture;
 48 import java.util.concurrent.Executor;
 49 import java.util.concurrent.Flow;
 50 import java.util.stream.IntStream;
 51 import java.time.Instant;
 52 import java.time.temporal.ChronoUnit;
 53 import javax.net.ssl.SSLContext;
 54 import javax.net.ssl.SSLParameters;
 55 import java.net.http.HttpClient;
 56 import java.net.http.HttpRequest;
 57 import java.net.http.HttpResponse;
 58 import jdk.internal.net.http.common.FlowTube;
 59 
 60 /**
 61  * @summary Verifies that the ConnectionPool correctly handle
 62  *          connection deadlines and purges the right connections
 63  *          from the cache.
<a name="8" id="anc8"></a><span class="line-modified"> 64  * @bug 8187044 8187111 8221395</span>
 65  * @author danielfuchs
 66  */
 67 public class ConnectionPoolTest {
 68 
 69     static long getActiveCleaners() throws ClassNotFoundException {
 70         // ConnectionPool.ACTIVE_CLEANER_COUNTER.get()
 71         // ConnectionPoolTest.class.getModule().addReads(
 72         //      Class.forName(&quot;java.lang.management.ManagementFactory&quot;).getModule());
 73         return java.util.stream.Stream.of(ManagementFactory.getThreadMXBean()
 74                 .dumpAllThreads(false, false))
 75               .filter(t -&gt; t.getThreadName().startsWith(&quot;HTTP-Cache-cleaner&quot;))
 76               .count();
 77     }
 78 
 79     public static void main(String[] args) throws Exception {
 80         if (args.length == 0) {
 81             args = new String[] {&quot;testCacheCleaners&quot;};
 82         }
 83         for (String arg : args) {
 84             if (&quot;testCacheCleaners&quot;.equals(arg)) {
 85                 testCacheCleaners();
 86             } else if (&quot;testPoolSize&quot;.equals(arg)) {
 87                 assert args.length == 1 : &quot;testPoolSize should be run in its own VM&quot;;
 88                 testPoolSize();
<a name="9" id="anc9"></a><span class="line-modified"> 89             } else if (&quot;testCloseOrReturnToPool&quot;.equals(arg)) {</span>
<span class="line-added"> 90                 assert args.length == 1 : &quot;testCloseOrReturnToPool should be run in its own VM&quot;;</span>
<span class="line-added"> 91                 testCloseOrReturnToPool();</span>
<span class="line-added"> 92             } else throw new RuntimeException(&quot;unknown test case: &quot; + arg);</span>
 93         }
 94     }
 95 
 96     public static void testCacheCleaners() throws Exception {
 97         ConnectionPool pool = new ConnectionPool(666);
 98         HttpClient client = new HttpClientStub(pool);
 99         InetSocketAddress proxy = InetSocketAddress.createUnresolved(&quot;bar&quot;, 80);
100         System.out.println(&quot;Adding 20 connections to pool&quot;);
101         Random random = new Random();
102 
103         final int count = 20;
104         Instant now = Instant.now().truncatedTo(ChronoUnit.SECONDS);
105         int[] keepAlives = new int[count];
106         HttpConnectionStub[] connections = new HttpConnectionStub[count];
107         long purge = pool.purgeExpiredConnectionsAndReturnNextDeadline(now);
108         long expected = 0;
109         if (purge != expected) {
110             throw new RuntimeException(&quot;Bad purge delay: &quot; + purge
111                                         + &quot;, expected &quot; + expected);
112         }
113         expected = Long.MAX_VALUE;
114         for (int i=0; i&lt;count; i++) {
115             InetSocketAddress addr = InetSocketAddress.createUnresolved(&quot;foo&quot;+i, 80);
116             keepAlives[i] = random.nextInt(10) * 10  + 10;
117             connections[i] = new HttpConnectionStub(client, addr, proxy, true);
118             System.out.println(&quot;Adding connection: &quot; + now
119                                 + &quot; keepAlive: &quot; + keepAlives[i]
120                                 + &quot; /&quot; + connections[i]);
121             pool.returnToPool(connections[i], now, keepAlives[i]);
122             expected = Math.min(expected, keepAlives[i] * 1000);
123             purge = pool.purgeExpiredConnectionsAndReturnNextDeadline(now);
124             if (purge != expected) {
125                 throw new RuntimeException(&quot;Bad purge delay: &quot; + purge
126                                         + &quot;, expected &quot; + expected);
127             }
128         }
129         int min = IntStream.of(keepAlives).min().getAsInt();
130         int max = IntStream.of(keepAlives).max().getAsInt();
131         int mean = (min + max)/2;
132         System.out.println(&quot;min=&quot; + min + &quot;, max=&quot; + max + &quot;, mean=&quot; + mean);
133         purge = pool.purgeExpiredConnectionsAndReturnNextDeadline(now);
134         System.out.println(&quot;first purge would be in &quot; + purge + &quot; ms&quot;);
135         if (Math.abs(purge/1000 - min) &gt; 0) {
136             throw new RuntimeException(&quot;expected &quot; + min + &quot; got &quot; + purge/1000);
137         }
138         long opened = java.util.stream.Stream.of(connections)
139                      .filter(HttpConnectionStub::connected).count();
140         if (opened != count) {
141             throw new RuntimeException(&quot;Opened: expected &quot;
142                                        + count + &quot; got &quot; + opened);
143         }
144         purge = mean * 1000;
145         System.out.println(&quot;start purging at &quot; + purge + &quot; ms&quot;);
146         Instant next = now;
147         do {
148            System.out.println(&quot;next purge is in &quot; + purge + &quot; ms&quot;);
149            next = next.plus(purge, ChronoUnit.MILLIS);
150            purge = pool.purgeExpiredConnectionsAndReturnNextDeadline(next);
151            long k = now.until(next, ChronoUnit.SECONDS);
152            System.out.println(&quot;now is &quot; + k + &quot;s from start&quot;);
153            for (int i=0; i&lt;count; i++) {
154                if (connections[i].connected() != (k &lt; keepAlives[i])) {
155                    throw new RuntimeException(&quot;Bad connection state for &quot;
156                              + i
157                              + &quot;\n\t connected=&quot; + connections[i].connected()
158                              + &quot;\n\t keepAlive=&quot; + keepAlives[i]
159                              + &quot;\n\t elapsed=&quot; + k);
160                }
161            }
162         } while (purge &gt; 0);
163         opened = java.util.stream.Stream.of(connections)
164                      .filter(HttpConnectionStub::connected).count();
165         if (opened != 0) {
166            throw new RuntimeException(&quot;Closed: expected &quot;
167                                        + count + &quot; got &quot;
168                                        + (count-opened));
169         }
170     }
171 
172     public static void testPoolSize() throws Exception {
173         final int MAX_POOL_SIZE = 10;
174         System.setProperty(&quot;jdk.httpclient.connectionPoolSize&quot;,
175                 String.valueOf(MAX_POOL_SIZE));
176         ConnectionPool pool = new ConnectionPool(666);
177         HttpClient client = new HttpClientStub(pool);
178         InetSocketAddress proxy = InetSocketAddress.createUnresolved(&quot;bar&quot;, 80);
179         System.out.println(&quot;Adding 20 connections to pool&quot;);
180         Random random = new Random();
181 
182         final int count = 20;
183         Instant now = Instant.now().truncatedTo(ChronoUnit.SECONDS);
184         int[] keepAlives = new int[count];
185         HttpConnectionStub[] connections = new HttpConnectionStub[count];
186         long purge = pool.purgeExpiredConnectionsAndReturnNextDeadline(now);
187         long expected = 0;
188         if (purge != expected) {
189             throw new RuntimeException(&quot;Bad purge delay: &quot; + purge
190                     + &quot;, expected &quot; + expected);
191         }
192         expected = Long.MAX_VALUE;
193         int previous = 0;
194         for (int i=0; i&lt;count; i++) {
195             InetSocketAddress addr = InetSocketAddress.createUnresolved(&quot;foo&quot;+i, 80);
196             keepAlives[i] = random.nextInt(10) * 10  + 5 + previous;
197             previous = keepAlives[i];
198             connections[i] = new HttpConnectionStub(client, addr, proxy, true);
199             System.out.println(&quot;Adding connection: &quot; + now
200                     + &quot; keepAlive: &quot; + keepAlives[i]
201                     + &quot; /&quot; + connections[i]);
202             pool.returnToPool(connections[i], now, keepAlives[i]);
203             if (i &lt; MAX_POOL_SIZE) {
204                 expected = Math.min(expected, keepAlives[i] * 1000);
205             } else {
206                 expected = keepAlives[i-MAX_POOL_SIZE+1] * 1000;
207                 if (pool.contains(connections[i-MAX_POOL_SIZE])) {
208                     throw new RuntimeException(&quot;Connection[&quot; + i + &quot;]/&quot;
209                             + connections[i] + &quot; should have been removed&quot;);
210                 }
211             }
212             purge = pool.purgeExpiredConnectionsAndReturnNextDeadline(now);
213             if (purge != expected) {
214                 throw new RuntimeException(&quot;Bad purge delay for &quot; + i + &quot;: &quot;
215                         + purge + &quot;, expected &quot; + expected);
216             }
217         }
218 
219         long opened = java.util.stream.Stream.of(connections)
220                 .filter(HttpConnectionStub::connected).count();
221         if (opened != MAX_POOL_SIZE) {
222             throw new RuntimeException(&quot;Opened: expected &quot;
223                     + count + &quot; got &quot; + opened);
224         }
225         for (int i=0 ; i&lt;count; i++) {
226             boolean closed = (i &lt; count - MAX_POOL_SIZE);
227             if (connections[i].closed != closed) {
228                 throw new RuntimeException(&quot;connection[&quot; + i + &quot;] should be &quot;
229                         + (closed ? &quot;closed&quot; : &quot;opened&quot;));
230             }
231             if (pool.contains(connections[i]) == closed) {
232                 throw new RuntimeException(&quot;Connection[&quot; + i + &quot;]/&quot;
233                         + connections[i] + &quot; should &quot;
234                         + (closed ? &quot;&quot; : &quot;not &quot;)
235                         + &quot;have been removed&quot;);
236             }
237         }
238     }
239 
<a name="10" id="anc10"></a><span class="line-added">240     public static void testCloseOrReturnToPool() throws Exception {</span>
<span class="line-added">241         HttpClientFacade facade = (HttpClientFacade)HttpClient.newHttpClient();</span>
<span class="line-added">242         HttpClientImpl client = facade.impl;</span>
<span class="line-added">243         ConnectionPool pool = client.connectionPool();</span>
<span class="line-added">244         InetSocketAddress proxy = InetSocketAddress.createUnresolved(&quot;bar&quot;, 80);</span>
<span class="line-added">245 </span>
<span class="line-added">246         InetSocketAddress addr = InetSocketAddress.createUnresolved(&quot;foo1&quot;, 80);</span>
<span class="line-added">247         HttpConnectionStub conn1 = new HttpConnectionStub(facade, client, addr, proxy, true);</span>
<span class="line-added">248         HttpHeaders hdrs = HttpHeaders.of(new HashMap&lt;&gt;(), (s1,s2) -&gt; true);</span>
<span class="line-added">249         HttpConnection conn;</span>
<span class="line-added">250 </span>
<span class="line-added">251         conn1.reopen();</span>
<span class="line-added">252         if (!conn1.isOpen()) {</span>
<span class="line-added">253             throw new RuntimeException(&quot;conn1 finished&quot;);</span>
<span class="line-added">254         }</span>
<span class="line-added">255 </span>
<span class="line-added">256         conn1.closeOrReturnToCache(hdrs);</span>
<span class="line-added">257 </span>
<span class="line-added">258         // Check we can find conn1 in the pool</span>
<span class="line-added">259         if (conn1 != (conn = pool.getConnection(true, addr, proxy))) {</span>
<span class="line-added">260             throw new RuntimeException(&quot;conn1 not returned, got: &quot; + conn);</span>
<span class="line-added">261         }</span>
<span class="line-added">262         System.out.println(&quot;Found connection in the pool: &quot; + conn );</span>
<span class="line-added">263 </span>
<span class="line-added">264         // Try to return it with no headers: the connection should</span>
<span class="line-added">265         // be closed and not returned to the pool (EOF).</span>
<span class="line-added">266         conn.closeOrReturnToCache(null);</span>
<span class="line-added">267         if ((conn = pool.getConnection(true, addr, proxy)) != null) {</span>
<span class="line-added">268             throw new RuntimeException(conn + &quot; found in the pool!&quot;);</span>
<span class="line-added">269         }</span>
<span class="line-added">270         if (!conn1.closed) {</span>
<span class="line-added">271             throw new RuntimeException(&quot;conn1 not closed!&quot;);</span>
<span class="line-added">272         }</span>
<span class="line-added">273         System.out.println(&quot;EOF connection successfully closed when returned to pool&quot;);</span>
<span class="line-added">274 </span>
<span class="line-added">275         // reopen the connection</span>
<span class="line-added">276         conn1.reopen();</span>
<span class="line-added">277         if (!conn1.isOpen()) {</span>
<span class="line-added">278             throw new RuntimeException(&quot;conn1 finished&quot;);</span>
<span class="line-added">279         }</span>
<span class="line-added">280 </span>
<span class="line-added">281         // Try to return it with empty headers: the connection should</span>
<span class="line-added">282         // be returned to the pool.</span>
<span class="line-added">283         conn1.closeOrReturnToCache(hdrs);</span>
<span class="line-added">284         if (conn1 != (conn = pool.getConnection(true, addr, proxy))) {</span>
<span class="line-added">285             throw new RuntimeException(&quot;conn1 not returned to pool, got: &quot; + conn);</span>
<span class="line-added">286         }</span>
<span class="line-added">287         if (conn1.closed) {</span>
<span class="line-added">288             throw new RuntimeException(&quot;conn1 closed&quot;);</span>
<span class="line-added">289         }</span>
<span class="line-added">290         if (!conn1.isOpen()) {</span>
<span class="line-added">291             throw new RuntimeException(&quot;conn1 finished&quot;);</span>
<span class="line-added">292         }</span>
<span class="line-added">293 </span>
<span class="line-added">294         System.out.println(&quot;Keep alive connection successfully returned to pool&quot;);</span>
<span class="line-added">295 </span>
<span class="line-added">296         // Try to return it with connection: close headers: the connection should</span>
<span class="line-added">297         // not be returned to the pool, and should be closed.</span>
<span class="line-added">298         HttpHeaders hdrs2 = HttpHeaders.of(Map.of(&quot;connection&quot;, List.of(&quot;close&quot;)), (s1, s2) -&gt; true);</span>
<span class="line-added">299         conn1.closeOrReturnToCache(hdrs2);</span>
<span class="line-added">300         if ((conn = pool.getConnection(true, addr, proxy)) != null) {</span>
<span class="line-added">301             throw new RuntimeException(conn + &quot; found in the pool!&quot;);</span>
<span class="line-added">302         }</span>
<span class="line-added">303         if (!conn1.closed) {</span>
<span class="line-added">304             throw new RuntimeException(&quot;conn1 not closed!&quot;);</span>
<span class="line-added">305         }</span>
<span class="line-added">306         System.out.println(&quot;Close connection successfully closed when returned to pool&quot;);</span>
<span class="line-added">307 </span>
<span class="line-added">308         // reopen and finish the connection.</span>
<span class="line-added">309         conn1.reopen();</span>
<span class="line-added">310         conn1.finish(true);</span>
<span class="line-added">311         if (conn1.closed) {</span>
<span class="line-added">312             throw new RuntimeException(&quot;conn1 closed&quot;);</span>
<span class="line-added">313         }</span>
<span class="line-added">314         if (conn1.isOpen()) {</span>
<span class="line-added">315             throw new RuntimeException(&quot;conn1 is opened!&quot;);</span>
<span class="line-added">316         }</span>
<span class="line-added">317         conn1.closeOrReturnToCache(hdrs2);</span>
<span class="line-added">318         if ((conn = pool.getConnection(true, addr, proxy)) != null) {</span>
<span class="line-added">319             throw new RuntimeException(conn + &quot; found in the pool!&quot;);</span>
<span class="line-added">320         }</span>
<span class="line-added">321         if (!conn1.closed) {</span>
<span class="line-added">322             throw new RuntimeException(&quot;conn1 not closed!&quot;);</span>
<span class="line-added">323         }</span>
<span class="line-added">324         System.out.println(&quot;Finished &#39;close&#39; connection successfully closed when returned to pool&quot;);</span>
<span class="line-added">325 </span>
<span class="line-added">326         // reopen and finish the connection.</span>
<span class="line-added">327         conn1.reopen();</span>
<span class="line-added">328         conn1.finish(true);</span>
<span class="line-added">329         if (conn1.closed) {</span>
<span class="line-added">330             throw new RuntimeException(&quot;conn1 closed&quot;);</span>
<span class="line-added">331         }</span>
<span class="line-added">332         if (conn1.isOpen()) {</span>
<span class="line-added">333             throw new RuntimeException(&quot;conn1 is opened!&quot;);</span>
<span class="line-added">334         }</span>
<span class="line-added">335         conn1.closeOrReturnToCache(hdrs);</span>
<span class="line-added">336         if ((conn = pool.getConnection(true, addr, proxy)) != null) {</span>
<span class="line-added">337             throw new RuntimeException(conn + &quot; found in the pool!&quot;);</span>
<span class="line-added">338         }</span>
<span class="line-added">339         if (!conn1.closed) {</span>
<span class="line-added">340             throw new RuntimeException(&quot;conn1 not closed!&quot;);</span>
<span class="line-added">341         }</span>
<span class="line-added">342         System.out.println(&quot;Finished keep-alive connection successfully closed when returned to pool&quot;);</span>
<span class="line-added">343 </span>
<span class="line-added">344         Reference.reachabilityFence(facade);</span>
<span class="line-added">345     }</span>
<span class="line-added">346 </span>
347     static &lt;T&gt; T error() {
348         throw new InternalError(&quot;Should not reach here: wrong test assumptions!&quot;);
349     }
350 
351     static class FlowTubeStub implements FlowTube {
352         final HttpConnectionStub conn;
353         FlowTubeStub(HttpConnectionStub conn) { this.conn = conn; }
354         @Override
355         public void onSubscribe(Flow.Subscription subscription) { }
356         @Override public void onError(Throwable error) { error(); }
357         @Override public void onComplete() { error(); }
358         @Override public void onNext(List&lt;ByteBuffer&gt; item) { error();}
359         @Override
360         public void subscribe(Flow.Subscriber&lt;? super List&lt;ByteBuffer&gt;&gt; subscriber) {
361         }
<a name="11" id="anc11"></a><span class="line-modified">362         @Override public boolean isFinished() { return conn.finished; }</span>
<span class="line-added">363     }</span>
<span class="line-added">364 </span>
<span class="line-added">365     static class SocketChannelStub extends SocketChannel {</span>
<span class="line-added">366 </span>
<span class="line-added">367         SocketChannelStub() { super(SelectorProvider.provider()); }</span>
<span class="line-added">368 </span>
<span class="line-added">369         @Override</span>
<span class="line-added">370         public SocketChannel bind(SocketAddress local) throws IOException {</span>
<span class="line-added">371             return error();</span>
<span class="line-added">372         }</span>
<span class="line-added">373         @Override</span>
<span class="line-added">374         public &lt;T&gt; SocketChannel setOption(SocketOption&lt;T&gt; name, T value) throws IOException {</span>
<span class="line-added">375             return error();</span>
<span class="line-added">376         }</span>
<span class="line-added">377         @Override</span>
<span class="line-added">378         public SocketChannel shutdownInput() throws IOException {</span>
<span class="line-added">379             return error();</span>
<span class="line-added">380         }</span>
<span class="line-added">381         @Override</span>
<span class="line-added">382         public SocketChannel shutdownOutput() throws IOException {</span>
<span class="line-added">383             return error();</span>
<span class="line-added">384         }</span>
<span class="line-added">385         @Override</span>
<span class="line-added">386         public Socket socket() { return error(); }</span>
<span class="line-added">387         @Override</span>
<span class="line-added">388         public boolean isConnected() { return true; }</span>
<span class="line-added">389         @Override</span>
<span class="line-added">390         public boolean isConnectionPending() { return false; }</span>
<span class="line-added">391         @Override</span>
<span class="line-added">392         public boolean connect(SocketAddress remote) throws IOException {</span>
<span class="line-added">393             return error();</span>
<span class="line-added">394         }</span>
<span class="line-added">395         @Override</span>
<span class="line-added">396         public boolean finishConnect() throws IOException {</span>
<span class="line-added">397             return error();</span>
<span class="line-added">398         }</span>
<span class="line-added">399         @Override</span>
<span class="line-added">400         public SocketAddress getRemoteAddress() throws IOException {</span>
<span class="line-added">401             return error();</span>
<span class="line-added">402         }</span>
<span class="line-added">403         @Override</span>
<span class="line-added">404         public int read(ByteBuffer dst) throws IOException {</span>
<span class="line-added">405             return error();</span>
<span class="line-added">406         }</span>
<span class="line-added">407         @Override</span>
<span class="line-added">408         public long read(ByteBuffer[] dsts, int offset, int length) throws IOException {</span>
<span class="line-added">409             return error();</span>
<span class="line-added">410         }</span>
<span class="line-added">411         @Override</span>
<span class="line-added">412         public int write(ByteBuffer src) throws IOException {</span>
<span class="line-added">413             return error();</span>
<span class="line-added">414         }</span>
<span class="line-added">415         @Override</span>
<span class="line-added">416         public long write(ByteBuffer[] srcs, int offset, int length) throws IOException {</span>
<span class="line-added">417             return 0;</span>
<span class="line-added">418         }</span>
<span class="line-added">419         @Override</span>
<span class="line-added">420         public SocketAddress getLocalAddress() throws IOException {</span>
<span class="line-added">421             return error();</span>
<span class="line-added">422         }</span>
<span class="line-added">423         @Override</span>
<span class="line-added">424         public &lt;T&gt; T getOption(SocketOption&lt;T&gt; name) throws IOException {</span>
<span class="line-added">425             return error();</span>
<span class="line-added">426         }</span>
<span class="line-added">427         @Override</span>
<span class="line-added">428         public Set&lt;SocketOption&lt;?&gt;&gt; supportedOptions() {</span>
<span class="line-added">429             return error();</span>
<span class="line-added">430         }</span>
<span class="line-added">431         @Override</span>
<span class="line-added">432         protected void implCloseSelectableChannel() throws IOException {</span>
<span class="line-added">433             error();</span>
<span class="line-added">434         }</span>
<span class="line-added">435         @Override</span>
<span class="line-added">436         protected void implConfigureBlocking(boolean block) throws IOException {</span>
<span class="line-added">437             error();</span>
<span class="line-added">438         }</span>
439     }
440 
441     // Emulates an HttpConnection that has a strong reference to its HttpClient.
442     static class HttpConnectionStub extends HttpConnection {
443 
<a name="12" id="anc12"></a><span class="line-modified">444         public HttpConnectionStub(</span>
<span class="line-added">445                 HttpClient client,</span>
<span class="line-added">446                 InetSocketAddress address,</span>
<span class="line-added">447                 InetSocketAddress proxy,</span>
<span class="line-added">448                 boolean secured) {</span>
<span class="line-added">449             this(client, null, address, proxy, secured);</span>
<span class="line-added">450         }</span>
<span class="line-added">451         public HttpConnectionStub(</span>
<span class="line-added">452                 HttpClient client,</span>
<span class="line-added">453                 HttpClientImpl impl,</span>
454                 InetSocketAddress address,
455                 InetSocketAddress proxy,
456                 boolean secured) {
<a name="13" id="anc13"></a><span class="line-modified">457             super(address, impl);</span>
458             this.key = ConnectionPool.cacheKey(address, proxy);
459             this.address = address;
460             this.proxy = proxy;
461             this.secured = secured;
462             this.client = client;
<a name="14" id="anc14"></a><span class="line-added">463             this.channel = new SocketChannelStub();</span>
464             this.flow = new FlowTubeStub(this);
465         }
466 
467         final InetSocketAddress proxy;
468         final InetSocketAddress address;
469         final boolean secured;
470         final ConnectionPool.CacheKey key;
471         final HttpClient client;
472         final FlowTubeStub flow;
<a name="15" id="anc15"></a><span class="line-modified">473         final SocketChannel channel;</span>
<span class="line-added">474         volatile boolean closed, finished;</span>
<span class="line-added">475 </span>
<span class="line-added">476         // Used for testing closeOrReturnToPool.</span>
<span class="line-added">477         void finish(boolean finished) { this.finished = finished; }</span>
<span class="line-added">478         void reopen() { closed = finished = false;}</span>
479 
480         // All these return something
481         @Override boolean connected() {return !closed;}
482         @Override boolean isSecure() {return secured;}
483         @Override boolean isProxied() {return proxy!=null;}
484         @Override ConnectionPool.CacheKey cacheKey() {return key;}
<a name="16" id="anc16"></a><span class="line-added">485         @Override FlowTube getConnectionFlow() {return flow;}</span>
<span class="line-added">486         @Override SocketChannel channel() {return channel;}</span>
487         @Override
488         public void close() {
<a name="17" id="anc17"></a><span class="line-modified">489             closed=finished=true;</span>
490             System.out.println(&quot;closed: &quot; + this);
491         }
492         @Override
493         public String toString() {
494             return &quot;HttpConnectionStub: &quot; + address + &quot; proxy: &quot; + proxy;
495         }
496 
<a name="18" id="anc18"></a><span class="line-added">497 </span>
498         // All these throw errors
499         @Override public HttpPublisher publisher() {return error();}
500         @Override public CompletableFuture&lt;Void&gt; connectAsync(Exchange&lt;?&gt; e) {return error();}
501         @Override public CompletableFuture&lt;Void&gt; finishConnect() {return error();}
<a name="19" id="anc19"></a>


502     }
503     // Emulates an HttpClient that has a strong reference to its connection pool.
504     static class HttpClientStub extends HttpClient {
505         public HttpClientStub(ConnectionPool pool) {
506             this.pool = pool;
507         }
508         final ConnectionPool pool;
509         @Override public Optional&lt;CookieHandler&gt; cookieHandler() {return error();}
510         @Override public Optional&lt;Duration&gt; connectTimeout() {return error();}
511         @Override public HttpClient.Redirect followRedirects() {return error();}
512         @Override public Optional&lt;ProxySelector&gt; proxy() {return error();}
513         @Override public SSLContext sslContext() {return error();}
514         @Override public SSLParameters sslParameters() {return error();}
515         @Override public Optional&lt;Authenticator&gt; authenticator() {return error();}
516         @Override public HttpClient.Version version() {return HttpClient.Version.HTTP_1_1;}
517         @Override public Optional&lt;Executor&gt; executor() {return error();}
518         @Override
519         public &lt;T&gt; HttpResponse&lt;T&gt; send(HttpRequest req,
520                                         HttpResponse.BodyHandler&lt;T&gt; responseBodyHandler)
521                 throws IOException, InterruptedException {
522             return error();
523         }
524         @Override
525         public &lt;T&gt; CompletableFuture&lt;HttpResponse&lt;T&gt;&gt; sendAsync(HttpRequest req,
526                 HttpResponse.BodyHandler&lt;T&gt; responseBodyHandler) {
527             return error();
528         }
529         @Override
530         public &lt;T&gt; CompletableFuture&lt;HttpResponse&lt;T&gt;&gt; sendAsync(HttpRequest req,
531                 HttpResponse.BodyHandler&lt;T&gt; bodyHandler,
532                 HttpResponse.PushPromiseHandler&lt;T&gt; multiHandler) {
533             return error();
534         }
535     }
536 
537 }
<a name="20" id="anc20"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="20" type="hidden" />
</body>
</html>
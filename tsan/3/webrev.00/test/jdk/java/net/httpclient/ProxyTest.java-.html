<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old test/jdk/java/net/httpclient/ProxyTest.java</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2017, 2018, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 import com.sun.net.httpserver.HttpContext;
 25 import com.sun.net.httpserver.HttpExchange;
 26 import com.sun.net.httpserver.HttpHandler;
 27 import com.sun.net.httpserver.HttpServer;
 28 import com.sun.net.httpserver.HttpsConfigurator;
 29 import com.sun.net.httpserver.HttpsParameters;
 30 import com.sun.net.httpserver.HttpsServer;
 31 import java.io.IOException;
 32 import java.io.InputStream;
 33 import java.io.OutputStream;
 34 import java.io.OutputStreamWriter;
 35 import java.io.PrintWriter;
 36 import java.io.Writer;
 37 import java.net.HttpURLConnection;
 38 import java.net.InetAddress;
 39 import java.net.InetSocketAddress;
 40 import java.net.Proxy;
 41 import java.net.ProxySelector;
 42 import java.net.ServerSocket;
 43 import java.net.Socket;
 44 import java.net.SocketAddress;
 45 import java.net.URI;
 46 import java.net.URISyntaxException;
 47 import java.nio.charset.StandardCharsets;
 48 import java.security.NoSuchAlgorithmException;
 49 import java.util.List;
 50 import java.util.concurrent.CompletableFuture;
 51 import java.util.concurrent.CopyOnWriteArrayList;
 52 import javax.net.ssl.HostnameVerifier;
 53 import javax.net.ssl.HttpsURLConnection;
 54 import javax.net.ssl.SSLContext;
 55 import javax.net.ssl.SSLSession;
 56 import java.net.http.HttpClient;
 57 import java.net.http.HttpRequest;
 58 import java.net.http.HttpResponse;
 59 import jdk.test.lib.net.SimpleSSLContext;
 60 
 61 /**
 62  * @test
 63  * @bug 8185852 8181422
 64  * @summary Verifies that passing a proxy with an unresolved address does
 65  *          not cause java.nio.channels.UnresolvedAddressException.
 66  *          Verifies that downgrading from HTTP/2 to HTTP/1.1 works through
 67  *          an SSL Tunnel connection when the client is HTTP/2 and the server
 68  *          and proxy are HTTP/1.1
 69  * @modules java.net.http
 70  * @library /test/lib
 71  * @build jdk.test.lib.net.SimpleSSLContext ProxyTest
 72  * @run main/othervm ProxyTest
 73  * @author danielfuchs
 74  */
 75 public class ProxyTest {
 76 
 77     static {
 78         try {
 79             HttpsURLConnection.setDefaultHostnameVerifier(new HostnameVerifier() {
 80                     public boolean verify(String hostname, SSLSession session) {
 81                         return true;
 82                     }
 83                 });
 84             SSLContext.setDefault(new SimpleSSLContext().get());
 85         } catch (IOException ex) {
 86             throw new ExceptionInInitializerError(ex);
 87         }
 88     }
 89 
 90     static final String RESPONSE = &quot;&lt;html&gt;&lt;body&gt;&lt;p&gt;Hello World!&lt;/body&gt;&lt;/html&gt;&quot;;
 91     static final String PATH = &quot;/foo/&quot;;
 92 
 93     static HttpServer createHttpsServer() throws IOException, NoSuchAlgorithmException {
 94         HttpsServer server = com.sun.net.httpserver.HttpsServer.create();
 95         HttpContext context = server.createContext(PATH);
 96         context.setHandler(new HttpHandler() {
 97             @Override
 98             public void handle(HttpExchange he) throws IOException {
 99                 he.getResponseHeaders().add(&quot;encoding&quot;, &quot;UTF-8&quot;);
100                 he.sendResponseHeaders(200, RESPONSE.length());
101                 he.getResponseBody().write(RESPONSE.getBytes(StandardCharsets.UTF_8));
102                 he.close();
103             }
104         });
105 
106         server.setHttpsConfigurator(new Configurator(SSLContext.getDefault()));
107         InetSocketAddress addr = new InetSocketAddress(InetAddress.getLoopbackAddress(), 0);
108         server.bind(addr, 0);
109         return server;
110     }
111 
112     public static void main(String[] args)
113             throws IOException,
114             URISyntaxException,
115             NoSuchAlgorithmException,
116             InterruptedException
117     {
118         HttpServer server = createHttpsServer();
119         server.start();
120         try {
121             test(server, HttpClient.Version.HTTP_1_1);
122             test(server, HttpClient.Version.HTTP_2);
123         } finally {
124             server.stop(0);
125             System.out.println(&quot;Server stopped&quot;);
126         }
127     }
128 
129     /**
130      * A Proxy Selector that wraps a ProxySelector.of(), and counts the number
131      * of times its select method has been invoked. This can be used to ensure
132      * that the Proxy Selector is invoked only once per HttpClient.sendXXX
133      * invocation.
134      */
135     static class CountingProxySelector extends ProxySelector {
136         private final ProxySelector proxySelector;
137         private volatile int count; // 0
138         private CountingProxySelector(InetSocketAddress proxyAddress) {
139             proxySelector = ProxySelector.of(proxyAddress);
140         }
141 
142         public static CountingProxySelector of(InetSocketAddress proxyAddress) {
143             return new CountingProxySelector(proxyAddress);
144         }
145 
146         int count() { return count; }
147 
148         @Override
149         public List&lt;Proxy&gt; select(URI uri) {
150             count++;
151             return proxySelector.select(uri);
152         }
153 
154         @Override
155         public void connectFailed(URI uri, SocketAddress sa, IOException ioe) {
156             proxySelector.connectFailed(uri, sa, ioe);
157         }
158     }
159 
160     public static void test(HttpServer server, HttpClient.Version version)
161             throws IOException,
162             URISyntaxException,
163             NoSuchAlgorithmException,
164             InterruptedException
165     {
166         System.out.println(&quot;Server is: &quot; + server.getAddress().toString());
167         System.out.println(&quot;Verifying communication with server&quot;);
168         URI uri = new URI(&quot;https://localhost:&quot;
169                           + server.getAddress().getPort() + PATH + &quot;x&quot;);
170         try (InputStream is = uri.toURL().openConnection().getInputStream()) {
171             String resp = new String(is.readAllBytes(), StandardCharsets.UTF_8);
172             System.out.println(resp);
173             if (!RESPONSE.equals(resp)) {
174                 throw new AssertionError(&quot;Unexpected response from server&quot;);
175             }
176         }
177         System.out.println(&quot;Communication with server OK&quot;);
178 
179         TunnelingProxy proxy = new TunnelingProxy(server);
180         proxy.start();
181         try {
182             System.out.println(&quot;Proxy started&quot;);
183             Proxy p = new Proxy(Proxy.Type.HTTP,
184                     InetSocketAddress.createUnresolved(&quot;localhost&quot;,
185                             proxy.getAddress().getPort()));
186             System.out.println(&quot;Verifying communication with proxy&quot;);
187             HttpURLConnection conn = (HttpURLConnection)uri.toURL().openConnection(p);
188             try (InputStream is = conn.getInputStream()) {
189                 String resp = new String(is.readAllBytes(), StandardCharsets.UTF_8);
190                 System.out.println(resp);
191                 if (!RESPONSE.equals(resp)) {
192                     throw new AssertionError(&quot;Unexpected response from proxy&quot;);
193                 }
194             }
195             System.out.println(&quot;Communication with proxy OK&quot;);
196             System.out.println(&quot;\nReal test begins here.&quot;);
197             System.out.println(&quot;Setting up request with HttpClient for version: &quot;
198                     + version.name());
199             CountingProxySelector ps = CountingProxySelector.of(
200                     InetSocketAddress.createUnresolved(&quot;localhost&quot;,
201                             proxy.getAddress().getPort()));
202             HttpClient client = HttpClient.newBuilder()
203                 .version(version)
204                 .proxy(ps)
205                 .build();
206             HttpRequest request = HttpRequest.newBuilder()
207                 .uri(uri)
208                 .GET()
209                 .build();
210 
211             System.out.println(&quot;Sending request with HttpClient&quot;);
212             HttpResponse&lt;String&gt; response
213                 = client.send(request, HttpResponse.BodyHandlers.ofString());
214             System.out.println(&quot;Got response&quot;);
215             String resp = response.body();
216             System.out.println(&quot;Received: &quot; + resp);
217             if (!RESPONSE.equals(resp)) {
218                 throw new AssertionError(&quot;Unexpected response&quot;);
219             }
220             if (ps.count() &gt; 1) {
221                 throw new AssertionError(&quot;CountingProxySelector. Expected 1, got &quot; + ps.count());
222             }
223         } finally {
224             System.out.println(&quot;Stopping proxy&quot;);
225             proxy.stop();
226             System.out.println(&quot;Proxy stopped&quot;);
227         }
228     }
229 
230     static class TunnelingProxy {
231         final Thread accept;
232         final ServerSocket ss;
233         final boolean DEBUG = false;
234         final HttpServer serverImpl;
235         final CopyOnWriteArrayList&lt;CompletableFuture&lt;Void&gt;&gt; connectionCFs
236                 = new CopyOnWriteArrayList&lt;&gt;();
237         private volatile boolean stopped;
238         TunnelingProxy(HttpServer serverImpl) throws IOException {
239             this.serverImpl = serverImpl;
240             ss = new ServerSocket();
241             accept = new Thread(this::accept);
242             accept.setDaemon(true);
243         }
244 
245         void start() throws IOException {
246             ss.bind(new InetSocketAddress(InetAddress.getLoopbackAddress(), 0));
247             accept.start();
248         }
249 
250         // Pipe the input stream to the output stream.
251         private synchronized Thread pipe(InputStream is, OutputStream os,
252                                          char tag, CompletableFuture&lt;Void&gt; end) {
253             return new Thread(&quot;TunnelPipe(&quot;+tag+&quot;)&quot;) {
254                 @Override
255                 public void run() {
256                     try {
257                         try {
258                             int c;
259                             while ((c = is.read()) != -1) {
260                                 os.write(c);
261                                 os.flush();
262                                 // if DEBUG prints a + or a - for each transferred
263                                 // character.
264                                 if (DEBUG) System.out.print(tag);
265                             }
266                             is.close();
267                         } finally {
268                             os.close();
269                         }
270                     } catch (IOException ex) {
271                         if (DEBUG) ex.printStackTrace(System.out);
272                     } finally {
273                         end.complete(null);
274                     }
275                 }
276             };
277         }
278 
279         public InetSocketAddress getAddress() {
280             return new InetSocketAddress(InetAddress.getLoopbackAddress(),
281                                          ss.getLocalPort());
282         }
283 
284         // This is a bit shaky. It doesn&#39;t handle continuation
285         // lines, but our client shouldn&#39;t send any.
286         // Read a line from the input stream, swallowing the final
287         // \r\n sequence. Stops at the first \n, doesn&#39;t complain
288         // if it wasn&#39;t preceded by &#39;\r&#39;.
289         //
290         String readLine(InputStream r) throws IOException {
291             StringBuilder b = new StringBuilder();
292             int c;
293             while ((c = r.read()) != -1) {
294                 if (c == &#39;\n&#39;) break;
295                 b.appendCodePoint(c);
296             }
297             if (b.codePointAt(b.length() -1) == &#39;\r&#39;) {
298                 b.delete(b.length() -1, b.length());
299             }
300             return b.toString();
301         }
302 
303         public void accept() {
304             Socket clientConnection = null;
305             try {
306                 while (!stopped) {
307                     System.out.println(&quot;Tunnel: Waiting for client&quot;);
308                     Socket toClose;
309                     try {
310                         toClose = clientConnection = ss.accept();
311                     } catch (IOException io) {
312                         if (DEBUG) io.printStackTrace(System.out);
313                         break;
314                     }
315                     System.out.println(&quot;Tunnel: Client accepted&quot;);
316                     Socket targetConnection = null;
317                     InputStream  ccis = clientConnection.getInputStream();
318                     OutputStream ccos = clientConnection.getOutputStream();
319                     Writer w = new OutputStreamWriter(ccos, &quot;UTF-8&quot;);
320                     PrintWriter pw = new PrintWriter(w);
321                     System.out.println(&quot;Tunnel: Reading request line&quot;);
322                     String requestLine = readLine(ccis);
323                     System.out.println(&quot;Tunnel: Request status line: &quot; + requestLine);
324                     if (requestLine.startsWith(&quot;CONNECT &quot;)) {
325                         // We should probably check that the next word following
326                         // CONNECT is the host:port of our HTTPS serverImpl.
327                         // Some improvement for a followup!
328 
329                         // Read all headers until we find the empty line that
330                         // signals the end of all headers.
331                         while(!requestLine.equals(&quot;&quot;)) {
332                             System.out.println(&quot;Tunnel: Reading header: &quot;
333                                                + (requestLine = readLine(ccis)));
334                         }
335 
336                         // Open target connection
337                         targetConnection = new Socket(
338                                 InetAddress.getLoopbackAddress(),
339                                 serverImpl.getAddress().getPort());
340 
341                         // Then send the 200 OK response to the client
342                         System.out.println(&quot;Tunnel: Sending &quot;
343                                            + &quot;HTTP/1.1 200 OK\r\n\r\n&quot;);
344                         pw.print(&quot;HTTP/1.1 200 OK\r\nContent-Length: 0\r\n\r\n&quot;);
345                         pw.flush();
346                     } else {
347                         // This should not happen. If it does then just print an
348                         // error - both on out and err, and close the accepted
349                         // socket
350                         System.out.println(&quot;WARNING: Tunnel: Unexpected status line: &quot;
351                                 + requestLine + &quot; received by &quot;
352                                 + ss.getLocalSocketAddress()
353                                 + &quot; from &quot;
354                                 + toClose.getRemoteSocketAddress()
355                                 + &quot; - closing accepted socket&quot;);
356                         // Print on err
357                         System.err.println(&quot;WARNING: Tunnel: Unexpected status line: &quot;
358                                 + requestLine + &quot; received by &quot;
359                                 + ss.getLocalSocketAddress()
360                                 + &quot; from &quot;
361                                 + toClose.getRemoteSocketAddress());
362                         // close accepted socket.
363                         toClose.close();
364                         System.err.println(&quot;Tunnel: accepted socket closed.&quot;);
365                         continue;
366                     }
367 
368                     // Pipe the input stream of the client connection to the
369                     // output stream of the target connection and conversely.
370                     // Now the client and target will just talk to each other.
371                     System.out.println(&quot;Tunnel: Starting tunnel pipes&quot;);
372                     CompletableFuture&lt;Void&gt; end, end1, end2;
373                     Thread t1 = pipe(ccis, targetConnection.getOutputStream(), &#39;+&#39;,
374                             end1 = new CompletableFuture&lt;&gt;());
375                     Thread t2 = pipe(targetConnection.getInputStream(), ccos, &#39;-&#39;,
376                             end2 = new CompletableFuture&lt;&gt;());
377                     end = CompletableFuture.allOf(end1, end2);
378                     end.whenComplete(
379                             (r,t) -&gt; {
380                                 try { toClose.close(); } catch (IOException x) { }
381                                 finally {connectionCFs.remove(end);}
382                             });
383                     connectionCFs.add(end);
384                     t1.start();
385                     t2.start();
386                 }
387             } catch (Throwable ex) {
388                 try {
389                     ss.close();
390                 } catch (IOException ex1) {
391                     ex.addSuppressed(ex1);
392                 }
393                 ex.printStackTrace(System.err);
394             } finally {
395                 System.out.println(&quot;Tunnel: exiting (stopped=&quot; + stopped + &quot;)&quot;);
396                 connectionCFs.forEach(cf -&gt; cf.complete(null));
397             }
398         }
399 
400         public void stop() throws IOException {
401             stopped = true;
402             ss.close();
403         }
404 
405     }
406 
407     static class Configurator extends HttpsConfigurator {
408         public Configurator(SSLContext ctx) {
409             super(ctx);
410         }
411 
412         @Override
413         public void configure (HttpsParameters params) {
414             params.setSSLParameters (getSSLContext().getSupportedSSLParameters());
415         }
416     }
417 
418 }
    </pre>
  </body>
</html>
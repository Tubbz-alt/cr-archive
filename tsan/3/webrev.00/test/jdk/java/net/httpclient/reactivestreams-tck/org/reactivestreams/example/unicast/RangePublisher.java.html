<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New test/jdk/java/net/httpclient/reactivestreams-tck/org/reactivestreams/example/unicast/RangePublisher.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 package org.reactivestreams.example.unicast;
 25 
 26 import org.reactivestreams.*;
 27 
 28 import java.util.concurrent.atomic.AtomicLong;
 29 
 30 /**
 31  * A synchronous implementation of the {@link Publisher} that can
 32  * be subscribed to multiple times and each individual subscription
 33  * will receive range of monotonically increasing integer values on demand.
 34  */
 35 public final class RangePublisher implements Publisher&lt;Integer&gt; {
 36 
 37     /** The starting value of the range. */
 38     final int start;
 39 
 40     /** The number of items to emit. */
 41     final int count;
 42 
 43     /**
 44      * Constructs a RangePublisher instance with the given start and count values
 45      * that yields a sequence of [start, start + count).
 46      * @param start the starting value of the range
 47      * @param count the number of items to emit
 48      */
 49     public RangePublisher(int start, int count) {
 50         this.start = start;
 51         this.count = count;
 52     }
 53 
 54     @Override
 55     public void subscribe(Subscriber&lt;? super Integer&gt; subscriber) {
 56         // As per rule 1.11, we have decided to support multiple subscribers
 57         // in a unicast configuration for this `Publisher` implementation.
 58 
 59         // As per rule 1.09, we need to throw a `java.lang.NullPointerException`
 60         // if the `Subscriber` is `null`
 61         if (subscriber == null) throw null;
 62 
 63         // As per 2.13, this method must return normally (i.e. not throw).
 64         try {
 65             subscriber.onSubscribe(new RangeSubscription(subscriber, start, start + count));
 66         } catch (Throwable ex) {
 67             new IllegalStateException(subscriber + &quot; violated the Reactive Streams rule 2.13 &quot; +
 68                     &quot;by throwing an exception from onSubscribe.&quot;, ex)
 69                     // When onSubscribe fails this way, we don&#39;t know what state the
 70                     // subscriber is thus calling onError may cause more crashes.
 71                     .printStackTrace();
 72         }
 73     }
 74 
 75     /**
 76      * A Subscription implementation that holds the current downstream
 77      * requested amount and responds to the downstream&#39;s request() and
 78      * cancel() calls.
 79      */
 80     static final class RangeSubscription
 81             // We are using this `AtomicLong` to make sure that this `Subscription`
 82             // doesn&#39;t run concurrently with itself, which would violate rule 1.3
 83             // among others (no concurrent notifications).
 84             // The atomic transition from 0L to N &gt; 0L will ensure this.
 85             extends AtomicLong implements Subscription {
 86 
 87         private static final long serialVersionUID = -9000845542177067735L;
 88 
 89         /** The Subscriber we are emitting integer values to. */
 90         final Subscriber&lt;? super Integer&gt; downstream;
 91 
 92         /** The end index (exclusive). */
 93         final int end;
 94 
 95         /**
 96          * The current index and within the [start, start + count) range that
 97          * will be emitted as downstream.onNext().
 98          */
 99         int index;
100 
101         /**
102          * Indicates the emission should stop.
103          */
104         volatile boolean cancelled;
105 
106         /**
107          * Holds onto the IllegalArgumentException (containing the offending stacktrace)
108          * indicating there was a non-positive request() call from the downstream.
109          */
110         volatile Throwable invalidRequest;
111 
112         /**
113          * Constructs a stateful RangeSubscription that emits signals to the given
114          * downstream from an integer range of [start, end).
115          * @param downstream the Subscriber receiving the integer values and the completion signal.
116          * @param start the first integer value emitted, start of the range
117          * @param end the end of the range, exclusive
118          */
119         RangeSubscription(Subscriber&lt;? super Integer&gt; downstream, int start, int end) {
120             this.downstream = downstream;
121             this.index = start;
122             this.end = end;
123         }
124 
125         // This method will register inbound demand from our `Subscriber` and
126         // validate it against rule 3.9 and rule 3.17
127         @Override
128         public void request(long n) {
129             // Non-positive requests should be honored with IllegalArgumentException
130             if (n &lt;= 0L) {
131                 invalidRequest = new IllegalArgumentException(&quot;ยง3.9: non-positive requests are not allowed!&quot;);
132                 n = 1;
133             }
134             // Downstream requests are cumulative and may come from any thread
135             for (;;) {
136                 long requested = get();
137                 long update = requested + n;
138                 // As governed by rule 3.17, when demand overflows `Long.MAX_VALUE`
139                 // we treat the signalled demand as &quot;effectively unbounded&quot;
140                 if (update &lt; 0L) {
141                     update = Long.MAX_VALUE;
142                 }
143                 // atomically update the current requested amount
144                 if (compareAndSet(requested, update)) {
145                     // if there was no prior request amount, we start the emission loop
146                     if (requested == 0L) {
147                         emit(update);
148                     }
149                     break;
150                 }
151             }
152         }
153 
154         // This handles cancellation requests, and is idempotent, thread-safe and not
155         // synchronously performing heavy computations as specified in rule 3.5
156         @Override
157         public void cancel() {
158             // Indicate to the emission loop it should stop.
159             cancelled = true;
160         }
161 
162         void emit(long currentRequested) {
163             // Load fields to avoid re-reading them from memory due to volatile accesses in the loop.
164             Subscriber&lt;? super Integer&gt; downstream = this.downstream;
165             int index = this.index;
166             int end = this.end;
167             int emitted = 0;
168 
169             try {
170                 for (; ; ) {
171                     // Check if there was an invalid request and then report its exception
172                     // as mandated by rule 3.9. The stacktrace in it should
173                     // help locate the faulty logic in the Subscriber.
174                     Throwable invalidRequest = this.invalidRequest;
175                     if (invalidRequest != null) {
176                         // When we signal onError, the subscription must be considered as cancelled, as per rule 1.6
177                         cancelled = true;
178 
179                         downstream.onError(invalidRequest);
180                         return;
181                     }
182 
183                     // Loop while the index hasn&#39;t reached the end and we haven&#39;t
184                     // emitted all that&#39;s been requested
185                     while (index != end &amp;&amp; emitted != currentRequested) {
186                         // to make sure that we follow rule 1.8, 3.6 and 3.7
187                         // We stop if cancellation was requested.
188                         if (cancelled) {
189                             return;
190                         }
191 
192                         downstream.onNext(index);
193 
194                         // Increment the index for the next possible emission.
195                         index++;
196                         // Increment the emitted count to prevent overflowing the downstream.
197                         emitted++;
198                     }
199 
200                     // If the index reached the end, we complete the downstream.
201                     if (index == end) {
202                         // to make sure that we follow rule 1.8, 3.6 and 3.7
203                         // Unless cancellation was requested by the last onNext.
204                         if (!cancelled) {
205                             // We need to consider this `Subscription` as cancelled as per rule 1.6
206                             // Note, however, that this state is not observable from the outside
207                             // world and since we leave the loop with requested &gt; 0L, any
208                             // further request() will never trigger the loop.
209                             cancelled = true;
210 
211                             downstream.onComplete();
212                         }
213                         return;
214                     }
215 
216                     // Did the requested amount change while we were looping?
217                     long freshRequested = get();
218                     if (freshRequested == currentRequested) {
219                         // Save where the loop has left off: the next value to be emitted
220                         this.index = index;
221                         // Atomically subtract the previously requested (also emitted) amount
222                         currentRequested = addAndGet(-currentRequested);
223                         // If there was no new request in between get() and addAndGet(), we simply quit
224                         // The next 0 to N transition in request() will trigger the next emission loop.
225                         if (currentRequested == 0L) {
226                             break;
227                         }
228                         // Looks like there were more async requests, reset the emitted count and continue.
229                         emitted = 0;
230                     } else {
231                         // Yes, avoid the atomic subtraction and resume.
232                         // emitted != currentRequest in this case and index
233                         // still points to the next value to be emitted
234                         currentRequested = freshRequested;
235                     }
236                 }
237             } catch (Throwable ex) {
238                 // We can only get here if `onNext`, `onError` or `onComplete` threw, and they
239                 // are not allowed to according to 2.13, so we can only cancel and log here.
240                 // If `onError` throws an exception, this is a spec violation according to rule 1.9,
241                 // and all we can do is to log it.
242 
243                 // Make sure that we are cancelled, since we cannot do anything else
244                 // since the `Subscriber` is faulty.
245                 cancelled = true;
246 
247                 // We can&#39;t report the failure to onError as the Subscriber is unreliable.
248                 (new IllegalStateException(downstream + &quot; violated the Reactive Streams rule 2.13 by &quot; +
249                         &quot;throwing an exception from onNext, onError or onComplete.&quot;, ex))
250                         .printStackTrace();
251             }
252         }
253     }
254 }
    </pre>
  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New test/jdk/java/net/httpclient/reactivestreams-tck-tests/S.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 import java.io.IOException;
 25 import java.io.InputStream;
 26 import java.nio.ByteBuffer;
 27 import java.nio.charset.StandardCharsets;
 28 import java.security.SecureRandom;
 29 import java.util.ArrayList;
 30 import java.util.Arrays;
 31 import java.util.Iterator;
 32 import java.util.List;
 33 import java.util.Objects;
 34 import java.util.Random;
 35 import java.util.concurrent.Flow.Publisher;
 36 import java.util.concurrent.Flow.Subscriber;
 37 import java.util.concurrent.Flow.Subscription;
 38 import java.util.stream.Stream;
 39 
 40 /*
 41  * S for Support.
 42  *
 43  * Auxiliary methods for tests that check conformance with reactive streams
 44  * specification.
 45  *
 46  * Short name is for the sake of convenience calling this class&#39; static methods.
 47  * It could&#39;ve been called Support or TckSupport, but then we would need to
 48  * place this class in its own package so as to use &quot;import static&quot;.
 49  */
 50 public class S {
 51 
 52     private static final Random RANDOM = new SecureRandom();
 53 
 54     private S() { }
 55 
 56     public static List&lt;ByteBuffer&gt; listOfBuffersFromBufferOfNBytes(int nBytes) {
 57         return scatterBuffer(bufferOfNRandomBytes(nBytes));
 58     }
 59 
 60     /*
 61      * Spreads the remaining contents of the given byte buffer across a number
 62      * of buffers put into a list.
 63      */
 64     public static List&lt;ByteBuffer&gt; scatterBuffer(ByteBuffer src) {
 65         List&lt;ByteBuffer&gt; buffers = new ArrayList&lt;&gt;();
 66         while (src.hasRemaining()) {
 67             // We do not allow empty buffers ~~~~~~~~~~~~~~~~v
 68             int capacity = RANDOM.nextInt(src.remaining()) + 1;
 69             ByteBuffer b = ByteBuffer.allocate(capacity);
 70             for (int i = 0; i &lt; capacity; i++) {
 71                 b.put(src.get());
 72             }
 73             b.flip();
 74             buffers.add(b);
 75         }
 76         return List.copyOf(buffers);
 77     }
 78 
 79     public static ByteBuffer bufferOfNRandomBytes(int capacity) {
 80         return ByteBuffer.wrap(arrayOfNRandomBytes(capacity));
 81     }
 82 
 83     public static byte[] arrayOfNRandomBytes(int nBytes) {
 84         byte[] contents = new byte[nBytes];
 85         RANDOM.nextBytes(contents);
 86         return contents;
 87     }
 88 
 89     public static InputStream inputStreamOfNReads(long n) {
 90         return new NReadsInputStream(n);
 91     }
 92 
 93     /*
 94      * Convenience method for testing publishers.
 95      */
 96     public static byte[] arrayOfNRandomBytes(long nBytes) {
 97         return arrayOfNRandomBytes((int) nBytes);
 98     }
 99 
100     public static ByteBuffer bufferOfNRandomASCIIBytes(int capacity) {
101         String alphaNumeric = &quot;abcdefghijklmnopqrstuvwxyz1234567890&quot;;
102         StringBuilder builder = new StringBuilder(capacity);
103         for (int i = 0; i &lt; capacity; i++) {
104             int idx = RANDOM.nextInt(alphaNumeric.length());
105             builder.append(alphaNumeric.charAt(idx));
106         }
107         return ByteBuffer.wrap(builder.toString().getBytes(
108                 StandardCharsets.US_ASCII));
109     }
110 
111     /*
112      * Returns a simple non-compliant Subscriber.
113      *
114      * This Subscriber is useful for testing our adaptors and wrappers, to make
115      * sure they do not delegate RS compliance to the underlying (and foreign to
116      * java.net.http codebase) Subscribers, but rather comply themselves.
117      *
118      * Here&#39;s an example:
119      *
120      *     public void onSubscribe(Subscription s) {
121      *         delegate.onSubscribe(s);
122      *     }
123      *
124      * The snippet above cannot be considered a good implementation of a
125      * Subscriber if `delegate` is an unknown Subscriber. In this case the
126      * implementation should independently check all the rules from the RS spec
127      * related to subscribers.
128      */
129     public static &lt;T&gt; Subscriber&lt;T&gt; nonCompliantSubscriber() {
130         return new Subscriber&lt;&gt;() {
131 
132             @Override
133             public void onSubscribe(Subscription subscription) {
134                 subscription.request(Long.MAX_VALUE);
135             }
136 
137             @Override
138             public void onNext(T item) { }
139 
140             @Override
141             public void onError(Throwable throwable) { }
142 
143             @Override
144             public void onComplete() { }
145         };
146     }
147 
148     public static int randomIntUpTo(int bound) {
149         return RANDOM.nextInt(bound);
150     }
151 
152     /*
153      * Signals an error to its subscribers immediately after subscription.
154      */
155     public static &lt;T&gt; Publisher&lt;T&gt; newErroredPublisher() {
156         return subscriber -&gt; {
157             subscriber.onSubscribe(new Subscription() {
158                 @Override
159                 public void request(long n) { }
160 
161                 @Override
162                 public void cancel() { }
163             });
164             subscriber.onError(new IOException());
165         };
166     }
167 
168     /*
169      * Publishes the elements obtained from the stream and signals completion.
170      * Can be cancelled, but cannot signal an error.
171      *
172      * This trivial ad-hoc implementation of Publisher was created so as to
173      * publish lists of byte buffers. We can publish ByteBuffer, but we can&#39;t
174      * seem to publish List&lt;ByteBuffer&gt; since there&#39;s no readily available
175      * publisher of those, nor there&#39;s a simple adaptor.
176      */
177     public static &lt;T&gt; Publisher&lt;T&gt; publisherOfStream(Stream&lt;? extends T&gt; stream)
178     {
179         if (stream == null) {
180             throw new NullPointerException();
181         }
182         return new Publisher&lt;T&gt;() {
183             @Override
184             public void subscribe(Subscriber&lt;? super T&gt; subscriber) {
185                 if (subscriber == null) {
186                     throw new NullPointerException();
187                 }
188                 Subscription subscription = new Subscription() {
189 
190                     boolean inOnNext; // recursion control
191                     volatile boolean cancelled;
192                     long demand;
193                     final Iterator&lt;? extends T&gt; supply = stream.iterator();
194 
195                     @Override
196                     public void request(long n) {
197                         demand = demand + n &lt; 0 ? Long.MAX_VALUE : demand + n;
198                         if (inOnNext) {
199                             return;
200                         }
201                         if (cancelled)
202                             return;
203                         if (n &lt;= 0) {
204                             cancelled = true;
205                             subscriber.onError(new IllegalArgumentException(
206                                     &quot;non-positive subscription request&quot;));
207                             return;
208                         }
209                         while (supply.hasNext() &amp;&amp; demand &gt; 0 &amp;&amp; !cancelled) {
210                             demand--;
211                             inOnNext = true;
212                             try {
213                                 T item = supply.next();
214                                 subscriber.onNext(item);
215                             } finally {
216                                 inOnNext = false;
217                             }
218                         }
219                         if (!supply.hasNext()) {
220                             cancelled = true;
221                             subscriber.onComplete();
222                         }
223                     }
224 
225                     @Override
226                     public void cancel() {
227                         cancelled = true;
228                     }
229                 };
230                 subscriber.onSubscribe(subscription);
231             }
232         };
233     }
234 
235     static final class NReadsInputStream extends InputStream {
236 
237         private static final int EOF = -1;
238         private long readsLeft;
239 
240         NReadsInputStream(long n) {
241             if (n &lt; 0) {
242                 throw new IllegalArgumentException(String.valueOf(n));
243             }
244             this.readsLeft = n;
245         }
246 
247         @Override
248         public int read() {
249             if (readsLeft == 0L) {
250                 return EOF;
251             }
252             readsLeft--;
253             return S.randomIntUpTo(256);
254         }
255 
256         @Override
257         public int read(byte[] b, int off, int len) {
258             Objects.checkFromIndexSize(off, len, b.length);
259             // Must return 0 if len == 0,
260             // even if there are no more reads left
261             if (len == 0) {
262                 return 0;
263             }
264             if (readsLeft == 0L) {
265                 return EOF;
266             }
267             readsLeft--;
268             // At least one byte MUST be read, but we can read
269             // less than `len` bytes
270             int r = RANDOM.nextInt(len) + 1;
271             for (int i = 0; i &lt; r; i++) {
272                 b[i] = (byte) randomIntUpTo(256);
273             }
274             return r;
275         }
276     }
277 }
    </pre>
  </body>
</html>
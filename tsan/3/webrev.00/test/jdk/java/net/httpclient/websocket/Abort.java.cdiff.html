<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff test/jdk/java/net/httpclient/websocket/Abort.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
<body>
<center><a href="../ssltest/Server.java.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="AutomaticPong.java.cdiff.html" target="_top">next &gt;</a></center>    <h2>test/jdk/java/net/httpclient/websocket/Abort.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 1,7 ***</span>
  /*
<span class="line-modified">!  * Copyright (c) 2018, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.
<span class="line-new-header">--- 1,7 ---</span>
  /*
<span class="line-modified">!  * Copyright (c) 2018, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 27,11 ***</span>
   * @run testng/othervm
   *      -Djdk.internal.httpclient.websocket.debug=true
   *       Abort
   */
  
<span class="line-removed">- import org.testng.annotations.AfterTest;</span>
  import org.testng.annotations.Test;
  
  import java.io.IOException;
  import java.net.ProtocolException;
  import java.net.http.WebSocket;
<span class="line-new-header">--- 27,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 54,251 ***</span>
  
      private static final Class&lt;NullPointerException&gt; NPE = NullPointerException.class;
      private static final Class&lt;IllegalArgumentException&gt; IAE = IllegalArgumentException.class;
      private static final Class&lt;IOException&gt; IOE = IOException.class;
  
<span class="line-removed">-     private DummyWebSocketServer server;</span>
<span class="line-removed">-     private WebSocket webSocket;</span>
<span class="line-removed">- </span>
<span class="line-removed">-     @AfterTest</span>
<span class="line-removed">-     public void cleanup() {</span>
<span class="line-removed">-         server.close();</span>
<span class="line-removed">-         webSocket.abort();</span>
<span class="line-removed">-     }</span>
  
      @Test
      public void onOpenThenAbort() throws Exception {
          int[] bytes = new int[]{
                  0x88, 0x00, // opcode=close
          };
<span class="line-modified">!         server = Support.serverWithCannedData(bytes);</span>
<span class="line-modified">!         server.open();</span>
<span class="line-modified">!         // messages are available</span>
<span class="line-modified">!         MockListener listener = new MockListener() {</span>
<span class="line-modified">!             @Override</span>
<span class="line-modified">!             protected void onOpen0(WebSocket webSocket) {</span>
<span class="line-modified">!                 // unbounded request</span>
<span class="line-modified">!                 webSocket.request(Long.MAX_VALUE);</span>
                  webSocket.abort();
              }
<span class="line-modified">!         };</span>
<span class="line-removed">-         webSocket = newHttpClient().newWebSocketBuilder()</span>
<span class="line-removed">-                 .buildAsync(server.getURI(), listener)</span>
<span class="line-removed">-                 .join();</span>
<span class="line-removed">-         TimeUnit.SECONDS.sleep(5);</span>
<span class="line-removed">-         List&lt;MockListener.Invocation&gt; inv = listener.invocationsSoFar();</span>
<span class="line-removed">-         // no more invocations after onOpen as WebSocket was aborted</span>
<span class="line-removed">-         assertEquals(inv, List.of(MockListener.Invocation.onOpen(webSocket)));</span>
      }
  
      @Test
      public void onOpenThenOnTextThenAbort() throws Exception {
          int[] bytes = new int[]{
                  0x81, 0x00, // opcode=text, fin=true
                  0x88, 0x00, // opcode=close
          };
<span class="line-modified">!         server = Support.serverWithCannedData(bytes);</span>
<span class="line-modified">!         server.open();</span>
<span class="line-modified">!         MockListener listener = new MockListener() {</span>
<span class="line-modified">!             @Override</span>
<span class="line-modified">!             protected void onOpen0(WebSocket webSocket) {</span>
<span class="line-modified">!                 // unbounded request</span>
<span class="line-modified">!                 webSocket.request(Long.MAX_VALUE);</span>
<span class="line-modified">!             }</span>
  
<span class="line-modified">!             @Override</span>
<span class="line-modified">!             protected CompletionStage&lt;?&gt; onText0(WebSocket webSocket,</span>
<span class="line-modified">!                                                  CharSequence message,</span>
<span class="line-modified">!                                                  boolean last) {</span>
                  webSocket.abort();
<span class="line-removed">-                 return super.onText0(webSocket, message, last);</span>
              }
<span class="line-modified">!         };</span>
<span class="line-removed">-         webSocket = newHttpClient().newWebSocketBuilder()</span>
<span class="line-removed">-                 .buildAsync(server.getURI(), listener)</span>
<span class="line-removed">-                 .join();</span>
<span class="line-removed">-         TimeUnit.SECONDS.sleep(5);</span>
<span class="line-removed">-         List&lt;MockListener.Invocation&gt; inv = listener.invocationsSoFar();</span>
<span class="line-removed">-         // no more invocations after onOpen, onBinary as WebSocket was aborted</span>
<span class="line-removed">-         List&lt;MockListener.Invocation&gt; expected = List.of(</span>
<span class="line-removed">-                 MockListener.Invocation.onOpen(webSocket),</span>
<span class="line-removed">-                 MockListener.Invocation.onText(webSocket, &quot;&quot;, true));</span>
<span class="line-removed">-         assertEquals(inv, expected);</span>
      }
  
      @Test
      public void onOpenThenOnBinaryThenAbort() throws Exception {
          int[] bytes = new int[]{
                  0x82, 0x00, // opcode=binary, fin=true
                  0x88, 0x00, // opcode=close
          };
<span class="line-modified">!         server = Support.serverWithCannedData(bytes);</span>
<span class="line-modified">!         server.open();</span>
<span class="line-modified">!         MockListener listener = new MockListener() {</span>
<span class="line-modified">!             @Override</span>
<span class="line-modified">!             protected void onOpen0(WebSocket webSocket) {</span>
<span class="line-modified">!                 // unbounded request</span>
<span class="line-modified">!                 webSocket.request(Long.MAX_VALUE);</span>
<span class="line-modified">!             }</span>
  
<span class="line-modified">!             @Override</span>
<span class="line-modified">!             protected CompletionStage&lt;?&gt; onBinary0(WebSocket webSocket,</span>
<span class="line-modified">!                                                    ByteBuffer message,</span>
<span class="line-modified">!                                                    boolean last) {</span>
                  webSocket.abort();
<span class="line-removed">-                 return super.onBinary0(webSocket, message, last);</span>
              }
<span class="line-modified">!         };</span>
<span class="line-removed">-         webSocket = newHttpClient().newWebSocketBuilder()</span>
<span class="line-removed">-                 .buildAsync(server.getURI(), listener)</span>
<span class="line-removed">-                 .join();</span>
<span class="line-removed">-         TimeUnit.SECONDS.sleep(5);</span>
<span class="line-removed">-         List&lt;MockListener.Invocation&gt; inv = listener.invocationsSoFar();</span>
<span class="line-removed">-         // no more invocations after onOpen, onBinary as WebSocket was aborted</span>
<span class="line-removed">-         List&lt;MockListener.Invocation&gt; expected = List.of(</span>
<span class="line-removed">-                 MockListener.Invocation.onOpen(webSocket),</span>
<span class="line-removed">-                 MockListener.Invocation.onBinary(webSocket, ByteBuffer.allocate(0), true));</span>
<span class="line-removed">-         assertEquals(inv, expected);</span>
      }
  
      @Test
      public void onOpenThenOnPingThenAbort() throws Exception {
          int[] bytes = {
                  0x89, 0x00, // opcode=ping
                  0x88, 0x00, // opcode=close
          };
<span class="line-modified">!         server = Support.serverWithCannedData(bytes);</span>
<span class="line-modified">!         server.open();</span>
<span class="line-modified">!         MockListener listener = new MockListener() {</span>
<span class="line-modified">!             @Override</span>
<span class="line-modified">!             protected void onOpen0(WebSocket webSocket) {</span>
<span class="line-modified">!                 // unbounded request</span>
<span class="line-modified">!                 webSocket.request(Long.MAX_VALUE);</span>
<span class="line-modified">!             }</span>
  
<span class="line-modified">!             @Override</span>
<span class="line-modified">!             protected CompletionStage&lt;?&gt; onPing0(WebSocket webSocket,</span>
<span class="line-modified">!                                                  ByteBuffer message) {</span>
                  webSocket.abort();
<span class="line-removed">-                 return super.onPing0(webSocket, message);</span>
              }
<span class="line-modified">!         };</span>
<span class="line-removed">-         webSocket = newHttpClient().newWebSocketBuilder()</span>
<span class="line-removed">-                 .buildAsync(server.getURI(), listener)</span>
<span class="line-removed">-                 .join();</span>
<span class="line-removed">-         TimeUnit.SECONDS.sleep(5);</span>
<span class="line-removed">-         List&lt;MockListener.Invocation&gt; inv = listener.invocationsSoFar();</span>
<span class="line-removed">-         // no more invocations after onOpen, onPing as WebSocket was aborted</span>
<span class="line-removed">-         List&lt;MockListener.Invocation&gt; expected = List.of(</span>
<span class="line-removed">-                 MockListener.Invocation.onOpen(webSocket),</span>
<span class="line-removed">-                 MockListener.Invocation.onPing(webSocket, ByteBuffer.allocate(0)));</span>
<span class="line-removed">-         assertEquals(inv, expected);</span>
      }
  
      @Test
      public void onOpenThenOnPongThenAbort() throws Exception {
          int[] bytes = {
                  0x8a, 0x00, // opcode=pong
                  0x88, 0x00, // opcode=close
          };
<span class="line-modified">!         server = Support.serverWithCannedData(bytes);</span>
<span class="line-modified">!         server.open();</span>
<span class="line-modified">!         MockListener listener = new MockListener() {</span>
<span class="line-modified">!             @Override</span>
<span class="line-modified">!             protected void onOpen0(WebSocket webSocket) {</span>
<span class="line-modified">!                 // unbounded request</span>
<span class="line-modified">!                 webSocket.request(Long.MAX_VALUE);</span>
<span class="line-modified">!             }</span>
  
<span class="line-modified">!             @Override</span>
<span class="line-modified">!             protected CompletionStage&lt;?&gt; onPong0(WebSocket webSocket,</span>
<span class="line-modified">!                                                  ByteBuffer message) {</span>
                  webSocket.abort();
<span class="line-removed">-                 return super.onPong0(webSocket, message);</span>
              }
<span class="line-modified">!         };</span>
<span class="line-removed">-         webSocket = newHttpClient().newWebSocketBuilder()</span>
<span class="line-removed">-                 .buildAsync(server.getURI(), listener)</span>
<span class="line-removed">-                 .join();</span>
<span class="line-removed">-         TimeUnit.SECONDS.sleep(5);</span>
<span class="line-removed">-         List&lt;MockListener.Invocation&gt; inv = listener.invocationsSoFar();</span>
<span class="line-removed">-         // no more invocations after onOpen, onPong as WebSocket was aborted</span>
<span class="line-removed">-         List&lt;MockListener.Invocation&gt; expected = List.of(</span>
<span class="line-removed">-                 MockListener.Invocation.onOpen(webSocket),</span>
<span class="line-removed">-                 MockListener.Invocation.onPong(webSocket, ByteBuffer.allocate(0)));</span>
<span class="line-removed">-         assertEquals(inv, expected);</span>
      }
  
      @Test
      public void onOpenThenOnCloseThenAbort() throws Exception {
          int[] bytes = {
                  0x88, 0x00, // opcode=close
                  0x8a, 0x00, // opcode=pong
          };
<span class="line-modified">!         server = Support.serverWithCannedData(bytes);</span>
<span class="line-modified">!         server.open();</span>
<span class="line-modified">!         MockListener listener = new MockListener() {</span>
<span class="line-modified">!             @Override</span>
<span class="line-modified">!             protected void onOpen0(WebSocket webSocket) {</span>
<span class="line-modified">!                 // unbounded request</span>
<span class="line-modified">!                 webSocket.request(Long.MAX_VALUE);</span>
<span class="line-modified">!             }</span>
  
<span class="line-modified">!             @Override</span>
<span class="line-modified">!             protected CompletionStage&lt;?&gt; onClose0(WebSocket webSocket,</span>
<span class="line-modified">!                                                   int statusCode,</span>
<span class="line-modified">!                                                   String reason) {</span>
                  webSocket.abort();
<span class="line-removed">-                 return super.onClose0(webSocket, statusCode, reason);</span>
              }
<span class="line-modified">!         };</span>
<span class="line-removed">-         webSocket = newHttpClient().newWebSocketBuilder()</span>
<span class="line-removed">-                 .buildAsync(server.getURI(), listener)</span>
<span class="line-removed">-                 .join();</span>
<span class="line-removed">-         TimeUnit.SECONDS.sleep(5);</span>
<span class="line-removed">-         List&lt;MockListener.Invocation&gt; inv = listener.invocationsSoFar();</span>
<span class="line-removed">-         // no more invocations after onOpen, onClose</span>
<span class="line-removed">-         List&lt;MockListener.Invocation&gt; expected = List.of(</span>
<span class="line-removed">-                 MockListener.Invocation.onOpen(webSocket),</span>
<span class="line-removed">-                 MockListener.Invocation.onClose(webSocket, 1005, &quot;&quot;));</span>
<span class="line-removed">-         assertEquals(inv, expected);</span>
      }
  
      @Test
      public void onOpenThenOnErrorThenAbort() throws Exception {
          // A header of 128 bytes long Ping (which is a protocol error)
          int[] badPingHeader = new int[]{0x89, 0x7e, 0x00, 0x80};
          int[] closeMessage = new int[]{0x88, 0x00};
          int[] bytes = new int[badPingHeader.length + 128 + closeMessage.length];
          System.arraycopy(badPingHeader, 0, bytes, 0, badPingHeader.length);
          System.arraycopy(closeMessage, 0, bytes, badPingHeader.length + 128, closeMessage.length);
<span class="line-modified">!         server = Support.serverWithCannedData(bytes);</span>
<span class="line-modified">!         server.open();</span>
<span class="line-modified">!         MockListener listener = new MockListener() {</span>
<span class="line-modified">!             @Override</span>
<span class="line-modified">!             protected void onOpen0(WebSocket webSocket) {</span>
<span class="line-modified">!                 // unbounded request</span>
<span class="line-modified">!                 webSocket.request(Long.MAX_VALUE);</span>
<span class="line-modified">!             }</span>
  
<span class="line-modified">!             @Override</span>
<span class="line-modified">!             protected void onError0(WebSocket webSocket, Throwable error) {</span>
                  webSocket.abort();
<span class="line-removed">-                 super.onError0(webSocket, error);</span>
              }
<span class="line-modified">!         };</span>
<span class="line-removed">-         webSocket = newHttpClient().newWebSocketBuilder()</span>
<span class="line-removed">-                 .buildAsync(server.getURI(), listener)</span>
<span class="line-removed">-                 .join();</span>
<span class="line-removed">-         TimeUnit.SECONDS.sleep(5);</span>
<span class="line-removed">-         List&lt;MockListener.Invocation&gt; inv = listener.invocationsSoFar();</span>
<span class="line-removed">-         // no more invocations after onOpen, onError</span>
<span class="line-removed">-         List&lt;MockListener.Invocation&gt; expected = List.of(</span>
<span class="line-removed">-                 MockListener.Invocation.onOpen(webSocket),</span>
<span class="line-removed">-                 MockListener.Invocation.onError(webSocket, ProtocolException.class));</span>
<span class="line-removed">-         System.out.println(&quot;actual invocations:&quot; + Arrays.toString(inv.toArray()));</span>
<span class="line-removed">-         assertEquals(inv, expected);</span>
      }
  
      @Test
      public void immediateAbort() throws Exception {
          CompletableFuture&lt;Void&gt; messageReceived = new CompletableFuture&lt;&gt;();
<span class="line-new-header">--- 53,278 ---</span>
  
      private static final Class&lt;NullPointerException&gt; NPE = NullPointerException.class;
      private static final Class&lt;IllegalArgumentException&gt; IAE = IllegalArgumentException.class;
      private static final Class&lt;IOException&gt; IOE = IOException.class;
  
  
      @Test
      public void onOpenThenAbort() throws Exception {
          int[] bytes = new int[]{
                  0x88, 0x00, // opcode=close
          };
<span class="line-modified">!         try (var server = Support.serverWithCannedData(bytes)) {</span>
<span class="line-modified">!             server.open();</span>
<span class="line-modified">!             // messages are available</span>
<span class="line-modified">!             MockListener listener = new MockListener() {</span>
<span class="line-modified">!                 @Override</span>
<span class="line-modified">!                 protected void onOpen0(WebSocket webSocket) {</span>
<span class="line-modified">!                     // unbounded request</span>
<span class="line-modified">!                     webSocket.request(Long.MAX_VALUE);</span>
<span class="line-added">+                     webSocket.abort();</span>
<span class="line-added">+                 }</span>
<span class="line-added">+             };</span>
<span class="line-added">+             var webSocket = newHttpClient().newWebSocketBuilder()</span>
<span class="line-added">+                     .buildAsync(server.getURI(), listener)</span>
<span class="line-added">+                     .join();</span>
<span class="line-added">+             try {</span>
<span class="line-added">+                 TimeUnit.SECONDS.sleep(5);</span>
<span class="line-added">+                 List&lt;MockListener.Invocation&gt; inv = listener.invocationsSoFar();</span>
<span class="line-added">+                 // no more invocations after onOpen as WebSocket was aborted</span>
<span class="line-added">+                 assertEquals(inv, List.of(MockListener.Invocation.onOpen(webSocket)));</span>
<span class="line-added">+             } finally {</span>
                  webSocket.abort();
              }
<span class="line-modified">!         }</span>
      }
  
      @Test
      public void onOpenThenOnTextThenAbort() throws Exception {
          int[] bytes = new int[]{
                  0x81, 0x00, // opcode=text, fin=true
                  0x88, 0x00, // opcode=close
          };
<span class="line-modified">!         try (var server = Support.serverWithCannedData(bytes)) {</span>
<span class="line-modified">!             server.open();</span>
<span class="line-modified">!             MockListener listener = new MockListener() {</span>
<span class="line-modified">!                 @Override</span>
<span class="line-modified">!                 protected void onOpen0(WebSocket webSocket) {</span>
<span class="line-modified">!                     // unbounded request</span>
<span class="line-modified">!                     webSocket.request(Long.MAX_VALUE);</span>
<span class="line-modified">!                 }</span>
  
<span class="line-modified">!                 @Override</span>
<span class="line-modified">!                 protected CompletionStage&lt;?&gt; onText0(WebSocket webSocket,</span>
<span class="line-modified">!                                                      CharSequence message,</span>
<span class="line-modified">!                                                      boolean last) {</span>
<span class="line-added">+                     webSocket.abort();</span>
<span class="line-added">+                     return super.onText0(webSocket, message, last);</span>
<span class="line-added">+                 }</span>
<span class="line-added">+             };</span>
<span class="line-added">+             var webSocket = newHttpClient().newWebSocketBuilder()</span>
<span class="line-added">+                     .buildAsync(server.getURI(), listener)</span>
<span class="line-added">+                     .join();</span>
<span class="line-added">+             try {</span>
<span class="line-added">+                 TimeUnit.SECONDS.sleep(5);</span>
<span class="line-added">+                 List&lt;MockListener.Invocation&gt; inv = listener.invocationsSoFar();</span>
<span class="line-added">+                 // no more invocations after onOpen, onBinary as WebSocket was aborted</span>
<span class="line-added">+                 List&lt;MockListener.Invocation&gt; expected = List.of(</span>
<span class="line-added">+                         MockListener.Invocation.onOpen(webSocket),</span>
<span class="line-added">+                         MockListener.Invocation.onText(webSocket, &quot;&quot;, true));</span>
<span class="line-added">+                 assertEquals(inv, expected);</span>
<span class="line-added">+             } finally {</span>
                  webSocket.abort();
              }
<span class="line-modified">!         }</span>
      }
  
      @Test
      public void onOpenThenOnBinaryThenAbort() throws Exception {
          int[] bytes = new int[]{
                  0x82, 0x00, // opcode=binary, fin=true
                  0x88, 0x00, // opcode=close
          };
<span class="line-modified">!         try (var server = Support.serverWithCannedData(bytes)) {</span>
<span class="line-modified">!             server.open();</span>
<span class="line-modified">!             MockListener listener = new MockListener() {</span>
<span class="line-modified">!                 @Override</span>
<span class="line-modified">!                 protected void onOpen0(WebSocket webSocket) {</span>
<span class="line-modified">!                     // unbounded request</span>
<span class="line-modified">!                     webSocket.request(Long.MAX_VALUE);</span>
<span class="line-modified">!                 }</span>
  
<span class="line-modified">!                 @Override</span>
<span class="line-modified">!                 protected CompletionStage&lt;?&gt; onBinary0(WebSocket webSocket,</span>
<span class="line-modified">!                                                        ByteBuffer message,</span>
<span class="line-modified">!                                                        boolean last) {</span>
<span class="line-added">+                     webSocket.abort();</span>
<span class="line-added">+                     return super.onBinary0(webSocket, message, last);</span>
<span class="line-added">+                 }</span>
<span class="line-added">+             };</span>
<span class="line-added">+             var webSocket = newHttpClient().newWebSocketBuilder()</span>
<span class="line-added">+                     .buildAsync(server.getURI(), listener)</span>
<span class="line-added">+                     .join();</span>
<span class="line-added">+             try {</span>
<span class="line-added">+                 TimeUnit.SECONDS.sleep(5);</span>
<span class="line-added">+                 List&lt;MockListener.Invocation&gt; inv = listener.invocationsSoFar();</span>
<span class="line-added">+                 // no more invocations after onOpen, onBinary as WebSocket was aborted</span>
<span class="line-added">+                 List&lt;MockListener.Invocation&gt; expected = List.of(</span>
<span class="line-added">+                         MockListener.Invocation.onOpen(webSocket),</span>
<span class="line-added">+                         MockListener.Invocation.onBinary(webSocket, ByteBuffer.allocate(0), true));</span>
<span class="line-added">+                 assertEquals(inv, expected);</span>
<span class="line-added">+             } finally {</span>
                  webSocket.abort();
              }
<span class="line-modified">!         }</span>
      }
  
      @Test
      public void onOpenThenOnPingThenAbort() throws Exception {
          int[] bytes = {
                  0x89, 0x00, // opcode=ping
                  0x88, 0x00, // opcode=close
          };
<span class="line-modified">!         try (var server = Support.serverWithCannedData(bytes)) {</span>
<span class="line-modified">!             server.open();</span>
<span class="line-modified">!             MockListener listener = new MockListener() {</span>
<span class="line-modified">!                 @Override</span>
<span class="line-modified">!                 protected void onOpen0(WebSocket webSocket) {</span>
<span class="line-modified">!                     // unbounded request</span>
<span class="line-modified">!                     webSocket.request(Long.MAX_VALUE);</span>
<span class="line-modified">!                 }</span>
  
<span class="line-modified">!                 @Override</span>
<span class="line-modified">!                 protected CompletionStage&lt;?&gt; onPing0(WebSocket webSocket,</span>
<span class="line-modified">!                                                      ByteBuffer message) {</span>
<span class="line-added">+                     webSocket.abort();</span>
<span class="line-added">+                     return super.onPing0(webSocket, message);</span>
<span class="line-added">+                 }</span>
<span class="line-added">+             };</span>
<span class="line-added">+             var webSocket = newHttpClient().newWebSocketBuilder()</span>
<span class="line-added">+                     .buildAsync(server.getURI(), listener)</span>
<span class="line-added">+                     .join();</span>
<span class="line-added">+             try {</span>
<span class="line-added">+                 TimeUnit.SECONDS.sleep(5);</span>
<span class="line-added">+                 List&lt;MockListener.Invocation&gt; inv = listener.invocationsSoFar();</span>
<span class="line-added">+                 // no more invocations after onOpen, onPing as WebSocket was aborted</span>
<span class="line-added">+                 List&lt;MockListener.Invocation&gt; expected = List.of(</span>
<span class="line-added">+                         MockListener.Invocation.onOpen(webSocket),</span>
<span class="line-added">+                         MockListener.Invocation.onPing(webSocket, ByteBuffer.allocate(0)));</span>
<span class="line-added">+                 assertEquals(inv, expected);</span>
<span class="line-added">+             } finally {</span>
                  webSocket.abort();
              }
<span class="line-modified">!         }</span>
      }
  
      @Test
      public void onOpenThenOnPongThenAbort() throws Exception {
          int[] bytes = {
                  0x8a, 0x00, // opcode=pong
                  0x88, 0x00, // opcode=close
          };
<span class="line-modified">!         try (var server = Support.serverWithCannedData(bytes)) {</span>
<span class="line-modified">!             server.open();</span>
<span class="line-modified">!             MockListener listener = new MockListener() {</span>
<span class="line-modified">!                 @Override</span>
<span class="line-modified">!                 protected void onOpen0(WebSocket webSocket) {</span>
<span class="line-modified">!                     // unbounded request</span>
<span class="line-modified">!                     webSocket.request(Long.MAX_VALUE);</span>
<span class="line-modified">!                 }</span>
  
<span class="line-modified">!                 @Override</span>
<span class="line-modified">!                 protected CompletionStage&lt;?&gt; onPong0(WebSocket webSocket,</span>
<span class="line-modified">!                                                      ByteBuffer message) {</span>
<span class="line-added">+                     webSocket.abort();</span>
<span class="line-added">+                     return super.onPong0(webSocket, message);</span>
<span class="line-added">+                 }</span>
<span class="line-added">+             };</span>
<span class="line-added">+             var webSocket = newHttpClient().newWebSocketBuilder()</span>
<span class="line-added">+                     .buildAsync(server.getURI(), listener)</span>
<span class="line-added">+                     .join();</span>
<span class="line-added">+             try {</span>
<span class="line-added">+                 TimeUnit.SECONDS.sleep(5);</span>
<span class="line-added">+                 List&lt;MockListener.Invocation&gt; inv = listener.invocationsSoFar();</span>
<span class="line-added">+                 // no more invocations after onOpen, onPong as WebSocket was aborted</span>
<span class="line-added">+                 List&lt;MockListener.Invocation&gt; expected = List.of(</span>
<span class="line-added">+                         MockListener.Invocation.onOpen(webSocket),</span>
<span class="line-added">+                         MockListener.Invocation.onPong(webSocket, ByteBuffer.allocate(0)));</span>
<span class="line-added">+                 assertEquals(inv, expected);</span>
<span class="line-added">+             } finally {</span>
                  webSocket.abort();
              }
<span class="line-modified">!         }</span>
      }
  
      @Test
      public void onOpenThenOnCloseThenAbort() throws Exception {
          int[] bytes = {
                  0x88, 0x00, // opcode=close
                  0x8a, 0x00, // opcode=pong
          };
<span class="line-modified">!         try (var server = Support.serverWithCannedData(bytes)) {</span>
<span class="line-modified">!             server.open();</span>
<span class="line-modified">!             MockListener listener = new MockListener() {</span>
<span class="line-modified">!                 @Override</span>
<span class="line-modified">!                 protected void onOpen0(WebSocket webSocket) {</span>
<span class="line-modified">!                     // unbounded request</span>
<span class="line-modified">!                     webSocket.request(Long.MAX_VALUE);</span>
<span class="line-modified">!                 }</span>
  
<span class="line-modified">!                 @Override</span>
<span class="line-modified">!                 protected CompletionStage&lt;?&gt; onClose0(WebSocket webSocket,</span>
<span class="line-modified">!                                                       int statusCode,</span>
<span class="line-modified">!                                                       String reason) {</span>
<span class="line-added">+                     webSocket.abort();</span>
<span class="line-added">+                     return super.onClose0(webSocket, statusCode, reason);</span>
<span class="line-added">+                 }</span>
<span class="line-added">+             };</span>
<span class="line-added">+             var webSocket = newHttpClient().newWebSocketBuilder()</span>
<span class="line-added">+                     .buildAsync(server.getURI(), listener)</span>
<span class="line-added">+                     .join();</span>
<span class="line-added">+             try {</span>
<span class="line-added">+                 TimeUnit.SECONDS.sleep(5);</span>
<span class="line-added">+                 List&lt;MockListener.Invocation&gt; inv = listener.invocationsSoFar();</span>
<span class="line-added">+                 // no more invocations after onOpen, onClose</span>
<span class="line-added">+                 List&lt;MockListener.Invocation&gt; expected = List.of(</span>
<span class="line-added">+                         MockListener.Invocation.onOpen(webSocket),</span>
<span class="line-added">+                         MockListener.Invocation.onClose(webSocket, 1005, &quot;&quot;));</span>
<span class="line-added">+                 assertEquals(inv, expected);</span>
<span class="line-added">+             } finally {</span>
                  webSocket.abort();
              }
<span class="line-modified">!         }</span>
      }
  
      @Test
      public void onOpenThenOnErrorThenAbort() throws Exception {
          // A header of 128 bytes long Ping (which is a protocol error)
          int[] badPingHeader = new int[]{0x89, 0x7e, 0x00, 0x80};
          int[] closeMessage = new int[]{0x88, 0x00};
          int[] bytes = new int[badPingHeader.length + 128 + closeMessage.length];
          System.arraycopy(badPingHeader, 0, bytes, 0, badPingHeader.length);
          System.arraycopy(closeMessage, 0, bytes, badPingHeader.length + 128, closeMessage.length);
<span class="line-modified">!         try (var server = Support.serverWithCannedData(bytes)) {</span>
<span class="line-modified">!             server.open();</span>
<span class="line-modified">!             MockListener listener = new MockListener() {</span>
<span class="line-modified">!                 @Override</span>
<span class="line-modified">!                 protected void onOpen0(WebSocket webSocket) {</span>
<span class="line-modified">!                     // unbounded request</span>
<span class="line-modified">!                     webSocket.request(Long.MAX_VALUE);</span>
<span class="line-modified">!                 }</span>
  
<span class="line-modified">!                 @Override</span>
<span class="line-modified">!                 protected void onError0(WebSocket webSocket, Throwable error) {</span>
<span class="line-added">+                     webSocket.abort();</span>
<span class="line-added">+                     super.onError0(webSocket, error);</span>
<span class="line-added">+                 }</span>
<span class="line-added">+             };</span>
<span class="line-added">+             var webSocket = newHttpClient().newWebSocketBuilder()</span>
<span class="line-added">+                     .buildAsync(server.getURI(), listener)</span>
<span class="line-added">+                     .join();</span>
<span class="line-added">+             try {</span>
<span class="line-added">+                 TimeUnit.SECONDS.sleep(5);</span>
<span class="line-added">+                 List&lt;MockListener.Invocation&gt; inv = listener.invocationsSoFar();</span>
<span class="line-added">+                 // no more invocations after onOpen, onError</span>
<span class="line-added">+                 List&lt;MockListener.Invocation&gt; expected = List.of(</span>
<span class="line-added">+                         MockListener.Invocation.onOpen(webSocket),</span>
<span class="line-added">+                         MockListener.Invocation.onError(webSocket, ProtocolException.class));</span>
<span class="line-added">+                 System.out.println(&quot;actual invocations:&quot; + Arrays.toString(inv.toArray()));</span>
<span class="line-added">+                 assertEquals(inv, expected);</span>
<span class="line-added">+             } finally {</span>
                  webSocket.abort();
              }
<span class="line-modified">!         }</span>
      }
  
      @Test
      public void immediateAbort() throws Exception {
          CompletableFuture&lt;Void&gt; messageReceived = new CompletableFuture&lt;&gt;();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 350,67 ***</span>
  
          int[] bytes = new int[]{
                  0x82, 0x00, // opcode=binary, fin=true
                  0x88, 0x00, // opcode=close
          };
<span class="line-modified">!         server = Support.serverWithCannedData(bytes);</span>
<span class="line-modified">!         server.open();</span>
  
<span class="line-modified">!         WebSocket ws = newHttpClient()</span>
<span class="line-modified">!                 .newWebSocketBuilder()</span>
<span class="line-modified">!                 .buildAsync(server.getURI(), listener)</span>
<span class="line-modified">!                 .join();</span>
<span class="line-modified">!         for (int i = 0; i &lt; 3; i++) {</span>
<span class="line-modified">!             System.out.printf(&quot;iteration #%s%n&quot;, i);</span>
<span class="line-modified">!             // after the first abort() each consecutive one must be a no-op,</span>
<span class="line-modified">!             // moreover, query methods should continue to return consistent</span>
<span class="line-modified">!             // values</span>
<span class="line-modified">!             for (int j = 0; j &lt; 3; j++) {</span>
<span class="line-modified">!                 System.out.printf(&quot;abort #%s%n&quot;, j);</span>
                  ws.abort();
<span class="line-removed">-                 assertTrue(ws.isInputClosed());</span>
<span class="line-removed">-                 assertTrue(ws.isOutputClosed());</span>
<span class="line-removed">-                 assertEquals(ws.getSubprotocol(), &quot;&quot;);</span>
<span class="line-removed">-             }</span>
<span class="line-removed">-             // at this point valid requests MUST be a no-op:</span>
<span class="line-removed">-             for (int j = 0; j &lt; 3; j++) {</span>
<span class="line-removed">-                 System.out.printf(&quot;request #%s%n&quot;, j);</span>
<span class="line-removed">-                 ws.request(1);</span>
<span class="line-removed">-                 ws.request(2);</span>
<span class="line-removed">-                 ws.request(8);</span>
<span class="line-removed">-                 ws.request(Integer.MAX_VALUE);</span>
<span class="line-removed">-                 ws.request(Long.MAX_VALUE);</span>
<span class="line-removed">-                 // invalid requests MUST throw IAE:</span>
<span class="line-removed">-                 assertThrows(IAE, () -&gt; ws.request(Integer.MIN_VALUE));</span>
<span class="line-removed">-                 assertThrows(IAE, () -&gt; ws.request(Long.MIN_VALUE));</span>
<span class="line-removed">-                 assertThrows(IAE, () -&gt; ws.request(-1));</span>
<span class="line-removed">-                 assertThrows(IAE, () -&gt; ws.request(0));</span>
              }
          }
<span class="line-removed">-         // even though there is a bunch of messages readily available on the</span>
<span class="line-removed">-         // wire we shouldn&#39;t have received any of them as we aborted before</span>
<span class="line-removed">-         // the first request</span>
<span class="line-removed">-         try {</span>
<span class="line-removed">-             messageReceived.get(5, TimeUnit.SECONDS);</span>
<span class="line-removed">-             fail();</span>
<span class="line-removed">-         } catch (TimeoutException expected) {</span>
<span class="line-removed">-             System.out.println(&quot;Finished waiting&quot;);</span>
<span class="line-removed">-         }</span>
<span class="line-removed">-         for (int i = 0; i &lt; 3; i++) {</span>
<span class="line-removed">-             System.out.printf(&quot;send #%s%n&quot;, i);</span>
<span class="line-removed">-             Support.assertFails(IOE, ws.sendText(&quot;text!&quot;, false));</span>
<span class="line-removed">-             Support.assertFails(IOE, ws.sendText(&quot;text!&quot;, true));</span>
<span class="line-removed">-             Support.assertFails(IOE, ws.sendBinary(ByteBuffer.allocate(16), false));</span>
<span class="line-removed">-             Support.assertFails(IOE, ws.sendBinary(ByteBuffer.allocate(16), true));</span>
<span class="line-removed">-             Support.assertFails(IOE, ws.sendPing(ByteBuffer.allocate(16)));</span>
<span class="line-removed">-             Support.assertFails(IOE, ws.sendPong(ByteBuffer.allocate(16)));</span>
<span class="line-removed">-             Support.assertFails(IOE, ws.sendClose(NORMAL_CLOSURE, &quot;a reason&quot;));</span>
<span class="line-removed">-             assertThrows(NPE, () -&gt; ws.sendText(null, false));</span>
<span class="line-removed">-             assertThrows(NPE, () -&gt; ws.sendText(null, true));</span>
<span class="line-removed">-             assertThrows(NPE, () -&gt; ws.sendBinary(null, false));</span>
<span class="line-removed">-             assertThrows(NPE, () -&gt; ws.sendBinary(null, true));</span>
<span class="line-removed">-             assertThrows(NPE, () -&gt; ws.sendPing(null));</span>
<span class="line-removed">-             assertThrows(NPE, () -&gt; ws.sendPong(null));</span>
<span class="line-removed">-             assertThrows(NPE, () -&gt; ws.sendClose(NORMAL_CLOSURE, null));</span>
<span class="line-removed">-         }</span>
      }
  }
<span class="line-new-header">--- 376,72 ---</span>
  
          int[] bytes = new int[]{
                  0x82, 0x00, // opcode=binary, fin=true
                  0x88, 0x00, // opcode=close
          };
<span class="line-modified">!         try (var server = Support.serverWithCannedData(bytes)) {</span>
<span class="line-modified">!             server.open();</span>
  
<span class="line-modified">!             WebSocket ws = newHttpClient()</span>
<span class="line-modified">!                     .newWebSocketBuilder()</span>
<span class="line-modified">!                     .buildAsync(server.getURI(), listener)</span>
<span class="line-modified">!                     .join();</span>
<span class="line-modified">!             try {</span>
<span class="line-modified">!                 for (int i = 0; i &lt; 3; i++) {</span>
<span class="line-modified">!                     System.out.printf(&quot;iteration #%s%n&quot;, i);</span>
<span class="line-modified">!                     // after the first abort() each consecutive one must be a no-op,</span>
<span class="line-modified">!                     // moreover, query methods should continue to return consistent</span>
<span class="line-modified">!                     // values</span>
<span class="line-modified">!                     for (int j = 0; j &lt; 3; j++) {</span>
<span class="line-added">+                         System.out.printf(&quot;abort #%s%n&quot;, j);</span>
<span class="line-added">+                         ws.abort();</span>
<span class="line-added">+                         assertTrue(ws.isInputClosed());</span>
<span class="line-added">+                         assertTrue(ws.isOutputClosed());</span>
<span class="line-added">+                         assertEquals(ws.getSubprotocol(), &quot;&quot;);</span>
<span class="line-added">+                     }</span>
<span class="line-added">+                     // at this point valid requests MUST be a no-op:</span>
<span class="line-added">+                     for (int j = 0; j &lt; 3; j++) {</span>
<span class="line-added">+                         System.out.printf(&quot;request #%s%n&quot;, j);</span>
<span class="line-added">+                         ws.request(1);</span>
<span class="line-added">+                         ws.request(2);</span>
<span class="line-added">+                         ws.request(8);</span>
<span class="line-added">+                         ws.request(Integer.MAX_VALUE);</span>
<span class="line-added">+                         ws.request(Long.MAX_VALUE);</span>
<span class="line-added">+                         // invalid requests MUST throw IAE:</span>
<span class="line-added">+                         assertThrows(IAE, () -&gt; ws.request(Integer.MIN_VALUE));</span>
<span class="line-added">+                         assertThrows(IAE, () -&gt; ws.request(Long.MIN_VALUE));</span>
<span class="line-added">+                         assertThrows(IAE, () -&gt; ws.request(-1));</span>
<span class="line-added">+                         assertThrows(IAE, () -&gt; ws.request(0));</span>
<span class="line-added">+                     }</span>
<span class="line-added">+                 }</span>
<span class="line-added">+                 // even though there is a bunch of messages readily available on the</span>
<span class="line-added">+                 // wire we shouldn&#39;t have received any of them as we aborted before</span>
<span class="line-added">+                 // the first request</span>
<span class="line-added">+                 try {</span>
<span class="line-added">+                     messageReceived.get(5, TimeUnit.SECONDS);</span>
<span class="line-added">+                     fail();</span>
<span class="line-added">+                 } catch (TimeoutException expected) {</span>
<span class="line-added">+                     System.out.println(&quot;Finished waiting&quot;);</span>
<span class="line-added">+                 }</span>
<span class="line-added">+                 for (int i = 0; i &lt; 3; i++) {</span>
<span class="line-added">+                     System.out.printf(&quot;send #%s%n&quot;, i);</span>
<span class="line-added">+                     Support.assertFails(IOE, ws.sendText(&quot;text!&quot;, false));</span>
<span class="line-added">+                     Support.assertFails(IOE, ws.sendText(&quot;text!&quot;, true));</span>
<span class="line-added">+                     Support.assertFails(IOE, ws.sendBinary(ByteBuffer.allocate(16), false));</span>
<span class="line-added">+                     Support.assertFails(IOE, ws.sendBinary(ByteBuffer.allocate(16), true));</span>
<span class="line-added">+                     Support.assertFails(IOE, ws.sendPing(ByteBuffer.allocate(16)));</span>
<span class="line-added">+                     Support.assertFails(IOE, ws.sendPong(ByteBuffer.allocate(16)));</span>
<span class="line-added">+                     Support.assertFails(IOE, ws.sendClose(NORMAL_CLOSURE, &quot;a reason&quot;));</span>
<span class="line-added">+                     assertThrows(NPE, () -&gt; ws.sendText(null, false));</span>
<span class="line-added">+                     assertThrows(NPE, () -&gt; ws.sendText(null, true));</span>
<span class="line-added">+                     assertThrows(NPE, () -&gt; ws.sendBinary(null, false));</span>
<span class="line-added">+                     assertThrows(NPE, () -&gt; ws.sendBinary(null, true));</span>
<span class="line-added">+                     assertThrows(NPE, () -&gt; ws.sendPing(null));</span>
<span class="line-added">+                     assertThrows(NPE, () -&gt; ws.sendPong(null));</span>
<span class="line-added">+                     assertThrows(NPE, () -&gt; ws.sendClose(NORMAL_CLOSURE, null));</span>
<span class="line-added">+                 }</span>
<span class="line-added">+             } finally {</span>
                  ws.abort();
              }
          }
      }
  }
</pre>
<center><a href="../ssltest/Server.java.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="AutomaticPong.java.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
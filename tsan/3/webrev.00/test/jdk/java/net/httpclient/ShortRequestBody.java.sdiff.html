<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff test/jdk/java/net/httpclient/ShortRequestBody.java</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
<body>
<center><a href="ProxyTest.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="ShortResponseBody.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>test/jdk/java/net/httpclient/ShortRequestBody.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2015, 2018, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 import java.io.IOException;
 25 import java.io.InputStream;
 26 import java.io.OutputStream;
 27 import java.io.UncheckedIOException;
 28 import java.net.InetAddress;
 29 import java.net.InetSocketAddress;
 30 import java.net.ServerSocket;
 31 import java.net.Socket;

 32 import java.net.URI;
 33 import java.net.http.HttpClient;
 34 import java.net.http.HttpRequest;
 35 import java.net.http.HttpRequest.BodyPublishers;
 36 import java.net.http.HttpResponse;
 37 import java.net.http.HttpResponse.BodyHandlers;
 38 import java.net.http.HttpTimeoutException;
 39 import java.nio.file.Files;
 40 import java.nio.file.Path;
 41 import java.nio.file.Paths;
 42 import java.nio.ByteBuffer;
 43 import java.util.ArrayList;
 44 import java.util.List;
 45 import java.util.concurrent.CompletableFuture;
 46 import java.util.concurrent.ExecutionException;
 47 import java.util.concurrent.Flow;
 48 import java.util.concurrent.TimeoutException;
 49 import java.util.concurrent.TimeUnit;
 50 import java.util.function.Supplier;
 51 import static java.lang.System.err;
</pre>
<hr />
<pre>
 59  *          reported by the body publisher
 60  * @run main/othervm ShortRequestBody
 61  */
 62 
 63 public class ShortRequestBody {
 64 
 65     static final Path testSrc = Paths.get(System.getProperty(&quot;test.src&quot;, &quot;.&quot;));
 66 
 67     // Some body types ( sources ) for testing.
 68     static final String STRING_BODY = &quot;Hello world&quot;;
 69     static final byte[] BYTE_ARRAY_BODY = new byte[] {
 70         (byte)0xCA, (byte)0xFE, (byte)0xBA, (byte)0xBE };
 71     static final Path FILE_BODY = testSrc.resolve(&quot;docs&quot;).resolve(&quot;files&quot;).resolve(&quot;foo.txt&quot;);
 72 
 73     // Body lengths and offsets ( amount to be wrong by ), to make coordination
 74     // between client and server easier.
 75     static final int[] BODY_LENGTHS = new int[] { STRING_BODY.length(),
 76                                                   BYTE_ARRAY_BODY.length,
 77                                                   fileSize(FILE_BODY) };
 78     static final int[] BODY_OFFSETS = new int[] { 0, +1, -1, +2, -2, +3, -3 };

 79 
 80     // A delegating Body Publisher. Subtypes will have a concrete body type.
 81     static abstract class AbstractDelegateRequestBody
 82             implements HttpRequest.BodyPublisher {
 83 
 84         final HttpRequest.BodyPublisher delegate;
 85         final long contentLength;
 86 
 87         AbstractDelegateRequestBody(HttpRequest.BodyPublisher delegate,
 88                                     long contentLength) {
 89             this.delegate = delegate;
 90             this.contentLength = contentLength;
 91         }
 92 
 93         @Override
 94         public void subscribe(Flow.Subscriber&lt;? super ByteBuffer&gt; subscriber) {
 95             delegate.subscribe(subscriber);
 96         }
 97 
 98         @Override
</pre>
<hr />
<pre>
117     }
118 
119     static class FileRequestBody extends AbstractDelegateRequestBody {
120         FileRequestBody(Path path, int additionalLength) throws IOException {
121             super(BodyPublishers.ofFile(path),
122                   Files.size(path) + additionalLength);
123         }
124     }
125 
126     // ---
127 
128     public static void main(String[] args) throws Exception {
129         HttpClient sharedClient = HttpClient.newHttpClient();
130         List&lt;Supplier&lt;HttpClient&gt;&gt; clientSuppliers = new ArrayList&lt;&gt;();
131         clientSuppliers.add(() -&gt; HttpClient.newHttpClient());
132         clientSuppliers.add(() -&gt; sharedClient);
133 
134         try (Server server = new Server()) {
135             for (Supplier&lt;HttpClient&gt; cs : clientSuppliers) {
136                 err.println(&quot;\n---- next supplier ----\n&quot;);
<span class="line-modified">137                 URI uri = new URI(&quot;http://localhost:&quot; + server.getPort() + &quot;/&quot;);</span>
138 
139                 // sanity ( 6 requests to keep client and server offsets easy to workout )
140                 success(cs, uri, new StringRequestBody(STRING_BODY, 0));
141                 success(cs, uri, new ByteArrayRequestBody(BYTE_ARRAY_BODY, 0));
142                 success(cs, uri, new FileRequestBody(FILE_BODY, 0));
143                 success(cs, uri, new StringRequestBody(STRING_BODY, 0));
144                 success(cs, uri, new ByteArrayRequestBody(BYTE_ARRAY_BODY, 0));
145                 success(cs, uri, new FileRequestBody(FILE_BODY, 0));
146 
147                 for (int i = 1; i &lt; BODY_OFFSETS.length; i++) {
148                     failureBlocking(cs, uri, new StringRequestBody(STRING_BODY, BODY_OFFSETS[i]));
149                     failureBlocking(cs, uri, new ByteArrayRequestBody(BYTE_ARRAY_BODY, BODY_OFFSETS[i]));
150                     failureBlocking(cs, uri, new FileRequestBody(FILE_BODY, BODY_OFFSETS[i]));
151 
152                     failureNonBlocking(cs, uri, new StringRequestBody(STRING_BODY, BODY_OFFSETS[i]));
153                     failureNonBlocking(cs, uri, new ByteArrayRequestBody(BYTE_ARRAY_BODY, BODY_OFFSETS[i]));
154                     failureNonBlocking(cs, uri, new FileRequestBody(FILE_BODY, BODY_OFFSETS[i]));
155                 }
156             }
157         }
</pre>
<hr />
<pre>
231 
232         private final ServerSocket ss;
233         private volatile boolean closed;
234 
235         Server() throws IOException {
236             super(&quot;Test-Server&quot;);
237             ss = new ServerSocket();
238             ss.setReuseAddress(false);
239             ss.bind(new InetSocketAddress(InetAddress.getLoopbackAddress(), 0));
240             this.start();
241         }
242 
243         int getPort() { return ss.getLocalPort(); }
244 
245         @Override
246         public void run() {
247             int count = 0;
248             int offset = 0;
249 
250             while (!closed) {

251                 try (Socket s = ss.accept()) {
252                     err.println(&quot;Server: got connection&quot;);
253                     InputStream is = s.getInputStream();
<span class="line-modified">254                     readRequestHeaders(is);</span>








255                     byte[] ba = new byte[1024];
256 
257                     int length = BODY_LENGTHS[count % 3];
258                     length += BODY_OFFSETS[offset];
259                     err.println(&quot;Server: count=&quot; + count + &quot;, offset=&quot; + offset);
260                     err.println(&quot;Server: expecting &quot; +length+ &quot; bytes&quot;);
<span class="line-modified">261                     int read = is.readNBytes(ba, 0, length);</span>
<span class="line-modified">262                     err.println(&quot;Server: actually read &quot; + read + &quot; bytes&quot;);</span>
<span class="line-modified">263 </span>
<span class="line-modified">264                     // Update the counts before replying, to prevent the</span>
<span class="line-modified">265                     // client-side racing reset with this thread.</span>
<span class="line-modified">266                     count++;</span>
<span class="line-modified">267                     if (count % 6 == 0) // 6 is the number of failure requests per offset</span>
<span class="line-modified">268                         offset++;</span>
<span class="line-modified">269                     if (count % 42 == 0) {</span>
<span class="line-modified">270                         count = 0;  // reset, for second iteration</span>
<span class="line-modified">271                         offset = 0;</span>



272                     }
<span class="line-removed">273 </span>
274                     if (read &lt; length) {
275                         // no need to reply, client has already closed
276                         // ensure closed
277                         if (is.read() != -1)
<span class="line-modified">278                             new AssertionError(&quot;Unexpected read&quot;);</span>
279                     } else {
280                         OutputStream os = s.getOutputStream();
281                         err.println(&quot;Server: writing &quot;
282                                 + RESPONSE.getBytes(US_ASCII).length + &quot; bytes&quot;);
283                         os.write(RESPONSE.getBytes(US_ASCII));
284                     }
<span class="line-modified">285 </span>
<span class="line-modified">286                 } catch (IOException e) {</span>
<span class="line-modified">287                     if (!closed)</span>
<span class="line-modified">288                         System.out.println(&quot;Unexpected&quot; + e);</span>

289                 }
290             }
291         }
292 
293         @Override
294         public void close() {
295             if (closed)
296                 return;
297             closed = true;
298             try {
299                 ss.close();
300             } catch (IOException e) {
301                 throw new UncheckedIOException(&quot;Unexpected&quot;, e);
302             }
303         }
304     }
305 
306     static final byte[] requestEnd = new byte[] {&#39;\r&#39;, &#39;\n&#39;, &#39;\r&#39;, &#39;\n&#39; };
307 
308     // Read until the end of a HTTP request headers
<span class="line-modified">309     static void readRequestHeaders(InputStream is) throws IOException {</span>
<span class="line-modified">310         int requestEndCount = 0, r;</span>

311         while ((r = is.read()) != -1) {




312             if (r == requestEnd[requestEndCount]) {
313                 requestEndCount++;
314                 if (requestEndCount == 4) {
315                     break;
316                 }
317             } else {
318                 requestEndCount = 0;
319             }
320         }





321     }
322 
323     static int fileSize(Path p) {
324         try { return (int) Files.size(p); }
325         catch (IOException x) { throw new UncheckedIOException(x); }
326     }
327 
328     static boolean check(boolean cond, Throwable t, Object... failedArgs) {
329         if (cond)
330             return true;
331         // We are going to fail...
332         StringBuilder sb = new StringBuilder();
333         for (Object o : failedArgs)
334                 sb.append(o);
335         throw new RuntimeException(sb.toString(), t);
336     }
337 }
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2015, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 import java.io.IOException;
 25 import java.io.InputStream;
 26 import java.io.OutputStream;
 27 import java.io.UncheckedIOException;
 28 import java.net.InetAddress;
 29 import java.net.InetSocketAddress;
 30 import java.net.ServerSocket;
 31 import java.net.Socket;
<span class="line-added"> 32 import java.net.SocketException;</span>
 33 import java.net.URI;
 34 import java.net.http.HttpClient;
 35 import java.net.http.HttpRequest;
 36 import java.net.http.HttpRequest.BodyPublishers;
 37 import java.net.http.HttpResponse;
 38 import java.net.http.HttpResponse.BodyHandlers;
 39 import java.net.http.HttpTimeoutException;
 40 import java.nio.file.Files;
 41 import java.nio.file.Path;
 42 import java.nio.file.Paths;
 43 import java.nio.ByteBuffer;
 44 import java.util.ArrayList;
 45 import java.util.List;
 46 import java.util.concurrent.CompletableFuture;
 47 import java.util.concurrent.ExecutionException;
 48 import java.util.concurrent.Flow;
 49 import java.util.concurrent.TimeoutException;
 50 import java.util.concurrent.TimeUnit;
 51 import java.util.function.Supplier;
 52 import static java.lang.System.err;
</pre>
<hr />
<pre>
 60  *          reported by the body publisher
 61  * @run main/othervm ShortRequestBody
 62  */
 63 
 64 public class ShortRequestBody {
 65 
 66     static final Path testSrc = Paths.get(System.getProperty(&quot;test.src&quot;, &quot;.&quot;));
 67 
 68     // Some body types ( sources ) for testing.
 69     static final String STRING_BODY = &quot;Hello world&quot;;
 70     static final byte[] BYTE_ARRAY_BODY = new byte[] {
 71         (byte)0xCA, (byte)0xFE, (byte)0xBA, (byte)0xBE };
 72     static final Path FILE_BODY = testSrc.resolve(&quot;docs&quot;).resolve(&quot;files&quot;).resolve(&quot;foo.txt&quot;);
 73 
 74     // Body lengths and offsets ( amount to be wrong by ), to make coordination
 75     // between client and server easier.
 76     static final int[] BODY_LENGTHS = new int[] { STRING_BODY.length(),
 77                                                   BYTE_ARRAY_BODY.length,
 78                                                   fileSize(FILE_BODY) };
 79     static final int[] BODY_OFFSETS = new int[] { 0, +1, -1, +2, -2, +3, -3 };
<span class="line-added"> 80     static final String MARKER = &quot;ShortRequestBody&quot;;</span>
 81 
 82     // A delegating Body Publisher. Subtypes will have a concrete body type.
 83     static abstract class AbstractDelegateRequestBody
 84             implements HttpRequest.BodyPublisher {
 85 
 86         final HttpRequest.BodyPublisher delegate;
 87         final long contentLength;
 88 
 89         AbstractDelegateRequestBody(HttpRequest.BodyPublisher delegate,
 90                                     long contentLength) {
 91             this.delegate = delegate;
 92             this.contentLength = contentLength;
 93         }
 94 
 95         @Override
 96         public void subscribe(Flow.Subscriber&lt;? super ByteBuffer&gt; subscriber) {
 97             delegate.subscribe(subscriber);
 98         }
 99 
100         @Override
</pre>
<hr />
<pre>
119     }
120 
121     static class FileRequestBody extends AbstractDelegateRequestBody {
122         FileRequestBody(Path path, int additionalLength) throws IOException {
123             super(BodyPublishers.ofFile(path),
124                   Files.size(path) + additionalLength);
125         }
126     }
127 
128     // ---
129 
130     public static void main(String[] args) throws Exception {
131         HttpClient sharedClient = HttpClient.newHttpClient();
132         List&lt;Supplier&lt;HttpClient&gt;&gt; clientSuppliers = new ArrayList&lt;&gt;();
133         clientSuppliers.add(() -&gt; HttpClient.newHttpClient());
134         clientSuppliers.add(() -&gt; sharedClient);
135 
136         try (Server server = new Server()) {
137             for (Supplier&lt;HttpClient&gt; cs : clientSuppliers) {
138                 err.println(&quot;\n---- next supplier ----\n&quot;);
<span class="line-modified">139                 URI uri = new URI(&quot;http://localhost:&quot; + server.getPort() + &quot;/&quot; + MARKER);</span>
140 
141                 // sanity ( 6 requests to keep client and server offsets easy to workout )
142                 success(cs, uri, new StringRequestBody(STRING_BODY, 0));
143                 success(cs, uri, new ByteArrayRequestBody(BYTE_ARRAY_BODY, 0));
144                 success(cs, uri, new FileRequestBody(FILE_BODY, 0));
145                 success(cs, uri, new StringRequestBody(STRING_BODY, 0));
146                 success(cs, uri, new ByteArrayRequestBody(BYTE_ARRAY_BODY, 0));
147                 success(cs, uri, new FileRequestBody(FILE_BODY, 0));
148 
149                 for (int i = 1; i &lt; BODY_OFFSETS.length; i++) {
150                     failureBlocking(cs, uri, new StringRequestBody(STRING_BODY, BODY_OFFSETS[i]));
151                     failureBlocking(cs, uri, new ByteArrayRequestBody(BYTE_ARRAY_BODY, BODY_OFFSETS[i]));
152                     failureBlocking(cs, uri, new FileRequestBody(FILE_BODY, BODY_OFFSETS[i]));
153 
154                     failureNonBlocking(cs, uri, new StringRequestBody(STRING_BODY, BODY_OFFSETS[i]));
155                     failureNonBlocking(cs, uri, new ByteArrayRequestBody(BYTE_ARRAY_BODY, BODY_OFFSETS[i]));
156                     failureNonBlocking(cs, uri, new FileRequestBody(FILE_BODY, BODY_OFFSETS[i]));
157                 }
158             }
159         }
</pre>
<hr />
<pre>
233 
234         private final ServerSocket ss;
235         private volatile boolean closed;
236 
237         Server() throws IOException {
238             super(&quot;Test-Server&quot;);
239             ss = new ServerSocket();
240             ss.setReuseAddress(false);
241             ss.bind(new InetSocketAddress(InetAddress.getLoopbackAddress(), 0));
242             this.start();
243         }
244 
245         int getPort() { return ss.getLocalPort(); }
246 
247         @Override
248         public void run() {
249             int count = 0;
250             int offset = 0;
251 
252             while (!closed) {
<span class="line-added">253                 err.println(&quot;Server: waiting for connection&quot;);</span>
254                 try (Socket s = ss.accept()) {
255                     err.println(&quot;Server: got connection&quot;);
256                     InputStream is = s.getInputStream();
<span class="line-modified">257                     try {</span>
<span class="line-added">258                         String headers = readRequestHeaders(is);</span>
<span class="line-added">259                         if (headers == null) continue;</span>
<span class="line-added">260                     } catch (SocketException ex) {</span>
<span class="line-added">261                         err.println(&quot;Ignoring unexpected exception while reading headers: &quot; + ex);</span>
<span class="line-added">262                         ex.printStackTrace(err);</span>
<span class="line-added">263                         // proceed in order to update count etc..., even though</span>
<span class="line-added">264                         // we know that read() will fail;</span>
<span class="line-added">265                     }</span>
266                     byte[] ba = new byte[1024];
267 
268                     int length = BODY_LENGTHS[count % 3];
269                     length += BODY_OFFSETS[offset];
270                     err.println(&quot;Server: count=&quot; + count + &quot;, offset=&quot; + offset);
271                     err.println(&quot;Server: expecting &quot; +length+ &quot; bytes&quot;);
<span class="line-modified">272                     int read = 0;</span>
<span class="line-modified">273                     try {</span>
<span class="line-modified">274                         read = is.readNBytes(ba, 0, length);</span>
<span class="line-modified">275                         err.println(&quot;Server: actually read &quot; + read + &quot; bytes&quot;);</span>
<span class="line-modified">276                     } finally {</span>
<span class="line-modified">277                         // Update the counts before replying, to prevent the</span>
<span class="line-modified">278                         // client-side racing reset with this thread.</span>
<span class="line-modified">279                         count++;</span>
<span class="line-modified">280                         if (count % 6 == 0) // 6 is the number of failure requests per offset</span>
<span class="line-modified">281                             offset++;</span>
<span class="line-modified">282                         if (count % 42 == 0) {</span>
<span class="line-added">283                             count = 0;  // reset, for second iteration</span>
<span class="line-added">284                             offset = 0;</span>
<span class="line-added">285                         }</span>
286                     }

287                     if (read &lt; length) {
288                         // no need to reply, client has already closed
289                         // ensure closed
290                         if (is.read() != -1)
<span class="line-modified">291                             new AssertionError(&quot;Unexpected read: &quot; + read);</span>
292                     } else {
293                         OutputStream os = s.getOutputStream();
294                         err.println(&quot;Server: writing &quot;
295                                 + RESPONSE.getBytes(US_ASCII).length + &quot; bytes&quot;);
296                         os.write(RESPONSE.getBytes(US_ASCII));
297                     }
<span class="line-modified">298                 } catch (Throwable e) {</span>
<span class="line-modified">299                     if (!closed) {</span>
<span class="line-modified">300                         err.println(&quot;Unexpected: &quot; + e);</span>
<span class="line-modified">301                         e.printStackTrace();</span>
<span class="line-added">302                     }</span>
303                 }
304             }
305         }
306 
307         @Override
308         public void close() {
309             if (closed)
310                 return;
311             closed = true;
312             try {
313                 ss.close();
314             } catch (IOException e) {
315                 throw new UncheckedIOException(&quot;Unexpected&quot;, e);
316             }
317         }
318     }
319 
320     static final byte[] requestEnd = new byte[] {&#39;\r&#39;, &#39;\n&#39;, &#39;\r&#39;, &#39;\n&#39; };
321 
322     // Read until the end of a HTTP request headers
<span class="line-modified">323     static String readRequestHeaders(InputStream is) throws IOException {</span>
<span class="line-modified">324         int requestEndCount = 0, r, eol = -1;</span>
<span class="line-added">325         StringBuilder headers = new StringBuilder();</span>
326         while ((r = is.read()) != -1) {
<span class="line-added">327             if (r == &#39;\r&#39; &amp;&amp; eol &lt; 0) {</span>
<span class="line-added">328                 eol = headers.length();</span>
<span class="line-added">329             }</span>
<span class="line-added">330             headers.append((char) r);</span>
331             if (r == requestEnd[requestEndCount]) {
332                 requestEndCount++;
333                 if (requestEndCount == 4) {
334                     break;
335                 }
336             } else {
337                 requestEndCount = 0;
338             }
339         }
<span class="line-added">340 </span>
<span class="line-added">341         if (eol &lt;= 0) return null;</span>
<span class="line-added">342         String requestLine = headers.toString().substring(0, eol);</span>
<span class="line-added">343         if (!requestLine.contains(MARKER)) return null;</span>
<span class="line-added">344         return headers.toString();</span>
345     }
346 
347     static int fileSize(Path p) {
348         try { return (int) Files.size(p); }
349         catch (IOException x) { throw new UncheckedIOException(x); }
350     }
351 
352     static boolean check(boolean cond, Throwable t, Object... failedArgs) {
353         if (cond)
354             return true;
355         // We are going to fail...
356         StringBuilder sb = new StringBuilder();
357         for (Object o : failedArgs)
358                 sb.append(o);
359         throw new RuntimeException(sb.toString(), t);
360     }
361 }
</pre>
</td>
</tr>
</table>
<center><a href="ProxyTest.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="ShortResponseBody.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
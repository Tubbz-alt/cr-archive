<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames test/jdk/java/net/httpclient/DigestEchoServer.java</title>
    <link rel="stylesheet" href="../../../../../style.css" />
    <script type="text/javascript" src="../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (c) 2018, 2019, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  */
  23 
  24 import com.sun.net.httpserver.BasicAuthenticator;
  25 import com.sun.net.httpserver.HttpServer;
  26 import com.sun.net.httpserver.HttpsConfigurator;
  27 import com.sun.net.httpserver.HttpsParameters;
  28 import com.sun.net.httpserver.HttpsServer;
<a name="1" id="anc1"></a><span class="line-added">  29 </span>
<span class="line-added">  30 import java.io.Closeable;</span>
  31 import java.io.IOException;
  32 import java.io.InputStream;
  33 import java.io.OutputStream;
  34 import java.io.OutputStreamWriter;
  35 import java.io.PrintWriter;
  36 import java.io.Writer;
  37 import java.math.BigInteger;
  38 import java.net.Authenticator;
  39 import java.net.HttpURLConnection;
  40 import java.net.InetAddress;
  41 import java.net.InetSocketAddress;
  42 import java.net.MalformedURLException;
  43 import java.net.PasswordAuthentication;
  44 import java.net.ServerSocket;
  45 import java.net.Socket;
  46 import java.net.StandardSocketOptions;
  47 import java.net.URI;
  48 import java.net.URISyntaxException;
  49 import java.net.URL;
  50 import java.nio.charset.StandardCharsets;
  51 import java.security.MessageDigest;
  52 import java.security.NoSuchAlgorithmException;
  53 import java.time.Instant;
  54 import java.util.ArrayList;
  55 import java.util.Arrays;
  56 import java.util.Base64;
  57 import java.util.List;
  58 import java.util.Locale;
  59 import java.util.Objects;
  60 import java.util.Optional;
  61 import java.util.Random;
  62 import java.util.StringTokenizer;
  63 import java.util.concurrent.CompletableFuture;
  64 import java.util.concurrent.CopyOnWriteArrayList;
  65 import java.util.concurrent.atomic.AtomicInteger;
  66 import java.util.stream.Collectors;
  67 import java.util.stream.Stream;
  68 import javax.net.ssl.SSLContext;
  69 import sun.net.www.HeaderParser;
  70 import java.net.http.HttpClient.Version;
  71 
  72 /**
  73  * A simple HTTP server that supports Basic or Digest authentication.
  74  * By default this server will echo back whatever is present
  75  * in the request body. Note that the Digest authentication is
  76  * a test implementation implemented only for tests purposes.
  77  * @author danielfuchs
  78  */
  79 public abstract class DigestEchoServer implements HttpServerAdapters {
  80 
  81     public static final boolean DEBUG =
  82             Boolean.parseBoolean(System.getProperty(&quot;test.debug&quot;, &quot;false&quot;));
  83     public static final boolean NO_LINGER =
  84             Boolean.parseBoolean(System.getProperty(&quot;test.nolinger&quot;, &quot;false&quot;));
<a name="2" id="anc2"></a><span class="line-added">  85     public static final boolean TUNNEL_REQUIRES_HOST =</span>
<span class="line-added">  86             Boolean.parseBoolean(System.getProperty(&quot;test.requiresHost&quot;, &quot;false&quot;));</span>
  87     public enum HttpAuthType {
  88         SERVER, PROXY, SERVER307, PROXY305
  89         /* add PROXY_AND_SERVER and SERVER_PROXY_NONE */
  90     };
  91     public enum HttpAuthSchemeType { NONE, BASICSERVER, BASIC, DIGEST };
  92     public static final HttpAuthType DEFAULT_HTTP_AUTH_TYPE = HttpAuthType.SERVER;
  93     public static final String DEFAULT_PROTOCOL_TYPE = &quot;https&quot;;
  94     public static final HttpAuthSchemeType DEFAULT_SCHEME_TYPE = HttpAuthSchemeType.DIGEST;
  95 
  96     public static class HttpTestAuthenticator extends Authenticator {
  97         private final String realm;
  98         private final String username;
  99         // Used to prevent incrementation of &#39;count&#39; when calling the
 100         // authenticator from the server side.
 101         private final ThreadLocal&lt;Boolean&gt; skipCount = new ThreadLocal&lt;&gt;();
 102         // count will be incremented every time getPasswordAuthentication()
 103         // is called from the client side.
 104         final AtomicInteger count = new AtomicInteger();
 105 
 106         public HttpTestAuthenticator(String realm, String username) {
 107             this.realm = realm;
 108             this.username = username;
 109         }
 110         @Override
 111         protected PasswordAuthentication getPasswordAuthentication() {
 112             if (skipCount.get() == null || skipCount.get().booleanValue() == false) {
 113                 System.out.println(&quot;Authenticator called: &quot; + count.incrementAndGet());
 114             }
 115             return new PasswordAuthentication(getUserName(),
 116                     new char[] {&#39;d&#39;,&#39;e&#39;,&#39;n&#39;, &#39;t&#39;});
 117         }
 118         // Called by the server side to get the password of the user
 119         // being authentified.
 120         public final char[] getPassword(String user) {
 121             if (user.equals(username)) {
 122                 skipCount.set(Boolean.TRUE);
 123                 try {
 124                     return getPasswordAuthentication().getPassword();
 125                 } finally {
 126                     skipCount.set(Boolean.FALSE);
 127                 }
 128             }
 129             throw new SecurityException(&quot;User unknown: &quot; + user);
 130         }
 131         public final String getUserName() {
 132             return username;
 133         }
 134         public final String getRealm() {
 135             return realm;
 136         }
 137     }
 138 
 139     public static final HttpTestAuthenticator AUTHENTICATOR;
 140     static {
 141         AUTHENTICATOR = new HttpTestAuthenticator(&quot;earth&quot;, &quot;arthur&quot;);
 142     }
 143 
 144 
 145     final HttpTestServer       serverImpl; // this server endpoint
 146     final DigestEchoServer     redirect;   // the target server where to redirect 3xx
 147     final HttpTestHandler      delegate;   // unused
 148     final String               key;
 149 
 150     DigestEchoServer(String key,
 151                              HttpTestServer server,
 152                              DigestEchoServer target,
 153                              HttpTestHandler delegate) {
 154         this.key = key;
 155         this.serverImpl = server;
 156         this.redirect = target;
 157         this.delegate = delegate;
 158     }
 159 
 160     public static void main(String[] args)
 161             throws IOException {
 162 
 163         DigestEchoServer server = create(Version.HTTP_1_1,
 164                 DEFAULT_PROTOCOL_TYPE,
 165                 DEFAULT_HTTP_AUTH_TYPE,
 166                 AUTHENTICATOR,
 167                 DEFAULT_SCHEME_TYPE);
 168         try {
 169             System.out.println(&quot;Server created at &quot; + server.getAddress());
 170             System.out.println(&quot;Strike &lt;Return&gt; to exit&quot;);
 171             System.in.read();
 172         } finally {
 173             System.out.println(&quot;stopping server&quot;);
 174             server.stop();
 175         }
 176     }
 177 
 178     private static String toString(HttpTestRequestHeaders headers) {
 179         return headers.entrySet().stream()
 180                 .map((e) -&gt; e.getKey() + &quot;: &quot; + e.getValue())
 181                 .collect(Collectors.joining(&quot;\n&quot;));
 182     }
 183 
 184     public static DigestEchoServer create(Version version,
 185                                           String protocol,
 186                                           HttpAuthType authType,
 187                                           HttpAuthSchemeType schemeType)
 188             throws IOException {
 189         return create(version, protocol, authType, AUTHENTICATOR, schemeType);
 190     }
 191 
 192     public static DigestEchoServer create(Version version,
 193                                           String protocol,
 194                                           HttpAuthType authType,
 195                                           HttpTestAuthenticator auth,
 196                                           HttpAuthSchemeType schemeType)
 197             throws IOException {
 198         return create(version, protocol, authType, auth, schemeType, null);
 199     }
 200 
 201     public static DigestEchoServer create(Version version,
 202                                         String protocol,
 203                                         HttpAuthType authType,
 204                                         HttpTestAuthenticator auth,
 205                                         HttpAuthSchemeType schemeType,
 206                                         HttpTestHandler delegate)
 207             throws IOException {
 208         Objects.requireNonNull(authType);
 209         Objects.requireNonNull(auth);
 210         switch(authType) {
 211             // A server that performs Server Digest authentication.
 212             case SERVER: return createServer(version, protocol, authType, auth,
 213                                              schemeType, delegate, &quot;/&quot;);
 214             // A server that pretends to be a Proxy and performs
 215             // Proxy Digest authentication. If protocol is HTTPS,
 216             // then this will create a HttpsProxyTunnel that will
 217             // handle the CONNECT request for tunneling.
 218             case PROXY: return createProxy(version, protocol, authType, auth,
 219                                            schemeType, delegate, &quot;/&quot;);
 220             // A server that sends 307 redirect to a server that performs
 221             // Digest authentication.
 222             // Note: 301 doesn&#39;t work here because it transforms POST into GET.
 223             case SERVER307: return createServerAndRedirect(version,
 224                                                         protocol,
 225                                                         HttpAuthType.SERVER,
 226                                                         auth, schemeType,
 227                                                         delegate, 307);
 228             // A server that sends 305 redirect to a proxy that performs
 229             // Digest authentication.
 230             // Note: this is not correctly stubbed/implemented in this test.
 231             case PROXY305:  return createServerAndRedirect(version,
 232                                                         protocol,
 233                                                         HttpAuthType.PROXY,
 234                                                         auth, schemeType,
 235                                                         delegate, 305);
 236             default:
 237                 throw new InternalError(&quot;Unknown server type: &quot; + authType);
 238         }
 239     }
 240 
 241 
 242     /**
 243      * The SocketBindableFactory ensures that the local port used by an HttpServer
 244      * or a proxy ServerSocket previously created by the current test/VM will not
 245      * get reused by a subsequent test in the same VM.
 246      * This is to avoid having the test client trying to reuse cached connections.
 247      */
 248     private static abstract class SocketBindableFactory&lt;B&gt; {
 249         private static final int MAX = 10;
 250         private static final CopyOnWriteArrayList&lt;String&gt; addresses =
 251                 new CopyOnWriteArrayList&lt;&gt;();
 252         protected B createInternal() throws IOException {
 253             final int max = addresses.size() + MAX;
 254             final List&lt;B&gt; toClose = new ArrayList&lt;&gt;();
 255             try {
 256                 for (int i = 1; i &lt;= max; i++) {
 257                     B bindable = createBindable();
 258                     InetSocketAddress address = getAddress(bindable);
 259                     String key = &quot;localhost:&quot; + address.getPort();
 260                     if (addresses.addIfAbsent(key)) {
 261                         System.out.println(&quot;Socket bound to: &quot; + key
 262                                 + &quot; after &quot; + i + &quot; attempt(s)&quot;);
 263                         return bindable;
 264                     }
 265                     System.out.println(&quot;warning: address &quot; + key
 266                             + &quot; already used. Retrying bind.&quot;);
 267                     // keep the port bound until we get a port that we haven&#39;t
 268                     // used already
 269                     toClose.add(bindable);
 270                 }
 271             } finally {
 272                 // if we had to retry, then close the socket we&#39;re not
 273                 // going to use.
 274                 for (B b : toClose) {
 275                     try { close(b); } catch (Exception x) { /* ignore */ }
 276                 }
 277             }
 278             throw new IOException(&quot;Couldn&#39;t bind socket after &quot; + max + &quot; attempts: &quot;
 279                     + &quot;addresses used before: &quot; + addresses);
 280         }
 281 
 282         protected abstract B createBindable() throws IOException;
 283 
 284         protected abstract InetSocketAddress getAddress(B bindable);
 285 
 286         protected abstract void close(B bindable) throws IOException;
 287     }
 288 
 289     /*
 290      * Used to create ServerSocket for a proxy.
 291      */
 292     private static final class ServerSocketFactory
 293     extends SocketBindableFactory&lt;ServerSocket&gt; {
 294         private static final ServerSocketFactory instance = new ServerSocketFactory();
 295 
 296         static ServerSocket create() throws IOException {
 297             return instance.createInternal();
 298         }
 299 
 300         @Override
 301         protected ServerSocket createBindable() throws IOException {
 302             ServerSocket ss = new ServerSocket();
 303             ss.setReuseAddress(false);
 304             ss.bind(new InetSocketAddress(InetAddress.getLoopbackAddress(), 0));
 305             return ss;
 306         }
 307 
 308         @Override
 309         protected InetSocketAddress getAddress(ServerSocket socket) {
 310             return new InetSocketAddress(socket.getInetAddress(), socket.getLocalPort());
 311         }
 312 
 313         @Override
 314         protected void close(ServerSocket socket) throws IOException {
 315             socket.close();
 316         }
 317     }
 318 
 319     /*
 320      * Used to create HttpServer
 321      */
 322     private static abstract class H1ServerFactory&lt;S extends HttpServer&gt;
 323             extends SocketBindableFactory&lt;S&gt; {
 324         @Override
 325         protected S createBindable() throws IOException {
 326             S server = newHttpServer();
 327             server.bind(new InetSocketAddress(InetAddress.getLoopbackAddress(), 0), 0);
 328             return server;
 329         }
 330 
 331         @Override
 332         protected InetSocketAddress getAddress(S server) {
 333             return server.getAddress();
 334         }
 335 
 336         @Override
 337         protected void close(S server) throws IOException {
 338             server.stop(1);
 339         }
 340 
 341         /*
 342          * Returns a HttpServer or a HttpsServer in different subclasses.
 343          */
 344         protected abstract S newHttpServer() throws IOException;
 345     }
 346 
 347     /*
 348      * Used to create Http2TestServer
 349      */
 350     private static abstract class H2ServerFactory&lt;S extends Http2TestServer&gt;
 351             extends SocketBindableFactory&lt;S&gt; {
 352         @Override
 353         protected S createBindable() throws IOException {
 354             final S server;
 355             try {
 356                 server = newHttpServer();
 357             } catch (IOException io) {
 358                 throw io;
 359             } catch (Exception x) {
 360                 throw new IOException(x);
 361             }
 362             return server;
 363         }
 364 
 365         @Override
 366         protected InetSocketAddress getAddress(S server) {
 367             return server.getAddress();
 368         }
 369 
 370         @Override
 371         protected void close(S server) throws IOException {
 372             server.stop();
 373         }
 374 
 375         /*
 376          * Returns a HttpServer or a HttpsServer in different subclasses.
 377          */
 378         protected abstract S newHttpServer() throws Exception;
 379     }
 380 
 381     private static final class Http2ServerFactory extends H2ServerFactory&lt;Http2TestServer&gt; {
 382         private static final Http2ServerFactory instance = new Http2ServerFactory();
 383 
 384         static Http2TestServer create() throws IOException {
 385             return instance.createInternal();
 386         }
 387 
 388         @Override
 389         protected Http2TestServer newHttpServer() throws Exception {
 390             return new Http2TestServer(&quot;localhost&quot;, false, 0);
 391         }
 392     }
 393 
 394     private static final class Https2ServerFactory extends H2ServerFactory&lt;Http2TestServer&gt; {
 395         private static final Https2ServerFactory instance = new Https2ServerFactory();
 396 
 397         static Http2TestServer create() throws IOException {
 398             return instance.createInternal();
 399         }
 400 
 401         @Override
 402         protected Http2TestServer newHttpServer() throws Exception {
 403             return new Http2TestServer(&quot;localhost&quot;, true, 0);
 404         }
 405     }
 406 
 407     private static final class Http1ServerFactory extends H1ServerFactory&lt;HttpServer&gt; {
 408         private static final Http1ServerFactory instance = new Http1ServerFactory();
 409 
 410         static HttpServer create() throws IOException {
 411             return instance.createInternal();
 412         }
 413 
 414         @Override
 415         protected HttpServer newHttpServer() throws IOException {
 416             return HttpServer.create();
 417         }
 418     }
 419 
 420     private static final class Https1ServerFactory extends H1ServerFactory&lt;HttpsServer&gt; {
 421         private static final Https1ServerFactory instance = new Https1ServerFactory();
 422 
 423         static HttpsServer create() throws IOException {
 424             return instance.createInternal();
 425         }
 426 
 427         @Override
 428         protected HttpsServer newHttpServer() throws IOException {
 429             return HttpsServer.create();
 430         }
 431     }
 432 
 433     static Http2TestServer createHttp2Server(String protocol) throws IOException {
 434         final Http2TestServer server;
 435         if (&quot;http&quot;.equalsIgnoreCase(protocol)) {
 436             server = Http2ServerFactory.create();
 437         } else if (&quot;https&quot;.equalsIgnoreCase(protocol)) {
 438             server = Https2ServerFactory.create();
 439         } else {
 440             throw new InternalError(&quot;unsupported protocol: &quot; + protocol);
 441         }
 442         return server;
 443     }
 444 
 445     static HttpTestServer createHttpServer(Version version, String protocol)
 446             throws IOException
 447     {
 448         switch(version) {
 449             case HTTP_1_1:
 450                 return HttpTestServer.of(createHttp1Server(protocol));
 451             case HTTP_2:
 452                 return HttpTestServer.of(createHttp2Server(protocol));
 453             default:
 454                 throw new InternalError(&quot;Unexpected version: &quot; + version);
 455         }
 456     }
 457 
 458     static HttpServer createHttp1Server(String protocol) throws IOException {
 459         final HttpServer server;
 460         if (&quot;http&quot;.equalsIgnoreCase(protocol)) {
 461             server = Http1ServerFactory.create();
 462         } else if (&quot;https&quot;.equalsIgnoreCase(protocol)) {
 463             server = configure(Https1ServerFactory.create());
 464         } else {
 465             throw new InternalError(&quot;unsupported protocol: &quot; + protocol);
 466         }
 467         return server;
 468     }
 469 
 470     static HttpsServer configure(HttpsServer server) throws IOException {
 471         try {
 472             SSLContext ctx = SSLContext.getDefault();
 473             server.setHttpsConfigurator(new Configurator(ctx));
 474         } catch (NoSuchAlgorithmException ex) {
 475             throw new IOException(ex);
 476         }
 477         return server;
 478     }
 479 
 480 
 481     static void setContextAuthenticator(HttpTestContext ctxt,
 482                                         HttpTestAuthenticator auth) {
 483         final String realm = auth.getRealm();
 484         com.sun.net.httpserver.Authenticator authenticator =
 485             new BasicAuthenticator(realm) {
 486                 @Override
 487                 public boolean checkCredentials(String username, String pwd) {
 488                     return auth.getUserName().equals(username)
 489                            &amp;&amp; new String(auth.getPassword(username)).equals(pwd);
 490                 }
 491         };
 492         ctxt.setAuthenticator(authenticator);
 493     }
 494 
 495     public static DigestEchoServer createServer(Version version,
 496                                         String protocol,
 497                                         HttpAuthType authType,
 498                                         HttpTestAuthenticator auth,
 499                                         HttpAuthSchemeType schemeType,
 500                                         HttpTestHandler delegate,
 501                                         String path)
 502             throws IOException {
 503         Objects.requireNonNull(authType);
 504         Objects.requireNonNull(auth);
 505 
 506         HttpTestServer impl = createHttpServer(version, protocol);
 507         String key = String.format(&quot;DigestEchoServer[PID=%s,PORT=%s]:%s:%s:%s:%s&quot;,
 508                 ProcessHandle.current().pid(),
 509                 impl.getAddress().getPort(),
 510                 version, protocol, authType, schemeType);
 511         final DigestEchoServer server = new DigestEchoServerImpl(key, impl, null, delegate);
 512         final HttpTestHandler handler =
 513                 server.createHandler(schemeType, auth, authType, false);
 514         HttpTestContext context = impl.addHandler(handler, path);
 515         server.configureAuthentication(context, schemeType, auth, authType);
 516         impl.start();
 517         return server;
 518     }
 519 
 520     public static DigestEchoServer createProxy(Version version,
 521                                         String protocol,
 522                                         HttpAuthType authType,
 523                                         HttpTestAuthenticator auth,
 524                                         HttpAuthSchemeType schemeType,
 525                                         HttpTestHandler delegate,
 526                                         String path)
 527             throws IOException {
 528         Objects.requireNonNull(authType);
 529         Objects.requireNonNull(auth);
 530 
 531         if (version == Version.HTTP_2 &amp;&amp; protocol.equalsIgnoreCase(&quot;http&quot;)) {
 532             System.out.println(&quot;WARNING: can&#39;t use HTTP/1.1 proxy with unsecure HTTP/2 server&quot;);
 533             version = Version.HTTP_1_1;
 534         }
 535         HttpTestServer impl = createHttpServer(version, protocol);
 536         String key = String.format(&quot;DigestEchoServer[PID=%s,PORT=%s]:%s:%s:%s:%s&quot;,
 537                 ProcessHandle.current().pid(),
 538                 impl.getAddress().getPort(),
 539                 version, protocol, authType, schemeType);
 540         final DigestEchoServer server = &quot;https&quot;.equalsIgnoreCase(protocol)
 541                 ? new HttpsProxyTunnel(key, impl, null, delegate)
 542                 : new DigestEchoServerImpl(key, impl, null, delegate);
 543 
 544         final HttpTestHandler hh = server.createHandler(HttpAuthSchemeType.NONE,
 545                                          null, HttpAuthType.SERVER,
 546                                          server instanceof HttpsProxyTunnel);
 547         HttpTestContext ctxt = impl.addHandler(hh, path);
 548         server.configureAuthentication(ctxt, schemeType, auth, authType);
 549         impl.start();
 550 
 551         return server;
 552     }
 553 
 554     public static DigestEchoServer createServerAndRedirect(
 555                                         Version version,
 556                                         String protocol,
 557                                         HttpAuthType targetAuthType,
 558                                         HttpTestAuthenticator auth,
 559                                         HttpAuthSchemeType schemeType,
 560                                         HttpTestHandler targetDelegate,
 561                                         int code300)
 562             throws IOException {
 563         Objects.requireNonNull(targetAuthType);
 564         Objects.requireNonNull(auth);
 565 
 566         // The connection between client and proxy can only
 567         // be a plain connection: SSL connection to proxy
 568         // is not supported by our client connection.
 569         String targetProtocol = targetAuthType == HttpAuthType.PROXY
 570                                           ? &quot;http&quot;
 571                                           : protocol;
 572         DigestEchoServer redirectTarget =
 573                 (targetAuthType == HttpAuthType.PROXY)
 574                 ? createProxy(version, protocol, targetAuthType,
 575                               auth, schemeType, targetDelegate, &quot;/&quot;)
 576                 : createServer(version, targetProtocol, targetAuthType,
 577                                auth, schemeType, targetDelegate, &quot;/&quot;);
 578         HttpTestServer impl = createHttpServer(version, protocol);
 579         String key = String.format(&quot;RedirectingServer[PID=%s,PORT=%s]:%s:%s:%s:%s&quot;,
 580                 ProcessHandle.current().pid(),
 581                 impl.getAddress().getPort(),
 582                 version, protocol,
 583                 HttpAuthType.SERVER, code300)
 584                 + &quot;-&gt;&quot; + redirectTarget.key;
 585         final DigestEchoServer redirectingServer =
 586                  new DigestEchoServerImpl(key, impl, redirectTarget, null);
 587         InetSocketAddress redirectAddr = redirectTarget.getAddress();
 588         URL locationURL = url(targetProtocol, redirectAddr, &quot;/&quot;);
 589         final HttpTestHandler hh = redirectingServer.create300Handler(key, locationURL,
 590                                              HttpAuthType.SERVER, code300);
 591         impl.addHandler(hh,&quot;/&quot;);
 592         impl.start();
 593         return redirectingServer;
 594     }
 595 
 596     public abstract InetSocketAddress getServerAddress();
 597     public abstract InetSocketAddress getProxyAddress();
 598     public abstract InetSocketAddress getAddress();
 599     public abstract void stop();
 600     public abstract Version getServerVersion();
 601 
 602     private static class DigestEchoServerImpl extends DigestEchoServer {
 603         DigestEchoServerImpl(String key,
 604                              HttpTestServer server,
 605                              DigestEchoServer target,
 606                              HttpTestHandler delegate) {
 607             super(key, Objects.requireNonNull(server), target, delegate);
 608         }
 609 
 610         public InetSocketAddress getAddress() {
 611             return new InetSocketAddress(InetAddress.getLoopbackAddress(),
 612                     serverImpl.getAddress().getPort());
 613         }
 614 
 615         public InetSocketAddress getServerAddress() {
 616             return new InetSocketAddress(InetAddress.getLoopbackAddress(),
 617                     serverImpl.getAddress().getPort());
 618         }
 619 
 620         public InetSocketAddress getProxyAddress() {
 621             return new InetSocketAddress(InetAddress.getLoopbackAddress(),
 622                     serverImpl.getAddress().getPort());
 623         }
 624 
 625         public Version getServerVersion() {
 626             return serverImpl.getVersion();
 627         }
 628 
 629         public void stop() {
 630             serverImpl.stop();
 631             if (redirect != null) {
 632                 redirect.stop();
 633             }
 634         }
 635     }
 636 
 637     protected void writeResponse(HttpTestExchange he) throws IOException {
 638         if (delegate == null) {
 639             he.sendResponseHeaders(HttpURLConnection.HTTP_OK, -1);
 640             he.getResponseBody().write(he.getRequestBody().readAllBytes());
 641         } else {
 642             delegate.handle(he);
 643         }
 644     }
 645 
 646     private HttpTestHandler createHandler(HttpAuthSchemeType schemeType,
 647                                       HttpTestAuthenticator auth,
 648                                       HttpAuthType authType,
 649                                       boolean tunelled) {
 650         return new HttpNoAuthHandler(key, authType, tunelled);
 651     }
 652 
 653     void configureAuthentication(HttpTestContext ctxt,
 654                                  HttpAuthSchemeType schemeType,
 655                                  HttpTestAuthenticator auth,
 656                                  HttpAuthType authType) {
 657         switch(schemeType) {
 658             case DIGEST:
 659                 // DIGEST authentication is handled by the handler.
 660                 ctxt.addFilter(new HttpDigestFilter(key, auth, authType));
 661                 break;
 662             case BASIC:
 663                 // BASIC authentication is handled by the filter.
 664                 ctxt.addFilter(new HttpBasicFilter(key, auth, authType));
 665                 break;
 666             case BASICSERVER:
 667                 switch(authType) {
 668                     case PROXY: case PROXY305:
 669                         // HttpServer can&#39;t support Proxy-type authentication
 670                         // =&gt; we do as if BASIC had been specified, and we will
 671                         //    handle authentication in the handler.
 672                         ctxt.addFilter(new HttpBasicFilter(key, auth, authType));
 673                         break;
 674                     case SERVER: case SERVER307:
 675                         if (ctxt.getVersion() == Version.HTTP_1_1) {
 676                             // Basic authentication is handled by HttpServer
 677                             // directly =&gt; the filter should not perform
 678                             // authentication again.
 679                             setContextAuthenticator(ctxt, auth);
 680                             ctxt.addFilter(new HttpNoAuthFilter(key, authType));
 681                         } else {
 682                             ctxt.addFilter(new HttpBasicFilter(key, auth, authType));
 683                         }
 684                         break;
 685                     default:
 686                         throw new InternalError(key + &quot;: Invalid combination scheme=&quot;
 687                              + schemeType + &quot; authType=&quot; + authType);
 688                 }
 689             case NONE:
 690                 // No authentication at all.
 691                 ctxt.addFilter(new HttpNoAuthFilter(key, authType));
 692                 break;
 693             default:
 694                 throw new InternalError(key + &quot;: No such scheme: &quot; + schemeType);
 695         }
 696     }
 697 
 698     private HttpTestHandler create300Handler(String key, URL proxyURL,
 699                                              HttpAuthType type, int code300)
 700             throws MalformedURLException
 701     {
 702         return new Http3xxHandler(key, proxyURL, type, code300);
 703     }
 704 
 705     // Abstract HTTP filter class.
 706     private abstract static class AbstractHttpFilter extends HttpTestFilter {
 707 
 708         final HttpAuthType authType;
 709         final String type;
 710         public AbstractHttpFilter(HttpAuthType authType, String type) {
 711             this.authType = authType;
 712             this.type = type;
 713         }
 714 
 715         String getLocation() {
 716             return &quot;Location&quot;;
 717         }
 718         String getAuthenticate() {
 719             return authType == HttpAuthType.PROXY
 720                     ? &quot;Proxy-Authenticate&quot; : &quot;WWW-Authenticate&quot;;
 721         }
 722         String getAuthorization() {
 723             return authType == HttpAuthType.PROXY
 724                     ? &quot;Proxy-Authorization&quot; : &quot;Authorization&quot;;
 725         }
 726         int getUnauthorizedCode() {
 727             return authType == HttpAuthType.PROXY
 728                     ? HttpURLConnection.HTTP_PROXY_AUTH
 729                     : HttpURLConnection.HTTP_UNAUTHORIZED;
 730         }
 731         String getKeepAlive() {
 732             return &quot;keep-alive&quot;;
 733         }
 734         String getConnection() {
 735             return authType == HttpAuthType.PROXY
 736                     ? &quot;Proxy-Connection&quot; : &quot;Connection&quot;;
 737         }
 738         protected abstract boolean isAuthentified(HttpTestExchange he) throws IOException;
 739         protected abstract void requestAuthentication(HttpTestExchange he) throws IOException;
 740         protected void accept(HttpTestExchange he, HttpChain chain) throws IOException {
 741             chain.doFilter(he);
 742         }
 743 
 744         @Override
 745         public String description() {
 746             return &quot;Filter for &quot; + type;
 747         }
 748         @Override
 749         public void doFilter(HttpTestExchange he, HttpChain chain) throws IOException {
 750             try {
 751                 System.out.println(type + &quot;: Got &quot; + he.getRequestMethod()
 752                     + &quot;: &quot; + he.getRequestURI()
 753                     + &quot;\n&quot; + DigestEchoServer.toString(he.getRequestHeaders()));
 754 
 755                 // Assert only a single value for Expect. Not directly related
 756                 // to digest authentication, but verifies good client behaviour.
 757                 List&lt;String&gt; expectValues = he.getRequestHeaders().get(&quot;Expect&quot;);
 758                 if (expectValues != null &amp;&amp; expectValues.size() &gt; 1) {
 759                     throw new IOException(&quot;Expect:  &quot; + expectValues);
 760                 }
 761 
 762                 if (!isAuthentified(he)) {
 763                     try {
 764                         requestAuthentication(he);
 765                         he.sendResponseHeaders(getUnauthorizedCode(), -1);
 766                         System.out.println(type
 767                             + &quot;: Sent back &quot; + getUnauthorizedCode());
 768                     } finally {
 769                         he.close();
 770                     }
 771                 } else {
 772                     accept(he, chain);
 773                 }
 774             } catch (RuntimeException | Error | IOException t) {
 775                System.err.println(type
 776                     + &quot;: Unexpected exception while handling request: &quot; + t);
 777                t.printStackTrace(System.err);
 778                he.close();
 779                throw t;
 780             }
 781         }
 782 
 783     }
 784 
 785     // WARNING: This is not a full fledged implementation of DIGEST.
 786     // It does contain bugs and inaccuracy.
 787     final static class DigestResponse {
 788         final String realm;
 789         final String username;
 790         final String nonce;
 791         final String cnonce;
 792         final String nc;
 793         final String uri;
 794         final String algorithm;
 795         final String response;
 796         final String qop;
 797         final String opaque;
 798 
 799         public DigestResponse(String realm, String username, String nonce,
 800                               String cnonce, String nc, String uri,
 801                               String algorithm, String qop, String opaque,
 802                               String response) {
 803             this.realm = realm;
 804             this.username = username;
 805             this.nonce = nonce;
 806             this.cnonce = cnonce;
 807             this.nc = nc;
 808             this.uri = uri;
 809             this.algorithm = algorithm;
 810             this.qop = qop;
 811             this.opaque = opaque;
 812             this.response = response;
 813         }
 814 
 815         String getAlgorithm(String defval) {
 816             return algorithm == null ? defval : algorithm;
 817         }
 818         String getQoP(String defval) {
 819             return qop == null ? defval : qop;
 820         }
 821 
 822         // Code stolen from DigestAuthentication:
 823 
 824         private static final char charArray[] = {
 825             &#39;0&#39;, &#39;1&#39;, &#39;2&#39;, &#39;3&#39;, &#39;4&#39;, &#39;5&#39;, &#39;6&#39;, &#39;7&#39;,
 826             &#39;8&#39;, &#39;9&#39;, &#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;, &#39;e&#39;, &#39;f&#39;
 827         };
 828 
 829         private static String encode(String src, char[] passwd, MessageDigest md) {
 830             try {
 831                 md.update(src.getBytes(&quot;ISO-8859-1&quot;));
 832             } catch (java.io.UnsupportedEncodingException uee) {
 833                 assert false;
 834             }
 835             if (passwd != null) {
 836                 byte[] passwdBytes = new byte[passwd.length];
 837                 for (int i=0; i&lt;passwd.length; i++)
 838                     passwdBytes[i] = (byte)passwd[i];
 839                 md.update(passwdBytes);
 840                 Arrays.fill(passwdBytes, (byte)0x00);
 841             }
 842             byte[] digest = md.digest();
 843 
 844             StringBuilder res = new StringBuilder(digest.length * 2);
 845             for (int i = 0; i &lt; digest.length; i++) {
 846                 int hashchar = ((digest[i] &gt;&gt;&gt; 4) &amp; 0xf);
 847                 res.append(charArray[hashchar]);
 848                 hashchar = (digest[i] &amp; 0xf);
 849                 res.append(charArray[hashchar]);
 850             }
 851             return res.toString();
 852         }
 853 
 854         public static String computeDigest(boolean isRequest,
 855                                            String reqMethod,
 856                                            char[] password,
 857                                            DigestResponse params)
 858             throws NoSuchAlgorithmException
 859         {
 860 
 861             String A1, HashA1;
 862             String algorithm = params.getAlgorithm(&quot;MD5&quot;);
 863             boolean md5sess = algorithm.equalsIgnoreCase (&quot;MD5-sess&quot;);
 864 
 865             MessageDigest md = MessageDigest.getInstance(md5sess?&quot;MD5&quot;:algorithm);
 866 
 867             if (params.username == null) {
 868                 throw new IllegalArgumentException(&quot;missing username&quot;);
 869             }
 870             if (params.realm == null) {
 871                 throw new IllegalArgumentException(&quot;missing realm&quot;);
 872             }
 873             if (params.uri == null) {
 874                 throw new IllegalArgumentException(&quot;missing uri&quot;);
 875             }
 876             if (params.nonce == null) {
 877                 throw new IllegalArgumentException(&quot;missing nonce&quot;);
 878             }
 879 
 880             A1 = params.username + &quot;:&quot; + params.realm + &quot;:&quot;;
 881             HashA1 = encode(A1, password, md);
 882 
 883             String A2;
 884             if (isRequest) {
 885                 A2 = reqMethod + &quot;:&quot; + params.uri;
 886             } else {
 887                 A2 = &quot;:&quot; + params.uri;
 888             }
 889             String HashA2 = encode(A2, null, md);
 890             String combo, finalHash;
 891 
 892             if (&quot;auth&quot;.equals(params.qop)) { /* RRC2617 when qop=auth */
 893                 if (params.cnonce == null) {
 894                     throw new IllegalArgumentException(&quot;missing nonce&quot;);
 895                 }
 896                 if (params.nc == null) {
 897                     throw new IllegalArgumentException(&quot;missing nonce&quot;);
 898                 }
 899                 combo = HashA1+ &quot;:&quot; + params.nonce + &quot;:&quot; + params.nc + &quot;:&quot; +
 900                             params.cnonce + &quot;:auth:&quot; +HashA2;
 901 
 902             } else { /* for compatibility with RFC2069 */
 903                 combo = HashA1 + &quot;:&quot; +
 904                            params.nonce + &quot;:&quot; +
 905                            HashA2;
 906             }
 907             finalHash = encode(combo, null, md);
 908             return finalHash;
 909         }
 910 
 911         public static DigestResponse create(String raw) {
 912             String username, realm, nonce, nc, uri, response, cnonce,
 913                    algorithm, qop, opaque;
 914             HeaderParser parser = new HeaderParser(raw);
 915             username = parser.findValue(&quot;username&quot;);
 916             realm = parser.findValue(&quot;realm&quot;);
 917             nonce = parser.findValue(&quot;nonce&quot;);
 918             nc = parser.findValue(&quot;nc&quot;);
 919             uri = parser.findValue(&quot;uri&quot;);
 920             cnonce = parser.findValue(&quot;cnonce&quot;);
 921             response = parser.findValue(&quot;response&quot;);
 922             algorithm = parser.findValue(&quot;algorithm&quot;);
 923             qop = parser.findValue(&quot;qop&quot;);
 924             opaque = parser.findValue(&quot;opaque&quot;);
 925             return new DigestResponse(realm, username, nonce, cnonce, nc, uri,
 926                                       algorithm, qop, opaque, response);
 927         }
 928 
 929     }
 930 
 931     private static class HttpNoAuthFilter extends AbstractHttpFilter {
 932 
 933         static String type(String key, HttpAuthType authType) {
 934             String type = authType == HttpAuthType.SERVER
 935                     ? &quot;NoAuth Server Filter&quot; : &quot;NoAuth Proxy Filter&quot;;
 936             return &quot;[&quot;+type+&quot;]:&quot;+key;
 937         }
 938 
 939         public HttpNoAuthFilter(String key, HttpAuthType authType) {
 940             super(authType, type(key, authType));
 941         }
 942 
 943         @Override
 944         protected boolean isAuthentified(HttpTestExchange he) throws IOException {
 945             return true;
 946         }
 947 
 948         @Override
 949         protected void requestAuthentication(HttpTestExchange he) throws IOException {
 950             throw new InternalError(&quot;Should not com here&quot;);
 951         }
 952 
 953         @Override
 954         public String description() {
 955             return &quot;Passthrough Filter&quot;;
 956         }
 957 
 958     }
 959 
 960     // An HTTP Filter that performs Basic authentication
 961     private static class HttpBasicFilter extends AbstractHttpFilter {
 962 
 963         static String type(String key, HttpAuthType authType) {
 964             String type = authType == HttpAuthType.SERVER
 965                     ? &quot;Basic Server Filter&quot; : &quot;Basic Proxy Filter&quot;;
 966             return &quot;[&quot;+type+&quot;]:&quot;+key;
 967         }
 968 
 969         private final HttpTestAuthenticator auth;
 970         public HttpBasicFilter(String key, HttpTestAuthenticator auth,
 971                                HttpAuthType authType) {
 972             super(authType, type(key, authType));
 973             this.auth = auth;
 974         }
 975 
 976         @Override
 977         protected void requestAuthentication(HttpTestExchange he)
 978             throws IOException
 979         {
 980             String headerName = getAuthenticate();
 981             String headerValue = &quot;Basic realm=\&quot;&quot; + auth.getRealm() + &quot;\&quot;&quot;;
 982             he.getResponseHeaders().addHeader(headerName, headerValue);
 983             System.out.println(type + &quot;: Requesting Basic Authentication, &quot;
 984                                + headerName + &quot; : &quot;+ headerValue);
 985         }
 986 
 987         @Override
 988         protected boolean isAuthentified(HttpTestExchange he) {
 989             if (he.getRequestHeaders().containsKey(getAuthorization())) {
 990                 List&lt;String&gt; authorization =
 991                     he.getRequestHeaders().get(getAuthorization());
 992                 for (String a : authorization) {
 993                     System.out.println(type + &quot;: processing &quot; + a);
 994                     int sp = a.indexOf(&#39; &#39;);
 995                     if (sp &lt; 0) return false;
 996                     String scheme = a.substring(0, sp);
 997                     if (!&quot;Basic&quot;.equalsIgnoreCase(scheme)) {
 998                         System.out.println(type + &quot;: Unsupported scheme &#39;&quot;
 999                                            + scheme +&quot;&#39;&quot;);
1000                         return false;
1001                     }
1002                     if (a.length() &lt;= sp+1) {
1003                         System.out.println(type + &quot;: value too short for &#39;&quot;
1004                                             + scheme +&quot;&#39;&quot;);
1005                         return false;
1006                     }
1007                     a = a.substring(sp+1);
1008                     return validate(a);
1009                 }
1010                 return false;
1011             }
1012             return false;
1013         }
1014 
1015         boolean validate(String a) {
1016             byte[] b = Base64.getDecoder().decode(a);
1017             String userpass = new String (b);
1018             int colon = userpass.indexOf (&#39;:&#39;);
1019             String uname = userpass.substring (0, colon);
1020             String pass = userpass.substring (colon+1);
1021             return auth.getUserName().equals(uname) &amp;&amp;
1022                    new String(auth.getPassword(uname)).equals(pass);
1023         }
1024 
1025         @Override
1026         public String description() {
1027             return &quot;Filter for BASIC authentication: &quot; + type;
1028         }
1029 
1030     }
1031 
1032 
1033     // An HTTP Filter that performs Digest authentication
1034     // WARNING: This is not a full fledged implementation of DIGEST.
1035     // It does contain bugs and inaccuracy.
1036     private static class HttpDigestFilter extends AbstractHttpFilter {
1037 
1038         static String type(String key, HttpAuthType authType) {
1039             String type = authType == HttpAuthType.SERVER
1040                     ? &quot;Digest Server Filter&quot; : &quot;Digest Proxy Filter&quot;;
1041             return &quot;[&quot;+type+&quot;]:&quot;+key;
1042         }
1043 
1044         // This is a very basic DIGEST - used only for the purpose of testing
1045         // the client implementation. Therefore we can get away with never
1046         // updating the server nonce as it makes the implementation of the
1047         // server side digest simpler.
1048         private final HttpTestAuthenticator auth;
1049         private final byte[] nonce;
1050         private final String ns;
1051         public HttpDigestFilter(String key, HttpTestAuthenticator auth, HttpAuthType authType) {
1052             super(authType, type(key, authType));
1053             this.auth = auth;
1054             nonce = new byte[16];
1055             new Random(Instant.now().toEpochMilli()).nextBytes(nonce);
1056             ns = new BigInteger(1, nonce).toString(16);
1057         }
1058 
1059         @Override
1060         protected void requestAuthentication(HttpTestExchange he)
1061                 throws IOException {
1062             String separator;
1063             Version v = he.getExchangeVersion();
1064             if (v == Version.HTTP_1_1) {
1065                 separator = &quot;\r\n    &quot;;
1066             } else if (v == Version.HTTP_2) {
1067                 separator = &quot; &quot;;
1068             } else {
1069                 throw new InternalError(String.valueOf(v));
1070             }
1071             String headerName = getAuthenticate();
1072             String headerValue = &quot;Digest realm=\&quot;&quot; + auth.getRealm() + &quot;\&quot;,&quot;
1073                     + separator + &quot;qop=\&quot;auth\&quot;,&quot;
1074                     + separator + &quot;nonce=\&quot;&quot; + ns +&quot;\&quot;&quot;;
1075             he.getResponseHeaders().addHeader(headerName, headerValue);
1076             System.out.println(type + &quot;: Requesting Digest Authentication, &quot;
1077                                + headerName + &quot; : &quot; + headerValue);
1078         }
1079 
1080         @Override
1081         protected boolean isAuthentified(HttpTestExchange he) {
1082             if (he.getRequestHeaders().containsKey(getAuthorization())) {
1083                 List&lt;String&gt; authorization = he.getRequestHeaders().get(getAuthorization());
1084                 for (String a : authorization) {
1085                     System.out.println(type + &quot;: processing &quot; + a);
1086                     int sp = a.indexOf(&#39; &#39;);
1087                     if (sp &lt; 0) return false;
1088                     String scheme = a.substring(0, sp);
1089                     if (!&quot;Digest&quot;.equalsIgnoreCase(scheme)) {
1090                         System.out.println(type + &quot;: Unsupported scheme &#39;&quot; + scheme +&quot;&#39;&quot;);
1091                         return false;
1092                     }
1093                     if (a.length() &lt;= sp+1) {
1094                         System.out.println(type + &quot;: value too short for &#39;&quot; + scheme +&quot;&#39;&quot;);
1095                         return false;
1096                     }
1097                     a = a.substring(sp+1);
1098                     DigestResponse dgr = DigestResponse.create(a);
1099                     return validate(he.getRequestURI(), he.getRequestMethod(), dgr);
1100                 }
1101                 return false;
1102             }
1103             return false;
1104         }
1105 
1106         boolean validate(URI uri, String reqMethod, DigestResponse dg) {
1107             if (!&quot;MD5&quot;.equalsIgnoreCase(dg.getAlgorithm(&quot;MD5&quot;))) {
1108                 System.out.println(type + &quot;: Unsupported algorithm &quot;
1109                                    + dg.algorithm);
1110                 return false;
1111             }
1112             if (!&quot;auth&quot;.equalsIgnoreCase(dg.getQoP(&quot;auth&quot;))) {
1113                 System.out.println(type + &quot;: Unsupported qop &quot;
1114                                    + dg.qop);
1115                 return false;
1116             }
1117             try {
1118                 if (!dg.nonce.equals(ns)) {
1119                     System.out.println(type + &quot;: bad nonce returned by client: &quot;
1120                                     + nonce + &quot; expected &quot; + ns);
1121                     return false;
1122                 }
1123                 if (dg.response == null) {
1124                     System.out.println(type + &quot;: missing digest response.&quot;);
1125                     return false;
1126                 }
1127                 char[] pa = auth.getPassword(dg.username);
1128                 return verify(uri, reqMethod, dg, pa);
1129             } catch(IllegalArgumentException | SecurityException
1130                     | NoSuchAlgorithmException e) {
1131                 System.out.println(type + &quot;: &quot; + e.getMessage());
1132                 return false;
1133             }
1134         }
1135 
1136 
1137         boolean verify(URI uri, String reqMethod, DigestResponse dg, char[] pw)
1138             throws NoSuchAlgorithmException {
1139             String response = DigestResponse.computeDigest(true, reqMethod, pw, dg);
1140             if (!dg.response.equals(response)) {
1141                 System.out.println(type + &quot;: bad response returned by client: &quot;
1142                                     + dg.response + &quot; expected &quot; + response);
1143                 return false;
1144             } else {
1145                 // A real server would also verify the uri=&lt;request-uri&gt;
1146                 // parameter - but this is just a test...
1147                 System.out.println(type + &quot;: verified response &quot; + response);
1148             }
1149             return true;
1150         }
1151 
1152 
1153         @Override
1154         public String description() {
1155             return &quot;Filter for DIGEST authentication: &quot; + type;
1156         }
1157     }
1158 
1159     // Abstract HTTP handler class.
1160     private abstract static class AbstractHttpHandler implements HttpTestHandler {
1161 
1162         final HttpAuthType authType;
1163         final String type;
1164         public AbstractHttpHandler(HttpAuthType authType, String type) {
1165             this.authType = authType;
1166             this.type = type;
1167         }
1168 
1169         String getLocation() {
1170             return &quot;Location&quot;;
1171         }
1172 
1173         @Override
1174         public void handle(HttpTestExchange he) throws IOException {
1175             try {
1176                 sendResponse(he);
1177             } catch (RuntimeException | Error | IOException t) {
1178                System.err.println(type
1179                     + &quot;: Unexpected exception while handling request: &quot; + t);
1180                t.printStackTrace(System.err);
1181                throw t;
1182             } finally {
1183                 he.close();
1184             }
1185         }
1186 
1187         protected abstract void sendResponse(HttpTestExchange he) throws IOException;
1188 
1189     }
1190 
1191     static String stype(String type, String key, HttpAuthType authType, boolean tunnelled) {
1192         type = type + (authType == HttpAuthType.SERVER
1193                        ? &quot; Server&quot; : &quot; Proxy&quot;)
1194                 + (tunnelled ? &quot; Tunnelled&quot; : &quot;&quot;);
1195         return &quot;[&quot;+type+&quot;]:&quot;+key;
1196     }
1197 
1198     private class HttpNoAuthHandler extends AbstractHttpHandler {
1199 
1200         // true if this server is behind a proxy tunnel.
1201         final boolean tunnelled;
1202         public HttpNoAuthHandler(String key, HttpAuthType authType, boolean tunnelled) {
1203             super(authType, stype(&quot;NoAuth&quot;, key, authType, tunnelled));
1204             this.tunnelled = tunnelled;
1205         }
1206 
1207         @Override
1208         protected void sendResponse(HttpTestExchange he) throws IOException {
1209             if (DEBUG) {
1210                 System.out.println(type + &quot;: headers are: &quot;
1211                         + DigestEchoServer.toString(he.getRequestHeaders()));
1212             }
1213             if (authType == HttpAuthType.SERVER &amp;&amp; tunnelled) {
1214                 // Verify that the client doesn&#39;t send us proxy-* headers
1215                 // used to establish the proxy tunnel
1216                 Optional&lt;String&gt; proxyAuth = he.getRequestHeaders()
1217                         .keySet().stream()
1218                         .filter(&quot;proxy-authorization&quot;::equalsIgnoreCase)
1219                         .findAny();
1220                 if (proxyAuth.isPresent()) {
1221                     System.out.println(type + &quot; found &quot;
1222                             + proxyAuth.get() + &quot;: failing!&quot;);
1223                     throw new IOException(proxyAuth.get()
1224                             + &quot; found by &quot; + type + &quot; for &quot;
1225                             + he.getRequestURI());
1226                 }
1227             }
1228             DigestEchoServer.this.writeResponse(he);
1229         }
1230 
1231     }
1232 
1233     // A dummy HTTP Handler that redirects all incoming requests
1234     // by sending a back 3xx response code (301, 305, 307 etc..)
1235     private class Http3xxHandler extends AbstractHttpHandler {
1236 
1237         private final URL redirectTargetURL;
1238         private final int code3XX;
1239         public Http3xxHandler(String key, URL proxyURL, HttpAuthType authType, int code300) {
1240             super(authType, stype(&quot;Server&quot; + code300, key, authType, false));
1241             this.redirectTargetURL = proxyURL;
1242             this.code3XX = code300;
1243         }
1244 
1245         int get3XX() {
1246             return code3XX;
1247         }
1248 
1249         @Override
1250         public void sendResponse(HttpTestExchange he) throws IOException {
1251             System.out.println(type + &quot;: Got &quot; + he.getRequestMethod()
1252                     + &quot;: &quot; + he.getRequestURI()
1253                     + &quot;\n&quot; + DigestEchoServer.toString(he.getRequestHeaders()));
1254             System.out.println(type + &quot;: Redirecting to &quot;
1255                                + (authType == HttpAuthType.PROXY305
1256                                     ? &quot;proxy&quot; : &quot;server&quot;));
1257             he.getResponseHeaders().addHeader(getLocation(),
1258                 redirectTargetURL.toExternalForm().toString());
1259             he.sendResponseHeaders(get3XX(), -1);
1260             System.out.println(type + &quot;: Sent back &quot; + get3XX() + &quot; &quot;
1261                  + getLocation() + &quot;: &quot; + redirectTargetURL.toExternalForm().toString());
1262         }
1263     }
1264 
1265     static class Configurator extends HttpsConfigurator {
1266         public Configurator(SSLContext ctx) {
1267             super(ctx);
1268         }
1269 
1270         @Override
1271         public void configure (HttpsParameters params) {
1272             params.setSSLParameters (getSSLContext().getSupportedSSLParameters());
1273         }
1274     }
1275 
1276     static final long start = System.nanoTime();
1277     public static String now() {
1278         long now = System.nanoTime() - start;
1279         long secs = now / 1000_000_000;
1280         long mill = (now % 1000_000_000) / 1000_000;
1281         long nan = now % 1000_000;
1282         return String.format(&quot;[%d s, %d ms, %d ns] &quot;, secs, mill, nan);
1283     }
1284 
1285     static class  ProxyAuthorization {
1286         final HttpAuthSchemeType schemeType;
1287         final HttpTestAuthenticator authenticator;
1288         private final byte[] nonce;
1289         private final String ns;
1290         private final String key;
1291 
1292         ProxyAuthorization(String key, HttpAuthSchemeType schemeType, HttpTestAuthenticator auth) {
1293             this.key = key;
1294             this.schemeType = schemeType;
1295             this.authenticator = auth;
1296             nonce = new byte[16];
1297             new Random(Instant.now().toEpochMilli()).nextBytes(nonce);
1298             ns = new BigInteger(1, nonce).toString(16);
1299         }
1300 
1301         String doBasic(Optional&lt;String&gt; authorization) {
1302             String offset = &quot;proxy-authorization: basic &quot;;
1303             String authstring = authorization.orElse(&quot;&quot;);
1304             if (!authstring.toLowerCase(Locale.US).startsWith(offset)) {
1305                 return &quot;Proxy-Authenticate: BASIC &quot; + &quot;realm=\&quot;&quot;
1306                         + authenticator.getRealm() +&quot;\&quot;&quot;;
1307             }
1308             authstring = authstring
1309                     .substring(offset.length())
1310                     .trim();
1311             byte[] base64 = Base64.getDecoder().decode(authstring);
1312             String up = new String(base64, StandardCharsets.UTF_8);
1313             int colon = up.indexOf(&#39;:&#39;);
1314             if (colon &lt; 1) {
1315                 return &quot;Proxy-Authenticate: BASIC &quot; + &quot;realm=\&quot;&quot;
1316                         + authenticator.getRealm() +&quot;\&quot;&quot;;
1317             }
1318             String u = up.substring(0, colon);
1319             String p = up.substring(colon+1);
1320             char[] pw = authenticator.getPassword(u);
1321             if (!p.equals(new String(pw))) {
1322                 return &quot;Proxy-Authenticate: BASIC &quot; + &quot;realm=\&quot;&quot;
1323                         + authenticator.getRealm() +&quot;\&quot;&quot;;
1324             }
1325             System.out.println(now() + key + &quot; Proxy basic authentication success&quot;);
1326             return null;
1327         }
1328 
1329         String doDigest(Optional&lt;String&gt; authorization) {
1330             String offset = &quot;proxy-authorization: digest &quot;;
1331             String authstring = authorization.orElse(&quot;&quot;);
1332             if (!authstring.toLowerCase(Locale.US).startsWith(offset)) {
1333                 return &quot;Proxy-Authenticate: &quot; +
1334                         &quot;Digest realm=\&quot;&quot; + authenticator.getRealm() + &quot;\&quot;,&quot;
1335                         + &quot;\r\n    qop=\&quot;auth\&quot;,&quot;
1336                         + &quot;\r\n    nonce=\&quot;&quot; + ns +&quot;\&quot;&quot;;
1337             }
1338             authstring = authstring
1339                     .substring(offset.length())
1340                     .trim();
1341             boolean validated = false;
1342             try {
1343                 DigestResponse dgr = DigestResponse.create(authstring);
1344                 validated = validate(&quot;CONNECT&quot;, dgr);
1345             } catch (Throwable t) {
1346                 t.printStackTrace();
1347             }
1348             if (!validated) {
1349                 return &quot;Proxy-Authenticate: &quot; +
1350                         &quot;Digest realm=\&quot;&quot; + authenticator.getRealm() + &quot;\&quot;,&quot;
1351                         + &quot;\r\n    qop=\&quot;auth\&quot;,&quot;
1352                         + &quot;\r\n    nonce=\&quot;&quot; + ns +&quot;\&quot;&quot;;
1353             }
1354             return null;
1355         }
1356 
1357 
1358 
1359 
1360         boolean validate(String reqMethod, DigestResponse dg) {
1361             String type = now() + this.getClass().getSimpleName() + &quot;:&quot; + key;
1362             if (!&quot;MD5&quot;.equalsIgnoreCase(dg.getAlgorithm(&quot;MD5&quot;))) {
1363                 System.out.println(type + &quot;: Unsupported algorithm &quot;
1364                         + dg.algorithm);
1365                 return false;
1366             }
1367             if (!&quot;auth&quot;.equalsIgnoreCase(dg.getQoP(&quot;auth&quot;))) {
1368                 System.out.println(type + &quot;: Unsupported qop &quot;
1369                         + dg.qop);
1370                 return false;
1371             }
1372             try {
1373                 if (!dg.nonce.equals(ns)) {
1374                     System.out.println(type + &quot;: bad nonce returned by client: &quot;
1375                             + nonce + &quot; expected &quot; + ns);
1376                     return false;
1377                 }
1378                 if (dg.response == null) {
1379                     System.out.println(type + &quot;: missing digest response.&quot;);
1380                     return false;
1381                 }
1382                 char[] pa = authenticator.getPassword(dg.username);
1383                 return verify(type, reqMethod, dg, pa);
1384             } catch(IllegalArgumentException | SecurityException
1385                     | NoSuchAlgorithmException e) {
1386                 System.out.println(type + &quot;: &quot; + e.getMessage());
1387                 return false;
1388             }
1389         }
1390 
1391 
1392         boolean verify(String type, String reqMethod, DigestResponse dg, char[] pw)
1393                 throws NoSuchAlgorithmException {
1394             String response = DigestResponse.computeDigest(true, reqMethod, pw, dg);
1395             if (!dg.response.equals(response)) {
1396                 System.out.println(type + &quot;: bad response returned by client: &quot;
1397                         + dg.response + &quot; expected &quot; + response);
1398                 return false;
1399             } else {
1400                 // A real server would also verify the uri=&lt;request-uri&gt;
1401                 // parameter - but this is just a test...
1402                 System.out.println(type + &quot;: verified response &quot; + response);
1403             }
1404             return true;
1405         }
1406 
1407         public boolean authorize(StringBuilder response, String requestLine, String headers) {
1408             String message = &quot;&lt;html&gt;&lt;body&gt;&lt;p&gt;Authorization Failed%s&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;\r\n&quot;;
1409             if (authenticator == null &amp;&amp; schemeType != HttpAuthSchemeType.NONE) {
1410                 message = String.format(message, &quot; No Authenticator Set&quot;);
1411                 response.append(&quot;HTTP/1.1 407 Proxy Authentication Failed\r\n&quot;);
1412                 response.append(&quot;Content-Length: &quot;)
1413                         .append(message.getBytes(StandardCharsets.UTF_8).length)
1414                         .append(&quot;\r\n\r\n&quot;);
1415                 response.append(message);
1416                 return false;
1417             }
1418             Optional&lt;String&gt; authorization = Stream.of(headers.split(&quot;\r\n&quot;))
1419                     .filter((k) -&gt; k.toLowerCase(Locale.US).startsWith(&quot;proxy-authorization:&quot;))
1420                     .findFirst();
1421             String authenticate = null;
1422             switch(schemeType) {
1423                 case BASIC:
1424                 case BASICSERVER:
1425                     authenticate = doBasic(authorization);
1426                     break;
1427                 case DIGEST:
1428                     authenticate = doDigest(authorization);
1429                     break;
1430                 case NONE:
1431                     response.append(&quot;HTTP/1.1 200 OK\r\nContent-Length: 0\r\n\r\n&quot;);
1432                     return true;
1433                 default:
1434                     throw new InternalError(&quot;Unknown scheme type: &quot; + schemeType);
1435             }
1436             if (authenticate != null) {
1437                 message = String.format(message, &quot;&quot;);
1438                 response.append(&quot;HTTP/1.1 407 Proxy Authentication Required\r\n&quot;);
1439                 response.append(&quot;Content-Length: &quot;)
1440                         .append(message.getBytes(StandardCharsets.UTF_8).length)
1441                         .append(&quot;\r\n&quot;)
1442                         .append(authenticate)
1443                         .append(&quot;\r\n\r\n&quot;);
1444                 response.append(message);
1445                 return false;
1446             }
1447             response.append(&quot;HTTP/1.1 200 OK\r\nContent-Length: 0\r\n\r\n&quot;);
1448             return true;
1449         }
1450     }
1451 
1452     public interface TunnelingProxy {
1453         InetSocketAddress getProxyAddress();
1454         void stop();
1455     }
1456 
1457     // This is a bit hacky: HttpsProxyTunnel is an HTTPTestServer hidden
1458     // behind a fake proxy that only understands CONNECT requests.
1459     // The fake proxy is just a server socket that intercept the
1460     // CONNECT and then redirect streams to the real server.
1461     static class HttpsProxyTunnel extends DigestEchoServer
1462             implements Runnable, TunnelingProxy {
1463 
1464         final ServerSocket ss;
1465         final CopyOnWriteArrayList&lt;CompletableFuture&lt;Void&gt;&gt; connectionCFs
1466                 = new CopyOnWriteArrayList&lt;&gt;();
1467         volatile ProxyAuthorization authorization;
1468         volatile boolean stopped;
1469         public HttpsProxyTunnel(String key, HttpTestServer server, DigestEchoServer target,
1470                                 HttpTestHandler delegate)
1471                 throws IOException {
1472             this(key, server, target, delegate, ServerSocketFactory.create());
1473         }
1474         private HttpsProxyTunnel(String key, HttpTestServer server, DigestEchoServer target,
1475                                 HttpTestHandler delegate, ServerSocket ss)
1476                 throws IOException {
1477             super(&quot;HttpsProxyTunnel:&quot; + ss.getLocalPort() + &quot;:&quot; + key,
1478                     server, target, delegate);
1479             System.out.flush();
1480             System.err.println(&quot;WARNING: HttpsProxyTunnel is an experimental test class&quot;);
1481             this.ss = ss;
1482             start();
1483         }
1484 
1485         final void start() throws IOException {
1486             Thread t = new Thread(this, &quot;ProxyThread&quot;);
1487             t.setDaemon(true);
1488             t.start();
1489         }
1490 
1491         @Override
1492         public Version getServerVersion() {
1493             // serverImpl is not null when this proxy
1494             // serves a single server. It will be null
1495             // if this proxy can serve multiple servers.
1496             if (serverImpl != null) return serverImpl.getVersion();
1497             return null;
1498         }
1499 
1500         @Override
1501         public void stop() {
1502             stopped = true;
1503             if (serverImpl != null) {
1504                 serverImpl.stop();
1505             }
1506             if (redirect != null) {
1507                 redirect.stop();
1508             }
1509             try {
1510                 ss.close();
1511             } catch (IOException ex) {
1512                 if (DEBUG) ex.printStackTrace(System.out);
1513             }
1514         }
1515 
1516 
1517         @Override
1518         void configureAuthentication(HttpTestContext ctxt,
1519                                      HttpAuthSchemeType schemeType,
1520                                      HttpTestAuthenticator auth,
1521                                      HttpAuthType authType) {
1522             if (authType == HttpAuthType.PROXY || authType == HttpAuthType.PROXY305) {
1523                 authorization = new ProxyAuthorization(key, schemeType, auth);
1524             } else {
1525                 super.configureAuthentication(ctxt, schemeType, auth, authType);
1526             }
1527         }
1528 
<a name="3" id="anc3"></a><span class="line-added">1529         boolean badRequest(StringBuilder response, String hostport, List&lt;String&gt; hosts) {</span>
<span class="line-added">1530             String message = null;</span>
<span class="line-added">1531             if (hosts.isEmpty()) {</span>
<span class="line-added">1532                 message = &quot;No host header provided\r\n&quot;;</span>
<span class="line-added">1533             } else if (hosts.size() &gt; 1) {</span>
<span class="line-added">1534                 message = &quot;Multiple host headers provided\r\n&quot;;</span>
<span class="line-added">1535                 for (String h : hosts) {</span>
<span class="line-added">1536                     message = message + &quot;host: &quot; + h + &quot;\r\n&quot;;</span>
<span class="line-added">1537                 }</span>
<span class="line-added">1538             } else {</span>
<span class="line-added">1539                 String h = hosts.get(0);</span>
<span class="line-added">1540                 if (!hostport.equalsIgnoreCase(h)</span>
<span class="line-added">1541                         &amp;&amp; !hostport.equalsIgnoreCase(h + &quot;:80&quot;)</span>
<span class="line-added">1542                         &amp;&amp; !hostport.equalsIgnoreCase(h + &quot;:443&quot;)) {</span>
<span class="line-added">1543                     message = &quot;Bad host provided: [&quot; + h</span>
<span class="line-added">1544                             + &quot;] doesnot match [&quot; + hostport + &quot;]\r\n&quot;;</span>
<span class="line-added">1545                 }</span>
<span class="line-added">1546             }</span>
<span class="line-added">1547             if (message != null) {</span>
<span class="line-added">1548                 int length = message.getBytes(StandardCharsets.UTF_8).length;</span>
<span class="line-added">1549                 response.append(&quot;HTTP/1.1 400 BadRequest\r\n&quot;)</span>
<span class="line-added">1550                         .append(&quot;Content-Length: &quot; + length)</span>
<span class="line-added">1551                         .append(&quot;\r\n\r\n&quot;)</span>
<span class="line-added">1552                         .append(message);</span>
<span class="line-added">1553                 return true;</span>
<span class="line-added">1554             }</span>
<span class="line-added">1555 </span>
<span class="line-added">1556             return false;</span>
<span class="line-added">1557         }</span>
<span class="line-added">1558 </span>
1559         boolean authorize(StringBuilder response, String requestLine, String headers) {
1560             if (authorization != null) {
1561                 return authorization.authorize(response, requestLine, headers);
1562             }
1563             response.append(&quot;HTTP/1.1 200 OK\r\nContent-Length: 0\r\n\r\n&quot;);
1564             return true;
1565         }
1566 
1567         // Pipe the input stream to the output stream.
1568         private synchronized Thread pipe(InputStream is, OutputStream os, char tag, CompletableFuture&lt;Void&gt; end) {
1569             return new Thread(&quot;TunnelPipe(&quot;+tag+&quot;)&quot;) {
1570                 @Override
1571                 public void run() {
1572                     try {
<a name="4" id="anc4"></a><span class="line-added">1573                         int c = 0;</span>
1574                         try {
<a name="5" id="anc5"></a>
1575                             while ((c = is.read()) != -1) {
1576                                 os.write(c);
1577                                 os.flush();
1578                                 // if DEBUG prints a + or a - for each transferred
1579                                 // character.
1580                                 if (DEBUG) System.out.print(tag);
1581                             }
1582                             is.close();
<a name="6" id="anc6"></a><span class="line-added">1583                         } catch (IOException ex) {</span>
<span class="line-added">1584                             if (DEBUG || !stopped &amp;&amp; c &gt;  -1)</span>
<span class="line-added">1585                                 ex.printStackTrace(System.out);</span>
<span class="line-added">1586                             end.completeExceptionally(ex);</span>
1587                         } finally {
<a name="7" id="anc7"></a><span class="line-modified">1588                             try {os.close();} catch (Throwable t) {}</span>
1589                         }
<a name="8" id="anc8"></a>

1590                     } finally {
1591                         end.complete(null);
1592                     }
1593                 }
1594             };
1595         }
1596 
1597         @Override
1598         public InetSocketAddress getAddress() {
1599             return new InetSocketAddress(InetAddress.getLoopbackAddress(),
1600                     ss.getLocalPort());
1601         }
1602         @Override
1603         public InetSocketAddress getProxyAddress() {
1604             return getAddress();
1605         }
1606         @Override
1607         public InetSocketAddress getServerAddress() {
1608             // serverImpl can be null if this proxy can serve
1609             // multiple servers.
1610             if (serverImpl != null) {
1611                 return serverImpl.getAddress();
1612             }
1613             return null;
1614         }
1615 
1616 
1617         // This is a bit shaky. It doesn&#39;t handle continuation
1618         // lines, but our client shouldn&#39;t send any.
1619         // Read a line from the input stream, swallowing the final
1620         // \r\n sequence. Stops at the first \n, doesn&#39;t complain
1621         // if it wasn&#39;t preceded by &#39;\r&#39;.
1622         //
1623         String readLine(InputStream r) throws IOException {
1624             StringBuilder b = new StringBuilder();
1625             int c;
1626             while ((c = r.read()) != -1) {
1627                 if (c == &#39;\n&#39;) break;
1628                 b.appendCodePoint(c);
1629             }
1630             if (b.codePointAt(b.length() -1) == &#39;\r&#39;) {
1631                 b.delete(b.length() -1, b.length());
1632             }
1633             return b.toString();
1634         }
1635 
1636         @Override
1637         public void run() {
1638             Socket clientConnection = null;
<a name="9" id="anc9"></a><span class="line-added">1639             Socket targetConnection = null;</span>
1640             try {
1641                 while (!stopped) {
1642                     System.out.println(now() + &quot;Tunnel: Waiting for client&quot;);
1643                     Socket toClose;
<a name="10" id="anc10"></a><span class="line-added">1644                     targetConnection = clientConnection = null;</span>
1645                     try {
1646                         toClose = clientConnection = ss.accept();
1647                         if (NO_LINGER) {
1648                             // can be useful to trigger &quot;Connection reset by peer&quot;
1649                             // errors on the client side.
1650                             clientConnection.setOption(StandardSocketOptions.SO_LINGER, 0);
1651                         }
1652                     } catch (IOException io) {
1653                         if (DEBUG || !stopped) io.printStackTrace(System.out);
1654                         break;
1655                     }
1656                     System.out.println(now() + &quot;Tunnel: Client accepted&quot;);
1657                     StringBuilder headers = new StringBuilder();
<a name="11" id="anc11"></a>
1658                     InputStream  ccis = clientConnection.getInputStream();
1659                     OutputStream ccos = clientConnection.getOutputStream();
1660                     Writer w = new OutputStreamWriter(
1661                                    clientConnection.getOutputStream(), &quot;UTF-8&quot;);
1662                     PrintWriter pw = new PrintWriter(w);
1663                     System.out.println(now() + &quot;Tunnel: Reading request line&quot;);
1664                     String requestLine = readLine(ccis);
1665                     System.out.println(now() + &quot;Tunnel: Request line: &quot; + requestLine);
1666                     if (requestLine.startsWith(&quot;CONNECT &quot;)) {
1667                         // We should probably check that the next word following
1668                         // CONNECT is the host:port of our HTTPS serverImpl.
1669                         // Some improvement for a followup!
1670                         StringTokenizer tokenizer = new StringTokenizer(requestLine);
1671                         String connect = tokenizer.nextToken();
1672                         assert connect.equalsIgnoreCase(&quot;connect&quot;);
1673                         String hostport = tokenizer.nextToken();
1674                         InetSocketAddress targetAddress;
<a name="12" id="anc12"></a><span class="line-added">1675                         List&lt;String&gt; hosts = new ArrayList&lt;&gt;();</span>
1676                         try {
1677                             URI uri = new URI(&quot;https&quot;, hostport, &quot;/&quot;, null, null);
1678                             int port = uri.getPort();
1679                             port = port == -1 ? 443 : port;
1680                             targetAddress = new InetSocketAddress(uri.getHost(), port);
1681                             if (serverImpl != null) {
1682                                 assert targetAddress.getHostString()
1683                                         .equalsIgnoreCase(serverImpl.getAddress().getHostString());
1684                                 assert targetAddress.getPort() == serverImpl.getAddress().getPort();
1685                             }
1686                         } catch (Throwable x) {
1687                             System.err.printf(&quot;Bad target address: \&quot;%s\&quot; in \&quot;%s\&quot;%n&quot;,
1688                                     hostport, requestLine);
1689                             toClose.close();
1690                             continue;
1691                         }
1692 
1693                         // Read all headers until we find the empty line that
1694                         // signals the end of all headers.
1695                         String line = requestLine;
1696                         while(!line.equals(&quot;&quot;)) {
1697                             System.out.println(now() + &quot;Tunnel: Reading header: &quot;
1698                                                + (line = readLine(ccis)));
1699                             headers.append(line).append(&quot;\r\n&quot;);
<a name="13" id="anc13"></a><span class="line-added">1700                             int index = line.indexOf(&#39;:&#39;);</span>
<span class="line-added">1701                             if (index &gt;= 0) {</span>
<span class="line-added">1702                                 String key = line.substring(0, index).trim();</span>
<span class="line-added">1703                                 if (key.equalsIgnoreCase(&quot;host&quot;)) {</span>
<span class="line-added">1704                                     hosts.add(line.substring(index+1).trim());</span>
<span class="line-added">1705                                 }</span>
<span class="line-added">1706                             }</span>
1707                         }
<a name="14" id="anc14"></a>
1708                         StringBuilder response = new StringBuilder();
<a name="15" id="anc15"></a><span class="line-added">1709                         if (TUNNEL_REQUIRES_HOST) {</span>
<span class="line-added">1710                             if (badRequest(response, hostport, hosts)) {</span>
<span class="line-added">1711                                 System.out.println(now() + &quot;Tunnel: Sending &quot; + response);</span>
<span class="line-added">1712                                 // send the 400 response</span>
<span class="line-added">1713                                 pw.print(response.toString());</span>
<span class="line-added">1714                                 pw.flush();</span>
<span class="line-added">1715                                 toClose.close();</span>
<span class="line-added">1716                                 continue;</span>
<span class="line-added">1717                             } else {</span>
<span class="line-added">1718                                 assert hosts.size() == 1;</span>
<span class="line-added">1719                                 System.out.println(now()</span>
<span class="line-added">1720                                         + &quot;Tunnel: Host header verified &quot; + hosts);</span>
<span class="line-added">1721                             }</span>
<span class="line-added">1722                         }</span>
<span class="line-added">1723 </span>
1724                         final boolean authorize = authorize(response, requestLine, headers.toString());
1725                         if (!authorize) {
1726                             System.out.println(now() + &quot;Tunnel: Sending &quot;
1727                                     + response);
1728                             // send the 407 response
1729                             pw.print(response.toString());
1730                             pw.flush();
1731                             toClose.close();
1732                             continue;
1733                         }
1734                         System.out.println(now()
1735                                 + &quot;Tunnel connecting to target server at &quot;
1736                                 + targetAddress.getAddress() + &quot;:&quot; + targetAddress.getPort());
1737                         targetConnection = new Socket(
1738                                 targetAddress.getAddress(),
1739                                 targetAddress.getPort());
1740 
1741                         // Then send the 200 OK response to the client
1742                         System.out.println(now() + &quot;Tunnel: Sending &quot;
1743                                            + response);
1744                         pw.print(response);
1745                         pw.flush();
1746                     } else {
1747                         // This should not happen. If it does then just print an
1748                         // error - both on out and err, and close the accepted
1749                         // socket
1750                         System.out.println(&quot;WARNING: Tunnel: Unexpected status line: &quot;
1751                                 + requestLine + &quot; received by &quot;
1752                                 + ss.getLocalSocketAddress()
1753                                 + &quot; from &quot;
1754                                 + toClose.getRemoteSocketAddress()
1755                                 + &quot; - closing accepted socket&quot;);
1756                         // Print on err
1757                         System.err.println(&quot;WARNING: Tunnel: Unexpected status line: &quot;
1758                                              + requestLine + &quot; received by &quot;
1759                                            + ss.getLocalSocketAddress()
1760                                            + &quot; from &quot;
1761                                            + toClose.getRemoteSocketAddress());
1762                         // close accepted socket.
1763                         toClose.close();
1764                         System.err.println(&quot;Tunnel: accepted socket closed.&quot;);
1765                         continue;
1766                     }
1767 
1768                     // Pipe the input stream of the client connection to the
1769                     // output stream of the target connection and conversely.
1770                     // Now the client and target will just talk to each other.
1771                     System.out.println(now() + &quot;Tunnel: Starting tunnel pipes&quot;);
1772                     CompletableFuture&lt;Void&gt; end, end1, end2;
1773                     Thread t1 = pipe(ccis, targetConnection.getOutputStream(), &#39;+&#39;,
1774                             end1 = new CompletableFuture&lt;&gt;());
1775                     Thread t2 = pipe(targetConnection.getInputStream(), ccos, &#39;-&#39;,
1776                             end2 = new CompletableFuture&lt;&gt;());
<a name="16" id="anc16"></a><span class="line-modified">1777                     var end11 = end1.whenComplete((r, t) -&gt; exceptionally(end2, t));</span>
<span class="line-added">1778                     var end22 = end2.whenComplete((r, t) -&gt;  exceptionally(end1, t));</span>
<span class="line-added">1779                     end = CompletableFuture.allOf(end11, end22);</span>
<span class="line-added">1780                     Socket tc = targetConnection;</span>
1781                     end.whenComplete(
1782                             (r,t) -&gt; {
1783                                 try { toClose.close(); } catch (IOException x) { }
<a name="17" id="anc17"></a><span class="line-added">1784                                 try { tc.close(); } catch (IOException x) { }</span>
1785                                 finally {connectionCFs.remove(end);}
1786                             });
1787                     connectionCFs.add(end);
<a name="18" id="anc18"></a><span class="line-added">1788                     targetConnection = clientConnection = null;</span>
1789                     t1.start();
1790                     t2.start();
1791                 }
1792             } catch (Throwable ex) {
<a name="19" id="anc19"></a><span class="line-modified">1793                 close(clientConnection, ex);</span>
<span class="line-modified">1794                 close(targetConnection, ex);</span>
<span class="line-modified">1795                 close(ss, ex);</span>


1796                 ex.printStackTrace(System.err);
1797             } finally {
1798                 System.out.println(now() + &quot;Tunnel: exiting (stopped=&quot; + stopped + &quot;)&quot;);
1799                 connectionCFs.forEach(cf -&gt; cf.complete(null));
1800             }
1801         }
<a name="20" id="anc20"></a><span class="line-added">1802 </span>
<span class="line-added">1803         void exceptionally(CompletableFuture&lt;?&gt; cf, Throwable t) {</span>
<span class="line-added">1804             if (t != null) cf.completeExceptionally(t);</span>
<span class="line-added">1805         }</span>
<span class="line-added">1806 </span>
<span class="line-added">1807         void close(Closeable c, Throwable e) {</span>
<span class="line-added">1808             if (c == null) return;</span>
<span class="line-added">1809             try {</span>
<span class="line-added">1810                 c.close();</span>
<span class="line-added">1811             } catch (IOException x) {</span>
<span class="line-added">1812                 e.addSuppressed(x);</span>
<span class="line-added">1813             }</span>
<span class="line-added">1814         }</span>
1815     }
1816 
1817     /**
1818      * Creates a TunnelingProxy that can serve multiple servers.
1819      * The server address is extracted from the CONNECT request line.
1820      * @param authScheme The authentication scheme supported by the proxy.
1821      *                   Typically one of DIGEST, BASIC, NONE.
1822      * @return A new TunnelingProxy able to serve multiple servers.
1823      * @throws IOException If the proxy could not be created.
1824      */
1825     public static TunnelingProxy createHttpsProxyTunnel(HttpAuthSchemeType authScheme)
1826             throws IOException {
1827         HttpsProxyTunnel result = new HttpsProxyTunnel(&quot;&quot;, null, null, null);
1828         if (authScheme != HttpAuthSchemeType.NONE) {
1829             result.configureAuthentication(null,
1830                                            authScheme,
1831                                            AUTHENTICATOR,
1832                                            HttpAuthType.PROXY);
1833         }
1834         return result;
1835     }
1836 
1837     private static String protocol(String protocol) {
1838         if (&quot;http&quot;.equalsIgnoreCase(protocol)) return &quot;http&quot;;
1839         else if (&quot;https&quot;.equalsIgnoreCase(protocol)) return &quot;https&quot;;
1840         else throw new InternalError(&quot;Unsupported protocol: &quot; + protocol);
1841     }
1842 
1843     public static URL url(String protocol, InetSocketAddress address,
1844                           String path) throws MalformedURLException {
1845         return new URL(protocol(protocol),
1846                 address.getHostString(),
1847                 address.getPort(), path);
1848     }
1849 
1850     public static URI uri(String protocol, InetSocketAddress address,
1851                           String path) throws URISyntaxException {
1852         return new URI(protocol(protocol) + &quot;://&quot; +
1853                 address.getHostString() + &quot;:&quot; +
1854                 address.getPort() + path);
1855     }
1856 }
<a name="21" id="anc21"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="21" type="hidden" />
</body>
</html>
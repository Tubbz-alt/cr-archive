<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff test/jdk/java/net/httpclient/SmokeTest.java</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
<body>
<center><a href="ShortResponseBody.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="http2/RedirectTest.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>test/jdk/java/net/httpclient/SmokeTest.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 2015, 2018, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  */
  23 
  24 /*
  25  * @test
  26  * @bug 8087112 8178699
  27  * @modules java.net.http
  28  *          java.logging
  29  *          jdk.httpserver
  30  * @library /test/lib /
  31  * @build jdk.test.lib.net.SimpleSSLContext ProxyServer
  32  * @compile ../../../com/sun/net/httpserver/LogFilter.java
<span class="line-removed">  33  * @compile ../../../com/sun/net/httpserver/EchoHandler.java</span>
  34  * @compile ../../../com/sun/net/httpserver/FileServerHandler.java
  35  * @run main/othervm
  36  *      -Djdk.internal.httpclient.debug=true
  37  *      -Djdk.httpclient.HttpClient.log=errors,ssl,trace
  38  *      SmokeTest
  39  */
  40 
  41 import com.sun.net.httpserver.Headers;
  42 import com.sun.net.httpserver.HttpContext;
  43 import com.sun.net.httpserver.HttpExchange;
  44 import com.sun.net.httpserver.HttpHandler;
  45 import com.sun.net.httpserver.HttpServer;
  46 import com.sun.net.httpserver.HttpsConfigurator;
  47 import com.sun.net.httpserver.HttpsParameters;
  48 import com.sun.net.httpserver.HttpsServer;
  49 
  50 import java.net.InetAddress;
  51 import java.net.Proxy;
  52 import java.net.SocketAddress;


  53 import java.util.Collections;

  54 import java.util.Set;
  55 import java.util.concurrent.atomic.AtomicInteger;
  56 import java.net.InetSocketAddress;
  57 import java.net.PasswordAuthentication;
  58 import java.net.ProxySelector;
  59 import java.net.URI;
  60 import java.net.http.HttpClient;
  61 import java.net.http.HttpRequest;
  62 import java.net.http.HttpRequest.BodyPublishers;
  63 import java.net.http.HttpResponse;
  64 import java.net.http.HttpResponse.BodyHandlers;
  65 import java.io.File;
  66 import java.io.FileInputStream;
  67 import java.io.FileOutputStream;
  68 import java.io.FileNotFoundException;
  69 import java.io.IOException;
  70 import java.io.BufferedInputStream;
  71 import java.io.InputStream;
  72 import java.io.OutputStream;
  73 import java.io.UncheckedIOException;
</pre>
<hr />
<pre>
 118     static SSLParameters sslparams;
 119     static HttpServer s1 ;
 120     static HttpsServer s2;
 121     static ExecutorService executor;
 122     static int port;
 123     static int httpsport;
 124     static String httproot;
 125     static String httpsroot;
 126     static HttpClient client;
 127     static ProxyServer proxy;
 128     static int proxyPort;
 129     static RedirectErrorHandler redirectErrorHandler, redirectErrorHandlerSecure;
 130     static RedirectHandler redirectHandler, redirectHandlerSecure;
 131     static DelayHandler delayHandler;
 132     final static String midSizedFilename = &quot;/files/notsobigfile.txt&quot;;
 133     final static String smallFilename = &quot;/files/smallfile.txt&quot;;
 134     static Path midSizedFile;
 135     static Path smallFile;
 136     static String fileroot;
 137 
















 138     static String getFileContent(String path) throws IOException {
 139         FileInputStream fis = new FileInputStream(path);
 140         byte[] buf = new byte[2000];
 141         StringBuilder sb = new StringBuilder();
 142         int n;
 143         while ((n=fis.read(buf)) != -1) {
 144             sb.append(new String(buf, 0, n, &quot;US-ASCII&quot;));
 145         }
 146         fis.close();
 147         return sb.toString();
 148     }
 149 
 150     static void cmpFileContent(Path path1, Path path2) throws IOException {
 151         InputStream fis1 = new BufferedInputStream(new FileInputStream(path1.toFile()));
 152         InputStream fis2 = new BufferedInputStream(new FileInputStream(path2.toFile()));
 153 
 154         int n1, n2;
 155         while ((n1=fis1.read()) != -1) {
 156             n2 = fis2.read();
 157             if (n1 != n2)
</pre>
<hr />
<pre>
 240         int count() {
 241             return count;
 242         }
 243     }
 244 
 245     // Basic test
 246     static void test1(String target, boolean fixedLen) throws Exception {
 247         System.out.print(&quot;test1: &quot; + target);
 248         URI uri = new URI(target);
 249 
 250         HttpRequest.Builder builder = HttpRequest.newBuilder().uri(uri).GET();
 251 
 252         if (fixedLen) {
 253             builder.header(&quot;XFixed&quot;, &quot;yes&quot;);
 254         }
 255 
 256         HttpRequest request = builder.build();
 257 
 258         HttpResponse&lt;String&gt; response = client.send(request, BodyHandlers.ofString());
 259 


 260         String body = response.body();
 261         if (!body.equals(&quot;This is foo.txt\r\n&quot;)) {
 262             throw new RuntimeException(&quot;Did not get expected body: &quot;
 263                 + &quot;\n\t expected \&quot;This is foo.txt\\r\\n\&quot;&quot;
 264                 + &quot;\n\t received \&quot;&quot;
 265                 + body.replace(&quot;\r&quot;, &quot;\\r&quot;).replace(&quot;\n&quot;,&quot;\\n&quot;) + &quot;\&quot;&quot;);
 266         }
 267 
 268         // repeat async
 269         HttpResponse&lt;String&gt; response1 = client.sendAsync(request, BodyHandlers.ofString())
 270                                                .join();
 271 
 272         String body1 = response1.body();
 273         if (!body1.equals(&quot;This is foo.txt\r\n&quot;)) {
 274             throw new RuntimeException();
 275         }
 276         System.out.println(&quot; OK&quot;);
 277     }
 278 
 279     // POST use echo to check reply
</pre>
<hr />
<pre>
 487     }
 488 
 489     // 100 Continue: use echo target
 490     static void test5(String target, boolean fixedLen) throws Exception {
 491         System.out.print(&quot;test5: &quot; + target);
 492         URI uri = new URI(target);
 493         String requestBody = generateString(12 * 1024 + 13);
 494 
 495         HttpRequest.Builder builder = HttpRequest.newBuilder(uri)
 496                                             .expectContinue(true)
 497                                             .POST(BodyPublishers.ofString(requestBody));
 498 
 499         if (fixedLen) {
 500             builder.header(&quot;XFixed&quot;, &quot;yes&quot;);
 501         }
 502 
 503         HttpRequest request = builder.build();
 504 
 505         HttpResponse&lt;String&gt; response = client.send(request, BodyHandlers.ofString());
 506 


 507         String body = response.body();
 508 
 509         if (!body.equals(requestBody)) {
 510             throw new RuntimeException(
 511                     &quot;Body mismatch: expected [&quot; + body + &quot;], got [&quot; + body + &quot;]&quot;);
 512         }
 513         System.out.println(&quot; OK&quot;);
 514     }
 515 
 516     // use echo
 517     static void test6(String target, boolean fixedLen) throws Exception {
 518         System.out.print(&quot;test6: &quot; + target);
 519         URI uri = new URI(target);
 520         String requestBody = generateString(12 * 1024 + 3);
 521 
 522         HttpRequest.Builder builder = HttpRequest.newBuilder(uri).GET();
 523 
 524         if (fixedLen) {
 525             builder.header(&quot;XFixed&quot;, &quot;yes&quot;);
 526         }
 527 
 528         HttpRequest request = builder.build();
 529 
 530         HttpResponse&lt;String&gt; response = client.send(request, BodyHandlers.ofString());
 531 


 532         if (response.statusCode() != 200) {
 533             throw new RuntimeException(
 534                     &quot;Expected 200, got [ &quot; + response.statusCode() + &quot; ]&quot;);
 535         }
 536 
 537         String responseBody = response.body();
 538 
 539         if (responseBody.equals(requestBody)) {
 540             throw new RuntimeException(
 541                     &quot;Body mismatch: expected [&quot; + requestBody + &quot;], got [&quot; + responseBody + &quot;]&quot;);
 542         }
 543         System.out.println(&quot; OK&quot;);
 544     }
 545 
 546     @SuppressWarnings(&quot;rawtypes&quot;)
 547     static void test7(String target) throws Exception {
 548         System.out.print(&quot;test7: &quot; + target);
 549         Path requestBody = getTempFile(128 * 1024);
 550         // First test
 551         URI uri = new URI(target);
</pre>
<hr />
<pre>
 677     static void delay(int seconds) {
 678         try {
 679             Thread.sleep(seconds * 1000);
 680         } catch (InterruptedException e) {
 681         }
 682     }
 683 
 684     // Redirect loop: return an error after a certain number of redirects
 685     static void test10(String s) throws Exception {
 686         System.out.print(&quot;test10: &quot; + s);
 687         URI uri = new URI(s);
 688         RedirectErrorHandler handler = uri.getScheme().equals(&quot;https&quot;)
 689                 ? redirectErrorHandlerSecure : redirectErrorHandler;
 690 
 691         HttpRequest request = HttpRequest.newBuilder(uri).GET().build();
 692         CompletableFuture&lt;HttpResponse&lt;String&gt;&gt; cf =
 693                 client.sendAsync(request, BodyHandlers.ofString());
 694 
 695         try {
 696             HttpResponse&lt;String&gt; response = cf.join();
<span class="line-modified"> 697             throw new RuntimeException(&quot;Exepected Completion Exception&quot;);</span>
 698         } catch (CompletionException e) {
 699             //System.out.println(e);
 700         }
 701 
 702         System.out.printf(&quot; (Calls %d) &quot;, handler.count());
 703         System.out.println(&quot; OK&quot;);
 704     }
 705 
 706     static final int NUM = 50;
 707 
 708     static Random random = new Random();
 709     static final String alphabet = &quot;ABCDEFGHIJKLMNOPQRST&quot;;
 710 
 711     static char randomChar() {
 712         return alphabet.charAt(random.nextInt(alphabet.length()));
 713     }
 714 
 715     static String generateString(int length) {
 716         StringBuilder sb = new StringBuilder(length);
 717         for (int i=0; i&lt;length; i++) {
</pre>
<hr />
<pre>
 722 
 723     static void initServer() throws Exception {
 724 
 725         Logger logger = Logger.getLogger(&quot;com.sun.net.httpserver&quot;);
 726         ConsoleHandler ch = new ConsoleHandler();
 727         logger.setLevel(Level.SEVERE);
 728         ch.setLevel(Level.SEVERE);
 729         logger.addHandler(ch);
 730 
 731         String root = System.getProperty (&quot;test.src&quot;, &quot;.&quot;)+ &quot;/docs&quot;;
 732         InetSocketAddress addr = new InetSocketAddress(InetAddress.getLoopbackAddress(), 0);
 733         s1 = HttpServer.create (addr, 0);
 734         if (s1 instanceof HttpsServer) {
 735             throw new RuntimeException (&quot;should not be httpsserver&quot;);
 736         }
 737         s2 = HttpsServer.create (addr, 0);
 738         HttpHandler h = new FileServerHandler(root);
 739 
 740         HttpContext c1 = s1.createContext(&quot;/files&quot;, h);
 741         HttpContext c2 = s2.createContext(&quot;/files&quot;, h);
<span class="line-modified"> 742         HttpContext c3 = s1.createContext(&quot;/echo&quot;, new EchoHandler());</span>
 743         redirectHandler = new RedirectHandler(&quot;/redirect&quot;);
 744         redirectHandlerSecure = new RedirectHandler(&quot;/redirect&quot;);
 745         HttpContext c4 = s1.createContext(&quot;/redirect&quot;, redirectHandler);
 746         HttpContext c41 = s2.createContext(&quot;/redirect&quot;, redirectHandlerSecure);
<span class="line-modified"> 747         HttpContext c5 = s2.createContext(&quot;/echo&quot;, new EchoHandler());</span>
 748         HttpContext c6 = s1.createContext(&quot;/keepalive&quot;, new KeepAliveHandler());
 749         redirectErrorHandler = new RedirectErrorHandler(&quot;/redirecterror&quot;);
 750         redirectErrorHandlerSecure = new RedirectErrorHandler(&quot;/redirecterror&quot;);
 751         HttpContext c7 = s1.createContext(&quot;/redirecterror&quot;, redirectErrorHandler);
 752         HttpContext c71 = s2.createContext(&quot;/redirecterror&quot;, redirectErrorHandlerSecure);
 753         delayHandler = new DelayHandler();
 754         HttpContext c8 = s1.createContext(&quot;/delay&quot;, delayHandler);
 755         HttpContext c81 = s2.createContext(&quot;/delay&quot;, delayHandler);
 756 
 757         executor = Executors.newCachedThreadPool();
 758         s1.setExecutor(executor);
 759         s2.setExecutor(executor);
 760         ctx = new SimpleSSLContext().get();
 761         sslparams = ctx.getDefaultSSLParameters();
 762         //sslparams.setProtocols(new String[]{&quot;TLSv1.2&quot;});
 763         s2.setHttpsConfigurator(new Configurator(ctx));
 764         s1.start();
 765         s2.start();
 766 
 767         port = s1.getAddress().getPort();
 768         System.out.println(&quot;HTTP server port = &quot; + port);
 769         httpsport = s2.getAddress().getPort();
 770         System.out.println(&quot;HTTPS server port = &quot; + httpsport);
 771         httproot = &quot;http://localhost:&quot; + port + &quot;/&quot;;
 772         httpsroot = &quot;https://localhost:&quot; + httpsport + &quot;/&quot;;
 773 
 774         proxy = new ProxyServer(0, false);
 775         proxyPort = proxy.getPort();
 776         System.out.println(&quot;Proxy port = &quot; + proxyPort);
 777     }
 778 













 779     static class RedirectHandler implements HttpHandler {
 780         private final String root;
 781         private volatile int count = 0;
 782 
 783         RedirectHandler(String root) {
 784             this.root = root;
 785         }
 786 
 787         @Override
 788         public synchronized void handle(HttpExchange t) throws IOException {
<span class="line-removed"> 789             byte[] buf = new byte[2048];</span>
 790             try (InputStream is = t.getRequestBody()) {
<span class="line-modified"> 791                 while (is.read(buf) != -1) ;</span>
 792             }
 793 
 794             Headers responseHeaders = t.getResponseHeaders();
 795 
 796             if (count++ &lt; 1) {
 797                 responseHeaders.add(&quot;Location&quot;, root + &quot;/foo/&quot; + count);
 798             } else {
 799                 responseHeaders.add(&quot;Location&quot;, SmokeTest.midSizedFilename);
 800             }
 801             t.sendResponseHeaders(301, 64 * 1024);
 802             byte[] bb = new byte[1024];
 803             OutputStream os = t.getResponseBody();
 804             for (int i=0; i&lt;64; i++) {
 805                 os.write(bb);
 806             }
 807             os.close();
 808             t.close();
 809         }
 810 
 811         int count() {
</pre>
<hr />
<pre>
 993                 portSet.add(lports[i]);
 994             }
 995             System.out.printf(&quot;Ports: %d, %d, %d, %d\n&quot;, lports[0], lports[1], lports[2], lports[3]);
 996             latch8.countDown();
 997         }
 998         // Third test
 999         if (n &gt; 7) {
1000             // wait until all n == 7 has updated portSet
1001             try {latch8.await();} catch (InterruptedException e) {}
1002             if (np &gt; 4) {
1003                 System.err.println(&quot;XXX np = &quot; + np);
1004             }
1005             // just check that port is one of the ones in portSet
1006             if (!portSet.contains(remotePort)) {
1007                 System.out.println (&quot;UNEXPECTED REMOTE PORT &quot;
1008                         + remotePort + &quot; not in &quot; + portSet);
1009                 result = &quot;Error &quot; + Integer.toString(n);
1010                 System.out.println(result);
1011             }
1012         }
<span class="line-removed">1013         byte[] buf = new byte[2048];</span>
1014 
1015         try (InputStream is = t.getRequestBody()) {
<span class="line-modified">1016             while (is.read(buf) != -1) ;</span>
1017         }
1018         t.sendResponseHeaders(200, result.length());
1019         OutputStream o = t.getResponseBody();
<span class="line-modified">1020         o.write(result.getBytes(&quot;US-ASCII&quot;));</span>
1021         t.close();
1022         nparallel.getAndDecrement();
1023     }
1024 }
</pre>
</td>
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 2015, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  */
  23 
  24 /*
  25  * @test
  26  * @bug 8087112 8178699
  27  * @modules java.net.http
  28  *          java.logging
  29  *          jdk.httpserver
  30  * @library /test/lib /
  31  * @build jdk.test.lib.net.SimpleSSLContext ProxyServer
  32  * @compile ../../../com/sun/net/httpserver/LogFilter.java

  33  * @compile ../../../com/sun/net/httpserver/FileServerHandler.java
  34  * @run main/othervm
  35  *      -Djdk.internal.httpclient.debug=true
  36  *      -Djdk.httpclient.HttpClient.log=errors,ssl,trace
  37  *      SmokeTest
  38  */
  39 
  40 import com.sun.net.httpserver.Headers;
  41 import com.sun.net.httpserver.HttpContext;
  42 import com.sun.net.httpserver.HttpExchange;
  43 import com.sun.net.httpserver.HttpHandler;
  44 import com.sun.net.httpserver.HttpServer;
  45 import com.sun.net.httpserver.HttpsConfigurator;
  46 import com.sun.net.httpserver.HttpsParameters;
  47 import com.sun.net.httpserver.HttpsServer;
  48 
  49 import java.net.InetAddress;
  50 import java.net.Proxy;
  51 import java.net.SocketAddress;
<span class="line-added">  52 import java.net.http.HttpHeaders;</span>
<span class="line-added">  53 import java.nio.charset.StandardCharsets;</span>
  54 import java.util.Collections;
<span class="line-added">  55 import java.util.Optional;</span>
  56 import java.util.Set;
  57 import java.util.concurrent.atomic.AtomicInteger;
  58 import java.net.InetSocketAddress;
  59 import java.net.PasswordAuthentication;
  60 import java.net.ProxySelector;
  61 import java.net.URI;
  62 import java.net.http.HttpClient;
  63 import java.net.http.HttpRequest;
  64 import java.net.http.HttpRequest.BodyPublishers;
  65 import java.net.http.HttpResponse;
  66 import java.net.http.HttpResponse.BodyHandlers;
  67 import java.io.File;
  68 import java.io.FileInputStream;
  69 import java.io.FileOutputStream;
  70 import java.io.FileNotFoundException;
  71 import java.io.IOException;
  72 import java.io.BufferedInputStream;
  73 import java.io.InputStream;
  74 import java.io.OutputStream;
  75 import java.io.UncheckedIOException;
</pre>
<hr />
<pre>
 120     static SSLParameters sslparams;
 121     static HttpServer s1 ;
 122     static HttpsServer s2;
 123     static ExecutorService executor;
 124     static int port;
 125     static int httpsport;
 126     static String httproot;
 127     static String httpsroot;
 128     static HttpClient client;
 129     static ProxyServer proxy;
 130     static int proxyPort;
 131     static RedirectErrorHandler redirectErrorHandler, redirectErrorHandlerSecure;
 132     static RedirectHandler redirectHandler, redirectHandlerSecure;
 133     static DelayHandler delayHandler;
 134     final static String midSizedFilename = &quot;/files/notsobigfile.txt&quot;;
 135     final static String smallFilename = &quot;/files/smallfile.txt&quot;;
 136     static Path midSizedFile;
 137     static Path smallFile;
 138     static String fileroot;
 139 
<span class="line-added"> 140     static class HttpEchoHandler implements HttpHandler {</span>
<span class="line-added"> 141 </span>
<span class="line-added"> 142         @Override</span>
<span class="line-added"> 143         public void handle(HttpExchange exchange) throws IOException {</span>
<span class="line-added"> 144             try (InputStream is = exchange.getRequestBody();</span>
<span class="line-added"> 145                  OutputStream os = exchange.getResponseBody()) {</span>
<span class="line-added"> 146                 byte[] bytes = is.readAllBytes();</span>
<span class="line-added"> 147                 long responseLength = bytes.length == 0 ? -1 : bytes.length;</span>
<span class="line-added"> 148                 boolean fixedLength = &quot;yes&quot;.equals(exchange.getRequestHeaders()</span>
<span class="line-added"> 149                         .getFirst(&quot;XFixed&quot;));</span>
<span class="line-added"> 150                 exchange.sendResponseHeaders(200, fixedLength ? responseLength : 0);</span>
<span class="line-added"> 151                 os.write(bytes);</span>
<span class="line-added"> 152             }</span>
<span class="line-added"> 153         }</span>
<span class="line-added"> 154     }</span>
<span class="line-added"> 155 </span>
 156     static String getFileContent(String path) throws IOException {
 157         FileInputStream fis = new FileInputStream(path);
 158         byte[] buf = new byte[2000];
 159         StringBuilder sb = new StringBuilder();
 160         int n;
 161         while ((n=fis.read(buf)) != -1) {
 162             sb.append(new String(buf, 0, n, &quot;US-ASCII&quot;));
 163         }
 164         fis.close();
 165         return sb.toString();
 166     }
 167 
 168     static void cmpFileContent(Path path1, Path path2) throws IOException {
 169         InputStream fis1 = new BufferedInputStream(new FileInputStream(path1.toFile()));
 170         InputStream fis2 = new BufferedInputStream(new FileInputStream(path2.toFile()));
 171 
 172         int n1, n2;
 173         while ((n1=fis1.read()) != -1) {
 174             n2 = fis2.read();
 175             if (n1 != n2)
</pre>
<hr />
<pre>
 258         int count() {
 259             return count;
 260         }
 261     }
 262 
 263     // Basic test
 264     static void test1(String target, boolean fixedLen) throws Exception {
 265         System.out.print(&quot;test1: &quot; + target);
 266         URI uri = new URI(target);
 267 
 268         HttpRequest.Builder builder = HttpRequest.newBuilder().uri(uri).GET();
 269 
 270         if (fixedLen) {
 271             builder.header(&quot;XFixed&quot;, &quot;yes&quot;);
 272         }
 273 
 274         HttpRequest request = builder.build();
 275 
 276         HttpResponse&lt;String&gt; response = client.send(request, BodyHandlers.ofString());
 277 
<span class="line-added"> 278         checkResponseContentLength(response.headers(), fixedLen);</span>
<span class="line-added"> 279 </span>
 280         String body = response.body();
 281         if (!body.equals(&quot;This is foo.txt\r\n&quot;)) {
 282             throw new RuntimeException(&quot;Did not get expected body: &quot;
 283                 + &quot;\n\t expected \&quot;This is foo.txt\\r\\n\&quot;&quot;
 284                 + &quot;\n\t received \&quot;&quot;
 285                 + body.replace(&quot;\r&quot;, &quot;\\r&quot;).replace(&quot;\n&quot;,&quot;\\n&quot;) + &quot;\&quot;&quot;);
 286         }
 287 
 288         // repeat async
 289         HttpResponse&lt;String&gt; response1 = client.sendAsync(request, BodyHandlers.ofString())
 290                                                .join();
 291 
 292         String body1 = response1.body();
 293         if (!body1.equals(&quot;This is foo.txt\r\n&quot;)) {
 294             throw new RuntimeException();
 295         }
 296         System.out.println(&quot; OK&quot;);
 297     }
 298 
 299     // POST use echo to check reply
</pre>
<hr />
<pre>
 507     }
 508 
 509     // 100 Continue: use echo target
 510     static void test5(String target, boolean fixedLen) throws Exception {
 511         System.out.print(&quot;test5: &quot; + target);
 512         URI uri = new URI(target);
 513         String requestBody = generateString(12 * 1024 + 13);
 514 
 515         HttpRequest.Builder builder = HttpRequest.newBuilder(uri)
 516                                             .expectContinue(true)
 517                                             .POST(BodyPublishers.ofString(requestBody));
 518 
 519         if (fixedLen) {
 520             builder.header(&quot;XFixed&quot;, &quot;yes&quot;);
 521         }
 522 
 523         HttpRequest request = builder.build();
 524 
 525         HttpResponse&lt;String&gt; response = client.send(request, BodyHandlers.ofString());
 526 
<span class="line-added"> 527         checkResponseContentLength(response.headers(), fixedLen);</span>
<span class="line-added"> 528 </span>
 529         String body = response.body();
 530 
 531         if (!body.equals(requestBody)) {
 532             throw new RuntimeException(
 533                     &quot;Body mismatch: expected [&quot; + body + &quot;], got [&quot; + body + &quot;]&quot;);
 534         }
 535         System.out.println(&quot; OK&quot;);
 536     }
 537 
 538     // use echo
 539     static void test6(String target, boolean fixedLen) throws Exception {
 540         System.out.print(&quot;test6: &quot; + target);
 541         URI uri = new URI(target);
 542         String requestBody = generateString(12 * 1024 + 3);
 543 
 544         HttpRequest.Builder builder = HttpRequest.newBuilder(uri).GET();
 545 
 546         if (fixedLen) {
 547             builder.header(&quot;XFixed&quot;, &quot;yes&quot;);
 548         }
 549 
 550         HttpRequest request = builder.build();
 551 
 552         HttpResponse&lt;String&gt; response = client.send(request, BodyHandlers.ofString());
 553 
<span class="line-added"> 554         checkResponseContentLength(response.headers(), fixedLen);</span>
<span class="line-added"> 555 </span>
 556         if (response.statusCode() != 200) {
 557             throw new RuntimeException(
 558                     &quot;Expected 200, got [ &quot; + response.statusCode() + &quot; ]&quot;);
 559         }
 560 
 561         String responseBody = response.body();
 562 
 563         if (responseBody.equals(requestBody)) {
 564             throw new RuntimeException(
 565                     &quot;Body mismatch: expected [&quot; + requestBody + &quot;], got [&quot; + responseBody + &quot;]&quot;);
 566         }
 567         System.out.println(&quot; OK&quot;);
 568     }
 569 
 570     @SuppressWarnings(&quot;rawtypes&quot;)
 571     static void test7(String target) throws Exception {
 572         System.out.print(&quot;test7: &quot; + target);
 573         Path requestBody = getTempFile(128 * 1024);
 574         // First test
 575         URI uri = new URI(target);
</pre>
<hr />
<pre>
 701     static void delay(int seconds) {
 702         try {
 703             Thread.sleep(seconds * 1000);
 704         } catch (InterruptedException e) {
 705         }
 706     }
 707 
 708     // Redirect loop: return an error after a certain number of redirects
 709     static void test10(String s) throws Exception {
 710         System.out.print(&quot;test10: &quot; + s);
 711         URI uri = new URI(s);
 712         RedirectErrorHandler handler = uri.getScheme().equals(&quot;https&quot;)
 713                 ? redirectErrorHandlerSecure : redirectErrorHandler;
 714 
 715         HttpRequest request = HttpRequest.newBuilder(uri).GET().build();
 716         CompletableFuture&lt;HttpResponse&lt;String&gt;&gt; cf =
 717                 client.sendAsync(request, BodyHandlers.ofString());
 718 
 719         try {
 720             HttpResponse&lt;String&gt; response = cf.join();
<span class="line-modified"> 721             throw new RuntimeException(&quot;Expected Completion Exception&quot;);</span>
 722         } catch (CompletionException e) {
 723             //System.out.println(e);
 724         }
 725 
 726         System.out.printf(&quot; (Calls %d) &quot;, handler.count());
 727         System.out.println(&quot; OK&quot;);
 728     }
 729 
 730     static final int NUM = 50;
 731 
 732     static Random random = new Random();
 733     static final String alphabet = &quot;ABCDEFGHIJKLMNOPQRST&quot;;
 734 
 735     static char randomChar() {
 736         return alphabet.charAt(random.nextInt(alphabet.length()));
 737     }
 738 
 739     static String generateString(int length) {
 740         StringBuilder sb = new StringBuilder(length);
 741         for (int i=0; i&lt;length; i++) {
</pre>
<hr />
<pre>
 746 
 747     static void initServer() throws Exception {
 748 
 749         Logger logger = Logger.getLogger(&quot;com.sun.net.httpserver&quot;);
 750         ConsoleHandler ch = new ConsoleHandler();
 751         logger.setLevel(Level.SEVERE);
 752         ch.setLevel(Level.SEVERE);
 753         logger.addHandler(ch);
 754 
 755         String root = System.getProperty (&quot;test.src&quot;, &quot;.&quot;)+ &quot;/docs&quot;;
 756         InetSocketAddress addr = new InetSocketAddress(InetAddress.getLoopbackAddress(), 0);
 757         s1 = HttpServer.create (addr, 0);
 758         if (s1 instanceof HttpsServer) {
 759             throw new RuntimeException (&quot;should not be httpsserver&quot;);
 760         }
 761         s2 = HttpsServer.create (addr, 0);
 762         HttpHandler h = new FileServerHandler(root);
 763 
 764         HttpContext c1 = s1.createContext(&quot;/files&quot;, h);
 765         HttpContext c2 = s2.createContext(&quot;/files&quot;, h);
<span class="line-modified"> 766         HttpContext c3 = s1.createContext(&quot;/echo&quot;, new HttpEchoHandler());</span>
 767         redirectHandler = new RedirectHandler(&quot;/redirect&quot;);
 768         redirectHandlerSecure = new RedirectHandler(&quot;/redirect&quot;);
 769         HttpContext c4 = s1.createContext(&quot;/redirect&quot;, redirectHandler);
 770         HttpContext c41 = s2.createContext(&quot;/redirect&quot;, redirectHandlerSecure);
<span class="line-modified"> 771         HttpContext c5 = s2.createContext(&quot;/echo&quot;, new HttpEchoHandler());</span>
 772         HttpContext c6 = s1.createContext(&quot;/keepalive&quot;, new KeepAliveHandler());
 773         redirectErrorHandler = new RedirectErrorHandler(&quot;/redirecterror&quot;);
 774         redirectErrorHandlerSecure = new RedirectErrorHandler(&quot;/redirecterror&quot;);
 775         HttpContext c7 = s1.createContext(&quot;/redirecterror&quot;, redirectErrorHandler);
 776         HttpContext c71 = s2.createContext(&quot;/redirecterror&quot;, redirectErrorHandlerSecure);
 777         delayHandler = new DelayHandler();
 778         HttpContext c8 = s1.createContext(&quot;/delay&quot;, delayHandler);
 779         HttpContext c81 = s2.createContext(&quot;/delay&quot;, delayHandler);
 780 
 781         executor = Executors.newCachedThreadPool();
 782         s1.setExecutor(executor);
 783         s2.setExecutor(executor);
 784         ctx = new SimpleSSLContext().get();
 785         sslparams = ctx.getDefaultSSLParameters();
 786         //sslparams.setProtocols(new String[]{&quot;TLSv1.2&quot;});
 787         s2.setHttpsConfigurator(new Configurator(ctx));
 788         s1.start();
 789         s2.start();
 790 
 791         port = s1.getAddress().getPort();
 792         System.out.println(&quot;HTTP server port = &quot; + port);
 793         httpsport = s2.getAddress().getPort();
 794         System.out.println(&quot;HTTPS server port = &quot; + httpsport);
 795         httproot = &quot;http://localhost:&quot; + port + &quot;/&quot;;
 796         httpsroot = &quot;https://localhost:&quot; + httpsport + &quot;/&quot;;
 797 
 798         proxy = new ProxyServer(0, false);
 799         proxyPort = proxy.getPort();
 800         System.out.println(&quot;Proxy port = &quot; + proxyPort);
 801     }
 802 
<span class="line-added"> 803     static void checkResponseContentLength(HttpHeaders responseHeaders, boolean fixedLen) {</span>
<span class="line-added"> 804         Optional&lt;String&gt; transferEncoding = responseHeaders.firstValue(&quot;transfer-encoding&quot;);</span>
<span class="line-added"> 805         Optional&lt;String&gt; contentLength = responseHeaders.firstValue(&quot;content-length&quot;);</span>
<span class="line-added"> 806         if (fixedLen) {</span>
<span class="line-added"> 807             assert contentLength.isPresent();</span>
<span class="line-added"> 808             assert !transferEncoding.isPresent();</span>
<span class="line-added"> 809         } else {</span>
<span class="line-added"> 810             assert !contentLength.isPresent();</span>
<span class="line-added"> 811             assert transferEncoding.isPresent();</span>
<span class="line-added"> 812             assert &quot;chunked&quot;.equals(transferEncoding.get());</span>
<span class="line-added"> 813         }</span>
<span class="line-added"> 814     }</span>
<span class="line-added"> 815 </span>
 816     static class RedirectHandler implements HttpHandler {
 817         private final String root;
 818         private volatile int count = 0;
 819 
 820         RedirectHandler(String root) {
 821             this.root = root;
 822         }
 823 
 824         @Override
 825         public synchronized void handle(HttpExchange t) throws IOException {

 826             try (InputStream is = t.getRequestBody()) {
<span class="line-modified"> 827                 is.readAllBytes();</span>
 828             }
 829 
 830             Headers responseHeaders = t.getResponseHeaders();
 831 
 832             if (count++ &lt; 1) {
 833                 responseHeaders.add(&quot;Location&quot;, root + &quot;/foo/&quot; + count);
 834             } else {
 835                 responseHeaders.add(&quot;Location&quot;, SmokeTest.midSizedFilename);
 836             }
 837             t.sendResponseHeaders(301, 64 * 1024);
 838             byte[] bb = new byte[1024];
 839             OutputStream os = t.getResponseBody();
 840             for (int i=0; i&lt;64; i++) {
 841                 os.write(bb);
 842             }
 843             os.close();
 844             t.close();
 845         }
 846 
 847         int count() {
</pre>
<hr />
<pre>
1029                 portSet.add(lports[i]);
1030             }
1031             System.out.printf(&quot;Ports: %d, %d, %d, %d\n&quot;, lports[0], lports[1], lports[2], lports[3]);
1032             latch8.countDown();
1033         }
1034         // Third test
1035         if (n &gt; 7) {
1036             // wait until all n == 7 has updated portSet
1037             try {latch8.await();} catch (InterruptedException e) {}
1038             if (np &gt; 4) {
1039                 System.err.println(&quot;XXX np = &quot; + np);
1040             }
1041             // just check that port is one of the ones in portSet
1042             if (!portSet.contains(remotePort)) {
1043                 System.out.println (&quot;UNEXPECTED REMOTE PORT &quot;
1044                         + remotePort + &quot; not in &quot; + portSet);
1045                 result = &quot;Error &quot; + Integer.toString(n);
1046                 System.out.println(result);
1047             }
1048         }

1049 
1050         try (InputStream is = t.getRequestBody()) {
<span class="line-modified">1051             is.readAllBytes();</span>
1052         }
1053         t.sendResponseHeaders(200, result.length());
1054         OutputStream o = t.getResponseBody();
<span class="line-modified">1055         o.write(result.getBytes(StandardCharsets.UTF_8));</span>
1056         t.close();
1057         nparallel.getAndDecrement();
1058     }
1059 }
</pre>
</td>
</tr>
</table>
<center><a href="ShortResponseBody.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="http2/RedirectTest.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
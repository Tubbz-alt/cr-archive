<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff test/jdk/java/net/httpclient/HttpsTunnelTest.java</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
<body>
<center><a href="HttpResponseInputStreamTest.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="LargeResponseContent.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>test/jdk/java/net/httpclient/HttpsTunnelTest.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2018, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
</pre>
<hr />
<pre>
 30 import java.net.ProxySelector;
 31 import java.net.URI;
 32 import java.net.http.HttpClient;
 33 import java.net.http.HttpClient.Version;
 34 import java.net.http.HttpRequest;
 35 import java.net.http.HttpResponse;
 36 import java.net.http.HttpResponse.BodyHandlers;
 37 import java.util.Arrays;
 38 import java.util.List;
 39 import java.util.stream.Collectors;
 40 import java.util.stream.Stream;
 41 import static java.lang.String.format;
 42 import static java.lang.System.out;
 43 
 44 /**
 45  * @test
 46  * @summary This test verifies that if an h2 connection going through a
 47  *          proxy P is downgraded to HTTP/1.1, then a new h2 request
 48  *          going to a different host through the same proxy will not
 49  *          be preemptively downgraded. That, is the stack should attempt
<span class="line-modified"> 50  *          a new h2 connection to the new host.</span>
<span class="line-modified"> 51  * @bug 8196967</span>

 52  * @library /test/lib http2/server
 53  * @build jdk.test.lib.net.SimpleSSLContext HttpServerAdapters DigestEchoServer HttpsTunnelTest
 54  * @modules java.net.http/jdk.internal.net.http.common
 55  *          java.net.http/jdk.internal.net.http.frame
 56  *          java.net.http/jdk.internal.net.http.hpack
 57  *          java.logging
 58  *          java.base/sun.net.www.http
 59  *          java.base/sun.net.www
 60  *          java.base/sun.net
<span class="line-modified"> 61  * @run main/othervm -Djdk.internal.httpclient.debug=true HttpsTunnelTest</span>







 62  */
 63 
 64 public class HttpsTunnelTest implements HttpServerAdapters {
 65 
 66     static final String data[] = {
 67         &quot;Lorem ipsum&quot;,
 68         &quot;dolor sit amet&quot;,
 69         &quot;consectetur adipiscing elit, sed do eiusmod tempor&quot;,
 70         &quot;quis nostrud exercitation ullamco&quot;,
 71         &quot;laboris nisi&quot;,
 72         &quot;ut&quot;,
 73         &quot;aliquip ex ea commodo consequat.&quot; +
 74         &quot;Duis aute irure dolor in reprehenderit in voluptate velit esse&quot; +
 75         &quot;cillum dolore eu fugiat nulla pariatur.&quot;,
 76         &quot;Excepteur sint occaecat cupidatat non proident.&quot;
 77     };
 78 
 79     static final SSLContext context;
 80     static {
 81         try {
</pre>
<hr />
<pre>
 99 
100     public static void main(String[] args) throws Exception {
101         InetSocketAddress sa = new InetSocketAddress(InetAddress.getLoopbackAddress(), 0);
102         HttpsServer server1 = HttpsServer.create(sa, 0);
103         server1.setHttpsConfigurator(new HttpsConfigurator(context));
104         HttpTestServer http1Server =
105                 HttpTestServer.of(server1);
106         http1Server.addHandler(new HttpTestEchoHandler(), &quot;/&quot;);
107         http1Server.start();
108         HttpTestServer http2Server = HttpTestServer.of(
109                 new Http2TestServer(&quot;localhost&quot;, true, 0));
110         http2Server.addHandler(new HttpTestEchoHandler(), &quot;/&quot;);
111         http2Server.start();
112 
113         DigestEchoServer.TunnelingProxy proxy = DigestEchoServer.createHttpsProxyTunnel(
114                 DigestEchoServer.HttpAuthSchemeType.NONE);
115 
116         try {
117             URI uri1 = new URI(&quot;https://&quot; + http1Server.serverAuthority() + &quot;/foo/https1&quot;);
118             URI uri2 = new URI(&quot;https://&quot; + http2Server.serverAuthority() + &quot;/foo/https2&quot;);












119             ProxySelector ps = ProxySelector.of(proxy.getProxyAddress());
120                     //HttpClient.Builder.NO_PROXY;
121             HttpsTunnelTest test = new HttpsTunnelTest();
122             HttpClient client = test.newHttpClient(ps);
123             out.println(&quot;Proxy is: &quot; + ps.select(uri2));
124 
125             List&lt;String&gt; lines = List.of(Arrays.copyOfRange(data, 0, data.length));
126             assert lines.size() == data.length;
127             String body = lines.stream().collect(Collectors.joining(&quot;\r\n&quot;));
128             HttpRequest.BodyPublisher reqBody = HttpRequest.BodyPublishers.ofString(body);
<span class="line-modified">129             HttpRequest req1 = HttpRequest</span>
130                     .newBuilder(uri1)
131                     .version(Version.HTTP_2)
<span class="line-modified">132                     .POST(reqBody)</span>
<span class="line-modified">133                     .build();</span>

134             out.println(&quot;\nPosting to HTTP/1.1 server at: &quot; + req1);
135             HttpResponse&lt;Stream&lt;String&gt;&gt; response = client.send(req1, BodyHandlers.ofLines());
136             out.println(&quot;Checking response...&quot;);
137             if (response.statusCode() != 200) {
138                 throw new RuntimeException(&quot;Unexpected status code: &quot; + response);
139             }
140             if (response.version() != Version.HTTP_1_1) {
141                 throw new RuntimeException(&quot;Unexpected protocol version: &quot;
142                         + response.version());
143             }
144             List&lt;String&gt; respLines = response.body().collect(Collectors.toList());
145             if (!lines.equals(respLines)) {
146                 throw new RuntimeException(&quot;Unexpected response 1: &quot; + respLines);
147             }

148             HttpRequest.BodyPublisher reqBody2 = HttpRequest.BodyPublishers.ofString(body);
<span class="line-modified">149             HttpRequest req2 = HttpRequest</span>
150                     .newBuilder(uri2)
151                     .version(Version.HTTP_2)
<span class="line-modified">152                     .POST(reqBody2)</span>
<span class="line-modified">153                     .build();</span>

154             out.println(&quot;\nPosting to HTTP/2 server at: &quot; + req2);
155             response = client.send(req2, BodyHandlers.ofLines());
156             out.println(&quot;Checking response...&quot;);
157             if (response.statusCode() != 200) {
158                 throw new RuntimeException(&quot;Unexpected status code: &quot; + response);
159             }
160             if (response.version() != Version.HTTP_2) {
161                 throw new RuntimeException(&quot;Unexpected protocol version: &quot;
162                         + response.version());
163             }
164             respLines = response.body().collect(Collectors.toList());
165             if (!lines.equals(respLines)) {
166                 throw new RuntimeException(&quot;Unexpected response 2: &quot; + respLines);
167             }
168         } catch(Throwable t) {
169             out.println(&quot;Unexpected exception: exiting: &quot; + t);
170             t.printStackTrace();
171             throw t;
172         } finally {
173             proxy.stop();
174             http1Server.stop();
175             http2Server.stop();
176         }
177     }
178 






















179 }
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2018, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
</pre>
<hr />
<pre>
 30 import java.net.ProxySelector;
 31 import java.net.URI;
 32 import java.net.http.HttpClient;
 33 import java.net.http.HttpClient.Version;
 34 import java.net.http.HttpRequest;
 35 import java.net.http.HttpResponse;
 36 import java.net.http.HttpResponse.BodyHandlers;
 37 import java.util.Arrays;
 38 import java.util.List;
 39 import java.util.stream.Collectors;
 40 import java.util.stream.Stream;
 41 import static java.lang.String.format;
 42 import static java.lang.System.out;
 43 
 44 /**
 45  * @test
 46  * @summary This test verifies that if an h2 connection going through a
 47  *          proxy P is downgraded to HTTP/1.1, then a new h2 request
 48  *          going to a different host through the same proxy will not
 49  *          be preemptively downgraded. That, is the stack should attempt
<span class="line-modified"> 50  *          a new h2 connection to the new host. It also verifies that</span>
<span class="line-modified"> 51  *          the stack sends the appropriate &quot;host&quot; header to the proxy.</span>
<span class="line-added"> 52  * @bug 8196967 8222527</span>
 53  * @library /test/lib http2/server
 54  * @build jdk.test.lib.net.SimpleSSLContext HttpServerAdapters DigestEchoServer HttpsTunnelTest
 55  * @modules java.net.http/jdk.internal.net.http.common
 56  *          java.net.http/jdk.internal.net.http.frame
 57  *          java.net.http/jdk.internal.net.http.hpack
 58  *          java.logging
 59  *          java.base/sun.net.www.http
 60  *          java.base/sun.net.www
 61  *          java.base/sun.net
<span class="line-modified"> 62  * @run main/othervm -Dtest.requiresHost=true</span>
<span class="line-added"> 63  *                   -Djdk.httpclient.HttpClient.log=headers</span>
<span class="line-added"> 64  *                   -Djdk.internal.httpclient.debug=true HttpsTunnelTest</span>
<span class="line-added"> 65  * @run main/othervm -Dtest.requiresHost=true</span>
<span class="line-added"> 66  *                   -Djdk.httpclient.allowRestrictedHeaders=host</span>
<span class="line-added"> 67  *                   -Djdk.httpclient.HttpClient.log=headers</span>
<span class="line-added"> 68  *                   -Djdk.internal.httpclient.debug=true HttpsTunnelTest</span>
<span class="line-added"> 69  *</span>
 70  */
 71 
 72 public class HttpsTunnelTest implements HttpServerAdapters {
 73 
 74     static final String data[] = {
 75         &quot;Lorem ipsum&quot;,
 76         &quot;dolor sit amet&quot;,
 77         &quot;consectetur adipiscing elit, sed do eiusmod tempor&quot;,
 78         &quot;quis nostrud exercitation ullamco&quot;,
 79         &quot;laboris nisi&quot;,
 80         &quot;ut&quot;,
 81         &quot;aliquip ex ea commodo consequat.&quot; +
 82         &quot;Duis aute irure dolor in reprehenderit in voluptate velit esse&quot; +
 83         &quot;cillum dolore eu fugiat nulla pariatur.&quot;,
 84         &quot;Excepteur sint occaecat cupidatat non proident.&quot;
 85     };
 86 
 87     static final SSLContext context;
 88     static {
 89         try {
</pre>
<hr />
<pre>
107 
108     public static void main(String[] args) throws Exception {
109         InetSocketAddress sa = new InetSocketAddress(InetAddress.getLoopbackAddress(), 0);
110         HttpsServer server1 = HttpsServer.create(sa, 0);
111         server1.setHttpsConfigurator(new HttpsConfigurator(context));
112         HttpTestServer http1Server =
113                 HttpTestServer.of(server1);
114         http1Server.addHandler(new HttpTestEchoHandler(), &quot;/&quot;);
115         http1Server.start();
116         HttpTestServer http2Server = HttpTestServer.of(
117                 new Http2TestServer(&quot;localhost&quot;, true, 0));
118         http2Server.addHandler(new HttpTestEchoHandler(), &quot;/&quot;);
119         http2Server.start();
120 
121         DigestEchoServer.TunnelingProxy proxy = DigestEchoServer.createHttpsProxyTunnel(
122                 DigestEchoServer.HttpAuthSchemeType.NONE);
123 
124         try {
125             URI uri1 = new URI(&quot;https://&quot; + http1Server.serverAuthority() + &quot;/foo/https1&quot;);
126             URI uri2 = new URI(&quot;https://&quot; + http2Server.serverAuthority() + &quot;/foo/https2&quot;);
<span class="line-added">127 </span>
<span class="line-added">128             boolean provideCustomHost = &quot;host&quot;.equalsIgnoreCase(</span>
<span class="line-added">129                     System.getProperty(&quot;jdk.httpclient.allowRestrictedHeaders&quot;,&quot;&quot;));</span>
<span class="line-added">130 </span>
<span class="line-added">131             String customHttp1Host = null, customHttp2Host = null;</span>
<span class="line-added">132             if (provideCustomHost) {</span>
<span class="line-added">133                 customHttp1Host = makeCustomHostString(http1Server, uri1);</span>
<span class="line-added">134                 out.println(&quot;HTTP/1.1: &lt;&quot; + uri1 + &quot;&gt; [custom host: &quot; + customHttp1Host + &quot;]&quot;);</span>
<span class="line-added">135                 customHttp2Host = makeCustomHostString(http2Server, uri2);</span>
<span class="line-added">136                 out.println(&quot;HTTP/2:   &lt;&quot; + uri2 + &quot;&gt; [custom host: &quot; + customHttp2Host + &quot;]&quot;);</span>
<span class="line-added">137             }</span>
<span class="line-added">138 </span>
139             ProxySelector ps = ProxySelector.of(proxy.getProxyAddress());
140                     //HttpClient.Builder.NO_PROXY;
141             HttpsTunnelTest test = new HttpsTunnelTest();
142             HttpClient client = test.newHttpClient(ps);
143             out.println(&quot;Proxy is: &quot; + ps.select(uri2));
144 
145             List&lt;String&gt; lines = List.of(Arrays.copyOfRange(data, 0, data.length));
146             assert lines.size() == data.length;
147             String body = lines.stream().collect(Collectors.joining(&quot;\r\n&quot;));
148             HttpRequest.BodyPublisher reqBody = HttpRequest.BodyPublishers.ofString(body);
<span class="line-modified">149             HttpRequest.Builder req1Builder = HttpRequest</span>
150                     .newBuilder(uri1)
151                     .version(Version.HTTP_2)
<span class="line-modified">152                     .POST(reqBody);</span>
<span class="line-modified">153             if (provideCustomHost) req1Builder.header(&quot;host&quot;, customHttp1Host);</span>
<span class="line-added">154             HttpRequest req1 = req1Builder.build();</span>
155             out.println(&quot;\nPosting to HTTP/1.1 server at: &quot; + req1);
156             HttpResponse&lt;Stream&lt;String&gt;&gt; response = client.send(req1, BodyHandlers.ofLines());
157             out.println(&quot;Checking response...&quot;);
158             if (response.statusCode() != 200) {
159                 throw new RuntimeException(&quot;Unexpected status code: &quot; + response);
160             }
161             if (response.version() != Version.HTTP_1_1) {
162                 throw new RuntimeException(&quot;Unexpected protocol version: &quot;
163                         + response.version());
164             }
165             List&lt;String&gt; respLines = response.body().collect(Collectors.toList());
166             if (!lines.equals(respLines)) {
167                 throw new RuntimeException(&quot;Unexpected response 1: &quot; + respLines);
168             }
<span class="line-added">169 </span>
170             HttpRequest.BodyPublisher reqBody2 = HttpRequest.BodyPublishers.ofString(body);
<span class="line-modified">171             HttpRequest.Builder req2Builder = HttpRequest</span>
172                     .newBuilder(uri2)
173                     .version(Version.HTTP_2)
<span class="line-modified">174                     .POST(reqBody2);</span>
<span class="line-modified">175             if (provideCustomHost) req2Builder.header(&quot;host&quot;, customHttp2Host);</span>
<span class="line-added">176             HttpRequest req2 = req2Builder.build();</span>
177             out.println(&quot;\nPosting to HTTP/2 server at: &quot; + req2);
178             response = client.send(req2, BodyHandlers.ofLines());
179             out.println(&quot;Checking response...&quot;);
180             if (response.statusCode() != 200) {
181                 throw new RuntimeException(&quot;Unexpected status code: &quot; + response);
182             }
183             if (response.version() != Version.HTTP_2) {
184                 throw new RuntimeException(&quot;Unexpected protocol version: &quot;
185                         + response.version());
186             }
187             respLines = response.body().collect(Collectors.toList());
188             if (!lines.equals(respLines)) {
189                 throw new RuntimeException(&quot;Unexpected response 2: &quot; + respLines);
190             }
191         } catch(Throwable t) {
192             out.println(&quot;Unexpected exception: exiting: &quot; + t);
193             t.printStackTrace();
194             throw t;
195         } finally {
196             proxy.stop();
197             http1Server.stop();
198             http2Server.stop();
199         }
200     }
201 
<span class="line-added">202     /**</span>
<span class="line-added">203      * Builds a custom host string that is different to what is in the URI</span>
<span class="line-added">204      * authority, that is textually different than what the stack would</span>
<span class="line-added">205      * send. For CONNECT we should ignore any custom host settings.</span>
<span class="line-added">206      * The tunnelling proxy will fail with badRequest 400 if it receives</span>
<span class="line-added">207      * the custom host instead of the expected URI authority string.</span>
<span class="line-added">208      * @param  server The target server.</span>
<span class="line-added">209      * @param  uri    The URI to the target server</span>
<span class="line-added">210      * @return a host value for the custom host header.</span>
<span class="line-added">211      */</span>
<span class="line-added">212     static final String makeCustomHostString(HttpTestServer server, URI uri) {</span>
<span class="line-added">213         String customHttpHost;</span>
<span class="line-added">214         if (server.serverAuthority().contains(&quot;localhost&quot;)) {</span>
<span class="line-added">215             customHttpHost = InetAddress.getLoopbackAddress().getHostAddress();</span>
<span class="line-added">216         } else {</span>
<span class="line-added">217             customHttpHost = InetAddress.getLoopbackAddress().getHostName();</span>
<span class="line-added">218         }</span>
<span class="line-added">219         if (customHttpHost.contains(&quot;:&quot;)) customHttpHost = &quot;[&quot; + customHttpHost + &quot;]&quot;;</span>
<span class="line-added">220         if (uri.getPort() != -1) customHttpHost = customHttpHost + &quot;:&quot; + uri.getPort();</span>
<span class="line-added">221         return customHttpHost;</span>
<span class="line-added">222     }</span>
<span class="line-added">223 </span>
224 }
</pre>
</td>
</tr>
</table>
<center><a href="HttpResponseInputStreamTest.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="LargeResponseContent.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
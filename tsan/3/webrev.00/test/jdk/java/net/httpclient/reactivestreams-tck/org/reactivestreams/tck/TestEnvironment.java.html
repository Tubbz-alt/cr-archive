<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New test/jdk/java/net/httpclient/reactivestreams-tck/org/reactivestreams/tck/TestEnvironment.java</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 2019, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  */
  23 
  24 package org.reactivestreams.tck;
  25 
  26 import org.reactivestreams.Publisher;
  27 import org.reactivestreams.Subscriber;
  28 import org.reactivestreams.Subscription;
  29 import org.reactivestreams.tck.flow.support.Optional;
  30 import org.reactivestreams.tck.flow.support.SubscriberBufferOverflowException;
  31 
  32 import java.util.Collections;
  33 import java.util.LinkedList;
  34 import java.util.List;
  35 import java.util.concurrent.ArrayBlockingQueue;
  36 import java.util.concurrent.CopyOnWriteArrayList;
  37 import java.util.concurrent.CountDownLatch;
  38 import java.util.concurrent.TimeUnit;
  39 import java.util.concurrent.atomic.AtomicReference;
  40 
  41 import static java.util.concurrent.TimeUnit.MILLISECONDS;
  42 import static java.util.concurrent.TimeUnit.NANOSECONDS;
  43 import static org.testng.Assert.assertTrue;
  44 import static org.testng.Assert.fail;
  45 
  46 public class TestEnvironment {
  47   public static final int TEST_BUFFER_SIZE = 16;
  48 
  49   private static final String DEFAULT_TIMEOUT_MILLIS_ENV = &quot;DEFAULT_TIMEOUT_MILLIS&quot;;
  50   private static final long DEFAULT_TIMEOUT_MILLIS = 100;
  51 
  52   private static final String DEFAULT_NO_SIGNALS_TIMEOUT_MILLIS_ENV = &quot;DEFAULT_NO_SIGNALS_TIMEOUT_MILLIS&quot;;
  53   private static final String DEFAULT_POLL_TIMEOUT_MILLIS_ENV = &quot;DEFAULT_POLL_TIMEOUT_MILLIS_ENV&quot;;
  54 
  55   private final long defaultTimeoutMillis;
  56   private final long defaultPollTimeoutMillis;
  57   private final long defaultNoSignalsTimeoutMillis;
  58   private final boolean printlnDebug;
  59 
  60   private CopyOnWriteArrayList&lt;Throwable&gt; asyncErrors = new CopyOnWriteArrayList&lt;Throwable&gt;();
  61 
  62   /**
  63    * Tests must specify the timeout for expected outcome of asynchronous
  64    * interactions. Longer timeout does not invalidate the correctness of
  65    * the implementation, but can in some cases result in longer time to
  66    * run the tests.
  67    * @param defaultTimeoutMillis default timeout to be used in all expect* methods
  68    * @param defaultNoSignalsTimeoutMillis default timeout to be used when no further signals are expected anymore
  69    * @param defaultPollTimeoutMillis default amount of time to poll for events if {@code defaultTimeoutMillis} isn&#39;t
  70     *                                preempted by an asynchronous event.
  71    * @param printlnDebug         if true, signals such as OnNext / Request / OnComplete etc will be printed to standard output,
  72    */
  73   public TestEnvironment(long defaultTimeoutMillis, long defaultNoSignalsTimeoutMillis, long defaultPollTimeoutMillis,
  74                          boolean printlnDebug) {
  75     this.defaultTimeoutMillis = defaultTimeoutMillis;
  76     this.defaultPollTimeoutMillis = defaultPollTimeoutMillis;
  77     this.defaultNoSignalsTimeoutMillis = defaultNoSignalsTimeoutMillis;
  78     this.printlnDebug = printlnDebug;
  79   }
  80 
  81   /**
  82    * Tests must specify the timeout for expected outcome of asynchronous
  83    * interactions. Longer timeout does not invalidate the correctness of
  84    * the implementation, but can in some cases result in longer time to
  85    * run the tests.
  86    * @param defaultTimeoutMillis default timeout to be used in all expect* methods
  87    * @param defaultNoSignalsTimeoutMillis default timeout to be used when no further signals are expected anymore
  88    * @param printlnDebug         if true, signals such as OnNext / Request / OnComplete etc will be printed to standard output,
  89    */
  90   public TestEnvironment(long defaultTimeoutMillis, long defaultNoSignalsTimeoutMillis, boolean printlnDebug) {
  91     this(defaultTimeoutMillis, defaultNoSignalsTimeoutMillis, defaultTimeoutMillis, printlnDebug);
  92   }
  93 
  94   /**
  95    * Tests must specify the timeout for expected outcome of asynchronous
  96    * interactions. Longer timeout does not invalidate the correctness of
  97    * the implementation, but can in some cases result in longer time to
  98    * run the tests.
  99    *
 100    * @param defaultTimeoutMillis default timeout to be used in all expect* methods
 101    * @param defaultNoSignalsTimeoutMillis default timeout to be used when no further signals are expected anymore
 102    * @param defaultPollTimeoutMillis default amount of time to poll for events if {@code defaultTimeoutMillis} isn&#39;t
 103    *                                 preempted by an asynchronous event.
 104    */
 105   public TestEnvironment(long defaultTimeoutMillis, long defaultNoSignalsTimeoutMillis, long defaultPollTimeoutMillis) {
 106       this(defaultTimeoutMillis, defaultNoSignalsTimeoutMillis, defaultPollTimeoutMillis, false);
 107   }
 108 
 109   /**
 110    * Tests must specify the timeout for expected outcome of asynchronous
 111    * interactions. Longer timeout does not invalidate the correctness of
 112    * the implementation, but can in some cases result in longer time to
 113    * run the tests.
 114    *
 115    * @param defaultTimeoutMillis default timeout to be used in all expect* methods
 116    * @param defaultNoSignalsTimeoutMillis default timeout to be used when no further signals are expected anymore
 117    */
 118   public TestEnvironment(long defaultTimeoutMillis, long defaultNoSignalsTimeoutMillis) {
 119     this(defaultTimeoutMillis, defaultTimeoutMillis, defaultNoSignalsTimeoutMillis);
 120   }
 121 
 122   /**
 123    * Tests must specify the timeout for expected outcome of asynchronous
 124    * interactions. Longer timeout does not invalidate the correctness of
 125    * the implementation, but can in some cases result in longer time to
 126    * run the tests.
 127    *
 128    * @param defaultTimeoutMillis default timeout to be used in all expect* methods
 129    */
 130   public TestEnvironment(long defaultTimeoutMillis) {
 131     this(defaultTimeoutMillis, defaultTimeoutMillis, defaultTimeoutMillis);
 132   }
 133 
 134   /**
 135    * Tests must specify the timeout for expected outcome of asynchronous
 136    * interactions. Longer timeout does not invalidate the correctness of
 137    * the implementation, but can in some cases result in longer time to
 138    * run the tests.
 139    *
 140    * The default timeout for all expect* methods will be obtained by either the env variable {@code DEFAULT_TIMEOUT_MILLIS}
 141    * or the default value ({@link TestEnvironment#DEFAULT_TIMEOUT_MILLIS}) will be used.
 142    *
 143    * @param printlnDebug if true, signals such as OnNext / Request / OnComplete etc will be printed to standard output,
 144    *                     often helpful to pinpoint simple race conditions etc.
 145    */
 146   public TestEnvironment(boolean printlnDebug) {
 147     this(envDefaultTimeoutMillis(), envDefaultNoSignalsTimeoutMillis(), envDefaultPollTimeoutMillis(), printlnDebug);
 148   }
 149 
 150   /**
 151    * Tests must specify the timeout for expected outcome of asynchronous
 152    * interactions. Longer timeout does not invalidate the correctness of
 153    * the implementation, but can in some cases result in longer time to
 154    * run the tests.
 155    *
 156    * The default timeout for all expect* methods will be obtained by either the env variable {@code DEFAULT_TIMEOUT_MILLIS}
 157    * or the default value ({@link TestEnvironment#DEFAULT_TIMEOUT_MILLIS}) will be used.
 158    */
 159   public TestEnvironment() {
 160     this(envDefaultTimeoutMillis(), envDefaultNoSignalsTimeoutMillis());
 161   }
 162 
 163   /** This timeout is used when waiting for a signal to arrive. */
 164   public long defaultTimeoutMillis() {
 165     return defaultTimeoutMillis;
 166   }
 167 
 168   /**
 169    * This timeout is used when asserting that no further signals are emitted.
 170    * Note that this timeout default
 171    */
 172   public long defaultNoSignalsTimeoutMillis() {
 173     return defaultNoSignalsTimeoutMillis;
 174   }
 175 
 176   /**
 177    * The default amount of time to poll for events if {@code defaultTimeoutMillis} isn&#39;t preempted by an asynchronous
 178    * event.
 179    */
 180   public long defaultPollTimeoutMillis() {
 181     return defaultPollTimeoutMillis;
 182   }
 183 
 184   /**
 185    * Tries to parse the env variable {@code DEFAULT_TIMEOUT_MILLIS} as long and returns the value if present OR its default value.
 186    *
 187    * @throws java.lang.IllegalArgumentException when unable to parse the env variable
 188    */
 189   public static long envDefaultTimeoutMillis() {
 190     final String envMillis = System.getenv(DEFAULT_TIMEOUT_MILLIS_ENV);
 191     if (envMillis == null) return DEFAULT_TIMEOUT_MILLIS;
 192     else try {
 193       return Long.parseLong(envMillis);
 194     } catch (NumberFormatException ex) {
 195       throw new IllegalArgumentException(String.format(&quot;Unable to parse %s env value [%s] as long!&quot;, DEFAULT_TIMEOUT_MILLIS_ENV, envMillis), ex);
 196     }
 197   }
 198 
 199   /**
 200    * Tries to parse the env variable {@code DEFAULT_NO_SIGNALS_TIMEOUT_MILLIS} as long and returns the value if present OR its default value.
 201    *
 202    * @throws java.lang.IllegalArgumentException when unable to parse the env variable
 203    */
 204   public static long envDefaultNoSignalsTimeoutMillis() {
 205     final String envMillis = System.getenv(DEFAULT_NO_SIGNALS_TIMEOUT_MILLIS_ENV);
 206     if (envMillis == null) return envDefaultTimeoutMillis();
 207     else try {
 208       return Long.parseLong(envMillis);
 209     } catch (NumberFormatException ex) {
 210       throw new IllegalArgumentException(String.format(&quot;Unable to parse %s env value [%s] as long!&quot;, DEFAULT_NO_SIGNALS_TIMEOUT_MILLIS_ENV, envMillis), ex);
 211     }
 212   }
 213 
 214   /**
 215    * Tries to parse the env variable {@code DEFAULT_POLL_TIMEOUT_MILLIS_ENV} as long and returns the value if present OR its default value.
 216    *
 217    * @throws java.lang.IllegalArgumentException when unable to parse the env variable
 218    */
 219   public static long envDefaultPollTimeoutMillis() {
 220     final String envMillis = System.getenv(DEFAULT_POLL_TIMEOUT_MILLIS_ENV);
 221     if (envMillis == null) return envDefaultTimeoutMillis();
 222     else try {
 223       return Long.parseLong(envMillis);
 224     } catch (NumberFormatException ex) {
 225       throw new IllegalArgumentException(String.format(&quot;Unable to parse %s env value [%s] as long!&quot;, DEFAULT_POLL_TIMEOUT_MILLIS_ENV, envMillis), ex);
 226     }
 227   }
 228 
 229   /**
 230    * To flop means to &quot;fail asynchronously&quot;, either by onErroring or by failing some TCK check triggered asynchronously.
 231    * This method does *NOT* fail the test - it&#39;s up to inspections of the error to fail the test if required.
 232    *
 233    * Use {@code env.verifyNoAsyncErrorsNoDelay()} at the end of your TCK tests to verify there no flops called during it&#39;s execution.
 234    * To check investigate asyncErrors more closely you can use {@code expectError} methods or collect the error directly
 235    * from the environment using {@code env.dropAsyncError()}.
 236    *
 237    * To clear asyncErrors you can call {@link org.reactivestreams.tck.TestEnvironment#clearAsyncErrors()}
 238    */
 239   public void flop(String msg) {
 240     try {
 241       fail(msg);
 242     } catch (Throwable t) {
 243       asyncErrors.add(t);
 244     }
 245   }
 246 
 247   /**
 248    * To flop means to &quot;fail asynchronously&quot;, either by onErroring or by failing some TCK check triggered asynchronously.
 249    * This method does *NOT* fail the test - it&#39;s up to inspections of the error to fail the test if required.
 250    *
 251    * This overload keeps the passed in throwable as the asyncError, instead of creating an AssertionError for this.
 252    *
 253    * Use {@code env.verifyNoAsyncErrorsNoDelay()} at the end of your TCK tests to verify there no flops called during it&#39;s execution.
 254    * To check investigate asyncErrors more closely you can use {@code expectError} methods or collect the error directly
 255    * from the environment using {@code env.dropAsyncError()}.
 256    *
 257    * To clear asyncErrors you can call {@link org.reactivestreams.tck.TestEnvironment#clearAsyncErrors()}
 258    */
 259   public void flop(Throwable thr, String msg) {
 260     try {
 261       fail(msg, thr);
 262     } catch (Throwable t) {
 263       asyncErrors.add(thr);
 264     }
 265   }
 266 
 267   /**
 268    * To flop means to &quot;fail asynchronously&quot;, either by onErroring or by failing some TCK check triggered asynchronously.
 269    * This method does *NOT* fail the test - it&#39;s up to inspections of the error to fail the test if required.
 270    *
 271    * This overload keeps the passed in throwable as the asyncError, instead of creating an AssertionError for this.
 272    *
 273    * Use {@code env.verifyNoAsyncErrorsNoDelay()} at the end of your TCK tests to verify there no flops called during it&#39;s execution.
 274    * To check investigate asyncErrors more closely you can use {@code expectError} methods or collect the error directly
 275    * from the environment using {@code env.dropAsyncError()}.
 276    *
 277    * To clear asyncErrors you can call {@link org.reactivestreams.tck.TestEnvironment#clearAsyncErrors()}
 278    */
 279   public void flop(Throwable thr) {
 280     try {
 281       fail(thr.getMessage(), thr);
 282     } catch (Throwable t) {
 283       asyncErrors.add(thr);
 284     }
 285   }
 286 
 287   /**
 288    * To flop means to &quot;fail asynchronously&quot;, either by onErroring or by failing some TCK check triggered asynchronously.
 289    *
 290    * This method DOES fail the test right away (it tries to, by throwing an AssertionException),
 291    * in such it is different from {@link org.reactivestreams.tck.TestEnvironment#flop} which only records the error.
 292    *
 293    * Use {@code env.verifyNoAsyncErrorsNoDelay()} at the end of your TCK tests to verify there no flops called during it&#39;s execution.
 294    * To check investigate asyncErrors more closely you can use {@code expectError} methods or collect the error directly
 295    * from the environment using {@code env.dropAsyncError()}.
 296    *
 297    * To clear asyncErrors you can call {@link org.reactivestreams.tck.TestEnvironment#clearAsyncErrors()}
 298    */
 299   public &lt;T&gt; T flopAndFail(String msg) {
 300     try {
 301       fail(msg);
 302     } catch (Throwable t) {
 303       asyncErrors.add(t);
 304       fail(msg, t);
 305     }
 306     return null; // unreachable, the previous block will always exit by throwing
 307   }
 308 
 309 
 310 
 311   public &lt;T&gt; void subscribe(Publisher&lt;T&gt; pub, TestSubscriber&lt;T&gt; sub) throws InterruptedException {
 312     subscribe(pub, sub, defaultTimeoutMillis);
 313   }
 314 
 315   public &lt;T&gt; void subscribe(Publisher&lt;T&gt; pub, TestSubscriber&lt;T&gt; sub, long timeoutMillis) throws InterruptedException {
 316     pub.subscribe(sub);
 317     sub.subscription.expectCompletion(timeoutMillis, String.format(&quot;Could not subscribe %s to Publisher %s&quot;, sub, pub));
 318     verifyNoAsyncErrorsNoDelay();
 319   }
 320 
 321   public &lt;T&gt; ManualSubscriber&lt;T&gt; newBlackholeSubscriber(Publisher&lt;T&gt; pub) throws InterruptedException {
 322     ManualSubscriberWithSubscriptionSupport&lt;T&gt; sub = new BlackholeSubscriberWithSubscriptionSupport&lt;T&gt;(this);
 323     subscribe(pub, sub, defaultTimeoutMillis());
 324     return sub;
 325   }
 326 
 327   public &lt;T&gt; ManualSubscriber&lt;T&gt; newManualSubscriber(Publisher&lt;T&gt; pub) throws InterruptedException {
 328     return newManualSubscriber(pub, defaultTimeoutMillis());
 329   }
 330 
 331   public &lt;T&gt; ManualSubscriber&lt;T&gt; newManualSubscriber(Publisher&lt;T&gt; pub, long timeoutMillis) throws InterruptedException {
 332     ManualSubscriberWithSubscriptionSupport&lt;T&gt; sub = new ManualSubscriberWithSubscriptionSupport&lt;T&gt;(this);
 333     subscribe(pub, sub, timeoutMillis);
 334     return sub;
 335   }
 336 
 337   public void clearAsyncErrors() {
 338     asyncErrors.clear();
 339   }
 340 
 341   public Throwable dropAsyncError() {
 342     try {
 343       return asyncErrors.remove(0);
 344     } catch (IndexOutOfBoundsException ex) {
 345       return null;
 346     }
 347   }
 348 
 349   /**
 350    * Waits for {@link TestEnvironment#defaultNoSignalsTimeoutMillis()} and then verifies that no asynchronous errors
 351    * were signalled pior to, or during that time (by calling {@code flop()}).
 352    */
 353   public void verifyNoAsyncErrors() {
 354     verifyNoAsyncErrors(defaultNoSignalsTimeoutMillis());
 355   }
 356 
 357   /**
 358    * This version of {@code verifyNoAsyncErrors} should be used when errors still could be signalled
 359    * asynchronously during {@link TestEnvironment#defaultTimeoutMillis()} time.
 360    * &lt;p&gt;&lt;/p&gt;
 361    * It will immediatly check if any async errors were signaled (using {@link TestEnvironment#flop(String)},
 362    * and if no errors encountered wait for another default timeout as the errors may yet be signalled.
 363    * The initial check is performed in order to fail-fast in case of an already failed test.
 364    */
 365   public void verifyNoAsyncErrors(long delay) {
 366     try {
 367       verifyNoAsyncErrorsNoDelay();
 368 
 369       Thread.sleep(delay);
 370       verifyNoAsyncErrorsNoDelay();
 371     } catch (InterruptedException e) {
 372       throw new RuntimeException(e);
 373     }
 374   }
 375 
 376   /**
 377    * Verifies that no asynchronous errors were signalled pior to calling this method (by calling {@code flop()}).
 378    * This version of verifyNoAsyncError &lt;b&gt;does not wait before checking for asynchronous errors&lt;/b&gt;, and is to be used
 379    * for example in tight loops etc.
 380    */
 381   public void verifyNoAsyncErrorsNoDelay() {
 382     for (Throwable e : asyncErrors) {
 383       if (e instanceof AssertionError) {
 384         throw (AssertionError) e;
 385       } else {
 386         fail(String.format(&quot;Async error during test execution: %s&quot;, e.getMessage()), e);
 387       }
 388     }
 389   }
 390 
 391   /** If {@code TestEnvironment#printlnDebug} is true, print debug message to std out. */
 392   public void debug(String msg) {
 393     if (debugEnabled()) {
 394       System.out.printf(&quot;[TCK-DEBUG] %s%n&quot;, msg);
 395     }
 396   }
 397 
 398   public final boolean debugEnabled() {
 399     return printlnDebug;
 400   }
 401 
 402   /**
 403    * Looks for given {@code method} method in stack trace.
 404    * Can be used to answer questions like &quot;was this method called from onComplete?&quot;.
 405    *
 406    * @return the caller&#39;s StackTraceElement at which he the looked for method was found in the call stack, EMPTY otherwise
 407    */
 408   public Optional&lt;StackTraceElement&gt; findCallerMethodInStackTrace(String method) {
 409     final Throwable thr = new Throwable(); // gets the stacktrace
 410 
 411     for (StackTraceElement stackElement : thr.getStackTrace()) {
 412       if (stackElement.getMethodName().equals(method)) {
 413         return Optional.of(stackElement);
 414       }
 415     }
 416     return Optional.empty();
 417   }
 418 
 419   // ---- classes ----
 420 
 421   /**
 422    * {@link Subscriber} implementation which can be steered by test code and asserted on.
 423    */
 424   public static class ManualSubscriber&lt;T&gt; extends TestSubscriber&lt;T&gt; {
 425     Receptacle&lt;T&gt; received;
 426 
 427     public ManualSubscriber(TestEnvironment env) {
 428       super(env);
 429       received = new Receptacle&lt;T&gt;(this.env);
 430     }
 431 
 432     @Override
 433     public void onNext(T element) {
 434       try {
 435         received.add(element);
 436       } catch (IllegalStateException ex) {
 437           // error message refinement
 438           throw new SubscriberBufferOverflowException(
 439             String.format(&quot;Received more than bufferSize (%d) onNext signals. &quot; +
 440                             &quot;The Publisher probably emited more signals than expected!&quot;,
 441                           received.QUEUE_SIZE), ex);
 442       }
 443     }
 444 
 445     @Override
 446     public void onComplete() {
 447       received.complete();
 448     }
 449 
 450     public void request(long elements) {
 451       subscription.value().request(elements);
 452     }
 453 
 454     public T requestNextElement() throws InterruptedException {
 455       return requestNextElement(env.defaultTimeoutMillis());
 456     }
 457 
 458     public T requestNextElement(long timeoutMillis) throws InterruptedException {
 459       return requestNextElement(timeoutMillis, &quot;Did not receive expected element&quot;);
 460     }
 461 
 462     public T requestNextElement(String errorMsg) throws InterruptedException {
 463       return requestNextElement(env.defaultTimeoutMillis(), errorMsg);
 464     }
 465 
 466     public T requestNextElement(long timeoutMillis, String errorMsg) throws InterruptedException {
 467       request(1);
 468       return nextElement(timeoutMillis, errorMsg);
 469     }
 470 
 471     public Optional&lt;T&gt; requestNextElementOrEndOfStream() throws InterruptedException {
 472       return requestNextElementOrEndOfStream(env.defaultTimeoutMillis(), &quot;Did not receive expected stream completion&quot;);
 473     }
 474 
 475     public Optional&lt;T&gt; requestNextElementOrEndOfStream(String errorMsg) throws InterruptedException {
 476       return requestNextElementOrEndOfStream(env.defaultTimeoutMillis(), errorMsg);
 477     }
 478 
 479     public Optional&lt;T&gt; requestNextElementOrEndOfStream(long timeoutMillis) throws InterruptedException {
 480       return requestNextElementOrEndOfStream(timeoutMillis, &quot;Did not receive expected stream completion&quot;);
 481     }
 482 
 483     public Optional&lt;T&gt; requestNextElementOrEndOfStream(long timeoutMillis, String errorMsg) throws InterruptedException {
 484       request(1);
 485       return nextElementOrEndOfStream(timeoutMillis, errorMsg);
 486     }
 487 
 488     public void requestEndOfStream() throws InterruptedException {
 489       requestEndOfStream(env.defaultTimeoutMillis(), &quot;Did not receive expected stream completion&quot;);
 490     }
 491 
 492     public void requestEndOfStream(long timeoutMillis) throws InterruptedException {
 493       requestEndOfStream(timeoutMillis, &quot;Did not receive expected stream completion&quot;);
 494     }
 495 
 496     public void requestEndOfStream(String errorMsg) throws InterruptedException {
 497       requestEndOfStream(env.defaultTimeoutMillis(), errorMsg);
 498     }
 499 
 500     public void requestEndOfStream(long timeoutMillis, String errorMsg) throws InterruptedException {
 501       request(1);
 502       expectCompletion(timeoutMillis, errorMsg);
 503     }
 504 
 505     public List&lt;T&gt; requestNextElements(long elements) throws InterruptedException {
 506       request(elements);
 507       return nextElements(elements, env.defaultTimeoutMillis());
 508     }
 509 
 510     public List&lt;T&gt; requestNextElements(long elements, long timeoutMillis) throws InterruptedException {
 511       request(elements);
 512       return nextElements(elements, timeoutMillis, String.format(&quot;Did not receive %d expected elements&quot;, elements));
 513     }
 514 
 515     public List&lt;T&gt; requestNextElements(long elements, long timeoutMillis, String errorMsg) throws InterruptedException {
 516       request(elements);
 517       return nextElements(elements, timeoutMillis, errorMsg);
 518     }
 519 
 520     public T nextElement() throws InterruptedException {
 521       return nextElement(env.defaultTimeoutMillis());
 522     }
 523 
 524     public T nextElement(long timeoutMillis) throws InterruptedException {
 525       return nextElement(timeoutMillis, &quot;Did not receive expected element&quot;);
 526     }
 527 
 528     public T nextElement(String errorMsg) throws InterruptedException {
 529       return nextElement(env.defaultTimeoutMillis(), errorMsg);
 530     }
 531 
 532     public T nextElement(long timeoutMillis, String errorMsg) throws InterruptedException {
 533       return received.next(timeoutMillis, errorMsg);
 534     }
 535 
 536     public Optional&lt;T&gt; nextElementOrEndOfStream() throws InterruptedException {
 537       return nextElementOrEndOfStream(env.defaultTimeoutMillis(), &quot;Did not receive expected stream completion&quot;);
 538     }
 539 
 540     public Optional&lt;T&gt; nextElementOrEndOfStream(long timeoutMillis) throws InterruptedException {
 541       return nextElementOrEndOfStream(timeoutMillis, &quot;Did not receive expected stream completion&quot;);
 542     }
 543 
 544     public Optional&lt;T&gt; nextElementOrEndOfStream(long timeoutMillis, String errorMsg) throws InterruptedException {
 545       return received.nextOrEndOfStream(timeoutMillis, errorMsg);
 546     }
 547 
 548     public List&lt;T&gt; nextElements(long elements) throws InterruptedException {
 549       return nextElements(elements, env.defaultTimeoutMillis(), &quot;Did not receive expected element or completion&quot;);
 550     }
 551 
 552     public List&lt;T&gt; nextElements(long elements, String errorMsg) throws InterruptedException {
 553       return nextElements(elements, env.defaultTimeoutMillis(), errorMsg);
 554     }
 555 
 556     public List&lt;T&gt; nextElements(long elements, long timeoutMillis) throws InterruptedException {
 557       return nextElements(elements, timeoutMillis, &quot;Did not receive expected element or completion&quot;);
 558     }
 559 
 560     public List&lt;T&gt; nextElements(long elements, long timeoutMillis, String errorMsg) throws InterruptedException {
 561       return received.nextN(elements, timeoutMillis, errorMsg);
 562     }
 563 
 564     public void expectNext(T expected) throws InterruptedException {
 565       expectNext(expected, env.defaultTimeoutMillis());
 566     }
 567 
 568     public void expectNext(T expected, long timeoutMillis) throws InterruptedException {
 569       T received = nextElement(timeoutMillis, &quot;Did not receive expected element on downstream&quot;);
 570       if (!received.equals(expected)) {
 571         env.flop(String.format(&quot;Expected element %s on downstream but received %s&quot;, expected, received));
 572       }
 573     }
 574 
 575     public void expectCompletion() throws InterruptedException {
 576       expectCompletion(env.defaultTimeoutMillis(), &quot;Did not receive expected stream completion&quot;);
 577     }
 578 
 579     public void expectCompletion(long timeoutMillis) throws InterruptedException {
 580       expectCompletion(timeoutMillis, &quot;Did not receive expected stream completion&quot;);
 581     }
 582 
 583     public void expectCompletion(String errorMsg) throws InterruptedException {
 584       expectCompletion(env.defaultTimeoutMillis(), errorMsg);
 585     }
 586 
 587     public void expectCompletion(long timeoutMillis, String errorMsg) throws InterruptedException {
 588       received.expectCompletion(timeoutMillis, errorMsg);
 589     }
 590 
 591     public &lt;E extends Throwable&gt; void expectErrorWithMessage(Class&lt;E&gt; expected, String requiredMessagePart) throws Exception {
 592       expectErrorWithMessage(expected, Collections.singletonList(requiredMessagePart), env.defaultTimeoutMillis(), env.defaultPollTimeoutMillis());
 593     }
 594     public &lt;E extends Throwable&gt; void expectErrorWithMessage(Class&lt;E&gt; expected, List&lt;String&gt; requiredMessagePartAlternatives) throws Exception {
 595       expectErrorWithMessage(expected, requiredMessagePartAlternatives, env.defaultTimeoutMillis(), env.defaultPollTimeoutMillis());
 596     }
 597 
 598     @SuppressWarnings(&quot;ThrowableResultOfMethodCallIgnored&quot;)
 599     public &lt;E extends Throwable&gt; void expectErrorWithMessage(Class&lt;E&gt; expected, String requiredMessagePart, long timeoutMillis) throws Exception {
 600       expectErrorWithMessage(expected, Collections.singletonList(requiredMessagePart), timeoutMillis);
 601     }
 602 
 603     public &lt;E extends Throwable&gt; void expectErrorWithMessage(Class&lt;E&gt; expected, List&lt;String&gt; requiredMessagePartAlternatives, long timeoutMillis) throws Exception {
 604       expectErrorWithMessage(expected, requiredMessagePartAlternatives, timeoutMillis, timeoutMillis);
 605     }
 606 
 607     public &lt;E extends Throwable&gt; void expectErrorWithMessage(Class&lt;E&gt; expected, List&lt;String&gt; requiredMessagePartAlternatives,
 608                                                              long totalTimeoutMillis, long pollTimeoutMillis) throws Exception {
 609       final E err = expectError(expected, totalTimeoutMillis, pollTimeoutMillis);
 610       final String message = err.getMessage();
 611 
 612       boolean contains = false;
 613       for (String requiredMessagePart : requiredMessagePartAlternatives)
 614         if (message.contains(requiredMessagePart)) contains = true; // not short-circuting loop, it is expected to
 615       assertTrue(contains,
 616               String.format(&quot;Got expected exception [%s] but missing message part [%s], was: %s&quot;,
 617                       err.getClass(), &quot;anyOf: &quot; + requiredMessagePartAlternatives, err.getMessage()));
 618     }
 619 
 620     public &lt;E extends Throwable&gt; E expectError(Class&lt;E&gt; expected) throws Exception {
 621       return expectError(expected, env.defaultTimeoutMillis());
 622     }
 623 
 624     public &lt;E extends Throwable&gt; E expectError(Class&lt;E&gt; expected, long timeoutMillis) throws Exception {
 625       return expectError(expected, timeoutMillis, env.defaultPollTimeoutMillis());
 626     }
 627 
 628     public &lt;E extends Throwable&gt; E expectError(Class&lt;E&gt; expected, String errorMsg) throws Exception {
 629       return expectError(expected, env.defaultTimeoutMillis(), errorMsg);
 630     }
 631 
 632     public &lt;E extends Throwable&gt; E expectError(Class&lt;E&gt; expected, long timeoutMillis, String errorMsg) throws Exception {
 633       return expectError(expected, timeoutMillis, env.defaultPollTimeoutMillis(), errorMsg);
 634     }
 635 
 636     public &lt;E extends Throwable&gt; E expectError(Class&lt;E&gt; expected, long totalTimeoutMillis, long pollTimeoutMillis) throws Exception {
 637       return expectError(expected, totalTimeoutMillis, pollTimeoutMillis, String.format(&quot;Expected onError(%s)&quot;, expected.getName()));
 638     }
 639 
 640     public &lt;E extends Throwable&gt; E expectError(Class&lt;E&gt; expected, long totalTimeoutMillis, long pollTimeoutMillis,
 641                                                String errorMsg) throws Exception {
 642       return received.expectError(expected, totalTimeoutMillis, pollTimeoutMillis, errorMsg);
 643     }
 644 
 645     public void expectNone() throws InterruptedException {
 646       expectNone(env.defaultNoSignalsTimeoutMillis());
 647     }
 648 
 649     public void expectNone(String errMsgPrefix) throws InterruptedException {
 650       expectNone(env.defaultNoSignalsTimeoutMillis(), errMsgPrefix);
 651     }
 652 
 653     public void expectNone(long withinMillis) throws InterruptedException {
 654       expectNone(withinMillis, &quot;Did not expect an element but got element&quot;);
 655     }
 656 
 657     public void expectNone(long withinMillis, String errMsgPrefix) throws InterruptedException {
 658       received.expectNone(withinMillis, errMsgPrefix);
 659     }
 660 
 661   }
 662 
 663   public static class ManualSubscriberWithSubscriptionSupport&lt;T&gt; extends ManualSubscriber&lt;T&gt; {
 664 
 665     public ManualSubscriberWithSubscriptionSupport(TestEnvironment env) {
 666       super(env);
 667     }
 668 
 669     @Override
 670     public void onNext(T element) {
 671       if (env.debugEnabled()) {
 672         env.debug(String.format(&quot;%s::onNext(%s)&quot;, this, element));
 673       }
 674       if (subscription.isCompleted()) {
 675         super.onNext(element);
 676       } else {
 677         env.flop(String.format(&quot;Subscriber::onNext(%s) called before Subscriber::onSubscribe&quot;, element));
 678       }
 679     }
 680 
 681     @Override
 682     public void onComplete() {
 683       if (env.debugEnabled()) {
 684         env.debug(this + &quot;::onComplete()&quot;);
 685       }
 686       if (subscription.isCompleted()) {
 687         super.onComplete();
 688       } else {
 689         env.flop(&quot;Subscriber::onComplete() called before Subscriber::onSubscribe&quot;);
 690       }
 691     }
 692 
 693     @Override
 694     public void onSubscribe(Subscription s) {
 695       if (env.debugEnabled()) {
 696         env.debug(String.format(&quot;%s::onSubscribe(%s)&quot;, this, s));
 697       }
 698       if (!subscription.isCompleted()) {
 699         subscription.complete(s);
 700       } else {
 701         env.flop(&quot;Subscriber::onSubscribe called on an already-subscribed Subscriber&quot;);
 702       }
 703     }
 704 
 705     @Override
 706     public void onError(Throwable cause) {
 707       if (env.debugEnabled()) {
 708         env.debug(String.format(&quot;%s::onError(%s)&quot;, this, cause));
 709       }
 710       if (subscription.isCompleted()) {
 711         super.onError(cause);
 712       } else {
 713         env.flop(cause, String.format(&quot;Subscriber::onError(%s) called before Subscriber::onSubscribe&quot;, cause));
 714       }
 715     }
 716   }
 717 
 718   /**
 719    * Similar to {@link org.reactivestreams.tck.TestEnvironment.ManualSubscriberWithSubscriptionSupport}
 720    * but does not accumulate values signalled via &lt;code&gt;onNext&lt;/code&gt;, thus it can not be used to assert
 721    * values signalled to this subscriber. Instead it may be used to quickly drain a given publisher.
 722    */
 723   public static class BlackholeSubscriberWithSubscriptionSupport&lt;T&gt;
 724     extends ManualSubscriberWithSubscriptionSupport&lt;T&gt; {
 725 
 726     public BlackholeSubscriberWithSubscriptionSupport(TestEnvironment env) {
 727       super(env);
 728     }
 729 
 730     @Override
 731     public void onNext(T element) {
 732       if (env.debugEnabled()) {
 733         env.debug(String.format(&quot;%s::onNext(%s)&quot;, this, element));
 734       }
 735       if (!subscription.isCompleted()) {
 736         env.flop(String.format(&quot;Subscriber::onNext(%s) called before Subscriber::onSubscribe&quot;, element));
 737       }
 738     }
 739 
 740     @Override
 741     public T nextElement(long timeoutMillis, String errorMsg) throws InterruptedException {
 742       throw new RuntimeException(&quot;Can not expect elements from BlackholeSubscriber, use ManualSubscriber instead!&quot;);
 743     }
 744 
 745     @Override
 746     public List&lt;T&gt; nextElements(long elements, long timeoutMillis, String errorMsg) throws InterruptedException {
 747       throw new RuntimeException(&quot;Can not expect elements from BlackholeSubscriber, use ManualSubscriber instead!&quot;);
 748     }
 749   }
 750 
 751   public static class TestSubscriber&lt;T&gt; implements Subscriber&lt;T&gt; {
 752     final Promise&lt;Subscription&gt; subscription;
 753 
 754     protected final TestEnvironment env;
 755 
 756     public TestSubscriber(TestEnvironment env) {
 757       this.env = env;
 758       subscription = new Promise&lt;Subscription&gt;(env);
 759     }
 760 
 761     @Override
 762     public void onError(Throwable cause) {
 763       env.flop(cause, String.format(&quot;Unexpected Subscriber::onError(%s)&quot;, cause));
 764     }
 765 
 766     @Override
 767     public void onComplete() {
 768       env.flop(&quot;Unexpected Subscriber::onComplete()&quot;);
 769     }
 770 
 771     @Override
 772     public void onNext(T element) {
 773       env.flop(String.format(&quot;Unexpected Subscriber::onNext(%s)&quot;, element));
 774     }
 775 
 776     @Override
 777     public void onSubscribe(Subscription subscription) {
 778       env.flop(String.format(&quot;Unexpected Subscriber::onSubscribe(%s)&quot;, subscription));
 779     }
 780 
 781     public void cancel() {
 782       if (subscription.isCompleted()) {
 783         subscription.value().cancel();
 784       } else {
 785         env.flop(&quot;Cannot cancel a subscription before having received it&quot;);
 786       }
 787     }
 788   }
 789 
 790   public static class ManualPublisher&lt;T&gt; implements Publisher&lt;T&gt; {
 791     protected final TestEnvironment env;
 792 
 793     protected long pendingDemand = 0L;
 794     protected Promise&lt;Subscriber&lt;? super T&gt;&gt; subscriber;
 795 
 796     protected final Receptacle&lt;Long&gt; requests;
 797 
 798     protected final Latch cancelled;
 799 
 800     public ManualPublisher(TestEnvironment env) {
 801       this.env = env;
 802       requests = new Receptacle&lt;Long&gt;(env);
 803       cancelled = new Latch(env);
 804       subscriber = new Promise&lt;Subscriber&lt;? super T&gt;&gt;(this.env);
 805     }
 806 
 807     @Override
 808     public void subscribe(Subscriber&lt;? super T&gt; s) {
 809       if (!subscriber.isCompleted()) {
 810         subscriber.completeImmediatly(s);
 811 
 812         Subscription subs = new Subscription() {
 813           @Override
 814           public void request(long elements) {
 815             requests.add(elements);
 816           }
 817 
 818           @Override
 819           public void cancel() {
 820             cancelled.close();
 821           }
 822         };
 823         s.onSubscribe(subs);
 824 
 825       } else {
 826         env.flop(&quot;TestPublisher doesn&#39;t support more than one Subscriber&quot;);
 827       }
 828     }
 829 
 830     public void sendNext(T element) {
 831       if (subscriber.isCompleted()) {
 832         subscriber.value().onNext(element);
 833       } else {
 834         env.flop(&quot;Cannot sendNext before having a Subscriber&quot;);
 835       }
 836     }
 837 
 838     public void sendCompletion() {
 839       if (subscriber.isCompleted()) {
 840         subscriber.value().onComplete();
 841       } else {
 842         env.flop(&quot;Cannot sendCompletion before having a Subscriber&quot;);
 843       }
 844     }
 845 
 846     public void sendError(Throwable cause) {
 847       if (subscriber.isCompleted()) {
 848         subscriber.value().onError(cause);
 849       } else {
 850         env.flop(&quot;Cannot sendError before having a Subscriber&quot;);
 851       }
 852     }
 853 
 854     public long expectRequest() throws InterruptedException {
 855       return expectRequest(env.defaultTimeoutMillis());
 856     }
 857 
 858     public long expectRequest(long timeoutMillis) throws InterruptedException {
 859       long requested = requests.next(timeoutMillis, &quot;Did not receive expected `request` call&quot;);
 860       if (requested &lt;= 0) {
 861         return env.&lt;Long&gt;flopAndFail(String.format(&quot;Requests cannot be zero or negative but received request(%s)&quot;, requested));
 862       } else {
 863         pendingDemand += requested;
 864         return requested;
 865       }
 866     }
 867 
 868 
 869     public long expectRequest(long timeoutMillis, String errorMessageAddendum) throws InterruptedException {
 870       long requested = requests.next(timeoutMillis, String.format(&quot;Did not receive expected `request` call. %s&quot;, errorMessageAddendum));
 871       if (requested &lt;= 0) {
 872         return env.&lt;Long&gt;flopAndFail(String.format(&quot;Requests cannot be zero or negative but received request(%s)&quot;, requested));
 873       } else {
 874         pendingDemand += requested;
 875         return requested;
 876       }
 877     }
 878 
 879     public void expectExactRequest(long expected) throws InterruptedException {
 880       expectExactRequest(expected, env.defaultTimeoutMillis());
 881     }
 882 
 883     public void expectExactRequest(long expected, long timeoutMillis) throws InterruptedException {
 884       long requested = expectRequest(timeoutMillis);
 885       if (requested != expected) {
 886         env.flop(String.format(&quot;Received `request(%d)` on upstream but expected `request(%d)`&quot;, requested, expected));
 887       }
 888       pendingDemand += requested;
 889     }
 890 
 891     public void expectNoRequest() throws InterruptedException {
 892       expectNoRequest(env.defaultTimeoutMillis());
 893     }
 894 
 895     public void expectNoRequest(long timeoutMillis) throws InterruptedException {
 896       requests.expectNone(timeoutMillis, &quot;Received an unexpected call to: request: &quot;);
 897     }
 898 
 899     public void expectCancelling() throws InterruptedException {
 900       expectCancelling(env.defaultTimeoutMillis());
 901     }
 902 
 903     public void expectCancelling(long timeoutMillis) throws InterruptedException {
 904       cancelled.expectClose(timeoutMillis, &quot;Did not receive expected cancelling of upstream subscription&quot;);
 905     }
 906 
 907     public boolean isCancelled() throws InterruptedException {
 908       return cancelled.isClosed();
 909     }
 910   }
 911 
 912   /**
 913    * Like a CountDownLatch, but resettable and with some convenience methods
 914    */
 915   public static class Latch {
 916     private final TestEnvironment env;
 917     volatile private CountDownLatch countDownLatch = new CountDownLatch(1);
 918 
 919     public Latch(TestEnvironment env) {
 920       this.env = env;
 921     }
 922 
 923     public void reOpen() {
 924       countDownLatch = new CountDownLatch(1);
 925     }
 926 
 927     public boolean isClosed() {
 928       return countDownLatch.getCount() == 0;
 929     }
 930 
 931     public void close() {
 932       countDownLatch.countDown();
 933     }
 934 
 935     public void assertClosed(String openErrorMsg) {
 936       if (!isClosed()) {
 937         env.flop(new ExpectedClosedLatchException(openErrorMsg));
 938       }
 939     }
 940 
 941     public void assertOpen(String closedErrorMsg) {
 942       if (isClosed()) {
 943         env.flop(new ExpectedOpenLatchException(closedErrorMsg));
 944       }
 945     }
 946 
 947     public void expectClose(String notClosedErrorMsg) throws InterruptedException {
 948       expectClose(env.defaultTimeoutMillis(), notClosedErrorMsg);
 949     }
 950 
 951     public void expectClose(long timeoutMillis, String notClosedErrorMsg) throws InterruptedException {
 952       countDownLatch.await(timeoutMillis, TimeUnit.MILLISECONDS);
 953       if (countDownLatch.getCount() &gt; 0) {
 954         env.flop(String.format(&quot;%s within %d ms&quot;, notClosedErrorMsg, timeoutMillis));
 955       }
 956     }
 957 
 958     static final class ExpectedOpenLatchException extends RuntimeException {
 959       public ExpectedOpenLatchException(String message) {
 960         super(message);
 961       }
 962     }
 963 
 964     static final class ExpectedClosedLatchException extends RuntimeException {
 965       public ExpectedClosedLatchException(String message) {
 966         super(message);
 967       }
 968     }
 969 
 970   }
 971 
 972   // simple promise for *one* value, which cannot be reset
 973   public static class Promise&lt;T&gt; {
 974     private final TestEnvironment env;
 975 
 976     public static &lt;T&gt; Promise&lt;T&gt; completed(TestEnvironment env, T value) {
 977       Promise&lt;T&gt; promise = new Promise&lt;T&gt;(env);
 978       promise.completeImmediatly(value);
 979       return promise;
 980     }
 981 
 982     public Promise(TestEnvironment env) {
 983       this.env = env;
 984     }
 985 
 986     private ArrayBlockingQueue&lt;T&gt; abq = new ArrayBlockingQueue&lt;T&gt;(1);
 987     private AtomicReference&lt;T&gt; _value = new AtomicReference&lt;T&gt;();
 988 
 989     public T value() {
 990       final T value = _value.get();
 991       if (value != null) {
 992         return value;
 993       } else {
 994         env.flop(&quot;Cannot access promise value before completion&quot;);
 995         return null;
 996       }
 997     }
 998 
 999     public boolean isCompleted() {
1000       return _value.get() != null;
1001     }
1002 
1003     /**
1004      * Allows using expectCompletion to await for completion of the value and complete it _then_
1005      */
1006     public void complete(T value) {
1007       if (_value.compareAndSet(null, value)) {
1008         // we add the value to the queue such to wake up any expectCompletion which was triggered before complete() was called
1009         abq.add(value);
1010       } else {
1011         env.flop(String.format(&quot;Cannot complete a promise more than once! Present value: %s, attempted to set: %s&quot;, _value.get(), value));
1012       }
1013     }
1014 
1015     /**
1016      * Same as complete.
1017      *
1018      * Keeping this method for binary compatibility.
1019      */
1020     public void completeImmediatly(T value) {
1021       complete(value);
1022     }
1023 
1024     public void expectCompletion(long timeoutMillis, String errorMsg) throws InterruptedException {
1025       if (!isCompleted()) {
1026         T val = abq.poll(timeoutMillis, TimeUnit.MILLISECONDS);
1027 
1028         if (val == null) {
1029           env.flop(String.format(&quot;%s within %d ms&quot;, errorMsg, timeoutMillis));
1030         }
1031       }
1032     }
1033   }
1034 
1035   // a &quot;Promise&quot; for multiple values, which also supports &quot;end-of-stream reached&quot;
1036   public static class Receptacle&lt;T&gt; {
1037     final int QUEUE_SIZE = 2 * TEST_BUFFER_SIZE;
1038     private final TestEnvironment env;
1039 
1040     private final ArrayBlockingQueue&lt;Optional&lt;T&gt;&gt; abq = new ArrayBlockingQueue&lt;Optional&lt;T&gt;&gt;(QUEUE_SIZE);
1041 
1042     private final Latch completedLatch;
1043 
1044     Receptacle(TestEnvironment env) {
1045       this.env = env;
1046       this.completedLatch = new Latch(env);
1047     }
1048 
1049     public void add(T value) {
1050       completedLatch.assertOpen(String.format(&quot;Unexpected element %s received after stream completed&quot;, value));
1051 
1052       abq.add(Optional.of(value));
1053     }
1054 
1055     public void complete() {
1056       completedLatch.assertOpen(&quot;Unexpected additional complete signal received!&quot;);
1057       completedLatch.close();
1058 
1059       abq.add(Optional.&lt;T&gt;empty());
1060     }
1061 
1062     public T next(long timeoutMillis, String errorMsg) throws InterruptedException {
1063       Optional&lt;T&gt; value = abq.poll(timeoutMillis, TimeUnit.MILLISECONDS);
1064 
1065       if (value == null) {
1066         return env.flopAndFail(String.format(&quot;%s within %d ms&quot;, errorMsg, timeoutMillis));
1067       } else if (value.isDefined()) {
1068         return value.get();
1069       } else {
1070         return env.flopAndFail(&quot;Expected element but got end-of-stream&quot;);
1071       }
1072     }
1073 
1074     public Optional&lt;T&gt; nextOrEndOfStream(long timeoutMillis, String errorMsg) throws InterruptedException {
1075       Optional&lt;T&gt; value = abq.poll(timeoutMillis, TimeUnit.MILLISECONDS);
1076 
1077       if (value == null) {
1078         env.flop(String.format(&quot;%s within %d ms&quot;, errorMsg, timeoutMillis));
1079         return Optional.empty();
1080       }
1081 
1082       return value;
1083     }
1084 
1085     /**
1086      * @param timeoutMillis total timeout time for awaiting all {@code elements} number of elements
1087      */
1088     public List&lt;T&gt; nextN(long elements, long timeoutMillis, String errorMsg) throws InterruptedException {
1089       List&lt;T&gt; result = new LinkedList&lt;T&gt;();
1090       long remaining = elements;
1091       long deadline = System.currentTimeMillis() + timeoutMillis;
1092       while (remaining &gt; 0) {
1093         long remainingMillis = deadline - System.currentTimeMillis();
1094 
1095         result.add(next(remainingMillis, errorMsg));
1096         remaining--;
1097       }
1098 
1099       return result;
1100     }
1101 
1102 
1103     public void expectCompletion(long timeoutMillis, String errorMsg) throws InterruptedException {
1104       Optional&lt;T&gt; value = abq.poll(timeoutMillis, TimeUnit.MILLISECONDS);
1105 
1106       if (value == null) {
1107         env.flop(String.format(&quot;%s within %d ms&quot;, errorMsg, timeoutMillis));
1108       } else if (value.isDefined()) {
1109         env.flop(String.format(&quot;Expected end-of-stream but got element [%s]&quot;, value.get()));
1110       } // else, ok
1111     }
1112 
1113     /**
1114      * @deprecated Deprecated in favor of {@link #expectError(Class, long, long, String)}.
1115      */
1116     @Deprecated
1117     public &lt;E extends Throwable&gt; E expectError(Class&lt;E&gt; clazz, long timeoutMillis, String errorMsg) throws Exception {
1118       return expectError(clazz, timeoutMillis, timeoutMillis, errorMsg);
1119     }
1120 
1121     @SuppressWarnings(&quot;unchecked&quot;)
1122     final &lt;E extends Throwable&gt; E expectError(Class&lt;E&gt; clazz, final long totalTimeoutMillis,
1123                                               long pollTimeoutMillis,
1124                                               String errorMsg) throws Exception {
1125       long totalTimeoutRemainingNs = MILLISECONDS.toNanos(totalTimeoutMillis);
1126       long timeStampANs = System.nanoTime();
1127       long timeStampBNs;
1128 
1129       for (;;) {
1130         Thread.sleep(Math.min(pollTimeoutMillis, NANOSECONDS.toMillis(totalTimeoutRemainingNs)));
1131 
1132         if (env.asyncErrors.isEmpty()) {
1133           timeStampBNs = System.nanoTime();
1134           totalTimeoutRemainingNs =- timeStampBNs - timeStampANs;
1135           timeStampANs = timeStampBNs;
1136 
1137           if (totalTimeoutRemainingNs &lt;= 0) {
1138             return env.flopAndFail(String.format(&quot;%s within %d ms&quot;, errorMsg, totalTimeoutMillis));
1139           }
1140         } else {
1141           // ok, there was an expected error
1142           Throwable thrown = env.asyncErrors.remove(0);
1143 
1144           if (clazz.isInstance(thrown)) {
1145             return (E) thrown;
1146           } else {
1147 
1148             return env.flopAndFail(String.format(&quot;%s within %d ms; Got %s but expected %s&quot;,
1149                     errorMsg, totalTimeoutMillis, thrown.getClass().getCanonicalName(), clazz.getCanonicalName()));
1150           }
1151         }
1152       }
1153     }
1154 
1155     public void expectNone(long withinMillis, String errorMsgPrefix) throws InterruptedException {
1156       Thread.sleep(withinMillis);
1157       Optional&lt;T&gt; value = abq.poll();
1158 
1159       if (value == null) {
1160         // ok
1161       } else if (value.isDefined()) {
1162         env.flop(String.format(&quot;%s [%s]&quot;, errorMsgPrefix, value.get()));
1163       } else {
1164         env.flop(&quot;Expected no element but got end-of-stream&quot;);
1165       }
1166     }
1167   }
1168 }
    </pre>
  </body>
</html>
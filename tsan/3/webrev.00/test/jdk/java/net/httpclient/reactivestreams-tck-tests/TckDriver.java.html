<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New test/jdk/java/net/httpclient/reactivestreams-tck-tests/TckDriver.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 /*
 25  * @test
 26  * @bug 8226602
 27  * @summary Tests convenience reactive primitives with RS TCK
 28  *
 29  * @library ../reactivestreams-tck
 30  * @build S
 31  *
 32  * @compile -encoding UTF-8 SPublisherOfStream.java
 33  *
 34  * @compile -encoding UTF-8 BodyPublishersFromPublisher.java
 35  * @compile -encoding UTF-8 BodyPublishersNoBody.java
 36  * @compile -encoding UTF-8 BodyPublishersOfByteArray.java
 37  * @compile -encoding UTF-8 BodyPublishersOfByteArrays.java
 38  * @compile -encoding UTF-8 BodyPublishersOfFile.java
 39  * @compile -encoding UTF-8 BodyPublishersOfInputStream.java
 40  * @compile -encoding UTF-8 BodyPublishersOfSubByteArray.java
 41  *
 42  * @compile -encoding UTF-8 BodySubscribersBuffering.java
 43  * @compile -encoding UTF-8 BodySubscribersDiscarding.java
 44  * @compile -encoding UTF-8 BodySubscribersFromLineSubscriber.java
 45  * @compile -encoding UTF-8 BodySubscribersFromSubscriber.java
 46  * @compile -encoding UTF-8 BodySubscribersMapping.java
 47  * @compile -encoding UTF-8 BodySubscribersOfByteArray.java
 48  * @compile -encoding UTF-8 BodySubscribersOfByteArrayConsumer.java
 49  * @compile -encoding UTF-8 BodySubscribersOfFile.java
 50  * @compile -encoding UTF-8 BodySubscribersOfInputStream.java
 51  * @compile -encoding UTF-8 BodySubscribersOfLines.java
 52  * @compile -encoding UTF-8 BodySubscribersOfPublisher.java
 53  * @compile -encoding UTF-8 BodySubscribersOfPublisher1.java
 54  * @compile -encoding UTF-8 BodySubscribersOfPublisherPublisher.java
 55  * @compile -encoding UTF-8 BodySubscribersOfString.java
 56  * @compile -encoding UTF-8 BodySubscribersReplacing.java
 57  *
 58  * @run testng/othervm STest
 59  * @run testng/othervm SPublisherOfStream
 60  *
 61  * @run testng/othervm BodyPublishersFromPublisher
 62  * @run testng/othervm BodyPublishersNoBody
 63  * @run testng/othervm BodyPublishersOfByteArray
 64  * @run testng/othervm BodyPublishersOfByteArrays
 65  * @run testng/othervm BodyPublishersOfFile
 66  * @run testng/othervm BodyPublishersOfInputStream
 67  * @run testng/othervm BodyPublishersOfSubByteArray
 68  *
 69  * @run testng/othervm BodySubscribersBuffering
 70  * @run testng/othervm BodySubscribersDiscarding
 71  * @run testng/othervm BodySubscribersFromLineSubscriber
 72  * @run testng/othervm BodySubscribersFromSubscriber
 73  * @run testng/othervm BodySubscribersMapping
 74  * @run testng/othervm BodySubscribersOfByteArray
 75  * @run testng/othervm BodySubscribersOfByteArrayConsumer
 76  * @run testng/othervm BodySubscribersOfFile
 77  * @run testng/othervm BodySubscribersOfInputStream
 78  * @run testng/othervm BodySubscribersOfLines
 79  * @run testng/othervm BodySubscribersOfPublisher
 80  * @run testng/othervm BodySubscribersOfPublisher1
 81  * @run testng/othervm BodySubscribersOfPublisherPublisher
 82  * @run testng/othervm BodySubscribersOfString
 83  * @run testng/othervm BodySubscribersReplacing
 84  *
 85  * @key randomness
 86  */
 87 public class TckDriver {
 88    /*
 89         #### General Information
 90 
 91         1. This JTREG test aggregates multiple TestNG tests. This is because
 92         these tests share a common library (reactivestreams-tck), and we don&#39;t
 93         want this library to be compiled separately for each of those tests.
 94 
 95         2. Tests that use RS TCK are compiled with the UTF-8 encoding. This is
 96         performed for the sake of reactivestreams-tck. We don&#39;t want to patch
 97         the TCK because of the extra merging work in the future, should we bring
 98         update(s) from the RS repo.
 99 
100         #### Tests
101 
102         1. The purpose of each test should be easily digestible. The name of the
103         test is derived from the very entity the test exercises. For example,
104 
105             the BodyPublishersOfFile test exercises the BodyPublisher obtained
106             by calling BodyPublishers.ofFile(Path)
107 
108             the BodySubscribersOfFile test exercises the BodySubscriber obtained
109             by calling BodySubscribers.ofFile(Path)
110 
111         2. RS TCK requires PublisherVerification tests to produce publishers
112         capable of emitting a certain number of elements. In order to achieve
113         this, we use some knowledge of the internal workings of our publishers.
114         An example would be a chunk size a publisher uses to deliver a portion
115         of data. Without knowing that it is not possible to guarantee that the
116         publisher will emit a particular number of elements.
117 
118         3. Typically our publishers cannot be created in a known failed state.
119         In this case the corresponding `createFailedFlowPublisher` method
120         returns `null`.
121 
122         4. SubscriberBlackBoxVerification uses the `createElement(int element)`
123         method. Our implementations usually cap the amount of data created by
124         this method, because it&#39;s not known beforehand how big the `element`
125         value is. Hence, sometimes there&#39;s code like as follows:
126 
127             @Override
128             public List&lt;ByteBuffer&gt; createElement(int element) {
129                 return scatterBuffer(
130                         bufferOfNRandomASCIIBytes(element % 17));
131             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^
132             }
133 
134         5. The amount of testing RS TCK performs on a publisher seems to depend
135         on the number of elements this publisher reports it can emit. Sometimes
136         a code like the following can be seen in the tests:
137 
138                 @Override public long maxElementsFromPublisher() {
139                     return 21;
140                 ~~~~~~~~~~~^
141                 }
142 
143         This magic number is a result of trial and error and seems to unlock
144         most of the tests. Reporting big values (e.g. Long.MAX_VALUE - 1) is
145         not an option for most of our publishers because they require to have
146         all the elements upfront.
147 
148         6. It doesn&#39;t seem currently feasible to provide SubscriberWhiteboxVerification
149         tests as a) it&#39;s not clear how much better the coverage is and b) it&#39;s
150         significantly harder to code that.
151 
152         #### S (Support)
153 
154         Support utilities are being tested (STest) too.
155     */
156 }
    </pre>
  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff test/jdk/java/net/httpclient/websocket/WebSocketProxyTest.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
<body>
<center><a href="SendTest.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="WebSocketTest.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>test/jdk/java/net/httpclient/websocket/WebSocketProxyTest.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 /*
 25  * @test
<span class="line-modified"> 26  * @bug 8217429</span>
 27  * @summary WebSocket proxy tunneling tests
<span class="line-modified"> 28  * @compile DummyWebSocketServer.java ../ProxyServer.java</span>


 29  * @run testng/othervm



 30  *         -Djdk.http.auth.tunneling.disabledSchemes=
 31  *         WebSocketProxyTest
 32  */
 33 
 34 import java.io.IOException;
 35 import java.io.UncheckedIOException;
 36 import java.net.Authenticator;
 37 import java.net.InetAddress;
 38 import java.net.InetSocketAddress;
 39 import java.net.PasswordAuthentication;
 40 import java.net.ProxySelector;
 41 import java.net.http.HttpResponse;
 42 import java.net.http.WebSocket;
 43 import java.net.http.WebSocketHandshakeException;
 44 import java.nio.ByteBuffer;
 45 import java.nio.charset.StandardCharsets;
 46 import java.util.ArrayList;
 47 import java.util.Base64;
 48 import java.util.List;
 49 import java.util.concurrent.CompletableFuture;
 50 import java.util.concurrent.CompletionException;
 51 import java.util.concurrent.CompletionStage;
 52 import java.util.function.Function;
 53 import java.util.function.Supplier;
 54 import java.util.stream.Collectors;


 55 import org.testng.annotations.BeforeMethod;
 56 import org.testng.annotations.DataProvider;
 57 import org.testng.annotations.Test;



 58 import static java.net.http.HttpClient.newBuilder;
 59 import static java.nio.charset.StandardCharsets.UTF_8;
 60 import static org.testng.Assert.assertEquals;
 61 import static org.testng.FileAssert.fail;
 62 
 63 public class WebSocketProxyTest {
 64 
 65     // Used to verify a proxy/websocket server requiring Authentication
 66     private static final String USERNAME = &quot;wally&quot;;
 67     private static final String PASSWORD = &quot;xyz987&quot;;
 68 








 69     static class WSAuthenticator extends Authenticator {
 70         @Override
 71         protected PasswordAuthentication getPasswordAuthentication() {
 72             return new PasswordAuthentication(USERNAME, PASSWORD.toCharArray());
 73         }
 74     }
 75 
<span class="line-modified"> 76     static final Function&lt;int[],DummyWebSocketServer&gt; SERVER_WITH_CANNED_DATA =</span>
 77         new Function&lt;&gt;() {
<span class="line-modified"> 78             @Override public DummyWebSocketServer apply(int[] data) {</span>
<span class="line-modified"> 79                 return Support.serverWithCannedData(data); }</span>
 80             @Override public String toString() { return &quot;SERVER_WITH_CANNED_DATA&quot;; }
 81         };
 82 
<span class="line-modified"> 83     static final Function&lt;int[],DummyWebSocketServer&gt; AUTH_SERVER_WITH_CANNED_DATA =</span>







 84         new Function&lt;&gt;() {
<span class="line-modified"> 85             @Override public DummyWebSocketServer apply(int[] data) {</span>
<span class="line-modified"> 86                 return Support.serverWithCannedDataAndAuthentication(USERNAME, PASSWORD, data); }</span>
 87             @Override public String toString() { return &quot;AUTH_SERVER_WITH_CANNED_DATA&quot;; }
 88         };
 89 







 90     static final Supplier&lt;ProxyServer&gt; TUNNELING_PROXY_SERVER =
 91         new Supplier&lt;&gt;() {
 92             @Override public ProxyServer get() {
 93                 try { return new ProxyServer(0, true);}
 94                 catch(IOException e) { throw new UncheckedIOException(e); } }
 95             @Override public String toString() { return &quot;TUNNELING_PROXY_SERVER&quot;; }
 96         };
 97     static final Supplier&lt;ProxyServer&gt; AUTH_TUNNELING_PROXY_SERVER =
 98         new Supplier&lt;&gt;() {
 99             @Override public ProxyServer get() {
100                 try { return new ProxyServer(0, true, USERNAME, PASSWORD);}
101                 catch(IOException e) { throw new UncheckedIOException(e); } }
102             @Override public String toString() { return &quot;AUTH_TUNNELING_PROXY_SERVER&quot;; }
103         };
104 
105     @DataProvider(name = &quot;servers&quot;)
106     public Object[][] servers() {
107         return new Object[][] {
<span class="line-modified">108             { SERVER_WITH_CANNED_DATA,      TUNNELING_PROXY_SERVER      },</span>
<span class="line-modified">109             { SERVER_WITH_CANNED_DATA,      AUTH_TUNNELING_PROXY_SERVER },</span>
<span class="line-modified">110             { AUTH_SERVER_WITH_CANNED_DATA, TUNNELING_PROXY_SERVER      },</span>





111         };
112     }
113 
114     @Test(dataProvider = &quot;servers&quot;)
115     public void simpleAggregatingBinaryMessages
<span class="line-modified">116             (Function&lt;int[],DummyWebSocketServer&gt; serverSupplier,</span>
117              Supplier&lt;ProxyServer&gt; proxyServerSupplier)
118         throws IOException
119     {
120         List&lt;byte[]&gt; expected = List.of(&quot;hello&quot;, &quot;chegar&quot;)
121                 .stream()
122                 .map(s -&gt; s.getBytes(StandardCharsets.US_ASCII))
123                 .collect(Collectors.toList());
124         int[] binary = new int[]{
125                 0x82, 0x05, 0x68, 0x65, 0x6C, 0x6C, 0x6F,       // hello
126                 0x82, 0x06, 0x63, 0x68, 0x65, 0x67, 0x61, 0x72, // chegar
127                 0x88, 0x00                                      // &lt;CLOSE&gt;
128         };
129         CompletableFuture&lt;List&lt;byte[]&gt;&gt; actual = new CompletableFuture&lt;&gt;();
130 
131         try (var proxyServer = proxyServerSupplier.get();
132              var server = serverSupplier.apply(binary)) {
133 
134             InetSocketAddress proxyAddress = new InetSocketAddress(
135                     InetAddress.getLoopbackAddress(), proxyServer.getPort());
136             server.open();


137 
138             WebSocket.Listener listener = new WebSocket.Listener() {
139 
140                 List&lt;byte[]&gt; collectedBytes = new ArrayList&lt;&gt;();
141                 ByteBuffer buffer = ByteBuffer.allocate(1024);
142 
143                 @Override
144                 public CompletionStage&lt;?&gt; onBinary(WebSocket webSocket,
145                                                    ByteBuffer message,
146                                                    boolean last) {
147                     System.out.printf(&quot;onBinary(%s, %s)%n&quot;, message, last);
148                     webSocket.request(1);
149 
150                     append(message);
151                     if (last) {
152                         buffer.flip();
153                         byte[] bytes = new byte[buffer.remaining()];
154                         buffer.get(bytes);
155                         buffer.clear();
156                         processWholeBinary(bytes);
</pre>
<hr />
<pre>
192             var webSocket = newBuilder()
193                     .proxy(ProxySelector.of(proxyAddress))
194                     .authenticator(new WSAuthenticator())
195                     .build().newWebSocketBuilder()
196                     .buildAsync(server.getURI(), listener)
197                     .join();
198 
199             List&lt;byte[]&gt; a = actual.join();
200             assertEquals(a, expected);
201         }
202     }
203 
204     // -- authentication specific tests
205 
206     /*
207      * Ensures authentication succeeds when an Authenticator set on client builder.
208      */
209     @Test
210     public void clientAuthenticate() throws IOException  {
211         try (var proxyServer = AUTH_TUNNELING_PROXY_SERVER.get();
<span class="line-modified">212              var server = new DummyWebSocketServer()){</span>
213             server.open();
214             InetSocketAddress proxyAddress = new InetSocketAddress(
215                     InetAddress.getLoopbackAddress(), proxyServer.getPort());
216 
217             var webSocket = newBuilder()
218                     .proxy(ProxySelector.of(proxyAddress))
219                     .authenticator(new WSAuthenticator())
220                     .build()
221                     .newWebSocketBuilder()
222                     .buildAsync(server.getURI(), new WebSocket.Listener() { })
223                     .join();
224         }
225     }
226 
227     /*
228      * Ensures authentication succeeds when an `Authorization` header is explicitly set.
229      */
230     @Test
231     public void explicitAuthenticate() throws IOException  {
232         try (var proxyServer = AUTH_TUNNELING_PROXY_SERVER.get();
<span class="line-modified">233              var server = new DummyWebSocketServer()) {</span>























234             server.open();
235             InetSocketAddress proxyAddress = new InetSocketAddress(
236                     InetAddress.getLoopbackAddress(), proxyServer.getPort());
237 
238             String hv = &quot;Basic &quot; + Base64.getEncoder().encodeToString(
239                     (USERNAME + &quot;:&quot; + PASSWORD).getBytes(UTF_8));
240 
241             var webSocket = newBuilder()
242                     .proxy(ProxySelector.of(proxyAddress)).build()
243                     .newWebSocketBuilder()
244                     .header(&quot;Proxy-Authorization&quot;, hv)

245                     .buildAsync(server.getURI(), new WebSocket.Listener() { })
246                     .join();
247         }
248     }
249 
250     /*
251      * Ensures authentication does not succeed when no authenticator is present.
252      */
253     @Test
254     public void failNoAuthenticator() throws IOException  {
255         try (var proxyServer = AUTH_TUNNELING_PROXY_SERVER.get();
<span class="line-modified">256              var server = new DummyWebSocketServer(USERNAME, PASSWORD)) {</span>
257             server.open();
258             InetSocketAddress proxyAddress = new InetSocketAddress(
259                     InetAddress.getLoopbackAddress(), proxyServer.getPort());
260 
261             CompletableFuture&lt;WebSocket&gt; cf = newBuilder()
262                     .proxy(ProxySelector.of(proxyAddress)).build()
263                     .newWebSocketBuilder()
264                     .buildAsync(server.getURI(), new WebSocket.Listener() { });
265 
266             try {
267                 var webSocket = cf.join();
268                 fail(&quot;Expected exception not thrown&quot;);
269             } catch (CompletionException expected) {
270                 WebSocketHandshakeException e = (WebSocketHandshakeException)expected.getCause();
271                 HttpResponse&lt;?&gt; response = e.getResponse();
272                 assertEquals(response.statusCode(), 407);
273             }
274         }
275     }
276 
277     /*
278      * Ensures authentication does not succeed when the authenticator presents
279      * unauthorized credentials.
280      */
281     @Test
282     public void failBadCredentials() throws IOException  {
283         try (var proxyServer = AUTH_TUNNELING_PROXY_SERVER.get();
<span class="line-modified">284              var server = new DummyWebSocketServer(USERNAME, PASSWORD)) {</span>
285             server.open();
286             InetSocketAddress proxyAddress = new InetSocketAddress(
287                     InetAddress.getLoopbackAddress(), proxyServer.getPort());
288 
289             Authenticator authenticator = new Authenticator() {
290                 @Override protected PasswordAuthentication getPasswordAuthentication() {
291                     return new PasswordAuthentication(&quot;BAD&quot;+USERNAME, &quot;&quot;.toCharArray());
292                 }
293             };
294 
295             CompletableFuture&lt;WebSocket&gt; cf = newBuilder()
296                     .proxy(ProxySelector.of(proxyAddress))
297                     .authenticator(authenticator)
298                     .build()
299                     .newWebSocketBuilder()
300                     .buildAsync(server.getURI(), new WebSocket.Listener() { });
301 
302             try {
303                 var webSocket = cf.join();
304                 fail(&quot;Expected exception not thrown&quot;);
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2019, 2020, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 /*
 25  * @test
<span class="line-modified"> 26  * @bug 8217429 8236859</span>
 27  * @summary WebSocket proxy tunneling tests
<span class="line-modified"> 28  * @library /test/lib</span>
<span class="line-added"> 29  * @compile SecureSupport.java DummySecureWebSocketServer.java ../ProxyServer.java</span>
<span class="line-added"> 30  * @build jdk.test.lib.net.SimpleSSLContext WebSocketProxyTest</span>
 31  * @run testng/othervm
<span class="line-added"> 32  *         -Djdk.internal.httpclient.debug=true</span>
<span class="line-added"> 33  *         -Djdk.internal.httpclient.websocket.debug=true</span>
<span class="line-added"> 34  *         -Djdk.httpclient.HttpClient.log=errors,requests,headers</span>
 35  *         -Djdk.http.auth.tunneling.disabledSchemes=
 36  *         WebSocketProxyTest
 37  */
 38 
 39 import java.io.IOException;
 40 import java.io.UncheckedIOException;
 41 import java.net.Authenticator;
 42 import java.net.InetAddress;
 43 import java.net.InetSocketAddress;
 44 import java.net.PasswordAuthentication;
 45 import java.net.ProxySelector;
 46 import java.net.http.HttpResponse;
 47 import java.net.http.WebSocket;
 48 import java.net.http.WebSocketHandshakeException;
 49 import java.nio.ByteBuffer;
 50 import java.nio.charset.StandardCharsets;
 51 import java.util.ArrayList;
 52 import java.util.Base64;
 53 import java.util.List;
 54 import java.util.concurrent.CompletableFuture;
 55 import java.util.concurrent.CompletionException;
 56 import java.util.concurrent.CompletionStage;
 57 import java.util.function.Function;
 58 import java.util.function.Supplier;
 59 import java.util.stream.Collectors;
<span class="line-added"> 60 </span>
<span class="line-added"> 61 import jdk.test.lib.net.SimpleSSLContext;</span>
 62 import org.testng.annotations.BeforeMethod;
 63 import org.testng.annotations.DataProvider;
 64 import org.testng.annotations.Test;
<span class="line-added"> 65 </span>
<span class="line-added"> 66 import javax.net.ssl.SSLContext;</span>
<span class="line-added"> 67 </span>
 68 import static java.net.http.HttpClient.newBuilder;
 69 import static java.nio.charset.StandardCharsets.UTF_8;
 70 import static org.testng.Assert.assertEquals;
 71 import static org.testng.FileAssert.fail;
 72 
 73 public class WebSocketProxyTest {
 74 
 75     // Used to verify a proxy/websocket server requiring Authentication
 76     private static final String USERNAME = &quot;wally&quot;;
 77     private static final String PASSWORD = &quot;xyz987&quot;;
 78 
<span class="line-added"> 79     static {</span>
<span class="line-added"> 80         try {</span>
<span class="line-added"> 81             SSLContext.setDefault(new SimpleSSLContext().get());</span>
<span class="line-added"> 82         } catch (IOException ex) {</span>
<span class="line-added"> 83             throw new ExceptionInInitializerError(ex);</span>
<span class="line-added"> 84         }</span>
<span class="line-added"> 85     }</span>
<span class="line-added"> 86 </span>
 87     static class WSAuthenticator extends Authenticator {
 88         @Override
 89         protected PasswordAuthentication getPasswordAuthentication() {
 90             return new PasswordAuthentication(USERNAME, PASSWORD.toCharArray());
 91         }
 92     }
 93 
<span class="line-modified"> 94     static final Function&lt;int[],DummySecureWebSocketServer&gt; SERVER_WITH_CANNED_DATA =</span>
 95         new Function&lt;&gt;() {
<span class="line-modified"> 96             @Override public DummySecureWebSocketServer apply(int[] data) {</span>
<span class="line-modified"> 97                 return SecureSupport.serverWithCannedData(data); }</span>
 98             @Override public String toString() { return &quot;SERVER_WITH_CANNED_DATA&quot;; }
 99         };
100 
<span class="line-modified">101     static final Function&lt;int[],DummySecureWebSocketServer&gt; SSL_SERVER_WITH_CANNED_DATA =</span>
<span class="line-added">102             new Function&lt;&gt;() {</span>
<span class="line-added">103                 @Override public DummySecureWebSocketServer apply(int[] data) {</span>
<span class="line-added">104                     return SecureSupport.serverWithCannedData(data).secure(); }</span>
<span class="line-added">105                 @Override public String toString() { return &quot;SSL_SERVER_WITH_CANNED_DATA&quot;; }</span>
<span class="line-added">106             };</span>
<span class="line-added">107 </span>
<span class="line-added">108     static final Function&lt;int[],DummySecureWebSocketServer&gt; AUTH_SERVER_WITH_CANNED_DATA =</span>
109         new Function&lt;&gt;() {
<span class="line-modified">110             @Override public DummySecureWebSocketServer apply(int[] data) {</span>
<span class="line-modified">111                 return SecureSupport.serverWithCannedDataAndAuthentication(USERNAME, PASSWORD, data); }</span>
112             @Override public String toString() { return &quot;AUTH_SERVER_WITH_CANNED_DATA&quot;; }
113         };
114 
<span class="line-added">115     static final Function&lt;int[],DummySecureWebSocketServer&gt; AUTH_SSL_SVR_WITH_CANNED_DATA =</span>
<span class="line-added">116             new Function&lt;&gt;() {</span>
<span class="line-added">117                 @Override public DummySecureWebSocketServer apply(int[] data) {</span>
<span class="line-added">118                     return SecureSupport.serverWithCannedDataAndAuthentication(USERNAME, PASSWORD, data).secure(); }</span>
<span class="line-added">119                 @Override public String toString() { return &quot;AUTH_SSL_SVR_WITH_CANNED_DATA&quot;; }</span>
<span class="line-added">120             };</span>
<span class="line-added">121 </span>
122     static final Supplier&lt;ProxyServer&gt; TUNNELING_PROXY_SERVER =
123         new Supplier&lt;&gt;() {
124             @Override public ProxyServer get() {
125                 try { return new ProxyServer(0, true);}
126                 catch(IOException e) { throw new UncheckedIOException(e); } }
127             @Override public String toString() { return &quot;TUNNELING_PROXY_SERVER&quot;; }
128         };
129     static final Supplier&lt;ProxyServer&gt; AUTH_TUNNELING_PROXY_SERVER =
130         new Supplier&lt;&gt;() {
131             @Override public ProxyServer get() {
132                 try { return new ProxyServer(0, true, USERNAME, PASSWORD);}
133                 catch(IOException e) { throw new UncheckedIOException(e); } }
134             @Override public String toString() { return &quot;AUTH_TUNNELING_PROXY_SERVER&quot;; }
135         };
136 
137     @DataProvider(name = &quot;servers&quot;)
138     public Object[][] servers() {
139         return new Object[][] {
<span class="line-modified">140             { SERVER_WITH_CANNED_DATA,       TUNNELING_PROXY_SERVER      },</span>
<span class="line-modified">141             { SERVER_WITH_CANNED_DATA,       AUTH_TUNNELING_PROXY_SERVER },</span>
<span class="line-modified">142             { SSL_SERVER_WITH_CANNED_DATA,   TUNNELING_PROXY_SERVER      },</span>
<span class="line-added">143             { SSL_SERVER_WITH_CANNED_DATA,   AUTH_TUNNELING_PROXY_SERVER },</span>
<span class="line-added">144             { AUTH_SERVER_WITH_CANNED_DATA,  TUNNELING_PROXY_SERVER      },</span>
<span class="line-added">145             { AUTH_SSL_SVR_WITH_CANNED_DATA, TUNNELING_PROXY_SERVER      },</span>
<span class="line-added">146             { AUTH_SERVER_WITH_CANNED_DATA,  AUTH_TUNNELING_PROXY_SERVER },</span>
<span class="line-added">147             { AUTH_SSL_SVR_WITH_CANNED_DATA, AUTH_TUNNELING_PROXY_SERVER },</span>
148         };
149     }
150 
151     @Test(dataProvider = &quot;servers&quot;)
152     public void simpleAggregatingBinaryMessages
<span class="line-modified">153             (Function&lt;int[],DummySecureWebSocketServer&gt; serverSupplier,</span>
154              Supplier&lt;ProxyServer&gt; proxyServerSupplier)
155         throws IOException
156     {
157         List&lt;byte[]&gt; expected = List.of(&quot;hello&quot;, &quot;chegar&quot;)
158                 .stream()
159                 .map(s -&gt; s.getBytes(StandardCharsets.US_ASCII))
160                 .collect(Collectors.toList());
161         int[] binary = new int[]{
162                 0x82, 0x05, 0x68, 0x65, 0x6C, 0x6C, 0x6F,       // hello
163                 0x82, 0x06, 0x63, 0x68, 0x65, 0x67, 0x61, 0x72, // chegar
164                 0x88, 0x00                                      // &lt;CLOSE&gt;
165         };
166         CompletableFuture&lt;List&lt;byte[]&gt;&gt; actual = new CompletableFuture&lt;&gt;();
167 
168         try (var proxyServer = proxyServerSupplier.get();
169              var server = serverSupplier.apply(binary)) {
170 
171             InetSocketAddress proxyAddress = new InetSocketAddress(
172                     InetAddress.getLoopbackAddress(), proxyServer.getPort());
173             server.open();
<span class="line-added">174             System.out.println(&quot;Server: &quot; + server.getURI());</span>
<span class="line-added">175             System.out.println(&quot;Proxy: &quot; + proxyAddress);</span>
176 
177             WebSocket.Listener listener = new WebSocket.Listener() {
178 
179                 List&lt;byte[]&gt; collectedBytes = new ArrayList&lt;&gt;();
180                 ByteBuffer buffer = ByteBuffer.allocate(1024);
181 
182                 @Override
183                 public CompletionStage&lt;?&gt; onBinary(WebSocket webSocket,
184                                                    ByteBuffer message,
185                                                    boolean last) {
186                     System.out.printf(&quot;onBinary(%s, %s)%n&quot;, message, last);
187                     webSocket.request(1);
188 
189                     append(message);
190                     if (last) {
191                         buffer.flip();
192                         byte[] bytes = new byte[buffer.remaining()];
193                         buffer.get(bytes);
194                         buffer.clear();
195                         processWholeBinary(bytes);
</pre>
<hr />
<pre>
231             var webSocket = newBuilder()
232                     .proxy(ProxySelector.of(proxyAddress))
233                     .authenticator(new WSAuthenticator())
234                     .build().newWebSocketBuilder()
235                     .buildAsync(server.getURI(), listener)
236                     .join();
237 
238             List&lt;byte[]&gt; a = actual.join();
239             assertEquals(a, expected);
240         }
241     }
242 
243     // -- authentication specific tests
244 
245     /*
246      * Ensures authentication succeeds when an Authenticator set on client builder.
247      */
248     @Test
249     public void clientAuthenticate() throws IOException  {
250         try (var proxyServer = AUTH_TUNNELING_PROXY_SERVER.get();
<span class="line-modified">251              var server = new DummySecureWebSocketServer()){</span>
252             server.open();
253             InetSocketAddress proxyAddress = new InetSocketAddress(
254                     InetAddress.getLoopbackAddress(), proxyServer.getPort());
255 
256             var webSocket = newBuilder()
257                     .proxy(ProxySelector.of(proxyAddress))
258                     .authenticator(new WSAuthenticator())
259                     .build()
260                     .newWebSocketBuilder()
261                     .buildAsync(server.getURI(), new WebSocket.Listener() { })
262                     .join();
263         }
264     }
265 
266     /*
267      * Ensures authentication succeeds when an `Authorization` header is explicitly set.
268      */
269     @Test
270     public void explicitAuthenticate() throws IOException  {
271         try (var proxyServer = AUTH_TUNNELING_PROXY_SERVER.get();
<span class="line-modified">272              var server = new DummySecureWebSocketServer()) {</span>
<span class="line-added">273             server.open();</span>
<span class="line-added">274             InetSocketAddress proxyAddress = new InetSocketAddress(</span>
<span class="line-added">275                     InetAddress.getLoopbackAddress(), proxyServer.getPort());</span>
<span class="line-added">276 </span>
<span class="line-added">277             String hv = &quot;Basic &quot; + Base64.getEncoder().encodeToString(</span>
<span class="line-added">278                     (USERNAME + &quot;:&quot; + PASSWORD).getBytes(UTF_8));</span>
<span class="line-added">279 </span>
<span class="line-added">280             var webSocket = newBuilder()</span>
<span class="line-added">281                     .proxy(ProxySelector.of(proxyAddress)).build()</span>
<span class="line-added">282                     .newWebSocketBuilder()</span>
<span class="line-added">283                     .header(&quot;Proxy-Authorization&quot;, hv)</span>
<span class="line-added">284                     .buildAsync(server.getURI(), new WebSocket.Listener() { })</span>
<span class="line-added">285                     .join();</span>
<span class="line-added">286         }</span>
<span class="line-added">287     }</span>
<span class="line-added">288 </span>
<span class="line-added">289     /*</span>
<span class="line-added">290      * Ensures authentication succeeds when an `Authorization` header is explicitly set.</span>
<span class="line-added">291      */</span>
<span class="line-added">292     @Test</span>
<span class="line-added">293     public void explicitAuthenticate2() throws IOException  {</span>
<span class="line-added">294         try (var proxyServer = AUTH_TUNNELING_PROXY_SERVER.get();</span>
<span class="line-added">295              var server = new DummySecureWebSocketServer(USERNAME, PASSWORD).secure()) {</span>
296             server.open();
297             InetSocketAddress proxyAddress = new InetSocketAddress(
298                     InetAddress.getLoopbackAddress(), proxyServer.getPort());
299 
300             String hv = &quot;Basic &quot; + Base64.getEncoder().encodeToString(
301                     (USERNAME + &quot;:&quot; + PASSWORD).getBytes(UTF_8));
302 
303             var webSocket = newBuilder()
304                     .proxy(ProxySelector.of(proxyAddress)).build()
305                     .newWebSocketBuilder()
306                     .header(&quot;Proxy-Authorization&quot;, hv)
<span class="line-added">307                     .header(&quot;Authorization&quot;, hv)</span>
308                     .buildAsync(server.getURI(), new WebSocket.Listener() { })
309                     .join();
310         }
311     }
312 
313     /*
314      * Ensures authentication does not succeed when no authenticator is present.
315      */
316     @Test
317     public void failNoAuthenticator() throws IOException  {
318         try (var proxyServer = AUTH_TUNNELING_PROXY_SERVER.get();
<span class="line-modified">319              var server = new DummySecureWebSocketServer(USERNAME, PASSWORD)) {</span>
320             server.open();
321             InetSocketAddress proxyAddress = new InetSocketAddress(
322                     InetAddress.getLoopbackAddress(), proxyServer.getPort());
323 
324             CompletableFuture&lt;WebSocket&gt; cf = newBuilder()
325                     .proxy(ProxySelector.of(proxyAddress)).build()
326                     .newWebSocketBuilder()
327                     .buildAsync(server.getURI(), new WebSocket.Listener() { });
328 
329             try {
330                 var webSocket = cf.join();
331                 fail(&quot;Expected exception not thrown&quot;);
332             } catch (CompletionException expected) {
333                 WebSocketHandshakeException e = (WebSocketHandshakeException)expected.getCause();
334                 HttpResponse&lt;?&gt; response = e.getResponse();
335                 assertEquals(response.statusCode(), 407);
336             }
337         }
338     }
339 
340     /*
341      * Ensures authentication does not succeed when the authenticator presents
342      * unauthorized credentials.
343      */
344     @Test
345     public void failBadCredentials() throws IOException  {
346         try (var proxyServer = AUTH_TUNNELING_PROXY_SERVER.get();
<span class="line-modified">347              var server = new DummySecureWebSocketServer(USERNAME, PASSWORD)) {</span>
348             server.open();
349             InetSocketAddress proxyAddress = new InetSocketAddress(
350                     InetAddress.getLoopbackAddress(), proxyServer.getPort());
351 
352             Authenticator authenticator = new Authenticator() {
353                 @Override protected PasswordAuthentication getPasswordAuthentication() {
354                     return new PasswordAuthentication(&quot;BAD&quot;+USERNAME, &quot;&quot;.toCharArray());
355                 }
356             };
357 
358             CompletableFuture&lt;WebSocket&gt; cf = newBuilder()
359                     .proxy(ProxySelector.of(proxyAddress))
360                     .authenticator(authenticator)
361                     .build()
362                     .newWebSocketBuilder()
363                     .buildAsync(server.getURI(), new WebSocket.Listener() { });
364 
365             try {
366                 var webSocket = cf.join();
367                 fail(&quot;Expected exception not thrown&quot;);
</pre>
</td>
</tr>
</table>
<center><a href="SendTest.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="WebSocketTest.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames test/jdk/java/net/httpclient/AbstractThrowingPublishers.java</title>
    <link rel="stylesheet" href="../../../../../style.css" />
    <script type="text/javascript" src="../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
<a name="1" id="anc1"></a><span class="line-modified">  2  * Copyright (c) 2018, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 import com.sun.net.httpserver.HttpServer;
 25 import com.sun.net.httpserver.HttpsConfigurator;
 26 import com.sun.net.httpserver.HttpsServer;
 27 import jdk.test.lib.net.SimpleSSLContext;
<a name="2" id="anc2"></a>
 28 import org.testng.annotations.AfterClass;
 29 import org.testng.annotations.AfterTest;
<a name="3" id="anc3"></a>
 30 import org.testng.annotations.BeforeTest;
 31 import org.testng.annotations.DataProvider;
 32 import org.testng.annotations.Test;
 33 
 34 import javax.net.ssl.SSLContext;
 35 import java.io.IOException;
 36 import java.io.InputStream;
 37 import java.io.OutputStream;
 38 import java.io.UncheckedIOException;
 39 import java.net.InetAddress;
 40 import java.net.InetSocketAddress;
 41 import java.net.URI;
 42 import java.net.http.HttpClient;
 43 import java.net.http.HttpRequest;
 44 import java.net.http.HttpRequest.BodyPublisher;
 45 import java.net.http.HttpRequest.BodyPublishers;
 46 import java.net.http.HttpResponse;
 47 import java.net.http.HttpResponse.BodyHandler;
 48 import java.net.http.HttpResponse.BodyHandlers;
 49 import java.nio.ByteBuffer;
 50 import java.nio.charset.StandardCharsets;
 51 import java.util.EnumSet;
 52 import java.util.List;
 53 import java.util.Set;
 54 import java.util.concurrent.CompletableFuture;
 55 import java.util.concurrent.CompletionException;
 56 import java.util.concurrent.ConcurrentHashMap;
 57 import java.util.concurrent.ConcurrentMap;
 58 import java.util.concurrent.ExecutionException;
 59 import java.util.concurrent.Executor;
 60 import java.util.concurrent.Executors;
 61 import java.util.concurrent.Flow;
 62 import java.util.concurrent.SubmissionPublisher;
 63 import java.util.concurrent.atomic.AtomicLong;
 64 import java.util.function.BiPredicate;
 65 import java.util.function.Consumer;
 66 import java.util.function.Supplier;
 67 import java.util.stream.Collectors;
 68 import java.util.stream.Stream;
 69 
 70 import static java.lang.String.format;
 71 import static java.lang.System.out;
 72 import static java.nio.charset.StandardCharsets.UTF_8;
 73 import static org.testng.Assert.assertEquals;
 74 import static org.testng.Assert.assertTrue;
 75 
 76 public abstract class AbstractThrowingPublishers implements HttpServerAdapters {
 77 
 78     SSLContext sslContext;
 79     HttpTestServer httpTestServer;    // HTTP/1.1    [ 4 servers ]
 80     HttpTestServer httpsTestServer;   // HTTPS/1.1
 81     HttpTestServer http2TestServer;   // HTTP/2 ( h2c )
 82     HttpTestServer https2TestServer;  // HTTP/2 ( h2  )
 83     String httpURI_fixed;
 84     String httpURI_chunk;
 85     String httpsURI_fixed;
 86     String httpsURI_chunk;
 87     String http2URI_fixed;
 88     String http2URI_chunk;
 89     String https2URI_fixed;
 90     String https2URI_chunk;
 91 
 92     static final int ITERATION_COUNT = 1;
 93     // a shared executor helps reduce the amount of threads created by the test
 94     static final Executor executor = new TestExecutor(Executors.newCachedThreadPool());
 95     static final ConcurrentMap&lt;String, Throwable&gt; FAILURES = new ConcurrentHashMap&lt;&gt;();
 96     static volatile boolean tasksFailed;
 97     static final AtomicLong serverCount = new AtomicLong();
 98     static final AtomicLong clientCount = new AtomicLong();
 99     static final long start = System.nanoTime();
100     public static String now() {
101         long now = System.nanoTime() - start;
102         long secs = now / 1000_000_000;
103         long mill = (now % 1000_000_000) / 1000_000;
104         long nan = now % 1000_000;
105         return String.format(&quot;[%d s, %d ms, %d ns] &quot;, secs, mill, nan);
106     }
107 
108     final ReferenceTracker TRACKER = ReferenceTracker.INSTANCE;
109     private volatile HttpClient sharedClient;
110 
111     static class TestExecutor implements Executor {
112         final AtomicLong tasks = new AtomicLong();
113         Executor executor;
114         TestExecutor(Executor executor) {
115             this.executor = executor;
116         }
117 
118         @Override
119         public void execute(Runnable command) {
120             long id = tasks.incrementAndGet();
121             executor.execute(() -&gt; {
122                 try {
123                     command.run();
124                 } catch (Throwable t) {
125                     tasksFailed = true;
126                     System.out.printf(now() + &quot;Task %s failed: %s%n&quot;, id, t);
127                     System.err.printf(now() + &quot;Task %s failed: %s%n&quot;, id, t);
128                     FAILURES.putIfAbsent(&quot;Task &quot; + id, t);
129                     throw t;
130                 }
131             });
132         }
133     }
134 
<a name="4" id="anc4"></a>










135     @AfterClass
136     static final void printFailedTests() {
137         out.println(&quot;\n=========================&quot;);
138         try {
139             out.printf(&quot;%n%sCreated %d servers and %d clients%n&quot;,
140                     now(), serverCount.get(), clientCount.get());
141             if (FAILURES.isEmpty()) return;
142             out.println(&quot;Failed tests: &quot;);
143             FAILURES.entrySet().forEach((e) -&gt; {
144                 out.printf(&quot;\t%s: %s%n&quot;, e.getKey(), e.getValue());
145                 e.getValue().printStackTrace(out);
146             });
147             if (tasksFailed) {
148                 System.out.println(&quot;WARNING: Some tasks failed&quot;);
149             }
150         } finally {
151             out.println(&quot;\n=========================\n&quot;);
152         }
153     }
154 
155     private String[] uris() {
156         return new String[] {
157                 httpURI_fixed,
158                 httpURI_chunk,
159                 httpsURI_fixed,
160                 httpsURI_chunk,
161                 http2URI_fixed,
162                 http2URI_chunk,
163                 https2URI_fixed,
164                 https2URI_chunk,
165         };
166     }
167 
168     @DataProvider(name = &quot;sanity&quot;)
169     public Object[][] sanity() {
170         String[] uris = uris();
171         Object[][] result = new Object[uris.length * 2][];
172         //Object[][] result = new Object[uris.length][];
173         int i = 0;
174         for (boolean sameClient : List.of(false, true)) {
175             //if (!sameClient) continue;
176             for (String uri: uris()) {
177                 result[i++] = new Object[] {uri + &quot;/sanity&quot;, sameClient};
178             }
179         }
180         assert i == uris.length * 2;
181         // assert i == uris.length ;
182         return result;
183     }
184 
185     enum Where {
186         BEFORE_SUBSCRIBE, BEFORE_REQUEST, BEFORE_NEXT_REQUEST, BEFORE_CANCEL,
187         AFTER_SUBSCRIBE, AFTER_REQUEST, AFTER_NEXT_REQUEST, AFTER_CANCEL;
188         public Consumer&lt;Where&gt; select(Consumer&lt;Where&gt; consumer) {
189             return new Consumer&lt;Where&gt;() {
190                 @Override
191                 public void accept(Where where) {
192                     if (Where.this == where) {
193                         consumer.accept(where);
194                     }
195                 }
196             };
197         }
198     }
199 
200     private Object[][] variants(List&lt;Thrower&gt; throwers, Set&lt;Where&gt; whereValues) {
201         String[] uris = uris();
202         Object[][] result = new Object[uris.length * 2 * throwers.size()][];
203         //Object[][] result = new Object[(uris.length/2) * 2 * 2][];
204         int i = 0;
205         for (Thrower thrower : throwers) {
206             for (boolean sameClient : List.of(false, true)) {
207                 for (String uri : uris()) {
208                     // if (uri.contains(&quot;http2&quot;) || uri.contains(&quot;https2&quot;)) continue;
209                     // if (!sameClient) continue;
210                     result[i++] = new Object[]{uri, sameClient, thrower, whereValues};
211                 }
212             }
213         }
214         assert i == uris.length * 2 * throwers.size();
215         //assert Stream.of(result).filter(o -&gt; o != null).count() == result.length;
216         return result;
217     }
218 
219     @DataProvider(name = &quot;subscribeProvider&quot;)
<a name="5" id="anc5"></a><span class="line-modified">220     public Object[][] subscribeProvider() {</span>



221         return  variants(List.of(
222                 new UncheckedCustomExceptionThrower(),
223                 new UncheckedIOExceptionThrower()),
224                 EnumSet.of(Where.BEFORE_SUBSCRIBE, Where.AFTER_SUBSCRIBE));
225     }
226 
227     @DataProvider(name = &quot;requestProvider&quot;)
<a name="6" id="anc6"></a><span class="line-modified">228     public Object[][] requestProvider() {</span>



229         return  variants(List.of(
230                 new UncheckedCustomExceptionThrower(),
231                 new UncheckedIOExceptionThrower()),
232                 EnumSet.of(Where.BEFORE_REQUEST, Where.AFTER_REQUEST));
233     }
234 
235     @DataProvider(name = &quot;nextRequestProvider&quot;)
<a name="7" id="anc7"></a><span class="line-modified">236     public Object[][] nextRequestProvider() {</span>



237         return  variants(List.of(
238                 new UncheckedCustomExceptionThrower(),
239                 new UncheckedIOExceptionThrower()),
240                 EnumSet.of(Where.BEFORE_NEXT_REQUEST, Where.AFTER_NEXT_REQUEST));
241     }
242 
243     @DataProvider(name = &quot;beforeCancelProviderIO&quot;)
<a name="8" id="anc8"></a><span class="line-modified">244     public Object[][] beforeCancelProviderIO() {</span>



245         return  variants(List.of(
246                 new UncheckedIOExceptionThrower()),
247                 EnumSet.of(Where.BEFORE_CANCEL));
248     }
249 
250     @DataProvider(name = &quot;afterCancelProviderIO&quot;)
<a name="9" id="anc9"></a><span class="line-modified">251     public Object[][] afterCancelProviderIO() {</span>



252         return  variants(List.of(
253                 new UncheckedIOExceptionThrower()),
254                 EnumSet.of(Where.AFTER_CANCEL));
255     }
256 
257     @DataProvider(name = &quot;beforeCancelProviderCustom&quot;)
<a name="10" id="anc10"></a><span class="line-modified">258     public Object[][] beforeCancelProviderCustom() {</span>



259         return  variants(List.of(
260                 new UncheckedCustomExceptionThrower()),
261                 EnumSet.of(Where.BEFORE_CANCEL));
262     }
263 
264     @DataProvider(name = &quot;afterCancelProviderCustom&quot;)
<a name="11" id="anc11"></a><span class="line-modified">265     public Object[][] afterCancelProvider() {</span>



266         return  variants(List.of(
267                 new UncheckedCustomExceptionThrower()),
268                 EnumSet.of(Where.AFTER_CANCEL));
269     }
270 
271     private HttpClient makeNewClient() {
272         clientCount.incrementAndGet();
273         return TRACKER.track(HttpClient.newBuilder()
274                 .proxy(HttpClient.Builder.NO_PROXY)
275                 .executor(executor)
276                 .sslContext(sslContext)
277                 .build());
278     }
279 
280     HttpClient newHttpClient(boolean share) {
281         if (!share) return makeNewClient();
282         HttpClient shared = sharedClient;
283         if (shared != null) return shared;
284         synchronized (this) {
285             shared = sharedClient;
286             if (shared == null) {
287                 shared = sharedClient = makeNewClient();
288             }
289             return shared;
290         }
291     }
292 
293     final String BODY = &quot;Some string | that ? can | be split ? several | ways.&quot;;
294 
295     //@Test(dataProvider = &quot;sanity&quot;)
296     protected void testSanityImpl(String uri, boolean sameClient)
297             throws Exception {
298         HttpClient client = null;
299         out.printf(&quot;%n%s testSanity(%s, %b)%n&quot;, now(), uri, sameClient);
300         for (int i=0; i&lt; ITERATION_COUNT; i++) {
301             if (!sameClient || client == null)
302                 client = newHttpClient(sameClient);
303 
304             SubmissionPublisher&lt;ByteBuffer&gt; publisher
305                     = new SubmissionPublisher&lt;&gt;(executor,10);
306             ThrowingBodyPublisher bodyPublisher = new ThrowingBodyPublisher((w) -&gt; {},
307                     BodyPublishers.fromPublisher(publisher));
308             CompletableFuture&lt;Void&gt; subscribedCF = bodyPublisher.subscribedCF();
309             subscribedCF.whenComplete((r,t) -&gt; System.out.println(now() + &quot; subscribe completed &quot; + t))
310                     .thenAcceptAsync((v) -&gt; {
311                                 Stream.of(BODY.split(&quot;\\|&quot;))
312                                         .forEachOrdered(s -&gt; {
313                                                 System.out.println(&quot;submitting \&quot;&quot; + s +&quot;\&quot;&quot;);
314                                                 publisher.submit(ByteBuffer.wrap(s.getBytes(StandardCharsets.UTF_8)));
315                                         });
316                                 System.out.println(&quot;publishing done&quot;);
317                                 publisher.close();
318                             },
319                     executor);
320 
321             HttpRequest req = HttpRequest.newBuilder(URI.create(uri))
322                     .POST(bodyPublisher)
323                     .build();
324             BodyHandler&lt;String&gt; handler = BodyHandlers.ofString();
325             CompletableFuture&lt;HttpResponse&lt;String&gt;&gt; response = client.sendAsync(req, handler);
326 
327             String body = response.join().body();
328             assertEquals(body, Stream.of(BODY.split(&quot;\\|&quot;)).collect(Collectors.joining()));
329         }
330     }
331 
332     // @Test(dataProvider = &quot;variants&quot;)
333     protected void testThrowingAsStringImpl(String uri,
334                                      boolean sameClient,
335                                      Thrower thrower,
336                                      Set&lt;Where&gt; whereValues)
337             throws Exception
338     {
339         String test = format(&quot;testThrowingAsString(%s, %b, %s, %s)&quot;,
340                              uri, sameClient, thrower, whereValues);
341         List&lt;byte[]&gt; bytes = Stream.of(BODY.split(&quot;|&quot;))
342                 .map(s -&gt; s.getBytes(UTF_8))
343                 .collect(Collectors.toList());
344         testThrowing(test, uri, sameClient, () -&gt; BodyPublishers.ofByteArrays(bytes),
345                 this::shouldNotThrowInCancel, thrower,false, whereValues);
346     }
347 
348     private &lt;T,U&gt; void testThrowing(String name, String uri, boolean sameClient,
349                                     Supplier&lt;BodyPublisher&gt; publishers,
350                                     Finisher finisher, Thrower thrower,
351                                     boolean async, Set&lt;Where&gt; whereValues)
352             throws Exception
353     {
354         out.printf(&quot;%n%s%s%n&quot;, now(), name);
355         try {
356             testThrowing(uri, sameClient, publishers, finisher, thrower, async, whereValues);
357         } catch (Error | Exception x) {
358             FAILURES.putIfAbsent(name, x);
359             throw x;
360         }
361     }
362 
363     private void testThrowing(String uri, boolean sameClient,
364                                     Supplier&lt;BodyPublisher&gt; publishers,
365                                     Finisher finisher, Thrower thrower,
366                                     boolean async, Set&lt;Where&gt; whereValues)
367             throws Exception
368     {
369         HttpClient client = null;
370         for (Where where : whereValues) {
371             //if (where == Where.ON_SUBSCRIBE) continue;
372             //if (where == Where.ON_ERROR) continue;
373             if (!sameClient || client == null)
374                 client = newHttpClient(sameClient);
375 
376             ThrowingBodyPublisher bodyPublisher =
377                     new ThrowingBodyPublisher(where.select(thrower), publishers.get());
378             HttpRequest req = HttpRequest.
379                     newBuilder(URI.create(uri))
380                     .header(&quot;X-expect-exception&quot;, &quot;true&quot;)
381                     .POST(bodyPublisher)
382                     .build();
383             BodyHandler&lt;String&gt; handler = BodyHandlers.ofString();
384             System.out.println(&quot;try throwing in &quot; + where);
385             HttpResponse&lt;String&gt; response = null;
386             if (async) {
387                 try {
388                     response = client.sendAsync(req, handler).join();
389                 } catch (Error | Exception x) {
390                     Throwable cause = findCause(where, x, thrower);
391                     if (cause == null) throw causeNotFound(where, x);
392                     System.out.println(now() + &quot;Got expected exception: &quot; + cause);
393                 }
394             } else {
395                 try {
396                     response = client.send(req, handler);
397                 } catch (Error | Exception t) {
398                     // synchronous send will rethrow exceptions
399                     Throwable throwable = t.getCause();
400                     assert throwable != null;
401 
402                     if (thrower.test(where, throwable)) {
403                         System.out.println(now() + &quot;Got expected exception: &quot; + throwable);
404                     } else throw causeNotFound(where, t);
405                 }
406             }
407             if (response != null) {
408                 finisher.finish(where, response, thrower);
409             }
410         }
411     }
412 
413     // can be used to reduce the surface of the test when diagnosing
414     // some failure
415     Set&lt;Where&gt; whereValues() {
416         //return EnumSet.of(Where.BEFORE_CANCEL, Where.AFTER_CANCEL);
417         return EnumSet.allOf(Where.class);
418     }
419 
420     interface Thrower extends Consumer&lt;Where&gt;, BiPredicate&lt;Where,Throwable&gt; {
421 
422     }
423 
424     interface Finisher&lt;T,U&gt; {
425         U finish(Where w, HttpResponse&lt;T&gt; resp, Thrower thrower) throws IOException;
426     }
427 
428     final &lt;T,U&gt; U shouldNotThrowInCancel(Where w, HttpResponse&lt;T&gt; resp, Thrower thrower) {
429         switch (w) {
430             case BEFORE_CANCEL: return null;
431             case AFTER_CANCEL: return null;
432             default: break;
433         }
434         return shouldHaveThrown(w, resp, thrower);
435     }
436 
437 
438     final &lt;T,U&gt; U shouldHaveThrown(Where w, HttpResponse&lt;T&gt; resp, Thrower thrower) {
439         String msg = &quot;Expected exception not thrown in &quot; + w
440                 + &quot;\n\tReceived: &quot; + resp
441                 + &quot;\n\tWith body: &quot; + resp.body();
442         System.out.println(msg);
443         throw new RuntimeException(msg);
444     }
445 
446 
447     private static Throwable findCause(Where w,
448                                        Throwable x,
449                                        BiPredicate&lt;Where, Throwable&gt; filter) {
450         while (x != null &amp;&amp; !filter.test(w,x)) x = x.getCause();
451         return x;
452     }
453 
454     static AssertionError causeNotFound(Where w, Throwable t) {
455         return new AssertionError(&quot;Expected exception not found in &quot; + w, t);
456     }
457 
458     static boolean isConnectionClosedLocally(Throwable t) {
459         if (t instanceof CompletionException) t = t.getCause();
460         if (t instanceof ExecutionException) t = t.getCause();
461         if (t instanceof IOException) {
462             String msg = t.getMessage();
463             return msg == null ? false
464                     : msg.contains(&quot;connection closed locally&quot;);
465         }
466         return false;
467     }
468 
469     static final class UncheckedCustomExceptionThrower implements Thrower {
470         @Override
471         public void accept(Where where) {
472             out.println(now() + &quot;Throwing in &quot; + where);
473             throw new UncheckedCustomException(where.name());
474         }
475 
476         @Override
477         public boolean test(Where w, Throwable throwable) {
478             switch (w) {
479                 case AFTER_REQUEST:
480                 case BEFORE_NEXT_REQUEST:
481                 case AFTER_NEXT_REQUEST:
482                     if (isConnectionClosedLocally(throwable)) return true;
483                     break;
484                 default:
485                     break;
486             }
487             return UncheckedCustomException.class.isInstance(throwable);
488         }
489 
490         @Override
491         public String toString() {
492             return &quot;UncheckedCustomExceptionThrower&quot;;
493         }
494     }
495 
496     static final class UncheckedIOExceptionThrower implements Thrower {
497         @Override
498         public void accept(Where where) {
499             out.println(now() + &quot;Throwing in &quot; + where);
500             throw new UncheckedIOException(new CustomIOException(where.name()));
501         }
502 
503         @Override
504         public boolean test(Where w, Throwable throwable) {
505             switch (w) {
506                 case AFTER_REQUEST:
507                 case BEFORE_NEXT_REQUEST:
508                 case AFTER_NEXT_REQUEST:
509                     if (isConnectionClosedLocally(throwable)) return true;
510                     break;
511                 default:
512                     break;
513             }
514             return UncheckedIOException.class.isInstance(throwable)
515                     &amp;&amp; CustomIOException.class.isInstance(throwable.getCause());
516         }
517 
518         @Override
519         public String toString() {
520             return &quot;UncheckedIOExceptionThrower&quot;;
521         }
522     }
523 
524     static final class UncheckedCustomException extends RuntimeException {
525         UncheckedCustomException(String message) {
526             super(message);
527         }
528         UncheckedCustomException(String message, Throwable cause) {
529             super(message, cause);
530         }
531     }
532 
533     static final class CustomIOException extends IOException {
534         CustomIOException(String message) {
535             super(message);
536         }
537         CustomIOException(String message, Throwable cause) {
538             super(message, cause);
539         }
540     }
541 
542 
543     static final class ThrowingBodyPublisher implements BodyPublisher {
544         private final BodyPublisher publisher;
545         private final CompletableFuture&lt;Void&gt; subscribedCF = new CompletableFuture&lt;&gt;();
546         final Consumer&lt;Where&gt; throwing;
547         ThrowingBodyPublisher(Consumer&lt;Where&gt; throwing, BodyPublisher publisher) {
548             this.throwing = throwing;
549             this.publisher = publisher;
550         }
551 
552         @Override
553         public long contentLength() {
554             return publisher.contentLength();
555         }
556 
557         @Override
558         public void subscribe(Flow.Subscriber&lt;? super ByteBuffer&gt; subscriber) {
559             try {
560                 throwing.accept(Where.BEFORE_SUBSCRIBE);
561                 publisher.subscribe(new SubscriberWrapper(subscriber));
562                 subscribedCF.complete(null);
563                 throwing.accept(Where.AFTER_SUBSCRIBE);
564             } catch (Throwable t) {
565                 subscribedCF.completeExceptionally(t);
566                 throw t;
567             }
568         }
569 
570         CompletableFuture&lt;Void&gt; subscribedCF() {
571             return subscribedCF;
572         }
573 
574         class SubscriptionWrapper implements Flow.Subscription {
575             final Flow.Subscription subscription;
576             final AtomicLong requestCount = new AtomicLong();
577             SubscriptionWrapper(Flow.Subscription subscription) {
578                 this.subscription = subscription;
579             }
580             @Override
581             public void request(long n) {
582                 long count = requestCount.incrementAndGet();
583                 System.out.printf(&quot;%s request-%d(%d)%n&quot;, now(), count, n);
584                 if (count &gt; 1) throwing.accept(Where.BEFORE_NEXT_REQUEST);
585                 throwing.accept(Where.BEFORE_REQUEST);
586                 subscription.request(n);
587                 throwing.accept(Where.AFTER_REQUEST);
588                 if (count &gt; 1) throwing.accept(Where.AFTER_NEXT_REQUEST);
589             }
590 
591             @Override
592             public void cancel() {
593                 throwing.accept(Where.BEFORE_CANCEL);
594                 subscription.cancel();
595                 throwing.accept(Where.AFTER_CANCEL);
596             }
597         }
598 
599         class SubscriberWrapper implements Flow.Subscriber&lt;ByteBuffer&gt; {
600             final Flow.Subscriber&lt;? super ByteBuffer&gt; subscriber;
601             SubscriberWrapper(Flow.Subscriber&lt;? super ByteBuffer&gt; subscriber) {
602                 this.subscriber = subscriber;
603             }
604             @Override
605             public void onSubscribe(Flow.Subscription subscription) {
606                 subscriber.onSubscribe(new SubscriptionWrapper(subscription));
607             }
608             @Override
609             public void onNext(ByteBuffer item) {
610                 subscriber.onNext(item);
611             }
612             @Override
613             public void onComplete() {
614                 subscriber.onComplete();
615             }
616 
617             @Override
618             public void onError(Throwable throwable) {
619                 subscriber.onError(throwable);
620             }
621         }
622     }
623 
624 
625     @BeforeTest
626     public void setup() throws Exception {
627         sslContext = new SimpleSSLContext().get();
628         if (sslContext == null)
629             throw new AssertionError(&quot;Unexpected null sslContext&quot;);
630 
631         // HTTP/1.1
632         HttpTestHandler h1_fixedLengthHandler = new HTTP_FixedLengthHandler();
633         HttpTestHandler h1_chunkHandler = new HTTP_ChunkedHandler();
634         InetSocketAddress sa = new InetSocketAddress(InetAddress.getLoopbackAddress(), 0);
635         httpTestServer = HttpTestServer.of(HttpServer.create(sa, 0));
636         httpTestServer.addHandler(h1_fixedLengthHandler, &quot;/http1/fixed&quot;);
637         httpTestServer.addHandler(h1_chunkHandler, &quot;/http1/chunk&quot;);
638         httpURI_fixed = &quot;http://&quot; + httpTestServer.serverAuthority() + &quot;/http1/fixed/x&quot;;
639         httpURI_chunk = &quot;http://&quot; + httpTestServer.serverAuthority() + &quot;/http1/chunk/x&quot;;
640 
641         HttpsServer httpsServer = HttpsServer.create(sa, 0);
642         httpsServer.setHttpsConfigurator(new HttpsConfigurator(sslContext));
643         httpsTestServer = HttpTestServer.of(httpsServer);
644         httpsTestServer.addHandler(h1_fixedLengthHandler, &quot;/https1/fixed&quot;);
645         httpsTestServer.addHandler(h1_chunkHandler, &quot;/https1/chunk&quot;);
646         httpsURI_fixed = &quot;https://&quot; + httpsTestServer.serverAuthority() + &quot;/https1/fixed/x&quot;;
647         httpsURI_chunk = &quot;https://&quot; + httpsTestServer.serverAuthority() + &quot;/https1/chunk/x&quot;;
648 
649         // HTTP/2
650         HttpTestHandler h2_fixedLengthHandler = new HTTP_FixedLengthHandler();
651         HttpTestHandler h2_chunkedHandler = new HTTP_ChunkedHandler();
652 
653         http2TestServer = HttpTestServer.of(new Http2TestServer(&quot;localhost&quot;, false, 0));
654         http2TestServer.addHandler(h2_fixedLengthHandler, &quot;/http2/fixed&quot;);
655         http2TestServer.addHandler(h2_chunkedHandler, &quot;/http2/chunk&quot;);
656         http2URI_fixed = &quot;http://&quot; + http2TestServer.serverAuthority() + &quot;/http2/fixed/x&quot;;
657         http2URI_chunk = &quot;http://&quot; + http2TestServer.serverAuthority() + &quot;/http2/chunk/x&quot;;
658 
659         https2TestServer = HttpTestServer.of(new Http2TestServer(&quot;localhost&quot;, true, sslContext));
660         https2TestServer.addHandler(h2_fixedLengthHandler, &quot;/https2/fixed&quot;);
661         https2TestServer.addHandler(h2_chunkedHandler, &quot;/https2/chunk&quot;);
662         https2URI_fixed = &quot;https://&quot; + https2TestServer.serverAuthority() + &quot;/https2/fixed/x&quot;;
663         https2URI_chunk = &quot;https://&quot; + https2TestServer.serverAuthority() + &quot;/https2/chunk/x&quot;;
664 
665         serverCount.addAndGet(4);
666         httpTestServer.start();
667         httpsTestServer.start();
668         http2TestServer.start();
669         https2TestServer.start();
670     }
671 
672     @AfterTest
673     public void teardown() throws Exception {
674         String sharedClientName =
675                 sharedClient == null ? null : sharedClient.toString();
676         sharedClient = null;
677         Thread.sleep(100);
678         AssertionError fail = TRACKER.check(500);
679         try {
680             httpTestServer.stop();
681             httpsTestServer.stop();
682             http2TestServer.stop();
683             https2TestServer.stop();
684         } finally {
685             if (fail != null) {
686                 if (sharedClientName != null) {
687                     System.err.println(&quot;Shared client name is: &quot; + sharedClientName);
688                 }
689                 throw fail;
690             }
691         }
692     }
693 
694     static class HTTP_FixedLengthHandler implements HttpTestHandler {
695         @Override
696         public void handle(HttpTestExchange t) throws IOException {
697             out.println(&quot;HTTP_FixedLengthHandler received request to &quot; + t.getRequestURI());
698             byte[] resp;
699             try (InputStream is = t.getRequestBody()) {
700                 resp = is.readAllBytes();
701             }
702             t.sendResponseHeaders(200, resp.length);  //fixed content length
703             try (OutputStream os = t.getResponseBody()) {
704                 os.write(resp);
705             }
706         }
707     }
708 
709     static class HTTP_ChunkedHandler implements HttpTestHandler {
710         @Override
711         public void handle(HttpTestExchange t) throws IOException {
712             out.println(&quot;HTTP_ChunkedHandler received request to &quot; + t.getRequestURI());
713             byte[] resp;
714             try (InputStream is = t.getRequestBody()) {
715                 resp = is.readAllBytes();
716             }
717             t.sendResponseHeaders(200, -1); // chunked/variable
718             try (OutputStream os = t.getResponseBody()) {
719                 os.write(resp);
720             }
721         }
722     }
723 
724 }
<a name="12" id="anc12"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="12" type="hidden" />
</body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old test/jdk/java/net/httpclient/ShortResponseBody.java</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2018, 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 /*
 25  * @test
 26  * @bug 8216498
 27  * @summary Tests Exception detail message when too few response bytes are
 28  *          received before a socket exception or eof.
 29  * @library /test/lib
 30  * @build jdk.test.lib.net.SimpleSSLContext
 31  * @run testng/othervm
 32  *       -Djdk.httpclient.HttpClient.log=headers,errors,channel
 33  *       ShortResponseBody
 34  */
 35 
 36 import java.io.IOException;
 37 import java.io.InputStream;
 38 import java.io.OutputStream;
 39 import java.io.UncheckedIOException;
 40 import java.net.InetAddress;
 41 import java.net.InetSocketAddress;
 42 import java.net.ServerSocket;
 43 import java.net.Socket;
 44 import java.net.URI;
 45 import java.net.http.HttpClient;
 46 import java.net.http.HttpRequest;
 47 import java.net.http.HttpRequest.BodyPublishers;
 48 import java.net.http.HttpResponse;
 49 import java.util.ArrayList;
 50 import java.util.Arrays;
 51 import java.util.List;
 52 import java.util.concurrent.ExecutionException;
 53 import java.util.concurrent.Executor;
 54 import java.util.concurrent.ExecutorService;
 55 import java.util.concurrent.Executors;
 56 import java.util.concurrent.ThreadFactory;
 57 import java.util.concurrent.atomic.AtomicLong;
 58 import java.util.stream.Stream;
 59 import jdk.test.lib.net.SimpleSSLContext;
 60 import org.testng.annotations.AfterTest;
 61 import org.testng.annotations.BeforeTest;
 62 import org.testng.annotations.DataProvider;
 63 import org.testng.annotations.Test;
 64 import javax.net.ssl.SSLContext;
 65 import javax.net.ssl.SSLHandshakeException;
 66 import javax.net.ssl.SSLServerSocketFactory;
 67 import javax.net.ssl.SSLParameters;
 68 import javax.net.ssl.SSLSocket;
 69 import static java.lang.System.out;
 70 import static java.net.http.HttpClient.Builder.NO_PROXY;
 71 import static java.net.http.HttpResponse.BodyHandlers.ofString;
 72 import static java.nio.charset.StandardCharsets.US_ASCII;
 73 import static java.util.stream.Collectors.toList;
 74 import static org.testng.Assert.assertTrue;
 75 import static org.testng.Assert.assertEquals;
 76 import static org.testng.Assert.fail;
 77 
 78 public class ShortResponseBody {
 79 
 80     Server closeImmediatelyServer;
 81     Server closeImmediatelyHttpsServer;
 82     Server variableLengthServer;
 83     Server variableLengthHttpsServer;
 84     Server fixedLengthServer;
 85 
 86     String httpURIClsImed;
 87     String httpsURIClsImed;
 88     String httpURIVarLen;
 89     String httpsURIVarLen;
 90     String httpURIFixLen;
 91 
 92     SSLContext sslContext;
 93     SSLParameters sslParameters;
 94 
 95     static final String EXPECTED_RESPONSE_BODY =
 96             &quot;&lt;html&gt;&lt;body&gt;&lt;h1&gt;Heading&lt;/h1&gt;&lt;p&gt;Some Text&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;&quot;;
 97 
 98     final static AtomicLong ids = new AtomicLong();
 99     final ThreadFactory factory = new ThreadFactory() {
100         @Override
101         public Thread newThread(Runnable r) {
102             Thread thread = new Thread(r,  &quot;HttpClient-Worker-&quot; + ids.incrementAndGet());
103             thread.setDaemon(true);
104             return thread;
105         }
106     };
107     final ExecutorService service = Executors.newCachedThreadPool(factory);
108 
109     @DataProvider(name = &quot;sanity&quot;)
110     public Object[][] sanity() {
111         return new Object[][]{
112             { httpURIVarLen  + &quot;?length=all&quot; },
113             { httpsURIVarLen + &quot;?length=all&quot; },
114             { httpURIFixLen  + &quot;?length=all&quot; },
115         };
116     }
117 
118     @Test(dataProvider = &quot;sanity&quot;)
119     void sanity(String url) throws Exception {
120         HttpClient client = newHttpClient();
121         HttpRequest request = HttpRequest.newBuilder(URI.create(url)).build();
122         HttpResponse&lt;String&gt; response = client.send(request, ofString());
123         String body = response.body();
124         assertEquals(body, EXPECTED_RESPONSE_BODY);
125         client.sendAsync(request, ofString())
126                 .thenApply(resp -&gt; resp.body())
127                 .thenAccept(b -&gt; assertEquals(b, EXPECTED_RESPONSE_BODY))
128                 .join();
129     }
130 
131     @DataProvider(name = &quot;uris&quot;)
132     public Object[][] variants() {
133         String[][] cases = new String[][] {
134             // The length query string is the total number of bytes in the reply,
135             // including headers, before the server closes the connection. The
136             // second arg is a partial-expected-detail message in the exception.
137             { httpURIVarLen + &quot;?length=0&quot;,   &quot;no bytes&quot;     }, // EOF without receiving anything
138             { httpURIVarLen + &quot;?length=1&quot;,   &quot;status line&quot;  }, // EOF during status-line
139             { httpURIVarLen + &quot;?length=2&quot;,   &quot;status line&quot;  },
140             { httpURIVarLen + &quot;?length=10&quot;,  &quot;status line&quot;  },
141             { httpURIVarLen + &quot;?length=19&quot;,  &quot;header&quot;       }, // EOF during Content-Type header
142             { httpURIVarLen + &quot;?length=30&quot;,  &quot;header&quot;       },
143             { httpURIVarLen + &quot;?length=45&quot;,  &quot;header&quot;       },
144             { httpURIVarLen + &quot;?length=48&quot;,  &quot;header&quot;       },
145             { httpURIVarLen + &quot;?length=51&quot;,  &quot;header&quot;       },
146             { httpURIVarLen + &quot;?length=98&quot;,  &quot;header&quot;       }, // EOF during Connection header
147             { httpURIVarLen + &quot;?length=100&quot;, &quot;header&quot;       },
148             { httpURIVarLen + &quot;?length=101&quot;, &quot;header&quot;       },
149             { httpURIVarLen + &quot;?length=104&quot;, &quot;header&quot;       },
150             { httpURIVarLen + &quot;?length=106&quot;, &quot;chunked transfer encoding&quot; }, // EOF during chunk header ( length )
151             { httpURIVarLen + &quot;?length=110&quot;, &quot;chunked transfer encoding&quot; }, // EOF during chunk response body data
152 
153             { httpsURIVarLen + &quot;?length=0&quot;,   &quot;no bytes&quot;    },
154             { httpsURIVarLen + &quot;?length=1&quot;,   &quot;status line&quot; },
155             { httpsURIVarLen + &quot;?length=2&quot;,   &quot;status line&quot; },
156             { httpsURIVarLen + &quot;?length=10&quot;,  &quot;status line&quot; },
157             { httpsURIVarLen + &quot;?length=19&quot;,  &quot;header&quot;      },
158             { httpsURIVarLen + &quot;?length=30&quot;,  &quot;header&quot;      },
159             { httpsURIVarLen + &quot;?length=45&quot;,  &quot;header&quot;      },
160             { httpsURIVarLen + &quot;?length=48&quot;,  &quot;header&quot;      },
161             { httpsURIVarLen + &quot;?length=51&quot;,  &quot;header&quot;      },
162             { httpsURIVarLen + &quot;?length=98&quot;,  &quot;header&quot;      },
163             { httpsURIVarLen + &quot;?length=100&quot;, &quot;header&quot;      },
164             { httpsURIVarLen + &quot;?length=101&quot;, &quot;header&quot;      },
165             { httpsURIVarLen + &quot;?length=104&quot;, &quot;header&quot;      },
166             { httpsURIVarLen + &quot;?length=106&quot;, &quot;chunked transfer encoding&quot; },
167             { httpsURIVarLen + &quot;?length=110&quot;, &quot;chunked transfer encoding&quot; },
168 
169             { httpURIFixLen + &quot;?length=0&quot;,   &quot;no bytes&quot;    }, // EOF without receiving anything
170             { httpURIFixLen + &quot;?length=1&quot;,   &quot;status line&quot; }, // EOF during status-line
171             { httpURIFixLen + &quot;?length=2&quot;,   &quot;status line&quot; },
172             { httpURIFixLen + &quot;?length=10&quot;,  &quot;status line&quot; },
173             { httpURIFixLen + &quot;?length=19&quot;,  &quot;header&quot;      }, // EOF during Content-Type header
174             { httpURIFixLen + &quot;?length=30&quot;,  &quot;header&quot;      },
175             { httpURIFixLen + &quot;?length=45&quot;,  &quot;header&quot;      },
176             { httpURIFixLen + &quot;?length=48&quot;,  &quot;header&quot;      },
177             { httpURIFixLen + &quot;?length=51&quot;,  &quot;header&quot;      },
178             { httpURIFixLen + &quot;?length=78&quot;,  &quot;header&quot;      }, // EOF during Connection header
179             { httpURIFixLen + &quot;?length=79&quot;,  &quot;header&quot;      },
180             { httpURIFixLen + &quot;?length=86&quot;,  &quot;header&quot;      },
181             { httpURIFixLen + &quot;?length=104&quot;, &quot;fixed content-length&quot; }, // EOF during body
182             { httpURIFixLen + &quot;?length=106&quot;, &quot;fixed content-length&quot; },
183             { httpURIFixLen + &quot;?length=110&quot;, &quot;fixed content-length&quot; },
184 
185             // ## ADD https fixed
186 
187             { httpURIClsImed,  &quot;no bytes&quot;},
188             { httpsURIClsImed, &quot;no bytes&quot;},
189         };
190 
191         List&lt;Object[]&gt; list = new ArrayList&lt;&gt;();
192         Arrays.asList(cases).stream()
193                 .map(e -&gt; new Object[] {e[0], e[1], true})  // reuse client
194                 .forEach(list::add);
195         Arrays.asList(cases).stream()
196                 .map(e -&gt; new Object[] {e[0], e[1], false}) // do not reuse client
197                 .forEach(list::add);
198         return list.stream().toArray(Object[][]::new);
199     }
200 
201     static final int ITERATION_COUNT = 3;
202 
203     HttpClient newHttpClient() {
204         return HttpClient.newBuilder()
205                 .proxy(NO_PROXY)
206                 .sslContext(sslContext)
207                 .sslParameters(sslParameters)
208                 .executor(service)
209                 .build();
210     }
211 
212     @Test(dataProvider = &quot;uris&quot;)
213     void testSynchronousGET(String url, String expectedMsg, boolean sameClient)
214         throws Exception
215     {
216         out.print(&quot;---\n&quot;);
217         HttpClient client = null;
218         for (int i=0; i&lt; ITERATION_COUNT; i++) {
219             if (!sameClient || client == null)
220                 client = newHttpClient();
221             HttpRequest request = HttpRequest.newBuilder(URI.create(url)).build();
222             try {
223                 HttpResponse&lt;String&gt; response = client.send(request, ofString());
224                 String body = response.body();
225                 out.println(response + &quot;: &quot; + body);
226                 fail(&quot;UNEXPECTED RESPONSE: &quot; + response);
227             } catch (IOException ioe) {
228                 out.println(&quot;Caught expected exception:&quot; + ioe);
229                 assertExpectedMessage(request, ioe, expectedMsg);
230                 // synchronous API must have the send method on the stack
231                 assertSendMethodOnStack(ioe);
232                 assertNoConnectionExpiredException(ioe);
233             }
234         }
235     }
236 
237     @Test(dataProvider = &quot;uris&quot;)
238     void testAsynchronousGET(String url, String expectedMsg, boolean sameClient)
239         throws Exception
240     {
241         out.print(&quot;---\n&quot;);
242         HttpClient client = null;
243         for (int i=0; i&lt; ITERATION_COUNT; i++) {
244             if (!sameClient || client == null)
245                 client = newHttpClient();
246             HttpRequest request = HttpRequest.newBuilder(URI.create(url)).build();
247             try {
248                 HttpResponse&lt;String&gt; response = client.sendAsync(request, ofString()).get();
249                 String body = response.body();
250                 out.println(response + &quot;: &quot; + body);
251                 fail(&quot;UNEXPECTED RESPONSE: &quot; + response);
252             } catch (ExecutionException ee) {
253                 if (ee.getCause() instanceof IOException) {
254                     IOException ioe = (IOException) ee.getCause();
255                     out.println(&quot;Caught expected exception:&quot; + ioe);
256                     assertExpectedMessage(request, ioe, expectedMsg);
257                     assertNoConnectionExpiredException(ioe);
258                 } else {
259                     throw ee;
260                 }
261             }
262         }
263     }
264 
265     // can be used to prolong request body publication
266     static final class InfiniteInputStream extends InputStream {
267         int count = 0;
268         int k16 = 0;
269         @Override
270         public int read() throws IOException {
271             if (++count == 1) {
272                 System.out.println(&quot;Start sending 1 byte&quot;);
273             }
274             if (count &gt; 16 * 1024) {
275                 k16++;
276                 System.out.println(&quot;... 16K sent.&quot;);
277                 count = count % (16 * 1024);
278             }
279             if (k16 &gt; 128) {
280                 System.out.println(&quot;WARNING: InfiniteInputStream: &quot; +
281                         &quot;more than 128 16k buffers generated: returning EOF&quot;);
282                 return -1;
283             }
284             return 1;
285         }
286 
287         @Override
288         public int read(byte[] buf, int offset, int length) {
289             //int count = offset;
290             length = Math.max(0, Math.min(buf.length - offset, length));
291             //for (; count &lt; length; count++)
292             //    buf[offset++] = 0x01;
293             //return count;
294             if (count == 0) {
295                 System.out.println(&quot;Start sending &quot; + length);
296             } else if (count &gt; 16 * 1024) {
297                 k16++;
298                 System.out.println(&quot;... 16K sent.&quot;);
299                 count = count % (16 * 1024);
300             }
301             if (k16 &gt; 128) {
302                 System.out.println(&quot;WARNING: InfiniteInputStream: &quot; +
303                         &quot;more than 128 16k buffers generated: returning EOF&quot;);
304                 return -1;
305             }
306             count += length;
307             return length;
308         }
309     }
310 
311     // POST tests are racy in what may be received before writing may cause a
312     // broken pipe or reset exception, before all the received data can be read.
313     // Any message up to, and including, the &quot;expected&quot; error message can occur.
314     // Strictly ordered list, in order of possible occurrence.
315     static final List&lt;String&gt; MSGS_ORDER =
316             List.of(&quot;no bytes&quot;, &quot;status line&quot;, &quot;header&quot;);
317 
318 
319     @Test(dataProvider = &quot;uris&quot;)
320     void testSynchronousPOST(String url, String expectedMsg, boolean sameClient)
321         throws Exception
322     {
323         out.print(&quot;---\n&quot;);
324         HttpClient client = null;
325         for (int i=0; i&lt; ITERATION_COUNT; i++) {
326             if (!sameClient || client == null)
327                 client = newHttpClient();
328             HttpRequest request = HttpRequest.newBuilder(URI.create(url))
329                     .POST(BodyPublishers.ofInputStream(() -&gt; new InfiniteInputStream()))
330                     .build();
331             try {
332                 HttpResponse&lt;String&gt; response = client.send(request, ofString());
333                 String body = response.body();
334                 out.println(response + &quot;: &quot; + body);
335                 fail(&quot;UNEXPECTED RESPONSE: &quot; + response);
336             } catch (IOException ioe) {
337                 out.println(&quot;Caught expected exception:&quot; + ioe);
338 
339                 List&lt;String&gt; expectedMessages = new ArrayList&lt;&gt;();
340                 expectedMessages.add(expectedMsg);
341                 MSGS_ORDER.stream().takeWhile(s -&gt; !s.equals(expectedMsg))
342                                    .forEach(expectedMessages::add);
343 
344                 assertExpectedMessage(request, ioe, expectedMessages);
345                 // synchronous API must have the send method on the stack
346                 assertSendMethodOnStack(ioe);
347                 assertNoConnectionExpiredException(ioe);
348             }
349         }
350     }
351 
352     @Test(dataProvider = &quot;uris&quot;)
353     void testAsynchronousPOST(String url, String expectedMsg, boolean sameClient)
354         throws Exception
355     {
356         out.print(&quot;---\n&quot;);
357         HttpClient client = null;
358         for (int i=0; i&lt; ITERATION_COUNT; i++) {
359             if (!sameClient || client == null)
360                 client = newHttpClient();
361             HttpRequest request = HttpRequest.newBuilder(URI.create(url))
362                     .POST(BodyPublishers.ofInputStream(() -&gt; new InfiniteInputStream()))
363                     .build();
364             try {
365                 HttpResponse&lt;String&gt; response = client.sendAsync(request, ofString()).get();
366                 String body = response.body();
367                 out.println(response + &quot;: &quot; + body);
368                 fail(&quot;UNEXPECTED RESPONSE: &quot; + response);
369             } catch (ExecutionException ee) {
370                 if (ee.getCause() instanceof IOException) {
371                     IOException ioe = (IOException) ee.getCause();
372                     out.println(&quot;Caught expected exception:&quot; + ioe);
373                     String msg = ioe.getMessage();
374 
375                     List&lt;String&gt; expectedMessages = new ArrayList&lt;&gt;();
376                     expectedMessages.add(expectedMsg);
377                     MSGS_ORDER.stream().takeWhile(s -&gt; !s.equals(expectedMsg))
378                             .forEach(expectedMessages::add);
379 
380                     assertExpectedMessage(request, ioe, expectedMessages);
381                     assertNoConnectionExpiredException(ioe);
382                 } else {
383                     throw ee;
384                 }
385             }
386         }
387     }
388 
389 
390     void assertExpectedMessage(HttpRequest request, Throwable t, String expected) {
391         if (request.uri().getScheme().equalsIgnoreCase(&quot;https&quot;)
392                 &amp;&amp; (t instanceof SSLHandshakeException)) {
393             // OK
394             out.println(&quot;Skipping expected &quot; + t);
395         } else {
396             String msg = t.getMessage();
397             assertTrue(msg.contains(expected),
398                     &quot;exception msg:[&quot; + msg + &quot;]&quot;);
399         }
400     }
401 
402     void assertExpectedMessage(HttpRequest request, Throwable t, List&lt;String&gt; expected) {
403         if (request.uri().getScheme().equalsIgnoreCase(&quot;https&quot;)
404                 &amp;&amp; (t instanceof SSLHandshakeException)) {
405             // OK
406             out.println(&quot;Skipping expected &quot; + t);
407         } else {
408             String msg = t.getMessage();
409             assertTrue(expected.stream().anyMatch(msg::contains),
410                     &quot;exception msg:[&quot; + msg + &quot;] not in &quot; + Arrays.asList(expected));
411         }
412     }
413 
414     // Asserts that the &quot;send&quot; method appears in the stack of the given
415     // exception. The synchronous API must contain the send method on the stack.
416     static void assertSendMethodOnStack(IOException ioe) {
417         final String cn = &quot;jdk.internal.net.http.HttpClientImpl&quot;;
418         List&lt;StackTraceElement&gt; list = Stream.of(ioe.getStackTrace())
419                 .filter(ste -&gt; ste.getClassName().equals(cn)
420                         &amp;&amp; ste.getMethodName().equals(&quot;send&quot;))
421                 .collect(toList());
422         if (list.size() != 1) {
423             ioe.printStackTrace(out);
424             fail(cn + &quot;.send method not found in stack.&quot;);
425         }
426     }
427 
428     // Asserts that the implementation-specific ConnectionExpiredException does
429     // NOT appear anywhere in the exception or its causal chain.
430     static void assertNoConnectionExpiredException(IOException ioe) {
431         Throwable throwable = ioe;
432         do {
433             String cn = throwable.getClass().getSimpleName();
434             if (cn.equals(&quot;ConnectionExpiredException&quot;)) {
435                 ioe.printStackTrace(out);
436                 fail(&quot;UNEXPECTED ConnectionExpiredException in:[&quot; + ioe + &quot;]&quot;);
437             }
438         } while ((throwable = throwable.getCause()) != null);
439     }
440 
441     // -- infra
442 
443     /**
444      * A server that, listens on a port, accepts new connections, and can be
445      * closed.
446      */
447     static abstract class Server extends Thread implements AutoCloseable {
448         protected final ServerSocket ss;
449         protected volatile boolean closed;
450 
451         Server(String name) throws IOException {
452             super(name);
453             ss = newServerSocket();
454             ss.bind(new InetSocketAddress(InetAddress.getLoopbackAddress(), 0));
455             this.start();
456         }
457 
458         protected ServerSocket newServerSocket() throws IOException {
459             return new ServerSocket();
460         }
461 
462         public int getPort() { return ss.getLocalPort(); }
463 
464         @Override
465         public void close() {
466             if (closed)
467                 return;
468             closed = true;
469             try {
470                 ss.close();
471             } catch (IOException e) {
472                 throw new UncheckedIOException(&quot;Unexpected&quot;, e);
473             }
474         }
475     }
476 
477     /**
478      * A server that closes the connection immediately, without reading or writing.
479      */
480     static class PlainCloseImmediatelyServer extends Server {
481         PlainCloseImmediatelyServer() throws IOException {
482             super(&quot;PlainCloseImmediatelyServer&quot;);
483         }
484 
485         protected PlainCloseImmediatelyServer(String name) throws IOException {
486             super(name);
487         }
488 
489         @Override
490         public void run() {
491             while (!closed) {
492                 try (Socket s = ss.accept()) {
493                     if (s instanceof SSLSocket) {
494                         ((SSLSocket)s).startHandshake();
495                     }
496                     out.println(&quot;Server: got connection, closing immediately &quot;);
497                 } catch (IOException e) {
498                     if (!closed)
499                         throw new UncheckedIOException(&quot;Unexpected&quot;, e);
500                 }
501             }
502         }
503     }
504 
505     /**
506      * A server that closes the connection immediately, without reading or writing,
507      * after completing the SSL handshake.
508      */
509     static final class SSLCloseImmediatelyServer extends PlainCloseImmediatelyServer {
510         SSLCloseImmediatelyServer() throws IOException {
511             super(&quot;SSLCloseImmediatelyServer&quot;);
512         }
513         @Override
514         public ServerSocket newServerSocket() throws IOException {
515             return SSLServerSocketFactory.getDefault().createServerSocket();
516         }
517     }
518 
519     /**
520      * A server that replies with headers and a, possibly partial, reply, before
521      * closing the connection. The number of bytes of written ( header + body),
522      * is controllable through the &quot;length&quot; query string param in the requested
523      * URI.
524      */
525     static abstract class ReplyingServer extends Server {
526 
527         private final String name;
528 
529         ReplyingServer(String name) throws IOException {
530             super(name);
531             this.name = name;
532         }
533 
534         abstract String response();
535 
536         @Override
537         public void run() {
538             while (!closed) {
539                 try (Socket s = ss.accept()) {
540                     out.print(name + &quot;: got connection &quot;);
541                     InputStream is = s.getInputStream();
542                     URI requestMethod = readRequestMethod(is);
543                     out.print(requestMethod + &quot; &quot;);
544                     URI uriPath = readRequestPath(is);
545                     out.println(uriPath);
546                     String headers = readRequestHeaders(is);
547 
548                     String query = uriPath.getRawQuery();
549                     if (query == null) {
550                         out.println(&quot;Request headers: [&quot; + headers + &quot;]&quot;);
551                     }
552                     assert query != null : &quot;null query for uriPath: &quot; + uriPath;
553                     String qv = query.split(&quot;=&quot;)[1];
554                     int len;
555                     if (qv.equals(&quot;all&quot;)) {
556                         len = response().getBytes(US_ASCII).length;
557                     } else {
558                         len = Integer.parseInt(query.split(&quot;=&quot;)[1]);
559                     }
560 
561                     OutputStream os = s.getOutputStream();
562                     out.println(name + &quot;: writing &quot; + len  + &quot; bytes&quot;);
563                     byte[] responseBytes = response().getBytes(US_ASCII);
564                     for (int i = 0; i&lt; len; i++) {
565                         os.write(responseBytes[i]);
566                         os.flush();
567                     }
568                 } catch (IOException e) {
569                     if (!closed)
570                         throw new UncheckedIOException(&quot;Unexpected&quot;, e);
571                 }
572             }
573         }
574 
575         static final byte[] requestEnd = new byte[] { &#39;\r&#39;, &#39;\n&#39;, &#39;\r&#39;, &#39;\n&#39; };
576 
577         // Read the request method
578         static URI readRequestMethod(InputStream is) throws IOException {
579             StringBuilder sb = new StringBuilder();
580             int r;
581             while ((r = is.read()) != -1 &amp;&amp; r != 0x20) {
582                 sb.append((char)r);
583             }
584             return URI.create(sb.toString());
585         }
586 
587         // Read the request URI path
588         static URI readRequestPath(InputStream is) throws IOException {
589             StringBuilder sb = new StringBuilder();
590             int r;
591             while ((r = is.read()) != -1 &amp;&amp; r != 0x20) {
592                 sb.append((char)r);
593             }
594             return URI.create(sb.toString());
595         }
596 
597         // Read until the end of a HTTP request headers
598         static String readRequestHeaders(InputStream is) throws IOException {
599             int requestEndCount = 0, r;
600             StringBuilder sb = new StringBuilder();
601             while ((r = is.read()) != -1) {
602                 sb.append((char) r);
603                 if (r == requestEnd[requestEndCount]) {
604                     requestEndCount++;
605                     if (requestEndCount == 4) {
606                         break;
607                     }
608                 } else {
609                     requestEndCount = 0;
610                 }
611             }
612             return sb.toString();
613         }
614     }
615 
616     /** A server that issues a, possibly-partial, chunked reply. */
617     static class PlainVariableLengthServer extends ReplyingServer {
618 
619         static final String CHUNKED_RESPONSE_BODY =
620                 &quot;6\r\n&quot;+ &quot;&lt;html&gt;\r\n&quot; +
621                 &quot;6\r\n&quot;+ &quot;&lt;body&gt;\r\n&quot; +
622                 &quot;10\r\n&quot;+ &quot;&lt;h1&gt;Heading&lt;/h1&gt;\r\n&quot; +
623                 &quot;10\r\n&quot;+ &quot;&lt;p&gt;Some Text&lt;/p&gt;\r\n&quot; +
624                 &quot;7\r\n&quot;+ &quot;&lt;/body&gt;\r\n&quot; +
625                 &quot;7\r\n&quot;+ &quot;&lt;/html&gt;\r\n&quot; +
626                 &quot;0\r\n&quot;+ &quot;\r\n&quot;;
627 
628         static final String RESPONSE_HEADERS =
629                 &quot;HTTP/1.1 200 OK\r\n&quot; +
630                 &quot;Content-Type: text/html; charset=utf-8\r\n&quot; +
631                 &quot;Transfer-Encoding: chunked\r\n&quot; +
632                 &quot;Connection: close\r\n\r\n&quot;;
633 
634         static final String RESPONSE = RESPONSE_HEADERS + CHUNKED_RESPONSE_BODY;
635 
636         PlainVariableLengthServer() throws IOException {
637             super(&quot;PlainVariableLengthServer&quot;);
638         }
639 
640         protected PlainVariableLengthServer(String name) throws IOException {
641             super(name);
642         }
643 
644         @Override
645         String response( ) { return RESPONSE; }
646     }
647 
648     /** A server that issues a, possibly-partial, chunked reply over SSL. */
649     static final class SSLVariableLengthServer extends PlainVariableLengthServer {
650         SSLVariableLengthServer() throws IOException {
651             super(&quot;SSLVariableLengthServer&quot;);
652         }
653         @Override
654         public ServerSocket newServerSocket() throws IOException {
655             return SSLServerSocketFactory.getDefault().createServerSocket();
656         }
657     }
658 
659     /** A server that issues a fixed-length reply. */
660     static final class FixedLengthServer extends ReplyingServer {
661 
662         static final String RESPONSE_BODY = EXPECTED_RESPONSE_BODY;
663 
664         static final String RESPONSE_HEADERS =
665                 &quot;HTTP/1.1 200 OK\r\n&quot; +
666                 &quot;Content-Type: text/html; charset=utf-8\r\n&quot; +
667                 &quot;Content-Length: &quot; + RESPONSE_BODY.length() + &quot;\r\n&quot; +
668                 &quot;Connection: close\r\n\r\n&quot;;
669 
670         static final String RESPONSE = RESPONSE_HEADERS + RESPONSE_BODY;
671 
672         FixedLengthServer() throws IOException {
673             super(&quot;FixedLengthServer&quot;);
674         }
675 
676         @Override
677         String response( ) { return RESPONSE; }
678     }
679 
680     static String serverAuthority(Server server) {
681         return InetAddress.getLoopbackAddress().getHostName() + &quot;:&quot;
682                 + server.getPort();
683     }
684 
685     @BeforeTest
686     public void setup() throws Exception {
687         sslContext = new SimpleSSLContext().get();
688         if (sslContext == null)
689             throw new AssertionError(&quot;Unexpected null sslContext&quot;);
690         SSLContext.setDefault(sslContext);
691 
692         sslParameters = new SSLParameters();
693         sslParameters.setProtocols(new String[] {&quot;TLSv1.2&quot;});
694 
695         closeImmediatelyServer = new PlainCloseImmediatelyServer();
696         httpURIClsImed = &quot;http://&quot; + serverAuthority(closeImmediatelyServer)
697                 + &quot;/http1/closeImmediately/foo&quot;;
698 
699         closeImmediatelyHttpsServer = new SSLCloseImmediatelyServer();
700         httpsURIClsImed = &quot;https://&quot; + serverAuthority(closeImmediatelyHttpsServer)
701                 + &quot;/https1/closeImmediately/foo&quot;;
702 
703         variableLengthServer = new PlainVariableLengthServer();
704         httpURIVarLen = &quot;http://&quot; + serverAuthority(variableLengthServer)
705                 + &quot;/http1/variable/bar&quot;;
706 
707         variableLengthHttpsServer = new SSLVariableLengthServer();
708         httpsURIVarLen = &quot;https://&quot; + serverAuthority(variableLengthHttpsServer)
709                 + &quot;/https1/variable/bar&quot;;
710 
711         fixedLengthServer = new FixedLengthServer();
712         httpURIFixLen = &quot;http://&quot; + serverAuthority(fixedLengthServer)
713                 + &quot;/http1/fixed/baz&quot;;
714     }
715 
716     @AfterTest
717     public void teardown() throws Exception {
718         closeImmediatelyServer.close();
719         closeImmediatelyHttpsServer.close();
720         variableLengthServer.close();
721         variableLengthHttpsServer.close();
722         fixedLengthServer.close();
723     }
724 }
    </pre>
  </body>
</html>
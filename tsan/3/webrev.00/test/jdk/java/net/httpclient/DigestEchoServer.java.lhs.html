<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames test/jdk/java/net/httpclient/DigestEchoServer.java</title>
    <link rel="stylesheet" href="../../../../../style.css" />
    <script type="text/javascript" src="../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (c) 2018, 2019, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  */
  23 
  24 import com.sun.net.httpserver.BasicAuthenticator;
  25 import com.sun.net.httpserver.HttpServer;
  26 import com.sun.net.httpserver.HttpsConfigurator;
  27 import com.sun.net.httpserver.HttpsParameters;
  28 import com.sun.net.httpserver.HttpsServer;
<a name="1" id="anc1"></a>

  29 import java.io.IOException;
  30 import java.io.InputStream;
  31 import java.io.OutputStream;
  32 import java.io.OutputStreamWriter;
  33 import java.io.PrintWriter;
  34 import java.io.Writer;
  35 import java.math.BigInteger;
  36 import java.net.Authenticator;
  37 import java.net.HttpURLConnection;
  38 import java.net.InetAddress;
  39 import java.net.InetSocketAddress;
  40 import java.net.MalformedURLException;
  41 import java.net.PasswordAuthentication;
  42 import java.net.ServerSocket;
  43 import java.net.Socket;
  44 import java.net.StandardSocketOptions;
  45 import java.net.URI;
  46 import java.net.URISyntaxException;
  47 import java.net.URL;
  48 import java.nio.charset.StandardCharsets;
  49 import java.security.MessageDigest;
  50 import java.security.NoSuchAlgorithmException;
  51 import java.time.Instant;
  52 import java.util.ArrayList;
  53 import java.util.Arrays;
  54 import java.util.Base64;
  55 import java.util.List;
  56 import java.util.Locale;
  57 import java.util.Objects;
  58 import java.util.Optional;
  59 import java.util.Random;
  60 import java.util.StringTokenizer;
  61 import java.util.concurrent.CompletableFuture;
  62 import java.util.concurrent.CopyOnWriteArrayList;
  63 import java.util.concurrent.atomic.AtomicInteger;
  64 import java.util.stream.Collectors;
  65 import java.util.stream.Stream;
  66 import javax.net.ssl.SSLContext;
  67 import sun.net.www.HeaderParser;
  68 import java.net.http.HttpClient.Version;
  69 
  70 /**
  71  * A simple HTTP server that supports Basic or Digest authentication.
  72  * By default this server will echo back whatever is present
  73  * in the request body. Note that the Digest authentication is
  74  * a test implementation implemented only for tests purposes.
  75  * @author danielfuchs
  76  */
  77 public abstract class DigestEchoServer implements HttpServerAdapters {
  78 
  79     public static final boolean DEBUG =
  80             Boolean.parseBoolean(System.getProperty(&quot;test.debug&quot;, &quot;false&quot;));
  81     public static final boolean NO_LINGER =
  82             Boolean.parseBoolean(System.getProperty(&quot;test.nolinger&quot;, &quot;false&quot;));
<a name="2" id="anc2"></a>

  83     public enum HttpAuthType {
  84         SERVER, PROXY, SERVER307, PROXY305
  85         /* add PROXY_AND_SERVER and SERVER_PROXY_NONE */
  86     };
  87     public enum HttpAuthSchemeType { NONE, BASICSERVER, BASIC, DIGEST };
  88     public static final HttpAuthType DEFAULT_HTTP_AUTH_TYPE = HttpAuthType.SERVER;
  89     public static final String DEFAULT_PROTOCOL_TYPE = &quot;https&quot;;
  90     public static final HttpAuthSchemeType DEFAULT_SCHEME_TYPE = HttpAuthSchemeType.DIGEST;
  91 
  92     public static class HttpTestAuthenticator extends Authenticator {
  93         private final String realm;
  94         private final String username;
  95         // Used to prevent incrementation of &#39;count&#39; when calling the
  96         // authenticator from the server side.
  97         private final ThreadLocal&lt;Boolean&gt; skipCount = new ThreadLocal&lt;&gt;();
  98         // count will be incremented every time getPasswordAuthentication()
  99         // is called from the client side.
 100         final AtomicInteger count = new AtomicInteger();
 101 
 102         public HttpTestAuthenticator(String realm, String username) {
 103             this.realm = realm;
 104             this.username = username;
 105         }
 106         @Override
 107         protected PasswordAuthentication getPasswordAuthentication() {
 108             if (skipCount.get() == null || skipCount.get().booleanValue() == false) {
 109                 System.out.println(&quot;Authenticator called: &quot; + count.incrementAndGet());
 110             }
 111             return new PasswordAuthentication(getUserName(),
 112                     new char[] {&#39;d&#39;,&#39;e&#39;,&#39;n&#39;, &#39;t&#39;});
 113         }
 114         // Called by the server side to get the password of the user
 115         // being authentified.
 116         public final char[] getPassword(String user) {
 117             if (user.equals(username)) {
 118                 skipCount.set(Boolean.TRUE);
 119                 try {
 120                     return getPasswordAuthentication().getPassword();
 121                 } finally {
 122                     skipCount.set(Boolean.FALSE);
 123                 }
 124             }
 125             throw new SecurityException(&quot;User unknown: &quot; + user);
 126         }
 127         public final String getUserName() {
 128             return username;
 129         }
 130         public final String getRealm() {
 131             return realm;
 132         }
 133     }
 134 
 135     public static final HttpTestAuthenticator AUTHENTICATOR;
 136     static {
 137         AUTHENTICATOR = new HttpTestAuthenticator(&quot;earth&quot;, &quot;arthur&quot;);
 138     }
 139 
 140 
 141     final HttpTestServer       serverImpl; // this server endpoint
 142     final DigestEchoServer     redirect;   // the target server where to redirect 3xx
 143     final HttpTestHandler      delegate;   // unused
 144     final String               key;
 145 
 146     DigestEchoServer(String key,
 147                              HttpTestServer server,
 148                              DigestEchoServer target,
 149                              HttpTestHandler delegate) {
 150         this.key = key;
 151         this.serverImpl = server;
 152         this.redirect = target;
 153         this.delegate = delegate;
 154     }
 155 
 156     public static void main(String[] args)
 157             throws IOException {
 158 
 159         DigestEchoServer server = create(Version.HTTP_1_1,
 160                 DEFAULT_PROTOCOL_TYPE,
 161                 DEFAULT_HTTP_AUTH_TYPE,
 162                 AUTHENTICATOR,
 163                 DEFAULT_SCHEME_TYPE);
 164         try {
 165             System.out.println(&quot;Server created at &quot; + server.getAddress());
 166             System.out.println(&quot;Strike &lt;Return&gt; to exit&quot;);
 167             System.in.read();
 168         } finally {
 169             System.out.println(&quot;stopping server&quot;);
 170             server.stop();
 171         }
 172     }
 173 
 174     private static String toString(HttpTestRequestHeaders headers) {
 175         return headers.entrySet().stream()
 176                 .map((e) -&gt; e.getKey() + &quot;: &quot; + e.getValue())
 177                 .collect(Collectors.joining(&quot;\n&quot;));
 178     }
 179 
 180     public static DigestEchoServer create(Version version,
 181                                           String protocol,
 182                                           HttpAuthType authType,
 183                                           HttpAuthSchemeType schemeType)
 184             throws IOException {
 185         return create(version, protocol, authType, AUTHENTICATOR, schemeType);
 186     }
 187 
 188     public static DigestEchoServer create(Version version,
 189                                           String protocol,
 190                                           HttpAuthType authType,
 191                                           HttpTestAuthenticator auth,
 192                                           HttpAuthSchemeType schemeType)
 193             throws IOException {
 194         return create(version, protocol, authType, auth, schemeType, null);
 195     }
 196 
 197     public static DigestEchoServer create(Version version,
 198                                         String protocol,
 199                                         HttpAuthType authType,
 200                                         HttpTestAuthenticator auth,
 201                                         HttpAuthSchemeType schemeType,
 202                                         HttpTestHandler delegate)
 203             throws IOException {
 204         Objects.requireNonNull(authType);
 205         Objects.requireNonNull(auth);
 206         switch(authType) {
 207             // A server that performs Server Digest authentication.
 208             case SERVER: return createServer(version, protocol, authType, auth,
 209                                              schemeType, delegate, &quot;/&quot;);
 210             // A server that pretends to be a Proxy and performs
 211             // Proxy Digest authentication. If protocol is HTTPS,
 212             // then this will create a HttpsProxyTunnel that will
 213             // handle the CONNECT request for tunneling.
 214             case PROXY: return createProxy(version, protocol, authType, auth,
 215                                            schemeType, delegate, &quot;/&quot;);
 216             // A server that sends 307 redirect to a server that performs
 217             // Digest authentication.
 218             // Note: 301 doesn&#39;t work here because it transforms POST into GET.
 219             case SERVER307: return createServerAndRedirect(version,
 220                                                         protocol,
 221                                                         HttpAuthType.SERVER,
 222                                                         auth, schemeType,
 223                                                         delegate, 307);
 224             // A server that sends 305 redirect to a proxy that performs
 225             // Digest authentication.
 226             // Note: this is not correctly stubbed/implemented in this test.
 227             case PROXY305:  return createServerAndRedirect(version,
 228                                                         protocol,
 229                                                         HttpAuthType.PROXY,
 230                                                         auth, schemeType,
 231                                                         delegate, 305);
 232             default:
 233                 throw new InternalError(&quot;Unknown server type: &quot; + authType);
 234         }
 235     }
 236 
 237 
 238     /**
 239      * The SocketBindableFactory ensures that the local port used by an HttpServer
 240      * or a proxy ServerSocket previously created by the current test/VM will not
 241      * get reused by a subsequent test in the same VM.
 242      * This is to avoid having the test client trying to reuse cached connections.
 243      */
 244     private static abstract class SocketBindableFactory&lt;B&gt; {
 245         private static final int MAX = 10;
 246         private static final CopyOnWriteArrayList&lt;String&gt; addresses =
 247                 new CopyOnWriteArrayList&lt;&gt;();
 248         protected B createInternal() throws IOException {
 249             final int max = addresses.size() + MAX;
 250             final List&lt;B&gt; toClose = new ArrayList&lt;&gt;();
 251             try {
 252                 for (int i = 1; i &lt;= max; i++) {
 253                     B bindable = createBindable();
 254                     InetSocketAddress address = getAddress(bindable);
 255                     String key = &quot;localhost:&quot; + address.getPort();
 256                     if (addresses.addIfAbsent(key)) {
 257                         System.out.println(&quot;Socket bound to: &quot; + key
 258                                 + &quot; after &quot; + i + &quot; attempt(s)&quot;);
 259                         return bindable;
 260                     }
 261                     System.out.println(&quot;warning: address &quot; + key
 262                             + &quot; already used. Retrying bind.&quot;);
 263                     // keep the port bound until we get a port that we haven&#39;t
 264                     // used already
 265                     toClose.add(bindable);
 266                 }
 267             } finally {
 268                 // if we had to retry, then close the socket we&#39;re not
 269                 // going to use.
 270                 for (B b : toClose) {
 271                     try { close(b); } catch (Exception x) { /* ignore */ }
 272                 }
 273             }
 274             throw new IOException(&quot;Couldn&#39;t bind socket after &quot; + max + &quot; attempts: &quot;
 275                     + &quot;addresses used before: &quot; + addresses);
 276         }
 277 
 278         protected abstract B createBindable() throws IOException;
 279 
 280         protected abstract InetSocketAddress getAddress(B bindable);
 281 
 282         protected abstract void close(B bindable) throws IOException;
 283     }
 284 
 285     /*
 286      * Used to create ServerSocket for a proxy.
 287      */
 288     private static final class ServerSocketFactory
 289     extends SocketBindableFactory&lt;ServerSocket&gt; {
 290         private static final ServerSocketFactory instance = new ServerSocketFactory();
 291 
 292         static ServerSocket create() throws IOException {
 293             return instance.createInternal();
 294         }
 295 
 296         @Override
 297         protected ServerSocket createBindable() throws IOException {
 298             ServerSocket ss = new ServerSocket();
 299             ss.setReuseAddress(false);
 300             ss.bind(new InetSocketAddress(InetAddress.getLoopbackAddress(), 0));
 301             return ss;
 302         }
 303 
 304         @Override
 305         protected InetSocketAddress getAddress(ServerSocket socket) {
 306             return new InetSocketAddress(socket.getInetAddress(), socket.getLocalPort());
 307         }
 308 
 309         @Override
 310         protected void close(ServerSocket socket) throws IOException {
 311             socket.close();
 312         }
 313     }
 314 
 315     /*
 316      * Used to create HttpServer
 317      */
 318     private static abstract class H1ServerFactory&lt;S extends HttpServer&gt;
 319             extends SocketBindableFactory&lt;S&gt; {
 320         @Override
 321         protected S createBindable() throws IOException {
 322             S server = newHttpServer();
 323             server.bind(new InetSocketAddress(InetAddress.getLoopbackAddress(), 0), 0);
 324             return server;
 325         }
 326 
 327         @Override
 328         protected InetSocketAddress getAddress(S server) {
 329             return server.getAddress();
 330         }
 331 
 332         @Override
 333         protected void close(S server) throws IOException {
 334             server.stop(1);
 335         }
 336 
 337         /*
 338          * Returns a HttpServer or a HttpsServer in different subclasses.
 339          */
 340         protected abstract S newHttpServer() throws IOException;
 341     }
 342 
 343     /*
 344      * Used to create Http2TestServer
 345      */
 346     private static abstract class H2ServerFactory&lt;S extends Http2TestServer&gt;
 347             extends SocketBindableFactory&lt;S&gt; {
 348         @Override
 349         protected S createBindable() throws IOException {
 350             final S server;
 351             try {
 352                 server = newHttpServer();
 353             } catch (IOException io) {
 354                 throw io;
 355             } catch (Exception x) {
 356                 throw new IOException(x);
 357             }
 358             return server;
 359         }
 360 
 361         @Override
 362         protected InetSocketAddress getAddress(S server) {
 363             return server.getAddress();
 364         }
 365 
 366         @Override
 367         protected void close(S server) throws IOException {
 368             server.stop();
 369         }
 370 
 371         /*
 372          * Returns a HttpServer or a HttpsServer in different subclasses.
 373          */
 374         protected abstract S newHttpServer() throws Exception;
 375     }
 376 
 377     private static final class Http2ServerFactory extends H2ServerFactory&lt;Http2TestServer&gt; {
 378         private static final Http2ServerFactory instance = new Http2ServerFactory();
 379 
 380         static Http2TestServer create() throws IOException {
 381             return instance.createInternal();
 382         }
 383 
 384         @Override
 385         protected Http2TestServer newHttpServer() throws Exception {
 386             return new Http2TestServer(&quot;localhost&quot;, false, 0);
 387         }
 388     }
 389 
 390     private static final class Https2ServerFactory extends H2ServerFactory&lt;Http2TestServer&gt; {
 391         private static final Https2ServerFactory instance = new Https2ServerFactory();
 392 
 393         static Http2TestServer create() throws IOException {
 394             return instance.createInternal();
 395         }
 396 
 397         @Override
 398         protected Http2TestServer newHttpServer() throws Exception {
 399             return new Http2TestServer(&quot;localhost&quot;, true, 0);
 400         }
 401     }
 402 
 403     private static final class Http1ServerFactory extends H1ServerFactory&lt;HttpServer&gt; {
 404         private static final Http1ServerFactory instance = new Http1ServerFactory();
 405 
 406         static HttpServer create() throws IOException {
 407             return instance.createInternal();
 408         }
 409 
 410         @Override
 411         protected HttpServer newHttpServer() throws IOException {
 412             return HttpServer.create();
 413         }
 414     }
 415 
 416     private static final class Https1ServerFactory extends H1ServerFactory&lt;HttpsServer&gt; {
 417         private static final Https1ServerFactory instance = new Https1ServerFactory();
 418 
 419         static HttpsServer create() throws IOException {
 420             return instance.createInternal();
 421         }
 422 
 423         @Override
 424         protected HttpsServer newHttpServer() throws IOException {
 425             return HttpsServer.create();
 426         }
 427     }
 428 
 429     static Http2TestServer createHttp2Server(String protocol) throws IOException {
 430         final Http2TestServer server;
 431         if (&quot;http&quot;.equalsIgnoreCase(protocol)) {
 432             server = Http2ServerFactory.create();
 433         } else if (&quot;https&quot;.equalsIgnoreCase(protocol)) {
 434             server = Https2ServerFactory.create();
 435         } else {
 436             throw new InternalError(&quot;unsupported protocol: &quot; + protocol);
 437         }
 438         return server;
 439     }
 440 
 441     static HttpTestServer createHttpServer(Version version, String protocol)
 442             throws IOException
 443     {
 444         switch(version) {
 445             case HTTP_1_1:
 446                 return HttpTestServer.of(createHttp1Server(protocol));
 447             case HTTP_2:
 448                 return HttpTestServer.of(createHttp2Server(protocol));
 449             default:
 450                 throw new InternalError(&quot;Unexpected version: &quot; + version);
 451         }
 452     }
 453 
 454     static HttpServer createHttp1Server(String protocol) throws IOException {
 455         final HttpServer server;
 456         if (&quot;http&quot;.equalsIgnoreCase(protocol)) {
 457             server = Http1ServerFactory.create();
 458         } else if (&quot;https&quot;.equalsIgnoreCase(protocol)) {
 459             server = configure(Https1ServerFactory.create());
 460         } else {
 461             throw new InternalError(&quot;unsupported protocol: &quot; + protocol);
 462         }
 463         return server;
 464     }
 465 
 466     static HttpsServer configure(HttpsServer server) throws IOException {
 467         try {
 468             SSLContext ctx = SSLContext.getDefault();
 469             server.setHttpsConfigurator(new Configurator(ctx));
 470         } catch (NoSuchAlgorithmException ex) {
 471             throw new IOException(ex);
 472         }
 473         return server;
 474     }
 475 
 476 
 477     static void setContextAuthenticator(HttpTestContext ctxt,
 478                                         HttpTestAuthenticator auth) {
 479         final String realm = auth.getRealm();
 480         com.sun.net.httpserver.Authenticator authenticator =
 481             new BasicAuthenticator(realm) {
 482                 @Override
 483                 public boolean checkCredentials(String username, String pwd) {
 484                     return auth.getUserName().equals(username)
 485                            &amp;&amp; new String(auth.getPassword(username)).equals(pwd);
 486                 }
 487         };
 488         ctxt.setAuthenticator(authenticator);
 489     }
 490 
 491     public static DigestEchoServer createServer(Version version,
 492                                         String protocol,
 493                                         HttpAuthType authType,
 494                                         HttpTestAuthenticator auth,
 495                                         HttpAuthSchemeType schemeType,
 496                                         HttpTestHandler delegate,
 497                                         String path)
 498             throws IOException {
 499         Objects.requireNonNull(authType);
 500         Objects.requireNonNull(auth);
 501 
 502         HttpTestServer impl = createHttpServer(version, protocol);
 503         String key = String.format(&quot;DigestEchoServer[PID=%s,PORT=%s]:%s:%s:%s:%s&quot;,
 504                 ProcessHandle.current().pid(),
 505                 impl.getAddress().getPort(),
 506                 version, protocol, authType, schemeType);
 507         final DigestEchoServer server = new DigestEchoServerImpl(key, impl, null, delegate);
 508         final HttpTestHandler handler =
 509                 server.createHandler(schemeType, auth, authType, false);
 510         HttpTestContext context = impl.addHandler(handler, path);
 511         server.configureAuthentication(context, schemeType, auth, authType);
 512         impl.start();
 513         return server;
 514     }
 515 
 516     public static DigestEchoServer createProxy(Version version,
 517                                         String protocol,
 518                                         HttpAuthType authType,
 519                                         HttpTestAuthenticator auth,
 520                                         HttpAuthSchemeType schemeType,
 521                                         HttpTestHandler delegate,
 522                                         String path)
 523             throws IOException {
 524         Objects.requireNonNull(authType);
 525         Objects.requireNonNull(auth);
 526 
 527         if (version == Version.HTTP_2 &amp;&amp; protocol.equalsIgnoreCase(&quot;http&quot;)) {
 528             System.out.println(&quot;WARNING: can&#39;t use HTTP/1.1 proxy with unsecure HTTP/2 server&quot;);
 529             version = Version.HTTP_1_1;
 530         }
 531         HttpTestServer impl = createHttpServer(version, protocol);
 532         String key = String.format(&quot;DigestEchoServer[PID=%s,PORT=%s]:%s:%s:%s:%s&quot;,
 533                 ProcessHandle.current().pid(),
 534                 impl.getAddress().getPort(),
 535                 version, protocol, authType, schemeType);
 536         final DigestEchoServer server = &quot;https&quot;.equalsIgnoreCase(protocol)
 537                 ? new HttpsProxyTunnel(key, impl, null, delegate)
 538                 : new DigestEchoServerImpl(key, impl, null, delegate);
 539 
 540         final HttpTestHandler hh = server.createHandler(HttpAuthSchemeType.NONE,
 541                                          null, HttpAuthType.SERVER,
 542                                          server instanceof HttpsProxyTunnel);
 543         HttpTestContext ctxt = impl.addHandler(hh, path);
 544         server.configureAuthentication(ctxt, schemeType, auth, authType);
 545         impl.start();
 546 
 547         return server;
 548     }
 549 
 550     public static DigestEchoServer createServerAndRedirect(
 551                                         Version version,
 552                                         String protocol,
 553                                         HttpAuthType targetAuthType,
 554                                         HttpTestAuthenticator auth,
 555                                         HttpAuthSchemeType schemeType,
 556                                         HttpTestHandler targetDelegate,
 557                                         int code300)
 558             throws IOException {
 559         Objects.requireNonNull(targetAuthType);
 560         Objects.requireNonNull(auth);
 561 
 562         // The connection between client and proxy can only
 563         // be a plain connection: SSL connection to proxy
 564         // is not supported by our client connection.
 565         String targetProtocol = targetAuthType == HttpAuthType.PROXY
 566                                           ? &quot;http&quot;
 567                                           : protocol;
 568         DigestEchoServer redirectTarget =
 569                 (targetAuthType == HttpAuthType.PROXY)
 570                 ? createProxy(version, protocol, targetAuthType,
 571                               auth, schemeType, targetDelegate, &quot;/&quot;)
 572                 : createServer(version, targetProtocol, targetAuthType,
 573                                auth, schemeType, targetDelegate, &quot;/&quot;);
 574         HttpTestServer impl = createHttpServer(version, protocol);
 575         String key = String.format(&quot;RedirectingServer[PID=%s,PORT=%s]:%s:%s:%s:%s&quot;,
 576                 ProcessHandle.current().pid(),
 577                 impl.getAddress().getPort(),
 578                 version, protocol,
 579                 HttpAuthType.SERVER, code300)
 580                 + &quot;-&gt;&quot; + redirectTarget.key;
 581         final DigestEchoServer redirectingServer =
 582                  new DigestEchoServerImpl(key, impl, redirectTarget, null);
 583         InetSocketAddress redirectAddr = redirectTarget.getAddress();
 584         URL locationURL = url(targetProtocol, redirectAddr, &quot;/&quot;);
 585         final HttpTestHandler hh = redirectingServer.create300Handler(key, locationURL,
 586                                              HttpAuthType.SERVER, code300);
 587         impl.addHandler(hh,&quot;/&quot;);
 588         impl.start();
 589         return redirectingServer;
 590     }
 591 
 592     public abstract InetSocketAddress getServerAddress();
 593     public abstract InetSocketAddress getProxyAddress();
 594     public abstract InetSocketAddress getAddress();
 595     public abstract void stop();
 596     public abstract Version getServerVersion();
 597 
 598     private static class DigestEchoServerImpl extends DigestEchoServer {
 599         DigestEchoServerImpl(String key,
 600                              HttpTestServer server,
 601                              DigestEchoServer target,
 602                              HttpTestHandler delegate) {
 603             super(key, Objects.requireNonNull(server), target, delegate);
 604         }
 605 
 606         public InetSocketAddress getAddress() {
 607             return new InetSocketAddress(InetAddress.getLoopbackAddress(),
 608                     serverImpl.getAddress().getPort());
 609         }
 610 
 611         public InetSocketAddress getServerAddress() {
 612             return new InetSocketAddress(InetAddress.getLoopbackAddress(),
 613                     serverImpl.getAddress().getPort());
 614         }
 615 
 616         public InetSocketAddress getProxyAddress() {
 617             return new InetSocketAddress(InetAddress.getLoopbackAddress(),
 618                     serverImpl.getAddress().getPort());
 619         }
 620 
 621         public Version getServerVersion() {
 622             return serverImpl.getVersion();
 623         }
 624 
 625         public void stop() {
 626             serverImpl.stop();
 627             if (redirect != null) {
 628                 redirect.stop();
 629             }
 630         }
 631     }
 632 
 633     protected void writeResponse(HttpTestExchange he) throws IOException {
 634         if (delegate == null) {
 635             he.sendResponseHeaders(HttpURLConnection.HTTP_OK, -1);
 636             he.getResponseBody().write(he.getRequestBody().readAllBytes());
 637         } else {
 638             delegate.handle(he);
 639         }
 640     }
 641 
 642     private HttpTestHandler createHandler(HttpAuthSchemeType schemeType,
 643                                       HttpTestAuthenticator auth,
 644                                       HttpAuthType authType,
 645                                       boolean tunelled) {
 646         return new HttpNoAuthHandler(key, authType, tunelled);
 647     }
 648 
 649     void configureAuthentication(HttpTestContext ctxt,
 650                                  HttpAuthSchemeType schemeType,
 651                                  HttpTestAuthenticator auth,
 652                                  HttpAuthType authType) {
 653         switch(schemeType) {
 654             case DIGEST:
 655                 // DIGEST authentication is handled by the handler.
 656                 ctxt.addFilter(new HttpDigestFilter(key, auth, authType));
 657                 break;
 658             case BASIC:
 659                 // BASIC authentication is handled by the filter.
 660                 ctxt.addFilter(new HttpBasicFilter(key, auth, authType));
 661                 break;
 662             case BASICSERVER:
 663                 switch(authType) {
 664                     case PROXY: case PROXY305:
 665                         // HttpServer can&#39;t support Proxy-type authentication
 666                         // =&gt; we do as if BASIC had been specified, and we will
 667                         //    handle authentication in the handler.
 668                         ctxt.addFilter(new HttpBasicFilter(key, auth, authType));
 669                         break;
 670                     case SERVER: case SERVER307:
 671                         if (ctxt.getVersion() == Version.HTTP_1_1) {
 672                             // Basic authentication is handled by HttpServer
 673                             // directly =&gt; the filter should not perform
 674                             // authentication again.
 675                             setContextAuthenticator(ctxt, auth);
 676                             ctxt.addFilter(new HttpNoAuthFilter(key, authType));
 677                         } else {
 678                             ctxt.addFilter(new HttpBasicFilter(key, auth, authType));
 679                         }
 680                         break;
 681                     default:
 682                         throw new InternalError(key + &quot;: Invalid combination scheme=&quot;
 683                              + schemeType + &quot; authType=&quot; + authType);
 684                 }
 685             case NONE:
 686                 // No authentication at all.
 687                 ctxt.addFilter(new HttpNoAuthFilter(key, authType));
 688                 break;
 689             default:
 690                 throw new InternalError(key + &quot;: No such scheme: &quot; + schemeType);
 691         }
 692     }
 693 
 694     private HttpTestHandler create300Handler(String key, URL proxyURL,
 695                                              HttpAuthType type, int code300)
 696             throws MalformedURLException
 697     {
 698         return new Http3xxHandler(key, proxyURL, type, code300);
 699     }
 700 
 701     // Abstract HTTP filter class.
 702     private abstract static class AbstractHttpFilter extends HttpTestFilter {
 703 
 704         final HttpAuthType authType;
 705         final String type;
 706         public AbstractHttpFilter(HttpAuthType authType, String type) {
 707             this.authType = authType;
 708             this.type = type;
 709         }
 710 
 711         String getLocation() {
 712             return &quot;Location&quot;;
 713         }
 714         String getAuthenticate() {
 715             return authType == HttpAuthType.PROXY
 716                     ? &quot;Proxy-Authenticate&quot; : &quot;WWW-Authenticate&quot;;
 717         }
 718         String getAuthorization() {
 719             return authType == HttpAuthType.PROXY
 720                     ? &quot;Proxy-Authorization&quot; : &quot;Authorization&quot;;
 721         }
 722         int getUnauthorizedCode() {
 723             return authType == HttpAuthType.PROXY
 724                     ? HttpURLConnection.HTTP_PROXY_AUTH
 725                     : HttpURLConnection.HTTP_UNAUTHORIZED;
 726         }
 727         String getKeepAlive() {
 728             return &quot;keep-alive&quot;;
 729         }
 730         String getConnection() {
 731             return authType == HttpAuthType.PROXY
 732                     ? &quot;Proxy-Connection&quot; : &quot;Connection&quot;;
 733         }
 734         protected abstract boolean isAuthentified(HttpTestExchange he) throws IOException;
 735         protected abstract void requestAuthentication(HttpTestExchange he) throws IOException;
 736         protected void accept(HttpTestExchange he, HttpChain chain) throws IOException {
 737             chain.doFilter(he);
 738         }
 739 
 740         @Override
 741         public String description() {
 742             return &quot;Filter for &quot; + type;
 743         }
 744         @Override
 745         public void doFilter(HttpTestExchange he, HttpChain chain) throws IOException {
 746             try {
 747                 System.out.println(type + &quot;: Got &quot; + he.getRequestMethod()
 748                     + &quot;: &quot; + he.getRequestURI()
 749                     + &quot;\n&quot; + DigestEchoServer.toString(he.getRequestHeaders()));
 750 
 751                 // Assert only a single value for Expect. Not directly related
 752                 // to digest authentication, but verifies good client behaviour.
 753                 List&lt;String&gt; expectValues = he.getRequestHeaders().get(&quot;Expect&quot;);
 754                 if (expectValues != null &amp;&amp; expectValues.size() &gt; 1) {
 755                     throw new IOException(&quot;Expect:  &quot; + expectValues);
 756                 }
 757 
 758                 if (!isAuthentified(he)) {
 759                     try {
 760                         requestAuthentication(he);
 761                         he.sendResponseHeaders(getUnauthorizedCode(), -1);
 762                         System.out.println(type
 763                             + &quot;: Sent back &quot; + getUnauthorizedCode());
 764                     } finally {
 765                         he.close();
 766                     }
 767                 } else {
 768                     accept(he, chain);
 769                 }
 770             } catch (RuntimeException | Error | IOException t) {
 771                System.err.println(type
 772                     + &quot;: Unexpected exception while handling request: &quot; + t);
 773                t.printStackTrace(System.err);
 774                he.close();
 775                throw t;
 776             }
 777         }
 778 
 779     }
 780 
 781     // WARNING: This is not a full fledged implementation of DIGEST.
 782     // It does contain bugs and inaccuracy.
 783     final static class DigestResponse {
 784         final String realm;
 785         final String username;
 786         final String nonce;
 787         final String cnonce;
 788         final String nc;
 789         final String uri;
 790         final String algorithm;
 791         final String response;
 792         final String qop;
 793         final String opaque;
 794 
 795         public DigestResponse(String realm, String username, String nonce,
 796                               String cnonce, String nc, String uri,
 797                               String algorithm, String qop, String opaque,
 798                               String response) {
 799             this.realm = realm;
 800             this.username = username;
 801             this.nonce = nonce;
 802             this.cnonce = cnonce;
 803             this.nc = nc;
 804             this.uri = uri;
 805             this.algorithm = algorithm;
 806             this.qop = qop;
 807             this.opaque = opaque;
 808             this.response = response;
 809         }
 810 
 811         String getAlgorithm(String defval) {
 812             return algorithm == null ? defval : algorithm;
 813         }
 814         String getQoP(String defval) {
 815             return qop == null ? defval : qop;
 816         }
 817 
 818         // Code stolen from DigestAuthentication:
 819 
 820         private static final char charArray[] = {
 821             &#39;0&#39;, &#39;1&#39;, &#39;2&#39;, &#39;3&#39;, &#39;4&#39;, &#39;5&#39;, &#39;6&#39;, &#39;7&#39;,
 822             &#39;8&#39;, &#39;9&#39;, &#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;, &#39;e&#39;, &#39;f&#39;
 823         };
 824 
 825         private static String encode(String src, char[] passwd, MessageDigest md) {
 826             try {
 827                 md.update(src.getBytes(&quot;ISO-8859-1&quot;));
 828             } catch (java.io.UnsupportedEncodingException uee) {
 829                 assert false;
 830             }
 831             if (passwd != null) {
 832                 byte[] passwdBytes = new byte[passwd.length];
 833                 for (int i=0; i&lt;passwd.length; i++)
 834                     passwdBytes[i] = (byte)passwd[i];
 835                 md.update(passwdBytes);
 836                 Arrays.fill(passwdBytes, (byte)0x00);
 837             }
 838             byte[] digest = md.digest();
 839 
 840             StringBuilder res = new StringBuilder(digest.length * 2);
 841             for (int i = 0; i &lt; digest.length; i++) {
 842                 int hashchar = ((digest[i] &gt;&gt;&gt; 4) &amp; 0xf);
 843                 res.append(charArray[hashchar]);
 844                 hashchar = (digest[i] &amp; 0xf);
 845                 res.append(charArray[hashchar]);
 846             }
 847             return res.toString();
 848         }
 849 
 850         public static String computeDigest(boolean isRequest,
 851                                            String reqMethod,
 852                                            char[] password,
 853                                            DigestResponse params)
 854             throws NoSuchAlgorithmException
 855         {
 856 
 857             String A1, HashA1;
 858             String algorithm = params.getAlgorithm(&quot;MD5&quot;);
 859             boolean md5sess = algorithm.equalsIgnoreCase (&quot;MD5-sess&quot;);
 860 
 861             MessageDigest md = MessageDigest.getInstance(md5sess?&quot;MD5&quot;:algorithm);
 862 
 863             if (params.username == null) {
 864                 throw new IllegalArgumentException(&quot;missing username&quot;);
 865             }
 866             if (params.realm == null) {
 867                 throw new IllegalArgumentException(&quot;missing realm&quot;);
 868             }
 869             if (params.uri == null) {
 870                 throw new IllegalArgumentException(&quot;missing uri&quot;);
 871             }
 872             if (params.nonce == null) {
 873                 throw new IllegalArgumentException(&quot;missing nonce&quot;);
 874             }
 875 
 876             A1 = params.username + &quot;:&quot; + params.realm + &quot;:&quot;;
 877             HashA1 = encode(A1, password, md);
 878 
 879             String A2;
 880             if (isRequest) {
 881                 A2 = reqMethod + &quot;:&quot; + params.uri;
 882             } else {
 883                 A2 = &quot;:&quot; + params.uri;
 884             }
 885             String HashA2 = encode(A2, null, md);
 886             String combo, finalHash;
 887 
 888             if (&quot;auth&quot;.equals(params.qop)) { /* RRC2617 when qop=auth */
 889                 if (params.cnonce == null) {
 890                     throw new IllegalArgumentException(&quot;missing nonce&quot;);
 891                 }
 892                 if (params.nc == null) {
 893                     throw new IllegalArgumentException(&quot;missing nonce&quot;);
 894                 }
 895                 combo = HashA1+ &quot;:&quot; + params.nonce + &quot;:&quot; + params.nc + &quot;:&quot; +
 896                             params.cnonce + &quot;:auth:&quot; +HashA2;
 897 
 898             } else { /* for compatibility with RFC2069 */
 899                 combo = HashA1 + &quot;:&quot; +
 900                            params.nonce + &quot;:&quot; +
 901                            HashA2;
 902             }
 903             finalHash = encode(combo, null, md);
 904             return finalHash;
 905         }
 906 
 907         public static DigestResponse create(String raw) {
 908             String username, realm, nonce, nc, uri, response, cnonce,
 909                    algorithm, qop, opaque;
 910             HeaderParser parser = new HeaderParser(raw);
 911             username = parser.findValue(&quot;username&quot;);
 912             realm = parser.findValue(&quot;realm&quot;);
 913             nonce = parser.findValue(&quot;nonce&quot;);
 914             nc = parser.findValue(&quot;nc&quot;);
 915             uri = parser.findValue(&quot;uri&quot;);
 916             cnonce = parser.findValue(&quot;cnonce&quot;);
 917             response = parser.findValue(&quot;response&quot;);
 918             algorithm = parser.findValue(&quot;algorithm&quot;);
 919             qop = parser.findValue(&quot;qop&quot;);
 920             opaque = parser.findValue(&quot;opaque&quot;);
 921             return new DigestResponse(realm, username, nonce, cnonce, nc, uri,
 922                                       algorithm, qop, opaque, response);
 923         }
 924 
 925     }
 926 
 927     private static class HttpNoAuthFilter extends AbstractHttpFilter {
 928 
 929         static String type(String key, HttpAuthType authType) {
 930             String type = authType == HttpAuthType.SERVER
 931                     ? &quot;NoAuth Server Filter&quot; : &quot;NoAuth Proxy Filter&quot;;
 932             return &quot;[&quot;+type+&quot;]:&quot;+key;
 933         }
 934 
 935         public HttpNoAuthFilter(String key, HttpAuthType authType) {
 936             super(authType, type(key, authType));
 937         }
 938 
 939         @Override
 940         protected boolean isAuthentified(HttpTestExchange he) throws IOException {
 941             return true;
 942         }
 943 
 944         @Override
 945         protected void requestAuthentication(HttpTestExchange he) throws IOException {
 946             throw new InternalError(&quot;Should not com here&quot;);
 947         }
 948 
 949         @Override
 950         public String description() {
 951             return &quot;Passthrough Filter&quot;;
 952         }
 953 
 954     }
 955 
 956     // An HTTP Filter that performs Basic authentication
 957     private static class HttpBasicFilter extends AbstractHttpFilter {
 958 
 959         static String type(String key, HttpAuthType authType) {
 960             String type = authType == HttpAuthType.SERVER
 961                     ? &quot;Basic Server Filter&quot; : &quot;Basic Proxy Filter&quot;;
 962             return &quot;[&quot;+type+&quot;]:&quot;+key;
 963         }
 964 
 965         private final HttpTestAuthenticator auth;
 966         public HttpBasicFilter(String key, HttpTestAuthenticator auth,
 967                                HttpAuthType authType) {
 968             super(authType, type(key, authType));
 969             this.auth = auth;
 970         }
 971 
 972         @Override
 973         protected void requestAuthentication(HttpTestExchange he)
 974             throws IOException
 975         {
 976             String headerName = getAuthenticate();
 977             String headerValue = &quot;Basic realm=\&quot;&quot; + auth.getRealm() + &quot;\&quot;&quot;;
 978             he.getResponseHeaders().addHeader(headerName, headerValue);
 979             System.out.println(type + &quot;: Requesting Basic Authentication, &quot;
 980                                + headerName + &quot; : &quot;+ headerValue);
 981         }
 982 
 983         @Override
 984         protected boolean isAuthentified(HttpTestExchange he) {
 985             if (he.getRequestHeaders().containsKey(getAuthorization())) {
 986                 List&lt;String&gt; authorization =
 987                     he.getRequestHeaders().get(getAuthorization());
 988                 for (String a : authorization) {
 989                     System.out.println(type + &quot;: processing &quot; + a);
 990                     int sp = a.indexOf(&#39; &#39;);
 991                     if (sp &lt; 0) return false;
 992                     String scheme = a.substring(0, sp);
 993                     if (!&quot;Basic&quot;.equalsIgnoreCase(scheme)) {
 994                         System.out.println(type + &quot;: Unsupported scheme &#39;&quot;
 995                                            + scheme +&quot;&#39;&quot;);
 996                         return false;
 997                     }
 998                     if (a.length() &lt;= sp+1) {
 999                         System.out.println(type + &quot;: value too short for &#39;&quot;
1000                                             + scheme +&quot;&#39;&quot;);
1001                         return false;
1002                     }
1003                     a = a.substring(sp+1);
1004                     return validate(a);
1005                 }
1006                 return false;
1007             }
1008             return false;
1009         }
1010 
1011         boolean validate(String a) {
1012             byte[] b = Base64.getDecoder().decode(a);
1013             String userpass = new String (b);
1014             int colon = userpass.indexOf (&#39;:&#39;);
1015             String uname = userpass.substring (0, colon);
1016             String pass = userpass.substring (colon+1);
1017             return auth.getUserName().equals(uname) &amp;&amp;
1018                    new String(auth.getPassword(uname)).equals(pass);
1019         }
1020 
1021         @Override
1022         public String description() {
1023             return &quot;Filter for BASIC authentication: &quot; + type;
1024         }
1025 
1026     }
1027 
1028 
1029     // An HTTP Filter that performs Digest authentication
1030     // WARNING: This is not a full fledged implementation of DIGEST.
1031     // It does contain bugs and inaccuracy.
1032     private static class HttpDigestFilter extends AbstractHttpFilter {
1033 
1034         static String type(String key, HttpAuthType authType) {
1035             String type = authType == HttpAuthType.SERVER
1036                     ? &quot;Digest Server Filter&quot; : &quot;Digest Proxy Filter&quot;;
1037             return &quot;[&quot;+type+&quot;]:&quot;+key;
1038         }
1039 
1040         // This is a very basic DIGEST - used only for the purpose of testing
1041         // the client implementation. Therefore we can get away with never
1042         // updating the server nonce as it makes the implementation of the
1043         // server side digest simpler.
1044         private final HttpTestAuthenticator auth;
1045         private final byte[] nonce;
1046         private final String ns;
1047         public HttpDigestFilter(String key, HttpTestAuthenticator auth, HttpAuthType authType) {
1048             super(authType, type(key, authType));
1049             this.auth = auth;
1050             nonce = new byte[16];
1051             new Random(Instant.now().toEpochMilli()).nextBytes(nonce);
1052             ns = new BigInteger(1, nonce).toString(16);
1053         }
1054 
1055         @Override
1056         protected void requestAuthentication(HttpTestExchange he)
1057                 throws IOException {
1058             String separator;
1059             Version v = he.getExchangeVersion();
1060             if (v == Version.HTTP_1_1) {
1061                 separator = &quot;\r\n    &quot;;
1062             } else if (v == Version.HTTP_2) {
1063                 separator = &quot; &quot;;
1064             } else {
1065                 throw new InternalError(String.valueOf(v));
1066             }
1067             String headerName = getAuthenticate();
1068             String headerValue = &quot;Digest realm=\&quot;&quot; + auth.getRealm() + &quot;\&quot;,&quot;
1069                     + separator + &quot;qop=\&quot;auth\&quot;,&quot;
1070                     + separator + &quot;nonce=\&quot;&quot; + ns +&quot;\&quot;&quot;;
1071             he.getResponseHeaders().addHeader(headerName, headerValue);
1072             System.out.println(type + &quot;: Requesting Digest Authentication, &quot;
1073                                + headerName + &quot; : &quot; + headerValue);
1074         }
1075 
1076         @Override
1077         protected boolean isAuthentified(HttpTestExchange he) {
1078             if (he.getRequestHeaders().containsKey(getAuthorization())) {
1079                 List&lt;String&gt; authorization = he.getRequestHeaders().get(getAuthorization());
1080                 for (String a : authorization) {
1081                     System.out.println(type + &quot;: processing &quot; + a);
1082                     int sp = a.indexOf(&#39; &#39;);
1083                     if (sp &lt; 0) return false;
1084                     String scheme = a.substring(0, sp);
1085                     if (!&quot;Digest&quot;.equalsIgnoreCase(scheme)) {
1086                         System.out.println(type + &quot;: Unsupported scheme &#39;&quot; + scheme +&quot;&#39;&quot;);
1087                         return false;
1088                     }
1089                     if (a.length() &lt;= sp+1) {
1090                         System.out.println(type + &quot;: value too short for &#39;&quot; + scheme +&quot;&#39;&quot;);
1091                         return false;
1092                     }
1093                     a = a.substring(sp+1);
1094                     DigestResponse dgr = DigestResponse.create(a);
1095                     return validate(he.getRequestURI(), he.getRequestMethod(), dgr);
1096                 }
1097                 return false;
1098             }
1099             return false;
1100         }
1101 
1102         boolean validate(URI uri, String reqMethod, DigestResponse dg) {
1103             if (!&quot;MD5&quot;.equalsIgnoreCase(dg.getAlgorithm(&quot;MD5&quot;))) {
1104                 System.out.println(type + &quot;: Unsupported algorithm &quot;
1105                                    + dg.algorithm);
1106                 return false;
1107             }
1108             if (!&quot;auth&quot;.equalsIgnoreCase(dg.getQoP(&quot;auth&quot;))) {
1109                 System.out.println(type + &quot;: Unsupported qop &quot;
1110                                    + dg.qop);
1111                 return false;
1112             }
1113             try {
1114                 if (!dg.nonce.equals(ns)) {
1115                     System.out.println(type + &quot;: bad nonce returned by client: &quot;
1116                                     + nonce + &quot; expected &quot; + ns);
1117                     return false;
1118                 }
1119                 if (dg.response == null) {
1120                     System.out.println(type + &quot;: missing digest response.&quot;);
1121                     return false;
1122                 }
1123                 char[] pa = auth.getPassword(dg.username);
1124                 return verify(uri, reqMethod, dg, pa);
1125             } catch(IllegalArgumentException | SecurityException
1126                     | NoSuchAlgorithmException e) {
1127                 System.out.println(type + &quot;: &quot; + e.getMessage());
1128                 return false;
1129             }
1130         }
1131 
1132 
1133         boolean verify(URI uri, String reqMethod, DigestResponse dg, char[] pw)
1134             throws NoSuchAlgorithmException {
1135             String response = DigestResponse.computeDigest(true, reqMethod, pw, dg);
1136             if (!dg.response.equals(response)) {
1137                 System.out.println(type + &quot;: bad response returned by client: &quot;
1138                                     + dg.response + &quot; expected &quot; + response);
1139                 return false;
1140             } else {
1141                 // A real server would also verify the uri=&lt;request-uri&gt;
1142                 // parameter - but this is just a test...
1143                 System.out.println(type + &quot;: verified response &quot; + response);
1144             }
1145             return true;
1146         }
1147 
1148 
1149         @Override
1150         public String description() {
1151             return &quot;Filter for DIGEST authentication: &quot; + type;
1152         }
1153     }
1154 
1155     // Abstract HTTP handler class.
1156     private abstract static class AbstractHttpHandler implements HttpTestHandler {
1157 
1158         final HttpAuthType authType;
1159         final String type;
1160         public AbstractHttpHandler(HttpAuthType authType, String type) {
1161             this.authType = authType;
1162             this.type = type;
1163         }
1164 
1165         String getLocation() {
1166             return &quot;Location&quot;;
1167         }
1168 
1169         @Override
1170         public void handle(HttpTestExchange he) throws IOException {
1171             try {
1172                 sendResponse(he);
1173             } catch (RuntimeException | Error | IOException t) {
1174                System.err.println(type
1175                     + &quot;: Unexpected exception while handling request: &quot; + t);
1176                t.printStackTrace(System.err);
1177                throw t;
1178             } finally {
1179                 he.close();
1180             }
1181         }
1182 
1183         protected abstract void sendResponse(HttpTestExchange he) throws IOException;
1184 
1185     }
1186 
1187     static String stype(String type, String key, HttpAuthType authType, boolean tunnelled) {
1188         type = type + (authType == HttpAuthType.SERVER
1189                        ? &quot; Server&quot; : &quot; Proxy&quot;)
1190                 + (tunnelled ? &quot; Tunnelled&quot; : &quot;&quot;);
1191         return &quot;[&quot;+type+&quot;]:&quot;+key;
1192     }
1193 
1194     private class HttpNoAuthHandler extends AbstractHttpHandler {
1195 
1196         // true if this server is behind a proxy tunnel.
1197         final boolean tunnelled;
1198         public HttpNoAuthHandler(String key, HttpAuthType authType, boolean tunnelled) {
1199             super(authType, stype(&quot;NoAuth&quot;, key, authType, tunnelled));
1200             this.tunnelled = tunnelled;
1201         }
1202 
1203         @Override
1204         protected void sendResponse(HttpTestExchange he) throws IOException {
1205             if (DEBUG) {
1206                 System.out.println(type + &quot;: headers are: &quot;
1207                         + DigestEchoServer.toString(he.getRequestHeaders()));
1208             }
1209             if (authType == HttpAuthType.SERVER &amp;&amp; tunnelled) {
1210                 // Verify that the client doesn&#39;t send us proxy-* headers
1211                 // used to establish the proxy tunnel
1212                 Optional&lt;String&gt; proxyAuth = he.getRequestHeaders()
1213                         .keySet().stream()
1214                         .filter(&quot;proxy-authorization&quot;::equalsIgnoreCase)
1215                         .findAny();
1216                 if (proxyAuth.isPresent()) {
1217                     System.out.println(type + &quot; found &quot;
1218                             + proxyAuth.get() + &quot;: failing!&quot;);
1219                     throw new IOException(proxyAuth.get()
1220                             + &quot; found by &quot; + type + &quot; for &quot;
1221                             + he.getRequestURI());
1222                 }
1223             }
1224             DigestEchoServer.this.writeResponse(he);
1225         }
1226 
1227     }
1228 
1229     // A dummy HTTP Handler that redirects all incoming requests
1230     // by sending a back 3xx response code (301, 305, 307 etc..)
1231     private class Http3xxHandler extends AbstractHttpHandler {
1232 
1233         private final URL redirectTargetURL;
1234         private final int code3XX;
1235         public Http3xxHandler(String key, URL proxyURL, HttpAuthType authType, int code300) {
1236             super(authType, stype(&quot;Server&quot; + code300, key, authType, false));
1237             this.redirectTargetURL = proxyURL;
1238             this.code3XX = code300;
1239         }
1240 
1241         int get3XX() {
1242             return code3XX;
1243         }
1244 
1245         @Override
1246         public void sendResponse(HttpTestExchange he) throws IOException {
1247             System.out.println(type + &quot;: Got &quot; + he.getRequestMethod()
1248                     + &quot;: &quot; + he.getRequestURI()
1249                     + &quot;\n&quot; + DigestEchoServer.toString(he.getRequestHeaders()));
1250             System.out.println(type + &quot;: Redirecting to &quot;
1251                                + (authType == HttpAuthType.PROXY305
1252                                     ? &quot;proxy&quot; : &quot;server&quot;));
1253             he.getResponseHeaders().addHeader(getLocation(),
1254                 redirectTargetURL.toExternalForm().toString());
1255             he.sendResponseHeaders(get3XX(), -1);
1256             System.out.println(type + &quot;: Sent back &quot; + get3XX() + &quot; &quot;
1257                  + getLocation() + &quot;: &quot; + redirectTargetURL.toExternalForm().toString());
1258         }
1259     }
1260 
1261     static class Configurator extends HttpsConfigurator {
1262         public Configurator(SSLContext ctx) {
1263             super(ctx);
1264         }
1265 
1266         @Override
1267         public void configure (HttpsParameters params) {
1268             params.setSSLParameters (getSSLContext().getSupportedSSLParameters());
1269         }
1270     }
1271 
1272     static final long start = System.nanoTime();
1273     public static String now() {
1274         long now = System.nanoTime() - start;
1275         long secs = now / 1000_000_000;
1276         long mill = (now % 1000_000_000) / 1000_000;
1277         long nan = now % 1000_000;
1278         return String.format(&quot;[%d s, %d ms, %d ns] &quot;, secs, mill, nan);
1279     }
1280 
1281     static class  ProxyAuthorization {
1282         final HttpAuthSchemeType schemeType;
1283         final HttpTestAuthenticator authenticator;
1284         private final byte[] nonce;
1285         private final String ns;
1286         private final String key;
1287 
1288         ProxyAuthorization(String key, HttpAuthSchemeType schemeType, HttpTestAuthenticator auth) {
1289             this.key = key;
1290             this.schemeType = schemeType;
1291             this.authenticator = auth;
1292             nonce = new byte[16];
1293             new Random(Instant.now().toEpochMilli()).nextBytes(nonce);
1294             ns = new BigInteger(1, nonce).toString(16);
1295         }
1296 
1297         String doBasic(Optional&lt;String&gt; authorization) {
1298             String offset = &quot;proxy-authorization: basic &quot;;
1299             String authstring = authorization.orElse(&quot;&quot;);
1300             if (!authstring.toLowerCase(Locale.US).startsWith(offset)) {
1301                 return &quot;Proxy-Authenticate: BASIC &quot; + &quot;realm=\&quot;&quot;
1302                         + authenticator.getRealm() +&quot;\&quot;&quot;;
1303             }
1304             authstring = authstring
1305                     .substring(offset.length())
1306                     .trim();
1307             byte[] base64 = Base64.getDecoder().decode(authstring);
1308             String up = new String(base64, StandardCharsets.UTF_8);
1309             int colon = up.indexOf(&#39;:&#39;);
1310             if (colon &lt; 1) {
1311                 return &quot;Proxy-Authenticate: BASIC &quot; + &quot;realm=\&quot;&quot;
1312                         + authenticator.getRealm() +&quot;\&quot;&quot;;
1313             }
1314             String u = up.substring(0, colon);
1315             String p = up.substring(colon+1);
1316             char[] pw = authenticator.getPassword(u);
1317             if (!p.equals(new String(pw))) {
1318                 return &quot;Proxy-Authenticate: BASIC &quot; + &quot;realm=\&quot;&quot;
1319                         + authenticator.getRealm() +&quot;\&quot;&quot;;
1320             }
1321             System.out.println(now() + key + &quot; Proxy basic authentication success&quot;);
1322             return null;
1323         }
1324 
1325         String doDigest(Optional&lt;String&gt; authorization) {
1326             String offset = &quot;proxy-authorization: digest &quot;;
1327             String authstring = authorization.orElse(&quot;&quot;);
1328             if (!authstring.toLowerCase(Locale.US).startsWith(offset)) {
1329                 return &quot;Proxy-Authenticate: &quot; +
1330                         &quot;Digest realm=\&quot;&quot; + authenticator.getRealm() + &quot;\&quot;,&quot;
1331                         + &quot;\r\n    qop=\&quot;auth\&quot;,&quot;
1332                         + &quot;\r\n    nonce=\&quot;&quot; + ns +&quot;\&quot;&quot;;
1333             }
1334             authstring = authstring
1335                     .substring(offset.length())
1336                     .trim();
1337             boolean validated = false;
1338             try {
1339                 DigestResponse dgr = DigestResponse.create(authstring);
1340                 validated = validate(&quot;CONNECT&quot;, dgr);
1341             } catch (Throwable t) {
1342                 t.printStackTrace();
1343             }
1344             if (!validated) {
1345                 return &quot;Proxy-Authenticate: &quot; +
1346                         &quot;Digest realm=\&quot;&quot; + authenticator.getRealm() + &quot;\&quot;,&quot;
1347                         + &quot;\r\n    qop=\&quot;auth\&quot;,&quot;
1348                         + &quot;\r\n    nonce=\&quot;&quot; + ns +&quot;\&quot;&quot;;
1349             }
1350             return null;
1351         }
1352 
1353 
1354 
1355 
1356         boolean validate(String reqMethod, DigestResponse dg) {
1357             String type = now() + this.getClass().getSimpleName() + &quot;:&quot; + key;
1358             if (!&quot;MD5&quot;.equalsIgnoreCase(dg.getAlgorithm(&quot;MD5&quot;))) {
1359                 System.out.println(type + &quot;: Unsupported algorithm &quot;
1360                         + dg.algorithm);
1361                 return false;
1362             }
1363             if (!&quot;auth&quot;.equalsIgnoreCase(dg.getQoP(&quot;auth&quot;))) {
1364                 System.out.println(type + &quot;: Unsupported qop &quot;
1365                         + dg.qop);
1366                 return false;
1367             }
1368             try {
1369                 if (!dg.nonce.equals(ns)) {
1370                     System.out.println(type + &quot;: bad nonce returned by client: &quot;
1371                             + nonce + &quot; expected &quot; + ns);
1372                     return false;
1373                 }
1374                 if (dg.response == null) {
1375                     System.out.println(type + &quot;: missing digest response.&quot;);
1376                     return false;
1377                 }
1378                 char[] pa = authenticator.getPassword(dg.username);
1379                 return verify(type, reqMethod, dg, pa);
1380             } catch(IllegalArgumentException | SecurityException
1381                     | NoSuchAlgorithmException e) {
1382                 System.out.println(type + &quot;: &quot; + e.getMessage());
1383                 return false;
1384             }
1385         }
1386 
1387 
1388         boolean verify(String type, String reqMethod, DigestResponse dg, char[] pw)
1389                 throws NoSuchAlgorithmException {
1390             String response = DigestResponse.computeDigest(true, reqMethod, pw, dg);
1391             if (!dg.response.equals(response)) {
1392                 System.out.println(type + &quot;: bad response returned by client: &quot;
1393                         + dg.response + &quot; expected &quot; + response);
1394                 return false;
1395             } else {
1396                 // A real server would also verify the uri=&lt;request-uri&gt;
1397                 // parameter - but this is just a test...
1398                 System.out.println(type + &quot;: verified response &quot; + response);
1399             }
1400             return true;
1401         }
1402 
1403         public boolean authorize(StringBuilder response, String requestLine, String headers) {
1404             String message = &quot;&lt;html&gt;&lt;body&gt;&lt;p&gt;Authorization Failed%s&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;\r\n&quot;;
1405             if (authenticator == null &amp;&amp; schemeType != HttpAuthSchemeType.NONE) {
1406                 message = String.format(message, &quot; No Authenticator Set&quot;);
1407                 response.append(&quot;HTTP/1.1 407 Proxy Authentication Failed\r\n&quot;);
1408                 response.append(&quot;Content-Length: &quot;)
1409                         .append(message.getBytes(StandardCharsets.UTF_8).length)
1410                         .append(&quot;\r\n\r\n&quot;);
1411                 response.append(message);
1412                 return false;
1413             }
1414             Optional&lt;String&gt; authorization = Stream.of(headers.split(&quot;\r\n&quot;))
1415                     .filter((k) -&gt; k.toLowerCase(Locale.US).startsWith(&quot;proxy-authorization:&quot;))
1416                     .findFirst();
1417             String authenticate = null;
1418             switch(schemeType) {
1419                 case BASIC:
1420                 case BASICSERVER:
1421                     authenticate = doBasic(authorization);
1422                     break;
1423                 case DIGEST:
1424                     authenticate = doDigest(authorization);
1425                     break;
1426                 case NONE:
1427                     response.append(&quot;HTTP/1.1 200 OK\r\nContent-Length: 0\r\n\r\n&quot;);
1428                     return true;
1429                 default:
1430                     throw new InternalError(&quot;Unknown scheme type: &quot; + schemeType);
1431             }
1432             if (authenticate != null) {
1433                 message = String.format(message, &quot;&quot;);
1434                 response.append(&quot;HTTP/1.1 407 Proxy Authentication Required\r\n&quot;);
1435                 response.append(&quot;Content-Length: &quot;)
1436                         .append(message.getBytes(StandardCharsets.UTF_8).length)
1437                         .append(&quot;\r\n&quot;)
1438                         .append(authenticate)
1439                         .append(&quot;\r\n\r\n&quot;);
1440                 response.append(message);
1441                 return false;
1442             }
1443             response.append(&quot;HTTP/1.1 200 OK\r\nContent-Length: 0\r\n\r\n&quot;);
1444             return true;
1445         }
1446     }
1447 
1448     public interface TunnelingProxy {
1449         InetSocketAddress getProxyAddress();
1450         void stop();
1451     }
1452 
1453     // This is a bit hacky: HttpsProxyTunnel is an HTTPTestServer hidden
1454     // behind a fake proxy that only understands CONNECT requests.
1455     // The fake proxy is just a server socket that intercept the
1456     // CONNECT and then redirect streams to the real server.
1457     static class HttpsProxyTunnel extends DigestEchoServer
1458             implements Runnable, TunnelingProxy {
1459 
1460         final ServerSocket ss;
1461         final CopyOnWriteArrayList&lt;CompletableFuture&lt;Void&gt;&gt; connectionCFs
1462                 = new CopyOnWriteArrayList&lt;&gt;();
1463         volatile ProxyAuthorization authorization;
1464         volatile boolean stopped;
1465         public HttpsProxyTunnel(String key, HttpTestServer server, DigestEchoServer target,
1466                                 HttpTestHandler delegate)
1467                 throws IOException {
1468             this(key, server, target, delegate, ServerSocketFactory.create());
1469         }
1470         private HttpsProxyTunnel(String key, HttpTestServer server, DigestEchoServer target,
1471                                 HttpTestHandler delegate, ServerSocket ss)
1472                 throws IOException {
1473             super(&quot;HttpsProxyTunnel:&quot; + ss.getLocalPort() + &quot;:&quot; + key,
1474                     server, target, delegate);
1475             System.out.flush();
1476             System.err.println(&quot;WARNING: HttpsProxyTunnel is an experimental test class&quot;);
1477             this.ss = ss;
1478             start();
1479         }
1480 
1481         final void start() throws IOException {
1482             Thread t = new Thread(this, &quot;ProxyThread&quot;);
1483             t.setDaemon(true);
1484             t.start();
1485         }
1486 
1487         @Override
1488         public Version getServerVersion() {
1489             // serverImpl is not null when this proxy
1490             // serves a single server. It will be null
1491             // if this proxy can serve multiple servers.
1492             if (serverImpl != null) return serverImpl.getVersion();
1493             return null;
1494         }
1495 
1496         @Override
1497         public void stop() {
1498             stopped = true;
1499             if (serverImpl != null) {
1500                 serverImpl.stop();
1501             }
1502             if (redirect != null) {
1503                 redirect.stop();
1504             }
1505             try {
1506                 ss.close();
1507             } catch (IOException ex) {
1508                 if (DEBUG) ex.printStackTrace(System.out);
1509             }
1510         }
1511 
1512 
1513         @Override
1514         void configureAuthentication(HttpTestContext ctxt,
1515                                      HttpAuthSchemeType schemeType,
1516                                      HttpTestAuthenticator auth,
1517                                      HttpAuthType authType) {
1518             if (authType == HttpAuthType.PROXY || authType == HttpAuthType.PROXY305) {
1519                 authorization = new ProxyAuthorization(key, schemeType, auth);
1520             } else {
1521                 super.configureAuthentication(ctxt, schemeType, auth, authType);
1522             }
1523         }
1524 
<a name="3" id="anc3"></a>





























1525         boolean authorize(StringBuilder response, String requestLine, String headers) {
1526             if (authorization != null) {
1527                 return authorization.authorize(response, requestLine, headers);
1528             }
1529             response.append(&quot;HTTP/1.1 200 OK\r\nContent-Length: 0\r\n\r\n&quot;);
1530             return true;
1531         }
1532 
1533         // Pipe the input stream to the output stream.
1534         private synchronized Thread pipe(InputStream is, OutputStream os, char tag, CompletableFuture&lt;Void&gt; end) {
1535             return new Thread(&quot;TunnelPipe(&quot;+tag+&quot;)&quot;) {
1536                 @Override
1537                 public void run() {
1538                     try {
<a name="4" id="anc4"></a>
1539                         try {
<a name="5" id="anc5"></a><span class="line-removed">1540                             int c;</span>
1541                             while ((c = is.read()) != -1) {
1542                                 os.write(c);
1543                                 os.flush();
1544                                 // if DEBUG prints a + or a - for each transferred
1545                                 // character.
1546                                 if (DEBUG) System.out.print(tag);
1547                             }
1548                             is.close();
<a name="6" id="anc6"></a>



1549                         } finally {
<a name="7" id="anc7"></a><span class="line-modified">1550                             os.close();</span>
1551                         }
<a name="8" id="anc8"></a><span class="line-removed">1552                     } catch (IOException ex) {</span>
<span class="line-removed">1553                         if (DEBUG) ex.printStackTrace(System.out);</span>
1554                     } finally {
1555                         end.complete(null);
1556                     }
1557                 }
1558             };
1559         }
1560 
1561         @Override
1562         public InetSocketAddress getAddress() {
1563             return new InetSocketAddress(InetAddress.getLoopbackAddress(),
1564                     ss.getLocalPort());
1565         }
1566         @Override
1567         public InetSocketAddress getProxyAddress() {
1568             return getAddress();
1569         }
1570         @Override
1571         public InetSocketAddress getServerAddress() {
1572             // serverImpl can be null if this proxy can serve
1573             // multiple servers.
1574             if (serverImpl != null) {
1575                 return serverImpl.getAddress();
1576             }
1577             return null;
1578         }
1579 
1580 
1581         // This is a bit shaky. It doesn&#39;t handle continuation
1582         // lines, but our client shouldn&#39;t send any.
1583         // Read a line from the input stream, swallowing the final
1584         // \r\n sequence. Stops at the first \n, doesn&#39;t complain
1585         // if it wasn&#39;t preceded by &#39;\r&#39;.
1586         //
1587         String readLine(InputStream r) throws IOException {
1588             StringBuilder b = new StringBuilder();
1589             int c;
1590             while ((c = r.read()) != -1) {
1591                 if (c == &#39;\n&#39;) break;
1592                 b.appendCodePoint(c);
1593             }
1594             if (b.codePointAt(b.length() -1) == &#39;\r&#39;) {
1595                 b.delete(b.length() -1, b.length());
1596             }
1597             return b.toString();
1598         }
1599 
1600         @Override
1601         public void run() {
1602             Socket clientConnection = null;
<a name="9" id="anc9"></a>
1603             try {
1604                 while (!stopped) {
1605                     System.out.println(now() + &quot;Tunnel: Waiting for client&quot;);
1606                     Socket toClose;
<a name="10" id="anc10"></a>
1607                     try {
1608                         toClose = clientConnection = ss.accept();
1609                         if (NO_LINGER) {
1610                             // can be useful to trigger &quot;Connection reset by peer&quot;
1611                             // errors on the client side.
1612                             clientConnection.setOption(StandardSocketOptions.SO_LINGER, 0);
1613                         }
1614                     } catch (IOException io) {
1615                         if (DEBUG || !stopped) io.printStackTrace(System.out);
1616                         break;
1617                     }
1618                     System.out.println(now() + &quot;Tunnel: Client accepted&quot;);
1619                     StringBuilder headers = new StringBuilder();
<a name="11" id="anc11"></a><span class="line-removed">1620                     Socket targetConnection = null;</span>
1621                     InputStream  ccis = clientConnection.getInputStream();
1622                     OutputStream ccos = clientConnection.getOutputStream();
1623                     Writer w = new OutputStreamWriter(
1624                                    clientConnection.getOutputStream(), &quot;UTF-8&quot;);
1625                     PrintWriter pw = new PrintWriter(w);
1626                     System.out.println(now() + &quot;Tunnel: Reading request line&quot;);
1627                     String requestLine = readLine(ccis);
1628                     System.out.println(now() + &quot;Tunnel: Request line: &quot; + requestLine);
1629                     if (requestLine.startsWith(&quot;CONNECT &quot;)) {
1630                         // We should probably check that the next word following
1631                         // CONNECT is the host:port of our HTTPS serverImpl.
1632                         // Some improvement for a followup!
1633                         StringTokenizer tokenizer = new StringTokenizer(requestLine);
1634                         String connect = tokenizer.nextToken();
1635                         assert connect.equalsIgnoreCase(&quot;connect&quot;);
1636                         String hostport = tokenizer.nextToken();
1637                         InetSocketAddress targetAddress;
<a name="12" id="anc12"></a>
1638                         try {
1639                             URI uri = new URI(&quot;https&quot;, hostport, &quot;/&quot;, null, null);
1640                             int port = uri.getPort();
1641                             port = port == -1 ? 443 : port;
1642                             targetAddress = new InetSocketAddress(uri.getHost(), port);
1643                             if (serverImpl != null) {
1644                                 assert targetAddress.getHostString()
1645                                         .equalsIgnoreCase(serverImpl.getAddress().getHostString());
1646                                 assert targetAddress.getPort() == serverImpl.getAddress().getPort();
1647                             }
1648                         } catch (Throwable x) {
1649                             System.err.printf(&quot;Bad target address: \&quot;%s\&quot; in \&quot;%s\&quot;%n&quot;,
1650                                     hostport, requestLine);
1651                             toClose.close();
1652                             continue;
1653                         }
1654 
1655                         // Read all headers until we find the empty line that
1656                         // signals the end of all headers.
1657                         String line = requestLine;
1658                         while(!line.equals(&quot;&quot;)) {
1659                             System.out.println(now() + &quot;Tunnel: Reading header: &quot;
1660                                                + (line = readLine(ccis)));
1661                             headers.append(line).append(&quot;\r\n&quot;);
<a name="13" id="anc13"></a>






1662                         }
<a name="14" id="anc14"></a><span class="line-removed">1663 </span>
1664                         StringBuilder response = new StringBuilder();
<a name="15" id="anc15"></a>














1665                         final boolean authorize = authorize(response, requestLine, headers.toString());
1666                         if (!authorize) {
1667                             System.out.println(now() + &quot;Tunnel: Sending &quot;
1668                                     + response);
1669                             // send the 407 response
1670                             pw.print(response.toString());
1671                             pw.flush();
1672                             toClose.close();
1673                             continue;
1674                         }
1675                         System.out.println(now()
1676                                 + &quot;Tunnel connecting to target server at &quot;
1677                                 + targetAddress.getAddress() + &quot;:&quot; + targetAddress.getPort());
1678                         targetConnection = new Socket(
1679                                 targetAddress.getAddress(),
1680                                 targetAddress.getPort());
1681 
1682                         // Then send the 200 OK response to the client
1683                         System.out.println(now() + &quot;Tunnel: Sending &quot;
1684                                            + response);
1685                         pw.print(response);
1686                         pw.flush();
1687                     } else {
1688                         // This should not happen. If it does then just print an
1689                         // error - both on out and err, and close the accepted
1690                         // socket
1691                         System.out.println(&quot;WARNING: Tunnel: Unexpected status line: &quot;
1692                                 + requestLine + &quot; received by &quot;
1693                                 + ss.getLocalSocketAddress()
1694                                 + &quot; from &quot;
1695                                 + toClose.getRemoteSocketAddress()
1696                                 + &quot; - closing accepted socket&quot;);
1697                         // Print on err
1698                         System.err.println(&quot;WARNING: Tunnel: Unexpected status line: &quot;
1699                                              + requestLine + &quot; received by &quot;
1700                                            + ss.getLocalSocketAddress()
1701                                            + &quot; from &quot;
1702                                            + toClose.getRemoteSocketAddress());
1703                         // close accepted socket.
1704                         toClose.close();
1705                         System.err.println(&quot;Tunnel: accepted socket closed.&quot;);
1706                         continue;
1707                     }
1708 
1709                     // Pipe the input stream of the client connection to the
1710                     // output stream of the target connection and conversely.
1711                     // Now the client and target will just talk to each other.
1712                     System.out.println(now() + &quot;Tunnel: Starting tunnel pipes&quot;);
1713                     CompletableFuture&lt;Void&gt; end, end1, end2;
1714                     Thread t1 = pipe(ccis, targetConnection.getOutputStream(), &#39;+&#39;,
1715                             end1 = new CompletableFuture&lt;&gt;());
1716                     Thread t2 = pipe(targetConnection.getInputStream(), ccos, &#39;-&#39;,
1717                             end2 = new CompletableFuture&lt;&gt;());
<a name="16" id="anc16"></a><span class="line-modified">1718                     end = CompletableFuture.allOf(end1, end2);</span>



1719                     end.whenComplete(
1720                             (r,t) -&gt; {
1721                                 try { toClose.close(); } catch (IOException x) { }
<a name="17" id="anc17"></a>
1722                                 finally {connectionCFs.remove(end);}
1723                             });
1724                     connectionCFs.add(end);
<a name="18" id="anc18"></a>
1725                     t1.start();
1726                     t2.start();
1727                 }
1728             } catch (Throwable ex) {
<a name="19" id="anc19"></a><span class="line-modified">1729                 try {</span>
<span class="line-modified">1730                     ss.close();</span>
<span class="line-modified">1731                 } catch (IOException ex1) {</span>
<span class="line-removed">1732                     ex.addSuppressed(ex1);</span>
<span class="line-removed">1733                 }</span>
1734                 ex.printStackTrace(System.err);
1735             } finally {
1736                 System.out.println(now() + &quot;Tunnel: exiting (stopped=&quot; + stopped + &quot;)&quot;);
1737                 connectionCFs.forEach(cf -&gt; cf.complete(null));
1738             }
1739         }
<a name="20" id="anc20"></a>












1740     }
1741 
1742     /**
1743      * Creates a TunnelingProxy that can serve multiple servers.
1744      * The server address is extracted from the CONNECT request line.
1745      * @param authScheme The authentication scheme supported by the proxy.
1746      *                   Typically one of DIGEST, BASIC, NONE.
1747      * @return A new TunnelingProxy able to serve multiple servers.
1748      * @throws IOException If the proxy could not be created.
1749      */
1750     public static TunnelingProxy createHttpsProxyTunnel(HttpAuthSchemeType authScheme)
1751             throws IOException {
1752         HttpsProxyTunnel result = new HttpsProxyTunnel(&quot;&quot;, null, null, null);
1753         if (authScheme != HttpAuthSchemeType.NONE) {
1754             result.configureAuthentication(null,
1755                                            authScheme,
1756                                            AUTHENTICATOR,
1757                                            HttpAuthType.PROXY);
1758         }
1759         return result;
1760     }
1761 
1762     private static String protocol(String protocol) {
1763         if (&quot;http&quot;.equalsIgnoreCase(protocol)) return &quot;http&quot;;
1764         else if (&quot;https&quot;.equalsIgnoreCase(protocol)) return &quot;https&quot;;
1765         else throw new InternalError(&quot;Unsupported protocol: &quot; + protocol);
1766     }
1767 
1768     public static URL url(String protocol, InetSocketAddress address,
1769                           String path) throws MalformedURLException {
1770         return new URL(protocol(protocol),
1771                 address.getHostString(),
1772                 address.getPort(), path);
1773     }
1774 
1775     public static URI uri(String protocol, InetSocketAddress address,
1776                           String path) throws URISyntaxException {
1777         return new URI(protocol(protocol) + &quot;://&quot; +
1778                 address.getHostString() + &quot;:&quot; +
1779                 address.getPort() + path);
1780     }
1781 }
<a name="21" id="anc21"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="21" type="hidden" />
</body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New test/jdk/java/net/httpclient/http2/RedirectTest.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2015, 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 /*
 25  * @test
 26  * @bug 8156514
 27  * @library /test/lib server
 28  * @build jdk.test.lib.net.SimpleSSLContext
 29  * @modules java.base/sun.net.www.http
 30  *          java.net.http/jdk.internal.net.http.common
 31  *          java.net.http/jdk.internal.net.http.frame
 32  *          java.net.http/jdk.internal.net.http.hpack
 33  * @run testng/othervm
 34  *      -Djdk.httpclient.HttpClient.log=frames,ssl,requests,responses,errors
 35  *      -Djdk.internal.httpclient.debug=true
 36  *      RedirectTest
 37  */
 38 
 39 import java.net.InetSocketAddress;
 40 import java.net.URI;
 41 import java.net.http.HttpClient;
 42 import java.net.http.HttpRequest;
 43 import java.net.http.HttpRequest.BodyPublishers;
 44 import java.net.http.HttpResponse;
 45 import java.net.http.HttpResponse.BodyHandlers;
 46 import java.util.concurrent.*;
 47 import java.util.function.*;
 48 import java.util.Arrays;
 49 import java.util.Iterator;
 50 import org.testng.annotations.Test;
 51 import static java.net.http.HttpClient.Version.HTTP_2;
 52 
 53 public class RedirectTest {
 54     static int httpPort;
 55     static Http2TestServer httpServer;
 56     static HttpClient client;
 57 
 58     static String httpURIString, altURIString1, altURIString2;
 59     static URI httpURI, altURI1, altURI2;
 60 
 61     static Supplier&lt;String&gt; sup(String... args) {
 62         Iterator&lt;String&gt; i = Arrays.asList(args).iterator();
 63         // need to know when to stop calling it.
 64         return () -&gt; i.next();
 65     }
 66 
 67     static class Redirector extends Http2RedirectHandler {
 68         private InetSocketAddress remoteAddr;
 69         private boolean error = false;
 70 
 71         Redirector(Supplier&lt;String&gt; supplier) {
 72             super(supplier);
 73         }
 74 
 75         protected synchronized void examineExchange(Http2TestExchange ex) {
 76             InetSocketAddress addr = ex.getRemoteAddress();
 77             if (remoteAddr == null) {
 78                 remoteAddr = addr;
 79                 return;
 80             }
 81             // check that the client addr/port stays the same, proving
 82             // that the connection didn&#39;t get dropped.
 83             if (!remoteAddr.equals(addr)) {
 84                 System.err.printf(&quot;Error %s/%s\n&quot;, remoteAddr.toString(),
 85                         addr.toString());
 86                 error = true;
 87             }
 88         }
 89 
 90         @Override
 91         protected int redirectCode() {
 92             return 308; // we need to use a code that preserves the body
 93         }
 94 
 95         public synchronized boolean error() {
 96             return error;
 97         }
 98     }
 99 
100     static void initialize() throws Exception {
101         try {
102             client = getClient();
103             httpServer = new Http2TestServer(false, 0, null, null);
104             httpPort = httpServer.getAddress().getPort();
105 
106             // urls are accessed in sequence below. The first two are on
107             // different servers. Third on same server as second. So, the
108             // client should use the same http connection.
109             httpURIString = &quot;http://localhost:&quot; + httpPort + &quot;/foo/&quot;;
110             httpURI = URI.create(httpURIString);
111             altURIString1 = &quot;http://localhost:&quot; + httpPort + &quot;/redir&quot;;
112             altURI1 = URI.create(altURIString1);
113             altURIString2 = &quot;http://localhost:&quot; + httpPort + &quot;/redir_again&quot;;
114             altURI2 = URI.create(altURIString2);
115 
116             Redirector r = new Redirector(sup(altURIString1, altURIString2));
117             httpServer.addHandler(r, &quot;/foo&quot;);
118             httpServer.addHandler(r, &quot;/redir&quot;);
119             httpServer.addHandler(new Http2EchoHandler(), &quot;/redir_again&quot;);
120 
121             httpServer.start();
122         } catch (Throwable e) {
123             System.err.println(&quot;Throwing now&quot;);
124             e.printStackTrace();
125             throw e;
126         }
127     }
128 
129     @Test
130     public static void test() throws Exception {
131         try {
132             initialize();
133             simpleTest();
134         } finally {
135             httpServer.stop();
136         }
137     }
138 
139     static HttpClient getClient() {
140         if (client == null) {
141             client = HttpClient.newBuilder()
142                                .followRedirects(HttpClient.Redirect.ALWAYS)
143                                .version(HTTP_2)
144                                .build();
145         }
146         return client;
147     }
148 
149     static URI getURI() {
150         return URI.create(httpURIString);
151     }
152 
153     static void checkStatus(int expected, int found) throws Exception {
154         if (expected != found) {
155             System.err.printf (&quot;Test failed: wrong status code %d/%d\n&quot;,
156                 expected, found);
157             throw new RuntimeException(&quot;Test failed&quot;);
158         }
159     }
160 
161     static void checkURIs(URI expected, URI found) throws Exception {
162         System.out.printf (&quot;Expected: %s, Found: %s\n&quot;, expected.toString(), found.toString());
163         if (!expected.equals(found)) {
164             System.err.printf (&quot;Test failed: wrong URI %s/%s\n&quot;,
165                 expected.toString(), found.toString());
166             throw new RuntimeException(&quot;Test failed&quot;);
167         }
168     }
169 
170     static void checkStrings(String expected, String found) throws Exception {
171         if (!expected.equals(found)) {
172             System.err.printf (&quot;Test failed: wrong string %s/%s\n&quot;,
173                 expected, found);
174             throw new RuntimeException(&quot;Test failed&quot;);
175         }
176     }
177 
178     static void check(boolean cond, Object... msg) {
179         if (cond)
180             return;
181         StringBuilder sb = new StringBuilder();
182         for (Object o : msg)
183             sb.append(o);
184         throw new RuntimeException(sb.toString());
185     }
186 
187     static final String SIMPLE_STRING = &quot;Hello world Goodbye world&quot;;
188 
189     static void simpleTest() throws Exception {
190         URI uri = getURI();
191         System.err.println(&quot;Request to &quot; + uri);
192 
193         HttpClient client = getClient();
194         HttpRequest req = HttpRequest.newBuilder(uri)
195                                      .POST(BodyPublishers.ofString(SIMPLE_STRING))
196                                      .build();
197         CompletableFuture&lt;HttpResponse&lt;String&gt;&gt; cf = client.sendAsync(req, BodyHandlers.ofString());
198         HttpResponse&lt;String&gt; response = cf.join();
199 
200         checkStatus(200, response.statusCode());
201         String responseBody = response.body();
202         checkStrings(SIMPLE_STRING, responseBody);
203         checkURIs(response.uri(), altURI2);
204 
205         // check two previous responses
206         HttpResponse&lt;String&gt; prev = response.previousResponse()
207             .orElseThrow(() -&gt; new RuntimeException(&quot;no previous response&quot;));
208         checkURIs(prev.uri(), altURI1);
209 
210         prev = prev.previousResponse()
211             .orElseThrow(() -&gt; new RuntimeException(&quot;no previous response&quot;));
212         checkURIs(prev.uri(), httpURI);
213 
214         checkPreviousRedirectResponses(req, response);
215 
216         System.err.println(&quot;DONE&quot;);
217     }
218 
219     static void checkPreviousRedirectResponses(HttpRequest initialRequest,
220                                                HttpResponse&lt;?&gt; finalResponse) {
221         // there must be at least one previous response
222         finalResponse.previousResponse()
223                 .orElseThrow(() -&gt; new RuntimeException(&quot;no previous response&quot;));
224 
225         HttpResponse&lt;?&gt; response = finalResponse;
226         do {
227             URI uri = response.uri();
228             response = response.previousResponse().get();
229             check(300 &lt;= response.statusCode() &amp;&amp; response.statusCode() &lt;= 309,
230                     &quot;Expected 300 &lt;= code &lt;= 309, got:&quot; + response.statusCode());
231             check(response.body() == null, &quot;Unexpected body: &quot; + response.body());
232             String locationHeader = response.headers().firstValue(&quot;Location&quot;)
233                     .orElseThrow(() -&gt; new RuntimeException(&quot;no previous Location&quot;));
234             check(uri.toString().endsWith(locationHeader),
235                     &quot;URI: &quot; + uri + &quot;, Location: &quot; + locationHeader);
236         } while (response.previousResponse().isPresent());
237 
238         // initial
239         check(initialRequest.equals(response.request()),
240                 &quot;Expected initial request [%s] to equal last prev req [%s]&quot;,
241                 initialRequest, response.request());
242     }
243 }
    </pre>
  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff test/jdk/java/net/httpclient/whitebox/java.net.http/jdk/internal/net/http/ConnectionPoolTest.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="../../../../../ConnectionPoolTestDriver.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../index.html" target="_top">index</a> <a href="Http1HeaderParserTest.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>test/jdk/java/net/httpclient/whitebox/java.net.http/jdk/internal/net/http/ConnectionPoolTest.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2017, 2018, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 package jdk.internal.net.http;
 25 
 26 import java.io.IOException;
 27 import java.lang.management.ManagementFactory;

 28 import java.net.Authenticator;
 29 import java.net.CookieHandler;
 30 import java.net.InetSocketAddress;
 31 import java.net.ProxySelector;




 32 import java.nio.ByteBuffer;
 33 import java.nio.channels.SocketChannel;

 34 import java.time.Duration;
<span class="line-modified"> 35 import java.util.Arrays;</span>
 36 import java.util.List;

 37 import java.util.Optional;
 38 import java.util.Random;

 39 import java.util.concurrent.CompletableFuture;
 40 import java.util.concurrent.Executor;
 41 import java.util.concurrent.Flow;
 42 import java.util.stream.IntStream;
 43 import java.time.Instant;
 44 import java.time.temporal.ChronoUnit;
 45 import javax.net.ssl.SSLContext;
 46 import javax.net.ssl.SSLParameters;
 47 import java.net.http.HttpClient;
 48 import java.net.http.HttpRequest;
 49 import java.net.http.HttpResponse;
 50 import jdk.internal.net.http.common.FlowTube;
 51 
 52 /**
 53  * @summary Verifies that the ConnectionPool correctly handle
 54  *          connection deadlines and purges the right connections
 55  *          from the cache.
<span class="line-modified"> 56  * @bug 8187044 8187111</span>
 57  * @author danielfuchs
 58  */
 59 public class ConnectionPoolTest {
 60 
 61     static long getActiveCleaners() throws ClassNotFoundException {
 62         // ConnectionPool.ACTIVE_CLEANER_COUNTER.get()
 63         // ConnectionPoolTest.class.getModule().addReads(
 64         //      Class.forName(&quot;java.lang.management.ManagementFactory&quot;).getModule());
 65         return java.util.stream.Stream.of(ManagementFactory.getThreadMXBean()
 66                 .dumpAllThreads(false, false))
 67               .filter(t -&gt; t.getThreadName().startsWith(&quot;HTTP-Cache-cleaner&quot;))
 68               .count();
 69     }
 70 
 71     public static void main(String[] args) throws Exception {
 72         if (args.length == 0) {
 73             args = new String[] {&quot;testCacheCleaners&quot;};
 74         }
 75         for (String arg : args) {
 76             if (&quot;testCacheCleaners&quot;.equals(arg)) {
 77                 testCacheCleaners();
 78             } else if (&quot;testPoolSize&quot;.equals(arg)) {
 79                 assert args.length == 1 : &quot;testPoolSize should be run in its own VM&quot;;
 80                 testPoolSize();
<span class="line-modified"> 81             }</span>



 82         }
 83     }
 84 
 85     public static void testCacheCleaners() throws Exception {
 86         ConnectionPool pool = new ConnectionPool(666);
 87         HttpClient client = new HttpClientStub(pool);
 88         InetSocketAddress proxy = InetSocketAddress.createUnresolved(&quot;bar&quot;, 80);
 89         System.out.println(&quot;Adding 20 connections to pool&quot;);
 90         Random random = new Random();
 91 
 92         final int count = 20;
 93         Instant now = Instant.now().truncatedTo(ChronoUnit.SECONDS);
 94         int[] keepAlives = new int[count];
 95         HttpConnectionStub[] connections = new HttpConnectionStub[count];
 96         long purge = pool.purgeExpiredConnectionsAndReturnNextDeadline(now);
 97         long expected = 0;
 98         if (purge != expected) {
 99             throw new RuntimeException(&quot;Bad purge delay: &quot; + purge
100                                         + &quot;, expected &quot; + expected);
101         }
</pre>
<hr />
<pre>
209                 .filter(HttpConnectionStub::connected).count();
210         if (opened != MAX_POOL_SIZE) {
211             throw new RuntimeException(&quot;Opened: expected &quot;
212                     + count + &quot; got &quot; + opened);
213         }
214         for (int i=0 ; i&lt;count; i++) {
215             boolean closed = (i &lt; count - MAX_POOL_SIZE);
216             if (connections[i].closed != closed) {
217                 throw new RuntimeException(&quot;connection[&quot; + i + &quot;] should be &quot;
218                         + (closed ? &quot;closed&quot; : &quot;opened&quot;));
219             }
220             if (pool.contains(connections[i]) == closed) {
221                 throw new RuntimeException(&quot;Connection[&quot; + i + &quot;]/&quot;
222                         + connections[i] + &quot; should &quot;
223                         + (closed ? &quot;&quot; : &quot;not &quot;)
224                         + &quot;have been removed&quot;);
225             }
226         }
227     }
228 











































































































229     static &lt;T&gt; T error() {
230         throw new InternalError(&quot;Should not reach here: wrong test assumptions!&quot;);
231     }
232 
233     static class FlowTubeStub implements FlowTube {
234         final HttpConnectionStub conn;
235         FlowTubeStub(HttpConnectionStub conn) { this.conn = conn; }
236         @Override
237         public void onSubscribe(Flow.Subscription subscription) { }
238         @Override public void onError(Throwable error) { error(); }
239         @Override public void onComplete() { error(); }
240         @Override public void onNext(List&lt;ByteBuffer&gt; item) { error();}
241         @Override
242         public void subscribe(Flow.Subscriber&lt;? super List&lt;ByteBuffer&gt;&gt; subscriber) {
243         }
<span class="line-modified">244         @Override public boolean isFinished() { return conn.closed; }</span>












































































245     }
246 
247     // Emulates an HttpConnection that has a strong reference to its HttpClient.
248     static class HttpConnectionStub extends HttpConnection {
249 
<span class="line-modified">250         public HttpConnectionStub(HttpClient client,</span>









251                 InetSocketAddress address,
252                 InetSocketAddress proxy,
253                 boolean secured) {
<span class="line-modified">254             super(address, null);</span>
255             this.key = ConnectionPool.cacheKey(address, proxy);
256             this.address = address;
257             this.proxy = proxy;
258             this.secured = secured;
259             this.client = client;

260             this.flow = new FlowTubeStub(this);
261         }
262 
263         final InetSocketAddress proxy;
264         final InetSocketAddress address;
265         final boolean secured;
266         final ConnectionPool.CacheKey key;
267         final HttpClient client;
268         final FlowTubeStub flow;
<span class="line-modified">269         volatile boolean closed;</span>





270 
271         // All these return something
272         @Override boolean connected() {return !closed;}
273         @Override boolean isSecure() {return secured;}
274         @Override boolean isProxied() {return proxy!=null;}
275         @Override ConnectionPool.CacheKey cacheKey() {return key;}


276         @Override
277         public void close() {
<span class="line-modified">278             closed=true;</span>
279             System.out.println(&quot;closed: &quot; + this);
280         }
281         @Override
282         public String toString() {
283             return &quot;HttpConnectionStub: &quot; + address + &quot; proxy: &quot; + proxy;
284         }
285 

286         // All these throw errors
287         @Override public HttpPublisher publisher() {return error();}
288         @Override public CompletableFuture&lt;Void&gt; connectAsync(Exchange&lt;?&gt; e) {return error();}
289         @Override public CompletableFuture&lt;Void&gt; finishConnect() {return error();}
<span class="line-removed">290         @Override SocketChannel channel() {return error();}</span>
<span class="line-removed">291         @Override</span>
<span class="line-removed">292         FlowTube getConnectionFlow() {return flow;}</span>
293     }
294     // Emulates an HttpClient that has a strong reference to its connection pool.
295     static class HttpClientStub extends HttpClient {
296         public HttpClientStub(ConnectionPool pool) {
297             this.pool = pool;
298         }
299         final ConnectionPool pool;
300         @Override public Optional&lt;CookieHandler&gt; cookieHandler() {return error();}
301         @Override public Optional&lt;Duration&gt; connectTimeout() {return error();}
302         @Override public HttpClient.Redirect followRedirects() {return error();}
303         @Override public Optional&lt;ProxySelector&gt; proxy() {return error();}
304         @Override public SSLContext sslContext() {return error();}
305         @Override public SSLParameters sslParameters() {return error();}
306         @Override public Optional&lt;Authenticator&gt; authenticator() {return error();}
307         @Override public HttpClient.Version version() {return HttpClient.Version.HTTP_1_1;}
308         @Override public Optional&lt;Executor&gt; executor() {return error();}
309         @Override
310         public &lt;T&gt; HttpResponse&lt;T&gt; send(HttpRequest req,
311                                         HttpResponse.BodyHandler&lt;T&gt; responseBodyHandler)
312                 throws IOException, InterruptedException {
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2017, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 package jdk.internal.net.http;
 25 
 26 import java.io.IOException;
 27 import java.lang.management.ManagementFactory;
<span class="line-added"> 28 import java.lang.ref.Reference;</span>
 29 import java.net.Authenticator;
 30 import java.net.CookieHandler;
 31 import java.net.InetSocketAddress;
 32 import java.net.ProxySelector;
<span class="line-added"> 33 import java.net.Socket;</span>
<span class="line-added"> 34 import java.net.SocketAddress;</span>
<span class="line-added"> 35 import java.net.SocketOption;</span>
<span class="line-added"> 36 import java.net.http.HttpHeaders;</span>
 37 import java.nio.ByteBuffer;
 38 import java.nio.channels.SocketChannel;
<span class="line-added"> 39 import java.nio.channels.spi.SelectorProvider;</span>
 40 import java.time.Duration;
<span class="line-modified"> 41 import java.util.HashMap;</span>
 42 import java.util.List;
<span class="line-added"> 43 import java.util.Map;</span>
 44 import java.util.Optional;
 45 import java.util.Random;
<span class="line-added"> 46 import java.util.Set;</span>
 47 import java.util.concurrent.CompletableFuture;
 48 import java.util.concurrent.Executor;
 49 import java.util.concurrent.Flow;
 50 import java.util.stream.IntStream;
 51 import java.time.Instant;
 52 import java.time.temporal.ChronoUnit;
 53 import javax.net.ssl.SSLContext;
 54 import javax.net.ssl.SSLParameters;
 55 import java.net.http.HttpClient;
 56 import java.net.http.HttpRequest;
 57 import java.net.http.HttpResponse;
 58 import jdk.internal.net.http.common.FlowTube;
 59 
 60 /**
 61  * @summary Verifies that the ConnectionPool correctly handle
 62  *          connection deadlines and purges the right connections
 63  *          from the cache.
<span class="line-modified"> 64  * @bug 8187044 8187111 8221395</span>
 65  * @author danielfuchs
 66  */
 67 public class ConnectionPoolTest {
 68 
 69     static long getActiveCleaners() throws ClassNotFoundException {
 70         // ConnectionPool.ACTIVE_CLEANER_COUNTER.get()
 71         // ConnectionPoolTest.class.getModule().addReads(
 72         //      Class.forName(&quot;java.lang.management.ManagementFactory&quot;).getModule());
 73         return java.util.stream.Stream.of(ManagementFactory.getThreadMXBean()
 74                 .dumpAllThreads(false, false))
 75               .filter(t -&gt; t.getThreadName().startsWith(&quot;HTTP-Cache-cleaner&quot;))
 76               .count();
 77     }
 78 
 79     public static void main(String[] args) throws Exception {
 80         if (args.length == 0) {
 81             args = new String[] {&quot;testCacheCleaners&quot;};
 82         }
 83         for (String arg : args) {
 84             if (&quot;testCacheCleaners&quot;.equals(arg)) {
 85                 testCacheCleaners();
 86             } else if (&quot;testPoolSize&quot;.equals(arg)) {
 87                 assert args.length == 1 : &quot;testPoolSize should be run in its own VM&quot;;
 88                 testPoolSize();
<span class="line-modified"> 89             } else if (&quot;testCloseOrReturnToPool&quot;.equals(arg)) {</span>
<span class="line-added"> 90                 assert args.length == 1 : &quot;testCloseOrReturnToPool should be run in its own VM&quot;;</span>
<span class="line-added"> 91                 testCloseOrReturnToPool();</span>
<span class="line-added"> 92             } else throw new RuntimeException(&quot;unknown test case: &quot; + arg);</span>
 93         }
 94     }
 95 
 96     public static void testCacheCleaners() throws Exception {
 97         ConnectionPool pool = new ConnectionPool(666);
 98         HttpClient client = new HttpClientStub(pool);
 99         InetSocketAddress proxy = InetSocketAddress.createUnresolved(&quot;bar&quot;, 80);
100         System.out.println(&quot;Adding 20 connections to pool&quot;);
101         Random random = new Random();
102 
103         final int count = 20;
104         Instant now = Instant.now().truncatedTo(ChronoUnit.SECONDS);
105         int[] keepAlives = new int[count];
106         HttpConnectionStub[] connections = new HttpConnectionStub[count];
107         long purge = pool.purgeExpiredConnectionsAndReturnNextDeadline(now);
108         long expected = 0;
109         if (purge != expected) {
110             throw new RuntimeException(&quot;Bad purge delay: &quot; + purge
111                                         + &quot;, expected &quot; + expected);
112         }
</pre>
<hr />
<pre>
220                 .filter(HttpConnectionStub::connected).count();
221         if (opened != MAX_POOL_SIZE) {
222             throw new RuntimeException(&quot;Opened: expected &quot;
223                     + count + &quot; got &quot; + opened);
224         }
225         for (int i=0 ; i&lt;count; i++) {
226             boolean closed = (i &lt; count - MAX_POOL_SIZE);
227             if (connections[i].closed != closed) {
228                 throw new RuntimeException(&quot;connection[&quot; + i + &quot;] should be &quot;
229                         + (closed ? &quot;closed&quot; : &quot;opened&quot;));
230             }
231             if (pool.contains(connections[i]) == closed) {
232                 throw new RuntimeException(&quot;Connection[&quot; + i + &quot;]/&quot;
233                         + connections[i] + &quot; should &quot;
234                         + (closed ? &quot;&quot; : &quot;not &quot;)
235                         + &quot;have been removed&quot;);
236             }
237         }
238     }
239 
<span class="line-added">240     public static void testCloseOrReturnToPool() throws Exception {</span>
<span class="line-added">241         HttpClientFacade facade = (HttpClientFacade)HttpClient.newHttpClient();</span>
<span class="line-added">242         HttpClientImpl client = facade.impl;</span>
<span class="line-added">243         ConnectionPool pool = client.connectionPool();</span>
<span class="line-added">244         InetSocketAddress proxy = InetSocketAddress.createUnresolved(&quot;bar&quot;, 80);</span>
<span class="line-added">245 </span>
<span class="line-added">246         InetSocketAddress addr = InetSocketAddress.createUnresolved(&quot;foo1&quot;, 80);</span>
<span class="line-added">247         HttpConnectionStub conn1 = new HttpConnectionStub(facade, client, addr, proxy, true);</span>
<span class="line-added">248         HttpHeaders hdrs = HttpHeaders.of(new HashMap&lt;&gt;(), (s1,s2) -&gt; true);</span>
<span class="line-added">249         HttpConnection conn;</span>
<span class="line-added">250 </span>
<span class="line-added">251         conn1.reopen();</span>
<span class="line-added">252         if (!conn1.isOpen()) {</span>
<span class="line-added">253             throw new RuntimeException(&quot;conn1 finished&quot;);</span>
<span class="line-added">254         }</span>
<span class="line-added">255 </span>
<span class="line-added">256         conn1.closeOrReturnToCache(hdrs);</span>
<span class="line-added">257 </span>
<span class="line-added">258         // Check we can find conn1 in the pool</span>
<span class="line-added">259         if (conn1 != (conn = pool.getConnection(true, addr, proxy))) {</span>
<span class="line-added">260             throw new RuntimeException(&quot;conn1 not returned, got: &quot; + conn);</span>
<span class="line-added">261         }</span>
<span class="line-added">262         System.out.println(&quot;Found connection in the pool: &quot; + conn );</span>
<span class="line-added">263 </span>
<span class="line-added">264         // Try to return it with no headers: the connection should</span>
<span class="line-added">265         // be closed and not returned to the pool (EOF).</span>
<span class="line-added">266         conn.closeOrReturnToCache(null);</span>
<span class="line-added">267         if ((conn = pool.getConnection(true, addr, proxy)) != null) {</span>
<span class="line-added">268             throw new RuntimeException(conn + &quot; found in the pool!&quot;);</span>
<span class="line-added">269         }</span>
<span class="line-added">270         if (!conn1.closed) {</span>
<span class="line-added">271             throw new RuntimeException(&quot;conn1 not closed!&quot;);</span>
<span class="line-added">272         }</span>
<span class="line-added">273         System.out.println(&quot;EOF connection successfully closed when returned to pool&quot;);</span>
<span class="line-added">274 </span>
<span class="line-added">275         // reopen the connection</span>
<span class="line-added">276         conn1.reopen();</span>
<span class="line-added">277         if (!conn1.isOpen()) {</span>
<span class="line-added">278             throw new RuntimeException(&quot;conn1 finished&quot;);</span>
<span class="line-added">279         }</span>
<span class="line-added">280 </span>
<span class="line-added">281         // Try to return it with empty headers: the connection should</span>
<span class="line-added">282         // be returned to the pool.</span>
<span class="line-added">283         conn1.closeOrReturnToCache(hdrs);</span>
<span class="line-added">284         if (conn1 != (conn = pool.getConnection(true, addr, proxy))) {</span>
<span class="line-added">285             throw new RuntimeException(&quot;conn1 not returned to pool, got: &quot; + conn);</span>
<span class="line-added">286         }</span>
<span class="line-added">287         if (conn1.closed) {</span>
<span class="line-added">288             throw new RuntimeException(&quot;conn1 closed&quot;);</span>
<span class="line-added">289         }</span>
<span class="line-added">290         if (!conn1.isOpen()) {</span>
<span class="line-added">291             throw new RuntimeException(&quot;conn1 finished&quot;);</span>
<span class="line-added">292         }</span>
<span class="line-added">293 </span>
<span class="line-added">294         System.out.println(&quot;Keep alive connection successfully returned to pool&quot;);</span>
<span class="line-added">295 </span>
<span class="line-added">296         // Try to return it with connection: close headers: the connection should</span>
<span class="line-added">297         // not be returned to the pool, and should be closed.</span>
<span class="line-added">298         HttpHeaders hdrs2 = HttpHeaders.of(Map.of(&quot;connection&quot;, List.of(&quot;close&quot;)), (s1, s2) -&gt; true);</span>
<span class="line-added">299         conn1.closeOrReturnToCache(hdrs2);</span>
<span class="line-added">300         if ((conn = pool.getConnection(true, addr, proxy)) != null) {</span>
<span class="line-added">301             throw new RuntimeException(conn + &quot; found in the pool!&quot;);</span>
<span class="line-added">302         }</span>
<span class="line-added">303         if (!conn1.closed) {</span>
<span class="line-added">304             throw new RuntimeException(&quot;conn1 not closed!&quot;);</span>
<span class="line-added">305         }</span>
<span class="line-added">306         System.out.println(&quot;Close connection successfully closed when returned to pool&quot;);</span>
<span class="line-added">307 </span>
<span class="line-added">308         // reopen and finish the connection.</span>
<span class="line-added">309         conn1.reopen();</span>
<span class="line-added">310         conn1.finish(true);</span>
<span class="line-added">311         if (conn1.closed) {</span>
<span class="line-added">312             throw new RuntimeException(&quot;conn1 closed&quot;);</span>
<span class="line-added">313         }</span>
<span class="line-added">314         if (conn1.isOpen()) {</span>
<span class="line-added">315             throw new RuntimeException(&quot;conn1 is opened!&quot;);</span>
<span class="line-added">316         }</span>
<span class="line-added">317         conn1.closeOrReturnToCache(hdrs2);</span>
<span class="line-added">318         if ((conn = pool.getConnection(true, addr, proxy)) != null) {</span>
<span class="line-added">319             throw new RuntimeException(conn + &quot; found in the pool!&quot;);</span>
<span class="line-added">320         }</span>
<span class="line-added">321         if (!conn1.closed) {</span>
<span class="line-added">322             throw new RuntimeException(&quot;conn1 not closed!&quot;);</span>
<span class="line-added">323         }</span>
<span class="line-added">324         System.out.println(&quot;Finished &#39;close&#39; connection successfully closed when returned to pool&quot;);</span>
<span class="line-added">325 </span>
<span class="line-added">326         // reopen and finish the connection.</span>
<span class="line-added">327         conn1.reopen();</span>
<span class="line-added">328         conn1.finish(true);</span>
<span class="line-added">329         if (conn1.closed) {</span>
<span class="line-added">330             throw new RuntimeException(&quot;conn1 closed&quot;);</span>
<span class="line-added">331         }</span>
<span class="line-added">332         if (conn1.isOpen()) {</span>
<span class="line-added">333             throw new RuntimeException(&quot;conn1 is opened!&quot;);</span>
<span class="line-added">334         }</span>
<span class="line-added">335         conn1.closeOrReturnToCache(hdrs);</span>
<span class="line-added">336         if ((conn = pool.getConnection(true, addr, proxy)) != null) {</span>
<span class="line-added">337             throw new RuntimeException(conn + &quot; found in the pool!&quot;);</span>
<span class="line-added">338         }</span>
<span class="line-added">339         if (!conn1.closed) {</span>
<span class="line-added">340             throw new RuntimeException(&quot;conn1 not closed!&quot;);</span>
<span class="line-added">341         }</span>
<span class="line-added">342         System.out.println(&quot;Finished keep-alive connection successfully closed when returned to pool&quot;);</span>
<span class="line-added">343 </span>
<span class="line-added">344         Reference.reachabilityFence(facade);</span>
<span class="line-added">345     }</span>
<span class="line-added">346 </span>
347     static &lt;T&gt; T error() {
348         throw new InternalError(&quot;Should not reach here: wrong test assumptions!&quot;);
349     }
350 
351     static class FlowTubeStub implements FlowTube {
352         final HttpConnectionStub conn;
353         FlowTubeStub(HttpConnectionStub conn) { this.conn = conn; }
354         @Override
355         public void onSubscribe(Flow.Subscription subscription) { }
356         @Override public void onError(Throwable error) { error(); }
357         @Override public void onComplete() { error(); }
358         @Override public void onNext(List&lt;ByteBuffer&gt; item) { error();}
359         @Override
360         public void subscribe(Flow.Subscriber&lt;? super List&lt;ByteBuffer&gt;&gt; subscriber) {
361         }
<span class="line-modified">362         @Override public boolean isFinished() { return conn.finished; }</span>
<span class="line-added">363     }</span>
<span class="line-added">364 </span>
<span class="line-added">365     static class SocketChannelStub extends SocketChannel {</span>
<span class="line-added">366 </span>
<span class="line-added">367         SocketChannelStub() { super(SelectorProvider.provider()); }</span>
<span class="line-added">368 </span>
<span class="line-added">369         @Override</span>
<span class="line-added">370         public SocketChannel bind(SocketAddress local) throws IOException {</span>
<span class="line-added">371             return error();</span>
<span class="line-added">372         }</span>
<span class="line-added">373         @Override</span>
<span class="line-added">374         public &lt;T&gt; SocketChannel setOption(SocketOption&lt;T&gt; name, T value) throws IOException {</span>
<span class="line-added">375             return error();</span>
<span class="line-added">376         }</span>
<span class="line-added">377         @Override</span>
<span class="line-added">378         public SocketChannel shutdownInput() throws IOException {</span>
<span class="line-added">379             return error();</span>
<span class="line-added">380         }</span>
<span class="line-added">381         @Override</span>
<span class="line-added">382         public SocketChannel shutdownOutput() throws IOException {</span>
<span class="line-added">383             return error();</span>
<span class="line-added">384         }</span>
<span class="line-added">385         @Override</span>
<span class="line-added">386         public Socket socket() { return error(); }</span>
<span class="line-added">387         @Override</span>
<span class="line-added">388         public boolean isConnected() { return true; }</span>
<span class="line-added">389         @Override</span>
<span class="line-added">390         public boolean isConnectionPending() { return false; }</span>
<span class="line-added">391         @Override</span>
<span class="line-added">392         public boolean connect(SocketAddress remote) throws IOException {</span>
<span class="line-added">393             return error();</span>
<span class="line-added">394         }</span>
<span class="line-added">395         @Override</span>
<span class="line-added">396         public boolean finishConnect() throws IOException {</span>
<span class="line-added">397             return error();</span>
<span class="line-added">398         }</span>
<span class="line-added">399         @Override</span>
<span class="line-added">400         public SocketAddress getRemoteAddress() throws IOException {</span>
<span class="line-added">401             return error();</span>
<span class="line-added">402         }</span>
<span class="line-added">403         @Override</span>
<span class="line-added">404         public int read(ByteBuffer dst) throws IOException {</span>
<span class="line-added">405             return error();</span>
<span class="line-added">406         }</span>
<span class="line-added">407         @Override</span>
<span class="line-added">408         public long read(ByteBuffer[] dsts, int offset, int length) throws IOException {</span>
<span class="line-added">409             return error();</span>
<span class="line-added">410         }</span>
<span class="line-added">411         @Override</span>
<span class="line-added">412         public int write(ByteBuffer src) throws IOException {</span>
<span class="line-added">413             return error();</span>
<span class="line-added">414         }</span>
<span class="line-added">415         @Override</span>
<span class="line-added">416         public long write(ByteBuffer[] srcs, int offset, int length) throws IOException {</span>
<span class="line-added">417             return 0;</span>
<span class="line-added">418         }</span>
<span class="line-added">419         @Override</span>
<span class="line-added">420         public SocketAddress getLocalAddress() throws IOException {</span>
<span class="line-added">421             return error();</span>
<span class="line-added">422         }</span>
<span class="line-added">423         @Override</span>
<span class="line-added">424         public &lt;T&gt; T getOption(SocketOption&lt;T&gt; name) throws IOException {</span>
<span class="line-added">425             return error();</span>
<span class="line-added">426         }</span>
<span class="line-added">427         @Override</span>
<span class="line-added">428         public Set&lt;SocketOption&lt;?&gt;&gt; supportedOptions() {</span>
<span class="line-added">429             return error();</span>
<span class="line-added">430         }</span>
<span class="line-added">431         @Override</span>
<span class="line-added">432         protected void implCloseSelectableChannel() throws IOException {</span>
<span class="line-added">433             error();</span>
<span class="line-added">434         }</span>
<span class="line-added">435         @Override</span>
<span class="line-added">436         protected void implConfigureBlocking(boolean block) throws IOException {</span>
<span class="line-added">437             error();</span>
<span class="line-added">438         }</span>
439     }
440 
441     // Emulates an HttpConnection that has a strong reference to its HttpClient.
442     static class HttpConnectionStub extends HttpConnection {
443 
<span class="line-modified">444         public HttpConnectionStub(</span>
<span class="line-added">445                 HttpClient client,</span>
<span class="line-added">446                 InetSocketAddress address,</span>
<span class="line-added">447                 InetSocketAddress proxy,</span>
<span class="line-added">448                 boolean secured) {</span>
<span class="line-added">449             this(client, null, address, proxy, secured);</span>
<span class="line-added">450         }</span>
<span class="line-added">451         public HttpConnectionStub(</span>
<span class="line-added">452                 HttpClient client,</span>
<span class="line-added">453                 HttpClientImpl impl,</span>
454                 InetSocketAddress address,
455                 InetSocketAddress proxy,
456                 boolean secured) {
<span class="line-modified">457             super(address, impl);</span>
458             this.key = ConnectionPool.cacheKey(address, proxy);
459             this.address = address;
460             this.proxy = proxy;
461             this.secured = secured;
462             this.client = client;
<span class="line-added">463             this.channel = new SocketChannelStub();</span>
464             this.flow = new FlowTubeStub(this);
465         }
466 
467         final InetSocketAddress proxy;
468         final InetSocketAddress address;
469         final boolean secured;
470         final ConnectionPool.CacheKey key;
471         final HttpClient client;
472         final FlowTubeStub flow;
<span class="line-modified">473         final SocketChannel channel;</span>
<span class="line-added">474         volatile boolean closed, finished;</span>
<span class="line-added">475 </span>
<span class="line-added">476         // Used for testing closeOrReturnToPool.</span>
<span class="line-added">477         void finish(boolean finished) { this.finished = finished; }</span>
<span class="line-added">478         void reopen() { closed = finished = false;}</span>
479 
480         // All these return something
481         @Override boolean connected() {return !closed;}
482         @Override boolean isSecure() {return secured;}
483         @Override boolean isProxied() {return proxy!=null;}
484         @Override ConnectionPool.CacheKey cacheKey() {return key;}
<span class="line-added">485         @Override FlowTube getConnectionFlow() {return flow;}</span>
<span class="line-added">486         @Override SocketChannel channel() {return channel;}</span>
487         @Override
488         public void close() {
<span class="line-modified">489             closed=finished=true;</span>
490             System.out.println(&quot;closed: &quot; + this);
491         }
492         @Override
493         public String toString() {
494             return &quot;HttpConnectionStub: &quot; + address + &quot; proxy: &quot; + proxy;
495         }
496 
<span class="line-added">497 </span>
498         // All these throw errors
499         @Override public HttpPublisher publisher() {return error();}
500         @Override public CompletableFuture&lt;Void&gt; connectAsync(Exchange&lt;?&gt; e) {return error();}
501         @Override public CompletableFuture&lt;Void&gt; finishConnect() {return error();}



502     }
503     // Emulates an HttpClient that has a strong reference to its connection pool.
504     static class HttpClientStub extends HttpClient {
505         public HttpClientStub(ConnectionPool pool) {
506             this.pool = pool;
507         }
508         final ConnectionPool pool;
509         @Override public Optional&lt;CookieHandler&gt; cookieHandler() {return error();}
510         @Override public Optional&lt;Duration&gt; connectTimeout() {return error();}
511         @Override public HttpClient.Redirect followRedirects() {return error();}
512         @Override public Optional&lt;ProxySelector&gt; proxy() {return error();}
513         @Override public SSLContext sslContext() {return error();}
514         @Override public SSLParameters sslParameters() {return error();}
515         @Override public Optional&lt;Authenticator&gt; authenticator() {return error();}
516         @Override public HttpClient.Version version() {return HttpClient.Version.HTTP_1_1;}
517         @Override public Optional&lt;Executor&gt; executor() {return error();}
518         @Override
519         public &lt;T&gt; HttpResponse&lt;T&gt; send(HttpRequest req,
520                                         HttpResponse.BodyHandler&lt;T&gt; responseBodyHandler)
521                 throws IOException, InterruptedException {
</pre>
</td>
</tr>
</table>
<center><a href="../../../../../ConnectionPoolTestDriver.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../index.html" target="_top">index</a> <a href="Http1HeaderParserTest.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
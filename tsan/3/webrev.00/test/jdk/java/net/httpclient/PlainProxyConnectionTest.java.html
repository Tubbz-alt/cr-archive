<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New test/jdk/java/net/httpclient/PlainProxyConnectionTest.java</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 import com.sun.net.httpserver.HttpContext;
 25 import com.sun.net.httpserver.HttpExchange;
 26 import com.sun.net.httpserver.HttpHandler;
 27 import com.sun.net.httpserver.HttpServer;
 28 import java.io.IOException;
 29 import java.io.InputStream;
 30 import java.net.HttpURLConnection;
 31 import java.net.InetAddress;
 32 import java.net.InetSocketAddress;
 33 import java.net.Proxy;
 34 import java.net.ProxySelector;
 35 import java.net.SocketAddress;
 36 import java.net.URI;
 37 import java.net.URISyntaxException;
 38 import java.nio.charset.StandardCharsets;
 39 import java.security.NoSuchAlgorithmException;
 40 import java.util.List;
 41 import java.util.Set;
 42 import java.util.concurrent.ConcurrentLinkedQueue;
 43 import java.net.http.HttpClient;
 44 import java.net.http.HttpRequest;
 45 import java.net.http.HttpResponse;
 46 import java.util.stream.Collectors;
 47 import static java.net.Proxy.NO_PROXY;
 48 
 49 /**
 50  * @test
 51  * @bug 8230526
 52  * @summary Verifies that PlainProxyConnections are cached and reused properly. We do this by
 53  *          verifying that the remote address of the HTTP exchange (on the fake proxy server)
 54  *          is always the same InetSocketAddress.
 55  * @modules jdk.httpserver
 56  * @run main/othervm PlainProxyConnectionTest
 57  * @author danielfuchs
 58  */
 59 public class PlainProxyConnectionTest {
 60 
 61     static final String RESPONSE = &quot;&lt;html&gt;&lt;body&gt;&lt;p&gt;Hello World!&lt;/body&gt;&lt;/html&gt;&quot;;
 62     static final String PATH = &quot;/foo/&quot;;
 63     static final ConcurrentLinkedQueue&lt;InetSocketAddress&gt; connections = new ConcurrentLinkedQueue&lt;&gt;();
 64 
 65     // For convenience the server is used both as a plain server and as a plain proxy.
 66     // When used as a proxy, it serves the request itself instead of forwarding it
 67     // to the requested server.
 68     static HttpServer createHttpsServer() throws IOException, NoSuchAlgorithmException {
 69         HttpServer server = com.sun.net.httpserver.HttpServer.create();
 70         HttpContext context = server.createContext(PATH);
 71         context.setHandler(new HttpHandler() {
 72             @Override
 73             public void handle(HttpExchange he) throws IOException {
 74                 connections.add(he.getRemoteAddress());
 75                 he.getResponseHeaders().add(&quot;encoding&quot;, &quot;UTF-8&quot;);
 76                 byte[] bytes = RESPONSE.getBytes(StandardCharsets.UTF_8);
 77                 he.sendResponseHeaders(200, bytes.length &gt; 0 ? bytes.length : -1);
 78                 he.getResponseBody().write(bytes);
 79                 he.close();
 80             }
 81         });
 82 
 83         InetSocketAddress addr = new InetSocketAddress(InetAddress.getLoopbackAddress(), 0);
 84         server.bind(addr, 0);
 85         return server;
 86     }
 87 
 88     public static void main(String[] args)
 89             throws IOException,
 90             URISyntaxException,
 91             NoSuchAlgorithmException,
 92             InterruptedException
 93     {
 94         HttpServer server = createHttpsServer();
 95         server.start();
 96         try {
 97             test(server, HttpClient.Version.HTTP_1_1);
 98             test(server, HttpClient.Version.HTTP_2);
 99         } finally {
100             server.stop(0);
101             System.out.println(&quot;Server stopped&quot;);
102         }
103     }
104 
105     /**
106      * A Proxy Selector that wraps a ProxySelector.of(), and counts the number
107      * of times its select method has been invoked. This can be used to ensure
108      * that the Proxy Selector is invoked only once per HttpClient.sendXXX
109      * invocation.
110      */
111     static class CountingProxySelector extends ProxySelector {
112         private final ProxySelector proxySelector;
113         private volatile int count; // 0
114         private CountingProxySelector(InetSocketAddress proxyAddress) {
115             proxySelector = ProxySelector.of(proxyAddress);
116         }
117 
118         public static CountingProxySelector of(InetSocketAddress proxyAddress) {
119             return new CountingProxySelector(proxyAddress);
120         }
121 
122         int count() { return count; }
123 
124         @Override
125         public List&lt;Proxy&gt; select(URI uri) {
126             count++;
127             return proxySelector.select(uri);
128         }
129 
130         @Override
131         public void connectFailed(URI uri, SocketAddress sa, IOException ioe) {
132             proxySelector.connectFailed(uri, sa, ioe);
133         }
134     }
135 
136     // The sanity test sends request to the server, and through the proxy,
137     // using the legacy HttpURLConnection to verify that server and proxy
138     // work as expected.
139     private static void performSanityTest(HttpServer server, URI uri, URI proxiedURI)
140         throws IOException {
141         connections.clear();
142         System.out.println(&quot;Verifying communication with server&quot;);
143         try (InputStream is = uri.toURL().openConnection(NO_PROXY).getInputStream()) {
144             String resp = new String(is.readAllBytes(), StandardCharsets.UTF_8);
145             System.out.println(resp);
146             if (!RESPONSE.equals(resp)) {
147                 throw new AssertionError(&quot;Unexpected response from server&quot;);
148             }
149         }
150         System.out.println(&quot;Communication with server OK&quot;);
151         int count = connections.size();
152         if (count != 1) {
153             System.err.println(&quot;Unexpected connection count: &quot; + count);
154             System.err.println(&quot;Connections: &quot; + connections);
155             throw new AssertionError(&quot;Expected only one connection: &quot; + connections);
156         }
157         try {
158             System.out.println(&quot;Pretending the server is a proxy...&quot;);
159             Proxy p = new Proxy(Proxy.Type.HTTP,
160                     InetSocketAddress.createUnresolved(
161                             server.getAddress().getAddress().getHostAddress(),
162                             server.getAddress().getPort()));
163             System.out.println(&quot;Verifying communication with proxy&quot;);
164             HttpURLConnection conn = (HttpURLConnection) proxiedURI.toURL().openConnection(p);
165             try (InputStream is = conn.getInputStream()) {
166                 String resp = new String(is.readAllBytes(), StandardCharsets.UTF_8);
167                 System.out.println(resp);
168                 if (!RESPONSE.equals(resp)) {
169                     throw new AssertionError(&quot;Unexpected response from proxy&quot;);
170                 }
171             }
172             count = connections.size();
173             if (count != 2) {
174                 System.err.println(&quot;Unexpected connection count: &quot; + count);
175                 System.err.println(&quot;Connections: &quot; + connections);
176                 throw new AssertionError(&quot;Expected two connection: &quot; + connections);
177             }
178             System.out.println(&quot;Communication with proxy OK&quot;);
179         } finally {
180             connections.clear();
181         }
182     }
183 
184     public static void test(HttpServer server, HttpClient.Version version)
185             throws IOException,
186             URISyntaxException,
187             InterruptedException {
188         connections.clear();
189         System.out.println(&quot;\n===== Testing with &quot; + version);
190         System.out.println(&quot;Server is: &quot; + server.getAddress().toString());
191         URI uri = new URI(&quot;http&quot;, null,
192                 server.getAddress().getAddress().getHostAddress(),
193                 server.getAddress().getPort(), PATH + &quot;x&quot;,
194                 null, null);
195         URI proxiedURI = new URI(&quot;http://some.host.that.does.not.exist:4242&quot; + PATH + &quot;x&quot;);
196 
197         performSanityTest(server, uri, proxiedURI);
198 
199         try {
200             connections.clear();
201             System.out.println(&quot;\nReal test begins here.&quot;);
202             System.out.println(&quot;Setting up request with HttpClient for version: &quot;
203                     + version.name());
204             // This will force the HTTP client to see the server as a proxy,
205             // and to (re)use a PlainProxyConnection to send the request
206             // to the fake `proxiedURI` at
207             // http://some.host.that.does.not.exist:4242/foo/x
208             //
209             CountingProxySelector ps = CountingProxySelector.of(
210                     InetSocketAddress.createUnresolved(
211                             server.getAddress().getAddress().getHostAddress(),
212                             server.getAddress().getPort()));
213             HttpClient client = HttpClient.newBuilder()
214                     .version(version)
215                     .proxy(ps)
216                     .build();
217             HttpRequest request = HttpRequest.newBuilder()
218                     .uri(proxiedURI)
219                     .GET()
220                     .build();
221 
222             System.out.println(&quot;Sending request with HttpClient: &quot; + request);
223             HttpResponse&lt;String&gt; response
224                     = client.send(request, HttpResponse.BodyHandlers.ofString());
225             System.out.println(&quot;Got response&quot;);
226             String resp = response.body();
227             System.out.println(&quot;Received: &quot; + resp);
228             if (!RESPONSE.equals(resp)) {
229                 throw new AssertionError(&quot;Unexpected response&quot;);
230             }
231             if (ps.count() &gt; 1) {
232                 throw new AssertionError(&quot;CountingProxySelector. Expected 1, got &quot; + ps.count());
233             }
234             int count = connections.size();
235             if (count != 1) {
236                 System.err.println(&quot;Unexpected connection count: &quot; + count);
237                 System.err.println(&quot;Connections: &quot; + connections);
238                 throw new AssertionError(&quot;Expected only one connection: &quot; + connections);
239             }
240             for (int i = 2; i &lt; 5; i++) {
241                 System.out.println(&quot;Sending next request (&quot; + i + &quot;) with HttpClient: &quot; + request);
242                 response = client.send(request, HttpResponse.BodyHandlers.ofString());
243                 System.out.println(&quot;Got response&quot;);
244                 resp = response.body();
245                 System.out.println(&quot;Received: &quot; + resp);
246                 if (!RESPONSE.equals(resp)) {
247                     throw new AssertionError(&quot;Unexpected response&quot;);
248                 }
249                 if (ps.count() &gt; i) {
250                     throw new AssertionError(&quot;CountingProxySelector. Expected &quot;
251                             + i + &quot;, got &quot; + ps.count());
252                 }
253                 count = connections.size();
254                 if (count != i) {
255                     System.err.println(&quot;Unexpected connection count: &quot; + count);
256                     System.err.println(&quot;Connections: &quot; + connections);
257                     throw new AssertionError(&quot;Expected &quot; + i + &quot;: &quot; + connections);
258                 }
259             }
260             Set&lt;InetSocketAddress&gt; remote = connections.stream().distinct().collect(Collectors.toSet());
261             count = remote.size();
262             if (count != 1) {
263                 System.err.println(&quot;Unexpected connection count: &quot; + count);
264                 System.err.println(&quot;Connections: &quot; + remote);
265                 throw new AssertionError(&quot;Expected only one connection: &quot; + remote);
266             } else {
267                 System.out.println(&quot;PASSED: Proxy received only one connection from: &quot; + remote);
268             }
269         } finally {
270             connections.clear();
271         }
272     }
273 }
    </pre>
  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New test/jdk/java/net/httpclient/ShortRequestBody.java</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2015, 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 import java.io.IOException;
 25 import java.io.InputStream;
 26 import java.io.OutputStream;
 27 import java.io.UncheckedIOException;
 28 import java.net.InetAddress;
 29 import java.net.InetSocketAddress;
 30 import java.net.ServerSocket;
 31 import java.net.Socket;
 32 import java.net.SocketException;
 33 import java.net.URI;
 34 import java.net.http.HttpClient;
 35 import java.net.http.HttpRequest;
 36 import java.net.http.HttpRequest.BodyPublishers;
 37 import java.net.http.HttpResponse;
 38 import java.net.http.HttpResponse.BodyHandlers;
 39 import java.net.http.HttpTimeoutException;
 40 import java.nio.file.Files;
 41 import java.nio.file.Path;
 42 import java.nio.file.Paths;
 43 import java.nio.ByteBuffer;
 44 import java.util.ArrayList;
 45 import java.util.List;
 46 import java.util.concurrent.CompletableFuture;
 47 import java.util.concurrent.ExecutionException;
 48 import java.util.concurrent.Flow;
 49 import java.util.concurrent.TimeoutException;
 50 import java.util.concurrent.TimeUnit;
 51 import java.util.function.Supplier;
 52 import static java.lang.System.err;
 53 import static java.nio.charset.StandardCharsets.US_ASCII;
 54 import static java.nio.charset.StandardCharsets.UTF_8;
 55 
 56 /**
 57  * @test
 58  * @bug 8151441
 59  * @summary Request body of incorrect (larger or smaller) sizes than that
 60  *          reported by the body publisher
 61  * @run main/othervm ShortRequestBody
 62  */
 63 
 64 public class ShortRequestBody {
 65 
 66     static final Path testSrc = Paths.get(System.getProperty(&quot;test.src&quot;, &quot;.&quot;));
 67 
 68     // Some body types ( sources ) for testing.
 69     static final String STRING_BODY = &quot;Hello world&quot;;
 70     static final byte[] BYTE_ARRAY_BODY = new byte[] {
 71         (byte)0xCA, (byte)0xFE, (byte)0xBA, (byte)0xBE };
 72     static final Path FILE_BODY = testSrc.resolve(&quot;docs&quot;).resolve(&quot;files&quot;).resolve(&quot;foo.txt&quot;);
 73 
 74     // Body lengths and offsets ( amount to be wrong by ), to make coordination
 75     // between client and server easier.
 76     static final int[] BODY_LENGTHS = new int[] { STRING_BODY.length(),
 77                                                   BYTE_ARRAY_BODY.length,
 78                                                   fileSize(FILE_BODY) };
 79     static final int[] BODY_OFFSETS = new int[] { 0, +1, -1, +2, -2, +3, -3 };
 80     static final String MARKER = &quot;ShortRequestBody&quot;;
 81 
 82     // A delegating Body Publisher. Subtypes will have a concrete body type.
 83     static abstract class AbstractDelegateRequestBody
 84             implements HttpRequest.BodyPublisher {
 85 
 86         final HttpRequest.BodyPublisher delegate;
 87         final long contentLength;
 88 
 89         AbstractDelegateRequestBody(HttpRequest.BodyPublisher delegate,
 90                                     long contentLength) {
 91             this.delegate = delegate;
 92             this.contentLength = contentLength;
 93         }
 94 
 95         @Override
 96         public void subscribe(Flow.Subscriber&lt;? super ByteBuffer&gt; subscriber) {
 97             delegate.subscribe(subscriber);
 98         }
 99 
100         @Override
101         public long contentLength() { return contentLength; /* may be wrong! */ }
102     }
103 
104     // Request body Publishers that may generate a different number of actual
105     // bytes to that of what is reported through their {@code contentLength}.
106 
107     static class StringRequestBody extends AbstractDelegateRequestBody {
108         StringRequestBody(String body, int additionalLength) {
109             super(HttpRequest.BodyPublishers.ofString(body),
110                   body.getBytes(UTF_8).length + additionalLength);
111         }
112     }
113 
114     static class ByteArrayRequestBody extends AbstractDelegateRequestBody {
115         ByteArrayRequestBody(byte[] body, int additionalLength) {
116             super(BodyPublishers.ofByteArray(body),
117                   body.length + additionalLength);
118         }
119     }
120 
121     static class FileRequestBody extends AbstractDelegateRequestBody {
122         FileRequestBody(Path path, int additionalLength) throws IOException {
123             super(BodyPublishers.ofFile(path),
124                   Files.size(path) + additionalLength);
125         }
126     }
127 
128     // ---
129 
130     public static void main(String[] args) throws Exception {
131         HttpClient sharedClient = HttpClient.newHttpClient();
132         List&lt;Supplier&lt;HttpClient&gt;&gt; clientSuppliers = new ArrayList&lt;&gt;();
133         clientSuppliers.add(() -&gt; HttpClient.newHttpClient());
134         clientSuppliers.add(() -&gt; sharedClient);
135 
136         try (Server server = new Server()) {
137             for (Supplier&lt;HttpClient&gt; cs : clientSuppliers) {
138                 err.println(&quot;\n---- next supplier ----\n&quot;);
139                 URI uri = new URI(&quot;http://localhost:&quot; + server.getPort() + &quot;/&quot; + MARKER);
140 
141                 // sanity ( 6 requests to keep client and server offsets easy to workout )
142                 success(cs, uri, new StringRequestBody(STRING_BODY, 0));
143                 success(cs, uri, new ByteArrayRequestBody(BYTE_ARRAY_BODY, 0));
144                 success(cs, uri, new FileRequestBody(FILE_BODY, 0));
145                 success(cs, uri, new StringRequestBody(STRING_BODY, 0));
146                 success(cs, uri, new ByteArrayRequestBody(BYTE_ARRAY_BODY, 0));
147                 success(cs, uri, new FileRequestBody(FILE_BODY, 0));
148 
149                 for (int i = 1; i &lt; BODY_OFFSETS.length; i++) {
150                     failureBlocking(cs, uri, new StringRequestBody(STRING_BODY, BODY_OFFSETS[i]));
151                     failureBlocking(cs, uri, new ByteArrayRequestBody(BYTE_ARRAY_BODY, BODY_OFFSETS[i]));
152                     failureBlocking(cs, uri, new FileRequestBody(FILE_BODY, BODY_OFFSETS[i]));
153 
154                     failureNonBlocking(cs, uri, new StringRequestBody(STRING_BODY, BODY_OFFSETS[i]));
155                     failureNonBlocking(cs, uri, new ByteArrayRequestBody(BYTE_ARRAY_BODY, BODY_OFFSETS[i]));
156                     failureNonBlocking(cs, uri, new FileRequestBody(FILE_BODY, BODY_OFFSETS[i]));
157                 }
158             }
159         }
160     }
161 
162     static void success(Supplier&lt;HttpClient&gt; clientSupplier,
163                         URI uri,
164                         HttpRequest.BodyPublisher publisher)
165         throws Exception
166     {
167         CompletableFuture&lt;HttpResponse&lt;Void&gt;&gt; cf;
168         HttpRequest request = HttpRequest.newBuilder(uri)
169                                          .POST(publisher)
170                                          .build();
171         cf = clientSupplier.get().sendAsync(request, BodyHandlers.discarding());
172 
173         HttpResponse&lt;Void&gt; resp = cf.get(30, TimeUnit.SECONDS);
174         err.println(&quot;Response code: &quot; + resp.statusCode());
175         check(resp.statusCode() == 200, null,
176                 &quot;Expected 200, got &quot;, resp.statusCode());
177     }
178 
179     static void failureNonBlocking(Supplier&lt;HttpClient&gt; clientSupplier,
180                                    URI uri,
181                                    HttpRequest.BodyPublisher publisher)
182         throws Exception
183     {
184         CompletableFuture&lt;HttpResponse&lt;Void&gt;&gt; cf;
185         HttpRequest request = HttpRequest.newBuilder(uri)
186                                          .POST(publisher)
187                                          .build();
188         cf = clientSupplier.get().sendAsync(request, BodyHandlers.discarding());
189 
190         try {
191             HttpResponse&lt;Void&gt; r = cf.get(30, TimeUnit.SECONDS);
192             throw new RuntimeException(&quot;Unexpected response: &quot; + r.statusCode());
193         } catch (TimeoutException x) {
194             throw new RuntimeException(&quot;Unexpected timeout&quot;, x);
195         } catch (ExecutionException expected) {
196             err.println(&quot;Caught expected: &quot; + expected);
197             Throwable t = expected.getCause();
198             check(t instanceof IOException, t,
199                   &quot;Expected cause IOException, but got: &quot;, t);
200             String msg = t.getMessage();
201             check(msg.contains(&quot;Too many&quot;) || msg.contains(&quot;Too few&quot;),
202                     t, &quot;Expected Too many|Too few, got: &quot;, t);
203         }
204     }
205 
206     static void failureBlocking(Supplier&lt;HttpClient&gt; clientSupplier,
207                                 URI uri,
208                                 HttpRequest.BodyPublisher publisher)
209         throws Exception
210     {
211         HttpRequest request = HttpRequest.newBuilder(uri)
212                                          .POST(publisher)
213                                          .build();
214         try {
215             HttpResponse&lt;Void&gt; r = clientSupplier.get()
216                     .send(request, BodyHandlers.discarding());
217             throw new RuntimeException(&quot;Unexpected response: &quot; + r.statusCode());
218         } catch (HttpTimeoutException x) {
219             throw new RuntimeException(&quot;Unexpected timeout&quot;, x);
220         } catch (IOException expected) {
221             err.println(&quot;Caught expected: &quot; + expected);
222             String msg = expected.getMessage();
223             check(msg.contains(&quot;Too many&quot;) || msg.contains(&quot;Too few&quot;),
224                     expected,&quot;Expected Too many|Too few, got: &quot;, expected);
225         }
226     }
227 
228     static class Server extends Thread implements AutoCloseable {
229 
230         static String RESPONSE = &quot;HTTP/1.1 200 OK\r\n&quot; +
231                                  &quot;Connection: close\r\n&quot;+
232                                  &quot;Content-length: 0\r\n\r\n&quot;;
233 
234         private final ServerSocket ss;
235         private volatile boolean closed;
236 
237         Server() throws IOException {
238             super(&quot;Test-Server&quot;);
239             ss = new ServerSocket();
240             ss.setReuseAddress(false);
241             ss.bind(new InetSocketAddress(InetAddress.getLoopbackAddress(), 0));
242             this.start();
243         }
244 
245         int getPort() { return ss.getLocalPort(); }
246 
247         @Override
248         public void run() {
249             int count = 0;
250             int offset = 0;
251 
252             while (!closed) {
253                 err.println(&quot;Server: waiting for connection&quot;);
254                 try (Socket s = ss.accept()) {
255                     err.println(&quot;Server: got connection&quot;);
256                     InputStream is = s.getInputStream();
257                     try {
258                         String headers = readRequestHeaders(is);
259                         if (headers == null) continue;
260                     } catch (SocketException ex) {
261                         err.println(&quot;Ignoring unexpected exception while reading headers: &quot; + ex);
262                         ex.printStackTrace(err);
263                         // proceed in order to update count etc..., even though
264                         // we know that read() will fail;
265                     }
266                     byte[] ba = new byte[1024];
267 
268                     int length = BODY_LENGTHS[count % 3];
269                     length += BODY_OFFSETS[offset];
270                     err.println(&quot;Server: count=&quot; + count + &quot;, offset=&quot; + offset);
271                     err.println(&quot;Server: expecting &quot; +length+ &quot; bytes&quot;);
272                     int read = 0;
273                     try {
274                         read = is.readNBytes(ba, 0, length);
275                         err.println(&quot;Server: actually read &quot; + read + &quot; bytes&quot;);
276                     } finally {
277                         // Update the counts before replying, to prevent the
278                         // client-side racing reset with this thread.
279                         count++;
280                         if (count % 6 == 0) // 6 is the number of failure requests per offset
281                             offset++;
282                         if (count % 42 == 0) {
283                             count = 0;  // reset, for second iteration
284                             offset = 0;
285                         }
286                     }
287                     if (read &lt; length) {
288                         // no need to reply, client has already closed
289                         // ensure closed
290                         if (is.read() != -1)
291                             new AssertionError(&quot;Unexpected read: &quot; + read);
292                     } else {
293                         OutputStream os = s.getOutputStream();
294                         err.println(&quot;Server: writing &quot;
295                                 + RESPONSE.getBytes(US_ASCII).length + &quot; bytes&quot;);
296                         os.write(RESPONSE.getBytes(US_ASCII));
297                     }
298                 } catch (Throwable e) {
299                     if (!closed) {
300                         err.println(&quot;Unexpected: &quot; + e);
301                         e.printStackTrace();
302                     }
303                 }
304             }
305         }
306 
307         @Override
308         public void close() {
309             if (closed)
310                 return;
311             closed = true;
312             try {
313                 ss.close();
314             } catch (IOException e) {
315                 throw new UncheckedIOException(&quot;Unexpected&quot;, e);
316             }
317         }
318     }
319 
320     static final byte[] requestEnd = new byte[] {&#39;\r&#39;, &#39;\n&#39;, &#39;\r&#39;, &#39;\n&#39; };
321 
322     // Read until the end of a HTTP request headers
323     static String readRequestHeaders(InputStream is) throws IOException {
324         int requestEndCount = 0, r, eol = -1;
325         StringBuilder headers = new StringBuilder();
326         while ((r = is.read()) != -1) {
327             if (r == &#39;\r&#39; &amp;&amp; eol &lt; 0) {
328                 eol = headers.length();
329             }
330             headers.append((char) r);
331             if (r == requestEnd[requestEndCount]) {
332                 requestEndCount++;
333                 if (requestEndCount == 4) {
334                     break;
335                 }
336             } else {
337                 requestEndCount = 0;
338             }
339         }
340 
341         if (eol &lt;= 0) return null;
342         String requestLine = headers.toString().substring(0, eol);
343         if (!requestLine.contains(MARKER)) return null;
344         return headers.toString();
345     }
346 
347     static int fileSize(Path p) {
348         try { return (int) Files.size(p); }
349         catch (IOException x) { throw new UncheckedIOException(x); }
350     }
351 
352     static boolean check(boolean cond, Throwable t, Object... failedArgs) {
353         if (cond)
354             return true;
355         // We are going to fail...
356         StringBuilder sb = new StringBuilder();
357         for (Object o : failedArgs)
358                 sb.append(o);
359         throw new RuntimeException(sb.toString(), t);
360     }
361 }
    </pre>
  </body>
</html>
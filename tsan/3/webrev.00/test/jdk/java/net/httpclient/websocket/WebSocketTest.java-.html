<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old test/jdk/java/net/httpclient/websocket/WebSocketTest.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2018, 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 /*
 25  * @test
 26  * @bug 8217429
 27  * @build DummyWebSocketServer
 28  * @run testng/othervm
 29  *       WebSocketTest
 30  */
 31 
 32 import org.testng.annotations.AfterTest;
 33 import org.testng.annotations.DataProvider;
 34 import org.testng.annotations.Test;
 35 
 36 import java.io.IOException;
 37 import java.net.Authenticator;
 38 import java.net.PasswordAuthentication;
 39 import java.net.http.HttpResponse;
 40 import java.net.http.WebSocket;
 41 import java.net.http.WebSocketHandshakeException;
 42 import java.nio.ByteBuffer;
 43 import java.nio.charset.StandardCharsets;
 44 import java.util.ArrayList;
 45 import java.util.Base64;
 46 import java.util.List;
 47 import java.util.concurrent.CompletableFuture;
 48 import java.util.concurrent.CompletionException;
 49 import java.util.concurrent.CompletionStage;
 50 import java.util.concurrent.TimeUnit;
 51 import java.util.concurrent.atomic.AtomicBoolean;
 52 import java.util.function.Function;
 53 import java.util.function.Supplier;
 54 import java.util.stream.Collectors;
 55 
 56 import static java.net.http.HttpClient.Builder.NO_PROXY;
 57 import static java.net.http.HttpClient.newBuilder;
 58 import static java.net.http.WebSocket.NORMAL_CLOSURE;
 59 import static java.nio.charset.StandardCharsets.UTF_8;
 60 import static org.testng.Assert.assertEquals;
 61 import static org.testng.Assert.assertThrows;
 62 import static org.testng.Assert.fail;
 63 
 64 public class WebSocketTest {
 65 
 66     private static final Class&lt;IllegalArgumentException&gt; IAE = IllegalArgumentException.class;
 67     private static final Class&lt;IllegalStateException&gt; ISE = IllegalStateException.class;
 68     private static final Class&lt;IOException&gt; IOE = IOException.class;
 69 
 70     /* shortcut */
 71     private static void assertFails(Class&lt;? extends Throwable&gt; clazz,
 72                                     CompletionStage&lt;?&gt; stage) {
 73         Support.assertCompletesExceptionally(clazz, stage);
 74     }
 75 
 76     private DummyWebSocketServer server;
 77     private WebSocket webSocket;
 78 
 79     @AfterTest
 80     public void cleanup() {
 81         System.out.println(&quot;AFTER TEST&quot;);
 82         if (server != null)
 83             server.close();
 84         if (webSocket != null)
 85             webSocket.abort();
 86     }
 87 
 88     @Test
 89     public void illegalArgument() throws IOException {
 90         server = new DummyWebSocketServer();
 91         server.open();
 92         webSocket = newBuilder().proxy(NO_PROXY).build()
 93                 .newWebSocketBuilder()
 94                 .buildAsync(server.getURI(), new WebSocket.Listener() { })
 95                 .join();
 96 
 97         assertFails(IAE, webSocket.sendPing(ByteBuffer.allocate(126)));
 98         assertFails(IAE, webSocket.sendPing(ByteBuffer.allocate(127)));
 99         assertFails(IAE, webSocket.sendPing(ByteBuffer.allocate(128)));
100         assertFails(IAE, webSocket.sendPing(ByteBuffer.allocate(129)));
101         assertFails(IAE, webSocket.sendPing(ByteBuffer.allocate(256)));
102 
103         assertFails(IAE, webSocket.sendPong(ByteBuffer.allocate(126)));
104         assertFails(IAE, webSocket.sendPong(ByteBuffer.allocate(127)));
105         assertFails(IAE, webSocket.sendPong(ByteBuffer.allocate(128)));
106         assertFails(IAE, webSocket.sendPong(ByteBuffer.allocate(129)));
107         assertFails(IAE, webSocket.sendPong(ByteBuffer.allocate(256)));
108 
109         assertFails(IOE, webSocket.sendText(Support.incompleteString(), true));
110         assertFails(IOE, webSocket.sendText(Support.incompleteString(), false));
111         assertFails(IOE, webSocket.sendText(Support.malformedString(), true));
112         assertFails(IOE, webSocket.sendText(Support.malformedString(), false));
113 
114         assertFails(IAE, webSocket.sendClose(NORMAL_CLOSURE, Support.stringWithNBytes(124)));
115         assertFails(IAE, webSocket.sendClose(NORMAL_CLOSURE, Support.stringWithNBytes(125)));
116         assertFails(IAE, webSocket.sendClose(NORMAL_CLOSURE, Support.stringWithNBytes(128)));
117         assertFails(IAE, webSocket.sendClose(NORMAL_CLOSURE, Support.stringWithNBytes(256)));
118         assertFails(IAE, webSocket.sendClose(NORMAL_CLOSURE, Support.stringWithNBytes(257)));
119         assertFails(IAE, webSocket.sendClose(NORMAL_CLOSURE, Support.stringWith2NBytes((123 / 2) + 1)));
120         assertFails(IAE, webSocket.sendClose(NORMAL_CLOSURE, Support.malformedString()));
121         assertFails(IAE, webSocket.sendClose(NORMAL_CLOSURE, Support.incompleteString()));
122 
123         assertFails(IAE, webSocket.sendClose(-2, &quot;a reason&quot;));
124         assertFails(IAE, webSocket.sendClose(-1, &quot;a reason&quot;));
125         assertFails(IAE, webSocket.sendClose(0, &quot;a reason&quot;));
126         assertFails(IAE, webSocket.sendClose(1, &quot;a reason&quot;));
127         assertFails(IAE, webSocket.sendClose(500, &quot;a reason&quot;));
128         assertFails(IAE, webSocket.sendClose(998, &quot;a reason&quot;));
129         assertFails(IAE, webSocket.sendClose(999, &quot;a reason&quot;));
130         assertFails(IAE, webSocket.sendClose(1002, &quot;a reason&quot;));
131         assertFails(IAE, webSocket.sendClose(1003, &quot;a reason&quot;));
132         assertFails(IAE, webSocket.sendClose(1006, &quot;a reason&quot;));
133         assertFails(IAE, webSocket.sendClose(1007, &quot;a reason&quot;));
134         assertFails(IAE, webSocket.sendClose(1009, &quot;a reason&quot;));
135         assertFails(IAE, webSocket.sendClose(1010, &quot;a reason&quot;));
136         assertFails(IAE, webSocket.sendClose(1012, &quot;a reason&quot;));
137         assertFails(IAE, webSocket.sendClose(1013, &quot;a reason&quot;));
138         assertFails(IAE, webSocket.sendClose(1015, &quot;a reason&quot;));
139         assertFails(IAE, webSocket.sendClose(5000, &quot;a reason&quot;));
140         assertFails(IAE, webSocket.sendClose(32768, &quot;a reason&quot;));
141         assertFails(IAE, webSocket.sendClose(65535, &quot;a reason&quot;));
142         assertFails(IAE, webSocket.sendClose(65536, &quot;a reason&quot;));
143         assertFails(IAE, webSocket.sendClose(Integer.MAX_VALUE, &quot;a reason&quot;));
144         assertFails(IAE, webSocket.sendClose(Integer.MIN_VALUE, &quot;a reason&quot;));
145 
146         assertThrows(IAE, () -&gt; webSocket.request(Integer.MIN_VALUE));
147         assertThrows(IAE, () -&gt; webSocket.request(Long.MIN_VALUE));
148         assertThrows(IAE, () -&gt; webSocket.request(-1));
149         assertThrows(IAE, () -&gt; webSocket.request(0));
150 
151         server.close();
152     }
153 
154     @Test
155     public void partialBinaryThenText() throws IOException {
156         server = new DummyWebSocketServer();
157         server.open();
158         webSocket = newBuilder().proxy(NO_PROXY).build().newWebSocketBuilder()
159                 .buildAsync(server.getURI(), new WebSocket.Listener() { })
160                 .join();
161         webSocket.sendBinary(ByteBuffer.allocate(16), false).join();
162         assertFails(ISE, webSocket.sendText(&quot;text&quot;, false));
163         assertFails(ISE, webSocket.sendText(&quot;text&quot;, true));
164         // Pings &amp; Pongs are fine
165         webSocket.sendPing(ByteBuffer.allocate(125)).join();
166         webSocket.sendPong(ByteBuffer.allocate(125)).join();
167         server.close();
168     }
169 
170     @Test
171     public void partialTextThenBinary() throws IOException {
172         server = new DummyWebSocketServer();
173         server.open();
174         webSocket = newBuilder().proxy(NO_PROXY).build().newWebSocketBuilder()
175                 .buildAsync(server.getURI(), new WebSocket.Listener() { })
176                 .join();
177 
178         webSocket.sendText(&quot;text&quot;, false).join();
179         assertFails(ISE, webSocket.sendBinary(ByteBuffer.allocate(16), false));
180         assertFails(ISE, webSocket.sendBinary(ByteBuffer.allocate(16), true));
181         // Pings &amp; Pongs are fine
182         webSocket.sendPing(ByteBuffer.allocate(125)).join();
183         webSocket.sendPong(ByteBuffer.allocate(125)).join();
184         server.close();
185     }
186 
187     @Test
188     public void sendMethodsThrowIOE1() throws IOException {
189         server = new DummyWebSocketServer();
190         server.open();
191         webSocket = newBuilder().proxy(NO_PROXY).build()
192                 .newWebSocketBuilder()
193                 .buildAsync(server.getURI(), new WebSocket.Listener() { })
194                 .join();
195 
196         webSocket.sendClose(NORMAL_CLOSURE, &quot;ok&quot;).join();
197 
198         assertFails(IOE, webSocket.sendClose(WebSocket.NORMAL_CLOSURE, &quot;ok&quot;));
199 
200         assertFails(IOE, webSocket.sendText(&quot;&quot;, true));
201         assertFails(IOE, webSocket.sendText(&quot;&quot;, false));
202         assertFails(IOE, webSocket.sendText(&quot;abc&quot;, true));
203         assertFails(IOE, webSocket.sendText(&quot;abc&quot;, false));
204         assertFails(IOE, webSocket.sendBinary(ByteBuffer.allocate(0), true));
205         assertFails(IOE, webSocket.sendBinary(ByteBuffer.allocate(0), false));
206         assertFails(IOE, webSocket.sendBinary(ByteBuffer.allocate(1), true));
207         assertFails(IOE, webSocket.sendBinary(ByteBuffer.allocate(1), false));
208 
209         assertFails(IOE, webSocket.sendPing(ByteBuffer.allocate(125)));
210         assertFails(IOE, webSocket.sendPing(ByteBuffer.allocate(124)));
211         assertFails(IOE, webSocket.sendPing(ByteBuffer.allocate(1)));
212         assertFails(IOE, webSocket.sendPing(ByteBuffer.allocate(0)));
213 
214         assertFails(IOE, webSocket.sendPong(ByteBuffer.allocate(125)));
215         assertFails(IOE, webSocket.sendPong(ByteBuffer.allocate(124)));
216         assertFails(IOE, webSocket.sendPong(ByteBuffer.allocate(1)));
217         assertFails(IOE, webSocket.sendPong(ByteBuffer.allocate(0)));
218 
219         server.close();
220     }
221 
222     @DataProvider(name = &quot;sequence&quot;)
223     public Object[][] data1() {
224         int[] CLOSE = {
225                 0x81, 0x00, // &quot;&quot;
226                 0x82, 0x00, // []
227                 0x89, 0x00, // &lt;PING&gt;
228                 0x8a, 0x00, // &lt;PONG&gt;
229                 0x88, 0x00, // &lt;CLOSE&gt;
230         };
231         int[] ERROR = {
232                 0x81, 0x00, // &quot;&quot;
233                 0x82, 0x00, // []
234                 0x89, 0x00, // &lt;PING&gt;
235                 0x8a, 0x00, // &lt;PONG&gt;
236                 0x8b, 0x00, // 0xB control frame (causes an error)
237         };
238         return new Object[][]{
239                 {CLOSE, 1},
240                 {CLOSE, 3},
241                 {CLOSE, 4},
242                 {CLOSE, Long.MAX_VALUE},
243                 {ERROR, 1},
244                 {ERROR, 3},
245                 {ERROR, 4},
246                 {ERROR, Long.MAX_VALUE},
247         };
248     }
249 
250     @Test(dataProvider = &quot;sequence&quot;)
251     public void listenerSequentialOrder(int[] binary, long requestSize)
252             throws IOException
253     {
254 
255         server = Support.serverWithCannedData(binary);
256         server.open();
257 
258         CompletableFuture&lt;Void&gt; violation = new CompletableFuture&lt;&gt;();
259 
260         MockListener listener = new MockListener(requestSize) {
261 
262             final AtomicBoolean guard = new AtomicBoolean();
263 
264             private &lt;T&gt; T checkRunExclusively(Supplier&lt;T&gt; action) {
265                 if (guard.getAndSet(true)) {
266                     violation.completeExceptionally(new RuntimeException());
267                 }
268                 try {
269                     return action.get();
270                 } finally {
271                     if (!guard.getAndSet(false)) {
272                         violation.completeExceptionally(new RuntimeException());
273                     }
274                 }
275             }
276 
277             @Override
278             public void onOpen(WebSocket webSocket) {
279                 checkRunExclusively(() -&gt; {
280                     super.onOpen(webSocket);
281                     return null;
282                 });
283             }
284 
285             @Override
286             public CompletionStage&lt;?&gt; onText(WebSocket webSocket,
287                                              CharSequence data,
288                                              boolean last) {
289                 return checkRunExclusively(
290                         () -&gt; super.onText(webSocket, data, last));
291             }
292 
293             @Override
294             public CompletionStage&lt;?&gt; onBinary(WebSocket webSocket,
295                                                ByteBuffer data,
296                                                boolean last) {
297                 return checkRunExclusively(
298                         () -&gt; super.onBinary(webSocket, data, last));
299             }
300 
301             @Override
302             public CompletionStage&lt;?&gt; onPing(WebSocket webSocket,
303                                              ByteBuffer message) {
304                 return checkRunExclusively(
305                         () -&gt; super.onPing(webSocket, message));
306             }
307 
308             @Override
309             public CompletionStage&lt;?&gt; onPong(WebSocket webSocket,
310                                              ByteBuffer message) {
311                 return checkRunExclusively(
312                         () -&gt; super.onPong(webSocket, message));
313             }
314 
315             @Override
316             public CompletionStage&lt;?&gt; onClose(WebSocket webSocket,
317                                               int statusCode,
318                                               String reason) {
319                 return checkRunExclusively(
320                         () -&gt; super.onClose(webSocket, statusCode, reason));
321             }
322 
323             @Override
324             public void onError(WebSocket webSocket, Throwable error) {
325                 checkRunExclusively(() -&gt; {
326                     super.onError(webSocket, error);
327                     return null;
328                 });
329             }
330         };
331 
332         webSocket = newBuilder().proxy(NO_PROXY).build().newWebSocketBuilder()
333                 .buildAsync(server.getURI(), listener)
334                 .join();
335 
336 
337         listener.invocations();
338         violation.complete(null); // won&#39;t affect if completed exceptionally
339         violation.join();
340 
341         server.close();
342     }
343 
344     @Test
345     public void sendMethodsThrowIOE2() throws Exception {
346         server = Support.serverWithCannedData(0x88, 0x00);
347         server.open();
348         CompletableFuture&lt;Void&gt; onCloseCalled = new CompletableFuture&lt;&gt;();
349         CompletableFuture&lt;Void&gt; canClose = new CompletableFuture&lt;&gt;();
350 
351         WebSocket.Listener listener = new WebSocket.Listener() {
352             @Override
353             public CompletionStage&lt;?&gt; onClose(WebSocket webSocket,
354                                               int statusCode,
355                                               String reason) {
356                 System.out.printf(&quot;onClose(%s, &#39;%s&#39;)%n&quot;, statusCode, reason);
357                 onCloseCalled.complete(null);
358                 return canClose;
359             }
360 
361             @Override
362             public void onError(WebSocket webSocket, Throwable error) {
363                 System.out.println(&quot;onError(&quot; + error + &quot;)&quot;);
364                 onCloseCalled.completeExceptionally(error);
365             }
366         };
367 
368         webSocket = newBuilder().proxy(NO_PROXY).build().newWebSocketBuilder()
369                 .buildAsync(server.getURI(), listener)
370                 .join();
371 
372         onCloseCalled.join();      // Wait for onClose to be called
373         canClose.complete(null);   // Signal to the WebSocket it can close the output
374         TimeUnit.SECONDS.sleep(5); // Give canClose some time to reach the WebSocket
375 
376         assertFails(IOE, webSocket.sendClose(WebSocket.NORMAL_CLOSURE, &quot;ok&quot;));
377 
378         assertFails(IOE, webSocket.sendText(&quot;&quot;, true));
379         assertFails(IOE, webSocket.sendText(&quot;&quot;, false));
380         assertFails(IOE, webSocket.sendText(&quot;abc&quot;, true));
381         assertFails(IOE, webSocket.sendText(&quot;abc&quot;, false));
382         assertFails(IOE, webSocket.sendBinary(ByteBuffer.allocate(0), true));
383         assertFails(IOE, webSocket.sendBinary(ByteBuffer.allocate(0), false));
384         assertFails(IOE, webSocket.sendBinary(ByteBuffer.allocate(1), true));
385         assertFails(IOE, webSocket.sendBinary(ByteBuffer.allocate(1), false));
386 
387         assertFails(IOE, webSocket.sendPing(ByteBuffer.allocate(125)));
388         assertFails(IOE, webSocket.sendPing(ByteBuffer.allocate(124)));
389         assertFails(IOE, webSocket.sendPing(ByteBuffer.allocate(1)));
390         assertFails(IOE, webSocket.sendPing(ByteBuffer.allocate(0)));
391 
392         assertFails(IOE, webSocket.sendPong(ByteBuffer.allocate(125)));
393         assertFails(IOE, webSocket.sendPong(ByteBuffer.allocate(124)));
394         assertFails(IOE, webSocket.sendPong(ByteBuffer.allocate(1)));
395         assertFails(IOE, webSocket.sendPong(ByteBuffer.allocate(0)));
396 
397         server.close();
398     }
399 
400     // Used to verify a server requiring Authentication
401     private static final String USERNAME = &quot;chegar&quot;;
402     private static final String PASSWORD = &quot;a1b2c3&quot;;
403 
404     static class WSAuthenticator extends Authenticator {
405         @Override
406         protected PasswordAuthentication getPasswordAuthentication() {
407             return new PasswordAuthentication(USERNAME, PASSWORD.toCharArray());
408         }
409     }
410 
411     static final Function&lt;int[],DummyWebSocketServer&gt; SERVER_WITH_CANNED_DATA =
412         new Function&lt;&gt;() {
413             @Override public DummyWebSocketServer apply(int[] data) {
414                 return Support.serverWithCannedData(data); }
415             @Override public String toString() { return &quot;SERVER_WITH_CANNED_DATA&quot;; }
416         };
417 
418     static final Function&lt;int[],DummyWebSocketServer&gt; AUTH_SERVER_WITH_CANNED_DATA =
419         new Function&lt;&gt;() {
420             @Override public DummyWebSocketServer apply(int[] data) {
421                 return Support.serverWithCannedDataAndAuthentication(USERNAME, PASSWORD, data); }
422             @Override public String toString() { return &quot;AUTH_SERVER_WITH_CANNED_DATA&quot;; }
423         };
424 
425     @DataProvider(name = &quot;servers&quot;)
426     public Object[][] servers() {
427         return new Object[][] {
428             { SERVER_WITH_CANNED_DATA },
429             { AUTH_SERVER_WITH_CANNED_DATA },
430         };
431     }
432 
433     @Test(dataProvider = &quot;servers&quot;)
434     public void simpleAggregatingBinaryMessages
435             (Function&lt;int[],DummyWebSocketServer&gt; serverSupplier)
436         throws IOException
437     {
438         List&lt;byte[]&gt; expected = List.of(&quot;alpha&quot;, &quot;beta&quot;, &quot;gamma&quot;, &quot;delta&quot;)
439                 .stream()
440                 .map(s -&gt; s.getBytes(StandardCharsets.US_ASCII))
441                 .collect(Collectors.toList());
442         int[] binary = new int[]{
443                 0x82, 0x05, 0x61, 0x6c, 0x70, 0x68, 0x61, // [alpha]
444                 0x02, 0x02, 0x62, 0x65,                   // [be
445                 0x80, 0x02, 0x74, 0x61,                   // ta]
446                 0x02, 0x01, 0x67,                         // [g
447                 0x00, 0x01, 0x61,                         // a
448                 0x00, 0x00,                               //
449                 0x00, 0x00,                               //
450                 0x00, 0x01, 0x6d,                         // m
451                 0x00, 0x01, 0x6d,                         // m
452                 0x80, 0x01, 0x61,                         // a]
453                 0x8a, 0x00,                               // &lt;PONG&gt;
454                 0x02, 0x04, 0x64, 0x65, 0x6c, 0x74,       // [delt
455                 0x00, 0x01, 0x61,                         // a
456                 0x80, 0x00,                               // ]
457                 0x88, 0x00                                // &lt;CLOSE&gt;
458         };
459         CompletableFuture&lt;List&lt;byte[]&gt;&gt; actual = new CompletableFuture&lt;&gt;();
460 
461         server = serverSupplier.apply(binary);
462         server.open();
463 
464         WebSocket.Listener listener = new WebSocket.Listener() {
465 
466             List&lt;byte[]&gt; collectedBytes = new ArrayList&lt;&gt;();
467             ByteBuffer buffer = ByteBuffer.allocate(1024);
468 
469             @Override
470             public CompletionStage&lt;?&gt; onBinary(WebSocket webSocket,
471                                                ByteBuffer message,
472                                                boolean last) {
473                 System.out.printf(&quot;onBinary(%s, %s)%n&quot;, message, last);
474                 webSocket.request(1);
475 
476                 append(message);
477                 if (last) {
478                     buffer.flip();
479                     byte[] bytes = new byte[buffer.remaining()];
480                     buffer.get(bytes);
481                     buffer.clear();
482                     processWholeBinary(bytes);
483                 }
484                 return null;
485             }
486 
487             private void append(ByteBuffer message) {
488                 if (buffer.remaining() &lt; message.remaining()) {
489                     assert message.remaining() &gt; 0;
490                     int cap = (buffer.capacity() + message.remaining()) * 2;
491                     ByteBuffer b = ByteBuffer.allocate(cap);
492                     b.put(buffer.flip());
493                     buffer = b;
494                 }
495                 buffer.put(message);
496             }
497 
498             private void processWholeBinary(byte[] bytes) {
499                 String stringBytes = new String(bytes, UTF_8);
500                 System.out.println(&quot;processWholeBinary: &quot; + stringBytes);
501                 collectedBytes.add(bytes);
502             }
503 
504             @Override
505             public CompletionStage&lt;?&gt; onClose(WebSocket webSocket,
506                                               int statusCode,
507                                               String reason) {
508                 actual.complete(collectedBytes);
509                 return null;
510             }
511 
512             @Override
513             public void onError(WebSocket webSocket, Throwable error) {
514                 actual.completeExceptionally(error);
515             }
516         };
517 
518         webSocket = newBuilder()
519                 .proxy(NO_PROXY)
520                 .authenticator(new WSAuthenticator())
521                 .build().newWebSocketBuilder()
522                 .buildAsync(server.getURI(), listener)
523                 .join();
524 
525         List&lt;byte[]&gt; a = actual.join();
526         assertEquals(a, expected);
527 
528         server.close();
529     }
530 
531     @Test(dataProvider = &quot;servers&quot;)
532     public void simpleAggregatingTextMessages
533             (Function&lt;int[],DummyWebSocketServer&gt; serverSupplier)
534         throws IOException
535     {
536         List&lt;String&gt; expected = List.of(&quot;alpha&quot;, &quot;beta&quot;, &quot;gamma&quot;, &quot;delta&quot;);
537 
538         int[] binary = new int[]{
539                 0x81, 0x05, 0x61, 0x6c, 0x70, 0x68, 0x61, // &quot;alpha&quot;
540                 0x01, 0x02, 0x62, 0x65,                   // &quot;be
541                 0x80, 0x02, 0x74, 0x61,                   // ta&quot;
542                 0x01, 0x01, 0x67,                         // &quot;g
543                 0x00, 0x01, 0x61,                         // a
544                 0x00, 0x00,                               //
545                 0x00, 0x00,                               //
546                 0x00, 0x01, 0x6d,                         // m
547                 0x00, 0x01, 0x6d,                         // m
548                 0x80, 0x01, 0x61,                         // a&quot;
549                 0x8a, 0x00,                               // &lt;PONG&gt;
550                 0x01, 0x04, 0x64, 0x65, 0x6c, 0x74,       // &quot;delt
551                 0x00, 0x01, 0x61,                         // a
552                 0x80, 0x00,                               // &quot;
553                 0x88, 0x00                                // &lt;CLOSE&gt;
554         };
555         CompletableFuture&lt;List&lt;String&gt;&gt; actual = new CompletableFuture&lt;&gt;();
556 
557         server = serverSupplier.apply(binary);
558         server.open();
559 
560         WebSocket.Listener listener = new WebSocket.Listener() {
561 
562             List&lt;String&gt; collectedStrings = new ArrayList&lt;&gt;();
563             StringBuilder text = new StringBuilder();
564 
565             @Override
566             public CompletionStage&lt;?&gt; onText(WebSocket webSocket,
567                                              CharSequence message,
568                                              boolean last) {
569                 System.out.printf(&quot;onText(%s, %s)%n&quot;, message, last);
570                 webSocket.request(1);
571                 text.append(message);
572                 if (last) {
573                     String str = text.toString();
574                     text.setLength(0);
575                     processWholeText(str);
576                 }
577                 return null;
578             }
579 
580             private void processWholeText(String string) {
581                 System.out.println(string);
582                 collectedStrings.add(string);
583             }
584 
585             @Override
586             public CompletionStage&lt;?&gt; onClose(WebSocket webSocket,
587                                               int statusCode,
588                                               String reason) {
589                 actual.complete(collectedStrings);
590                 return null;
591             }
592 
593             @Override
594             public void onError(WebSocket webSocket, Throwable error) {
595                 actual.completeExceptionally(error);
596             }
597         };
598 
599         webSocket = newBuilder()
600                 .proxy(NO_PROXY)
601                 .authenticator(new WSAuthenticator())
602                 .build().newWebSocketBuilder()
603                 .buildAsync(server.getURI(), listener)
604                 .join();
605 
606         List&lt;String&gt; a = actual.join();
607         assertEquals(a, expected);
608 
609         server.close();
610     }
611 
612     /*
613      * Exercises the scenario where requests for more messages are made prior to
614      * completing the returned CompletionStage instances.
615      */
616     @Test(dataProvider = &quot;servers&quot;)
617     public void aggregatingTextMessages
618         (Function&lt;int[],DummyWebSocketServer&gt; serverSupplier)
619         throws IOException
620     {
621         List&lt;String&gt; expected = List.of(&quot;alpha&quot;, &quot;beta&quot;, &quot;gamma&quot;, &quot;delta&quot;);
622 
623         int[] binary = new int[]{
624                 0x81, 0x05, 0x61, 0x6c, 0x70, 0x68, 0x61, // &quot;alpha&quot;
625                 0x01, 0x02, 0x62, 0x65,                   // &quot;be
626                 0x80, 0x02, 0x74, 0x61,                   // ta&quot;
627                 0x01, 0x01, 0x67,                         // &quot;g
628                 0x00, 0x01, 0x61,                         // a
629                 0x00, 0x00,                               //
630                 0x00, 0x00,                               //
631                 0x00, 0x01, 0x6d,                         // m
632                 0x00, 0x01, 0x6d,                         // m
633                 0x80, 0x01, 0x61,                         // a&quot;
634                 0x8a, 0x00,                               // &lt;PONG&gt;
635                 0x01, 0x04, 0x64, 0x65, 0x6c, 0x74,       // &quot;delt
636                 0x00, 0x01, 0x61,                         // a
637                 0x80, 0x00,                               // &quot;
638                 0x88, 0x00                                // &lt;CLOSE&gt;
639         };
640         CompletableFuture&lt;List&lt;String&gt;&gt; actual = new CompletableFuture&lt;&gt;();
641 
642         server = serverSupplier.apply(binary);
643         server.open();
644 
645         WebSocket.Listener listener = new WebSocket.Listener() {
646 
647             List&lt;CharSequence&gt; parts = new ArrayList&lt;&gt;();
648             /*
649              * A CompletableFuture which will complete once the current
650              * message has been fully assembled. Until then the listener
651              * returns this instance for every call.
652              */
653             CompletableFuture&lt;?&gt; currentCf = new CompletableFuture&lt;&gt;();
654             List&lt;String&gt; collected = new ArrayList&lt;&gt;();
655 
656             @Override
657             public CompletionStage&lt;?&gt; onText(WebSocket webSocket,
658                                              CharSequence message,
659                                              boolean last) {
660                 parts.add(message);
661                 if (!last) {
662                     webSocket.request(1);
663                 } else {
664                     this.currentCf.thenRun(() -&gt; webSocket.request(1));
665                     CompletableFuture&lt;?&gt; refCf = this.currentCf;
666                     processWholeMessage(new ArrayList&lt;&gt;(parts), refCf);
667                     currentCf = new CompletableFuture&lt;&gt;();
668                     parts.clear();
669                     return refCf;
670                 }
671                 return currentCf;
672             }
673 
674             @Override
675             public CompletionStage&lt;?&gt; onClose(WebSocket webSocket,
676                                               int statusCode,
677                                               String reason) {
678                 actual.complete(collected);
679                 return null;
680             }
681 
682             @Override
683             public void onError(WebSocket webSocket, Throwable error) {
684                 actual.completeExceptionally(error);
685             }
686 
687             public void processWholeMessage(List&lt;CharSequence&gt; data,
688                                             CompletableFuture&lt;?&gt; cf) {
689                 StringBuilder b = new StringBuilder();
690                 data.forEach(b::append);
691                 String s = b.toString();
692                 System.out.println(s);
693                 cf.complete(null);
694                 collected.add(s);
695             }
696         };
697 
698         webSocket = newBuilder()
699                 .proxy(NO_PROXY)
700                 .authenticator(new WSAuthenticator())
701                 .build().newWebSocketBuilder()
702                 .buildAsync(server.getURI(), listener)
703                 .join();
704 
705         List&lt;String&gt; a = actual.join();
706         assertEquals(a, expected);
707 
708         server.close();
709     }
710 
711     // -- authentication specific tests
712 
713     /*
714      * Ensures authentication succeeds when an Authenticator set on client builder.
715      */
716     @Test
717     public void clientAuthenticate() throws IOException  {
718         try (var server = new DummyWebSocketServer(USERNAME, PASSWORD)){
719             server.open();
720 
721             var webSocket = newBuilder()
722                     .proxy(NO_PROXY)
723                     .authenticator(new WSAuthenticator())
724                     .build()
725                     .newWebSocketBuilder()
726                     .buildAsync(server.getURI(), new WebSocket.Listener() { })
727                     .join();
728         }
729     }
730 
731     /*
732      * Ensures authentication succeeds when an `Authorization` header is explicitly set.
733      */
734     @Test
735     public void explicitAuthenticate() throws IOException  {
736         try (var server = new DummyWebSocketServer(USERNAME, PASSWORD)) {
737             server.open();
738 
739             String hv = &quot;Basic &quot; + Base64.getEncoder().encodeToString(
740                     (USERNAME + &quot;:&quot; + PASSWORD).getBytes(UTF_8));
741 
742             var webSocket = newBuilder()
743                     .proxy(NO_PROXY).build()
744                     .newWebSocketBuilder()
745                     .header(&quot;Authorization&quot;, hv)
746                     .buildAsync(server.getURI(), new WebSocket.Listener() { })
747                     .join();
748         }
749     }
750 
751     /*
752      * Ensures authentication does not succeed when no authenticator is present.
753      */
754     @Test
755     public void failNoAuthenticator() throws IOException  {
756         try (var server = new DummyWebSocketServer(USERNAME, PASSWORD)) {
757             server.open();
758 
759             CompletableFuture&lt;WebSocket&gt; cf = newBuilder()
760                     .proxy(NO_PROXY).build()
761                     .newWebSocketBuilder()
762                     .buildAsync(server.getURI(), new WebSocket.Listener() { });
763 
764             try {
765                 var webSocket = cf.join();
766                 fail(&quot;Expected exception not thrown&quot;);
767             } catch (CompletionException expected) {
768                 WebSocketHandshakeException e = (WebSocketHandshakeException)expected.getCause();
769                 HttpResponse&lt;?&gt; response = e.getResponse();
770                 assertEquals(response.statusCode(), 401);
771             }
772         }
773     }
774 
775     /*
776      * Ensures authentication does not succeed when the authenticator presents
777      * unauthorized credentials.
778      */
779     @Test
780     public void failBadCredentials() throws IOException  {
781         try (var server = new DummyWebSocketServer(USERNAME, PASSWORD)) {
782             server.open();
783 
784             Authenticator authenticator = new Authenticator() {
785                 @Override protected PasswordAuthentication getPasswordAuthentication() {
786                     return new PasswordAuthentication(&quot;BAD&quot;+USERNAME, &quot;&quot;.toCharArray());
787                 }
788             };
789 
790             CompletableFuture&lt;WebSocket&gt; cf = newBuilder()
791                     .proxy(NO_PROXY)
792                     .authenticator(authenticator)
793                     .build()
794                     .newWebSocketBuilder()
795                     .buildAsync(server.getURI(), new WebSocket.Listener() { });
796 
797             try {
798                 var webSocket = cf.join();
799                 fail(&quot;Expected exception not thrown&quot;);
800             } catch (CompletionException expected) {
801                 System.out.println(&quot;caught expected exception:&quot; + expected);
802             }
803         }
804     }
805 }
    </pre>
  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff test/jdk/java/net/httpclient/HttpsTunnelTest.java</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
<body>
<center><a href="HttpResponseInputStreamTest.java.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="LargeResponseContent.java.cdiff.html" target="_top">next &gt;</a></center>    <h2>test/jdk/java/net/httpclient/HttpsTunnelTest.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 1,7 ***</span>
  /*
<span class="line-modified">!  * Copyright (c) 2018, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.
<span class="line-new-header">--- 1,7 ---</span>
  /*
<span class="line-modified">!  * Copyright (c) 2018, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 45,22 ***</span>
   * @test
   * @summary This test verifies that if an h2 connection going through a
   *          proxy P is downgraded to HTTP/1.1, then a new h2 request
   *          going to a different host through the same proxy will not
   *          be preemptively downgraded. That, is the stack should attempt
<span class="line-modified">!  *          a new h2 connection to the new host.</span>
<span class="line-modified">!  * @bug 8196967</span>
   * @library /test/lib http2/server
   * @build jdk.test.lib.net.SimpleSSLContext HttpServerAdapters DigestEchoServer HttpsTunnelTest
   * @modules java.net.http/jdk.internal.net.http.common
   *          java.net.http/jdk.internal.net.http.frame
   *          java.net.http/jdk.internal.net.http.hpack
   *          java.logging
   *          java.base/sun.net.www.http
   *          java.base/sun.net.www
   *          java.base/sun.net
<span class="line-modified">!  * @run main/othervm -Djdk.internal.httpclient.debug=true HttpsTunnelTest</span>
   */
  
  public class HttpsTunnelTest implements HttpServerAdapters {
  
      static final String data[] = {
<span class="line-new-header">--- 45,30 ---</span>
   * @test
   * @summary This test verifies that if an h2 connection going through a
   *          proxy P is downgraded to HTTP/1.1, then a new h2 request
   *          going to a different host through the same proxy will not
   *          be preemptively downgraded. That, is the stack should attempt
<span class="line-modified">!  *          a new h2 connection to the new host. It also verifies that</span>
<span class="line-modified">!  *          the stack sends the appropriate &quot;host&quot; header to the proxy.</span>
<span class="line-added">+  * @bug 8196967 8222527</span>
   * @library /test/lib http2/server
   * @build jdk.test.lib.net.SimpleSSLContext HttpServerAdapters DigestEchoServer HttpsTunnelTest
   * @modules java.net.http/jdk.internal.net.http.common
   *          java.net.http/jdk.internal.net.http.frame
   *          java.net.http/jdk.internal.net.http.hpack
   *          java.logging
   *          java.base/sun.net.www.http
   *          java.base/sun.net.www
   *          java.base/sun.net
<span class="line-modified">!  * @run main/othervm -Dtest.requiresHost=true</span>
<span class="line-added">+  *                   -Djdk.httpclient.HttpClient.log=headers</span>
<span class="line-added">+  *                   -Djdk.internal.httpclient.debug=true HttpsTunnelTest</span>
<span class="line-added">+  * @run main/othervm -Dtest.requiresHost=true</span>
<span class="line-added">+  *                   -Djdk.httpclient.allowRestrictedHeaders=host</span>
<span class="line-added">+  *                   -Djdk.httpclient.HttpClient.log=headers</span>
<span class="line-added">+  *                   -Djdk.internal.httpclient.debug=true HttpsTunnelTest</span>
<span class="line-added">+  *</span>
   */
  
  public class HttpsTunnelTest implements HttpServerAdapters {
  
      static final String data[] = {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 114,25 ***</span>
                  DigestEchoServer.HttpAuthSchemeType.NONE);
  
          try {
              URI uri1 = new URI(&quot;https://&quot; + http1Server.serverAuthority() + &quot;/foo/https1&quot;);
              URI uri2 = new URI(&quot;https://&quot; + http2Server.serverAuthority() + &quot;/foo/https2&quot;);
              ProxySelector ps = ProxySelector.of(proxy.getProxyAddress());
                      //HttpClient.Builder.NO_PROXY;
              HttpsTunnelTest test = new HttpsTunnelTest();
              HttpClient client = test.newHttpClient(ps);
              out.println(&quot;Proxy is: &quot; + ps.select(uri2));
  
              List&lt;String&gt; lines = List.of(Arrays.copyOfRange(data, 0, data.length));
              assert lines.size() == data.length;
              String body = lines.stream().collect(Collectors.joining(&quot;\r\n&quot;));
              HttpRequest.BodyPublisher reqBody = HttpRequest.BodyPublishers.ofString(body);
<span class="line-modified">!             HttpRequest req1 = HttpRequest</span>
                      .newBuilder(uri1)
                      .version(Version.HTTP_2)
<span class="line-modified">!                     .POST(reqBody)</span>
<span class="line-modified">!                     .build();</span>
              out.println(&quot;\nPosting to HTTP/1.1 server at: &quot; + req1);
              HttpResponse&lt;Stream&lt;String&gt;&gt; response = client.send(req1, BodyHandlers.ofLines());
              out.println(&quot;Checking response...&quot;);
              if (response.statusCode() != 200) {
                  throw new RuntimeException(&quot;Unexpected status code: &quot; + response);
<span class="line-new-header">--- 122,38 ---</span>
                  DigestEchoServer.HttpAuthSchemeType.NONE);
  
          try {
              URI uri1 = new URI(&quot;https://&quot; + http1Server.serverAuthority() + &quot;/foo/https1&quot;);
              URI uri2 = new URI(&quot;https://&quot; + http2Server.serverAuthority() + &quot;/foo/https2&quot;);
<span class="line-added">+ </span>
<span class="line-added">+             boolean provideCustomHost = &quot;host&quot;.equalsIgnoreCase(</span>
<span class="line-added">+                     System.getProperty(&quot;jdk.httpclient.allowRestrictedHeaders&quot;,&quot;&quot;));</span>
<span class="line-added">+ </span>
<span class="line-added">+             String customHttp1Host = null, customHttp2Host = null;</span>
<span class="line-added">+             if (provideCustomHost) {</span>
<span class="line-added">+                 customHttp1Host = makeCustomHostString(http1Server, uri1);</span>
<span class="line-added">+                 out.println(&quot;HTTP/1.1: &lt;&quot; + uri1 + &quot;&gt; [custom host: &quot; + customHttp1Host + &quot;]&quot;);</span>
<span class="line-added">+                 customHttp2Host = makeCustomHostString(http2Server, uri2);</span>
<span class="line-added">+                 out.println(&quot;HTTP/2:   &lt;&quot; + uri2 + &quot;&gt; [custom host: &quot; + customHttp2Host + &quot;]&quot;);</span>
<span class="line-added">+             }</span>
<span class="line-added">+ </span>
              ProxySelector ps = ProxySelector.of(proxy.getProxyAddress());
                      //HttpClient.Builder.NO_PROXY;
              HttpsTunnelTest test = new HttpsTunnelTest();
              HttpClient client = test.newHttpClient(ps);
              out.println(&quot;Proxy is: &quot; + ps.select(uri2));
  
              List&lt;String&gt; lines = List.of(Arrays.copyOfRange(data, 0, data.length));
              assert lines.size() == data.length;
              String body = lines.stream().collect(Collectors.joining(&quot;\r\n&quot;));
              HttpRequest.BodyPublisher reqBody = HttpRequest.BodyPublishers.ofString(body);
<span class="line-modified">!             HttpRequest.Builder req1Builder = HttpRequest</span>
                      .newBuilder(uri1)
                      .version(Version.HTTP_2)
<span class="line-modified">!                     .POST(reqBody);</span>
<span class="line-modified">!             if (provideCustomHost) req1Builder.header(&quot;host&quot;, customHttp1Host);</span>
<span class="line-added">+             HttpRequest req1 = req1Builder.build();</span>
              out.println(&quot;\nPosting to HTTP/1.1 server at: &quot; + req1);
              HttpResponse&lt;Stream&lt;String&gt;&gt; response = client.send(req1, BodyHandlers.ofLines());
              out.println(&quot;Checking response...&quot;);
              if (response.statusCode() != 200) {
                  throw new RuntimeException(&quot;Unexpected status code: &quot; + response);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 143,16 ***</span>
              }
              List&lt;String&gt; respLines = response.body().collect(Collectors.toList());
              if (!lines.equals(respLines)) {
                  throw new RuntimeException(&quot;Unexpected response 1: &quot; + respLines);
              }
              HttpRequest.BodyPublisher reqBody2 = HttpRequest.BodyPublishers.ofString(body);
<span class="line-modified">!             HttpRequest req2 = HttpRequest</span>
                      .newBuilder(uri2)
                      .version(Version.HTTP_2)
<span class="line-modified">!                     .POST(reqBody2)</span>
<span class="line-modified">!                     .build();</span>
              out.println(&quot;\nPosting to HTTP/2 server at: &quot; + req2);
              response = client.send(req2, BodyHandlers.ofLines());
              out.println(&quot;Checking response...&quot;);
              if (response.statusCode() != 200) {
                  throw new RuntimeException(&quot;Unexpected status code: &quot; + response);
<span class="line-new-header">--- 164,18 ---</span>
              }
              List&lt;String&gt; respLines = response.body().collect(Collectors.toList());
              if (!lines.equals(respLines)) {
                  throw new RuntimeException(&quot;Unexpected response 1: &quot; + respLines);
              }
<span class="line-added">+ </span>
              HttpRequest.BodyPublisher reqBody2 = HttpRequest.BodyPublishers.ofString(body);
<span class="line-modified">!             HttpRequest.Builder req2Builder = HttpRequest</span>
                      .newBuilder(uri2)
                      .version(Version.HTTP_2)
<span class="line-modified">!                     .POST(reqBody2);</span>
<span class="line-modified">!             if (provideCustomHost) req2Builder.header(&quot;host&quot;, customHttp2Host);</span>
<span class="line-added">+             HttpRequest req2 = req2Builder.build();</span>
              out.println(&quot;\nPosting to HTTP/2 server at: &quot; + req2);
              response = client.send(req2, BodyHandlers.ofLines());
              out.println(&quot;Checking response...&quot;);
              if (response.statusCode() != 200) {
                  throw new RuntimeException(&quot;Unexpected status code: &quot; + response);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 174,6 ***</span>
<span class="line-new-header">--- 197,28 ---</span>
              http1Server.stop();
              http2Server.stop();
          }
      }
  
<span class="line-added">+     /**</span>
<span class="line-added">+      * Builds a custom host string that is different to what is in the URI</span>
<span class="line-added">+      * authority, that is textually different than what the stack would</span>
<span class="line-added">+      * send. For CONNECT we should ignore any custom host settings.</span>
<span class="line-added">+      * The tunnelling proxy will fail with badRequest 400 if it receives</span>
<span class="line-added">+      * the custom host instead of the expected URI authority string.</span>
<span class="line-added">+      * @param  server The target server.</span>
<span class="line-added">+      * @param  uri    The URI to the target server</span>
<span class="line-added">+      * @return a host value for the custom host header.</span>
<span class="line-added">+      */</span>
<span class="line-added">+     static final String makeCustomHostString(HttpTestServer server, URI uri) {</span>
<span class="line-added">+         String customHttpHost;</span>
<span class="line-added">+         if (server.serverAuthority().contains(&quot;localhost&quot;)) {</span>
<span class="line-added">+             customHttpHost = InetAddress.getLoopbackAddress().getHostAddress();</span>
<span class="line-added">+         } else {</span>
<span class="line-added">+             customHttpHost = InetAddress.getLoopbackAddress().getHostName();</span>
<span class="line-added">+         }</span>
<span class="line-added">+         if (customHttpHost.contains(&quot;:&quot;)) customHttpHost = &quot;[&quot; + customHttpHost + &quot;]&quot;;</span>
<span class="line-added">+         if (uri.getPort() != -1) customHttpHost = customHttpHost + &quot;:&quot; + uri.getPort();</span>
<span class="line-added">+         return customHttpHost;</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
  }
</pre>
<center><a href="HttpResponseInputStreamTest.java.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="LargeResponseContent.java.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
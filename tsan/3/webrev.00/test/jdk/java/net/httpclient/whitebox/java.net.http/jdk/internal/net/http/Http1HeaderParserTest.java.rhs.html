<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames test/jdk/java/net/httpclient/whitebox/java.net.http/jdk/internal/net/http/Http1HeaderParserTest.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (c) 2017, 2018, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 package jdk.internal.net.http;
 25 
 26 import java.io.ByteArrayInputStream;
 27 import java.net.ProtocolException;
 28 import java.nio.ByteBuffer;
 29 import java.util.ArrayList;
 30 import java.util.Arrays;
 31 import java.util.Collections;
 32 import java.util.HashMap;
 33 import java.util.List;
 34 import java.util.Map;
 35 import java.util.concurrent.atomic.AtomicBoolean;
 36 import java.util.concurrent.atomic.AtomicInteger;
 37 import java.util.stream.IntStream;
 38 import sun.net.www.MessageHeader;
 39 import org.testng.annotations.Test;
 40 import org.testng.annotations.DataProvider;
 41 import static java.lang.System.out;
 42 import static java.lang.String.format;
 43 import static java.nio.charset.StandardCharsets.US_ASCII;
 44 import static java.util.stream.Collectors.toList;
 45 import static org.testng.Assert.*;
 46 
 47 // Mostly verifies the &quot;new&quot; Http1HeaderParser returns the same results as the
 48 // tried and tested sun.net.www.MessageHeader.
 49 
 50 public class Http1HeaderParserTest {
 51 
 52     @DataProvider(name = &quot;responses&quot;)
 53     public Object[][] responses() {
 54         List&lt;String&gt; responses = new ArrayList&lt;&gt;();
 55 
 56         String[] basic =
 57             { &quot;HTTP/1.1 200 OK\r\n\r\n&quot;,
 58 
 59               &quot;HTTP/1.1 200 OK\r\n&quot; +
 60               &quot;Date: Mon, 15 Jan 2001 12:18:21 GMT\r\n&quot; +
 61               &quot;Server: Apache/1.3.14 (Unix)\r\n&quot; +
 62               &quot;Connection: close\r\n&quot; +
 63               &quot;Content-Type: text/html; charset=iso-8859-1\r\n&quot; +
 64               &quot;Content-Length: 10\r\n\r\n&quot; +
 65               &quot;123456789&quot;,
 66 
 67               &quot;HTTP/1.1 200 OK\r\n&quot; +
 68               &quot;Content-Length: 9\r\n&quot; +
 69               &quot;Content-Type: text/html; charset=UTF-8\r\n\r\n&quot; +
 70               &quot;XXXXX&quot;,
 71 
 72               &quot;HTTP/1.1 200 OK\r\n&quot; +
 73               &quot;Content-Length:   9\r\n&quot; +
 74               &quot;Content-Type:   text/html; charset=UTF-8\r\n\r\n&quot; +   // more than one SP after &#39;:&#39;
 75               &quot;XXXXX&quot;,
 76 
 77               &quot;HTTP/1.1 200 OK\r\n&quot; +
 78               &quot;Content-Length:\t10\r\n&quot; +
 79               &quot;Content-Type:\ttext/html; charset=UTF-8\r\n\r\n&quot; +   // HT separator
 80               &quot;XXXXX&quot;,
 81 
 82               &quot;HTTP/1.1 200 OK\r\n&quot; +
 83               &quot;Content-Length:\t\t10\r\n&quot; +
 84               &quot;Content-Type:\t\ttext/html; charset=UTF-8\r\n\r\n&quot; +   // more than one HT after &#39;:&#39;
 85               &quot;XXXXX&quot;,
 86 
 87               &quot;HTTP/1.1 407 Proxy Authorization Required\r\n&quot; +
 88               &quot;Proxy-Authenticate: Basic realm=\&quot;a fake realm\&quot;\r\n\r\n&quot;,
 89 
 90               &quot;HTTP/1.1 401 Unauthorized\r\n&quot; +
 91               &quot;WWW-Authenticate: Digest realm=\&quot;wally land\&quot; domain=/ &quot; +
 92               &quot;nonce=\&quot;2B7F3A2B\&quot; qop=\&quot;auth\&quot;\r\n\r\n&quot;,
 93 
 94               &quot;HTTP/1.1 200 OK\r\n&quot; +
 95               &quot;X-Foo:\r\n\r\n&quot;,      // no value
 96 
 97               &quot;HTTP/1.1 200 OK\r\n&quot; +
 98               &quot;X-Foo:\r\n\r\n&quot; +     // no value, with response body
 99               &quot;Some Response Body&quot;,
100 
101               &quot;HTTP/1.1 200 OK\r\n&quot; +
102               &quot;X-Foo:\r\n&quot; +    // no value, followed by another header
103               &quot;Content-Length: 10\r\n\r\n&quot; +
104               &quot;Some Response Body&quot;,
105 
106               &quot;HTTP/1.1 200 OK\r\n&quot; +
107               &quot;X-Foo:\r\n&quot; +    // no value, followed by another header, with response body
108               &quot;Content-Length: 10\r\n\r\n&quot;,
109 
110               &quot;HTTP/1.1 200 OK\r\n&quot; +
111               &quot;X-Foo: chegar\r\n&quot; +
112               &quot;X-Foo: dfuchs\r\n&quot; +  // same header appears multiple times
113               &quot;Content-Length: 0\r\n&quot; +
114               &quot;X-Foo: michaelm\r\n&quot; +
115               &quot;X-Foo: prappo\r\n\r\n&quot;,
116 
117               &quot;HTTP/1.1 200 OK\r\n&quot; +
118               &quot;X-Foo:\r\n&quot; +    // no value, same header appears multiple times
119               &quot;X-Foo: dfuchs\r\n&quot; +
120               &quot;Content-Length: 0\r\n&quot; +
121               &quot;X-Foo: michaelm\r\n&quot; +
122               &quot;X-Foo: prappo\r\n\r\n&quot;,
123 
124               &quot;HTTP/1.1 200 OK\r\n&quot; +
125               &quot;Accept-Ranges: bytes\r\n&quot; +
126               &quot;Cache-control: max-age=0, no-cache=\&quot;set-cookie\&quot;\r\n&quot; +
127               &quot;Content-Length: 132868\r\n&quot; +
128               &quot;Content-Type: text/html; charset=UTF-8\r\n&quot; +
129               &quot;Date: Sun, 05 Nov 2017 22:24:03 GMT\r\n&quot; +
130               &quot;Server: Apache/2.4.6 (Red Hat Enterprise Linux) OpenSSL/1.0.1e-fips Communique/4.2.2\r\n&quot; +
131               &quot;Set-Cookie: AWSELB=AF7927F5100F4202119876ED2436B5005EE;PATH=/;MAX-AGE=900\r\n&quot; +
132               &quot;Vary: Host,Accept-Encoding,User-Agent\r\n&quot; +
133               &quot;X-Mod-Pagespeed: 1.12.34.2-0\r\n&quot; +
134               &quot;Connection: keep-alive\r\n\r\n&quot;
135             };
136         Arrays.stream(basic).forEach(responses::add);
137         // add some tests where some of the CRLF are replaced
138         // by a single LF
139         Arrays.stream(basic)
140                 .map(Http1HeaderParserTest::mixedCRLF)
141                 .forEach(responses::add);
142 
143         String[] foldingTemplate =
144            {  &quot;HTTP/1.1 200 OK\r\n&quot; +
145               &quot;Content-Length: 9\r\n&quot; +
146               &quot;Content-Type: text/html;$NEWLINE&quot; +  // folding field-value with &#39;\n&#39;|&#39;\r&#39;
147               &quot; charset=UTF-8\r\n&quot; +                // one preceding SP
148               &quot;Connection: close\r\n\r\n&quot; +
149               &quot;XXYYZZAABBCCDDEE&quot;,
150 
151               &quot;HTTP/1.1 200 OK\r\n&quot; +
152               &quot;Content-Length: 19\r\n&quot; +
153               &quot;Content-Type: text/html;$NEWLINE&quot; +  // folding field-value with &#39;\n&#39;|&#39;\r
154               &quot;   charset=UTF-8\r\n&quot; +              // more than one preceding SP
155               &quot;Connection: keep-alive\r\n\r\n&quot; +
156               &quot;XXYYZZAABBCCDDEEFFGG&quot;,
157 
158               &quot;HTTP/1.1 200 OK\r\n&quot; +
159               &quot;Content-Length: 999\r\n&quot; +
160               &quot;Content-Type: text/html;$NEWLINE&quot; +  // folding field-value with &#39;\n&#39;|&#39;\r
161               &quot;\tcharset=UTF-8\r\n&quot; +               // one preceding HT
162               &quot;Connection: close\r\n\r\n&quot; +
163               &quot;XXYYZZAABBCCDDEE&quot;,
164 
165               &quot;HTTP/1.1 200 OK\r\n&quot; +
166               &quot;Content-Length: 54\r\n&quot; +
167               &quot;Content-Type: text/html;$NEWLINE&quot; +  // folding field-value with &#39;\n&#39;|&#39;\r
168               &quot;\t\t\tcharset=UTF-8\r\n&quot; +           // more than one preceding HT
169               &quot;Connection: keep-alive\r\n\r\n&quot; +
170               &quot;XXYYZZAABBCCDDEEFFGG&quot;,
171 
172               &quot;HTTP/1.1 200 OK\r\n&quot; +
173               &quot;Content-Length: -1\r\n&quot; +
174               &quot;Content-Type: text/html;$NEWLINE&quot; +  // folding field-value with &#39;\n&#39;|&#39;\r
175               &quot;\t \t \tcharset=UTF-8\r\n&quot; +         // mix of preceding HT and SP
176               &quot;Connection: keep-alive\r\n\r\n&quot; +
177               &quot;XXYYZZAABBCCDDEEFFGGHH&quot;,
178 
179               &quot;HTTP/1.1 200 OK\r\n&quot; +
180               &quot;Content-Length: 65\r\n&quot; +
181               &quot;Content-Type: text/html;$NEWLINE&quot; +  // folding field-value with &#39;\n&#39;|&#39;\r
182               &quot; \t \t charset=UTF-8\r\n&quot; +          // mix of preceding SP and HT
183               &quot;Connection: keep-alive\r\n\r\n&quot; +
184               &quot;XXYYZZAABBCCDDEEFFGGHHII&quot;,
185 
186               &quot;HTTP/1.1 401 Unauthorized\r\n&quot; +
187               &quot;WWW-Authenticate: Digest realm=\&quot;wally land\&quot;,&quot;
188                       +&quot;$NEWLINE    domain=/,&quot;
189                       +&quot;$NEWLINE nonce=\&quot;2B7F3A2B\&quot;,&quot;
190                       +&quot;$NEWLINE\tqop=\&quot;auth\&quot;\r\n\r\n&quot;,
191 
192            };
193         for (String newLineChar : new String[] { &quot;\n&quot;, &quot;\r&quot;, &quot;\r\n&quot; }) {
194             for (String template : foldingTemplate)
195                 responses.add(template.replace(&quot;$NEWLINE&quot;, newLineChar));
196         }
197         // add some tests where some of the CRLF are replaced
198         // by a single LF
199         for (String newLineChar : new String[] { &quot;\n&quot;, &quot;\r&quot;, &quot;\r\n&quot; }) {
200             for (String template : foldingTemplate)
201                 responses.add(mixedCRLF(template).replace(&quot;$NEWLINE&quot;, newLineChar));
202         }
203 
204         String[] bad = // much of this is to retain parity with legacy MessageHeaders
205            { &quot;HTTP/1.1 200 OK\r\n&quot; +
206              &quot;Connection:\r\n\r\n&quot;,   // empty value, no body
207 
208              &quot;HTTP/1.1 200 OK\r\n&quot; +
209              &quot;Connection:\r\n\r\n&quot; +  // empty value, with body
210              &quot;XXXXX&quot;,
211 
212              &quot;HTTP/1.1 200 OK\r\n&quot; +
213              &quot;: no header\r\n\r\n&quot;,  // no/empty header-name, no body, no following header
214 
215              &quot;HTTP/1.1 200 OK\r\n&quot; +
216              &quot;: no; header\r\n&quot; +  // no/empty header-name, no body, following header
217              &quot;Content-Length: 65\r\n\r\n&quot;,
218 
219              &quot;HTTP/1.1 200 OK\r\n&quot; +
220              &quot;: no header\r\n&quot; +  // no/empty header-name
221              &quot;Content-Length: 65\r\n\r\n&quot; +
222              &quot;XXXXX&quot;,
223 
224              &quot;HTTP/1.1 200 OK\r\n&quot; +
225              &quot;: no header\r\n\r\n&quot; +  // no/empty header-name, followed by header
226              &quot;XXXXX&quot;,
227 
228              &quot;HTTP/1.1 200 OK\r\n&quot; +
229              &quot;Conte\r&quot; +
230              &quot; nt-Length: 9\r\n&quot; +    // fold/bad header name ???
231              &quot;Content-Type: text/html; charset=UTF-8\r\n\r\n&quot; +
232              &quot;XXXXX&quot;,
233 
234              &quot;HTTP/1.1 200 OK\r\n&quot; +
235              &quot;Conte\r&quot; +
236              &quot;nt-Length: 9\r\n&quot; +    // fold/bad header name ??? without preceding space
237              &quot;Content-Type: text/html; charset=UTF-8\r\n\r\n&quot; +
238              &quot;XXXXXYYZZ&quot;,
239 
240              &quot;HTTP/1.0 404 Not Found\r\n&quot; +
241              &quot;header-without-colon\r\n\r\n&quot;,
242 
243              &quot;HTTP/1.0 404 Not Found\r\n&quot; +
244              &quot;header-without-colon\r\n\r\n&quot; +
245              &quot;SOMEBODY&quot;,
246 
247            };
248         Arrays.stream(bad).forEach(responses::add);
249 
250         return responses.stream().map(p -&gt; new Object[] { p }).toArray(Object[][]::new);
251     }
252 
253     static final AtomicInteger index = new AtomicInteger();
254     static final AtomicInteger limit = new AtomicInteger(1);
255     static final AtomicBoolean useCRLF = new AtomicBoolean();
256     // A small method to replace part of the CRLF present in a string
257     // with simple LF. The method uses a deterministic algorithm based
258     // on current values of static index/limit/useCRLF counters.
259     // These counters are used to produce a stream of substitutes that
260     // looks like this:
261     // LF CRLF LF LF CRLF CRLF LF LF LF CRLF CRLF CRLF (then repeat from start)
262     static final String mixedCRLF(String headers) {
263         int next;
264         int start = 0;
265         int last = headers.lastIndexOf(&quot;\r\n&quot;);
266         String prev = &quot;&quot;;
267         StringBuilder res = new StringBuilder();
268         while ((next = headers.indexOf(&quot;\r\n&quot;, start)) &gt; 0) {
269             res.append(headers.substring(start, next));
270             if (&quot;\n&quot;.equals(prev) &amp;&amp; next == last) {
271                 // for some reason the legacy MessageHeader parser will
272                 // not consume the final LF if the headers are terminated
273                 // by &lt;LF&gt;&lt;CRLF&gt; instead of &lt;CRLF&gt;&lt;CRLF&gt;. It consume
274                 // &lt;LF&gt;&lt;CR&gt; but leaves the last &lt;LF&gt; in the stream.
275                 // Here we just make sure to avoid using &lt;LF&gt;&lt;CRLF&gt;
276                 // as that would cause the legacy parser to consume
277                 // 1 byte less than the Http1HeadersParser - which
278                 // does consume the last &lt;LF&gt;, as it should.
279                 // if this is the last CRLF and the previous one
280                 // was replaced by LF then use LF.
281                 res.append(prev);
282             } else {
283                 prev = useCRLF.get() ? &quot;\r\n&quot; : &quot;\n&quot;;
284                 res.append(prev);
285             }
286             // skip CRLF
287             start = next + 2;
288 
289             // The idea is to substitute some of the CRLF with LF.
290             // Rather than doing this randomly, always use the following
291             // sequence:
292             // LF CRLF LF LF CRLF CRLF LF LF LF CRLF CRLF CRLF
293             index.incrementAndGet();
294             if (index.get() == limit.get()) {
295                 index.set(0);
296                 if (useCRLF.get()) limit.incrementAndGet();
297                 if (limit.get() &gt; 3) limit.set(1);
298                 useCRLF.set(!useCRLF.get());
299             }
300         }
301         res.append(headers.substring(start));
302         return res.toString();
303     }
304 
305 
306     @Test(dataProvider = &quot;responses&quot;)
307     public void verifyHeaders(String respString) throws Exception {
308         System.out.println(&quot;\ntesting:\n\t&quot; + respString
309                 .replace(&quot;\r\n&quot;, &quot;&lt;CRLF&gt;&quot;)
310                 .replace(&quot;\r&quot;, &quot;&lt;CR&gt;&quot;)
311                 .replace(&quot;\n&quot;,&quot;&lt;LF&gt;&quot;)
312                 .replace(&quot;LF&gt;&quot;, &quot;LF&gt;\n\t&quot;));
313         byte[] bytes = respString.getBytes(US_ASCII);
314         ByteArrayInputStream bais = new ByteArrayInputStream(bytes);
315         MessageHeader m = new MessageHeader(bais);
316         Map&lt;String,List&lt;String&gt;&gt; messageHeaderMap = m.getHeaders();
317         int availableBytes = bais.available();
318 
319         Http1HeaderParser decoder = new Http1HeaderParser();
320         ByteBuffer b = ByteBuffer.wrap(bytes);
321         decoder.parse(b);
322         System.out.printf(&quot;Http1HeaderParser parsed %d bytes out of %d%n&quot;, b.position(), bytes.length);
323         Map&lt;String,List&lt;String&gt;&gt; decoderMap1 = decoder.headers().map();
324 
325         // assert status-line
326         String statusLine1 = messageHeaderMap.get(null).get(0);
327         String statusLine2 = decoder.statusLine();
328         if (statusLine1.startsWith(&quot;HTTP&quot;)) {// skip the case where MH&#39;s messes up the status-line
329             assertEquals(statusLine1, statusLine2, &quot;Status-line not equal&quot;);
330         } else {
331             assertTrue(statusLine2.startsWith(&quot;HTTP/1.&quot;), &quot;Status-line not HTTP/1.&quot;);
332         }
333 
334         // remove the null&#39;th entry with is the status-line
335         Map&lt;String,List&lt;String&gt;&gt; map = new HashMap&lt;&gt;();
336         for (Map.Entry&lt;String,List&lt;String&gt;&gt; e : messageHeaderMap.entrySet()) {
337             if (e.getKey() != null) {
338                 map.put(e.getKey(), e.getValue());
339             }
340         }
341         messageHeaderMap = map;
342 
343         assertHeadersEqual(messageHeaderMap, decoderMap1,
344                           &quot;messageHeaderMap not equal to decoderMap1&quot;);
345 
346         assertEquals(availableBytes, b.remaining(),
347                 String.format(&quot;stream available (%d) not equal to remaining (%d)&quot;,
348                         availableBytes, b.remaining()));
349         // byte at a time
350         decoder = new Http1HeaderParser();
351         List&lt;ByteBuffer&gt; buffers = IntStream.range(0, bytes.length)
352                 .mapToObj(i -&gt; ByteBuffer.wrap(bytes, i, 1))
353                 .collect(toList());
354         while (decoder.parse(buffers.remove(0)) != true);
355         Map&lt;String,List&lt;String&gt;&gt; decoderMap2 = decoder.headers().map();
356         assertEquals(availableBytes, buffers.size(),
357                      &quot;stream available not equals to remaining buffers&quot;);
358         assertEquals(decoderMap1, decoderMap2, &quot;decoder maps not equal&quot;);
359 
360     }
361 
362     @DataProvider(name = &quot;errors&quot;)
363     public Object[][] errors() {
364         List&lt;String&gt; responses = new ArrayList&lt;&gt;();
365 
366         // These responses are parsed, somewhat, by MessageHeaders but give
367         // nonsensible results. They, correctly, fail with the Http1HeaderParser.
368         String[] bad =
369            {// &quot;HTTP/1.1 402 Payment Required\r\n&quot; +
370             // &quot;Content-Length: 65\r\n\r&quot;,   // missing trailing LF   //TODO: incomplete
371 
372              &quot;HTTP/1.1 402 Payment Required\r\n&quot; +
373              &quot;Content-Length: 65\r\n\rT\r\n\r\nGGGGGG&quot;,
374 
375              &quot;HTTP/1.1 200OK\r\n\rT&quot;,
376 
377              &quot;HTTP/1.1 200OK\rT&quot;,
<a name="1" id="anc1"></a><span class="line-added">378 </span>
<span class="line-added">379              &quot;HTTP/1.0 FOO\r\n&quot;,</span>
<span class="line-added">380 </span>
<span class="line-added">381              &quot;HTTP/1.1 BAR\r\n&quot;,</span>
<span class="line-added">382 </span>
<span class="line-added">383              &quot;HTTP/1.1 +99\r\n&quot;,</span>
<span class="line-added">384 </span>
<span class="line-added">385              &quot;HTTP/1.1 -22\r\n&quot;,</span>
<span class="line-added">386 </span>
<span class="line-added">387              &quot;HTTP/1.1 -20 \r\n&quot;</span>
<span class="line-added">388 </span>
389            };
390         Arrays.stream(bad).forEach(responses::add);
391 
392         return responses.stream().map(p -&gt; new Object[] { p }).toArray(Object[][]::new);
393     }
394 
395     @Test(dataProvider = &quot;errors&quot;, expectedExceptions = ProtocolException.class)
396     public void errors(String respString) throws ProtocolException {
397         byte[] bytes = respString.getBytes(US_ASCII);
398         Http1HeaderParser decoder = new Http1HeaderParser();
399         ByteBuffer b = ByteBuffer.wrap(bytes);
400         decoder.parse(b);
401     }
402 
403     void assertHeadersEqual(Map&lt;String,List&lt;String&gt;&gt; expected,
404                             Map&lt;String,List&lt;String&gt;&gt; actual,
405                             String msg) {
406 
407         if (expected.equals(actual))
408             return;
409 
410         assertEquals(expected.size(), actual.size(),
411                      format(&quot;%s. Expected size %d, actual size %s. %nexpected= %s,%n actual=%s.&quot;,
412                             msg, expected.size(), actual.size(), mapToString(expected), mapToString(actual)));
413 
414         for (Map.Entry&lt;String,List&lt;String&gt;&gt; e : expected.entrySet()) {
415             String key = e.getKey();
416             List&lt;String&gt; values = e.getValue();
417 
418             boolean found = false;
419             for (Map.Entry&lt;String,List&lt;String&gt;&gt; other: actual.entrySet()) {
420                 if (key.equalsIgnoreCase(other.getKey())) {
421                     found = true;
422                     List&lt;String&gt; otherValues = other.getValue();
423                     assertEquals(values.size(), otherValues.size(),
424                                  format(&quot;%s. Expected list size %d, actual size %s&quot;,
425                                         msg, values.size(), otherValues.size()));
426                     if (!(values.containsAll(otherValues) &amp;&amp; otherValues.containsAll(values)))
427                         assertTrue(false, format(&quot;Lists are unequal [%s] [%s]&quot;, values, otherValues));
428                     break;
429                 }
430             }
431             assertTrue(found, format(&quot;header name, %s, not found in %s&quot;, key, actual));
432         }
433     }
434 
435     static String mapToString(Map&lt;String,List&lt;String&gt;&gt; map) {
436         StringBuilder sb = new StringBuilder();
437         List&lt;String&gt; sortedKeys = new ArrayList(map.keySet());
438         Collections.sort(sortedKeys);
439         for (String key : sortedKeys) {
440             List&lt;String&gt; values = map.get(key);
441             sb.append(&quot;\n\t&quot; + key + &quot; | &quot; + values);
442         }
443         return sb.toString();
444     }
445 
446     // ---
447 
448     /* Main entry point for standalone testing of the main functional test. */
449     public static void main(String... args) throws Exception  {
450         Http1HeaderParserTest test = new Http1HeaderParserTest();
451         int count = 0;
452         for (Object[] objs : test.responses()) {
453             out.println(&quot;Testing &quot; + count++ + &quot;, &quot; + objs[0]);
454             test.verifyHeaders((String) objs[0]);
455         }
456         for (Object[] objs : test.errors()) {
457             out.println(&quot;Testing &quot; + count++ + &quot;, &quot; + objs[0]);
458             try {
459                 test.errors((String) objs[0]);
460                 throw new RuntimeException(&quot;Expected ProtocolException for &quot; + objs[0]);
461             } catch (ProtocolException expected) { /* Ok */ }
462         }
463     }
464 }
<a name="2" id="anc2"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="2" type="hidden" />
</body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames test/jdk/java/net/httpclient/ShortRequestBody.java</title>
    <link rel="stylesheet" href="../../../../../style.css" />
    <script type="text/javascript" src="../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
<a name="1" id="anc1"></a><span class="line-modified">  2  * Copyright (c) 2015, 2018, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 import java.io.IOException;
 25 import java.io.InputStream;
 26 import java.io.OutputStream;
 27 import java.io.UncheckedIOException;
 28 import java.net.InetAddress;
 29 import java.net.InetSocketAddress;
 30 import java.net.ServerSocket;
 31 import java.net.Socket;
<a name="2" id="anc2"></a>
 32 import java.net.URI;
 33 import java.net.http.HttpClient;
 34 import java.net.http.HttpRequest;
 35 import java.net.http.HttpRequest.BodyPublishers;
 36 import java.net.http.HttpResponse;
 37 import java.net.http.HttpResponse.BodyHandlers;
 38 import java.net.http.HttpTimeoutException;
 39 import java.nio.file.Files;
 40 import java.nio.file.Path;
 41 import java.nio.file.Paths;
 42 import java.nio.ByteBuffer;
 43 import java.util.ArrayList;
 44 import java.util.List;
 45 import java.util.concurrent.CompletableFuture;
 46 import java.util.concurrent.ExecutionException;
 47 import java.util.concurrent.Flow;
 48 import java.util.concurrent.TimeoutException;
 49 import java.util.concurrent.TimeUnit;
 50 import java.util.function.Supplier;
 51 import static java.lang.System.err;
 52 import static java.nio.charset.StandardCharsets.US_ASCII;
 53 import static java.nio.charset.StandardCharsets.UTF_8;
 54 
 55 /**
 56  * @test
 57  * @bug 8151441
 58  * @summary Request body of incorrect (larger or smaller) sizes than that
 59  *          reported by the body publisher
 60  * @run main/othervm ShortRequestBody
 61  */
 62 
 63 public class ShortRequestBody {
 64 
 65     static final Path testSrc = Paths.get(System.getProperty(&quot;test.src&quot;, &quot;.&quot;));
 66 
 67     // Some body types ( sources ) for testing.
 68     static final String STRING_BODY = &quot;Hello world&quot;;
 69     static final byte[] BYTE_ARRAY_BODY = new byte[] {
 70         (byte)0xCA, (byte)0xFE, (byte)0xBA, (byte)0xBE };
 71     static final Path FILE_BODY = testSrc.resolve(&quot;docs&quot;).resolve(&quot;files&quot;).resolve(&quot;foo.txt&quot;);
 72 
 73     // Body lengths and offsets ( amount to be wrong by ), to make coordination
 74     // between client and server easier.
 75     static final int[] BODY_LENGTHS = new int[] { STRING_BODY.length(),
 76                                                   BYTE_ARRAY_BODY.length,
 77                                                   fileSize(FILE_BODY) };
 78     static final int[] BODY_OFFSETS = new int[] { 0, +1, -1, +2, -2, +3, -3 };
<a name="3" id="anc3"></a>
 79 
 80     // A delegating Body Publisher. Subtypes will have a concrete body type.
 81     static abstract class AbstractDelegateRequestBody
 82             implements HttpRequest.BodyPublisher {
 83 
 84         final HttpRequest.BodyPublisher delegate;
 85         final long contentLength;
 86 
 87         AbstractDelegateRequestBody(HttpRequest.BodyPublisher delegate,
 88                                     long contentLength) {
 89             this.delegate = delegate;
 90             this.contentLength = contentLength;
 91         }
 92 
 93         @Override
 94         public void subscribe(Flow.Subscriber&lt;? super ByteBuffer&gt; subscriber) {
 95             delegate.subscribe(subscriber);
 96         }
 97 
 98         @Override
 99         public long contentLength() { return contentLength; /* may be wrong! */ }
100     }
101 
102     // Request body Publishers that may generate a different number of actual
103     // bytes to that of what is reported through their {@code contentLength}.
104 
105     static class StringRequestBody extends AbstractDelegateRequestBody {
106         StringRequestBody(String body, int additionalLength) {
107             super(HttpRequest.BodyPublishers.ofString(body),
108                   body.getBytes(UTF_8).length + additionalLength);
109         }
110     }
111 
112     static class ByteArrayRequestBody extends AbstractDelegateRequestBody {
113         ByteArrayRequestBody(byte[] body, int additionalLength) {
114             super(BodyPublishers.ofByteArray(body),
115                   body.length + additionalLength);
116         }
117     }
118 
119     static class FileRequestBody extends AbstractDelegateRequestBody {
120         FileRequestBody(Path path, int additionalLength) throws IOException {
121             super(BodyPublishers.ofFile(path),
122                   Files.size(path) + additionalLength);
123         }
124     }
125 
126     // ---
127 
128     public static void main(String[] args) throws Exception {
129         HttpClient sharedClient = HttpClient.newHttpClient();
130         List&lt;Supplier&lt;HttpClient&gt;&gt; clientSuppliers = new ArrayList&lt;&gt;();
131         clientSuppliers.add(() -&gt; HttpClient.newHttpClient());
132         clientSuppliers.add(() -&gt; sharedClient);
133 
134         try (Server server = new Server()) {
135             for (Supplier&lt;HttpClient&gt; cs : clientSuppliers) {
136                 err.println(&quot;\n---- next supplier ----\n&quot;);
<a name="4" id="anc4"></a><span class="line-modified">137                 URI uri = new URI(&quot;http://localhost:&quot; + server.getPort() + &quot;/&quot;);</span>
138 
139                 // sanity ( 6 requests to keep client and server offsets easy to workout )
140                 success(cs, uri, new StringRequestBody(STRING_BODY, 0));
141                 success(cs, uri, new ByteArrayRequestBody(BYTE_ARRAY_BODY, 0));
142                 success(cs, uri, new FileRequestBody(FILE_BODY, 0));
143                 success(cs, uri, new StringRequestBody(STRING_BODY, 0));
144                 success(cs, uri, new ByteArrayRequestBody(BYTE_ARRAY_BODY, 0));
145                 success(cs, uri, new FileRequestBody(FILE_BODY, 0));
146 
147                 for (int i = 1; i &lt; BODY_OFFSETS.length; i++) {
148                     failureBlocking(cs, uri, new StringRequestBody(STRING_BODY, BODY_OFFSETS[i]));
149                     failureBlocking(cs, uri, new ByteArrayRequestBody(BYTE_ARRAY_BODY, BODY_OFFSETS[i]));
150                     failureBlocking(cs, uri, new FileRequestBody(FILE_BODY, BODY_OFFSETS[i]));
151 
152                     failureNonBlocking(cs, uri, new StringRequestBody(STRING_BODY, BODY_OFFSETS[i]));
153                     failureNonBlocking(cs, uri, new ByteArrayRequestBody(BYTE_ARRAY_BODY, BODY_OFFSETS[i]));
154                     failureNonBlocking(cs, uri, new FileRequestBody(FILE_BODY, BODY_OFFSETS[i]));
155                 }
156             }
157         }
158     }
159 
160     static void success(Supplier&lt;HttpClient&gt; clientSupplier,
161                         URI uri,
162                         HttpRequest.BodyPublisher publisher)
163         throws Exception
164     {
165         CompletableFuture&lt;HttpResponse&lt;Void&gt;&gt; cf;
166         HttpRequest request = HttpRequest.newBuilder(uri)
167                                          .POST(publisher)
168                                          .build();
169         cf = clientSupplier.get().sendAsync(request, BodyHandlers.discarding());
170 
171         HttpResponse&lt;Void&gt; resp = cf.get(30, TimeUnit.SECONDS);
172         err.println(&quot;Response code: &quot; + resp.statusCode());
173         check(resp.statusCode() == 200, null,
174                 &quot;Expected 200, got &quot;, resp.statusCode());
175     }
176 
177     static void failureNonBlocking(Supplier&lt;HttpClient&gt; clientSupplier,
178                                    URI uri,
179                                    HttpRequest.BodyPublisher publisher)
180         throws Exception
181     {
182         CompletableFuture&lt;HttpResponse&lt;Void&gt;&gt; cf;
183         HttpRequest request = HttpRequest.newBuilder(uri)
184                                          .POST(publisher)
185                                          .build();
186         cf = clientSupplier.get().sendAsync(request, BodyHandlers.discarding());
187 
188         try {
189             HttpResponse&lt;Void&gt; r = cf.get(30, TimeUnit.SECONDS);
190             throw new RuntimeException(&quot;Unexpected response: &quot; + r.statusCode());
191         } catch (TimeoutException x) {
192             throw new RuntimeException(&quot;Unexpected timeout&quot;, x);
193         } catch (ExecutionException expected) {
194             err.println(&quot;Caught expected: &quot; + expected);
195             Throwable t = expected.getCause();
196             check(t instanceof IOException, t,
197                   &quot;Expected cause IOException, but got: &quot;, t);
198             String msg = t.getMessage();
199             check(msg.contains(&quot;Too many&quot;) || msg.contains(&quot;Too few&quot;),
200                     t, &quot;Expected Too many|Too few, got: &quot;, t);
201         }
202     }
203 
204     static void failureBlocking(Supplier&lt;HttpClient&gt; clientSupplier,
205                                 URI uri,
206                                 HttpRequest.BodyPublisher publisher)
207         throws Exception
208     {
209         HttpRequest request = HttpRequest.newBuilder(uri)
210                                          .POST(publisher)
211                                          .build();
212         try {
213             HttpResponse&lt;Void&gt; r = clientSupplier.get()
214                     .send(request, BodyHandlers.discarding());
215             throw new RuntimeException(&quot;Unexpected response: &quot; + r.statusCode());
216         } catch (HttpTimeoutException x) {
217             throw new RuntimeException(&quot;Unexpected timeout&quot;, x);
218         } catch (IOException expected) {
219             err.println(&quot;Caught expected: &quot; + expected);
220             String msg = expected.getMessage();
221             check(msg.contains(&quot;Too many&quot;) || msg.contains(&quot;Too few&quot;),
222                     expected,&quot;Expected Too many|Too few, got: &quot;, expected);
223         }
224     }
225 
226     static class Server extends Thread implements AutoCloseable {
227 
228         static String RESPONSE = &quot;HTTP/1.1 200 OK\r\n&quot; +
229                                  &quot;Connection: close\r\n&quot;+
230                                  &quot;Content-length: 0\r\n\r\n&quot;;
231 
232         private final ServerSocket ss;
233         private volatile boolean closed;
234 
235         Server() throws IOException {
236             super(&quot;Test-Server&quot;);
237             ss = new ServerSocket();
238             ss.setReuseAddress(false);
239             ss.bind(new InetSocketAddress(InetAddress.getLoopbackAddress(), 0));
240             this.start();
241         }
242 
243         int getPort() { return ss.getLocalPort(); }
244 
245         @Override
246         public void run() {
247             int count = 0;
248             int offset = 0;
249 
250             while (!closed) {
<a name="5" id="anc5"></a>
251                 try (Socket s = ss.accept()) {
252                     err.println(&quot;Server: got connection&quot;);
253                     InputStream is = s.getInputStream();
<a name="6" id="anc6"></a><span class="line-modified">254                     readRequestHeaders(is);</span>








255                     byte[] ba = new byte[1024];
256 
257                     int length = BODY_LENGTHS[count % 3];
258                     length += BODY_OFFSETS[offset];
259                     err.println(&quot;Server: count=&quot; + count + &quot;, offset=&quot; + offset);
260                     err.println(&quot;Server: expecting &quot; +length+ &quot; bytes&quot;);
<a name="7" id="anc7"></a><span class="line-modified">261                     int read = is.readNBytes(ba, 0, length);</span>
<span class="line-modified">262                     err.println(&quot;Server: actually read &quot; + read + &quot; bytes&quot;);</span>
<span class="line-modified">263 </span>
<span class="line-modified">264                     // Update the counts before replying, to prevent the</span>
<span class="line-modified">265                     // client-side racing reset with this thread.</span>
<span class="line-modified">266                     count++;</span>
<span class="line-modified">267                     if (count % 6 == 0) // 6 is the number of failure requests per offset</span>
<span class="line-modified">268                         offset++;</span>
<span class="line-modified">269                     if (count % 42 == 0) {</span>
<span class="line-modified">270                         count = 0;  // reset, for second iteration</span>
<span class="line-modified">271                         offset = 0;</span>



272                     }
<a name="8" id="anc8"></a><span class="line-removed">273 </span>
274                     if (read &lt; length) {
275                         // no need to reply, client has already closed
276                         // ensure closed
277                         if (is.read() != -1)
<a name="9" id="anc9"></a><span class="line-modified">278                             new AssertionError(&quot;Unexpected read&quot;);</span>
279                     } else {
280                         OutputStream os = s.getOutputStream();
281                         err.println(&quot;Server: writing &quot;
282                                 + RESPONSE.getBytes(US_ASCII).length + &quot; bytes&quot;);
283                         os.write(RESPONSE.getBytes(US_ASCII));
284                     }
<a name="10" id="anc10"></a><span class="line-modified">285 </span>
<span class="line-modified">286                 } catch (IOException e) {</span>
<span class="line-modified">287                     if (!closed)</span>
<span class="line-modified">288                         System.out.println(&quot;Unexpected&quot; + e);</span>

289                 }
290             }
291         }
292 
293         @Override
294         public void close() {
295             if (closed)
296                 return;
297             closed = true;
298             try {
299                 ss.close();
300             } catch (IOException e) {
301                 throw new UncheckedIOException(&quot;Unexpected&quot;, e);
302             }
303         }
304     }
305 
306     static final byte[] requestEnd = new byte[] {&#39;\r&#39;, &#39;\n&#39;, &#39;\r&#39;, &#39;\n&#39; };
307 
308     // Read until the end of a HTTP request headers
<a name="11" id="anc11"></a><span class="line-modified">309     static void readRequestHeaders(InputStream is) throws IOException {</span>
<span class="line-modified">310         int requestEndCount = 0, r;</span>

311         while ((r = is.read()) != -1) {
<a name="12" id="anc12"></a>



312             if (r == requestEnd[requestEndCount]) {
313                 requestEndCount++;
314                 if (requestEndCount == 4) {
315                     break;
316                 }
317             } else {
318                 requestEndCount = 0;
319             }
320         }
<a name="13" id="anc13"></a>




321     }
322 
323     static int fileSize(Path p) {
324         try { return (int) Files.size(p); }
325         catch (IOException x) { throw new UncheckedIOException(x); }
326     }
327 
328     static boolean check(boolean cond, Throwable t, Object... failedArgs) {
329         if (cond)
330             return true;
331         // We are going to fail...
332         StringBuilder sb = new StringBuilder();
333         for (Object o : failedArgs)
334                 sb.append(o);
335         throw new RuntimeException(sb.toString(), t);
336     }
337 }
<a name="14" id="anc14"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="14" type="hidden" />
</body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New test/jdk/java/net/httpclient/ProxyTest.java</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2017, 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 import com.sun.net.httpserver.HttpContext;
 25 import com.sun.net.httpserver.HttpExchange;
 26 import com.sun.net.httpserver.HttpHandler;
 27 import com.sun.net.httpserver.HttpServer;
 28 import com.sun.net.httpserver.HttpsConfigurator;
 29 import com.sun.net.httpserver.HttpsParameters;
 30 import com.sun.net.httpserver.HttpsServer;
 31 import java.io.IOException;
 32 import java.io.InputStream;
 33 import java.io.OutputStream;
 34 import java.io.OutputStreamWriter;
 35 import java.io.PrintWriter;
 36 import java.io.Writer;
 37 import java.net.HttpURLConnection;
 38 import java.net.InetAddress;
 39 import java.net.InetSocketAddress;
 40 import java.net.Proxy;
 41 import java.net.ProxySelector;
 42 import java.net.ServerSocket;
 43 import java.net.Socket;
 44 import java.net.SocketAddress;
 45 import java.net.URI;
 46 import java.net.URISyntaxException;
 47 import java.nio.charset.StandardCharsets;
 48 import java.security.NoSuchAlgorithmException;
 49 import java.util.List;
 50 import java.util.concurrent.CompletableFuture;
 51 import java.util.concurrent.CopyOnWriteArrayList;
 52 import javax.net.ssl.HostnameVerifier;
 53 import javax.net.ssl.HttpsURLConnection;
 54 import javax.net.ssl.SSLContext;
 55 import javax.net.ssl.SSLSession;
 56 import java.net.http.HttpClient;
 57 import java.net.http.HttpRequest;
 58 import java.net.http.HttpResponse;
 59 import jdk.test.lib.net.SimpleSSLContext;
 60 import static java.net.Proxy.NO_PROXY;
 61 
 62 /**
 63  * @test
 64  * @bug 8185852 8181422
 65  * @summary Verifies that passing a proxy with an unresolved address does
 66  *          not cause java.nio.channels.UnresolvedAddressException.
 67  *          Verifies that downgrading from HTTP/2 to HTTP/1.1 works through
 68  *          an SSL Tunnel connection when the client is HTTP/2 and the server
 69  *          and proxy are HTTP/1.1
 70  * @modules java.net.http
 71  * @library /test/lib
 72  * @build jdk.test.lib.net.SimpleSSLContext ProxyTest
 73  * @run main/othervm ProxyTest
 74  * @author danielfuchs
 75  */
 76 public class ProxyTest {
 77 
 78     static {
 79         try {
 80             HttpsURLConnection.setDefaultHostnameVerifier(new HostnameVerifier() {
 81                     public boolean verify(String hostname, SSLSession session) {
 82                         return true;
 83                     }
 84                 });
 85             SSLContext.setDefault(new SimpleSSLContext().get());
 86         } catch (IOException ex) {
 87             throw new ExceptionInInitializerError(ex);
 88         }
 89     }
 90 
 91     static final String RESPONSE = &quot;&lt;html&gt;&lt;body&gt;&lt;p&gt;Hello World!&lt;/body&gt;&lt;/html&gt;&quot;;
 92     static final String PATH = &quot;/foo/&quot;;
 93 
 94     static HttpServer createHttpsServer() throws IOException, NoSuchAlgorithmException {
 95         HttpsServer server = com.sun.net.httpserver.HttpsServer.create();
 96         HttpContext context = server.createContext(PATH);
 97         context.setHandler(new HttpHandler() {
 98             @Override
 99             public void handle(HttpExchange he) throws IOException {
100                 he.getResponseHeaders().add(&quot;encoding&quot;, &quot;UTF-8&quot;);
101                 he.sendResponseHeaders(200, RESPONSE.length());
102                 he.getResponseBody().write(RESPONSE.getBytes(StandardCharsets.UTF_8));
103                 he.close();
104             }
105         });
106 
107         server.setHttpsConfigurator(new Configurator(SSLContext.getDefault()));
108         InetSocketAddress addr = new InetSocketAddress(InetAddress.getLoopbackAddress(), 0);
109         server.bind(addr, 0);
110         return server;
111     }
112 
113     public static void main(String[] args)
114             throws IOException,
115             URISyntaxException,
116             NoSuchAlgorithmException,
117             InterruptedException
118     {
119         HttpServer server = createHttpsServer();
120         server.start();
121         try {
122             test(server, HttpClient.Version.HTTP_1_1);
123             test(server, HttpClient.Version.HTTP_2);
124         } finally {
125             server.stop(0);
126             System.out.println(&quot;Server stopped&quot;);
127         }
128     }
129 
130     /**
131      * A Proxy Selector that wraps a ProxySelector.of(), and counts the number
132      * of times its select method has been invoked. This can be used to ensure
133      * that the Proxy Selector is invoked only once per HttpClient.sendXXX
134      * invocation.
135      */
136     static class CountingProxySelector extends ProxySelector {
137         private final ProxySelector proxySelector;
138         private volatile int count; // 0
139         private CountingProxySelector(InetSocketAddress proxyAddress) {
140             proxySelector = ProxySelector.of(proxyAddress);
141         }
142 
143         public static CountingProxySelector of(InetSocketAddress proxyAddress) {
144             return new CountingProxySelector(proxyAddress);
145         }
146 
147         int count() { return count; }
148 
149         @Override
150         public List&lt;Proxy&gt; select(URI uri) {
151             count++;
152             return proxySelector.select(uri);
153         }
154 
155         @Override
156         public void connectFailed(URI uri, SocketAddress sa, IOException ioe) {
157             proxySelector.connectFailed(uri, sa, ioe);
158         }
159     }
160 
161     public static void test(HttpServer server, HttpClient.Version version)
162             throws IOException,
163             URISyntaxException,
164             NoSuchAlgorithmException,
165             InterruptedException
166     {
167         System.out.println(&quot;Server is: &quot; + server.getAddress().toString());
168         System.out.println(&quot;Verifying communication with server&quot;);
169         URI uri = new URI(&quot;https://localhost:&quot;
170                           + server.getAddress().getPort() + PATH + &quot;x&quot;);
171         try (InputStream is = uri.toURL().openConnection(NO_PROXY).getInputStream()) {
172             String resp = new String(is.readAllBytes(), StandardCharsets.UTF_8);
173             System.out.println(resp);
174             if (!RESPONSE.equals(resp)) {
175                 throw new AssertionError(&quot;Unexpected response from server&quot;);
176             }
177         }
178         System.out.println(&quot;Communication with server OK&quot;);
179 
180         TunnelingProxy proxy = new TunnelingProxy(server);
181         proxy.start();
182         try {
183             System.out.println(&quot;Proxy started&quot;);
184             Proxy p = new Proxy(Proxy.Type.HTTP,
185                     InetSocketAddress.createUnresolved(&quot;localhost&quot;,
186                             proxy.getAddress().getPort()));
187             System.out.println(&quot;Verifying communication with proxy&quot;);
188             HttpURLConnection conn = (HttpURLConnection)uri.toURL().openConnection(p);
189             try (InputStream is = conn.getInputStream()) {
190                 String resp = new String(is.readAllBytes(), StandardCharsets.UTF_8);
191                 System.out.println(resp);
192                 if (!RESPONSE.equals(resp)) {
193                     throw new AssertionError(&quot;Unexpected response from proxy&quot;);
194                 }
195             }
196             System.out.println(&quot;Communication with proxy OK&quot;);
197             System.out.println(&quot;\nReal test begins here.&quot;);
198             System.out.println(&quot;Setting up request with HttpClient for version: &quot;
199                     + version.name());
200             CountingProxySelector ps = CountingProxySelector.of(
201                     InetSocketAddress.createUnresolved(&quot;localhost&quot;,
202                             proxy.getAddress().getPort()));
203             HttpClient client = HttpClient.newBuilder()
204                 .version(version)
205                 .proxy(ps)
206                 .build();
207             HttpRequest request = HttpRequest.newBuilder()
208                 .uri(uri)
209                 .GET()
210                 .build();
211 
212             System.out.println(&quot;Sending request with HttpClient&quot;);
213             HttpResponse&lt;String&gt; response
214                 = client.send(request, HttpResponse.BodyHandlers.ofString());
215             System.out.println(&quot;Got response&quot;);
216             String resp = response.body();
217             System.out.println(&quot;Received: &quot; + resp);
218             if (!RESPONSE.equals(resp)) {
219                 throw new AssertionError(&quot;Unexpected response&quot;);
220             }
221             if (ps.count() &gt; 1) {
222                 throw new AssertionError(&quot;CountingProxySelector. Expected 1, got &quot; + ps.count());
223             }
224         } finally {
225             System.out.println(&quot;Stopping proxy&quot;);
226             proxy.stop();
227             System.out.println(&quot;Proxy stopped&quot;);
228         }
229     }
230 
231     static class TunnelingProxy {
232         final Thread accept;
233         final ServerSocket ss;
234         final boolean DEBUG = false;
235         final HttpServer serverImpl;
236         final CopyOnWriteArrayList&lt;CompletableFuture&lt;Void&gt;&gt; connectionCFs
237                 = new CopyOnWriteArrayList&lt;&gt;();
238         private volatile boolean stopped;
239         TunnelingProxy(HttpServer serverImpl) throws IOException {
240             this.serverImpl = serverImpl;
241             ss = new ServerSocket();
242             accept = new Thread(this::accept);
243             accept.setDaemon(true);
244         }
245 
246         void start() throws IOException {
247             ss.bind(new InetSocketAddress(InetAddress.getLoopbackAddress(), 0));
248             accept.start();
249         }
250 
251         // Pipe the input stream to the output stream.
252         private synchronized Thread pipe(InputStream is, OutputStream os,
253                                          char tag, CompletableFuture&lt;Void&gt; end) {
254             return new Thread(&quot;TunnelPipe(&quot;+tag+&quot;)&quot;) {
255                 @Override
256                 public void run() {
257                     try {
258                         try {
259                             int c;
260                             while ((c = is.read()) != -1) {
261                                 os.write(c);
262                                 os.flush();
263                                 // if DEBUG prints a + or a - for each transferred
264                                 // character.
265                                 if (DEBUG) System.out.print(tag);
266                             }
267                             is.close();
268                         } finally {
269                             os.close();
270                         }
271                     } catch (IOException ex) {
272                         if (DEBUG) ex.printStackTrace(System.out);
273                     } finally {
274                         end.complete(null);
275                     }
276                 }
277             };
278         }
279 
280         public InetSocketAddress getAddress() {
281             return new InetSocketAddress(InetAddress.getLoopbackAddress(),
282                                          ss.getLocalPort());
283         }
284 
285         // This is a bit shaky. It doesn&#39;t handle continuation
286         // lines, but our client shouldn&#39;t send any.
287         // Read a line from the input stream, swallowing the final
288         // \r\n sequence. Stops at the first \n, doesn&#39;t complain
289         // if it wasn&#39;t preceded by &#39;\r&#39;.
290         //
291         String readLine(InputStream r) throws IOException {
292             StringBuilder b = new StringBuilder();
293             int c;
294             while ((c = r.read()) != -1) {
295                 if (c == &#39;\n&#39;) break;
296                 b.appendCodePoint(c);
297             }
298             if (b.codePointAt(b.length() -1) == &#39;\r&#39;) {
299                 b.delete(b.length() -1, b.length());
300             }
301             return b.toString();
302         }
303 
304         public void accept() {
305             Socket clientConnection = null;
306             try {
307                 while (!stopped) {
308                     System.out.println(&quot;Tunnel: Waiting for client&quot;);
309                     Socket toClose;
310                     try {
311                         toClose = clientConnection = ss.accept();
312                     } catch (IOException io) {
313                         if (DEBUG) io.printStackTrace(System.out);
314                         break;
315                     }
316                     System.out.println(&quot;Tunnel: Client accepted&quot;);
317                     Socket targetConnection = null;
318                     InputStream  ccis = clientConnection.getInputStream();
319                     OutputStream ccos = clientConnection.getOutputStream();
320                     Writer w = new OutputStreamWriter(ccos, &quot;UTF-8&quot;);
321                     PrintWriter pw = new PrintWriter(w);
322                     System.out.println(&quot;Tunnel: Reading request line&quot;);
323                     String requestLine = readLine(ccis);
324                     System.out.println(&quot;Tunnel: Request status line: &quot; + requestLine);
325                     if (requestLine.startsWith(&quot;CONNECT &quot;)) {
326                         // We should probably check that the next word following
327                         // CONNECT is the host:port of our HTTPS serverImpl.
328                         // Some improvement for a followup!
329 
330                         // Read all headers until we find the empty line that
331                         // signals the end of all headers.
332                         while(!requestLine.equals(&quot;&quot;)) {
333                             System.out.println(&quot;Tunnel: Reading header: &quot;
334                                                + (requestLine = readLine(ccis)));
335                         }
336 
337                         // Open target connection
338                         targetConnection = new Socket(
339                                 InetAddress.getLoopbackAddress(),
340                                 serverImpl.getAddress().getPort());
341 
342                         // Then send the 200 OK response to the client
343                         System.out.println(&quot;Tunnel: Sending &quot;
344                                            + &quot;HTTP/1.1 200 OK\r\n\r\n&quot;);
345                         pw.print(&quot;HTTP/1.1 200 OK\r\nContent-Length: 0\r\n\r\n&quot;);
346                         pw.flush();
347                     } else {
348                         // This should not happen. If it does then just print an
349                         // error - both on out and err, and close the accepted
350                         // socket
351                         System.out.println(&quot;WARNING: Tunnel: Unexpected status line: &quot;
352                                 + requestLine + &quot; received by &quot;
353                                 + ss.getLocalSocketAddress()
354                                 + &quot; from &quot;
355                                 + toClose.getRemoteSocketAddress()
356                                 + &quot; - closing accepted socket&quot;);
357                         // Print on err
358                         System.err.println(&quot;WARNING: Tunnel: Unexpected status line: &quot;
359                                 + requestLine + &quot; received by &quot;
360                                 + ss.getLocalSocketAddress()
361                                 + &quot; from &quot;
362                                 + toClose.getRemoteSocketAddress());
363                         // close accepted socket.
364                         toClose.close();
365                         System.err.println(&quot;Tunnel: accepted socket closed.&quot;);
366                         continue;
367                     }
368 
369                     // Pipe the input stream of the client connection to the
370                     // output stream of the target connection and conversely.
371                     // Now the client and target will just talk to each other.
372                     System.out.println(&quot;Tunnel: Starting tunnel pipes&quot;);
373                     CompletableFuture&lt;Void&gt; end, end1, end2;
374                     Thread t1 = pipe(ccis, targetConnection.getOutputStream(), &#39;+&#39;,
375                             end1 = new CompletableFuture&lt;&gt;());
376                     Thread t2 = pipe(targetConnection.getInputStream(), ccos, &#39;-&#39;,
377                             end2 = new CompletableFuture&lt;&gt;());
378                     end = CompletableFuture.allOf(end1, end2);
379                     end.whenComplete(
380                             (r,t) -&gt; {
381                                 try { toClose.close(); } catch (IOException x) { }
382                                 finally {connectionCFs.remove(end);}
383                             });
384                     connectionCFs.add(end);
385                     t1.start();
386                     t2.start();
387                 }
388             } catch (Throwable ex) {
389                 try {
390                     ss.close();
391                 } catch (IOException ex1) {
392                     ex.addSuppressed(ex1);
393                 }
394                 ex.printStackTrace(System.err);
395             } finally {
396                 System.out.println(&quot;Tunnel: exiting (stopped=&quot; + stopped + &quot;)&quot;);
397                 connectionCFs.forEach(cf -&gt; cf.complete(null));
398             }
399         }
400 
401         public void stop() throws IOException {
402             stopped = true;
403             ss.close();
404         }
405 
406     }
407 
408     static class Configurator extends HttpsConfigurator {
409         public Configurator(SSLContext ctx) {
410             super(ctx);
411         }
412 
413         @Override
414         public void configure (HttpsParameters params) {
415             params.setSSLParameters (getSSLContext().getSupportedSSLParameters());
416         }
417     }
418 
419 }
    </pre>
  </body>
</html>
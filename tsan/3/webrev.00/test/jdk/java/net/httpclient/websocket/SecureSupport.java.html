<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New test/jdk/java/net/httpclient/websocket/SecureSupport.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2020, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 import java.io.IOException;
 25 import java.net.Socket;
 26 import java.nio.ByteBuffer;
 27 import java.nio.channels.SocketChannel;
 28 import java.nio.charset.StandardCharsets;
 29 import java.util.Arrays;
 30 import java.util.concurrent.CompletableFuture;
 31 import java.util.concurrent.CompletionException;
 32 import java.util.concurrent.CompletionStage;
 33 import java.util.concurrent.TimeUnit;
 34 import java.util.concurrent.TimeoutException;
 35 
 36 import static org.testng.Assert.assertThrows;
 37 
 38 /**
 39  * Helper class to create instances of DummySecureWebSocketServer which
 40  * can support both plain and secure connections.
 41  * The caller should invoke DummySecureWebSocketServer::secure before
 42  * DummySecureWebSocketServer::open in order to enable secure connection.
 43  * When secure, the DummySecureWebSocketServer currently only support using the
 44  * default SSLEngine through the default SSLSocketServerFacrtory.
 45  */
 46 public class SecureSupport {
 47 
 48     private SecureSupport() { }
 49 
 50     public static DummySecureWebSocketServer serverWithCannedData(int... data) {
 51         return serverWithCannedDataAndAuthentication(null, null, data);
 52     }
 53 
 54     public static DummySecureWebSocketServer serverWithCannedDataAndAuthentication(
 55             String username,
 56             String password,
 57             int... data)
 58     {
 59         byte[] copy = new byte[data.length];
 60         for (int i = 0; i &lt; data.length; i++) {
 61             copy[i] = (byte) data[i];
 62         }
 63         return serverWithCannedDataAndAuthentication(username, password, copy);
 64     }
 65 
 66     public static DummySecureWebSocketServer serverWithCannedData(byte... data) {
 67        return serverWithCannedDataAndAuthentication(null, null, data);
 68     }
 69 
 70     public static DummySecureWebSocketServer serverWithCannedDataAndAuthentication(
 71             String username,
 72             String password,
 73             byte... data)
 74     {
 75         byte[] copy = Arrays.copyOf(data, data.length);
 76         return new DummySecureWebSocketServer(username, password) {
 77             @Override
 78             protected void write(WebSocketChannel ch) throws IOException {
 79                 int off = 0; int n = 1; // 1 byte at a time
 80                 while (off + n &lt; copy.length + n) {
 81                     int len = Math.min(copy.length - off, n);
 82                     ByteBuffer bytes = ByteBuffer.wrap(copy, off, len);
 83                     off += len;
 84                     ch.write(bytes);
 85                 }
 86                 super.write(ch);
 87             }
 88         };
 89     }
 90 
 91     /*
 92      * This server does not read from the wire, allowing its client to fill up
 93      * their send buffer. Used to test scenarios with outstanding send
 94      * operations.
 95      */
 96     public static DummySecureWebSocketServer notReadingServer() {
 97         return new DummySecureWebSocketServer() {
 98             @Override
 99             protected void read(WebSocketChannel ch) throws IOException {
100                 try {
101                     Thread.sleep(Long.MAX_VALUE);
102                 } catch (InterruptedException e) {
103                     throw new IOException(e);
104                 }
105             }
106         };
107     }
108 
109     public static DummySecureWebSocketServer writingServer(int... data) {
110         byte[] copy = new byte[data.length];
111         for (int i = 0; i &lt; data.length; i++) {
112             copy[i] = (byte) data[i];
113         }
114         return new DummySecureWebSocketServer() {
115 
116             @Override
117             protected void read(WebSocketChannel ch) throws IOException {
118                 try {
119                     Thread.sleep(Long.MAX_VALUE);
120                 } catch (InterruptedException e) {
121                     throw new IOException(e);
122                 }
123             }
124 
125             @Override
126             protected void write(WebSocketChannel ch) throws IOException {
127                 int off = 0; int n = 1; // 1 byte at a time
128                 while (off + n &lt; copy.length + n) {
129                     int len = Math.min(copy.length - off, n);
130                     ByteBuffer bytes = ByteBuffer.wrap(copy, off, len);
131                     off += len;
132                     ch.write(bytes);
133                 }
134                 super.write(ch);
135             }
136         };
137 
138     }
139 
140     public static String stringWith2NBytes(int n) {
141         // -- Russian Alphabet (33 characters, 2 bytes per char) --
142         char[] abc = {
143                 0x0410, 0x0411, 0x0412, 0x0413, 0x0414, 0x0415, 0x0401, 0x0416,
144                 0x0417, 0x0418, 0x0419, 0x041A, 0x041B, 0x041C, 0x041D, 0x041E,
145                 0x041F, 0x0420, 0x0421, 0x0422, 0x0423, 0x0424, 0x0425, 0x0426,
146                 0x0427, 0x0428, 0x0429, 0x042A, 0x042B, 0x042C, 0x042D, 0x042E,
147                 0x042F,
148         };
149         // repeat cyclically
150         StringBuilder sb = new StringBuilder(n);
151         for (int i = 0, j = 0; i &lt; n; i++, j = (j + 1) % abc.length) {
152             sb.append(abc[j]);
153         }
154         String s = sb.toString();
155         assert s.length() == n &amp;&amp; s.getBytes(StandardCharsets.UTF_8).length == 2 * n;
156         return s;
157     }
158 
159     public static String malformedString() {
160         return new String(new char[]{0xDC00, 0xD800});
161     }
162 
163     public static String incompleteString() {
164         return new String(new char[]{0xD800});
165     }
166 
167     public static String stringWithNBytes(int n) {
168         char[] chars = new char[n];
169         Arrays.fill(chars, &#39;A&#39;);
170         return new String(chars);
171     }
172 }
    </pre>
  </body>
</html>
diff a/test/jdk/java/net/httpclient/HandshakeFailureTest.java b/test/jdk/java/net/httpclient/HandshakeFailureTest.java
--- a/test/jdk/java/net/httpclient/HandshakeFailureTest.java
+++ b/test/jdk/java/net/httpclient/HandshakeFailureTest.java
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2017, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2017, 2020, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.
@@ -19,51 +19,60 @@
  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  * or visit www.oracle.com if you need additional information or have any
  * questions.
  */
 
-import javax.net.ServerSocketFactory;
-import javax.net.ssl.SSLContext;
-import javax.net.ssl.SSLParameters;
-import javax.net.ssl.SSLHandshakeException;
-import javax.net.ssl.SSLSocket;
+import static java.lang.System.out;
+import static java.net.http.HttpResponse.BodyHandlers.discarding;
+
 import java.io.DataInputStream;
 import java.io.IOException;
 import java.io.UncheckedIOException;
 import java.net.InetAddress;
 import java.net.InetSocketAddress;
 import java.net.ServerSocket;
 import java.net.Socket;
+import java.net.SocketException;
 import java.net.URI;
-import java.util.List;
-import java.util.concurrent.CompletableFuture;
-import java.util.concurrent.CompletionException;
 import java.net.http.HttpClient;
 import java.net.http.HttpClient.Version;
-import java.net.http.HttpResponse;
 import java.net.http.HttpRequest;
-import static java.lang.System.out;
-import static java.net.http.HttpResponse.BodyHandlers.discarding;
+import java.net.http.HttpResponse;
+import java.util.List;
+import java.util.concurrent.CompletableFuture;
+import java.util.concurrent.CompletionException;
+
+import javax.net.ServerSocketFactory;
+import javax.net.ssl.SSLContext;
+import javax.net.ssl.SSLHandshakeException;
+import javax.net.ssl.SSLParameters;
+import javax.net.ssl.SSLSocket;
 
 /**
  * @test
- * @run main/othervm -Djdk.internal.httpclient.debug=true HandshakeFailureTest
+ * @run main/othervm -Djdk.internal.httpclient.debug=false HandshakeFailureTest TLSv1.2
+ * @run main/othervm -Djdk.internal.httpclient.debug=false HandshakeFailureTest TLSv1.3
  * @summary Verify SSLHandshakeException is received when the handshake fails,
- * either because the server closes ( EOF ) the connection during handshaking
- * or no cipher suite ( or similar ) can be negotiated.
+ * either because the server closes (EOF) the connection during handshaking,
+ * or no cipher suite can be negotiated (TLSv1.2) or no available authentication
+ * scheme (TLSv1.3).
  */
 // To switch on debugging use:
 // @run main/othervm -Djdk.internal.httpclient.debug=true HandshakeFailureTest
 public class HandshakeFailureTest {
 
     // The number of iterations each testXXXClient performs. Can be increased
     // when running standalone testing.
     static final int TIMES = 10;
 
+    private static String tlsProtocol;
+
     public static void main(String[] args) throws Exception {
+        tlsProtocol = args[0];
+
         HandshakeFailureTest test = new HandshakeFailureTest();
-        List<AbstractServer> servers = List.of( new PlainServer(), new SSLServer());
+        List<AbstractServer> servers = List.of(new PlainServer(), new SSLServer());
 
         for (AbstractServer server : servers) {
             try (server) {
                 out.format("%n%n------ Testing with server:%s ------%n", server);
                 URI uri = new URI("https://localhost:" + server.getPort() + "/");
@@ -81,11 +90,11 @@
         }
     }
 
     static HttpClient getClient() {
         SSLParameters params = new SSLParameters();
-        params.setProtocols(new String[] {"TLSv1.2"});
+        params.setProtocols(new String[] { tlsProtocol });
         return HttpClient.newBuilder()
                 .sslParameters(params)
                 .build();
     }
 
@@ -101,11 +110,11 @@
                 HttpResponse<Void> response = client.send(request, discarding());
                 String msg = String.format("UNEXPECTED response=%s%n", response);
                 throw new RuntimeException(msg);
             } catch (IOException expected) {
                 out.printf("Client: caught expected exception: %s%n", expected);
-                checkExceptionOrCause(SSLHandshakeException.class, expected);
+                checkExceptionOrCause(expected);
             }
         }
     }
 
     void testSyncDiffClient(URI uri, Version version) throws Exception {
@@ -121,11 +130,11 @@
                 HttpResponse<Void> response = client.send(request, discarding());
                 String msg = String.format("UNEXPECTED response=%s%n", response);
                 throw new RuntimeException(msg);
             } catch (IOException expected) {
                 out.printf("Client: caught expected exception: %s%n", expected);
-                checkExceptionOrCause(SSLHandshakeException.class, expected);
+                checkExceptionOrCause(expected);
             }
         }
     }
 
     void testAsyncSameClient(URI uri, Version version) throws Exception {
@@ -143,11 +152,11 @@
                 String msg = String.format("UNEXPECTED response=%s%n", response);
                 throw new RuntimeException(msg);
             } catch (CompletionException ce) {
                 Throwable expected = ce.getCause();
                 out.printf("Client: caught expected exception: %s%n", expected);
-                checkExceptionOrCause(SSLHandshakeException.class, expected);
+                checkExceptionOrCause(expected);
             }
         }
     }
 
     void testAsyncDiffClient(URI uri, Version version) throws Exception {
@@ -167,28 +176,35 @@
                 throw new RuntimeException(msg);
             } catch (CompletionException ce) {
                 ce.printStackTrace(out);
                 Throwable expected = ce.getCause();
                 out.printf("Client: caught expected exception: %s%n", expected);
-                checkExceptionOrCause(SSLHandshakeException.class, expected);
+                checkExceptionOrCause(expected);
             }
         }
     }
 
-    static void checkExceptionOrCause(Class<? extends Throwable> clazz, Throwable t) {
+    static void checkExceptionOrCause(Throwable t) {
         final Throwable original = t;
         do {
-            if (clazz.isInstance(t)) {
+            if (SSLHandshakeException.class.isInstance(t)
+                    // For TLSv1.3, possibly the server is (being) closed when
+                    // the client read the input alert. In this case, the client
+                    // just gets SocketException instead of SSLHandshakeException.
+                    || (tlsProtocol.equalsIgnoreCase("TLSv1.3")
+                            && SocketException.class.isInstance(t))) {
                 System.out.println("Found expected exception/cause: " + t);
                 return; // found
             }
         } while ((t = t.getCause()) != null);
         original.printStackTrace(System.out);
-        throw new RuntimeException("Expected " + clazz + "in " + original);
+        throw new RuntimeException(
+                "Not found expected SSLHandshakeException or SocketException in "
+                        + original);
     }
 
-    /** Common supertype for PlainServer and SSLServer. */
+    /** Common super type for PlainServer and SSLServer. */
     static abstract class AbstractServer extends Thread implements AutoCloseable {
         protected final ServerSocket ss;
         protected volatile boolean closed;
 
         AbstractServer(String name, ServerSocket ss) throws IOException {
@@ -269,18 +285,19 @@
             }
         }
     }
 
     /** Emulates a server-side, using SSL Sockets, that will fail during
-     * handshaking, as there are no cipher suites in common. */
+     * handshaking, as there are no cipher suites in common (TLSv1.2)
+     * or no available authentication scheme (TLSv1.3). */
     static class SSLServer extends AbstractServer {
         static final SSLContext sslContext = createUntrustingContext();
         static final ServerSocketFactory factory = sslContext.getServerSocketFactory();
 
         static SSLContext createUntrustingContext() {
             try {
-                SSLContext sslContext = SSLContext.getInstance("TLSv1.2");
+                SSLContext sslContext = SSLContext.getInstance("TLS");
                 sslContext.init(null, null, null);
                 return sslContext;
             } catch (Throwable t) {
                 throw new AssertionError(t);
             }
@@ -296,11 +313,12 @@
                 try (SSLSocket s = (SSLSocket)ss.accept()) {
                     s.getInputStream().read();  // will throw SHE here
 
                     throw new AssertionError("Should not reach here");
                 } catch (SSLHandshakeException expected) {
-                    // Expected: SSLHandshakeException: no cipher suites in common
+                    // Expected: SSLHandshakeException: no cipher suites in common (TLSv1.2)
+                    // or no available authentication scheme (TLSv1.3)
                     out.printf("Server: caught expected exception: %s%n", expected);
                 } catch (IOException e) {
                     if (!closed)
                         out.printf("UNEXPECTED %s", e);
                 }

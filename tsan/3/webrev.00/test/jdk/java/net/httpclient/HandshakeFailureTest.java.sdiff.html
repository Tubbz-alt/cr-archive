<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff test/jdk/java/net/httpclient/HandshakeFailureTest.java</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
<body>
<center><a href="DigestEchoServer.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="HttpResponseInputStreamTest.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>test/jdk/java/net/httpclient/HandshakeFailureTest.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2017, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
<span class="line-modified"> 24 import javax.net.ServerSocketFactory;</span>
<span class="line-modified"> 25 import javax.net.ssl.SSLContext;</span>
<span class="line-modified"> 26 import javax.net.ssl.SSLParameters;</span>
<span class="line-removed"> 27 import javax.net.ssl.SSLHandshakeException;</span>
<span class="line-removed"> 28 import javax.net.ssl.SSLSocket;</span>
 29 import java.io.DataInputStream;
 30 import java.io.IOException;
 31 import java.io.UncheckedIOException;
 32 import java.net.InetAddress;
 33 import java.net.InetSocketAddress;
 34 import java.net.ServerSocket;
 35 import java.net.Socket;

 36 import java.net.URI;
<span class="line-removed"> 37 import java.util.List;</span>
<span class="line-removed"> 38 import java.util.concurrent.CompletableFuture;</span>
<span class="line-removed"> 39 import java.util.concurrent.CompletionException;</span>
 40 import java.net.http.HttpClient;
 41 import java.net.http.HttpClient.Version;
<span class="line-removed"> 42 import java.net.http.HttpResponse;</span>
 43 import java.net.http.HttpRequest;
<span class="line-modified"> 44 import static java.lang.System.out;</span>
<span class="line-modified"> 45 import static java.net.http.HttpResponse.BodyHandlers.discarding;</span>








 46 
 47 /**
 48  * @test
<span class="line-modified"> 49  * @run main/othervm -Djdk.internal.httpclient.debug=true HandshakeFailureTest</span>

 50  * @summary Verify SSLHandshakeException is received when the handshake fails,
<span class="line-modified"> 51  * either because the server closes ( EOF ) the connection during handshaking</span>
<span class="line-modified"> 52  * or no cipher suite ( or similar ) can be negotiated.</span>

 53  */
 54 // To switch on debugging use:
 55 // @run main/othervm -Djdk.internal.httpclient.debug=true HandshakeFailureTest
 56 public class HandshakeFailureTest {
 57 
 58     // The number of iterations each testXXXClient performs. Can be increased
 59     // when running standalone testing.
 60     static final int TIMES = 10;
 61 


 62     public static void main(String[] args) throws Exception {


 63         HandshakeFailureTest test = new HandshakeFailureTest();
<span class="line-modified"> 64         List&lt;AbstractServer&gt; servers = List.of( new PlainServer(), new SSLServer());</span>
 65 
 66         for (AbstractServer server : servers) {
 67             try (server) {
 68                 out.format(&quot;%n%n------ Testing with server:%s ------%n&quot;, server);
 69                 URI uri = new URI(&quot;https://localhost:&quot; + server.getPort() + &quot;/&quot;);
 70 
 71                 test.testSyncSameClient(uri, Version.HTTP_1_1);
 72                 test.testSyncSameClient(uri, Version.HTTP_2);
 73                 test.testSyncDiffClient(uri, Version.HTTP_1_1);
 74                 test.testSyncDiffClient(uri, Version.HTTP_2);
 75 
 76                 test.testAsyncSameClient(uri, Version.HTTP_1_1);
 77                 test.testAsyncSameClient(uri, Version.HTTP_2);
 78                 test.testAsyncDiffClient(uri, Version.HTTP_1_1);
 79                 test.testAsyncDiffClient(uri, Version.HTTP_2);
 80             }
 81         }
 82     }
 83 
 84     static HttpClient getClient() {
 85         SSLParameters params = new SSLParameters();
<span class="line-modified"> 86         params.setProtocols(new String[] {&quot;TLSv1.2&quot;});</span>
 87         return HttpClient.newBuilder()
 88                 .sslParameters(params)
 89                 .build();
 90     }
 91 
 92     void testSyncSameClient(URI uri, Version version) throws Exception {
 93         out.printf(&quot;%n--- testSyncSameClient %s ---%n&quot;, version);
 94         HttpClient client = getClient();
 95         for (int i = 0; i &lt; TIMES; i++) {
 96             out.printf(&quot;iteration %d%n&quot;, i);
 97             HttpRequest request = HttpRequest.newBuilder(uri)
 98                                              .version(version)
 99                                              .build();
100             try {
101                 HttpResponse&lt;Void&gt; response = client.send(request, discarding());
102                 String msg = String.format(&quot;UNEXPECTED response=%s%n&quot;, response);
103                 throw new RuntimeException(msg);
104             } catch (IOException expected) {
105                 out.printf(&quot;Client: caught expected exception: %s%n&quot;, expected);
<span class="line-modified">106                 checkExceptionOrCause(SSLHandshakeException.class, expected);</span>
107             }
108         }
109     }
110 
111     void testSyncDiffClient(URI uri, Version version) throws Exception {
112         out.printf(&quot;%n--- testSyncDiffClient %s ---%n&quot;, version);
113         for (int i = 0; i &lt; TIMES; i++) {
114             out.printf(&quot;iteration %d%n&quot;, i);
115             // a new client each time
116             HttpClient client = getClient();
117             HttpRequest request = HttpRequest.newBuilder(uri)
118                                              .version(version)
119                                              .build();
120             try {
121                 HttpResponse&lt;Void&gt; response = client.send(request, discarding());
122                 String msg = String.format(&quot;UNEXPECTED response=%s%n&quot;, response);
123                 throw new RuntimeException(msg);
124             } catch (IOException expected) {
125                 out.printf(&quot;Client: caught expected exception: %s%n&quot;, expected);
<span class="line-modified">126                 checkExceptionOrCause(SSLHandshakeException.class, expected);</span>
127             }
128         }
129     }
130 
131     void testAsyncSameClient(URI uri, Version version) throws Exception {
132         out.printf(&quot;%n--- testAsyncSameClient %s ---%n&quot;, version);
133         HttpClient client = getClient();
134         for (int i = 0; i &lt; TIMES; i++) {
135             out.printf(&quot;iteration %d%n&quot;, i);
136             HttpRequest request = HttpRequest.newBuilder(uri)
137                                              .version(version)
138                                              .build();
139             CompletableFuture&lt;HttpResponse&lt;Void&gt;&gt; response =
140                         client.sendAsync(request, discarding());
141             try {
142                 response.join();
143                 String msg = String.format(&quot;UNEXPECTED response=%s%n&quot;, response);
144                 throw new RuntimeException(msg);
145             } catch (CompletionException ce) {
146                 Throwable expected = ce.getCause();
147                 out.printf(&quot;Client: caught expected exception: %s%n&quot;, expected);
<span class="line-modified">148                 checkExceptionOrCause(SSLHandshakeException.class, expected);</span>
149             }
150         }
151     }
152 
153     void testAsyncDiffClient(URI uri, Version version) throws Exception {
154         out.printf(&quot;%n--- testAsyncDiffClient %s ---%n&quot;, version);
155         for (int i = 0; i &lt; TIMES; i++) {
156             out.printf(&quot;iteration %d%n&quot;, i);
157             // a new client each time
158             HttpClient client = getClient();
159             HttpRequest request = HttpRequest.newBuilder(uri)
160                                              .version(version)
161                                              .build();
162             CompletableFuture&lt;HttpResponse&lt;Void&gt;&gt; response =
163                     client.sendAsync(request, discarding());
164             try {
165                 response.join();
166                 String msg = String.format(&quot;UNEXPECTED response=%s%n&quot;, response);
167                 throw new RuntimeException(msg);
168             } catch (CompletionException ce) {
169                 ce.printStackTrace(out);
170                 Throwable expected = ce.getCause();
171                 out.printf(&quot;Client: caught expected exception: %s%n&quot;, expected);
<span class="line-modified">172                 checkExceptionOrCause(SSLHandshakeException.class, expected);</span>
173             }
174         }
175     }
176 
<span class="line-modified">177     static void checkExceptionOrCause(Class&lt;? extends Throwable&gt; clazz, Throwable t) {</span>
178         final Throwable original = t;
179         do {
<span class="line-modified">180             if (clazz.isInstance(t)) {</span>





181                 System.out.println(&quot;Found expected exception/cause: &quot; + t);
182                 return; // found
183             }
184         } while ((t = t.getCause()) != null);
185         original.printStackTrace(System.out);
<span class="line-modified">186         throw new RuntimeException(&quot;Expected &quot; + clazz + &quot;in &quot; + original);</span>


187     }
188 
<span class="line-modified">189     /** Common supertype for PlainServer and SSLServer. */</span>
190     static abstract class AbstractServer extends Thread implements AutoCloseable {
191         protected final ServerSocket ss;
192         protected volatile boolean closed;
193 
194         AbstractServer(String name, ServerSocket ss) throws IOException {
195             super(name);
196             ss.setReuseAddress(false);
197             ss.bind(new InetSocketAddress(InetAddress.getLoopbackAddress(), 0));
198             this.ss = ss;
199             this.start();
200         }
201 
202         int getPort() { return ss.getLocalPort(); }
203 
204         @Override
205         public void close() {
206             if (closed)
207                 return;
208             closed = true;
209             try {
</pre>
<hr />
<pre>
254                     out.println(&quot;Minor:&quot; + minorVersion);
255                     int length = din.readShort();
256                     out.println(&quot;length:&quot; + length);
257                     byte[] ba = new byte[length];
258                     din.readFully(ba);
259 
260                     // simulate various delays in response
261                     Thread.sleep(10 * (count % 10));
262                     s.close(); // close without giving any reply
263                 } catch (IOException e) {
264                     if (!closed)
265                         out.println(&quot;Unexpected&quot; + e);
266                 } catch (InterruptedException e) {
267                     throw new RuntimeException(e);
268                 }
269             }
270         }
271     }
272 
273     /** Emulates a server-side, using SSL Sockets, that will fail during
<span class="line-modified">274      * handshaking, as there are no cipher suites in common. */</span>

275     static class SSLServer extends AbstractServer {
276         static final SSLContext sslContext = createUntrustingContext();
277         static final ServerSocketFactory factory = sslContext.getServerSocketFactory();
278 
279         static SSLContext createUntrustingContext() {
280             try {
<span class="line-modified">281                 SSLContext sslContext = SSLContext.getInstance(&quot;TLSv1.2&quot;);</span>
282                 sslContext.init(null, null, null);
283                 return sslContext;
284             } catch (Throwable t) {
285                 throw new AssertionError(t);
286             }
287         }
288 
289         SSLServer() throws IOException {
290             super(&quot;SSLServer&quot;, factory.createServerSocket());
291         }
292 
293         @Override
294         public void run() {
295             while (!closed) {
296                 try (SSLSocket s = (SSLSocket)ss.accept()) {
297                     s.getInputStream().read();  // will throw SHE here
298 
299                     throw new AssertionError(&quot;Should not reach here&quot;);
300                 } catch (SSLHandshakeException expected) {
<span class="line-modified">301                     // Expected: SSLHandshakeException: no cipher suites in common</span>

302                     out.printf(&quot;Server: caught expected exception: %s%n&quot;, expected);
303                 } catch (IOException e) {
304                     if (!closed)
305                         out.printf(&quot;UNEXPECTED %s&quot;, e);
306                 }
307             }
308         }
309     }
310 }
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2017, 2020, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
<span class="line-modified"> 24 import static java.lang.System.out;</span>
<span class="line-modified"> 25 import static java.net.http.HttpResponse.BodyHandlers.discarding;</span>
<span class="line-modified"> 26 </span>


 27 import java.io.DataInputStream;
 28 import java.io.IOException;
 29 import java.io.UncheckedIOException;
 30 import java.net.InetAddress;
 31 import java.net.InetSocketAddress;
 32 import java.net.ServerSocket;
 33 import java.net.Socket;
<span class="line-added"> 34 import java.net.SocketException;</span>
 35 import java.net.URI;



 36 import java.net.http.HttpClient;
 37 import java.net.http.HttpClient.Version;

 38 import java.net.http.HttpRequest;
<span class="line-modified"> 39 import java.net.http.HttpResponse;</span>
<span class="line-modified"> 40 import java.util.List;</span>
<span class="line-added"> 41 import java.util.concurrent.CompletableFuture;</span>
<span class="line-added"> 42 import java.util.concurrent.CompletionException;</span>
<span class="line-added"> 43 </span>
<span class="line-added"> 44 import javax.net.ServerSocketFactory;</span>
<span class="line-added"> 45 import javax.net.ssl.SSLContext;</span>
<span class="line-added"> 46 import javax.net.ssl.SSLHandshakeException;</span>
<span class="line-added"> 47 import javax.net.ssl.SSLParameters;</span>
<span class="line-added"> 48 import javax.net.ssl.SSLSocket;</span>
 49 
 50 /**
 51  * @test
<span class="line-modified"> 52  * @run main/othervm -Djdk.internal.httpclient.debug=false HandshakeFailureTest TLSv1.2</span>
<span class="line-added"> 53  * @run main/othervm -Djdk.internal.httpclient.debug=false HandshakeFailureTest TLSv1.3</span>
 54  * @summary Verify SSLHandshakeException is received when the handshake fails,
<span class="line-modified"> 55  * either because the server closes (EOF) the connection during handshaking,</span>
<span class="line-modified"> 56  * or no cipher suite can be negotiated (TLSv1.2) or no available authentication</span>
<span class="line-added"> 57  * scheme (TLSv1.3).</span>
 58  */
 59 // To switch on debugging use:
 60 // @run main/othervm -Djdk.internal.httpclient.debug=true HandshakeFailureTest
 61 public class HandshakeFailureTest {
 62 
 63     // The number of iterations each testXXXClient performs. Can be increased
 64     // when running standalone testing.
 65     static final int TIMES = 10;
 66 
<span class="line-added"> 67     private static String tlsProtocol;</span>
<span class="line-added"> 68 </span>
 69     public static void main(String[] args) throws Exception {
<span class="line-added"> 70         tlsProtocol = args[0];</span>
<span class="line-added"> 71 </span>
 72         HandshakeFailureTest test = new HandshakeFailureTest();
<span class="line-modified"> 73         List&lt;AbstractServer&gt; servers = List.of(new PlainServer(), new SSLServer());</span>
 74 
 75         for (AbstractServer server : servers) {
 76             try (server) {
 77                 out.format(&quot;%n%n------ Testing with server:%s ------%n&quot;, server);
 78                 URI uri = new URI(&quot;https://localhost:&quot; + server.getPort() + &quot;/&quot;);
 79 
 80                 test.testSyncSameClient(uri, Version.HTTP_1_1);
 81                 test.testSyncSameClient(uri, Version.HTTP_2);
 82                 test.testSyncDiffClient(uri, Version.HTTP_1_1);
 83                 test.testSyncDiffClient(uri, Version.HTTP_2);
 84 
 85                 test.testAsyncSameClient(uri, Version.HTTP_1_1);
 86                 test.testAsyncSameClient(uri, Version.HTTP_2);
 87                 test.testAsyncDiffClient(uri, Version.HTTP_1_1);
 88                 test.testAsyncDiffClient(uri, Version.HTTP_2);
 89             }
 90         }
 91     }
 92 
 93     static HttpClient getClient() {
 94         SSLParameters params = new SSLParameters();
<span class="line-modified"> 95         params.setProtocols(new String[] { tlsProtocol });</span>
 96         return HttpClient.newBuilder()
 97                 .sslParameters(params)
 98                 .build();
 99     }
100 
101     void testSyncSameClient(URI uri, Version version) throws Exception {
102         out.printf(&quot;%n--- testSyncSameClient %s ---%n&quot;, version);
103         HttpClient client = getClient();
104         for (int i = 0; i &lt; TIMES; i++) {
105             out.printf(&quot;iteration %d%n&quot;, i);
106             HttpRequest request = HttpRequest.newBuilder(uri)
107                                              .version(version)
108                                              .build();
109             try {
110                 HttpResponse&lt;Void&gt; response = client.send(request, discarding());
111                 String msg = String.format(&quot;UNEXPECTED response=%s%n&quot;, response);
112                 throw new RuntimeException(msg);
113             } catch (IOException expected) {
114                 out.printf(&quot;Client: caught expected exception: %s%n&quot;, expected);
<span class="line-modified">115                 checkExceptionOrCause(expected);</span>
116             }
117         }
118     }
119 
120     void testSyncDiffClient(URI uri, Version version) throws Exception {
121         out.printf(&quot;%n--- testSyncDiffClient %s ---%n&quot;, version);
122         for (int i = 0; i &lt; TIMES; i++) {
123             out.printf(&quot;iteration %d%n&quot;, i);
124             // a new client each time
125             HttpClient client = getClient();
126             HttpRequest request = HttpRequest.newBuilder(uri)
127                                              .version(version)
128                                              .build();
129             try {
130                 HttpResponse&lt;Void&gt; response = client.send(request, discarding());
131                 String msg = String.format(&quot;UNEXPECTED response=%s%n&quot;, response);
132                 throw new RuntimeException(msg);
133             } catch (IOException expected) {
134                 out.printf(&quot;Client: caught expected exception: %s%n&quot;, expected);
<span class="line-modified">135                 checkExceptionOrCause(expected);</span>
136             }
137         }
138     }
139 
140     void testAsyncSameClient(URI uri, Version version) throws Exception {
141         out.printf(&quot;%n--- testAsyncSameClient %s ---%n&quot;, version);
142         HttpClient client = getClient();
143         for (int i = 0; i &lt; TIMES; i++) {
144             out.printf(&quot;iteration %d%n&quot;, i);
145             HttpRequest request = HttpRequest.newBuilder(uri)
146                                              .version(version)
147                                              .build();
148             CompletableFuture&lt;HttpResponse&lt;Void&gt;&gt; response =
149                         client.sendAsync(request, discarding());
150             try {
151                 response.join();
152                 String msg = String.format(&quot;UNEXPECTED response=%s%n&quot;, response);
153                 throw new RuntimeException(msg);
154             } catch (CompletionException ce) {
155                 Throwable expected = ce.getCause();
156                 out.printf(&quot;Client: caught expected exception: %s%n&quot;, expected);
<span class="line-modified">157                 checkExceptionOrCause(expected);</span>
158             }
159         }
160     }
161 
162     void testAsyncDiffClient(URI uri, Version version) throws Exception {
163         out.printf(&quot;%n--- testAsyncDiffClient %s ---%n&quot;, version);
164         for (int i = 0; i &lt; TIMES; i++) {
165             out.printf(&quot;iteration %d%n&quot;, i);
166             // a new client each time
167             HttpClient client = getClient();
168             HttpRequest request = HttpRequest.newBuilder(uri)
169                                              .version(version)
170                                              .build();
171             CompletableFuture&lt;HttpResponse&lt;Void&gt;&gt; response =
172                     client.sendAsync(request, discarding());
173             try {
174                 response.join();
175                 String msg = String.format(&quot;UNEXPECTED response=%s%n&quot;, response);
176                 throw new RuntimeException(msg);
177             } catch (CompletionException ce) {
178                 ce.printStackTrace(out);
179                 Throwable expected = ce.getCause();
180                 out.printf(&quot;Client: caught expected exception: %s%n&quot;, expected);
<span class="line-modified">181                 checkExceptionOrCause(expected);</span>
182             }
183         }
184     }
185 
<span class="line-modified">186     static void checkExceptionOrCause(Throwable t) {</span>
187         final Throwable original = t;
188         do {
<span class="line-modified">189             if (SSLHandshakeException.class.isInstance(t)</span>
<span class="line-added">190                     // For TLSv1.3, possibly the server is (being) closed when</span>
<span class="line-added">191                     // the client read the input alert. In this case, the client</span>
<span class="line-added">192                     // just gets SocketException instead of SSLHandshakeException.</span>
<span class="line-added">193                     || (tlsProtocol.equalsIgnoreCase(&quot;TLSv1.3&quot;)</span>
<span class="line-added">194                             &amp;&amp; SocketException.class.isInstance(t))) {</span>
195                 System.out.println(&quot;Found expected exception/cause: &quot; + t);
196                 return; // found
197             }
198         } while ((t = t.getCause()) != null);
199         original.printStackTrace(System.out);
<span class="line-modified">200         throw new RuntimeException(</span>
<span class="line-added">201                 &quot;Not found expected SSLHandshakeException or SocketException in &quot;</span>
<span class="line-added">202                         + original);</span>
203     }
204 
<span class="line-modified">205     /** Common super type for PlainServer and SSLServer. */</span>
206     static abstract class AbstractServer extends Thread implements AutoCloseable {
207         protected final ServerSocket ss;
208         protected volatile boolean closed;
209 
210         AbstractServer(String name, ServerSocket ss) throws IOException {
211             super(name);
212             ss.setReuseAddress(false);
213             ss.bind(new InetSocketAddress(InetAddress.getLoopbackAddress(), 0));
214             this.ss = ss;
215             this.start();
216         }
217 
218         int getPort() { return ss.getLocalPort(); }
219 
220         @Override
221         public void close() {
222             if (closed)
223                 return;
224             closed = true;
225             try {
</pre>
<hr />
<pre>
270                     out.println(&quot;Minor:&quot; + minorVersion);
271                     int length = din.readShort();
272                     out.println(&quot;length:&quot; + length);
273                     byte[] ba = new byte[length];
274                     din.readFully(ba);
275 
276                     // simulate various delays in response
277                     Thread.sleep(10 * (count % 10));
278                     s.close(); // close without giving any reply
279                 } catch (IOException e) {
280                     if (!closed)
281                         out.println(&quot;Unexpected&quot; + e);
282                 } catch (InterruptedException e) {
283                     throw new RuntimeException(e);
284                 }
285             }
286         }
287     }
288 
289     /** Emulates a server-side, using SSL Sockets, that will fail during
<span class="line-modified">290      * handshaking, as there are no cipher suites in common (TLSv1.2)</span>
<span class="line-added">291      * or no available authentication scheme (TLSv1.3). */</span>
292     static class SSLServer extends AbstractServer {
293         static final SSLContext sslContext = createUntrustingContext();
294         static final ServerSocketFactory factory = sslContext.getServerSocketFactory();
295 
296         static SSLContext createUntrustingContext() {
297             try {
<span class="line-modified">298                 SSLContext sslContext = SSLContext.getInstance(&quot;TLS&quot;);</span>
299                 sslContext.init(null, null, null);
300                 return sslContext;
301             } catch (Throwable t) {
302                 throw new AssertionError(t);
303             }
304         }
305 
306         SSLServer() throws IOException {
307             super(&quot;SSLServer&quot;, factory.createServerSocket());
308         }
309 
310         @Override
311         public void run() {
312             while (!closed) {
313                 try (SSLSocket s = (SSLSocket)ss.accept()) {
314                     s.getInputStream().read();  // will throw SHE here
315 
316                     throw new AssertionError(&quot;Should not reach here&quot;);
317                 } catch (SSLHandshakeException expected) {
<span class="line-modified">318                     // Expected: SSLHandshakeException: no cipher suites in common (TLSv1.2)</span>
<span class="line-added">319                     // or no available authentication scheme (TLSv1.3)</span>
320                     out.printf(&quot;Server: caught expected exception: %s%n&quot;, expected);
321                 } catch (IOException e) {
322                     if (!closed)
323                         out.printf(&quot;UNEXPECTED %s&quot;, e);
324                 }
325             }
326         }
327     }
328 }
</pre>
</td>
</tr>
</table>
<center><a href="DigestEchoServer.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="HttpResponseInputStreamTest.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff test/jdk/java/net/httpclient/HandshakeFailureTest.java</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
<body>
<center><a href="DigestEchoServer.java.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="HttpResponseInputStreamTest.java.cdiff.html" target="_top">next &gt;</a></center>    <h2>test/jdk/java/net/httpclient/HandshakeFailureTest.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 1,7 ***</span>
  /*
<span class="line-modified">!  * Copyright (c) 2017, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.
<span class="line-new-header">--- 1,7 ---</span>
  /*
<span class="line-modified">!  * Copyright (c) 2017, 2020, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 19,51 ***</span>
   * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
   * or visit www.oracle.com if you need additional information or have any
   * questions.
   */
  
<span class="line-modified">! import javax.net.ServerSocketFactory;</span>
<span class="line-modified">! import javax.net.ssl.SSLContext;</span>
<span class="line-modified">! import javax.net.ssl.SSLParameters;</span>
<span class="line-removed">- import javax.net.ssl.SSLHandshakeException;</span>
<span class="line-removed">- import javax.net.ssl.SSLSocket;</span>
  import java.io.DataInputStream;
  import java.io.IOException;
  import java.io.UncheckedIOException;
  import java.net.InetAddress;
  import java.net.InetSocketAddress;
  import java.net.ServerSocket;
  import java.net.Socket;
  import java.net.URI;
<span class="line-removed">- import java.util.List;</span>
<span class="line-removed">- import java.util.concurrent.CompletableFuture;</span>
<span class="line-removed">- import java.util.concurrent.CompletionException;</span>
  import java.net.http.HttpClient;
  import java.net.http.HttpClient.Version;
<span class="line-removed">- import java.net.http.HttpResponse;</span>
  import java.net.http.HttpRequest;
<span class="line-modified">! import static java.lang.System.out;</span>
<span class="line-modified">! import static java.net.http.HttpResponse.BodyHandlers.discarding;</span>
  
  /**
   * @test
<span class="line-modified">!  * @run main/othervm -Djdk.internal.httpclient.debug=true HandshakeFailureTest</span>
   * @summary Verify SSLHandshakeException is received when the handshake fails,
<span class="line-modified">!  * either because the server closes ( EOF ) the connection during handshaking</span>
<span class="line-modified">!  * or no cipher suite ( or similar ) can be negotiated.</span>
   */
  // To switch on debugging use:
  // @run main/othervm -Djdk.internal.httpclient.debug=true HandshakeFailureTest
  public class HandshakeFailureTest {
  
      // The number of iterations each testXXXClient performs. Can be increased
      // when running standalone testing.
      static final int TIMES = 10;
  
      public static void main(String[] args) throws Exception {
          HandshakeFailureTest test = new HandshakeFailureTest();
<span class="line-modified">!         List&lt;AbstractServer&gt; servers = List.of( new PlainServer(), new SSLServer());</span>
  
          for (AbstractServer server : servers) {
              try (server) {
                  out.format(&quot;%n%n------ Testing with server:%s ------%n&quot;, server);
                  URI uri = new URI(&quot;https://localhost:&quot; + server.getPort() + &quot;/&quot;);
<span class="line-new-header">--- 19,60 ---</span>
   * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
   * or visit www.oracle.com if you need additional information or have any
   * questions.
   */
  
<span class="line-modified">! import static java.lang.System.out;</span>
<span class="line-modified">! import static java.net.http.HttpResponse.BodyHandlers.discarding;</span>
<span class="line-modified">! </span>
  import java.io.DataInputStream;
  import java.io.IOException;
  import java.io.UncheckedIOException;
  import java.net.InetAddress;
  import java.net.InetSocketAddress;
  import java.net.ServerSocket;
  import java.net.Socket;
<span class="line-added">+ import java.net.SocketException;</span>
  import java.net.URI;
  import java.net.http.HttpClient;
  import java.net.http.HttpClient.Version;
  import java.net.http.HttpRequest;
<span class="line-modified">! import java.net.http.HttpResponse;</span>
<span class="line-modified">! import java.util.List;</span>
<span class="line-added">+ import java.util.concurrent.CompletableFuture;</span>
<span class="line-added">+ import java.util.concurrent.CompletionException;</span>
<span class="line-added">+ </span>
<span class="line-added">+ import javax.net.ServerSocketFactory;</span>
<span class="line-added">+ import javax.net.ssl.SSLContext;</span>
<span class="line-added">+ import javax.net.ssl.SSLHandshakeException;</span>
<span class="line-added">+ import javax.net.ssl.SSLParameters;</span>
<span class="line-added">+ import javax.net.ssl.SSLSocket;</span>
  
  /**
   * @test
<span class="line-modified">!  * @run main/othervm -Djdk.internal.httpclient.debug=false HandshakeFailureTest TLSv1.2</span>
<span class="line-added">+  * @run main/othervm -Djdk.internal.httpclient.debug=false HandshakeFailureTest TLSv1.3</span>
   * @summary Verify SSLHandshakeException is received when the handshake fails,
<span class="line-modified">!  * either because the server closes (EOF) the connection during handshaking,</span>
<span class="line-modified">!  * or no cipher suite can be negotiated (TLSv1.2) or no available authentication</span>
<span class="line-added">+  * scheme (TLSv1.3).</span>
   */
  // To switch on debugging use:
  // @run main/othervm -Djdk.internal.httpclient.debug=true HandshakeFailureTest
  public class HandshakeFailureTest {
  
      // The number of iterations each testXXXClient performs. Can be increased
      // when running standalone testing.
      static final int TIMES = 10;
  
<span class="line-added">+     private static String tlsProtocol;</span>
<span class="line-added">+ </span>
      public static void main(String[] args) throws Exception {
<span class="line-added">+         tlsProtocol = args[0];</span>
<span class="line-added">+ </span>
          HandshakeFailureTest test = new HandshakeFailureTest();
<span class="line-modified">!         List&lt;AbstractServer&gt; servers = List.of(new PlainServer(), new SSLServer());</span>
  
          for (AbstractServer server : servers) {
              try (server) {
                  out.format(&quot;%n%n------ Testing with server:%s ------%n&quot;, server);
                  URI uri = new URI(&quot;https://localhost:&quot; + server.getPort() + &quot;/&quot;);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 81,11 ***</span>
          }
      }
  
      static HttpClient getClient() {
          SSLParameters params = new SSLParameters();
<span class="line-modified">!         params.setProtocols(new String[] {&quot;TLSv1.2&quot;});</span>
          return HttpClient.newBuilder()
                  .sslParameters(params)
                  .build();
      }
  
<span class="line-new-header">--- 90,11 ---</span>
          }
      }
  
      static HttpClient getClient() {
          SSLParameters params = new SSLParameters();
<span class="line-modified">!         params.setProtocols(new String[] { tlsProtocol });</span>
          return HttpClient.newBuilder()
                  .sslParameters(params)
                  .build();
      }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 101,11 ***</span>
                  HttpResponse&lt;Void&gt; response = client.send(request, discarding());
                  String msg = String.format(&quot;UNEXPECTED response=%s%n&quot;, response);
                  throw new RuntimeException(msg);
              } catch (IOException expected) {
                  out.printf(&quot;Client: caught expected exception: %s%n&quot;, expected);
<span class="line-modified">!                 checkExceptionOrCause(SSLHandshakeException.class, expected);</span>
              }
          }
      }
  
      void testSyncDiffClient(URI uri, Version version) throws Exception {
<span class="line-new-header">--- 110,11 ---</span>
                  HttpResponse&lt;Void&gt; response = client.send(request, discarding());
                  String msg = String.format(&quot;UNEXPECTED response=%s%n&quot;, response);
                  throw new RuntimeException(msg);
              } catch (IOException expected) {
                  out.printf(&quot;Client: caught expected exception: %s%n&quot;, expected);
<span class="line-modified">!                 checkExceptionOrCause(expected);</span>
              }
          }
      }
  
      void testSyncDiffClient(URI uri, Version version) throws Exception {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 121,11 ***</span>
                  HttpResponse&lt;Void&gt; response = client.send(request, discarding());
                  String msg = String.format(&quot;UNEXPECTED response=%s%n&quot;, response);
                  throw new RuntimeException(msg);
              } catch (IOException expected) {
                  out.printf(&quot;Client: caught expected exception: %s%n&quot;, expected);
<span class="line-modified">!                 checkExceptionOrCause(SSLHandshakeException.class, expected);</span>
              }
          }
      }
  
      void testAsyncSameClient(URI uri, Version version) throws Exception {
<span class="line-new-header">--- 130,11 ---</span>
                  HttpResponse&lt;Void&gt; response = client.send(request, discarding());
                  String msg = String.format(&quot;UNEXPECTED response=%s%n&quot;, response);
                  throw new RuntimeException(msg);
              } catch (IOException expected) {
                  out.printf(&quot;Client: caught expected exception: %s%n&quot;, expected);
<span class="line-modified">!                 checkExceptionOrCause(expected);</span>
              }
          }
      }
  
      void testAsyncSameClient(URI uri, Version version) throws Exception {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 143,11 ***</span>
                  String msg = String.format(&quot;UNEXPECTED response=%s%n&quot;, response);
                  throw new RuntimeException(msg);
              } catch (CompletionException ce) {
                  Throwable expected = ce.getCause();
                  out.printf(&quot;Client: caught expected exception: %s%n&quot;, expected);
<span class="line-modified">!                 checkExceptionOrCause(SSLHandshakeException.class, expected);</span>
              }
          }
      }
  
      void testAsyncDiffClient(URI uri, Version version) throws Exception {
<span class="line-new-header">--- 152,11 ---</span>
                  String msg = String.format(&quot;UNEXPECTED response=%s%n&quot;, response);
                  throw new RuntimeException(msg);
              } catch (CompletionException ce) {
                  Throwable expected = ce.getCause();
                  out.printf(&quot;Client: caught expected exception: %s%n&quot;, expected);
<span class="line-modified">!                 checkExceptionOrCause(expected);</span>
              }
          }
      }
  
      void testAsyncDiffClient(URI uri, Version version) throws Exception {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 167,28 ***</span>
                  throw new RuntimeException(msg);
              } catch (CompletionException ce) {
                  ce.printStackTrace(out);
                  Throwable expected = ce.getCause();
                  out.printf(&quot;Client: caught expected exception: %s%n&quot;, expected);
<span class="line-modified">!                 checkExceptionOrCause(SSLHandshakeException.class, expected);</span>
              }
          }
      }
  
<span class="line-modified">!     static void checkExceptionOrCause(Class&lt;? extends Throwable&gt; clazz, Throwable t) {</span>
          final Throwable original = t;
          do {
<span class="line-modified">!             if (clazz.isInstance(t)) {</span>
                  System.out.println(&quot;Found expected exception/cause: &quot; + t);
                  return; // found
              }
          } while ((t = t.getCause()) != null);
          original.printStackTrace(System.out);
<span class="line-modified">!         throw new RuntimeException(&quot;Expected &quot; + clazz + &quot;in &quot; + original);</span>
      }
  
<span class="line-modified">!     /** Common supertype for PlainServer and SSLServer. */</span>
      static abstract class AbstractServer extends Thread implements AutoCloseable {
          protected final ServerSocket ss;
          protected volatile boolean closed;
  
          AbstractServer(String name, ServerSocket ss) throws IOException {
<span class="line-new-header">--- 176,35 ---</span>
                  throw new RuntimeException(msg);
              } catch (CompletionException ce) {
                  ce.printStackTrace(out);
                  Throwable expected = ce.getCause();
                  out.printf(&quot;Client: caught expected exception: %s%n&quot;, expected);
<span class="line-modified">!                 checkExceptionOrCause(expected);</span>
              }
          }
      }
  
<span class="line-modified">!     static void checkExceptionOrCause(Throwable t) {</span>
          final Throwable original = t;
          do {
<span class="line-modified">!             if (SSLHandshakeException.class.isInstance(t)</span>
<span class="line-added">+                     // For TLSv1.3, possibly the server is (being) closed when</span>
<span class="line-added">+                     // the client read the input alert. In this case, the client</span>
<span class="line-added">+                     // just gets SocketException instead of SSLHandshakeException.</span>
<span class="line-added">+                     || (tlsProtocol.equalsIgnoreCase(&quot;TLSv1.3&quot;)</span>
<span class="line-added">+                             &amp;&amp; SocketException.class.isInstance(t))) {</span>
                  System.out.println(&quot;Found expected exception/cause: &quot; + t);
                  return; // found
              }
          } while ((t = t.getCause()) != null);
          original.printStackTrace(System.out);
<span class="line-modified">!         throw new RuntimeException(</span>
<span class="line-added">+                 &quot;Not found expected SSLHandshakeException or SocketException in &quot;</span>
<span class="line-added">+                         + original);</span>
      }
  
<span class="line-modified">!     /** Common super type for PlainServer and SSLServer. */</span>
      static abstract class AbstractServer extends Thread implements AutoCloseable {
          protected final ServerSocket ss;
          protected volatile boolean closed;
  
          AbstractServer(String name, ServerSocket ss) throws IOException {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 269,18 ***</span>
              }
          }
      }
  
      /** Emulates a server-side, using SSL Sockets, that will fail during
<span class="line-modified">!      * handshaking, as there are no cipher suites in common. */</span>
      static class SSLServer extends AbstractServer {
          static final SSLContext sslContext = createUntrustingContext();
          static final ServerSocketFactory factory = sslContext.getServerSocketFactory();
  
          static SSLContext createUntrustingContext() {
              try {
<span class="line-modified">!                 SSLContext sslContext = SSLContext.getInstance(&quot;TLSv1.2&quot;);</span>
                  sslContext.init(null, null, null);
                  return sslContext;
              } catch (Throwable t) {
                  throw new AssertionError(t);
              }
<span class="line-new-header">--- 285,19 ---</span>
              }
          }
      }
  
      /** Emulates a server-side, using SSL Sockets, that will fail during
<span class="line-modified">!      * handshaking, as there are no cipher suites in common (TLSv1.2)</span>
<span class="line-added">+      * or no available authentication scheme (TLSv1.3). */</span>
      static class SSLServer extends AbstractServer {
          static final SSLContext sslContext = createUntrustingContext();
          static final ServerSocketFactory factory = sslContext.getServerSocketFactory();
  
          static SSLContext createUntrustingContext() {
              try {
<span class="line-modified">!                 SSLContext sslContext = SSLContext.getInstance(&quot;TLS&quot;);</span>
                  sslContext.init(null, null, null);
                  return sslContext;
              } catch (Throwable t) {
                  throw new AssertionError(t);
              }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 296,11 ***</span>
                  try (SSLSocket s = (SSLSocket)ss.accept()) {
                      s.getInputStream().read();  // will throw SHE here
  
                      throw new AssertionError(&quot;Should not reach here&quot;);
                  } catch (SSLHandshakeException expected) {
<span class="line-modified">!                     // Expected: SSLHandshakeException: no cipher suites in common</span>
                      out.printf(&quot;Server: caught expected exception: %s%n&quot;, expected);
                  } catch (IOException e) {
                      if (!closed)
                          out.printf(&quot;UNEXPECTED %s&quot;, e);
                  }
<span class="line-new-header">--- 313,12 ---</span>
                  try (SSLSocket s = (SSLSocket)ss.accept()) {
                      s.getInputStream().read();  // will throw SHE here
  
                      throw new AssertionError(&quot;Should not reach here&quot;);
                  } catch (SSLHandshakeException expected) {
<span class="line-modified">!                     // Expected: SSLHandshakeException: no cipher suites in common (TLSv1.2)</span>
<span class="line-added">+                     // or no available authentication scheme (TLSv1.3)</span>
                      out.printf(&quot;Server: caught expected exception: %s%n&quot;, expected);
                  } catch (IOException e) {
                      if (!closed)
                          out.printf(&quot;UNEXPECTED %s&quot;, e);
                  }
</pre>
<center><a href="DigestEchoServer.java.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="HttpResponseInputStreamTest.java.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
diff a/test/jdk/java/net/httpclient/SmokeTest.java b/test/jdk/java/net/httpclient/SmokeTest.java
--- a/test/jdk/java/net/httpclient/SmokeTest.java
+++ b/test/jdk/java/net/httpclient/SmokeTest.java
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2015, 2018, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2015, 2019, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.
@@ -28,11 +28,10 @@
  *          java.logging
  *          jdk.httpserver
  * @library /test/lib /
  * @build jdk.test.lib.net.SimpleSSLContext ProxyServer
  * @compile ../../../com/sun/net/httpserver/LogFilter.java
- * @compile ../../../com/sun/net/httpserver/EchoHandler.java
  * @compile ../../../com/sun/net/httpserver/FileServerHandler.java
  * @run main/othervm
  *      -Djdk.internal.httpclient.debug=true
  *      -Djdk.httpclient.HttpClient.log=errors,ssl,trace
  *      SmokeTest
@@ -48,11 +47,14 @@
 import com.sun.net.httpserver.HttpsServer;
 
 import java.net.InetAddress;
 import java.net.Proxy;
 import java.net.SocketAddress;
+import java.net.http.HttpHeaders;
+import java.nio.charset.StandardCharsets;
 import java.util.Collections;
+import java.util.Optional;
 import java.util.Set;
 import java.util.concurrent.atomic.AtomicInteger;
 import java.net.InetSocketAddress;
 import java.net.PasswordAuthentication;
 import java.net.ProxySelector;
@@ -133,10 +135,26 @@
     final static String smallFilename = "/files/smallfile.txt";
     static Path midSizedFile;
     static Path smallFile;
     static String fileroot;
 
+    static class HttpEchoHandler implements HttpHandler {
+
+        @Override
+        public void handle(HttpExchange exchange) throws IOException {
+            try (InputStream is = exchange.getRequestBody();
+                 OutputStream os = exchange.getResponseBody()) {
+                byte[] bytes = is.readAllBytes();
+                long responseLength = bytes.length == 0 ? -1 : bytes.length;
+                boolean fixedLength = "yes".equals(exchange.getRequestHeaders()
+                        .getFirst("XFixed"));
+                exchange.sendResponseHeaders(200, fixedLength ? responseLength : 0);
+                os.write(bytes);
+            }
+        }
+    }
+
     static String getFileContent(String path) throws IOException {
         FileInputStream fis = new FileInputStream(path);
         byte[] buf = new byte[2000];
         StringBuilder sb = new StringBuilder();
         int n;
@@ -255,10 +273,12 @@
 
         HttpRequest request = builder.build();
 
         HttpResponse<String> response = client.send(request, BodyHandlers.ofString());
 
+        checkResponseContentLength(response.headers(), fixedLen);
+
         String body = response.body();
         if (!body.equals("This is foo.txt\r\n")) {
             throw new RuntimeException("Did not get expected body: "
                 + "\n\t expected \"This is foo.txt\\r\\n\""
                 + "\n\t received \""
@@ -502,10 +522,12 @@
 
         HttpRequest request = builder.build();
 
         HttpResponse<String> response = client.send(request, BodyHandlers.ofString());
 
+        checkResponseContentLength(response.headers(), fixedLen);
+
         String body = response.body();
 
         if (!body.equals(requestBody)) {
             throw new RuntimeException(
                     "Body mismatch: expected [" + body + "], got [" + body + "]");
@@ -527,10 +549,12 @@
 
         HttpRequest request = builder.build();
 
         HttpResponse<String> response = client.send(request, BodyHandlers.ofString());
 
+        checkResponseContentLength(response.headers(), fixedLen);
+
         if (response.statusCode() != 200) {
             throw new RuntimeException(
                     "Expected 200, got [ " + response.statusCode() + " ]");
         }
 
@@ -692,11 +716,11 @@
         CompletableFuture<HttpResponse<String>> cf =
                 client.sendAsync(request, BodyHandlers.ofString());
 
         try {
             HttpResponse<String> response = cf.join();
-            throw new RuntimeException("Exepected Completion Exception");
+            throw new RuntimeException("Expected Completion Exception");
         } catch (CompletionException e) {
             //System.out.println(e);
         }
 
         System.out.printf(" (Calls %d) ", handler.count());
@@ -737,16 +761,16 @@
         s2 = HttpsServer.create (addr, 0);
         HttpHandler h = new FileServerHandler(root);
 
         HttpContext c1 = s1.createContext("/files", h);
         HttpContext c2 = s2.createContext("/files", h);
-        HttpContext c3 = s1.createContext("/echo", new EchoHandler());
+        HttpContext c3 = s1.createContext("/echo", new HttpEchoHandler());
         redirectHandler = new RedirectHandler("/redirect");
         redirectHandlerSecure = new RedirectHandler("/redirect");
         HttpContext c4 = s1.createContext("/redirect", redirectHandler);
         HttpContext c41 = s2.createContext("/redirect", redirectHandlerSecure);
-        HttpContext c5 = s2.createContext("/echo", new EchoHandler());
+        HttpContext c5 = s2.createContext("/echo", new HttpEchoHandler());
         HttpContext c6 = s1.createContext("/keepalive", new KeepAliveHandler());
         redirectErrorHandler = new RedirectErrorHandler("/redirecterror");
         redirectErrorHandlerSecure = new RedirectErrorHandler("/redirecterror");
         HttpContext c7 = s1.createContext("/redirecterror", redirectErrorHandler);
         HttpContext c71 = s2.createContext("/redirecterror", redirectErrorHandlerSecure);
@@ -774,23 +798,35 @@
         proxy = new ProxyServer(0, false);
         proxyPort = proxy.getPort();
         System.out.println("Proxy port = " + proxyPort);
     }
 
+    static void checkResponseContentLength(HttpHeaders responseHeaders, boolean fixedLen) {
+        Optional<String> transferEncoding = responseHeaders.firstValue("transfer-encoding");
+        Optional<String> contentLength = responseHeaders.firstValue("content-length");
+        if (fixedLen) {
+            assert contentLength.isPresent();
+            assert !transferEncoding.isPresent();
+        } else {
+            assert !contentLength.isPresent();
+            assert transferEncoding.isPresent();
+            assert "chunked".equals(transferEncoding.get());
+        }
+    }
+
     static class RedirectHandler implements HttpHandler {
         private final String root;
         private volatile int count = 0;
 
         RedirectHandler(String root) {
             this.root = root;
         }
 
         @Override
         public synchronized void handle(HttpExchange t) throws IOException {
-            byte[] buf = new byte[2048];
             try (InputStream is = t.getRequestBody()) {
-                while (is.read(buf) != -1) ;
+                is.readAllBytes();
             }
 
             Headers responseHeaders = t.getResponseHeaders();
 
             if (count++ < 1) {
@@ -1008,17 +1044,16 @@
                         + remotePort + " not in " + portSet);
                 result = "Error " + Integer.toString(n);
                 System.out.println(result);
             }
         }
-        byte[] buf = new byte[2048];
 
         try (InputStream is = t.getRequestBody()) {
-            while (is.read(buf) != -1) ;
+            is.readAllBytes();
         }
         t.sendResponseHeaders(200, result.length());
         OutputStream o = t.getResponseBody();
-        o.write(result.getBytes("US-ASCII"));
+        o.write(result.getBytes(StandardCharsets.UTF_8));
         t.close();
         nparallel.getAndDecrement();
     }
 }

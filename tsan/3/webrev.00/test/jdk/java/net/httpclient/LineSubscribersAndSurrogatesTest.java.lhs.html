<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames test/jdk/java/net/httpclient/LineSubscribersAndSurrogatesTest.java</title>
    <link rel="stylesheet" href="../../../../../style.css" />
    <script type="text/javascript" src="../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
<a name="1" id="anc1"></a><span class="line-modified">  2  * Copyright (c) 2018, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 import java.io.BufferedReader;
 25 import java.io.ByteArrayInputStream;
 26 import java.io.ByteArrayOutputStream;
 27 import java.io.IOException;
 28 import java.io.InputStreamReader;
 29 import java.io.StringReader;
 30 import java.io.UncheckedIOException;
 31 import java.net.http.HttpResponse.BodySubscriber;
 32 import java.net.http.HttpResponse.BodySubscribers;
 33 import java.nio.ByteBuffer;
 34 import java.nio.charset.MalformedInputException;
 35 import java.util.ArrayList;
 36 import java.util.Arrays;
 37 import java.util.List;
 38 import java.util.concurrent.CopyOnWriteArrayList;
 39 import java.util.concurrent.ExecutionException;
 40 import java.util.concurrent.Flow;
 41 import java.util.concurrent.SubmissionPublisher;
 42 import java.util.function.Supplier;
 43 import java.util.stream.Collectors;
 44 import java.util.stream.Stream;
 45 import org.testng.annotations.Test;
 46 import static java.nio.charset.StandardCharsets.UTF_8;
 47 import static java.nio.charset.StandardCharsets.UTF_16;
 48 import static org.testng.Assert.assertEquals;
 49 
 50 /*
 51  * @test
 52  * @summary tests for BodySubscribers returned by fromLineSubscriber.
 53  *       In particular tests that surrogate characters are handled
 54  *       correctly.
 55  * @modules java.net.http java.logging
 56  * @run testng/othervm LineSubscribersAndSurrogatesTest
 57  */
 58 
 59 public class LineSubscribersAndSurrogatesTest {
 60 
 61 
 62     static final Class&lt;NullPointerException&gt; NPE = NullPointerException.class;
 63 
 64     private static final List&lt;String&gt; lines(String text, String eol) {
 65         if (eol == null) {
 66             return new BufferedReader(new StringReader(text)).lines().collect(Collectors.toList());
 67         } else {
 68             String replaced = text.replace(eol, &quot;|&quot;);
 69             int i=0;
 70             while(replaced.endsWith(&quot;||&quot;)) {
 71                 replaced = replaced.substring(0,replaced.length()-1);
 72                 i++;
 73             }
 74             List&lt;String&gt; res = List.of(replaced.split(&quot;\\|&quot;));
 75             if (i &gt; 0) {
 76                 res = new ArrayList&lt;&gt;(res);
 77                 for (int j=0; j&lt;i; j++) res.add(&quot;&quot;);
 78             }
 79             return res;
 80         }
 81     }
 82 
 83     @Test
<a name="2" id="anc2"></a><span class="line-modified"> 84     void testIncomplete() throws Exception {</span>
 85         // Uses U+10400 which is encoded as the surrogate pair U+D801 U+DC00
 86         String text = &quot;Bient\u00f4t\r\n nous plongerons\r\n dans\r&quot; +
 87                 &quot; les\n\n fr\u00f4\ud801\udc00des\r\n t\u00e9n\u00e8bres\ud801\udc00&quot;;
 88         ObjectSubscriber subscriber = new ObjectSubscriber();
 89         BodySubscriber&lt;String&gt; bodySubscriber = BodySubscribers.fromLineSubscriber(
 90                 subscriber, Supplier::get, UTF_8, null);
 91         SubmissionPublisher&lt;List&lt;ByteBuffer&gt;&gt; publisher = new SubmissionPublisher&lt;&gt;();
 92         byte[] sbytes = text.getBytes(UTF_8);
 93         byte[] bytes = Arrays.copyOfRange(sbytes,0, sbytes.length - 1);
 94         publisher.subscribe(bodySubscriber);
 95         System.out.println(&quot;Publishing &quot; + bytes.length + &quot; bytes&quot;);
 96         for (int i=0; i&lt;bytes.length; i++) {
 97             // ensure that surrogates are split over several buffers.
 98             publisher.submit(List.of(ByteBuffer.wrap(bytes, i, 1)));
 99         }
100         publisher.close();
101         try {
102             String resp = bodySubscriber.getBody().toCompletableFuture().get();
103             System.out.println(&quot;***** Got: &quot; + resp);
104             ByteArrayInputStream bais = new ByteArrayInputStream(bytes);
105             BufferedReader reader = new BufferedReader(new InputStreamReader(bais, UTF_8));
106             String resp2 = reader.lines().collect(Collectors.joining(&quot;&quot;));
107             assertEquals(resp, resp2);
108             assertEquals(subscriber.list, List.of(&quot;Bient\u00f4t&quot;,
109                     &quot; nous plongerons&quot;,
110                     &quot; dans&quot;,
111                     &quot; les&quot;,
112                     &quot;&quot;,
113                     &quot; fr\u00f4\ud801\udc00des&quot;,
114                     &quot; t\u00e9n\u00e8bres\ufffd&quot;));
115         } catch (ExecutionException x) {
116             Throwable cause = x.getCause();
117             if (cause instanceof MalformedInputException) {
118                 throw new RuntimeException(&quot;Unexpected MalformedInputException thrown&quot;, cause);
119             }
120             throw x;
121         }
122     }
123 
124 
125     @Test
<a name="3" id="anc3"></a><span class="line-modified">126     void testStringWithFinisherLF() throws Exception {</span>
127         // Uses U+10400 which is encoded as the surrogate pair U+D801 U+DC00
128         String text = &quot;Bient\u00f4t\r\n nous plongerons\r\n dans\r&quot; +
129                 &quot; les\n\n fr\u00f4\ud801\udc00des\r\n t\u00e9n\u00e8bres\r&quot;;
130         ObjectSubscriber subscriber = new ObjectSubscriber();
131         BodySubscriber&lt;String&gt; bodySubscriber = BodySubscribers.fromLineSubscriber(
132                 subscriber, Supplier::get, UTF_8, &quot;\n&quot;);
133         SubmissionPublisher&lt;List&lt;ByteBuffer&gt;&gt; publisher = new SubmissionPublisher&lt;&gt;();
134         byte[] bytes = text.getBytes(UTF_8);
135         publisher.subscribe(bodySubscriber);
136         System.out.println(&quot;Publishing &quot; + bytes.length + &quot; bytes&quot;);
137         for (int i=0; i&lt;bytes.length; i++) {
138             // ensure that surrogates are split over several buffers.
139             publisher.submit(List.of(ByteBuffer.wrap(bytes, i, 1)));
140         }
141         publisher.close();
142         String resp = bodySubscriber.getBody().toCompletableFuture().get();
143         System.out.println(&quot;***** Got: &quot; + resp);
144         List&lt;String&gt; expected = List.of(&quot;Bient\u00f4t\r&quot;,
145                 &quot; nous plongerons\r&quot;,
146                 &quot; dans\r les&quot;,
147                 &quot;&quot;,
148                 &quot; fr\u00f4\ud801\udc00des\r&quot;,
149                 &quot; t\u00e9n\u00e8bres\r&quot;);
150         assertEquals(subscriber.list, expected);
151         assertEquals(resp, Stream.of(text.split(&quot;\n&quot;)).collect(Collectors.joining(&quot;&quot;)));
152         assertEquals(resp, expected.stream().collect(Collectors.joining(&quot;&quot;)));
153         assertEquals(subscriber.list, lines(text, &quot;\n&quot;));
154     }
155 
156 
157     @Test
<a name="4" id="anc4"></a><span class="line-modified">158     void testStringWithFinisherCR() throws Exception {</span>
159         String text = &quot;Bient\u00f4t\r\n nous plongerons\r\n dans\r&quot; +
160                 &quot; les fr\u00f4\ud801\udc00des\r\n t\u00e9n\u00e8bres\r\r&quot;;
161         ObjectSubscriber subscriber = new ObjectSubscriber();
162         BodySubscriber&lt;String&gt; bodySubscriber = BodySubscribers.fromLineSubscriber(
163                 subscriber, Supplier::get, UTF_8, &quot;\r&quot;);
164         SubmissionPublisher&lt;List&lt;ByteBuffer&gt;&gt; publisher = new SubmissionPublisher&lt;&gt;();
165         byte[] bytes = text.getBytes(UTF_8);
166         publisher.subscribe(bodySubscriber);
167         System.out.println(&quot;Publishing &quot; + bytes.length + &quot; bytes&quot;);
168         for (int i=0; i&lt;bytes.length; i++) {
169             // ensure that surrogates are split over several buffers.
170             publisher.submit(List.of(ByteBuffer.wrap(bytes, i, 1)));
171         }
172         publisher.close();
173         String resp = bodySubscriber.getBody().toCompletableFuture().get();
174         System.out.println(&quot;***** Got: &quot; + resp);
175         assertEquals(resp, text.replace(&quot;\r&quot;, &quot;&quot;));
176         assertEquals(subscriber.list, List.of(&quot;Bient\u00f4t&quot;,
177                 &quot;\n nous plongerons&quot;,
178                 &quot;\n dans&quot;,
179                 &quot; les fr\u00f4\ud801\udc00des&quot;,
180                 &quot;\n t\u00e9n\u00e8bres&quot;,
181                 &quot;&quot;));
182         assertEquals(subscriber.list, lines(text, &quot;\r&quot;));
183     }
184 
185     @Test
<a name="5" id="anc5"></a><span class="line-modified">186     void testStringWithFinisherCRLF() throws Exception {</span>
187         String text = &quot;Bient\u00f4t\r\n nous plongerons\r\n dans\r&quot; +
188                 &quot; les fr\u00f4\ud801\udc00des\r\n t\u00e9n\u00e8bres&quot;;
189         ObjectSubscriber subscriber = new ObjectSubscriber();
190         BodySubscriber&lt;String&gt; bodySubscriber = BodySubscribers.fromLineSubscriber(
191                 subscriber, Supplier::get, UTF_8, &quot;\r\n&quot;);
192         SubmissionPublisher&lt;List&lt;ByteBuffer&gt;&gt; publisher = new SubmissionPublisher&lt;&gt;();
193         byte[] bytes = text.getBytes(UTF_8);
194         publisher.subscribe(bodySubscriber);
195         System.out.println(&quot;Publishing &quot; + bytes.length + &quot; bytes&quot;);
196         for (int i=0; i&lt;bytes.length; i++) {
197             // ensure that surrogates are split over several buffers.
198             publisher.submit(List.of(ByteBuffer.wrap(bytes, i, 1)));
199         }
200         publisher.close();
201         String resp = bodySubscriber.getBody().toCompletableFuture().get();
202         System.out.println(&quot;***** Got: &quot; + resp);
203         assertEquals(resp, text.replace(&quot;\r\n&quot;,&quot;&quot;));
204         assertEquals(subscriber.list, List.of(&quot;Bient\u00f4t&quot;,
205                 &quot; nous plongerons&quot;,
206                 &quot; dans\r les fr\u00f4\ud801\udc00des&quot;,
207                 &quot; t\u00e9n\u00e8bres&quot;));
208         assertEquals(subscriber.list, lines(text, &quot;\r\n&quot;));
209     }
210 
211 
212     @Test
<a name="6" id="anc6"></a><span class="line-modified">213     void testStringWithFinisherBR() throws Exception {</span>
214         String text = &quot;Bient\u00f4t\r\n nous plongerons\r\n dans\r&quot; +
215                 &quot; les\r\r fr\u00f4\ud801\udc00des\r\n t\u00e9n\u00e8bres&quot;;
216         ObjectSubscriber subscriber = new ObjectSubscriber();
217         BodySubscriber&lt;String&gt; bodySubscriber = BodySubscribers.fromLineSubscriber(
218                 subscriber, Supplier::get, UTF_8, null);
219         SubmissionPublisher&lt;List&lt;ByteBuffer&gt;&gt; publisher = new SubmissionPublisher&lt;&gt;();
220         byte[] bytes = text.getBytes(UTF_8);
221         publisher.subscribe(bodySubscriber);
222         System.out.println(&quot;Publishing &quot; + bytes.length + &quot; bytes&quot;);
223         for (int i=0; i&lt;bytes.length; i++) {
224             // ensure that surrogates are split over several buffers.
225             publisher.submit(List.of(ByteBuffer.wrap(bytes, i, 1)));
226         }
227         publisher.close();
228         String resp = bodySubscriber.getBody().toCompletableFuture().get();
229         System.out.println(&quot;***** Got: &quot; + resp);
230         List&lt;String&gt; expected = List.of(&quot;Bient\u00f4t&quot;,
231                 &quot; nous plongerons&quot;,
232                 &quot; dans&quot;,
233                 &quot; les&quot;,
234                 &quot;&quot;,
235                 &quot; fr\u00f4\ud801\udc00des&quot;,
236                 &quot; t\u00e9n\u00e8bres&quot;);
237         assertEquals(subscriber.list, expected);
238         assertEquals(resp, expected.stream().collect(Collectors.joining(&quot;&quot;)));
239         assertEquals(subscriber.list, lines(text, null));
240     }
241 
242     @Test
<a name="7" id="anc7"></a><span class="line-modified">243     void testStringWithFinisherBR_UTF_16() throws Exception {</span>
244         String text = &quot;Bient\u00f4t\r\n nous plongerons\r\n dans\r&quot; +
245                 &quot; les\r\r fr\u00f4\ud801\udc00des\r\n t\u00e9n\u00e8bres\r\r&quot;;
246         ObjectSubscriber subscriber = new ObjectSubscriber();
247         BodySubscriber&lt;String&gt; bodySubscriber = BodySubscribers.fromLineSubscriber(
248                 subscriber, Supplier::get, UTF_16, null);
249         SubmissionPublisher&lt;List&lt;ByteBuffer&gt;&gt; publisher = new SubmissionPublisher&lt;&gt;();
250         byte[] bytes = text.getBytes(UTF_16);
251         publisher.subscribe(bodySubscriber);
252         System.out.println(&quot;Publishing &quot; + bytes.length + &quot; bytes&quot;);
253         for (int i=0; i&lt;bytes.length; i++) {
254             // ensure that surrogates are split over several buffers.
255             publisher.submit(List.of(ByteBuffer.wrap(bytes, i, 1)));
256         }
257         publisher.close();
258         String resp = bodySubscriber.getBody().toCompletableFuture().get();
259         System.out.println(&quot;***** Got: &quot; + resp);
260         List&lt;String&gt; expected = List.of(&quot;Bient\u00f4t&quot;,
261                 &quot; nous plongerons&quot;,
262                 &quot; dans&quot;,
263                 &quot; les&quot;,
264                 &quot;&quot;,
265                 &quot; fr\u00f4\ud801\udc00des&quot;,
266                 &quot; t\u00e9n\u00e8bres&quot;,
267                 &quot;&quot;);
268         assertEquals(resp, expected.stream().collect(Collectors.joining(&quot;&quot;)));
269         assertEquals(subscriber.list, expected);
270         assertEquals(subscriber.list, lines(text, null));
271     }
272 
273     void testStringWithoutFinisherBR() throws Exception {
274         String text = &quot;Bient\u00f4t\r\n nous plongerons\r\n dans\r&quot; +
275                 &quot; les\r\r fr\u00f4\ud801\udc00des\r\n t\u00e9n\u00e8bres&quot;;
276         ObjectSubscriber subscriber = new ObjectSubscriber();
277         BodySubscriber&lt;Void&gt; bodySubscriber = BodySubscribers.fromLineSubscriber(subscriber);
278         SubmissionPublisher&lt;List&lt;ByteBuffer&gt;&gt; publisher = new SubmissionPublisher&lt;&gt;();
279         byte[] bytes = text.getBytes(UTF_8);
280         publisher.subscribe(bodySubscriber);
281         System.out.println(&quot;Publishing &quot; + bytes.length + &quot; bytes&quot;);
282         for (int i = 0; i &lt; bytes.length; i++) {
283             // ensure that surrogates are split over several buffers.
284             publisher.submit(List.of(ByteBuffer.wrap(bytes, i, 1)));
285         }
286         publisher.close();
287         Void resp = bodySubscriber.getBody().toCompletableFuture().get();
288         System.out.println(&quot;***** Got: &quot; + resp);
289         List&lt;String&gt; expected = List.of(&quot;Bient\u00f4t&quot;,
290                 &quot; nous plongerons&quot;,
291                 &quot; dans&quot;,
292                 &quot; les&quot;,
293                 &quot;&quot;,
294                 &quot; fr\u00f4\ud801\udc00des&quot;,
295                 &quot; t\u00e9n\u00e8bres&quot;);
296         assertEquals(subscriber.text, expected.stream().collect(Collectors.joining(&quot;&quot;)));
297         assertEquals(subscriber.list, expected);
298         assertEquals(subscriber.list, lines(text, null));
299     }
300 
301 
302     /** An abstract Subscriber that converts all received data into a String. */
303     static abstract class AbstractSubscriber implements Supplier&lt;String&gt; {
304         protected final List&lt;Object&gt; list = new CopyOnWriteArrayList&lt;&gt;();
305         protected volatile Flow.Subscription subscription;
306         protected final StringBuilder baos = new StringBuilder();
307         protected volatile String text;
308         protected volatile RuntimeException error;
309 
310         public void onSubscribe(Flow.Subscription subscription) {
311             this.subscription = subscription;
312             subscription.request(Long.MAX_VALUE);
313         }
314         public void onError(Throwable throwable) {
315             System.out.println(this + &quot; onError: &quot; + throwable);
316             error = new RuntimeException(throwable);
317         }
318         public void onComplete() {
319             System.out.println(this + &quot; onComplete&quot;);
320             text = baos.toString();
321         }
322         @Override public String get() {
323             if (error != null) throw error;
324             return text;
325         }
326         public final List&lt;?&gt; list() {
327             return list;
328         }
329     }
330 
331     static class StringSubscriber extends AbstractSubscriber
332             implements Flow.Subscriber&lt;String&gt;, Supplier&lt;String&gt;
333     {
334         @Override public void onNext(String item) {
335             System.out.println(this + &quot; onNext: \&quot;&quot;
336                     + item.replace(&quot;\n&quot;,&quot;\\n&quot;)
337                           .replace(&quot;\r&quot;, &quot;\\r&quot;)
338                     + &quot;\&quot;&quot;);
339             baos.append(item);
340             list.add(item);
341         }
342     }
343 
344     static class CharSequenceSubscriber extends AbstractSubscriber
345             implements Flow.Subscriber&lt;CharSequence&gt;, Supplier&lt;String&gt;
346     {
347         @Override public void onNext(CharSequence item) {
348             System.out.println(this + &quot; onNext: \&quot;&quot;
349                     + item.toString().replace(&quot;\n&quot;,&quot;\\n&quot;)
350                     .replace(&quot;\r&quot;, &quot;\\r&quot;)
351                     + &quot;\&quot;&quot;);
352             baos.append(item);
353             list.add(item);
354         }
355     }
356 
357     static class ObjectSubscriber extends AbstractSubscriber
358             implements Flow.Subscriber&lt;Object&gt;, Supplier&lt;String&gt;
359     {
360         @Override public void onNext(Object item) {
361             System.out.println(this + &quot; onNext: \&quot;&quot;
362                     + item.toString().replace(&quot;\n&quot;,&quot;\\n&quot;)
363                     .replace(&quot;\r&quot;, &quot;\\r&quot;)
364                     + &quot;\&quot;&quot;);
365             baos.append(item);
366             list.add(item);
367         }
368     }
369 
370 
371     static void uncheckedWrite(ByteArrayOutputStream baos, byte[] ba) {
372         try {
373             baos.write(ba);
374         } catch (IOException e) {
375             throw new UncheckedIOException(e);
376         }
377     }
378 
379 }
<a name="8" id="anc8"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="8" type="hidden" />
</body>
</html>
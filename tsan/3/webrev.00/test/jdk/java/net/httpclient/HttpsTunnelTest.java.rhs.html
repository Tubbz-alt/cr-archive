<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames test/jdk/java/net/httpclient/HttpsTunnelTest.java</title>
    <link rel="stylesheet" href="../../../../../style.css" />
    <script type="text/javascript" src="../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
<a name="1" id="anc1"></a><span class="line-modified">  2  * Copyright (c) 2018, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 import com.sun.net.httpserver.HttpsConfigurator;
 25 import com.sun.net.httpserver.HttpsServer;
 26 import jdk.test.lib.net.SimpleSSLContext;
 27 import javax.net.ssl.SSLContext;
 28 import java.net.InetAddress;
 29 import java.net.InetSocketAddress;
 30 import java.net.ProxySelector;
 31 import java.net.URI;
 32 import java.net.http.HttpClient;
 33 import java.net.http.HttpClient.Version;
 34 import java.net.http.HttpRequest;
 35 import java.net.http.HttpResponse;
 36 import java.net.http.HttpResponse.BodyHandlers;
 37 import java.util.Arrays;
 38 import java.util.List;
 39 import java.util.stream.Collectors;
 40 import java.util.stream.Stream;
 41 import static java.lang.String.format;
 42 import static java.lang.System.out;
 43 
 44 /**
 45  * @test
 46  * @summary This test verifies that if an h2 connection going through a
 47  *          proxy P is downgraded to HTTP/1.1, then a new h2 request
 48  *          going to a different host through the same proxy will not
 49  *          be preemptively downgraded. That, is the stack should attempt
<a name="2" id="anc2"></a><span class="line-modified"> 50  *          a new h2 connection to the new host. It also verifies that</span>
<span class="line-modified"> 51  *          the stack sends the appropriate &quot;host&quot; header to the proxy.</span>
<span class="line-added"> 52  * @bug 8196967 8222527</span>
 53  * @library /test/lib http2/server
 54  * @build jdk.test.lib.net.SimpleSSLContext HttpServerAdapters DigestEchoServer HttpsTunnelTest
 55  * @modules java.net.http/jdk.internal.net.http.common
 56  *          java.net.http/jdk.internal.net.http.frame
 57  *          java.net.http/jdk.internal.net.http.hpack
 58  *          java.logging
 59  *          java.base/sun.net.www.http
 60  *          java.base/sun.net.www
 61  *          java.base/sun.net
<a name="3" id="anc3"></a><span class="line-modified"> 62  * @run main/othervm -Dtest.requiresHost=true</span>
<span class="line-added"> 63  *                   -Djdk.httpclient.HttpClient.log=headers</span>
<span class="line-added"> 64  *                   -Djdk.internal.httpclient.debug=true HttpsTunnelTest</span>
<span class="line-added"> 65  * @run main/othervm -Dtest.requiresHost=true</span>
<span class="line-added"> 66  *                   -Djdk.httpclient.allowRestrictedHeaders=host</span>
<span class="line-added"> 67  *                   -Djdk.httpclient.HttpClient.log=headers</span>
<span class="line-added"> 68  *                   -Djdk.internal.httpclient.debug=true HttpsTunnelTest</span>
<span class="line-added"> 69  *</span>
 70  */
 71 
 72 public class HttpsTunnelTest implements HttpServerAdapters {
 73 
 74     static final String data[] = {
 75         &quot;Lorem ipsum&quot;,
 76         &quot;dolor sit amet&quot;,
 77         &quot;consectetur adipiscing elit, sed do eiusmod tempor&quot;,
 78         &quot;quis nostrud exercitation ullamco&quot;,
 79         &quot;laboris nisi&quot;,
 80         &quot;ut&quot;,
 81         &quot;aliquip ex ea commodo consequat.&quot; +
 82         &quot;Duis aute irure dolor in reprehenderit in voluptate velit esse&quot; +
 83         &quot;cillum dolore eu fugiat nulla pariatur.&quot;,
 84         &quot;Excepteur sint occaecat cupidatat non proident.&quot;
 85     };
 86 
 87     static final SSLContext context;
 88     static {
 89         try {
 90             context = new SimpleSSLContext().get();
 91             SSLContext.setDefault(context);
 92         } catch (Exception x) {
 93             throw new ExceptionInInitializerError(x);
 94         }
 95     }
 96 
 97     HttpsTunnelTest() {
 98     }
 99 
100     public HttpClient newHttpClient(ProxySelector ps) {
101         HttpClient.Builder builder = HttpClient
102                 .newBuilder()
103                 .sslContext(context)
104                 .proxy(ps);
105         return builder.build();
106     }
107 
108     public static void main(String[] args) throws Exception {
109         InetSocketAddress sa = new InetSocketAddress(InetAddress.getLoopbackAddress(), 0);
110         HttpsServer server1 = HttpsServer.create(sa, 0);
111         server1.setHttpsConfigurator(new HttpsConfigurator(context));
112         HttpTestServer http1Server =
113                 HttpTestServer.of(server1);
114         http1Server.addHandler(new HttpTestEchoHandler(), &quot;/&quot;);
115         http1Server.start();
116         HttpTestServer http2Server = HttpTestServer.of(
117                 new Http2TestServer(&quot;localhost&quot;, true, 0));
118         http2Server.addHandler(new HttpTestEchoHandler(), &quot;/&quot;);
119         http2Server.start();
120 
121         DigestEchoServer.TunnelingProxy proxy = DigestEchoServer.createHttpsProxyTunnel(
122                 DigestEchoServer.HttpAuthSchemeType.NONE);
123 
124         try {
125             URI uri1 = new URI(&quot;https://&quot; + http1Server.serverAuthority() + &quot;/foo/https1&quot;);
126             URI uri2 = new URI(&quot;https://&quot; + http2Server.serverAuthority() + &quot;/foo/https2&quot;);
<a name="4" id="anc4"></a><span class="line-added">127 </span>
<span class="line-added">128             boolean provideCustomHost = &quot;host&quot;.equalsIgnoreCase(</span>
<span class="line-added">129                     System.getProperty(&quot;jdk.httpclient.allowRestrictedHeaders&quot;,&quot;&quot;));</span>
<span class="line-added">130 </span>
<span class="line-added">131             String customHttp1Host = null, customHttp2Host = null;</span>
<span class="line-added">132             if (provideCustomHost) {</span>
<span class="line-added">133                 customHttp1Host = makeCustomHostString(http1Server, uri1);</span>
<span class="line-added">134                 out.println(&quot;HTTP/1.1: &lt;&quot; + uri1 + &quot;&gt; [custom host: &quot; + customHttp1Host + &quot;]&quot;);</span>
<span class="line-added">135                 customHttp2Host = makeCustomHostString(http2Server, uri2);</span>
<span class="line-added">136                 out.println(&quot;HTTP/2:   &lt;&quot; + uri2 + &quot;&gt; [custom host: &quot; + customHttp2Host + &quot;]&quot;);</span>
<span class="line-added">137             }</span>
<span class="line-added">138 </span>
139             ProxySelector ps = ProxySelector.of(proxy.getProxyAddress());
140                     //HttpClient.Builder.NO_PROXY;
141             HttpsTunnelTest test = new HttpsTunnelTest();
142             HttpClient client = test.newHttpClient(ps);
143             out.println(&quot;Proxy is: &quot; + ps.select(uri2));
144 
145             List&lt;String&gt; lines = List.of(Arrays.copyOfRange(data, 0, data.length));
146             assert lines.size() == data.length;
147             String body = lines.stream().collect(Collectors.joining(&quot;\r\n&quot;));
148             HttpRequest.BodyPublisher reqBody = HttpRequest.BodyPublishers.ofString(body);
<a name="5" id="anc5"></a><span class="line-modified">149             HttpRequest.Builder req1Builder = HttpRequest</span>
150                     .newBuilder(uri1)
151                     .version(Version.HTTP_2)
<a name="6" id="anc6"></a><span class="line-modified">152                     .POST(reqBody);</span>
<span class="line-modified">153             if (provideCustomHost) req1Builder.header(&quot;host&quot;, customHttp1Host);</span>
<span class="line-added">154             HttpRequest req1 = req1Builder.build();</span>
155             out.println(&quot;\nPosting to HTTP/1.1 server at: &quot; + req1);
156             HttpResponse&lt;Stream&lt;String&gt;&gt; response = client.send(req1, BodyHandlers.ofLines());
157             out.println(&quot;Checking response...&quot;);
158             if (response.statusCode() != 200) {
159                 throw new RuntimeException(&quot;Unexpected status code: &quot; + response);
160             }
161             if (response.version() != Version.HTTP_1_1) {
162                 throw new RuntimeException(&quot;Unexpected protocol version: &quot;
163                         + response.version());
164             }
165             List&lt;String&gt; respLines = response.body().collect(Collectors.toList());
166             if (!lines.equals(respLines)) {
167                 throw new RuntimeException(&quot;Unexpected response 1: &quot; + respLines);
168             }
<a name="7" id="anc7"></a><span class="line-added">169 </span>
170             HttpRequest.BodyPublisher reqBody2 = HttpRequest.BodyPublishers.ofString(body);
<a name="8" id="anc8"></a><span class="line-modified">171             HttpRequest.Builder req2Builder = HttpRequest</span>
172                     .newBuilder(uri2)
173                     .version(Version.HTTP_2)
<a name="9" id="anc9"></a><span class="line-modified">174                     .POST(reqBody2);</span>
<span class="line-modified">175             if (provideCustomHost) req2Builder.header(&quot;host&quot;, customHttp2Host);</span>
<span class="line-added">176             HttpRequest req2 = req2Builder.build();</span>
177             out.println(&quot;\nPosting to HTTP/2 server at: &quot; + req2);
178             response = client.send(req2, BodyHandlers.ofLines());
179             out.println(&quot;Checking response...&quot;);
180             if (response.statusCode() != 200) {
181                 throw new RuntimeException(&quot;Unexpected status code: &quot; + response);
182             }
183             if (response.version() != Version.HTTP_2) {
184                 throw new RuntimeException(&quot;Unexpected protocol version: &quot;
185                         + response.version());
186             }
187             respLines = response.body().collect(Collectors.toList());
188             if (!lines.equals(respLines)) {
189                 throw new RuntimeException(&quot;Unexpected response 2: &quot; + respLines);
190             }
191         } catch(Throwable t) {
192             out.println(&quot;Unexpected exception: exiting: &quot; + t);
193             t.printStackTrace();
194             throw t;
195         } finally {
196             proxy.stop();
197             http1Server.stop();
198             http2Server.stop();
199         }
200     }
201 
<a name="10" id="anc10"></a><span class="line-added">202     /**</span>
<span class="line-added">203      * Builds a custom host string that is different to what is in the URI</span>
<span class="line-added">204      * authority, that is textually different than what the stack would</span>
<span class="line-added">205      * send. For CONNECT we should ignore any custom host settings.</span>
<span class="line-added">206      * The tunnelling proxy will fail with badRequest 400 if it receives</span>
<span class="line-added">207      * the custom host instead of the expected URI authority string.</span>
<span class="line-added">208      * @param  server The target server.</span>
<span class="line-added">209      * @param  uri    The URI to the target server</span>
<span class="line-added">210      * @return a host value for the custom host header.</span>
<span class="line-added">211      */</span>
<span class="line-added">212     static final String makeCustomHostString(HttpTestServer server, URI uri) {</span>
<span class="line-added">213         String customHttpHost;</span>
<span class="line-added">214         if (server.serverAuthority().contains(&quot;localhost&quot;)) {</span>
<span class="line-added">215             customHttpHost = InetAddress.getLoopbackAddress().getHostAddress();</span>
<span class="line-added">216         } else {</span>
<span class="line-added">217             customHttpHost = InetAddress.getLoopbackAddress().getHostName();</span>
<span class="line-added">218         }</span>
<span class="line-added">219         if (customHttpHost.contains(&quot;:&quot;)) customHttpHost = &quot;[&quot; + customHttpHost + &quot;]&quot;;</span>
<span class="line-added">220         if (uri.getPort() != -1) customHttpHost = customHttpHost + &quot;:&quot; + uri.getPort();</span>
<span class="line-added">221         return customHttpHost;</span>
<span class="line-added">222     }</span>
<span class="line-added">223 </span>
224 }
<a name="11" id="anc11"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="11" type="hidden" />
</body>
</html>
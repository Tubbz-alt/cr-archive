<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff test/jdk/java/net/httpclient/DigestEchoServer.java</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
<body>
<center><a href="AuthSchemesTest.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="HandshakeFailureTest.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>test/jdk/java/net/httpclient/DigestEchoServer.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  */
  23 
  24 import com.sun.net.httpserver.BasicAuthenticator;
  25 import com.sun.net.httpserver.HttpServer;
  26 import com.sun.net.httpserver.HttpsConfigurator;
  27 import com.sun.net.httpserver.HttpsParameters;
  28 import com.sun.net.httpserver.HttpsServer;


  29 import java.io.IOException;
  30 import java.io.InputStream;
  31 import java.io.OutputStream;
  32 import java.io.OutputStreamWriter;
  33 import java.io.PrintWriter;
  34 import java.io.Writer;
  35 import java.math.BigInteger;
  36 import java.net.Authenticator;
  37 import java.net.HttpURLConnection;
  38 import java.net.InetAddress;
  39 import java.net.InetSocketAddress;
  40 import java.net.MalformedURLException;
  41 import java.net.PasswordAuthentication;
  42 import java.net.ServerSocket;
  43 import java.net.Socket;
  44 import java.net.StandardSocketOptions;
  45 import java.net.URI;
  46 import java.net.URISyntaxException;
  47 import java.net.URL;
  48 import java.nio.charset.StandardCharsets;
</pre>
<hr />
<pre>
  63 import java.util.concurrent.atomic.AtomicInteger;
  64 import java.util.stream.Collectors;
  65 import java.util.stream.Stream;
  66 import javax.net.ssl.SSLContext;
  67 import sun.net.www.HeaderParser;
  68 import java.net.http.HttpClient.Version;
  69 
  70 /**
  71  * A simple HTTP server that supports Basic or Digest authentication.
  72  * By default this server will echo back whatever is present
  73  * in the request body. Note that the Digest authentication is
  74  * a test implementation implemented only for tests purposes.
  75  * @author danielfuchs
  76  */
  77 public abstract class DigestEchoServer implements HttpServerAdapters {
  78 
  79     public static final boolean DEBUG =
  80             Boolean.parseBoolean(System.getProperty(&quot;test.debug&quot;, &quot;false&quot;));
  81     public static final boolean NO_LINGER =
  82             Boolean.parseBoolean(System.getProperty(&quot;test.nolinger&quot;, &quot;false&quot;));


  83     public enum HttpAuthType {
  84         SERVER, PROXY, SERVER307, PROXY305
  85         /* add PROXY_AND_SERVER and SERVER_PROXY_NONE */
  86     };
  87     public enum HttpAuthSchemeType { NONE, BASICSERVER, BASIC, DIGEST };
  88     public static final HttpAuthType DEFAULT_HTTP_AUTH_TYPE = HttpAuthType.SERVER;
  89     public static final String DEFAULT_PROTOCOL_TYPE = &quot;https&quot;;
  90     public static final HttpAuthSchemeType DEFAULT_SCHEME_TYPE = HttpAuthSchemeType.DIGEST;
  91 
  92     public static class HttpTestAuthenticator extends Authenticator {
  93         private final String realm;
  94         private final String username;
  95         // Used to prevent incrementation of &#39;count&#39; when calling the
  96         // authenticator from the server side.
  97         private final ThreadLocal&lt;Boolean&gt; skipCount = new ThreadLocal&lt;&gt;();
  98         // count will be incremented every time getPasswordAuthentication()
  99         // is called from the client side.
 100         final AtomicInteger count = new AtomicInteger();
 101 
 102         public HttpTestAuthenticator(String realm, String username) {
</pre>
<hr />
<pre>
1505             try {
1506                 ss.close();
1507             } catch (IOException ex) {
1508                 if (DEBUG) ex.printStackTrace(System.out);
1509             }
1510         }
1511 
1512 
1513         @Override
1514         void configureAuthentication(HttpTestContext ctxt,
1515                                      HttpAuthSchemeType schemeType,
1516                                      HttpTestAuthenticator auth,
1517                                      HttpAuthType authType) {
1518             if (authType == HttpAuthType.PROXY || authType == HttpAuthType.PROXY305) {
1519                 authorization = new ProxyAuthorization(key, schemeType, auth);
1520             } else {
1521                 super.configureAuthentication(ctxt, schemeType, auth, authType);
1522             }
1523         }
1524 






























1525         boolean authorize(StringBuilder response, String requestLine, String headers) {
1526             if (authorization != null) {
1527                 return authorization.authorize(response, requestLine, headers);
1528             }
1529             response.append(&quot;HTTP/1.1 200 OK\r\nContent-Length: 0\r\n\r\n&quot;);
1530             return true;
1531         }
1532 
1533         // Pipe the input stream to the output stream.
1534         private synchronized Thread pipe(InputStream is, OutputStream os, char tag, CompletableFuture&lt;Void&gt; end) {
1535             return new Thread(&quot;TunnelPipe(&quot;+tag+&quot;)&quot;) {
1536                 @Override
1537                 public void run() {
1538                     try {

1539                         try {
<span class="line-removed">1540                             int c;</span>
1541                             while ((c = is.read()) != -1) {
1542                                 os.write(c);
1543                                 os.flush();
1544                                 // if DEBUG prints a + or a - for each transferred
1545                                 // character.
1546                                 if (DEBUG) System.out.print(tag);
1547                             }
1548                             is.close();




1549                         } finally {
<span class="line-modified">1550                             os.close();</span>
1551                         }
<span class="line-removed">1552                     } catch (IOException ex) {</span>
<span class="line-removed">1553                         if (DEBUG) ex.printStackTrace(System.out);</span>
1554                     } finally {
1555                         end.complete(null);
1556                     }
1557                 }
1558             };
1559         }
1560 
1561         @Override
1562         public InetSocketAddress getAddress() {
1563             return new InetSocketAddress(InetAddress.getLoopbackAddress(),
1564                     ss.getLocalPort());
1565         }
1566         @Override
1567         public InetSocketAddress getProxyAddress() {
1568             return getAddress();
1569         }
1570         @Override
1571         public InetSocketAddress getServerAddress() {
1572             // serverImpl can be null if this proxy can serve
1573             // multiple servers.
</pre>
<hr />
<pre>
1583         // Read a line from the input stream, swallowing the final
1584         // \r\n sequence. Stops at the first \n, doesn&#39;t complain
1585         // if it wasn&#39;t preceded by &#39;\r&#39;.
1586         //
1587         String readLine(InputStream r) throws IOException {
1588             StringBuilder b = new StringBuilder();
1589             int c;
1590             while ((c = r.read()) != -1) {
1591                 if (c == &#39;\n&#39;) break;
1592                 b.appendCodePoint(c);
1593             }
1594             if (b.codePointAt(b.length() -1) == &#39;\r&#39;) {
1595                 b.delete(b.length() -1, b.length());
1596             }
1597             return b.toString();
1598         }
1599 
1600         @Override
1601         public void run() {
1602             Socket clientConnection = null;

1603             try {
1604                 while (!stopped) {
1605                     System.out.println(now() + &quot;Tunnel: Waiting for client&quot;);
1606                     Socket toClose;

1607                     try {
1608                         toClose = clientConnection = ss.accept();
1609                         if (NO_LINGER) {
1610                             // can be useful to trigger &quot;Connection reset by peer&quot;
1611                             // errors on the client side.
1612                             clientConnection.setOption(StandardSocketOptions.SO_LINGER, 0);
1613                         }
1614                     } catch (IOException io) {
1615                         if (DEBUG || !stopped) io.printStackTrace(System.out);
1616                         break;
1617                     }
1618                     System.out.println(now() + &quot;Tunnel: Client accepted&quot;);
1619                     StringBuilder headers = new StringBuilder();
<span class="line-removed">1620                     Socket targetConnection = null;</span>
1621                     InputStream  ccis = clientConnection.getInputStream();
1622                     OutputStream ccos = clientConnection.getOutputStream();
1623                     Writer w = new OutputStreamWriter(
1624                                    clientConnection.getOutputStream(), &quot;UTF-8&quot;);
1625                     PrintWriter pw = new PrintWriter(w);
1626                     System.out.println(now() + &quot;Tunnel: Reading request line&quot;);
1627                     String requestLine = readLine(ccis);
1628                     System.out.println(now() + &quot;Tunnel: Request line: &quot; + requestLine);
1629                     if (requestLine.startsWith(&quot;CONNECT &quot;)) {
1630                         // We should probably check that the next word following
1631                         // CONNECT is the host:port of our HTTPS serverImpl.
1632                         // Some improvement for a followup!
1633                         StringTokenizer tokenizer = new StringTokenizer(requestLine);
1634                         String connect = tokenizer.nextToken();
1635                         assert connect.equalsIgnoreCase(&quot;connect&quot;);
1636                         String hostport = tokenizer.nextToken();
1637                         InetSocketAddress targetAddress;

1638                         try {
1639                             URI uri = new URI(&quot;https&quot;, hostport, &quot;/&quot;, null, null);
1640                             int port = uri.getPort();
1641                             port = port == -1 ? 443 : port;
1642                             targetAddress = new InetSocketAddress(uri.getHost(), port);
1643                             if (serverImpl != null) {
1644                                 assert targetAddress.getHostString()
1645                                         .equalsIgnoreCase(serverImpl.getAddress().getHostString());
1646                                 assert targetAddress.getPort() == serverImpl.getAddress().getPort();
1647                             }
1648                         } catch (Throwable x) {
1649                             System.err.printf(&quot;Bad target address: \&quot;%s\&quot; in \&quot;%s\&quot;%n&quot;,
1650                                     hostport, requestLine);
1651                             toClose.close();
1652                             continue;
1653                         }
1654 
1655                         // Read all headers until we find the empty line that
1656                         // signals the end of all headers.
1657                         String line = requestLine;
1658                         while(!line.equals(&quot;&quot;)) {
1659                             System.out.println(now() + &quot;Tunnel: Reading header: &quot;
1660                                                + (line = readLine(ccis)));
1661                             headers.append(line).append(&quot;\r\n&quot;);







1662                         }
<span class="line-removed">1663 </span>
1664                         StringBuilder response = new StringBuilder();















1665                         final boolean authorize = authorize(response, requestLine, headers.toString());
1666                         if (!authorize) {
1667                             System.out.println(now() + &quot;Tunnel: Sending &quot;
1668                                     + response);
1669                             // send the 407 response
1670                             pw.print(response.toString());
1671                             pw.flush();
1672                             toClose.close();
1673                             continue;
1674                         }
1675                         System.out.println(now()
1676                                 + &quot;Tunnel connecting to target server at &quot;
1677                                 + targetAddress.getAddress() + &quot;:&quot; + targetAddress.getPort());
1678                         targetConnection = new Socket(
1679                                 targetAddress.getAddress(),
1680                                 targetAddress.getPort());
1681 
1682                         // Then send the 200 OK response to the client
1683                         System.out.println(now() + &quot;Tunnel: Sending &quot;
1684                                            + response);
</pre>
<hr />
<pre>
1698                         System.err.println(&quot;WARNING: Tunnel: Unexpected status line: &quot;
1699                                              + requestLine + &quot; received by &quot;
1700                                            + ss.getLocalSocketAddress()
1701                                            + &quot; from &quot;
1702                                            + toClose.getRemoteSocketAddress());
1703                         // close accepted socket.
1704                         toClose.close();
1705                         System.err.println(&quot;Tunnel: accepted socket closed.&quot;);
1706                         continue;
1707                     }
1708 
1709                     // Pipe the input stream of the client connection to the
1710                     // output stream of the target connection and conversely.
1711                     // Now the client and target will just talk to each other.
1712                     System.out.println(now() + &quot;Tunnel: Starting tunnel pipes&quot;);
1713                     CompletableFuture&lt;Void&gt; end, end1, end2;
1714                     Thread t1 = pipe(ccis, targetConnection.getOutputStream(), &#39;+&#39;,
1715                             end1 = new CompletableFuture&lt;&gt;());
1716                     Thread t2 = pipe(targetConnection.getInputStream(), ccos, &#39;-&#39;,
1717                             end2 = new CompletableFuture&lt;&gt;());
<span class="line-modified">1718                     end = CompletableFuture.allOf(end1, end2);</span>



1719                     end.whenComplete(
1720                             (r,t) -&gt; {
1721                                 try { toClose.close(); } catch (IOException x) { }

1722                                 finally {connectionCFs.remove(end);}
1723                             });
1724                     connectionCFs.add(end);

1725                     t1.start();
1726                     t2.start();
1727                 }
1728             } catch (Throwable ex) {
<span class="line-modified">1729                 try {</span>
<span class="line-modified">1730                     ss.close();</span>
<span class="line-modified">1731                 } catch (IOException ex1) {</span>
<span class="line-removed">1732                     ex.addSuppressed(ex1);</span>
<span class="line-removed">1733                 }</span>
1734                 ex.printStackTrace(System.err);
1735             } finally {
1736                 System.out.println(now() + &quot;Tunnel: exiting (stopped=&quot; + stopped + &quot;)&quot;);
1737                 connectionCFs.forEach(cf -&gt; cf.complete(null));
1738             }
1739         }













1740     }
1741 
1742     /**
1743      * Creates a TunnelingProxy that can serve multiple servers.
1744      * The server address is extracted from the CONNECT request line.
1745      * @param authScheme The authentication scheme supported by the proxy.
1746      *                   Typically one of DIGEST, BASIC, NONE.
1747      * @return A new TunnelingProxy able to serve multiple servers.
1748      * @throws IOException If the proxy could not be created.
1749      */
1750     public static TunnelingProxy createHttpsProxyTunnel(HttpAuthSchemeType authScheme)
1751             throws IOException {
1752         HttpsProxyTunnel result = new HttpsProxyTunnel(&quot;&quot;, null, null, null);
1753         if (authScheme != HttpAuthSchemeType.NONE) {
1754             result.configureAuthentication(null,
1755                                            authScheme,
1756                                            AUTHENTICATOR,
1757                                            HttpAuthType.PROXY);
1758         }
1759         return result;
</pre>
</td>
<td>
<hr />
<pre>
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  */
  23 
  24 import com.sun.net.httpserver.BasicAuthenticator;
  25 import com.sun.net.httpserver.HttpServer;
  26 import com.sun.net.httpserver.HttpsConfigurator;
  27 import com.sun.net.httpserver.HttpsParameters;
  28 import com.sun.net.httpserver.HttpsServer;
<span class="line-added">  29 </span>
<span class="line-added">  30 import java.io.Closeable;</span>
  31 import java.io.IOException;
  32 import java.io.InputStream;
  33 import java.io.OutputStream;
  34 import java.io.OutputStreamWriter;
  35 import java.io.PrintWriter;
  36 import java.io.Writer;
  37 import java.math.BigInteger;
  38 import java.net.Authenticator;
  39 import java.net.HttpURLConnection;
  40 import java.net.InetAddress;
  41 import java.net.InetSocketAddress;
  42 import java.net.MalformedURLException;
  43 import java.net.PasswordAuthentication;
  44 import java.net.ServerSocket;
  45 import java.net.Socket;
  46 import java.net.StandardSocketOptions;
  47 import java.net.URI;
  48 import java.net.URISyntaxException;
  49 import java.net.URL;
  50 import java.nio.charset.StandardCharsets;
</pre>
<hr />
<pre>
  65 import java.util.concurrent.atomic.AtomicInteger;
  66 import java.util.stream.Collectors;
  67 import java.util.stream.Stream;
  68 import javax.net.ssl.SSLContext;
  69 import sun.net.www.HeaderParser;
  70 import java.net.http.HttpClient.Version;
  71 
  72 /**
  73  * A simple HTTP server that supports Basic or Digest authentication.
  74  * By default this server will echo back whatever is present
  75  * in the request body. Note that the Digest authentication is
  76  * a test implementation implemented only for tests purposes.
  77  * @author danielfuchs
  78  */
  79 public abstract class DigestEchoServer implements HttpServerAdapters {
  80 
  81     public static final boolean DEBUG =
  82             Boolean.parseBoolean(System.getProperty(&quot;test.debug&quot;, &quot;false&quot;));
  83     public static final boolean NO_LINGER =
  84             Boolean.parseBoolean(System.getProperty(&quot;test.nolinger&quot;, &quot;false&quot;));
<span class="line-added">  85     public static final boolean TUNNEL_REQUIRES_HOST =</span>
<span class="line-added">  86             Boolean.parseBoolean(System.getProperty(&quot;test.requiresHost&quot;, &quot;false&quot;));</span>
  87     public enum HttpAuthType {
  88         SERVER, PROXY, SERVER307, PROXY305
  89         /* add PROXY_AND_SERVER and SERVER_PROXY_NONE */
  90     };
  91     public enum HttpAuthSchemeType { NONE, BASICSERVER, BASIC, DIGEST };
  92     public static final HttpAuthType DEFAULT_HTTP_AUTH_TYPE = HttpAuthType.SERVER;
  93     public static final String DEFAULT_PROTOCOL_TYPE = &quot;https&quot;;
  94     public static final HttpAuthSchemeType DEFAULT_SCHEME_TYPE = HttpAuthSchemeType.DIGEST;
  95 
  96     public static class HttpTestAuthenticator extends Authenticator {
  97         private final String realm;
  98         private final String username;
  99         // Used to prevent incrementation of &#39;count&#39; when calling the
 100         // authenticator from the server side.
 101         private final ThreadLocal&lt;Boolean&gt; skipCount = new ThreadLocal&lt;&gt;();
 102         // count will be incremented every time getPasswordAuthentication()
 103         // is called from the client side.
 104         final AtomicInteger count = new AtomicInteger();
 105 
 106         public HttpTestAuthenticator(String realm, String username) {
</pre>
<hr />
<pre>
1509             try {
1510                 ss.close();
1511             } catch (IOException ex) {
1512                 if (DEBUG) ex.printStackTrace(System.out);
1513             }
1514         }
1515 
1516 
1517         @Override
1518         void configureAuthentication(HttpTestContext ctxt,
1519                                      HttpAuthSchemeType schemeType,
1520                                      HttpTestAuthenticator auth,
1521                                      HttpAuthType authType) {
1522             if (authType == HttpAuthType.PROXY || authType == HttpAuthType.PROXY305) {
1523                 authorization = new ProxyAuthorization(key, schemeType, auth);
1524             } else {
1525                 super.configureAuthentication(ctxt, schemeType, auth, authType);
1526             }
1527         }
1528 
<span class="line-added">1529         boolean badRequest(StringBuilder response, String hostport, List&lt;String&gt; hosts) {</span>
<span class="line-added">1530             String message = null;</span>
<span class="line-added">1531             if (hosts.isEmpty()) {</span>
<span class="line-added">1532                 message = &quot;No host header provided\r\n&quot;;</span>
<span class="line-added">1533             } else if (hosts.size() &gt; 1) {</span>
<span class="line-added">1534                 message = &quot;Multiple host headers provided\r\n&quot;;</span>
<span class="line-added">1535                 for (String h : hosts) {</span>
<span class="line-added">1536                     message = message + &quot;host: &quot; + h + &quot;\r\n&quot;;</span>
<span class="line-added">1537                 }</span>
<span class="line-added">1538             } else {</span>
<span class="line-added">1539                 String h = hosts.get(0);</span>
<span class="line-added">1540                 if (!hostport.equalsIgnoreCase(h)</span>
<span class="line-added">1541                         &amp;&amp; !hostport.equalsIgnoreCase(h + &quot;:80&quot;)</span>
<span class="line-added">1542                         &amp;&amp; !hostport.equalsIgnoreCase(h + &quot;:443&quot;)) {</span>
<span class="line-added">1543                     message = &quot;Bad host provided: [&quot; + h</span>
<span class="line-added">1544                             + &quot;] doesnot match [&quot; + hostport + &quot;]\r\n&quot;;</span>
<span class="line-added">1545                 }</span>
<span class="line-added">1546             }</span>
<span class="line-added">1547             if (message != null) {</span>
<span class="line-added">1548                 int length = message.getBytes(StandardCharsets.UTF_8).length;</span>
<span class="line-added">1549                 response.append(&quot;HTTP/1.1 400 BadRequest\r\n&quot;)</span>
<span class="line-added">1550                         .append(&quot;Content-Length: &quot; + length)</span>
<span class="line-added">1551                         .append(&quot;\r\n\r\n&quot;)</span>
<span class="line-added">1552                         .append(message);</span>
<span class="line-added">1553                 return true;</span>
<span class="line-added">1554             }</span>
<span class="line-added">1555 </span>
<span class="line-added">1556             return false;</span>
<span class="line-added">1557         }</span>
<span class="line-added">1558 </span>
1559         boolean authorize(StringBuilder response, String requestLine, String headers) {
1560             if (authorization != null) {
1561                 return authorization.authorize(response, requestLine, headers);
1562             }
1563             response.append(&quot;HTTP/1.1 200 OK\r\nContent-Length: 0\r\n\r\n&quot;);
1564             return true;
1565         }
1566 
1567         // Pipe the input stream to the output stream.
1568         private synchronized Thread pipe(InputStream is, OutputStream os, char tag, CompletableFuture&lt;Void&gt; end) {
1569             return new Thread(&quot;TunnelPipe(&quot;+tag+&quot;)&quot;) {
1570                 @Override
1571                 public void run() {
1572                     try {
<span class="line-added">1573                         int c = 0;</span>
1574                         try {

1575                             while ((c = is.read()) != -1) {
1576                                 os.write(c);
1577                                 os.flush();
1578                                 // if DEBUG prints a + or a - for each transferred
1579                                 // character.
1580                                 if (DEBUG) System.out.print(tag);
1581                             }
1582                             is.close();
<span class="line-added">1583                         } catch (IOException ex) {</span>
<span class="line-added">1584                             if (DEBUG || !stopped &amp;&amp; c &gt;  -1)</span>
<span class="line-added">1585                                 ex.printStackTrace(System.out);</span>
<span class="line-added">1586                             end.completeExceptionally(ex);</span>
1587                         } finally {
<span class="line-modified">1588                             try {os.close();} catch (Throwable t) {}</span>
1589                         }


1590                     } finally {
1591                         end.complete(null);
1592                     }
1593                 }
1594             };
1595         }
1596 
1597         @Override
1598         public InetSocketAddress getAddress() {
1599             return new InetSocketAddress(InetAddress.getLoopbackAddress(),
1600                     ss.getLocalPort());
1601         }
1602         @Override
1603         public InetSocketAddress getProxyAddress() {
1604             return getAddress();
1605         }
1606         @Override
1607         public InetSocketAddress getServerAddress() {
1608             // serverImpl can be null if this proxy can serve
1609             // multiple servers.
</pre>
<hr />
<pre>
1619         // Read a line from the input stream, swallowing the final
1620         // \r\n sequence. Stops at the first \n, doesn&#39;t complain
1621         // if it wasn&#39;t preceded by &#39;\r&#39;.
1622         //
1623         String readLine(InputStream r) throws IOException {
1624             StringBuilder b = new StringBuilder();
1625             int c;
1626             while ((c = r.read()) != -1) {
1627                 if (c == &#39;\n&#39;) break;
1628                 b.appendCodePoint(c);
1629             }
1630             if (b.codePointAt(b.length() -1) == &#39;\r&#39;) {
1631                 b.delete(b.length() -1, b.length());
1632             }
1633             return b.toString();
1634         }
1635 
1636         @Override
1637         public void run() {
1638             Socket clientConnection = null;
<span class="line-added">1639             Socket targetConnection = null;</span>
1640             try {
1641                 while (!stopped) {
1642                     System.out.println(now() + &quot;Tunnel: Waiting for client&quot;);
1643                     Socket toClose;
<span class="line-added">1644                     targetConnection = clientConnection = null;</span>
1645                     try {
1646                         toClose = clientConnection = ss.accept();
1647                         if (NO_LINGER) {
1648                             // can be useful to trigger &quot;Connection reset by peer&quot;
1649                             // errors on the client side.
1650                             clientConnection.setOption(StandardSocketOptions.SO_LINGER, 0);
1651                         }
1652                     } catch (IOException io) {
1653                         if (DEBUG || !stopped) io.printStackTrace(System.out);
1654                         break;
1655                     }
1656                     System.out.println(now() + &quot;Tunnel: Client accepted&quot;);
1657                     StringBuilder headers = new StringBuilder();

1658                     InputStream  ccis = clientConnection.getInputStream();
1659                     OutputStream ccos = clientConnection.getOutputStream();
1660                     Writer w = new OutputStreamWriter(
1661                                    clientConnection.getOutputStream(), &quot;UTF-8&quot;);
1662                     PrintWriter pw = new PrintWriter(w);
1663                     System.out.println(now() + &quot;Tunnel: Reading request line&quot;);
1664                     String requestLine = readLine(ccis);
1665                     System.out.println(now() + &quot;Tunnel: Request line: &quot; + requestLine);
1666                     if (requestLine.startsWith(&quot;CONNECT &quot;)) {
1667                         // We should probably check that the next word following
1668                         // CONNECT is the host:port of our HTTPS serverImpl.
1669                         // Some improvement for a followup!
1670                         StringTokenizer tokenizer = new StringTokenizer(requestLine);
1671                         String connect = tokenizer.nextToken();
1672                         assert connect.equalsIgnoreCase(&quot;connect&quot;);
1673                         String hostport = tokenizer.nextToken();
1674                         InetSocketAddress targetAddress;
<span class="line-added">1675                         List&lt;String&gt; hosts = new ArrayList&lt;&gt;();</span>
1676                         try {
1677                             URI uri = new URI(&quot;https&quot;, hostport, &quot;/&quot;, null, null);
1678                             int port = uri.getPort();
1679                             port = port == -1 ? 443 : port;
1680                             targetAddress = new InetSocketAddress(uri.getHost(), port);
1681                             if (serverImpl != null) {
1682                                 assert targetAddress.getHostString()
1683                                         .equalsIgnoreCase(serverImpl.getAddress().getHostString());
1684                                 assert targetAddress.getPort() == serverImpl.getAddress().getPort();
1685                             }
1686                         } catch (Throwable x) {
1687                             System.err.printf(&quot;Bad target address: \&quot;%s\&quot; in \&quot;%s\&quot;%n&quot;,
1688                                     hostport, requestLine);
1689                             toClose.close();
1690                             continue;
1691                         }
1692 
1693                         // Read all headers until we find the empty line that
1694                         // signals the end of all headers.
1695                         String line = requestLine;
1696                         while(!line.equals(&quot;&quot;)) {
1697                             System.out.println(now() + &quot;Tunnel: Reading header: &quot;
1698                                                + (line = readLine(ccis)));
1699                             headers.append(line).append(&quot;\r\n&quot;);
<span class="line-added">1700                             int index = line.indexOf(&#39;:&#39;);</span>
<span class="line-added">1701                             if (index &gt;= 0) {</span>
<span class="line-added">1702                                 String key = line.substring(0, index).trim();</span>
<span class="line-added">1703                                 if (key.equalsIgnoreCase(&quot;host&quot;)) {</span>
<span class="line-added">1704                                     hosts.add(line.substring(index+1).trim());</span>
<span class="line-added">1705                                 }</span>
<span class="line-added">1706                             }</span>
1707                         }

1708                         StringBuilder response = new StringBuilder();
<span class="line-added">1709                         if (TUNNEL_REQUIRES_HOST) {</span>
<span class="line-added">1710                             if (badRequest(response, hostport, hosts)) {</span>
<span class="line-added">1711                                 System.out.println(now() + &quot;Tunnel: Sending &quot; + response);</span>
<span class="line-added">1712                                 // send the 400 response</span>
<span class="line-added">1713                                 pw.print(response.toString());</span>
<span class="line-added">1714                                 pw.flush();</span>
<span class="line-added">1715                                 toClose.close();</span>
<span class="line-added">1716                                 continue;</span>
<span class="line-added">1717                             } else {</span>
<span class="line-added">1718                                 assert hosts.size() == 1;</span>
<span class="line-added">1719                                 System.out.println(now()</span>
<span class="line-added">1720                                         + &quot;Tunnel: Host header verified &quot; + hosts);</span>
<span class="line-added">1721                             }</span>
<span class="line-added">1722                         }</span>
<span class="line-added">1723 </span>
1724                         final boolean authorize = authorize(response, requestLine, headers.toString());
1725                         if (!authorize) {
1726                             System.out.println(now() + &quot;Tunnel: Sending &quot;
1727                                     + response);
1728                             // send the 407 response
1729                             pw.print(response.toString());
1730                             pw.flush();
1731                             toClose.close();
1732                             continue;
1733                         }
1734                         System.out.println(now()
1735                                 + &quot;Tunnel connecting to target server at &quot;
1736                                 + targetAddress.getAddress() + &quot;:&quot; + targetAddress.getPort());
1737                         targetConnection = new Socket(
1738                                 targetAddress.getAddress(),
1739                                 targetAddress.getPort());
1740 
1741                         // Then send the 200 OK response to the client
1742                         System.out.println(now() + &quot;Tunnel: Sending &quot;
1743                                            + response);
</pre>
<hr />
<pre>
1757                         System.err.println(&quot;WARNING: Tunnel: Unexpected status line: &quot;
1758                                              + requestLine + &quot; received by &quot;
1759                                            + ss.getLocalSocketAddress()
1760                                            + &quot; from &quot;
1761                                            + toClose.getRemoteSocketAddress());
1762                         // close accepted socket.
1763                         toClose.close();
1764                         System.err.println(&quot;Tunnel: accepted socket closed.&quot;);
1765                         continue;
1766                     }
1767 
1768                     // Pipe the input stream of the client connection to the
1769                     // output stream of the target connection and conversely.
1770                     // Now the client and target will just talk to each other.
1771                     System.out.println(now() + &quot;Tunnel: Starting tunnel pipes&quot;);
1772                     CompletableFuture&lt;Void&gt; end, end1, end2;
1773                     Thread t1 = pipe(ccis, targetConnection.getOutputStream(), &#39;+&#39;,
1774                             end1 = new CompletableFuture&lt;&gt;());
1775                     Thread t2 = pipe(targetConnection.getInputStream(), ccos, &#39;-&#39;,
1776                             end2 = new CompletableFuture&lt;&gt;());
<span class="line-modified">1777                     var end11 = end1.whenComplete((r, t) -&gt; exceptionally(end2, t));</span>
<span class="line-added">1778                     var end22 = end2.whenComplete((r, t) -&gt;  exceptionally(end1, t));</span>
<span class="line-added">1779                     end = CompletableFuture.allOf(end11, end22);</span>
<span class="line-added">1780                     Socket tc = targetConnection;</span>
1781                     end.whenComplete(
1782                             (r,t) -&gt; {
1783                                 try { toClose.close(); } catch (IOException x) { }
<span class="line-added">1784                                 try { tc.close(); } catch (IOException x) { }</span>
1785                                 finally {connectionCFs.remove(end);}
1786                             });
1787                     connectionCFs.add(end);
<span class="line-added">1788                     targetConnection = clientConnection = null;</span>
1789                     t1.start();
1790                     t2.start();
1791                 }
1792             } catch (Throwable ex) {
<span class="line-modified">1793                 close(clientConnection, ex);</span>
<span class="line-modified">1794                 close(targetConnection, ex);</span>
<span class="line-modified">1795                 close(ss, ex);</span>


1796                 ex.printStackTrace(System.err);
1797             } finally {
1798                 System.out.println(now() + &quot;Tunnel: exiting (stopped=&quot; + stopped + &quot;)&quot;);
1799                 connectionCFs.forEach(cf -&gt; cf.complete(null));
1800             }
1801         }
<span class="line-added">1802 </span>
<span class="line-added">1803         void exceptionally(CompletableFuture&lt;?&gt; cf, Throwable t) {</span>
<span class="line-added">1804             if (t != null) cf.completeExceptionally(t);</span>
<span class="line-added">1805         }</span>
<span class="line-added">1806 </span>
<span class="line-added">1807         void close(Closeable c, Throwable e) {</span>
<span class="line-added">1808             if (c == null) return;</span>
<span class="line-added">1809             try {</span>
<span class="line-added">1810                 c.close();</span>
<span class="line-added">1811             } catch (IOException x) {</span>
<span class="line-added">1812                 e.addSuppressed(x);</span>
<span class="line-added">1813             }</span>
<span class="line-added">1814         }</span>
1815     }
1816 
1817     /**
1818      * Creates a TunnelingProxy that can serve multiple servers.
1819      * The server address is extracted from the CONNECT request line.
1820      * @param authScheme The authentication scheme supported by the proxy.
1821      *                   Typically one of DIGEST, BASIC, NONE.
1822      * @return A new TunnelingProxy able to serve multiple servers.
1823      * @throws IOException If the proxy could not be created.
1824      */
1825     public static TunnelingProxy createHttpsProxyTunnel(HttpAuthSchemeType authScheme)
1826             throws IOException {
1827         HttpsProxyTunnel result = new HttpsProxyTunnel(&quot;&quot;, null, null, null);
1828         if (authScheme != HttpAuthSchemeType.NONE) {
1829             result.configureAuthentication(null,
1830                                            authScheme,
1831                                            AUTHENTICATOR,
1832                                            HttpAuthType.PROXY);
1833         }
1834         return result;
</pre>
</td>
</tr>
</table>
<center><a href="AuthSchemesTest.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="HandshakeFailureTest.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
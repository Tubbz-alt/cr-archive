<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New test/jdk/java/net/httpclient/reactivestreams-tck/org/reactivestreams/tck/PublisherVerification.java</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 2019, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  */
  23 
  24 package org.reactivestreams.tck;
  25 
  26 import org.reactivestreams.Publisher;
  27 import org.reactivestreams.Subscriber;
  28 import org.reactivestreams.Subscription;
  29 import org.reactivestreams.tck.TestEnvironment.BlackholeSubscriberWithSubscriptionSupport;
  30 import org.reactivestreams.tck.TestEnvironment.Latch;
  31 import org.reactivestreams.tck.TestEnvironment.ManualSubscriber;
  32 import org.reactivestreams.tck.TestEnvironment.ManualSubscriberWithSubscriptionSupport;
  33 import org.reactivestreams.tck.flow.support.Function;
  34 import org.reactivestreams.tck.flow.support.Optional;
  35 import org.reactivestreams.tck.flow.support.PublisherVerificationRules;
  36 import org.testng.SkipException;
  37 import org.testng.annotations.BeforeMethod;
  38 import org.testng.annotations.Test;
  39 
  40 import java.lang.Override;
  41 import java.lang.ref.ReferenceQueue;
  42 import java.lang.ref.WeakReference;
  43 import java.util.ArrayList;
  44 import java.util.Arrays;
  45 import java.util.Collections;
  46 import java.util.List;
  47 import java.util.Random;
  48 import java.util.concurrent.atomic.AtomicInteger;
  49 import java.util.concurrent.atomic.AtomicReference;
  50 
  51 import static org.testng.Assert.assertEquals;
  52 import static org.testng.Assert.assertTrue;
  53 
  54 /**
  55  * Provides tests for verifying {@code Publisher} specification rules.
  56  *
  57  * @see org.reactivestreams.Publisher
  58  */
  59 public abstract class PublisherVerification&lt;T&gt; implements PublisherVerificationRules {
  60 
  61   private static final String PUBLISHER_REFERENCE_GC_TIMEOUT_MILLIS_ENV = &quot;PUBLISHER_REFERENCE_GC_TIMEOUT_MILLIS&quot;;
  62   private static final long DEFAULT_PUBLISHER_REFERENCE_GC_TIMEOUT_MILLIS = 300L;
  63 
  64   private final TestEnvironment env;
  65 
  66   /**
  67    * The amount of time after which a cancelled Subscriber reference should be dropped.
  68    * See Rule 3.13 for details.
  69    */
  70   private final long publisherReferenceGCTimeoutMillis;
  71 
  72   /**
  73    * Constructs a new verification class using the given env and configuration.
  74    *
  75    * @param publisherReferenceGCTimeoutMillis used to determine after how much time a reference to a Subscriber should be already dropped by the Publisher.
  76    */
  77   public PublisherVerification(TestEnvironment env, long publisherReferenceGCTimeoutMillis) {
  78     this.env = env;
  79     this.publisherReferenceGCTimeoutMillis = publisherReferenceGCTimeoutMillis;
  80   }
  81 
  82   /**
  83    * Constructs a new verification class using the given env and configuration.
  84    *
  85    * The value for {@code publisherReferenceGCTimeoutMillis} will be obtained by using {@link PublisherVerification#envPublisherReferenceGCTimeoutMillis()}.
  86    */
  87   public PublisherVerification(TestEnvironment env) {
  88     this.env = env;
  89     this.publisherReferenceGCTimeoutMillis = envPublisherReferenceGCTimeoutMillis();
  90   }
  91 
  92   /**
  93    * Tries to parse the env variable {@code PUBLISHER_REFERENCE_GC_TIMEOUT_MILLIS} as long and returns the value if present,
  94    * OR its default value ({@link PublisherVerification#DEFAULT_PUBLISHER_REFERENCE_GC_TIMEOUT_MILLIS}).
  95    *
  96    * This value is used to determine after how much time a reference to a Subscriber should be already dropped by the Publisher.
  97    *
  98    * @throws java.lang.IllegalArgumentException when unable to parse the env variable
  99    */
 100   public static long envPublisherReferenceGCTimeoutMillis() {
 101     final String envMillis = System.getenv(PUBLISHER_REFERENCE_GC_TIMEOUT_MILLIS_ENV);
 102     if (envMillis == null) return DEFAULT_PUBLISHER_REFERENCE_GC_TIMEOUT_MILLIS;
 103     else try {
 104       return Long.parseLong(envMillis);
 105     } catch (NumberFormatException ex) {
 106       throw new IllegalArgumentException(String.format(&quot;Unable to parse %s env value [%s] as long!&quot;, PUBLISHER_REFERENCE_GC_TIMEOUT_MILLIS_ENV, envMillis), ex);
 107     }
 108   }
 109 
 110   /**
 111    * This is the main method you must implement in your test incarnation.
 112    * It must create a Publisher for a stream with exactly the given number of elements.
 113    * If `elements` is `Long.MAX_VALUE` the produced stream must be infinite.
 114    */
 115   public abstract Publisher&lt;T&gt; createPublisher(long elements);
 116 
 117   /**
 118    * By implementing this method, additional TCK tests concerning a &quot;failed&quot; publishers will be run.
 119    *
 120    * The expected behaviour of the {@link Publisher} returned by this method is hand out a subscription,
 121    * followed by signalling {@code onError} on it, as specified by Rule 1.9.
 122    *
 123    * If you ignore these additional tests, return {@code null} from this method.
 124    */
 125   public abstract Publisher&lt;T&gt; createFailedPublisher();
 126 
 127 
 128   /**
 129    * Override and return lower value if your Publisher is only able to produce a known number of elements.
 130    * For example, if it is designed to return at-most-one element, return {@code 1} from this method.
 131    *
 132    * Defaults to {@code Long.MAX_VALUE - 1}, meaning that the Publisher can be produce a huge but NOT an unbounded number of elements.
 133    *
 134    * To mark your Publisher will *never* signal an {@code onComplete} override this method and return {@code Long.MAX_VALUE},
 135    * which will result in *skipping all tests which require an onComplete to be triggered* (!).
 136    */
 137   public long maxElementsFromPublisher() {
 138     return Long.MAX_VALUE - 1;
 139   }
 140 
 141   /**
 142    * Override and return {@code true} in order to skip executing tests marked as {@code Stochastic}.
 143    * Stochastic in this case means that the Rule is impossible or infeasible to deterministically verifyâ€”
 144    * usually this means that this test case can yield false positives (&quot;be green&quot;) even if for some case,
 145    * the given implementation may violate the tested behaviour.
 146    */
 147   public boolean skipStochasticTests() {
 148     return false;
 149   }
 150 
 151   /**
 152    * In order to verify rule 3.3 of the reactive streams spec, this number will be used to check if a
 153    * {@code Subscription} actually solves the &quot;unbounded recursion&quot; problem by not allowing the number of
 154    * recursive calls to exceed the number returned by this method.
 155    *
 156    * @see &lt;a href=&quot;https://github.com/reactive-streams/reactive-streams-jvm#3.3&quot;&gt;reactive streams spec, rule 3.3&lt;/a&gt;
 157    * @see PublisherVerification#required_spec303_mustNotAllowUnboundedRecursion()
 158    */
 159   public long boundedDepthOfOnNextAndRequestRecursion() {
 160     return 1;
 161   }
 162 
 163   ////////////////////// TEST ENV CLEANUP /////////////////////////////////////
 164 
 165   @BeforeMethod
 166   public void setUp() throws Exception {
 167     env.clearAsyncErrors();
 168   }
 169 
 170   ////////////////////// TEST SETUP VERIFICATION //////////////////////////////
 171 
 172   @Override @Test
 173   public void required_createPublisher1MustProduceAStreamOfExactly1Element() throws Throwable {
 174     activePublisherTest(1, true, new PublisherTestRun&lt;T&gt;() {
 175       @Override
 176       public void run(Publisher&lt;T&gt; pub) throws InterruptedException {
 177         ManualSubscriber&lt;T&gt; sub = env.newManualSubscriber(pub);
 178         assertTrue(requestNextElementOrEndOfStream(pub, sub).isDefined(), String.format(&quot;Publisher %s produced no elements&quot;, pub));
 179         sub.requestEndOfStream();
 180       }
 181 
 182       Optional&lt;T&gt; requestNextElementOrEndOfStream(Publisher&lt;T&gt; pub, ManualSubscriber&lt;T&gt; sub) throws InterruptedException {
 183         return sub.requestNextElementOrEndOfStream(String.format(&quot;Timeout while waiting for next element from Publisher %s&quot;, pub));
 184       }
 185 
 186     });
 187   }
 188 
 189   @Override @Test
 190   public void required_createPublisher3MustProduceAStreamOfExactly3Elements() throws Throwable {
 191     activePublisherTest(3, true, new PublisherTestRun&lt;T&gt;() {
 192       @Override
 193       public void run(Publisher&lt;T&gt; pub) throws InterruptedException {
 194         ManualSubscriber&lt;T&gt; sub = env.newManualSubscriber(pub);
 195         assertTrue(requestNextElementOrEndOfStream(pub, sub).isDefined(), String.format(&quot;Publisher %s produced no elements&quot;, pub));
 196         assertTrue(requestNextElementOrEndOfStream(pub, sub).isDefined(), String.format(&quot;Publisher %s produced only 1 element&quot;, pub));
 197         assertTrue(requestNextElementOrEndOfStream(pub, sub).isDefined(), String.format(&quot;Publisher %s produced only 2 elements&quot;, pub));
 198         sub.requestEndOfStream();
 199       }
 200 
 201       Optional&lt;T&gt; requestNextElementOrEndOfStream(Publisher&lt;T&gt; pub, ManualSubscriber&lt;T&gt; sub) throws InterruptedException {
 202         return sub.requestNextElementOrEndOfStream(String.format(&quot;Timeout while waiting for next element from Publisher %s&quot;, pub));
 203       }
 204 
 205     });
 206   }
 207 
 208   @Override @Test
 209   public void required_validate_maxElementsFromPublisher() throws Exception {
 210     assertTrue(maxElementsFromPublisher() &gt;= 0, &quot;maxElementsFromPublisher MUST return a number &gt;= 0&quot;);
 211   }
 212 
 213   @Override @Test
 214   public void required_validate_boundedDepthOfOnNextAndRequestRecursion() throws Exception {
 215     assertTrue(boundedDepthOfOnNextAndRequestRecursion() &gt;= 1, &quot;boundedDepthOfOnNextAndRequestRecursion must return a number &gt;= 1&quot;);
 216   }
 217 
 218 
 219   ////////////////////// SPEC RULE VERIFICATION ///////////////////////////////
 220 
 221   @Override @Test
 222   public void required_spec101_subscriptionRequestMustResultInTheCorrectNumberOfProducedElements() throws Throwable {
 223     activePublisherTest(5, false, new PublisherTestRun&lt;T&gt;() {
 224       @Override
 225       public void run(Publisher&lt;T&gt; pub) throws InterruptedException {
 226 
 227         ManualSubscriber&lt;T&gt; sub = env.newManualSubscriber(pub);
 228         try {
 229             sub.expectNone(String.format(&quot;Publisher %s produced value before the first `request`: &quot;, pub));
 230             sub.request(1);
 231             sub.nextElement(String.format(&quot;Publisher %s produced no element after first `request`&quot;, pub));
 232             sub.expectNone(String.format(&quot;Publisher %s produced unrequested: &quot;, pub));
 233 
 234             sub.request(1);
 235             sub.request(2);
 236             sub.nextElements(3, env.defaultTimeoutMillis(), String.format(&quot;Publisher %s produced less than 3 elements after two respective `request` calls&quot;, pub));
 237 
 238             sub.expectNone(String.format(&quot;Publisher %sproduced unrequested &quot;, pub));
 239         } finally {
 240             sub.cancel();
 241         }
 242       }
 243     });
 244   }
 245 
 246   @Override @Test
 247   public void required_spec102_maySignalLessThanRequestedAndTerminateSubscription() throws Throwable {
 248     final int elements = 3;
 249     final int requested = 10;
 250 
 251     activePublisherTest(elements, true, new PublisherTestRun&lt;T&gt;() {
 252       @Override
 253       public void run(Publisher&lt;T&gt; pub) throws Throwable {
 254         final ManualSubscriber&lt;T&gt; sub = env.newManualSubscriber(pub);
 255         sub.request(requested);
 256         sub.nextElements(elements);
 257         sub.expectCompletion();
 258       }
 259     });
 260   }
 261 
 262   @Override @Test
 263   public void stochastic_spec103_mustSignalOnMethodsSequentially() throws Throwable {
 264     final int iterations = 100;
 265     final int elements = 10;
 266 
 267     stochasticTest(iterations, new Function&lt;Integer, Void&gt;() {
 268       @Override
 269       public Void apply(final Integer runNumber) throws Throwable {
 270         activePublisherTest(elements, true, new PublisherTestRun&lt;T&gt;() {
 271           @Override
 272           public void run(Publisher&lt;T&gt; pub) throws Throwable {
 273             final Latch completionLatch = new Latch(env);
 274 
 275             final AtomicInteger gotElements = new AtomicInteger(0);
 276             pub.subscribe(new Subscriber&lt;T&gt;() {
 277               private Subscription subs;
 278 
 279               private ConcurrentAccessBarrier concurrentAccessBarrier = new ConcurrentAccessBarrier();
 280 
 281               /**
 282                * Concept wise very similar to a {@link org.reactivestreams.tck.TestEnvironment.Latch}, serves to protect
 283                * a critical section from concurrent access, with the added benefit of Thread tracking and same-thread-access awareness.
 284                *
 285                * Since a &lt;i&gt;Synchronous&lt;/i&gt; Publisher may choose to synchronously (using the same {@link Thread}) call
 286                * {@code onNext} directly from either {@code subscribe} or {@code request} a plain Latch is not enough
 287                * to verify concurrent access safety - one needs to track if the caller is not still using the calling thread
 288                * to enter subsequent critical sections (&quot;nesting&quot; them effectively).
 289                */
 290               final class ConcurrentAccessBarrier {
 291                 private AtomicReference&lt;Thread&gt; currentlySignallingThread = new AtomicReference&lt;Thread&gt;(null);
 292                 private volatile String previousSignal = null;
 293 
 294                 public void enterSignal(String signalName) {
 295                   if((!currentlySignallingThread.compareAndSet(null, Thread.currentThread())) &amp;&amp; !isSynchronousSignal()) {
 296                     env.flop(String.format(
 297                       &quot;Illegal concurrent access detected (entering critical section)! &quot; +
 298                         &quot;%s emited %s signal, before %s finished its %s signal.&quot;,
 299                         Thread.currentThread(), signalName, currentlySignallingThread.get(), previousSignal));
 300                   }
 301                   this.previousSignal = signalName;
 302                 }
 303 
 304                 public void leaveSignal(String signalName) {
 305                   currentlySignallingThread.set(null);
 306                   this.previousSignal = signalName;
 307                 }
 308 
 309                 private boolean isSynchronousSignal() {
 310                   return (previousSignal != null) &amp;&amp; Thread.currentThread().equals(currentlySignallingThread.get());
 311                 }
 312 
 313               }
 314 
 315               @Override
 316               public void onSubscribe(Subscription s) {
 317                 final String signal = &quot;onSubscribe()&quot;;
 318                 concurrentAccessBarrier.enterSignal(signal);
 319 
 320                 subs = s;
 321                 subs.request(1);
 322 
 323                 concurrentAccessBarrier.leaveSignal(signal);
 324               }
 325 
 326               @Override
 327               public void onNext(T ignore) {
 328                 final String signal = String.format(&quot;onNext(%s)&quot;, ignore);
 329                 concurrentAccessBarrier.enterSignal(signal);
 330 
 331                 if (gotElements.incrementAndGet() &lt;= elements) // requesting one more than we know are in the stream (some Publishers need this)
 332                   subs.request(1);
 333 
 334                 concurrentAccessBarrier.leaveSignal(signal);
 335               }
 336 
 337               @Override
 338               public void onError(Throwable t) {
 339                 final String signal = String.format(&quot;onError(%s)&quot;, t.getMessage());
 340                 concurrentAccessBarrier.enterSignal(signal);
 341 
 342                 // ignore value
 343 
 344                 concurrentAccessBarrier.leaveSignal(signal);
 345               }
 346 
 347               @Override
 348               public void onComplete() {
 349                 final String signal = &quot;onComplete()&quot;;
 350                 concurrentAccessBarrier.enterSignal(signal);
 351 
 352                 // entering for completeness
 353 
 354                 concurrentAccessBarrier.leaveSignal(signal);
 355                 completionLatch.close();
 356               }
 357             });
 358 
 359             completionLatch.expectClose(
 360               elements * env.defaultTimeoutMillis(),
 361               String.format(&quot;Failed in iteration %d of %d. Expected completion signal after signalling %d elements (signalled %d), yet did not receive it&quot;,
 362                             runNumber, iterations, elements, gotElements.get()));
 363           }
 364         });
 365         return null;
 366       }
 367     });
 368   }
 369 
 370   @Override @Test
 371   public void optional_spec104_mustSignalOnErrorWhenFails() throws Throwable {
 372     try {
 373       whenHasErrorPublisherTest(new PublisherTestRun&lt;T&gt;() {
 374         @Override
 375         public void run(final Publisher&lt;T&gt; pub) throws InterruptedException {
 376           final Latch onErrorlatch = new Latch(env);
 377           final Latch onSubscribeLatch = new Latch(env);
 378           pub.subscribe(new TestEnvironment.TestSubscriber&lt;T&gt;(env) {
 379             @Override
 380             public void onSubscribe(Subscription subs) {
 381               onSubscribeLatch.assertOpen(&quot;Only one onSubscribe call expected&quot;);
 382               onSubscribeLatch.close();
 383             }
 384             @Override
 385             public void onError(Throwable cause) {
 386               onSubscribeLatch.assertClosed(&quot;onSubscribe should be called prior to onError always&quot;);
 387               onErrorlatch.assertOpen(String.format(&quot;Error-state Publisher %s called `onError` twice on new Subscriber&quot;, pub));
 388               onErrorlatch.close();
 389             }
 390           });
 391 
 392           onSubscribeLatch.expectClose(&quot;Should have received onSubscribe&quot;);
 393           onErrorlatch.expectClose(String.format(&quot;Error-state Publisher %s did not call `onError` on new Subscriber&quot;, pub));
 394 
 395           env.verifyNoAsyncErrors();
 396           }
 397       });
 398     } catch (SkipException se) {
 399       throw se;
 400     } catch (Throwable ex) {
 401       // we also want to catch AssertionErrors and anything the publisher may have thrown inside subscribe
 402       // which was wrong of him - he should have signalled on error using onError
 403       throw new RuntimeException(String.format(&quot;Publisher threw exception (%s) instead of signalling error via onError!&quot;, ex.getMessage()), ex);
 404     }
 405   }
 406 
 407   @Override @Test
 408   public void required_spec105_mustSignalOnCompleteWhenFiniteStreamTerminates() throws Throwable {
 409     activePublisherTest(3, true, new PublisherTestRun&lt;T&gt;() {
 410       @Override
 411       public void run(Publisher&lt;T&gt; pub) throws Throwable {
 412         ManualSubscriber&lt;T&gt; sub = env.newManualSubscriber(pub);
 413         sub.requestNextElement();
 414         sub.requestNextElement();
 415         sub.requestNextElement();
 416         sub.requestEndOfStream();
 417         sub.expectNone();
 418       }
 419     });
 420   }
 421 
 422   @Override @Test
 423   public void optional_spec105_emptyStreamMustTerminateBySignallingOnComplete() throws Throwable {
 424     optionalActivePublisherTest(0, true, new PublisherTestRun&lt;T&gt;() {
 425       @Override
 426       public void run(Publisher&lt;T&gt; pub) throws Throwable {
 427         ManualSubscriber&lt;T&gt; sub = env.newManualSubscriber(pub);
 428         sub.request(1);
 429         sub.expectCompletion();
 430         sub.expectNone();
 431       }
 432     });
 433   }
 434 
 435   @Override @Test
 436   public void untested_spec106_mustConsiderSubscriptionCancelledAfterOnErrorOrOnCompleteHasBeenCalled() throws Throwable {
 437     notVerified(); // not really testable without more control over the Publisher
 438   }
 439 
 440   @Override @Test
 441   public void required_spec107_mustNotEmitFurtherSignalsOnceOnCompleteHasBeenSignalled() throws Throwable {
 442     activePublisherTest(1, true, new PublisherTestRun&lt;T&gt;() {
 443       @Override
 444       public void run(Publisher&lt;T&gt; pub) throws Throwable {
 445         ManualSubscriber&lt;T&gt; sub = env.newManualSubscriber(pub);
 446         sub.request(10);
 447         sub.nextElement();
 448         sub.expectCompletion();
 449 
 450         sub.request(10);
 451         sub.expectNone();
 452       }
 453     });
 454   }
 455 
 456   @Override @Test
 457   public void untested_spec107_mustNotEmitFurtherSignalsOnceOnErrorHasBeenSignalled() throws Throwable {
 458     notVerified(); // can we meaningfully test this, without more control over the publisher?
 459   }
 460 
 461   @Override @Test
 462   public void untested_spec108_possiblyCanceledSubscriptionShouldNotReceiveOnErrorOrOnCompleteSignals() throws Throwable {
 463     notVerified(); // can we meaningfully test this?
 464   }
 465 
 466   @Override @Test
 467   public void untested_spec109_subscribeShouldNotThrowNonFatalThrowable() throws Throwable {
 468     notVerified(); // can we meaningfully test this?
 469   }
 470 
 471   @Override @Test
 472   public void required_spec109_subscribeThrowNPEOnNullSubscriber() throws Throwable {
 473     activePublisherTest(0, false, new PublisherTestRun&lt;T&gt;() {
 474       @Override
 475       public void run(Publisher&lt;T&gt; pub) throws Throwable {
 476         try {
 477             pub.subscribe(null);
 478             env.flop(&quot;Publisher did not throw a NullPointerException when given a null Subscribe in subscribe&quot;);
 479         } catch (NullPointerException ignored) {
 480           // valid behaviour
 481         }
 482         env.verifyNoAsyncErrorsNoDelay();
 483       }
 484     });
 485   }
 486 
 487   @Override @Test
 488   public void required_spec109_mustIssueOnSubscribeForNonNullSubscriber() throws Throwable {
 489     activePublisherTest(0, false, new PublisherTestRun&lt;T&gt;() {
 490       @Override
 491       public void run(Publisher&lt;T&gt; pub) throws Throwable {
 492         final Latch onSubscribeLatch = new Latch(env);
 493         final AtomicReference&lt;Subscription&gt; cancel = new AtomicReference&lt;Subscription&gt;();
 494         try {
 495           pub.subscribe(new Subscriber&lt;T&gt;() {
 496             @Override
 497             public void onError(Throwable cause) {
 498               onSubscribeLatch.assertClosed(&quot;onSubscribe should be called prior to onError always&quot;);
 499             }
 500 
 501             @Override
 502             public void onSubscribe(Subscription subs) {
 503               cancel.set(subs);
 504               onSubscribeLatch.assertOpen(&quot;Only one onSubscribe call expected&quot;);
 505               onSubscribeLatch.close();
 506             }
 507 
 508             @Override
 509             public void onNext(T elem) {
 510               onSubscribeLatch.assertClosed(&quot;onSubscribe should be called prior to onNext always&quot;);
 511             }
 512 
 513             @Override
 514             public void onComplete() {
 515               onSubscribeLatch.assertClosed(&quot;onSubscribe should be called prior to onComplete always&quot;);
 516             }
 517           });
 518           onSubscribeLatch.expectClose(&quot;Should have received onSubscribe&quot;);
 519           env.verifyNoAsyncErrorsNoDelay();
 520         } finally {
 521           Subscription s = cancel.getAndSet(null);
 522           if (s != null) {
 523             s.cancel();
 524           }
 525         }
 526       }
 527     });
 528   }
 529 
 530   @Override @Test
 531   public void required_spec109_mayRejectCallsToSubscribeIfPublisherIsUnableOrUnwillingToServeThemRejectionMustTriggerOnErrorAfterOnSubscribe() throws Throwable {
 532     whenHasErrorPublisherTest(new PublisherTestRun&lt;T&gt;() {
 533       @Override
 534       public void run(Publisher&lt;T&gt; pub) throws Throwable {
 535         final Latch onErrorLatch = new Latch(env);
 536         final Latch onSubscribeLatch = new Latch(env);
 537         ManualSubscriberWithSubscriptionSupport&lt;T&gt; sub = new ManualSubscriberWithSubscriptionSupport&lt;T&gt;(env) {
 538           @Override
 539           public void onError(Throwable cause) {
 540             onSubscribeLatch.assertClosed(&quot;onSubscribe should be called prior to onError always&quot;);
 541             onErrorLatch.assertOpen(&quot;Only one onError call expected&quot;);
 542             onErrorLatch.close();
 543           }
 544 
 545           @Override
 546           public void onSubscribe(Subscription subs) {
 547             onSubscribeLatch.assertOpen(&quot;Only one onSubscribe call expected&quot;);
 548             onSubscribeLatch.close();
 549           }
 550         };
 551         pub.subscribe(sub);
 552         onSubscribeLatch.expectClose(&quot;Should have received onSubscribe&quot;);
 553         onErrorLatch.expectClose(&quot;Should have received onError&quot;);
 554 
 555         env.verifyNoAsyncErrorsNoDelay();
 556       }
 557     });
 558   }
 559 
 560   @Override @Test
 561   public void untested_spec110_rejectASubscriptionRequestIfTheSameSubscriberSubscribesTwice() throws Throwable {
 562     notVerified(); // can we meaningfully test this?
 563   }
 564 
 565   // Verifies rule: https://github.com/reactive-streams/reactive-streams-jvm#1.11
 566   @Override @Test
 567   public void optional_spec111_maySupportMultiSubscribe() throws Throwable {
 568     optionalActivePublisherTest(1, false, new PublisherTestRun&lt;T&gt;() {
 569       @Override
 570       public void run(Publisher&lt;T&gt; pub) throws Throwable {
 571         ManualSubscriber&lt;T&gt; sub1 = env.newManualSubscriber(pub);
 572         ManualSubscriber&lt;T&gt; sub2 = env.newManualSubscriber(pub);
 573 
 574         try {
 575           env.verifyNoAsyncErrors();
 576         } finally {
 577           try {
 578             sub1.cancel();
 579           } finally {
 580             sub2.cancel();
 581           }
 582         }
 583       }
 584     });
 585   }
 586 
 587   @Override @Test
 588   public void optional_spec111_registeredSubscribersMustReceiveOnNextOrOnCompleteSignals() throws Throwable {
 589     optionalActivePublisherTest(1, false, new PublisherTestRun&lt;T&gt;() {
 590       @Override
 591       public void run(Publisher&lt;T&gt; pub) throws Throwable {
 592         ManualSubscriber&lt;T&gt; sub1 = env.newManualSubscriber(pub);
 593         ManualSubscriber&lt;T&gt; sub2 = env.newManualSubscriber(pub);
 594         // Since we&#39;re testing the case when the Publisher DOES support the optional multi-subscribers scenario,
 595         // and decides if it handles them uni-cast or multi-cast, we don&#39;t know which subscriber will receive an
 596         // onNext (and optional onComplete) signal(s) and which just onComplete signal.
 597         // Plus, even if subscription assumed to be unicast, it&#39;s implementation choice, which one will be signalled
 598         // with onNext.
 599         sub1.requestNextElementOrEndOfStream();
 600         sub2.requestNextElementOrEndOfStream();
 601         try {
 602             env.verifyNoAsyncErrors();
 603         } finally {
 604             try {
 605                 sub1.cancel();
 606             } finally {
 607                 sub2.cancel();
 608             }
 609         }
 610       }
 611     });
 612   }
 613 
 614   @Override @Test
 615   public void optional_spec111_multicast_mustProduceTheSameElementsInTheSameSequenceToAllOfItsSubscribersWhenRequestingOneByOne() throws Throwable {
 616     optionalActivePublisherTest(5, true, new PublisherTestRun&lt;T&gt;() { // This test is skipped if the publisher is unbounded (never sends onComplete)
 617       @Override
 618       public void run(Publisher&lt;T&gt; pub) throws InterruptedException {
 619         ManualSubscriber&lt;T&gt; sub1 = env.newManualSubscriber(pub);
 620         ManualSubscriber&lt;T&gt; sub2 = env.newManualSubscriber(pub);
 621         ManualSubscriber&lt;T&gt; sub3 = env.newManualSubscriber(pub);
 622 
 623         sub1.request(1);
 624         T x1 = sub1.nextElement(String.format(&quot;Publisher %s did not produce the requested 1 element on 1st subscriber&quot;, pub));
 625         sub2.request(2);
 626         List&lt;T&gt; y1 = sub2.nextElements(2, String.format(&quot;Publisher %s did not produce the requested 2 elements on 2nd subscriber&quot;, pub));
 627         sub1.request(1);
 628         T x2 = sub1.nextElement(String.format(&quot;Publisher %s did not produce the requested 1 element on 1st subscriber&quot;, pub));
 629         sub3.request(3);
 630         List&lt;T&gt; z1 = sub3.nextElements(3, String.format(&quot;Publisher %s did not produce the requested 3 elements on 3rd subscriber&quot;, pub));
 631         sub3.request(1);
 632         T z2 = sub3.nextElement(String.format(&quot;Publisher %s did not produce the requested 1 element on 3rd subscriber&quot;, pub));
 633         sub3.request(1);
 634         T z3 = sub3.nextElement(String.format(&quot;Publisher %s did not produce the requested 1 element on 3rd subscriber&quot;, pub));
 635         sub3.requestEndOfStream(String.format(&quot;Publisher %s did not complete the stream as expected on 3rd subscriber&quot;, pub));
 636         sub2.request(3);
 637         List&lt;T&gt; y2 = sub2.nextElements(3, String.format(&quot;Publisher %s did not produce the requested 3 elements on 2nd subscriber&quot;, pub));
 638         sub2.requestEndOfStream(String.format(&quot;Publisher %s did not complete the stream as expected on 2nd subscriber&quot;, pub));
 639         sub1.request(2);
 640         List&lt;T&gt; x3 = sub1.nextElements(2, String.format(&quot;Publisher %s did not produce the requested 2 elements on 1st subscriber&quot;, pub));
 641         sub1.request(1);
 642         T x4 = sub1.nextElement(String.format(&quot;Publisher %s did not produce the requested 1 element on 1st subscriber&quot;, pub));
 643         sub1.requestEndOfStream(String.format(&quot;Publisher %s did not complete the stream as expected on 1st subscriber&quot;, pub));
 644 
 645         @SuppressWarnings(&quot;unchecked&quot;)
 646         List&lt;T&gt; r = new ArrayList&lt;T&gt;(Arrays.asList(x1, x2));
 647         r.addAll(x3);
 648         r.addAll(Collections.singleton(x4));
 649 
 650         List&lt;T&gt; check1 = new ArrayList&lt;T&gt;(y1);
 651         check1.addAll(y2);
 652 
 653         //noinspection unchecked
 654         List&lt;T&gt; check2 = new ArrayList&lt;T&gt;(z1);
 655         check2.add(z2);
 656         check2.add(z3);
 657 
 658         assertEquals(r, check1, String.format(&quot;Publisher %s did not produce the same element sequence for subscribers 1 and 2&quot;, pub));
 659         assertEquals(r, check2, String.format(&quot;Publisher %s did not produce the same element sequence for subscribers 1 and 3&quot;, pub));
 660       }
 661     });
 662   }
 663 
 664   @Override @Test
 665   public void optional_spec111_multicast_mustProduceTheSameElementsInTheSameSequenceToAllOfItsSubscribersWhenRequestingManyUpfront() throws Throwable {
 666     optionalActivePublisherTest(3, false, new PublisherTestRun&lt;T&gt;() { // This test is skipped if the publisher cannot produce enough elements
 667       @Override
 668       public void run(Publisher&lt;T&gt; pub) throws Throwable {
 669         ManualSubscriber&lt;T&gt; sub1 = env.newManualSubscriber(pub);
 670         ManualSubscriber&lt;T&gt; sub2 = env.newManualSubscriber(pub);
 671         ManualSubscriber&lt;T&gt; sub3 = env.newManualSubscriber(pub);
 672 
 673         List&lt;T&gt; received1 = new ArrayList&lt;T&gt;();
 674         List&lt;T&gt; received2 = new ArrayList&lt;T&gt;();
 675         List&lt;T&gt; received3 = new ArrayList&lt;T&gt;();
 676 
 677         // if the publisher must touch it&#39;s source to notice it&#39;s been drained, the OnComplete won&#39;t come until we ask for more than it actually contains...
 678         // edgy edge case?
 679         sub1.request(4);
 680         sub2.request(4);
 681         sub3.request(4);
 682 
 683         received1.addAll(sub1.nextElements(3));
 684         received2.addAll(sub2.nextElements(3));
 685         received3.addAll(sub3.nextElements(3));
 686 
 687         // NOTE: can&#39;t check completion, the Publisher may not be able to signal it
 688         //       a similar test *with* completion checking is implemented
 689 
 690         assertEquals(received1, received2, String.format(&quot;Expected elements to be signaled in the same sequence to 1st and 2nd subscribers&quot;));
 691         assertEquals(received2, received3, String.format(&quot;Expected elements to be signaled in the same sequence to 2nd and 3rd subscribers&quot;));
 692       }
 693     });
 694   }
 695 
 696   @Override @Test
 697   public void optional_spec111_multicast_mustProduceTheSameElementsInTheSameSequenceToAllOfItsSubscribersWhenRequestingManyUpfrontAndCompleteAsExpected() throws Throwable {
 698     optionalActivePublisherTest(3, true, new PublisherTestRun&lt;T&gt;() { // This test is skipped if the publisher is unbounded (never sends onComplete)
 699       @Override
 700       public void run(Publisher&lt;T&gt; pub) throws Throwable {
 701         ManualSubscriber&lt;T&gt; sub1 = env.newManualSubscriber(pub);
 702         ManualSubscriber&lt;T&gt; sub2 = env.newManualSubscriber(pub);
 703         ManualSubscriber&lt;T&gt; sub3 = env.newManualSubscriber(pub);
 704 
 705         List&lt;T&gt; received1 = new ArrayList&lt;T&gt;();
 706         List&lt;T&gt; received2 = new ArrayList&lt;T&gt;();
 707         List&lt;T&gt; received3 = new ArrayList&lt;T&gt;();
 708 
 709         // if the publisher must touch it&#39;s source to notice it&#39;s been drained, the OnComplete won&#39;t come until we ask for more than it actually contains...
 710         // edgy edge case?
 711         sub1.request(4);
 712         sub2.request(4);
 713         sub3.request(4);
 714 
 715         received1.addAll(sub1.nextElements(3));
 716         received2.addAll(sub2.nextElements(3));
 717         received3.addAll(sub3.nextElements(3));
 718 
 719         sub1.expectCompletion();
 720         sub2.expectCompletion();
 721         sub3.expectCompletion();
 722 
 723         assertEquals(received1, received2, String.format(&quot;Expected elements to be signaled in the same sequence to 1st and 2nd subscribers&quot;));
 724         assertEquals(received2, received3, String.format(&quot;Expected elements to be signaled in the same sequence to 2nd and 3rd subscribers&quot;));
 725       }
 726     });
 727   }
 728 
 729   ///////////////////// SUBSCRIPTION TESTS //////////////////////////////////
 730 
 731   @Override @Test
 732   public void required_spec302_mustAllowSynchronousRequestCallsFromOnNextAndOnSubscribe() throws Throwable {
 733     activePublisherTest(6, false, new PublisherTestRun&lt;T&gt;() {
 734       @Override
 735       public void run(Publisher&lt;T&gt; pub) throws Throwable {
 736         ManualSubscriber&lt;T&gt; sub = new ManualSubscriber&lt;T&gt;(env) {
 737           @Override
 738           public void onSubscribe(Subscription subs) {
 739             this.subscription.completeImmediatly(subs);
 740 
 741             subs.request(1);
 742             subs.request(1);
 743             subs.request(1);
 744           }
 745 
 746           @Override
 747           public void onNext(T element) {
 748             Subscription subs = this.subscription.value();
 749             subs.request(1);
 750           }
 751         };
 752 
 753         env.subscribe(pub, sub);
 754 
 755         env.verifyNoAsyncErrors();
 756       }
 757     });
 758   }
 759 
 760   @Override @Test
 761   public void required_spec303_mustNotAllowUnboundedRecursion() throws Throwable {
 762     final long oneMoreThanBoundedLimit = boundedDepthOfOnNextAndRequestRecursion() + 1;
 763 
 764     activePublisherTest(oneMoreThanBoundedLimit, false, new PublisherTestRun&lt;T&gt;() {
 765       @Override
 766       public void run(Publisher&lt;T&gt; pub) throws Throwable {
 767         final ThreadLocal&lt;Long&gt; stackDepthCounter = new ThreadLocal&lt;Long&gt;() {
 768           @Override
 769           protected Long initialValue() {
 770             return 0L;
 771           }
 772         };
 773 
 774         final Latch runCompleted = new Latch(env);
 775 
 776         final ManualSubscriber&lt;T&gt; sub = new ManualSubscriberWithSubscriptionSupport&lt;T&gt;(env) {
 777           // counts the number of signals received, used to break out from possibly infinite request/onNext loops
 778           long signalsReceived = 0L;
 779 
 780           @Override
 781           public void onNext(T element) {
 782             // NOT calling super.onNext as this test only cares about stack depths, not the actual values of elements
 783             // which also simplifies this test as we do not have to drain the test buffer, which would otherwise be in danger of overflowing
 784 
 785             signalsReceived += 1;
 786             stackDepthCounter.set(stackDepthCounter.get() + 1);
 787             if (env.debugEnabled()) {
 788               env.debug(String.format(&quot;%s(recursion depth: %d)::onNext(%s)&quot;, this, stackDepthCounter.get(), element));
 789             }
 790 
 791             final long callsUntilNow = stackDepthCounter.get();
 792             if (callsUntilNow &gt; boundedDepthOfOnNextAndRequestRecursion()) {
 793               env.flop(String.format(&quot;Got %d onNext calls within thread: %s, yet expected recursive bound was %d&quot;,
 794                                      callsUntilNow, Thread.currentThread(), boundedDepthOfOnNextAndRequestRecursion()));
 795 
 796               // stop the recursive call chain
 797               runCompleted.close();
 798               return;
 799             } else if (signalsReceived &gt;= oneMoreThanBoundedLimit) {
 800               // since max number of signals reached, and recursion depth not exceeded, we judge this as a success and
 801               // stop the recursive call chain
 802               runCompleted.close();
 803               return;
 804             }
 805 
 806             // request more right away, the Publisher must break the recursion
 807             subscription.value().request(1);
 808 
 809             stackDepthCounter.set(stackDepthCounter.get() - 1);
 810           }
 811 
 812           @Override
 813           public void onComplete() {
 814             super.onComplete();
 815             runCompleted.close();
 816           }
 817 
 818           @Override
 819           public void onError(Throwable cause) {
 820             super.onError(cause);
 821             runCompleted.close();
 822           }
 823         };
 824 
 825         try {
 826           env.subscribe(pub, sub);
 827 
 828           sub.request(1); // kick-off the `request -&gt; onNext -&gt; request -&gt; onNext -&gt; ...`
 829 
 830           final String msg = String.format(&quot;Unable to validate call stack depth safety, &quot; +
 831                                                &quot;awaited at-most %s signals (`maxOnNextSignalsInRecursionTest()`) or completion&quot;,
 832                                            oneMoreThanBoundedLimit);
 833           runCompleted.expectClose(env.defaultTimeoutMillis(), msg);
 834           env.verifyNoAsyncErrorsNoDelay();
 835         } finally {
 836           // since the request/onNext recursive calls may keep the publisher running &quot;forever&quot;,
 837           // we MUST cancel it manually before exiting this test case
 838           sub.cancel();
 839         }
 840       }
 841     });
 842   }
 843 
 844   @Override @Test
 845   public void untested_spec304_requestShouldNotPerformHeavyComputations() throws Exception {
 846     notVerified(); // cannot be meaningfully tested, or can it?
 847   }
 848 
 849   @Override @Test
 850   public void untested_spec305_cancelMustNotSynchronouslyPerformHeavyComputation() throws Exception {
 851     notVerified(); // cannot be meaningfully tested, or can it?
 852   }
 853 
 854   @Override @Test
 855   public void required_spec306_afterSubscriptionIsCancelledRequestMustBeNops() throws Throwable {
 856     activePublisherTest(3, false, new PublisherTestRun&lt;T&gt;() {
 857       @Override
 858       public void run(Publisher&lt;T&gt; pub) throws Throwable {
 859 
 860         // override ManualSubscriberWithSubscriptionSupport#cancel because by default a ManualSubscriber will drop the
 861         // subscription once it&#39;s cancelled (as expected).
 862         // In this test however it must keep the cancelled Subscription and keep issuing `request(long)` to it.
 863         ManualSubscriber&lt;T&gt; sub = new ManualSubscriberWithSubscriptionSupport&lt;T&gt;(env) {
 864           @Override
 865           public void cancel() {
 866             if (subscription.isCompleted()) {
 867               subscription.value().cancel();
 868             } else {
 869               env.flop(&quot;Cannot cancel a subscription before having received it&quot;);
 870             }
 871           }
 872         };
 873 
 874         env.subscribe(pub, sub);
 875 
 876         sub.cancel();
 877         sub.request(1);
 878         sub.request(1);
 879         sub.request(1);
 880 
 881         sub.expectNone();
 882         env.verifyNoAsyncErrorsNoDelay();
 883       }
 884     });
 885   }
 886 
 887   @Override @Test
 888   public void required_spec307_afterSubscriptionIsCancelledAdditionalCancelationsMustBeNops() throws Throwable {
 889     activePublisherTest(1, false, new PublisherTestRun&lt;T&gt;() {
 890       @Override
 891       public void run(Publisher&lt;T&gt; pub) throws Throwable {
 892         final ManualSubscriber&lt;T&gt; sub = env.newManualSubscriber(pub);
 893 
 894         // leak the Subscription
 895         final Subscription subs = sub.subscription.value();
 896 
 897         subs.cancel();
 898         subs.cancel();
 899         subs.cancel();
 900 
 901         sub.expectNone();
 902         env.verifyNoAsyncErrorsNoDelay();
 903       }
 904     });
 905   }
 906 
 907   @Override @Test
 908   public void required_spec309_requestZeroMustSignalIllegalArgumentException() throws Throwable {
 909     activePublisherTest(10, false, new PublisherTestRun&lt;T&gt;() {
 910       @Override public void run(Publisher&lt;T&gt; pub) throws Throwable {
 911         final ManualSubscriber&lt;T&gt; sub = env.newManualSubscriber(pub);
 912         sub.request(0);
 913         sub.expectError(IllegalArgumentException.class);
 914       }
 915     });
 916   }
 917 
 918   @Override @Test
 919   public void required_spec309_requestNegativeNumberMustSignalIllegalArgumentException() throws Throwable {
 920     activePublisherTest(10, false, new PublisherTestRun&lt;T&gt;() {
 921       @Override
 922       public void run(Publisher&lt;T&gt; pub) throws Throwable {
 923         final ManualSubscriber&lt;T&gt; sub = env.newManualSubscriber(pub);
 924         final Random r = new Random();
 925         sub.request(-r.nextInt(Integer.MAX_VALUE) - 1);
 926         // we do require implementations to mention the rule number at the very least, or mentioning that the non-negative request is the problem
 927         sub.expectError(IllegalArgumentException.class);
 928       }
 929     });
 930   }
 931 
 932   @Override @Test
 933   public void optional_spec309_requestNegativeNumberMaySignalIllegalArgumentExceptionWithSpecificMessage() throws Throwable {
 934     optionalActivePublisherTest(10, false, new PublisherTestRun&lt;T&gt;() {
 935       @Override
 936       public void run(Publisher&lt;T&gt; pub) throws Throwable {
 937         final ManualSubscriber&lt;T&gt; sub = env.newManualSubscriber(pub);
 938         final Random r = new Random();
 939         sub.request(-r.nextInt(Integer.MAX_VALUE) - 1);
 940         // we do require implementations to mention the rule number at the very least, or mentioning that the non-negative request is the problem
 941         sub.expectErrorWithMessage(IllegalArgumentException.class, Arrays.asList(&quot;3.9&quot;, &quot;non-positive subscription request&quot;, &quot;negative subscription request&quot;));
 942       }
 943     });
 944   }
 945 
 946   @Override @Test
 947   public void required_spec312_cancelMustMakeThePublisherToEventuallyStopSignaling() throws Throwable {
 948     // the publisher is able to signal more elements than the subscriber will be requesting in total
 949     final int publisherElements = 20;
 950 
 951     final int demand1 = 10;
 952     final int demand2 = 5;
 953     final int totalDemand = demand1 + demand2;
 954 
 955     activePublisherTest(publisherElements, false, new PublisherTestRun&lt;T&gt;() {
 956       @Override @SuppressWarnings(&quot;ThrowableResultOfMethodCallIgnored&quot;)
 957       public void run(Publisher&lt;T&gt; pub) throws Throwable {
 958         final ManualSubscriber&lt;T&gt; sub = env.newManualSubscriber(pub);
 959 
 960         sub.request(demand1);
 961         sub.request(demand2);
 962 
 963         /*
 964           NOTE: The order of the nextElement/cancel calls below is very important (!)
 965 
 966           If this ordering was reversed, given an asynchronous publisher,
 967           the following scenario would be *legal* and would break this test:
 968 
 969           &gt; AsyncPublisher receives request(10) - it does not emit data right away, it&#39;s asynchronous
 970           &gt; AsyncPublisher receives request(5) - demand is now 15
 971           ! AsyncPublisher didn&#39;t emit any onNext yet (!)
 972           &gt; AsyncPublisher receives cancel() - handles it right away, by &quot;stopping itself&quot; for example
 973           ! cancel was handled hefore the AsyncPublisher ever got the chance to emit data
 974           ! the subscriber ends up never receiving even one element - the test is stuck (and fails, even on valid Publisher)
 975 
 976           Which is why we must first expect an element, and then cancel, once the producing is &quot;running&quot;.
 977          */
 978         sub.nextElement();
 979         sub.cancel();
 980 
 981         int onNextsSignalled = 1;
 982 
 983         boolean stillBeingSignalled;
 984         do {
 985           // put asyncError if onNext signal received
 986           sub.expectNone();
 987           Throwable error = env.dropAsyncError();
 988 
 989           if (error == null) {
 990             stillBeingSignalled = false;
 991           } else {
 992             onNextsSignalled += 1;
 993             stillBeingSignalled = true;
 994           }
 995 
 996           // if the Publisher tries to emit more elements than was requested (and/or ignores cancellation) this will throw
 997           assertTrue(onNextsSignalled &lt;= totalDemand,
 998                      String.format(&quot;Publisher signalled [%d] elements, which is more than the signalled demand: %d&quot;,
 999                                    onNextsSignalled, totalDemand));
1000 
1001         } while (stillBeingSignalled);
1002       }
1003     });
1004 
1005     env.verifyNoAsyncErrorsNoDelay();
1006   }
1007 
1008   @Override @Test
1009   public void required_spec313_cancelMustMakeThePublisherEventuallyDropAllReferencesToTheSubscriber() throws Throwable {
1010     final ReferenceQueue&lt;ManualSubscriber&lt;T&gt;&gt; queue = new ReferenceQueue&lt;ManualSubscriber&lt;T&gt;&gt;();
1011 
1012     final Function&lt;Publisher&lt;T&gt;, WeakReference&lt;ManualSubscriber&lt;T&gt;&gt;&gt; run = new Function&lt;Publisher&lt;T&gt;, WeakReference&lt;ManualSubscriber&lt;T&gt;&gt;&gt;() {
1013       @Override
1014       public WeakReference&lt;ManualSubscriber&lt;T&gt;&gt; apply(Publisher&lt;T&gt; pub) throws Exception {
1015         final ManualSubscriber&lt;T&gt; sub = env.newManualSubscriber(pub);
1016         final WeakReference&lt;ManualSubscriber&lt;T&gt;&gt; ref = new WeakReference&lt;ManualSubscriber&lt;T&gt;&gt;(sub, queue);
1017 
1018         sub.request(1);
1019         sub.nextElement();
1020         sub.cancel();
1021 
1022         return ref;
1023       }
1024     };
1025 
1026     activePublisherTest(3, false, new PublisherTestRun&lt;T&gt;() {
1027       @Override
1028       public void run(Publisher&lt;T&gt; pub) throws Throwable {
1029         final WeakReference&lt;ManualSubscriber&lt;T&gt;&gt; ref = run.apply(pub);
1030 
1031         // cancel may be run asynchronously so we add a sleep before running the GC
1032         // to &quot;resolve&quot; the race
1033         Thread.sleep(publisherReferenceGCTimeoutMillis);
1034         System.gc();
1035 
1036         if (!ref.equals(queue.remove(100))) {
1037           env.flop(String.format(&quot;Publisher %s did not drop reference to test subscriber after subscription cancellation&quot;, pub));
1038         }
1039 
1040         env.verifyNoAsyncErrorsNoDelay();
1041       }
1042     });
1043   }
1044 
1045   @Override @Test
1046   public void required_spec317_mustSupportAPendingElementCountUpToLongMaxValue() throws Throwable {
1047     final int totalElements = 3;
1048 
1049     activePublisherTest(totalElements, true, new PublisherTestRun&lt;T&gt;() {
1050       @Override
1051       public void run(Publisher&lt;T&gt; pub) throws Throwable {
1052         ManualSubscriber&lt;T&gt; sub = env.newManualSubscriber(pub);
1053         sub.request(Long.MAX_VALUE);
1054 
1055         sub.nextElements(totalElements);
1056         sub.expectCompletion();
1057 
1058         env.verifyNoAsyncErrorsNoDelay();
1059       }
1060     });
1061   }
1062 
1063   @Override @Test
1064   public void required_spec317_mustSupportACumulativePendingElementCountUpToLongMaxValue() throws Throwable {
1065     final int totalElements = 3;
1066 
1067     activePublisherTest(totalElements, true, new PublisherTestRun&lt;T&gt;() {
1068       @Override
1069       public void run(Publisher&lt;T&gt; pub) throws Throwable {
1070         final ManualSubscriber&lt;T&gt; sub = env.newManualSubscriber(pub);
1071         sub.request(Long.MAX_VALUE / 2); // pending = Long.MAX_VALUE / 2
1072         sub.request(Long.MAX_VALUE / 2); // pending = Long.MAX_VALUE - 1
1073         sub.request(1); // pending = Long.MAX_VALUE
1074 
1075         sub.nextElements(totalElements);
1076         sub.expectCompletion();
1077 
1078         try {
1079           env.verifyNoAsyncErrorsNoDelay();
1080         } finally {
1081           sub.cancel();
1082         }
1083 
1084       }
1085     });
1086   }
1087 
1088   @Override @Test
1089   public void required_spec317_mustNotSignalOnErrorWhenPendingAboveLongMaxValue() throws Throwable {
1090     activePublisherTest(Integer.MAX_VALUE, false, new PublisherTestRun&lt;T&gt;() {
1091       @Override public void run(Publisher&lt;T&gt; pub) throws Throwable {
1092         final ManualSubscriberWithSubscriptionSupport&lt;T&gt; sub = new BlackholeSubscriberWithSubscriptionSupport&lt;T&gt;(env) {
1093            // arbitrarily set limit on nuber of request calls signalled, we expect overflow after already 2 calls,
1094            // so 10 is relatively high and safe even if arbitrarily chosen
1095           int callsCounter = 10;
1096 
1097           @Override
1098           public void onNext(T element) {
1099             if (env.debugEnabled()) {
1100               env.debug(String.format(&quot;%s::onNext(%s)&quot;, this, element));
1101             }
1102             if (subscription.isCompleted()) {
1103               if (callsCounter &gt; 0) {
1104                 subscription.value().request(Long.MAX_VALUE - 1);
1105                 callsCounter--;
1106               } else {
1107                   subscription.value().cancel();
1108               }
1109             } else {
1110               env.flop(String.format(&quot;Subscriber::onNext(%s) called before Subscriber::onSubscribe&quot;, element));
1111             }
1112           }
1113         };
1114         env.subscribe(pub, sub, env.defaultTimeoutMillis());
1115 
1116         // eventually triggers `onNext`, which will then trigger up to `callsCounter` times `request(Long.MAX_VALUE - 1)`
1117         // we&#39;re pretty sure to overflow from those
1118         sub.request(1);
1119 
1120         // no onError should be signalled
1121         try {
1122           env.verifyNoAsyncErrors();
1123         } finally {
1124           sub.cancel();
1125         }
1126       }
1127     });
1128   }
1129 
1130   ///////////////////// ADDITIONAL &quot;COROLLARY&quot; TESTS ////////////////////////
1131 
1132   ///////////////////// TEST INFRASTRUCTURE /////////////////////////////////
1133 
1134   public interface PublisherTestRun&lt;T&gt; {
1135     public void run(Publisher&lt;T&gt; pub) throws Throwable;
1136   }
1137 
1138   /**
1139    * Test for feature that SHOULD/MUST be implemented, using a live publisher.
1140    *
1141    * @param elements the number of elements the Publisher under test  must be able to emit to run this test
1142    * @param completionSignalRequired true if an {@code onComplete} signal is required by this test to run.
1143    *                                 If the tested Publisher is unable to signal completion, tests requireing onComplete signals will be skipped.
1144    *                                 To signal if your Publisher is able to signal completion see {@link PublisherVerification#maxElementsFromPublisher()}.
1145    */
1146   public void activePublisherTest(long elements, boolean completionSignalRequired, PublisherTestRun&lt;T&gt; body) throws Throwable {
1147     if (elements &gt; maxElementsFromPublisher()) {
1148       throw new SkipException(String.format(&quot;Unable to run this test, as required elements nr: %d is higher than supported by given producer: %d&quot;, elements, maxElementsFromPublisher()));
1149     } else if (completionSignalRequired &amp;&amp; maxElementsFromPublisher() == Long.MAX_VALUE) {
1150       throw new SkipException(&quot;Unable to run this test, as it requires an onComplete signal, &quot; +
1151                                 &quot;which this Publisher is unable to provide (as signalled by returning Long.MAX_VALUE from `maxElementsFromPublisher()`)&quot;);
1152     } else {
1153       Publisher&lt;T&gt; pub = createPublisher(elements);
1154       body.run(pub);
1155       env.verifyNoAsyncErrorsNoDelay();
1156     }
1157   }
1158 
1159   /**
1160    * Test for feature that MAY be implemented. This test will be marked as SKIPPED if it fails.
1161    *
1162    * @param elements the number of elements the Publisher under test  must be able to emit to run this test
1163    * @param completionSignalRequired true if an {@code onComplete} signal is required by this test to run.
1164    *                                 If the tested Publisher is unable to signal completion, tests requireing onComplete signals will be skipped.
1165    *                                 To signal if your Publisher is able to signal completion see {@link PublisherVerification#maxElementsFromPublisher()}.
1166    */
1167   public void optionalActivePublisherTest(long elements, boolean completionSignalRequired, PublisherTestRun&lt;T&gt; body) throws Throwable {
1168     if (elements &gt; maxElementsFromPublisher()) {
1169       throw new SkipException(String.format(&quot;Unable to run this test, as required elements nr: %d is higher than supported by given producer: %d&quot;, elements, maxElementsFromPublisher()));
1170     } else if (completionSignalRequired &amp;&amp; maxElementsFromPublisher() == Long.MAX_VALUE) {
1171       throw new SkipException(&quot;Unable to run this test, as it requires an onComplete signal, &quot; +
1172                                 &quot;which this Publisher is unable to provide (as signalled by returning Long.MAX_VALUE from `maxElementsFromPublisher()`)&quot;);
1173     } else {
1174 
1175       final Publisher&lt;T&gt; pub = createPublisher(elements);
1176       final String skipMessage = &quot;Skipped because tested publisher does NOT implement this OPTIONAL requirement.&quot;;
1177 
1178       try {
1179         potentiallyPendingTest(pub, body);
1180       } catch (Exception ex) {
1181         notVerified(skipMessage);
1182       } catch (AssertionError ex) {
1183         notVerified(skipMessage + &quot; Reason for skipping was: &quot; + ex.getMessage());
1184       }
1185     }
1186   }
1187 
1188   public static final String SKIPPING_NO_ERROR_PUBLISHER_AVAILABLE =
1189     &quot;Skipping because no error state Publisher provided, and the test requires it. &quot; +
1190           &quot;Please implement PublisherVerification#createFailedPublisher to run this test.&quot;;
1191 
1192   public static final String SKIPPING_OPTIONAL_TEST_FAILED =
1193     &quot;Skipping, because provided Publisher does not pass this *additional* verification.&quot;;
1194   /**
1195    * Additional test for Publisher in error state
1196    */
1197   public void whenHasErrorPublisherTest(PublisherTestRun&lt;T&gt; body) throws Throwable {
1198     potentiallyPendingTest(createFailedPublisher(), body, SKIPPING_NO_ERROR_PUBLISHER_AVAILABLE);
1199   }
1200 
1201   public void potentiallyPendingTest(Publisher&lt;T&gt; pub, PublisherTestRun&lt;T&gt; body) throws Throwable {
1202     potentiallyPendingTest(pub, body, SKIPPING_OPTIONAL_TEST_FAILED);
1203   }
1204 
1205   public void potentiallyPendingTest(Publisher&lt;T&gt; pub, PublisherTestRun&lt;T&gt; body, String message) throws Throwable {
1206     if (pub != null) {
1207       body.run(pub);
1208     } else {
1209       throw new SkipException(message);
1210     }
1211   }
1212 
1213   /**
1214    * Executes a given test body {@code n} times.
1215    * All the test runs must pass in order for the stochastic test to pass.
1216    */
1217   public void stochasticTest(int n, Function&lt;Integer, Void&gt; body) throws Throwable {
1218     if (skipStochasticTests()) {
1219       notVerified(&quot;Skipping @Stochastic test because `skipStochasticTests()` returned `true`!&quot;);
1220     }
1221 
1222     for (int i = 0; i &lt; n; i++) {
1223       body.apply(i);
1224     }
1225   }
1226 
1227   public void notVerified() {
1228     throw new SkipException(&quot;Not verified by this TCK.&quot;);
1229   }
1230 
1231   /**
1232    * Return this value from {@link PublisherVerification#maxElementsFromPublisher()} to mark that the given {@link org.reactivestreams.Publisher},
1233    * is not able to signal completion. For example it is strictly a time-bound or unbounded source of data.
1234    *
1235    * &lt;b&gt;Returning this value from {@link PublisherVerification#maxElementsFromPublisher()} will result in skipping all TCK tests which require onComplete signals!&lt;/b&gt;
1236    */
1237   public long publisherUnableToSignalOnComplete() {
1238     return Long.MAX_VALUE;
1239   }
1240 
1241   public void notVerified(String message) {
1242     throw new SkipException(message);
1243   }
1244 
1245 }
    </pre>
  </body>
</html>
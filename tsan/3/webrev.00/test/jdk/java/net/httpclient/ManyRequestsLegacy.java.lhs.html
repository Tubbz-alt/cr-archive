<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames test/jdk/java/net/httpclient/ManyRequestsLegacy.java</title>
    <link rel="stylesheet" href="../../../../../style.css" />
    <script type="text/javascript" src="../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (c) 2015, 2018, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 /*
 25  * @test
 26  * @modules java.net.http
 27  *          java.logging
 28  *          jdk.httpserver
 29  * @library /test/lib
 30  * @build jdk.test.lib.net.SimpleSSLContext
 31  * @compile ../../../com/sun/net/httpserver/LogFilter.java
 32  * @compile ../../../com/sun/net/httpserver/EchoHandler.java
 33  * @compile ../../../com/sun/net/httpserver/FileServerHandler.java
 34  * @run main/othervm/timeout=40 ManyRequestsLegacy
 35  * @run main/othervm/timeout=40 -Dtest.insertDelay=true ManyRequestsLegacy
 36  * @run main/othervm/timeout=40 -Dtest.chunkSize=64 ManyRequestsLegacy
 37  * @run main/othervm/timeout=40 -Dtest.insertDelay=true
 38  *                              -Dtest.chunkSize=64 ManyRequestsLegacy
 39  * @summary Send a large number of requests asynchronously using the legacy
 40  *          URL.openConnection(), to help sanitize results of the test
 41  *          ManyRequest.java.
 42  */
 43 
 44 import javax.net.ssl.HttpsURLConnection;
 45 import javax.net.ssl.HostnameVerifier;
 46 import com.sun.net.httpserver.HttpsConfigurator;
 47 import com.sun.net.httpserver.HttpsParameters;
 48 import com.sun.net.httpserver.HttpsServer;
 49 import com.sun.net.httpserver.HttpExchange;
 50 import java.io.IOException;
 51 import java.io.InputStream;
 52 import java.io.OutputStream;
 53 import java.net.HttpURLConnection;
 54 import java.net.InetAddress;
 55 import java.net.URI;
 56 import java.net.URLConnection;
 57 import java.util.Optional;
 58 import java.util.concurrent.CompletableFuture;
 59 import java.util.stream.Collectors;
 60 import javax.net.ssl.SSLContext;
 61 import javax.net.ssl.SSLSession;
 62 import java.net.http.HttpClient;
 63 import java.net.http.HttpClient.Version;
 64 import java.net.http.HttpHeaders;
 65 import java.net.http.HttpRequest;
 66 import java.net.http.HttpRequest.BodyPublishers;
 67 import java.net.http.HttpResponse;
 68 import java.net.InetSocketAddress;
 69 import java.util.Arrays;
 70 import java.util.Formatter;
 71 import java.util.HashMap;
 72 import java.util.LinkedList;
 73 import java.util.Random;
 74 import java.util.logging.Logger;
 75 import java.util.logging.Level;
 76 import jdk.test.lib.net.SimpleSSLContext;
<a name="1" id="anc1"></a>
 77 
 78 public class ManyRequestsLegacy {
 79 
 80     volatile static int counter = 0;
 81 
 82     public static void main(String[] args) throws Exception {
 83         Logger logger = Logger.getLogger(&quot;com.sun.net.httpserver&quot;);
 84         logger.setLevel(Level.ALL);
 85         logger.info(&quot;TEST&quot;);
 86         System.out.println(&quot;Sending &quot; + REQUESTS
 87                          + &quot; requests; delay=&quot; + INSERT_DELAY
 88                          + &quot;, chunks=&quot; + CHUNK_SIZE
 89                          + &quot;, XFixed=&quot; + XFIXED);
 90         SSLContext ctx = new SimpleSSLContext().get();
 91         SSLContext.setDefault(ctx);
 92         HttpsURLConnection.setDefaultHostnameVerifier(new HostnameVerifier() {
 93                 public boolean verify(String hostname, SSLSession session) {
 94                     return true;
 95                 }
 96             });
 97         InetSocketAddress addr = new InetSocketAddress(InetAddress.getLoopbackAddress(), 0);
 98         HttpsServer server = HttpsServer.create(addr, 0);
 99         server.setHttpsConfigurator(new Configurator(ctx));
100 
101         LegacyHttpClient client = new LegacyHttpClient();
102 
103         try {
104             test(server, client);
105             System.out.println(&quot;OK&quot;);
106         } finally {
107             server.stop(0);
108         }
109     }
110 
111     //static final int REQUESTS = 1000;
112     static final int REQUESTS = 20;
113     static final boolean INSERT_DELAY = Boolean.getBoolean(&quot;test.insertDelay&quot;);
114     static final int CHUNK_SIZE = Math.max(0,
115            Integer.parseInt(System.getProperty(&quot;test.chunkSize&quot;, &quot;0&quot;)));
116     static final boolean XFIXED = Boolean.getBoolean(&quot;test.XFixed&quot;);
117 
118     static class LegacyHttpClient {
119         static final class LegacyHttpResponse implements HttpResponse&lt;byte[]&gt; {
120             final HttpRequest request;
121             final byte[] response;
122             final int statusCode;
123             public LegacyHttpResponse(HttpRequest request, int statusCode, byte[] response) {
124                 this.request = request;
125                 this.statusCode = statusCode;
126                 this.response = response;
127             }
128             private &lt;T&gt; T error() {
129                 throw new UnsupportedOperationException(&quot;Not supported yet.&quot;);
130             }
131             @Override
132             public int statusCode() { return statusCode;}
133             @Override
134             public HttpRequest request() {return request;}
135             @Override
136             public Optional&lt;HttpResponse&lt;byte[]&gt;&gt; previousResponse() {return Optional.empty();}
137             @Override
138             public HttpHeaders headers() { return error(); }
139             @Override
140             public byte[] body() {return response;}
141             @Override
142             public Optional&lt;SSLSession&gt; sslSession() {
143                 return Optional.empty(); // for now
144             }
145             @Override
146             public URI uri() { return request.uri();}
147             @Override
148             public HttpClient.Version version() { return Version.HTTP_1_1;}
149         }
150 
151         private void debugCompleted(String tag, long startNanos, HttpRequest req) {
152             System.err.println(tag + &quot; elapsed &quot;
153                     + (System.nanoTime() - startNanos)/1000_000L
154                     + &quot; millis for &quot; + req.method()
155                     + &quot; to &quot; + req.uri());
156         }
157 
158         CompletableFuture&lt;? extends HttpResponse&lt;byte[]&gt;&gt; sendAsync(HttpRequest r, byte[] buf) {
159             long start = System.nanoTime();
160             try {
161                 CompletableFuture&lt;LegacyHttpResponse&gt; cf = new CompletableFuture&lt;&gt;();
<a name="2" id="anc2"></a><span class="line-modified">162                 URLConnection urlc = r.uri().toURL().openConnection();</span>
163                 HttpURLConnection httpc = (HttpURLConnection)urlc;
164                 httpc.setRequestMethod(r.method());
165                 for (String s : r.headers().map().keySet()) {
166                     httpc.setRequestProperty(s, r.headers().allValues(s)
167                         .stream().collect(Collectors.joining(&quot;,&quot;)));
168                 }
169                 httpc.setDoInput(true);
170                 if (buf != null) httpc.setDoOutput(true);
171                 Thread t = new Thread(() -&gt; {
172                     try {
173                         if (buf != null) {
174                             try (OutputStream os = httpc.getOutputStream()) {
175                                 os.write(buf);
176                                 os.flush();
177                             }
178                         }
179                         LegacyHttpResponse response = new LegacyHttpResponse(r,
180                                 httpc.getResponseCode(),httpc.getInputStream().readAllBytes());
181                         cf.complete(response);
182                     } catch(Throwable x) {
183                         cf.completeExceptionally(x);
184                     }
185                 });
186                 t.start();
187                 return cf.whenComplete((b,x) -&gt; debugCompleted(&quot;ClientImpl (async)&quot;, start, r));
188             } catch(Throwable t) {
189                 debugCompleted(&quot;ClientImpl (async)&quot;, start, r);
190                 return CompletableFuture.failedFuture(t);
191             }
192         }
193     }
194 
195     static class TestEchoHandler extends EchoHandler {
196         final Random rand = new Random();
197         @Override
198         public void handle(HttpExchange e) throws IOException {
199             System.out.println(&quot;Server: received &quot; + e.getRequestURI());
200             super.handle(e);
201         }
202         @Override
203         protected void close(HttpExchange t, OutputStream os) throws IOException {
204             if (INSERT_DELAY) {
205                 try { Thread.sleep(rand.nextInt(200)); }
206                 catch (InterruptedException e) {}
207             }
208             System.out.println(&quot;Server: close outbound: &quot; + t.getRequestURI());
209             os.close();
210         }
211         @Override
212         protected void close(HttpExchange t, InputStream is) throws IOException {
213             if (INSERT_DELAY) {
214                 try { Thread.sleep(rand.nextInt(200)); }
215                 catch (InterruptedException e) {}
216             }
217             System.out.println(&quot;Server: close inbound: &quot; + t.getRequestURI());
218             is.close();
219         }
220     }
221 
222     static void test(HttpsServer server, LegacyHttpClient client) throws Exception {
223         int port = server.getAddress().getPort();
224         URI baseURI = new URI(&quot;https://localhost:&quot; + port + &quot;/foo/x&quot;);
225         server.createContext(&quot;/foo&quot;, new TestEchoHandler());
226         server.start();
227 
228         RequestLimiter limiter = new RequestLimiter(40);
229         Random rand = new Random();
230         CompletableFuture&lt;?&gt;[] results = new CompletableFuture&lt;?&gt;[REQUESTS];
231         HashMap&lt;HttpRequest,byte[]&gt; bodies = new HashMap&lt;&gt;();
232 
233         for (int i=0; i&lt;REQUESTS; i++) {
234             byte[] buf = new byte[(i+1)*CHUNK_SIZE+i+1];  // different size bodies
235             rand.nextBytes(buf);
236             URI uri = new URI(baseURI.toString() + String.valueOf(i+1));
237             HttpRequest r = HttpRequest.newBuilder(uri)
238                                        .header(&quot;XFixed&quot;, &quot;true&quot;)
239                                        .POST(BodyPublishers.ofByteArray(buf))
240                                        .build();
241             bodies.put(r, buf);
242 
243             results[i] =
244                 limiter.whenOkToSend()
245                        .thenCompose((v) -&gt; {
246                            System.out.println(&quot;Client: sendAsync: &quot; + r.uri());
247                            return client.sendAsync(r, buf);
248                        })
249                        .thenCompose((resp) -&gt; {
250                            limiter.requestComplete();
251                            if (resp.statusCode() != 200) {
252                                String s = &quot;Expected 200, got: &quot; + resp.statusCode();
253                                System.out.println(s + &quot; from &quot;
254                                                   + resp.request().uri().getPath());
255                                return completedWithIOException(s);
256                            } else {
257                                counter++;
258                                System.out.println(&quot;Result (&quot; + counter + &quot;) from &quot;
259                                                    + resp.request().uri().getPath());
260                            }
261                            return CompletableFuture.completedStage(resp.body())
262                                       .thenApply((b) -&gt; new Pair&lt;&gt;(resp, b));
263                        })
264                       .thenAccept((pair) -&gt; {
265                           HttpRequest request = pair.t.request();
266                           byte[] requestBody = bodies.get(request);
267                           check(Arrays.equals(requestBody, pair.u),
268                                 &quot;bodies not equal:[&quot; + bytesToHexString(requestBody)
269                                 + &quot;] [&quot; + bytesToHexString(pair.u) + &quot;]&quot;);
270 
271                       });
272         }
273 
274         // wait for them all to complete and throw exception in case of error
275         CompletableFuture.allOf(results).join();
276     }
277 
278     static &lt;T&gt; CompletableFuture&lt;T&gt; completedWithIOException(String message) {
279         return CompletableFuture.failedFuture(new IOException(message));
280     }
281 
282     static String bytesToHexString(byte[] bytes) {
283         if (bytes == null)
284             return &quot;null&quot;;
285 
286         StringBuilder sb = new StringBuilder(bytes.length * 2);
287 
288         Formatter formatter = new Formatter(sb);
289         for (byte b : bytes) {
290             formatter.format(&quot;%02x&quot;, b);
291         }
292 
293         return sb.toString();
294     }
295 
296     static final class Pair&lt;T,U&gt; {
297         Pair(T t, U u) {
298             this.t = t; this.u = u;
299         }
300         T t;
301         U u;
302     }
303 
304     /**
305      * A simple limiter for controlling the number of requests to be run in
306      * parallel whenOkToSend() is called which returns a CF&lt;Void&gt; that allows
307      * each individual request to proceed, or block temporarily (blocking occurs
308      * on the waiters list here. As each request actually completes
309      * requestComplete() is called to notify this object, and allow some
310      * requests to continue.
311      */
312     static class RequestLimiter {
313 
314         static final CompletableFuture&lt;Void&gt; COMPLETED_FUTURE =
315                 CompletableFuture.completedFuture(null);
316 
317         final int maxnumber;
318         final LinkedList&lt;CompletableFuture&lt;Void&gt;&gt; waiters;
319         int number;
320         boolean blocked;
321 
322         RequestLimiter(int maximum) {
323             waiters = new LinkedList&lt;&gt;();
324             maxnumber = maximum;
325         }
326 
327         synchronized void requestComplete() {
328             number--;
329             // don&#39;t unblock until number of requests has halved.
330             if ((blocked &amp;&amp; number &lt;= maxnumber / 2) ||
331                         (!blocked &amp;&amp; waiters.size() &gt; 0)) {
332                 int toRelease = Math.min(maxnumber - number, waiters.size());
333                 for (int i=0; i&lt;toRelease; i++) {
334                     CompletableFuture&lt;Void&gt; f = waiters.remove();
335                     number ++;
336                     f.complete(null);
337                 }
338                 blocked = number &gt;= maxnumber;
339             }
340         }
341 
342         synchronized CompletableFuture&lt;Void&gt; whenOkToSend() {
343             if (blocked || number + 1 &gt;= maxnumber) {
344                 blocked = true;
345                 CompletableFuture&lt;Void&gt; r = new CompletableFuture&lt;&gt;();
346                 waiters.add(r);
347                 return r;
348             } else {
349                 number++;
350                 return COMPLETED_FUTURE;
351             }
352         }
353     }
354 
355     static void check(boolean cond, Object... msg) {
356         if (cond)
357             return;
358         StringBuilder sb = new StringBuilder();
359         for (Object o : msg)
360             sb.append(o);
361         throw new RuntimeException(sb.toString());
362     }
363 
364     static class Configurator extends HttpsConfigurator {
365         public Configurator(SSLContext ctx) {
366             super(ctx);
367         }
368 
369         public void configure(HttpsParameters params) {
370             params.setSSLParameters(getSSLContext().getSupportedSSLParameters());
371         }
372     }
373 }
<a name="3" id="anc3"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="3" type="hidden" />
</body>
</html>
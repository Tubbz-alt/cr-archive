<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New test/jdk/java/net/httpclient/HttpsTunnelTest.java</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2018, 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 import com.sun.net.httpserver.HttpsConfigurator;
 25 import com.sun.net.httpserver.HttpsServer;
 26 import jdk.test.lib.net.SimpleSSLContext;
 27 import javax.net.ssl.SSLContext;
 28 import java.net.InetAddress;
 29 import java.net.InetSocketAddress;
 30 import java.net.ProxySelector;
 31 import java.net.URI;
 32 import java.net.http.HttpClient;
 33 import java.net.http.HttpClient.Version;
 34 import java.net.http.HttpRequest;
 35 import java.net.http.HttpResponse;
 36 import java.net.http.HttpResponse.BodyHandlers;
 37 import java.util.Arrays;
 38 import java.util.List;
 39 import java.util.stream.Collectors;
 40 import java.util.stream.Stream;
 41 import static java.lang.String.format;
 42 import static java.lang.System.out;
 43 
 44 /**
 45  * @test
 46  * @summary This test verifies that if an h2 connection going through a
 47  *          proxy P is downgraded to HTTP/1.1, then a new h2 request
 48  *          going to a different host through the same proxy will not
 49  *          be preemptively downgraded. That, is the stack should attempt
 50  *          a new h2 connection to the new host. It also verifies that
 51  *          the stack sends the appropriate &quot;host&quot; header to the proxy.
 52  * @bug 8196967 8222527
 53  * @library /test/lib http2/server
 54  * @build jdk.test.lib.net.SimpleSSLContext HttpServerAdapters DigestEchoServer HttpsTunnelTest
 55  * @modules java.net.http/jdk.internal.net.http.common
 56  *          java.net.http/jdk.internal.net.http.frame
 57  *          java.net.http/jdk.internal.net.http.hpack
 58  *          java.logging
 59  *          java.base/sun.net.www.http
 60  *          java.base/sun.net.www
 61  *          java.base/sun.net
 62  * @run main/othervm -Dtest.requiresHost=true
 63  *                   -Djdk.httpclient.HttpClient.log=headers
 64  *                   -Djdk.internal.httpclient.debug=true HttpsTunnelTest
 65  * @run main/othervm -Dtest.requiresHost=true
 66  *                   -Djdk.httpclient.allowRestrictedHeaders=host
 67  *                   -Djdk.httpclient.HttpClient.log=headers
 68  *                   -Djdk.internal.httpclient.debug=true HttpsTunnelTest
 69  *
 70  */
 71 
 72 public class HttpsTunnelTest implements HttpServerAdapters {
 73 
 74     static final String data[] = {
 75         &quot;Lorem ipsum&quot;,
 76         &quot;dolor sit amet&quot;,
 77         &quot;consectetur adipiscing elit, sed do eiusmod tempor&quot;,
 78         &quot;quis nostrud exercitation ullamco&quot;,
 79         &quot;laboris nisi&quot;,
 80         &quot;ut&quot;,
 81         &quot;aliquip ex ea commodo consequat.&quot; +
 82         &quot;Duis aute irure dolor in reprehenderit in voluptate velit esse&quot; +
 83         &quot;cillum dolore eu fugiat nulla pariatur.&quot;,
 84         &quot;Excepteur sint occaecat cupidatat non proident.&quot;
 85     };
 86 
 87     static final SSLContext context;
 88     static {
 89         try {
 90             context = new SimpleSSLContext().get();
 91             SSLContext.setDefault(context);
 92         } catch (Exception x) {
 93             throw new ExceptionInInitializerError(x);
 94         }
 95     }
 96 
 97     HttpsTunnelTest() {
 98     }
 99 
100     public HttpClient newHttpClient(ProxySelector ps) {
101         HttpClient.Builder builder = HttpClient
102                 .newBuilder()
103                 .sslContext(context)
104                 .proxy(ps);
105         return builder.build();
106     }
107 
108     public static void main(String[] args) throws Exception {
109         InetSocketAddress sa = new InetSocketAddress(InetAddress.getLoopbackAddress(), 0);
110         HttpsServer server1 = HttpsServer.create(sa, 0);
111         server1.setHttpsConfigurator(new HttpsConfigurator(context));
112         HttpTestServer http1Server =
113                 HttpTestServer.of(server1);
114         http1Server.addHandler(new HttpTestEchoHandler(), &quot;/&quot;);
115         http1Server.start();
116         HttpTestServer http2Server = HttpTestServer.of(
117                 new Http2TestServer(&quot;localhost&quot;, true, 0));
118         http2Server.addHandler(new HttpTestEchoHandler(), &quot;/&quot;);
119         http2Server.start();
120 
121         DigestEchoServer.TunnelingProxy proxy = DigestEchoServer.createHttpsProxyTunnel(
122                 DigestEchoServer.HttpAuthSchemeType.NONE);
123 
124         try {
125             URI uri1 = new URI(&quot;https://&quot; + http1Server.serverAuthority() + &quot;/foo/https1&quot;);
126             URI uri2 = new URI(&quot;https://&quot; + http2Server.serverAuthority() + &quot;/foo/https2&quot;);
127 
128             boolean provideCustomHost = &quot;host&quot;.equalsIgnoreCase(
129                     System.getProperty(&quot;jdk.httpclient.allowRestrictedHeaders&quot;,&quot;&quot;));
130 
131             String customHttp1Host = null, customHttp2Host = null;
132             if (provideCustomHost) {
133                 customHttp1Host = makeCustomHostString(http1Server, uri1);
134                 out.println(&quot;HTTP/1.1: &lt;&quot; + uri1 + &quot;&gt; [custom host: &quot; + customHttp1Host + &quot;]&quot;);
135                 customHttp2Host = makeCustomHostString(http2Server, uri2);
136                 out.println(&quot;HTTP/2:   &lt;&quot; + uri2 + &quot;&gt; [custom host: &quot; + customHttp2Host + &quot;]&quot;);
137             }
138 
139             ProxySelector ps = ProxySelector.of(proxy.getProxyAddress());
140                     //HttpClient.Builder.NO_PROXY;
141             HttpsTunnelTest test = new HttpsTunnelTest();
142             HttpClient client = test.newHttpClient(ps);
143             out.println(&quot;Proxy is: &quot; + ps.select(uri2));
144 
145             List&lt;String&gt; lines = List.of(Arrays.copyOfRange(data, 0, data.length));
146             assert lines.size() == data.length;
147             String body = lines.stream().collect(Collectors.joining(&quot;\r\n&quot;));
148             HttpRequest.BodyPublisher reqBody = HttpRequest.BodyPublishers.ofString(body);
149             HttpRequest.Builder req1Builder = HttpRequest
150                     .newBuilder(uri1)
151                     .version(Version.HTTP_2)
152                     .POST(reqBody);
153             if (provideCustomHost) req1Builder.header(&quot;host&quot;, customHttp1Host);
154             HttpRequest req1 = req1Builder.build();
155             out.println(&quot;\nPosting to HTTP/1.1 server at: &quot; + req1);
156             HttpResponse&lt;Stream&lt;String&gt;&gt; response = client.send(req1, BodyHandlers.ofLines());
157             out.println(&quot;Checking response...&quot;);
158             if (response.statusCode() != 200) {
159                 throw new RuntimeException(&quot;Unexpected status code: &quot; + response);
160             }
161             if (response.version() != Version.HTTP_1_1) {
162                 throw new RuntimeException(&quot;Unexpected protocol version: &quot;
163                         + response.version());
164             }
165             List&lt;String&gt; respLines = response.body().collect(Collectors.toList());
166             if (!lines.equals(respLines)) {
167                 throw new RuntimeException(&quot;Unexpected response 1: &quot; + respLines);
168             }
169 
170             HttpRequest.BodyPublisher reqBody2 = HttpRequest.BodyPublishers.ofString(body);
171             HttpRequest.Builder req2Builder = HttpRequest
172                     .newBuilder(uri2)
173                     .version(Version.HTTP_2)
174                     .POST(reqBody2);
175             if (provideCustomHost) req2Builder.header(&quot;host&quot;, customHttp2Host);
176             HttpRequest req2 = req2Builder.build();
177             out.println(&quot;\nPosting to HTTP/2 server at: &quot; + req2);
178             response = client.send(req2, BodyHandlers.ofLines());
179             out.println(&quot;Checking response...&quot;);
180             if (response.statusCode() != 200) {
181                 throw new RuntimeException(&quot;Unexpected status code: &quot; + response);
182             }
183             if (response.version() != Version.HTTP_2) {
184                 throw new RuntimeException(&quot;Unexpected protocol version: &quot;
185                         + response.version());
186             }
187             respLines = response.body().collect(Collectors.toList());
188             if (!lines.equals(respLines)) {
189                 throw new RuntimeException(&quot;Unexpected response 2: &quot; + respLines);
190             }
191         } catch(Throwable t) {
192             out.println(&quot;Unexpected exception: exiting: &quot; + t);
193             t.printStackTrace();
194             throw t;
195         } finally {
196             proxy.stop();
197             http1Server.stop();
198             http2Server.stop();
199         }
200     }
201 
202     /**
203      * Builds a custom host string that is different to what is in the URI
204      * authority, that is textually different than what the stack would
205      * send. For CONNECT we should ignore any custom host settings.
206      * The tunnelling proxy will fail with badRequest 400 if it receives
207      * the custom host instead of the expected URI authority string.
208      * @param  server The target server.
209      * @param  uri    The URI to the target server
210      * @return a host value for the custom host header.
211      */
212     static final String makeCustomHostString(HttpTestServer server, URI uri) {
213         String customHttpHost;
214         if (server.serverAuthority().contains(&quot;localhost&quot;)) {
215             customHttpHost = InetAddress.getLoopbackAddress().getHostAddress();
216         } else {
217             customHttpHost = InetAddress.getLoopbackAddress().getHostName();
218         }
219         if (customHttpHost.contains(&quot;:&quot;)) customHttpHost = &quot;[&quot; + customHttpHost + &quot;]&quot;;
220         if (uri.getPort() != -1) customHttpHost = customHttpHost + &quot;:&quot; + uri.getPort();
221         return customHttpHost;
222     }
223 
224 }
    </pre>
  </body>
</html>
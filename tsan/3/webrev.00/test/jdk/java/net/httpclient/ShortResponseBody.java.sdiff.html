<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff test/jdk/java/net/httpclient/ShortResponseBody.java</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
<body>
<center><a href="ShortRequestBody.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="SmokeTest.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>test/jdk/java/net/httpclient/ShortResponseBody.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2018, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
</pre>
<hr />
<pre>
 33  *       ShortResponseBody
 34  */
 35 
 36 import java.io.IOException;
 37 import java.io.InputStream;
 38 import java.io.OutputStream;
 39 import java.io.UncheckedIOException;
 40 import java.net.InetAddress;
 41 import java.net.InetSocketAddress;
 42 import java.net.ServerSocket;
 43 import java.net.Socket;
 44 import java.net.URI;
 45 import java.net.http.HttpClient;
 46 import java.net.http.HttpRequest;
 47 import java.net.http.HttpRequest.BodyPublishers;
 48 import java.net.http.HttpResponse;
 49 import java.util.ArrayList;
 50 import java.util.Arrays;
 51 import java.util.List;
 52 import java.util.concurrent.ExecutionException;
<span class="line-removed"> 53 import java.util.concurrent.Executor;</span>
 54 import java.util.concurrent.ExecutorService;
 55 import java.util.concurrent.Executors;
 56 import java.util.concurrent.ThreadFactory;
 57 import java.util.concurrent.atomic.AtomicLong;
 58 import java.util.stream.Stream;
 59 import jdk.test.lib.net.SimpleSSLContext;


 60 import org.testng.annotations.AfterTest;
 61 import org.testng.annotations.BeforeTest;
 62 import org.testng.annotations.DataProvider;
 63 import org.testng.annotations.Test;
 64 import javax.net.ssl.SSLContext;
 65 import javax.net.ssl.SSLHandshakeException;
 66 import javax.net.ssl.SSLServerSocketFactory;
 67 import javax.net.ssl.SSLParameters;
 68 import javax.net.ssl.SSLSocket;
 69 import static java.lang.System.out;
 70 import static java.net.http.HttpClient.Builder.NO_PROXY;
 71 import static java.net.http.HttpResponse.BodyHandlers.ofString;
 72 import static java.nio.charset.StandardCharsets.US_ASCII;
 73 import static java.util.stream.Collectors.toList;
 74 import static org.testng.Assert.assertTrue;
 75 import static org.testng.Assert.assertEquals;
 76 import static org.testng.Assert.fail;
 77 
 78 public class ShortResponseBody {
 79 
</pre>
<hr />
<pre>
 89     String httpsURIVarLen;
 90     String httpURIFixLen;
 91 
 92     SSLContext sslContext;
 93     SSLParameters sslParameters;
 94 
 95     static final String EXPECTED_RESPONSE_BODY =
 96             &quot;&lt;html&gt;&lt;body&gt;&lt;h1&gt;Heading&lt;/h1&gt;&lt;p&gt;Some Text&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;&quot;;
 97 
 98     final static AtomicLong ids = new AtomicLong();
 99     final ThreadFactory factory = new ThreadFactory() {
100         @Override
101         public Thread newThread(Runnable r) {
102             Thread thread = new Thread(r,  &quot;HttpClient-Worker-&quot; + ids.incrementAndGet());
103             thread.setDaemon(true);
104             return thread;
105         }
106     };
107     final ExecutorService service = Executors.newCachedThreadPool(factory);
108 







109     @DataProvider(name = &quot;sanity&quot;)
110     public Object[][] sanity() {
111         return new Object[][]{
112             { httpURIVarLen  + &quot;?length=all&quot; },
113             { httpsURIVarLen + &quot;?length=all&quot; },
114             { httpURIFixLen  + &quot;?length=all&quot; },
115         };
116     }
117 
118     @Test(dataProvider = &quot;sanity&quot;)
119     void sanity(String url) throws Exception {
120         HttpClient client = newHttpClient();
121         HttpRequest request = HttpRequest.newBuilder(URI.create(url)).build();
122         HttpResponse&lt;String&gt; response = client.send(request, ofString());
123         String body = response.body();
124         assertEquals(body, EXPECTED_RESPONSE_BODY);
125         client.sendAsync(request, ofString())
126                 .thenApply(resp -&gt; resp.body())
127                 .thenAccept(b -&gt; assertEquals(b, EXPECTED_RESPONSE_BODY))
128                 .join();
129     }
130 
131     @DataProvider(name = &quot;uris&quot;)
<span class="line-modified">132     public Object[][] variants() {</span>
133         String[][] cases = new String[][] {
134             // The length query string is the total number of bytes in the reply,
135             // including headers, before the server closes the connection. The
136             // second arg is a partial-expected-detail message in the exception.
137             { httpURIVarLen + &quot;?length=0&quot;,   &quot;no bytes&quot;     }, // EOF without receiving anything
138             { httpURIVarLen + &quot;?length=1&quot;,   &quot;status line&quot;  }, // EOF during status-line
139             { httpURIVarLen + &quot;?length=2&quot;,   &quot;status line&quot;  },
140             { httpURIVarLen + &quot;?length=10&quot;,  &quot;status line&quot;  },
141             { httpURIVarLen + &quot;?length=19&quot;,  &quot;header&quot;       }, // EOF during Content-Type header
142             { httpURIVarLen + &quot;?length=30&quot;,  &quot;header&quot;       },
143             { httpURIVarLen + &quot;?length=45&quot;,  &quot;header&quot;       },
144             { httpURIVarLen + &quot;?length=48&quot;,  &quot;header&quot;       },
145             { httpURIVarLen + &quot;?length=51&quot;,  &quot;header&quot;       },
146             { httpURIVarLen + &quot;?length=98&quot;,  &quot;header&quot;       }, // EOF during Connection header
147             { httpURIVarLen + &quot;?length=100&quot;, &quot;header&quot;       },
148             { httpURIVarLen + &quot;?length=101&quot;, &quot;header&quot;       },
149             { httpURIVarLen + &quot;?length=104&quot;, &quot;header&quot;       },
150             { httpURIVarLen + &quot;?length=106&quot;, &quot;chunked transfer encoding&quot; }, // EOF during chunk header ( length )
151             { httpURIVarLen + &quot;?length=110&quot;, &quot;chunked transfer encoding&quot; }, // EOF during chunk response body data
152 
</pre>
<hr />
<pre>
171             { httpURIFixLen + &quot;?length=2&quot;,   &quot;status line&quot; },
172             { httpURIFixLen + &quot;?length=10&quot;,  &quot;status line&quot; },
173             { httpURIFixLen + &quot;?length=19&quot;,  &quot;header&quot;      }, // EOF during Content-Type header
174             { httpURIFixLen + &quot;?length=30&quot;,  &quot;header&quot;      },
175             { httpURIFixLen + &quot;?length=45&quot;,  &quot;header&quot;      },
176             { httpURIFixLen + &quot;?length=48&quot;,  &quot;header&quot;      },
177             { httpURIFixLen + &quot;?length=51&quot;,  &quot;header&quot;      },
178             { httpURIFixLen + &quot;?length=78&quot;,  &quot;header&quot;      }, // EOF during Connection header
179             { httpURIFixLen + &quot;?length=79&quot;,  &quot;header&quot;      },
180             { httpURIFixLen + &quot;?length=86&quot;,  &quot;header&quot;      },
181             { httpURIFixLen + &quot;?length=104&quot;, &quot;fixed content-length&quot; }, // EOF during body
182             { httpURIFixLen + &quot;?length=106&quot;, &quot;fixed content-length&quot; },
183             { httpURIFixLen + &quot;?length=110&quot;, &quot;fixed content-length&quot; },
184 
185             // ## ADD https fixed
186 
187             { httpURIClsImed,  &quot;no bytes&quot;},
188             { httpsURIClsImed, &quot;no bytes&quot;},
189         };
190 







191         List&lt;Object[]&gt; list = new ArrayList&lt;&gt;();
192         Arrays.asList(cases).stream()
193                 .map(e -&gt; new Object[] {e[0], e[1], true})  // reuse client
194                 .forEach(list::add);
195         Arrays.asList(cases).stream()
196                 .map(e -&gt; new Object[] {e[0], e[1], false}) // do not reuse client
197                 .forEach(list::add);
198         return list.stream().toArray(Object[][]::new);
199     }
200 
201     static final int ITERATION_COUNT = 3;
202 
203     HttpClient newHttpClient() {
204         return HttpClient.newBuilder()
205                 .proxy(NO_PROXY)
206                 .sslContext(sslContext)
207                 .sslParameters(sslParameters)
208                 .executor(service)
209                 .build();
210     }
</pre>
<hr />
<pre>
353     void testAsynchronousPOST(String url, String expectedMsg, boolean sameClient)
354         throws Exception
355     {
356         out.print(&quot;---\n&quot;);
357         HttpClient client = null;
358         for (int i=0; i&lt; ITERATION_COUNT; i++) {
359             if (!sameClient || client == null)
360                 client = newHttpClient();
361             HttpRequest request = HttpRequest.newBuilder(URI.create(url))
362                     .POST(BodyPublishers.ofInputStream(() -&gt; new InfiniteInputStream()))
363                     .build();
364             try {
365                 HttpResponse&lt;String&gt; response = client.sendAsync(request, ofString()).get();
366                 String body = response.body();
367                 out.println(response + &quot;: &quot; + body);
368                 fail(&quot;UNEXPECTED RESPONSE: &quot; + response);
369             } catch (ExecutionException ee) {
370                 if (ee.getCause() instanceof IOException) {
371                     IOException ioe = (IOException) ee.getCause();
372                     out.println(&quot;Caught expected exception:&quot; + ioe);
<span class="line-removed">373                     String msg = ioe.getMessage();</span>
374 
375                     List&lt;String&gt; expectedMessages = new ArrayList&lt;&gt;();
376                     expectedMessages.add(expectedMsg);
377                     MSGS_ORDER.stream().takeWhile(s -&gt; !s.equals(expectedMsg))
378                             .forEach(expectedMessages::add);
379 
380                     assertExpectedMessage(request, ioe, expectedMessages);
381                     assertNoConnectionExpiredException(ioe);
382                 } else {
383                     throw ee;
384                 }
385             }
386         }
387     }
388 
389 
390     void assertExpectedMessage(HttpRequest request, Throwable t, String expected) {
391         if (request.uri().getScheme().equalsIgnoreCase(&quot;https&quot;)
392                 &amp;&amp; (t instanceof SSLHandshakeException)) {
393             // OK
</pre>
<hr />
<pre>
452             super(name);
453             ss = newServerSocket();
454             ss.bind(new InetSocketAddress(InetAddress.getLoopbackAddress(), 0));
455             this.start();
456         }
457 
458         protected ServerSocket newServerSocket() throws IOException {
459             return new ServerSocket();
460         }
461 
462         public int getPort() { return ss.getLocalPort(); }
463 
464         @Override
465         public void close() {
466             if (closed)
467                 return;
468             closed = true;
469             try {
470                 ss.close();
471             } catch (IOException e) {
<span class="line-modified">472                 throw new UncheckedIOException(&quot;Unexpected&quot;, e);</span>


473             }
474         }
475     }
476 
477     /**
478      * A server that closes the connection immediately, without reading or writing.
479      */
480     static class PlainCloseImmediatelyServer extends Server {
481         PlainCloseImmediatelyServer() throws IOException {
482             super(&quot;PlainCloseImmediatelyServer&quot;);
483         }
484 
485         protected PlainCloseImmediatelyServer(String name) throws IOException {
486             super(name);
487         }
488 
489         @Override
490         public void run() {
491             while (!closed) {
492                 try (Socket s = ss.accept()) {
493                     if (s instanceof SSLSocket) {
494                         ((SSLSocket)s).startHandshake();
495                     }
496                     out.println(&quot;Server: got connection, closing immediately &quot;);
<span class="line-modified">497                 } catch (IOException e) {</span>
<span class="line-modified">498                     if (!closed)</span>
<span class="line-modified">499                         throw new UncheckedIOException(&quot;Unexpected&quot;, e);</span>



500                 }
501             }
502         }
503     }
504 
505     /**
506      * A server that closes the connection immediately, without reading or writing,
507      * after completing the SSL handshake.
508      */
509     static final class SSLCloseImmediatelyServer extends PlainCloseImmediatelyServer {
510         SSLCloseImmediatelyServer() throws IOException {
511             super(&quot;SSLCloseImmediatelyServer&quot;);
512         }
513         @Override
514         public ServerSocket newServerSocket() throws IOException {
515             return SSLServerSocketFactory.getDefault().createServerSocket();
516         }
517     }
518 
519     /**
</pre>
<hr />
<pre>
548                     String query = uriPath.getRawQuery();
549                     if (query == null) {
550                         out.println(&quot;Request headers: [&quot; + headers + &quot;]&quot;);
551                     }
552                     assert query != null : &quot;null query for uriPath: &quot; + uriPath;
553                     String qv = query.split(&quot;=&quot;)[1];
554                     int len;
555                     if (qv.equals(&quot;all&quot;)) {
556                         len = response().getBytes(US_ASCII).length;
557                     } else {
558                         len = Integer.parseInt(query.split(&quot;=&quot;)[1]);
559                     }
560 
561                     OutputStream os = s.getOutputStream();
562                     out.println(name + &quot;: writing &quot; + len  + &quot; bytes&quot;);
563                     byte[] responseBytes = response().getBytes(US_ASCII);
564                     for (int i = 0; i&lt; len; i++) {
565                         os.write(responseBytes[i]);
566                         os.flush();
567                     }
<span class="line-modified">568                 } catch (IOException e) {</span>
<span class="line-modified">569                     if (!closed)</span>
<span class="line-modified">570                         throw new UncheckedIOException(&quot;Unexpected&quot;, e);</span>



571                 }
572             }
573         }
574 
575         static final byte[] requestEnd = new byte[] { &#39;\r&#39;, &#39;\n&#39;, &#39;\r&#39;, &#39;\n&#39; };
576 
577         // Read the request method
578         static URI readRequestMethod(InputStream is) throws IOException {
579             StringBuilder sb = new StringBuilder();
580             int r;
581             while ((r = is.read()) != -1 &amp;&amp; r != 0x20) {
582                 sb.append((char)r);
583             }
584             return URI.create(sb.toString());
585         }
586 
587         // Read the request URI path
588         static URI readRequestPath(InputStream is) throws IOException {
589             StringBuilder sb = new StringBuilder();
590             int r;
</pre>
<hr />
<pre>
673             super(&quot;FixedLengthServer&quot;);
674         }
675 
676         @Override
677         String response( ) { return RESPONSE; }
678     }
679 
680     static String serverAuthority(Server server) {
681         return InetAddress.getLoopbackAddress().getHostName() + &quot;:&quot;
682                 + server.getPort();
683     }
684 
685     @BeforeTest
686     public void setup() throws Exception {
687         sslContext = new SimpleSSLContext().get();
688         if (sslContext == null)
689             throw new AssertionError(&quot;Unexpected null sslContext&quot;);
690         SSLContext.setDefault(sslContext);
691 
692         sslParameters = new SSLParameters();
<span class="line-removed">693         sslParameters.setProtocols(new String[] {&quot;TLSv1.2&quot;});</span>
694 
695         closeImmediatelyServer = new PlainCloseImmediatelyServer();
696         httpURIClsImed = &quot;http://&quot; + serverAuthority(closeImmediatelyServer)
697                 + &quot;/http1/closeImmediately/foo&quot;;
698 
699         closeImmediatelyHttpsServer = new SSLCloseImmediatelyServer();
700         httpsURIClsImed = &quot;https://&quot; + serverAuthority(closeImmediatelyHttpsServer)
701                 + &quot;/https1/closeImmediately/foo&quot;;
702 
703         variableLengthServer = new PlainVariableLengthServer();
704         httpURIVarLen = &quot;http://&quot; + serverAuthority(variableLengthServer)
705                 + &quot;/http1/variable/bar&quot;;
706 
707         variableLengthHttpsServer = new SSLVariableLengthServer();
708         httpsURIVarLen = &quot;https://&quot; + serverAuthority(variableLengthHttpsServer)
709                 + &quot;/https1/variable/bar&quot;;
710 
711         fixedLengthServer = new FixedLengthServer();
712         httpURIFixLen = &quot;http://&quot; + serverAuthority(fixedLengthServer)
713                 + &quot;/http1/fixed/baz&quot;;
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2018, 2020, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
</pre>
<hr />
<pre>
 33  *       ShortResponseBody
 34  */
 35 
 36 import java.io.IOException;
 37 import java.io.InputStream;
 38 import java.io.OutputStream;
 39 import java.io.UncheckedIOException;
 40 import java.net.InetAddress;
 41 import java.net.InetSocketAddress;
 42 import java.net.ServerSocket;
 43 import java.net.Socket;
 44 import java.net.URI;
 45 import java.net.http.HttpClient;
 46 import java.net.http.HttpRequest;
 47 import java.net.http.HttpRequest.BodyPublishers;
 48 import java.net.http.HttpResponse;
 49 import java.util.ArrayList;
 50 import java.util.Arrays;
 51 import java.util.List;
 52 import java.util.concurrent.ExecutionException;

 53 import java.util.concurrent.ExecutorService;
 54 import java.util.concurrent.Executors;
 55 import java.util.concurrent.ThreadFactory;
 56 import java.util.concurrent.atomic.AtomicLong;
 57 import java.util.stream.Stream;
 58 import jdk.test.lib.net.SimpleSSLContext;
<span class="line-added"> 59 import org.testng.ITestContext;</span>
<span class="line-added"> 60 import org.testng.annotations.BeforeMethod;</span>
 61 import org.testng.annotations.AfterTest;
 62 import org.testng.annotations.BeforeTest;
 63 import org.testng.annotations.DataProvider;
 64 import org.testng.annotations.Test;
 65 import javax.net.ssl.SSLContext;
 66 import javax.net.ssl.SSLHandshakeException;
 67 import javax.net.ssl.SSLServerSocketFactory;
 68 import javax.net.ssl.SSLParameters;
 69 import javax.net.ssl.SSLSocket;
 70 import static java.lang.System.out;
 71 import static java.net.http.HttpClient.Builder.NO_PROXY;
 72 import static java.net.http.HttpResponse.BodyHandlers.ofString;
 73 import static java.nio.charset.StandardCharsets.US_ASCII;
 74 import static java.util.stream.Collectors.toList;
 75 import static org.testng.Assert.assertTrue;
 76 import static org.testng.Assert.assertEquals;
 77 import static org.testng.Assert.fail;
 78 
 79 public class ShortResponseBody {
 80 
</pre>
<hr />
<pre>
 90     String httpsURIVarLen;
 91     String httpURIFixLen;
 92 
 93     SSLContext sslContext;
 94     SSLParameters sslParameters;
 95 
 96     static final String EXPECTED_RESPONSE_BODY =
 97             &quot;&lt;html&gt;&lt;body&gt;&lt;h1&gt;Heading&lt;/h1&gt;&lt;p&gt;Some Text&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;&quot;;
 98 
 99     final static AtomicLong ids = new AtomicLong();
100     final ThreadFactory factory = new ThreadFactory() {
101         @Override
102         public Thread newThread(Runnable r) {
103             Thread thread = new Thread(r,  &quot;HttpClient-Worker-&quot; + ids.incrementAndGet());
104             thread.setDaemon(true);
105             return thread;
106         }
107     };
108     final ExecutorService service = Executors.newCachedThreadPool(factory);
109 
<span class="line-added">110     @BeforeMethod</span>
<span class="line-added">111     void beforeMethod(ITestContext context) {</span>
<span class="line-added">112         if (context.getFailedTests().size() &gt; 0) {</span>
<span class="line-added">113             throw new RuntimeException(&quot;some tests failed&quot;);</span>
<span class="line-added">114         }</span>
<span class="line-added">115     }</span>
<span class="line-added">116 </span>
117     @DataProvider(name = &quot;sanity&quot;)
118     public Object[][] sanity() {
119         return new Object[][]{
120             { httpURIVarLen  + &quot;?length=all&quot; },
121             { httpsURIVarLen + &quot;?length=all&quot; },
122             { httpURIFixLen  + &quot;?length=all&quot; },
123         };
124     }
125 
126     @Test(dataProvider = &quot;sanity&quot;)
127     void sanity(String url) throws Exception {
128         HttpClient client = newHttpClient();
129         HttpRequest request = HttpRequest.newBuilder(URI.create(url)).build();
130         HttpResponse&lt;String&gt; response = client.send(request, ofString());
131         String body = response.body();
132         assertEquals(body, EXPECTED_RESPONSE_BODY);
133         client.sendAsync(request, ofString())
134                 .thenApply(resp -&gt; resp.body())
135                 .thenAccept(b -&gt; assertEquals(b, EXPECTED_RESPONSE_BODY))
136                 .join();
137     }
138 
139     @DataProvider(name = &quot;uris&quot;)
<span class="line-modified">140     public Object[][] variants(ITestContext context) {</span>
141         String[][] cases = new String[][] {
142             // The length query string is the total number of bytes in the reply,
143             // including headers, before the server closes the connection. The
144             // second arg is a partial-expected-detail message in the exception.
145             { httpURIVarLen + &quot;?length=0&quot;,   &quot;no bytes&quot;     }, // EOF without receiving anything
146             { httpURIVarLen + &quot;?length=1&quot;,   &quot;status line&quot;  }, // EOF during status-line
147             { httpURIVarLen + &quot;?length=2&quot;,   &quot;status line&quot;  },
148             { httpURIVarLen + &quot;?length=10&quot;,  &quot;status line&quot;  },
149             { httpURIVarLen + &quot;?length=19&quot;,  &quot;header&quot;       }, // EOF during Content-Type header
150             { httpURIVarLen + &quot;?length=30&quot;,  &quot;header&quot;       },
151             { httpURIVarLen + &quot;?length=45&quot;,  &quot;header&quot;       },
152             { httpURIVarLen + &quot;?length=48&quot;,  &quot;header&quot;       },
153             { httpURIVarLen + &quot;?length=51&quot;,  &quot;header&quot;       },
154             { httpURIVarLen + &quot;?length=98&quot;,  &quot;header&quot;       }, // EOF during Connection header
155             { httpURIVarLen + &quot;?length=100&quot;, &quot;header&quot;       },
156             { httpURIVarLen + &quot;?length=101&quot;, &quot;header&quot;       },
157             { httpURIVarLen + &quot;?length=104&quot;, &quot;header&quot;       },
158             { httpURIVarLen + &quot;?length=106&quot;, &quot;chunked transfer encoding&quot; }, // EOF during chunk header ( length )
159             { httpURIVarLen + &quot;?length=110&quot;, &quot;chunked transfer encoding&quot; }, // EOF during chunk response body data
160 
</pre>
<hr />
<pre>
179             { httpURIFixLen + &quot;?length=2&quot;,   &quot;status line&quot; },
180             { httpURIFixLen + &quot;?length=10&quot;,  &quot;status line&quot; },
181             { httpURIFixLen + &quot;?length=19&quot;,  &quot;header&quot;      }, // EOF during Content-Type header
182             { httpURIFixLen + &quot;?length=30&quot;,  &quot;header&quot;      },
183             { httpURIFixLen + &quot;?length=45&quot;,  &quot;header&quot;      },
184             { httpURIFixLen + &quot;?length=48&quot;,  &quot;header&quot;      },
185             { httpURIFixLen + &quot;?length=51&quot;,  &quot;header&quot;      },
186             { httpURIFixLen + &quot;?length=78&quot;,  &quot;header&quot;      }, // EOF during Connection header
187             { httpURIFixLen + &quot;?length=79&quot;,  &quot;header&quot;      },
188             { httpURIFixLen + &quot;?length=86&quot;,  &quot;header&quot;      },
189             { httpURIFixLen + &quot;?length=104&quot;, &quot;fixed content-length&quot; }, // EOF during body
190             { httpURIFixLen + &quot;?length=106&quot;, &quot;fixed content-length&quot; },
191             { httpURIFixLen + &quot;?length=110&quot;, &quot;fixed content-length&quot; },
192 
193             // ## ADD https fixed
194 
195             { httpURIClsImed,  &quot;no bytes&quot;},
196             { httpsURIClsImed, &quot;no bytes&quot;},
197         };
198 
<span class="line-added">199         if (context.getFailedTests().size() &gt; 0) {</span>
<span class="line-added">200             // Shorten the log output by preventing useless</span>
<span class="line-added">201             // skip traces to be printed for subsequent methods</span>
<span class="line-added">202             // if one of the previous @Test method has failed.</span>
<span class="line-added">203             return new Object[0][];</span>
<span class="line-added">204         }</span>
<span class="line-added">205 </span>
206         List&lt;Object[]&gt; list = new ArrayList&lt;&gt;();
207         Arrays.asList(cases).stream()
208                 .map(e -&gt; new Object[] {e[0], e[1], true})  // reuse client
209                 .forEach(list::add);
210         Arrays.asList(cases).stream()
211                 .map(e -&gt; new Object[] {e[0], e[1], false}) // do not reuse client
212                 .forEach(list::add);
213         return list.stream().toArray(Object[][]::new);
214     }
215 
216     static final int ITERATION_COUNT = 3;
217 
218     HttpClient newHttpClient() {
219         return HttpClient.newBuilder()
220                 .proxy(NO_PROXY)
221                 .sslContext(sslContext)
222                 .sslParameters(sslParameters)
223                 .executor(service)
224                 .build();
225     }
</pre>
<hr />
<pre>
368     void testAsynchronousPOST(String url, String expectedMsg, boolean sameClient)
369         throws Exception
370     {
371         out.print(&quot;---\n&quot;);
372         HttpClient client = null;
373         for (int i=0; i&lt; ITERATION_COUNT; i++) {
374             if (!sameClient || client == null)
375                 client = newHttpClient();
376             HttpRequest request = HttpRequest.newBuilder(URI.create(url))
377                     .POST(BodyPublishers.ofInputStream(() -&gt; new InfiniteInputStream()))
378                     .build();
379             try {
380                 HttpResponse&lt;String&gt; response = client.sendAsync(request, ofString()).get();
381                 String body = response.body();
382                 out.println(response + &quot;: &quot; + body);
383                 fail(&quot;UNEXPECTED RESPONSE: &quot; + response);
384             } catch (ExecutionException ee) {
385                 if (ee.getCause() instanceof IOException) {
386                     IOException ioe = (IOException) ee.getCause();
387                     out.println(&quot;Caught expected exception:&quot; + ioe);

388 
389                     List&lt;String&gt; expectedMessages = new ArrayList&lt;&gt;();
390                     expectedMessages.add(expectedMsg);
391                     MSGS_ORDER.stream().takeWhile(s -&gt; !s.equals(expectedMsg))
392                             .forEach(expectedMessages::add);
393 
394                     assertExpectedMessage(request, ioe, expectedMessages);
395                     assertNoConnectionExpiredException(ioe);
396                 } else {
397                     throw ee;
398                 }
399             }
400         }
401     }
402 
403 
404     void assertExpectedMessage(HttpRequest request, Throwable t, String expected) {
405         if (request.uri().getScheme().equalsIgnoreCase(&quot;https&quot;)
406                 &amp;&amp; (t instanceof SSLHandshakeException)) {
407             // OK
</pre>
<hr />
<pre>
466             super(name);
467             ss = newServerSocket();
468             ss.bind(new InetSocketAddress(InetAddress.getLoopbackAddress(), 0));
469             this.start();
470         }
471 
472         protected ServerSocket newServerSocket() throws IOException {
473             return new ServerSocket();
474         }
475 
476         public int getPort() { return ss.getLocalPort(); }
477 
478         @Override
479         public void close() {
480             if (closed)
481                 return;
482             closed = true;
483             try {
484                 ss.close();
485             } catch (IOException e) {
<span class="line-modified">486                 out.println(&quot;Unexpected exception while closing server: &quot; + e);</span>
<span class="line-added">487                 e.printStackTrace(out);</span>
<span class="line-added">488                 throw new UncheckedIOException(&quot;Unexpected: &quot;, e);</span>
489             }
490         }
491     }
492 
493     /**
494      * A server that closes the connection immediately, without reading or writing.
495      */
496     static class PlainCloseImmediatelyServer extends Server {
497         PlainCloseImmediatelyServer() throws IOException {
498             super(&quot;PlainCloseImmediatelyServer&quot;);
499         }
500 
501         protected PlainCloseImmediatelyServer(String name) throws IOException {
502             super(name);
503         }
504 
505         @Override
506         public void run() {
507             while (!closed) {
508                 try (Socket s = ss.accept()) {
509                     if (s instanceof SSLSocket) {
510                         ((SSLSocket)s).startHandshake();
511                     }
512                     out.println(&quot;Server: got connection, closing immediately &quot;);
<span class="line-modified">513                 } catch (Throwable e) {</span>
<span class="line-modified">514                     if (!closed) {</span>
<span class="line-modified">515                         out.println(&quot;Unexpected exception in server: &quot; + e);</span>
<span class="line-added">516                         e.printStackTrace(out);</span>
<span class="line-added">517                         throw new RuntimeException(&quot;Unexpected: &quot;, e);</span>
<span class="line-added">518                     }</span>
519                 }
520             }
521         }
522     }
523 
524     /**
525      * A server that closes the connection immediately, without reading or writing,
526      * after completing the SSL handshake.
527      */
528     static final class SSLCloseImmediatelyServer extends PlainCloseImmediatelyServer {
529         SSLCloseImmediatelyServer() throws IOException {
530             super(&quot;SSLCloseImmediatelyServer&quot;);
531         }
532         @Override
533         public ServerSocket newServerSocket() throws IOException {
534             return SSLServerSocketFactory.getDefault().createServerSocket();
535         }
536     }
537 
538     /**
</pre>
<hr />
<pre>
567                     String query = uriPath.getRawQuery();
568                     if (query == null) {
569                         out.println(&quot;Request headers: [&quot; + headers + &quot;]&quot;);
570                     }
571                     assert query != null : &quot;null query for uriPath: &quot; + uriPath;
572                     String qv = query.split(&quot;=&quot;)[1];
573                     int len;
574                     if (qv.equals(&quot;all&quot;)) {
575                         len = response().getBytes(US_ASCII).length;
576                     } else {
577                         len = Integer.parseInt(query.split(&quot;=&quot;)[1]);
578                     }
579 
580                     OutputStream os = s.getOutputStream();
581                     out.println(name + &quot;: writing &quot; + len  + &quot; bytes&quot;);
582                     byte[] responseBytes = response().getBytes(US_ASCII);
583                     for (int i = 0; i&lt; len; i++) {
584                         os.write(responseBytes[i]);
585                         os.flush();
586                     }
<span class="line-modified">587                 } catch (Throwable e) {</span>
<span class="line-modified">588                     if (!closed) {</span>
<span class="line-modified">589                         out.println(&quot;Unexpected exception in server: &quot; + e);</span>
<span class="line-added">590                         e.printStackTrace(out);</span>
<span class="line-added">591                         throw new RuntimeException(&quot;Unexpected: &quot; + e, e);</span>
<span class="line-added">592                     }</span>
593                 }
594             }
595         }
596 
597         static final byte[] requestEnd = new byte[] { &#39;\r&#39;, &#39;\n&#39;, &#39;\r&#39;, &#39;\n&#39; };
598 
599         // Read the request method
600         static URI readRequestMethod(InputStream is) throws IOException {
601             StringBuilder sb = new StringBuilder();
602             int r;
603             while ((r = is.read()) != -1 &amp;&amp; r != 0x20) {
604                 sb.append((char)r);
605             }
606             return URI.create(sb.toString());
607         }
608 
609         // Read the request URI path
610         static URI readRequestPath(InputStream is) throws IOException {
611             StringBuilder sb = new StringBuilder();
612             int r;
</pre>
<hr />
<pre>
695             super(&quot;FixedLengthServer&quot;);
696         }
697 
698         @Override
699         String response( ) { return RESPONSE; }
700     }
701 
702     static String serverAuthority(Server server) {
703         return InetAddress.getLoopbackAddress().getHostName() + &quot;:&quot;
704                 + server.getPort();
705     }
706 
707     @BeforeTest
708     public void setup() throws Exception {
709         sslContext = new SimpleSSLContext().get();
710         if (sslContext == null)
711             throw new AssertionError(&quot;Unexpected null sslContext&quot;);
712         SSLContext.setDefault(sslContext);
713 
714         sslParameters = new SSLParameters();

715 
716         closeImmediatelyServer = new PlainCloseImmediatelyServer();
717         httpURIClsImed = &quot;http://&quot; + serverAuthority(closeImmediatelyServer)
718                 + &quot;/http1/closeImmediately/foo&quot;;
719 
720         closeImmediatelyHttpsServer = new SSLCloseImmediatelyServer();
721         httpsURIClsImed = &quot;https://&quot; + serverAuthority(closeImmediatelyHttpsServer)
722                 + &quot;/https1/closeImmediately/foo&quot;;
723 
724         variableLengthServer = new PlainVariableLengthServer();
725         httpURIVarLen = &quot;http://&quot; + serverAuthority(variableLengthServer)
726                 + &quot;/http1/variable/bar&quot;;
727 
728         variableLengthHttpsServer = new SSLVariableLengthServer();
729         httpsURIVarLen = &quot;https://&quot; + serverAuthority(variableLengthHttpsServer)
730                 + &quot;/https1/variable/bar&quot;;
731 
732         fixedLengthServer = new FixedLengthServer();
733         httpURIFixLen = &quot;http://&quot; + serverAuthority(fixedLengthServer)
734                 + &quot;/http1/fixed/baz&quot;;
</pre>
</td>
</tr>
</table>
<center><a href="ShortRequestBody.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="SmokeTest.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
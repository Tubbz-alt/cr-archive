<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames test/jdk/java/net/HttpURLConnection/SetAuthenticator/HTTPTestServer.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (c) 2016, 2019, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  */
  23 
  24 import com.sun.net.httpserver.BasicAuthenticator;
  25 import com.sun.net.httpserver.Filter;
  26 import com.sun.net.httpserver.Headers;
  27 import com.sun.net.httpserver.HttpContext;
  28 import com.sun.net.httpserver.HttpExchange;
  29 import com.sun.net.httpserver.HttpHandler;
  30 import com.sun.net.httpserver.HttpServer;
  31 import com.sun.net.httpserver.HttpsConfigurator;
  32 import com.sun.net.httpserver.HttpsParameters;
  33 import com.sun.net.httpserver.HttpsServer;
  34 import java.io.IOException;
  35 import java.io.InputStream;
  36 import java.io.OutputStream;
  37 import java.io.OutputStreamWriter;
  38 import java.io.PrintWriter;
  39 import java.io.Writer;
  40 import java.math.BigInteger;
  41 import java.net.HttpURLConnection;
  42 import java.net.InetAddress;
  43 import java.net.InetSocketAddress;
  44 import java.net.MalformedURLException;
  45 import java.net.ServerSocket;
  46 import java.net.Socket;
  47 import java.net.SocketAddress;
  48 import java.net.URL;
  49 import java.security.MessageDigest;
  50 import java.security.NoSuchAlgorithmException;
  51 import java.time.Instant;
  52 import java.util.ArrayList;
  53 import java.util.Arrays;
  54 import java.util.Base64;
  55 import java.util.List;
  56 import java.util.Objects;
  57 import java.util.Random;
  58 import java.util.concurrent.CopyOnWriteArrayList;
  59 import java.util.stream.Collectors;
  60 import javax.net.ssl.SSLContext;
  61 import sun.net.www.HeaderParser;
  62 
  63 /**
  64  * A simple HTTP server that supports Digest authentication.
  65  * By default this server will echo back whatever is present
  66  * in the request body.
  67  * @author danielfuchs
  68  */
  69 public class HTTPTestServer extends HTTPTest {
  70 
  71     final HttpServer      serverImpl; // this server endpoint
  72     final HTTPTestServer  redirect;   // the target server where to redirect 3xx
  73     final HttpHandler     delegate;   // unused
  74 
  75     private HTTPTestServer(HttpServer server, HTTPTestServer target,
  76                            HttpHandler delegate) {
  77         this.serverImpl = server;
  78         this.redirect = target;
  79         this.delegate = delegate;
  80     }
  81 
  82     public static void main(String[] args)
  83             throws IOException {
  84 
  85            HTTPTestServer server = create(HTTPTest.DEFAULT_PROTOCOL_TYPE,
  86                                           HTTPTest.DEFAULT_HTTP_AUTH_TYPE,
  87                                           HTTPTest.AUTHENTICATOR,
  88                                           HTTPTest.DEFAULT_SCHEME_TYPE);
  89            try {
  90                System.out.println(&quot;Server created at &quot; + server.getAddress());
  91                System.out.println(&quot;Strike &lt;Return&gt; to exit&quot;);
  92                System.in.read();
  93            } finally {
  94                System.out.println(&quot;stopping server&quot;);
  95                server.stop();
  96            }
  97     }
  98 
  99     private static String toString(Headers headers) {
 100         return headers.entrySet().stream()
 101                 .map((e) -&gt; e.getKey() + &quot;: &quot; + e.getValue())
 102                 .collect(Collectors.joining(&quot;\n&quot;));
 103     }
 104 
 105     public static HTTPTestServer create(HttpProtocolType protocol,
 106                                         HttpAuthType authType,
 107                                         HttpTestAuthenticator auth,
 108                                         HttpSchemeType schemeType)
 109             throws IOException {
 110         return create(protocol, authType, auth, schemeType, null);
 111     }
 112 
 113     public static HTTPTestServer create(HttpProtocolType protocol,
 114                                         HttpAuthType authType,
 115                                         HttpTestAuthenticator auth,
 116                                         HttpSchemeType schemeType,
 117                                         HttpHandler delegate)
 118             throws IOException {
 119         Objects.requireNonNull(authType);
 120         Objects.requireNonNull(auth);
 121         switch(authType) {
 122             // A server that performs Server Digest authentication.
 123             case SERVER: return createServer(protocol, authType, auth,
 124                                              schemeType, delegate, &quot;/&quot;);
 125             // A server that pretends to be a Proxy and performs
 126             // Proxy Digest authentication. If protocol is HTTPS,
 127             // then this will create a HttpsProxyTunnel that will
 128             // handle the CONNECT request for tunneling.
 129             case PROXY: return createProxy(protocol, authType, auth,
 130                                            schemeType, delegate, &quot;/&quot;);
 131             // A server that sends 307 redirect to a server that performs
 132             // Digest authentication.
 133             // Note: 301 doesn&#39;t work here because it transforms POST into GET.
 134             case SERVER307: return createServerAndRedirect(protocol,
 135                                                         HttpAuthType.SERVER,
 136                                                         auth, schemeType,
 137                                                         delegate, 307);
 138             // A server that sends 305 redirect to a proxy that performs
 139             // Digest authentication.
 140             case PROXY305:  return createServerAndRedirect(protocol,
 141                                                         HttpAuthType.PROXY,
 142                                                         auth, schemeType,
 143                                                         delegate, 305);
 144             default:
 145                 throw new InternalError(&quot;Unknown server type: &quot; + authType);
 146         }
 147     }
 148 
 149     /**
 150      * The SocketBindableFactory ensures that the local port used by an HttpServer
 151      * or a proxy ServerSocket previously created by the current test/VM will not
 152      * get reused by a subsequent test in the same VM. This is to avoid having the
 153      * AuthCache reuse credentials from previous tests - which would invalidate the
 154      * assumptions made by the current test on when the default authenticator should
 155      * be called.
 156      */
 157     private static abstract class SocketBindableFactory&lt;B&gt; {
 158         private static final int MAX = 10;
 159         private static final CopyOnWriteArrayList&lt;String&gt; addresses =
 160             new CopyOnWriteArrayList&lt;&gt;();
 161         protected B createInternal() throws IOException {
 162             final int max = addresses.size() + MAX;
 163             final List&lt;B&gt; toClose = new ArrayList&lt;&gt;();
 164             try {
 165                 for (int i = 1; i &lt;= max; i++) {
 166                     B bindable = createBindable();
 167                     SocketAddress address = getAddress(bindable);
<a name="1" id="anc1"></a><span class="line-modified"> 168                     String key = toString(address);</span>
 169                     if (addresses.addIfAbsent(key)) {
 170                        System.out.println(&quot;Socket bound to: &quot; + key
 171                                           + &quot; after &quot; + i + &quot; attempt(s)&quot;);
 172                        return bindable;
 173                     }
 174                     System.out.println(&quot;warning: address &quot; + key
 175                                        + &quot; already used. Retrying bind.&quot;);
 176                     // keep the port bound until we get a port that we haven&#39;t
 177                     // used already
 178                     toClose.add(bindable);
 179                 }
 180             } finally {
 181                 // if we had to retry, then close the socket we&#39;re not
 182                 // going to use.
 183                 for (B b : toClose) {
 184                   try { close(b); } catch (Exception x) { /* ignore */ }
 185                 }
 186             }
 187             throw new IOException(&quot;Couldn&#39;t bind socket after &quot; + max + &quot; attempts: &quot;
 188                                   + &quot;addresses used before: &quot; + addresses);
 189         }
 190 
<a name="2" id="anc2"></a><span class="line-added"> 191         private static String toString(SocketAddress address) {</span>
<span class="line-added"> 192             // We don&#39;t rely on address.toString(): sometimes it can be</span>
<span class="line-added"> 193             // &quot;/127.0.0.1:port&quot;, sometimes it can be &quot;localhost/127.0.0.1:port&quot;</span>
<span class="line-added"> 194             // Instead we compose our own string representation:</span>
<span class="line-added"> 195             InetSocketAddress candidate = (InetSocketAddress) address;</span>
<span class="line-added"> 196             String hostAddr = candidate.getAddress().getHostAddress();</span>
<span class="line-added"> 197             if (hostAddr.contains(&quot;:&quot;)) hostAddr = &quot;[&quot; + hostAddr + &quot;]&quot;;</span>
<span class="line-added"> 198             return hostAddr + &quot;:&quot; + candidate.getPort();</span>
<span class="line-added"> 199         }</span>
<span class="line-added"> 200 </span>
 201         protected abstract B createBindable() throws IOException;
 202 
 203         protected abstract SocketAddress getAddress(B bindable);
 204 
 205         protected abstract void close(B bindable) throws IOException;
 206     }
 207 
 208     /*
 209      * Used to create ServerSocket for a proxy.
 210      */
 211     private static final class ServerSocketFactory
 212             extends SocketBindableFactory&lt;ServerSocket&gt; {
 213         private static final ServerSocketFactory instance = new ServerSocketFactory();
 214 
 215         static ServerSocket create() throws IOException {
 216             return instance.createInternal();
 217         }
 218 
 219         @Override
 220         protected ServerSocket createBindable() throws IOException {
 221             InetAddress address = InetAddress.getLoopbackAddress();
 222             return new ServerSocket(0, 0, address);
 223         }
 224 
 225         @Override
 226         protected SocketAddress getAddress(ServerSocket socket) {
 227             return socket.getLocalSocketAddress();
 228         }
 229 
 230         @Override
 231         protected void close(ServerSocket socket) throws IOException {
 232             socket.close();
 233         }
 234     }
 235 
 236     /*
 237      * Used to create HttpServer for a NTLMTestServer.
 238      */
 239     private static abstract class WebServerFactory&lt;S extends HttpServer&gt;
 240             extends SocketBindableFactory&lt;S&gt; {
 241         @Override
 242         protected S createBindable() throws IOException {
 243             S server = newHttpServer();
 244             InetAddress address = InetAddress.getLoopbackAddress();
 245             server.bind(new InetSocketAddress(address, 0), 0);
 246             return server;
 247         }
 248 
 249         @Override
 250         protected SocketAddress getAddress(S server) {
 251             return server.getAddress();
 252         }
 253 
 254         @Override
 255         protected void close(S server) throws IOException {
 256             server.stop(1);
 257         }
 258 
 259         /*
 260          * Returns a HttpServer or a HttpsServer in different subclasses.
 261          */
 262         protected abstract S newHttpServer() throws IOException;
 263     }
 264 
 265     private static final class HttpServerFactory extends WebServerFactory&lt;HttpServer&gt; {
 266         private static final HttpServerFactory instance = new HttpServerFactory();
 267 
 268         static HttpServer create() throws IOException {
 269             return instance.createInternal();
 270         }
 271 
 272         @Override
 273         protected HttpServer newHttpServer() throws IOException {
 274             return HttpServer.create();
 275         }
 276     }
 277 
 278     private static final class HttpsServerFactory extends WebServerFactory&lt;HttpsServer&gt; {
 279         private static final HttpsServerFactory instance = new HttpsServerFactory();
 280 
 281         static HttpsServer create() throws IOException {
 282             return instance.createInternal();
 283         }
 284 
 285         @Override
 286         protected HttpsServer newHttpServer() throws IOException {
 287             return HttpsServer.create();
 288         }
 289     }
 290 
 291     static HttpServer createHttpServer(HttpProtocolType protocol) throws IOException {
 292         switch (protocol) {
 293             case HTTP:  return HttpServerFactory.create();
 294             case HTTPS: return configure(HttpsServerFactory.create());
 295             default: throw new InternalError(&quot;Unsupported protocol &quot; + protocol);
 296         }
 297     }
 298 
 299     static HttpsServer configure(HttpsServer server) throws IOException {
 300         try {
 301             SSLContext ctx = SSLContext.getDefault();
 302             server.setHttpsConfigurator(new Configurator(ctx));
 303         } catch (NoSuchAlgorithmException ex) {
 304             throw new IOException(ex);
 305         }
 306         return server;
 307     }
 308 
 309 
 310     static void setContextAuthenticator(HttpContext ctxt,
 311                                         HttpTestAuthenticator auth) {
 312         final String realm = auth.getRealm();
 313         com.sun.net.httpserver.Authenticator authenticator =
 314             new BasicAuthenticator(realm) {
 315                 @Override
 316                 public boolean checkCredentials(String username, String pwd) {
 317                     return auth.getUserName().equals(username)
 318                            &amp;&amp; new String(auth.getPassword(username)).equals(pwd);
 319                 }
 320         };
 321         ctxt.setAuthenticator(authenticator);
 322     }
 323 
 324     public static HTTPTestServer createServer(HttpProtocolType protocol,
 325                                         HttpAuthType authType,
 326                                         HttpTestAuthenticator auth,
 327                                         HttpSchemeType schemeType,
 328                                         HttpHandler delegate,
 329                                         String path)
 330             throws IOException {
 331         Objects.requireNonNull(authType);
 332         Objects.requireNonNull(auth);
 333 
 334         HttpServer impl = createHttpServer(protocol);
 335         final HTTPTestServer server = new HTTPTestServer(impl, null, delegate);
 336         final HttpHandler hh = server.createHandler(schemeType, auth, authType);
 337         HttpContext ctxt = impl.createContext(path, hh);
 338         server.configureAuthentication(ctxt, schemeType, auth, authType);
 339         impl.start();
 340         return server;
 341     }
 342 
 343     public static HTTPTestServer createProxy(HttpProtocolType protocol,
 344                                         HttpAuthType authType,
 345                                         HttpTestAuthenticator auth,
 346                                         HttpSchemeType schemeType,
 347                                         HttpHandler delegate,
 348                                         String path)
 349             throws IOException {
 350         Objects.requireNonNull(authType);
 351         Objects.requireNonNull(auth);
 352 
 353         HttpServer impl = createHttpServer(protocol);
 354         final HTTPTestServer server = protocol == HttpProtocolType.HTTPS
 355                 ? new HttpsProxyTunnel(impl, null, delegate)
 356                 : new HTTPTestServer(impl, null, delegate);
 357         final HttpHandler hh = server.createHandler(schemeType, auth, authType);
 358         HttpContext ctxt = impl.createContext(path, hh);
 359         server.configureAuthentication(ctxt, schemeType, auth, authType);
 360         impl.start();
 361 
 362         return server;
 363     }
 364 
 365     public static HTTPTestServer createServerAndRedirect(
 366                                         HttpProtocolType protocol,
 367                                         HttpAuthType targetAuthType,
 368                                         HttpTestAuthenticator auth,
 369                                         HttpSchemeType schemeType,
 370                                         HttpHandler targetDelegate,
 371                                         int code300)
 372             throws IOException {
 373         Objects.requireNonNull(targetAuthType);
 374         Objects.requireNonNull(auth);
 375 
 376         // The connection between client and proxy can only
 377         // be a plain connection: SSL connection to proxy
 378         // is not supported by our client connection.
 379         HttpProtocolType targetProtocol = targetAuthType == HttpAuthType.PROXY
 380                                           ? HttpProtocolType.HTTP
 381                                           : protocol;
 382         HTTPTestServer redirectTarget =
 383                 (targetAuthType == HttpAuthType.PROXY)
 384                 ? createProxy(protocol, targetAuthType,
 385                               auth, schemeType, targetDelegate, &quot;/&quot;)
 386                 : createServer(targetProtocol, targetAuthType,
 387                                auth, schemeType, targetDelegate, &quot;/&quot;);
 388         HttpServer impl = createHttpServer(protocol);
 389         final HTTPTestServer redirectingServer =
 390                  new HTTPTestServer(impl, redirectTarget, null);
 391         InetSocketAddress redirectAddr = redirectTarget.getAddress();
 392         URL locationURL = url(targetProtocol, redirectAddr, &quot;/&quot;);
 393         final HttpHandler hh = redirectingServer.create300Handler(locationURL,
 394                                              HttpAuthType.SERVER, code300);
 395         impl.createContext(&quot;/&quot;, hh);
 396         impl.start();
 397         return redirectingServer;
 398     }
 399 
 400     public InetSocketAddress getAddress() {
 401         return serverImpl.getAddress();
 402     }
 403 
<a name="3" id="anc3"></a><span class="line-added"> 404     public InetSocketAddress getProxyAddress() {</span>
<span class="line-added"> 405         return serverImpl.getAddress();</span>
<span class="line-added"> 406     }</span>
<span class="line-added"> 407 </span>
 408     public void stop() {
 409         serverImpl.stop(0);
 410         if (redirect != null) {
 411             redirect.stop();
 412         }
 413     }
 414 
 415     protected void writeResponse(HttpExchange he) throws IOException {
 416         if (delegate == null) {
 417             he.sendResponseHeaders(HttpURLConnection.HTTP_OK, 0);
 418             he.getResponseBody().write(he.getRequestBody().readAllBytes());
 419         } else {
 420             delegate.handle(he);
 421         }
 422     }
 423 
 424     private HttpHandler createHandler(HttpSchemeType schemeType,
 425                                       HttpTestAuthenticator auth,
 426                                       HttpAuthType authType) {
 427         return new HttpNoAuthHandler(authType);
 428     }
 429 
 430     private void configureAuthentication(HttpContext ctxt,
 431                             HttpSchemeType schemeType,
 432                             HttpTestAuthenticator auth,
 433                             HttpAuthType authType) {
 434         switch(schemeType) {
 435             case DIGEST:
 436                 // DIGEST authentication is handled by the handler.
 437                 ctxt.getFilters().add(new HttpDigestFilter(auth, authType));
 438                 break;
 439             case BASIC:
 440                 // BASIC authentication is handled by the filter.
 441                 ctxt.getFilters().add(new HttpBasicFilter(auth, authType));
 442                 break;
 443             case BASICSERVER:
 444                 switch(authType) {
 445                     case PROXY: case PROXY305:
 446                         // HttpServer can&#39;t support Proxy-type authentication
 447                         // =&gt; we do as if BASIC had been specified, and we will
 448                         //    handle authentication in the handler.
 449                         ctxt.getFilters().add(new HttpBasicFilter(auth, authType));
 450                         break;
 451                     case SERVER: case SERVER307:
 452                         // Basic authentication is handled by HttpServer
 453                         // directly =&gt; the filter should not perform
 454                         // authentication again.
 455                         setContextAuthenticator(ctxt, auth);
 456                         ctxt.getFilters().add(new HttpNoAuthFilter(authType));
 457                         break;
 458                     default:
 459                         throw new InternalError(&quot;Invalid combination scheme=&quot;
 460                              + schemeType + &quot; authType=&quot; + authType);
 461                 }
 462             case NONE:
 463                 // No authentication at all.
 464                 ctxt.getFilters().add(new HttpNoAuthFilter(authType));
 465                 break;
 466             default:
 467                 throw new InternalError(&quot;No such scheme: &quot; + schemeType);
 468         }
 469     }
 470 
 471     private HttpHandler create300Handler(URL proxyURL,
 472         HttpAuthType type, int code300) throws MalformedURLException {
 473         return new Http3xxHandler(proxyURL, type, code300);
 474     }
 475 
 476     // Abstract HTTP filter class.
 477     private abstract static class AbstractHttpFilter extends Filter {
 478 
 479         final HttpAuthType authType;
 480         final String type;
 481         public AbstractHttpFilter(HttpAuthType authType, String type) {
 482             this.authType = authType;
 483             this.type = type;
 484         }
 485 
 486         String getLocation() {
 487             return &quot;Location&quot;;
 488         }
 489         String getAuthenticate() {
 490             return authType == HttpAuthType.PROXY
 491                     ? &quot;Proxy-Authenticate&quot; : &quot;WWW-Authenticate&quot;;
 492         }
 493         String getAuthorization() {
 494             return authType == HttpAuthType.PROXY
 495                     ? &quot;Proxy-Authorization&quot; : &quot;Authorization&quot;;
 496         }
 497         int getUnauthorizedCode() {
 498             return authType == HttpAuthType.PROXY
 499                     ? HttpURLConnection.HTTP_PROXY_AUTH
 500                     : HttpURLConnection.HTTP_UNAUTHORIZED;
 501         }
 502         String getKeepAlive() {
 503             return &quot;keep-alive&quot;;
 504         }
 505         String getConnection() {
 506             return authType == HttpAuthType.PROXY
 507                     ? &quot;Proxy-Connection&quot; : &quot;Connection&quot;;
 508         }
 509         protected abstract boolean isAuthentified(HttpExchange he) throws IOException;
 510         protected abstract void requestAuthentication(HttpExchange he) throws IOException;
 511         protected void accept(HttpExchange he, Chain chain) throws IOException {
 512             chain.doFilter(he);
 513         }
 514 
 515         @Override
 516         public String description() {
 517             return &quot;Filter for &quot; + type;
 518         }
 519         @Override
 520         public void doFilter(HttpExchange he, Chain chain) throws IOException {
 521             try {
 522                 System.out.println(type + &quot;: Got &quot; + he.getRequestMethod()
 523                     + &quot;: &quot; + he.getRequestURI()
 524                     + &quot;\n&quot; + HTTPTestServer.toString(he.getRequestHeaders()));
 525                 if (!isAuthentified(he)) {
 526                     try {
 527                         requestAuthentication(he);
 528                         he.sendResponseHeaders(getUnauthorizedCode(), 0);
 529                         System.out.println(type
 530                             + &quot;: Sent back &quot; + getUnauthorizedCode());
 531                     } finally {
 532                         he.close();
 533                     }
 534                 } else {
 535                     accept(he, chain);
 536                 }
 537             } catch (RuntimeException | Error | IOException t) {
 538                System.err.println(type
 539                     + &quot;: Unexpected exception while handling request: &quot; + t);
 540                t.printStackTrace(System.err);
 541                he.close();
 542                throw t;
 543             }
 544         }
 545 
 546     }
 547 
 548     private final static class DigestResponse {
 549         final String realm;
 550         final String username;
 551         final String nonce;
 552         final String cnonce;
 553         final String nc;
 554         final String uri;
 555         final String algorithm;
 556         final String response;
 557         final String qop;
 558         final String opaque;
 559 
 560         public DigestResponse(String realm, String username, String nonce,
 561                               String cnonce, String nc, String uri,
 562                               String algorithm, String qop, String opaque,
 563                               String response) {
 564             this.realm = realm;
 565             this.username = username;
 566             this.nonce = nonce;
 567             this.cnonce = cnonce;
 568             this.nc = nc;
 569             this.uri = uri;
 570             this.algorithm = algorithm;
 571             this.qop = qop;
 572             this.opaque = opaque;
 573             this.response = response;
 574         }
 575 
 576         String getAlgorithm(String defval) {
 577             return algorithm == null ? defval : algorithm;
 578         }
 579         String getQoP(String defval) {
 580             return qop == null ? defval : qop;
 581         }
 582 
 583         // Code stolen from DigestAuthentication:
 584 
 585         private static final char charArray[] = {
 586             &#39;0&#39;, &#39;1&#39;, &#39;2&#39;, &#39;3&#39;, &#39;4&#39;, &#39;5&#39;, &#39;6&#39;, &#39;7&#39;,
 587             &#39;8&#39;, &#39;9&#39;, &#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;, &#39;e&#39;, &#39;f&#39;
 588         };
 589 
 590         private static String encode(String src, char[] passwd, MessageDigest md) {
 591             try {
 592                 md.update(src.getBytes(&quot;ISO-8859-1&quot;));
 593             } catch (java.io.UnsupportedEncodingException uee) {
 594                 assert false;
 595             }
 596             if (passwd != null) {
 597                 byte[] passwdBytes = new byte[passwd.length];
 598                 for (int i=0; i&lt;passwd.length; i++)
 599                     passwdBytes[i] = (byte)passwd[i];
 600                 md.update(passwdBytes);
 601                 Arrays.fill(passwdBytes, (byte)0x00);
 602             }
 603             byte[] digest = md.digest();
 604 
 605             StringBuilder res = new StringBuilder(digest.length * 2);
 606             for (int i = 0; i &lt; digest.length; i++) {
 607                 int hashchar = ((digest[i] &gt;&gt;&gt; 4) &amp; 0xf);
 608                 res.append(charArray[hashchar]);
 609                 hashchar = (digest[i] &amp; 0xf);
 610                 res.append(charArray[hashchar]);
 611             }
 612             return res.toString();
 613         }
 614 
 615         public static String computeDigest(boolean isRequest,
 616                                             String reqMethod,
 617                                             char[] password,
 618                                             DigestResponse params)
 619             throws NoSuchAlgorithmException
 620         {
 621 
 622             String A1, HashA1;
 623             String algorithm = params.getAlgorithm(&quot;MD5&quot;);
 624             boolean md5sess = algorithm.equalsIgnoreCase (&quot;MD5-sess&quot;);
 625 
 626             MessageDigest md = MessageDigest.getInstance(md5sess?&quot;MD5&quot;:algorithm);
 627 
 628             if (params.username == null) {
 629                 throw new IllegalArgumentException(&quot;missing username&quot;);
 630             }
 631             if (params.realm == null) {
 632                 throw new IllegalArgumentException(&quot;missing realm&quot;);
 633             }
 634             if (params.uri == null) {
 635                 throw new IllegalArgumentException(&quot;missing uri&quot;);
 636             }
 637             if (params.nonce == null) {
 638                 throw new IllegalArgumentException(&quot;missing nonce&quot;);
 639             }
 640 
 641             A1 = params.username + &quot;:&quot; + params.realm + &quot;:&quot;;
 642             HashA1 = encode(A1, password, md);
 643 
 644             String A2;
 645             if (isRequest) {
 646                 A2 = reqMethod + &quot;:&quot; + params.uri;
 647             } else {
 648                 A2 = &quot;:&quot; + params.uri;
 649             }
 650             String HashA2 = encode(A2, null, md);
 651             String combo, finalHash;
 652 
 653             if (&quot;auth&quot;.equals(params.qop)) { /* RRC2617 when qop=auth */
 654                 if (params.cnonce == null) {
 655                     throw new IllegalArgumentException(&quot;missing nonce&quot;);
 656                 }
 657                 if (params.nc == null) {
 658                     throw new IllegalArgumentException(&quot;missing nonce&quot;);
 659                 }
 660                 combo = HashA1+ &quot;:&quot; + params.nonce + &quot;:&quot; + params.nc + &quot;:&quot; +
 661                             params.cnonce + &quot;:auth:&quot; +HashA2;
 662 
 663             } else { /* for compatibility with RFC2069 */
 664                 combo = HashA1 + &quot;:&quot; +
 665                            params.nonce + &quot;:&quot; +
 666                            HashA2;
 667             }
 668             finalHash = encode(combo, null, md);
 669             return finalHash;
 670         }
 671 
 672         public static DigestResponse create(String raw) {
 673             String username, realm, nonce, nc, uri, response, cnonce,
 674                    algorithm, qop, opaque;
 675             HeaderParser parser = new HeaderParser(raw);
 676             username = parser.findValue(&quot;username&quot;);
 677             realm = parser.findValue(&quot;realm&quot;);
 678             nonce = parser.findValue(&quot;nonce&quot;);
 679             nc = parser.findValue(&quot;nc&quot;);
 680             uri = parser.findValue(&quot;uri&quot;);
 681             cnonce = parser.findValue(&quot;cnonce&quot;);
 682             response = parser.findValue(&quot;response&quot;);
 683             algorithm = parser.findValue(&quot;algorithm&quot;);
 684             qop = parser.findValue(&quot;qop&quot;);
 685             opaque = parser.findValue(&quot;opaque&quot;);
 686             return new DigestResponse(realm, username, nonce, cnonce, nc, uri,
 687                                       algorithm, qop, opaque, response);
 688         }
 689 
 690     }
 691 
 692     private class HttpNoAuthFilter extends AbstractHttpFilter {
 693 
 694         public HttpNoAuthFilter(HttpAuthType authType) {
 695             super(authType, authType == HttpAuthType.SERVER
 696                             ? &quot;NoAuth Server&quot; : &quot;NoAuth Proxy&quot;);
 697         }
 698 
 699         @Override
 700         protected boolean isAuthentified(HttpExchange he) throws IOException {
 701             return true;
 702         }
 703 
 704         @Override
 705         protected void requestAuthentication(HttpExchange he) throws IOException {
 706             throw new InternalError(&quot;Should not com here&quot;);
 707         }
 708 
 709         @Override
 710         public String description() {
 711             return &quot;Passthrough Filter&quot;;
 712         }
 713 
 714     }
 715 
 716     // An HTTP Filter that performs Basic authentication
 717     private class HttpBasicFilter extends AbstractHttpFilter {
 718 
 719         private final HttpTestAuthenticator auth;
 720         public HttpBasicFilter(HttpTestAuthenticator auth, HttpAuthType authType) {
 721             super(authType, authType == HttpAuthType.SERVER
 722                             ? &quot;Basic Server&quot; : &quot;Basic Proxy&quot;);
 723             this.auth = auth;
 724         }
 725 
 726         @Override
 727         protected void requestAuthentication(HttpExchange he)
 728             throws IOException {
 729             he.getResponseHeaders().add(getAuthenticate(),
 730                  &quot;Basic realm=\&quot;&quot; + auth.getRealm() + &quot;\&quot;&quot;);
 731             System.out.println(type + &quot;: Requesting Basic Authentication &quot;
 732                  + he.getResponseHeaders().getFirst(getAuthenticate()));
 733         }
 734 
 735         @Override
 736         protected boolean isAuthentified(HttpExchange he) {
 737             if (he.getRequestHeaders().containsKey(getAuthorization())) {
 738                 List&lt;String&gt; authorization =
 739                     he.getRequestHeaders().get(getAuthorization());
 740                 for (String a : authorization) {
 741                     System.out.println(type + &quot;: processing &quot; + a);
 742                     int sp = a.indexOf(&#39; &#39;);
 743                     if (sp &lt; 0) return false;
 744                     String scheme = a.substring(0, sp);
 745                     if (!&quot;Basic&quot;.equalsIgnoreCase(scheme)) {
 746                         System.out.println(type + &quot;: Unsupported scheme &#39;&quot;
 747                                            + scheme +&quot;&#39;&quot;);
 748                         return false;
 749                     }
 750                     if (a.length() &lt;= sp+1) {
 751                         System.out.println(type + &quot;: value too short for &#39;&quot;
 752                                             + scheme +&quot;&#39;&quot;);
 753                         return false;
 754                     }
 755                     a = a.substring(sp+1);
 756                     return validate(a);
 757                 }
 758                 return false;
 759             }
 760             return false;
 761         }
 762 
 763         boolean validate(String a) {
 764             byte[] b = Base64.getDecoder().decode(a);
 765             String userpass = new String (b);
 766             int colon = userpass.indexOf (&#39;:&#39;);
 767             String uname = userpass.substring (0, colon);
 768             String pass = userpass.substring (colon+1);
 769             return auth.getUserName().equals(uname) &amp;&amp;
 770                    new String(auth.getPassword(uname)).equals(pass);
 771         }
 772 
 773         @Override
 774         public String description() {
 775             return &quot;Filter for &quot; + type;
 776         }
 777 
 778     }
 779 
 780 
 781     // An HTTP Filter that performs Digest authentication
 782     private class HttpDigestFilter extends AbstractHttpFilter {
 783 
 784         // This is a very basic DIGEST - used only for the purpose of testing
 785         // the client implementation. Therefore we can get away with never
 786         // updating the server nonce as it makes the implementation of the
 787         // server side digest simpler.
 788         private final HttpTestAuthenticator auth;
 789         private final byte[] nonce;
 790         private final String ns;
 791         public HttpDigestFilter(HttpTestAuthenticator auth, HttpAuthType authType) {
 792             super(authType, authType == HttpAuthType.SERVER
 793                             ? &quot;Digest Server&quot; : &quot;Digest Proxy&quot;);
 794             this.auth = auth;
 795             nonce = new byte[16];
 796             new Random(Instant.now().toEpochMilli()).nextBytes(nonce);
 797             ns = new BigInteger(1, nonce).toString(16);
 798         }
 799 
 800         @Override
 801         protected void requestAuthentication(HttpExchange he)
 802             throws IOException {
 803             he.getResponseHeaders().add(getAuthenticate(),
 804                  &quot;Digest realm=\&quot;&quot; + auth.getRealm() + &quot;\&quot;,&quot;
 805                  + &quot;\r\n    qop=\&quot;auth\&quot;,&quot;
 806                  + &quot;\r\n    nonce=\&quot;&quot; + ns +&quot;\&quot;&quot;);
 807             System.out.println(type + &quot;: Requesting Digest Authentication &quot;
 808                  + he.getResponseHeaders().getFirst(getAuthenticate()));
 809         }
 810 
 811         @Override
 812         protected boolean isAuthentified(HttpExchange he) {
 813             if (he.getRequestHeaders().containsKey(getAuthorization())) {
 814                 List&lt;String&gt; authorization = he.getRequestHeaders().get(getAuthorization());
 815                 for (String a : authorization) {
 816                     System.out.println(type + &quot;: processing &quot; + a);
 817                     int sp = a.indexOf(&#39; &#39;);
 818                     if (sp &lt; 0) return false;
 819                     String scheme = a.substring(0, sp);
 820                     if (!&quot;Digest&quot;.equalsIgnoreCase(scheme)) {
 821                         System.out.println(type + &quot;: Unsupported scheme &#39;&quot; + scheme +&quot;&#39;&quot;);
 822                         return false;
 823                     }
 824                     if (a.length() &lt;= sp+1) {
 825                         System.out.println(type + &quot;: value too short for &#39;&quot; + scheme +&quot;&#39;&quot;);
 826                         return false;
 827                     }
 828                     a = a.substring(sp+1);
 829                     DigestResponse dgr = DigestResponse.create(a);
 830                     return validate(he.getRequestMethod(), dgr);
 831                 }
 832                 return false;
 833             }
 834             return false;
 835         }
 836 
 837         boolean validate(String reqMethod, DigestResponse dg) {
 838             if (!&quot;MD5&quot;.equalsIgnoreCase(dg.getAlgorithm(&quot;MD5&quot;))) {
 839                 System.out.println(type + &quot;: Unsupported algorithm &quot;
 840                                    + dg.algorithm);
 841                 return false;
 842             }
 843             if (!&quot;auth&quot;.equalsIgnoreCase(dg.getQoP(&quot;auth&quot;))) {
 844                 System.out.println(type + &quot;: Unsupported qop &quot;
 845                                    + dg.qop);
 846                 return false;
 847             }
 848             try {
 849                 if (!dg.nonce.equals(ns)) {
 850                     System.out.println(type + &quot;: bad nonce returned by client: &quot;
 851                                     + nonce + &quot; expected &quot; + ns);
 852                     return false;
 853                 }
 854                 if (dg.response == null) {
 855                     System.out.println(type + &quot;: missing digest response.&quot;);
 856                     return false;
 857                 }
 858                 char[] pa = auth.getPassword(dg.username);
 859                 return verify(reqMethod, dg, pa);
 860             } catch(IllegalArgumentException | SecurityException
 861                     | NoSuchAlgorithmException e) {
 862                 System.out.println(type + &quot;: &quot; + e.getMessage());
 863                 return false;
 864             }
 865         }
 866 
 867         boolean verify(String reqMethod, DigestResponse dg, char[] pw)
 868             throws NoSuchAlgorithmException {
 869             String response = DigestResponse.computeDigest(true, reqMethod, pw, dg);
 870             if (!dg.response.equals(response)) {
 871                 System.out.println(type + &quot;: bad response returned by client: &quot;
 872                                     + dg.response + &quot; expected &quot; + response);
 873                 return false;
 874             } else {
 875                 System.out.println(type + &quot;: verified response &quot; + response);
 876             }
 877             return true;
 878         }
 879 
 880         @Override
 881         public String description() {
 882             return &quot;Filter for DIGEST authentication&quot;;
 883         }
 884     }
 885 
 886     // Abstract HTTP handler class.
 887     private abstract static class AbstractHttpHandler implements HttpHandler {
 888 
 889         final HttpAuthType authType;
 890         final String type;
 891         public AbstractHttpHandler(HttpAuthType authType, String type) {
 892             this.authType = authType;
 893             this.type = type;
 894         }
 895 
 896         String getLocation() {
 897             return &quot;Location&quot;;
 898         }
 899 
 900         @Override
 901         public void handle(HttpExchange he) throws IOException {
 902             try {
 903                 sendResponse(he);
 904             } catch (RuntimeException | Error | IOException t) {
 905                System.err.println(type
 906                     + &quot;: Unexpected exception while handling request: &quot; + t);
 907                t.printStackTrace(System.err);
 908                throw t;
 909             } finally {
 910                 he.close();
 911             }
 912         }
 913 
 914         protected abstract void sendResponse(HttpExchange he) throws IOException;
 915 
 916     }
 917 
 918     private class HttpNoAuthHandler extends AbstractHttpHandler {
 919 
 920         public HttpNoAuthHandler(HttpAuthType authType) {
 921             super(authType, authType == HttpAuthType.SERVER
 922                             ? &quot;NoAuth Server&quot; : &quot;NoAuth Proxy&quot;);
 923         }
 924 
 925         @Override
 926         protected void sendResponse(HttpExchange he) throws IOException {
 927             HTTPTestServer.this.writeResponse(he);
 928         }
 929 
 930     }
 931 
 932     // A dummy HTTP Handler that redirects all incoming requests
 933     // by sending a back 3xx response code (301, 305, 307 etc..)
 934     private class Http3xxHandler extends AbstractHttpHandler {
 935 
 936         private final URL redirectTargetURL;
 937         private final int code3XX;
 938         public Http3xxHandler(URL proxyURL, HttpAuthType authType, int code300) {
 939             super(authType, &quot;Server&quot; + code300);
 940             this.redirectTargetURL = proxyURL;
 941             this.code3XX = code300;
 942         }
 943 
 944         int get3XX() {
 945             return code3XX;
 946         }
 947 
 948         @Override
 949         public void sendResponse(HttpExchange he) throws IOException {
 950             System.out.println(type + &quot;: Got &quot; + he.getRequestMethod()
 951                     + &quot;: &quot; + he.getRequestURI()
 952                     + &quot;\n&quot; + HTTPTestServer.toString(he.getRequestHeaders()));
 953             System.out.println(type + &quot;: Redirecting to &quot;
 954                                + (authType == HttpAuthType.PROXY305
 955                                     ? &quot;proxy&quot; : &quot;server&quot;));
 956             he.getResponseHeaders().add(getLocation(),
 957                 redirectTargetURL.toExternalForm().toString());
 958             he.sendResponseHeaders(get3XX(), 0);
 959             System.out.println(type + &quot;: Sent back &quot; + get3XX() + &quot; &quot;
 960                  + getLocation() + &quot;: &quot; + redirectTargetURL.toExternalForm().toString());
 961         }
 962     }
 963 
 964     static class Configurator extends HttpsConfigurator {
 965         public Configurator(SSLContext ctx) {
 966             super(ctx);
 967         }
 968 
 969         @Override
 970         public void configure (HttpsParameters params) {
 971             params.setSSLParameters (getSSLContext().getSupportedSSLParameters());
 972         }
 973     }
 974 
 975     // This is a bit hacky: HttpsProxyTunnel is an HTTPTestServer hidden
 976     // behind a fake proxy that only understands CONNECT requests.
 977     // The fake proxy is just a server socket that intercept the
 978     // CONNECT and then redirect streams to the real server.
 979     static class HttpsProxyTunnel extends HTTPTestServer
 980             implements Runnable {
 981 
 982         final ServerSocket ss;
<a name="4" id="anc4"></a><span class="line-added"> 983         private volatile boolean stop;</span>
<span class="line-added"> 984 </span>
 985         public HttpsProxyTunnel(HttpServer server, HTTPTestServer target,
 986                                HttpHandler delegate)
 987                 throws IOException {
 988             super(server, target, delegate);
 989             System.out.flush();
 990             System.err.println(&quot;WARNING: HttpsProxyTunnel is an experimental test class&quot;);
 991             ss = ServerSocketFactory.create();
 992             start();
 993         }
 994 
 995         final void start() throws IOException {
 996             Thread t = new Thread(this, &quot;ProxyThread&quot;);
 997             t.setDaemon(true);
 998             t.start();
 999         }
1000 
1001         @Override
1002         public void stop() {
<a name="5" id="anc5"></a><span class="line-modified">1003             try (var toClose = ss) {</span>
<span class="line-modified">1004                 stop = true;</span>
<span class="line-modified">1005                 System.out.println(&quot;Server &quot; + ss + &quot; stop requested&quot;);</span>
<span class="line-added">1006                 super.stop();</span>
1007             } catch (IOException ex) {
1008                 if (DEBUG) ex.printStackTrace(System.out);
1009             }
1010         }
1011 
1012         // Pipe the input stream to the output stream.
1013         private synchronized Thread pipe(InputStream is, OutputStream os, char tag) {
1014             return new Thread(&quot;TunnelPipe(&quot;+tag+&quot;)&quot;) {
1015                 @Override
1016                 public void run() {
1017                     try {
1018                         try {
1019                             int c;
1020                             while ((c = is.read()) != -1) {
1021                                 os.write(c);
1022                                 os.flush();
1023                                 // if DEBUG prints a + or a - for each transferred
1024                                 // character.
1025                                 if (DEBUG) System.out.print(tag);
1026                             }
1027                             is.close();
1028                         } finally {
1029                             os.close();
1030                         }
1031                     } catch (IOException ex) {
1032                         if (DEBUG) ex.printStackTrace(System.out);
1033                     }
1034                 }
1035             };
1036         }
1037 
1038         @Override
<a name="6" id="anc6"></a><span class="line-modified">1039         public InetSocketAddress getProxyAddress() {</span>
1040             return new InetSocketAddress(ss.getInetAddress(), ss.getLocalPort());
1041         }
1042 
1043         // This is a bit shaky. It doesn&#39;t handle continuation
1044         // lines, but our client shouldn&#39;t send any.
1045         // Read a line from the input stream, swallowing the final
1046         // \r\n sequence. Stops at the first \n, doesn&#39;t complain
1047         // if it wasn&#39;t preceded by &#39;\r&#39;.
1048         //
1049         String readLine(InputStream r) throws IOException {
1050             StringBuilder b = new StringBuilder();
1051             int c;
1052             while ((c = r.read()) != -1) {
1053                 if (c == &#39;\n&#39;) break;
1054                 b.appendCodePoint(c);
1055             }
<a name="7" id="anc7"></a><span class="line-added">1056             if (b.length() == 0) {</span>
<span class="line-added">1057                 return &quot;&quot;;</span>
<span class="line-added">1058             }</span>
1059             if (b.codePointAt(b.length() -1) == &#39;\r&#39;) {
1060                 b.delete(b.length() -1, b.length());
1061             }
1062             return b.toString();
1063         }
1064 
1065         @Override
1066         public void run() {
1067             Socket clientConnection = null;
<a name="8" id="anc8"></a><span class="line-modified">1068             while (!stop) {</span>
<span class="line-modified">1069                 System.out.println(&quot;Tunnel: Waiting for client at: &quot; + ss);</span>
<span class="line-modified">1070                 final Socket previous = clientConnection;</span>
<span class="line-modified">1071                 try {</span>
<span class="line-added">1072                     clientConnection = ss.accept();</span>
<span class="line-added">1073                 } catch (IOException io) {</span>
1074                     try {
<a name="9" id="anc9"></a><span class="line-modified">1075                         ss.close();</span>
<span class="line-modified">1076                     } catch (IOException ex) {</span>
<span class="line-modified">1077                         if (DEBUG) {</span>
<span class="line-modified">1078                             ex.printStackTrace(System.out);</span>
<span class="line-modified">1079                         }</span>
<span class="line-modified">1080                     }</span>
<span class="line-modified">1081                     // log the reason that caused the server to stop accepting connections</span>
<span class="line-added">1082                     if (!stop) {</span>
<span class="line-added">1083                         System.err.println(&quot;Server will stop accepting connections due to an exception:&quot;);</span>
<span class="line-added">1084                         io.printStackTrace();</span>
1085                     }
<a name="10" id="anc10"></a><span class="line-modified">1086                     break;</span>
<span class="line-modified">1087                 } finally {</span>
<span class="line-modified">1088                     // close the previous connection</span>
<span class="line-modified">1089                     if (previous != null) {</span>
<span class="line-modified">1090                         try {</span>
<span class="line-modified">1091                             previous.close();</span>
<span class="line-modified">1092                         } catch (IOException e) {</span>
<span class="line-modified">1093                             // ignore</span>
<span class="line-modified">1094                             if (DEBUG) {</span>
<span class="line-modified">1095                                 System.out.println(&quot;Ignoring exception that happened while closing &quot; +</span>
<span class="line-modified">1096                                         &quot;an older connection:&quot;);</span>
<span class="line-modified">1097                                 e.printStackTrace(System.out);</span>
<span class="line-modified">1098                             }</span>







1099                         }
<a name="11" id="anc11"></a>














1100                     }
<a name="12" id="anc12"></a>













1101                 }
<a name="13" id="anc13"></a><span class="line-modified">1102                 System.out.println(&quot;Tunnel: Client accepted&quot;);</span>
1103                 try {
<a name="14" id="anc14"></a><span class="line-modified">1104                     // We have only 1 client... process the current client</span>
<span class="line-modified">1105                     // request and wait until it has finished before</span>
<span class="line-modified">1106                     // accepting a new connection request.</span>
<span class="line-added">1107                     processRequestAndWaitToComplete(clientConnection);</span>
<span class="line-added">1108                 } catch (IOException ioe) {</span>
<span class="line-added">1109                     // close the client connection</span>
<span class="line-added">1110                     try {</span>
<span class="line-added">1111                         clientConnection.close();</span>
<span class="line-added">1112                     } catch (IOException io) {</span>
<span class="line-added">1113                         // ignore</span>
<span class="line-added">1114                         if (DEBUG) {</span>
<span class="line-added">1115                             System.out.println(&quot;Ignoring exception that happened during client&quot; +</span>
<span class="line-added">1116                                     &quot; connection close:&quot;);</span>
<span class="line-added">1117                             io.printStackTrace(System.out);</span>
<span class="line-added">1118                         }</span>
<span class="line-added">1119                     } finally {</span>
<span class="line-added">1120                         clientConnection = null;</span>
<span class="line-added">1121                     }</span>
<span class="line-added">1122                 } catch (Throwable t) {</span>
<span class="line-added">1123                     // don&#39;t close the client connection for non-IOExceptions, instead</span>
<span class="line-added">1124                     // just log it and move on to accept next connection</span>
<span class="line-added">1125                     if (!stop) {</span>
<span class="line-added">1126                         t.printStackTrace();</span>
<span class="line-added">1127                     }</span>
1128                 }
<a name="15" id="anc15"></a>
1129             }
1130         }
1131 
<a name="16" id="anc16"></a><span class="line-added">1132         private void processRequestAndWaitToComplete(final Socket clientConnection)</span>
<span class="line-added">1133                 throws IOException, InterruptedException {</span>
<span class="line-added">1134             final Socket targetConnection;</span>
<span class="line-added">1135             InputStream  ccis = clientConnection.getInputStream();</span>
<span class="line-added">1136             OutputStream ccos = clientConnection.getOutputStream();</span>
<span class="line-added">1137             Writer w = new OutputStreamWriter(</span>
<span class="line-added">1138                     clientConnection.getOutputStream(), &quot;UTF-8&quot;);</span>
<span class="line-added">1139             PrintWriter pw = new PrintWriter(w);</span>
<span class="line-added">1140             System.out.println(&quot;Tunnel: Reading request line&quot;);</span>
<span class="line-added">1141             String requestLine = readLine(ccis);</span>
<span class="line-added">1142             System.out.println(&quot;Tunnel: Request line: &quot; + requestLine);</span>
<span class="line-added">1143             if (requestLine.startsWith(&quot;CONNECT &quot;)) {</span>
<span class="line-added">1144                 // We should probably check that the next word following</span>
<span class="line-added">1145                 // CONNECT is the host:port of our HTTPS serverImpl.</span>
<span class="line-added">1146                 // Some improvement for a followup!</span>
<span class="line-added">1147 </span>
<span class="line-added">1148                 // Read all headers until we find the empty line that</span>
<span class="line-added">1149                 // signals the end of all headers.</span>
<span class="line-added">1150                 while(!requestLine.equals(&quot;&quot;)) {</span>
<span class="line-added">1151                     System.out.println(&quot;Tunnel: Reading header: &quot;</span>
<span class="line-added">1152                             + (requestLine = readLine(ccis)));</span>
<span class="line-added">1153                 }</span>
<span class="line-added">1154 </span>
<span class="line-added">1155                 targetConnection = new Socket(</span>
<span class="line-added">1156                         serverImpl.getAddress().getAddress(),</span>
<span class="line-added">1157                         serverImpl.getAddress().getPort());</span>
<span class="line-added">1158 </span>
<span class="line-added">1159                 // Then send the 200 OK response to the client</span>
<span class="line-added">1160                 System.out.println(&quot;Tunnel: Sending &quot;</span>
<span class="line-added">1161                         + &quot;HTTP/1.1 200 OK\r\n\r\n&quot;);</span>
<span class="line-added">1162                 pw.print(&quot;HTTP/1.1 200 OK\r\nContent-Length: 0\r\n\r\n&quot;);</span>
<span class="line-added">1163                 pw.flush();</span>
<span class="line-added">1164             } else {</span>
<span class="line-added">1165                 // This should not happen. If it does then consider it a</span>
<span class="line-added">1166                 // client error and throw an IOException</span>
<span class="line-added">1167                 System.out.println(&quot;Tunnel: Throwing an IOException due to unexpected&quot; +</span>
<span class="line-added">1168                         &quot; request line: &quot; + requestLine);</span>
<span class="line-added">1169                 throw new IOException(&quot;Client request error - Unexpected request line&quot;);</span>
<span class="line-added">1170             }</span>
<span class="line-added">1171 </span>
<span class="line-added">1172             // Pipe the input stream of the client connection to the</span>
<span class="line-added">1173             // output stream of the target connection and conversely.</span>
<span class="line-added">1174             // Now the client and target will just talk to each other.</span>
<span class="line-added">1175             System.out.println(&quot;Tunnel: Starting tunnel pipes&quot;);</span>
<span class="line-added">1176             Thread t1 = pipe(ccis, targetConnection.getOutputStream(), &#39;+&#39;);</span>
<span class="line-added">1177             Thread t2 = pipe(targetConnection.getInputStream(), ccos, &#39;-&#39;);</span>
<span class="line-added">1178             t1.start();</span>
<span class="line-added">1179             t2.start();</span>
<span class="line-added">1180             // wait for the request to complete</span>
<span class="line-added">1181             t1.join();</span>
<span class="line-added">1182             t2.join();</span>
<span class="line-added">1183         }</span>
1184     }
1185 }
<a name="17" id="anc17"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="17" type="hidden" />
</body>
</html>
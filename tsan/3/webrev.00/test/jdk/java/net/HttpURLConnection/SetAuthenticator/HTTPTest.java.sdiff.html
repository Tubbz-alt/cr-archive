<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff test/jdk/java/net/HttpURLConnection/SetAuthenticator/HTTPTest.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
<body>
<center><a href="HTTPSetAuthenticatorTest.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="HTTPTestServer.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>test/jdk/java/net/HttpURLConnection/SetAuthenticator/HTTPTest.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2016, 2018, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 import java.io.IOException;
 25 import java.io.UncheckedIOException;
 26 import java.net.Authenticator;
 27 import java.net.HttpURLConnection;
 28 import java.net.InetSocketAddress;
 29 import java.net.MalformedURLException;
 30 import java.net.PasswordAuthentication;
 31 import java.net.Proxy;
 32 import java.net.URL;
 33 import java.util.Locale;
 34 import java.util.concurrent.atomic.AtomicInteger;
 35 import java.util.logging.Level;
 36 import java.util.logging.Logger;
 37 import java.util.stream.Stream;
 38 import javax.net.ssl.HostnameVerifier;
 39 import javax.net.ssl.HttpsURLConnection;
 40 import javax.net.ssl.SSLContext;
 41 import javax.net.ssl.SSLSession;
 42 import jdk.test.lib.net.SimpleSSLContext;

 43 
 44 /*
 45  * @test
 46  * @bug 8169415
 47  * @library /test/lib
 48  * @modules java.logging
 49  *          java.base/sun.net.www
 50  *          jdk.httpserver/sun.net.httpserver
 51  * @build jdk.test.lib.net.SimpleSSLContext HTTPTest HTTPTestServer HTTPTestClient
 52  * @summary A simple HTTP test that starts an echo server supporting Digest
 53  *          authentication, then starts a regular HTTP client to invoke it.
 54  *          The client first does a GET request on &quot;/&quot;, then follows on
 55  *          with a POST request that sends &quot;Hello World!&quot; to the server.
 56  *          The client expects to receive &quot;Hello World!&quot; in return.
 57  *          The test supports several execution modes:
 58  *            SERVER: The server performs Digest Server authentication;
 59  *            PROXY:  The server pretends to be a proxy and performs
 60  *                    Digest Proxy authentication;
 61  *            SERVER307: The server redirects the client (307) to another
 62  *                    server that perform Digest authentication;
</pre>
<hr />
<pre>
 72 public class HTTPTest {
 73 
 74     public static final boolean DEBUG =
 75          Boolean.parseBoolean(System.getProperty(&quot;test.debug&quot;, &quot;false&quot;));
 76     public static enum HttpAuthType { SERVER, PROXY, SERVER307, PROXY305 };
 77     public static enum HttpProtocolType { HTTP, HTTPS };
 78     public static enum HttpSchemeType { NONE, BASICSERVER, BASIC, DIGEST };
 79     public static final HttpAuthType DEFAULT_HTTP_AUTH_TYPE = HttpAuthType.SERVER;
 80     public static final HttpProtocolType DEFAULT_PROTOCOL_TYPE = HttpProtocolType.HTTP;
 81     public static final HttpSchemeType DEFAULT_SCHEME_TYPE = HttpSchemeType.DIGEST;
 82 
 83     public static class HttpTestAuthenticator extends Authenticator {
 84         private final String realm;
 85         private final String username;
 86         // Used to prevent incrementation of &#39;count&#39; when calling the
 87         // authenticator from the server side.
 88         private final ThreadLocal&lt;Boolean&gt; skipCount = new ThreadLocal&lt;&gt;();
 89         // count will be incremented every time getPasswordAuthentication()
 90         // is called from the client side.
 91         final AtomicInteger count = new AtomicInteger();

 92 
<span class="line-modified"> 93         public HttpTestAuthenticator(String realm, String username) {</span>

 94             this.realm = realm;
 95             this.username = username;
 96         }
 97 
 98         @Override
 99         protected PasswordAuthentication getPasswordAuthentication() {
100             if (skipCount.get() == null || skipCount.get().booleanValue() == false) {
<span class="line-modified">101                 System.out.println(&quot;Authenticator called: &quot; + count.incrementAndGet());</span>
102             }
103             return new PasswordAuthentication(getUserName(),
104                     new char[] {&#39;b&#39;,&#39;a&#39;,&#39;r&#39;});
105         }
106 
107         // Called by the server side to get the password of the user
108         // being authentified.
109         public final char[] getPassword(String user) {
110             if (user.equals(username)) {
111                 skipCount.set(Boolean.TRUE);
112                 try {
113                     return getPasswordAuthentication().getPassword();
114                 } finally {
115                     skipCount.set(Boolean.FALSE);
116                 }
117             }
118             throw new SecurityException(&quot;User unknown: &quot; + user);
119         }
120 





121         public final String getUserName() {
122             return username;
123         }
124         public final String getRealm() {
125             return realm;
126         }
127 
128     }
129     public static final HttpTestAuthenticator AUTHENTICATOR;
130     static {
<span class="line-modified">131         AUTHENTICATOR = new HttpTestAuthenticator(&quot;dublin&quot;, &quot;foox&quot;);</span>
132         Authenticator.setDefault(AUTHENTICATOR);
133     }
134 
135     static {
136         try {
137             HttpsURLConnection.setDefaultHostnameVerifier(new HostnameVerifier() {
138                 public boolean verify(String hostname, SSLSession session) {
139                     return true;
140                 }
141             });
142             SSLContext.setDefault(new SimpleSSLContext().get());
143         } catch (IOException ex) {
144             throw new ExceptionInInitializerError(ex);
145         }
146     }
147 
148     static final Logger logger = Logger.getLogger (&quot;com.sun.net.httpserver&quot;);
149     static {
150         if (DEBUG) logger.setLevel(Level.ALL);
151         Stream.of(Logger.getLogger(&quot;&quot;).getHandlers())
</pre>
<hr />
<pre>
241         switch(count) {
242             case 0: return &quot;not even once&quot;;
243             case 1: return &quot;once&quot;;
244             case 2: return &quot;twice&quot;;
245             default: return String.valueOf(count) + &quot; times&quot;;
246         }
247     }
248 
249     public static String expected(int count) {
250         switch(count) {
251             default: return count(count);
252         }
253     }
254     public static String protocol(HttpProtocolType type) {
255         return type.name().toLowerCase(Locale.US);
256     }
257 
258     public static URL url(HttpProtocolType protocol, InetSocketAddress address,
259                           String path) throws MalformedURLException {
260         return new URL(protocol(protocol),
<span class="line-modified">261                        address.getHostString(),</span>
262                        address.getPort(), path);
263     }
264 
265     public static Proxy proxy(HTTPTestServer server, HttpAuthType authType) {
<span class="line-modified">266         return (authType == HttpAuthType.PROXY)</span>
<span class="line-modified">267                ? new Proxy(Proxy.Type.HTTP, server.getAddress())</span>
<span class="line-modified">268                : null;</span>













269     }
270 
271     public static HttpURLConnection openConnection(URL url,
272                                                    HttpAuthType authType,
273                                                    Proxy proxy)
274                                     throws IOException {
275 
276         HttpURLConnection conn = (HttpURLConnection)
277                 (authType == HttpAuthType.PROXY
278                     ? url.openConnection(proxy)
<span class="line-modified">279                     : url.openConnection());</span>
280         return conn;
281     }
282 }
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2016, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 import java.io.IOException;
 25 import java.io.UncheckedIOException;
 26 import java.net.Authenticator;
 27 import java.net.HttpURLConnection;
 28 import java.net.InetSocketAddress;
 29 import java.net.MalformedURLException;
 30 import java.net.PasswordAuthentication;
 31 import java.net.Proxy;
 32 import java.net.URL;
 33 import java.util.Locale;
 34 import java.util.concurrent.atomic.AtomicInteger;
 35 import java.util.logging.Level;
 36 import java.util.logging.Logger;
 37 import java.util.stream.Stream;
 38 import javax.net.ssl.HostnameVerifier;
 39 import javax.net.ssl.HttpsURLConnection;
 40 import javax.net.ssl.SSLContext;
 41 import javax.net.ssl.SSLSession;
 42 import jdk.test.lib.net.SimpleSSLContext;
<span class="line-added"> 43 import static java.net.Proxy.NO_PROXY;</span>
 44 
 45 /*
 46  * @test
 47  * @bug 8169415
 48  * @library /test/lib
 49  * @modules java.logging
 50  *          java.base/sun.net.www
 51  *          jdk.httpserver/sun.net.httpserver
 52  * @build jdk.test.lib.net.SimpleSSLContext HTTPTest HTTPTestServer HTTPTestClient
 53  * @summary A simple HTTP test that starts an echo server supporting Digest
 54  *          authentication, then starts a regular HTTP client to invoke it.
 55  *          The client first does a GET request on &quot;/&quot;, then follows on
 56  *          with a POST request that sends &quot;Hello World!&quot; to the server.
 57  *          The client expects to receive &quot;Hello World!&quot; in return.
 58  *          The test supports several execution modes:
 59  *            SERVER: The server performs Digest Server authentication;
 60  *            PROXY:  The server pretends to be a proxy and performs
 61  *                    Digest Proxy authentication;
 62  *            SERVER307: The server redirects the client (307) to another
 63  *                    server that perform Digest authentication;
</pre>
<hr />
<pre>
 73 public class HTTPTest {
 74 
 75     public static final boolean DEBUG =
 76          Boolean.parseBoolean(System.getProperty(&quot;test.debug&quot;, &quot;false&quot;));
 77     public static enum HttpAuthType { SERVER, PROXY, SERVER307, PROXY305 };
 78     public static enum HttpProtocolType { HTTP, HTTPS };
 79     public static enum HttpSchemeType { NONE, BASICSERVER, BASIC, DIGEST };
 80     public static final HttpAuthType DEFAULT_HTTP_AUTH_TYPE = HttpAuthType.SERVER;
 81     public static final HttpProtocolType DEFAULT_PROTOCOL_TYPE = HttpProtocolType.HTTP;
 82     public static final HttpSchemeType DEFAULT_SCHEME_TYPE = HttpSchemeType.DIGEST;
 83 
 84     public static class HttpTestAuthenticator extends Authenticator {
 85         private final String realm;
 86         private final String username;
 87         // Used to prevent incrementation of &#39;count&#39; when calling the
 88         // authenticator from the server side.
 89         private final ThreadLocal&lt;Boolean&gt; skipCount = new ThreadLocal&lt;&gt;();
 90         // count will be incremented every time getPasswordAuthentication()
 91         // is called from the client side.
 92         final AtomicInteger count = new AtomicInteger();
<span class="line-added"> 93         private final String name;</span>
 94 
<span class="line-modified"> 95         public HttpTestAuthenticator(String name, String realm, String username) {</span>
<span class="line-added"> 96             this.name = name;</span>
 97             this.realm = realm;
 98             this.username = username;
 99         }
100 
101         @Override
102         protected PasswordAuthentication getPasswordAuthentication() {
103             if (skipCount.get() == null || skipCount.get().booleanValue() == false) {
<span class="line-modified">104                 System.out.println(&quot;Authenticator &quot; + name + &quot; called: &quot; + count.incrementAndGet());</span>
105             }
106             return new PasswordAuthentication(getUserName(),
107                     new char[] {&#39;b&#39;,&#39;a&#39;,&#39;r&#39;});
108         }
109 
110         // Called by the server side to get the password of the user
111         // being authentified.
112         public final char[] getPassword(String user) {
113             if (user.equals(username)) {
114                 skipCount.set(Boolean.TRUE);
115                 try {
116                     return getPasswordAuthentication().getPassword();
117                 } finally {
118                     skipCount.set(Boolean.FALSE);
119                 }
120             }
121             throw new SecurityException(&quot;User unknown: &quot; + user);
122         }
123 
<span class="line-added">124         @Override</span>
<span class="line-added">125         public String toString() {</span>
<span class="line-added">126             return super.toString() + &quot;[name=\&quot;&quot; + name + &quot;\&quot;]&quot;;</span>
<span class="line-added">127         }</span>
<span class="line-added">128 </span>
129         public final String getUserName() {
130             return username;
131         }
132         public final String getRealm() {
133             return realm;
134         }
135 
136     }
137     public static final HttpTestAuthenticator AUTHENTICATOR;
138     static {
<span class="line-modified">139         AUTHENTICATOR = new HttpTestAuthenticator(&quot;AUTHENTICATOR&quot;,&quot;dublin&quot;, &quot;foox&quot;);</span>
140         Authenticator.setDefault(AUTHENTICATOR);
141     }
142 
143     static {
144         try {
145             HttpsURLConnection.setDefaultHostnameVerifier(new HostnameVerifier() {
146                 public boolean verify(String hostname, SSLSession session) {
147                     return true;
148                 }
149             });
150             SSLContext.setDefault(new SimpleSSLContext().get());
151         } catch (IOException ex) {
152             throw new ExceptionInInitializerError(ex);
153         }
154     }
155 
156     static final Logger logger = Logger.getLogger (&quot;com.sun.net.httpserver&quot;);
157     static {
158         if (DEBUG) logger.setLevel(Level.ALL);
159         Stream.of(Logger.getLogger(&quot;&quot;).getHandlers())
</pre>
<hr />
<pre>
249         switch(count) {
250             case 0: return &quot;not even once&quot;;
251             case 1: return &quot;once&quot;;
252             case 2: return &quot;twice&quot;;
253             default: return String.valueOf(count) + &quot; times&quot;;
254         }
255     }
256 
257     public static String expected(int count) {
258         switch(count) {
259             default: return count(count);
260         }
261     }
262     public static String protocol(HttpProtocolType type) {
263         return type.name().toLowerCase(Locale.US);
264     }
265 
266     public static URL url(HttpProtocolType protocol, InetSocketAddress address,
267                           String path) throws MalformedURLException {
268         return new URL(protocol(protocol),
<span class="line-modified">269                        address.getAddress().getHostAddress(),</span>
270                        address.getPort(), path);
271     }
272 
273     public static Proxy proxy(HTTPTestServer server, HttpAuthType authType) {
<span class="line-modified">274         if (authType != HttpAuthType.PROXY) return null;</span>
<span class="line-modified">275 </span>
<span class="line-modified">276         InetSocketAddress proxyAddress = server.getProxyAddress();</span>
<span class="line-added">277         if (!proxyAddress.isUnresolved()) {</span>
<span class="line-added">278             // Forces the proxy to use an unresolved address created</span>
<span class="line-added">279             // from the actual IP address to avoid using the proxy</span>
<span class="line-added">280             // address hostname which would result in resolving to</span>
<span class="line-added">281             // a posibly different address. For instance we want to</span>
<span class="line-added">282             // avoid cases such as:</span>
<span class="line-added">283             //    ::1 =&gt; &quot;localhost&quot; =&gt; 127.0.0.1</span>
<span class="line-added">284             proxyAddress = InetSocketAddress.</span>
<span class="line-added">285                 createUnresolved(proxyAddress.getAddress().getHostAddress(),</span>
<span class="line-added">286                                  proxyAddress.getPort());</span>
<span class="line-added">287         }</span>
<span class="line-added">288 </span>
<span class="line-added">289         return new Proxy(Proxy.Type.HTTP, proxyAddress);</span>
290     }
291 
292     public static HttpURLConnection openConnection(URL url,
293                                                    HttpAuthType authType,
294                                                    Proxy proxy)
295                                     throws IOException {
296 
297         HttpURLConnection conn = (HttpURLConnection)
298                 (authType == HttpAuthType.PROXY
299                     ? url.openConnection(proxy)
<span class="line-modified">300                     : url.openConnection(NO_PROXY));</span>
301         return conn;
302     }
303 }
</pre>
</td>
</tr>
</table>
<center><a href="HTTPSetAuthenticatorTest.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="HTTPTestServer.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
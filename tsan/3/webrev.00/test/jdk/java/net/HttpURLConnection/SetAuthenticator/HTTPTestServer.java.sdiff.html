<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff test/jdk/java/net/HttpURLConnection/SetAuthenticator/HTTPTestServer.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
<body>
<center><a href="HTTPTest.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="../UnmodifiableMaps.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>test/jdk/java/net/HttpURLConnection/SetAuthenticator/HTTPTestServer.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 148 
 149     /**
 150      * The SocketBindableFactory ensures that the local port used by an HttpServer
 151      * or a proxy ServerSocket previously created by the current test/VM will not
 152      * get reused by a subsequent test in the same VM. This is to avoid having the
 153      * AuthCache reuse credentials from previous tests - which would invalidate the
 154      * assumptions made by the current test on when the default authenticator should
 155      * be called.
 156      */
 157     private static abstract class SocketBindableFactory&lt;B&gt; {
 158         private static final int MAX = 10;
 159         private static final CopyOnWriteArrayList&lt;String&gt; addresses =
 160             new CopyOnWriteArrayList&lt;&gt;();
 161         protected B createInternal() throws IOException {
 162             final int max = addresses.size() + MAX;
 163             final List&lt;B&gt; toClose = new ArrayList&lt;&gt;();
 164             try {
 165                 for (int i = 1; i &lt;= max; i++) {
 166                     B bindable = createBindable();
 167                     SocketAddress address = getAddress(bindable);
<span class="line-modified"> 168                     String key = address.toString();</span>
 169                     if (addresses.addIfAbsent(key)) {
 170                        System.out.println(&quot;Socket bound to: &quot; + key
 171                                           + &quot; after &quot; + i + &quot; attempt(s)&quot;);
 172                        return bindable;
 173                     }
 174                     System.out.println(&quot;warning: address &quot; + key
 175                                        + &quot; already used. Retrying bind.&quot;);
 176                     // keep the port bound until we get a port that we haven&#39;t
 177                     // used already
 178                     toClose.add(bindable);
 179                 }
 180             } finally {
 181                 // if we had to retry, then close the socket we&#39;re not
 182                 // going to use.
 183                 for (B b : toClose) {
 184                   try { close(b); } catch (Exception x) { /* ignore */ }
 185                 }
 186             }
 187             throw new IOException(&quot;Couldn&#39;t bind socket after &quot; + max + &quot; attempts: &quot;
 188                                   + &quot;addresses used before: &quot; + addresses);
 189         }
 190 










 191         protected abstract B createBindable() throws IOException;
 192 
 193         protected abstract SocketAddress getAddress(B bindable);
 194 
 195         protected abstract void close(B bindable) throws IOException;
 196     }
 197 
 198     /*
 199      * Used to create ServerSocket for a proxy.
 200      */
 201     private static final class ServerSocketFactory
 202             extends SocketBindableFactory&lt;ServerSocket&gt; {
 203         private static final ServerSocketFactory instance = new ServerSocketFactory();
 204 
 205         static ServerSocket create() throws IOException {
 206             return instance.createInternal();
 207         }
 208 
 209         @Override
 210         protected ServerSocket createBindable() throws IOException {
</pre>
<hr />
<pre>
 374                 ? createProxy(protocol, targetAuthType,
 375                               auth, schemeType, targetDelegate, &quot;/&quot;)
 376                 : createServer(targetProtocol, targetAuthType,
 377                                auth, schemeType, targetDelegate, &quot;/&quot;);
 378         HttpServer impl = createHttpServer(protocol);
 379         final HTTPTestServer redirectingServer =
 380                  new HTTPTestServer(impl, redirectTarget, null);
 381         InetSocketAddress redirectAddr = redirectTarget.getAddress();
 382         URL locationURL = url(targetProtocol, redirectAddr, &quot;/&quot;);
 383         final HttpHandler hh = redirectingServer.create300Handler(locationURL,
 384                                              HttpAuthType.SERVER, code300);
 385         impl.createContext(&quot;/&quot;, hh);
 386         impl.start();
 387         return redirectingServer;
 388     }
 389 
 390     public InetSocketAddress getAddress() {
 391         return serverImpl.getAddress();
 392     }
 393 




 394     public void stop() {
 395         serverImpl.stop(0);
 396         if (redirect != null) {
 397             redirect.stop();
 398         }
 399     }
 400 
 401     protected void writeResponse(HttpExchange he) throws IOException {
 402         if (delegate == null) {
 403             he.sendResponseHeaders(HttpURLConnection.HTTP_OK, 0);
 404             he.getResponseBody().write(he.getRequestBody().readAllBytes());
 405         } else {
 406             delegate.handle(he);
 407         }
 408     }
 409 
 410     private HttpHandler createHandler(HttpSchemeType schemeType,
 411                                       HttpTestAuthenticator auth,
 412                                       HttpAuthType authType) {
 413         return new HttpNoAuthHandler(authType);
</pre>
<hr />
<pre>
 949 
 950     static class Configurator extends HttpsConfigurator {
 951         public Configurator(SSLContext ctx) {
 952             super(ctx);
 953         }
 954 
 955         @Override
 956         public void configure (HttpsParameters params) {
 957             params.setSSLParameters (getSSLContext().getSupportedSSLParameters());
 958         }
 959     }
 960 
 961     // This is a bit hacky: HttpsProxyTunnel is an HTTPTestServer hidden
 962     // behind a fake proxy that only understands CONNECT requests.
 963     // The fake proxy is just a server socket that intercept the
 964     // CONNECT and then redirect streams to the real server.
 965     static class HttpsProxyTunnel extends HTTPTestServer
 966             implements Runnable {
 967 
 968         final ServerSocket ss;


 969         public HttpsProxyTunnel(HttpServer server, HTTPTestServer target,
 970                                HttpHandler delegate)
 971                 throws IOException {
 972             super(server, target, delegate);
 973             System.out.flush();
 974             System.err.println(&quot;WARNING: HttpsProxyTunnel is an experimental test class&quot;);
 975             ss = ServerSocketFactory.create();
 976             start();
 977         }
 978 
 979         final void start() throws IOException {
 980             Thread t = new Thread(this, &quot;ProxyThread&quot;);
 981             t.setDaemon(true);
 982             t.start();
 983         }
 984 
 985         @Override
 986         public void stop() {
<span class="line-modified"> 987             super.stop();</span>
<span class="line-modified"> 988             try {</span>
<span class="line-modified"> 989                 ss.close();</span>

 990             } catch (IOException ex) {
 991                 if (DEBUG) ex.printStackTrace(System.out);
 992             }
 993         }
 994 
 995         // Pipe the input stream to the output stream.
 996         private synchronized Thread pipe(InputStream is, OutputStream os, char tag) {
 997             return new Thread(&quot;TunnelPipe(&quot;+tag+&quot;)&quot;) {
 998                 @Override
 999                 public void run() {
1000                     try {
1001                         try {
1002                             int c;
1003                             while ((c = is.read()) != -1) {
1004                                 os.write(c);
1005                                 os.flush();
1006                                 // if DEBUG prints a + or a - for each transferred
1007                                 // character.
1008                                 if (DEBUG) System.out.print(tag);
1009                             }
1010                             is.close();
1011                         } finally {
1012                             os.close();
1013                         }
1014                     } catch (IOException ex) {
1015                         if (DEBUG) ex.printStackTrace(System.out);
1016                     }
1017                 }
1018             };
1019         }
1020 
1021         @Override
<span class="line-modified">1022         public InetSocketAddress getAddress() {</span>
1023             return new InetSocketAddress(ss.getInetAddress(), ss.getLocalPort());
1024         }
1025 
1026         // This is a bit shaky. It doesn&#39;t handle continuation
1027         // lines, but our client shouldn&#39;t send any.
1028         // Read a line from the input stream, swallowing the final
1029         // \r\n sequence. Stops at the first \n, doesn&#39;t complain
1030         // if it wasn&#39;t preceded by &#39;\r&#39;.
1031         //
1032         String readLine(InputStream r) throws IOException {
1033             StringBuilder b = new StringBuilder();
1034             int c;
1035             while ((c = r.read()) != -1) {
1036                 if (c == &#39;\n&#39;) break;
1037                 b.appendCodePoint(c);
1038             }



1039             if (b.codePointAt(b.length() -1) == &#39;\r&#39;) {
1040                 b.delete(b.length() -1, b.length());
1041             }
1042             return b.toString();
1043         }
1044 
1045         @Override
1046         public void run() {
1047             Socket clientConnection = null;
<span class="line-modified">1048             try {</span>
<span class="line-modified">1049                 while (true) {</span>
<span class="line-modified">1050                     System.out.println(&quot;Tunnel: Waiting for client&quot;);</span>
<span class="line-modified">1051                     Socket previous = clientConnection;</span>


1052                     try {
<span class="line-modified">1053                         clientConnection = ss.accept();</span>
<span class="line-modified">1054                     } catch (IOException io) {</span>
<span class="line-modified">1055                         if (DEBUG) io.printStackTrace(System.out);</span>
<span class="line-modified">1056                         break;</span>
<span class="line-modified">1057                     } finally {</span>
<span class="line-modified">1058                         // close the previous connection</span>
<span class="line-modified">1059                         if (previous != null) previous.close();</span>



1060                     }
<span class="line-modified">1061                     System.out.println(&quot;Tunnel: Client accepted&quot;);</span>
<span class="line-modified">1062                     Socket targetConnection = null;</span>
<span class="line-modified">1063                     InputStream  ccis = clientConnection.getInputStream();</span>
<span class="line-modified">1064                     OutputStream ccos = clientConnection.getOutputStream();</span>
<span class="line-modified">1065                     Writer w = new OutputStreamWriter(</span>
<span class="line-modified">1066                                    clientConnection.getOutputStream(), &quot;UTF-8&quot;);</span>
<span class="line-modified">1067                     PrintWriter pw = new PrintWriter(w);</span>
<span class="line-modified">1068                     System.out.println(&quot;Tunnel: Reading request line&quot;);</span>
<span class="line-modified">1069                     String requestLine = readLine(ccis);</span>
<span class="line-modified">1070                     System.out.println(&quot;Tunnel: Request line: &quot; + requestLine);</span>
<span class="line-modified">1071                     if (requestLine.startsWith(&quot;CONNECT &quot;)) {</span>
<span class="line-modified">1072                         // We should probably check that the next word following</span>
<span class="line-modified">1073                         // CONNECT is the host:port of our HTTPS serverImpl.</span>
<span class="line-removed">1074                         // Some improvement for a followup!</span>
<span class="line-removed">1075 </span>
<span class="line-removed">1076                         // Read all headers until we find the empty line that</span>
<span class="line-removed">1077                         // signals the end of all headers.</span>
<span class="line-removed">1078                         while(!requestLine.equals(&quot;&quot;)) {</span>
<span class="line-removed">1079                             System.out.println(&quot;Tunnel: Reading header: &quot;</span>
<span class="line-removed">1080                                                + (requestLine = readLine(ccis)));</span>
1081                         }
<span class="line-removed">1082 </span>
<span class="line-removed">1083                         targetConnection = new Socket(</span>
<span class="line-removed">1084                                 serverImpl.getAddress().getAddress(),</span>
<span class="line-removed">1085                                 serverImpl.getAddress().getPort());</span>
<span class="line-removed">1086 </span>
<span class="line-removed">1087                         // Then send the 200 OK response to the client</span>
<span class="line-removed">1088                         System.out.println(&quot;Tunnel: Sending &quot;</span>
<span class="line-removed">1089                                            + &quot;HTTP/1.1 200 OK\r\n\r\n&quot;);</span>
<span class="line-removed">1090                         pw.print(&quot;HTTP/1.1 200 OK\r\nContent-Length: 0\r\n\r\n&quot;);</span>
<span class="line-removed">1091                         pw.flush();</span>
<span class="line-removed">1092                     } else {</span>
<span class="line-removed">1093                         // This should not happen. If it does let our serverImpl</span>
<span class="line-removed">1094                         // deal with it.</span>
<span class="line-removed">1095                         throw new IOException(&quot;Tunnel: Unexpected status line: &quot;</span>
<span class="line-removed">1096                                              + requestLine);</span>
1097                     }
<span class="line-removed">1098 </span>
<span class="line-removed">1099                     // Pipe the input stream of the client connection to the</span>
<span class="line-removed">1100                     // output stream of the target connection and conversely.</span>
<span class="line-removed">1101                     // Now the client and target will just talk to each other.</span>
<span class="line-removed">1102                     System.out.println(&quot;Tunnel: Starting tunnel pipes&quot;);</span>
<span class="line-removed">1103                     Thread t1 = pipe(ccis, targetConnection.getOutputStream(), &#39;+&#39;);</span>
<span class="line-removed">1104                     Thread t2 = pipe(targetConnection.getInputStream(), ccos, &#39;-&#39;);</span>
<span class="line-removed">1105                     t1.start();</span>
<span class="line-removed">1106                     t2.start();</span>
<span class="line-removed">1107 </span>
<span class="line-removed">1108                     // We have only 1 client... wait until it has finished before</span>
<span class="line-removed">1109                     // accepting a new connection request.</span>
<span class="line-removed">1110                     t1.join();</span>
<span class="line-removed">1111                     t2.join();</span>
1112                 }
<span class="line-modified">1113             } catch (Throwable ex) {</span>
1114                 try {
<span class="line-modified">1115                     ss.close();</span>
<span class="line-modified">1116                 } catch (IOException ex1) {</span>
<span class="line-modified">1117                     ex.addSuppressed(ex1);</span>





















1118                 }
<span class="line-removed">1119                 ex.printStackTrace(System.err);</span>
1120             }
1121         }
1122 




















































1123     }
1124 }
</pre>
</td>
<td>
<hr />
<pre>
 148 
 149     /**
 150      * The SocketBindableFactory ensures that the local port used by an HttpServer
 151      * or a proxy ServerSocket previously created by the current test/VM will not
 152      * get reused by a subsequent test in the same VM. This is to avoid having the
 153      * AuthCache reuse credentials from previous tests - which would invalidate the
 154      * assumptions made by the current test on when the default authenticator should
 155      * be called.
 156      */
 157     private static abstract class SocketBindableFactory&lt;B&gt; {
 158         private static final int MAX = 10;
 159         private static final CopyOnWriteArrayList&lt;String&gt; addresses =
 160             new CopyOnWriteArrayList&lt;&gt;();
 161         protected B createInternal() throws IOException {
 162             final int max = addresses.size() + MAX;
 163             final List&lt;B&gt; toClose = new ArrayList&lt;&gt;();
 164             try {
 165                 for (int i = 1; i &lt;= max; i++) {
 166                     B bindable = createBindable();
 167                     SocketAddress address = getAddress(bindable);
<span class="line-modified"> 168                     String key = toString(address);</span>
 169                     if (addresses.addIfAbsent(key)) {
 170                        System.out.println(&quot;Socket bound to: &quot; + key
 171                                           + &quot; after &quot; + i + &quot; attempt(s)&quot;);
 172                        return bindable;
 173                     }
 174                     System.out.println(&quot;warning: address &quot; + key
 175                                        + &quot; already used. Retrying bind.&quot;);
 176                     // keep the port bound until we get a port that we haven&#39;t
 177                     // used already
 178                     toClose.add(bindable);
 179                 }
 180             } finally {
 181                 // if we had to retry, then close the socket we&#39;re not
 182                 // going to use.
 183                 for (B b : toClose) {
 184                   try { close(b); } catch (Exception x) { /* ignore */ }
 185                 }
 186             }
 187             throw new IOException(&quot;Couldn&#39;t bind socket after &quot; + max + &quot; attempts: &quot;
 188                                   + &quot;addresses used before: &quot; + addresses);
 189         }
 190 
<span class="line-added"> 191         private static String toString(SocketAddress address) {</span>
<span class="line-added"> 192             // We don&#39;t rely on address.toString(): sometimes it can be</span>
<span class="line-added"> 193             // &quot;/127.0.0.1:port&quot;, sometimes it can be &quot;localhost/127.0.0.1:port&quot;</span>
<span class="line-added"> 194             // Instead we compose our own string representation:</span>
<span class="line-added"> 195             InetSocketAddress candidate = (InetSocketAddress) address;</span>
<span class="line-added"> 196             String hostAddr = candidate.getAddress().getHostAddress();</span>
<span class="line-added"> 197             if (hostAddr.contains(&quot;:&quot;)) hostAddr = &quot;[&quot; + hostAddr + &quot;]&quot;;</span>
<span class="line-added"> 198             return hostAddr + &quot;:&quot; + candidate.getPort();</span>
<span class="line-added"> 199         }</span>
<span class="line-added"> 200 </span>
 201         protected abstract B createBindable() throws IOException;
 202 
 203         protected abstract SocketAddress getAddress(B bindable);
 204 
 205         protected abstract void close(B bindable) throws IOException;
 206     }
 207 
 208     /*
 209      * Used to create ServerSocket for a proxy.
 210      */
 211     private static final class ServerSocketFactory
 212             extends SocketBindableFactory&lt;ServerSocket&gt; {
 213         private static final ServerSocketFactory instance = new ServerSocketFactory();
 214 
 215         static ServerSocket create() throws IOException {
 216             return instance.createInternal();
 217         }
 218 
 219         @Override
 220         protected ServerSocket createBindable() throws IOException {
</pre>
<hr />
<pre>
 384                 ? createProxy(protocol, targetAuthType,
 385                               auth, schemeType, targetDelegate, &quot;/&quot;)
 386                 : createServer(targetProtocol, targetAuthType,
 387                                auth, schemeType, targetDelegate, &quot;/&quot;);
 388         HttpServer impl = createHttpServer(protocol);
 389         final HTTPTestServer redirectingServer =
 390                  new HTTPTestServer(impl, redirectTarget, null);
 391         InetSocketAddress redirectAddr = redirectTarget.getAddress();
 392         URL locationURL = url(targetProtocol, redirectAddr, &quot;/&quot;);
 393         final HttpHandler hh = redirectingServer.create300Handler(locationURL,
 394                                              HttpAuthType.SERVER, code300);
 395         impl.createContext(&quot;/&quot;, hh);
 396         impl.start();
 397         return redirectingServer;
 398     }
 399 
 400     public InetSocketAddress getAddress() {
 401         return serverImpl.getAddress();
 402     }
 403 
<span class="line-added"> 404     public InetSocketAddress getProxyAddress() {</span>
<span class="line-added"> 405         return serverImpl.getAddress();</span>
<span class="line-added"> 406     }</span>
<span class="line-added"> 407 </span>
 408     public void stop() {
 409         serverImpl.stop(0);
 410         if (redirect != null) {
 411             redirect.stop();
 412         }
 413     }
 414 
 415     protected void writeResponse(HttpExchange he) throws IOException {
 416         if (delegate == null) {
 417             he.sendResponseHeaders(HttpURLConnection.HTTP_OK, 0);
 418             he.getResponseBody().write(he.getRequestBody().readAllBytes());
 419         } else {
 420             delegate.handle(he);
 421         }
 422     }
 423 
 424     private HttpHandler createHandler(HttpSchemeType schemeType,
 425                                       HttpTestAuthenticator auth,
 426                                       HttpAuthType authType) {
 427         return new HttpNoAuthHandler(authType);
</pre>
<hr />
<pre>
 963 
 964     static class Configurator extends HttpsConfigurator {
 965         public Configurator(SSLContext ctx) {
 966             super(ctx);
 967         }
 968 
 969         @Override
 970         public void configure (HttpsParameters params) {
 971             params.setSSLParameters (getSSLContext().getSupportedSSLParameters());
 972         }
 973     }
 974 
 975     // This is a bit hacky: HttpsProxyTunnel is an HTTPTestServer hidden
 976     // behind a fake proxy that only understands CONNECT requests.
 977     // The fake proxy is just a server socket that intercept the
 978     // CONNECT and then redirect streams to the real server.
 979     static class HttpsProxyTunnel extends HTTPTestServer
 980             implements Runnable {
 981 
 982         final ServerSocket ss;
<span class="line-added"> 983         private volatile boolean stop;</span>
<span class="line-added"> 984 </span>
 985         public HttpsProxyTunnel(HttpServer server, HTTPTestServer target,
 986                                HttpHandler delegate)
 987                 throws IOException {
 988             super(server, target, delegate);
 989             System.out.flush();
 990             System.err.println(&quot;WARNING: HttpsProxyTunnel is an experimental test class&quot;);
 991             ss = ServerSocketFactory.create();
 992             start();
 993         }
 994 
 995         final void start() throws IOException {
 996             Thread t = new Thread(this, &quot;ProxyThread&quot;);
 997             t.setDaemon(true);
 998             t.start();
 999         }
1000 
1001         @Override
1002         public void stop() {
<span class="line-modified">1003             try (var toClose = ss) {</span>
<span class="line-modified">1004                 stop = true;</span>
<span class="line-modified">1005                 System.out.println(&quot;Server &quot; + ss + &quot; stop requested&quot;);</span>
<span class="line-added">1006                 super.stop();</span>
1007             } catch (IOException ex) {
1008                 if (DEBUG) ex.printStackTrace(System.out);
1009             }
1010         }
1011 
1012         // Pipe the input stream to the output stream.
1013         private synchronized Thread pipe(InputStream is, OutputStream os, char tag) {
1014             return new Thread(&quot;TunnelPipe(&quot;+tag+&quot;)&quot;) {
1015                 @Override
1016                 public void run() {
1017                     try {
1018                         try {
1019                             int c;
1020                             while ((c = is.read()) != -1) {
1021                                 os.write(c);
1022                                 os.flush();
1023                                 // if DEBUG prints a + or a - for each transferred
1024                                 // character.
1025                                 if (DEBUG) System.out.print(tag);
1026                             }
1027                             is.close();
1028                         } finally {
1029                             os.close();
1030                         }
1031                     } catch (IOException ex) {
1032                         if (DEBUG) ex.printStackTrace(System.out);
1033                     }
1034                 }
1035             };
1036         }
1037 
1038         @Override
<span class="line-modified">1039         public InetSocketAddress getProxyAddress() {</span>
1040             return new InetSocketAddress(ss.getInetAddress(), ss.getLocalPort());
1041         }
1042 
1043         // This is a bit shaky. It doesn&#39;t handle continuation
1044         // lines, but our client shouldn&#39;t send any.
1045         // Read a line from the input stream, swallowing the final
1046         // \r\n sequence. Stops at the first \n, doesn&#39;t complain
1047         // if it wasn&#39;t preceded by &#39;\r&#39;.
1048         //
1049         String readLine(InputStream r) throws IOException {
1050             StringBuilder b = new StringBuilder();
1051             int c;
1052             while ((c = r.read()) != -1) {
1053                 if (c == &#39;\n&#39;) break;
1054                 b.appendCodePoint(c);
1055             }
<span class="line-added">1056             if (b.length() == 0) {</span>
<span class="line-added">1057                 return &quot;&quot;;</span>
<span class="line-added">1058             }</span>
1059             if (b.codePointAt(b.length() -1) == &#39;\r&#39;) {
1060                 b.delete(b.length() -1, b.length());
1061             }
1062             return b.toString();
1063         }
1064 
1065         @Override
1066         public void run() {
1067             Socket clientConnection = null;
<span class="line-modified">1068             while (!stop) {</span>
<span class="line-modified">1069                 System.out.println(&quot;Tunnel: Waiting for client at: &quot; + ss);</span>
<span class="line-modified">1070                 final Socket previous = clientConnection;</span>
<span class="line-modified">1071                 try {</span>
<span class="line-added">1072                     clientConnection = ss.accept();</span>
<span class="line-added">1073                 } catch (IOException io) {</span>
1074                     try {
<span class="line-modified">1075                         ss.close();</span>
<span class="line-modified">1076                     } catch (IOException ex) {</span>
<span class="line-modified">1077                         if (DEBUG) {</span>
<span class="line-modified">1078                             ex.printStackTrace(System.out);</span>
<span class="line-modified">1079                         }</span>
<span class="line-modified">1080                     }</span>
<span class="line-modified">1081                     // log the reason that caused the server to stop accepting connections</span>
<span class="line-added">1082                     if (!stop) {</span>
<span class="line-added">1083                         System.err.println(&quot;Server will stop accepting connections due to an exception:&quot;);</span>
<span class="line-added">1084                         io.printStackTrace();</span>
1085                     }
<span class="line-modified">1086                     break;</span>
<span class="line-modified">1087                 } finally {</span>
<span class="line-modified">1088                     // close the previous connection</span>
<span class="line-modified">1089                     if (previous != null) {</span>
<span class="line-modified">1090                         try {</span>
<span class="line-modified">1091                             previous.close();</span>
<span class="line-modified">1092                         } catch (IOException e) {</span>
<span class="line-modified">1093                             // ignore</span>
<span class="line-modified">1094                             if (DEBUG) {</span>
<span class="line-modified">1095                                 System.out.println(&quot;Ignoring exception that happened while closing &quot; +</span>
<span class="line-modified">1096                                         &quot;an older connection:&quot;);</span>
<span class="line-modified">1097                                 e.printStackTrace(System.out);</span>
<span class="line-modified">1098                             }</span>







1099                         }















1100                     }














1101                 }
<span class="line-modified">1102                 System.out.println(&quot;Tunnel: Client accepted&quot;);</span>
1103                 try {
<span class="line-modified">1104                     // We have only 1 client... process the current client</span>
<span class="line-modified">1105                     // request and wait until it has finished before</span>
<span class="line-modified">1106                     // accepting a new connection request.</span>
<span class="line-added">1107                     processRequestAndWaitToComplete(clientConnection);</span>
<span class="line-added">1108                 } catch (IOException ioe) {</span>
<span class="line-added">1109                     // close the client connection</span>
<span class="line-added">1110                     try {</span>
<span class="line-added">1111                         clientConnection.close();</span>
<span class="line-added">1112                     } catch (IOException io) {</span>
<span class="line-added">1113                         // ignore</span>
<span class="line-added">1114                         if (DEBUG) {</span>
<span class="line-added">1115                             System.out.println(&quot;Ignoring exception that happened during client&quot; +</span>
<span class="line-added">1116                                     &quot; connection close:&quot;);</span>
<span class="line-added">1117                             io.printStackTrace(System.out);</span>
<span class="line-added">1118                         }</span>
<span class="line-added">1119                     } finally {</span>
<span class="line-added">1120                         clientConnection = null;</span>
<span class="line-added">1121                     }</span>
<span class="line-added">1122                 } catch (Throwable t) {</span>
<span class="line-added">1123                     // don&#39;t close the client connection for non-IOExceptions, instead</span>
<span class="line-added">1124                     // just log it and move on to accept next connection</span>
<span class="line-added">1125                     if (!stop) {</span>
<span class="line-added">1126                         t.printStackTrace();</span>
<span class="line-added">1127                     }</span>
1128                 }

1129             }
1130         }
1131 
<span class="line-added">1132         private void processRequestAndWaitToComplete(final Socket clientConnection)</span>
<span class="line-added">1133                 throws IOException, InterruptedException {</span>
<span class="line-added">1134             final Socket targetConnection;</span>
<span class="line-added">1135             InputStream  ccis = clientConnection.getInputStream();</span>
<span class="line-added">1136             OutputStream ccos = clientConnection.getOutputStream();</span>
<span class="line-added">1137             Writer w = new OutputStreamWriter(</span>
<span class="line-added">1138                     clientConnection.getOutputStream(), &quot;UTF-8&quot;);</span>
<span class="line-added">1139             PrintWriter pw = new PrintWriter(w);</span>
<span class="line-added">1140             System.out.println(&quot;Tunnel: Reading request line&quot;);</span>
<span class="line-added">1141             String requestLine = readLine(ccis);</span>
<span class="line-added">1142             System.out.println(&quot;Tunnel: Request line: &quot; + requestLine);</span>
<span class="line-added">1143             if (requestLine.startsWith(&quot;CONNECT &quot;)) {</span>
<span class="line-added">1144                 // We should probably check that the next word following</span>
<span class="line-added">1145                 // CONNECT is the host:port of our HTTPS serverImpl.</span>
<span class="line-added">1146                 // Some improvement for a followup!</span>
<span class="line-added">1147 </span>
<span class="line-added">1148                 // Read all headers until we find the empty line that</span>
<span class="line-added">1149                 // signals the end of all headers.</span>
<span class="line-added">1150                 while(!requestLine.equals(&quot;&quot;)) {</span>
<span class="line-added">1151                     System.out.println(&quot;Tunnel: Reading header: &quot;</span>
<span class="line-added">1152                             + (requestLine = readLine(ccis)));</span>
<span class="line-added">1153                 }</span>
<span class="line-added">1154 </span>
<span class="line-added">1155                 targetConnection = new Socket(</span>
<span class="line-added">1156                         serverImpl.getAddress().getAddress(),</span>
<span class="line-added">1157                         serverImpl.getAddress().getPort());</span>
<span class="line-added">1158 </span>
<span class="line-added">1159                 // Then send the 200 OK response to the client</span>
<span class="line-added">1160                 System.out.println(&quot;Tunnel: Sending &quot;</span>
<span class="line-added">1161                         + &quot;HTTP/1.1 200 OK\r\n\r\n&quot;);</span>
<span class="line-added">1162                 pw.print(&quot;HTTP/1.1 200 OK\r\nContent-Length: 0\r\n\r\n&quot;);</span>
<span class="line-added">1163                 pw.flush();</span>
<span class="line-added">1164             } else {</span>
<span class="line-added">1165                 // This should not happen. If it does then consider it a</span>
<span class="line-added">1166                 // client error and throw an IOException</span>
<span class="line-added">1167                 System.out.println(&quot;Tunnel: Throwing an IOException due to unexpected&quot; +</span>
<span class="line-added">1168                         &quot; request line: &quot; + requestLine);</span>
<span class="line-added">1169                 throw new IOException(&quot;Client request error - Unexpected request line&quot;);</span>
<span class="line-added">1170             }</span>
<span class="line-added">1171 </span>
<span class="line-added">1172             // Pipe the input stream of the client connection to the</span>
<span class="line-added">1173             // output stream of the target connection and conversely.</span>
<span class="line-added">1174             // Now the client and target will just talk to each other.</span>
<span class="line-added">1175             System.out.println(&quot;Tunnel: Starting tunnel pipes&quot;);</span>
<span class="line-added">1176             Thread t1 = pipe(ccis, targetConnection.getOutputStream(), &#39;+&#39;);</span>
<span class="line-added">1177             Thread t2 = pipe(targetConnection.getInputStream(), ccos, &#39;-&#39;);</span>
<span class="line-added">1178             t1.start();</span>
<span class="line-added">1179             t2.start();</span>
<span class="line-added">1180             // wait for the request to complete</span>
<span class="line-added">1181             t1.join();</span>
<span class="line-added">1182             t2.join();</span>
<span class="line-added">1183         }</span>
1184     }
1185 }
</pre>
</td>
</tr>
</table>
<center><a href="HTTPTest.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="../UnmodifiableMaps.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
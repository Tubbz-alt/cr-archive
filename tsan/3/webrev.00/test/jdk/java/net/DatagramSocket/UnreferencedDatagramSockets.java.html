<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New test/jdk/java/net/DatagramSocket/UnreferencedDatagramSockets.java</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2017, 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 /**
 25  * @test
 26  * @library /test/lib
 27  * @modules java.management java.base/java.io:+open java.base/java.net:+open
 28  * @run main/othervm UnreferencedDatagramSockets
 29  * @run main/othervm -Djava.net.preferIPv4Stack=true UnreferencedDatagramSockets
 30  * @summary Check that unreferenced datagram sockets are closed
 31  */
 32 
 33 import java.io.FileDescriptor;
 34 import java.lang.management.ManagementFactory;
 35 import java.lang.management.OperatingSystemMXBean;
 36 import java.lang.ref.ReferenceQueue;
 37 import java.lang.ref.WeakReference;
 38 import java.lang.reflect.Field;
 39 import java.io.IOException;
 40 import java.net.DatagramPacket;
 41 import java.net.DatagramSocket;
 42 import java.net.DatagramSocketImpl;
 43 import java.net.InetAddress;
 44 import java.net.UnknownHostException;
 45 import java.nio.file.Files;
 46 import java.nio.file.Path;
 47 import java.nio.file.Paths;
 48 import java.util.ArrayDeque;
 49 import java.util.List;
 50 import java.util.Optional;
 51 import java.util.concurrent.TimeUnit;
 52 import java.util.concurrent.CountDownLatch;
 53 
 54 import com.sun.management.UnixOperatingSystemMXBean;
 55 
 56 import jdk.test.lib.net.IPSupport;
 57 
 58 public class UnreferencedDatagramSockets {
 59 
 60     /**
 61      * The set of sockets we have to check up on.
 62      */
 63     final static ArrayDeque&lt;NamedWeak&gt; pendingSockets = new ArrayDeque&lt;&gt;(5);
 64 
 65     /**
 66      * Queued objects when they are unreferenced.
 67      */
 68     final static ReferenceQueue&lt;Object&gt; pendingQueue = new ReferenceQueue&lt;&gt;();
 69 
 70     // Server to echo a datagram packet
 71     static class Server implements Runnable {
 72 
 73         DatagramSocket ss;
 74         CountDownLatch latch = new CountDownLatch(1);
 75 
 76         Server() throws IOException {
 77             ss = new DatagramSocket(0, getHost());
 78             System.out.printf(&quot;  DatagramServer addr: %s: %d%n&quot;,
 79                     this.getHost(), this.getPort());
 80             pendingSockets.add(new NamedWeak(ss, pendingQueue, &quot;serverDatagramSocket&quot;));
 81             extractRefs(ss, &quot;serverDatagramSocket&quot;);
 82         }
 83 
 84         InetAddress getHost() throws UnknownHostException {
 85             InetAddress localhost = lookupLocalHost();
 86             return localhost;
 87         }
 88 
 89         int getPort() {
 90             return ss.getLocalPort();
 91         }
 92 
 93         // Receive a byte and send back a byte
 94         public void run() {
 95             try {
 96                 byte[] buffer = new byte[50];
 97                 DatagramPacket p = new DatagramPacket(buffer, buffer.length);
 98                 ss.receive(p);
 99                 buffer[0] += 1;
100                 ss.send(p);         // send back +1
101                 latch.await();      // wait for the client to receive the packet
102                 // do NOT close but &#39;forget&#39; the datagram socket reference
103                 ss = null;
104             } catch (Exception ioe) {
105                 ioe.printStackTrace();
106             }
107         }
108     }
109 
110     static InetAddress lookupLocalHost() throws UnknownHostException {
111         return InetAddress.getByName(&quot;localhost&quot;); //.getLocalHost();
112     }
113 
114     public static void main(String args[]) throws Exception {
115         IPSupport.throwSkippedExceptionIfNonOperational();
116 
117         // Create and close a DatagramSocket to warm up the FD count for side effects.
118         try (DatagramSocket s = new DatagramSocket(0, lookupLocalHost())) {
119             // no-op; close immediately
120             s.getLocalPort();   // no-op
121         }
122 
123         long fdCount0 = getFdCount();
124         listProcFD();
125 
126         // start a server
127         Server svr = new Server();
128         Thread thr = new Thread(svr);
129         thr.start();
130 
131         DatagramSocket client = new DatagramSocket(0, lookupLocalHost());
132         client.connect(svr.getHost(), svr.getPort());
133         pendingSockets.add(new NamedWeak(client, pendingQueue, &quot;clientDatagramSocket&quot;));
134         extractRefs(client, &quot;clientDatagramSocket&quot;);
135 
136         byte[] msg = new byte[1];
137         msg[0] = 1;
138         DatagramPacket p = new DatagramPacket(msg, msg.length, svr.getHost(), svr.getPort());
139         client.send(p);
140 
141         p = new DatagramPacket(msg, msg.length);
142         client.receive(p);
143         svr.latch.countDown(); // unblock the server
144 
145 
146         System.out.printf(&quot;echo received from: %s%n&quot;, p.getSocketAddress());
147         if (msg[0] != 2) {
148             throw new AssertionError(&quot;incorrect data received: expected: 2, actual: &quot; + msg[0]);
149         }
150 
151         // Do NOT close the DatagramSocket; forget it
152 
153         Object ref;
154         int loops = 20;
155         while (!pendingSockets.isEmpty() &amp;&amp; loops-- &gt; 0) {
156             ref = pendingQueue.remove(1000L);
157             if (ref != null) {
158                 pendingSockets.remove(ref);
159                 System.out.printf(&quot;  ref freed: %s, remaining: %d%n&quot;, ref, pendingSockets.size());
160             } else {
161                 client = null;
162                 p = null;
163                 msg = null;
164                 System.gc();
165             }
166         }
167 
168         thr.join();
169 
170         // List the open file descriptors
171         long fdCount = getFdCount();
172         System.out.printf(&quot;Initial fdCount: %d, final fdCount: %d%n&quot;, fdCount0, fdCount);
173         listProcFD();
174 
175         if (loops == 0) {
176             throw new AssertionError(&quot;Not all references reclaimed&quot;);
177         }
178     }
179 
180     // Get the count of open file descriptors, or -1 if not available
181     private static long getFdCount() {
182         OperatingSystemMXBean mxBean = ManagementFactory.getOperatingSystemMXBean();
183         return (mxBean instanceof UnixOperatingSystemMXBean)
184                 ? ((UnixOperatingSystemMXBean) mxBean).getOpenFileDescriptorCount()
185                 : -1L;
186     }
187 
188     // Reflect to find references in the datagram implementation that will be gc&#39;d
189     private static void extractRefs(DatagramSocket s, String name) {
190         try {
191 
192             Field socketImplField = DatagramSocket.class.getDeclaredField(&quot;impl&quot;);
193             socketImplField.setAccessible(true);
194             Object socketImpl = socketImplField.get(s);
195 
196             Field fileDescriptorField = DatagramSocketImpl.class.getDeclaredField(&quot;fd&quot;);
197             fileDescriptorField.setAccessible(true);
198             FileDescriptor fileDescriptor = (FileDescriptor) fileDescriptorField.get(socketImpl);
199             extractRefs(fileDescriptor, name);
200 
201             Class&lt;?&gt; socketImplClass = socketImpl.getClass();
202             System.out.printf(&quot;socketImplClass: %s%n&quot;, socketImplClass);
203             if (socketImplClass.getName().equals(&quot;java.net.TwoStacksPlainDatagramSocketImpl&quot;)) {
204                 Field fileDescriptor1Field = socketImplClass.getDeclaredField(&quot;fd1&quot;);
205                 fileDescriptor1Field.setAccessible(true);
206                 FileDescriptor fileDescriptor1 = (FileDescriptor) fileDescriptor1Field.get(socketImpl);
207                 extractRefs(fileDescriptor1, name + &quot;::twoStacksFd1&quot;);
208 
209             } else {
210                 System.out.printf(&quot;socketImpl class name not matched: %s != %s%n&quot;,
211                         socketImplClass.getName(), &quot;java.net.TwoStacksPlainDatagramSocketImpl&quot;);
212             }
213         } catch (NoSuchFieldException | IllegalAccessException ex) {
214             ex.printStackTrace();
215             throw new AssertionError(&quot;missing field&quot;, ex);
216         }
217     }
218 
219     private static void extractRefs(FileDescriptor fileDescriptor, String name) {
220         Object cleanup = null;
221         int rawfd = -1;
222         try {
223             if (fileDescriptor != null) {
224                 Field fd1Field = FileDescriptor.class.getDeclaredField(&quot;fd&quot;);
225                 fd1Field.setAccessible(true);
226                 rawfd = fd1Field.getInt(fileDescriptor);
227 
228                 Field cleanupfdField = FileDescriptor.class.getDeclaredField(&quot;cleanup&quot;);
229                 cleanupfdField.setAccessible(true);
230                 cleanup = cleanupfdField.get(fileDescriptor);
231                 pendingSockets.add(new NamedWeak(fileDescriptor, pendingQueue,
232                         name + &quot;::fileDescriptor: &quot; + rawfd));
233                 pendingSockets.add(new NamedWeak(cleanup, pendingQueue, name + &quot;::fdCleanup: &quot; + rawfd));
234 
235             }
236         } catch (NoSuchFieldException | IllegalAccessException ex) {
237             ex.printStackTrace();
238             throw new AssertionError(&quot;missing field&quot;, ex);
239         } finally {
240             System.out.print(String.format(&quot;  %s:: fd: %s, fd: %d, cleanup: %s%n&quot;,
241                     name, fileDescriptor, rawfd, cleanup));
242         }
243     }
244 
245     /**
246      * Method to list the open file descriptors (if supported by the &#39;lsof&#39; command).
247      */
248     static void listProcFD() {
249         List&lt;String&gt; lsofDirs = List.of(&quot;/usr/bin&quot;, &quot;/usr/sbin&quot;);
250         Optional&lt;Path&gt; lsof = lsofDirs.stream()
251                 .map(s -&gt; Paths.get(s, &quot;lsof&quot;))
252                 .filter(f -&gt; Files.isExecutable(f))
253                 .findFirst();
254         lsof.ifPresent(exe -&gt; {
255             try {
256                 System.out.printf(&quot;Open File Descriptors:%n&quot;);
257                 long pid = ProcessHandle.current().pid();
258                 ProcessBuilder pb = new ProcessBuilder(exe.toString(), &quot;-p&quot;, Integer.toString((int) pid));
259                 pb.inheritIO();
260                 Process p = pb.start();
261                 p.waitFor(10, TimeUnit.SECONDS);
262             } catch (IOException | InterruptedException ie) {
263                 ie.printStackTrace();
264             }
265         });
266     }
267 
268     // Simple class to identify which refs have been queued
269     static class NamedWeak extends WeakReference&lt;Object&gt; {
270         private final String name;
271 
272         NamedWeak(Object o, ReferenceQueue&lt;Object&gt; queue, String name) {
273             super(o, queue);
274             this.name = name;
275         }
276 
277         public String toString() {
278             return name + &quot;; &quot; + super.toString();
279         }
280     }
281 }
    </pre>
  </body>
</html>
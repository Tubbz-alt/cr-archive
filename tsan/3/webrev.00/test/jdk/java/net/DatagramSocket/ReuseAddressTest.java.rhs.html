<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames test/jdk/java/net/DatagramSocket/ReuseAddressTest.java</title>
    <link rel="stylesheet" href="../../../../../style.css" />
    <script type="text/javascript" src="../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre><a name="1" id="anc1"></a><span class="line-modified">  1 /* Copyright (c) 2016, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  2  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  3  *
  4  * This code is free software; you can redistribute it and/or modify it
  5  * under the terms of the GNU General Public License version 2 only, as
  6  * published by the Free Software Foundation.
  7  *
  8  * This code is distributed in the hope that it will be useful, but WITHOUT
  9  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 10  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 11  * version 2 for more details (a copy is included in the LICENSE file that
 12  * accompanied this code).
 13  *
 14  * You should have received a copy of the GNU General Public License version
 15  * 2 along with this work; if not, write to the Free Software Foundation,
 16  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 17  *
 18  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 19  * or visit www.oracle.com if you need additional information or have any
 20  * questions.
 21  */
 22 
 23 import java.io.IOException;
 24 import java.net.DatagramSocket;
 25 import java.net.InetAddress;
 26 import java.net.InetSocketAddress;
 27 import java.net.MulticastSocket;
 28 import java.net.SocketException;
 29 
 30 /*
 31  * @test
 32  * @bug 8153674
<a name="2" id="anc2"></a><span class="line-added"> 33  * @key intermittent</span>
<span class="line-added"> 34  * @summary This test might fail intermittently as it needs a UDP socket that</span>
<span class="line-added"> 35  *          binds to the wildcard address.</span>
 36  * @summary Expected SocketException not thrown when calling bind() with
 37  *   setReuseAddress(false)
 38  * @run main/othervm ReuseAddressTest
 39  */
 40 
 41 public class ReuseAddressTest {
 42 
 43     String getInfo(DatagramSocket soc) {
 44         if (soc == null) {
 45             return null;
 46         }
 47 
 48         return &quot;localPort: &quot; + soc.getLocalPort()
 49                 + &quot;; localAddress: &quot; + soc.getLocalAddress()
 50                 + &quot;; remotePort: &quot; + soc.getPort()
 51                 + &quot;; remoteAddress: &quot; + soc.getInetAddress()
 52                 + &quot;; isClosed: &quot; + soc.isClosed()
 53                 + &quot;; isBound: &quot; + soc.isBound();
 54     }
 55 
 56     static InetSocketAddress createSocketAddress(int testMcastPort) throws Exception {
 57         InetAddress localAddress = InetAddress.getLocalHost();
 58         InetSocketAddress localSocketAddress = new InetSocketAddress(localAddress, testMcastPort);
 59         return localSocketAddress;
 60     }
 61 
 62     /* standalone interface */
 63     public static void main(String argv[]) throws Exception {
 64         ReuseAddressTest test = new ReuseAddressTest();
 65         test.DatagramSocket0029();
 66         test.DatagramSocket0030();
 67         test.DatagramSocket0031();
 68         test.DatagramSocket0032();
 69         test.DatagramSocket0034();
 70         test.DatagramSocket0035();
 71         test.DatagramSocket2028();
 72         test.DatagramSocket2029();
 73         test.DatagramSocket2030();
 74 
 75     }
 76 
 77     /**
 78      * Equivalence class partitioning with input values orientation for public
 79      * void setReuseAddress(boolean on) throws SocketException,
 80      * &lt;br&gt;&lt;b&gt;on&lt;/b&gt;: false.
 81      * &lt;br&gt;&lt;b&gt;Expected results&lt;/b&gt;: getReuseAddress() will return false
 82      */
 83     public void DatagramSocket0029() throws Exception {
 84         String testCaseID = &quot;DatagramSocket0029&quot;;
 85         System.out.println(&quot; &gt;&gt; &quot; + testCaseID + &quot;: &quot; + &quot;public void setReuseAddress(boolean on) throws SocketException&quot;);
 86 
 87         DatagramSocket ds = null;
 88         try {
 89             ds = new DatagramSocket(null);
 90             ds.setReuseAddress(false);
 91             if (ds.getReuseAddress() == true) {
 92                 throw new RuntimeException(&quot;SO_REUSEADDR is not set to false&quot;);
 93             }
 94         } catch (IOException e) {
 95             e.printStackTrace(System.out);
 96             throw new RuntimeException(&quot;unexpected: &quot; + e);
 97         } catch (SecurityException e) {
 98             System.out.println(&quot;Security restriction&quot;);
 99         } finally {
100             if (ds != null) {
101                 ds.close();
102             }
103         }
104 
105         System.out.println(&quot;OKAY&quot;);
106     }
107 
108     /**
109      * Equivalence class partitioning with input values orientation for public
110      * void setReuseAddress(boolean on) throws SocketException,
111      * &lt;br&gt;&lt;b&gt;on&lt;/b&gt;: true.
112      * &lt;br&gt;&lt;b&gt;Expected results&lt;/b&gt;: Allows completely duplicate bindings (same
113      * address and port) on multicast sockets
114      */
115     public void DatagramSocket0030() throws Exception {
116         String testCaseID = &quot;DatagramSocket0030&quot;;
117         System.out.println(&quot; &gt;&gt; &quot; + testCaseID + &quot;: &quot; + &quot;public void setReuseAddress(boolean on) throws SocketException&quot;);
118 
119         MulticastSocket ms1 = null;
120         MulticastSocket ms2 = null;
121         try {
<a name="3" id="anc3"></a><span class="line-modified">122             InetSocketAddress addr = createSocketAddress(0);</span>
123 
124             ms1 = new MulticastSocket(null);
125             ms1.setReuseAddress(true);
126             if (!ms1.getReuseAddress()) {
127                 System.out.println(&quot;Cannot check: &quot;
128                         + &quot; safety for SO_REUSEADDR option is not guaranteed&quot;);
129             }
130 
131             try {
132                 ms1.bind(addr);
133             } catch (SocketException e) {
134                 throw new RuntimeException(&quot;cannot bind first socket to &quot; + addr
135                         + &quot; unexpected &quot; + e);
136             }
137 
<a name="4" id="anc4"></a><span class="line-added">138             addr = createSocketAddress(ms1.getLocalPort());</span>
139             ms2 = new MulticastSocket(null);
140             ms2.setReuseAddress(true);
141             if (!ms2.getReuseAddress()) {
142                 System.out.println(&quot;Cannot check: &quot;
143                         + &quot; safety for SO_REUSEADDR option is not guaranteed&quot;);
144             }
145 
146             try {
147                 ms2.bind(addr);
148             } catch (SocketException e) {
149                 throw new RuntimeException(&quot;cannot bind second socket to &quot; + addr
150                         + &quot; unexpected &quot; + e);
151             }
152 
153             if (ms1.getLocalPort() != addr.getPort() || !ms1.isBound()
154                     || ms2.getLocalPort() != addr.getPort() || !ms2.isBound()) {
155                 System.out.println(&quot;bind() fails with: &quot; + addr);
156                 System.out.println(&quot;  ms1 [&quot; + getInfo(ms1) + &quot;]&quot;);
157                 System.out.println(&quot;  ms2 [&quot; + getInfo(ms2) + &quot;]&quot;);
158                 System.out.println(&quot;  getReuseAddress(): &quot; + ms2.getReuseAddress());
159                 throw new RuntimeException(&quot;bind() fails with: &quot; + addr);
160             }
161 
162         } catch (IOException e) {
163             e.printStackTrace(System.out);
164             throw new RuntimeException(&quot;unexpected: &quot; + e);
165         } catch (SecurityException e) {
166             System.out.println(&quot;Security restriction&quot;);
167         } finally {
168             if (ms1 != null) {
169                 ms1.close();
170             }
171             if (ms2 != null) {
172                 ms2.close();
173             }
174         }
175 
176         System.out.println(&quot;OKAY&quot;);
177     }
178 
179     /**
180      * Equivalence class partitioning with input values orientation for public
181      * void setReuseAddress(boolean on) throws SocketException,
182      * &lt;br&gt;&lt;b&gt;on&lt;/b&gt;: false.
183      * &lt;br&gt;&lt;b&gt;Expected results&lt;/b&gt;: The second bind will throw SocketException,
184      * when SO_REUSEADDR disable
185      */
186     public void DatagramSocket0031() throws Exception {
187         String testCaseID = &quot;DatagramSocket0031&quot;;
188         System.out.println(&quot; &gt;&gt; &quot; + testCaseID + &quot;: &quot; + &quot;public void setReuseAddress(boolean on) throws SocketException&quot;);
189 
190         MulticastSocket ms1 = null;
191         MulticastSocket ms2 = null;
192         try {
<a name="5" id="anc5"></a><span class="line-modified">193             InetSocketAddress addr = createSocketAddress(0);</span>
194 
195             ms1 = new MulticastSocket(null);
196             try {
197                 ms1.bind(addr);
198             } catch (SocketException e) {
199                 throw new RuntimeException(&quot;cannot bind first socket to &quot; + addr
200                         + &quot; unexpected &quot; + e);
201             }
202 
<a name="6" id="anc6"></a><span class="line-added">203             addr = createSocketAddress(ms1.getLocalPort());</span>
204             ms2 = new MulticastSocket(null);
205             ms2.setReuseAddress(false);  // method under test
206 
207             try {
208                 ms2.bind(addr);
209                 System.out.println(&quot;No exceptions: &quot;);
210                 System.out.println(&quot;  addr: &quot; + addr);
211                 System.out.println(&quot;  ms1 [&quot; + getInfo(ms1) + &quot;]&quot;);
212                 System.out.println(&quot;  ms2 [&quot; + getInfo(ms2) + &quot;]&quot;);
213                 System.out.println(&quot;  getReuseAddress(): &quot; + ms2.getReuseAddress());
214                 throw new RuntimeException(&quot;no exceptions from bind() with &quot; + addr);
215             } catch (SocketException e) {
216             }
217 
218         } catch (IOException e) {
219             e.printStackTrace(System.out);
220             throw new RuntimeException(&quot;unexpected: &quot; + e);
221         } catch (SecurityException e) {
222             System.out.println(&quot;Security restriction&quot;);
223         } finally {
224             if (ms1 != null) {
225                 ms1.close();
226             }
227             if (ms2 != null) {
228                 ms2.close();
229             }
230         }
231 
232         System.out.println(&quot;OKAY&quot;);
233     }
234 
235     /**
236      * Equivalence class partitioning with input values orientation for public
237      * void setReuseAddress(boolean on) throws SocketException,
238      * &lt;br&gt;&lt;b&gt;on&lt;/b&gt;: true.
239      * &lt;br&gt;&lt;b&gt;Expected results&lt;/b&gt;: Allows a single process to bind the same
240      * port to multiple sockets as long as each bind specifies a different local
241      * IP address
242      */
243     public void DatagramSocket0032() throws Exception {
244         String testCaseID = &quot;DatagramSocket0032&quot;;
245         System.out.println(&quot; &gt;&gt; &quot; + testCaseID + &quot;: &quot; + &quot;public void setReuseAddress(boolean on) throws SocketException&quot;);
246 
247         DatagramSocket ds1 = null;
248         DatagramSocket ds2 = null;
249         try {
250 
<a name="7" id="anc7"></a><span class="line-modified">251             InetSocketAddress isa1 = createSocketAddress(0);</span>
<span class="line-modified">252             InetAddress addr = isa1.getAddress();</span>
253             InetAddress wildcard = InetAddress.getByName(&quot;0.0.0.0&quot;);
254             if (addr.equals(wildcard) || addr.isLoopbackAddress()) {
255                 System.out.println(&quot;Cannot check: addresses are equal&quot;);
256             }
257 
<a name="8" id="anc8"></a>

258 
259             ds1 = new DatagramSocket(null);
260             ds1.setReuseAddress(true);    // method under test
261             if (!ds1.getReuseAddress()) {
262                 System.out.println(&quot;Cannot check: &quot;
263                         + &quot; safety for SO_REUSEADDR option is not guaranteed&quot;);
264             }
265             ds1.bind(isa1);
266 
<a name="9" id="anc9"></a><span class="line-added">267             InetSocketAddress isa2 = new InetSocketAddress(wildcard, ds1.getLocalPort());</span>
<span class="line-added">268 </span>
269             ds2 = new DatagramSocket(null);
270             ds2.setReuseAddress(true);    // method under test
271             if (!ds2.getReuseAddress()) {
272                 System.out.println(&quot;Cannot check: &quot;
273                         + &quot; safety for SO_REUSEADDR option is not guaranteed&quot;);
274             }
275 
276             try {
277                 ds2.bind(isa2);
278             } catch (SocketException e) {
279                 throw new RuntimeException(&quot;cannot bind second socket to &quot; + isa2
280                         + &quot; unexpected &quot; + e);
281             }
282 
<a name="10" id="anc10"></a><span class="line-modified">283             if (ds1.getLocalPort() != ds2.getLocalPort() || !ds1.isBound()</span>
<span class="line-modified">284                     || !ds2.isBound()) {</span>
285                 System.out.println(&quot;bind() fails with: &quot; + addr);
286                 System.out.println(&quot;  ds1 [&quot; + getInfo(ds1) + &quot;]&quot;);
287                 System.out.println(&quot;  ds2 [&quot; + getInfo(ds2) + &quot;]&quot;);
288                 System.out.println(&quot;  getReuseAddress(): &quot; + ds2.getReuseAddress());
289                 throw new RuntimeException(&quot;bind() fails with: &quot; + addr);
290             }
291 
292         } catch (IOException e) {
293             e.printStackTrace(System.out);
294             throw new RuntimeException(&quot;unexpected: &quot; + e);
295         } catch (SecurityException e) {
296             System.out.println(&quot;Security restriction&quot;);
297         } finally {
298             if (ds1 != null) {
299                 ds1.close();
300             }
301             if (ds2 != null) {
302                 ds2.close();
303             }
304         }
305 
306         System.out.println(&quot;OKAY&quot;);
307     }
308 
309     /**
310      * Assertion testing for public int getTrafficClass() throws
311      * SocketException, will return a number in range from 0 to 255 or throw
312      * SocketException.
313      */
314     public void DatagramSocket2028() throws Exception {
315         String testCaseID = &quot;DatagramSocket2028&quot;;
316         System.out.println(&quot; &gt;&gt; &quot; + testCaseID + &quot;: &quot; + &quot;public int getTrafficClass() throws SocketException&quot;);
317 
318         DatagramSocket ds = null;
319         try {
320             ds = new DatagramSocket();
321             int tc = ds.getTrafficClass();
322             if (tc &lt; 0 || tc &gt; 255) {
323                 throw new RuntimeException(&quot;getTrafficClass() returns: &quot; + tc);
324             }
325         } catch (SecurityException e) {
326             System.out.println(&quot;Security restriction: &quot; + e);
327         } catch (SocketException e) {
328             e.printStackTrace(System.out);
329             throw new RuntimeException(&quot;Unexpected exception : &quot; + e);
330         } finally {
331             if (ds != null) {
332                 ds.close();
333             }
334         }
335 
336         System.out.println(&quot;OKAY&quot;);
337     }
338 
339     /**
340      * Assertion testing for public void setTrafficClass(int tc) throws
341      * SocketException, IAE will be thrown with tc less than 0 or greater than
342      * 255.
343      */
344     public void DatagramSocket2029() throws Exception {
345         String testCaseID = &quot;DatagramSocket2029&quot;;
346         System.out.println(&quot; &gt;&gt; &quot; + testCaseID + &quot;: &quot; + &quot;public void setTrafficClass(int tc) throws SocketException&quot;);
347 
348         DatagramSocket ds = null;
349         try {
350             ds = new DatagramSocket();
351         } catch (SecurityException e) {
352             System.out.println(&quot;Security restriction: &quot; + e);
353         } catch (IOException e) {
354             e.printStackTrace(System.out);
355             throw new RuntimeException(&quot;cannot create socket: &quot; + e);
356         }
357 
358         int[] values = {
359             Integer.MIN_VALUE, Integer.MIN_VALUE + 1, -1000, -2, -1,
360             256, 257, 1000, 50000, Integer.MAX_VALUE - 1, Integer.MAX_VALUE
361         };
362 
363         for (int i = 0; i &lt; values.length; i++) {
364             try {
365                 ds.setTrafficClass(values[i]);
366                 System.out.println(&quot;No exception with: &quot; + values[i]);
367                 System.out.println(&quot;getTrafficClass() returns: &quot; + ds.getTrafficClass());
368                 ds.close();
369                 throw new RuntimeException(&quot;setTrafficClass() fails with : &quot; + values[i]);
370             } catch (SocketException e) {
371                 ds.close();
372                 e.printStackTrace(System.out);
373                 throw new RuntimeException(&quot;setTrafficClass() throws : &quot; + e);
374             } catch (IllegalArgumentException e) {
375             }
376         }
377 
378         System.out.println(&quot;OKAY&quot;);
379     }
380 
381     /**
382      * Assertion testing for public void setTrafficClass(int tc) throws
383      * SocketException, only SocketException may be thrown with tc in range from
384      * 0 to 255.
385      */
386     public void DatagramSocket2030() throws Exception {
387         String testCaseID = &quot;DatagramSocket2030&quot;;
388         System.out.println(&quot; &gt;&gt; &quot; + testCaseID + &quot;: &quot; + &quot;public void setTrafficClass(int tc) throws SocketException&quot;);
389 
390         DatagramSocket ds = null;
391         try {
392             ds = new DatagramSocket();
393         } catch (SecurityException e) {
394             System.out.println(&quot;Security restriction: &quot; + e);
395         } catch (IOException e) {
396             e.printStackTrace(System.out);
397             throw new RuntimeException(&quot;cannot create socket: &quot; + e);
398         }
399 
400         for (int i = 0; i &lt;= 255; i++) {
401             try {
402                 ds.setTrafficClass(i);
403             } catch (SocketException e) {
404             }
405         }
406 
407         System.out.println(&quot;OKAY&quot;);
408     }
409 
410     /**
411      * Equivalence class partitioning with input values orientation for public
412      * void setBroadcast(boolean on) throws SocketException,
413      * &lt;br&gt;&lt;b&gt;on&lt;/b&gt;: false.
414      * &lt;br&gt;&lt;b&gt;Expected results&lt;/b&gt;: getBroadcast() will return false
415      */
416     public void DatagramSocket0034() throws Exception {
417         String testCaseID = &quot;DatagramSocket0034&quot;;
418         System.out.println(&quot; &gt;&gt; &quot; + testCaseID + &quot;: &quot; + &quot;public void setBroadcast(boolean on) throws SocketException&quot;);
419 
420         DatagramSocket ds = null;
421         try {
422             ds = new DatagramSocket();
423             ds.setBroadcast(false);
424             if (ds.getBroadcast() == true) {
425                 throw new RuntimeException(&quot;SO_BROADCAST is not set to false&quot;);
426             }
427         } catch (IOException e) {
428             e.printStackTrace(System.out);
429             throw new RuntimeException(&quot;unexpected: &quot; + e);
430         } catch (SecurityException e) {
431             System.out.println(&quot;Security restriction&quot;);
432         } finally {
433             if (ds != null) {
434                 ds.close();
435             }
436         }
437 
438         System.out.println(&quot;OKAY&quot;);
439     }
440 
441     /**
442      * Equivalence class partitioning with input values orientation for public
443      * void setBroadcast(boolean on) throws SocketException,
444      * &lt;br&gt;&lt;b&gt;on&lt;/b&gt;: true.
445      * &lt;br&gt;&lt;b&gt;Expected results&lt;/b&gt;: getBroadcast() will return true
446      */
447     public void DatagramSocket0035() throws Exception {
448         String testCaseID = &quot;DatagramSocket0035&quot;;
449         System.out.println(&quot; &gt;&gt; &quot; + testCaseID + &quot;: &quot; + &quot;public void setBroadcast(boolean on) throws SocketException&quot;);
450 
451         DatagramSocket ds = null;
452         try {
453             ds = new DatagramSocket();
454             ds.setBroadcast(true);
455             if (ds.getBroadcast() == false) {
456                 throw new RuntimeException(&quot;SO_BROADCAST is not set to true&quot;);
457             }
458         } catch (IOException e) {
459             e.printStackTrace(System.out);
460             throw new RuntimeException(&quot;unexpected: &quot; + e);
461         } catch (SecurityException e) {
462             System.out.println(&quot;Security restriction&quot;);
463         } finally {
464             if (ds != null) {
465                 ds.close();
466             }
467         }
468 
469         System.out.println(&quot;OKAY&quot;);
470     }
471 }
<a name="11" id="anc11"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="11" type="hidden" />
</body>
</html>
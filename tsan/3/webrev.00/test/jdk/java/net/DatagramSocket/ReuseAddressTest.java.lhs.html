<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames test/jdk/java/net/DatagramSocket/ReuseAddressTest.java</title>
    <link rel="stylesheet" href="../../../../../style.css" />
    <script type="text/javascript" src="../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre><a name="1" id="anc1"></a><span class="line-modified">  1 /* Copyright (c) 2016, Oracle and/or its affiliates. All rights reserved.</span>
  2  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  3  *
  4  * This code is free software; you can redistribute it and/or modify it
  5  * under the terms of the GNU General Public License version 2 only, as
  6  * published by the Free Software Foundation.
  7  *
  8  * This code is distributed in the hope that it will be useful, but WITHOUT
  9  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 10  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 11  * version 2 for more details (a copy is included in the LICENSE file that
 12  * accompanied this code).
 13  *
 14  * You should have received a copy of the GNU General Public License version
 15  * 2 along with this work; if not, write to the Free Software Foundation,
 16  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 17  *
 18  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 19  * or visit www.oracle.com if you need additional information or have any
 20  * questions.
 21  */
 22 
 23 import java.io.IOException;
 24 import java.net.DatagramSocket;
 25 import java.net.InetAddress;
 26 import java.net.InetSocketAddress;
 27 import java.net.MulticastSocket;
 28 import java.net.SocketException;
 29 
 30 /*
 31  * @test
 32  * @bug 8153674
<a name="2" id="anc2"></a>


 33  * @summary Expected SocketException not thrown when calling bind() with
 34  *   setReuseAddress(false)
 35  * @run main/othervm ReuseAddressTest
 36  */
 37 
 38 public class ReuseAddressTest {
 39 
 40     String getInfo(DatagramSocket soc) {
 41         if (soc == null) {
 42             return null;
 43         }
 44 
 45         return &quot;localPort: &quot; + soc.getLocalPort()
 46                 + &quot;; localAddress: &quot; + soc.getLocalAddress()
 47                 + &quot;; remotePort: &quot; + soc.getPort()
 48                 + &quot;; remoteAddress: &quot; + soc.getInetAddress()
 49                 + &quot;; isClosed: &quot; + soc.isClosed()
 50                 + &quot;; isBound: &quot; + soc.isBound();
 51     }
 52 
 53     static InetSocketAddress createSocketAddress(int testMcastPort) throws Exception {
 54         InetAddress localAddress = InetAddress.getLocalHost();
 55         InetSocketAddress localSocketAddress = new InetSocketAddress(localAddress, testMcastPort);
 56         return localSocketAddress;
 57     }
 58 
 59     /* standalone interface */
 60     public static void main(String argv[]) throws Exception {
 61         ReuseAddressTest test = new ReuseAddressTest();
 62         test.DatagramSocket0029();
 63         test.DatagramSocket0030();
 64         test.DatagramSocket0031();
 65         test.DatagramSocket0032();
 66         test.DatagramSocket0034();
 67         test.DatagramSocket0035();
 68         test.DatagramSocket2028();
 69         test.DatagramSocket2029();
 70         test.DatagramSocket2030();
 71 
 72     }
 73 
 74     /**
 75      * Equivalence class partitioning with input values orientation for public
 76      * void setReuseAddress(boolean on) throws SocketException,
 77      * &lt;br&gt;&lt;b&gt;on&lt;/b&gt;: false.
 78      * &lt;br&gt;&lt;b&gt;Expected results&lt;/b&gt;: getReuseAddress() will return false
 79      */
 80     public void DatagramSocket0029() throws Exception {
 81         String testCaseID = &quot;DatagramSocket0029&quot;;
 82         System.out.println(&quot; &gt;&gt; &quot; + testCaseID + &quot;: &quot; + &quot;public void setReuseAddress(boolean on) throws SocketException&quot;);
 83 
 84         DatagramSocket ds = null;
 85         try {
 86             ds = new DatagramSocket(null);
 87             ds.setReuseAddress(false);
 88             if (ds.getReuseAddress() == true) {
 89                 throw new RuntimeException(&quot;SO_REUSEADDR is not set to false&quot;);
 90             }
 91         } catch (IOException e) {
 92             e.printStackTrace(System.out);
 93             throw new RuntimeException(&quot;unexpected: &quot; + e);
 94         } catch (SecurityException e) {
 95             System.out.println(&quot;Security restriction&quot;);
 96         } finally {
 97             if (ds != null) {
 98                 ds.close();
 99             }
100         }
101 
102         System.out.println(&quot;OKAY&quot;);
103     }
104 
105     /**
106      * Equivalence class partitioning with input values orientation for public
107      * void setReuseAddress(boolean on) throws SocketException,
108      * &lt;br&gt;&lt;b&gt;on&lt;/b&gt;: true.
109      * &lt;br&gt;&lt;b&gt;Expected results&lt;/b&gt;: Allows completely duplicate bindings (same
110      * address and port) on multicast sockets
111      */
112     public void DatagramSocket0030() throws Exception {
113         String testCaseID = &quot;DatagramSocket0030&quot;;
114         System.out.println(&quot; &gt;&gt; &quot; + testCaseID + &quot;: &quot; + &quot;public void setReuseAddress(boolean on) throws SocketException&quot;);
115 
116         MulticastSocket ms1 = null;
117         MulticastSocket ms2 = null;
118         try {
<a name="3" id="anc3"></a><span class="line-modified">119             InetSocketAddress addr = createSocketAddress(5050);</span>
120 
121             ms1 = new MulticastSocket(null);
122             ms1.setReuseAddress(true);
123             if (!ms1.getReuseAddress()) {
124                 System.out.println(&quot;Cannot check: &quot;
125                         + &quot; safety for SO_REUSEADDR option is not guaranteed&quot;);
126             }
127 
128             try {
129                 ms1.bind(addr);
130             } catch (SocketException e) {
131                 throw new RuntimeException(&quot;cannot bind first socket to &quot; + addr
132                         + &quot; unexpected &quot; + e);
133             }
134 
<a name="4" id="anc4"></a>
135             ms2 = new MulticastSocket(null);
136             ms2.setReuseAddress(true);
137             if (!ms2.getReuseAddress()) {
138                 System.out.println(&quot;Cannot check: &quot;
139                         + &quot; safety for SO_REUSEADDR option is not guaranteed&quot;);
140             }
141 
142             try {
143                 ms2.bind(addr);
144             } catch (SocketException e) {
145                 throw new RuntimeException(&quot;cannot bind second socket to &quot; + addr
146                         + &quot; unexpected &quot; + e);
147             }
148 
149             if (ms1.getLocalPort() != addr.getPort() || !ms1.isBound()
150                     || ms2.getLocalPort() != addr.getPort() || !ms2.isBound()) {
151                 System.out.println(&quot;bind() fails with: &quot; + addr);
152                 System.out.println(&quot;  ms1 [&quot; + getInfo(ms1) + &quot;]&quot;);
153                 System.out.println(&quot;  ms2 [&quot; + getInfo(ms2) + &quot;]&quot;);
154                 System.out.println(&quot;  getReuseAddress(): &quot; + ms2.getReuseAddress());
155                 throw new RuntimeException(&quot;bind() fails with: &quot; + addr);
156             }
157 
158         } catch (IOException e) {
159             e.printStackTrace(System.out);
160             throw new RuntimeException(&quot;unexpected: &quot; + e);
161         } catch (SecurityException e) {
162             System.out.println(&quot;Security restriction&quot;);
163         } finally {
164             if (ms1 != null) {
165                 ms1.close();
166             }
167             if (ms2 != null) {
168                 ms2.close();
169             }
170         }
171 
172         System.out.println(&quot;OKAY&quot;);
173     }
174 
175     /**
176      * Equivalence class partitioning with input values orientation for public
177      * void setReuseAddress(boolean on) throws SocketException,
178      * &lt;br&gt;&lt;b&gt;on&lt;/b&gt;: false.
179      * &lt;br&gt;&lt;b&gt;Expected results&lt;/b&gt;: The second bind will throw SocketException,
180      * when SO_REUSEADDR disable
181      */
182     public void DatagramSocket0031() throws Exception {
183         String testCaseID = &quot;DatagramSocket0031&quot;;
184         System.out.println(&quot; &gt;&gt; &quot; + testCaseID + &quot;: &quot; + &quot;public void setReuseAddress(boolean on) throws SocketException&quot;);
185 
186         MulticastSocket ms1 = null;
187         MulticastSocket ms2 = null;
188         try {
<a name="5" id="anc5"></a><span class="line-modified">189             InetSocketAddress addr = createSocketAddress(6060);</span>
190 
191             ms1 = new MulticastSocket(null);
192             try {
193                 ms1.bind(addr);
194             } catch (SocketException e) {
195                 throw new RuntimeException(&quot;cannot bind first socket to &quot; + addr
196                         + &quot; unexpected &quot; + e);
197             }
198 
<a name="6" id="anc6"></a>
199             ms2 = new MulticastSocket(null);
200             ms2.setReuseAddress(false);  // method under test
201 
202             try {
203                 ms2.bind(addr);
204                 System.out.println(&quot;No exceptions: &quot;);
205                 System.out.println(&quot;  addr: &quot; + addr);
206                 System.out.println(&quot;  ms1 [&quot; + getInfo(ms1) + &quot;]&quot;);
207                 System.out.println(&quot;  ms2 [&quot; + getInfo(ms2) + &quot;]&quot;);
208                 System.out.println(&quot;  getReuseAddress(): &quot; + ms2.getReuseAddress());
209                 throw new RuntimeException(&quot;no exceptions from bind() with &quot; + addr);
210             } catch (SocketException e) {
211             }
212 
213         } catch (IOException e) {
214             e.printStackTrace(System.out);
215             throw new RuntimeException(&quot;unexpected: &quot; + e);
216         } catch (SecurityException e) {
217             System.out.println(&quot;Security restriction&quot;);
218         } finally {
219             if (ms1 != null) {
220                 ms1.close();
221             }
222             if (ms2 != null) {
223                 ms2.close();
224             }
225         }
226 
227         System.out.println(&quot;OKAY&quot;);
228     }
229 
230     /**
231      * Equivalence class partitioning with input values orientation for public
232      * void setReuseAddress(boolean on) throws SocketException,
233      * &lt;br&gt;&lt;b&gt;on&lt;/b&gt;: true.
234      * &lt;br&gt;&lt;b&gt;Expected results&lt;/b&gt;: Allows a single process to bind the same
235      * port to multiple sockets as long as each bind specifies a different local
236      * IP address
237      */
238     public void DatagramSocket0032() throws Exception {
239         String testCaseID = &quot;DatagramSocket0032&quot;;
240         System.out.println(&quot; &gt;&gt; &quot; + testCaseID + &quot;: &quot; + &quot;public void setReuseAddress(boolean on) throws SocketException&quot;);
241 
242         DatagramSocket ds1 = null;
243         DatagramSocket ds2 = null;
244         try {
245 
<a name="7" id="anc7"></a><span class="line-modified">246             InetSocketAddress isa = createSocketAddress(7070);</span>
<span class="line-modified">247             InetAddress addr = isa.getAddress();</span>
248             InetAddress wildcard = InetAddress.getByName(&quot;0.0.0.0&quot;);
249             if (addr.equals(wildcard) || addr.isLoopbackAddress()) {
250                 System.out.println(&quot;Cannot check: addresses are equal&quot;);
251             }
252 
<a name="8" id="anc8"></a><span class="line-removed">253             InetSocketAddress isa1 = new InetSocketAddress(addr, isa.getPort());</span>
<span class="line-removed">254             InetSocketAddress isa2 = new InetSocketAddress(wildcard, isa.getPort());</span>
255 
256             ds1 = new DatagramSocket(null);
257             ds1.setReuseAddress(true);    // method under test
258             if (!ds1.getReuseAddress()) {
259                 System.out.println(&quot;Cannot check: &quot;
260                         + &quot; safety for SO_REUSEADDR option is not guaranteed&quot;);
261             }
262             ds1.bind(isa1);
263 
<a name="9" id="anc9"></a>

264             ds2 = new DatagramSocket(null);
265             ds2.setReuseAddress(true);    // method under test
266             if (!ds2.getReuseAddress()) {
267                 System.out.println(&quot;Cannot check: &quot;
268                         + &quot; safety for SO_REUSEADDR option is not guaranteed&quot;);
269             }
270 
271             try {
272                 ds2.bind(isa2);
273             } catch (SocketException e) {
274                 throw new RuntimeException(&quot;cannot bind second socket to &quot; + isa2
275                         + &quot; unexpected &quot; + e);
276             }
277 
<a name="10" id="anc10"></a><span class="line-modified">278             if (ds1.getLocalPort() != isa.getPort() || !ds1.isBound()</span>
<span class="line-modified">279                     || ds2.getLocalPort() != isa.getPort() || !ds2.isBound()) {</span>
280                 System.out.println(&quot;bind() fails with: &quot; + addr);
281                 System.out.println(&quot;  ds1 [&quot; + getInfo(ds1) + &quot;]&quot;);
282                 System.out.println(&quot;  ds2 [&quot; + getInfo(ds2) + &quot;]&quot;);
283                 System.out.println(&quot;  getReuseAddress(): &quot; + ds2.getReuseAddress());
284                 throw new RuntimeException(&quot;bind() fails with: &quot; + addr);
285             }
286 
287         } catch (IOException e) {
288             e.printStackTrace(System.out);
289             throw new RuntimeException(&quot;unexpected: &quot; + e);
290         } catch (SecurityException e) {
291             System.out.println(&quot;Security restriction&quot;);
292         } finally {
293             if (ds1 != null) {
294                 ds1.close();
295             }
296             if (ds2 != null) {
297                 ds2.close();
298             }
299         }
300 
301         System.out.println(&quot;OKAY&quot;);
302     }
303 
304     /**
305      * Assertion testing for public int getTrafficClass() throws
306      * SocketException, will return a number in range from 0 to 255 or throw
307      * SocketException.
308      */
309     public void DatagramSocket2028() throws Exception {
310         String testCaseID = &quot;DatagramSocket2028&quot;;
311         System.out.println(&quot; &gt;&gt; &quot; + testCaseID + &quot;: &quot; + &quot;public int getTrafficClass() throws SocketException&quot;);
312 
313         DatagramSocket ds = null;
314         try {
315             ds = new DatagramSocket();
316             int tc = ds.getTrafficClass();
317             if (tc &lt; 0 || tc &gt; 255) {
318                 throw new RuntimeException(&quot;getTrafficClass() returns: &quot; + tc);
319             }
320         } catch (SecurityException e) {
321             System.out.println(&quot;Security restriction: &quot; + e);
322         } catch (SocketException e) {
323             e.printStackTrace(System.out);
324             throw new RuntimeException(&quot;Unexpected exception : &quot; + e);
325         } finally {
326             if (ds != null) {
327                 ds.close();
328             }
329         }
330 
331         System.out.println(&quot;OKAY&quot;);
332     }
333 
334     /**
335      * Assertion testing for public void setTrafficClass(int tc) throws
336      * SocketException, IAE will be thrown with tc less than 0 or greater than
337      * 255.
338      */
339     public void DatagramSocket2029() throws Exception {
340         String testCaseID = &quot;DatagramSocket2029&quot;;
341         System.out.println(&quot; &gt;&gt; &quot; + testCaseID + &quot;: &quot; + &quot;public void setTrafficClass(int tc) throws SocketException&quot;);
342 
343         DatagramSocket ds = null;
344         try {
345             ds = new DatagramSocket();
346         } catch (SecurityException e) {
347             System.out.println(&quot;Security restriction: &quot; + e);
348         } catch (IOException e) {
349             e.printStackTrace(System.out);
350             throw new RuntimeException(&quot;cannot create socket: &quot; + e);
351         }
352 
353         int[] values = {
354             Integer.MIN_VALUE, Integer.MIN_VALUE + 1, -1000, -2, -1,
355             256, 257, 1000, 50000, Integer.MAX_VALUE - 1, Integer.MAX_VALUE
356         };
357 
358         for (int i = 0; i &lt; values.length; i++) {
359             try {
360                 ds.setTrafficClass(values[i]);
361                 System.out.println(&quot;No exception with: &quot; + values[i]);
362                 System.out.println(&quot;getTrafficClass() returns: &quot; + ds.getTrafficClass());
363                 ds.close();
364                 throw new RuntimeException(&quot;setTrafficClass() fails with : &quot; + values[i]);
365             } catch (SocketException e) {
366                 ds.close();
367                 e.printStackTrace(System.out);
368                 throw new RuntimeException(&quot;setTrafficClass() throws : &quot; + e);
369             } catch (IllegalArgumentException e) {
370             }
371         }
372 
373         System.out.println(&quot;OKAY&quot;);
374     }
375 
376     /**
377      * Assertion testing for public void setTrafficClass(int tc) throws
378      * SocketException, only SocketException may be thrown with tc in range from
379      * 0 to 255.
380      */
381     public void DatagramSocket2030() throws Exception {
382         String testCaseID = &quot;DatagramSocket2030&quot;;
383         System.out.println(&quot; &gt;&gt; &quot; + testCaseID + &quot;: &quot; + &quot;public void setTrafficClass(int tc) throws SocketException&quot;);
384 
385         DatagramSocket ds = null;
386         try {
387             ds = new DatagramSocket();
388         } catch (SecurityException e) {
389             System.out.println(&quot;Security restriction: &quot; + e);
390         } catch (IOException e) {
391             e.printStackTrace(System.out);
392             throw new RuntimeException(&quot;cannot create socket: &quot; + e);
393         }
394 
395         for (int i = 0; i &lt;= 255; i++) {
396             try {
397                 ds.setTrafficClass(i);
398             } catch (SocketException e) {
399             }
400         }
401 
402         System.out.println(&quot;OKAY&quot;);
403     }
404 
405     /**
406      * Equivalence class partitioning with input values orientation for public
407      * void setBroadcast(boolean on) throws SocketException,
408      * &lt;br&gt;&lt;b&gt;on&lt;/b&gt;: false.
409      * &lt;br&gt;&lt;b&gt;Expected results&lt;/b&gt;: getBroadcast() will return false
410      */
411     public void DatagramSocket0034() throws Exception {
412         String testCaseID = &quot;DatagramSocket0034&quot;;
413         System.out.println(&quot; &gt;&gt; &quot; + testCaseID + &quot;: &quot; + &quot;public void setBroadcast(boolean on) throws SocketException&quot;);
414 
415         DatagramSocket ds = null;
416         try {
417             ds = new DatagramSocket();
418             ds.setBroadcast(false);
419             if (ds.getBroadcast() == true) {
420                 throw new RuntimeException(&quot;SO_BROADCAST is not set to false&quot;);
421             }
422         } catch (IOException e) {
423             e.printStackTrace(System.out);
424             throw new RuntimeException(&quot;unexpected: &quot; + e);
425         } catch (SecurityException e) {
426             System.out.println(&quot;Security restriction&quot;);
427         } finally {
428             if (ds != null) {
429                 ds.close();
430             }
431         }
432 
433         System.out.println(&quot;OKAY&quot;);
434     }
435 
436     /**
437      * Equivalence class partitioning with input values orientation for public
438      * void setBroadcast(boolean on) throws SocketException,
439      * &lt;br&gt;&lt;b&gt;on&lt;/b&gt;: true.
440      * &lt;br&gt;&lt;b&gt;Expected results&lt;/b&gt;: getBroadcast() will return true
441      */
442     public void DatagramSocket0035() throws Exception {
443         String testCaseID = &quot;DatagramSocket0035&quot;;
444         System.out.println(&quot; &gt;&gt; &quot; + testCaseID + &quot;: &quot; + &quot;public void setBroadcast(boolean on) throws SocketException&quot;);
445 
446         DatagramSocket ds = null;
447         try {
448             ds = new DatagramSocket();
449             ds.setBroadcast(true);
450             if (ds.getBroadcast() == false) {
451                 throw new RuntimeException(&quot;SO_BROADCAST is not set to true&quot;);
452             }
453         } catch (IOException e) {
454             e.printStackTrace(System.out);
455             throw new RuntimeException(&quot;unexpected: &quot; + e);
456         } catch (SecurityException e) {
457             System.out.println(&quot;Security restriction&quot;);
458         } finally {
459             if (ds != null) {
460                 ds.close();
461             }
462         }
463 
464         System.out.println(&quot;OKAY&quot;);
465     }
466 }
<a name="11" id="anc11"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="11" type="hidden" />
</body>
</html>
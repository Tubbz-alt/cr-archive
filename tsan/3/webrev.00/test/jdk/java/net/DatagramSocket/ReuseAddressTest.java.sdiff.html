<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff test/jdk/java/net/DatagramSocket/ReuseAddressTest.java</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
<body>
<center><a href="PortUnreachable.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="Send12k.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>test/jdk/java/net/DatagramSocket/ReuseAddressTest.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
<span class="line-modified">  1 /* Copyright (c) 2016, Oracle and/or its affiliates. All rights reserved.</span>
  2  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  3  *
  4  * This code is free software; you can redistribute it and/or modify it
  5  * under the terms of the GNU General Public License version 2 only, as
  6  * published by the Free Software Foundation.
  7  *
  8  * This code is distributed in the hope that it will be useful, but WITHOUT
  9  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 10  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 11  * version 2 for more details (a copy is included in the LICENSE file that
 12  * accompanied this code).
 13  *
 14  * You should have received a copy of the GNU General Public License version
 15  * 2 along with this work; if not, write to the Free Software Foundation,
 16  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 17  *
 18  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 19  * or visit www.oracle.com if you need additional information or have any
 20  * questions.
 21  */
 22 
 23 import java.io.IOException;
 24 import java.net.DatagramSocket;
 25 import java.net.InetAddress;
 26 import java.net.InetSocketAddress;
 27 import java.net.MulticastSocket;
 28 import java.net.SocketException;
 29 
 30 /*
 31  * @test
 32  * @bug 8153674



 33  * @summary Expected SocketException not thrown when calling bind() with
 34  *   setReuseAddress(false)
 35  * @run main/othervm ReuseAddressTest
 36  */
 37 
 38 public class ReuseAddressTest {
 39 
 40     String getInfo(DatagramSocket soc) {
 41         if (soc == null) {
 42             return null;
 43         }
 44 
 45         return &quot;localPort: &quot; + soc.getLocalPort()
 46                 + &quot;; localAddress: &quot; + soc.getLocalAddress()
 47                 + &quot;; remotePort: &quot; + soc.getPort()
 48                 + &quot;; remoteAddress: &quot; + soc.getInetAddress()
 49                 + &quot;; isClosed: &quot; + soc.isClosed()
 50                 + &quot;; isBound: &quot; + soc.isBound();
 51     }
 52 
</pre>
<hr />
<pre>
 99             }
100         }
101 
102         System.out.println(&quot;OKAY&quot;);
103     }
104 
105     /**
106      * Equivalence class partitioning with input values orientation for public
107      * void setReuseAddress(boolean on) throws SocketException,
108      * &lt;br&gt;&lt;b&gt;on&lt;/b&gt;: true.
109      * &lt;br&gt;&lt;b&gt;Expected results&lt;/b&gt;: Allows completely duplicate bindings (same
110      * address and port) on multicast sockets
111      */
112     public void DatagramSocket0030() throws Exception {
113         String testCaseID = &quot;DatagramSocket0030&quot;;
114         System.out.println(&quot; &gt;&gt; &quot; + testCaseID + &quot;: &quot; + &quot;public void setReuseAddress(boolean on) throws SocketException&quot;);
115 
116         MulticastSocket ms1 = null;
117         MulticastSocket ms2 = null;
118         try {
<span class="line-modified">119             InetSocketAddress addr = createSocketAddress(5050);</span>
120 
121             ms1 = new MulticastSocket(null);
122             ms1.setReuseAddress(true);
123             if (!ms1.getReuseAddress()) {
124                 System.out.println(&quot;Cannot check: &quot;
125                         + &quot; safety for SO_REUSEADDR option is not guaranteed&quot;);
126             }
127 
128             try {
129                 ms1.bind(addr);
130             } catch (SocketException e) {
131                 throw new RuntimeException(&quot;cannot bind first socket to &quot; + addr
132                         + &quot; unexpected &quot; + e);
133             }
134 

135             ms2 = new MulticastSocket(null);
136             ms2.setReuseAddress(true);
137             if (!ms2.getReuseAddress()) {
138                 System.out.println(&quot;Cannot check: &quot;
139                         + &quot; safety for SO_REUSEADDR option is not guaranteed&quot;);
140             }
141 
142             try {
143                 ms2.bind(addr);
144             } catch (SocketException e) {
145                 throw new RuntimeException(&quot;cannot bind second socket to &quot; + addr
146                         + &quot; unexpected &quot; + e);
147             }
148 
149             if (ms1.getLocalPort() != addr.getPort() || !ms1.isBound()
150                     || ms2.getLocalPort() != addr.getPort() || !ms2.isBound()) {
151                 System.out.println(&quot;bind() fails with: &quot; + addr);
152                 System.out.println(&quot;  ms1 [&quot; + getInfo(ms1) + &quot;]&quot;);
153                 System.out.println(&quot;  ms2 [&quot; + getInfo(ms2) + &quot;]&quot;);
154                 System.out.println(&quot;  getReuseAddress(): &quot; + ms2.getReuseAddress());
</pre>
<hr />
<pre>
169             }
170         }
171 
172         System.out.println(&quot;OKAY&quot;);
173     }
174 
175     /**
176      * Equivalence class partitioning with input values orientation for public
177      * void setReuseAddress(boolean on) throws SocketException,
178      * &lt;br&gt;&lt;b&gt;on&lt;/b&gt;: false.
179      * &lt;br&gt;&lt;b&gt;Expected results&lt;/b&gt;: The second bind will throw SocketException,
180      * when SO_REUSEADDR disable
181      */
182     public void DatagramSocket0031() throws Exception {
183         String testCaseID = &quot;DatagramSocket0031&quot;;
184         System.out.println(&quot; &gt;&gt; &quot; + testCaseID + &quot;: &quot; + &quot;public void setReuseAddress(boolean on) throws SocketException&quot;);
185 
186         MulticastSocket ms1 = null;
187         MulticastSocket ms2 = null;
188         try {
<span class="line-modified">189             InetSocketAddress addr = createSocketAddress(6060);</span>
190 
191             ms1 = new MulticastSocket(null);
192             try {
193                 ms1.bind(addr);
194             } catch (SocketException e) {
195                 throw new RuntimeException(&quot;cannot bind first socket to &quot; + addr
196                         + &quot; unexpected &quot; + e);
197             }
198 

199             ms2 = new MulticastSocket(null);
200             ms2.setReuseAddress(false);  // method under test
201 
202             try {
203                 ms2.bind(addr);
204                 System.out.println(&quot;No exceptions: &quot;);
205                 System.out.println(&quot;  addr: &quot; + addr);
206                 System.out.println(&quot;  ms1 [&quot; + getInfo(ms1) + &quot;]&quot;);
207                 System.out.println(&quot;  ms2 [&quot; + getInfo(ms2) + &quot;]&quot;);
208                 System.out.println(&quot;  getReuseAddress(): &quot; + ms2.getReuseAddress());
209                 throw new RuntimeException(&quot;no exceptions from bind() with &quot; + addr);
210             } catch (SocketException e) {
211             }
212 
213         } catch (IOException e) {
214             e.printStackTrace(System.out);
215             throw new RuntimeException(&quot;unexpected: &quot; + e);
216         } catch (SecurityException e) {
217             System.out.println(&quot;Security restriction&quot;);
218         } finally {
</pre>
<hr />
<pre>
226 
227         System.out.println(&quot;OKAY&quot;);
228     }
229 
230     /**
231      * Equivalence class partitioning with input values orientation for public
232      * void setReuseAddress(boolean on) throws SocketException,
233      * &lt;br&gt;&lt;b&gt;on&lt;/b&gt;: true.
234      * &lt;br&gt;&lt;b&gt;Expected results&lt;/b&gt;: Allows a single process to bind the same
235      * port to multiple sockets as long as each bind specifies a different local
236      * IP address
237      */
238     public void DatagramSocket0032() throws Exception {
239         String testCaseID = &quot;DatagramSocket0032&quot;;
240         System.out.println(&quot; &gt;&gt; &quot; + testCaseID + &quot;: &quot; + &quot;public void setReuseAddress(boolean on) throws SocketException&quot;);
241 
242         DatagramSocket ds1 = null;
243         DatagramSocket ds2 = null;
244         try {
245 
<span class="line-modified">246             InetSocketAddress isa = createSocketAddress(7070);</span>
<span class="line-modified">247             InetAddress addr = isa.getAddress();</span>
248             InetAddress wildcard = InetAddress.getByName(&quot;0.0.0.0&quot;);
249             if (addr.equals(wildcard) || addr.isLoopbackAddress()) {
250                 System.out.println(&quot;Cannot check: addresses are equal&quot;);
251             }
252 
<span class="line-removed">253             InetSocketAddress isa1 = new InetSocketAddress(addr, isa.getPort());</span>
<span class="line-removed">254             InetSocketAddress isa2 = new InetSocketAddress(wildcard, isa.getPort());</span>
255 
256             ds1 = new DatagramSocket(null);
257             ds1.setReuseAddress(true);    // method under test
258             if (!ds1.getReuseAddress()) {
259                 System.out.println(&quot;Cannot check: &quot;
260                         + &quot; safety for SO_REUSEADDR option is not guaranteed&quot;);
261             }
262             ds1.bind(isa1);
263 


264             ds2 = new DatagramSocket(null);
265             ds2.setReuseAddress(true);    // method under test
266             if (!ds2.getReuseAddress()) {
267                 System.out.println(&quot;Cannot check: &quot;
268                         + &quot; safety for SO_REUSEADDR option is not guaranteed&quot;);
269             }
270 
271             try {
272                 ds2.bind(isa2);
273             } catch (SocketException e) {
274                 throw new RuntimeException(&quot;cannot bind second socket to &quot; + isa2
275                         + &quot; unexpected &quot; + e);
276             }
277 
<span class="line-modified">278             if (ds1.getLocalPort() != isa.getPort() || !ds1.isBound()</span>
<span class="line-modified">279                     || ds2.getLocalPort() != isa.getPort() || !ds2.isBound()) {</span>
280                 System.out.println(&quot;bind() fails with: &quot; + addr);
281                 System.out.println(&quot;  ds1 [&quot; + getInfo(ds1) + &quot;]&quot;);
282                 System.out.println(&quot;  ds2 [&quot; + getInfo(ds2) + &quot;]&quot;);
283                 System.out.println(&quot;  getReuseAddress(): &quot; + ds2.getReuseAddress());
284                 throw new RuntimeException(&quot;bind() fails with: &quot; + addr);
285             }
286 
287         } catch (IOException e) {
288             e.printStackTrace(System.out);
289             throw new RuntimeException(&quot;unexpected: &quot; + e);
290         } catch (SecurityException e) {
291             System.out.println(&quot;Security restriction&quot;);
292         } finally {
293             if (ds1 != null) {
294                 ds1.close();
295             }
296             if (ds2 != null) {
297                 ds2.close();
298             }
299         }
</pre>
</td>
<td>
<hr />
<pre>
<span class="line-modified">  1 /* Copyright (c) 2016, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  2  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  3  *
  4  * This code is free software; you can redistribute it and/or modify it
  5  * under the terms of the GNU General Public License version 2 only, as
  6  * published by the Free Software Foundation.
  7  *
  8  * This code is distributed in the hope that it will be useful, but WITHOUT
  9  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 10  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 11  * version 2 for more details (a copy is included in the LICENSE file that
 12  * accompanied this code).
 13  *
 14  * You should have received a copy of the GNU General Public License version
 15  * 2 along with this work; if not, write to the Free Software Foundation,
 16  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 17  *
 18  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 19  * or visit www.oracle.com if you need additional information or have any
 20  * questions.
 21  */
 22 
 23 import java.io.IOException;
 24 import java.net.DatagramSocket;
 25 import java.net.InetAddress;
 26 import java.net.InetSocketAddress;
 27 import java.net.MulticastSocket;
 28 import java.net.SocketException;
 29 
 30 /*
 31  * @test
 32  * @bug 8153674
<span class="line-added"> 33  * @key intermittent</span>
<span class="line-added"> 34  * @summary This test might fail intermittently as it needs a UDP socket that</span>
<span class="line-added"> 35  *          binds to the wildcard address.</span>
 36  * @summary Expected SocketException not thrown when calling bind() with
 37  *   setReuseAddress(false)
 38  * @run main/othervm ReuseAddressTest
 39  */
 40 
 41 public class ReuseAddressTest {
 42 
 43     String getInfo(DatagramSocket soc) {
 44         if (soc == null) {
 45             return null;
 46         }
 47 
 48         return &quot;localPort: &quot; + soc.getLocalPort()
 49                 + &quot;; localAddress: &quot; + soc.getLocalAddress()
 50                 + &quot;; remotePort: &quot; + soc.getPort()
 51                 + &quot;; remoteAddress: &quot; + soc.getInetAddress()
 52                 + &quot;; isClosed: &quot; + soc.isClosed()
 53                 + &quot;; isBound: &quot; + soc.isBound();
 54     }
 55 
</pre>
<hr />
<pre>
102             }
103         }
104 
105         System.out.println(&quot;OKAY&quot;);
106     }
107 
108     /**
109      * Equivalence class partitioning with input values orientation for public
110      * void setReuseAddress(boolean on) throws SocketException,
111      * &lt;br&gt;&lt;b&gt;on&lt;/b&gt;: true.
112      * &lt;br&gt;&lt;b&gt;Expected results&lt;/b&gt;: Allows completely duplicate bindings (same
113      * address and port) on multicast sockets
114      */
115     public void DatagramSocket0030() throws Exception {
116         String testCaseID = &quot;DatagramSocket0030&quot;;
117         System.out.println(&quot; &gt;&gt; &quot; + testCaseID + &quot;: &quot; + &quot;public void setReuseAddress(boolean on) throws SocketException&quot;);
118 
119         MulticastSocket ms1 = null;
120         MulticastSocket ms2 = null;
121         try {
<span class="line-modified">122             InetSocketAddress addr = createSocketAddress(0);</span>
123 
124             ms1 = new MulticastSocket(null);
125             ms1.setReuseAddress(true);
126             if (!ms1.getReuseAddress()) {
127                 System.out.println(&quot;Cannot check: &quot;
128                         + &quot; safety for SO_REUSEADDR option is not guaranteed&quot;);
129             }
130 
131             try {
132                 ms1.bind(addr);
133             } catch (SocketException e) {
134                 throw new RuntimeException(&quot;cannot bind first socket to &quot; + addr
135                         + &quot; unexpected &quot; + e);
136             }
137 
<span class="line-added">138             addr = createSocketAddress(ms1.getLocalPort());</span>
139             ms2 = new MulticastSocket(null);
140             ms2.setReuseAddress(true);
141             if (!ms2.getReuseAddress()) {
142                 System.out.println(&quot;Cannot check: &quot;
143                         + &quot; safety for SO_REUSEADDR option is not guaranteed&quot;);
144             }
145 
146             try {
147                 ms2.bind(addr);
148             } catch (SocketException e) {
149                 throw new RuntimeException(&quot;cannot bind second socket to &quot; + addr
150                         + &quot; unexpected &quot; + e);
151             }
152 
153             if (ms1.getLocalPort() != addr.getPort() || !ms1.isBound()
154                     || ms2.getLocalPort() != addr.getPort() || !ms2.isBound()) {
155                 System.out.println(&quot;bind() fails with: &quot; + addr);
156                 System.out.println(&quot;  ms1 [&quot; + getInfo(ms1) + &quot;]&quot;);
157                 System.out.println(&quot;  ms2 [&quot; + getInfo(ms2) + &quot;]&quot;);
158                 System.out.println(&quot;  getReuseAddress(): &quot; + ms2.getReuseAddress());
</pre>
<hr />
<pre>
173             }
174         }
175 
176         System.out.println(&quot;OKAY&quot;);
177     }
178 
179     /**
180      * Equivalence class partitioning with input values orientation for public
181      * void setReuseAddress(boolean on) throws SocketException,
182      * &lt;br&gt;&lt;b&gt;on&lt;/b&gt;: false.
183      * &lt;br&gt;&lt;b&gt;Expected results&lt;/b&gt;: The second bind will throw SocketException,
184      * when SO_REUSEADDR disable
185      */
186     public void DatagramSocket0031() throws Exception {
187         String testCaseID = &quot;DatagramSocket0031&quot;;
188         System.out.println(&quot; &gt;&gt; &quot; + testCaseID + &quot;: &quot; + &quot;public void setReuseAddress(boolean on) throws SocketException&quot;);
189 
190         MulticastSocket ms1 = null;
191         MulticastSocket ms2 = null;
192         try {
<span class="line-modified">193             InetSocketAddress addr = createSocketAddress(0);</span>
194 
195             ms1 = new MulticastSocket(null);
196             try {
197                 ms1.bind(addr);
198             } catch (SocketException e) {
199                 throw new RuntimeException(&quot;cannot bind first socket to &quot; + addr
200                         + &quot; unexpected &quot; + e);
201             }
202 
<span class="line-added">203             addr = createSocketAddress(ms1.getLocalPort());</span>
204             ms2 = new MulticastSocket(null);
205             ms2.setReuseAddress(false);  // method under test
206 
207             try {
208                 ms2.bind(addr);
209                 System.out.println(&quot;No exceptions: &quot;);
210                 System.out.println(&quot;  addr: &quot; + addr);
211                 System.out.println(&quot;  ms1 [&quot; + getInfo(ms1) + &quot;]&quot;);
212                 System.out.println(&quot;  ms2 [&quot; + getInfo(ms2) + &quot;]&quot;);
213                 System.out.println(&quot;  getReuseAddress(): &quot; + ms2.getReuseAddress());
214                 throw new RuntimeException(&quot;no exceptions from bind() with &quot; + addr);
215             } catch (SocketException e) {
216             }
217 
218         } catch (IOException e) {
219             e.printStackTrace(System.out);
220             throw new RuntimeException(&quot;unexpected: &quot; + e);
221         } catch (SecurityException e) {
222             System.out.println(&quot;Security restriction&quot;);
223         } finally {
</pre>
<hr />
<pre>
231 
232         System.out.println(&quot;OKAY&quot;);
233     }
234 
235     /**
236      * Equivalence class partitioning with input values orientation for public
237      * void setReuseAddress(boolean on) throws SocketException,
238      * &lt;br&gt;&lt;b&gt;on&lt;/b&gt;: true.
239      * &lt;br&gt;&lt;b&gt;Expected results&lt;/b&gt;: Allows a single process to bind the same
240      * port to multiple sockets as long as each bind specifies a different local
241      * IP address
242      */
243     public void DatagramSocket0032() throws Exception {
244         String testCaseID = &quot;DatagramSocket0032&quot;;
245         System.out.println(&quot; &gt;&gt; &quot; + testCaseID + &quot;: &quot; + &quot;public void setReuseAddress(boolean on) throws SocketException&quot;);
246 
247         DatagramSocket ds1 = null;
248         DatagramSocket ds2 = null;
249         try {
250 
<span class="line-modified">251             InetSocketAddress isa1 = createSocketAddress(0);</span>
<span class="line-modified">252             InetAddress addr = isa1.getAddress();</span>
253             InetAddress wildcard = InetAddress.getByName(&quot;0.0.0.0&quot;);
254             if (addr.equals(wildcard) || addr.isLoopbackAddress()) {
255                 System.out.println(&quot;Cannot check: addresses are equal&quot;);
256             }
257 


258 
259             ds1 = new DatagramSocket(null);
260             ds1.setReuseAddress(true);    // method under test
261             if (!ds1.getReuseAddress()) {
262                 System.out.println(&quot;Cannot check: &quot;
263                         + &quot; safety for SO_REUSEADDR option is not guaranteed&quot;);
264             }
265             ds1.bind(isa1);
266 
<span class="line-added">267             InetSocketAddress isa2 = new InetSocketAddress(wildcard, ds1.getLocalPort());</span>
<span class="line-added">268 </span>
269             ds2 = new DatagramSocket(null);
270             ds2.setReuseAddress(true);    // method under test
271             if (!ds2.getReuseAddress()) {
272                 System.out.println(&quot;Cannot check: &quot;
273                         + &quot; safety for SO_REUSEADDR option is not guaranteed&quot;);
274             }
275 
276             try {
277                 ds2.bind(isa2);
278             } catch (SocketException e) {
279                 throw new RuntimeException(&quot;cannot bind second socket to &quot; + isa2
280                         + &quot; unexpected &quot; + e);
281             }
282 
<span class="line-modified">283             if (ds1.getLocalPort() != ds2.getLocalPort() || !ds1.isBound()</span>
<span class="line-modified">284                     || !ds2.isBound()) {</span>
285                 System.out.println(&quot;bind() fails with: &quot; + addr);
286                 System.out.println(&quot;  ds1 [&quot; + getInfo(ds1) + &quot;]&quot;);
287                 System.out.println(&quot;  ds2 [&quot; + getInfo(ds2) + &quot;]&quot;);
288                 System.out.println(&quot;  getReuseAddress(): &quot; + ds2.getReuseAddress());
289                 throw new RuntimeException(&quot;bind() fails with: &quot; + addr);
290             }
291 
292         } catch (IOException e) {
293             e.printStackTrace(System.out);
294             throw new RuntimeException(&quot;unexpected: &quot; + e);
295         } catch (SecurityException e) {
296             System.out.println(&quot;Security restriction&quot;);
297         } finally {
298             if (ds1 != null) {
299                 ds1.close();
300             }
301             if (ds2 != null) {
302                 ds2.close();
303             }
304         }
</pre>
</td>
</tr>
</table>
<center><a href="PortUnreachable.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="Send12k.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
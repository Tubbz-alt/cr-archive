<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff test/jdk/java/net/DatagramSocket/UnreferencedDatagramSockets.java</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
<body>
<center><a href="SetReceiveBufferSize.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="../HttpCookie/ExpiredCookieTest.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>test/jdk/java/net/DatagramSocket/UnreferencedDatagramSockets.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2017, 2018, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 /**
 25  * @test

 26  * @modules java.management java.base/java.io:+open java.base/java.net:+open
 27  * @run main/othervm UnreferencedDatagramSockets
 28  * @run main/othervm -Djava.net.preferIPv4Stack=true UnreferencedDatagramSockets
 29  * @summary Check that unreferenced datagram sockets are closed
 30  */
 31 
 32 import java.io.FileDescriptor;
 33 import java.lang.management.ManagementFactory;
 34 import java.lang.management.OperatingSystemMXBean;
 35 import java.lang.ref.ReferenceQueue;
 36 import java.lang.ref.WeakReference;
 37 import java.lang.reflect.Field;
 38 import java.io.IOException;
 39 import java.net.DatagramPacket;
 40 import java.net.DatagramSocket;
 41 import java.net.DatagramSocketImpl;
 42 import java.net.InetAddress;
 43 import java.net.UnknownHostException;
 44 import java.nio.file.Files;
 45 import java.nio.file.Path;
 46 import java.nio.file.Paths;
 47 import java.util.ArrayDeque;
 48 import java.util.List;
 49 import java.util.Optional;
 50 import java.util.concurrent.TimeUnit;

 51 
 52 import com.sun.management.UnixOperatingSystemMXBean;
 53 


 54 public class UnreferencedDatagramSockets {
 55 
 56     /**
 57      * The set of sockets we have to check up on.
 58      */
 59     final static ArrayDeque&lt;NamedWeak&gt; pendingSockets = new ArrayDeque&lt;&gt;(5);
 60 
 61     /**
 62      * Queued objects when they are unreferenced.
 63      */
 64     final static ReferenceQueue&lt;Object&gt; pendingQueue = new ReferenceQueue&lt;&gt;();
 65 
 66     // Server to echo a datagram packet
 67     static class Server implements Runnable {
 68 
 69         DatagramSocket ss;

 70 
 71         Server() throws IOException {
<span class="line-modified"> 72             ss = new DatagramSocket(0);</span>
 73             System.out.printf(&quot;  DatagramServer addr: %s: %d%n&quot;,
 74                     this.getHost(), this.getPort());
 75             pendingSockets.add(new NamedWeak(ss, pendingQueue, &quot;serverDatagramSocket&quot;));
 76             extractRefs(ss, &quot;serverDatagramSocket&quot;);
 77         }
 78 
 79         InetAddress getHost() throws UnknownHostException {
<span class="line-modified"> 80             InetAddress localhost = InetAddress.getByName(&quot;localhost&quot;); //.getLocalHost();</span>
 81             return localhost;
 82         }
 83 
 84         int getPort() {
 85             return ss.getLocalPort();
 86         }
 87 
 88         // Receive a byte and send back a byte
 89         public void run() {
 90             try {
 91                 byte[] buffer = new byte[50];
 92                 DatagramPacket p = new DatagramPacket(buffer, buffer.length);
 93                 ss.receive(p);
 94                 buffer[0] += 1;
 95                 ss.send(p);         // send back +1
<span class="line-modified"> 96 </span>
 97                 // do NOT close but &#39;forget&#39; the datagram socket reference
 98                 ss = null;
 99             } catch (Exception ioe) {
100                 ioe.printStackTrace();
101             }
102         }
103     }
104 




105     public static void main(String args[]) throws Exception {

106 
107         // Create and close a DatagramSocket to warm up the FD count for side effects.
<span class="line-modified">108         try (DatagramSocket s = new DatagramSocket(0)) {</span>
109             // no-op; close immediately
110             s.getLocalPort();   // no-op
111         }
112 
113         long fdCount0 = getFdCount();
114         listProcFD();
115 
116         // start a server
117         Server svr = new Server();
118         Thread thr = new Thread(svr);
119         thr.start();
120 
<span class="line-modified">121         DatagramSocket client = new DatagramSocket(0);</span>
122         client.connect(svr.getHost(), svr.getPort());
123         pendingSockets.add(new NamedWeak(client, pendingQueue, &quot;clientDatagramSocket&quot;));
124         extractRefs(client, &quot;clientDatagramSocket&quot;);
125 
126         byte[] msg = new byte[1];
127         msg[0] = 1;
128         DatagramPacket p = new DatagramPacket(msg, msg.length, svr.getHost(), svr.getPort());
129         client.send(p);
130 
131         p = new DatagramPacket(msg, msg.length);
132         client.receive(p);


133 
134         System.out.printf(&quot;echo received from: %s%n&quot;, p.getSocketAddress());
135         if (msg[0] != 2) {
136             throw new AssertionError(&quot;incorrect data received: expected: 2, actual: &quot; + msg[0]);
137         }
138 
139         // Do NOT close the DatagramSocket; forget it
140 
141         Object ref;
142         int loops = 20;
143         while (!pendingSockets.isEmpty() &amp;&amp; loops-- &gt; 0) {
144             ref = pendingQueue.remove(1000L);
145             if (ref != null) {
146                 pendingSockets.remove(ref);
147                 System.out.printf(&quot;  ref freed: %s, remaining: %d%n&quot;, ref, pendingSockets.size());
148             } else {
149                 client = null;
150                 p = null;
151                 msg = null;
152                 System.gc();
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2017, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 /**
 25  * @test
<span class="line-added"> 26  * @library /test/lib</span>
 27  * @modules java.management java.base/java.io:+open java.base/java.net:+open
 28  * @run main/othervm UnreferencedDatagramSockets
 29  * @run main/othervm -Djava.net.preferIPv4Stack=true UnreferencedDatagramSockets
 30  * @summary Check that unreferenced datagram sockets are closed
 31  */
 32 
 33 import java.io.FileDescriptor;
 34 import java.lang.management.ManagementFactory;
 35 import java.lang.management.OperatingSystemMXBean;
 36 import java.lang.ref.ReferenceQueue;
 37 import java.lang.ref.WeakReference;
 38 import java.lang.reflect.Field;
 39 import java.io.IOException;
 40 import java.net.DatagramPacket;
 41 import java.net.DatagramSocket;
 42 import java.net.DatagramSocketImpl;
 43 import java.net.InetAddress;
 44 import java.net.UnknownHostException;
 45 import java.nio.file.Files;
 46 import java.nio.file.Path;
 47 import java.nio.file.Paths;
 48 import java.util.ArrayDeque;
 49 import java.util.List;
 50 import java.util.Optional;
 51 import java.util.concurrent.TimeUnit;
<span class="line-added"> 52 import java.util.concurrent.CountDownLatch;</span>
 53 
 54 import com.sun.management.UnixOperatingSystemMXBean;
 55 
<span class="line-added"> 56 import jdk.test.lib.net.IPSupport;</span>
<span class="line-added"> 57 </span>
 58 public class UnreferencedDatagramSockets {
 59 
 60     /**
 61      * The set of sockets we have to check up on.
 62      */
 63     final static ArrayDeque&lt;NamedWeak&gt; pendingSockets = new ArrayDeque&lt;&gt;(5);
 64 
 65     /**
 66      * Queued objects when they are unreferenced.
 67      */
 68     final static ReferenceQueue&lt;Object&gt; pendingQueue = new ReferenceQueue&lt;&gt;();
 69 
 70     // Server to echo a datagram packet
 71     static class Server implements Runnable {
 72 
 73         DatagramSocket ss;
<span class="line-added"> 74         CountDownLatch latch = new CountDownLatch(1);</span>
 75 
 76         Server() throws IOException {
<span class="line-modified"> 77             ss = new DatagramSocket(0, getHost());</span>
 78             System.out.printf(&quot;  DatagramServer addr: %s: %d%n&quot;,
 79                     this.getHost(), this.getPort());
 80             pendingSockets.add(new NamedWeak(ss, pendingQueue, &quot;serverDatagramSocket&quot;));
 81             extractRefs(ss, &quot;serverDatagramSocket&quot;);
 82         }
 83 
 84         InetAddress getHost() throws UnknownHostException {
<span class="line-modified"> 85             InetAddress localhost = lookupLocalHost();</span>
 86             return localhost;
 87         }
 88 
 89         int getPort() {
 90             return ss.getLocalPort();
 91         }
 92 
 93         // Receive a byte and send back a byte
 94         public void run() {
 95             try {
 96                 byte[] buffer = new byte[50];
 97                 DatagramPacket p = new DatagramPacket(buffer, buffer.length);
 98                 ss.receive(p);
 99                 buffer[0] += 1;
100                 ss.send(p);         // send back +1
<span class="line-modified">101                 latch.await();      // wait for the client to receive the packet</span>
102                 // do NOT close but &#39;forget&#39; the datagram socket reference
103                 ss = null;
104             } catch (Exception ioe) {
105                 ioe.printStackTrace();
106             }
107         }
108     }
109 
<span class="line-added">110     static InetAddress lookupLocalHost() throws UnknownHostException {</span>
<span class="line-added">111         return InetAddress.getByName(&quot;localhost&quot;); //.getLocalHost();</span>
<span class="line-added">112     }</span>
<span class="line-added">113 </span>
114     public static void main(String args[]) throws Exception {
<span class="line-added">115         IPSupport.throwSkippedExceptionIfNonOperational();</span>
116 
117         // Create and close a DatagramSocket to warm up the FD count for side effects.
<span class="line-modified">118         try (DatagramSocket s = new DatagramSocket(0, lookupLocalHost())) {</span>
119             // no-op; close immediately
120             s.getLocalPort();   // no-op
121         }
122 
123         long fdCount0 = getFdCount();
124         listProcFD();
125 
126         // start a server
127         Server svr = new Server();
128         Thread thr = new Thread(svr);
129         thr.start();
130 
<span class="line-modified">131         DatagramSocket client = new DatagramSocket(0, lookupLocalHost());</span>
132         client.connect(svr.getHost(), svr.getPort());
133         pendingSockets.add(new NamedWeak(client, pendingQueue, &quot;clientDatagramSocket&quot;));
134         extractRefs(client, &quot;clientDatagramSocket&quot;);
135 
136         byte[] msg = new byte[1];
137         msg[0] = 1;
138         DatagramPacket p = new DatagramPacket(msg, msg.length, svr.getHost(), svr.getPort());
139         client.send(p);
140 
141         p = new DatagramPacket(msg, msg.length);
142         client.receive(p);
<span class="line-added">143         svr.latch.countDown(); // unblock the server</span>
<span class="line-added">144 </span>
145 
146         System.out.printf(&quot;echo received from: %s%n&quot;, p.getSocketAddress());
147         if (msg[0] != 2) {
148             throw new AssertionError(&quot;incorrect data received: expected: 2, actual: &quot; + msg[0]);
149         }
150 
151         // Do NOT close the DatagramSocket; forget it
152 
153         Object ref;
154         int loops = 20;
155         while (!pendingSockets.isEmpty() &amp;&amp; loops-- &gt; 0) {
156             ref = pendingQueue.remove(1000L);
157             if (ref != null) {
158                 pendingSockets.remove(ref);
159                 System.out.printf(&quot;  ref freed: %s, remaining: %d%n&quot;, ref, pendingSockets.size());
160             } else {
161                 client = null;
162                 p = null;
163                 msg = null;
164                 System.gc();
</pre>
</td>
</tr>
</table>
<center><a href="SetReceiveBufferSize.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="../HttpCookie/ExpiredCookieTest.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
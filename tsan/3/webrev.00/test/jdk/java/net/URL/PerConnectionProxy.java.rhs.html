<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames test/jdk/java/net/URL/PerConnectionProxy.java</title>
    <link rel="stylesheet" href="../../../../../style.css" />
    <script type="text/javascript" src="../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
<a name="1" id="anc1"></a><span class="line-modified">  2  * Copyright (c) 2003, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 /* @test
 25  * @bug 4920526
 26  * @summary Needs per connection proxy support for URLs
 27  * @modules java.base/sun.net.www
<a name="2" id="anc2"></a><span class="line-modified"> 28  * @library ../../../sun/net/www/httptest/ /test/lib</span>
 29  * @build ClosedChannelList TestHttpServer HttpTransaction HttpCallback
 30  * @compile PerConnectionProxy.java
 31  * @run main/othervm -Dhttp.proxyHost=inexistant -Dhttp.proxyPort=8080 PerConnectionProxy
 32  */
 33 
 34 import java.net.*;
 35 import java.io.*;
<a name="3" id="anc3"></a><span class="line-modified"> 36 </span>
<span class="line-added"> 37 import jdk.test.lib.net.URIBuilder;</span>
 38 
 39 public class PerConnectionProxy implements HttpCallback {
 40     static TestHttpServer server;
 41 
 42     public void request (HttpTransaction req) {
 43         req.setResponseEntityBody (&quot;Hello .&quot;);
 44         try {
 45             req.sendResponse (200, &quot;Ok&quot;);
 46             req.orderlyClose();
 47         } catch (IOException e) {
 48         }
 49     }
 50 
 51     public static void main(String[] args) {
 52         try {
<a name="4" id="anc4"></a><span class="line-modified"> 53             InetAddress loopbackAddress = InetAddress.getLoopbackAddress();</span>
<span class="line-modified"> 54             server = new TestHttpServer(new PerConnectionProxy(), 1, 10, loopbackAddress, 0);</span>
<span class="line-added"> 55             ProxyServer pserver = new ProxyServer(loopbackAddress, server.getLocalPort());</span>
 56             // start proxy server
 57             new Thread(pserver).start();
 58 
<a name="5" id="anc5"></a><span class="line-modified"> 59             URL url = URIBuilder.newBuilder()</span>
<span class="line-added"> 60                     .scheme(&quot;http&quot;)</span>
<span class="line-added"> 61                     .loopback()</span>
<span class="line-added"> 62                     .port(server.getLocalPort())</span>
<span class="line-added"> 63                     .toURLUnchecked();</span>
 64 
 65             // for non existing proxy expect an IOException
 66             try {
 67                 InetSocketAddress isa = InetSocketAddress.createUnresolved(&quot;inexistent&quot;, 8080);
 68                 Proxy proxy = new Proxy(Proxy.Type.HTTP, isa);
 69                 HttpURLConnection urlc = (HttpURLConnection)url.openConnection (proxy);
 70                 InputStream is = urlc.getInputStream ();
 71                 is.close();
 72                 throw new RuntimeException(&quot;non existing per connection proxy should lead to IOException&quot;);
 73             } catch (IOException ioex) {
 74                 // expected
 75             }
 76 
 77             // for NO_PROXY, expect direct connection
 78             try {
 79                 HttpURLConnection urlc = (HttpURLConnection)url.openConnection (Proxy.NO_PROXY);
 80                 int respCode = urlc.getResponseCode();
 81                 urlc.disconnect();
 82             } catch (IOException ioex) {
 83                 throw new RuntimeException(&quot;direct connection should succeed :&quot;+ioex.getMessage());
 84             }
 85 
 86             // for a normal proxy setting expect to see connection
 87             // goes through that proxy
 88             try {
<a name="6" id="anc6"></a><span class="line-modified"> 89                 InetSocketAddress isa = InetSocketAddress.createUnresolved(</span>
<span class="line-added"> 90                         loopbackAddress.getHostAddress(),</span>
<span class="line-added"> 91                         pserver.getPort());</span>
 92                 Proxy p = new Proxy(Proxy.Type.HTTP, isa);
 93                 HttpURLConnection urlc = (HttpURLConnection)url.openConnection (p);
 94                 int respCode = urlc.getResponseCode();
 95                 urlc.disconnect();
 96             } catch (IOException ioex) {
 97                 throw new RuntimeException(&quot;connection through a local proxy should succeed :&quot;+ioex.getMessage());
 98             }
 99 
100         } catch (Exception e) {
101             throw new RuntimeException(e);
102         } finally {
103             if (server != null) {
104                 server.terminate();
105             }
106         }
107 
108     }
109 
110     static class ProxyServer extends Thread {
111         private static ServerSocket ss = null;
112 
113         // client requesting for a tunnel
114         private Socket clientSocket = null;
115 
116         /*
117          * Origin server&#39;s address and port that the client
118          * wants to establish the tunnel for communication.
119          */
120         private InetAddress serverInetAddr;
121         private int     serverPort;
122 
123         public ProxyServer(InetAddress server, int port) throws IOException {
124             serverInetAddr = server;
125             serverPort = port;
<a name="7" id="anc7"></a><span class="line-modified">126             ss = new ServerSocket(0, 0, InetAddress.getLoopbackAddress());</span>
127         }
128 
129         public void run() {
130             try {
131                 clientSocket = ss.accept();
132                 processRequests();
133             } catch (Exception e) {
134                 System.out.println(&quot;Proxy Failed: &quot; + e);
135                 e.printStackTrace();
136                 try {
137                     ss.close();
138                 }
139                 catch (IOException excep) {
140                     System.out.println(&quot;ProxyServer close error: &quot; + excep);
141                     excep.printStackTrace();
142                 }
143             }
144         }
145 
146         private void processRequests() throws Exception {
147             // connection set to the tunneling mode
148 
149             Socket serverSocket = new Socket(serverInetAddr, serverPort);
150             ProxyTunnel clientToServer = new ProxyTunnel(
151                                                          clientSocket, serverSocket);
152             ProxyTunnel serverToClient = new ProxyTunnel(
153                                                          serverSocket, clientSocket);
154             clientToServer.start();
155             serverToClient.start();
156             System.out.println(&quot;Proxy: Started tunneling.......&quot;);
157 
158             clientToServer.join();
159             serverToClient.join();
160             System.out.println(&quot;Proxy: Finished tunneling........&quot;);
161 
162             clientToServer.close();
163             serverToClient.close();
164 
165         }
166 
167         /**
168 ***************************************************************
169 *                       helper methods follow
170 ***************************************************************
171 */
172         public int getPort() {
173             return ss.getLocalPort();
174         }
175         /*
176          * This inner class provides unidirectional data flow through the sockets
177          * by continuously copying bytes from the input socket onto the output
178          * socket, until both sockets are open and EOF has not been received.
179          */
180         static class ProxyTunnel extends Thread {
181             Socket sockIn;
182             Socket sockOut;
183             InputStream input;
184             OutputStream output;
185 
186             public ProxyTunnel(Socket sockIn, Socket sockOut)
187                 throws Exception {
188                 this.sockIn = sockIn;
189                 this.sockOut = sockOut;
190                 input = sockIn.getInputStream();
191                 output = sockOut.getOutputStream();
192             }
193 
194             public void run() {
195                 int BUFFER_SIZE = 400;
196                 byte[] buf = new byte[BUFFER_SIZE];
197                 int bytesRead = 0;
198                 int count = 0;  // keep track of the amount of data transfer
199 
200                 try {
201                     while ((bytesRead = input.read(buf)) &gt;= 0) {
202                         output.write(buf, 0, bytesRead);
203                         output.flush();
204                         count += bytesRead;
205                     }
206                 } catch (IOException e) {
207                     /*
208                      * The peer end has closed the connection
209                      * we will close the tunnel
210                      */
211                     close();
212                 }
213             }
214 
215             public void close() {
216                 try {
217                     if (!sockIn.isClosed())
218                         sockIn.close();
219                     if (!sockOut.isClosed())
220                         sockOut.close();
221                 } catch (IOException ignored) { }
222             }
223         }
224 
225     }
226 }
<a name="8" id="anc8"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="8" type="hidden" />
</body>
</html>
diff a/test/jdk/java/net/Socket/HttpProxy.java b/test/jdk/java/net/Socket/HttpProxy.java
--- a/test/jdk/java/net/Socket/HttpProxy.java
+++ b/test/jdk/java/net/Socket/HttpProxy.java
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2010, 2018, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2010, 2019, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.
@@ -21,15 +21,19 @@
  * questions.
  */
 
 /*
  * @test
- * @bug 6370908
- * @summary Add support for HTTP_CONNECT proxy in Socket class
+ * @bug 6370908 8220663
+ * @library /test/lib
+ * @summary Add support for HTTP_CONNECT proxy in Socket class.
+ * This test uses the wildcard address and is susceptible to fail intermittently.
+ * @key intermittent
  * @modules java.base/sun.net.www
  * @run main HttpProxy
  * @run main/othervm -Djava.net.preferIPv4Stack=true HttpProxy
+ * @run main/othervm -Djava.net.preferIPv6Addresses=true HttpProxy
  */
 
 import java.io.IOException;
 import java.io.InputStream;
 import java.io.OutputStream;
@@ -38,25 +42,32 @@
 import java.net.InetAddress;
 import java.net.InetSocketAddress;
 import java.net.Proxy;
 import java.net.ServerSocket;
 import java.net.Socket;
+import java.net.SocketAddress;
+import java.util.ArrayList;
+import java.util.List;
+import jdk.test.lib.net.IPSupport;
 import sun.net.www.MessageHeader;
 
 public class HttpProxy {
     final String proxyHost;
     final int proxyPort;
     static final int SO_TIMEOUT = 15000;
 
     public static void main(String[] args) throws Exception {
+        IPSupport.throwSkippedExceptionIfNonOperational();
+
         String host;
         int port;
+        ConnectProxyTunnelServer proxy = null;
         if (args.length == 0) {
             // Start internal proxy
-            ConnectProxyTunnelServer proxy = new ConnectProxyTunnelServer();
+            proxy = new ConnectProxyTunnelServer();
             proxy.start();
-            host = "localhost";
+            host = InetAddress.getLoopbackAddress().getHostAddress();
             port = proxy.getLocalPort();
             out.println("Running with internal proxy: " + host + ":" + port);
         } else if (args.length == 2) {
             host = args[0];
             port = Integer.valueOf(args[1]);
@@ -64,53 +75,74 @@
         } else {
             System.err.println("Usage: java HttpProxy [<proxy host> <proxy port>]");
             return;
         }
 
-        HttpProxy p = new HttpProxy(host, port);
-        p.test();
+        try {
+            HttpProxy p = new HttpProxy(host, port);
+            p.test();
+        } finally {
+            if (proxy != null)
+                proxy.close();
+        }
     }
 
     public HttpProxy(String proxyHost, int proxyPort) {
         this.proxyHost = proxyHost;
         this.proxyPort = proxyPort;
     }
 
+    static boolean canUseIPv6() {
+        return IPSupport.hasIPv6() && !IPSupport.preferIPv4Stack();
+    }
+
     void test() throws Exception {
         InetSocketAddress proxyAddress = new InetSocketAddress(proxyHost, proxyPort);
         Proxy httpProxy = new Proxy(Proxy.Type.HTTP, proxyAddress);
 
-        try (ServerSocket ss = new ServerSocket(0);
-             Socket sock = new Socket(httpProxy)) {
-            sock.setSoTimeout(SO_TIMEOUT);
-            sock.setTcpNoDelay(false);
-
-            InetSocketAddress externalAddress =
-                new InetSocketAddress(InetAddress.getLocalHost(), ss.getLocalPort());
-
-            out.println("Trying to connect to server socket on " + externalAddress);
-            sock.connect(externalAddress);
-            try (Socket externalSock = ss.accept()) {
-                // perform some simple checks
-                check(sock.isBound(), "Socket is not bound");
-                check(sock.isConnected(), "Socket is not connected");
-                check(!sock.isClosed(), "Socket should not be closed");
-                check(sock.getSoTimeout() == SO_TIMEOUT,
-                        "Socket should have a previously set timeout");
-                check(sock.getTcpNoDelay() ==  false, "NODELAY should be false");
-
-                simpleDataExchange(sock, externalSock);
+        // Wildcard address is needed here
+        try (ServerSocket ss = new ServerSocket(0)) {
+            List<InetSocketAddress> externalAddresses = new ArrayList<>();
+            externalAddresses.add(
+                new InetSocketAddress(InetAddress.getLocalHost(), ss.getLocalPort()));
+
+            if (canUseIPv6()) {
+                byte[] bytes = new byte[] {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1};
+                var address = InetAddress.getByAddress(bytes);
+                externalAddresses.add(
+                        new InetSocketAddress(address, ss.getLocalPort()));
+            }
+
+            for (SocketAddress externalAddress : externalAddresses) {
+                try (Socket sock = new Socket(httpProxy)) {
+                    sock.setSoTimeout(SO_TIMEOUT);
+                    sock.setTcpNoDelay(false);
+
+                    out.println("Trying to connect to server socket on " + externalAddress);
+                    sock.connect(externalAddress);
+                    try (Socket externalSock = ss.accept()) {
+                        // perform some simple checks
+                        check(sock.isBound(), "Socket is not bound");
+                        check(sock.isConnected(), "Socket is not connected");
+                        check(!sock.isClosed(), "Socket should not be closed");
+                        check(sock.getSoTimeout() == SO_TIMEOUT,
+                                "Socket should have a previously set timeout");
+                        check(sock.getTcpNoDelay() == false, "NODELAY should be false");
+
+                        simpleDataExchange(sock, externalSock);
+                    }
+                }
             }
         }
     }
 
     static void check(boolean condition, String message) {
         if (!condition) out.println(message);
     }
 
     static Exception unexpected(Exception e) {
-        out.println("Unexcepted Exception: " + e);
+        out.println("Unexpected Exception: " + e);
         e.printStackTrace();
         return e;
     }
 
     // performs a simple exchange of data between the two sockets
@@ -130,20 +162,22 @@
     void startSimpleWriter(String threadName, final OutputStream os, final int start) {
         (new Thread(new Runnable() {
             public void run() {
                 try { simpleWrite(os, start); }
                 catch (Exception e) {unexpected(e); }
+                finally { out.println(threadName + ": done"); }
             }}, threadName)).start();
     }
 
     void simpleWrite(OutputStream os, int start) throws Exception {
         byte b[] = new byte[2];
         for (int i=start; i<start+100; i++) {
             b[0] = (byte) (i / 256);
             b[1] = (byte) (i % 256);
             os.write(b);
         }
+        out.println("Wrote " + start + " -> " + (start + 100));
     }
 
     void simpleRead(InputStream is, int start) throws Exception {
         byte b[] = new byte [2];
         for (int i=start; i<start+100; i++) {
@@ -154,61 +188,77 @@
                 throw new Exception("read error");
             int r = bytes(b[0], b[1]);
             if (r != i)
                 throw new Exception("read " + r + " expected " +i);
         }
+        out.println("Read " + start + " -> " + (start + 100));
     }
 
     int bytes(byte b1, byte b2) {
         int i1 = (int)b1 & 0xFF;
         int i2 = (int)b2 & 0xFF;
         return i1 * 256 + i2;
     }
 
-    static class ConnectProxyTunnelServer extends Thread {
+    static class ConnectProxyTunnelServer extends Thread implements AutoCloseable {
 
         private final ServerSocket ss;
+        private volatile boolean closed;
 
         public ConnectProxyTunnelServer() throws IOException {
-            ss = new ServerSocket(0);
+            ss = new ServerSocket(0, 0, InetAddress.getLoopbackAddress());
         }
 
         @Override
         public void run() {
-            try (Socket clientSocket = ss.accept()) {
-                processRequest(clientSocket);
+            try {
+                while (!closed) {
+                    try (Socket clientSocket = ss.accept()) {
+                        processRequest(clientSocket);
+                    }
+                }
             } catch (Exception e) {
-                out.println("Proxy Failed: " + e);
-                e.printStackTrace();
+                if (!closed) {
+                    out.println("Proxy Failed: " + e);
+                    e.printStackTrace();
+                }
             } finally {
-                try { ss.close(); } catch (IOException x) { unexpected(x); }
+                if (!closed)
+                    try { ss.close(); } catch (IOException x) { unexpected(x); }
             }
         }
 
         /**
          * Returns the port on which the proxy is accepting connections.
          */
         public int getLocalPort() {
             return ss.getLocalPort();
         }
 
+        @Override
+        public void close() throws Exception {
+            closed = true;
+            ss.close();
+        }
+
         /*
          * Processes the CONNECT request
          */
         private void processRequest(Socket clientSocket) throws Exception {
             MessageHeader mheader = new MessageHeader(clientSocket.getInputStream());
             String statusLine = mheader.getValue(0);
 
             if (!statusLine.startsWith("CONNECT")) {
                 out.println("proxy server: processes only "
-                                  + "CONNECT method requests, recieved: "
+                                  + "CONNECT method requests, received: "
                                   + statusLine);
                 return;
             }
 
             // retrieve the host and port info from the status-line
             InetSocketAddress serverAddr = getConnectInfo(statusLine);
+            out.println("Proxy serving CONNECT request to " + serverAddr);
 
             //open socket to the server
             try (Socket serverSocket = new Socket(serverAddr.getAddress(),
                                                   serverAddr.getPort())) {
                 Forwarder clientFW = new Forwarder(clientSocket.getInputStream(),
@@ -244,16 +294,23 @@
             try {
                 int starti = connectStr.indexOf(' ');
                 int endi = connectStr.lastIndexOf(' ');
                 String connectInfo = connectStr.substring(starti+1, endi).trim();
                 // retrieve server name and port
-                endi = connectInfo.indexOf(':');
+                endi = connectInfo.lastIndexOf(':');
                 String name = connectInfo.substring(0, endi);
+
+                if (name.contains(":")) {
+                    if (!(name.startsWith("[") && name.endsWith("]"))) {
+                        throw new IOException("Invalid host:" + name);
+                    }
+                    name = name.substring(1, name.length() - 1);
+                }
                 int port = Integer.parseInt(connectInfo.substring(endi+1));
                 return new InetSocketAddress(name, port);
             } catch (Exception e) {
-                out.println("Proxy recieved a request: " + connectStr);
+                out.println("Proxy received a request: " + connectStr);
                 throw unexpected(e);
             }
         }
     }
 

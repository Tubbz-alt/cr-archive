<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff test/jdk/java/net/Socket/HttpProxy.java</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
<body>
<center><a href="GetLocalAddress.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="InheritHandle.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>test/jdk/java/net/Socket/HttpProxy.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2010, 2018, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 /*
 25  * @test
<span class="line-modified"> 26  * @bug 6370908</span>
<span class="line-modified"> 27  * @summary Add support for HTTP_CONNECT proxy in Socket class</span>



 28  * @modules java.base/sun.net.www
 29  * @run main HttpProxy
 30  * @run main/othervm -Djava.net.preferIPv4Stack=true HttpProxy

 31  */
 32 
 33 import java.io.IOException;
 34 import java.io.InputStream;
 35 import java.io.OutputStream;
 36 import java.io.PrintWriter;
 37 import static java.lang.System.out;
 38 import java.net.InetAddress;
 39 import java.net.InetSocketAddress;
 40 import java.net.Proxy;
 41 import java.net.ServerSocket;
 42 import java.net.Socket;




 43 import sun.net.www.MessageHeader;
 44 
 45 public class HttpProxy {
 46     final String proxyHost;
 47     final int proxyPort;
 48     static final int SO_TIMEOUT = 15000;
 49 
 50     public static void main(String[] args) throws Exception {


 51         String host;
 52         int port;

 53         if (args.length == 0) {
 54             // Start internal proxy
<span class="line-modified"> 55             ConnectProxyTunnelServer proxy = new ConnectProxyTunnelServer();</span>
 56             proxy.start();
<span class="line-modified"> 57             host = &quot;localhost&quot;;</span>
 58             port = proxy.getLocalPort();
 59             out.println(&quot;Running with internal proxy: &quot; + host + &quot;:&quot; + port);
 60         } else if (args.length == 2) {
 61             host = args[0];
 62             port = Integer.valueOf(args[1]);
 63             out.println(&quot;Running against specified proxy server: &quot; + host + &quot;:&quot; + port);
 64         } else {
 65             System.err.println(&quot;Usage: java HttpProxy [&lt;proxy host&gt; &lt;proxy port&gt;]&quot;);
 66             return;
 67         }
 68 
<span class="line-modified"> 69         HttpProxy p = new HttpProxy(host, port);</span>
<span class="line-modified"> 70         p.test();</span>





 71     }
 72 
 73     public HttpProxy(String proxyHost, int proxyPort) {
 74         this.proxyHost = proxyHost;
 75         this.proxyPort = proxyPort;
 76     }
 77 




 78     void test() throws Exception {
 79         InetSocketAddress proxyAddress = new InetSocketAddress(proxyHost, proxyPort);
 80         Proxy httpProxy = new Proxy(Proxy.Type.HTTP, proxyAddress);
 81 
<span class="line-modified"> 82         try (ServerSocket ss = new ServerSocket(0);</span>
<span class="line-modified"> 83              Socket sock = new Socket(httpProxy)) {</span>
<span class="line-modified"> 84             sock.setSoTimeout(SO_TIMEOUT);</span>
<span class="line-modified"> 85             sock.setTcpNoDelay(false);</span>
<span class="line-modified"> 86 </span>
<span class="line-modified"> 87             InetSocketAddress externalAddress =</span>
<span class="line-modified"> 88                 new InetSocketAddress(InetAddress.getLocalHost(), ss.getLocalPort());</span>
<span class="line-modified"> 89 </span>
<span class="line-modified"> 90             out.println(&quot;Trying to connect to server socket on &quot; + externalAddress);</span>
<span class="line-modified"> 91             sock.connect(externalAddress);</span>
<span class="line-modified"> 92             try (Socket externalSock = ss.accept()) {</span>
<span class="line-modified"> 93                 // perform some simple checks</span>
<span class="line-modified"> 94                 check(sock.isBound(), &quot;Socket is not bound&quot;);</span>
<span class="line-modified"> 95                 check(sock.isConnected(), &quot;Socket is not connected&quot;);</span>
<span class="line-modified"> 96                 check(!sock.isClosed(), &quot;Socket should not be closed&quot;);</span>
<span class="line-modified"> 97                 check(sock.getSoTimeout() == SO_TIMEOUT,</span>
<span class="line-modified"> 98                         &quot;Socket should have a previously set timeout&quot;);</span>
<span class="line-modified"> 99                 check(sock.getTcpNoDelay() ==  false, &quot;NODELAY should be false&quot;);</span>
<span class="line-modified">100 </span>
<span class="line-modified">101                 simpleDataExchange(sock, externalSock);</span>












102             }
103         }
104     }
105 
106     static void check(boolean condition, String message) {
107         if (!condition) out.println(message);
108     }
109 
110     static Exception unexpected(Exception e) {
<span class="line-modified">111         out.println(&quot;Unexcepted Exception: &quot; + e);</span>
112         e.printStackTrace();
113         return e;
114     }
115 
116     // performs a simple exchange of data between the two sockets
117     // and throws an exception if there is any problem.
118     void simpleDataExchange(Socket s1, Socket s2) throws Exception {
119         try (final InputStream i1 = s1.getInputStream();
120              final InputStream i2 = s2.getInputStream();
121              final OutputStream o1 = s1.getOutputStream();
122              final OutputStream o2 = s2.getOutputStream()) {
123             startSimpleWriter(&quot;simpleWriter1&quot;, o1, 100);
124             startSimpleWriter(&quot;simpleWriter2&quot;, o2, 200);
125             simpleRead(i2, 100);
126             simpleRead(i1, 200);
127         }
128     }
129 
130     void startSimpleWriter(String threadName, final OutputStream os, final int start) {
131         (new Thread(new Runnable() {
132             public void run() {
133                 try { simpleWrite(os, start); }
134                 catch (Exception e) {unexpected(e); }

135             }}, threadName)).start();
136     }
137 
138     void simpleWrite(OutputStream os, int start) throws Exception {
139         byte b[] = new byte[2];
140         for (int i=start; i&lt;start+100; i++) {
141             b[0] = (byte) (i / 256);
142             b[1] = (byte) (i % 256);
143             os.write(b);
144         }

145     }
146 
147     void simpleRead(InputStream is, int start) throws Exception {
148         byte b[] = new byte [2];
149         for (int i=start; i&lt;start+100; i++) {
150             int x = is.read(b);
151             if (x == 1)
152                 x += is.read(b,1,1);
153             if (x!=2)
154                 throw new Exception(&quot;read error&quot;);
155             int r = bytes(b[0], b[1]);
156             if (r != i)
157                 throw new Exception(&quot;read &quot; + r + &quot; expected &quot; +i);
158         }

159     }
160 
161     int bytes(byte b1, byte b2) {
162         int i1 = (int)b1 &amp; 0xFF;
163         int i2 = (int)b2 &amp; 0xFF;
164         return i1 * 256 + i2;
165     }
166 
<span class="line-modified">167     static class ConnectProxyTunnelServer extends Thread {</span>
168 
169         private final ServerSocket ss;

170 
171         public ConnectProxyTunnelServer() throws IOException {
<span class="line-modified">172             ss = new ServerSocket(0);</span>
173         }
174 
175         @Override
176         public void run() {
<span class="line-modified">177             try (Socket clientSocket = ss.accept()) {</span>
<span class="line-modified">178                 processRequest(clientSocket);</span>




179             } catch (Exception e) {
<span class="line-modified">180                 out.println(&quot;Proxy Failed: &quot; + e);</span>
<span class="line-modified">181                 e.printStackTrace();</span>


182             } finally {
<span class="line-modified">183                 try { ss.close(); } catch (IOException x) { unexpected(x); }</span>

184             }
185         }
186 
187         /**
188          * Returns the port on which the proxy is accepting connections.
189          */
190         public int getLocalPort() {
191             return ss.getLocalPort();
192         }
193 






194         /*
195          * Processes the CONNECT request
196          */
197         private void processRequest(Socket clientSocket) throws Exception {
198             MessageHeader mheader = new MessageHeader(clientSocket.getInputStream());
199             String statusLine = mheader.getValue(0);
200 
201             if (!statusLine.startsWith(&quot;CONNECT&quot;)) {
202                 out.println(&quot;proxy server: processes only &quot;
<span class="line-modified">203                                   + &quot;CONNECT method requests, recieved: &quot;</span>
204                                   + statusLine);
205                 return;
206             }
207 
208             // retrieve the host and port info from the status-line
209             InetSocketAddress serverAddr = getConnectInfo(statusLine);

210 
211             //open socket to the server
212             try (Socket serverSocket = new Socket(serverAddr.getAddress(),
213                                                   serverAddr.getPort())) {
214                 Forwarder clientFW = new Forwarder(clientSocket.getInputStream(),
215                                                    serverSocket.getOutputStream());
216                 Thread clientForwarderThread = new Thread(clientFW, &quot;ClientForwarder&quot;);
217                 clientForwarderThread.start();
218                 send200(clientSocket);
219                 Forwarder serverFW = new Forwarder(serverSocket.getInputStream(),
220                                                    clientSocket.getOutputStream());
221                 serverFW.run();
222                 clientForwarderThread.join();
223             }
224         }
225 
226         private void send200(Socket clientSocket) throws IOException {
227             OutputStream out = clientSocket.getOutputStream();
228             PrintWriter pout = new PrintWriter(out);
229 
230             pout.println(&quot;HTTP/1.1 200 OK&quot;);
231             pout.println();
232             pout.flush();
233         }
234 
235         /*
236          * This method retrieves the hostname and port of the tunnel destination
237          * from the request line.
238          * @param connectStr
239          *        of the form: &lt;i&gt;CONNECT server-name:server-port HTTP/1.x&lt;/i&gt;
240          */
241         static InetSocketAddress getConnectInfo(String connectStr)
242             throws Exception
243         {
244             try {
245                 int starti = connectStr.indexOf(&#39; &#39;);
246                 int endi = connectStr.lastIndexOf(&#39; &#39;);
247                 String connectInfo = connectStr.substring(starti+1, endi).trim();
248                 // retrieve server name and port
<span class="line-modified">249                 endi = connectInfo.indexOf(&#39;:&#39;);</span>
250                 String name = connectInfo.substring(0, endi);







251                 int port = Integer.parseInt(connectInfo.substring(endi+1));
252                 return new InetSocketAddress(name, port);
253             } catch (Exception e) {
<span class="line-modified">254                 out.println(&quot;Proxy recieved a request: &quot; + connectStr);</span>
255                 throw unexpected(e);
256             }
257         }
258     }
259 
260     /* Reads from the given InputStream and writes to the given OutputStream */
261     static class Forwarder implements Runnable
262     {
263         private final InputStream in;
264         private final OutputStream os;
265 
266         Forwarder(InputStream in, OutputStream os) {
267             this.in = in;
268             this.os = os;
269         }
270 
271         @Override
272         public void run() {
273             try {
274                 byte[] ba = new byte[1024];
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2010, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 /*
 25  * @test
<span class="line-modified"> 26  * @bug 6370908 8220663</span>
<span class="line-modified"> 27  * @library /test/lib</span>
<span class="line-added"> 28  * @summary Add support for HTTP_CONNECT proxy in Socket class.</span>
<span class="line-added"> 29  * This test uses the wildcard address and is susceptible to fail intermittently.</span>
<span class="line-added"> 30  * @key intermittent</span>
 31  * @modules java.base/sun.net.www
 32  * @run main HttpProxy
 33  * @run main/othervm -Djava.net.preferIPv4Stack=true HttpProxy
<span class="line-added"> 34  * @run main/othervm -Djava.net.preferIPv6Addresses=true HttpProxy</span>
 35  */
 36 
 37 import java.io.IOException;
 38 import java.io.InputStream;
 39 import java.io.OutputStream;
 40 import java.io.PrintWriter;
 41 import static java.lang.System.out;
 42 import java.net.InetAddress;
 43 import java.net.InetSocketAddress;
 44 import java.net.Proxy;
 45 import java.net.ServerSocket;
 46 import java.net.Socket;
<span class="line-added"> 47 import java.net.SocketAddress;</span>
<span class="line-added"> 48 import java.util.ArrayList;</span>
<span class="line-added"> 49 import java.util.List;</span>
<span class="line-added"> 50 import jdk.test.lib.net.IPSupport;</span>
 51 import sun.net.www.MessageHeader;
 52 
 53 public class HttpProxy {
 54     final String proxyHost;
 55     final int proxyPort;
 56     static final int SO_TIMEOUT = 15000;
 57 
 58     public static void main(String[] args) throws Exception {
<span class="line-added"> 59         IPSupport.throwSkippedExceptionIfNonOperational();</span>
<span class="line-added"> 60 </span>
 61         String host;
 62         int port;
<span class="line-added"> 63         ConnectProxyTunnelServer proxy = null;</span>
 64         if (args.length == 0) {
 65             // Start internal proxy
<span class="line-modified"> 66             proxy = new ConnectProxyTunnelServer();</span>
 67             proxy.start();
<span class="line-modified"> 68             host = InetAddress.getLoopbackAddress().getHostAddress();</span>
 69             port = proxy.getLocalPort();
 70             out.println(&quot;Running with internal proxy: &quot; + host + &quot;:&quot; + port);
 71         } else if (args.length == 2) {
 72             host = args[0];
 73             port = Integer.valueOf(args[1]);
 74             out.println(&quot;Running against specified proxy server: &quot; + host + &quot;:&quot; + port);
 75         } else {
 76             System.err.println(&quot;Usage: java HttpProxy [&lt;proxy host&gt; &lt;proxy port&gt;]&quot;);
 77             return;
 78         }
 79 
<span class="line-modified"> 80         try {</span>
<span class="line-modified"> 81             HttpProxy p = new HttpProxy(host, port);</span>
<span class="line-added"> 82             p.test();</span>
<span class="line-added"> 83         } finally {</span>
<span class="line-added"> 84             if (proxy != null)</span>
<span class="line-added"> 85                 proxy.close();</span>
<span class="line-added"> 86         }</span>
 87     }
 88 
 89     public HttpProxy(String proxyHost, int proxyPort) {
 90         this.proxyHost = proxyHost;
 91         this.proxyPort = proxyPort;
 92     }
 93 
<span class="line-added"> 94     static boolean canUseIPv6() {</span>
<span class="line-added"> 95         return IPSupport.hasIPv6() &amp;&amp; !IPSupport.preferIPv4Stack();</span>
<span class="line-added"> 96     }</span>
<span class="line-added"> 97 </span>
 98     void test() throws Exception {
 99         InetSocketAddress proxyAddress = new InetSocketAddress(proxyHost, proxyPort);
100         Proxy httpProxy = new Proxy(Proxy.Type.HTTP, proxyAddress);
101 
<span class="line-modified">102         // Wildcard address is needed here</span>
<span class="line-modified">103         try (ServerSocket ss = new ServerSocket(0)) {</span>
<span class="line-modified">104             List&lt;InetSocketAddress&gt; externalAddresses = new ArrayList&lt;&gt;();</span>
<span class="line-modified">105             externalAddresses.add(</span>
<span class="line-modified">106                 new InetSocketAddress(InetAddress.getLocalHost(), ss.getLocalPort()));</span>
<span class="line-modified">107 </span>
<span class="line-modified">108             if (canUseIPv6()) {</span>
<span class="line-modified">109                 byte[] bytes = new byte[] {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1};</span>
<span class="line-modified">110                 var address = InetAddress.getByAddress(bytes);</span>
<span class="line-modified">111                 externalAddresses.add(</span>
<span class="line-modified">112                         new InetSocketAddress(address, ss.getLocalPort()));</span>
<span class="line-modified">113             }</span>
<span class="line-modified">114 </span>
<span class="line-modified">115             for (SocketAddress externalAddress : externalAddresses) {</span>
<span class="line-modified">116                 try (Socket sock = new Socket(httpProxy)) {</span>
<span class="line-modified">117                     sock.setSoTimeout(SO_TIMEOUT);</span>
<span class="line-modified">118                     sock.setTcpNoDelay(false);</span>
<span class="line-modified">119 </span>
<span class="line-modified">120                     out.println(&quot;Trying to connect to server socket on &quot; + externalAddress);</span>
<span class="line-modified">121                     sock.connect(externalAddress);</span>
<span class="line-added">122                     try (Socket externalSock = ss.accept()) {</span>
<span class="line-added">123                         // perform some simple checks</span>
<span class="line-added">124                         check(sock.isBound(), &quot;Socket is not bound&quot;);</span>
<span class="line-added">125                         check(sock.isConnected(), &quot;Socket is not connected&quot;);</span>
<span class="line-added">126                         check(!sock.isClosed(), &quot;Socket should not be closed&quot;);</span>
<span class="line-added">127                         check(sock.getSoTimeout() == SO_TIMEOUT,</span>
<span class="line-added">128                                 &quot;Socket should have a previously set timeout&quot;);</span>
<span class="line-added">129                         check(sock.getTcpNoDelay() == false, &quot;NODELAY should be false&quot;);</span>
<span class="line-added">130 </span>
<span class="line-added">131                         simpleDataExchange(sock, externalSock);</span>
<span class="line-added">132                     }</span>
<span class="line-added">133                 }</span>
134             }
135         }
136     }
137 
138     static void check(boolean condition, String message) {
139         if (!condition) out.println(message);
140     }
141 
142     static Exception unexpected(Exception e) {
<span class="line-modified">143         out.println(&quot;Unexpected Exception: &quot; + e);</span>
144         e.printStackTrace();
145         return e;
146     }
147 
148     // performs a simple exchange of data between the two sockets
149     // and throws an exception if there is any problem.
150     void simpleDataExchange(Socket s1, Socket s2) throws Exception {
151         try (final InputStream i1 = s1.getInputStream();
152              final InputStream i2 = s2.getInputStream();
153              final OutputStream o1 = s1.getOutputStream();
154              final OutputStream o2 = s2.getOutputStream()) {
155             startSimpleWriter(&quot;simpleWriter1&quot;, o1, 100);
156             startSimpleWriter(&quot;simpleWriter2&quot;, o2, 200);
157             simpleRead(i2, 100);
158             simpleRead(i1, 200);
159         }
160     }
161 
162     void startSimpleWriter(String threadName, final OutputStream os, final int start) {
163         (new Thread(new Runnable() {
164             public void run() {
165                 try { simpleWrite(os, start); }
166                 catch (Exception e) {unexpected(e); }
<span class="line-added">167                 finally { out.println(threadName + &quot;: done&quot;); }</span>
168             }}, threadName)).start();
169     }
170 
171     void simpleWrite(OutputStream os, int start) throws Exception {
172         byte b[] = new byte[2];
173         for (int i=start; i&lt;start+100; i++) {
174             b[0] = (byte) (i / 256);
175             b[1] = (byte) (i % 256);
176             os.write(b);
177         }
<span class="line-added">178         out.println(&quot;Wrote &quot; + start + &quot; -&gt; &quot; + (start + 100));</span>
179     }
180 
181     void simpleRead(InputStream is, int start) throws Exception {
182         byte b[] = new byte [2];
183         for (int i=start; i&lt;start+100; i++) {
184             int x = is.read(b);
185             if (x == 1)
186                 x += is.read(b,1,1);
187             if (x!=2)
188                 throw new Exception(&quot;read error&quot;);
189             int r = bytes(b[0], b[1]);
190             if (r != i)
191                 throw new Exception(&quot;read &quot; + r + &quot; expected &quot; +i);
192         }
<span class="line-added">193         out.println(&quot;Read &quot; + start + &quot; -&gt; &quot; + (start + 100));</span>
194     }
195 
196     int bytes(byte b1, byte b2) {
197         int i1 = (int)b1 &amp; 0xFF;
198         int i2 = (int)b2 &amp; 0xFF;
199         return i1 * 256 + i2;
200     }
201 
<span class="line-modified">202     static class ConnectProxyTunnelServer extends Thread implements AutoCloseable {</span>
203 
204         private final ServerSocket ss;
<span class="line-added">205         private volatile boolean closed;</span>
206 
207         public ConnectProxyTunnelServer() throws IOException {
<span class="line-modified">208             ss = new ServerSocket(0, 0, InetAddress.getLoopbackAddress());</span>
209         }
210 
211         @Override
212         public void run() {
<span class="line-modified">213             try {</span>
<span class="line-modified">214                 while (!closed) {</span>
<span class="line-added">215                     try (Socket clientSocket = ss.accept()) {</span>
<span class="line-added">216                         processRequest(clientSocket);</span>
<span class="line-added">217                     }</span>
<span class="line-added">218                 }</span>
219             } catch (Exception e) {
<span class="line-modified">220                 if (!closed) {</span>
<span class="line-modified">221                     out.println(&quot;Proxy Failed: &quot; + e);</span>
<span class="line-added">222                     e.printStackTrace();</span>
<span class="line-added">223                 }</span>
224             } finally {
<span class="line-modified">225                 if (!closed)</span>
<span class="line-added">226                     try { ss.close(); } catch (IOException x) { unexpected(x); }</span>
227             }
228         }
229 
230         /**
231          * Returns the port on which the proxy is accepting connections.
232          */
233         public int getLocalPort() {
234             return ss.getLocalPort();
235         }
236 
<span class="line-added">237         @Override</span>
<span class="line-added">238         public void close() throws Exception {</span>
<span class="line-added">239             closed = true;</span>
<span class="line-added">240             ss.close();</span>
<span class="line-added">241         }</span>
<span class="line-added">242 </span>
243         /*
244          * Processes the CONNECT request
245          */
246         private void processRequest(Socket clientSocket) throws Exception {
247             MessageHeader mheader = new MessageHeader(clientSocket.getInputStream());
248             String statusLine = mheader.getValue(0);
249 
250             if (!statusLine.startsWith(&quot;CONNECT&quot;)) {
251                 out.println(&quot;proxy server: processes only &quot;
<span class="line-modified">252                                   + &quot;CONNECT method requests, received: &quot;</span>
253                                   + statusLine);
254                 return;
255             }
256 
257             // retrieve the host and port info from the status-line
258             InetSocketAddress serverAddr = getConnectInfo(statusLine);
<span class="line-added">259             out.println(&quot;Proxy serving CONNECT request to &quot; + serverAddr);</span>
260 
261             //open socket to the server
262             try (Socket serverSocket = new Socket(serverAddr.getAddress(),
263                                                   serverAddr.getPort())) {
264                 Forwarder clientFW = new Forwarder(clientSocket.getInputStream(),
265                                                    serverSocket.getOutputStream());
266                 Thread clientForwarderThread = new Thread(clientFW, &quot;ClientForwarder&quot;);
267                 clientForwarderThread.start();
268                 send200(clientSocket);
269                 Forwarder serverFW = new Forwarder(serverSocket.getInputStream(),
270                                                    clientSocket.getOutputStream());
271                 serverFW.run();
272                 clientForwarderThread.join();
273             }
274         }
275 
276         private void send200(Socket clientSocket) throws IOException {
277             OutputStream out = clientSocket.getOutputStream();
278             PrintWriter pout = new PrintWriter(out);
279 
280             pout.println(&quot;HTTP/1.1 200 OK&quot;);
281             pout.println();
282             pout.flush();
283         }
284 
285         /*
286          * This method retrieves the hostname and port of the tunnel destination
287          * from the request line.
288          * @param connectStr
289          *        of the form: &lt;i&gt;CONNECT server-name:server-port HTTP/1.x&lt;/i&gt;
290          */
291         static InetSocketAddress getConnectInfo(String connectStr)
292             throws Exception
293         {
294             try {
295                 int starti = connectStr.indexOf(&#39; &#39;);
296                 int endi = connectStr.lastIndexOf(&#39; &#39;);
297                 String connectInfo = connectStr.substring(starti+1, endi).trim();
298                 // retrieve server name and port
<span class="line-modified">299                 endi = connectInfo.lastIndexOf(&#39;:&#39;);</span>
300                 String name = connectInfo.substring(0, endi);
<span class="line-added">301 </span>
<span class="line-added">302                 if (name.contains(&quot;:&quot;)) {</span>
<span class="line-added">303                     if (!(name.startsWith(&quot;[&quot;) &amp;&amp; name.endsWith(&quot;]&quot;))) {</span>
<span class="line-added">304                         throw new IOException(&quot;Invalid host:&quot; + name);</span>
<span class="line-added">305                     }</span>
<span class="line-added">306                     name = name.substring(1, name.length() - 1);</span>
<span class="line-added">307                 }</span>
308                 int port = Integer.parseInt(connectInfo.substring(endi+1));
309                 return new InetSocketAddress(name, port);
310             } catch (Exception e) {
<span class="line-modified">311                 out.println(&quot;Proxy received a request: &quot; + connectStr);</span>
312                 throw unexpected(e);
313             }
314         }
315     }
316 
317     /* Reads from the given InputStream and writes to the given OutputStream */
318     static class Forwarder implements Runnable
319     {
320         private final InputStream in;
321         private final OutputStream os;
322 
323         Forwarder(InputStream in, OutputStream os) {
324             this.in = in;
325             this.os = os;
326         }
327 
328         @Override
329         public void run() {
330             try {
331                 byte[] ba = new byte[1024];
</pre>
</td>
</tr>
</table>
<center><a href="GetLocalAddress.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="InheritHandle.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
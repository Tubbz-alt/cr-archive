<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames test/jdk/java/net/Socket/HttpProxy.java</title>
    <link rel="stylesheet" href="../../../../../style.css" />
    <script type="text/javascript" src="../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
<a name="1" id="anc1"></a><span class="line-modified">  2  * Copyright (c) 2010, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 /*
 25  * @test
<a name="2" id="anc2"></a><span class="line-modified"> 26  * @bug 6370908 8220663</span>
<span class="line-modified"> 27  * @library /test/lib</span>
<span class="line-added"> 28  * @summary Add support for HTTP_CONNECT proxy in Socket class.</span>
<span class="line-added"> 29  * This test uses the wildcard address and is susceptible to fail intermittently.</span>
<span class="line-added"> 30  * @key intermittent</span>
 31  * @modules java.base/sun.net.www
 32  * @run main HttpProxy
 33  * @run main/othervm -Djava.net.preferIPv4Stack=true HttpProxy
<a name="3" id="anc3"></a><span class="line-added"> 34  * @run main/othervm -Djava.net.preferIPv6Addresses=true HttpProxy</span>
 35  */
 36 
 37 import java.io.IOException;
 38 import java.io.InputStream;
 39 import java.io.OutputStream;
 40 import java.io.PrintWriter;
 41 import static java.lang.System.out;
 42 import java.net.InetAddress;
 43 import java.net.InetSocketAddress;
 44 import java.net.Proxy;
 45 import java.net.ServerSocket;
 46 import java.net.Socket;
<a name="4" id="anc4"></a><span class="line-added"> 47 import java.net.SocketAddress;</span>
<span class="line-added"> 48 import java.util.ArrayList;</span>
<span class="line-added"> 49 import java.util.List;</span>
<span class="line-added"> 50 import jdk.test.lib.net.IPSupport;</span>
 51 import sun.net.www.MessageHeader;
 52 
 53 public class HttpProxy {
 54     final String proxyHost;
 55     final int proxyPort;
 56     static final int SO_TIMEOUT = 15000;
 57 
 58     public static void main(String[] args) throws Exception {
<a name="5" id="anc5"></a><span class="line-added"> 59         IPSupport.throwSkippedExceptionIfNonOperational();</span>
<span class="line-added"> 60 </span>
 61         String host;
 62         int port;
<a name="6" id="anc6"></a><span class="line-added"> 63         ConnectProxyTunnelServer proxy = null;</span>
 64         if (args.length == 0) {
 65             // Start internal proxy
<a name="7" id="anc7"></a><span class="line-modified"> 66             proxy = new ConnectProxyTunnelServer();</span>
 67             proxy.start();
<a name="8" id="anc8"></a><span class="line-modified"> 68             host = InetAddress.getLoopbackAddress().getHostAddress();</span>
 69             port = proxy.getLocalPort();
 70             out.println(&quot;Running with internal proxy: &quot; + host + &quot;:&quot; + port);
 71         } else if (args.length == 2) {
 72             host = args[0];
 73             port = Integer.valueOf(args[1]);
 74             out.println(&quot;Running against specified proxy server: &quot; + host + &quot;:&quot; + port);
 75         } else {
 76             System.err.println(&quot;Usage: java HttpProxy [&lt;proxy host&gt; &lt;proxy port&gt;]&quot;);
 77             return;
 78         }
 79 
<a name="9" id="anc9"></a><span class="line-modified"> 80         try {</span>
<span class="line-modified"> 81             HttpProxy p = new HttpProxy(host, port);</span>
<span class="line-added"> 82             p.test();</span>
<span class="line-added"> 83         } finally {</span>
<span class="line-added"> 84             if (proxy != null)</span>
<span class="line-added"> 85                 proxy.close();</span>
<span class="line-added"> 86         }</span>
 87     }
 88 
 89     public HttpProxy(String proxyHost, int proxyPort) {
 90         this.proxyHost = proxyHost;
 91         this.proxyPort = proxyPort;
 92     }
 93 
<a name="10" id="anc10"></a><span class="line-added"> 94     static boolean canUseIPv6() {</span>
<span class="line-added"> 95         return IPSupport.hasIPv6() &amp;&amp; !IPSupport.preferIPv4Stack();</span>
<span class="line-added"> 96     }</span>
<span class="line-added"> 97 </span>
 98     void test() throws Exception {
 99         InetSocketAddress proxyAddress = new InetSocketAddress(proxyHost, proxyPort);
100         Proxy httpProxy = new Proxy(Proxy.Type.HTTP, proxyAddress);
101 
<a name="11" id="anc11"></a><span class="line-modified">102         // Wildcard address is needed here</span>
<span class="line-modified">103         try (ServerSocket ss = new ServerSocket(0)) {</span>
<span class="line-modified">104             List&lt;InetSocketAddress&gt; externalAddresses = new ArrayList&lt;&gt;();</span>
<span class="line-modified">105             externalAddresses.add(</span>
<span class="line-modified">106                 new InetSocketAddress(InetAddress.getLocalHost(), ss.getLocalPort()));</span>
<span class="line-modified">107 </span>
<span class="line-modified">108             if (canUseIPv6()) {</span>
<span class="line-modified">109                 byte[] bytes = new byte[] {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1};</span>
<span class="line-modified">110                 var address = InetAddress.getByAddress(bytes);</span>
<span class="line-modified">111                 externalAddresses.add(</span>
<span class="line-modified">112                         new InetSocketAddress(address, ss.getLocalPort()));</span>
<span class="line-modified">113             }</span>
<span class="line-modified">114 </span>
<span class="line-modified">115             for (SocketAddress externalAddress : externalAddresses) {</span>
<span class="line-modified">116                 try (Socket sock = new Socket(httpProxy)) {</span>
<span class="line-modified">117                     sock.setSoTimeout(SO_TIMEOUT);</span>
<span class="line-modified">118                     sock.setTcpNoDelay(false);</span>
<span class="line-modified">119 </span>
<span class="line-modified">120                     out.println(&quot;Trying to connect to server socket on &quot; + externalAddress);</span>
<span class="line-modified">121                     sock.connect(externalAddress);</span>
<span class="line-added">122                     try (Socket externalSock = ss.accept()) {</span>
<span class="line-added">123                         // perform some simple checks</span>
<span class="line-added">124                         check(sock.isBound(), &quot;Socket is not bound&quot;);</span>
<span class="line-added">125                         check(sock.isConnected(), &quot;Socket is not connected&quot;);</span>
<span class="line-added">126                         check(!sock.isClosed(), &quot;Socket should not be closed&quot;);</span>
<span class="line-added">127                         check(sock.getSoTimeout() == SO_TIMEOUT,</span>
<span class="line-added">128                                 &quot;Socket should have a previously set timeout&quot;);</span>
<span class="line-added">129                         check(sock.getTcpNoDelay() == false, &quot;NODELAY should be false&quot;);</span>
<span class="line-added">130 </span>
<span class="line-added">131                         simpleDataExchange(sock, externalSock);</span>
<span class="line-added">132                     }</span>
<span class="line-added">133                 }</span>
134             }
135         }
136     }
137 
138     static void check(boolean condition, String message) {
139         if (!condition) out.println(message);
140     }
141 
142     static Exception unexpected(Exception e) {
<a name="12" id="anc12"></a><span class="line-modified">143         out.println(&quot;Unexpected Exception: &quot; + e);</span>
144         e.printStackTrace();
145         return e;
146     }
147 
148     // performs a simple exchange of data between the two sockets
149     // and throws an exception if there is any problem.
150     void simpleDataExchange(Socket s1, Socket s2) throws Exception {
151         try (final InputStream i1 = s1.getInputStream();
152              final InputStream i2 = s2.getInputStream();
153              final OutputStream o1 = s1.getOutputStream();
154              final OutputStream o2 = s2.getOutputStream()) {
155             startSimpleWriter(&quot;simpleWriter1&quot;, o1, 100);
156             startSimpleWriter(&quot;simpleWriter2&quot;, o2, 200);
157             simpleRead(i2, 100);
158             simpleRead(i1, 200);
159         }
160     }
161 
162     void startSimpleWriter(String threadName, final OutputStream os, final int start) {
163         (new Thread(new Runnable() {
164             public void run() {
165                 try { simpleWrite(os, start); }
166                 catch (Exception e) {unexpected(e); }
<a name="13" id="anc13"></a><span class="line-added">167                 finally { out.println(threadName + &quot;: done&quot;); }</span>
168             }}, threadName)).start();
169     }
170 
171     void simpleWrite(OutputStream os, int start) throws Exception {
172         byte b[] = new byte[2];
173         for (int i=start; i&lt;start+100; i++) {
174             b[0] = (byte) (i / 256);
175             b[1] = (byte) (i % 256);
176             os.write(b);
177         }
<a name="14" id="anc14"></a><span class="line-added">178         out.println(&quot;Wrote &quot; + start + &quot; -&gt; &quot; + (start + 100));</span>
179     }
180 
181     void simpleRead(InputStream is, int start) throws Exception {
182         byte b[] = new byte [2];
183         for (int i=start; i&lt;start+100; i++) {
184             int x = is.read(b);
185             if (x == 1)
186                 x += is.read(b,1,1);
187             if (x!=2)
188                 throw new Exception(&quot;read error&quot;);
189             int r = bytes(b[0], b[1]);
190             if (r != i)
191                 throw new Exception(&quot;read &quot; + r + &quot; expected &quot; +i);
192         }
<a name="15" id="anc15"></a><span class="line-added">193         out.println(&quot;Read &quot; + start + &quot; -&gt; &quot; + (start + 100));</span>
194     }
195 
196     int bytes(byte b1, byte b2) {
197         int i1 = (int)b1 &amp; 0xFF;
198         int i2 = (int)b2 &amp; 0xFF;
199         return i1 * 256 + i2;
200     }
201 
<a name="16" id="anc16"></a><span class="line-modified">202     static class ConnectProxyTunnelServer extends Thread implements AutoCloseable {</span>
203 
204         private final ServerSocket ss;
<a name="17" id="anc17"></a><span class="line-added">205         private volatile boolean closed;</span>
206 
207         public ConnectProxyTunnelServer() throws IOException {
<a name="18" id="anc18"></a><span class="line-modified">208             ss = new ServerSocket(0, 0, InetAddress.getLoopbackAddress());</span>
209         }
210 
211         @Override
212         public void run() {
<a name="19" id="anc19"></a><span class="line-modified">213             try {</span>
<span class="line-modified">214                 while (!closed) {</span>
<span class="line-added">215                     try (Socket clientSocket = ss.accept()) {</span>
<span class="line-added">216                         processRequest(clientSocket);</span>
<span class="line-added">217                     }</span>
<span class="line-added">218                 }</span>
219             } catch (Exception e) {
<a name="20" id="anc20"></a><span class="line-modified">220                 if (!closed) {</span>
<span class="line-modified">221                     out.println(&quot;Proxy Failed: &quot; + e);</span>
<span class="line-added">222                     e.printStackTrace();</span>
<span class="line-added">223                 }</span>
224             } finally {
<a name="21" id="anc21"></a><span class="line-modified">225                 if (!closed)</span>
<span class="line-added">226                     try { ss.close(); } catch (IOException x) { unexpected(x); }</span>
227             }
228         }
229 
230         /**
231          * Returns the port on which the proxy is accepting connections.
232          */
233         public int getLocalPort() {
234             return ss.getLocalPort();
235         }
236 
<a name="22" id="anc22"></a><span class="line-added">237         @Override</span>
<span class="line-added">238         public void close() throws Exception {</span>
<span class="line-added">239             closed = true;</span>
<span class="line-added">240             ss.close();</span>
<span class="line-added">241         }</span>
<span class="line-added">242 </span>
243         /*
244          * Processes the CONNECT request
245          */
246         private void processRequest(Socket clientSocket) throws Exception {
247             MessageHeader mheader = new MessageHeader(clientSocket.getInputStream());
248             String statusLine = mheader.getValue(0);
249 
250             if (!statusLine.startsWith(&quot;CONNECT&quot;)) {
251                 out.println(&quot;proxy server: processes only &quot;
<a name="23" id="anc23"></a><span class="line-modified">252                                   + &quot;CONNECT method requests, received: &quot;</span>
253                                   + statusLine);
254                 return;
255             }
256 
257             // retrieve the host and port info from the status-line
258             InetSocketAddress serverAddr = getConnectInfo(statusLine);
<a name="24" id="anc24"></a><span class="line-added">259             out.println(&quot;Proxy serving CONNECT request to &quot; + serverAddr);</span>
260 
261             //open socket to the server
262             try (Socket serverSocket = new Socket(serverAddr.getAddress(),
263                                                   serverAddr.getPort())) {
264                 Forwarder clientFW = new Forwarder(clientSocket.getInputStream(),
265                                                    serverSocket.getOutputStream());
266                 Thread clientForwarderThread = new Thread(clientFW, &quot;ClientForwarder&quot;);
267                 clientForwarderThread.start();
268                 send200(clientSocket);
269                 Forwarder serverFW = new Forwarder(serverSocket.getInputStream(),
270                                                    clientSocket.getOutputStream());
271                 serverFW.run();
272                 clientForwarderThread.join();
273             }
274         }
275 
276         private void send200(Socket clientSocket) throws IOException {
277             OutputStream out = clientSocket.getOutputStream();
278             PrintWriter pout = new PrintWriter(out);
279 
280             pout.println(&quot;HTTP/1.1 200 OK&quot;);
281             pout.println();
282             pout.flush();
283         }
284 
285         /*
286          * This method retrieves the hostname and port of the tunnel destination
287          * from the request line.
288          * @param connectStr
289          *        of the form: &lt;i&gt;CONNECT server-name:server-port HTTP/1.x&lt;/i&gt;
290          */
291         static InetSocketAddress getConnectInfo(String connectStr)
292             throws Exception
293         {
294             try {
295                 int starti = connectStr.indexOf(&#39; &#39;);
296                 int endi = connectStr.lastIndexOf(&#39; &#39;);
297                 String connectInfo = connectStr.substring(starti+1, endi).trim();
298                 // retrieve server name and port
<a name="25" id="anc25"></a><span class="line-modified">299                 endi = connectInfo.lastIndexOf(&#39;:&#39;);</span>
300                 String name = connectInfo.substring(0, endi);
<a name="26" id="anc26"></a><span class="line-added">301 </span>
<span class="line-added">302                 if (name.contains(&quot;:&quot;)) {</span>
<span class="line-added">303                     if (!(name.startsWith(&quot;[&quot;) &amp;&amp; name.endsWith(&quot;]&quot;))) {</span>
<span class="line-added">304                         throw new IOException(&quot;Invalid host:&quot; + name);</span>
<span class="line-added">305                     }</span>
<span class="line-added">306                     name = name.substring(1, name.length() - 1);</span>
<span class="line-added">307                 }</span>
308                 int port = Integer.parseInt(connectInfo.substring(endi+1));
309                 return new InetSocketAddress(name, port);
310             } catch (Exception e) {
<a name="27" id="anc27"></a><span class="line-modified">311                 out.println(&quot;Proxy received a request: &quot; + connectStr);</span>
312                 throw unexpected(e);
313             }
314         }
315     }
316 
317     /* Reads from the given InputStream and writes to the given OutputStream */
318     static class Forwarder implements Runnable
319     {
320         private final InputStream in;
321         private final OutputStream os;
322 
323         Forwarder(InputStream in, OutputStream os) {
324             this.in = in;
325             this.os = os;
326         }
327 
328         @Override
329         public void run() {
330             try {
331                 byte[] ba = new byte[1024];
332                 int count;
333                 while ((count = in.read(ba)) != -1) {
334                     os.write(ba, 0, count);
335                 }
336             } catch (IOException e) {
337                 unexpected(e);
338             }
339         }
340     }
341 }
<a name="28" id="anc28"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="28" type="hidden" />
</body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old test/jdk/java/net/Socket/reset/Test.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2002, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 /*
 25  * @bug 4517622
 26  * @summary SocketException on first read after error; -1 on subsequent reads
 27  */
 28 import java.net.*;
 29 import java.io.*;
 30 import java.util.Random;
 31 
 32 public class Test {
 33 
 34     static int TEST_COMBINATIONS = 5;
 35 
 36     // test server that cycles through each combination of response
 37 
 38     static class Server extends Thread {
 39         ServerSocket ss;
 40 
 41         public Server() throws IOException {
 42             ss = new ServerSocket(0);
 43             System.out.println(&quot;Server listening on port: &quot; + getPort());
 44         }
 45 
 46         public void run() {
 47 
 48             int testCombination = 0;
 49 
 50             try {
 51                 for (;;) {
 52                     Socket s = ss.accept();
 53 
 54                     switch (testCombination) {
 55                         case 0:
 56                             s.setTcpNoDelay(false);
 57                             s.getOutputStream().write(new byte[256]);
 58                             s.setSoLinger(true, 0);
 59                             break;
 60 
 61                         case 1:
 62                             s.setTcpNoDelay(true);
 63                             s.getOutputStream().write(new byte[256]);
 64                             s.setSoLinger(true, 0);
 65                             break;
 66 
 67                         case 2:
 68                             s.getOutputStream().write(&quot;hello&quot;.getBytes());
 69                             s.setSoLinger(true, 0);
 70                             break;
 71 
 72                         case 3:
 73                             break;      /* EOF test */
 74 
 75                         case 4:
 76                             s.getOutputStream().write(new byte[256]);
 77                             break;
 78                     }
 79 
 80                     s.close();
 81 
 82                     testCombination = (testCombination + 1) % TEST_COMBINATIONS;
 83                 }
 84             } catch (IOException ioe) {
 85                 if (!ss.isClosed()) {
 86                     System.err.println(&quot;Server failed: &quot; + ioe);
 87                 }
 88             }
 89         }
 90 
 91         public int getPort() {
 92             return ss.getLocalPort();
 93         }
 94 
 95         public void shutdown() {
 96             try {
 97                 ss.close();
 98             } catch (IOException ioe) { }
 99         }
100 
101     }
102 
103     static final int STATE_DATA = 0;
104     static final int STATE_EOF = 1;
105     static final int STATE_IOE = 2;
106 
107     static void Test(SocketAddress sa) throws Exception {
108         System.out.println(&quot;-----------&quot;);
109 
110         Socket s = new Socket();
111         s.connect(sa);
112 
113         byte b[] = new byte[50];
114         int state = STATE_DATA;
115         boolean failed = false;
116 
117         Random rand = new Random();
118 
119         for (int i=0; i&lt;200; i++) {
120             switch (rand.nextInt(4)) {
121                 case 0:
122                     try {
123                         s.getOutputStream().write(&quot;data&quot;.getBytes());
124                     } catch (IOException ioe) { }
125                     break;
126 
127                 case 1:
128                     try {
129                         int n = s.getInputStream().available();
130 
131                         // available should never return &gt; 0 if read
132                         // has already thrown IOE or returned EOF
133 
134                         if (n &gt; 0 &amp;&amp; state != STATE_DATA) {
135                             System.out.println(&quot;FAILED!! available: &quot; + n +
136                                 &quot; (unexpected as IOE or EOF already received)&quot;);
137                             failed = true;
138                         }
139                     } catch (IOException ioe) {
140                         System.out.println(&quot;FAILED!!! available: &quot; + ioe);
141                         failed = true;
142                     }
143                     break;
144 
145                 case 2:
146                     try {
147                         int n = s.getInputStream().read(b);
148 
149                         if (n &gt; 0 &amp;&amp; state == STATE_IOE) {
150                             System.out.println(&quot;FAILED!! read: &quot; + n +
151                                 &quot; (unexpected as IOE already thrown)&quot;);
152                             failed = true;
153                         }
154 
155                         if (n &gt; 0 &amp;&amp; state == STATE_EOF) {
156                             System.out.println(&quot;FAILED!! read: &quot; + n +
157                                 &quot; (unexpected as EOF already received)&quot;);
158                             failed = true;
159                         }
160 
161                         if (n &lt; 0) {
162                             if (state == STATE_IOE) {
163                                 System.out.println(&quot;FAILED!! read: EOF &quot; +
164                                     &quot; (unexpected as IOE already thrown)&quot;);
165                                 failed = true;
166                             }
167                             if (state != STATE_EOF) {
168                                 System.out.println(&quot;read: EOF&quot;);
169                                 state = STATE_EOF;
170                             }
171                         }
172 
173                     } catch (IOException ioe) {
174                         if (state == STATE_EOF) {
175                             System.out.println(&quot;FAILED!! read: &quot; + ioe +
176                                 &quot; (unexpected as EOF already received)&quot;);
177                             failed = true;
178                         }
179                         if (state != STATE_IOE) {
180                             System.out.println(&quot;read: &quot; + ioe);
181                             state = STATE_IOE;
182                         }
183                     }
184                     break;
185 
186                 case 3:
187                     try {
188                         Thread.currentThread().sleep(100);
189                     } catch (Exception ie) { }
190             }
191 
192             if (failed) {
193                 failures++;
194                 break;
195             }
196         }
197 
198         s.close();
199     }
200 
201     static int failures = 0;
202 
203     public static void main(String args[]) throws Exception {
204         SocketAddress sa = null;
205         Server svr = null;
206 
207         // server mode only
208         if (args.length &gt; 0) {
209             if (args[0].equals(&quot;-server&quot;)) {
210                 svr = new Server();
211                 svr.start();
212                 return;
213             }
214         }
215 
216         // run standalone or connect to remote server
217         if (args.length &gt; 0) {
218             InetAddress rh = InetAddress.getByName(args[0]);
219             int port = Integer.parseInt(args[1]);
220             sa = new InetSocketAddress(rh, port);
221         } else {
222             svr = new Server();
223             svr.start();
224 
225             InetAddress lh = InetAddress.getLocalHost();
226             sa = new InetSocketAddress(lh, svr.getPort());
227         }
228 
229         for (int i=0; i&lt;10; i++) {
230             Test(sa);
231         }
232 
233         if (svr != null) {
234             svr.shutdown();
235         }
236 
237         if (failures &gt; 0) {
238             throw new Exception(failures + &quot; sub-test(s) failed.&quot;);
239         }
240     }
241 }
    </pre>
  </body>
</html>
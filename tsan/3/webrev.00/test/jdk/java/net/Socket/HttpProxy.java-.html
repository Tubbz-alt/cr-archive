<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old test/jdk/java/net/Socket/HttpProxy.java</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2010, 2018, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 /*
 25  * @test
 26  * @bug 6370908
 27  * @summary Add support for HTTP_CONNECT proxy in Socket class
 28  * @modules java.base/sun.net.www
 29  * @run main HttpProxy
 30  * @run main/othervm -Djava.net.preferIPv4Stack=true HttpProxy
 31  */
 32 
 33 import java.io.IOException;
 34 import java.io.InputStream;
 35 import java.io.OutputStream;
 36 import java.io.PrintWriter;
 37 import static java.lang.System.out;
 38 import java.net.InetAddress;
 39 import java.net.InetSocketAddress;
 40 import java.net.Proxy;
 41 import java.net.ServerSocket;
 42 import java.net.Socket;
 43 import sun.net.www.MessageHeader;
 44 
 45 public class HttpProxy {
 46     final String proxyHost;
 47     final int proxyPort;
 48     static final int SO_TIMEOUT = 15000;
 49 
 50     public static void main(String[] args) throws Exception {
 51         String host;
 52         int port;
 53         if (args.length == 0) {
 54             // Start internal proxy
 55             ConnectProxyTunnelServer proxy = new ConnectProxyTunnelServer();
 56             proxy.start();
 57             host = &quot;localhost&quot;;
 58             port = proxy.getLocalPort();
 59             out.println(&quot;Running with internal proxy: &quot; + host + &quot;:&quot; + port);
 60         } else if (args.length == 2) {
 61             host = args[0];
 62             port = Integer.valueOf(args[1]);
 63             out.println(&quot;Running against specified proxy server: &quot; + host + &quot;:&quot; + port);
 64         } else {
 65             System.err.println(&quot;Usage: java HttpProxy [&lt;proxy host&gt; &lt;proxy port&gt;]&quot;);
 66             return;
 67         }
 68 
 69         HttpProxy p = new HttpProxy(host, port);
 70         p.test();
 71     }
 72 
 73     public HttpProxy(String proxyHost, int proxyPort) {
 74         this.proxyHost = proxyHost;
 75         this.proxyPort = proxyPort;
 76     }
 77 
 78     void test() throws Exception {
 79         InetSocketAddress proxyAddress = new InetSocketAddress(proxyHost, proxyPort);
 80         Proxy httpProxy = new Proxy(Proxy.Type.HTTP, proxyAddress);
 81 
 82         try (ServerSocket ss = new ServerSocket(0);
 83              Socket sock = new Socket(httpProxy)) {
 84             sock.setSoTimeout(SO_TIMEOUT);
 85             sock.setTcpNoDelay(false);
 86 
 87             InetSocketAddress externalAddress =
 88                 new InetSocketAddress(InetAddress.getLocalHost(), ss.getLocalPort());
 89 
 90             out.println(&quot;Trying to connect to server socket on &quot; + externalAddress);
 91             sock.connect(externalAddress);
 92             try (Socket externalSock = ss.accept()) {
 93                 // perform some simple checks
 94                 check(sock.isBound(), &quot;Socket is not bound&quot;);
 95                 check(sock.isConnected(), &quot;Socket is not connected&quot;);
 96                 check(!sock.isClosed(), &quot;Socket should not be closed&quot;);
 97                 check(sock.getSoTimeout() == SO_TIMEOUT,
 98                         &quot;Socket should have a previously set timeout&quot;);
 99                 check(sock.getTcpNoDelay() ==  false, &quot;NODELAY should be false&quot;);
100 
101                 simpleDataExchange(sock, externalSock);
102             }
103         }
104     }
105 
106     static void check(boolean condition, String message) {
107         if (!condition) out.println(message);
108     }
109 
110     static Exception unexpected(Exception e) {
111         out.println(&quot;Unexcepted Exception: &quot; + e);
112         e.printStackTrace();
113         return e;
114     }
115 
116     // performs a simple exchange of data between the two sockets
117     // and throws an exception if there is any problem.
118     void simpleDataExchange(Socket s1, Socket s2) throws Exception {
119         try (final InputStream i1 = s1.getInputStream();
120              final InputStream i2 = s2.getInputStream();
121              final OutputStream o1 = s1.getOutputStream();
122              final OutputStream o2 = s2.getOutputStream()) {
123             startSimpleWriter(&quot;simpleWriter1&quot;, o1, 100);
124             startSimpleWriter(&quot;simpleWriter2&quot;, o2, 200);
125             simpleRead(i2, 100);
126             simpleRead(i1, 200);
127         }
128     }
129 
130     void startSimpleWriter(String threadName, final OutputStream os, final int start) {
131         (new Thread(new Runnable() {
132             public void run() {
133                 try { simpleWrite(os, start); }
134                 catch (Exception e) {unexpected(e); }
135             }}, threadName)).start();
136     }
137 
138     void simpleWrite(OutputStream os, int start) throws Exception {
139         byte b[] = new byte[2];
140         for (int i=start; i&lt;start+100; i++) {
141             b[0] = (byte) (i / 256);
142             b[1] = (byte) (i % 256);
143             os.write(b);
144         }
145     }
146 
147     void simpleRead(InputStream is, int start) throws Exception {
148         byte b[] = new byte [2];
149         for (int i=start; i&lt;start+100; i++) {
150             int x = is.read(b);
151             if (x == 1)
152                 x += is.read(b,1,1);
153             if (x!=2)
154                 throw new Exception(&quot;read error&quot;);
155             int r = bytes(b[0], b[1]);
156             if (r != i)
157                 throw new Exception(&quot;read &quot; + r + &quot; expected &quot; +i);
158         }
159     }
160 
161     int bytes(byte b1, byte b2) {
162         int i1 = (int)b1 &amp; 0xFF;
163         int i2 = (int)b2 &amp; 0xFF;
164         return i1 * 256 + i2;
165     }
166 
167     static class ConnectProxyTunnelServer extends Thread {
168 
169         private final ServerSocket ss;
170 
171         public ConnectProxyTunnelServer() throws IOException {
172             ss = new ServerSocket(0);
173         }
174 
175         @Override
176         public void run() {
177             try (Socket clientSocket = ss.accept()) {
178                 processRequest(clientSocket);
179             } catch (Exception e) {
180                 out.println(&quot;Proxy Failed: &quot; + e);
181                 e.printStackTrace();
182             } finally {
183                 try { ss.close(); } catch (IOException x) { unexpected(x); }
184             }
185         }
186 
187         /**
188          * Returns the port on which the proxy is accepting connections.
189          */
190         public int getLocalPort() {
191             return ss.getLocalPort();
192         }
193 
194         /*
195          * Processes the CONNECT request
196          */
197         private void processRequest(Socket clientSocket) throws Exception {
198             MessageHeader mheader = new MessageHeader(clientSocket.getInputStream());
199             String statusLine = mheader.getValue(0);
200 
201             if (!statusLine.startsWith(&quot;CONNECT&quot;)) {
202                 out.println(&quot;proxy server: processes only &quot;
203                                   + &quot;CONNECT method requests, recieved: &quot;
204                                   + statusLine);
205                 return;
206             }
207 
208             // retrieve the host and port info from the status-line
209             InetSocketAddress serverAddr = getConnectInfo(statusLine);
210 
211             //open socket to the server
212             try (Socket serverSocket = new Socket(serverAddr.getAddress(),
213                                                   serverAddr.getPort())) {
214                 Forwarder clientFW = new Forwarder(clientSocket.getInputStream(),
215                                                    serverSocket.getOutputStream());
216                 Thread clientForwarderThread = new Thread(clientFW, &quot;ClientForwarder&quot;);
217                 clientForwarderThread.start();
218                 send200(clientSocket);
219                 Forwarder serverFW = new Forwarder(serverSocket.getInputStream(),
220                                                    clientSocket.getOutputStream());
221                 serverFW.run();
222                 clientForwarderThread.join();
223             }
224         }
225 
226         private void send200(Socket clientSocket) throws IOException {
227             OutputStream out = clientSocket.getOutputStream();
228             PrintWriter pout = new PrintWriter(out);
229 
230             pout.println(&quot;HTTP/1.1 200 OK&quot;);
231             pout.println();
232             pout.flush();
233         }
234 
235         /*
236          * This method retrieves the hostname and port of the tunnel destination
237          * from the request line.
238          * @param connectStr
239          *        of the form: &lt;i&gt;CONNECT server-name:server-port HTTP/1.x&lt;/i&gt;
240          */
241         static InetSocketAddress getConnectInfo(String connectStr)
242             throws Exception
243         {
244             try {
245                 int starti = connectStr.indexOf(&#39; &#39;);
246                 int endi = connectStr.lastIndexOf(&#39; &#39;);
247                 String connectInfo = connectStr.substring(starti+1, endi).trim();
248                 // retrieve server name and port
249                 endi = connectInfo.indexOf(&#39;:&#39;);
250                 String name = connectInfo.substring(0, endi);
251                 int port = Integer.parseInt(connectInfo.substring(endi+1));
252                 return new InetSocketAddress(name, port);
253             } catch (Exception e) {
254                 out.println(&quot;Proxy recieved a request: &quot; + connectStr);
255                 throw unexpected(e);
256             }
257         }
258     }
259 
260     /* Reads from the given InputStream and writes to the given OutputStream */
261     static class Forwarder implements Runnable
262     {
263         private final InputStream in;
264         private final OutputStream os;
265 
266         Forwarder(InputStream in, OutputStream os) {
267             this.in = in;
268             this.os = os;
269         }
270 
271         @Override
272         public void run() {
273             try {
274                 byte[] ba = new byte[1024];
275                 int count;
276                 while ((count = in.read(ba)) != -1) {
277                     os.write(ba, 0, count);
278                 }
279             } catch (IOException e) {
280                 unexpected(e);
281             }
282         }
283     }
284 }
    </pre>
  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old test/jdk/java/net/Authenticator/B4769350.java</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2002, 2016, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 /**
 25  * @test
 26  * @bug 4769350 8017779
 27  * @modules jdk.httpserver
 28  * @run main/othervm B4769350 server
 29  * @run main/othervm B4769350 proxy
 30  * @summary proxy authentication username and password caching only works in serial case
 31  * Run in othervm since the test sets system properties that are read by the
 32  * networking stack and cached when the HTTP handler is invoked, and previous
 33  * tests may already have invoked the HTTP handler.
 34  */
 35 
 36 import com.sun.net.httpserver.HttpExchange;
 37 import com.sun.net.httpserver.HttpHandler;
 38 import com.sun.net.httpserver.HttpServer;
 39 import java.io.*;
 40 import java.net.*;
 41 import java.util.concurrent.BrokenBarrierException;
 42 import java.util.concurrent.CountDownLatch;
 43 import java.util.concurrent.CyclicBarrier;
 44 import java.util.concurrent.Executor;
 45 import java.util.concurrent.ExecutorService;
 46 import java.util.concurrent.Executors;
 47 
 48 public class B4769350 {
 49 
 50     static int count = 0;
 51     static boolean error = false;
 52 
 53     static void read (InputStream is) throws IOException {
 54         while (is.read() != -1) {
 55             //System.out.write (c);
 56         }
 57     }
 58 
 59      static class Client extends Thread {
 60         String authority, path;
 61         boolean allowerror;
 62 
 63         Client (String authority, String path, boolean allowerror) {
 64             super(&quot;Thread-&quot; + path);
 65             this.authority = authority;
 66             this.path = path;
 67             this.allowerror = allowerror;
 68         }
 69 
 70         @Override
 71         public void run () {
 72             try {
 73                 URI u = new URI (&quot;http&quot;, authority, path, null, null);
 74                 URL url = u.toURL();
 75                 URLConnection urlc = url.openConnection();
 76                 try (InputStream is = urlc.getInputStream()) {
 77                     read (is);
 78                 }
 79             } catch (URISyntaxException  e) {
 80                 System.out.println (e);
 81                 error = true;
 82             } catch (IOException e) {
 83                 if (!allowerror) {
 84                     System.out.println (Thread.currentThread().getName()
 85                             + &quot; &quot; + e);
 86                     e.printStackTrace();
 87                     error = true;
 88                 }
 89             }
 90         }
 91     }
 92 
 93     class Server implements AutoCloseable {
 94         HttpServer server;
 95         Executor executor;
 96 
 97         public String getAddress() {
 98             return server.getAddress().getHostName();
 99         }
100 
101         public void startServer() {
102             InetSocketAddress addr = new InetSocketAddress(0);
103 
104             try {
105                 server = HttpServer.create(addr, 0);
106             } catch (IOException ioe) {
107                 throw new RuntimeException(&quot;Server could not be created&quot;);
108             }
109             executor = Executors.newFixedThreadPool(10);
110             server.setExecutor(executor);
111             server.createContext(&quot;/test/realm1/t1a&quot;,
112                     new AuthenticationHandlerT1a() );
113             server.createContext(&quot;/test/realm2/t1b&quot;,
114                     new AuthenticationHandlerT1b());
115             server.createContext(&quot;/test/realm1/t1c&quot;,
116                     new AuthenticationHandlerT1c());
117             server.createContext(&quot;/test/realm2/t1d&quot;,
118                     new AuthenticationHandlerT1d());
119             server.createContext(&quot;/test/realm3/t2a&quot;,
120                     new AuthenticationHandlerT2a());
121             server.createContext(&quot;/test/realm3/t2b&quot;,
122                     new AuthenticationHandlerT2b());
123             server.createContext(&quot;/test/realm4/t3a&quot;,
124                     new AuthenticationHandlerT3a());
125             server.createContext(&quot;/test/realm4/t3b&quot;,
126                     new AuthenticationHandlerT3bc());
127             server.createContext(&quot;/test/realm4/t3c&quot;,
128                     new AuthenticationHandlerT3bc());
129             t1Cond1 = new CyclicBarrier(3);
130             server.start();
131         }
132 
133         public int getPort() {
134             return server.getAddress().getPort();
135         }
136 
137         @Override
138         public void close() {
139             if (executor != null)
140                 ((ExecutorService)executor).shutdownNow();
141             if (server != null)
142                 server.stop(0);
143         }
144 
145         /* T1 tests the client by sending 4 requests to 2 different realms
146          * in parallel. The client should recognise two pairs of dependent requests
147          * and execute the first of each pair in parallel. When they both succeed
148          * the second requests should be executed without calling the authenticator.
149          * The test succeeds if the authenticator was only called twice.
150          */
151         class AuthenticationHandlerT1a implements HttpHandler
152         {
153             volatile int count = -1;
154 
155             @Override
156             public void handle(HttpExchange exchange) throws IOException {
157                 count++;
158                 try {
159                     switch(count) {
160                         case 0:
161                             AuthenticationHandler.errorReply(exchange,
162                                     &quot;Basic realm=\&quot;realm1\&quot;&quot;);
163                             break;
164                         case 1:
165                             t1Cond1.await();
166                             AuthenticationHandler.okReply(exchange);
167                             break;
168                         default:
169                             System.out.println (&quot;Unexpected request&quot;);
170                     }
171                 } catch (InterruptedException |
172                                  BrokenBarrierException e)
173                         {
174                             throw new RuntimeException(e);
175                         }
176             }
177         }
178 
179         class AuthenticationHandlerT1b implements HttpHandler
180         {
181             volatile int count = -1;
182 
183             @Override
184             public void handle(HttpExchange exchange) throws IOException {
185                 count++;
186                 try {
187                     switch(count) {
188                         case 0:
189                             AuthenticationHandler.errorReply(exchange,
190                                     &quot;Basic realm=\&quot;realm2\&quot;&quot;);
191                             break;
192                         case 1:
193                             t1Cond1.await();
194                             AuthenticationHandler.okReply(exchange);
195                             break;
196                         default:
197                             System.out.println (&quot;Unexpected request&quot;);
198                     }
199                 } catch (InterruptedException | BrokenBarrierException e) {
200                     throw new RuntimeException(e);
201                 }
202             }
203         }
204 
205         class AuthenticationHandlerT1c implements HttpHandler
206         {
207             volatile int count = -1;
208 
209             @Override
210             public void handle(HttpExchange exchange) throws IOException {
211                 count++;
212                 switch(count) {
213                     case 0:
214                         AuthenticationHandler.errorReply(exchange,
215                                 &quot;Basic realm=\&quot;realm1\&quot;&quot;);
216                         break;
217                     case 1:
218                         AuthenticationHandler.okReply(exchange);
219                         break;
220                     default:
221                         System.out.println (&quot;Unexpected request&quot;);
222                 }
223             }
224         }
225 
226         class AuthenticationHandlerT1d implements HttpHandler
227         {
228             volatile int count = -1;
229 
230             @Override
231             public void handle(HttpExchange exchange) throws IOException {
232                 count++;
233                 switch(count) {
234                     case 0:
235                         AuthenticationHandler.errorReply(exchange,
236                                 &quot;Basic realm=\&quot;realm2\&quot;&quot;);
237                         break;
238                     case 1:
239                         AuthenticationHandler.okReply(exchange);
240                         break;
241                     default:
242                         System.out.println (&quot;Unexpected request&quot;);
243                 }
244             }
245         }
246 
247         /* T2 tests to check that if initial authentication fails, the second will
248          * succeed, and the authenticator is called twice
249          */
250 
251         class AuthenticationHandlerT2a implements HttpHandler
252         {
253             volatile int count = -1;
254 
255             @Override
256             public void handle(HttpExchange exchange) throws IOException {
257                 count++;
258                 if (count == 1) {
259                     t2condlatch.countDown();
260                 }
261                 AuthenticationHandler.errorReply(exchange,
262                         &quot;Basic realm=\&quot;realm3\&quot;&quot;);
263 
264             }
265         }
266 
267          class AuthenticationHandlerT2b implements HttpHandler
268         {
269             volatile int count = -1;
270 
271             @Override
272             public void handle(HttpExchange exchange) throws IOException {
273                 count++;
274                 switch(count) {
275                     case 0:
276                         AuthenticationHandler.errorReply(exchange,
277                                 &quot;Basic realm=\&quot;realm3\&quot;&quot;);
278                         break;
279                     case 1:
280                         AuthenticationHandler.okReply(exchange);
281                         break;
282                     default:
283                         System.out.println (&quot;Unexpected request&quot;);
284                 }
285             }
286         }
287 
288         /* T3 tests proxy and server authentication. three threads request same
289          * resource at same time. Authenticator should be called once for server
290          * and once for proxy
291          */
292 
293         class AuthenticationHandlerT3a implements HttpHandler
294         {
295             volatile int count = -1;
296 
297             @Override
298             public void handle(HttpExchange exchange) throws IOException {
299                 count++;
300                 switch(count) {
301                     case 0:
302                         AuthenticationHandler.proxyReply(exchange,
303                                 &quot;Basic realm=\&quot;proxy\&quot;&quot;);
304                         break;
305                     case 1:
306                         t3cond1.countDown();
307                         AuthenticationHandler.errorReply(exchange,
308                                 &quot;Basic realm=\&quot;realm4\&quot;&quot;);
309                         break;
310                     case 2:
311                         AuthenticationHandler.okReply(exchange);
312                         break;
313                     default:
314                         System.out.println (&quot;Unexpected request&quot;);
315                 }
316             }
317         }
318 
319         class AuthenticationHandlerT3bc implements HttpHandler
320         {
321             volatile int count = -1;
322 
323             @Override
324             public void handle(HttpExchange exchange) throws IOException {
325                 count++;
326                 switch(count) {
327                     case 0:
328                         AuthenticationHandler.proxyReply(exchange,
329                                 &quot;Basic realm=\&quot;proxy\&quot;&quot;);
330                         break;
331                     case 1:
332                         AuthenticationHandler.okReply(exchange);
333                         break;
334                     default:
335                         System.out.println (&quot;Unexpected request&quot;);
336                 }
337             }
338         }
339     }
340 
341     static class AuthenticationHandler {
342         static void errorReply(HttpExchange exchange, String reply)
343                 throws IOException
344         {
345             exchange.getResponseHeaders().add(&quot;Connection&quot;, &quot;close&quot;);
346             exchange.getResponseHeaders().add(&quot;WWW-Authenticate&quot;, reply);
347             exchange.sendResponseHeaders(401, 0);
348             exchange.close();
349         }
350 
351         static void proxyReply (HttpExchange exchange, String reply)
352                 throws IOException
353         {
354             exchange.getResponseHeaders().add(&quot;Proxy-Authenticate&quot;, reply);
355             exchange.sendResponseHeaders(407, 0);
356         }
357 
358         static void okReply (HttpExchange exchange) throws IOException {
359             exchange.getResponseHeaders().add(&quot;Connection&quot;, &quot;close&quot;);
360             String response = &quot;Hello .&quot;;
361             exchange.sendResponseHeaders(200, response.getBytes().length);
362             try (OutputStream os = exchange.getResponseBody()) {
363                 os.write(response.getBytes());
364             }
365             exchange.close();
366         }
367     }
368 
369     static Server server;
370     static MyAuthenticator auth = new MyAuthenticator ();
371 
372     static int redirects = 4;
373 
374     static Client c1,c2,c3,c4,c5,c6,c7,c8,c9;
375 
376     static CountDownLatch t2condlatch;
377     static CountDownLatch t3cond1;
378     static CyclicBarrier t1Cond1;
379 
380     static void doServerTests (String authority, Server server) throws Exception
381     {
382         System.out.println (&quot;Doing Server tests&quot;);
383         System.out.println (&quot;T1&quot;);
384         c1 = new Client (authority, &quot;/test/realm1/t1a&quot;, false);
385         c2 = new Client (authority, &quot;/test/realm2/t1b&quot;, false);
386         c3 = new Client (authority, &quot;/test/realm1/t1c&quot;, false);
387         c4 = new Client (authority, &quot;/test/realm2/t1d&quot;, false);
388         c1.start(); c2.start();
389         t1Cond1.await();
390         c3.start(); c4.start();
391         c1.join(); c2.join(); c3.join(); c4.join();
392 
393         int f = auth.getCount();
394         if (f != 2) {
395             except (&quot;Authenticator was called &quot;+f+&quot; times. Should be 2&quot;,
396                     server);
397         }
398         if (error) {
399             except (&quot;error occurred&quot;, server);
400         }
401 
402         auth.resetCount();
403         System.out.println (&quot;T2&quot;);
404 
405         c5 = new Client (authority, &quot;/test/realm3/t2a&quot;, true);
406         c6 = new Client (authority, &quot;/test/realm3/t2b&quot;, false);
407         t2condlatch = new CountDownLatch(1);
408         c5.start ();
409         t2condlatch.await();
410         c6.start ();
411         c5.join(); c6.join();
412 
413         f = auth.getCount();
414         if (f != redirects+1) {
415             except (&quot;Authenticator was called &quot;+f+&quot; times. Should be: &quot;
416                     + redirects+1, server);
417         }
418         if (error) {
419             except (&quot;error occurred&quot;, server);
420         }
421     }
422 
423     static void doProxyTests (String authority, Server server) throws Exception
424     {
425         System.out.println (&quot;Doing Proxy tests&quot;);
426         c7 = new Client (authority, &quot;/test/realm4/t3a&quot;, false);
427         c8 = new Client (authority, &quot;/test/realm4/t3b&quot;, false);
428         c9 = new Client (authority, &quot;/test/realm4/t3c&quot;, false);
429         t3cond1 = new CountDownLatch(1);
430         c7.start ();
431         t3cond1.await();
432         c8.start ();
433         c9.start ();
434         c7.join(); c8.join(); c9.join();
435 
436         int f = auth.getCount();
437         if (f != 2) {
438             except (&quot;Authenticator was called &quot;+f+&quot; times. Should be: &quot; + 2,
439                     server);
440         }
441         if (error) {
442             except (&quot;error occurred&quot;, server);
443         }
444     }
445 
446     public static void main (String[] args) throws Exception {
447         new B4769350().runTest(args[0].equals (&quot;proxy&quot;));
448     }
449 
450     public void runTest(boolean proxy) throws Exception {
451         System.setProperty (&quot;http.maxRedirects&quot;, Integer.toString (redirects));
452         System.setProperty (&quot;http.auth.serializeRequests&quot;, &quot;true&quot;);
453         Authenticator.setDefault (auth);
454         try (Server server = new Server()) {
455             server.startServer();
456             System.out.println (&quot;Server: listening on port: &quot;
457                     + server.getPort());
458             if (proxy) {
459                 System.setProperty (&quot;http.proxyHost&quot;, &quot;localhost&quot;);
460                 System.setProperty (&quot;http.proxyPort&quot;,
461                         Integer.toString(server.getPort()));
462                 doProxyTests (&quot;www.foo.com&quot;, server);
463             } else {
464                 doServerTests (&quot;localhost:&quot;+server.getPort(), server);
465             }
466         }
467 
468     }
469 
470     public static void except (String s, Server server) {
471         server.close();
472         throw new RuntimeException (s);
473     }
474 
475     static class MyAuthenticator extends Authenticator {
476         MyAuthenticator () {
477             super ();
478         }
479 
480         volatile int count = 0;
481 
482         @Override
483         public PasswordAuthentication getPasswordAuthentication () {
484             PasswordAuthentication pw;
485             pw = new PasswordAuthentication (&quot;user&quot;, &quot;pass1&quot;.toCharArray());
486             count ++;
487             return pw;
488         }
489 
490         public void resetCount () {
491             count = 0;
492         }
493 
494         public int getCount () {
495             return count;
496         }
497     }
498 }
499 
    </pre>
  </body>
</html>
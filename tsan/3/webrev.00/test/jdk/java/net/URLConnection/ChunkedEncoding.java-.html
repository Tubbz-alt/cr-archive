<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old test/jdk/java/net/URLConnection/ChunkedEncoding.java</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2001, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 /**
 25  *
 26  * @bug 4333920
 27  * @bug 4394548
 28  * @summary Check that chunked encoding response doesn&#39;t cause
 29  *          getInputStream to block until last chunk arrives.
 30  *          Also regression against NPE in ChunkedInputStream.
 31  */
 32 import java.net.*;
 33 import java.io.*;
 34 import java.util.Random;
 35 
 36 public class ChunkedEncoding implements Runnable {
 37 
 38     ServerSocket ss;
 39 
 40     /*
 41      * Our &quot;http&quot; server to return a chunked response
 42      */
 43     public void run() {
 44         try {
 45             Socket s = ss.accept();
 46 
 47             PrintStream out = new PrintStream(
 48                                  new BufferedOutputStream(
 49                                     s.getOutputStream() ));
 50 
 51             /* send the header */
 52             out.print(&quot;HTTP/1.1 200\r\n&quot;);
 53             out.print(&quot;Transfer-Encoding: chunked\r\n&quot;);
 54             out.print(&quot;Content-Type: text/html\r\n&quot;);
 55             out.print(&quot;\r\n&quot;);
 56             out.flush();
 57 
 58             /* delay the server before first chunk */
 59             Thread.sleep(5000);
 60 
 61             /*
 62              * Our response will be of random length
 63              * but &gt; 32k
 64              */
 65             Random rand = new Random();
 66 
 67             int len;
 68             do {
 69                 len = rand.nextInt(128*1024);
 70             } while (len &lt; 32*1024);
 71 
 72             /*
 73              * Our chunk size will be 2-32k
 74              */
 75             int chunkSize;
 76             do {
 77                 chunkSize = rand.nextInt(len / 3);
 78             } while (chunkSize &lt; 2*1024);
 79 
 80             /*
 81              * Generate random content and check sum it
 82              */
 83             byte buf[] = new byte[len];
 84             int cs = 0;
 85             for (int i=0; i&lt;len; i++) {
 86                 buf[i] = (byte)(&#39;a&#39; + rand.nextInt(26));
 87                 cs = (cs + buf[i]) % 65536;
 88             }
 89 
 90             /*
 91              * Stream the chunks to the client
 92              */
 93             int remaining = len;
 94             int pos = 0;
 95             while (remaining &gt; 0) {
 96                 int size = Math.min(remaining, chunkSize);
 97                 out.print( Integer.toHexString(size) );
 98                 out.print(&quot;\r\n&quot;);
 99                 out.write( buf, pos, size );
100                 pos += size;
101                 remaining -= size;
102                 out.print(&quot;\r\n&quot;);
103                 out.flush();
104             }
105 
106             /* send EOF chunk */
107             out.print(&quot;0\r\n&quot;);
108             out.flush();
109 
110             /*
111              * Send trailer with checksum
112              */
113             String trailer = &quot;Checksum:&quot; + cs + &quot;\r\n&quot;;
114             out.print(trailer);
115             out.print(&quot;\r\n&quot;);
116             out.flush();
117 
118             s.close();
119             ss.close();
120         } catch (Exception e) {
121             e.printStackTrace();
122         }
123     }
124 
125     ChunkedEncoding() throws Exception {
126 
127         /* start the server */
128         ss = new ServerSocket(0);
129         (new Thread(this)).start();
130 
131         /* establish http connection to server */
132         String uri = &quot;http://localhost:&quot; +
133                      Integer.toString(ss.getLocalPort()) +
134                      &quot;/foo&quot;;
135         URL url = new URL(uri);
136         HttpURLConnection http = (HttpURLConnection)url.openConnection();
137 
138         /*
139          * Server should only send headers if TE:trailers
140          * specified - see updated HTTP 1.1 spec.
141          */
142         http.setRequestProperty(&quot;TE&quot;, &quot;trailers&quot;);
143 
144         /* Time how long the getInputStream takes */
145         long ts = System.currentTimeMillis();
146         InputStream in = http.getInputStream();
147         long te = System.currentTimeMillis();
148 
149         /*
150          * If getInputStream takes &gt;2 seconds it probably means
151          * that the implementation is waiting for the chunks to
152          * arrive.
153          */
154         if ( (te-ts) &gt; 2000) {
155             throw new Exception(&quot;getInputStream didn&#39;t return immediately&quot;);
156         }
157 
158         /*
159          * Read the stream and checksum it as it arrives
160          */
161         int nread;
162         int cs = 0;
163         byte b[] = new byte[1024];
164         do {
165             nread = in.read(b);
166             if (nread &gt; 0) {
167                 for (int i=0; i&lt;nread; i++) {
168                     cs = (cs + b[i]) % 65536;
169                 }
170             }
171         } while (nread &gt; 0);
172 
173         /*
174          * Verify that the checksums match
175          */
176         String trailer = http.getHeaderField(&quot;Checksum&quot;);
177         if (trailer == null) {
178             throw new Exception(&quot;Checksum trailer missing from response&quot;);
179         }
180         int rcvd_cs = Integer.parseInt(trailer);
181         if (rcvd_cs != cs) {
182             throw new Exception(&quot;Trailer checksum doesn&#39;t equal calculated checksum&quot;);
183         }
184 
185         http.disconnect();
186 
187     }
188 
189     public static void main(String args[]) throws Exception {
190         new ChunkedEncoding();
191     }
192 
193 }
    </pre>
  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New test/jdk/java/net/URLConnection/HandleContentTypeWithAttrs.java</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 1998, 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 /*
 25  * @test
 26  * @bug 4160200
 27  * @summary Make sure URLConnection.getContentHandler
 28  *     can handle MIME types with attributes
 29  * @library /test/lib
 30  * @modules java.base/sun.net.www java.base/sun.net.www.content.text
 31  */
 32 import java.net.*;
 33 import java.io.*;
 34 import sun.net.www.content.text.*;
 35 import sun.net.www.MessageHeader;
 36 import static java.net.Proxy.NO_PROXY;
 37 
 38 import jdk.test.lib.net.URIBuilder;
 39 
 40 public class HandleContentTypeWithAttrs {
 41 
 42     URL url;
 43 
 44     public HandleContentTypeWithAttrs (int port) throws Exception {
 45 
 46         // Request echo.html from myHttpServer.
 47         // In the header of the response, we make
 48         // the content type have some attributes.
 49         url = URIBuilder.newBuilder()
 50                 .scheme(&quot;http&quot;)
 51                 .loopback()
 52                 .port(port)
 53                 .path(&quot;/echo.html&quot;)
 54                 .toURL();
 55         URLConnection urlConn = url.openConnection(NO_PROXY);
 56 
 57         // the method getContent() calls the method
 58         // getContentHandler(). With the fix, the method
 59         // getContentHandler() gets the correct content
 60         // handler for our response -  it should be the
 61         // PlainText conten handler; without the fix,
 62         // it gets the UnknownContent handler.
 63         // So based on what the getContent()
 64         // returns, we know whether getContentHandler()
 65         // can handle content type with attributes or not.
 66         Object obj = urlConn.getContent();
 67 
 68         if (!(obj instanceof PlainTextInputStream))
 69             throw new Exception(&quot;Cannot get the correct content handler.&quot;);
 70     }
 71 
 72     public static void main(String [] argv) throws Exception {
 73         // Start myHttpServer
 74         myHttpServer testServer = new myHttpServer();
 75         testServer.startServer(0);
 76         int serverPort = testServer.getServerLocalPort();
 77         new HandleContentTypeWithAttrs(serverPort);
 78     }
 79 }
 80 
 81 // myHttpServer is pretty much like
 82 // sun.net.www.httpd.BasicHttpServer.
 83 // But we only need it to handle one
 84 // simple request.
 85 class myHttpServer implements Runnable, Cloneable {
 86 
 87     /** Socket for communicating with client. */
 88     public Socket clientSocket = null;
 89     private Thread serverInstance;
 90     private ServerSocket serverSocket;
 91 
 92     /** Stream for printing to the client. */
 93     public PrintStream clientOutput;
 94 
 95     /** Buffered stream for reading replies from client. */
 96     public InputStream clientInput;
 97 
 98     static URL defaultContext;
 99 
100     /** Close an open connection to the client. */
101     public void close() throws IOException {
102         clientSocket.close();
103         clientSocket = null;
104         clientInput = null;
105         clientOutput = null;
106     }
107 
108     final public void run() {
109         if (serverSocket != null) {
110             Thread.currentThread().setPriority(Thread.MAX_PRIORITY);
111 
112             try {
113                 // wait for incoming request
114                 Socket ns = serverSocket.accept();
115                 myHttpServer n = (myHttpServer)clone();
116                 n.serverSocket = null;
117                 n.clientSocket = ns;
118                 new Thread(n).start();
119             } catch(Exception e) {
120                 System.out.print(&quot;Server failure\n&quot;);
121                 e.printStackTrace();
122             } finally {
123                 try { serverSocket.close(); } catch(IOException unused) {}
124             }
125         } else {
126             try {
127                 clientOutput = new PrintStream(
128                     new BufferedOutputStream(clientSocket.getOutputStream()),
129                                              false);
130                 clientInput = new BufferedInputStream(
131                                              clientSocket.getInputStream());
132                 serviceRequest();
133 
134             } catch(Exception e) {
135                 // System.out.print(&quot;Service handler failure\n&quot;);
136                 // e.printStackTrace();
137             } finally {
138                 try { close(); }  catch(IOException unused) {}
139             }
140         }
141     }
142 
143     /** Start a server on port &lt;i&gt;port&lt;/i&gt;.  It will call serviceRequest()
144         for each new connection. */
145     final public void startServer(int port) throws IOException {
146         serverSocket = new ServerSocket(port, 50,
147                 InetAddress.getLoopbackAddress());
148         serverInstance = new Thread(this);
149         serverInstance.start();
150     }
151 
152     final public int getServerLocalPort() throws Exception {
153         if (serverSocket != null) {
154             return serverSocket.getLocalPort();
155         }
156         throw new Exception(&quot;serverSocket is null&quot;);
157     }
158 
159     MessageHeader mh;
160 
161     final public void serviceRequest() {
162         //totalConnections++;
163         try {
164             mh = new MessageHeader(clientInput);
165             String cmd = mh.findValue(null);
166             // if (cmd == null) {
167             //  error(&quot;Missing command &quot; + mh);
168             //  return;
169             // }
170             int fsp = cmd.indexOf(&#39; &#39;);
171             // if (fsp &lt; 0) {
172             //  error(&quot;Syntax error in command: &quot; + cmd);
173             //  return;
174             //  }
175             String k = cmd.substring(0, fsp);
176             int nsp = cmd.indexOf(&#39; &#39;, fsp + 1);
177             String p1, p2;
178             if (nsp &gt; 0) {
179                 p1 = cmd.substring(fsp + 1, nsp);
180                 p2 = cmd.substring(nsp + 1);
181             } else {
182                 p1 = cmd.substring(fsp + 1);
183                 p2 = null;
184             }
185             // expectsMime = p2 != null;
186             if (k.equalsIgnoreCase(&quot;get&quot;))
187                 getRequest(new URL(defaultContext, p1), p2);
188             else {
189                 //      error(&quot;Unknown command: &quot; + k + &quot; (&quot; + cmd + &quot;)&quot;);
190                 return;
191             }
192         } catch(IOException e) {
193             // totally ignore IOException.  They&#39;re usually client crashes.
194         } catch(Exception e) {
195             //  error(&quot;Exception: &quot; + e);
196             e.printStackTrace();
197         }
198     }
199 
200     /** Satisfy one get request.  It is invoked with the clientInput and
201         clientOutput streams initialized.  This method handles one client
202         connection. When it is done, it can simply exit. The default
203         server just echoes it&#39;s input. */
204     protected void getRequest(URL u, String param) {
205         try {
206             if (u.getFile().equals(&quot;/echo.html&quot;)) {
207                startHtml(&quot;Echo reply&quot;);
208                clientOutput.print(&quot;&lt;p&gt;URL was &quot; + u.toExternalForm() + &quot;\n&quot;);
209                clientOutput.print(&quot;&lt;p&gt;Socket was &quot; + clientSocket + &quot;\n&lt;p&gt;&lt;pre&gt;&quot;);
210                mh.print(clientOutput);
211            }
212         } catch(Exception e) {
213             System.out.print(&quot;Failed on &quot;+u.getFile()+&quot;\n&quot;);
214             e.printStackTrace();
215         }
216     }
217      /**
218       * Clone this object;
219      */
220     public Object clone() {
221         try {
222             return super.clone();
223         } catch (CloneNotSupportedException e) {
224             // this shouldn&#39;t happen, since we are Cloneable
225             throw new InternalError();
226         }
227     }
228 
229     public myHttpServer () {
230         try {
231             defaultContext = URIBuilder.newBuilder()
232                     .scheme(&quot;http&quot;)
233                     .loopback()
234                     .path(&quot;/&quot;)
235                     .toURL();
236         } catch(Exception e) {
237             System.out.println(&quot;Failed to construct default URL context: &quot;
238                                + e);
239             e.printStackTrace();
240         }
241     }
242 
243     // Make the content type have some attributes
244     protected void startHtml(String title) {
245         clientOutput.print(&quot;HTTP/1.0 200 Document follows\n&quot; +
246                            &quot;Server: Java/&quot; + getClass().getName() + &quot;\n&quot; +
247                            &quot;Content-type: text/plain; charset=Shift_JIS \n\n&quot;);
248     }
249 
250 }
    </pre>
  </body>
</html>
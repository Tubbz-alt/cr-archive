<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff test/jdk/java/net/URLConnection/DisconnectAfterEOF.java</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
<body>
<center><a href="ChunkedEncoding.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="GetResponseCode.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>test/jdk/java/net/URLConnection/DisconnectAfterEOF.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2002, 2010, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 /**
 25  * @test
 26  * @bug 4774503

 27  * @summary Calling HttpURLConnection&#39;s disconnect method after the
 28  *          response has been received causes havoc with persistent
 29  *          connections.
 30  */
 31 import java.net.*;
 32 import java.io.*;
 33 import java.util.*;


 34 
 35 public class DisconnectAfterEOF {
 36 
 37     /*
 38      * Worker thread to service single connection - can service
 39      * multiple http requests on same connection.
 40      */
 41     static class Worker extends Thread {
 42         Socket s;
 43 
 44         Worker(Socket s) {
 45             this.s = s;
 46         }
 47 
 48         public void run() {
 49             try {
 50                 InputStream in = s.getInputStream();
 51                 PrintStream out = new PrintStream(
 52                                         new BufferedOutputStream(
 53                                                 s.getOutputStream() ));
</pre>
<hr />
<pre>
196                 for (;;) {
197                     Socket s = ss.accept();
198                     Worker w = new Worker(s);
199                     w.start();
200                 }
201 
202             } catch (IOException ioe) {
203             }
204 
205             System.out.println(&quot;+ Server shutdown.&quot;);
206         }
207 
208         public void shutdown() {
209             try {
210                 ss.close();
211             } catch (IOException ioe) { }
212         }
213     }
214 
215     static URLConnection doRequest(String uri) throws IOException {
<span class="line-modified">216         URLConnection uc = (new URL(uri)).openConnection();</span>
217         uc.setDoOutput(true);
218         OutputStream out = uc.getOutputStream();
219         out.write(new byte[16000]);
220 
221         // force the request to be sent
222         uc.getInputStream();
223         return uc;
224     }
225 
226     static URLConnection doResponse(URLConnection uc) throws IOException {
227         int cl = ((HttpURLConnection)uc).getContentLength();
228         byte b[] = new byte[4096];
229         int n;
230         do {
231             n = uc.getInputStream().read(b);
232             if (n &gt; 0) cl -= n;
233         } while (n &gt; 0);
234         if (cl != 0) {
235             throw new RuntimeException(&quot;ERROR: content-length mismatch&quot;);
236         }
237         return uc;
238     }
239 
240     public static void main(String args[]) throws Exception {
241         // start server
<span class="line-modified">242         ServerSocket ss = new ServerSocket(0);</span>


243         Server svr = new Server(ss);
244         svr.start();
245 
<span class="line-modified">246         String uri = &quot;http://localhost:&quot; +</span>
<span class="line-modified">247                      Integer.toString(ss.getLocalPort()) +</span>
<span class="line-modified">248                      &quot;/foo.html&quot;;</span>



249 
250         /*
251          * The following is the test scenario we create here :-
252          *
253          * 1. We do a http request/response and read the response
254          *    to EOF. As it&#39;s a persistent connection the idle
255          *    connection should go into the keep-alive cache for a
256          *    few seconds.
257          *
258          * 2. We start a second request but don&#39;t read the response.
259          *    As the request is to the same server we can assume it
260          *    (for our implementation anyway) that it will use the
261          *    same TCP connection.
262          *
263          * 3. We &quot;disconnect&quot; the first HttpURLConnection. This
264          *    should be no-op because the connection is in use
265          *    but another request. However with 1.3.1 and 1.4/1.4.1
266          *    this causes the TCP connection for the second request
267          *    to be closed.
268          *
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2002, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 /**
 25  * @test
 26  * @bug 4774503
<span class="line-added"> 27  * @library /test/lib</span>
 28  * @summary Calling HttpURLConnection&#39;s disconnect method after the
 29  *          response has been received causes havoc with persistent
 30  *          connections.
 31  */
 32 import java.net.*;
 33 import java.io.*;
 34 import java.util.*;
<span class="line-added"> 35 import jdk.test.lib.net.URIBuilder;</span>
<span class="line-added"> 36 import static java.net.Proxy.NO_PROXY;</span>
 37 
 38 public class DisconnectAfterEOF {
 39 
 40     /*
 41      * Worker thread to service single connection - can service
 42      * multiple http requests on same connection.
 43      */
 44     static class Worker extends Thread {
 45         Socket s;
 46 
 47         Worker(Socket s) {
 48             this.s = s;
 49         }
 50 
 51         public void run() {
 52             try {
 53                 InputStream in = s.getInputStream();
 54                 PrintStream out = new PrintStream(
 55                                         new BufferedOutputStream(
 56                                                 s.getOutputStream() ));
</pre>
<hr />
<pre>
199                 for (;;) {
200                     Socket s = ss.accept();
201                     Worker w = new Worker(s);
202                     w.start();
203                 }
204 
205             } catch (IOException ioe) {
206             }
207 
208             System.out.println(&quot;+ Server shutdown.&quot;);
209         }
210 
211         public void shutdown() {
212             try {
213                 ss.close();
214             } catch (IOException ioe) { }
215         }
216     }
217 
218     static URLConnection doRequest(String uri) throws IOException {
<span class="line-modified">219         URLConnection uc = (new URL(uri)).openConnection(NO_PROXY);</span>
220         uc.setDoOutput(true);
221         OutputStream out = uc.getOutputStream();
222         out.write(new byte[16000]);
223 
224         // force the request to be sent
225         uc.getInputStream();
226         return uc;
227     }
228 
229     static URLConnection doResponse(URLConnection uc) throws IOException {
230         int cl = ((HttpURLConnection)uc).getContentLength();
231         byte b[] = new byte[4096];
232         int n;
233         do {
234             n = uc.getInputStream().read(b);
235             if (n &gt; 0) cl -= n;
236         } while (n &gt; 0);
237         if (cl != 0) {
238             throw new RuntimeException(&quot;ERROR: content-length mismatch&quot;);
239         }
240         return uc;
241     }
242 
243     public static void main(String args[]) throws Exception {
244         // start server
<span class="line-modified">245         InetAddress loopback = InetAddress.getLoopbackAddress();</span>
<span class="line-added">246         ServerSocket ss = new ServerSocket();</span>
<span class="line-added">247         ss.bind(new InetSocketAddress(loopback, 0));</span>
248         Server svr = new Server(ss);
249         svr.start();
250 
<span class="line-modified">251         String uri = URIBuilder.newBuilder()</span>
<span class="line-modified">252                      .scheme(&quot;http&quot;)</span>
<span class="line-modified">253                      .loopback()</span>
<span class="line-added">254                      .port(ss.getLocalPort())</span>
<span class="line-added">255                      .path(&quot;/foo.html&quot;)</span>
<span class="line-added">256                      .build().toString();</span>
257 
258         /*
259          * The following is the test scenario we create here :-
260          *
261          * 1. We do a http request/response and read the response
262          *    to EOF. As it&#39;s a persistent connection the idle
263          *    connection should go into the keep-alive cache for a
264          *    few seconds.
265          *
266          * 2. We start a second request but don&#39;t read the response.
267          *    As the request is to the same server we can assume it
268          *    (for our implementation anyway) that it will use the
269          *    same TCP connection.
270          *
271          * 3. We &quot;disconnect&quot; the first HttpURLConnection. This
272          *    should be no-op because the connection is in use
273          *    but another request. However with 1.3.1 and 1.4/1.4.1
274          *    this causes the TCP connection for the second request
275          *    to be closed.
276          *
</pre>
</td>
</tr>
</table>
<center><a href="ChunkedEncoding.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="GetResponseCode.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
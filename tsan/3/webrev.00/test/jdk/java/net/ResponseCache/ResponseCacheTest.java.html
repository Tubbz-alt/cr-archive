<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New test/jdk/java/net/ResponseCache/ResponseCacheTest.java</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2003, 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 /* @test
 25  * @summary Unit test for java.net.ResponseCache
 26  * @bug 4837267
 27  * @library /test/lib
 28  * @author Yingxian Wang
 29  */
 30 
 31 import java.net.*;
 32 import java.util.*;
 33 import java.io.*;
 34 import javax.net.ssl.*;
 35 import jdk.test.lib.net.URIBuilder;
 36 import static java.net.Proxy.NO_PROXY;
 37 
 38 /**
 39  * Request should get serviced by the cache handler. Response get
 40  * saved through the cache handler.
 41  */
 42 public class ResponseCacheTest implements Runnable {
 43     ServerSocket ss;
 44     static URL url1;
 45     static URL url2;
 46     static String FNPrefix, OutFNPrefix;
 47     static List&lt;Closeable&gt; streams = new ArrayList&lt;&gt;();
 48     static List&lt;File&gt; files = new ArrayList&lt;&gt;();
 49 
 50     /*
 51      * Our &quot;http&quot; server to return a 404 */
 52     public void run() {
 53         Socket s = null;
 54         FileInputStream fis = null;
 55         try {
 56             s = ss.accept();
 57 
 58             InputStream is = s.getInputStream ();
 59             BufferedReader r = new BufferedReader(new InputStreamReader(is));
 60             String x;
 61             while ((x=r.readLine()) != null) {
 62                 if (x.length() ==0) {
 63                     break;
 64                 }
 65             }
 66             PrintStream out = new PrintStream(
 67                                  new BufferedOutputStream(
 68                                     s.getOutputStream() ));
 69 
 70             /* send file2.1 */
 71             File file2 = new File(FNPrefix+&quot;file2.1&quot;);
 72             out.print(&quot;HTTP/1.1 200 OK\r\n&quot;);
 73             out.print(&quot;Content-Type: text/html; charset=iso-8859-1\r\n&quot;);
 74             out.print(&quot;Content-Length: &quot;+file2.length()+&quot;\r\n&quot;);
 75             out.print(&quot;Connection: close\r\n&quot;);
 76             out.print(&quot;\r\n&quot;);
 77             fis = new FileInputStream(file2);
 78             byte[] buf = new byte[(int)file2.length()];
 79             int len;
 80             while ((len = fis.read(buf)) != -1) {
 81                 out.print(new String(buf));
 82             }
 83 
 84             out.flush();
 85 
 86             s.close();
 87             ss.close();
 88         } catch (Exception e) {
 89             e.printStackTrace();
 90         } finally {
 91             try { ss.close(); } catch (IOException unused) {}
 92             try { s.close(); } catch (IOException unused) {}
 93             try { fis.close(); } catch (IOException unused) {}
 94         }
 95     }
 96     static class NameVerifier implements HostnameVerifier {
 97         public boolean verify(String hostname, SSLSession session) {
 98             return true;
 99         }
100     }
101     ResponseCacheTest() throws Exception {
102         /* start the server */
103         InetAddress loopback = InetAddress.getLoopbackAddress();
104         ss = new ServerSocket();
105         ss.bind(new InetSocketAddress(loopback, 0));
106 
107         (new Thread(this)).start();
108         /* establish http connection to server */
109         url1 = new URL(&quot;http://localhost/file1.cache&quot;);
110         HttpURLConnection http = (HttpURLConnection)url1.openConnection();
111         InputStream is = null;
112         System.out.println(&quot;request headers: &quot;+http.getRequestProperties());
113         System.out.println(&quot;responsecode is :&quot;+http.getResponseCode());
114         Map&lt;String,List&lt;String&gt;&gt; headers1 = http.getHeaderFields();
115         try {
116             is = http.getInputStream();
117         } catch (IOException ioex) {
118             throw new RuntimeException(ioex.getMessage());
119         }
120         BufferedReader r = new BufferedReader(new InputStreamReader(is));
121         String x;
122         File fileout = new File(OutFNPrefix+&quot;file1&quot;);
123         PrintStream out = new PrintStream(
124                                  new BufferedOutputStream(
125                                     new FileOutputStream(fileout)));
126         while ((x=r.readLine()) != null) {
127             out.print(x+&quot;\n&quot;);
128         }
129         out.flush();
130         out.close();
131 
132         http.disconnect();
133 
134         // testing ResponseCacheHandler.put()
135         url2 = URIBuilder.newBuilder()
136                    .scheme(&quot;http&quot;)
137                    .host(ss.getInetAddress())
138                    .port(ss.getLocalPort())
139                    .path(&quot;/file2.1&quot;)
140                    .toURL();
141         http = (HttpURLConnection)url2.openConnection(NO_PROXY);
142         System.out.println(&quot;responsecode2 is :&quot;+http.getResponseCode());
143         Map&lt;String,List&lt;String&gt;&gt; headers2 = http.getHeaderFields();
144 
145         try {
146             is = http.getInputStream();
147         } catch (IOException ioex) {
148             throw new RuntimeException(ioex.getMessage());
149         }
150         r = new BufferedReader(new InputStreamReader(is));
151         fileout = new File(OutFNPrefix+&quot;file2.2&quot;);
152         out = new PrintStream(
153                                  new BufferedOutputStream(
154                                     new FileOutputStream(fileout)));
155         while ((x=r.readLine()) != null) {
156             out.print(x+&quot;\n&quot;);
157         }
158         out.flush();
159         out.close();
160 
161         // assert (headers1 == headers2 &amp;&amp; file1 == file2.2)
162         File file1 = new File(OutFNPrefix+&quot;file1&quot;);
163         File file2 = new File(OutFNPrefix+&quot;file2.2&quot;);
164         files.add(file1);
165         files.add(file2);
166         System.out.println(&quot;headers1&quot;+headers1+&quot;\nheaders2=&quot;+headers2);
167         if (!headers1.equals(headers2) || file1.length() != file2.length()) {
168             throw new RuntimeException(&quot;test failed&quot;);
169         }
170     }
171 
172     public static void main(String args[]) throws Exception {
173         try {
174             ResponseCache.setDefault(new MyResponseCache());
175             FNPrefix = System.getProperty(&quot;test.src&quot;, &quot;.&quot;)+&quot;/&quot;;
176             OutFNPrefix = System.getProperty(&quot;test.scratch&quot;, &quot;.&quot;)+&quot;/&quot;;
177             new ResponseCacheTest();
178         } finally{
179             ResponseCache.setDefault(null);
180             for (Closeable c: streams) {
181                 try { c.close(); } catch (IOException unused) {}
182             }
183             for (File f: files) {
184                 f.delete();
185             }
186         }
187     }
188 
189     static class MyResponseCache extends ResponseCache {
190         public CacheResponse get(URI uri, String rqstMethod,
191                                  Map&lt;String,List&lt;String&gt;&gt; rqstHeaders)
192             throws IOException
193         {
194             try {
195                 if (uri.equals(url1.toURI())) {
196                     return new MyCacheResponse(FNPrefix+&quot;file1.cache&quot;);
197                 }
198             } catch (URISyntaxException ex) {
199                 throw new RuntimeException (ex);
200             }
201             return null;
202         }
203 
204         public CacheRequest put(URI uri, URLConnection conn)  throws IOException {
205             // save cache to file2.cache
206             // 1. serialize headers into file2.cache
207             // 2. write data to file2.cache
208             return new MyCacheRequest(OutFNPrefix+&quot;file2.cache&quot;, conn.getHeaderFields());
209         }
210     }
211 
212     static class MyCacheResponse extends CacheResponse {
213         FileInputStream fis;
214         Map&lt;String,List&lt;String&gt;&gt; headers;
215         public MyCacheResponse(String filename) {
216             try {
217                 fis = new FileInputStream(new File(filename));
218                 streams.add(fis);
219                 ObjectInputStream ois = new ObjectInputStream(fis);
220                 headers = (Map&lt;String,List&lt;String&gt;&gt;)ois.readObject();
221             } catch (Exception ex) {
222                 // throw new RuntimeException(ex.getMessage());
223             }
224         }
225 
226         public InputStream getBody() throws IOException {
227             return fis;
228         }
229 
230         public Map&lt;String,List&lt;String&gt;&gt; getHeaders() throws IOException {
231             return headers;
232         }
233     }
234 
235     static class MyCacheRequest extends CacheRequest {
236         FileOutputStream fos;
237         public MyCacheRequest(String filename, Map&lt;String,List&lt;String&gt;&gt; rspHeaders) {
238             try {
239                 File file = new File(filename);
240                 fos = new FileOutputStream(file);
241                 streams.add(fos);
242                 files.add(file);
243                 ObjectOutputStream oos = new ObjectOutputStream(fos);
244                 oos.writeObject(rspHeaders);
245             } catch (Exception ex) {
246                 throw new RuntimeException(ex.getMessage());
247             }
248         }
249         public OutputStream getBody() throws IOException {
250             return fos;
251         }
252 
253         public void abort() {
254             // no op
255         }
256     }
257 
258 
259 }
    </pre>
  </body>
</html>
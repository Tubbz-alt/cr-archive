<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New test/jdk/java/net/MulticastSocket/NoLoopbackPackets.java</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2007, 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 /*
 25  * @test
 26  * @bug 4742177
 27  * @library /test/lib
 28  * @summary Re-test IPv6 (and specifically MulticastSocket) with latest Linux &amp; USAGI code
 29  */
 30 import java.util.*;
 31 import java.net.*;
 32 import jdk.test.lib.NetworkConfiguration;
 33 import jdk.test.lib.net.IPSupport;
 34 
 35 public class NoLoopbackPackets {
 36     private static String osname;
 37 
 38     static boolean isWindows() {
 39         if (osname == null)
 40             osname = System.getProperty(&quot;os.name&quot;);
 41         return osname.contains(&quot;Windows&quot;);
 42     }
 43 
 44     private static final String MESSAGE = &quot;hello world (&quot; + System.nanoTime() + &quot;)&quot;;
 45     public static void main(String[] args) throws Exception {
 46         if (isWindows()) {
 47             System.out.println(&quot;The test only run on non-Windows OS. Bye.&quot;);
 48             return;
 49         }
 50 
 51         MulticastSocket msock = null;
 52         List&lt;SocketAddress&gt; failedGroups = new ArrayList&lt;SocketAddress&gt;();
 53         Sender sender = null;
 54         Thread senderThread = null;
 55         try {
 56             msock = new MulticastSocket();
 57             int port = msock.getLocalPort();
 58 
 59             // we will send packets to three multicast groups :-
 60             // 224.1.1.1, ::ffff:224.1.1.2, and ff02::1:1
 61             //
 62             List&lt;SocketAddress&gt; groups = new ArrayList&lt;SocketAddress&gt;();
 63             if (IPSupport.hasIPv4()) {
 64                 groups.add(new InetSocketAddress(InetAddress.getByName(&quot;224.1.1.1&quot;), port));
 65             }
 66 
 67             NetworkConfiguration nc = NetworkConfiguration.probe();
 68             if (IPSupport.hasIPv6() &amp;&amp; nc.hasTestableIPv6Address()) {
 69                 groups.add(new InetSocketAddress(InetAddress.getByName(&quot;::ffff:224.1.1.2&quot;), port));
 70                 groups.add(new InetSocketAddress(InetAddress.getByName(&quot;ff02::1:1&quot;), port));
 71             }
 72             if (groups.isEmpty()) {
 73                 System.err.println(&quot;Nothing to test: there are no network interfaces&quot;);
 74             }
 75 
 76             sender = new Sender(groups);
 77             senderThread = new Thread(sender);
 78             senderThread.start();
 79 
 80             // Now try to receive multicast packets. we should not see any of them
 81             // since we disable loopback mode.
 82             //
 83             msock.setSoTimeout(5000);       // 5 seconds
 84 
 85             byte[] buf = new byte[1024];
 86             for (int i = 0; i &lt; buf.length; i++) {
 87                 buf[i] = (byte) &#39;z&#39;;
 88             }
 89             DatagramPacket packet = new DatagramPacket(buf, 0, buf.length);
 90             byte[] expected = MESSAGE.getBytes();
 91             assert expected.length &lt;= buf.length;
 92             for (SocketAddress group : groups) {
 93                 System.out.println(&quot;joining group: &quot; + group);
 94                 msock.joinGroup(group, null);
 95 
 96                 try {
 97                     do {
 98                         for (int i = 0; i &lt; buf.length; i++) {
 99                             buf[i] = (byte) &#39;a&#39;;
100                         }
101                         msock.receive(packet);
102                         byte[] data = packet.getData();
103                         int len = packet.getLength();
104 
105                         if (expected(data, len, expected)) {
106                             failedGroups.add(group);
107                             break;
108                         } else {
109                             System.err.println(&quot;WARNING: Unexpected packet received from &quot;
110                                                + group + &quot;: &quot;
111                                                + len + &quot; bytes&quot;);
112                             System.err.println(&quot;\t as text: &quot; + new String(data, 0, len));
113                         }
114                     } while (true);
115                 } catch (SocketTimeoutException e) {
116                     // we expect this
117                     System.out.println(&quot;Received expected exception from &quot; + group + &quot;: &quot; + e);
118                 } finally {
119                     msock.leaveGroup(group, null);
120                 }
121             }
122         } finally {
123             if (msock != null) try { msock.close(); } catch (Exception e) {}
124             if (sender != null) {
125                 sender.stop();
126             }
127         }
128         try {
129             if (failedGroups.size() &gt; 0) {
130                 System.out.println(&quot;We should not receive anything from following groups, but we did:&quot;);
131                 for (SocketAddress group : failedGroups)
132                     System.out.println(group);
133                 throw new RuntimeException(&quot;test failed.&quot;);
134             }
135         } finally {
136             if (senderThread != null) {
137                 senderThread.join();
138             }
139         }
140     }
141 
142     static boolean expected(byte[] data, int len, byte[] expected) {
143         if (len != expected.length) return false;
144         for (int i = 0; i &lt; len; i++) {
145             if (data[i] != expected[i]) return false;
146         }
147         return true;
148     }
149 
150     static class Sender implements Runnable {
151         private List&lt;SocketAddress&gt; sendToGroups;
152         private volatile boolean stop;
153 
154         public Sender(List&lt;SocketAddress&gt; groups) {
155             sendToGroups = groups;
156         }
157 
158         public void run() {
159             byte[] buf = MESSAGE.getBytes();
160             List&lt;DatagramPacket&gt; packets = new ArrayList&lt;DatagramPacket&gt;();
161 
162             try (MulticastSocket msock = new MulticastSocket()) {
163                 for (SocketAddress group : sendToGroups) {
164                     DatagramPacket packet = new DatagramPacket(buf, buf.length, group);
165                     packets.add(packet);
166                 }
167 
168                 msock.setLoopbackMode(true);    // disable loopback mode
169                 while (!stop) {
170                     for (DatagramPacket packet : packets) {
171                         msock.send(packet);
172                     }
173 
174                     Thread.sleep(1000);     // 1 second
175                 }
176             } catch (Exception e) {
177                 throw new RuntimeException(e);
178             }
179         }
180 
181         void stop() {
182             stop = true;
183         }
184     }
185 }
    </pre>
  </body>
</html>
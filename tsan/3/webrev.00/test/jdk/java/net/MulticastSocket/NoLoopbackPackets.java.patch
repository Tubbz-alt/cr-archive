diff a/test/jdk/java/net/MulticastSocket/NoLoopbackPackets.java b/test/jdk/java/net/MulticastSocket/NoLoopbackPackets.java
--- a/test/jdk/java/net/MulticastSocket/NoLoopbackPackets.java
+++ b/test/jdk/java/net/MulticastSocket/NoLoopbackPackets.java
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2007, 2016, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2007, 2019, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.
@@ -22,104 +22,131 @@
  */
 
 /*
  * @test
  * @bug 4742177
+ * @library /test/lib
  * @summary Re-test IPv6 (and specifically MulticastSocket) with latest Linux & USAGI code
  */
 import java.util.*;
 import java.net.*;
+import jdk.test.lib.NetworkConfiguration;
+import jdk.test.lib.net.IPSupport;
 
 public class NoLoopbackPackets {
     private static String osname;
 
     static boolean isWindows() {
         if (osname == null)
             osname = System.getProperty("os.name");
         return osname.contains("Windows");
     }
 
-    private static boolean hasIPv6() throws Exception {
-        List<NetworkInterface> nics = Collections.list(
-                                        NetworkInterface.getNetworkInterfaces());
-        for (NetworkInterface nic : nics) {
-            if (!nic.isLoopback()) {
-                List<InetAddress> addrs = Collections.list(nic.getInetAddresses());
-                for (InetAddress addr : addrs) {
-                    if (addr instanceof Inet6Address) {
-                        return true;
-                    }
-                }
-            }
-        }
-
-        return false;
-    }
-
+    private static final String MESSAGE = "hello world (" + System.nanoTime() + ")";
     public static void main(String[] args) throws Exception {
         if (isWindows()) {
             System.out.println("The test only run on non-Windows OS. Bye.");
             return;
         }
 
-        if (!hasIPv6()) {
-            System.out.println("No IPv6 available. Bye.");
-            return;
-        }
-
         MulticastSocket msock = null;
         List<SocketAddress> failedGroups = new ArrayList<SocketAddress>();
         Sender sender = null;
+        Thread senderThread = null;
         try {
             msock = new MulticastSocket();
             int port = msock.getLocalPort();
 
             // we will send packets to three multicast groups :-
             // 224.1.1.1, ::ffff:224.1.1.2, and ff02::1:1
             //
             List<SocketAddress> groups = new ArrayList<SocketAddress>();
-            groups.add(new InetSocketAddress(InetAddress.getByName("224.1.1.1"), port));
-            groups.add(new InetSocketAddress(InetAddress.getByName("::ffff:224.1.1.2"), port));
-            groups.add(new InetSocketAddress(InetAddress.getByName("ff02::1:1"), port));
+            if (IPSupport.hasIPv4()) {
+                groups.add(new InetSocketAddress(InetAddress.getByName("224.1.1.1"), port));
+            }
+
+            NetworkConfiguration nc = NetworkConfiguration.probe();
+            if (IPSupport.hasIPv6() && nc.hasTestableIPv6Address()) {
+                groups.add(new InetSocketAddress(InetAddress.getByName("::ffff:224.1.1.2"), port));
+                groups.add(new InetSocketAddress(InetAddress.getByName("ff02::1:1"), port));
+            }
+            if (groups.isEmpty()) {
+                System.err.println("Nothing to test: there are no network interfaces");
+            }
 
             sender = new Sender(groups);
-            new Thread(sender).start();
+            senderThread = new Thread(sender);
+            senderThread.start();
 
             // Now try to receive multicast packets. we should not see any of them
             // since we disable loopback mode.
             //
             msock.setSoTimeout(5000);       // 5 seconds
 
             byte[] buf = new byte[1024];
+            for (int i = 0; i < buf.length; i++) {
+                buf[i] = (byte) 'z';
+            }
             DatagramPacket packet = new DatagramPacket(buf, 0, buf.length);
+            byte[] expected = MESSAGE.getBytes();
+            assert expected.length <= buf.length;
             for (SocketAddress group : groups) {
+                System.out.println("joining group: " + group);
                 msock.joinGroup(group, null);
 
                 try {
-                    msock.receive(packet);
-
-                    // it is an error if we receive something
-                    failedGroups.add(group);
+                    do {
+                        for (int i = 0; i < buf.length; i++) {
+                            buf[i] = (byte) 'a';
+                        }
+                        msock.receive(packet);
+                        byte[] data = packet.getData();
+                        int len = packet.getLength();
+
+                        if (expected(data, len, expected)) {
+                            failedGroups.add(group);
+                            break;
+                        } else {
+                            System.err.println("WARNING: Unexpected packet received from "
+                                               + group + ": "
+                                               + len + " bytes");
+                            System.err.println("\t as text: " + new String(data, 0, len));
+                        }
+                    } while (true);
                 } catch (SocketTimeoutException e) {
                     // we expect this
+                    System.out.println("Received expected exception from " + group + ": " + e);
+                } finally {
+                    msock.leaveGroup(group, null);
                 }
-
-                msock.leaveGroup(group, null);
             }
         } finally {
             if (msock != null) try { msock.close(); } catch (Exception e) {}
             if (sender != null) {
                 sender.stop();
             }
         }
+        try {
+            if (failedGroups.size() > 0) {
+                System.out.println("We should not receive anything from following groups, but we did:");
+                for (SocketAddress group : failedGroups)
+                    System.out.println(group);
+                throw new RuntimeException("test failed.");
+            }
+        } finally {
+            if (senderThread != null) {
+                senderThread.join();
+            }
+        }
+    }
 
-        if (failedGroups.size() > 0) {
-            System.out.println("We should not receive anything from following groups, but we did:");
-            for (SocketAddress group : failedGroups)
-                System.out.println(group);
-            throw new RuntimeException("test failed.");
+    static boolean expected(byte[] data, int len, byte[] expected) {
+        if (len != expected.length) return false;
+        for (int i = 0; i < len; i++) {
+            if (data[i] != expected[i]) return false;
         }
+        return true;
     }
 
     static class Sender implements Runnable {
         private List<SocketAddress> sendToGroups;
         private volatile boolean stop;
@@ -127,20 +154,19 @@
         public Sender(List<SocketAddress> groups) {
             sendToGroups = groups;
         }
 
         public void run() {
-            byte[] buf = "hello world".getBytes();
+            byte[] buf = MESSAGE.getBytes();
             List<DatagramPacket> packets = new ArrayList<DatagramPacket>();
 
-            try {
+            try (MulticastSocket msock = new MulticastSocket()) {
                 for (SocketAddress group : sendToGroups) {
                     DatagramPacket packet = new DatagramPacket(buf, buf.length, group);
                     packets.add(packet);
                 }
 
-                MulticastSocket msock = new MulticastSocket();
                 msock.setLoopbackMode(true);    // disable loopback mode
                 while (!stop) {
                     for (DatagramPacket packet : packets) {
                         msock.send(packet);
                     }

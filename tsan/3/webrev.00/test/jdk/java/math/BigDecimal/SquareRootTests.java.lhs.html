<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames test/jdk/java/math/BigDecimal/SquareRootTests.java</title>
    <link rel="stylesheet" href="../../../../../style.css" />
    <script type="text/javascript" src="../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
<a name="1" id="anc1"></a><span class="line-modified">  2  * Copyright (c) 2016, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 /*
 25  * @test
<a name="2" id="anc2"></a><span class="line-modified"> 26  * @bug 4851777</span>
 27  * @summary Tests of BigDecimal.sqrt().
 28  */
 29 
 30 import java.math.*;
 31 import java.util.*;
 32 
<a name="3" id="anc3"></a>




 33 public class SquareRootTests {
<a name="4" id="anc4"></a>





 34 
 35     public static void main(String... args) {
 36         int failures = 0;
 37 
 38         failures += negativeTests();
 39         failures += zeroTests();
<a name="5" id="anc5"></a>

 40         failures += evenPowersOfTenTests();
 41         failures += squareRootTwoTests();
 42         failures += lowPrecisionPerfectSquares();
<a name="6" id="anc6"></a>




 43 
 44         if (failures &gt; 0 ) {
 45             throw new RuntimeException(&quot;Incurred &quot; + failures + &quot; failures&quot; +
 46                                        &quot; testing BigDecimal.sqrt().&quot;);
 47         }
 48     }
 49 
 50     private static int negativeTests() {
 51         int failures = 0;
 52 
 53         for (long i = -10; i &lt; 0; i++) {
 54             for (int j = -5; j &lt; 5; j++) {
 55                 try {
 56                     BigDecimal input = BigDecimal.valueOf(i, j);
 57                     BigDecimal result = input.sqrt(MathContext.DECIMAL64);
 58                     System.err.println(&quot;Unexpected sqrt of negative: (&quot; +
 59                                        input + &quot;).sqrt()  = &quot; + result );
 60                     failures += 1;
 61                 } catch (ArithmeticException e) {
 62                     ; // Expected
 63                 }
 64             }
 65         }
 66 
 67         return failures;
 68     }
 69 
 70     private static int zeroTests() {
 71         int failures = 0;
 72 
 73         for (int i = -100; i &lt; 100; i++) {
 74             BigDecimal expected = BigDecimal.valueOf(0L, i/2);
 75             // These results are independent of rounding mode
 76             failures += compare(BigDecimal.valueOf(0L, i).sqrt(MathContext.UNLIMITED),
 77                                 expected, true, &quot;zeros&quot;);
 78 
 79             failures += compare(BigDecimal.valueOf(0L, i).sqrt(MathContext.DECIMAL64),
 80                                 expected, true, &quot;zeros&quot;);
 81         }
 82 
 83         return failures;
 84     }
 85 
<a name="7" id="anc7"></a>



































































 86     /**
 87      * sqrt(10^2N) is 10^N
 88      * Both numerical value and representation should be verified
 89      */
 90     private static int evenPowersOfTenTests() {
 91         int failures = 0;
 92         MathContext oneDigitExactly = new MathContext(1, RoundingMode.UNNECESSARY);
 93 
 94         for (int scale = -100; scale &lt;= 100; scale++) {
<a name="8" id="anc8"></a><span class="line-modified"> 95             BigDecimal testValue       = BigDecimal.valueOf(1, 2*scale);</span>
<span class="line-modified"> 96             BigDecimal expectedNumericalResult = BigDecimal.valueOf(1, scale);</span>
 97 
 98             BigDecimal result;
 99 
<a name="9" id="anc9"></a><span class="line-removed">100 </span>
101             failures += equalNumerically(expectedNumericalResult,
<a name="10" id="anc10"></a><span class="line-modified">102                                            result = testValue.sqrt(MathContext.DECIMAL64),</span>
<span class="line-modified">103                                            &quot;Even powers of 10, DECIMAL64&quot;);</span>
104 
105             // Can round to one digit of precision exactly
106             failures += equalNumerically(expectedNumericalResult,
<a name="11" id="anc11"></a><span class="line-modified">107                                            result = testValue.sqrt(oneDigitExactly),</span>
<span class="line-modified">108                                            &quot;even powers of 10, 1 digit&quot;);</span>

109             if (result.precision() &gt; 1) {
110                 failures += 1;
111                 System.err.println(&quot;Excess precision for &quot; + result);
112             }
113 
<a name="12" id="anc12"></a><span class="line-removed">114 </span>
115             // If rounding to more than one digit, do precision / scale checking...
<a name="13" id="anc13"></a><span class="line-removed">116 </span>
117         }
118 
119         return failures;
120     }
121 
122     private static int squareRootTwoTests() {
123         int failures = 0;
<a name="14" id="anc14"></a><span class="line-removed">124         BigDecimal TWO = new BigDecimal(2);</span>
125 
126         // Square root of 2 truncated to 65 digits
127         BigDecimal highPrecisionRoot2 =
128             new BigDecimal(&quot;1.41421356237309504880168872420969807856967187537694807317667973799&quot;);
129 
<a name="15" id="anc15"></a><span class="line-removed">130 </span>
131         RoundingMode[] modes = {
132             RoundingMode.UP,       RoundingMode.DOWN,
133             RoundingMode.CEILING, RoundingMode.FLOOR,
134             RoundingMode.HALF_UP, RoundingMode.HALF_DOWN, RoundingMode.HALF_EVEN
135         };
136 
<a name="16" id="anc16"></a><span class="line-removed">137         // For each iteresting rounding mode, for precisions 1 to, say</span>
<span class="line-removed">138         // 63 numerically compare TWO.sqrt(mc) to</span>
<span class="line-removed">139         // highPrecisionRoot2.round(mc)</span>
140 
<a name="17" id="anc17"></a>



141         for (RoundingMode mode : modes) {
142             for (int precision = 1; precision &lt; 63; precision++) {
143                 MathContext mc = new MathContext(precision, mode);
144                 BigDecimal expected = highPrecisionRoot2.round(mc);
145                 BigDecimal computed = TWO.sqrt(mc);
<a name="18" id="anc18"></a>
146 
<a name="19" id="anc19"></a><span class="line-modified">147                 equalNumerically(expected, computed, &quot;sqrt(2)&quot;);</span>

148             }
149         }
150 
151         return failures;
152     }
153 
154     private static int lowPrecisionPerfectSquares() {
155         int failures = 0;
156 
157         // For 5^2 through 9^2, if the input is rounded to one digit
158         // first before the root is computed, the wrong answer will
159         // result. Verify results and scale for different rounding
160         // modes and precisions.
161         long[][] squaresWithOneDigitRoot = {{ 4, 2},
162                                             { 9, 3},
163                                             {25, 5},
164                                             {36, 6},
165                                             {49, 7},
166                                             {64, 8},
167                                             {81, 9}};
168 
169         for (long[] squareAndRoot : squaresWithOneDigitRoot) {
170             BigDecimal square     = new BigDecimal(squareAndRoot[0]);
171             BigDecimal expected   = new BigDecimal(squareAndRoot[1]);
172 
173             for (int scale = 0; scale &lt;= 4; scale++) {
174                 BigDecimal scaledSquare = square.setScale(scale, RoundingMode.UNNECESSARY);
175                 int expectedScale = scale/2;
176                 for (int precision = 0; precision &lt;= 5; precision++) {
177                     for (RoundingMode rm : RoundingMode.values()) {
178                         MathContext mc = new MathContext(precision, rm);
179                         BigDecimal computedRoot = scaledSquare.sqrt(mc);
180                         failures += equalNumerically(expected, computedRoot, &quot;simple squares&quot;);
181                         int computedScale = computedRoot.scale();
182                         if (precision &gt;=  expectedScale + 1 &amp;&amp;
183                             computedScale != expectedScale) {
<a name="20" id="anc20"></a><span class="line-modified">184                         System.err.printf(&quot;%s\tprecision=%d\trm=%s%n&quot;,</span>
<span class="line-modified">185                                           computedRoot.toString(), precision, rm);</span>
186                             failures++;
187                             System.err.printf(&quot;\t%s does not have expected scale of %d%n.&quot;,
188                                               computedRoot, expectedScale);
189                         }
190                     }
191                 }
192             }
193         }
194 
195         return failures;
196     }
197 
<a name="21" id="anc21"></a>































































































































198     private static int compare(BigDecimal a, BigDecimal b, boolean expected, String prefix) {
199         boolean result = a.equals(b);
200         int failed = (result==expected) ? 0 : 1;
201         if (failed == 1) {
202             System.err.println(&quot;Testing &quot; + prefix +
203                                &quot;(&quot; + a + &quot;).compareTo(&quot; + b + &quot;) =&gt; &quot; + result +
204                                &quot;\n\tExpected &quot; + expected);
205         }
206         return failed;
207     }
208 
209     private static int equalNumerically(BigDecimal a, BigDecimal b,
210                                         String prefix) {
211         return compareNumerically(a, b, 0, prefix);
212     }
213 
214 
215     private static int compareNumerically(BigDecimal a, BigDecimal b,
216                                           int expected, String prefix) {
217         int result = a.compareTo(b);
218         int failed = (result==expected) ? 0 : 1;
219         if (failed == 1) {
220             System.err.println(&quot;Testing &quot; + prefix +
221                                &quot;(&quot; + a + &quot;).compareTo(&quot; + b + &quot;) =&gt; &quot; + result +
222                                &quot;\n\tExpected &quot; + expected);
223         }
224         return failed;
225     }
226 
<a name="22" id="anc22"></a>












































































































































































































































































































227 }
<a name="23" id="anc23"></a>
<a name="24" id="anc24"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="24" type="hidden" />
</body>
</html>
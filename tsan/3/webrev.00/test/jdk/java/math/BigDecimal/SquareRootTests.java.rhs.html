<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames test/jdk/java/math/BigDecimal/SquareRootTests.java</title>
    <link rel="stylesheet" href="../../../../../style.css" />
    <script type="text/javascript" src="../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
<a name="1" id="anc1"></a><span class="line-modified">  2  * Copyright (c) 2016, 2020, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 /*
 25  * @test
<a name="2" id="anc2"></a><span class="line-modified"> 26  * @bug 4851777 8233452</span>
 27  * @summary Tests of BigDecimal.sqrt().
 28  */
 29 
 30 import java.math.*;
 31 import java.util.*;
 32 
<a name="3" id="anc3"></a><span class="line-added"> 33 import static java.math.BigDecimal.ONE;</span>
<span class="line-added"> 34 import static java.math.BigDecimal.TEN;</span>
<span class="line-added"> 35 import static java.math.BigDecimal.ZERO;</span>
<span class="line-added"> 36 import static java.math.BigDecimal.valueOf;</span>
<span class="line-added"> 37 </span>
 38 public class SquareRootTests {
<a name="4" id="anc4"></a><span class="line-added"> 39     private static BigDecimal TWO = new BigDecimal(2);</span>
<span class="line-added"> 40 </span>
<span class="line-added"> 41     /**</span>
<span class="line-added"> 42      * The value 0.1, with a scale of 1.</span>
<span class="line-added"> 43      */</span>
<span class="line-added"> 44     private static final BigDecimal ONE_TENTH = valueOf(1L, 1);</span>
 45 
 46     public static void main(String... args) {
 47         int failures = 0;
 48 
 49         failures += negativeTests();
 50         failures += zeroTests();
<a name="5" id="anc5"></a><span class="line-added"> 51         failures += oneDigitTests();</span>
<span class="line-added"> 52         failures += twoDigitTests();</span>
 53         failures += evenPowersOfTenTests();
 54         failures += squareRootTwoTests();
 55         failures += lowPrecisionPerfectSquares();
<a name="6" id="anc6"></a><span class="line-added"> 56         failures += almostFourRoundingDown();</span>
<span class="line-added"> 57         failures += almostFourRoundingUp();</span>
<span class="line-added"> 58         failures += nearTen();</span>
<span class="line-added"> 59         failures += nearOne();</span>
<span class="line-added"> 60         failures += halfWay();</span>
 61 
 62         if (failures &gt; 0 ) {
 63             throw new RuntimeException(&quot;Incurred &quot; + failures + &quot; failures&quot; +
 64                                        &quot; testing BigDecimal.sqrt().&quot;);
 65         }
 66     }
 67 
 68     private static int negativeTests() {
 69         int failures = 0;
 70 
 71         for (long i = -10; i &lt; 0; i++) {
 72             for (int j = -5; j &lt; 5; j++) {
 73                 try {
 74                     BigDecimal input = BigDecimal.valueOf(i, j);
 75                     BigDecimal result = input.sqrt(MathContext.DECIMAL64);
 76                     System.err.println(&quot;Unexpected sqrt of negative: (&quot; +
 77                                        input + &quot;).sqrt()  = &quot; + result );
 78                     failures += 1;
 79                 } catch (ArithmeticException e) {
 80                     ; // Expected
 81                 }
 82             }
 83         }
 84 
 85         return failures;
 86     }
 87 
 88     private static int zeroTests() {
 89         int failures = 0;
 90 
 91         for (int i = -100; i &lt; 100; i++) {
 92             BigDecimal expected = BigDecimal.valueOf(0L, i/2);
 93             // These results are independent of rounding mode
 94             failures += compare(BigDecimal.valueOf(0L, i).sqrt(MathContext.UNLIMITED),
 95                                 expected, true, &quot;zeros&quot;);
 96 
 97             failures += compare(BigDecimal.valueOf(0L, i).sqrt(MathContext.DECIMAL64),
 98                                 expected, true, &quot;zeros&quot;);
 99         }
100 
101         return failures;
102     }
103 
<a name="7" id="anc7"></a><span class="line-added">104     /**</span>
<span class="line-added">105      * Probe inputs with one digit of precision, 1 ... 9 and those</span>
<span class="line-added">106      * values scaled by 10^-1, 0.1, ... 0.9.</span>
<span class="line-added">107      */</span>
<span class="line-added">108     private static int oneDigitTests() {</span>
<span class="line-added">109         int failures = 0;</span>
<span class="line-added">110 </span>
<span class="line-added">111         List&lt;BigDecimal&gt; oneToNine =</span>
<span class="line-added">112             List.of(ONE,        TWO,        valueOf(3),</span>
<span class="line-added">113                     valueOf(4), valueOf(5), valueOf(6),</span>
<span class="line-added">114                     valueOf(7), valueOf(8), valueOf(9));</span>
<span class="line-added">115 </span>
<span class="line-added">116         List&lt;RoundingMode&gt; modes =</span>
<span class="line-added">117             List.of(RoundingMode.UP,      RoundingMode.DOWN,</span>
<span class="line-added">118                     RoundingMode.CEILING, RoundingMode.FLOOR,</span>
<span class="line-added">119                     RoundingMode.HALF_UP, RoundingMode.HALF_DOWN, RoundingMode.HALF_EVEN);</span>
<span class="line-added">120 </span>
<span class="line-added">121         for (int i = 1; i &lt; 20; i++) {</span>
<span class="line-added">122             for (RoundingMode rm : modes) {</span>
<span class="line-added">123                 for (BigDecimal bd  : oneToNine) {</span>
<span class="line-added">124                     MathContext mc = new MathContext(i, rm);</span>
<span class="line-added">125 </span>
<span class="line-added">126                     failures += compareSqrtImplementations(bd, mc);</span>
<span class="line-added">127                     bd = bd.multiply(ONE_TENTH);</span>
<span class="line-added">128                     failures += compareSqrtImplementations(bd, mc);</span>
<span class="line-added">129                 }</span>
<span class="line-added">130             }</span>
<span class="line-added">131         }</span>
<span class="line-added">132 </span>
<span class="line-added">133         return failures;</span>
<span class="line-added">134     }</span>
<span class="line-added">135 </span>
<span class="line-added">136     /**</span>
<span class="line-added">137      * Probe inputs with two digits of precision, (10 ... 99) and</span>
<span class="line-added">138      * those values scaled by 10^-1 (1, ... 9.9) and scaled by 10^-2</span>
<span class="line-added">139      * (0.1 ... 0.99).</span>
<span class="line-added">140      */</span>
<span class="line-added">141     private static int twoDigitTests() {</span>
<span class="line-added">142         int failures = 0;</span>
<span class="line-added">143 </span>
<span class="line-added">144         List&lt;RoundingMode&gt; modes =</span>
<span class="line-added">145             List.of(RoundingMode.UP,      RoundingMode.DOWN,</span>
<span class="line-added">146                     RoundingMode.CEILING, RoundingMode.FLOOR,</span>
<span class="line-added">147                     RoundingMode.HALF_UP, RoundingMode.HALF_DOWN, RoundingMode.HALF_EVEN);</span>
<span class="line-added">148 </span>
<span class="line-added">149         for (int i = 10; i &lt; 100; i++) {</span>
<span class="line-added">150             BigDecimal bd0 = BigDecimal.valueOf(i);</span>
<span class="line-added">151             BigDecimal bd1 = bd0.multiply(ONE_TENTH);</span>
<span class="line-added">152             BigDecimal bd2 = bd1.multiply(ONE_TENTH);</span>
<span class="line-added">153 </span>
<span class="line-added">154             for (BigDecimal bd : List.of(bd0, bd1, bd2)) {</span>
<span class="line-added">155                 for (int precision = 1; i &lt; 20; i++) {</span>
<span class="line-added">156                     for (RoundingMode rm : modes) {</span>
<span class="line-added">157                         MathContext mc = new MathContext(precision, rm);</span>
<span class="line-added">158                         failures += compareSqrtImplementations(bd, mc);</span>
<span class="line-added">159                     }</span>
<span class="line-added">160                 }</span>
<span class="line-added">161             }</span>
<span class="line-added">162         }</span>
<span class="line-added">163 </span>
<span class="line-added">164         return failures;</span>
<span class="line-added">165     }</span>
<span class="line-added">166 </span>
<span class="line-added">167     private static int compareSqrtImplementations(BigDecimal bd, MathContext mc) {</span>
<span class="line-added">168         return equalNumerically(BigSquareRoot.sqrt(bd, mc),</span>
<span class="line-added">169                                 bd.sqrt(mc), &quot;sqrt(&quot; + bd + &quot;) under &quot; + mc);</span>
<span class="line-added">170     }</span>
<span class="line-added">171 </span>
172     /**
173      * sqrt(10^2N) is 10^N
174      * Both numerical value and representation should be verified
175      */
176     private static int evenPowersOfTenTests() {
177         int failures = 0;
178         MathContext oneDigitExactly = new MathContext(1, RoundingMode.UNNECESSARY);
179 
180         for (int scale = -100; scale &lt;= 100; scale++) {
<a name="8" id="anc8"></a><span class="line-modified">181             BigDecimal testValue               = BigDecimal.valueOf(1, 2*scale);</span>
<span class="line-modified">182             BigDecimal expectedNumericalResult = BigDecimal.valueOf(1,   scale);</span>
183 
184             BigDecimal result;
185 
<a name="9" id="anc9"></a>
186             failures += equalNumerically(expectedNumericalResult,
<a name="10" id="anc10"></a><span class="line-modified">187                                          result = testValue.sqrt(MathContext.DECIMAL64),</span>
<span class="line-modified">188                                          &quot;Even powers of 10, DECIMAL64&quot;);</span>
189 
190             // Can round to one digit of precision exactly
191             failures += equalNumerically(expectedNumericalResult,
<a name="11" id="anc11"></a><span class="line-modified">192                                          result = testValue.sqrt(oneDigitExactly),</span>
<span class="line-modified">193                                          &quot;even powers of 10, 1 digit&quot;);</span>
<span class="line-added">194 </span>
195             if (result.precision() &gt; 1) {
196                 failures += 1;
197                 System.err.println(&quot;Excess precision for &quot; + result);
198             }
199 
<a name="12" id="anc12"></a>
200             // If rounding to more than one digit, do precision / scale checking...
<a name="13" id="anc13"></a>
201         }
202 
203         return failures;
204     }
205 
206     private static int squareRootTwoTests() {
207         int failures = 0;
<a name="14" id="anc14"></a>
208 
209         // Square root of 2 truncated to 65 digits
210         BigDecimal highPrecisionRoot2 =
211             new BigDecimal(&quot;1.41421356237309504880168872420969807856967187537694807317667973799&quot;);
212 
<a name="15" id="anc15"></a>
213         RoundingMode[] modes = {
214             RoundingMode.UP,       RoundingMode.DOWN,
215             RoundingMode.CEILING, RoundingMode.FLOOR,
216             RoundingMode.HALF_UP, RoundingMode.HALF_DOWN, RoundingMode.HALF_EVEN
217         };
218 
<a name="16" id="anc16"></a>


219 
<a name="17" id="anc17"></a><span class="line-added">220         // For each interesting rounding mode, for precisions 1 to, say,</span>
<span class="line-added">221         // 63 numerically compare TWO.sqrt(mc) to</span>
<span class="line-added">222         // highPrecisionRoot2.round(mc) and the alternative internal high-precision</span>
<span class="line-added">223         // implementation of square root.</span>
224         for (RoundingMode mode : modes) {
225             for (int precision = 1; precision &lt; 63; precision++) {
226                 MathContext mc = new MathContext(precision, mode);
227                 BigDecimal expected = highPrecisionRoot2.round(mc);
228                 BigDecimal computed = TWO.sqrt(mc);
<a name="18" id="anc18"></a><span class="line-added">229                 BigDecimal altComputed = BigSquareRoot.sqrt(TWO, mc);</span>
230 
<a name="19" id="anc19"></a><span class="line-modified">231                 failures += equalNumerically(expected, computed, &quot;sqrt(2)&quot;);</span>
<span class="line-added">232                 failures += equalNumerically(computed, altComputed, &quot;computed &amp; altComputed&quot;);</span>
233             }
234         }
235 
236         return failures;
237     }
238 
239     private static int lowPrecisionPerfectSquares() {
240         int failures = 0;
241 
242         // For 5^2 through 9^2, if the input is rounded to one digit
243         // first before the root is computed, the wrong answer will
244         // result. Verify results and scale for different rounding
245         // modes and precisions.
246         long[][] squaresWithOneDigitRoot = {{ 4, 2},
247                                             { 9, 3},
248                                             {25, 5},
249                                             {36, 6},
250                                             {49, 7},
251                                             {64, 8},
252                                             {81, 9}};
253 
254         for (long[] squareAndRoot : squaresWithOneDigitRoot) {
255             BigDecimal square     = new BigDecimal(squareAndRoot[0]);
256             BigDecimal expected   = new BigDecimal(squareAndRoot[1]);
257 
258             for (int scale = 0; scale &lt;= 4; scale++) {
259                 BigDecimal scaledSquare = square.setScale(scale, RoundingMode.UNNECESSARY);
260                 int expectedScale = scale/2;
261                 for (int precision = 0; precision &lt;= 5; precision++) {
262                     for (RoundingMode rm : RoundingMode.values()) {
263                         MathContext mc = new MathContext(precision, rm);
264                         BigDecimal computedRoot = scaledSquare.sqrt(mc);
265                         failures += equalNumerically(expected, computedRoot, &quot;simple squares&quot;);
266                         int computedScale = computedRoot.scale();
267                         if (precision &gt;=  expectedScale + 1 &amp;&amp;
268                             computedScale != expectedScale) {
<a name="20" id="anc20"></a><span class="line-modified">269                             System.err.printf(&quot;%s\tprecision=%d\trm=%s%n&quot;,</span>
<span class="line-modified">270                                               computedRoot.toString(), precision, rm);</span>
271                             failures++;
272                             System.err.printf(&quot;\t%s does not have expected scale of %d%n.&quot;,
273                                               computedRoot, expectedScale);
274                         }
275                     }
276                 }
277             }
278         }
279 
280         return failures;
281     }
282 
<a name="21" id="anc21"></a><span class="line-added">283     /**</span>
<span class="line-added">284      * Test around 3.9999 that the sqrt doesn&#39;t improperly round-up to</span>
<span class="line-added">285      * a numerical value of 2.</span>
<span class="line-added">286      */</span>
<span class="line-added">287     private static int almostFourRoundingDown() {</span>
<span class="line-added">288         int failures = 0;</span>
<span class="line-added">289         BigDecimal nearFour = new BigDecimal(&quot;3.999999999999999999999999999999&quot;);</span>
<span class="line-added">290 </span>
<span class="line-added">291         // Sqrt is 1.9999...</span>
<span class="line-added">292 </span>
<span class="line-added">293         for (int i = 1; i &lt; 64; i++) {</span>
<span class="line-added">294             MathContext mc = new MathContext(i, RoundingMode.FLOOR);</span>
<span class="line-added">295             BigDecimal result = nearFour.sqrt(mc);</span>
<span class="line-added">296             BigDecimal expected = BigSquareRoot.sqrt(nearFour, mc);</span>
<span class="line-added">297             failures += equalNumerically(expected, result, &quot;near four rounding down&quot;);</span>
<span class="line-added">298             failures += (result.compareTo(TWO) &lt; 0) ? 0  : 1 ;</span>
<span class="line-added">299         }</span>
<span class="line-added">300 </span>
<span class="line-added">301         return failures;</span>
<span class="line-added">302     }</span>
<span class="line-added">303 </span>
<span class="line-added">304     /**</span>
<span class="line-added">305      * Test around 4.000...1 that the sqrt doesn&#39;t improperly</span>
<span class="line-added">306      * round-down to a numerical value of 2.</span>
<span class="line-added">307      */</span>
<span class="line-added">308     private static int almostFourRoundingUp() {</span>
<span class="line-added">309         int failures = 0;</span>
<span class="line-added">310         BigDecimal nearFour = new BigDecimal(&quot;4.000000000000000000000000000001&quot;);</span>
<span class="line-added">311 </span>
<span class="line-added">312         // Sqrt is 2.0000....&lt;non-zero digits&gt;</span>
<span class="line-added">313 </span>
<span class="line-added">314         for (int i = 1; i &lt; 64; i++) {</span>
<span class="line-added">315             MathContext mc = new MathContext(i, RoundingMode.CEILING);</span>
<span class="line-added">316             BigDecimal result = nearFour.sqrt(mc);</span>
<span class="line-added">317             BigDecimal expected = BigSquareRoot.sqrt(nearFour, mc);</span>
<span class="line-added">318             failures += equalNumerically(expected, result, &quot;near four rounding up&quot;);</span>
<span class="line-added">319             failures += (result.compareTo(TWO) &gt; 0) ? 0  : 1 ;</span>
<span class="line-added">320         }</span>
<span class="line-added">321 </span>
<span class="line-added">322         return failures;</span>
<span class="line-added">323     }</span>
<span class="line-added">324 </span>
<span class="line-added">325     private static int nearTen() {</span>
<span class="line-added">326         int failures = 0;</span>
<span class="line-added">327 </span>
<span class="line-added">328          BigDecimal near10 = new BigDecimal(&quot;9.99999999999999999999&quot;);</span>
<span class="line-added">329 </span>
<span class="line-added">330          BigDecimal near10sq = near10.multiply(near10);</span>
<span class="line-added">331 </span>
<span class="line-added">332          BigDecimal near10sq_ulp = near10sq.add(near10sq.ulp());</span>
<span class="line-added">333 </span>
<span class="line-added">334         for (int i = 10; i &lt; 23; i++) {</span>
<span class="line-added">335             MathContext mc = new MathContext(i, RoundingMode.HALF_EVEN);</span>
<span class="line-added">336 </span>
<span class="line-added">337             failures += equalNumerically(BigSquareRoot.sqrt(near10sq_ulp, mc),</span>
<span class="line-added">338                                          near10sq_ulp.sqrt(mc),</span>
<span class="line-added">339                                          &quot;near 10 rounding half even&quot;);</span>
<span class="line-added">340         }</span>
<span class="line-added">341 </span>
<span class="line-added">342         return failures;</span>
<span class="line-added">343     }</span>
<span class="line-added">344 </span>
<span class="line-added">345 </span>
<span class="line-added">346     /*</span>
<span class="line-added">347      * Probe for rounding failures near a power of ten, 1 = 10^0,</span>
<span class="line-added">348      * where an ulp has a different size above and below the value.</span>
<span class="line-added">349      */</span>
<span class="line-added">350     private static int nearOne() {</span>
<span class="line-added">351         int failures = 0;</span>
<span class="line-added">352 </span>
<span class="line-added">353          BigDecimal near1 = new BigDecimal(&quot;.999999999999999999999&quot;);</span>
<span class="line-added">354          BigDecimal near1sq = near1.multiply(near1);</span>
<span class="line-added">355          BigDecimal near1sq_ulp = near1sq.add(near1sq.ulp());</span>
<span class="line-added">356 </span>
<span class="line-added">357          for (int i = 10; i &lt; 23; i++) {</span>
<span class="line-added">358              for (RoundingMode rm : List.of(RoundingMode.HALF_EVEN,</span>
<span class="line-added">359                                             RoundingMode.UP,</span>
<span class="line-added">360                                             RoundingMode.DOWN )) {</span>
<span class="line-added">361                  MathContext mc = new MathContext(i, rm);</span>
<span class="line-added">362                  failures += equalNumerically(BigSquareRoot.sqrt(near1sq_ulp, mc),</span>
<span class="line-added">363                                               near1sq_ulp.sqrt(mc),</span>
<span class="line-added">364                                               mc.toString());</span>
<span class="line-added">365              }</span>
<span class="line-added">366          }</span>
<span class="line-added">367 </span>
<span class="line-added">368          return failures;</span>
<span class="line-added">369     }</span>
<span class="line-added">370 </span>
<span class="line-added">371 </span>
<span class="line-added">372     private static int halfWay() {</span>
<span class="line-added">373         int failures = 0;</span>
<span class="line-added">374 </span>
<span class="line-added">375         /*</span>
<span class="line-added">376          * Use enough digits that the exact result cannot be computed</span>
<span class="line-added">377          * from the sqrt of a double.</span>
<span class="line-added">378          */</span>
<span class="line-added">379         BigDecimal[] halfWayCases = {</span>
<span class="line-added">380             // Odd next digit, truncate on HALF_EVEN</span>
<span class="line-added">381             new BigDecimal(&quot;123456789123456789.5&quot;),</span>
<span class="line-added">382 </span>
<span class="line-added">383              // Even next digit, round up on HALF_EVEN</span>
<span class="line-added">384             new BigDecimal(&quot;123456789123456788.5&quot;),</span>
<span class="line-added">385         };</span>
<span class="line-added">386 </span>
<span class="line-added">387         for (BigDecimal halfWayCase : halfWayCases) {</span>
<span class="line-added">388             // Round result to next-to-last place</span>
<span class="line-added">389             int precision = halfWayCase.precision() - 1;</span>
<span class="line-added">390             BigDecimal square = halfWayCase.multiply(halfWayCase);</span>
<span class="line-added">391 </span>
<span class="line-added">392             for (RoundingMode rm : List.of(RoundingMode.HALF_EVEN,</span>
<span class="line-added">393                                            RoundingMode.HALF_UP,</span>
<span class="line-added">394                                            RoundingMode.HALF_DOWN)) {</span>
<span class="line-added">395                 MathContext mc = new MathContext(precision, rm);</span>
<span class="line-added">396 </span>
<span class="line-added">397                 System.out.println(&quot;\nRounding mode &quot; + rm);</span>
<span class="line-added">398                 System.out.println(&quot;\t&quot; + halfWayCase.round(mc) + &quot;\t&quot; + halfWayCase);</span>
<span class="line-added">399                 System.out.println(&quot;\t&quot; + BigSquareRoot.sqrt(square, mc));</span>
<span class="line-added">400 </span>
<span class="line-added">401                 failures += equalNumerically(/*square.sqrt(mc),*/</span>
<span class="line-added">402                                              BigSquareRoot.sqrt(square, mc),</span>
<span class="line-added">403                                              halfWayCase.round(mc),</span>
<span class="line-added">404                                              &quot;Rounding halway &quot; + rm);</span>
<span class="line-added">405             }</span>
<span class="line-added">406         }</span>
<span class="line-added">407 </span>
<span class="line-added">408         return failures;</span>
<span class="line-added">409     }</span>
<span class="line-added">410 </span>
411     private static int compare(BigDecimal a, BigDecimal b, boolean expected, String prefix) {
412         boolean result = a.equals(b);
413         int failed = (result==expected) ? 0 : 1;
414         if (failed == 1) {
415             System.err.println(&quot;Testing &quot; + prefix +
416                                &quot;(&quot; + a + &quot;).compareTo(&quot; + b + &quot;) =&gt; &quot; + result +
417                                &quot;\n\tExpected &quot; + expected);
418         }
419         return failed;
420     }
421 
422     private static int equalNumerically(BigDecimal a, BigDecimal b,
423                                         String prefix) {
424         return compareNumerically(a, b, 0, prefix);
425     }
426 
427 
428     private static int compareNumerically(BigDecimal a, BigDecimal b,
429                                           int expected, String prefix) {
430         int result = a.compareTo(b);
431         int failed = (result==expected) ? 0 : 1;
432         if (failed == 1) {
433             System.err.println(&quot;Testing &quot; + prefix +
434                                &quot;(&quot; + a + &quot;).compareTo(&quot; + b + &quot;) =&gt; &quot; + result +
435                                &quot;\n\tExpected &quot; + expected);
436         }
437         return failed;
438     }
439 
<a name="22" id="anc22"></a><span class="line-added">440     /**</span>
<span class="line-added">441      * Alternative implementation of BigDecimal square root which uses</span>
<span class="line-added">442      * higher-precision for a simpler set of termination conditions</span>
<span class="line-added">443      * for the Newton iteration.</span>
<span class="line-added">444      */</span>
<span class="line-added">445     private static class BigSquareRoot {</span>
<span class="line-added">446 </span>
<span class="line-added">447         /**</span>
<span class="line-added">448          * The value 0.5, with a scale of 1.</span>
<span class="line-added">449          */</span>
<span class="line-added">450         private static final BigDecimal ONE_HALF = valueOf(5L, 1);</span>
<span class="line-added">451 </span>
<span class="line-added">452         public static boolean isPowerOfTen(BigDecimal bd) {</span>
<span class="line-added">453             return BigInteger.ONE.equals(bd.unscaledValue());</span>
<span class="line-added">454         }</span>
<span class="line-added">455 </span>
<span class="line-added">456         public static BigDecimal square(BigDecimal bd) {</span>
<span class="line-added">457             return bd.multiply(bd);</span>
<span class="line-added">458         }</span>
<span class="line-added">459 </span>
<span class="line-added">460         public static BigDecimal sqrt(BigDecimal bd, MathContext mc) {</span>
<span class="line-added">461             int signum = bd.signum();</span>
<span class="line-added">462             if (signum == 1) {</span>
<span class="line-added">463                 /*</span>
<span class="line-added">464                  * The following code draws on the algorithm presented in</span>
<span class="line-added">465                  * &quot;Properly Rounded Variable Precision Square Root,&quot; Hull and</span>
<span class="line-added">466                  * Abrham, ACM Transactions on Mathematical Software, Vol 11,</span>
<span class="line-added">467                  * No. 3, September 1985, Pages 229-237.</span>
<span class="line-added">468                  *</span>
<span class="line-added">469                  * The BigDecimal computational model differs from the one</span>
<span class="line-added">470                  * presented in the paper in several ways: first BigDecimal</span>
<span class="line-added">471                  * numbers aren&#39;t necessarily normalized, second many more</span>
<span class="line-added">472                  * rounding modes are supported, including UNNECESSARY, and</span>
<span class="line-added">473                  * exact results can be requested.</span>
<span class="line-added">474                  *</span>
<span class="line-added">475                  * The main steps of the algorithm below are as follows,</span>
<span class="line-added">476                  * first argument reduce the value to the numerical range</span>
<span class="line-added">477                  * [1, 10) using the following relations:</span>
<span class="line-added">478                  *</span>
<span class="line-added">479                  * x = y * 10 ^ exp</span>
<span class="line-added">480                  * sqrt(x) = sqrt(y) * 10^(exp / 2) if exp is even</span>
<span class="line-added">481                  * sqrt(x) = sqrt(y/10) * 10 ^((exp+1)/2) is exp is odd</span>
<span class="line-added">482                  *</span>
<span class="line-added">483                  * Then use Newton&#39;s iteration on the reduced value to compute</span>
<span class="line-added">484                  * the numerical digits of the desired result.</span>
<span class="line-added">485                  *</span>
<span class="line-added">486                  * Finally, scale back to the desired exponent range and</span>
<span class="line-added">487                  * perform any adjustment to get the preferred scale in the</span>
<span class="line-added">488                  * representation.</span>
<span class="line-added">489                  */</span>
<span class="line-added">490 </span>
<span class="line-added">491                 // The code below favors relative simplicity over checking</span>
<span class="line-added">492                 // for special cases that could run faster.</span>
<span class="line-added">493 </span>
<span class="line-added">494                 int preferredScale = bd.scale()/2;</span>
<span class="line-added">495                 BigDecimal zeroWithFinalPreferredScale =</span>
<span class="line-added">496                     BigDecimal.valueOf(0L, preferredScale);</span>
<span class="line-added">497 </span>
<span class="line-added">498                 // First phase of numerical normalization, strip trailing</span>
<span class="line-added">499                 // zeros and check for even powers of 10.</span>
<span class="line-added">500                 BigDecimal stripped = bd.stripTrailingZeros();</span>
<span class="line-added">501                 int strippedScale = stripped.scale();</span>
<span class="line-added">502 </span>
<span class="line-added">503                 // Numerically sqrt(10^2N) = 10^N</span>
<span class="line-added">504                 if (isPowerOfTen(stripped) &amp;&amp;</span>
<span class="line-added">505                     strippedScale % 2 == 0) {</span>
<span class="line-added">506                     BigDecimal result = BigDecimal.valueOf(1L, strippedScale/2);</span>
<span class="line-added">507                     if (result.scale() != preferredScale) {</span>
<span class="line-added">508                         // Adjust to requested precision and preferred</span>
<span class="line-added">509                         // scale as appropriate.</span>
<span class="line-added">510                         result = result.add(zeroWithFinalPreferredScale, mc);</span>
<span class="line-added">511                     }</span>
<span class="line-added">512                     return result;</span>
<span class="line-added">513                 }</span>
<span class="line-added">514 </span>
<span class="line-added">515                 // After stripTrailingZeros, the representation is normalized as</span>
<span class="line-added">516                 //</span>
<span class="line-added">517                 // unscaledValue * 10^(-scale)</span>
<span class="line-added">518                 //</span>
<span class="line-added">519                 // where unscaledValue is an integer with the mimimum</span>
<span class="line-added">520                 // precision for the cohort of the numerical value. To</span>
<span class="line-added">521                 // allow binary floating-point hardware to be used to get</span>
<span class="line-added">522                 // approximately a 15 digit approximation to the square</span>
<span class="line-added">523                 // root, it is helpful to instead normalize this so that</span>
<span class="line-added">524                 // the significand portion is to right of the decimal</span>
<span class="line-added">525                 // point by roughly (scale() - precision() + 1).</span>
<span class="line-added">526 </span>
<span class="line-added">527                 // Now the precision / scale adjustment</span>
<span class="line-added">528                 int scaleAdjust = 0;</span>
<span class="line-added">529                 int scale = stripped.scale() - stripped.precision() + 1;</span>
<span class="line-added">530                 if (scale % 2 == 0) {</span>
<span class="line-added">531                     scaleAdjust = scale;</span>
<span class="line-added">532                 } else {</span>
<span class="line-added">533                     scaleAdjust = scale - 1;</span>
<span class="line-added">534                 }</span>
<span class="line-added">535 </span>
<span class="line-added">536                 BigDecimal working = stripped.scaleByPowerOfTen(scaleAdjust);</span>
<span class="line-added">537 </span>
<span class="line-added">538                 assert  // Verify 0.1 &lt;= working &lt; 10</span>
<span class="line-added">539                     ONE_TENTH.compareTo(working) &lt;= 0 &amp;&amp; working.compareTo(TEN) &lt; 0;</span>
<span class="line-added">540 </span>
<span class="line-added">541                 // Use good ole&#39; Math.sqrt to get the initial guess for</span>
<span class="line-added">542                 // the Newton iteration, good to at least 15 decimal</span>
<span class="line-added">543                 // digits. This approach does incur the cost of a</span>
<span class="line-added">544                 //</span>
<span class="line-added">545                 // BigDecimal -&gt; double -&gt; BigDecimal</span>
<span class="line-added">546                 //</span>
<span class="line-added">547                 // conversion cycle, but it avoids the need for several</span>
<span class="line-added">548                 // Newton iterations in BigDecimal arithmetic to get the</span>
<span class="line-added">549                 // working answer to 15 digits of precision. If many fewer</span>
<span class="line-added">550                 // than 15 digits were needed, it might be faster to do</span>
<span class="line-added">551                 // the loop entirely in BigDecimal arithmetic.</span>
<span class="line-added">552                 //</span>
<span class="line-added">553                 // (A double value might have as much many as 17 decimal</span>
<span class="line-added">554                 // digits of precision; it depends on the relative density</span>
<span class="line-added">555                 // of binary and decimal numbers at different regions of</span>
<span class="line-added">556                 // the number line.)</span>
<span class="line-added">557                 //</span>
<span class="line-added">558                 // (It would be possible to check for certain special</span>
<span class="line-added">559                 // cases to avoid doing any Newton iterations. For</span>
<span class="line-added">560                 // example, if the BigDecimal -&gt; double conversion was</span>
<span class="line-added">561                 // known to be exact and the rounding mode had a</span>
<span class="line-added">562                 // low-enough precision, the post-Newton rounding logic</span>
<span class="line-added">563                 // could be applied directly.)</span>
<span class="line-added">564 </span>
<span class="line-added">565                 BigDecimal guess = new BigDecimal(Math.sqrt(working.doubleValue()));</span>
<span class="line-added">566                 int guessPrecision = 15;</span>
<span class="line-added">567                 int originalPrecision = mc.getPrecision();</span>
<span class="line-added">568                 int targetPrecision;</span>
<span class="line-added">569 </span>
<span class="line-added">570                 // If an exact value is requested, it must only need</span>
<span class="line-added">571                 // about half of the input digits to represent since</span>
<span class="line-added">572                 // multiplying an N digit number by itself yield a (2N</span>
<span class="line-added">573                 // - 1) digit or 2N digit result.</span>
<span class="line-added">574                 if (originalPrecision == 0) {</span>
<span class="line-added">575                     targetPrecision = stripped.precision()/2 + 1;</span>
<span class="line-added">576                 } else {</span>
<span class="line-added">577                     targetPrecision = originalPrecision;</span>
<span class="line-added">578                 }</span>
<span class="line-added">579 </span>
<span class="line-added">580                 // When setting the precision to use inside the Newton</span>
<span class="line-added">581                 // iteration loop, take care to avoid the case where the</span>
<span class="line-added">582                 // precision of the input exceeds the requested precision</span>
<span class="line-added">583                 // and rounding the input value too soon.</span>
<span class="line-added">584                 BigDecimal approx = guess;</span>
<span class="line-added">585                 int workingPrecision = working.precision();</span>
<span class="line-added">586                 // Use &quot;2p + 2&quot; property to guarantee enough</span>
<span class="line-added">587                 // intermediate precision so that a double-rounding</span>
<span class="line-added">588                 // error does not occur when rounded to the final</span>
<span class="line-added">589                 // destination precision.</span>
<span class="line-added">590                 int loopPrecision =</span>
<span class="line-added">591                     Math.max(2 * Math.max(targetPrecision, workingPrecision) + 2,</span>
<span class="line-added">592                              34); // Force at least two Netwon</span>
<span class="line-added">593                                   // iterations on the Math.sqrt</span>
<span class="line-added">594                                   // result.</span>
<span class="line-added">595                 do {</span>
<span class="line-added">596                     MathContext mcTmp = new MathContext(loopPrecision, RoundingMode.HALF_EVEN);</span>
<span class="line-added">597                     // approx = 0.5 * (approx + fraction / approx)</span>
<span class="line-added">598                     approx = ONE_HALF.multiply(approx.add(working.divide(approx, mcTmp), mcTmp));</span>
<span class="line-added">599                     guessPrecision *= 2;</span>
<span class="line-added">600                 } while (guessPrecision &lt; loopPrecision);</span>
<span class="line-added">601 </span>
<span class="line-added">602                 BigDecimal result;</span>
<span class="line-added">603                 RoundingMode targetRm = mc.getRoundingMode();</span>
<span class="line-added">604                 if (targetRm == RoundingMode.UNNECESSARY || originalPrecision == 0) {</span>
<span class="line-added">605                     RoundingMode tmpRm =</span>
<span class="line-added">606                         (targetRm == RoundingMode.UNNECESSARY) ? RoundingMode.DOWN : targetRm;</span>
<span class="line-added">607                     MathContext mcTmp = new MathContext(targetPrecision, tmpRm);</span>
<span class="line-added">608                     result = approx.scaleByPowerOfTen(-scaleAdjust/2).round(mcTmp);</span>
<span class="line-added">609 </span>
<span class="line-added">610                     // If result*result != this numerically, the square</span>
<span class="line-added">611                     // root isn&#39;t exact</span>
<span class="line-added">612                     if (bd.subtract(square(result)).compareTo(ZERO) != 0) {</span>
<span class="line-added">613                         throw new ArithmeticException(&quot;Computed square root not exact.&quot;);</span>
<span class="line-added">614                     }</span>
<span class="line-added">615                 } else {</span>
<span class="line-added">616                     result = approx.scaleByPowerOfTen(-scaleAdjust/2).round(mc);</span>
<span class="line-added">617                 }</span>
<span class="line-added">618 </span>
<span class="line-added">619                 assert squareRootResultAssertions(bd, result, mc);</span>
<span class="line-added">620                 if (result.scale() != preferredScale) {</span>
<span class="line-added">621                     // The preferred scale of an add is</span>
<span class="line-added">622                     // max(addend.scale(), augend.scale()). Therefore, if</span>
<span class="line-added">623                     // the scale of the result is first minimized using</span>
<span class="line-added">624                     // stripTrailingZeros(), adding a zero of the</span>
<span class="line-added">625                     // preferred scale rounding the correct precision will</span>
<span class="line-added">626                     // perform the proper scale vs precision tradeoffs.</span>
<span class="line-added">627                     result = result.stripTrailingZeros().</span>
<span class="line-added">628                         add(zeroWithFinalPreferredScale,</span>
<span class="line-added">629                             new MathContext(originalPrecision, RoundingMode.UNNECESSARY));</span>
<span class="line-added">630                 }</span>
<span class="line-added">631                 return result;</span>
<span class="line-added">632             } else {</span>
<span class="line-added">633                 switch (signum) {</span>
<span class="line-added">634                 case -1:</span>
<span class="line-added">635                     throw new ArithmeticException(&quot;Attempted square root &quot; +</span>
<span class="line-added">636                                                   &quot;of negative BigDecimal&quot;);</span>
<span class="line-added">637                 case 0:</span>
<span class="line-added">638                     return valueOf(0L, bd.scale()/2);</span>
<span class="line-added">639 </span>
<span class="line-added">640                 default:</span>
<span class="line-added">641                     throw new AssertionError(&quot;Bad value from signum&quot;);</span>
<span class="line-added">642                 }</span>
<span class="line-added">643             }</span>
<span class="line-added">644         }</span>
<span class="line-added">645 </span>
<span class="line-added">646         /**</span>
<span class="line-added">647          * For nonzero values, check numerical correctness properties of</span>
<span class="line-added">648          * the computed result for the chosen rounding mode.</span>
<span class="line-added">649          *</span>
<span class="line-added">650          * For the directed roundings, for DOWN and FLOOR, result^2 must</span>
<span class="line-added">651          * be {@code &lt;=} the input and (result+ulp)^2 must be {@code &gt;} the</span>
<span class="line-added">652          * input. Conversely, for UP and CEIL, result^2 must be {@code &gt;=} the</span>
<span class="line-added">653          * input and (result-ulp)^2 must be {@code &lt;} the input.</span>
<span class="line-added">654          */</span>
<span class="line-added">655         private static boolean squareRootResultAssertions(BigDecimal input, BigDecimal result, MathContext mc) {</span>
<span class="line-added">656             if (result.signum() == 0) {</span>
<span class="line-added">657                 return squareRootZeroResultAssertions(input, result, mc);</span>
<span class="line-added">658             } else {</span>
<span class="line-added">659                 RoundingMode rm = mc.getRoundingMode();</span>
<span class="line-added">660                 BigDecimal ulp = result.ulp();</span>
<span class="line-added">661                 BigDecimal neighborUp   = result.add(ulp);</span>
<span class="line-added">662                 // Make neighbor down accurate even for powers of ten</span>
<span class="line-added">663                 if (isPowerOfTen(result)) {</span>
<span class="line-added">664                     ulp = ulp.divide(TEN);</span>
<span class="line-added">665                 }</span>
<span class="line-added">666                 BigDecimal neighborDown = result.subtract(ulp);</span>
<span class="line-added">667 </span>
<span class="line-added">668                 // Both the starting value and result should be nonzero and positive.</span>
<span class="line-added">669                 if (result.signum() != 1 ||</span>
<span class="line-added">670                     input.signum() != 1) {</span>
<span class="line-added">671                     return false;</span>
<span class="line-added">672                 }</span>
<span class="line-added">673 </span>
<span class="line-added">674                 switch (rm) {</span>
<span class="line-added">675                 case DOWN:</span>
<span class="line-added">676                 case FLOOR:</span>
<span class="line-added">677                     assert</span>
<span class="line-added">678                         square(result).compareTo(input)    &lt;= 0 &amp;&amp;</span>
<span class="line-added">679                         square(neighborUp).compareTo(input) &gt; 0:</span>
<span class="line-added">680                     &quot;Square of result out for bounds rounding &quot; + rm;</span>
<span class="line-added">681                     return true;</span>
<span class="line-added">682 </span>
<span class="line-added">683                 case UP:</span>
<span class="line-added">684                 case CEILING:</span>
<span class="line-added">685                     assert</span>
<span class="line-added">686                         square(result).compareTo(input) &gt;= 0 :</span>
<span class="line-added">687                     &quot;Square of result too small rounding &quot; + rm;</span>
<span class="line-added">688 </span>
<span class="line-added">689                     assert</span>
<span class="line-added">690                         square(neighborDown).compareTo(input) &lt; 0 :</span>
<span class="line-added">691                     &quot;Square of down neighbor too large rounding  &quot; + rm + &quot;\n&quot; +</span>
<span class="line-added">692                         &quot;\t input: &quot; + input + &quot;\t neighborDown: &quot; +  neighborDown +&quot;\t sqrt: &quot; + result +</span>
<span class="line-added">693                         &quot;\t&quot; + mc;</span>
<span class="line-added">694                     return true;</span>
<span class="line-added">695 </span>
<span class="line-added">696 </span>
<span class="line-added">697                 case HALF_DOWN:</span>
<span class="line-added">698                 case HALF_EVEN:</span>
<span class="line-added">699                 case HALF_UP:</span>
<span class="line-added">700                     BigDecimal err = square(result).subtract(input).abs();</span>
<span class="line-added">701                     BigDecimal errUp = square(neighborUp).subtract(input);</span>
<span class="line-added">702                     BigDecimal errDown =  input.subtract(square(neighborDown));</span>
<span class="line-added">703                     // All error values should be positive so don&#39;t need to</span>
<span class="line-added">704                     // compare absolute values.</span>
<span class="line-added">705 </span>
<span class="line-added">706                     int err_comp_errUp = err.compareTo(errUp);</span>
<span class="line-added">707                     int err_comp_errDown = err.compareTo(errDown);</span>
<span class="line-added">708 </span>
<span class="line-added">709                     assert</span>
<span class="line-added">710                         errUp.signum()   == 1 &amp;&amp;</span>
<span class="line-added">711                         errDown.signum() == 1 :</span>
<span class="line-added">712                     &quot;Errors of neighbors squared don&#39;t have correct signs&quot;;</span>
<span class="line-added">713 </span>
<span class="line-added">714                     // At least one of these must be true, but not both</span>
<span class="line-added">715 //                     assert</span>
<span class="line-added">716 //                         err_comp_errUp   &lt;= 0 : &quot;Upper neighbor is closer than result: &quot; + rm +</span>
<span class="line-added">717 //                         &quot;\t&quot; + input + &quot;\t result&quot; + result;</span>
<span class="line-added">718 //                     assert</span>
<span class="line-added">719 //                         err_comp_errDown &lt;= 0 : &quot;Lower neighbor is closer than result: &quot; + rm +</span>
<span class="line-added">720 //                         &quot;\t&quot; + input + &quot;\t result &quot; + result + &quot;\t lower neighbor: &quot; + neighborDown;</span>
<span class="line-added">721 </span>
<span class="line-added">722                     assert</span>
<span class="line-added">723                         ((err_comp_errUp   == 0 ) ? err_comp_errDown &lt; 0 : true) &amp;&amp;</span>
<span class="line-added">724                         ((err_comp_errDown == 0 ) ? err_comp_errUp   &lt; 0 : true) :</span>
<span class="line-added">725                             &quot;Incorrect error relationships&quot;;</span>
<span class="line-added">726                         // &amp;&amp; could check for digit conditions for ties too</span>
<span class="line-added">727                         return true;</span>
<span class="line-added">728 </span>
<span class="line-added">729                 default: // Definition of UNNECESSARY already verified.</span>
<span class="line-added">730                     return true;</span>
<span class="line-added">731                 }</span>
<span class="line-added">732             }</span>
<span class="line-added">733         }</span>
<span class="line-added">734 </span>
<span class="line-added">735         private static boolean squareRootZeroResultAssertions(BigDecimal input,</span>
<span class="line-added">736                                                               BigDecimal result,</span>
<span class="line-added">737                                                               MathContext mc) {</span>
<span class="line-added">738             return input.compareTo(ZERO) == 0;</span>
<span class="line-added">739         }</span>
<span class="line-added">740     }</span>
741 }
<a name="23" id="anc23"></a><span class="line-added">742 </span>
<a name="24" id="anc24"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="24" type="hidden" />
</body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff test/jdk/java/math/BigDecimal/SquareRootTests.java</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
<body>
<center><a href="LongValueExactTests.java.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="../BigInteger/LargeValueExceptions.java.cdiff.html" target="_top">next &gt;</a></center>    <h2>test/jdk/java/math/BigDecimal/SquareRootTests.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 1,7 ***</span>
  /*
<span class="line-modified">!  * Copyright (c) 2016, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.
<span class="line-new-header">--- 1,7 ---</span>
  /*
<span class="line-modified">!  * Copyright (c) 2016, 2020, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 21,27 ***</span>
   * questions.
   */
  
  /*
   * @test
<span class="line-modified">!  * @bug 4851777</span>
   * @summary Tests of BigDecimal.sqrt().
   */
  
  import java.math.*;
  import java.util.*;
  
  public class SquareRootTests {
  
      public static void main(String... args) {
          int failures = 0;
  
          failures += negativeTests();
          failures += zeroTests();
          failures += evenPowersOfTenTests();
          failures += squareRootTwoTests();
          failures += lowPrecisionPerfectSquares();
  
          if (failures &gt; 0 ) {
              throw new RuntimeException(&quot;Incurred &quot; + failures + &quot; failures&quot; +
                                         &quot; testing BigDecimal.sqrt().&quot;);
          }
<span class="line-new-header">--- 21,45 ---</span>
   * questions.
   */
  
  /*
   * @test
<span class="line-modified">!  * @bug 4851777 8233452</span>
   * @summary Tests of BigDecimal.sqrt().
   */
  
  import java.math.*;
  import java.util.*;
  
<span class="line-added">+ import static java.math.BigDecimal.ONE;</span>
<span class="line-added">+ import static java.math.BigDecimal.TEN;</span>
<span class="line-added">+ import static java.math.BigDecimal.ZERO;</span>
<span class="line-added">+ import static java.math.BigDecimal.valueOf;</span>
<span class="line-added">+ </span>
  public class SquareRootTests {
<span class="line-added">+     private static BigDecimal TWO = new BigDecimal(2);</span>
<span class="line-added">+ </span>
<span class="line-added">+     /**</span>
<span class="line-added">+      * The value 0.1, with a scale of 1.</span>
<span class="line-added">+      */</span>
<span class="line-added">+     private static final BigDecimal ONE_TENTH = valueOf(1L, 1);</span>
  
      public static void main(String... args) {
          int failures = 0;
  
          failures += negativeTests();
          failures += zeroTests();
<span class="line-added">+         failures += oneDigitTests();</span>
<span class="line-added">+         failures += twoDigitTests();</span>
          failures += evenPowersOfTenTests();
          failures += squareRootTwoTests();
          failures += lowPrecisionPerfectSquares();
<span class="line-added">+         failures += almostFourRoundingDown();</span>
<span class="line-added">+         failures += almostFourRoundingUp();</span>
<span class="line-added">+         failures += nearTen();</span>
<span class="line-added">+         failures += nearOne();</span>
<span class="line-added">+         failures += halfWay();</span>
  
          if (failures &gt; 0 ) {
              throw new RuntimeException(&quot;Incurred &quot; + failures + &quot; failures&quot; +
                                         &quot; testing BigDecimal.sqrt().&quot;);
          }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 81,72 ***</span>
          }
  
          return failures;
      }
  
      /**
       * sqrt(10^2N) is 10^N
       * Both numerical value and representation should be verified
       */
      private static int evenPowersOfTenTests() {
          int failures = 0;
          MathContext oneDigitExactly = new MathContext(1, RoundingMode.UNNECESSARY);
  
          for (int scale = -100; scale &lt;= 100; scale++) {
<span class="line-modified">!             BigDecimal testValue       = BigDecimal.valueOf(1, 2*scale);</span>
<span class="line-modified">!             BigDecimal expectedNumericalResult = BigDecimal.valueOf(1, scale);</span>
  
              BigDecimal result;
  
<span class="line-removed">- </span>
              failures += equalNumerically(expectedNumericalResult,
<span class="line-modified">!                                            result = testValue.sqrt(MathContext.DECIMAL64),</span>
<span class="line-modified">!                                            &quot;Even powers of 10, DECIMAL64&quot;);</span>
  
              // Can round to one digit of precision exactly
              failures += equalNumerically(expectedNumericalResult,
<span class="line-modified">!                                            result = testValue.sqrt(oneDigitExactly),</span>
<span class="line-modified">!                                            &quot;even powers of 10, 1 digit&quot;);</span>
              if (result.precision() &gt; 1) {
                  failures += 1;
                  System.err.println(&quot;Excess precision for &quot; + result);
              }
  
<span class="line-removed">- </span>
              // If rounding to more than one digit, do precision / scale checking...
<span class="line-removed">- </span>
          }
  
          return failures;
      }
  
      private static int squareRootTwoTests() {
          int failures = 0;
<span class="line-removed">-         BigDecimal TWO = new BigDecimal(2);</span>
  
          // Square root of 2 truncated to 65 digits
          BigDecimal highPrecisionRoot2 =
              new BigDecimal(&quot;1.41421356237309504880168872420969807856967187537694807317667973799&quot;);
  
<span class="line-removed">- </span>
          RoundingMode[] modes = {
              RoundingMode.UP,       RoundingMode.DOWN,
              RoundingMode.CEILING, RoundingMode.FLOOR,
              RoundingMode.HALF_UP, RoundingMode.HALF_DOWN, RoundingMode.HALF_EVEN
          };
  
<span class="line-removed">-         // For each iteresting rounding mode, for precisions 1 to, say</span>
<span class="line-removed">-         // 63 numerically compare TWO.sqrt(mc) to</span>
<span class="line-removed">-         // highPrecisionRoot2.round(mc)</span>
  
          for (RoundingMode mode : modes) {
              for (int precision = 1; precision &lt; 63; precision++) {
                  MathContext mc = new MathContext(precision, mode);
                  BigDecimal expected = highPrecisionRoot2.round(mc);
                  BigDecimal computed = TWO.sqrt(mc);
  
<span class="line-modified">!                 equalNumerically(expected, computed, &quot;sqrt(2)&quot;);</span>
              }
          }
  
          return failures;
      }
<span class="line-new-header">--- 99,139 ---</span>
          }
  
          return failures;
      }
  
<span class="line-added">+     /**</span>
<span class="line-added">+      * Probe inputs with one digit of precision, 1 ... 9 and those</span>
<span class="line-added">+      * values scaled by 10^-1, 0.1, ... 0.9.</span>
<span class="line-added">+      */</span>
<span class="line-added">+     private static int oneDigitTests() {</span>
<span class="line-added">+         int failures = 0;</span>
<span class="line-added">+ </span>
<span class="line-added">+         List&lt;BigDecimal&gt; oneToNine =</span>
<span class="line-added">+             List.of(ONE,        TWO,        valueOf(3),</span>
<span class="line-added">+                     valueOf(4), valueOf(5), valueOf(6),</span>
<span class="line-added">+                     valueOf(7), valueOf(8), valueOf(9));</span>
<span class="line-added">+ </span>
<span class="line-added">+         List&lt;RoundingMode&gt; modes =</span>
<span class="line-added">+             List.of(RoundingMode.UP,      RoundingMode.DOWN,</span>
<span class="line-added">+                     RoundingMode.CEILING, RoundingMode.FLOOR,</span>
<span class="line-added">+                     RoundingMode.HALF_UP, RoundingMode.HALF_DOWN, RoundingMode.HALF_EVEN);</span>
<span class="line-added">+ </span>
<span class="line-added">+         for (int i = 1; i &lt; 20; i++) {</span>
<span class="line-added">+             for (RoundingMode rm : modes) {</span>
<span class="line-added">+                 for (BigDecimal bd  : oneToNine) {</span>
<span class="line-added">+                     MathContext mc = new MathContext(i, rm);</span>
<span class="line-added">+ </span>
<span class="line-added">+                     failures += compareSqrtImplementations(bd, mc);</span>
<span class="line-added">+                     bd = bd.multiply(ONE_TENTH);</span>
<span class="line-added">+                     failures += compareSqrtImplementations(bd, mc);</span>
<span class="line-added">+                 }</span>
<span class="line-added">+             }</span>
<span class="line-added">+         }</span>
<span class="line-added">+ </span>
<span class="line-added">+         return failures;</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     /**</span>
<span class="line-added">+      * Probe inputs with two digits of precision, (10 ... 99) and</span>
<span class="line-added">+      * those values scaled by 10^-1 (1, ... 9.9) and scaled by 10^-2</span>
<span class="line-added">+      * (0.1 ... 0.99).</span>
<span class="line-added">+      */</span>
<span class="line-added">+     private static int twoDigitTests() {</span>
<span class="line-added">+         int failures = 0;</span>
<span class="line-added">+ </span>
<span class="line-added">+         List&lt;RoundingMode&gt; modes =</span>
<span class="line-added">+             List.of(RoundingMode.UP,      RoundingMode.DOWN,</span>
<span class="line-added">+                     RoundingMode.CEILING, RoundingMode.FLOOR,</span>
<span class="line-added">+                     RoundingMode.HALF_UP, RoundingMode.HALF_DOWN, RoundingMode.HALF_EVEN);</span>
<span class="line-added">+ </span>
<span class="line-added">+         for (int i = 10; i &lt; 100; i++) {</span>
<span class="line-added">+             BigDecimal bd0 = BigDecimal.valueOf(i);</span>
<span class="line-added">+             BigDecimal bd1 = bd0.multiply(ONE_TENTH);</span>
<span class="line-added">+             BigDecimal bd2 = bd1.multiply(ONE_TENTH);</span>
<span class="line-added">+ </span>
<span class="line-added">+             for (BigDecimal bd : List.of(bd0, bd1, bd2)) {</span>
<span class="line-added">+                 for (int precision = 1; i &lt; 20; i++) {</span>
<span class="line-added">+                     for (RoundingMode rm : modes) {</span>
<span class="line-added">+                         MathContext mc = new MathContext(precision, rm);</span>
<span class="line-added">+                         failures += compareSqrtImplementations(bd, mc);</span>
<span class="line-added">+                     }</span>
<span class="line-added">+                 }</span>
<span class="line-added">+             }</span>
<span class="line-added">+         }</span>
<span class="line-added">+ </span>
<span class="line-added">+         return failures;</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     private static int compareSqrtImplementations(BigDecimal bd, MathContext mc) {</span>
<span class="line-added">+         return equalNumerically(BigSquareRoot.sqrt(bd, mc),</span>
<span class="line-added">+                                 bd.sqrt(mc), &quot;sqrt(&quot; + bd + &quot;) under &quot; + mc);</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
      /**
       * sqrt(10^2N) is 10^N
       * Both numerical value and representation should be verified
       */
      private static int evenPowersOfTenTests() {
          int failures = 0;
          MathContext oneDigitExactly = new MathContext(1, RoundingMode.UNNECESSARY);
  
          for (int scale = -100; scale &lt;= 100; scale++) {
<span class="line-modified">!             BigDecimal testValue               = BigDecimal.valueOf(1, 2*scale);</span>
<span class="line-modified">!             BigDecimal expectedNumericalResult = BigDecimal.valueOf(1,   scale);</span>
  
              BigDecimal result;
  
              failures += equalNumerically(expectedNumericalResult,
<span class="line-modified">!                                          result = testValue.sqrt(MathContext.DECIMAL64),</span>
<span class="line-modified">!                                          &quot;Even powers of 10, DECIMAL64&quot;);</span>
  
              // Can round to one digit of precision exactly
              failures += equalNumerically(expectedNumericalResult,
<span class="line-modified">!                                          result = testValue.sqrt(oneDigitExactly),</span>
<span class="line-modified">!                                          &quot;even powers of 10, 1 digit&quot;);</span>
<span class="line-added">+ </span>
              if (result.precision() &gt; 1) {
                  failures += 1;
                  System.err.println(&quot;Excess precision for &quot; + result);
              }
  
              // If rounding to more than one digit, do precision / scale checking...
          }
  
          return failures;
      }
  
      private static int squareRootTwoTests() {
          int failures = 0;
  
          // Square root of 2 truncated to 65 digits
          BigDecimal highPrecisionRoot2 =
              new BigDecimal(&quot;1.41421356237309504880168872420969807856967187537694807317667973799&quot;);
  
          RoundingMode[] modes = {
              RoundingMode.UP,       RoundingMode.DOWN,
              RoundingMode.CEILING, RoundingMode.FLOOR,
              RoundingMode.HALF_UP, RoundingMode.HALF_DOWN, RoundingMode.HALF_EVEN
          };
  
  
<span class="line-added">+         // For each interesting rounding mode, for precisions 1 to, say,</span>
<span class="line-added">+         // 63 numerically compare TWO.sqrt(mc) to</span>
<span class="line-added">+         // highPrecisionRoot2.round(mc) and the alternative internal high-precision</span>
<span class="line-added">+         // implementation of square root.</span>
          for (RoundingMode mode : modes) {
              for (int precision = 1; precision &lt; 63; precision++) {
                  MathContext mc = new MathContext(precision, mode);
                  BigDecimal expected = highPrecisionRoot2.round(mc);
                  BigDecimal computed = TWO.sqrt(mc);
<span class="line-added">+                 BigDecimal altComputed = BigSquareRoot.sqrt(TWO, mc);</span>
  
<span class="line-modified">!                 failures += equalNumerically(expected, computed, &quot;sqrt(2)&quot;);</span>
<span class="line-added">+                 failures += equalNumerically(computed, altComputed, &quot;computed &amp; altComputed&quot;);</span>
              }
          }
  
          return failures;
      }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 179,12 ***</span>
                          BigDecimal computedRoot = scaledSquare.sqrt(mc);
                          failures += equalNumerically(expected, computedRoot, &quot;simple squares&quot;);
                          int computedScale = computedRoot.scale();
                          if (precision &gt;=  expectedScale + 1 &amp;&amp;
                              computedScale != expectedScale) {
<span class="line-modified">!                         System.err.printf(&quot;%s\tprecision=%d\trm=%s%n&quot;,</span>
<span class="line-modified">!                                           computedRoot.toString(), precision, rm);</span>
                              failures++;
                              System.err.printf(&quot;\t%s does not have expected scale of %d%n.&quot;,
                                                computedRoot, expectedScale);
                          }
                      }
<span class="line-new-header">--- 264,12 ---</span>
                          BigDecimal computedRoot = scaledSquare.sqrt(mc);
                          failures += equalNumerically(expected, computedRoot, &quot;simple squares&quot;);
                          int computedScale = computedRoot.scale();
                          if (precision &gt;=  expectedScale + 1 &amp;&amp;
                              computedScale != expectedScale) {
<span class="line-modified">!                             System.err.printf(&quot;%s\tprecision=%d\trm=%s%n&quot;,</span>
<span class="line-modified">!                                               computedRoot.toString(), precision, rm);</span>
                              failures++;
                              System.err.printf(&quot;\t%s does not have expected scale of %d%n.&quot;,
                                                computedRoot, expectedScale);
                          }
                      }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 193,10 ***</span>
<span class="line-new-header">--- 278,138 ---</span>
          }
  
          return failures;
      }
  
<span class="line-added">+     /**</span>
<span class="line-added">+      * Test around 3.9999 that the sqrt doesn&#39;t improperly round-up to</span>
<span class="line-added">+      * a numerical value of 2.</span>
<span class="line-added">+      */</span>
<span class="line-added">+     private static int almostFourRoundingDown() {</span>
<span class="line-added">+         int failures = 0;</span>
<span class="line-added">+         BigDecimal nearFour = new BigDecimal(&quot;3.999999999999999999999999999999&quot;);</span>
<span class="line-added">+ </span>
<span class="line-added">+         // Sqrt is 1.9999...</span>
<span class="line-added">+ </span>
<span class="line-added">+         for (int i = 1; i &lt; 64; i++) {</span>
<span class="line-added">+             MathContext mc = new MathContext(i, RoundingMode.FLOOR);</span>
<span class="line-added">+             BigDecimal result = nearFour.sqrt(mc);</span>
<span class="line-added">+             BigDecimal expected = BigSquareRoot.sqrt(nearFour, mc);</span>
<span class="line-added">+             failures += equalNumerically(expected, result, &quot;near four rounding down&quot;);</span>
<span class="line-added">+             failures += (result.compareTo(TWO) &lt; 0) ? 0  : 1 ;</span>
<span class="line-added">+         }</span>
<span class="line-added">+ </span>
<span class="line-added">+         return failures;</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     /**</span>
<span class="line-added">+      * Test around 4.000...1 that the sqrt doesn&#39;t improperly</span>
<span class="line-added">+      * round-down to a numerical value of 2.</span>
<span class="line-added">+      */</span>
<span class="line-added">+     private static int almostFourRoundingUp() {</span>
<span class="line-added">+         int failures = 0;</span>
<span class="line-added">+         BigDecimal nearFour = new BigDecimal(&quot;4.000000000000000000000000000001&quot;);</span>
<span class="line-added">+ </span>
<span class="line-added">+         // Sqrt is 2.0000....&lt;non-zero digits&gt;</span>
<span class="line-added">+ </span>
<span class="line-added">+         for (int i = 1; i &lt; 64; i++) {</span>
<span class="line-added">+             MathContext mc = new MathContext(i, RoundingMode.CEILING);</span>
<span class="line-added">+             BigDecimal result = nearFour.sqrt(mc);</span>
<span class="line-added">+             BigDecimal expected = BigSquareRoot.sqrt(nearFour, mc);</span>
<span class="line-added">+             failures += equalNumerically(expected, result, &quot;near four rounding up&quot;);</span>
<span class="line-added">+             failures += (result.compareTo(TWO) &gt; 0) ? 0  : 1 ;</span>
<span class="line-added">+         }</span>
<span class="line-added">+ </span>
<span class="line-added">+         return failures;</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     private static int nearTen() {</span>
<span class="line-added">+         int failures = 0;</span>
<span class="line-added">+ </span>
<span class="line-added">+          BigDecimal near10 = new BigDecimal(&quot;9.99999999999999999999&quot;);</span>
<span class="line-added">+ </span>
<span class="line-added">+          BigDecimal near10sq = near10.multiply(near10);</span>
<span class="line-added">+ </span>
<span class="line-added">+          BigDecimal near10sq_ulp = near10sq.add(near10sq.ulp());</span>
<span class="line-added">+ </span>
<span class="line-added">+         for (int i = 10; i &lt; 23; i++) {</span>
<span class="line-added">+             MathContext mc = new MathContext(i, RoundingMode.HALF_EVEN);</span>
<span class="line-added">+ </span>
<span class="line-added">+             failures += equalNumerically(BigSquareRoot.sqrt(near10sq_ulp, mc),</span>
<span class="line-added">+                                          near10sq_ulp.sqrt(mc),</span>
<span class="line-added">+                                          &quot;near 10 rounding half even&quot;);</span>
<span class="line-added">+         }</span>
<span class="line-added">+ </span>
<span class="line-added">+         return failures;</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+ </span>
<span class="line-added">+     /*</span>
<span class="line-added">+      * Probe for rounding failures near a power of ten, 1 = 10^0,</span>
<span class="line-added">+      * where an ulp has a different size above and below the value.</span>
<span class="line-added">+      */</span>
<span class="line-added">+     private static int nearOne() {</span>
<span class="line-added">+         int failures = 0;</span>
<span class="line-added">+ </span>
<span class="line-added">+          BigDecimal near1 = new BigDecimal(&quot;.999999999999999999999&quot;);</span>
<span class="line-added">+          BigDecimal near1sq = near1.multiply(near1);</span>
<span class="line-added">+          BigDecimal near1sq_ulp = near1sq.add(near1sq.ulp());</span>
<span class="line-added">+ </span>
<span class="line-added">+          for (int i = 10; i &lt; 23; i++) {</span>
<span class="line-added">+              for (RoundingMode rm : List.of(RoundingMode.HALF_EVEN,</span>
<span class="line-added">+                                             RoundingMode.UP,</span>
<span class="line-added">+                                             RoundingMode.DOWN )) {</span>
<span class="line-added">+                  MathContext mc = new MathContext(i, rm);</span>
<span class="line-added">+                  failures += equalNumerically(BigSquareRoot.sqrt(near1sq_ulp, mc),</span>
<span class="line-added">+                                               near1sq_ulp.sqrt(mc),</span>
<span class="line-added">+                                               mc.toString());</span>
<span class="line-added">+              }</span>
<span class="line-added">+          }</span>
<span class="line-added">+ </span>
<span class="line-added">+          return failures;</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+ </span>
<span class="line-added">+     private static int halfWay() {</span>
<span class="line-added">+         int failures = 0;</span>
<span class="line-added">+ </span>
<span class="line-added">+         /*</span>
<span class="line-added">+          * Use enough digits that the exact result cannot be computed</span>
<span class="line-added">+          * from the sqrt of a double.</span>
<span class="line-added">+          */</span>
<span class="line-added">+         BigDecimal[] halfWayCases = {</span>
<span class="line-added">+             // Odd next digit, truncate on HALF_EVEN</span>
<span class="line-added">+             new BigDecimal(&quot;123456789123456789.5&quot;),</span>
<span class="line-added">+ </span>
<span class="line-added">+              // Even next digit, round up on HALF_EVEN</span>
<span class="line-added">+             new BigDecimal(&quot;123456789123456788.5&quot;),</span>
<span class="line-added">+         };</span>
<span class="line-added">+ </span>
<span class="line-added">+         for (BigDecimal halfWayCase : halfWayCases) {</span>
<span class="line-added">+             // Round result to next-to-last place</span>
<span class="line-added">+             int precision = halfWayCase.precision() - 1;</span>
<span class="line-added">+             BigDecimal square = halfWayCase.multiply(halfWayCase);</span>
<span class="line-added">+ </span>
<span class="line-added">+             for (RoundingMode rm : List.of(RoundingMode.HALF_EVEN,</span>
<span class="line-added">+                                            RoundingMode.HALF_UP,</span>
<span class="line-added">+                                            RoundingMode.HALF_DOWN)) {</span>
<span class="line-added">+                 MathContext mc = new MathContext(precision, rm);</span>
<span class="line-added">+ </span>
<span class="line-added">+                 System.out.println(&quot;\nRounding mode &quot; + rm);</span>
<span class="line-added">+                 System.out.println(&quot;\t&quot; + halfWayCase.round(mc) + &quot;\t&quot; + halfWayCase);</span>
<span class="line-added">+                 System.out.println(&quot;\t&quot; + BigSquareRoot.sqrt(square, mc));</span>
<span class="line-added">+ </span>
<span class="line-added">+                 failures += equalNumerically(/*square.sqrt(mc),*/</span>
<span class="line-added">+                                              BigSquareRoot.sqrt(square, mc),</span>
<span class="line-added">+                                              halfWayCase.round(mc),</span>
<span class="line-added">+                                              &quot;Rounding halway &quot; + rm);</span>
<span class="line-added">+             }</span>
<span class="line-added">+         }</span>
<span class="line-added">+ </span>
<span class="line-added">+         return failures;</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
      private static int compare(BigDecimal a, BigDecimal b, boolean expected, String prefix) {
          boolean result = a.equals(b);
          int failed = (result==expected) ? 0 : 1;
          if (failed == 1) {
              System.err.println(&quot;Testing &quot; + prefix +
</pre>
<hr />
<pre>
<span class="line-old-header">*** 222,6 ***</span>
<span class="line-new-header">--- 435,308 ---</span>
                                 &quot;\n\tExpected &quot; + expected);
          }
          return failed;
      }
  
<span class="line-added">+     /**</span>
<span class="line-added">+      * Alternative implementation of BigDecimal square root which uses</span>
<span class="line-added">+      * higher-precision for a simpler set of termination conditions</span>
<span class="line-added">+      * for the Newton iteration.</span>
<span class="line-added">+      */</span>
<span class="line-added">+     private static class BigSquareRoot {</span>
<span class="line-added">+ </span>
<span class="line-added">+         /**</span>
<span class="line-added">+          * The value 0.5, with a scale of 1.</span>
<span class="line-added">+          */</span>
<span class="line-added">+         private static final BigDecimal ONE_HALF = valueOf(5L, 1);</span>
<span class="line-added">+ </span>
<span class="line-added">+         public static boolean isPowerOfTen(BigDecimal bd) {</span>
<span class="line-added">+             return BigInteger.ONE.equals(bd.unscaledValue());</span>
<span class="line-added">+         }</span>
<span class="line-added">+ </span>
<span class="line-added">+         public static BigDecimal square(BigDecimal bd) {</span>
<span class="line-added">+             return bd.multiply(bd);</span>
<span class="line-added">+         }</span>
<span class="line-added">+ </span>
<span class="line-added">+         public static BigDecimal sqrt(BigDecimal bd, MathContext mc) {</span>
<span class="line-added">+             int signum = bd.signum();</span>
<span class="line-added">+             if (signum == 1) {</span>
<span class="line-added">+                 /*</span>
<span class="line-added">+                  * The following code draws on the algorithm presented in</span>
<span class="line-added">+                  * &quot;Properly Rounded Variable Precision Square Root,&quot; Hull and</span>
<span class="line-added">+                  * Abrham, ACM Transactions on Mathematical Software, Vol 11,</span>
<span class="line-added">+                  * No. 3, September 1985, Pages 229-237.</span>
<span class="line-added">+                  *</span>
<span class="line-added">+                  * The BigDecimal computational model differs from the one</span>
<span class="line-added">+                  * presented in the paper in several ways: first BigDecimal</span>
<span class="line-added">+                  * numbers aren&#39;t necessarily normalized, second many more</span>
<span class="line-added">+                  * rounding modes are supported, including UNNECESSARY, and</span>
<span class="line-added">+                  * exact results can be requested.</span>
<span class="line-added">+                  *</span>
<span class="line-added">+                  * The main steps of the algorithm below are as follows,</span>
<span class="line-added">+                  * first argument reduce the value to the numerical range</span>
<span class="line-added">+                  * [1, 10) using the following relations:</span>
<span class="line-added">+                  *</span>
<span class="line-added">+                  * x = y * 10 ^ exp</span>
<span class="line-added">+                  * sqrt(x) = sqrt(y) * 10^(exp / 2) if exp is even</span>
<span class="line-added">+                  * sqrt(x) = sqrt(y/10) * 10 ^((exp+1)/2) is exp is odd</span>
<span class="line-added">+                  *</span>
<span class="line-added">+                  * Then use Newton&#39;s iteration on the reduced value to compute</span>
<span class="line-added">+                  * the numerical digits of the desired result.</span>
<span class="line-added">+                  *</span>
<span class="line-added">+                  * Finally, scale back to the desired exponent range and</span>
<span class="line-added">+                  * perform any adjustment to get the preferred scale in the</span>
<span class="line-added">+                  * representation.</span>
<span class="line-added">+                  */</span>
<span class="line-added">+ </span>
<span class="line-added">+                 // The code below favors relative simplicity over checking</span>
<span class="line-added">+                 // for special cases that could run faster.</span>
<span class="line-added">+ </span>
<span class="line-added">+                 int preferredScale = bd.scale()/2;</span>
<span class="line-added">+                 BigDecimal zeroWithFinalPreferredScale =</span>
<span class="line-added">+                     BigDecimal.valueOf(0L, preferredScale);</span>
<span class="line-added">+ </span>
<span class="line-added">+                 // First phase of numerical normalization, strip trailing</span>
<span class="line-added">+                 // zeros and check for even powers of 10.</span>
<span class="line-added">+                 BigDecimal stripped = bd.stripTrailingZeros();</span>
<span class="line-added">+                 int strippedScale = stripped.scale();</span>
<span class="line-added">+ </span>
<span class="line-added">+                 // Numerically sqrt(10^2N) = 10^N</span>
<span class="line-added">+                 if (isPowerOfTen(stripped) &amp;&amp;</span>
<span class="line-added">+                     strippedScale % 2 == 0) {</span>
<span class="line-added">+                     BigDecimal result = BigDecimal.valueOf(1L, strippedScale/2);</span>
<span class="line-added">+                     if (result.scale() != preferredScale) {</span>
<span class="line-added">+                         // Adjust to requested precision and preferred</span>
<span class="line-added">+                         // scale as appropriate.</span>
<span class="line-added">+                         result = result.add(zeroWithFinalPreferredScale, mc);</span>
<span class="line-added">+                     }</span>
<span class="line-added">+                     return result;</span>
<span class="line-added">+                 }</span>
<span class="line-added">+ </span>
<span class="line-added">+                 // After stripTrailingZeros, the representation is normalized as</span>
<span class="line-added">+                 //</span>
<span class="line-added">+                 // unscaledValue * 10^(-scale)</span>
<span class="line-added">+                 //</span>
<span class="line-added">+                 // where unscaledValue is an integer with the mimimum</span>
<span class="line-added">+                 // precision for the cohort of the numerical value. To</span>
<span class="line-added">+                 // allow binary floating-point hardware to be used to get</span>
<span class="line-added">+                 // approximately a 15 digit approximation to the square</span>
<span class="line-added">+                 // root, it is helpful to instead normalize this so that</span>
<span class="line-added">+                 // the significand portion is to right of the decimal</span>
<span class="line-added">+                 // point by roughly (scale() - precision() + 1).</span>
<span class="line-added">+ </span>
<span class="line-added">+                 // Now the precision / scale adjustment</span>
<span class="line-added">+                 int scaleAdjust = 0;</span>
<span class="line-added">+                 int scale = stripped.scale() - stripped.precision() + 1;</span>
<span class="line-added">+                 if (scale % 2 == 0) {</span>
<span class="line-added">+                     scaleAdjust = scale;</span>
<span class="line-added">+                 } else {</span>
<span class="line-added">+                     scaleAdjust = scale - 1;</span>
<span class="line-added">+                 }</span>
<span class="line-added">+ </span>
<span class="line-added">+                 BigDecimal working = stripped.scaleByPowerOfTen(scaleAdjust);</span>
<span class="line-added">+ </span>
<span class="line-added">+                 assert  // Verify 0.1 &lt;= working &lt; 10</span>
<span class="line-added">+                     ONE_TENTH.compareTo(working) &lt;= 0 &amp;&amp; working.compareTo(TEN) &lt; 0;</span>
<span class="line-added">+ </span>
<span class="line-added">+                 // Use good ole&#39; Math.sqrt to get the initial guess for</span>
<span class="line-added">+                 // the Newton iteration, good to at least 15 decimal</span>
<span class="line-added">+                 // digits. This approach does incur the cost of a</span>
<span class="line-added">+                 //</span>
<span class="line-added">+                 // BigDecimal -&gt; double -&gt; BigDecimal</span>
<span class="line-added">+                 //</span>
<span class="line-added">+                 // conversion cycle, but it avoids the need for several</span>
<span class="line-added">+                 // Newton iterations in BigDecimal arithmetic to get the</span>
<span class="line-added">+                 // working answer to 15 digits of precision. If many fewer</span>
<span class="line-added">+                 // than 15 digits were needed, it might be faster to do</span>
<span class="line-added">+                 // the loop entirely in BigDecimal arithmetic.</span>
<span class="line-added">+                 //</span>
<span class="line-added">+                 // (A double value might have as much many as 17 decimal</span>
<span class="line-added">+                 // digits of precision; it depends on the relative density</span>
<span class="line-added">+                 // of binary and decimal numbers at different regions of</span>
<span class="line-added">+                 // the number line.)</span>
<span class="line-added">+                 //</span>
<span class="line-added">+                 // (It would be possible to check for certain special</span>
<span class="line-added">+                 // cases to avoid doing any Newton iterations. For</span>
<span class="line-added">+                 // example, if the BigDecimal -&gt; double conversion was</span>
<span class="line-added">+                 // known to be exact and the rounding mode had a</span>
<span class="line-added">+                 // low-enough precision, the post-Newton rounding logic</span>
<span class="line-added">+                 // could be applied directly.)</span>
<span class="line-added">+ </span>
<span class="line-added">+                 BigDecimal guess = new BigDecimal(Math.sqrt(working.doubleValue()));</span>
<span class="line-added">+                 int guessPrecision = 15;</span>
<span class="line-added">+                 int originalPrecision = mc.getPrecision();</span>
<span class="line-added">+                 int targetPrecision;</span>
<span class="line-added">+ </span>
<span class="line-added">+                 // If an exact value is requested, it must only need</span>
<span class="line-added">+                 // about half of the input digits to represent since</span>
<span class="line-added">+                 // multiplying an N digit number by itself yield a (2N</span>
<span class="line-added">+                 // - 1) digit or 2N digit result.</span>
<span class="line-added">+                 if (originalPrecision == 0) {</span>
<span class="line-added">+                     targetPrecision = stripped.precision()/2 + 1;</span>
<span class="line-added">+                 } else {</span>
<span class="line-added">+                     targetPrecision = originalPrecision;</span>
<span class="line-added">+                 }</span>
<span class="line-added">+ </span>
<span class="line-added">+                 // When setting the precision to use inside the Newton</span>
<span class="line-added">+                 // iteration loop, take care to avoid the case where the</span>
<span class="line-added">+                 // precision of the input exceeds the requested precision</span>
<span class="line-added">+                 // and rounding the input value too soon.</span>
<span class="line-added">+                 BigDecimal approx = guess;</span>
<span class="line-added">+                 int workingPrecision = working.precision();</span>
<span class="line-added">+                 // Use &quot;2p + 2&quot; property to guarantee enough</span>
<span class="line-added">+                 // intermediate precision so that a double-rounding</span>
<span class="line-added">+                 // error does not occur when rounded to the final</span>
<span class="line-added">+                 // destination precision.</span>
<span class="line-added">+                 int loopPrecision =</span>
<span class="line-added">+                     Math.max(2 * Math.max(targetPrecision, workingPrecision) + 2,</span>
<span class="line-added">+                              34); // Force at least two Netwon</span>
<span class="line-added">+                                   // iterations on the Math.sqrt</span>
<span class="line-added">+                                   // result.</span>
<span class="line-added">+                 do {</span>
<span class="line-added">+                     MathContext mcTmp = new MathContext(loopPrecision, RoundingMode.HALF_EVEN);</span>
<span class="line-added">+                     // approx = 0.5 * (approx + fraction / approx)</span>
<span class="line-added">+                     approx = ONE_HALF.multiply(approx.add(working.divide(approx, mcTmp), mcTmp));</span>
<span class="line-added">+                     guessPrecision *= 2;</span>
<span class="line-added">+                 } while (guessPrecision &lt; loopPrecision);</span>
<span class="line-added">+ </span>
<span class="line-added">+                 BigDecimal result;</span>
<span class="line-added">+                 RoundingMode targetRm = mc.getRoundingMode();</span>
<span class="line-added">+                 if (targetRm == RoundingMode.UNNECESSARY || originalPrecision == 0) {</span>
<span class="line-added">+                     RoundingMode tmpRm =</span>
<span class="line-added">+                         (targetRm == RoundingMode.UNNECESSARY) ? RoundingMode.DOWN : targetRm;</span>
<span class="line-added">+                     MathContext mcTmp = new MathContext(targetPrecision, tmpRm);</span>
<span class="line-added">+                     result = approx.scaleByPowerOfTen(-scaleAdjust/2).round(mcTmp);</span>
<span class="line-added">+ </span>
<span class="line-added">+                     // If result*result != this numerically, the square</span>
<span class="line-added">+                     // root isn&#39;t exact</span>
<span class="line-added">+                     if (bd.subtract(square(result)).compareTo(ZERO) != 0) {</span>
<span class="line-added">+                         throw new ArithmeticException(&quot;Computed square root not exact.&quot;);</span>
<span class="line-added">+                     }</span>
<span class="line-added">+                 } else {</span>
<span class="line-added">+                     result = approx.scaleByPowerOfTen(-scaleAdjust/2).round(mc);</span>
<span class="line-added">+                 }</span>
<span class="line-added">+ </span>
<span class="line-added">+                 assert squareRootResultAssertions(bd, result, mc);</span>
<span class="line-added">+                 if (result.scale() != preferredScale) {</span>
<span class="line-added">+                     // The preferred scale of an add is</span>
<span class="line-added">+                     // max(addend.scale(), augend.scale()). Therefore, if</span>
<span class="line-added">+                     // the scale of the result is first minimized using</span>
<span class="line-added">+                     // stripTrailingZeros(), adding a zero of the</span>
<span class="line-added">+                     // preferred scale rounding the correct precision will</span>
<span class="line-added">+                     // perform the proper scale vs precision tradeoffs.</span>
<span class="line-added">+                     result = result.stripTrailingZeros().</span>
<span class="line-added">+                         add(zeroWithFinalPreferredScale,</span>
<span class="line-added">+                             new MathContext(originalPrecision, RoundingMode.UNNECESSARY));</span>
<span class="line-added">+                 }</span>
<span class="line-added">+                 return result;</span>
<span class="line-added">+             } else {</span>
<span class="line-added">+                 switch (signum) {</span>
<span class="line-added">+                 case -1:</span>
<span class="line-added">+                     throw new ArithmeticException(&quot;Attempted square root &quot; +</span>
<span class="line-added">+                                                   &quot;of negative BigDecimal&quot;);</span>
<span class="line-added">+                 case 0:</span>
<span class="line-added">+                     return valueOf(0L, bd.scale()/2);</span>
<span class="line-added">+ </span>
<span class="line-added">+                 default:</span>
<span class="line-added">+                     throw new AssertionError(&quot;Bad value from signum&quot;);</span>
<span class="line-added">+                 }</span>
<span class="line-added">+             }</span>
<span class="line-added">+         }</span>
<span class="line-added">+ </span>
<span class="line-added">+         /**</span>
<span class="line-added">+          * For nonzero values, check numerical correctness properties of</span>
<span class="line-added">+          * the computed result for the chosen rounding mode.</span>
<span class="line-added">+          *</span>
<span class="line-added">+          * For the directed roundings, for DOWN and FLOOR, result^2 must</span>
<span class="line-added">+          * be {@code &lt;=} the input and (result+ulp)^2 must be {@code &gt;} the</span>
<span class="line-added">+          * input. Conversely, for UP and CEIL, result^2 must be {@code &gt;=} the</span>
<span class="line-added">+          * input and (result-ulp)^2 must be {@code &lt;} the input.</span>
<span class="line-added">+          */</span>
<span class="line-added">+         private static boolean squareRootResultAssertions(BigDecimal input, BigDecimal result, MathContext mc) {</span>
<span class="line-added">+             if (result.signum() == 0) {</span>
<span class="line-added">+                 return squareRootZeroResultAssertions(input, result, mc);</span>
<span class="line-added">+             } else {</span>
<span class="line-added">+                 RoundingMode rm = mc.getRoundingMode();</span>
<span class="line-added">+                 BigDecimal ulp = result.ulp();</span>
<span class="line-added">+                 BigDecimal neighborUp   = result.add(ulp);</span>
<span class="line-added">+                 // Make neighbor down accurate even for powers of ten</span>
<span class="line-added">+                 if (isPowerOfTen(result)) {</span>
<span class="line-added">+                     ulp = ulp.divide(TEN);</span>
<span class="line-added">+                 }</span>
<span class="line-added">+                 BigDecimal neighborDown = result.subtract(ulp);</span>
<span class="line-added">+ </span>
<span class="line-added">+                 // Both the starting value and result should be nonzero and positive.</span>
<span class="line-added">+                 if (result.signum() != 1 ||</span>
<span class="line-added">+                     input.signum() != 1) {</span>
<span class="line-added">+                     return false;</span>
<span class="line-added">+                 }</span>
<span class="line-added">+ </span>
<span class="line-added">+                 switch (rm) {</span>
<span class="line-added">+                 case DOWN:</span>
<span class="line-added">+                 case FLOOR:</span>
<span class="line-added">+                     assert</span>
<span class="line-added">+                         square(result).compareTo(input)    &lt;= 0 &amp;&amp;</span>
<span class="line-added">+                         square(neighborUp).compareTo(input) &gt; 0:</span>
<span class="line-added">+                     &quot;Square of result out for bounds rounding &quot; + rm;</span>
<span class="line-added">+                     return true;</span>
<span class="line-added">+ </span>
<span class="line-added">+                 case UP:</span>
<span class="line-added">+                 case CEILING:</span>
<span class="line-added">+                     assert</span>
<span class="line-added">+                         square(result).compareTo(input) &gt;= 0 :</span>
<span class="line-added">+                     &quot;Square of result too small rounding &quot; + rm;</span>
<span class="line-added">+ </span>
<span class="line-added">+                     assert</span>
<span class="line-added">+                         square(neighborDown).compareTo(input) &lt; 0 :</span>
<span class="line-added">+                     &quot;Square of down neighbor too large rounding  &quot; + rm + &quot;\n&quot; +</span>
<span class="line-added">+                         &quot;\t input: &quot; + input + &quot;\t neighborDown: &quot; +  neighborDown +&quot;\t sqrt: &quot; + result +</span>
<span class="line-added">+                         &quot;\t&quot; + mc;</span>
<span class="line-added">+                     return true;</span>
<span class="line-added">+ </span>
<span class="line-added">+ </span>
<span class="line-added">+                 case HALF_DOWN:</span>
<span class="line-added">+                 case HALF_EVEN:</span>
<span class="line-added">+                 case HALF_UP:</span>
<span class="line-added">+                     BigDecimal err = square(result).subtract(input).abs();</span>
<span class="line-added">+                     BigDecimal errUp = square(neighborUp).subtract(input);</span>
<span class="line-added">+                     BigDecimal errDown =  input.subtract(square(neighborDown));</span>
<span class="line-added">+                     // All error values should be positive so don&#39;t need to</span>
<span class="line-added">+                     // compare absolute values.</span>
<span class="line-added">+ </span>
<span class="line-added">+                     int err_comp_errUp = err.compareTo(errUp);</span>
<span class="line-added">+                     int err_comp_errDown = err.compareTo(errDown);</span>
<span class="line-added">+ </span>
<span class="line-added">+                     assert</span>
<span class="line-added">+                         errUp.signum()   == 1 &amp;&amp;</span>
<span class="line-added">+                         errDown.signum() == 1 :</span>
<span class="line-added">+                     &quot;Errors of neighbors squared don&#39;t have correct signs&quot;;</span>
<span class="line-added">+ </span>
<span class="line-added">+                     // At least one of these must be true, but not both</span>
<span class="line-added">+ //                     assert</span>
<span class="line-added">+ //                         err_comp_errUp   &lt;= 0 : &quot;Upper neighbor is closer than result: &quot; + rm +</span>
<span class="line-added">+ //                         &quot;\t&quot; + input + &quot;\t result&quot; + result;</span>
<span class="line-added">+ //                     assert</span>
<span class="line-added">+ //                         err_comp_errDown &lt;= 0 : &quot;Lower neighbor is closer than result: &quot; + rm +</span>
<span class="line-added">+ //                         &quot;\t&quot; + input + &quot;\t result &quot; + result + &quot;\t lower neighbor: &quot; + neighborDown;</span>
<span class="line-added">+ </span>
<span class="line-added">+                     assert</span>
<span class="line-added">+                         ((err_comp_errUp   == 0 ) ? err_comp_errDown &lt; 0 : true) &amp;&amp;</span>
<span class="line-added">+                         ((err_comp_errDown == 0 ) ? err_comp_errUp   &lt; 0 : true) :</span>
<span class="line-added">+                             &quot;Incorrect error relationships&quot;;</span>
<span class="line-added">+                         // &amp;&amp; could check for digit conditions for ties too</span>
<span class="line-added">+                         return true;</span>
<span class="line-added">+ </span>
<span class="line-added">+                 default: // Definition of UNNECESSARY already verified.</span>
<span class="line-added">+                     return true;</span>
<span class="line-added">+                 }</span>
<span class="line-added">+             }</span>
<span class="line-added">+         }</span>
<span class="line-added">+ </span>
<span class="line-added">+         private static boolean squareRootZeroResultAssertions(BigDecimal input,</span>
<span class="line-added">+                                                               BigDecimal result,</span>
<span class="line-added">+                                                               MathContext mc) {</span>
<span class="line-added">+             return input.compareTo(ZERO) == 0;</span>
<span class="line-added">+         }</span>
<span class="line-added">+     }</span>
  }
<span class="line-added">+ </span>
</pre>
<center><a href="LongValueExactTests.java.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="../BigInteger/LargeValueExceptions.java.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames test/jdk/java/awt/Focus/ContainerFocusAutoTransferTest/ContainerFocusAutoTransferTest.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
<a name="1" id="anc1"></a><span class="line-modified">  2  * Copyright (c) 2008, 2018, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 /*
 25   @test
 26   @key headful
 27   @bug       6607170
 28   @summary   Tests for focus-auto-transfer.
<a name="2" id="anc2"></a>
 29   @library   ../../regtesthelpers
 30   @build     Util
 31   @run       main ContainerFocusAutoTransferTest
 32 */
 33 
<a name="3" id="anc3"></a>
 34 import java.awt.AWTEvent;
 35 import java.awt.Component;
 36 import java.awt.ComponentOrientation;
 37 import java.awt.DefaultKeyboardFocusManager;
 38 import java.awt.KeyboardFocusManager;
 39 import java.awt.Robot;
 40 import java.awt.Color;
 41 import java.awt.FlowLayout;
 42 import java.awt.Toolkit;
 43 import java.awt.event.AWTEventListener;
 44 import java.awt.event.FocusEvent;
 45 import java.awt.event.WindowEvent;
 46 import javax.swing.JButton;
 47 import javax.swing.JFrame;
 48 import javax.swing.JPanel;
 49 import test.java.awt.regtesthelpers.Util;
 50 
<a name="4" id="anc4"></a><span class="line-modified"> 51 public class ContainerFocusAutoTransferTest {</span>
 52     Robot robot;
 53     TestFrame frame;
 54     KeyboardFocusManager kfm;
 55     enum TestCase {
 56         REMOVAL { public String toString() { return &quot;removal&quot;; } },
 57         HIDING { public String toString() { return &quot;hiding&quot;; } },
 58         DISABLING { public String toString() { return &quot;disabling&quot;; } },
 59         DEFOCUSING { public String toString() { return &quot;defocusing&quot;; } };
 60         public abstract String toString();
 61     };
 62 
 63     public static void main(String[] args) {
 64         ContainerFocusAutoTransferTest app = new ContainerFocusAutoTransferTest();
 65         app.init();
 66         app.start();
 67     }
 68 
 69     public void init() {
 70         robot = Util.createRobot();
 71         kfm = KeyboardFocusManager.getCurrentKeyboardFocusManager();
 72         Toolkit.getDefaultToolkit().addAWTEventListener(new AWTEventListener() {
 73             public void eventDispatched(AWTEvent event) {
 74                 System.out.println(&quot;--&gt; &quot; + event);
 75             }
 76         }, FocusEvent.FOCUS_EVENT_MASK | WindowEvent.WINDOW_FOCUS_EVENT_MASK);
 77     }
 78 
 79     public void start() {
 80         System.out.println(&quot;*** TEST #1 ***&quot;);
 81         test(TestCase.HIDING);
 82 
 83         System.out.println(&quot;*** TEST #2 ***&quot;);
 84         test(TestCase.REMOVAL);
 85 
 86         System.out.println(&quot;*** TEST #3 ***&quot;);
 87         test3(TestCase.DISABLING);
 88 
 89         System.out.println(&quot;*** TEST #4 ***&quot;);
 90         test3(TestCase.DEFOCUSING);
 91 
 92         System.out.println(&quot;*** TEST #5 ***&quot;);
 93         test4();
 94 
 95         System.out.println(&quot;Test passed.&quot;);
 96     }
 97 
 98     void test(final TestCase t) {
 99         showFrame();
100         test1(t); // Test for correct auto-transfer
101         test2(t); // Test for clearing focus
102     }
103 
104     void test1(final TestCase t) {
105         Runnable action = new Runnable() {
106             public void run() {
107                 KeyboardFocusManager.setCurrentKeyboardFocusManager(new TestKFM());
108                 if (t == TestCase.REMOVAL) {
109                     frame.remove(frame.panel0);
110 
111                 } else if (t == TestCase.HIDING) {
112                     frame.panel0.setVisible(false);
113                 }
114                 frame.repaint();
115             }
116         };
117         if (!Util.trackFocusGained(frame.b3, action, 2000, false)) {
118             throw new TestFailedException(t + &quot;: focus wasn&#39;t transfered as expected!&quot;);
119         }
120         KeyboardFocusManager.setCurrentKeyboardFocusManager(kfm);
121     }
122 
123     void test2(TestCase t) {
124         frame.setFocusable(false); // exclude it from the focus cycle
125         if (t == TestCase.REMOVAL) {
126             frame.remove(frame.panel1);
127 
128         } else if (t == TestCase.HIDING) {
129             frame.panel1.setVisible(false);
130         }
131         frame.repaint();
132         Util.waitForIdle(robot);
133         if (kfm.getFocusOwner() != null) {
134             throw new TestFailedException(t + &quot;: focus wasn&#39;t cleared!&quot;);
135         }
136     }
137 
138     void test3(final TestCase t) {
139         showFrame();
140         Runnable action = new Runnable() {
141             public void run() {
142                 if (t == TestCase.DISABLING) {
143                     frame.b0.setEnabled(false);
144 
145                 } else if (t == TestCase.DEFOCUSING) {
146                     frame.b0.setFocusable(false);
147                 }
148             }};
149         if (!Util.trackFocusGained(frame.b1, action, 2000, false)) {
150             throw new TestFailedException(t + &quot;: focus wasn&#39;t transfered as expected!&quot;);
151         }
152     }
153 
154     void test4() {
155         showFrame();
156         frame.setFocusableWindowState(false);
157         Util.waitForIdle(robot);
158         if (kfm.getFocusOwner() != null) {
159             throw new TestFailedException(&quot;defocusing the frame: focus wasn&#39;t cleared!&quot;);
160         }
161     }
162 
163     void showFrame() {
164         if (frame != null) {
165             frame.dispose();
166             Util.waitForIdle(robot);
167         }
168         frame = new TestFrame();
169         frame.setVisible(true);
170         Util.waitTillShown(frame);
171 
172         if (!frame.b0.hasFocus()) {
173             Util.clickOnComp(frame.b0, robot);
174             Util.waitForIdle(robot);
175             if (!frame.b0.hasFocus()) {
176                 throw new TestErrorException(&quot;couldn&#39;t set focus on &quot; + frame.b2);
177             }
178         }
179     }
180 
181     class TestKFM extends DefaultKeyboardFocusManager {
182         public boolean dispatchEvent(AWTEvent e) {
183             if (e.getID() == FocusEvent.FOCUS_GAINED) {
184                 System.out.println(e);
185                 Component src = (Component)e.getSource();
186                 if (src == frame.b1 || src == frame.b2) {
187                     throw new TestFailedException(&quot;wrong focus transfer on removal!&quot;);
188                 }
189             }
190             return super.dispatchEvent(e);
191         }
192     }
193 }
194 
195 class TestFrame extends JFrame {
196     public JPanel panel0 = new JPanel();
197     public JPanel panel1 = new JPanel();
198     public JButton b0 = new JButton(&quot;b0&quot;);
199     public JButton b1 = new JButton(&quot;b1&quot;);
200     public JButton b2 = new JButton(&quot;b2&quot;);
201     public JButton b3 = new JButton(&quot;b3&quot;);
202     public JButton b4 = new JButton(&quot;b4&quot;);
203 
204     public TestFrame() {
205         super(&quot;TestFrame&quot;);
206 
207         // The change of the orientation and the reverse order of
208         // adding the buttons to the panel is because in Container.removeNotify()
209         // the child components are removed in the reverse order.
210         // We want that the focus owner (b0) would be removed first and
211         // that the next traversable component would be b1.
212         panel0.setComponentOrientation(ComponentOrientation.RIGHT_TO_LEFT);
213         panel0.add(b2);
214         panel0.add(b1);
215         panel0.add(b0);
216 
217         panel1.add(b3);
218         panel1.add(b4);
219 
220         setLayout(new FlowLayout());
221         add(panel0);
222         add(panel1);
223         pack();
224 
225         panel0.setBackground(Color.red);
226         panel1.setBackground(Color.blue);
227     }
228 }
229 
230 // Thrown when the behavior being verified is found wrong.
231 class TestFailedException extends RuntimeException {
232     TestFailedException(String msg) {
233         super(&quot;Test failed: &quot; + msg);
234     }
235 }
236 
237 // Thrown when an error not related to the behavior being verified is encountered.
238 class TestErrorException extends RuntimeException {
239     TestErrorException(String msg) {
240         super(&quot;Unexpected error: &quot; + msg);
241     }
242 }
<a name="5" id="anc5"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="5" type="hidden" />
</body>
</html>
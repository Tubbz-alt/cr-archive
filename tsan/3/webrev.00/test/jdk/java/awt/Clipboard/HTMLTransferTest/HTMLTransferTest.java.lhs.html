<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames test/jdk/java/awt/Clipboard/HTMLTransferTest/HTMLTransferTest.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (c) 2015, 2018, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 /*
<a name="1" id="anc1"></a>

 25   @bug 6392086 8014725
<a name="2" id="anc2"></a><span class="line-modified"> 26   @summary Tests basic DnD functionality in an applet</span>
<span class="line-modified"> 27   @author Alexey Utkin, Semyon Sadetsky</span>
<span class="line-modified"> 28   @run applet HTMLTransferTest.html</span>
 29 */
 30 
<a name="3" id="anc3"></a><span class="line-removed"> 31 /**</span>
<span class="line-removed"> 32  * HTMLTransferTest.java</span>
<span class="line-removed"> 33  *</span>
<span class="line-removed"> 34  * summary: tests that HTMLs of all supported native HTML formats</span>
<span class="line-removed"> 35  *          are transfered properly</span>
<span class="line-removed"> 36  */</span>
<span class="line-removed"> 37 </span>
<span class="line-removed"> 38 import java.applet.Applet;</span>
 39 import java.awt.*;
 40 import java.awt.datatransfer.*;
 41 import java.io.*;
 42 
<a name="4" id="anc4"></a><span class="line-modified"> 43 </span>
<span class="line-removed"> 44 public class HTMLTransferTest extends Applet {</span>
 45     public static final int CODE_NOT_RETURNED = 100;
 46     public static final int CODE_CONSUMER_TEST_FAILED = 101;
 47     public static final int CODE_FAILURE = 102;
 48     public static DataFlavor[] HTMLFlavors = null;
 49     public static DataFlavor SyncFlavor = null;
 50     static {
 51         try{
 52             HTMLFlavors = new DataFlavor[] {
 53                 new DataFlavor(&quot;text/html; document=selection; Class=&quot; + InputStream.class.getName() + &quot;; charset=UTF-8&quot;),
 54                 new DataFlavor(&quot;text/html; document=selection; Class=&quot; + String.class.getName() + &quot;; charset=UTF-8&quot;)
 55             };
 56             SyncFlavor = new DataFlavor(
 57                 &quot;application/x-java-serialized-object; class=&quot;
 58                 + SyncMessage.class.getName()
 59                 + &quot;; charset=UTF-8&quot;
 60             );
 61         }catch(Exception e){
 62             e.printStackTrace();
 63         }
 64     }
 65 
 66     private THTMLProducer imPr;
 67     private int returnCode = CODE_NOT_RETURNED;
 68 
<a name="5" id="anc5"></a>





 69     public void init() {
 70         initImpl();
 71 
 72     } // init()
 73 
 74     private void initImpl() {
 75         imPr = new THTMLProducer();
 76         imPr.begin();
 77     }
 78 
 79 
 80     public void start() {
 81         try {
 82             String stFormats = &quot;&quot;;
 83 
 84             String iniMsg = &quot;Testing formats from the list:\n&quot;;
 85             for (int i = 0; i &lt; HTMLTransferTest.HTMLFlavors.length; i++) {
 86                 stFormats += &quot;\&quot;&quot; + HTMLTransferTest.HTMLFlavors[i].getMimeType() + &quot;\&quot;\n&quot;;
 87             }
 88             System.out.println(iniMsg + stFormats);
 89             System.err.println(&quot;===&gt;&quot; + iniMsg + stFormats);
 90 
 91             String javaPath = System.getProperty(&quot;java.home&quot;, &quot;&quot;);
 92             String cmd = javaPath + File.separator + &quot;bin&quot; + File.separator
 93                 + &quot;java -cp &quot; + System.getProperty(&quot;test.classes&quot;, &quot;.&quot;) +
 94                 //+ &quot;-Xdebug -Xrunjdwp:transport=dt_socket,server=y,suspend=y,address=8000 &quot;
 95                 &quot; THTMLConsumer&quot;
 96                 //+ stFormats
 97                 ;
 98 
 99             Process process = Runtime.getRuntime().exec(cmd);
100             ProcessResults pres = ProcessResults.doWaitFor(process);
101             returnCode = pres.exitValue;
102 
103             if (pres.stderr != null &amp;&amp; pres.stderr.length() &gt; 0) {
104                 System.err.println(&quot;========= Child VM System.err ========&quot;);
105                 System.err.print(pres.stderr);
106                 System.err.println(&quot;======================================&quot;);
107             }
108 
109             if (pres.stdout != null &amp;&amp; pres.stdout.length() &gt; 0) {
110                 System.err.println(&quot;========= Child VM System.out ========&quot;);
111                 System.err.print(pres.stdout);
112                 System.err.println(&quot;======================================&quot;);
113             }
114         } catch (Throwable e) {
115             e.printStackTrace();
116             //returnCode equals CODE_NOT_RETURNED
117         }
118 
119         switch (returnCode) {
120         case CODE_NOT_RETURNED:
121             System.err.println(&quot;Child VM: failed to start&quot;);
122             break;
123         case CODE_FAILURE:
124             System.err.println(&quot;Child VM: abnormal termination&quot;);
125             break;
126         case CODE_CONSUMER_TEST_FAILED:
127             throw new RuntimeException(&quot;test failed: HTMLs in some &quot; +
128                 &quot;native formats are not transferred properly: &quot; +
129                 &quot;see output of child VM&quot;);
130         default:
131             boolean failed = false;
132             String passedFormats = &quot;&quot;;
133             String failedFormats = &quot;&quot;;
134 
135             for (int i = 0; i &lt; imPr.passedArray.length; i++) {
136                if (imPr.passedArray[i]) {
137                    passedFormats += HTMLTransferTest.HTMLFlavors[i].getMimeType() + &quot; &quot;;
138                } else {
139                    failed = true;
140                    failedFormats += HTMLTransferTest.HTMLFlavors[i].getMimeType() + &quot; &quot;;
141                }
142             }
143             if (failed) {
144                 throw new RuntimeException(
145                     &quot;test failed: HTMLs in following &quot;
146                     + &quot;native formats are not transferred properly: &quot;
147                     + failedFormats
148                 );
149             } else {
150                 System.err.println(
151                     &quot;HTMLs in following native formats are &quot;
152                     + &quot;transferred properly: &quot;
153                     + passedFormats
154                 );
155             }
156         }
157 
158     } // start()
159 
160 } // class HTMLTransferTest
161 
162 class SyncMessage implements Serializable {
163     String msg;
164 
165     public SyncMessage(String sync) {
166         this.msg = sync;
167     }
168 
169     @Override
170     public boolean equals(Object obj) {
171         return this.msg.equals(((SyncMessage)obj).msg);
172     }
173 
174     @Override
175     public String toString() {
176         return msg;
177     }
178 }
179 
180 class ProcessResults {
181     public int exitValue;
182     public String stdout;
183     public String stderr;
184 
185     public ProcessResults() {
186         exitValue = -1;
187         stdout = &quot;&quot;;
188         stderr = &quot;&quot;;
189     }
190 
191     /**
192      * Method to perform a &quot;wait&quot; for a process and return its exit value.
193      * This is a workaround for &lt;code&gt;Process.waitFor()&lt;/code&gt; never returning.
194      */
195     public static ProcessResults doWaitFor(Process p) {
196         ProcessResults pres = new ProcessResults();
197 
198         InputStream in = null;
199         InputStream err = null;
200 
201         try {
202             in = p.getInputStream();
203             err = p.getErrorStream();
204 
205             boolean finished = false;
206 
207             while (!finished) {
208                 try {
209                     while (in.available() &gt; 0) {
210                         pres.stdout += (char)in.read();
211                     }
212                     while (err.available() &gt; 0) {
213                         pres.stderr += (char)err.read();
214                     }
215                     // Ask the process for its exitValue. If the process
216                     // is not finished, an IllegalThreadStateException
217                     // is thrown. If it is finished, we fall through and
218                     // the variable finished is set to true.
219                     pres.exitValue = p.exitValue();
220                     finished  = true;
221                 }
222                 catch (IllegalThreadStateException e) {
223                     // Process is not finished yet;
224                     // Sleep a little to save on CPU cycles
225                     Thread.currentThread().sleep(500);
226                 }
227             }
228             if (in != null) in.close();
229             if (err != null) err.close();
230         }
231         catch (Throwable e) {
232             System.err.println(&quot;doWaitFor(): unexpected exception&quot;);
233             e.printStackTrace();
234         }
235         return pres;
236     }
237 }
238 
239 
240 abstract class HTMLTransferer implements ClipboardOwner {
241 
242     static final SyncMessage S_PASSED = new SyncMessage(&quot;Y&quot;);
243     static final SyncMessage S_FAILED = new SyncMessage(&quot;N&quot;);
244     static final SyncMessage S_BEGIN = new SyncMessage(&quot;B&quot;);
245     static final SyncMessage S_BEGIN_ANSWER = new SyncMessage(&quot;BA&quot;);
246     static final SyncMessage S_END = new SyncMessage(&quot;E&quot;);
247 
248 
249 
250     Clipboard m_clipboard;
251 
252     HTMLTransferer() {
253         m_clipboard = Toolkit.getDefaultToolkit().getSystemClipboard();
254     }
255 
256 
257     abstract void notifyTransferSuccess(boolean status);
258 
259 
260     static Object createTRInstance(int i) {
261         try{
262             String _htmlText =
263                 &quot;The quick &lt;font color=&#39;#78650d&#39;&gt;brown&lt;/font&gt; &lt;b&gt;mouse&lt;/b&gt; jumped over the lazy &lt;b&gt;cat&lt;/b&gt;.&quot;;
264             switch(i){
265             case 0:
266                 return new ByteArrayInputStream(_htmlText.getBytes(&quot;utf-8&quot;));
267             case 1:
268                 return _htmlText;
269             }
270         }catch(UnsupportedEncodingException e){ e.printStackTrace(); }
271         return null;
272     }
273 
274     static byte[] getContent(InputStream is)
275     {
276         ByteArrayOutputStream tmp = new ByteArrayOutputStream();
277         try{
278             int read;
279             while( -1 != (read = is.read()) ){
280                 tmp.write(read);
281             };
282         } catch( IOException e ) {
283             e.printStackTrace();
284         }
285         return tmp.toByteArray();
286     }
287 
288     static void Dump(byte[] b){
289         System.err.println( new String(b) );
290     };
291 
292     void setClipboardContents(
293         Transferable contents,
294         ClipboardOwner owner
295     ) {
296         synchronized (m_clipboard) {
297             boolean set = false;
298             while (!set) {
299                 try {
300                     m_clipboard.setContents(contents, owner);
301                     set = true;
302                 } catch (IllegalStateException ise) {
303                     try {
304                         Thread.sleep(100);
305                     } catch(InterruptedException e) {
306                         e.printStackTrace();
307                     }
308                 }
309             }
310         }
311     }
312 
313     Transferable getClipboardContents(Object requestor)
314     {
315         synchronized (m_clipboard) {
316             while (true) {
317                 try {
318                     Transferable t = m_clipboard.getContents(requestor);
319                     return t;
320                 } catch (IllegalStateException ise) {
321                     try {
322                         Thread.sleep(100);
323                     } catch (InterruptedException e) {
324                         e.printStackTrace();
325                     }
326                 }
327             }
328         }
329     }
330 
331 }
332 
333 
334 class THTMLProducer extends HTMLTransferer {
335 
336     boolean[] passedArray;
337     int fi = 0; // next format index
338     private boolean isFirstCallOfLostOwnership = true;
339 
340     THTMLProducer() {
341         passedArray = new boolean[HTMLTransferTest.HTMLFlavors.length];
342     }
343 
344     void begin() {
345         setClipboardContents(
346             new HTMLSelection(
347                 HTMLTransferTest.SyncFlavor,
348                 S_BEGIN
349             ),
350             this
351         );
352     }
353 
354     public void lostOwnership(Clipboard cb, Transferable contents) {
355         System.err.println(&quot;{PRODUCER: lost clipboard ownership&quot;);
356         Transferable t = getClipboardContents(null);
357         if (t.isDataFlavorSupported(HTMLTransferTest.SyncFlavor)) {
358             SyncMessage msg = null;
359             // for test going on if t.getTransferData() will throw an exception
360             if (isFirstCallOfLostOwnership) {
361                 isFirstCallOfLostOwnership = false;
362                 msg = S_BEGIN_ANSWER;
363             } else {
364                 msg = S_PASSED;
365             }
366             try {
367                 msg = (SyncMessage)t.getTransferData(HTMLTransferTest.SyncFlavor);
368                 System.err.println(&quot;++received message: &quot; + msg);
369             } catch (Exception e) {
370                 System.err.println(&quot;Can&#39;t getTransferData-message: &quot; + e);
371             }
372             if( msg.equals(S_PASSED) ){
373                 notifyTransferSuccess(true);
374             } else if( msg.equals(S_FAILED) ){
375                 notifyTransferSuccess(false);
376             } else if (!msg.equals(S_BEGIN_ANSWER)) {
377                 throw new RuntimeException(&quot;wrong message in &quot; +
378                     &quot;THTMLProducer.lostOwnership(): &quot; + msg +
379                     &quot;  (possibly due to bug 4683804)&quot;);
380             }
381         } else {
382             throw new RuntimeException(
383                 &quot;DataFlavor.stringFlavor is not &quot;
384                 + &quot;suppurted by transferable in &quot;
385                 + &quot;THTMLProducer.lostOwnership()&quot;
386             );
387         }
388 
389         if (fi &lt; HTMLTransferTest.HTMLFlavors.length) {
390             System.err.println(
391                 &quot;testing native HTML format \&quot;&quot;
392                 + HTMLTransferTest.HTMLFlavors[fi].getMimeType()
393                 + &quot;\&quot;...&quot;
394             );
395             //leaveFormat( HTMLTransferTest.HTMLFlavors[fi].getMimeType() );
396             setClipboardContents(
397                 new HTMLSelection(
398                     HTMLTransferTest.HTMLFlavors[fi],
399                     HTMLTransferer.createTRInstance(fi)
400                 ),
401                 this
402             );
403         } else {
404             setClipboardContents(
405                 new HTMLSelection(
406                     HTMLTransferTest.SyncFlavor,
407                     S_END
408                 ),
409                 null
410             );
411         }
412         System.err.println(&quot;}PRODUCER: lost clipboard ownership&quot;);
413     }
414 
415 
416     void notifyTransferSuccess(boolean status) {
417         passedArray[fi] = status;
418         fi++;
419     }
420 
421 }
422 
423 
424 class THTMLConsumer extends HTMLTransferer
425 {
426     private static final Object LOCK = new Object();
427     private static boolean failed;
428     int fi = 0; // next format index
429 
430     public void lostOwnership(Clipboard cb, Transferable contents) {
431         System.err.println(&quot;{CONSUMER: lost clipboard ownership&quot;);
432         Transferable t = getClipboardContents(null);
433         boolean bContinue = true;
434         if(t.isDataFlavorSupported(HTMLTransferTest.SyncFlavor)) {
435             try {
436                 SyncMessage msg = (SyncMessage)t.getTransferData(HTMLTransferTest.SyncFlavor);
437                 System.err.println(&quot;received message: &quot; + msg);
438                 if(msg.equals(S_END)){
439                     synchronized (LOCK) {
440                         LOCK.notifyAll();
441                     }
442                     bContinue = false;
443                 }
444             } catch (Exception e) {
445                 System.err.println(&quot;Can&#39;t getTransferData-message: &quot; + e);
446             }
447         }
448         if(bContinue){
449             // all HTML formats have been processed
450             System.err.println( &quot;============================================================&quot;);
451             System.err.println( &quot;Put as &quot; + HTMLTransferTest.HTMLFlavors[fi].getMimeType() );
452             boolean bSuccess = false;
453             for(int i = 0; i &lt; HTMLTransferTest.HTMLFlavors.length; ++i) {
454                 System.err.println( &quot;----------------------------------------------------------&quot;);
455                 if( t.isDataFlavorSupported(HTMLTransferTest.HTMLFlavors[i]) ){
456                     Object im = null; //? HTML;
457                     try {
458                        im = t.getTransferData(HTMLTransferTest.HTMLFlavors[i]);
459                        if (im == null) {
460                            System.err.println(&quot;getTransferData returned null&quot;);
461                        } else {
462                             System.err.println( &quot;Extract as &quot; + HTMLTransferTest.HTMLFlavors[i].getMimeType() );
463                             String stIn = &quot;(unknown)&quot;, stOut = &quot;(unknown)&quot;;
464                             switch( i ){
465                             case 0:
466                                 stIn = new String( getContent( (InputStream)HTMLTransferer.createTRInstance(i) ) );
467                                 stOut = new String( getContent((InputStream)im) );
468                                 bSuccess = stIn.equals(stOut);
469                                 break;
470                             case 1:
471                                 stIn = (String)HTMLTransferer.createTRInstance(i);
472                                 stOut = (String)im;
473                                 int head = stOut.indexOf(&quot;&lt;HTML&gt;&lt;BODY&gt;&quot;);
474                                 if (head &gt;= 0) {
475                                     stOut = stOut.substring(head + 12, stOut.length() - 14);
476                                 }
477                                 bSuccess = stIn.equals(stOut);
478                                 break;
479                             default:
480                                 bSuccess = HTMLTransferer.createTRInstance(i).equals(im);
481                                 break;
482                             };
483                             System.err.println(&quot;in :&quot; + stIn);
484                             System.err.println(&quot;out:&quot; + stOut);
485                        };
486                     } catch (Exception e) {
487                         System.err.println(&quot;Can&#39;t getTransferData: &quot; + e);
488                     }
489                     if(!bSuccess)
490                         System.err.println(&quot;transferred DATA is different from initial DATA\n&quot;);
491                 } else {
492                     System.err.println(&quot;Flavor is not supported by transferable:\n&quot;);
493                     DataFlavor[] dfs = t.getTransferDataFlavors();
494                     int ii;
495                     for(ii = 0; ii &lt; dfs.length; ++ii)
496                         System.err.println(&quot;Supported:&quot; + dfs[ii] + &quot;\n&quot;);
497                     dfs = HTMLTransferTest.HTMLFlavors;
498                     for(ii = 0; ii &lt; dfs.length; ++ii)
499                         System.err.println(&quot;Accepted:&quot; + dfs[ii] + &quot;\n&quot; );
500                 }
501             }
502             System.err.println( &quot;----------------------------------------------------------&quot;);
503             notifyTransferSuccess(bSuccess);
504             System.err.println( &quot;============================================================&quot;);
505             ++fi;
506         }
507         System.err.println(&quot;}CONSUMER: lost clipboard ownership&quot;);
508     }
509 
510 
511     void notifyTransferSuccess(boolean status) {
512         System.err.println(
513             &quot;format &quot;
514             + (status
515                 ? &quot;passed&quot;
516                 : &quot;failed&quot;
517             )
518             + &quot;!!!&quot;
519         );
520         setClipboardContents(
521             new HTMLSelection(
522                 HTMLTransferTest.SyncFlavor,
523                 status
524                     ? S_PASSED
525                     : S_FAILED
526             ),
527             this
528         );
529     }
530 
531 
532     public static void main(String[] args) {
533         try {
534             System.err.println(&quot;{CONSUMER: start&quot;);
535             THTMLConsumer ic = new THTMLConsumer();
536             ic.setClipboardContents(
537                 new HTMLSelection(
538                     HTMLTransferTest.SyncFlavor,
539                     S_BEGIN_ANSWER
540                 ),
541                 ic
542             );
543             synchronized (LOCK) {
544                 LOCK.wait();
545             }
546             System.err.println(&quot;}CONSUMER: start&quot;);
547         } catch (Throwable e) {
548             e.printStackTrace();
549             System.exit(HTMLTransferTest.CODE_FAILURE);
550         }
551     }
552 
553 }
554 
555 
556 /**
557  * A &lt;code&gt;Transferable&lt;/code&gt; which implements the capability required
558  * to transfer an &lt;code&gt;HTML&lt;/code&gt;.
559  *
560  * This &lt;code&gt;Transferable&lt;/code&gt; properly supports
561  * &lt;code&gt;HTMLTransferTest.HTMLFlavors&lt;/code&gt;.
562  * and all equivalent flavors.
563  * No other &lt;code&gt;DataFlavor&lt;/code&gt;s are supported.
564  *
565  * @see java.awt.datatransfer.HTMLTransferTest.HTMLFlavors
566  */
567 class HTMLSelection implements Transferable {
568     private DataFlavor m_flavor;
569     private Object m_data;
570 
571     /**
572      * Creates a &lt;code&gt;Transferable&lt;/code&gt; capable of transferring
573      * the specified &lt;code&gt;String&lt;/code&gt;.
574      */
575     public HTMLSelection(
576         DataFlavor flavor,
577         Object data
578     ){
579         m_flavor = flavor;
580         m_data = data;
581     }
582 
583     /**
584      * Returns an array of flavors in which this &lt;code&gt;Transferable&lt;/code&gt;
585      * can provide the data. &lt;code&gt;DataFlavor.stringFlavor&lt;/code&gt;
586      * is properly supported.
587      * Support for &lt;code&gt;DataFlavor.plainTextFlavor&lt;/code&gt; is
588      * &lt;b&gt;deprecated&lt;/b&gt;.
589      *
590      * @return an array of length one, whose element is &lt;code&gt;DataFlavor.
591      *         HTMLTransferTest.HTMLFlavors&lt;/code&gt;
592      */
593     public DataFlavor[] getTransferDataFlavors() {
594         // returning flavors itself would allow client code to modify
595         // our internal behavior
596         return new DataFlavor[]{ m_flavor } ;
597     }
598 
599     /**
600      * Returns whether the requested flavor is supported by this
601      * &lt;code&gt;Transferable&lt;/code&gt;.
602      *
603      * @param flavor the requested flavor for the data
604      * @return true if &lt;code&gt;flavor&lt;/code&gt; is equal to
605      *   &lt;code&gt;HTMLTransferTest.HTMLFlavors&lt;/code&gt;;
606      *   false if &lt;code&gt;flavor&lt;/code&gt;
607      *   is not one of the above flavors
608      * @throws NullPointerException if flavor is &lt;code&gt;null&lt;/code&gt;
609      */
610     public boolean isDataFlavorSupported(DataFlavor flavor) {
611         System.err.println(&quot;Have:&quot; + flavor + &quot; Can:&quot; + m_flavor);
612         if(flavor.equals(m_flavor))
613             return true;
614         return false;
615     }
616 
617     /**
618      * Returns the &lt;code&gt;Transferable&lt;/code&gt;&#39;s data in the requested
619      * &lt;code&gt;DataFlavor&lt;/code&gt; if possible. If the desired flavor is
620      * &lt;code&gt;HTMLTransferTest.HTMLFlavors&lt;/code&gt;, or an equivalent flavor,
621      * the &lt;code&gt;HTML&lt;/code&gt; representing the selection is
622      * returned.
623      *
624      * @param flavor the requested flavor for the data
625      * @return the data in the requested flavor, as outlined above
626      * @throws UnsupportedFlavorException if the requested data flavor is
627      *         not equivalent to &lt;code&gt;HTMLTransferTest.HTMLFlavors&lt;/code&gt;
628      * @throws IOException if an IOException occurs while retrieving the data.
629      *         By default, &lt;code&gt;HTMLSelection&lt;/code&gt; never throws
630      *         this exception, but a subclass may.
631      * @throws NullPointerException if flavor is &lt;code&gt;null&lt;/code&gt;
632      */
633     public Object getTransferData(DataFlavor flavor)
634         throws UnsupportedFlavorException, IOException
635     {
636         if (flavor.equals(m_flavor)) {
637             return (Object)m_data;
638         } else {
639             throw new UnsupportedFlavorException(flavor);
640         }
641     }
642 
643 } // class HTMLSelection
<a name="6" id="anc6"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="6" type="hidden" />
</body>
</html>
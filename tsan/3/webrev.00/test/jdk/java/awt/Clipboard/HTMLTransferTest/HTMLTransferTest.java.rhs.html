<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames test/jdk/java/awt/Clipboard/HTMLTransferTest/HTMLTransferTest.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (c) 2015, 2018, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 /*
<a name="1" id="anc1"></a><span class="line-added"> 25   @test</span>
<span class="line-added"> 26   @key headful</span>
 27   @bug 6392086 8014725
<a name="2" id="anc2"></a><span class="line-modified"> 28   @summary tests that HTMLs of all supported native HTML formats are transfered</span>
<span class="line-modified"> 29            properly</span>
<span class="line-modified"> 30   @run main/othervm HTMLTransferTest</span>
 31 */
 32 
<a name="3" id="anc3"></a>







 33 import java.awt.*;
 34 import java.awt.datatransfer.*;
 35 import java.io.*;
 36 
<a name="4" id="anc4"></a><span class="line-modified"> 37 public class HTMLTransferTest {</span>

 38     public static final int CODE_NOT_RETURNED = 100;
 39     public static final int CODE_CONSUMER_TEST_FAILED = 101;
 40     public static final int CODE_FAILURE = 102;
 41     public static DataFlavor[] HTMLFlavors = null;
 42     public static DataFlavor SyncFlavor = null;
 43     static {
 44         try{
 45             HTMLFlavors = new DataFlavor[] {
 46                 new DataFlavor(&quot;text/html; document=selection; Class=&quot; + InputStream.class.getName() + &quot;; charset=UTF-8&quot;),
 47                 new DataFlavor(&quot;text/html; document=selection; Class=&quot; + String.class.getName() + &quot;; charset=UTF-8&quot;)
 48             };
 49             SyncFlavor = new DataFlavor(
 50                 &quot;application/x-java-serialized-object; class=&quot;
 51                 + SyncMessage.class.getName()
 52                 + &quot;; charset=UTF-8&quot;
 53             );
 54         }catch(Exception e){
 55             e.printStackTrace();
 56         }
 57     }
 58 
 59     private THTMLProducer imPr;
 60     private int returnCode = CODE_NOT_RETURNED;
 61 
<a name="5" id="anc5"></a><span class="line-added"> 62     public static void main(final String[] args) {</span>
<span class="line-added"> 63         HTMLTransferTest app = new HTMLTransferTest();</span>
<span class="line-added"> 64         app.init();</span>
<span class="line-added"> 65         app.start();</span>
<span class="line-added"> 66     }</span>
<span class="line-added"> 67 </span>
 68     public void init() {
 69         initImpl();
 70 
 71     } // init()
 72 
 73     private void initImpl() {
 74         imPr = new THTMLProducer();
 75         imPr.begin();
 76     }
 77 
 78 
 79     public void start() {
 80         try {
 81             String stFormats = &quot;&quot;;
 82 
 83             String iniMsg = &quot;Testing formats from the list:\n&quot;;
 84             for (int i = 0; i &lt; HTMLTransferTest.HTMLFlavors.length; i++) {
 85                 stFormats += &quot;\&quot;&quot; + HTMLTransferTest.HTMLFlavors[i].getMimeType() + &quot;\&quot;\n&quot;;
 86             }
 87             System.out.println(iniMsg + stFormats);
 88             System.err.println(&quot;===&gt;&quot; + iniMsg + stFormats);
 89 
 90             String javaPath = System.getProperty(&quot;java.home&quot;, &quot;&quot;);
 91             String cmd = javaPath + File.separator + &quot;bin&quot; + File.separator
 92                 + &quot;java -cp &quot; + System.getProperty(&quot;test.classes&quot;, &quot;.&quot;) +
 93                 //+ &quot;-Xdebug -Xrunjdwp:transport=dt_socket,server=y,suspend=y,address=8000 &quot;
 94                 &quot; THTMLConsumer&quot;
 95                 //+ stFormats
 96                 ;
 97 
 98             Process process = Runtime.getRuntime().exec(cmd);
 99             ProcessResults pres = ProcessResults.doWaitFor(process);
100             returnCode = pres.exitValue;
101 
102             if (pres.stderr != null &amp;&amp; pres.stderr.length() &gt; 0) {
103                 System.err.println(&quot;========= Child VM System.err ========&quot;);
104                 System.err.print(pres.stderr);
105                 System.err.println(&quot;======================================&quot;);
106             }
107 
108             if (pres.stdout != null &amp;&amp; pres.stdout.length() &gt; 0) {
109                 System.err.println(&quot;========= Child VM System.out ========&quot;);
110                 System.err.print(pres.stdout);
111                 System.err.println(&quot;======================================&quot;);
112             }
113         } catch (Throwable e) {
114             e.printStackTrace();
115             //returnCode equals CODE_NOT_RETURNED
116         }
117 
118         switch (returnCode) {
119         case CODE_NOT_RETURNED:
120             System.err.println(&quot;Child VM: failed to start&quot;);
121             break;
122         case CODE_FAILURE:
123             System.err.println(&quot;Child VM: abnormal termination&quot;);
124             break;
125         case CODE_CONSUMER_TEST_FAILED:
126             throw new RuntimeException(&quot;test failed: HTMLs in some &quot; +
127                 &quot;native formats are not transferred properly: &quot; +
128                 &quot;see output of child VM&quot;);
129         default:
130             boolean failed = false;
131             String passedFormats = &quot;&quot;;
132             String failedFormats = &quot;&quot;;
133 
134             for (int i = 0; i &lt; imPr.passedArray.length; i++) {
135                if (imPr.passedArray[i]) {
136                    passedFormats += HTMLTransferTest.HTMLFlavors[i].getMimeType() + &quot; &quot;;
137                } else {
138                    failed = true;
139                    failedFormats += HTMLTransferTest.HTMLFlavors[i].getMimeType() + &quot; &quot;;
140                }
141             }
142             if (failed) {
143                 throw new RuntimeException(
144                     &quot;test failed: HTMLs in following &quot;
145                     + &quot;native formats are not transferred properly: &quot;
146                     + failedFormats
147                 );
148             } else {
149                 System.err.println(
150                     &quot;HTMLs in following native formats are &quot;
151                     + &quot;transferred properly: &quot;
152                     + passedFormats
153                 );
154             }
155         }
156 
157     } // start()
158 
159 } // class HTMLTransferTest
160 
161 class SyncMessage implements Serializable {
162     String msg;
163 
164     public SyncMessage(String sync) {
165         this.msg = sync;
166     }
167 
168     @Override
169     public boolean equals(Object obj) {
170         return this.msg.equals(((SyncMessage)obj).msg);
171     }
172 
173     @Override
174     public String toString() {
175         return msg;
176     }
177 }
178 
179 class ProcessResults {
180     public int exitValue;
181     public String stdout;
182     public String stderr;
183 
184     public ProcessResults() {
185         exitValue = -1;
186         stdout = &quot;&quot;;
187         stderr = &quot;&quot;;
188     }
189 
190     /**
191      * Method to perform a &quot;wait&quot; for a process and return its exit value.
192      * This is a workaround for &lt;code&gt;Process.waitFor()&lt;/code&gt; never returning.
193      */
194     public static ProcessResults doWaitFor(Process p) {
195         ProcessResults pres = new ProcessResults();
196 
197         InputStream in = null;
198         InputStream err = null;
199 
200         try {
201             in = p.getInputStream();
202             err = p.getErrorStream();
203 
204             boolean finished = false;
205 
206             while (!finished) {
207                 try {
208                     while (in.available() &gt; 0) {
209                         pres.stdout += (char)in.read();
210                     }
211                     while (err.available() &gt; 0) {
212                         pres.stderr += (char)err.read();
213                     }
214                     // Ask the process for its exitValue. If the process
215                     // is not finished, an IllegalThreadStateException
216                     // is thrown. If it is finished, we fall through and
217                     // the variable finished is set to true.
218                     pres.exitValue = p.exitValue();
219                     finished  = true;
220                 }
221                 catch (IllegalThreadStateException e) {
222                     // Process is not finished yet;
223                     // Sleep a little to save on CPU cycles
224                     Thread.currentThread().sleep(500);
225                 }
226             }
227             if (in != null) in.close();
228             if (err != null) err.close();
229         }
230         catch (Throwable e) {
231             System.err.println(&quot;doWaitFor(): unexpected exception&quot;);
232             e.printStackTrace();
233         }
234         return pres;
235     }
236 }
237 
238 
239 abstract class HTMLTransferer implements ClipboardOwner {
240 
241     static final SyncMessage S_PASSED = new SyncMessage(&quot;Y&quot;);
242     static final SyncMessage S_FAILED = new SyncMessage(&quot;N&quot;);
243     static final SyncMessage S_BEGIN = new SyncMessage(&quot;B&quot;);
244     static final SyncMessage S_BEGIN_ANSWER = new SyncMessage(&quot;BA&quot;);
245     static final SyncMessage S_END = new SyncMessage(&quot;E&quot;);
246 
247 
248 
249     Clipboard m_clipboard;
250 
251     HTMLTransferer() {
252         m_clipboard = Toolkit.getDefaultToolkit().getSystemClipboard();
253     }
254 
255 
256     abstract void notifyTransferSuccess(boolean status);
257 
258 
259     static Object createTRInstance(int i) {
260         try{
261             String _htmlText =
262                 &quot;The quick &lt;font color=&#39;#78650d&#39;&gt;brown&lt;/font&gt; &lt;b&gt;mouse&lt;/b&gt; jumped over the lazy &lt;b&gt;cat&lt;/b&gt;.&quot;;
263             switch(i){
264             case 0:
265                 return new ByteArrayInputStream(_htmlText.getBytes(&quot;utf-8&quot;));
266             case 1:
267                 return _htmlText;
268             }
269         }catch(UnsupportedEncodingException e){ e.printStackTrace(); }
270         return null;
271     }
272 
273     static byte[] getContent(InputStream is)
274     {
275         ByteArrayOutputStream tmp = new ByteArrayOutputStream();
276         try{
277             int read;
278             while( -1 != (read = is.read()) ){
279                 tmp.write(read);
280             };
281         } catch( IOException e ) {
282             e.printStackTrace();
283         }
284         return tmp.toByteArray();
285     }
286 
287     static void Dump(byte[] b){
288         System.err.println( new String(b) );
289     };
290 
291     void setClipboardContents(
292         Transferable contents,
293         ClipboardOwner owner
294     ) {
295         synchronized (m_clipboard) {
296             boolean set = false;
297             while (!set) {
298                 try {
299                     m_clipboard.setContents(contents, owner);
300                     set = true;
301                 } catch (IllegalStateException ise) {
302                     try {
303                         Thread.sleep(100);
304                     } catch(InterruptedException e) {
305                         e.printStackTrace();
306                     }
307                 }
308             }
309         }
310     }
311 
312     Transferable getClipboardContents(Object requestor)
313     {
314         synchronized (m_clipboard) {
315             while (true) {
316                 try {
317                     Transferable t = m_clipboard.getContents(requestor);
318                     return t;
319                 } catch (IllegalStateException ise) {
320                     try {
321                         Thread.sleep(100);
322                     } catch (InterruptedException e) {
323                         e.printStackTrace();
324                     }
325                 }
326             }
327         }
328     }
329 
330 }
331 
332 
333 class THTMLProducer extends HTMLTransferer {
334 
335     boolean[] passedArray;
336     int fi = 0; // next format index
337     private boolean isFirstCallOfLostOwnership = true;
338 
339     THTMLProducer() {
340         passedArray = new boolean[HTMLTransferTest.HTMLFlavors.length];
341     }
342 
343     void begin() {
344         setClipboardContents(
345             new HTMLSelection(
346                 HTMLTransferTest.SyncFlavor,
347                 S_BEGIN
348             ),
349             this
350         );
351     }
352 
353     public void lostOwnership(Clipboard cb, Transferable contents) {
354         System.err.println(&quot;{PRODUCER: lost clipboard ownership&quot;);
355         Transferable t = getClipboardContents(null);
356         if (t.isDataFlavorSupported(HTMLTransferTest.SyncFlavor)) {
357             SyncMessage msg = null;
358             // for test going on if t.getTransferData() will throw an exception
359             if (isFirstCallOfLostOwnership) {
360                 isFirstCallOfLostOwnership = false;
361                 msg = S_BEGIN_ANSWER;
362             } else {
363                 msg = S_PASSED;
364             }
365             try {
366                 msg = (SyncMessage)t.getTransferData(HTMLTransferTest.SyncFlavor);
367                 System.err.println(&quot;++received message: &quot; + msg);
368             } catch (Exception e) {
369                 System.err.println(&quot;Can&#39;t getTransferData-message: &quot; + e);
370             }
371             if( msg.equals(S_PASSED) ){
372                 notifyTransferSuccess(true);
373             } else if( msg.equals(S_FAILED) ){
374                 notifyTransferSuccess(false);
375             } else if (!msg.equals(S_BEGIN_ANSWER)) {
376                 throw new RuntimeException(&quot;wrong message in &quot; +
377                     &quot;THTMLProducer.lostOwnership(): &quot; + msg +
378                     &quot;  (possibly due to bug 4683804)&quot;);
379             }
380         } else {
381             throw new RuntimeException(
382                 &quot;DataFlavor.stringFlavor is not &quot;
383                 + &quot;suppurted by transferable in &quot;
384                 + &quot;THTMLProducer.lostOwnership()&quot;
385             );
386         }
387 
388         if (fi &lt; HTMLTransferTest.HTMLFlavors.length) {
389             System.err.println(
390                 &quot;testing native HTML format \&quot;&quot;
391                 + HTMLTransferTest.HTMLFlavors[fi].getMimeType()
392                 + &quot;\&quot;...&quot;
393             );
394             //leaveFormat( HTMLTransferTest.HTMLFlavors[fi].getMimeType() );
395             setClipboardContents(
396                 new HTMLSelection(
397                     HTMLTransferTest.HTMLFlavors[fi],
398                     HTMLTransferer.createTRInstance(fi)
399                 ),
400                 this
401             );
402         } else {
403             setClipboardContents(
404                 new HTMLSelection(
405                     HTMLTransferTest.SyncFlavor,
406                     S_END
407                 ),
408                 null
409             );
410         }
411         System.err.println(&quot;}PRODUCER: lost clipboard ownership&quot;);
412     }
413 
414 
415     void notifyTransferSuccess(boolean status) {
416         passedArray[fi] = status;
417         fi++;
418     }
419 
420 }
421 
422 
423 class THTMLConsumer extends HTMLTransferer
424 {
425     private static final Object LOCK = new Object();
426     private static boolean failed;
427     int fi = 0; // next format index
428 
429     public void lostOwnership(Clipboard cb, Transferable contents) {
430         System.err.println(&quot;{CONSUMER: lost clipboard ownership&quot;);
431         Transferable t = getClipboardContents(null);
432         boolean bContinue = true;
433         if(t.isDataFlavorSupported(HTMLTransferTest.SyncFlavor)) {
434             try {
435                 SyncMessage msg = (SyncMessage)t.getTransferData(HTMLTransferTest.SyncFlavor);
436                 System.err.println(&quot;received message: &quot; + msg);
437                 if(msg.equals(S_END)){
438                     synchronized (LOCK) {
439                         LOCK.notifyAll();
440                     }
441                     bContinue = false;
442                 }
443             } catch (Exception e) {
444                 System.err.println(&quot;Can&#39;t getTransferData-message: &quot; + e);
445             }
446         }
447         if(bContinue){
448             // all HTML formats have been processed
449             System.err.println( &quot;============================================================&quot;);
450             System.err.println( &quot;Put as &quot; + HTMLTransferTest.HTMLFlavors[fi].getMimeType() );
451             boolean bSuccess = false;
452             for(int i = 0; i &lt; HTMLTransferTest.HTMLFlavors.length; ++i) {
453                 System.err.println( &quot;----------------------------------------------------------&quot;);
454                 if( t.isDataFlavorSupported(HTMLTransferTest.HTMLFlavors[i]) ){
455                     Object im = null; //? HTML;
456                     try {
457                        im = t.getTransferData(HTMLTransferTest.HTMLFlavors[i]);
458                        if (im == null) {
459                            System.err.println(&quot;getTransferData returned null&quot;);
460                        } else {
461                             System.err.println( &quot;Extract as &quot; + HTMLTransferTest.HTMLFlavors[i].getMimeType() );
462                             String stIn = &quot;(unknown)&quot;, stOut = &quot;(unknown)&quot;;
463                             switch( i ){
464                             case 0:
465                                 stIn = new String( getContent( (InputStream)HTMLTransferer.createTRInstance(i) ) );
466                                 stOut = new String( getContent((InputStream)im) );
467                                 bSuccess = stIn.equals(stOut);
468                                 break;
469                             case 1:
470                                 stIn = (String)HTMLTransferer.createTRInstance(i);
471                                 stOut = (String)im;
472                                 int head = stOut.indexOf(&quot;&lt;HTML&gt;&lt;BODY&gt;&quot;);
473                                 if (head &gt;= 0) {
474                                     stOut = stOut.substring(head + 12, stOut.length() - 14);
475                                 }
476                                 bSuccess = stIn.equals(stOut);
477                                 break;
478                             default:
479                                 bSuccess = HTMLTransferer.createTRInstance(i).equals(im);
480                                 break;
481                             };
482                             System.err.println(&quot;in :&quot; + stIn);
483                             System.err.println(&quot;out:&quot; + stOut);
484                        };
485                     } catch (Exception e) {
486                         System.err.println(&quot;Can&#39;t getTransferData: &quot; + e);
487                     }
488                     if(!bSuccess)
489                         System.err.println(&quot;transferred DATA is different from initial DATA\n&quot;);
490                 } else {
491                     System.err.println(&quot;Flavor is not supported by transferable:\n&quot;);
492                     DataFlavor[] dfs = t.getTransferDataFlavors();
493                     int ii;
494                     for(ii = 0; ii &lt; dfs.length; ++ii)
495                         System.err.println(&quot;Supported:&quot; + dfs[ii] + &quot;\n&quot;);
496                     dfs = HTMLTransferTest.HTMLFlavors;
497                     for(ii = 0; ii &lt; dfs.length; ++ii)
498                         System.err.println(&quot;Accepted:&quot; + dfs[ii] + &quot;\n&quot; );
499                 }
500             }
501             System.err.println( &quot;----------------------------------------------------------&quot;);
502             notifyTransferSuccess(bSuccess);
503             System.err.println( &quot;============================================================&quot;);
504             ++fi;
505         }
506         System.err.println(&quot;}CONSUMER: lost clipboard ownership&quot;);
507     }
508 
509 
510     void notifyTransferSuccess(boolean status) {
511         System.err.println(
512             &quot;format &quot;
513             + (status
514                 ? &quot;passed&quot;
515                 : &quot;failed&quot;
516             )
517             + &quot;!!!&quot;
518         );
519         setClipboardContents(
520             new HTMLSelection(
521                 HTMLTransferTest.SyncFlavor,
522                 status
523                     ? S_PASSED
524                     : S_FAILED
525             ),
526             this
527         );
528     }
529 
530 
531     public static void main(String[] args) {
532         try {
533             System.err.println(&quot;{CONSUMER: start&quot;);
534             THTMLConsumer ic = new THTMLConsumer();
535             ic.setClipboardContents(
536                 new HTMLSelection(
537                     HTMLTransferTest.SyncFlavor,
538                     S_BEGIN_ANSWER
539                 ),
540                 ic
541             );
542             synchronized (LOCK) {
543                 LOCK.wait();
544             }
545             System.err.println(&quot;}CONSUMER: start&quot;);
546         } catch (Throwable e) {
547             e.printStackTrace();
548             System.exit(HTMLTransferTest.CODE_FAILURE);
549         }
550     }
551 
552 }
553 
554 
555 /**
556  * A &lt;code&gt;Transferable&lt;/code&gt; which implements the capability required
557  * to transfer an &lt;code&gt;HTML&lt;/code&gt;.
558  *
559  * This &lt;code&gt;Transferable&lt;/code&gt; properly supports
560  * &lt;code&gt;HTMLTransferTest.HTMLFlavors&lt;/code&gt;.
561  * and all equivalent flavors.
562  * No other &lt;code&gt;DataFlavor&lt;/code&gt;s are supported.
563  *
564  * @see java.awt.datatransfer.HTMLTransferTest.HTMLFlavors
565  */
566 class HTMLSelection implements Transferable {
567     private DataFlavor m_flavor;
568     private Object m_data;
569 
570     /**
571      * Creates a &lt;code&gt;Transferable&lt;/code&gt; capable of transferring
572      * the specified &lt;code&gt;String&lt;/code&gt;.
573      */
574     public HTMLSelection(
575         DataFlavor flavor,
576         Object data
577     ){
578         m_flavor = flavor;
579         m_data = data;
580     }
581 
582     /**
583      * Returns an array of flavors in which this &lt;code&gt;Transferable&lt;/code&gt;
584      * can provide the data. &lt;code&gt;DataFlavor.stringFlavor&lt;/code&gt;
585      * is properly supported.
586      * Support for &lt;code&gt;DataFlavor.plainTextFlavor&lt;/code&gt; is
587      * &lt;b&gt;deprecated&lt;/b&gt;.
588      *
589      * @return an array of length one, whose element is &lt;code&gt;DataFlavor.
590      *         HTMLTransferTest.HTMLFlavors&lt;/code&gt;
591      */
592     public DataFlavor[] getTransferDataFlavors() {
593         // returning flavors itself would allow client code to modify
594         // our internal behavior
595         return new DataFlavor[]{ m_flavor } ;
596     }
597 
598     /**
599      * Returns whether the requested flavor is supported by this
600      * &lt;code&gt;Transferable&lt;/code&gt;.
601      *
602      * @param flavor the requested flavor for the data
603      * @return true if &lt;code&gt;flavor&lt;/code&gt; is equal to
604      *   &lt;code&gt;HTMLTransferTest.HTMLFlavors&lt;/code&gt;;
605      *   false if &lt;code&gt;flavor&lt;/code&gt;
606      *   is not one of the above flavors
607      * @throws NullPointerException if flavor is &lt;code&gt;null&lt;/code&gt;
608      */
609     public boolean isDataFlavorSupported(DataFlavor flavor) {
610         System.err.println(&quot;Have:&quot; + flavor + &quot; Can:&quot; + m_flavor);
611         if(flavor.equals(m_flavor))
612             return true;
613         return false;
614     }
615 
616     /**
617      * Returns the &lt;code&gt;Transferable&lt;/code&gt;&#39;s data in the requested
618      * &lt;code&gt;DataFlavor&lt;/code&gt; if possible. If the desired flavor is
619      * &lt;code&gt;HTMLTransferTest.HTMLFlavors&lt;/code&gt;, or an equivalent flavor,
620      * the &lt;code&gt;HTML&lt;/code&gt; representing the selection is
621      * returned.
622      *
623      * @param flavor the requested flavor for the data
624      * @return the data in the requested flavor, as outlined above
625      * @throws UnsupportedFlavorException if the requested data flavor is
626      *         not equivalent to &lt;code&gt;HTMLTransferTest.HTMLFlavors&lt;/code&gt;
627      * @throws IOException if an IOException occurs while retrieving the data.
628      *         By default, &lt;code&gt;HTMLSelection&lt;/code&gt; never throws
629      *         this exception, but a subclass may.
630      * @throws NullPointerException if flavor is &lt;code&gt;null&lt;/code&gt;
631      */
632     public Object getTransferData(DataFlavor flavor)
633         throws UnsupportedFlavorException, IOException
634     {
635         if (flavor.equals(m_flavor)) {
636             return (Object)m_data;
637         } else {
638             throw new UnsupportedFlavorException(flavor);
639         }
640     }
641 
642 } // class HTMLSelection
<a name="6" id="anc6"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="6" type="hidden" />
</body>
</html>
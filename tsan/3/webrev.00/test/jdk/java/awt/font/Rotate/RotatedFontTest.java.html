<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New test/jdk/java/awt/font/Rotate/RotatedFontTest.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2020, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 /*
 25  * @test
 26  * @bug 8224109
 27  * @summary test for consistent text rotation.
 28  */
 29 
 30 import java.awt.Color;
 31 import java.awt.Font;
 32 import java.awt.Graphics2D;
 33 import java.awt.RenderingHints;
 34 import static java.awt.RenderingHints.*;
 35 import java.awt.font.FontRenderContext;
 36 import java.awt.font.GlyphVector;
 37 import java.awt.font.TextLayout;
 38 import java.awt.geom.AffineTransform;
 39 import java.awt.geom.Rectangle2D;
 40 import java.awt.image.BufferedImage;
 41 import java.io.File;
 42 import java.text.AttributedString;
 43 import java.util.Collections;
 44 
 45 import javax.imageio.ImageIO;
 46 
 47 public class RotatedFontTest {
 48 
 49     static final String TEXT = &quot;MMMM&quot;; // Use a short homogenous string.
 50     static final RenderingHints.Key AA_KEY = KEY_TEXT_ANTIALIASING;
 51     static final Object AA_OFF = VALUE_TEXT_ANTIALIAS_OFF;
 52     static final RenderingHints.Key FM_KEY = KEY_FRACTIONALMETRICS;
 53     static final Object FM_ON = VALUE_FRACTIONALMETRICS_ON;
 54     static final Object FM_OFF = VALUE_FRACTIONALMETRICS_OFF;
 55 
 56     static final int DRAWSTRING = 0;
 57     static final int TEXTLAYOUT = 1;
 58     static final int GLYPHVECTOR = 2;
 59     static final int LAYEDOUT_GLYPHVECTOR = 3;
 60 
 61     public static void main(String... args) throws Exception {
 62 
 63         /*
 64          * First verify we have rotation by checking for text colored pixels
 65          * several lines below the baseline of the text.
 66          * Then for subsequent images, check that they are identical to the
 67          * the previous image.
 68          * Do this for both FM on and off.
 69          */
 70         int x = 100;
 71         int y =  10;
 72         AffineTransform gtx = new AffineTransform();
 73 
 74         /* Use monospaced because otherwise an API like TextLayout which
 75          * lays out in a horizontal direction with hints applied might
 76          * sometimes result in a pixel or so difference and cause a
 77          * failure but an effect is not actually a failure of rotation.
 78          * Monospaced needs to be monospaced for this to work, and there
 79          * is also still some risk of this but we can try it.
 80          * This - and fractional metrics is why we use a short string
 81          * and count errors. A long string might have a small difference
 82          * early on that causes a lot of subsequent pixels to be off-by-one.
 83          * This isn&#39;t just theoretical. Despite best efforts the test can
 84          * fail like this.
 85          */
 86         Font font = new Font(Font.MONOSPACED, Font.PLAIN, 20);
 87         String os = System.getProperty(&quot;os.name&quot;).toLowerCase();
 88         if (os.startsWith(&quot;mac&quot;)) {
 89             // Avoid a bug with AAT fonts on macos.
 90             font = new Font(&quot;Courier New&quot;, Font.PLAIN, 20);
 91         }
 92         System.out.println(font);
 93         AffineTransform at = AffineTransform.getRotateInstance(Math.PI / 2);
 94         at.scale(2.0, 1.5);
 95         Font rotFont = font.deriveFont(at);
 96 
 97         test(FM_OFF, x, y, rotFont, gtx, &quot;font-rotation-fm-off.png&quot;);
 98         test(FM_ON, x, y, rotFont, gtx, &quot;font-rotation-fm-on.png&quot;);
 99 
100         // Repeat with rotated graphics, unrotated font
101         gtx = at;
102         x = 10;
103         y = -100;
104         test(FM_OFF, x, y, font, gtx, &quot;gx-rotation-fm-off.png&quot;);
105         test(FM_ON, x, y, font, gtx, &quot;gx-rotation-fm-on.png&quot;);
106 
107         // Repeat with rotated graphics, rotated font
108         gtx = AffineTransform.getRotateInstance(Math.PI / 4);
109         at = AffineTransform.getRotateInstance(Math.PI / 4);
110         at.scale(2.0, 1.5);
111         rotFont = font.deriveFont(at);
112         x = 140;
113         y = -100;
114         test(FM_OFF, x, y, rotFont, gtx, &quot;gx-and-font-rotation-fm-off.png&quot;);
115         test(FM_ON, x, y, rotFont, gtx, &quot;gx-and-font-rotation-fm-on.png&quot;);
116     }
117 
118     static void test(Object fm, int x, int y, Font font,
119                      AffineTransform gtx, String fileName) throws Exception {
120 
121         BufferedImage img = createNewImage();
122         draw(img, DRAWSTRING, TEXT, x, y, font, gtx, fm);
123         ImageIO.write(img, &quot;png&quot;, new File(fileName));
124         checkImageForRotation(img);
125         BufferedImage imageCopy = copyImage(img);
126 
127         draw(img, TEXTLAYOUT, TEXT, x, y, font, gtx, fm);
128         compareImages(imageCopy, img);
129 
130         draw(img, GLYPHVECTOR, TEXT, x, y, font, gtx, fm);
131         compareImages(imageCopy, img);
132 /*
133         This case needs to be fixed before the test can be enabled.
134         See bug 8236451.
135         draw(img, LAYEDOUT_GLYPHVECTOR, TEXT, x, y, font, gtx, fm);
136         compareImages(imageCopy, img);
137 */
138     }
139 
140     private static BufferedImage createNewImage() {
141         BufferedImage img = new BufferedImage(500, 500,
142                                               BufferedImage.TYPE_INT_RGB);
143         Graphics2D g2d = img.createGraphics();
144         g2d.setColor(Color.WHITE);
145         g2d.fillRect(0, 0, img.getWidth(), img.getHeight());
146         g2d.setColor(Color.BLACK);
147         g2d.dispose();
148         return img;
149     }
150 
151     private static void checkImageForRotation(BufferedImage img)
152                        throws Exception {
153      /*
154       * Some expectations are hardwired here.
155       */
156         int firstRowWithBlackPixel = -1;
157         int lastRowWithBlackPixel = -1;
158         int width = img.getWidth(null);
159         int height = img.getHeight(null);
160         for (int x=0; x&lt;width; x++) {
161             for (int y=0; y&lt;height; y++) {
162                 int rgb = img.getRGB(x, y);
163                 if ((rgb &amp; 0xffffff) == 0) {
164                     lastRowWithBlackPixel = y;
165                     if (firstRowWithBlackPixel == -1) {
166                         firstRowWithBlackPixel = y;
167                     }
168                 }
169             }
170         }
171         if ((firstRowWithBlackPixel == -1) ||
172             (lastRowWithBlackPixel - firstRowWithBlackPixel &lt; 40)) {
173             ImageIO.write(img, &quot;png&quot;, new File(&quot;font-rotation-failed.png&quot;));
174                  throw new RuntimeException(&quot;no rotation &quot; +
175                     &quot;first = &quot; + firstRowWithBlackPixel +
176                     &quot; last = &quot; + lastRowWithBlackPixel);
177         }
178     }
179 
180     private static BufferedImage copyImage(BufferedImage origImg) {
181         int w = origImg.getWidth(null);
182         int h = origImg.getHeight(null);
183         BufferedImage newImg = new BufferedImage(w, h, BufferedImage.TYPE_INT_RGB);
184         Graphics2D g2d = newImg.createGraphics();
185         g2d.drawImage(origImg, 0, 0, null);
186         g2d.dispose();
187         return newImg;
188     }
189 
190     private static void compareImages(BufferedImage i1, BufferedImage i2)
191             throws Exception {
192         final int MAXDIFFS = 40;
193         int maxDiffs = MAXDIFFS;
194         int diffCnt = 0;
195         boolean failed = false;
196         int width = i1.getWidth(null);
197         int height = i1.getHeight(null);
198         for (int x=0; x&lt;width; x++) {
199             for (int y=0; y&lt;height; y++) {
200                if (maxDiffs == MAXDIFFS) {
201                    int b1 = i1.getRGB(x, y) &amp; 0x0ff;
202                    int b2 = i2.getRGB(x, y) &amp; 0x0ff;
203                    /* If request to use AA_OFF is ignored,
204                     * too hard, give up.
205                     */
206                    if ((b1 &gt; 0 &amp;&amp; b1 &lt; 255) || (b2 &gt; 0 &amp;&amp; b2 &lt; 255)) {
207                        System.out.println(&quot;AA text, skip.&quot;);
208                        return;
209                    }
210                }
211                if (i1.getRGB(x, y) != i2.getRGB(x, y)) {
212                    /* This is an attempt to mitigate against small
213                     * differences, especially in the fractional metrics case.
214                     */
215                    diffCnt++;
216                    if (diffCnt &gt; maxDiffs) {
217                        failed = true;
218                    }
219                }
220             }
221         }
222         if (failed) {
223             ImageIO.write(i2, &quot;png&quot;, new File(&quot;font-rotation-failed.png&quot;));
224                  throw new RuntimeException(&quot;images differ, diffCnt=&quot;+diffCnt);
225         }
226     }
227 
228     private static void draw(BufferedImage img, int api, String s, int x, int y,
229                              Font font, AffineTransform gtx, Object fm) {
230 
231         System.out.print(&quot;Font:&quot; + font + &quot; GTX:&quot;+ gtx + &quot; FM:&quot; + fm + &quot; using &quot;);
232         Graphics2D g2d = img.createGraphics();
233         g2d.setColor(Color.black);
234         g2d.transform(gtx);
235         g2d.setRenderingHint(AA_KEY, AA_OFF);
236         g2d.setRenderingHint(FM_KEY, fm);
237         g2d.setFont(font);
238         FontRenderContext frc = g2d.getFontRenderContext();
239         GlyphVector gv;
240         Rectangle2D bds = null;
241         char[] chs;
242         switch (api) {
243             case DRAWSTRING:
244                  System.out.println(&quot;drawString&quot;);
245                  g2d.drawString(s, x, y);
246                  chs = s.toCharArray();
247                  bds = font.getStringBounds(chs, 0, chs.length, frc);
248                  System.out.println(&quot;drawString Bounds=&quot;+bds);
249                  break;
250             case TEXTLAYOUT:
251                  System.out.println(&quot;TextLayout&quot;);
252                  TextLayout tl = new TextLayout(s, font, frc);
253                  tl.draw(g2d, (float)x, (float)y);
254                  System.out.println(&quot;TextLayout Bounds=&quot;+tl.getBounds());
255                  System.out.println(&quot;TextLayout Pixel Bounds=&quot;+tl.getPixelBounds(frc, (float)x, (float)y));
256                  break;
257             case GLYPHVECTOR:
258                  System.out.println(&quot;GlyphVector&quot;);
259                  gv = font.createGlyphVector(frc, s);
260                  g2d.drawGlyphVector(gv, (float)x, (float)y);
261                  System.out.println(&quot;Default GlyphVector Logical Bounds=&quot;+gv.getLogicalBounds());
262                  System.out.println(&quot;Default GlyphVector Visual Bounds=&quot;+gv.getVisualBounds());
263                  System.out.println(&quot;Default GlyphVector Pixel Bounds=&quot;+gv.getPixelBounds(frc, (float)x, (float)y));
264                  break;
265             case LAYEDOUT_GLYPHVECTOR:
266                  System.out.println(&quot;Layed out GlyphVector&quot;);
267                  chs = s.toCharArray();
268                  gv = font.layoutGlyphVector(frc, chs, 0, chs.length, 0);
269                  g2d.drawGlyphVector(gv, (float)x, (float)y);
270                  System.out.println(&quot;Layed out GlyphVector Logical Bounds=&quot;+gv.getLogicalBounds());
271                  System.out.println(&quot;Layed out GlyphVector Visual Bounds=&quot;+gv.getVisualBounds());
272                  System.out.println(&quot;Layed out GlyphVector Pixel Bounds=&quot;+gv.getPixelBounds(frc, (float)x, (float)y));
273                  break;
274             default: /* do nothing */
275         }
276         g2d.dispose();
277     }
278 
279 }
    </pre>
  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New test/jdk/java/text/Collator/RuleBasedCollatorTest.java</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 /*
 25  * @test
 26  * @bug 4406815 8222969
 27  * @summary RuleBasedCollatorTest uses very limited but selected test data
 28  *  to test basic functionalities provided by RuleBasedCollator.
 29  * @run testng/othervm RuleBasedCollatorTest
 30  */
 31 
 32 import java.text.CollationElementIterator;
 33 import java.text.CollationKey;
 34 import java.text.RuleBasedCollator;
 35 import java.text.Collator;
 36 import java.text.ParseException;
 37 import java.util.Arrays;
 38 import java.util.Locale;
 39 
 40 import org.testng.annotations.BeforeGroups;
 41 import org.testng.annotations.DataProvider;
 42 import org.testng.annotations.Test;
 43 import org.testng.SkipException;
 44 import static org.testng.Assert.*;
 45 
 46 public class RuleBasedCollatorTest {
 47 
 48     static RuleBasedCollator USC;
 49     static String US_RULES;
 50 
 51     @BeforeGroups(&quot;USC&quot;)
 52     public void setup() {
 53         Collator c = Collator.getInstance(Locale.US);
 54         if (!(c instanceof RuleBasedCollator)) {
 55             throw new SkipException(&quot;skip tests.&quot;);
 56         }
 57         USC = (RuleBasedCollator) c;
 58         US_RULES = USC.getRules();
 59     }
 60 
 61 
 62     @DataProvider(name = &quot;rulesData&quot;)
 63     Object[][] rulesData() {
 64         //Basic Tailor
 65         String BASIC_TAILOR_RULES = &quot;&lt; b=c&lt;\u00e6;A,a&quot;;
 66         String[] BASIC_TAILOR_DATA = {&quot;\u00e6&quot;, &quot;b&quot;, &quot;a&quot;, &quot;c&quot;, &quot;A&quot;};
 67         String[] BASIC_TAILOR_EXPECTED = {&quot;b&quot;, &quot;c&quot;, &quot;\u00e6&quot;, &quot;A&quot;, &quot;a&quot;};
 68 
 69         //Contraction
 70         String CONTRACTION_RULES = US_RULES + &quot;&amp; b &lt; ch ,cH, Ch, CH &lt; c &quot;;
 71         String[] CONTRACTION_DATA = {&quot;b&quot;, &quot;c&quot;, &quot;ch&quot;, &quot;CH&quot;, &quot;Ch&quot;, &quot;cH&quot;};
 72         String[] CONTRACTION_EXPECTED = {&quot;b&quot;, &quot;ch&quot;, &quot;cH&quot;, &quot;Ch&quot;, &quot;CH&quot;, &quot;c&quot;};
 73 
 74         //Expansion
 75         String EXPANSION_RULES = US_RULES + &quot;&amp; ae = \u00e4 &lt; b&quot;;
 76         String[] EXPANSION_DATA = {&quot;ad&quot;, &quot;af&quot;, &quot;\u00e4&quot;};
 77         String[] EXPANSION_EXPECTED = {&quot;ad&quot;, &quot;\u00e4&quot;, &quot;af&quot;};
 78 
 79         //Punctuation
 80         String PUNCTUATION_RULES = US_RULES + &quot;&lt; &#39; &#39; &lt; &#39;-&#39;&quot;;
 81         String[] PUNCTUATION_DATA = {&quot;b-w&quot;, &quot;b-W&quot;, &quot;B-w&quot;, &quot;B-W&quot;, &quot;bW&quot;, &quot;bw&quot;,
 82                 &quot;Bw&quot;, &quot;BW&quot;, &quot;b w&quot;, &quot;b W&quot;, &quot;B w&quot;, &quot;B W&quot;};
 83         String[] PUNCTUATION_EXPECTED = {&quot;bw&quot;, &quot;bW&quot;, &quot;Bw&quot;, &quot;BW&quot;, &quot;b w&quot;, &quot;b W&quot;,
 84                 &quot;B w&quot;, &quot;B W&quot;, &quot;b-w&quot;, &quot;b-W&quot;, &quot;B-w&quot;, &quot;B-W&quot;};
 85 
 86         return new Object[][] {
 87                 {BASIC_TAILOR_RULES, BASIC_TAILOR_DATA, BASIC_TAILOR_EXPECTED},
 88                 {CONTRACTION_RULES, CONTRACTION_DATA, CONTRACTION_EXPECTED},
 89                 {EXPANSION_RULES, EXPANSION_DATA, EXPANSION_EXPECTED},
 90                 {PUNCTUATION_RULES, PUNCTUATION_DATA, PUNCTUATION_EXPECTED}
 91         };
 92     }
 93 
 94     @Test(dataProvider = &quot;rulesData&quot;, groups = &quot;USC&quot;)
 95     public void testRules(String rules, String[] testData, String[] expected)
 96             throws ParseException {
 97         Arrays.sort(testData, new RuleBasedCollator(rules));
 98         assertEquals(testData, expected);
 99 
100     }
101 
102     @DataProvider(name = &quot;FrenchSecondarySort&quot;)
103     Object[][] FrenchSecondarySort() {
104         return new Object[][] {
105                 { &quot;\u0061\u00e1\u0061&quot;, &quot;\u00e1\u0061\u0061&quot;, 1 },
106                 //{&quot;\u0061\u00e1&quot;, &quot;\u00e1\u0041&quot;, 1},  //JDK-4406815
107                 //{&quot;\u00e1\u0041&quot;, &quot;\u0061\u00e1&quot;, -1}, //JDK-4406815
108                 {&quot;\u1ea0a&quot;, &quot;\u1ea2A&quot;, -1}, //case ignore
109                 { &quot;\u1ea0b&quot;, &quot;\u1ea2A&quot;, 1 },  //primary overwrite
110                 { &quot;\u1e15&quot;, &quot;\u1e1d&quot;, -1 },   //ignore sec diacritic
111                 { &quot;a&quot;, &quot;\u1ea1&quot;, -1 } };
112     }
113 
114     @Test(dataProvider = &quot;FrenchSecondarySort&quot;, groups = &quot;USC&quot;)
115     public void testFrenchSecondarySort(String sData, String tData,
116             int expected) throws ParseException {
117         String french_rule = &quot;@&quot;;
118         String rules = US_RULES + french_rule;
119         RuleBasedCollator rc = new RuleBasedCollator(rules);
120         int result = rc.compare(sData, tData);
121         assertEquals(expected, result);
122     }
123 
124     @DataProvider(name = &quot;ThaiLaoVowelConsonantSwapping&quot;)
125     Object[][] ThaiLaoVowelConsonantSwapping() {
126         return new Object[][] {{&quot;\u0e44\u0e01&quot;, &quot;\u0e40\u0e2e&quot;, -1},//swap
127                 {&quot;\u0e2e\u0e40&quot;, &quot;\u0e01\u0e44&quot;, 1},//no swap
128                 {&quot;\u0e44\u0061&quot;, &quot;\u0e40\u0081&quot;, 1}//no swap
129         };
130     }
131 
132     @Test(dataProvider = &quot;ThaiLaoVowelConsonantSwapping&quot;, groups = &quot;USC&quot;)
133     public void testThaiLaoVowelConsonantSwapping(String sData, String tData,
134             int expected) throws ParseException {
135         String thai_rule = &quot;&amp; Z &lt; \u0e01 &lt; \u0e2e &lt;\u0e40 &lt; \u0e44!&quot;;
136         String rules = US_RULES + thai_rule;
137         RuleBasedCollator rc = new RuleBasedCollator(rules);
138         int result = rc.compare(sData, tData);
139         assertEquals(expected, result);
140     }
141 
142     @Test
143     public void testIgnorableCharacter() throws ParseException {
144         String rule = &quot;=f&lt;a&lt;c&quot;;
145         RuleBasedCollator rc = new RuleBasedCollator(rule);
146         CollationElementIterator iter = rc.getCollationElementIterator(&quot;f&quot;);
147         int element = iter.next();
148         int primary = iter.primaryOrder(element);
149         assertEquals(primary, 0);
150     }
151 
152     @DataProvider(name = &quot;Normalization&quot;)
153     Object[][] Normalization() {
154         return new Object[][] {
155                 //micro sign has no canonical decomp mapping
156                 // 0:NO_Decomposition;
157                 // 1:CANONICAL_Decomposition;
158                 // 2:FULL_Decomposition
159                 {&quot;\u00b5&quot;, &quot;\u03BC&quot;, 0, -1},
160                 {&quot;\u00b5&quot;, &quot;\u03BC&quot;, 1, -1},
161                 {&quot;\u00b5&quot;, &quot;\u03BC&quot;, 2, 0}
162         };
163     }
164 
165     @Test(dataProvider = &quot;Normalization&quot;, groups = &quot;USC&quot;)
166     public void testNormalization(String sData, String tData, int decomp,
167             int result) {
168         RuleBasedCollator rc = (RuleBasedCollator)USC.clone();
169         rc.setDecomposition(decomp);
170         assertEquals(rc.compare(sData, tData), result);
171     }
172 
173     @Test
174     public void testEquality() throws ParseException {
175         String rule1 = &quot;&lt;a=b&quot;;
176         RuleBasedCollator rc1= new RuleBasedCollator(rule1);
177         //test equals()
178         assertTrue(rc1.equals(new RuleBasedCollator(rule1)));
179 
180         //test semantic equality
181         String[] array1 = {&quot;b&quot;, &quot;c&quot;, &quot;a&quot;};
182         String[] array2 = Arrays.copyOf(array1, array1.length);
183         String[] expected = {&quot;b&quot;, &quot;a&quot;, &quot;c&quot;};
184         String rule2 = &quot;&lt;b=a&quot;;
185         RuleBasedCollator rc2= new RuleBasedCollator(rule2);
186 
187         Arrays.sort(array1, rc1);
188         Arrays.sort(array2, rc2);
189         assertEquals(array1, array2);
190         assertEquals(array1, expected);
191     }
192 
193     @Test
194     public void testBasicParsingOrder() throws ParseException {
195         String rule1 = &quot;&lt; a &lt; b &amp; a &lt; c&quot;;
196         String rule2 = &quot;&lt; a &lt; c &amp; a &lt; b&quot;;
197         String rule3 = &quot;&lt; a &lt; b &lt; c&quot;;
198         String s = &quot;abc&quot;;
199         RuleBasedCollator c1 = new RuleBasedCollator(rule1);
200         RuleBasedCollator c2 = new RuleBasedCollator(rule2);
201         RuleBasedCollator c3 = new RuleBasedCollator(rule3);
202         CollationKey k1 = c1.getCollationKey(s);
203         CollationKey k2 = c2.getCollationKey(s);
204         CollationKey k3 = c3.getCollationKey(s);
205         //rule1 should not equals to rule2
206         assertEquals(k1.compareTo(k2) == 0, false);
207 
208         //rule2 should equals to rule3
209         assertEquals(k2.compareTo(k3) == 0, true);
210     }
211 
212     @DataProvider(name = &quot;ParseData&quot;)
213     Object[][] ParseData() {
214         return new Object[][] {
215                 {&quot;&quot;},
216                 {&quot;a &lt; b&quot;},
217                 {&quot;&lt; a-b &lt; c&quot;},
218                 {&quot;&lt; ,a&quot;},
219                 {&quot;&lt; a &lt; b &amp; c &lt; d&quot;}
220         };
221     }
222 
223     @Test(dataProvider = &quot;ParseData&quot;,
224             expectedExceptions = ParseException.class)
225     public void testParseException(String rule) throws ParseException{
226         new RuleBasedCollator(rule);
227     }
228 
229     @Test(expectedExceptions = NullPointerException.class)
230     public void testNullParseException() throws ParseException{
231         new RuleBasedCollator(null);
232     }
233 }
    </pre>
  </body>
</html>
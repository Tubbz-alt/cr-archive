<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff test/jdk/java/text/Format/DecimalFormat/FormatMicroBenchmark.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
<body>
<center><a href="../DateFormat/WeekDateTest.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="../NumberFormat/CurrencyFormat.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>test/jdk/java/text/Format/DecimalFormat/FormatMicroBenchmark.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 70  *  uses internal class sun.misc.FloatingDecimal and its dtoa(double) method to
 71  *  provide digits,  fast-path embeds its own  algorithm for  binary to decimal
 72  *  string conversion.
 73  *
 74  *  FloatingDecimal always converts completely  the passed double to  a string.
 75  *  Fast-path converts  only to the needed digits  since it follows constraints
 76  *  on both the pattern rule,  the  DecimalFormat instance properties, and  the
 77  *  passed double.
 78  *
 79  *  Micro benchmarks below measure  the throughput for formating double  values
 80  *  using NumberFormat.format(double)  call stack.  The  standard DecimalFormat
 81  *  call stack as well as the  fast-path algorithm implementation are sensitive
 82  *  to the nature of the passed double values regarding throughput performance.
 83  *
 84  *  These benchmarks are useful both  for measuring the global performance gain
 85  *  of fast-path and to check that any modification done on fast-path algorithm
 86  *  does not bring any regression in the performance boost of fast-path.
 87  *
 88  *  Note  that these benchmarks  will provide numbers  without any knowledge of
 89  *  the  implementation of DecimalFormat class. So  to check regression any run
<span class="line-modified"> 90  *  should be compared to another reference run with  a previous JDK, wether or</span>
 91  *  not this previous reference JDK contains fast-path implementation.
 92  *
 93  *  The eight benchmarks below are dedicated to measure throughput on different
 94  *  kinds of double that all fall in the fast-path case (all in Integer range):
 95  *
 96  *  - Integer case : used double values are all &quot;integer-like&quot; (ex: -12345.0).
 97  *    This is the benchFormatInteger micro-benchmark.
 98  *
 99  *  - Fractional case : double values are &quot;fractional&quot; (ex: -0.12345).
100  *    This is the benchFormatFractional micro-benchmark.
101  *
102  *  - Small integral case : like Integer case but double values are all limited
103  *    in their magnitude, from -500.0 to 500.0 if the number of iterations N is
104  *    set to 500000.
105  *    This is the benchFormatSmallIntegral micro-benchmark.
106  *
107  *  - Fractional All Nines : doubles values have fractional part that is very
108  *    close to &quot;999&quot; (decimal pattern), or &quot;99&quot; (currency pattern),
109  *    or &quot;0000...&quot;.
110  *    This is the benchFormatFractionalAllNines micro-benchmark.
</pre>
</td>
<td>
<hr />
<pre>
 70  *  uses internal class sun.misc.FloatingDecimal and its dtoa(double) method to
 71  *  provide digits,  fast-path embeds its own  algorithm for  binary to decimal
 72  *  string conversion.
 73  *
 74  *  FloatingDecimal always converts completely  the passed double to  a string.
 75  *  Fast-path converts  only to the needed digits  since it follows constraints
 76  *  on both the pattern rule,  the  DecimalFormat instance properties, and  the
 77  *  passed double.
 78  *
 79  *  Micro benchmarks below measure  the throughput for formating double  values
 80  *  using NumberFormat.format(double)  call stack.  The  standard DecimalFormat
 81  *  call stack as well as the  fast-path algorithm implementation are sensitive
 82  *  to the nature of the passed double values regarding throughput performance.
 83  *
 84  *  These benchmarks are useful both  for measuring the global performance gain
 85  *  of fast-path and to check that any modification done on fast-path algorithm
 86  *  does not bring any regression in the performance boost of fast-path.
 87  *
 88  *  Note  that these benchmarks  will provide numbers  without any knowledge of
 89  *  the  implementation of DecimalFormat class. So  to check regression any run
<span class="line-modified"> 90  *  should be compared to another reference run with  a previous JDK, whether or</span>
 91  *  not this previous reference JDK contains fast-path implementation.
 92  *
 93  *  The eight benchmarks below are dedicated to measure throughput on different
 94  *  kinds of double that all fall in the fast-path case (all in Integer range):
 95  *
 96  *  - Integer case : used double values are all &quot;integer-like&quot; (ex: -12345.0).
 97  *    This is the benchFormatInteger micro-benchmark.
 98  *
 99  *  - Fractional case : double values are &quot;fractional&quot; (ex: -0.12345).
100  *    This is the benchFormatFractional micro-benchmark.
101  *
102  *  - Small integral case : like Integer case but double values are all limited
103  *    in their magnitude, from -500.0 to 500.0 if the number of iterations N is
104  *    set to 500000.
105  *    This is the benchFormatSmallIntegral micro-benchmark.
106  *
107  *  - Fractional All Nines : doubles values have fractional part that is very
108  *    close to &quot;999&quot; (decimal pattern), or &quot;99&quot; (currency pattern),
109  *    or &quot;0000...&quot;.
110  *    This is the benchFormatFractionalAllNines micro-benchmark.
</pre>
</td>
</tr>
</table>
<center><a href="../DateFormat/WeekDateTest.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="../NumberFormat/CurrencyFormat.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames test/jdk/java/time/test/java/time/chrono/TestJapaneseChronology.java</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
<a name="1" id="anc1"></a><span class="line-modified">  2  * Copyright (c) 2013, 2018, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package test.java.time.chrono;
 27 
 28 import java.time.*;
 29 import java.time.chrono.*;
 30 import java.time.temporal.*;
 31 import java.util.List;
 32 import java.util.Locale;
 33 
 34 import org.testng.annotations.DataProvider;
 35 import org.testng.annotations.Test;
 36 import static org.testng.Assert.assertEquals;
<a name="2" id="anc2"></a>
 37 
 38 /**
 39  * Tests for the Japanese chronology
 40  */
 41 @Test
 42 public class TestJapaneseChronology {
 43     private static final JapaneseChronology JAPANESE = JapaneseChronology.INSTANCE;
 44     private static final Locale jaJPJP = Locale.forLanguageTag(&quot;ja-JP-u-ca-japanese&quot;);
 45 
 46     @DataProvider(name=&quot;transitions&quot;)
 47     Object[][] transitionData() {
 48         return new Object[][] {
 49             // Japanese era, yearOfEra, month, dayOfMonth, gregorianYear
 50             { JapaneseEra.MEIJI,      6,  1,  1, 1873 },
 51             // Meiji-Taisho transition isn&#39;t accurate. 1912-07-30 is the last day of Meiji
 52             // and the first day of Taisho.
 53             { JapaneseEra.MEIJI,     45,  7, 29, 1912 },
 54             { JapaneseEra.TAISHO,     1,  7, 30, 1912 },
 55             // Same for Taisho-Showa transition. 1926-12-25 is the last day of Taisho
 56             // and the first day of Showa.
 57             { JapaneseEra.TAISHO,    15, 12, 24, 1926 },
 58             { JapaneseEra.SHOWA,      1, 12, 25, 1926 },
 59             { JapaneseEra.SHOWA,     64,  1,  7, 1989 },
 60             { JapaneseEra.HEISEI,     1,  1,  8, 1989 },
 61             { JapaneseEra.HEISEI,    31,  4, 30, 2019 },
<a name="3" id="anc3"></a><span class="line-modified"> 62             { JapaneseEra.of(3),      1,  5,  1, 2019 }, // NEWERA</span>
 63         };
 64     }
 65 
 66     @DataProvider(name=&quot;day_year_data&quot;)
 67     Object[][] dayYearData() {
 68         return new Object[][] {
 69             // Japanese era, yearOfEra, dayOfYear, month, dayOfMonth
 70             { JapaneseEra.MEIJI,  45,  211,  7, 29 },
 71             { JapaneseEra.TAISHO,  1,    1,  7, 30 },
 72             { JapaneseEra.TAISHO,  2,   60,  3,  1 },
 73             { JapaneseEra.TAISHO, 15,  358, 12, 24 },
 74             { JapaneseEra.SHOWA,   1,    1, 12, 25 },
 75             { JapaneseEra.SHOWA,   2,    8,  1,  8 },
 76             { JapaneseEra.SHOWA,  64,    7,  1,  7 },
 77             { JapaneseEra.HEISEI,  1,    1,  1,  8 },
 78             { JapaneseEra.HEISEI,  2,    8,  1,  8 },
 79             { JapaneseEra.HEISEI, 31,  120,  4, 30 },
<a name="4" id="anc4"></a><span class="line-modified"> 80             { JapaneseEra.of(3),   1,    1,  5,  1 }, // NEWERA</span>
 81         };
 82     }
 83 
 84     @DataProvider(name=&quot;range_data&quot;)
 85     Object[][] rangeData() {
 86         return new Object[][] {
 87             // field, minSmallest, minLargest, maxSmallest, maxLargest
 88             { ChronoField.ERA,         -1, -1, 3, 3},
 89             { ChronoField.YEAR_OF_ERA, 1, 1, 15, 999999999-2019}, // depends on the current era
 90             { ChronoField.DAY_OF_YEAR, 1, 1, 7, 366},
 91             { ChronoField.YEAR, 1873, 1873, 999999999, 999999999},
 92         };
 93     }
 94 
 95     @DataProvider(name=&quot;invalid_dates&quot;)
 96     Object[][] invalidDatesData() {
 97         return new Object[][] {
 98             // Japanese era, yearOfEra, month, dayOfMonth
 99             { JapaneseEra.MEIJI,      6,  2, 29 },
100             { JapaneseEra.MEIJI,     45,  7, 30 },
101             { JapaneseEra.MEIJI,     46,  1,  1 },
102             { JapaneseEra.TAISHO,     1,  7, 29 },
103             { JapaneseEra.TAISHO,     2,  2, 29 },
104             { JapaneseEra.TAISHO,    15, 12, 25 },
105             { JapaneseEra.TAISHO,    16,  1,  1 },
106             { JapaneseEra.SHOWA,      1, 12, 24 },
107             { JapaneseEra.SHOWA,      2,  2, 29 },
108             { JapaneseEra.SHOWA,     64,  1,  8 },
109             { JapaneseEra.SHOWA,     65,  1,  1 },
110             { JapaneseEra.HEISEI,     1,  1,  7 },
111             { JapaneseEra.HEISEI,     1,  2, 29 },
112             { JapaneseEra.HEISEI,    31,  5,  1 },
<a name="5" id="anc5"></a><span class="line-modified">113             { JapaneseEra.of(3),      1,  4, 30 }, // NEWERA</span>
<span class="line-modified">114             { JapaneseEra.of(3), Year.MAX_VALUE,  12, 31 }, // NEWERA</span>
115         };
116     }
117 
118     @DataProvider(name=&quot;invalid_eraYear&quot;)
119     Object[][] invalidEraYearData() {
120         return new Object[][] {
121             // Japanese era, yearOfEra
122             { JapaneseEra.MEIJI,     -1 },
123             { JapaneseEra.MEIJI,      0 },
124             { JapaneseEra.MEIJI,     46 },
125             { JapaneseEra.TAISHO,    -1 },
126             { JapaneseEra.TAISHO,     0 },
127             { JapaneseEra.TAISHO,    16 },
128             { JapaneseEra.SHOWA,     -1 },
129             { JapaneseEra.SHOWA,      0 },
130             { JapaneseEra.SHOWA,     65 },
131             { JapaneseEra.HEISEI,    -1 },
132             { JapaneseEra.HEISEI,     0 },
133             { JapaneseEra.HEISEI,    32 },
<a name="6" id="anc6"></a><span class="line-modified">134             { JapaneseEra.of(3),     -1 }, // NEWERA</span>
<span class="line-modified">135             { JapaneseEra.of(3),      0 }, // NEWERA</span>
<span class="line-modified">136             { JapaneseEra.of(3), Year.MAX_VALUE }, // NEWERA</span>
137         };
138     }
139 
140     @DataProvider(name=&quot;invalid_day_year_data&quot;)
141     Object[][] invalidDayYearData() {
142         return new Object[][] {
143             // Japanese era, yearOfEra, dayOfYear
144             { JapaneseEra.MEIJI,  45, 240 },
145             { JapaneseEra.TAISHO,  1, 365 },
146             { JapaneseEra.TAISHO,  2, 366 },
147             { JapaneseEra.TAISHO, 15, 359 },
148             { JapaneseEra.SHOWA,   1,   8 },
149             { JapaneseEra.SHOWA,   2, 366 },
150             { JapaneseEra.SHOWA,  64,   8 },
151             { JapaneseEra.HEISEI,  1, 360 },
152             { JapaneseEra.HEISEI,  2, 366 },
153             { JapaneseEra.HEISEI, 31, 121 },
<a name="7" id="anc7"></a><span class="line-modified">154             { JapaneseEra.of(3),   1, 246 }, // NEWERA</span>
<span class="line-modified">155             { JapaneseEra.of(3),   2, 367 }, // NEWERA</span>













156         };
157     }
158 
159     @Test
160     public void test_ofLocale() {
161         // must be a singleton
162         assertEquals(Chronology.ofLocale(jaJPJP) == JAPANESE, true);
163     }
164 
165     @Test(dataProvider=&quot;transitions&quot;)
166     public void test_transitions(JapaneseEra era, int yearOfEra, int month, int dayOfMonth, int gregorianYear) {
167         assertEquals(JAPANESE.prolepticYear(era, yearOfEra), gregorianYear);
168 
169         JapaneseDate jdate1 = JapaneseDate.of(era, yearOfEra, month, dayOfMonth);
170         JapaneseDate jdate2 = JapaneseDate.of(gregorianYear, month, dayOfMonth);
171         assertEquals(jdate1, jdate2);
172     }
173 
174     @Test(dataProvider=&quot;range_data&quot;)
175     public void test_range(ChronoField field, int minSmallest, int minLargest, int maxSmallest, int maxLargest) {
176         ValueRange range = JAPANESE.range(field);
177         assertEquals(range.getMinimum(), minSmallest);
178         assertEquals(range.getLargestMinimum(), minLargest);
179         assertEquals(range.getSmallestMaximum(), maxSmallest);
180         assertEquals(range.getMaximum(), maxLargest);
181     }
182 
183     @Test(dataProvider=&quot;day_year_data&quot;)
184     public void test_firstDayOfEra(JapaneseEra era, int yearOfEra, int dayOfYear, int month, int dayOfMonth) {
185         JapaneseDate date1 = JAPANESE.dateYearDay(era, yearOfEra, dayOfYear);
186         JapaneseDate date2 = JAPANESE.date(era, yearOfEra, month, dayOfMonth);
187         assertEquals(date1, date2);
188     }
189 
190     @Test(dataProvider=&quot;invalid_dates&quot;, expectedExceptions=DateTimeException.class)
191     public void test_invalidDate(JapaneseEra era, int yearOfEra, int month, int dayOfMonth) {
192         JapaneseDate jdate = JapaneseDate.of(era, yearOfEra, month, dayOfMonth);
193         System.out.printf(&quot;No DateTimeException with %s %d.%02d.%02d%n&quot;, era, yearOfEra, month, dayOfMonth);
194     }
195 
196     @Test(dataProvider=&quot;invalid_eraYear&quot;, expectedExceptions=DateTimeException.class)
197     public void test_invalidEraYear(JapaneseEra era, int yearOfEra) {
198         int year = JAPANESE.prolepticYear(era, yearOfEra);
199         System.out.printf(&quot;No DateTimeException with era=%s, year=%d%n&quot;, era, yearOfEra);
200     }
201 
202     @Test(dataProvider=&quot;invalid_day_year_data&quot;, expectedExceptions=DateTimeException.class)
203     public void test_invalidDayYear(JapaneseEra era, int yearOfEra, int dayOfYear) {
204         JapaneseDate date = JAPANESE.dateYearDay(era, yearOfEra, dayOfYear);
205         System.out.printf(&quot;No DateTimeException with era=%s, year=%d, dayOfYear=%d%n&quot;, era, yearOfEra, dayOfYear);
206     }
<a name="8" id="anc8"></a>








207 }
<a name="9" id="anc9"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="9" type="hidden" />
</body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New test/jdk/java/time/test/java/time/format/TestLocalizedOffsetPrinterParser.java</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 /*
 25  * @test
 26  * @bug 8154520
 27  * @summary This test verifies that the localized text for &quot;GMT&quot; from CLDR is
 28  * applied/recognized during printing/parsing timestamps. For example, the
 29  * localized text for &quot;GMT&quot; on some particular locale may be &quot;UTC&quot;, and the
 30  * resulting formatted string should have UTC+&lt;offset&gt; (instead of GMT+&lt;offset&gt;).
 31  * Since the test relies on CLDR data, the &quot;expected&quot; text in the test data may
 32  * require to be modified in accordance with changes to CLDR, if any.
 33  * @modules jdk.localedata
 34  */
 35 
 36 package test.java.time.format;
 37 
 38 import static org.testng.Assert.assertEquals;
 39 
 40 import java.time.LocalDateTime;
 41 import java.time.OffsetDateTime;
 42 import java.time.ZoneOffset;
 43 import java.time.ZonedDateTime;
 44 import java.time.format.DateTimeFormatter;
 45 import java.time.format.DateTimeFormatterBuilder;
 46 import java.time.format.TextStyle;
 47 import java.util.Locale;
 48 import java.util.Objects;
 49 
 50 import org.testng.annotations.DataProvider;
 51 import org.testng.annotations.Test;
 52 
 53 /**
 54  * Test DateTimeFormatterBuilder.appendOffset().
 55  */
 56 @Test
 57 public class TestLocalizedOffsetPrinterParser {
 58 
 59     private static final LocalDateTime DT_2012_06_30_12_30_40 = LocalDateTime.of(2012, 6, 30, 12, 30, 40);
 60 
 61     private static final Locale LOCALE_GA = new Locale(&quot;ga&quot;);
 62 
 63     @DataProvider(name=&quot;print_localized_custom_locale&quot;)
 64     Object[][] data_print_localized_custom_locale() {
 65         return new Object[][] {
 66                 {TextStyle.FULL, DT_2012_06_30_12_30_40, ZoneOffset.UTC, LOCALE_GA, &quot;MAG&quot;},
 67                 {TextStyle.SHORT, DT_2012_06_30_12_30_40, ZoneOffset.ofHours(1), LOCALE_GA, &quot;MAG+1&quot;},
 68                 {TextStyle.FULL, DT_2012_06_30_12_30_40, ZoneOffset.ofHours(-1), LOCALE_GA, &quot;MAG-01:00&quot;}
 69         };
 70     }
 71 
 72     @Test(dataProvider=&quot;print_localized_custom_locale&quot;)
 73     public void test_print_localized_custom_locale(TextStyle style, LocalDateTime ldt, ZoneOffset offset, Locale locale, String expected) {
 74 
 75         Objects.requireNonNull(locale, &quot;Locale must not be null&quot;);
 76 
 77         OffsetDateTime odt = OffsetDateTime.of(ldt, offset);
 78         ZonedDateTime zdt = ldt.atZone(offset);
 79 
 80         DateTimeFormatter f = new DateTimeFormatterBuilder().appendLocalizedOffset(style).toFormatter(locale);
 81         assertEquals(f.format(odt), expected);
 82         assertEquals(f.format(zdt), expected);
 83         assertEquals(f.parse(expected, ZoneOffset::from), offset);
 84 
 85         if (style == TextStyle.FULL) {
 86             f = new DateTimeFormatterBuilder().appendPattern(&quot;ZZZZ&quot;).toFormatter(locale);
 87             assertEquals(f.format(odt), expected);
 88             assertEquals(f.format(zdt), expected);
 89             assertEquals(f.parse(expected, ZoneOffset::from), offset);
 90 
 91             f = new DateTimeFormatterBuilder().appendPattern(&quot;OOOO&quot;).toFormatter(locale);
 92             assertEquals(f.format(odt), expected);
 93             assertEquals(f.format(zdt), expected);
 94             assertEquals(f.parse(expected, ZoneOffset::from), offset);
 95         }
 96 
 97         if (style == TextStyle.SHORT) {
 98             f = new DateTimeFormatterBuilder().appendPattern(&quot;O&quot;).toFormatter(locale);
 99             assertEquals(f.format(odt), expected);
100             assertEquals(f.format(zdt), expected);
101             assertEquals(f.parse(expected, ZoneOffset::from), offset);
102         }
103 
104     }
105 
106 }
    </pre>
  </body>
</html>
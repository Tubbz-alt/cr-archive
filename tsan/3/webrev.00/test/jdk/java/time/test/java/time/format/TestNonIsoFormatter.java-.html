<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old test/jdk/java/time/test/java/time/format/TestNonIsoFormatter.java</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2013, 2018, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 /*
 25  *
 26  * @test
 27  * @bug 8206120
 28  * @modules jdk.localedata
 29  */
 30 
 31 package test.java.time.format;
 32 
 33 import static org.testng.Assert.assertEquals;
 34 
 35 import java.time.LocalDate;
 36 import java.time.chrono.ChronoLocalDate;
 37 import java.time.chrono.Chronology;
 38 import java.time.chrono.HijrahChronology;
 39 import java.time.chrono.IsoChronology;
 40 import java.time.chrono.JapaneseChronology;
 41 import java.time.chrono.MinguoChronology;
 42 import java.time.chrono.ThaiBuddhistChronology;
 43 import java.time.format.DecimalStyle;
 44 import java.time.format.DateTimeFormatter;
 45 import java.time.format.DateTimeFormatterBuilder;
 46 import java.time.format.DateTimeParseException;
 47 import java.time.format.FormatStyle;
 48 import java.time.format.ResolverStyle;
 49 import java.time.format.TextStyle;
 50 import java.time.temporal.TemporalAccessor;
 51 import java.time.temporal.TemporalQueries;
 52 import java.util.Locale;
 53 
 54 import org.testng.annotations.BeforeMethod;
 55 import org.testng.annotations.DataProvider;
 56 import org.testng.annotations.Test;
 57 
 58 /**
 59  * Test DateTimeFormatter with non-ISO chronology.
 60  *
 61  * Strings in test data are all dependent on CLDR data which may change
 62  * in future CLDR releases.
 63  */
 64 @Test
 65 public class TestNonIsoFormatter {
 66     private static final Chronology ISO8601 = IsoChronology.INSTANCE;
 67     private static final Chronology JAPANESE = JapaneseChronology.INSTANCE;
 68     private static final Chronology HIJRAH = HijrahChronology.INSTANCE;
 69     private static final Chronology MINGUO = MinguoChronology.INSTANCE;
 70     private static final Chronology BUDDHIST = ThaiBuddhistChronology.INSTANCE;
 71 
 72     private static final LocalDate IsoDate = LocalDate.of(2013, 2, 11);
 73 
 74     private static final Locale ARABIC = new Locale(&quot;ar&quot;);
 75     private static final Locale thTH = new Locale(&quot;th&quot;, &quot;TH&quot;);
 76     private static final Locale thTHTH = Locale.forLanguageTag(&quot;th-TH-u-nu-thai&quot;);
 77     private static final Locale jaJPJP = Locale.forLanguageTag(&quot;ja-JP-u-ca-japanese&quot;);
 78 
 79     @BeforeMethod
 80     public void setUp() {
 81     }
 82 
 83     @DataProvider(name=&quot;format_data&quot;)
 84     Object[][] formatData() {
 85         return new Object[][] {
 86             // Chronology, Format Locale, Numbering Locale, ChronoLocalDate, expected string
 87             { JAPANESE, Locale.JAPANESE, Locale.JAPANESE, JAPANESE.date(IsoDate),
 88               &quot;\u5e73\u621025\u5e742\u670811\u65e5\u6708\u66dc\u65e5&quot; }, // Japanese Heisei 25-02-11
 89             { HIJRAH, ARABIC, ARABIC, HIJRAH.date(IsoDate),
 90               &quot;\u0627\u0644\u0627\u062b\u0646\u064a\u0646\u060c \u0661 \u0631\u0628\u064a\u0639 &quot;
 91               + &quot;\u0627\u0644\u0622\u062e\u0631 \u0661\u0664\u0663\u0664 \u0647\u0640&quot; }, // Hijrah AH 1434-04-01 (Mon)
 92             { MINGUO, Locale.TAIWAN, Locale.TAIWAN, MINGUO.date(IsoDate),
 93               &quot;\u6c11\u570b102\u5e742\u670811\u65e5 \u661f\u671f\u4e00&quot; }, // Minguo ROC 102-02-11 (Mon)
 94             { BUDDHIST, thTH, thTH, BUDDHIST.date(IsoDate),
 95               &quot;\u0e27\u0e31\u0e19\u0e08\u0e31\u0e19\u0e17\u0e23\u0e4c\u0e17\u0e35\u0e48&quot;
 96               + &quot; 11 \u0e01\u0e38\u0e21\u0e20\u0e32\u0e1e\u0e31\u0e19\u0e18\u0e4c&quot;
 97               + &quot; \u0e1e.\u0e28. 2556&quot; }, // ThaiBuddhist BE 2556-02-11
 98             { BUDDHIST, thTH, thTHTH, BUDDHIST.date(IsoDate),
 99               &quot;\u0e27\u0e31\u0e19\u0e08\u0e31\u0e19\u0e17\u0e23\u0e4c\u0e17\u0e35\u0e48 \u0e51\u0e51 &quot;
100               + &quot;\u0e01\u0e38\u0e21\u0e20\u0e32\u0e1e\u0e31\u0e19\u0e18\u0e4c \u0e1e.\u0e28. &quot;
101               + &quot;\u0e52\u0e55\u0e55\u0e56&quot; }, // ThaiBuddhist BE 2556-02-11 (with Thai digits)
102         };
103     }
104 
105     @DataProvider(name=&quot;invalid_text&quot;)
106     Object[][] invalidText() {
107         return new Object[][] {
108             // TODO: currently fixed Chronology and Locale.
109             // line commented out, as S64.01.09 seems like a reasonable thing to parse
110             // (era &quot;S&quot; ended on S64.01.07, but a little leniency is a good thing
111 //            { &quot;\u662d\u548c64\u5e741\u67089\u65e5\u6708\u66dc\u65e5&quot; }, // S64.01.09 (Mon)
112             { &quot;\u662d\u548c65\u5e741\u67081\u65e5\u6708\u66dc\u65e5&quot; }, // S65.01.01 (Mon)
113         };
114     }
115 
116     @DataProvider(name=&quot;chrono_names&quot;)
117     Object[][] chronoNamesData() {
118         return new Object[][] {
119             // Chronology, Locale, Chronology Name
120             { ISO8601,  Locale.ENGLISH, &quot;ISO&quot; },    // No data in CLDR; Use Id.
121             { BUDDHIST, Locale.ENGLISH, &quot;Buddhist Calendar&quot; },
122             { HIJRAH,   Locale.ENGLISH, &quot;Islamic Calendar (Umm al-Qura)&quot; },
123             { JAPANESE, Locale.ENGLISH, &quot;Japanese Calendar&quot; },
124             { MINGUO,   Locale.ENGLISH, &quot;Minguo Calendar&quot; },
125 
126             { ISO8601,  Locale.JAPANESE, &quot;ISO&quot; },    // No data in CLDR; Use Id.
127             { JAPANESE, Locale.JAPANESE, &quot;\u548c\u66a6&quot; },
128             { BUDDHIST, Locale.JAPANESE, &quot;\u4ecf\u66a6&quot; },
129 
130             { ISO8601,  thTH, &quot;ISO&quot; },    // No data in CLDR; Use Id.
131             { JAPANESE, thTH, &quot;\u0e1b\u0e0f\u0e34\u0e17\u0e34\u0e19\u0e0d\u0e35\u0e48\u0e1b\u0e38\u0e48\u0e19&quot; },
132             { BUDDHIST, thTH, &quot;\u0e1b\u0e0f\u0e34\u0e17\u0e34\u0e19\u0e1e\u0e38\u0e17\u0e18&quot; },
133 
134             { HIJRAH,   ARABIC, &quot;\u0627\u0644\u062a\u0642\u0648\u064a\u0645 &quot;
135                                 + &quot;\u0627\u0644\u0625\u0633\u0644\u0627\u0645\u064a &quot;
136                                 + &quot;(\u0623\u0645 \u0627\u0644\u0642\u0631\u0649)&quot; },
137         };
138     }
139 
140     @DataProvider(name=&quot;lenient_eraYear&quot;)
141     Object[][] lenientEraYear() {
142         return new Object[][] {
143             // Chronology, lenient era/year, strict era/year
144             { JAPANESE, &quot;Meiji 123&quot;, &quot;Heisei 2&quot; },
145             { JAPANESE, &quot;Showa 65&quot;, &quot;Heisei 2&quot; },
146             { JAPANESE, &quot;Heisei 32&quot;, &quot;NewEra 2&quot; }, // NewEra
147         };
148     }
149 
150     @Test(dataProvider=&quot;format_data&quot;)
151     public void test_formatLocalizedDate(Chronology chrono, Locale formatLocale, Locale numberingLocale,
152                                          ChronoLocalDate date, String expected) {
153         DateTimeFormatter dtf = DateTimeFormatter.ofLocalizedDate(FormatStyle.FULL)
154             .withChronology(chrono).withLocale(formatLocale)
155             .withDecimalStyle(DecimalStyle.of(numberingLocale));
156         String text = dtf.format(date);
157         assertEquals(text, expected);
158     }
159 
160     @Test(dataProvider=&quot;format_data&quot;)
161     public void test_parseLocalizedText(Chronology chrono, Locale formatLocale, Locale numberingLocale,
162                                         ChronoLocalDate expected, String text) {
163         DateTimeFormatter dtf = DateTimeFormatter.ofLocalizedDate(FormatStyle.FULL)
164             .withChronology(chrono).withLocale(formatLocale)
165             .withDecimalStyle(DecimalStyle.of(numberingLocale));
166         TemporalAccessor temporal = dtf.parse(text);
167         ChronoLocalDate date = chrono.date(temporal);
168         assertEquals(date, expected);
169     }
170 
171     @Test(dataProvider=&quot;invalid_text&quot;, expectedExceptions=DateTimeParseException.class)
172     public void test_parseInvalidText(String text) {
173         DateTimeFormatter dtf = DateTimeFormatter.ofLocalizedDate(FormatStyle.FULL)
174             .withChronology(JAPANESE).withLocale(Locale.JAPANESE);
175         dtf.parse(text);
176     }
177 
178     @Test(dataProvider=&quot;chrono_names&quot;)
179     public void test_chronoNames(Chronology chrono, Locale locale, String expected) {
180         DateTimeFormatter dtf = new DateTimeFormatterBuilder().appendChronologyText(TextStyle.SHORT)
181             .toFormatter(locale);
182         String text = dtf.format(chrono.dateNow());
183         assertEquals(text, expected);
184         TemporalAccessor ta = dtf.parse(text);
185         Chronology cal = ta.query(TemporalQueries.chronology());
186         assertEquals(cal, chrono);
187     }
188 
189     @Test(dataProvider=&quot;lenient_eraYear&quot;)
190     public void test_lenientEraYear(Chronology chrono, String lenient, String strict) {
191         String mdStr = &quot;-01-01&quot;;
192         DateTimeFormatter dtf = new DateTimeFormatterBuilder()
193             .appendPattern(&quot;GGGG y-M-d&quot;)
194             .toFormatter(Locale.ROOT)
195             .withChronology(chrono);
196         DateTimeFormatter dtfLenient = dtf.withResolverStyle(ResolverStyle.LENIENT);
197         assertEquals(LocalDate.parse(lenient+mdStr, dtfLenient), LocalDate.parse(strict+mdStr, dtf));
198     }
199 }
    </pre>
  </body>
</html>
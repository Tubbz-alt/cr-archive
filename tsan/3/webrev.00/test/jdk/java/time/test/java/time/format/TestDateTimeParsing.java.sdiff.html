<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff test/jdk/java/time/test/java/time/format/TestDateTimeParsing.java</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="../chrono/TestUmmAlQuraChronology.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="TestDateTimeTextProviderWithLocale.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>test/jdk/java/time/test/java/time/format/TestDateTimeParsing.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2014, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
</pre>
<hr />
<pre>
 42  *    and/or other materials provided with the distribution.
 43  *
 44  *  * Neither the name of JSR-310 nor the names of its contributors
 45  *    may be used to endorse or promote products derived from this software
 46  *    without specific prior written permission.
 47  *
 48  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 49  * &quot;AS IS&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 50  * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 51  * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR
 52  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 53  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 54  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 55  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 56  * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 57  * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 58  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 59  */
 60 package test.java.time.format;
 61 

 62 import static java.time.temporal.ChronoField.EPOCH_DAY;

 63 import static java.time.temporal.ChronoField.INSTANT_SECONDS;
 64 import static java.time.temporal.ChronoField.MICRO_OF_SECOND;
 65 import static java.time.temporal.ChronoField.MILLI_OF_SECOND;
 66 import static java.time.temporal.ChronoField.NANO_OF_SECOND;
 67 import static java.time.temporal.ChronoField.OFFSET_SECONDS;
 68 import static java.time.temporal.ChronoField.SECOND_OF_DAY;

 69 import static org.testng.Assert.assertEquals;
 70 
 71 import java.time.DateTimeException;
 72 import java.time.Instant;
 73 import java.time.LocalDateTime;
 74 import java.time.ZoneId;
 75 import java.time.ZoneOffset;
 76 import java.time.ZonedDateTime;
 77 import java.time.format.DateTimeFormatter;
 78 import java.time.format.DateTimeFormatterBuilder;

 79 import java.time.temporal.TemporalAccessor;
 80 
 81 import org.testng.annotations.DataProvider;
 82 import org.testng.annotations.Test;
 83 
 84 /**
<span class="line-modified"> 85  * Test parsing of edge cases.</span>


 86  */
<span class="line-removed"> 87 @Test</span>
 88 public class TestDateTimeParsing {
 89 
 90     private static final ZoneId PARIS = ZoneId.of(&quot;Europe/Paris&quot;);
 91     private static final ZoneOffset OFFSET_0230 = ZoneOffset.ofHoursMinutes(2, 30);
 92 
 93     private static final DateTimeFormatter LOCALFIELDS = new DateTimeFormatterBuilder()
 94         .appendPattern(&quot;yyyy-MM-dd HH:mm:ss&quot;).toFormatter();
 95     private static final DateTimeFormatter LOCALFIELDS_ZONEID = new DateTimeFormatterBuilder()
 96         .appendPattern(&quot;yyyy-MM-dd HH:mm:ss &quot;).appendZoneId().toFormatter();
 97     private static final DateTimeFormatter LOCALFIELDS_OFFSETID = new DateTimeFormatterBuilder()
 98         .appendPattern(&quot;yyyy-MM-dd HH:mm:ss &quot;).appendOffsetId().toFormatter();
 99     private static final DateTimeFormatter LOCALFIELDS_WITH_PARIS = LOCALFIELDS.withZone(PARIS);
100     private static final DateTimeFormatter LOCALFIELDS_WITH_0230 = LOCALFIELDS.withZone(OFFSET_0230);
101     private static final DateTimeFormatter INSTANT = new DateTimeFormatterBuilder()
102         .appendInstant().toFormatter();
103     private static final DateTimeFormatter INSTANT_WITH_PARIS = INSTANT.withZone(PARIS);
104     private static final DateTimeFormatter INSTANT_WITH_0230 = INSTANT.withZone(OFFSET_0230);
105     private static final DateTimeFormatter INSTANT_OFFSETID = new DateTimeFormatterBuilder()
106         .appendInstant().appendLiteral(&#39; &#39;).appendOffsetId().toFormatter();
107     private static final DateTimeFormatter INSTANT_OFFSETSECONDS = new DateTimeFormatterBuilder()
108         .appendInstant().appendLiteral(&#39; &#39;).appendValue(OFFSET_SECONDS).toFormatter();
109     private static final DateTimeFormatter INSTANTSECONDS = new DateTimeFormatterBuilder()
110         .appendValue(INSTANT_SECONDS).toFormatter();
111     private static final DateTimeFormatter INSTANTSECONDS_WITH_PARIS = INSTANTSECONDS.withZone(PARIS);
112     private static final DateTimeFormatter INSTANTSECONDS_NOS = new DateTimeFormatterBuilder()
113         .appendValue(INSTANT_SECONDS).appendLiteral(&#39;.&#39;).appendValue(NANO_OF_SECOND).toFormatter();
114     private static final DateTimeFormatter INSTANTSECONDS_NOS_WITH_PARIS = INSTANTSECONDS_NOS.withZone(PARIS);
115     private static final DateTimeFormatter INSTANTSECONDS_OFFSETSECONDS = new DateTimeFormatterBuilder()
116         .appendValue(INSTANT_SECONDS).appendLiteral(&#39; &#39;).appendValue(OFFSET_SECONDS).toFormatter();
117 



118     @DataProvider(name = &quot;instantZones&quot;)
119     Object[][] data_instantZones() {
120         return new Object[][] {
121             {LOCALFIELDS_ZONEID, &quot;2014-06-30 01:02:03 Europe/Paris&quot;, ZonedDateTime.of(2014, 6, 30, 1, 2, 3, 0, PARIS)},
122             {LOCALFIELDS_ZONEID, &quot;2014-06-30 01:02:03 +02:30&quot;, ZonedDateTime.of(2014, 6, 30, 1, 2, 3, 0, OFFSET_0230)},
123             {LOCALFIELDS_OFFSETID, &quot;2014-06-30 01:02:03 +02:30&quot;, ZonedDateTime.of(2014, 6, 30, 1, 2, 3, 0, OFFSET_0230)},
124             {LOCALFIELDS_WITH_PARIS, &quot;2014-06-30 01:02:03&quot;, ZonedDateTime.of(2014, 6, 30, 1, 2, 3, 0, PARIS)},
125             {LOCALFIELDS_WITH_0230, &quot;2014-06-30 01:02:03&quot;, ZonedDateTime.of(2014, 6, 30, 1, 2, 3, 0, OFFSET_0230)},
126             {INSTANT_WITH_PARIS, &quot;2014-06-30T01:02:03Z&quot;, ZonedDateTime.of(2014, 6, 30, 1, 2, 3, 0, ZoneOffset.UTC).withZoneSameInstant(PARIS)},
127             {INSTANT_WITH_0230, &quot;2014-06-30T01:02:03Z&quot;, ZonedDateTime.of(2014, 6, 30, 1, 2, 3, 0, ZoneOffset.UTC).withZoneSameInstant(OFFSET_0230)},
128             {INSTANT_OFFSETID, &quot;2014-06-30T01:02:03Z +02:30&quot;, ZonedDateTime.of(2014, 6, 30, 1, 2, 3, 0, ZoneOffset.UTC).withZoneSameInstant(OFFSET_0230)},
129             {INSTANT_OFFSETSECONDS, &quot;2014-06-30T01:02:03Z 9000&quot;, ZonedDateTime.of(2014, 6, 30, 1, 2, 3, 0, ZoneOffset.UTC).withZoneSameInstant(OFFSET_0230)},
130             {INSTANTSECONDS_WITH_PARIS, &quot;86402&quot;, Instant.ofEpochSecond(86402).atZone(PARIS)},
131             {INSTANTSECONDS_NOS_WITH_PARIS, &quot;86402.123456789&quot;, Instant.ofEpochSecond(86402, 123456789).atZone(PARIS)},
132             {INSTANTSECONDS_OFFSETSECONDS, &quot;86402 9000&quot;, Instant.ofEpochSecond(86402).atZone(OFFSET_0230)},
133         };
134     }
135 
136     @Test(dataProvider = &quot;instantZones&quot;)
137     public void test_parse_instantZones_ZDT(DateTimeFormatter formatter, String text, ZonedDateTime expected) {
</pre>
<hr />
<pre>
184         LocalDateTime.from(actual);
185     }
186 
187     @Test(dataProvider = &quot;instantNoZone&quot;)
188     public void test_parse_instantNoZone_Instant(DateTimeFormatter formatter, String text, Instant expected) {
189         TemporalAccessor actual = formatter.parse(text);
190         assertEquals(Instant.from(actual), expected);
191     }
192 
193     @Test(dataProvider = &quot;instantNoZone&quot;)
194     public void test_parse_instantNoZone_supported(DateTimeFormatter formatter, String text, Instant expected) {
195         TemporalAccessor actual = formatter.parse(text);
196         assertEquals(actual.isSupported(INSTANT_SECONDS), true);
197         assertEquals(actual.isSupported(EPOCH_DAY), false);
198         assertEquals(actual.isSupported(SECOND_OF_DAY), false);
199         assertEquals(actual.isSupported(NANO_OF_SECOND), true);
200         assertEquals(actual.isSupported(MICRO_OF_SECOND), true);
201         assertEquals(actual.isSupported(MILLI_OF_SECOND), true);
202     }
203 





















204 }
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2014, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
</pre>
<hr />
<pre>
 42  *    and/or other materials provided with the distribution.
 43  *
 44  *  * Neither the name of JSR-310 nor the names of its contributors
 45  *    may be used to endorse or promote products derived from this software
 46  *    without specific prior written permission.
 47  *
 48  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 49  * &quot;AS IS&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 50  * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 51  * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR
 52  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 53  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 54  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 55  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 56  * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 57  * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 58  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 59  */
 60 package test.java.time.format;
 61 
<span class="line-added"> 62 import static java.time.temporal.ChronoField.AMPM_OF_DAY;</span>
 63 import static java.time.temporal.ChronoField.EPOCH_DAY;
<span class="line-added"> 64 import static java.time.temporal.ChronoField.HOUR_OF_AMPM;</span>
 65 import static java.time.temporal.ChronoField.INSTANT_SECONDS;
 66 import static java.time.temporal.ChronoField.MICRO_OF_SECOND;
 67 import static java.time.temporal.ChronoField.MILLI_OF_SECOND;
 68 import static java.time.temporal.ChronoField.NANO_OF_SECOND;
 69 import static java.time.temporal.ChronoField.OFFSET_SECONDS;
 70 import static java.time.temporal.ChronoField.SECOND_OF_DAY;
<span class="line-added"> 71 import static java.util.Locale.US;</span>
 72 import static org.testng.Assert.assertEquals;
 73 
 74 import java.time.DateTimeException;
 75 import java.time.Instant;
 76 import java.time.LocalDateTime;
 77 import java.time.ZoneId;
 78 import java.time.ZoneOffset;
 79 import java.time.ZonedDateTime;
 80 import java.time.format.DateTimeFormatter;
 81 import java.time.format.DateTimeFormatterBuilder;
<span class="line-added"> 82 import java.time.format.DateTimeParseException;</span>
 83 import java.time.temporal.TemporalAccessor;
 84 
 85 import org.testng.annotations.DataProvider;
 86 import org.testng.annotations.Test;
 87 
 88 /**
<span class="line-modified"> 89  * @test</span>
<span class="line-added"> 90  * @summary Test parsing of edge cases.</span>
<span class="line-added"> 91  * @bug 8223773</span>
 92  */

 93 public class TestDateTimeParsing {
 94 
 95     private static final ZoneId PARIS = ZoneId.of(&quot;Europe/Paris&quot;);
 96     private static final ZoneOffset OFFSET_0230 = ZoneOffset.ofHoursMinutes(2, 30);
 97 
 98     private static final DateTimeFormatter LOCALFIELDS = new DateTimeFormatterBuilder()
 99         .appendPattern(&quot;yyyy-MM-dd HH:mm:ss&quot;).toFormatter();
100     private static final DateTimeFormatter LOCALFIELDS_ZONEID = new DateTimeFormatterBuilder()
101         .appendPattern(&quot;yyyy-MM-dd HH:mm:ss &quot;).appendZoneId().toFormatter();
102     private static final DateTimeFormatter LOCALFIELDS_OFFSETID = new DateTimeFormatterBuilder()
103         .appendPattern(&quot;yyyy-MM-dd HH:mm:ss &quot;).appendOffsetId().toFormatter();
104     private static final DateTimeFormatter LOCALFIELDS_WITH_PARIS = LOCALFIELDS.withZone(PARIS);
105     private static final DateTimeFormatter LOCALFIELDS_WITH_0230 = LOCALFIELDS.withZone(OFFSET_0230);
106     private static final DateTimeFormatter INSTANT = new DateTimeFormatterBuilder()
107         .appendInstant().toFormatter();
108     private static final DateTimeFormatter INSTANT_WITH_PARIS = INSTANT.withZone(PARIS);
109     private static final DateTimeFormatter INSTANT_WITH_0230 = INSTANT.withZone(OFFSET_0230);
110     private static final DateTimeFormatter INSTANT_OFFSETID = new DateTimeFormatterBuilder()
111         .appendInstant().appendLiteral(&#39; &#39;).appendOffsetId().toFormatter();
112     private static final DateTimeFormatter INSTANT_OFFSETSECONDS = new DateTimeFormatterBuilder()
113         .appendInstant().appendLiteral(&#39; &#39;).appendValue(OFFSET_SECONDS).toFormatter();
114     private static final DateTimeFormatter INSTANTSECONDS = new DateTimeFormatterBuilder()
115         .appendValue(INSTANT_SECONDS).toFormatter();
116     private static final DateTimeFormatter INSTANTSECONDS_WITH_PARIS = INSTANTSECONDS.withZone(PARIS);
117     private static final DateTimeFormatter INSTANTSECONDS_NOS = new DateTimeFormatterBuilder()
118         .appendValue(INSTANT_SECONDS).appendLiteral(&#39;.&#39;).appendValue(NANO_OF_SECOND).toFormatter();
119     private static final DateTimeFormatter INSTANTSECONDS_NOS_WITH_PARIS = INSTANTSECONDS_NOS.withZone(PARIS);
120     private static final DateTimeFormatter INSTANTSECONDS_OFFSETSECONDS = new DateTimeFormatterBuilder()
121         .appendValue(INSTANT_SECONDS).appendLiteral(&#39; &#39;).appendValue(OFFSET_SECONDS).toFormatter();
122 
<span class="line-added">123     private static final String DTPE_MESSAGE =</span>
<span class="line-added">124         &quot;Invalid value for HourOfAmPm (valid values 0 - 11): 12&quot;;</span>
<span class="line-added">125 </span>
126     @DataProvider(name = &quot;instantZones&quot;)
127     Object[][] data_instantZones() {
128         return new Object[][] {
129             {LOCALFIELDS_ZONEID, &quot;2014-06-30 01:02:03 Europe/Paris&quot;, ZonedDateTime.of(2014, 6, 30, 1, 2, 3, 0, PARIS)},
130             {LOCALFIELDS_ZONEID, &quot;2014-06-30 01:02:03 +02:30&quot;, ZonedDateTime.of(2014, 6, 30, 1, 2, 3, 0, OFFSET_0230)},
131             {LOCALFIELDS_OFFSETID, &quot;2014-06-30 01:02:03 +02:30&quot;, ZonedDateTime.of(2014, 6, 30, 1, 2, 3, 0, OFFSET_0230)},
132             {LOCALFIELDS_WITH_PARIS, &quot;2014-06-30 01:02:03&quot;, ZonedDateTime.of(2014, 6, 30, 1, 2, 3, 0, PARIS)},
133             {LOCALFIELDS_WITH_0230, &quot;2014-06-30 01:02:03&quot;, ZonedDateTime.of(2014, 6, 30, 1, 2, 3, 0, OFFSET_0230)},
134             {INSTANT_WITH_PARIS, &quot;2014-06-30T01:02:03Z&quot;, ZonedDateTime.of(2014, 6, 30, 1, 2, 3, 0, ZoneOffset.UTC).withZoneSameInstant(PARIS)},
135             {INSTANT_WITH_0230, &quot;2014-06-30T01:02:03Z&quot;, ZonedDateTime.of(2014, 6, 30, 1, 2, 3, 0, ZoneOffset.UTC).withZoneSameInstant(OFFSET_0230)},
136             {INSTANT_OFFSETID, &quot;2014-06-30T01:02:03Z +02:30&quot;, ZonedDateTime.of(2014, 6, 30, 1, 2, 3, 0, ZoneOffset.UTC).withZoneSameInstant(OFFSET_0230)},
137             {INSTANT_OFFSETSECONDS, &quot;2014-06-30T01:02:03Z 9000&quot;, ZonedDateTime.of(2014, 6, 30, 1, 2, 3, 0, ZoneOffset.UTC).withZoneSameInstant(OFFSET_0230)},
138             {INSTANTSECONDS_WITH_PARIS, &quot;86402&quot;, Instant.ofEpochSecond(86402).atZone(PARIS)},
139             {INSTANTSECONDS_NOS_WITH_PARIS, &quot;86402.123456789&quot;, Instant.ofEpochSecond(86402, 123456789).atZone(PARIS)},
140             {INSTANTSECONDS_OFFSETSECONDS, &quot;86402 9000&quot;, Instant.ofEpochSecond(86402).atZone(OFFSET_0230)},
141         };
142     }
143 
144     @Test(dataProvider = &quot;instantZones&quot;)
145     public void test_parse_instantZones_ZDT(DateTimeFormatter formatter, String text, ZonedDateTime expected) {
</pre>
<hr />
<pre>
192         LocalDateTime.from(actual);
193     }
194 
195     @Test(dataProvider = &quot;instantNoZone&quot;)
196     public void test_parse_instantNoZone_Instant(DateTimeFormatter formatter, String text, Instant expected) {
197         TemporalAccessor actual = formatter.parse(text);
198         assertEquals(Instant.from(actual), expected);
199     }
200 
201     @Test(dataProvider = &quot;instantNoZone&quot;)
202     public void test_parse_instantNoZone_supported(DateTimeFormatter formatter, String text, Instant expected) {
203         TemporalAccessor actual = formatter.parse(text);
204         assertEquals(actual.isSupported(INSTANT_SECONDS), true);
205         assertEquals(actual.isSupported(EPOCH_DAY), false);
206         assertEquals(actual.isSupported(SECOND_OF_DAY), false);
207         assertEquals(actual.isSupported(NANO_OF_SECOND), true);
208         assertEquals(actual.isSupported(MICRO_OF_SECOND), true);
209         assertEquals(actual.isSupported(MILLI_OF_SECOND), true);
210     }
211 
<span class="line-added">212     // Bug 8223773: validation check for the range of HourOfAmPm in SMART mode.</span>
<span class="line-added">213     // Should throw a DateTimeParseException, as 12 is out of range for HourOfAmPm.</span>
<span class="line-added">214     @Test(expectedExceptions = DateTimeParseException.class)</span>
<span class="line-added">215     public void test_validateHourOfAmPm() {</span>
<span class="line-added">216         try {</span>
<span class="line-added">217             new DateTimeFormatterBuilder()</span>
<span class="line-added">218                 .appendValue(HOUR_OF_AMPM,2)</span>
<span class="line-added">219                 .appendText(AMPM_OF_DAY)</span>
<span class="line-added">220                 .toFormatter(US)</span>
<span class="line-added">221                 .parse(&quot;12PM&quot;);</span>
<span class="line-added">222         } catch (DateTimeParseException e) {</span>
<span class="line-added">223             Throwable cause = e.getCause();</span>
<span class="line-added">224             if (cause == null ||</span>
<span class="line-added">225                 !DTPE_MESSAGE.equals(cause.getMessage())) {</span>
<span class="line-added">226                 throw new RuntimeException(</span>
<span class="line-added">227                     &quot;DateTimeParseException was thrown with different reason: &quot; + e);</span>
<span class="line-added">228             } else {</span>
<span class="line-added">229                 throw e;</span>
<span class="line-added">230             }</span>
<span class="line-added">231         }</span>
<span class="line-added">232     }</span>
233 }
</pre>
</td>
</tr>
</table>
<center><a href="../chrono/TestUmmAlQuraChronology.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="TestDateTimeTextProviderWithLocale.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
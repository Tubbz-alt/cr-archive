<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old test/jdk/java/time/test/java/time/format/TestFractionPrinterParser.java</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2012, 2013, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 /*
 25  * This file is available under and governed by the GNU General Public
 26  * License version 2 only, as published by the Free Software Foundation.
 27  * However, the following notice accompanied the original version of this
 28  * file:
 29  *
 30  * Copyright (c) 2008-2012, Stephen Colebourne &amp; Michael Nascimento Santos
 31  *
 32  * All rights reserved.
 33  *
 34  * Redistribution and use in source and binary forms, with or without
 35  * modification, are permitted provided that the following conditions are met:
 36  *
 37  *  * Redistributions of source code must retain the above copyright notice,
 38  *    this list of conditions and the following disclaimer.
 39  *
 40  *  * Redistributions in binary form must reproduce the above copyright notice,
 41  *    this list of conditions and the following disclaimer in the documentation
 42  *    and/or other materials provided with the distribution.
 43  *
 44  *  * Neither the name of JSR-310 nor the names of its contributors
 45  *    may be used to endorse or promote products derived from this software
 46  *    without specific prior written permission.
 47  *
 48  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 49  * &quot;AS IS&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 50  * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 51  * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR
 52  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 53  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 54  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 55  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 56  * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 57  * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 58  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 59  */
 60 package test.java.time.format;
 61 
 62 import static java.time.temporal.ChronoField.NANO_OF_SECOND;
 63 import static java.time.temporal.ChronoField.SECOND_OF_MINUTE;
 64 import static org.testng.Assert.assertEquals;
 65 import static org.testng.Assert.fail;
 66 
 67 import java.text.ParsePosition;
 68 import java.time.DateTimeException;
 69 import java.time.LocalTime;
 70 import java.time.format.DateTimeFormatter;
 71 import java.time.temporal.TemporalAccessor;
 72 import java.time.temporal.TemporalField;
 73 
 74 import org.testng.annotations.DataProvider;
 75 import org.testng.annotations.Test;
 76 import test.java.time.temporal.MockFieldValue;
 77 
 78 /**
 79  * Test FractionPrinterParser.
 80  */
 81 @Test
 82 public class TestFractionPrinterParser extends AbstractTestPrinterParser {
 83 
 84     private DateTimeFormatter getFormatter(TemporalField field, int minWidth, int maxWidth, boolean decimalPoint) {
 85         return builder.appendFraction(field, minWidth, maxWidth, decimalPoint).toFormatter(locale).withDecimalStyle(decimalStyle);
 86     }
 87 
 88     //-----------------------------------------------------------------------
 89     // print
 90     //-----------------------------------------------------------------------
 91     @Test(expectedExceptions=DateTimeException.class)
 92     public void test_print_emptyCalendrical() throws Exception {
 93         getFormatter(NANO_OF_SECOND, 0, 9, true).formatTo(EMPTY_DTA, buf);
 94     }
 95 
 96     public void test_print_append() throws Exception {
 97         buf.append(&quot;EXISTING&quot;);
 98         getFormatter(NANO_OF_SECOND, 0, 9, true).formatTo(LocalTime.of(12, 30, 40, 3), buf);
 99         assertEquals(buf.toString(), &quot;EXISTING.000000003&quot;);
100     }
101 
102     //-----------------------------------------------------------------------
103     @DataProvider(name=&quot;Nanos&quot;)
104     Object[][] provider_nanos() {
105         return new Object[][] {
106             {0, 9, 0,           &quot;&quot;},
107             {0, 9, 2,           &quot;.000000002&quot;},
108             {0, 9, 20,          &quot;.00000002&quot;},
109             {0, 9, 200,         &quot;.0000002&quot;},
110             {0, 9, 2000,        &quot;.000002&quot;},
111             {0, 9, 20000,       &quot;.00002&quot;},
112             {0, 9, 200000,      &quot;.0002&quot;},
113             {0, 9, 2000000,     &quot;.002&quot;},
114             {0, 9, 20000000,    &quot;.02&quot;},
115             {0, 9, 200000000,   &quot;.2&quot;},
116             {0, 9, 1,           &quot;.000000001&quot;},
117             {0, 9, 12,          &quot;.000000012&quot;},
118             {0, 9, 123,         &quot;.000000123&quot;},
119             {0, 9, 1234,        &quot;.000001234&quot;},
120             {0, 9, 12345,       &quot;.000012345&quot;},
121             {0, 9, 123456,      &quot;.000123456&quot;},
122             {0, 9, 1234567,     &quot;.001234567&quot;},
123             {0, 9, 12345678,    &quot;.012345678&quot;},
124             {0, 9, 123456789,   &quot;.123456789&quot;},
125 
126             {1, 9, 0,           &quot;.0&quot;},
127             {1, 9, 2,           &quot;.000000002&quot;},
128             {1, 9, 20,          &quot;.00000002&quot;},
129             {1, 9, 200,         &quot;.0000002&quot;},
130             {1, 9, 2000,        &quot;.000002&quot;},
131             {1, 9, 20000,       &quot;.00002&quot;},
132             {1, 9, 200000,      &quot;.0002&quot;},
133             {1, 9, 2000000,     &quot;.002&quot;},
134             {1, 9, 20000000,    &quot;.02&quot;},
135             {1, 9, 200000000,   &quot;.2&quot;},
136 
137             {2, 3, 0,           &quot;.00&quot;},
138             {2, 3, 2,           &quot;.000&quot;},
139             {2, 3, 20,          &quot;.000&quot;},
140             {2, 3, 200,         &quot;.000&quot;},
141             {2, 3, 2000,        &quot;.000&quot;},
142             {2, 3, 20000,       &quot;.000&quot;},
143             {2, 3, 200000,      &quot;.000&quot;},
144             {2, 3, 2000000,     &quot;.002&quot;},
145             {2, 3, 20000000,    &quot;.02&quot;},
146             {2, 3, 200000000,   &quot;.20&quot;},
147             {2, 3, 1,           &quot;.000&quot;},
148             {2, 3, 12,          &quot;.000&quot;},
149             {2, 3, 123,         &quot;.000&quot;},
150             {2, 3, 1234,        &quot;.000&quot;},
151             {2, 3, 12345,       &quot;.000&quot;},
152             {2, 3, 123456,      &quot;.000&quot;},
153             {2, 3, 1234567,     &quot;.001&quot;},
154             {2, 3, 12345678,    &quot;.012&quot;},
155             {2, 3, 123456789,   &quot;.123&quot;},
156 
157             {6, 6, 0,           &quot;.000000&quot;},
158             {6, 6, 2,           &quot;.000000&quot;},
159             {6, 6, 20,          &quot;.000000&quot;},
160             {6, 6, 200,         &quot;.000000&quot;},
161             {6, 6, 2000,        &quot;.000002&quot;},
162             {6, 6, 20000,       &quot;.000020&quot;},
163             {6, 6, 200000,      &quot;.000200&quot;},
164             {6, 6, 2000000,     &quot;.002000&quot;},
165             {6, 6, 20000000,    &quot;.020000&quot;},
166             {6, 6, 200000000,   &quot;.200000&quot;},
167             {6, 6, 1,           &quot;.000000&quot;},
168             {6, 6, 12,          &quot;.000000&quot;},
169             {6, 6, 123,         &quot;.000000&quot;},
170             {6, 6, 1234,        &quot;.000001&quot;},
171             {6, 6, 12345,       &quot;.000012&quot;},
172             {6, 6, 123456,      &quot;.000123&quot;},
173             {6, 6, 1234567,     &quot;.001234&quot;},
174             {6, 6, 12345678,    &quot;.012345&quot;},
175             {6, 6, 123456789,   &quot;.123456&quot;},
176        };
177     }
178 
179     @Test(dataProvider=&quot;Nanos&quot;)
180     public void test_print_nanos(int minWidth, int maxWidth, int value, String result) throws Exception {
181         getFormatter(NANO_OF_SECOND,  minWidth, maxWidth, true).formatTo(new MockFieldValue(NANO_OF_SECOND, value), buf);
182         if (result == null) {
183             fail(&quot;Expected exception&quot;);
184         }
185         assertEquals(buf.toString(), result);
186     }
187 
188     @Test(dataProvider=&quot;Nanos&quot;)
189     public void test_print_nanos_noDecimalPoint(int minWidth, int maxWidth, int value, String result) throws Exception {
190         getFormatter(NANO_OF_SECOND,  minWidth, maxWidth, false).formatTo(new MockFieldValue(NANO_OF_SECOND, value), buf);
191         if (result == null) {
192             fail(&quot;Expected exception&quot;);
193         }
194         assertEquals(buf.toString(), (result.startsWith(&quot;.&quot;) ? result.substring(1) : result));
195     }
196 
197     //-----------------------------------------------------------------------
198     @DataProvider(name=&quot;Seconds&quot;)
199     Object[][] provider_seconds() {
200         return new Object[][] {
201             {0, 9, 0,  &quot;&quot;},
202             {0, 9, 3,  &quot;.05&quot;},
203             {0, 9, 6,  &quot;.1&quot;},
204             {0, 9, 9,  &quot;.15&quot;},
205             {0, 9, 12, &quot;.2&quot;},
206             {0, 9, 15, &quot;.25&quot;},
207             {0, 9, 30, &quot;.5&quot;},
208             {0, 9, 45, &quot;.75&quot;},
209 
210             {2, 2, 0,  &quot;.00&quot;},
211             {2, 2, 3,  &quot;.05&quot;},
212             {2, 2, 6,  &quot;.10&quot;},
213             {2, 2, 9,  &quot;.15&quot;},
214             {2, 2, 12, &quot;.20&quot;},
215             {2, 2, 15, &quot;.25&quot;},
216             {2, 2, 30, &quot;.50&quot;},
217             {2, 2, 45, &quot;.75&quot;},
218         };
219     }
220 
221     @Test(dataProvider=&quot;Seconds&quot;)
222     public void test_print_seconds(int minWidth, int maxWidth, int value, String result) throws Exception {
223         getFormatter(SECOND_OF_MINUTE, minWidth, maxWidth, true).formatTo(new MockFieldValue(SECOND_OF_MINUTE, value), buf);
224         if (result == null) {
225             fail(&quot;Expected exception&quot;);
226         }
227         assertEquals(buf.toString(), result);
228     }
229 
230     @Test(dataProvider=&quot;Seconds&quot;)
231     public void test_print_seconds_noDecimalPoint(int minWidth, int maxWidth, int value, String result) throws Exception {
232         getFormatter(SECOND_OF_MINUTE, minWidth, maxWidth, false).formatTo(new MockFieldValue(SECOND_OF_MINUTE, value), buf);
233         if (result == null) {
234             fail(&quot;Expected exception&quot;);
235         }
236         assertEquals(buf.toString(), (result.startsWith(&quot;.&quot;) ? result.substring(1) : result));
237     }
238 
239     //-----------------------------------------------------------------------
240     // parse
241     //-----------------------------------------------------------------------
242     @Test(dataProvider=&quot;Nanos&quot;)
243     public void test_reverseParse(int minWidth, int maxWidth, int value, String result) throws Exception {
244         ParsePosition pos = new ParsePosition(0);
245         int expectedValue = fixParsedValue(maxWidth, value);
246         TemporalAccessor parsed = getFormatter(NANO_OF_SECOND, minWidth, maxWidth, true).parseUnresolved(result, pos);
247         assertEquals(pos.getIndex(), result.length());
248         assertParsed(parsed, NANO_OF_SECOND, value == 0 &amp;&amp; minWidth == 0 ? null : (long) expectedValue);
249     }
250 
251     @Test(dataProvider=&quot;Nanos&quot;)
252     public void test_reverseParse_noDecimalPoint(int minWidth, int maxWidth, int value, String result) throws Exception {
253         ParsePosition pos = new ParsePosition((result.startsWith(&quot;.&quot;) ? 1 : 0));
254         TemporalAccessor parsed = getFormatter(NANO_OF_SECOND, minWidth, maxWidth, false).parseUnresolved(result, pos);
255         assertEquals(pos.getIndex(), result.length());
256         int expectedValue = fixParsedValue(maxWidth, value);
257         assertParsed(parsed, NANO_OF_SECOND, value == 0 &amp;&amp; minWidth == 0 ? null : (long) expectedValue);
258     }
259 
260     @Test(dataProvider=&quot;Nanos&quot;)
261     public void test_reverseParse_followedByNonDigit(int minWidth, int maxWidth, int value, String result) throws Exception {
262         ParsePosition pos = new ParsePosition(0);
263         int expectedValue = fixParsedValue(maxWidth, value);
264         TemporalAccessor parsed = getFormatter(NANO_OF_SECOND, minWidth, maxWidth, true).parseUnresolved(result + &quot; &quot;, pos);
265         assertEquals(pos.getIndex(), result.length());
266         assertParsed(parsed, NANO_OF_SECOND, value == 0 &amp;&amp; minWidth == 0 ? null : (long) expectedValue);
267     }
268 
269 //    @Test(dataProvider=&quot;Nanos&quot;)
270 //    public void test_reverseParse_followedByNonDigit_noDecimalPoint(int minWidth, int maxWidth, int value, String result) throws Exception {
271 //        FractionPrinterParser pp = new FractionPrinterParser(NANO_OF_SECOND, minWidth, maxWidth, false);
272 //        int newPos = pp.parse(parseContext, result + &quot; &quot;, (result.startsWith(&quot;.&quot;) ? 1 : 0));
273 //        assertEquals(newPos, result.length());
274 //        int expectedValue = fixParsedValue(maxWidth, value);
275 //        assertParsed(parseContext, NANO_OF_SECOND, value == 0 &amp;&amp; minWidth == 0 ? null : (long) expectedValue);
276 //    }
277 
278     @Test(dataProvider=&quot;Nanos&quot;)
279     public void test_reverseParse_preceededByNonDigit(int minWidth, int maxWidth, int value, String result) throws Exception {
280         ParsePosition pos = new ParsePosition(1);
281         int expectedValue = fixParsedValue(maxWidth, value);
282         TemporalAccessor parsed = getFormatter(NANO_OF_SECOND, minWidth, maxWidth, true).parseUnresolved(&quot; &quot; + result, pos);
283         assertEquals(pos.getIndex(), result.length() + 1);
284         assertParsed(parsed, NANO_OF_SECOND, value == 0 &amp;&amp; minWidth == 0 ? null : (long) expectedValue);
285     }
286 
287     private int fixParsedValue(int maxWidth, int value) {
288         if (maxWidth &lt; 9) {
289             int power = (int) Math.pow(10, (9 - maxWidth));
290             value = (value / power) * power;
291         }
292         return value;
293     }
294 
295     @Test(dataProvider=&quot;Seconds&quot;)
296     public void test_reverseParse_seconds(int minWidth, int maxWidth, int value, String result) throws Exception {
297         ParsePosition pos = new ParsePosition(0);
298         TemporalAccessor parsed = getFormatter(SECOND_OF_MINUTE, minWidth, maxWidth, true).parseUnresolved(result, pos);
299         assertEquals(pos.getIndex(), result.length());
300         assertParsed(parsed, SECOND_OF_MINUTE, value == 0 &amp;&amp; minWidth == 0 ? null : (long) value);
301     }
302 
303     private void assertParsed(TemporalAccessor parsed, TemporalField field, Long value) {
304         if (value == null) {
305             assertEquals(parsed.isSupported(field), false);
306         } else {
307             assertEquals(parsed.isSupported(field), true);
308             assertEquals(parsed.getLong(field), (long) value);
309         }
310     }
311 
312     //-----------------------------------------------------------------------
313     @DataProvider(name=&quot;ParseNothing&quot;)
314     Object[][] provider_parseNothing() {
315         return new Object[][] {
316             {NANO_OF_SECOND, 3, 6, true, &quot;&quot;, 0, 0},
317             {NANO_OF_SECOND, 3, 6, true, &quot;A&quot;, 0, 0},
318             {NANO_OF_SECOND, 3, 6, true, &quot;.&quot;, 0, 1},
319             {NANO_OF_SECOND, 3, 6, true, &quot;.5&quot;, 0, 1},
320             {NANO_OF_SECOND, 3, 6, true, &quot;.51&quot;, 0, 1},
321             {NANO_OF_SECOND, 3, 6, true, &quot;.A23456&quot;, 0, 1},
322             {NANO_OF_SECOND, 3, 6, true, &quot;.1A3456&quot;, 0, 1},
323         };
324     }
325 
326     @Test(dataProvider = &quot;ParseNothing&quot;)
327     public void test_parse_nothing(TemporalField field, int min, int max, boolean decimalPoint, String text, int pos, int expected) {
328         ParsePosition ppos = new ParsePosition(pos);
329         TemporalAccessor parsed = getFormatter(field, min, max, decimalPoint).parseUnresolved(text, ppos);
330         assertEquals(ppos.getErrorIndex(), expected);
331         assertEquals(parsed, null);
332     }
333 
334     //-----------------------------------------------------------------------
335     public void test_toString() throws Exception {
336         assertEquals(getFormatter(NANO_OF_SECOND, 3, 6, true).toString(), &quot;Fraction(NanoOfSecond,3,6,DecimalPoint)&quot;);
337     }
338 
339     public void test_toString_noDecimalPoint() throws Exception {
340         assertEquals(getFormatter(NANO_OF_SECOND, 3, 6, false).toString(), &quot;Fraction(NanoOfSecond,3,6)&quot;);
341     }
342 
343 }
    </pre>
  </body>
</html>
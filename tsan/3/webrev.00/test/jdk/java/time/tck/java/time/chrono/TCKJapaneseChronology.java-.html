<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old test/jdk/java/time/tck/java/time/chrono/TCKJapaneseChronology.java</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  o Copyright (c) 2012, 2018, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 /*
  27  * Copyright (c) 2008-2012, Stephen Colebourne &amp; Michael Nascimento Santos
  28  *
  29  * All rights reserved.
  30  *
  31  * Redistribution and use in source and binary forms, with or without
  32  * modification, are permitted provided that the following conditions are met:
  33  *
  34  *  * Redistributions of source code must retain the above copyright notice,
  35  *    this list of conditions and the following disclaimer.
  36  *
  37  *  * Redistributions in binary form must reproduce the above copyright notice,
  38  *    this list of conditions and the following disclaimer in the documentation
  39  *    and/or other materials provided with the distribution.
  40  *
  41  *  * Neither the name of JSR-310 nor the names of its contributors
  42  *    may be used to endorse or promote products derived from this software
  43  *    without specific prior written permission.
  44  *
  45  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
  46  * &quot;AS IS&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
  47  * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
  48  * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR
  49  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
  50  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
  51  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
  52  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
  53  * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
  54  * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
  55  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  56  */
  57 package tck.java.time.chrono;
  58 
  59 import static java.time.temporal.ChronoField.DAY_OF_MONTH;
  60 import static java.time.temporal.ChronoField.DAY_OF_YEAR;
  61 import static java.time.temporal.ChronoField.EPOCH_DAY;
  62 import static java.time.temporal.ChronoField.ERA;
  63 import static java.time.temporal.ChronoField.MONTH_OF_YEAR;
  64 import static java.time.temporal.ChronoField.YEAR;
  65 import static java.time.temporal.ChronoField.YEAR_OF_ERA;
  66 import static org.testng.Assert.assertEquals;
  67 import static org.testng.Assert.assertFalse;
  68 import static org.testng.Assert.assertNotEquals;
  69 import static org.testng.Assert.assertTrue;
  70 import static org.testng.Assert.fail;
  71 
  72 import java.time.Clock;
  73 import java.time.DateTimeException;
  74 import java.time.LocalDate;
  75 import java.time.LocalDateTime;
  76 import java.time.Month;
  77 import java.time.Period;
  78 import java.time.Year;
  79 import java.time.ZoneId;
  80 import java.time.ZoneOffset;
  81 import java.time.chrono.ChronoLocalDate;
  82 import java.time.chrono.ChronoPeriod;
  83 import java.time.chrono.Chronology;
  84 import java.time.chrono.Era;
  85 import java.time.chrono.IsoChronology;
  86 import java.time.chrono.JapaneseChronology;
  87 import java.time.chrono.JapaneseDate;
  88 import java.time.chrono.JapaneseEra;
  89 import java.time.chrono.MinguoChronology;
  90 import java.time.chrono.MinguoDate;
  91 import java.time.chrono.ThaiBuddhistChronology;
  92 import java.time.format.ResolverStyle;
  93 import java.time.temporal.ChronoField;
  94 import java.time.temporal.ChronoUnit;
  95 import java.time.temporal.TemporalAdjusters;
  96 import java.time.temporal.TemporalField;
  97 import java.time.temporal.TemporalQueries;
  98 import java.time.temporal.ValueRange;
  99 
 100 import java.util.HashMap;
 101 import java.util.List;
 102 import java.util.Locale;
 103 import java.util.Map;
 104 
 105 import org.testng.Assert;
 106 import org.testng.annotations.DataProvider;
 107 import org.testng.annotations.Test;
 108 
 109 /**
 110  * Test.
 111  */
 112 @Test
 113 public class TCKJapaneseChronology {
 114     private static final int YDIFF_NEWERA = 2018;
 115     private static final int YDIFF_HEISEI = 1988;
 116     private static final int YDIFF_MEIJI = 1867;
 117     private static final int YDIFF_SHOWA = 1925;
 118     private static final int YDIFF_TAISHO = 1911;
 119 
 120     //-----------------------------------------------------------------------
 121     // Chronology.of(String)
 122     //-----------------------------------------------------------------------
 123     @Test
 124     public void test_chrono_byName() {
 125         Chronology c = JapaneseChronology.INSTANCE;
 126         Chronology test = Chronology.of(&quot;Japanese&quot;);
 127         Assert.assertNotNull(test, &quot;The Japanese calendar could not be found byName&quot;);
 128         Assert.assertEquals(test.getId(), &quot;Japanese&quot;, &quot;ID mismatch&quot;);
 129         Assert.assertEquals(test.getCalendarType(), &quot;japanese&quot;, &quot;Type mismatch&quot;);
 130         Assert.assertEquals(test, c);
 131     }
 132 
 133     //-----------------------------------------------------------------------
 134     // Chronology.ofLocale(Locale)
 135     //-----------------------------------------------------------------------
 136     @Test
 137     public void test_chrono_byLocale_fullTag_japaneseCalendarFromJapan() {
 138         Chronology test = Chronology.ofLocale(Locale.forLanguageTag(&quot;ja-JP-u-ca-japanese&quot;));
 139         Assert.assertEquals(test.getId(), &quot;Japanese&quot;);
 140         Assert.assertEquals(test, JapaneseChronology.INSTANCE);
 141     }
 142 
 143     @Test
 144     public void test_chrono_byLocale_fullTag_japaneseCalendarFromElsewhere() {
 145         Chronology test = Chronology.ofLocale(Locale.forLanguageTag(&quot;en-US-u-ca-japanese&quot;));
 146         Assert.assertEquals(test.getId(), &quot;Japanese&quot;);
 147         Assert.assertEquals(test, JapaneseChronology.INSTANCE);
 148     }
 149 
 150     @Test
 151     public void test_chrono_byLocale_oldJP_noVariant() {
 152         Chronology test = Chronology.ofLocale(new Locale(&quot;ja&quot;, &quot;JP&quot;));
 153         Assert.assertEquals(test.getId(), &quot;ISO&quot;);
 154         Assert.assertEquals(test, IsoChronology.INSTANCE);
 155     }
 156 
 157     @Test
 158     public void test_chrono_byLocale_oldJP_variant() {
 159         Chronology test = Chronology.ofLocale(new Locale(&quot;ja&quot;, &quot;JP&quot;, &quot;JP&quot;));
 160         Assert.assertEquals(test.getId(), &quot;Japanese&quot;);
 161         Assert.assertEquals(test, JapaneseChronology.INSTANCE);
 162     }
 163 
 164     @Test
 165     public void test_chrono_byLocale_iso() {
 166         Assert.assertEquals(Chronology.ofLocale(new Locale(&quot;ja&quot;, &quot;JP&quot;)).getId(), &quot;ISO&quot;);
 167         Assert.assertEquals(Chronology.ofLocale(Locale.forLanguageTag(&quot;ja-JP&quot;)).getId(), &quot;ISO&quot;);
 168         Assert.assertEquals(Chronology.ofLocale(Locale.forLanguageTag(&quot;ja-JP-JP&quot;)).getId(), &quot;ISO&quot;);
 169     }
 170 
 171     //-----------------------------------------------------------------------
 172     // creation and cross-checks
 173     //-----------------------------------------------------------------------
 174     @DataProvider(name=&quot;createByEra&quot;)
 175     Object[][] data_createByEra() {
 176         return new Object[][] {
 177                 {JapaneseEra.of(3), 2020 - YDIFF_NEWERA, 2, 29, 60, LocalDate.of(2020, 2, 29)}, // NEWERA
 178                 {JapaneseEra.HEISEI, 1996 - YDIFF_HEISEI, 2, 29, 60, LocalDate.of(1996, 2, 29)},
 179                 {JapaneseEra.HEISEI, 2000 - YDIFF_HEISEI, 2, 29, 60, LocalDate.of(2000, 2, 29)},
 180                 {JapaneseEra.MEIJI, 1874 - YDIFF_MEIJI, 2, 28, 59, LocalDate.of(1874, 2, 28)},
 181                 {JapaneseEra.SHOWA, 1928 - YDIFF_SHOWA, 12, 25, 360, LocalDate.of(1928, 12, 25)},
 182                 {JapaneseEra.TAISHO, 1916 - YDIFF_TAISHO, 7, 30, 212, LocalDate.of(1916, 7, 30)},
 183                 {JapaneseEra.MEIJI, 6, 1, 1, 1, LocalDate.of(1873, 1, 1)},
 184                 {JapaneseEra.MEIJI, 45, 7, 29, 211, LocalDate.of(1912, 7, 29)},
 185                 {JapaneseEra.TAISHO, 1, 7, 30, 1, LocalDate.of(1912, 7, 30)},
 186                 {JapaneseEra.TAISHO, 15, 12, 24, 358, LocalDate.of(1926, 12, 24)},
 187                 {JapaneseEra.SHOWA, 1, 12, 25, 1, LocalDate.of(1926, 12, 25)},
 188                 {JapaneseEra.SHOWA, 64, 1, 7, 7, LocalDate.of(1989, 1, 7)},
 189                 {JapaneseEra.HEISEI, 1, 1, 8, 1, LocalDate.of(1989, 1, 8)},
 190         };
 191     }
 192 
 193     @Test(dataProvider=&quot;createByEra&quot;)
 194     public void test_createEymd(JapaneseEra era, int yoe, int moy, int dom, int doy, LocalDate iso) {
 195         JapaneseDate dateByChronoFactory = JapaneseChronology.INSTANCE.date(era, yoe, moy, dom);
 196         JapaneseDate dateByDateFactory = JapaneseDate.of(era, yoe, moy, dom);
 197         assertEquals(dateByChronoFactory, dateByDateFactory);
 198         assertEquals(dateByChronoFactory.hashCode(), dateByDateFactory.hashCode());
 199     }
 200 
 201     @Test(dataProvider=&quot;createByEra&quot;)
 202     public void test_createEyd(JapaneseEra era, int yoe, int moy, int dom, int doy, LocalDate iso) {
 203         JapaneseDate dateByChronoFactory = JapaneseChronology.INSTANCE.dateYearDay(era, yoe, doy);
 204         JapaneseDate dateByDateFactory = JapaneseDate.of(era, yoe, moy, dom);
 205         assertEquals(dateByChronoFactory, dateByDateFactory);
 206         assertEquals(dateByChronoFactory.hashCode(), dateByDateFactory.hashCode());
 207     }
 208 
 209     @Test(dataProvider=&quot;createByEra&quot;)
 210     public void test_createByEra_isEqual(JapaneseEra era, int yoe, int moy, int dom, int doy, LocalDate iso) {
 211         JapaneseDate test = JapaneseDate.of(era, yoe, moy, dom);
 212         assertEquals(test.isEqual(iso), true);
 213         assertEquals(iso.isEqual(test), true);
 214     }
 215 
 216     @Test(dataProvider=&quot;createByEra&quot;)
 217     public void test_createByEra_chronologyTemporalFactory(JapaneseEra era, int yoe, int moy, int dom, int doy, LocalDate iso) {
 218         JapaneseDate test = JapaneseDate.of(era, yoe, moy, dom);
 219         assertEquals(IsoChronology.INSTANCE.date(test), iso);
 220         assertEquals(JapaneseChronology.INSTANCE.date(iso), test);
 221     }
 222 
 223     @Test(dataProvider=&quot;createByEra&quot;)
 224     public void test_createByEra_dateFrom(JapaneseEra era, int yoe, int moy, int dom, int doy, LocalDate iso) {
 225         JapaneseDate test = JapaneseDate.of(era, yoe, moy, dom);
 226         assertEquals(LocalDate.from(test), iso);
 227         assertEquals(JapaneseDate.from(iso), test);
 228     }
 229 
 230     @Test(dataProvider=&quot;createByEra&quot;)
 231     public void test_createByEra_query(JapaneseEra era, int yoe, int moy, int dom, int doy, LocalDate iso) {
 232         JapaneseDate test = JapaneseDate.of(era, yoe, moy, dom);
 233         assertEquals(test.query(TemporalQueries.localDate()), iso);
 234     }
 235 
 236     @Test(dataProvider=&quot;createByEra&quot;)
 237     public void test_createByEra_epochDay(JapaneseEra era, int yoe, int moy, int dom, int doy, LocalDate iso) {
 238         JapaneseDate test = JapaneseDate.of(era, yoe, moy, dom);
 239         assertEquals(test.getLong(EPOCH_DAY), iso.getLong(EPOCH_DAY));
 240         assertEquals(test.toEpochDay(), iso.toEpochDay());
 241     }
 242 
 243     //-----------------------------------------------------------------------
 244     @DataProvider(name=&quot;createByProleptic&quot;)
 245     Object[][] data_createByProleptic() {
 246         return new Object[][] {
 247                 {1928, 2, 28, 59, LocalDate.of(1928, 2, 28)},
 248                 {1928, 2, 29, 60, LocalDate.of(1928, 2, 29)},
 249 
 250                 {1873, 9, 7, 250, LocalDate.of(1873, 9, 7)},
 251                 {1873, 9, 8, 251, LocalDate.of(1873, 9, 8)},
 252                 {1912, 7, 29, 211, LocalDate.of(1912, 7, 29)},
 253                 {1912, 7, 30, 212, LocalDate.of(1912, 7, 30)},
 254                 {1926, 12, 24, 358, LocalDate.of(1926, 12, 24)},
 255                 {1926, 12, 25, 359, LocalDate.of(1926, 12, 25)},
 256                 {1989, 1, 7, 7, LocalDate.of(1989, 1, 7)},
 257                 {1989, 1, 8, 8, LocalDate.of(1989, 1, 8)},
 258         };
 259     }
 260 
 261     @Test(dataProvider=&quot;createByProleptic&quot;)
 262     public void test_createYmd(int y, int moy, int dom, int doy, LocalDate iso) {
 263         JapaneseDate dateByChronoFactory = JapaneseChronology.INSTANCE.date(y, moy, dom);
 264         JapaneseDate dateByDateFactory = JapaneseDate.of(y, moy, dom);
 265         assertEquals(dateByChronoFactory, dateByDateFactory);
 266         assertEquals(dateByChronoFactory.hashCode(), dateByDateFactory.hashCode());
 267     }
 268 
 269     @Test(dataProvider=&quot;createByProleptic&quot;)
 270     public void test_createYd(int y, int moy, int dom, int doy, LocalDate iso) {
 271         JapaneseDate dateByChronoFactory = JapaneseChronology.INSTANCE.dateYearDay(y, doy);
 272         JapaneseDate dateByDateFactory = JapaneseDate.of(y, moy, dom);
 273         assertEquals(dateByChronoFactory, dateByDateFactory);
 274         assertEquals(dateByChronoFactory.hashCode(), dateByDateFactory.hashCode());
 275     }
 276 
 277     @Test(dataProvider=&quot;createByProleptic&quot;)
 278     public void test_createByProleptic_isEqual(int y, int moy, int dom, int doy, LocalDate iso) {
 279         JapaneseDate test = JapaneseDate.of(y, moy, dom);
 280         assertEquals(test.isEqual(iso), true);
 281         assertEquals(iso.isEqual(test), true);
 282     }
 283 
 284     @Test(dataProvider=&quot;createByProleptic&quot;)
 285     public void test_createByProleptic_chronologyTemporalFactory(int y, int moy, int dom, int doy, LocalDate iso) {
 286         JapaneseDate test = JapaneseDate.of(y, moy, dom);
 287         assertEquals(IsoChronology.INSTANCE.date(test), iso);
 288         assertEquals(JapaneseChronology.INSTANCE.date(iso), test);
 289     }
 290 
 291     @Test(dataProvider=&quot;createByProleptic&quot;)
 292     public void test_createByProleptic_dateFrom(int y, int moy, int dom, int doy, LocalDate iso) {
 293         JapaneseDate test = JapaneseDate.of(y, moy, dom);
 294         assertEquals(LocalDate.from(test), iso);
 295         assertEquals(JapaneseDate.from(iso), test);
 296     }
 297 
 298     @Test(dataProvider=&quot;createByProleptic&quot;)
 299     public void test_createByProleptic_query(int y, int moy, int dom, int doy, LocalDate iso) {
 300         JapaneseDate test = JapaneseDate.of(y, moy, dom);
 301         assertEquals(test.query(TemporalQueries.localDate()), iso);
 302     }
 303 
 304     @Test(dataProvider=&quot;createByProleptic&quot;)
 305     public void test_createByProleptic_epochDay(int y, int moy, int dom, int doy, LocalDate iso) {
 306         JapaneseDate test = JapaneseDate.of(y, moy, dom);
 307         assertEquals(test.getLong(EPOCH_DAY), iso.getLong(EPOCH_DAY));
 308         assertEquals(test.toEpochDay(), iso.toEpochDay());
 309     }
 310 
 311     //-----------------------------------------------------------------------
 312     @Test
 313     public void test_dateNow(){
 314         assertEquals(JapaneseChronology.INSTANCE.dateNow(), JapaneseDate.now()) ;
 315         assertEquals(JapaneseChronology.INSTANCE.dateNow(), JapaneseDate.now(ZoneId.systemDefault())) ;
 316         assertEquals(JapaneseChronology.INSTANCE.dateNow(), JapaneseDate.now(Clock.systemDefaultZone())) ;
 317         assertEquals(JapaneseChronology.INSTANCE.dateNow(), JapaneseDate.now(Clock.systemDefaultZone().getZone())) ;
 318 
 319         assertEquals(JapaneseChronology.INSTANCE.dateNow(), JapaneseChronology.INSTANCE.dateNow(ZoneId.systemDefault())) ;
 320         assertEquals(JapaneseChronology.INSTANCE.dateNow(), JapaneseChronology.INSTANCE.dateNow(Clock.systemDefaultZone())) ;
 321         assertEquals(JapaneseChronology.INSTANCE.dateNow(), JapaneseChronology.INSTANCE.dateNow(Clock.systemDefaultZone().getZone())) ;
 322 
 323         ZoneId zoneId = ZoneId.of(&quot;Europe/Paris&quot;);
 324         assertEquals(JapaneseChronology.INSTANCE.dateNow(zoneId), JapaneseChronology.INSTANCE.dateNow(Clock.system(zoneId))) ;
 325         assertEquals(JapaneseChronology.INSTANCE.dateNow(zoneId), JapaneseChronology.INSTANCE.dateNow(Clock.system(zoneId).getZone())) ;
 326         assertEquals(JapaneseChronology.INSTANCE.dateNow(zoneId), JapaneseDate.now(Clock.system(zoneId))) ;
 327         assertEquals(JapaneseChronology.INSTANCE.dateNow(zoneId), JapaneseDate.now(Clock.system(zoneId).getZone())) ;
 328 
 329         assertEquals(JapaneseChronology.INSTANCE.dateNow(ZoneId.of(ZoneOffset.UTC.getId())), JapaneseChronology.INSTANCE.dateNow(Clock.systemUTC())) ;
 330     }
 331 
 332     //-----------------------------------------------------------------------
 333     @DataProvider(name=&quot;badDates&quot;)
 334     Object[][] data_badDates() {
 335         return new Object[][] {
 336             {1928, 0, 0},
 337 
 338             {1928, -1, 1},
 339             {1928, 0, 1},
 340             {1928, 14, 1},
 341             {1928, 15, 1},
 342 
 343             {1928, 1, -1},
 344             {1928, 1, 0},
 345             {1928, 1, 32},
 346 
 347             {1928, 12, -1},
 348             {1928, 12, 0},
 349             {1928, 12, 32},
 350 
 351             {1725, 2, 29},
 352             {500, 2, 29},
 353             {2100, 2, 29},
 354 
 355             {1872, 12, 31},     // Last day of MEIJI 5
 356         };
 357     }
 358 
 359     @Test(dataProvider=&quot;badDates&quot;, expectedExceptions=DateTimeException.class)
 360     public void test_badDates(int year, int month, int dom) {
 361         JapaneseChronology.INSTANCE.date(year, month, dom);
 362     }
 363 
 364     //-----------------------------------------------------------------------
 365     // prolepticYear() and is LeapYear()
 366     //-----------------------------------------------------------------------
 367     @DataProvider(name=&quot;prolepticYear&quot;)
 368     Object[][] data_prolepticYear() {
 369         return new Object[][] {
 370                 {3, JapaneseEra.of(3), 1, 1 + YDIFF_NEWERA, false}, // NEWERA
 371                 {3, JapaneseEra.of(3), 102, 102 + YDIFF_NEWERA, true}, // NEWERA
 372 
 373                 {2, JapaneseEra.HEISEI, 1, 1 + YDIFF_HEISEI, false},
 374                 {2, JapaneseEra.HEISEI, 4, 4 + YDIFF_HEISEI, true},
 375 
 376                 {-1, JapaneseEra.MEIJI, 9, 9 + YDIFF_MEIJI, true},
 377                 {-1, JapaneseEra.MEIJI, 10, 10 + YDIFF_MEIJI, false},
 378 
 379                 {1, JapaneseEra.SHOWA, 1, 1 + YDIFF_SHOWA, false},
 380                 {1, JapaneseEra.SHOWA, 7, 7 + YDIFF_SHOWA, true},
 381 
 382                 {0, JapaneseEra.TAISHO, 1, 1 + YDIFF_TAISHO, true},
 383                 {0, JapaneseEra.TAISHO, 4, 4 + YDIFF_TAISHO, false},
 384         };
 385     }
 386 
 387     @Test(dataProvider=&quot;prolepticYear&quot;)
 388     public void test_prolepticYear(int eraValue, Era  era, int yearOfEra, int expectedProlepticYear, boolean isLeapYear) {
 389         Era eraObj = JapaneseChronology.INSTANCE.eraOf(eraValue);
 390         assertTrue(JapaneseChronology.INSTANCE.eras().contains(eraObj));
 391         assertEquals(eraObj, era);
 392         assertEquals(JapaneseChronology.INSTANCE.prolepticYear(era, yearOfEra), expectedProlepticYear);
 393     }
 394 
 395     @Test(dataProvider=&quot;prolepticYear&quot;)
 396     public void test_isLeapYear(int eraValue, Era  era, int yearOfEra, int expectedProlepticYear, boolean isLeapYear) {
 397         assertEquals(JapaneseChronology.INSTANCE.isLeapYear(expectedProlepticYear), isLeapYear);
 398         assertEquals(JapaneseChronology.INSTANCE.isLeapYear(expectedProlepticYear), Year.of(expectedProlepticYear).isLeap());
 399 
 400         JapaneseDate jdate = JapaneseDate.now();
 401         jdate = jdate.with(ChronoField.YEAR, expectedProlepticYear).with(ChronoField.MONTH_OF_YEAR, 2);
 402         if (isLeapYear) {
 403             assertEquals(jdate.lengthOfMonth(), 29);
 404         } else {
 405             assertEquals(jdate.lengthOfMonth(), 28);
 406         }
 407     }
 408 
 409     @DataProvider(name=&quot;prolepticYearError&quot;)
 410     Object[][] data_prolepticYearError() {
 411         return new Object[][] {
 412                 {JapaneseEra.MEIJI, 100},
 413                 {JapaneseEra.MEIJI, 0},
 414                 {JapaneseEra.MEIJI, -10},
 415 
 416                 {JapaneseEra.SHOWA, 100},
 417                 {JapaneseEra.SHOWA, 0},
 418                 {JapaneseEra.SHOWA, -10},
 419 
 420                 {JapaneseEra.TAISHO, 100},
 421                 {JapaneseEra.TAISHO, 0},
 422                 {JapaneseEra.TAISHO, -10},
 423         };
 424     }
 425 
 426     @Test(dataProvider=&quot;prolepticYearError&quot;, expectedExceptions=DateTimeException.class)
 427     public void test_prolepticYearError(Era era, int yearOfEra) {
 428         JapaneseChronology.INSTANCE.prolepticYear(era, yearOfEra);
 429     }
 430 
 431     //-----------------------------------------------------------------------
 432     // Bad Era for Chronology.date(era,...) and Chronology.prolepticYear(Era,...)
 433     //-----------------------------------------------------------------------
 434     @Test
 435     public void test_InvalidEras() {
 436         // Verify that the eras from every other Chronology are invalid
 437         for (Chronology chrono : Chronology.getAvailableChronologies()) {
 438             if (chrono instanceof JapaneseChronology) {
 439                 continue;
 440             }
 441             List&lt;Era&gt; eras = chrono.eras();
 442             for (Era era : eras) {
 443                 try {
 444                     ChronoLocalDate date = JapaneseChronology.INSTANCE.date(era, 1, 1, 1);
 445                     fail(&quot;JapaneseChronology.date did not throw ClassCastException for Era: &quot; + era);
 446                 } catch (ClassCastException cex) {
 447                     ; // ignore expected exception
 448                 }
 449                 try {
 450                     @SuppressWarnings(&quot;unused&quot;)
 451                     int year = JapaneseChronology.INSTANCE.prolepticYear(era, 1);
 452                     fail(&quot;JapaneseChronology.prolepticYear did not throw ClassCastException for Era: &quot; + era);
 453                 } catch (ClassCastException cex) {
 454                     ; // ignore expected exception
 455                 }
 456 
 457             }
 458         }
 459     }
 460 
 461     //-----------------------------------------------------------------------
 462     // get(TemporalField)
 463     //-----------------------------------------------------------------------
 464     @Test
 465     public void test_getLong() {
 466         JapaneseDate base = JapaneseChronology.INSTANCE.date(JapaneseEra.SHOWA, 63, 6, 30);
 467         assertEquals(base.getLong(ERA), JapaneseEra.SHOWA.getValue());
 468         assertEquals(base.getLong(YEAR), 1988L);
 469         assertEquals(base.getLong(YEAR_OF_ERA), 63L);
 470         assertEquals(base.getLong(MONTH_OF_YEAR), 6L);
 471         assertEquals(base.getLong(DAY_OF_MONTH), 30L);
 472     }
 473 
 474     //-----------------------------------------------------------------------
 475     // with(TemporalField, long)
 476     //-----------------------------------------------------------------------
 477     @Test
 478     public void test_with_TemporalField_long() {
 479         JapaneseDate base = JapaneseChronology.INSTANCE.date(JapaneseEra.SHOWA, 63, 6, 30);
 480         JapaneseDate test = base.with(YEAR, 1987);
 481         assertEquals(test, JapaneseChronology.INSTANCE.date(JapaneseEra.SHOWA, 62, 6, 30));
 482 
 483         test = test.with(YEAR_OF_ERA, 2);
 484         assertEquals(test, JapaneseChronology.INSTANCE.date(JapaneseEra.SHOWA, 2, 6, 30));
 485 
 486         test = test.with(ERA, JapaneseEra.HEISEI.getValue());
 487         assertEquals(test, JapaneseChronology.INSTANCE.date(JapaneseEra.HEISEI, 2, 6, 30));
 488 
 489         test = test.with(MONTH_OF_YEAR, 3);
 490         assertEquals(test, JapaneseChronology.INSTANCE.date(JapaneseEra.HEISEI, 2, 3, 30));
 491 
 492         test = test.with(DAY_OF_MONTH, 4);
 493         assertEquals(test, JapaneseChronology.INSTANCE.date(JapaneseEra.HEISEI, 2, 3, 4));
 494     }
 495 
 496     //-----------------------------------------------------------------------
 497     // with(WithAdjuster)
 498     //-----------------------------------------------------------------------
 499     @Test
 500     public void test_adjust1() {
 501         JapaneseDate base = JapaneseChronology.INSTANCE.date(1928, 10, 29);
 502         JapaneseDate test = base.with(TemporalAdjusters.lastDayOfMonth());
 503         assertEquals(test, JapaneseChronology.INSTANCE.date(1928, 10, 31));
 504     }
 505 
 506     @Test
 507     public void test_adjust2() {
 508         JapaneseDate base = JapaneseChronology.INSTANCE.date(1928, 12, 2);
 509         JapaneseDate test = base.with(TemporalAdjusters.lastDayOfMonth());
 510         assertEquals(test, JapaneseChronology.INSTANCE.date(1928, 12, 31));
 511     }
 512 
 513     //-----------------------------------------------------------------------
 514     // JapaneseDate.with(Local*)
 515     //-----------------------------------------------------------------------
 516     @Test
 517     public void test_adjust_toLocalDate() {
 518         JapaneseDate jdate = JapaneseChronology.INSTANCE.date(1926, 1, 4);
 519         JapaneseDate test = jdate.with(LocalDate.of(2012, 7, 6));
 520         assertEquals(test, JapaneseChronology.INSTANCE.date(2012, 7, 6));
 521     }
 522 
 523     @Test(expectedExceptions=DateTimeException.class)
 524     public void test_adjust_toMonth() {
 525         JapaneseDate jdate = JapaneseChronology.INSTANCE.date(1926, 1, 4);
 526         jdate.with(Month.APRIL);
 527     }
 528 
 529     //-----------------------------------------------------------------------
 530     // LocalDate.with(JapaneseDate)
 531     //-----------------------------------------------------------------------
 532     @Test
 533     public void test_LocalDate_adjustToJapaneseDate() {
 534         JapaneseDate jdate = JapaneseChronology.INSTANCE.date(1928, 10, 29);
 535         LocalDate test = LocalDate.MIN.with(jdate);
 536         assertEquals(test, LocalDate.of(1928, 10, 29));
 537     }
 538 
 539     @Test
 540     public void test_LocalDateTime_adjustToJapaneseDate() {
 541         JapaneseDate jdate = JapaneseChronology.INSTANCE.date(1928, 10, 29);
 542         LocalDateTime test = LocalDateTime.MIN.with(jdate);
 543         assertEquals(test, LocalDateTime.of(1928, 10, 29, 0, 0));
 544     }
 545 
 546     //-----------------------------------------------------------------------
 547     // Check Japanese Eras
 548     //-----------------------------------------------------------------------
 549     @DataProvider(name=&quot;japaneseEras&quot;)
 550     Object[][] data_japanseseEras() {
 551         return new Object[][] {
 552             { JapaneseEra.MEIJI, -1, &quot;Meiji&quot;},
 553             { JapaneseEra.TAISHO, 0, &quot;Taisho&quot;},
 554             { JapaneseEra.SHOWA, 1, &quot;Showa&quot;},
 555             { JapaneseEra.HEISEI, 2, &quot;Heisei&quot;},
 556             { JapaneseEra.of(3), 3, &quot;NewEra&quot;}, // NEWERA
 557         };
 558     }
 559 
 560     @Test(dataProvider=&quot;japaneseEras&quot;)
 561     public void test_Japanese_Eras(Era era, int eraValue, String name) {
 562         assertEquals(era.getValue(), eraValue, &quot;EraValue&quot;);
 563         assertEquals(era.toString(), name, &quot;Era Name&quot;);
 564         assertEquals(era, JapaneseChronology.INSTANCE.eraOf(eraValue), &quot;JapaneseChronology.eraOf()&quot;);
 565         List&lt;Era&gt; eras = JapaneseChronology.INSTANCE.eras();
 566         assertTrue(eras.contains(era), &quot;Era is not present in JapaneseChronology.INSTANCE.eras()&quot;);
 567     }
 568 
 569     @Test
 570     public void test_Japanese_badEras() {
 571         int badEras[] = {-1000, -998, -997, -2, 4, 5, 1000};
 572         for (int badEra : badEras) {
 573             try {
 574                 Era era = JapaneseChronology.INSTANCE.eraOf(badEra);
 575                 fail(&quot;JapaneseChronology.eraOf returned &quot; + era + &quot; + for invalid eraValue &quot; + badEra);
 576             } catch (DateTimeException ex) {
 577                 // ignore expected exception
 578             }
 579         }
 580     }
 581 
 582     @Test(dataProvider=&quot;japaneseEras&quot;)
 583     public void test_JapaneseEra_singletons(Era expectedEra, int eraValue, String name) {
 584         JapaneseEra actualEra = JapaneseEra.valueOf(name);
 585         assertEquals(actualEra, expectedEra, &quot;JapaneseEra.valueOf(name)&quot;);
 586 
 587         actualEra = JapaneseEra.of(eraValue);
 588         assertEquals(actualEra, expectedEra, &quot;JapaneseEra.of(value)&quot;);
 589 
 590         String string = actualEra.toString();
 591         assertEquals(string, name, &quot;JapaneseEra.toString()&quot;);
 592     }
 593 
 594     @Test
 595     public void test_JapaneseEra_values() {
 596         JapaneseEra[] actualEras = JapaneseEra.values();
 597         Object[][] erasInfo = data_japanseseEras();
 598         assertEquals(actualEras.length, erasInfo.length, &quot;Wrong number of Eras&quot;);
 599 
 600         for (int i = 0; i &lt; erasInfo.length; i++) {
 601             Object[] eraInfo = erasInfo[i];
 602             assertEquals(actualEras[i], eraInfo[0], &quot;Singleton mismatch&quot;);
 603         }
 604     }
 605 
 606     @Test
 607     public void test_JapaneseChronology_eras() {
 608         List&lt;Era&gt; actualEras = JapaneseChronology.INSTANCE.eras();
 609         Object[][] erasInfo = data_japanseseEras();
 610         assertEquals(actualEras.size(), erasInfo.length, &quot;Wrong number of Eras&quot;);
 611 
 612         for (int i = 0; i &lt; erasInfo.length; i++) {
 613             Object[] eraInfo = erasInfo[i];
 614             assertEquals(actualEras.get(i), eraInfo[0], &quot;Singleton mismatch&quot;);
 615         }
 616     }
 617 
 618     //-----------------------------------------------------------------------
 619     // PeriodUntil()
 620     //-----------------------------------------------------------------------
 621     @Test
 622     public void test_periodUntilDate() {
 623         JapaneseDate mdate1 = JapaneseDate.of(1970, 1, 1);
 624         JapaneseDate mdate2 = JapaneseDate.of(1971, 2, 2);
 625         ChronoPeriod period = mdate1.until(mdate2);
 626         assertEquals(period, JapaneseChronology.INSTANCE.period(1, 1, 1));
 627     }
 628 
 629     @Test
 630     public void test_periodUntilUnit() {
 631         JapaneseDate mdate1 = JapaneseDate.of(1970, 1, 1);
 632         JapaneseDate mdate2 = JapaneseDate.of(1971, 2, 2);
 633         long months = mdate1.until(mdate2, ChronoUnit.MONTHS);
 634         assertEquals(months, 13);
 635     }
 636 
 637     @Test
 638     public void test_periodUntilDiffChrono() {
 639         JapaneseDate mdate1 = JapaneseDate.of(1970, 1, 1);
 640         JapaneseDate mdate2 = JapaneseDate.of(1971, 2, 2);
 641         MinguoDate ldate2 = MinguoChronology.INSTANCE.date(mdate2);
 642         ChronoPeriod period = mdate1.until(ldate2);
 643         assertEquals(period, JapaneseChronology.INSTANCE.period(1, 1, 1));
 644     }
 645 
 646     //-----------------------------------------------------------------------
 647     // JapaneseChronology.dateYearDay, getDayOfYear
 648     //-----------------------------------------------------------------------
 649     @Test
 650     public void test_getDayOfYear() {
 651         // Test all the Eras
 652         for (JapaneseEra era : JapaneseEra.values()) {
 653             int firstYear = (era == JapaneseEra.MEIJI) ? 6 : 1;  // Until Era supports range(YEAR_OF_ERA)
 654             JapaneseDate hd1 = JapaneseChronology.INSTANCE.dateYearDay(era, firstYear, 1);
 655             ValueRange range = hd1.range(DAY_OF_YEAR);
 656             assertEquals(range.getMaximum(), hd1.lengthOfYear(), &quot;lengthOfYear should match range.getMaximum()&quot;);
 657 
 658             for (int i = 1; i &lt;= hd1.lengthOfYear(); i++) {
 659                 JapaneseDate hd = JapaneseChronology.INSTANCE.dateYearDay(era, firstYear, i);
 660                 int doy = hd.get(DAY_OF_YEAR);
 661                 assertEquals(doy, i, &quot;get(DAY_OF_YEAR) incorrect for &quot; + i + &quot;, of date: &quot; + hd);
 662             }
 663         }
 664     }
 665 
 666     @Test
 667     public void test_withDayOfYear() {
 668         JapaneseDate hd = JapaneseChronology.INSTANCE.dateYearDay(1990, 1);
 669         for (int i = 1; i &lt;= hd.lengthOfYear(); i++) {
 670             JapaneseDate hd2 = hd.with(DAY_OF_YEAR, i);
 671             int doy = hd2.get(DAY_OF_YEAR);
 672             assertEquals(doy, i, &quot;with(DAY_OF_YEAR) incorrect for &quot; + i + &quot; &quot; + hd2);
 673         }
 674     }
 675 
 676     //-----------------------------------------------------------------------
 677     // toString()
 678     //-----------------------------------------------------------------------
 679     @DataProvider(name=&quot;toString&quot;)
 680     Object[][] data_toString() {
 681         return new Object[][] {
 682             {JapaneseChronology.INSTANCE.date(1873, 12,  5), &quot;Japanese Meiji 6-12-05&quot;},
 683             {JapaneseChronology.INSTANCE.date(1873, 12,  6), &quot;Japanese Meiji 6-12-06&quot;},
 684             {JapaneseChronology.INSTANCE.date(1873,  9,  8), &quot;Japanese Meiji 6-09-08&quot;},
 685             {JapaneseChronology.INSTANCE.date(1912,  7, 29), &quot;Japanese Meiji 45-07-29&quot;},
 686             {JapaneseChronology.INSTANCE.date(1912,  7, 30), &quot;Japanese Taisho 1-07-30&quot;},
 687             {JapaneseChronology.INSTANCE.date(1926, 12, 24), &quot;Japanese Taisho 15-12-24&quot;},
 688             {JapaneseChronology.INSTANCE.date(1926, 12, 25), &quot;Japanese Showa 1-12-25&quot;},
 689             {JapaneseChronology.INSTANCE.date(1989,  1,  7), &quot;Japanese Showa 64-01-07&quot;},
 690             {JapaneseChronology.INSTANCE.date(1989,  1,  8), &quot;Japanese Heisei 1-01-08&quot;},
 691             {JapaneseChronology.INSTANCE.date(2012, 12,  6), &quot;Japanese Heisei 24-12-06&quot;},
 692             {JapaneseChronology.INSTANCE.date(2020,  1,  6), &quot;Japanese NewEra 2-01-06&quot;},
 693         };
 694     }
 695 
 696     @Test(dataProvider=&quot;toString&quot;)
 697     public void test_toString(JapaneseDate jdate, String expected) {
 698         assertEquals(jdate.toString(), expected);
 699     }
 700 
 701     //-----------------------------------------------------------------------
 702     // equals()
 703     //-----------------------------------------------------------------------
 704     @Test
 705     public void test_equals_true() {
 706         assertTrue(JapaneseChronology.INSTANCE.equals(JapaneseChronology.INSTANCE));
 707     }
 708 
 709     @Test
 710     public void test_equals_false() {
 711         assertFalse(JapaneseChronology.INSTANCE.equals(IsoChronology.INSTANCE));
 712     }
 713 
 714     //-----------------------------------------------------------------------
 715     //-----------------------------------------------------------------------
 716     @DataProvider(name = &quot;resolve_styleByEra&quot;)
 717     Object[][] data_resolve_styleByEra() {
 718         Object[][] result = new Object[ResolverStyle.values().length * JapaneseEra.values().length][];
 719         int i = 0;
 720         for (ResolverStyle style : ResolverStyle.values()) {
 721             for (JapaneseEra era : JapaneseEra.values()) {
 722                 result[i++] = new Object[] {style, era};
 723             }
 724         }
 725         return result;
 726     }
 727 
 728     @Test(dataProvider = &quot;resolve_styleByEra&quot;)
 729     public void test_resolve_yearOfEra_eraOnly_valid(ResolverStyle style, JapaneseEra era) {
 730         Map&lt;TemporalField, Long&gt; fieldValues = new HashMap&lt;&gt;();
 731         fieldValues.put(ChronoField.ERA, (long) era.getValue());
 732         JapaneseDate date = JapaneseChronology.INSTANCE.resolveDate(fieldValues, style);
 733         assertEquals(date, null);
 734         assertEquals(fieldValues.get(ChronoField.ERA), (Long) (long) era.getValue());
 735         assertEquals(fieldValues.size(), 1);
 736     }
 737 
 738     @Test(dataProvider = &quot;resolve_styleByEra&quot;)
 739     public void test_resolve_yearOfEra_eraAndYearOfEraOnly_valid(ResolverStyle style, JapaneseEra era) {
 740         Map&lt;TemporalField, Long&gt; fieldValues = new HashMap&lt;&gt;();
 741         fieldValues.put(ChronoField.ERA, (long) era.getValue());
 742         fieldValues.put(ChronoField.YEAR_OF_ERA, 1L);
 743         JapaneseDate date = JapaneseChronology.INSTANCE.resolveDate(fieldValues, style);
 744         assertEquals(date, null);
 745         assertEquals(fieldValues.get(ChronoField.ERA), (Long) (long) era.getValue());
 746         assertEquals(fieldValues.get(ChronoField.YEAR_OF_ERA), (Long) 1L);
 747         assertEquals(fieldValues.size(), 2);
 748     }
 749 
 750     @Test(dataProvider = &quot;resolve_styleByEra&quot;)
 751     public void test_resolve_yearOfEra_eraAndYearOnly_valid(ResolverStyle style, JapaneseEra era) {
 752         Map&lt;TemporalField, Long&gt; fieldValues = new HashMap&lt;&gt;();
 753         fieldValues.put(ChronoField.ERA, (long) era.getValue());
 754         fieldValues.put(ChronoField.YEAR, 1L);
 755         JapaneseDate date = JapaneseChronology.INSTANCE.resolveDate(fieldValues, style);
 756         assertEquals(date, null);
 757         assertEquals(fieldValues.get(ChronoField.ERA), (Long) (long) era.getValue());
 758         assertEquals(fieldValues.get(ChronoField.YEAR), (Long) 1L);
 759         assertEquals(fieldValues.size(), 2);
 760     }
 761 
 762     @DataProvider(name = &quot;resolve_styles&quot;)
 763     Object[][] data_resolve_styles() {
 764         Object[][] result = new Object[ResolverStyle.values().length][];
 765         int i = 0;
 766         for (ResolverStyle style : ResolverStyle.values()) {
 767             result[i++] = new Object[] {style};
 768         }
 769         return result;
 770     }
 771 
 772     @Test(dataProvider = &quot;resolve_styles&quot;)
 773     public void test_resolve_yearOfEra_yearOfEraOnly_valid(ResolverStyle style) {
 774         Map&lt;TemporalField, Long&gt; fieldValues = new HashMap&lt;&gt;();
 775         fieldValues.put(ChronoField.YEAR_OF_ERA, 1L);
 776         JapaneseDate date = JapaneseChronology.INSTANCE.resolveDate(fieldValues, style);
 777         assertEquals(date, null);
 778         assertEquals(fieldValues.get(ChronoField.YEAR_OF_ERA), (Long) 1L);
 779         assertEquals(fieldValues.size(), 1);
 780     }
 781 
 782     @Test(dataProvider = &quot;resolve_styles&quot;)
 783     public void test_resolve_yearOfEra_yearOfEraAndYearOnly_valid(ResolverStyle style) {
 784         Map&lt;TemporalField, Long&gt; fieldValues = new HashMap&lt;&gt;();
 785         fieldValues.put(ChronoField.YEAR_OF_ERA, 1L);
 786         fieldValues.put(ChronoField.YEAR, 2012L);
 787         JapaneseDate date = JapaneseChronology.INSTANCE.resolveDate(fieldValues, style);
 788         assertEquals(date, null);
 789         assertEquals(fieldValues.get(ChronoField.YEAR_OF_ERA), (Long) 1L);
 790         assertEquals(fieldValues.get(ChronoField.YEAR), (Long) 2012L);
 791         assertEquals(fieldValues.size(), 2);
 792     }
 793 
 794     public void test_resolve_yearOfEra_eraOnly_invalidTooSmall() {
 795         for (ResolverStyle style : ResolverStyle.values()) {
 796             Map&lt;TemporalField, Long&gt; fieldValues = new HashMap&lt;&gt;();
 797             fieldValues.put(ChronoField.ERA, JapaneseEra.MEIJI.getValue() - 1L);
 798             try {
 799                 JapaneseChronology.INSTANCE.resolveDate(fieldValues, style);
 800                 fail(&quot;Should have failed: &quot; + style);
 801             } catch (DateTimeException ex) {
 802                 // expected
 803             }
 804         }
 805     }
 806 
 807     public void test_resolve_yearOfEra_eraOnly_invalidTooLarge() {
 808         for (ResolverStyle style : ResolverStyle.values()) {
 809             Map&lt;TemporalField, Long&gt; fieldValues = new HashMap&lt;&gt;();
 810             fieldValues.put(ChronoField.ERA, JapaneseEra.values()[JapaneseEra.values().length - 1].getValue() + 1L);
 811             try {
 812                 JapaneseChronology.INSTANCE.resolveDate(fieldValues, style);
 813                 fail(&quot;Should have failed: &quot; + style);
 814             } catch (DateTimeException ex) {
 815                 // expected
 816             }
 817         }
 818     }
 819 
 820     //-----------------------------------------------------------------------
 821     //-----------------------------------------------------------------------
 822     @DataProvider(name = &quot;resolve_ymd&quot;)
 823     Object[][] data_resolve_ymd() {
 824         return new Object[][] {
 825                 {2012, 1, -365, date(2010, 12, 31), false, false},
 826                 {2012, 1, -364, date(2011, 1, 1), false, false},
 827                 {2012, 1, -31, date(2011, 11, 30), false, false},
 828                 {2012, 1, -30, date(2011, 12, 1), false, false},
 829                 {2012, 1, -12, date(2011, 12, 19), false, false},
 830                 {2012, 1, 1, date(2012, 1, 1), true, true},
 831                 {2012, 1, 59, date(2012, 2, 28), false, false},
 832                 {2012, 1, 60, date(2012, 2, 29), false, false},
 833                 {2012, 1, 61, date(2012, 3, 1), false, false},
 834                 {2012, 1, 365, date(2012, 12, 30), false, false},
 835                 {2012, 1, 366, date(2012, 12, 31), false, false},
 836                 {2012, 1, 367, date(2013, 1, 1), false, false},
 837                 {2012, 1, 367 + 364, date(2013, 12, 31), false, false},
 838                 {2012, 1, 367 + 365, date(2014, 1, 1), false, false},
 839 
 840                 {2012, 2, 1, date(2012, 2, 1), true, true},
 841                 {2012, 2, 28, date(2012, 2, 28), true, true},
 842                 {2012, 2, 29, date(2012, 2, 29), true, true},
 843                 {2012, 2, 30, date(2012, 3, 1), date(2012, 2, 29), false},
 844                 {2012, 2, 31, date(2012, 3, 2), date(2012, 2, 29), false},
 845                 {2012, 2, 32, date(2012, 3, 3), false, false},
 846 
 847                 {2012, -12, 1, date(2010, 12, 1), false, false},
 848                 {2012, -11, 1, date(2011, 1, 1), false, false},
 849                 {2012, -1, 1, date(2011, 11, 1), false, false},
 850                 {2012, 0, 1, date(2011, 12, 1), false, false},
 851                 {2012, 1, 1, date(2012, 1, 1), true, true},
 852                 {2012, 12, 1, date(2012, 12, 1), true, true},
 853                 {2012, 13, 1, date(2013, 1, 1), false, false},
 854                 {2012, 24, 1, date(2013, 12, 1), false, false},
 855                 {2012, 25, 1, date(2014, 1, 1), false, false},
 856 
 857                 {2012, 6, -31, date(2012, 4, 30), false, false},
 858                 {2012, 6, -30, date(2012, 5, 1), false, false},
 859                 {2012, 6, -1, date(2012, 5, 30), false, false},
 860                 {2012, 6, 0, date(2012, 5, 31), false, false},
 861                 {2012, 6, 1, date(2012, 6, 1), true, true},
 862                 {2012, 6, 30, date(2012, 6, 30), true, true},
 863                 {2012, 6, 31, date(2012, 7, 1), date(2012, 6, 30), false},
 864                 {2012, 6, 61, date(2012, 7, 31), false, false},
 865                 {2012, 6, 62, date(2012, 8, 1), false, false},
 866 
 867                 {2011, 2, 1, date(2011, 2, 1), true, true},
 868                 {2011, 2, 28, date(2011, 2, 28), true, true},
 869                 {2011, 2, 29, date(2011, 3, 1), date(2011, 2, 28), false},
 870                 {2011, 2, 30, date(2011, 3, 2), date(2011, 2, 28), false},
 871                 {2011, 2, 31, date(2011, 3, 3), date(2011, 2, 28), false},
 872                 {2011, 2, 32, date(2011, 3, 4), false, false},
 873         };
 874     }
 875 
 876     @Test(dataProvider = &quot;resolve_ymd&quot;)
 877     public void test_resolve_ymd_lenient(int y, int m, int d, JapaneseDate expected, Object smart, boolean strict) {
 878         Map&lt;TemporalField, Long&gt; fieldValues = new HashMap&lt;&gt;();
 879         fieldValues.put(ChronoField.YEAR, (long) y);
 880         fieldValues.put(ChronoField.MONTH_OF_YEAR, (long) m);
 881         fieldValues.put(ChronoField.DAY_OF_MONTH, (long) d);
 882         JapaneseDate date = JapaneseChronology.INSTANCE.resolveDate(fieldValues, ResolverStyle.LENIENT);
 883         assertEquals(date, expected);
 884         assertEquals(fieldValues.size(), 0);
 885     }
 886 
 887     @Test(dataProvider = &quot;resolve_ymd&quot;)
 888     public void test_resolve_ymd_smart(int y, int m, int d, JapaneseDate expected, Object smart, boolean strict) {
 889         Map&lt;TemporalField, Long&gt; fieldValues = new HashMap&lt;&gt;();
 890         fieldValues.put(ChronoField.YEAR, (long) y);
 891         fieldValues.put(ChronoField.MONTH_OF_YEAR, (long) m);
 892         fieldValues.put(ChronoField.DAY_OF_MONTH, (long) d);
 893         if (Boolean.TRUE.equals(smart)) {
 894             JapaneseDate date = JapaneseChronology.INSTANCE.resolveDate(fieldValues, ResolverStyle.SMART);
 895             assertEquals(date, expected);
 896             assertEquals(fieldValues.size(), 0);
 897         } else if (smart instanceof JapaneseDate) {
 898             JapaneseDate date = JapaneseChronology.INSTANCE.resolveDate(fieldValues, ResolverStyle.SMART);
 899             assertEquals(date, smart);
 900         } else {
 901             try {
 902                 JapaneseChronology.INSTANCE.resolveDate(fieldValues, ResolverStyle.SMART);
 903                 fail(&quot;Should have failed&quot;);
 904             } catch (DateTimeException ex) {
 905                 // expected
 906             }
 907         }
 908     }
 909 
 910     @Test(dataProvider = &quot;resolve_ymd&quot;)
 911     public void test_resolve_ymd_strict(int y, int m, int d, JapaneseDate expected, Object smart, boolean strict) {
 912         Map&lt;TemporalField, Long&gt; fieldValues = new HashMap&lt;&gt;();
 913         fieldValues.put(ChronoField.YEAR, (long) y);
 914         fieldValues.put(ChronoField.MONTH_OF_YEAR, (long) m);
 915         fieldValues.put(ChronoField.DAY_OF_MONTH, (long) d);
 916         if (strict) {
 917             JapaneseDate date = JapaneseChronology.INSTANCE.resolveDate(fieldValues, ResolverStyle.STRICT);
 918             assertEquals(date, expected);
 919             assertEquals(fieldValues.size(), 0);
 920         } else {
 921             try {
 922                 JapaneseChronology.INSTANCE.resolveDate(fieldValues, ResolverStyle.STRICT);
 923                 fail(&quot;Should have failed&quot;);
 924             } catch (DateTimeException ex) {
 925                 // expected
 926             }
 927         }
 928     }
 929 
 930     //-----------------------------------------------------------------------
 931     //-----------------------------------------------------------------------
 932     @DataProvider(name = &quot;resolve_yd&quot;)
 933     Object[][] data_resolve_yd() {
 934         return new Object[][] {
 935                 {2012, -365, date(2010, 12, 31), false, false},
 936                 {2012, -364, date(2011, 1, 1), false, false},
 937                 {2012, -31, date(2011, 11, 30), false, false},
 938                 {2012, -30, date(2011, 12, 1), false, false},
 939                 {2012, -12, date(2011, 12, 19), false, false},
 940                 {2012, -1, date(2011, 12, 30), false, false},
 941                 {2012, 0, date(2011, 12, 31), false, false},
 942                 {2012, 1, date(2012, 1, 1), true, true},
 943                 {2012, 2, date(2012, 1, 2), true, true},
 944                 {2012, 31, date(2012, 1, 31), true, true},
 945                 {2012, 32, date(2012, 2, 1), true, true},
 946                 {2012, 59, date(2012, 2, 28), true, true},
 947                 {2012, 60, date(2012, 2, 29), true, true},
 948                 {2012, 61, date(2012, 3, 1), true, true},
 949                 {2012, 365, date(2012, 12, 30), true, true},
 950                 {2012, 366, date(2012, 12, 31), true, true},
 951                 {2012, 367, date(2013, 1, 1), false, false},
 952                 {2012, 367 + 364, date(2013, 12, 31), false, false},
 953                 {2012, 367 + 365, date(2014, 1, 1), false, false},
 954 
 955                 {2011, 59, date(2011, 2, 28), true, true},
 956                 {2011, 60, date(2011, 3, 1), true, true},
 957         };
 958     }
 959 
 960     @Test(dataProvider = &quot;resolve_yd&quot;)
 961     public void test_resolve_yd_lenient(int y, int d, JapaneseDate expected, boolean smart, boolean strict) {
 962         Map&lt;TemporalField, Long&gt; fieldValues = new HashMap&lt;&gt;();
 963         fieldValues.put(ChronoField.YEAR, (long) y);
 964         fieldValues.put(ChronoField.DAY_OF_YEAR, (long) d);
 965         JapaneseDate date = JapaneseChronology.INSTANCE.resolveDate(fieldValues, ResolverStyle.LENIENT);
 966         assertEquals(date, expected);
 967         assertEquals(fieldValues.size(), 0);
 968     }
 969 
 970     @Test(dataProvider = &quot;resolve_yd&quot;)
 971     public void test_resolve_yd_smart(int y, int d, JapaneseDate expected, boolean smart, boolean strict) {
 972         Map&lt;TemporalField, Long&gt; fieldValues = new HashMap&lt;&gt;();
 973         fieldValues.put(ChronoField.YEAR, (long) y);
 974         fieldValues.put(ChronoField.DAY_OF_YEAR, (long) d);
 975         if (smart) {
 976             JapaneseDate date = JapaneseChronology.INSTANCE.resolveDate(fieldValues, ResolverStyle.SMART);
 977             assertEquals(date, expected);
 978             assertEquals(fieldValues.size(), 0);
 979         } else {
 980             try {
 981                 JapaneseChronology.INSTANCE.resolveDate(fieldValues, ResolverStyle.SMART);
 982                 fail(&quot;Should have failed&quot;);
 983             } catch (DateTimeException ex) {
 984                 // expected
 985             }
 986         }
 987     }
 988 
 989     @Test(dataProvider = &quot;resolve_yd&quot;)
 990     public void test_resolve_yd_strict(int y, int d, JapaneseDate expected, boolean smart, boolean strict) {
 991         Map&lt;TemporalField, Long&gt; fieldValues = new HashMap&lt;&gt;();
 992         fieldValues.put(ChronoField.YEAR, (long) y);
 993         fieldValues.put(ChronoField.DAY_OF_YEAR, (long) d);
 994         if (strict) {
 995             JapaneseDate date = JapaneseChronology.INSTANCE.resolveDate(fieldValues, ResolverStyle.STRICT);
 996             assertEquals(date, expected);
 997             assertEquals(fieldValues.size(), 0);
 998         } else {
 999             try {
1000                 JapaneseChronology.INSTANCE.resolveDate(fieldValues, ResolverStyle.STRICT);
1001                 fail(&quot;Should have failed&quot;);
1002             } catch (DateTimeException ex) {
1003                 // expected
1004             }
1005         }
1006     }
1007 
1008     //-----------------------------------------------------------------------
1009     //-----------------------------------------------------------------------
1010     @DataProvider(name = &quot;resolve_eymd&quot;)
1011     Object[][] data_resolve_eymd() {
1012         return new Object[][] {
1013                 // lenient
1014                 {ResolverStyle.LENIENT, JapaneseEra.HEISEI, 1, 1, 1, date(1989, 1, 1)},  // SHOWA, not HEISEI
1015                 {ResolverStyle.LENIENT, JapaneseEra.HEISEI, 1, 1, 7, date(1989, 1, 7)},  // SHOWA, not HEISEI
1016                 {ResolverStyle.LENIENT, JapaneseEra.HEISEI, 1, 1, 8, date(1989, 1, 8)},
1017                 {ResolverStyle.LENIENT, JapaneseEra.HEISEI, 1, 12, 31, date(1989, 12, 31)},
1018                 {ResolverStyle.LENIENT, JapaneseEra.HEISEI, 2, 1, 1, date(1990, 1, 1)},
1019 
1020                 {ResolverStyle.LENIENT, JapaneseEra.SHOWA, 64, 1, 1, date(1989, 1, 1)},
1021                 {ResolverStyle.LENIENT, JapaneseEra.SHOWA, 64, 1, 7, date(1989, 1, 7)},
1022                 {ResolverStyle.LENIENT, JapaneseEra.SHOWA, 64, 1, 8, date(1989, 1, 8)},  // HEISEI, not SHOWA
1023                 {ResolverStyle.LENIENT, JapaneseEra.SHOWA, 64, 12, 31, date(1989, 12, 31)},  // HEISEI, not SHOWA
1024                 {ResolverStyle.LENIENT, JapaneseEra.SHOWA, 65, 1, 1, date(1990, 1, 1)},  // HEISEI, not SHOWA
1025 
1026                 {ResolverStyle.LENIENT, JapaneseEra.SHOWA, 64, 1, -366, date(1987, 12, 31)},
1027                 {ResolverStyle.LENIENT, JapaneseEra.SHOWA, 64, 1, -365, date(1988, 1, 1)},
1028                 {ResolverStyle.LENIENT, JapaneseEra.SHOWA, 64, 1, -31, date(1988, 11, 30)},
1029                 {ResolverStyle.LENIENT, JapaneseEra.SHOWA, 64, 1, -30, date(1988, 12, 1)},
1030                 {ResolverStyle.LENIENT, JapaneseEra.SHOWA, 64, 1, 0, date(1988, 12, 31)},
1031                 {ResolverStyle.LENIENT, JapaneseEra.SHOWA, 64, 1, 1, date(1989, 1, 1)},
1032                 {ResolverStyle.LENIENT, JapaneseEra.SHOWA, 64, 1, 27, date(1989, 1, 27)},
1033                 {ResolverStyle.LENIENT, JapaneseEra.SHOWA, 64, 1, 28, date(1989, 1, 28)},
1034                 {ResolverStyle.LENIENT, JapaneseEra.SHOWA, 64, 1, 29, date(1989, 1, 29)},
1035                 {ResolverStyle.LENIENT, JapaneseEra.SHOWA, 64, 1, 30, date(1989, 1, 30)},
1036                 {ResolverStyle.LENIENT, JapaneseEra.SHOWA, 64, 1, 31, date(1989, 1, 31)},
1037                 {ResolverStyle.LENIENT, JapaneseEra.SHOWA, 64, 1, 32, date(1989, 2, 1)},
1038                 {ResolverStyle.LENIENT, JapaneseEra.SHOWA, 64, 1, 58, date(1989, 2, 27)},
1039                 {ResolverStyle.LENIENT, JapaneseEra.SHOWA, 64, 1, 59, date(1989, 2, 28)},
1040                 {ResolverStyle.LENIENT, JapaneseEra.SHOWA, 64, 1, 60, date(1989, 3, 1)},
1041                 {ResolverStyle.LENIENT, JapaneseEra.SHOWA, 64, 1, 365, date(1989, 12, 31)},
1042                 {ResolverStyle.LENIENT, JapaneseEra.SHOWA, 64, 1, 366, date(1990, 1, 1)},
1043 
1044                 {ResolverStyle.LENIENT, JapaneseEra.SHOWA, 63, 1, 1, date(1988, 1, 1)},
1045                 {ResolverStyle.LENIENT, JapaneseEra.SHOWA, 63, 1, 31, date(1988, 1, 31)},
1046                 {ResolverStyle.LENIENT, JapaneseEra.SHOWA, 63, 1, 32, date(1988, 2, 1)},
1047                 {ResolverStyle.LENIENT, JapaneseEra.SHOWA, 63, 1, 58, date(1988, 2, 27)},
1048                 {ResolverStyle.LENIENT, JapaneseEra.SHOWA, 63, 1, 59, date(1988, 2, 28)},
1049                 {ResolverStyle.LENIENT, JapaneseEra.SHOWA, 63, 1, 60, date(1988, 2, 29)},
1050                 {ResolverStyle.LENIENT, JapaneseEra.SHOWA, 63, 1, 61, date(1988, 3, 1)},
1051 
1052                 {ResolverStyle.LENIENT, JapaneseEra.SHOWA, 64, 2, 1, date(1989, 2, 1)},
1053                 {ResolverStyle.LENIENT, JapaneseEra.SHOWA, 64, 2, 28, date(1989, 2, 28)},
1054                 {ResolverStyle.LENIENT, JapaneseEra.SHOWA, 64, 2, 29, date(1989, 3, 1)},
1055 
1056                 {ResolverStyle.LENIENT, JapaneseEra.SHOWA, 63, 2, 1, date(1988, 2, 1)},
1057                 {ResolverStyle.LENIENT, JapaneseEra.SHOWA, 63, 2, 28, date(1988, 2, 28)},
1058                 {ResolverStyle.LENIENT, JapaneseEra.SHOWA, 63, 2, 29, date(1988, 2, 29)},
1059                 {ResolverStyle.LENIENT, JapaneseEra.SHOWA, 63, 2, 30, date(1988, 3, 1)},
1060 
1061                 {ResolverStyle.LENIENT, JapaneseEra.SHOWA, 62, -11, 1, date(1986, 1, 1)},
1062                 {ResolverStyle.LENIENT, JapaneseEra.SHOWA, 62, -1, 1, date(1986, 11, 1)},
1063                 {ResolverStyle.LENIENT, JapaneseEra.SHOWA, 62, 0, 1, date(1986, 12, 1)},
1064                 {ResolverStyle.LENIENT, JapaneseEra.SHOWA, 62, 13, 1, date(1988, 1, 1)},
1065 
1066                 // smart
1067                 {ResolverStyle.SMART, JapaneseEra.HEISEI, 0, 1, 1, null},
1068                 {ResolverStyle.SMART, JapaneseEra.HEISEI, 1, 1, 1, date(1989, 1, 1)},  // SHOWA, not HEISEI
1069                 {ResolverStyle.SMART, JapaneseEra.HEISEI, 1, 1, 7, date(1989, 1, 7)},  // SHOWA, not HEISEI
1070                 {ResolverStyle.SMART, JapaneseEra.HEISEI, 1, 1, 8, date(1989, 1, 8)},
1071                 {ResolverStyle.SMART, JapaneseEra.HEISEI, 1, 12, 31, date(1989, 12, 31)},
1072                 {ResolverStyle.SMART, JapaneseEra.HEISEI, 2, 1, 1, date(1990, 1, 1)},
1073 
1074                 {ResolverStyle.SMART, JapaneseEra.SHOWA, 64, 1, 1, date(1989, 1, 1)},
1075                 {ResolverStyle.SMART, JapaneseEra.SHOWA, 64, 1, 7, date(1989, 1, 7)},
1076                 {ResolverStyle.SMART, JapaneseEra.SHOWA, 64, 1, 8, date(1989, 1, 8)},  // HEISEI, not SHOWA
1077                 {ResolverStyle.SMART, JapaneseEra.SHOWA, 64, 12, 31, date(1989, 12, 31)},  // HEISEI, not SHOWA
1078                 {ResolverStyle.SMART, JapaneseEra.SHOWA, 65, 1, 1, null},  // HEISEI, not SHOWA
1079 
1080                 {ResolverStyle.SMART, JapaneseEra.SHOWA, 62, 1, 0, null},
1081                 {ResolverStyle.SMART, JapaneseEra.SHOWA, 62, 1, 1, date(1987, 1, 1)},
1082                 {ResolverStyle.SMART, JapaneseEra.SHOWA, 62, 1, 27, date(1987, 1, 27)},
1083                 {ResolverStyle.SMART, JapaneseEra.SHOWA, 62, 1, 28, date(1987, 1, 28)},
1084                 {ResolverStyle.SMART, JapaneseEra.SHOWA, 62, 1, 29, date(1987, 1, 29)},
1085                 {ResolverStyle.SMART, JapaneseEra.SHOWA, 62, 1, 30, date(1987, 1, 30)},
1086                 {ResolverStyle.SMART, JapaneseEra.SHOWA, 62, 1, 31, date(1987, 1, 31)},
1087                 {ResolverStyle.SMART, JapaneseEra.SHOWA, 62, 1, 32, null},
1088 
1089                 {ResolverStyle.SMART, JapaneseEra.SHOWA, 62, 2, 0, null},
1090                 {ResolverStyle.SMART, JapaneseEra.SHOWA, 62, 2, 1, date(1987, 2, 1)},
1091                 {ResolverStyle.SMART, JapaneseEra.SHOWA, 62, 2, 27, date(1987, 2, 27)},
1092                 {ResolverStyle.SMART, JapaneseEra.SHOWA, 62, 2, 28, date(1987, 2, 28)},
1093                 {ResolverStyle.SMART, JapaneseEra.SHOWA, 62, 2, 29, date(1987, 2, 28)},
1094                 {ResolverStyle.SMART, JapaneseEra.SHOWA, 62, 2, 30, date(1987, 2, 28)},
1095                 {ResolverStyle.SMART, JapaneseEra.SHOWA, 62, 2, 31, date(1987, 2, 28)},
1096                 {ResolverStyle.SMART, JapaneseEra.SHOWA, 62, 2, 32, null},
1097 
1098                 {ResolverStyle.SMART, JapaneseEra.SHOWA, 63, 2, 0, null},
1099                 {ResolverStyle.SMART, JapaneseEra.SHOWA, 63, 2, 1, date(1988, 2, 1)},
1100                 {ResolverStyle.SMART, JapaneseEra.SHOWA, 63, 2, 27, date(1988, 2, 27)},
1101                 {ResolverStyle.SMART, JapaneseEra.SHOWA, 63, 2, 28, date(1988, 2, 28)},
1102                 {ResolverStyle.SMART, JapaneseEra.SHOWA, 63, 2, 29, date(1988, 2, 29)},
1103                 {ResolverStyle.SMART, JapaneseEra.SHOWA, 63, 2, 30, date(1988, 2, 29)},
1104                 {ResolverStyle.SMART, JapaneseEra.SHOWA, 63, 2, 31, date(1988, 2, 29)},
1105                 {ResolverStyle.SMART, JapaneseEra.SHOWA, 63, 2, 32, null},
1106 
1107                 {ResolverStyle.SMART, JapaneseEra.SHOWA, 62, -12, 1, null},
1108                 {ResolverStyle.SMART, JapaneseEra.SHOWA, 62, -1, 1, null},
1109                 {ResolverStyle.SMART, JapaneseEra.SHOWA, 62, 0, 1, null},
1110                 {ResolverStyle.SMART, JapaneseEra.SHOWA, 62, 13, 1, null},
1111 
1112                 // strict
1113                 {ResolverStyle.STRICT, JapaneseEra.HEISEI, 0, 1, 1, null},
1114                 {ResolverStyle.STRICT, JapaneseEra.HEISEI, 1, 1, 1, null},  // SHOWA, not HEISEI
1115                 {ResolverStyle.STRICT, JapaneseEra.HEISEI, 1, 1, 7, null},  // SHOWA, not HEISEI
1116                 {ResolverStyle.STRICT, JapaneseEra.HEISEI, 1, 1, 8, date(1989, 1, 8)},
1117                 {ResolverStyle.STRICT, JapaneseEra.HEISEI, 1, 12, 31, date(1989, 12, 31)},
1118                 {ResolverStyle.STRICT, JapaneseEra.HEISEI, 2, 1, 1, date(1990, 1, 1)},
1119 
1120                 {ResolverStyle.STRICT, JapaneseEra.SHOWA, 64, 1, 1, date(1989, 1, 1)},
1121                 {ResolverStyle.STRICT, JapaneseEra.SHOWA, 64, 1, 7, date(1989, 1, 7)},
1122                 {ResolverStyle.STRICT, JapaneseEra.SHOWA, 64, 1, 8, null},  // HEISEI, not SHOWA
1123                 {ResolverStyle.STRICT, JapaneseEra.SHOWA, 64, 12, 31, null},  // HEISEI, not SHOWA
1124                 {ResolverStyle.STRICT, JapaneseEra.SHOWA, 65, 1, 1, null},  // HEISEI, not SHOWA
1125 
1126                 {ResolverStyle.STRICT, JapaneseEra.SHOWA, 62, 1, 0, null},
1127                 {ResolverStyle.STRICT, JapaneseEra.SHOWA, 62, 1, 1, date(1987, 1, 1)},
1128                 {ResolverStyle.STRICT, JapaneseEra.SHOWA, 62, 1, 27, date(1987, 1, 27)},
1129                 {ResolverStyle.STRICT, JapaneseEra.SHOWA, 62, 1, 28, date(1987, 1, 28)},
1130                 {ResolverStyle.STRICT, JapaneseEra.SHOWA, 62, 1, 29, date(1987, 1, 29)},
1131                 {ResolverStyle.STRICT, JapaneseEra.SHOWA, 62, 1, 30, date(1987, 1, 30)},
1132                 {ResolverStyle.STRICT, JapaneseEra.SHOWA, 62, 1, 31, date(1987, 1, 31)},
1133                 {ResolverStyle.STRICT, JapaneseEra.SHOWA, 62, 1, 32, null},
1134 
1135                 {ResolverStyle.STRICT, JapaneseEra.SHOWA, 62, 2, 0, null},
1136                 {ResolverStyle.STRICT, JapaneseEra.SHOWA, 62, 2, 1, date(1987, 2, 1)},
1137                 {ResolverStyle.STRICT, JapaneseEra.SHOWA, 62, 2, 27, date(1987, 2, 27)},
1138                 {ResolverStyle.STRICT, JapaneseEra.SHOWA, 62, 2, 28, date(1987, 2, 28)},
1139                 {ResolverStyle.STRICT, JapaneseEra.SHOWA, 62, 2, 29, null},
1140                 {ResolverStyle.STRICT, JapaneseEra.SHOWA, 62, 2, 30, null},
1141                 {ResolverStyle.STRICT, JapaneseEra.SHOWA, 62, 2, 31, null},
1142                 {ResolverStyle.STRICT, JapaneseEra.SHOWA, 62, 2, 32, null},
1143 
1144                 {ResolverStyle.STRICT, JapaneseEra.SHOWA, 63, 2, 0, null},
1145                 {ResolverStyle.STRICT, JapaneseEra.SHOWA, 63, 2, 1, date(1988, 2, 1)},
1146                 {ResolverStyle.STRICT, JapaneseEra.SHOWA, 63, 2, 27, date(1988, 2, 27)},
1147                 {ResolverStyle.STRICT, JapaneseEra.SHOWA, 63, 2, 28, date(1988, 2, 28)},
1148                 {ResolverStyle.STRICT, JapaneseEra.SHOWA, 63, 2, 29, date(1988, 2, 29)},
1149                 {ResolverStyle.STRICT, JapaneseEra.SHOWA, 63, 2, 30, null},
1150                 {ResolverStyle.STRICT, JapaneseEra.SHOWA, 63, 2, 31, null},
1151                 {ResolverStyle.STRICT, JapaneseEra.SHOWA, 63, 2, 32, null},
1152 
1153                 {ResolverStyle.STRICT, JapaneseEra.SHOWA, 62, -12, 1, null},
1154                 {ResolverStyle.STRICT, JapaneseEra.SHOWA, 62, -1, 1, null},
1155                 {ResolverStyle.STRICT, JapaneseEra.SHOWA, 62, 0, 1, null},
1156                 {ResolverStyle.STRICT, JapaneseEra.SHOWA, 62, 13, 1, null},
1157         };
1158     }
1159 
1160     @Test(dataProvider = &quot;resolve_eymd&quot;)
1161     public void test_resolve_eymd(ResolverStyle style, JapaneseEra era, int yoe, int m, int d, JapaneseDate expected) {
1162         Map&lt;TemporalField, Long&gt; fieldValues = new HashMap&lt;&gt;();
1163         fieldValues.put(ChronoField.ERA, (long) era.getValue());
1164         fieldValues.put(ChronoField.YEAR_OF_ERA, (long) yoe);
1165         fieldValues.put(ChronoField.MONTH_OF_YEAR, (long) m);
1166         fieldValues.put(ChronoField.DAY_OF_MONTH, (long) d);
1167         if (expected != null) {
1168             JapaneseDate date = JapaneseChronology.INSTANCE.resolveDate(fieldValues, style);
1169             assertEquals(date, expected);
1170             assertEquals(fieldValues.size(), 0);
1171         } else {
1172             try {
1173                 JapaneseChronology.INSTANCE.resolveDate(fieldValues, style);
1174                 fail(&quot;Should have failed&quot;);
1175             } catch (DateTimeException ex) {
1176                 // expected
1177             }
1178         }
1179     }
1180 
1181     //-----------------------------------------------------------------------
1182     private static JapaneseDate date(int y, int m, int d) {
1183         return JapaneseDate.of(y, m, d);
1184     }
1185 
1186 }
    </pre>
  </body>
</html>
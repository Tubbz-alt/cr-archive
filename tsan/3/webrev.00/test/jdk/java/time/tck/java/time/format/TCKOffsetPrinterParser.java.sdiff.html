<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff test/jdk/java/time/tck/java/time/format/TCKOffsetPrinterParser.java</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="TCKDateTimeFormatterBuilder.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="../../../../test/TEST.properties.sdiff.html" target="_top">next &gt;</a></center>    <h2>test/jdk/java/time/tck/java/time/format/TCKOffsetPrinterParser.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2012, 2016, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
</pre>
<hr />
<pre>
 52  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 53  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 54  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 55  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 56  * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 57  * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 58  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 59  */
 60 package tck.java.time.format;
 61 
 62 import static org.testng.Assert.assertEquals;
 63 
 64 import java.time.LocalDateTime;
 65 import java.time.OffsetDateTime;
 66 import java.time.ZoneId;
 67 import java.time.ZoneOffset;
 68 import java.time.ZonedDateTime;
 69 import java.time.format.DateTimeFormatter;
 70 import java.time.format.DateTimeFormatterBuilder;
 71 import java.time.format.TextStyle;

 72 
 73 import org.testng.annotations.BeforeMethod;
 74 import org.testng.annotations.DataProvider;
 75 import org.testng.annotations.Test;
 76 
 77 /**
 78  * Test DateTimeFormatterBuilder.appendOffset().
 79  */
 80 @Test
 81 public class TCKOffsetPrinterParser {
 82 
 83     private static final ZoneOffset OFFSET_UTC = ZoneOffset.UTC;
 84     private static final ZoneOffset OFFSET_P0100 = ZoneOffset.ofHours(1);
 85     private static final ZoneOffset OFFSET_P0123 = ZoneOffset.ofHoursMinutes(1, 23);
 86     private static final ZoneOffset OFFSET_P0023 = ZoneOffset.ofHoursMinutes(0, 23);
 87     private static final ZoneOffset OFFSET_P012345 = ZoneOffset.ofHoursMinutesSeconds(1, 23, 45);
 88     private static final ZoneOffset OFFSET_P000045 = ZoneOffset.ofHoursMinutesSeconds(0, 0, 45);
 89     private static final ZoneOffset OFFSET_M0100 = ZoneOffset.ofHours(-1);
 90     private static final ZoneOffset OFFSET_M0123 = ZoneOffset.ofHoursMinutes(-1, -23);
 91     private static final ZoneOffset OFFSET_M0023 = ZoneOffset.ofHoursMinutes(0, -23);
</pre>
<hr />
<pre>
540             String output2 = f2.format(zdt);
541             assertEquals(output2, (expected.equals(&quot;Z&quot;) ? &quot;+0000&quot; : expected));
542 
543             DateTimeFormatter f3 = new DateTimeFormatterBuilder().appendPattern(&quot;ZZZ&quot;).toFormatter();
544             String output3 = f3.format(zdt);
545             assertEquals(output3, (expected.equals(&quot;Z&quot;) ? &quot;+0000&quot; : expected));
546         } else if (offsetPattern.equals(&quot;+HH:MM:ss&quot;) &amp;&amp; noOffset.equals(&quot;Z&quot;)) {
547             ZonedDateTime zdt = ldt.atZone(zone);
548             DateTimeFormatter f = new DateTimeFormatterBuilder().appendPattern(&quot;ZZZZZ&quot;).toFormatter();
549             String output = f.format(zdt);
550             assertEquals(output, expected);
551         }
552     }
553 
554     @Test(dataProvider=&quot;print_localized&quot;)
555     public void test_print_localized(TextStyle style, LocalDateTime ldt, ZoneOffset offset, String expected) {
556         OffsetDateTime odt = OffsetDateTime.of(ldt, offset);
557         ZonedDateTime zdt = ldt.atZone(offset);
558 
559         DateTimeFormatter f = new DateTimeFormatterBuilder().appendLocalizedOffset(style)
<span class="line-modified">560                                                             .toFormatter();</span>
561         assertEquals(f.format(odt), expected);
562         assertEquals(f.format(zdt), expected);
563         assertEquals(f.parse(expected, ZoneOffset::from), offset);
564 
565         if (style == TextStyle.FULL) {
566             f = new DateTimeFormatterBuilder().appendPattern(&quot;ZZZZ&quot;)
<span class="line-modified">567                                               .toFormatter();</span>
568             assertEquals(f.format(odt), expected);
569             assertEquals(f.format(zdt), expected);
570             assertEquals(f.parse(expected, ZoneOffset::from), offset);
571 
572             f = new DateTimeFormatterBuilder().appendPattern(&quot;OOOO&quot;)
<span class="line-modified">573                                               .toFormatter();</span>
574             assertEquals(f.format(odt), expected);
575             assertEquals(f.format(zdt), expected);
576             assertEquals(f.parse(expected, ZoneOffset::from), offset);
577         }
578 
579         if (style == TextStyle.SHORT) {
580             f = new DateTimeFormatterBuilder().appendPattern(&quot;O&quot;)
<span class="line-modified">581                                               .toFormatter();</span>
582             assertEquals(f.format(odt), expected);
583             assertEquals(f.format(zdt), expected);
584             assertEquals(f.parse(expected, ZoneOffset::from), offset);
585         }
586     }
587 
588     //-----------------------------------------------------------------------
589     @Test(expectedExceptions=IllegalArgumentException.class)
590     public void test_print_pattern_X6rejected() {
591         builder.appendPattern(&quot;XXXXXX&quot;);
592     }
593 
594     @Test(expectedExceptions=IllegalArgumentException.class)
595     public void test_print_pattern_x6rejected() {
596         builder.appendPattern(&quot;xxxxxx&quot;);
597     }
598 
599     @Test(expectedExceptions=IllegalArgumentException.class)
600     public void test_print_pattern_Z6rejected() {
601         builder.appendPattern(&quot;ZZZZZZ&quot;);
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2012, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
</pre>
<hr />
<pre>
 52  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 53  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 54  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 55  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 56  * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 57  * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 58  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 59  */
 60 package tck.java.time.format;
 61 
 62 import static org.testng.Assert.assertEquals;
 63 
 64 import java.time.LocalDateTime;
 65 import java.time.OffsetDateTime;
 66 import java.time.ZoneId;
 67 import java.time.ZoneOffset;
 68 import java.time.ZonedDateTime;
 69 import java.time.format.DateTimeFormatter;
 70 import java.time.format.DateTimeFormatterBuilder;
 71 import java.time.format.TextStyle;
<span class="line-added"> 72 import java.util.Locale;</span>
 73 
 74 import org.testng.annotations.BeforeMethod;
 75 import org.testng.annotations.DataProvider;
 76 import org.testng.annotations.Test;
 77 
 78 /**
 79  * Test DateTimeFormatterBuilder.appendOffset().
 80  */
 81 @Test
 82 public class TCKOffsetPrinterParser {
 83 
 84     private static final ZoneOffset OFFSET_UTC = ZoneOffset.UTC;
 85     private static final ZoneOffset OFFSET_P0100 = ZoneOffset.ofHours(1);
 86     private static final ZoneOffset OFFSET_P0123 = ZoneOffset.ofHoursMinutes(1, 23);
 87     private static final ZoneOffset OFFSET_P0023 = ZoneOffset.ofHoursMinutes(0, 23);
 88     private static final ZoneOffset OFFSET_P012345 = ZoneOffset.ofHoursMinutesSeconds(1, 23, 45);
 89     private static final ZoneOffset OFFSET_P000045 = ZoneOffset.ofHoursMinutesSeconds(0, 0, 45);
 90     private static final ZoneOffset OFFSET_M0100 = ZoneOffset.ofHours(-1);
 91     private static final ZoneOffset OFFSET_M0123 = ZoneOffset.ofHoursMinutes(-1, -23);
 92     private static final ZoneOffset OFFSET_M0023 = ZoneOffset.ofHoursMinutes(0, -23);
</pre>
<hr />
<pre>
541             String output2 = f2.format(zdt);
542             assertEquals(output2, (expected.equals(&quot;Z&quot;) ? &quot;+0000&quot; : expected));
543 
544             DateTimeFormatter f3 = new DateTimeFormatterBuilder().appendPattern(&quot;ZZZ&quot;).toFormatter();
545             String output3 = f3.format(zdt);
546             assertEquals(output3, (expected.equals(&quot;Z&quot;) ? &quot;+0000&quot; : expected));
547         } else if (offsetPattern.equals(&quot;+HH:MM:ss&quot;) &amp;&amp; noOffset.equals(&quot;Z&quot;)) {
548             ZonedDateTime zdt = ldt.atZone(zone);
549             DateTimeFormatter f = new DateTimeFormatterBuilder().appendPattern(&quot;ZZZZZ&quot;).toFormatter();
550             String output = f.format(zdt);
551             assertEquals(output, expected);
552         }
553     }
554 
555     @Test(dataProvider=&quot;print_localized&quot;)
556     public void test_print_localized(TextStyle style, LocalDateTime ldt, ZoneOffset offset, String expected) {
557         OffsetDateTime odt = OffsetDateTime.of(ldt, offset);
558         ZonedDateTime zdt = ldt.atZone(offset);
559 
560         DateTimeFormatter f = new DateTimeFormatterBuilder().appendLocalizedOffset(style)
<span class="line-modified">561                                                             .toFormatter(Locale.US);</span>
562         assertEquals(f.format(odt), expected);
563         assertEquals(f.format(zdt), expected);
564         assertEquals(f.parse(expected, ZoneOffset::from), offset);
565 
566         if (style == TextStyle.FULL) {
567             f = new DateTimeFormatterBuilder().appendPattern(&quot;ZZZZ&quot;)
<span class="line-modified">568                                               .toFormatter(Locale.US);</span>
569             assertEquals(f.format(odt), expected);
570             assertEquals(f.format(zdt), expected);
571             assertEquals(f.parse(expected, ZoneOffset::from), offset);
572 
573             f = new DateTimeFormatterBuilder().appendPattern(&quot;OOOO&quot;)
<span class="line-modified">574                                               .toFormatter(Locale.US);</span>
575             assertEquals(f.format(odt), expected);
576             assertEquals(f.format(zdt), expected);
577             assertEquals(f.parse(expected, ZoneOffset::from), offset);
578         }
579 
580         if (style == TextStyle.SHORT) {
581             f = new DateTimeFormatterBuilder().appendPattern(&quot;O&quot;)
<span class="line-modified">582                                               .toFormatter(Locale.US);</span>
583             assertEquals(f.format(odt), expected);
584             assertEquals(f.format(zdt), expected);
585             assertEquals(f.parse(expected, ZoneOffset::from), offset);
586         }
587     }
588 
589     //-----------------------------------------------------------------------
590     @Test(expectedExceptions=IllegalArgumentException.class)
591     public void test_print_pattern_X6rejected() {
592         builder.appendPattern(&quot;XXXXXX&quot;);
593     }
594 
595     @Test(expectedExceptions=IllegalArgumentException.class)
596     public void test_print_pattern_x6rejected() {
597         builder.appendPattern(&quot;xxxxxx&quot;);
598     }
599 
600     @Test(expectedExceptions=IllegalArgumentException.class)
601     public void test_print_pattern_Z6rejected() {
602         builder.appendPattern(&quot;ZZZZZZ&quot;);
</pre>
</td>
</tr>
</table>
<center><a href="TCKDateTimeFormatterBuilder.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="../../../../test/TEST.properties.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
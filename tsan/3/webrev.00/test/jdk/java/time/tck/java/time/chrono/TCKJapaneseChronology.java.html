<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New test/jdk/java/time/tck/java/time/chrono/TCKJapaneseChronology.java</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  o Copyright (c) 2012, 2019, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 /*
  27  * Copyright (c) 2008-2012, Stephen Colebourne &amp; Michael Nascimento Santos
  28  *
  29  * All rights reserved.
  30  *
  31  * Redistribution and use in source and binary forms, with or without
  32  * modification, are permitted provided that the following conditions are met:
  33  *
  34  *  * Redistributions of source code must retain the above copyright notice,
  35  *    this list of conditions and the following disclaimer.
  36  *
  37  *  * Redistributions in binary form must reproduce the above copyright notice,
  38  *    this list of conditions and the following disclaimer in the documentation
  39  *    and/or other materials provided with the distribution.
  40  *
  41  *  * Neither the name of JSR-310 nor the names of its contributors
  42  *    may be used to endorse or promote products derived from this software
  43  *    without specific prior written permission.
  44  *
  45  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
  46  * &quot;AS IS&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
  47  * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
  48  * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR
  49  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
  50  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
  51  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
  52  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
  53  * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
  54  * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
  55  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  56  */
  57 package tck.java.time.chrono;
  58 
  59 import static java.time.temporal.ChronoField.DAY_OF_MONTH;
  60 import static java.time.temporal.ChronoField.DAY_OF_YEAR;
  61 import static java.time.temporal.ChronoField.EPOCH_DAY;
  62 import static java.time.temporal.ChronoField.ERA;
  63 import static java.time.temporal.ChronoField.MONTH_OF_YEAR;
  64 import static java.time.temporal.ChronoField.YEAR;
  65 import static java.time.temporal.ChronoField.YEAR_OF_ERA;
  66 import static org.testng.Assert.assertEquals;
  67 import static org.testng.Assert.assertFalse;
  68 import static org.testng.Assert.assertNotEquals;
  69 import static org.testng.Assert.assertTrue;
  70 import static org.testng.Assert.fail;
  71 
  72 import java.time.Clock;
  73 import java.time.DateTimeException;
  74 import java.time.LocalDate;
  75 import java.time.LocalDateTime;
  76 import java.time.Month;
  77 import java.time.Period;
  78 import java.time.Year;
  79 import java.time.ZoneId;
  80 import java.time.ZoneOffset;
  81 import java.time.chrono.ChronoLocalDate;
  82 import java.time.chrono.ChronoPeriod;
  83 import java.time.chrono.Chronology;
  84 import java.time.chrono.Era;
  85 import java.time.chrono.IsoChronology;
  86 import java.time.chrono.JapaneseChronology;
  87 import java.time.chrono.JapaneseDate;
  88 import java.time.chrono.JapaneseEra;
  89 import java.time.chrono.MinguoChronology;
  90 import java.time.chrono.MinguoDate;
  91 import java.time.chrono.ThaiBuddhistChronology;
  92 import java.time.format.ResolverStyle;
  93 import java.time.temporal.ChronoField;
  94 import java.time.temporal.ChronoUnit;
  95 import java.time.temporal.TemporalAdjusters;
  96 import java.time.temporal.TemporalField;
  97 import java.time.temporal.TemporalQueries;
  98 import java.time.temporal.ValueRange;
  99 
 100 import java.util.HashMap;
 101 import java.util.List;
 102 import java.util.Locale;
 103 import java.util.Map;
 104 
 105 import org.testng.Assert;
 106 import org.testng.annotations.DataProvider;
 107 import org.testng.annotations.Test;
 108 
 109 /**
 110  * Test.
 111  */
 112 @Test
 113 public class TCKJapaneseChronology {
 114 
 115     // Year differences from Gregorian years.
 116     private static final int YDIFF_REIWA = 2018;
 117     private static final int YDIFF_HEISEI = 1988;
 118     private static final int YDIFF_MEIJI = 1867;
 119     private static final int YDIFF_SHOWA = 1925;
 120     private static final int YDIFF_TAISHO = 1911;
 121 
 122     //-----------------------------------------------------------------------
 123     // Chronology.of(String)
 124     //-----------------------------------------------------------------------
 125     @Test
 126     public void test_chrono_byName() {
 127         Chronology c = JapaneseChronology.INSTANCE;
 128         Chronology test = Chronology.of(&quot;Japanese&quot;);
 129         Assert.assertNotNull(test, &quot;The Japanese calendar could not be found byName&quot;);
 130         Assert.assertEquals(test.getId(), &quot;Japanese&quot;, &quot;ID mismatch&quot;);
 131         Assert.assertEquals(test.getCalendarType(), &quot;japanese&quot;, &quot;Type mismatch&quot;);
 132         Assert.assertEquals(test, c);
 133     }
 134 
 135     //-----------------------------------------------------------------------
 136     // Chronology.ofLocale(Locale)
 137     //-----------------------------------------------------------------------
 138     @Test
 139     public void test_chrono_byLocale_fullTag_japaneseCalendarFromJapan() {
 140         Chronology test = Chronology.ofLocale(Locale.forLanguageTag(&quot;ja-JP-u-ca-japanese&quot;));
 141         Assert.assertEquals(test.getId(), &quot;Japanese&quot;);
 142         Assert.assertEquals(test, JapaneseChronology.INSTANCE);
 143     }
 144 
 145     @Test
 146     public void test_chrono_byLocale_fullTag_japaneseCalendarFromElsewhere() {
 147         Chronology test = Chronology.ofLocale(Locale.forLanguageTag(&quot;en-US-u-ca-japanese&quot;));
 148         Assert.assertEquals(test.getId(), &quot;Japanese&quot;);
 149         Assert.assertEquals(test, JapaneseChronology.INSTANCE);
 150     }
 151 
 152     @Test
 153     public void test_chrono_byLocale_oldJP_noVariant() {
 154         Chronology test = Chronology.ofLocale(new Locale(&quot;ja&quot;, &quot;JP&quot;));
 155         Assert.assertEquals(test.getId(), &quot;ISO&quot;);
 156         Assert.assertEquals(test, IsoChronology.INSTANCE);
 157     }
 158 
 159     @Test
 160     public void test_chrono_byLocale_oldJP_variant() {
 161         Chronology test = Chronology.ofLocale(new Locale(&quot;ja&quot;, &quot;JP&quot;, &quot;JP&quot;));
 162         Assert.assertEquals(test.getId(), &quot;Japanese&quot;);
 163         Assert.assertEquals(test, JapaneseChronology.INSTANCE);
 164     }
 165 
 166     @Test
 167     public void test_chrono_byLocale_iso() {
 168         Assert.assertEquals(Chronology.ofLocale(new Locale(&quot;ja&quot;, &quot;JP&quot;)).getId(), &quot;ISO&quot;);
 169         Assert.assertEquals(Chronology.ofLocale(Locale.forLanguageTag(&quot;ja-JP&quot;)).getId(), &quot;ISO&quot;);
 170         Assert.assertEquals(Chronology.ofLocale(Locale.forLanguageTag(&quot;ja-JP-JP&quot;)).getId(), &quot;ISO&quot;);
 171     }
 172 
 173     //-----------------------------------------------------------------------
 174     // creation and cross-checks
 175     //-----------------------------------------------------------------------
 176     @DataProvider(name=&quot;createByEra&quot;)
 177     Object[][] data_createByEra() {
 178         return new Object[][] {
 179                 {JapaneseEra.REIWA, 2020 - YDIFF_REIWA, 2, 29, 60, LocalDate.of(2020, 2, 29)},
 180                 {JapaneseEra.HEISEI, 1996 - YDIFF_HEISEI, 2, 29, 60, LocalDate.of(1996, 2, 29)},
 181                 {JapaneseEra.HEISEI, 2000 - YDIFF_HEISEI, 2, 29, 60, LocalDate.of(2000, 2, 29)},
 182                 {JapaneseEra.MEIJI, 1874 - YDIFF_MEIJI, 2, 28, 59, LocalDate.of(1874, 2, 28)},
 183                 {JapaneseEra.SHOWA, 1928 - YDIFF_SHOWA, 12, 25, 360, LocalDate.of(1928, 12, 25)},
 184                 {JapaneseEra.TAISHO, 1916 - YDIFF_TAISHO, 7, 30, 212, LocalDate.of(1916, 7, 30)},
 185                 {JapaneseEra.MEIJI, 6, 1, 1, 1, LocalDate.of(1873, 1, 1)},
 186                 {JapaneseEra.MEIJI, 45, 7, 29, 211, LocalDate.of(1912, 7, 29)},
 187                 {JapaneseEra.TAISHO, 1, 7, 30, 1, LocalDate.of(1912, 7, 30)},
 188                 {JapaneseEra.TAISHO, 15, 12, 24, 358, LocalDate.of(1926, 12, 24)},
 189                 {JapaneseEra.SHOWA, 1, 12, 25, 1, LocalDate.of(1926, 12, 25)},
 190                 {JapaneseEra.SHOWA, 64, 1, 7, 7, LocalDate.of(1989, 1, 7)},
 191                 {JapaneseEra.HEISEI, 1, 1, 8, 1, LocalDate.of(1989, 1, 8)},
 192         };
 193     }
 194 
 195     @Test(dataProvider=&quot;createByEra&quot;)
 196     public void test_createEymd(JapaneseEra era, int yoe, int moy, int dom, int doy, LocalDate iso) {
 197         JapaneseDate dateByChronoFactory = JapaneseChronology.INSTANCE.date(era, yoe, moy, dom);
 198         JapaneseDate dateByDateFactory = JapaneseDate.of(era, yoe, moy, dom);
 199         assertEquals(dateByChronoFactory, dateByDateFactory);
 200         assertEquals(dateByChronoFactory.hashCode(), dateByDateFactory.hashCode());
 201     }
 202 
 203     @Test(dataProvider=&quot;createByEra&quot;)
 204     public void test_createEyd(JapaneseEra era, int yoe, int moy, int dom, int doy, LocalDate iso) {
 205         JapaneseDate dateByChronoFactory = JapaneseChronology.INSTANCE.dateYearDay(era, yoe, doy);
 206         JapaneseDate dateByDateFactory = JapaneseDate.of(era, yoe, moy, dom);
 207         assertEquals(dateByChronoFactory, dateByDateFactory);
 208         assertEquals(dateByChronoFactory.hashCode(), dateByDateFactory.hashCode());
 209     }
 210 
 211     @Test(dataProvider=&quot;createByEra&quot;)
 212     public void test_createByEra_isEqual(JapaneseEra era, int yoe, int moy, int dom, int doy, LocalDate iso) {
 213         JapaneseDate test = JapaneseDate.of(era, yoe, moy, dom);
 214         assertEquals(test.isEqual(iso), true);
 215         assertEquals(iso.isEqual(test), true);
 216     }
 217 
 218     @Test(dataProvider=&quot;createByEra&quot;)
 219     public void test_createByEra_chronologyTemporalFactory(JapaneseEra era, int yoe, int moy, int dom, int doy, LocalDate iso) {
 220         JapaneseDate test = JapaneseDate.of(era, yoe, moy, dom);
 221         assertEquals(IsoChronology.INSTANCE.date(test), iso);
 222         assertEquals(JapaneseChronology.INSTANCE.date(iso), test);
 223     }
 224 
 225     @Test(dataProvider=&quot;createByEra&quot;)
 226     public void test_createByEra_dateFrom(JapaneseEra era, int yoe, int moy, int dom, int doy, LocalDate iso) {
 227         JapaneseDate test = JapaneseDate.of(era, yoe, moy, dom);
 228         assertEquals(LocalDate.from(test), iso);
 229         assertEquals(JapaneseDate.from(iso), test);
 230     }
 231 
 232     @Test(dataProvider=&quot;createByEra&quot;)
 233     public void test_createByEra_query(JapaneseEra era, int yoe, int moy, int dom, int doy, LocalDate iso) {
 234         JapaneseDate test = JapaneseDate.of(era, yoe, moy, dom);
 235         assertEquals(test.query(TemporalQueries.localDate()), iso);
 236     }
 237 
 238     @Test(dataProvider=&quot;createByEra&quot;)
 239     public void test_createByEra_epochDay(JapaneseEra era, int yoe, int moy, int dom, int doy, LocalDate iso) {
 240         JapaneseDate test = JapaneseDate.of(era, yoe, moy, dom);
 241         assertEquals(test.getLong(EPOCH_DAY), iso.getLong(EPOCH_DAY));
 242         assertEquals(test.toEpochDay(), iso.toEpochDay());
 243     }
 244 
 245     //-----------------------------------------------------------------------
 246     @DataProvider(name=&quot;createByProleptic&quot;)
 247     Object[][] data_createByProleptic() {
 248         return new Object[][] {
 249                 {1928, 2, 28, 59, LocalDate.of(1928, 2, 28)},
 250                 {1928, 2, 29, 60, LocalDate.of(1928, 2, 29)},
 251 
 252                 {1873, 9, 7, 250, LocalDate.of(1873, 9, 7)},
 253                 {1873, 9, 8, 251, LocalDate.of(1873, 9, 8)},
 254                 {1912, 7, 29, 211, LocalDate.of(1912, 7, 29)},
 255                 {1912, 7, 30, 212, LocalDate.of(1912, 7, 30)},
 256                 {1926, 12, 24, 358, LocalDate.of(1926, 12, 24)},
 257                 {1926, 12, 25, 359, LocalDate.of(1926, 12, 25)},
 258                 {1989, 1, 7, 7, LocalDate.of(1989, 1, 7)},
 259                 {1989, 1, 8, 8, LocalDate.of(1989, 1, 8)},
 260         };
 261     }
 262 
 263     @Test(dataProvider=&quot;createByProleptic&quot;)
 264     public void test_createYmd(int y, int moy, int dom, int doy, LocalDate iso) {
 265         JapaneseDate dateByChronoFactory = JapaneseChronology.INSTANCE.date(y, moy, dom);
 266         JapaneseDate dateByDateFactory = JapaneseDate.of(y, moy, dom);
 267         assertEquals(dateByChronoFactory, dateByDateFactory);
 268         assertEquals(dateByChronoFactory.hashCode(), dateByDateFactory.hashCode());
 269     }
 270 
 271     @Test(dataProvider=&quot;createByProleptic&quot;)
 272     public void test_createYd(int y, int moy, int dom, int doy, LocalDate iso) {
 273         JapaneseDate dateByChronoFactory = JapaneseChronology.INSTANCE.dateYearDay(y, doy);
 274         JapaneseDate dateByDateFactory = JapaneseDate.of(y, moy, dom);
 275         assertEquals(dateByChronoFactory, dateByDateFactory);
 276         assertEquals(dateByChronoFactory.hashCode(), dateByDateFactory.hashCode());
 277     }
 278 
 279     @Test(dataProvider=&quot;createByProleptic&quot;)
 280     public void test_createByProleptic_isEqual(int y, int moy, int dom, int doy, LocalDate iso) {
 281         JapaneseDate test = JapaneseDate.of(y, moy, dom);
 282         assertEquals(test.isEqual(iso), true);
 283         assertEquals(iso.isEqual(test), true);
 284     }
 285 
 286     @Test(dataProvider=&quot;createByProleptic&quot;)
 287     public void test_createByProleptic_chronologyTemporalFactory(int y, int moy, int dom, int doy, LocalDate iso) {
 288         JapaneseDate test = JapaneseDate.of(y, moy, dom);
 289         assertEquals(IsoChronology.INSTANCE.date(test), iso);
 290         assertEquals(JapaneseChronology.INSTANCE.date(iso), test);
 291     }
 292 
 293     @Test(dataProvider=&quot;createByProleptic&quot;)
 294     public void test_createByProleptic_dateFrom(int y, int moy, int dom, int doy, LocalDate iso) {
 295         JapaneseDate test = JapaneseDate.of(y, moy, dom);
 296         assertEquals(LocalDate.from(test), iso);
 297         assertEquals(JapaneseDate.from(iso), test);
 298     }
 299 
 300     @Test(dataProvider=&quot;createByProleptic&quot;)
 301     public void test_createByProleptic_query(int y, int moy, int dom, int doy, LocalDate iso) {
 302         JapaneseDate test = JapaneseDate.of(y, moy, dom);
 303         assertEquals(test.query(TemporalQueries.localDate()), iso);
 304     }
 305 
 306     @Test(dataProvider=&quot;createByProleptic&quot;)
 307     public void test_createByProleptic_epochDay(int y, int moy, int dom, int doy, LocalDate iso) {
 308         JapaneseDate test = JapaneseDate.of(y, moy, dom);
 309         assertEquals(test.getLong(EPOCH_DAY), iso.getLong(EPOCH_DAY));
 310         assertEquals(test.toEpochDay(), iso.toEpochDay());
 311     }
 312 
 313     //-----------------------------------------------------------------------
 314     @Test
 315     public void test_dateNow(){
 316         assertEquals(JapaneseChronology.INSTANCE.dateNow(), JapaneseDate.now()) ;
 317         assertEquals(JapaneseChronology.INSTANCE.dateNow(), JapaneseDate.now(ZoneId.systemDefault())) ;
 318         assertEquals(JapaneseChronology.INSTANCE.dateNow(), JapaneseDate.now(Clock.systemDefaultZone())) ;
 319         assertEquals(JapaneseChronology.INSTANCE.dateNow(), JapaneseDate.now(Clock.systemDefaultZone().getZone())) ;
 320 
 321         assertEquals(JapaneseChronology.INSTANCE.dateNow(), JapaneseChronology.INSTANCE.dateNow(ZoneId.systemDefault())) ;
 322         assertEquals(JapaneseChronology.INSTANCE.dateNow(), JapaneseChronology.INSTANCE.dateNow(Clock.systemDefaultZone())) ;
 323         assertEquals(JapaneseChronology.INSTANCE.dateNow(), JapaneseChronology.INSTANCE.dateNow(Clock.systemDefaultZone().getZone())) ;
 324 
 325         ZoneId zoneId = ZoneId.of(&quot;Europe/Paris&quot;);
 326         assertEquals(JapaneseChronology.INSTANCE.dateNow(zoneId), JapaneseChronology.INSTANCE.dateNow(Clock.system(zoneId))) ;
 327         assertEquals(JapaneseChronology.INSTANCE.dateNow(zoneId), JapaneseChronology.INSTANCE.dateNow(Clock.system(zoneId).getZone())) ;
 328         assertEquals(JapaneseChronology.INSTANCE.dateNow(zoneId), JapaneseDate.now(Clock.system(zoneId))) ;
 329         assertEquals(JapaneseChronology.INSTANCE.dateNow(zoneId), JapaneseDate.now(Clock.system(zoneId).getZone())) ;
 330 
 331         assertEquals(JapaneseChronology.INSTANCE.dateNow(ZoneId.of(ZoneOffset.UTC.getId())), JapaneseChronology.INSTANCE.dateNow(Clock.systemUTC())) ;
 332     }
 333 
 334     //-----------------------------------------------------------------------
 335     @DataProvider(name=&quot;badDates&quot;)
 336     Object[][] data_badDates() {
 337         return new Object[][] {
 338             {1928, 0, 0},
 339 
 340             {1928, -1, 1},
 341             {1928, 0, 1},
 342             {1928, 14, 1},
 343             {1928, 15, 1},
 344 
 345             {1928, 1, -1},
 346             {1928, 1, 0},
 347             {1928, 1, 32},
 348 
 349             {1928, 12, -1},
 350             {1928, 12, 0},
 351             {1928, 12, 32},
 352 
 353             {1725, 2, 29},
 354             {500, 2, 29},
 355             {2100, 2, 29},
 356 
 357             {1872, 12, 31},     // Last day of MEIJI 5
 358         };
 359     }
 360 
 361     @Test(dataProvider=&quot;badDates&quot;, expectedExceptions=DateTimeException.class)
 362     public void test_badDates(int year, int month, int dom) {
 363         JapaneseChronology.INSTANCE.date(year, month, dom);
 364     }
 365 
 366     //-----------------------------------------------------------------------
 367     // prolepticYear() and is LeapYear()
 368     //-----------------------------------------------------------------------
 369     @DataProvider(name=&quot;prolepticYear&quot;)
 370     Object[][] data_prolepticYear() {
 371         return new Object[][] {
 372                 {3, JapaneseEra.REIWA, 1, 1 + YDIFF_REIWA, false},
 373                 {3, JapaneseEra.REIWA, 102, 102 + YDIFF_REIWA, true},
 374 
 375                 {2, JapaneseEra.HEISEI, 1, 1 + YDIFF_HEISEI, false},
 376                 {2, JapaneseEra.HEISEI, 4, 4 + YDIFF_HEISEI, true},
 377 
 378                 {-1, JapaneseEra.MEIJI, 9, 9 + YDIFF_MEIJI, true},
 379                 {-1, JapaneseEra.MEIJI, 10, 10 + YDIFF_MEIJI, false},
 380 
 381                 {1, JapaneseEra.SHOWA, 1, 1 + YDIFF_SHOWA, false},
 382                 {1, JapaneseEra.SHOWA, 7, 7 + YDIFF_SHOWA, true},
 383 
 384                 {0, JapaneseEra.TAISHO, 1, 1 + YDIFF_TAISHO, true},
 385                 {0, JapaneseEra.TAISHO, 4, 4 + YDIFF_TAISHO, false},
 386         };
 387     }
 388 
 389     @Test(dataProvider=&quot;prolepticYear&quot;)
 390     public void test_prolepticYear(int eraValue, Era  era, int yearOfEra, int expectedProlepticYear, boolean isLeapYear) {
 391         Era eraObj = JapaneseChronology.INSTANCE.eraOf(eraValue);
 392         assertTrue(JapaneseChronology.INSTANCE.eras().contains(eraObj));
 393         assertEquals(eraObj, era);
 394         assertEquals(JapaneseChronology.INSTANCE.prolepticYear(era, yearOfEra), expectedProlepticYear);
 395     }
 396 
 397     @Test(dataProvider=&quot;prolepticYear&quot;)
 398     public void test_isLeapYear(int eraValue, Era  era, int yearOfEra, int expectedProlepticYear, boolean isLeapYear) {
 399         assertEquals(JapaneseChronology.INSTANCE.isLeapYear(expectedProlepticYear), isLeapYear);
 400         assertEquals(JapaneseChronology.INSTANCE.isLeapYear(expectedProlepticYear), Year.of(expectedProlepticYear).isLeap());
 401 
 402         JapaneseDate jdate = JapaneseDate.now();
 403         jdate = jdate.with(ChronoField.YEAR, expectedProlepticYear).with(ChronoField.MONTH_OF_YEAR, 2);
 404         if (isLeapYear) {
 405             assertEquals(jdate.lengthOfMonth(), 29);
 406         } else {
 407             assertEquals(jdate.lengthOfMonth(), 28);
 408         }
 409     }
 410 
 411     @DataProvider(name=&quot;prolepticYearError&quot;)
 412     Object[][] data_prolepticYearError() {
 413         return new Object[][] {
 414                 {JapaneseEra.MEIJI, 100},
 415                 {JapaneseEra.MEIJI, 0},
 416                 {JapaneseEra.MEIJI, -10},
 417 
 418                 {JapaneseEra.SHOWA, 100},
 419                 {JapaneseEra.SHOWA, 0},
 420                 {JapaneseEra.SHOWA, -10},
 421 
 422                 {JapaneseEra.TAISHO, 100},
 423                 {JapaneseEra.TAISHO, 0},
 424                 {JapaneseEra.TAISHO, -10},
 425         };
 426     }
 427 
 428     @Test(dataProvider=&quot;prolepticYearError&quot;, expectedExceptions=DateTimeException.class)
 429     public void test_prolepticYearError(Era era, int yearOfEra) {
 430         JapaneseChronology.INSTANCE.prolepticYear(era, yearOfEra);
 431     }
 432 
 433     //-----------------------------------------------------------------------
 434     // Bad Era for Chronology.date(era,...) and Chronology.prolepticYear(Era,...)
 435     //-----------------------------------------------------------------------
 436     @Test
 437     public void test_InvalidEras() {
 438         // Verify that the eras from every other Chronology are invalid
 439         for (Chronology chrono : Chronology.getAvailableChronologies()) {
 440             if (chrono instanceof JapaneseChronology) {
 441                 continue;
 442             }
 443             List&lt;Era&gt; eras = chrono.eras();
 444             for (Era era : eras) {
 445                 try {
 446                     ChronoLocalDate date = JapaneseChronology.INSTANCE.date(era, 1, 1, 1);
 447                     fail(&quot;JapaneseChronology.date did not throw ClassCastException for Era: &quot; + era);
 448                 } catch (ClassCastException cex) {
 449                     ; // ignore expected exception
 450                 }
 451                 try {
 452                     @SuppressWarnings(&quot;unused&quot;)
 453                     int year = JapaneseChronology.INSTANCE.prolepticYear(era, 1);
 454                     fail(&quot;JapaneseChronology.prolepticYear did not throw ClassCastException for Era: &quot; + era);
 455                 } catch (ClassCastException cex) {
 456                     ; // ignore expected exception
 457                 }
 458 
 459             }
 460         }
 461     }
 462 
 463     //-----------------------------------------------------------------------
 464     // get(TemporalField)
 465     //-----------------------------------------------------------------------
 466     @Test
 467     public void test_getLong() {
 468         JapaneseDate base = JapaneseChronology.INSTANCE.date(JapaneseEra.SHOWA, 63, 6, 30);
 469         assertEquals(base.getLong(ERA), JapaneseEra.SHOWA.getValue());
 470         assertEquals(base.getLong(YEAR), 1988L);
 471         assertEquals(base.getLong(YEAR_OF_ERA), 63L);
 472         assertEquals(base.getLong(MONTH_OF_YEAR), 6L);
 473         assertEquals(base.getLong(DAY_OF_MONTH), 30L);
 474     }
 475 
 476     //-----------------------------------------------------------------------
 477     // with(TemporalField, long)
 478     //-----------------------------------------------------------------------
 479     @Test
 480     public void test_with_TemporalField_long() {
 481         JapaneseDate base = JapaneseChronology.INSTANCE.date(JapaneseEra.SHOWA, 63, 6, 30);
 482         JapaneseDate test = base.with(YEAR, 1987);
 483         assertEquals(test, JapaneseChronology.INSTANCE.date(JapaneseEra.SHOWA, 62, 6, 30));
 484 
 485         test = test.with(YEAR_OF_ERA, 2);
 486         assertEquals(test, JapaneseChronology.INSTANCE.date(JapaneseEra.SHOWA, 2, 6, 30));
 487 
 488         test = test.with(ERA, JapaneseEra.HEISEI.getValue());
 489         assertEquals(test, JapaneseChronology.INSTANCE.date(JapaneseEra.HEISEI, 2, 6, 30));
 490 
 491         test = test.with(MONTH_OF_YEAR, 3);
 492         assertEquals(test, JapaneseChronology.INSTANCE.date(JapaneseEra.HEISEI, 2, 3, 30));
 493 
 494         test = test.with(DAY_OF_MONTH, 4);
 495         assertEquals(test, JapaneseChronology.INSTANCE.date(JapaneseEra.HEISEI, 2, 3, 4));
 496     }
 497 
 498     //-----------------------------------------------------------------------
 499     // with(WithAdjuster)
 500     //-----------------------------------------------------------------------
 501     @Test
 502     public void test_adjust1() {
 503         JapaneseDate base = JapaneseChronology.INSTANCE.date(1928, 10, 29);
 504         JapaneseDate test = base.with(TemporalAdjusters.lastDayOfMonth());
 505         assertEquals(test, JapaneseChronology.INSTANCE.date(1928, 10, 31));
 506     }
 507 
 508     @Test
 509     public void test_adjust2() {
 510         JapaneseDate base = JapaneseChronology.INSTANCE.date(1928, 12, 2);
 511         JapaneseDate test = base.with(TemporalAdjusters.lastDayOfMonth());
 512         assertEquals(test, JapaneseChronology.INSTANCE.date(1928, 12, 31));
 513     }
 514 
 515     //-----------------------------------------------------------------------
 516     // JapaneseDate.with(Local*)
 517     //-----------------------------------------------------------------------
 518     @Test
 519     public void test_adjust_toLocalDate() {
 520         JapaneseDate jdate = JapaneseChronology.INSTANCE.date(1926, 1, 4);
 521         JapaneseDate test = jdate.with(LocalDate.of(2012, 7, 6));
 522         assertEquals(test, JapaneseChronology.INSTANCE.date(2012, 7, 6));
 523     }
 524 
 525     @Test(expectedExceptions=DateTimeException.class)
 526     public void test_adjust_toMonth() {
 527         JapaneseDate jdate = JapaneseChronology.INSTANCE.date(1926, 1, 4);
 528         jdate.with(Month.APRIL);
 529     }
 530 
 531     //-----------------------------------------------------------------------
 532     // LocalDate.with(JapaneseDate)
 533     //-----------------------------------------------------------------------
 534     @Test
 535     public void test_LocalDate_adjustToJapaneseDate() {
 536         JapaneseDate jdate = JapaneseChronology.INSTANCE.date(1928, 10, 29);
 537         LocalDate test = LocalDate.MIN.with(jdate);
 538         assertEquals(test, LocalDate.of(1928, 10, 29));
 539     }
 540 
 541     @Test
 542     public void test_LocalDateTime_adjustToJapaneseDate() {
 543         JapaneseDate jdate = JapaneseChronology.INSTANCE.date(1928, 10, 29);
 544         LocalDateTime test = LocalDateTime.MIN.with(jdate);
 545         assertEquals(test, LocalDateTime.of(1928, 10, 29, 0, 0));
 546     }
 547 
 548     //-----------------------------------------------------------------------
 549     // Check Japanese Eras
 550     //-----------------------------------------------------------------------
 551     @DataProvider(name=&quot;japaneseEras&quot;)
 552     Object[][] data_japanseseEras() {
 553         return new Object[][] {
 554             { JapaneseEra.MEIJI, -1, &quot;Meiji&quot;},
 555             { JapaneseEra.TAISHO, 0, &quot;Taisho&quot;},
 556             { JapaneseEra.SHOWA, 1, &quot;Showa&quot;},
 557             { JapaneseEra.HEISEI, 2, &quot;Heisei&quot;},
 558             { JapaneseEra.REIWA, 3, &quot;Reiwa&quot;},
 559         };
 560     }
 561 
 562     @Test(dataProvider=&quot;japaneseEras&quot;)
 563     public void test_Japanese_Eras(Era era, int eraValue, String name) {
 564         assertEquals(era.getValue(), eraValue, &quot;EraValue&quot;);
 565         assertEquals(era.toString(), name, &quot;Era Name&quot;);
 566         assertEquals(era, JapaneseChronology.INSTANCE.eraOf(eraValue), &quot;JapaneseChronology.eraOf()&quot;);
 567         List&lt;Era&gt; eras = JapaneseChronology.INSTANCE.eras();
 568         assertTrue(eras.contains(era), &quot;Era is not present in JapaneseChronology.INSTANCE.eras()&quot;);
 569     }
 570 
 571     @Test
 572     public void test_Japanese_badEras() {
 573         int badEras[] = {-1000, -998, -997, -2, 4, 5, 1000};
 574         for (int badEra : badEras) {
 575             try {
 576                 Era era = JapaneseChronology.INSTANCE.eraOf(badEra);
 577                 fail(&quot;JapaneseChronology.eraOf returned &quot; + era + &quot; + for invalid eraValue &quot; + badEra);
 578             } catch (DateTimeException ex) {
 579                 // ignore expected exception
 580             }
 581         }
 582     }
 583 
 584     @Test(dataProvider=&quot;japaneseEras&quot;)
 585     public void test_JapaneseEra_singletons(Era expectedEra, int eraValue, String name) {
 586         JapaneseEra actualEra = JapaneseEra.valueOf(name);
 587         assertEquals(actualEra, expectedEra, &quot;JapaneseEra.valueOf(name)&quot;);
 588 
 589         actualEra = JapaneseEra.of(eraValue);
 590         assertEquals(actualEra, expectedEra, &quot;JapaneseEra.of(value)&quot;);
 591 
 592         String string = actualEra.toString();
 593         assertEquals(string, name, &quot;JapaneseEra.toString()&quot;);
 594     }
 595 
 596     @Test
 597     public void test_JapaneseEra_values() {
 598         JapaneseEra[] actualEras = JapaneseEra.values();
 599         Object[][] erasInfo = data_japanseseEras();
 600         assertEquals(actualEras.length, erasInfo.length, &quot;Wrong number of Eras&quot;);
 601 
 602         for (int i = 0; i &lt; erasInfo.length; i++) {
 603             Object[] eraInfo = erasInfo[i];
 604             assertEquals(actualEras[i], eraInfo[0], &quot;Singleton mismatch&quot;);
 605         }
 606     }
 607 
 608     @Test
 609     public void test_JapaneseChronology_eras() {
 610         List&lt;Era&gt; actualEras = JapaneseChronology.INSTANCE.eras();
 611         Object[][] erasInfo = data_japanseseEras();
 612         assertEquals(actualEras.size(), erasInfo.length, &quot;Wrong number of Eras&quot;);
 613 
 614         for (int i = 0; i &lt; erasInfo.length; i++) {
 615             Object[] eraInfo = erasInfo[i];
 616             assertEquals(actualEras.get(i), eraInfo[0], &quot;Singleton mismatch&quot;);
 617         }
 618     }
 619 
 620     //-----------------------------------------------------------------------
 621     // PeriodUntil()
 622     //-----------------------------------------------------------------------
 623     @Test
 624     public void test_periodUntilDate() {
 625         JapaneseDate mdate1 = JapaneseDate.of(1970, 1, 1);
 626         JapaneseDate mdate2 = JapaneseDate.of(1971, 2, 2);
 627         ChronoPeriod period = mdate1.until(mdate2);
 628         assertEquals(period, JapaneseChronology.INSTANCE.period(1, 1, 1));
 629     }
 630 
 631     @Test
 632     public void test_periodUntilUnit() {
 633         JapaneseDate mdate1 = JapaneseDate.of(1970, 1, 1);
 634         JapaneseDate mdate2 = JapaneseDate.of(1971, 2, 2);
 635         long months = mdate1.until(mdate2, ChronoUnit.MONTHS);
 636         assertEquals(months, 13);
 637     }
 638 
 639     @Test
 640     public void test_periodUntilDiffChrono() {
 641         JapaneseDate mdate1 = JapaneseDate.of(1970, 1, 1);
 642         JapaneseDate mdate2 = JapaneseDate.of(1971, 2, 2);
 643         MinguoDate ldate2 = MinguoChronology.INSTANCE.date(mdate2);
 644         ChronoPeriod period = mdate1.until(ldate2);
 645         assertEquals(period, JapaneseChronology.INSTANCE.period(1, 1, 1));
 646     }
 647 
 648     //-----------------------------------------------------------------------
 649     // JapaneseChronology.dateYearDay, getDayOfYear
 650     //-----------------------------------------------------------------------
 651     @Test
 652     public void test_getDayOfYear() {
 653         // Test all the Eras
 654         for (JapaneseEra era : JapaneseEra.values()) {
 655             int firstYear = (era == JapaneseEra.MEIJI) ? 6 : 1;  // Until Era supports range(YEAR_OF_ERA)
 656             JapaneseDate hd1 = JapaneseChronology.INSTANCE.dateYearDay(era, firstYear, 1);
 657             ValueRange range = hd1.range(DAY_OF_YEAR);
 658             assertEquals(range.getMaximum(), hd1.lengthOfYear(), &quot;lengthOfYear should match range.getMaximum()&quot;);
 659 
 660             for (int i = 1; i &lt;= hd1.lengthOfYear(); i++) {
 661                 JapaneseDate hd = JapaneseChronology.INSTANCE.dateYearDay(era, firstYear, i);
 662                 int doy = hd.get(DAY_OF_YEAR);
 663                 assertEquals(doy, i, &quot;get(DAY_OF_YEAR) incorrect for &quot; + i + &quot;, of date: &quot; + hd);
 664             }
 665         }
 666     }
 667 
 668     @Test
 669     public void test_withDayOfYear() {
 670         JapaneseDate hd = JapaneseChronology.INSTANCE.dateYearDay(1990, 1);
 671         for (int i = 1; i &lt;= hd.lengthOfYear(); i++) {
 672             JapaneseDate hd2 = hd.with(DAY_OF_YEAR, i);
 673             int doy = hd2.get(DAY_OF_YEAR);
 674             assertEquals(doy, i, &quot;with(DAY_OF_YEAR) incorrect for &quot; + i + &quot; &quot; + hd2);
 675         }
 676     }
 677 
 678     //-----------------------------------------------------------------------
 679     // toString()
 680     //-----------------------------------------------------------------------
 681     @DataProvider(name=&quot;toString&quot;)
 682     Object[][] data_toString() {
 683         return new Object[][] {
 684             {JapaneseChronology.INSTANCE.date(1873, 12,  5), &quot;Japanese Meiji 6-12-05&quot;},
 685             {JapaneseChronology.INSTANCE.date(1873, 12,  6), &quot;Japanese Meiji 6-12-06&quot;},
 686             {JapaneseChronology.INSTANCE.date(1873,  9,  8), &quot;Japanese Meiji 6-09-08&quot;},
 687             {JapaneseChronology.INSTANCE.date(1912,  7, 29), &quot;Japanese Meiji 45-07-29&quot;},
 688             {JapaneseChronology.INSTANCE.date(1912,  7, 30), &quot;Japanese Taisho 1-07-30&quot;},
 689             {JapaneseChronology.INSTANCE.date(1926, 12, 24), &quot;Japanese Taisho 15-12-24&quot;},
 690             {JapaneseChronology.INSTANCE.date(1926, 12, 25), &quot;Japanese Showa 1-12-25&quot;},
 691             {JapaneseChronology.INSTANCE.date(1989,  1,  7), &quot;Japanese Showa 64-01-07&quot;},
 692             {JapaneseChronology.INSTANCE.date(1989,  1,  8), &quot;Japanese Heisei 1-01-08&quot;},
 693             {JapaneseChronology.INSTANCE.date(2012, 12,  6), &quot;Japanese Heisei 24-12-06&quot;},
 694             {JapaneseChronology.INSTANCE.date(2020,  1,  6), &quot;Japanese Reiwa 2-01-06&quot;},
 695         };
 696     }
 697 
 698     @Test(dataProvider=&quot;toString&quot;)
 699     public void test_toString(JapaneseDate jdate, String expected) {
 700         assertEquals(jdate.toString(), expected);
 701     }
 702 
 703     //-----------------------------------------------------------------------
 704     // equals()
 705     //-----------------------------------------------------------------------
 706     @Test
 707     public void test_equals_true() {
 708         assertTrue(JapaneseChronology.INSTANCE.equals(JapaneseChronology.INSTANCE));
 709     }
 710 
 711     @Test
 712     public void test_equals_false() {
 713         assertFalse(JapaneseChronology.INSTANCE.equals(IsoChronology.INSTANCE));
 714     }
 715 
 716     //-----------------------------------------------------------------------
 717     //-----------------------------------------------------------------------
 718     @DataProvider(name = &quot;resolve_styleByEra&quot;)
 719     Object[][] data_resolve_styleByEra() {
 720         Object[][] result = new Object[ResolverStyle.values().length * JapaneseEra.values().length][];
 721         int i = 0;
 722         for (ResolverStyle style : ResolverStyle.values()) {
 723             for (JapaneseEra era : JapaneseEra.values()) {
 724                 result[i++] = new Object[] {style, era};
 725             }
 726         }
 727         return result;
 728     }
 729 
 730     @Test(dataProvider = &quot;resolve_styleByEra&quot;)
 731     public void test_resolve_yearOfEra_eraOnly_valid(ResolverStyle style, JapaneseEra era) {
 732         Map&lt;TemporalField, Long&gt; fieldValues = new HashMap&lt;&gt;();
 733         fieldValues.put(ChronoField.ERA, (long) era.getValue());
 734         JapaneseDate date = JapaneseChronology.INSTANCE.resolveDate(fieldValues, style);
 735         assertEquals(date, null);
 736         assertEquals(fieldValues.get(ChronoField.ERA), (Long) (long) era.getValue());
 737         assertEquals(fieldValues.size(), 1);
 738     }
 739 
 740     @Test(dataProvider = &quot;resolve_styleByEra&quot;)
 741     public void test_resolve_yearOfEra_eraAndYearOfEraOnly_valid(ResolverStyle style, JapaneseEra era) {
 742         Map&lt;TemporalField, Long&gt; fieldValues = new HashMap&lt;&gt;();
 743         fieldValues.put(ChronoField.ERA, (long) era.getValue());
 744         fieldValues.put(ChronoField.YEAR_OF_ERA, 1L);
 745         JapaneseDate date = JapaneseChronology.INSTANCE.resolveDate(fieldValues, style);
 746         assertEquals(date, null);
 747         assertEquals(fieldValues.get(ChronoField.ERA), (Long) (long) era.getValue());
 748         assertEquals(fieldValues.get(ChronoField.YEAR_OF_ERA), (Long) 1L);
 749         assertEquals(fieldValues.size(), 2);
 750     }
 751 
 752     @Test(dataProvider = &quot;resolve_styleByEra&quot;)
 753     public void test_resolve_yearOfEra_eraAndYearOnly_valid(ResolverStyle style, JapaneseEra era) {
 754         Map&lt;TemporalField, Long&gt; fieldValues = new HashMap&lt;&gt;();
 755         fieldValues.put(ChronoField.ERA, (long) era.getValue());
 756         fieldValues.put(ChronoField.YEAR, 1L);
 757         JapaneseDate date = JapaneseChronology.INSTANCE.resolveDate(fieldValues, style);
 758         assertEquals(date, null);
 759         assertEquals(fieldValues.get(ChronoField.ERA), (Long) (long) era.getValue());
 760         assertEquals(fieldValues.get(ChronoField.YEAR), (Long) 1L);
 761         assertEquals(fieldValues.size(), 2);
 762     }
 763 
 764     @DataProvider(name = &quot;resolve_styles&quot;)
 765     Object[][] data_resolve_styles() {
 766         Object[][] result = new Object[ResolverStyle.values().length][];
 767         int i = 0;
 768         for (ResolverStyle style : ResolverStyle.values()) {
 769             result[i++] = new Object[] {style};
 770         }
 771         return result;
 772     }
 773 
 774     @Test(dataProvider = &quot;resolve_styles&quot;)
 775     public void test_resolve_yearOfEra_yearOfEraOnly_valid(ResolverStyle style) {
 776         Map&lt;TemporalField, Long&gt; fieldValues = new HashMap&lt;&gt;();
 777         fieldValues.put(ChronoField.YEAR_OF_ERA, 1L);
 778         JapaneseDate date = JapaneseChronology.INSTANCE.resolveDate(fieldValues, style);
 779         assertEquals(date, null);
 780         assertEquals(fieldValues.get(ChronoField.YEAR_OF_ERA), (Long) 1L);
 781         assertEquals(fieldValues.size(), 1);
 782     }
 783 
 784     @Test(dataProvider = &quot;resolve_styles&quot;)
 785     public void test_resolve_yearOfEra_yearOfEraAndYearOnly_valid(ResolverStyle style) {
 786         Map&lt;TemporalField, Long&gt; fieldValues = new HashMap&lt;&gt;();
 787         fieldValues.put(ChronoField.YEAR_OF_ERA, 1L);
 788         fieldValues.put(ChronoField.YEAR, 2012L);
 789         JapaneseDate date = JapaneseChronology.INSTANCE.resolveDate(fieldValues, style);
 790         assertEquals(date, null);
 791         assertEquals(fieldValues.get(ChronoField.YEAR_OF_ERA), (Long) 1L);
 792         assertEquals(fieldValues.get(ChronoField.YEAR), (Long) 2012L);
 793         assertEquals(fieldValues.size(), 2);
 794     }
 795 
 796     public void test_resolve_yearOfEra_eraOnly_invalidTooSmall() {
 797         for (ResolverStyle style : ResolverStyle.values()) {
 798             Map&lt;TemporalField, Long&gt; fieldValues = new HashMap&lt;&gt;();
 799             fieldValues.put(ChronoField.ERA, JapaneseEra.MEIJI.getValue() - 1L);
 800             try {
 801                 JapaneseChronology.INSTANCE.resolveDate(fieldValues, style);
 802                 fail(&quot;Should have failed: &quot; + style);
 803             } catch (DateTimeException ex) {
 804                 // expected
 805             }
 806         }
 807     }
 808 
 809     public void test_resolve_yearOfEra_eraOnly_invalidTooLarge() {
 810         for (ResolverStyle style : ResolverStyle.values()) {
 811             Map&lt;TemporalField, Long&gt; fieldValues = new HashMap&lt;&gt;();
 812             fieldValues.put(ChronoField.ERA, JapaneseEra.values()[JapaneseEra.values().length - 1].getValue() + 1L);
 813             try {
 814                 JapaneseChronology.INSTANCE.resolveDate(fieldValues, style);
 815                 fail(&quot;Should have failed: &quot; + style);
 816             } catch (DateTimeException ex) {
 817                 // expected
 818             }
 819         }
 820     }
 821 
 822     //-----------------------------------------------------------------------
 823     //-----------------------------------------------------------------------
 824     @DataProvider(name = &quot;resolve_ymd&quot;)
 825     Object[][] data_resolve_ymd() {
 826         return new Object[][] {
 827                 {2012, 1, -365, date(2010, 12, 31), false, false},
 828                 {2012, 1, -364, date(2011, 1, 1), false, false},
 829                 {2012, 1, -31, date(2011, 11, 30), false, false},
 830                 {2012, 1, -30, date(2011, 12, 1), false, false},
 831                 {2012, 1, -12, date(2011, 12, 19), false, false},
 832                 {2012, 1, 1, date(2012, 1, 1), true, true},
 833                 {2012, 1, 59, date(2012, 2, 28), false, false},
 834                 {2012, 1, 60, date(2012, 2, 29), false, false},
 835                 {2012, 1, 61, date(2012, 3, 1), false, false},
 836                 {2012, 1, 365, date(2012, 12, 30), false, false},
 837                 {2012, 1, 366, date(2012, 12, 31), false, false},
 838                 {2012, 1, 367, date(2013, 1, 1), false, false},
 839                 {2012, 1, 367 + 364, date(2013, 12, 31), false, false},
 840                 {2012, 1, 367 + 365, date(2014, 1, 1), false, false},
 841 
 842                 {2012, 2, 1, date(2012, 2, 1), true, true},
 843                 {2012, 2, 28, date(2012, 2, 28), true, true},
 844                 {2012, 2, 29, date(2012, 2, 29), true, true},
 845                 {2012, 2, 30, date(2012, 3, 1), date(2012, 2, 29), false},
 846                 {2012, 2, 31, date(2012, 3, 2), date(2012, 2, 29), false},
 847                 {2012, 2, 32, date(2012, 3, 3), false, false},
 848 
 849                 {2012, -12, 1, date(2010, 12, 1), false, false},
 850                 {2012, -11, 1, date(2011, 1, 1), false, false},
 851                 {2012, -1, 1, date(2011, 11, 1), false, false},
 852                 {2012, 0, 1, date(2011, 12, 1), false, false},
 853                 {2012, 1, 1, date(2012, 1, 1), true, true},
 854                 {2012, 12, 1, date(2012, 12, 1), true, true},
 855                 {2012, 13, 1, date(2013, 1, 1), false, false},
 856                 {2012, 24, 1, date(2013, 12, 1), false, false},
 857                 {2012, 25, 1, date(2014, 1, 1), false, false},
 858 
 859                 {2012, 6, -31, date(2012, 4, 30), false, false},
 860                 {2012, 6, -30, date(2012, 5, 1), false, false},
 861                 {2012, 6, -1, date(2012, 5, 30), false, false},
 862                 {2012, 6, 0, date(2012, 5, 31), false, false},
 863                 {2012, 6, 1, date(2012, 6, 1), true, true},
 864                 {2012, 6, 30, date(2012, 6, 30), true, true},
 865                 {2012, 6, 31, date(2012, 7, 1), date(2012, 6, 30), false},
 866                 {2012, 6, 61, date(2012, 7, 31), false, false},
 867                 {2012, 6, 62, date(2012, 8, 1), false, false},
 868 
 869                 {2011, 2, 1, date(2011, 2, 1), true, true},
 870                 {2011, 2, 28, date(2011, 2, 28), true, true},
 871                 {2011, 2, 29, date(2011, 3, 1), date(2011, 2, 28), false},
 872                 {2011, 2, 30, date(2011, 3, 2), date(2011, 2, 28), false},
 873                 {2011, 2, 31, date(2011, 3, 3), date(2011, 2, 28), false},
 874                 {2011, 2, 32, date(2011, 3, 4), false, false},
 875         };
 876     }
 877 
 878     @Test(dataProvider = &quot;resolve_ymd&quot;)
 879     public void test_resolve_ymd_lenient(int y, int m, int d, JapaneseDate expected, Object smart, boolean strict) {
 880         Map&lt;TemporalField, Long&gt; fieldValues = new HashMap&lt;&gt;();
 881         fieldValues.put(ChronoField.YEAR, (long) y);
 882         fieldValues.put(ChronoField.MONTH_OF_YEAR, (long) m);
 883         fieldValues.put(ChronoField.DAY_OF_MONTH, (long) d);
 884         JapaneseDate date = JapaneseChronology.INSTANCE.resolveDate(fieldValues, ResolverStyle.LENIENT);
 885         assertEquals(date, expected);
 886         assertEquals(fieldValues.size(), 0);
 887     }
 888 
 889     @Test(dataProvider = &quot;resolve_ymd&quot;)
 890     public void test_resolve_ymd_smart(int y, int m, int d, JapaneseDate expected, Object smart, boolean strict) {
 891         Map&lt;TemporalField, Long&gt; fieldValues = new HashMap&lt;&gt;();
 892         fieldValues.put(ChronoField.YEAR, (long) y);
 893         fieldValues.put(ChronoField.MONTH_OF_YEAR, (long) m);
 894         fieldValues.put(ChronoField.DAY_OF_MONTH, (long) d);
 895         if (Boolean.TRUE.equals(smart)) {
 896             JapaneseDate date = JapaneseChronology.INSTANCE.resolveDate(fieldValues, ResolverStyle.SMART);
 897             assertEquals(date, expected);
 898             assertEquals(fieldValues.size(), 0);
 899         } else if (smart instanceof JapaneseDate) {
 900             JapaneseDate date = JapaneseChronology.INSTANCE.resolveDate(fieldValues, ResolverStyle.SMART);
 901             assertEquals(date, smart);
 902         } else {
 903             try {
 904                 JapaneseChronology.INSTANCE.resolveDate(fieldValues, ResolverStyle.SMART);
 905                 fail(&quot;Should have failed&quot;);
 906             } catch (DateTimeException ex) {
 907                 // expected
 908             }
 909         }
 910     }
 911 
 912     @Test(dataProvider = &quot;resolve_ymd&quot;)
 913     public void test_resolve_ymd_strict(int y, int m, int d, JapaneseDate expected, Object smart, boolean strict) {
 914         Map&lt;TemporalField, Long&gt; fieldValues = new HashMap&lt;&gt;();
 915         fieldValues.put(ChronoField.YEAR, (long) y);
 916         fieldValues.put(ChronoField.MONTH_OF_YEAR, (long) m);
 917         fieldValues.put(ChronoField.DAY_OF_MONTH, (long) d);
 918         if (strict) {
 919             JapaneseDate date = JapaneseChronology.INSTANCE.resolveDate(fieldValues, ResolverStyle.STRICT);
 920             assertEquals(date, expected);
 921             assertEquals(fieldValues.size(), 0);
 922         } else {
 923             try {
 924                 JapaneseChronology.INSTANCE.resolveDate(fieldValues, ResolverStyle.STRICT);
 925                 fail(&quot;Should have failed&quot;);
 926             } catch (DateTimeException ex) {
 927                 // expected
 928             }
 929         }
 930     }
 931 
 932     //-----------------------------------------------------------------------
 933     //-----------------------------------------------------------------------
 934     @DataProvider(name = &quot;resolve_yd&quot;)
 935     Object[][] data_resolve_yd() {
 936         return new Object[][] {
 937                 {2012, -365, date(2010, 12, 31), false, false},
 938                 {2012, -364, date(2011, 1, 1), false, false},
 939                 {2012, -31, date(2011, 11, 30), false, false},
 940                 {2012, -30, date(2011, 12, 1), false, false},
 941                 {2012, -12, date(2011, 12, 19), false, false},
 942                 {2012, -1, date(2011, 12, 30), false, false},
 943                 {2012, 0, date(2011, 12, 31), false, false},
 944                 {2012, 1, date(2012, 1, 1), true, true},
 945                 {2012, 2, date(2012, 1, 2), true, true},
 946                 {2012, 31, date(2012, 1, 31), true, true},
 947                 {2012, 32, date(2012, 2, 1), true, true},
 948                 {2012, 59, date(2012, 2, 28), true, true},
 949                 {2012, 60, date(2012, 2, 29), true, true},
 950                 {2012, 61, date(2012, 3, 1), true, true},
 951                 {2012, 365, date(2012, 12, 30), true, true},
 952                 {2012, 366, date(2012, 12, 31), true, true},
 953                 {2012, 367, date(2013, 1, 1), false, false},
 954                 {2012, 367 + 364, date(2013, 12, 31), false, false},
 955                 {2012, 367 + 365, date(2014, 1, 1), false, false},
 956 
 957                 {2011, 59, date(2011, 2, 28), true, true},
 958                 {2011, 60, date(2011, 3, 1), true, true},
 959         };
 960     }
 961 
 962     @Test(dataProvider = &quot;resolve_yd&quot;)
 963     public void test_resolve_yd_lenient(int y, int d, JapaneseDate expected, boolean smart, boolean strict) {
 964         Map&lt;TemporalField, Long&gt; fieldValues = new HashMap&lt;&gt;();
 965         fieldValues.put(ChronoField.YEAR, (long) y);
 966         fieldValues.put(ChronoField.DAY_OF_YEAR, (long) d);
 967         JapaneseDate date = JapaneseChronology.INSTANCE.resolveDate(fieldValues, ResolverStyle.LENIENT);
 968         assertEquals(date, expected);
 969         assertEquals(fieldValues.size(), 0);
 970     }
 971 
 972     @Test(dataProvider = &quot;resolve_yd&quot;)
 973     public void test_resolve_yd_smart(int y, int d, JapaneseDate expected, boolean smart, boolean strict) {
 974         Map&lt;TemporalField, Long&gt; fieldValues = new HashMap&lt;&gt;();
 975         fieldValues.put(ChronoField.YEAR, (long) y);
 976         fieldValues.put(ChronoField.DAY_OF_YEAR, (long) d);
 977         if (smart) {
 978             JapaneseDate date = JapaneseChronology.INSTANCE.resolveDate(fieldValues, ResolverStyle.SMART);
 979             assertEquals(date, expected);
 980             assertEquals(fieldValues.size(), 0);
 981         } else {
 982             try {
 983                 JapaneseChronology.INSTANCE.resolveDate(fieldValues, ResolverStyle.SMART);
 984                 fail(&quot;Should have failed&quot;);
 985             } catch (DateTimeException ex) {
 986                 // expected
 987             }
 988         }
 989     }
 990 
 991     @Test(dataProvider = &quot;resolve_yd&quot;)
 992     public void test_resolve_yd_strict(int y, int d, JapaneseDate expected, boolean smart, boolean strict) {
 993         Map&lt;TemporalField, Long&gt; fieldValues = new HashMap&lt;&gt;();
 994         fieldValues.put(ChronoField.YEAR, (long) y);
 995         fieldValues.put(ChronoField.DAY_OF_YEAR, (long) d);
 996         if (strict) {
 997             JapaneseDate date = JapaneseChronology.INSTANCE.resolveDate(fieldValues, ResolverStyle.STRICT);
 998             assertEquals(date, expected);
 999             assertEquals(fieldValues.size(), 0);
1000         } else {
1001             try {
1002                 JapaneseChronology.INSTANCE.resolveDate(fieldValues, ResolverStyle.STRICT);
1003                 fail(&quot;Should have failed&quot;);
1004             } catch (DateTimeException ex) {
1005                 // expected
1006             }
1007         }
1008     }
1009 
1010     //-----------------------------------------------------------------------
1011     //-----------------------------------------------------------------------
1012     @DataProvider(name = &quot;resolve_eymd&quot;)
1013     Object[][] data_resolve_eymd() {
1014         return new Object[][] {
1015                 // lenient
1016                 {ResolverStyle.LENIENT, JapaneseEra.HEISEI, 1, 1, 1, date(1989, 1, 1)},  // SHOWA, not HEISEI
1017                 {ResolverStyle.LENIENT, JapaneseEra.HEISEI, 1, 1, 7, date(1989, 1, 7)},  // SHOWA, not HEISEI
1018                 {ResolverStyle.LENIENT, JapaneseEra.HEISEI, 1, 1, 8, date(1989, 1, 8)},
1019                 {ResolverStyle.LENIENT, JapaneseEra.HEISEI, 1, 12, 31, date(1989, 12, 31)},
1020                 {ResolverStyle.LENIENT, JapaneseEra.HEISEI, 2, 1, 1, date(1990, 1, 1)},
1021 
1022                 {ResolverStyle.LENIENT, JapaneseEra.SHOWA, 64, 1, 1, date(1989, 1, 1)},
1023                 {ResolverStyle.LENIENT, JapaneseEra.SHOWA, 64, 1, 7, date(1989, 1, 7)},
1024                 {ResolverStyle.LENIENT, JapaneseEra.SHOWA, 64, 1, 8, date(1989, 1, 8)},  // HEISEI, not SHOWA
1025                 {ResolverStyle.LENIENT, JapaneseEra.SHOWA, 64, 12, 31, date(1989, 12, 31)},  // HEISEI, not SHOWA
1026                 {ResolverStyle.LENIENT, JapaneseEra.SHOWA, 65, 1, 1, date(1990, 1, 1)},  // HEISEI, not SHOWA
1027 
1028                 {ResolverStyle.LENIENT, JapaneseEra.SHOWA, 64, 1, -366, date(1987, 12, 31)},
1029                 {ResolverStyle.LENIENT, JapaneseEra.SHOWA, 64, 1, -365, date(1988, 1, 1)},
1030                 {ResolverStyle.LENIENT, JapaneseEra.SHOWA, 64, 1, -31, date(1988, 11, 30)},
1031                 {ResolverStyle.LENIENT, JapaneseEra.SHOWA, 64, 1, -30, date(1988, 12, 1)},
1032                 {ResolverStyle.LENIENT, JapaneseEra.SHOWA, 64, 1, 0, date(1988, 12, 31)},
1033                 {ResolverStyle.LENIENT, JapaneseEra.SHOWA, 64, 1, 1, date(1989, 1, 1)},
1034                 {ResolverStyle.LENIENT, JapaneseEra.SHOWA, 64, 1, 27, date(1989, 1, 27)},
1035                 {ResolverStyle.LENIENT, JapaneseEra.SHOWA, 64, 1, 28, date(1989, 1, 28)},
1036                 {ResolverStyle.LENIENT, JapaneseEra.SHOWA, 64, 1, 29, date(1989, 1, 29)},
1037                 {ResolverStyle.LENIENT, JapaneseEra.SHOWA, 64, 1, 30, date(1989, 1, 30)},
1038                 {ResolverStyle.LENIENT, JapaneseEra.SHOWA, 64, 1, 31, date(1989, 1, 31)},
1039                 {ResolverStyle.LENIENT, JapaneseEra.SHOWA, 64, 1, 32, date(1989, 2, 1)},
1040                 {ResolverStyle.LENIENT, JapaneseEra.SHOWA, 64, 1, 58, date(1989, 2, 27)},
1041                 {ResolverStyle.LENIENT, JapaneseEra.SHOWA, 64, 1, 59, date(1989, 2, 28)},
1042                 {ResolverStyle.LENIENT, JapaneseEra.SHOWA, 64, 1, 60, date(1989, 3, 1)},
1043                 {ResolverStyle.LENIENT, JapaneseEra.SHOWA, 64, 1, 365, date(1989, 12, 31)},
1044                 {ResolverStyle.LENIENT, JapaneseEra.SHOWA, 64, 1, 366, date(1990, 1, 1)},
1045 
1046                 {ResolverStyle.LENIENT, JapaneseEra.SHOWA, 63, 1, 1, date(1988, 1, 1)},
1047                 {ResolverStyle.LENIENT, JapaneseEra.SHOWA, 63, 1, 31, date(1988, 1, 31)},
1048                 {ResolverStyle.LENIENT, JapaneseEra.SHOWA, 63, 1, 32, date(1988, 2, 1)},
1049                 {ResolverStyle.LENIENT, JapaneseEra.SHOWA, 63, 1, 58, date(1988, 2, 27)},
1050                 {ResolverStyle.LENIENT, JapaneseEra.SHOWA, 63, 1, 59, date(1988, 2, 28)},
1051                 {ResolverStyle.LENIENT, JapaneseEra.SHOWA, 63, 1, 60, date(1988, 2, 29)},
1052                 {ResolverStyle.LENIENT, JapaneseEra.SHOWA, 63, 1, 61, date(1988, 3, 1)},
1053 
1054                 {ResolverStyle.LENIENT, JapaneseEra.SHOWA, 64, 2, 1, date(1989, 2, 1)},
1055                 {ResolverStyle.LENIENT, JapaneseEra.SHOWA, 64, 2, 28, date(1989, 2, 28)},
1056                 {ResolverStyle.LENIENT, JapaneseEra.SHOWA, 64, 2, 29, date(1989, 3, 1)},
1057 
1058                 {ResolverStyle.LENIENT, JapaneseEra.SHOWA, 63, 2, 1, date(1988, 2, 1)},
1059                 {ResolverStyle.LENIENT, JapaneseEra.SHOWA, 63, 2, 28, date(1988, 2, 28)},
1060                 {ResolverStyle.LENIENT, JapaneseEra.SHOWA, 63, 2, 29, date(1988, 2, 29)},
1061                 {ResolverStyle.LENIENT, JapaneseEra.SHOWA, 63, 2, 30, date(1988, 3, 1)},
1062 
1063                 {ResolverStyle.LENIENT, JapaneseEra.SHOWA, 62, -11, 1, date(1986, 1, 1)},
1064                 {ResolverStyle.LENIENT, JapaneseEra.SHOWA, 62, -1, 1, date(1986, 11, 1)},
1065                 {ResolverStyle.LENIENT, JapaneseEra.SHOWA, 62, 0, 1, date(1986, 12, 1)},
1066                 {ResolverStyle.LENIENT, JapaneseEra.SHOWA, 62, 13, 1, date(1988, 1, 1)},
1067 
1068                 // smart
1069                 {ResolverStyle.SMART, JapaneseEra.HEISEI, 0, 1, 1, null},
1070                 {ResolverStyle.SMART, JapaneseEra.HEISEI, 1, 1, 1, date(1989, 1, 1)},  // SHOWA, not HEISEI
1071                 {ResolverStyle.SMART, JapaneseEra.HEISEI, 1, 1, 7, date(1989, 1, 7)},  // SHOWA, not HEISEI
1072                 {ResolverStyle.SMART, JapaneseEra.HEISEI, 1, 1, 8, date(1989, 1, 8)},
1073                 {ResolverStyle.SMART, JapaneseEra.HEISEI, 1, 12, 31, date(1989, 12, 31)},
1074                 {ResolverStyle.SMART, JapaneseEra.HEISEI, 2, 1, 1, date(1990, 1, 1)},
1075 
1076                 {ResolverStyle.SMART, JapaneseEra.SHOWA, 64, 1, 1, date(1989, 1, 1)},
1077                 {ResolverStyle.SMART, JapaneseEra.SHOWA, 64, 1, 7, date(1989, 1, 7)},
1078                 {ResolverStyle.SMART, JapaneseEra.SHOWA, 64, 1, 8, date(1989, 1, 8)},  // HEISEI, not SHOWA
1079                 {ResolverStyle.SMART, JapaneseEra.SHOWA, 64, 12, 31, date(1989, 12, 31)},  // HEISEI, not SHOWA
1080                 {ResolverStyle.SMART, JapaneseEra.SHOWA, 65, 1, 1, null},  // HEISEI, not SHOWA
1081 
1082                 {ResolverStyle.SMART, JapaneseEra.SHOWA, 62, 1, 0, null},
1083                 {ResolverStyle.SMART, JapaneseEra.SHOWA, 62, 1, 1, date(1987, 1, 1)},
1084                 {ResolverStyle.SMART, JapaneseEra.SHOWA, 62, 1, 27, date(1987, 1, 27)},
1085                 {ResolverStyle.SMART, JapaneseEra.SHOWA, 62, 1, 28, date(1987, 1, 28)},
1086                 {ResolverStyle.SMART, JapaneseEra.SHOWA, 62, 1, 29, date(1987, 1, 29)},
1087                 {ResolverStyle.SMART, JapaneseEra.SHOWA, 62, 1, 30, date(1987, 1, 30)},
1088                 {ResolverStyle.SMART, JapaneseEra.SHOWA, 62, 1, 31, date(1987, 1, 31)},
1089                 {ResolverStyle.SMART, JapaneseEra.SHOWA, 62, 1, 32, null},
1090 
1091                 {ResolverStyle.SMART, JapaneseEra.SHOWA, 62, 2, 0, null},
1092                 {ResolverStyle.SMART, JapaneseEra.SHOWA, 62, 2, 1, date(1987, 2, 1)},
1093                 {ResolverStyle.SMART, JapaneseEra.SHOWA, 62, 2, 27, date(1987, 2, 27)},
1094                 {ResolverStyle.SMART, JapaneseEra.SHOWA, 62, 2, 28, date(1987, 2, 28)},
1095                 {ResolverStyle.SMART, JapaneseEra.SHOWA, 62, 2, 29, date(1987, 2, 28)},
1096                 {ResolverStyle.SMART, JapaneseEra.SHOWA, 62, 2, 30, date(1987, 2, 28)},
1097                 {ResolverStyle.SMART, JapaneseEra.SHOWA, 62, 2, 31, date(1987, 2, 28)},
1098                 {ResolverStyle.SMART, JapaneseEra.SHOWA, 62, 2, 32, null},
1099 
1100                 {ResolverStyle.SMART, JapaneseEra.SHOWA, 63, 2, 0, null},
1101                 {ResolverStyle.SMART, JapaneseEra.SHOWA, 63, 2, 1, date(1988, 2, 1)},
1102                 {ResolverStyle.SMART, JapaneseEra.SHOWA, 63, 2, 27, date(1988, 2, 27)},
1103                 {ResolverStyle.SMART, JapaneseEra.SHOWA, 63, 2, 28, date(1988, 2, 28)},
1104                 {ResolverStyle.SMART, JapaneseEra.SHOWA, 63, 2, 29, date(1988, 2, 29)},
1105                 {ResolverStyle.SMART, JapaneseEra.SHOWA, 63, 2, 30, date(1988, 2, 29)},
1106                 {ResolverStyle.SMART, JapaneseEra.SHOWA, 63, 2, 31, date(1988, 2, 29)},
1107                 {ResolverStyle.SMART, JapaneseEra.SHOWA, 63, 2, 32, null},
1108 
1109                 {ResolverStyle.SMART, JapaneseEra.SHOWA, 62, -12, 1, null},
1110                 {ResolverStyle.SMART, JapaneseEra.SHOWA, 62, -1, 1, null},
1111                 {ResolverStyle.SMART, JapaneseEra.SHOWA, 62, 0, 1, null},
1112                 {ResolverStyle.SMART, JapaneseEra.SHOWA, 62, 13, 1, null},
1113 
1114                 // strict
1115                 {ResolverStyle.STRICT, JapaneseEra.HEISEI, 0, 1, 1, null},
1116                 {ResolverStyle.STRICT, JapaneseEra.HEISEI, 1, 1, 1, null},  // SHOWA, not HEISEI
1117                 {ResolverStyle.STRICT, JapaneseEra.HEISEI, 1, 1, 7, null},  // SHOWA, not HEISEI
1118                 {ResolverStyle.STRICT, JapaneseEra.HEISEI, 1, 1, 8, date(1989, 1, 8)},
1119                 {ResolverStyle.STRICT, JapaneseEra.HEISEI, 1, 12, 31, date(1989, 12, 31)},
1120                 {ResolverStyle.STRICT, JapaneseEra.HEISEI, 2, 1, 1, date(1990, 1, 1)},
1121 
1122                 {ResolverStyle.STRICT, JapaneseEra.SHOWA, 64, 1, 1, date(1989, 1, 1)},
1123                 {ResolverStyle.STRICT, JapaneseEra.SHOWA, 64, 1, 7, date(1989, 1, 7)},
1124                 {ResolverStyle.STRICT, JapaneseEra.SHOWA, 64, 1, 8, null},  // HEISEI, not SHOWA
1125                 {ResolverStyle.STRICT, JapaneseEra.SHOWA, 64, 12, 31, null},  // HEISEI, not SHOWA
1126                 {ResolverStyle.STRICT, JapaneseEra.SHOWA, 65, 1, 1, null},  // HEISEI, not SHOWA
1127 
1128                 {ResolverStyle.STRICT, JapaneseEra.SHOWA, 62, 1, 0, null},
1129                 {ResolverStyle.STRICT, JapaneseEra.SHOWA, 62, 1, 1, date(1987, 1, 1)},
1130                 {ResolverStyle.STRICT, JapaneseEra.SHOWA, 62, 1, 27, date(1987, 1, 27)},
1131                 {ResolverStyle.STRICT, JapaneseEra.SHOWA, 62, 1, 28, date(1987, 1, 28)},
1132                 {ResolverStyle.STRICT, JapaneseEra.SHOWA, 62, 1, 29, date(1987, 1, 29)},
1133                 {ResolverStyle.STRICT, JapaneseEra.SHOWA, 62, 1, 30, date(1987, 1, 30)},
1134                 {ResolverStyle.STRICT, JapaneseEra.SHOWA, 62, 1, 31, date(1987, 1, 31)},
1135                 {ResolverStyle.STRICT, JapaneseEra.SHOWA, 62, 1, 32, null},
1136 
1137                 {ResolverStyle.STRICT, JapaneseEra.SHOWA, 62, 2, 0, null},
1138                 {ResolverStyle.STRICT, JapaneseEra.SHOWA, 62, 2, 1, date(1987, 2, 1)},
1139                 {ResolverStyle.STRICT, JapaneseEra.SHOWA, 62, 2, 27, date(1987, 2, 27)},
1140                 {ResolverStyle.STRICT, JapaneseEra.SHOWA, 62, 2, 28, date(1987, 2, 28)},
1141                 {ResolverStyle.STRICT, JapaneseEra.SHOWA, 62, 2, 29, null},
1142                 {ResolverStyle.STRICT, JapaneseEra.SHOWA, 62, 2, 30, null},
1143                 {ResolverStyle.STRICT, JapaneseEra.SHOWA, 62, 2, 31, null},
1144                 {ResolverStyle.STRICT, JapaneseEra.SHOWA, 62, 2, 32, null},
1145 
1146                 {ResolverStyle.STRICT, JapaneseEra.SHOWA, 63, 2, 0, null},
1147                 {ResolverStyle.STRICT, JapaneseEra.SHOWA, 63, 2, 1, date(1988, 2, 1)},
1148                 {ResolverStyle.STRICT, JapaneseEra.SHOWA, 63, 2, 27, date(1988, 2, 27)},
1149                 {ResolverStyle.STRICT, JapaneseEra.SHOWA, 63, 2, 28, date(1988, 2, 28)},
1150                 {ResolverStyle.STRICT, JapaneseEra.SHOWA, 63, 2, 29, date(1988, 2, 29)},
1151                 {ResolverStyle.STRICT, JapaneseEra.SHOWA, 63, 2, 30, null},
1152                 {ResolverStyle.STRICT, JapaneseEra.SHOWA, 63, 2, 31, null},
1153                 {ResolverStyle.STRICT, JapaneseEra.SHOWA, 63, 2, 32, null},
1154 
1155                 {ResolverStyle.STRICT, JapaneseEra.SHOWA, 62, -12, 1, null},
1156                 {ResolverStyle.STRICT, JapaneseEra.SHOWA, 62, -1, 1, null},
1157                 {ResolverStyle.STRICT, JapaneseEra.SHOWA, 62, 0, 1, null},
1158                 {ResolverStyle.STRICT, JapaneseEra.SHOWA, 62, 13, 1, null},
1159         };
1160     }
1161 
1162     @Test(dataProvider = &quot;resolve_eymd&quot;)
1163     public void test_resolve_eymd(ResolverStyle style, JapaneseEra era, int yoe, int m, int d, JapaneseDate expected) {
1164         Map&lt;TemporalField, Long&gt; fieldValues = new HashMap&lt;&gt;();
1165         fieldValues.put(ChronoField.ERA, (long) era.getValue());
1166         fieldValues.put(ChronoField.YEAR_OF_ERA, (long) yoe);
1167         fieldValues.put(ChronoField.MONTH_OF_YEAR, (long) m);
1168         fieldValues.put(ChronoField.DAY_OF_MONTH, (long) d);
1169         if (expected != null) {
1170             JapaneseDate date = JapaneseChronology.INSTANCE.resolveDate(fieldValues, style);
1171             assertEquals(date, expected);
1172             assertEquals(fieldValues.size(), 0);
1173         } else {
1174             try {
1175                 JapaneseChronology.INSTANCE.resolveDate(fieldValues, style);
1176                 fail(&quot;Should have failed&quot;);
1177             } catch (DateTimeException ex) {
1178                 // expected
1179             }
1180         }
1181     }
1182 
1183     //-----------------------------------------------------------------------
1184     private static JapaneseDate date(int y, int m, int d) {
1185         return JapaneseDate.of(y, m, d);
1186     }
1187 
1188 }
    </pre>
  </body>
</html>
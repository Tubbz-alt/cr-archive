<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff test/jdk/java/time/tck/java/time/chrono/TCKJapaneseChronology.java</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="../../../TEST.properties.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="TCKJapaneseEra.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>test/jdk/java/time/tck/java/time/chrono/TCKJapaneseChronology.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  o Copyright (c) 2012, 2018, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
</pre>
<hr />
<pre>
  94 import java.time.temporal.ChronoUnit;
  95 import java.time.temporal.TemporalAdjusters;
  96 import java.time.temporal.TemporalField;
  97 import java.time.temporal.TemporalQueries;
  98 import java.time.temporal.ValueRange;
  99 
 100 import java.util.HashMap;
 101 import java.util.List;
 102 import java.util.Locale;
 103 import java.util.Map;
 104 
 105 import org.testng.Assert;
 106 import org.testng.annotations.DataProvider;
 107 import org.testng.annotations.Test;
 108 
 109 /**
 110  * Test.
 111  */
 112 @Test
 113 public class TCKJapaneseChronology {
<span class="line-modified"> 114     private static final int YDIFF_NEWERA = 2018;</span>


 115     private static final int YDIFF_HEISEI = 1988;
 116     private static final int YDIFF_MEIJI = 1867;
 117     private static final int YDIFF_SHOWA = 1925;
 118     private static final int YDIFF_TAISHO = 1911;
 119 
 120     //-----------------------------------------------------------------------
 121     // Chronology.of(String)
 122     //-----------------------------------------------------------------------
 123     @Test
 124     public void test_chrono_byName() {
 125         Chronology c = JapaneseChronology.INSTANCE;
 126         Chronology test = Chronology.of(&quot;Japanese&quot;);
 127         Assert.assertNotNull(test, &quot;The Japanese calendar could not be found byName&quot;);
 128         Assert.assertEquals(test.getId(), &quot;Japanese&quot;, &quot;ID mismatch&quot;);
 129         Assert.assertEquals(test.getCalendarType(), &quot;japanese&quot;, &quot;Type mismatch&quot;);
 130         Assert.assertEquals(test, c);
 131     }
 132 
 133     //-----------------------------------------------------------------------
 134     // Chronology.ofLocale(Locale)
</pre>
<hr />
<pre>
 157     @Test
 158     public void test_chrono_byLocale_oldJP_variant() {
 159         Chronology test = Chronology.ofLocale(new Locale(&quot;ja&quot;, &quot;JP&quot;, &quot;JP&quot;));
 160         Assert.assertEquals(test.getId(), &quot;Japanese&quot;);
 161         Assert.assertEquals(test, JapaneseChronology.INSTANCE);
 162     }
 163 
 164     @Test
 165     public void test_chrono_byLocale_iso() {
 166         Assert.assertEquals(Chronology.ofLocale(new Locale(&quot;ja&quot;, &quot;JP&quot;)).getId(), &quot;ISO&quot;);
 167         Assert.assertEquals(Chronology.ofLocale(Locale.forLanguageTag(&quot;ja-JP&quot;)).getId(), &quot;ISO&quot;);
 168         Assert.assertEquals(Chronology.ofLocale(Locale.forLanguageTag(&quot;ja-JP-JP&quot;)).getId(), &quot;ISO&quot;);
 169     }
 170 
 171     //-----------------------------------------------------------------------
 172     // creation and cross-checks
 173     //-----------------------------------------------------------------------
 174     @DataProvider(name=&quot;createByEra&quot;)
 175     Object[][] data_createByEra() {
 176         return new Object[][] {
<span class="line-modified"> 177                 {JapaneseEra.of(3), 2020 - YDIFF_NEWERA, 2, 29, 60, LocalDate.of(2020, 2, 29)}, // NEWERA</span>
 178                 {JapaneseEra.HEISEI, 1996 - YDIFF_HEISEI, 2, 29, 60, LocalDate.of(1996, 2, 29)},
 179                 {JapaneseEra.HEISEI, 2000 - YDIFF_HEISEI, 2, 29, 60, LocalDate.of(2000, 2, 29)},
 180                 {JapaneseEra.MEIJI, 1874 - YDIFF_MEIJI, 2, 28, 59, LocalDate.of(1874, 2, 28)},
 181                 {JapaneseEra.SHOWA, 1928 - YDIFF_SHOWA, 12, 25, 360, LocalDate.of(1928, 12, 25)},
 182                 {JapaneseEra.TAISHO, 1916 - YDIFF_TAISHO, 7, 30, 212, LocalDate.of(1916, 7, 30)},
 183                 {JapaneseEra.MEIJI, 6, 1, 1, 1, LocalDate.of(1873, 1, 1)},
 184                 {JapaneseEra.MEIJI, 45, 7, 29, 211, LocalDate.of(1912, 7, 29)},
 185                 {JapaneseEra.TAISHO, 1, 7, 30, 1, LocalDate.of(1912, 7, 30)},
 186                 {JapaneseEra.TAISHO, 15, 12, 24, 358, LocalDate.of(1926, 12, 24)},
 187                 {JapaneseEra.SHOWA, 1, 12, 25, 1, LocalDate.of(1926, 12, 25)},
 188                 {JapaneseEra.SHOWA, 64, 1, 7, 7, LocalDate.of(1989, 1, 7)},
 189                 {JapaneseEra.HEISEI, 1, 1, 8, 1, LocalDate.of(1989, 1, 8)},
 190         };
 191     }
 192 
 193     @Test(dataProvider=&quot;createByEra&quot;)
 194     public void test_createEymd(JapaneseEra era, int yoe, int moy, int dom, int doy, LocalDate iso) {
 195         JapaneseDate dateByChronoFactory = JapaneseChronology.INSTANCE.date(era, yoe, moy, dom);
 196         JapaneseDate dateByDateFactory = JapaneseDate.of(era, yoe, moy, dom);
 197         assertEquals(dateByChronoFactory, dateByDateFactory);
</pre>
<hr />
<pre>
 350 
 351             {1725, 2, 29},
 352             {500, 2, 29},
 353             {2100, 2, 29},
 354 
 355             {1872, 12, 31},     // Last day of MEIJI 5
 356         };
 357     }
 358 
 359     @Test(dataProvider=&quot;badDates&quot;, expectedExceptions=DateTimeException.class)
 360     public void test_badDates(int year, int month, int dom) {
 361         JapaneseChronology.INSTANCE.date(year, month, dom);
 362     }
 363 
 364     //-----------------------------------------------------------------------
 365     // prolepticYear() and is LeapYear()
 366     //-----------------------------------------------------------------------
 367     @DataProvider(name=&quot;prolepticYear&quot;)
 368     Object[][] data_prolepticYear() {
 369         return new Object[][] {
<span class="line-modified"> 370                 {3, JapaneseEra.of(3), 1, 1 + YDIFF_NEWERA, false}, // NEWERA</span>
<span class="line-modified"> 371                 {3, JapaneseEra.of(3), 102, 102 + YDIFF_NEWERA, true}, // NEWERA</span>
 372 
 373                 {2, JapaneseEra.HEISEI, 1, 1 + YDIFF_HEISEI, false},
 374                 {2, JapaneseEra.HEISEI, 4, 4 + YDIFF_HEISEI, true},
 375 
 376                 {-1, JapaneseEra.MEIJI, 9, 9 + YDIFF_MEIJI, true},
 377                 {-1, JapaneseEra.MEIJI, 10, 10 + YDIFF_MEIJI, false},
 378 
 379                 {1, JapaneseEra.SHOWA, 1, 1 + YDIFF_SHOWA, false},
 380                 {1, JapaneseEra.SHOWA, 7, 7 + YDIFF_SHOWA, true},
 381 
 382                 {0, JapaneseEra.TAISHO, 1, 1 + YDIFF_TAISHO, true},
 383                 {0, JapaneseEra.TAISHO, 4, 4 + YDIFF_TAISHO, false},
 384         };
 385     }
 386 
 387     @Test(dataProvider=&quot;prolepticYear&quot;)
 388     public void test_prolepticYear(int eraValue, Era  era, int yearOfEra, int expectedProlepticYear, boolean isLeapYear) {
 389         Era eraObj = JapaneseChronology.INSTANCE.eraOf(eraValue);
 390         assertTrue(JapaneseChronology.INSTANCE.eras().contains(eraObj));
 391         assertEquals(eraObj, era);
</pre>
<hr />
<pre>
 536         assertEquals(test, LocalDate.of(1928, 10, 29));
 537     }
 538 
 539     @Test
 540     public void test_LocalDateTime_adjustToJapaneseDate() {
 541         JapaneseDate jdate = JapaneseChronology.INSTANCE.date(1928, 10, 29);
 542         LocalDateTime test = LocalDateTime.MIN.with(jdate);
 543         assertEquals(test, LocalDateTime.of(1928, 10, 29, 0, 0));
 544     }
 545 
 546     //-----------------------------------------------------------------------
 547     // Check Japanese Eras
 548     //-----------------------------------------------------------------------
 549     @DataProvider(name=&quot;japaneseEras&quot;)
 550     Object[][] data_japanseseEras() {
 551         return new Object[][] {
 552             { JapaneseEra.MEIJI, -1, &quot;Meiji&quot;},
 553             { JapaneseEra.TAISHO, 0, &quot;Taisho&quot;},
 554             { JapaneseEra.SHOWA, 1, &quot;Showa&quot;},
 555             { JapaneseEra.HEISEI, 2, &quot;Heisei&quot;},
<span class="line-modified"> 556             { JapaneseEra.of(3), 3, &quot;NewEra&quot;}, // NEWERA</span>
 557         };
 558     }
 559 
 560     @Test(dataProvider=&quot;japaneseEras&quot;)
 561     public void test_Japanese_Eras(Era era, int eraValue, String name) {
 562         assertEquals(era.getValue(), eraValue, &quot;EraValue&quot;);
 563         assertEquals(era.toString(), name, &quot;Era Name&quot;);
 564         assertEquals(era, JapaneseChronology.INSTANCE.eraOf(eraValue), &quot;JapaneseChronology.eraOf()&quot;);
 565         List&lt;Era&gt; eras = JapaneseChronology.INSTANCE.eras();
 566         assertTrue(eras.contains(era), &quot;Era is not present in JapaneseChronology.INSTANCE.eras()&quot;);
 567     }
 568 
 569     @Test
 570     public void test_Japanese_badEras() {
 571         int badEras[] = {-1000, -998, -997, -2, 4, 5, 1000};
 572         for (int badEra : badEras) {
 573             try {
 574                 Era era = JapaneseChronology.INSTANCE.eraOf(badEra);
 575                 fail(&quot;JapaneseChronology.eraOf returned &quot; + era + &quot; + for invalid eraValue &quot; + badEra);
 576             } catch (DateTimeException ex) {
</pre>
<hr />
<pre>
 672             assertEquals(doy, i, &quot;with(DAY_OF_YEAR) incorrect for &quot; + i + &quot; &quot; + hd2);
 673         }
 674     }
 675 
 676     //-----------------------------------------------------------------------
 677     // toString()
 678     //-----------------------------------------------------------------------
 679     @DataProvider(name=&quot;toString&quot;)
 680     Object[][] data_toString() {
 681         return new Object[][] {
 682             {JapaneseChronology.INSTANCE.date(1873, 12,  5), &quot;Japanese Meiji 6-12-05&quot;},
 683             {JapaneseChronology.INSTANCE.date(1873, 12,  6), &quot;Japanese Meiji 6-12-06&quot;},
 684             {JapaneseChronology.INSTANCE.date(1873,  9,  8), &quot;Japanese Meiji 6-09-08&quot;},
 685             {JapaneseChronology.INSTANCE.date(1912,  7, 29), &quot;Japanese Meiji 45-07-29&quot;},
 686             {JapaneseChronology.INSTANCE.date(1912,  7, 30), &quot;Japanese Taisho 1-07-30&quot;},
 687             {JapaneseChronology.INSTANCE.date(1926, 12, 24), &quot;Japanese Taisho 15-12-24&quot;},
 688             {JapaneseChronology.INSTANCE.date(1926, 12, 25), &quot;Japanese Showa 1-12-25&quot;},
 689             {JapaneseChronology.INSTANCE.date(1989,  1,  7), &quot;Japanese Showa 64-01-07&quot;},
 690             {JapaneseChronology.INSTANCE.date(1989,  1,  8), &quot;Japanese Heisei 1-01-08&quot;},
 691             {JapaneseChronology.INSTANCE.date(2012, 12,  6), &quot;Japanese Heisei 24-12-06&quot;},
<span class="line-modified"> 692             {JapaneseChronology.INSTANCE.date(2020,  1,  6), &quot;Japanese NewEra 2-01-06&quot;},</span>
 693         };
 694     }
 695 
 696     @Test(dataProvider=&quot;toString&quot;)
 697     public void test_toString(JapaneseDate jdate, String expected) {
 698         assertEquals(jdate.toString(), expected);
 699     }
 700 
 701     //-----------------------------------------------------------------------
 702     // equals()
 703     //-----------------------------------------------------------------------
 704     @Test
 705     public void test_equals_true() {
 706         assertTrue(JapaneseChronology.INSTANCE.equals(JapaneseChronology.INSTANCE));
 707     }
 708 
 709     @Test
 710     public void test_equals_false() {
 711         assertFalse(JapaneseChronology.INSTANCE.equals(IsoChronology.INSTANCE));
 712     }
</pre>
</td>
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  o Copyright (c) 2012, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
</pre>
<hr />
<pre>
  94 import java.time.temporal.ChronoUnit;
  95 import java.time.temporal.TemporalAdjusters;
  96 import java.time.temporal.TemporalField;
  97 import java.time.temporal.TemporalQueries;
  98 import java.time.temporal.ValueRange;
  99 
 100 import java.util.HashMap;
 101 import java.util.List;
 102 import java.util.Locale;
 103 import java.util.Map;
 104 
 105 import org.testng.Assert;
 106 import org.testng.annotations.DataProvider;
 107 import org.testng.annotations.Test;
 108 
 109 /**
 110  * Test.
 111  */
 112 @Test
 113 public class TCKJapaneseChronology {
<span class="line-modified"> 114 </span>
<span class="line-added"> 115     // Year differences from Gregorian years.</span>
<span class="line-added"> 116     private static final int YDIFF_REIWA = 2018;</span>
 117     private static final int YDIFF_HEISEI = 1988;
 118     private static final int YDIFF_MEIJI = 1867;
 119     private static final int YDIFF_SHOWA = 1925;
 120     private static final int YDIFF_TAISHO = 1911;
 121 
 122     //-----------------------------------------------------------------------
 123     // Chronology.of(String)
 124     //-----------------------------------------------------------------------
 125     @Test
 126     public void test_chrono_byName() {
 127         Chronology c = JapaneseChronology.INSTANCE;
 128         Chronology test = Chronology.of(&quot;Japanese&quot;);
 129         Assert.assertNotNull(test, &quot;The Japanese calendar could not be found byName&quot;);
 130         Assert.assertEquals(test.getId(), &quot;Japanese&quot;, &quot;ID mismatch&quot;);
 131         Assert.assertEquals(test.getCalendarType(), &quot;japanese&quot;, &quot;Type mismatch&quot;);
 132         Assert.assertEquals(test, c);
 133     }
 134 
 135     //-----------------------------------------------------------------------
 136     // Chronology.ofLocale(Locale)
</pre>
<hr />
<pre>
 159     @Test
 160     public void test_chrono_byLocale_oldJP_variant() {
 161         Chronology test = Chronology.ofLocale(new Locale(&quot;ja&quot;, &quot;JP&quot;, &quot;JP&quot;));
 162         Assert.assertEquals(test.getId(), &quot;Japanese&quot;);
 163         Assert.assertEquals(test, JapaneseChronology.INSTANCE);
 164     }
 165 
 166     @Test
 167     public void test_chrono_byLocale_iso() {
 168         Assert.assertEquals(Chronology.ofLocale(new Locale(&quot;ja&quot;, &quot;JP&quot;)).getId(), &quot;ISO&quot;);
 169         Assert.assertEquals(Chronology.ofLocale(Locale.forLanguageTag(&quot;ja-JP&quot;)).getId(), &quot;ISO&quot;);
 170         Assert.assertEquals(Chronology.ofLocale(Locale.forLanguageTag(&quot;ja-JP-JP&quot;)).getId(), &quot;ISO&quot;);
 171     }
 172 
 173     //-----------------------------------------------------------------------
 174     // creation and cross-checks
 175     //-----------------------------------------------------------------------
 176     @DataProvider(name=&quot;createByEra&quot;)
 177     Object[][] data_createByEra() {
 178         return new Object[][] {
<span class="line-modified"> 179                 {JapaneseEra.REIWA, 2020 - YDIFF_REIWA, 2, 29, 60, LocalDate.of(2020, 2, 29)},</span>
 180                 {JapaneseEra.HEISEI, 1996 - YDIFF_HEISEI, 2, 29, 60, LocalDate.of(1996, 2, 29)},
 181                 {JapaneseEra.HEISEI, 2000 - YDIFF_HEISEI, 2, 29, 60, LocalDate.of(2000, 2, 29)},
 182                 {JapaneseEra.MEIJI, 1874 - YDIFF_MEIJI, 2, 28, 59, LocalDate.of(1874, 2, 28)},
 183                 {JapaneseEra.SHOWA, 1928 - YDIFF_SHOWA, 12, 25, 360, LocalDate.of(1928, 12, 25)},
 184                 {JapaneseEra.TAISHO, 1916 - YDIFF_TAISHO, 7, 30, 212, LocalDate.of(1916, 7, 30)},
 185                 {JapaneseEra.MEIJI, 6, 1, 1, 1, LocalDate.of(1873, 1, 1)},
 186                 {JapaneseEra.MEIJI, 45, 7, 29, 211, LocalDate.of(1912, 7, 29)},
 187                 {JapaneseEra.TAISHO, 1, 7, 30, 1, LocalDate.of(1912, 7, 30)},
 188                 {JapaneseEra.TAISHO, 15, 12, 24, 358, LocalDate.of(1926, 12, 24)},
 189                 {JapaneseEra.SHOWA, 1, 12, 25, 1, LocalDate.of(1926, 12, 25)},
 190                 {JapaneseEra.SHOWA, 64, 1, 7, 7, LocalDate.of(1989, 1, 7)},
 191                 {JapaneseEra.HEISEI, 1, 1, 8, 1, LocalDate.of(1989, 1, 8)},
 192         };
 193     }
 194 
 195     @Test(dataProvider=&quot;createByEra&quot;)
 196     public void test_createEymd(JapaneseEra era, int yoe, int moy, int dom, int doy, LocalDate iso) {
 197         JapaneseDate dateByChronoFactory = JapaneseChronology.INSTANCE.date(era, yoe, moy, dom);
 198         JapaneseDate dateByDateFactory = JapaneseDate.of(era, yoe, moy, dom);
 199         assertEquals(dateByChronoFactory, dateByDateFactory);
</pre>
<hr />
<pre>
 352 
 353             {1725, 2, 29},
 354             {500, 2, 29},
 355             {2100, 2, 29},
 356 
 357             {1872, 12, 31},     // Last day of MEIJI 5
 358         };
 359     }
 360 
 361     @Test(dataProvider=&quot;badDates&quot;, expectedExceptions=DateTimeException.class)
 362     public void test_badDates(int year, int month, int dom) {
 363         JapaneseChronology.INSTANCE.date(year, month, dom);
 364     }
 365 
 366     //-----------------------------------------------------------------------
 367     // prolepticYear() and is LeapYear()
 368     //-----------------------------------------------------------------------
 369     @DataProvider(name=&quot;prolepticYear&quot;)
 370     Object[][] data_prolepticYear() {
 371         return new Object[][] {
<span class="line-modified"> 372                 {3, JapaneseEra.REIWA, 1, 1 + YDIFF_REIWA, false},</span>
<span class="line-modified"> 373                 {3, JapaneseEra.REIWA, 102, 102 + YDIFF_REIWA, true},</span>
 374 
 375                 {2, JapaneseEra.HEISEI, 1, 1 + YDIFF_HEISEI, false},
 376                 {2, JapaneseEra.HEISEI, 4, 4 + YDIFF_HEISEI, true},
 377 
 378                 {-1, JapaneseEra.MEIJI, 9, 9 + YDIFF_MEIJI, true},
 379                 {-1, JapaneseEra.MEIJI, 10, 10 + YDIFF_MEIJI, false},
 380 
 381                 {1, JapaneseEra.SHOWA, 1, 1 + YDIFF_SHOWA, false},
 382                 {1, JapaneseEra.SHOWA, 7, 7 + YDIFF_SHOWA, true},
 383 
 384                 {0, JapaneseEra.TAISHO, 1, 1 + YDIFF_TAISHO, true},
 385                 {0, JapaneseEra.TAISHO, 4, 4 + YDIFF_TAISHO, false},
 386         };
 387     }
 388 
 389     @Test(dataProvider=&quot;prolepticYear&quot;)
 390     public void test_prolepticYear(int eraValue, Era  era, int yearOfEra, int expectedProlepticYear, boolean isLeapYear) {
 391         Era eraObj = JapaneseChronology.INSTANCE.eraOf(eraValue);
 392         assertTrue(JapaneseChronology.INSTANCE.eras().contains(eraObj));
 393         assertEquals(eraObj, era);
</pre>
<hr />
<pre>
 538         assertEquals(test, LocalDate.of(1928, 10, 29));
 539     }
 540 
 541     @Test
 542     public void test_LocalDateTime_adjustToJapaneseDate() {
 543         JapaneseDate jdate = JapaneseChronology.INSTANCE.date(1928, 10, 29);
 544         LocalDateTime test = LocalDateTime.MIN.with(jdate);
 545         assertEquals(test, LocalDateTime.of(1928, 10, 29, 0, 0));
 546     }
 547 
 548     //-----------------------------------------------------------------------
 549     // Check Japanese Eras
 550     //-----------------------------------------------------------------------
 551     @DataProvider(name=&quot;japaneseEras&quot;)
 552     Object[][] data_japanseseEras() {
 553         return new Object[][] {
 554             { JapaneseEra.MEIJI, -1, &quot;Meiji&quot;},
 555             { JapaneseEra.TAISHO, 0, &quot;Taisho&quot;},
 556             { JapaneseEra.SHOWA, 1, &quot;Showa&quot;},
 557             { JapaneseEra.HEISEI, 2, &quot;Heisei&quot;},
<span class="line-modified"> 558             { JapaneseEra.REIWA, 3, &quot;Reiwa&quot;},</span>
 559         };
 560     }
 561 
 562     @Test(dataProvider=&quot;japaneseEras&quot;)
 563     public void test_Japanese_Eras(Era era, int eraValue, String name) {
 564         assertEquals(era.getValue(), eraValue, &quot;EraValue&quot;);
 565         assertEquals(era.toString(), name, &quot;Era Name&quot;);
 566         assertEquals(era, JapaneseChronology.INSTANCE.eraOf(eraValue), &quot;JapaneseChronology.eraOf()&quot;);
 567         List&lt;Era&gt; eras = JapaneseChronology.INSTANCE.eras();
 568         assertTrue(eras.contains(era), &quot;Era is not present in JapaneseChronology.INSTANCE.eras()&quot;);
 569     }
 570 
 571     @Test
 572     public void test_Japanese_badEras() {
 573         int badEras[] = {-1000, -998, -997, -2, 4, 5, 1000};
 574         for (int badEra : badEras) {
 575             try {
 576                 Era era = JapaneseChronology.INSTANCE.eraOf(badEra);
 577                 fail(&quot;JapaneseChronology.eraOf returned &quot; + era + &quot; + for invalid eraValue &quot; + badEra);
 578             } catch (DateTimeException ex) {
</pre>
<hr />
<pre>
 674             assertEquals(doy, i, &quot;with(DAY_OF_YEAR) incorrect for &quot; + i + &quot; &quot; + hd2);
 675         }
 676     }
 677 
 678     //-----------------------------------------------------------------------
 679     // toString()
 680     //-----------------------------------------------------------------------
 681     @DataProvider(name=&quot;toString&quot;)
 682     Object[][] data_toString() {
 683         return new Object[][] {
 684             {JapaneseChronology.INSTANCE.date(1873, 12,  5), &quot;Japanese Meiji 6-12-05&quot;},
 685             {JapaneseChronology.INSTANCE.date(1873, 12,  6), &quot;Japanese Meiji 6-12-06&quot;},
 686             {JapaneseChronology.INSTANCE.date(1873,  9,  8), &quot;Japanese Meiji 6-09-08&quot;},
 687             {JapaneseChronology.INSTANCE.date(1912,  7, 29), &quot;Japanese Meiji 45-07-29&quot;},
 688             {JapaneseChronology.INSTANCE.date(1912,  7, 30), &quot;Japanese Taisho 1-07-30&quot;},
 689             {JapaneseChronology.INSTANCE.date(1926, 12, 24), &quot;Japanese Taisho 15-12-24&quot;},
 690             {JapaneseChronology.INSTANCE.date(1926, 12, 25), &quot;Japanese Showa 1-12-25&quot;},
 691             {JapaneseChronology.INSTANCE.date(1989,  1,  7), &quot;Japanese Showa 64-01-07&quot;},
 692             {JapaneseChronology.INSTANCE.date(1989,  1,  8), &quot;Japanese Heisei 1-01-08&quot;},
 693             {JapaneseChronology.INSTANCE.date(2012, 12,  6), &quot;Japanese Heisei 24-12-06&quot;},
<span class="line-modified"> 694             {JapaneseChronology.INSTANCE.date(2020,  1,  6), &quot;Japanese Reiwa 2-01-06&quot;},</span>
 695         };
 696     }
 697 
 698     @Test(dataProvider=&quot;toString&quot;)
 699     public void test_toString(JapaneseDate jdate, String expected) {
 700         assertEquals(jdate.toString(), expected);
 701     }
 702 
 703     //-----------------------------------------------------------------------
 704     // equals()
 705     //-----------------------------------------------------------------------
 706     @Test
 707     public void test_equals_true() {
 708         assertTrue(JapaneseChronology.INSTANCE.equals(JapaneseChronology.INSTANCE));
 709     }
 710 
 711     @Test
 712     public void test_equals_false() {
 713         assertFalse(JapaneseChronology.INSTANCE.equals(IsoChronology.INSTANCE));
 714     }
</pre>
</td>
</tr>
</table>
<center><a href="../../../TEST.properties.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="TCKJapaneseEra.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
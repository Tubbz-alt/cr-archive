<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New test/jdk/java/time/tck/java/time/format/TCKDateTimeFormatterBuilder.java</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 2012, 2019, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  */
  23 
  24 /*
  25  * This file is available under and governed by the GNU General Public
  26  * License version 2 only, as published by the Free Software Foundation.
  27  * However, the following notice accompanied the original version of this
  28  * file:
  29  *
  30  * Copyright (c) 2009-2012, Stephen Colebourne &amp; Michael Nascimento Santos
  31  *
  32  * All rights reserved.
  33  *
  34  * Redistribution and use in source and binary forms, with or without
  35  * modification, are permitted provided that the following conditions are met:
  36  *
  37  *  * Redistributions of source code must retain the above copyright notice,
  38  *    this list of conditions and the following disclaimer.
  39  *
  40  *  * Redistributions in binary form must reproduce the above copyright notice,
  41  *    this list of conditions and the following disclaimer in the documentation
  42  *    and/or other materials provided with the distribution.
  43  *
  44  *  * Neither the name of JSR-310 nor the names of its contributors
  45  *    may be used to endorse or promote products derived from this software
  46  *    without specific prior written permission.
  47  *
  48  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
  49  * &quot;AS IS&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
  50  * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
  51  * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR
  52  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
  53  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
  54  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
  55  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
  56  * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
  57  * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
  58  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  59  */
  60 package tck.java.time.format;
  61 
  62 import static java.time.format.DateTimeFormatter.BASIC_ISO_DATE;
  63 import static java.time.temporal.ChronoField.DAY_OF_MONTH;
  64 import static java.time.temporal.ChronoField.HOUR_OF_DAY;
  65 import static java.time.temporal.ChronoField.MINUTE_OF_HOUR;
  66 import static java.time.temporal.ChronoField.MONTH_OF_YEAR;
  67 import static java.time.temporal.ChronoField.NANO_OF_SECOND;
  68 import static java.time.temporal.ChronoField.OFFSET_SECONDS;
  69 import static java.time.temporal.ChronoField.YEAR;
  70 import static org.testng.Assert.assertEquals;
  71 
  72 import java.text.ParsePosition;
  73 import java.time.LocalDate;
  74 import java.time.LocalDateTime;
  75 import java.time.LocalTime;
  76 import java.time.Month;
  77 import java.time.YearMonth;
  78 import java.time.ZonedDateTime;
  79 import java.time.ZoneId;
  80 import java.time.ZoneOffset;
  81 import java.time.format.DateTimeFormatter;
  82 import java.time.format.DateTimeFormatterBuilder;
  83 import java.time.format.DateTimeParseException;
  84 import java.time.format.SignStyle;
  85 import java.time.format.TextStyle;
  86 import java.time.temporal.Temporal;
  87 import java.time.temporal.TemporalAccessor;
  88 import java.util.HashMap;
  89 import java.util.Locale;
  90 import java.util.Map;
  91 
  92 import org.testng.annotations.BeforeMethod;
  93 import org.testng.annotations.DataProvider;
  94 import org.testng.annotations.Test;
  95 
  96 /**
  97  * Test DateTimeFormatterBuilder.
  98  */
  99 @Test
 100 public class TCKDateTimeFormatterBuilder {
 101 
 102     private DateTimeFormatterBuilder builder;
 103 
 104     @BeforeMethod
 105     public void setUp() {
 106         builder = new DateTimeFormatterBuilder();
 107     }
 108 
 109     //-----------------------------------------------------------------------
 110     @Test
 111     public void test_toFormatter_empty() throws Exception {
 112         DateTimeFormatter f = builder.toFormatter();
 113         assertEquals(f.format(LocalDate.of(2012, 6, 30)), &quot;&quot;);
 114     }
 115 
 116     //-----------------------------------------------------------------------
 117     @Test
 118     public void test_parseDefaulting_entireDate() {
 119         DateTimeFormatter f = builder
 120             .parseDefaulting(YEAR, 2012).parseDefaulting(MONTH_OF_YEAR, 6)
 121             .parseDefaulting(DAY_OF_MONTH, 30).toFormatter();
 122         LocalDate parsed = f.parse(&quot;&quot;, LocalDate::from);  // blank string can be parsed
 123         assertEquals(parsed, LocalDate.of(2012, 6, 30));
 124     }
 125 
 126     @Test
 127     public void test_parseDefaulting_yearOptionalMonthOptionalDay() {
 128         DateTimeFormatter f = builder
 129                 .appendValue(YEAR)
 130                 .optionalStart().appendLiteral(&#39;-&#39;).appendValue(MONTH_OF_YEAR)
 131                 .optionalStart().appendLiteral(&#39;-&#39;).appendValue(DAY_OF_MONTH)
 132                 .optionalEnd().optionalEnd()
 133                 .parseDefaulting(MONTH_OF_YEAR, 1)
 134                 .parseDefaulting(DAY_OF_MONTH, 1).toFormatter();
 135         assertEquals(f.parse(&quot;2012&quot;, LocalDate::from), LocalDate.of(2012, 1, 1));
 136         assertEquals(f.parse(&quot;2012-6&quot;, LocalDate::from), LocalDate.of(2012, 6, 1));
 137         assertEquals(f.parse(&quot;2012-6-30&quot;, LocalDate::from), LocalDate.of(2012, 6, 30));
 138     }
 139 
 140     @Test(expectedExceptions = NullPointerException.class)
 141     public void test_parseDefaulting_null() {
 142         builder.parseDefaulting(null, 1);
 143     }
 144 
 145     //-----------------------------------------------------------------------
 146     @Test(expectedExceptions=NullPointerException.class)
 147     public void test_appendValue_1arg_null() throws Exception {
 148         builder.appendValue(null);
 149     }
 150 
 151     //-----------------------------------------------------------------------
 152     @Test(expectedExceptions=NullPointerException.class)
 153     public void test_appendValue_2arg_null() throws Exception {
 154         builder.appendValue(null, 3);
 155     }
 156 
 157     @Test(expectedExceptions=IllegalArgumentException.class)
 158     public void test_appendValue_2arg_widthTooSmall() throws Exception {
 159         builder.appendValue(DAY_OF_MONTH, 0);
 160     }
 161 
 162     @Test(expectedExceptions=IllegalArgumentException.class)
 163     public void test_appendValue_2arg_widthTooBig() throws Exception {
 164         builder.appendValue(DAY_OF_MONTH, 20);
 165     }
 166 
 167     //-----------------------------------------------------------------------
 168     @Test(expectedExceptions=NullPointerException.class)
 169     public void test_appendValue_3arg_nullField() throws Exception {
 170         builder.appendValue(null, 2, 3, SignStyle.NORMAL);
 171     }
 172 
 173     @Test(expectedExceptions=IllegalArgumentException.class)
 174     public void test_appendValue_3arg_minWidthTooSmall() throws Exception {
 175         builder.appendValue(DAY_OF_MONTH, 0, 2, SignStyle.NORMAL);
 176     }
 177 
 178     @Test(expectedExceptions=IllegalArgumentException.class)
 179     public void test_appendValue_3arg_minWidthTooBig() throws Exception {
 180         builder.appendValue(DAY_OF_MONTH, 20, 2, SignStyle.NORMAL);
 181     }
 182 
 183     @Test(expectedExceptions=IllegalArgumentException.class)
 184     public void test_appendValue_3arg_maxWidthTooSmall() throws Exception {
 185         builder.appendValue(DAY_OF_MONTH, 2, 0, SignStyle.NORMAL);
 186     }
 187 
 188     @Test(expectedExceptions=IllegalArgumentException.class)
 189     public void test_appendValue_3arg_maxWidthTooBig() throws Exception {
 190         builder.appendValue(DAY_OF_MONTH, 2, 20, SignStyle.NORMAL);
 191     }
 192 
 193     @Test(expectedExceptions=IllegalArgumentException.class)
 194     public void test_appendValue_3arg_maxWidthMinWidth() throws Exception {
 195         builder.appendValue(DAY_OF_MONTH, 4, 2, SignStyle.NORMAL);
 196     }
 197 
 198     @Test(expectedExceptions=NullPointerException.class)
 199     public void test_appendValue_3arg_nullSignStyle() throws Exception {
 200         builder.appendValue(DAY_OF_MONTH, 2, 3, null);
 201     }
 202 
 203     //-----------------------------------------------------------------------
 204     @Test(expectedExceptions=NullPointerException.class)
 205     public void test_appendValueReduced_int_nullField() throws Exception {
 206         builder.appendValueReduced(null, 2, 2, 2000);
 207     }
 208 
 209     @Test(expectedExceptions=IllegalArgumentException.class)
 210     public void test_appendValueReduced_int_minWidthTooSmall() throws Exception {
 211         builder.appendValueReduced(YEAR, 0, 2, 2000);
 212     }
 213 
 214     @Test(expectedExceptions=IllegalArgumentException.class)
 215     public void test_appendValueReduced_int_minWidthTooBig() throws Exception {
 216         builder.appendValueReduced(YEAR, 11, 2, 2000);
 217     }
 218 
 219     @Test(expectedExceptions=IllegalArgumentException.class)
 220     public void test_appendValueReduced_int_maxWidthTooSmall() throws Exception {
 221         builder.appendValueReduced(YEAR, 2, 0, 2000);
 222     }
 223 
 224     @Test(expectedExceptions=IllegalArgumentException.class)
 225     public void test_appendValueReduced_int_maxWidthTooBig() throws Exception {
 226         builder.appendValueReduced(YEAR, 2, 11, 2000);
 227     }
 228 
 229     @Test(expectedExceptions=IllegalArgumentException.class)
 230     public void test_appendValueReduced_int_maxWidthLessThanMin() throws Exception {
 231         builder.appendValueReduced(YEAR, 2, 1, 2000);
 232     }
 233 
 234     //-----------------------------------------------------------------------
 235     @Test(expectedExceptions=NullPointerException.class)
 236     public void test_appendValueReduced_date_nullField() throws Exception {
 237         builder.appendValueReduced(null, 2, 2, LocalDate.of(2000, 1, 1));
 238     }
 239 
 240     @Test(expectedExceptions=NullPointerException.class)
 241     public void test_appendValueReduced_date_nullDate() throws Exception {
 242         builder.appendValueReduced(YEAR, 2, 2, null);
 243     }
 244 
 245     @Test(expectedExceptions=IllegalArgumentException.class)
 246     public void test_appendValueReduced_date_minWidthTooSmall() throws Exception {
 247         builder.appendValueReduced(YEAR, 0, 2, LocalDate.of(2000, 1, 1));
 248     }
 249 
 250     @Test(expectedExceptions=IllegalArgumentException.class)
 251     public void test_appendValueReduced_date_minWidthTooBig() throws Exception {
 252         builder.appendValueReduced(YEAR, 11, 2, LocalDate.of(2000, 1, 1));
 253     }
 254 
 255     @Test(expectedExceptions=IllegalArgumentException.class)
 256     public void test_appendValueReduced_date_maxWidthTooSmall() throws Exception {
 257         builder.appendValueReduced(YEAR, 2, 0, LocalDate.of(2000, 1, 1));
 258     }
 259 
 260     @Test(expectedExceptions=IllegalArgumentException.class)
 261     public void test_appendValueReduced_date_maxWidthTooBig() throws Exception {
 262         builder.appendValueReduced(YEAR, 2, 11, LocalDate.of(2000, 1, 1));
 263     }
 264 
 265     @Test(expectedExceptions=IllegalArgumentException.class)
 266     public void test_appendValueReduced_date_maxWidthLessThanMin() throws Exception {
 267         builder.appendValueReduced(YEAR, 2, 1, LocalDate.of(2000, 1, 1));
 268     }
 269 
 270     //-----------------------------------------------------------------------
 271     //-----------------------------------------------------------------------
 272     //-----------------------------------------------------------------------
 273     @Test(expectedExceptions=NullPointerException.class)
 274     public void test_appendFraction_4arg_nullRule() throws Exception {
 275         builder.appendFraction(null, 1, 9, false);
 276     }
 277 
 278     @Test(expectedExceptions=IllegalArgumentException.class)
 279     public void test_appendFraction_4arg_invalidRuleNotFixedSet() throws Exception {
 280         builder.appendFraction(DAY_OF_MONTH, 1, 9, false);
 281     }
 282 
 283     @Test(expectedExceptions=IllegalArgumentException.class)
 284     public void test_appendFraction_4arg_minTooSmall() throws Exception {
 285         builder.appendFraction(MINUTE_OF_HOUR, -1, 9, false);
 286     }
 287 
 288     @Test(expectedExceptions=IllegalArgumentException.class)
 289     public void test_appendFraction_4arg_minTooBig() throws Exception {
 290         builder.appendFraction(MINUTE_OF_HOUR, 10, 9, false);
 291     }
 292 
 293     @Test(expectedExceptions=IllegalArgumentException.class)
 294     public void test_appendFraction_4arg_maxTooSmall() throws Exception {
 295         builder.appendFraction(MINUTE_OF_HOUR, 0, -1, false);
 296     }
 297 
 298     @Test(expectedExceptions=IllegalArgumentException.class)
 299     public void test_appendFraction_4arg_maxTooBig() throws Exception {
 300         builder.appendFraction(MINUTE_OF_HOUR, 1, 10, false);
 301     }
 302 
 303     @Test(expectedExceptions=IllegalArgumentException.class)
 304     public void test_appendFraction_4arg_maxWidthMinWidth() throws Exception {
 305         builder.appendFraction(MINUTE_OF_HOUR, 9, 3, false);
 306     }
 307 
 308     //-----------------------------------------------------------------------
 309     //-----------------------------------------------------------------------
 310     //-----------------------------------------------------------------------
 311     @Test(expectedExceptions=NullPointerException.class)
 312     public void test_appendText_1arg_null() throws Exception {
 313         builder.appendText(null);
 314     }
 315 
 316     //-----------------------------------------------------------------------
 317     @Test(expectedExceptions=NullPointerException.class)
 318     public void test_appendText_2arg_nullRule() throws Exception {
 319         builder.appendText(null, TextStyle.SHORT);
 320     }
 321 
 322     @Test(expectedExceptions=NullPointerException.class)
 323     public void test_appendText_2arg_nullStyle() throws Exception {
 324         builder.appendText(MONTH_OF_YEAR, (TextStyle) null);
 325     }
 326 
 327     //-----------------------------------------------------------------------
 328     @Test(expectedExceptions=NullPointerException.class)
 329     public void test_appendTextMap_nullRule() throws Exception {
 330         builder.appendText(null, new HashMap&lt;&gt;());
 331     }
 332 
 333     @Test(expectedExceptions=NullPointerException.class)
 334     public void test_appendTextMap_nullStyle() throws Exception {
 335         builder.appendText(MONTH_OF_YEAR, (Map&lt;Long, String&gt;) null);
 336     }
 337 
 338     //-----------------------------------------------------------------------
 339     //-----------------------------------------------------------------------
 340     //-----------------------------------------------------------------------
 341     @DataProvider(name=&quot;offsetPatterns&quot;)
 342     Object[][] data_offsetPatterns() {
 343         return new Object[][] {
 344                 {&quot;+HH&quot;, 2, 0, 0, &quot;+02&quot;},
 345                 {&quot;+HH&quot;, -2, 0, 0, &quot;-02&quot;},
 346                 {&quot;+HH&quot;, 2, 30, 0, &quot;+02&quot;},
 347                 {&quot;+HH&quot;, 2, 0, 45, &quot;+02&quot;},
 348                 {&quot;+HH&quot;, 2, 30, 45, &quot;+02&quot;},
 349 
 350                 {&quot;+HHmm&quot;, 2, 0, 0, &quot;+02&quot;},
 351                 {&quot;+HHmm&quot;, -2, 0, 0, &quot;-02&quot;},
 352                 {&quot;+HHmm&quot;, 2, 30, 0, &quot;+0230&quot;},
 353                 {&quot;+HHmm&quot;, 2, 0, 45, &quot;+02&quot;},
 354                 {&quot;+HHmm&quot;, 2, 30, 45, &quot;+0230&quot;},
 355 
 356                 {&quot;+HH:mm&quot;, 2, 0, 0, &quot;+02&quot;},
 357                 {&quot;+HH:mm&quot;, -2, 0, 0, &quot;-02&quot;},
 358                 {&quot;+HH:mm&quot;, 2, 30, 0, &quot;+02:30&quot;},
 359                 {&quot;+HH:mm&quot;, 2, 0, 45, &quot;+02&quot;},
 360                 {&quot;+HH:mm&quot;, 2, 30, 45, &quot;+02:30&quot;},
 361 
 362                 {&quot;+HHMM&quot;, 2, 0, 0, &quot;+0200&quot;},
 363                 {&quot;+HHMM&quot;, -2, 0, 0, &quot;-0200&quot;},
 364                 {&quot;+HHMM&quot;, 2, 30, 0, &quot;+0230&quot;},
 365                 {&quot;+HHMM&quot;, 2, 0, 45, &quot;+0200&quot;},
 366                 {&quot;+HHMM&quot;, 2, 30, 45, &quot;+0230&quot;},
 367 
 368                 {&quot;+HH:MM&quot;, 2, 0, 0, &quot;+02:00&quot;},
 369                 {&quot;+HH:MM&quot;, -2, 0, 0, &quot;-02:00&quot;},
 370                 {&quot;+HH:MM&quot;, 2, 30, 0, &quot;+02:30&quot;},
 371                 {&quot;+HH:MM&quot;, 2, 0, 45, &quot;+02:00&quot;},
 372                 {&quot;+HH:MM&quot;, 2, 30, 45, &quot;+02:30&quot;},
 373 
 374                 {&quot;+HHMMss&quot;, 2, 0, 0, &quot;+0200&quot;},
 375                 {&quot;+HHMMss&quot;, -2, 0, 0, &quot;-0200&quot;},
 376                 {&quot;+HHMMss&quot;, 2, 30, 0, &quot;+0230&quot;},
 377                 {&quot;+HHMMss&quot;, 2, 0, 45, &quot;+020045&quot;},
 378                 {&quot;+HHMMss&quot;, 2, 30, 45, &quot;+023045&quot;},
 379 
 380                 {&quot;+HH:MM:ss&quot;, 2, 0, 0, &quot;+02:00&quot;},
 381                 {&quot;+HH:MM:ss&quot;, -2, 0, 0, &quot;-02:00&quot;},
 382                 {&quot;+HH:MM:ss&quot;, 2, 30, 0, &quot;+02:30&quot;},
 383                 {&quot;+HH:MM:ss&quot;, 2, 0, 45, &quot;+02:00:45&quot;},
 384                 {&quot;+HH:MM:ss&quot;, 2, 30, 45, &quot;+02:30:45&quot;},
 385 
 386                 {&quot;+HHMMSS&quot;, 2, 0, 0, &quot;+020000&quot;},
 387                 {&quot;+HHMMSS&quot;, -2, 0, 0, &quot;-020000&quot;},
 388                 {&quot;+HHMMSS&quot;, 2, 30, 0, &quot;+023000&quot;},
 389                 {&quot;+HHMMSS&quot;, 2, 0, 45, &quot;+020045&quot;},
 390                 {&quot;+HHMMSS&quot;, 2, 30, 45, &quot;+023045&quot;},
 391 
 392                 {&quot;+HH:MM:SS&quot;, 2, 0, 0, &quot;+02:00:00&quot;},
 393                 {&quot;+HH:MM:SS&quot;, -2, 0, 0, &quot;-02:00:00&quot;},
 394                 {&quot;+HH:MM:SS&quot;, 2, 30, 0, &quot;+02:30:00&quot;},
 395                 {&quot;+HH:MM:SS&quot;, 2, 0, 45, &quot;+02:00:45&quot;},
 396                 {&quot;+HH:MM:SS&quot;, 2, 30, 45, &quot;+02:30:45&quot;},
 397 
 398                 {&quot;+HHmmss&quot;, 2, 0, 0, &quot;+02&quot;},
 399                 {&quot;+HHmmss&quot;, -2, 0, 0, &quot;-02&quot;},
 400                 {&quot;+HHmmss&quot;, 2, 30, 0, &quot;+0230&quot;},
 401                 {&quot;+HHmmss&quot;, 2, 0, 45, &quot;+020045&quot;},
 402                 {&quot;+HHmmss&quot;, 2, 30, 45, &quot;+023045&quot;},
 403 
 404                 {&quot;+HH:mm:ss&quot;, 2, 0, 0, &quot;+02&quot;},
 405                 {&quot;+HH:mm:ss&quot;, -2, 0, 0, &quot;-02&quot;},
 406                 {&quot;+HH:mm:ss&quot;, 2, 30, 0, &quot;+02:30&quot;},
 407                 {&quot;+HH:mm:ss&quot;, 2, 0, 45, &quot;+02:00:45&quot;},
 408                 {&quot;+HH:mm:ss&quot;, 2, 30, 45, &quot;+02:30:45&quot;},
 409 
 410                 {&quot;+H&quot;, 2, 0, 0, &quot;+2&quot;},
 411                 {&quot;+H&quot;, -2, 0, 0, &quot;-2&quot;},
 412                 {&quot;+H&quot;, 2, 30, 0, &quot;+2&quot;},
 413                 {&quot;+H&quot;, 2, 0, 45, &quot;+2&quot;},
 414                 {&quot;+H&quot;, 2, 30, 45, &quot;+2&quot;},
 415                 {&quot;+H&quot;, 12, 0, 0, &quot;+12&quot;},
 416                 {&quot;+H&quot;, -12, 0, 0, &quot;-12&quot;},
 417                 {&quot;+H&quot;, 12, 30, 0, &quot;+12&quot;},
 418                 {&quot;+H&quot;, 12, 0, 45, &quot;+12&quot;},
 419                 {&quot;+H&quot;, 12, 30, 45, &quot;+12&quot;},
 420 
 421                 {&quot;+Hmm&quot;, 2, 0, 0, &quot;+2&quot;},
 422                 {&quot;+Hmm&quot;, -2, 0, 0, &quot;-2&quot;},
 423                 {&quot;+Hmm&quot;, 2, 30, 0, &quot;+230&quot;},
 424                 {&quot;+Hmm&quot;, 2, 0, 45, &quot;+2&quot;},
 425                 {&quot;+Hmm&quot;, 2, 30, 45, &quot;+230&quot;},
 426                 {&quot;+Hmm&quot;, 12, 0, 0, &quot;+12&quot;},
 427                 {&quot;+Hmm&quot;, -12, 0, 0, &quot;-12&quot;},
 428                 {&quot;+Hmm&quot;, 12, 30, 0, &quot;+1230&quot;},
 429                 {&quot;+Hmm&quot;, 12, 0, 45, &quot;+12&quot;},
 430                 {&quot;+Hmm&quot;, 12, 30, 45, &quot;+1230&quot;},
 431 
 432                 {&quot;+H:mm&quot;, 2, 0, 0, &quot;+2&quot;},
 433                 {&quot;+H:mm&quot;, -2, 0, 0, &quot;-2&quot;},
 434                 {&quot;+H:mm&quot;, 2, 30, 0, &quot;+2:30&quot;},
 435                 {&quot;+H:mm&quot;, 2, 0, 45, &quot;+2&quot;},
 436                 {&quot;+H:mm&quot;, 2, 30, 45, &quot;+2:30&quot;},
 437                 {&quot;+H:mm&quot;, 12, 0, 0, &quot;+12&quot;},
 438                 {&quot;+H:mm&quot;, -12, 0, 0, &quot;-12&quot;},
 439                 {&quot;+H:mm&quot;, 12, 30, 0, &quot;+12:30&quot;},
 440                 {&quot;+H:mm&quot;, 12, 0, 45, &quot;+12&quot;},
 441                 {&quot;+H:mm&quot;, 12, 30, 45, &quot;+12:30&quot;},
 442 
 443                 {&quot;+HMM&quot;, 2, 0, 0, &quot;+200&quot;},
 444                 {&quot;+HMM&quot;, -2, 0, 0, &quot;-200&quot;},
 445                 {&quot;+HMM&quot;, 2, 30, 0, &quot;+230&quot;},
 446                 {&quot;+HMM&quot;, 2, 0, 45, &quot;+200&quot;},
 447                 {&quot;+HMM&quot;, 2, 30, 45, &quot;+230&quot;},
 448                 {&quot;+HMM&quot;, 12, 0, 0, &quot;+1200&quot;},
 449                 {&quot;+HMM&quot;, -12, 0, 0, &quot;-1200&quot;},
 450                 {&quot;+HMM&quot;, 12, 30, 0, &quot;+1230&quot;},
 451                 {&quot;+HMM&quot;, 12, 0, 45, &quot;+1200&quot;},
 452                 {&quot;+HMM&quot;, 12, 30, 45, &quot;+1230&quot;},
 453 
 454                 {&quot;+H:MM&quot;, 2, 0, 0, &quot;+2:00&quot;},
 455                 {&quot;+H:MM&quot;, -2, 0, 0, &quot;-2:00&quot;},
 456                 {&quot;+H:MM&quot;, 2, 30, 0, &quot;+2:30&quot;},
 457                 {&quot;+H:MM&quot;, 2, 0, 45, &quot;+2:00&quot;},
 458                 {&quot;+H:MM&quot;, 2, 30, 45, &quot;+2:30&quot;},
 459                 {&quot;+H:MM&quot;, 12, 0, 0, &quot;+12:00&quot;},
 460                 {&quot;+H:MM&quot;, -12, 0, 0, &quot;-12:00&quot;},
 461                 {&quot;+H:MM&quot;, 12, 30, 0, &quot;+12:30&quot;},
 462                 {&quot;+H:MM&quot;, 12, 0, 45, &quot;+12:00&quot;},
 463                 {&quot;+H:MM&quot;, 12, 30, 45, &quot;+12:30&quot;},
 464 
 465                 {&quot;+HMMss&quot;, 2, 0, 0, &quot;+200&quot;},
 466                 {&quot;+HMMss&quot;, -2, 0, 0, &quot;-200&quot;},
 467                 {&quot;+HMMss&quot;, 2, 30, 0, &quot;+230&quot;},
 468                 {&quot;+HMMss&quot;, 2, 0, 45, &quot;+20045&quot;},
 469                 {&quot;+HMMss&quot;, 2, 30, 45, &quot;+23045&quot;},
 470                 {&quot;+HMMss&quot;, 12, 0, 0, &quot;+1200&quot;},
 471                 {&quot;+HMMss&quot;, -12, 0, 0, &quot;-1200&quot;},
 472                 {&quot;+HMMss&quot;, 12, 30, 0, &quot;+1230&quot;},
 473                 {&quot;+HMMss&quot;, 12, 0, 45, &quot;+120045&quot;},
 474                 {&quot;+HMMss&quot;, 12, 30, 45, &quot;+123045&quot;},
 475 
 476                 {&quot;+H:MM:ss&quot;, 2, 0, 0, &quot;+2:00&quot;},
 477                 {&quot;+H:MM:ss&quot;, -2, 0, 0, &quot;-2:00&quot;},
 478                 {&quot;+H:MM:ss&quot;, 2, 30, 0, &quot;+2:30&quot;},
 479                 {&quot;+H:MM:ss&quot;, 2, 0, 45, &quot;+2:00:45&quot;},
 480                 {&quot;+H:MM:ss&quot;, 2, 30, 45, &quot;+2:30:45&quot;},
 481                 {&quot;+H:MM:ss&quot;, 12, 0, 0, &quot;+12:00&quot;},
 482                 {&quot;+H:MM:ss&quot;, -12, 0, 0, &quot;-12:00&quot;},
 483                 {&quot;+H:MM:ss&quot;, 12, 30, 0, &quot;+12:30&quot;},
 484                 {&quot;+H:MM:ss&quot;, 12, 0, 45, &quot;+12:00:45&quot;},
 485                 {&quot;+H:MM:ss&quot;, 12, 30, 45, &quot;+12:30:45&quot;},
 486 
 487                 {&quot;+HMMSS&quot;, 2, 0, 0, &quot;+20000&quot;},
 488                 {&quot;+HMMSS&quot;, -2, 0, 0, &quot;-20000&quot;},
 489                 {&quot;+HMMSS&quot;, 2, 30, 0, &quot;+23000&quot;},
 490                 {&quot;+HMMSS&quot;, 2, 0, 45, &quot;+20045&quot;},
 491                 {&quot;+HMMSS&quot;, 2, 30, 45, &quot;+23045&quot;},
 492                 {&quot;+HMMSS&quot;, 12, 0, 0, &quot;+120000&quot;},
 493                 {&quot;+HMMSS&quot;, -12, 0, 0, &quot;-120000&quot;},
 494                 {&quot;+HMMSS&quot;, 12, 30, 0, &quot;+123000&quot;},
 495                 {&quot;+HMMSS&quot;, 12, 0, 45, &quot;+120045&quot;},
 496                 {&quot;+HMMSS&quot;, 12, 30, 45, &quot;+123045&quot;},
 497 
 498                 {&quot;+H:MM:SS&quot;, 2, 0, 0, &quot;+2:00:00&quot;},
 499                 {&quot;+H:MM:SS&quot;, -2, 0, 0, &quot;-2:00:00&quot;},
 500                 {&quot;+H:MM:SS&quot;, 2, 30, 0, &quot;+2:30:00&quot;},
 501                 {&quot;+H:MM:SS&quot;, 2, 0, 45, &quot;+2:00:45&quot;},
 502                 {&quot;+H:MM:SS&quot;, 2, 30, 45, &quot;+2:30:45&quot;},
 503                 {&quot;+H:MM:SS&quot;, 12, 0, 0, &quot;+12:00:00&quot;},
 504                 {&quot;+H:MM:SS&quot;, -12, 0, 0, &quot;-12:00:00&quot;},
 505                 {&quot;+H:MM:SS&quot;, 12, 30, 0, &quot;+12:30:00&quot;},
 506                 {&quot;+H:MM:SS&quot;, 12, 0, 45, &quot;+12:00:45&quot;},
 507                 {&quot;+H:MM:SS&quot;, 12, 30, 45, &quot;+12:30:45&quot;},
 508 
 509                 {&quot;+Hmmss&quot;, 2, 0, 0, &quot;+2&quot;},
 510                 {&quot;+Hmmss&quot;, -2, 0, 0, &quot;-2&quot;},
 511                 {&quot;+Hmmss&quot;, 2, 30, 0, &quot;+230&quot;},
 512                 {&quot;+Hmmss&quot;, 2, 0, 45, &quot;+20045&quot;},
 513                 {&quot;+Hmmss&quot;, 2, 30, 45, &quot;+23045&quot;},
 514                 {&quot;+Hmmss&quot;, 12, 0, 0, &quot;+12&quot;},
 515                 {&quot;+Hmmss&quot;, -12, 0, 0, &quot;-12&quot;},
 516                 {&quot;+Hmmss&quot;, 12, 30, 0, &quot;+1230&quot;},
 517                 {&quot;+Hmmss&quot;, 12, 0, 45, &quot;+120045&quot;},
 518                 {&quot;+Hmmss&quot;, 12, 30, 45, &quot;+123045&quot;},
 519 
 520                 {&quot;+H:mm:ss&quot;, 2, 0, 0, &quot;+2&quot;},
 521                 {&quot;+H:mm:ss&quot;, -2, 0, 0, &quot;-2&quot;},
 522                 {&quot;+H:mm:ss&quot;, 2, 30, 0, &quot;+2:30&quot;},
 523                 {&quot;+H:mm:ss&quot;, 2, 0, 45, &quot;+2:00:45&quot;},
 524                 {&quot;+H:mm:ss&quot;, 2, 30, 45, &quot;+2:30:45&quot;},
 525                 {&quot;+H:mm:ss&quot;, 12, 0, 0, &quot;+12&quot;},
 526                 {&quot;+H:mm:ss&quot;, -12, 0, 0, &quot;-12&quot;},
 527                 {&quot;+H:mm:ss&quot;, 12, 30, 0, &quot;+12:30&quot;},
 528                 {&quot;+H:mm:ss&quot;, 12, 0, 45, &quot;+12:00:45&quot;},
 529                 {&quot;+H:mm:ss&quot;, 12, 30, 45, &quot;+12:30:45&quot;},
 530 
 531 
 532         };
 533     }
 534 
 535     @Test(dataProvider=&quot;offsetPatterns&quot;)
 536     public void test_appendOffset_format(String pattern, int h, int m, int s, String expected) throws Exception {
 537         builder.appendOffset(pattern, &quot;Z&quot;);
 538         DateTimeFormatter f = builder.toFormatter();
 539         ZoneOffset offset = ZoneOffset.ofHoursMinutesSeconds(h, m, s);
 540         assertEquals(f.format(offset), expected);
 541     }
 542 
 543     @Test(dataProvider=&quot;offsetPatterns&quot;)
 544     public void test_appendOffset_parse(String pattern, int h, int m, int s, String expected) throws Exception {
 545         builder.appendOffset(pattern, &quot;Z&quot;);
 546         DateTimeFormatter f = builder.toFormatter();
 547         ZoneOffset parsed = f.parse(expected, ZoneOffset::from);
 548         assertEquals(f.format(parsed), expected);
 549     }
 550 
 551     @DataProvider(name=&quot;badOffsetPatterns&quot;)
 552     Object[][] data_badOffsetPatterns() {
 553         return new Object[][] {
 554             {&quot;HH&quot;},
 555             {&quot;HHMM&quot;},
 556             {&quot;HH:MM&quot;},
 557             {&quot;HHMMss&quot;},
 558             {&quot;HH:MM:ss&quot;},
 559             {&quot;HHMMSS&quot;},
 560             {&quot;HH:MM:SS&quot;},
 561             {&quot;+HHM&quot;},
 562             {&quot;+A&quot;},
 563         };
 564     }
 565 
 566     @Test(dataProvider=&quot;badOffsetPatterns&quot;, expectedExceptions=IllegalArgumentException.class)
 567     public void test_appendOffset_badPattern(String pattern) throws Exception {
 568         builder.appendOffset(pattern, &quot;Z&quot;);
 569     }
 570 
 571     @Test(expectedExceptions=NullPointerException.class)
 572     public void test_appendOffset_3arg_nullText() throws Exception {
 573         builder.appendOffset(&quot;+HH:MM&quot;, null);
 574     }
 575 
 576     @Test(expectedExceptions=NullPointerException.class)
 577     public void test_appendOffset_3arg_nullPattern() throws Exception {
 578         builder.appendOffset(null, &quot;Z&quot;);
 579     }
 580 
 581     //-----------------------------------------------------------------------
 582     //-----------------------------------------------------------------------
 583     //-----------------------------------------------------------------------
 584     @DataProvider(name = &quot;formatGenericTimeZonePatterns&quot;)
 585     Object[][] data_formatGenericNonLocationPatterns() {
 586         return new Object[][] {
 587                 {&quot;v&quot;, &quot;America/Los_Angeles&quot;, &quot;PT&quot;},
 588                 {&quot;vvvv&quot;, &quot;America/Los_Angeles&quot;, &quot;Pacific Time&quot;},
 589                 {&quot;v&quot;, &quot;America/New_York&quot;, &quot;ET&quot;},
 590                 {&quot;vvvv&quot;, &quot;America/New_York&quot;, &quot;Eastern Time&quot;},
 591         };
 592     }
 593 
 594     @Test(dataProvider = &quot;formatGenericTimeZonePatterns&quot;)
 595     public void test_appendZoneText_formatGenericTimeZonePatterns(String pattern, String input, String expected) {
 596         ZonedDateTime zdt = ZonedDateTime.of(LocalDateTime.now(), ZoneId.of(input));
 597         DateTimeFormatter df = DateTimeFormatter.ofPattern(pattern, Locale.US);
 598         assertEquals(zdt.format(df), expected);
 599     }
 600 
 601     @DataProvider(name = &quot;parseGenericTimeZonePatterns&quot;)
 602     Object[][]  data_parseGenericTimeZonePatterns() {
 603         return new Object[][] {
 604                 {&quot;yyyy DDD HH mm v&quot;, LocalDateTime.of(2015, Month.MARCH, 10, 12, 13), ZoneId.of(&quot;America/Los_Angeles&quot;),
 605                  &quot;2015 069 12 13 PT&quot;},
 606                 {&quot;yyyy DDD HH mm vvvv&quot;, LocalDateTime.of(2015, Month.MARCH, 10, 12, 13), ZoneId.of(&quot;America/Los_Angeles&quot;),
 607                  &quot;2015 069 12 13 Pacific Time&quot;},
 608                 {&quot;yyyy DDD HH mm v&quot;, LocalDateTime.of(2015, Month.NOVEMBER, 10, 12, 13), ZoneId.of(&quot;America/Los_Angeles&quot;),
 609                  &quot;2015 314 12 13 PT&quot;},
 610                 {&quot;yyyy DDD HH mm vvvv&quot;, LocalDateTime.of(2015, Month.NOVEMBER, 10, 12, 13), ZoneId.of(&quot;America/Los_Angeles&quot;),
 611                  &quot;2015 314 12 13 Pacific Time&quot;},
 612         };
 613     }
 614 
 615     @Test(dataProvider = &quot;parseGenericTimeZonePatterns&quot;)
 616     public void test_appendZoneText_parseGenericTimeZonePatterns(String pattern, LocalDateTime ldt, ZoneId zId, String input) {
 617         DateTimeFormatter df = new DateTimeFormatterBuilder().appendPattern(pattern).toFormatter(Locale.US);
 618         ZonedDateTime expected = ZonedDateTime.parse(input, df);
 619         ZonedDateTime actual = ZonedDateTime.of(ldt, zId);
 620         assertEquals(actual, expected);
 621     }
 622 
 623     @DataProvider(name = &quot;formatNonGenericTimeZonePatterns_1&quot;)
 624     Object[][]  data_formatNonGenericTimeZonePatterns_1() {
 625         return new Object[][] {
 626                 {&quot;yyyy-MM-dd HH:mm:ss z&quot;, LocalDateTime.of(2015, Month.NOVEMBER, 1, 0, 30),
 627                  &quot;2015-11-01 00:30:00 PDT&quot;},
 628                 {&quot;yyyy-MM-dd HH:mm:ss z&quot;, LocalDateTime.of(2015, Month.NOVEMBER, 1, 1, 30),
 629                  &quot;2015-11-01 01:30:00 PDT&quot;},
 630                 {&quot;yyyy-MM-dd HH:mm:ss z&quot;, LocalDateTime.of(2015, Month.NOVEMBER, 1, 2, 30),
 631                  &quot;2015-11-01 02:30:00 PST&quot;},
 632                 {&quot;yyyy-MM-dd HH:mm:ss zzzz&quot;, LocalDateTime.of(2015, Month.NOVEMBER, 1, 0, 30),
 633                  &quot;2015-11-01 00:30:00 Pacific Daylight Time&quot;},
 634                 {&quot;yyyy-MM-dd HH:mm:ss zzzz&quot;, LocalDateTime.of(2015, Month.NOVEMBER, 1, 1, 30),
 635                  &quot;2015-11-01 01:30:00 Pacific Daylight Time&quot;},
 636                 {&quot;yyyy-MM-dd HH:mm:ss zzzz&quot;, LocalDateTime.of(2015, Month.NOVEMBER, 1, 2, 30),
 637                  &quot;2015-11-01 02:30:00 Pacific Standard Time&quot;},
 638         };
 639     }
 640 
 641     @Test(dataProvider = &quot;formatNonGenericTimeZonePatterns_1&quot;)
 642     public void test_appendZoneText_parseNonGenricTimeZonePatterns_1(String pattern, LocalDateTime ldt, String expected) {
 643         ZoneId  zId = ZoneId.of(&quot;America/Los_Angeles&quot;);
 644         DateTimeFormatter df = new DateTimeFormatterBuilder().appendPattern(pattern).toFormatter(Locale.US);
 645         ZonedDateTime zdt = ZonedDateTime.of(ldt, zId);
 646         String actual = df.format(zdt);
 647         assertEquals(actual, expected);
 648     }
 649 
 650     @DataProvider(name = &quot;formatNonGenericTimeZonePatterns_2&quot;)
 651     Object[][]  data_formatNonGenericTimeZonePatterns_2() {
 652         return new Object[][] {
 653                 {&quot;yyyy-MM-dd HH:mm:ss z&quot;, LocalDateTime.of(2015, Month.NOVEMBER, 1, 0, 30),
 654                  &quot;2015-11-01 00:30:00 PDT&quot;},
 655                 {&quot;yyyy-MM-dd HH:mm:ss z&quot;, LocalDateTime.of(2015, Month.NOVEMBER, 1, 1, 30),
 656                  &quot;2015-11-01 01:30:00 PT&quot;},
 657                 {&quot;yyyy-MM-dd HH:mm:ss z&quot;, LocalDateTime.of(2015, Month.NOVEMBER, 1, 2, 30),
 658                  &quot;2015-11-01 02:30:00 PST&quot;},
 659                 {&quot;yyyy-MM-dd HH:mm:ss zzzz&quot;, LocalDateTime.of(2015, Month.NOVEMBER, 1, 0, 30),
 660                  &quot;2015-11-01 00:30:00 Pacific Daylight Time&quot;},
 661                 {&quot;yyyy-MM-dd HH:mm:ss zzzz&quot;, LocalDateTime.of(2015, Month.NOVEMBER, 1, 1, 30),
 662                  &quot;2015-11-01 01:30:00 Pacific Time&quot;},
 663                 {&quot;yyyy-MM-dd HH:mm:ss zzzz&quot;, LocalDateTime.of(2015, Month.NOVEMBER, 1, 2, 30),
 664                  &quot;2015-11-01 02:30:00 Pacific Standard Time&quot;},
 665         };
 666     }
 667 
 668     @Test(dataProvider = &quot;formatNonGenericTimeZonePatterns_2&quot;)
 669     public void test_appendZoneText_parseNonGenricTimeZonePatterns_2(String pattern, LocalDateTime ldt, String expected) {
 670         ZoneId  zId = ZoneId.of(&quot;America/Los_Angeles&quot;);
 671         DateTimeFormatter df = DateTimeFormatter.ofPattern(pattern, Locale.US).withZone(zId);
 672         String actual = df.format(ldt);
 673         assertEquals(actual, expected);
 674     }
 675 
 676     @Test(expectedExceptions=NullPointerException.class)
 677     public void test_appendZoneText_1arg_nullText() throws Exception {
 678         builder.appendZoneText(null);
 679     }
 680 
 681     //-----------------------------------------------------------------------
 682     //-----------------------------------------------------------------------
 683     //-----------------------------------------------------------------------
 684     @Test
 685     public void test_padNext_1arg() {
 686         builder.appendValue(MONTH_OF_YEAR).appendLiteral(&#39;:&#39;).padNext(2).appendValue(DAY_OF_MONTH);
 687         assertEquals(builder.toFormatter().format(LocalDate.of(2013, 2, 1)), &quot;2: 1&quot;);
 688     }
 689 
 690     @Test(expectedExceptions=IllegalArgumentException.class)
 691     public void test_padNext_1arg_invalidWidth() throws Exception {
 692         builder.padNext(0);
 693     }
 694 
 695     //-----------------------------------------------------------------------
 696     @Test
 697     public void test_padNext_2arg_dash() throws Exception {
 698         builder.appendValue(MONTH_OF_YEAR).appendLiteral(&#39;:&#39;).padNext(2, &#39;-&#39;).appendValue(DAY_OF_MONTH);
 699         assertEquals(builder.toFormatter().format(LocalDate.of(2013, 2, 1)), &quot;2:-1&quot;);
 700     }
 701 
 702     @Test(expectedExceptions=IllegalArgumentException.class)
 703     public void test_padNext_2arg_invalidWidth() throws Exception {
 704         builder.padNext(0, &#39;-&#39;);
 705     }
 706 
 707     //-----------------------------------------------------------------------
 708     @Test
 709     public void test_padOptional() throws Exception {
 710         builder.appendValue(MONTH_OF_YEAR).appendLiteral(&#39;:&#39;)
 711                 .padNext(5).optionalStart().appendValue(DAY_OF_MONTH).optionalEnd()
 712                 .appendLiteral(&#39;:&#39;).appendValue(YEAR);
 713         assertEquals(builder.toFormatter().format(LocalDate.of(2013, 2, 1)), &quot;2:    1:2013&quot;);
 714         assertEquals(builder.toFormatter().format(YearMonth.of(2013, 2)), &quot;2:     :2013&quot;);
 715     }
 716 
 717     //-----------------------------------------------------------------------
 718     //-----------------------------------------------------------------------
 719     //-----------------------------------------------------------------------
 720     @Test(expectedExceptions=IllegalStateException.class)
 721     public void test_optionalEnd_noStart() throws Exception {
 722         builder.optionalEnd();
 723     }
 724 
 725     //-----------------------------------------------------------------------
 726     //-----------------------------------------------------------------------
 727     //-----------------------------------------------------------------------
 728     @DataProvider(name=&quot;validPatterns&quot;)
 729     Object[][] dataValid() {
 730         return new Object[][] {
 731             {&quot;&#39;a&#39;&quot;},
 732             {&quot;&#39;&#39;&quot;},
 733             {&quot;&#39;!&#39;&quot;},
 734             {&quot;!&quot;},
 735             {&quot;&#39;#&#39;&quot;},
 736 
 737             {&quot;&#39;hello_people,][)(&#39;&quot;},
 738             {&quot;&#39;hi&#39;&quot;},
 739             {&quot;&#39;yyyy&#39;&quot;},
 740             {&quot;&#39;&#39;&#39;&#39;&quot;},
 741             {&quot;&#39;o&#39;&#39;clock&#39;&quot;},
 742 
 743             {&quot;G&quot;},
 744             {&quot;GG&quot;},
 745             {&quot;GGG&quot;},
 746             {&quot;GGGG&quot;},
 747             {&quot;GGGGG&quot;},
 748 
 749             {&quot;y&quot;},
 750             {&quot;yy&quot;},
 751             {&quot;yyy&quot;},
 752             {&quot;yyyy&quot;},
 753             {&quot;yyyyy&quot;},
 754 
 755             {&quot;M&quot;},
 756             {&quot;MM&quot;},
 757             {&quot;MMM&quot;},
 758             {&quot;MMMM&quot;},
 759             {&quot;MMMMM&quot;},
 760 
 761             {&quot;L&quot;},
 762             {&quot;LL&quot;},
 763             {&quot;LLL&quot;},
 764             {&quot;LLLL&quot;},
 765             {&quot;LLLLL&quot;},
 766 
 767             {&quot;D&quot;},
 768             {&quot;DD&quot;},
 769             {&quot;DDD&quot;},
 770 
 771             {&quot;d&quot;},
 772             {&quot;dd&quot;},
 773 
 774             {&quot;F&quot;},
 775 
 776             {&quot;Q&quot;},
 777             {&quot;QQ&quot;},
 778             {&quot;QQQ&quot;},
 779             {&quot;QQQQ&quot;},
 780             {&quot;QQQQQ&quot;},
 781 
 782             {&quot;q&quot;},
 783             {&quot;qq&quot;},
 784             {&quot;qqq&quot;},
 785             {&quot;qqqq&quot;},
 786             {&quot;qqqqq&quot;},
 787 
 788             {&quot;E&quot;},
 789             {&quot;EE&quot;},
 790             {&quot;EEE&quot;},
 791             {&quot;EEEE&quot;},
 792             {&quot;EEEEE&quot;},
 793 
 794             {&quot;e&quot;},
 795             {&quot;ee&quot;},
 796             {&quot;eee&quot;},
 797             {&quot;eeee&quot;},
 798             {&quot;eeeee&quot;},
 799 
 800             {&quot;c&quot;},
 801             {&quot;ccc&quot;},
 802             {&quot;cccc&quot;},
 803             {&quot;ccccc&quot;},
 804 
 805             {&quot;a&quot;},
 806 
 807             {&quot;H&quot;},
 808             {&quot;HH&quot;},
 809 
 810             {&quot;K&quot;},
 811             {&quot;KK&quot;},
 812 
 813             {&quot;k&quot;},
 814             {&quot;kk&quot;},
 815 
 816             {&quot;h&quot;},
 817             {&quot;hh&quot;},
 818 
 819             {&quot;m&quot;},
 820             {&quot;mm&quot;},
 821 
 822             {&quot;s&quot;},
 823             {&quot;ss&quot;},
 824 
 825             {&quot;S&quot;},
 826             {&quot;SS&quot;},
 827             {&quot;SSS&quot;},
 828             {&quot;SSSSSSSSS&quot;},
 829 
 830             {&quot;A&quot;},
 831             {&quot;AA&quot;},
 832             {&quot;AAA&quot;},
 833 
 834             {&quot;n&quot;},
 835             {&quot;nn&quot;},
 836             {&quot;nnn&quot;},
 837 
 838             {&quot;N&quot;},
 839             {&quot;NN&quot;},
 840             {&quot;NNN&quot;},
 841 
 842             {&quot;z&quot;},
 843             {&quot;zz&quot;},
 844             {&quot;zzz&quot;},
 845             {&quot;zzzz&quot;},
 846 
 847             {&quot;VV&quot;},
 848 
 849             {&quot;Z&quot;},
 850             {&quot;ZZ&quot;},
 851             {&quot;ZZZ&quot;},
 852 
 853             {&quot;X&quot;},
 854             {&quot;XX&quot;},
 855             {&quot;XXX&quot;},
 856             {&quot;XXXX&quot;},
 857             {&quot;XXXXX&quot;},
 858 
 859             {&quot;x&quot;},
 860             {&quot;xx&quot;},
 861             {&quot;xxx&quot;},
 862             {&quot;xxxx&quot;},
 863             {&quot;xxxxx&quot;},
 864 
 865             {&quot;ppH&quot;},
 866             {&quot;pppDD&quot;},
 867 
 868             {&quot;yyyy[-MM[-dd&quot;},
 869             {&quot;yyyy[-MM[-dd]]&quot;},
 870             {&quot;yyyy[-MM[]-dd]&quot;},
 871 
 872             {&quot;yyyy-MM-dd&#39;T&#39;HH:mm:ss.SSS&quot;},
 873 
 874             {&quot;e&quot;},
 875             {&quot;w&quot;},
 876             {&quot;ww&quot;},
 877             {&quot;W&quot;},
 878             {&quot;W&quot;},
 879 
 880             {&quot;g&quot;},
 881             {&quot;ggggg&quot;},
 882         };
 883     }
 884 
 885     @Test(dataProvider=&quot;validPatterns&quot;)
 886     public void test_appendPattern_valid(String input) throws Exception {
 887         builder.appendPattern(input);  // test is for no error here
 888     }
 889 
 890     //-----------------------------------------------------------------------
 891     @DataProvider(name=&quot;invalidPatterns&quot;)
 892     Object[][] dataInvalid() {
 893         return new Object[][] {
 894             {&quot;&#39;&quot;},
 895             {&quot;&#39;hello&quot;},
 896             {&quot;&#39;hel&#39;&#39;lo&quot;},
 897             {&quot;&#39;hello&#39;&#39;&quot;},
 898             {&quot;{&quot;},
 899             {&quot;}&quot;},
 900             {&quot;{}&quot;},
 901             {&quot;#&quot;},
 902             {&quot;]&quot;},
 903             {&quot;yyyy]&quot;},
 904             {&quot;yyyy]MM&quot;},
 905             {&quot;yyyy[MM]]&quot;},
 906 
 907             {&quot;aa&quot;},
 908             {&quot;aaa&quot;},
 909             {&quot;aaaa&quot;},
 910             {&quot;aaaaa&quot;},
 911             {&quot;aaaaaa&quot;},
 912             {&quot;MMMMMM&quot;},
 913             {&quot;QQQQQQ&quot;},
 914             {&quot;qqqqqq&quot;},
 915             {&quot;EEEEEE&quot;},
 916             {&quot;eeeeee&quot;},
 917             {&quot;cc&quot;},
 918             {&quot;cccccc&quot;},
 919             {&quot;ddd&quot;},
 920             {&quot;DDDD&quot;},
 921             {&quot;FF&quot;},
 922             {&quot;FFF&quot;},
 923             {&quot;hhh&quot;},
 924             {&quot;HHH&quot;},
 925             {&quot;kkk&quot;},
 926             {&quot;KKK&quot;},
 927             {&quot;mmm&quot;},
 928             {&quot;sss&quot;},
 929             {&quot;OO&quot;},
 930             {&quot;OOO&quot;},
 931             {&quot;OOOOO&quot;},
 932             {&quot;XXXXXX&quot;},
 933             {&quot;zzzzz&quot;},
 934             {&quot;ZZZZZZ&quot;},
 935 
 936             {&quot;RO&quot;},
 937 
 938             {&quot;p&quot;},
 939             {&quot;pp&quot;},
 940             {&quot;p:&quot;},
 941 
 942             {&quot;f&quot;},
 943             {&quot;ff&quot;},
 944             {&quot;f:&quot;},
 945             {&quot;fy&quot;},
 946             {&quot;fa&quot;},
 947             {&quot;fM&quot;},
 948 
 949             {&quot;www&quot;},
 950             {&quot;WW&quot;},
 951 
 952             {&quot;vv&quot;},
 953             {&quot;vvv&quot;},
 954         };
 955     }
 956 
 957     @Test(dataProvider=&quot;invalidPatterns&quot;, expectedExceptions=IllegalArgumentException.class)
 958     public void test_appendPattern_invalid(String input) throws Exception {
 959         builder.appendPattern(input);  // test is for error here
 960     }
 961 
 962     //-----------------------------------------------------------------------
 963     @DataProvider(name=&quot;patternPrint&quot;)
 964     Object[][] data_patternPrint() {
 965         return new Object[][] {
 966             {&quot;Q&quot;, date(2012, 2, 10), &quot;1&quot;},
 967             {&quot;QQ&quot;, date(2012, 2, 10), &quot;01&quot;},
 968             {&quot;QQQ&quot;, date(2012, 2, 10), &quot;Q1&quot;},
 969             {&quot;QQQQ&quot;, date(2012, 2, 10), &quot;1st quarter&quot;},
 970             {&quot;QQQQQ&quot;, date(2012, 2, 10), &quot;1&quot;},
 971         };
 972     }
 973 
 974     @Test(dataProvider=&quot;patternPrint&quot;)
 975     public void test_appendPattern_patternPrint(String input, Temporal temporal, String expected) throws Exception {
 976         DateTimeFormatter f = builder.appendPattern(input).toFormatter(Locale.UK);
 977         String test = f.format(temporal);
 978         assertEquals(test, expected);
 979     }
 980 
 981     private static Temporal date(int y, int m, int d) {
 982         return LocalDate.of(y, m, d);
 983     }
 984 
 985     //-----------------------------------------------------------------------
 986     @DataProvider(name=&quot;modJulianFieldPattern&quot;)
 987     Object[][] data_modJuilanFieldPattern() {
 988         return new Object[][] {
 989             {&quot;g&quot;, &quot;1&quot;},
 990             {&quot;g&quot;, &quot;123456&quot;},
 991             {&quot;gggggg&quot;, &quot;123456&quot;},
 992         };
 993     }
 994 
 995     @Test(dataProvider=&quot;modJulianFieldPattern&quot;)
 996     public void test_modJulianFieldPattern(String pattern, String input) throws Exception {
 997         DateTimeFormatter.ofPattern(pattern).parse(input);
 998     }
 999 
1000     @DataProvider(name=&quot;modJulianFieldValues&quot;)
1001     Object[][] data_modJuilanFieldValues() {
1002         return new Object[][] {
1003             {1970, 1, 1, &quot;40587&quot;},
1004             {1858, 11, 17, &quot;0&quot;},
1005             {1858, 11, 16, &quot;-1&quot;},
1006         };
1007     }
1008 
1009     @Test(dataProvider=&quot;modJulianFieldValues&quot;)
1010     public void test_modJulianFieldValues(int y, int m, int d, String expected) throws Exception {
1011         DateTimeFormatter df = new DateTimeFormatterBuilder().appendPattern(&quot;g&quot;).toFormatter();
1012          assertEquals(LocalDate.of(y, m, d).format(df), expected);
1013     }
1014     //----------------------------------------------------------------------
1015     @DataProvider(name=&quot;dayOfYearFieldValues&quot;)
1016     Object[][] data_dayOfYearFieldValues() {
1017         return new Object[][] {
1018                 {2016, 1, 1, &quot;D&quot;, &quot;1&quot;},
1019                 {2016, 1, 31, &quot;D&quot;, &quot;31&quot;},
1020                 {2016, 1, 1, &quot;DD&quot;, &quot;01&quot;},
1021                 {2016, 1, 31, &quot;DD&quot;, &quot;31&quot;},
1022                 {2016, 4, 9, &quot;DD&quot;, &quot;100&quot;},
1023                 {2016, 1, 1, &quot;DDD&quot;, &quot;001&quot;},
1024                 {2016, 1, 31, &quot;DDD&quot;, &quot;031&quot;},
1025                 {2016, 4, 9, &quot;DDD&quot;, &quot;100&quot;},
1026         };
1027     }
1028 
1029     @Test(dataProvider=&quot;dayOfYearFieldValues&quot;)
1030     public void test_dayOfYearFieldValues(int y, int m, int d, String pattern, String expected) throws Exception {
1031         DateTimeFormatter df = new DateTimeFormatterBuilder().appendPattern(pattern).toFormatter();
1032         assertEquals(LocalDate.of(y, m, d).format(df), expected);
1033     }
1034 
1035     @DataProvider(name=&quot;dayOfYearFieldAdjacentParsingValues&quot;)
1036     Object[][] data_dayOfYearFieldAdjacentParsingValues() {
1037         return new Object[][] {
1038             {&quot;20160281015&quot;, LocalDateTime.of(2016, 1, 28, 10, 15)},
1039             {&quot;20161001015&quot;, LocalDateTime.of(2016, 4, 9, 10, 15)},
1040         };
1041     }
1042 
1043     @Test(dataProvider=&quot;dayOfYearFieldAdjacentParsingValues&quot;)
1044     public void test_dayOfYearFieldAdjacentValueParsing(String input, LocalDateTime expected) {
1045         DateTimeFormatter df = new DateTimeFormatterBuilder().appendPattern(&quot;yyyyDDDHHmm&quot;).toFormatter();
1046         LocalDateTime actual = LocalDateTime.parse(input, df);
1047         assertEquals(actual, expected);
1048     }
1049 
1050     @Test(expectedExceptions = DateTimeParseException.class)
1051     public void test_dayOfYearFieldInvalidValue() {
1052         DateTimeFormatter.ofPattern(&quot;DDD&quot;).parse(&quot;1234&quot;);
1053     }
1054 
1055     @Test(expectedExceptions = DateTimeParseException.class)
1056     public void test_dayOfYearFieldInvalidAdacentValueParsingPattern() {
1057         // patterns D and DD will not take part in adjacent value parsing
1058         DateTimeFormatter.ofPattern(&quot;yyyyDDHHmmss&quot;).parse(&quot;201610123456&quot;);
1059     }
1060 
1061     //-----------------------------------------------------------------------
1062     @DataProvider(name=&quot;secondsPattern&quot;)
1063     Object[][] data_secondsPattern() {
1064         return new Object[][] {
1065                 {&quot;A&quot;, &quot;1&quot;, LocalTime.ofNanoOfDay(1_000_000)},
1066                 {&quot;A&quot;, &quot;100000&quot;, LocalTime.ofSecondOfDay(100)},
1067                 {&quot;AA&quot;, &quot;01&quot;, LocalTime.ofNanoOfDay(1_000_000)},
1068                 {&quot;AA&quot;, &quot;100000&quot;, LocalTime.ofSecondOfDay(100)},
1069                 {&quot;AAAAAA&quot;, &quot;100000&quot;, LocalTime.ofSecondOfDay(100)},
1070                 {&quot;HHmmssn&quot;, &quot;0000001&quot;, LocalTime.ofNanoOfDay(1)},
1071                 {&quot;HHmmssn&quot;, &quot;000000111&quot;, LocalTime.ofNanoOfDay(111)},
1072                 {&quot;HHmmssnn&quot;, &quot;00000001&quot;, LocalTime.ofNanoOfDay(1)},
1073                 {&quot;HHmmssnn&quot;, &quot;0000001111&quot;, LocalTime.ofNanoOfDay(1111)},
1074                 {&quot;HHmmssnnnnnn&quot;, &quot;000000111111&quot;, LocalTime.ofNanoOfDay(111_111)},
1075                 {&quot;N&quot;, &quot;1&quot;, LocalTime.ofNanoOfDay(1)},
1076                 {&quot;N&quot;, &quot;100000&quot;, LocalTime.ofNanoOfDay(100_000)},
1077                 {&quot;NN&quot;, &quot;01&quot;, LocalTime.ofNanoOfDay(1)},
1078                 {&quot;NN&quot;, &quot;100000&quot;, LocalTime.ofNanoOfDay(100_000)},
1079                 {&quot;NNNNNN&quot;, &quot;100000&quot;, LocalTime.ofNanoOfDay(100_000)},
1080         };
1081     }
1082 
1083     @Test(dataProvider=&quot;secondsPattern&quot;)
1084     public void test_secondsPattern(String pattern, String input, LocalTime expected) throws Exception {
1085         DateTimeFormatter df = new DateTimeFormatterBuilder().appendPattern(pattern).toFormatter();
1086         assertEquals(LocalTime.parse(input, df), expected);
1087     }
1088 
1089     @DataProvider(name=&quot;secondsValues&quot;)
1090     Object[][] data_secondsValues() {
1091         return new Object[][] {
1092                 {&quot;A&quot;, 1, &quot;1000&quot;},
1093                 {&quot;n&quot;, 1, &quot;0&quot;},
1094                 {&quot;N&quot;, 1, &quot;1000000000&quot;},
1095         };
1096     }
1097 
1098     @Test(dataProvider=&quot;secondsValues&quot;)
1099     public void test_secondsValues(String pattern, int seconds , String expected) throws Exception {
1100         DateTimeFormatter df = new DateTimeFormatterBuilder().appendPattern(pattern).toFormatter();
1101         assertEquals(LocalTime.ofSecondOfDay(seconds).format(df), expected);
1102     }
1103 
1104     @Test(expectedExceptions = DateTimeParseException.class)
1105     public void test_secondsPatternInvalidAdacentValueParsingPattern() {
1106         // patterns A*, N*, n* will not take part in adjacent value parsing
1107         DateTimeFormatter.ofPattern(&quot;yyyyAA&quot;).parse(&quot;201610&quot;);
1108     }
1109 
1110     //-----------------------------------------------------------------------
1111     @Test
1112     public void test_adjacent_strict_firstFixedWidth() throws Exception {
1113         // succeeds because both number elements are fixed width
1114         DateTimeFormatter f = builder.appendValue(HOUR_OF_DAY, 2).appendValue(MINUTE_OF_HOUR, 2).appendLiteral(&#39;9&#39;).toFormatter(Locale.UK);
1115         ParsePosition pp = new ParsePosition(0);
1116         TemporalAccessor parsed = f.parseUnresolved(&quot;12309&quot;, pp);
1117         assertEquals(pp.getErrorIndex(), -1);
1118         assertEquals(pp.getIndex(), 5);
1119         assertEquals(parsed.getLong(HOUR_OF_DAY), 12L);
1120         assertEquals(parsed.getLong(MINUTE_OF_HOUR), 30L);
1121     }
1122 
1123     @Test
1124     public void test_adjacent_strict_firstVariableWidth_success() throws Exception {
1125         // succeeds greedily parsing variable width, then fixed width, to non-numeric Z
1126         DateTimeFormatter f = builder.appendValue(HOUR_OF_DAY).appendValue(MINUTE_OF_HOUR, 2).appendLiteral(&#39;Z&#39;).toFormatter(Locale.UK);
1127         ParsePosition pp = new ParsePosition(0);
1128         TemporalAccessor parsed = f.parseUnresolved(&quot;12309Z&quot;, pp);
1129         assertEquals(pp.getErrorIndex(), -1);
1130         assertEquals(pp.getIndex(), 6);
1131         assertEquals(parsed.getLong(HOUR_OF_DAY), 123L);
1132         assertEquals(parsed.getLong(MINUTE_OF_HOUR), 9L);
1133     }
1134 
1135     @Test
1136     public void test_adjacent_strict_firstVariableWidth_fails() throws Exception {
1137         // fails because literal is a number and variable width parse greedily absorbs it
1138         DateTimeFormatter f = builder.appendValue(HOUR_OF_DAY).appendValue(MINUTE_OF_HOUR, 2).appendLiteral(&#39;9&#39;).toFormatter(Locale.UK);
1139         ParsePosition pp = new ParsePosition(0);
1140         TemporalAccessor parsed = f.parseUnresolved(&quot;12309&quot;, pp);
1141         assertEquals(pp.getErrorIndex(), 5);
1142         assertEquals(parsed, null);
1143     }
1144 
1145     @Test
1146     public void test_adjacent_lenient() throws Exception {
1147         // succeeds because both number elements are fixed width even in lenient mode
1148         DateTimeFormatter f = builder.parseLenient().appendValue(HOUR_OF_DAY, 2).appendValue(MINUTE_OF_HOUR, 2).appendLiteral(&#39;9&#39;).toFormatter(Locale.UK);
1149         ParsePosition pp = new ParsePosition(0);
1150         TemporalAccessor parsed = f.parseUnresolved(&quot;12309&quot;, pp);
1151         assertEquals(pp.getErrorIndex(), -1);
1152         assertEquals(pp.getIndex(), 5);
1153         assertEquals(parsed.getLong(HOUR_OF_DAY), 12L);
1154         assertEquals(parsed.getLong(MINUTE_OF_HOUR), 30L);
1155     }
1156 
1157     @Test
1158     public void test_adjacent_lenient_firstVariableWidth_success() throws Exception {
1159         // succeeds greedily parsing variable width, then fixed width, to non-numeric Z
1160         DateTimeFormatter f = builder.parseLenient().appendValue(HOUR_OF_DAY).appendValue(MINUTE_OF_HOUR, 2).appendLiteral(&#39;Z&#39;).toFormatter(Locale.UK);
1161         ParsePosition pp = new ParsePosition(0);
1162         TemporalAccessor parsed = f.parseUnresolved(&quot;12309Z&quot;, pp);
1163         assertEquals(pp.getErrorIndex(), -1);
1164         assertEquals(pp.getIndex(), 6);
1165         assertEquals(parsed.getLong(HOUR_OF_DAY), 123L);
1166         assertEquals(parsed.getLong(MINUTE_OF_HOUR), 9L);
1167     }
1168 
1169     @Test
1170     public void test_adjacent_lenient_firstVariableWidth_fails() throws Exception {
1171         // fails because literal is a number and variable width parse greedily absorbs it
1172         DateTimeFormatter f = builder.parseLenient().appendValue(HOUR_OF_DAY).appendValue(MINUTE_OF_HOUR, 2).appendLiteral(&#39;9&#39;).toFormatter(Locale.UK);
1173         ParsePosition pp = new ParsePosition(0);
1174         TemporalAccessor parsed = f.parseUnresolved(&quot;12309&quot;, pp);
1175         assertEquals(pp.getErrorIndex(), 5);
1176         assertEquals(parsed, null);
1177     }
1178 
1179     //-----------------------------------------------------------------------
1180     @Test
1181     public void test_adjacent_strict_fractionFollows() throws Exception {
1182         // succeeds because hour/min are fixed width
1183         DateTimeFormatter f = builder.appendValue(HOUR_OF_DAY, 2).appendValue(MINUTE_OF_HOUR, 2).appendFraction(NANO_OF_SECOND, 0, 3, false).toFormatter(Locale.UK);
1184         ParsePosition pp = new ParsePosition(0);
1185         TemporalAccessor parsed = f.parseUnresolved(&quot;1230567&quot;, pp);
1186         assertEquals(pp.getErrorIndex(), -1);
1187         assertEquals(pp.getIndex(), 7);
1188         assertEquals(parsed.getLong(HOUR_OF_DAY), 12L);
1189         assertEquals(parsed.getLong(MINUTE_OF_HOUR), 30L);
1190         assertEquals(parsed.getLong(NANO_OF_SECOND), 567_000_000L);
1191     }
1192 
1193     @Test
1194     public void test_adjacent_strict_fractionFollows_2digit() throws Exception {
1195         // succeeds because hour/min are fixed width
1196         DateTimeFormatter f = builder.appendValue(HOUR_OF_DAY, 2).appendValue(MINUTE_OF_HOUR, 2).appendFraction(NANO_OF_SECOND, 0, 3, false).toFormatter(Locale.UK);
1197         ParsePosition pp = new ParsePosition(0);
1198         TemporalAccessor parsed = f.parseUnresolved(&quot;123056&quot;, pp);
1199         assertEquals(pp.getErrorIndex(), -1);
1200         assertEquals(pp.getIndex(), 6);
1201         assertEquals(parsed.getLong(HOUR_OF_DAY), 12L);
1202         assertEquals(parsed.getLong(MINUTE_OF_HOUR), 30L);
1203         assertEquals(parsed.getLong(NANO_OF_SECOND), 560_000_000L);
1204     }
1205 
1206     @Test
1207     public void test_adjacent_strict_fractionFollows_0digit() throws Exception {
1208         // succeeds because hour/min are fixed width
1209         DateTimeFormatter f = builder.appendValue(HOUR_OF_DAY, 2).appendValue(MINUTE_OF_HOUR, 2).appendFraction(NANO_OF_SECOND, 0, 3, false).toFormatter(Locale.UK);
1210         ParsePosition pp = new ParsePosition(0);
1211         TemporalAccessor parsed = f.parseUnresolved(&quot;1230&quot;, pp);
1212         assertEquals(pp.getErrorIndex(), -1);
1213         assertEquals(pp.getIndex(), 4);
1214         assertEquals(parsed.getLong(HOUR_OF_DAY), 12L);
1215         assertEquals(parsed.getLong(MINUTE_OF_HOUR), 30L);
1216     }
1217 
1218     @Test
1219     public void test_adjacent_lenient_fractionFollows() throws Exception {
1220         // succeeds because hour/min are fixed width
1221         DateTimeFormatter f = builder.parseLenient().appendValue(HOUR_OF_DAY, 2).appendValue(MINUTE_OF_HOUR, 2).appendFraction(NANO_OF_SECOND, 3, 3, false).toFormatter(Locale.UK);
1222         ParsePosition pp = new ParsePosition(0);
1223         TemporalAccessor parsed = f.parseUnresolved(&quot;1230567&quot;, pp);
1224         assertEquals(pp.getErrorIndex(), -1);
1225         assertEquals(pp.getIndex(), 7);
1226         assertEquals(parsed.getLong(HOUR_OF_DAY), 12L);
1227         assertEquals(parsed.getLong(MINUTE_OF_HOUR), 30L);
1228         assertEquals(parsed.getLong(NANO_OF_SECOND), 567_000_000L);
1229     }
1230 
1231     @Test
1232     public void test_adjacent_lenient_fractionFollows_2digit() throws Exception {
1233         // succeeds because hour/min are fixed width
1234         DateTimeFormatter f = builder.parseLenient().appendValue(HOUR_OF_DAY, 2).appendValue(MINUTE_OF_HOUR, 2).appendFraction(NANO_OF_SECOND, 3, 3, false).toFormatter(Locale.UK);
1235         ParsePosition pp = new ParsePosition(0);
1236         TemporalAccessor parsed = f.parseUnresolved(&quot;123056&quot;, pp);
1237         assertEquals(pp.getErrorIndex(), -1);
1238         assertEquals(pp.getIndex(), 6);
1239         assertEquals(parsed.getLong(HOUR_OF_DAY), 12L);
1240         assertEquals(parsed.getLong(MINUTE_OF_HOUR), 30L);
1241         assertEquals(parsed.getLong(NANO_OF_SECOND), 560_000_000L);
1242     }
1243 
1244     @Test
1245     public void test_adjacent_lenient_fractionFollows_0digit() throws Exception {
1246         // succeeds because hour, min and fraction of seconds are fixed width
1247         DateTimeFormatter f = builder.parseLenient().appendValue(HOUR_OF_DAY, 2).appendValue(MINUTE_OF_HOUR, 2).appendFraction(NANO_OF_SECOND, 3, 3, false).toFormatter(Locale.UK);
1248         ParsePosition pp = new ParsePosition(0);
1249         TemporalAccessor parsed = f.parseUnresolved(&quot;1230&quot;, pp);
1250         assertEquals(pp.getErrorIndex(), -1);
1251         assertEquals(pp.getIndex(), 4);
1252         assertEquals(parsed.getLong(HOUR_OF_DAY), 12L);
1253         assertEquals(parsed.getLong(MINUTE_OF_HOUR), 30L);
1254     }
1255 
1256     @DataProvider(name=&quot;adjacentFractionParseData&quot;)
1257     Object[][] data_adjacent_fraction_parse() {
1258         return new Object[][] {
1259             {&quot;20130812214600025&quot;, &quot;yyyyMMddHHmmssSSS&quot;, LocalDateTime.of(2013, 8, 12, 21, 46, 00, 25000000)},
1260             {&quot;201308122146000256&quot;, &quot;yyyyMMddHHmmssSSSS&quot;, LocalDateTime.of(2013, 8, 12, 21, 46, 00, 25600000)},
1261         };
1262     }
1263 
1264     @Test(dataProvider = &quot;adjacentFractionParseData&quot;)
1265     public void test_adjacent_fraction(String input, String pattern, LocalDateTime expected) {
1266         DateTimeFormatter dtf = DateTimeFormatter.ofPattern(pattern);
1267         LocalDateTime actual = LocalDateTime.parse(input, dtf);
1268         assertEquals(actual, expected);
1269     }
1270 
1271     @DataProvider(name=&quot;lenientOffsetParseData&quot;)
1272     Object[][] data_lenient_offset_parse() {
1273         return new Object[][] {
1274             {&quot;+HH&quot;, &quot;+01&quot;, 3600},
1275             {&quot;+HH&quot;, &quot;+0101&quot;, 3660},
1276             {&quot;+HH&quot;, &quot;+010101&quot;, 3661},
1277             {&quot;+HH&quot;, &quot;+01&quot;, 3600},
1278             {&quot;+HH&quot;, &quot;+01:01&quot;, 3660},
1279             {&quot;+HH&quot;, &quot;+01:01:01&quot;, 3661},
1280             {&quot;+HHmm&quot;, &quot;+01&quot;, 3600},
1281             {&quot;+HHmm&quot;, &quot;+0101&quot;, 3660},
1282             {&quot;+HHmm&quot;, &quot;+010101&quot;, 3661},
1283             {&quot;+HH:mm&quot;, &quot;+01&quot;, 3600},
1284             {&quot;+HH:mm&quot;, &quot;+01:01&quot;, 3660},
1285             {&quot;+HH:mm&quot;, &quot;+01:01:01&quot;, 3661},
1286             {&quot;+HHMM&quot;, &quot;+01&quot;, 3600},
1287             {&quot;+HHMM&quot;, &quot;+0101&quot;, 3660},
1288             {&quot;+HHMM&quot;, &quot;+010101&quot;, 3661},
1289             {&quot;+HH:MM&quot;, &quot;+01&quot;, 3600},
1290             {&quot;+HH:MM&quot;, &quot;+01:01&quot;, 3660},
1291             {&quot;+HH:MM&quot;, &quot;+01:01:01&quot;, 3661},
1292             {&quot;+HHMMss&quot;, &quot;+01&quot;, 3600},
1293             {&quot;+HHMMss&quot;, &quot;+0101&quot;, 3660},
1294             {&quot;+HHMMss&quot;, &quot;+010101&quot;, 3661},
1295             {&quot;+HH:MM:ss&quot;, &quot;+01&quot;, 3600},
1296             {&quot;+HH:MM:ss&quot;, &quot;+01:01&quot;, 3660},
1297             {&quot;+HH:MM:ss&quot;, &quot;+01:01:01&quot;, 3661},
1298             {&quot;+HHMMSS&quot;, &quot;+01&quot;, 3600},
1299             {&quot;+HHMMSS&quot;, &quot;+0101&quot;, 3660},
1300             {&quot;+HHMMSS&quot;, &quot;+010101&quot;, 3661},
1301             {&quot;+HH:MM:SS&quot;, &quot;+01&quot;, 3600},
1302             {&quot;+HH:MM:SS&quot;, &quot;+01:01&quot;, 3660},
1303             {&quot;+HH:MM:SS&quot;, &quot;+01:01:01&quot;, 3661},
1304             {&quot;+HHmmss&quot;, &quot;+01&quot;, 3600},
1305             {&quot;+HHmmss&quot;, &quot;+0101&quot;, 3660},
1306             {&quot;+HHmmss&quot;, &quot;+010101&quot;, 3661},
1307             {&quot;+HH:mm:ss&quot;, &quot;+01&quot;, 3600},
1308             {&quot;+HH:mm:ss&quot;, &quot;+01:01&quot;, 3660},
1309             {&quot;+HH:mm:ss&quot;, &quot;+01:01:01&quot;, 3661},
1310 
1311             {&quot;+H&quot;, &quot;+1&quot;, 3600},
1312             {&quot;+H&quot;, &quot;+101&quot;, 3660},
1313             {&quot;+H&quot;, &quot;+10101&quot;, 3661},
1314             {&quot;+H&quot;, &quot;+1:01&quot;, 3660},
1315             {&quot;+H&quot;, &quot;+1:01:01&quot;, 3661},
1316             {&quot;+H&quot;, &quot;+01&quot;, 3600},
1317             {&quot;+H&quot;, &quot;+0101&quot;, 3660},
1318             {&quot;+H&quot;, &quot;+010101&quot;, 3661},
1319             {&quot;+H&quot;, &quot;+01:01&quot;, 3660},
1320             {&quot;+H&quot;, &quot;+01:01:01&quot;, 3661},
1321             {&quot;+Hmm&quot;, &quot;+1&quot;, 3600},
1322             {&quot;+Hmm&quot;, &quot;+101&quot;, 3660},
1323             {&quot;+Hmm&quot;, &quot;+10101&quot;, 3661},
1324             {&quot;+Hmm&quot;, &quot;+01&quot;, 3600},
1325             {&quot;+Hmm&quot;, &quot;+0101&quot;, 3660},
1326             {&quot;+Hmm&quot;, &quot;+010101&quot;, 3661},
1327             {&quot;+H:mm&quot;, &quot;+1&quot;, 3600},
1328             {&quot;+H:mm&quot;, &quot;+1:01&quot;, 3660},
1329             {&quot;+H:mm&quot;, &quot;+1:01:01&quot;, 3661},
1330             {&quot;+H:mm&quot;, &quot;+01&quot;, 3600},
1331             {&quot;+H:mm&quot;, &quot;+01:01&quot;, 3660},
1332             {&quot;+H:mm&quot;, &quot;+01:01:01&quot;, 3661},
1333             {&quot;+HMM&quot;, &quot;+1&quot;, 3600},
1334             {&quot;+HMM&quot;, &quot;+101&quot;, 3660},
1335             {&quot;+HMM&quot;, &quot;+10101&quot;, 3661},
1336             {&quot;+HMM&quot;, &quot;+01&quot;, 3600},
1337             {&quot;+HMM&quot;, &quot;+0101&quot;, 3660},
1338             {&quot;+HMM&quot;, &quot;+010101&quot;, 3661},
1339             {&quot;+H:MM&quot;, &quot;+1&quot;, 3600},
1340             {&quot;+H:MM&quot;, &quot;+1:01&quot;, 3660},
1341             {&quot;+H:MM&quot;, &quot;+1:01:01&quot;, 3661},
1342             {&quot;+H:MM&quot;, &quot;+01&quot;, 3600},
1343             {&quot;+H:MM&quot;, &quot;+01:01&quot;, 3660},
1344             {&quot;+H:MM&quot;, &quot;+01:01:01&quot;, 3661},
1345             {&quot;+HMMss&quot;, &quot;+1&quot;, 3600},
1346             {&quot;+HMMss&quot;, &quot;+101&quot;, 3660},
1347             {&quot;+HMMss&quot;, &quot;+10101&quot;, 3661},
1348             {&quot;+HMMss&quot;, &quot;+01&quot;, 3600},
1349             {&quot;+HMMss&quot;, &quot;+0101&quot;, 3660},
1350             {&quot;+HMMss&quot;, &quot;+010101&quot;, 3661},
1351             {&quot;+H:MM:ss&quot;, &quot;+1&quot;, 3600},
1352             {&quot;+H:MM:ss&quot;, &quot;+1:01&quot;, 3660},
1353             {&quot;+H:MM:ss&quot;, &quot;+1:01:01&quot;, 3661},
1354             {&quot;+H:MM:ss&quot;, &quot;+01&quot;, 3600},
1355             {&quot;+H:MM:ss&quot;, &quot;+01:01&quot;, 3660},
1356             {&quot;+H:MM:ss&quot;, &quot;+01:01:01&quot;, 3661},
1357             {&quot;+HMMSS&quot;, &quot;+1&quot;, 3600},
1358             {&quot;+HMMSS&quot;, &quot;+101&quot;, 3660},
1359             {&quot;+HMMSS&quot;, &quot;+10101&quot;, 3661},
1360             {&quot;+HMMSS&quot;, &quot;+01&quot;, 3600},
1361             {&quot;+HMMSS&quot;, &quot;+0101&quot;, 3660},
1362             {&quot;+HMMSS&quot;, &quot;+010101&quot;, 3661},
1363             {&quot;+H:MM:SS&quot;, &quot;+1&quot;, 3600},
1364             {&quot;+H:MM:SS&quot;, &quot;+1:01&quot;, 3660},
1365             {&quot;+H:MM:SS&quot;, &quot;+1:01:01&quot;, 3661},
1366             {&quot;+H:MM:SS&quot;, &quot;+01&quot;, 3600},
1367             {&quot;+H:MM:SS&quot;, &quot;+01:01&quot;, 3660},
1368             {&quot;+H:MM:SS&quot;, &quot;+01:01:01&quot;, 3661},
1369             {&quot;+Hmmss&quot;, &quot;+1&quot;, 3600},
1370             {&quot;+Hmmss&quot;, &quot;+101&quot;, 3660},
1371             {&quot;+Hmmss&quot;, &quot;+10101&quot;, 3661},
1372             {&quot;+Hmmss&quot;, &quot;+01&quot;, 3600},
1373             {&quot;+Hmmss&quot;, &quot;+0101&quot;, 3660},
1374             {&quot;+Hmmss&quot;, &quot;+010101&quot;, 3661},
1375             {&quot;+H:mm:ss&quot;, &quot;+1&quot;, 3600},
1376             {&quot;+H:mm:ss&quot;, &quot;+1:01&quot;, 3660},
1377             {&quot;+H:mm:ss&quot;, &quot;+1:01:01&quot;, 3661},
1378             {&quot;+H:mm:ss&quot;, &quot;+01&quot;, 3600},
1379             {&quot;+H:mm:ss&quot;, &quot;+01:01&quot;, 3660},
1380             {&quot;+H:mm:ss&quot;, &quot;+01:01:01&quot;, 3661},
1381         };
1382     }
1383 
1384     @DataProvider(name=&quot;strictDoubleDigitHourOffsetParseData&quot;)
1385     Object[][] data_strictDoubleDigitHour_offset_parse() {
1386         return new Object[][] {
1387             {&quot;+HH&quot;, &quot;+01&quot;, 3600},
1388             {&quot;+HHmm&quot;, &quot;+01&quot;, 3600},
1389             {&quot;+HHmm&quot;, &quot;+0101&quot;, 3660},
1390             {&quot;+HH:mm&quot;, &quot;+01&quot;, 3600},
1391             {&quot;+HH:mm&quot;, &quot;+01:01&quot;, 3660},
1392             {&quot;+HHMM&quot;, &quot;+0101&quot;, 3660},
1393             {&quot;+HH:MM&quot;, &quot;+01:01&quot;, 3660},
1394             {&quot;+HHMMss&quot;, &quot;+0101&quot;, 3660},
1395             {&quot;+HHMMss&quot;, &quot;+010101&quot;, 3661},
1396             {&quot;+HH:MM:ss&quot;, &quot;+01:01&quot;, 3660},
1397             {&quot;+HH:MM:ss&quot;, &quot;+01:01:01&quot;, 3661},
1398             {&quot;+HHMMSS&quot;, &quot;+010101&quot;, 3661},
1399             {&quot;+HH:MM:SS&quot;, &quot;+01:01:01&quot;, 3661},
1400             {&quot;+HHmmss&quot;, &quot;+01&quot;, 3600},
1401             {&quot;+HHmmss&quot;, &quot;+0101&quot;, 3660},
1402             {&quot;+HHmmss&quot;, &quot;+010101&quot;, 3661},
1403             {&quot;+HH:mm:ss&quot;, &quot;+01&quot;, 3600},
1404             {&quot;+HH:mm:ss&quot;, &quot;+01:01&quot;, 3660},
1405             {&quot;+HH:mm:ss&quot;, &quot;+01:01:01&quot;, 3661},
1406         };
1407     }
1408 
1409     @DataProvider(name=&quot;strictSingleDigitHourOffsetParseData&quot;)
1410     Object[][] data_strictSingleDigitHour_offset_parse() {
1411         return new Object[][] {
1412             {&quot;+H&quot;, &quot;+01&quot;, 3600},
1413             {&quot;+H&quot;, &quot;+1&quot;, 3600},
1414             {&quot;+Hmm&quot;, &quot;+01&quot;, 3600},
1415             {&quot;+Hmm&quot;, &quot;+0101&quot;, 3660},
1416             {&quot;+Hmm&quot;, &quot;+1&quot;, 3600},
1417             {&quot;+Hmm&quot;, &quot;+101&quot;, 3660},
1418             {&quot;+H:mm&quot;, &quot;+01&quot;, 3600},
1419             {&quot;+H:mm&quot;, &quot;+01:01&quot;, 3660},
1420             {&quot;+H:mm&quot;, &quot;+1&quot;, 3600},
1421             {&quot;+H:mm&quot;, &quot;+1:01&quot;, 3660},
1422             {&quot;+HMM&quot;, &quot;+0101&quot;, 3660},
1423             {&quot;+HMM&quot;, &quot;+101&quot;, 3660},
1424             {&quot;+H:MM&quot;, &quot;+01:01&quot;, 3660},
1425             {&quot;+H:MM&quot;, &quot;+1:01&quot;, 3660},
1426             {&quot;+HMMss&quot;, &quot;+0101&quot;, 3660},
1427             {&quot;+HMMss&quot;, &quot;+010101&quot;, 3661},
1428             {&quot;+HMMss&quot;, &quot;+101&quot;, 3660},
1429             {&quot;+HMMss&quot;, &quot;+10101&quot;, 3661},
1430             {&quot;+H:MM:ss&quot;, &quot;+01:01&quot;, 3660},
1431             {&quot;+H:MM:ss&quot;, &quot;+01:01:01&quot;, 3661},
1432             {&quot;+H:MM:ss&quot;, &quot;+1:01&quot;, 3660},
1433             {&quot;+H:MM:ss&quot;, &quot;+1:01:01&quot;, 3661},
1434             {&quot;+HMMSS&quot;, &quot;+010101&quot;, 3661},
1435             {&quot;+HMMSS&quot;, &quot;+10101&quot;, 3661},
1436             {&quot;+H:MM:SS&quot;, &quot;+01:01:01&quot;, 3661},
1437             {&quot;+H:MM:SS&quot;, &quot;+1:01:01&quot;, 3661},
1438             {&quot;+Hmmss&quot;, &quot;+01&quot;, 3600},
1439             {&quot;+Hmmss&quot;, &quot;+0101&quot;, 3660},
1440             {&quot;+Hmmss&quot;, &quot;+010101&quot;, 3661},
1441             {&quot;+Hmmss&quot;, &quot;+1&quot;, 3600},
1442             {&quot;+Hmmss&quot;, &quot;+101&quot;, 3660},
1443             {&quot;+Hmmss&quot;, &quot;+10101&quot;, 3661},
1444             {&quot;+H:mm:ss&quot;, &quot;+01&quot;, 3600},
1445             {&quot;+H:mm:ss&quot;, &quot;+01:01&quot;, 3660},
1446             {&quot;+H:mm:ss&quot;, &quot;+01:01:01&quot;, 3661},
1447             {&quot;+H:mm:ss&quot;, &quot;+1&quot;, 3600},
1448             {&quot;+H:mm:ss&quot;, &quot;+1:01&quot;, 3660},
1449             {&quot;+H:mm:ss&quot;, &quot;+1:01:01&quot;, 3661},
1450         };
1451     }
1452 
1453     @Test(dataProvider=&quot;lenientOffsetParseData&quot;)
1454     public void test_lenient_offset_parse_1(String pattern, String offset, int offsetSeconds) {
1455         assertEquals(new DateTimeFormatterBuilder().parseLenient().appendOffset(pattern, &quot;Z&quot;).toFormatter().parse(offset).get(OFFSET_SECONDS),
1456                      offsetSeconds);
1457     }
1458 
1459     @Test
1460     public void test_lenient_offset_parse_2() {
1461         assertEquals(new DateTimeFormatterBuilder().parseLenient().appendOffsetId().toFormatter().parse(&quot;+01&quot;).get(OFFSET_SECONDS),
1462                      3600);
1463     }
1464 
1465     @Test(dataProvider=&quot;strictDoubleDigitHourOffsetParseData&quot;)
1466     public void test_strictDoubleDigitHour_offset_parse_1(String pattern, String offset, int offsetSeconds) {
1467         assertEquals(new DateTimeFormatterBuilder().appendOffset(pattern, &quot;Z&quot;).toFormatter()
1468                 .parse(offset).get(OFFSET_SECONDS), offsetSeconds);
1469     }
1470 
1471     @Test(dataProvider=&quot;strictDoubleDigitHourOffsetParseData&quot;)
1472     public void test_strictDoubleDigitHour_offset_parse_2(String pattern, String offset, int offsetSeconds) {
1473         assertEquals(new DateTimeFormatterBuilder().appendOffset(pattern, &quot;Z&quot;)
1474                 .appendLiteral(&quot;text&quot;).toFormatter().parse(offset + &quot;text&quot;).get(OFFSET_SECONDS), offsetSeconds);
1475     }
1476 
1477     @Test(dataProvider=&quot;strictSingleDigitHourOffsetParseData&quot;)
1478     public void test_strictSingleDigitHour_offset_parse_1(String pattern, String offset, int offsetSeconds) {
1479         assertEquals(new DateTimeFormatterBuilder().appendOffset(pattern, &quot;Z&quot;).toFormatter()
1480                 .parse(offset).get(OFFSET_SECONDS), offsetSeconds);
1481     }
1482 
1483     @Test(dataProvider=&quot;strictSingleDigitHourOffsetParseData&quot;)
1484     public void test_strictSingleDigitHour_offset_parse_2(String pattern, String offset, int offsetSeconds) {
1485         assertEquals(new DateTimeFormatterBuilder().appendOffset(pattern, &quot;Z&quot;)
1486                 .appendLiteral(&quot;text&quot;).toFormatter().parse(offset + &quot;text&quot;).get(OFFSET_SECONDS), offsetSeconds);
1487     }
1488 
1489     @DataProvider(name=&quot;strictOffsetAdjacentParseValidPatternData&quot;)
1490     Object[][] data_strict_offset_adjacentParse_validPattern() {
1491         return new Object[][] {
1492             {&quot;+HH&quot;, &quot;+01&quot;, 3600},
1493             {&quot;+HHmm&quot;, &quot;+0101&quot;, 3660},
1494             {&quot;+HH:mm&quot;, &quot;+01&quot;, 3600},
1495             {&quot;+HH:mm&quot;, &quot;+01:01&quot;, 3660},
1496             {&quot;+HHMM&quot;, &quot;+0101&quot;, 3660},
1497             {&quot;+HH:MM&quot;, &quot;+01:01&quot;, 3660},
1498             {&quot;+HHMMss&quot;, &quot;+010101&quot;, 3661},
1499             {&quot;+HH:MM:ss&quot;, &quot;+01:01&quot;, 3660},
1500             {&quot;+HH:MM:ss&quot;, &quot;+01:01:01&quot;, 3661},
1501             {&quot;+HHMMSS&quot;, &quot;+010101&quot;, 3661},
1502             {&quot;+HH:MM:SS&quot;, &quot;+01:01:01&quot;, 3661},
1503             {&quot;+HHmmss&quot;, &quot;+010101&quot;, 3661},
1504             {&quot;+HH:mm:ss&quot;, &quot;+01&quot;, 3600},
1505             {&quot;+HH:mm:ss&quot;, &quot;+01:01&quot;, 3660},
1506             {&quot;+HH:mm:ss&quot;, &quot;+01:01:01&quot;, 3661},
1507 
1508             {&quot;+H&quot;, &quot;+01&quot;, 3600},
1509             {&quot;+Hmm&quot;, &quot;+0101&quot;, 3660},
1510             {&quot;+H:mm&quot;, &quot;+01&quot;, 3600},
1511             {&quot;+H:mm&quot;, &quot;+01:01&quot;, 3660},
1512             {&quot;+H:mm&quot;, &quot;+1:01&quot;, 3660},
1513             {&quot;+HMM&quot;, &quot;+0101&quot;, 3660},
1514             {&quot;+H:MM&quot;, &quot;+01:01&quot;, 3660},
1515             {&quot;+H:MM&quot;, &quot;+1:01&quot;, 3660},
1516             {&quot;+HMMss&quot;, &quot;+010101&quot;, 3661},
1517             {&quot;+H:MM:ss&quot;, &quot;+01:01&quot;, 3660},
1518             {&quot;+H:MM:ss&quot;, &quot;+01:01:01&quot;, 3661},
1519             {&quot;+H:MM:ss&quot;, &quot;+1:01&quot;, 3660},
1520             {&quot;+H:MM:ss&quot;, &quot;+1:01:01&quot;, 3661},
1521             {&quot;+HMMSS&quot;, &quot;+010101&quot;, 3661},
1522             {&quot;+H:MM:SS&quot;, &quot;+01:01:01&quot;, 3661},
1523             {&quot;+H:MM:SS&quot;, &quot;+1:01:01&quot;, 3661},
1524             {&quot;+Hmmss&quot;, &quot;+010101&quot;, 3661},
1525             {&quot;+H:mm:ss&quot;, &quot;+01&quot;, 3600},
1526             {&quot;+H:mm:ss&quot;, &quot;+01:01&quot;, 3660},
1527             {&quot;+H:mm:ss&quot;, &quot;+01:01:01&quot;, 3661},
1528             {&quot;+H:mm:ss&quot;, &quot;+1:01&quot;, 3660},
1529             {&quot;+H:mm:ss&quot;, &quot;+1:01:01&quot;, 3661},
1530         };
1531     }
1532 
1533     @Test(dataProvider=&quot;strictOffsetAdjacentParseValidPatternData&quot;)
1534     public void test_strict_offset_adjacentValidPattern_parse(String pattern, String offset, int offsetSeconds) {
1535         TemporalAccessor tmp = new DateTimeFormatterBuilder().appendOffset(pattern, &quot;Z&quot;)
1536                 .appendValue(HOUR_OF_DAY, 2).toFormatter().parse(offset + &quot;12&quot;);
1537         assertEquals(tmp.get(OFFSET_SECONDS), offsetSeconds);
1538         assertEquals(tmp.get(HOUR_OF_DAY), 12);
1539     }
1540 
1541     @DataProvider(name=&quot;strictOffsetAdjacentParseInvalidPatternData&quot;)
1542     Object[][] data_strict_offset_adjacentParse_invalidPattern() {
1543         return new Object[][] {
1544             {&quot;+HHmm&quot;, &quot;+01&quot;, 3600},
1545             {&quot;+HHMMss&quot;, &quot;+0101&quot;, 3660},
1546             {&quot;+HHmmss&quot;, &quot;+01&quot;, 3600},
1547             {&quot;+HHmmss&quot;, &quot;+0101&quot;, 3660},
1548             {&quot;+H&quot;, &quot;+1&quot;, 3600},
1549             {&quot;+Hmm&quot;, &quot;+01&quot;, 3600},
1550             {&quot;+H:mm&quot;, &quot;+1&quot;, 3600},
1551             {&quot;+Hmm&quot;, &quot;+1&quot;, 3600},
1552             {&quot;+Hmm&quot;, &quot;+101&quot;, 3660},
1553             {&quot;+HMM&quot;, &quot;+101&quot;, 3660},
1554             {&quot;+HMMss&quot;, &quot;+0101&quot;, 3660},
1555             {&quot;+HMMss&quot;, &quot;+101&quot;, 3660},
1556             {&quot;+HMMss&quot;, &quot;+10101&quot;, 3661},
1557             {&quot;+HMMSS&quot;, &quot;+10101&quot;, 3661},
1558             {&quot;+Hmmss&quot;, &quot;+01&quot;, 3600},
1559             {&quot;+Hmmss&quot;, &quot;+0101&quot;, 3660},
1560             {&quot;+Hmmss&quot;, &quot;+1&quot;, 3600},
1561             {&quot;+Hmmss&quot;, &quot;+101&quot;, 3660},
1562             {&quot;+Hmmss&quot;, &quot;+10101&quot;, 3661},
1563             {&quot;+H:mm:ss&quot;, &quot;+1&quot;, 3600},
1564         };
1565     }
1566 
1567     @Test(dataProvider=&quot;strictOffsetAdjacentParseInvalidPatternData&quot;, expectedExceptions=DateTimeParseException.class)
1568     public void test_strict_offset_adjacentInvalidPattern_parse(String pattern, String offset, int offsetSeconds) {
1569        new DateTimeFormatterBuilder().appendOffset(pattern, &quot;Z&quot;).appendValue(HOUR_OF_DAY, 2)
1570                .toFormatter().parse(offset + &quot;12&quot;);
1571     }
1572 
1573     @DataProvider(name=&quot;lenientOffsetAdjacentParseValidPatternData&quot;)
1574     Object[][] data_lenient_offset_adjacentParse_validPattern() {
1575         return new Object[][] {
1576             {&quot;+HH:mm&quot;, &quot;+01&quot;, 3600},
1577             {&quot;+HH:mm&quot;, &quot;+01:01&quot;, 3660},
1578             {&quot;+HH:MM&quot;, &quot;+01:01&quot;, 3660},
1579             {&quot;+HH:MM:ss&quot;, &quot;+01:01&quot;, 3660},
1580             {&quot;+HH:MM:ss&quot;, &quot;+01:01:01&quot;, 3661},
1581             {&quot;+HHMMSS&quot;, &quot;+010101&quot;, 3661},
1582             {&quot;+HH:MM:SS&quot;, &quot;+01:01:01&quot;, 3661},
1583             {&quot;+HHmmss&quot;, &quot;+010101&quot;, 3661},
1584             {&quot;+HH:mm:ss&quot;, &quot;+01&quot;, 3600},
1585             {&quot;+HH:mm:ss&quot;, &quot;+01:01&quot;, 3660},
1586             {&quot;+HH:mm:ss&quot;, &quot;+01:01:01&quot;, 3661},
1587             {&quot;+H:mm&quot;, &quot;+01&quot;, 3600},
1588             {&quot;+H:mm&quot;, &quot;+01:01&quot;, 3660},
1589             {&quot;+H:mm&quot;, &quot;+1:01&quot;, 3660},
1590             {&quot;+H:MM&quot;, &quot;+01:01&quot;, 3660},
1591             {&quot;+H:MM&quot;, &quot;+1:01&quot;, 3660},
1592             {&quot;+HMMss&quot;, &quot;+010101&quot;, 3661},
1593             {&quot;+H:MM:ss&quot;, &quot;+01:01&quot;, 3660},
1594             {&quot;+H:MM:ss&quot;, &quot;+01:01:01&quot;, 3661},
1595             {&quot;+H:MM:ss&quot;, &quot;+1:01&quot;, 3660},
1596             {&quot;+H:MM:ss&quot;, &quot;+1:01:01&quot;, 3661},
1597             {&quot;+HMMSS&quot;, &quot;+010101&quot;, 3661},
1598             {&quot;+H:MM:SS&quot;, &quot;+01:01:01&quot;, 3661},
1599             {&quot;+H:MM:SS&quot;, &quot;+1:01:01&quot;, 3661},
1600             {&quot;+Hmmss&quot;, &quot;+010101&quot;, 3661},
1601             {&quot;+H:mm:ss&quot;, &quot;+01&quot;, 3600},
1602             {&quot;+H:mm:ss&quot;, &quot;+01:01&quot;, 3660},
1603             {&quot;+H:mm:ss&quot;, &quot;+01:01:01&quot;, 3661},
1604             {&quot;+H:mm:ss&quot;, &quot;+1:01&quot;, 3660},
1605             {&quot;+H:mm:ss&quot;, &quot;+1:01:01&quot;, 3661},
1606         };
1607     }
1608 
1609     @Test(dataProvider=&quot;lenientOffsetAdjacentParseValidPatternData&quot;)
1610     public void test_lenient_offset_adjacentValidPattern_parse(String pattern, String offset, int offsetSeconds) {
1611         TemporalAccessor tmp = new DateTimeFormatterBuilder().parseLenient()
1612                 .appendOffset(pattern, &quot;Z&quot;).appendValue(HOUR_OF_DAY, 2).toFormatter().parse(offset + &quot;12&quot;);
1613         assertEquals(tmp.get(OFFSET_SECONDS), offsetSeconds);
1614         assertEquals(tmp.get(HOUR_OF_DAY), 12);
1615     }
1616 
1617     @Test
1618     public void test_lenient_offset_adjacentValidPattern_parse1() {
1619         TemporalAccessor tmp = new DateTimeFormatterBuilder().parseLenient()
1620                 .appendOffset(&quot;+HMMSS&quot;, &quot;Z&quot;).appendValue(HOUR_OF_DAY, 2).toFormatter().parse(&quot;+10101&quot; + &quot;12&quot;);
1621         //Equivalent to +101011. In lenient mode, offset will parse upto 6 digit if possible.
1622         //It will take 1 digit from HOUR_OF_DAY.
1623         assertEquals(tmp.get(OFFSET_SECONDS), 36611);
1624         assertEquals(tmp.get(HOUR_OF_DAY), 2);
1625     }
1626 
1627   @DataProvider(name=&quot;lenientOffsetAdjacentParseInvalidPatternData&quot;)
1628     Object[][] data_lenient_offset_adjacentParse_invalidPattern() {
1629         return new Object[][] {
1630             {&quot;+HH&quot;, &quot;+01&quot;, 3600},
1631             {&quot;+HHmm&quot;, &quot;+0101&quot;, 3660},
1632             {&quot;+HHMM&quot;, &quot;+0101&quot;, 3660},
1633             {&quot;+H&quot;, &quot;+01&quot;, 3600},
1634             {&quot;+Hmm&quot;, &quot;+0101&quot;, 3660},
1635             {&quot;+HMM&quot;, &quot;+0101&quot;, 3660},
1636         };
1637     }
1638 
1639     @Test(dataProvider=&quot;lenientOffsetAdjacentParseInvalidPatternData&quot;, expectedExceptions=DateTimeParseException.class)
1640     public void test_lenient_offset_adjacentInvalidPattern_parse(String pattern, String offset, int offsetSeconds) {
1641        new DateTimeFormatterBuilder().parseLenient().appendOffset(pattern, &quot;Z&quot;)
1642                .appendValue(HOUR_OF_DAY, 2).toFormatter().parse(offset + &quot;12&quot;);
1643     }
1644 
1645     @DataProvider(name=&quot;badValues&quot;)
1646     Object[][] data_badOffsetValues() {
1647         return new Object[][] {
1648             {&quot;+HH&quot;, &quot;+24&quot;},
1649             {&quot;+HHMM&quot;, &quot;-1361&quot;},
1650             {&quot;+HH:MM:ss&quot;, &quot;+13:12:66&quot;},
1651             {&quot;+HH:MM:SS&quot;, &quot;+24:60:60&quot;},
1652             {&quot;+HHMMSS&quot;, &quot;369999&quot;},
1653             {&quot;+H:MM&quot;, &quot;+28:12&quot;},
1654         };
1655     }
1656 
1657     @Test(dataProvider=&quot;badValues&quot;, expectedExceptions=DateTimeParseException.class)
1658     public void test_badOffset_parse(String pattern, String offset) {
1659         new DateTimeFormatterBuilder().appendOffset(pattern, &quot;Z&quot;).toFormatter().parse(offset);
1660     }
1661 
1662     @Test(expectedExceptions=DateTimeParseException.class)
1663     public void test_strict_appendOffsetId() {
1664         new DateTimeFormatterBuilder().appendOffsetId().toFormatter().parse(&quot;+01&quot;);
1665     }
1666 
1667     @Test(expectedExceptions=DateTimeParseException.class)
1668     public void test_strict_appendOffset_1() {
1669         new DateTimeFormatterBuilder().appendOffset(&quot;+HH:MM:ss&quot;, &quot;Z&quot;).toFormatter().parse(&quot;+01&quot;);
1670     }
1671 
1672     @Test(expectedExceptions=DateTimeParseException.class)
1673     public void test_strict_appendOffset_2() {
1674         new DateTimeFormatterBuilder().appendOffset(&quot;+HHMMss&quot;, &quot;Z&quot;).toFormatter().parse(&quot;+01&quot;);
1675     }
1676 
1677     @Test(expectedExceptions=DateTimeParseException.class)
1678     public void test_strict_appendOffset_3() {
1679         new DateTimeFormatterBuilder().appendOffset(&quot;+H:MM:ss&quot;, &quot;Z&quot;).toFormatter().parse(&quot;+1&quot;);
1680     }
1681 
1682     @Test(expectedExceptions=DateTimeParseException.class)
1683     public void test_strict_appendOffset_4() {
1684         new DateTimeFormatterBuilder().appendOffset(&quot;+HMMss&quot;, &quot;Z&quot;).toFormatter().parse(&quot;+1&quot;);
1685     }
1686 
1687     @Test
1688     public void test_basic_iso_date() {
1689         assertEquals(BASIC_ISO_DATE.parse(&quot;20021231+01&quot;).get(OFFSET_SECONDS), 3600);
1690         assertEquals(BASIC_ISO_DATE.parse(&quot;20021231+0101&quot;).get(OFFSET_SECONDS), 3660);
1691     }
1692 
1693 }
    </pre>
  </body>
</html>
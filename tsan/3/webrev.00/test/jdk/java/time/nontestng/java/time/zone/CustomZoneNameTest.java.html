<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New test/jdk/java/time/nontestng/java/time/zone/CustomZoneNameTest.java</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
 1 /*
 2  * Copyright (c) 2019, Oracle and/or its affiliates. All rights reserved.
 3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 4  *
 5  * This code is free software; you can redistribute it and/or modify it
 6  * under the terms of the GNU General Public License version 2 only, as
 7  * published by the Free Software Foundation.
 8  *
 9  * This code is distributed in the hope that it will be useful, but WITHOUT
10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
12  * version 2 for more details (a copy is included in the LICENSE file that
13  * accompanied this code).
14  *
15  * You should have received a copy of the GNU General Public License version
16  * 2 along with this work; if not, write to the Free Software Foundation,
17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
18  *
19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
20  * or visit www.oracle.com if you need additional information or have any
21  * questions.
22  */
23 
24 import java.time.Instant;
25 import java.time.ZoneId;
26 import java.time.ZonedDateTime;
27 import java.time.format.DateTimeFormatter;
28 import java.util.Map;
29 
30 /* @test
31  * @bug 8235238
32  * @summary Checks whether custom zone names can be formatted/parsed correctly.
33  * @library zoneProvider
34  * @build custom.CustomZoneRulesProvider custom.CustomTimeZoneNameProvider
35  * @run main/othervm -Djava.locale.providers=SPI,CLDR CustomZoneNameTest
36  */
37 public class CustomZoneNameTest {
38 
39     private final static long now = 1575669972372L;
40     private final static Instant instant = Instant.ofEpochMilli(now);
41     private final static ZoneId customZone = ZoneId.of(&quot;Custom/Timezone&quot;);
42 
43     // test data
44     private final static Map&lt;String, String&gt;  formats = Map.of(
45         &quot;yyyy-MM-dd HH:mm:ss.SSS VV&quot;, &quot;2019-12-06 22:06:12.372 Custom/Timezone&quot;,
46         &quot;yyyy-MM-dd HH:mm:ss.SSS z&quot;, &quot;2019-12-06 22:06:12.372 CUST_WT&quot;,
47         &quot;yyyy-MM-dd HH:mm:ss.SSS zzzz&quot;, &quot;2019-12-06 22:06:12.372 Custom Winter Time&quot;,
48         &quot;yyyy-MM-dd HH:mm:ss.SSS v&quot;, &quot;2019-12-06 22:06:12.372 Custom Time&quot;,
49         &quot;yyyy-MM-dd HH:mm:ss.SSS vvvv&quot;, &quot;2019-12-06 22:06:12.372 Custom Timezone Time&quot;
50     );
51 
52     public static void main(String... args) {
53         testFormatting();
54         testParsing();
55     }
56 
57     private static void testFormatting() {
58         var customZDT = ZonedDateTime.ofInstant(instant, customZone);
59         formats.entrySet().stream()
60             .filter(e -&gt; {
61                 var formatted = DateTimeFormatter.ofPattern(e.getKey()).format(customZDT);
62                 var expected = e.getValue();
63                 System.out.println(&quot;testFormatting. Pattern: &quot; + e.getKey() +
64                         &quot;, expected: &quot; + expected +
65                         &quot;, formatted: &quot; + formatted);
66                 return !formatted.equals(expected);
67             })
68             .findAny()
69             .ifPresent(e -&gt; {
70                 throw new RuntimeException(
71                         &quot;Provider&#39;s custom name was not retrieved for the format &quot; +
72                         e.getKey());
73             });
74     }
75 
76     public static void testParsing() {
77         formats.entrySet().stream()
78             .filter(e -&gt; {
79                 var fmt = DateTimeFormatter.ofPattern(e.getKey());
80                 var input = e.getValue();
81                 var parsedInstant = fmt.parse(input, Instant::from).toEpochMilli();
82                 var parsedZone = fmt.parse(input, ZonedDateTime::from).getZone();
83                 System.out.println(&quot;testParsing. Input: &quot; + input +
84                         &quot;, expected instant: &quot; + now +
85                         &quot;, expected zone: &quot; + customZone +
86                         &quot;, parsed instant: &quot; + parsedInstant +
87                         &quot;, parsed zone: &quot; + parsedZone);
88                 return parsedInstant != now ||
89                         !parsedZone.equals(customZone);
90             })
91             .findAny()
92             .ifPresent(e -&gt; {
93                 throw new RuntimeException(&quot;Parsing failed for the format &quot; +
94                                 e.getKey());
95             });
96     }
97 }
    </pre>
  </body>
</html>
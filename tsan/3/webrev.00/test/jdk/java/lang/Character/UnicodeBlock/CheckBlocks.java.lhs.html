<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames test/jdk/java/lang/Character/UnicodeBlock/CheckBlocks.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
<a name="1" id="anc1"></a><span class="line-modified">  2  * Copyright (c) 2007, 2018, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 /*
 27  * @test
 28  * @bug 4830803 4886934 6565620 6959267 7070436 7198195 8032446 8072600 8202771
<a name="2" id="anc2"></a><span class="line-modified"> 29  * @summary  Check that the UnicodeBlock forName() method works as expected and block ranges are correct for all Unicode characters.</span>



 30  * @run main CheckBlocks
 31  * @author John O&#39;Conner
 32  */
 33 
 34 import java.lang.Character.UnicodeBlock;
 35 import java.lang.reflect.Field;
 36 import java.io.BufferedReader;
 37 import java.io.File;
 38 import java.io.FileReader;
 39 import java.util.HashSet;
 40 import java.util.Locale;
 41 
 42 public class CheckBlocks {
 43 
 44     static boolean err = false;
 45     static Class&lt;?&gt; clazzUnicodeBlock;
 46 
 47     public static void main(String[] args) throws Exception {
 48         generateBlockList();
 49 
 50         try {
 51             clazzUnicodeBlock = Class.forName(&quot;java.lang.Character$UnicodeBlock&quot;);
 52         } catch (ClassNotFoundException e) {
 53             throw new RuntimeException(&quot;Class.forName(\&quot;java.lang.Character$UnicodeBlock\&quot;) failed.&quot;);
 54         }
 55 
 56         for (Block blk : blocks) {
 57             test4830803_1(blk);
 58             test4830803_2();
 59             test4886934(blk);
 60         }
 61 
 62         test8202771();
 63 
 64         if (err) {
 65             throw new RuntimeException(&quot;Failed&quot;);
 66         } else {
 67             System.out.println(&quot;Passed&quot;);
 68         }
 69     }
 70 
 71     /**
 72      * Check that the UnicodeBlock forName() method works as expected.
 73      */
 74     private static void test4830803_1(Block blk) throws Exception {
 75 
 76         /*
 77          * Try 3 forms of block name in the forName() method. Each form should
 78          * produce the same expected block.
 79          */
 80         String blkName = blk.getName();
 81 
 82         // For backward compatibility
 83         switch (blkName) {
 84             case &quot;COMBINING_DIACRITICAL_MARKS_FOR_SYMBOLS&quot;:
 85                 blkName = &quot;COMBINING_MARKS_FOR_SYMBOLS&quot;;
 86                 System.out.println(&quot;*** COMBINING_DIACRITICAL_MARKS_FOR_SYMBOLS&quot;
 87                         + &quot; is replaced with COMBINING_MARKS_FOR_SYMBOLS&quot;
 88                         + &quot; for backward compatibility.&quot;);
 89                 break;
 90             case &quot;GREEK_AND_COPTIC&quot;:
 91                 blkName = &quot;GREEK&quot;;
 92                 System.out.println(&quot;*** GREEK_AND_COPTIC is replaced with GREEK&quot;
 93                         + &quot; for backward compatibility.&quot;);
 94                 break;
 95             case &quot;CYRILLIC_SUPPLEMENT&quot;:
 96                 blkName = &quot;CYRILLIC_SUPPLEMENTARY&quot;;
 97                 System.out.println(&quot;*** CYRILLIC_SUPPLEMENT is replaced with&quot;
 98                         + &quot; CYRILLIC_SUPPLEMENTARY for backward compatibility.&quot;);
 99                 break;
100             default:
101                 break;
102         }
103 
104         String expectedBlock = null;
105         try {
106             expectedBlock = clazzUnicodeBlock.getField(blkName).getName();
107         } catch (NoSuchFieldException | SecurityException e) {
108             System.err.println(&quot;Error: &quot; + blkName + &quot; was not found.&quot;);
109             err = true;
110             return;
111         }
112 
113         String canonicalBlockName = blk.getOriginalName();
114         String idBlockName = expectedBlock;
115         String regexBlockName = toRegExString(canonicalBlockName);
116 
117         if (regexBlockName == null) {
118             System.err.println(&quot;Error: Block name which was processed with regex was null.&quot;);
119             err = true;
120             return;
121         }
122 
123         if (!expectedBlock.equals(UnicodeBlock.forName(canonicalBlockName).toString())) {
124             System.err.println(&quot;Error #1: UnicodeBlock.forName(\&quot;&quot; +
125                     canonicalBlockName + &quot;\&quot;) returned wrong value.\n\tGot: &quot; +
126                     UnicodeBlock.forName(canonicalBlockName) +
127                     &quot;\n\tExpected: &quot; + expectedBlock);
128             err = true;
129         }
130 
131         if (!expectedBlock.equals(UnicodeBlock.forName(idBlockName).toString())) {
132             System.err.println(&quot;Error #2: UnicodeBlock.forName(\&quot;&quot; +
133                     idBlockName + &quot;\&quot;) returned wrong value.\n\tGot: &quot; +
134                     UnicodeBlock.forName(idBlockName) +
135                     &quot;\n\tExpected: &quot; + expectedBlock);
136             err = true;
137         }
138 
139         if (!expectedBlock.equals(UnicodeBlock.forName(regexBlockName).toString())) {
140             System.err.println(&quot;Error #3: UnicodeBlock.forName(\&quot;&quot; +
141                     regexBlockName + &quot;\&quot;) returned wrong value.\n\tGot: &quot; +
142                     UnicodeBlock.forName(regexBlockName) +
143                     &quot;\n\tExpected: &quot; + expectedBlock);
144             err = true;
145         }
146     }
147 
148     /**
149      * now try a bad block name. This should produce an IAE.
150      */
151     private static void test4830803_2() {
152         boolean threwExpected = false;
153 
154         try {
155             UnicodeBlock block = UnicodeBlock.forName(&quot;notdefined&quot;);
156         }
157         catch(IllegalArgumentException e) {
158             threwExpected = true;
159         }
160 
161         if (threwExpected == false) {
162             System.err.println(&quot;Error: UnicodeBlock.forName(\&quot;notdefined\&quot;) should throw IllegalArgumentException.&quot;);
163             err = true;
164         }
165     }
166 
167     /**
168      * Convert the argument to a block name form used by the regex package.
169      * That is, remove all spaces.
170      */
171     private static String toRegExString(String str) {
172         String[] tokens = null;
173         StringBuilder retStr = new StringBuilder();
174         try {
175             tokens = str.split(&quot; &quot;);
176         }
177         catch(java.util.regex.PatternSyntaxException e) {
178             return null;
179         }
180         for(int x=0; x &lt; tokens.length; ++x) {
181             retStr.append(tokens[x]);
182         }
183         return retStr.toString();
184     }
185 
186     private static void test4886934(Block blk) {
187         String blkName = blk.getName();
188         String blkOrigName = blk.getOriginalName();
189         UnicodeBlock block;
190         String blockName;
191 
192         // For backward compatibility
193         switch (blkName) {
194             case &quot;COMBINING_DIACRITICAL_MARKS_FOR_SYMBOLS&quot;:
195                 blkName = &quot;COMBINING_MARKS_FOR_SYMBOLS&quot;;
196                 System.out.println(&quot;*** COMBINING_DIACRITICAL_MARKS_FOR_SYMBOLS&quot;
197                         + &quot; is replaced with COMBINING_MARKS_FOR_SYMBOLS&quot;
198                         + &quot; for backward compatibility.&quot;);
199                 break;
200             case &quot;GREEK_AND_COPTIC&quot;:
201                 blkName = &quot;GREEK&quot;;
202                 System.out.println(&quot;*** GREEK_AND_COPTIC is replaced with GREEK&quot;
203                         + &quot; for backward compatibility.&quot;);
204                 break;
205             case &quot;CYRILLIC_SUPPLEMENT&quot;:
206                 blkName = &quot;CYRILLIC_SUPPLEMENTARY&quot;;
207                 System.out.println(&quot;*** CYRILLIC_SUPPLEMENT is replaced with&quot;
208                         + &quot; CYRILLIC_SUPPLEMENTARY for backward compatibility.&quot;);
209                 break;
210             default:
211                 break;
212         }
213 
214         for (int ch = blk.getBegin(); ch &lt;= blk.getEnd(); ch++) {
215             block = UnicodeBlock.of(ch);
216             if (block == null) {
217                 System.err.println(&quot;Error: The block for &quot; + blkName
218                         + &quot; is missing. Please check java.lang.Character.UnicodeBlock.&quot;);
219                 err = true;
220                 break;
221             }
222             blockName = block.toString();
223             if (!blockName.equals(blkName)) {
224                 System.err.println(&quot;Error: Character(0x&quot;
225                         + Integer.toHexString(ch).toUpperCase()
226                         + &quot;) should be in \&quot;&quot; + blkName + &quot;\&quot; block &quot;
227                         + &quot;(Block name is \&quot;&quot; + blkOrigName + &quot;\&quot;)&quot;
228                         + &quot; but found in \&quot;&quot; + blockName + &quot;\&quot; block.&quot;);
229                 err = true;
230             }
231         }
232     }
233 
234     /**
235      * Check if every Field of Character.UnicodeBlock is a valid Unicode Block.
236      */
237     private static void test8202771() {
238         Field[] fields = clazzUnicodeBlock.getFields();
239 
240         for (Field f : fields) {
241             // Handle Deprecated field &quot;SURROGATES_AREA&quot;.
242             if (f.getAnnotation(Deprecated.class) != null) {
243                 continue;
244             }
245 
246             String blkName = f.getName();
247             switch (blkName) {
248                 case &quot;COMBINING_MARKS_FOR_SYMBOLS&quot;:
249                     validateBlock(&quot;COMBINING_DIACRITICAL_MARKS_FOR_SYMBOLS&quot;);
250                     break;
251                 case &quot;GREEK&quot;:
252                     validateBlock(&quot;GREEK_AND_COPTIC&quot;);
253                     break;
254                 case &quot;CYRILLIC_SUPPLEMENTARY&quot;:
255                     validateBlock(&quot;CYRILLIC_SUPPLEMENT&quot;);
256                     break;
257                 default:
258                     validateBlock(blkName);
259                     break;
260             }
261         }
262     }
263 
264     private static void validateBlock(String blkName) {
265         for (Block block : blocks) {
266             String blockName = block.getName();
267             if (blockName.equals(blkName)) {
268                 return;
269             }
270         }
271         err = true;
272         System.err.println(blkName + &quot; is not a valid Unicode Block.&quot;);
273     }
274 
275     // List of all Unicode blocks, their start, and end codepoints.
276     public static HashSet&lt;Block&gt; blocks = new HashSet&lt;&gt;();
277 
278     private static void generateBlockList() throws Exception {
<a name="3" id="anc3"></a><span class="line-modified">279         File blockData = new File(System.getProperty(&quot;test.src&quot;, &quot;.&quot;),</span>
<span class="line-removed">280                 &quot;Blocks.txt&quot;);</span>
281         try (BufferedReader f = new BufferedReader(new FileReader(blockData))) {
282             String line;
283             while ((line = f.readLine()) != null) {
284                 if (line.length() == 0 || line.charAt(0) == &#39;#&#39;) {
285                     continue;
286                 }
287 
288                 int index1 = line.indexOf(&#39;.&#39;);
289                 int begin = Integer.parseInt(line.substring(0, index1), 16);
290                 int index2 = line.indexOf(&#39;;&#39;);
291                 int end = Integer.parseInt(line.substring(index1 + 2, index2), 16);
292                 String name = line.substring(index2 + 1).trim();
293 
294                 System.out.println(&quot;  Adding a Block(&quot; + Integer.toHexString(begin) + &quot;, &quot; + Integer.toHexString(end)
295                         + &quot;, &quot; + name + &quot;)&quot;);
296                 blocks.add(new Block(begin, end, name));
297             }
298         }
299     }
300 }
301 
302 class Block {
303 
304     public Block() {
305         blockBegin = 0;
306         blockEnd = 0;
307         blockName = null;
308     }
309 
310     public Block(int begin, int end, String name) {
311         blockBegin = begin;
312         blockEnd = end;
313         blockName = name.replaceAll(&quot;[ -]&quot;, &quot;_&quot;).toUpperCase(Locale.ENGLISH);
314         originalBlockName = name;
315     }
316 
317     public int getBegin() {
318         return blockBegin;
319     }
320 
321     public int getEnd() {
322         return blockEnd;
323     }
324 
325     public String getName() {
326         return blockName;
327     }
328 
329     public String getOriginalName() {
330         return originalBlockName;
331     }
332 
333     @Override
334     public boolean equals(Object obj) {
335         if (obj == null) return false;
336         if (!(obj instanceof Block)) return false;
337 
338         Block other = (Block)obj;
339         return other.blockBegin == blockBegin &amp;&amp;
340                 other.blockEnd == blockEnd &amp;&amp;
341                 other.blockName.equals(blockName) &amp;&amp;
342                 other.originalBlockName.equals(originalBlockName);
343     }
344     int blockBegin, blockEnd;
345     String blockName, originalBlockName;
346 }
<a name="4" id="anc4"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="4" type="hidden" />
</body>
</html>
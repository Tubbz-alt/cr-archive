<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames test/jdk/java/lang/Math/DivModTests.java</title>
    <link rel="stylesheet" href="../../../../../style.css" />
    <script type="text/javascript" src="../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (c) 2012, 2016, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 import java.math.BigDecimal;
 25 import java.math.RoundingMode;
 26 
 27 /**
 28  * @test Test Math and StrictMath Floor Div / Modulo operations.
 29  * @bug 6282196
 30  * @summary Basic tests for Floor division and modulo methods for both Math
 31  * and StrictMath for int and long datatypes.
 32  */
 33 public class DivModTests {
 34 
 35     /**
 36      * The count of test errors.
 37      */
 38     private static int errors = 0;
 39 
 40     /**
 41      * @param args the command line arguments are unused
 42      */
 43     public static void main(String[] args) {
 44         errors = 0;
 45         testIntFloorDivMod();
 46         testLongFloorDivMod();
 47 
 48         if (errors &gt; 0) {
 49             throw new RuntimeException(errors + &quot; errors found in DivMod methods.&quot;);
 50         }
 51     }
 52 
 53     /**
 54      * Report a test failure and increment the error count.
 55      * @param message the formatting string
 56      * @param args the variable number of arguments for the message.
 57      */
 58     static void fail(String message, Object... args) {
 59         errors++;
 60         System.out.printf(message, args);
 61     }
 62 
 63     /**
 64      * Test the integer floorDiv and floorMod methods.
 65      * Math and StrictMath tested and the same results are expected for both.
 66      */
 67     static void testIntFloorDivMod() {
 68         testIntFloorDivMod(4, 0, new ArithmeticException(), new ArithmeticException()); // Should throw ArithmeticException
 69         testIntFloorDivMod(4, 3, 1, 1);
 70         testIntFloorDivMod(3, 3, 1, 0);
 71         testIntFloorDivMod(2, 3, 0, 2);
 72         testIntFloorDivMod(1, 3, 0, 1);
 73         testIntFloorDivMod(0, 3, 0, 0);
 74         testIntFloorDivMod(4, -3, -2, -2);
 75         testIntFloorDivMod(3, -3, -1, 0);
 76         testIntFloorDivMod(2, -3, -1, -1);
 77         testIntFloorDivMod(1, -3, -1, -2);
 78         testIntFloorDivMod(0, -3, 0, 0);
 79         testIntFloorDivMod(-1, 3, -1, 2);
 80         testIntFloorDivMod(-2, 3, -1, 1);
 81         testIntFloorDivMod(-3, 3, -1, 0);
 82         testIntFloorDivMod(-4, 3, -2, 2);
 83         testIntFloorDivMod(-1, -3, 0, -1);
 84         testIntFloorDivMod(-2, -3, 0, -2);
 85         testIntFloorDivMod(-3, -3, 1, 0);
 86         testIntFloorDivMod(-4, -3, 1, -1);
 87         testIntFloorDivMod(Integer.MAX_VALUE, 1, Integer.MAX_VALUE, 0);
 88         testIntFloorDivMod(Integer.MAX_VALUE, -1, -Integer.MAX_VALUE, 0);
 89         testIntFloorDivMod(Integer.MAX_VALUE, 3, 715827882, 1);
 90         testIntFloorDivMod(Integer.MAX_VALUE - 1, 3, 715827882, 0);
 91         testIntFloorDivMod(Integer.MIN_VALUE, 3, -715827883, 1);
 92         testIntFloorDivMod(Integer.MIN_VALUE + 1, 3, -715827883, 2);
 93         testIntFloorDivMod(Integer.MIN_VALUE + 1, -1, Integer.MAX_VALUE, 0);
<a name="1" id="anc1"></a><span class="line-added"> 94         testIntFloorDivMod(Integer.MAX_VALUE, Integer.MAX_VALUE, 1, 0);</span>
<span class="line-added"> 95         testIntFloorDivMod(Integer.MAX_VALUE, Integer.MIN_VALUE, -1, -1);</span>
<span class="line-added"> 96         testIntFloorDivMod(Integer.MIN_VALUE, Integer.MIN_VALUE, 1, 0);</span>
<span class="line-added"> 97         testIntFloorDivMod(Integer.MIN_VALUE, Integer.MAX_VALUE, -2, 2147483646);</span>
 98         // Special case of integer overflow
 99         testIntFloorDivMod(Integer.MIN_VALUE, -1, Integer.MIN_VALUE, 0);
100     }
101 
102     /**
103      * Test FloorDiv and then FloorMod with int data.
104      */
105     static void testIntFloorDivMod(int x, int y, Object divExpected, Object modExpected) {
106         testIntFloorDiv(x, y, divExpected);
107         testIntFloorMod(x, y, modExpected);
108     }
109 
110     /**
111      * Test FloorDiv with int data.
112      */
113     static void testIntFloorDiv(int x, int y, Object expected) {
114         Object result = doFloorDiv(x, y);
115         if (!resultEquals(result, expected)) {
116             fail(&quot;FAIL: Math.floorDiv(%d, %d) = %s; expected %s%n&quot;, x, y, result, expected);
117         }
118 
119         Object strict_result = doStrictFloorDiv(x, y);
120         if (!resultEquals(strict_result, expected)) {
121             fail(&quot;FAIL: StrictMath.floorDiv(%d, %d) = %s; expected %s%n&quot;, x, y, strict_result, expected);
122         }
123     }
124 
125     /**
126      * Test FloorMod with int data.
127      */
128     static void testIntFloorMod(int x, int y, Object expected) {
129         Object result = doFloorMod(x, y);
130         if (!resultEquals(result, expected)) {
131             fail(&quot;FAIL: Math.floorMod(%d, %d) = %s; expected %s%n&quot;, x, y, result, expected);
132         }
133 
134         Object strict_result = doStrictFloorMod(x, y);
135         if (!resultEquals(strict_result, expected)) {
136             fail(&quot;FAIL: StrictMath.floorMod(%d, %d) = %s; expected %s%n&quot;, x, y, strict_result, expected);
137         }
138 
139         try {
140             // Verify result against double precision floor function
141             int tmp = x / y;     // Force ArithmeticException for divide by zero
142             double ff = x - Math.floor((double)x / (double)y) * y;
143             int fr = (int)ff;
144             boolean t = (fr == ((Integer)result));
145             if (!result.equals(fr)) {
146                 fail(&quot;FAIL: Math.floorMod(%d, %d) = %s differs from Math.floor(x, y): %d%n&quot;, x, y, result, fr);
147             }
148         } catch (ArithmeticException ae) {
149             if (y != 0) {
150                 fail(&quot;FAIL: Math.floorMod(%d, %d); unexpected %s%n&quot;, x, y, ae);
151             }
152         }
153     }
154 
155     /**
156      * Test the floorDiv and floorMod methods for primitive long.
157      */
158     static void testLongFloorDivMod() {
159         testLongFloorDivMod(4L, 0L, new ArithmeticException(), new ArithmeticException()); // Should throw ArithmeticException
160         testLongFloorDivMod(4L, 3L, 1L, 1L);
161         testLongFloorDivMod(3L, 3L, 1L, 0L);
162         testLongFloorDivMod(2L, 3L, 0L, 2L);
163         testLongFloorDivMod(1L, 3L, 0L, 1L);
164         testLongFloorDivMod(0L, 3L, 0L, 0L);
165         testLongFloorDivMod(4L, -3L, -2L, -2L);
166         testLongFloorDivMod(3L, -3L, -1L, 0l);
167         testLongFloorDivMod(2L, -3L, -1L, -1L);
168         testLongFloorDivMod(1L, -3L, -1L, -2L);
169         testLongFloorDivMod(0L, -3L, 0L, 0L);
170         testLongFloorDivMod(-1L, 3L, -1L, 2L);
171         testLongFloorDivMod(-2L, 3L, -1L, 1L);
172         testLongFloorDivMod(-3L, 3L, -1L, 0L);
173         testLongFloorDivMod(-4L, 3L, -2L, 2L);
174         testLongFloorDivMod(-1L, -3L, 0L, -1L);
175         testLongFloorDivMod(-2L, -3L, 0L, -2L);
176         testLongFloorDivMod(-3L, -3L, 1L, 0L);
177         testLongFloorDivMod(-4L, -3L, 1L, -1L);
178 
179         testLongFloorDivMod(Long.MAX_VALUE, 1, Long.MAX_VALUE, 0L);
180         testLongFloorDivMod(Long.MAX_VALUE, -1, -Long.MAX_VALUE, 0L);
181         testLongFloorDivMod(Long.MAX_VALUE, 3L, Long.MAX_VALUE / 3L, 1L);
182         testLongFloorDivMod(Long.MAX_VALUE - 1L, 3L, (Long.MAX_VALUE - 1L) / 3L, 0L);
183         testLongFloorDivMod(Long.MIN_VALUE, 3L, Long.MIN_VALUE / 3L - 1L, 1L);
184         testLongFloorDivMod(Long.MIN_VALUE + 1L, 3L, Long.MIN_VALUE / 3L - 1L, 2L);
185         testLongFloorDivMod(Long.MIN_VALUE + 1, -1, Long.MAX_VALUE, 0L);
<a name="2" id="anc2"></a><span class="line-added">186         testLongFloorDivMod(Long.MAX_VALUE, Long.MAX_VALUE, 1L, 0L);</span>
<span class="line-added">187         testLongFloorDivMod(Long.MAX_VALUE, Long.MIN_VALUE, -1L, -1L);</span>
<span class="line-added">188         testLongFloorDivMod(Long.MIN_VALUE, Long.MIN_VALUE, 1L, 0L);</span>
<span class="line-added">189         testLongFloorDivMod(Long.MIN_VALUE, Long.MAX_VALUE, -2L, 9223372036854775806L);</span>
190         // Special case of integer overflow
191         testLongFloorDivMod(Long.MIN_VALUE, -1, Long.MIN_VALUE, 0L);
192     }
193 
194     /**
195      * Test the long floorDiv and floorMod methods.
196      * Math and StrictMath are tested and the same results are expected for both.
197      */
198     static void testLongFloorDivMod(long x, long y, Object divExpected, Object modExpected) {
199         testLongFloorDiv(x, y, divExpected);
200         testLongFloorMod(x, y, modExpected);
201     }
202 
203     /**
204      * Test FloorDiv with long arguments against expected value.
205      * The expected value is usually a Long but in some cases  is
206      * an ArithmeticException.
207      *
208      * @param x dividend
209      * @param y modulus
210      * @param expected expected value,
211      */
212     static void testLongFloorDiv(long x, long y, Object expected) {
213         Object result = doFloorDiv(x, y);
214         if (!resultEquals(result, expected)) {
215             fail(&quot;FAIL: long Math.floorDiv(%d, %d) = %s; expected %s%n&quot;, x, y, result, expected);
216         }
217 
218         Object strict_result = doStrictFloorDiv(x, y);
219         if (!resultEquals(strict_result, expected)) {
220             fail(&quot;FAIL: long StrictMath.floorDiv(%d, %d) = %s; expected %s%n&quot;, x, y, strict_result, expected);
221         }
222     }
223 
224     /**
225      * Test FloorMod of long arguments against expected value.
226      * The expected value is usually a Long but in some cases  is
227      * an ArithmeticException.
228      *
229      * @param x dividend
230      * @param y modulus
231      * @param expected expected value
232      */
233     static void testLongFloorMod(long x, long y, Object expected) {
234         Object result = doFloorMod(x, y);
235         if (!resultEquals(result, expected)) {
236             fail(&quot;FAIL: long Math.floorMod(%d, %d) = %s; expected %s%n&quot;, x, y, result, expected);
237         }
238 
239         Object strict_result = doStrictFloorMod(x, y);
240         if (!resultEquals(strict_result, expected)) {
241             fail(&quot;FAIL: long StrictMath.floorMod(%d, %d) = %s; expected %s%n&quot;, x, y, strict_result, expected);
242         }
243 
244         try {
245             // Verify the result against BigDecimal rounding mode.
246             BigDecimal xD = new BigDecimal(x);
247             BigDecimal yD = new BigDecimal(y);
248             BigDecimal resultD = xD.divide(yD, RoundingMode.FLOOR);
249             resultD = resultD.multiply(yD);
250             resultD = xD.subtract(resultD);
251             long fr = resultD.longValue();
252             if (!result.equals(fr)) {
253                 fail(&quot;FAIL: Long.floorMod(%d, %d) = %d is different than BigDecimal result: %d%n&quot;, x, y, result, fr);
254 
255             }
256         } catch (ArithmeticException ae) {
257             if (y != 0) {
258                 fail(&quot;FAIL: long Math.floorMod(%d, %d); unexpected ArithmeticException from bigdecimal&quot;);
259             }
260         }
261     }
262 
263     /**
264      * Test the floorDiv and floorMod methods for mixed long and int.
265      */
266     static void testLongIntFloorDivMod() {
267         testLongIntFloorDivMod(4L, 0, new ArithmeticException(), new ArithmeticException()); // Should throw ArithmeticException
268         testLongIntFloorDivMod(4L, 3, 1L, 1);
269         testLongIntFloorDivMod(3L, 3, 1L, 0);
270         testLongIntFloorDivMod(2L, 3, 0L, 2);
271         testLongIntFloorDivMod(1L, 3, 0L, 1);
272         testLongIntFloorDivMod(0L, 3, 0L, 0);
273         testLongIntFloorDivMod(4L, -3, -2L, -2);
274         testLongIntFloorDivMod(3L, -3, -1L, 0);
275         testLongIntFloorDivMod(2L, -3, -1L, -1);
276         testLongIntFloorDivMod(1L, -3, -1L, -2);
277         testLongIntFloorDivMod(0L, -3, 0L, 0);
278         testLongIntFloorDivMod(-1L, 3, -1L, 2);
279         testLongIntFloorDivMod(-2L, 3, -1L, 1);
280         testLongIntFloorDivMod(-3L, 3, -1L, 0);
281         testLongIntFloorDivMod(-4L, 3, -2L, 2);
282         testLongIntFloorDivMod(-1L, -3, 0L, -1);
283         testLongIntFloorDivMod(-2L, -3, 0L, -2);
284         testLongIntFloorDivMod(-3L, -3, 1L, 0);
285         testLongIntFloorDivMod(-4L, -3, 1L, -1);
286 
287         testLongIntFloorDivMod(Long.MAX_VALUE, 1, Long.MAX_VALUE, 0L);
288         testLongIntFloorDivMod(Long.MAX_VALUE, -1, -Long.MAX_VALUE, 0L);
289         testLongIntFloorDivMod(Long.MAX_VALUE, 3, Long.MAX_VALUE / 3L, 1L);
290         testLongIntFloorDivMod(Long.MAX_VALUE - 1L, 3, (Long.MAX_VALUE - 1L) / 3L, 0L);
291         testLongIntFloorDivMod(Long.MIN_VALUE, 3, Long.MIN_VALUE / 3L - 1L, 1L);
292         testLongIntFloorDivMod(Long.MIN_VALUE + 1L, 3, Long.MIN_VALUE / 3L - 1L, 2L);
293         testLongIntFloorDivMod(Long.MIN_VALUE + 1, -1, Long.MAX_VALUE, 0L);
<a name="3" id="anc3"></a><span class="line-added">294         testLongIntFloorDivMod(Long.MAX_VALUE, Integer.MAX_VALUE, 4294967298L, 1);</span>
<span class="line-added">295         testLongIntFloorDivMod(Long.MAX_VALUE, Integer.MIN_VALUE, -4294967296L, -1);</span>
<span class="line-added">296         testLongIntFloorDivMod(Long.MIN_VALUE, Integer.MIN_VALUE, 4294967296L, 0);</span>
<span class="line-added">297         testLongIntFloorDivMod(Long.MIN_VALUE, Integer.MAX_VALUE, -4294967299L, 2147483645);</span>
298         // Special case of integer overflow
299         testLongIntFloorDivMod(Long.MIN_VALUE, -1, Long.MIN_VALUE, 0L);
300     }
301 
302     /**
303      * Test the integer floorDiv and floorMod methods.
304      * Math and StrictMath are tested and the same results are expected for both.
305      */
306     static void testLongIntFloorDivMod(long x, int y, Object divExpected, Object modExpected) {
307         testLongIntFloorDiv(x, y, divExpected);
308         testLongIntFloorMod(x, y, modExpected);
309     }
310 
311     /**
312      * Test FloorDiv with long arguments against expected value.
313      * The expected value is usually a Long but in some cases  is
314      * an ArithmeticException.
315      *
316      * @param x dividend
317      * @param y modulus
318      * @param expected expected value,
319      */
320     static void testLongIntFloorDiv(long x, int y, Object expected) {
321         Object result = doFloorDiv(x, y);
322         if (!resultEquals(result, expected)) {
323             fail(&quot;FAIL: long Math.floorDiv(%d, %d) = %s; expected %s%n&quot;, x, y, result, expected);
324         }
325 
326         Object strict_result = doStrictFloorDiv(x, y);
327         if (!resultEquals(strict_result, expected)) {
328             fail(&quot;FAIL: long StrictMath.floorDiv(%d, %d) = %s; expected %s%n&quot;, x, y, strict_result, expected);
329         }
330     }
331 
332     /**
333      * Test FloorMod of long arguments against expected value.
334      * The expected value is usually a Long but in some cases  is
335      * an ArithmeticException.
336      *
337      * @param x dividend
338      * @param y modulus
339      * @param expected expected value
340      */
341     static void testLongIntFloorMod(long x, int y, Object expected) {
342         Object result = doFloorMod(x, y);
343         if (!resultEquals(result, expected)) {
344             fail(&quot;FAIL: long Math.floorMod(%d, %d) = %s; expected %s%n&quot;, x, y, result, expected);
345         }
346 
347         Object strict_result = doStrictFloorMod(x, y);
348         if (!resultEquals(strict_result, expected)) {
349             fail(&quot;FAIL: long StrictMath.floorMod(%d, %d) = %s; expected %s%n&quot;, x, y, strict_result, expected);
350         }
351 
352         try {
353             // Verify the result against BigDecimal rounding mode.
354             BigDecimal xD = new BigDecimal(x);
355             BigDecimal yD = new BigDecimal(y);
356             BigDecimal resultD = xD.divide(yD, RoundingMode.FLOOR);
357             resultD = resultD.multiply(yD);
358             resultD = xD.subtract(resultD);
359             long fr = resultD.longValue();
360             if (!result.equals(fr)) {
361                 fail(&quot;FAIL: Long.floorMod(%d, %d) = %d is different than BigDecimal result: %d%n&quot;, x, y, result, fr);
362 
363             }
364         } catch (ArithmeticException ae) {
365             if (y != 0) {
366                 fail(&quot;FAIL: long Math.floorMod(%d, %d); unexpected ArithmeticException from bigdecimal&quot;);
367             }
368         }
369     }
370 
371     /**
372      * Invoke floorDiv and return the result or any exception.
373      * @param x the x value
374      * @param y the y value
375      * @return the result Integer or an exception.
376      */
377     static Object doFloorDiv(int x, int y) {
378         try {
379             return Math.floorDiv(x, y);
380         } catch (ArithmeticException ae) {
381             return ae;
382         }
383     }
384 
385     /**
386      * Invoke floorDiv and return the result or any exception.
387      * @param x the x value
388      * @param y the y value
389      * @return the result Integer or an exception.
390      */
391     static Object doFloorDiv(long x, int y) {
392         try {
393             return Math.floorDiv(x, y);
394         } catch (ArithmeticException ae) {
395             return ae;
396         }
397     }
398 
399     /**
400      * Invoke floorDiv and return the result or any exception.
401      * @param x the x value
402      * @param y the y value
403      * @return the result Integer or an exception.
404      */
405     static Object doFloorDiv(long x, long y) {
406         try {
407             return Math.floorDiv(x, y);
408         } catch (ArithmeticException ae) {
409             return ae;
410         }
411     }
412 
413     /**
414      * Invoke floorDiv and return the result or any exception.
415      * @param x the x value
416      * @param y the y value
417      * @return the result Integer or an exception.
418      */
419     static Object doFloorMod(int x, int y) {
420         try {
421             return Math.floorMod(x, y);
422         } catch (ArithmeticException ae) {
423             return ae;
424         }
425     }
426 
427     /**
428      * Invoke floorDiv and return the result or any exception.
429      * @param x the x value
430      * @param y the y value
431      * @return the result Integer or an exception.
432      */
433     static Object doFloorMod(long x, int y) {
434         try {
435             return Math.floorMod(x, y);
436         } catch (ArithmeticException ae) {
437             return ae;
438         }
439     }
440 
441     /**
442      * Invoke floorDiv and return the result or any exception.
443      * @param x the x value
444      * @param y the y value
445      * @return the result Integer or an exception.
446      */
447     static Object doFloorMod(long x, long y) {
448         try {
449             return Math.floorMod(x, y);
450         } catch (ArithmeticException ae) {
451             return ae;
452         }
453     }
454 
455     /**
456      * Invoke floorDiv and return the result or any exception.
457      * @param x the x value
458      * @param y the y value
459      * @return the result Integer or an exception.
460      */
461     static Object doStrictFloorDiv(int x, int y) {
462         try {
463             return StrictMath.floorDiv(x, y);
464         } catch (ArithmeticException ae) {
465             return ae;
466         }
467     }
468 
469     /**
470      * Invoke floorDiv and return the result or any exception.
471      * @param x the x value
472      * @param y the y value
473      * @return the result Integer or an exception.
474      */
475     static Object doStrictFloorDiv(long x, int y) {
476         try {
477             return StrictMath.floorDiv(x, y);
478         } catch (ArithmeticException ae) {
479             return ae;
480         }
481     }
482 
483     /**
484      * Invoke floorDiv and return the result or any exception.
485      * @param x the x value
486      * @param y the y value
487      * @return the result Integer or an exception.
488      */
489     static Object doStrictFloorDiv(long x, long y) {
490         try {
491             return StrictMath.floorDiv(x, y);
492         } catch (ArithmeticException ae) {
493             return ae;
494         }
495     }
496 
497     /**
498      * Invoke floorDiv and return the result or any exception.
499      * @param x the x value
500      * @param y the y value
501      * @return the result Integer or an exception.
502      */
503     static Object doStrictFloorMod(int x, int y) {
504         try {
505             return StrictMath.floorMod(x, y);
506         } catch (ArithmeticException ae) {
507             return ae;
508         }
509     }
510 
511     /**
512      * Invoke floorDiv and return the result or any exception.
513      * @param x the x value
514      * @param y the y value
515      * @return the result Integer or an exception.
516      */
517     static Object doStrictFloorMod(long x, int y) {
518         try {
519             return StrictMath.floorMod(x, y);
520         } catch (ArithmeticException ae) {
521             return ae;
522         }
523     }
524 
525     /**
526      * Invoke floorDiv and return the result or any exception.
527      * @param x the x value
528      * @param y the y value
529      * @return the result Integer or an exception.
530      */
531     static Object doStrictFloorMod(long x, long y) {
532         try {
533             return StrictMath.floorMod(x, y);
534         } catch (ArithmeticException ae) {
535             return ae;
536         }
537     }
538 
539     /**
540      * Returns a boolean by comparing the result and the expected value.
541      * The equals method is not defined for ArithmeticException but it is
542      * desirable to have equals return true if the expected and the result
543      * both threw the same exception (class and message.)
544      *
545      * @param result the result from testing the method
546      * @param expected the expected value
547      * @return true if the result is equal to the expected values; false otherwise.
548      */
549     static boolean resultEquals(Object result, Object expected) {
550         if (result.getClass() != expected.getClass()) {
551             fail(&quot;FAIL: Result type mismatch, %s; expected: %s%n&quot;,
552                     result.getClass().getName(), expected.getClass().getName());
553             return false;
554         }
555 
556         if (result.equals(expected)) {
557             return true;
558         }
559         // Handle special case to compare ArithmeticExceptions
560         if (result instanceof ArithmeticException &amp;&amp; expected instanceof ArithmeticException) {
561             return true;
562         }
563         return false;
564     }
565 
566 }
<a name="4" id="anc4"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="4" type="hidden" />
</body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New test/jdk/java/lang/constant/ClassDescTest.java</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2018, 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 import java.lang.invoke.MethodHandles;
 25 import java.lang.constant.ClassDesc;
 26 import java.lang.constant.ConstantDescs;
 27 import java.lang.reflect.Array;
 28 import java.lang.reflect.Field;
 29 import java.lang.reflect.Modifier;
 30 import java.util.Arrays;
 31 import java.util.List;
 32 import java.util.Map;
 33 
 34 import org.testng.annotations.Test;
 35 
 36 import static org.testng.Assert.assertEquals;
 37 import static org.testng.Assert.assertFalse;
 38 import static org.testng.Assert.assertNotEquals;
 39 import static org.testng.Assert.assertNull;
 40 import static org.testng.Assert.assertTrue;
 41 import static org.testng.Assert.fail;
 42 
 43 /**
 44  * @test
 45  * @bug 8215510
 46  * @compile ClassDescTest.java
 47  * @run testng ClassDescTest
 48  * @summary unit tests for java.lang.constant.ClassDesc
 49  */
 50 @Test
 51 public class ClassDescTest extends SymbolicDescTest {
 52 
 53     private void testClassDesc(ClassDesc r) throws ReflectiveOperationException {
 54         testSymbolicDesc(r);
 55 
 56         // Test descriptor accessor, factory, equals
 57         assertEquals(r, ClassDesc.ofDescriptor(r.descriptorString()));
 58 
 59         if (!r.descriptorString().equals(&quot;V&quot;)) {
 60             assertEquals(r, r.arrayType().componentType());
 61             // Commutativity: array -&gt; resolve -&gt; componentType -&gt; toSymbolic
 62             assertEquals(r, ((Class&lt;?&gt;) r.arrayType().resolveConstantDesc(LOOKUP)).getComponentType().describeConstable().orElseThrow());
 63             // Commutativity: resolve -&gt; array -&gt; toSymbolic -&gt; component type
 64             assertEquals(r, Array.newInstance(((Class&lt;?&gt;) r.resolveConstantDesc(LOOKUP)), 0).getClass().describeConstable().orElseThrow().componentType());
 65         }
 66 
 67         if (r.isArray()) {
 68             assertEquals(r, r.componentType().arrayType());
 69             assertEquals(r, ((Class&lt;?&gt;) r.resolveConstantDesc(LOOKUP)).getComponentType().describeConstable().orElseThrow().arrayType());
 70             assertEquals(r, Array.newInstance(((Class&lt;?&gt;) r.componentType().resolveConstantDesc(LOOKUP)), 0).getClass().describeConstable().orElseThrow());
 71         }
 72     }
 73 
 74     private void testClassDesc(ClassDesc r, Class&lt;?&gt; c) throws ReflectiveOperationException {
 75         testClassDesc(r);
 76 
 77         assertEquals(r.resolveConstantDesc(LOOKUP), c);
 78         assertEquals(c.describeConstable().orElseThrow(), r);
 79         assertEquals(ClassDesc.ofDescriptor(c.descriptorString()), r);
 80     }
 81 
 82     public void testSymbolicDescsConstants() throws ReflectiveOperationException {
 83         int tested = 0;
 84         Field[] fields = ConstantDescs.class.getDeclaredFields();
 85         for (Field f : fields) {
 86             try {
 87                 if (f.getType().equals(ClassDesc.class)
 88                     &amp;&amp; ((f.getModifiers() &amp; Modifier.STATIC) != 0)
 89                     &amp;&amp; ((f.getModifiers() &amp; Modifier.PUBLIC) != 0)) {
 90                     ClassDesc cr = (ClassDesc) f.get(null);
 91                     Class c = (Class)cr.resolveConstantDesc(MethodHandles.lookup());
 92                     testClassDesc(cr, c);
 93                     ++tested;
 94                 }
 95             }
 96             catch (Throwable e) {
 97                 System.out.println(e.getMessage());
 98                 fail(&quot;Error testing field &quot; + f.getName(), e);
 99             }
100         }
101 
102         assertTrue(tested &gt; 0);
103     }
104 
105     public void testPrimitiveClassDesc() throws ReflectiveOperationException {
106         for (Primitives p : Primitives.values()) {
107             List&lt;ClassDesc&gt; descs = List.of(ClassDesc.ofDescriptor(p.descriptor),
108                                            p.classDesc,
109                                            (ClassDesc) p.clazz.describeConstable().orElseThrow());
110             for (ClassDesc c : descs) {
111                 testClassDesc(c, p.clazz);
112                 assertTrue(c.isPrimitive());
113                 assertEquals(p.descriptor, c.descriptorString());
114                 assertEquals(p.name, c.displayName());
115                 descs.forEach(cc -&gt; assertEquals(c, cc));
116                 if (p != Primitives.VOID) {
117                     testClassDesc(c.arrayType(), p.arrayClass);
118                     assertEquals(c, ((ClassDesc) p.arrayClass.describeConstable().orElseThrow()).componentType());
119                     assertEquals(c, p.classDesc.arrayType().componentType());
120                 }
121             }
122 
123             for (Primitives other : Primitives.values()) {
124                 ClassDesc otherDescr = ClassDesc.ofDescriptor(other.descriptor);
125                 if (p != other)
126                     descs.forEach(c -&gt; assertNotEquals(c, otherDescr));
127                 else
128                     descs.forEach(c -&gt; assertEquals(c, otherDescr));
129             }
130         }
131     }
132 
133     public void testSimpleClassDesc() throws ReflectiveOperationException {
134 
135         List&lt;ClassDesc&gt; stringClassDescs = Arrays.asList(ClassDesc.ofDescriptor(&quot;Ljava/lang/String;&quot;),
136                                                         ClassDesc.of(&quot;java.lang&quot;, &quot;String&quot;),
137                                                         ClassDesc.of(&quot;java.lang.String&quot;),
138                                                         ClassDesc.of(&quot;java.lang.String&quot;).arrayType().componentType(),
139                                                         String.class.describeConstable().orElseThrow());
140         for (ClassDesc r : stringClassDescs) {
141             testClassDesc(r, String.class);
142             assertFalse(r.isPrimitive());
143             assertEquals(&quot;Ljava/lang/String;&quot;, r.descriptorString());
144             assertEquals(&quot;String&quot;, r.displayName());
145             assertEquals(r.arrayType().resolveConstantDesc(LOOKUP), String[].class);
146             stringClassDescs.forEach(rr -&gt; assertEquals(r, rr));
147         }
148 
149         testClassDesc(ClassDesc.of(&quot;java.lang.String&quot;).arrayType(), String[].class);
150         testClassDesc(ClassDesc.of(&quot;java.util.Map&quot;).nested(&quot;Entry&quot;), Map.Entry.class);
151 
152         ClassDesc thisClassDesc = ClassDesc.ofDescriptor(&quot;LClassDescTest;&quot;);
153         assertEquals(thisClassDesc, ClassDesc.of(&quot;&quot;, &quot;ClassDescTest&quot;));
154         assertEquals(thisClassDesc, ClassDesc.of(&quot;ClassDescTest&quot;));
155         assertEquals(thisClassDesc.displayName(), &quot;ClassDescTest&quot;);
156         testClassDesc(thisClassDesc, ClassDescTest.class);
157     }
158 
159     public void testPackageName() {
160         assertEquals(&quot;com.foo&quot;, ClassDesc.of(&quot;com.foo.Bar&quot;).packageName());
161         assertEquals(&quot;com.foo&quot;, ClassDesc.of(&quot;com.foo.Bar&quot;).nested(&quot;Baz&quot;).packageName());
162         assertEquals(&quot;&quot;, ClassDesc.of(&quot;Bar&quot;).packageName());
163         assertEquals(&quot;&quot;, ClassDesc.of(&quot;Bar&quot;).nested(&quot;Baz&quot;).packageName());
164         assertEquals(&quot;&quot;, ClassDesc.of(&quot;Bar&quot;).nested(&quot;Baz&quot;, &quot;Foo&quot;).packageName());
165 
166         assertEquals(&quot;&quot;, ConstantDescs.CD_int.packageName());
167         assertEquals(&quot;&quot;, ConstantDescs.CD_int.arrayType().packageName());
168         assertEquals(&quot;&quot;, ConstantDescs.CD_String.arrayType().packageName());
169         assertEquals(&quot;&quot;, ClassDesc.of(&quot;Bar&quot;).arrayType().packageName());
170     }
171 
172     private void testBadArrayRank(ClassDesc cr) {
173         try {
174             cr.arrayType(-1);
175             fail(&quot;&quot;);
176         } catch (IllegalArgumentException e) {
177             // good
178         }
179         try {
180             cr.arrayType(0);
181             fail(&quot;&quot;);
182         } catch (IllegalArgumentException e) {
183             // good
184         }
185     }
186 
187     public void testArrayClassDesc() throws ReflectiveOperationException {
188         for (String d : basicDescs) {
189             ClassDesc a0 = ClassDesc.ofDescriptor(d);
190             ClassDesc a1 = a0.arrayType();
191             ClassDesc a2 = a1.arrayType();
192 
193             testClassDesc(a0);
194             testClassDesc(a1);
195             testClassDesc(a2);
196             assertFalse(a0.isArray());
197             assertTrue(a1.isArray());
198             assertTrue(a2.isArray());
199             assertFalse(a1.isPrimitive());
200             assertFalse(a2.isPrimitive());
201             assertEquals(a0.descriptorString(), d);
202             assertEquals(a1.descriptorString(), &quot;[&quot; + a0.descriptorString());
203             assertEquals(a2.descriptorString(), &quot;[[&quot; + a0.descriptorString());
204 
205             assertNull(a0.componentType());
206             assertEquals(a0, a1.componentType());
207             assertEquals(a1, a2.componentType());
208 
209             assertNotEquals(a0, a1);
210             assertNotEquals(a1, a2);
211 
212             assertEquals(a1, ClassDesc.ofDescriptor(&quot;[&quot; + d));
213             assertEquals(a2, ClassDesc.ofDescriptor(&quot;[[&quot; + d));
214             assertEquals(classToDescriptor((Class&lt;?&gt;) a0.resolveConstantDesc(LOOKUP)), a0.descriptorString());
215             assertEquals(classToDescriptor((Class&lt;?&gt;) a1.resolveConstantDesc(LOOKUP)), a1.descriptorString());
216             assertEquals(classToDescriptor((Class&lt;?&gt;) a2.resolveConstantDesc(LOOKUP)), a2.descriptorString());
217 
218             testBadArrayRank(ConstantDescs.CD_int);
219             testBadArrayRank(ConstantDescs.CD_String);
220             testBadArrayRank(ClassDesc.of(&quot;Bar&quot;));
221         }
222     }
223 
224     public void testBadClassDescs() {
225         List&lt;String&gt; badDescriptors = List.of(&quot;II&quot;, &quot;I;&quot;, &quot;Q&quot;, &quot;L&quot;, &quot;&quot;,
226                                               &quot;java.lang.String&quot;, &quot;[]&quot;, &quot;Ljava/lang/String&quot;,
227                                               &quot;Ljava.lang.String;&quot;, &quot;java/lang/String&quot;);
228 
229         for (String d : badDescriptors) {
230             try {
231                 ClassDesc constant = ClassDesc.ofDescriptor(d);
232                 fail(d);
233             }
234             catch (IllegalArgumentException e) {
235                 // good
236             }
237         }
238 
239         List&lt;String&gt; badBinaryNames = List.of(&quot;I;&quot;, &quot;[]&quot;, &quot;Ljava/lang/String&quot;,
240                 &quot;Ljava.lang.String;&quot;, &quot;java/lang/String&quot;);
241         for (String d : badBinaryNames) {
242             try {
243                 ClassDesc constant = ClassDesc.of(d);
244                 fail(d);
245             } catch (IllegalArgumentException e) {
246                 // good
247             }
248         }
249 
250         for (Primitives p : Primitives.values()) {
251             testBadNestedClasses(ClassDesc.ofDescriptor(p.descriptor), &quot;any&quot;);
252             testBadNestedClasses(ClassDesc.ofDescriptor(p.descriptor), &quot;any&quot;, &quot;other&quot;);
253         }
254 
255         ClassDesc stringDesc = ClassDesc.ofDescriptor(&quot;Ljava/lang/String;&quot;);
256         ClassDesc stringArrDesc = stringDesc.arrayType(255);
257         try {
258             ClassDesc arrGreaterThan255 = stringArrDesc.arrayType();
259             fail(&quot;can&#39;t create an array type descriptor with more than 255 dimensions&quot;);
260         } catch (IllegalStateException e) {
261             // good
262         }
263         String descWith255ArrayDims = new String(new char[255]).replace(&#39;\0&#39;, &#39;[&#39;);
264         try {
265             ClassDesc arrGreaterThan255 = ClassDesc.ofDescriptor(descWith255ArrayDims + &quot;[Ljava/lang/String;&quot;);
266             fail(&quot;can&#39;t create an array type descriptor with more than 255 dimensions&quot;);
267         } catch (IllegalArgumentException e) {
268             // good
269         }
270         try {
271             ClassDesc arrWith255Dims = ClassDesc.ofDescriptor(descWith255ArrayDims + &quot;Ljava/lang/String;&quot;);
272             arrWith255Dims.arrayType(1);
273             fail(&quot;can&#39;t create an array type descriptor with more than 255 dimensions&quot;);
274         } catch (IllegalArgumentException e) {
275             // good
276         }
277     }
278 
279     private void testBadNestedClasses(ClassDesc cr, String firstNestedName, String... moreNestedNames) {
280         try {
281             cr.nested(firstNestedName, moreNestedNames);
282             fail(&quot;&quot;);
283         } catch (IllegalStateException e) {
284             // good
285         }
286     }
287 
288     public void testLangClasses() {
289         Double d = 1.0;
290         assertEquals(d.resolveConstantDesc(LOOKUP), d);
291         assertEquals(d.describeConstable().get(), d);
292 
293         Integer i = 1;
294         assertEquals(i.resolveConstantDesc(LOOKUP), i);
295         assertEquals(i.describeConstable().get(), i);
296 
297         Float f = 1.0f;
298         assertEquals(f.resolveConstantDesc(LOOKUP), f);
299         assertEquals(f.describeConstable().get(), f);
300 
301         Long l = 1L;
302         assertEquals(l.resolveConstantDesc(LOOKUP), l);
303         assertEquals(l.describeConstable().get(), l);
304 
305         String s = &quot;&quot;;
306         assertEquals(s.resolveConstantDesc(LOOKUP), s);
307         assertEquals(s.describeConstable().get(), s);
308     }
309 
310     public void testNullNestedClasses() {
311         ClassDesc cd = ClassDesc.of(&quot;Bar&quot;);
312         try {
313             cd.nested(null);
314             fail(&quot;&quot;);
315         } catch (NullPointerException e) {
316             // good
317         }
318 
319         try {
320             cd.nested(&quot;good&quot;, null);
321             fail(&quot;&quot;);
322         } catch (NullPointerException e) {
323             // good
324         }
325 
326         try {
327             cd.nested(&quot;good&quot;, &quot;goodToo&quot;, null);
328             fail(&quot;&quot;);
329         } catch (NullPointerException e) {
330             // good
331         }
332     }
333 }
    </pre>
  </body>
</html>
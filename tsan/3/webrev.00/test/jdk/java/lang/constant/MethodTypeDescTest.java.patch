diff a/test/jdk/java/lang/constant/MethodTypeDescTest.java b/test/jdk/java/lang/constant/MethodTypeDescTest.java
--- a/test/jdk/java/lang/constant/MethodTypeDescTest.java
+++ b/test/jdk/java/lang/constant/MethodTypeDescTest.java
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2018, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2018, 2019, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.
@@ -101,10 +101,18 @@
             MethodTypeDesc newDesc = mtDesc.changeReturnType(rc);
             assertEquals(newDesc, MethodTypeDesc.of(rc, paramTypes));
             testMethodTypeDesc(newDesc, mt.changeReturnType((Class<?>)rc.resolveConstantDesc(LOOKUP)));
         }
 
+        // try with null parameter
+        try {
+            MethodTypeDesc newDesc = mtDesc.changeReturnType(null);
+            fail("should fail with NPE");
+        } catch (NullPointerException ex) {
+            // good
+        }
+
         // changeParamType
         for (int i=0; i<paramTypes.length; i++) {
             for (String p : paramDescs) {
                 ClassDesc pc = ClassDesc.ofDescriptor(p);
                 ClassDesc[] ps = paramTypes.clone();
@@ -161,10 +169,38 @@
             MethodTypeDesc newDesc = mtDesc.insertParameterTypes(paramTypes.length + 1, paramTypes);
             fail("pos > current arguments length should have failed");
         } catch (IndexOutOfBoundsException ex) {
             // good
         }
+
+        try {
+            ClassDesc[] newParamTypes = new ClassDesc[1];
+            newParamTypes[0] = CD_void;
+            MethodTypeDesc newDesc = MethodTypeDesc.of(returnType, CD_int);
+            newDesc = newDesc.insertParameterTypes(0, newParamTypes);
+            fail("shouldn't allow parameters with class descriptor CD_void");
+        } catch (IllegalArgumentException ex) {
+            // good
+        }
+
+        try {
+            MethodTypeDesc newDesc = MethodTypeDesc.of(returnType, CD_int);
+            newDesc = newDesc.insertParameterTypes(0, null);
+            fail("should fail with NPE");
+        } catch (NullPointerException ex) {
+            // good
+        }
+
+        try {
+            ClassDesc[] newParamTypes = new ClassDesc[1];
+            newParamTypes[0] = null;
+            MethodTypeDesc newDesc = MethodTypeDesc.of(returnType, CD_int);
+            newDesc = newDesc.insertParameterTypes(0, newParamTypes);
+            fail("should fail with NPE");
+        } catch (NullPointerException ex) {
+            // good
+        }
     }
 
     private void badDropParametersTypes(ClassDesc returnType, String... paramDescTypes) {
         ClassDesc[] paramTypes =
                 IntStream.rangeClosed(0, paramDescTypes.length - 1)
@@ -199,11 +235,11 @@
         }
 
         try {
             MethodTypeDesc newDesc = mtDesc.dropParameterTypes(1, 0);
             fail("start index > end index should have failed");
-        } catch (IllegalArgumentException ex) {
+        } catch (IndexOutOfBoundsException ex) {
             // good
         }
     }
 
     public void testMethodTypeDesc() throws ReflectiveOperationException {
@@ -231,16 +267,42 @@
             catch (IllegalArgumentException e) {
                 // good
             }
         }
 
+        // try with null argument
+        try {
+            MethodTypeDesc r = MethodTypeDesc.ofDescriptor(null);
+            fail("should fail with NPE");
+        } catch (NullPointerException ex) {
+            // good
+        }
+
         // try with void arguments, this will stress another code path in particular
         // ConstantMethodTypeDesc::init
         try {
             MethodTypeDesc r = MethodTypeDesc.of(CD_int, CD_void);
             fail("can't reach here");
         }
         catch (IllegalArgumentException e) {
             // good
         }
+
+        try {
+            MethodTypeDesc r = MethodTypeDesc.of(CD_int, null);
+            fail("ClassDesc array should not be null");
+        }
+        catch (NullPointerException e) {
+            // good
+        }
+
+        try {
+            ClassDesc[] paramDescs = new ClassDesc[1];
+            paramDescs[0] = null;
+            MethodTypeDesc r = MethodTypeDesc.of(CD_int, paramDescs);
+            fail("ClassDesc should not be null");
+        }
+        catch (NullPointerException e) {
+            // good
+        }
     }
 }

<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old test/jdk/java/lang/constant/MethodHandleDescTest.java</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2018, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 import java.lang.invoke.MethodHandle;
 25 import java.lang.invoke.MethodHandleInfo;
 26 import java.lang.invoke.MethodHandles;
 27 import java.lang.invoke.MethodType;
 28 import java.lang.invoke.WrongMethodTypeException;
 29 import java.lang.constant.ClassDesc;
 30 import java.lang.constant.ConstantDescs;
 31 import java.lang.constant.DirectMethodHandleDesc;
 32 import java.lang.constant.MethodHandleDesc;
 33 import java.lang.reflect.Field;
 34 import java.lang.reflect.Modifier;
 35 import java.lang.constant.MethodTypeDesc;
 36 import java.util.ArrayList;
 37 import java.util.List;
 38 import java.util.function.Supplier;
 39 
 40 import org.testng.annotations.Test;
 41 
 42 import static java.lang.constant.ConstantDescs.CD_Void;
 43 import static java.lang.constant.ConstantDescs.CD_boolean;
 44 import static java.lang.constant.DirectMethodHandleDesc.*;
 45 import static java.lang.constant.DirectMethodHandleDesc.Kind.GETTER;
 46 import static java.lang.constant.DirectMethodHandleDesc.Kind.SETTER;
 47 import static java.lang.constant.DirectMethodHandleDesc.Kind.STATIC_GETTER;
 48 import static java.lang.constant.DirectMethodHandleDesc.Kind.STATIC_SETTER;
 49 import static java.lang.constant.DirectMethodHandleDesc.Kind.VIRTUAL;
 50 import static java.lang.constant.ConstantDescs.CD_Integer;
 51 import static java.lang.constant.ConstantDescs.CD_List;
 52 import static java.lang.constant.ConstantDescs.CD_Object;
 53 import static java.lang.constant.ConstantDescs.CD_String;
 54 import static java.lang.constant.ConstantDescs.CD_int;
 55 import static java.lang.constant.ConstantDescs.CD_void;
 56 import static org.testng.Assert.assertEquals;
 57 import static org.testng.Assert.assertNotSame;
 58 import static org.testng.Assert.assertSame;
 59 import static org.testng.Assert.assertTrue;
 60 import static org.testng.Assert.fail;
 61 
 62 /**
 63  * @test
 64  * @compile MethodHandleDescTest.java
 65  * @run testng MethodHandleDescTest
 66  * @summary unit tests for java.lang.constant.MethodHandleDesc
 67  */
 68 @Test
 69 public class MethodHandleDescTest extends SymbolicDescTest {
 70     private static ClassDesc helperHolderClass = ClassDesc.of(&quot;TestHelpers&quot;);
 71     private static ClassDesc testClass = helperHolderClass.nested(&quot;TestClass&quot;);
 72     private static ClassDesc testInterface = helperHolderClass.nested(&quot;TestInterface&quot;);
 73     private static ClassDesc testSuperclass = helperHolderClass.nested(&quot;TestSuperclass&quot;);
 74 
 75 
 76     private static void assertMHEquals(MethodHandle a, MethodHandle b) {
 77         MethodHandleInfo ia = LOOKUP.revealDirect(a);
 78         MethodHandleInfo ib = LOOKUP.revealDirect(b);
 79         assertEquals(ia.getDeclaringClass(), ib.getDeclaringClass());
 80         assertEquals(ia.getName(), ib.getName());
 81         assertEquals(ia.getMethodType(), ib.getMethodType());
 82         assertEquals(ia.getReferenceKind(), ib.getReferenceKind());
 83     }
 84 
 85     private void testMethodHandleDesc(MethodHandleDesc r) throws ReflectiveOperationException {
 86         if (r instanceof DirectMethodHandleDesc) {
 87             testSymbolicDesc(r);
 88 
 89             DirectMethodHandleDesc rr = (DirectMethodHandleDesc) r;
 90             assertEquals(r, MethodHandleDesc.of(rr.kind(), rr.owner(), rr.methodName(), rr.lookupDescriptor()));
 91             assertEquals(r.invocationType().resolveConstantDesc(LOOKUP), ((MethodHandle) r.resolveConstantDesc(LOOKUP)).type());
 92         }
 93         else {
 94             testSymbolicDescForwardOnly(r);
 95         }
 96     }
 97 
 98     private String lookupDescriptor(DirectMethodHandleDesc rr) {
 99         switch (rr.kind()) {
100             case VIRTUAL:
101             case SPECIAL:
102             case INTERFACE_VIRTUAL:
103             case INTERFACE_SPECIAL:
104                 return rr.invocationType().dropParameterTypes(0, 1).descriptorString();
105             case CONSTRUCTOR:
106                 return rr.invocationType().changeReturnType(CD_void).descriptorString();
107             default:
108                 return rr.invocationType().descriptorString();
109         }
110     }
111 
112     private void testMethodHandleDesc(MethodHandleDesc r, MethodHandle mh) throws ReflectiveOperationException {
113         testMethodHandleDesc(r);
114 
115         assertMHEquals(((MethodHandle) r.resolveConstantDesc(LOOKUP)), mh);
116         assertEquals(mh.describeConstable().orElseThrow(), r);
117 
118         // compare extractable properties: refKind, owner, name, type
119         MethodHandleInfo mhi = LOOKUP.revealDirect(mh);
120         DirectMethodHandleDesc rr = (DirectMethodHandleDesc) r;
121         assertEquals(mhi.getDeclaringClass().descriptorString(), rr.owner().descriptorString());
122         assertEquals(mhi.getName(), rr.methodName());
123         assertEquals(mhi.getReferenceKind(), rr.kind().refKind);
124         MethodType type = mhi.getMethodType();
125         assertEquals(type.toMethodDescriptorString(), lookupDescriptor(rr));
126     }
127 
128     public void testSimpleMHs() throws ReflectiveOperationException {
129         MethodHandle MH_String_isEmpty = LOOKUP.findVirtual(String.class, &quot;isEmpty&quot;, MethodType.fromMethodDescriptorString(&quot;()Z&quot;, null));
130         testMethodHandleDesc(MethodHandleDesc.of(Kind.VIRTUAL, CD_String, &quot;isEmpty&quot;, &quot;()Z&quot;), MH_String_isEmpty);
131         testMethodHandleDesc(MethodHandleDesc.ofMethod(Kind.VIRTUAL, CD_String, &quot;isEmpty&quot;, MethodTypeDesc.of(CD_boolean)), MH_String_isEmpty);
132 
133         MethodHandle MH_List_isEmpty = LOOKUP.findVirtual(List.class, &quot;isEmpty&quot;, MethodType.fromMethodDescriptorString(&quot;()Z&quot;, null));
134         testMethodHandleDesc(MethodHandleDesc.of(Kind.INTERFACE_VIRTUAL, CD_List, &quot;isEmpty&quot;, &quot;()Z&quot;), MH_List_isEmpty);
135         testMethodHandleDesc(MethodHandleDesc.ofMethod(Kind.INTERFACE_VIRTUAL, CD_List, &quot;isEmpty&quot;, MethodTypeDesc.of(CD_boolean)), MH_List_isEmpty);
136 
137         MethodHandle MH_String_format = LOOKUP.findStatic(String.class, &quot;format&quot;, MethodType.methodType(String.class, String.class, Object[].class));
138         testMethodHandleDesc(MethodHandleDesc.of(Kind.STATIC, CD_String, &quot;format&quot;, MethodType.methodType(String.class, String.class, Object[].class).descriptorString()),
139                              MH_String_format);
140         testMethodHandleDesc(MethodHandleDesc.ofMethod(Kind.STATIC, CD_String, &quot;format&quot;, MethodTypeDesc.of(CD_String, CD_String, CD_Object.arrayType())),
141                              MH_String_format);
142 
143         MethodHandle MH_ArrayList_new = LOOKUP.findConstructor(ArrayList.class, MethodType.methodType(void.class));
144         testMethodHandleDesc(MethodHandleDesc.ofMethod(Kind.CONSTRUCTOR, ClassDesc.of(&quot;java.util.ArrayList&quot;), &quot;&lt;init&gt;&quot;, MethodTypeDesc.of(CD_void)),
145                              MH_ArrayList_new);
146         testMethodHandleDesc(MethodHandleDesc.ofConstructor(ClassDesc.of(&quot;java.util.ArrayList&quot;)), MH_ArrayList_new);
147 
148         // bad constructor non void return type
149         try {
150             MethodHandleDesc.of(Kind.CONSTRUCTOR, ClassDesc.of(&quot;java.util.ArrayList&quot;), &quot;&lt;init&gt;&quot;, &quot;()I&quot;);
151             fail(&quot;should have failed: non void return type for constructor&quot;);
152         } catch (IllegalArgumentException ex) {
153             // good
154         }
155     }
156 
157     public void testAsType() throws Throwable {
158         MethodHandleDesc mhr = MethodHandleDesc.ofMethod(Kind.STATIC, ClassDesc.of(&quot;java.lang.Integer&quot;), &quot;valueOf&quot;,
159                                                          MethodTypeDesc.of(CD_Integer, CD_int));
160         MethodHandleDesc takesInteger = mhr.asType(MethodTypeDesc.of(CD_Integer, CD_Integer));
161         testMethodHandleDesc(takesInteger);
162         MethodHandle mh1 = (MethodHandle) takesInteger.resolveConstantDesc(LOOKUP);
163         assertEquals((Integer) 3, (Integer) mh1.invokeExact((Integer) 3));
164         assertEquals(takesInteger.toString(), &quot;MethodHandleDesc[STATIC/Integer::valueOf(int)Integer].asType(Integer)Integer&quot;);
165 
166         try {
167             Integer i = (Integer) mh1.invokeExact(3);
168             fail(&quot;Expected WMTE&quot;);
169         }
170         catch (WrongMethodTypeException ignored) { }
171 
172         MethodHandleDesc takesInt = takesInteger.asType(MethodTypeDesc.of(CD_Integer, CD_int));
173         testMethodHandleDesc(takesInt);
174         MethodHandle mh2 = (MethodHandle) takesInt.resolveConstantDesc(LOOKUP);
175         assertEquals((Integer) 3, (Integer) mh2.invokeExact(3));
176 
177         try {
178             Integer i = (Integer) mh2.invokeExact((Integer) 3);
179             fail(&quot;Expected WMTE&quot;);
180         }
181         catch (WrongMethodTypeException ignored) { }
182 
183         // Short circuit optimization
184         MethodHandleDesc same = mhr.asType(mhr.invocationType());
185         assertSame(mhr, same);
186 
187         // @@@ Test varargs adaptation
188         // @@@ Test bad adaptations and assert runtime error on resolution
189         // @@@ Test intrinsification of adapted MH
190     }
191 
192     public void testMethodHandleDesc() throws Throwable {
193         MethodHandleDesc ctorDesc = MethodHandleDesc.of(Kind.CONSTRUCTOR, testClass, &quot;&lt;ignored!&gt;&quot;, &quot;()V&quot;);
194         MethodHandleDesc staticMethodDesc = MethodHandleDesc.of(Kind.STATIC, testClass, &quot;sm&quot;, &quot;(I)I&quot;);
195         MethodHandleDesc staticIMethodDesc = MethodHandleDesc.of(Kind.INTERFACE_STATIC, testInterface, &quot;sm&quot;, &quot;(I)I&quot;);
196         MethodHandleDesc instanceMethodDesc = MethodHandleDesc.of(Kind.VIRTUAL, testClass, &quot;m&quot;, &quot;(I)I&quot;);
197         MethodHandleDesc instanceIMethodDesc = MethodHandleDesc.of(Kind.INTERFACE_VIRTUAL, testInterface, &quot;m&quot;, &quot;(I)I&quot;);
198         MethodHandleDesc superMethodDesc = MethodHandleDesc.of(Kind.SPECIAL, testSuperclass, &quot;m&quot;, &quot;(I)I&quot;);
199         MethodHandleDesc superIMethodDesc = MethodHandleDesc.of(Kind.INTERFACE_SPECIAL, testInterface, &quot;m&quot;, &quot;(I)I&quot;);
200         MethodHandleDesc privateMethodDesc = MethodHandleDesc.of(Kind.SPECIAL, testClass, &quot;pm&quot;, &quot;(I)I&quot;);
201         MethodHandleDesc privateIMethodDesc = MethodHandleDesc.of(Kind.INTERFACE_SPECIAL, testInterface, &quot;pm&quot;, &quot;(I)I&quot;);
202         MethodHandleDesc privateStaticMethodDesc = MethodHandleDesc.of(Kind.STATIC, testClass, &quot;psm&quot;, &quot;(I)I&quot;);
203         MethodHandleDesc privateStaticIMethodDesc = MethodHandleDesc.of(Kind.INTERFACE_STATIC, testInterface, &quot;psm&quot;, &quot;(I)I&quot;);
204 
205         assertEquals(ctorDesc.invocationType(), MethodTypeDesc.of(testClass));
206         assertEquals(((DirectMethodHandleDesc) ctorDesc).lookupDescriptor(), &quot;()V&quot;);
207 
208         assertEquals(staticMethodDesc.invocationType().descriptorString(), &quot;(I)I&quot;);
209         assertEquals(((DirectMethodHandleDesc) staticMethodDesc).lookupDescriptor(), &quot;(I)I&quot;);
210 
211         assertEquals(instanceMethodDesc.invocationType().descriptorString(), &quot;(&quot; + testClass.descriptorString() + &quot;I)I&quot;);
212         assertEquals(((DirectMethodHandleDesc) instanceMethodDesc).lookupDescriptor(), &quot;(I)I&quot;);
213 
214         for (MethodHandleDesc r : List.of(ctorDesc, staticMethodDesc, staticIMethodDesc, instanceMethodDesc, instanceIMethodDesc))
215             testMethodHandleDesc(r);
216 
217         TestHelpers.TestClass instance = (TestHelpers.TestClass) ((MethodHandle)ctorDesc.resolveConstantDesc(LOOKUP)).invokeExact();
218         TestHelpers.TestClass instance2 = (TestHelpers.TestClass) ((MethodHandle)ctorDesc.resolveConstantDesc(TestHelpers.TestClass.LOOKUP)).invokeExact();
219         TestHelpers.TestInterface instanceI = instance;
220 
221         assertNotSame(instance, instance2);
222 
223         assertEquals(5, (int) ((MethodHandle)staticMethodDesc.resolveConstantDesc(LOOKUP)).invokeExact(5));
224         assertEquals(5, (int) ((MethodHandle)staticMethodDesc.resolveConstantDesc(TestHelpers.TestClass.LOOKUP)).invokeExact(5));
225         assertEquals(0, (int) ((MethodHandle)staticIMethodDesc.resolveConstantDesc(LOOKUP)).invokeExact(5));
226         assertEquals(0, (int) ((MethodHandle)staticIMethodDesc.resolveConstantDesc(TestHelpers.TestClass.LOOKUP)).invokeExact(5));
227 
228         assertEquals(5, (int) ((MethodHandle)instanceMethodDesc.resolveConstantDesc(LOOKUP)).invokeExact(instance, 5));
229         assertEquals(5, (int) ((MethodHandle)instanceMethodDesc.resolveConstantDesc(TestHelpers.TestClass.LOOKUP)).invokeExact(instance, 5));
230         assertEquals(5, (int) ((MethodHandle)instanceIMethodDesc.resolveConstantDesc(LOOKUP)).invokeExact(instanceI, 5));
231         assertEquals(5, (int) ((MethodHandle)instanceIMethodDesc.resolveConstantDesc(TestHelpers.TestClass.LOOKUP)).invokeExact(instanceI, 5));
232 
233         try { superMethodDesc.resolveConstantDesc(LOOKUP); fail(); }
234         catch (IllegalAccessException e) { /* expected */ }
235         assertEquals(-1, (int) ((MethodHandle)superMethodDesc.resolveConstantDesc(TestHelpers.TestClass.LOOKUP)).invokeExact(instance, 5));
236 
237         try { superIMethodDesc.resolveConstantDesc(LOOKUP); fail(); }
238         catch (IllegalAccessException e) { /* expected */ }
239         assertEquals(0, (int) ((MethodHandle)superIMethodDesc.resolveConstantDesc(TestHelpers.TestClass.LOOKUP)).invokeExact(instance, 5));
240 
241         try { privateMethodDesc.resolveConstantDesc(LOOKUP); fail(); }
242         catch (IllegalAccessException e) { /* expected */ }
243         assertEquals(5, (int) ((MethodHandle)privateMethodDesc.resolveConstantDesc(TestHelpers.TestClass.LOOKUP)).invokeExact(instance, 5));
244 
245         try { privateIMethodDesc.resolveConstantDesc(LOOKUP); fail(); }
246         catch (IllegalAccessException e) { /* expected */ }
247         assertEquals(0, (int) ((MethodHandle)privateIMethodDesc.resolveConstantDesc(TestHelpers.TestInterface.LOOKUP)).invokeExact(instanceI, 5));
248         assertEquals(0, (int) ((MethodHandle)privateIMethodDesc.resolveConstantDesc(TestHelpers.TestClass.LOOKUP)).invoke(instanceI, 5));
249 
250         try { privateStaticMethodDesc.resolveConstantDesc(LOOKUP); fail(); }
251         catch (IllegalAccessException e) { /* expected */ }
252         assertEquals(5, (int) ((MethodHandle)privateStaticMethodDesc.resolveConstantDesc(TestHelpers.TestClass.LOOKUP)).invokeExact(5));
253 
254         try { privateStaticIMethodDesc.resolveConstantDesc(LOOKUP); fail(); }
255         catch (IllegalAccessException e) { /* expected */ }
256         assertEquals(0, (int) ((MethodHandle)privateStaticIMethodDesc.resolveConstantDesc(TestHelpers.TestInterface.LOOKUP)).invokeExact(5));
257         assertEquals(0, (int) ((MethodHandle)privateStaticIMethodDesc.resolveConstantDesc(TestHelpers.TestClass.LOOKUP)).invokeExact(5));
258 
259         MethodHandleDesc staticSetterDesc = MethodHandleDesc.ofField(STATIC_SETTER, testClass, &quot;sf&quot;, CD_int);
260         MethodHandleDesc staticGetterDesc = MethodHandleDesc.ofField(STATIC_GETTER, testClass, &quot;sf&quot;, CD_int);
261         MethodHandleDesc staticGetterIDesc = MethodHandleDesc.ofField(STATIC_GETTER, testInterface, &quot;sf&quot;, CD_int);
262         MethodHandleDesc setterDesc = MethodHandleDesc.ofField(SETTER, testClass, &quot;f&quot;, CD_int);
263         MethodHandleDesc getterDesc = MethodHandleDesc.ofField(GETTER, testClass, &quot;f&quot;, CD_int);
264 
265         for (MethodHandleDesc r : List.of(staticSetterDesc, staticGetterDesc, staticGetterIDesc, setterDesc, getterDesc))
266             testMethodHandleDesc(r);
267 
268         ((MethodHandle)staticSetterDesc.resolveConstantDesc(LOOKUP)).invokeExact(6); assertEquals(TestHelpers.TestClass.sf, 6);
269         assertEquals(6, (int) ((MethodHandle)staticGetterDesc.resolveConstantDesc(LOOKUP)).invokeExact());
270         assertEquals(6, (int) ((MethodHandle)staticGetterDesc.resolveConstantDesc(TestHelpers.TestClass.LOOKUP)).invokeExact());
271         ((MethodHandle)staticSetterDesc.resolveConstantDesc(TestHelpers.TestClass.LOOKUP)).invokeExact(7); assertEquals(TestHelpers.TestClass.sf, 7);
272         assertEquals(7, (int) ((MethodHandle)staticGetterDesc.resolveConstantDesc(LOOKUP)).invokeExact());
273         assertEquals(7, (int) ((MethodHandle)staticGetterDesc.resolveConstantDesc(TestHelpers.TestClass.LOOKUP)).invokeExact());
274 
275         assertEquals(3, (int) ((MethodHandle)staticGetterIDesc.resolveConstantDesc(LOOKUP)).invokeExact());
276         assertEquals(3, (int) ((MethodHandle)staticGetterIDesc.resolveConstantDesc(TestHelpers.TestClass.LOOKUP)).invokeExact());
277 
278         ((MethodHandle)setterDesc.resolveConstantDesc(LOOKUP)).invokeExact(instance, 6); assertEquals(instance.f, 6);
279         assertEquals(6, (int) ((MethodHandle)getterDesc.resolveConstantDesc(LOOKUP)).invokeExact(instance));
280         assertEquals(6, (int) ((MethodHandle)getterDesc.resolveConstantDesc(TestHelpers.TestClass.LOOKUP)).invokeExact(instance));
281         ((MethodHandle)setterDesc.resolveConstantDesc(TestHelpers.TestClass.LOOKUP)).invokeExact(instance, 7); assertEquals(instance.f, 7);
282         assertEquals(7, (int) ((MethodHandle)getterDesc.resolveConstantDesc(LOOKUP)).invokeExact(instance));
283         assertEquals(7, (int) ((MethodHandle)getterDesc.resolveConstantDesc(TestHelpers.TestClass.LOOKUP)).invokeExact(instance));
284     }
285 
286     private void assertBadArgs(Supplier&lt;MethodHandleDesc&gt; supplier, String s) {
287         try {
288             MethodHandleDesc r = supplier.get();
289             fail(&quot;Expected failure for &quot; + s);
290         }
291         catch (IllegalArgumentException e) {
292             // succeed
293         }
294     }
295 
296     public void testBadFieldMHs() {
297         List&lt;String&gt; badGetterDescs = List.of(&quot;()V&quot;, &quot;(Ljava/lang/Object;)V&quot;, &quot;(I)I&quot;, &quot;(Ljava/lang/Object;I)I&quot;);
298         List&lt;String&gt; badStaticGetterDescs = List.of(&quot;()V&quot;, &quot;(Ljava/lang/Object;)I&quot;, &quot;(I)I&quot;, &quot;(Ljava/lang/Object;I)I&quot;);
299         List&lt;String&gt; badSetterDescs = List.of(&quot;()V&quot;, &quot;(I)V&quot;, &quot;(Ljava/lang/Object;)V&quot;, &quot;(Ljava/lang/Object;I)I&quot;, &quot;(Ljava/lang/Object;II)V&quot;);
300         List&lt;String&gt; badStaticSetterDescs = List.of(&quot;()V&quot;, &quot;(II)V&quot;, &quot;()I&quot;);
301 
302         badGetterDescs.forEach(s -&gt; assertBadArgs(() -&gt; MethodHandleDesc.of(GETTER, helperHolderClass, &quot;x&quot;, s), s));
303         badSetterDescs.forEach(s -&gt; assertBadArgs(() -&gt; MethodHandleDesc.of(SETTER, helperHolderClass, &quot;x&quot;, s), s));
304         badStaticGetterDescs.forEach(s -&gt; assertBadArgs(() -&gt; MethodHandleDesc.of(STATIC_GETTER, helperHolderClass, &quot;x&quot;, s), s));
305         badStaticSetterDescs.forEach(s -&gt; assertBadArgs(() -&gt; MethodHandleDesc.of(STATIC_SETTER, helperHolderClass, &quot;x&quot;, s), s));
306     }
307 
308     @Test(expectedExceptions = IllegalArgumentException.class)
309     public void testBadOwners() {
310         MethodHandleDesc.ofMethod(VIRTUAL, ClassDesc.ofDescriptor(&quot;I&quot;), &quot;x&quot;, MethodTypeDesc.ofDescriptor(&quot;()I&quot;));
311     }
312 
313     public void testSymbolicDescsConstants() throws ReflectiveOperationException {
314         int tested = 0;
315         Field[] fields = ConstantDescs.class.getDeclaredFields();
316         for (Field f : fields) {
317             try {
318                 if (f.getType().equals(DirectMethodHandleDesc.class)
319                     &amp;&amp; ((f.getModifiers() &amp; Modifier.STATIC) != 0)
320                     &amp;&amp; ((f.getModifiers() &amp; Modifier.PUBLIC) != 0)) {
321                     MethodHandleDesc r = (MethodHandleDesc) f.get(null);
322                     MethodHandle m = (MethodHandle)r.resolveConstantDesc(MethodHandles.lookup());
323                     testMethodHandleDesc(r, m);
324                     ++tested;
325                 }
326             }
327             catch (Throwable e) {
328                 fail(&quot;Error testing field &quot; + f.getName(), e);
329             }
330         }
331 
332         assertTrue(tested &gt; 0);
333     }
334 
335     public void testKind() {
336         for (Kind k : Kind.values()) {
337             assertEquals(Kind.valueOf(k.refKind, k.isInterface), k);
338         }
339     }
340 }
    </pre>
  </body>
</html>
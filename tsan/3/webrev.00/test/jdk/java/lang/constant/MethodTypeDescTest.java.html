<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New test/jdk/java/lang/constant/MethodTypeDescTest.java</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2018, 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 import java.lang.invoke.MethodType;
 25 import java.lang.constant.ClassDesc;
 26 import java.lang.constant.MethodTypeDesc;
 27 import java.util.Arrays;
 28 import java.util.List;
 29 import java.util.stream.IntStream;
 30 import java.util.stream.Stream;
 31 
 32 import org.testng.annotations.Test;
 33 
 34 import static java.lang.constant.ConstantDescs.CD_int;
 35 import static java.lang.constant.ConstantDescs.CD_void;
 36 import static java.util.stream.Collectors.joining;
 37 import static java.util.stream.Collectors.toList;
 38 import static org.testng.Assert.assertEquals;
 39 import static org.testng.Assert.fail;
 40 
 41 /**
 42  * @test
 43  * @compile MethodTypeDescTest.java
 44  * @run testng MethodTypeDescTest
 45  * @summary unit tests for java.lang.constant.MethodTypeDesc
 46  */
 47 @Test
 48 public class MethodTypeDescTest extends SymbolicDescTest {
 49 
 50     private void testMethodTypeDesc(MethodTypeDesc r) throws ReflectiveOperationException {
 51         testSymbolicDesc(r);
 52 
 53         // Tests accessors (rType, pType, pCount, pList, pArray, descriptorString),
 54         // factories (ofDescriptor, of), equals
 55         assertEquals(r, MethodTypeDesc.ofDescriptor(r.descriptorString()));
 56         assertEquals(r, MethodTypeDesc.of(r.returnType(), r.parameterArray()));
 57         assertEquals(r, MethodTypeDesc.of(r.returnType(), r.parameterList().toArray(new ClassDesc[0])));
 58         assertEquals(r, MethodTypeDesc.of(r.returnType(), r.parameterList().stream().toArray(ClassDesc[]::new)));
 59         assertEquals(r, MethodTypeDesc.of(r.returnType(), IntStream.range(0, r.parameterCount())
 60                                                                    .mapToObj(r::parameterType)
 61                                                                    .toArray(ClassDesc[]::new)));
 62     }
 63 
 64     private void testMethodTypeDesc(MethodTypeDesc r, MethodType mt) throws ReflectiveOperationException {
 65         testMethodTypeDesc(r);
 66 
 67         assertEquals(r.resolveConstantDesc(LOOKUP), mt);
 68         assertEquals(mt.describeConstable().get(), r);
 69 
 70         assertEquals(r.descriptorString(), mt.toMethodDescriptorString());
 71         assertEquals(r.parameterCount(), mt.parameterCount());
 72         assertEquals(r.parameterList(), mt.parameterList().stream().map(SymbolicDescTest::classToDesc).collect(toList()));
 73         assertEquals(r.parameterArray(), Stream.of(mt.parameterArray()).map(SymbolicDescTest::classToDesc).toArray(ClassDesc[]::new));
 74         for (int i=0; i&lt;r.parameterCount(); i++)
 75             assertEquals(r.parameterType(i), classToDesc(mt.parameterType(i)));
 76         assertEquals(r.returnType(), classToDesc(mt.returnType()));
 77     }
 78 
 79     private void assertMethodType(ClassDesc returnType,
 80                                   ClassDesc... paramTypes) throws ReflectiveOperationException {
 81         String descriptor = Stream.of(paramTypes).map(ClassDesc::descriptorString).collect(joining(&quot;&quot;, &quot;(&quot;, &quot;)&quot;))
 82                             + returnType.descriptorString();
 83         MethodTypeDesc mtDesc = MethodTypeDesc.of(returnType, paramTypes);
 84 
 85         // MTDesc accessors
 86         assertEquals(descriptor, mtDesc.descriptorString());
 87         assertEquals(returnType, mtDesc.returnType());
 88         assertEquals(paramTypes, mtDesc.parameterArray());
 89         assertEquals(Arrays.asList(paramTypes), mtDesc.parameterList());
 90         assertEquals(paramTypes.length, mtDesc.parameterCount());
 91         for (int i=0; i&lt;paramTypes.length; i++)
 92             assertEquals(paramTypes[i], mtDesc.parameterType(i));
 93 
 94         // Consistency between MT and MTDesc
 95         MethodType mt = MethodType.fromMethodDescriptorString(descriptor, null);
 96         testMethodTypeDesc(mtDesc, mt);
 97 
 98         // changeReturnType
 99         for (String r : returnDescs) {
100             ClassDesc rc = ClassDesc.ofDescriptor(r);
101             MethodTypeDesc newDesc = mtDesc.changeReturnType(rc);
102             assertEquals(newDesc, MethodTypeDesc.of(rc, paramTypes));
103             testMethodTypeDesc(newDesc, mt.changeReturnType((Class&lt;?&gt;)rc.resolveConstantDesc(LOOKUP)));
104         }
105 
106         // try with null parameter
107         try {
108             MethodTypeDesc newDesc = mtDesc.changeReturnType(null);
109             fail(&quot;should fail with NPE&quot;);
110         } catch (NullPointerException ex) {
111             // good
112         }
113 
114         // changeParamType
115         for (int i=0; i&lt;paramTypes.length; i++) {
116             for (String p : paramDescs) {
117                 ClassDesc pc = ClassDesc.ofDescriptor(p);
118                 ClassDesc[] ps = paramTypes.clone();
119                 ps[i] = pc;
120                 MethodTypeDesc newDesc = mtDesc.changeParameterType(i, pc);
121                 assertEquals(newDesc, MethodTypeDesc.of(returnType, ps));
122                 testMethodTypeDesc(newDesc, mt.changeParameterType(i, (Class&lt;?&gt;)pc.resolveConstantDesc(LOOKUP)));
123             }
124         }
125 
126         // dropParamType
127         for (int i=0; i&lt;paramTypes.length; i++) {
128             int k = i;
129             ClassDesc[] ps = IntStream.range(0, paramTypes.length)
130                                       .filter(j -&gt; j != k)
131                                       .mapToObj(j -&gt; paramTypes[j])
132                                       .toArray(ClassDesc[]::new);
133             MethodTypeDesc newDesc = mtDesc.dropParameterTypes(i, i + 1);
134             assertEquals(newDesc, MethodTypeDesc.of(returnType, ps));
135             testMethodTypeDesc(newDesc, mt.dropParameterTypes(i, i+1));
136         }
137 
138         badDropParametersTypes(CD_void, paramDescs);
139 
140         // addParam
141         for (int i=0; i &lt;= paramTypes.length; i++) {
142             for (ClassDesc p : paramTypes) {
143                 int k = i;
144                 ClassDesc[] ps = IntStream.range(0, paramTypes.length + 1)
145                                           .mapToObj(j -&gt; (j &lt; k) ? paramTypes[j] : (j == k) ? p : paramTypes[j-1])
146                                           .toArray(ClassDesc[]::new);
147                 MethodTypeDesc newDesc = mtDesc.insertParameterTypes(i, p);
148                 assertEquals(newDesc, MethodTypeDesc.of(returnType, ps));
149                 testMethodTypeDesc(newDesc, mt.insertParameterTypes(i, (Class&lt;?&gt;)p.resolveConstantDesc(LOOKUP)));
150             }
151         }
152 
153         badInsertParametersTypes(CD_void, paramDescs);
154     }
155 
156     private void badInsertParametersTypes(ClassDesc returnType, String... paramDescTypes) {
157         ClassDesc[] paramTypes =
158                 IntStream.rangeClosed(0, paramDescTypes.length - 1)
159                         .mapToObj(i -&gt; ClassDesc.ofDescriptor(paramDescTypes[i])).toArray(ClassDesc[]::new);
160         MethodTypeDesc mtDesc = MethodTypeDesc.of(returnType, paramTypes);
161         try {
162             MethodTypeDesc newDesc = mtDesc.insertParameterTypes(-1, paramTypes);
163             fail(&quot;pos &lt; 0 should have failed&quot;);
164         } catch (IndexOutOfBoundsException ex) {
165             // good
166         }
167 
168         try {
169             MethodTypeDesc newDesc = mtDesc.insertParameterTypes(paramTypes.length + 1, paramTypes);
170             fail(&quot;pos &gt; current arguments length should have failed&quot;);
171         } catch (IndexOutOfBoundsException ex) {
172             // good
173         }
174 
175         try {
176             ClassDesc[] newParamTypes = new ClassDesc[1];
177             newParamTypes[0] = CD_void;
178             MethodTypeDesc newDesc = MethodTypeDesc.of(returnType, CD_int);
179             newDesc = newDesc.insertParameterTypes(0, newParamTypes);
180             fail(&quot;shouldn&#39;t allow parameters with class descriptor CD_void&quot;);
181         } catch (IllegalArgumentException ex) {
182             // good
183         }
184 
185         try {
186             MethodTypeDesc newDesc = MethodTypeDesc.of(returnType, CD_int);
187             newDesc = newDesc.insertParameterTypes(0, null);
188             fail(&quot;should fail with NPE&quot;);
189         } catch (NullPointerException ex) {
190             // good
191         }
192 
193         try {
194             ClassDesc[] newParamTypes = new ClassDesc[1];
195             newParamTypes[0] = null;
196             MethodTypeDesc newDesc = MethodTypeDesc.of(returnType, CD_int);
197             newDesc = newDesc.insertParameterTypes(0, newParamTypes);
198             fail(&quot;should fail with NPE&quot;);
199         } catch (NullPointerException ex) {
200             // good
201         }
202     }
203 
204     private void badDropParametersTypes(ClassDesc returnType, String... paramDescTypes) {
205         ClassDesc[] paramTypes =
206                 IntStream.rangeClosed(0, paramDescTypes.length - 1)
207                         .mapToObj(i -&gt; ClassDesc.ofDescriptor(paramDescTypes[i])).toArray(ClassDesc[]::new);
208         MethodTypeDesc mtDesc = MethodTypeDesc.of(returnType, paramTypes);
209         try {
210             MethodTypeDesc newDesc = mtDesc.dropParameterTypes(-1, 0);
211             fail(&quot;start index &lt; 0 should have failed&quot;);
212         } catch (IndexOutOfBoundsException ex) {
213             // good
214         }
215 
216         try {
217             MethodTypeDesc newDesc = mtDesc.dropParameterTypes(paramTypes.length, 0);
218             fail(&quot;start index = arguments.length should have failed&quot;);
219         } catch (IndexOutOfBoundsException ex) {
220             // good
221         }
222 
223         try {
224             MethodTypeDesc newDesc = mtDesc.dropParameterTypes(paramTypes.length + 1, 0);
225             fail(&quot;start index &gt; arguments.length should have failed&quot;);
226         } catch (IndexOutOfBoundsException ex) {
227             // good
228         }
229 
230         try {
231             MethodTypeDesc newDesc = mtDesc.dropParameterTypes(0, paramTypes.length + 1);
232             fail(&quot;end index &gt; arguments.length should have failed&quot;);
233         } catch (IndexOutOfBoundsException ex) {
234             // good
235         }
236 
237         try {
238             MethodTypeDesc newDesc = mtDesc.dropParameterTypes(1, 0);
239             fail(&quot;start index &gt; end index should have failed&quot;);
240         } catch (IndexOutOfBoundsException ex) {
241             // good
242         }
243     }
244 
245     public void testMethodTypeDesc() throws ReflectiveOperationException {
246         for (String r : returnDescs) {
247             assertMethodType(ClassDesc.ofDescriptor(r));
248             for (String p1 : paramDescs) {
249                 assertMethodType(ClassDesc.ofDescriptor(r), ClassDesc.ofDescriptor(p1));
250                 for (String p2 : paramDescs) {
251                     assertMethodType(ClassDesc.ofDescriptor(r), ClassDesc.ofDescriptor(p1), ClassDesc.ofDescriptor(p2));
252                 }
253             }
254         }
255     }
256 
257     public void testBadMethodTypeRefs() {
258         List&lt;String&gt; badDescriptors = List.of(&quot;()II&quot;, &quot;()I;&quot;, &quot;(I;)&quot;, &quot;(I)&quot;, &quot;()L&quot;, &quot;(V)V&quot;,
259                                               &quot;(java.lang.String)V&quot;, &quot;()[]&quot;, &quot;(Ljava/lang/String)V&quot;,
260                                               &quot;(Ljava.lang.String;)V&quot;, &quot;(java/lang/String)V&quot;);
261 
262         for (String d : badDescriptors) {
263             try {
264                 MethodTypeDesc r = MethodTypeDesc.ofDescriptor(d);
265                 fail(d);
266             }
267             catch (IllegalArgumentException e) {
268                 // good
269             }
270         }
271 
272         // try with null argument
273         try {
274             MethodTypeDesc r = MethodTypeDesc.ofDescriptor(null);
275             fail(&quot;should fail with NPE&quot;);
276         } catch (NullPointerException ex) {
277             // good
278         }
279 
280         // try with void arguments, this will stress another code path in particular
281         // ConstantMethodTypeDesc::init
282         try {
283             MethodTypeDesc r = MethodTypeDesc.of(CD_int, CD_void);
284             fail(&quot;can&#39;t reach here&quot;);
285         }
286         catch (IllegalArgumentException e) {
287             // good
288         }
289 
290         try {
291             MethodTypeDesc r = MethodTypeDesc.of(CD_int, null);
292             fail(&quot;ClassDesc array should not be null&quot;);
293         }
294         catch (NullPointerException e) {
295             // good
296         }
297 
298         try {
299             ClassDesc[] paramDescs = new ClassDesc[1];
300             paramDescs[0] = null;
301             MethodTypeDesc r = MethodTypeDesc.of(CD_int, paramDescs);
302             fail(&quot;ClassDesc should not be null&quot;);
303         }
304         catch (NullPointerException e) {
305             // good
306         }
307     }
308 }
    </pre>
  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames test/jdk/java/lang/constant/MethodHandleDescTest.java</title>
    <link rel="stylesheet" href="../../../../../style.css" />
    <script type="text/javascript" src="../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
<a name="1" id="anc1"></a><span class="line-modified">  2  * Copyright (c) 2018, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 import java.lang.invoke.MethodHandle;
 25 import java.lang.invoke.MethodHandleInfo;
 26 import java.lang.invoke.MethodHandles;
 27 import java.lang.invoke.MethodType;
 28 import java.lang.invoke.WrongMethodTypeException;
 29 import java.lang.constant.ClassDesc;
 30 import java.lang.constant.ConstantDescs;
 31 import java.lang.constant.DirectMethodHandleDesc;
 32 import java.lang.constant.MethodHandleDesc;
 33 import java.lang.reflect.Field;
 34 import java.lang.reflect.Modifier;
 35 import java.lang.constant.MethodTypeDesc;
 36 import java.util.ArrayList;
 37 import java.util.List;
 38 import java.util.function.Supplier;
 39 
 40 import org.testng.annotations.Test;
 41 
 42 import static java.lang.constant.ConstantDescs.CD_Void;
 43 import static java.lang.constant.ConstantDescs.CD_boolean;
 44 import static java.lang.constant.DirectMethodHandleDesc.*;
 45 import static java.lang.constant.DirectMethodHandleDesc.Kind.GETTER;
 46 import static java.lang.constant.DirectMethodHandleDesc.Kind.SETTER;
 47 import static java.lang.constant.DirectMethodHandleDesc.Kind.STATIC_GETTER;
 48 import static java.lang.constant.DirectMethodHandleDesc.Kind.STATIC_SETTER;
 49 import static java.lang.constant.DirectMethodHandleDesc.Kind.VIRTUAL;
 50 import static java.lang.constant.ConstantDescs.CD_Integer;
 51 import static java.lang.constant.ConstantDescs.CD_List;
 52 import static java.lang.constant.ConstantDescs.CD_Object;
 53 import static java.lang.constant.ConstantDescs.CD_String;
 54 import static java.lang.constant.ConstantDescs.CD_int;
 55 import static java.lang.constant.ConstantDescs.CD_void;
 56 import static org.testng.Assert.assertEquals;
 57 import static org.testng.Assert.assertNotSame;
 58 import static org.testng.Assert.assertSame;
 59 import static org.testng.Assert.assertTrue;
 60 import static org.testng.Assert.fail;
 61 
 62 /**
 63  * @test
 64  * @compile MethodHandleDescTest.java
 65  * @run testng MethodHandleDescTest
 66  * @summary unit tests for java.lang.constant.MethodHandleDesc
 67  */
 68 @Test
 69 public class MethodHandleDescTest extends SymbolicDescTest {
 70     private static ClassDesc helperHolderClass = ClassDesc.of(&quot;TestHelpers&quot;);
 71     private static ClassDesc testClass = helperHolderClass.nested(&quot;TestClass&quot;);
 72     private static ClassDesc testInterface = helperHolderClass.nested(&quot;TestInterface&quot;);
 73     private static ClassDesc testSuperclass = helperHolderClass.nested(&quot;TestSuperclass&quot;);
 74 
 75 
 76     private static void assertMHEquals(MethodHandle a, MethodHandle b) {
 77         MethodHandleInfo ia = LOOKUP.revealDirect(a);
 78         MethodHandleInfo ib = LOOKUP.revealDirect(b);
 79         assertEquals(ia.getDeclaringClass(), ib.getDeclaringClass());
 80         assertEquals(ia.getName(), ib.getName());
 81         assertEquals(ia.getMethodType(), ib.getMethodType());
 82         assertEquals(ia.getReferenceKind(), ib.getReferenceKind());
 83     }
 84 
 85     private void testMethodHandleDesc(MethodHandleDesc r) throws ReflectiveOperationException {
 86         if (r instanceof DirectMethodHandleDesc) {
 87             testSymbolicDesc(r);
 88 
 89             DirectMethodHandleDesc rr = (DirectMethodHandleDesc) r;
 90             assertEquals(r, MethodHandleDesc.of(rr.kind(), rr.owner(), rr.methodName(), rr.lookupDescriptor()));
 91             assertEquals(r.invocationType().resolveConstantDesc(LOOKUP), ((MethodHandle) r.resolveConstantDesc(LOOKUP)).type());
 92         }
 93         else {
 94             testSymbolicDescForwardOnly(r);
 95         }
 96     }
 97 
 98     private String lookupDescriptor(DirectMethodHandleDesc rr) {
 99         switch (rr.kind()) {
100             case VIRTUAL:
101             case SPECIAL:
102             case INTERFACE_VIRTUAL:
103             case INTERFACE_SPECIAL:
104                 return rr.invocationType().dropParameterTypes(0, 1).descriptorString();
105             case CONSTRUCTOR:
106                 return rr.invocationType().changeReturnType(CD_void).descriptorString();
107             default:
108                 return rr.invocationType().descriptorString();
109         }
110     }
111 
112     private void testMethodHandleDesc(MethodHandleDesc r, MethodHandle mh) throws ReflectiveOperationException {
113         testMethodHandleDesc(r);
114 
115         assertMHEquals(((MethodHandle) r.resolveConstantDesc(LOOKUP)), mh);
116         assertEquals(mh.describeConstable().orElseThrow(), r);
117 
118         // compare extractable properties: refKind, owner, name, type
119         MethodHandleInfo mhi = LOOKUP.revealDirect(mh);
120         DirectMethodHandleDesc rr = (DirectMethodHandleDesc) r;
121         assertEquals(mhi.getDeclaringClass().descriptorString(), rr.owner().descriptorString());
122         assertEquals(mhi.getName(), rr.methodName());
123         assertEquals(mhi.getReferenceKind(), rr.kind().refKind);
124         MethodType type = mhi.getMethodType();
125         assertEquals(type.toMethodDescriptorString(), lookupDescriptor(rr));
126     }
127 
128     public void testSimpleMHs() throws ReflectiveOperationException {
129         MethodHandle MH_String_isEmpty = LOOKUP.findVirtual(String.class, &quot;isEmpty&quot;, MethodType.fromMethodDescriptorString(&quot;()Z&quot;, null));
130         testMethodHandleDesc(MethodHandleDesc.of(Kind.VIRTUAL, CD_String, &quot;isEmpty&quot;, &quot;()Z&quot;), MH_String_isEmpty);
131         testMethodHandleDesc(MethodHandleDesc.ofMethod(Kind.VIRTUAL, CD_String, &quot;isEmpty&quot;, MethodTypeDesc.of(CD_boolean)), MH_String_isEmpty);
132 
133         MethodHandle MH_List_isEmpty = LOOKUP.findVirtual(List.class, &quot;isEmpty&quot;, MethodType.fromMethodDescriptorString(&quot;()Z&quot;, null));
134         testMethodHandleDesc(MethodHandleDesc.of(Kind.INTERFACE_VIRTUAL, CD_List, &quot;isEmpty&quot;, &quot;()Z&quot;), MH_List_isEmpty);
135         testMethodHandleDesc(MethodHandleDesc.ofMethod(Kind.INTERFACE_VIRTUAL, CD_List, &quot;isEmpty&quot;, MethodTypeDesc.of(CD_boolean)), MH_List_isEmpty);
136 
137         MethodHandle MH_String_format = LOOKUP.findStatic(String.class, &quot;format&quot;, MethodType.methodType(String.class, String.class, Object[].class));
138         testMethodHandleDesc(MethodHandleDesc.of(Kind.STATIC, CD_String, &quot;format&quot;, MethodType.methodType(String.class, String.class, Object[].class).descriptorString()),
139                              MH_String_format);
140         testMethodHandleDesc(MethodHandleDesc.ofMethod(Kind.STATIC, CD_String, &quot;format&quot;, MethodTypeDesc.of(CD_String, CD_String, CD_Object.arrayType())),
141                              MH_String_format);
142 
143         MethodHandle MH_ArrayList_new = LOOKUP.findConstructor(ArrayList.class, MethodType.methodType(void.class));
144         testMethodHandleDesc(MethodHandleDesc.ofMethod(Kind.CONSTRUCTOR, ClassDesc.of(&quot;java.util.ArrayList&quot;), &quot;&lt;init&gt;&quot;, MethodTypeDesc.of(CD_void)),
145                              MH_ArrayList_new);
146         testMethodHandleDesc(MethodHandleDesc.ofConstructor(ClassDesc.of(&quot;java.util.ArrayList&quot;)), MH_ArrayList_new);
147 
148         // bad constructor non void return type
149         try {
150             MethodHandleDesc.of(Kind.CONSTRUCTOR, ClassDesc.of(&quot;java.util.ArrayList&quot;), &quot;&lt;init&gt;&quot;, &quot;()I&quot;);
151             fail(&quot;should have failed: non void return type for constructor&quot;);
152         } catch (IllegalArgumentException ex) {
153             // good
154         }
<a name="2" id="anc2"></a><span class="line-added">155 </span>
<span class="line-added">156         // null list of parameters</span>
<span class="line-added">157         try {</span>
<span class="line-added">158             MethodHandleDesc.ofConstructor(ClassDesc.of(&quot;java.util.ArrayList&quot;, null));</span>
<span class="line-added">159             fail(&quot;should have failed: null list of parameters&quot;);</span>
<span class="line-added">160         } catch (NullPointerException ex) {</span>
<span class="line-added">161             // good</span>
<span class="line-added">162         }</span>
<span class="line-added">163 </span>
<span class="line-added">164         // null elements in list of parameters</span>
<span class="line-added">165         try {</span>
<span class="line-added">166             ClassDesc[] paramList = new ClassDesc[1];</span>
<span class="line-added">167             paramList[0] = null;</span>
<span class="line-added">168             MethodHandleDesc.ofConstructor(ClassDesc.of(&quot;java.util.ArrayList&quot;), paramList);</span>
<span class="line-added">169             fail(&quot;should have failed: null content in list of parameters&quot;);</span>
<span class="line-added">170         } catch (NullPointerException ex) {</span>
<span class="line-added">171             // good</span>
<span class="line-added">172         }</span>
173     }
174 
175     public void testAsType() throws Throwable {
176         MethodHandleDesc mhr = MethodHandleDesc.ofMethod(Kind.STATIC, ClassDesc.of(&quot;java.lang.Integer&quot;), &quot;valueOf&quot;,
177                                                          MethodTypeDesc.of(CD_Integer, CD_int));
178         MethodHandleDesc takesInteger = mhr.asType(MethodTypeDesc.of(CD_Integer, CD_Integer));
179         testMethodHandleDesc(takesInteger);
180         MethodHandle mh1 = (MethodHandle) takesInteger.resolveConstantDesc(LOOKUP);
181         assertEquals((Integer) 3, (Integer) mh1.invokeExact((Integer) 3));
182         assertEquals(takesInteger.toString(), &quot;MethodHandleDesc[STATIC/Integer::valueOf(int)Integer].asType(Integer)Integer&quot;);
183 
184         try {
185             Integer i = (Integer) mh1.invokeExact(3);
186             fail(&quot;Expected WMTE&quot;);
187         }
188         catch (WrongMethodTypeException ignored) { }
189 
190         MethodHandleDesc takesInt = takesInteger.asType(MethodTypeDesc.of(CD_Integer, CD_int));
191         testMethodHandleDesc(takesInt);
192         MethodHandle mh2 = (MethodHandle) takesInt.resolveConstantDesc(LOOKUP);
193         assertEquals((Integer) 3, (Integer) mh2.invokeExact(3));
194 
195         try {
196             Integer i = (Integer) mh2.invokeExact((Integer) 3);
197             fail(&quot;Expected WMTE&quot;);
198         }
199         catch (WrongMethodTypeException ignored) { }
200 
201         // Short circuit optimization
202         MethodHandleDesc same = mhr.asType(mhr.invocationType());
203         assertSame(mhr, same);
204 
<a name="3" id="anc3"></a><span class="line-added">205         try {</span>
<span class="line-added">206             mhr.asType(null);</span>
<span class="line-added">207             fail(&quot;Expected NPE&quot;);</span>
<span class="line-added">208         } catch (NullPointerException ex) {</span>
<span class="line-added">209             // good</span>
<span class="line-added">210         }</span>
<span class="line-added">211 </span>
212         // @@@ Test varargs adaptation
213         // @@@ Test bad adaptations and assert runtime error on resolution
214         // @@@ Test intrinsification of adapted MH
215     }
216 
217     public void testMethodHandleDesc() throws Throwable {
218         MethodHandleDesc ctorDesc = MethodHandleDesc.of(Kind.CONSTRUCTOR, testClass, &quot;&lt;ignored!&gt;&quot;, &quot;()V&quot;);
219         MethodHandleDesc staticMethodDesc = MethodHandleDesc.of(Kind.STATIC, testClass, &quot;sm&quot;, &quot;(I)I&quot;);
220         MethodHandleDesc staticIMethodDesc = MethodHandleDesc.of(Kind.INTERFACE_STATIC, testInterface, &quot;sm&quot;, &quot;(I)I&quot;);
221         MethodHandleDesc instanceMethodDesc = MethodHandleDesc.of(Kind.VIRTUAL, testClass, &quot;m&quot;, &quot;(I)I&quot;);
222         MethodHandleDesc instanceIMethodDesc = MethodHandleDesc.of(Kind.INTERFACE_VIRTUAL, testInterface, &quot;m&quot;, &quot;(I)I&quot;);
223         MethodHandleDesc superMethodDesc = MethodHandleDesc.of(Kind.SPECIAL, testSuperclass, &quot;m&quot;, &quot;(I)I&quot;);
224         MethodHandleDesc superIMethodDesc = MethodHandleDesc.of(Kind.INTERFACE_SPECIAL, testInterface, &quot;m&quot;, &quot;(I)I&quot;);
225         MethodHandleDesc privateMethodDesc = MethodHandleDesc.of(Kind.SPECIAL, testClass, &quot;pm&quot;, &quot;(I)I&quot;);
226         MethodHandleDesc privateIMethodDesc = MethodHandleDesc.of(Kind.INTERFACE_SPECIAL, testInterface, &quot;pm&quot;, &quot;(I)I&quot;);
227         MethodHandleDesc privateStaticMethodDesc = MethodHandleDesc.of(Kind.STATIC, testClass, &quot;psm&quot;, &quot;(I)I&quot;);
228         MethodHandleDesc privateStaticIMethodDesc = MethodHandleDesc.of(Kind.INTERFACE_STATIC, testInterface, &quot;psm&quot;, &quot;(I)I&quot;);
229 
230         assertEquals(ctorDesc.invocationType(), MethodTypeDesc.of(testClass));
231         assertEquals(((DirectMethodHandleDesc) ctorDesc).lookupDescriptor(), &quot;()V&quot;);
232 
233         assertEquals(staticMethodDesc.invocationType().descriptorString(), &quot;(I)I&quot;);
234         assertEquals(((DirectMethodHandleDesc) staticMethodDesc).lookupDescriptor(), &quot;(I)I&quot;);
235 
236         assertEquals(instanceMethodDesc.invocationType().descriptorString(), &quot;(&quot; + testClass.descriptorString() + &quot;I)I&quot;);
237         assertEquals(((DirectMethodHandleDesc) instanceMethodDesc).lookupDescriptor(), &quot;(I)I&quot;);
238 
239         for (MethodHandleDesc r : List.of(ctorDesc, staticMethodDesc, staticIMethodDesc, instanceMethodDesc, instanceIMethodDesc))
240             testMethodHandleDesc(r);
241 
242         TestHelpers.TestClass instance = (TestHelpers.TestClass) ((MethodHandle)ctorDesc.resolveConstantDesc(LOOKUP)).invokeExact();
243         TestHelpers.TestClass instance2 = (TestHelpers.TestClass) ((MethodHandle)ctorDesc.resolveConstantDesc(TestHelpers.TestClass.LOOKUP)).invokeExact();
244         TestHelpers.TestInterface instanceI = instance;
245 
246         assertNotSame(instance, instance2);
247 
248         assertEquals(5, (int) ((MethodHandle)staticMethodDesc.resolveConstantDesc(LOOKUP)).invokeExact(5));
249         assertEquals(5, (int) ((MethodHandle)staticMethodDesc.resolveConstantDesc(TestHelpers.TestClass.LOOKUP)).invokeExact(5));
250         assertEquals(0, (int) ((MethodHandle)staticIMethodDesc.resolveConstantDesc(LOOKUP)).invokeExact(5));
251         assertEquals(0, (int) ((MethodHandle)staticIMethodDesc.resolveConstantDesc(TestHelpers.TestClass.LOOKUP)).invokeExact(5));
252 
253         assertEquals(5, (int) ((MethodHandle)instanceMethodDesc.resolveConstantDesc(LOOKUP)).invokeExact(instance, 5));
254         assertEquals(5, (int) ((MethodHandle)instanceMethodDesc.resolveConstantDesc(TestHelpers.TestClass.LOOKUP)).invokeExact(instance, 5));
255         assertEquals(5, (int) ((MethodHandle)instanceIMethodDesc.resolveConstantDesc(LOOKUP)).invokeExact(instanceI, 5));
256         assertEquals(5, (int) ((MethodHandle)instanceIMethodDesc.resolveConstantDesc(TestHelpers.TestClass.LOOKUP)).invokeExact(instanceI, 5));
257 
258         try { superMethodDesc.resolveConstantDesc(LOOKUP); fail(); }
259         catch (IllegalAccessException e) { /* expected */ }
260         assertEquals(-1, (int) ((MethodHandle)superMethodDesc.resolveConstantDesc(TestHelpers.TestClass.LOOKUP)).invokeExact(instance, 5));
261 
262         try { superIMethodDesc.resolveConstantDesc(LOOKUP); fail(); }
263         catch (IllegalAccessException e) { /* expected */ }
264         assertEquals(0, (int) ((MethodHandle)superIMethodDesc.resolveConstantDesc(TestHelpers.TestClass.LOOKUP)).invokeExact(instance, 5));
265 
266         try { privateMethodDesc.resolveConstantDesc(LOOKUP); fail(); }
267         catch (IllegalAccessException e) { /* expected */ }
268         assertEquals(5, (int) ((MethodHandle)privateMethodDesc.resolveConstantDesc(TestHelpers.TestClass.LOOKUP)).invokeExact(instance, 5));
269 
270         try { privateIMethodDesc.resolveConstantDesc(LOOKUP); fail(); }
271         catch (IllegalAccessException e) { /* expected */ }
272         assertEquals(0, (int) ((MethodHandle)privateIMethodDesc.resolveConstantDesc(TestHelpers.TestInterface.LOOKUP)).invokeExact(instanceI, 5));
273         assertEquals(0, (int) ((MethodHandle)privateIMethodDesc.resolveConstantDesc(TestHelpers.TestClass.LOOKUP)).invoke(instanceI, 5));
274 
275         try { privateStaticMethodDesc.resolveConstantDesc(LOOKUP); fail(); }
276         catch (IllegalAccessException e) { /* expected */ }
277         assertEquals(5, (int) ((MethodHandle)privateStaticMethodDesc.resolveConstantDesc(TestHelpers.TestClass.LOOKUP)).invokeExact(5));
278 
279         try { privateStaticIMethodDesc.resolveConstantDesc(LOOKUP); fail(); }
280         catch (IllegalAccessException e) { /* expected */ }
281         assertEquals(0, (int) ((MethodHandle)privateStaticIMethodDesc.resolveConstantDesc(TestHelpers.TestInterface.LOOKUP)).invokeExact(5));
282         assertEquals(0, (int) ((MethodHandle)privateStaticIMethodDesc.resolveConstantDesc(TestHelpers.TestClass.LOOKUP)).invokeExact(5));
283 
284         MethodHandleDesc staticSetterDesc = MethodHandleDesc.ofField(STATIC_SETTER, testClass, &quot;sf&quot;, CD_int);
285         MethodHandleDesc staticGetterDesc = MethodHandleDesc.ofField(STATIC_GETTER, testClass, &quot;sf&quot;, CD_int);
286         MethodHandleDesc staticGetterIDesc = MethodHandleDesc.ofField(STATIC_GETTER, testInterface, &quot;sf&quot;, CD_int);
287         MethodHandleDesc setterDesc = MethodHandleDesc.ofField(SETTER, testClass, &quot;f&quot;, CD_int);
288         MethodHandleDesc getterDesc = MethodHandleDesc.ofField(GETTER, testClass, &quot;f&quot;, CD_int);
289 
290         for (MethodHandleDesc r : List.of(staticSetterDesc, staticGetterDesc, staticGetterIDesc, setterDesc, getterDesc))
291             testMethodHandleDesc(r);
292 
293         ((MethodHandle)staticSetterDesc.resolveConstantDesc(LOOKUP)).invokeExact(6); assertEquals(TestHelpers.TestClass.sf, 6);
294         assertEquals(6, (int) ((MethodHandle)staticGetterDesc.resolveConstantDesc(LOOKUP)).invokeExact());
295         assertEquals(6, (int) ((MethodHandle)staticGetterDesc.resolveConstantDesc(TestHelpers.TestClass.LOOKUP)).invokeExact());
296         ((MethodHandle)staticSetterDesc.resolveConstantDesc(TestHelpers.TestClass.LOOKUP)).invokeExact(7); assertEquals(TestHelpers.TestClass.sf, 7);
297         assertEquals(7, (int) ((MethodHandle)staticGetterDesc.resolveConstantDesc(LOOKUP)).invokeExact());
298         assertEquals(7, (int) ((MethodHandle)staticGetterDesc.resolveConstantDesc(TestHelpers.TestClass.LOOKUP)).invokeExact());
299 
300         assertEquals(3, (int) ((MethodHandle)staticGetterIDesc.resolveConstantDesc(LOOKUP)).invokeExact());
301         assertEquals(3, (int) ((MethodHandle)staticGetterIDesc.resolveConstantDesc(TestHelpers.TestClass.LOOKUP)).invokeExact());
302 
303         ((MethodHandle)setterDesc.resolveConstantDesc(LOOKUP)).invokeExact(instance, 6); assertEquals(instance.f, 6);
304         assertEquals(6, (int) ((MethodHandle)getterDesc.resolveConstantDesc(LOOKUP)).invokeExact(instance));
305         assertEquals(6, (int) ((MethodHandle)getterDesc.resolveConstantDesc(TestHelpers.TestClass.LOOKUP)).invokeExact(instance));
306         ((MethodHandle)setterDesc.resolveConstantDesc(TestHelpers.TestClass.LOOKUP)).invokeExact(instance, 7); assertEquals(instance.f, 7);
307         assertEquals(7, (int) ((MethodHandle)getterDesc.resolveConstantDesc(LOOKUP)).invokeExact(instance));
308         assertEquals(7, (int) ((MethodHandle)getterDesc.resolveConstantDesc(TestHelpers.TestClass.LOOKUP)).invokeExact(instance));
309     }
310 
311     private void assertBadArgs(Supplier&lt;MethodHandleDesc&gt; supplier, String s) {
312         try {
313             MethodHandleDesc r = supplier.get();
314             fail(&quot;Expected failure for &quot; + s);
315         }
316         catch (IllegalArgumentException e) {
317             // succeed
318         }
319     }
320 
321     public void testBadFieldMHs() {
322         List&lt;String&gt; badGetterDescs = List.of(&quot;()V&quot;, &quot;(Ljava/lang/Object;)V&quot;, &quot;(I)I&quot;, &quot;(Ljava/lang/Object;I)I&quot;);
323         List&lt;String&gt; badStaticGetterDescs = List.of(&quot;()V&quot;, &quot;(Ljava/lang/Object;)I&quot;, &quot;(I)I&quot;, &quot;(Ljava/lang/Object;I)I&quot;);
324         List&lt;String&gt; badSetterDescs = List.of(&quot;()V&quot;, &quot;(I)V&quot;, &quot;(Ljava/lang/Object;)V&quot;, &quot;(Ljava/lang/Object;I)I&quot;, &quot;(Ljava/lang/Object;II)V&quot;);
325         List&lt;String&gt; badStaticSetterDescs = List.of(&quot;()V&quot;, &quot;(II)V&quot;, &quot;()I&quot;);
326 
327         badGetterDescs.forEach(s -&gt; assertBadArgs(() -&gt; MethodHandleDesc.of(GETTER, helperHolderClass, &quot;x&quot;, s), s));
328         badSetterDescs.forEach(s -&gt; assertBadArgs(() -&gt; MethodHandleDesc.of(SETTER, helperHolderClass, &quot;x&quot;, s), s));
329         badStaticGetterDescs.forEach(s -&gt; assertBadArgs(() -&gt; MethodHandleDesc.of(STATIC_GETTER, helperHolderClass, &quot;x&quot;, s), s));
330         badStaticSetterDescs.forEach(s -&gt; assertBadArgs(() -&gt; MethodHandleDesc.of(STATIC_SETTER, helperHolderClass, &quot;x&quot;, s), s));
331     }
332 
333     @Test(expectedExceptions = IllegalArgumentException.class)
334     public void testBadOwners() {
335         MethodHandleDesc.ofMethod(VIRTUAL, ClassDesc.ofDescriptor(&quot;I&quot;), &quot;x&quot;, MethodTypeDesc.ofDescriptor(&quot;()I&quot;));
336     }
337 
338     public void testSymbolicDescsConstants() throws ReflectiveOperationException {
339         int tested = 0;
340         Field[] fields = ConstantDescs.class.getDeclaredFields();
341         for (Field f : fields) {
342             try {
343                 if (f.getType().equals(DirectMethodHandleDesc.class)
344                     &amp;&amp; ((f.getModifiers() &amp; Modifier.STATIC) != 0)
345                     &amp;&amp; ((f.getModifiers() &amp; Modifier.PUBLIC) != 0)) {
346                     MethodHandleDesc r = (MethodHandleDesc) f.get(null);
347                     MethodHandle m = (MethodHandle)r.resolveConstantDesc(MethodHandles.lookup());
348                     testMethodHandleDesc(r, m);
349                     ++tested;
350                 }
351             }
352             catch (Throwable e) {
353                 fail(&quot;Error testing field &quot; + f.getName(), e);
354             }
355         }
356 
357         assertTrue(tested &gt; 0);
358     }
359 
360     public void testKind() {
361         for (Kind k : Kind.values()) {
362             assertEquals(Kind.valueOf(k.refKind, k.isInterface), k);
363         }
364     }
365 }
<a name="4" id="anc4"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="4" type="hidden" />
</body>
</html>
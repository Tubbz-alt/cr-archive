<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff test/jdk/java/lang/constant/MethodTypeDescTest.java</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
<body>
<center><a href="MethodHandleDescTest.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="../instrument/RedefineAddDeleteMethod/DeleteMethodHandle/MethodHandleDeletedMethod.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>test/jdk/java/lang/constant/MethodTypeDescTest.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2018, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
</pre>
<hr />
<pre>
 86         assertEquals(descriptor, mtDesc.descriptorString());
 87         assertEquals(returnType, mtDesc.returnType());
 88         assertEquals(paramTypes, mtDesc.parameterArray());
 89         assertEquals(Arrays.asList(paramTypes), mtDesc.parameterList());
 90         assertEquals(paramTypes.length, mtDesc.parameterCount());
 91         for (int i=0; i&lt;paramTypes.length; i++)
 92             assertEquals(paramTypes[i], mtDesc.parameterType(i));
 93 
 94         // Consistency between MT and MTDesc
 95         MethodType mt = MethodType.fromMethodDescriptorString(descriptor, null);
 96         testMethodTypeDesc(mtDesc, mt);
 97 
 98         // changeReturnType
 99         for (String r : returnDescs) {
100             ClassDesc rc = ClassDesc.ofDescriptor(r);
101             MethodTypeDesc newDesc = mtDesc.changeReturnType(rc);
102             assertEquals(newDesc, MethodTypeDesc.of(rc, paramTypes));
103             testMethodTypeDesc(newDesc, mt.changeReturnType((Class&lt;?&gt;)rc.resolveConstantDesc(LOOKUP)));
104         }
105 








106         // changeParamType
107         for (int i=0; i&lt;paramTypes.length; i++) {
108             for (String p : paramDescs) {
109                 ClassDesc pc = ClassDesc.ofDescriptor(p);
110                 ClassDesc[] ps = paramTypes.clone();
111                 ps[i] = pc;
112                 MethodTypeDesc newDesc = mtDesc.changeParameterType(i, pc);
113                 assertEquals(newDesc, MethodTypeDesc.of(returnType, ps));
114                 testMethodTypeDesc(newDesc, mt.changeParameterType(i, (Class&lt;?&gt;)pc.resolveConstantDesc(LOOKUP)));
115             }
116         }
117 
118         // dropParamType
119         for (int i=0; i&lt;paramTypes.length; i++) {
120             int k = i;
121             ClassDesc[] ps = IntStream.range(0, paramTypes.length)
122                                       .filter(j -&gt; j != k)
123                                       .mapToObj(j -&gt; paramTypes[j])
124                                       .toArray(ClassDesc[]::new);
125             MethodTypeDesc newDesc = mtDesc.dropParameterTypes(i, i + 1);
</pre>
<hr />
<pre>
146     }
147 
148     private void badInsertParametersTypes(ClassDesc returnType, String... paramDescTypes) {
149         ClassDesc[] paramTypes =
150                 IntStream.rangeClosed(0, paramDescTypes.length - 1)
151                         .mapToObj(i -&gt; ClassDesc.ofDescriptor(paramDescTypes[i])).toArray(ClassDesc[]::new);
152         MethodTypeDesc mtDesc = MethodTypeDesc.of(returnType, paramTypes);
153         try {
154             MethodTypeDesc newDesc = mtDesc.insertParameterTypes(-1, paramTypes);
155             fail(&quot;pos &lt; 0 should have failed&quot;);
156         } catch (IndexOutOfBoundsException ex) {
157             // good
158         }
159 
160         try {
161             MethodTypeDesc newDesc = mtDesc.insertParameterTypes(paramTypes.length + 1, paramTypes);
162             fail(&quot;pos &gt; current arguments length should have failed&quot;);
163         } catch (IndexOutOfBoundsException ex) {
164             // good
165         }




























166     }
167 
168     private void badDropParametersTypes(ClassDesc returnType, String... paramDescTypes) {
169         ClassDesc[] paramTypes =
170                 IntStream.rangeClosed(0, paramDescTypes.length - 1)
171                         .mapToObj(i -&gt; ClassDesc.ofDescriptor(paramDescTypes[i])).toArray(ClassDesc[]::new);
172         MethodTypeDesc mtDesc = MethodTypeDesc.of(returnType, paramTypes);
173         try {
174             MethodTypeDesc newDesc = mtDesc.dropParameterTypes(-1, 0);
175             fail(&quot;start index &lt; 0 should have failed&quot;);
176         } catch (IndexOutOfBoundsException ex) {
177             // good
178         }
179 
180         try {
181             MethodTypeDesc newDesc = mtDesc.dropParameterTypes(paramTypes.length, 0);
182             fail(&quot;start index = arguments.length should have failed&quot;);
183         } catch (IndexOutOfBoundsException ex) {
184             // good
185         }
186 
187         try {
188             MethodTypeDesc newDesc = mtDesc.dropParameterTypes(paramTypes.length + 1, 0);
189             fail(&quot;start index &gt; arguments.length should have failed&quot;);
190         } catch (IndexOutOfBoundsException ex) {
191             // good
192         }
193 
194         try {
195             MethodTypeDesc newDesc = mtDesc.dropParameterTypes(0, paramTypes.length + 1);
196             fail(&quot;end index &gt; arguments.length should have failed&quot;);
197         } catch (IndexOutOfBoundsException ex) {
198             // good
199         }
200 
201         try {
202             MethodTypeDesc newDesc = mtDesc.dropParameterTypes(1, 0);
203             fail(&quot;start index &gt; end index should have failed&quot;);
<span class="line-modified">204         } catch (IllegalArgumentException ex) {</span>
205             // good
206         }
207     }
208 
209     public void testMethodTypeDesc() throws ReflectiveOperationException {
210         for (String r : returnDescs) {
211             assertMethodType(ClassDesc.ofDescriptor(r));
212             for (String p1 : paramDescs) {
213                 assertMethodType(ClassDesc.ofDescriptor(r), ClassDesc.ofDescriptor(p1));
214                 for (String p2 : paramDescs) {
215                     assertMethodType(ClassDesc.ofDescriptor(r), ClassDesc.ofDescriptor(p1), ClassDesc.ofDescriptor(p2));
216                 }
217             }
218         }
219     }
220 
221     public void testBadMethodTypeRefs() {
222         List&lt;String&gt; badDescriptors = List.of(&quot;()II&quot;, &quot;()I;&quot;, &quot;(I;)&quot;, &quot;(I)&quot;, &quot;()L&quot;, &quot;(V)V&quot;,
223                                               &quot;(java.lang.String)V&quot;, &quot;()[]&quot;, &quot;(Ljava/lang/String)V&quot;,
224                                               &quot;(Ljava.lang.String;)V&quot;, &quot;(java/lang/String)V&quot;);
225 
226         for (String d : badDescriptors) {
227             try {
228                 MethodTypeDesc r = MethodTypeDesc.ofDescriptor(d);
229                 fail(d);
230             }
231             catch (IllegalArgumentException e) {
232                 // good
233             }
234         }
235 








236         // try with void arguments, this will stress another code path in particular
237         // ConstantMethodTypeDesc::init
238         try {
239             MethodTypeDesc r = MethodTypeDesc.of(CD_int, CD_void);
240             fail(&quot;can&#39;t reach here&quot;);
241         }
242         catch (IllegalArgumentException e) {
243             // good
244         }


















245     }
246 }
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2018, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
</pre>
<hr />
<pre>
 86         assertEquals(descriptor, mtDesc.descriptorString());
 87         assertEquals(returnType, mtDesc.returnType());
 88         assertEquals(paramTypes, mtDesc.parameterArray());
 89         assertEquals(Arrays.asList(paramTypes), mtDesc.parameterList());
 90         assertEquals(paramTypes.length, mtDesc.parameterCount());
 91         for (int i=0; i&lt;paramTypes.length; i++)
 92             assertEquals(paramTypes[i], mtDesc.parameterType(i));
 93 
 94         // Consistency between MT and MTDesc
 95         MethodType mt = MethodType.fromMethodDescriptorString(descriptor, null);
 96         testMethodTypeDesc(mtDesc, mt);
 97 
 98         // changeReturnType
 99         for (String r : returnDescs) {
100             ClassDesc rc = ClassDesc.ofDescriptor(r);
101             MethodTypeDesc newDesc = mtDesc.changeReturnType(rc);
102             assertEquals(newDesc, MethodTypeDesc.of(rc, paramTypes));
103             testMethodTypeDesc(newDesc, mt.changeReturnType((Class&lt;?&gt;)rc.resolveConstantDesc(LOOKUP)));
104         }
105 
<span class="line-added">106         // try with null parameter</span>
<span class="line-added">107         try {</span>
<span class="line-added">108             MethodTypeDesc newDesc = mtDesc.changeReturnType(null);</span>
<span class="line-added">109             fail(&quot;should fail with NPE&quot;);</span>
<span class="line-added">110         } catch (NullPointerException ex) {</span>
<span class="line-added">111             // good</span>
<span class="line-added">112         }</span>
<span class="line-added">113 </span>
114         // changeParamType
115         for (int i=0; i&lt;paramTypes.length; i++) {
116             for (String p : paramDescs) {
117                 ClassDesc pc = ClassDesc.ofDescriptor(p);
118                 ClassDesc[] ps = paramTypes.clone();
119                 ps[i] = pc;
120                 MethodTypeDesc newDesc = mtDesc.changeParameterType(i, pc);
121                 assertEquals(newDesc, MethodTypeDesc.of(returnType, ps));
122                 testMethodTypeDesc(newDesc, mt.changeParameterType(i, (Class&lt;?&gt;)pc.resolveConstantDesc(LOOKUP)));
123             }
124         }
125 
126         // dropParamType
127         for (int i=0; i&lt;paramTypes.length; i++) {
128             int k = i;
129             ClassDesc[] ps = IntStream.range(0, paramTypes.length)
130                                       .filter(j -&gt; j != k)
131                                       .mapToObj(j -&gt; paramTypes[j])
132                                       .toArray(ClassDesc[]::new);
133             MethodTypeDesc newDesc = mtDesc.dropParameterTypes(i, i + 1);
</pre>
<hr />
<pre>
154     }
155 
156     private void badInsertParametersTypes(ClassDesc returnType, String... paramDescTypes) {
157         ClassDesc[] paramTypes =
158                 IntStream.rangeClosed(0, paramDescTypes.length - 1)
159                         .mapToObj(i -&gt; ClassDesc.ofDescriptor(paramDescTypes[i])).toArray(ClassDesc[]::new);
160         MethodTypeDesc mtDesc = MethodTypeDesc.of(returnType, paramTypes);
161         try {
162             MethodTypeDesc newDesc = mtDesc.insertParameterTypes(-1, paramTypes);
163             fail(&quot;pos &lt; 0 should have failed&quot;);
164         } catch (IndexOutOfBoundsException ex) {
165             // good
166         }
167 
168         try {
169             MethodTypeDesc newDesc = mtDesc.insertParameterTypes(paramTypes.length + 1, paramTypes);
170             fail(&quot;pos &gt; current arguments length should have failed&quot;);
171         } catch (IndexOutOfBoundsException ex) {
172             // good
173         }
<span class="line-added">174 </span>
<span class="line-added">175         try {</span>
<span class="line-added">176             ClassDesc[] newParamTypes = new ClassDesc[1];</span>
<span class="line-added">177             newParamTypes[0] = CD_void;</span>
<span class="line-added">178             MethodTypeDesc newDesc = MethodTypeDesc.of(returnType, CD_int);</span>
<span class="line-added">179             newDesc = newDesc.insertParameterTypes(0, newParamTypes);</span>
<span class="line-added">180             fail(&quot;shouldn&#39;t allow parameters with class descriptor CD_void&quot;);</span>
<span class="line-added">181         } catch (IllegalArgumentException ex) {</span>
<span class="line-added">182             // good</span>
<span class="line-added">183         }</span>
<span class="line-added">184 </span>
<span class="line-added">185         try {</span>
<span class="line-added">186             MethodTypeDesc newDesc = MethodTypeDesc.of(returnType, CD_int);</span>
<span class="line-added">187             newDesc = newDesc.insertParameterTypes(0, null);</span>
<span class="line-added">188             fail(&quot;should fail with NPE&quot;);</span>
<span class="line-added">189         } catch (NullPointerException ex) {</span>
<span class="line-added">190             // good</span>
<span class="line-added">191         }</span>
<span class="line-added">192 </span>
<span class="line-added">193         try {</span>
<span class="line-added">194             ClassDesc[] newParamTypes = new ClassDesc[1];</span>
<span class="line-added">195             newParamTypes[0] = null;</span>
<span class="line-added">196             MethodTypeDesc newDesc = MethodTypeDesc.of(returnType, CD_int);</span>
<span class="line-added">197             newDesc = newDesc.insertParameterTypes(0, newParamTypes);</span>
<span class="line-added">198             fail(&quot;should fail with NPE&quot;);</span>
<span class="line-added">199         } catch (NullPointerException ex) {</span>
<span class="line-added">200             // good</span>
<span class="line-added">201         }</span>
202     }
203 
204     private void badDropParametersTypes(ClassDesc returnType, String... paramDescTypes) {
205         ClassDesc[] paramTypes =
206                 IntStream.rangeClosed(0, paramDescTypes.length - 1)
207                         .mapToObj(i -&gt; ClassDesc.ofDescriptor(paramDescTypes[i])).toArray(ClassDesc[]::new);
208         MethodTypeDesc mtDesc = MethodTypeDesc.of(returnType, paramTypes);
209         try {
210             MethodTypeDesc newDesc = mtDesc.dropParameterTypes(-1, 0);
211             fail(&quot;start index &lt; 0 should have failed&quot;);
212         } catch (IndexOutOfBoundsException ex) {
213             // good
214         }
215 
216         try {
217             MethodTypeDesc newDesc = mtDesc.dropParameterTypes(paramTypes.length, 0);
218             fail(&quot;start index = arguments.length should have failed&quot;);
219         } catch (IndexOutOfBoundsException ex) {
220             // good
221         }
222 
223         try {
224             MethodTypeDesc newDesc = mtDesc.dropParameterTypes(paramTypes.length + 1, 0);
225             fail(&quot;start index &gt; arguments.length should have failed&quot;);
226         } catch (IndexOutOfBoundsException ex) {
227             // good
228         }
229 
230         try {
231             MethodTypeDesc newDesc = mtDesc.dropParameterTypes(0, paramTypes.length + 1);
232             fail(&quot;end index &gt; arguments.length should have failed&quot;);
233         } catch (IndexOutOfBoundsException ex) {
234             // good
235         }
236 
237         try {
238             MethodTypeDesc newDesc = mtDesc.dropParameterTypes(1, 0);
239             fail(&quot;start index &gt; end index should have failed&quot;);
<span class="line-modified">240         } catch (IndexOutOfBoundsException ex) {</span>
241             // good
242         }
243     }
244 
245     public void testMethodTypeDesc() throws ReflectiveOperationException {
246         for (String r : returnDescs) {
247             assertMethodType(ClassDesc.ofDescriptor(r));
248             for (String p1 : paramDescs) {
249                 assertMethodType(ClassDesc.ofDescriptor(r), ClassDesc.ofDescriptor(p1));
250                 for (String p2 : paramDescs) {
251                     assertMethodType(ClassDesc.ofDescriptor(r), ClassDesc.ofDescriptor(p1), ClassDesc.ofDescriptor(p2));
252                 }
253             }
254         }
255     }
256 
257     public void testBadMethodTypeRefs() {
258         List&lt;String&gt; badDescriptors = List.of(&quot;()II&quot;, &quot;()I;&quot;, &quot;(I;)&quot;, &quot;(I)&quot;, &quot;()L&quot;, &quot;(V)V&quot;,
259                                               &quot;(java.lang.String)V&quot;, &quot;()[]&quot;, &quot;(Ljava/lang/String)V&quot;,
260                                               &quot;(Ljava.lang.String;)V&quot;, &quot;(java/lang/String)V&quot;);
261 
262         for (String d : badDescriptors) {
263             try {
264                 MethodTypeDesc r = MethodTypeDesc.ofDescriptor(d);
265                 fail(d);
266             }
267             catch (IllegalArgumentException e) {
268                 // good
269             }
270         }
271 
<span class="line-added">272         // try with null argument</span>
<span class="line-added">273         try {</span>
<span class="line-added">274             MethodTypeDesc r = MethodTypeDesc.ofDescriptor(null);</span>
<span class="line-added">275             fail(&quot;should fail with NPE&quot;);</span>
<span class="line-added">276         } catch (NullPointerException ex) {</span>
<span class="line-added">277             // good</span>
<span class="line-added">278         }</span>
<span class="line-added">279 </span>
280         // try with void arguments, this will stress another code path in particular
281         // ConstantMethodTypeDesc::init
282         try {
283             MethodTypeDesc r = MethodTypeDesc.of(CD_int, CD_void);
284             fail(&quot;can&#39;t reach here&quot;);
285         }
286         catch (IllegalArgumentException e) {
287             // good
288         }
<span class="line-added">289 </span>
<span class="line-added">290         try {</span>
<span class="line-added">291             MethodTypeDesc r = MethodTypeDesc.of(CD_int, null);</span>
<span class="line-added">292             fail(&quot;ClassDesc array should not be null&quot;);</span>
<span class="line-added">293         }</span>
<span class="line-added">294         catch (NullPointerException e) {</span>
<span class="line-added">295             // good</span>
<span class="line-added">296         }</span>
<span class="line-added">297 </span>
<span class="line-added">298         try {</span>
<span class="line-added">299             ClassDesc[] paramDescs = new ClassDesc[1];</span>
<span class="line-added">300             paramDescs[0] = null;</span>
<span class="line-added">301             MethodTypeDesc r = MethodTypeDesc.of(CD_int, paramDescs);</span>
<span class="line-added">302             fail(&quot;ClassDesc should not be null&quot;);</span>
<span class="line-added">303         }</span>
<span class="line-added">304         catch (NullPointerException e) {</span>
<span class="line-added">305             // good</span>
<span class="line-added">306         }</span>
307     }
308 }
</pre>
</td>
</tr>
</table>
<center><a href="MethodHandleDescTest.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="../instrument/RedefineAddDeleteMethod/DeleteMethodHandle/MethodHandleDeletedMethod.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
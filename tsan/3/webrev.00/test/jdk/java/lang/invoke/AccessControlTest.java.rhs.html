<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames test/jdk/java/lang/invoke/AccessControlTest.java</title>
    <link rel="stylesheet" href="../../../../../style.css" />
    <script type="text/javascript" src="../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
<a name="1" id="anc1"></a><span class="line-modified">  2  * Copyright (c) 2012, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 /* @test
 25  * @summary test access checking by java.lang.invoke.MethodHandles.Lookup
 26  * @compile AccessControlTest.java AccessControlTest_subpkg/Acquaintance_remote.java
 27  * @run testng/othervm test.java.lang.invoke.AccessControlTest
 28  */
 29 
 30 package test.java.lang.invoke;
 31 
 32 import java.lang.invoke.*;
 33 import java.lang.reflect.*;
 34 import java.lang.reflect.Modifier;
 35 import java.util.*;
<a name="2" id="anc2"></a>
 36 import org.testng.annotations.*;
 37 
 38 import static java.lang.invoke.MethodHandles.*;
 39 import static java.lang.invoke.MethodHandles.Lookup.*;
 40 import static java.lang.invoke.MethodType.*;
 41 import static org.testng.Assert.*;
 42 
 43 import test.java.lang.invoke.AccessControlTest_subpkg.Acquaintance_remote;
 44 
 45 
 46 /**
 47  * Test many combinations of Lookup access and cross-class lookupStatic.
 48  * @author jrose
 49  */
 50 public class AccessControlTest {
 51     static final Class&lt;?&gt; THIS_CLASS = AccessControlTest.class;
 52     // How much output?
 53     static int verbosity = 0;
 54     static {
 55         String vstr = System.getProperty(THIS_CLASS.getSimpleName()+&quot;.verbosity&quot;);
 56         if (vstr == null)
 57             vstr = System.getProperty(THIS_CLASS.getName()+&quot;.verbosity&quot;);
 58         if (vstr != null)  verbosity = Integer.parseInt(vstr);
 59     }
 60 
 61     private class LookupCase implements Comparable&lt;LookupCase&gt; {
 62         final Lookup   lookup;
 63         final Class&lt;?&gt; lookupClass;
<a name="3" id="anc3"></a><span class="line-added"> 64         final Class&lt;?&gt; prevLookupClass;</span>
 65         final int      lookupModes;
 66         public LookupCase(Lookup lookup) {
 67             this.lookup = lookup;
 68             this.lookupClass = lookup.lookupClass();
<a name="4" id="anc4"></a><span class="line-added"> 69             this.prevLookupClass = lookup.previousLookupClass();</span>
 70             this.lookupModes = lookup.lookupModes();
<a name="5" id="anc5"></a><span class="line-added"> 71 </span>
 72             assert(lookupString().equals(lookup.toString()));
 73             numberOf(lookupClass().getClassLoader()); // assign CL#
 74         }
<a name="6" id="anc6"></a><span class="line-modified"> 75         public LookupCase(Class&lt;?&gt; lookupClass, Class&lt;?&gt; prevLookupClass, int lookupModes) {</span>
 76             this.lookup = null;
 77             this.lookupClass = lookupClass;
<a name="7" id="anc7"></a><span class="line-added"> 78             this.prevLookupClass = prevLookupClass;</span>
 79             this.lookupModes = lookupModes;
 80             numberOf(lookupClass().getClassLoader()); // assign CL#
 81         }
 82 
<a name="8" id="anc8"></a><span class="line-modified"> 83         public final Class&lt;?&gt; lookupClass()     { return lookupClass; }</span>
<span class="line-modified"> 84         public final Class&lt;?&gt; prevLookupClass() { return prevLookupClass; }</span>
<span class="line-added"> 85         public final int      lookupModes()     { return lookupModes; }</span>
 86 
 87         public Lookup lookup() { lookup.getClass(); return lookup; }
 88 
 89         @Override
 90         public int compareTo(LookupCase that) {
 91             Class&lt;?&gt; c1 = this.lookupClass();
 92             Class&lt;?&gt; c2 = that.lookupClass();
<a name="9" id="anc9"></a><span class="line-added"> 93             Class&lt;?&gt; p1 = this.prevLookupClass();</span>
<span class="line-added"> 94             Class&lt;?&gt; p2 = that.prevLookupClass();</span>
 95             if (c1 != c2) {
 96                 int cmp = c1.getName().compareTo(c2.getName());
 97                 if (cmp != 0)  return cmp;
 98                 cmp = numberOf(c1.getClassLoader()) - numberOf(c2.getClassLoader());
 99                 assert(cmp != 0);
100                 return cmp;
<a name="10" id="anc10"></a><span class="line-added">101             } else if (p1 != p2){</span>
<span class="line-added">102                 if (p1 == null)</span>
<span class="line-added">103                     return 1;</span>
<span class="line-added">104                 else if (p2 == null)</span>
<span class="line-added">105                     return -1;</span>
<span class="line-added">106                 int cmp = p1.getName().compareTo(p2.getName());</span>
<span class="line-added">107                 if (cmp != 0)  return cmp;</span>
<span class="line-added">108                 cmp = numberOf(p1.getClassLoader()) - numberOf(p2.getClassLoader());</span>
<span class="line-added">109                 assert(cmp != 0);</span>
<span class="line-added">110                 return cmp;</span>
111             }
112             return -(this.lookupModes() - that.lookupModes());
113         }
114 
115         @Override
116         public boolean equals(Object that) {
117             return (that instanceof LookupCase &amp;&amp; equals((LookupCase)that));
118         }
119         public boolean equals(LookupCase that) {
120             return (this.lookupClass() == that.lookupClass() &amp;&amp;
<a name="11" id="anc11"></a><span class="line-added">121                     this.prevLookupClass() == that.prevLookupClass() &amp;&amp;</span>
122                     this.lookupModes() == that.lookupModes());
123         }
124 
125         @Override
126         public int hashCode() {
127             return lookupClass().hashCode() + (lookupModes() * 31);
128         }
129 
130         /** Simulate all assertions in the spec. for Lookup.toString. */
131         private String lookupString() {
132             String name = lookupClass.getName();
<a name="12" id="anc12"></a><span class="line-added">133             if (prevLookupClass != null)</span>
<span class="line-added">134                 name += &quot;/&quot; + prevLookupClass.getName();</span>
135             String suffix = &quot;&quot;;
136             if (lookupModes == 0)
137                 suffix = &quot;/noaccess&quot;;
138             else if (lookupModes == PUBLIC)
139                 suffix = &quot;/public&quot;;
<a name="13" id="anc13"></a><span class="line-modified">140              else if (lookupModes == UNCONDITIONAL)</span>
141                 suffix = &quot;/publicLookup&quot;;
142             else if (lookupModes == (PUBLIC|MODULE))
143                 suffix = &quot;/module&quot;;
<a name="14" id="anc14"></a><span class="line-modified">144             else if (lookupModes == (PUBLIC|PACKAGE)</span>
<span class="line-added">145                      || lookupModes == (PUBLIC|MODULE|PACKAGE))</span>
146                 suffix = &quot;/package&quot;;
<a name="15" id="anc15"></a><span class="line-modified">147             else if (lookupModes == (PUBLIC|PACKAGE|PRIVATE)</span>
<span class="line-added">148                     || lookupModes == (PUBLIC|MODULE|PACKAGE|PRIVATE))</span>
149                 suffix = &quot;/private&quot;;
<a name="16" id="anc16"></a><span class="line-modified">150             else if (lookupModes == (PUBLIC|PACKAGE|PRIVATE|PROTECTED)</span>
<span class="line-added">151                      || lookupModes == (PUBLIC|MODULE|PACKAGE|PRIVATE|PROTECTED))</span>
152                 suffix = &quot;&quot;;
153             else
154                 suffix = &quot;/#&quot;+Integer.toHexString(lookupModes);
155             return name+suffix;
156         }
157 
158         /** Simulate all assertions from the spec. for Lookup.in:
159          * &lt;hr&gt;
160          * Creates a lookup on the specified new lookup class.
161          * [A1] The resulting object will report the specified
162          * class as its own {@link #lookupClass lookupClass}.
<a name="17" id="anc17"></a>
163          * [A2] However, the resulting {@code Lookup} object is guaranteed
164          * to have no more access capabilities than the original.
165          * In particular, access capabilities can be lost as follows:&lt;ul&gt;
<a name="18" id="anc18"></a><span class="line-modified">166          * [A3] If the new lookup class is in a different module from the old one,</span>
<span class="line-modified">167          * i.e. {@link #MODULE MODULE} access is lost.</span>
<span class="line-modified">168          * [A4] If the new lookup class is in a different package</span>
<span class="line-modified">169          * than the old one, protected and default (package) members will not be accessible,</span>
<span class="line-modified">170          * i.e. {@link #PROTECTED PROTECTED} and {@link #PACKAGE PACKAGE} access are lost.</span>
<span class="line-modified">171          * [A5] If the new lookup class is not within the same package member</span>
<span class="line-modified">172          * as the old one, private members will not be accessible, and protected members</span>
<span class="line-modified">173          * will not be accessible by virtue of inheritance,</span>
<span class="line-modified">174          * i.e. {@link #PRIVATE PRIVATE} access is lost.</span>

175          * (Protected members may continue to be accessible because of package sharing.)
<a name="19" id="anc19"></a><span class="line-modified">176          * [A6] If the new lookup class is not</span>
<span class="line-modified">177          * {@linkplain #accessClass(Class) accessible} to this lookup,</span>
<span class="line-modified">178          * then no members, not even public members, will be accessible</span>
<span class="line-modified">179          * i.e. all access modes are lost.</span>
<span class="line-modified">180          * [A7] If the new lookup class, the old lookup class and the previous lookup class</span>
<span class="line-modified">181          * are all in different modules i.e. teleporting to a third module,</span>
<span class="line-modified">182          * all access modes are lost.</span>
<span class="line-modified">183          * &lt;p&gt;</span>
<span class="line-added">184          * The new previous lookup class is chosen as follows:</span>
<span class="line-added">185          * [A8] If the new lookup object has {@link #UNCONDITIONAL UNCONDITIONAL} bit,</span>
<span class="line-added">186          * the new previous lookup class is {@code null}.</span>
<span class="line-added">187          * [A9] If the new lookup class is in the same module as the old lookup class,</span>
<span class="line-added">188          * the new previous lookup class is the old previous lookup class.</span>
<span class="line-added">189          * [A10] If the new lookup class is in a different module from the old lookup class,</span>
<span class="line-added">190          * the new previous lookup class is the the old lookup class.</span>
<span class="line-added">191          *</span>
192          * Other than the above cases, the new lookup will have the same
<a name="20" id="anc20"></a><span class="line-modified">193          * access capabilities as the original. [A11]</span>
194          * &lt;hr&gt;
195          */
196         public LookupCase in(Class&lt;?&gt; c2) {
197             Class&lt;?&gt; c1 = lookupClass();
<a name="21" id="anc21"></a><span class="line-modified">198             Module m1 = c1.getModule();</span>
<span class="line-added">199             Module m2 = c2.getModule();</span>
<span class="line-added">200             Module m0 = prevLookupClass() != null ? prevLookupClass.getModule() : c1.getModule();</span>
<span class="line-added">201             int modes1 = lookupModes();</span>
202             int changed = 0;
203             // for the purposes of access control then treat classes in different unnamed
204             // modules as being in the same module.
<a name="22" id="anc22"></a><span class="line-modified">205             boolean sameModule = (m1 == m2) ||</span>
<span class="line-modified">206                                  (!m1.isNamed() &amp;&amp; !m2.isNamed());</span>
207             boolean samePackage = (c1.getClassLoader() == c2.getClassLoader() &amp;&amp;
208                                    c1.getPackageName().equals(c2.getPackageName()));
209             boolean sameTopLevel = (topLevelClass(c1) == topLevelClass(c2));
210             boolean sameClass = (c1 == c2);
211             assert(samePackage  || !sameTopLevel);
212             assert(sameTopLevel || !sameClass);
213             boolean accessible = sameClass;
<a name="23" id="anc23"></a><span class="line-modified">214 </span>
<span class="line-modified">215             if ((modes1 &amp; PACKAGE) != 0)  accessible |= samePackage;</span>
<span class="line-modified">216             if ((modes1 &amp; PUBLIC ) != 0)  {</span>
<span class="line-modified">217                 if (isModuleAccessible(c2))</span>
<span class="line-modified">218                     accessible |= (c2.getModifiers() &amp; PUBLIC) != 0;</span>
<span class="line-modified">219                 else</span>
<span class="line-modified">220                     accessible = false;</span>
<span class="line-modified">221             }</span>
<span class="line-added">222             if ((modes1 &amp; UNCONDITIONAL) != 0) {</span>
<span class="line-added">223                 if (m2.isExported(c2.getPackageName()))</span>
<span class="line-added">224                     accessible |= (c2.getModifiers() &amp; PUBLIC) != 0;</span>
<span class="line-added">225                 else</span>
<span class="line-added">226                     accessible = false;</span>
227             }
228             if (!accessible) {
<a name="24" id="anc24"></a><span class="line-modified">229                 // no access to c2; lose all access.</span>
<span class="line-modified">230                 changed |= (PUBLIC|MODULE|PACKAGE|PRIVATE|PROTECTED|UNCONDITIONAL);  // [A6]</span>
<span class="line-added">231             }</span>
<span class="line-added">232             if (m2 != m1 &amp;&amp; m0 != m1) {</span>
<span class="line-added">233                 // hop to a third module; lose all access</span>
<span class="line-added">234                 changed |= (PUBLIC|MODULE|PACKAGE|PRIVATE|PROTECTED);  // [A7]</span>
<span class="line-added">235             }</span>
<span class="line-added">236             if (!sameModule) {</span>
<span class="line-added">237                 changed |= MODULE;  // [A3]</span>
238             }
239             if (!samePackage) {
240                 // Different package; loose PACKAGE and lower access.
<a name="25" id="anc25"></a><span class="line-modified">241                 changed |= (PACKAGE|PRIVATE|PROTECTED);  // [A4]</span>
242             }
243             if (!sameTopLevel) {
244                 // Different top-level class.  Lose PRIVATE and PROTECTED access.
<a name="26" id="anc26"></a><span class="line-modified">245                 changed |= (PRIVATE|PROTECTED);  // [A5]</span>
246             }
<a name="27" id="anc27"></a><span class="line-modified">247             if (sameClass) {</span>
<span class="line-modified">248                 assert(changed == 0);       // [A11] (no deprivation if same class)</span>


249             }
<a name="28" id="anc28"></a><span class="line-modified">250 </span>
<span class="line-modified">251             if (accessible)  assert((changed &amp; PUBLIC) == 0);</span>
<span class="line-modified">252             int modes2 = modes1 &amp; ~changed;</span>
<span class="line-modified">253             Class&lt;?&gt; plc = (m1 == m2) ? prevLookupClass() : c1; // [A9] [A10]</span>
<span class="line-modified">254             if ((modes1 &amp; UNCONDITIONAL) != 0) plc = null;      // [A8]</span>
<span class="line-added">255             LookupCase l2 = new LookupCase(c2, plc, modes2);</span>
<span class="line-added">256             assert(l2.lookupClass() == c2);         // [A1]</span>
<span class="line-added">257             assert((modes1 | modes2) == modes1);    // [A2] (no elevation of access)</span>
<span class="line-added">258             assert(l2.prevLookupClass() == null || (modes2 &amp; MODULE) == 0);</span>
<span class="line-added">259             return l2;</span>
<span class="line-added">260         }</span>
<span class="line-added">261 </span>
<span class="line-added">262         LookupCase dropLookupMode(int modeToDrop) {</span>
<span class="line-added">263             int oldModes = lookupModes();</span>
<span class="line-added">264             int newModes = oldModes &amp; ~(modeToDrop | PROTECTED);</span>
<span class="line-added">265             switch (modeToDrop) {</span>
<span class="line-added">266                 case PUBLIC: newModes &amp;= ~(MODULE|PACKAGE|PROTECTED|PRIVATE); break;</span>
<span class="line-added">267                 case MODULE: newModes &amp;= ~(PACKAGE|PRIVATE); break;</span>
<span class="line-added">268                 case PACKAGE: newModes &amp;= ~(PRIVATE); break;</span>
<span class="line-added">269                 case PROTECTED:</span>
<span class="line-added">270                 case PRIVATE:</span>
<span class="line-added">271                 case UNCONDITIONAL: break;</span>
<span class="line-added">272                 default: throw new IllegalArgumentException(modeToDrop + &quot; is not a valid mode to drop&quot;);</span>
<span class="line-added">273             }</span>
<span class="line-added">274             if (newModes == oldModes) return this;  // return self if no change</span>
<span class="line-added">275             LookupCase l2 = new LookupCase(lookupClass(), prevLookupClass(), newModes);</span>
<span class="line-added">276             assert((oldModes | newModes) == oldModes);    // [A2] (no elevation of access)</span>
<span class="line-added">277             assert(l2.prevLookupClass() == null || (newModes &amp; MODULE) == 0);</span>
278             return l2;
279         }
280 
<a name="29" id="anc29"></a><span class="line-added">281         boolean isModuleAccessible(Class&lt;?&gt; c) {</span>
<span class="line-added">282             Module m1 = lookupClass().getModule();</span>
<span class="line-added">283             Module m2 = c.getModule();</span>
<span class="line-added">284             Module m0 = prevLookupClass() != null ? prevLookupClass.getModule() : m1;</span>
<span class="line-added">285             String pn = c.getPackageName();</span>
<span class="line-added">286             boolean accessible = m1.canRead(m2) &amp;&amp; m2.isExported(pn, m1);</span>
<span class="line-added">287             if (m1 != m0) {</span>
<span class="line-added">288                 accessible = accessible &amp;&amp; m0.canRead(m2) &amp;&amp; m2.isExported(pn, m0);</span>
<span class="line-added">289             }</span>
<span class="line-added">290             return accessible;</span>
<span class="line-added">291         }</span>
<span class="line-added">292 </span>
293         @Override
294         public String toString() {
295             String s = lookupClass().getSimpleName();
296             String lstr = lookupString();
297             int sl = lstr.indexOf(&#39;/&#39;);
298             if (sl &gt;= 0)  s += lstr.substring(sl);
299             ClassLoader cld = lookupClass().getClassLoader();
300             if (cld != THIS_LOADER)  s += &quot;/loader#&quot;+numberOf(cld);
301             return s;
302         }
303 
304         /** Predict the success or failure of accessing this method. */
305         public boolean willAccess(Method m) {
306             Class&lt;?&gt; c1 = lookupClass();
307             Class&lt;?&gt; c2 = m.getDeclaringClass();
<a name="30" id="anc30"></a><span class="line-added">308             Module m1 = c1.getModule();</span>
<span class="line-added">309             Module m2 = c2.getModule();</span>
<span class="line-added">310             Module m0 = prevLookupClass != null ? prevLookupClass.getModule() : m1;</span>
<span class="line-added">311             // unconditional has access to all public types/members of types that is in a package</span>
<span class="line-added">312             // are unconditionally exported</span>
<span class="line-added">313             if ((lookupModes &amp; UNCONDITIONAL) != 0) {</span>
<span class="line-added">314                 return m2.isExported(c2.getPackageName())</span>
<span class="line-added">315                        &amp;&amp; Modifier.isPublic(c2.getModifiers())</span>
<span class="line-added">316                        &amp;&amp; Modifier.isPublic(m.getModifiers());</span>
<span class="line-added">317             }</span>
318 
<a name="31" id="anc31"></a><span class="line-modified">319             // c1 and c2 are in different module</span>
<span class="line-modified">320             if (m1 != m2 || m0 != m2) {</span>
<span class="line-modified">321                 return (lookupModes &amp; PUBLIC) != 0</span>
<span class="line-modified">322                        &amp;&amp; isModuleAccessible(c2)</span>
<span class="line-modified">323                        &amp;&amp; Modifier.isPublic(c2.getModifiers())</span>
<span class="line-modified">324                        &amp;&amp; Modifier.isPublic(m.getModifiers());</span>
<span class="line-modified">325             }</span>
<span class="line-added">326 </span>
<span class="line-added">327             assert(m1 == m2 &amp;&amp; prevLookupClass == null);</span>
<span class="line-added">328 </span>
<span class="line-added">329             if (!willAccessClass(c2, false))</span>
<span class="line-added">330                 return false;</span>
331 
332             LookupCase lc = this.in(c2);
<a name="32" id="anc32"></a><span class="line-modified">333             int modes1 = lc.lookupModes();</span>
<span class="line-modified">334             int modes2 = fixMods(m.getModifiers());</span>
335             // allow private lookup on nestmates. Otherwise, privacy is strictly enforced
<a name="33" id="anc33"></a><span class="line-modified">336             if (c1 != c2 &amp;&amp; ((modes2 &amp; PRIVATE) == 0 || !c1.isNestmateOf(c2))) {</span>
<span class="line-modified">337                 modes1 &amp;= ~PRIVATE;</span>
338             }
339             // protected access is sometimes allowed
<a name="34" id="anc34"></a><span class="line-modified">340             if ((modes2 &amp; PROTECTED) != 0) {</span>
<span class="line-modified">341                 int prev = modes2;</span>
<span class="line-modified">342                 modes2 |= PACKAGE;  // it acts like a package method also</span>
343                 if ((lookupModes() &amp; PROTECTED) != 0 &amp;&amp;
344                     c2.isAssignableFrom(c1))
<a name="35" id="anc35"></a><span class="line-modified">345                     modes2 |= PUBLIC;  // from a subclass, it acts like a public method also</span>
346             }
347             if (verbosity &gt;= 2)
<a name="36" id="anc36"></a><span class="line-modified">348                 System.out.format(&quot;%s willAccess %s modes1=0x%h modes2=0x%h =&gt; %s%n&quot;, lookupString(), lc.lookupString(), modes1, modes2, (modes2 &amp; modes1) != 0);</span>
<span class="line-modified">349             return (modes2 &amp; modes1) != 0;</span>
350         }
351 
352         /** Predict the success or failure of accessing this class. */
353         public boolean willAccessClass(Class&lt;?&gt; c2, boolean load) {
354             Class&lt;?&gt; c1 = lookupClass();
355             if (load &amp;&amp; c2.getClassLoader() != null) {
356                 if (c1.getClassLoader() == null) {
357                     // not visible
358                     return false;
359                 }
360             }
361 
<a name="37" id="anc37"></a><span class="line-modified">362             Module m1 = c1.getModule();</span>
<span class="line-modified">363             Module m2 = c2.getModule();</span>
<span class="line-modified">364             Module m0 = prevLookupClass != null ? prevLookupClass.getModule() : m1;</span>
<span class="line-modified">365             // unconditional has access to all public types that is in an unconditionally exported package</span>
<span class="line-modified">366             if ((lookupModes &amp; UNCONDITIONAL) != 0) {</span>
<span class="line-modified">367                 return m2.isExported(c2.getPackageName()) &amp;&amp; Modifier.isPublic(c2.getModifiers());</span>
<span class="line-added">368             }</span>
<span class="line-added">369             // c1 and c2 are in different module</span>
<span class="line-added">370             if (m1 != m2 || m0 != m2) {</span>
<span class="line-added">371                 return (lookupModes &amp; PUBLIC) != 0</span>
<span class="line-added">372                     &amp;&amp; isModuleAccessible(c2)</span>
<span class="line-added">373                     &amp;&amp; Modifier.isPublic(c2.getModifiers());</span>
<span class="line-added">374             }</span>
<span class="line-added">375 </span>
<span class="line-added">376             assert(m1 == m2 &amp;&amp; prevLookupClass == null);</span>
377 
378             LookupCase lc = this.in(c2);
<a name="38" id="anc38"></a><span class="line-modified">379             int modes1 = lc.lookupModes();</span>
380             boolean r = false;
<a name="39" id="anc39"></a><span class="line-modified">381             if (modes1 == 0) {</span>
382                 r = false;
383             } else {
<a name="40" id="anc40"></a><span class="line-modified">384                 if (Modifier.isPublic(c2.getModifiers())) {</span>
<span class="line-modified">385                     if ((modes1 &amp; MODULE) != 0)</span>
<span class="line-modified">386                         r = true;</span>
<span class="line-modified">387                     else if ((modes1 &amp; PUBLIC) != 0)</span>
<span class="line-modified">388                         r = m1.isExported(c2.getPackageName());</span>
<span class="line-added">389                 } else {</span>
<span class="line-added">390                     if ((modes1 &amp; PACKAGE) != 0 &amp;&amp; c1.getPackage() == c2.getPackage())</span>
<span class="line-added">391                         r = true;</span>
392                 }
393             }
394             if (verbosity &gt;= 2) {
395                 System.out.println(this+&quot; willAccessClass &quot;+lc+&quot; c1=&quot;+c1+&quot; c2=&quot;+c2+&quot; =&gt; &quot;+r);
396             }
397             return r;
398         }
399     }
400 
401     private static Class&lt;?&gt; topLevelClass(Class&lt;?&gt; cls) {
402         Class&lt;?&gt; c = cls;
403         for (Class&lt;?&gt; ec; (ec = c.getEnclosingClass()) != null; )
404             c = ec;
405         assert(c.getEnclosingClass() == null);
406         assert(c == cls || cls.getEnclosingClass() != null);
407         return c;
408     }
409 
410     private final TreeSet&lt;LookupCase&gt; CASES = new TreeSet&lt;&gt;();
411     private final TreeMap&lt;LookupCase,TreeSet&lt;LookupCase&gt;&gt; CASE_EDGES = new TreeMap&lt;&gt;();
412     private final ArrayList&lt;ClassLoader&gt; LOADERS = new ArrayList&lt;&gt;();
413     private final ClassLoader THIS_LOADER = this.getClass().getClassLoader();
414     { if (THIS_LOADER != null)  LOADERS.add(THIS_LOADER); }  // #1
415 
416     private LookupCase lookupCase(String name) {
417         for (LookupCase lc : CASES) {
418             if (lc.toString().equals(name))
419                 return lc;
420         }
421         throw new AssertionError(name);
422     }
423 
424     private int numberOf(ClassLoader cl) {
425         if (cl == null)  return 0;
426         int i = LOADERS.indexOf(cl);
427         if (i &lt; 0) {
428             i = LOADERS.size();
429             LOADERS.add(cl);
430         }
431         return i+1;
432     }
433 
<a name="41" id="anc41"></a><span class="line-modified">434     private void addLookupEdge(LookupCase l1, Class&lt;?&gt; c2, LookupCase l2, int dropAccess) {</span>
435         TreeSet&lt;LookupCase&gt; edges = CASE_EDGES.get(l2);
436         if (edges == null)  CASE_EDGES.put(l2, edges = new TreeSet&lt;&gt;());
437         if (edges.add(l1)) {
438             Class&lt;?&gt; c1 = l1.lookupClass();
439             assert(l2.lookupClass() == c2); // [A1]
440             int m1 = l1.lookupModes();
441             int m2 = l2.lookupModes();
442             assert((m1 | m2) == m1);        // [A2] (no elevation of access)
<a name="42" id="anc42"></a><span class="line-modified">443             LookupCase expect = dropAccess == 0 ? l1.in(c2) : l1.in(c2).dropLookupMode(dropAccess);</span>
444             if (!expect.equals(l2))
445                 System.out.println(&quot;*** expect &quot;+l1+&quot; =&gt; &quot;+expect+&quot; but got &quot;+l2);
446             assertEquals(l2, expect);
447         }
448     }
449 
450     private void makeCases(Lookup[] originalLookups) {
451         // make initial set of lookup test cases
452         CASES.clear(); LOADERS.clear(); CASE_EDGES.clear();
453         ArrayList&lt;Class&lt;?&gt;&gt; classes = new ArrayList&lt;&gt;();
454         for (Lookup l : originalLookups) {
455             CASES.add(new LookupCase(l));
456             classes.remove(l.lookupClass());  // no dups please
457             classes.add(l.lookupClass());
458         }
459         System.out.println(&quot;loaders = &quot;+LOADERS);
460         int rounds = 0;
461         for (int lastCount = -1; lastCount != CASES.size(); ) {
462             lastCount = CASES.size();  // if CASES grow in the loop we go round again
463             for (LookupCase lc1 : CASES.toArray(new LookupCase[0])) {
<a name="43" id="anc43"></a><span class="line-added">464                 for (int mode : ACCESS_CASES) {</span>
<span class="line-added">465                     LookupCase lc2 = new LookupCase(lc1.lookup().dropLookupMode(mode));</span>
<span class="line-added">466                     addLookupEdge(lc1, lc1.lookupClass(), lc2, mode);</span>
<span class="line-added">467                     CASES.add(lc2);</span>
<span class="line-added">468                 }</span>
469                 for (Class&lt;?&gt; c2 : classes) {
470                     LookupCase lc2 = new LookupCase(lc1.lookup().in(c2));
<a name="44" id="anc44"></a><span class="line-modified">471                     addLookupEdge(lc1, c2, lc2, 0);</span>
472                     CASES.add(lc2);
473                 }
474             }
475             rounds++;
476         }
477         System.out.println(&quot;filled in &quot;+CASES.size()+&quot; cases from &quot;+originalLookups.length+&quot; original cases in &quot;+rounds+&quot; rounds&quot;);
478         if (false) {
479             System.out.println(&quot;CASES: {&quot;);
480             for (LookupCase lc : CASES) {
481                 System.out.println(lc);
482                 Set&lt;LookupCase&gt; edges = CASE_EDGES.get(lc);
483                 if (edges != null)
484                     for (LookupCase prev : edges) {
485                         System.out.println(&quot;\t&quot;+prev);
486                     }
487             }
488             System.out.println(&quot;}&quot;);
489         }
490     }
491 
492     @Test public void test() {
493         makeCases(lookups());
494         if (verbosity &gt; 0) {
495             verbosity += 9;
496             Method pro_in_self = targetMethod(THIS_CLASS, PROTECTED, methodType(void.class));
<a name="45" id="anc45"></a><span class="line-modified">497             testOneAccess(lookupCase(&quot;AccessControlTest/module&quot;),  pro_in_self, &quot;find&quot;);</span>
<span class="line-modified">498             testOneAccess(lookupCase(&quot;Remote_subclass/module&quot;),    pro_in_self, &quot;find&quot;);</span>
499             testOneAccess(lookupCase(&quot;Remote_subclass&quot;),           pro_in_self, &quot;find&quot;);
500             verbosity -= 9;
501         }
502         Set&lt;Class&lt;?&gt;&gt; targetClassesDone = new HashSet&lt;&gt;();
503         for (LookupCase targetCase : CASES) {
504             Class&lt;?&gt; targetClass = targetCase.lookupClass();
505             if (!targetClassesDone.add(targetClass))  continue;  // already saw this one
506             String targetPlace = placeName(targetClass);
507             if (targetPlace == null)  continue;  // Object, String, not a target
508             for (int targetAccess : ACCESS_CASES) {
<a name="46" id="anc46"></a><span class="line-added">509                 if (targetAccess == MODULE || targetAccess == UNCONDITIONAL)</span>
<span class="line-added">510                     continue;</span>
511                 MethodType methodType = methodType(void.class);
512                 Method method = targetMethod(targetClass, targetAccess, methodType);
513                 // Try to access target method from various contexts.
514                 for (LookupCase sourceCase : CASES) {
515                     testOneAccess(sourceCase, method, &quot;findClass&quot;);
516                     testOneAccess(sourceCase, method, &quot;accessClass&quot;);
517                     testOneAccess(sourceCase, method, &quot;find&quot;);
518                     testOneAccess(sourceCase, method, &quot;unreflect&quot;);
519                 }
520             }
521         }
522         System.out.println(&quot;tested &quot;+testCount+&quot; access scenarios; &quot;+testCountFails+&quot; accesses were denied&quot;);
523     }
524 
525     private int testCount, testCountFails;
526 
527     private void testOneAccess(LookupCase sourceCase, Method method, String kind) {
528         Class&lt;?&gt; targetClass = method.getDeclaringClass();
529         String methodName = method.getName();
530         MethodType methodType = methodType(method.getReturnType(), method.getParameterTypes());
531         boolean isFindOrAccessClass = &quot;findClass&quot;.equals(kind) || &quot;accessClass&quot;.equals(kind);
532         boolean willAccess = isFindOrAccessClass ?
533                 sourceCase.willAccessClass(targetClass, &quot;findClass&quot;.equals(kind)) : sourceCase.willAccess(method);
534         boolean didAccess = false;
535         ReflectiveOperationException accessError = null;
536         try {
537             switch (kind) {
538             case &quot;accessClass&quot;:
539                 sourceCase.lookup().accessClass(targetClass);
540                 break;
541             case &quot;findClass&quot;:
542                 sourceCase.lookup().findClass(targetClass.getName());
543                 break;
544             case &quot;find&quot;:
545                 if ((method.getModifiers() &amp; Modifier.STATIC) != 0)
546                     sourceCase.lookup().findStatic(targetClass, methodName, methodType);
547                 else
548                     sourceCase.lookup().findVirtual(targetClass, methodName, methodType);
549                 break;
550             case &quot;unreflect&quot;:
551                 sourceCase.lookup().unreflect(method);
552                 break;
553             default:
554                 throw new AssertionError(kind);
555             }
556             didAccess = true;
557         } catch (ReflectiveOperationException ex) {
558             accessError = ex;
559         }
560         if (willAccess != didAccess) {
561             System.out.println(sourceCase+&quot; =&gt; &quot;+targetClass.getSimpleName()+(isFindOrAccessClass?&quot;&quot;:&quot;.&quot;+methodName+methodType));
562             System.out.println(&quot;fail &quot;+(isFindOrAccessClass?kind:&quot;on &quot;+method)+&quot; ex=&quot;+accessError);
563             assertEquals(willAccess, didAccess);
564         }
565         testCount++;
566         if (!didAccess)  testCountFails++;
567     }
568 
569     static Method targetMethod(Class&lt;?&gt; targetClass, int targetAccess, MethodType methodType) {
<a name="47" id="anc47"></a>
570         String methodName = accessName(targetAccess)+placeName(targetClass);
571         if (verbosity &gt;= 2)
572             System.out.println(targetClass.getSimpleName()+&quot;.&quot;+methodName+methodType);
573         try {
574             Method method = targetClass.getDeclaredMethod(methodName, methodType.parameterArray());
575             assertEquals(method.getReturnType(), methodType.returnType());
576             int haveMods = method.getModifiers();
577             assert(Modifier.isStatic(haveMods));
578             assert(targetAccess == fixMods(haveMods));
579             return method;
580         } catch (NoSuchMethodException ex) {
581             throw new AssertionError(methodName, ex);
582         }
583     }
584 
585     static String placeName(Class&lt;?&gt; cls) {
586         // return &quot;self&quot;, &quot;sibling&quot;, &quot;nestmate&quot;, etc.
587         if (cls == AccessControlTest.class)  return &quot;self&quot;;
588         String cln = cls.getSimpleName();
589         int under = cln.lastIndexOf(&#39;_&#39;);
590         if (under &lt; 0)  return null;
591         return cln.substring(under+1);
592     }
593     static String accessName(int acc) {
594         switch (acc) {
595         case PUBLIC:     return &quot;pub_in_&quot;;
596         case PROTECTED:  return &quot;pro_in_&quot;;
597         case PACKAGE:    return &quot;pkg_in_&quot;;
598         case PRIVATE:    return &quot;pri_in_&quot;;
599         }
600         assert(false);
601         return &quot;?&quot;;
602     }
<a name="48" id="anc48"></a>
603     private static final int[] ACCESS_CASES = {
<a name="49" id="anc49"></a><span class="line-modified">604         PUBLIC, PACKAGE, PRIVATE, PROTECTED, MODULE, UNCONDITIONAL</span>
605     };
<a name="50" id="anc50"></a><span class="line-added">606     /*</span>
<span class="line-added">607      * Adjust PUBLIC =&gt; PUBLIC|MODULE|UNCONDITIONAL</span>
<span class="line-added">608      * Adjust 0 =&gt; PACKAGE</span>
<span class="line-added">609      */</span>
610     /** Return one of the ACCESS_CASES. */
611     static int fixMods(int mods) {
612         mods &amp;= (PUBLIC|PRIVATE|PROTECTED);
613         switch (mods) {
614         case PUBLIC: case PRIVATE: case PROTECTED: return mods;
615         case 0:  return PACKAGE;
616         }
617         throw new AssertionError(mods);
618     }
619 
620     static Lookup[] lookups() {
621         ArrayList&lt;Lookup&gt; tem = new ArrayList&lt;&gt;();
622         Collections.addAll(tem,
623                            AccessControlTest.lookup_in_self(),
624                            Inner_nestmate.lookup_in_nestmate(),
625                            AccessControlTest_sibling.lookup_in_sibling());
626         if (true) {
627             Collections.addAll(tem,Acquaintance_remote.lookups());
628         } else {
629             try {
630                 Class&lt;?&gt; remc = Class.forName(&quot;test.java.lang.invoke.AccessControlTest_subpkg.Acquaintance_remote&quot;);
631                 Lookup[] remls = (Lookup[]) remc.getMethod(&quot;lookups&quot;).invoke(null);
632                 Collections.addAll(tem, remls);
633             } catch (ReflectiveOperationException ex) {
634                 throw new LinkageError(&quot;reflection failed&quot;, ex);
635             }
636         }
637         tem.add(publicLookup());
638         tem.add(publicLookup().in(String.class));
639         tem.add(publicLookup().in(List.class));
640         return tem.toArray(new Lookup[0]);
641     }
642 
643     static Lookup lookup_in_self() {
644         return MethodHandles.lookup();
645     }
646     public static      void pub_in_self() { }
647     protected static   void pro_in_self() { }
648     static /*package*/ void pkg_in_self() { }
649     private static     void pri_in_self() { }
650 
651     static class Inner_nestmate {
652         static Lookup lookup_in_nestmate() {
653             return MethodHandles.lookup();
654         }
655         public static      void pub_in_nestmate() { }
656         protected static   void pro_in_nestmate() { }
657         static /*package*/ void pkg_in_nestmate() { }
658         private static     void pri_in_nestmate() { }
659     }
660 }
661 class AccessControlTest_sibling {
662     static Lookup lookup_in_sibling() {
663         return MethodHandles.lookup();
664     }
665     public static      void pub_in_sibling() { }
666     protected static   void pro_in_sibling() { }
667     static /*package*/ void pkg_in_sibling() { }
668     private static     void pri_in_sibling() { }
669 }
670 
671 // This guy tests access from outside the package:
672 /*
673 package test.java.lang.invoke.AccessControlTest_subpkg;
674 public class Acquaintance_remote {
675     public static Lookup[] lookups() { ...
676     }
677     ...
678 }
679 */
<a name="51" id="anc51"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="51" type="hidden" />
</body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff test/jdk/java/lang/invoke/MethodHandlesGeneralTest.java</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
<body>
<center><a href="MethodHandles/privateLookupIn/test/p/PrivateLookupInTests.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="MethodHandlesTest.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>test/jdk/java/lang/invoke/MethodHandlesGeneralTest.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 2018, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  */
  23 
  24 /* @test

  25  * @summary unit tests for java.lang.invoke.MethodHandles
  26  * @library /test/lib /java/lang/invoke/common
  27  * @compile MethodHandlesTest.java MethodHandlesGeneralTest.java remote/RemoteExample.java
  28  * @run junit/othervm/timeout=2500 -XX:+IgnoreUnrecognizedVMOptions
  29  *                                 -XX:-VerifyDependencies
  30  *                                 -esa
  31  *                                 test.java.lang.invoke.MethodHandlesGeneralTest
  32  */
  33 
  34 package test.java.lang.invoke;
  35 
  36 import org.junit.*;
  37 import test.java.lang.invoke.lib.CodeCacheOverflowProcessor;
  38 import test.java.lang.invoke.remote.RemoteExample;
  39 
  40 import java.lang.invoke.MethodHandle;
  41 import java.lang.invoke.MethodHandleProxies;
  42 import java.lang.invoke.MethodHandles;
  43 import java.lang.invoke.MethodType;
  44 import java.lang.invoke.WrongMethodTypeException;
</pre>
<hr />
<pre>
 617     public void testFindGetter0() throws Throwable {
 618         if (CAN_SKIP_WORKING)  return;
 619         startTest(&quot;findGetter&quot;);
 620         testGetter(TEST_FIND_FIELD);
 621         testGetter(TEST_FIND_FIELD | TEST_BOUND);
 622     }
 623 
 624     @Test
 625     public void testFindStaticGetter() throws Throwable {
 626         CodeCacheOverflowProcessor.runMHTest(this::testFindStaticGetter0);
 627     }
 628 
 629     public void testFindStaticGetter0() throws Throwable {
 630         if (CAN_SKIP_WORKING)  return;
 631         startTest(&quot;findStaticGetter&quot;);
 632         testGetter(TEST_FIND_STATIC);
 633     }
 634 
 635     public void testGetter(int testMode) throws Throwable {
 636         Lookup lookup = PRIVATE;  // FIXME: test more lookups than this one
<span class="line-modified"> 637         for (Object[] c : HasFields.CASES) {</span>
 638             boolean positive = (c[1] != Error.class);
 639             testGetter(positive, lookup, c[0], c[1], testMode);
 640             if (positive)
 641                 testGetter(positive, lookup, c[0], c[1], testMode | TEST_NPE);
 642         }
 643         testGetter(true, lookup,
 644                    new Object[]{ true,  System.class, &quot;out&quot;, java.io.PrintStream.class },
 645                    System.out, testMode);
 646         for (int isStaticN = 0; isStaticN &lt;= 1; isStaticN++) {
 647             testGetter(false, lookup,
 648                        new Object[]{ (isStaticN != 0), System.class, &quot;bogus&quot;, char.class },
 649                        null, testMode);
 650         }
 651     }
 652 
 653     public void testGetter(boolean positive, MethodHandles.Lookup lookup,
 654                            Object fieldRef, Object value, int testMode) throws Throwable {
 655         testAccessor(positive, lookup, fieldRef, value, testMode);
 656     }
 657 
</pre>
<hr />
<pre>
 706             case TEST_SETTER|
 707                  TEST_UNREFLECT:   mh = lookup.unreflectSetter(f);                      break;
 708             case TEST_SETTER|
 709                  TEST_FIND_FIELD:  mh = lookup.findSetter(fclass, fname, ftype);        break;
 710             case TEST_SETTER|
 711                  TEST_FIND_STATIC: mh = lookup.findStaticSetter(fclass, fname, ftype);  break;
 712             default:
 713                 throw new InternalError(&quot;testMode=&quot;+testMode);
 714             }
 715         } catch (ReflectiveOperationException ex) {
 716             mh = null;
 717             noAccess = ex;
 718             assertExceptionClass(
 719                 (fname.contains(&quot;bogus&quot;))
 720                 ?   NoSuchFieldException.class
 721                 :   IllegalAccessException.class,
 722                 noAccess);
 723             if (verbosity &gt;= 5)  ex.printStackTrace(System.out);
 724         }
 725         if (verbosity &gt;= 3)
<span class="line-modified"> 726             System.out.println(&quot;find&quot;+(isStatic?&quot;Static&quot;:&quot;&quot;)+(isGetter?&quot;Getter&quot;:&quot;Setter&quot;)+&quot; &quot;+fclass.getName()+&quot;.&quot;+fname+&quot;/&quot;+ftype</span>
<span class="line-modified"> 727                                +&quot; =&gt; &quot;+mh</span>
<span class="line-modified"> 728                                +(noAccess == null ? &quot;&quot; : &quot; !! &quot;+noAccess));</span>







 729         if (positive &amp;&amp; !testNPE &amp;&amp; noAccess != null)  throw new RuntimeException(noAccess);
 730         assertEquals(positive0 ? &quot;positive test&quot; : &quot;negative test erroneously passed&quot;, positive0, mh != null);
 731         if (!positive &amp;&amp; !testNPE)  return; // negative access test failed as expected
 732         assertEquals((isStatic ? 0 : 1)+(isGetter ? 0 : 1), mh.type().parameterCount());
<span class="line-removed"> 733 </span>
<span class="line-removed"> 734 </span>
 735         assertSame(mh.type(), expType);
 736         //assertNameStringContains(mh, fname);  // This does not hold anymore with LFs
 737         HasFields fields = new HasFields();
 738         HasFields fieldsForMH = fields;
 739         if (testNPE)  fieldsForMH = null;  // perturb MH argument to elicit expected error
 740         if (doBound)
 741             mh = mh.bindTo(fieldsForMH);
 742         Object sawValue;
 743         Class&lt;?&gt; vtype = ftype;
 744         if (ftype != int.class)  vtype = Object.class;
 745         if (isGetter) {
 746             mh = mh.asType(mh.type().generic()
 747                            .changeReturnType(vtype));
 748         } else {
 749             int last = mh.type().parameterCount() - 1;
 750             mh = mh.asType(mh.type().generic()
 751                            .changeReturnType(void.class)
 752                            .changeParameterType(last, vtype));
 753         }
 754         if (f != null &amp;&amp; f.getDeclaringClass() == HasFields.class) {
 755             assertEquals(f.get(fields), value);  // clean to start with
 756         }
 757         Throwable caughtEx = null;



 758         if (isGetter) {
 759             Object expValue = value;
 760             for (int i = 0; i &lt;= 1; i++) {
 761                 sawValue = null;  // make DA rules happy under try/catch
 762                 try {
 763                     if (isStatic || doBound) {
 764                         if (ftype == int.class)
 765                             sawValue = (int) mh.invokeExact();  // do these exactly
 766                         else
 767                             sawValue = mh.invokeExact();
 768                     } else {
 769                         if (ftype == int.class)
 770                             sawValue = (int) mh.invokeExact((Object) fieldsForMH);
 771                         else
 772                             sawValue = mh.invokeExact((Object) fieldsForMH);
 773                     }
 774                 } catch (RuntimeException ex) {
 775                     if (ex instanceof NullPointerException &amp;&amp; testNPE) {
 776                         caughtEx = ex;
 777                         break;
 778                     }
 779                 }
 780                 assertEquals(sawValue, expValue);
<span class="line-modified"> 781                 if (f != null &amp;&amp; f.getDeclaringClass() == HasFields.class</span>
<span class="line-removed"> 782                     &amp;&amp; !Modifier.isFinal(f.getModifiers())) {</span>
 783                     Object random = randomArg(ftype);
 784                     f.set(fields, random);
 785                     expValue = random;
 786                 } else {
 787                     break;
 788                 }
 789             }
 790         } else {
 791             for (int i = 0; i &lt;= 1; i++) {
 792                 Object putValue = randomArg(ftype);
 793                 try {
 794                     if (isStatic || doBound) {
 795                         if (ftype == int.class)
 796                             mh.invokeExact((int)putValue);  // do these exactly
 797                         else
 798                             mh.invokeExact(putValue);
 799                     } else {
 800                         if (ftype == int.class)
 801                             mh.invokeExact((Object) fieldsForMH, (int)putValue);
 802                         else
 803                             mh.invokeExact((Object) fieldsForMH, putValue);
 804                     }
 805                 } catch (RuntimeException ex) {
 806                     if (ex instanceof NullPointerException &amp;&amp; testNPE) {
 807                         caughtEx = ex;
 808                         break;
 809                     }
 810                 }
 811                 if (f != null &amp;&amp; f.getDeclaringClass() == HasFields.class) {
 812                     assertEquals(f.get(fields), putValue);
 813                 }
 814             }
 815         }
<span class="line-modified"> 816         if (f != null &amp;&amp; f.getDeclaringClass() == HasFields.class) {</span>
<span class="line-modified"> 817             f.set(fields, value);  // put it back</span>
 818         }
 819         if (testNPE) {
 820             if (caughtEx == null || !(caughtEx instanceof NullPointerException))
 821                 throw new RuntimeException(&quot;failed to catch NPE exception&quot;+(caughtEx == null ? &quot; (caughtEx=null)&quot; : &quot;&quot;), caughtEx);
 822             caughtEx = null;  // nullify expected exception
 823         }
 824         if (caughtEx != null) {
 825             throw new RuntimeException(&quot;unexpected exception&quot;, caughtEx);
 826         }
 827     }
 828 
 829     @Test
 830     public void testUnreflectSetter() throws Throwable {
 831         CodeCacheOverflowProcessor.runMHTest(this::testUnreflectSetter0);
 832     }
 833 
 834     public void testUnreflectSetter0() throws Throwable {
 835         if (CAN_SKIP_WORKING)  return;
 836         startTest(&quot;unreflectSetter&quot;);
 837         testSetter(TEST_UNREFLECT);
</pre>
<hr />
<pre>
 845     public void testFindSetter0() throws Throwable {
 846         if (CAN_SKIP_WORKING)  return;
 847         startTest(&quot;findSetter&quot;);
 848         testSetter(TEST_FIND_FIELD);
 849         testSetter(TEST_FIND_FIELD | TEST_BOUND);
 850     }
 851 
 852     @Test
 853     public void testFindStaticSetter() throws Throwable {
 854         CodeCacheOverflowProcessor.runMHTest(this::testFindStaticSetter0);
 855     }
 856 
 857     public void testFindStaticSetter0() throws Throwable {
 858         if (CAN_SKIP_WORKING)  return;
 859         startTest(&quot;findStaticSetter&quot;);
 860         testSetter(TEST_FIND_STATIC);
 861     }
 862 
 863     public void testSetter(int testMode) throws Throwable {
 864         Lookup lookup = PRIVATE;  // FIXME: test more lookups than this one
<span class="line-modified"> 865         startTest(&quot;unreflectSetter&quot;);</span>
<span class="line-modified"> 866         for (Object[] c : HasFields.CASES) {</span>
 867             boolean positive = (c[1] != Error.class);
 868             testSetter(positive, lookup, c[0], c[1], testMode);
 869             if (positive)
 870                 testSetter(positive, lookup, c[0], c[1], testMode | TEST_NPE);
 871         }
 872         for (int isStaticN = 0; isStaticN &lt;= 1; isStaticN++) {
 873             testSetter(false, lookup,
 874                        new Object[]{ (isStaticN != 0), System.class, &quot;bogus&quot;, char.class },
 875                        null, testMode);
 876         }
 877     }
 878 
 879     public void testSetter(boolean positive, MethodHandles.Lookup lookup,
 880                            Object fieldRef, Object value, int testMode) throws Throwable {
 881         testAccessor(positive, lookup, fieldRef, value, testMode | TEST_SETTER);
 882     }
 883 
 884     @Test
 885     public void testArrayElementGetter() throws Throwable {
 886         CodeCacheOverflowProcessor.runMHTest(this::testArrayElementGetter0);
</pre>
</td>
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 2018, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  */
  23 
  24 /* @test
<span class="line-added">  25  * @bug 8216558</span>
  26  * @summary unit tests for java.lang.invoke.MethodHandles
  27  * @library /test/lib /java/lang/invoke/common
  28  * @compile MethodHandlesTest.java MethodHandlesGeneralTest.java remote/RemoteExample.java
  29  * @run junit/othervm/timeout=2500 -XX:+IgnoreUnrecognizedVMOptions
  30  *                                 -XX:-VerifyDependencies
  31  *                                 -esa
  32  *                                 test.java.lang.invoke.MethodHandlesGeneralTest
  33  */
  34 
  35 package test.java.lang.invoke;
  36 
  37 import org.junit.*;
  38 import test.java.lang.invoke.lib.CodeCacheOverflowProcessor;
  39 import test.java.lang.invoke.remote.RemoteExample;
  40 
  41 import java.lang.invoke.MethodHandle;
  42 import java.lang.invoke.MethodHandleProxies;
  43 import java.lang.invoke.MethodHandles;
  44 import java.lang.invoke.MethodType;
  45 import java.lang.invoke.WrongMethodTypeException;
</pre>
<hr />
<pre>
 618     public void testFindGetter0() throws Throwable {
 619         if (CAN_SKIP_WORKING)  return;
 620         startTest(&quot;findGetter&quot;);
 621         testGetter(TEST_FIND_FIELD);
 622         testGetter(TEST_FIND_FIELD | TEST_BOUND);
 623     }
 624 
 625     @Test
 626     public void testFindStaticGetter() throws Throwable {
 627         CodeCacheOverflowProcessor.runMHTest(this::testFindStaticGetter0);
 628     }
 629 
 630     public void testFindStaticGetter0() throws Throwable {
 631         if (CAN_SKIP_WORKING)  return;
 632         startTest(&quot;findStaticGetter&quot;);
 633         testGetter(TEST_FIND_STATIC);
 634     }
 635 
 636     public void testGetter(int testMode) throws Throwable {
 637         Lookup lookup = PRIVATE;  // FIXME: test more lookups than this one
<span class="line-modified"> 638         for (Object[] c : HasFields.testCasesFor(testMode)) {</span>
 639             boolean positive = (c[1] != Error.class);
 640             testGetter(positive, lookup, c[0], c[1], testMode);
 641             if (positive)
 642                 testGetter(positive, lookup, c[0], c[1], testMode | TEST_NPE);
 643         }
 644         testGetter(true, lookup,
 645                    new Object[]{ true,  System.class, &quot;out&quot;, java.io.PrintStream.class },
 646                    System.out, testMode);
 647         for (int isStaticN = 0; isStaticN &lt;= 1; isStaticN++) {
 648             testGetter(false, lookup,
 649                        new Object[]{ (isStaticN != 0), System.class, &quot;bogus&quot;, char.class },
 650                        null, testMode);
 651         }
 652     }
 653 
 654     public void testGetter(boolean positive, MethodHandles.Lookup lookup,
 655                            Object fieldRef, Object value, int testMode) throws Throwable {
 656         testAccessor(positive, lookup, fieldRef, value, testMode);
 657     }
 658 
</pre>
<hr />
<pre>
 707             case TEST_SETTER|
 708                  TEST_UNREFLECT:   mh = lookup.unreflectSetter(f);                      break;
 709             case TEST_SETTER|
 710                  TEST_FIND_FIELD:  mh = lookup.findSetter(fclass, fname, ftype);        break;
 711             case TEST_SETTER|
 712                  TEST_FIND_STATIC: mh = lookup.findStaticSetter(fclass, fname, ftype);  break;
 713             default:
 714                 throw new InternalError(&quot;testMode=&quot;+testMode);
 715             }
 716         } catch (ReflectiveOperationException ex) {
 717             mh = null;
 718             noAccess = ex;
 719             assertExceptionClass(
 720                 (fname.contains(&quot;bogus&quot;))
 721                 ?   NoSuchFieldException.class
 722                 :   IllegalAccessException.class,
 723                 noAccess);
 724             if (verbosity &gt;= 5)  ex.printStackTrace(System.out);
 725         }
 726         if (verbosity &gt;= 3)
<span class="line-modified"> 727             System.out.format(&quot;%s%s %s.%s/%s =&gt; %s %s%n&quot;,</span>
<span class="line-modified"> 728                               (testMode0 &amp; TEST_UNREFLECT) != 0</span>
<span class="line-modified"> 729                                   ? &quot;unreflect&quot;</span>
<span class="line-added"> 730                                   : &quot;find&quot; + ((testMode0 &amp; TEST_FIND_STATIC) != 0 ? &quot;Static&quot; : &quot;&quot;),</span>
<span class="line-added"> 731                               (isGetter ? &quot;Getter&quot; : &quot;Setter&quot;),</span>
<span class="line-added"> 732                               fclass.getName(), fname, ftype, mh,</span>
<span class="line-added"> 733                               (noAccess == null ? &quot;&quot; : &quot; !! &quot;+noAccess));</span>
<span class="line-added"> 734         // negative test case and expected noAccess, then done.</span>
<span class="line-added"> 735         if (!positive &amp;&amp; noAccess != null) return;</span>
<span class="line-added"> 736         // positive test case but found noAccess, then error</span>
 737         if (positive &amp;&amp; !testNPE &amp;&amp; noAccess != null)  throw new RuntimeException(noAccess);
 738         assertEquals(positive0 ? &quot;positive test&quot; : &quot;negative test erroneously passed&quot;, positive0, mh != null);
 739         if (!positive &amp;&amp; !testNPE)  return; // negative access test failed as expected
 740         assertEquals((isStatic ? 0 : 1)+(isGetter ? 0 : 1), mh.type().parameterCount());


 741         assertSame(mh.type(), expType);
 742         //assertNameStringContains(mh, fname);  // This does not hold anymore with LFs
 743         HasFields fields = new HasFields();
 744         HasFields fieldsForMH = fields;
 745         if (testNPE)  fieldsForMH = null;  // perturb MH argument to elicit expected error
 746         if (doBound)
 747             mh = mh.bindTo(fieldsForMH);
 748         Object sawValue;
 749         Class&lt;?&gt; vtype = ftype;
 750         if (ftype != int.class)  vtype = Object.class;
 751         if (isGetter) {
 752             mh = mh.asType(mh.type().generic()
 753                            .changeReturnType(vtype));
 754         } else {
 755             int last = mh.type().parameterCount() - 1;
 756             mh = mh.asType(mh.type().generic()
 757                            .changeReturnType(void.class)
 758                            .changeParameterType(last, vtype));
 759         }
 760         if (f != null &amp;&amp; f.getDeclaringClass() == HasFields.class) {
 761             assertEquals(f.get(fields), value);  // clean to start with
 762         }
 763         Throwable caughtEx = null;
<span class="line-added"> 764         // non-final field and setAccessible(true) on instance field will have write access</span>
<span class="line-added"> 765         boolean writeAccess = !Modifier.isFinal(f.getModifiers()) ||</span>
<span class="line-added"> 766                               (!Modifier.isStatic(f.getModifiers()) &amp;&amp; f.isAccessible());</span>
 767         if (isGetter) {
 768             Object expValue = value;
 769             for (int i = 0; i &lt;= 1; i++) {
 770                 sawValue = null;  // make DA rules happy under try/catch
 771                 try {
 772                     if (isStatic || doBound) {
 773                         if (ftype == int.class)
 774                             sawValue = (int) mh.invokeExact();  // do these exactly
 775                         else
 776                             sawValue = mh.invokeExact();
 777                     } else {
 778                         if (ftype == int.class)
 779                             sawValue = (int) mh.invokeExact((Object) fieldsForMH);
 780                         else
 781                             sawValue = mh.invokeExact((Object) fieldsForMH);
 782                     }
 783                 } catch (RuntimeException ex) {
 784                     if (ex instanceof NullPointerException &amp;&amp; testNPE) {
 785                         caughtEx = ex;
 786                         break;
 787                     }
 788                 }
 789                 assertEquals(sawValue, expValue);
<span class="line-modified"> 790                 if (f != null &amp;&amp; f.getDeclaringClass() == HasFields.class &amp;&amp; writeAccess) {</span>

 791                     Object random = randomArg(ftype);
 792                     f.set(fields, random);
 793                     expValue = random;
 794                 } else {
 795                     break;
 796                 }
 797             }
 798         } else {
 799             for (int i = 0; i &lt;= 1; i++) {
 800                 Object putValue = randomArg(ftype);
 801                 try {
 802                     if (isStatic || doBound) {
 803                         if (ftype == int.class)
 804                             mh.invokeExact((int)putValue);  // do these exactly
 805                         else
 806                             mh.invokeExact(putValue);
 807                     } else {
 808                         if (ftype == int.class)
 809                             mh.invokeExact((Object) fieldsForMH, (int)putValue);
 810                         else
 811                             mh.invokeExact((Object) fieldsForMH, putValue);
 812                     }
 813                 } catch (RuntimeException ex) {
 814                     if (ex instanceof NullPointerException &amp;&amp; testNPE) {
 815                         caughtEx = ex;
 816                         break;
 817                     }
 818                 }
 819                 if (f != null &amp;&amp; f.getDeclaringClass() == HasFields.class) {
 820                     assertEquals(f.get(fields), putValue);
 821                 }
 822             }
 823         }
<span class="line-modified"> 824         if (f != null &amp;&amp; f.getDeclaringClass() == HasFields.class &amp;&amp; writeAccess) {</span>
<span class="line-modified"> 825             f.set(fields, value);  // put it back if it has write access</span>
 826         }
 827         if (testNPE) {
 828             if (caughtEx == null || !(caughtEx instanceof NullPointerException))
 829                 throw new RuntimeException(&quot;failed to catch NPE exception&quot;+(caughtEx == null ? &quot; (caughtEx=null)&quot; : &quot;&quot;), caughtEx);
 830             caughtEx = null;  // nullify expected exception
 831         }
 832         if (caughtEx != null) {
 833             throw new RuntimeException(&quot;unexpected exception&quot;, caughtEx);
 834         }
 835     }
 836 
 837     @Test
 838     public void testUnreflectSetter() throws Throwable {
 839         CodeCacheOverflowProcessor.runMHTest(this::testUnreflectSetter0);
 840     }
 841 
 842     public void testUnreflectSetter0() throws Throwable {
 843         if (CAN_SKIP_WORKING)  return;
 844         startTest(&quot;unreflectSetter&quot;);
 845         testSetter(TEST_UNREFLECT);
</pre>
<hr />
<pre>
 853     public void testFindSetter0() throws Throwable {
 854         if (CAN_SKIP_WORKING)  return;
 855         startTest(&quot;findSetter&quot;);
 856         testSetter(TEST_FIND_FIELD);
 857         testSetter(TEST_FIND_FIELD | TEST_BOUND);
 858     }
 859 
 860     @Test
 861     public void testFindStaticSetter() throws Throwable {
 862         CodeCacheOverflowProcessor.runMHTest(this::testFindStaticSetter0);
 863     }
 864 
 865     public void testFindStaticSetter0() throws Throwable {
 866         if (CAN_SKIP_WORKING)  return;
 867         startTest(&quot;findStaticSetter&quot;);
 868         testSetter(TEST_FIND_STATIC);
 869     }
 870 
 871     public void testSetter(int testMode) throws Throwable {
 872         Lookup lookup = PRIVATE;  // FIXME: test more lookups than this one
<span class="line-modified"> 873         startTest(&quot;testSetter&quot;);</span>
<span class="line-modified"> 874         for (Object[] c : HasFields.testCasesFor(testMode|TEST_SETTER)) {</span>
 875             boolean positive = (c[1] != Error.class);
 876             testSetter(positive, lookup, c[0], c[1], testMode);
 877             if (positive)
 878                 testSetter(positive, lookup, c[0], c[1], testMode | TEST_NPE);
 879         }
 880         for (int isStaticN = 0; isStaticN &lt;= 1; isStaticN++) {
 881             testSetter(false, lookup,
 882                        new Object[]{ (isStaticN != 0), System.class, &quot;bogus&quot;, char.class },
 883                        null, testMode);
 884         }
 885     }
 886 
 887     public void testSetter(boolean positive, MethodHandles.Lookup lookup,
 888                            Object fieldRef, Object value, int testMode) throws Throwable {
 889         testAccessor(positive, lookup, fieldRef, value, testMode | TEST_SETTER);
 890     }
 891 
 892     @Test
 893     public void testArrayElementGetter() throws Throwable {
 894         CodeCacheOverflowProcessor.runMHTest(this::testArrayElementGetter0);
</pre>
</td>
</tr>
</table>
<center><a href="MethodHandles/privateLookupIn/test/p/PrivateLookupInTests.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="MethodHandlesTest.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
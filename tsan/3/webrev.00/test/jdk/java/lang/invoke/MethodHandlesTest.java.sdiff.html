<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff test/jdk/java/lang/invoke/MethodHandlesTest.java</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
<body>
<center><a href="MethodHandlesGeneralTest.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="TryFinallyTest.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>test/jdk/java/lang/invoke/MethodHandlesTest.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 2009, 2018, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  */
  23 
  24 package test.java.lang.invoke;
  25 
  26 import org.junit.*;
  27 import test.java.lang.invoke.remote.RemoteExample;
  28 
  29 import java.lang.invoke.MethodHandle;
  30 import java.lang.invoke.MethodHandles;
  31 import java.lang.invoke.MethodHandles.Lookup;
  32 import java.lang.invoke.MethodType;
  33 import java.lang.reflect.Array;
  34 import java.lang.reflect.Field;
  35 import java.lang.reflect.Modifier;
  36 import java.util.ArrayList;
  37 import java.util.Arrays;
  38 import java.util.Collection;
  39 import java.util.Collections;
  40 import java.util.List;

  41 
  42 import static org.junit.Assert.*;
  43 
  44 /**
  45  *
  46  * @author jrose
  47  */
  48 public abstract class MethodHandlesTest {
  49 
  50     static final Class&lt;?&gt; THIS_CLASS = MethodHandlesTest.class;
  51     // How much output?
  52     static int verbosity = 0;
  53 
  54     static {
  55         String vstr = System.getProperty(THIS_CLASS.getSimpleName()+&quot;.verbosity&quot;);
  56         if (vstr == null)
  57             vstr = System.getProperty(THIS_CLASS.getName()+&quot;.verbosity&quot;);
  58         if (vstr != null)  verbosity = Integer.parseInt(vstr);
  59     }
  60 
</pre>
<hr />
<pre>
 528                                      Throwable actual) {
 529         if (expected.isInstance(actual))  return;
 530         actual.printStackTrace();
 531         assertEquals(expected, actual.getClass());
 532     }
 533 
 534     static final boolean DEBUG_METHOD_HANDLE_NAMES = Boolean.getBoolean(&quot;java.lang.invoke.MethodHandle.DEBUG_NAMES&quot;);
 535 
 536     // rough check of name string
 537     static void assertNameStringContains(MethodHandle x, String s) {
 538         if (!DEBUG_METHOD_HANDLE_NAMES) {
 539             // ignore s
 540             assertEquals(&quot;MethodHandle&quot;+x.type(), x.toString());
 541             return;
 542         }
 543         if (x.toString().contains(s))  return;
 544         assertEquals(s, x);
 545     }
 546 
 547     public static class HasFields {
<span class="line-modified"> 548         boolean fZ = false;</span>
<span class="line-modified"> 549         byte fB = (byte)&#39;B&#39;;</span>
<span class="line-modified"> 550         short fS = (short)&#39;S&#39;;</span>
<span class="line-modified"> 551         char fC = &#39;C&#39;;</span>
<span class="line-modified"> 552         int fI = &#39;I&#39;;</span>
<span class="line-modified"> 553         long fJ = &#39;J&#39;;</span>
<span class="line-modified"> 554         float fF = &#39;F&#39;;</span>
<span class="line-modified"> 555         double fD = &#39;D&#39;;</span>
 556         static boolean sZ = true;
 557         static byte sB = 1+(byte)&#39;B&#39;;
 558         static short sS = 1+(short)&#39;S&#39;;
 559         static char sC = 1+&#39;C&#39;;
 560         static int sI = 1+&#39;I&#39;;
 561         static long sJ = 1+&#39;J&#39;;
 562         static float sF = 1+&#39;F&#39;;
 563         static double sD = 1+&#39;D&#39;;
 564 
<span class="line-modified"> 565         Object fL = &#39;L&#39;;</span>
<span class="line-modified"> 566         String fR = &quot;R&quot;;</span>
<span class="line-modified"> 567         static Object sL = &#39;M&#39;;</span>
<span class="line-modified"> 568         static String sR = &quot;S&quot;;</span>
<span class="line-modified"> 569 </span>
<span class="line-modified"> 570         static final Object[][] CASES;</span>























 571         static {
<span class="line-removed"> 572             ArrayList&lt;Object[]&gt; cases = new ArrayList&lt;&gt;();</span>
 573             Object types[][] = {
 574                 {&#39;L&#39;,Object.class}, {&#39;R&#39;,String.class},
 575                 {&#39;I&#39;,int.class}, {&#39;J&#39;,long.class},
 576                 {&#39;F&#39;,float.class}, {&#39;D&#39;,double.class},
 577                 {&#39;Z&#39;,boolean.class}, {&#39;B&#39;,byte.class},
 578                 {&#39;S&#39;,short.class}, {&#39;C&#39;,char.class},
 579             };
 580             HasFields fields = new HasFields();
 581             for (Object[] t : types) {
 582                 for (int kind = 0; kind &lt;= 1; kind++) {
 583                     boolean isStatic = (kind != 0);

 584                     char btc = (Character)t[0];
<span class="line-modified"> 585                     String name = (isStatic ? &quot;s&quot; : &quot;f&quot;) + btc;</span>

 586                     Class&lt;?&gt; type = (Class&lt;?&gt;) t[1];
<span class="line-modified"> 587                     Object value;</span>
<span class="line-modified"> 588                     Field field;</span>
<span class="line-modified"> 589                         try {</span>
<span class="line-removed"> 590                         field = HasFields.class.getDeclaredField(name);</span>
<span class="line-removed"> 591                     } catch (NoSuchFieldException | SecurityException ex) {</span>
<span class="line-removed"> 592                         throw new InternalError(&quot;no field HasFields.&quot;+name);</span>
<span class="line-removed"> 593                     }</span>
<span class="line-removed"> 594                     try {</span>
<span class="line-removed"> 595                         value = field.get(fields);</span>
<span class="line-removed"> 596                     } catch (IllegalArgumentException | IllegalAccessException ex) {</span>
<span class="line-removed"> 597                         throw new InternalError(&quot;cannot fetch field HasFields.&quot;+name);</span>
<span class="line-removed"> 598                     }</span>
 599                     if (type == float.class) {
 600                         float v = &#39;F&#39;;
 601                         if (isStatic)  v++;
 602                         assertTrue(value.equals(v));
 603                     }
<span class="line-modified"> 604                     assertTrue(name.equals(field.getName()));</span>
<span class="line-modified"> 605                     assertTrue(type.equals(field.getType()));</span>
<span class="line-modified"> 606                     assertTrue(isStatic == (Modifier.isStatic(field.getModifiers())));</span>
<span class="line-modified"> 607                     cases.add(new Object[]{ field, value });</span>





 608                 }
 609             }
<span class="line-modified"> 610             cases.add(new Object[]{ new Object[]{ false, HasFields.class, &quot;bogus_fD&quot;, double.class }, Error.class });</span>
<span class="line-modified"> 611             cases.add(new Object[]{ new Object[]{ true,  HasFields.class, &quot;bogus_sL&quot;, Object.class }, Error.class });</span>
<span class="line-modified"> 612             CASES = cases.toArray(new Object[0][]);</span>
























































 613         }
 614     }
 615 
 616     static final int TEST_UNREFLECT = 1, TEST_FIND_FIELD = 2, TEST_FIND_STATIC = 3, TEST_SETTER = 0x10, TEST_BOUND = 0x20, TEST_NPE = 0x40;
 617 
 618     static boolean testModeMatches(int testMode, boolean isStatic) {
 619         switch (testMode) {
 620         case TEST_FIND_STATIC:          return isStatic;
 621         case TEST_FIND_FIELD:           return !isStatic;
 622         case TEST_UNREFLECT:            return true;  // unreflect matches both
 623         }
 624         throw new InternalError(&quot;testMode=&quot;+testMode);
 625     }
 626 
 627     static class Callee {
 628         static Object id() { return called(&quot;id&quot;); }
 629         static Object id(Object x) { return called(&quot;id&quot;, x); }
 630         static Object id(Object x, Object y) { return called(&quot;id&quot;, x, y); }
 631         static Object id(Object x, Object y, Object z) { return called(&quot;id&quot;, x, y, z); }
 632         static Object id(Object... vx) { return called(&quot;id&quot;, vx); }
</pre>
</td>
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 2009, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  */
  23 
  24 package test.java.lang.invoke;
  25 
  26 import org.junit.*;
  27 import test.java.lang.invoke.remote.RemoteExample;
  28 
  29 import java.lang.invoke.MethodHandle;
  30 import java.lang.invoke.MethodHandles;
  31 import java.lang.invoke.MethodHandles.Lookup;
  32 import java.lang.invoke.MethodType;
  33 import java.lang.reflect.Array;
  34 import java.lang.reflect.Field;
  35 import java.lang.reflect.Modifier;
  36 import java.util.ArrayList;
  37 import java.util.Arrays;
  38 import java.util.Collection;
  39 import java.util.Collections;
  40 import java.util.List;
<span class="line-added">  41 import java.util.stream.Stream;</span>
  42 
  43 import static org.junit.Assert.*;
  44 
  45 /**
  46  *
  47  * @author jrose
  48  */
  49 public abstract class MethodHandlesTest {
  50 
  51     static final Class&lt;?&gt; THIS_CLASS = MethodHandlesTest.class;
  52     // How much output?
  53     static int verbosity = 0;
  54 
  55     static {
  56         String vstr = System.getProperty(THIS_CLASS.getSimpleName()+&quot;.verbosity&quot;);
  57         if (vstr == null)
  58             vstr = System.getProperty(THIS_CLASS.getName()+&quot;.verbosity&quot;);
  59         if (vstr != null)  verbosity = Integer.parseInt(vstr);
  60     }
  61 
</pre>
<hr />
<pre>
 529                                      Throwable actual) {
 530         if (expected.isInstance(actual))  return;
 531         actual.printStackTrace();
 532         assertEquals(expected, actual.getClass());
 533     }
 534 
 535     static final boolean DEBUG_METHOD_HANDLE_NAMES = Boolean.getBoolean(&quot;java.lang.invoke.MethodHandle.DEBUG_NAMES&quot;);
 536 
 537     // rough check of name string
 538     static void assertNameStringContains(MethodHandle x, String s) {
 539         if (!DEBUG_METHOD_HANDLE_NAMES) {
 540             // ignore s
 541             assertEquals(&quot;MethodHandle&quot;+x.type(), x.toString());
 542             return;
 543         }
 544         if (x.toString().contains(s))  return;
 545         assertEquals(s, x);
 546     }
 547 
 548     public static class HasFields {
<span class="line-modified"> 549         boolean iZ = false;</span>
<span class="line-modified"> 550         byte iB = (byte)&#39;B&#39;;</span>
<span class="line-modified"> 551         short iS = (short)&#39;S&#39;;</span>
<span class="line-modified"> 552         char iC = &#39;C&#39;;</span>
<span class="line-modified"> 553         int iI = &#39;I&#39;;</span>
<span class="line-modified"> 554         long iJ = &#39;J&#39;;</span>
<span class="line-modified"> 555         float iF = &#39;F&#39;;</span>
<span class="line-modified"> 556         double iD = &#39;D&#39;;</span>
 557         static boolean sZ = true;
 558         static byte sB = 1+(byte)&#39;B&#39;;
 559         static short sS = 1+(short)&#39;S&#39;;
 560         static char sC = 1+&#39;C&#39;;
 561         static int sI = 1+&#39;I&#39;;
 562         static long sJ = 1+&#39;J&#39;;
 563         static float sF = 1+&#39;F&#39;;
 564         static double sD = 1+&#39;D&#39;;
 565 
<span class="line-modified"> 566         // final fields</span>
<span class="line-modified"> 567         final boolean fiZ = false;</span>
<span class="line-modified"> 568         final byte fiB = 2+(byte)&#39;B&#39;;</span>
<span class="line-modified"> 569         final short fiS = 2+(short)&#39;S&#39;;</span>
<span class="line-modified"> 570         final char fiC = 2+&#39;C&#39;;</span>
<span class="line-modified"> 571         final int fiI = 2+&#39;I&#39;;</span>
<span class="line-added"> 572         final long fiJ = 2+&#39;J&#39;;</span>
<span class="line-added"> 573         final float fiF = 2+&#39;F&#39;;</span>
<span class="line-added"> 574         final double fiD = 2+&#39;D&#39;;</span>
<span class="line-added"> 575         final static boolean fsZ = false;</span>
<span class="line-added"> 576         final static byte fsB = 3+(byte)&#39;B&#39;;</span>
<span class="line-added"> 577         final static short fsS = 3+(short)&#39;S&#39;;</span>
<span class="line-added"> 578         final static char fsC = 3+&#39;C&#39;;</span>
<span class="line-added"> 579         final static int fsI = 3+&#39;I&#39;;</span>
<span class="line-added"> 580         final static long fsJ = 3+&#39;J&#39;;</span>
<span class="line-added"> 581         final static float fsF = 3+&#39;F&#39;;</span>
<span class="line-added"> 582         final static double fsD = 3+&#39;D&#39;;</span>
<span class="line-added"> 583 </span>
<span class="line-added"> 584         Object iL = &#39;L&#39;;</span>
<span class="line-added"> 585         String iR = &quot;iR&quot;;</span>
<span class="line-added"> 586         static Object sL = 1+&#39;L&#39;;</span>
<span class="line-added"> 587         static String sR = &quot;sR&quot;;</span>
<span class="line-added"> 588         final Object fiL = 2+&#39;L&#39;;</span>
<span class="line-added"> 589         final String fiR = &quot;fiR&quot;;</span>
<span class="line-added"> 590         final static Object fsL = 3+&#39;L&#39;;</span>
<span class="line-added"> 591         final static String fsR = &quot;fsR&quot;;</span>
<span class="line-added"> 592 </span>
<span class="line-added"> 593         static final ArrayList&lt;Object[]&gt; STATIC_FIELD_CASES = new ArrayList&lt;&gt;();</span>
<span class="line-added"> 594         static final ArrayList&lt;Object[]&gt; INSTANCE_FIELD_CASES = new ArrayList&lt;&gt;();</span>
 595         static {

 596             Object types[][] = {
 597                 {&#39;L&#39;,Object.class}, {&#39;R&#39;,String.class},
 598                 {&#39;I&#39;,int.class}, {&#39;J&#39;,long.class},
 599                 {&#39;F&#39;,float.class}, {&#39;D&#39;,double.class},
 600                 {&#39;Z&#39;,boolean.class}, {&#39;B&#39;,byte.class},
 601                 {&#39;S&#39;,short.class}, {&#39;C&#39;,char.class},
 602             };
 603             HasFields fields = new HasFields();
 604             for (Object[] t : types) {
 605                 for (int kind = 0; kind &lt;= 1; kind++) {
 606                     boolean isStatic = (kind != 0);
<span class="line-added"> 607                     ArrayList&lt;Object[]&gt; cases = isStatic ? STATIC_FIELD_CASES : INSTANCE_FIELD_CASES;</span>
 608                     char btc = (Character)t[0];
<span class="line-modified"> 609                     String fname = (isStatic ? &quot;s&quot; : &quot;i&quot;) + btc;</span>
<span class="line-added"> 610                     String finalFname = (isStatic ? &quot;fs&quot; : &quot;fi&quot;) + btc;</span>
 611                     Class&lt;?&gt; type = (Class&lt;?&gt;) t[1];
<span class="line-modified"> 612                     // non-final field</span>
<span class="line-modified"> 613                     Field nonFinalField = getField(fname, type);</span>
<span class="line-modified"> 614                     Object value = getValue(fields, nonFinalField);</span>









 615                     if (type == float.class) {
 616                         float v = &#39;F&#39;;
 617                         if (isStatic)  v++;
 618                         assertTrue(value.equals(v));
 619                     }
<span class="line-modified"> 620                     assertTrue(isStatic == (Modifier.isStatic(nonFinalField.getModifiers())));</span>
<span class="line-modified"> 621                     cases.add(new Object[]{ nonFinalField, value });</span>
<span class="line-modified"> 622 </span>
<span class="line-modified"> 623                     // setAccessible(true) on final field but static final field only has read access</span>
<span class="line-added"> 624                     Field finalField = getField(finalFname, type);</span>
<span class="line-added"> 625                     Object fvalue = getValue(fields, finalField);</span>
<span class="line-added"> 626                     finalField.setAccessible(true);</span>
<span class="line-added"> 627                     assertTrue(isStatic == (Modifier.isStatic(finalField.getModifiers())));</span>
<span class="line-added"> 628                     cases.add(new Object[]{ finalField, fvalue, Error.class});</span>
 629                 }
 630             }
<span class="line-modified"> 631             INSTANCE_FIELD_CASES.add(new Object[]{ new Object[]{ false, HasFields.class, &quot;bogus_fD&quot;, double.class }, Error.class });</span>
<span class="line-modified"> 632             STATIC_FIELD_CASES.add(new Object[]{ new Object[]{ true,  HasFields.class, &quot;bogus_sL&quot;, Object.class }, Error.class });</span>
<span class="line-modified"> 633         }</span>
<span class="line-added"> 634 </span>
<span class="line-added"> 635         private static Field getField(String name, Class&lt;?&gt; type) {</span>
<span class="line-added"> 636             try {</span>
<span class="line-added"> 637                 Field field = HasFields.class.getDeclaredField(name);</span>
<span class="line-added"> 638                 assertTrue(name.equals(field.getName()));</span>
<span class="line-added"> 639                 assertTrue(type.equals(field.getType()));</span>
<span class="line-added"> 640                 return field;</span>
<span class="line-added"> 641             } catch (NoSuchFieldException | SecurityException ex) {</span>
<span class="line-added"> 642                 throw new InternalError(&quot;no field HasFields.&quot;+name);</span>
<span class="line-added"> 643             }</span>
<span class="line-added"> 644         }</span>
<span class="line-added"> 645 </span>
<span class="line-added"> 646         private static Object getValue(Object o, Field field) {</span>
<span class="line-added"> 647             try {</span>
<span class="line-added"> 648                 return field.get(o);</span>
<span class="line-added"> 649             } catch (IllegalArgumentException | IllegalAccessException ex) {</span>
<span class="line-added"> 650                 throw new InternalError(&quot;cannot fetch field HasFields.&quot;+field.getName());</span>
<span class="line-added"> 651             }</span>
<span class="line-added"> 652         }</span>
<span class="line-added"> 653 </span>
<span class="line-added"> 654         static Object[][] testCasesFor(int testMode) {</span>
<span class="line-added"> 655             Stream&lt;Object[]&gt; cases;</span>
<span class="line-added"> 656             if ((testMode &amp; TEST_UNREFLECT) != 0) {</span>
<span class="line-added"> 657                 cases = Stream.concat(STATIC_FIELD_CASES.stream(), INSTANCE_FIELD_CASES.stream());</span>
<span class="line-added"> 658             } else if ((testMode &amp; TEST_FIND_STATIC) != 0) {</span>
<span class="line-added"> 659                 cases = STATIC_FIELD_CASES.stream();</span>
<span class="line-added"> 660             } else if ((testMode &amp; TEST_FIND_FIELD) != 0) {</span>
<span class="line-added"> 661                 cases = INSTANCE_FIELD_CASES.stream();</span>
<span class="line-added"> 662             } else {</span>
<span class="line-added"> 663                 throw new InternalError(&quot;unexpected test mode: &quot; + testMode);</span>
<span class="line-added"> 664             }</span>
<span class="line-added"> 665             return cases.map(c -&gt; mapTestCase(testMode, c)).toArray(Object[][]::new);</span>
<span class="line-added"> 666 </span>
<span class="line-added"> 667         }</span>
<span class="line-added"> 668 </span>
<span class="line-added"> 669         private static Object[] mapTestCase(int testMode, Object[] c) {</span>
<span class="line-added"> 670             // non-final fields (2-element) and final fields (3-element) if not TEST_SETTER</span>
<span class="line-added"> 671             if (c.length == 2 || (testMode &amp; TEST_SETTER) == 0)</span>
<span class="line-added"> 672                 return c;</span>
<span class="line-added"> 673 </span>
<span class="line-added"> 674             // final fields (3-element)</span>
<span class="line-added"> 675             assertTrue((testMode &amp; TEST_SETTER) != 0 &amp;&amp; c[0] instanceof Field &amp;&amp; c[2] == Error.class);</span>
<span class="line-added"> 676             if ((testMode &amp; TEST_UNREFLECT) == 0)</span>
<span class="line-added"> 677                 return new Object[]{ c[0], c[2]};   // negative test case; can&#39;t set on final fields</span>
<span class="line-added"> 678 </span>
<span class="line-added"> 679             // unreflectSetter grants write access on instance final field if accessible flag is true</span>
<span class="line-added"> 680             // hence promote the negative test case to positive test case</span>
<span class="line-added"> 681             Field f = (Field) c[0];</span>
<span class="line-added"> 682             int mods = f.getModifiers();</span>
<span class="line-added"> 683             if (!Modifier.isFinal(mods) || (!Modifier.isStatic(mods) &amp;&amp; f.isAccessible())) {</span>
<span class="line-added"> 684                 // positive test case</span>
<span class="line-added"> 685                 return new Object[]{ c[0], c[1] };</span>
<span class="line-added"> 686             } else {</span>
<span class="line-added"> 687                 // otherwise, negative test case</span>
<span class="line-added"> 688                 return new Object[]{ c[0], c[2]};</span>
<span class="line-added"> 689             }</span>
 690         }
 691     }
 692 
 693     static final int TEST_UNREFLECT = 1, TEST_FIND_FIELD = 2, TEST_FIND_STATIC = 3, TEST_SETTER = 0x10, TEST_BOUND = 0x20, TEST_NPE = 0x40;
 694 
 695     static boolean testModeMatches(int testMode, boolean isStatic) {
 696         switch (testMode) {
 697         case TEST_FIND_STATIC:          return isStatic;
 698         case TEST_FIND_FIELD:           return !isStatic;
 699         case TEST_UNREFLECT:            return true;  // unreflect matches both
 700         }
 701         throw new InternalError(&quot;testMode=&quot;+testMode);
 702     }
 703 
 704     static class Callee {
 705         static Object id() { return called(&quot;id&quot;); }
 706         static Object id(Object x) { return called(&quot;id&quot;, x); }
 707         static Object id(Object x, Object y) { return called(&quot;id&quot;, x, y); }
 708         static Object id(Object x, Object y, Object z) { return called(&quot;id&quot;, x, y, z); }
 709         static Object id(Object... vx) { return called(&quot;id&quot;, vx); }
</pre>
</td>
</tr>
</table>
<center><a href="MethodHandlesGeneralTest.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="TryFinallyTest.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
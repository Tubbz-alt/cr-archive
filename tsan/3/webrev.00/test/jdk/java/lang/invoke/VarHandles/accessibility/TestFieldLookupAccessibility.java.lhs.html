<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames test/jdk/java/lang/invoke/VarHandles/accessibility/TestFieldLookupAccessibility.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (c) 2016, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 /* @test
<a name="1" id="anc1"></a><span class="line-modified"> 25  * @bug 8152645</span>
 26  * @summary test field lookup accessibility of MethodHandles and VarHandles
 27  * @compile TestFieldLookupAccessibility.java
 28  *          pkg/A.java pkg/B_extends_A.java pkg/C.java
 29  *          pkg/subpkg/B_extends_A.java pkg/subpkg/C.java
 30  * @run testng/othervm TestFieldLookupAccessibility
 31  */
 32 
 33 import org.testng.Assert;
 34 import org.testng.annotations.DataProvider;
 35 import org.testng.annotations.Test;
 36 import pkg.B_extends_A;
 37 
 38 import java.lang.invoke.MethodHandles;
 39 import java.lang.reflect.Field;
 40 import java.lang.reflect.Modifier;
 41 import java.util.ArrayList;
 42 import java.util.HashMap;
 43 import java.util.HashSet;
 44 import java.util.List;
 45 import java.util.Map;
 46 import java.util.Set;
 47 import java.util.stream.Collectors;
 48 import java.util.stream.Stream;
 49 
 50 public class TestFieldLookupAccessibility {
 51 
 52     // The set of possible field lookup mechanisms
 53     enum FieldLookup {
 54         MH_GETTER() {
 55             Object lookup(MethodHandles.Lookup l, Field f) throws Exception {
 56                 return l.findGetter(f.getDeclaringClass(), f.getName(), f.getType());
 57             }
 58 
 59             boolean isAccessible(Field f) {
 60                 return !Modifier.isStatic(f.getModifiers());
 61             }
 62         },
 63         MH_SETTER() {
 64             Object lookup(MethodHandles.Lookup l, Field f) throws Exception {
 65                 return l.findSetter(f.getDeclaringClass(), f.getName(), f.getType());
 66             }
 67 
 68             boolean isAccessible(Field f) {
 69                 return !Modifier.isStatic(f.getModifiers()) &amp;&amp; !Modifier.isFinal(f.getModifiers());
 70             }
 71         },
 72         MH_STATIC_GETTER() {
 73             Object lookup(MethodHandles.Lookup l, Field f) throws Exception {
 74                 return l.findStaticGetter(f.getDeclaringClass(), f.getName(), f.getType());
 75             }
 76 
 77             boolean isAccessible(Field f) {
 78                 return Modifier.isStatic(f.getModifiers());
 79             }
 80         },
 81         MH_STATIC_SETTER() {
 82             Object lookup(MethodHandles.Lookup l, Field f) throws Exception {
 83                 return l.findStaticSetter(f.getDeclaringClass(), f.getName(), f.getType());
 84             }
 85 
 86             boolean isAccessible(Field f) {
 87                 return Modifier.isStatic(f.getModifiers()) &amp;&amp; !Modifier.isFinal(f.getModifiers());
 88             }
 89         },
 90         MH_UNREFLECT_GETTER() {
 91             Object lookup(MethodHandles.Lookup l, Field f) throws Exception {
 92                 return l.unreflectGetter(f);
 93             }
 94         },
 95         MH_UNREFLECT_GETTER_ACCESSIBLE() {
 96             Object lookup(MethodHandles.Lookup l, Field f) throws Exception {
 97                 return l.unreflectGetter(cloneAndSetAccessible(f));
 98             }
<a name="2" id="anc2"></a>





 99         },
100         MH_UNREFLECT_SETTER() {
101             Object lookup(MethodHandles.Lookup l, Field f) throws Exception {
102                 return l.unreflectSetter(f);
103             }
104 
105             boolean isAccessible(Field f) {
<a name="3" id="anc3"></a><span class="line-modified">106                 return f.isAccessible() || !Modifier.isFinal(f.getModifiers());</span>
107             }
108         },
109         MH_UNREFLECT_SETTER_ACCESSIBLE() {
110             Object lookup(MethodHandles.Lookup l, Field f) throws Exception {
111                 return l.unreflectSetter(cloneAndSetAccessible(f));
112             }
<a name="4" id="anc4"></a>













113         },
114         VH() {
115             Object lookup(MethodHandles.Lookup l, Field f) throws Exception {
116                 return l.findVarHandle(f.getDeclaringClass(), f.getName(), f.getType());
117             }
118 
119             boolean isAccessible(Field f) {
120                 return !Modifier.isStatic(f.getModifiers());
121             }
122         },
123         VH_STATIC() {
124             Object lookup(MethodHandles.Lookup l, Field f) throws Exception {
125                 return l.findStaticVarHandle(f.getDeclaringClass(), f.getName(), f.getType());
126             }
127 
128             boolean isAccessible(Field f) {
129                 return Modifier.isStatic(f.getModifiers());
130             }
131         },
132         VH_UNREFLECT() {
133             Object lookup(MethodHandles.Lookup l, Field f) throws Exception {
134                 return l.unreflectVarHandle(f);
135             }
136         };
137 
138         // Look up a handle to a field
139         abstract Object lookup(MethodHandles.Lookup l, Field f) throws Exception;
140 
141         boolean isAccessible(Field f) {
142             return true;
143         }
144 
<a name="5" id="anc5"></a>



145         static Field cloneAndSetAccessible(Field f) throws Exception {
146             // Clone to avoid mutating source field
147             f = f.getDeclaringClass().getDeclaredField(f.getName());
148             f.setAccessible(true);
149             return f;
150         }
151     }
152 
153     @DataProvider
154     public Object[][] lookupProvider() throws Exception {
155         Stream&lt;List&lt;Object&gt;&gt; baseCases = Stream.of(
156                 // Look up from same package
157                 List.of(pkg.A.class, pkg.A.lookup(), pkg.A.inaccessibleFields()),
158                 List.of(pkg.A.class, pkg.A.lookup(), pkg.A.inaccessibleFields()),
159                 List.of(pkg.A.class, B_extends_A.lookup(), B_extends_A.inaccessibleFields()),
160                 List.of(pkg.A.class, pkg.C.lookup(), pkg.C.inaccessibleFields()),
161 
162                 // Look up from sub-package
163                 List.of(pkg.A.class, pkg.subpkg.B_extends_A.lookup(), pkg.subpkg.B_extends_A.inaccessibleFields()),
164                 List.of(pkg.A.class, pkg.subpkg.C.lookup(), pkg.subpkg.C.inaccessibleFields())
165         );
166 
167         // Cross product base cases with the field lookup classes
168         return baseCases.
169                 flatMap(l -&gt; Stream.of(FieldLookup.values()).map(fl -&gt; prepend(fl, l))).
170                 toArray(Object[][]::new);
171     }
172 
173     private static Object[] prepend(Object o, List&lt;Object&gt; l) {
174         List&lt;Object&gt; pl = new ArrayList&lt;&gt;();
175         pl.add(o);
176         pl.addAll(l);
177         return pl.toArray();
178     }
179 
180     @Test(dataProvider = &quot;lookupProvider&quot;)
181     public void test(FieldLookup fl, Class&lt;?&gt; src, MethodHandles.Lookup l, Set&lt;String&gt; inaccessibleFields) {
182         // Add to the expected failures all inaccessible fields due to accessibility modifiers
<a name="6" id="anc6"></a><span class="line-modified">183         Set&lt;String&gt; expected = new HashSet&lt;&gt;(inaccessibleFields);</span>
184         Map&lt;Field, Throwable&gt; actual = new HashMap&lt;&gt;();
185 
186         for (Field f : fields(src)) {
187             // Add to the expected failures all inaccessible fields due to static/final modifiers
188             if (!fl.isAccessible(f)) {
189                 expected.add(f.getName());
190             }
191 
192             try {
193                 fl.lookup(l, f);
194             }
195             catch (Throwable t) {
196                 // Lookup failed, add to the actual failures
197                 actual.put(f, t);
198             }
199         }
200 
201         Set&lt;String&gt; actualFieldNames = actual.keySet().stream().map(Field::getName).
202                 collect(Collectors.toSet());
203         if (!actualFieldNames.equals(expected)) {
204             if (actualFieldNames.isEmpty()) {
<a name="7" id="anc7"></a><span class="line-modified">205                 // Setting the accessibility bit of a Field grants access under</span>
<span class="line-removed">206                 // all conditions for MethodHander getters and setters</span>
<span class="line-removed">207                 if (fl != FieldLookup.MH_UNREFLECT_GETTER_ACCESSIBLE &amp;&amp;</span>
<span class="line-removed">208                     fl != FieldLookup.MH_UNREFLECT_SETTER_ACCESSIBLE) {</span>
<span class="line-removed">209                     Assert.assertEquals(actualFieldNames, expected, &quot;No accessibility failures:&quot;);</span>
<span class="line-removed">210                 }</span>
211             }
212             else {
213                 Assert.assertEquals(actualFieldNames, expected, &quot;Accessibility failures differ:&quot;);
214             }
215         }
216         else {
217             if (!actual.values().stream().allMatch(IllegalAccessException.class::isInstance)) {
218                 Assert.fail(&quot;Expecting an IllegalArgumentException for all failures &quot; + actual);
219             }
220         }
221     }
222 
223     static List&lt;Field&gt; fields(Class&lt;?&gt; src) {
224         return List.of(src.getDeclaredFields());
225     }
226 }
<a name="8" id="anc8"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="8" type="hidden" />
</body>
</html>
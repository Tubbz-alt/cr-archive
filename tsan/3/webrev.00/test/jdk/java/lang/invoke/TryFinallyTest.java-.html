<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old test/jdk/java/lang/invoke/TryFinallyTest.java</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2015, 2016, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 /* @test
 27  * @bug 8139885 8150824 8150825 8194238
 28  * @run testng/othervm -ea -esa test.java.lang.invoke.TryFinallyTest
 29  */
 30 
 31 package test.java.lang.invoke;
 32 
 33 import java.lang.invoke.MethodHandle;
 34 import java.lang.invoke.MethodHandles;
 35 import java.lang.invoke.MethodHandles.Lookup;
 36 import java.lang.invoke.MethodType;
 37 
 38 import static java.lang.invoke.MethodType.methodType;
 39 
 40 import static org.testng.AssertJUnit.*;
 41 
 42 import org.testng.annotations.*;
 43 
 44 /**
 45  * Tests for the tryFinally method handle combinator introduced in JEP 274.
 46  */
 47 public class TryFinallyTest {
 48 
 49     static final Lookup LOOKUP = MethodHandles.lookup();
 50 
 51     @Test
 52     public static void testTryFinally() throws Throwable {
 53         MethodHandle hello = MethodHandles.tryFinally(TryFinally.MH_greet, TryFinally.MH_exclaim);
 54         assertEquals(TryFinally.MT_hello, hello.type());
 55         assertEquals(&quot;Hello, world!&quot;, hello.invoke(&quot;world&quot;));
 56     }
 57 
 58     @Test
 59     public static void testTryFinallyVoid() throws Throwable {
 60         MethodHandle tfVoid = MethodHandles.tryFinally(TryFinally.MH_print, TryFinally.MH_printMore);
 61         assertEquals(TryFinally.MT_printHello, tfVoid.type());
 62         tfVoid.invoke(&quot;world&quot;);
 63     }
 64 
 65     @Test
 66     public static void testTryFinallySublist() throws Throwable {
 67         MethodHandle helloMore = MethodHandles.tryFinally(TryFinally.MH_greetMore, TryFinally.MH_exclaimMore);
 68         assertEquals(TryFinally.MT_moreHello, helloMore.type());
 69         assertEquals(&quot;Hello, world and universe (but world first)!&quot;, helloMore.invoke(&quot;world&quot;, &quot;universe&quot;));
 70     }
 71 
 72     @DataProvider
 73     static Object[][] omitTrailingArguments() {
 74         MethodHandle c = TryFinally.MH_voidCleanup;
 75         return new Object[][]{
 76                 {c},
 77                 {MethodHandles.dropArguments(c, 1, int.class)},
 78                 {MethodHandles.dropArguments(c, 1, int.class, long.class)},
 79                 {MethodHandles.dropArguments(c, 1, int.class, long.class, Object.class, int.class)},
 80                 {MethodHandles.dropArguments(c, 1, int.class, long.class, Object.class, int.class, long.class)}
 81         };
 82     }
 83 
 84     @Test(dataProvider = &quot;omitTrailingArguments&quot;)
 85     public static void testTryFinallyOmitTrailingArguments(MethodHandle cleanup) throws Throwable {
 86         MethodHandle tf = MethodHandles.tryFinally(TryFinally.MH_dummyTarget, cleanup);
 87         tf.invoke(1, 2L, &quot;a&quot;, 23, 42L, &quot;b&quot;);
 88     }
 89 
 90     @DataProvider
 91     static Object[][] negativeTestData() {
 92         MethodHandle intid = MethodHandles.identity(int.class);
 93         MethodHandle intco = MethodHandles.constant(int.class, 0);
 94         MethodHandle errTarget = MethodHandles.dropArguments(intco, 0, int.class, double.class, String.class, int.class);
 95         MethodHandle errCleanup = MethodHandles.dropArguments(MethodHandles.constant(int.class, 0), 0, Throwable.class,
 96                 int.class, double.class, Object.class);
 97         MethodHandle voidTarget = TryFinally.MH_voidTarget;
 98         MethodHandle voidICleanup = MethodHandles.dropArguments(TryFinally.MH_voidCleanup, 1, int.class);
 99         return new Object[][]{
100                 {intid, MethodHandles.identity(double.class),
101                         &quot;target and return types must match: double != int&quot;},
102                 {intid, MethodHandles.dropArguments(intid, 0, String.class),
103                         &quot;cleanup first argument and Throwable must match: (String,int)int != class java.lang.Throwable&quot;},
104                 {intid, MethodHandles.dropArguments(intid, 0, Throwable.class, double.class),
105                         &quot;cleanup second argument and target return type must match: (Throwable,double,int)int != int&quot;},
106                 {errTarget, errCleanup,
107                         &quot;cleanup parameters after (Throwable,result) and target parameter list prefix must match: &quot; +
108                                 errCleanup.type() + &quot; != &quot; + errTarget.type()},
109                 {voidTarget, voidICleanup,
110                         &quot;cleanup parameters after (Throwable,result) and target parameter list prefix must match: &quot; +
111                                 voidICleanup.type() + &quot; != &quot; + voidTarget.type()}
112         };
113     }
114 
115     @Test(dataProvider = &quot;negativeTestData&quot;)
116     public static void testTryFinallyNegative(MethodHandle target, MethodHandle cleanup, String expectedMessage) {
117         boolean caught = false;
118         try {
119             MethodHandles.tryFinally(target, cleanup);
120         } catch (IllegalArgumentException iae) {
121             assertEquals(expectedMessage, iae.getMessage());
122             caught = true;
123         }
124         assertTrue(caught);
125     }
126 
127     @Test
128     public static void testTryFinallyThrowableCheck() {
129         MethodHandle mh = MethodHandles.tryFinally(TryFinally.MH_throwingTarget,
130                                                    TryFinally.MH_catchingCleanup);
131         try {
132             mh.invoke();
133             fail(&quot;ClassCastException expected&quot;);
134         } catch (Throwable t) {
135             assertTrue(&quot;Throwable not assignable to ClassCastException: &quot; + t,
136                        ClassCastException.class.isAssignableFrom(t.getClass()));
137         }
138     }
139 
140     static class TryFinally {
141 
142         static String greet(String whom) {
143             return &quot;Hello, &quot; + whom;
144         }
145 
146         static String exclaim(Throwable t, String r, String whom) {
147             return r + &quot;!&quot;;
148         }
149 
150         static void print(String what) {
151             System.out.print(&quot;Hello, &quot; + what);
152         }
153 
154         static void printMore(Throwable t, String what) {
155             System.out.println(&quot;!&quot;);
156         }
157 
158         static String greetMore(String first, String second) {
159             return &quot;Hello, &quot; + first + &quot; and &quot; + second;
160         }
161 
162         static String exclaimMore(Throwable t, String r, String first) {
163             return r + &quot; (but &quot; + first + &quot; first)!&quot;;
164         }
165 
166         static void voidTarget() {}
167 
168         static void voidCleanup(Throwable t) {}
169 
170         static class T1 extends Throwable {}
171 
172         static class T2 extends Throwable {}
173 
174         static void throwingTarget() throws Throwable {
175             throw new T1();
176         }
177 
178         static void catchingCleanup(T2 t) throws Throwable {
179         }
180 
181         static final Class&lt;TryFinally&gt; TRY_FINALLY = TryFinally.class;
182 
183         static final MethodType MT_greet = methodType(String.class, String.class);
184         static final MethodType MT_exclaim = methodType(String.class, Throwable.class, String.class, String.class);
185         static final MethodType MT_print = methodType(void.class, String.class);
186         static final MethodType MT_printMore = methodType(void.class, Throwable.class, String.class);
187         static final MethodType MT_greetMore = methodType(String.class, String.class, String.class);
188         static final MethodType MT_exclaimMore = methodType(String.class, Throwable.class, String.class, String.class);
189         static final MethodType MT_voidTarget = methodType(void.class);
190         static final MethodType MT_voidCleanup = methodType(void.class, Throwable.class);
191         static final MethodType MT_throwingTarget = methodType(void.class);
192         static final MethodType MT_catchingCleanup = methodType(void.class, T2.class);
193 
194         static final MethodHandle MH_greet;
195         static final MethodHandle MH_exclaim;
196         static final MethodHandle MH_print;
197         static final MethodHandle MH_printMore;
198         static final MethodHandle MH_greetMore;
199         static final MethodHandle MH_exclaimMore;
200         static final MethodHandle MH_voidTarget;
201         static final MethodHandle MH_voidCleanup;
202         static final MethodHandle MH_throwingTarget;
203         static final MethodHandle MH_catchingCleanup;
204 
205         static final MethodHandle MH_dummyTarget;
206 
207         static final MethodType MT_hello = methodType(String.class, String.class);
208         static final MethodType MT_printHello = methodType(void.class, String.class);
209         static final MethodType MT_moreHello = methodType(String.class, String.class, String.class);
210 
211         static {
212             try {
213                 MH_greet = LOOKUP.findStatic(TRY_FINALLY, &quot;greet&quot;, MT_greet);
214                 MH_exclaim = LOOKUP.findStatic(TRY_FINALLY, &quot;exclaim&quot;, MT_exclaim);
215                 MH_print = LOOKUP.findStatic(TRY_FINALLY, &quot;print&quot;, MT_print);
216                 MH_printMore = LOOKUP.findStatic(TRY_FINALLY, &quot;printMore&quot;, MT_printMore);
217                 MH_greetMore = LOOKUP.findStatic(TRY_FINALLY, &quot;greetMore&quot;, MT_greetMore);
218                 MH_exclaimMore = LOOKUP.findStatic(TRY_FINALLY, &quot;exclaimMore&quot;, MT_exclaimMore);
219                 MH_voidTarget = LOOKUP.findStatic(TRY_FINALLY, &quot;voidTarget&quot;, MT_voidTarget);
220                 MH_voidCleanup = LOOKUP.findStatic(TRY_FINALLY, &quot;voidCleanup&quot;, MT_voidCleanup);
221                 MH_throwingTarget = LOOKUP.findStatic(TRY_FINALLY, &quot;throwingTarget&quot;, MT_throwingTarget);
222                 MH_catchingCleanup = LOOKUP.findStatic(TRY_FINALLY, &quot;catchingCleanup&quot;, MT_catchingCleanup);
223                 MH_dummyTarget = MethodHandles.dropArguments(MH_voidTarget, 0, int.class, long.class, Object.class,
224                         int.class, long.class, Object.class);
225             } catch (Exception e) {
226                 throw new ExceptionInInitializerError(e);
227             }
228         }
229 
230     }
231 
232 }
    </pre>
  </body>
</html>
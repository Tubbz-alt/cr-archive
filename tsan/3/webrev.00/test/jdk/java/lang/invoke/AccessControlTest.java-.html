<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old test/jdk/java/lang/invoke/AccessControlTest.java</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2012, 2018, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 /* @test
 25  * @summary test access checking by java.lang.invoke.MethodHandles.Lookup
 26  * @compile AccessControlTest.java AccessControlTest_subpkg/Acquaintance_remote.java
 27  * @run testng/othervm test.java.lang.invoke.AccessControlTest
 28  */
 29 
 30 package test.java.lang.invoke;
 31 
 32 import java.lang.invoke.*;
 33 import java.lang.reflect.*;
 34 import java.lang.reflect.Modifier;
 35 import java.util.*;
 36 import org.testng.*;
 37 import org.testng.annotations.*;
 38 
 39 import static java.lang.invoke.MethodHandles.*;
 40 import static java.lang.invoke.MethodHandles.Lookup.*;
 41 import static java.lang.invoke.MethodType.*;
 42 import static org.testng.Assert.*;
 43 
 44 import test.java.lang.invoke.AccessControlTest_subpkg.Acquaintance_remote;
 45 
 46 
 47 /**
 48  * Test many combinations of Lookup access and cross-class lookupStatic.
 49  * @author jrose
 50  */
 51 public class AccessControlTest {
 52     static final Class&lt;?&gt; THIS_CLASS = AccessControlTest.class;
 53     // How much output?
 54     static int verbosity = 0;
 55     static {
 56         String vstr = System.getProperty(THIS_CLASS.getSimpleName()+&quot;.verbosity&quot;);
 57         if (vstr == null)
 58             vstr = System.getProperty(THIS_CLASS.getName()+&quot;.verbosity&quot;);
 59         if (vstr != null)  verbosity = Integer.parseInt(vstr);
 60     }
 61 
 62     private class LookupCase implements Comparable&lt;LookupCase&gt; {
 63         final Lookup   lookup;
 64         final Class&lt;?&gt; lookupClass;
 65         final int      lookupModes;
 66         public LookupCase(Lookup lookup) {
 67             this.lookup = lookup;
 68             this.lookupClass = lookup.lookupClass();
 69             this.lookupModes = lookup.lookupModes();
 70             assert(lookupString().equals(lookup.toString()));
 71             numberOf(lookupClass().getClassLoader()); // assign CL#
 72         }
 73         public LookupCase(Class&lt;?&gt; lookupClass, int lookupModes) {
 74             this.lookup = null;
 75             this.lookupClass = lookupClass;
 76             this.lookupModes = lookupModes;
 77             numberOf(lookupClass().getClassLoader()); // assign CL#
 78         }
 79 
 80         public final Class&lt;?&gt; lookupClass() { return lookupClass; }
 81         public final int      lookupModes() { return lookupModes; }
 82 
 83         public Lookup lookup() { lookup.getClass(); return lookup; }
 84 
 85         @Override
 86         public int compareTo(LookupCase that) {
 87             Class&lt;?&gt; c1 = this.lookupClass();
 88             Class&lt;?&gt; c2 = that.lookupClass();
 89             if (c1 != c2) {
 90                 int cmp = c1.getName().compareTo(c2.getName());
 91                 if (cmp != 0)  return cmp;
 92                 cmp = numberOf(c1.getClassLoader()) - numberOf(c2.getClassLoader());
 93                 assert(cmp != 0);
 94                 return cmp;
 95             }
 96             return -(this.lookupModes() - that.lookupModes());
 97         }
 98 
 99         @Override
100         public boolean equals(Object that) {
101             return (that instanceof LookupCase &amp;&amp; equals((LookupCase)that));
102         }
103         public boolean equals(LookupCase that) {
104             return (this.lookupClass() == that.lookupClass() &amp;&amp;
105                     this.lookupModes() == that.lookupModes());
106         }
107 
108         @Override
109         public int hashCode() {
110             return lookupClass().hashCode() + (lookupModes() * 31);
111         }
112 
113         /** Simulate all assertions in the spec. for Lookup.toString. */
114         private String lookupString() {
115             String name = lookupClass.getName();
116             String suffix = &quot;&quot;;
117             if (lookupModes == 0)
118                 suffix = &quot;/noaccess&quot;;
119             else if (lookupModes == PUBLIC)
120                 suffix = &quot;/public&quot;;
121              else if (lookupModes == (PUBLIC|UNCONDITIONAL))
122                 suffix = &quot;/publicLookup&quot;;
123             else if (lookupModes == (PUBLIC|MODULE))
124                 suffix = &quot;/module&quot;;
125             else if (lookupModes == (PUBLIC|MODULE|PACKAGE))
126                 suffix = &quot;/package&quot;;
127             else if (lookupModes == (PUBLIC|MODULE|PACKAGE|PRIVATE))
128                 suffix = &quot;/private&quot;;
129             else if (lookupModes == (PUBLIC|MODULE|PACKAGE|PRIVATE|PROTECTED))
130                 suffix = &quot;&quot;;
131             else
132                 suffix = &quot;/#&quot;+Integer.toHexString(lookupModes);
133             return name+suffix;
134         }
135 
136         /** Simulate all assertions from the spec. for Lookup.in:
137          * &lt;hr&gt;
138          * Creates a lookup on the specified new lookup class.
139          * [A1] The resulting object will report the specified
140          * class as its own {@link #lookupClass lookupClass}.
141          * &lt;p&gt;
142          * [A2] However, the resulting {@code Lookup} object is guaranteed
143          * to have no more access capabilities than the original.
144          * In particular, access capabilities can be lost as follows:&lt;ul&gt;
145          * &lt;li&gt; [A3] If the old lookup class is in a named module, and the new
146          * lookup class is in a different module {@code M}, then no members, not
147          * even public members in {@code M}&#39;s exported packages, will be accessible.
148          * The exception to this is when this lookup is publicLookup, in which case
149          * public access is not lost.
150          * &lt;li&gt; [A4] If the old lookup class is in an unnamed module, and the new
151          * lookup class is a different module then module access is lost.
152          * &lt;li&gt; [A5] If the new lookup class differs from the old one then UNCONDITIONAL
153          * is lost. If the new lookup class is not within the same package member as the
154          * old one, protected members will not be accessible by virtue of inheritance.
155          * (Protected members may continue to be accessible because of package sharing.)
156          * &lt;li&gt; [A6] If the new lookup class is in a different package than the old one,
157          * protected and default (package) members will not be accessible.
158          * &lt;li&gt; [A7] If the new lookup class is not within the same package member
159          * as the old one, private members will not be accessible.
160          * &lt;li&gt; [A8] If the new lookup class is not accessible to the old lookup class,
161          * then no members, not even public members, will be accessible.
162          * &lt;li&gt; [A9] (In all other cases, public members will continue to be accessible.)
163          * &lt;/ul&gt;
164          * Other than the above cases, the new lookup will have the same
165          * access capabilities as the original. [A10]
166          * &lt;hr&gt;
167          */
168         public LookupCase in(Class&lt;?&gt; c2) {
169             Class&lt;?&gt; c1 = lookupClass();
170             int m1 = lookupModes();
171             int changed = 0;
172             // for the purposes of access control then treat classes in different unnamed
173             // modules as being in the same module.
174             boolean sameModule = (c1.getModule() == c2.getModule()) ||
175                                  (!c1.getModule().isNamed() &amp;&amp; !c2.getModule().isNamed());
176             boolean samePackage = (c1.getClassLoader() == c2.getClassLoader() &amp;&amp;
177                                    c1.getPackageName().equals(c2.getPackageName()));
178             boolean sameTopLevel = (topLevelClass(c1) == topLevelClass(c2));
179             boolean sameClass = (c1 == c2);
180             assert(samePackage  || !sameTopLevel);
181             assert(sameTopLevel || !sameClass);
182             boolean accessible = sameClass;
183             if ((m1 &amp; PACKAGE) != 0)  accessible |= samePackage;
184             if ((m1 &amp; PUBLIC ) != 0)  accessible |= (c2.getModifiers() &amp; PUBLIC) != 0;
185             if (!sameModule) {
186                 if (c1.getModule().isNamed() &amp;&amp; (m1 &amp; UNCONDITIONAL) == 0) {
187                     accessible = false;  // [A3]
188                 } else {
189                     changed |= (MODULE|PACKAGE|PRIVATE|PROTECTED);    // [A3] [A4]
190                 }
191             }
192             if (!accessible) {
193                 // Different package and no access to c2; lose all access.
194                 changed |= (PUBLIC|MODULE|PACKAGE|PRIVATE|PROTECTED);  // [A8]
195             }
196             if (!samePackage) {
197                 // Different package; loose PACKAGE and lower access.
198                 changed |= (PACKAGE|PRIVATE|PROTECTED);  // [A6]
199             }
200             if (!sameTopLevel) {
201                 // Different top-level class.  Lose PRIVATE and PROTECTED access.
202                 changed |= (PRIVATE|PROTECTED);  // [A5] [A7]
203             }
204             if (!sameClass) {
205                 changed |= (UNCONDITIONAL);     // [A5]
206             } else {
207                 assert(changed == 0);       // [A10] (no deprivation if same class)
208             }
209             if (accessible)  assert((changed &amp; PUBLIC) == 0);  // [A9]
210             int m2 = m1 &amp; ~changed;
211             LookupCase l2 = new LookupCase(c2, m2);
212             assert(l2.lookupClass() == c2); // [A1]
213             assert((m1 | m2) == m1);        // [A2] (no elevation of access)
214             return l2;
215         }
216 
217         @Override
218         public String toString() {
219             String s = lookupClass().getSimpleName();
220             String lstr = lookupString();
221             int sl = lstr.indexOf(&#39;/&#39;);
222             if (sl &gt;= 0)  s += lstr.substring(sl);
223             ClassLoader cld = lookupClass().getClassLoader();
224             if (cld != THIS_LOADER)  s += &quot;/loader#&quot;+numberOf(cld);
225             return s;
226         }
227 
228         /** Predict the success or failure of accessing this method. */
229         public boolean willAccess(Method m) {
230             Class&lt;?&gt; c1 = lookupClass();
231             Class&lt;?&gt; c2 = m.getDeclaringClass();
232 
233             // publicLookup has access to all public types/members of types in unnamed modules
234             if ((lookupModes &amp; UNCONDITIONAL) != 0
235                 &amp;&amp; (lookupModes &amp; PUBLIC) != 0
236                 &amp;&amp; !c2.getModule().isNamed()
237                 &amp;&amp; Modifier.isPublic(c2.getModifiers())
238                 &amp;&amp; Modifier.isPublic(m.getModifiers()))
239                 return true;
240 
241             LookupCase lc = this.in(c2);
242             int m1 = lc.lookupModes();
243             int m2 = fixMods(m.getModifiers());
244             // allow private lookup on nestmates. Otherwise, privacy is strictly enforced
245             if (c1 != c2 &amp;&amp; ((m2 &amp; PRIVATE) == 0 || !c1.isNestmateOf(c2))) {
246                 m1 &amp;= ~PRIVATE;
247             }
248             // protected access is sometimes allowed
249             if ((m2 &amp; PROTECTED) != 0) {
250                 int prev = m2;
251                 m2 |= PACKAGE;  // it acts like a package method also
252                 if ((lookupModes() &amp; PROTECTED) != 0 &amp;&amp;
253                     c2.isAssignableFrom(c1))
254                     m2 |= PUBLIC;  // from a subclass, it acts like a public method also
255             }
256             if (verbosity &gt;= 2)
257                 System.out.format(&quot;%s willAccess %s m1=0x%h m2=0x%h =&gt; %s%n&quot;, this, lc, m1, m2, ((m2 &amp; m1) != 0));
258             return (m2 &amp; m1) != 0;
259         }
260 
261         /** Predict the success or failure of accessing this class. */
262         public boolean willAccessClass(Class&lt;?&gt; c2, boolean load) {
263             Class&lt;?&gt; c1 = lookupClass();
264             if (load &amp;&amp; c2.getClassLoader() != null) {
265                 if (c1.getClassLoader() == null) {
266                     // not visible
267                     return false;
268                 }
269             }
270 
271             // publicLookup has access to all public types/members of types in unnamed modules
272             if ((lookupModes &amp; UNCONDITIONAL) != 0
273                 &amp;&amp; (lookupModes &amp; PUBLIC) != 0
274                 &amp;&amp; (!c2.getModule().isNamed())
275                 &amp;&amp; Modifier.isPublic(c2.getModifiers()))
276                 return true;
277 
278             LookupCase lc = this.in(c2);
279             int m1 = lc.lookupModes();
280             boolean r = false;
281             if (m1 == 0) {
282                 r = false;
283             } else {
284                 int m2 = fixMods(c2.getModifiers());
285                 if ((m2 &amp; PUBLIC) != 0) {
286                     r = true;
287                 } else if ((m1 &amp; PACKAGE) != 0 &amp;&amp; c1.getPackage() == c2.getPackage()) {
288                     r = true;
289                 }
290             }
291             if (verbosity &gt;= 2) {
292                 System.out.println(this+&quot; willAccessClass &quot;+lc+&quot; c1=&quot;+c1+&quot; c2=&quot;+c2+&quot; =&gt; &quot;+r);
293             }
294             return r;
295         }
296     }
297 
298     private static Class&lt;?&gt; topLevelClass(Class&lt;?&gt; cls) {
299         Class&lt;?&gt; c = cls;
300         for (Class&lt;?&gt; ec; (ec = c.getEnclosingClass()) != null; )
301             c = ec;
302         assert(c.getEnclosingClass() == null);
303         assert(c == cls || cls.getEnclosingClass() != null);
304         return c;
305     }
306 
307     private final TreeSet&lt;LookupCase&gt; CASES = new TreeSet&lt;&gt;();
308     private final TreeMap&lt;LookupCase,TreeSet&lt;LookupCase&gt;&gt; CASE_EDGES = new TreeMap&lt;&gt;();
309     private final ArrayList&lt;ClassLoader&gt; LOADERS = new ArrayList&lt;&gt;();
310     private final ClassLoader THIS_LOADER = this.getClass().getClassLoader();
311     { if (THIS_LOADER != null)  LOADERS.add(THIS_LOADER); }  // #1
312 
313     private LookupCase lookupCase(String name) {
314         for (LookupCase lc : CASES) {
315             if (lc.toString().equals(name))
316                 return lc;
317         }
318         throw new AssertionError(name);
319     }
320 
321     private int numberOf(ClassLoader cl) {
322         if (cl == null)  return 0;
323         int i = LOADERS.indexOf(cl);
324         if (i &lt; 0) {
325             i = LOADERS.size();
326             LOADERS.add(cl);
327         }
328         return i+1;
329     }
330 
331     private void addLookupEdge(LookupCase l1, Class&lt;?&gt; c2, LookupCase l2) {
332         TreeSet&lt;LookupCase&gt; edges = CASE_EDGES.get(l2);
333         if (edges == null)  CASE_EDGES.put(l2, edges = new TreeSet&lt;&gt;());
334         if (edges.add(l1)) {
335             Class&lt;?&gt; c1 = l1.lookupClass();
336             assert(l2.lookupClass() == c2); // [A1]
337             int m1 = l1.lookupModes();
338             int m2 = l2.lookupModes();
339             assert((m1 | m2) == m1);        // [A2] (no elevation of access)
340             LookupCase expect = l1.in(c2);
341             if (!expect.equals(l2))
342                 System.out.println(&quot;*** expect &quot;+l1+&quot; =&gt; &quot;+expect+&quot; but got &quot;+l2);
343             assertEquals(l2, expect);
344         }
345     }
346 
347     private void makeCases(Lookup[] originalLookups) {
348         // make initial set of lookup test cases
349         CASES.clear(); LOADERS.clear(); CASE_EDGES.clear();
350         ArrayList&lt;Class&lt;?&gt;&gt; classes = new ArrayList&lt;&gt;();
351         for (Lookup l : originalLookups) {
352             CASES.add(new LookupCase(l));
353             classes.remove(l.lookupClass());  // no dups please
354             classes.add(l.lookupClass());
355         }
356         System.out.println(&quot;loaders = &quot;+LOADERS);
357         int rounds = 0;
358         for (int lastCount = -1; lastCount != CASES.size(); ) {
359             lastCount = CASES.size();  // if CASES grow in the loop we go round again
360             for (LookupCase lc1 : CASES.toArray(new LookupCase[0])) {
361                 for (Class&lt;?&gt; c2 : classes) {
362                     LookupCase lc2 = new LookupCase(lc1.lookup().in(c2));
363                     addLookupEdge(lc1, c2, lc2);
364                     CASES.add(lc2);
365                 }
366             }
367             rounds++;
368         }
369         System.out.println(&quot;filled in &quot;+CASES.size()+&quot; cases from &quot;+originalLookups.length+&quot; original cases in &quot;+rounds+&quot; rounds&quot;);
370         if (false) {
371             System.out.println(&quot;CASES: {&quot;);
372             for (LookupCase lc : CASES) {
373                 System.out.println(lc);
374                 Set&lt;LookupCase&gt; edges = CASE_EDGES.get(lc);
375                 if (edges != null)
376                     for (LookupCase prev : edges) {
377                         System.out.println(&quot;\t&quot;+prev);
378                     }
379             }
380             System.out.println(&quot;}&quot;);
381         }
382     }
383 
384     @Test public void test() {
385         makeCases(lookups());
386         if (verbosity &gt; 0) {
387             verbosity += 9;
388             Method pro_in_self = targetMethod(THIS_CLASS, PROTECTED, methodType(void.class));
389             testOneAccess(lookupCase(&quot;AccessControlTest/public&quot;),  pro_in_self, &quot;find&quot;);
390             testOneAccess(lookupCase(&quot;Remote_subclass/public&quot;),    pro_in_self, &quot;find&quot;);
391             testOneAccess(lookupCase(&quot;Remote_subclass&quot;),           pro_in_self, &quot;find&quot;);
392             verbosity -= 9;
393         }
394         Set&lt;Class&lt;?&gt;&gt; targetClassesDone = new HashSet&lt;&gt;();
395         for (LookupCase targetCase : CASES) {
396             Class&lt;?&gt; targetClass = targetCase.lookupClass();
397             if (!targetClassesDone.add(targetClass))  continue;  // already saw this one
398             String targetPlace = placeName(targetClass);
399             if (targetPlace == null)  continue;  // Object, String, not a target
400             for (int targetAccess : ACCESS_CASES) {
401                 MethodType methodType = methodType(void.class);
402                 Method method = targetMethod(targetClass, targetAccess, methodType);
403                 // Try to access target method from various contexts.
404                 for (LookupCase sourceCase : CASES) {
405                     testOneAccess(sourceCase, method, &quot;findClass&quot;);
406                     testOneAccess(sourceCase, method, &quot;accessClass&quot;);
407                     testOneAccess(sourceCase, method, &quot;find&quot;);
408                     testOneAccess(sourceCase, method, &quot;unreflect&quot;);
409                 }
410             }
411         }
412         System.out.println(&quot;tested &quot;+testCount+&quot; access scenarios; &quot;+testCountFails+&quot; accesses were denied&quot;);
413     }
414 
415     private int testCount, testCountFails;
416 
417     private void testOneAccess(LookupCase sourceCase, Method method, String kind) {
418         Class&lt;?&gt; targetClass = method.getDeclaringClass();
419         String methodName = method.getName();
420         MethodType methodType = methodType(method.getReturnType(), method.getParameterTypes());
421         boolean isFindOrAccessClass = &quot;findClass&quot;.equals(kind) || &quot;accessClass&quot;.equals(kind);
422         boolean willAccess = isFindOrAccessClass ?
423                 sourceCase.willAccessClass(targetClass, &quot;findClass&quot;.equals(kind)) : sourceCase.willAccess(method);
424         boolean didAccess = false;
425         ReflectiveOperationException accessError = null;
426         try {
427             switch (kind) {
428             case &quot;accessClass&quot;:
429                 sourceCase.lookup().accessClass(targetClass);
430                 break;
431             case &quot;findClass&quot;:
432                 sourceCase.lookup().findClass(targetClass.getName());
433                 break;
434             case &quot;find&quot;:
435                 if ((method.getModifiers() &amp; Modifier.STATIC) != 0)
436                     sourceCase.lookup().findStatic(targetClass, methodName, methodType);
437                 else
438                     sourceCase.lookup().findVirtual(targetClass, methodName, methodType);
439                 break;
440             case &quot;unreflect&quot;:
441                 sourceCase.lookup().unreflect(method);
442                 break;
443             default:
444                 throw new AssertionError(kind);
445             }
446             didAccess = true;
447         } catch (ReflectiveOperationException ex) {
448             accessError = ex;
449         }
450         if (willAccess != didAccess) {
451             System.out.println(sourceCase+&quot; =&gt; &quot;+targetClass.getSimpleName()+(isFindOrAccessClass?&quot;&quot;:&quot;.&quot;+methodName+methodType));
452             System.out.println(&quot;fail &quot;+(isFindOrAccessClass?kind:&quot;on &quot;+method)+&quot; ex=&quot;+accessError);
453             assertEquals(willAccess, didAccess);
454         }
455         testCount++;
456         if (!didAccess)  testCountFails++;
457     }
458 
459     static Method targetMethod(Class&lt;?&gt; targetClass, int targetAccess, MethodType methodType) {
460         assert targetAccess != MODULE;
461         String methodName = accessName(targetAccess)+placeName(targetClass);
462         if (verbosity &gt;= 2)
463             System.out.println(targetClass.getSimpleName()+&quot;.&quot;+methodName+methodType);
464         try {
465             Method method = targetClass.getDeclaredMethod(methodName, methodType.parameterArray());
466             assertEquals(method.getReturnType(), methodType.returnType());
467             int haveMods = method.getModifiers();
468             assert(Modifier.isStatic(haveMods));
469             assert(targetAccess == fixMods(haveMods));
470             return method;
471         } catch (NoSuchMethodException ex) {
472             throw new AssertionError(methodName, ex);
473         }
474     }
475 
476     static String placeName(Class&lt;?&gt; cls) {
477         // return &quot;self&quot;, &quot;sibling&quot;, &quot;nestmate&quot;, etc.
478         if (cls == AccessControlTest.class)  return &quot;self&quot;;
479         String cln = cls.getSimpleName();
480         int under = cln.lastIndexOf(&#39;_&#39;);
481         if (under &lt; 0)  return null;
482         return cln.substring(under+1);
483     }
484     static String accessName(int acc) {
485         switch (acc) {
486         case PUBLIC:     return &quot;pub_in_&quot;;
487         case PROTECTED:  return &quot;pro_in_&quot;;
488         case PACKAGE:    return &quot;pkg_in_&quot;;
489         case PRIVATE:    return &quot;pri_in_&quot;;
490         }
491         assert(false);
492         return &quot;?&quot;;
493     }
494     // MODULE not a test case at this time
495     private static final int[] ACCESS_CASES = {
496         PUBLIC, PACKAGE, PRIVATE, PROTECTED
497     };
498     /** Return one of the ACCESS_CASES. */
499     static int fixMods(int mods) {
500         mods &amp;= (PUBLIC|PRIVATE|PROTECTED);
501         switch (mods) {
502         case PUBLIC: case PRIVATE: case PROTECTED: return mods;
503         case 0:  return PACKAGE;
504         }
505         throw new AssertionError(mods);
506     }
507 
508     static Lookup[] lookups() {
509         ArrayList&lt;Lookup&gt; tem = new ArrayList&lt;&gt;();
510         Collections.addAll(tem,
511                            AccessControlTest.lookup_in_self(),
512                            Inner_nestmate.lookup_in_nestmate(),
513                            AccessControlTest_sibling.lookup_in_sibling());
514         if (true) {
515             Collections.addAll(tem,Acquaintance_remote.lookups());
516         } else {
517             try {
518                 Class&lt;?&gt; remc = Class.forName(&quot;test.java.lang.invoke.AccessControlTest_subpkg.Acquaintance_remote&quot;);
519                 Lookup[] remls = (Lookup[]) remc.getMethod(&quot;lookups&quot;).invoke(null);
520                 Collections.addAll(tem, remls);
521             } catch (ReflectiveOperationException ex) {
522                 throw new LinkageError(&quot;reflection failed&quot;, ex);
523             }
524         }
525         tem.add(publicLookup());
526         tem.add(publicLookup().in(String.class));
527         tem.add(publicLookup().in(List.class));
528         return tem.toArray(new Lookup[0]);
529     }
530 
531     static Lookup lookup_in_self() {
532         return MethodHandles.lookup();
533     }
534     public static      void pub_in_self() { }
535     protected static   void pro_in_self() { }
536     static /*package*/ void pkg_in_self() { }
537     private static     void pri_in_self() { }
538 
539     static class Inner_nestmate {
540         static Lookup lookup_in_nestmate() {
541             return MethodHandles.lookup();
542         }
543         public static      void pub_in_nestmate() { }
544         protected static   void pro_in_nestmate() { }
545         static /*package*/ void pkg_in_nestmate() { }
546         private static     void pri_in_nestmate() { }
547     }
548 }
549 class AccessControlTest_sibling {
550     static Lookup lookup_in_sibling() {
551         return MethodHandles.lookup();
552     }
553     public static      void pub_in_sibling() { }
554     protected static   void pro_in_sibling() { }
555     static /*package*/ void pkg_in_sibling() { }
556     private static     void pri_in_sibling() { }
557 }
558 
559 // This guy tests access from outside the package:
560 /*
561 package test.java.lang.invoke.AccessControlTest_subpkg;
562 public class Acquaintance_remote {
563     public static Lookup[] lookups() { ...
564     }
565     ...
566 }
567 */
    </pre>
  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames test/jdk/java/lang/invoke/VarHandles/accessibility/TestFieldLookupAccessibility.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (c) 2016, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 /* @test
<a name="1" id="anc1"></a><span class="line-modified"> 25  * @bug 8152645 8216558</span>
 26  * @summary test field lookup accessibility of MethodHandles and VarHandles
 27  * @compile TestFieldLookupAccessibility.java
 28  *          pkg/A.java pkg/B_extends_A.java pkg/C.java
 29  *          pkg/subpkg/B_extends_A.java pkg/subpkg/C.java
 30  * @run testng/othervm TestFieldLookupAccessibility
 31  */
 32 
 33 import org.testng.Assert;
 34 import org.testng.annotations.DataProvider;
 35 import org.testng.annotations.Test;
 36 import pkg.B_extends_A;
 37 
 38 import java.lang.invoke.MethodHandles;
 39 import java.lang.reflect.Field;
 40 import java.lang.reflect.Modifier;
 41 import java.util.ArrayList;
 42 import java.util.HashMap;
 43 import java.util.HashSet;
 44 import java.util.List;
 45 import java.util.Map;
 46 import java.util.Set;
 47 import java.util.stream.Collectors;
 48 import java.util.stream.Stream;
 49 
 50 public class TestFieldLookupAccessibility {
 51 
 52     // The set of possible field lookup mechanisms
 53     enum FieldLookup {
 54         MH_GETTER() {
 55             Object lookup(MethodHandles.Lookup l, Field f) throws Exception {
 56                 return l.findGetter(f.getDeclaringClass(), f.getName(), f.getType());
 57             }
 58 
 59             boolean isAccessible(Field f) {
 60                 return !Modifier.isStatic(f.getModifiers());
 61             }
 62         },
 63         MH_SETTER() {
 64             Object lookup(MethodHandles.Lookup l, Field f) throws Exception {
 65                 return l.findSetter(f.getDeclaringClass(), f.getName(), f.getType());
 66             }
 67 
 68             boolean isAccessible(Field f) {
 69                 return !Modifier.isStatic(f.getModifiers()) &amp;&amp; !Modifier.isFinal(f.getModifiers());
 70             }
 71         },
 72         MH_STATIC_GETTER() {
 73             Object lookup(MethodHandles.Lookup l, Field f) throws Exception {
 74                 return l.findStaticGetter(f.getDeclaringClass(), f.getName(), f.getType());
 75             }
 76 
 77             boolean isAccessible(Field f) {
 78                 return Modifier.isStatic(f.getModifiers());
 79             }
 80         },
 81         MH_STATIC_SETTER() {
 82             Object lookup(MethodHandles.Lookup l, Field f) throws Exception {
 83                 return l.findStaticSetter(f.getDeclaringClass(), f.getName(), f.getType());
 84             }
 85 
 86             boolean isAccessible(Field f) {
 87                 return Modifier.isStatic(f.getModifiers()) &amp;&amp; !Modifier.isFinal(f.getModifiers());
 88             }
 89         },
 90         MH_UNREFLECT_GETTER() {
 91             Object lookup(MethodHandles.Lookup l, Field f) throws Exception {
 92                 return l.unreflectGetter(f);
 93             }
 94         },
 95         MH_UNREFLECT_GETTER_ACCESSIBLE() {
 96             Object lookup(MethodHandles.Lookup l, Field f) throws Exception {
 97                 return l.unreflectGetter(cloneAndSetAccessible(f));
 98             }
<a name="2" id="anc2"></a><span class="line-added"> 99 </span>
<span class="line-added">100             // Setting the accessibility bit of a Field grants access under</span>
<span class="line-added">101             // all conditions for MethodHandle getters.</span>
<span class="line-added">102             Set&lt;String&gt; inaccessibleFields(Set&lt;String&gt; inaccessibleFields) {</span>
<span class="line-added">103                 return new HashSet&lt;&gt;();</span>
<span class="line-added">104             }</span>
105         },
106         MH_UNREFLECT_SETTER() {
107             Object lookup(MethodHandles.Lookup l, Field f) throws Exception {
108                 return l.unreflectSetter(f);
109             }
110 
111             boolean isAccessible(Field f) {
<a name="3" id="anc3"></a><span class="line-modified">112                 return f.isAccessible() &amp;&amp; !Modifier.isStatic(f.getModifiers()) || !Modifier.isFinal(f.getModifiers());</span>
113             }
114         },
115         MH_UNREFLECT_SETTER_ACCESSIBLE() {
116             Object lookup(MethodHandles.Lookup l, Field f) throws Exception {
117                 return l.unreflectSetter(cloneAndSetAccessible(f));
118             }
<a name="4" id="anc4"></a><span class="line-added">119 </span>
<span class="line-added">120             boolean isAccessible(Field f) {</span>
<span class="line-added">121                 return !(Modifier.isStatic(f.getModifiers()) &amp;&amp; Modifier.isFinal(f.getModifiers()));</span>
<span class="line-added">122             }</span>
<span class="line-added">123 </span>
<span class="line-added">124             // Setting the accessibility bit of a Field grants access to non-static</span>
<span class="line-added">125             // final fields for MethodHandle setters.</span>
<span class="line-added">126             Set&lt;String&gt; inaccessibleFields(Set&lt;String&gt;inaccessibleFields) {</span>
<span class="line-added">127                 Set&lt;String&gt; result = new HashSet&lt;&gt;();</span>
<span class="line-added">128                 inaccessibleFields.stream()</span>
<span class="line-added">129                                   .filter(f -&gt; (f.contains(&quot;static&quot;) &amp;&amp; f.contains(&quot;final&quot;)))</span>
<span class="line-added">130                                   .forEach(result::add);</span>
<span class="line-added">131                 return result;</span>
<span class="line-added">132             }</span>
133         },
134         VH() {
135             Object lookup(MethodHandles.Lookup l, Field f) throws Exception {
136                 return l.findVarHandle(f.getDeclaringClass(), f.getName(), f.getType());
137             }
138 
139             boolean isAccessible(Field f) {
140                 return !Modifier.isStatic(f.getModifiers());
141             }
142         },
143         VH_STATIC() {
144             Object lookup(MethodHandles.Lookup l, Field f) throws Exception {
145                 return l.findStaticVarHandle(f.getDeclaringClass(), f.getName(), f.getType());
146             }
147 
148             boolean isAccessible(Field f) {
149                 return Modifier.isStatic(f.getModifiers());
150             }
151         },
152         VH_UNREFLECT() {
153             Object lookup(MethodHandles.Lookup l, Field f) throws Exception {
154                 return l.unreflectVarHandle(f);
155             }
156         };
157 
158         // Look up a handle to a field
159         abstract Object lookup(MethodHandles.Lookup l, Field f) throws Exception;
160 
161         boolean isAccessible(Field f) {
162             return true;
163         }
164 
<a name="5" id="anc5"></a><span class="line-added">165         Set&lt;String&gt; inaccessibleFields(Set&lt;String&gt; inaccessibleFields) {</span>
<span class="line-added">166             return new HashSet&lt;&gt;(inaccessibleFields);</span>
<span class="line-added">167         }</span>
<span class="line-added">168 </span>
169         static Field cloneAndSetAccessible(Field f) throws Exception {
170             // Clone to avoid mutating source field
171             f = f.getDeclaringClass().getDeclaredField(f.getName());
172             f.setAccessible(true);
173             return f;
174         }
175     }
176 
177     @DataProvider
178     public Object[][] lookupProvider() throws Exception {
179         Stream&lt;List&lt;Object&gt;&gt; baseCases = Stream.of(
180                 // Look up from same package
181                 List.of(pkg.A.class, pkg.A.lookup(), pkg.A.inaccessibleFields()),
182                 List.of(pkg.A.class, pkg.A.lookup(), pkg.A.inaccessibleFields()),
183                 List.of(pkg.A.class, B_extends_A.lookup(), B_extends_A.inaccessibleFields()),
184                 List.of(pkg.A.class, pkg.C.lookup(), pkg.C.inaccessibleFields()),
185 
186                 // Look up from sub-package
187                 List.of(pkg.A.class, pkg.subpkg.B_extends_A.lookup(), pkg.subpkg.B_extends_A.inaccessibleFields()),
188                 List.of(pkg.A.class, pkg.subpkg.C.lookup(), pkg.subpkg.C.inaccessibleFields())
189         );
190 
191         // Cross product base cases with the field lookup classes
192         return baseCases.
193                 flatMap(l -&gt; Stream.of(FieldLookup.values()).map(fl -&gt; prepend(fl, l))).
194                 toArray(Object[][]::new);
195     }
196 
197     private static Object[] prepend(Object o, List&lt;Object&gt; l) {
198         List&lt;Object&gt; pl = new ArrayList&lt;&gt;();
199         pl.add(o);
200         pl.addAll(l);
201         return pl.toArray();
202     }
203 
204     @Test(dataProvider = &quot;lookupProvider&quot;)
205     public void test(FieldLookup fl, Class&lt;?&gt; src, MethodHandles.Lookup l, Set&lt;String&gt; inaccessibleFields) {
206         // Add to the expected failures all inaccessible fields due to accessibility modifiers
<a name="6" id="anc6"></a><span class="line-modified">207         Set&lt;String&gt; expected = fl.inaccessibleFields(inaccessibleFields);</span>
208         Map&lt;Field, Throwable&gt; actual = new HashMap&lt;&gt;();
209 
210         for (Field f : fields(src)) {
211             // Add to the expected failures all inaccessible fields due to static/final modifiers
212             if (!fl.isAccessible(f)) {
213                 expected.add(f.getName());
214             }
215 
216             try {
217                 fl.lookup(l, f);
218             }
219             catch (Throwable t) {
220                 // Lookup failed, add to the actual failures
221                 actual.put(f, t);
222             }
223         }
224 
225         Set&lt;String&gt; actualFieldNames = actual.keySet().stream().map(Field::getName).
226                 collect(Collectors.toSet());
227         if (!actualFieldNames.equals(expected)) {
228             if (actualFieldNames.isEmpty()) {
<a name="7" id="anc7"></a><span class="line-modified">229                 Assert.assertEquals(actualFieldNames, expected, &quot;No accessibility failures:&quot;);</span>





230             }
231             else {
232                 Assert.assertEquals(actualFieldNames, expected, &quot;Accessibility failures differ:&quot;);
233             }
234         }
235         else {
236             if (!actual.values().stream().allMatch(IllegalAccessException.class::isInstance)) {
237                 Assert.fail(&quot;Expecting an IllegalArgumentException for all failures &quot; + actual);
238             }
239         }
240     }
241 
242     static List&lt;Field&gt; fields(Class&lt;?&gt; src) {
243         return List.of(src.getDeclaredFields());
244     }
245 }
<a name="8" id="anc8"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="8" type="hidden" />
</body>
</html>
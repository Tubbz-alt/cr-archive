<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff test/jdk/java/lang/invoke/modules/m1/p1/Main.java</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="../../Unnamed.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="../../../../management/GarbageCollectorMXBean/GcInfoCompositeType.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>test/jdk/java/lang/invoke/modules/m1/p1/Main.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2015, 2017, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
</pre>
<hr />
<pre>
 28 import java.lang.invoke.MethodHandles.Lookup;
 29 import java.lang.invoke.MethodType;
 30 
 31 import static java.lang.invoke.MethodHandles.Lookup.*;
 32 
 33 import org.testng.annotations.BeforeTest;
 34 import org.testng.annotations.Test;
 35 import static org.testng.Assert.*;
 36 
 37 /**
 38  * Basic test case for module access checks and Lookup.in.
 39  */
 40 
 41 @Test
 42 public class Main {
 43 
 44     private Class&lt;?&gt; p1_Type1;        // m1, exported
 45     private Class&lt;?&gt; p2_Type2;        // m1, not exported
 46     private Class&lt;?&gt; q1_Type1;        // m2, exported
 47     private Class&lt;?&gt; q2_Type2;        // m2, not exported
<span class="line-modified"> 48     private Class&lt;?&gt; x500NameClass;   // java.base, not exported</span>
 49     private Class&lt;?&gt; unnamedClass;    // class in unnamed module
 50 
 51     @BeforeTest
 52     public void setup() throws Exception {
 53         try {
 54             p1_Type1 = Class.forName(&quot;p1.Type1&quot;);
 55             p2_Type2 = Class.forName(&quot;p2.Type2&quot;);
 56             q1_Type1 = Class.forName(&quot;q1.Type1&quot;);
 57             q2_Type2 = Class.forName(&quot;q2.Type2&quot;);
<span class="line-modified"> 58             x500NameClass = Class.forName(&quot;sun.security.x509.X500Name&quot;);</span>
 59             unnamedClass = Class.forName(&quot;Unnamed&quot;);
 60         } catch (ClassNotFoundException e) {
 61             throw new AssertionError(e);
 62         }
 63 
 64         // check setup
 65         Module m1 = ModuleLayer.boot().findModule(&quot;m1&quot;).orElse(null);
 66         assertNotNull(m1);
 67         assertTrue(p1_Type1.getModule() == m1);
 68         assertTrue(p2_Type2.getModule() == m1);
 69         assertTrue(m1.isExported(&quot;p1&quot;));
 70         assertFalse(m1.isExported(&quot;p2&quot;));
 71 
 72         Module m2 = ModuleLayer.boot().findModule(&quot;m2&quot;).orElse(null);
 73         assertNotNull(m2);
 74         assertTrue(q1_Type1.getModule() == m2);
 75         assertTrue(q2_Type2.getModule() == m2);
 76         assertTrue(m2.isExported(&quot;q1&quot;));
 77         assertFalse(m2.isExported(&quot;q2&quot;));
 78 
</pre>
<hr />
<pre>
 88      *
 89      * [A0] has module access
 90      * [A1] can access all public types in m1
 91      * [A2] can access public types in packages exported by modules that m1 reads
 92      * [A3] cannot access public types in non-exported modules of modules that m1 reads
 93      */
 94     public void testLookup() throws Exception {
 95         Lookup lookup = MethodHandles.lookup();
 96         assertTrue((lookup.lookupModes() &amp; MODULE) == MODULE); // [A0]
 97 
 98         // m1
 99         findConstructor(lookup, p1_Type1, void.class); // [A1]
100         findConstructor(lookup, p2_Type2, void.class); // [A1]
101 
102         // m2
103         findConstructor(lookup, q1_Type1, void.class); // [A2]
104         findConstructorExpectingIAE(lookup, q2_Type2, void.class); // [A3]
105 
106         // java.base
107         findConstructor(lookup, Object.class, void.class); // [A2]
<span class="line-modified">108         findConstructorExpectingIAE(lookup, x500NameClass, void.class, String.class); // [A3]</span>
109 
110         // unnamed
111         findConstructor(lookup, unnamedClass, void.class);  // [A3]
112     }
113 
114     /**
115      * Hop to lookup class in the same module
116      *
117      * [A0] module and public access is not lost
118      */
119     public void testToSameModule() throws Exception {
120         Lookup lookup = MethodHandles.lookup().in(p2_Type2);
121         assertTrue(lookup.lookupModes() == (MODULE|PUBLIC)); // [A0]
122 
123         // m1
124         findConstructor(lookup, p1_Type1, void.class);
125         findConstructor(lookup, p2_Type2, void.class);
126 
127         // m2
128         findConstructor(lookup, q1_Type1, void.class);
129         findConstructorExpectingIAE(lookup, q2_Type2, void.class);
130 
131         // java.base
132         findConstructor(lookup, Object.class, void.class);
<span class="line-modified">133         findConstructorExpectingIAE(lookup, x500NameClass, void.class, String.class);</span>
134 
135         // unnamed
136         findConstructor(lookup, unnamedClass, void.class);
137     }
138 
139     /**
140      * Hop to lookup class in another named module
141      *
<span class="line-modified">142      * [A0] has no access</span>

143      */
144     public void testFromNamedToNamedModule() throws Exception {

145         Lookup lookup = MethodHandles.lookup().in(q1_Type1);
<span class="line-modified">146         assertTrue(lookup.lookupModes() == 0); // [A0]</span>





147 
148         // m1
149         findConstructorExpectingIAE(lookup, p1_Type1, void.class);
150         findConstructorExpectingIAE(lookup, p2_Type2, void.class);
151 



152         // m2
<span class="line-modified">153         findConstructorExpectingIAE(lookup, q1_Type1, void.class);</span>
154         findConstructorExpectingIAE(lookup, q2_Type2, void.class);
155 



156         // java.base
<span class="line-modified">157         findConstructorExpectingIAE(lookup, Object.class, void.class);</span>
<span class="line-modified">158         findConstructorExpectingIAE(lookup, x500NameClass, void.class, String.class);</span>



159 
160         // unnamed
161         findConstructorExpectingIAE(lookup, unnamedClass, void.class);



162     }
163 
164     /**
165      * Hop to lookup class in an unnamed module
166      *
<span class="line-modified">167      * [A0] has no access</span>
168      */
169     public void testFromNamedToUnnamedModule() throws Exception {
170         Lookup lookup = MethodHandles.lookup().in(unnamedClass);
<span class="line-modified">171         assertTrue(lookup.lookupModes() == 0); // [A0]</span>
172 
173         // m1
<span class="line-modified">174         findConstructorExpectingIAE(lookup, p1_Type1, void.class);</span>
175         findConstructorExpectingIAE(lookup, p2_Type2, void.class);
176 
177         // m2
<span class="line-modified">178         findConstructorExpectingIAE(lookup, q1_Type1, void.class);</span>
179         findConstructorExpectingIAE(lookup, q2_Type2, void.class);
180 
181         // java.base
<span class="line-modified">182         findConstructorExpectingIAE(lookup, Object.class, void.class);</span>
<span class="line-modified">183         findConstructorExpectingIAE(lookup, x500NameClass, void.class, String.class);</span>
184 
185         // unnamed
<span class="line-modified">186         findConstructorExpectingIAE(lookup, unnamedClass, void.class);</span>
187     }
188 
189     /**
190      * Hop from unnamed to named module.
191      *
192      * [A0] retains PUBLIC access
193      */
194     public void testFromUnnamedToNamedModule() throws Exception {
195         Lookup lookup = MethodHandles.lookup();
196         lookup = MethodHandles.privateLookupIn(unnamedClass, lookup).in(p1_Type1);
197         assertTrue(lookup.lookupModes() == PUBLIC); // A0
198 
199         // m1
200         findConstructor(lookup, p1_Type1, void.class);
201         findConstructorExpectingIAE(lookup, p2_Type2, void.class);
202 
203         // m2
204         findConstructor(lookup, q1_Type1, void.class);
205         findConstructorExpectingIAE(lookup, q2_Type2, void.class);
206 
207         // java.base
208         findConstructor(lookup, Object.class, void.class);
<span class="line-modified">209         findConstructorExpectingIAE(lookup, x500NameClass, void.class, String.class);</span>
210 
211         // unnamed
212         findConstructor(lookup, unnamedClass, void.class);
213     }
214 
215     /**
216      * MethodHandles.publicLookup()
217      *
<span class="line-modified">218      * [A0] has PUBLIC|UNCONDITIONAL access</span>
219      */
220     public void testPublicLookup() throws Exception {
221         Lookup lookup = MethodHandles.publicLookup();
<span class="line-modified">222         assertTrue(lookup.lookupModes() == (PUBLIC|UNCONDITIONAL)); // A0</span>
223 
224         // m1
225         findConstructor(lookup, p1_Type1, void.class);
226         findConstructorExpectingIAE(lookup, p2_Type2, void.class);
227 
228         // m2
229         findConstructor(lookup, q1_Type1, void.class);
230         findConstructorExpectingIAE(lookup, q2_Type2, void.class);
231 
232         // java.base
233         findConstructor(lookup, Object.class, void.class);
<span class="line-modified">234         findConstructorExpectingIAE(lookup, x500NameClass, void.class, String.class);</span>
235 
236         // unnamed
237         findConstructor(lookup, unnamedClass, void.class);
238     }
239 
240     /**
241      * Hop from publicLookup to accessible type in java.base


242      */
243     public void testPublicLookupToBaseModule() throws Exception {
244         Lookup lookup = MethodHandles.publicLookup().in(String.class);
<span class="line-modified">245         assertTrue(lookup.lookupModes() == PUBLIC); // A0</span>
246 
247         // m1
<span class="line-modified">248         findConstructorExpectingIAE(lookup, p1_Type1, void.class);</span>
249         findConstructorExpectingIAE(lookup, p2_Type2, void.class);
250 
251         // m2
<span class="line-modified">252         findConstructorExpectingIAE(lookup, q1_Type1, void.class);</span>
253         findConstructorExpectingIAE(lookup, q2_Type2, void.class);
254 
255         // java.base
256         findConstructor(lookup, Object.class, void.class);
<span class="line-modified">257         findConstructorExpectingIAE(lookup, x500NameClass, void.class, String.class);</span>
258 
259         // unnamed
<span class="line-modified">260         findConstructorExpectingIAE(lookup, unnamedClass, void.class);</span>
261     }
262 
263 
264     /**
265      * Hop from publicLookup to accessible type in named module.
266      *
<span class="line-modified">267      * [A0] has PUBLIC access</span>
268      */
269     public void testPublicLookupToAccessibleTypeInNamedModule() throws Exception {
270         Lookup lookup = MethodHandles.publicLookup().in(p1_Type1);
<span class="line-modified">271         assertTrue(lookup.lookupModes() == PUBLIC); // A0</span>
272 
273         // m1
274         findConstructor(lookup, p1_Type1, void.class);
275         findConstructorExpectingIAE(lookup, p2_Type2, void.class);
276 
277         // m2
278         findConstructor(lookup, q1_Type1, void.class);
279         findConstructorExpectingIAE(lookup, q2_Type2, void.class);
280 
281         // java.base
282         findConstructor(lookup, Object.class, void.class);
<span class="line-modified">283         findConstructorExpectingIAE(lookup, x500NameClass, void.class, String.class);</span>
284 
285         // unnamed
286         findConstructor(lookup, unnamedClass, void.class);
287     }
288 
289     /**
290      * Teleport from publicLookup to inaccessible type in named module.
291      *
292      * [A0] has no access
293      */
294     public void testPublicLookupToInaccessibleTypeInNamedModule() throws Exception {
295         Lookup lookup = MethodHandles.publicLookup().in(p2_Type2);
296         assertTrue(lookup.lookupModes() == 0); // A0
297 
298         // m1
299         findConstructorExpectingIAE(lookup, p1_Type1, void.class);
300         findConstructorExpectingIAE(lookup, p2_Type2, void.class);
301 
302         // m2
303         findConstructorExpectingIAE(lookup, q1_Type1, void.class);
304         findConstructorExpectingIAE(lookup, q2_Type2, void.class);
305 
306         // java.base
307         findConstructorExpectingIAE(lookup, Object.class, void.class);
<span class="line-modified">308         findConstructorExpectingIAE(lookup, x500NameClass, void.class, String.class);</span>
309 
310         // unnamed
311         findConstructorExpectingIAE(lookup, unnamedClass, void.class);
312     }
313 
314     /**
315      * Teleport from publicLookup to public type in unnamed module
316      *
<span class="line-modified">317      * [A0] has PUBLIC access</span>
318      */
319     public void testPublicLookupToUnnamedModule() throws Exception {
320         Lookup lookup = MethodHandles.publicLookup().in(unnamedClass);
<span class="line-modified">321         assertTrue(lookup.lookupModes() == PUBLIC); // A0</span>
322 
323         // m1
324         findConstructor(lookup, p1_Type1, void.class);
325         findConstructorExpectingIAE(lookup, p2_Type2, void.class);
326 
327         // m2
328         findConstructor(lookup, q1_Type1, void.class);
329         findConstructorExpectingIAE(lookup, q2_Type2, void.class);
330 
331         // java.base
332         findConstructor(lookup, Object.class, void.class);
<span class="line-modified">333         findConstructorExpectingIAE(lookup, x500NameClass, void.class, String.class);</span>
334 
335         // unnamed
336         findConstructor(lookup, unnamedClass, void.class);
337     }
338 
339     /**
340      * Invokes Lookup findConstructor with a method type constructored from the
341      * given return and parameter types, expecting IllegalAccessException to be
342      * thrown.
343      */
344     static void findConstructorExpectingIAE(Lookup lookup,
345                                             Class&lt;?&gt; clazz,
346                                             Class&lt;?&gt; rtype,
347                                             Class&lt;?&gt;... ptypes) throws Exception {
348         try {
349             findConstructor(lookup, clazz, rtype, ptypes);
350             assertTrue(false);
351         } catch (IllegalAccessException expected) { }
352     }
353 
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2015, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
</pre>
<hr />
<pre>
 28 import java.lang.invoke.MethodHandles.Lookup;
 29 import java.lang.invoke.MethodType;
 30 
 31 import static java.lang.invoke.MethodHandles.Lookup.*;
 32 
 33 import org.testng.annotations.BeforeTest;
 34 import org.testng.annotations.Test;
 35 import static org.testng.Assert.*;
 36 
 37 /**
 38  * Basic test case for module access checks and Lookup.in.
 39  */
 40 
 41 @Test
 42 public class Main {
 43 
 44     private Class&lt;?&gt; p1_Type1;        // m1, exported
 45     private Class&lt;?&gt; p2_Type2;        // m1, not exported
 46     private Class&lt;?&gt; q1_Type1;        // m2, exported
 47     private Class&lt;?&gt; q2_Type2;        // m2, not exported
<span class="line-modified"> 48     private Class&lt;?&gt; signalClass;     // java.base, not exported</span>
 49     private Class&lt;?&gt; unnamedClass;    // class in unnamed module
 50 
 51     @BeforeTest
 52     public void setup() throws Exception {
 53         try {
 54             p1_Type1 = Class.forName(&quot;p1.Type1&quot;);
 55             p2_Type2 = Class.forName(&quot;p2.Type2&quot;);
 56             q1_Type1 = Class.forName(&quot;q1.Type1&quot;);
 57             q2_Type2 = Class.forName(&quot;q2.Type2&quot;);
<span class="line-modified"> 58             signalClass = Class.forName(&quot;jdk.internal.misc.Signal&quot;);</span>
 59             unnamedClass = Class.forName(&quot;Unnamed&quot;);
 60         } catch (ClassNotFoundException e) {
 61             throw new AssertionError(e);
 62         }
 63 
 64         // check setup
 65         Module m1 = ModuleLayer.boot().findModule(&quot;m1&quot;).orElse(null);
 66         assertNotNull(m1);
 67         assertTrue(p1_Type1.getModule() == m1);
 68         assertTrue(p2_Type2.getModule() == m1);
 69         assertTrue(m1.isExported(&quot;p1&quot;));
 70         assertFalse(m1.isExported(&quot;p2&quot;));
 71 
 72         Module m2 = ModuleLayer.boot().findModule(&quot;m2&quot;).orElse(null);
 73         assertNotNull(m2);
 74         assertTrue(q1_Type1.getModule() == m2);
 75         assertTrue(q2_Type2.getModule() == m2);
 76         assertTrue(m2.isExported(&quot;q1&quot;));
 77         assertFalse(m2.isExported(&quot;q2&quot;));
 78 
</pre>
<hr />
<pre>
 88      *
 89      * [A0] has module access
 90      * [A1] can access all public types in m1
 91      * [A2] can access public types in packages exported by modules that m1 reads
 92      * [A3] cannot access public types in non-exported modules of modules that m1 reads
 93      */
 94     public void testLookup() throws Exception {
 95         Lookup lookup = MethodHandles.lookup();
 96         assertTrue((lookup.lookupModes() &amp; MODULE) == MODULE); // [A0]
 97 
 98         // m1
 99         findConstructor(lookup, p1_Type1, void.class); // [A1]
100         findConstructor(lookup, p2_Type2, void.class); // [A1]
101 
102         // m2
103         findConstructor(lookup, q1_Type1, void.class); // [A2]
104         findConstructorExpectingIAE(lookup, q2_Type2, void.class); // [A3]
105 
106         // java.base
107         findConstructor(lookup, Object.class, void.class); // [A2]
<span class="line-modified">108         findConstructorExpectingIAE(lookup, signalClass, void.class, String.class); // [A3]</span>
109 
110         // unnamed
111         findConstructor(lookup, unnamedClass, void.class);  // [A3]
112     }
113 
114     /**
115      * Hop to lookup class in the same module
116      *
117      * [A0] module and public access is not lost
118      */
119     public void testToSameModule() throws Exception {
120         Lookup lookup = MethodHandles.lookup().in(p2_Type2);
121         assertTrue(lookup.lookupModes() == (MODULE|PUBLIC)); // [A0]
122 
123         // m1
124         findConstructor(lookup, p1_Type1, void.class);
125         findConstructor(lookup, p2_Type2, void.class);
126 
127         // m2
128         findConstructor(lookup, q1_Type1, void.class);
129         findConstructorExpectingIAE(lookup, q2_Type2, void.class);
130 
131         // java.base
132         findConstructor(lookup, Object.class, void.class);
<span class="line-modified">133         findConstructorExpectingIAE(lookup, signalClass, void.class, String.class);</span>
134 
135         // unnamed
136         findConstructor(lookup, unnamedClass, void.class);
137     }
138 
139     /**
140      * Hop to lookup class in another named module
141      *
<span class="line-modified">142      * [A0] has PUBLIC access if accessible; otherwise no access</span>
<span class="line-added">143      * [A1] old lookup class becomes previous lookup class</span>
144      */
145     public void testFromNamedToNamedModule() throws Exception {
<span class="line-added">146         // m2/q1_Type1 is accessible to m1 whereas m2/q_Type2 is not accessible</span>
147         Lookup lookup = MethodHandles.lookup().in(q1_Type1);
<span class="line-modified">148         assertTrue(lookup.lookupModes() == PUBLIC); // [A0]</span>
<span class="line-added">149         assertTrue(lookup.previousLookupClass() == Main.class); // [A1]</span>
<span class="line-added">150 </span>
<span class="line-added">151         Lookup lookup2 = MethodHandles.lookup().in(q2_Type2);</span>
<span class="line-added">152         assertTrue(lookup2.lookupModes() == 0);      // [A0]</span>
<span class="line-added">153         assertTrue(lookup2.previousLookupClass() == Main.class); // [A1]</span>
154 
155         // m1
156         findConstructorExpectingIAE(lookup, p1_Type1, void.class);
157         findConstructorExpectingIAE(lookup, p2_Type2, void.class);
158 
<span class="line-added">159         findConstructorExpectingIAE(lookup2, p1_Type1, void.class);</span>
<span class="line-added">160         findConstructorExpectingIAE(lookup2, p2_Type2, void.class);</span>
<span class="line-added">161 </span>
162         // m2
<span class="line-modified">163         findConstructor(lookup, q1_Type1, void.class);  // m2/q1 is exported</span>
164         findConstructorExpectingIAE(lookup, q2_Type2, void.class);
165 
<span class="line-added">166         findConstructorExpectingIAE(lookup2, q1_Type1, void.class);</span>
<span class="line-added">167         findConstructorExpectingIAE(lookup2, q2_Type2, void.class);</span>
<span class="line-added">168 </span>
169         // java.base
<span class="line-modified">170         findConstructor(lookup, Object.class, void.class);</span>
<span class="line-modified">171         findConstructorExpectingIAE(lookup, signalClass, void.class, String.class);</span>
<span class="line-added">172 </span>
<span class="line-added">173         findConstructorExpectingIAE(lookup2, Object.class, void.class);</span>
<span class="line-added">174         findConstructorExpectingIAE(lookup2, signalClass, void.class, String.class);</span>
175 
176         // unnamed
177         findConstructorExpectingIAE(lookup, unnamedClass, void.class);
<span class="line-added">178 </span>
<span class="line-added">179         findConstructorExpectingIAE(lookup2, unnamedClass, void.class);</span>
<span class="line-added">180 </span>
181     }
182 
183     /**
184      * Hop to lookup class in an unnamed module
185      *
<span class="line-modified">186      * [A0] has PUBLIC access</span>
187      */
188     public void testFromNamedToUnnamedModule() throws Exception {
189         Lookup lookup = MethodHandles.lookup().in(unnamedClass);
<span class="line-modified">190         assertTrue(lookup.lookupModes() == PUBLIC); // [A0]</span>
191 
192         // m1
<span class="line-modified">193         findConstructor(lookup, p1_Type1, void.class);      // p1 is exported</span>
194         findConstructorExpectingIAE(lookup, p2_Type2, void.class);
195 
196         // m2
<span class="line-modified">197         findConstructor(lookup, q1_Type1, void.class);</span>
198         findConstructorExpectingIAE(lookup, q2_Type2, void.class);
199 
200         // java.base
<span class="line-modified">201         findConstructor(lookup, Object.class, void.class);</span>
<span class="line-modified">202         findConstructorExpectingIAE(lookup, signalClass, void.class, String.class);</span>
203 
204         // unnamed
<span class="line-modified">205         findConstructor(lookup, unnamedClass, void.class);</span>
206     }
207 
208     /**
209      * Hop from unnamed to named module.
210      *
211      * [A0] retains PUBLIC access
212      */
213     public void testFromUnnamedToNamedModule() throws Exception {
214         Lookup lookup = MethodHandles.lookup();
215         lookup = MethodHandles.privateLookupIn(unnamedClass, lookup).in(p1_Type1);
216         assertTrue(lookup.lookupModes() == PUBLIC); // A0
217 
218         // m1
219         findConstructor(lookup, p1_Type1, void.class);
220         findConstructorExpectingIAE(lookup, p2_Type2, void.class);
221 
222         // m2
223         findConstructor(lookup, q1_Type1, void.class);
224         findConstructorExpectingIAE(lookup, q2_Type2, void.class);
225 
226         // java.base
227         findConstructor(lookup, Object.class, void.class);
<span class="line-modified">228         findConstructorExpectingIAE(lookup, signalClass, void.class, String.class);</span>
229 
230         // unnamed
231         findConstructor(lookup, unnamedClass, void.class);
232     }
233 
234     /**
235      * MethodHandles.publicLookup()
236      *
<span class="line-modified">237      * [A0] has UNCONDITIONAL access</span>
238      */
239     public void testPublicLookup() throws Exception {
240         Lookup lookup = MethodHandles.publicLookup();
<span class="line-modified">241         assertTrue(lookup.lookupModes() == UNCONDITIONAL); // A0</span>
242 
243         // m1
244         findConstructor(lookup, p1_Type1, void.class);
245         findConstructorExpectingIAE(lookup, p2_Type2, void.class);
246 
247         // m2
248         findConstructor(lookup, q1_Type1, void.class);
249         findConstructorExpectingIAE(lookup, q2_Type2, void.class);
250 
251         // java.base
252         findConstructor(lookup, Object.class, void.class);
<span class="line-modified">253         findConstructorExpectingIAE(lookup, signalClass, void.class, String.class);</span>
254 
255         // unnamed
256         findConstructor(lookup, unnamedClass, void.class);
257     }
258 
259     /**
260      * Hop from publicLookup to accessible type in java.base
<span class="line-added">261      *</span>
<span class="line-added">262      * [A0] has UNCONDITIONAL access</span>
263      */
264     public void testPublicLookupToBaseModule() throws Exception {
265         Lookup lookup = MethodHandles.publicLookup().in(String.class);
<span class="line-modified">266         assertTrue(lookup.lookupModes() == UNCONDITIONAL); // A0</span>
267 
268         // m1
<span class="line-modified">269         findConstructor(lookup, p1_Type1, void.class);</span>
270         findConstructorExpectingIAE(lookup, p2_Type2, void.class);
271 
272         // m2
<span class="line-modified">273         findConstructor(lookup, q1_Type1, void.class);</span>
274         findConstructorExpectingIAE(lookup, q2_Type2, void.class);
275 
276         // java.base
277         findConstructor(lookup, Object.class, void.class);
<span class="line-modified">278         findConstructorExpectingIAE(lookup, signalClass, void.class, String.class);</span>
279 
280         // unnamed
<span class="line-modified">281         findConstructor(lookup, unnamedClass, void.class);</span>
282     }
283 
284 
285     /**
286      * Hop from publicLookup to accessible type in named module.
287      *
<span class="line-modified">288      * [A0] has UNCONDITIONAL access</span>
289      */
290     public void testPublicLookupToAccessibleTypeInNamedModule() throws Exception {
291         Lookup lookup = MethodHandles.publicLookup().in(p1_Type1);
<span class="line-modified">292         assertTrue(lookup.lookupModes() == UNCONDITIONAL); // A0</span>
293 
294         // m1
295         findConstructor(lookup, p1_Type1, void.class);
296         findConstructorExpectingIAE(lookup, p2_Type2, void.class);
297 
298         // m2
299         findConstructor(lookup, q1_Type1, void.class);
300         findConstructorExpectingIAE(lookup, q2_Type2, void.class);
301 
302         // java.base
303         findConstructor(lookup, Object.class, void.class);
<span class="line-modified">304         findConstructorExpectingIAE(lookup, signalClass, void.class, String.class);</span>
305 
306         // unnamed
307         findConstructor(lookup, unnamedClass, void.class);
308     }
309 
310     /**
311      * Teleport from publicLookup to inaccessible type in named module.
312      *
313      * [A0] has no access
314      */
315     public void testPublicLookupToInaccessibleTypeInNamedModule() throws Exception {
316         Lookup lookup = MethodHandles.publicLookup().in(p2_Type2);
317         assertTrue(lookup.lookupModes() == 0); // A0
318 
319         // m1
320         findConstructorExpectingIAE(lookup, p1_Type1, void.class);
321         findConstructorExpectingIAE(lookup, p2_Type2, void.class);
322 
323         // m2
324         findConstructorExpectingIAE(lookup, q1_Type1, void.class);
325         findConstructorExpectingIAE(lookup, q2_Type2, void.class);
326 
327         // java.base
328         findConstructorExpectingIAE(lookup, Object.class, void.class);
<span class="line-modified">329         findConstructorExpectingIAE(lookup, signalClass, void.class, String.class);</span>
330 
331         // unnamed
332         findConstructorExpectingIAE(lookup, unnamedClass, void.class);
333     }
334 
335     /**
336      * Teleport from publicLookup to public type in unnamed module
337      *
<span class="line-modified">338      * [A0] has UNCONDITIONAL access</span>
339      */
340     public void testPublicLookupToUnnamedModule() throws Exception {
341         Lookup lookup = MethodHandles.publicLookup().in(unnamedClass);
<span class="line-modified">342         assertTrue(lookup.lookupModes() == UNCONDITIONAL); // A0</span>
343 
344         // m1
345         findConstructor(lookup, p1_Type1, void.class);
346         findConstructorExpectingIAE(lookup, p2_Type2, void.class);
347 
348         // m2
349         findConstructor(lookup, q1_Type1, void.class);
350         findConstructorExpectingIAE(lookup, q2_Type2, void.class);
351 
352         // java.base
353         findConstructor(lookup, Object.class, void.class);
<span class="line-modified">354         findConstructorExpectingIAE(lookup, signalClass, void.class, String.class);</span>
355 
356         // unnamed
357         findConstructor(lookup, unnamedClass, void.class);
358     }
359 
360     /**
361      * Invokes Lookup findConstructor with a method type constructored from the
362      * given return and parameter types, expecting IllegalAccessException to be
363      * thrown.
364      */
365     static void findConstructorExpectingIAE(Lookup lookup,
366                                             Class&lt;?&gt; clazz,
367                                             Class&lt;?&gt; rtype,
368                                             Class&lt;?&gt;... ptypes) throws Exception {
369         try {
370             findConstructor(lookup, clazz, rtype, ptypes);
371             assertTrue(false);
372         } catch (IllegalAccessException expected) { }
373     }
374 
</pre>
</td>
</tr>
</table>
<center><a href="../../Unnamed.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="../../../../management/GarbageCollectorMXBean/GcInfoCompositeType.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff test/jdk/java/lang/invoke/MethodHandlesTest.java</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
<body>
<center><a href="MethodHandlesGeneralTest.java.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="TryFinallyTest.java.cdiff.html" target="_top">next &gt;</a></center>    <h2>test/jdk/java/lang/invoke/MethodHandlesTest.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 1,7 ***</span>
  /*
<span class="line-modified">!  * Copyright (c) 2009, 2018, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.
<span class="line-new-header">--- 1,7 ---</span>
  /*
<span class="line-modified">!  * Copyright (c) 2009, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 36,10 ***</span>
<span class="line-new-header">--- 36,11 ---</span>
  import java.util.ArrayList;
  import java.util.Arrays;
  import java.util.Collection;
  import java.util.Collections;
  import java.util.List;
<span class="line-added">+ import java.util.stream.Stream;</span>
  
  import static org.junit.Assert.*;
  
  /**
   *
</pre>
<hr />
<pre>
<span class="line-old-header">*** 543,35 ***</span>
          if (x.toString().contains(s))  return;
          assertEquals(s, x);
      }
  
      public static class HasFields {
<span class="line-modified">!         boolean fZ = false;</span>
<span class="line-modified">!         byte fB = (byte)&#39;B&#39;;</span>
<span class="line-modified">!         short fS = (short)&#39;S&#39;;</span>
<span class="line-modified">!         char fC = &#39;C&#39;;</span>
<span class="line-modified">!         int fI = &#39;I&#39;;</span>
<span class="line-modified">!         long fJ = &#39;J&#39;;</span>
<span class="line-modified">!         float fF = &#39;F&#39;;</span>
<span class="line-modified">!         double fD = &#39;D&#39;;</span>
          static boolean sZ = true;
          static byte sB = 1+(byte)&#39;B&#39;;
          static short sS = 1+(short)&#39;S&#39;;
          static char sC = 1+&#39;C&#39;;
          static int sI = 1+&#39;I&#39;;
          static long sJ = 1+&#39;J&#39;;
          static float sF = 1+&#39;F&#39;;
          static double sD = 1+&#39;D&#39;;
  
<span class="line-modified">!         Object fL = &#39;L&#39;;</span>
<span class="line-modified">!         String fR = &quot;R&quot;;</span>
<span class="line-modified">!         static Object sL = &#39;M&#39;;</span>
<span class="line-modified">!         static String sR = &quot;S&quot;;</span>
<span class="line-modified">! </span>
<span class="line-modified">!         static final Object[][] CASES;</span>
          static {
<span class="line-removed">-             ArrayList&lt;Object[]&gt; cases = new ArrayList&lt;&gt;();</span>
              Object types[][] = {
                  {&#39;L&#39;,Object.class}, {&#39;R&#39;,String.class},
                  {&#39;I&#39;,int.class}, {&#39;J&#39;,long.class},
                  {&#39;F&#39;,float.class}, {&#39;D&#39;,double.class},
                  {&#39;Z&#39;,boolean.class}, {&#39;B&#39;,byte.class},
<span class="line-new-header">--- 544,57 ---</span>
          if (x.toString().contains(s))  return;
          assertEquals(s, x);
      }
  
      public static class HasFields {
<span class="line-modified">!         boolean iZ = false;</span>
<span class="line-modified">!         byte iB = (byte)&#39;B&#39;;</span>
<span class="line-modified">!         short iS = (short)&#39;S&#39;;</span>
<span class="line-modified">!         char iC = &#39;C&#39;;</span>
<span class="line-modified">!         int iI = &#39;I&#39;;</span>
<span class="line-modified">!         long iJ = &#39;J&#39;;</span>
<span class="line-modified">!         float iF = &#39;F&#39;;</span>
<span class="line-modified">!         double iD = &#39;D&#39;;</span>
          static boolean sZ = true;
          static byte sB = 1+(byte)&#39;B&#39;;
          static short sS = 1+(short)&#39;S&#39;;
          static char sC = 1+&#39;C&#39;;
          static int sI = 1+&#39;I&#39;;
          static long sJ = 1+&#39;J&#39;;
          static float sF = 1+&#39;F&#39;;
          static double sD = 1+&#39;D&#39;;
  
<span class="line-modified">!         // final fields</span>
<span class="line-modified">!         final boolean fiZ = false;</span>
<span class="line-modified">!         final byte fiB = 2+(byte)&#39;B&#39;;</span>
<span class="line-modified">!         final short fiS = 2+(short)&#39;S&#39;;</span>
<span class="line-modified">!         final char fiC = 2+&#39;C&#39;;</span>
<span class="line-modified">!         final int fiI = 2+&#39;I&#39;;</span>
<span class="line-added">+         final long fiJ = 2+&#39;J&#39;;</span>
<span class="line-added">+         final float fiF = 2+&#39;F&#39;;</span>
<span class="line-added">+         final double fiD = 2+&#39;D&#39;;</span>
<span class="line-added">+         final static boolean fsZ = false;</span>
<span class="line-added">+         final static byte fsB = 3+(byte)&#39;B&#39;;</span>
<span class="line-added">+         final static short fsS = 3+(short)&#39;S&#39;;</span>
<span class="line-added">+         final static char fsC = 3+&#39;C&#39;;</span>
<span class="line-added">+         final static int fsI = 3+&#39;I&#39;;</span>
<span class="line-added">+         final static long fsJ = 3+&#39;J&#39;;</span>
<span class="line-added">+         final static float fsF = 3+&#39;F&#39;;</span>
<span class="line-added">+         final static double fsD = 3+&#39;D&#39;;</span>
<span class="line-added">+ </span>
<span class="line-added">+         Object iL = &#39;L&#39;;</span>
<span class="line-added">+         String iR = &quot;iR&quot;;</span>
<span class="line-added">+         static Object sL = 1+&#39;L&#39;;</span>
<span class="line-added">+         static String sR = &quot;sR&quot;;</span>
<span class="line-added">+         final Object fiL = 2+&#39;L&#39;;</span>
<span class="line-added">+         final String fiR = &quot;fiR&quot;;</span>
<span class="line-added">+         final static Object fsL = 3+&#39;L&#39;;</span>
<span class="line-added">+         final static String fsR = &quot;fsR&quot;;</span>
<span class="line-added">+ </span>
<span class="line-added">+         static final ArrayList&lt;Object[]&gt; STATIC_FIELD_CASES = new ArrayList&lt;&gt;();</span>
<span class="line-added">+         static final ArrayList&lt;Object[]&gt; INSTANCE_FIELD_CASES = new ArrayList&lt;&gt;();</span>
          static {
              Object types[][] = {
                  {&#39;L&#39;,Object.class}, {&#39;R&#39;,String.class},
                  {&#39;I&#39;,int.class}, {&#39;J&#39;,long.class},
                  {&#39;F&#39;,float.class}, {&#39;D&#39;,double.class},
                  {&#39;Z&#39;,boolean.class}, {&#39;B&#39;,byte.class},
</pre>
<hr />
<pre>
<span class="line-old-header">*** 579,39 ***</span>
              };
              HasFields fields = new HasFields();
              for (Object[] t : types) {
                  for (int kind = 0; kind &lt;= 1; kind++) {
                      boolean isStatic = (kind != 0);
                      char btc = (Character)t[0];
<span class="line-modified">!                     String name = (isStatic ? &quot;s&quot; : &quot;f&quot;) + btc;</span>
                      Class&lt;?&gt; type = (Class&lt;?&gt;) t[1];
<span class="line-modified">!                     Object value;</span>
<span class="line-modified">!                     Field field;</span>
<span class="line-modified">!                         try {</span>
<span class="line-removed">-                         field = HasFields.class.getDeclaredField(name);</span>
<span class="line-removed">-                     } catch (NoSuchFieldException | SecurityException ex) {</span>
<span class="line-removed">-                         throw new InternalError(&quot;no field HasFields.&quot;+name);</span>
<span class="line-removed">-                     }</span>
<span class="line-removed">-                     try {</span>
<span class="line-removed">-                         value = field.get(fields);</span>
<span class="line-removed">-                     } catch (IllegalArgumentException | IllegalAccessException ex) {</span>
<span class="line-removed">-                         throw new InternalError(&quot;cannot fetch field HasFields.&quot;+name);</span>
<span class="line-removed">-                     }</span>
                      if (type == float.class) {
                          float v = &#39;F&#39;;
                          if (isStatic)  v++;
                          assertTrue(value.equals(v));
                      }
<span class="line-modified">!                     assertTrue(name.equals(field.getName()));</span>
<span class="line-modified">!                     assertTrue(type.equals(field.getType()));</span>
<span class="line-modified">!                     assertTrue(isStatic == (Modifier.isStatic(field.getModifiers())));</span>
<span class="line-modified">!                     cases.add(new Object[]{ field, value });</span>
                  }
              }
<span class="line-modified">!             cases.add(new Object[]{ new Object[]{ false, HasFields.class, &quot;bogus_fD&quot;, double.class }, Error.class });</span>
<span class="line-modified">!             cases.add(new Object[]{ new Object[]{ true,  HasFields.class, &quot;bogus_sL&quot;, Object.class }, Error.class });</span>
<span class="line-modified">!             CASES = cases.toArray(new Object[0][]);</span>
          }
      }
  
      static final int TEST_UNREFLECT = 1, TEST_FIND_FIELD = 2, TEST_FIND_STATIC = 3, TEST_SETTER = 0x10, TEST_BOUND = 0x20, TEST_NPE = 0x40;
  
<span class="line-new-header">--- 602,93 ---</span>
              };
              HasFields fields = new HasFields();
              for (Object[] t : types) {
                  for (int kind = 0; kind &lt;= 1; kind++) {
                      boolean isStatic = (kind != 0);
<span class="line-added">+                     ArrayList&lt;Object[]&gt; cases = isStatic ? STATIC_FIELD_CASES : INSTANCE_FIELD_CASES;</span>
                      char btc = (Character)t[0];
<span class="line-modified">!                     String fname = (isStatic ? &quot;s&quot; : &quot;i&quot;) + btc;</span>
<span class="line-added">+                     String finalFname = (isStatic ? &quot;fs&quot; : &quot;fi&quot;) + btc;</span>
                      Class&lt;?&gt; type = (Class&lt;?&gt;) t[1];
<span class="line-modified">!                     // non-final field</span>
<span class="line-modified">!                     Field nonFinalField = getField(fname, type);</span>
<span class="line-modified">!                     Object value = getValue(fields, nonFinalField);</span>
                      if (type == float.class) {
                          float v = &#39;F&#39;;
                          if (isStatic)  v++;
                          assertTrue(value.equals(v));
                      }
<span class="line-modified">!                     assertTrue(isStatic == (Modifier.isStatic(nonFinalField.getModifiers())));</span>
<span class="line-modified">!                     cases.add(new Object[]{ nonFinalField, value });</span>
<span class="line-modified">! </span>
<span class="line-modified">!                     // setAccessible(true) on final field but static final field only has read access</span>
<span class="line-added">+                     Field finalField = getField(finalFname, type);</span>
<span class="line-added">+                     Object fvalue = getValue(fields, finalField);</span>
<span class="line-added">+                     finalField.setAccessible(true);</span>
<span class="line-added">+                     assertTrue(isStatic == (Modifier.isStatic(finalField.getModifiers())));</span>
<span class="line-added">+                     cases.add(new Object[]{ finalField, fvalue, Error.class});</span>
                  }
              }
<span class="line-modified">!             INSTANCE_FIELD_CASES.add(new Object[]{ new Object[]{ false, HasFields.class, &quot;bogus_fD&quot;, double.class }, Error.class });</span>
<span class="line-modified">!             STATIC_FIELD_CASES.add(new Object[]{ new Object[]{ true,  HasFields.class, &quot;bogus_sL&quot;, Object.class }, Error.class });</span>
<span class="line-modified">!         }</span>
<span class="line-added">+ </span>
<span class="line-added">+         private static Field getField(String name, Class&lt;?&gt; type) {</span>
<span class="line-added">+             try {</span>
<span class="line-added">+                 Field field = HasFields.class.getDeclaredField(name);</span>
<span class="line-added">+                 assertTrue(name.equals(field.getName()));</span>
<span class="line-added">+                 assertTrue(type.equals(field.getType()));</span>
<span class="line-added">+                 return field;</span>
<span class="line-added">+             } catch (NoSuchFieldException | SecurityException ex) {</span>
<span class="line-added">+                 throw new InternalError(&quot;no field HasFields.&quot;+name);</span>
<span class="line-added">+             }</span>
<span class="line-added">+         }</span>
<span class="line-added">+ </span>
<span class="line-added">+         private static Object getValue(Object o, Field field) {</span>
<span class="line-added">+             try {</span>
<span class="line-added">+                 return field.get(o);</span>
<span class="line-added">+             } catch (IllegalArgumentException | IllegalAccessException ex) {</span>
<span class="line-added">+                 throw new InternalError(&quot;cannot fetch field HasFields.&quot;+field.getName());</span>
<span class="line-added">+             }</span>
<span class="line-added">+         }</span>
<span class="line-added">+ </span>
<span class="line-added">+         static Object[][] testCasesFor(int testMode) {</span>
<span class="line-added">+             Stream&lt;Object[]&gt; cases;</span>
<span class="line-added">+             if ((testMode &amp; TEST_UNREFLECT) != 0) {</span>
<span class="line-added">+                 cases = Stream.concat(STATIC_FIELD_CASES.stream(), INSTANCE_FIELD_CASES.stream());</span>
<span class="line-added">+             } else if ((testMode &amp; TEST_FIND_STATIC) != 0) {</span>
<span class="line-added">+                 cases = STATIC_FIELD_CASES.stream();</span>
<span class="line-added">+             } else if ((testMode &amp; TEST_FIND_FIELD) != 0) {</span>
<span class="line-added">+                 cases = INSTANCE_FIELD_CASES.stream();</span>
<span class="line-added">+             } else {</span>
<span class="line-added">+                 throw new InternalError(&quot;unexpected test mode: &quot; + testMode);</span>
<span class="line-added">+             }</span>
<span class="line-added">+             return cases.map(c -&gt; mapTestCase(testMode, c)).toArray(Object[][]::new);</span>
<span class="line-added">+ </span>
<span class="line-added">+         }</span>
<span class="line-added">+ </span>
<span class="line-added">+         private static Object[] mapTestCase(int testMode, Object[] c) {</span>
<span class="line-added">+             // non-final fields (2-element) and final fields (3-element) if not TEST_SETTER</span>
<span class="line-added">+             if (c.length == 2 || (testMode &amp; TEST_SETTER) == 0)</span>
<span class="line-added">+                 return c;</span>
<span class="line-added">+ </span>
<span class="line-added">+             // final fields (3-element)</span>
<span class="line-added">+             assertTrue((testMode &amp; TEST_SETTER) != 0 &amp;&amp; c[0] instanceof Field &amp;&amp; c[2] == Error.class);</span>
<span class="line-added">+             if ((testMode &amp; TEST_UNREFLECT) == 0)</span>
<span class="line-added">+                 return new Object[]{ c[0], c[2]};   // negative test case; can&#39;t set on final fields</span>
<span class="line-added">+ </span>
<span class="line-added">+             // unreflectSetter grants write access on instance final field if accessible flag is true</span>
<span class="line-added">+             // hence promote the negative test case to positive test case</span>
<span class="line-added">+             Field f = (Field) c[0];</span>
<span class="line-added">+             int mods = f.getModifiers();</span>
<span class="line-added">+             if (!Modifier.isFinal(mods) || (!Modifier.isStatic(mods) &amp;&amp; f.isAccessible())) {</span>
<span class="line-added">+                 // positive test case</span>
<span class="line-added">+                 return new Object[]{ c[0], c[1] };</span>
<span class="line-added">+             } else {</span>
<span class="line-added">+                 // otherwise, negative test case</span>
<span class="line-added">+                 return new Object[]{ c[0], c[2]};</span>
<span class="line-added">+             }</span>
          }
      }
  
      static final int TEST_UNREFLECT = 1, TEST_FIND_FIELD = 2, TEST_FIND_STATIC = 3, TEST_SETTER = 0x10, TEST_BOUND = 0x20, TEST_NPE = 0x40;
  
</pre>
<center><a href="MethodHandlesGeneralTest.java.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="TryFinallyTest.java.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
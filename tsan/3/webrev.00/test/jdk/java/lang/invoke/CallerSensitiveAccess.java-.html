<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old test/jdk/java/lang/invoke/CallerSensitiveAccess.java</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2018, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 /* @test
 25  * @bug 8196830
 26  * @modules java.base/jdk.internal.reflect
 27  * @run testng/othervm --illegal-access=deny CallerSensitiveAccess
 28  * @summary Check Lookup findVirtual, findStatic and unreflect behavior with
 29  *          caller sensitive methods with focus on AccessibleObject.setAccessible
 30  */
 31 
 32 import java.io.IOException;
 33 import java.io.UncheckedIOException;
 34 import java.lang.invoke.MethodHandle;
 35 import java.lang.invoke.MethodHandles;
 36 import java.lang.invoke.MethodHandles.Lookup;
 37 import java.lang.invoke.MethodType;
 38 import java.lang.module.ModuleReader;
 39 import java.lang.module.ModuleReference;
 40 import java.lang.reflect.AccessibleObject;
 41 import java.lang.reflect.Field;
 42 import java.lang.reflect.InaccessibleObjectException;
 43 import java.lang.reflect.Method;
 44 import java.lang.reflect.Modifier;
 45 import java.util.Arrays;
 46 import java.util.List;
 47 import java.util.StringJoiner;
 48 import java.util.stream.Collectors;
 49 import java.util.stream.Stream;
 50 
 51 import jdk.internal.reflect.CallerSensitive;
 52 
 53 import org.testng.annotations.DataProvider;
 54 import org.testng.annotations.NoInjection;
 55 import org.testng.annotations.Test;
 56 import static org.testng.Assert.*;
 57 
 58 public class CallerSensitiveAccess {
 59 
 60     /**
 61      * Caller sensitive methods in APIs exported by java.base.
 62      */
 63     @DataProvider(name = &quot;callerSensitiveMethods&quot;)
 64     static Object[][] callerSensitiveMethods() {
 65         return callerSensitiveMethods(Object.class.getModule())
 66                 .map(m -&gt; new Object[] { m, shortDescription(m) })
 67                 .toArray(Object[][]::new);
 68     }
 69 
 70     /**
 71      * Using publicLookup, attempt to use findVirtual or findStatic to obtain a
 72      * method handle to a caller sensitive method.
 73      */
 74     @Test(dataProvider = &quot;callerSensitiveMethods&quot;,
 75             expectedExceptions = IllegalAccessException.class)
 76     public void testPublicLookupFind(@NoInjection Method method, String desc) throws Exception {
 77         Lookup lookup = MethodHandles.publicLookup();
 78         Class&lt;?&gt; refc = method.getDeclaringClass();
 79         String name = method.getName();
 80         MethodType mt = MethodType.methodType(method.getReturnType(), method.getParameterTypes());
 81         if (Modifier.isStatic(method.getModifiers())) {
 82             lookup.findStatic(refc, name, mt);
 83         } else {
 84             lookup.findVirtual(refc, name, mt);
 85         }
 86     }
 87 
 88     /**
 89      * Using publicLookup, attempt to use unreflect to obtain a method handle to a
 90      * caller sensitive method.
 91      */
 92     @Test(dataProvider = &quot;callerSensitiveMethods&quot;,
 93             expectedExceptions = IllegalAccessException.class)
 94     public void testPublicLookupUnreflect(@NoInjection Method method, String desc) throws Exception {
 95         MethodHandles.publicLookup().unreflect(method);
 96     }
 97 
 98 
 99     // -- Test method handles to setAccessible --
100 
101     private int aField;
102 
103     Field accessibleField() {
104         try {
105             return getClass().getDeclaredField(&quot;aField&quot;);
106         } catch (NoSuchFieldException e) {
107             fail();
108             return null;
109         }
110     }
111 
112     Field inaccessibleField() {
113         try {
114             return String.class.getDeclaredField(&quot;hash&quot;);
115         } catch (NoSuchFieldException e) {
116             fail();
117             return null;
118         }
119     }
120 
121     void findAndInvokeSetAccessible(Class&lt;? extends AccessibleObject&gt; refc, Field f) throws Throwable {
122         MethodType mt = MethodType.methodType(void.class, boolean.class);
123         MethodHandle mh = MethodHandles.lookup().findVirtual(refc, &quot;setAccessible&quot;, mt);
124         mh.invoke(f, true);  // may throw InaccessibleObjectException
125         assertTrue(f.isAccessible());
126     }
127 
128     void unreflectAndInvokeSetAccessible(Method m, Field f) throws Throwable {
129         assertTrue(m.getName().equals(&quot;setAccessible&quot;));
130         assertFalse(Modifier.isStatic(m.getModifiers()));
131         MethodHandle mh = MethodHandles.lookup().unreflect(m);
132         mh.invoke(f, true);   // may throw InaccessibleObjectException
133         assertTrue(f.isAccessible());
134     }
135 
136     /**
137      * Create a method handle to setAccessible and use it to suppress access to an
138      * accessible member.
139      */
140     @Test
141     public void testSetAccessible1() throws Throwable {
142         findAndInvokeSetAccessible(AccessibleObject.class, accessibleField());
143     }
144     @Test
145     public void testSetAccessible2() throws Throwable {
146         findAndInvokeSetAccessible(Field.class, accessibleField());
147     }
148     @Test
149     public void testSetAccessible3() throws Throwable {
150         Method m = AccessibleObject.class.getMethod(&quot;setAccessible&quot;, boolean.class);
151         unreflectAndInvokeSetAccessible(m, accessibleField());
152     }
153     @Test
154     public void testSetAccessible4() throws Throwable {
155         Method m = Field.class.getMethod(&quot;setAccessible&quot;, boolean.class);
156         unreflectAndInvokeSetAccessible(m, accessibleField());
157     }
158 
159     /**
160      * Create a method handle to setAccessible and attempt to use it to suppress
161      * access to an inaccessible member.
162      */
163     @Test(expectedExceptions = InaccessibleObjectException.class)
164     public void testSetAccessible5() throws Throwable {
165         findAndInvokeSetAccessible(AccessibleObject.class, inaccessibleField());
166     }
167     @Test(expectedExceptions = InaccessibleObjectException.class)
168     public void testSetAccessible6() throws Throwable {
169         findAndInvokeSetAccessible(Field.class, inaccessibleField());
170     }
171     @Test(expectedExceptions = InaccessibleObjectException.class)
172     public void testSetAccessible7() throws Throwable {
173         Method m = AccessibleObject.class.getMethod(&quot;setAccessible&quot;, boolean.class);
174         unreflectAndInvokeSetAccessible(m, inaccessibleField());
175     }
176     @Test(expectedExceptions = InaccessibleObjectException.class)
177     public void testSetAccessible8() throws Throwable {
178         Method m = Field.class.getMethod(&quot;setAccessible&quot;, boolean.class);
179         unreflectAndInvokeSetAccessible(m, inaccessibleField());
180     }
181 
182 
183     // -- Test sub-classes of AccessibleObject --
184 
185     /**
186      * Custom AccessibleObject objects. One class overrides setAccessible, the other
187      * does not override this method.
188      */
189     @DataProvider(name = &quot;customAccessibleObjects&quot;)
190     static Object[][] customAccessibleObjectClasses() {
191         return new Object[][] { { new S1() }, { new S2() } };
192     }
193     public static class S1 extends AccessibleObject { }
194     public static class S2 extends AccessibleObject {
195         @Override
196         public void setAccessible(boolean flag) {
197             super.setAccessible(flag);
198         }
199     }
200 
201     void findAndInvokeSetAccessible(Lookup lookup, AccessibleObject obj) throws Throwable {
202         MethodType mt = MethodType.methodType(void.class, boolean.class);
203         MethodHandle mh = lookup.findVirtual(obj.getClass(), &quot;setAccessible&quot;, mt);
204         mh.invoke(obj, true);
205         assertTrue(obj.isAccessible());
206     }
207 
208     void unreflectAndInvokeSetAccessible(Lookup lookup, AccessibleObject obj) throws Throwable {
209         Method m = obj.getClass().getMethod(&quot;setAccessible&quot;, boolean.class);
210         MethodHandle mh = lookup.unreflect(m);
211         mh.invoke(obj, true);
212         assertTrue(obj.isAccessible());
213     }
214 
215     /**
216      * Using publicLookup, create a method handle to setAccessible and invoke it
217      * on a custom AccessibleObject object.
218      */
219     @Test(expectedExceptions = IllegalAccessException.class)
220     public void testPublicLookupSubclass1() throws Throwable {
221         // S1 does not override setAccessible
222         findAndInvokeSetAccessible(MethodHandles.publicLookup(), new S1());
223     }
224     @Test
225     public void testPublicLookupSubclass2() throws Throwable {
226         // S2 overrides setAccessible
227         findAndInvokeSetAccessible(MethodHandles.publicLookup(), new S2());
228     }
229     @Test(expectedExceptions = IllegalAccessException.class)
230     public void testPublicLookupSubclass3() throws Throwable {
231         // S1 does not override setAccessible
232         unreflectAndInvokeSetAccessible(MethodHandles.publicLookup(), new S1());
233     }
234     @Test
235     public void testPublicLookupSubclass4() throws Throwable {
236         // S2 overrides setAccessible
237         unreflectAndInvokeSetAccessible(MethodHandles.publicLookup(), new S2());
238     }
239 
240     /**
241      * Using a full power lookup, create a method handle to setAccessible and
242      * invoke it on a custom AccessibleObject object.
243      */
244     @Test(dataProvider = &quot;customAccessibleObjects&quot;)
245     public void testLookupSubclass1(AccessibleObject obj) throws Throwable {
246         findAndInvokeSetAccessible(MethodHandles.lookup(), obj);
247     }
248     @Test(dataProvider = &quot;customAccessibleObjects&quot;)
249     public void testLookupSubclass2(AccessibleObject obj) throws Throwable {
250         unreflectAndInvokeSetAccessible(MethodHandles.lookup(), obj);
251     }
252 
253     /**
254      * Using a full power lookup, create a method handle to setAccessible on a
255      * sub-class of AccessibleObject and then attempt to invoke it on a Field object.
256      */
257     @Test(dataProvider = &quot;customAccessibleObjects&quot;,
258             expectedExceptions = ClassCastException.class)
259     public void testLookupSubclass3(AccessibleObject obj) throws Throwable {
260         MethodType mt = MethodType.methodType(void.class, boolean.class);
261         Lookup lookup = MethodHandles.lookup();
262         MethodHandle mh = lookup.findVirtual(obj.getClass(), &quot;setAccessible&quot;, mt);
263         mh.invoke(accessibleField(), true);  // should throw ClassCastException
264     }
265 
266     /**
267      * Using a full power lookup, use unreflect to create a method handle to
268      * setAccessible on a sub-class of AccessibleObject, then attempt to invoke
269      * it on a Field object.
270      */
271     @Test
272     public void testLookupSubclass4() throws Throwable {
273         // S1 does not override setAccessible
274         Method m = S1.class.getMethod(&quot;setAccessible&quot;, boolean.class);
275         assertTrue(m.getDeclaringClass() == AccessibleObject.class);
276         MethodHandle mh = MethodHandles.lookup().unreflect(m);
277         Field f = accessibleField();
278         mh.invoke(f, true);
279         assertTrue(f.isAccessible());
280     }
281     @Test(expectedExceptions = InaccessibleObjectException.class)
282     public void testLookupSubclass5() throws Throwable {
283         // S1 does not override setAccessible
284         Method m = S1.class.getMethod(&quot;setAccessible&quot;, boolean.class);
285         assertTrue(m.getDeclaringClass() == AccessibleObject.class);
286         MethodHandle mh = MethodHandles.lookup().unreflect(m);
287         mh.invoke(inaccessibleField(), true);  // should throw InaccessibleObjectException
288     }
289     @Test(expectedExceptions = ClassCastException.class)
290     public void testLookupSubclass6() throws Throwable {
291         // S2 overrides setAccessible
292         Method m = S2.class.getMethod(&quot;setAccessible&quot;, boolean.class);
293         assertTrue(m.getDeclaringClass() == S2.class);
294         MethodHandle mh = MethodHandles.lookup().unreflect(m);
295         mh.invoke(accessibleField(), true);  // should throw ClassCastException
296     }
297     @Test(expectedExceptions = ClassCastException.class)
298     public void testLookupSubclass7() throws Throwable {
299         // S2 overrides setAccessible
300         Method m = S2.class.getMethod(&quot;setAccessible&quot;, boolean.class);
301         assertTrue(m.getDeclaringClass() == S2.class);
302         MethodHandle mh = MethodHandles.lookup().unreflect(m);
303         mh.invoke(inaccessibleField(), true);  // should throw ClassCastException
304     }
305 
306 
307     // -- supporting methods --
308 
309     /**
310      * Returns a stream of all caller sensitive methods on public classes in packages
311      * exported by a named module.
312      */
313     static Stream&lt;Method&gt; callerSensitiveMethods(Module module) {
314         assert module.isNamed();
315         ModuleReference mref = module.getLayer().configuration()
316                 .findModule(module.getName())
317                 .orElseThrow(() -&gt; new RuntimeException())
318                 .reference();
319         // find all &quot;.class&quot; resources in the module
320         // transform the resource name to a class name
321         // load every class in the exported packages
322         // return the caller sensitive methods of the public classes
323         try (ModuleReader reader = mref.open()) {
324             return reader.list()
325                     .filter(rn -&gt; rn.endsWith(&quot;.class&quot;))
326                     .map(rn -&gt; rn.substring(0, rn.length() - 6)
327                                  .replace(&#39;/&#39;, &#39;.&#39;))
328                     .filter(cn -&gt; module.isExported(packageName(cn)))
329                     .map(cn -&gt; Class.forName(module, cn))
330                     .filter(refc -&gt; refc != null
331                                     &amp;&amp; Modifier.isPublic(refc.getModifiers()))
332                     .map(refc -&gt; callerSensitiveMethods(refc))
333                     .flatMap(List::stream);
334         } catch (IOException ioe) {
335             throw new UncheckedIOException(ioe);
336         }
337     }
338 
339     static String packageName(String cn) {
340         int last = cn.lastIndexOf(&#39;.&#39;);
341         if (last &gt; 0) {
342             return cn.substring(0, last);
343         } else {
344             return &quot;&quot;;
345         }
346     }
347 
348     /**
349      * Returns a list of the caller sensitive methods directly declared by the given
350      * class.
351      */
352     static List&lt;Method&gt; callerSensitiveMethods(Class&lt;?&gt; refc) {
353         return Arrays.stream(refc.getDeclaredMethods())
354                 .filter(m -&gt; m.isAnnotationPresent(CallerSensitive.class))
355                 .collect(Collectors.toList());
356     }
357 
358     /**
359      * Returns a short description of the given method for tracing purposes.
360      */
361     static String shortDescription(Method m) {
362         var sb = new StringBuilder();
363         sb.append(m.getDeclaringClass().getName());
364         sb.append(&#39;.&#39;);
365         sb.append(m.getName());
366         sb.append(&#39;(&#39;);
367         StringJoiner sj = new StringJoiner(&quot;,&quot;);
368         for (Class&lt;?&gt; parameterType : m.getParameterTypes()) {
369             sj.add(parameterType.getTypeName());
370         }
371         sb.append(sj);
372         sb.append(&#39;)&#39;);
373         return sb.toString();
374     }
375 }
    </pre>
  </body>
</html>
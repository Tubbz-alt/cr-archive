<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames test/jdk/java/lang/invoke/CallerSensitiveAccess.java</title>
    <link rel="stylesheet" href="../../../../../style.css" />
    <script type="text/javascript" src="../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (c) 2018, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 /* @test
<a name="1" id="anc1"></a><span class="line-modified"> 25  * @bug 8196830 8235351</span>
 26  * @modules java.base/jdk.internal.reflect
 27  * @run testng/othervm --illegal-access=deny CallerSensitiveAccess
 28  * @summary Check Lookup findVirtual, findStatic and unreflect behavior with
 29  *          caller sensitive methods with focus on AccessibleObject.setAccessible
 30  */
 31 
 32 import java.io.IOException;
 33 import java.io.UncheckedIOException;
 34 import java.lang.invoke.MethodHandle;
 35 import java.lang.invoke.MethodHandles;
 36 import java.lang.invoke.MethodHandles.Lookup;
 37 import java.lang.invoke.MethodType;
 38 import java.lang.module.ModuleReader;
 39 import java.lang.module.ModuleReference;
 40 import java.lang.reflect.AccessibleObject;
 41 import java.lang.reflect.Field;
 42 import java.lang.reflect.InaccessibleObjectException;
 43 import java.lang.reflect.Method;
 44 import java.lang.reflect.Modifier;
 45 import java.util.Arrays;
 46 import java.util.List;
 47 import java.util.StringJoiner;
 48 import java.util.stream.Collectors;
 49 import java.util.stream.Stream;
 50 
 51 import jdk.internal.reflect.CallerSensitive;
 52 
 53 import org.testng.annotations.DataProvider;
 54 import org.testng.annotations.NoInjection;
 55 import org.testng.annotations.Test;
 56 import static org.testng.Assert.*;
 57 
 58 public class CallerSensitiveAccess {
 59 
 60     /**
 61      * Caller sensitive methods in APIs exported by java.base.
 62      */
 63     @DataProvider(name = &quot;callerSensitiveMethods&quot;)
 64     static Object[][] callerSensitiveMethods() {
 65         return callerSensitiveMethods(Object.class.getModule())
 66                 .map(m -&gt; new Object[] { m, shortDescription(m) })
 67                 .toArray(Object[][]::new);
 68     }
 69 
 70     /**
 71      * Using publicLookup, attempt to use findVirtual or findStatic to obtain a
 72      * method handle to a caller sensitive method.
 73      */
 74     @Test(dataProvider = &quot;callerSensitiveMethods&quot;,
 75             expectedExceptions = IllegalAccessException.class)
 76     public void testPublicLookupFind(@NoInjection Method method, String desc) throws Exception {
 77         Lookup lookup = MethodHandles.publicLookup();
 78         Class&lt;?&gt; refc = method.getDeclaringClass();
 79         String name = method.getName();
 80         MethodType mt = MethodType.methodType(method.getReturnType(), method.getParameterTypes());
 81         if (Modifier.isStatic(method.getModifiers())) {
 82             lookup.findStatic(refc, name, mt);
 83         } else {
 84             lookup.findVirtual(refc, name, mt);
 85         }
 86     }
 87 
 88     /**
 89      * Using publicLookup, attempt to use unreflect to obtain a method handle to a
 90      * caller sensitive method.
 91      */
 92     @Test(dataProvider = &quot;callerSensitiveMethods&quot;,
 93             expectedExceptions = IllegalAccessException.class)
 94     public void testPublicLookupUnreflect(@NoInjection Method method, String desc) throws Exception {
 95         MethodHandles.publicLookup().unreflect(method);
 96     }
 97 
<a name="2" id="anc2"></a><span class="line-added"> 98     /**</span>
<span class="line-added"> 99      * public accessible caller sensitive methods in APIs exported by java.base.</span>
<span class="line-added">100      */</span>
<span class="line-added">101     @DataProvider(name = &quot;accessibleCallerSensitiveMethods&quot;)</span>
<span class="line-added">102     static Object[][] accessibleCallerSensitiveMethods() {</span>
<span class="line-added">103         return callerSensitiveMethods(Object.class.getModule())</span>
<span class="line-added">104                 .filter(m -&gt; Modifier.isPublic(m.getModifiers()))</span>
<span class="line-added">105                 .map(m -&gt; { m.setAccessible(true); return m; })</span>
<span class="line-added">106                 .map(m -&gt; new Object[] { m, shortDescription(m) })</span>
<span class="line-added">107                 .toArray(Object[][]::new);</span>
<span class="line-added">108     }</span>
<span class="line-added">109 </span>
<span class="line-added">110     /**</span>
<span class="line-added">111      * Using publicLookup, attempt to use unreflect to obtain a method handle to a</span>
<span class="line-added">112      * caller sensitive method.</span>
<span class="line-added">113      */</span>
<span class="line-added">114     @Test(dataProvider = &quot;accessibleCallerSensitiveMethods&quot;,</span>
<span class="line-added">115             expectedExceptions = IllegalAccessException.class)</span>
<span class="line-added">116     public void testLookupUnreflect(@NoInjection Method method, String desc) throws Exception {</span>
<span class="line-added">117         MethodHandles.publicLookup().unreflect(method);</span>
<span class="line-added">118     }</span>
119 
120     // -- Test method handles to setAccessible --
121 
122     private int aField;
123 
124     Field accessibleField() {
125         try {
126             return getClass().getDeclaredField(&quot;aField&quot;);
127         } catch (NoSuchFieldException e) {
128             fail();
129             return null;
130         }
131     }
132 
133     Field inaccessibleField() {
134         try {
135             return String.class.getDeclaredField(&quot;hash&quot;);
136         } catch (NoSuchFieldException e) {
137             fail();
138             return null;
139         }
140     }
141 
142     void findAndInvokeSetAccessible(Class&lt;? extends AccessibleObject&gt; refc, Field f) throws Throwable {
143         MethodType mt = MethodType.methodType(void.class, boolean.class);
144         MethodHandle mh = MethodHandles.lookup().findVirtual(refc, &quot;setAccessible&quot;, mt);
145         mh.invoke(f, true);  // may throw InaccessibleObjectException
146         assertTrue(f.isAccessible());
147     }
148 
149     void unreflectAndInvokeSetAccessible(Method m, Field f) throws Throwable {
150         assertTrue(m.getName().equals(&quot;setAccessible&quot;));
151         assertFalse(Modifier.isStatic(m.getModifiers()));
152         MethodHandle mh = MethodHandles.lookup().unreflect(m);
153         mh.invoke(f, true);   // may throw InaccessibleObjectException
154         assertTrue(f.isAccessible());
155     }
156 
157     /**
158      * Create a method handle to setAccessible and use it to suppress access to an
159      * accessible member.
160      */
161     @Test
162     public void testSetAccessible1() throws Throwable {
163         findAndInvokeSetAccessible(AccessibleObject.class, accessibleField());
164     }
165     @Test
166     public void testSetAccessible2() throws Throwable {
167         findAndInvokeSetAccessible(Field.class, accessibleField());
168     }
169     @Test
170     public void testSetAccessible3() throws Throwable {
171         Method m = AccessibleObject.class.getMethod(&quot;setAccessible&quot;, boolean.class);
172         unreflectAndInvokeSetAccessible(m, accessibleField());
173     }
174     @Test
175     public void testSetAccessible4() throws Throwable {
176         Method m = Field.class.getMethod(&quot;setAccessible&quot;, boolean.class);
177         unreflectAndInvokeSetAccessible(m, accessibleField());
178     }
179 
180     /**
181      * Create a method handle to setAccessible and attempt to use it to suppress
182      * access to an inaccessible member.
183      */
184     @Test(expectedExceptions = InaccessibleObjectException.class)
185     public void testSetAccessible5() throws Throwable {
186         findAndInvokeSetAccessible(AccessibleObject.class, inaccessibleField());
187     }
188     @Test(expectedExceptions = InaccessibleObjectException.class)
189     public void testSetAccessible6() throws Throwable {
190         findAndInvokeSetAccessible(Field.class, inaccessibleField());
191     }
192     @Test(expectedExceptions = InaccessibleObjectException.class)
193     public void testSetAccessible7() throws Throwable {
194         Method m = AccessibleObject.class.getMethod(&quot;setAccessible&quot;, boolean.class);
195         unreflectAndInvokeSetAccessible(m, inaccessibleField());
196     }
197     @Test(expectedExceptions = InaccessibleObjectException.class)
198     public void testSetAccessible8() throws Throwable {
199         Method m = Field.class.getMethod(&quot;setAccessible&quot;, boolean.class);
200         unreflectAndInvokeSetAccessible(m, inaccessibleField());
201     }
202 
203 
204     // -- Test sub-classes of AccessibleObject --
205 
206     /**
207      * Custom AccessibleObject objects. One class overrides setAccessible, the other
208      * does not override this method.
209      */
210     @DataProvider(name = &quot;customAccessibleObjects&quot;)
211     static Object[][] customAccessibleObjectClasses() {
212         return new Object[][] { { new S1() }, { new S2() } };
213     }
214     public static class S1 extends AccessibleObject { }
215     public static class S2 extends AccessibleObject {
216         @Override
217         public void setAccessible(boolean flag) {
218             super.setAccessible(flag);
219         }
220     }
221 
222     void findAndInvokeSetAccessible(Lookup lookup, AccessibleObject obj) throws Throwable {
223         MethodType mt = MethodType.methodType(void.class, boolean.class);
224         MethodHandle mh = lookup.findVirtual(obj.getClass(), &quot;setAccessible&quot;, mt);
225         mh.invoke(obj, true);
226         assertTrue(obj.isAccessible());
227     }
228 
229     void unreflectAndInvokeSetAccessible(Lookup lookup, AccessibleObject obj) throws Throwable {
230         Method m = obj.getClass().getMethod(&quot;setAccessible&quot;, boolean.class);
231         MethodHandle mh = lookup.unreflect(m);
232         mh.invoke(obj, true);
233         assertTrue(obj.isAccessible());
234     }
235 
236     /**
237      * Using publicLookup, create a method handle to setAccessible and invoke it
238      * on a custom AccessibleObject object.
239      */
240     @Test(expectedExceptions = IllegalAccessException.class)
241     public void testPublicLookupSubclass1() throws Throwable {
242         // S1 does not override setAccessible
243         findAndInvokeSetAccessible(MethodHandles.publicLookup(), new S1());
244     }
245     @Test
246     public void testPublicLookupSubclass2() throws Throwable {
247         // S2 overrides setAccessible
248         findAndInvokeSetAccessible(MethodHandles.publicLookup(), new S2());
249     }
250     @Test(expectedExceptions = IllegalAccessException.class)
251     public void testPublicLookupSubclass3() throws Throwable {
252         // S1 does not override setAccessible
253         unreflectAndInvokeSetAccessible(MethodHandles.publicLookup(), new S1());
254     }
255     @Test
256     public void testPublicLookupSubclass4() throws Throwable {
257         // S2 overrides setAccessible
258         unreflectAndInvokeSetAccessible(MethodHandles.publicLookup(), new S2());
259     }
260 
261     /**
262      * Using a full power lookup, create a method handle to setAccessible and
263      * invoke it on a custom AccessibleObject object.
264      */
265     @Test(dataProvider = &quot;customAccessibleObjects&quot;)
266     public void testLookupSubclass1(AccessibleObject obj) throws Throwable {
267         findAndInvokeSetAccessible(MethodHandles.lookup(), obj);
268     }
269     @Test(dataProvider = &quot;customAccessibleObjects&quot;)
270     public void testLookupSubclass2(AccessibleObject obj) throws Throwable {
271         unreflectAndInvokeSetAccessible(MethodHandles.lookup(), obj);
272     }
273 
274     /**
275      * Using a full power lookup, create a method handle to setAccessible on a
276      * sub-class of AccessibleObject and then attempt to invoke it on a Field object.
277      */
278     @Test(dataProvider = &quot;customAccessibleObjects&quot;,
279             expectedExceptions = ClassCastException.class)
280     public void testLookupSubclass3(AccessibleObject obj) throws Throwable {
281         MethodType mt = MethodType.methodType(void.class, boolean.class);
282         Lookup lookup = MethodHandles.lookup();
283         MethodHandle mh = lookup.findVirtual(obj.getClass(), &quot;setAccessible&quot;, mt);
284         mh.invoke(accessibleField(), true);  // should throw ClassCastException
285     }
286 
287     /**
288      * Using a full power lookup, use unreflect to create a method handle to
289      * setAccessible on a sub-class of AccessibleObject, then attempt to invoke
290      * it on a Field object.
291      */
292     @Test
293     public void testLookupSubclass4() throws Throwable {
294         // S1 does not override setAccessible
295         Method m = S1.class.getMethod(&quot;setAccessible&quot;, boolean.class);
296         assertTrue(m.getDeclaringClass() == AccessibleObject.class);
297         MethodHandle mh = MethodHandles.lookup().unreflect(m);
298         Field f = accessibleField();
299         mh.invoke(f, true);
300         assertTrue(f.isAccessible());
301     }
302     @Test(expectedExceptions = InaccessibleObjectException.class)
303     public void testLookupSubclass5() throws Throwable {
304         // S1 does not override setAccessible
305         Method m = S1.class.getMethod(&quot;setAccessible&quot;, boolean.class);
306         assertTrue(m.getDeclaringClass() == AccessibleObject.class);
307         MethodHandle mh = MethodHandles.lookup().unreflect(m);
308         mh.invoke(inaccessibleField(), true);  // should throw InaccessibleObjectException
309     }
310     @Test(expectedExceptions = ClassCastException.class)
311     public void testLookupSubclass6() throws Throwable {
312         // S2 overrides setAccessible
313         Method m = S2.class.getMethod(&quot;setAccessible&quot;, boolean.class);
314         assertTrue(m.getDeclaringClass() == S2.class);
315         MethodHandle mh = MethodHandles.lookup().unreflect(m);
316         mh.invoke(accessibleField(), true);  // should throw ClassCastException
317     }
318     @Test(expectedExceptions = ClassCastException.class)
319     public void testLookupSubclass7() throws Throwable {
320         // S2 overrides setAccessible
321         Method m = S2.class.getMethod(&quot;setAccessible&quot;, boolean.class);
322         assertTrue(m.getDeclaringClass() == S2.class);
323         MethodHandle mh = MethodHandles.lookup().unreflect(m);
324         mh.invoke(inaccessibleField(), true);  // should throw ClassCastException
325     }
326 
327 
328     // -- supporting methods --
329 
330     /**
331      * Returns a stream of all caller sensitive methods on public classes in packages
332      * exported by a named module.
333      */
334     static Stream&lt;Method&gt; callerSensitiveMethods(Module module) {
335         assert module.isNamed();
336         ModuleReference mref = module.getLayer().configuration()
337                 .findModule(module.getName())
338                 .orElseThrow(() -&gt; new RuntimeException())
339                 .reference();
340         // find all &quot;.class&quot; resources in the module
341         // transform the resource name to a class name
342         // load every class in the exported packages
343         // return the caller sensitive methods of the public classes
344         try (ModuleReader reader = mref.open()) {
345             return reader.list()
346                     .filter(rn -&gt; rn.endsWith(&quot;.class&quot;))
347                     .map(rn -&gt; rn.substring(0, rn.length() - 6)
348                                  .replace(&#39;/&#39;, &#39;.&#39;))
349                     .filter(cn -&gt; module.isExported(packageName(cn)))
350                     .map(cn -&gt; Class.forName(module, cn))
351                     .filter(refc -&gt; refc != null
352                                     &amp;&amp; Modifier.isPublic(refc.getModifiers()))
353                     .map(refc -&gt; callerSensitiveMethods(refc))
354                     .flatMap(List::stream);
355         } catch (IOException ioe) {
356             throw new UncheckedIOException(ioe);
357         }
358     }
359 
360     static String packageName(String cn) {
361         int last = cn.lastIndexOf(&#39;.&#39;);
362         if (last &gt; 0) {
363             return cn.substring(0, last);
364         } else {
365             return &quot;&quot;;
366         }
367     }
368 
369     /**
370      * Returns a list of the caller sensitive methods directly declared by the given
371      * class.
372      */
373     static List&lt;Method&gt; callerSensitiveMethods(Class&lt;?&gt; refc) {
374         return Arrays.stream(refc.getDeclaredMethods())
375                 .filter(m -&gt; m.isAnnotationPresent(CallerSensitive.class))
376                 .collect(Collectors.toList());
377     }
378 
379     /**
380      * Returns a short description of the given method for tracing purposes.
381      */
382     static String shortDescription(Method m) {
383         var sb = new StringBuilder();
384         sb.append(m.getDeclaringClass().getName());
385         sb.append(&#39;.&#39;);
386         sb.append(m.getName());
387         sb.append(&#39;(&#39;);
388         StringJoiner sj = new StringJoiner(&quot;,&quot;);
389         for (Class&lt;?&gt; parameterType : m.getParameterTypes()) {
390             sj.add(parameterType.getTypeName());
391         }
392         sb.append(sj);
393         sb.append(&#39;)&#39;);
394         return sb.toString();
395     }
396 }
<a name="3" id="anc3"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="3" type="hidden" />
</body>
</html>
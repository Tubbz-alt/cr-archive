<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames test/jdk/java/lang/invoke/modules/m1/p1/Main.java</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
<a name="1" id="anc1"></a><span class="line-modified">  2  * Copyright (c) 2015, 2017, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 package p1;
 25 
 26 import java.lang.invoke.MethodHandle;
 27 import java.lang.invoke.MethodHandles;
 28 import java.lang.invoke.MethodHandles.Lookup;
 29 import java.lang.invoke.MethodType;
 30 
 31 import static java.lang.invoke.MethodHandles.Lookup.*;
 32 
 33 import org.testng.annotations.BeforeTest;
 34 import org.testng.annotations.Test;
 35 import static org.testng.Assert.*;
 36 
 37 /**
 38  * Basic test case for module access checks and Lookup.in.
 39  */
 40 
 41 @Test
 42 public class Main {
 43 
 44     private Class&lt;?&gt; p1_Type1;        // m1, exported
 45     private Class&lt;?&gt; p2_Type2;        // m1, not exported
 46     private Class&lt;?&gt; q1_Type1;        // m2, exported
 47     private Class&lt;?&gt; q2_Type2;        // m2, not exported
<a name="2" id="anc2"></a><span class="line-modified"> 48     private Class&lt;?&gt; x500NameClass;   // java.base, not exported</span>
 49     private Class&lt;?&gt; unnamedClass;    // class in unnamed module
 50 
 51     @BeforeTest
 52     public void setup() throws Exception {
 53         try {
 54             p1_Type1 = Class.forName(&quot;p1.Type1&quot;);
 55             p2_Type2 = Class.forName(&quot;p2.Type2&quot;);
 56             q1_Type1 = Class.forName(&quot;q1.Type1&quot;);
 57             q2_Type2 = Class.forName(&quot;q2.Type2&quot;);
<a name="3" id="anc3"></a><span class="line-modified"> 58             x500NameClass = Class.forName(&quot;sun.security.x509.X500Name&quot;);</span>
 59             unnamedClass = Class.forName(&quot;Unnamed&quot;);
 60         } catch (ClassNotFoundException e) {
 61             throw new AssertionError(e);
 62         }
 63 
 64         // check setup
 65         Module m1 = ModuleLayer.boot().findModule(&quot;m1&quot;).orElse(null);
 66         assertNotNull(m1);
 67         assertTrue(p1_Type1.getModule() == m1);
 68         assertTrue(p2_Type2.getModule() == m1);
 69         assertTrue(m1.isExported(&quot;p1&quot;));
 70         assertFalse(m1.isExported(&quot;p2&quot;));
 71 
 72         Module m2 = ModuleLayer.boot().findModule(&quot;m2&quot;).orElse(null);
 73         assertNotNull(m2);
 74         assertTrue(q1_Type1.getModule() == m2);
 75         assertTrue(q2_Type2.getModule() == m2);
 76         assertTrue(m2.isExported(&quot;q1&quot;));
 77         assertFalse(m2.isExported(&quot;q2&quot;));
 78 
 79         Module unnamedModule = unnamedClass.getModule();
 80         assertFalse(unnamedModule.isNamed());
 81 
 82         // m1 needs to read unnamed module
 83         Main.class.getModule().addReads(unnamedModule);
 84     }
 85 
 86     /**
 87      * MethodHandles.lookup()
 88      *
 89      * [A0] has module access
 90      * [A1] can access all public types in m1
 91      * [A2] can access public types in packages exported by modules that m1 reads
 92      * [A3] cannot access public types in non-exported modules of modules that m1 reads
 93      */
 94     public void testLookup() throws Exception {
 95         Lookup lookup = MethodHandles.lookup();
 96         assertTrue((lookup.lookupModes() &amp; MODULE) == MODULE); // [A0]
 97 
 98         // m1
 99         findConstructor(lookup, p1_Type1, void.class); // [A1]
100         findConstructor(lookup, p2_Type2, void.class); // [A1]
101 
102         // m2
103         findConstructor(lookup, q1_Type1, void.class); // [A2]
104         findConstructorExpectingIAE(lookup, q2_Type2, void.class); // [A3]
105 
106         // java.base
107         findConstructor(lookup, Object.class, void.class); // [A2]
<a name="4" id="anc4"></a><span class="line-modified">108         findConstructorExpectingIAE(lookup, x500NameClass, void.class, String.class); // [A3]</span>
109 
110         // unnamed
111         findConstructor(lookup, unnamedClass, void.class);  // [A3]
112     }
113 
114     /**
115      * Hop to lookup class in the same module
116      *
117      * [A0] module and public access is not lost
118      */
119     public void testToSameModule() throws Exception {
120         Lookup lookup = MethodHandles.lookup().in(p2_Type2);
121         assertTrue(lookup.lookupModes() == (MODULE|PUBLIC)); // [A0]
122 
123         // m1
124         findConstructor(lookup, p1_Type1, void.class);
125         findConstructor(lookup, p2_Type2, void.class);
126 
127         // m2
128         findConstructor(lookup, q1_Type1, void.class);
129         findConstructorExpectingIAE(lookup, q2_Type2, void.class);
130 
131         // java.base
132         findConstructor(lookup, Object.class, void.class);
<a name="5" id="anc5"></a><span class="line-modified">133         findConstructorExpectingIAE(lookup, x500NameClass, void.class, String.class);</span>
134 
135         // unnamed
136         findConstructor(lookup, unnamedClass, void.class);
137     }
138 
139     /**
140      * Hop to lookup class in another named module
141      *
<a name="6" id="anc6"></a><span class="line-modified">142      * [A0] has no access</span>

143      */
144     public void testFromNamedToNamedModule() throws Exception {
<a name="7" id="anc7"></a>
145         Lookup lookup = MethodHandles.lookup().in(q1_Type1);
<a name="8" id="anc8"></a><span class="line-modified">146         assertTrue(lookup.lookupModes() == 0); // [A0]</span>





147 
148         // m1
149         findConstructorExpectingIAE(lookup, p1_Type1, void.class);
150         findConstructorExpectingIAE(lookup, p2_Type2, void.class);
151 
<a name="9" id="anc9"></a>


152         // m2
<a name="10" id="anc10"></a><span class="line-modified">153         findConstructorExpectingIAE(lookup, q1_Type1, void.class);</span>
154         findConstructorExpectingIAE(lookup, q2_Type2, void.class);
155 
<a name="11" id="anc11"></a>


156         // java.base
<a name="12" id="anc12"></a><span class="line-modified">157         findConstructorExpectingIAE(lookup, Object.class, void.class);</span>
<span class="line-modified">158         findConstructorExpectingIAE(lookup, x500NameClass, void.class, String.class);</span>



159 
160         // unnamed
161         findConstructorExpectingIAE(lookup, unnamedClass, void.class);
<a name="13" id="anc13"></a>


162     }
163 
164     /**
165      * Hop to lookup class in an unnamed module
166      *
<a name="14" id="anc14"></a><span class="line-modified">167      * [A0] has no access</span>
168      */
169     public void testFromNamedToUnnamedModule() throws Exception {
170         Lookup lookup = MethodHandles.lookup().in(unnamedClass);
<a name="15" id="anc15"></a><span class="line-modified">171         assertTrue(lookup.lookupModes() == 0); // [A0]</span>
172 
173         // m1
<a name="16" id="anc16"></a><span class="line-modified">174         findConstructorExpectingIAE(lookup, p1_Type1, void.class);</span>
175         findConstructorExpectingIAE(lookup, p2_Type2, void.class);
176 
177         // m2
<a name="17" id="anc17"></a><span class="line-modified">178         findConstructorExpectingIAE(lookup, q1_Type1, void.class);</span>
179         findConstructorExpectingIAE(lookup, q2_Type2, void.class);
180 
181         // java.base
<a name="18" id="anc18"></a><span class="line-modified">182         findConstructorExpectingIAE(lookup, Object.class, void.class);</span>
<span class="line-modified">183         findConstructorExpectingIAE(lookup, x500NameClass, void.class, String.class);</span>
184 
185         // unnamed
<a name="19" id="anc19"></a><span class="line-modified">186         findConstructorExpectingIAE(lookup, unnamedClass, void.class);</span>
187     }
188 
189     /**
190      * Hop from unnamed to named module.
191      *
192      * [A0] retains PUBLIC access
193      */
194     public void testFromUnnamedToNamedModule() throws Exception {
195         Lookup lookup = MethodHandles.lookup();
196         lookup = MethodHandles.privateLookupIn(unnamedClass, lookup).in(p1_Type1);
197         assertTrue(lookup.lookupModes() == PUBLIC); // A0
198 
199         // m1
200         findConstructor(lookup, p1_Type1, void.class);
201         findConstructorExpectingIAE(lookup, p2_Type2, void.class);
202 
203         // m2
204         findConstructor(lookup, q1_Type1, void.class);
205         findConstructorExpectingIAE(lookup, q2_Type2, void.class);
206 
207         // java.base
208         findConstructor(lookup, Object.class, void.class);
<a name="20" id="anc20"></a><span class="line-modified">209         findConstructorExpectingIAE(lookup, x500NameClass, void.class, String.class);</span>
210 
211         // unnamed
212         findConstructor(lookup, unnamedClass, void.class);
213     }
214 
215     /**
216      * MethodHandles.publicLookup()
217      *
<a name="21" id="anc21"></a><span class="line-modified">218      * [A0] has PUBLIC|UNCONDITIONAL access</span>
219      */
220     public void testPublicLookup() throws Exception {
221         Lookup lookup = MethodHandles.publicLookup();
<a name="22" id="anc22"></a><span class="line-modified">222         assertTrue(lookup.lookupModes() == (PUBLIC|UNCONDITIONAL)); // A0</span>
223 
224         // m1
225         findConstructor(lookup, p1_Type1, void.class);
226         findConstructorExpectingIAE(lookup, p2_Type2, void.class);
227 
228         // m2
229         findConstructor(lookup, q1_Type1, void.class);
230         findConstructorExpectingIAE(lookup, q2_Type2, void.class);
231 
232         // java.base
233         findConstructor(lookup, Object.class, void.class);
<a name="23" id="anc23"></a><span class="line-modified">234         findConstructorExpectingIAE(lookup, x500NameClass, void.class, String.class);</span>
235 
236         // unnamed
237         findConstructor(lookup, unnamedClass, void.class);
238     }
239 
240     /**
241      * Hop from publicLookup to accessible type in java.base
<a name="24" id="anc24"></a>

242      */
243     public void testPublicLookupToBaseModule() throws Exception {
244         Lookup lookup = MethodHandles.publicLookup().in(String.class);
<a name="25" id="anc25"></a><span class="line-modified">245         assertTrue(lookup.lookupModes() == PUBLIC); // A0</span>
246 
247         // m1
<a name="26" id="anc26"></a><span class="line-modified">248         findConstructorExpectingIAE(lookup, p1_Type1, void.class);</span>
249         findConstructorExpectingIAE(lookup, p2_Type2, void.class);
250 
251         // m2
<a name="27" id="anc27"></a><span class="line-modified">252         findConstructorExpectingIAE(lookup, q1_Type1, void.class);</span>
253         findConstructorExpectingIAE(lookup, q2_Type2, void.class);
254 
255         // java.base
256         findConstructor(lookup, Object.class, void.class);
<a name="28" id="anc28"></a><span class="line-modified">257         findConstructorExpectingIAE(lookup, x500NameClass, void.class, String.class);</span>
258 
259         // unnamed
<a name="29" id="anc29"></a><span class="line-modified">260         findConstructorExpectingIAE(lookup, unnamedClass, void.class);</span>
261     }
262 
263 
264     /**
265      * Hop from publicLookup to accessible type in named module.
266      *
<a name="30" id="anc30"></a><span class="line-modified">267      * [A0] has PUBLIC access</span>
268      */
269     public void testPublicLookupToAccessibleTypeInNamedModule() throws Exception {
270         Lookup lookup = MethodHandles.publicLookup().in(p1_Type1);
<a name="31" id="anc31"></a><span class="line-modified">271         assertTrue(lookup.lookupModes() == PUBLIC); // A0</span>
272 
273         // m1
274         findConstructor(lookup, p1_Type1, void.class);
275         findConstructorExpectingIAE(lookup, p2_Type2, void.class);
276 
277         // m2
278         findConstructor(lookup, q1_Type1, void.class);
279         findConstructorExpectingIAE(lookup, q2_Type2, void.class);
280 
281         // java.base
282         findConstructor(lookup, Object.class, void.class);
<a name="32" id="anc32"></a><span class="line-modified">283         findConstructorExpectingIAE(lookup, x500NameClass, void.class, String.class);</span>
284 
285         // unnamed
286         findConstructor(lookup, unnamedClass, void.class);
287     }
288 
289     /**
290      * Teleport from publicLookup to inaccessible type in named module.
291      *
292      * [A0] has no access
293      */
294     public void testPublicLookupToInaccessibleTypeInNamedModule() throws Exception {
295         Lookup lookup = MethodHandles.publicLookup().in(p2_Type2);
296         assertTrue(lookup.lookupModes() == 0); // A0
297 
298         // m1
299         findConstructorExpectingIAE(lookup, p1_Type1, void.class);
300         findConstructorExpectingIAE(lookup, p2_Type2, void.class);
301 
302         // m2
303         findConstructorExpectingIAE(lookup, q1_Type1, void.class);
304         findConstructorExpectingIAE(lookup, q2_Type2, void.class);
305 
306         // java.base
307         findConstructorExpectingIAE(lookup, Object.class, void.class);
<a name="33" id="anc33"></a><span class="line-modified">308         findConstructorExpectingIAE(lookup, x500NameClass, void.class, String.class);</span>
309 
310         // unnamed
311         findConstructorExpectingIAE(lookup, unnamedClass, void.class);
312     }
313 
314     /**
315      * Teleport from publicLookup to public type in unnamed module
316      *
<a name="34" id="anc34"></a><span class="line-modified">317      * [A0] has PUBLIC access</span>
318      */
319     public void testPublicLookupToUnnamedModule() throws Exception {
320         Lookup lookup = MethodHandles.publicLookup().in(unnamedClass);
<a name="35" id="anc35"></a><span class="line-modified">321         assertTrue(lookup.lookupModes() == PUBLIC); // A0</span>
322 
323         // m1
324         findConstructor(lookup, p1_Type1, void.class);
325         findConstructorExpectingIAE(lookup, p2_Type2, void.class);
326 
327         // m2
328         findConstructor(lookup, q1_Type1, void.class);
329         findConstructorExpectingIAE(lookup, q2_Type2, void.class);
330 
331         // java.base
332         findConstructor(lookup, Object.class, void.class);
<a name="36" id="anc36"></a><span class="line-modified">333         findConstructorExpectingIAE(lookup, x500NameClass, void.class, String.class);</span>
334 
335         // unnamed
336         findConstructor(lookup, unnamedClass, void.class);
337     }
338 
339     /**
340      * Invokes Lookup findConstructor with a method type constructored from the
341      * given return and parameter types, expecting IllegalAccessException to be
342      * thrown.
343      */
344     static void findConstructorExpectingIAE(Lookup lookup,
345                                             Class&lt;?&gt; clazz,
346                                             Class&lt;?&gt; rtype,
347                                             Class&lt;?&gt;... ptypes) throws Exception {
348         try {
349             findConstructor(lookup, clazz, rtype, ptypes);
350             assertTrue(false);
351         } catch (IllegalAccessException expected) { }
352     }
353 
354     /**
355      * Invokes Lookup findConstructor with a method type constructored from the
356      * given return and parameter types.
357      */
358     static MethodHandle findConstructor(Lookup lookup,
359                                         Class&lt;?&gt; clazz,
360                                         Class&lt;?&gt; rtype,
361                                         Class&lt;?&gt;... ptypes) throws Exception {
362         MethodType mt = MethodType.methodType(rtype, ptypes);
363         return lookup.findConstructor(clazz, mt);
364     }
365 }
<a name="37" id="anc37"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="37" type="hidden" />
</body>
</html>
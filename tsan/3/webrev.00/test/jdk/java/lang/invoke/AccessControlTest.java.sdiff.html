<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff test/jdk/java/lang/invoke/AccessControlTest.java</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
<body>
<center><a href="../instrument/RedefineNestmateAttr/TestNestmateAttr.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="CallSiteTest.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>test/jdk/java/lang/invoke/AccessControlTest.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2012, 2018, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 /* @test
 25  * @summary test access checking by java.lang.invoke.MethodHandles.Lookup
 26  * @compile AccessControlTest.java AccessControlTest_subpkg/Acquaintance_remote.java
 27  * @run testng/othervm test.java.lang.invoke.AccessControlTest
 28  */
 29 
 30 package test.java.lang.invoke;
 31 
 32 import java.lang.invoke.*;
 33 import java.lang.reflect.*;
 34 import java.lang.reflect.Modifier;
 35 import java.util.*;
<span class="line-removed"> 36 import org.testng.*;</span>
 37 import org.testng.annotations.*;
 38 
 39 import static java.lang.invoke.MethodHandles.*;
 40 import static java.lang.invoke.MethodHandles.Lookup.*;
 41 import static java.lang.invoke.MethodType.*;
 42 import static org.testng.Assert.*;
 43 
 44 import test.java.lang.invoke.AccessControlTest_subpkg.Acquaintance_remote;
 45 
 46 
 47 /**
 48  * Test many combinations of Lookup access and cross-class lookupStatic.
 49  * @author jrose
 50  */
 51 public class AccessControlTest {
 52     static final Class&lt;?&gt; THIS_CLASS = AccessControlTest.class;
 53     // How much output?
 54     static int verbosity = 0;
 55     static {
 56         String vstr = System.getProperty(THIS_CLASS.getSimpleName()+&quot;.verbosity&quot;);
 57         if (vstr == null)
 58             vstr = System.getProperty(THIS_CLASS.getName()+&quot;.verbosity&quot;);
 59         if (vstr != null)  verbosity = Integer.parseInt(vstr);
 60     }
 61 
 62     private class LookupCase implements Comparable&lt;LookupCase&gt; {
 63         final Lookup   lookup;
 64         final Class&lt;?&gt; lookupClass;

 65         final int      lookupModes;
 66         public LookupCase(Lookup lookup) {
 67             this.lookup = lookup;
 68             this.lookupClass = lookup.lookupClass();

 69             this.lookupModes = lookup.lookupModes();

 70             assert(lookupString().equals(lookup.toString()));
 71             numberOf(lookupClass().getClassLoader()); // assign CL#
 72         }
<span class="line-modified"> 73         public LookupCase(Class&lt;?&gt; lookupClass, int lookupModes) {</span>
 74             this.lookup = null;
 75             this.lookupClass = lookupClass;

 76             this.lookupModes = lookupModes;
 77             numberOf(lookupClass().getClassLoader()); // assign CL#
 78         }
 79 
<span class="line-modified"> 80         public final Class&lt;?&gt; lookupClass() { return lookupClass; }</span>
<span class="line-modified"> 81         public final int      lookupModes() { return lookupModes; }</span>

 82 
 83         public Lookup lookup() { lookup.getClass(); return lookup; }
 84 
 85         @Override
 86         public int compareTo(LookupCase that) {
 87             Class&lt;?&gt; c1 = this.lookupClass();
 88             Class&lt;?&gt; c2 = that.lookupClass();


 89             if (c1 != c2) {
 90                 int cmp = c1.getName().compareTo(c2.getName());
 91                 if (cmp != 0)  return cmp;
 92                 cmp = numberOf(c1.getClassLoader()) - numberOf(c2.getClassLoader());
 93                 assert(cmp != 0);
 94                 return cmp;










 95             }
 96             return -(this.lookupModes() - that.lookupModes());
 97         }
 98 
 99         @Override
100         public boolean equals(Object that) {
101             return (that instanceof LookupCase &amp;&amp; equals((LookupCase)that));
102         }
103         public boolean equals(LookupCase that) {
104             return (this.lookupClass() == that.lookupClass() &amp;&amp;

105                     this.lookupModes() == that.lookupModes());
106         }
107 
108         @Override
109         public int hashCode() {
110             return lookupClass().hashCode() + (lookupModes() * 31);
111         }
112 
113         /** Simulate all assertions in the spec. for Lookup.toString. */
114         private String lookupString() {
115             String name = lookupClass.getName();


116             String suffix = &quot;&quot;;
117             if (lookupModes == 0)
118                 suffix = &quot;/noaccess&quot;;
119             else if (lookupModes == PUBLIC)
120                 suffix = &quot;/public&quot;;
<span class="line-modified">121              else if (lookupModes == (PUBLIC|UNCONDITIONAL))</span>
122                 suffix = &quot;/publicLookup&quot;;
123             else if (lookupModes == (PUBLIC|MODULE))
124                 suffix = &quot;/module&quot;;
<span class="line-modified">125             else if (lookupModes == (PUBLIC|MODULE|PACKAGE))</span>

126                 suffix = &quot;/package&quot;;
<span class="line-modified">127             else if (lookupModes == (PUBLIC|MODULE|PACKAGE|PRIVATE))</span>

128                 suffix = &quot;/private&quot;;
<span class="line-modified">129             else if (lookupModes == (PUBLIC|MODULE|PACKAGE|PRIVATE|PROTECTED))</span>

130                 suffix = &quot;&quot;;
131             else
132                 suffix = &quot;/#&quot;+Integer.toHexString(lookupModes);
133             return name+suffix;
134         }
135 
136         /** Simulate all assertions from the spec. for Lookup.in:
137          * &lt;hr&gt;
138          * Creates a lookup on the specified new lookup class.
139          * [A1] The resulting object will report the specified
140          * class as its own {@link #lookupClass lookupClass}.
<span class="line-removed">141          * &lt;p&gt;</span>
142          * [A2] However, the resulting {@code Lookup} object is guaranteed
143          * to have no more access capabilities than the original.
144          * In particular, access capabilities can be lost as follows:&lt;ul&gt;
<span class="line-modified">145          * &lt;li&gt; [A3] If the old lookup class is in a named module, and the new</span>
<span class="line-modified">146          * lookup class is in a different module {@code M}, then no members, not</span>
<span class="line-modified">147          * even public members in {@code M}&#39;s exported packages, will be accessible.</span>
<span class="line-modified">148          * The exception to this is when this lookup is publicLookup, in which case</span>
<span class="line-modified">149          * public access is not lost.</span>
<span class="line-modified">150          * &lt;li&gt; [A4] If the old lookup class is in an unnamed module, and the new</span>
<span class="line-modified">151          * lookup class is a different module then module access is lost.</span>
<span class="line-modified">152          * &lt;li&gt; [A5] If the new lookup class differs from the old one then UNCONDITIONAL</span>
<span class="line-modified">153          * is lost. If the new lookup class is not within the same package member as the</span>
<span class="line-removed">154          * old one, protected members will not be accessible by virtue of inheritance.</span>
155          * (Protected members may continue to be accessible because of package sharing.)
<span class="line-modified">156          * &lt;li&gt; [A6] If the new lookup class is in a different package than the old one,</span>
<span class="line-modified">157          * protected and default (package) members will not be accessible.</span>
<span class="line-modified">158          * &lt;li&gt; [A7] If the new lookup class is not within the same package member</span>
<span class="line-modified">159          * as the old one, private members will not be accessible.</span>
<span class="line-modified">160          * &lt;li&gt; [A8] If the new lookup class is not accessible to the old lookup class,</span>
<span class="line-modified">161          * then no members, not even public members, will be accessible.</span>
<span class="line-modified">162          * &lt;li&gt; [A9] (In all other cases, public members will continue to be accessible.)</span>
<span class="line-modified">163          * &lt;/ul&gt;</span>








164          * Other than the above cases, the new lookup will have the same
<span class="line-modified">165          * access capabilities as the original. [A10]</span>
166          * &lt;hr&gt;
167          */
168         public LookupCase in(Class&lt;?&gt; c2) {
169             Class&lt;?&gt; c1 = lookupClass();
<span class="line-modified">170             int m1 = lookupModes();</span>



171             int changed = 0;
172             // for the purposes of access control then treat classes in different unnamed
173             // modules as being in the same module.
<span class="line-modified">174             boolean sameModule = (c1.getModule() == c2.getModule()) ||</span>
<span class="line-modified">175                                  (!c1.getModule().isNamed() &amp;&amp; !c2.getModule().isNamed());</span>
176             boolean samePackage = (c1.getClassLoader() == c2.getClassLoader() &amp;&amp;
177                                    c1.getPackageName().equals(c2.getPackageName()));
178             boolean sameTopLevel = (topLevelClass(c1) == topLevelClass(c2));
179             boolean sameClass = (c1 == c2);
180             assert(samePackage  || !sameTopLevel);
181             assert(sameTopLevel || !sameClass);
182             boolean accessible = sameClass;
<span class="line-modified">183             if ((m1 &amp; PACKAGE) != 0)  accessible |= samePackage;</span>
<span class="line-modified">184             if ((m1 &amp; PUBLIC ) != 0)  accessible |= (c2.getModifiers() &amp; PUBLIC) != 0;</span>
<span class="line-modified">185             if (!sameModule) {</span>
<span class="line-modified">186                 if (c1.getModule().isNamed() &amp;&amp; (m1 &amp; UNCONDITIONAL) == 0) {</span>
<span class="line-modified">187                     accessible = false;  // [A3]</span>
<span class="line-modified">188                 } else {</span>
<span class="line-modified">189                     changed |= (MODULE|PACKAGE|PRIVATE|PROTECTED);    // [A3] [A4]</span>
<span class="line-modified">190                 }</span>





191             }
192             if (!accessible) {
<span class="line-modified">193                 // Different package and no access to c2; lose all access.</span>
<span class="line-modified">194                 changed |= (PUBLIC|MODULE|PACKAGE|PRIVATE|PROTECTED);  // [A8]</span>







195             }
196             if (!samePackage) {
197                 // Different package; loose PACKAGE and lower access.
<span class="line-modified">198                 changed |= (PACKAGE|PRIVATE|PROTECTED);  // [A6]</span>
199             }
200             if (!sameTopLevel) {
201                 // Different top-level class.  Lose PRIVATE and PROTECTED access.
<span class="line-modified">202                 changed |= (PRIVATE|PROTECTED);  // [A5] [A7]</span>
203             }
<span class="line-modified">204             if (!sameClass) {</span>
<span class="line-modified">205                 changed |= (UNCONDITIONAL);     // [A5]</span>
<span class="line-removed">206             } else {</span>
<span class="line-removed">207                 assert(changed == 0);       // [A10] (no deprivation if same class)</span>
208             }
<span class="line-modified">209             if (accessible)  assert((changed &amp; PUBLIC) == 0);  // [A9]</span>
<span class="line-modified">210             int m2 = m1 &amp; ~changed;</span>
<span class="line-modified">211             LookupCase l2 = new LookupCase(c2, m2);</span>
<span class="line-modified">212             assert(l2.lookupClass() == c2); // [A1]</span>
<span class="line-modified">213             assert((m1 | m2) == m1);        // [A2] (no elevation of access)</span>























214             return l2;
215         }
216 












217         @Override
218         public String toString() {
219             String s = lookupClass().getSimpleName();
220             String lstr = lookupString();
221             int sl = lstr.indexOf(&#39;/&#39;);
222             if (sl &gt;= 0)  s += lstr.substring(sl);
223             ClassLoader cld = lookupClass().getClassLoader();
224             if (cld != THIS_LOADER)  s += &quot;/loader#&quot;+numberOf(cld);
225             return s;
226         }
227 
228         /** Predict the success or failure of accessing this method. */
229         public boolean willAccess(Method m) {
230             Class&lt;?&gt; c1 = lookupClass();
231             Class&lt;?&gt; c2 = m.getDeclaringClass();










232 
<span class="line-modified">233             // publicLookup has access to all public types/members of types in unnamed modules</span>
<span class="line-modified">234             if ((lookupModes &amp; UNCONDITIONAL) != 0</span>
<span class="line-modified">235                 &amp;&amp; (lookupModes &amp; PUBLIC) != 0</span>
<span class="line-modified">236                 &amp;&amp; !c2.getModule().isNamed()</span>
<span class="line-modified">237                 &amp;&amp; Modifier.isPublic(c2.getModifiers())</span>
<span class="line-modified">238                 &amp;&amp; Modifier.isPublic(m.getModifiers()))</span>
<span class="line-modified">239                 return true;</span>





240 
241             LookupCase lc = this.in(c2);
<span class="line-modified">242             int m1 = lc.lookupModes();</span>
<span class="line-modified">243             int m2 = fixMods(m.getModifiers());</span>
244             // allow private lookup on nestmates. Otherwise, privacy is strictly enforced
<span class="line-modified">245             if (c1 != c2 &amp;&amp; ((m2 &amp; PRIVATE) == 0 || !c1.isNestmateOf(c2))) {</span>
<span class="line-modified">246                 m1 &amp;= ~PRIVATE;</span>
247             }
248             // protected access is sometimes allowed
<span class="line-modified">249             if ((m2 &amp; PROTECTED) != 0) {</span>
<span class="line-modified">250                 int prev = m2;</span>
<span class="line-modified">251                 m2 |= PACKAGE;  // it acts like a package method also</span>
252                 if ((lookupModes() &amp; PROTECTED) != 0 &amp;&amp;
253                     c2.isAssignableFrom(c1))
<span class="line-modified">254                     m2 |= PUBLIC;  // from a subclass, it acts like a public method also</span>
255             }
256             if (verbosity &gt;= 2)
<span class="line-modified">257                 System.out.format(&quot;%s willAccess %s m1=0x%h m2=0x%h =&gt; %s%n&quot;, this, lc, m1, m2, ((m2 &amp; m1) != 0));</span>
<span class="line-modified">258             return (m2 &amp; m1) != 0;</span>
259         }
260 
261         /** Predict the success or failure of accessing this class. */
262         public boolean willAccessClass(Class&lt;?&gt; c2, boolean load) {
263             Class&lt;?&gt; c1 = lookupClass();
264             if (load &amp;&amp; c2.getClassLoader() != null) {
265                 if (c1.getClassLoader() == null) {
266                     // not visible
267                     return false;
268                 }
269             }
270 
<span class="line-modified">271             // publicLookup has access to all public types/members of types in unnamed modules</span>
<span class="line-modified">272             if ((lookupModes &amp; UNCONDITIONAL) != 0</span>
<span class="line-modified">273                 &amp;&amp; (lookupModes &amp; PUBLIC) != 0</span>
<span class="line-modified">274                 &amp;&amp; (!c2.getModule().isNamed())</span>
<span class="line-modified">275                 &amp;&amp; Modifier.isPublic(c2.getModifiers()))</span>
<span class="line-modified">276                 return true;</span>









277 
278             LookupCase lc = this.in(c2);
<span class="line-modified">279             int m1 = lc.lookupModes();</span>
280             boolean r = false;
<span class="line-modified">281             if (m1 == 0) {</span>
282                 r = false;
283             } else {
<span class="line-modified">284                 int m2 = fixMods(c2.getModifiers());</span>
<span class="line-modified">285                 if ((m2 &amp; PUBLIC) != 0) {</span>
<span class="line-modified">286                     r = true;</span>
<span class="line-modified">287                 } else if ((m1 &amp; PACKAGE) != 0 &amp;&amp; c1.getPackage() == c2.getPackage()) {</span>
<span class="line-modified">288                     r = true;</span>



289                 }
290             }
291             if (verbosity &gt;= 2) {
292                 System.out.println(this+&quot; willAccessClass &quot;+lc+&quot; c1=&quot;+c1+&quot; c2=&quot;+c2+&quot; =&gt; &quot;+r);
293             }
294             return r;
295         }
296     }
297 
298     private static Class&lt;?&gt; topLevelClass(Class&lt;?&gt; cls) {
299         Class&lt;?&gt; c = cls;
300         for (Class&lt;?&gt; ec; (ec = c.getEnclosingClass()) != null; )
301             c = ec;
302         assert(c.getEnclosingClass() == null);
303         assert(c == cls || cls.getEnclosingClass() != null);
304         return c;
305     }
306 
307     private final TreeSet&lt;LookupCase&gt; CASES = new TreeSet&lt;&gt;();
308     private final TreeMap&lt;LookupCase,TreeSet&lt;LookupCase&gt;&gt; CASE_EDGES = new TreeMap&lt;&gt;();
</pre>
<hr />
<pre>
311     { if (THIS_LOADER != null)  LOADERS.add(THIS_LOADER); }  // #1
312 
313     private LookupCase lookupCase(String name) {
314         for (LookupCase lc : CASES) {
315             if (lc.toString().equals(name))
316                 return lc;
317         }
318         throw new AssertionError(name);
319     }
320 
321     private int numberOf(ClassLoader cl) {
322         if (cl == null)  return 0;
323         int i = LOADERS.indexOf(cl);
324         if (i &lt; 0) {
325             i = LOADERS.size();
326             LOADERS.add(cl);
327         }
328         return i+1;
329     }
330 
<span class="line-modified">331     private void addLookupEdge(LookupCase l1, Class&lt;?&gt; c2, LookupCase l2) {</span>
332         TreeSet&lt;LookupCase&gt; edges = CASE_EDGES.get(l2);
333         if (edges == null)  CASE_EDGES.put(l2, edges = new TreeSet&lt;&gt;());
334         if (edges.add(l1)) {
335             Class&lt;?&gt; c1 = l1.lookupClass();
336             assert(l2.lookupClass() == c2); // [A1]
337             int m1 = l1.lookupModes();
338             int m2 = l2.lookupModes();
339             assert((m1 | m2) == m1);        // [A2] (no elevation of access)
<span class="line-modified">340             LookupCase expect = l1.in(c2);</span>
341             if (!expect.equals(l2))
342                 System.out.println(&quot;*** expect &quot;+l1+&quot; =&gt; &quot;+expect+&quot; but got &quot;+l2);
343             assertEquals(l2, expect);
344         }
345     }
346 
347     private void makeCases(Lookup[] originalLookups) {
348         // make initial set of lookup test cases
349         CASES.clear(); LOADERS.clear(); CASE_EDGES.clear();
350         ArrayList&lt;Class&lt;?&gt;&gt; classes = new ArrayList&lt;&gt;();
351         for (Lookup l : originalLookups) {
352             CASES.add(new LookupCase(l));
353             classes.remove(l.lookupClass());  // no dups please
354             classes.add(l.lookupClass());
355         }
356         System.out.println(&quot;loaders = &quot;+LOADERS);
357         int rounds = 0;
358         for (int lastCount = -1; lastCount != CASES.size(); ) {
359             lastCount = CASES.size();  // if CASES grow in the loop we go round again
360             for (LookupCase lc1 : CASES.toArray(new LookupCase[0])) {





361                 for (Class&lt;?&gt; c2 : classes) {
362                     LookupCase lc2 = new LookupCase(lc1.lookup().in(c2));
<span class="line-modified">363                     addLookupEdge(lc1, c2, lc2);</span>
364                     CASES.add(lc2);
365                 }
366             }
367             rounds++;
368         }
369         System.out.println(&quot;filled in &quot;+CASES.size()+&quot; cases from &quot;+originalLookups.length+&quot; original cases in &quot;+rounds+&quot; rounds&quot;);
370         if (false) {
371             System.out.println(&quot;CASES: {&quot;);
372             for (LookupCase lc : CASES) {
373                 System.out.println(lc);
374                 Set&lt;LookupCase&gt; edges = CASE_EDGES.get(lc);
375                 if (edges != null)
376                     for (LookupCase prev : edges) {
377                         System.out.println(&quot;\t&quot;+prev);
378                     }
379             }
380             System.out.println(&quot;}&quot;);
381         }
382     }
383 
384     @Test public void test() {
385         makeCases(lookups());
386         if (verbosity &gt; 0) {
387             verbosity += 9;
388             Method pro_in_self = targetMethod(THIS_CLASS, PROTECTED, methodType(void.class));
<span class="line-modified">389             testOneAccess(lookupCase(&quot;AccessControlTest/public&quot;),  pro_in_self, &quot;find&quot;);</span>
<span class="line-modified">390             testOneAccess(lookupCase(&quot;Remote_subclass/public&quot;),    pro_in_self, &quot;find&quot;);</span>
391             testOneAccess(lookupCase(&quot;Remote_subclass&quot;),           pro_in_self, &quot;find&quot;);
392             verbosity -= 9;
393         }
394         Set&lt;Class&lt;?&gt;&gt; targetClassesDone = new HashSet&lt;&gt;();
395         for (LookupCase targetCase : CASES) {
396             Class&lt;?&gt; targetClass = targetCase.lookupClass();
397             if (!targetClassesDone.add(targetClass))  continue;  // already saw this one
398             String targetPlace = placeName(targetClass);
399             if (targetPlace == null)  continue;  // Object, String, not a target
400             for (int targetAccess : ACCESS_CASES) {


401                 MethodType methodType = methodType(void.class);
402                 Method method = targetMethod(targetClass, targetAccess, methodType);
403                 // Try to access target method from various contexts.
404                 for (LookupCase sourceCase : CASES) {
405                     testOneAccess(sourceCase, method, &quot;findClass&quot;);
406                     testOneAccess(sourceCase, method, &quot;accessClass&quot;);
407                     testOneAccess(sourceCase, method, &quot;find&quot;);
408                     testOneAccess(sourceCase, method, &quot;unreflect&quot;);
409                 }
410             }
411         }
412         System.out.println(&quot;tested &quot;+testCount+&quot; access scenarios; &quot;+testCountFails+&quot; accesses were denied&quot;);
413     }
414 
415     private int testCount, testCountFails;
416 
417     private void testOneAccess(LookupCase sourceCase, Method method, String kind) {
418         Class&lt;?&gt; targetClass = method.getDeclaringClass();
419         String methodName = method.getName();
420         MethodType methodType = methodType(method.getReturnType(), method.getParameterTypes());
</pre>
<hr />
<pre>
440             case &quot;unreflect&quot;:
441                 sourceCase.lookup().unreflect(method);
442                 break;
443             default:
444                 throw new AssertionError(kind);
445             }
446             didAccess = true;
447         } catch (ReflectiveOperationException ex) {
448             accessError = ex;
449         }
450         if (willAccess != didAccess) {
451             System.out.println(sourceCase+&quot; =&gt; &quot;+targetClass.getSimpleName()+(isFindOrAccessClass?&quot;&quot;:&quot;.&quot;+methodName+methodType));
452             System.out.println(&quot;fail &quot;+(isFindOrAccessClass?kind:&quot;on &quot;+method)+&quot; ex=&quot;+accessError);
453             assertEquals(willAccess, didAccess);
454         }
455         testCount++;
456         if (!didAccess)  testCountFails++;
457     }
458 
459     static Method targetMethod(Class&lt;?&gt; targetClass, int targetAccess, MethodType methodType) {
<span class="line-removed">460         assert targetAccess != MODULE;</span>
461         String methodName = accessName(targetAccess)+placeName(targetClass);
462         if (verbosity &gt;= 2)
463             System.out.println(targetClass.getSimpleName()+&quot;.&quot;+methodName+methodType);
464         try {
465             Method method = targetClass.getDeclaredMethod(methodName, methodType.parameterArray());
466             assertEquals(method.getReturnType(), methodType.returnType());
467             int haveMods = method.getModifiers();
468             assert(Modifier.isStatic(haveMods));
469             assert(targetAccess == fixMods(haveMods));
470             return method;
471         } catch (NoSuchMethodException ex) {
472             throw new AssertionError(methodName, ex);
473         }
474     }
475 
476     static String placeName(Class&lt;?&gt; cls) {
477         // return &quot;self&quot;, &quot;sibling&quot;, &quot;nestmate&quot;, etc.
478         if (cls == AccessControlTest.class)  return &quot;self&quot;;
479         String cln = cls.getSimpleName();
480         int under = cln.lastIndexOf(&#39;_&#39;);
481         if (under &lt; 0)  return null;
482         return cln.substring(under+1);
483     }
484     static String accessName(int acc) {
485         switch (acc) {
486         case PUBLIC:     return &quot;pub_in_&quot;;
487         case PROTECTED:  return &quot;pro_in_&quot;;
488         case PACKAGE:    return &quot;pkg_in_&quot;;
489         case PRIVATE:    return &quot;pri_in_&quot;;
490         }
491         assert(false);
492         return &quot;?&quot;;
493     }
<span class="line-removed">494     // MODULE not a test case at this time</span>
495     private static final int[] ACCESS_CASES = {
<span class="line-modified">496         PUBLIC, PACKAGE, PRIVATE, PROTECTED</span>
497     };




498     /** Return one of the ACCESS_CASES. */
499     static int fixMods(int mods) {
500         mods &amp;= (PUBLIC|PRIVATE|PROTECTED);
501         switch (mods) {
502         case PUBLIC: case PRIVATE: case PROTECTED: return mods;
503         case 0:  return PACKAGE;
504         }
505         throw new AssertionError(mods);
506     }
507 
508     static Lookup[] lookups() {
509         ArrayList&lt;Lookup&gt; tem = new ArrayList&lt;&gt;();
510         Collections.addAll(tem,
511                            AccessControlTest.lookup_in_self(),
512                            Inner_nestmate.lookup_in_nestmate(),
513                            AccessControlTest_sibling.lookup_in_sibling());
514         if (true) {
515             Collections.addAll(tem,Acquaintance_remote.lookups());
516         } else {
517             try {
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2012, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 /* @test
 25  * @summary test access checking by java.lang.invoke.MethodHandles.Lookup
 26  * @compile AccessControlTest.java AccessControlTest_subpkg/Acquaintance_remote.java
 27  * @run testng/othervm test.java.lang.invoke.AccessControlTest
 28  */
 29 
 30 package test.java.lang.invoke;
 31 
 32 import java.lang.invoke.*;
 33 import java.lang.reflect.*;
 34 import java.lang.reflect.Modifier;
 35 import java.util.*;

 36 import org.testng.annotations.*;
 37 
 38 import static java.lang.invoke.MethodHandles.*;
 39 import static java.lang.invoke.MethodHandles.Lookup.*;
 40 import static java.lang.invoke.MethodType.*;
 41 import static org.testng.Assert.*;
 42 
 43 import test.java.lang.invoke.AccessControlTest_subpkg.Acquaintance_remote;
 44 
 45 
 46 /**
 47  * Test many combinations of Lookup access and cross-class lookupStatic.
 48  * @author jrose
 49  */
 50 public class AccessControlTest {
 51     static final Class&lt;?&gt; THIS_CLASS = AccessControlTest.class;
 52     // How much output?
 53     static int verbosity = 0;
 54     static {
 55         String vstr = System.getProperty(THIS_CLASS.getSimpleName()+&quot;.verbosity&quot;);
 56         if (vstr == null)
 57             vstr = System.getProperty(THIS_CLASS.getName()+&quot;.verbosity&quot;);
 58         if (vstr != null)  verbosity = Integer.parseInt(vstr);
 59     }
 60 
 61     private class LookupCase implements Comparable&lt;LookupCase&gt; {
 62         final Lookup   lookup;
 63         final Class&lt;?&gt; lookupClass;
<span class="line-added"> 64         final Class&lt;?&gt; prevLookupClass;</span>
 65         final int      lookupModes;
 66         public LookupCase(Lookup lookup) {
 67             this.lookup = lookup;
 68             this.lookupClass = lookup.lookupClass();
<span class="line-added"> 69             this.prevLookupClass = lookup.previousLookupClass();</span>
 70             this.lookupModes = lookup.lookupModes();
<span class="line-added"> 71 </span>
 72             assert(lookupString().equals(lookup.toString()));
 73             numberOf(lookupClass().getClassLoader()); // assign CL#
 74         }
<span class="line-modified"> 75         public LookupCase(Class&lt;?&gt; lookupClass, Class&lt;?&gt; prevLookupClass, int lookupModes) {</span>
 76             this.lookup = null;
 77             this.lookupClass = lookupClass;
<span class="line-added"> 78             this.prevLookupClass = prevLookupClass;</span>
 79             this.lookupModes = lookupModes;
 80             numberOf(lookupClass().getClassLoader()); // assign CL#
 81         }
 82 
<span class="line-modified"> 83         public final Class&lt;?&gt; lookupClass()     { return lookupClass; }</span>
<span class="line-modified"> 84         public final Class&lt;?&gt; prevLookupClass() { return prevLookupClass; }</span>
<span class="line-added"> 85         public final int      lookupModes()     { return lookupModes; }</span>
 86 
 87         public Lookup lookup() { lookup.getClass(); return lookup; }
 88 
 89         @Override
 90         public int compareTo(LookupCase that) {
 91             Class&lt;?&gt; c1 = this.lookupClass();
 92             Class&lt;?&gt; c2 = that.lookupClass();
<span class="line-added"> 93             Class&lt;?&gt; p1 = this.prevLookupClass();</span>
<span class="line-added"> 94             Class&lt;?&gt; p2 = that.prevLookupClass();</span>
 95             if (c1 != c2) {
 96                 int cmp = c1.getName().compareTo(c2.getName());
 97                 if (cmp != 0)  return cmp;
 98                 cmp = numberOf(c1.getClassLoader()) - numberOf(c2.getClassLoader());
 99                 assert(cmp != 0);
100                 return cmp;
<span class="line-added">101             } else if (p1 != p2){</span>
<span class="line-added">102                 if (p1 == null)</span>
<span class="line-added">103                     return 1;</span>
<span class="line-added">104                 else if (p2 == null)</span>
<span class="line-added">105                     return -1;</span>
<span class="line-added">106                 int cmp = p1.getName().compareTo(p2.getName());</span>
<span class="line-added">107                 if (cmp != 0)  return cmp;</span>
<span class="line-added">108                 cmp = numberOf(p1.getClassLoader()) - numberOf(p2.getClassLoader());</span>
<span class="line-added">109                 assert(cmp != 0);</span>
<span class="line-added">110                 return cmp;</span>
111             }
112             return -(this.lookupModes() - that.lookupModes());
113         }
114 
115         @Override
116         public boolean equals(Object that) {
117             return (that instanceof LookupCase &amp;&amp; equals((LookupCase)that));
118         }
119         public boolean equals(LookupCase that) {
120             return (this.lookupClass() == that.lookupClass() &amp;&amp;
<span class="line-added">121                     this.prevLookupClass() == that.prevLookupClass() &amp;&amp;</span>
122                     this.lookupModes() == that.lookupModes());
123         }
124 
125         @Override
126         public int hashCode() {
127             return lookupClass().hashCode() + (lookupModes() * 31);
128         }
129 
130         /** Simulate all assertions in the spec. for Lookup.toString. */
131         private String lookupString() {
132             String name = lookupClass.getName();
<span class="line-added">133             if (prevLookupClass != null)</span>
<span class="line-added">134                 name += &quot;/&quot; + prevLookupClass.getName();</span>
135             String suffix = &quot;&quot;;
136             if (lookupModes == 0)
137                 suffix = &quot;/noaccess&quot;;
138             else if (lookupModes == PUBLIC)
139                 suffix = &quot;/public&quot;;
<span class="line-modified">140              else if (lookupModes == UNCONDITIONAL)</span>
141                 suffix = &quot;/publicLookup&quot;;
142             else if (lookupModes == (PUBLIC|MODULE))
143                 suffix = &quot;/module&quot;;
<span class="line-modified">144             else if (lookupModes == (PUBLIC|PACKAGE)</span>
<span class="line-added">145                      || lookupModes == (PUBLIC|MODULE|PACKAGE))</span>
146                 suffix = &quot;/package&quot;;
<span class="line-modified">147             else if (lookupModes == (PUBLIC|PACKAGE|PRIVATE)</span>
<span class="line-added">148                     || lookupModes == (PUBLIC|MODULE|PACKAGE|PRIVATE))</span>
149                 suffix = &quot;/private&quot;;
<span class="line-modified">150             else if (lookupModes == (PUBLIC|PACKAGE|PRIVATE|PROTECTED)</span>
<span class="line-added">151                      || lookupModes == (PUBLIC|MODULE|PACKAGE|PRIVATE|PROTECTED))</span>
152                 suffix = &quot;&quot;;
153             else
154                 suffix = &quot;/#&quot;+Integer.toHexString(lookupModes);
155             return name+suffix;
156         }
157 
158         /** Simulate all assertions from the spec. for Lookup.in:
159          * &lt;hr&gt;
160          * Creates a lookup on the specified new lookup class.
161          * [A1] The resulting object will report the specified
162          * class as its own {@link #lookupClass lookupClass}.

163          * [A2] However, the resulting {@code Lookup} object is guaranteed
164          * to have no more access capabilities than the original.
165          * In particular, access capabilities can be lost as follows:&lt;ul&gt;
<span class="line-modified">166          * [A3] If the new lookup class is in a different module from the old one,</span>
<span class="line-modified">167          * i.e. {@link #MODULE MODULE} access is lost.</span>
<span class="line-modified">168          * [A4] If the new lookup class is in a different package</span>
<span class="line-modified">169          * than the old one, protected and default (package) members will not be accessible,</span>
<span class="line-modified">170          * i.e. {@link #PROTECTED PROTECTED} and {@link #PACKAGE PACKAGE} access are lost.</span>
<span class="line-modified">171          * [A5] If the new lookup class is not within the same package member</span>
<span class="line-modified">172          * as the old one, private members will not be accessible, and protected members</span>
<span class="line-modified">173          * will not be accessible by virtue of inheritance,</span>
<span class="line-modified">174          * i.e. {@link #PRIVATE PRIVATE} access is lost.</span>

175          * (Protected members may continue to be accessible because of package sharing.)
<span class="line-modified">176          * [A6] If the new lookup class is not</span>
<span class="line-modified">177          * {@linkplain #accessClass(Class) accessible} to this lookup,</span>
<span class="line-modified">178          * then no members, not even public members, will be accessible</span>
<span class="line-modified">179          * i.e. all access modes are lost.</span>
<span class="line-modified">180          * [A7] If the new lookup class, the old lookup class and the previous lookup class</span>
<span class="line-modified">181          * are all in different modules i.e. teleporting to a third module,</span>
<span class="line-modified">182          * all access modes are lost.</span>
<span class="line-modified">183          * &lt;p&gt;</span>
<span class="line-added">184          * The new previous lookup class is chosen as follows:</span>
<span class="line-added">185          * [A8] If the new lookup object has {@link #UNCONDITIONAL UNCONDITIONAL} bit,</span>
<span class="line-added">186          * the new previous lookup class is {@code null}.</span>
<span class="line-added">187          * [A9] If the new lookup class is in the same module as the old lookup class,</span>
<span class="line-added">188          * the new previous lookup class is the old previous lookup class.</span>
<span class="line-added">189          * [A10] If the new lookup class is in a different module from the old lookup class,</span>
<span class="line-added">190          * the new previous lookup class is the the old lookup class.</span>
<span class="line-added">191          *</span>
192          * Other than the above cases, the new lookup will have the same
<span class="line-modified">193          * access capabilities as the original. [A11]</span>
194          * &lt;hr&gt;
195          */
196         public LookupCase in(Class&lt;?&gt; c2) {
197             Class&lt;?&gt; c1 = lookupClass();
<span class="line-modified">198             Module m1 = c1.getModule();</span>
<span class="line-added">199             Module m2 = c2.getModule();</span>
<span class="line-added">200             Module m0 = prevLookupClass() != null ? prevLookupClass.getModule() : c1.getModule();</span>
<span class="line-added">201             int modes1 = lookupModes();</span>
202             int changed = 0;
203             // for the purposes of access control then treat classes in different unnamed
204             // modules as being in the same module.
<span class="line-modified">205             boolean sameModule = (m1 == m2) ||</span>
<span class="line-modified">206                                  (!m1.isNamed() &amp;&amp; !m2.isNamed());</span>
207             boolean samePackage = (c1.getClassLoader() == c2.getClassLoader() &amp;&amp;
208                                    c1.getPackageName().equals(c2.getPackageName()));
209             boolean sameTopLevel = (topLevelClass(c1) == topLevelClass(c2));
210             boolean sameClass = (c1 == c2);
211             assert(samePackage  || !sameTopLevel);
212             assert(sameTopLevel || !sameClass);
213             boolean accessible = sameClass;
<span class="line-modified">214 </span>
<span class="line-modified">215             if ((modes1 &amp; PACKAGE) != 0)  accessible |= samePackage;</span>
<span class="line-modified">216             if ((modes1 &amp; PUBLIC ) != 0)  {</span>
<span class="line-modified">217                 if (isModuleAccessible(c2))</span>
<span class="line-modified">218                     accessible |= (c2.getModifiers() &amp; PUBLIC) != 0;</span>
<span class="line-modified">219                 else</span>
<span class="line-modified">220                     accessible = false;</span>
<span class="line-modified">221             }</span>
<span class="line-added">222             if ((modes1 &amp; UNCONDITIONAL) != 0) {</span>
<span class="line-added">223                 if (m2.isExported(c2.getPackageName()))</span>
<span class="line-added">224                     accessible |= (c2.getModifiers() &amp; PUBLIC) != 0;</span>
<span class="line-added">225                 else</span>
<span class="line-added">226                     accessible = false;</span>
227             }
228             if (!accessible) {
<span class="line-modified">229                 // no access to c2; lose all access.</span>
<span class="line-modified">230                 changed |= (PUBLIC|MODULE|PACKAGE|PRIVATE|PROTECTED|UNCONDITIONAL);  // [A6]</span>
<span class="line-added">231             }</span>
<span class="line-added">232             if (m2 != m1 &amp;&amp; m0 != m1) {</span>
<span class="line-added">233                 // hop to a third module; lose all access</span>
<span class="line-added">234                 changed |= (PUBLIC|MODULE|PACKAGE|PRIVATE|PROTECTED);  // [A7]</span>
<span class="line-added">235             }</span>
<span class="line-added">236             if (!sameModule) {</span>
<span class="line-added">237                 changed |= MODULE;  // [A3]</span>
238             }
239             if (!samePackage) {
240                 // Different package; loose PACKAGE and lower access.
<span class="line-modified">241                 changed |= (PACKAGE|PRIVATE|PROTECTED);  // [A4]</span>
242             }
243             if (!sameTopLevel) {
244                 // Different top-level class.  Lose PRIVATE and PROTECTED access.
<span class="line-modified">245                 changed |= (PRIVATE|PROTECTED);  // [A5]</span>
246             }
<span class="line-modified">247             if (sameClass) {</span>
<span class="line-modified">248                 assert(changed == 0);       // [A11] (no deprivation if same class)</span>


249             }
<span class="line-modified">250 </span>
<span class="line-modified">251             if (accessible)  assert((changed &amp; PUBLIC) == 0);</span>
<span class="line-modified">252             int modes2 = modes1 &amp; ~changed;</span>
<span class="line-modified">253             Class&lt;?&gt; plc = (m1 == m2) ? prevLookupClass() : c1; // [A9] [A10]</span>
<span class="line-modified">254             if ((modes1 &amp; UNCONDITIONAL) != 0) plc = null;      // [A8]</span>
<span class="line-added">255             LookupCase l2 = new LookupCase(c2, plc, modes2);</span>
<span class="line-added">256             assert(l2.lookupClass() == c2);         // [A1]</span>
<span class="line-added">257             assert((modes1 | modes2) == modes1);    // [A2] (no elevation of access)</span>
<span class="line-added">258             assert(l2.prevLookupClass() == null || (modes2 &amp; MODULE) == 0);</span>
<span class="line-added">259             return l2;</span>
<span class="line-added">260         }</span>
<span class="line-added">261 </span>
<span class="line-added">262         LookupCase dropLookupMode(int modeToDrop) {</span>
<span class="line-added">263             int oldModes = lookupModes();</span>
<span class="line-added">264             int newModes = oldModes &amp; ~(modeToDrop | PROTECTED);</span>
<span class="line-added">265             switch (modeToDrop) {</span>
<span class="line-added">266                 case PUBLIC: newModes &amp;= ~(MODULE|PACKAGE|PROTECTED|PRIVATE); break;</span>
<span class="line-added">267                 case MODULE: newModes &amp;= ~(PACKAGE|PRIVATE); break;</span>
<span class="line-added">268                 case PACKAGE: newModes &amp;= ~(PRIVATE); break;</span>
<span class="line-added">269                 case PROTECTED:</span>
<span class="line-added">270                 case PRIVATE:</span>
<span class="line-added">271                 case UNCONDITIONAL: break;</span>
<span class="line-added">272                 default: throw new IllegalArgumentException(modeToDrop + &quot; is not a valid mode to drop&quot;);</span>
<span class="line-added">273             }</span>
<span class="line-added">274             if (newModes == oldModes) return this;  // return self if no change</span>
<span class="line-added">275             LookupCase l2 = new LookupCase(lookupClass(), prevLookupClass(), newModes);</span>
<span class="line-added">276             assert((oldModes | newModes) == oldModes);    // [A2] (no elevation of access)</span>
<span class="line-added">277             assert(l2.prevLookupClass() == null || (newModes &amp; MODULE) == 0);</span>
278             return l2;
279         }
280 
<span class="line-added">281         boolean isModuleAccessible(Class&lt;?&gt; c) {</span>
<span class="line-added">282             Module m1 = lookupClass().getModule();</span>
<span class="line-added">283             Module m2 = c.getModule();</span>
<span class="line-added">284             Module m0 = prevLookupClass() != null ? prevLookupClass.getModule() : m1;</span>
<span class="line-added">285             String pn = c.getPackageName();</span>
<span class="line-added">286             boolean accessible = m1.canRead(m2) &amp;&amp; m2.isExported(pn, m1);</span>
<span class="line-added">287             if (m1 != m0) {</span>
<span class="line-added">288                 accessible = accessible &amp;&amp; m0.canRead(m2) &amp;&amp; m2.isExported(pn, m0);</span>
<span class="line-added">289             }</span>
<span class="line-added">290             return accessible;</span>
<span class="line-added">291         }</span>
<span class="line-added">292 </span>
293         @Override
294         public String toString() {
295             String s = lookupClass().getSimpleName();
296             String lstr = lookupString();
297             int sl = lstr.indexOf(&#39;/&#39;);
298             if (sl &gt;= 0)  s += lstr.substring(sl);
299             ClassLoader cld = lookupClass().getClassLoader();
300             if (cld != THIS_LOADER)  s += &quot;/loader#&quot;+numberOf(cld);
301             return s;
302         }
303 
304         /** Predict the success or failure of accessing this method. */
305         public boolean willAccess(Method m) {
306             Class&lt;?&gt; c1 = lookupClass();
307             Class&lt;?&gt; c2 = m.getDeclaringClass();
<span class="line-added">308             Module m1 = c1.getModule();</span>
<span class="line-added">309             Module m2 = c2.getModule();</span>
<span class="line-added">310             Module m0 = prevLookupClass != null ? prevLookupClass.getModule() : m1;</span>
<span class="line-added">311             // unconditional has access to all public types/members of types that is in a package</span>
<span class="line-added">312             // are unconditionally exported</span>
<span class="line-added">313             if ((lookupModes &amp; UNCONDITIONAL) != 0) {</span>
<span class="line-added">314                 return m2.isExported(c2.getPackageName())</span>
<span class="line-added">315                        &amp;&amp; Modifier.isPublic(c2.getModifiers())</span>
<span class="line-added">316                        &amp;&amp; Modifier.isPublic(m.getModifiers());</span>
<span class="line-added">317             }</span>
318 
<span class="line-modified">319             // c1 and c2 are in different module</span>
<span class="line-modified">320             if (m1 != m2 || m0 != m2) {</span>
<span class="line-modified">321                 return (lookupModes &amp; PUBLIC) != 0</span>
<span class="line-modified">322                        &amp;&amp; isModuleAccessible(c2)</span>
<span class="line-modified">323                        &amp;&amp; Modifier.isPublic(c2.getModifiers())</span>
<span class="line-modified">324                        &amp;&amp; Modifier.isPublic(m.getModifiers());</span>
<span class="line-modified">325             }</span>
<span class="line-added">326 </span>
<span class="line-added">327             assert(m1 == m2 &amp;&amp; prevLookupClass == null);</span>
<span class="line-added">328 </span>
<span class="line-added">329             if (!willAccessClass(c2, false))</span>
<span class="line-added">330                 return false;</span>
331 
332             LookupCase lc = this.in(c2);
<span class="line-modified">333             int modes1 = lc.lookupModes();</span>
<span class="line-modified">334             int modes2 = fixMods(m.getModifiers());</span>
335             // allow private lookup on nestmates. Otherwise, privacy is strictly enforced
<span class="line-modified">336             if (c1 != c2 &amp;&amp; ((modes2 &amp; PRIVATE) == 0 || !c1.isNestmateOf(c2))) {</span>
<span class="line-modified">337                 modes1 &amp;= ~PRIVATE;</span>
338             }
339             // protected access is sometimes allowed
<span class="line-modified">340             if ((modes2 &amp; PROTECTED) != 0) {</span>
<span class="line-modified">341                 int prev = modes2;</span>
<span class="line-modified">342                 modes2 |= PACKAGE;  // it acts like a package method also</span>
343                 if ((lookupModes() &amp; PROTECTED) != 0 &amp;&amp;
344                     c2.isAssignableFrom(c1))
<span class="line-modified">345                     modes2 |= PUBLIC;  // from a subclass, it acts like a public method also</span>
346             }
347             if (verbosity &gt;= 2)
<span class="line-modified">348                 System.out.format(&quot;%s willAccess %s modes1=0x%h modes2=0x%h =&gt; %s%n&quot;, lookupString(), lc.lookupString(), modes1, modes2, (modes2 &amp; modes1) != 0);</span>
<span class="line-modified">349             return (modes2 &amp; modes1) != 0;</span>
350         }
351 
352         /** Predict the success or failure of accessing this class. */
353         public boolean willAccessClass(Class&lt;?&gt; c2, boolean load) {
354             Class&lt;?&gt; c1 = lookupClass();
355             if (load &amp;&amp; c2.getClassLoader() != null) {
356                 if (c1.getClassLoader() == null) {
357                     // not visible
358                     return false;
359                 }
360             }
361 
<span class="line-modified">362             Module m1 = c1.getModule();</span>
<span class="line-modified">363             Module m2 = c2.getModule();</span>
<span class="line-modified">364             Module m0 = prevLookupClass != null ? prevLookupClass.getModule() : m1;</span>
<span class="line-modified">365             // unconditional has access to all public types that is in an unconditionally exported package</span>
<span class="line-modified">366             if ((lookupModes &amp; UNCONDITIONAL) != 0) {</span>
<span class="line-modified">367                 return m2.isExported(c2.getPackageName()) &amp;&amp; Modifier.isPublic(c2.getModifiers());</span>
<span class="line-added">368             }</span>
<span class="line-added">369             // c1 and c2 are in different module</span>
<span class="line-added">370             if (m1 != m2 || m0 != m2) {</span>
<span class="line-added">371                 return (lookupModes &amp; PUBLIC) != 0</span>
<span class="line-added">372                     &amp;&amp; isModuleAccessible(c2)</span>
<span class="line-added">373                     &amp;&amp; Modifier.isPublic(c2.getModifiers());</span>
<span class="line-added">374             }</span>
<span class="line-added">375 </span>
<span class="line-added">376             assert(m1 == m2 &amp;&amp; prevLookupClass == null);</span>
377 
378             LookupCase lc = this.in(c2);
<span class="line-modified">379             int modes1 = lc.lookupModes();</span>
380             boolean r = false;
<span class="line-modified">381             if (modes1 == 0) {</span>
382                 r = false;
383             } else {
<span class="line-modified">384                 if (Modifier.isPublic(c2.getModifiers())) {</span>
<span class="line-modified">385                     if ((modes1 &amp; MODULE) != 0)</span>
<span class="line-modified">386                         r = true;</span>
<span class="line-modified">387                     else if ((modes1 &amp; PUBLIC) != 0)</span>
<span class="line-modified">388                         r = m1.isExported(c2.getPackageName());</span>
<span class="line-added">389                 } else {</span>
<span class="line-added">390                     if ((modes1 &amp; PACKAGE) != 0 &amp;&amp; c1.getPackage() == c2.getPackage())</span>
<span class="line-added">391                         r = true;</span>
392                 }
393             }
394             if (verbosity &gt;= 2) {
395                 System.out.println(this+&quot; willAccessClass &quot;+lc+&quot; c1=&quot;+c1+&quot; c2=&quot;+c2+&quot; =&gt; &quot;+r);
396             }
397             return r;
398         }
399     }
400 
401     private static Class&lt;?&gt; topLevelClass(Class&lt;?&gt; cls) {
402         Class&lt;?&gt; c = cls;
403         for (Class&lt;?&gt; ec; (ec = c.getEnclosingClass()) != null; )
404             c = ec;
405         assert(c.getEnclosingClass() == null);
406         assert(c == cls || cls.getEnclosingClass() != null);
407         return c;
408     }
409 
410     private final TreeSet&lt;LookupCase&gt; CASES = new TreeSet&lt;&gt;();
411     private final TreeMap&lt;LookupCase,TreeSet&lt;LookupCase&gt;&gt; CASE_EDGES = new TreeMap&lt;&gt;();
</pre>
<hr />
<pre>
414     { if (THIS_LOADER != null)  LOADERS.add(THIS_LOADER); }  // #1
415 
416     private LookupCase lookupCase(String name) {
417         for (LookupCase lc : CASES) {
418             if (lc.toString().equals(name))
419                 return lc;
420         }
421         throw new AssertionError(name);
422     }
423 
424     private int numberOf(ClassLoader cl) {
425         if (cl == null)  return 0;
426         int i = LOADERS.indexOf(cl);
427         if (i &lt; 0) {
428             i = LOADERS.size();
429             LOADERS.add(cl);
430         }
431         return i+1;
432     }
433 
<span class="line-modified">434     private void addLookupEdge(LookupCase l1, Class&lt;?&gt; c2, LookupCase l2, int dropAccess) {</span>
435         TreeSet&lt;LookupCase&gt; edges = CASE_EDGES.get(l2);
436         if (edges == null)  CASE_EDGES.put(l2, edges = new TreeSet&lt;&gt;());
437         if (edges.add(l1)) {
438             Class&lt;?&gt; c1 = l1.lookupClass();
439             assert(l2.lookupClass() == c2); // [A1]
440             int m1 = l1.lookupModes();
441             int m2 = l2.lookupModes();
442             assert((m1 | m2) == m1);        // [A2] (no elevation of access)
<span class="line-modified">443             LookupCase expect = dropAccess == 0 ? l1.in(c2) : l1.in(c2).dropLookupMode(dropAccess);</span>
444             if (!expect.equals(l2))
445                 System.out.println(&quot;*** expect &quot;+l1+&quot; =&gt; &quot;+expect+&quot; but got &quot;+l2);
446             assertEquals(l2, expect);
447         }
448     }
449 
450     private void makeCases(Lookup[] originalLookups) {
451         // make initial set of lookup test cases
452         CASES.clear(); LOADERS.clear(); CASE_EDGES.clear();
453         ArrayList&lt;Class&lt;?&gt;&gt; classes = new ArrayList&lt;&gt;();
454         for (Lookup l : originalLookups) {
455             CASES.add(new LookupCase(l));
456             classes.remove(l.lookupClass());  // no dups please
457             classes.add(l.lookupClass());
458         }
459         System.out.println(&quot;loaders = &quot;+LOADERS);
460         int rounds = 0;
461         for (int lastCount = -1; lastCount != CASES.size(); ) {
462             lastCount = CASES.size();  // if CASES grow in the loop we go round again
463             for (LookupCase lc1 : CASES.toArray(new LookupCase[0])) {
<span class="line-added">464                 for (int mode : ACCESS_CASES) {</span>
<span class="line-added">465                     LookupCase lc2 = new LookupCase(lc1.lookup().dropLookupMode(mode));</span>
<span class="line-added">466                     addLookupEdge(lc1, lc1.lookupClass(), lc2, mode);</span>
<span class="line-added">467                     CASES.add(lc2);</span>
<span class="line-added">468                 }</span>
469                 for (Class&lt;?&gt; c2 : classes) {
470                     LookupCase lc2 = new LookupCase(lc1.lookup().in(c2));
<span class="line-modified">471                     addLookupEdge(lc1, c2, lc2, 0);</span>
472                     CASES.add(lc2);
473                 }
474             }
475             rounds++;
476         }
477         System.out.println(&quot;filled in &quot;+CASES.size()+&quot; cases from &quot;+originalLookups.length+&quot; original cases in &quot;+rounds+&quot; rounds&quot;);
478         if (false) {
479             System.out.println(&quot;CASES: {&quot;);
480             for (LookupCase lc : CASES) {
481                 System.out.println(lc);
482                 Set&lt;LookupCase&gt; edges = CASE_EDGES.get(lc);
483                 if (edges != null)
484                     for (LookupCase prev : edges) {
485                         System.out.println(&quot;\t&quot;+prev);
486                     }
487             }
488             System.out.println(&quot;}&quot;);
489         }
490     }
491 
492     @Test public void test() {
493         makeCases(lookups());
494         if (verbosity &gt; 0) {
495             verbosity += 9;
496             Method pro_in_self = targetMethod(THIS_CLASS, PROTECTED, methodType(void.class));
<span class="line-modified">497             testOneAccess(lookupCase(&quot;AccessControlTest/module&quot;),  pro_in_self, &quot;find&quot;);</span>
<span class="line-modified">498             testOneAccess(lookupCase(&quot;Remote_subclass/module&quot;),    pro_in_self, &quot;find&quot;);</span>
499             testOneAccess(lookupCase(&quot;Remote_subclass&quot;),           pro_in_self, &quot;find&quot;);
500             verbosity -= 9;
501         }
502         Set&lt;Class&lt;?&gt;&gt; targetClassesDone = new HashSet&lt;&gt;();
503         for (LookupCase targetCase : CASES) {
504             Class&lt;?&gt; targetClass = targetCase.lookupClass();
505             if (!targetClassesDone.add(targetClass))  continue;  // already saw this one
506             String targetPlace = placeName(targetClass);
507             if (targetPlace == null)  continue;  // Object, String, not a target
508             for (int targetAccess : ACCESS_CASES) {
<span class="line-added">509                 if (targetAccess == MODULE || targetAccess == UNCONDITIONAL)</span>
<span class="line-added">510                     continue;</span>
511                 MethodType methodType = methodType(void.class);
512                 Method method = targetMethod(targetClass, targetAccess, methodType);
513                 // Try to access target method from various contexts.
514                 for (LookupCase sourceCase : CASES) {
515                     testOneAccess(sourceCase, method, &quot;findClass&quot;);
516                     testOneAccess(sourceCase, method, &quot;accessClass&quot;);
517                     testOneAccess(sourceCase, method, &quot;find&quot;);
518                     testOneAccess(sourceCase, method, &quot;unreflect&quot;);
519                 }
520             }
521         }
522         System.out.println(&quot;tested &quot;+testCount+&quot; access scenarios; &quot;+testCountFails+&quot; accesses were denied&quot;);
523     }
524 
525     private int testCount, testCountFails;
526 
527     private void testOneAccess(LookupCase sourceCase, Method method, String kind) {
528         Class&lt;?&gt; targetClass = method.getDeclaringClass();
529         String methodName = method.getName();
530         MethodType methodType = methodType(method.getReturnType(), method.getParameterTypes());
</pre>
<hr />
<pre>
550             case &quot;unreflect&quot;:
551                 sourceCase.lookup().unreflect(method);
552                 break;
553             default:
554                 throw new AssertionError(kind);
555             }
556             didAccess = true;
557         } catch (ReflectiveOperationException ex) {
558             accessError = ex;
559         }
560         if (willAccess != didAccess) {
561             System.out.println(sourceCase+&quot; =&gt; &quot;+targetClass.getSimpleName()+(isFindOrAccessClass?&quot;&quot;:&quot;.&quot;+methodName+methodType));
562             System.out.println(&quot;fail &quot;+(isFindOrAccessClass?kind:&quot;on &quot;+method)+&quot; ex=&quot;+accessError);
563             assertEquals(willAccess, didAccess);
564         }
565         testCount++;
566         if (!didAccess)  testCountFails++;
567     }
568 
569     static Method targetMethod(Class&lt;?&gt; targetClass, int targetAccess, MethodType methodType) {

570         String methodName = accessName(targetAccess)+placeName(targetClass);
571         if (verbosity &gt;= 2)
572             System.out.println(targetClass.getSimpleName()+&quot;.&quot;+methodName+methodType);
573         try {
574             Method method = targetClass.getDeclaredMethod(methodName, methodType.parameterArray());
575             assertEquals(method.getReturnType(), methodType.returnType());
576             int haveMods = method.getModifiers();
577             assert(Modifier.isStatic(haveMods));
578             assert(targetAccess == fixMods(haveMods));
579             return method;
580         } catch (NoSuchMethodException ex) {
581             throw new AssertionError(methodName, ex);
582         }
583     }
584 
585     static String placeName(Class&lt;?&gt; cls) {
586         // return &quot;self&quot;, &quot;sibling&quot;, &quot;nestmate&quot;, etc.
587         if (cls == AccessControlTest.class)  return &quot;self&quot;;
588         String cln = cls.getSimpleName();
589         int under = cln.lastIndexOf(&#39;_&#39;);
590         if (under &lt; 0)  return null;
591         return cln.substring(under+1);
592     }
593     static String accessName(int acc) {
594         switch (acc) {
595         case PUBLIC:     return &quot;pub_in_&quot;;
596         case PROTECTED:  return &quot;pro_in_&quot;;
597         case PACKAGE:    return &quot;pkg_in_&quot;;
598         case PRIVATE:    return &quot;pri_in_&quot;;
599         }
600         assert(false);
601         return &quot;?&quot;;
602     }

603     private static final int[] ACCESS_CASES = {
<span class="line-modified">604         PUBLIC, PACKAGE, PRIVATE, PROTECTED, MODULE, UNCONDITIONAL</span>
605     };
<span class="line-added">606     /*</span>
<span class="line-added">607      * Adjust PUBLIC =&gt; PUBLIC|MODULE|UNCONDITIONAL</span>
<span class="line-added">608      * Adjust 0 =&gt; PACKAGE</span>
<span class="line-added">609      */</span>
610     /** Return one of the ACCESS_CASES. */
611     static int fixMods(int mods) {
612         mods &amp;= (PUBLIC|PRIVATE|PROTECTED);
613         switch (mods) {
614         case PUBLIC: case PRIVATE: case PROTECTED: return mods;
615         case 0:  return PACKAGE;
616         }
617         throw new AssertionError(mods);
618     }
619 
620     static Lookup[] lookups() {
621         ArrayList&lt;Lookup&gt; tem = new ArrayList&lt;&gt;();
622         Collections.addAll(tem,
623                            AccessControlTest.lookup_in_self(),
624                            Inner_nestmate.lookup_in_nestmate(),
625                            AccessControlTest_sibling.lookup_in_sibling());
626         if (true) {
627             Collections.addAll(tem,Acquaintance_remote.lookups());
628         } else {
629             try {
</pre>
</td>
</tr>
</table>
<center><a href="../instrument/RedefineNestmateAttr/TestNestmateAttr.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="CallSiteTest.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
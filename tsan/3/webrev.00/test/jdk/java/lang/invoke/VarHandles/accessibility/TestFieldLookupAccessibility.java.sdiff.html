<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff test/jdk/java/lang/invoke/VarHandles/accessibility/TestFieldLookupAccessibility.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
<body>
<center><a href="../../TryFinallyTest.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="../../modules/Unnamed.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>test/jdk/java/lang/invoke/VarHandles/accessibility/TestFieldLookupAccessibility.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 /* @test
<span class="line-modified"> 25  * @bug 8152645</span>
 26  * @summary test field lookup accessibility of MethodHandles and VarHandles
 27  * @compile TestFieldLookupAccessibility.java
 28  *          pkg/A.java pkg/B_extends_A.java pkg/C.java
 29  *          pkg/subpkg/B_extends_A.java pkg/subpkg/C.java
 30  * @run testng/othervm TestFieldLookupAccessibility
 31  */
 32 
 33 import org.testng.Assert;
 34 import org.testng.annotations.DataProvider;
 35 import org.testng.annotations.Test;
 36 import pkg.B_extends_A;
 37 
 38 import java.lang.invoke.MethodHandles;
 39 import java.lang.reflect.Field;
 40 import java.lang.reflect.Modifier;
 41 import java.util.ArrayList;
 42 import java.util.HashMap;
 43 import java.util.HashSet;
 44 import java.util.List;
 45 import java.util.Map;
</pre>
<hr />
<pre>
 79             }
 80         },
 81         MH_STATIC_SETTER() {
 82             Object lookup(MethodHandles.Lookup l, Field f) throws Exception {
 83                 return l.findStaticSetter(f.getDeclaringClass(), f.getName(), f.getType());
 84             }
 85 
 86             boolean isAccessible(Field f) {
 87                 return Modifier.isStatic(f.getModifiers()) &amp;&amp; !Modifier.isFinal(f.getModifiers());
 88             }
 89         },
 90         MH_UNREFLECT_GETTER() {
 91             Object lookup(MethodHandles.Lookup l, Field f) throws Exception {
 92                 return l.unreflectGetter(f);
 93             }
 94         },
 95         MH_UNREFLECT_GETTER_ACCESSIBLE() {
 96             Object lookup(MethodHandles.Lookup l, Field f) throws Exception {
 97                 return l.unreflectGetter(cloneAndSetAccessible(f));
 98             }






 99         },
100         MH_UNREFLECT_SETTER() {
101             Object lookup(MethodHandles.Lookup l, Field f) throws Exception {
102                 return l.unreflectSetter(f);
103             }
104 
105             boolean isAccessible(Field f) {
<span class="line-modified">106                 return f.isAccessible() || !Modifier.isFinal(f.getModifiers());</span>
107             }
108         },
109         MH_UNREFLECT_SETTER_ACCESSIBLE() {
110             Object lookup(MethodHandles.Lookup l, Field f) throws Exception {
111                 return l.unreflectSetter(cloneAndSetAccessible(f));
112             }














113         },
114         VH() {
115             Object lookup(MethodHandles.Lookup l, Field f) throws Exception {
116                 return l.findVarHandle(f.getDeclaringClass(), f.getName(), f.getType());
117             }
118 
119             boolean isAccessible(Field f) {
120                 return !Modifier.isStatic(f.getModifiers());
121             }
122         },
123         VH_STATIC() {
124             Object lookup(MethodHandles.Lookup l, Field f) throws Exception {
125                 return l.findStaticVarHandle(f.getDeclaringClass(), f.getName(), f.getType());
126             }
127 
128             boolean isAccessible(Field f) {
129                 return Modifier.isStatic(f.getModifiers());
130             }
131         },
132         VH_UNREFLECT() {
133             Object lookup(MethodHandles.Lookup l, Field f) throws Exception {
134                 return l.unreflectVarHandle(f);
135             }
136         };
137 
138         // Look up a handle to a field
139         abstract Object lookup(MethodHandles.Lookup l, Field f) throws Exception;
140 
141         boolean isAccessible(Field f) {
142             return true;
143         }
144 




145         static Field cloneAndSetAccessible(Field f) throws Exception {
146             // Clone to avoid mutating source field
147             f = f.getDeclaringClass().getDeclaredField(f.getName());
148             f.setAccessible(true);
149             return f;
150         }
151     }
152 
153     @DataProvider
154     public Object[][] lookupProvider() throws Exception {
155         Stream&lt;List&lt;Object&gt;&gt; baseCases = Stream.of(
156                 // Look up from same package
157                 List.of(pkg.A.class, pkg.A.lookup(), pkg.A.inaccessibleFields()),
158                 List.of(pkg.A.class, pkg.A.lookup(), pkg.A.inaccessibleFields()),
159                 List.of(pkg.A.class, B_extends_A.lookup(), B_extends_A.inaccessibleFields()),
160                 List.of(pkg.A.class, pkg.C.lookup(), pkg.C.inaccessibleFields()),
161 
162                 // Look up from sub-package
163                 List.of(pkg.A.class, pkg.subpkg.B_extends_A.lookup(), pkg.subpkg.B_extends_A.inaccessibleFields()),
164                 List.of(pkg.A.class, pkg.subpkg.C.lookup(), pkg.subpkg.C.inaccessibleFields())
165         );
166 
167         // Cross product base cases with the field lookup classes
168         return baseCases.
169                 flatMap(l -&gt; Stream.of(FieldLookup.values()).map(fl -&gt; prepend(fl, l))).
170                 toArray(Object[][]::new);
171     }
172 
173     private static Object[] prepend(Object o, List&lt;Object&gt; l) {
174         List&lt;Object&gt; pl = new ArrayList&lt;&gt;();
175         pl.add(o);
176         pl.addAll(l);
177         return pl.toArray();
178     }
179 
180     @Test(dataProvider = &quot;lookupProvider&quot;)
181     public void test(FieldLookup fl, Class&lt;?&gt; src, MethodHandles.Lookup l, Set&lt;String&gt; inaccessibleFields) {
182         // Add to the expected failures all inaccessible fields due to accessibility modifiers
<span class="line-modified">183         Set&lt;String&gt; expected = new HashSet&lt;&gt;(inaccessibleFields);</span>
184         Map&lt;Field, Throwable&gt; actual = new HashMap&lt;&gt;();
185 
186         for (Field f : fields(src)) {
187             // Add to the expected failures all inaccessible fields due to static/final modifiers
188             if (!fl.isAccessible(f)) {
189                 expected.add(f.getName());
190             }
191 
192             try {
193                 fl.lookup(l, f);
194             }
195             catch (Throwable t) {
196                 // Lookup failed, add to the actual failures
197                 actual.put(f, t);
198             }
199         }
200 
201         Set&lt;String&gt; actualFieldNames = actual.keySet().stream().map(Field::getName).
202                 collect(Collectors.toSet());
203         if (!actualFieldNames.equals(expected)) {
204             if (actualFieldNames.isEmpty()) {
<span class="line-modified">205                 // Setting the accessibility bit of a Field grants access under</span>
<span class="line-removed">206                 // all conditions for MethodHander getters and setters</span>
<span class="line-removed">207                 if (fl != FieldLookup.MH_UNREFLECT_GETTER_ACCESSIBLE &amp;&amp;</span>
<span class="line-removed">208                     fl != FieldLookup.MH_UNREFLECT_SETTER_ACCESSIBLE) {</span>
<span class="line-removed">209                     Assert.assertEquals(actualFieldNames, expected, &quot;No accessibility failures:&quot;);</span>
<span class="line-removed">210                 }</span>
211             }
212             else {
213                 Assert.assertEquals(actualFieldNames, expected, &quot;Accessibility failures differ:&quot;);
214             }
215         }
216         else {
217             if (!actual.values().stream().allMatch(IllegalAccessException.class::isInstance)) {
218                 Assert.fail(&quot;Expecting an IllegalArgumentException for all failures &quot; + actual);
219             }
220         }
221     }
222 
223     static List&lt;Field&gt; fields(Class&lt;?&gt; src) {
224         return List.of(src.getDeclaredFields());
225     }
226 }
</pre>
</td>
<td>
<hr />
<pre>
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 /* @test
<span class="line-modified"> 25  * @bug 8152645 8216558</span>
 26  * @summary test field lookup accessibility of MethodHandles and VarHandles
 27  * @compile TestFieldLookupAccessibility.java
 28  *          pkg/A.java pkg/B_extends_A.java pkg/C.java
 29  *          pkg/subpkg/B_extends_A.java pkg/subpkg/C.java
 30  * @run testng/othervm TestFieldLookupAccessibility
 31  */
 32 
 33 import org.testng.Assert;
 34 import org.testng.annotations.DataProvider;
 35 import org.testng.annotations.Test;
 36 import pkg.B_extends_A;
 37 
 38 import java.lang.invoke.MethodHandles;
 39 import java.lang.reflect.Field;
 40 import java.lang.reflect.Modifier;
 41 import java.util.ArrayList;
 42 import java.util.HashMap;
 43 import java.util.HashSet;
 44 import java.util.List;
 45 import java.util.Map;
</pre>
<hr />
<pre>
 79             }
 80         },
 81         MH_STATIC_SETTER() {
 82             Object lookup(MethodHandles.Lookup l, Field f) throws Exception {
 83                 return l.findStaticSetter(f.getDeclaringClass(), f.getName(), f.getType());
 84             }
 85 
 86             boolean isAccessible(Field f) {
 87                 return Modifier.isStatic(f.getModifiers()) &amp;&amp; !Modifier.isFinal(f.getModifiers());
 88             }
 89         },
 90         MH_UNREFLECT_GETTER() {
 91             Object lookup(MethodHandles.Lookup l, Field f) throws Exception {
 92                 return l.unreflectGetter(f);
 93             }
 94         },
 95         MH_UNREFLECT_GETTER_ACCESSIBLE() {
 96             Object lookup(MethodHandles.Lookup l, Field f) throws Exception {
 97                 return l.unreflectGetter(cloneAndSetAccessible(f));
 98             }
<span class="line-added"> 99 </span>
<span class="line-added">100             // Setting the accessibility bit of a Field grants access under</span>
<span class="line-added">101             // all conditions for MethodHandle getters.</span>
<span class="line-added">102             Set&lt;String&gt; inaccessibleFields(Set&lt;String&gt; inaccessibleFields) {</span>
<span class="line-added">103                 return new HashSet&lt;&gt;();</span>
<span class="line-added">104             }</span>
105         },
106         MH_UNREFLECT_SETTER() {
107             Object lookup(MethodHandles.Lookup l, Field f) throws Exception {
108                 return l.unreflectSetter(f);
109             }
110 
111             boolean isAccessible(Field f) {
<span class="line-modified">112                 return f.isAccessible() &amp;&amp; !Modifier.isStatic(f.getModifiers()) || !Modifier.isFinal(f.getModifiers());</span>
113             }
114         },
115         MH_UNREFLECT_SETTER_ACCESSIBLE() {
116             Object lookup(MethodHandles.Lookup l, Field f) throws Exception {
117                 return l.unreflectSetter(cloneAndSetAccessible(f));
118             }
<span class="line-added">119 </span>
<span class="line-added">120             boolean isAccessible(Field f) {</span>
<span class="line-added">121                 return !(Modifier.isStatic(f.getModifiers()) &amp;&amp; Modifier.isFinal(f.getModifiers()));</span>
<span class="line-added">122             }</span>
<span class="line-added">123 </span>
<span class="line-added">124             // Setting the accessibility bit of a Field grants access to non-static</span>
<span class="line-added">125             // final fields for MethodHandle setters.</span>
<span class="line-added">126             Set&lt;String&gt; inaccessibleFields(Set&lt;String&gt;inaccessibleFields) {</span>
<span class="line-added">127                 Set&lt;String&gt; result = new HashSet&lt;&gt;();</span>
<span class="line-added">128                 inaccessibleFields.stream()</span>
<span class="line-added">129                                   .filter(f -&gt; (f.contains(&quot;static&quot;) &amp;&amp; f.contains(&quot;final&quot;)))</span>
<span class="line-added">130                                   .forEach(result::add);</span>
<span class="line-added">131                 return result;</span>
<span class="line-added">132             }</span>
133         },
134         VH() {
135             Object lookup(MethodHandles.Lookup l, Field f) throws Exception {
136                 return l.findVarHandle(f.getDeclaringClass(), f.getName(), f.getType());
137             }
138 
139             boolean isAccessible(Field f) {
140                 return !Modifier.isStatic(f.getModifiers());
141             }
142         },
143         VH_STATIC() {
144             Object lookup(MethodHandles.Lookup l, Field f) throws Exception {
145                 return l.findStaticVarHandle(f.getDeclaringClass(), f.getName(), f.getType());
146             }
147 
148             boolean isAccessible(Field f) {
149                 return Modifier.isStatic(f.getModifiers());
150             }
151         },
152         VH_UNREFLECT() {
153             Object lookup(MethodHandles.Lookup l, Field f) throws Exception {
154                 return l.unreflectVarHandle(f);
155             }
156         };
157 
158         // Look up a handle to a field
159         abstract Object lookup(MethodHandles.Lookup l, Field f) throws Exception;
160 
161         boolean isAccessible(Field f) {
162             return true;
163         }
164 
<span class="line-added">165         Set&lt;String&gt; inaccessibleFields(Set&lt;String&gt; inaccessibleFields) {</span>
<span class="line-added">166             return new HashSet&lt;&gt;(inaccessibleFields);</span>
<span class="line-added">167         }</span>
<span class="line-added">168 </span>
169         static Field cloneAndSetAccessible(Field f) throws Exception {
170             // Clone to avoid mutating source field
171             f = f.getDeclaringClass().getDeclaredField(f.getName());
172             f.setAccessible(true);
173             return f;
174         }
175     }
176 
177     @DataProvider
178     public Object[][] lookupProvider() throws Exception {
179         Stream&lt;List&lt;Object&gt;&gt; baseCases = Stream.of(
180                 // Look up from same package
181                 List.of(pkg.A.class, pkg.A.lookup(), pkg.A.inaccessibleFields()),
182                 List.of(pkg.A.class, pkg.A.lookup(), pkg.A.inaccessibleFields()),
183                 List.of(pkg.A.class, B_extends_A.lookup(), B_extends_A.inaccessibleFields()),
184                 List.of(pkg.A.class, pkg.C.lookup(), pkg.C.inaccessibleFields()),
185 
186                 // Look up from sub-package
187                 List.of(pkg.A.class, pkg.subpkg.B_extends_A.lookup(), pkg.subpkg.B_extends_A.inaccessibleFields()),
188                 List.of(pkg.A.class, pkg.subpkg.C.lookup(), pkg.subpkg.C.inaccessibleFields())
189         );
190 
191         // Cross product base cases with the field lookup classes
192         return baseCases.
193                 flatMap(l -&gt; Stream.of(FieldLookup.values()).map(fl -&gt; prepend(fl, l))).
194                 toArray(Object[][]::new);
195     }
196 
197     private static Object[] prepend(Object o, List&lt;Object&gt; l) {
198         List&lt;Object&gt; pl = new ArrayList&lt;&gt;();
199         pl.add(o);
200         pl.addAll(l);
201         return pl.toArray();
202     }
203 
204     @Test(dataProvider = &quot;lookupProvider&quot;)
205     public void test(FieldLookup fl, Class&lt;?&gt; src, MethodHandles.Lookup l, Set&lt;String&gt; inaccessibleFields) {
206         // Add to the expected failures all inaccessible fields due to accessibility modifiers
<span class="line-modified">207         Set&lt;String&gt; expected = fl.inaccessibleFields(inaccessibleFields);</span>
208         Map&lt;Field, Throwable&gt; actual = new HashMap&lt;&gt;();
209 
210         for (Field f : fields(src)) {
211             // Add to the expected failures all inaccessible fields due to static/final modifiers
212             if (!fl.isAccessible(f)) {
213                 expected.add(f.getName());
214             }
215 
216             try {
217                 fl.lookup(l, f);
218             }
219             catch (Throwable t) {
220                 // Lookup failed, add to the actual failures
221                 actual.put(f, t);
222             }
223         }
224 
225         Set&lt;String&gt; actualFieldNames = actual.keySet().stream().map(Field::getName).
226                 collect(Collectors.toSet());
227         if (!actualFieldNames.equals(expected)) {
228             if (actualFieldNames.isEmpty()) {
<span class="line-modified">229                 Assert.assertEquals(actualFieldNames, expected, &quot;No accessibility failures:&quot;);</span>





230             }
231             else {
232                 Assert.assertEquals(actualFieldNames, expected, &quot;Accessibility failures differ:&quot;);
233             }
234         }
235         else {
236             if (!actual.values().stream().allMatch(IllegalAccessException.class::isInstance)) {
237                 Assert.fail(&quot;Expecting an IllegalArgumentException for all failures &quot; + actual);
238             }
239         }
240     }
241 
242     static List&lt;Field&gt; fields(Class&lt;?&gt; src) {
243         return List.of(src.getDeclaredFields());
244     }
245 }
</pre>
</td>
</tr>
</table>
<center><a href="../../TryFinallyTest.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="../../modules/Unnamed.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
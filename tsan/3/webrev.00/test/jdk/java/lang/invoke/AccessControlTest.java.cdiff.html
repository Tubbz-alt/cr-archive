<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff test/jdk/java/lang/invoke/AccessControlTest.java</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
<body>
<center><a href="../instrument/RedefineNestmateAttr/TestNestmateAttr.java.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="CallSiteTest.java.cdiff.html" target="_top">next &gt;</a></center>    <h2>test/jdk/java/lang/invoke/AccessControlTest.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 1,7 ***</span>
  /*
<span class="line-modified">!  * Copyright (c) 2012, 2018, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.
<span class="line-new-header">--- 1,7 ---</span>
  /*
<span class="line-modified">!  * Copyright (c) 2012, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 31,11 ***</span>
  
  import java.lang.invoke.*;
  import java.lang.reflect.*;
  import java.lang.reflect.Modifier;
  import java.util.*;
<span class="line-removed">- import org.testng.*;</span>
  import org.testng.annotations.*;
  
  import static java.lang.invoke.MethodHandles.*;
  import static java.lang.invoke.MethodHandles.Lookup.*;
  import static java.lang.invoke.MethodType.*;
<span class="line-new-header">--- 31,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 60,50 ***</span>
      }
  
      private class LookupCase implements Comparable&lt;LookupCase&gt; {
          final Lookup   lookup;
          final Class&lt;?&gt; lookupClass;
          final int      lookupModes;
          public LookupCase(Lookup lookup) {
              this.lookup = lookup;
              this.lookupClass = lookup.lookupClass();
              this.lookupModes = lookup.lookupModes();
              assert(lookupString().equals(lookup.toString()));
              numberOf(lookupClass().getClassLoader()); // assign CL#
          }
<span class="line-modified">!         public LookupCase(Class&lt;?&gt; lookupClass, int lookupModes) {</span>
              this.lookup = null;
              this.lookupClass = lookupClass;
              this.lookupModes = lookupModes;
              numberOf(lookupClass().getClassLoader()); // assign CL#
          }
  
<span class="line-modified">!         public final Class&lt;?&gt; lookupClass() { return lookupClass; }</span>
<span class="line-modified">!         public final int      lookupModes() { return lookupModes; }</span>
  
          public Lookup lookup() { lookup.getClass(); return lookup; }
  
          @Override
          public int compareTo(LookupCase that) {
              Class&lt;?&gt; c1 = this.lookupClass();
              Class&lt;?&gt; c2 = that.lookupClass();
              if (c1 != c2) {
                  int cmp = c1.getName().compareTo(c2.getName());
                  if (cmp != 0)  return cmp;
                  cmp = numberOf(c1.getClassLoader()) - numberOf(c2.getClassLoader());
                  assert(cmp != 0);
                  return cmp;
              }
              return -(this.lookupModes() - that.lookupModes());
          }
  
          @Override
          public boolean equals(Object that) {
              return (that instanceof LookupCase &amp;&amp; equals((LookupCase)that));
          }
          public boolean equals(LookupCase that) {
              return (this.lookupClass() == that.lookupClass() &amp;&amp;
                      this.lookupModes() == that.lookupModes());
          }
  
          @Override
          public int hashCode() {
<span class="line-new-header">--- 59,68 ---</span>
      }
  
      private class LookupCase implements Comparable&lt;LookupCase&gt; {
          final Lookup   lookup;
          final Class&lt;?&gt; lookupClass;
<span class="line-added">+         final Class&lt;?&gt; prevLookupClass;</span>
          final int      lookupModes;
          public LookupCase(Lookup lookup) {
              this.lookup = lookup;
              this.lookupClass = lookup.lookupClass();
<span class="line-added">+             this.prevLookupClass = lookup.previousLookupClass();</span>
              this.lookupModes = lookup.lookupModes();
<span class="line-added">+ </span>
              assert(lookupString().equals(lookup.toString()));
              numberOf(lookupClass().getClassLoader()); // assign CL#
          }
<span class="line-modified">!         public LookupCase(Class&lt;?&gt; lookupClass, Class&lt;?&gt; prevLookupClass, int lookupModes) {</span>
              this.lookup = null;
              this.lookupClass = lookupClass;
<span class="line-added">+             this.prevLookupClass = prevLookupClass;</span>
              this.lookupModes = lookupModes;
              numberOf(lookupClass().getClassLoader()); // assign CL#
          }
  
<span class="line-modified">!         public final Class&lt;?&gt; lookupClass()     { return lookupClass; }</span>
<span class="line-modified">!         public final Class&lt;?&gt; prevLookupClass() { return prevLookupClass; }</span>
<span class="line-added">+         public final int      lookupModes()     { return lookupModes; }</span>
  
          public Lookup lookup() { lookup.getClass(); return lookup; }
  
          @Override
          public int compareTo(LookupCase that) {
              Class&lt;?&gt; c1 = this.lookupClass();
              Class&lt;?&gt; c2 = that.lookupClass();
<span class="line-added">+             Class&lt;?&gt; p1 = this.prevLookupClass();</span>
<span class="line-added">+             Class&lt;?&gt; p2 = that.prevLookupClass();</span>
              if (c1 != c2) {
                  int cmp = c1.getName().compareTo(c2.getName());
                  if (cmp != 0)  return cmp;
                  cmp = numberOf(c1.getClassLoader()) - numberOf(c2.getClassLoader());
                  assert(cmp != 0);
                  return cmp;
<span class="line-added">+             } else if (p1 != p2){</span>
<span class="line-added">+                 if (p1 == null)</span>
<span class="line-added">+                     return 1;</span>
<span class="line-added">+                 else if (p2 == null)</span>
<span class="line-added">+                     return -1;</span>
<span class="line-added">+                 int cmp = p1.getName().compareTo(p2.getName());</span>
<span class="line-added">+                 if (cmp != 0)  return cmp;</span>
<span class="line-added">+                 cmp = numberOf(p1.getClassLoader()) - numberOf(p2.getClassLoader());</span>
<span class="line-added">+                 assert(cmp != 0);</span>
<span class="line-added">+                 return cmp;</span>
              }
              return -(this.lookupModes() - that.lookupModes());
          }
  
          @Override
          public boolean equals(Object that) {
              return (that instanceof LookupCase &amp;&amp; equals((LookupCase)that));
          }
          public boolean equals(LookupCase that) {
              return (this.lookupClass() == that.lookupClass() &amp;&amp;
<span class="line-added">+                     this.prevLookupClass() == that.prevLookupClass() &amp;&amp;</span>
                      this.lookupModes() == that.lookupModes());
          }
  
          @Override
          public int hashCode() {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 111,24 ***</span>
          }
  
          /** Simulate all assertions in the spec. for Lookup.toString. */
          private String lookupString() {
              String name = lookupClass.getName();
              String suffix = &quot;&quot;;
              if (lookupModes == 0)
                  suffix = &quot;/noaccess&quot;;
              else if (lookupModes == PUBLIC)
                  suffix = &quot;/public&quot;;
<span class="line-modified">!              else if (lookupModes == (PUBLIC|UNCONDITIONAL))</span>
                  suffix = &quot;/publicLookup&quot;;
              else if (lookupModes == (PUBLIC|MODULE))
                  suffix = &quot;/module&quot;;
<span class="line-modified">!             else if (lookupModes == (PUBLIC|MODULE|PACKAGE))</span>
                  suffix = &quot;/package&quot;;
<span class="line-modified">!             else if (lookupModes == (PUBLIC|MODULE|PACKAGE|PRIVATE))</span>
                  suffix = &quot;/private&quot;;
<span class="line-modified">!             else if (lookupModes == (PUBLIC|MODULE|PACKAGE|PRIVATE|PROTECTED))</span>
                  suffix = &quot;&quot;;
              else
                  suffix = &quot;/#&quot;+Integer.toHexString(lookupModes);
              return name+suffix;
          }
<span class="line-new-header">--- 128,29 ---</span>
          }
  
          /** Simulate all assertions in the spec. for Lookup.toString. */
          private String lookupString() {
              String name = lookupClass.getName();
<span class="line-added">+             if (prevLookupClass != null)</span>
<span class="line-added">+                 name += &quot;/&quot; + prevLookupClass.getName();</span>
              String suffix = &quot;&quot;;
              if (lookupModes == 0)
                  suffix = &quot;/noaccess&quot;;
              else if (lookupModes == PUBLIC)
                  suffix = &quot;/public&quot;;
<span class="line-modified">!              else if (lookupModes == UNCONDITIONAL)</span>
                  suffix = &quot;/publicLookup&quot;;
              else if (lookupModes == (PUBLIC|MODULE))
                  suffix = &quot;/module&quot;;
<span class="line-modified">!             else if (lookupModes == (PUBLIC|PACKAGE)</span>
<span class="line-added">+                      || lookupModes == (PUBLIC|MODULE|PACKAGE))</span>
                  suffix = &quot;/package&quot;;
<span class="line-modified">!             else if (lookupModes == (PUBLIC|PACKAGE|PRIVATE)</span>
<span class="line-added">+                     || lookupModes == (PUBLIC|MODULE|PACKAGE|PRIVATE))</span>
                  suffix = &quot;/private&quot;;
<span class="line-modified">!             else if (lookupModes == (PUBLIC|PACKAGE|PRIVATE|PROTECTED)</span>
<span class="line-added">+                      || lookupModes == (PUBLIC|MODULE|PACKAGE|PRIVATE|PROTECTED))</span>
                  suffix = &quot;&quot;;
              else
                  suffix = &quot;/#&quot;+Integer.toHexString(lookupModes);
              return name+suffix;
          }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 136,86 ***</span>
          /** Simulate all assertions from the spec. for Lookup.in:
           * &lt;hr&gt;
           * Creates a lookup on the specified new lookup class.
           * [A1] The resulting object will report the specified
           * class as its own {@link #lookupClass lookupClass}.
<span class="line-removed">-          * &lt;p&gt;</span>
           * [A2] However, the resulting {@code Lookup} object is guaranteed
           * to have no more access capabilities than the original.
           * In particular, access capabilities can be lost as follows:&lt;ul&gt;
<span class="line-modified">!          * &lt;li&gt; [A3] If the old lookup class is in a named module, and the new</span>
<span class="line-modified">!          * lookup class is in a different module {@code M}, then no members, not</span>
<span class="line-modified">!          * even public members in {@code M}&#39;s exported packages, will be accessible.</span>
<span class="line-modified">!          * The exception to this is when this lookup is publicLookup, in which case</span>
<span class="line-modified">!          * public access is not lost.</span>
<span class="line-modified">!          * &lt;li&gt; [A4] If the old lookup class is in an unnamed module, and the new</span>
<span class="line-modified">!          * lookup class is a different module then module access is lost.</span>
<span class="line-modified">!          * &lt;li&gt; [A5] If the new lookup class differs from the old one then UNCONDITIONAL</span>
<span class="line-modified">!          * is lost. If the new lookup class is not within the same package member as the</span>
<span class="line-removed">-          * old one, protected members will not be accessible by virtue of inheritance.</span>
           * (Protected members may continue to be accessible because of package sharing.)
<span class="line-modified">!          * &lt;li&gt; [A6] If the new lookup class is in a different package than the old one,</span>
<span class="line-modified">!          * protected and default (package) members will not be accessible.</span>
<span class="line-modified">!          * &lt;li&gt; [A7] If the new lookup class is not within the same package member</span>
<span class="line-modified">!          * as the old one, private members will not be accessible.</span>
<span class="line-modified">!          * &lt;li&gt; [A8] If the new lookup class is not accessible to the old lookup class,</span>
<span class="line-modified">!          * then no members, not even public members, will be accessible.</span>
<span class="line-modified">!          * &lt;li&gt; [A9] (In all other cases, public members will continue to be accessible.)</span>
<span class="line-modified">!          * &lt;/ul&gt;</span>
           * Other than the above cases, the new lookup will have the same
<span class="line-modified">!          * access capabilities as the original. [A10]</span>
           * &lt;hr&gt;
           */
          public LookupCase in(Class&lt;?&gt; c2) {
              Class&lt;?&gt; c1 = lookupClass();
<span class="line-modified">!             int m1 = lookupModes();</span>
              int changed = 0;
              // for the purposes of access control then treat classes in different unnamed
              // modules as being in the same module.
<span class="line-modified">!             boolean sameModule = (c1.getModule() == c2.getModule()) ||</span>
<span class="line-modified">!                                  (!c1.getModule().isNamed() &amp;&amp; !c2.getModule().isNamed());</span>
              boolean samePackage = (c1.getClassLoader() == c2.getClassLoader() &amp;&amp;
                                     c1.getPackageName().equals(c2.getPackageName()));
              boolean sameTopLevel = (topLevelClass(c1) == topLevelClass(c2));
              boolean sameClass = (c1 == c2);
              assert(samePackage  || !sameTopLevel);
              assert(sameTopLevel || !sameClass);
              boolean accessible = sameClass;
<span class="line-modified">!             if ((m1 &amp; PACKAGE) != 0)  accessible |= samePackage;</span>
<span class="line-modified">!             if ((m1 &amp; PUBLIC ) != 0)  accessible |= (c2.getModifiers() &amp; PUBLIC) != 0;</span>
<span class="line-modified">!             if (!sameModule) {</span>
<span class="line-modified">!                 if (c1.getModule().isNamed() &amp;&amp; (m1 &amp; UNCONDITIONAL) == 0) {</span>
<span class="line-modified">!                     accessible = false;  // [A3]</span>
<span class="line-modified">!                 } else {</span>
<span class="line-modified">!                     changed |= (MODULE|PACKAGE|PRIVATE|PROTECTED);    // [A3] [A4]</span>
<span class="line-modified">!                 }</span>
              }
              if (!accessible) {
<span class="line-modified">!                 // Different package and no access to c2; lose all access.</span>
<span class="line-modified">!                 changed |= (PUBLIC|MODULE|PACKAGE|PRIVATE|PROTECTED);  // [A8]</span>
              }
              if (!samePackage) {
                  // Different package; loose PACKAGE and lower access.
<span class="line-modified">!                 changed |= (PACKAGE|PRIVATE|PROTECTED);  // [A6]</span>
              }
              if (!sameTopLevel) {
                  // Different top-level class.  Lose PRIVATE and PROTECTED access.
<span class="line-modified">!                 changed |= (PRIVATE|PROTECTED);  // [A5] [A7]</span>
              }
<span class="line-modified">!             if (!sameClass) {</span>
<span class="line-modified">!                 changed |= (UNCONDITIONAL);     // [A5]</span>
<span class="line-removed">-             } else {</span>
<span class="line-removed">-                 assert(changed == 0);       // [A10] (no deprivation if same class)</span>
              }
<span class="line-modified">!             if (accessible)  assert((changed &amp; PUBLIC) == 0);  // [A9]</span>
<span class="line-modified">!             int m2 = m1 &amp; ~changed;</span>
<span class="line-modified">!             LookupCase l2 = new LookupCase(c2, m2);</span>
<span class="line-modified">!             assert(l2.lookupClass() == c2); // [A1]</span>
<span class="line-modified">!             assert((m1 | m2) == m1);        // [A2] (no elevation of access)</span>
              return l2;
          }
  
          @Override
          public String toString() {
              String s = lookupClass().getSimpleName();
              String lstr = lookupString();
              int sl = lstr.indexOf(&#39;/&#39;);
<span class="line-new-header">--- 158,140 ---</span>
          /** Simulate all assertions from the spec. for Lookup.in:
           * &lt;hr&gt;
           * Creates a lookup on the specified new lookup class.
           * [A1] The resulting object will report the specified
           * class as its own {@link #lookupClass lookupClass}.
           * [A2] However, the resulting {@code Lookup} object is guaranteed
           * to have no more access capabilities than the original.
           * In particular, access capabilities can be lost as follows:&lt;ul&gt;
<span class="line-modified">!          * [A3] If the new lookup class is in a different module from the old one,</span>
<span class="line-modified">!          * i.e. {@link #MODULE MODULE} access is lost.</span>
<span class="line-modified">!          * [A4] If the new lookup class is in a different package</span>
<span class="line-modified">!          * than the old one, protected and default (package) members will not be accessible,</span>
<span class="line-modified">!          * i.e. {@link #PROTECTED PROTECTED} and {@link #PACKAGE PACKAGE} access are lost.</span>
<span class="line-modified">!          * [A5] If the new lookup class is not within the same package member</span>
<span class="line-modified">!          * as the old one, private members will not be accessible, and protected members</span>
<span class="line-modified">!          * will not be accessible by virtue of inheritance,</span>
<span class="line-modified">!          * i.e. {@link #PRIVATE PRIVATE} access is lost.</span>
           * (Protected members may continue to be accessible because of package sharing.)
<span class="line-modified">!          * [A6] If the new lookup class is not</span>
<span class="line-modified">!          * {@linkplain #accessClass(Class) accessible} to this lookup,</span>
<span class="line-modified">!          * then no members, not even public members, will be accessible</span>
<span class="line-modified">!          * i.e. all access modes are lost.</span>
<span class="line-modified">!          * [A7] If the new lookup class, the old lookup class and the previous lookup class</span>
<span class="line-modified">!          * are all in different modules i.e. teleporting to a third module,</span>
<span class="line-modified">!          * all access modes are lost.</span>
<span class="line-modified">!          * &lt;p&gt;</span>
<span class="line-added">+          * The new previous lookup class is chosen as follows:</span>
<span class="line-added">+          * [A8] If the new lookup object has {@link #UNCONDITIONAL UNCONDITIONAL} bit,</span>
<span class="line-added">+          * the new previous lookup class is {@code null}.</span>
<span class="line-added">+          * [A9] If the new lookup class is in the same module as the old lookup class,</span>
<span class="line-added">+          * the new previous lookup class is the old previous lookup class.</span>
<span class="line-added">+          * [A10] If the new lookup class is in a different module from the old lookup class,</span>
<span class="line-added">+          * the new previous lookup class is the the old lookup class.</span>
<span class="line-added">+          *</span>
           * Other than the above cases, the new lookup will have the same
<span class="line-modified">!          * access capabilities as the original. [A11]</span>
           * &lt;hr&gt;
           */
          public LookupCase in(Class&lt;?&gt; c2) {
              Class&lt;?&gt; c1 = lookupClass();
<span class="line-modified">!             Module m1 = c1.getModule();</span>
<span class="line-added">+             Module m2 = c2.getModule();</span>
<span class="line-added">+             Module m0 = prevLookupClass() != null ? prevLookupClass.getModule() : c1.getModule();</span>
<span class="line-added">+             int modes1 = lookupModes();</span>
              int changed = 0;
              // for the purposes of access control then treat classes in different unnamed
              // modules as being in the same module.
<span class="line-modified">!             boolean sameModule = (m1 == m2) ||</span>
<span class="line-modified">!                                  (!m1.isNamed() &amp;&amp; !m2.isNamed());</span>
              boolean samePackage = (c1.getClassLoader() == c2.getClassLoader() &amp;&amp;
                                     c1.getPackageName().equals(c2.getPackageName()));
              boolean sameTopLevel = (topLevelClass(c1) == topLevelClass(c2));
              boolean sameClass = (c1 == c2);
              assert(samePackage  || !sameTopLevel);
              assert(sameTopLevel || !sameClass);
              boolean accessible = sameClass;
<span class="line-modified">! </span>
<span class="line-modified">!             if ((modes1 &amp; PACKAGE) != 0)  accessible |= samePackage;</span>
<span class="line-modified">!             if ((modes1 &amp; PUBLIC ) != 0)  {</span>
<span class="line-modified">!                 if (isModuleAccessible(c2))</span>
<span class="line-modified">!                     accessible |= (c2.getModifiers() &amp; PUBLIC) != 0;</span>
<span class="line-modified">!                 else</span>
<span class="line-modified">!                     accessible = false;</span>
<span class="line-modified">!             }</span>
<span class="line-added">+             if ((modes1 &amp; UNCONDITIONAL) != 0) {</span>
<span class="line-added">+                 if (m2.isExported(c2.getPackageName()))</span>
<span class="line-added">+                     accessible |= (c2.getModifiers() &amp; PUBLIC) != 0;</span>
<span class="line-added">+                 else</span>
<span class="line-added">+                     accessible = false;</span>
              }
              if (!accessible) {
<span class="line-modified">!                 // no access to c2; lose all access.</span>
<span class="line-modified">!                 changed |= (PUBLIC|MODULE|PACKAGE|PRIVATE|PROTECTED|UNCONDITIONAL);  // [A6]</span>
<span class="line-added">+             }</span>
<span class="line-added">+             if (m2 != m1 &amp;&amp; m0 != m1) {</span>
<span class="line-added">+                 // hop to a third module; lose all access</span>
<span class="line-added">+                 changed |= (PUBLIC|MODULE|PACKAGE|PRIVATE|PROTECTED);  // [A7]</span>
<span class="line-added">+             }</span>
<span class="line-added">+             if (!sameModule) {</span>
<span class="line-added">+                 changed |= MODULE;  // [A3]</span>
              }
              if (!samePackage) {
                  // Different package; loose PACKAGE and lower access.
<span class="line-modified">!                 changed |= (PACKAGE|PRIVATE|PROTECTED);  // [A4]</span>
              }
              if (!sameTopLevel) {
                  // Different top-level class.  Lose PRIVATE and PROTECTED access.
<span class="line-modified">!                 changed |= (PRIVATE|PROTECTED);  // [A5]</span>
              }
<span class="line-modified">!             if (sameClass) {</span>
<span class="line-modified">!                 assert(changed == 0);       // [A11] (no deprivation if same class)</span>
              }
<span class="line-modified">! </span>
<span class="line-modified">!             if (accessible)  assert((changed &amp; PUBLIC) == 0);</span>
<span class="line-modified">!             int modes2 = modes1 &amp; ~changed;</span>
<span class="line-modified">!             Class&lt;?&gt; plc = (m1 == m2) ? prevLookupClass() : c1; // [A9] [A10]</span>
<span class="line-modified">!             if ((modes1 &amp; UNCONDITIONAL) != 0) plc = null;      // [A8]</span>
<span class="line-added">+             LookupCase l2 = new LookupCase(c2, plc, modes2);</span>
<span class="line-added">+             assert(l2.lookupClass() == c2);         // [A1]</span>
<span class="line-added">+             assert((modes1 | modes2) == modes1);    // [A2] (no elevation of access)</span>
<span class="line-added">+             assert(l2.prevLookupClass() == null || (modes2 &amp; MODULE) == 0);</span>
<span class="line-added">+             return l2;</span>
<span class="line-added">+         }</span>
<span class="line-added">+ </span>
<span class="line-added">+         LookupCase dropLookupMode(int modeToDrop) {</span>
<span class="line-added">+             int oldModes = lookupModes();</span>
<span class="line-added">+             int newModes = oldModes &amp; ~(modeToDrop | PROTECTED);</span>
<span class="line-added">+             switch (modeToDrop) {</span>
<span class="line-added">+                 case PUBLIC: newModes &amp;= ~(MODULE|PACKAGE|PROTECTED|PRIVATE); break;</span>
<span class="line-added">+                 case MODULE: newModes &amp;= ~(PACKAGE|PRIVATE); break;</span>
<span class="line-added">+                 case PACKAGE: newModes &amp;= ~(PRIVATE); break;</span>
<span class="line-added">+                 case PROTECTED:</span>
<span class="line-added">+                 case PRIVATE:</span>
<span class="line-added">+                 case UNCONDITIONAL: break;</span>
<span class="line-added">+                 default: throw new IllegalArgumentException(modeToDrop + &quot; is not a valid mode to drop&quot;);</span>
<span class="line-added">+             }</span>
<span class="line-added">+             if (newModes == oldModes) return this;  // return self if no change</span>
<span class="line-added">+             LookupCase l2 = new LookupCase(lookupClass(), prevLookupClass(), newModes);</span>
<span class="line-added">+             assert((oldModes | newModes) == oldModes);    // [A2] (no elevation of access)</span>
<span class="line-added">+             assert(l2.prevLookupClass() == null || (newModes &amp; MODULE) == 0);</span>
              return l2;
          }
  
<span class="line-added">+         boolean isModuleAccessible(Class&lt;?&gt; c) {</span>
<span class="line-added">+             Module m1 = lookupClass().getModule();</span>
<span class="line-added">+             Module m2 = c.getModule();</span>
<span class="line-added">+             Module m0 = prevLookupClass() != null ? prevLookupClass.getModule() : m1;</span>
<span class="line-added">+             String pn = c.getPackageName();</span>
<span class="line-added">+             boolean accessible = m1.canRead(m2) &amp;&amp; m2.isExported(pn, m1);</span>
<span class="line-added">+             if (m1 != m0) {</span>
<span class="line-added">+                 accessible = accessible &amp;&amp; m0.canRead(m2) &amp;&amp; m2.isExported(pn, m0);</span>
<span class="line-added">+             }</span>
<span class="line-added">+             return accessible;</span>
<span class="line-added">+         }</span>
<span class="line-added">+ </span>
          @Override
          public String toString() {
              String s = lookupClass().getSimpleName();
              String lstr = lookupString();
              int sl = lstr.indexOf(&#39;/&#39;);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 227,37 ***</span>
  
          /** Predict the success or failure of accessing this method. */
          public boolean willAccess(Method m) {
              Class&lt;?&gt; c1 = lookupClass();
              Class&lt;?&gt; c2 = m.getDeclaringClass();
  
<span class="line-modified">!             // publicLookup has access to all public types/members of types in unnamed modules</span>
<span class="line-modified">!             if ((lookupModes &amp; UNCONDITIONAL) != 0</span>
<span class="line-modified">!                 &amp;&amp; (lookupModes &amp; PUBLIC) != 0</span>
<span class="line-modified">!                 &amp;&amp; !c2.getModule().isNamed()</span>
<span class="line-modified">!                 &amp;&amp; Modifier.isPublic(c2.getModifiers())</span>
<span class="line-modified">!                 &amp;&amp; Modifier.isPublic(m.getModifiers()))</span>
<span class="line-modified">!                 return true;</span>
  
              LookupCase lc = this.in(c2);
<span class="line-modified">!             int m1 = lc.lookupModes();</span>
<span class="line-modified">!             int m2 = fixMods(m.getModifiers());</span>
              // allow private lookup on nestmates. Otherwise, privacy is strictly enforced
<span class="line-modified">!             if (c1 != c2 &amp;&amp; ((m2 &amp; PRIVATE) == 0 || !c1.isNestmateOf(c2))) {</span>
<span class="line-modified">!                 m1 &amp;= ~PRIVATE;</span>
              }
              // protected access is sometimes allowed
<span class="line-modified">!             if ((m2 &amp; PROTECTED) != 0) {</span>
<span class="line-modified">!                 int prev = m2;</span>
<span class="line-modified">!                 m2 |= PACKAGE;  // it acts like a package method also</span>
                  if ((lookupModes() &amp; PROTECTED) != 0 &amp;&amp;
                      c2.isAssignableFrom(c1))
<span class="line-modified">!                     m2 |= PUBLIC;  // from a subclass, it acts like a public method also</span>
              }
              if (verbosity &gt;= 2)
<span class="line-modified">!                 System.out.format(&quot;%s willAccess %s m1=0x%h m2=0x%h =&gt; %s%n&quot;, this, lc, m1, m2, ((m2 &amp; m1) != 0));</span>
<span class="line-modified">!             return (m2 &amp; m1) != 0;</span>
          }
  
          /** Predict the success or failure of accessing this class. */
          public boolean willAccessClass(Class&lt;?&gt; c2, boolean load) {
              Class&lt;?&gt; c1 = lookupClass();
<span class="line-new-header">--- 303,52 ---</span>
  
          /** Predict the success or failure of accessing this method. */
          public boolean willAccess(Method m) {
              Class&lt;?&gt; c1 = lookupClass();
              Class&lt;?&gt; c2 = m.getDeclaringClass();
<span class="line-added">+             Module m1 = c1.getModule();</span>
<span class="line-added">+             Module m2 = c2.getModule();</span>
<span class="line-added">+             Module m0 = prevLookupClass != null ? prevLookupClass.getModule() : m1;</span>
<span class="line-added">+             // unconditional has access to all public types/members of types that is in a package</span>
<span class="line-added">+             // are unconditionally exported</span>
<span class="line-added">+             if ((lookupModes &amp; UNCONDITIONAL) != 0) {</span>
<span class="line-added">+                 return m2.isExported(c2.getPackageName())</span>
<span class="line-added">+                        &amp;&amp; Modifier.isPublic(c2.getModifiers())</span>
<span class="line-added">+                        &amp;&amp; Modifier.isPublic(m.getModifiers());</span>
<span class="line-added">+             }</span>
  
<span class="line-modified">!             // c1 and c2 are in different module</span>
<span class="line-modified">!             if (m1 != m2 || m0 != m2) {</span>
<span class="line-modified">!                 return (lookupModes &amp; PUBLIC) != 0</span>
<span class="line-modified">!                        &amp;&amp; isModuleAccessible(c2)</span>
<span class="line-modified">!                        &amp;&amp; Modifier.isPublic(c2.getModifiers())</span>
<span class="line-modified">!                        &amp;&amp; Modifier.isPublic(m.getModifiers());</span>
<span class="line-modified">!             }</span>
<span class="line-added">+ </span>
<span class="line-added">+             assert(m1 == m2 &amp;&amp; prevLookupClass == null);</span>
<span class="line-added">+ </span>
<span class="line-added">+             if (!willAccessClass(c2, false))</span>
<span class="line-added">+                 return false;</span>
  
              LookupCase lc = this.in(c2);
<span class="line-modified">!             int modes1 = lc.lookupModes();</span>
<span class="line-modified">!             int modes2 = fixMods(m.getModifiers());</span>
              // allow private lookup on nestmates. Otherwise, privacy is strictly enforced
<span class="line-modified">!             if (c1 != c2 &amp;&amp; ((modes2 &amp; PRIVATE) == 0 || !c1.isNestmateOf(c2))) {</span>
<span class="line-modified">!                 modes1 &amp;= ~PRIVATE;</span>
              }
              // protected access is sometimes allowed
<span class="line-modified">!             if ((modes2 &amp; PROTECTED) != 0) {</span>
<span class="line-modified">!                 int prev = modes2;</span>
<span class="line-modified">!                 modes2 |= PACKAGE;  // it acts like a package method also</span>
                  if ((lookupModes() &amp; PROTECTED) != 0 &amp;&amp;
                      c2.isAssignableFrom(c1))
<span class="line-modified">!                     modes2 |= PUBLIC;  // from a subclass, it acts like a public method also</span>
              }
              if (verbosity &gt;= 2)
<span class="line-modified">!                 System.out.format(&quot;%s willAccess %s modes1=0x%h modes2=0x%h =&gt; %s%n&quot;, lookupString(), lc.lookupString(), modes1, modes2, (modes2 &amp; modes1) != 0);</span>
<span class="line-modified">!             return (modes2 &amp; modes1) != 0;</span>
          }
  
          /** Predict the success or failure of accessing this class. */
          public boolean willAccessClass(Class&lt;?&gt; c2, boolean load) {
              Class&lt;?&gt; c1 = lookupClass();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 266,28 ***</span>
                      // not visible
                      return false;
                  }
              }
  
<span class="line-modified">!             // publicLookup has access to all public types/members of types in unnamed modules</span>
<span class="line-modified">!             if ((lookupModes &amp; UNCONDITIONAL) != 0</span>
<span class="line-modified">!                 &amp;&amp; (lookupModes &amp; PUBLIC) != 0</span>
<span class="line-modified">!                 &amp;&amp; (!c2.getModule().isNamed())</span>
<span class="line-modified">!                 &amp;&amp; Modifier.isPublic(c2.getModifiers()))</span>
<span class="line-modified">!                 return true;</span>
  
              LookupCase lc = this.in(c2);
<span class="line-modified">!             int m1 = lc.lookupModes();</span>
              boolean r = false;
<span class="line-modified">!             if (m1 == 0) {</span>
                  r = false;
              } else {
<span class="line-modified">!                 int m2 = fixMods(c2.getModifiers());</span>
<span class="line-modified">!                 if ((m2 &amp; PUBLIC) != 0) {</span>
<span class="line-modified">!                     r = true;</span>
<span class="line-modified">!                 } else if ((m1 &amp; PACKAGE) != 0 &amp;&amp; c1.getPackage() == c2.getPackage()) {</span>
<span class="line-modified">!                     r = true;</span>
                  }
              }
              if (verbosity &gt;= 2) {
                  System.out.println(this+&quot; willAccessClass &quot;+lc+&quot; c1=&quot;+c1+&quot; c2=&quot;+c2+&quot; =&gt; &quot;+r);
              }
<span class="line-new-header">--- 357,40 ---</span>
                      // not visible
                      return false;
                  }
              }
  
<span class="line-modified">!             Module m1 = c1.getModule();</span>
<span class="line-modified">!             Module m2 = c2.getModule();</span>
<span class="line-modified">!             Module m0 = prevLookupClass != null ? prevLookupClass.getModule() : m1;</span>
<span class="line-modified">!             // unconditional has access to all public types that is in an unconditionally exported package</span>
<span class="line-modified">!             if ((lookupModes &amp; UNCONDITIONAL) != 0) {</span>
<span class="line-modified">!                 return m2.isExported(c2.getPackageName()) &amp;&amp; Modifier.isPublic(c2.getModifiers());</span>
<span class="line-added">+             }</span>
<span class="line-added">+             // c1 and c2 are in different module</span>
<span class="line-added">+             if (m1 != m2 || m0 != m2) {</span>
<span class="line-added">+                 return (lookupModes &amp; PUBLIC) != 0</span>
<span class="line-added">+                     &amp;&amp; isModuleAccessible(c2)</span>
<span class="line-added">+                     &amp;&amp; Modifier.isPublic(c2.getModifiers());</span>
<span class="line-added">+             }</span>
<span class="line-added">+ </span>
<span class="line-added">+             assert(m1 == m2 &amp;&amp; prevLookupClass == null);</span>
  
              LookupCase lc = this.in(c2);
<span class="line-modified">!             int modes1 = lc.lookupModes();</span>
              boolean r = false;
<span class="line-modified">!             if (modes1 == 0) {</span>
                  r = false;
              } else {
<span class="line-modified">!                 if (Modifier.isPublic(c2.getModifiers())) {</span>
<span class="line-modified">!                     if ((modes1 &amp; MODULE) != 0)</span>
<span class="line-modified">!                         r = true;</span>
<span class="line-modified">!                     else if ((modes1 &amp; PUBLIC) != 0)</span>
<span class="line-modified">!                         r = m1.isExported(c2.getPackageName());</span>
<span class="line-added">+                 } else {</span>
<span class="line-added">+                     if ((modes1 &amp; PACKAGE) != 0 &amp;&amp; c1.getPackage() == c2.getPackage())</span>
<span class="line-added">+                         r = true;</span>
                  }
              }
              if (verbosity &gt;= 2) {
                  System.out.println(this+&quot; willAccessClass &quot;+lc+&quot; c1=&quot;+c1+&quot; c2=&quot;+c2+&quot; =&gt; &quot;+r);
              }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 326,20 ***</span>
              LOADERS.add(cl);
          }
          return i+1;
      }
  
<span class="line-modified">!     private void addLookupEdge(LookupCase l1, Class&lt;?&gt; c2, LookupCase l2) {</span>
          TreeSet&lt;LookupCase&gt; edges = CASE_EDGES.get(l2);
          if (edges == null)  CASE_EDGES.put(l2, edges = new TreeSet&lt;&gt;());
          if (edges.add(l1)) {
              Class&lt;?&gt; c1 = l1.lookupClass();
              assert(l2.lookupClass() == c2); // [A1]
              int m1 = l1.lookupModes();
              int m2 = l2.lookupModes();
              assert((m1 | m2) == m1);        // [A2] (no elevation of access)
<span class="line-modified">!             LookupCase expect = l1.in(c2);</span>
              if (!expect.equals(l2))
                  System.out.println(&quot;*** expect &quot;+l1+&quot; =&gt; &quot;+expect+&quot; but got &quot;+l2);
              assertEquals(l2, expect);
          }
      }
<span class="line-new-header">--- 429,20 ---</span>
              LOADERS.add(cl);
          }
          return i+1;
      }
  
<span class="line-modified">!     private void addLookupEdge(LookupCase l1, Class&lt;?&gt; c2, LookupCase l2, int dropAccess) {</span>
          TreeSet&lt;LookupCase&gt; edges = CASE_EDGES.get(l2);
          if (edges == null)  CASE_EDGES.put(l2, edges = new TreeSet&lt;&gt;());
          if (edges.add(l1)) {
              Class&lt;?&gt; c1 = l1.lookupClass();
              assert(l2.lookupClass() == c2); // [A1]
              int m1 = l1.lookupModes();
              int m2 = l2.lookupModes();
              assert((m1 | m2) == m1);        // [A2] (no elevation of access)
<span class="line-modified">!             LookupCase expect = dropAccess == 0 ? l1.in(c2) : l1.in(c2).dropLookupMode(dropAccess);</span>
              if (!expect.equals(l2))
                  System.out.println(&quot;*** expect &quot;+l1+&quot; =&gt; &quot;+expect+&quot; but got &quot;+l2);
              assertEquals(l2, expect);
          }
      }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 356,13 ***</span>
          System.out.println(&quot;loaders = &quot;+LOADERS);
          int rounds = 0;
          for (int lastCount = -1; lastCount != CASES.size(); ) {
              lastCount = CASES.size();  // if CASES grow in the loop we go round again
              for (LookupCase lc1 : CASES.toArray(new LookupCase[0])) {
                  for (Class&lt;?&gt; c2 : classes) {
                      LookupCase lc2 = new LookupCase(lc1.lookup().in(c2));
<span class="line-modified">!                     addLookupEdge(lc1, c2, lc2);</span>
                      CASES.add(lc2);
                  }
              }
              rounds++;
          }
<span class="line-new-header">--- 459,18 ---</span>
          System.out.println(&quot;loaders = &quot;+LOADERS);
          int rounds = 0;
          for (int lastCount = -1; lastCount != CASES.size(); ) {
              lastCount = CASES.size();  // if CASES grow in the loop we go round again
              for (LookupCase lc1 : CASES.toArray(new LookupCase[0])) {
<span class="line-added">+                 for (int mode : ACCESS_CASES) {</span>
<span class="line-added">+                     LookupCase lc2 = new LookupCase(lc1.lookup().dropLookupMode(mode));</span>
<span class="line-added">+                     addLookupEdge(lc1, lc1.lookupClass(), lc2, mode);</span>
<span class="line-added">+                     CASES.add(lc2);</span>
<span class="line-added">+                 }</span>
                  for (Class&lt;?&gt; c2 : classes) {
                      LookupCase lc2 = new LookupCase(lc1.lookup().in(c2));
<span class="line-modified">!                     addLookupEdge(lc1, c2, lc2, 0);</span>
                      CASES.add(lc2);
                  }
              }
              rounds++;
          }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 384,22 ***</span>
      @Test public void test() {
          makeCases(lookups());
          if (verbosity &gt; 0) {
              verbosity += 9;
              Method pro_in_self = targetMethod(THIS_CLASS, PROTECTED, methodType(void.class));
<span class="line-modified">!             testOneAccess(lookupCase(&quot;AccessControlTest/public&quot;),  pro_in_self, &quot;find&quot;);</span>
<span class="line-modified">!             testOneAccess(lookupCase(&quot;Remote_subclass/public&quot;),    pro_in_self, &quot;find&quot;);</span>
              testOneAccess(lookupCase(&quot;Remote_subclass&quot;),           pro_in_self, &quot;find&quot;);
              verbosity -= 9;
          }
          Set&lt;Class&lt;?&gt;&gt; targetClassesDone = new HashSet&lt;&gt;();
          for (LookupCase targetCase : CASES) {
              Class&lt;?&gt; targetClass = targetCase.lookupClass();
              if (!targetClassesDone.add(targetClass))  continue;  // already saw this one
              String targetPlace = placeName(targetClass);
              if (targetPlace == null)  continue;  // Object, String, not a target
              for (int targetAccess : ACCESS_CASES) {
                  MethodType methodType = methodType(void.class);
                  Method method = targetMethod(targetClass, targetAccess, methodType);
                  // Try to access target method from various contexts.
                  for (LookupCase sourceCase : CASES) {
                      testOneAccess(sourceCase, method, &quot;findClass&quot;);
<span class="line-new-header">--- 492,24 ---</span>
      @Test public void test() {
          makeCases(lookups());
          if (verbosity &gt; 0) {
              verbosity += 9;
              Method pro_in_self = targetMethod(THIS_CLASS, PROTECTED, methodType(void.class));
<span class="line-modified">!             testOneAccess(lookupCase(&quot;AccessControlTest/module&quot;),  pro_in_self, &quot;find&quot;);</span>
<span class="line-modified">!             testOneAccess(lookupCase(&quot;Remote_subclass/module&quot;),    pro_in_self, &quot;find&quot;);</span>
              testOneAccess(lookupCase(&quot;Remote_subclass&quot;),           pro_in_self, &quot;find&quot;);
              verbosity -= 9;
          }
          Set&lt;Class&lt;?&gt;&gt; targetClassesDone = new HashSet&lt;&gt;();
          for (LookupCase targetCase : CASES) {
              Class&lt;?&gt; targetClass = targetCase.lookupClass();
              if (!targetClassesDone.add(targetClass))  continue;  // already saw this one
              String targetPlace = placeName(targetClass);
              if (targetPlace == null)  continue;  // Object, String, not a target
              for (int targetAccess : ACCESS_CASES) {
<span class="line-added">+                 if (targetAccess == MODULE || targetAccess == UNCONDITIONAL)</span>
<span class="line-added">+                     continue;</span>
                  MethodType methodType = methodType(void.class);
                  Method method = targetMethod(targetClass, targetAccess, methodType);
                  // Try to access target method from various contexts.
                  for (LookupCase sourceCase : CASES) {
                      testOneAccess(sourceCase, method, &quot;findClass&quot;);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 455,11 ***</span>
          testCount++;
          if (!didAccess)  testCountFails++;
      }
  
      static Method targetMethod(Class&lt;?&gt; targetClass, int targetAccess, MethodType methodType) {
<span class="line-removed">-         assert targetAccess != MODULE;</span>
          String methodName = accessName(targetAccess)+placeName(targetClass);
          if (verbosity &gt;= 2)
              System.out.println(targetClass.getSimpleName()+&quot;.&quot;+methodName+methodType);
          try {
              Method method = targetClass.getDeclaredMethod(methodName, methodType.parameterArray());
<span class="line-new-header">--- 565,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 489,14 ***</span>
          case PRIVATE:    return &quot;pri_in_&quot;;
          }
          assert(false);
          return &quot;?&quot;;
      }
<span class="line-removed">-     // MODULE not a test case at this time</span>
      private static final int[] ACCESS_CASES = {
<span class="line-modified">!         PUBLIC, PACKAGE, PRIVATE, PROTECTED</span>
      };
      /** Return one of the ACCESS_CASES. */
      static int fixMods(int mods) {
          mods &amp;= (PUBLIC|PRIVATE|PROTECTED);
          switch (mods) {
          case PUBLIC: case PRIVATE: case PROTECTED: return mods;
<span class="line-new-header">--- 598,17 ---</span>
          case PRIVATE:    return &quot;pri_in_&quot;;
          }
          assert(false);
          return &quot;?&quot;;
      }
      private static final int[] ACCESS_CASES = {
<span class="line-modified">!         PUBLIC, PACKAGE, PRIVATE, PROTECTED, MODULE, UNCONDITIONAL</span>
      };
<span class="line-added">+     /*</span>
<span class="line-added">+      * Adjust PUBLIC =&gt; PUBLIC|MODULE|UNCONDITIONAL</span>
<span class="line-added">+      * Adjust 0 =&gt; PACKAGE</span>
<span class="line-added">+      */</span>
      /** Return one of the ACCESS_CASES. */
      static int fixMods(int mods) {
          mods &amp;= (PUBLIC|PRIVATE|PROTECTED);
          switch (mods) {
          case PUBLIC: case PRIVATE: case PROTECTED: return mods;
</pre>
<center><a href="../instrument/RedefineNestmateAttr/TestNestmateAttr.java.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="CallSiteTest.java.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
diff a/test/jdk/java/lang/invoke/MethodHandlesGeneralTest.java b/test/jdk/java/lang/invoke/MethodHandlesGeneralTest.java
--- a/test/jdk/java/lang/invoke/MethodHandlesGeneralTest.java
+++ b/test/jdk/java/lang/invoke/MethodHandlesGeneralTest.java
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2018, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2018, 2019, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.
@@ -20,10 +20,11 @@
  * or visit www.oracle.com if you need additional information or have any
  * questions.
  */
 
 /* @test
+ * @bug 8216558
  * @summary unit tests for java.lang.invoke.MethodHandles
  * @library /test/lib /java/lang/invoke/common
  * @compile MethodHandlesTest.java MethodHandlesGeneralTest.java remote/RemoteExample.java
  * @run junit/othervm/timeout=2500 -XX:+IgnoreUnrecognizedVMOptions
  *                                 -XX:-VerifyDependencies
@@ -632,11 +633,11 @@
         testGetter(TEST_FIND_STATIC);
     }
 
     public void testGetter(int testMode) throws Throwable {
         Lookup lookup = PRIVATE;  // FIXME: test more lookups than this one
-        for (Object[] c : HasFields.CASES) {
+        for (Object[] c : HasFields.testCasesFor(testMode)) {
             boolean positive = (c[1] != Error.class);
             testGetter(positive, lookup, c[0], c[1], testMode);
             if (positive)
                 testGetter(positive, lookup, c[0], c[1], testMode | TEST_NPE);
         }
@@ -721,19 +722,24 @@
                 :   IllegalAccessException.class,
                 noAccess);
             if (verbosity >= 5)  ex.printStackTrace(System.out);
         }
         if (verbosity >= 3)
-            System.out.println("find"+(isStatic?"Static":"")+(isGetter?"Getter":"Setter")+" "+fclass.getName()+"."+fname+"/"+ftype
-                               +" => "+mh
-                               +(noAccess == null ? "" : " !! "+noAccess));
+            System.out.format("%s%s %s.%s/%s => %s %s%n",
+                              (testMode0 & TEST_UNREFLECT) != 0
+                                  ? "unreflect"
+                                  : "find" + ((testMode0 & TEST_FIND_STATIC) != 0 ? "Static" : ""),
+                              (isGetter ? "Getter" : "Setter"),
+                              fclass.getName(), fname, ftype, mh,
+                              (noAccess == null ? "" : " !! "+noAccess));
+        // negative test case and expected noAccess, then done.
+        if (!positive && noAccess != null) return;
+        // positive test case but found noAccess, then error
         if (positive && !testNPE && noAccess != null)  throw new RuntimeException(noAccess);
         assertEquals(positive0 ? "positive test" : "negative test erroneously passed", positive0, mh != null);
         if (!positive && !testNPE)  return; // negative access test failed as expected
         assertEquals((isStatic ? 0 : 1)+(isGetter ? 0 : 1), mh.type().parameterCount());
-
-
         assertSame(mh.type(), expType);
         //assertNameStringContains(mh, fname);  // This does not hold anymore with LFs
         HasFields fields = new HasFields();
         HasFields fieldsForMH = fields;
         if (testNPE)  fieldsForMH = null;  // perturb MH argument to elicit expected error
@@ -753,10 +759,13 @@
         }
         if (f != null && f.getDeclaringClass() == HasFields.class) {
             assertEquals(f.get(fields), value);  // clean to start with
         }
         Throwable caughtEx = null;
+        // non-final field and setAccessible(true) on instance field will have write access
+        boolean writeAccess = !Modifier.isFinal(f.getModifiers()) ||
+                              (!Modifier.isStatic(f.getModifiers()) && f.isAccessible());
         if (isGetter) {
             Object expValue = value;
             for (int i = 0; i <= 1; i++) {
                 sawValue = null;  // make DA rules happy under try/catch
                 try {
@@ -776,12 +785,11 @@
                         caughtEx = ex;
                         break;
                     }
                 }
                 assertEquals(sawValue, expValue);
-                if (f != null && f.getDeclaringClass() == HasFields.class
-                    && !Modifier.isFinal(f.getModifiers())) {
+                if (f != null && f.getDeclaringClass() == HasFields.class && writeAccess) {
                     Object random = randomArg(ftype);
                     f.set(fields, random);
                     expValue = random;
                 } else {
                     break;
@@ -811,12 +819,12 @@
                 if (f != null && f.getDeclaringClass() == HasFields.class) {
                     assertEquals(f.get(fields), putValue);
                 }
             }
         }
-        if (f != null && f.getDeclaringClass() == HasFields.class) {
-            f.set(fields, value);  // put it back
+        if (f != null && f.getDeclaringClass() == HasFields.class && writeAccess) {
+            f.set(fields, value);  // put it back if it has write access
         }
         if (testNPE) {
             if (caughtEx == null || !(caughtEx instanceof NullPointerException))
                 throw new RuntimeException("failed to catch NPE exception"+(caughtEx == null ? " (caughtEx=null)" : ""), caughtEx);
             caughtEx = null;  // nullify expected exception
@@ -860,12 +868,12 @@
         testSetter(TEST_FIND_STATIC);
     }
 
     public void testSetter(int testMode) throws Throwable {
         Lookup lookup = PRIVATE;  // FIXME: test more lookups than this one
-        startTest("unreflectSetter");
-        for (Object[] c : HasFields.CASES) {
+        startTest("testSetter");
+        for (Object[] c : HasFields.testCasesFor(testMode|TEST_SETTER)) {
             boolean positive = (c[1] != Error.class);
             testSetter(positive, lookup, c[0], c[1], testMode);
             if (positive)
                 testSetter(positive, lookup, c[0], c[1], testMode | TEST_NPE);
         }

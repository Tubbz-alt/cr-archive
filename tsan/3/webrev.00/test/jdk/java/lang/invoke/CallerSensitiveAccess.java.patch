diff a/test/jdk/java/lang/invoke/CallerSensitiveAccess.java b/test/jdk/java/lang/invoke/CallerSensitiveAccess.java
--- a/test/jdk/java/lang/invoke/CallerSensitiveAccess.java
+++ b/test/jdk/java/lang/invoke/CallerSensitiveAccess.java
@@ -20,11 +20,11 @@
  * or visit www.oracle.com if you need additional information or have any
  * questions.
  */
 
 /* @test
- * @bug 8196830
+ * @bug 8196830 8235351
  * @modules java.base/jdk.internal.reflect
  * @run testng/othervm --illegal-access=deny CallerSensitiveAccess
  * @summary Check Lookup findVirtual, findStatic and unreflect behavior with
  *          caller sensitive methods with focus on AccessibleObject.setAccessible
  */
@@ -93,10 +93,31 @@
             expectedExceptions = IllegalAccessException.class)
     public void testPublicLookupUnreflect(@NoInjection Method method, String desc) throws Exception {
         MethodHandles.publicLookup().unreflect(method);
     }
 
+    /**
+     * public accessible caller sensitive methods in APIs exported by java.base.
+     */
+    @DataProvider(name = "accessibleCallerSensitiveMethods")
+    static Object[][] accessibleCallerSensitiveMethods() {
+        return callerSensitiveMethods(Object.class.getModule())
+                .filter(m -> Modifier.isPublic(m.getModifiers()))
+                .map(m -> { m.setAccessible(true); return m; })
+                .map(m -> new Object[] { m, shortDescription(m) })
+                .toArray(Object[][]::new);
+    }
+
+    /**
+     * Using publicLookup, attempt to use unreflect to obtain a method handle to a
+     * caller sensitive method.
+     */
+    @Test(dataProvider = "accessibleCallerSensitiveMethods",
+            expectedExceptions = IllegalAccessException.class)
+    public void testLookupUnreflect(@NoInjection Method method, String desc) throws Exception {
+        MethodHandles.publicLookup().unreflect(method);
+    }
 
     // -- Test method handles to setAccessible --
 
     private int aField;
 

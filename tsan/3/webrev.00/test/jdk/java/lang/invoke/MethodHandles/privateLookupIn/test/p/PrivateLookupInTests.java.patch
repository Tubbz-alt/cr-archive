diff a/test/jdk/java/lang/invoke/MethodHandles/privateLookupIn/test/p/PrivateLookupInTests.java b/test/jdk/java/lang/invoke/MethodHandles/privateLookupIn/test/p/PrivateLookupInTests.java
--- a/test/jdk/java/lang/invoke/MethodHandles/privateLookupIn/test/p/PrivateLookupInTests.java
+++ b/test/jdk/java/lang/invoke/MethodHandles/privateLookupIn/test/p/PrivateLookupInTests.java
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2016, 2017, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2016, 2019, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.
@@ -72,31 +72,26 @@
 
     // Invoke MethodHandles.privateLookupIn with a full-power caller
     public void testAllAccessCallerSameModule() throws Throwable {
         Lookup lookup = MethodHandles.privateLookupIn(nonPublicType, MethodHandles.lookup());
         assertTrue(lookup.lookupClass() == nonPublicType);
-        assertTrue(lookup.hasPrivateAccess());
+        assertTrue(lookup.hasFullPrivilegeAccess());
 
         // get obj field
         MethodHandle mh = lookup.findStaticGetter(nonPublicType, "obj", Object.class);
         Object obj = mh.invokeExact();
     }
 
     // Invoke MethodHandles.privateLookupIn with a reduced-power caller
+    @Test(expectedExceptions = {IllegalAccessException.class})
     public void testReducedAccessCallerSameModule() throws Throwable {
         Lookup caller = MethodHandles.lookup().dropLookupMode(PACKAGE);
         assertTrue((caller.lookupModes() & PRIVATE) == 0);
         assertTrue((caller.lookupModes() & PACKAGE) == 0);
         assertTrue((caller.lookupModes() & MODULE) != 0);
 
         Lookup lookup = MethodHandles.privateLookupIn(nonPublicType, caller);
-        assertTrue(lookup.lookupClass() == nonPublicType);
-        assertTrue(lookup.hasPrivateAccess());
-
-        // use it
-        MethodHandle mh = lookup.findStaticGetter(nonPublicType, "obj", Object.class);
-        Object obj = mh.invokeExact();
     }
 
     // Invoke MethodHandles.privateLookupIn with the public lookup as caller
     @Test(expectedExceptions = {IllegalAccessException.class})
     public void testPublicLookupSameModule() throws Exception {
@@ -116,11 +111,12 @@
         thisModule.addReads(clazz.getModule());
         assertTrue(m1.isOpen("p1", thisModule));
 
         Lookup lookup = MethodHandles.privateLookupIn(clazz, MethodHandles.lookup());
         assertTrue(lookup.lookupClass() == clazz);
-        assertTrue(lookup.hasPrivateAccess());
+        assertTrue((lookup.lookupModes() & PRIVATE) != 0);
+        assertFalse(lookup.hasFullPrivilegeAccess());
 
         // get obj field
         MethodHandle mh = lookup.findStaticGetter(clazz, "obj", Object.class);
         Object obj = mh.invokeExact();
     }
@@ -140,11 +136,11 @@
 
         // thisModule reads the unnamed module
         thisModule.addReads(clazz.getModule());
         Lookup lookup = MethodHandles.privateLookupIn(clazz, MethodHandles.lookup());
         assertTrue(lookup.lookupClass() == clazz);
-        assertTrue(lookup.hasPrivateAccess());
+        assertTrue((lookup.lookupModes() & PRIVATE) != 0);
     }
 
     // test does not read m2, m2 opens p2 to test
     @Test(expectedExceptions = {IllegalAccessException.class})
     public void testCallerDoesNotRead() throws Throwable {

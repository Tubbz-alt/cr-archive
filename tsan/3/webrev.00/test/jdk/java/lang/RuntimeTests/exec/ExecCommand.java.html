<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New test/jdk/java/lang/RuntimeTests/exec/ExecCommand.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2013, 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 
 25 /**
 26  * @test
 27  * @bug 8012453 8016046
 28  * @run main/othervm ExecCommand
 29  * @summary workaround for legacy applications with Runtime.getRuntime().exec(String command)
 30  */
 31 
 32 import java.io.BufferedWriter;
 33 import java.io.File;
 34 import java.io.FileNotFoundException;
 35 import java.io.FileWriter;
 36 import java.io.IOException;
 37 import java.nio.file.FileSystems;
 38 import java.nio.file.Files;
 39 import java.security.AccessControlException;
 40 
 41 public class ExecCommand {
 42     static class SecurityMan extends SecurityManager {
 43         public static String unquote(String str)
 44         {
 45             int length = (str == null)
 46                 ? 0
 47                 : str.length();
 48 
 49             if (length &gt; 1
 50                 &amp;&amp; str.charAt(0) == &#39;\&quot;&#39;
 51                 &amp;&amp; str.charAt(length - 1) == &#39;\&quot;&#39;)
 52             {
 53                return str.substring(1, length - 1);
 54             }
 55             return str;
 56         }
 57 
 58         @Override public void checkExec(String cmd) {
 59             String ncmd = (new File(unquote(cmd))).getPath();
 60             if ( ncmd.equals(&quot;.\\Program&quot;)
 61               || ncmd.equals(&quot;\&quot;.\\Program&quot;)
 62               || ncmd.equals(&quot;.\\Program Files\\do.cmd&quot;)
 63               || ncmd.equals(&quot;.\\Program.cmd&quot;)
 64               || ncmd.equals(&quot;cmd&quot;))
 65             {
 66                 return;
 67             }
 68             super.checkExec(cmd);
 69         }
 70 
 71         @Override public void checkDelete(String file) {}
 72         @Override public void checkRead(String file) {}
 73     }
 74 
 75     // Parameters for the Runtime.exec calls
 76     private static final String TEST_RTE_ARG[] = {
 77         &quot;cmd /C dir &gt; dirOut.txt&quot;,
 78         &quot;cmd /C dir &gt; \&quot;.\\Program Files\\dirOut.txt\&quot;&quot;,
 79         &quot;.\\Program Files\\do.cmd&quot;,
 80         &quot;\&quot;.\\Program Files\\doNot.cmd\&quot; arg&quot;,
 81         &quot;\&quot;.\\Program Files\\do.cmd\&quot; arg&quot;,
 82         // compatibility
 83         &quot;\&quot;.\\Program.cmd\&quot; arg&quot;,
 84         &quot;.\\Program.cmd arg&quot;,
 85     };
 86 
 87     private static final String doCmdCopy[] = {
 88         &quot;.\\Program.cmd&quot;,
 89         &quot;.\\Program Files\\doNot.cmd&quot;,
 90         &quot;.\\Program Files\\do.cmd&quot;,
 91     };
 92 
 93     // Golden image for results
 94     private static final String TEST_RTE_GI[][] = {
 95                     //Def Legacy mode, Enforced mode, Set Legacy mode, Set Legacy mode &amp; SM
 96         // [cmd /C dir &gt; dirOut.txt]
 97         new String[]{&quot;Success&quot;,
 98                      &quot;IOException&quot;,  // [cmd /C dir &quot;&gt;&quot; dirOut.txt] no redirection
 99                      &quot;Success&quot;,
100                      &quot;IOException&quot;}, //SM - no legacy mode, bad command
101 
102         // [cmd /C dir &gt; &quot;.\Program Files\dirOut.txt&quot;]
103         new String[]{&quot;Success&quot;,
104                      &quot;IOException&quot;,  // [cmd /C dir &quot;&gt;&quot; &quot;.\Program Files\dirOut.txt&quot;] no redirection
105                      &quot;Success&quot;,
106                      &quot;IOException&quot;}, //SM - no legacy mode, bad command
107 
108         // [.\Program File\do.cmd]
109         new String[]{&quot;Success&quot;,
110                      &quot;IOException&quot;,  // [.\Program] not found
111                      &quot;Success&quot;,
112                      &quot;IOException&quot;}, //SM - no legacy mode [.\Program] - OK
113 
114         // [&quot;.\Program File\doNot.cmd&quot; arg]
115         new String[]{&quot;Success&quot;,
116                      &quot;Success&quot;,
117                      &quot;Success&quot;,
118                      &quot;AccessControlException&quot;}, //SM   - [&quot;.\Program] - OK,
119                                  //     [.\\Program Files\\doNot.cmd] - Fail
120 
121         // [&quot;.\Program File\do.cmd&quot; arg]
122         // AccessControlException
123         new String[]{&quot;Success&quot;,
124                      &quot;Success&quot;,
125                      &quot;Success&quot;,
126                      &quot;Success&quot;}, //SM - [&quot;.\Program] - OK,
127                                  //     [.\\Program Files\\do.cmd] - OK
128 
129         // compatibility
130         new String[]{&quot;Success&quot;, &quot;Success&quot;, &quot;Success&quot;, &quot;Success&quot;}, //[&quot;.\Program.cmd&quot;]
131         new String[]{&quot;Success&quot;, &quot;Success&quot;, &quot;Success&quot;, &quot;Success&quot;}  //[.\Program.cmd]
132     };
133 
134     private static void deleteOut(String path) {
135         try {
136             Files.delete(FileSystems.getDefault().getPath(path));
137         } catch (IOException ex) {
138             //that is OK
139         }
140     }
141     private static void checkOut(String path) throws FileNotFoundException {
142         if (Files.notExists(FileSystems.getDefault().getPath(path)))
143             throw new FileNotFoundException(path);
144     }
145 
146     public static void main(String[] _args) throws Exception {
147         if (!System.getProperty(&quot;os.name&quot;).startsWith(&quot;Windows&quot;)) {
148             return;
149         }
150 
151         // tear up
152         try {
153             new File(&quot;.\\Program Files&quot;).mkdirs();
154             for (int i = 0; i &lt; doCmdCopy.length; ++i) {
155                 try (BufferedWriter outCmd = new BufferedWriter(
156                              new FileWriter(doCmdCopy[i]))) {
157                     outCmd.write(&quot;@echo %1&quot;);
158                 }
159             }
160         } catch (IOException e) {
161             throw new Error(e.getMessage());
162         }
163 
164         // action
165         for (int k = 0; k &lt; 4; ++k) {
166             switch (k) {
167             case 0:
168                 // the &quot;jdk.lang.Process.allowAmbiguousCommands&quot; is undefined
169                 // &quot;true&quot; by default with the legacy verification procedure
170                 break;
171             case 1:
172                 System.setProperty(&quot;jdk.lang.Process.allowAmbiguousCommands&quot;, &quot;false&quot;);
173                 break;
174             case 2:
175                 System.setProperty(&quot;jdk.lang.Process.allowAmbiguousCommands&quot;, &quot;&quot;);
176                 break;
177             case 3:
178                 System.setSecurityManager( new SecurityMan() );
179                 break;
180             }
181             for (int i = 0; i &lt; TEST_RTE_ARG.length; ++i) {
182                 String outRes;
183                 try {
184                     // tear up
185                     switch (i) {
186                     case 0:
187                         // [cmd /C dir &gt; dirOut.txt]
188                         deleteOut(&quot;.\\dirOut.txt&quot;);
189                         break;
190                     case 1:
191                         // [cmd /C dir &gt; &quot;.\Program Files\dirOut.txt&quot;]
192                         deleteOut(&quot;.\\Program Files\\dirOut.txt&quot;);
193                         break;
194                     }
195 
196                     Process exec = Runtime.getRuntime().exec(TEST_RTE_ARG[i]);
197                     exec.waitFor();
198 
199                     //exteded check
200                     switch (i) {
201                     case 0:
202                         // [cmd /C dir &gt; dirOut.txt]
203                         checkOut(&quot;.\\dirOut.txt&quot;);
204                         break;
205                     case 1:
206                         // [cmd /C dir &gt; &quot;.\Program Files\dirOut.txt&quot;]
207                         checkOut(&quot;.\\Program Files\\dirOut.txt&quot;);
208                         break;
209                     }
210                     outRes = &quot;Success&quot;;
211                 } catch (IOException ioe) {
212                     outRes = &quot;IOException: &quot; + ioe.getMessage();
213                 } catch (IllegalArgumentException iae) {
214                     outRes = &quot;IllegalArgumentException: &quot; + iae.getMessage();
215                 } catch (AccessControlException se) {
216                     outRes = &quot;AccessControlException: &quot; + se.getMessage();
217                 }
218 
219                 if (!outRes.startsWith(TEST_RTE_GI[i][k])) {
220                     throw new Error(&quot;Unexpected output! Step&quot; + k + &quot;:&quot; + i
221                                 + &quot;\nArgument: &quot; + TEST_RTE_ARG[i]
222                                 + &quot;\nExpected: &quot; + TEST_RTE_GI[i][k]
223                                 + &quot;\n  Output: &quot; + outRes);
224                 } else {
225                     System.out.println(&quot;RTE OK:&quot; + TEST_RTE_ARG[i]);
226                 }
227             }
228         }
229     }
230 }
    </pre>
  </body>
</html>
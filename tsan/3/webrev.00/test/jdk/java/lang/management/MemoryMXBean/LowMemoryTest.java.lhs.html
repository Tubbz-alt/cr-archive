<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames test/jdk/java/lang/management/MemoryMXBean/LowMemoryTest.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
<a name="1" id="anc1"></a><span class="line-modified">  2  * Copyright (c) 2003, 2018, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 /*
 25  * @test
 26  * @bug     4530538
 27  * @summary Basic unit test of memory management testing:
 28  *          1) setUsageThreshold() and getUsageThreshold()
 29  *          2) test low memory detection on the old generation.
 30  * @author  Mandy Chung
 31  *
 32  * @requires vm.gc == &quot;null&quot;
 33  * @requires vm.opt.ExplicitGCInvokesConcurrent != &quot;true&quot;
 34  * @requires vm.opt.DisableExplicitGC != &quot;true&quot;
 35  * @library /test/lib
 36  *
 37  * @build LowMemoryTest MemoryUtil RunUtil
 38  * @build sun.hotspot.WhiteBox
 39  * @run driver ClassFileInstaller sun.hotspot.WhiteBox sun.hotspot.WhiteBox$WhiteBoxPermission
 40  * @run main/othervm/timeout=600 -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -Xbootclasspath/a:. LowMemoryTest
 41  */
 42 
 43 import java.lang.management.*;
 44 import java.util.*;
 45 import java.util.concurrent.Phaser;
 46 import javax.management.*;
 47 import javax.management.openmbean.CompositeData;
 48 import jdk.test.lib.JDKToolFinder;
 49 import jdk.test.lib.process.ProcessTools;
 50 import jdk.test.lib.Utils;
 51 
 52 import sun.hotspot.code.Compiler;
 53 
 54 public class LowMemoryTest {
 55     private static final MemoryMXBean mm = ManagementFactory.getMemoryMXBean();
 56     private static final List&lt;MemoryPoolMXBean&gt; pools = ManagementFactory.getMemoryPoolMXBeans();
 57     private static final Phaser phaser = new Phaser(2);
 58     private static MemoryPoolMXBean mpool = null;
 59     private static boolean trace = false;
 60     private static boolean testFailed = false;
 61     private static final int NUM_TRIGGERS = 5;
 62     private static final int NUM_CHUNKS = 2;
 63     private static final int YOUNG_GEN_SIZE = 8 * 1024 * 1024;
 64     private static long chunkSize;
 65     private static final String classMain = &quot;LowMemoryTest$TestMain&quot;;
 66 
 67     /**
 68      * Run the test multiple times with different GC versions.
 69      * First with default command line specified by the framework.
 70      * Then with GC versions specified by the test.
 71      */
 72     public static void main(String a[]) throws Throwable {
 73         // Use a low young gen size to ensure that the
 74         // allocated objects are put in the old gen.
 75         final String nmFlag = &quot;-Xmn&quot; + YOUNG_GEN_SIZE;
 76         // Using large pages will change the young gen size,
 77         // make sure we don&#39;t use them for this test.
 78         final String lpFlag = &quot;-XX:-UseLargePages&quot;;
 79         // Prevent G1 from selecting a large heap region size,
 80         // since that would change the young gen size.
 81         final String g1Flag = &quot;-XX:G1HeapRegionSize=1m&quot;;
 82 
 83         // Runs the test collecting subprocess I/O while it&#39;s running.
 84         traceTest(classMain + &quot;, -XX:+UseSerialGC&quot;, nmFlag, lpFlag, &quot;-XX:+UseSerialGC&quot;);
 85         traceTest(classMain + &quot;, -XX:+UseParallelGC&quot;, nmFlag, lpFlag, &quot;-XX:+UseParallelGC&quot;);
 86         traceTest(classMain + &quot;, -XX:+UseG1GC&quot;, nmFlag, lpFlag, &quot;-XX:+UseG1GC&quot;, g1Flag);
<a name="2" id="anc2"></a><span class="line-removed"> 87         if (!Compiler.isGraalEnabled()) { // Graal does not support CMS</span>
<span class="line-removed"> 88             traceTest(classMain + &quot;, -XX:+UseConcMarkSweepGC&quot;, nmFlag, lpFlag, &quot;-XX:+UseConcMarkSweepGC&quot;);</span>
<span class="line-removed"> 89         }</span>
 90     }
 91 
 92     /*
 93      * Creating command-line for running subprocess JVM:
 94      *
 95      * JVM command line is like:
 96      * {test_jdk}/bin/java {defaultopts} -cp {test.class.path} {testopts} main
 97      *
 98      * {defaultopts} are the default java options set by the framework.
 99      *
100      * @param testOpts java options specified by the test.
101      */
102     private static List&lt;String&gt; buildCommandLine(String... testOpts) {
103         List&lt;String&gt; opts = new ArrayList&lt;&gt;();
104         opts.add(JDKToolFinder.getJDKTool(&quot;java&quot;));
105         opts.addAll(Arrays.asList(Utils.getTestJavaOpts()));
106         opts.add(&quot;-cp&quot;);
107         opts.add(System.getProperty(&quot;test.class.path&quot;, &quot;test.class.path&quot;));
108         opts.add(&quot;-Xlog:gc*=debug&quot;);
109         opts.addAll(Arrays.asList(testOpts));
110         opts.add(classMain);
111 
112         return opts;
113     }
114 
115     /**
116      * Runs LowMemoryTest$TestMain with the passed options and redirects subprocess
117      * standard I/O to the current (parent) process. This provides a trace of what
118      * happens in the subprocess while it is runnning (and before it terminates).
119      *
120      * @param prefixName the prefix string for redirected outputs
121      * @param testOpts java options specified by the test.
122      */
123     private static void traceTest(String prefixName,
124                                   String... testOpts)
125                 throws Throwable {
126 
127         // Building command-line
128         List&lt;String&gt; opts = buildCommandLine(testOpts);
129 
130         // We activate all tracing in subprocess
131         opts.add(&quot;trace&quot;);
132 
133         // Launch separate JVM subprocess
134         String[] optsArray = opts.toArray(new String[0]);
135         ProcessBuilder pb = new ProcessBuilder(optsArray);
136         System.out.println(&quot;\n========= Tracing of subprocess &quot; + prefixName + &quot; =========&quot;);
137         Process p = ProcessTools.startProcess(prefixName, pb);
138 
139         // Handling end of subprocess
140         try {
141             int exitCode = p.waitFor();
142             if (exitCode != 0) {
143                 throw new RuntimeException(
144                     &quot;Subprocess unexpected exit value of [&quot; + exitCode + &quot;]. Expected 0.\n&quot;);
145             }
146         } catch (InterruptedException e) {
147             throw new RuntimeException(&quot;Parent process interrupted with exception : \n &quot; + e + &quot; :&quot; );
148         }
149 
150 
151      }
152 
153     private static volatile boolean listenerInvoked = false;
154     static class SensorListener implements NotificationListener {
155         @Override
156         public void handleNotification(Notification notif, Object handback) {
157             String type = notif.getType();
158             if (type.equals(MemoryNotificationInfo.MEMORY_THRESHOLD_EXCEEDED) ||
159                 type.equals(MemoryNotificationInfo.
160                     MEMORY_COLLECTION_THRESHOLD_EXCEEDED)) {
161 
162                 MemoryNotificationInfo minfo = MemoryNotificationInfo.
163                     from((CompositeData) notif.getUserData());
164 
165                 MemoryUtil.printMemoryNotificationInfo(minfo, type);
166                 listenerInvoked = true;
167             }
168         }
169     }
170 
171     static class TestListener implements NotificationListener {
<a name="3" id="anc3"></a><span class="line-removed">172         private boolean isRelaxed = false;</span>
173         private int triggers = 0;
174         private final long[] count = new long[NUM_TRIGGERS * 2];
175         private final long[] usedMemory = new long[NUM_TRIGGERS * 2];
176 
<a name="4" id="anc4"></a><span class="line-removed">177         public TestListener() {</span>
<span class="line-removed">178             isRelaxed = ManagementFactory.getRuntimeMXBean().getInputArguments().contains(&quot;-XX:+UseConcMarkSweepGC&quot;);</span>
<span class="line-removed">179         }</span>
<span class="line-removed">180 </span>
181         @Override
182         public void handleNotification(Notification notif, Object handback) {
183             MemoryNotificationInfo minfo = MemoryNotificationInfo.
184                 from((CompositeData) notif.getUserData());
185             count[triggers] = minfo.getCount();
186             usedMemory[triggers] = minfo.getUsage().getUsed();
187             triggers++;
188         }
189         public void checkResult() throws Exception {
190             if (!checkValue(triggers, NUM_TRIGGERS)) {
191                 throw new RuntimeException(&quot;Unexpected number of triggers = &quot; +
192                     triggers + &quot; but expected to be &quot; + NUM_TRIGGERS);
193             }
194 
195             for (int i = 0; i &lt; triggers; i++) {
196                 if (!checkValue(count[i], i + 1)) {
197                     throw new RuntimeException(&quot;Unexpected count of&quot; +
198                         &quot; notification #&quot; + i +
199                         &quot; count = &quot; + count[i] +
200                         &quot; but expected to be &quot; + (i+1));
201                 }
202                 if (usedMemory[i] &lt; newThreshold) {
203                     throw new RuntimeException(&quot;Used memory = &quot; +
204                         usedMemory[i] + &quot; is less than the threshold = &quot; +
205                         newThreshold);
206                 }
207             }
208         }
209 
210         private boolean checkValue(int value, int target) {
211             return checkValue((long)value, target);
212         }
213 
214         private boolean checkValue(long value, int target) {
<a name="5" id="anc5"></a><span class="line-modified">215             if (!isRelaxed) {</span>
<span class="line-removed">216                 return value == target;</span>
<span class="line-removed">217             } else {</span>
<span class="line-removed">218                 return value &gt;= target;</span>
<span class="line-removed">219             }</span>
220         }
221     }
222 
223     private static long newThreshold;
224 
225     private static class TestMain {
226         public static void main(String args[]) throws Exception {
227             if (args.length &gt; 0 &amp;&amp; args[0].equals(&quot;trace&quot;)) {
228                 trace = true;
229             }
230 
231             // Find the Old generation which supports low memory detection
232             ListIterator iter = pools.listIterator();
233             while (iter.hasNext()) {
234                 MemoryPoolMXBean p = (MemoryPoolMXBean) iter.next();
235                 if (p.getType() == MemoryType.HEAP &amp;&amp;
236                     p.isUsageThresholdSupported()) {
237                     mpool = p;
238                     if (trace) {
239                         System.out.println(&quot;Selected memory pool for low memory &quot; +
240                             &quot;detection.&quot;);
241                         MemoryUtil.printMemoryPool(mpool);
242                     }
243                     break;
244                 }
245             }
246 
247             TestListener listener = new TestListener();
248             SensorListener l2 = new SensorListener();
249             NotificationEmitter emitter = (NotificationEmitter) mm;
250             emitter.addNotificationListener(listener, null, null);
251             emitter.addNotificationListener(l2, null, null);
252 
253             Thread allocator = new AllocatorThread();
254             Thread sweeper = new SweeperThread();
255 
256             // The chunk size needs to be larger than YOUNG_GEN_SIZE,
257             // otherwise we will get intermittent failures when objects
258             // end up in the young gen instead of the old gen.
259             final long epsilon = 1024;
260             chunkSize = YOUNG_GEN_SIZE + epsilon;
261 
262             MemoryUsage mu = mpool.getUsage();
263             newThreshold = mu.getUsed() + (chunkSize * NUM_CHUNKS);
264 
265             // Sanity check. Make sure the new threshold isn&#39;t too large.
266             // Tweak the test if this fails.
267             final long headRoom = chunkSize * 2;
268             final long max = mu.getMax();
269             if (max != -1 &amp;&amp; newThreshold &gt; max - headRoom) {
270                 throw new RuntimeException(&quot;TEST FAILED: newThreshold: &quot; + newThreshold +
271                         &quot; is too near the maximum old gen size: &quot; + max +
272                         &quot; used: &quot; + mu.getUsed() + &quot; headRoom: &quot; + headRoom);
273             }
274 
275             System.out.println(&quot;Setting threshold for &quot; + mpool.getName() +
276                 &quot; from &quot; + mpool.getUsageThreshold() + &quot; to &quot; + newThreshold +
277                 &quot;.  Current used = &quot; + mu.getUsed());
278 
279             mpool.setUsageThreshold(newThreshold);
280 
281             if (mpool.getUsageThreshold() != newThreshold) {
282                 throw new RuntimeException(&quot;TEST FAILED: &quot; +
283                 &quot;Threshold for Memory pool &quot; + mpool.getName() +
284                 &quot;is &quot; + mpool.getUsageThreshold() + &quot; but expected to be&quot; +
285                 newThreshold);
286             }
287 
288 
289             allocator.start();
290             // Force Allocator start first
291             phaser.arriveAndAwaitAdvance();
292             sweeper.start();
293 
294 
295             try {
296                 allocator.join();
297                 // Wait until AllocatorThread&#39;s done
298                 phaser.arriveAndAwaitAdvance();
299                 sweeper.join();
300             } catch (InterruptedException e) {
301                 System.out.println(&quot;Unexpected exception:&quot; + e);
302                 testFailed = true;
303             }
304 
305             listener.checkResult();
306 
307             if (testFailed)
308                 throw new RuntimeException(&quot;TEST FAILED.&quot;);
309 
310             System.out.println(RunUtil.successMessage);
311         }
312     }
313 
314     private static void goSleep(long ms) {
315         try {
316             Thread.sleep(ms);
317         } catch (InterruptedException e) {
318             System.out.println(&quot;Unexpected exception:&quot; + e);
319             testFailed = true;
320         }
321     }
322 
323     private static final List&lt;Object&gt; objectPool = new ArrayList&lt;&gt;();
324     static class AllocatorThread extends Thread {
325         public void doTask() {
326             int iterations = 0;
327             int numElements = (int) (chunkSize / 4); // minimal object size
328             while (!listenerInvoked || mpool.getUsage().getUsed() &lt; mpool.getUsageThreshold()) {
329                 iterations++;
330                 if (trace) {
331                     System.out.println(&quot;   Iteration &quot; + iterations +
332                         &quot;: before allocation &quot; +
333                         mpool.getUsage().getUsed());
334                 }
335 
336                 Object[] o = new Object[numElements];
337                 if (iterations &lt;= NUM_CHUNKS) {
338                     // only hold a reference to the first NUM_CHUNKS
339                     // allocated objects
340                     objectPool.add(o);
341                 }
342 
343                 if (trace) {
344                     System.out.println(&quot;               &quot; +
345                         &quot;  after allocation &quot; +
346                         mpool.getUsage().getUsed());
347                 }
348                 goSleep(100);
349             }
350         }
351         @Override
352         public void run() {
353             for (int i = 1; i &lt;= NUM_TRIGGERS; i++) {
354                 // Sync with SweeperThread&#39;s second phase.
355                 phaser.arriveAndAwaitAdvance();
356                 System.out.println(&quot;AllocatorThread is doing task &quot; + i +
357                     &quot; phase &quot; + phaser.getPhase());
358                 doTask();
359                 // Sync with SweeperThread&#39;s first phase.
360                 phaser.arriveAndAwaitAdvance();
361                 System.out.println(&quot;AllocatorThread done task &quot; + i +
362                     &quot; phase &quot; + phaser.getPhase());
363                 if (testFailed) {
364                     return;
365                 }
366             }
367         }
368     }
369 
370     static class SweeperThread extends Thread {
371         private void doTask() {
372             int iterations = 0;
373             if (trace) {
374                 System.out.println(&quot;SweeperThread clearing allocated objects.&quot;);
375             }
376 
377             for (; mpool.getUsage().getUsed() &gt;=
378                        mpool.getUsageThreshold();) {
379                 // clear all allocated objects and invoke GC
380                 objectPool.clear();
381                 mm.gc();
382 
383                 if (trace) {
384                     iterations++;
385                     System.out.println(&quot;SweeperThread called &quot; + iterations +
386                         &quot; time(s) MemoryMXBean.gc().&quot;);
387                 }
388 
389                 goSleep(100);
390             }
391         }
392 
393         @Override
394         public void run() {
395             for (int i = 1; i &lt;= NUM_TRIGGERS; i++) {
396                 // Sync with AllocatorThread&#39;s first phase.
397                 phaser.arriveAndAwaitAdvance();
398                 System.out.println(&quot;SweeperThread is doing task &quot; + i +
399                     &quot; phase &quot; + phaser.getPhase());
400 
401                 doTask();
402 
403                 listenerInvoked = false;
404 
405                 // Sync with AllocatorThread&#39;s second phase.
406                 phaser.arriveAndAwaitAdvance();
407                 System.out.println(&quot;SweeperThread done task &quot; + i +
408                     &quot; phase &quot; + phaser.getPhase());
409                 if (testFailed) return;
410             }
411         }
412     }
413 }
<a name="6" id="anc6"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="6" type="hidden" />
</body>
</html>
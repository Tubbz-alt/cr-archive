<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames test/jdk/java/lang/management/MemoryMXBean/ResetPeakMemoryUsage.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
<a name="1" id="anc1"></a><span class="line-modified">  2  * Copyright (c) 2003, 2018, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 /*
 25  * The -XX:MarkSweepAlwaysCompactCount=1 argument below makes sure serial gc
 26  * compacts the heap at every full gc so that the usage is correctly updated.
 27  */
 28 
 29 /*
 30  * @test
 31  * @bug     4892507
 32  * @summary Basic Test for MemoryPool.resetPeakUsage()
 33  * @author  Mandy Chung
 34  *
 35  * @requires vm.opt.ExplicitGCInvokesConcurrent != &quot;true&quot;
 36  * @requires vm.opt.DisableExplicitGC != &quot;true&quot;
 37  * @library /test/lib
 38  * @modules jdk.management
 39  *
 40  * @build ResetPeakMemoryUsage MemoryUtil RunUtil
 41  * @build sun.hotspot.WhiteBox
 42  * @run driver ClassFileInstaller sun.hotspot.WhiteBox sun.hotspot.WhiteBox$WhiteBoxPermission
 43  * @run main/othervm -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -Xbootclasspath/a:. ResetPeakMemoryUsage
 44  */
 45 
 46 import java.lang.management.*;
 47 import java.lang.ref.WeakReference;
 48 import java.util.*;
 49 
 50 import sun.hotspot.code.Compiler;
 51 
 52 public class ResetPeakMemoryUsage {
 53     private static MemoryMXBean mbean = ManagementFactory.getMemoryMXBean();
 54     // make public so that it can&#39;t be optimized away easily
 55     public static Object[] obj;
 56 
 57     /**
 58      * Run the test multiple times with different GC versions.
 59      * First with default command line specified by the framework.
 60      * Then with all GC versions specified by the test.
 61      */
 62     public static void main(String a[]) throws Throwable {
 63         final String main = &quot;ResetPeakMemoryUsage$TestMain&quot;;
 64         final String ms = &quot;-Xms256m&quot;;
 65         final String mn = &quot;-Xmn8m&quot;;
<a name="2" id="anc2"></a><span class="line-modified"> 66         if (!Compiler.isGraalEnabled()) { // Graal does not support CMS</span>
<span class="line-removed"> 67             RunUtil.runTestClearGcOpts(main, ms, mn, &quot;-XX:+UseConcMarkSweepGC&quot;);</span>
<span class="line-removed"> 68         }</span>
 69         RunUtil.runTestClearGcOpts(main, ms, mn, &quot;-XX:+UseParallelGC&quot;);
 70         RunUtil.runTestClearGcOpts(main, ms, mn, &quot;-XX:+UseG1GC&quot;, &quot;-XX:G1HeapRegionSize=1m&quot;);
 71         RunUtil.runTestClearGcOpts(main, ms, mn, &quot;-XX:+UseSerialGC&quot;,
 72                 &quot;-XX:MarkSweepAlwaysCompactCount=1&quot;);
 73     }
 74 
 75     private static class TestMain {
 76         public static void main(String[] argv) {
 77             List pools = ManagementFactory.getMemoryPoolMXBeans();
 78             ListIterator iter = pools.listIterator();
 79             boolean found = false;
 80             while (iter.hasNext()) {
 81                 MemoryPoolMXBean p = (MemoryPoolMXBean) iter.next();
 82                 // only check heap pools that support usage threshold
 83                 // this is typically only the old generation space
 84                 // since the other spaces are expected to get filled up
 85                 if (p.getType() == MemoryType.HEAP &amp;&amp;
 86                     p.isUsageThresholdSupported())
 87                 {
 88                     found = true;
 89                     testPool(p);
 90                 }
 91             }
 92             if (!found) {
 93                 throw new RuntimeException(&quot;No heap pool found&quot;);
 94             }
 95         }
 96     }
 97 
 98     private static void testPool(MemoryPoolMXBean mpool) {
 99         System.out.println(&quot;Selected memory pool: &quot;);
100         MemoryUtil.printMemoryPool(mpool);
101 
102         MemoryUsage usage0 = mpool.getUsage();
103         MemoryUsage peak0 = mpool.getPeakUsage();
104 
105         // use a size that is larger than the young generation and G1 regions
106         // to force the array into the old gen
107         int largeArraySize = 9 * 1000 * 1000;
108 
109         System.out.println(&quot;Before big object array (of size &quot;+largeArraySize+&quot;) is allocated: &quot;);
110         printMemoryUsage(usage0, peak0);
111 
112         obj = new Object[largeArraySize];
113         WeakReference&lt;Object&gt; weakRef = new WeakReference&lt;&gt;(obj);
114 
115         MemoryUsage usage1 = mpool.getUsage();
116         MemoryUsage peak1 = mpool.getPeakUsage();
117         System.out.println(&quot;After the object is allocated: &quot;);
118         printMemoryUsage(usage1, peak1);
119 
120         if (usage1.getUsed() &lt;= usage0.getUsed()) {
121             throw new RuntimeException(
122                 formatSize(&quot;Before allocation: used&quot;, usage0.getUsed()) +
123                 &quot; expected to be &lt; &quot; +
124                 formatSize(&quot;After allocation: used&quot;, usage1.getUsed()));
125         }
126 
127         if (peak1.getUsed() &lt;= peak0.getUsed()) {
128             throw new RuntimeException(
129                 formatSize(&quot;Before allocation: peak&quot;, peak0.getUsed()) +
130                 &quot; expected to be &lt; &quot; +
131                 formatSize(&quot;After allocation: peak&quot;, peak1.getUsed()));
132         }
133 
134 
135         // The object is now garbage and do a GC
136         // memory usage should drop
137         obj = null;
138 
139         //This will cause sure shot GC unlike Runtime.gc() invoked by mbean.gc()
140         while(weakRef.get() != null) {
141             mbean.gc();
142         }
143 
144         MemoryUsage usage2 = mpool.getUsage();
145         MemoryUsage peak2 = mpool.getPeakUsage();
146         System.out.println(&quot;After GC: &quot;);
147         printMemoryUsage(usage2, peak2);
148 
149         if (usage2.getUsed() &gt;= usage1.getUsed()) {
150             throw new RuntimeException(
151                 formatSize(&quot;Before GC: used&quot;, usage1.getUsed()) + &quot; &quot; +
152                 &quot; expected to be &gt; &quot; +
153                 formatSize(&quot;After GC: used&quot;, usage2.getUsed()));
154         }
155 
156         mpool.resetPeakUsage();
157 
158         MemoryUsage usage3 = mpool.getUsage();
159         MemoryUsage peak3 = mpool.getPeakUsage();
160         System.out.println(&quot;After resetPeakUsage: &quot;);
161         printMemoryUsage(usage3, peak3);
162 
163         if (peak3.getUsed() != usage3.getUsed()) {
164             throw new RuntimeException(
165                 formatSize(&quot;After resetting peak: peak&quot;, peak3.getUsed()) + &quot; &quot; +
166                 &quot; expected to be equal to &quot; +
167                 formatSize(&quot;current used&quot;, usage3.getUsed()));
168         }
169 
170         if (peak3.getUsed() &gt;= peak2.getUsed()) {
171             throw new RuntimeException(
172                 formatSize(&quot;After resetting peak: peak&quot;, peak3.getUsed()) + &quot; &quot; +
173                 &quot; expected to be &lt; &quot; +
174                 formatSize(&quot;previous peak&quot;, peak2.getUsed()));
175         }
176 
177         System.out.println(RunUtil.successMessage);
178     }
179 
180     private static String INDENT = &quot;    &quot;;
181     private static void printMemoryUsage(MemoryUsage current, MemoryUsage peak) {
182         System.out.println(&quot;Current Usage: &quot;);
183         MemoryUtil.printMemoryUsage(current);
184         System.out.println(&quot;Peak Usage: &quot;);
185         MemoryUtil.printMemoryUsage(peak);
186 
187     }
188     private static String formatSize(String name, long value) {
189         StringBuffer buf = new StringBuffer(name + &quot; = &quot; + value);
190         if (value &gt; 0) {
191             buf.append(&quot; (&quot; + (value &gt;&gt; 10) + &quot;K)&quot;);
192         }
193         return buf.toString();
194     }
195 }
<a name="3" id="anc3"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="3" type="hidden" />
</body>
</html>
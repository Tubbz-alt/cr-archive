<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff test/jdk/java/lang/ProcessBuilder/Basic.java</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
<body>
<center><a href="../Math/ExactArithTests.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="SecurityManagerClinit.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>test/jdk/java/lang/ProcessBuilder/Basic.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 2003, 2018, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  */
  23 
  24 /*
  25  * @test
  26  * @bug 4199068 4738465 4937983 4930681 4926230 4931433 4932663 4986689
  27  *      5026830 5023243 5070673 4052517 4811767 6192449 6397034 6413313
  28  *      6464154 6523983 6206031 4960438 6631352 6631966 6850957 6850958
  29  *      4947220 7018606 7034570 4244896 5049299 8003488 8054494 8058464
<span class="line-modified">  30  *      8067796</span>
  31  * @key intermittent
  32  * @summary Basic tests for Process and Environment Variable code
  33  * @modules java.base/java.lang:open
  34  * @run main/othervm/timeout=300 Basic
  35  * @run main/othervm/timeout=300 -Djdk.lang.Process.launchMechanism=fork Basic
  36  * @author Martin Buchholz
  37  */
  38 
  39 /*
  40  * @test
  41  * @modules java.base/java.lang:open
  42  * @requires (os.family == &quot;linux&quot;)
  43  * @run main/othervm/timeout=300 -Djdk.lang.Process.launchMechanism=posix_spawn Basic
  44  */
  45 
  46 import java.lang.ProcessBuilder.Redirect;
  47 import java.lang.ProcessHandle;
  48 import static java.lang.ProcessBuilder.Redirect.*;
  49 
  50 import java.io.*;
</pre>
<hr />
<pre>
2094                 childArgs.add(&quot;sleep&quot;);
2095                 final byte[] bytes = new byte[10];
2096                 final Process p = new ProcessBuilder(childArgs).start();
2097                 final CountDownLatch latch = new CountDownLatch(1);
2098                 final InputStream s;
2099                 switch (action &amp; 0x1) {
2100                     case 0: s = p.getInputStream(); break;
2101                     case 1: s = p.getErrorStream(); break;
2102                     default: throw new Error();
2103                 }
2104                 final Thread thread = new Thread() {
2105                     public void run() {
2106                         try {
2107                             int r;
2108                             latch.countDown();
2109                             switch (action &amp; 0x2) {
2110                                 case 0: r = s.read(); break;
2111                                 case 2: r = s.read(bytes); break;
2112                                 default: throw new Error();
2113                             }













2114                             equal(-1, r);
2115                         } catch (IOException ioe) {
2116                             if (!ioe.getMessage().equals(&quot;Stream closed&quot;)) {
2117                                 // BufferedInputStream may throw IOE(&quot;Stream closed&quot;).
2118                                 unexpected(ioe);
2119                             }
2120                         } catch (Throwable t) { unexpected(t); }}};
2121 
2122                 thread.start();
2123                 latch.await();
2124                 Thread.sleep(10);
2125 
2126                 String os = System.getProperty(&quot;os.name&quot;);
2127                 if (os.equalsIgnoreCase(&quot;Solaris&quot;) ||
2128                     os.equalsIgnoreCase(&quot;SunOS&quot;))
2129                 {
2130                     final Object deferred;
2131                     Class&lt;?&gt; c = s.getClass();
2132                     if (c.getName().equals(
2133                         &quot;java.lang.ProcessImpl$DeferredCloseInputStream&quot;))
</pre>
<hr />
<pre>
2170                 &amp;&amp; new File(&quot;/bin/sleep&quot;).exists()) {
2171                 // Notice that we only destroy the process created by us (i.e.
2172                 // our child) but not our grandchild (i.e. &#39;/bin/sleep&#39;). So
2173                 // pay attention that the grandchild doesn&#39;t run too long to
2174                 // avoid polluting the process space with useless processes.
2175                 // Running the grandchild for 60s should be more than enough.
2176                 final String[] cmd = { &quot;/bin/bash&quot;, &quot;-c&quot;, &quot;(/bin/sleep 60)&quot; };
2177                 final String[] cmdkill = { &quot;/bin/bash&quot;, &quot;-c&quot;, &quot;(/usr/bin/pkill -f \&quot;sleep 60\&quot;)&quot; };
2178                 final ProcessBuilder pb = new ProcessBuilder(cmd);
2179                 final Process p = pb.start();
2180                 final InputStream stdout = p.getInputStream();
2181                 final InputStream stderr = p.getErrorStream();
2182                 final OutputStream stdin = p.getOutputStream();
2183                 final Thread reader = new Thread() {
2184                     public void run() {
2185                         try { stdout.read(); }
2186                         catch (IOException e) {
2187                             // Check that reader failed because stream was
2188                             // asynchronously closed.
2189                             // e.printStackTrace();

2190                             if (EnglishUnix.is() &amp;&amp;
<span class="line-modified">2191                                 ! (e.getMessage().matches(&quot;.*Bad file.*&quot;)))</span>

2192                                 unexpected(e);
2193                         }
2194                         catch (Throwable t) { unexpected(t); }}};
2195                 reader.setDaemon(true);
2196                 reader.start();
2197                 Thread.sleep(100);
2198                 p.destroy();
2199                 check(p.waitFor() != 0);
2200                 check(p.exitValue() != 0);
2201                 // Subprocess is now dead, but file descriptors remain open.
2202                 // Make sure the test will fail if we don&#39;t manage to close
2203                 // the open streams within 30 seconds. Notice that this time
2204                 // must be shorter than the sleep time of the grandchild.
2205                 Timer t = new Timer(&quot;test/java/lang/ProcessBuilder/Basic.java process reaper&quot;, true);
2206                 t.schedule(new TimerTask() {
2207                       public void run() {
2208                           fail(&quot;Subprocesses which create subprocesses of &quot; +
2209                                &quot;their own caused the parent to hang while &quot; +
2210                                &quot;waiting for file descriptors to be closed.&quot;);
2211                           System.exit(-1);
</pre>
<hr />
<pre>
2583                 fail(&quot;Test failed: waitFor didn&#39;t take long enough&quot;);
2584 
2585             p.destroy();
2586 
2587             p.waitFor(1000, TimeUnit.MILLISECONDS);
2588         } catch (Throwable t) { unexpected(t); }
2589     }
2590 
2591     static void closeStreams(Process p) {
2592         try {
2593             p.getOutputStream().close();
2594             p.getInputStream().close();
2595             p.getErrorStream().close();
2596         } catch (Throwable t) { unexpected(t); }
2597     }
2598 
2599     //----------------------------------------------------------------
2600     // A Policy class designed to make permissions fiddling very easy.
2601     //----------------------------------------------------------------
2602     private static class Policy extends java.security.Policy {


2603         private Permissions perms;
2604 
2605         public void setPermissions(Permission...permissions) {
2606             perms = new Permissions();
2607             for (Permission permission : permissions)
2608                 perms.add(permission);
2609         }
2610 
2611         public Policy() { setPermissions(/* Nothing */); }
2612 
2613         public PermissionCollection getPermissions(CodeSource cs) {
2614             return perms;
2615         }
2616 
2617         public PermissionCollection getPermissions(ProtectionDomain pd) {
2618             return perms;
2619         }
2620 
2621         public boolean implies(ProtectionDomain pd, Permission p) {
<span class="line-modified">2622             return perms.implies(p);</span>
2623         }
2624 
2625         public void refresh() {}
2626     }
2627 
2628     private static class StreamAccumulator extends Thread {
2629         private final InputStream is;
2630         private final StringBuilder sb = new StringBuilder();
2631         private Throwable throwable = null;
2632 
2633         public String result () throws Throwable {
2634             if (throwable != null)
2635                 throw throwable;
2636             return sb.toString();
2637         }
2638 
2639         StreamAccumulator (InputStream is) {
2640             this.is = is;
2641         }
2642 
</pre>
</td>
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 2003, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  */
  23 
  24 /*
  25  * @test
  26  * @bug 4199068 4738465 4937983 4930681 4926230 4931433 4932663 4986689
  27  *      5026830 5023243 5070673 4052517 4811767 6192449 6397034 6413313
  28  *      6464154 6523983 6206031 4960438 6631352 6631966 6850957 6850958
  29  *      4947220 7018606 7034570 4244896 5049299 8003488 8054494 8058464
<span class="line-modified">  30  *      8067796 8224905</span>
  31  * @key intermittent
  32  * @summary Basic tests for Process and Environment Variable code
  33  * @modules java.base/java.lang:open
  34  * @run main/othervm/timeout=300 Basic
  35  * @run main/othervm/timeout=300 -Djdk.lang.Process.launchMechanism=fork Basic
  36  * @author Martin Buchholz
  37  */
  38 
  39 /*
  40  * @test
  41  * @modules java.base/java.lang:open
  42  * @requires (os.family == &quot;linux&quot;)
  43  * @run main/othervm/timeout=300 -Djdk.lang.Process.launchMechanism=posix_spawn Basic
  44  */
  45 
  46 import java.lang.ProcessBuilder.Redirect;
  47 import java.lang.ProcessHandle;
  48 import static java.lang.ProcessBuilder.Redirect.*;
  49 
  50 import java.io.*;
</pre>
<hr />
<pre>
2094                 childArgs.add(&quot;sleep&quot;);
2095                 final byte[] bytes = new byte[10];
2096                 final Process p = new ProcessBuilder(childArgs).start();
2097                 final CountDownLatch latch = new CountDownLatch(1);
2098                 final InputStream s;
2099                 switch (action &amp; 0x1) {
2100                     case 0: s = p.getInputStream(); break;
2101                     case 1: s = p.getErrorStream(); break;
2102                     default: throw new Error();
2103                 }
2104                 final Thread thread = new Thread() {
2105                     public void run() {
2106                         try {
2107                             int r;
2108                             latch.countDown();
2109                             switch (action &amp; 0x2) {
2110                                 case 0: r = s.read(); break;
2111                                 case 2: r = s.read(bytes); break;
2112                                 default: throw new Error();
2113                             }
<span class="line-added">2114                             if (r &gt;= 0) {</span>
<span class="line-added">2115                                 // The child sent unexpected output; print it to diagnose</span>
<span class="line-added">2116                                 System.out.println(&quot;Unexpected child output:&quot;);</span>
<span class="line-added">2117                                 if ((action &amp; 0x2) == 0) {</span>
<span class="line-added">2118                                     System.out.write(r);    // Single character</span>
<span class="line-added">2119 </span>
<span class="line-added">2120                                 } else {</span>
<span class="line-added">2121                                     System.out.write(bytes, 0, r);</span>
<span class="line-added">2122                                 }</span>
<span class="line-added">2123                                 for (int c = s.read(); c &gt;= 0; c = s.read())</span>
<span class="line-added">2124                                     System.out.write(c);</span>
<span class="line-added">2125                                 System.out.println(&quot;\nEND Child output.&quot;);</span>
<span class="line-added">2126                             }</span>
2127                             equal(-1, r);
2128                         } catch (IOException ioe) {
2129                             if (!ioe.getMessage().equals(&quot;Stream closed&quot;)) {
2130                                 // BufferedInputStream may throw IOE(&quot;Stream closed&quot;).
2131                                 unexpected(ioe);
2132                             }
2133                         } catch (Throwable t) { unexpected(t); }}};
2134 
2135                 thread.start();
2136                 latch.await();
2137                 Thread.sleep(10);
2138 
2139                 String os = System.getProperty(&quot;os.name&quot;);
2140                 if (os.equalsIgnoreCase(&quot;Solaris&quot;) ||
2141                     os.equalsIgnoreCase(&quot;SunOS&quot;))
2142                 {
2143                     final Object deferred;
2144                     Class&lt;?&gt; c = s.getClass();
2145                     if (c.getName().equals(
2146                         &quot;java.lang.ProcessImpl$DeferredCloseInputStream&quot;))
</pre>
<hr />
<pre>
2183                 &amp;&amp; new File(&quot;/bin/sleep&quot;).exists()) {
2184                 // Notice that we only destroy the process created by us (i.e.
2185                 // our child) but not our grandchild (i.e. &#39;/bin/sleep&#39;). So
2186                 // pay attention that the grandchild doesn&#39;t run too long to
2187                 // avoid polluting the process space with useless processes.
2188                 // Running the grandchild for 60s should be more than enough.
2189                 final String[] cmd = { &quot;/bin/bash&quot;, &quot;-c&quot;, &quot;(/bin/sleep 60)&quot; };
2190                 final String[] cmdkill = { &quot;/bin/bash&quot;, &quot;-c&quot;, &quot;(/usr/bin/pkill -f \&quot;sleep 60\&quot;)&quot; };
2191                 final ProcessBuilder pb = new ProcessBuilder(cmd);
2192                 final Process p = pb.start();
2193                 final InputStream stdout = p.getInputStream();
2194                 final InputStream stderr = p.getErrorStream();
2195                 final OutputStream stdin = p.getOutputStream();
2196                 final Thread reader = new Thread() {
2197                     public void run() {
2198                         try { stdout.read(); }
2199                         catch (IOException e) {
2200                             // Check that reader failed because stream was
2201                             // asynchronously closed.
2202                             // e.printStackTrace();
<span class="line-added">2203                             String msg = e.getMessage();</span>
2204                             if (EnglishUnix.is() &amp;&amp;
<span class="line-modified">2205                                 ! (msg.matches(&quot;.*Bad file.*&quot;) ||</span>
<span class="line-added">2206                                         msg.matches(&quot;.*Stream closed.*&quot;)))</span>
2207                                 unexpected(e);
2208                         }
2209                         catch (Throwable t) { unexpected(t); }}};
2210                 reader.setDaemon(true);
2211                 reader.start();
2212                 Thread.sleep(100);
2213                 p.destroy();
2214                 check(p.waitFor() != 0);
2215                 check(p.exitValue() != 0);
2216                 // Subprocess is now dead, but file descriptors remain open.
2217                 // Make sure the test will fail if we don&#39;t manage to close
2218                 // the open streams within 30 seconds. Notice that this time
2219                 // must be shorter than the sleep time of the grandchild.
2220                 Timer t = new Timer(&quot;test/java/lang/ProcessBuilder/Basic.java process reaper&quot;, true);
2221                 t.schedule(new TimerTask() {
2222                       public void run() {
2223                           fail(&quot;Subprocesses which create subprocesses of &quot; +
2224                                &quot;their own caused the parent to hang while &quot; +
2225                                &quot;waiting for file descriptors to be closed.&quot;);
2226                           System.exit(-1);
</pre>
<hr />
<pre>
2598                 fail(&quot;Test failed: waitFor didn&#39;t take long enough&quot;);
2599 
2600             p.destroy();
2601 
2602             p.waitFor(1000, TimeUnit.MILLISECONDS);
2603         } catch (Throwable t) { unexpected(t); }
2604     }
2605 
2606     static void closeStreams(Process p) {
2607         try {
2608             p.getOutputStream().close();
2609             p.getInputStream().close();
2610             p.getErrorStream().close();
2611         } catch (Throwable t) { unexpected(t); }
2612     }
2613 
2614     //----------------------------------------------------------------
2615     // A Policy class designed to make permissions fiddling very easy.
2616     //----------------------------------------------------------------
2617     private static class Policy extends java.security.Policy {
<span class="line-added">2618         static final java.security.Policy DEFAULT_POLICY = java.security.Policy.getPolicy();</span>
<span class="line-added">2619 </span>
2620         private Permissions perms;
2621 
2622         public void setPermissions(Permission...permissions) {
2623             perms = new Permissions();
2624             for (Permission permission : permissions)
2625                 perms.add(permission);
2626         }
2627 
2628         public Policy() { setPermissions(/* Nothing */); }
2629 
2630         public PermissionCollection getPermissions(CodeSource cs) {
2631             return perms;
2632         }
2633 
2634         public PermissionCollection getPermissions(ProtectionDomain pd) {
2635             return perms;
2636         }
2637 
2638         public boolean implies(ProtectionDomain pd, Permission p) {
<span class="line-modified">2639             return perms.implies(p) || DEFAULT_POLICY.implies(pd, p);</span>
2640         }
2641 
2642         public void refresh() {}
2643     }
2644 
2645     private static class StreamAccumulator extends Thread {
2646         private final InputStream is;
2647         private final StringBuilder sb = new StringBuilder();
2648         private Throwable throwable = null;
2649 
2650         public String result () throws Throwable {
2651             if (throwable != null)
2652                 throw throwable;
2653             return sb.toString();
2654         }
2655 
2656         StreamAccumulator (InputStream is) {
2657             this.is = is;
2658         }
2659 
</pre>
</td>
</tr>
</table>
<center><a href="../Math/ExactArithTests.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="SecurityManagerClinit.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New test/jdk/java/lang/annotation/loaderLeak/Main.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2004, 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 /*
 25  * @test
 26  * @bug 5040740
 27  * @summary annotations cause memory leak
 28  * @author gafter
 29  *
 30  * @run shell LoaderLeak.sh
 31  */
 32 
 33 import java.net.*;
 34 import java.lang.ref.*;
 35 import java.util.*;
 36 import java.io.*;
 37 
 38 public class Main {
 39     public static void main(String[] args) throws Exception {
 40         for (int i=0; i&lt;100; i++)
 41             doTest(args.length != 0);
 42     }
 43 
 44     static void doTest(boolean readAnn) throws Exception {
 45         // URL classes = new URL(&quot;file://&quot; + System.getProperty(&quot;user.dir&quot;) + &quot;/classes&quot;);
 46         // URL[] path = { classes };
 47         // URLClassLoader loader = new URLClassLoader(path);
 48         ClassLoader loader = new SimpleClassLoader();
 49         WeakReference&lt;Class&lt;?&gt;&gt; c = new WeakReference(loader.loadClass(&quot;C&quot;));
 50         if (c.get() == null) throw new AssertionError();
 51         if (c.get().getClassLoader() != loader) throw new AssertionError();
 52         if (readAnn) System.out.println(c.get().getAnnotations()[0]);
 53         if (c.get() == null) throw new AssertionError();
 54         System.gc();
 55         System.gc();
 56         if (c.get() == null) throw new AssertionError();
 57         System.gc();
 58         System.gc();
 59         Reference.reachabilityFence(loader);
 60         loader = null;
 61 
 62         // Might require multiple calls to System.gc() for weak-references
 63         // processing to be complete. If the weak-reference is not cleared as
 64         // expected we will hang here until timed out by the test harness.
 65         while (true) {
 66             System.gc();
 67             Thread.sleep(20);
 68             if (c.get() == null) {
 69                 break;
 70             }
 71         }
 72     }
 73 }
 74 
 75 class SimpleClassLoader extends ClassLoader {
 76     private Hashtable classes = new Hashtable();
 77 
 78     public SimpleClassLoader() {
 79     }
 80     private byte getClassImplFromDataBase(String className)[] {
 81         byte result[];
 82         try {
 83             FileInputStream fi = new FileInputStream(&quot;classes/&quot;+className+&quot;.class&quot;);
 84             result = new byte[fi.available()];
 85             fi.read(result);
 86             return result;
 87         } catch (Exception e) {
 88 
 89             /*
 90              * If we caught an exception, either the class wasnt found or it
 91              * was unreadable by our process.
 92              */
 93             return null;
 94         }
 95     }
 96     public Class loadClass(String className) throws ClassNotFoundException {
 97         return (loadClass(className, true));
 98     }
 99     public synchronized Class loadClass(String className, boolean resolveIt)
100         throws ClassNotFoundException {
101         Class result;
102         byte  classData[];
103 
104         /* Check our local cache of classes */
105         result = (Class)classes.get(className);
106         if (result != null) {
107             return result;
108         }
109 
110         /* Check with the primordial class loader */
111         try {
112             result = super.findSystemClass(className);
113             return result;
114         } catch (ClassNotFoundException e) {
115         }
116 
117         /* Try to load it from our repository */
118         classData = getClassImplFromDataBase(className);
119         if (classData == null) {
120             throw new ClassNotFoundException();
121         }
122 
123         /* Define it (parse the class file) */
124         result = defineClass(classData, 0, classData.length);
125         if (result == null) {
126             throw new ClassFormatError();
127         }
128 
129         if (resolveIt) {
130             resolveClass(result);
131         }
132 
133         classes.put(className, result);
134         return result;
135     }
136 }
    </pre>
  </body>
</html>
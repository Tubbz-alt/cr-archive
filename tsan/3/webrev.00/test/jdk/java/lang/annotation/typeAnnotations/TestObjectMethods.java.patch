diff a/test/jdk/java/lang/annotation/typeAnnotations/TestObjectMethods.java b/test/jdk/java/lang/annotation/typeAnnotations/TestObjectMethods.java
--- a/test/jdk/java/lang/annotation/typeAnnotations/TestObjectMethods.java
+++ b/test/jdk/java/lang/annotation/typeAnnotations/TestObjectMethods.java
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2018, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2018, 2019, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.
@@ -21,11 +21,11 @@
  * questions.
  */
 
 /*
  * @test
- * @bug 8058202 8212081
+ * @bug 8058202 8212081 8224012
  * @summary Test java.lang.Object methods on AnnotatedType objects.
  */
 
 import java.lang.annotation.*;
 import java.lang.reflect.*;
@@ -71,10 +71,12 @@
         testGetAnnotations(TypeHost.class, false);
         testGetAnnotations(AnnotatedTypeHost.class, true);
 
         testWildcards();
 
+        testFbounds();
+
         if (errors > 0) {
             throw new RuntimeException(errors + " errors");
         }
     }
 
@@ -173,11 +175,11 @@
                                    "\n\n");
             }
         }
     }
 
-    private static final Pattern annotationRegex = Pattern.compile("@TestObjectMethods\\$AnnotType\\(value=(\\p{Digit})+\\)");
+    private static final Pattern annotationRegex = Pattern.compile("@TestObjectMethods\\$AnnotType\\((\\p{Digit})+\\)");
 
     static void testGetAnnotations(Class<?> clazz, boolean annotationsExpectedOnMethods) {
         System.err.println("Testing getAnnotations on methods of class " + clazz.getName());
         Method[] methods = clazz.getDeclaredMethods();
         for (Method m : methods) {
@@ -312,10 +314,27 @@
         } catch (Exception e) {
             throw new RuntimeException(e);
         }
     }
 
+    static void testFbounds() {
+        // Make sure equals and hashCode work fine for a type
+        // involving an F-bound, in particular Comparable<E> in
+        // java.lang.Enum:
+        //
+        // class Enum<E extends Enum<E>>
+        // implements Constable, Comparable<E>, Serializable
+
+        AnnotatedType[] types = Enum.class.getAnnotatedInterfaces();
+
+        for (int i = 0; i < types.length; i ++) {
+            for (int j = 0; j < types.length; j ++) {
+                checkTypesForEquality(types[i], types[j], i == j);
+            }
+        }
+    }
+
     // The TypeHost and AnnotatedTypeHost classes declare methods with
     // the same name and signatures but with the AnnotatedTypeHost
     // methods having annotations on their return type, where
     // possible.
 

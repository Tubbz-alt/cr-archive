<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff test/jdk/java/lang/annotation/typeAnnotations/TestObjectMethods.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
<body>
<center><a href="TestConstructorParameterTypeAnnotations.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="../../constant/ClassDescTest.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>test/jdk/java/lang/annotation/typeAnnotations/TestObjectMethods.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2018, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 /*
 25  * @test
<span class="line-modified"> 26  * @bug 8058202 8212081</span>
 27  * @summary Test java.lang.Object methods on AnnotatedType objects.
 28  */
 29 
 30 import java.lang.annotation.*;
 31 import java.lang.reflect.*;
 32 import java.util.*;
 33 import java.util.regex.*;
 34 
 35 /**
 36  * Test toString, equals, and hashCode on various AnnotatedType objects.
 37  */
 38 
 39 public class TestObjectMethods {
 40     private static int errors = 0;
 41 
 42     /*
 43      * There are various subtypes of AnnotatedType implementations:
 44      *
 45      * AnnotatedType
 46      * AnnotatedArrayType
</pre>
<hr />
<pre>
 56      * well.
 57      */
 58     public static void main(String... args) {
 59         Class&lt;?&gt;[] testClasses = {TypeHost.class, AnnotatedTypeHost.class};
 60 
 61         for (Class&lt;?&gt; clazz : testClasses) {
 62             testEqualsReflexivity(clazz);
 63             testEquals(clazz);
 64         }
 65 
 66         testToString(TypeHost.class);
 67         testToString(AnnotatedTypeHost.class);
 68 
 69         testAnnotationsMatterForEquals(TypeHost.class, AnnotatedTypeHost.class);
 70 
 71         testGetAnnotations(TypeHost.class, false);
 72         testGetAnnotations(AnnotatedTypeHost.class, true);
 73 
 74         testWildcards();
 75 


 76         if (errors &gt; 0) {
 77             throw new RuntimeException(errors + &quot; errors&quot;);
 78         }
 79     }
 80 
 81     /*
 82      * For non-array types, verify toString version of the annotated
 83      * type ends with the same string as the generic type.
 84      */
 85     static void testToString(Class&lt;?&gt; clazz) {
 86         System.err.println(&quot;Testing toString on methods of class &quot; + clazz.getName());
 87         Method[] methods = clazz.getDeclaredMethods();
 88         for (Method m : methods) {
 89             // Expected information about the type annotations stored
 90             // in a *declaration* annotation.
 91             AnnotTypeInfo annotTypeInfo = m.getAnnotation(AnnotTypeInfo.class);
 92             int expectedAnnotCount      = annotTypeInfo.count();
 93             Relation relation           = annotTypeInfo.relation();
 94 
 95             AnnotatedType annotType = m.getAnnotatedReturnType();
</pre>
<hr />
<pre>
158                         System.err.println(&quot;\tExpected annotation not found: &quot; + annotTypeString);
159                     }
160                 }
161             }
162 
163             boolean found = matcher.find();
164             if (found) {
165                 errors++;
166                 System.err.println(&quot;\tAnnotation found unexpectedly: &quot; + annotTypeString);
167             }
168 
169             if (!valid) {
170                 errors++;
171                 System.err.println(typeString + &quot;\n&quot; + annotTypeString +
172                                    &quot;\n &quot; + valid  +
173                                    &quot;\n\n&quot;);
174             }
175         }
176     }
177 
<span class="line-modified">178     private static final Pattern annotationRegex = Pattern.compile(&quot;@TestObjectMethods\\$AnnotType\\(value=(\\p{Digit})+\\)&quot;);</span>
179 
180     static void testGetAnnotations(Class&lt;?&gt; clazz, boolean annotationsExpectedOnMethods) {
181         System.err.println(&quot;Testing getAnnotations on methods of class &quot; + clazz.getName());
182         Method[] methods = clazz.getDeclaredMethods();
183         for (Method m : methods) {
184             Type type = m.getGenericReturnType();
185             AnnotatedType annotType = m.getAnnotatedReturnType();
186             Annotation[] annotations = annotType.getAnnotations();
187 
188             boolean isVoid = &quot;void&quot;.equals(type.toString());
189 
190             if (annotationsExpectedOnMethods &amp;&amp; !isVoid) {
191                 if (annotations.length == 0 ) {
192                     errors++;
193                     System.err.println(&quot;Expected annotations missing on &quot; + annotType);
194                 }
195             } else {
196                 if (annotations.length &gt; 0 ) {
197                     errors++;
198                     System.err.println(&quot;Unexpected annotations present on &quot; + annotType);
</pre>
<hr />
<pre>
297 
298         checkTypesForEquality(awt1, awt2, false);
299 
300         if (awt2.getAnnotations().length == 0) {
301             errors++;
302             System.err.println(&quot;Expected annotations not found.&quot;);
303         }
304     }
305 
306     private static AnnotatedWildcardType extractWildcard(String methodName) {
307         try {
308             return (AnnotatedWildcardType)
309                 (((AnnotatedParameterizedType)(AnnotatedTypeHost.class.getMethod(methodName).
310                                                getAnnotatedReturnType())).
311                  getAnnotatedActualTypeArguments()[0] );
312         } catch (Exception e) {
313             throw new RuntimeException(e);
314         }
315     }
316 

















317     // The TypeHost and AnnotatedTypeHost classes declare methods with
318     // the same name and signatures but with the AnnotatedTypeHost
319     // methods having annotations on their return type, where
320     // possible.
321 
322     static class TypeHost&lt;E, F extends Number&gt; {
323         @AnnotTypeInfo
324         public void fooVoid() {return;}
325 
326         @AnnotTypeInfo
327         public int foo() {return 0;}
328 
329         @AnnotTypeInfo
330         public String fooString() {return null;}
331 
332         @AnnotTypeInfo
333         public int[] fooIntArray() {return null;}
334 
335         @AnnotTypeInfo
336         public String[] fooStringArray() {return null;}
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2018, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 /*
 25  * @test
<span class="line-modified"> 26  * @bug 8058202 8212081 8224012</span>
 27  * @summary Test java.lang.Object methods on AnnotatedType objects.
 28  */
 29 
 30 import java.lang.annotation.*;
 31 import java.lang.reflect.*;
 32 import java.util.*;
 33 import java.util.regex.*;
 34 
 35 /**
 36  * Test toString, equals, and hashCode on various AnnotatedType objects.
 37  */
 38 
 39 public class TestObjectMethods {
 40     private static int errors = 0;
 41 
 42     /*
 43      * There are various subtypes of AnnotatedType implementations:
 44      *
 45      * AnnotatedType
 46      * AnnotatedArrayType
</pre>
<hr />
<pre>
 56      * well.
 57      */
 58     public static void main(String... args) {
 59         Class&lt;?&gt;[] testClasses = {TypeHost.class, AnnotatedTypeHost.class};
 60 
 61         for (Class&lt;?&gt; clazz : testClasses) {
 62             testEqualsReflexivity(clazz);
 63             testEquals(clazz);
 64         }
 65 
 66         testToString(TypeHost.class);
 67         testToString(AnnotatedTypeHost.class);
 68 
 69         testAnnotationsMatterForEquals(TypeHost.class, AnnotatedTypeHost.class);
 70 
 71         testGetAnnotations(TypeHost.class, false);
 72         testGetAnnotations(AnnotatedTypeHost.class, true);
 73 
 74         testWildcards();
 75 
<span class="line-added"> 76         testFbounds();</span>
<span class="line-added"> 77 </span>
 78         if (errors &gt; 0) {
 79             throw new RuntimeException(errors + &quot; errors&quot;);
 80         }
 81     }
 82 
 83     /*
 84      * For non-array types, verify toString version of the annotated
 85      * type ends with the same string as the generic type.
 86      */
 87     static void testToString(Class&lt;?&gt; clazz) {
 88         System.err.println(&quot;Testing toString on methods of class &quot; + clazz.getName());
 89         Method[] methods = clazz.getDeclaredMethods();
 90         for (Method m : methods) {
 91             // Expected information about the type annotations stored
 92             // in a *declaration* annotation.
 93             AnnotTypeInfo annotTypeInfo = m.getAnnotation(AnnotTypeInfo.class);
 94             int expectedAnnotCount      = annotTypeInfo.count();
 95             Relation relation           = annotTypeInfo.relation();
 96 
 97             AnnotatedType annotType = m.getAnnotatedReturnType();
</pre>
<hr />
<pre>
160                         System.err.println(&quot;\tExpected annotation not found: &quot; + annotTypeString);
161                     }
162                 }
163             }
164 
165             boolean found = matcher.find();
166             if (found) {
167                 errors++;
168                 System.err.println(&quot;\tAnnotation found unexpectedly: &quot; + annotTypeString);
169             }
170 
171             if (!valid) {
172                 errors++;
173                 System.err.println(typeString + &quot;\n&quot; + annotTypeString +
174                                    &quot;\n &quot; + valid  +
175                                    &quot;\n\n&quot;);
176             }
177         }
178     }
179 
<span class="line-modified">180     private static final Pattern annotationRegex = Pattern.compile(&quot;@TestObjectMethods\\$AnnotType\\((\\p{Digit})+\\)&quot;);</span>
181 
182     static void testGetAnnotations(Class&lt;?&gt; clazz, boolean annotationsExpectedOnMethods) {
183         System.err.println(&quot;Testing getAnnotations on methods of class &quot; + clazz.getName());
184         Method[] methods = clazz.getDeclaredMethods();
185         for (Method m : methods) {
186             Type type = m.getGenericReturnType();
187             AnnotatedType annotType = m.getAnnotatedReturnType();
188             Annotation[] annotations = annotType.getAnnotations();
189 
190             boolean isVoid = &quot;void&quot;.equals(type.toString());
191 
192             if (annotationsExpectedOnMethods &amp;&amp; !isVoid) {
193                 if (annotations.length == 0 ) {
194                     errors++;
195                     System.err.println(&quot;Expected annotations missing on &quot; + annotType);
196                 }
197             } else {
198                 if (annotations.length &gt; 0 ) {
199                     errors++;
200                     System.err.println(&quot;Unexpected annotations present on &quot; + annotType);
</pre>
<hr />
<pre>
299 
300         checkTypesForEquality(awt1, awt2, false);
301 
302         if (awt2.getAnnotations().length == 0) {
303             errors++;
304             System.err.println(&quot;Expected annotations not found.&quot;);
305         }
306     }
307 
308     private static AnnotatedWildcardType extractWildcard(String methodName) {
309         try {
310             return (AnnotatedWildcardType)
311                 (((AnnotatedParameterizedType)(AnnotatedTypeHost.class.getMethod(methodName).
312                                                getAnnotatedReturnType())).
313                  getAnnotatedActualTypeArguments()[0] );
314         } catch (Exception e) {
315             throw new RuntimeException(e);
316         }
317     }
318 
<span class="line-added">319     static void testFbounds() {</span>
<span class="line-added">320         // Make sure equals and hashCode work fine for a type</span>
<span class="line-added">321         // involving an F-bound, in particular Comparable&lt;E&gt; in</span>
<span class="line-added">322         // java.lang.Enum:</span>
<span class="line-added">323         //</span>
<span class="line-added">324         // class Enum&lt;E extends Enum&lt;E&gt;&gt;</span>
<span class="line-added">325         // implements Constable, Comparable&lt;E&gt;, Serializable</span>
<span class="line-added">326 </span>
<span class="line-added">327         AnnotatedType[] types = Enum.class.getAnnotatedInterfaces();</span>
<span class="line-added">328 </span>
<span class="line-added">329         for (int i = 0; i &lt; types.length; i ++) {</span>
<span class="line-added">330             for (int j = 0; j &lt; types.length; j ++) {</span>
<span class="line-added">331                 checkTypesForEquality(types[i], types[j], i == j);</span>
<span class="line-added">332             }</span>
<span class="line-added">333         }</span>
<span class="line-added">334     }</span>
<span class="line-added">335 </span>
336     // The TypeHost and AnnotatedTypeHost classes declare methods with
337     // the same name and signatures but with the AnnotatedTypeHost
338     // methods having annotations on their return type, where
339     // possible.
340 
341     static class TypeHost&lt;E, F extends Number&gt; {
342         @AnnotTypeInfo
343         public void fooVoid() {return;}
344 
345         @AnnotTypeInfo
346         public int foo() {return 0;}
347 
348         @AnnotTypeInfo
349         public String fooString() {return null;}
350 
351         @AnnotTypeInfo
352         public int[] fooIntArray() {return null;}
353 
354         @AnnotTypeInfo
355         public String[] fooStringArray() {return null;}
</pre>
</td>
</tr>
</table>
<center><a href="TestConstructorParameterTypeAnnotations.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="../../constant/ClassDescTest.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
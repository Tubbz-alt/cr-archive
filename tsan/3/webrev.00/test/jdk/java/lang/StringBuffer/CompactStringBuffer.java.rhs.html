<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames test/jdk/java/lang/StringBuffer/CompactStringBuffer.java</title>
    <link rel="stylesheet" href="../../../../../style.css" />
    <script type="text/javascript" src="../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
<a name="1" id="anc1"></a><span class="line-modified">  2  * Copyright (c) 2015, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 import java.util.Arrays;
 25 
 26 import org.testng.annotations.Test;
 27 
 28 import static org.testng.Assert.assertEquals;
 29 import static org.testng.Assert.assertTrue;
 30 
 31 /*
 32  * @test
<a name="2" id="anc2"></a><span class="line-modified"> 33  * @bug 8077559 8221430</span>
 34  * @summary Tests Compact String. This test is testing StringBuffer
 35  *          behavior related to Compact String.
 36  * @run testng/othervm -XX:+CompactStrings CompactStringBuffer
 37  * @run testng/othervm -XX:-CompactStrings CompactStringBuffer
 38  */
 39 
 40 public class CompactStringBuffer {
 41 
 42     /*
 43      * Tests for &quot;A&quot;
 44      */
 45     @Test
 46     public void testCompactStringBufferForLatinA() {
 47         final String ORIGIN = &quot;A&quot;;
 48         /*
 49          * Because right now ASCII is the default encoding parameter for source
 50          * code in JDK build environment, so we escape them. same as below.
 51          */
 52         check(new StringBuffer(ORIGIN).append(new char[] { &#39;\uFF21&#39; }),
 53                 &quot;A\uFF21&quot;);
 54         check(new StringBuffer(ORIGIN).append(new StringBuffer(&quot;\uFF21&quot;)),
 55                 &quot;A\uFF21&quot;);
 56         check(new StringBuffer(ORIGIN).append(&quot;\uFF21&quot;), &quot;A\uFF21&quot;);
 57         check(new StringBuffer(ORIGIN).append(new StringBuffer(&quot;\uFF21&quot;)),
 58                 &quot;A\uFF21&quot;);
 59         check(new StringBuffer(ORIGIN).delete(0, 1), &quot;&quot;);
 60         check(new StringBuffer(ORIGIN).delete(0, 0), &quot;A&quot;);
 61         check(new StringBuffer(ORIGIN).deleteCharAt(0), &quot;&quot;);
 62         assertEquals(new StringBuffer(ORIGIN).indexOf(&quot;A&quot;, 0), 0);
 63         assertEquals(new StringBuffer(ORIGIN).indexOf(&quot;\uFF21&quot;, 0), -1);
 64         assertEquals(new StringBuffer(ORIGIN).indexOf(&quot;&quot;, 0), 0);
 65         assertEquals(new StringBuffer(ORIGIN).insert(1, &quot;\uD801\uDC00&quot;)
 66                 .indexOf(&quot;A&quot;, 0), 0);
 67         assertEquals(new StringBuffer(ORIGIN).insert(0, &quot;\uD801\uDC00&quot;)
 68                 .indexOf(&quot;A&quot;, 0), 2);
 69         check(new StringBuffer(ORIGIN).insert(0, new char[] {}), &quot;A&quot;);
 70         check(new StringBuffer(ORIGIN).insert(1, new char[] { &#39;\uFF21&#39; }),
 71                 &quot;A\uFF21&quot;);
 72         check(new StringBuffer(ORIGIN).insert(0, new char[] { &#39;\uFF21&#39; }),
 73                 &quot;\uFF21A&quot;);
 74         check(new StringBuffer(ORIGIN).insert(0, new StringBuffer(&quot;\uFF21&quot;)),
 75                 &quot;\uFF21A&quot;);
 76         check(new StringBuffer(ORIGIN).insert(1, new StringBuffer(&quot;\uFF21&quot;)),
 77                 &quot;A\uFF21&quot;);
 78         check(new StringBuffer(ORIGIN).insert(0, &quot;&quot;), &quot;A&quot;);
 79         check(new StringBuffer(ORIGIN).insert(0, &quot;\uFF21&quot;), &quot;\uFF21A&quot;);
 80         check(new StringBuffer(ORIGIN).insert(1, &quot;\uFF21&quot;), &quot;A\uFF21&quot;);
 81         assertEquals(new StringBuffer(ORIGIN).lastIndexOf(&quot;A&quot;), 0);
 82         assertEquals(new StringBuffer(ORIGIN).lastIndexOf(&quot;\uFF21&quot;), -1);
 83         assertEquals(new StringBuffer(ORIGIN).lastIndexOf(&quot;&quot;), 1);
 84         check(new StringBuffer(ORIGIN).replace(0, 0, &quot;\uFF21&quot;), &quot;\uFF21A&quot;);
 85         check(new StringBuffer(ORIGIN).replace(0, 1, &quot;\uFF21&quot;), &quot;\uFF21&quot;);
 86         checkSetCharAt(new StringBuffer(ORIGIN), 0, &#39;\uFF21&#39;, &quot;\uFF21&quot;);
 87         checkSetLength(new StringBuffer(ORIGIN), 0, &quot;&quot;);
 88         checkSetLength(new StringBuffer(ORIGIN), 1, &quot;A&quot;);
 89         check(new StringBuffer(ORIGIN).substring(0), &quot;A&quot;);
 90         check(new StringBuffer(ORIGIN).substring(1), &quot;&quot;);
 91     }
 92 
 93     /*
 94      * Tests for &quot;\uFF21&quot;
 95      */
 96     @Test
 97     public void testCompactStringBufferForNonLatinA() {
 98         final String ORIGIN = &quot;\uFF21&quot;;
 99         check(new StringBuffer(ORIGIN).append(new char[] { &#39;A&#39; }), &quot;\uFF21A&quot;);
100         check(new StringBuffer(ORIGIN).append(new StringBuffer(&quot;A&quot;)), &quot;\uFF21A&quot;);
101         check(new StringBuffer(ORIGIN).append(&quot;A&quot;), &quot;\uFF21A&quot;);
102         check(new StringBuffer(ORIGIN).append(new StringBuffer(&quot;A&quot;)), &quot;\uFF21A&quot;);
103         check(new StringBuffer(ORIGIN).delete(0, 1), &quot;&quot;);
104         check(new StringBuffer(ORIGIN).delete(0, 0), &quot;\uFF21&quot;);
105         check(new StringBuffer(ORIGIN).deleteCharAt(0), &quot;&quot;);
106         assertEquals(new StringBuffer(ORIGIN).indexOf(&quot;A&quot;, 0), -1);
107         assertEquals(new StringBuffer(ORIGIN).indexOf(&quot;\uFF21&quot;, 0), 0);
108         assertEquals(new StringBuffer(ORIGIN).indexOf(&quot;&quot;, 0), 0);
109         check(new StringBuffer(ORIGIN).insert(0, new char[] {}), &quot;\uFF21&quot;);
110         check(new StringBuffer(ORIGIN).insert(1, new char[] { &#39;A&#39; }), &quot;\uFF21A&quot;);
111         check(new StringBuffer(ORIGIN).insert(0, new char[] { &#39;A&#39; }), &quot;A\uFF21&quot;);
112         check(new StringBuffer(ORIGIN).insert(0, new StringBuffer(&quot;A&quot;)),
113                 &quot;A\uFF21&quot;);
114         check(new StringBuffer(ORIGIN).insert(1, new StringBuffer(&quot;A&quot;)),
115                 &quot;\uFF21A&quot;);
116         check(new StringBuffer(ORIGIN).insert(0, &quot;&quot;), &quot;\uFF21&quot;);
117         check(new StringBuffer(ORIGIN).insert(0, &quot;A&quot;), &quot;A\uFF21&quot;);
118         check(new StringBuffer(ORIGIN).insert(1, &quot;A&quot;), &quot;\uFF21A&quot;);
119         assertEquals(new StringBuffer(ORIGIN).lastIndexOf(&quot;A&quot;), -1);
120         assertEquals(new StringBuffer(ORIGIN).lastIndexOf(&quot;\uFF21&quot;), 0);
121         assertEquals(new StringBuffer(ORIGIN).lastIndexOf(&quot;&quot;), 1);
122         check(new StringBuffer(ORIGIN).replace(0, 0, &quot;A&quot;), &quot;A\uFF21&quot;);
123         check(new StringBuffer(ORIGIN).replace(0, 1, &quot;A&quot;), &quot;A&quot;);
124         checkSetCharAt(new StringBuffer(ORIGIN), 0, &#39;A&#39;, &quot;A&quot;);
125         checkSetLength(new StringBuffer(ORIGIN), 0, &quot;&quot;);
126         checkSetLength(new StringBuffer(ORIGIN), 1, &quot;\uFF21&quot;);
127         check(new StringBuffer(ORIGIN).substring(0), &quot;\uFF21&quot;);
128         check(new StringBuffer(ORIGIN).substring(1), &quot;&quot;);
129     }
130 
131     /*
132      * Tests for &quot;\uFF21A&quot;
133      */
134     @Test
135     public void testCompactStringBufferForMixedA1() {
136         final String ORIGIN = &quot;\uFF21A&quot;;
137         check(new StringBuffer(ORIGIN).delete(0, 1), &quot;A&quot;);
138         check(new StringBuffer(ORIGIN).delete(1, 2), &quot;\uFF21&quot;);
139         check(new StringBuffer(ORIGIN).deleteCharAt(1), &quot;\uFF21&quot;);
140         check(new StringBuffer(ORIGIN).deleteCharAt(0), &quot;A&quot;);
141         assertEquals(new StringBuffer(ORIGIN).indexOf(&quot;A&quot;, 0), 1);
142         assertEquals(new StringBuffer(ORIGIN).indexOf(&quot;\uFF21&quot;, 0), 0);
143         assertEquals(new StringBuffer(ORIGIN).indexOf(&quot;&quot;, 0), 0);
144         check(new StringBuffer(ORIGIN).insert(1, new char[] { &#39;A&#39; }), &quot;\uFF21AA&quot;);
145         check(new StringBuffer(ORIGIN).insert(0, new char[] { &#39;\uFF21&#39; }),
146                 &quot;\uFF21\uFF21A&quot;);
147         assertEquals(new StringBuffer(ORIGIN).lastIndexOf(&quot;A&quot;), 1);
148         assertEquals(new StringBuffer(ORIGIN).lastIndexOf(&quot;\uFF21&quot;), 0);
149         assertEquals(new StringBuffer(ORIGIN).lastIndexOf(&quot;&quot;), 2);
150         check(new StringBuffer(ORIGIN).replace(0, 0, &quot;A&quot;), &quot;A\uFF21A&quot;);
151         check(new StringBuffer(ORIGIN).replace(0, 1, &quot;A&quot;), &quot;AA&quot;);
152         checkSetCharAt(new StringBuffer(ORIGIN), 0, &#39;A&#39;, &quot;AA&quot;);
153         checkSetLength(new StringBuffer(ORIGIN), 0, &quot;&quot;);
154         checkSetLength(new StringBuffer(ORIGIN), 1, &quot;\uFF21&quot;);
155         check(new StringBuffer(ORIGIN).substring(0), &quot;\uFF21A&quot;);
156         check(new StringBuffer(ORIGIN).substring(1), &quot;A&quot;);
157     }
158 
159     /*
160      * Tests for &quot;A\uFF21&quot;
161      */
162     @Test
163     public void testCompactStringBufferForMixedA2() {
164         final String ORIGIN = &quot;A\uFF21&quot;;
165         check(new StringBuffer(ORIGIN).replace(1, 2, &quot;A&quot;), &quot;AA&quot;);
166         checkSetLength(new StringBuffer(ORIGIN), 1, &quot;A&quot;);
167         check(new StringBuffer(ORIGIN).substring(0), &quot;A\uFF21&quot;);
168         check(new StringBuffer(ORIGIN).substring(1), &quot;\uFF21&quot;);
169         check(new StringBuffer(ORIGIN).substring(0, 1), &quot;A&quot;);
170     }
171 
172     /*
173      * Tests for &quot;\uFF21A\uFF21A\uFF21A\uFF21A\uFF21A&quot;
174      */
175     @Test
176     public void testCompactStringBufferForDuplicatedMixedA1() {
177         final String ORIGIN = &quot;\uFF21A\uFF21A\uFF21A\uFF21A\uFF21A&quot;;
178         checkSetLength(new StringBuffer(ORIGIN), 1, &quot;\uFF21&quot;);
179         assertEquals(new StringBuffer(ORIGIN).indexOf(&quot;A&quot;, 5), 5);
180         assertEquals(new StringBuffer(ORIGIN).indexOf(&quot;\uFF21&quot;, 5), 6);
181         assertEquals(new StringBuffer(ORIGIN).lastIndexOf(&quot;A&quot;), 9);
182         assertEquals(new StringBuffer(ORIGIN).lastIndexOf(&quot;\uFF21&quot;), 8);
183         assertEquals(new StringBuffer(ORIGIN).lastIndexOf(&quot;&quot;), 10);
184         check(new StringBuffer(ORIGIN).substring(9), &quot;A&quot;);
185         check(new StringBuffer(ORIGIN).substring(8), &quot;\uFF21A&quot;);
186     }
187 
188     /*
189      * Tests for &quot;A\uFF21A\uFF21A\uFF21A\uFF21A\uFF21&quot;
190      */
191     @Test
192     public void testCompactStringBufferForDuplicatedMixedA2() {
193         final String ORIGIN = &quot;A\uFF21A\uFF21A\uFF21A\uFF21A\uFF21&quot;;
194         checkSetLength(new StringBuffer(ORIGIN), 1, &quot;A&quot;);
195         assertEquals(new StringBuffer(ORIGIN).indexOf(&quot;A&quot;, 5), 6);
196         assertEquals(new StringBuffer(ORIGIN).indexOf(&quot;\uFF21&quot;, 5), 5);
197         assertEquals(new StringBuffer(ORIGIN).lastIndexOf(&quot;A&quot;), 8);
198         assertEquals(new StringBuffer(ORIGIN).lastIndexOf(&quot;\uFF21&quot;), 9);
199         check(new StringBuffer(ORIGIN).substring(9), &quot;\uFF21&quot;);
200         check(new StringBuffer(ORIGIN).substring(8), &quot;A\uFF21&quot;);
201     }
202 
203     /*
204      * Tests for &quot;\uD801\uDC00\uD801\uDC01&quot;
205      */
206     @Test
207     public void testCompactStringForSupplementaryCodePoint() {
208         final String ORIGIN = &quot;\uD801\uDC00\uD801\uDC01&quot;;
209         check(new StringBuffer(ORIGIN).append(&quot;A&quot;), &quot;\uD801\uDC00\uD801\uDC01A&quot;);
210         check(new StringBuffer(ORIGIN).append(&quot;\uFF21&quot;),
211                 &quot;\uD801\uDC00\uD801\uDC01\uFF21&quot;);
212         check(new StringBuffer(ORIGIN).appendCodePoint(&#39;A&#39;),
213                 &quot;\uD801\uDC00\uD801\uDC01A&quot;);
214         check(new StringBuffer(ORIGIN).appendCodePoint(&#39;\uFF21&#39;),
215                 &quot;\uD801\uDC00\uD801\uDC01\uFF21&quot;);
216         assertEquals(new StringBuffer(ORIGIN).charAt(0), &#39;\uD801&#39;);
217         assertEquals(new StringBuffer(ORIGIN).codePointAt(0),
218                 Character.codePointAt(ORIGIN, 0));
219         assertEquals(new StringBuffer(ORIGIN).codePointAt(1),
220                 Character.codePointAt(ORIGIN, 1));
221         assertEquals(new StringBuffer(ORIGIN).codePointBefore(2),
222                 Character.codePointAt(ORIGIN, 0));
223         assertEquals(new StringBuffer(ORIGIN).codePointCount(1, 3), 2);
224         check(new StringBuffer(ORIGIN).delete(0, 2), &quot;\uD801\uDC01&quot;);
225         check(new StringBuffer(ORIGIN).delete(0, 3), &quot;\uDC01&quot;);
226         check(new StringBuffer(ORIGIN).deleteCharAt(1), &quot;\uD801\uD801\uDC01&quot;);
227         checkGetChars(new StringBuffer(ORIGIN), 0, 3, new char[] { &#39;\uD801&#39;,
228                 &#39;\uDC00&#39;, &#39;\uD801&#39; });
229         assertEquals(new StringBuffer(ORIGIN).indexOf(&quot;\uD801\uDC01&quot;), 2);
230         assertEquals(new StringBuffer(ORIGIN).indexOf(&quot;\uDC01&quot;), 3);
231         assertEquals(new StringBuffer(ORIGIN).indexOf(&quot;\uFF21&quot;), -1);
232         assertEquals(new StringBuffer(ORIGIN).indexOf(&quot;A&quot;), -1);
233         check(new StringBuffer(ORIGIN).insert(0, &quot;\uFF21&quot;),
234                 &quot;\uFF21\uD801\uDC00\uD801\uDC01&quot;);
235         check(new StringBuffer(ORIGIN).insert(1, &quot;\uFF21&quot;),
236                 &quot;\uD801\uFF21\uDC00\uD801\uDC01&quot;);
237         check(new StringBuffer(ORIGIN).insert(1, &quot;A&quot;),
238                 &quot;\uD801A\uDC00\uD801\uDC01&quot;);
239         assertEquals(new StringBuffer(ORIGIN).lastIndexOf(&quot;\uDC00\uD801&quot;), 1);
240         assertEquals(new StringBuffer(ORIGIN).lastIndexOf(&quot;\uD801&quot;), 2);
241         assertEquals(new StringBuffer(ORIGIN).lastIndexOf(&quot;\uFF21&quot;), -1);
242         assertEquals(new StringBuffer(ORIGIN).lastIndexOf(&quot;A&quot;), -1);
243         assertEquals(new StringBuffer(ORIGIN).length(), 4);
244         assertEquals(new StringBuffer(ORIGIN).offsetByCodePoints(1, 1), 2);
245         assertEquals(new StringBuffer(ORIGIN).offsetByCodePoints(0, 1), 2);
246         check(new StringBuffer(ORIGIN).replace(0, 2, &quot;A&quot;), &quot;A\uD801\uDC01&quot;);
247         check(new StringBuffer(ORIGIN).replace(0, 3, &quot;A&quot;), &quot;A\uDC01&quot;);
248         check(new StringBuffer(ORIGIN).replace(0, 2, &quot;\uFF21&quot;),
249                 &quot;\uFF21\uD801\uDC01&quot;);
250         check(new StringBuffer(ORIGIN).replace(0, 3, &quot;\uFF21&quot;), &quot;\uFF21\uDC01&quot;);
251         check(new StringBuffer(ORIGIN).reverse(), &quot;\uD801\uDC01\uD801\uDC00&quot;);
252         checkSetCharAt(new StringBuffer(ORIGIN), 1, &#39;\uDC01&#39;,
253                 &quot;\uD801\uDC01\uD801\uDC01&quot;);
254         checkSetCharAt(new StringBuffer(ORIGIN), 1, &#39;A&#39;, &quot;\uD801A\uD801\uDC01&quot;);
255         checkSetLength(new StringBuffer(ORIGIN), 2, &quot;\uD801\uDC00&quot;);
256         checkSetLength(new StringBuffer(ORIGIN), 3, &quot;\uD801\uDC00\uD801&quot;);
257         check(new StringBuffer(ORIGIN).substring(1, 3), &quot;\uDC00\uD801&quot;);
258     }
259 
260     /*
261      * Tests for &quot;A\uD801\uDC00\uFF21&quot;
262      */
263     @Test
264     public void testCompactStringForSupplementaryCodePointMixed1() {
265         final String ORIGIN = &quot;A\uD801\uDC00\uFF21&quot;;
266         assertEquals(new StringBuffer(ORIGIN).codePointBefore(3),
267                 Character.codePointAt(ORIGIN, 1));
268         assertEquals(new StringBuffer(ORIGIN).codePointBefore(2), &#39;\uD801&#39;);
269         assertEquals(new StringBuffer(ORIGIN).codePointBefore(1), &#39;A&#39;);
270         assertEquals(new StringBuffer(ORIGIN).codePointCount(0, 3), 2);
271         assertEquals(new StringBuffer(ORIGIN).codePointCount(0, 4), 3);
272         check(new StringBuffer(ORIGIN).delete(0, 1), &quot;\uD801\uDC00\uFF21&quot;);
273         check(new StringBuffer(ORIGIN).delete(0, 1).delete(2, 3), &quot;\uD801\uDC00&quot;);
274         check(new StringBuffer(ORIGIN).deleteCharAt(3).deleteCharAt(0),
275                 &quot;\uD801\uDC00&quot;);
276         assertEquals(new StringBuffer(ORIGIN).indexOf(&quot;\uFF21&quot;), 3);
277         assertEquals(new StringBuffer(ORIGIN).indexOf(&quot;A&quot;), 0);
278         assertEquals(new StringBuffer(ORIGIN).lastIndexOf(&quot;\uFF21&quot;), 3);
279         assertEquals(new StringBuffer(ORIGIN).lastIndexOf(&quot;A&quot;), 0);
280         assertEquals(new StringBuffer(ORIGIN).offsetByCodePoints(0, 1), 1);
281         assertEquals(new StringBuffer(ORIGIN).offsetByCodePoints(1, 1), 3);
282         check(new StringBuffer(ORIGIN).replace(1, 3, &quot;A&quot;), &quot;AA\uFF21&quot;);
283         check(new StringBuffer(ORIGIN).replace(1, 4, &quot;A&quot;), &quot;AA&quot;);
284         check(new StringBuffer(ORIGIN).replace(1, 4, &quot;&quot;), &quot;A&quot;);
285         check(new StringBuffer(ORIGIN).reverse(), &quot;\uFF21\uD801\uDC00A&quot;);
286         checkSetLength(new StringBuffer(ORIGIN), 1, &quot;A&quot;);
287         check(new StringBuffer(ORIGIN).substring(0, 1), &quot;A&quot;);
288     }
289 
290     /*
291      * Tests for &quot;\uD801\uDC00\uFF21A&quot;
292      */
293     @Test
294     public void testCompactStringForSupplementaryCodePointMixed2() {
295         final String ORIGIN = &quot;\uD801\uDC00\uFF21A&quot;;
296         assertEquals(new StringBuffer(ORIGIN).codePointBefore(3),
297                 Character.codePointAt(ORIGIN, 2));
298         assertEquals(new StringBuffer(ORIGIN).codePointBefore(2),
299                 Character.codePointAt(ORIGIN, 0));
300         assertEquals(new StringBuffer(ORIGIN).codePointBefore(1), &#39;\uD801&#39;);
301         assertEquals(new StringBuffer(ORIGIN).codePointCount(0, 3), 2);
302         assertEquals(new StringBuffer(ORIGIN).codePointCount(0, 4), 3);
303         check(new StringBuffer(ORIGIN).delete(0, 2), &quot;\uFF21A&quot;);
304         check(new StringBuffer(ORIGIN).delete(0, 3), &quot;A&quot;);
305         check(new StringBuffer(ORIGIN).deleteCharAt(0).deleteCharAt(0)
306                 .deleteCharAt(0), &quot;A&quot;);
307         assertEquals(new StringBuffer(ORIGIN).indexOf(&quot;A&quot;), 3);
308         assertEquals(new StringBuffer(ORIGIN).delete(0, 3).indexOf(&quot;A&quot;), 0);
309         assertEquals(new StringBuffer(ORIGIN).replace(0, 3, &quot;B&quot;).indexOf(&quot;A&quot;),
310                 1);
311         assertEquals(new StringBuffer(ORIGIN).substring(3, 4).indexOf(&quot;A&quot;), 0);
312         assertEquals(new StringBuffer(ORIGIN).offsetByCodePoints(1, 1), 2);
313         assertEquals(new StringBuffer(ORIGIN).offsetByCodePoints(0, 1), 2);
314         assertEquals(new StringBuffer(ORIGIN).offsetByCodePoints(2, 1), 3);
315         check(new StringBuffer(ORIGIN).replace(0, 3, &quot;B&quot;), &quot;BA&quot;);
316         check(new StringBuffer(ORIGIN).reverse(), &quot;A\uFF21\uD801\uDC00&quot;);
317     }
318 
319     /*
320      * Tests for &quot;\uD801A\uDC00\uFF21&quot;
321      */
322     @Test
323     public void testCompactStringForSupplementaryCodePointMixed3() {
324         final String ORIGIN = &quot;\uD801A\uDC00\uFF21&quot;;
325         assertEquals(new StringBuffer(ORIGIN).codePointAt(1), &#39;A&#39;);
326         assertEquals(new StringBuffer(ORIGIN).codePointAt(3), &#39;\uFF21&#39;);
327         assertEquals(new StringBuffer(ORIGIN).codePointBefore(1), &#39;\uD801&#39;);
328         assertEquals(new StringBuffer(ORIGIN).codePointBefore(2), &#39;A&#39;);
329         assertEquals(new StringBuffer(ORIGIN).codePointBefore(3), &#39;\uDC00&#39;);
330         assertEquals(new StringBuffer(ORIGIN).codePointCount(0, 3), 3);
331         assertEquals(new StringBuffer(ORIGIN).codePointCount(1, 3), 2);
332         assertEquals(new StringBuffer(ORIGIN).delete(0, 1).delete(1, 3)
333                 .indexOf(&quot;A&quot;), 0);
334         assertEquals(
335                 new StringBuffer(ORIGIN).replace(0, 1, &quot;B&quot;).replace(2, 4, &quot;C&quot;)
336                         .indexOf(&quot;A&quot;), 1);
337         assertEquals(new StringBuffer(ORIGIN).substring(1, 4).substring(0, 1)
338                 .indexOf(&quot;A&quot;), 0);
339         assertEquals(new StringBuffer(ORIGIN).offsetByCodePoints(0, 1), 1);
340         assertEquals(new StringBuffer(ORIGIN).offsetByCodePoints(1, 1), 2);
341         assertEquals(new StringBuffer(ORIGIN).offsetByCodePoints(2, 1), 3);
342         check(new StringBuffer(ORIGIN).reverse(), &quot;\uFF21\uDC00A\uD801&quot;);
343     }
344 
345     /*
346      * Tests for &quot;A\uDC01\uFF21\uD801&quot;
347      */
348     @Test
349     public void testCompactStringForSupplementaryCodePointMixed4() {
350         final String ORIGIN = &quot;A\uDC01\uFF21\uD801&quot;;
351         assertEquals(new StringBuffer(ORIGIN).codePointAt(1), &#39;\uDC01&#39;);
352         assertEquals(new StringBuffer(ORIGIN).codePointAt(3), &#39;\uD801&#39;);
353         assertEquals(new StringBuffer(ORIGIN).codePointBefore(1), &#39;A&#39;);
354         assertEquals(new StringBuffer(ORIGIN).codePointBefore(2), &#39;\uDC01&#39;);
355         assertEquals(new StringBuffer(ORIGIN).codePointBefore(3), &#39;\uFF21&#39;);
356         assertEquals(new StringBuffer(ORIGIN).codePointCount(0, 3), 3);
357         assertEquals(new StringBuffer(ORIGIN).codePointCount(1, 3), 2);
358         assertEquals(new StringBuffer(ORIGIN).delete(1, 4).indexOf(&quot;A&quot;), 0);
359         assertEquals(new StringBuffer(ORIGIN).replace(1, 4, &quot;B&quot;).indexOf(&quot;A&quot;),
360                 0);
361         assertEquals(new StringBuffer(ORIGIN).substring(0, 1).indexOf(&quot;A&quot;), 0);
362         assertEquals(new StringBuffer(ORIGIN).offsetByCodePoints(0, 1), 1);
363         assertEquals(new StringBuffer(ORIGIN).offsetByCodePoints(1, 1), 2);
364         assertEquals(new StringBuffer(ORIGIN).offsetByCodePoints(2, 1), 3);
365         check(new StringBuffer(ORIGIN).reverse(), &quot;\uD801\uFF21\uDC01A&quot;);
366     }
367 
368     @Test
369     public void testCompactStringMisc() {
370         String ascii = &quot;abcdefgh&quot;;
371         String asciiMixed = &quot;abc&quot; + &quot;\u4e00\u4e01\u4e02&quot; + &quot;fgh&quot;;
372         String bmp = &quot;\u4e00\u4e01\u4e02\u4e03\u4e04\u4e05\u4e06\u4e07\u4e08&quot;;
373         String bmpMixed = &quot;\u4e00\u4e01\u4e02&quot; + &quot;ABC&quot; + &quot;\u4e06\u4e07\u4e08&quot;;
374 
375         check(new StringBuffer().append(ascii).delete(0, 20).toString(),
376               &quot;&quot;);
377         check(new StringBuffer().append(ascii).delete(3, 20).toString(),
378               &quot;abc&quot;);
379         check(new StringBuffer().append(ascii).delete(3, 6).toString(),
380               &quot;abcgh&quot;);
381         check(new StringBuffer().append(ascii).deleteCharAt(0).toString(),
382               &quot;bcdefgh&quot;);
383         check(new StringBuffer().append(ascii).deleteCharAt(3).toString(),
384               &quot;abcefgh&quot;);
385         check(new StringBuffer().append(asciiMixed).delete(3, 6).toString(),
386               &quot;abcfgh&quot;);
387         check(new StringBuffer().append(asciiMixed).deleteCharAt(3).toString(),
388               &quot;abc\u4e01\u4e02fgh&quot;);
389         check(new StringBuffer().append(asciiMixed).deleteCharAt(3)
390                                                    .deleteCharAt(3)
391                                                    .deleteCharAt(3).toString(),
392               &quot;abcfgh&quot;);
393         check(new StringBuffer().append(bmp).delete(0, 20).toString(),
394               &quot;&quot;);
395         check(new StringBuffer().append(bmp).delete(3, 20).toString(),
396               &quot;\u4e00\u4e01\u4e02&quot;);
397         check(new StringBuffer().append(bmp).delete(3, 6).toString(),
398               &quot;\u4e00\u4e01\u4e02\u4e06\u4e07\u4e08&quot;);
399         check(new StringBuffer().append(bmp).deleteCharAt(0).toString(),
400               &quot;\u4e01\u4e02\u4e03\u4e04\u4e05\u4e06\u4e07\u4e08&quot;);
401         check(new StringBuffer().append(bmp).deleteCharAt(3).toString(),
402               &quot;\u4e00\u4e01\u4e02\u4e04\u4e05\u4e06\u4e07\u4e08&quot;);
403         check(new StringBuffer().append(bmpMixed).delete(3, 6).toString(),
404               &quot;\u4e00\u4e01\u4e02\u4e06\u4e07\u4e08&quot;);
405 
406         ////////////////////////////////////////////////////////////////////
407         check(new StringBuffer().append(ascii).replace(3, 6, &quot;AB&quot;).toString(),
408               &quot;abcABgh&quot;);
409         check(new StringBuffer().append(asciiMixed).replace(3, 6, &quot;AB&quot;).toString(),
410               &quot;abcABfgh&quot;);
411         check(new StringBuffer().append(bmp).replace(3, 6, &quot;AB&quot;).toString(),
412               &quot;\u4e00\u4e01\u4e02AB\u4e06\u4e07\u4e08&quot;);
413 
414         check(new StringBuffer().append(bmpMixed).replace(3, 6, &quot;&quot;).toString(),
415               &quot;\u4e00\u4e01\u4e02\u4e06\u4e07\u4e08&quot;);
416 
417         check(new StringBuffer().append(ascii).replace(3, 6, &quot;\u4e01\u4e02&quot;).toString(),
418               &quot;abc\u4e01\u4e02gh&quot;);
419 
420         ////////////////////////////////////////////////////////////////////
421         check(new StringBuffer().append(ascii).insert(3, &quot;&quot;).toString(),
422               &quot;abcdefgh&quot;);
423         check(new StringBuffer().append(ascii).insert(3, &quot;AB&quot;).toString(),
424               &quot;abcABdefgh&quot;);
425         check(new StringBuffer().append(ascii).insert(3, &quot;\u4e01\u4e02&quot;).toString(),
426               &quot;abc\u4e01\u4e02defgh&quot;);
427 
428         check(new StringBuffer().append(asciiMixed).insert(0, &#39;A&#39;).toString(),
429               &quot;Aabc\u4e00\u4e01\u4e02fgh&quot;);
430         check(new StringBuffer().append(asciiMixed).insert(3, &quot;A&quot;).toString(),
431               &quot;abcA\u4e00\u4e01\u4e02fgh&quot;);
432 
433         check(new StringBuffer().append(ascii).insert(3, 1234567).toString(),
434               &quot;abc1234567defgh&quot;);
435         check(new StringBuffer().append(bmp).insert(3, 1234567).toString(),
436               &quot;\u4e00\u4e01\u4e021234567\u4e03\u4e04\u4e05\u4e06\u4e07\u4e08&quot;);
437 
438         ////////////////////////////////////////////////////////////////////
439         check(new StringBuffer().append(ascii).append(1.23456).toString(),
440               &quot;abcdefgh1.23456&quot;);
441         check(new StringBuffer().append(bmp).append(1.23456).toString(),
442               &quot;\u4e00\u4e01\u4e02\u4e03\u4e04\u4e05\u4e06\u4e07\u4e081.23456&quot;);
<a name="3" id="anc3"></a><span class="line-added">443 </span>
<span class="line-added">444         ////////////////////////////////////////////////////////////////////</span>
<span class="line-added">445         check(new StringBuffer((CharSequence)new StringBuffer(ascii)).toString(),</span>
<span class="line-added">446               ascii);</span>
<span class="line-added">447         check(new StringBuffer((CharSequence)new StringBuffer(asciiMixed)).toString(),</span>
<span class="line-added">448               asciiMixed);</span>
449     }
450 
451     private void checkGetChars(StringBuffer sb, int srcBegin, int srcEnd,
452             char expected[]) {
453         char[] dst = new char[srcEnd - srcBegin];
454         sb.getChars(srcBegin, srcEnd, dst, 0);
455         assertTrue(Arrays.equals(dst, expected));
456     }
457 
458     private void checkSetCharAt(StringBuffer sb, int index, char ch,
459             String expected) {
460         sb.setCharAt(index, ch);
461         check(sb, expected);
462     }
463 
464     private void checkSetLength(StringBuffer sb, int newLength, String expected) {
465         sb.setLength(newLength);
466         check(sb, expected);
467     }
468 
469     private void check(StringBuffer sb, String expected) {
470         check(sb.toString(), expected);
471     }
472 
473     private void check(String str, String expected) {
474         assertTrue(str.equals(expected), String.format(
475                 &quot;Get (%s) but expect (%s), &quot;, escapeNonASCIIs(str),
476                 escapeNonASCIIs(expected)));
477     }
478 
479     /*
480      * Escape non-ASCII characters since not all systems support them.
481      */
482     private String escapeNonASCIIs(String str) {
483         StringBuilder sb = new StringBuilder();
484         for (int i = 0; i &lt; str.length(); i++) {
485             char c = str.charAt(i);
486             if (c &gt; 0x7F) {
487                 sb.append(&quot;\\u&quot;).append(Integer.toHexString((int) c));
488             } else {
489                 sb.append(c);
490             }
491         }
492         return sb.toString();
493     }
494 }
<a name="4" id="anc4"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="4" type="hidden" />
</body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old test/jdk/java/lang/reflect/PublicMethods/PublicMethodsTest.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2016, 2017, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 import javax.tools.Diagnostic;
 25 import javax.tools.DiagnosticListener;
 26 import javax.tools.FileObject;
 27 import javax.tools.ForwardingJavaFileManager;
 28 import javax.tools.JavaCompiler;
 29 import javax.tools.JavaFileObject;
 30 import javax.tools.SimpleJavaFileObject;
 31 import javax.tools.StandardJavaFileManager;
 32 import javax.tools.StandardLocation;
 33 import javax.tools.ToolProvider;
 34 import java.io.BufferedReader;
 35 import java.io.ByteArrayOutputStream;
 36 import java.io.Closeable;
 37 import java.io.IOException;
 38 import java.io.InputStreamReader;
 39 import java.io.OutputStream;
 40 import java.io.UncheckedIOException;
 41 import java.lang.reflect.Method;
 42 import java.net.URI;
 43 import java.nio.charset.Charset;
 44 import java.util.ArrayList;
 45 import java.util.HashMap;
 46 import java.util.List;
 47 import java.util.Locale;
 48 import java.util.Map;
 49 import java.util.regex.Pattern;
 50 import java.util.stream.Collectors;
 51 import java.util.stream.IntStream;
 52 import java.util.stream.Stream;
 53 
 54 import static java.util.stream.Collectors.joining;
 55 import static java.util.stream.Collectors.toMap;
 56 
 57 /*
 58  * @test
 59  * @bug 8062389
 60  * @modules jdk.compiler
 61  *          jdk.zipfs
 62  * @summary Nearly exhaustive test of Class.getMethod() and Class.getMethods()
 63  * @run main PublicMethodsTest
 64  */
 65 public class PublicMethodsTest {
 66 
 67     public static void main(String[] args) {
 68         Case c = new Case1();
 69 
 70         int[] diffs = new int[1];
 71         try (Stream&lt;Map.Entry&lt;int[], Map&lt;String, String&gt;&gt;&gt;
 72                  expected = expectedResults(c)) {
 73             diffResults(c, expected)
 74                 .forEach(diff -&gt; {
 75                     System.out.println(diff);
 76                     diffs[0]++;
 77                 });
 78         }
 79 
 80         if (diffs[0] &gt; 0) {
 81             throw new RuntimeException(
 82                 &quot;There were &quot; + diffs[0] + &quot; differences.&quot;);
 83         }
 84     }
 85 
 86     // use this to generate .results file for particular case
 87     public static class Generate {
 88         public static void main(String[] args) {
 89             Case c = new Case1();
 90             dumpResults(generateResults(c))
 91                 .forEach(System.out::println);
 92         }
 93     }
 94 
 95     interface Case {
 96         Pattern PLACEHOLDER_PATTERN = Pattern.compile(&quot;\\$\\{(.+?)}&quot;);
 97 
 98         // possible variants of interface method
 99         List&lt;String&gt; INTERFACE_METHODS = List.of(
100             &quot;&quot;, &quot;void m();&quot;, &quot;default void m() {}&quot;, &quot;static void m() {}&quot;
101         );
102 
103         // possible variants of class method
104         List&lt;String&gt; CLASS_METHODS = List.of(
105             &quot;&quot;, &quot;public abstract void m();&quot;,
106             &quot;public void m() {}&quot;, &quot;public static void m() {}&quot;
107         );
108 
109         // template with placeholders parsed with PLACEHOLDER_PATTERN
110         String template();
111 
112         // map of replacementKey (== PLACEHOLDER_PATTERN captured group #1) -&gt;
113         // list of possible replacements
114         Map&lt;String, List&lt;String&gt;&gt; replacements();
115 
116         // ordered list of replacement keys
117         List&lt;String&gt; replacementKeys();
118 
119         // names of types occurring in the template
120         List&lt;String&gt; classNames();
121     }
122 
123     static class Case1 implements Case {
124 
125         private static final String TEMPLATE = Stream.of(
126             &quot;interface I { ${I} }&quot;,
127             &quot;interface J { ${J} }&quot;,
128             &quot;interface K extends I, J { ${K} }&quot;,
129             &quot;abstract class C { ${C} }&quot;,
130             &quot;abstract class D extends C implements I { ${D} }&quot;,
131             &quot;abstract class E extends D implements J, K { ${E} }&quot;
132         ).collect(joining(&quot;\n&quot;));
133 
134         private static final Map&lt;String, List&lt;String&gt;&gt; REPLACEMENTS = Map.of(
135             &quot;I&quot;, INTERFACE_METHODS,
136             &quot;J&quot;, INTERFACE_METHODS,
137             &quot;K&quot;, INTERFACE_METHODS,
138             &quot;C&quot;, CLASS_METHODS,
139             &quot;D&quot;, CLASS_METHODS,
140             &quot;E&quot;, CLASS_METHODS
141         );
142 
143         private static final List&lt;String&gt; REPLACEMENT_KEYS = REPLACEMENTS
144             .keySet().stream().sorted().collect(Collectors.toList());
145 
146         @Override
147         public String template() {
148             return TEMPLATE;
149         }
150 
151         @Override
152         public Map&lt;String, List&lt;String&gt;&gt; replacements() {
153             return REPLACEMENTS;
154         }
155 
156         @Override
157         public List&lt;String&gt; replacementKeys() {
158             return REPLACEMENT_KEYS;
159         }
160 
161         @Override
162         public List&lt;String&gt; classNames() {
163             // just by accident, names of classes are equal to replacement keys
164             // (this need not be the case in general)
165             return REPLACEMENT_KEYS;
166         }
167     }
168 
169     // generate all combinations as a tuple of indexes into lists of
170     // replacements. The index of the element in int[] tuple represents the index
171     // of the key in replacementKeys() list. The value of the element in int[] tuple
172     // represents the index of the replacement string in list of strings in the
173     // value of the entry of replacements() map with the corresponding key.
174     static Stream&lt;int[]&gt; combinations(Case c) {
175         int[] sizes = c.replacementKeys().stream()
176                        .mapToInt(key -&gt; c.replacements().get(key).size())
177                        .toArray();
178 
179         return Stream.iterate(
180             new int[sizes.length],
181             state -&gt; state != null,
182             state -&gt; {
183                 int[] newState = state.clone();
184                 for (int i = 0; i &lt; state.length; i++) {
185                     if (++newState[i] &lt; sizes[i]) {
186                         return newState;
187                     }
188                     newState[i] = 0;
189                 }
190                 // wrapped-around
191                 return null;
192             }
193         );
194     }
195 
196     // given the combination of indexes, return the expanded template
197     static String expandTemplate(Case c, int[] combination) {
198 
199         // 1st create a map: key -&gt; replacement string
200         Map&lt;String, String&gt; map = new HashMap&lt;&gt;(combination.length * 4 / 3 + 1);
201         for (int i = 0; i &lt; combination.length; i++) {
202             String key = c.replacementKeys().get(i);
203             String repl = c.replacements().get(key).get(combination[i]);
204             map.put(key, repl);
205         }
206 
207         return Case.PLACEHOLDER_PATTERN
208             .matcher(c.template())
209             .replaceAll(match -&gt; map.get(match.group(1)));
210     }
211 
212     /**
213      * compile expanded template into a ClassLoader that sees compiled classes
214      */
215     static TestClassLoader compile(String source) throws CompileException {
216         JavaCompiler javac = ToolProvider.getSystemJavaCompiler();
217         if (javac == null) {
218             throw new AssertionError(&quot;No Java compiler tool found.&quot;);
219         }
220 
221         ErrorsCollector errorsCollector = new ErrorsCollector();
222         StandardJavaFileManager standardJavaFileManager =
223             javac.getStandardFileManager(errorsCollector, Locale.ROOT,
224                                          Charset.forName(&quot;UTF-8&quot;));
225         TestFileManager testFileManager = new TestFileManager(
226             standardJavaFileManager, source);
227 
228         JavaCompiler.CompilationTask javacTask;
229         try {
230             javacTask = javac.getTask(
231                 null, // use System.err
232                 testFileManager,
233                 errorsCollector,
234                 null,
235                 null,
236                 List.of(testFileManager.getJavaFileForInput(
237                     StandardLocation.SOURCE_PATH,
238                     TestFileManager.TEST_CLASS_NAME,
239                     JavaFileObject.Kind.SOURCE))
240             );
241         } catch (IOException e) {
242             throw new UncheckedIOException(e);
243         }
244 
245         javacTask.call();
246 
247         if (errorsCollector.hasError()) {
248             throw new CompileException(errorsCollector.getErrors());
249         }
250 
251         return new TestClassLoader(ClassLoader.getSystemClassLoader(),
252                                    testFileManager);
253     }
254 
255     static class CompileException extends Exception {
256         CompileException(List&lt;Diagnostic&lt;?&gt;&gt; diagnostics) {
257             super(diagnostics.stream()
258                              .map(diag -&gt; diag.toString())
259                              .collect(Collectors.joining(&quot;\n&quot;)));
260         }
261     }
262 
263     static class TestFileManager
264         extends ForwardingJavaFileManager&lt;StandardJavaFileManager&gt; {
265         static final String TEST_CLASS_NAME = &quot;Test&quot;;
266 
267         private final String testSource;
268         private final Map&lt;String, ClassFileObject&gt; classes = new HashMap&lt;&gt;();
269 
270         TestFileManager(StandardJavaFileManager fileManager, String source) {
271             super(fileManager);
272             testSource = &quot;public class &quot; + TEST_CLASS_NAME + &quot; {}\n&quot; +
273                          source; // the rest of classes are package-private
274         }
275 
276         @Override
277         public JavaFileObject getJavaFileForInput(Location location,
278                                                   String className,
279                                                   JavaFileObject.Kind kind)
280         throws IOException {
281             if (location == StandardLocation.SOURCE_PATH &amp;&amp;
282                 kind == JavaFileObject.Kind.SOURCE &amp;&amp;
283                 TEST_CLASS_NAME.equals(className)) {
284                 return new SourceFileObject(className, testSource);
285             }
286             return super.getJavaFileForInput(location, className, kind);
287         }
288 
289         private static class SourceFileObject extends SimpleJavaFileObject {
290             private final String source;
291 
292             SourceFileObject(String className, String source) {
293                 super(
294                     URI.create(&quot;memory:/src/&quot; +
295                                className.replace(&#39;.&#39;, &#39;/&#39;) + &quot;.java&quot;),
296                     Kind.SOURCE
297                 );
298                 this.source = source;
299             }
300 
301             @Override
302             public CharSequence getCharContent(boolean ignoreEncodingErrors) {
303                 return source;
304             }
305         }
306 
307         @Override
308         public JavaFileObject getJavaFileForOutput(Location location,
309                                                    String className,
310                                                    JavaFileObject.Kind kind,
311                                                    FileObject sibling)
312         throws IOException {
313             if (kind == JavaFileObject.Kind.CLASS) {
314                 ClassFileObject cfo = new ClassFileObject(className);
315                 classes.put(className, cfo);
316                 return cfo;
317             }
318             return super.getJavaFileForOutput(location, className, kind, sibling);
319         }
320 
321         private static class ClassFileObject extends SimpleJavaFileObject {
322             final String className;
323             ByteArrayOutputStream byteArrayOutputStream;
324 
325             ClassFileObject(String className) {
326                 super(
327                     URI.create(&quot;memory:/out/&quot; +
328                                className.replace(&#39;.&#39;, &#39;/&#39;) + &quot;.class&quot;),
329                     Kind.CLASS
330                 );
331                 this.className = className;
332             }
333 
334             @Override
335             public OutputStream openOutputStream() throws IOException {
336                 return byteArrayOutputStream = new ByteArrayOutputStream();
337             }
338 
339             byte[] getBytes() {
340                 if (byteArrayOutputStream == null) {
341                     throw new IllegalStateException(
342                         &quot;No class file written for class: &quot; + className);
343                 }
344                 return byteArrayOutputStream.toByteArray();
345             }
346         }
347 
348         byte[] getClassBytes(String className) {
349             ClassFileObject cfo = classes.get(className);
350             return (cfo == null) ? null : cfo.getBytes();
351         }
352     }
353 
354     static class ErrorsCollector implements DiagnosticListener&lt;JavaFileObject&gt; {
355         private final List&lt;Diagnostic&lt;?&gt;&gt; errors = new ArrayList&lt;&gt;();
356 
357         @Override
358         public void report(Diagnostic&lt;? extends JavaFileObject&gt; diagnostic) {
359             if (diagnostic.getKind() == Diagnostic.Kind.ERROR) {
360                 errors.add(diagnostic);
361             }
362         }
363 
364         boolean hasError() {
365             return !errors.isEmpty();
366         }
367 
368         List&lt;Diagnostic&lt;?&gt;&gt; getErrors() {
369             return errors;
370         }
371     }
372 
373     static class TestClassLoader extends ClassLoader implements Closeable {
374         private final TestFileManager fileManager;
375 
376         public TestClassLoader(ClassLoader parent, TestFileManager fileManager) {
377             super(parent);
378             this.fileManager = fileManager;
379         }
380 
381         @Override
382         protected Class&lt;?&gt; findClass(String name) throws ClassNotFoundException {
383             byte[] classBytes = fileManager.getClassBytes(name);
384             if (classBytes == null) {
385                 throw new ClassNotFoundException(name);
386             }
387             return defineClass(name, classBytes, 0, classBytes.length);
388         }
389 
390         @Override
391         public void close() throws IOException {
392             fileManager.close();
393         }
394     }
395 
396     static Map&lt;String, String&gt; generateResult(Case c, ClassLoader cl) {
397         return
398             c.classNames()
399              .stream()
400              .map(cn -&gt; {
401                  try {
402                      return Class.forName(cn, false, cl);
403                  } catch (ClassNotFoundException e) {
404                      throw new RuntimeException(&quot;Class not found: &quot; + cn, e);
405                  }
406              })
407              .flatMap(clazz -&gt; Stream.of(
408                  Map.entry(clazz.getName() + &quot;.gM&quot;, generateGetMethodResult(clazz)),
409                  Map.entry(clazz.getName() + &quot;.gMs&quot;, generateGetMethodsResult(clazz))
410              ))
411              .collect(Collectors.toMap(Map.Entry::getKey, Map.Entry::getValue));
412     }
413 
414     static String generateGetMethodResult(Class&lt;?&gt; clazz) {
415         try {
416             Method m = clazz.getMethod(&quot;m&quot;);
417             return m.getDeclaringClass().getName() + &quot;.&quot; + m.getName();
418         } catch (NoSuchMethodException e) {
419             return &quot;-&quot;;
420         }
421     }
422 
423     static String generateGetMethodsResult(Class&lt;?&gt; clazz) {
424         return Stream.of(clazz.getMethods())
425                      .filter(m -&gt; m.getDeclaringClass() != Object.class)
426                      .map(m -&gt; m.getDeclaringClass().getName()
427                                + &quot;.&quot; + m.getName())
428                      .collect(Collectors.joining(&quot;, &quot;, &quot;[&quot;, &quot;]&quot;));
429     }
430 
431     static Stream&lt;Map.Entry&lt;int[], Map&lt;String, String&gt;&gt;&gt; generateResults(Case c) {
432         return combinations(c)
433             .flatMap(comb -&gt; {
434                 String src = expandTemplate(c, comb);
435                 try {
436                     try (TestClassLoader cl = compile(src)) {
437                         // compilation was successful -&gt; generate result
438                         return Stream.of(Map.entry(
439                             comb,
440                             generateResult(c, cl)
441                         ));
442                     } catch (CompileException e) {
443                         // ignore uncompilable combinations
444                         return Stream.empty();
445                     }
446                 } catch (IOException ioe) {
447                     // from TestClassLoader.close()
448                     throw new UncheckedIOException(ioe);
449                 }
450             });
451     }
452 
453     static Stream&lt;Map.Entry&lt;int[], Map&lt;String, String&gt;&gt;&gt; expectedResults(Case c) {
454         try {
455             BufferedReader r = new BufferedReader(new InputStreamReader(
456                 c.getClass().getResourceAsStream(
457                     c.getClass().getSimpleName() + &quot;.results&quot;),
458                 &quot;UTF-8&quot;
459             ));
460 
461             return parseResults(r.lines())
462                 .onClose(() -&gt; {
463                     try {
464                         r.close();
465                     } catch (IOException ioe) {
466                         throw new UncheckedIOException(ioe);
467                     }
468                 });
469         } catch (IOException e) {
470             throw new UncheckedIOException(e);
471         }
472     }
473 
474     static Stream&lt;Map.Entry&lt;int[], Map&lt;String, String&gt;&gt;&gt; parseResults(
475         Stream&lt;String&gt; lines
476     ) {
477         return lines
478             .map(l -&gt; l.split(Pattern.quote(&quot;#&quot;)))
479             .map(lkv -&gt; Map.entry(
480                 Stream.of(lkv[0].split(Pattern.quote(&quot;,&quot;)))
481                       .mapToInt(Integer::parseInt)
482                       .toArray(),
483                 Stream.of(lkv[1].split(Pattern.quote(&quot;|&quot;)))
484                       .map(e -&gt; e.split(Pattern.quote(&quot;=&quot;)))
485                       .collect(toMap(ekv -&gt; ekv[0], ekv -&gt; ekv[1]))
486             ));
487     }
488 
489     static Stream&lt;String&gt; dumpResults(
490         Stream&lt;Map.Entry&lt;int[], Map&lt;String, String&gt;&gt;&gt; results
491     ) {
492         return results
493             .map(le -&gt;
494                      IntStream.of(le.getKey())
495                               .mapToObj(String::valueOf)
496                               .collect(joining(&quot;,&quot;))
497                      + &quot;#&quot; +
498                      le.getValue().entrySet().stream()
499                        .map(e -&gt; e.getKey() + &quot;=&quot; + e.getValue())
500                        .collect(joining(&quot;|&quot;))
501             );
502     }
503 
504     static Stream&lt;String&gt; diffResults(
505         Case c,
506         Stream&lt;Map.Entry&lt;int[], Map&lt;String, String&gt;&gt;&gt; expectedResults
507     ) {
508         return expectedResults
509             .flatMap(exp -&gt; {
510                 int[] comb = exp.getKey();
511                 Map&lt;String, String&gt; expected = exp.getValue();
512 
513                 String src = expandTemplate(c, comb);
514                 Map&lt;String, String&gt; actual;
515                 try {
516                     try (TestClassLoader cl = compile(src)) {
517                         actual = generateResult(c, cl);
518                     } catch (CompileException ce) {
519                         return Stream.of(src + &quot;\n&quot; +
520                                          &quot;got compilation error: &quot; + ce);
521                     }
522                 } catch (IOException ioe) {
523                     // from TestClassLoader.close()
524                     return Stream.of(src + &quot;\n&quot; +
525                                      &quot;got IOException: &quot; + ioe);
526                 }
527 
528                 if (actual.equals(expected)) {
529                     return Stream.empty();
530                 } else {
531                     Map&lt;String, String&gt; diff = new HashMap&lt;&gt;(expected);
532                     diff.entrySet().removeAll(actual.entrySet());
533                     return Stream.of(
534                         diff.entrySet()
535                             .stream()
536                             .map(e -&gt; &quot;expected: &quot; + e.getKey() + &quot;: &quot; +
537                                       e.getValue() + &quot;\n&quot; +
538                                       &quot;  actual: &quot; + e.getKey() + &quot;: &quot; +
539                                       actual.get(e.getKey()) + &quot;\n&quot;)
540                             .collect(joining(&quot;\n&quot;, src + &quot;\n\n&quot;, &quot;\n&quot;))
541                     );
542                 }
543             });
544     }
545 }
    </pre>
  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New test/jdk/java/lang/reflect/exeCallerAccessTest/exeCallerAccessTest.c</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 #include &lt;stdio.h&gt;
 25 #include &lt;stdlib.h&gt;
 26 
 27 #include &quot;jni.h&quot;
 28 #include &quot;assert.h&quot;
 29 
 30 static jclass    classClass;
 31 static jclass    iaeClass;
 32 static jmethodID mid_Class_forName;
 33 static jmethodID mid_Class_getField;
 34 static jmethodID mid_Field_get;
 35 
 36 int getField(JNIEnv *env, char* declaringClass_name, char* field_name);
 37 int checkAndClearIllegalAccessExceptionThrown(JNIEnv *env);
 38 
 39 int main(int argc, char** args) {
 40     JavaVM *jvm;
 41     JNIEnv *env;
 42     JavaVMInitArgs vm_args;
 43     JavaVMOption options[1];
 44     jint rc;
 45 
 46     vm_args.version = JNI_VERSION_1_2;
 47     vm_args.nOptions = 0;
 48     vm_args.options = options;
 49 
 50     if ((rc = JNI_CreateJavaVM(&amp;jvm, (void**)&amp;env, &amp;vm_args)) != JNI_OK) {
 51         printf(&quot;ERROR: cannot create VM.\n&quot;);
 52         exit(-1);
 53     }
 54 
 55     classClass = (*env)-&gt;FindClass(env, &quot;java/lang/Class&quot;);
 56     iaeClass = (*env)-&gt;FindClass(env, &quot;java/lang/IllegalAccessException&quot;);
 57     mid_Class_forName = (*env)-&gt;GetStaticMethodID(env, classClass, &quot;forName&quot;,
 58                                                   &quot;(Ljava/lang/String;)Ljava/lang/Class;&quot;);
 59     assert(mid_Class_forName != NULL);
 60 
 61     mid_Class_getField = (*env)-&gt;GetMethodID(env, classClass, &quot;getField&quot;,
 62                                              &quot;(Ljava/lang/String;)Ljava/lang/reflect/Field;&quot;);
 63     assert(mid_Class_getField != NULL);
 64 
 65     jclass fieldClass = (*env)-&gt;FindClass(env, &quot;java/lang/reflect/Field&quot;);
 66     mid_Field_get = (*env)-&gt;GetMethodID(env, fieldClass, &quot;get&quot;, &quot;(Ljava/lang/Object;)Ljava/lang/Object;&quot;);
 67     assert(mid_Class_getField != NULL);
 68 
 69     // can access to public member of an exported type
 70     if ((rc = getField(env, &quot;java.lang.Integer&quot;, &quot;TYPE&quot;)) != 0) {
 71         printf(&quot;ERROR: fail to access java.lang.Integer::TYPE\n&quot;);
 72         exit(-1);
 73     }
 74 
 75     // expect IAE to jdk.internal.misc.Unsafe class
 76     if ((rc = getField(env, &quot;jdk.internal.misc.Unsafe&quot;, &quot;INVALID_FIELD_OFFSET&quot;)) == 0) {
 77         printf(&quot;ERROR: IAE not thrown\n&quot;);
 78         exit(-1);
 79     }
 80     if (checkAndClearIllegalAccessExceptionThrown(env) != JNI_TRUE) {
 81         printf(&quot;ERROR: exception is not an instance of IAE\n&quot;);
 82         exit(-1);
 83     }
 84 
 85     // expect IAE to jdk.internal.misc.Unsafe class
 86     if ((rc = getField(env, &quot;jdk.internal.misc.Unsafe&quot;, &quot;INVALID_FIELD_OFFSET&quot;)) == 0) {
 87         printf(&quot;ERROR: IAE not thrown\n&quot;);
 88         exit(-1);
 89     }
 90     if (checkAndClearIllegalAccessExceptionThrown(env) != JNI_TRUE) {
 91         printf(&quot;ERROR: exception is not an instance of IAE\n&quot;);
 92         exit(-1);
 93     }
 94 
 95     (*jvm)-&gt;DestroyJavaVM(jvm);
 96     return 0;
 97 }
 98 
 99 int checkAndClearIllegalAccessExceptionThrown(JNIEnv *env) {
100     jthrowable t = (*env)-&gt;ExceptionOccurred(env);
101     if ((*env)-&gt;IsInstanceOf(env, t, iaeClass) == JNI_TRUE) {
102         (*env)-&gt;ExceptionClear(env);
103         return JNI_TRUE;
104     }
105     return JNI_FALSE;
106 }
107 
108 int getField(JNIEnv *env, char* declaringClass_name, char* field_name) {
109     jobject c = (*env)-&gt;CallStaticObjectMethod(env, classClass, mid_Class_forName,
110                                                (*env)-&gt;NewStringUTF(env, declaringClass_name));
111     if ((*env)-&gt;ExceptionOccurred(env) != NULL) {
112         (*env)-&gt;ExceptionDescribe(env);
113         return 1;
114     }
115 
116     jobject f = (*env)-&gt;CallObjectMethod(env, c, mid_Class_getField, (*env)-&gt;NewStringUTF(env, field_name));
117     if ((*env)-&gt;ExceptionOccurred(env) != NULL) {
118         (*env)-&gt;ExceptionDescribe(env);
119         return 2;
120     }
121 
122     jobject v = (*env)-&gt;CallObjectMethod(env, f, mid_Field_get, c);
123     if ((*env)-&gt;ExceptionOccurred(env) != NULL) {
124         (*env)-&gt;ExceptionDescribe(env);
125         return 3;
126     }
127     return 0;
128 }
129 
    </pre>
  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New test/jdk/java/lang/reflect/PublicMethods/PublicMethodsTest.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2016, 2017, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 import javax.tools.Diagnostic;
 25 import javax.tools.DiagnosticListener;
 26 import javax.tools.FileObject;
 27 import javax.tools.ForwardingJavaFileManager;
 28 import javax.tools.JavaCompiler;
 29 import javax.tools.JavaFileObject;
 30 import javax.tools.SimpleJavaFileObject;
 31 import javax.tools.StandardJavaFileManager;
 32 import javax.tools.StandardLocation;
 33 import javax.tools.ToolProvider;
 34 import java.io.BufferedReader;
 35 import java.io.ByteArrayOutputStream;
 36 import java.io.Closeable;
 37 import java.io.IOException;
 38 import java.io.InputStreamReader;
 39 import java.io.OutputStream;
 40 import java.io.UncheckedIOException;
 41 import java.lang.reflect.Method;
 42 import java.net.URI;
 43 import java.nio.charset.Charset;
 44 import java.util.ArrayList;
 45 import java.util.HashMap;
 46 import java.util.List;
 47 import java.util.Locale;
 48 import java.util.Map;
 49 import java.util.regex.Pattern;
 50 import java.util.stream.Collectors;
 51 import java.util.stream.IntStream;
 52 import java.util.stream.Stream;
 53 
 54 import static java.util.stream.Collectors.joining;
 55 import static java.util.stream.Collectors.toMap;
 56 
 57 /*
 58  * @test
 59  * @bug 8062389
 60  * @modules jdk.compiler
 61  *          jdk.zipfs
 62  * @summary Nearly exhaustive test of Class.getMethod() and Class.getMethods()
 63  * @run main PublicMethodsTest
 64  */
 65 public class PublicMethodsTest {
 66 
 67     public static void main(String[] args) {
 68         Case c = new Case1();
 69 
 70         int[] diffs = new int[1];
 71         try (Stream&lt;Map.Entry&lt;int[], Map&lt;String, String&gt;&gt;&gt;
 72                  expected = expectedResults(c)) {
 73             diffResults(c, expected)
 74                 .forEach(diff -&gt; {
 75                     System.out.println(diff);
 76                     diffs[0]++;
 77                 });
 78         }
 79 
 80         if (diffs[0] &gt; 0) {
 81             throw new RuntimeException(
 82                 &quot;There were &quot; + diffs[0] + &quot; differences.&quot;);
 83         }
 84     }
 85 
 86     // use this to generate .results file for particular case
 87     public static class Generate {
 88         public static void main(String[] args) {
 89             Case c = new Case1();
 90             dumpResults(generateResults(c))
 91                 .forEach(System.out::println);
 92         }
 93     }
 94 
 95     interface Case {
 96         Pattern PLACEHOLDER_PATTERN = Pattern.compile(&quot;\\$\\{(.+?)}&quot;);
 97 
 98         // possible variants of interface method
 99         List&lt;String&gt; INTERFACE_METHODS = List.of(
100             &quot;&quot;, &quot;void m();&quot;, &quot;default void m() {}&quot;, &quot;static void m() {}&quot;
101         );
102 
103         // possible variants of class method
104         List&lt;String&gt; CLASS_METHODS = List.of(
105             &quot;&quot;, &quot;public abstract void m();&quot;,
106             &quot;public void m() {}&quot;, &quot;public static void m() {}&quot;
107         );
108 
109         // template with placeholders parsed with PLACEHOLDER_PATTERN
110         String template();
111 
112         // map of replacementKey (== PLACEHOLDER_PATTERN captured group #1) -&gt;
113         // list of possible replacements
114         Map&lt;String, List&lt;String&gt;&gt; replacements();
115 
116         // ordered list of replacement keys
117         List&lt;String&gt; replacementKeys();
118 
119         // names of types occurring in the template
120         List&lt;String&gt; classNames();
121     }
122 
123     static class Case1 implements Case {
124 
125         private static final String TEMPLATE = Stream.of(
126             &quot;interface I { ${I} }&quot;,
127             &quot;interface J { ${J} }&quot;,
128             &quot;interface K extends I, J { ${K} }&quot;,
129             &quot;abstract class C { ${C} }&quot;,
130             &quot;abstract class D extends C implements I { ${D} }&quot;,
131             &quot;abstract class E extends D implements J, K { ${E} }&quot;
132         ).collect(joining(&quot;\n&quot;));
133 
134         private static final Map&lt;String, List&lt;String&gt;&gt; REPLACEMENTS = Map.of(
135             &quot;I&quot;, INTERFACE_METHODS,
136             &quot;J&quot;, INTERFACE_METHODS,
137             &quot;K&quot;, INTERFACE_METHODS,
138             &quot;C&quot;, CLASS_METHODS,
139             &quot;D&quot;, CLASS_METHODS,
140             &quot;E&quot;, CLASS_METHODS
141         );
142 
143         private static final List&lt;String&gt; REPLACEMENT_KEYS = REPLACEMENTS
144             .keySet().stream().sorted().collect(Collectors.toList());
145 
146         @Override
147         public String template() {
148             return TEMPLATE;
149         }
150 
151         @Override
152         public Map&lt;String, List&lt;String&gt;&gt; replacements() {
153             return REPLACEMENTS;
154         }
155 
156         @Override
157         public List&lt;String&gt; replacementKeys() {
158             return REPLACEMENT_KEYS;
159         }
160 
161         @Override
162         public List&lt;String&gt; classNames() {
163             // just by accident, names of classes are equal to replacement keys
164             // (this need not be the case in general)
165             return REPLACEMENT_KEYS;
166         }
167     }
168 
169     // generate all combinations as a tuple of indexes into lists of
170     // replacements. The index of the element in int[] tuple represents the index
171     // of the key in replacementKeys() list. The value of the element in int[] tuple
172     // represents the index of the replacement string in list of strings in the
173     // value of the entry of replacements() map with the corresponding key.
174     static Stream&lt;int[]&gt; combinations(Case c) {
175         int[] sizes = c.replacementKeys().stream()
176                        .mapToInt(key -&gt; c.replacements().get(key).size())
177                        .toArray();
178 
179         return Stream.iterate(
180             new int[sizes.length],
181             state -&gt; state != null,
182             state -&gt; {
183                 int[] newState = state.clone();
184                 for (int i = 0; i &lt; state.length; i++) {
185                     if (++newState[i] &lt; sizes[i]) {
186                         return newState;
187                     }
188                     newState[i] = 0;
189                 }
190                 // wrapped-around
191                 return null;
192             }
193         );
194     }
195 
196     // given the combination of indexes, return the expanded template
197     static String expandTemplate(Case c, int[] combination) {
198 
199         // 1st create a map: key -&gt; replacement string
200         Map&lt;String, String&gt; map = new HashMap&lt;&gt;(combination.length * 4 / 3 + 1);
201         for (int i = 0; i &lt; combination.length; i++) {
202             String key = c.replacementKeys().get(i);
203             String repl = c.replacements().get(key).get(combination[i]);
204             map.put(key, repl);
205         }
206 
207         return Case.PLACEHOLDER_PATTERN
208             .matcher(c.template())
209             .replaceAll(match -&gt; map.get(match.group(1)));
210     }
211 
212     /**
213      * compile expanded template into a ClassLoader that sees compiled classes
214      */
215     static TestClassLoader compile(String source) throws CompileException {
216         JavaCompiler javac = ToolProvider.getSystemJavaCompiler();
217         if (javac == null) {
218             throw new AssertionError(&quot;No Java compiler tool found.&quot;);
219         }
220 
221         ErrorsCollector errorsCollector = new ErrorsCollector();
222         StandardJavaFileManager standardJavaFileManager =
223             javac.getStandardFileManager(errorsCollector, Locale.ROOT,
224                                          Charset.forName(&quot;UTF-8&quot;));
225         try {
226             standardJavaFileManager.setLocation(StandardLocation.CLASS_PATH, List.of());
227         } catch (IOException e) {
228             throw new UncheckedIOException(e);
229         }
230         TestFileManager testFileManager = new TestFileManager(
231             standardJavaFileManager, source);
232 
233         JavaCompiler.CompilationTask javacTask;
234         try {
235             javacTask = javac.getTask(
236                 null, // use System.err
237                 testFileManager,
238                 errorsCollector,
239                 null,
240                 null,
241                 List.of(testFileManager.getJavaFileForInput(
242                     StandardLocation.SOURCE_PATH,
243                     TestFileManager.TEST_CLASS_NAME,
244                     JavaFileObject.Kind.SOURCE))
245             );
246         } catch (IOException e) {
247             throw new UncheckedIOException(e);
248         }
249 
250         javacTask.call();
251 
252         if (errorsCollector.hasError()) {
253             throw new CompileException(errorsCollector.getErrors());
254         }
255 
256         return new TestClassLoader(ClassLoader.getSystemClassLoader(),
257                                    testFileManager);
258     }
259 
260     static class CompileException extends Exception {
261         CompileException(List&lt;Diagnostic&lt;?&gt;&gt; diagnostics) {
262             super(diagnostics.stream()
263                              .map(diag -&gt; diag.toString())
264                              .collect(Collectors.joining(&quot;\n&quot;)));
265         }
266     }
267 
268     static class TestFileManager
269         extends ForwardingJavaFileManager&lt;StandardJavaFileManager&gt; {
270         static final String TEST_CLASS_NAME = &quot;Test&quot;;
271 
272         private final String testSource;
273         private final Map&lt;String, ClassFileObject&gt; classes = new HashMap&lt;&gt;();
274 
275         TestFileManager(StandardJavaFileManager fileManager, String source) {
276             super(fileManager);
277             testSource = &quot;public class &quot; + TEST_CLASS_NAME + &quot; {}\n&quot; +
278                          source; // the rest of classes are package-private
279         }
280 
281         @Override
282         public JavaFileObject getJavaFileForInput(Location location,
283                                                   String className,
284                                                   JavaFileObject.Kind kind)
285         throws IOException {
286             if (location == StandardLocation.SOURCE_PATH &amp;&amp;
287                 kind == JavaFileObject.Kind.SOURCE &amp;&amp;
288                 TEST_CLASS_NAME.equals(className)) {
289                 return new SourceFileObject(className, testSource);
290             }
291             return super.getJavaFileForInput(location, className, kind);
292         }
293 
294         private static class SourceFileObject extends SimpleJavaFileObject {
295             private final String source;
296 
297             SourceFileObject(String className, String source) {
298                 super(
299                     URI.create(&quot;memory:/src/&quot; +
300                                className.replace(&#39;.&#39;, &#39;/&#39;) + &quot;.java&quot;),
301                     Kind.SOURCE
302                 );
303                 this.source = source;
304             }
305 
306             @Override
307             public CharSequence getCharContent(boolean ignoreEncodingErrors) {
308                 return source;
309             }
310         }
311 
312         @Override
313         public JavaFileObject getJavaFileForOutput(Location location,
314                                                    String className,
315                                                    JavaFileObject.Kind kind,
316                                                    FileObject sibling)
317         throws IOException {
318             if (kind == JavaFileObject.Kind.CLASS) {
319                 ClassFileObject cfo = new ClassFileObject(className);
320                 classes.put(className, cfo);
321                 return cfo;
322             }
323             return super.getJavaFileForOutput(location, className, kind, sibling);
324         }
325 
326         private static class ClassFileObject extends SimpleJavaFileObject {
327             final String className;
328             ByteArrayOutputStream byteArrayOutputStream;
329 
330             ClassFileObject(String className) {
331                 super(
332                     URI.create(&quot;memory:/out/&quot; +
333                                className.replace(&#39;.&#39;, &#39;/&#39;) + &quot;.class&quot;),
334                     Kind.CLASS
335                 );
336                 this.className = className;
337             }
338 
339             @Override
340             public OutputStream openOutputStream() throws IOException {
341                 return byteArrayOutputStream = new ByteArrayOutputStream();
342             }
343 
344             byte[] getBytes() {
345                 if (byteArrayOutputStream == null) {
346                     throw new IllegalStateException(
347                         &quot;No class file written for class: &quot; + className);
348                 }
349                 return byteArrayOutputStream.toByteArray();
350             }
351         }
352 
353         byte[] getClassBytes(String className) {
354             ClassFileObject cfo = classes.get(className);
355             return (cfo == null) ? null : cfo.getBytes();
356         }
357     }
358 
359     static class ErrorsCollector implements DiagnosticListener&lt;JavaFileObject&gt; {
360         private final List&lt;Diagnostic&lt;?&gt;&gt; errors = new ArrayList&lt;&gt;();
361 
362         @Override
363         public void report(Diagnostic&lt;? extends JavaFileObject&gt; diagnostic) {
364             if (diagnostic.getKind() == Diagnostic.Kind.ERROR) {
365                 errors.add(diagnostic);
366             }
367         }
368 
369         boolean hasError() {
370             return !errors.isEmpty();
371         }
372 
373         List&lt;Diagnostic&lt;?&gt;&gt; getErrors() {
374             return errors;
375         }
376     }
377 
378     static class TestClassLoader extends ClassLoader implements Closeable {
379         private final TestFileManager fileManager;
380 
381         public TestClassLoader(ClassLoader parent, TestFileManager fileManager) {
382             super(parent);
383             this.fileManager = fileManager;
384         }
385 
386         @Override
387         protected Class&lt;?&gt; findClass(String name) throws ClassNotFoundException {
388             byte[] classBytes = fileManager.getClassBytes(name);
389             if (classBytes == null) {
390                 throw new ClassNotFoundException(name);
391             }
392             return defineClass(name, classBytes, 0, classBytes.length);
393         }
394 
395         @Override
396         public void close() throws IOException {
397             fileManager.close();
398         }
399     }
400 
401     static Map&lt;String, String&gt; generateResult(Case c, ClassLoader cl) {
402         return
403             c.classNames()
404              .stream()
405              .map(cn -&gt; {
406                  try {
407                      return Class.forName(cn, false, cl);
408                  } catch (ClassNotFoundException e) {
409                      throw new RuntimeException(&quot;Class not found: &quot; + cn, e);
410                  }
411              })
412              .flatMap(clazz -&gt; Stream.of(
413                  Map.entry(clazz.getName() + &quot;.gM&quot;, generateGetMethodResult(clazz)),
414                  Map.entry(clazz.getName() + &quot;.gMs&quot;, generateGetMethodsResult(clazz))
415              ))
416              .collect(Collectors.toMap(Map.Entry::getKey, Map.Entry::getValue));
417     }
418 
419     static String generateGetMethodResult(Class&lt;?&gt; clazz) {
420         try {
421             Method m = clazz.getMethod(&quot;m&quot;);
422             return m.getDeclaringClass().getName() + &quot;.&quot; + m.getName();
423         } catch (NoSuchMethodException e) {
424             return &quot;-&quot;;
425         }
426     }
427 
428     static String generateGetMethodsResult(Class&lt;?&gt; clazz) {
429         return Stream.of(clazz.getMethods())
430                      .filter(m -&gt; m.getDeclaringClass() != Object.class)
431                      .map(m -&gt; m.getDeclaringClass().getName()
432                                + &quot;.&quot; + m.getName())
433                      .collect(Collectors.joining(&quot;, &quot;, &quot;[&quot;, &quot;]&quot;));
434     }
435 
436     static Stream&lt;Map.Entry&lt;int[], Map&lt;String, String&gt;&gt;&gt; generateResults(Case c) {
437         return combinations(c)
438             .flatMap(comb -&gt; {
439                 String src = expandTemplate(c, comb);
440                 try {
441                     try (TestClassLoader cl = compile(src)) {
442                         // compilation was successful -&gt; generate result
443                         return Stream.of(Map.entry(
444                             comb,
445                             generateResult(c, cl)
446                         ));
447                     } catch (CompileException e) {
448                         // ignore uncompilable combinations
449                         return Stream.empty();
450                     }
451                 } catch (IOException ioe) {
452                     // from TestClassLoader.close()
453                     throw new UncheckedIOException(ioe);
454                 }
455             });
456     }
457 
458     static Stream&lt;Map.Entry&lt;int[], Map&lt;String, String&gt;&gt;&gt; expectedResults(Case c) {
459         try {
460             BufferedReader r = new BufferedReader(new InputStreamReader(
461                 c.getClass().getResourceAsStream(
462                     c.getClass().getSimpleName() + &quot;.results&quot;),
463                 &quot;UTF-8&quot;
464             ));
465 
466             return parseResults(r.lines())
467                 .onClose(() -&gt; {
468                     try {
469                         r.close();
470                     } catch (IOException ioe) {
471                         throw new UncheckedIOException(ioe);
472                     }
473                 });
474         } catch (IOException e) {
475             throw new UncheckedIOException(e);
476         }
477     }
478 
479     static Stream&lt;Map.Entry&lt;int[], Map&lt;String, String&gt;&gt;&gt; parseResults(
480         Stream&lt;String&gt; lines
481     ) {
482         return lines
483             .map(l -&gt; l.split(Pattern.quote(&quot;#&quot;)))
484             .map(lkv -&gt; Map.entry(
485                 Stream.of(lkv[0].split(Pattern.quote(&quot;,&quot;)))
486                       .mapToInt(Integer::parseInt)
487                       .toArray(),
488                 Stream.of(lkv[1].split(Pattern.quote(&quot;|&quot;)))
489                       .map(e -&gt; e.split(Pattern.quote(&quot;=&quot;)))
490                       .collect(toMap(ekv -&gt; ekv[0], ekv -&gt; ekv[1]))
491             ));
492     }
493 
494     static Stream&lt;String&gt; dumpResults(
495         Stream&lt;Map.Entry&lt;int[], Map&lt;String, String&gt;&gt;&gt; results
496     ) {
497         return results
498             .map(le -&gt;
499                      IntStream.of(le.getKey())
500                               .mapToObj(String::valueOf)
501                               .collect(joining(&quot;,&quot;))
502                      + &quot;#&quot; +
503                      le.getValue().entrySet().stream()
504                        .map(e -&gt; e.getKey() + &quot;=&quot; + e.getValue())
505                        .collect(joining(&quot;|&quot;))
506             );
507     }
508 
509     static Stream&lt;String&gt; diffResults(
510         Case c,
511         Stream&lt;Map.Entry&lt;int[], Map&lt;String, String&gt;&gt;&gt; expectedResults
512     ) {
513         return expectedResults
514             .flatMap(exp -&gt; {
515                 int[] comb = exp.getKey();
516                 Map&lt;String, String&gt; expected = exp.getValue();
517 
518                 String src = expandTemplate(c, comb);
519                 Map&lt;String, String&gt; actual;
520                 try {
521                     try (TestClassLoader cl = compile(src)) {
522                         actual = generateResult(c, cl);
523                     } catch (CompileException ce) {
524                         return Stream.of(src + &quot;\n&quot; +
525                                          &quot;got compilation error: &quot; + ce);
526                     }
527                 } catch (IOException ioe) {
528                     // from TestClassLoader.close()
529                     return Stream.of(src + &quot;\n&quot; +
530                                      &quot;got IOException: &quot; + ioe);
531                 }
532 
533                 if (actual.equals(expected)) {
534                     return Stream.empty();
535                 } else {
536                     Map&lt;String, String&gt; diff = new HashMap&lt;&gt;(expected);
537                     diff.entrySet().removeAll(actual.entrySet());
538                     return Stream.of(
539                         diff.entrySet()
540                             .stream()
541                             .map(e -&gt; &quot;expected: &quot; + e.getKey() + &quot;: &quot; +
542                                       e.getValue() + &quot;\n&quot; +
543                                       &quot;  actual: &quot; + e.getKey() + &quot;: &quot; +
544                                       actual.get(e.getKey()) + &quot;\n&quot;)
545                             .collect(joining(&quot;\n&quot;, src + &quot;\n\n&quot;, &quot;\n&quot;))
546                     );
547                 }
548             });
549     }
550 }
    </pre>
  </body>
</html>
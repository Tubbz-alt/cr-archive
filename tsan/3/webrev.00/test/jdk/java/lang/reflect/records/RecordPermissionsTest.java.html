<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New test/jdk/java/lang/reflect/records/RecordPermissionsTest.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 /*
 25  * @test
 26  * @bug 8235369
 27  * @summary Security manager checks for record related core reflection
 28  * @compile --enable-preview -source ${jdk.version} RecordPermissionsTest.java
 29  * @run testng/othervm/java.security.policy=allPermissions.policy --enable-preview RecordPermissionsTest
 30  */
 31 
 32 import java.net.URL;
 33 import java.net.URLClassLoader;
 34 import java.nio.file.Path;
 35 import java.security.AccessControlContext;
 36 import java.security.AccessController;
 37 import java.security.Permission;
 38 import java.security.Permissions;
 39 import java.security.PrivilegedAction;
 40 import java.security.ProtectionDomain;
 41 import java.util.Arrays;
 42 import java.util.Collection;
 43 import java.util.List;
 44 import java.util.stream.Stream;
 45 import org.testng.annotations.*;
 46 import org.testng.annotations.Test;
 47 import static java.lang.System.out;
 48 import static org.testng.Assert.*;
 49 
 50 public class RecordPermissionsTest {
 51 
 52     class C { }
 53     record R1() { }
 54     record R2(int i, int j) { }
 55     record R3(List&lt;String&gt; ls) { }
 56     record R4(R1 r1, R2 r2, R3 r3) { }
 57     record R5(String... args) { }
 58     record R6(long l, String... args) implements java.io.Serializable { }
 59 
 60     /** A list of classes loaded by a different loader to that of this class&#39; loader. */
 61     static final List&lt;Class&lt;?&gt;&gt; OTHER_LOADER_CLASSES = otherLoaderClasses();
 62 
 63     /** A list of classes loaded by the same loader as this class&#39; loader. */
 64     static final List&lt;Class&lt;?&gt;&gt; SAME_LOADER_CLASSES = sameLoaderClasses();
 65 
 66     static List&lt;Class&lt;?&gt;&gt; otherLoaderClasses() {
 67         try {
 68             ClassLoader cl = new URLClassLoader(
 69                 &quot;other-classloader&quot;,
 70                 new URL[]{Path.of(System.getProperty(&quot;test.classes&quot;)).toUri().toURL()},
 71                 ClassLoader.getPlatformClassLoader()); // skip the system classloader
 72 
 73             return List.of(cl.loadClass(&quot;RecordPermissionsTest$R1&quot;),
 74                            cl.loadClass(&quot;RecordPermissionsTest$R2&quot;),
 75                            Record.class,
 76                            Record[].class,
 77                            byte.class,
 78                            byte[].class);
 79         } catch (Exception e) {
 80             throw new AssertionError(&quot;should not reach here&quot;, e);
 81         }
 82     }
 83 
 84     static List&lt;Class&lt;?&gt;&gt; sameLoaderClasses() {
 85         return List.of(C.class,
 86                        R3.class,
 87                        R4.class,
 88                        R5.class,
 89                        R6.class);
 90     }
 91 
 92     @BeforeTest
 93     public void setup() throws Exception {
 94         assertTrue(System.getSecurityManager() != null);
 95     }
 96 
 97     @DataProvider(name = &quot;isRecordScenarios&quot;)
 98     public Object[][] isRecordScenarios() {
 99          return Stream.of(OTHER_LOADER_CLASSES, SAME_LOADER_CLASSES)
100                       .flatMap(Collection::stream)
101                       .map(cls -&gt; new Object[]{&quot;isRecord-&quot; + cls.getName(),
102                                                (PrivilegedAction&lt;?&gt;)cls::isRecord })
103                       .toArray(Object[][]::new);
104      }
105 
106      @DataProvider(name = &quot;otherGetRecordComponentsScenarios&quot;)
107      public Object[][] otherGetRecordComponentsScenarios() {
108          return OTHER_LOADER_CLASSES.stream()
109                      .map(cls -&gt; new Object[]{&quot;getRecordComponents-other-&quot; + cls.getName(),
110                                              (PrivilegedAction&lt;?&gt;)cls::getRecordComponents })
111                      .toArray(Object[][]::new);
112     }
113 
114     @DataProvider(name = &quot;sameGetRecordComponentsScenarios&quot;)
115     public Object[][] sameGetRecordComponentsScenarios() {
116         return SAME_LOADER_CLASSES.stream()
117                      .map(cls -&gt; new Object[]{&quot;getRecordComponents-same-&quot; + cls.getName(),
118                                              (PrivilegedAction&lt;?&gt;)cls::getRecordComponents })
119                      .toArray(Object[][]::new);
120     }
121 
122     @DataProvider(name = &quot;allScenarios&quot;)
123     public Object[][] allScenarios() {
124         return Stream.of(isRecordScenarios(),
125                          sameGetRecordComponentsScenarios(),
126                          otherGetRecordComponentsScenarios())
127                      .flatMap(Arrays::stream)
128                      .toArray(Object[][]::new);
129     }
130 
131     @DataProvider(name = &quot;allNonThrowingScenarios&quot;)
132     public Object[][] allNonThrowingScenarios() {
133         return Stream.of(isRecordScenarios(),
134                          sameGetRecordComponentsScenarios())
135                      .flatMap(Arrays::stream)
136                      .toArray(Object[][]::new);
137     }
138 
139     /** Tests all scenarios without any security manager - sanity. */
140     @Test(dataProvider = &quot;allScenarios&quot;)
141     public void testWithNoSecurityManager(String description,
142                                           PrivilegedAction&lt;?&gt; action) {
143         System.setSecurityManager(null);
144         try {
145             AccessController.doPrivileged(action);
146         } finally {
147             System.setSecurityManager(new SecurityManager());
148         }
149     }
150 
151     /** Tests all scenarios with all permissions. */
152     @Test(dataProvider = &quot;allScenarios&quot;)
153     public void testWithAllPermissions(String description,
154                                        PrivilegedAction&lt;?&gt; action) {
155         // Run with all permissions, i.e. no further restrictions than test&#39;s AllPermission
156         assert System.getSecurityManager() != null;
157         AccessController.doPrivileged(action);
158     }
159 
160     /** Tests given scenarios with no permissions - expect should not require any. */
161     @Test(dataProvider = &quot;allNonThrowingScenarios&quot;)
162     public void testWithNoPermissionsPass(String description,
163                                           PrivilegedAction&lt;?&gt; action) {
164         assert System.getSecurityManager() != null;
165         AccessController.doPrivileged(action, noPermissions());
166     }
167 
168     static Class&lt;SecurityException&gt; SE = SecurityException.class;
169 
170     /**
171      * Tests getRecordComponents with no permissions, and classes
172      * loaded by a loader other than the test class&#39; loader - expects
173      * security exception.
174      */
175     @Test(dataProvider = &quot;otherGetRecordComponentsScenarios&quot;)
176     public void testWithNoPermissionsFail(String description,
177                                           PrivilegedAction&lt;?&gt; action) {
178         // Run with NO permissions, i.e. expect SecurityException
179         assert System.getSecurityManager() != null;
180         SecurityException se = expectThrows(SE, () -&gt; AccessController.doPrivileged(action, noPermissions()));
181         out.println(&quot;Got expected SecurityException: &quot; + se);
182     }
183 
184     /**
185      * Tests getRecordComponents with minimal permissions, and classes
186      * loaded by a loader other than the test class&#39; loader.
187      */
188     @Test(dataProvider = &quot;otherGetRecordComponentsScenarios&quot;)
189     public void testWithMinimalPermissions(String description,
190                                            PrivilegedAction&lt;?&gt; action) {
191         // Run with minimal permissions, i.e. just what is required
192         assert System.getSecurityManager() != null;
193         AccessControlContext minimalACC = withPermissions(
194                 new RuntimePermission(&quot;accessDeclaredMembers&quot;),
195                 new RuntimePermission(&quot;accessClassInPackage.*&quot;)
196         );
197         AccessController.doPrivileged(action, minimalACC);
198     }
199 
200     static AccessControlContext withPermissions(Permission... perms) {
201         Permissions p = new Permissions();
202         for (Permission perm : perms) {
203             p.add(perm);
204         }
205         ProtectionDomain pd = new ProtectionDomain(null, p);
206         return new AccessControlContext(new ProtectionDomain[]{ pd });
207     }
208 
209     static AccessControlContext noPermissions() {
210         return withPermissions(/*empty*/);
211     }
212 }
    </pre>
  </body>
</html>
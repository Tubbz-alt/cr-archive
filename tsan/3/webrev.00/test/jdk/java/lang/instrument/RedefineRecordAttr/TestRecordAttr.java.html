<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New test/jdk/java/lang/instrument/RedefineRecordAttr/TestRecordAttr.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 /*
 25  * @test
 26  * @summary Class redefinition must preclude changes to Record attributes
 27  * @comment This is a copy of test/jdk/java/lang/instrument/RedefineNestmateAttr/
 28  * @comment modified for records and the Record attribute.
 29  *
 30  * @library /test/lib
 31  * @modules java.base/jdk.internal.misc
 32  * @modules java.compiler
 33  *          java.instrument
 34  * @compile ../NamedBuffer.java
 35  * @run main RedefineClassHelper
 36  * @compile --enable-preview -source ${jdk.version} Host/Host.java
 37  * @compile --enable-preview -source ${jdk.version} TestRecordAttr.java
 38  * @run main/othervm -javaagent:redefineagent.jar --enable-preview -Xlog:redefine+class+record=trace TestRecordAttr Host
 39  * @compile --enable-preview -source ${jdk.version} HostA/Host.java
 40  * @run main/othervm -javaagent:redefineagent.jar --enable-preview -Xlog:redefine+class+record=trace TestRecordAttr HostA
 41  * @compile --enable-preview -source ${jdk.version} HostAB/Host.java
 42  * @run main/othervm -javaagent:redefineagent.jar --enable-preview -Xlog:redefine+class+record=trace TestRecordAttr HostAB
 43  * @compile --enable-preview -source ${jdk.version} HostABC/Host.java
 44  * @run main/othervm -javaagent:redefineagent.jar --enable-preview -Xlog:redefine+class+record=trace TestRecordAttr HostABC
 45  */
 46 
 47 /* Test Description
 48 
 49 The basic test class is called Host and we have variants that have zero or more
 50 record components.  Each variant of Host is defined in source code in its own
 51 directory i.e.
 52 
 53 Host/Host.java defines zero record components
 54 Record HostA/Host.java has record component &quot;int A&quot;
 55 Record HostAB/Host.java has record components &quot;int A&quot; and &quot;long B&quot; (in that order)
 56 Record HostABC/Host.java has record components &quot;int A&quot;, &quot;long B&quot;, and &quot;char C&quot; (in that order)
 57 etc.
 58 
 59 Each Host class has the form:
 60 
 61   public record Host &lt;zero or more record components&gt; {
 62     public static String getID() { return &quot;&lt;directory name&gt;/Host.java&quot;; }
 63 
 64     public int m() {
 65         return 1; // original class
 66     }
 67 
 68     public Host(int A, long B, char C) {
 69          ...
 70     }
 71   }
 72 
 73 Under each directory is a directory &quot;redef&quot; with a modified version of the Host
 74 class that changes the ID to e.g. Host/redef/Host.java, and the method m()
 75 returns 2. This allows us to check we have the redefined class loaded.
 76 
 77 Using Host&#39; to represent the redefined version we test redefinition
 78 combinations as follows:
 79 
 80 Host:
 81   Host -&gt; Host&#39;  - succeeds m() returns 2
 82   Host -&gt; HostA&#39; - fails - added a record component
 83 
 84 HostA:
 85   HostA -&gt; HostA&#39;  - succeeds m() returns 2
 86   HostA -&gt; Host&#39;   - fails - removed a record component
 87   HostA -&gt; HostAB&#39; - fails - added a record component
 88   HostA -&gt; HostB&#39;  - fails - replaced a record component
 89 
 90 HostAB:
 91   HostAB -&gt; HostAB&#39;  - succeeds m() returns 2
 92   HostAB -&gt; HostBA&#39;  - fails - reordered record components
 93   HostAB -&gt; HostA&#39;   - fails - removed a record component
 94   HostAB -&gt; HostABC&#39; - fails - added a record component
 95   HostAB -&gt; HostAC&#39;  - fails - replaced a record component
 96 
 97 HostABC:
 98   HostABC -&gt; HostABC&#39;  - succeeds m() returns 2
 99   HostABC -&gt; HostACB&#39;  - fails - reordered record components
100   HostABC -&gt; HostBAC&#39;  - fails - reordered record components
101   HostABC -&gt; HostBCA&#39;  - fails - reordered record components
102   HostABC -&gt; HostCAB&#39;  - fails - reordered record components
103   HostABC -&gt; HostCBA&#39;  - fails - reordered record components
104   HostABC -&gt; HostAB&#39;   - fails - removed a record component
105   HostABC -&gt; HostABCD&#39; - fails - added a record component
106   HostABC -&gt; HostABD&#39;  - fails - replaced a record component
107 
108 More than three record components doesn&#39;t add to the code coverage so
109 we stop here.
110 
111 Note that we always try to load the redefined version even when we expect it
112 to fail.
113 
114 We can only directly load one class Host per classloader, so to run all the
115 groups we either need to use new classloaders, or we reinvoke the test
116 requesting a different primary directory. We chose the latter using
117 multiple @run tags. So we preceed as follows:
118 
119  @compile Host/Host.java
120  @run TestRecordAttr Host
121  @compile HostA/Host.java  - replaces previous Host.class
122  @run TestRecordAttr HostA
123  @compile HostAB/Host.java  - replaces previous Host.class
124  @run TestRecordAttr HostAB
125 etc.
126 
127 Within the test we directly compile redefined versions of the classes,
128 using CompilerUtil, and then read the .class file directly as a byte[]
129 to use with the RedefineClassHelper.
130 
131 */
132 
133 import java.io.File;
134 import java.io.FileInputStream;
135 import jdk.test.lib.ByteCodeLoader;
136 import jdk.test.lib.compiler.CompilerUtils;
137 import jdk.test.lib.compiler.InMemoryJavaCompiler;
138 import static jdk.test.lib.Asserts.assertTrue;
139 
140 public class TestRecordAttr {
141 
142     static final String SRC = System.getProperty(&quot;test.src&quot;);
143     static final String DEST = System.getProperty(&quot;test.classes&quot;);
144     static final boolean VERBOSE = Boolean.getBoolean(&quot;verbose&quot;);
145     private static final String VERSION = Integer.toString(Runtime.version().feature());
146 
147     public static void main(String[] args) throws Throwable {
148         String origin = args[0];
149         System.out.println(&quot;Testing original Host class from &quot; + origin);
150 
151         // Make sure the Host class loaded directly is an original version
152         // and from the expected location. Use a ctor common to all Host
153         // classes.
154         Host h = new Host(3, 4, &#39;a&#39;);
155         assertTrue(h.m() == 1);
156         assertTrue(Host.getID().startsWith(origin + &quot;/&quot;));
157 
158         String[] badTransforms;  // directories of bad classes
159         String[] goodTransforms; // directories of good classes
160 
161         switch (origin) {
162         case &quot;Host&quot;:
163             badTransforms = new String[] {
164                 &quot;HostA&quot; // add record component
165             };
166             goodTransforms = new String[] {
167                 origin
168             };
169             break;
170 
171         case &quot;HostA&quot;:
172             badTransforms = new String[] {
173                 &quot;Host&quot;,   // remove record component
174                 &quot;HostAB&quot;, // add record component
175                 &quot;HostB&quot;   // change record component
176             };
177             goodTransforms = new String[] {
178                 origin
179             };
180             break;
181 
182         case &quot;HostAB&quot;:
183             badTransforms = new String[] {
184                 &quot;HostA&quot;,   // remove record component
185                 &quot;HostABC&quot;, // add record component
186                 &quot;HostAC&quot;,  // change record component
187                 &quot;HostBA&quot;   // reorder record components
188             };
189             goodTransforms = new String[] {
190                 origin,
191             };
192             break;
193 
194         case &quot;HostABC&quot;:
195             badTransforms = new String[] {
196                 &quot;HostAB&quot;,   // remove record component
197                 &quot;HostABCD&quot;, // add record component
198                 &quot;HostABD&quot;,  // change record component
199                 &quot;HostACB&quot;,  // reorder record components
200                 &quot;HostBAC&quot;,  // reorder record components
201                 &quot;HostBCA&quot;,  // reorder record components
202                 &quot;HostCAB&quot;,  // reorder record components
203                 &quot;HostCBA&quot;   // reorder record components
204             };
205             goodTransforms = new String[] {
206                 origin
207             };
208             break;
209 
210         default: throw new Error(&quot;Unknown test directory: &quot; + origin);
211         }
212 
213         // Compile and check bad transformations
214         checkBadTransforms(Host.class, badTransforms);
215 
216         // Compile and check good transformations
217         checkGoodTransforms(Host.class, goodTransforms);
218     }
219 
220     static void checkGoodTransforms(Class&lt;?&gt; c, String[] dirs) throws Throwable {
221         for (String dir : dirs) {
222             dir += &quot;/redef&quot;;
223             System.out.println(&quot;Trying good retransform from &quot; + dir);
224             byte[] buf = bytesForHostClass(dir);
225             RedefineClassHelper.redefineClass(c, buf);
226 
227             // Test redefintion worked
228             Host h = new Host(3, 4, &#39;a&#39;);
229             assertTrue(h.m() == 2);
230             if (VERBOSE) System.out.println(&quot;Redefined ID: &quot; + Host.getID());
231             assertTrue(Host.getID().startsWith(dir));
232         }
233     }
234 
235     static void checkBadTransforms(Class&lt;?&gt; c, String[] dirs) throws Throwable {
236         for (String dir : dirs) {
237             dir += &quot;/redef&quot;;
238             System.out.println(&quot;Trying bad retransform from &quot; + dir);
239             byte[] buf = bytesForHostClass(dir);
240             try {
241                 RedefineClassHelper.redefineClass(c, buf);
242                 throw new Error(&quot;Retransformation from directory &quot; + dir +
243                                 &quot; succeeded unexpectedly&quot;);
244             }
245             catch (UnsupportedOperationException uoe) {
246                 if (uoe.getMessage().contains(&quot;attempted to change the class&quot;) &amp;&amp;
247                     uoe.getMessage().contains(&quot; Record&quot;)) {
248                     System.out.println(&quot;Got expected exception &quot; + uoe);
249                 }
250                 else throw new Error(&quot;Wrong UnsupportedOperationException&quot;, uoe);
251             }
252         }
253     }
254 
255     static byte[] bytesForHostClass(String dir) throws Throwable {
256         compile(&quot;/&quot; + dir);
257         File clsfile = new File(DEST + &quot;/&quot; + dir + &quot;/Host.class&quot;);
258         if (VERBOSE) System.out.println(&quot;Reading bytes from &quot; + clsfile);
259         byte[] buf = null;
260         try (FileInputStream str = new FileInputStream(clsfile)) {
261             return buf = NamedBuffer.loadBufferFromStream(str);
262         }
263     }
264 
265     static void compile(String dir) throws Throwable {
266         File src = new File(SRC + dir);
267         File dst = new File(DEST + dir);
268         if (VERBOSE) System.out.println(&quot;Compiling from: &quot; + src + &quot;\n&quot; +
269                                         &quot;            to: &quot; + dst);
270         CompilerUtils.compile(src.toPath(),
271                               dst.toPath(),
272                               false /* don&#39;t recurse */,
273                               &quot;--enable-preview&quot;,
274                               &quot;--source&quot;, VERSION);
275     }
276 }
    </pre>
  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New test/jdk/java/lang/instrument/RedefineRecordAttrGenericSig/TestRecordAttrGenericSig.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 /*
 25  * @test
 26  * @summary Class redefinition must preclude changes to Record attributes
 27  * @comment This is a copy of test/jdk/java/lang/instrument/RedefineNestmateAttr/
 28  * @comment modified for records and the Record attribute.
 29  *
 30  * @library /test/lib
 31  * @modules java.base/jdk.internal.misc
 32  * @modules java.compiler
 33  *          java.instrument
 34  * @compile ../NamedBuffer.java
 35  * @run main RedefineClassHelper
 36  * @compile --enable-preview --source ${jdk.version} Host/Host.java
 37  * @compile --enable-preview --source ${jdk.version} TestRecordAttrGenericSig.java
 38  * @run main/othervm -javaagent:redefineagent.jar -Xlog:redefine+class+record=trace --enable-preview TestRecordAttrGenericSig Host
 39  * @compile --enable-preview --source ${jdk.version} HostA/Host.java
 40  * @run main/othervm -javaagent:redefineagent.jar -Xlog:redefine+class+record=trace --enable-preview TestRecordAttrGenericSig HostA
 41  */
 42 
 43 /* Test Description
 44 
 45 The basic test class is called Host and we have variants that have record components
 46 with different or no generic_signature attributes.  Each variant of Host is defined
 47 in source code in its own directory i.e.
 48 
 49 Host/Host.java has record components with no generic signature attributes.
 50 HostA/Host.java has a record component with generic signature &quot;TT&quot;.
 51 HostB/Host.java has a record component with generic signature &quot;TX&quot;.
 52 
 53 Each Host class has the form:
 54 
 55   public record Host &lt;possible generic&gt;(&lt;java.lang.Object or generic&gt; a, java.lang.String b) {
 56     public static String getID() { return &quot;&lt;directory name&gt;/Host.java&quot;; }
 57 
 58     public int m() {
 59         return 1; // original class
 60     }
 61 
 62   }
 63 
 64 Under each directory is a directory &quot;redef&quot; with a modified version of the Host
 65 class that changes the ID to e.g. Host/redef/Host.java, and the method m()
 66 returns 2. This allows us to check we have the redefined class loaded.
 67 
 68 Using Host&#39; to represent the redefined version we test redefinition
 69 combinations as follows:
 70 
 71 Host:
 72   Host -&gt; Host&#39;  - succeeds m() returns 2
 73   Host -&gt; HostA&#39; - fails - added a generic signature
 74 
 75 HostA:
 76   HostA -&gt; HostA&#39;  - succeeds m() returns 2
 77   HostA -&gt; Host&#39;   - fails - removed a generic signature
 78   HostA -&gt; HostB&#39;  - fails - replaced a generic signature
 79 
 80 Note that we always try to load the redefined version even when we expect it
 81 to fail.
 82 
 83 We can only directly load one class Host per classloader, so to run all the
 84 groups we either need to use new classloaders, or we reinvoke the test
 85 requesting a different primary directory. We chose the latter using
 86 multiple @run tags. So we preceed as follows:
 87 
 88  @compile Host/Host.java
 89  @run TestRecordAttrGenericSig Host
 90  @compile HostA/Host.java  - replaces previous Host.class
 91  @run TestRecordAttrGenericSig HostA
 92 etc.
 93 
 94 Within the test we directly compile redefined versions of the classes,
 95 using CompilerUtil, and then read the .class file directly as a byte[]
 96 to use with the RedefineClassHelper.
 97 
 98 */
 99 
100 import java.io.File;
101 import java.io.FileInputStream;
102 import jdk.test.lib.ByteCodeLoader;
103 import jdk.test.lib.compiler.CompilerUtils;
104 import jdk.test.lib.compiler.InMemoryJavaCompiler;
105 import static jdk.test.lib.Asserts.assertTrue;
106 
107 public class TestRecordAttrGenericSig {
108 
109     static final String SRC = System.getProperty(&quot;test.src&quot;);
110     static final String DEST = System.getProperty(&quot;test.classes&quot;);
111     static final boolean VERBOSE = Boolean.getBoolean(&quot;verbose&quot;);
112     private static final String VERSION = Integer.toString(Runtime.version().feature());
113 
114     public static void main(String[] args) throws Throwable {
115         String origin = args[0];
116         System.out.println(&quot;Testing original Host class from &quot; + origin);
117 
118         // Make sure the Host class loaded directly is an original version
119         // and from the expected location. Use a ctor common to all Host
120         // classes.
121         Host h = new Host(&quot;abc&quot;, &quot;def&quot;);
122         assertTrue(h.m() == 1);
123         assertTrue(Host.getID().startsWith(origin + &quot;/&quot;));
124 
125         String[] badTransforms;  // directories of bad classes
126         String[] goodTransforms; // directories of good classes
127 
128         switch (origin) {
129         case &quot;Host&quot;:
130             badTransforms = new String[] {
131                 &quot;HostA&quot; // add a generic signature to a record component
132             };
133             goodTransforms = new String[] {
134                 origin
135             };
136             break;
137 
138         case &quot;HostA&quot;:
139             badTransforms = new String[] {
140                 &quot;Host&quot;,   // remove a generic signature from a record component
141                 &quot;HostB&quot;   // change a record component generic signature
142             };
143             goodTransforms = new String[] {
144                 origin
145             };
146             break;
147 
148         default: throw new Error(&quot;Unknown test directory: &quot; + origin);
149         }
150 
151         // Compile and check bad transformations
152         checkBadTransforms(Host.class, badTransforms);
153 
154         // Compile and check good transformations
155         checkGoodTransforms(Host.class, goodTransforms);
156     }
157 
158     static void checkGoodTransforms(Class&lt;?&gt; c, String[] dirs) throws Throwable {
159         for (String dir : dirs) {
160             dir += &quot;/redef&quot;;
161             System.out.println(&quot;Trying good retransform from &quot; + dir);
162             byte[] buf = bytesForHostClass(dir);
163             RedefineClassHelper.redefineClass(c, buf);
164 
165             // Test redefintion worked
166             Host h = new Host(&quot;abc&quot;, &quot;def&quot;);
167             assertTrue(h.m() == 2);
168             if (VERBOSE) System.out.println(&quot;Redefined ID: &quot; + Host.getID());
169             assertTrue(Host.getID().startsWith(dir));
170         }
171     }
172 
173     static void checkBadTransforms(Class&lt;?&gt; c, String[] dirs) throws Throwable {
174         for (String dir : dirs) {
175             dir += &quot;/redef&quot;;
176             System.out.println(&quot;Trying bad retransform from &quot; + dir);
177             byte[] buf = bytesForHostClass(dir);
178             try {
179                 RedefineClassHelper.redefineClass(c, buf);
180                 throw new Error(&quot;Retransformation from directory &quot; + dir +
181                                 &quot; succeeded unexpectedly&quot;);
182             }
183             catch (UnsupportedOperationException uoe) {
184                 if (uoe.getMessage().contains(&quot;attempted to change the class&quot;) &amp;&amp;
185                     uoe.getMessage().contains(&quot; Record&quot;)) {
186                     System.out.println(&quot;Got expected exception &quot; + uoe);
187                 }
188                 else throw new Error(&quot;Wrong UnsupportedOperationException&quot;, uoe);
189             }
190         }
191     }
192 
193     static byte[] bytesForHostClass(String dir) throws Throwable {
194         compile(&quot;/&quot; + dir);
195         File clsfile = new File(DEST + &quot;/&quot; + dir + &quot;/Host.class&quot;);
196         if (VERBOSE) System.out.println(&quot;Reading bytes from &quot; + clsfile);
197         byte[] buf = null;
198         try (FileInputStream str = new FileInputStream(clsfile)) {
199             return buf = NamedBuffer.loadBufferFromStream(str);
200         }
201     }
202 
203     static void compile(String dir) throws Throwable {
204         File src = new File(SRC + dir);
205         File dst = new File(DEST + dir);
206         if (VERBOSE) System.out.println(&quot;Compiling from: &quot; + src + &quot;\n&quot; +
207                                         &quot;            to: &quot; + dst);
208         CompilerUtils.compile(src.toPath(),
209                               dst.toPath(),
210                               false /* don&#39;t recurse */,
211                               &quot;--enable-preview&quot;,
212                               &quot;--source&quot;, VERSION);
213     }
214 }
    </pre>
  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames test/jdk/java/lang/instrument/RedefineNestmateAttr/TestNestmateAttr.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
<a name="1" id="anc1"></a><span class="line-modified">  2  * Copyright (c) 2018, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 /*
 25  * @test
 26  * @bug 8046171
 27  * @summary Class redefinition must preclude changes to nest attributes
 28  * @library /test/lib
 29  * @modules java.base/jdk.internal.misc
 30  * @modules java.compiler
 31  *          java.instrument
<a name="2" id="anc2"></a>
 32  * @compile ../NamedBuffer.java
 33  * @run main RedefineClassHelper
 34  * @compile Host/Host.java
 35  * @run main/othervm -javaagent:redefineagent.jar -Xlog:redefine+class+nestmates=trace TestNestmateAttr Host
 36  * @compile HostA/Host.java
 37  * @run main/othervm -javaagent:redefineagent.jar -Xlog:redefine+class+nestmates=trace TestNestmateAttr HostA
 38  * @compile HostAB/Host.java
 39  * @run main/othervm -javaagent:redefineagent.jar -Xlog:redefine+class+nestmates=trace TestNestmateAttr HostAB
 40  * @compile HostABC/Host.java
 41  * @run main/othervm -javaagent:redefineagent.jar -Xlog:redefine+class+nestmates=trace TestNestmateAttr HostABC
 42  */
 43 
 44 /* Test Description
 45 
 46 The basic test class is call Host and we have variants that have zero or more
 47 nested classes named A, B, C etc. Each variant of Host is defined in source
 48 code in its own directory i.e.
 49 
 50 Host/Host.java defines zero nested classes
 51 HostA/Host.java defines one nested class A
 52 HostAB/Host.java defines two nested classes A and B (in that order)
 53 etc.
 54 
 55 Each Host class has the form:
 56 
 57   public class Host {
 58     public static String getID() { return &quot;&lt;directory name&gt;/Host.java&quot;; }
 59 
 60     &lt; zero or more empty nested classes&gt;
 61 
 62     public int m() {
 63         return 1; // original class
 64     }
 65   }
 66 
 67 Under each directory is a directory &quot;redef&quot; with a modified version of the Host
 68 class that changes the ID to e.g. Host/redef/Host.java, and the method m()
 69 returns 2. This allows us to check we have the redefined class loaded.
 70 
 71 Using Host&#39; to represent the redefined version we test redefinition
 72 combinations as follows:
 73 
 74 Host:
 75   Host -&gt; Host&#39;  - succeeds m() returns 2
 76   Host -&gt; HostA&#39; - fails - added a nest member
 77 
 78 HostA:
 79   HostA -&gt; HostA&#39;  - succeeds m() returns 2
 80   HostA -&gt; Host&#39;   - fails - removed a nest member
 81   HostA -&gt; HostAB&#39; - fails - added a nest member
 82   HostA -&gt; HostB&#39;  - fails - replaced a nest member
 83 
 84 HostAB:
 85   HostAB -&gt; HostAB&#39;  - succeeds m() returns 2
 86   HostAB -&gt; HostBA&#39;  - succeeds m() returns 2
 87   HostAB -&gt; HostA&#39;   - fails - removed a nest member
 88   HostAB -&gt; HostABC&#39; - fails - added a nest member
 89   HostAB -&gt; HostAC&#39;  - fails - replaced a nest member
 90 
 91 HostABC:
 92   HostABC -&gt; HostABC&#39;  - succeeds m() returns 2
 93   HostABC -&gt; HostACB&#39;  - succeeds m() returns 2
 94   HostABC -&gt; HostBAC&#39;  - succeeds m() returns 2
 95   HostABC -&gt; HostBCA&#39;  - succeeds m() returns 2
 96   HostABC -&gt; HostCAB&#39;  - succeeds m() returns 2
 97   HostABC -&gt; HostCBA&#39;  - succeeds m() returns 2
 98   HostABC -&gt; HostAB&#39;   - fails - removed a nest member
 99   HostABC -&gt; HostABCD&#39; - fails - added a nest member
100   HostABC -&gt; HostABD&#39;  - fails - replaced a nest member
101 
102 More than three nested classes doesn&#39;t add to the code coverage so
103 we stop here.
104 
105 Note that we always try to load the redefined version even when we expect it
106 to fail.
107 
108 We can only directly load one class Host per classloader, so to run all the
109 groups we either need to use new classloaders, or we reinvoke the test
110 requesting a different primary directory. We chose the latter using
111 multiple @run tags. So we preceed as follows:
112 
113  @compile Host/Host.java
114  @run TestNestmateAttr Host
115  @compile HostA/Host.java  - replaces previous Host.class
116  @run TestNestmateAttr HostA
117  @compile HostAB/Host.java  - replaces previous Host.class
118  @run TestNestmateAttr HostAB
119 etc.
120 
121 Within the test we directly compile redefined versions of the classes,
122 using CompilerUtil, and then read the .class file directly as a byte[]
123 to use with the RedefineClassHelper.
124 
125 Finally we test redefinition of the NestHost attribute - which is
126 conceptually simple, but in fact very tricky to do. We do that
127 when testing HostA so we can reuse the Host$A class.
128 
129 */
130 
131 import java.io.File;
132 import java.io.FileInputStream;
133 import jdk.test.lib.ByteCodeLoader;
134 import jdk.test.lib.compiler.CompilerUtils;
135 import jdk.test.lib.compiler.InMemoryJavaCompiler;
136 import static jdk.test.lib.Asserts.assertTrue;
137 
138 public class TestNestmateAttr {
139 
140     static final String SRC = System.getProperty(&quot;test.src&quot;);
141     static final String DEST = System.getProperty(&quot;test.classes&quot;);
142     static final boolean VERBOSE = Boolean.getBoolean(&quot;verbose&quot;);
143 
144     public static void main(String[] args) throws Throwable {
145         String origin = args[0];
146         System.out.println(&quot;Testing original Host class from &quot; + origin);
147 
148         // Make sure the Host class loaded directly is an original version
149         // and from the expected location
150         Host h = new Host();
151         assertTrue(h.m() == 1);
152         assertTrue(Host.getID().startsWith(origin + &quot;/&quot;));
153 
154         String[] badTransforms;  // directories of bad classes
155         String[] goodTransforms; // directories of good classes
156 
157         boolean testNestHostChanges = false;
158 
159         switch (origin) {
160         case &quot;Host&quot;:
161             badTransforms = new String[] {
162                 &quot;HostA&quot; // add member
163             };
164             goodTransforms = new String[] {
165                 origin
166             };
167             break;
168 
169         case &quot;HostA&quot;:
170             badTransforms = new String[] {
171                 &quot;Host&quot;,   // remove member
172                 &quot;HostAB&quot;, // add member
173                 &quot;HostB&quot;   // change member
174             };
175             goodTransforms = new String[] {
176                 origin
177             };
178             testNestHostChanges = true;
179             break;
180 
181         case &quot;HostAB&quot;:
182             badTransforms = new String[] {
183                 &quot;HostA&quot;,   // remove member
184                 &quot;HostABC&quot;, // add member
185                 &quot;HostAC&quot;   // change member
186             };
187             goodTransforms = new String[] {
188                 origin,
189                 &quot;HostBA&quot;  // reorder members
190             };
191             break;
192 
193         case &quot;HostABC&quot;:
194             badTransforms = new String[] {
195                 &quot;HostAB&quot;,   // remove member
196                 &quot;HostABCD&quot;, // add member
197                 &quot;HostABD&quot;   // change member
198             };
199             goodTransforms = new String[] {
200                 origin,
201                 &quot;HostACB&quot;,  // reorder members
202                 &quot;HostBAC&quot;,  // reorder members
203                 &quot;HostBCA&quot;,  // reorder members
204                 &quot;HostCAB&quot;,  // reorder members
205                 &quot;HostCBA&quot;   // reorder members
206             };
207             break;
208 
209         default: throw new Error(&quot;Unknown test directory: &quot; + origin);
210         }
211 
212         // Compile and check bad transformations
213         checkBadTransforms(Host.class, badTransforms);
214 
215         // Compile and check good transformations
216         checkGoodTransforms(Host.class, goodTransforms);
217 
218         if (testNestHostChanges)
219             checkNestHostChanges();
220     }
221 
222     static void checkNestHostChanges() throws Throwable {
223         // case 1: remove NestHost attribute
224         //   - try to redefine Host$A with a top-level
225         //     class called Host$A
226         System.out.println(&quot;Trying bad retransform that removes the NestHost attribute&quot;);
227 
228         String name = &quot;Host$A&quot;;
229         // This is compiled as a top-level class: the $ in the name is not
230         // significant to the compiler.
231         String hostA = &quot;public class &quot; + name + &quot; {}&quot;;
232 
233         // Have to do this reflectively as there is no Host$A
234         // when compiling the &quot;Host/&quot; case.
235         Class&lt;?&gt; nestedA = Class.forName(name);
236 
237         try {
238             RedefineClassHelper.redefineClass(nestedA, hostA);
239             throw new Error(&quot;Retransformation to top-level class &quot; + name +
240                             &quot; succeeded unexpectedly&quot;);
241         }
242         catch (UnsupportedOperationException uoe) {
243             if (uoe.getMessage().contains(&quot;attempted to change the class Nest&quot;)) {
244                 System.out.println(&quot;Got expected exception &quot; + uoe);
245             }
246             else throw new Error(&quot;Wrong UnsupportedOperationException&quot;, uoe);
247         }
248 
249         // case 2: add NestHost attribute
250         //  - This is tricky because the class with no NestHost attribute
251         //    has to have the name of a nested class! Plus we need the
252         //    redefining class in bytecode form.
253         //  - Use the InMemoryJavaCompiler plus ByteCodeLoader to load
254         //    the top-level Host$A class
255         //  - Try to redefine that class with a real nested Host$A
256 
257         System.out.println(&quot;Trying bad retransform that adds the NestHost attribute&quot;);
258         byte[] bytes = InMemoryJavaCompiler.compile(name, hostA);
259         Class&lt;?&gt; topLevelHostA = ByteCodeLoader.load(name, bytes);
260 
261         byte[] nestedBytes;
262         File clsfile = new File(DEST + &quot;/&quot; + name + &quot;.class&quot;);
263         if (VERBOSE) System.out.println(&quot;Reading bytes from &quot; + clsfile);
264         try (FileInputStream str = new FileInputStream(clsfile)) {
265             nestedBytes = NamedBuffer.loadBufferFromStream(str);
266         }
267         try {
268             RedefineClassHelper.redefineClass(topLevelHostA, nestedBytes);
269             throw new Error(&quot;Retransformation to nested class &quot; + name +
270                             &quot; succeeded unexpectedly&quot;);
271         }
272         catch (UnsupportedOperationException uoe) {
273             if (uoe.getMessage().contains(&quot;attempted to change the class Nest&quot;)) {
274                 System.out.println(&quot;Got expected exception &quot; + uoe);
275             }
276             else throw new Error(&quot;Wrong UnsupportedOperationException&quot;, uoe);
277         }
278 
279         // case 3: replace the NestHost attribute
280         //  - the easiest way (perhaps only reasonable way) to do this
281         //    is to search for the Utf8 entry used by the Constant_ClassRef,
282         //    set in the NestHost attribute, and edit it to refer to a different
283         //    name.
284         System.out.println(&quot;Trying bad retransform that changes the NestHost attribute&quot;);
285         int utf8Entry_length = 7;
286         boolean found = false;
287         for (int i = 0; i &lt; nestedBytes.length - utf8Entry_length; i++) {
288             if (nestedBytes[i] == 1 &amp;&amp;   // utf8 tag
289                 nestedBytes[i+1] == 0 &amp;&amp; // msb of length
290                 nestedBytes[i+2] == 4 &amp;&amp; // lsb of length
291                 nestedBytes[i+3] == (byte) &#39;H&#39; &amp;&amp;
292                 nestedBytes[i+4] == (byte) &#39;o&#39; &amp;&amp;
293                 nestedBytes[i+5] == (byte) &#39;s&#39; &amp;&amp;
294                 nestedBytes[i+6] == (byte) &#39;t&#39;) {
295 
296                 if (VERBOSE) System.out.println(&quot;Appear to have found Host utf8 entry starting at &quot; + i);
297 
298                 nestedBytes[i+3] = (byte) &#39;G&#39;;
299                 found = true;
300                 break;
301             }
302         }
303 
304         if (!found)
305             throw new Error(&quot;Could not locate &#39;Host&#39; name in byte array&quot;);
306 
307         try {
308             RedefineClassHelper.redefineClass(nestedA, nestedBytes);
309             throw new Error(&quot;Retransformation to modified nested class&quot; +
310                             &quot; succeeded unexpectedly&quot;);
311         }
312         catch (UnsupportedOperationException uoe) {
313             if (uoe.getMessage().contains(&quot;attempted to change the class Nest&quot;)) {
314                 System.out.println(&quot;Got expected exception &quot; + uoe);
315             }
316             else throw new Error(&quot;Wrong UnsupportedOperationException&quot;, uoe);
317         }
318 
319     }
320 
321     static void checkGoodTransforms(Class&lt;?&gt; c, String[] dirs) throws Throwable {
322         for (String dir : dirs) {
323             dir += &quot;/redef&quot;;
324             System.out.println(&quot;Trying good retransform from &quot; + dir);
325             byte[] buf = bytesForHostClass(dir);
326             RedefineClassHelper.redefineClass(c, buf);
327 
328             // Test redefintion worked
329             Host h = new Host();
330             assertTrue(h.m() == 2);
331             if (VERBOSE) System.out.println(&quot;Redefined ID: &quot; + Host.getID());
332             assertTrue(Host.getID().startsWith(dir));
333         }
334     }
335 
336     static void checkBadTransforms(Class&lt;?&gt; c, String[] dirs) throws Throwable {
337         for (String dir : dirs) {
338             dir += &quot;/redef&quot;;
339             System.out.println(&quot;Trying bad retransform from &quot; + dir);
340             byte[] buf = bytesForHostClass(dir);
341             try {
342                 RedefineClassHelper.redefineClass(c, buf);
343                 throw new Error(&quot;Retransformation from directory &quot; + dir +
344                                 &quot; succeeded unexpectedly&quot;);
345             }
346             catch (UnsupportedOperationException uoe) {
347                 if (uoe.getMessage().contains(&quot;attempted to change the class Nest&quot;)) {
348                     System.out.println(&quot;Got expected exception &quot; + uoe);
349                 }
350                 else throw new Error(&quot;Wrong UnsupportedOperationException&quot;, uoe);
351             }
352         }
353     }
354 
355     static byte[] bytesForHostClass(String dir) throws Throwable {
356         compile(&quot;/&quot; + dir);
357         File clsfile = new File(DEST + &quot;/&quot; + dir + &quot;/Host.class&quot;);
358         if (VERBOSE) System.out.println(&quot;Reading bytes from &quot; + clsfile);
359         byte[] buf = null;
360         try (FileInputStream str = new FileInputStream(clsfile)) {
361             return buf = NamedBuffer.loadBufferFromStream(str);
362         }
363     }
364 
365     static void compile(String dir) throws Throwable {
366         File src = new File(SRC + dir);
367         File dst = new File(DEST + dir);
368         if (VERBOSE) System.out.println(&quot;Compiling from: &quot; + src + &quot;\n&quot; +
369                                         &quot;            to: &quot; + dst);
370         CompilerUtils.compile(src.toPath(),
371                               dst.toPath(),
372                               false /* don&#39;t recurse */,
373                               new String[0]);
374     }
375 }
<a name="3" id="anc3"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="3" type="hidden" />
</body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New test/jdk/java/lang/System/LoggerFinder/jdk/DefaultLoggerBridgeTest/DefaultLoggerBridgeTest.java</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2015, 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 import java.security.AccessControlException;
 24 import java.security.CodeSource;
 25 import java.security.Permission;
 26 import java.security.PermissionCollection;
 27 import java.security.Permissions;
 28 import java.security.Policy;
 29 import java.security.ProtectionDomain;
 30 import java.util.Arrays;
 31 import java.util.Collections;
 32 import java.util.Enumeration;
 33 import java.util.HashMap;
 34 import java.util.Map;
 35 import java.util.Objects;
 36 import java.util.Queue;
 37 import java.util.ResourceBundle;
 38 import java.util.concurrent.ArrayBlockingQueue;
 39 import java.util.concurrent.ConcurrentHashMap;
 40 import java.util.concurrent.atomic.AtomicBoolean;
 41 import java.util.concurrent.atomic.AtomicLong;
 42 import java.util.function.Supplier;
 43 import java.util.logging.Handler;
 44 import java.util.logging.LogManager;
 45 import sun.util.logging.PlatformLogger;
 46 import java.util.logging.LogRecord;
 47 import java.lang.System.LoggerFinder;
 48 import java.lang.System.Logger;
 49 import java.util.stream.Stream;
 50 import sun.util.logging.internal.LoggingProviderImpl;
 51 
 52 /**
 53  * @test
 54  * @bug     8140364
 55  * @summary JDK implementation specific unit test for JDK internal artifacts.
 56  *          Tests all internal bridge methods with the default LoggerFinder
 57  *          JUL backend.
 58  * @modules java.base/sun.util.logging
 59  *          java.base/jdk.internal.logger
 60  *          java.logging/sun.util.logging.internal
 61  * @run  main/othervm DefaultLoggerBridgeTest NOSECURITY
 62  * @run  main/othervm DefaultLoggerBridgeTest NOPERMISSIONS
 63  * @run  main/othervm DefaultLoggerBridgeTest WITHPERMISSIONS
 64  * @author danielfuchs
 65  */
 66 public class DefaultLoggerBridgeTest {
 67 
 68     final static AtomicLong sequencer = new AtomicLong();
 69     final static boolean VERBOSE = false;
 70     static final ThreadLocal&lt;AtomicBoolean&gt; allowControl = new ThreadLocal&lt;AtomicBoolean&gt;() {
 71         @Override
 72         protected AtomicBoolean initialValue() {
 73             return  new AtomicBoolean(false);
 74         }
 75     };
 76     static final ThreadLocal&lt;AtomicBoolean&gt; allowAccess = new ThreadLocal&lt;AtomicBoolean&gt;() {
 77         @Override
 78         protected AtomicBoolean initialValue() {
 79             return  new AtomicBoolean(false);
 80         }
 81     };
 82     static final ThreadLocal&lt;AtomicBoolean&gt; allowAll = new ThreadLocal&lt;AtomicBoolean&gt;() {
 83         @Override
 84         protected AtomicBoolean initialValue() {
 85             return  new AtomicBoolean(false);
 86         }
 87     };
 88 
 89     public static final Queue&lt;LogEvent&gt; eventQueue = new ArrayBlockingQueue&lt;&gt;(128);
 90 
 91     public static final class LogEvent implements Cloneable {
 92 
 93         public LogEvent() {
 94             this(sequencer.getAndIncrement());
 95         }
 96 
 97         LogEvent(long sequenceNumber) {
 98             this.sequenceNumber = sequenceNumber;
 99         }
100 
101         long sequenceNumber;
102         boolean isLoggable;
103         String loggerName;
104         java.util.logging.Level level;
105         ResourceBundle bundle;
106         Throwable thrown;
107         Object[] args;
108         String msg;
109         String className;
110         String methodName;
111 
112         Object[] toArray() {
113             return new Object[] {
114                 sequenceNumber,
115                 isLoggable,
116                 loggerName,
117                 level,
118                 bundle,
119                 thrown,
120                 args,
121                 msg,
122                 className,
123                 methodName,
124             };
125         }
126 
127         @Override
128         public String toString() {
129             return Arrays.deepToString(toArray());
130         }
131 
132         @Override
133         public boolean equals(Object obj) {
134             return obj instanceof LogEvent
135                     &amp;&amp; Objects.deepEquals(this.toArray(), ((LogEvent)obj).toArray());
136         }
137 
138         @Override
139         public int hashCode() {
140             return Objects.hash(toArray());
141         }
142 
143         public LogEvent cloneWith(long sequenceNumber)
144                 throws CloneNotSupportedException {
145             LogEvent cloned = (LogEvent)super.clone();
146             cloned.sequenceNumber = sequenceNumber;
147             return cloned;
148         }
149 
150         public static LogEvent of(long sequenceNumber,
151                 boolean isLoggable, String name,
152                 java.util.logging.Level level, ResourceBundle bundle,
153                 String key, Throwable thrown, Object... params) {
154             return LogEvent.of(sequenceNumber, isLoggable, name,
155                     DefaultLoggerBridgeTest.class.getName(),
156                     &quot;testLogger&quot;, level, bundle, key,
157                     thrown, params);
158         }
159         public static LogEvent of(long sequenceNumber,
160                 boolean isLoggable, String name,
161                 String className, String methodName,
162                 java.util.logging.Level level, ResourceBundle bundle,
163                 String key, Throwable thrown, Object... params) {
164             LogEvent evt = new LogEvent(sequenceNumber);
165             evt.loggerName = name;
166             evt.level = level;
167             evt.args = params;
168             evt.bundle = bundle;
169             evt.thrown = thrown;
170             evt.msg = key;
171             evt.isLoggable = isLoggable;
172             evt.className = className;
173             evt.methodName = methodName;
174             return evt;
175         }
176 
177     }
178 
179     static final java.util.logging.Level[] julLevels = {
180         java.util.logging.Level.ALL,
181         java.util.logging.Level.FINEST,
182         java.util.logging.Level.FINER,
183         java.util.logging.Level.FINE,
184         java.util.logging.Level.CONFIG,
185         java.util.logging.Level.INFO,
186         java.util.logging.Level.WARNING,
187         java.util.logging.Level.SEVERE,
188         java.util.logging.Level.OFF,
189     };
190 
191 
192     public static class MyBundle extends ResourceBundle {
193 
194         final ConcurrentHashMap&lt;String, String&gt; map = new ConcurrentHashMap&lt;&gt;();
195 
196         @Override
197         protected Object handleGetObject(String key) {
198             if (key.contains(&quot; (translated)&quot;)) {
199                 throw new RuntimeException(&quot;Unexpected key: &quot; + key);
200             }
201             return map.computeIfAbsent(key, k -&gt; k + &quot; (translated)&quot;);
202         }
203 
204         @Override
205         public Enumeration&lt;String&gt; getKeys() {
206             return Collections.enumeration(map.keySet());
207         }
208 
209     }
210 
211     public static class MyHandler extends Handler {
212 
213         @Override
214         public java.util.logging.Level getLevel() {
215             return java.util.logging.Level.ALL;
216         }
217 
218         @Override
219         public void publish(LogRecord record) {
220             eventQueue.add(LogEvent.of(sequencer.getAndIncrement(),
221                     true, record.getLoggerName(),
222                     record.getSourceClassName(),
223                     record.getSourceMethodName(),
224                     record.getLevel(),
225                     record.getResourceBundle(), record.getMessage(),
226                     record.getThrown(), record.getParameters()));
227         }
228         @Override
229         public void flush() {
230         }
231         @Override
232         public void close() throws SecurityException {
233         }
234 
235     }
236 
237     public static class MyLoggerBundle extends MyBundle {
238 
239     }
240 
241     static PlatformLogger.Bridge convert(Logger logger) {
242         boolean old = allowAccess.get().get();
243         allowAccess.get().set(true);
244         try {
245             return PlatformLogger.Bridge.convert(logger);
246         } finally {
247             allowAccess.get().set(old);
248         }
249     }
250 
251     static Logger getLogger(String name, Module caller) {
252         boolean old = allowAccess.get().get();
253         allowAccess.get().set(true);
254         try {
255             return jdk.internal.logger.LazyLoggers.getLogger(name, caller);
256         } finally {
257             allowAccess.get().set(old);
258         }
259     }
260 
261     static enum TestCases {NOSECURITY, NOPERMISSIONS, WITHPERMISSIONS};
262 
263     static void setSecurityManager() {
264         if (System.getSecurityManager() == null) {
265             Policy.setPolicy(new SimplePolicy(allowControl, allowAccess, allowAll));
266             System.setSecurityManager(new SecurityManager());
267         }
268     }
269 
270     public static void main(String[] args) {
271         if (args.length == 0)
272             args = new String[] {
273                 &quot;NOSECURITY&quot;,
274                 &quot;NOPERMISSIONS&quot;,
275                 &quot;WITHPERMISSIONS&quot;
276             };
277 
278         Stream.of(args).map(TestCases::valueOf).forEach((testCase) -&gt; {
279             switch (testCase) {
280                 case NOSECURITY:
281                     System.out.println(&quot;\n*** Without Security Manager\n&quot;);
282                     test(true);
283                     System.out.println(&quot;Tetscase count: &quot; + sequencer.get());
284                     break;
285                 case NOPERMISSIONS:
286                     System.out.println(&quot;\n*** With Security Manager, without permissions\n&quot;);
287                     setSecurityManager();
288                     test(false);
289                     System.out.println(&quot;Tetscase count: &quot; + sequencer.get());
290                     break;
291                 case WITHPERMISSIONS:
292                     System.out.println(&quot;\n*** With Security Manager, with control permission\n&quot;);
293                     setSecurityManager();
294                     final boolean control = allowControl.get().get();
295                     try {
296                         allowControl.get().set(true);
297                         test(true);
298                     } finally {
299                         allowControl.get().set(control);
300                     }
301                     break;
302                 default:
303                     throw new RuntimeException(&quot;Unknown test case: &quot; + testCase);
304             }
305         });
306         System.out.println(&quot;\nPASSED: Tested &quot; + sequencer.get() + &quot; cases.&quot;);
307     }
308 
309     public static void test(boolean hasRequiredPermissions) {
310 
311         ResourceBundle loggerBundle =
312                 ResourceBundle.getBundle(MyLoggerBundle.class.getName());
313         final Map&lt;Object, String&gt; loggerDescMap = new HashMap&lt;&gt;();
314 
315         Logger sysLogger1a = getLogger(&quot;foo&quot;, Thread.class.getModule());
316         loggerDescMap.put(sysLogger1a, &quot;jdk.internal.logger.LazyLoggers.getLogger(\&quot;foo\&quot;, Thread.class.getModule())&quot;);
317 
318         Logger appLogger1 = System.getLogger(&quot;foo&quot;);
319         loggerDescMap.put(appLogger1, &quot;System.getLogger(\&quot;foo\&quot;)&quot;);
320 
321         LoggerFinder provider;
322         try {
323             provider = LoggerFinder.getLoggerFinder();
324             if (!hasRequiredPermissions) {
325                 throw new RuntimeException(&quot;Expected exception not raised&quot;);
326             }
327         } catch (AccessControlException x) {
328             if (hasRequiredPermissions) {
329                 throw new RuntimeException(&quot;Unexpected permission check&quot;, x);
330             }
331             if (!SimplePolicy.LOGGERFINDER_PERMISSION.equals(x.getPermission())) {
332                 throw new RuntimeException(&quot;Unexpected permission in exception: &quot; + x, x);
333             }
334             final boolean control = allowControl.get().get();
335             try {
336                 allowControl.get().set(true);
337                 provider = LoggerFinder.getLoggerFinder();
338             } finally {
339                 allowControl.get().set(control);
340             }
341         }
342 
343         Logger sysLogger1b = null;
344         try {
345             sysLogger1b = provider.getLogger(&quot;foo&quot;, Thread.class.getModule());
346             if (sysLogger1b != sysLogger1a) {
347                 loggerDescMap.put(sysLogger1b, &quot;provider.getLogger(\&quot;foo\&quot;, Thread.class.getModule())&quot;);
348             }
349             if (!hasRequiredPermissions) {
350                 throw new RuntimeException(&quot;Managed to obtain a system logger without permission&quot;);
351             }
352         } catch (AccessControlException acx) {
353             if (hasRequiredPermissions) {
354                 throw new RuntimeException(&quot;Unexpected security exception: &quot;, acx);
355             }
356             if (!acx.getPermission().equals(SimplePolicy.LOGGERFINDER_PERMISSION)) {
357                 throw new RuntimeException(&quot;Unexpected permission in exception: &quot; + acx, acx);
358             }
359             System.out.println(&quot;Got expected exception for system logger: &quot; + acx);
360         }
361 
362         Logger appLogger2 = System.getLogger(&quot;foo&quot;, loggerBundle);
363         loggerDescMap.put(appLogger2, &quot;System.getLogger(\&quot;foo\&quot;, loggerBundle)&quot;);
364 
365         if (appLogger2 == appLogger1) {
366             throw new RuntimeException(&quot;identical loggers&quot;);
367         }
368 
369         Logger sysLogger2 = null;
370         try {
371             sysLogger2 = provider.getLocalizedLogger(&quot;foo&quot;, loggerBundle, Thread.class.getModule());
372             loggerDescMap.put(sysLogger2, &quot;provider.getLocalizedLogger(\&quot;foo\&quot;, loggerBundle, Thread.class.getModule())&quot;);
373             if (!hasRequiredPermissions) {
374                 throw new RuntimeException(&quot;Managed to obtain a system logger without permission&quot;);
375             }
376         } catch (AccessControlException acx) {
377             if (hasRequiredPermissions) {
378                 throw new RuntimeException(&quot;Unexpected security exception: &quot;, acx);
379             }
380             if (!acx.getPermission().equals(SimplePolicy.LOGGERFINDER_PERMISSION)) {
381                 throw new RuntimeException(&quot;Unexpected permission in exception: &quot; + acx, acx);
382             }
383             System.out.println(&quot;Got expected exception for localized system logger: &quot; + acx);
384         }
385         if (hasRequiredPermissions &amp;&amp; appLogger2 == sysLogger2) {
386             throw new RuntimeException(&quot;identical loggers&quot;);
387         }
388         if (hasRequiredPermissions &amp;&amp; sysLogger2 == sysLogger1a) {
389             throw new RuntimeException(&quot;identical loggers&quot;);
390         }
391 
392         final java.util.logging.Logger sink;
393         final java.util.logging.Logger appSink;
394         final java.util.logging.Logger sysSink;
395         final MyHandler appHandler;
396         final MyHandler sysHandler;
397         final boolean old = allowAll.get().get();
398         allowAll.get().set(true);
399         try {
400             appSink = LoggingProviderImpl.getLogManagerAccess().demandLoggerFor(
401                     LogManager.getLogManager(), &quot;foo&quot;, DefaultLoggerBridgeTest.class.getModule());
402             sysSink = LoggingProviderImpl.getLogManagerAccess().demandLoggerFor(
403                     LogManager.getLogManager(), &quot;foo&quot;, Thread.class.getModule());
404             if (appSink == sysSink) {
405                 throw new RuntimeException(&quot;identical backend loggers&quot;);
406             }
407             sink = java.util.logging.Logger.getLogger(&quot;foo&quot;);
408             if (appSink != sink) {
409                 throw new RuntimeException(&quot;expected same application logger&quot;);
410             }
411 
412             sink.addHandler(appHandler = sysHandler = new MyHandler());
413             sink.setUseParentHandlers(VERBOSE);
414         } finally {
415             allowAll.get().set(old);
416         }
417 
418         try {
419             testLogger(provider, loggerDescMap, &quot;foo&quot;, null, convert(sysLogger1a), sysSink);
420             testLogger(provider, loggerDescMap, &quot;foo&quot;, null, convert(appLogger1), appSink);
421             testLogger(provider, loggerDescMap, &quot;foo&quot;, loggerBundle, convert(appLogger2), appSink);
422             if (sysLogger1b != null &amp;&amp; sysLogger1b != sysLogger1a) {
423                 testLogger(provider, loggerDescMap, &quot;foo&quot;, null, convert(sysLogger1b), sysSink);
424             }
425             if (sysLogger2 != null) {
426                 testLogger(provider, loggerDescMap, &quot;foo&quot;, loggerBundle, convert(sysLogger2), sysSink);
427             }
428         } finally {
429             allowAll.get().set(true);
430             try {
431                 appSink.removeHandler(appHandler);
432                 sysSink.removeHandler(sysHandler);
433             } finally {
434                 allowAll.get().set(old);
435             }
436         }
437     }
438 
439     public static class Foo {
440 
441     }
442 
443     static void verbose(String msg) {
444        if (VERBOSE) {
445            System.out.println(msg);
446        }
447     }
448 
449     static void checkLogEvent(LoggerFinder provider, String desc,
450             LogEvent expected) {
451         LogEvent actual =  eventQueue.poll();
452         if (!expected.equals(actual)) {
453             throw new RuntimeException(&quot;mismatch for &quot; + desc
454                     + &quot;\n\texpected=&quot; + expected
455                     + &quot;\n\t  actual=&quot; + actual);
456         } else {
457             verbose(&quot;Got expected results for &quot;
458                     + desc + &quot;\n\t&quot; + expected);
459         }
460     }
461 
462     static void checkLogEvent(LoggerFinder provider, String desc,
463             LogEvent expected, boolean expectNotNull) {
464         LogEvent actual =  eventQueue.poll();
465         if (actual == null &amp;&amp; !expectNotNull) return;
466         if (actual != null &amp;&amp; !expectNotNull) {
467             throw new RuntimeException(&quot;Unexpected log event found for &quot; + desc
468                 + &quot;\n\tgot: &quot; + actual);
469         }
470         if (!expected.equals(actual)) {
471             throw new RuntimeException(&quot;mismatch for &quot; + desc
472                     + &quot;\n\texpected=&quot; + expected
473                     + &quot;\n\t  actual=&quot; + actual);
474         } else {
475             verbose(&quot;Got expected results for &quot;
476                     + desc + &quot;\n\t&quot; + expected);
477         }
478     }
479 
480     static void setLevel(java.util.logging.Logger sink, java.util.logging.Level loggerLevel) {
481         boolean before = allowAll.get().get();
482         try {
483             allowAll.get().set(true);
484             sink.setLevel(loggerLevel);
485         } finally {
486             allowAll.get().set(before);
487         }
488     }
489 
490     static sun.util.logging.PlatformLogger.Level toPlatformLevel(java.util.logging.Level level) {
491         boolean old = allowAccess.get().get();
492         allowAccess.get().set(true);
493         try {
494             return sun.util.logging.PlatformLogger.Level.valueOf(level.getName());
495         } finally {
496             allowAccess.get().set(old);
497         }
498     }
499 
500     // Calls the methods defined on LogProducer and verify the
501     // parameters received by the underlying logger.
502     private static void testLogger(LoggerFinder provider,
503             Map&lt;Object, String&gt; loggerDescMap,
504             String name,
505             ResourceBundle loggerBundle,
506             PlatformLogger.Bridge logger,
507             java.util.logging.Logger sink) {
508 
509         if (loggerDescMap.get(logger) == null) {
510             throw new RuntimeException(&quot;Missing description for &quot; + logger);
511         }
512         System.out.println(&quot;Testing &quot; + loggerDescMap.get(logger) + &quot; [&quot; + logger + &quot;]&quot;);
513         final java.util.logging.Level OFF = java.util.logging.Level.OFF;
514 
515         Foo foo = new Foo();
516         String fooMsg = foo.toString();
517         System.out.println(&quot;\tlogger.log(messageLevel, fooMsg)&quot;);
518         System.out.println(&quot;\tlogger.&lt;level&gt;(fooMsg)&quot;);
519         for (java.util.logging.Level loggerLevel : julLevels) {
520             setLevel(sink, loggerLevel);
521             for (java.util.logging.Level messageLevel :julLevels) {
522                 String desc = &quot;logger.log(messageLevel, fooMsg): loggerLevel=&quot;
523                         + loggerLevel+&quot;, messageLevel=&quot;+messageLevel;
524                 LogEvent expected =
525                         LogEvent.of(
526                             sequencer.get(),
527                             loggerLevel != OFF &amp;&amp; messageLevel.intValue() &gt;= loggerLevel.intValue(),
528                             name, messageLevel, loggerBundle,
529                             fooMsg, (Throwable)null, (Object[])null);
530                 logger.log(toPlatformLevel(messageLevel), fooMsg);
531                 checkLogEvent(provider, desc, expected, expected.isLoggable);
532             }
533         }
534 
535         Supplier&lt;String&gt; supplier = new Supplier&lt;String&gt;() {
536             @Override
537             public String get() {
538                 return this.toString();
539             }
540         };
541         System.out.println(&quot;\tlogger.log(messageLevel, supplier)&quot;);
542         System.out.println(&quot;\tlogger.&lt;level&gt;(supplier)&quot;);
543         for (java.util.logging.Level loggerLevel : julLevels) {
544             setLevel(sink, loggerLevel);
545             for (java.util.logging.Level messageLevel :julLevels) {
546                 String desc = &quot;logger.log(messageLevel, supplier): loggerLevel=&quot;
547                         + loggerLevel+&quot;, messageLevel=&quot;+messageLevel;
548                 LogEvent expected =
549                         LogEvent.of(
550                             sequencer.get(),
551                             loggerLevel != OFF &amp;&amp; messageLevel.intValue() &gt;= loggerLevel.intValue(),
552                             name, messageLevel, null,
553                             supplier.get(), (Throwable)null, (Object[])null);
554                 logger.log(toPlatformLevel(messageLevel), supplier);
555                 checkLogEvent(provider, desc, expected, expected.isLoggable);
556             }
557         }
558 
559         String format = &quot;two params [{1} {2}]&quot;;
560         Object arg1 = foo;
561         Object arg2 = fooMsg;
562         System.out.println(&quot;\tlogger.log(messageLevel, format, arg1, arg2)&quot;);
563         for (java.util.logging.Level loggerLevel : julLevels) {
564             setLevel(sink, loggerLevel);
565             for (java.util.logging.Level messageLevel :julLevels) {
566                 String desc = &quot;logger.log(messageLevel, format, foo, fooMsg): loggerLevel=&quot;
567                         + loggerLevel+&quot;, messageLevel=&quot;+messageLevel;
568                 LogEvent expected =
569                         LogEvent.of(
570                             sequencer.get(),
571                             loggerLevel != OFF &amp;&amp; messageLevel.intValue() &gt;= loggerLevel.intValue(),
572                             name, messageLevel, loggerBundle,
573                             format, (Throwable)null, arg1, arg2);
574                 logger.log(toPlatformLevel(messageLevel), format, arg1, arg2);
575                 checkLogEvent(provider, desc, expected, expected.isLoggable);
576             }
577         }
578 
579         Throwable thrown = new Exception(&quot;OK: log me!&quot;);
580         System.out.println(&quot;\tlogger.log(messageLevel, fooMsg, thrown)&quot;);
581         for (java.util.logging.Level loggerLevel : julLevels) {
582             setLevel(sink, loggerLevel);
583             for (java.util.logging.Level messageLevel :julLevels) {
584                 String desc = &quot;logger.log(messageLevel, fooMsg, thrown): loggerLevel=&quot;
585                         + loggerLevel+&quot;, messageLevel=&quot;+messageLevel;
586                 LogEvent expected =
587                         LogEvent.of(
588                             sequencer.get(),
589                             loggerLevel != OFF &amp;&amp; messageLevel.intValue() &gt;= loggerLevel.intValue(),
590                             name, messageLevel, loggerBundle,
591                             fooMsg, thrown, (Object[])null);
592                 logger.log(toPlatformLevel(messageLevel), fooMsg, thrown);
593                 checkLogEvent(provider, desc, expected, expected.isLoggable);
594             }
595         }
596 
597         System.out.println(&quot;\tlogger.log(messageLevel, thrown, supplier)&quot;);
598         for (java.util.logging.Level loggerLevel : julLevels) {
599             setLevel(sink, loggerLevel);
600             for (java.util.logging.Level messageLevel :julLevels) {
601                 String desc = &quot;logger.log(messageLevel, thrown, supplier): loggerLevel=&quot;
602                         + loggerLevel+&quot;, messageLevel=&quot;+messageLevel;
603                 LogEvent expected =
604                         LogEvent.of(
605                             sequencer.get(),
606                             loggerLevel != OFF &amp;&amp; messageLevel.intValue() &gt;= loggerLevel.intValue(),
607                             name, messageLevel, null,
608                             supplier.get(), thrown, (Object[])null);
609                 logger.log(toPlatformLevel(messageLevel), thrown, supplier);
610                 checkLogEvent(provider, desc, expected, expected.isLoggable);
611             }
612         }
613 
614         String sourceClass = &quot;blah.Blah&quot;;
615         String sourceMethod = &quot;blih&quot;;
616         System.out.println(&quot;\tlogger.logp(messageLevel, sourceClass, sourceMethod, fooMsg)&quot;);
617         for (java.util.logging.Level loggerLevel : julLevels) {
618             setLevel(sink, loggerLevel);
619             for (java.util.logging.Level messageLevel :julLevels) {
620                 String desc = &quot;logger.logp(messageLevel, sourceClass, sourceMethod, fooMsg): loggerLevel=&quot;
621                         + loggerLevel+&quot;, messageLevel=&quot;+messageLevel;
622                 LogEvent expected =
623                         LogEvent.of(
624                             sequencer.get(),
625                             loggerLevel != OFF &amp;&amp; messageLevel.intValue() &gt;= loggerLevel.intValue(),
626                             name, sourceClass, sourceMethod, messageLevel, loggerBundle,
627                             fooMsg, (Throwable)null, (Object[])null);
628                 logger.logp(toPlatformLevel(messageLevel), sourceClass, sourceMethod, fooMsg);
629                 checkLogEvent(provider, desc, expected, expected.isLoggable);
630             }
631         }
632 
633         System.out.println(&quot;\tlogger.logp(messageLevel, sourceClass, sourceMethod, supplier)&quot;);
634         for (java.util.logging.Level loggerLevel : julLevels) {
635             setLevel(sink, loggerLevel);
636             for (java.util.logging.Level messageLevel :julLevels) {
637                 String desc = &quot;logger.logp(messageLevel, sourceClass, sourceMethod, supplier): loggerLevel=&quot;
638                         + loggerLevel+&quot;, messageLevel=&quot;+messageLevel;
639                 LogEvent expected =
640                         LogEvent.of(
641                             sequencer.get(),
642                             loggerLevel != OFF &amp;&amp; messageLevel.intValue() &gt;= loggerLevel.intValue(),
643                             name, sourceClass, sourceMethod, messageLevel, null,
644                             supplier.get(), (Throwable)null, (Object[])null);
645                 logger.logp(toPlatformLevel(messageLevel), sourceClass, sourceMethod, supplier);
646                 checkLogEvent(provider, desc, expected, expected.isLoggable);
647             }
648         }
649 
650         System.out.println(&quot;\tlogger.logp(messageLevel, sourceClass, sourceMethod, format, arg1, arg2)&quot;);
651         for (java.util.logging.Level loggerLevel : julLevels) {
652             setLevel(sink, loggerLevel);
653             for (java.util.logging.Level messageLevel :julLevels) {
654                 String desc = &quot;logger.logp(messageLevel, sourceClass, sourceMethod, format, arg1, arg2): loggerLevel=&quot;
655                         + loggerLevel+&quot;, messageLevel=&quot;+messageLevel;
656                 LogEvent expected =
657                         LogEvent.of(
658                             sequencer.get(),
659                             loggerLevel != OFF &amp;&amp; messageLevel.intValue() &gt;= loggerLevel.intValue(),
660                             name, sourceClass, sourceMethod, messageLevel, loggerBundle,
661                             format, (Throwable)null, arg1, arg2);
662                 logger.logp(toPlatformLevel(messageLevel), sourceClass, sourceMethod, format, arg1, arg2);
663                 checkLogEvent(provider, desc, expected, expected.isLoggable);
664             }
665         }
666 
667         System.out.println(&quot;\tlogger.logp(messageLevel, sourceClass, sourceMethod, fooMsg, thrown)&quot;);
668         for (java.util.logging.Level loggerLevel : julLevels) {
669             setLevel(sink, loggerLevel);
670             for (java.util.logging.Level messageLevel :julLevels) {
671                 String desc = &quot;logger.logp(messageLevel, sourceClass, sourceMethod, fooMsg, thrown): loggerLevel=&quot;
672                         + loggerLevel+&quot;, messageLevel=&quot;+messageLevel;
673                 LogEvent expected =
674                         LogEvent.of(
675                             sequencer.get(),
676                             loggerLevel != OFF &amp;&amp; messageLevel.intValue() &gt;= loggerLevel.intValue(),
677                             name, sourceClass, sourceMethod, messageLevel, loggerBundle,
678                             fooMsg, thrown, (Object[])null);
679                 logger.logp(toPlatformLevel(messageLevel), sourceClass, sourceMethod, fooMsg, thrown);
680                 checkLogEvent(provider, desc, expected, expected.isLoggable);
681             }
682         }
683 
684         System.out.println(&quot;\tlogger.logp(messageLevel, sourceClass, sourceMethod, thrown, supplier)&quot;);
685         for (java.util.logging.Level loggerLevel : julLevels) {
686             setLevel(sink, loggerLevel);
687             for (java.util.logging.Level messageLevel :julLevels) {
688                 String desc = &quot;logger.logp(messageLevel, sourceClass, sourceMethod, thrown, supplier): loggerLevel=&quot;
689                         + loggerLevel+&quot;, messageLevel=&quot;+messageLevel;
690                 LogEvent expected =
691                         LogEvent.of(
692                             sequencer.get(),
693                             loggerLevel != OFF &amp;&amp; messageLevel.intValue() &gt;= loggerLevel.intValue(),
694                             name, sourceClass, sourceMethod, messageLevel, null,
695                             supplier.get(), thrown, (Object[])null);
696                 logger.logp(toPlatformLevel(messageLevel), sourceClass, sourceMethod, thrown, supplier);
697                 checkLogEvent(provider, desc, expected, expected.isLoggable);
698             }
699         }
700 
701         ResourceBundle bundle = ResourceBundle.getBundle(MyBundle.class.getName());
702         System.out.println(&quot;\tlogger.logrb(messageLevel, bundle, format, arg1, arg2)&quot;);
703         for (java.util.logging.Level loggerLevel : julLevels) {
704             setLevel(sink, loggerLevel);
705             for (java.util.logging.Level messageLevel :julLevels) {
706                 String desc = &quot;logger.logrb(messageLevel, bundle, format, arg1, arg2): loggerLevel=&quot;
707                         + loggerLevel+&quot;, messageLevel=&quot;+messageLevel;
708                 LogEvent expected =
709                         LogEvent.of(
710                             sequencer.get(),
711                             loggerLevel != OFF &amp;&amp; messageLevel.intValue() &gt;= loggerLevel.intValue(),
712                             name, messageLevel, bundle,
713                             format, (Throwable)null, arg1, arg2);
714                 logger.logrb(toPlatformLevel(messageLevel), bundle, format, arg1, arg2);
715                 checkLogEvent(provider, desc, expected, expected.isLoggable);
716             }
717         }
718 
719         System.out.println(&quot;\tlogger.logrb(messageLevel, bundle, msg, thrown)&quot;);
720         for (java.util.logging.Level loggerLevel : julLevels) {
721             setLevel(sink, loggerLevel);
722             for (java.util.logging.Level messageLevel :julLevels) {
723                 String desc = &quot;logger.logrb(messageLevel, bundle, msg, thrown): loggerLevel=&quot;
724                         + loggerLevel+&quot;, messageLevel=&quot;+messageLevel;
725                 LogEvent expected =
726                         LogEvent.of(
727                             sequencer.get(),
728                             loggerLevel != OFF &amp;&amp; messageLevel.intValue() &gt;= loggerLevel.intValue(),
729                             name, messageLevel, bundle,
730                             fooMsg, thrown, (Object[])null);
731                 logger.logrb(toPlatformLevel(messageLevel), bundle, fooMsg, thrown);
732                 checkLogEvent(provider, desc, expected, expected.isLoggable);
733             }
734         }
735 
736         System.out.println(&quot;\tlogger.logrb(messageLevel, sourceClass, sourceMethod, bundle, format, arg1, arg2)&quot;);
737         for (java.util.logging.Level loggerLevel : julLevels) {
738             setLevel(sink, loggerLevel);
739             for (java.util.logging.Level messageLevel :julLevels) {
740                 String desc = &quot;logger.logrb(messageLevel, sourceClass, sourceMethod, bundle, format, arg1, arg2): loggerLevel=&quot;
741                         + loggerLevel+&quot;, messageLevel=&quot;+messageLevel;
742                 LogEvent expected =
743                         LogEvent.of(
744                             sequencer.get(),
745                             loggerLevel != OFF &amp;&amp; messageLevel.intValue() &gt;= loggerLevel.intValue(),
746                             name, sourceClass, sourceMethod, messageLevel, bundle,
747                             format, (Throwable)null, arg1, arg2);
748                 logger.logrb(toPlatformLevel(messageLevel), sourceClass, sourceMethod, bundle, format, arg1, arg2);
749                 checkLogEvent(provider, desc, expected, expected.isLoggable);
750             }
751         }
752 
753         System.out.println(&quot;\tlogger.logrb(messageLevel, sourceClass, sourceMethod, bundle, msg, thrown)&quot;);
754         for (java.util.logging.Level loggerLevel : julLevels) {
755             setLevel(sink, loggerLevel);
756             for (java.util.logging.Level messageLevel :julLevels) {
757                 String desc = &quot;logger.logrb(messageLevel, sourceClass, sourceMethod, bundle, msg, thrown): loggerLevel=&quot;
758                         + loggerLevel+&quot;, messageLevel=&quot;+messageLevel;
759                 LogEvent expected =
760                         LogEvent.of(
761                             sequencer.get(),
762                             loggerLevel != OFF &amp;&amp; messageLevel.intValue() &gt;= loggerLevel.intValue(),
763                             name, sourceClass, sourceMethod, messageLevel, bundle,
764                             fooMsg, thrown, (Object[])null);
765                 logger.logrb(toPlatformLevel(messageLevel), sourceClass, sourceMethod, bundle, fooMsg, thrown);
766                 checkLogEvent(provider, desc, expected, expected.isLoggable);
767             }
768         }
769     }
770 
771     final static class PermissionsBuilder {
772         final Permissions perms;
773         public PermissionsBuilder() {
774             this(new Permissions());
775         }
776         public PermissionsBuilder(Permissions perms) {
777             this.perms = perms;
778         }
779         public PermissionsBuilder add(Permission p) {
780             perms.add(p);
781             return this;
782         }
783         public PermissionsBuilder addAll(PermissionCollection col) {
784             if (col != null) {
785                 for (Enumeration&lt;Permission&gt; e = col.elements(); e.hasMoreElements(); ) {
786                     perms.add(e.nextElement());
787                 }
788             }
789             return this;
790         }
791         public Permissions toPermissions() {
792             final PermissionsBuilder builder = new PermissionsBuilder();
793             builder.addAll(perms);
794             return builder.perms;
795         }
796     }
797 
798     public static class SimplePolicy extends Policy {
799         public static final RuntimePermission LOGGERFINDER_PERMISSION =
800                 new RuntimePermission(&quot;loggerFinder&quot;);
801         final static RuntimePermission ACCESS_LOGGER = new RuntimePermission(&quot;accessClassInPackage.jdk.internal.logger&quot;);
802         final static RuntimePermission ACCESS_LOGGING = new RuntimePermission(&quot;accessClassInPackage.sun.util.logging&quot;);
803 
804         static final Policy DEFAULT_POLICY = Policy.getPolicy();
805 
806         final Permissions permissions;
807         final Permissions allPermissions;
808         final ThreadLocal&lt;AtomicBoolean&gt; allowControl;
809         final ThreadLocal&lt;AtomicBoolean&gt; allowAccess;
810         final ThreadLocal&lt;AtomicBoolean&gt; allowAll;
811         public SimplePolicy(ThreadLocal&lt;AtomicBoolean&gt; allowControl,
812                 ThreadLocal&lt;AtomicBoolean&gt; allowAccess,
813                 ThreadLocal&lt;AtomicBoolean&gt; allowAll) {
814             this.allowControl = allowControl;
815             this.allowAccess = allowAccess;
816             this.allowAll = allowAll;
817             permissions = new Permissions();
818             allPermissions = new PermissionsBuilder()
819                     .add(new java.security.AllPermission())
820                     .toPermissions();
821         }
822 
823         Permissions getPermissions() {
824             if (allowControl.get().get() || allowAccess.get().get() || allowAll.get().get()) {
825                 PermissionsBuilder builder =  new PermissionsBuilder()
826                         .addAll(permissions);
827                 if (allowControl.get().get()) {
828                     builder.add(LOGGERFINDER_PERMISSION);
829                 }
830                 if (allowAccess.get().get()) {
831                     builder.add(ACCESS_LOGGER);
832                     builder.add(ACCESS_LOGGING);
833                 }
834                 if (allowAll.get().get()) {
835                     builder.addAll(allPermissions);
836                 }
837                 return builder.toPermissions();
838             }
839             return permissions;
840         }
841 
842         @Override
843         public boolean implies(ProtectionDomain domain, Permission permission) {
844             return getPermissions().implies(permission) || DEFAULT_POLICY.implies(domain, permission);
845         }
846 
847         @Override
848         public PermissionCollection getPermissions(CodeSource codesource) {
849             return new PermissionsBuilder().addAll(getPermissions()).toPermissions();
850         }
851 
852         @Override
853         public PermissionCollection getPermissions(ProtectionDomain domain) {
854             return new PermissionsBuilder().addAll(getPermissions()).toPermissions();
855         }
856     }
857 }
    </pre>
  </body>
</html>
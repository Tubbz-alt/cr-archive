<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New test/jdk/java/lang/System/LoggerFinder/DefaultLoggerFinderTest/DefaultLoggerFinderTest.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2015, 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 import java.security.AccessControlException;
 24 import java.security.CodeSource;
 25 import java.security.Permission;
 26 import java.security.PermissionCollection;
 27 import java.security.Permissions;
 28 import java.security.Policy;
 29 import java.security.ProtectionDomain;
 30 import java.util.Arrays;
 31 import java.util.Collections;
 32 import java.util.Enumeration;
 33 import java.util.HashMap;
 34 import java.util.Map;
 35 import java.util.Objects;
 36 import java.util.Queue;
 37 import java.util.ResourceBundle;
 38 import java.util.concurrent.ArrayBlockingQueue;
 39 import java.util.concurrent.ConcurrentHashMap;
 40 import java.util.concurrent.atomic.AtomicBoolean;
 41 import java.util.concurrent.atomic.AtomicLong;
 42 import java.util.function.Supplier;
 43 import java.util.logging.Handler;
 44 import java.util.logging.LogRecord;
 45 import java.lang.System.LoggerFinder;
 46 import java.lang.System.Logger;
 47 import java.lang.System.Logger.Level;
 48 import java.util.stream.Stream;
 49 
 50 /**
 51  * @test
 52  * @bug     8140364
 53  * @summary Tests the default implementation of System.Logger, when
 54  *          JUL is the default backend.
 55  * @modules java.logging
 56  * @build AccessSystemLogger DefaultLoggerFinderTest
 57  * @run  driver AccessSystemLogger
 58  * @run  main/othervm -Xbootclasspath/a:boot DefaultLoggerFinderTest NOSECURITY
 59  * @run  main/othervm -Xbootclasspath/a:boot DefaultLoggerFinderTest NOPERMISSIONS
 60  * @run  main/othervm -Xbootclasspath/a:boot DefaultLoggerFinderTest WITHPERMISSIONS
 61  * @author danielfuchs
 62  */
 63 public class DefaultLoggerFinderTest {
 64 
 65     static final RuntimePermission LOGGERFINDER_PERMISSION =
 66                 new RuntimePermission(&quot;loggerFinder&quot;);
 67     final static AtomicLong sequencer = new AtomicLong();
 68     final static boolean VERBOSE = false;
 69     static final ThreadLocal&lt;AtomicBoolean&gt; allowControl = new ThreadLocal&lt;AtomicBoolean&gt;() {
 70         @Override
 71         protected AtomicBoolean initialValue() {
 72             return  new AtomicBoolean(false);
 73         }
 74     };
 75     static final ThreadLocal&lt;AtomicBoolean&gt; allowAll = new ThreadLocal&lt;AtomicBoolean&gt;() {
 76         @Override
 77         protected AtomicBoolean initialValue() {
 78             return  new AtomicBoolean(false);
 79         }
 80     };
 81 
 82     static final AccessSystemLogger accessSystemLogger = new AccessSystemLogger();
 83 
 84     public static final Queue&lt;LogEvent&gt; eventQueue = new ArrayBlockingQueue&lt;&gt;(128);
 85 
 86     public static final class LogEvent {
 87 
 88         public LogEvent() {
 89             this(sequencer.getAndIncrement());
 90         }
 91 
 92         LogEvent(long sequenceNumber) {
 93             this.sequenceNumber = sequenceNumber;
 94         }
 95 
 96         long sequenceNumber;
 97         boolean isLoggable;
 98         String loggerName;
 99         java.util.logging.Level level;
100         ResourceBundle bundle;
101         Throwable thrown;
102         Object[] args;
103         String msg;
104         String className;
105         String methodName;
106 
107         Object[] toArray() {
108             return new Object[] {
109                 sequenceNumber,
110                 isLoggable,
111                 loggerName,
112                 level,
113                 bundle,
114                 thrown,
115                 args,
116                 msg,
117                 className,
118                 methodName,
119             };
120         }
121 
122         @Override
123         public String toString() {
124             return Arrays.deepToString(toArray());
125         }
126 
127         @Override
128         public boolean equals(Object obj) {
129             return obj instanceof LogEvent
130                     &amp;&amp; Objects.deepEquals(this.toArray(), ((LogEvent)obj).toArray());
131         }
132 
133         @Override
134         public int hashCode() {
135             return Objects.hash(toArray());
136         }
137         public static LogEvent of(long sequenceNumber,
138                 boolean isLoggable, String name,
139                 java.util.logging.Level level, ResourceBundle bundle,
140                 String key, Throwable thrown, Object... params) {
141             return LogEvent.of(sequenceNumber, isLoggable, name,
142                     DefaultLoggerFinderTest.class.getName(),
143                     &quot;testLogger&quot;, level, bundle, key,
144                     thrown, params);
145         }
146         public static LogEvent of(long sequenceNumber,
147                 boolean isLoggable, String name,
148                 String className, String methodName,
149                 java.util.logging.Level level, ResourceBundle bundle,
150                 String key, Throwable thrown, Object... params) {
151             LogEvent evt = new LogEvent(sequenceNumber);
152             evt.loggerName = name;
153             evt.level = level;
154             evt.args = params;
155             evt.bundle = bundle;
156             evt.thrown = thrown;
157             evt.msg = key;
158             evt.isLoggable = isLoggable;
159             evt.className = className;
160             evt.methodName = methodName;
161             return evt;
162         }
163 
164     }
165 
166     static java.util.logging.Level mapToJul(Level level) {
167         switch (level) {
168             case ALL: return java.util.logging.Level.ALL;
169             case TRACE: return java.util.logging.Level.FINER;
170             case DEBUG: return java.util.logging.Level.FINE;
171             case INFO: return java.util.logging.Level.INFO;
172             case WARNING: return java.util.logging.Level.WARNING;
173             case ERROR: return java.util.logging.Level.SEVERE;
174             case OFF: return java.util.logging.Level.OFF;
175         }
176         throw new InternalError(&quot;No such level: &quot; + level);
177     }
178 
179     static final java.util.logging.Level[] julLevels = {
180         java.util.logging.Level.ALL,
181         new java.util.logging.Level(&quot;FINER_THAN_FINEST&quot;, java.util.logging.Level.FINEST.intValue() - 10) {},
182         java.util.logging.Level.FINEST,
183         new java.util.logging.Level(&quot;FINER_THAN_FINER&quot;, java.util.logging.Level.FINER.intValue() - 10) {},
184         java.util.logging.Level.FINER,
185         new java.util.logging.Level(&quot;FINER_THAN_FINE&quot;, java.util.logging.Level.FINE.intValue() - 10) {},
186         java.util.logging.Level.FINE,
187         new java.util.logging.Level(&quot;FINER_THAN_CONFIG&quot;, java.util.logging.Level.FINE.intValue() + 10) {},
188         java.util.logging.Level.CONFIG,
189         new java.util.logging.Level(&quot;FINER_THAN_INFO&quot;, java.util.logging.Level.INFO.intValue() - 10) {},
190         java.util.logging.Level.INFO,
191         new java.util.logging.Level(&quot;FINER_THAN_WARNING&quot;, java.util.logging.Level.INFO.intValue() + 10) {},
192         java.util.logging.Level.WARNING,
193         new java.util.logging.Level(&quot;FINER_THAN_SEVERE&quot;, java.util.logging.Level.SEVERE.intValue() - 10) {},
194         java.util.logging.Level.SEVERE,
195         new java.util.logging.Level(&quot;FATAL&quot;, java.util.logging.Level.SEVERE.intValue() + 10) {},
196         java.util.logging.Level.OFF,
197     };
198 
199     static final Level[] mappedLevels = {
200         Level.ALL,     // ALL
201         Level.DEBUG,   // FINER_THAN_FINEST
202         Level.DEBUG,   // FINEST
203         Level.DEBUG,   // FINER_THAN_FINER
204         Level.TRACE,   // FINER
205         Level.TRACE,   // FINER_THAN_FINE
206         Level.DEBUG,   // FINE
207         Level.DEBUG,   // FINER_THAN_CONFIG
208         Level.DEBUG,   // CONFIG
209         Level.DEBUG,   // FINER_THAN_INFO
210         Level.INFO,    // INFO
211         Level.INFO,    // FINER_THAN_WARNING
212         Level.WARNING, // WARNING
213         Level.WARNING, // FINER_THAN_SEVERE
214         Level.ERROR,   // SEVERE
215         Level.ERROR,   // FATAL
216         Level.OFF,     // OFF
217     };
218 
219     final static Map&lt;java.util.logging.Level, Level&gt; julToSpiMap;
220     static {
221         Map&lt;java.util.logging.Level, Level&gt; map = new HashMap&lt;&gt;();
222         if (mappedLevels.length != julLevels.length) {
223             throw new ExceptionInInitializerError(&quot;Array lengths differ&quot;
224                 + &quot;\n\tjulLevels=&quot; + Arrays.deepToString(julLevels)
225                 + &quot;\n\tmappedLevels=&quot; + Arrays.deepToString(mappedLevels));
226         }
227         for (int i=0; i&lt;julLevels.length; i++) {
228             map.put(julLevels[i], mappedLevels[i]);
229         }
230         julToSpiMap = Collections.unmodifiableMap(map);
231     }
232 
233     public static class MyBundle extends ResourceBundle {
234 
235         final ConcurrentHashMap&lt;String,String&gt; map = new ConcurrentHashMap&lt;&gt;();
236 
237         @Override
238         protected Object handleGetObject(String key) {
239             if (key.contains(&quot; (translated)&quot;)) {
240                 throw new RuntimeException(&quot;Unexpected key: &quot; + key);
241             }
242             return map.computeIfAbsent(key, k -&gt; k + &quot; (translated)&quot;);
243         }
244 
245         @Override
246         public Enumeration&lt;String&gt; getKeys() {
247             return Collections.enumeration(map.keySet());
248         }
249 
250     }
251 
252     public static class MyHandler extends Handler {
253 
254         @Override
255         public java.util.logging.Level getLevel() {
256             return java.util.logging.Level.ALL;
257         }
258 
259         @Override
260         public void publish(LogRecord record) {
261             eventQueue.add(LogEvent.of(sequencer.getAndIncrement(),
262                     true, record.getLoggerName(),
263                     record.getSourceClassName(),
264                     record.getSourceMethodName(),
265                     record.getLevel(),
266                     record.getResourceBundle(), record.getMessage(),
267                     record.getThrown(), record.getParameters()));
268         }
269         @Override
270         public void flush() {
271         }
272         @Override
273         public void close() throws SecurityException {
274         }
275 
276     }
277 
278     public static class MyLoggerBundle extends MyBundle {
279 
280     }
281 
282 
283     static enum TestCases {NOSECURITY, NOPERMISSIONS, WITHPERMISSIONS};
284 
285     static void setSecurityManager() {
286         if (System.getSecurityManager() == null) {
287             Policy.setPolicy(new SimplePolicy(allowAll, allowControl));
288             System.setSecurityManager(new SecurityManager());
289         }
290     }
291 
292     public static void main(String[] args) {
293         if (args.length == 0)
294             args = new String[] {
295                 &quot;NOSECURITY&quot;,
296                 &quot;NOPERMISSIONS&quot;,
297                 &quot;WITHPERMISSIONS&quot;
298             };
299 
300         final java.util.logging.Logger appSink = java.util.logging.Logger.getLogger(&quot;foo&quot;);
301         final java.util.logging.Logger sysSink = accessSystemLogger.demandSystemLogger(&quot;foo&quot;);
302         final java.util.logging.Logger sink = java.util.logging.Logger.getLogger(&quot;foo&quot;);
303         sink.addHandler(new MyHandler());
304         sink.setUseParentHandlers(VERBOSE);
305 
306         Stream.of(args).map(TestCases::valueOf).forEach((testCase) -&gt; {
307             LoggerFinder provider;
308             switch (testCase) {
309                 case NOSECURITY:
310                     System.out.println(&quot;\n*** Without Security Manager\n&quot;);
311                     provider = LoggerFinder.getLoggerFinder();
312                     test(provider, true, appSink, sysSink);
313                     System.out.println(&quot;Tetscase count: &quot; + sequencer.get());
314                     break;
315                 case NOPERMISSIONS:
316                     System.out.println(&quot;\n*** With Security Manager, without permissions\n&quot;);
317                     setSecurityManager();
318                     try {
319                         provider = LoggerFinder.getLoggerFinder();
320                         throw new RuntimeException(&quot;Expected exception not raised&quot;);
321                     } catch (AccessControlException x) {
322                         if (!LOGGERFINDER_PERMISSION.equals(x.getPermission())) {
323                             throw new RuntimeException(&quot;Unexpected permission check&quot;, x);
324                         }
325                         final boolean control = allowControl.get().get();
326                         try {
327                             allowControl.get().set(true);
328                             provider = LoggerFinder.getLoggerFinder();
329                         } finally {
330                             allowControl.get().set(control);
331                         }
332                     }
333                     test(provider, false, appSink, sysSink);
334                     System.out.println(&quot;Tetscase count: &quot; + sequencer.get());
335                     break;
336                 case WITHPERMISSIONS:
337                     System.out.println(&quot;\n*** With Security Manager, with control permission\n&quot;);
338                     setSecurityManager();
339                     final boolean control = allowControl.get().get();
340                     try {
341                         allowControl.get().set(true);
342                         provider = LoggerFinder.getLoggerFinder();
343                         test(provider, true, appSink, sysSink);
344                     } finally {
345                         allowControl.get().set(control);
346                     }
347                     break;
348                 default:
349                     throw new RuntimeException(&quot;Unknown test case: &quot; + testCase);
350             }
351         });
352         System.out.println(&quot;\nPASSED: Tested &quot; + sequencer.get() + &quot; cases.&quot;);
353     }
354 
355     public static void test(LoggerFinder provider,
356             boolean hasRequiredPermissions,
357             java.util.logging.Logger appSink,
358             java.util.logging.Logger sysSink) {
359 
360         ResourceBundle loggerBundle = ResourceBundle.getBundle(MyLoggerBundle.class.getName());
361         final Map&lt;Logger, String&gt; loggerDescMap = new HashMap&lt;&gt;();
362 
363 
364         Logger appLogger1 = null;
365         try {
366             appLogger1 = provider.getLogger(&quot;foo&quot;, DefaultLoggerFinderTest.class.getModule());
367             loggerDescMap.put(appLogger1, &quot;provider.getLogger(\&quot;foo\&quot;, DefaultLoggerFinderTest.class.getModule())&quot;);
368             if (!hasRequiredPermissions) {
369                 throw new RuntimeException(&quot;Managed to obtain a logger without permission&quot;);
370             }
371         } catch (AccessControlException acx) {
372             if (hasRequiredPermissions) {
373                 throw new RuntimeException(&quot;Unexpected security exception: &quot;, acx);
374             }
375             if (!acx.getPermission().equals(LOGGERFINDER_PERMISSION)) {
376                 throw new RuntimeException(&quot;Unexpected permission in exception: &quot; + acx, acx);
377             }
378             System.out.println(&quot;Got expected exception for logger: &quot; + acx);
379             boolean old = allowControl.get().get();
380             allowControl.get().set(true);
381             try {
382                 appLogger1 =provider.getLogger(&quot;foo&quot;, DefaultLoggerFinderTest.class.getModule());
383                 loggerDescMap.put(appLogger1, &quot;provider.getLogger(\&quot;foo\&quot;, DefaultLoggerFinderTest.class.getModule())&quot;);
384             } finally {
385                 allowControl.get().set(old);
386             }
387         }
388 
389         Logger sysLogger1 = null;
390         try {
391             sysLogger1 = provider.getLogger(&quot;foo&quot;, Thread.class.getModule());
392             loggerDescMap.put(sysLogger1, &quot;provider.getLogger(\&quot;foo\&quot;, Thread.class.getModule())&quot;);
393             if (!hasRequiredPermissions) {
394                 throw new RuntimeException(&quot;Managed to obtain a system logger without permission&quot;);
395             }
396         } catch (AccessControlException acx) {
397             if (hasRequiredPermissions) {
398                 throw new RuntimeException(&quot;Unexpected security exception: &quot;, acx);
399             }
400             if (!acx.getPermission().equals(LOGGERFINDER_PERMISSION)) {
401                 throw new RuntimeException(&quot;Unexpected permission in exception: &quot; + acx, acx);
402             }
403             System.out.println(&quot;Got expected exception for system logger: &quot; + acx);
404             boolean old = allowControl.get().get();
405             allowControl.get().set(true);
406             try {
407                 sysLogger1 = provider.getLogger(&quot;foo&quot;, Thread.class.getModule());
408                 loggerDescMap.put(sysLogger1, &quot;provider.getLogger(\&quot;foo\&quot;, Thread.class.getModule())&quot;);
409             } finally {
410                 allowControl.get().set(old);
411             }
412         }
413         if (appLogger1 == sysLogger1) {
414             throw new RuntimeException(&quot;identical loggers&quot;);
415         }
416 
417         Logger appLogger2 = null;
418         try {
419             appLogger2 = provider.getLocalizedLogger(&quot;foo&quot;, loggerBundle, DefaultLoggerFinderTest.class.getModule());
420             loggerDescMap.put(appLogger2, &quot;provider.getLocalizedLogger(\&quot;foo\&quot;, loggerBundle, DefaultLoggerFinderTest.class.getModule())&quot;);
421             if (!hasRequiredPermissions) {
422                 throw new RuntimeException(&quot;Managed to obtain a logger without permission&quot;);
423             }
424         } catch (AccessControlException acx) {
425             if (hasRequiredPermissions) {
426                 throw new RuntimeException(&quot;Unexpected security exception: &quot;, acx);
427             }
428             if (!acx.getPermission().equals(LOGGERFINDER_PERMISSION)) {
429                 throw new RuntimeException(&quot;Unexpected permission in exception: &quot; + acx, acx);
430             }
431             System.out.println(&quot;Got expected exception for logger: &quot; + acx);
432             boolean old = allowControl.get().get();
433             allowControl.get().set(true);
434             try {
435                 appLogger2 = provider.getLocalizedLogger(&quot;foo&quot;, loggerBundle, DefaultLoggerFinderTest.class.getModule());
436                 loggerDescMap.put(appLogger2, &quot;provider.getLocalizedLogger(\&quot;foo\&quot;, loggerBundle, DefaultLoggerFinderTest.class.getModule())&quot;);
437             } finally {
438                 allowControl.get().set(old);
439             }
440         }
441 
442         Logger sysLogger2 = null;
443         try {
444             sysLogger2 = provider.getLocalizedLogger(&quot;foo&quot;, loggerBundle, Thread.class.getModule());
445             loggerDescMap.put(sysLogger2, &quot;provider.getLocalizedLogger(\&quot;foo\&quot;, loggerBundle, Thread.class.getModule())&quot;);
446             if (!hasRequiredPermissions) {
447                 throw new RuntimeException(&quot;Managed to obtain a system logger without permission&quot;);
448             }
449         } catch (AccessControlException acx) {
450             if (hasRequiredPermissions) {
451                 throw new RuntimeException(&quot;Unexpected security exception: &quot;, acx);
452             }
453             if (!acx.getPermission().equals(LOGGERFINDER_PERMISSION)) {
454                 throw new RuntimeException(&quot;Unexpected permission in exception: &quot; + acx, acx);
455             }
456             System.out.println(&quot;Got expected exception for localized system logger: &quot; + acx);
457             boolean old = allowControl.get().get();
458             allowControl.get().set(true);
459             try {
460                 sysLogger2 = provider.getLocalizedLogger(&quot;foo&quot;, loggerBundle, Thread.class.getModule());
461                 loggerDescMap.put(sysLogger2, &quot;provider.getLocalizedLogger(\&quot;foo\&quot;, loggerBundle, Thread.class.getModule())&quot;);
462             } finally {
463                 allowControl.get().set(old);
464             }
465         }
466         if (appLogger2 == sysLogger2) {
467             throw new RuntimeException(&quot;identical loggers&quot;);
468         }
469         if (appLogger2 == appLogger1) {
470             throw new RuntimeException(&quot;identical loggers&quot;);
471         }
472         if (sysLogger2 == sysLogger1) {
473             throw new RuntimeException(&quot;identical loggers&quot;);
474         }
475 
476 
477         testLogger(provider, loggerDescMap, &quot;foo&quot;, null, appLogger1, appSink);
478         testLogger(provider, loggerDescMap, &quot;foo&quot;, null, sysLogger1, sysSink);
479         testLogger(provider, loggerDescMap, &quot;foo&quot;, loggerBundle, appLogger2, appSink);
480         testLogger(provider, loggerDescMap, &quot;foo&quot;, loggerBundle, sysLogger2, sysSink);
481 
482 
483         Logger appLogger3 = System.getLogger(&quot;foo&quot;);
484         loggerDescMap.put(appLogger3, &quot;System.getLogger(\&quot;foo\&quot;)&quot;);
485 
486         testLogger(provider, loggerDescMap, &quot;foo&quot;, null, appLogger3, appSink);
487 
488         Logger appLogger4 =
489                 System.getLogger(&quot;foo&quot;, loggerBundle);
490         loggerDescMap.put(appLogger4, &quot;System.getLogger(\&quot;foo\&quot;, loggerBundle)&quot;);
491 
492         if (appLogger4 == appLogger1) {
493             throw new RuntimeException(&quot;identical loggers&quot;);
494         }
495 
496         testLogger(provider, loggerDescMap, &quot;foo&quot;, loggerBundle, appLogger4, appSink);
497 
498         Logger sysLogger3 = accessSystemLogger.getLogger(&quot;foo&quot;);
499         loggerDescMap.put(sysLogger3, &quot;AccessSystemLogger.getLogger(\&quot;foo\&quot;)&quot;);
500 
501         testLogger(provider, loggerDescMap, &quot;foo&quot;, null, sysLogger3, sysSink);
502 
503         Logger sysLogger4 =
504                 accessSystemLogger.getLogger(&quot;foo&quot;, loggerBundle);
505         loggerDescMap.put(appLogger4, &quot;AccessSystemLogger.getLogger(\&quot;foo\&quot;, loggerBundle)&quot;);
506 
507         if (sysLogger4 == sysLogger1) {
508             throw new RuntimeException(&quot;identical loggers&quot;);
509         }
510 
511         testLogger(provider, loggerDescMap, &quot;foo&quot;, loggerBundle, sysLogger4, sysSink);
512 
513     }
514 
515     public static class Foo {
516 
517     }
518 
519     static void verbose(String msg) {
520        if (VERBOSE) {
521            System.out.println(msg);
522        }
523     }
524 
525     static void setLevel(java.util.logging.Logger sink, java.util.logging.Level loggerLevel) {
526         boolean before = allowAll.get().get();
527         try {
528             allowAll.get().set(true);
529             sink.setLevel(loggerLevel);
530         } finally {
531             allowAll.get().set(before);
532         }
533     }
534 
535 
536     // Calls the 8 methods defined on Logger and verify the
537     // parameters received by the underlying Logger Impl
538     // logger.
539     private static void testLogger(LoggerFinder provider,
540             Map&lt;Logger, String&gt; loggerDescMap,
541             String name,
542             ResourceBundle loggerBundle,
543             Logger logger,
544             java.util.logging.Logger sink) {
545 
546         System.out.println(&quot;Testing &quot; + loggerDescMap.get(logger) + &quot; [&quot; + logger + &quot;]&quot;);
547         final java.util.logging.Level OFF = java.util.logging.Level.OFF;
548 
549         Foo foo = new Foo();
550         String fooMsg = foo.toString();
551         for (java.util.logging.Level loggerLevel : julLevels) {
552             setLevel(sink, loggerLevel);
553             for (Level messageLevel : Level.values()) {
554                 java.util.logging.Level julLevel = mapToJul(messageLevel);
555                 String desc = &quot;logger.log(messageLevel, foo): loggerLevel=&quot;
556                         + loggerLevel+&quot;, messageLevel=&quot;+messageLevel;
557                 LogEvent expected =
558                         LogEvent.of(
559                             sequencer.get(),
560                             julLevel.intValue() &gt;= loggerLevel.intValue(),
561                             name, julLevel, (ResourceBundle)null,
562                             fooMsg, (Throwable)null, (Object[])null);
563                 logger.log(messageLevel, foo);
564                 if (loggerLevel == OFF || julLevel.intValue() &lt; loggerLevel.intValue()) {
565                     if (eventQueue.poll() != null) {
566                         throw new RuntimeException(&quot;unexpected event in queue for &quot; + desc);
567                     }
568                 } else {
569                     LogEvent actual =  eventQueue.poll();
570                     if (!expected.equals(actual)) {
571                         throw new RuntimeException(&quot;mismatch for &quot; + desc
572                                 + &quot;\n\texpected=&quot; + expected
573                                 + &quot;\n\t  actual=&quot; + actual);
574                     } else {
575                         verbose(&quot;Got expected results for &quot;
576                                 + desc + &quot;\n\t&quot; + expected);
577                     }
578                 }
579             }
580         }
581 
582         String msg = &quot;blah&quot;;
583         for (java.util.logging.Level loggerLevel : julLevels) {
584             setLevel(sink, loggerLevel);
585             for (Level messageLevel : Level.values()) {
586                 java.util.logging.Level julLevel = mapToJul(messageLevel);
587                 String desc = &quot;logger.log(messageLevel, \&quot;blah\&quot;): loggerLevel=&quot;
588                         + loggerLevel+&quot;, messageLevel=&quot;+messageLevel;
589                 LogEvent expected =
590                         LogEvent.of(
591                             sequencer.get(),
592                             julLevel.intValue() &gt;= loggerLevel.intValue(),
593                             name, julLevel, loggerBundle,
594                             msg, (Throwable)null, (Object[])null);
595                 logger.log(messageLevel, msg);
596                 if (loggerLevel == OFF || julLevel.intValue() &lt; loggerLevel.intValue()) {
597                     if (eventQueue.poll() != null) {
598                         throw new RuntimeException(&quot;unexpected event in queue for &quot; + desc);
599                     }
600                 } else {
601                     LogEvent actual =  eventQueue.poll();
602                     if (!expected.equals(actual)) {
603                         throw new RuntimeException(&quot;mismatch for &quot; + desc
604                                 + &quot;\n\texpected=&quot; + expected
605                                 + &quot;\n\t  actual=&quot; + actual);
606                     } else {
607                         verbose(&quot;Got expected results for &quot;
608                                 + desc + &quot;\n\t&quot; + expected);
609                     }
610                 }
611             }
612         }
613 
614         Supplier&lt;String&gt; fooSupplier = new Supplier&lt;String&gt;() {
615             @Override
616             public String get() {
617                 return this.toString();
618             }
619         };
620 
621         for (java.util.logging.Level loggerLevel : julLevels) {
622             setLevel(sink, loggerLevel);
623             for (Level messageLevel : Level.values()) {
624                 java.util.logging.Level julLevel = mapToJul(messageLevel);
625                 String desc = &quot;logger.log(messageLevel, fooSupplier): loggerLevel=&quot;
626                         + loggerLevel+&quot;, messageLevel=&quot;+messageLevel;
627                 LogEvent expected =
628                         LogEvent.of(
629                             sequencer.get(),
630                             julLevel.intValue() &gt;= loggerLevel.intValue(),
631                             name, julLevel, (ResourceBundle)null,
632                             fooSupplier.get(),
633                             (Throwable)null, (Object[])null);
634                 logger.log(messageLevel, fooSupplier);
635                 if (loggerLevel == OFF || julLevel.intValue() &lt; loggerLevel.intValue()) {
636                     if (eventQueue.poll() != null) {
637                         throw new RuntimeException(&quot;unexpected event in queue for &quot; + desc);
638                     }
639                 } else {
640                     LogEvent actual =  eventQueue.poll();
641                     if (!expected.equals(actual)) {
642                         throw new RuntimeException(&quot;mismatch for &quot; + desc
643                                 + &quot;\n\texpected=&quot; + expected
644                                 + &quot;\n\t  actual=&quot; + actual);
645                     } else {
646                         verbose(&quot;Got expected results for &quot;
647                                 + desc + &quot;\n\t&quot; + expected);
648                     }
649                 }
650             }
651         }
652 
653         String format = &quot;two params [{1} {2}]&quot;;
654         Object arg1 = foo;
655         Object arg2 = msg;
656         for (java.util.logging.Level loggerLevel : julLevels) {
657             setLevel(sink, loggerLevel);
658             for (Level messageLevel : Level.values()) {
659                 java.util.logging.Level julLevel = mapToJul(messageLevel);
660                 String desc = &quot;logger.log(messageLevel, format, params...): loggerLevel=&quot;
661                         + loggerLevel+&quot;, messageLevel=&quot;+messageLevel;
662                 LogEvent expected =
663                         LogEvent.of(
664                             sequencer.get(),
665                             julLevel.intValue() &gt;= loggerLevel.intValue(),
666                             name, julLevel, loggerBundle,
667                             format, (Throwable)null, new Object[] {arg1, arg2});
668                 logger.log(messageLevel, format, arg1, arg2);
669                 if (loggerLevel == OFF || julLevel.intValue() &lt; loggerLevel.intValue()) {
670                     if (eventQueue.poll() != null) {
671                         throw new RuntimeException(&quot;unexpected event in queue for &quot; + desc);
672                     }
673                 } else {
674                     LogEvent actual =  eventQueue.poll();
675                     if (!expected.equals(actual)) {
676                         throw new RuntimeException(&quot;mismatch for &quot; + desc
677                                 + &quot;\n\texpected=&quot; + expected
678                                 + &quot;\n\t  actual=&quot; + actual);
679                     } else {
680                         verbose(&quot;Got expected results for &quot;
681                                 + desc + &quot;\n\t&quot; + expected);
682                     }
683                 }
684             }
685         }
686 
687         Throwable thrown = new Exception(&quot;OK: log me!&quot;);
688         for (java.util.logging.Level loggerLevel : julLevels) {
689             setLevel(sink, loggerLevel);
690             for (Level messageLevel : Level.values()) {
691                 java.util.logging.Level julLevel = mapToJul(messageLevel);
692                 String desc = &quot;logger.log(messageLevel, \&quot;blah\&quot;, thrown): loggerLevel=&quot;
693                         + loggerLevel+&quot;, messageLevel=&quot;+messageLevel;
694                 LogEvent expected =
695                         LogEvent.of(
696                             sequencer.get(),
697                             julLevel.intValue() &gt;= loggerLevel.intValue(),
698                             name, julLevel, loggerBundle,
699                             msg, thrown, (Object[]) null);
700                 logger.log(messageLevel, msg, thrown);
701                 if (loggerLevel == OFF || julLevel.intValue() &lt; loggerLevel.intValue()) {
702                     if (eventQueue.poll() != null) {
703                         throw new RuntimeException(&quot;unexpected event in queue for &quot; + desc);
704                     }
705                 } else {
706                     LogEvent actual =  eventQueue.poll();
707                     if (!expected.equals(actual)) {
708                         throw new RuntimeException(&quot;mismatch for &quot; + desc
709                                 + &quot;\n\texpected=&quot; + expected
710                                 + &quot;\n\t  actual=&quot; + actual);
711                     } else {
712                         verbose(&quot;Got expected results for &quot;
713                                 + desc + &quot;\n\t&quot; + expected);
714                     }
715                 }
716             }
717         }
718 
719 
720         for (java.util.logging.Level loggerLevel : julLevels) {
721             setLevel(sink, loggerLevel);
722             for (Level messageLevel : Level.values()) {
723                 java.util.logging.Level julLevel = mapToJul(messageLevel);
724                 String desc = &quot;logger.log(messageLevel, thrown, fooSupplier): loggerLevel=&quot;
725                         + loggerLevel+&quot;, messageLevel=&quot;+messageLevel;
726                 LogEvent expected =
727                         LogEvent.of(
728                             sequencer.get(),
729                             julLevel.intValue() &gt;= loggerLevel.intValue(),
730                             name, julLevel, (ResourceBundle)null,
731                             fooSupplier.get(),
732                             (Throwable)thrown, (Object[])null);
733                 logger.log(messageLevel, fooSupplier, thrown);
734                 if (loggerLevel == OFF || julLevel.intValue() &lt; loggerLevel.intValue()) {
735                     if (eventQueue.poll() != null) {
736                         throw new RuntimeException(&quot;unexpected event in queue for &quot; + desc);
737                     }
738                 } else {
739                     LogEvent actual =  eventQueue.poll();
740                     if (!expected.equals(actual)) {
741                         throw new RuntimeException(&quot;mismatch for &quot; + desc
742                                 + &quot;\n\texpected=&quot; + expected
743                                 + &quot;\n\t  actual=&quot; + actual);
744                     } else {
745                         verbose(&quot;Got expected results for &quot;
746                                 + desc + &quot;\n\t&quot; + expected);
747                     }
748                 }
749             }
750         }
751 
752         ResourceBundle bundle = ResourceBundle.getBundle(MyBundle.class.getName());
753         for (java.util.logging.Level loggerLevel : julLevels) {
754             setLevel(sink, loggerLevel);
755             for (Level messageLevel : Level.values()) {
756                 java.util.logging.Level julLevel = mapToJul(messageLevel);
757                 String desc = &quot;logger.log(messageLevel, bundle, format, params...): loggerLevel=&quot;
758                         + loggerLevel+&quot;, messageLevel=&quot;+messageLevel;
759                 LogEvent expected =
760                         LogEvent.of(
761                             sequencer.get(),
762                             julLevel.intValue() &gt;= loggerLevel.intValue(),
763                             name, julLevel, bundle,
764                             format, (Throwable)null, new Object[] {foo, msg});
765                 logger.log(messageLevel, bundle, format, foo, msg);
766                 if (loggerLevel == OFF || julLevel.intValue() &lt; loggerLevel.intValue()) {
767                     if (eventQueue.poll() != null) {
768                         throw new RuntimeException(&quot;unexpected event in queue for &quot; + desc);
769                     }
770                 } else {
771                     LogEvent actual =  eventQueue.poll();
772                     if (!expected.equals(actual)) {
773                         throw new RuntimeException(&quot;mismatch for &quot; + desc
774                                 + &quot;\n\texpected=&quot; + expected
775                                 + &quot;\n\t  actual=&quot; + actual);
776                     } else {
777                         verbose(&quot;Got expected results for &quot;
778                                 + desc + &quot;\n\t&quot; + expected);
779                     }
780                 }
781             }
782         }
783 
784         for (java.util.logging.Level loggerLevel : julLevels) {
785             setLevel(sink, loggerLevel);
786             for (Level messageLevel : Level.values()) {
787                 java.util.logging.Level julLevel = mapToJul(messageLevel);
788                 String desc = &quot;logger.log(messageLevel, bundle, \&quot;blah\&quot;, thrown): loggerLevel=&quot;
789                         + loggerLevel+&quot;, messageLevel=&quot;+messageLevel;
790                 LogEvent expected =
791                         LogEvent.of(
792                             sequencer.get(),
793                             julLevel.intValue() &gt;= loggerLevel.intValue(),
794                             name, julLevel, bundle,
795                             msg, thrown, (Object[]) null);
796                 logger.log(messageLevel, bundle, msg, thrown);
797                 if (loggerLevel == OFF || julLevel.intValue() &lt; loggerLevel.intValue()) {
798                     if (eventQueue.poll() != null) {
799                         throw new RuntimeException(&quot;unexpected event in queue for &quot; + desc);
800                     }
801                 } else {
802                     LogEvent actual =  eventQueue.poll();
803                     if (!expected.equals(actual)) {
804                         throw new RuntimeException(&quot;mismatch for &quot; + desc
805                                 + &quot;\n\texpected=&quot; + expected
806                                 + &quot;\n\t  actual=&quot; + actual);
807                     } else {
808                         verbose(&quot;Got expected results for &quot;
809                                 + desc + &quot;\n\t&quot; + expected);
810                     }
811                 }
812             }
813         }
814     }
815 
816     final static class PermissionsBuilder {
817         final Permissions perms;
818         public PermissionsBuilder() {
819             this(new Permissions());
820         }
821         public PermissionsBuilder(Permissions perms) {
822             this.perms = perms;
823         }
824         public PermissionsBuilder add(Permission p) {
825             perms.add(p);
826             return this;
827         }
828         public PermissionsBuilder addAll(PermissionCollection col) {
829             if (col != null) {
830                 for (Enumeration&lt;Permission&gt; e = col.elements(); e.hasMoreElements(); ) {
831                     perms.add(e.nextElement());
832                 }
833             }
834             return this;
835         }
836         public Permissions toPermissions() {
837             final PermissionsBuilder builder = new PermissionsBuilder();
838             builder.addAll(perms);
839             return builder.perms;
840         }
841     }
842 
843     public static class SimplePolicy extends Policy {
844 
845         static final Policy DEFAULT_POLICY = Policy.getPolicy();
846 
847         final Permissions permissions;
848         final Permissions withControlPermissions;
849         final Permissions allPermissions;
850         final ThreadLocal&lt;AtomicBoolean&gt; allowAll;
851         final ThreadLocal&lt;AtomicBoolean&gt; allowControl;
852         public SimplePolicy(ThreadLocal&lt;AtomicBoolean&gt; allowAll,
853                 ThreadLocal&lt;AtomicBoolean&gt; allowControl) {
854             this.allowAll = allowAll;
855             this.allowControl = allowControl;
856             permissions = new Permissions();
857 
858             withControlPermissions = new Permissions();
859             withControlPermissions.add(LOGGERFINDER_PERMISSION);
860 
861             // these are used for configuring the test itself...
862             allPermissions = new Permissions();
863             allPermissions.add(new java.security.AllPermission());
864         }
865 
866         @Override
867         public boolean implies(ProtectionDomain domain, Permission permission) {
868             if (allowAll.get().get()) return allPermissions.implies(permission);
869             if (allowControl.get().get()) return withControlPermissions.implies(permission);
870             return permissions.implies(permission) || DEFAULT_POLICY.implies(domain, permission);
871         }
872 
873         @Override
874         public PermissionCollection getPermissions(CodeSource codesource) {
875             return new PermissionsBuilder().addAll(
876                     allowAll.get().get() ? allPermissions :
877                     allowControl.get().get()
878                     ? withControlPermissions : permissions).toPermissions();
879         }
880 
881         @Override
882         public PermissionCollection getPermissions(ProtectionDomain domain) {
883             return new PermissionsBuilder().addAll(
884                     allowAll.get().get() ? allPermissions :
885                     allowControl.get().get()
886                     ? withControlPermissions : permissions).toPermissions();
887         }
888     }
889 }
    </pre>
  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New test/jdk/java/lang/System/LoggerFinder/internal/LoggerBridgeTest/LoggerBridgeTest.java</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 2015, 2019, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  */
  23 import java.lang.reflect.InvocationTargetException;
  24 import java.lang.reflect.Method;
  25 import java.security.AccessControlException;
  26 import java.security.CodeSource;
  27 import java.security.Permission;
  28 import java.security.PermissionCollection;
  29 import java.security.Permissions;
  30 import java.security.Policy;
  31 import java.security.ProtectionDomain;
  32 import java.util.Arrays;
  33 import java.util.Collections;
  34 import java.util.Enumeration;
  35 import java.util.HashMap;
  36 import java.util.Map;
  37 import java.util.Objects;
  38 import java.util.Queue;
  39 import java.util.ResourceBundle;
  40 import java.util.concurrent.ArrayBlockingQueue;
  41 import java.util.concurrent.ConcurrentHashMap;
  42 import java.util.concurrent.atomic.AtomicBoolean;
  43 import java.util.concurrent.atomic.AtomicLong;
  44 import java.util.function.Supplier;
  45 import java.util.logging.Handler;
  46 import java.util.logging.LogRecord;
  47 import java.lang.System.LoggerFinder;
  48 import java.lang.System.Logger;
  49 import java.util.stream.Stream;
  50 import sun.util.logging.PlatformLogger;
  51 
  52 /**
  53  * @test
  54  * @bug     8140364
  55  * @summary JDK implementation specific unit test for JDK internal artifacts.
  56  *          Tests all bridge methods with the a custom backend whose
  57  *          loggers implement PlatformLogger.Bridge.
  58  * @modules java.base/sun.util.logging
  59  *          java.base/jdk.internal.logger
  60  *          java.logging
  61  * @build CustomSystemClassLoader LogProducerFinder LoggerBridgeTest
  62  * @run  main/othervm -Djava.system.class.loader=CustomSystemClassLoader LoggerBridgeTest NOSECURITY
  63  * @run  main/othervm -Djava.system.class.loader=CustomSystemClassLoader LoggerBridgeTest NOPERMISSIONS
  64  * @run  main/othervm -Djava.system.class.loader=CustomSystemClassLoader LoggerBridgeTest WITHPERMISSIONS
  65  * @author danielfuchs
  66  */
  67 public class LoggerBridgeTest {
  68 
  69     public static final RuntimePermission LOGGERFINDER_PERMISSION =
  70                 new RuntimePermission(&quot;loggerFinder&quot;);
  71 
  72     final static AtomicLong sequencer = new AtomicLong();
  73     final static boolean VERBOSE = false;
  74     static final ThreadLocal&lt;AtomicBoolean&gt; allowControl = new ThreadLocal&lt;AtomicBoolean&gt;() {
  75         @Override
  76         protected AtomicBoolean initialValue() {
  77             return  new AtomicBoolean(false);
  78         }
  79     };
  80     static final ThreadLocal&lt;AtomicBoolean&gt; allowAccess = new ThreadLocal&lt;AtomicBoolean&gt;() {
  81         @Override
  82         protected AtomicBoolean initialValue() {
  83             return  new AtomicBoolean(false);
  84         }
  85     };
  86     static final ThreadLocal&lt;AtomicBoolean&gt; allowAll = new ThreadLocal&lt;AtomicBoolean&gt;() {
  87         @Override
  88         protected AtomicBoolean initialValue() {
  89             return  new AtomicBoolean(false);
  90         }
  91     };
  92 
  93     public static final Queue&lt;LogEvent&gt; eventQueue = new ArrayBlockingQueue&lt;&gt;(128);
  94 
  95     public static final class LogEvent implements Cloneable {
  96 
  97         public LogEvent() {
  98             this(sequencer.getAndIncrement());
  99         }
 100 
 101         LogEvent(long sequenceNumber) {
 102             this.sequenceNumber = sequenceNumber;
 103         }
 104 
 105         long sequenceNumber;
 106         boolean isLoggable;
 107         String loggerName;
 108         sun.util.logging.PlatformLogger.Level level;
 109         ResourceBundle bundle;
 110         Throwable thrown;
 111         Object[] args;
 112         String msg;
 113         Supplier&lt;String&gt; supplier;
 114         String className;
 115         String methodName;
 116 
 117         Object[] toArray() {
 118             return new Object[] {
 119                 sequenceNumber,
 120                 loggerName,
 121                 level,
 122                 isLoggable,
 123                 bundle,
 124                 msg,
 125                 supplier,
 126                 thrown,
 127                 args,
 128                 className,
 129                 methodName,
 130             };
 131         }
 132 
 133         @Override
 134         public String toString() {
 135             return Arrays.deepToString(toArray());
 136         }
 137 
 138         @Override
 139         public boolean equals(Object obj) {
 140             return obj instanceof LogEvent
 141                     &amp;&amp; Objects.deepEquals(this.toArray(), ((LogEvent)obj).toArray());
 142         }
 143 
 144         @Override
 145         public int hashCode() {
 146             return Objects.hash(toArray());
 147         }
 148 
 149         public LogEvent cloneWith(long sequenceNumber)
 150                 throws CloneNotSupportedException {
 151             LogEvent cloned = (LogEvent)super.clone();
 152             cloned.sequenceNumber = sequenceNumber;
 153             return cloned;
 154         }
 155 
 156         public static LogEvent of(long sequenceNumber,
 157                 boolean isLoggable, String name,
 158                 sun.util.logging.PlatformLogger.Level level, ResourceBundle bundle,
 159                 String key, Throwable thrown, Object... params) {
 160             return LogEvent.of(sequenceNumber, isLoggable, name,
 161                     null, null, level, bundle, key,
 162                     thrown, params);
 163         }
 164 
 165         public static LogEvent of(long sequenceNumber,
 166                 boolean isLoggable, String name,
 167                 sun.util.logging.PlatformLogger.Level level, ResourceBundle bundle,
 168                 Supplier&lt;String&gt; supplier, Throwable thrown, Object... params) {
 169             return LogEvent.of(sequenceNumber, isLoggable, name,
 170                     null, null, level, bundle, supplier,
 171                     thrown, params);
 172         }
 173 
 174         public static LogEvent of(long sequenceNumber,
 175                 boolean isLoggable, String name,
 176                 String className, String methodName,
 177                 sun.util.logging.PlatformLogger.Level level, ResourceBundle bundle,
 178                 String key, Throwable thrown, Object... params) {
 179             LogEvent evt = new LogEvent(sequenceNumber);
 180             evt.loggerName = name;
 181             evt.level = level;
 182             evt.args = params;
 183             evt.bundle = bundle;
 184             evt.thrown = thrown;
 185             evt.msg = key;
 186             evt.isLoggable = isLoggable;
 187             evt.className = className;
 188             evt.methodName = methodName;
 189             return evt;
 190         }
 191 
 192         public static LogEvent of(boolean isLoggable, String name,
 193                 String className, String methodName,
 194                 sun.util.logging.PlatformLogger.Level level, ResourceBundle bundle,
 195                 String key, Throwable thrown, Object... params) {
 196             return LogEvent.of(sequencer.getAndIncrement(), isLoggable, name,
 197                     className, methodName, level, bundle, key, thrown, params);
 198         }
 199 
 200         public static LogEvent of(long sequenceNumber,
 201                 boolean isLoggable, String name,
 202                 String className, String methodName,
 203                 sun.util.logging.PlatformLogger.Level level, ResourceBundle bundle,
 204                 Supplier&lt;String&gt; supplier, Throwable thrown, Object... params) {
 205             LogEvent evt = new LogEvent(sequenceNumber);
 206             evt.loggerName = name;
 207             evt.level = level;
 208             evt.args = params;
 209             evt.bundle = bundle;
 210             evt.thrown = thrown;
 211             evt.supplier = supplier;
 212             evt.isLoggable = isLoggable;
 213             evt.className = className;
 214             evt.methodName = methodName;
 215             return evt;
 216         }
 217 
 218         public static LogEvent of(boolean isLoggable, String name,
 219                 String className, String methodName,
 220                 sun.util.logging.PlatformLogger.Level level, ResourceBundle bundle,
 221                 Supplier&lt;String&gt; supplier, Throwable thrown, Object... params) {
 222             return LogEvent.of(sequencer.getAndIncrement(), isLoggable, name,
 223                     className, methodName, level, bundle, supplier, thrown, params);
 224         }
 225 
 226     }
 227     static final Class&lt;?&gt; providerClass;
 228     static {
 229         try {
 230             // Preload classes before the security manager is on.
 231             providerClass = ClassLoader.getSystemClassLoader().loadClass(&quot;LogProducerFinder&quot;);
 232             ((LoggerFinder)providerClass.newInstance()).getLogger(&quot;foo&quot;, providerClass.getModule());
 233         } catch (Exception ex) {
 234             throw new ExceptionInInitializerError(ex);
 235         }
 236     }
 237 
 238     public static class LoggerImpl implements System.Logger, PlatformLogger.Bridge {
 239         private final String name;
 240         private PlatformLogger.Level level = PlatformLogger.Level.INFO;
 241         private PlatformLogger.Level OFF = PlatformLogger.Level.OFF;
 242         private PlatformLogger.Level FINE = PlatformLogger.Level.FINE;
 243         private PlatformLogger.Level FINER = PlatformLogger.Level.FINER;
 244         private PlatformLogger.Level FINEST = PlatformLogger.Level.FINEST;
 245         private PlatformLogger.Level CONFIG = PlatformLogger.Level.CONFIG;
 246         private PlatformLogger.Level INFO = PlatformLogger.Level.INFO;
 247         private PlatformLogger.Level WARNING = PlatformLogger.Level.WARNING;
 248         private PlatformLogger.Level SEVERE = PlatformLogger.Level.SEVERE;
 249 
 250         public LoggerImpl(String name) {
 251             this.name = name;
 252         }
 253 
 254         public void configureLevel(PlatformLogger.Level level) {
 255             this.level = level;
 256         }
 257 
 258         @Override
 259         public String getName() {
 260             return name;
 261         }
 262 
 263         @Override
 264         public boolean isLoggable(Level level) {
 265             return this.level != OFF &amp;&amp; this.level.intValue() &lt;= level.getSeverity();
 266         }
 267 
 268         @Override
 269         public void log(Level level, ResourceBundle bundle,
 270                         String key, Throwable thrown) {
 271             throw new UnsupportedOperationException();
 272         }
 273 
 274         @Override
 275         public void log(Level level, ResourceBundle bundle,
 276                         String format, Object... params) {
 277             throw new UnsupportedOperationException();
 278         }
 279 
 280         void log(LogEvent event) {
 281             eventQueue.add(event);
 282         }
 283 
 284         @Override
 285         public void log(Level level, Supplier&lt;String&gt; msgSupplier) {
 286             throw new UnsupportedOperationException();
 287         }
 288 
 289         @Override
 290         public void log(Level level, Supplier&lt;String&gt; msgSupplier,
 291                         Throwable thrown) {
 292             throw new UnsupportedOperationException();
 293         }
 294 
 295         @Override
 296         public void log(PlatformLogger.Level level, String msg) {
 297             log(LogEvent.of(isLoggable(level), name, null, null,
 298                     level, null, msg, null, (Object[]) null));
 299         }
 300 
 301         @Override
 302         public void log(PlatformLogger.Level level,
 303                         Supplier&lt;String&gt; msgSupplier) {
 304             log(LogEvent.of(isLoggable(level), name, null, null,
 305                     level, null, msgSupplier, null, (Object[]) null));
 306         }
 307 
 308         @Override
 309         public void log(PlatformLogger.Level level, String msg,
 310                         Object... params) {
 311             log(LogEvent.of(isLoggable(level), name, null, null,
 312                     level, null, msg, null, params));
 313         }
 314 
 315         @Override
 316         public void log(PlatformLogger.Level level, String msg,
 317                         Throwable thrown) {
 318             log(LogEvent.of(isLoggable(level), name, null, null,
 319                     level, null, msg, thrown, (Object[]) null));
 320         }
 321 
 322         @Override
 323         public void log(PlatformLogger.Level level, Throwable thrown,
 324                         Supplier&lt;String&gt; msgSupplier) {
 325             log(LogEvent.of(isLoggable(level), name, null, null,
 326                     level, null, msgSupplier, thrown, (Object[]) null));
 327         }
 328 
 329         @Override
 330         public void logp(PlatformLogger.Level level, String sourceClass,
 331                          String sourceMethod, String msg) {
 332             log(LogEvent.of(isLoggable(level), name,
 333                     sourceClass, sourceMethod,
 334                     level, null, msg, null, (Object[]) null));
 335         }
 336 
 337         @Override
 338         public void logp(PlatformLogger.Level level, String sourceClass,
 339                          String sourceMethod, Supplier&lt;String&gt; msgSupplier) {
 340             log(LogEvent.of(isLoggable(level), name,
 341                     sourceClass, sourceMethod,
 342                     level, null, msgSupplier, null, (Object[]) null));
 343         }
 344 
 345         @Override
 346         public void logp(PlatformLogger.Level level, String sourceClass,
 347                          String sourceMethod, String msg, Object... params) {
 348             log(LogEvent.of(isLoggable(level), name,
 349                     sourceClass, sourceMethod,
 350                     level, null, msg, null, params));
 351         }
 352 
 353         @Override
 354         public void logp(PlatformLogger.Level level, String sourceClass,
 355                          String sourceMethod, String msg, Throwable thrown) {
 356             log(LogEvent.of(isLoggable(level), name,
 357                     sourceClass, sourceMethod,
 358                     level, null, msg, thrown, (Object[]) null));
 359         }
 360 
 361         @Override
 362         public void logp(PlatformLogger.Level level, String sourceClass,
 363                          String sourceMethod, Throwable thrown,
 364                          Supplier&lt;String&gt; msgSupplier) {
 365             log(LogEvent.of(isLoggable(level), name,
 366                     sourceClass, sourceMethod,
 367                     level, null, msgSupplier, thrown, (Object[]) null));
 368         }
 369 
 370         @Override
 371         public void logrb(PlatformLogger.Level level, String sourceClass,
 372                           String sourceMethod, ResourceBundle bundle, String msg,
 373                           Object... params) {
 374             log(LogEvent.of(isLoggable(level), name,
 375                     sourceClass, sourceMethod,
 376                     level, bundle, msg, null, params));
 377         }
 378 
 379         @Override
 380         public void logrb(PlatformLogger.Level level, ResourceBundle bundle,
 381                           String msg, Object... params) {
 382             log(LogEvent.of(isLoggable(level), name, null, null,
 383                     level, bundle, msg, null, params));
 384         }
 385 
 386         @Override
 387         public void logrb(PlatformLogger.Level level, String sourceClass,
 388                           String sourceMethod, ResourceBundle bundle, String msg,
 389                           Throwable thrown) {
 390             log(LogEvent.of(isLoggable(level), name,
 391                     sourceClass, sourceMethod,
 392                     level, bundle, msg, thrown, (Object[]) null));
 393         }
 394 
 395         @Override
 396         public void logrb(PlatformLogger.Level level, ResourceBundle bundle,
 397                           String msg, Throwable thrown) {
 398             log(LogEvent.of(isLoggable(level), name, null, null,
 399                     level, bundle, msg, thrown, (Object[]) null));
 400         }
 401 
 402         @Override
 403         public boolean isLoggable(PlatformLogger.Level level) {
 404             return this.level != OFF &amp;&amp; level.intValue()
 405                     &gt;= this.level.intValue();
 406         }
 407 
 408         @Override
 409         public boolean isEnabled() {
 410             return this.level != OFF;
 411         }
 412 
 413     }
 414 
 415     static ClassLoader getClassLoader(Module m) {
 416         final boolean before = allowAll.get().getAndSet(true);
 417         try {
 418             return m.getClassLoader();
 419         } finally {
 420             allowAll.get().set(before);
 421         }
 422     }
 423 
 424     static final sun.util.logging.PlatformLogger.Level[] julLevels = {
 425         sun.util.logging.PlatformLogger.Level.ALL,
 426         sun.util.logging.PlatformLogger.Level.FINEST,
 427         sun.util.logging.PlatformLogger.Level.FINER,
 428         sun.util.logging.PlatformLogger.Level.FINE,
 429         sun.util.logging.PlatformLogger.Level.CONFIG,
 430         sun.util.logging.PlatformLogger.Level.INFO,
 431         sun.util.logging.PlatformLogger.Level.WARNING,
 432         sun.util.logging.PlatformLogger.Level.SEVERE,
 433         sun.util.logging.PlatformLogger.Level.OFF,
 434     };
 435 
 436     public static class MyBundle extends ResourceBundle {
 437 
 438         final ConcurrentHashMap&lt;String,String&gt; map = new ConcurrentHashMap&lt;&gt;();
 439 
 440         @Override
 441         protected Object handleGetObject(String key) {
 442             if (key.contains(&quot; (translated)&quot;)) {
 443                 throw new RuntimeException(&quot;Unexpected key: &quot; + key);
 444             }
 445             return map.computeIfAbsent(key, k -&gt; k + &quot; (translated)&quot;);
 446         }
 447 
 448         @Override
 449         public Enumeration&lt;String&gt; getKeys() {
 450             return Collections.enumeration(map.keySet());
 451         }
 452 
 453     }
 454 
 455     public static class MyHandler extends Handler {
 456 
 457         @Override
 458         public java.util.logging.Level getLevel() {
 459             return java.util.logging.Level.ALL;
 460         }
 461 
 462         @Override
 463         public void publish(LogRecord record) {
 464             eventQueue.add(LogEvent.of(sequencer.getAndIncrement(),
 465                     true, record.getLoggerName(),
 466                     record.getSourceClassName(),
 467                     record.getSourceMethodName(),
 468                     PlatformLogger.Level.valueOf(record.getLevel().getName()),
 469                     record.getResourceBundle(), record.getMessage(),
 470                     record.getThrown(), record.getParameters()));
 471         }
 472         @Override
 473         public void flush() {
 474         }
 475         @Override
 476         public void close() throws SecurityException {
 477         }
 478 
 479     }
 480 
 481     public static class MyLoggerBundle extends MyBundle {
 482 
 483     }
 484 
 485     final static Method lazyGetLogger;
 486     static {
 487         // jdk.internal.logging.LoggerBridge.getLogger(name, caller)
 488         try {
 489             Class&lt;?&gt; bridgeClass = Class.forName(&quot;jdk.internal.logger.LazyLoggers&quot;);
 490             lazyGetLogger = bridgeClass.getDeclaredMethod(&quot;getLogger&quot;,
 491                     String.class, Module.class);
 492             lazyGetLogger.setAccessible(true);
 493         } catch (Throwable ex) {
 494             throw new ExceptionInInitializerError(ex);
 495         }
 496     }
 497 
 498     static Logger getLogger(LoggerFinder provider, String name, Module caller) {
 499         Logger logger;
 500         try {
 501             logger = Logger.class.cast(lazyGetLogger.invoke(null, name, caller));
 502         } catch (Throwable x) {
 503             Throwable t = (x instanceof InvocationTargetException) ?
 504                     ((InvocationTargetException)x).getTargetException() : x;
 505             if (t instanceof RuntimeException) {
 506                 throw (RuntimeException)t;
 507             } else if (t instanceof Exception) {
 508                 throw new RuntimeException(t);
 509             } else {
 510                 throw (Error)t;
 511             }
 512         }
 513         // The method above does not throw exception...
 514         // call the provider here to verify that an exception would have
 515         // been thrown by the provider.
 516         if (logger != null &amp;&amp; caller == Thread.class.getModule()) {
 517             Logger log = provider.getLogger(name, caller);
 518         }
 519         return logger;
 520     }
 521 
 522     static Logger getLogger(LoggerFinder provider, String name, ResourceBundle bundle, Module caller) {
 523         if (getClassLoader(caller) != null) {
 524             return System.getLogger(name,bundle);
 525         } else {
 526             return provider.getLocalizedLogger(name, bundle, caller);
 527         }
 528     }
 529 
 530     static PlatformLogger.Bridge convert(Logger logger) {
 531         return PlatformLogger.Bridge.convert(logger);
 532     }
 533 
 534     static enum TestCases {NOSECURITY, NOPERMISSIONS, WITHPERMISSIONS};
 535 
 536     static void setSecurityManager() {
 537         if (System.getSecurityManager() == null) {
 538             Policy.setPolicy(new SimplePolicy(allowControl, allowAccess, allowAll));
 539             System.setSecurityManager(new SecurityManager());
 540         }
 541     }
 542 
 543     public static void main(String[] args) {
 544         if (args.length == 0)
 545             args = new String[] {
 546                 //&quot;NOSECURITY&quot;,
 547                 &quot;NOPERMISSIONS&quot;,
 548                 &quot;WITHPERMISSIONS&quot;
 549             };
 550 
 551 
 552         Stream.of(args).map(TestCases::valueOf).forEach((testCase) -&gt; {
 553             LoggerFinder provider;
 554             switch (testCase) {
 555                 case NOSECURITY:
 556                     System.out.println(&quot;\n*** Without Security Manager\n&quot;);
 557                     provider = LoggerFinder.getLoggerFinder();
 558                     test(provider, true);
 559                     System.out.println(&quot;Tetscase count: &quot; + sequencer.get());
 560                     break;
 561                 case NOPERMISSIONS:
 562                     System.out.println(&quot;\n*** With Security Manager, without permissions\n&quot;);
 563                     setSecurityManager();
 564                     try {
 565                         provider = LoggerFinder.getLoggerFinder();
 566                         throw new RuntimeException(&quot;Expected exception not raised&quot;);
 567                     } catch (AccessControlException x) {
 568                         if (!LOGGERFINDER_PERMISSION.equals(x.getPermission())) {
 569                             throw new RuntimeException(&quot;Unexpected permission check&quot;, x);
 570                         }
 571                         final boolean control = allowControl.get().get();
 572                         try {
 573                             allowControl.get().set(true);
 574                             provider = LoggerFinder.getLoggerFinder();
 575                         } finally {
 576                             allowControl.get().set(control);
 577                         }
 578                     }
 579                     test(provider, false);
 580                     System.out.println(&quot;Tetscase count: &quot; + sequencer.get());
 581                     break;
 582                 case WITHPERMISSIONS:
 583                     System.out.println(&quot;\n*** With Security Manager, with control permission\n&quot;);
 584                     setSecurityManager();
 585                     final boolean control = allowControl.get().get();
 586                     try {
 587                         allowControl.get().set(true);
 588                         provider = LoggerFinder.getLoggerFinder();
 589                         test(provider, true);
 590                     } finally {
 591                         allowControl.get().set(control);
 592                     }
 593                     break;
 594                 default:
 595                     throw new RuntimeException(&quot;Unknown test case: &quot; + testCase);
 596             }
 597         });
 598         System.out.println(&quot;\nPASSED: Tested &quot; + sequencer.get() + &quot; cases.&quot;);
 599     }
 600 
 601     public static void test(LoggerFinder provider, boolean hasRequiredPermissions) {
 602 
 603         ResourceBundle loggerBundle = ResourceBundle.getBundle(MyLoggerBundle.class.getName());
 604         final Map&lt;Object, String&gt; loggerDescMap = new HashMap&lt;&gt;();
 605 
 606 
 607         Logger appLogger1 = System.getLogger(&quot;foo&quot;);
 608         loggerDescMap.put(appLogger1, &quot;System.getLogger(\&quot;foo\&quot;)&quot;);
 609 
 610         Logger sysLogger1 = null;
 611         try {
 612             sysLogger1 = getLogger(provider, &quot;foo&quot;, Thread.class.getModule());
 613             loggerDescMap.put(sysLogger1, &quot;provider.getLogger(\&quot;foo\&quot;, Thread.class.getModule())&quot;);
 614             if (!hasRequiredPermissions) {
 615                 throw new RuntimeException(&quot;Managed to obtain a system logger without permission&quot;);
 616             }
 617         } catch (AccessControlException acx) {
 618             if (hasRequiredPermissions) {
 619                 throw new RuntimeException(&quot;Unexpected security exception: &quot;, acx);
 620             }
 621             if (!acx.getPermission().equals(LOGGERFINDER_PERMISSION)) {
 622                 throw new RuntimeException(&quot;Unexpected permission in exception: &quot; + acx, acx);
 623             }
 624             System.out.println(&quot;Got expected exception for system logger: &quot; + acx);
 625         }
 626 
 627 
 628         Logger appLogger2 =
 629                 System.getLogger(&quot;foo&quot;, loggerBundle);
 630         loggerDescMap.put(appLogger2, &quot;System.getLogger(\&quot;foo\&quot;, loggerBundle)&quot;);
 631 
 632         Logger sysLogger2 = null;
 633         try {
 634             sysLogger2 = getLogger(provider, &quot;foo&quot;, loggerBundle, Thread.class.getModule());
 635             loggerDescMap.put(sysLogger2, &quot;provider.getLogger(\&quot;foo\&quot;, loggerBundle, Thread.class.getModule())&quot;);
 636             if (!hasRequiredPermissions) {
 637                 throw new RuntimeException(&quot;Managed to obtain a system logger without permission&quot;);
 638             }
 639         } catch (AccessControlException acx) {
 640             if (hasRequiredPermissions) {
 641                 throw new RuntimeException(&quot;Unexpected security exception: &quot;, acx);
 642             }
 643             if (!acx.getPermission().equals(LOGGERFINDER_PERMISSION)) {
 644                 throw new RuntimeException(&quot;Unexpected permission in exception: &quot; + acx, acx);
 645             }
 646             System.out.println(&quot;Got expected exception for localized system logger: &quot; + acx);
 647         }
 648         if (hasRequiredPermissions &amp;&amp; appLogger2 == sysLogger2) {
 649             throw new RuntimeException(&quot;identical loggers&quot;);
 650         }
 651         if (appLogger2 == appLogger1) {
 652             throw new RuntimeException(&quot;identical loggers&quot;);
 653         }
 654         if (hasRequiredPermissions &amp;&amp; sysLogger2 == sysLogger1) {
 655             throw new RuntimeException(&quot;identical loggers&quot;);
 656         }
 657 
 658 
 659         final LoggerImpl appSink;
 660         final LoggerImpl sysSink;
 661         boolean old = allowControl.get().get();
 662         allowControl.get().set(true);
 663         try {
 664            appSink = LoggerImpl.class.cast(
 665                    provider.getLogger(&quot;foo&quot;,  LoggerBridgeTest.class.getModule()));
 666            sysSink = LoggerImpl.class.cast(
 667                         provider.getLogger(&quot;foo&quot;, Thread.class.getModule()));
 668         } finally {
 669             allowControl.get().set(old);
 670         }
 671 
 672         testLogger(provider, loggerDescMap, &quot;foo&quot;, null, convert(appLogger1), appSink);
 673         if (hasRequiredPermissions) {
 674             testLogger(provider, loggerDescMap, &quot;foo&quot;, null, convert(sysLogger1), sysSink);
 675         }
 676         testLogger(provider, loggerDescMap, &quot;foo&quot;, loggerBundle, convert(appLogger2), appSink);
 677         if (hasRequiredPermissions) {
 678             testLogger(provider, loggerDescMap, &quot;foo&quot;, loggerBundle, convert(sysLogger2), sysSink);
 679         }
 680     }
 681 
 682     public static class Foo {
 683 
 684     }
 685 
 686     static void verbose(String msg) {
 687        if (VERBOSE) {
 688            System.out.println(msg);
 689        }
 690     }
 691 
 692     static void checkLogEvent(LoggerFinder provider, String desc,
 693             LogEvent expected) {
 694         LogEvent actual =  eventQueue.poll();
 695         if (!expected.equals(actual)) {
 696             throw new RuntimeException(&quot;mismatch for &quot; + desc
 697                     + &quot;\n\texpected=&quot; + expected
 698                     + &quot;\n\t  actual=&quot; + actual);
 699         } else {
 700             verbose(&quot;Got expected results for &quot;
 701                     + desc + &quot;\n\t&quot; + expected);
 702         }
 703     }
 704 
 705     static void checkLogEvent(LoggerFinder provider, String desc,
 706             LogEvent expected, boolean expectNotNull) {
 707         LogEvent actual =  eventQueue.poll();
 708         if (actual == null &amp;&amp; !expectNotNull) return;
 709         if (actual != null &amp;&amp; !expectNotNull) {
 710             throw new RuntimeException(&quot;Unexpected log event found for &quot; + desc
 711                 + &quot;\n\tgot: &quot; + actual);
 712         }
 713         if (!expected.equals(actual)) {
 714             throw new RuntimeException(&quot;mismatch for &quot; + desc
 715                     + &quot;\n\texpected=&quot; + expected
 716                     + &quot;\n\t  actual=&quot; + actual);
 717         } else {
 718             verbose(&quot;Got expected results for &quot;
 719                     + desc + &quot;\n\t&quot; + expected);
 720         }
 721     }
 722 
 723     static void setLevel(LoggerImpl sink,
 724             sun.util.logging.PlatformLogger.Level loggerLevel) {
 725         sink.configureLevel(loggerLevel);
 726     }
 727 
 728     // Calls the methods defined on PlatformLogger.Bridge and verify the
 729     // parameters received by the underlying LoggerImpl
 730     // logger.
 731     private static void testLogger(LoggerFinder provider,
 732             Map&lt;Object, String&gt; loggerDescMap,
 733             String name,
 734             ResourceBundle loggerBundle,
 735             PlatformLogger.Bridge logger,
 736             LoggerImpl sink) {
 737 
 738         System.out.println(&quot;Testing &quot; + loggerDescMap.get(logger) + &quot;[&quot; + logger + &quot;]&quot;);
 739         final sun.util.logging.PlatformLogger.Level OFF = sun.util.logging.PlatformLogger.Level.OFF;
 740 
 741         Foo foo = new Foo();
 742         String fooMsg = foo.toString();
 743         System.out.println(&quot;\tlogger.log(messageLevel, fooMsg)&quot;);
 744         System.out.println(&quot;\tlogger.&lt;level&gt;(fooMsg)&quot;);
 745         for (sun.util.logging.PlatformLogger.Level loggerLevel : julLevels) {
 746             setLevel(sink, loggerLevel);
 747             for (sun.util.logging.PlatformLogger.Level messageLevel :julLevels) {
 748                 String desc = &quot;logger.log(messageLevel, fooMsg): loggerLevel=&quot;
 749                         + loggerLevel+&quot;, messageLevel=&quot;+messageLevel;
 750                 LogEvent expected =
 751                         LogEvent.of(
 752                             sequencer.get(),
 753                             loggerLevel != OFF &amp;&amp; messageLevel.intValue() &gt;= loggerLevel.intValue(),
 754                             name, messageLevel, loggerBundle,
 755                             fooMsg, (Throwable)null, (Object[])null);
 756                 logger.log(messageLevel, fooMsg);
 757                 checkLogEvent(provider, desc, expected);
 758             }
 759         }
 760 
 761         Supplier&lt;String&gt; supplier = new Supplier&lt;String&gt;() {
 762             @Override
 763             public String get() {
 764                 return this.toString();
 765             }
 766         };
 767         System.out.println(&quot;\tlogger.log(messageLevel, supplier)&quot;);
 768         System.out.println(&quot;\tlogger.&lt;level&gt;(supplier)&quot;);
 769         for (sun.util.logging.PlatformLogger.Level loggerLevel : julLevels) {
 770             setLevel(sink, loggerLevel);
 771             for (sun.util.logging.PlatformLogger.Level messageLevel :julLevels) {
 772                 String desc = &quot;logger.log(messageLevel, supplier): loggerLevel=&quot;
 773                         + loggerLevel+&quot;, messageLevel=&quot;+messageLevel;
 774                 LogEvent expected =
 775                         LogEvent.of(
 776                             sequencer.get(),
 777                             loggerLevel != OFF &amp;&amp; messageLevel.intValue() &gt;= loggerLevel.intValue(),
 778                             name, messageLevel, null,
 779                             supplier, (Throwable)null, (Object[])null);
 780                 logger.log(messageLevel, supplier);
 781                 checkLogEvent(provider, desc, expected);
 782             }
 783         }
 784 
 785         String format = &quot;two params [{1} {2}]&quot;;
 786         Object arg1 = foo;
 787         Object arg2 = fooMsg;
 788         System.out.println(&quot;\tlogger.log(messageLevel, format, arg1, arg2)&quot;);
 789         for (sun.util.logging.PlatformLogger.Level loggerLevel : julLevels) {
 790             setLevel(sink, loggerLevel);
 791             for (sun.util.logging.PlatformLogger.Level messageLevel :julLevels) {
 792                 String desc = &quot;logger.log(messageLevel, format, foo, fooMsg): loggerLevel=&quot;
 793                         + loggerLevel+&quot;, messageLevel=&quot;+messageLevel;
 794                 LogEvent expected =
 795                         LogEvent.of(
 796                             sequencer.get(),
 797                             loggerLevel != OFF &amp;&amp; messageLevel.intValue() &gt;= loggerLevel.intValue(),
 798                             name, messageLevel, loggerBundle,
 799                             format, (Throwable)null, arg1, arg2);
 800                 logger.log(messageLevel, format, arg1, arg2);
 801                 checkLogEvent(provider, desc, expected);
 802             }
 803         }
 804 
 805         Throwable thrown = new Exception(&quot;OK: log me!&quot;);
 806         System.out.println(&quot;\tlogger.log(messageLevel, fooMsg, thrown)&quot;);
 807         for (sun.util.logging.PlatformLogger.Level loggerLevel : julLevels) {
 808             setLevel(sink, loggerLevel);
 809             for (sun.util.logging.PlatformLogger.Level messageLevel :julLevels) {
 810                 String desc = &quot;logger.log(messageLevel, fooMsg, thrown): loggerLevel=&quot;
 811                         + loggerLevel+&quot;, messageLevel=&quot;+messageLevel;
 812                 LogEvent expected =
 813                         LogEvent.of(
 814                             sequencer.get(),
 815                             loggerLevel != OFF &amp;&amp; messageLevel.intValue() &gt;= loggerLevel.intValue(),
 816                             name, messageLevel, loggerBundle,
 817                             fooMsg, thrown, (Object[])null);
 818                 logger.log(messageLevel, fooMsg, thrown);
 819                 checkLogEvent(provider, desc, expected);
 820             }
 821         }
 822 
 823         System.out.println(&quot;\tlogger.log(messageLevel, thrown, supplier)&quot;);
 824         for (sun.util.logging.PlatformLogger.Level loggerLevel : julLevels) {
 825             setLevel(sink, loggerLevel);
 826             for (sun.util.logging.PlatformLogger.Level messageLevel :julLevels) {
 827                 String desc = &quot;logger.log(messageLevel, thrown, supplier): loggerLevel=&quot;
 828                         + loggerLevel+&quot;, messageLevel=&quot;+messageLevel;
 829                 LogEvent expected =
 830                         LogEvent.of(
 831                             sequencer.get(),
 832                             loggerLevel != OFF &amp;&amp; messageLevel.intValue() &gt;= loggerLevel.intValue(),
 833                             name, messageLevel, null,
 834                             supplier, thrown, (Object[])null);
 835                 logger.log(messageLevel, thrown, supplier);
 836                 checkLogEvent(provider, desc, expected);
 837             }
 838         }
 839 
 840         String sourceClass = &quot;blah.Blah&quot;;
 841         String sourceMethod = &quot;blih&quot;;
 842         System.out.println(&quot;\tlogger.logp(messageLevel, sourceClass, sourceMethod, fooMsg)&quot;);
 843         for (sun.util.logging.PlatformLogger.Level loggerLevel : julLevels) {
 844             setLevel(sink, loggerLevel);
 845             for (sun.util.logging.PlatformLogger.Level messageLevel :julLevels) {
 846                 String desc = &quot;logger.logp(messageLevel, sourceClass, sourceMethod, fooMsg): loggerLevel=&quot;
 847                         + loggerLevel+&quot;, messageLevel=&quot;+messageLevel;
 848                 LogEvent expected =
 849                         LogEvent.of(
 850                             sequencer.get(),
 851                             loggerLevel != OFF &amp;&amp; messageLevel.intValue() &gt;= loggerLevel.intValue(),
 852                             name, sourceClass, sourceMethod, messageLevel, loggerBundle,
 853                             fooMsg, (Throwable)null, (Object[])null);
 854                 logger.logp(messageLevel, sourceClass, sourceMethod, fooMsg);
 855                 checkLogEvent(provider, desc, expected);
 856             }
 857         }
 858 
 859         System.out.println(&quot;\tlogger.logp(messageLevel, sourceClass, sourceMethod, supplier)&quot;);
 860         for (sun.util.logging.PlatformLogger.Level loggerLevel : julLevels) {
 861             setLevel(sink, loggerLevel);
 862             for (sun.util.logging.PlatformLogger.Level messageLevel :julLevels) {
 863                 String desc = &quot;logger.logp(messageLevel, sourceClass, sourceMethod, supplier): loggerLevel=&quot;
 864                         + loggerLevel+&quot;, messageLevel=&quot;+messageLevel;
 865                 LogEvent expected =
 866                         LogEvent.of(
 867                             sequencer.get(),
 868                             loggerLevel != OFF &amp;&amp; messageLevel.intValue() &gt;= loggerLevel.intValue(),
 869                             name, sourceClass, sourceMethod, messageLevel, null,
 870                             supplier, (Throwable)null, (Object[])null);
 871                 logger.logp(messageLevel, sourceClass, sourceMethod, supplier);
 872                 checkLogEvent(provider, desc, expected);
 873             }
 874         }
 875 
 876         System.out.println(&quot;\tlogger.logp(messageLevel, sourceClass, sourceMethod, format, arg1, arg2)&quot;);
 877         for (sun.util.logging.PlatformLogger.Level loggerLevel : julLevels) {
 878             setLevel(sink, loggerLevel);
 879             for (sun.util.logging.PlatformLogger.Level messageLevel :julLevels) {
 880                 String desc = &quot;logger.logp(messageLevel, sourceClass, sourceMethod, format, arg1, arg2): loggerLevel=&quot;
 881                         + loggerLevel+&quot;, messageLevel=&quot;+messageLevel;
 882                 LogEvent expected =
 883                         LogEvent.of(
 884                             sequencer.get(),
 885                             loggerLevel != OFF &amp;&amp; messageLevel.intValue() &gt;= loggerLevel.intValue(),
 886                             name, sourceClass, sourceMethod, messageLevel, loggerBundle,
 887                             format, (Throwable)null, arg1, arg2);
 888                 logger.logp(messageLevel, sourceClass, sourceMethod, format, arg1, arg2);
 889                 checkLogEvent(provider, desc, expected);
 890             }
 891         }
 892 
 893         System.out.println(&quot;\tlogger.logp(messageLevel, sourceClass, sourceMethod, fooMsg, thrown)&quot;);
 894         for (sun.util.logging.PlatformLogger.Level loggerLevel : julLevels) {
 895             setLevel(sink, loggerLevel);
 896             for (sun.util.logging.PlatformLogger.Level messageLevel :julLevels) {
 897                 String desc = &quot;logger.logp(messageLevel, sourceClass, sourceMethod, fooMsg, thrown): loggerLevel=&quot;
 898                         + loggerLevel+&quot;, messageLevel=&quot;+messageLevel;
 899                 LogEvent expected =
 900                         LogEvent.of(
 901                             sequencer.get(),
 902                             loggerLevel != OFF &amp;&amp; messageLevel.intValue() &gt;= loggerLevel.intValue(),
 903                             name, sourceClass, sourceMethod, messageLevel, loggerBundle,
 904                             fooMsg, thrown, (Object[])null);
 905                 logger.logp(messageLevel, sourceClass, sourceMethod, fooMsg, thrown);
 906                 checkLogEvent(provider, desc, expected);
 907             }
 908         }
 909 
 910         System.out.println(&quot;\tlogger.logp(messageLevel, sourceClass, sourceMethod, thrown, supplier)&quot;);
 911         for (sun.util.logging.PlatformLogger.Level loggerLevel : julLevels) {
 912             setLevel(sink, loggerLevel);
 913             for (sun.util.logging.PlatformLogger.Level messageLevel :julLevels) {
 914                 String desc = &quot;logger.logp(messageLevel, sourceClass, sourceMethod, thrown, supplier): loggerLevel=&quot;
 915                         + loggerLevel+&quot;, messageLevel=&quot;+messageLevel;
 916                 LogEvent expected =
 917                         LogEvent.of(
 918                             sequencer.get(),
 919                             loggerLevel != OFF &amp;&amp; messageLevel.intValue() &gt;= loggerLevel.intValue(),
 920                             name, sourceClass, sourceMethod, messageLevel, null,
 921                             supplier, thrown, (Object[])null);
 922                 logger.logp(messageLevel, sourceClass, sourceMethod, thrown, supplier);
 923                 checkLogEvent(provider, desc, expected);
 924             }
 925         }
 926 
 927         ResourceBundle bundle = ResourceBundle.getBundle(MyBundle.class.getName());
 928         System.out.println(&quot;\tlogger.logrb(messageLevel, bundle, format, arg1, arg2)&quot;);
 929         for (sun.util.logging.PlatformLogger.Level loggerLevel : julLevels) {
 930             setLevel(sink, loggerLevel);
 931             for (sun.util.logging.PlatformLogger.Level messageLevel :julLevels) {
 932                 String desc = &quot;logger.logrb(messageLevel, bundle, format, arg1, arg2): loggerLevel=&quot;
 933                         + loggerLevel+&quot;, messageLevel=&quot;+messageLevel;
 934                 LogEvent expected =
 935                         LogEvent.of(
 936                             sequencer.get(),
 937                             loggerLevel != OFF &amp;&amp; messageLevel.intValue() &gt;= loggerLevel.intValue(),
 938                             name, messageLevel, bundle,
 939                             format, (Throwable)null, arg1, arg2);
 940                 logger.logrb(messageLevel, bundle, format, arg1, arg2);
 941                 checkLogEvent(provider, desc, expected);
 942             }
 943         }
 944 
 945         System.out.println(&quot;\tlogger.logrb(messageLevel, bundle, msg, thrown)&quot;);
 946         for (sun.util.logging.PlatformLogger.Level loggerLevel : julLevels) {
 947             setLevel(sink, loggerLevel);
 948             for (sun.util.logging.PlatformLogger.Level messageLevel :julLevels) {
 949                 String desc = &quot;logger.logrb(messageLevel, bundle, msg, thrown): loggerLevel=&quot;
 950                         + loggerLevel+&quot;, messageLevel=&quot;+messageLevel;
 951                 LogEvent expected =
 952                         LogEvent.of(
 953                             sequencer.get(),
 954                             loggerLevel != OFF &amp;&amp; messageLevel.intValue() &gt;= loggerLevel.intValue(),
 955                             name, messageLevel, bundle,
 956                             fooMsg, thrown, (Object[])null);
 957                 logger.logrb(messageLevel, bundle, fooMsg, thrown);
 958                 checkLogEvent(provider, desc, expected);
 959             }
 960         }
 961 
 962         System.out.println(&quot;\tlogger.logrb(messageLevel, sourceClass, sourceMethod, bundle, format, arg1, arg2)&quot;);
 963         for (sun.util.logging.PlatformLogger.Level loggerLevel : julLevels) {
 964             setLevel(sink, loggerLevel);
 965             for (sun.util.logging.PlatformLogger.Level messageLevel :julLevels) {
 966                 String desc = &quot;logger.logrb(messageLevel, sourceClass, sourceMethod, bundle, format, arg1, arg2): loggerLevel=&quot;
 967                         + loggerLevel+&quot;, messageLevel=&quot;+messageLevel;
 968                 LogEvent expected =
 969                         LogEvent.of(
 970                             sequencer.get(),
 971                             loggerLevel != OFF &amp;&amp; messageLevel.intValue() &gt;= loggerLevel.intValue(),
 972                             name, sourceClass, sourceMethod, messageLevel, bundle,
 973                             format, (Throwable)null, arg1, arg2);
 974                 logger.logrb(messageLevel, sourceClass, sourceMethod, bundle, format, arg1, arg2);
 975                 checkLogEvent(provider, desc, expected);
 976             }
 977         }
 978 
 979         System.out.println(&quot;\tlogger.logrb(messageLevel, sourceClass, sourceMethod, bundle, msg, thrown)&quot;);
 980         for (sun.util.logging.PlatformLogger.Level loggerLevel : julLevels) {
 981             setLevel(sink, loggerLevel);
 982             for (sun.util.logging.PlatformLogger.Level messageLevel :julLevels) {
 983                 String desc = &quot;logger.logrb(messageLevel, sourceClass, sourceMethod, bundle, msg, thrown): loggerLevel=&quot;
 984                         + loggerLevel+&quot;, messageLevel=&quot;+messageLevel;
 985                 LogEvent expected =
 986                         LogEvent.of(
 987                             sequencer.get(),
 988                             loggerLevel != OFF &amp;&amp; messageLevel.intValue() &gt;= loggerLevel.intValue(),
 989                             name, sourceClass, sourceMethod, messageLevel, bundle,
 990                             fooMsg, thrown, (Object[])null);
 991                 logger.logrb(messageLevel, sourceClass, sourceMethod, bundle, fooMsg, thrown);
 992                 checkLogEvent(provider, desc, expected);
 993             }
 994         }
 995     }
 996 
 997     final static class PermissionsBuilder {
 998         final Permissions perms;
 999         public PermissionsBuilder() {
1000             this(new Permissions());
1001         }
1002         public PermissionsBuilder(Permissions perms) {
1003             this.perms = perms;
1004         }
1005         public PermissionsBuilder add(Permission p) {
1006             perms.add(p);
1007             return this;
1008         }
1009         public PermissionsBuilder addAll(PermissionCollection col) {
1010             if (col != null) {
1011                 for (Enumeration&lt;Permission&gt; e = col.elements(); e.hasMoreElements(); ) {
1012                     perms.add(e.nextElement());
1013                 }
1014             }
1015             return this;
1016         }
1017         public Permissions toPermissions() {
1018             final PermissionsBuilder builder = new PermissionsBuilder();
1019             builder.addAll(perms);
1020             return builder.perms;
1021         }
1022     }
1023 
1024     public static class SimplePolicy extends Policy {
1025         final static RuntimePermission CONTROL = LOGGERFINDER_PERMISSION;
1026         final static RuntimePermission ACCESS_LOGGER = new RuntimePermission(&quot;accessClassInPackage.jdk.internal.logger&quot;);
1027         final static RuntimePermission ACCESS_LOGGING = new RuntimePermission(&quot;accessClassInPackage.sun.util.logging&quot;);
1028 
1029         static final Policy DEFAULT_POLICY = Policy.getPolicy();
1030 
1031         final Permissions permissions;
1032         final Permissions allPermissions;
1033         final ThreadLocal&lt;AtomicBoolean&gt; allowControl;
1034         final ThreadLocal&lt;AtomicBoolean&gt; allowAccess;
1035         final ThreadLocal&lt;AtomicBoolean&gt; allowAll;
1036         public SimplePolicy(ThreadLocal&lt;AtomicBoolean&gt; allowControl,
1037                 ThreadLocal&lt;AtomicBoolean&gt; allowAccess,
1038                 ThreadLocal&lt;AtomicBoolean&gt; allowAll) {
1039             this.allowControl = allowControl;
1040             this.allowAccess = allowAccess;
1041             this.allowAll = allowAll;
1042             permissions = new Permissions();
1043             allPermissions = new PermissionsBuilder()
1044                     .add(new java.security.AllPermission())
1045                     .toPermissions();
1046         }
1047 
1048         Permissions getPermissions() {
1049             if (allowControl.get().get() || allowAccess.get().get() || allowAll.get().get()) {
1050                 PermissionsBuilder builder =  new PermissionsBuilder()
1051                         .addAll(permissions);
1052                 if (allowControl.get().get()) {
1053                     builder.add(CONTROL);
1054                 }
1055                 if (allowAccess.get().get()) {
1056                     builder.add(ACCESS_LOGGER);
1057                     builder.add(ACCESS_LOGGING);
1058                 }
1059                 if (allowAll.get().get()) {
1060                     builder.addAll(allPermissions);
1061                 }
1062                 return builder.toPermissions();
1063             }
1064             return permissions;
1065         }
1066 
1067         @Override
1068         public boolean implies(ProtectionDomain domain, Permission permission) {
1069             return getPermissions().implies(permission) || DEFAULT_POLICY.implies(domain, permission);
1070         }
1071 
1072         @Override
1073         public PermissionCollection getPermissions(CodeSource codesource) {
1074             return new PermissionsBuilder().addAll(getPermissions()).toPermissions();
1075         }
1076 
1077         @Override
1078         public PermissionCollection getPermissions(ProtectionDomain domain) {
1079             return new PermissionsBuilder().addAll(getPermissions()).toPermissions();
1080         }
1081     }
1082 }
    </pre>
  </body>
</html>
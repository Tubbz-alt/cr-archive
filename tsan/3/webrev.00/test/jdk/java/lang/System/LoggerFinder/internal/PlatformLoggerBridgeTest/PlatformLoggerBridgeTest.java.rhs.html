<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames test/jdk/java/lang/System/LoggerFinder/internal/PlatformLoggerBridgeTest/PlatformLoggerBridgeTest.java</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
<a name="1" id="anc1"></a><span class="line-modified">  2  * Copyright (c) 2015, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 import java.security.AccessControlException;
 24 import java.security.AccessController;
 25 import java.security.CodeSource;
 26 import java.security.Permission;
 27 import java.security.PermissionCollection;
 28 import java.security.Permissions;
 29 import java.security.Policy;
 30 import java.security.PrivilegedAction;
 31 import java.security.ProtectionDomain;
 32 import java.util.Arrays;
 33 import java.util.Collections;
 34 import java.util.Enumeration;
 35 import java.util.HashMap;
 36 import java.util.Map;
 37 import java.util.Objects;
 38 import java.util.Queue;
 39 import java.util.ResourceBundle;
 40 import java.util.concurrent.ArrayBlockingQueue;
 41 import java.util.concurrent.ConcurrentHashMap;
 42 import java.util.concurrent.atomic.AtomicBoolean;
 43 import java.util.concurrent.atomic.AtomicLong;
 44 import java.util.function.Supplier;
 45 import java.util.logging.Handler;
 46 import java.util.logging.LogRecord;
 47 import java.lang.System.LoggerFinder;
 48 import java.lang.System.Logger;
 49 import java.lang.System.Logger.Level;
 50 import java.util.stream.Stream;
 51 import sun.util.logging.PlatformLogger;
 52 
 53 /**
 54  * @test
 55  * @bug     8140364
 56  * @summary JDK implementation specific unit test for JDK internal artifacts.
 57  *          Tests all bridge methods from PlatformLogger with the a custom
 58  *          backend whose loggers implement PlatformLogger.Bridge.
 59  * @modules java.base/sun.util.logging
 60  *          java.logging
 61  * @build CustomSystemClassLoader LogProducerFinder PlatformLoggerBridgeTest
 62  * @run  main/othervm -Djava.system.class.loader=CustomSystemClassLoader PlatformLoggerBridgeTest NOSECURITY
 63  * @run  main/othervm -Djava.system.class.loader=CustomSystemClassLoader PlatformLoggerBridgeTest NOPERMISSIONS
 64  * @run  main/othervm -Djava.system.class.loader=CustomSystemClassLoader PlatformLoggerBridgeTest WITHPERMISSIONS
 65  * @author danielfuchs
 66  */
 67 public class PlatformLoggerBridgeTest {
 68 
 69     static final RuntimePermission LOGGERFINDER_PERMISSION =
 70                 new RuntimePermission(&quot;loggerFinder&quot;);
 71     final static AtomicLong sequencer = new AtomicLong();
 72     final static boolean VERBOSE = false;
 73     static final ThreadLocal&lt;AtomicBoolean&gt; allowControl = new ThreadLocal&lt;AtomicBoolean&gt;() {
 74         @Override
 75         protected AtomicBoolean initialValue() {
 76             return  new AtomicBoolean(false);
 77         }
 78     };
 79     static final ThreadLocal&lt;AtomicBoolean&gt; allowAccess = new ThreadLocal&lt;AtomicBoolean&gt;() {
 80         @Override
 81         protected AtomicBoolean initialValue() {
 82             return  new AtomicBoolean(false);
 83         }
 84     };
 85     static final ThreadLocal&lt;AtomicBoolean&gt; allowAll = new ThreadLocal&lt;AtomicBoolean&gt;() {
 86         @Override
 87         protected AtomicBoolean initialValue() {
 88             return  new AtomicBoolean(false);
 89         }
 90     };
 91 
 92     public static final Queue&lt;LogEvent&gt; eventQueue = new ArrayBlockingQueue&lt;&gt;(128);
 93 
 94     static final Class&lt;?&gt; providerClass;
 95     static {
 96         try {
 97             // Preload classes before the security manager is on.
 98             providerClass = ClassLoader.getSystemClassLoader().loadClass(&quot;LogProducerFinder&quot;);
 99             ((LoggerFinder)providerClass.newInstance()).getLogger(&quot;foo&quot;, providerClass.getModule());
100         } catch (Exception ex) {
101             throw new ExceptionInInitializerError(ex);
102         }
103     }
104 
105     public static final class LogEvent implements Cloneable {
106 
107         public LogEvent() {
108             this(sequencer.getAndIncrement());
109         }
110 
111         LogEvent(long sequenceNumber) {
112             this.sequenceNumber = sequenceNumber;
113         }
114 
115         long sequenceNumber;
116         boolean isLoggable;
117         String loggerName;
118         sun.util.logging.PlatformLogger.Level level;
119         ResourceBundle bundle;
120         Throwable thrown;
121         Object[] args;
122         String msg;
123         Supplier&lt;String&gt; supplier;
124         String className;
125         String methodName;
126 
127         Object[] toArray() {
128             return new Object[] {
129                 sequenceNumber,
130                 loggerName,
131                 level,
132                 isLoggable,
133                 bundle,
134                 msg,
135                 supplier,
136                 thrown,
137                 args,
138                 className,
139                 methodName,
140             };
141         }
142 
143         @Override
144         public String toString() {
145             return Arrays.deepToString(toArray());
146         }
147 
148         @Override
149         public boolean equals(Object obj) {
150             return obj instanceof LogEvent
151                     &amp;&amp; Objects.deepEquals(this.toArray(), ((LogEvent)obj).toArray());
152         }
153 
154         @Override
155         public int hashCode() {
156             return Objects.hash(toArray());
157         }
158 
159         public LogEvent cloneWith(long sequenceNumber)
160                 throws CloneNotSupportedException {
161             LogEvent cloned = (LogEvent)super.clone();
162             cloned.sequenceNumber = sequenceNumber;
163             return cloned;
164         }
165 
166         public static LogEvent of(long sequenceNumber,
167                 boolean isLoggable, String name,
168                 sun.util.logging.PlatformLogger.Level level, ResourceBundle bundle,
169                 String key, Throwable thrown, Object... params) {
170             return LogEvent.of(sequenceNumber, isLoggable, name,
171                     null, null, level, bundle, key,
172                     thrown, params);
173         }
174         public static LogEvent of(long sequenceNumber,
175                 boolean isLoggable, String name,
176                 sun.util.logging.PlatformLogger.Level level, ResourceBundle bundle,
177                 Supplier&lt;String&gt; supplier, Throwable thrown, Object... params) {
178             return LogEvent.of(sequenceNumber, isLoggable, name,
179                     null, null, level, bundle, supplier,
180                     thrown, params);
181         }
182 
183         public static LogEvent of(long sequenceNumber,
184                 boolean isLoggable, String name,
185                 String className, String methodName,
186                 sun.util.logging.PlatformLogger.Level level, ResourceBundle bundle,
187                 String key, Throwable thrown, Object... params) {
188             LogEvent evt = new LogEvent(sequenceNumber);
189             evt.loggerName = name;
190             evt.level = level;
191             evt.args = params;
192             evt.bundle = bundle;
193             evt.thrown = thrown;
194             evt.msg = key;
195             evt.isLoggable = isLoggable;
196             evt.className = className;
197             evt.methodName = methodName;
198             return evt;
199         }
200 
201         public static LogEvent of(boolean isLoggable, String name,
202                 String className, String methodName,
203                 sun.util.logging.PlatformLogger.Level level, ResourceBundle bundle,
204                 String key, Throwable thrown, Object... params) {
205             return LogEvent.of(sequencer.getAndIncrement(), isLoggable, name,
206                     className, methodName, level, bundle, key, thrown, params);
207         }
208 
209         public static LogEvent of(long sequenceNumber,
210                 boolean isLoggable, String name,
211                 String className, String methodName,
212                 sun.util.logging.PlatformLogger.Level level, ResourceBundle bundle,
213                 Supplier&lt;String&gt; supplier, Throwable thrown, Object... params) {
214             LogEvent evt = new LogEvent(sequenceNumber);
215             evt.loggerName = name;
216             evt.level = level;
217             evt.args = params;
218             evt.bundle = bundle;
219             evt.thrown = thrown;
220             evt.supplier = supplier;
221             evt.isLoggable = isLoggable;
222             evt.className = className;
223             evt.methodName = methodName;
224             return evt;
225         }
226 
227         public static LogEvent of(boolean isLoggable, String name,
228                 String className, String methodName,
229                 sun.util.logging.PlatformLogger.Level level, ResourceBundle bundle,
230                 Supplier&lt;String&gt; supplier, Throwable thrown, Object... params) {
231             return LogEvent.of(sequencer.getAndIncrement(), isLoggable, name,
232                     className, methodName, level, bundle, supplier, thrown, params);
233         }
234 
235     }
236 
237     public static class LoggerImpl implements System.Logger, PlatformLogger.Bridge {
238         private final String name;
239         private sun.util.logging.PlatformLogger.Level level = sun.util.logging.PlatformLogger.Level.INFO;
240         private sun.util.logging.PlatformLogger.Level OFF = sun.util.logging.PlatformLogger.Level.OFF;
241         private sun.util.logging.PlatformLogger.Level FINE = sun.util.logging.PlatformLogger.Level.FINE;
242         private sun.util.logging.PlatformLogger.Level FINER = sun.util.logging.PlatformLogger.Level.FINER;
243         private sun.util.logging.PlatformLogger.Level FINEST = sun.util.logging.PlatformLogger.Level.FINEST;
244         private sun.util.logging.PlatformLogger.Level CONFIG = sun.util.logging.PlatformLogger.Level.CONFIG;
245         private sun.util.logging.PlatformLogger.Level INFO = sun.util.logging.PlatformLogger.Level.INFO;
246         private sun.util.logging.PlatformLogger.Level WARNING = sun.util.logging.PlatformLogger.Level.WARNING;
247         private sun.util.logging.PlatformLogger.Level SEVERE = sun.util.logging.PlatformLogger.Level.SEVERE;
248 
249         public LoggerImpl(String name) {
250             this.name = name;
251         }
252 
253         public void configureLevel(sun.util.logging.PlatformLogger.Level level) {
254             this.level = level;
255         }
256 
257         @Override
258         public String getName() {
259             return name;
260         }
261 
262         @Override
263         public boolean isLoggable(Level level) {
264             return this.level != OFF &amp;&amp; this.level.intValue() &lt;= level.getSeverity();
265         }
266 
267         @Override
268         public void log(Level level, ResourceBundle bundle,
269                         String key, Throwable thrown) {
270             throw new UnsupportedOperationException();
271         }
272 
273         @Override
274         public void log(Level level, ResourceBundle bundle,
275                         String format, Object... params) {
276             throw new UnsupportedOperationException();
277         }
278 
279         void log(PlatformLoggerBridgeTest.LogEvent event) {
280             eventQueue.add(event);
281         }
282 
283         @Override
284         public void log(Level level, Supplier&lt;String&gt; msgSupplier) {
285             throw new UnsupportedOperationException();
286         }
287 
288         @Override
289         public void log(Level level, Supplier&lt;String&gt; msgSupplier,
290                         Throwable thrown) {
291             throw new UnsupportedOperationException();
292         }
293 
294         @Override
295         public void log(sun.util.logging.PlatformLogger.Level level, String msg) {
296             log(LogEvent.of(isLoggable(level), name, null, null,
297                     level, null, msg, null, (Object[]) null));
298         }
299 
300         @Override
301         public void log(sun.util.logging.PlatformLogger.Level level,
302                         Supplier&lt;String&gt; msgSupplier) {
303             log(LogEvent.of(isLoggable(level), name, null, null,
304                     level, null, msgSupplier, null, (Object[]) null));
305         }
306 
307         @Override
308         public void log(sun.util.logging.PlatformLogger.Level level, String msg,
309                         Object... params) {
310             log(LogEvent.of(isLoggable(level), name, null, null,
311                     level, null, msg, null, params));
312         }
313 
314         @Override
315         public void log(sun.util.logging.PlatformLogger.Level level, String msg,
316                         Throwable thrown) {
317             log(LogEvent.of(isLoggable(level), name, null, null,
318                     level, null, msg, thrown, (Object[]) null));
319         }
320 
321         @Override
322         public void log(sun.util.logging.PlatformLogger.Level level, Throwable thrown,
323                         Supplier&lt;String&gt; msgSupplier) {
324             log(LogEvent.of(isLoggable(level), name, null, null,
325                     level, null, msgSupplier, thrown, (Object[]) null));
326         }
327 
328         @Override
329         public void logp(sun.util.logging.PlatformLogger.Level level, String sourceClass,
330                          String sourceMethod, String msg) {
331             log(LogEvent.of(isLoggable(level), name,
332                     sourceClass, sourceMethod,
333                     level, null, msg, null, (Object[]) null));
334         }
335 
336         @Override
337         public void logp(sun.util.logging.PlatformLogger.Level level, String sourceClass,
338                          String sourceMethod, Supplier&lt;String&gt; msgSupplier) {
339             log(LogEvent.of(isLoggable(level), name,
340                     sourceClass, sourceMethod,
341                     level, null, msgSupplier, null, (Object[]) null));
342         }
343 
344         @Override
345         public void logp(sun.util.logging.PlatformLogger.Level level, String sourceClass,
346                          String sourceMethod, String msg, Object... params) {
347             log(LogEvent.of(isLoggable(level), name,
348                     sourceClass, sourceMethod,
349                     level, null, msg, null, params));
350         }
351 
352         @Override
353         public void logp(sun.util.logging.PlatformLogger.Level level, String sourceClass,
354                          String sourceMethod, String msg, Throwable thrown) {
355             log(LogEvent.of(isLoggable(level), name,
356                     sourceClass, sourceMethod,
357                     level, null, msg, thrown, (Object[]) null));
358         }
359 
360         @Override
361         public void logp(sun.util.logging.PlatformLogger.Level level, String sourceClass,
362                          String sourceMethod, Throwable thrown,
363                          Supplier&lt;String&gt; msgSupplier) {
364             log(LogEvent.of(isLoggable(level), name,
365                     sourceClass, sourceMethod,
366                     level, null, msgSupplier, thrown, (Object[]) null));
367         }
368 
369         @Override
370         public void logrb(sun.util.logging.PlatformLogger.Level level, String sourceClass,
371                           String sourceMethod, ResourceBundle bundle, String msg,
372                           Object... params) {
373             log(LogEvent.of(isLoggable(level), name,
374                     sourceClass, sourceMethod,
375                     level, bundle, msg, null, params));
376         }
377 
378         @Override
379         public void logrb(sun.util.logging.PlatformLogger.Level level, ResourceBundle bundle,
380                           String msg, Object... params) {
381             log(LogEvent.of(isLoggable(level), name, null, null,
382                     level, bundle, msg, null, params));
383         }
384 
385         @Override
386         public void logrb(sun.util.logging.PlatformLogger.Level level, String sourceClass,
387                           String sourceMethod, ResourceBundle bundle, String msg,
388                           Throwable thrown) {
389             log(LogEvent.of(isLoggable(level), name,
390                     sourceClass, sourceMethod,
391                     level, bundle, msg, thrown, (Object[]) null));
392         }
393 
394         @Override
395         public void logrb(sun.util.logging.PlatformLogger.Level level, ResourceBundle bundle,
396                           String msg, Throwable thrown) {
397             log(LogEvent.of(isLoggable(level), name, null, null,
398                     level, bundle, msg, thrown, (Object[]) null));
399         }
400 
401         @Override
402         public boolean isLoggable(sun.util.logging.PlatformLogger.Level level) {
403             return this.level != OFF &amp;&amp; level.intValue()
404                     &gt;= this.level.intValue();
405         }
406 
407         @Override
408         public boolean isEnabled() {
409             return this.level != OFF;
410         }
411 
412 
413     }
414 
415     static final sun.util.logging.PlatformLogger.Level[] julLevels = {
416         sun.util.logging.PlatformLogger.Level.ALL,
417         sun.util.logging.PlatformLogger.Level.FINEST,
418         sun.util.logging.PlatformLogger.Level.FINER,
419         sun.util.logging.PlatformLogger.Level.FINE,
420         sun.util.logging.PlatformLogger.Level.CONFIG,
421         sun.util.logging.PlatformLogger.Level.INFO,
422         sun.util.logging.PlatformLogger.Level.WARNING,
423         sun.util.logging.PlatformLogger.Level.SEVERE,
424         sun.util.logging.PlatformLogger.Level.OFF,
425     };
426 
427     public static class MyBundle extends ResourceBundle {
428 
429         final ConcurrentHashMap map = new ConcurrentHashMap();
430 
431         @Override
432         protected Object handleGetObject(String key) {
433             if (key.contains(&quot; (translated)&quot;)) {
434                 throw new RuntimeException(&quot;Unexpected key: &quot; + key);
435             }
436             return map.computeIfAbsent(key, k -&gt; k + &quot; (translated)&quot;);
437         }
438 
439         @Override
440         public Enumeration&lt;String&gt; getKeys() {
441             return Collections.enumeration(map.keySet());
442         }
443 
444     }
445 
446     public static class MyHandler extends Handler {
447 
448         @Override
449         public java.util.logging.Level getLevel() {
450             return java.util.logging.Level.ALL;
451         }
452 
453         @Override
454         public void publish(LogRecord record) {
455             eventQueue.add(LogEvent.of(sequencer.getAndIncrement(),
456                     true, record.getLoggerName(),
457                     record.getSourceClassName(),
458                     record.getSourceMethodName(),
459                     PlatformLogger.Level.valueOf(record.getLevel().getName()),
460                     record.getResourceBundle(), record.getMessage(),
461                     record.getThrown(), record.getParameters()));
462         }
463         @Override
464         public void flush() {
465         }
466         @Override
467         public void close() throws SecurityException {
468         }
469 
470     }
471 
472     public static class MyLoggerBundle extends MyBundle {
473 
474     }
475 
476     static enum TestCases {NOSECURITY, NOPERMISSIONS, WITHPERMISSIONS};
477 
478     static void setSecurityManager() {
479         if (System.getSecurityManager() == null) {
480             Policy.setPolicy(new SimplePolicy(allowControl, allowAccess, allowAll));
481             System.setSecurityManager(new SecurityManager());
482         }
483     }
484 
485     public static void main(String[] args) {
486         if (args.length == 0)
487             args = new String[] {
488                 //&quot;NOSECURITY&quot;,
489                 &quot;NOPERMISSIONS&quot;,
490                 &quot;WITHPERMISSIONS&quot;
491             };
492 
493 
494         Stream.of(args).map(TestCases::valueOf).forEach((testCase) -&gt; {
495             LoggerFinder provider;
496             switch (testCase) {
497                 case NOSECURITY:
498                     System.out.println(&quot;\n*** Without Security Manager\n&quot;);
499                     provider = LoggerFinder.getLoggerFinder();
500                     test(provider, true);
501                     System.out.println(&quot;Tetscase count: &quot; + sequencer.get());
502                     break;
503                 case NOPERMISSIONS:
504                     System.out.println(&quot;\n*** With Security Manager, without permissions\n&quot;);
505                     setSecurityManager();
506                     try {
507                         provider = LoggerFinder.getLoggerFinder();
508                         throw new RuntimeException(&quot;Expected exception not raised&quot;);
509                     } catch (AccessControlException x) {
510                         if (!LOGGERFINDER_PERMISSION.equals(x.getPermission())) {
511                             throw new RuntimeException(&quot;Unexpected permission check&quot;, x);
512                         }
513                         final boolean control = allowControl.get().get();
514                         try {
515                             allowControl.get().set(true);
516                             provider = LoggerFinder.getLoggerFinder();
517                         } finally {
518                             allowControl.get().set(control);
519                         }
520                     }
521                     test(provider, false);
522                     System.out.println(&quot;Tetscase count: &quot; + sequencer.get());
523                     break;
524                 case WITHPERMISSIONS:
525                     System.out.println(&quot;\n*** With Security Manager, with access permission\n&quot;);
526                     setSecurityManager();
527                     final boolean control = allowControl.get().get();
528                     try {
529                         allowControl.get().set(true);
530                         provider = LoggerFinder.getLoggerFinder();
531                     } finally {
532                         allowControl.get().set(control);
533                     }
534                     final boolean access = allowAccess.get().get();
535                     try {
536                         allowAccess.get().set(true);
537                         test(provider, true);
538                     } finally {
539                         allowAccess.get().set(access);
540                     }
541                     break;
542                 default:
543                     throw new RuntimeException(&quot;Unknown test case: &quot; + testCase);
544             }
545         });
546         System.out.println(&quot;\nPASSED: Tested &quot; + sequencer.get() + &quot; cases.&quot;);
547     }
548 
549     public static void test(LoggerFinder provider, boolean hasRequiredPermissions) {
550 
551         final Map&lt;PlatformLogger, String&gt; loggerDescMap = new HashMap&lt;&gt;();
552 
553         PlatformLogger sysLogger1 = null;
554         try {
555             sysLogger1 = PlatformLogger.getLogger(&quot;foo&quot;);
556             loggerDescMap.put(sysLogger1, &quot;PlatformLogger.getLogger(\&quot;foo\&quot;)&quot;);
557             if (!hasRequiredPermissions) {
558                 throw new RuntimeException(&quot;Managed to obtain a system logger without permission&quot;);
559             }
560         } catch (AccessControlException acx) {
561             if (hasRequiredPermissions) {
562                 throw new RuntimeException(&quot;Unexpected security exception: &quot;, acx);
563             }
564             if (!acx.getPermission().equals(SimplePolicy.ACCESS_LOGGING)) {
565                 throw new RuntimeException(&quot;Unexpected permission in exception: &quot; + acx, acx);
566             }
567             final boolean old = allowAccess.get().get();
568             allowAccess.get().set(true);
569             try {
570                 sysLogger1 = PlatformLogger.getLogger(&quot;foo&quot;);
571                 loggerDescMap.put(sysLogger1, &quot;PlatformLogger.getLogger(\&quot;foo\&quot;)&quot;);
572             } finally {
573                 allowAccess.get().set(old);
574             }
575             System.out.println(&quot;Got expected exception for system logger: &quot; + acx);
576         }
577 
578         final LoggerImpl sysSink;
579         boolean old = allowControl.get().get();
580         allowControl.get().set(true);
581         try {
582            sysSink = LoggerImpl.class.cast(
583                         provider.getLogger(&quot;foo&quot;, Thread.class.getModule()));
584         } finally {
585             allowControl.get().set(old);
586         }
587 
588         testLogger(provider, loggerDescMap, &quot;foo&quot;, null, sysLogger1, sysSink);
589     }
590 
591     public static class Foo {
592 
593     }
594 
595     static void verbose(String msg) {
596        if (VERBOSE) {
597            System.out.println(msg);
598        }
599     }
600 
601     static void checkLogEvent(LoggerFinder provider, String desc,
602             LogEvent expected) {
603         LogEvent actual =  eventQueue.poll();
604         if (!expected.equals(actual)) {
605             throw new RuntimeException(&quot;mismatch for &quot; + desc
606                     + &quot;\n\texpected=&quot; + expected
607                     + &quot;\n\t  actual=&quot; + actual);
608         } else {
609             verbose(&quot;Got expected results for &quot;
610                     + desc + &quot;\n\t&quot; + expected);
611         }
612     }
613 
614     static void checkLogEvent(LoggerFinder provider, String desc,
615             LogEvent expected, boolean expectNotNull) {
616         LogEvent actual =  eventQueue.poll();
617         if (actual == null &amp;&amp; !expectNotNull) return;
618         if (actual != null &amp;&amp; !expectNotNull) {
619             throw new RuntimeException(&quot;Unexpected log event found for &quot; + desc
620                 + &quot;\n\tgot: &quot; + actual);
621         }
622         if (!expected.equals(actual)) {
623             throw new RuntimeException(&quot;mismatch for &quot; + desc
624                     + &quot;\n\texpected=&quot; + expected
625                     + &quot;\n\t  actual=&quot; + actual);
626         } else {
627             verbose(&quot;Got expected results for &quot;
628                     + desc + &quot;\n\t&quot; + expected);
629         }
630     }
631 
632     static void setLevel(LoggerImpl sink,
633             sun.util.logging.PlatformLogger.Level loggerLevel) {
634         sink.configureLevel(loggerLevel);
635     }
636 
637     // Calls the methods defined on LogProducer and verify the
638     // parameters received by the underlying LoggerImpl
639     // logger.
640     private static void testLogger(LoggerFinder provider,
641             Map&lt;PlatformLogger, String&gt; loggerDescMap,
642             String name,
643             ResourceBundle loggerBundle,
644             PlatformLogger logger,
645             LoggerImpl sink) {
646 
647         System.out.println(&quot;Testing &quot; + loggerDescMap.get(logger) + &quot; [&quot; + logger +&quot;]&quot;);
648         final sun.util.logging.PlatformLogger.Level OFF = sun.util.logging.PlatformLogger.Level.OFF;
649         final sun.util.logging.PlatformLogger.Level ALL = sun.util.logging.PlatformLogger.Level.OFF;
650 
651         Foo foo = new Foo();
652         String fooMsg = foo.toString();
653         System.out.println(&quot;\tlogger.log(messageLevel, fooMsg)&quot;);
654         System.out.println(&quot;\tlogger.&lt;level&gt;(fooMsg)&quot;);
655         for (sun.util.logging.PlatformLogger.Level loggerLevel : julLevels) {
656             setLevel(sink, loggerLevel);
657             for (sun.util.logging.PlatformLogger.Level messageLevel :julLevels) {
658                 if (messageLevel == ALL || messageLevel == OFF) continue;
659                 LogEvent expected =
660                         LogEvent.of(
661                             sequencer.get(),
662                             loggerLevel != OFF &amp;&amp; messageLevel.intValue() &gt;= loggerLevel.intValue(),
663                             name, messageLevel, loggerBundle,
664                             fooMsg, (Throwable)null, (Object[])null);
665                 String desc2 = &quot;logger.&quot; + messageLevel.toString().toLowerCase()
666                         + &quot;(fooMsg): loggerLevel=&quot;
667                         + loggerLevel+&quot;, messageLevel=&quot;+messageLevel;
668                 if (messageLevel == sun.util.logging.PlatformLogger.Level.FINEST) {
669                     logger.finest(fooMsg);
670                     checkLogEvent(provider, desc2, expected);
671                 } else if (messageLevel == sun.util.logging.PlatformLogger.Level.FINER) {
672                     logger.finer(fooMsg);
673                     checkLogEvent(provider, desc2, expected);
674                 } else if (messageLevel == sun.util.logging.PlatformLogger.Level.FINE) {
675                     logger.fine(fooMsg);
676                     checkLogEvent(provider, desc2, expected);
677                 } else if (messageLevel == sun.util.logging.PlatformLogger.Level.CONFIG) {
678                     logger.config(fooMsg);
679                     checkLogEvent(provider, desc2, expected);
680                 } else if (messageLevel == sun.util.logging.PlatformLogger.Level.INFO) {
681                     logger.info(fooMsg);
682                     checkLogEvent(provider, desc2, expected);
683                 } else if (messageLevel == sun.util.logging.PlatformLogger.Level.WARNING) {
684                     logger.warning(fooMsg);
685                     checkLogEvent(provider, desc2, expected);
686                 } else if (messageLevel == sun.util.logging.PlatformLogger.Level.SEVERE) {
687                     logger.severe(fooMsg);
688                     checkLogEvent(provider, desc2, expected);
689                 }
690             }
691         }
692 
693         String format = &quot;two params [{1} {2}]&quot;;
694         Object arg1 = foo;
695         Object arg2 = fooMsg;
696         System.out.println(&quot;\tlogger.log(messageLevel, format, arg1, arg2)&quot;);
697         for (sun.util.logging.PlatformLogger.Level loggerLevel : julLevels) {
698             setLevel(sink, loggerLevel);
699             for (sun.util.logging.PlatformLogger.Level messageLevel :julLevels) {
700                 if (messageLevel == ALL || messageLevel == OFF) continue;
701                 LogEvent expected =
702                         LogEvent.of(
703                             sequencer.get(),
704                             loggerLevel != OFF &amp;&amp; messageLevel.intValue() &gt;= loggerLevel.intValue(),
705                             name, messageLevel, loggerBundle,
706                             format, (Throwable)null, arg1, arg2);
707                 String desc2 = &quot;logger.&quot; + messageLevel.toString().toLowerCase()
708                         + &quot;(format, foo, fooMsg): loggerLevel=&quot;
709                         + loggerLevel+&quot;, messageLevel=&quot;+messageLevel;
710                 if (messageLevel == sun.util.logging.PlatformLogger.Level.FINEST) {
711                     logger.finest(format, arg1, arg2);
712                     checkLogEvent(provider, desc2, expected);
713                 } else if (messageLevel == sun.util.logging.PlatformLogger.Level.FINER) {
714                     logger.finer(format, arg1, arg2);
715                     checkLogEvent(provider, desc2, expected);
716                 } else if (messageLevel == sun.util.logging.PlatformLogger.Level.FINE) {
717                     logger.fine(format, arg1, arg2);
718                     checkLogEvent(provider, desc2, expected);
719                 } else if (messageLevel == sun.util.logging.PlatformLogger.Level.CONFIG) {
720                     logger.config(format, arg1, arg2);
721                     checkLogEvent(provider, desc2, expected);
722                 } else if (messageLevel == sun.util.logging.PlatformLogger.Level.INFO) {
723                     logger.info(format, arg1, arg2);
724                     checkLogEvent(provider, desc2, expected);
725                 } else if (messageLevel == sun.util.logging.PlatformLogger.Level.WARNING) {
726                     logger.warning(format, arg1, arg2);
727                     checkLogEvent(provider, desc2, expected);
728                 } else if (messageLevel == sun.util.logging.PlatformLogger.Level.SEVERE) {
729                     logger.severe(format, arg1, arg2);
730                     checkLogEvent(provider, desc2, expected);
731                 }
732             }
733         }
734 
735         Throwable thrown = new Exception(&quot;OK: log me!&quot;);
736         System.out.println(&quot;\tlogger.log(messageLevel, fooMsg, thrown)&quot;);
737         for (sun.util.logging.PlatformLogger.Level loggerLevel : julLevels) {
738             setLevel(sink, loggerLevel);
739             for (sun.util.logging.PlatformLogger.Level messageLevel :julLevels) {
740                 if (messageLevel == ALL || messageLevel == OFF) continue;
741                 LogEvent expected =
742                         LogEvent.of(
743                             sequencer.get(),
744                             loggerLevel != OFF &amp;&amp; messageLevel.intValue() &gt;= loggerLevel.intValue(),
745                             name, messageLevel, loggerBundle,
746                             fooMsg, thrown, (Object[])null);
747                 String desc2 = &quot;logger.&quot; + messageLevel.toString().toLowerCase()
748                         + &quot;(fooMsg, thrown): loggerLevel=&quot;
749                         + loggerLevel+&quot;, messageLevel=&quot;+messageLevel;
750                 if (messageLevel == sun.util.logging.PlatformLogger.Level.FINEST) {
751                     logger.finest(fooMsg, thrown);
752                     checkLogEvent(provider, desc2, expected);
753                 } else if (messageLevel == sun.util.logging.PlatformLogger.Level.FINER) {
754                     logger.finer(fooMsg, thrown);
755                     checkLogEvent(provider, desc2, expected);
756                 } else if (messageLevel == sun.util.logging.PlatformLogger.Level.FINE) {
757                     logger.fine(fooMsg, thrown);
758                     checkLogEvent(provider, desc2, expected);
759                 } else if (messageLevel == sun.util.logging.PlatformLogger.Level.CONFIG) {
760                     logger.config(fooMsg, thrown);
761                     checkLogEvent(provider, desc2, expected);
762                 } else if (messageLevel == sun.util.logging.PlatformLogger.Level.INFO) {
763                     logger.info(fooMsg, thrown);
764                     checkLogEvent(provider, desc2, expected);
765                 } else if (messageLevel == sun.util.logging.PlatformLogger.Level.WARNING) {
766                     logger.warning(fooMsg, thrown);
767                     checkLogEvent(provider, desc2, expected);
768                 } else if (messageLevel == sun.util.logging.PlatformLogger.Level.SEVERE) {
769                     logger.severe(fooMsg, thrown);
770                     checkLogEvent(provider, desc2, expected);
771                 }
772             }
773         }
774     }
775 
776     final static class PermissionsBuilder {
777         final Permissions perms;
778         public PermissionsBuilder() {
779             this(new Permissions());
780         }
781         public PermissionsBuilder(Permissions perms) {
782             this.perms = perms;
783         }
784         public PermissionsBuilder add(Permission p) {
785             perms.add(p);
786             return this;
787         }
788         public PermissionsBuilder addAll(PermissionCollection col) {
789             if (col != null) {
790                 for (Enumeration&lt;Permission&gt; e = col.elements(); e.hasMoreElements(); ) {
791                     perms.add(e.nextElement());
792                 }
793             }
794             return this;
795         }
796         public Permissions toPermissions() {
797             final PermissionsBuilder builder = new PermissionsBuilder();
798             builder.addAll(perms);
799             return builder.perms;
800         }
801     }
802 
803     public static class SimplePolicy extends Policy {
804         final static RuntimePermission CONTROL = LOGGERFINDER_PERMISSION;
805         final static RuntimePermission ACCESS_LOGGER = new RuntimePermission(&quot;accessClassInPackage.jdk.internal.logger&quot;);
806         final static RuntimePermission ACCESS_LOGGING = new RuntimePermission(&quot;accessClassInPackage.sun.util.logging&quot;);
807 
<a name="2" id="anc2"></a><span class="line-added">808         static final Policy DEFAULT_POLICY = Policy.getPolicy();</span>
<span class="line-added">809 </span>
810         final Permissions permissions;
811         final Permissions allPermissions;
812         final ThreadLocal&lt;AtomicBoolean&gt; allowControl;
813         final ThreadLocal&lt;AtomicBoolean&gt; allowAccess;
814         final ThreadLocal&lt;AtomicBoolean&gt; allowAll;
815         public SimplePolicy(ThreadLocal&lt;AtomicBoolean&gt; allowControl,
816                 ThreadLocal&lt;AtomicBoolean&gt; allowAccess,
817                 ThreadLocal&lt;AtomicBoolean&gt; allowAll) {
818             this.allowControl = allowControl;
819             this.allowAccess = allowAccess;
820             this.allowAll = allowAll;
821             permissions = new Permissions();
822             allPermissions = new PermissionsBuilder()
823                     .add(new java.security.AllPermission())
824                     .toPermissions();
825         }
826 
827         Permissions getPermissions() {
828             if (allowControl.get().get() || allowAccess.get().get() || allowAll.get().get()) {
829                 PermissionsBuilder builder =  new PermissionsBuilder()
830                         .addAll(permissions);
831                 if (allowControl.get().get()) {
832                     builder.add(CONTROL);
833                 }
834                 if (allowAccess.get().get()) {
835                     builder.add(ACCESS_LOGGER);
836                     builder.add(ACCESS_LOGGING);
837                 }
838                 if (allowAll.get().get()) {
839                     builder.addAll(allPermissions);
840                 }
841                 return builder.toPermissions();
842             }
843             return permissions;
844         }
845 
846         @Override
847         public boolean implies(ProtectionDomain domain, Permission permission) {
<a name="3" id="anc3"></a><span class="line-modified">848             return getPermissions().implies(permission) || DEFAULT_POLICY.implies(domain, permission);</span>
849         }
850 
851         @Override
852         public PermissionCollection getPermissions(CodeSource codesource) {
853             return new PermissionsBuilder().addAll(getPermissions()).toPermissions();
854         }
855 
856         @Override
857         public PermissionCollection getPermissions(ProtectionDomain domain) {
858             return new PermissionsBuilder().addAll(getPermissions()).toPermissions();
859         }
860     }
861 }
<a name="4" id="anc4"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="4" type="hidden" />
</body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff test/jdk/java/util/Locale/LocaleProviders.java</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
<body>
<center><a href="Bug8179071.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="LocaleProvidersRun.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>test/jdk/java/util/Locale/LocaleProviders.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2012, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 import java.text.*;
 24 import java.text.spi.*;
 25 import java.util.*;
 26 import java.util.spi.*;

 27 import sun.util.locale.provider.LocaleProviderAdapter;
 28 
 29 public class LocaleProviders {
 30 



 31     public static void main(String[] args) {
 32         String methodName = args[0];
 33 
 34         switch (methodName) {
 35             case &quot;getPlatformLocale&quot;:
 36                 if (args[1].equals(&quot;format&quot;)) {
 37                     getPlatformLocale(Locale.Category.FORMAT);
 38                 } else {
 39                     getPlatformLocale(Locale.Category.DISPLAY);
 40                 }
 41                 break;
 42 
 43             case &quot;adapterTest&quot;:
 44                 adapterTest(args[1], args[2], (args.length &gt;= 4 ? args[3] : &quot;&quot;));
 45                 break;
 46 
 47             case &quot;bug7198834Test&quot;:
 48                 bug7198834Test();
 49                 break;
 50 
</pre>
<hr />
<pre>
 59             case &quot;bug8010666Test&quot;:
 60                 bug8010666Test();
 61                 break;
 62 
 63             case &quot;bug8013086Test&quot;:
 64                 bug8013086Test(args[1], args[2]);
 65                 break;
 66 
 67             case &quot;bug8013903Test&quot;:
 68                 bug8013903Test();
 69                 break;
 70 
 71             case &quot;bug8027289Test&quot;:
 72                 bug8027289Test(args[1]);
 73                 break;
 74 
 75             case &quot;bug8220227Test&quot;:
 76                 bug8220227Test();
 77                 break;
 78 












 79             default:
 80                 throw new RuntimeException(&quot;Test method &#39;&quot;+methodName+&quot;&#39; not found.&quot;);
 81         }
 82     }
 83 
 84     static void getPlatformLocale(Locale.Category cat) {
 85         Locale defloc = Locale.getDefault(cat);
 86         System.out.printf(&quot;%s,%s\n&quot;, defloc.getLanguage(), defloc.getCountry());
 87     }
 88 
 89     static void adapterTest(String expected, String lang, String ctry) {
 90         Locale testLocale = new Locale(lang, ctry);
 91         LocaleProviderAdapter ldaExpected =
 92             LocaleProviderAdapter.forType(LocaleProviderAdapter.Type.valueOf(expected));
 93         if (!ldaExpected.getDateFormatProvider().isSupportedLocale(testLocale)) {
 94             System.out.println(&quot;test locale: &quot;+testLocale+&quot; is not supported by the expected provider: &quot;+ldaExpected+&quot;. Ignoring the test.&quot;);
 95             return;
 96         }
 97         String preference = System.getProperty(&quot;java.locale.providers&quot;, &quot;&quot;);
 98         LocaleProviderAdapter lda = LocaleProviderAdapter.getAdapter(DateFormatProvider.class, testLocale);
 99         LocaleProviderAdapter.Type type = lda.getAdapterType();
100         System.out.printf(&quot;testLocale: %s, got: %s, expected: %s\n&quot;, testLocale, type, expected);
101         if (!type.toString().equals(expected)) {
102             throw new RuntimeException(&quot;Returned locale data adapter is not correct.&quot;);
103         }
104     }
105 
106     static void bug7198834Test() {
107         LocaleProviderAdapter lda = LocaleProviderAdapter.getAdapter(DateFormatProvider.class, Locale.US);
108         LocaleProviderAdapter.Type type = lda.getAdapterType();
<span class="line-modified">109         if (type == LocaleProviderAdapter.Type.HOST &amp;&amp; System.getProperty(&quot;os.name&quot;).startsWith(&quot;Windows&quot;)) {</span>
110             DateFormat df = DateFormat.getDateInstance(DateFormat.FULL, Locale.US);
111             String date = df.format(new Date());
112             if (date.charAt(date.length()-1) == &#39; &#39;) {
113                 throw new RuntimeException(&quot;Windows Host Locale Provider returns a trailing space.&quot;);
114             }
115         } else {
116             System.out.println(&quot;Windows HOST locale adapter not found. Ignoring this test.&quot;);
117         }
118     }
119 
120     static void tzNameTest(String id) {
121         TimeZone tz = TimeZone.getTimeZone(id);
122         String tzName = tz.getDisplayName(false, TimeZone.SHORT, Locale.US);
123         if (tzName.startsWith(&quot;GMT&quot;)) {
124             throw new RuntimeException(&quot;JRE&#39;s localized time zone name for &quot;+id+&quot; could not be retrieved. Returned name was: &quot;+tzName);
125         }
126     }
127 
128     static void bug8001440Test() {
129         Locale locale = Locale.forLanguageTag(&quot;th-TH-u-nu-hoge&quot;);
130         NumberFormat nf = NumberFormat.getInstance(locale);
131         String nu = nf.format(1234560);
132     }
133 
134     // This test assumes Windows localized language/country display names.
135     static void bug8010666Test() {
<span class="line-modified">136         if (System.getProperty(&quot;os.name&quot;).startsWith(&quot;Windows&quot;)) {</span>
137             NumberFormat nf = NumberFormat.getInstance(Locale.US);
138             try {
139                 double ver = nf.parse(System.getProperty(&quot;os.version&quot;))
140                                .doubleValue();
141                 System.out.printf(&quot;Windows version: %.1f\n&quot;, ver);
142                 if (ver &gt;= 6.0) {
143                     LocaleProviderAdapter lda =
144                         LocaleProviderAdapter.getAdapter(
145                             LocaleNameProvider.class, Locale.ENGLISH);
146                     LocaleProviderAdapter.Type type = lda.getAdapterType();
147                     if (type == LocaleProviderAdapter.Type.HOST) {
148                         LocaleNameProvider lnp = lda.getLocaleNameProvider();
149                         Locale mkmk = Locale.forLanguageTag(&quot;mk-MK&quot;);
150                         String result = mkmk.getDisplayLanguage(Locale.ENGLISH);
151                         String hostResult =
152                             lnp.getDisplayLanguage(mkmk.getLanguage(),
153                                                    Locale.ENGLISH);
154                         System.out.printf(&quot;  Display language name for&quot; +
155                             &quot; (mk_MK): result(HOST): \&quot;%s\&quot;, returned: \&quot;%s\&quot;\n&quot;,
156                             hostResult, result);
</pre>
<hr />
<pre>
198                             &quot; LocaleProviderAdapter was not selected for&quot; +
199                             &quot; English locale.&quot;);
200                     }
201                 }
202             } catch (ParseException pe) {
203                 throw new RuntimeException(&quot;Parsing Windows version failed: &quot;+pe.toString());
204             }
205         }
206     }
207 
208     static void bug8013086Test(String lang, String ctry) {
209         try {
210             // Throws a NullPointerException if the test fails.
211             System.out.println(new SimpleDateFormat(&quot;z&quot;, new Locale(lang, ctry)).parse(&quot;UTC&quot;));
212         } catch (ParseException pe) {
213             // ParseException is fine in this test, as it&#39;s not &quot;UTC&quot;
214 }
215     }
216 
217     static void bug8013903Test() {
<span class="line-modified">218         if (System.getProperty(&quot;os.name&quot;).startsWith(&quot;Windows&quot;)) {</span>
219             Date sampleDate = new Date(0x10000000000L);
220             String hostResult = &quot;\u5e73\u6210 16.11.03 (Wed) AM 11:53:47&quot;;
221             String jreResult = &quot;\u5e73\u6210 16.11.03 (\u6c34) \u5348\u524d 11:53:47&quot;;
222             Locale l = new Locale(&quot;ja&quot;, &quot;JP&quot;, &quot;JP&quot;);
223             SimpleDateFormat sdf = new SimpleDateFormat(&quot;GGGG yyyy.MMM.dd &#39;(&#39;E&#39;)&#39; a hh:mm:ss&quot;, l);
224             sdf.setTimeZone(TimeZone.getTimeZone(&quot;America/Los_Angeles&quot;));
225             String result = sdf.format(sampleDate);
226             System.out.println(result);
227             if (LocaleProviderAdapter.getAdapterPreference()
228                 .contains(LocaleProviderAdapter.Type.JRE)) {
229                 if (!jreResult.equals(result)) {
230                     throw new RuntimeException(&quot;Format failed. result: \&quot;&quot; +
231                         result + &quot;\&quot;, expected: \&quot;&quot; + jreResult);
232                 }
233             } else {
234                 // Windows display names. Subject to change if Windows changes its format.
235                 if (!hostResult.equals(result)) {
236                     throw new RuntimeException(&quot;Format failed. result: \&quot;&quot; +
237                         result + &quot;\&quot;, expected: \&quot;&quot; + hostResult);
238                 }
239             }
240         }
241     }
242 
243     static void bug8027289Test(String expectedCodePoint) {
<span class="line-modified">244         if (System.getProperty(&quot;os.name&quot;).startsWith(&quot;Windows&quot;)) {</span>
245             char[] expectedSymbol = Character.toChars(Integer.valueOf(expectedCodePoint, 16));
246             NumberFormat nf = NumberFormat.getCurrencyInstance(Locale.CHINA);
247             char formatted = nf.format(7000).charAt(0);
248             System.out.println(&quot;returned: &quot; + formatted + &quot;, expected: &quot; + expectedSymbol[0]);
249             if (formatted != expectedSymbol[0]) {
250                 throw new RuntimeException(
251                         &quot;Unexpected Chinese currency symbol. returned: &quot;
252                                 + formatted + &quot;, expected: &quot; + expectedSymbol[0]);
253             }
254         }
255     }
256 
257     static void bug8220227Test() {
<span class="line-modified">258         if (System.getProperty(&quot;os.name&quot;).startsWith(&quot;Windows&quot;)) {</span>
259             Locale l = new Locale(&quot;xx&quot;,&quot;XX&quot;);
260             String country = l.getDisplayCountry();
261             if (country.endsWith(&quot;(XX)&quot;)) {
262                 throw new RuntimeException(
263                         &quot;Unexpected Region name: &quot; + country);
264             }
265         }
266     }






























































































267 }
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2012, 2020, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 import java.text.*;
 24 import java.text.spi.*;
 25 import java.util.*;
 26 import java.util.spi.*;
<span class="line-added"> 27 import java.util.stream.IntStream;</span>
 28 import sun.util.locale.provider.LocaleProviderAdapter;
 29 
 30 public class LocaleProviders {
 31 
<span class="line-added"> 32     private static final boolean IS_WINDOWS = System.getProperty(&quot;os.name&quot;).startsWith(&quot;Windows&quot;);</span>
<span class="line-added"> 33     private static final boolean IS_MAC = System.getProperty(&quot;os.name&quot;).startsWith(&quot;Mac&quot;);</span>
<span class="line-added"> 34 </span>
 35     public static void main(String[] args) {
 36         String methodName = args[0];
 37 
 38         switch (methodName) {
 39             case &quot;getPlatformLocale&quot;:
 40                 if (args[1].equals(&quot;format&quot;)) {
 41                     getPlatformLocale(Locale.Category.FORMAT);
 42                 } else {
 43                     getPlatformLocale(Locale.Category.DISPLAY);
 44                 }
 45                 break;
 46 
 47             case &quot;adapterTest&quot;:
 48                 adapterTest(args[1], args[2], (args.length &gt;= 4 ? args[3] : &quot;&quot;));
 49                 break;
 50 
 51             case &quot;bug7198834Test&quot;:
 52                 bug7198834Test();
 53                 break;
 54 
</pre>
<hr />
<pre>
 63             case &quot;bug8010666Test&quot;:
 64                 bug8010666Test();
 65                 break;
 66 
 67             case &quot;bug8013086Test&quot;:
 68                 bug8013086Test(args[1], args[2]);
 69                 break;
 70 
 71             case &quot;bug8013903Test&quot;:
 72                 bug8013903Test();
 73                 break;
 74 
 75             case &quot;bug8027289Test&quot;:
 76                 bug8027289Test(args[1]);
 77                 break;
 78 
 79             case &quot;bug8220227Test&quot;:
 80                 bug8220227Test();
 81                 break;
 82 
<span class="line-added"> 83             case &quot;bug8228465Test&quot;:</span>
<span class="line-added"> 84                 bug8228465Test();</span>
<span class="line-added"> 85                 break;</span>
<span class="line-added"> 86 </span>
<span class="line-added"> 87             case &quot;bug8232871Test&quot;:</span>
<span class="line-added"> 88                 bug8232871Test();</span>
<span class="line-added"> 89                 break;</span>
<span class="line-added"> 90 </span>
<span class="line-added"> 91             case &quot;bug8232860Test&quot;:</span>
<span class="line-added"> 92                 bug8232860Test();</span>
<span class="line-added"> 93                 break;</span>
<span class="line-added"> 94 </span>
 95             default:
 96                 throw new RuntimeException(&quot;Test method &#39;&quot;+methodName+&quot;&#39; not found.&quot;);
 97         }
 98     }
 99 
100     static void getPlatformLocale(Locale.Category cat) {
101         Locale defloc = Locale.getDefault(cat);
102         System.out.printf(&quot;%s,%s\n&quot;, defloc.getLanguage(), defloc.getCountry());
103     }
104 
105     static void adapterTest(String expected, String lang, String ctry) {
106         Locale testLocale = new Locale(lang, ctry);
107         LocaleProviderAdapter ldaExpected =
108             LocaleProviderAdapter.forType(LocaleProviderAdapter.Type.valueOf(expected));
109         if (!ldaExpected.getDateFormatProvider().isSupportedLocale(testLocale)) {
110             System.out.println(&quot;test locale: &quot;+testLocale+&quot; is not supported by the expected provider: &quot;+ldaExpected+&quot;. Ignoring the test.&quot;);
111             return;
112         }
113         String preference = System.getProperty(&quot;java.locale.providers&quot;, &quot;&quot;);
114         LocaleProviderAdapter lda = LocaleProviderAdapter.getAdapter(DateFormatProvider.class, testLocale);
115         LocaleProviderAdapter.Type type = lda.getAdapterType();
116         System.out.printf(&quot;testLocale: %s, got: %s, expected: %s\n&quot;, testLocale, type, expected);
117         if (!type.toString().equals(expected)) {
118             throw new RuntimeException(&quot;Returned locale data adapter is not correct.&quot;);
119         }
120     }
121 
122     static void bug7198834Test() {
123         LocaleProviderAdapter lda = LocaleProviderAdapter.getAdapter(DateFormatProvider.class, Locale.US);
124         LocaleProviderAdapter.Type type = lda.getAdapterType();
<span class="line-modified">125         if (type == LocaleProviderAdapter.Type.HOST &amp;&amp; IS_WINDOWS) {</span>
126             DateFormat df = DateFormat.getDateInstance(DateFormat.FULL, Locale.US);
127             String date = df.format(new Date());
128             if (date.charAt(date.length()-1) == &#39; &#39;) {
129                 throw new RuntimeException(&quot;Windows Host Locale Provider returns a trailing space.&quot;);
130             }
131         } else {
132             System.out.println(&quot;Windows HOST locale adapter not found. Ignoring this test.&quot;);
133         }
134     }
135 
136     static void tzNameTest(String id) {
137         TimeZone tz = TimeZone.getTimeZone(id);
138         String tzName = tz.getDisplayName(false, TimeZone.SHORT, Locale.US);
139         if (tzName.startsWith(&quot;GMT&quot;)) {
140             throw new RuntimeException(&quot;JRE&#39;s localized time zone name for &quot;+id+&quot; could not be retrieved. Returned name was: &quot;+tzName);
141         }
142     }
143 
144     static void bug8001440Test() {
145         Locale locale = Locale.forLanguageTag(&quot;th-TH-u-nu-hoge&quot;);
146         NumberFormat nf = NumberFormat.getInstance(locale);
147         String nu = nf.format(1234560);
148     }
149 
150     // This test assumes Windows localized language/country display names.
151     static void bug8010666Test() {
<span class="line-modified">152         if (IS_WINDOWS) {</span>
153             NumberFormat nf = NumberFormat.getInstance(Locale.US);
154             try {
155                 double ver = nf.parse(System.getProperty(&quot;os.version&quot;))
156                                .doubleValue();
157                 System.out.printf(&quot;Windows version: %.1f\n&quot;, ver);
158                 if (ver &gt;= 6.0) {
159                     LocaleProviderAdapter lda =
160                         LocaleProviderAdapter.getAdapter(
161                             LocaleNameProvider.class, Locale.ENGLISH);
162                     LocaleProviderAdapter.Type type = lda.getAdapterType();
163                     if (type == LocaleProviderAdapter.Type.HOST) {
164                         LocaleNameProvider lnp = lda.getLocaleNameProvider();
165                         Locale mkmk = Locale.forLanguageTag(&quot;mk-MK&quot;);
166                         String result = mkmk.getDisplayLanguage(Locale.ENGLISH);
167                         String hostResult =
168                             lnp.getDisplayLanguage(mkmk.getLanguage(),
169                                                    Locale.ENGLISH);
170                         System.out.printf(&quot;  Display language name for&quot; +
171                             &quot; (mk_MK): result(HOST): \&quot;%s\&quot;, returned: \&quot;%s\&quot;\n&quot;,
172                             hostResult, result);
</pre>
<hr />
<pre>
214                             &quot; LocaleProviderAdapter was not selected for&quot; +
215                             &quot; English locale.&quot;);
216                     }
217                 }
218             } catch (ParseException pe) {
219                 throw new RuntimeException(&quot;Parsing Windows version failed: &quot;+pe.toString());
220             }
221         }
222     }
223 
224     static void bug8013086Test(String lang, String ctry) {
225         try {
226             // Throws a NullPointerException if the test fails.
227             System.out.println(new SimpleDateFormat(&quot;z&quot;, new Locale(lang, ctry)).parse(&quot;UTC&quot;));
228         } catch (ParseException pe) {
229             // ParseException is fine in this test, as it&#39;s not &quot;UTC&quot;
230 }
231     }
232 
233     static void bug8013903Test() {
<span class="line-modified">234         if (IS_WINDOWS) {</span>
235             Date sampleDate = new Date(0x10000000000L);
236             String hostResult = &quot;\u5e73\u6210 16.11.03 (Wed) AM 11:53:47&quot;;
237             String jreResult = &quot;\u5e73\u6210 16.11.03 (\u6c34) \u5348\u524d 11:53:47&quot;;
238             Locale l = new Locale(&quot;ja&quot;, &quot;JP&quot;, &quot;JP&quot;);
239             SimpleDateFormat sdf = new SimpleDateFormat(&quot;GGGG yyyy.MMM.dd &#39;(&#39;E&#39;)&#39; a hh:mm:ss&quot;, l);
240             sdf.setTimeZone(TimeZone.getTimeZone(&quot;America/Los_Angeles&quot;));
241             String result = sdf.format(sampleDate);
242             System.out.println(result);
243             if (LocaleProviderAdapter.getAdapterPreference()
244                 .contains(LocaleProviderAdapter.Type.JRE)) {
245                 if (!jreResult.equals(result)) {
246                     throw new RuntimeException(&quot;Format failed. result: \&quot;&quot; +
247                         result + &quot;\&quot;, expected: \&quot;&quot; + jreResult);
248                 }
249             } else {
250                 // Windows display names. Subject to change if Windows changes its format.
251                 if (!hostResult.equals(result)) {
252                     throw new RuntimeException(&quot;Format failed. result: \&quot;&quot; +
253                         result + &quot;\&quot;, expected: \&quot;&quot; + hostResult);
254                 }
255             }
256         }
257     }
258 
259     static void bug8027289Test(String expectedCodePoint) {
<span class="line-modified">260         if (IS_WINDOWS) {</span>
261             char[] expectedSymbol = Character.toChars(Integer.valueOf(expectedCodePoint, 16));
262             NumberFormat nf = NumberFormat.getCurrencyInstance(Locale.CHINA);
263             char formatted = nf.format(7000).charAt(0);
264             System.out.println(&quot;returned: &quot; + formatted + &quot;, expected: &quot; + expectedSymbol[0]);
265             if (formatted != expectedSymbol[0]) {
266                 throw new RuntimeException(
267                         &quot;Unexpected Chinese currency symbol. returned: &quot;
268                                 + formatted + &quot;, expected: &quot; + expectedSymbol[0]);
269             }
270         }
271     }
272 
273     static void bug8220227Test() {
<span class="line-modified">274         if (IS_WINDOWS) {</span>
275             Locale l = new Locale(&quot;xx&quot;,&quot;XX&quot;);
276             String country = l.getDisplayCountry();
277             if (country.endsWith(&quot;(XX)&quot;)) {
278                 throw new RuntimeException(
279                         &quot;Unexpected Region name: &quot; + country);
280             }
281         }
282     }
<span class="line-added">283 </span>
<span class="line-added">284     static void bug8228465Test() {</span>
<span class="line-added">285         LocaleProviderAdapter lda = LocaleProviderAdapter.getAdapter(CalendarNameProvider.class, Locale.US);</span>
<span class="line-added">286         LocaleProviderAdapter.Type type = lda.getAdapterType();</span>
<span class="line-added">287         if (type == LocaleProviderAdapter.Type.HOST &amp;&amp; IS_WINDOWS) {</span>
<span class="line-added">288             var names =  new GregorianCalendar()</span>
<span class="line-added">289                 .getDisplayNames(Calendar.ERA, Calendar.SHORT_FORMAT, Locale.US);</span>
<span class="line-added">290             if (!names.keySet().contains(&quot;AD&quot;) ||</span>
<span class="line-added">291                 names.get(&quot;AD&quot;).intValue() != 1) {</span>
<span class="line-added">292                     throw new RuntimeException(</span>
<span class="line-added">293                             &quot;Short Era name for &#39;AD&#39; is missing or incorrect&quot;);</span>
<span class="line-added">294             } else {</span>
<span class="line-added">295                 System.out.println(&quot;bug8228465Test succeeded.&quot;);</span>
<span class="line-added">296             }</span>
<span class="line-added">297         }</span>
<span class="line-added">298     }</span>
<span class="line-added">299 </span>
<span class="line-added">300     static void bug8232871Test() {</span>
<span class="line-added">301         LocaleProviderAdapter lda = LocaleProviderAdapter.getAdapter(CalendarNameProvider.class, Locale.US);</span>
<span class="line-added">302         LocaleProviderAdapter.Type type = lda.getAdapterType();</span>
<span class="line-added">303         var lang = Locale.getDefault().getLanguage();</span>
<span class="line-added">304         var cal = Calendar.getInstance();</span>
<span class="line-added">305         var calType = cal.getCalendarType();</span>
<span class="line-added">306         var expected = &quot;\u4ee4\u548c1\u5e745\u67081\u65e5 \u6c34\u66dc\u65e5 \u5348\u524d0:00:00 \u30a2\u30e1\u30ea\u30ab\u592a\u5e73\u6d0b\u590f\u6642\u9593&quot;;</span>
<span class="line-added">307 </span>
<span class="line-added">308         if (type == LocaleProviderAdapter.Type.HOST &amp;&amp;</span>
<span class="line-added">309             IS_MAC &amp;&amp;</span>
<span class="line-added">310             lang.equals(&quot;ja&quot;) &amp;&amp;</span>
<span class="line-added">311             calType.equals(&quot;japanese&quot;)) {</span>
<span class="line-added">312             cal.set(1, 4, 1, 0, 0, 0);</span>
<span class="line-added">313             cal.setTimeZone(TimeZone.getTimeZone(&quot;America/Los_Angeles&quot;));</span>
<span class="line-added">314             DateFormat df = DateFormat.getDateTimeInstance(DateFormat.FULL, DateFormat.FULL,</span>
<span class="line-added">315                             Locale.JAPAN);</span>
<span class="line-added">316             df.setCalendar(cal);</span>
<span class="line-added">317             var result = df.format(cal.getTime());</span>
<span class="line-added">318             if (result.equals(expected)) {</span>
<span class="line-added">319                 System.out.println(&quot;bug8232871Test succeeded.&quot;);</span>
<span class="line-added">320             } else {</span>
<span class="line-added">321                 throw new RuntimeException(</span>
<span class="line-added">322                             &quot;Japanese calendar names mismatch. result: &quot; +</span>
<span class="line-added">323                             result +</span>
<span class="line-added">324                             &quot;, expected: &quot; +</span>
<span class="line-added">325                             expected);</span>
<span class="line-added">326             }</span>
<span class="line-added">327         } else {</span>
<span class="line-added">328             System.out.println(&quot;Test ignored. Either :-\n&quot; +</span>
<span class="line-added">329                 &quot;OS is not macOS, or\n&quot; +</span>
<span class="line-added">330                 &quot;provider is not HOST: &quot; + type + &quot;, or\n&quot; +</span>
<span class="line-added">331                 &quot;Language is not Japanese: &quot; + lang + &quot;, or\n&quot; +</span>
<span class="line-added">332                 &quot;native calendar is not JapaneseCalendar: &quot; + calType);</span>
<span class="line-added">333         }</span>
<span class="line-added">334     }</span>
<span class="line-added">335 </span>
<span class="line-added">336     static void bug8232860Test() {</span>
<span class="line-added">337         var inputList = List.of(123, 123.4);</span>
<span class="line-added">338         var nfExpectedList = List.of(&quot;123&quot;, &quot;123.4&quot;);</span>
<span class="line-added">339         var ifExpectedList = List.of(&quot;123&quot;, &quot;123&quot;);</span>
<span class="line-added">340 </span>
<span class="line-added">341         var defLoc = Locale.getDefault(Locale.Category.FORMAT);</span>
<span class="line-added">342         var type = LocaleProviderAdapter.getAdapter(CalendarNameProvider.class, Locale.US)</span>
<span class="line-added">343                                         .getAdapterType();</span>
<span class="line-added">344         if (defLoc.equals(Locale.US) &amp;&amp;</span>
<span class="line-added">345             type == LocaleProviderAdapter.Type.HOST &amp;&amp;</span>
<span class="line-added">346             (IS_WINDOWS || IS_MAC)) {</span>
<span class="line-added">347             final var numf = NumberFormat.getNumberInstance(Locale.US);</span>
<span class="line-added">348             final var intf = NumberFormat.getIntegerInstance(Locale.US);</span>
<span class="line-added">349 </span>
<span class="line-added">350             IntStream.range(0, inputList.size())</span>
<span class="line-added">351                 .forEach(i -&gt; {</span>
<span class="line-added">352                     var input = inputList.get(i);</span>
<span class="line-added">353                     var nfExpected = nfExpectedList.get(i);</span>
<span class="line-added">354                     var result = numf.format(input);</span>
<span class="line-added">355                     if (!result.equals(nfExpected)) {</span>
<span class="line-added">356                         throw new RuntimeException(&quot;Incorrect number format. &quot; +</span>
<span class="line-added">357                             &quot;input: &quot; + input + &quot;, expected: &quot; +</span>
<span class="line-added">358                             nfExpected + &quot;, result: &quot; + result);</span>
<span class="line-added">359                     }</span>
<span class="line-added">360 </span>
<span class="line-added">361                     var ifExpected = ifExpectedList.get(i);</span>
<span class="line-added">362                     result = intf.format(input);</span>
<span class="line-added">363                     if (!result.equals(ifExpected)) {</span>
<span class="line-added">364                         throw new RuntimeException(&quot;Incorrect integer format. &quot; +</span>
<span class="line-added">365                             &quot;input: &quot; + input + &quot;, expected: &quot; +</span>
<span class="line-added">366                             ifExpected + &quot;, result: &quot; + result);</span>
<span class="line-added">367                     }</span>
<span class="line-added">368                 });</span>
<span class="line-added">369             System.out.println(&quot;bug8232860Test succeeded.&quot;);</span>
<span class="line-added">370         } else {</span>
<span class="line-added">371             System.out.println(&quot;Test ignored. Either :-\n&quot; +</span>
<span class="line-added">372                 &quot;Default format locale is not Locale.US: &quot; + defLoc + &quot;, or\n&quot; +</span>
<span class="line-added">373                 &quot;OS is neither macOS/Windows, or\n&quot; +</span>
<span class="line-added">374                 &quot;provider is not HOST: &quot; + type);</span>
<span class="line-added">375         }</span>
<span class="line-added">376     }</span>
377 }
</pre>
</td>
</tr>
</table>
<center><a href="Bug8179071.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="LocaleProvidersRun.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
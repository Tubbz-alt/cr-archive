<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames test/jdk/java/util/logging/LogManager/Configuration/updateConfiguration/HandlersOnComplexResetUpdate.java</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (c) 2015, 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 import java.io.ByteArrayInputStream;
 24 import java.io.ByteArrayOutputStream;
 25 import java.io.FilePermission;
 26 import java.io.IOException;
 27 import java.lang.ref.Reference;
 28 import java.lang.ref.ReferenceQueue;
 29 import java.lang.ref.WeakReference;
 30 import java.nio.file.Files;
 31 import java.nio.file.Paths;
 32 import java.security.CodeSource;
 33 import java.security.Permission;
 34 import java.security.PermissionCollection;
 35 import java.security.Permissions;
 36 import java.security.Policy;
 37 import java.security.ProtectionDomain;
 38 import java.util.Arrays;
 39 import java.util.Collections;
 40 import java.util.Enumeration;
 41 import java.util.List;
 42 import java.util.Properties;
 43 import java.util.UUID;
 44 import java.util.concurrent.Callable;
 45 import java.util.concurrent.atomic.AtomicBoolean;
 46 import java.util.function.BiFunction;
 47 import java.util.function.Function;
 48 import java.util.logging.FileHandler;
 49 import java.util.logging.LogManager;
 50 import java.util.logging.Logger;
 51 import java.util.logging.LoggingPermission;
 52 
 53 /**
 54  * @test
 55  * @bug 8033661
 56  * @summary tests that FileHandlers configured on abstract nodes in logging.properties
 57  *          will be closed on reset and reopened on updateConfiguration().
 58  *          Test a complex reconfiguration where a logger with handlers
 59  *          suddenly appears in the hierarchy between a child logger and the
 60  *          root logger.
 61  * @run main/othervm HandlersOnComplexResetUpdate UNSECURE
 62  * @run main/othervm HandlersOnComplexResetUpdate SECURE
 63  * @author danielfuchs
 64  */
 65 public class HandlersOnComplexResetUpdate {
 66 
 67     /**
 68      * We will test the handling of abstract logger nodes with file handlers in
 69      * two configurations:
 70      * UNSECURE: No security manager.
 71      * SECURE: With the security manager present - and the required
 72      *         permissions granted.
 73      */
 74     public static enum TestCase {
 75         UNSECURE, SECURE;
 76         public void run(List&lt;Properties&gt; properties) throws Exception {
 77             System.out.println(&quot;Running test case: &quot; + name());
 78             Configure.setUp(this, properties.get(0));
 79             test(this.name(), properties);
 80         }
 81     }
 82 
 83     public static final double TIMEOUT_FACTOR;
 84     static {
 85         String toFactor = System.getProperty(&quot;test.timeout.factor&quot;, &quot;1.0&quot;);
 86         TIMEOUT_FACTOR = Double.parseDouble(toFactor);
 87     }
 88     static int adjustCount(int count) {
 89         return (int) Math.ceil(TIMEOUT_FACTOR * count);
 90     }
 91 
 92     private static final String PREFIX =
 93             &quot;FileHandler-&quot; + UUID.randomUUID() + &quot;.log&quot;;
 94     private static final String userDir = System.getProperty(&quot;user.dir&quot;, &quot;.&quot;);
 95     private static final boolean userDirWritable = Files.isWritable(Paths.get(userDir));
 96 
 97     private static final List&lt;Properties&gt; properties;
 98     static {
 99         // The test will call reset() and updateConfiguration() with each of these
100         // properties in sequence. The child logger is not released between each
101         // configuration. What is interesting here is mostly what happens between
102         // props4 and props5:
103         //
104         // In step 4 (props4) the configuration defines a handler for the
105         // logger com.foo (the direct parent of com.foo.child - which is the
106         // logger we hold on to).
107         //
108         // In step 5 (props5) the configuration has nothing concerning
109         // &#39;com.foo&#39;, but the handler has been migrated to &#39;com&#39;.
110         // Since there doesn&#39;t exist any logger for &#39;com&#39; (the previous
111         // configuration didn&#39;t have any configuration for &#39;com&#39;), then
112         // &#39;com&#39; will not be found when we process the existing loggers named
113         // in the configuration.
114         //
115         // So if we didn&#39;t also process the existing loggers not named in the
116         // configuration (such as com.foo.child) then no logger for &#39;com&#39;
117         // would be created, which means that com.foo.child would not be
118         // able to inherit its configuration for &#39;com&#39; until someone explicitely
119         // creates a logger for &#39;com&#39;.
120         //
121         // This test check that a logger for &#39;com&#39; will be created because
122         // &#39;com.foo.child&#39; still exists when updateConfiguration() is called.
123 
124         Properties props1 = new Properties();
125         props1.setProperty(&quot;test.name&quot;, &quot;parent logger with handler&quot;);
126         props1.setProperty(FileHandler.class.getName() + &quot;.pattern&quot;, PREFIX);
127         props1.setProperty(FileHandler.class.getName() + &quot;.limit&quot;, String.valueOf(Integer.MAX_VALUE));
128         props1.setProperty(FileHandler.class.getName() + &quot;.level&quot;, &quot;ALL&quot;);
129         props1.setProperty(FileHandler.class.getName() + &quot;.formatter&quot;, &quot;java.util.logging.SimpleFormatter&quot;);
130         props1.setProperty(&quot;com.foo.handlers&quot;, FileHandler.class.getName());
131         props1.setProperty(&quot;test.checkHandlersOnParent&quot;, &quot;true&quot;);
132         props1.setProperty(&quot;test.checkHandlersOn&quot;, &quot;com.foo&quot;);
133         props1.setProperty(&quot;com.bar.level&quot;, &quot;FINEST&quot;);
134 
135         Properties props2 = new Properties();
136         props2.setProperty(&quot;java.util.logging.LogManager.reconfigureHandlers&quot;, &quot;true&quot;);
137         props2.setProperty(FileHandler.class.getName() + &quot;.pattern&quot;, PREFIX);
138         props2.setProperty(FileHandler.class.getName() + &quot;.limit&quot;, String.valueOf(Integer.MAX_VALUE));
139         props2.setProperty(FileHandler.class.getName() + &quot;.level&quot;, &quot;ALL&quot;);
140         props2.setProperty(FileHandler.class.getName() + &quot;.formatter&quot;, &quot;java.util.logging.SimpleFormatter&quot;);
141         props2.setProperty(&quot;com.foo.handlers&quot;, FileHandler.class.getName());
142         props2.setProperty(&quot;test.checkHandlersOnParent&quot;, &quot;true&quot;);
143         props2.setProperty(&quot;test.checkHandlersOn&quot;, &quot;com.foo&quot;);
144         props2.setProperty(&quot;com.bar.level&quot;, &quot;FINEST&quot;);
145 
146         Properties props3 = new Properties();
147         props3.setProperty(&quot;test.name&quot;, &quot;parent logger with handler&quot;);
148         props3.setProperty(FileHandler.class.getName() + &quot;.pattern&quot;, PREFIX);
149         props3.setProperty(FileHandler.class.getName() + &quot;.limit&quot;, String.valueOf(Integer.MAX_VALUE));
150         props3.setProperty(FileHandler.class.getName() + &quot;.level&quot;, &quot;ALL&quot;);
151         props3.setProperty(FileHandler.class.getName() + &quot;.formatter&quot;, &quot;java.util.logging.SimpleFormatter&quot;);
152         props3.setProperty(&quot;com.foo.handlers&quot;, FileHandler.class.getName());
153         props3.setProperty(&quot;test.checkHandlersOnParent&quot;, &quot;true&quot;);
154         props3.setProperty(&quot;test.checkHandlersOn&quot;, &quot;com.foo&quot;);
155         props3.setProperty(&quot;com.bar.level&quot;, &quot;FINEST&quot;);
156 
157         Properties props4 = new Properties();
158         props4.setProperty(&quot;java.util.logging.LogManager.reconfigureHandlers&quot;, &quot;true&quot;);
159         props4.setProperty(FileHandler.class.getName() + &quot;.pattern&quot;, PREFIX);
160         props4.setProperty(FileHandler.class.getName() + &quot;.limit&quot;, String.valueOf(Integer.MAX_VALUE));
161         props4.setProperty(FileHandler.class.getName() + &quot;.level&quot;, &quot;ALL&quot;);
162         props4.setProperty(FileHandler.class.getName() + &quot;.formatter&quot;, &quot;java.util.logging.SimpleFormatter&quot;);
163         props4.setProperty(&quot;test.checkHandlersOnParent&quot;, &quot;true&quot;);
164         props4.setProperty(&quot;test.checkHandlersOn&quot;, &quot;com.foo&quot;);
165         props4.setProperty(&quot;com.foo.handlers&quot;, FileHandler.class.getName());
166 
167         Properties props5 = new Properties();
168         props5.setProperty(&quot;test.name&quot;, &quot;parent logger with handler&quot;);
169         props5.setProperty(FileHandler.class.getName() + &quot;.pattern&quot;, PREFIX);
170         props5.setProperty(FileHandler.class.getName() + &quot;.limit&quot;, String.valueOf(Integer.MAX_VALUE));
171         props5.setProperty(FileHandler.class.getName() + &quot;.level&quot;, &quot;ALL&quot;);
172         props5.setProperty(FileHandler.class.getName() + &quot;.formatter&quot;, &quot;java.util.logging.SimpleFormatter&quot;);
173         props5.setProperty(&quot;test.checkHandlersOnParent&quot;, &quot;false&quot;);
174         props5.setProperty(&quot;test.checkHandlersOn&quot;, &quot;com&quot;);
175         props5.setProperty(&quot;com.handlers&quot;, FileHandler.class.getName());
176 
177         properties = Collections.unmodifiableList(Arrays.asList(
178                     props1, props2, props3, props4, props5));
179     }
180 
181     /**
182      * This is the main test method. The rest is infrastructure.
183      * Creates a child of the &#39;com.foo&#39; logger (com.foo.child) and holds on to
184      * it.
185      * &lt;p&gt;
186      * Then applies all given configurations in sequence and verifies assumptions
187      * about the handlers that com.foo should have, or not have.
188      * In the last configuration (props5) it also verifies that the
189      * logger &#39;com&#39; has been created and has now the expected handler.
190      * &lt;p&gt;
191      * Finally releases the child logger after all configurations have been
192      * applied.
193      *
194      * @param name
195      * @param properties
196      * @throws Exception
197      */
198     static void test(String name, List&lt;Properties&gt; properties)
199             throws Exception {
200 
201         System.out.println(&quot;\nTesting: &quot; + name);
202         if (!userDirWritable) {
203             throw new RuntimeException(&quot;Not writable: &quot;+userDir);
204         }
205 
206         // Then create a child of the com.foo logger.
207         Logger fooChild = Logger.getLogger(&quot;com.foo.child&quot;);
208         fooChild.info(&quot;hello world&quot;);
209         Logger barChild = Logger.getLogger(&quot;com.bar.child&quot;);
210         barChild.info(&quot;hello world&quot;);
211 
212         ReferenceQueue&lt;Logger&gt; queue = new ReferenceQueue();
213         WeakReference&lt;Logger&gt; fooRef = new WeakReference&lt;&gt;(Logger.getLogger(&quot;com.foo&quot;), queue);
214         if (fooRef.get() != fooChild.getParent()) {
215             throw new RuntimeException(&quot;Unexpected parent logger: &quot;
216                     + fooChild.getParent() +&quot;\n\texpected: &quot; + fooRef.get());
217         }
218         WeakReference&lt;Logger&gt; barRef = new WeakReference&lt;&gt;(Logger.getLogger(&quot;com.bar&quot;), queue);
219         if (barRef.get() != barChild.getParent()) {
220             throw new RuntimeException(&quot;Unexpected parent logger: &quot;
221                     + barChild.getParent() +&quot;\n\texpected: &quot; + barRef.get());
222         }
223         Reference&lt;? extends Logger&gt; ref2;
224         int max = adjustCount(3);
225         barChild = null;
226         while ((ref2 = queue.poll()) == null) {
227             System.gc();
228             Thread.sleep(1000);
229             if (--max == 0) break;
230         }
231 
232         Throwable failed = null;
233         try {
234             if (ref2 != null) {
235                 String refName = ref2 == fooRef ? &quot;fooRef&quot; : ref2 == barRef ? &quot;barRef&quot; : &quot;unknown&quot;;
236                 if (ref2 != barRef) {
237                     throw new RuntimeException(&quot;Unexpected logger reference cleared: &quot; + refName);
238                 } else {
239                     System.out.println(&quot;Reference &quot; + refName + &quot; cleared as expected&quot;);
240                 }
241             } else if (ref2 == null) {
242                 throw new RuntimeException(&quot;Expected &#39;barRef&#39; to be cleared&quot;);
243             }
244             // Now lets try to reset, check that ref2 has no handlers, and
245             // attempt to configure again.
246             Properties previousProps  = properties.get(0);
247             int expectedHandlersCount = 1;
248             boolean checkHandlersOnParent = Boolean.parseBoolean(
249                     previousProps.getProperty(&quot;test.checkHandlersOnParent&quot;, &quot;true&quot;));
250             String checkHandlersOn = previousProps.getProperty(&quot;test.checkHandlersOn&quot;, null);
251             for (int i=1; i&lt;properties.size(); i++) {
252                 System.out.println(&quot;\n*** Reconfiguration with properties[&quot;+i+&quot;]\n&quot;);
253                 Properties nextProps = properties.get(i);
254                 boolean reconfigureHandlers = true;
255 
256                 if (checkHandlersOnParent) {
257                     assertEquals(expectedHandlersCount,
258                             fooChild.getParent().getHandlers().length,
259                             &quot;fooChild.getParent().getHandlers().length&quot;);
260                 }
261                 if (checkHandlersOn != null) {
262                     Logger loggerWithHandlers = LogManager.getLogManager().getLogger(checkHandlersOn);
263                     if (loggerWithHandlers == null) {
264                         throw new RuntimeException(&quot;Logger with handlers not found: &quot; + checkHandlersOn);
265                     }
266                     assertEquals(expectedHandlersCount,
267                             loggerWithHandlers.getHandlers().length,
268                             checkHandlersOn + &quot;.getHandlers().length&quot;);
269                 }
270 
271                 // Reset
272                 Configure.doPrivileged(() -&gt; LogManager.getLogManager().reset());
273                 assertEquals(0, fooChild.getParent().getHandlers().length, &quot;fooChild.getParent().getHandlers().length&quot;);
274                 if (checkHandlersOn != null) {
275                     Logger loggerWithHandlers = LogManager.getLogManager().getLogger(checkHandlersOn);
276                     if (loggerWithHandlers == null) {
277                         throw new RuntimeException(&quot;Logger with handlers not found: &quot; + checkHandlersOn);
278                     }
279                     assertEquals(0, loggerWithHandlers.getHandlers().length,
280                             checkHandlersOn + &quot;.getHandlers().length&quot;);
281                 }
282 
283                 if (i == 4) {
284                     System.out.println(&quot;Last configuration...&quot;);
285                 }
286                 // Read configuration
287                 Configure.doPrivileged(() -&gt; Configure.updateConfigurationWith(nextProps, false));
288 
289                 expectedHandlersCount = reconfigureHandlers ? 1 : 0;
290                 checkHandlersOnParent = Boolean.parseBoolean(
291                     nextProps.getProperty(&quot;test.checkHandlersOnParent&quot;, &quot;true&quot;));
292                 checkHandlersOn = nextProps.getProperty(&quot;test.checkHandlersOn&quot;, null);
293 
294                 if (checkHandlersOnParent) {
295                     assertEquals(expectedHandlersCount,
296                         fooChild.getParent().getHandlers().length,
297                         &quot;fooChild.getParent().getHandlers().length&quot;);
298                 } else {
299                     assertEquals(0,
300                         fooChild.getParent().getHandlers().length,
301                         &quot;fooChild.getParent().getHandlers().length&quot;);
302                 }
303                 if (checkHandlersOn != null) {
304                     Logger loggerWithHandlers = LogManager.getLogManager().getLogger(checkHandlersOn);
305                     if (loggerWithHandlers == null) {
306                         throw new RuntimeException(&quot;Logger with handlers not found: &quot; + checkHandlersOn);
307                     }
308                     assertEquals(expectedHandlersCount,
309                             loggerWithHandlers.getHandlers().length,
310                             checkHandlersOn + &quot;.getHandlers().length&quot;);
311                 }
312             }
313         } catch (Throwable t) {
314             failed = t;
315         } finally {
316             final Throwable suppressed = failed;
317             Configure.doPrivileged(() -&gt; LogManager.getLogManager().reset());
318             Configure.doPrivileged(() -&gt; {
319                 try {
320                     StringBuilder builder = new StringBuilder();
321                     Files.list(Paths.get(userDir))
322                         .filter((f) -&gt; f.toString().contains(PREFIX))
323                         .filter((f) -&gt; f.toString().endsWith(&quot;.lck&quot;))
324                         .forEach((f) -&gt; {
325                                 builder.append(f.toString()).append(&#39;\n&#39;);
326                         });
327                     if (!builder.toString().isEmpty()) {
328                         throw new RuntimeException(&quot;Lock files not cleaned:\n&quot;
329                                 + builder.toString());
330                     }
331                 } catch(RuntimeException | Error x) {
332                     if (suppressed != null) x.addSuppressed(suppressed);
333                     throw x;
334                 } catch(Exception x) {
335                     if (suppressed != null) x.addSuppressed(suppressed);
336                     throw new RuntimeException(x);
337                 }
338             });
339             try {
340                 fooChild = null;
341                 System.out.println(&quot;Setting fooChild to: &quot; + fooChild);
342                 while ((ref2 = queue.poll()) == null) {
343                     System.gc();
344                     Thread.sleep(1000);
345                 }
346                 if (ref2 != fooRef) {
347                     throw new RuntimeException(&quot;Unexpected reference: &quot;
348                             + ref2 +&quot;\n\texpected: &quot; + fooRef);
349                 }
350                 if (ref2.get() != null) {
351                     throw new RuntimeException(&quot;Referent not cleared: &quot; + ref2.get());
352                 }
353                 System.out.println(&quot;Got fooRef after reset(), fooChild is &quot; + fooChild);
354              } catch(Throwable t) {
355                 if (failed != null) t.addSuppressed(failed);
356                 throw t;
357              }
358         }
359         if (failed != null) {
360             // should rarely happen...
361             throw new RuntimeException(failed);
362         }
363 
364     }
365 
366     public static void main(String... args) throws Exception {
367 
368 
369         if (args == null || args.length == 0) {
370             args = new String[] {
371                 TestCase.UNSECURE.name(),
372                 TestCase.SECURE.name(),
373             };
374         }
375 
376         try {
377             for (String testName : args) {
378                 TestCase test = TestCase.valueOf(testName);
379                 test.run(properties);
380             }
381         } finally {
382             if (userDirWritable) {
383                 Configure.doPrivileged(() -&gt; {
384                     // cleanup - delete files that have been created
385                     try {
386                         Files.list(Paths.get(userDir))
387                             .filter((f) -&gt; f.toString().contains(PREFIX))
388                             .forEach((f) -&gt; {
389                                 try {
390                                     System.out.println(&quot;deleting &quot; + f);
391                                     Files.delete(f);
392                                 } catch(Throwable t) {
393                                     System.err.println(&quot;Failed to delete &quot; + f + &quot;: &quot; + t);
394                                 }
395                             });
396                     } catch(Throwable t) {
397                         System.err.println(&quot;Cleanup failed to list files: &quot; + t);
398                         t.printStackTrace();
399                     }
400                 });
401             }
402         }
403     }
404 
405     static class Configure {
406         static Policy policy = null;
407         static final ThreadLocal&lt;AtomicBoolean&gt; allowAll = new ThreadLocal&lt;AtomicBoolean&gt;() {
408             @Override
409             protected AtomicBoolean initialValue() {
410                 return  new AtomicBoolean(false);
411             }
412         };
413         static void setUp(TestCase test, Properties propertyFile) {
414             switch (test) {
415                 case SECURE:
416                     if (policy == null &amp;&amp; System.getSecurityManager() != null) {
417                         throw new IllegalStateException(&quot;SecurityManager already set&quot;);
418                     } else if (policy == null) {
419                         policy = new SimplePolicy(TestCase.SECURE, allowAll);
420                         Policy.setPolicy(policy);
421                         System.setSecurityManager(new SecurityManager());
422                     }
423                     if (System.getSecurityManager() == null) {
424                         throw new IllegalStateException(&quot;No SecurityManager.&quot;);
425                     }
426                     if (policy == null) {
427                         throw new IllegalStateException(&quot;policy not configured&quot;);
428                     }
429                     break;
430                 case UNSECURE:
431                     if (System.getSecurityManager() != null) {
432                         throw new IllegalStateException(&quot;SecurityManager already set&quot;);
433                     }
434                     break;
435                 default:
436                     new InternalError(&quot;No such testcase: &quot; + test);
437             }
438             doPrivileged(() -&gt; {
439                 updateConfigurationWith(propertyFile, false);
440             });
441         }
442 
443         static void updateConfigurationWith(Properties propertyFile, boolean append) {
444             try {
445                 ByteArrayOutputStream bytes = new ByteArrayOutputStream();
446                 propertyFile.store(bytes, propertyFile.getProperty(&quot;test.name&quot;));
447                 ByteArrayInputStream bais = new ByteArrayInputStream(bytes.toByteArray());
448                 Function&lt;String, BiFunction&lt;String,String,String&gt;&gt; remapper =
449                         append ? (x) -&gt; ((o, n) -&gt; n == null ? o : n)
450                                : (x) -&gt; ((o, n) -&gt; n);
451                 LogManager.getLogManager().updateConfiguration(bais, remapper);
452             } catch (IOException ex) {
453                 throw new RuntimeException(ex);
454             }
455         }
456 
457         static void doPrivileged(Runnable run) {
458             final boolean old = allowAll.get().getAndSet(true);
459             try {
460                 run.run();
461             } finally {
462                 allowAll.get().set(old);
463             }
464         }
465         static &lt;T&gt; T callPrivileged(Callable&lt;T&gt; call) throws Exception {
466             final boolean old = allowAll.get().getAndSet(true);
467             try {
468                 return call.call();
469             } finally {
470                 allowAll.get().set(old);
471             }
472         }
473     }
474 
475     @FunctionalInterface
476     public static interface FileHandlerSupplier {
477         public FileHandler test() throws Exception;
478     }
479 
480     static final class TestAssertException extends RuntimeException {
481         TestAssertException(String msg) {
482             super(msg);
483         }
484     }
485 
486     private static void assertEquals(long expected, long received, String msg) {
487         if (expected != received) {
488             throw new TestAssertException(&quot;Unexpected result for &quot; + msg
489                     + &quot;.\n\texpected: &quot; + expected
490                     +  &quot;\n\tactual:   &quot; + received);
491         } else {
492             System.out.println(&quot;Got expected &quot; + msg + &quot;: &quot; + received);
493         }
494     }
495 
496     final static class PermissionsBuilder {
497         final Permissions perms;
498         public PermissionsBuilder() {
499             this(new Permissions());
500         }
501         public PermissionsBuilder(Permissions perms) {
502             this.perms = perms;
503         }
504         public PermissionsBuilder add(Permission p) {
505             perms.add(p);
506             return this;
507         }
508         public PermissionsBuilder addAll(PermissionCollection col) {
509             if (col != null) {
510                 for (Enumeration&lt;Permission&gt; e = col.elements(); e.hasMoreElements(); ) {
511                     perms.add(e.nextElement());
512                 }
513             }
514             return this;
515         }
516         public Permissions toPermissions() {
517             final PermissionsBuilder builder = new PermissionsBuilder();
518             builder.addAll(perms);
519             return builder.perms;
520         }
521     }
522 
523     public static class SimplePolicy extends Policy {
524 
<a name="1" id="anc1"></a>

525         final Permissions permissions;
526         final Permissions allPermissions;
527         final ThreadLocal&lt;AtomicBoolean&gt; allowAll; // actually: this should be in a thread locale
528         public SimplePolicy(TestCase test, ThreadLocal&lt;AtomicBoolean&gt; allowAll) {
529             this.allowAll = allowAll;
530             permissions = new Permissions();
531             permissions.add(new LoggingPermission(&quot;control&quot;, null));
532             permissions.add(new FilePermission(PREFIX+&quot;.lck&quot;, &quot;read,write,delete&quot;));
533             permissions.add(new FilePermission(PREFIX, &quot;read,write&quot;));
534 
535             // these are used for configuring the test itself...
536             allPermissions = new Permissions();
537             allPermissions.add(new java.security.AllPermission());
538 
539         }
540 
541         @Override
542         public boolean implies(ProtectionDomain domain, Permission permission) {
543             if (allowAll.get().get()) return allPermissions.implies(permission);
<a name="2" id="anc2"></a><span class="line-modified">544             return permissions.implies(permission);</span>
545         }
546 
547         @Override
548         public PermissionCollection getPermissions(CodeSource codesource) {
549             return new PermissionsBuilder().addAll(allowAll.get().get()
550                     ? allPermissions : permissions).toPermissions();
551         }
552 
553         @Override
554         public PermissionCollection getPermissions(ProtectionDomain domain) {
555             return new PermissionsBuilder().addAll(allowAll.get().get()
556                     ? allPermissions : permissions).toPermissions();
557         }
558     }
559 
560 }
<a name="3" id="anc3"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="3" type="hidden" />
</body>
</html>
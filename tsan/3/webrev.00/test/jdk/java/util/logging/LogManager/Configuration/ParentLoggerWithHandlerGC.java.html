<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New test/jdk/java/util/logging/LogManager/Configuration/ParentLoggerWithHandlerGC.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2014, 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 import java.io.ByteArrayInputStream;
 24 import java.io.ByteArrayOutputStream;
 25 import java.io.FilePermission;
 26 import java.io.IOException;
 27 import java.lang.ref.Reference;
 28 import java.lang.ref.ReferenceQueue;
 29 import java.lang.ref.WeakReference;
 30 import java.nio.file.Files;
 31 import java.nio.file.Paths;
 32 import java.security.CodeSource;
 33 import java.security.Permission;
 34 import java.security.PermissionCollection;
 35 import java.security.Permissions;
 36 import java.security.Policy;
 37 import java.security.ProtectionDomain;
 38 import java.util.Arrays;
 39 import java.util.Collections;
 40 import java.util.Enumeration;
 41 import java.util.HashSet;
 42 import java.util.List;
 43 import java.util.Properties;
 44 import java.util.Set;
 45 import java.util.UUID;
 46 import java.util.concurrent.Callable;
 47 import java.util.concurrent.atomic.AtomicBoolean;
 48 import java.util.logging.FileHandler;
 49 import java.util.logging.Handler;
 50 import java.util.logging.LogManager;
 51 import java.util.logging.Logger;
 52 import java.util.logging.LoggingPermission;
 53 
 54 /**
 55  * @test
 56  * @bug 8060132
 57  * @summary tests that FileHandlers configured on abstract nodes in logging.properties
 58  *          will be closed by reset().
 59  * @run main/othervm ParentLoggerWithHandlerGC UNSECURE
 60  * @run main/othervm ParentLoggerWithHandlerGC SECURE
 61  * @author danielfuchs
 62  * @key randomness
 63  */
 64 public class ParentLoggerWithHandlerGC {
 65 
 66     /**
 67      * We will test the handling of abstract logger nodes with file handlers in
 68      * two configurations:
 69      * UNSECURE: No security manager.
 70      * SECURE: With the security manager present - and the required
 71      *         permissions granted.
 72      */
 73     public static enum TestCase {
 74         UNSECURE, SECURE;
 75         public void run(Properties propertyFile) throws Exception {
 76             System.out.println(&quot;Running test case: &quot; + name());
 77             Configure.setUp(this, propertyFile);
 78             test(this.name() + &quot; &quot; + propertyFile.getProperty(&quot;test.name&quot;), propertyFile);
 79         }
 80     }
 81 
 82 
 83     private static final String PREFIX =
 84             &quot;FileHandler-&quot; + UUID.randomUUID() + &quot;.log&quot;;
 85     private static final String userDir = System.getProperty(&quot;user.dir&quot;, &quot;.&quot;);
 86     private static final boolean userDirWritable = Files.isWritable(Paths.get(userDir));
 87 
 88     static enum ConfigMode { DEFAULT, ENSURE_CLOSE_ON_RESET_TRUE, ENSURE_CLOSE_ON_RESET_FALSE }
 89 
 90     private static final List&lt;Properties&gt; properties;
 91     static {
 92         Properties props1 = new Properties();
 93         props1.setProperty(&quot;test.name&quot;, &quot;parent logger with handler&quot;);
 94         props1.setProperty(&quot;test.config.mode&quot;, ConfigMode.DEFAULT.name());
 95         props1.setProperty(FileHandler.class.getName() + &quot;.pattern&quot;, PREFIX);
 96         props1.setProperty(FileHandler.class.getName() + &quot;.limit&quot;, String.valueOf(Integer.MAX_VALUE));
 97         props1.setProperty(FileHandler.class.getName() + &quot;.level&quot;, &quot;ALL&quot;);
 98         props1.setProperty(FileHandler.class.getName() + &quot;.formatter&quot;, &quot;java.util.logging.SimpleFormatter&quot;);
 99         props1.setProperty(&quot;com.foo.handlers&quot;, FileHandler.class.getName());
100         props1.setProperty(&quot;com.bar.level&quot;, &quot;FINEST&quot;);
101 
102         Properties props2 = new Properties();
103         props2.setProperty(&quot;test.name&quot;, &quot;parent logger with handler&quot;);
104         props2.setProperty(&quot;test.config.mode&quot;, ConfigMode.ENSURE_CLOSE_ON_RESET_TRUE.name());
105         props2.setProperty(FileHandler.class.getName() + &quot;.pattern&quot;, PREFIX);
106         props2.setProperty(FileHandler.class.getName() + &quot;.limit&quot;, String.valueOf(Integer.MAX_VALUE));
107         props2.setProperty(FileHandler.class.getName() + &quot;.level&quot;, &quot;ALL&quot;);
108         props2.setProperty(FileHandler.class.getName() + &quot;.formatter&quot;, &quot;java.util.logging.SimpleFormatter&quot;);
109         props2.setProperty(&quot;com.foo.handlers&quot;, FileHandler.class.getName());
110         props2.setProperty(&quot;com.foo.handlers.ensureCloseOnReset&quot;, &quot;true&quot;);
111         props2.setProperty(&quot;com.bar.level&quot;, &quot;FINEST&quot;);
112 
113         Properties props3 = new Properties();
114         props3.setProperty(&quot;test.name&quot;, &quot;parent logger with handler&quot;);
115         props3.setProperty(&quot;test.config.mode&quot;, ConfigMode.ENSURE_CLOSE_ON_RESET_FALSE.name());
116         props3.setProperty(FileHandler.class.getName() + &quot;.pattern&quot;, PREFIX);
117         props3.setProperty(FileHandler.class.getName() + &quot;.limit&quot;, String.valueOf(Integer.MAX_VALUE));
118         props3.setProperty(FileHandler.class.getName() + &quot;.level&quot;, &quot;ALL&quot;);
119         props3.setProperty(FileHandler.class.getName() + &quot;.formatter&quot;, &quot;java.util.logging.SimpleFormatter&quot;);
120         props3.setProperty(&quot;com.foo.handlers&quot;, FileHandler.class.getName());
121         props3.setProperty(&quot;com.foo.handlers.ensureCloseOnReset&quot;, &quot;false&quot;);
122         props3.setProperty(&quot;com.bar.level&quot;, &quot;FINEST&quot;);
123 
124         properties = Collections.unmodifiableList(Arrays.asList(
125                     props1, props2, props3));
126     }
127 
128     public static void main(String... args) throws Exception {
129 
130 
131         if (args == null || args.length == 0) {
132             args = new String[] {
133                 TestCase.UNSECURE.name(),
134                 TestCase.SECURE.name(),
135             };
136         }
137 
138         try {
139             for (String testName : args) {
140                 for (Properties propertyFile : properties) {
141                     TestCase test = TestCase.valueOf(testName);
142                     test.run(propertyFile);
143                 }
144             }
145         } finally {
146             if (userDirWritable) {
147                 Configure.doPrivileged(() -&gt; {
148                     // cleanup - delete files that have been created
149                     try {
150                         Files.list(Paths.get(userDir))
151                             .filter((f) -&gt; f.toString().contains(PREFIX))
152                             .forEach((f) -&gt; {
153                                 try {
154                                     System.out.println(&quot;deleting &quot; + f);
155                                     Files.delete(f);
156                                 } catch(Throwable t) {
157                                     System.err.println(&quot;Failed to delete &quot; + f + &quot;: &quot; + t);
158                                 }
159                             });
160                     } catch(Throwable t) {
161                         System.err.println(&quot;Cleanup failed to list files: &quot; + t);
162                         t.printStackTrace();
163                     }
164                 });
165             }
166         }
167     }
168 
169     static class Configure {
170         static Policy policy = null;
171         static final AtomicBoolean allowAll = new AtomicBoolean(false);
172         static void setUp(TestCase test, Properties propertyFile) {
173             switch (test) {
174                 case SECURE:
175                     if (policy == null &amp;&amp; System.getSecurityManager() != null) {
176                         throw new IllegalStateException(&quot;SecurityManager already set&quot;);
177                     } else if (policy == null) {
178                         policy = new SimplePolicy(TestCase.SECURE, allowAll);
179                         Policy.setPolicy(policy);
180                         System.setSecurityManager(new SecurityManager());
181                     }
182                     if (System.getSecurityManager() == null) {
183                         throw new IllegalStateException(&quot;No SecurityManager.&quot;);
184                     }
185                     if (policy == null) {
186                         throw new IllegalStateException(&quot;policy not configured&quot;);
187                     }
188                     break;
189                 case UNSECURE:
190                     if (System.getSecurityManager() != null) {
191                         throw new IllegalStateException(&quot;SecurityManager already set&quot;);
192                     }
193                     break;
194                 default:
195                     new InternalError(&quot;No such testcase: &quot; + test);
196             }
197             doPrivileged(() -&gt; {
198                 try {
199                     ByteArrayOutputStream bytes = new ByteArrayOutputStream();
200                     propertyFile.store(bytes, propertyFile.getProperty(&quot;test.name&quot;));
201                     ByteArrayInputStream bais = new ByteArrayInputStream(bytes.toByteArray());
202                     LogManager.getLogManager().readConfiguration(bais);
203                 } catch (IOException ex) {
204                     throw new RuntimeException(ex);
205                 }
206             });
207         }
208         static void doPrivileged(Runnable run) {
209             allowAll.set(true);
210             try {
211                 run.run();
212             } finally {
213                 allowAll.set(false);
214             }
215         }
216         static &lt;T&gt; T callPrivileged(Callable&lt;T&gt; call) throws Exception {
217             allowAll.set(true);
218             try {
219                 return call.call();
220             } finally {
221                 allowAll.set(false);
222             }
223         }
224     }
225 
226     @FunctionalInterface
227     public static interface FileHandlerSupplier {
228         public FileHandler test() throws Exception;
229     }
230 
231     static final class TestAssertException extends RuntimeException {
232         TestAssertException(String msg) {
233             super(msg);
234         }
235     }
236 
237     private static void assertEquals(long expected, long received, String msg) {
238         if (expected != received) {
239             throw new TestAssertException(&quot;Unexpected result for &quot; + msg
240                     + &quot;.\n\texpected: &quot; + expected
241                     +  &quot;\n\tactual:   &quot; + received);
242         } else {
243             System.out.println(&quot;Got expected &quot; + msg + &quot;: &quot; + received);
244         }
245     }
246 
247 
248     public static void test(String name, Properties props) throws Exception {
249         ConfigMode configMode = ConfigMode.valueOf(props.getProperty(&quot;test.config.mode&quot;));
250         System.out.println(&quot;\nTesting: &quot; + name + &quot; mode=&quot; + configMode);
251         if (!userDirWritable) {
252             throw new RuntimeException(&quot;Not writable: &quot;+userDir);
253         }
254         switch(configMode) {
255             case DEFAULT:
256             case ENSURE_CLOSE_ON_RESET_TRUE:
257                 testCloseOnResetTrue(name, props); break;
258             case ENSURE_CLOSE_ON_RESET_FALSE:
259                 testCloseOnResetFalse(name, props); break;
260             default:
261                 throw new RuntimeException(&quot;Unknwown mode: &quot; + configMode);
262         }
263     }
264 
265 
266     // Test a configuration which has either
267     // com.foo.handlers.ensureCloseOnReset=true, or where
268     // com.foo.handlers.ensureCloseOnReset is not specified.
269     public static void testCloseOnResetTrue(String name, Properties props)
270             throws Exception {
271         Logger fooChild = Logger.getLogger(&quot;com.foo.child&quot;);
272         fooChild.info(&quot;hello world&quot;);
273         Logger barChild = Logger.getLogger(&quot;com.bar.child&quot;);
274         barChild.info(&quot;hello world&quot;);
275 
276         ReferenceQueue&lt;Logger&gt; queue = new ReferenceQueue();
277         WeakReference&lt;Logger&gt; fooRef = new WeakReference&lt;&gt;(Logger.getLogger(&quot;com.foo&quot;), queue);
278         if (fooRef.get() != fooChild.getParent()) {
279             throw new RuntimeException(&quot;Unexpected parent logger: &quot;
280                     + fooChild.getParent() +&quot;\n\texpected: &quot; + fooRef.get());
281         }
282         WeakReference&lt;Logger&gt; barRef = new WeakReference&lt;&gt;(Logger.getLogger(&quot;com.bar&quot;), queue);
283         if (barRef.get() != barChild.getParent()) {
284             throw new RuntimeException(&quot;Unexpected parent logger: &quot;
285                     + barChild.getParent() +&quot;\n\texpected: &quot; + barRef.get());
286         }
287         fooChild = barChild = null;
288         Reference&lt;? extends Logger&gt; ref2 = null;
289         while ((ref2 = queue.poll()) == null) {
290             System.gc();
291             Thread.sleep(1000);
292         }
293         Throwable failed = null;
294         try {
295             do {
296                 if (ref2 != barRef) {
297                     throw new RuntimeException(&quot;Unexpected reference: &quot;
298                             + ref2 +&quot;\n\texpected: &quot; + barRef);
299                 }
300                 if (ref2.get() != null) {
301                     throw new RuntimeException(&quot;Referent not cleared: &quot;
302                             + ref2.get());
303                 }
304                 System.out.println(&quot;Got barRef&quot;);
305                 System.gc();
306                 Thread.sleep(1000);
307             } while( (ref2 = queue.poll()) != null);
308             System.out.println(&quot;Parent logger GCed&quot;);
309         } catch(Throwable t) {
310             failed = t;
311         } finally {
312             final Throwable suppressed = failed;
313             Configure.doPrivileged(() -&gt; LogManager.getLogManager().reset());
314             Configure.doPrivileged(() -&gt; {
315                 try {
316                     StringBuilder builder = new StringBuilder();
317                     Files.list(Paths.get(userDir))
318                         .filter((f) -&gt; f.toString().contains(PREFIX))
319                         .filter((f) -&gt; f.toString().endsWith(&quot;.lck&quot;))
320                         .forEach((f) -&gt; {
321                                 builder.append(f.toString()).append(&#39;\n&#39;);
322                         });
323                     if (!builder.toString().isEmpty()) {
324                         throw new RuntimeException(&quot;Lock files not cleaned:\n&quot;
325                                 + builder.toString());
326                     }
327                 } catch(RuntimeException | Error x) {
328                     if (suppressed != null) x.addSuppressed(suppressed);
329                     throw x;
330                 } catch(Exception x) {
331                     if (suppressed != null) x.addSuppressed(suppressed);
332                     throw new RuntimeException(x);
333                 }
334             });
335             while ((ref2 = queue.poll()) == null) {
336                 System.gc();
337                 Thread.sleep(1000);
338             }
339             if (ref2 != fooRef) {
340                 throw new RuntimeException(&quot;Unexpected reference: &quot;
341                         + ref2 +&quot;\n\texpected: &quot; + fooRef);
342             }
343             if (ref2.get() != null) {
344                 throw new RuntimeException(&quot;Referent not cleared: &quot; + ref2.get());
345             }
346             System.out.println(&quot;Got fooRef after reset()&quot;);
347 
348         }
349         if (failed != null) {
350             // should rarely happen...
351             throw new RuntimeException(failed);
352         }
353 
354     }
355 
356     private static Handler getHandlerToClose() throws Exception {
357         return Configure.callPrivileged(
358                 () -&gt; Logger.getLogger(&quot;com.foo.child&quot;).getParent().getHandlers()[0]);
359     }
360 
361     // Test a configuration which has com.foo.handlers.ensureCloseOnReset=false
362     public static void testCloseOnResetFalse(String name, Properties props)
363             throws Exception {
364         Logger fooChild = Logger.getLogger(&quot;com.foo.child&quot;);
365         fooChild.info(&quot;hello world&quot;);
366         Logger barChild = Logger.getLogger(&quot;com.bar.child&quot;);
367         barChild.info(&quot;hello world&quot;);
368 
369         Handler toClose = getHandlerToClose();
370 
371         ReferenceQueue&lt;Logger&gt; queue = new ReferenceQueue();
372         WeakReference&lt;Logger&gt; fooRef = new WeakReference&lt;&gt;(Logger.getLogger(&quot;com.foo&quot;), queue);
373         if (fooRef.get() != fooChild.getParent()) {
374             throw new RuntimeException(&quot;Unexpected parent logger: &quot;
375                     + fooChild.getParent() +&quot;\n\texpected: &quot; + fooRef.get());
376         }
377         WeakReference&lt;Logger&gt; barRef = new WeakReference&lt;&gt;(Logger.getLogger(&quot;com.bar&quot;), queue);
378         if (barRef.get() != barChild.getParent()) {
379             throw new RuntimeException(&quot;Unexpected parent logger: &quot;
380                     + barChild.getParent() +&quot;\n\texpected: &quot; + barRef.get());
381         }
382         fooChild = barChild = null;
383         Reference&lt;? extends Logger&gt; ref2 = null;
384         Set&lt;WeakReference&lt;Logger&gt;&gt; expectedRefs = new HashSet&lt;&gt;(Arrays.asList(fooRef, barRef));
385         Throwable failed = null;
386         try {
387             int l=0;
388             while (failed == null &amp;&amp; !expectedRefs.isEmpty()) {
389                 int max = 60;
390                 while ((ref2 = queue.poll()) == null) {
391                     if (l &gt; 0 &amp;&amp; max-- &lt;= 0) {
392                         throw new RuntimeException(&quot;Logger #2 not GC&#39;ed!&quot;
393                                 + &quot; max too short (max=60) or &quot;
394                                 + &quot;com.foo.handlers.ensureCloseOnReset=false&quot;
395                                 + &quot; does not work&quot;);
396                     }
397                     System.gc();
398                     Thread.sleep(1000);
399                 }
400                 do {
401                     if (!expectedRefs.contains(ref2)) {
402                         throw new RuntimeException(&quot;Unexpected reference: &quot;
403                                 + ref2 +&quot;\n\texpected: &quot; + expectedRefs);
404                     }
405                     if (ref2.get() != null) {
406                         throw new RuntimeException(&quot;Referent not cleared: &quot;
407                                 + ref2.get());
408                     }
409                     expectedRefs.remove(ref2);
410                     System.out.println(&quot;Got &quot;+
411                             (ref2 == barRef ? &quot;barRef&quot;
412                                     : (ref2 == fooRef ? &quot;fooRef&quot;
413                                             : ref2.toString())));
414                     System.gc();
415                     Thread.sleep(1000);
416                     System.out.println(&quot;Logger #&quot; + (++l) + &quot; GCed&quot;);
417                 } while( (ref2 = queue.poll()) != null);
418             }
419         } catch(Throwable t) {
420             failed = t;
421         } finally {
422             final Throwable suppressed = failed;
423             Configure.doPrivileged(() -&gt; LogManager.getLogManager().reset());
424             Configure.doPrivileged(() -&gt; {
425                 try {
426                     toClose.close();
427                     StringBuilder builder = new StringBuilder();
428                     Files.list(Paths.get(userDir))
429                         .filter((f) -&gt; f.toString().contains(PREFIX))
430                         .filter((f) -&gt; f.toString().endsWith(&quot;.lck&quot;))
431                         .forEach((f) -&gt; {
432                                 builder.append(f.toString()).append(&#39;\n&#39;);
433                         });
434                     if (!builder.toString().isEmpty()) {
435                         throw new RuntimeException(&quot;Lock files not cleaned:\n&quot; + builder.toString());
436                     }
437                 } catch(RuntimeException | Error x) {
438                     if (suppressed != null) x.addSuppressed(suppressed);
439                     throw x;
440                 } catch(Exception x) {
441                     if (suppressed != null) x.addSuppressed(suppressed);
442                     throw new RuntimeException(x);
443                 }
444             });
445         }
446         if (failed != null) {
447             // should rarely happen...
448             throw new RuntimeException(failed);
449         }
450 
451     }
452 
453 
454     static final class PermissionsBuilder {
455         final Permissions perms;
456         public PermissionsBuilder() {
457             this(new Permissions());
458         }
459         public PermissionsBuilder(Permissions perms) {
460             this.perms = perms;
461         }
462         public PermissionsBuilder add(Permission p) {
463             perms.add(p);
464             return this;
465         }
466         public PermissionsBuilder addAll(PermissionCollection col) {
467             if (col != null) {
468                 for (Enumeration&lt;Permission&gt; e = col.elements(); e.hasMoreElements(); ) {
469                     perms.add(e.nextElement());
470                 }
471             }
472             return this;
473         }
474         public Permissions toPermissions() {
475             final PermissionsBuilder builder = new PermissionsBuilder();
476             builder.addAll(perms);
477             return builder.perms;
478         }
479     }
480 
481     public static class SimplePolicy extends Policy {
482 
483         static final Policy DEFAULT_POLICY = Policy.getPolicy();
484 
485         final Permissions permissions;
486         final Permissions allPermissions;
487         final AtomicBoolean allowAll;
488         public SimplePolicy(TestCase test, AtomicBoolean allowAll) {
489             this.allowAll = allowAll;
490             permissions = new Permissions();
491             permissions.add(new LoggingPermission(&quot;control&quot;, null));
492             permissions.add(new FilePermission(PREFIX+&quot;.lck&quot;, &quot;read,write,delete&quot;));
493             permissions.add(new FilePermission(PREFIX, &quot;read,write&quot;));
494 
495             // these are used for configuring the test itself...
496             allPermissions = new Permissions();
497             allPermissions.add(new java.security.AllPermission());
498 
499         }
500 
501         @Override
502         public boolean implies(ProtectionDomain domain, Permission permission) {
503             if (allowAll.get()) return allPermissions.implies(permission);
504             return permissions.implies(permission) || DEFAULT_POLICY.implies(domain, permission);
505         }
506 
507         @Override
508         public PermissionCollection getPermissions(CodeSource codesource) {
509             return new PermissionsBuilder().addAll(allowAll.get()
510                     ? allPermissions : permissions).toPermissions();
511         }
512 
513         @Override
514         public PermissionCollection getPermissions(ProtectionDomain domain) {
515             return new PermissionsBuilder().addAll(allowAll.get()
516                     ? allPermissions : permissions).toPermissions();
517         }
518     }
519 
520 }
    </pre>
  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames test/jdk/java/util/logging/FileHandlerPath.java</title>
    <link rel="stylesheet" href="../../../../../style.css" />
    <script type="text/javascript" src="../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
<a name="1" id="anc1"></a><span class="line-modified">  2  * Copyright (c) 2014, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 import java.io.ByteArrayInputStream;
 24 import java.io.ByteArrayOutputStream;
 25 import java.io.File;
 26 import java.io.FilePermission;
 27 import java.io.IOException;
 28 import java.nio.channels.FileChannel;
 29 import java.nio.file.Files;
 30 import java.nio.file.Paths;
 31 import static java.nio.file.StandardOpenOption.CREATE_NEW;
 32 import static java.nio.file.StandardOpenOption.WRITE;
 33 import java.security.CodeSource;
 34 import java.security.Permission;
 35 import java.security.PermissionCollection;
 36 import java.security.Permissions;
 37 import java.security.Policy;
 38 import java.security.ProtectionDomain;
 39 import java.util.Arrays;
 40 import java.util.Collections;
 41 import java.util.Enumeration;
 42 import java.util.List;
 43 import java.util.Properties;
 44 import java.util.PropertyPermission;
 45 import java.util.UUID;
 46 import java.util.concurrent.atomic.AtomicBoolean;
 47 import java.util.logging.FileHandler;
 48 import java.util.logging.LogManager;
 49 import java.util.logging.LoggingPermission;
 50 
 51 /**
 52  * @test
 53  * @bug 8059269
 54  * @summary tests that using a simple (non composite) pattern does not lead
 55  *        to NPE when the lock file already exists.
 56  * @run main/othervm FileHandlerPath UNSECURE
 57  * @run main/othervm FileHandlerPath SECURE
 58  * @author danielfuchs
 59  * @key randomness
 60  */
 61 public class FileHandlerPath {
 62 
 63     /**
 64      * We will test the simple pattern in two configurations.
 65      * UNSECURE: No security manager.
 66      * SECURE: With the security manager present - and the required
 67      *         permissions granted.
 68      */
 69     public static enum TestCase {
 70         UNSECURE, SECURE;
 71         public void run(Properties propertyFile) throws Exception {
 72             System.out.println(&quot;Running test case: &quot; + name());
 73             Configure.setUp(this, propertyFile);
 74             test(this.name() + &quot; &quot; + propertyFile.getProperty(&quot;test.name&quot;), propertyFile);
 75         }
 76     }
 77 
 78 
 79     // Use a random name provided by UUID to avoid collision with other tests
 80     static final String logFile = FileHandlerPath.class.getSimpleName() + &quot;_&quot;
 81                 + UUID.randomUUID().toString() + &quot;.log&quot;;
 82     static final String tmpLogFile;
 83     static final String userDir = System.getProperty(&quot;user.dir&quot;);
 84     static final String tmpDir = System.getProperty(&quot;java.io.tmpdir&quot;);
 85     private static final List&lt;Properties&gt; properties;
 86     static {
 87         tmpLogFile = new File(tmpDir, logFile).toString();
 88         Properties props1 = new Properties();
 89         Properties props2 = new Properties();
 90         props1.setProperty(&quot;test.name&quot;, &quot;relative file&quot;);
 91         props1.setProperty(&quot;test.file.name&quot;, logFile);
 92         props1.setProperty(FileHandler.class.getName() + &quot;.pattern&quot;, logFile);
 93         props1.setProperty(FileHandler.class.getName() + &quot;.count&quot;, &quot;1&quot;);
 94         props2.setProperty(&quot;test.name&quot;, &quot;absoluste file&quot;);
 95         props2.setProperty(&quot;test.file.name&quot;, tmpLogFile);
 96         props2.setProperty(FileHandler.class.getName() + &quot;.pattern&quot;, &quot;%t/&quot; + logFile);
 97         props2.setProperty(FileHandler.class.getName() + &quot;.count&quot;, &quot;1&quot;);
 98         properties = Collections.unmodifiableList(Arrays.asList(
 99                     props1,
100                     props2));
101     }
102 
103     public static void main(String... args) throws Exception {
104 
105         if (args == null || args.length == 0) {
106             args = new String[] {
107                 TestCase.UNSECURE.name(),
108                 TestCase.SECURE.name(),
109             };
110         }
111 
112         // Sanity checks
113 
114         if (!Files.isWritable(Paths.get(userDir))) {
115             throw new RuntimeException(userDir +
116                     &quot;: user.dir is not writable - can&#39;t run test.&quot;);
117         }
118         if (!Files.isWritable(Paths.get(tmpDir))) {
119             throw new RuntimeException(tmpDir +
120                     &quot;: java.io.tmpdir is not writable - can&#39;t run test.&quot;);
121         }
122 
123         File[] files = {
124             new File(logFile),
125             new File(tmpLogFile),
126             new File(logFile+&quot;.1&quot;),
127             new File(tmpLogFile+&quot;.1&quot;),
128             new File(logFile+&quot;.lck&quot;),
129             new File(tmpLogFile+&quot;.lck&quot;),
130             new File(logFile+&quot;.1.lck&quot;),
131             new File(tmpLogFile+&quot;.1.lck&quot;)
132         };
133 
134         for (File log : files) {
135             if (log.exists()) {
136                 throw new Exception(log +&quot;: file already exists - can&#39;t run test.&quot;);
137             }
138         }
139 
140         // Now start the real test
141 
142         try {
143             for (String testName : args) {
144                 for (Properties propertyFile : properties) {
145                     TestCase test = TestCase.valueOf(testName);
146                     test.run(propertyFile);
147                 }
148             }
149         } finally {
150             // Cleanup...
151             Configure.doPrivileged(() -&gt; {
152                 for(File log : files) {
153                     try {
154                         final boolean isLockFile = log.getName().endsWith(&quot;.lck&quot;);
155                         // lock file should already be deleted, except if the
156                         // test failed in exception.
157                         // log file should all be present, except if the test
158                         // failed in exception.
159                         if (log.exists()) {
160                             if (!isLockFile) {
161                                 System.out.println(&quot;deleting &quot;+log.toString());
162                             } else {
163                                 System.err.println(&quot;deleting lock file &quot;+log.toString());
164                             }
165                             log.delete();
166                         } else {
167                             if (!isLockFile) {
168                                 System.err.println(log.toString() + &quot;: not found.&quot;);
169                             }
170                         }
171                     } catch (Throwable t) {
172                         // should not happen
173                         t.printStackTrace();
174                     }
175                 }
176             });
177         }
178     }
179 
180     static class Configure {
181         static Policy policy = null;
182         static final AtomicBoolean allowAll = new AtomicBoolean(false);
183         static void setUp(TestCase test, Properties propertyFile) {
184             switch (test) {
185                 case SECURE:
186                     if (policy == null &amp;&amp; System.getSecurityManager() != null) {
187                         throw new IllegalStateException(&quot;SecurityManager already set&quot;);
188                     } else if (policy == null) {
189                         policy = new SimplePolicy(TestCase.SECURE, allowAll);
190                         Policy.setPolicy(policy);
191                         System.setSecurityManager(new SecurityManager());
192                     }
193                     if (System.getSecurityManager() == null) {
194                         throw new IllegalStateException(&quot;No SecurityManager.&quot;);
195                     }
196                     if (policy == null) {
197                         throw new IllegalStateException(&quot;policy not configured&quot;);
198                     }
199                     break;
200                 case UNSECURE:
201                     if (System.getSecurityManager() != null) {
202                         throw new IllegalStateException(&quot;SecurityManager already set&quot;);
203                     }
204                     break;
205                 default:
206                     new InternalError(&quot;No such testcase: &quot; + test);
207             }
208             doPrivileged(() -&gt; {
209                 try {
210                     ByteArrayOutputStream bytes = new ByteArrayOutputStream();
211                     propertyFile.store(bytes, propertyFile.getProperty(&quot;test.name&quot;));
212                     ByteArrayInputStream bais = new ByteArrayInputStream(bytes.toByteArray());
213                     LogManager.getLogManager().readConfiguration(bais);
214                 } catch (IOException ex) {
215                     throw new RuntimeException(ex);
216                 }
217             });
218         }
219         static void doPrivileged(Runnable run) {
220             allowAll.set(true);
221             try {
222                 run.run();
223             } finally {
224                 allowAll.set(false);
225             }
226         }
227     }
228 
229     public static void test(String name, Properties props) throws Exception {
230         System.out.println(&quot;Testing: &quot; + name);
231         String file = props.getProperty(&quot;test.file.name&quot;);
232         // create the lock files first - in order to take the path that
233         // used to trigger the NPE
234         Files.createFile(Paths.get(file + &quot;.lck&quot;));
235         Files.createFile(Paths.get(file + &quot;.1.lck&quot;));
236         final FileHandler f1 = new FileHandler();
237         final FileHandler f2 = new FileHandler();
238         f1.close();
239         f2.close();
240         System.out.println(&quot;Success for &quot; + name);
241     }
242 
243 
244     static final class PermissionsBuilder {
245         final Permissions perms;
246         public PermissionsBuilder() {
247             this(new Permissions());
248         }
249         public PermissionsBuilder(Permissions perms) {
250             this.perms = perms;
251         }
252         public PermissionsBuilder add(Permission p) {
253             perms.add(p);
254             return this;
255         }
256         public PermissionsBuilder addAll(PermissionCollection col) {
257             if (col != null) {
258                 for (Enumeration&lt;Permission&gt; e = col.elements(); e.hasMoreElements(); ) {
259                     perms.add(e.nextElement());
260                 }
261             }
262             return this;
263         }
264         public Permissions toPermissions() {
265             final PermissionsBuilder builder = new PermissionsBuilder();
266             builder.addAll(perms);
267             return builder.perms;
268         }
269     }
270 
271     public static class SimplePolicy extends Policy {
272 
<a name="2" id="anc2"></a>

273         final Permissions permissions;
274         final Permissions allPermissions;
275         final AtomicBoolean allowAll;
276         public SimplePolicy(TestCase test, AtomicBoolean allowAll) {
277             this.allowAll = allowAll;
278             permissions = new Permissions();
279             permissions.add(new LoggingPermission(&quot;control&quot;, null)); // needed by new FileHandler()
280             permissions.add(new FilePermission(&quot;&lt;&lt;ALL FILES&gt;&gt;&quot;, &quot;read&quot;)); // needed by new FileHandler()
281             permissions.add(new FilePermission(logFile, &quot;write,delete&quot;)); // needed by new FileHandler()
282             permissions.add(new FilePermission(logFile+&quot;.lck&quot;, &quot;write,delete&quot;)); // needed by FileHandler.close()
283             permissions.add(new FilePermission(logFile+&quot;.1&quot;, &quot;write,delete&quot;)); // needed by new FileHandler()
284             permissions.add(new FilePermission(logFile+&quot;.1.lck&quot;, &quot;write,delete&quot;)); // needed by FileHandler.close()
285             permissions.add(new FilePermission(tmpLogFile, &quot;write,delete&quot;)); // needed by new FileHandler()
286             permissions.add(new FilePermission(tmpLogFile+&quot;.lck&quot;, &quot;write,delete&quot;)); // needed by FileHandler.close()
287             permissions.add(new FilePermission(tmpLogFile+&quot;.1&quot;, &quot;write,delete&quot;)); // needed by new FileHandler()
288             permissions.add(new FilePermission(tmpLogFile+&quot;.1.lck&quot;, &quot;write,delete&quot;)); // needed by FileHandler.close()
289             permissions.add(new FilePermission(userDir, &quot;write&quot;)); // needed by new FileHandler()
290             permissions.add(new FilePermission(tmpDir, &quot;write&quot;)); // needed by new FileHandler()
291             permissions.add(new PropertyPermission(&quot;user.dir&quot;, &quot;read&quot;));
292             permissions.add(new PropertyPermission(&quot;java.io.tmpdir&quot;, &quot;read&quot;));
293             allPermissions = new Permissions();
294             allPermissions.add(new java.security.AllPermission());
295         }
296 
297         @Override
298         public boolean implies(ProtectionDomain domain, Permission permission) {
299             if (allowAll.get()) return allPermissions.implies(permission);
<a name="3" id="anc3"></a><span class="line-modified">300             return permissions.implies(permission);</span>
301         }
302 
303         @Override
304         public PermissionCollection getPermissions(CodeSource codesource) {
305             return new PermissionsBuilder().addAll(allowAll.get()
306                     ? allPermissions : permissions).toPermissions();
307         }
308 
309         @Override
310         public PermissionCollection getPermissions(ProtectionDomain domain) {
311             return new PermissionsBuilder().addAll(allowAll.get()
312                     ? allPermissions : permissions).toPermissions();
313         }
314     }
315 
316 }
<a name="4" id="anc4"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="4" type="hidden" />
</body>
</html>
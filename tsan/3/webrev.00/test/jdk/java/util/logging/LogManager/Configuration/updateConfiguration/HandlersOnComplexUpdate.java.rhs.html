<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames test/jdk/java/util/logging/LogManager/Configuration/updateConfiguration/HandlersOnComplexUpdate.java</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (c) 2015, 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 import java.io.ByteArrayInputStream;
 24 import java.io.ByteArrayOutputStream;
 25 import java.io.FilePermission;
 26 import java.io.IOException;
 27 import java.lang.ref.Reference;
 28 import java.lang.ref.ReferenceQueue;
 29 import java.lang.ref.WeakReference;
 30 import java.nio.file.Files;
 31 import java.nio.file.Paths;
 32 import java.security.CodeSource;
 33 import java.security.Permission;
 34 import java.security.PermissionCollection;
 35 import java.security.Permissions;
 36 import java.security.Policy;
 37 import java.security.ProtectionDomain;
 38 import java.util.Arrays;
 39 import java.util.Collections;
 40 import java.util.Enumeration;
 41 import java.util.List;
 42 import java.util.Properties;
 43 import java.util.UUID;
 44 import java.util.concurrent.Callable;
 45 import java.util.concurrent.atomic.AtomicBoolean;
 46 import java.util.function.BiFunction;
 47 import java.util.function.Function;
 48 import java.util.logging.FileHandler;
 49 import java.util.logging.LogManager;
 50 import java.util.logging.Logger;
 51 import java.util.logging.LoggingPermission;
 52 
 53 /**
 54  * @test
 55  * @bug 8033661
 56  * @summary tests that FileHandlers configured on abstract nodes in logging.properties
 57  *          will be properly closed and reopened on updateConfiguration().
 58  *          Test a complex reconfiguration where a logger with handlers
 59  *          suddenly appears in the hierarchy between a child logger and the
 60  *          root logger.
 61  * @run main/othervm HandlersOnComplexUpdate UNSECURE
 62  * @run main/othervm HandlersOnComplexUpdate SECURE
 63  * @author danielfuchs
 64  */
 65 public class HandlersOnComplexUpdate {
 66 
 67     /**
 68      * We will test the handling of abstract logger nodes with file handlers in
 69      * two configurations:
 70      * UNSECURE: No security manager.
 71      * SECURE: With the security manager present - and the required
 72      *         permissions granted.
 73      */
 74     public static enum TestCase {
 75         UNSECURE, SECURE;
 76         public void run(List&lt;Properties&gt; properties) throws Exception {
 77             System.out.println(&quot;Running test case: &quot; + name());
 78             Configure.setUp(this, properties.get(0));
 79             test(this.name(), properties);
 80         }
 81     }
 82 
 83     public static final double TIMEOUT_FACTOR;
 84     static {
 85         String toFactor = System.getProperty(&quot;test.timeout.factor&quot;, &quot;1.0&quot;);
 86         TIMEOUT_FACTOR = Double.parseDouble(toFactor);
 87     }
 88     static int adjustCount(int count) {
 89         return (int) Math.ceil(TIMEOUT_FACTOR * count);
 90     }
 91 
 92     private static final String PREFIX =
 93             &quot;FileHandler-&quot; + UUID.randomUUID() + &quot;.log&quot;;
 94     private static final String userDir = System.getProperty(&quot;user.dir&quot;, &quot;.&quot;);
 95     private static final boolean userDirWritable = Files.isWritable(Paths.get(userDir));
 96 
 97     private static final List&lt;Properties&gt; properties;
 98     static {
 99         // The test will call updateConfiguration() with each of these
100         // properties in sequence. The child logger is not released between each
101         // configuration. What is interesting here is mostly what happens between
102         // props4 and props5:
103         //
104         // In step 4 (props4) the configuration defines a handler for the
105         // logger com.foo (the direct parent of com.foo.child - which is the
106         // logger we hold on to).
107         //
108         // In step 5 (props5) the configuration has nothing concerning
109         // &#39;com.foo&#39;, but the handler has been migrated to &#39;com&#39;.
110         // Since there doesn&#39;t exist any logger for &#39;com&#39; (the previous
111         // configuration didn&#39;t have any configuration for &#39;com&#39;), then
112         // &#39;com&#39; will not be found when we process the existing loggers named
113         // in the configuration.
114         //
115         // So if we didn&#39;t also process the existing loggers not named in the
116         // configuration (such as com.foo.child) then no logger for &#39;com&#39;
117         // would be created, which means that com.foo.child would not be
118         // able to inherit its configuration for &#39;com&#39; until someone explicitely
119         // creates a logger for &#39;com&#39;.
120         //
121         // This test check that a logger for &#39;com&#39; will be created because
122         // &#39;com.foo.child&#39; still exists when updateConfiguration() is called.
123 
124         Properties props1 = new Properties();
125         props1.setProperty(&quot;test.name&quot;, &quot;parent logger with handler&quot;);
126         props1.setProperty(FileHandler.class.getName() + &quot;.pattern&quot;, PREFIX);
127         props1.setProperty(FileHandler.class.getName() + &quot;.limit&quot;, String.valueOf(Integer.MAX_VALUE));
128         props1.setProperty(FileHandler.class.getName() + &quot;.level&quot;, &quot;ALL&quot;);
129         props1.setProperty(FileHandler.class.getName() + &quot;.formatter&quot;, &quot;java.util.logging.SimpleFormatter&quot;);
130         props1.setProperty(&quot;com.foo.handlers&quot;, FileHandler.class.getName());
131         props1.setProperty(&quot;test.checkHandlersOnParent&quot;, &quot;true&quot;);
132         props1.setProperty(&quot;test.checkHandlersOn&quot;, &quot;com.foo&quot;);
133         props1.setProperty(&quot;com.bar.level&quot;, &quot;FINEST&quot;);
134 
135         Properties props2 = new Properties();
136         props2.setProperty(&quot;test.name&quot;, &quot;parent logger with handler&quot;);
137         props2.setProperty(FileHandler.class.getName() + &quot;.pattern&quot;, PREFIX);
138         props2.setProperty(FileHandler.class.getName() + &quot;.limit&quot;, String.valueOf(Integer.MAX_VALUE));
139         props2.setProperty(FileHandler.class.getName() + &quot;.level&quot;, &quot;ALL&quot;);
140         props2.setProperty(FileHandler.class.getName() + &quot;.formatter&quot;, &quot;java.util.logging.SimpleFormatter&quot;);
141         props2.setProperty(&quot;com.foo.handlers&quot;, FileHandler.class.getName());
142         props2.setProperty(&quot;test.checkHandlersOnParent&quot;, &quot;true&quot;);
143         props2.setProperty(&quot;test.checkHandlersOn&quot;, &quot;com.foo&quot;);
144         props2.setProperty(&quot;com.bar.level&quot;, &quot;FINEST&quot;);
145 
146         Properties props3 = new Properties();
147         props3.setProperty(&quot;test.name&quot;, &quot;parent logger with handler&quot;);
148         props3.setProperty(FileHandler.class.getName() + &quot;.pattern&quot;, PREFIX);
149         props3.setProperty(FileHandler.class.getName() + &quot;.limit&quot;, String.valueOf(Integer.MAX_VALUE));
150         props3.setProperty(FileHandler.class.getName() + &quot;.level&quot;, &quot;ALL&quot;);
151         props3.setProperty(FileHandler.class.getName() + &quot;.formatter&quot;, &quot;java.util.logging.SimpleFormatter&quot;);
152         props3.setProperty(&quot;com.foo.handlers&quot;, FileHandler.class.getName());
153         props3.setProperty(&quot;test.checkHandlersOnParent&quot;, &quot;true&quot;);
154         props3.setProperty(&quot;test.checkHandlersOn&quot;, &quot;com.foo&quot;);
155         props3.setProperty(&quot;com.bar.level&quot;, &quot;FINEST&quot;);
156 
157         Properties props4 = new Properties();
158         props4.setProperty(&quot;test.name&quot;, &quot;parent logger with handler&quot;);
159         props4.setProperty(FileHandler.class.getName() + &quot;.pattern&quot;, PREFIX);
160         props4.setProperty(FileHandler.class.getName() + &quot;.limit&quot;, String.valueOf(Integer.MAX_VALUE));
161         props4.setProperty(FileHandler.class.getName() + &quot;.level&quot;, &quot;ALL&quot;);
162         props4.setProperty(FileHandler.class.getName() + &quot;.formatter&quot;, &quot;java.util.logging.SimpleFormatter&quot;);
163         props4.setProperty(&quot;test.checkHandlersOnParent&quot;, &quot;true&quot;);
164         props4.setProperty(&quot;test.checkHandlersOn&quot;, &quot;com.foo&quot;);
165         props4.setProperty(&quot;com.foo.handlers&quot;, FileHandler.class.getName());
166 
167         Properties props5 = new Properties();
168         props5.setProperty(&quot;test.name&quot;, &quot;parent logger with handler&quot;);
169         props5.setProperty(FileHandler.class.getName() + &quot;.pattern&quot;, PREFIX);
170         props5.setProperty(FileHandler.class.getName() + &quot;.limit&quot;, String.valueOf(Integer.MAX_VALUE));
171         props5.setProperty(FileHandler.class.getName() + &quot;.level&quot;, &quot;ALL&quot;);
172         props5.setProperty(FileHandler.class.getName() + &quot;.formatter&quot;, &quot;java.util.logging.SimpleFormatter&quot;);
173         props5.setProperty(&quot;test.checkHandlersOnParent&quot;, &quot;false&quot;);
174         props5.setProperty(&quot;test.checkHandlersOn&quot;, &quot;com&quot;);
175         props5.setProperty(&quot;com.handlers&quot;, FileHandler.class.getName());
176 
177         properties = Collections.unmodifiableList(Arrays.asList(
178                     props1, props2, props3, props4, props5));
179     }
180 
181     /**
182      * This is the main test method. The rest is infrastructure.
183      * Creates a child of the &#39;com.foo&#39; logger (com.foo.child) and holds on to
184      * it.
185      * &lt;p&gt;
186      * Then applies all given configurations in sequence and verifies assumptions
187      * about the handlers that com.foo should have, or not have.
188      * In the last configuration (props5) it also verifies that the
189      * logger &#39;com&#39; has been created and has now the expected handler.
190      * &lt;p&gt;
191      * Finally releases the child logger after all configurations have been
192      * applied.
193      *
194      * @param name
195      * @param properties
196      * @throws Exception
197      */
198     static void test(String name, List&lt;Properties&gt; properties)
199             throws Exception {
200 
201         System.out.println(&quot;\nTesting: &quot; + name);
202         if (!userDirWritable) {
203             throw new RuntimeException(&quot;Not writable: &quot;+userDir);
204         }
205 
206         // Then create a child of the com.foo logger.
207         Logger fooChild = Logger.getLogger(&quot;com.foo.child&quot;);
208         fooChild.info(&quot;hello world&quot;);
209         Logger barChild = Logger.getLogger(&quot;com.bar.child&quot;);
210         barChild.info(&quot;hello world&quot;);
211 
212         ReferenceQueue&lt;Logger&gt; queue = new ReferenceQueue();
213         WeakReference&lt;Logger&gt; fooRef = new WeakReference&lt;&gt;(Logger.getLogger(&quot;com.foo&quot;), queue);
214         if (fooRef.get() != fooChild.getParent()) {
215             throw new RuntimeException(&quot;Unexpected parent logger: &quot;
216                     + fooChild.getParent() +&quot;\n\texpected: &quot; + fooRef.get());
217         }
218         WeakReference&lt;Logger&gt; barRef = new WeakReference&lt;&gt;(Logger.getLogger(&quot;com.bar&quot;), queue);
219         if (barRef.get() != barChild.getParent()) {
220             throw new RuntimeException(&quot;Unexpected parent logger: &quot;
221                     + barChild.getParent() +&quot;\n\texpected: &quot; + barRef.get());
222         }
223         Reference&lt;? extends Logger&gt; ref2;
224         int max = adjustCount(3);
225         barChild = null;
226         while ((ref2 = queue.poll()) == null) {
227             System.gc();
228             Thread.sleep(1000);
229             if (--max == 0) break;
230         }
231 
232         Throwable failed = null;
233         try {
234             if (ref2 != null) {
235                 String refName = ref2 == fooRef ? &quot;fooRef&quot; : ref2 == barRef ? &quot;barRef&quot; : &quot;unknown&quot;;
236                 if (ref2 != barRef) {
237                     throw new RuntimeException(&quot;Unexpected logger reference cleared: &quot; + refName);
238                 } else {
239                     System.out.println(&quot;Reference &quot; + refName + &quot; cleared as expected&quot;);
240                 }
241             } else if (ref2 == null) {
242                 throw new RuntimeException(&quot;Expected &#39;barRef&#39; to be cleared&quot;);
243             }
244             // Now lets try to check handlers, and
245             // attempt to update the configuration again.
246             Properties previousProps  = properties.get(0);
247             int expectedHandlersCount = 1;
248             boolean checkHandlersOnParent = Boolean.parseBoolean(
249                     previousProps.getProperty(&quot;test.checkHandlersOnParent&quot;, &quot;true&quot;));
250             String checkHandlersOn = previousProps.getProperty(&quot;test.checkHandlersOn&quot;, null);
251             for (int i=1; i&lt;properties.size(); i++) {
252                 System.out.println(&quot;\n*** Reconfiguration with properties[&quot;+i+&quot;]\n&quot;);
253                 Properties nextProps = properties.get(i);
254                 boolean reconfigureHandlers = true;
255 
256                 if (checkHandlersOnParent) {
257                     assertEquals(expectedHandlersCount,
258                             fooChild.getParent().getHandlers().length,
259                             &quot;fooChild.getParent().getHandlers().length&quot;);
260                 }
261                 if (checkHandlersOn != null) {
262                     Logger loggerWithHandlers = LogManager.getLogManager().getLogger(checkHandlersOn);
263                     if (loggerWithHandlers == null) {
264                         throw new RuntimeException(&quot;Logger with handlers not found: &quot; + checkHandlersOn);
265                     }
266                     assertEquals(expectedHandlersCount,
267                             loggerWithHandlers.getHandlers().length,
268                             checkHandlersOn + &quot;.getHandlers().length&quot;);
269                 }
270 
271                 if (i == 4) {
272                     System.out.println(&quot;Last configuration...&quot;);
273                 }
274                 // Read configuration
275                 Configure.doPrivileged(() -&gt; Configure.updateConfigurationWith(nextProps, false));
276 
277                 expectedHandlersCount = reconfigureHandlers ? 1 : 0;
278                 checkHandlersOnParent = Boolean.parseBoolean(
279                     nextProps.getProperty(&quot;test.checkHandlersOnParent&quot;, &quot;true&quot;));
280                 checkHandlersOn = nextProps.getProperty(&quot;test.checkHandlersOn&quot;, null);
281 
282                 if (checkHandlersOnParent) {
283                     assertEquals(expectedHandlersCount,
284                         fooChild.getParent().getHandlers().length,
285                         &quot;fooChild.getParent().getHandlers().length&quot;);
286                 } else {
287                     assertEquals(0,
288                         fooChild.getParent().getHandlers().length,
289                         &quot;fooChild.getParent().getHandlers().length&quot;);
290                 }
291                 if (checkHandlersOn != null) {
292                     Logger loggerWithHandlers = LogManager.getLogManager().getLogger(checkHandlersOn);
293                     if (loggerWithHandlers == null) {
294                         throw new RuntimeException(&quot;Logger with handlers not found: &quot; + checkHandlersOn);
295                     }
296                     assertEquals(expectedHandlersCount,
297                             loggerWithHandlers.getHandlers().length,
298                             checkHandlersOn + &quot;.getHandlers().length&quot;);
299                 }
300             }
301         } catch (Throwable t) {
302             failed = t;
303         } finally {
304             final Throwable suppressed = failed;
305             Configure.doPrivileged(() -&gt; LogManager.getLogManager().reset());
306             Configure.doPrivileged(() -&gt; {
307                 try {
308                     StringBuilder builder = new StringBuilder();
309                     Files.list(Paths.get(userDir))
310                         .filter((f) -&gt; f.toString().contains(PREFIX))
311                         .filter((f) -&gt; f.toString().endsWith(&quot;.lck&quot;))
312                         .forEach((f) -&gt; {
313                                 builder.append(f.toString()).append(&#39;\n&#39;);
314                         });
315                     if (!builder.toString().isEmpty()) {
316                         throw new RuntimeException(&quot;Lock files not cleaned:\n&quot;
317                                 + builder.toString());
318                     }
319                 } catch(RuntimeException | Error x) {
320                     if (suppressed != null) x.addSuppressed(suppressed);
321                     throw x;
322                 } catch(Exception x) {
323                     if (suppressed != null) x.addSuppressed(suppressed);
324                     throw new RuntimeException(x);
325                 }
326             });
327             try {
328                 fooChild = null;
329                 System.out.println(&quot;Setting fooChild to: &quot; + fooChild);
330                 while ((ref2 = queue.poll()) == null) {
331                     System.gc();
332                     Thread.sleep(1000);
333                 }
334                 if (ref2 != fooRef) {
335                     throw new RuntimeException(&quot;Unexpected reference: &quot;
336                             + ref2 +&quot;\n\texpected: &quot; + fooRef);
337                 }
338                 if (ref2.get() != null) {
339                     throw new RuntimeException(&quot;Referent not cleared: &quot; + ref2.get());
340                 }
341                 System.out.println(&quot;Got fooRef after reset(), fooChild is &quot; + fooChild);
342            } catch (Throwable t) {
343                if (failed != null) t.addSuppressed(failed);
344                throw t;
345            }
346         }
347         if (failed != null) {
348             // should rarely happen...
349             throw new RuntimeException(failed);
350         }
351 
352     }
353 
354     public static void main(String... args) throws Exception {
355 
356 
357         if (args == null || args.length == 0) {
358             args = new String[] {
359                 TestCase.UNSECURE.name(),
360                 TestCase.SECURE.name(),
361             };
362         }
363 
364         try {
365             for (String testName : args) {
366                 TestCase test = TestCase.valueOf(testName);
367                 test.run(properties);
368             }
369         } finally {
370             if (userDirWritable) {
371                 Configure.doPrivileged(() -&gt; {
372                     // cleanup - delete files that have been created
373                     try {
374                         Files.list(Paths.get(userDir))
375                             .filter((f) -&gt; f.toString().contains(PREFIX))
376                             .forEach((f) -&gt; {
377                                 try {
378                                     System.out.println(&quot;deleting &quot; + f);
379                                     Files.delete(f);
380                                 } catch(Throwable t) {
381                                     System.err.println(&quot;Failed to delete &quot; + f + &quot;: &quot; + t);
382                                 }
383                             });
384                     } catch(Throwable t) {
385                         System.err.println(&quot;Cleanup failed to list files: &quot; + t);
386                         t.printStackTrace();
387                     }
388                 });
389             }
390         }
391     }
392 
393     static class Configure {
394         static Policy policy = null;
395         static final ThreadLocal&lt;AtomicBoolean&gt; allowAll = new ThreadLocal&lt;AtomicBoolean&gt;() {
396             @Override
397             protected AtomicBoolean initialValue() {
398                 return  new AtomicBoolean(false);
399             }
400         };
401         static void setUp(TestCase test, Properties propertyFile) {
402             switch (test) {
403                 case SECURE:
404                     if (policy == null &amp;&amp; System.getSecurityManager() != null) {
405                         throw new IllegalStateException(&quot;SecurityManager already set&quot;);
406                     } else if (policy == null) {
407                         policy = new SimplePolicy(TestCase.SECURE, allowAll);
408                         Policy.setPolicy(policy);
409                         System.setSecurityManager(new SecurityManager());
410                     }
411                     if (System.getSecurityManager() == null) {
412                         throw new IllegalStateException(&quot;No SecurityManager.&quot;);
413                     }
414                     if (policy == null) {
415                         throw new IllegalStateException(&quot;policy not configured&quot;);
416                     }
417                     break;
418                 case UNSECURE:
419                     if (System.getSecurityManager() != null) {
420                         throw new IllegalStateException(&quot;SecurityManager already set&quot;);
421                     }
422                     break;
423                 default:
424                     new InternalError(&quot;No such testcase: &quot; + test);
425             }
426             doPrivileged(() -&gt; {
427                 configureWith(propertyFile);
428             });
429         }
430 
431         static void configureWith(Properties propertyFile) {
432             try {
433                 ByteArrayOutputStream bytes = new ByteArrayOutputStream();
434                 propertyFile.store(bytes, propertyFile.getProperty(&quot;test.name&quot;));
435                 ByteArrayInputStream bais = new ByteArrayInputStream(bytes.toByteArray());
436                 LogManager.getLogManager().readConfiguration(bais);
437             } catch (IOException ex) {
438                 throw new RuntimeException(ex);
439             }
440         }
441 
442         static void updateConfigurationWith(Properties propertyFile, boolean append) {
443             try {
444                 ByteArrayOutputStream bytes = new ByteArrayOutputStream();
445                 propertyFile.store(bytes, propertyFile.getProperty(&quot;test.name&quot;));
446                 ByteArrayInputStream bais = new ByteArrayInputStream(bytes.toByteArray());
447                 Function&lt;String, BiFunction&lt;String,String,String&gt;&gt; remapper =
448                         append ? (x) -&gt; ((o, n) -&gt; n == null ? o : n)
449                                : (x) -&gt; ((o, n) -&gt; n);
450                 LogManager.getLogManager().updateConfiguration(bais, remapper);
451             } catch (IOException ex) {
452                 throw new RuntimeException(ex);
453             }
454         }
455 
456         static void doPrivileged(Runnable run) {
457             final boolean old = allowAll.get().getAndSet(true);
458             try {
459                 run.run();
460             } finally {
461                 allowAll.get().set(old);
462             }
463         }
464         static &lt;T&gt; T callPrivileged(Callable&lt;T&gt; call) throws Exception {
465             final boolean old = allowAll.get().getAndSet(true);
466             try {
467                 return call.call();
468             } finally {
469                 allowAll.get().set(old);
470             }
471         }
472     }
473 
474     @FunctionalInterface
475     public static interface FileHandlerSupplier {
476         public FileHandler test() throws Exception;
477     }
478 
479     static final class TestAssertException extends RuntimeException {
480         TestAssertException(String msg) {
481             super(msg);
482         }
483     }
484 
485     private static void assertEquals(long expected, long received, String msg) {
486         if (expected != received) {
487             throw new TestAssertException(&quot;Unexpected result for &quot; + msg
488                     + &quot;.\n\texpected: &quot; + expected
489                     +  &quot;\n\tactual:   &quot; + received);
490         } else {
491             System.out.println(&quot;Got expected &quot; + msg + &quot;: &quot; + received);
492         }
493     }
494 
495     final static class PermissionsBuilder {
496         final Permissions perms;
497         public PermissionsBuilder() {
498             this(new Permissions());
499         }
500         public PermissionsBuilder(Permissions perms) {
501             this.perms = perms;
502         }
503         public PermissionsBuilder add(Permission p) {
504             perms.add(p);
505             return this;
506         }
507         public PermissionsBuilder addAll(PermissionCollection col) {
508             if (col != null) {
509                 for (Enumeration&lt;Permission&gt; e = col.elements(); e.hasMoreElements(); ) {
510                     perms.add(e.nextElement());
511                 }
512             }
513             return this;
514         }
515         public Permissions toPermissions() {
516             final PermissionsBuilder builder = new PermissionsBuilder();
517             builder.addAll(perms);
518             return builder.perms;
519         }
520     }
521 
522     public static class SimplePolicy extends Policy {
523 
<a name="1" id="anc1"></a><span class="line-added">524         static final Policy DEFAULT_POLICY = Policy.getPolicy();</span>
<span class="line-added">525 </span>
526         final Permissions permissions;
527         final Permissions allPermissions;
528         final ThreadLocal&lt;AtomicBoolean&gt; allowAll; // actually: this should be in a thread locale
529         public SimplePolicy(TestCase test, ThreadLocal&lt;AtomicBoolean&gt; allowAll) {
530             this.allowAll = allowAll;
531             permissions = new Permissions();
532             permissions.add(new LoggingPermission(&quot;control&quot;, null));
533             permissions.add(new FilePermission(PREFIX+&quot;.lck&quot;, &quot;read,write,delete&quot;));
534             permissions.add(new FilePermission(PREFIX, &quot;read,write&quot;));
535 
536             // these are used for configuring the test itself...
537             allPermissions = new Permissions();
538             allPermissions.add(new java.security.AllPermission());
539 
540         }
541 
542         @Override
543         public boolean implies(ProtectionDomain domain, Permission permission) {
544             if (allowAll.get().get()) return allPermissions.implies(permission);
<a name="2" id="anc2"></a><span class="line-modified">545             return permissions.implies(permission) || DEFAULT_POLICY.implies(domain, permission);</span>
546         }
547 
548         @Override
549         public PermissionCollection getPermissions(CodeSource codesource) {
550             return new PermissionsBuilder().addAll(allowAll.get().get()
551                     ? allPermissions : permissions).toPermissions();
552         }
553 
554         @Override
555         public PermissionCollection getPermissions(ProtectionDomain domain) {
556             return new PermissionsBuilder().addAll(allowAll.get().get()
557                     ? allPermissions : permissions).toPermissions();
558         }
559     }
560 
561 }
<a name="3" id="anc3"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="3" type="hidden" />
</body>
</html>
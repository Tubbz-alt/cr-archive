<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old test/jdk/java/util/logging/LogManager/Configuration/updateConfiguration/SimpleUpdateConfigurationTest.java</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2015, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 import java.io.ByteArrayInputStream;
 24 import java.io.ByteArrayOutputStream;
 25 import java.io.FileOutputStream;
 26 import java.io.FilePermission;
 27 import java.io.IOException;
 28 import java.nio.file.Files;
 29 import java.nio.file.Path;
 30 import java.nio.file.Paths;
 31 import java.security.CodeSource;
 32 import java.security.Permission;
 33 import java.security.PermissionCollection;
 34 import java.security.Permissions;
 35 import java.security.Policy;
 36 import java.security.ProtectionDomain;
 37 import java.util.Arrays;
 38 import java.util.Enumeration;
 39 import java.util.Objects;
 40 import java.util.Properties;
 41 import java.util.PropertyPermission;
 42 import java.util.concurrent.Callable;
 43 import java.util.concurrent.atomic.AtomicBoolean;
 44 import java.util.concurrent.atomic.AtomicLong;
 45 import java.util.function.BiFunction;
 46 import java.util.function.Function;
 47 import java.util.logging.Handler;
 48 import java.util.logging.Level;
 49 import java.util.logging.LogManager;
 50 import java.util.logging.LogRecord;
 51 import java.util.logging.Logger;
 52 import java.util.logging.LoggingPermission;
 53 
 54 /**
 55  * @test
 56  * @bug 8033661
 57  * @summary tests LogManager.updateConfiguration(Function) method
 58  * @run main/othervm SimpleUpdateConfigurationTest UNSECURE
 59  * @run main/othervm SimpleUpdateConfigurationTest SECURE
 60  * @author danielfuchs
 61  */
 62 public class SimpleUpdateConfigurationTest {
 63 
 64     /**
 65      * We will test updateConfiguration in
 66      * two configurations:
 67      * UNSECURE: No security manager.
 68      * SECURE: With the security manager present - and the required
 69      *         permissions granted.
 70      */
 71     public static enum TestCase {
 72         UNSECURE, SECURE;
 73         public void execute(Runnable run) {
 74             System.out.println(&quot;Running test case: &quot; + name());
 75             try {
 76                Configure.setUp(this);
 77                Configure.doPrivileged(run, SimplePolicy.allowControl);
 78             } finally {
 79                Configure.doPrivileged(() -&gt; {
 80                    try {
 81                        setSystemProperty(&quot;java.util.logging.config.file&quot;, null);
 82                        LogManager.getLogManager().readConfiguration();
 83                        System.gc();
 84                    } catch (Exception x) {
 85                        throw new RuntimeException(x);
 86                    }
 87                }, SimplePolicy.allowAll);
 88             }
 89         }
 90     }
 91 
 92     public static class MyHandler extends Handler {
 93         static final AtomicLong seq = new AtomicLong();
 94         long count = seq.incrementAndGet();
 95 
 96         @Override
 97         public void publish(LogRecord record) {
 98         }
 99 
100         @Override
101         public void flush() {
102         }
103 
104         @Override
105         public void close() throws SecurityException {
106         }
107 
108         @Override
109         public String toString() {
110             return super.toString() + &quot;(&quot;+count+&quot;)&quot;;
111         }
112 
113     }
114 
115     static String storePropertyToFile(String name, Properties props)
116         throws Exception {
117         return Configure.callPrivileged(() -&gt; {
118             String scratch = System.getProperty(&quot;user.dir&quot;, &quot;.&quot;);
119             Path p = Paths.get(scratch, name);
120             try (FileOutputStream fos = new FileOutputStream(p.toFile())) {
121                 props.store(fos, name);
122             }
123             return p.toString();
124         }, SimplePolicy.allowAll);
125     }
126 
127     static void setSystemProperty(String name, String value)
128         throws Exception {
129         Configure.doPrivileged(() -&gt; {
130             if (value == null)
131                 System.clearProperty(name);
132             else
133                 System.setProperty(name, value);
134         }, SimplePolicy.allowAll);
135     }
136 
137     static String trim(String value) {
138         return value == null ? null : value.trim();
139     }
140 
141 
142     /**
143      * Tests one of the configuration defined above.
144      * &lt;p&gt;
145      * This is the main test method (the rest is infrastructure).
146      */
147     static void testUpdateConfiguration() {
148         String configFile = null;
149         try {
150             // manager initialized with default configuration.
151             LogManager manager = LogManager.getLogManager();
152 
153             // Test default configuration. It should not have
154             // any value for &quot;com.foo.level&quot; and &quot;com.foo.handlers&quot;
155             assertEquals(null, manager.getProperty(&quot;com.foo.level&quot;),
156                 &quot;com.foo.level in default configuration&quot;);
157             assertEquals(null, manager.getProperty(&quot;com.foo.handlers&quot;),
158                 &quot;com.foo.handlers in default configuration&quot;);
159 
160             // Create a logging configuration file that contains
161             // com.foo.level=FINEST
162             // and set &quot;java.util.logging.config.file&quot; to this file.
163             Properties props = new Properties();
164             props.setProperty(&quot;com.foo.level&quot;, &quot;FINEST&quot;);
165             configFile = storePropertyToFile(&quot;config1&quot;, props);
166             setSystemProperty(&quot;java.util.logging.config.file&quot;, configFile);
167 
168             // Update configuration with configFile
169             // then test that the new configuration has
170             // com.foo.level=FINEST
171             // and nothing for com.foo.handlers
172             manager.updateConfiguration(null);
173             assertEquals(&quot;FINEST&quot;, manager.getProperty(&quot;com.foo.level&quot;),
174                 &quot;com.foo.level in &quot; + configFile);
175             assertEquals(null, manager.getProperty(&quot;com.foo.handlers&quot;),
176                 &quot;com.foo.handlers in &quot; + configFile);
177 
178             // clear (&quot;java.util.logging.config.file&quot; system property,
179             // and call updateConfiguration again.
180             // check that the new configuration no longer has
181             // any value for com.foo.level, and still no value
182             // for com.foo.handlers
183             setSystemProperty(&quot;java.util.logging.config.file&quot;, null);
184             manager.updateConfiguration(null);
185             assertEquals(null, manager.getProperty(&quot;com.foo.level&quot;),
186                     &quot;com.foo.level in default configuration&quot;);
187             assertEquals(null, manager.getProperty(&quot;com.foo.handlers&quot;),
188                 &quot;com.foo.handlers in default configuration&quot;);
189 
190             // creates the com.foo logger, check it has
191             // the default config: no level, and no handlers
192             final Logger logger = Logger.getLogger(&quot;com.foo&quot;);
193             assertEquals(null, logger.getLevel(),
194                 &quot;Logger.getLogger(\&quot;com.foo\&quot;).getLevel()&quot;);
195             assertDeepEquals(new Handler[0], logger.getHandlers(),
196                     &quot;Logger.getLogger(\&quot;com.foo\&quot;).getHandlers()&quot;);
197 
198             // set &quot;java.util.logging.config.file&quot; to configFile and
199             // call updateConfiguration.
200             // check that the configuration has
201             // com.foo.level=FINEST
202             // and nothing for com.foo.handlers
203             // check that the logger has now a FINEST level and still
204             // no handlers
205             setSystemProperty(&quot;java.util.logging.config.file&quot;, configFile);
206             manager.updateConfiguration(null);
207             assertEquals(&quot;FINEST&quot;, manager.getProperty(&quot;com.foo.level&quot;),
208                 &quot;com.foo.level in &quot; + configFile);
209             assertEquals(Level.FINEST, logger.getLevel(),
210                 &quot;Logger.getLogger(\&quot;com.foo\&quot;).getLevel()&quot;);
211             assertDeepEquals(new Handler[0], logger.getHandlers(),
212                     &quot;Logger.getLogger(\&quot;com.foo\&quot;).getHandlers()&quot;);
213             assertEquals(null, manager.getProperty(&quot;com.foo.handlers&quot;),
214                 &quot;com.foo.handlers in &quot; + configFile);
215 
216             // Calls updateConfiguration with a lambda whose effect should
217             // be to set the FINER level on the &quot;com.foo&quot; logger.
218             // Check that the new configuration has
219             // com.foo.level=FINER
220             // and nothing for com.foo.handlers
221             // check that the logger has now a FINER level and still
222             // no handlers
223             manager.updateConfiguration(
224                     (k) -&gt; (&quot;com.foo.level&quot;.equals(k) ? (o, n) -&gt; &quot;FINER&quot; : (o, n) -&gt; n));
225             assertEquals(&quot;FINER&quot;, manager.getProperty(&quot;com.foo.level&quot;),
226                 &quot;com.foo.level set to FINER by updateConfiguration&quot;);
227             assertEquals(Level.FINER, logger.getLevel(),
228                 &quot;Logger.getLogger(\&quot;com.foo\&quot;).getLevel()&quot;);
229             assertDeepEquals(new Handler[0], logger.getHandlers(),
230                     &quot;Logger.getLogger(\&quot;com.foo\&quot;).getHandlers()&quot;);
231             assertEquals(null, manager.getProperty(&quot;com.foo.handlers&quot;),
232                 &quot;com.foo.handlers in &quot; + configFile);
233 
234             // Calls updateConfiguration with a lambda whose effect is a noop.
235             // This should not change the configuration, so
236             // check that the new configuration still has
237             // com.foo.level=FINER
238             // and nothing for com.foo.handlers
239             // check that the logger still has FINER level and still
240             // no handlers
241             manager.updateConfiguration(
242                     (k) -&gt; ((o, n) -&gt; o));
243             assertEquals(&quot;FINER&quot;, manager.getProperty(&quot;com.foo.level&quot;),
244                 &quot;com.foo.level preserved by updateConfiguration&quot;);
245             assertEquals(Level.FINER, logger.getLevel(),
246                 &quot;Logger.getLogger(\&quot;com.foo\&quot;).getLevel()&quot;);
247             assertDeepEquals(new Handler[0], logger.getHandlers(),
248                     &quot;Logger.getLogger(\&quot;com.foo\&quot;).getHandlers()&quot;);
249             assertEquals(null, manager.getProperty(&quot;com.foo.handlers&quot;),
250                 &quot;com.foo.handlers in &quot; + configFile);
251 
252             // Calls updateConfiguration with a lambda whose effect is to
253             // take all values from the new configuration.
254             // This should update the configuration to what is in configFile, so
255             // check that the new configuration has
256             // com.foo.level=FINEST
257             // and nothing for com.foo.handlers
258             // check that the logger now has FINEST level and still
259             // no handlers
260             manager.updateConfiguration(
261                     (k) -&gt; ((o, n) -&gt; n));
262             assertEquals(&quot;FINEST&quot;, manager.getProperty(&quot;com.foo.level&quot;),
263                 &quot;com.foo.level updated by updateConfiguration&quot;);
264             assertEquals(Level.FINEST, logger.getLevel(),
265                 &quot;Logger.getLogger(\&quot;com.foo\&quot;).getLevel()&quot;);
266             assertDeepEquals(new Handler[0], logger.getHandlers(),
267                     &quot;Logger.getLogger(\&quot;com.foo\&quot;).getHandlers()&quot;);
268             assertEquals(null, manager.getProperty(&quot;com.foo.handlers&quot;),
269                 &quot;com.foo.handlers in &quot; + configFile);
270 
271             // now set a handler on the com.foo logger.
272             MyHandler h = new MyHandler();
273             logger.addHandler(h);
274             assertDeepEquals(new Handler[] {h}, logger.getHandlers(),
275                     &quot;Logger.getLogger(\&quot;com.foo\&quot;).getHandlers()&quot;);
276 
277             // Calls updateConfiguration with a lambda whose effect should
278             // be to set the FINER level on the &quot;com.foo&quot; logger, and
279             // take the value from configFile for everything else.
280             // Check that the new configuration has
281             // com.foo.level=FINER
282             // and nothing for com.foo.handlers
283             // check that the logger has now a FINER level, but that its
284             // handlers are still present and have not been reset
285             // since neither the old nor new configuration defined them.
286             manager.updateConfiguration(
287                     (k) -&gt; (&quot;com.foo.level&quot;.equals(k) ? (o, n) -&gt; &quot;FINER&quot; : (o, n) -&gt; n));
288             assertEquals(&quot;FINER&quot;, manager.getProperty(&quot;com.foo.level&quot;),
289                 &quot;com.foo.level set to FINER by updateConfiguration&quot;);
290             assertEquals(Level.FINER, logger.getLevel(),
291                 &quot;Logger.getLogger(\&quot;com.foo\&quot;).getLevel()&quot;);
292             assertDeepEquals(new Handler[] {h}, logger.getHandlers(),
293                     &quot;Logger.getLogger(\&quot;com.foo\&quot;).getHandlers()&quot;);
294             assertEquals(null, manager.getProperty(&quot;com.foo.handlers&quot;),
295                 &quot;com.foo.handlers in &quot; + configFile);
296 
297             // now add some configuration for com.foo.handlers in the
298             // configuration file.
299             props.setProperty(&quot;com.foo.handlers&quot;, MyHandler.class.getName());
300             storePropertyToFile(&quot;config1&quot;, props);
301 
302             // we didn&#39;t call updateConfiguration, so just changing the
303             // content of the file should have had no no effect yet.
304             assertEquals(&quot;FINER&quot;, manager.getProperty(&quot;com.foo.level&quot;),
305                 &quot;com.foo.level set to FINER by updateConfiguration&quot;);
306             assertEquals(Level.FINER, logger.getLevel(),
307                 &quot;Logger.getLogger(\&quot;com.foo\&quot;).getLevel()&quot;);
308             assertEquals(null,
309                     manager.getProperty(&quot;com.foo.handlers&quot;),
310                     &quot;manager.getProperty(\&quot;com.foo.handlers\&quot;)&quot;);
311             assertDeepEquals(new Handler[] {h}, logger.getHandlers(),
312                     &quot;Logger.getLogger(\&quot;com.foo\&quot;).getHandlers()&quot;);
313 
314             // Calls updateConfiguration with a lambda whose effect is a noop.
315             // This should not change the current configuration, so
316             // check that the new configuration still has
317             // com.foo.level=FINER
318             // and nothing for com.foo.handlers
319             // check that the logger still has FINER level and still
320             // has its handlers and that they haven&#39;t been reset.
321             manager.updateConfiguration((k) -&gt; ((o, n) -&gt; o));
322             assertEquals(&quot;FINER&quot;, manager.getProperty(&quot;com.foo.level&quot;),
323                 &quot;com.foo.level set to FINER by updateConfiguration&quot;);
324             assertEquals(Level.FINER, logger.getLevel(),
325                 &quot;Logger.getLogger(\&quot;com.foo\&quot;).getLevel()&quot;);
326             assertEquals(null,
327                     manager.getProperty(&quot;com.foo.handlers&quot;),
328                     &quot;manager.getProperty(\&quot;com.foo.handlers\&quot;)&quot;);
329             assertDeepEquals(new Handler[] {h}, logger.getHandlers(),
330                     &quot;Logger.getLogger(\&quot;com.foo\&quot;).getHandlers()&quot;);
331 
332             // Calls updateConfiguration with a lambda whose effect is to
333             // take all values from the new configuration.
334             // This should update the configuration to what is in configFile, so
335             // check that the new configuration has
336             // com.foo.level=FINEST
337             // com.foo.handlers=SimpleUpdateConfigurationTest$MyHandler
338             // check that the logger now has FINEST level
339             // and a new handler instance, since the old config
340             // had no handlers for com.foo and the new config has one.
341             manager.updateConfiguration((k) -&gt; ((o, n) -&gt; n));
342             assertEquals(&quot;FINEST&quot;, manager.getProperty(&quot;com.foo.level&quot;),
343                 &quot;com.foo.level updated by updateConfiguration&quot;);
344             assertEquals(Level.FINEST, logger.getLevel(),
345                 &quot;Logger.getLogger(\&quot;com.foo\&quot;).getLevel()&quot;);
346             assertEquals(MyHandler.class.getName(),
347                     manager.getProperty(&quot;com.foo.handlers&quot;),
348                     &quot;manager.getProperty(\&quot;com.foo.handlers\&quot;)&quot;);
349             Handler[] loggerHandlers = logger.getHandlers().clone();
350             assertEquals(1, loggerHandlers.length,
351                     &quot;Logger.getLogger(\&quot;com.foo\&quot;).getHandlers().length&quot;);
352             assertEquals(MyHandler.class, loggerHandlers[0].getClass(),
353                     &quot;Logger.getLogger(\&quot;com.foo\&quot;).getHandlers()[0].getClass()&quot;);
354             assertEquals(h.count + 1, ((MyHandler)logger.getHandlers()[0]).count,
355                     &quot;Logger.getLogger(\&quot;com.foo\&quot;).getHandlers()[0].count&quot;);
356 
357             // Calls updateConfiguration with a lambda whose effect is a noop.
358             // This should not change the current configuration, so
359             // check that the new configuration still has
360             // com.foo.level=FINEST
361             // com.foo.handlers=SimpleUpdateConfigurationTest$MyHandler
362             // check that the logger still has FINEST level and still
363             // has its handlers and that they haven&#39;t been reset.
364             manager.updateConfiguration((k) -&gt; ((o, n) -&gt; o));
365             assertDeepEquals(loggerHandlers, logger.getHandlers(),
366                     &quot;Logger.getLogger(\&quot;com.foo\&quot;).getHandlers()&quot;);
367             assertEquals(&quot;FINEST&quot;, manager.getProperty(&quot;com.foo.level&quot;),
368                 &quot;com.foo.level updated by updateConfiguration&quot;);
369             assertEquals(Level.FINEST, logger.getLevel(),
370                 &quot;Logger.getLogger(\&quot;com.foo\&quot;).getLevel()&quot;);
371             assertEquals(MyHandler.class.getName(),
372                     manager.getProperty(&quot;com.foo.handlers&quot;),
373                     &quot;manager.getProperty(\&quot;com.foo.handlers\&quot;)&quot;);
374 
375             // Calls updateConfiguration with a lambda whose effect is to
376             // take all values from the new configuration.
377             // Because the content of the configFile hasn&#39;t changed, then
378             // it should also be a noop.
379             // check that the new configuration still has
380             // com.foo.level=FINEST
381             // com.foo.handlers=SimpleUpdateConfigurationTest$MyHandler
382             // check that the logger still has FINEST level and still
383             // has its handlers and that they haven&#39;t been reset.
384             manager.updateConfiguration((k) -&gt; ((o, n) -&gt; n));
385             assertDeepEquals(loggerHandlers, logger.getHandlers(),
386                     &quot;Logger.getLogger(\&quot;com.foo\&quot;).getHandlers()&quot;);
387             assertEquals(&quot;FINEST&quot;, manager.getProperty(&quot;com.foo.level&quot;),
388                 &quot;com.foo.level updated by updateConfiguration&quot;);
389             assertEquals(Level.FINEST, logger.getLevel(),
390                 &quot;Logger.getLogger(\&quot;com.foo\&quot;).getLevel()&quot;);
391             assertEquals(MyHandler.class.getName(),
392                     manager.getProperty(&quot;com.foo.handlers&quot;),
393                     &quot;manager.getProperty(\&quot;com.foo.handlers\&quot;)&quot;);
394 
395             // Calls updateConfiguration with a null lambda, whose effect is to
396             // take all values from the new configuration.
397             // Because the content of the configFile hasn&#39;t changed, then
398             // it should also be a noop.
399             // check that the new configuration still has
400             // com.foo.level=FINEST
401             // com.foo.handlers=SimpleUpdateConfigurationTest$MyHandler
402             // check that the logger still has FINEST level and still
403             // has its handlers and that they haven&#39;t been reset.
404             manager.updateConfiguration((k) -&gt; ((o, n) -&gt; n));
405             assertDeepEquals(loggerHandlers, logger.getHandlers(),
406                     &quot;Logger.getLogger(\&quot;com.foo\&quot;).getHandlers()&quot;);
407             assertEquals(&quot;FINEST&quot;, manager.getProperty(&quot;com.foo.level&quot;),
408                 &quot;com.foo.level updated by updateConfiguration&quot;);
409             assertEquals(Level.FINEST, logger.getLevel(),
410                 &quot;Logger.getLogger(\&quot;com.foo\&quot;).getLevel()&quot;);
411             assertEquals(MyHandler.class.getName(),
412                     manager.getProperty(&quot;com.foo.handlers&quot;),
413                     &quot;manager.getProperty(\&quot;com.foo.handlers\&quot;)&quot;);
414 
415             // no remove com.foo.handlers=SimpleUpdateConfigurationTest$MyHandler
416             // from the configuration file.
417             props.remove(&quot;com.foo.handlers&quot;);
418             storePropertyToFile(&quot;config1&quot;, props);
419 
420             // Calls updateConfiguration with a lambda whose effect is a noop.
421             // This should not change the current configuration, so
422             // check that the new configuration still has
423             // com.foo.level=FINEST
424             // com.foo.handlers=SimpleUpdateConfigurationTest$MyHandler
425             // check that the logger still has FINEST level and still
426             // has its handlers and that they haven&#39;t been reset.
427             manager.updateConfiguration((k) -&gt; ((o, n) -&gt; o));
428             assertDeepEquals(loggerHandlers, logger.getHandlers(),
429                     &quot;Logger.getLogger(\&quot;com.foo\&quot;).getHandlers()&quot;);
430             assertEquals(&quot;FINEST&quot;, manager.getProperty(&quot;com.foo.level&quot;),
431                 &quot;com.foo.level updated by updateConfiguration&quot;);
432             assertEquals(Level.FINEST, logger.getLevel(),
433                 &quot;Logger.getLogger(\&quot;com.foo\&quot;).getLevel()&quot;);
434             assertEquals(MyHandler.class.getName(),
435                     manager.getProperty(&quot;com.foo.handlers&quot;),
436                     &quot;manager.getProperty(\&quot;com.foo.handlers\&quot;)&quot;);
437 
438             // Calls updateConfiguration with a lambda whose effect is to
439             // take all values from the new configuration.
440             // This should update the configuration to what is in configFile, so
441             // check that the new configuration has
442             // com.foo.level=FINEST
443             // and nothing for com.foo.handlers
444             // check that the logger still has FINEST level
445             // and no handlers, since the old config
446             // had an handler for com.foo and the new config doesn&#39;t.
447             manager.updateConfiguration((k) -&gt; ((o, n) -&gt; n));
448             assertDeepEquals(new Handler[0], logger.getHandlers(),
449                     &quot;Logger.getLogger(\&quot;com.foo\&quot;).getHandlers()&quot;);
450             assertEquals(&quot;FINEST&quot;, manager.getProperty(&quot;com.foo.level&quot;),
451                 &quot;com.foo.level updated by updateConfiguration&quot;);
452             assertEquals(Level.FINEST, logger.getLevel(),
453                 &quot;Logger.getLogger(\&quot;com.foo\&quot;).getLevel()&quot;);
454             assertEquals(null,
455                     manager.getProperty(&quot;com.foo.handlers&quot;),
456                     &quot;manager.getProperty(\&quot;com.foo.handlers\&quot;)&quot;);
457 
458 
459         } catch (RuntimeException | Error r) {
460             throw r;
461         } catch (Exception x) {
462             throw new RuntimeException(x);
463         } finally {
464             if (configFile != null) {
465                 // cleanup
466                 final String file = configFile;
467                 Configure.doPrivileged(() -&gt; {
468                     try {
469                         Files.delete(Paths.get(file));
470                     } catch (RuntimeException | Error r) {
471                         throw r;
472                     } catch (Exception x) {
473                         throw new RuntimeException(x);
474                     }
475                 }, SimplePolicy.allowAll);
476             }
477         }
478     }
479 
480     public static void main(String[] args) throws Exception {
481         if (args == null || args.length == 0) {
482             args = new String[] { &quot;UNSECURE&quot;, &quot;SECURE&quot; };
483         }
484         for (String test : args) {
485             TestCase.valueOf(test).execute(SimpleUpdateConfigurationTest::testUpdateConfiguration);
486         }
487     }
488 
489     static class Configure {
490         static Policy policy = null;
491         static void setUp(TestCase test) {
492             switch (test) {
493                 case SECURE:
494                     if (policy == null &amp;&amp; System.getSecurityManager() != null) {
495                         throw new IllegalStateException(&quot;SecurityManager already set&quot;);
496                     } else if (policy == null) {
497                         policy = new SimplePolicy(TestCase.SECURE);
498                         Policy.setPolicy(policy);
499                         System.setSecurityManager(new SecurityManager());
500                     }
501                     if (System.getSecurityManager() == null) {
502                         throw new IllegalStateException(&quot;No SecurityManager.&quot;);
503                     }
504                     if (policy == null) {
505                         throw new IllegalStateException(&quot;policy not configured&quot;);
506                     }
507                     break;
508                 case UNSECURE:
509                     if (System.getSecurityManager() != null) {
510                         throw new IllegalStateException(&quot;SecurityManager already set&quot;);
511                     }
512                     break;
513                 default:
514                     throw new InternalError(&quot;No such testcase: &quot; + test);
515             }
516         }
517 
518         static void updateConfigurationWith(Properties propertyFile,
519                 Function&lt;String,BiFunction&lt;String,String,String&gt;&gt; remapper) {
520             try {
521                 ByteArrayOutputStream bytes = new ByteArrayOutputStream();
522                 propertyFile.store(bytes, propertyFile.getProperty(&quot;test.name&quot;));
523                 ByteArrayInputStream bais = new ByteArrayInputStream(bytes.toByteArray());
524                 LogManager.getLogManager().updateConfiguration(bais, remapper);
525             } catch (IOException ex) {
526                 throw new RuntimeException(ex);
527             }
528         }
529 
530         static void doPrivileged(Runnable run, ThreadLocal&lt;AtomicBoolean&gt; granter) {
531             final boolean old = granter.get().getAndSet(true);
532             try {
533                 run.run();
534             } finally {
535                 granter.get().set(old);
536             }
537         }
538         static &lt;T&gt; T callPrivileged(Callable&lt;T&gt; call,
539                 ThreadLocal&lt;AtomicBoolean&gt; granter) throws Exception {
540             final boolean old = granter.get().getAndSet(true);
541             try {
542                 return call.call();
543             } finally {
544                 granter.get().set(old);
545             }
546         }
547     }
548 
549     static final class TestAssertException extends RuntimeException {
550         TestAssertException(String msg) {
551             super(msg);
552         }
553     }
554 
555     private static void assertEquals(long expected, long received, String msg) {
556         if (expected != received) {
557             throw new TestAssertException(&quot;Unexpected result for &quot; + msg
558                     + &quot;.\n\texpected: &quot; + expected
559                     +  &quot;\n\tactual:   &quot; + received);
560         } else {
561             System.out.println(&quot;Got expected &quot; + msg + &quot;: &quot; + received);
562         }
563     }
564 
565     private static void assertEquals(String expected, String received, String msg) {
566         if (!Objects.equals(expected, received)) {
567             throw new TestAssertException(&quot;Unexpected result for &quot; + msg
568                     + &quot;.\n\texpected: &quot; + expected
569                     +  &quot;\n\tactual:   &quot; + received);
570         } else {
571             System.out.println(&quot;Got expected &quot; + msg + &quot;: &quot; + received);
572         }
573     }
574 
575     private static void assertEquals(Object expected, Object received, String msg) {
576         if (!Objects.equals(expected, received)) {
577             throw new TestAssertException(&quot;Unexpected result for &quot; + msg
578                     + &quot;.\n\texpected: &quot; + expected
579                     +  &quot;\n\tactual:   &quot; + received);
580         } else {
581             System.out.println(&quot;Got expected &quot; + msg + &quot;: &quot; + received);
582         }
583     }
584 
585     public static String deepToString(Object o) {
586         if (o == null) {
587             return &quot;null&quot;;
588         } else if (o.getClass().isArray()) {
589             String s;
590             if (o instanceof Object[])
591                 s = Arrays.deepToString((Object[]) o);
592             else if (o instanceof byte[])
593                 s = Arrays.toString((byte[]) o);
594             else if (o instanceof short[])
595                 s = Arrays.toString((short[]) o);
596             else if (o instanceof int[])
597                 s = Arrays.toString((int[]) o);
598             else if (o instanceof long[])
599                 s = Arrays.toString((long[]) o);
600             else if (o instanceof char[])
601                 s = Arrays.toString((char[]) o);
602             else if (o instanceof float[])
603                 s = Arrays.toString((float[]) o);
604             else if (o instanceof double[])
605                 s = Arrays.toString((double[]) o);
606             else if (o instanceof boolean[])
607                 s = Arrays.toString((boolean[]) o);
608             else
609                 s = o.toString();
610             return s;
611         } else {
612             return o.toString();
613         }
614     }
615 
616     private static void assertDeepEquals(Object expected, Object received, String msg) {
617         if (!Objects.deepEquals(expected, received)) {
618             throw new TestAssertException(&quot;Unexpected result for &quot; + msg
619                     + &quot;.\n\texpected: &quot; + deepToString(expected)
620                     +  &quot;\n\tactual:   &quot; + deepToString(received));
621         } else {
622             System.out.println(&quot;Got expected &quot; + msg + &quot;: &quot; + deepToString(received));
623         }
624     }
625 
626     final static class PermissionsBuilder {
627         final Permissions perms;
628         public PermissionsBuilder() {
629             this(new Permissions());
630         }
631         public PermissionsBuilder(Permissions perms) {
632             this.perms = perms;
633         }
634         public PermissionsBuilder add(Permission p) {
635             perms.add(p);
636             return this;
637         }
638         public PermissionsBuilder addAll(PermissionCollection col) {
639             if (col != null) {
640                 for (Enumeration&lt;Permission&gt; e = col.elements(); e.hasMoreElements(); ) {
641                     perms.add(e.nextElement());
642                 }
643             }
644             return this;
645         }
646         public Permissions toPermissions() {
647             final PermissionsBuilder builder = new PermissionsBuilder();
648             builder.addAll(perms);
649             return builder.perms;
650         }
651     }
652 
653     public static class SimplePolicy extends Policy {
654 
655         final Permissions basic;
656         final Permissions control;
657         final Permissions all;
658         public final static ThreadLocal&lt;AtomicBoolean&gt; allowAll =
659                 new ThreadLocal&lt;AtomicBoolean&gt;() {
660             @Override
661             protected AtomicBoolean initialValue() {
662                 return new AtomicBoolean();
663             }
664         };
665         public final static ThreadLocal&lt;AtomicBoolean&gt; allowControl =
666                 new ThreadLocal&lt;AtomicBoolean&gt;() {
667             @Override
668             protected AtomicBoolean initialValue() {
669                 return new AtomicBoolean();
670             }
671         };
672         public SimplePolicy(TestCase test) {
673             basic = new Permissions();
674             control = new Permissions();
675             control.add(new LoggingPermission(&quot;control&quot;, null));
676 
677             // These permissions are required to call updateConfiguration(Function)
678             control.add(new PropertyPermission(&quot;java.util.logging.config.file&quot;, &quot;read&quot;));
679             control.add(new PropertyPermission(&quot;java.home&quot;, &quot;read&quot;));
680             control.add(new FilePermission(
681                     Paths.get(System.getProperty(&quot;user.dir&quot;, &quot;.&quot;),&quot;-&quot;).toString(), &quot;read&quot;));
682             control.add(new FilePermission(
683                     Paths.get(System.getProperty(&quot;java.home&quot;),&quot;conf&quot;,&quot;-&quot;).toString(), &quot;read&quot;));
684 
685             // these are used for configuring the test itself...
686             all = new Permissions();
687             all.add(new java.security.AllPermission());
688 
689         }
690 
691         @Override
692         public boolean implies(ProtectionDomain domain, Permission permission) {
693             return getPermissions(domain).implies(permission);
694         }
695 
696         public PermissionCollection permissions() {
697             PermissionsBuilder builder = new PermissionsBuilder();
698             if (allowAll.get().get()) {
699                 builder.addAll(all);
700             } else {
701                 builder.addAll(basic);
702                 if (allowControl.get().get()) {
703                     builder.addAll(control);
704                 }
705             }
706             return builder.toPermissions();
707         }
708 
709         @Override
710         public PermissionCollection getPermissions(CodeSource codesource) {
711             return permissions();
712         }
713 
714         @Override
715         public PermissionCollection getPermissions(ProtectionDomain domain) {
716             return permissions();
717         }
718     }
719 
720 }
    </pre>
  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames test/jdk/java/util/TimeZone/TimeZoneTest.java</title>
    <link rel="stylesheet" href="../../../../../style.css" />
    <script type="text/javascript" src="../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
<a name="1" id="anc1"></a><span class="line-modified">  2  * Copyright (c) 1997, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 /*
 25  * @test
 26  * @bug 4028006 4044013 4096694 4107276 4107570 4112869 4130885 7039469 7126465 7158483
 27  *      8008577 8077685 8098547 8133321 8138716 8148446 8151876 8159684 8166875 8181157
<a name="2" id="anc2"></a><span class="line-added"> 28  *      8228469</span>
 29  * @modules java.base/sun.util.resources
 30  * @library /java/text/testlib
 31  * @summary test TimeZone
 32  */
 33 
 34 import java.io.*;
 35 import java.text.*;
 36 import java.util.*;
 37 import sun.util.resources.LocaleData;
 38 
 39 public class TimeZoneTest extends IntlTest
 40 {
 41     static final int millisPerHour = 3600000;
 42 
 43     public static void main(String[] args) throws Exception {
 44         new TimeZoneTest().run(args);
 45     }
 46 
 47     /**
 48      * Bug 4130885
 49      * Certain short zone IDs, used since 1.1.x, are incorrect.
 50      *
 51      * The worst of these is:
 52      *
 53      * &quot;CAT&quot; (Central African Time) should be GMT+2:00, but instead returns a
 54      * zone at GMT-1:00. The zone at GMT-1:00 should be called EGT, CVT, EGST,
 55      * or AZOST, depending on which zone is meant, but in no case is it CAT.
 56      *
 57      * Other wrong zone IDs:
 58      *
 59      * ECT (European Central Time) GMT+1:00: ECT is Ecuador Time,
 60      * GMT-5:00. European Central time is abbreviated CEST.
 61      *
 62      * SST (Solomon Island Time) GMT+11:00. SST is actually Samoa Standard Time,
 63      * GMT-11:00. Solomon Island time is SBT.
 64      *
 65      * NST (New Zealand Time) GMT+12:00. NST is the abbreviation for
 66      * Newfoundland Standard Time, GMT-3:30. New Zealanders use NZST.
 67      *
 68      * AST (Alaska Standard Time) GMT-9:00. [This has already been noted in
 69      * another bug.] It should be &quot;AKST&quot;. AST is Atlantic Standard Time,
 70      * GMT-4:00.
 71      *
 72      * PNT (Phoenix Time) GMT-7:00. PNT usually means Pitcairn Time,
 73      * GMT-8:30. There is no standard abbreviation for Phoenix time, as distinct
 74      * from MST with daylight savings.
 75      *
 76      * In addition to these problems, a number of zones are FAKE. That is, they
 77      * don&#39;t match what people use in the real world.
 78      *
 79      * FAKE zones:
 80      *
 81      * EET (should be EEST)
 82      * ART (should be EET)
 83      * MET (should be IRST)
 84      * NET (should be AMST)
 85      * PLT (should be PKT)
 86      * BST (should be BDT)
 87      * VST (should be ICT)
 88      * CTT (should be CST) +
 89      * ACT (should be CST) +
 90      * AET (should be EST) +
 91      * MIT (should be WST) +
 92      * IET (should be EST) +
 93      * PRT (should be AST) +
 94      * CNT (should be NST)
 95      * AGT (should be ARST)
 96      * BET (should be EST) +
 97      *
 98      * + A zone with the correct name already exists and means something
 99      * else. E.g., EST usually indicates the US Eastern zone, so it cannot be
100      * used for Brazil (BET).
101      */
102     public void TestShortZoneIDs() throws Exception {
103 
104         ZoneDescriptor[] JDK_116_REFERENCE_LIST = {
105             new ZoneDescriptor(&quot;MIT&quot;, 780, true),
106             new ZoneDescriptor(&quot;HST&quot;, -600, false),
107             new ZoneDescriptor(&quot;AST&quot;, -540, true),
108             new ZoneDescriptor(&quot;PST&quot;, -480, true),
109             new ZoneDescriptor(&quot;PNT&quot;, -420, false),
110             new ZoneDescriptor(&quot;MST&quot;, -420, false),
111             new ZoneDescriptor(&quot;CST&quot;, -360, true),
112             new ZoneDescriptor(&quot;IET&quot;, -300, true),
113             new ZoneDescriptor(&quot;EST&quot;, -300, false),
114             new ZoneDescriptor(&quot;PRT&quot;, -240, false),
115             new ZoneDescriptor(&quot;CNT&quot;, -210, true),
116             new ZoneDescriptor(&quot;AGT&quot;, -180, false),
<a name="3" id="anc3"></a><span class="line-modified">117             new ZoneDescriptor(&quot;BET&quot;, -180, false),</span>
118             // new ZoneDescriptor(&quot;CAT&quot;, -60, false), // Wrong:
119             // As of bug 4130885, fix CAT (Central Africa)
120             new ZoneDescriptor(&quot;CAT&quot;, 120, false), // Africa/Harare
121             new ZoneDescriptor(&quot;GMT&quot;, 0, false),
122             new ZoneDescriptor(&quot;UTC&quot;, 0, false),
123             new ZoneDescriptor(&quot;ECT&quot;, 60, true),
124             new ZoneDescriptor(&quot;ART&quot;, 120, false),
125             new ZoneDescriptor(&quot;EET&quot;, 120, true),
126             new ZoneDescriptor(&quot;EAT&quot;, 180, false),
127             new ZoneDescriptor(&quot;MET&quot;, 60, true),
128             new ZoneDescriptor(&quot;NET&quot;, 240, false),
129             new ZoneDescriptor(&quot;PLT&quot;, 300, false),
130             new ZoneDescriptor(&quot;IST&quot;, 330, false),
131             new ZoneDescriptor(&quot;BST&quot;, 360, false),
132             new ZoneDescriptor(&quot;VST&quot;, 420, false),
133             new ZoneDescriptor(&quot;CTT&quot;, 480, false),
134             new ZoneDescriptor(&quot;JST&quot;, 540, false),
135             new ZoneDescriptor(&quot;ACT&quot;, 570, false),
136             new ZoneDescriptor(&quot;AET&quot;, 600, true),
137             new ZoneDescriptor(&quot;SST&quot;, 660, false),
138             // new ZoneDescriptor(&quot;NST&quot;, 720, false),
139             // As of bug 4130885, fix NST (New Zealand)
140             new ZoneDescriptor(&quot;NST&quot;, 720, true), // Pacific/Auckland
141         };
142 
143         Map&lt;String, ZoneDescriptor&gt; hash = new HashMap&lt;&gt;();
144 
145         String[] ids = TimeZone.getAvailableIDs();
146         for (String id : ids) {
147             if (id.length() == 3) {
148                 hash.put(id, new ZoneDescriptor(TimeZone.getTimeZone(id)));
149             }
150         }
151 
152         for (int i = 0; i &lt; JDK_116_REFERENCE_LIST.length; ++i) {
153             ZoneDescriptor referenceZone = JDK_116_REFERENCE_LIST[i];
154             ZoneDescriptor currentZone = hash.get(referenceZone.getID());
155             if (referenceZone.equals(currentZone)) {
156                 logln(&quot;ok &quot; + referenceZone);
157             }
158             else {
159                 errln(&quot;Fail: Expected &quot; + referenceZone +
160                       &quot;; got &quot; + currentZone);
161             }
162         }
163     }
164 
165     /**
166      * A descriptor for a zone; used to regress the short zone IDs.
167      */
168     static class ZoneDescriptor {
169         String id;
170         int offset; // In minutes
171         boolean daylight;
172 
173         ZoneDescriptor(TimeZone zone) {
174             this.id = zone.getID();
175             this.offset = zone.getRawOffset() / 60000;
176             this.daylight = zone.useDaylightTime();
177         }
178 
179         ZoneDescriptor(String id, int offset, boolean daylight) {
180             this.id = id;
181             this.offset = offset;
182             this.daylight = daylight;
183         }
184 
185         public String getID() { return id; }
186 
187         @Override
188         public boolean equals(Object o) {
189             ZoneDescriptor that = (ZoneDescriptor)o;
190             return that != null &amp;&amp;
191                 id.equals(that.id) &amp;&amp;
192                 offset == that.offset &amp;&amp;
193                 daylight == that.daylight;
194         }
195 
196         @Override
197         public int hashCode() {
198             return id.hashCode() ^ offset | (daylight ? 1 : 0);
199         }
200 
201         @Override
202         public String toString() {
203             int min = offset;
204             char sign = &#39;+&#39;;
205             if (min &lt; 0) { sign = &#39;-&#39;; min = -min; }
206 
207             return &quot;Zone[\&quot;&quot; + id + &quot;\&quot;, GMT&quot; + sign + (min/60) + &#39;:&#39; +
208                 (min%60&lt;10?&quot;0&quot;:&quot;&quot;) + (min%60) + &quot;, &quot; +
209                 (daylight ? &quot;Daylight&quot; : &quot;Standard&quot;) + &quot;]&quot;;
210         }
211 
212         public static int compare(Object o1, Object o2) {
213             ZoneDescriptor i1 = (ZoneDescriptor)o1;
214             ZoneDescriptor i2 = (ZoneDescriptor)o2;
215             if (i1.offset &gt; i2.offset) return 1;
216             if (i1.offset &lt; i2.offset) return -1;
217             if (i1.daylight &amp;&amp; !i2.daylight) return 1;
218             if (!i1.daylight &amp;&amp; i2.daylight) return -1;
219             return i1.id.compareTo(i2.id);
220         }
221     }
222 
223     static final String formatMinutes(int min) {
224         char sign = &#39;+&#39;;
225         if (min &lt; 0) { sign = &#39;-&#39;; min = -min; }
226         int h = min/60;
227         min = min%60;
228         return &quot;&quot; + sign + h + &quot;:&quot; + ((min&lt;10) ? &quot;0&quot; : &quot;&quot;) + min;
229     }
230     /**
231      * As part of the VM fix (see CCC approved RFE 4028006, bug
232      * 4044013), TimeZone.getTimeZone() has been modified to recognize
233      * generic IDs of the form GMT[+-]hh:mm, GMT[+-]hhmm, and
234      * GMT[+-]hh.  Test this behavior here.
235      *
236      * Bug 4044013
237      *
238      * ID &quot;Custom&quot; is no longer used for TimeZone objects created with
239      * a custom time zone ID, such as &quot;GMT-8&quot;. See 4322313.
240      */
241     public void TestCustomParse() throws Exception {
242         Object[] DATA = {
243             // ID        Expected offset in minutes
244             &quot;GMT&quot;,       null,
245             &quot;GMT+0&quot;,     new Integer(0),
246             &quot;GMT+1&quot;,     new Integer(60),
247             &quot;GMT-0030&quot;,  new Integer(-30),
248             &quot;GMT+15:99&quot;, null,
249             &quot;GMT+&quot;,      null,
250             &quot;GMT-&quot;,      null,
251             &quot;GMT+0:&quot;,    null,
252             &quot;GMT-:&quot;,     null,
253             &quot;GMT+0010&quot;,  new Integer(10), // Interpret this as 00:10
254             &quot;GMT-10&quot;,    new Integer(-10*60),
255             &quot;GMT+30&quot;,    null,
256             &quot;GMT-3:30&quot;,  new Integer(-(3*60+30)),
257             &quot;GMT-230&quot;,   new Integer(-(2*60+30)),
258         };
259         for (int i=0; i&lt;DATA.length; i+=2) {
260             String id = (String)DATA[i];
261             Integer exp = (Integer)DATA[i+1];
262             TimeZone zone = TimeZone.getTimeZone(id);
263             if (zone.getID().equals(&quot;GMT&quot;)) {
264                 logln(id + &quot; -&gt; generic GMT&quot;);
265                 // When TimeZone.getTimeZone() can&#39;t parse the id, it
266                 // returns GMT -- a dubious practice, but required for
267                 // backward compatibility.
268                 if (exp != null) {
269                     throw new Exception(&quot;Expected offset of &quot; + formatMinutes(exp.intValue()) +
270                                         &quot; for &quot; + id + &quot;, got parse failure&quot;);
271                 }
272             }
273             else {
274                 int ioffset = zone.getRawOffset()/60000;
275                 String offset = formatMinutes(ioffset);
276                 logln(id + &quot; -&gt; &quot; + zone.getID() + &quot; GMT&quot; + offset);
277                 if (exp == null) {
278                     throw new Exception(&quot;Expected parse failure for &quot; + id +
279                                         &quot;, got offset of &quot; + offset +
280                                         &quot;, id &quot; + zone.getID());
281                 }
282                 else if (ioffset != exp.intValue()) {
283                     throw new Exception(&quot;Expected offset of &quot; + formatMinutes(exp.intValue()) +
284                                         &quot;, id Custom, for &quot; + id +
285                                         &quot;, got offset of &quot; + offset +
286                                         &quot;, id &quot; + zone.getID());
287                 }
288             }
289         }
290     }
291 
292     /**
293      * Test the basic functionality of the getDisplayName() API.
294      *
295      * Bug 4112869
296      * Bug 4028006
297      *
298      * See also API change request A41.
299      *
300      * 4/21/98 - make smarter, so the test works if the ext resources
301      * are present or not.
302      */
303     public void TestDisplayName() {
304         TimeZone zone = TimeZone.getTimeZone(&quot;PST&quot;);
305         String name = zone.getDisplayName(Locale.ENGLISH);
306         logln(&quot;PST-&gt;&quot; + name);
307         if (!name.equals(&quot;Pacific Standard Time&quot;))
308             errln(&quot;Fail: Expected \&quot;Pacific Standard Time\&quot;&quot;);
309 
310         //*****************************************************************
311         // THE FOLLOWING LINES MUST BE UPDATED IF THE LOCALE DATA CHANGES
312         // THE FOLLOWING LINES MUST BE UPDATED IF THE LOCALE DATA CHANGES
313         // THE FOLLOWING LINES MUST BE UPDATED IF THE LOCALE DATA CHANGES
314         //*****************************************************************
315         Object[] DATA = {
316             new Boolean(false), new Integer(TimeZone.SHORT), &quot;PST&quot;,
317             new Boolean(true),  new Integer(TimeZone.SHORT), &quot;PDT&quot;,
318             new Boolean(false), new Integer(TimeZone.LONG),  &quot;Pacific Standard Time&quot;,
319             new Boolean(true),  new Integer(TimeZone.LONG),  &quot;Pacific Daylight Time&quot;,
320         };
321 
322         for (int i=0; i&lt;DATA.length; i+=3) {
323             name = zone.getDisplayName(((Boolean)DATA[i]).booleanValue(),
324                                        ((Integer)DATA[i+1]).intValue(),
325                                        Locale.ENGLISH);
326             if (!name.equals(DATA[i+2]))
327                 errln(&quot;Fail: Expected &quot; + DATA[i+2] + &quot;; got &quot; + name);
328         }
329 
330         // Make sure that we don&#39;t display the DST name by constructing a fake
331         // PST zone that has DST all year long.
332         SimpleTimeZone zone2 = new SimpleTimeZone(0, &quot;PST&quot;);
333         zone2.setStartRule(Calendar.JANUARY, 1, 0);
334         zone2.setEndRule(Calendar.DECEMBER, 31, 0);
335         logln(&quot;Modified PST inDaylightTime-&gt;&quot; + zone2.inDaylightTime(new Date()));
336         name = zone2.getDisplayName(Locale.ENGLISH);
337         logln(&quot;Modified PST-&gt;&quot; + name);
338         if (!name.equals(&quot;Pacific Standard Time&quot;))
339             errln(&quot;Fail: Expected \&quot;Pacific Standard Time\&quot;&quot;);
340 
341         // Make sure we get the default display format for Locales
342         // with no display name data.
343         Locale zh_CN = Locale.SIMPLIFIED_CHINESE;
344         name = zone.getDisplayName(zh_CN);
345         //*****************************************************************
346         // THE FOLLOWING LINE MUST BE UPDATED IF THE LOCALE DATA CHANGES
347         // THE FOLLOWING LINE MUST BE UPDATED IF THE LOCALE DATA CHANGES
348         // THE FOLLOWING LINE MUST BE UPDATED IF THE LOCALE DATA CHANGES
349         //*****************************************************************
350         logln(&quot;PST(zh_CN)-&gt;&quot; + name);
351 
352         // Now be smart -- check to see if zh resource is even present.
353         // If not, we expect the en fallback behavior.
354         ResourceBundle enRB = LocaleData.getBundle(&quot;sun.util.resources.TimeZoneNames&quot;,
355                                                    Locale.ENGLISH);
356         ResourceBundle zhRB = LocaleData.getBundle(&quot;sun.util.resources.TimeZoneNames&quot;,
357                                                    zh_CN);
358 
359         boolean noZH = enRB == zhRB;
360 
361         if (noZH) {
362             logln(&quot;Warning: Not testing the zh_CN behavior because resource is absent&quot;);
363             if (!name.equals(&quot;Pacific Standard Time&quot;))
364                 errln(&quot;Fail: Expected Pacific Standard Time&quot;);
365         }
366         else if (!name.equals(&quot;Pacific Standard Time&quot;) &amp;&amp;
367                  !name.equals(&quot;\u592a\u5e73\u6d0b\u6807\u51c6\u65f6\u95f4&quot;) &amp;&amp;
368                  !name.equals(&quot;\u5317\u7f8e\u592a\u5e73\u6d0b\u6807\u51c6\u65f6\u95f4&quot;) &amp;&amp;
369                  !name.equals(&quot;GMT-08:00&quot;) &amp;&amp;
370                  !name.equals(&quot;GMT-8:00&quot;) &amp;&amp;
371                  !name.equals(&quot;GMT-0800&quot;) &amp;&amp;
372                  !name.equals(&quot;GMT-800&quot;)) {
373             errln(&quot;Fail: Expected GMT-08:00 or something similar&quot;);
374             errln(&quot;************************************************************&quot;);
375             errln(&quot;THE ABOVE FAILURE MAY JUST MEAN THE LOCALE DATA HAS CHANGED&quot;);
376             errln(&quot;************************************************************&quot;);
377         }
378 
379         // Now try a non-existent zone
380         zone2 = new SimpleTimeZone(90*60*1000, &quot;xyzzy&quot;);
381         name = zone2.getDisplayName(Locale.ENGLISH);
382         logln(&quot;GMT+90min-&gt;&quot; + name);
383         if (!name.equals(&quot;GMT+01:30&quot;) &amp;&amp;
384             !name.equals(&quot;GMT+1:30&quot;) &amp;&amp;
385             !name.equals(&quot;GMT+0130&quot;) &amp;&amp;
386             !name.equals(&quot;GMT+130&quot;))
387             errln(&quot;Fail: Expected GMT+01:30 or something similar&quot;);
388     }
389 
390     public void TestGenericAPI() {
391         String id = &quot;NewGMT&quot;;
392         int offset = 12345;
393 
394         SimpleTimeZone zone = new SimpleTimeZone(offset, id);
395         if (zone.useDaylightTime()) {
396             errln(&quot;FAIL: useDaylightTime should return false&quot;);
397         }
398 
399         TimeZone zoneclone = (TimeZone)zone.clone();
400         if (!zoneclone.equals(zone)) {
401             errln(&quot;FAIL: clone or operator== failed&quot;);
402         }
403         zoneclone.setID(&quot;abc&quot;);
404         if (zoneclone.equals(zone)) {
405             errln(&quot;FAIL: clone or operator!= failed&quot;);
406         }
407 
408         zoneclone = (TimeZone)zone.clone();
409         if (!zoneclone.equals(zone)) {
410             errln(&quot;FAIL: clone or operator== failed&quot;);
411         }
412         zoneclone.setRawOffset(45678);
413         if (zoneclone.equals(zone)) {
414             errln(&quot;FAIL: clone or operator!= failed&quot;);
415         }
416 
417         TimeZone saveDefault = TimeZone.getDefault();
418         try {
419             TimeZone.setDefault(zone);
420             TimeZone defaultzone = TimeZone.getDefault();
421             if (defaultzone == zone) {
422                 errln(&quot;FAIL: Default object is identical, not clone&quot;);
423             }
424             if (!defaultzone.equals(zone)) {
425                 errln(&quot;FAIL: Default object is not equal&quot;);
426             }
427         }
428         finally {
429             TimeZone.setDefault(saveDefault);
430         }
431     }
432 
433     @SuppressWarnings(&quot;deprecation&quot;)
434     public void TestRuleAPI()
435     {
436         // ErrorCode status = ZERO_ERROR;
437 
438         int offset = (int)(60*60*1000*1.75); // Pick a weird offset
439         SimpleTimeZone zone = new SimpleTimeZone(offset, &quot;TestZone&quot;);
440         if (zone.useDaylightTime()) errln(&quot;FAIL: useDaylightTime should return false&quot;);
441 
442         // Establish our expected transition times.  Do this with a non-DST
443         // calendar with the (above) declared local offset.
444         GregorianCalendar gc = new GregorianCalendar(zone);
445         gc.clear();
446         gc.set(1990, Calendar.MARCH, 1);
447         long marchOneStd = gc.getTime().getTime(); // Local Std time midnight
448         gc.clear();
449         gc.set(1990, Calendar.JULY, 1);
450         long julyOneStd = gc.getTime().getTime(); // Local Std time midnight
451 
452         // Starting and ending hours, WALL TIME
453         int startHour = (int)(2.25 * 3600000);
454         int endHour   = (int)(3.5  * 3600000);
455 
456         zone.setStartRule(Calendar.MARCH, 1, 0, startHour);
457         zone.setEndRule  (Calendar.JULY,  1, 0, endHour);
458 
459         gc = new GregorianCalendar(zone);
460         // if (failure(status, &quot;new GregorianCalendar&quot;)) return;
461 
462         long marchOne = marchOneStd + startHour;
463         long julyOne = julyOneStd + endHour - 3600000; // Adjust from wall to Std time
464 
465         long expMarchOne = 636251400000L;
466         if (marchOne != expMarchOne)
467         {
468             errln(&quot;FAIL: Expected start computed as &quot; + marchOne +
469                   &quot; = &quot; + new Date(marchOne));
470             logln(&quot;      Should be                  &quot; + expMarchOne +
471                   &quot; = &quot; + new Date(expMarchOne));
472         }
473 
474         long expJulyOne = 646793100000L;
475         if (julyOne != expJulyOne)
476         {
477             errln(&quot;FAIL: Expected start computed as &quot; + julyOne +
478                   &quot; = &quot; + new Date(julyOne));
479             logln(&quot;      Should be                  &quot; + expJulyOne +
480                   &quot; = &quot; + new Date(expJulyOne));
481         }
482 
483         testUsingBinarySearch(zone, new Date(90, Calendar.JANUARY, 1).getTime(),
484                               new Date(90, Calendar.JUNE, 15).getTime(), marchOne);
485         testUsingBinarySearch(zone, new Date(90, Calendar.JUNE, 1).getTime(),
486                               new Date(90, Calendar.DECEMBER, 31).getTime(), julyOne);
487 
488         if (zone.inDaylightTime(new Date(marchOne - 1000)) ||
489             !zone.inDaylightTime(new Date(marchOne)))
490             errln(&quot;FAIL: Start rule broken&quot;);
491         if (!zone.inDaylightTime(new Date(julyOne - 1000)) ||
492             zone.inDaylightTime(new Date(julyOne)))
493             errln(&quot;FAIL: End rule broken&quot;);
494 
495         zone.setStartYear(1991);
496         if (zone.inDaylightTime(new Date(marchOne)) ||
497             zone.inDaylightTime(new Date(julyOne - 1000)))
498             errln(&quot;FAIL: Start year broken&quot;);
499 
500         // failure(status, &quot;TestRuleAPI&quot;);
501         // delete gc;
502         // delete zone;
503     }
504 
505     void testUsingBinarySearch(SimpleTimeZone tz, long min, long max, long expectedBoundary)
506     {
507         // ErrorCode status = ZERO_ERROR;
508         boolean startsInDST = tz.inDaylightTime(new Date(min));
509         // if (failure(status, &quot;SimpleTimeZone::inDaylightTime&quot;)) return;
510         if (tz.inDaylightTime(new Date(max)) == startsInDST) {
511             logln(&quot;Error: inDaylightTime(&quot; + new Date(max) + &quot;) != &quot; + (!startsInDST));
512             return;
513         }
514         // if (failure(status, &quot;SimpleTimeZone::inDaylightTime&quot;)) return;
515         while ((max - min) &gt; INTERVAL) {
516             long mid = (min + max) / 2;
517             if (tz.inDaylightTime(new Date(mid)) == startsInDST) {
518                 min = mid;
519             }
520             else {
521                 max = mid;
522             }
523             // if (failure(status, &quot;SimpleTimeZone::inDaylightTime&quot;)) return;
524         }
525         logln(&quot;Binary Search Before: &quot; + min + &quot; = &quot; + new Date(min));
526         logln(&quot;Binary Search After:  &quot; + max + &quot; = &quot; + new Date(max));
527         long mindelta = expectedBoundary - min;
528         long maxdelta = max - expectedBoundary;
529         if (mindelta &gt;= 0 &amp;&amp;
530             mindelta &lt;= INTERVAL &amp;&amp;
531             mindelta &gt;= 0 &amp;&amp;
532             mindelta &lt;= INTERVAL)
533             logln(&quot;PASS: Expected bdry:  &quot; + expectedBoundary + &quot; = &quot; + new Date(expectedBoundary));
534         else
535             errln(&quot;FAIL: Expected bdry:  &quot; + expectedBoundary + &quot; = &quot; + new Date(expectedBoundary));
536     }
537 
538     static final int INTERVAL = 100;
539 
540     // Bug 006; verify the offset for a specific zone.
541     public void TestPRTOffset()
542     {
543         TimeZone tz = TimeZone.getTimeZone( &quot;PRT&quot; );
544         if( tz == null ) {
545             errln( &quot;FAIL: TimeZone(PRT) is null&quot; );
546         }
547         else{
548             if (tz.getRawOffset() != (-4*millisPerHour))
549                 errln(&quot;FAIL: Offset for PRT should be -4&quot;);
550         }
551 
552     }
553 
554     // Test various calls
555     @SuppressWarnings(&quot;deprecation&quot;)
556     public void TestVariousAPI518()
557     {
558         TimeZone time_zone = TimeZone.getTimeZone(&quot;PST&quot;);
559         Date d = new Date(97, Calendar.APRIL, 30);
560 
561         logln(&quot;The timezone is &quot; + time_zone.getID());
562 
563         if (time_zone.inDaylightTime(d) != true)
564             errln(&quot;FAIL: inDaylightTime returned false&quot;);
565 
566         if (time_zone.useDaylightTime() != true)
567             errln(&quot;FAIL: useDaylightTime returned false&quot;);
568 
569         if (time_zone.getRawOffset() != -8*millisPerHour)
570             errln( &quot;FAIL: getRawOffset returned wrong value&quot;);
571 
572         GregorianCalendar gc = new GregorianCalendar();
573         gc.setTime(d);
574         if (time_zone.getOffset(gc.AD, gc.get(gc.YEAR), gc.get(gc.MONTH),
575                                 gc.get(gc.DAY_OF_MONTH),
576                                 gc.get(gc.DAY_OF_WEEK), 0)
577             != -7*millisPerHour)
578             errln(&quot;FAIL: getOffset returned wrong value&quot;);
579     }
580 
581     // Test getAvailableID API
582     public void TestGetAvailableIDs913()
583     {
584         StringBuffer buf = new StringBuffer(&quot;TimeZone.getAvailableIDs() = { &quot;);
585         String[] s = TimeZone.getAvailableIDs();
586         for (int i=0; i&lt;s.length; ++i)
587         {
588             if (i &gt; 0) buf.append(&quot;, &quot;);
589             buf.append(s[i]);
590         }
591         buf.append(&quot; };&quot;);
592         logln(buf.toString());
593 
594         buf.setLength(0);
595         buf.append(&quot;TimeZone.getAvailableIDs(GMT+02:00) = { &quot;);
596         s = TimeZone.getAvailableIDs(+2 * 60 * 60 * 1000);
597         for (int i=0; i&lt;s.length; ++i)
598         {
599             if (i &gt; 0) buf.append(&quot;, &quot;);
600             buf.append(s[i]);
601         }
602         buf.append(&quot; };&quot;);
603         logln(buf.toString());
604 
605         TimeZone tz = TimeZone.getTimeZone(&quot;PST&quot;);
606         if (tz != null)
607             logln(&quot;getTimeZone(PST) = &quot; + tz.getID());
608         else
609             errln(&quot;FAIL: getTimeZone(PST) = null&quot;);
610 
611         tz = TimeZone.getTimeZone(&quot;America/Los_Angeles&quot;);
612         if (tz != null)
613             logln(&quot;getTimeZone(America/Los_Angeles) = &quot; + tz.getID());
614         else
615             errln(&quot;FAIL: getTimeZone(PST) = null&quot;);
616 
617         // Bug 4096694
618         tz = TimeZone.getTimeZone(&quot;NON_EXISTENT&quot;);
619         if (tz == null)
620             errln(&quot;FAIL: getTimeZone(NON_EXISTENT) = null&quot;);
621         else if (!tz.getID().equals(&quot;GMT&quot;))
622             errln(&quot;FAIL: getTimeZone(NON_EXISTENT) = &quot; + tz.getID());
623     }
624 
625     /**
626      * Bug 4107276
627      */
628     public void TestDSTSavings() {
629         // It might be better to find a way to integrate this test into the main TimeZone
630         // tests above, but I don&#39;t have time to figure out how to do this (or if it&#39;s
631         // even really a good idea).  Let&#39;s consider that a future.  --rtg 1/27/98
632         SimpleTimeZone tz = new SimpleTimeZone(-5 * millisPerHour, &quot;dstSavingsTest&quot;,
633                                                Calendar.MARCH, 1, 0, 0, Calendar.SEPTEMBER, 1, 0, 0,
634                                                (int)(0.5 * millisPerHour));
635 
636         if (tz.getRawOffset() != -5 * millisPerHour)
637             errln(&quot;Got back a raw offset of &quot; + (tz.getRawOffset() / millisPerHour) +
638                   &quot; hours instead of -5 hours.&quot;);
639         if (!tz.useDaylightTime())
640             errln(&quot;Test time zone should use DST but claims it doesn&#39;t.&quot;);
641         if (tz.getDSTSavings() != 0.5 * millisPerHour)
642             errln(&quot;Set DST offset to 0.5 hour, but got back &quot; + (tz.getDSTSavings() /
643                                                                  millisPerHour) + &quot; hours instead.&quot;);
644 
645         int offset = tz.getOffset(GregorianCalendar.AD, 1998, Calendar.JANUARY, 1,
646                                   Calendar.THURSDAY, 10 * millisPerHour);
647         if (offset != -5 * millisPerHour)
648             errln(&quot;The offset for 10 AM, 1/1/98 should have been -5 hours, but we got &quot;
649                   + (offset / millisPerHour) + &quot; hours.&quot;);
650 
651         offset = tz.getOffset(GregorianCalendar.AD, 1998, Calendar.JUNE, 1, Calendar.MONDAY,
652                               10 * millisPerHour);
653         if (offset != -4.5 * millisPerHour)
654             errln(&quot;The offset for 10 AM, 6/1/98 should have been -4.5 hours, but we got &quot;
655                   + (offset / millisPerHour) + &quot; hours.&quot;);
656 
657         tz.setDSTSavings(millisPerHour);
658         offset = tz.getOffset(GregorianCalendar.AD, 1998, Calendar.JANUARY, 1,
659                               Calendar.THURSDAY, 10 * millisPerHour);
660         if (offset != -5 * millisPerHour)
661             errln(&quot;The offset for 10 AM, 1/1/98 should have been -5 hours, but we got &quot;
662                   + (offset / millisPerHour) + &quot; hours.&quot;);
663 
664         offset = tz.getOffset(GregorianCalendar.AD, 1998, Calendar.JUNE, 1, Calendar.MONDAY,
665                               10 * millisPerHour);
666         if (offset != -4 * millisPerHour)
667             errln(&quot;The offset for 10 AM, 6/1/98 (with a 1-hour DST offset) should have been -4 hours, but we got &quot;
668                   + (offset / millisPerHour) + &quot; hours.&quot;);
669     }
670 
671     /**
672      * Bug 4107570
673      */
674     public void TestAlternateRules() {
675         // Like TestDSTSavings, this test should probably be integrated somehow with the main
676         // test at the top of this class, but I didn&#39;t have time to figure out how to do that.
677         //                      --rtg 1/28/98
678 
679         SimpleTimeZone tz = new SimpleTimeZone(-5 * millisPerHour, &quot;alternateRuleTest&quot;);
680 
681         // test the day-of-month API
682         tz.setStartRule(Calendar.MARCH, 10, 12 * millisPerHour);
683         tz.setEndRule(Calendar.OCTOBER, 20, 12 * millisPerHour);
684 
685         int offset = tz.getOffset(GregorianCalendar.AD, 1998, Calendar.MARCH, 5,
686                                   Calendar.THURSDAY, 10 * millisPerHour);
687         if (offset != -5 * millisPerHour)
688             errln(&quot;The offset for 10AM, 3/5/98 should have been -5 hours, but we got &quot;
689                   + (offset / millisPerHour) + &quot; hours.&quot;);
690 
691         offset = tz.getOffset(GregorianCalendar.AD, 1998, Calendar.MARCH, 15,
692                               Calendar.SUNDAY, 10 * millisPerHour);
693         if (offset != -4 * millisPerHour)
694             errln(&quot;The offset for 10AM, 3/15/98 should have been -4 hours, but we got &quot;
695                   + (offset / millisPerHour) + &quot; hours.&quot;);
696 
697         offset = tz.getOffset(GregorianCalendar.AD, 1998, Calendar.OCTOBER, 15,
698                               Calendar.THURSDAY, 10 * millisPerHour);
699         if (offset != -4 * millisPerHour)
700             errln(&quot;The offset for 10AM, 10/15/98 should have been -4 hours, but we got &quot;
701                   + (offset / millisPerHour) + &quot; hours.&quot;);
702 
703         offset = tz.getOffset(GregorianCalendar.AD, 1998, Calendar.OCTOBER, 25,
704                               Calendar.SUNDAY, 10 * millisPerHour);
705         if (offset != -5 * millisPerHour)
706             errln(&quot;The offset for 10AM, 10/25/98 should have been -5 hours, but we got &quot;
707                   + (offset / millisPerHour) + &quot; hours.&quot;);
708 
709         // test the day-of-week-after-day-in-month API
710         tz.setStartRule(Calendar.MARCH, 10, Calendar.FRIDAY, 12 * millisPerHour, true);
711         tz.setEndRule(Calendar.OCTOBER, 20, Calendar.FRIDAY, 12 * millisPerHour, false);
712 
713         offset = tz.getOffset(GregorianCalendar.AD, 1998, Calendar.MARCH, 11,
714                               Calendar.WEDNESDAY, 10 * millisPerHour);
715         if (offset != -5 * millisPerHour)
716             errln(&quot;The offset for 10AM, 3/11/98 should have been -5 hours, but we got &quot;
717                   + (offset / millisPerHour) + &quot; hours.&quot;);
718 
719         offset = tz.getOffset(GregorianCalendar.AD, 1998, Calendar.MARCH, 14,
720                               Calendar.SATURDAY, 10 * millisPerHour);
721         if (offset != -4 * millisPerHour)
722             errln(&quot;The offset for 10AM, 3/14/98 should have been -4 hours, but we got &quot;
723                   + (offset / millisPerHour) + &quot; hours.&quot;);
724 
725         offset = tz.getOffset(GregorianCalendar.AD, 1998, Calendar.OCTOBER, 15,
726                               Calendar.THURSDAY, 10 * millisPerHour);
727         if (offset != -4 * millisPerHour)
728             errln(&quot;The offset for 10AM, 10/15/98 should have been -4 hours, but we got &quot;
729                   + (offset / millisPerHour) + &quot; hours.&quot;);
730 
731         offset = tz.getOffset(GregorianCalendar.AD, 1998, Calendar.OCTOBER, 17,
732                               Calendar.SATURDAY, 10 * millisPerHour);
733         if (offset != -5 * millisPerHour)
734             errln(&quot;The offset for 10AM, 10/17/98 should have been -5 hours, but we got &quot;
735                   + (offset / millisPerHour) + &quot; hours.&quot;);
736     }
737 }
738 
739 //eof
<a name="4" id="anc4"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="4" type="hidden" />
</body>
</html>
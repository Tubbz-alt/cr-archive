<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames test/jdk/java/util/regex/RegExTest.java</title>
    <link rel="stylesheet" href="../../../../../style.css" />
    <script type="text/javascript" src="../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
<a name="1" id="anc1"></a><span class="line-modified">   2  * Copyright (c) 1999, 2018, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  */
  23 
  24 /**
  25  * @test
  26  * @summary tests RegExp framework (use -Dseed=X to set PRNG seed)
  27  * @author Mike McCloskey
  28  * @bug 4481568 4482696 4495089 4504687 4527731 4599621 4631553 4619345
  29  * 4630911 4672616 4711773 4727935 4750573 4792284 4803197 4757029 4808962
  30  * 4872664 4803179 4892980 4900747 4945394 4938995 4979006 4994840 4997476
  31  * 5013885 5003322 4988891 5098443 5110268 6173522 4829857 5027748 6376940
  32  * 6358731 6178785 6284152 6231989 6497148 6486934 6233084 6504326 6635133
  33  * 6350801 6676425 6878475 6919132 6931676 6948903 6990617 7014645 7039066
  34  * 7067045 7014640 7189363 8007395 8013252 8013254 8012646 8023647 6559590
  35  * 8027645 8035076 8039124 8035975 8074678 6854417 8143854 8147531 7071819
  36  * 8151481 4867170 7080302 6728861 6995635 6736245 4916384 6328855 6192895
  37  * 6345469 6988218 6693451 7006761 8140212 8143282 8158482 8176029 8184706
<a name="2" id="anc2"></a><span class="line-modified">  38  * 8194667 8197462 8184692</span>
  39  *
  40  * @library /test/lib
<a name="3" id="anc3"></a>
  41  * @build jdk.test.lib.RandomFactory
  42  * @run main RegExTest
  43  * @key randomness
  44  */
  45 
<a name="4" id="anc4"></a><span class="line-modified">  46 import java.util.function.Function;</span>
<span class="line-modified">  47 import java.util.regex.*;</span>














  48 import java.util.Random;
  49 import java.util.Scanner;
<a name="5" id="anc5"></a><span class="line-modified">  50 import java.io.*;</span>
<span class="line-removed">  51 import java.nio.file.*;</span>
<span class="line-removed">  52 import java.util.*;</span>
<span class="line-removed">  53 import java.nio.CharBuffer;</span>
  54 import java.util.function.Predicate;
<a name="6" id="anc6"></a>



  55 import jdk.test.lib.RandomFactory;
  56 
  57 /**
  58  * This is a test class created to check the operation of
  59  * the Pattern and Matcher classes.
  60  */
  61 public class RegExTest {
  62 
  63     private static Random generator = RandomFactory.getRandom();
  64     private static boolean failure = false;
  65     private static int failCount = 0;
  66     private static String firstFailure = null;
  67 
  68     /**
  69      * Main to interpret arguments and run several tests.
  70      *
  71      */
  72     public static void main(String[] args) throws Exception {
  73         // Most of the tests are in a file
  74         processFile(&quot;TestCases.txt&quot;);
  75         //processFile(&quot;PerlCases.txt&quot;);
  76         processFile(&quot;BMPTestCases.txt&quot;);
  77         processFile(&quot;SupplementaryTestCases.txt&quot;);
  78 
  79         // These test many randomly generated char patterns
  80         bm();
  81         slice();
  82 
  83         // These are hard to put into the file
  84         escapes();
  85         blankInput();
  86 
  87         // Substitition tests on randomly generated sequences
  88         globalSubstitute();
  89         stringbufferSubstitute();
  90         stringbuilderSubstitute();
  91 
  92         substitutionBasher();
  93         substitutionBasher2();
  94 
  95         // Canonical Equivalence
  96         ceTest();
  97 
  98         // Anchors
  99         anchorTest();
 100 
 101         // boolean match calls
 102         matchesTest();
 103         lookingAtTest();
 104 
 105         // Pattern API
 106         patternMatchesTest();
 107 
 108         // Misc
 109         lookbehindTest();
 110         nullArgumentTest();
 111         backRefTest();
 112         groupCaptureTest();
 113         caretTest();
 114         charClassTest();
 115         emptyPatternTest();
 116         findIntTest();
 117         group0Test();
 118         longPatternTest();
 119         octalTest();
 120         ampersandTest();
 121         negationTest();
 122         splitTest();
 123         appendTest();
 124         caseFoldingTest();
 125         commentsTest();
 126         unixLinesTest();
 127         replaceFirstTest();
 128         gTest();
 129         zTest();
 130         serializeTest();
 131         reluctantRepetitionTest();
 132         multilineDollarTest();
 133         dollarAtEndTest();
 134         caretBetweenTerminatorsTest();
 135         // This RFE rejected in Tiger numOccurrencesTest();
 136         javaCharClassTest();
 137         nonCaptureRepetitionTest();
 138         notCapturedGroupCurlyMatchTest();
 139         escapedSegmentTest();
 140         literalPatternTest();
 141         literalReplacementTest();
 142         regionTest();
 143         toStringTest();
 144         negatedCharClassTest();
 145         findFromTest();
 146         boundsTest();
 147         unicodeWordBoundsTest();
 148         caretAtEndTest();
 149         wordSearchTest();
 150         hitEndTest();
 151         toMatchResultTest();
 152         toMatchResultTest2();
 153         surrogatesInClassTest();
 154         removeQEQuotingTest();
 155         namedGroupCaptureTest();
 156         nonBmpClassComplementTest();
 157         unicodePropertiesTest();
 158         unicodeHexNotationTest();
 159         unicodeClassesTest();
 160         unicodeCharacterNameTest();
 161         horizontalAndVerticalWSTest();
 162         linebreakTest();
 163         branchTest();
 164         groupCurlyNotFoundSuppTest();
 165         groupCurlyBackoffTest();
 166         patternAsPredicate();
 167         patternAsMatchPredicate();
 168         invalidFlags();
 169         embeddedFlags();
 170         grapheme();
 171         expoBacktracking();
 172         invalidGroupName();
<a name="7" id="anc7"></a>


 173 
 174         if (failure) {
 175             throw new
 176                 RuntimeException(&quot;RegExTest failed, 1st failure: &quot; +
 177                                  firstFailure);
 178         } else {
 179             System.err.println(&quot;OKAY: All tests passed.&quot;);
 180         }
 181     }
 182 
 183     // Utility functions
 184 
 185     private static String getRandomAlphaString(int length) {
 186         StringBuffer buf = new StringBuffer(length);
 187         for (int i=0; i&lt;length; i++) {
 188             char randChar = (char)(97 + generator.nextInt(26));
 189             buf.append(randChar);
 190         }
 191         return buf.toString();
 192     }
 193 
 194     private static void check(Matcher m, String expected) {
 195         m.find();
 196         if (!m.group().equals(expected))
 197             failCount++;
 198     }
 199 
 200     private static void check(Matcher m, String result, boolean expected) {
 201         m.find();
 202         if (m.group().equals(result) != expected)
 203             failCount++;
 204     }
 205 
 206     private static void check(Pattern p, String s, boolean expected) {
 207         if (p.matcher(s).find() != expected)
 208             failCount++;
 209     }
 210 
 211     private static void check(String p, String s, boolean expected) {
 212         Matcher matcher = Pattern.compile(p).matcher(s);
 213         if (matcher.find() != expected)
 214             failCount++;
 215     }
 216 
 217     private static void check(String p, char c, boolean expected) {
 218         String propertyPattern = expected ? &quot;\\p&quot; + p : &quot;\\P&quot; + p;
 219         Pattern pattern = Pattern.compile(propertyPattern);
 220         char[] ca = new char[1]; ca[0] = c;
 221         Matcher matcher = pattern.matcher(new String(ca));
 222         if (!matcher.find())
 223             failCount++;
 224     }
 225 
 226     private static void check(String p, int codePoint, boolean expected) {
 227         String propertyPattern = expected ? &quot;\\p&quot; + p : &quot;\\P&quot; + p;
 228         Pattern pattern = Pattern.compile(propertyPattern);
 229         char[] ca = Character.toChars(codePoint);
 230         Matcher matcher = pattern.matcher(new String(ca));
 231         if (!matcher.find())
 232             failCount++;
 233     }
 234 
 235     private static void check(String p, int flag, String input, String s,
 236                               boolean expected)
 237     {
 238         Pattern pattern = Pattern.compile(p, flag);
 239         Matcher matcher = pattern.matcher(input);
 240         if (expected)
 241             check(matcher, s, expected);
 242         else
 243             check(pattern, input, false);
 244     }
 245 
 246     private static void report(String testName) {
 247         int spacesToAdd = 30 - testName.length();
 248         StringBuffer paddedNameBuffer = new StringBuffer(testName);
 249         for (int i=0; i&lt;spacesToAdd; i++)
 250             paddedNameBuffer.append(&quot; &quot;);
 251         String paddedName = paddedNameBuffer.toString();
 252         System.err.println(paddedName + &quot;: &quot; +
 253                            (failCount==0 ? &quot;Passed&quot;:&quot;Failed(&quot;+failCount+&quot;)&quot;));
 254         if (failCount &gt; 0) {
 255             failure = true;
 256 
 257             if (firstFailure == null) {
 258                 firstFailure = testName;
 259             }
 260         }
 261 
 262         failCount = 0;
 263     }
 264 
 265     /**
 266      * Converts ASCII alphabet characters [A-Za-z] in the given &#39;s&#39; to
 267      * supplementary characters. This method does NOT fully take care
 268      * of the regex syntax.
 269      */
 270     private static String toSupplementaries(String s) {
 271         int length = s.length();
 272         StringBuffer sb = new StringBuffer(length * 2);
 273 
 274         for (int i = 0; i &lt; length; ) {
 275             char c = s.charAt(i++);
 276             if (c == &#39;\\&#39;) {
 277                 sb.append(c);
 278                 if (i &lt; length) {
 279                     c = s.charAt(i++);
 280                     sb.append(c);
 281                     if (c == &#39;u&#39;) {
 282                         // assume no syntax error
 283                         sb.append(s.charAt(i++));
 284                         sb.append(s.charAt(i++));
 285                         sb.append(s.charAt(i++));
 286                         sb.append(s.charAt(i++));
 287                     }
 288                 }
 289             } else if ((c &gt;= &#39;A&#39; &amp;&amp; c &lt;= &#39;Z&#39;) || (c &gt;= &#39;a&#39; &amp;&amp; c &lt;= &#39;z&#39;)) {
 290                 sb.append(&#39;\ud800&#39;).append((char)(&#39;\udc00&#39;+c));
 291             } else {
 292                 sb.append(c);
 293             }
 294         }
 295         return sb.toString();
 296     }
 297 
 298     // Regular expression tests
 299 
 300     // This is for bug 6178785
 301     // Test if an expected NPE gets thrown when passing in a null argument
 302     private static boolean check(Runnable test) {
 303         try {
 304             test.run();
 305             failCount++;
 306             return false;
 307         } catch (NullPointerException npe) {
 308             return true;
 309         }
 310     }
 311 
 312     private static void nullArgumentTest() {
 313         check(() -&gt; Pattern.compile(null));
 314         check(() -&gt; Pattern.matches(null, null));
 315         check(() -&gt; Pattern.matches(&quot;xyz&quot;, null));
 316         check(() -&gt; Pattern.quote(null));
 317         check(() -&gt; Pattern.compile(&quot;xyz&quot;).split(null));
 318         check(() -&gt; Pattern.compile(&quot;xyz&quot;).matcher(null));
 319 
 320         final Matcher m = Pattern.compile(&quot;xyz&quot;).matcher(&quot;xyz&quot;);
 321         m.matches();
 322         check(() -&gt; m.appendTail((StringBuffer) null));
 323         check(() -&gt; m.appendTail((StringBuilder)null));
 324         check(() -&gt; m.replaceAll((String) null));
 325         check(() -&gt; m.replaceAll((Function&lt;MatchResult, String&gt;)null));
 326         check(() -&gt; m.replaceFirst((String)null));
 327         check(() -&gt; m.replaceFirst((Function&lt;MatchResult, String&gt;) null));
 328         check(() -&gt; m.appendReplacement((StringBuffer)null, null));
 329         check(() -&gt; m.appendReplacement((StringBuilder)null, null));
 330         check(() -&gt; m.reset(null));
 331         check(() -&gt; Matcher.quoteReplacement(null));
 332         //check(() -&gt; m.usePattern(null));
 333 
 334         report(&quot;Null Argument&quot;);
 335     }
 336 
 337     // This is for bug6635133
 338     // Test if surrogate pair in Unicode escapes can be handled correctly.
 339     private static void surrogatesInClassTest() throws Exception {
 340         Pattern pattern = Pattern.compile(&quot;[\\ud834\\udd21-\\ud834\\udd24]&quot;);
 341         Matcher matcher = pattern.matcher(&quot;\ud834\udd22&quot;);
 342         if (!matcher.find())
 343             failCount++;
 344 
 345         report(&quot;Surrogate pair in Unicode escape&quot;);
 346     }
 347 
 348     // This is for bug6990617
 349     // Test if Pattern.RemoveQEQuoting works correctly if the octal unicode
 350     // char encoding is only 2 or 3 digits instead of 4 and the first quoted
 351     // char is an octal digit.
 352     private static void removeQEQuotingTest() throws Exception {
 353         Pattern pattern =
 354             Pattern.compile(&quot;\\011\\Q1sometext\\E\\011\\Q2sometext\\E&quot;);
 355         Matcher matcher = pattern.matcher(&quot;\t1sometext\t2sometext&quot;);
 356         if (!matcher.find())
 357             failCount++;
 358 
 359         report(&quot;Remove Q/E Quoting&quot;);
 360     }
 361 
 362     // This is for bug 4988891
 363     // Test toMatchResult to see that it is a copy of the Matcher
 364     // that is not affected by subsequent operations on the original
 365     private static void toMatchResultTest() throws Exception {
 366         Pattern pattern = Pattern.compile(&quot;squid&quot;);
 367         Matcher matcher = pattern.matcher(
 368             &quot;agiantsquidofdestinyasmallsquidoffate&quot;);
 369         matcher.find();
 370         int matcherStart1 = matcher.start();
 371         MatchResult mr = matcher.toMatchResult();
 372         if (mr == matcher)
 373             failCount++;
 374         int resultStart1 = mr.start();
 375         if (matcherStart1 != resultStart1)
 376             failCount++;
 377         matcher.find();
 378         int matcherStart2 = matcher.start();
 379         int resultStart2 = mr.start();
 380         if (matcherStart2 == resultStart2)
 381             failCount++;
 382         if (resultStart1 != resultStart2)
 383             failCount++;
 384         MatchResult mr2 = matcher.toMatchResult();
 385         if (mr == mr2)
 386             failCount++;
 387         if (mr2.start() != matcherStart2)
 388             failCount++;
 389         report(&quot;toMatchResult is a copy&quot;);
 390     }
 391 
 392     private static void checkExpectedISE(Runnable test) {
 393         try {
 394             test.run();
 395             failCount++;
 396         } catch (IllegalStateException x) {
 397         } catch (IndexOutOfBoundsException xx) {
 398             failCount++;
 399         }
 400     }
 401 
 402     private static void checkExpectedIOOE(Runnable test) {
 403         try {
 404             test.run();
 405             failCount++;
 406         } catch (IndexOutOfBoundsException x) {}
 407     }
 408 
 409     // This is for bug 8074678
 410     // Test the result of toMatchResult throws ISE if no match is availble
 411     private static void toMatchResultTest2() throws Exception {
 412         Matcher matcher = Pattern.compile(&quot;nomatch&quot;).matcher(&quot;hello world&quot;);
 413         matcher.find();
 414         MatchResult mr = matcher.toMatchResult();
 415 
 416         checkExpectedISE(() -&gt; mr.start());
 417         checkExpectedISE(() -&gt; mr.start(2));
 418         checkExpectedISE(() -&gt; mr.end());
 419         checkExpectedISE(() -&gt; mr.end(2));
 420         checkExpectedISE(() -&gt; mr.group());
 421         checkExpectedISE(() -&gt; mr.group(2));
 422 
 423         matcher = Pattern.compile(&quot;(match)&quot;).matcher(&quot;there is a match&quot;);
 424         matcher.find();
 425         MatchResult mr2 = matcher.toMatchResult();
 426         checkExpectedIOOE(() -&gt; mr2.start(2));
 427         checkExpectedIOOE(() -&gt; mr2.end(2));
 428         checkExpectedIOOE(() -&gt; mr2.group(2));
 429 
 430         report(&quot;toMatchResult2 appropriate exceptions&quot;);
 431     }
 432 
 433     // This is for bug 5013885
 434     // Must test a slice to see if it reports hitEnd correctly
 435     private static void hitEndTest() throws Exception {
 436         // Basic test of Slice node
 437         Pattern p = Pattern.compile(&quot;^squidattack&quot;);
 438         Matcher m = p.matcher(&quot;squack&quot;);
 439         m.find();
 440         if (m.hitEnd())
 441             failCount++;
 442         m.reset(&quot;squid&quot;);
 443         m.find();
 444         if (!m.hitEnd())
 445             failCount++;
 446 
 447         // Test Slice, SliceA and SliceU nodes
 448         for (int i=0; i&lt;3; i++) {
 449             int flags = 0;
 450             if (i==1) flags = Pattern.CASE_INSENSITIVE;
 451             if (i==2) flags = Pattern.UNICODE_CASE;
 452             p = Pattern.compile(&quot;^abc&quot;, flags);
 453             m = p.matcher(&quot;ad&quot;);
 454             m.find();
 455             if (m.hitEnd())
 456                 failCount++;
 457             m.reset(&quot;ab&quot;);
 458             m.find();
 459             if (!m.hitEnd())
 460                 failCount++;
 461         }
 462 
 463         // Test Boyer-Moore node
 464         p = Pattern.compile(&quot;catattack&quot;);
 465         m = p.matcher(&quot;attack&quot;);
 466         m.find();
 467         if (!m.hitEnd())
 468             failCount++;
 469 
 470         p = Pattern.compile(&quot;catattack&quot;);
 471         m = p.matcher(&quot;attackattackattackcatatta&quot;);
 472         m.find();
 473         if (!m.hitEnd())
 474             failCount++;
 475 
 476         // 8184706: Matching u+0d at EOL against \R should hit-end
 477         p = Pattern.compile(&quot;...\\R&quot;);
 478         m = p.matcher(&quot;cat&quot; + (char)0x0a);
 479         m.find();
 480         if (m.hitEnd())
 481             failCount++;
 482 
 483         m = p.matcher(&quot;cat&quot; + (char)0x0d);
 484         m.find();
 485         if (!m.hitEnd())
 486             failCount++;
 487 
 488         m = p.matcher(&quot;cat&quot; + (char)0x0d + (char)0x0a);
 489         m.find();
 490         if (m.hitEnd())
 491             failCount++;
 492 
 493         report(&quot;hitEnd&quot;);
 494     }
 495 
 496     // This is for bug 4997476
 497     // It is weird code submitted by customer demonstrating a regression
 498     private static void wordSearchTest() throws Exception {
 499         String testString = new String(&quot;word1 word2 word3&quot;);
 500         Pattern p = Pattern.compile(&quot;\\b&quot;);
 501         Matcher m = p.matcher(testString);
 502         int position = 0;
 503         int start = 0;
 504         while (m.find(position)) {
 505             start = m.start();
 506             if (start == testString.length())
 507                 break;
 508             if (m.find(start+1)) {
 509                 position = m.start();
 510             } else {
 511                 position = testString.length();
 512             }
 513             if (testString.substring(start, position).equals(&quot; &quot;))
 514                 continue;
 515             if (!testString.substring(start, position-1).startsWith(&quot;word&quot;))
 516                 failCount++;
 517         }
 518         report(&quot;Customer word search&quot;);
 519     }
 520 
 521     // This is for bug 4994840
 522     private static void caretAtEndTest() throws Exception {
 523         // Problem only occurs with multiline patterns
 524         // containing a beginning-of-line caret &quot;^&quot; followed
 525         // by an expression that also matches the empty string.
 526         Pattern pattern = Pattern.compile(&quot;^x?&quot;, Pattern.MULTILINE);
 527         Matcher matcher = pattern.matcher(&quot;\r&quot;);
 528         matcher.find();
 529         matcher.find();
 530         report(&quot;Caret at end&quot;);
 531     }
 532 
 533     // This test is for 4979006
 534     // Check to see if word boundary construct properly handles unicode
 535     // non spacing marks
 536     private static void unicodeWordBoundsTest() throws Exception {
 537         String spaces = &quot;  &quot;;
 538         String wordChar = &quot;a&quot;;
 539         String nsm = &quot;\u030a&quot;;
 540 
 541         assert (Character.getType(&#39;\u030a&#39;) == Character.NON_SPACING_MARK);
 542 
 543         Pattern pattern = Pattern.compile(&quot;\\b&quot;);
 544         Matcher matcher = pattern.matcher(&quot;&quot;);
 545         // S=other B=word character N=non spacing mark .=word boundary
 546         // SS.BB.SS
 547         String input = spaces + wordChar + wordChar + spaces;
 548         twoFindIndexes(input, matcher, 2, 4);
 549         // SS.BBN.SS
 550         input = spaces + wordChar +wordChar + nsm + spaces;
 551         twoFindIndexes(input, matcher, 2, 5);
 552         // SS.BN.SS
 553         input = spaces + wordChar + nsm + spaces;
 554         twoFindIndexes(input, matcher, 2, 4);
 555         // SS.BNN.SS
 556         input = spaces + wordChar + nsm + nsm + spaces;
 557         twoFindIndexes(input, matcher, 2, 5);
 558         // SSN.BB.SS
 559         input = spaces + nsm + wordChar + wordChar + spaces;
 560         twoFindIndexes(input, matcher, 3, 5);
 561         // SS.BNB.SS
 562         input = spaces + wordChar + nsm + wordChar + spaces;
 563         twoFindIndexes(input, matcher, 2, 5);
 564         // SSNNSS
 565         input = spaces + nsm + nsm + spaces;
 566         matcher.reset(input);
 567         if (matcher.find())
 568             failCount++;
 569         // SSN.BBN.SS
 570         input = spaces + nsm + wordChar + wordChar + nsm + spaces;
 571         twoFindIndexes(input, matcher, 3, 6);
 572 
 573         report(&quot;Unicode word boundary&quot;);
 574     }
 575 
 576     private static void twoFindIndexes(String input, Matcher matcher, int a,
 577                                        int b) throws Exception
 578     {
 579         matcher.reset(input);
 580         matcher.find();
 581         if (matcher.start() != a)
 582             failCount++;
 583         matcher.find();
 584         if (matcher.start() != b)
 585             failCount++;
 586     }
 587 
 588     // This test is for 6284152
 589     static void check(String regex, String input, String[] expected) {
 590         List&lt;String&gt; result = new ArrayList&lt;String&gt;();
 591         Pattern p = Pattern.compile(regex);
 592         Matcher m = p.matcher(input);
 593         while (m.find()) {
 594             result.add(m.group());
 595         }
 596         if (!Arrays.asList(expected).equals(result))
 597             failCount++;
 598     }
 599 
 600     private static void lookbehindTest() throws Exception {
 601         //Positive
 602         check(&quot;(?&lt;=%.{0,5})foo\\d&quot;,
 603               &quot;%foo1\n%bar foo2\n%bar  foo3\n%blahblah foo4\nfoo5&quot;,
 604               new String[]{&quot;foo1&quot;, &quot;foo2&quot;, &quot;foo3&quot;});
 605 
 606         //boundary at end of the lookbehind sub-regex should work consistently
 607         //with the boundary just after the lookbehind sub-regex
 608         check(&quot;(?&lt;=.*\\b)foo&quot;, &quot;abcd foo&quot;, new String[]{&quot;foo&quot;});
 609         check(&quot;(?&lt;=.*)\\bfoo&quot;, &quot;abcd foo&quot;, new String[]{&quot;foo&quot;});
 610         check(&quot;(?&lt;!abc )\\bfoo&quot;, &quot;abc foo&quot;, new String[0]);
 611         check(&quot;(?&lt;!abc \\b)foo&quot;, &quot;abc foo&quot;, new String[0]);
 612 
 613         //Negative
 614         check(&quot;(?&lt;!%.{0,5})foo\\d&quot;,
 615               &quot;%foo1\n%bar foo2\n%bar  foo3\n%blahblah foo4\nfoo5&quot;,
 616               new String[] {&quot;foo4&quot;, &quot;foo5&quot;});
 617 
 618         //Positive greedy
 619         check(&quot;(?&lt;=%b{1,4})foo&quot;, &quot;%bbbbfoo&quot;, new String[] {&quot;foo&quot;});
 620 
 621         //Positive reluctant
 622         check(&quot;(?&lt;=%b{1,4}?)foo&quot;, &quot;%bbbbfoo&quot;, new String[] {&quot;foo&quot;});
 623 
 624         //supplementary
 625         check(&quot;(?&lt;=%b{1,4})fo\ud800\udc00o&quot;, &quot;%bbbbfo\ud800\udc00o&quot;,
 626               new String[] {&quot;fo\ud800\udc00o&quot;});
 627         check(&quot;(?&lt;=%b{1,4}?)fo\ud800\udc00o&quot;, &quot;%bbbbfo\ud800\udc00o&quot;,
 628               new String[] {&quot;fo\ud800\udc00o&quot;});
 629         check(&quot;(?&lt;!%b{1,4})fo\ud800\udc00o&quot;, &quot;%afo\ud800\udc00o&quot;,
 630               new String[] {&quot;fo\ud800\udc00o&quot;});
 631         check(&quot;(?&lt;!%b{1,4}?)fo\ud800\udc00o&quot;, &quot;%afo\ud800\udc00o&quot;,
 632               new String[] {&quot;fo\ud800\udc00o&quot;});
 633         report(&quot;Lookbehind&quot;);
 634     }
 635 
 636     // This test is for 4938995
 637     // Check to see if weak region boundaries are transparent to
 638     // lookahead and lookbehind constructs
 639     private static void boundsTest() throws Exception {
 640         String fullMessage = &quot;catdogcat&quot;;
 641         Pattern pattern = Pattern.compile(&quot;(?&lt;=cat)dog(?=cat)&quot;);
 642         Matcher matcher = pattern.matcher(&quot;catdogca&quot;);
 643         matcher.useTransparentBounds(true);
 644         if (matcher.find())
 645             failCount++;
 646         matcher.reset(&quot;atdogcat&quot;);
 647         if (matcher.find())
 648             failCount++;
 649         matcher.reset(fullMessage);
 650         if (!matcher.find())
 651             failCount++;
 652         matcher.reset(fullMessage);
 653         matcher.region(0,9);
 654         if (!matcher.find())
 655             failCount++;
 656         matcher.reset(fullMessage);
 657         matcher.region(0,6);
 658         if (!matcher.find())
 659             failCount++;
 660         matcher.reset(fullMessage);
 661         matcher.region(3,6);
 662         if (!matcher.find())
 663             failCount++;
 664         matcher.useTransparentBounds(false);
 665         if (matcher.find())
 666             failCount++;
 667 
 668         // Negative lookahead/lookbehind
 669         pattern = Pattern.compile(&quot;(?&lt;!cat)dog(?!cat)&quot;);
 670         matcher = pattern.matcher(&quot;dogcat&quot;);
 671         matcher.useTransparentBounds(true);
 672         matcher.region(0,3);
 673         if (matcher.find())
 674             failCount++;
 675         matcher.reset(&quot;catdog&quot;);
 676         matcher.region(3,6);
 677         if (matcher.find())
 678             failCount++;
 679         matcher.useTransparentBounds(false);
 680         matcher.reset(&quot;dogcat&quot;);
 681         matcher.region(0,3);
 682         if (!matcher.find())
 683             failCount++;
 684         matcher.reset(&quot;catdog&quot;);
 685         matcher.region(3,6);
 686         if (!matcher.find())
 687             failCount++;
 688 
 689         report(&quot;Region bounds transparency&quot;);
 690     }
 691 
 692     // This test is for 4945394
 693     private static void findFromTest() throws Exception {
 694         String message = &quot;This is 40 $0 message.&quot;;
 695         Pattern pat = Pattern.compile(&quot;\\$0&quot;);
 696         Matcher match = pat.matcher(message);
 697         if (!match.find())
 698             failCount++;
 699         if (match.find())
 700             failCount++;
 701         if (match.find())
 702             failCount++;
 703         report(&quot;Check for alternating find&quot;);
 704     }
 705 
 706     // This test is for 4872664 and 4892980
 707     private static void negatedCharClassTest() throws Exception {
 708         Pattern pattern = Pattern.compile(&quot;[^&gt;]&quot;);
 709         Matcher matcher = pattern.matcher(&quot;\u203A&quot;);
 710         if (!matcher.matches())
 711             failCount++;
 712         pattern = Pattern.compile(&quot;[^fr]&quot;);
 713         matcher = pattern.matcher(&quot;a&quot;);
 714         if (!matcher.find())
 715             failCount++;
 716         matcher.reset(&quot;\u203A&quot;);
 717         if (!matcher.find())
 718             failCount++;
 719         String s = &quot;for&quot;;
 720         String result[] = s.split(&quot;[^fr]&quot;);
 721         if (!result[0].equals(&quot;f&quot;))
 722             failCount++;
 723         if (!result[1].equals(&quot;r&quot;))
 724             failCount++;
 725         s = &quot;f\u203Ar&quot;;
 726         result = s.split(&quot;[^fr]&quot;);
 727         if (!result[0].equals(&quot;f&quot;))
 728             failCount++;
 729         if (!result[1].equals(&quot;r&quot;))
 730             failCount++;
 731 
 732         // Test adding to bits, subtracting a node, then adding to bits again
 733         pattern = Pattern.compile(&quot;[^f\u203Ar]&quot;);
 734         matcher = pattern.matcher(&quot;a&quot;);
 735         if (!matcher.find())
 736             failCount++;
 737         matcher.reset(&quot;f&quot;);
 738         if (matcher.find())
 739             failCount++;
 740         matcher.reset(&quot;\u203A&quot;);
 741         if (matcher.find())
 742             failCount++;
 743         matcher.reset(&quot;r&quot;);
 744         if (matcher.find())
 745             failCount++;
 746         matcher.reset(&quot;\u203B&quot;);
 747         if (!matcher.find())
 748             failCount++;
 749 
 750         // Test subtracting a node, adding to bits, subtracting again
 751         pattern = Pattern.compile(&quot;[^\u203Ar\u203B]&quot;);
 752         matcher = pattern.matcher(&quot;a&quot;);
 753         if (!matcher.find())
 754             failCount++;
 755         matcher.reset(&quot;\u203A&quot;);
 756         if (matcher.find())
 757             failCount++;
 758         matcher.reset(&quot;r&quot;);
 759         if (matcher.find())
 760             failCount++;
 761         matcher.reset(&quot;\u203B&quot;);
 762         if (matcher.find())
 763             failCount++;
 764         matcher.reset(&quot;\u203C&quot;);
 765         if (!matcher.find())
 766             failCount++;
 767 
 768         report(&quot;Negated Character Class&quot;);
 769     }
 770 
 771     // This test is for 4628291
 772     private static void toStringTest() throws Exception {
 773         Pattern pattern = Pattern.compile(&quot;b+&quot;);
 774         if (pattern.toString() != &quot;b+&quot;)
 775             failCount++;
 776         Matcher matcher = pattern.matcher(&quot;aaabbbccc&quot;);
 777         String matcherString = matcher.toString(); // unspecified
 778         matcher.find();
 779         matcherString = matcher.toString(); // unspecified
 780         matcher.region(0,3);
 781         matcherString = matcher.toString(); // unspecified
 782         matcher.reset();
 783         matcherString = matcher.toString(); // unspecified
 784         report(&quot;toString&quot;);
 785     }
 786 
 787     // This test is for 4808962
 788     private static void literalPatternTest() throws Exception {
 789         int flags = Pattern.LITERAL;
 790 
 791         Pattern pattern = Pattern.compile(&quot;abc\\t$^&quot;, flags);
 792         check(pattern, &quot;abc\\t$^&quot;, true);
 793 
 794         pattern = Pattern.compile(Pattern.quote(&quot;abc\\t$^&quot;));
 795         check(pattern, &quot;abc\\t$^&quot;, true);
 796 
 797         pattern = Pattern.compile(&quot;\\Qa^$bcabc\\E&quot;, flags);
 798         check(pattern, &quot;\\Qa^$bcabc\\E&quot;, true);
 799         check(pattern, &quot;a^$bcabc&quot;, false);
 800 
 801         pattern = Pattern.compile(&quot;\\\\Q\\\\E&quot;);
 802         check(pattern, &quot;\\Q\\E&quot;, true);
 803 
 804         pattern = Pattern.compile(&quot;\\Qabc\\Eefg\\\\Q\\\\Ehij&quot;);
 805         check(pattern, &quot;abcefg\\Q\\Ehij&quot;, true);
 806 
 807         pattern = Pattern.compile(&quot;\\\\\\Q\\\\E&quot;);
 808         check(pattern, &quot;\\\\\\\\&quot;, true);
 809 
 810         pattern = Pattern.compile(Pattern.quote(&quot;\\Qa^$bcabc\\E&quot;));
 811         check(pattern, &quot;\\Qa^$bcabc\\E&quot;, true);
 812         check(pattern, &quot;a^$bcabc&quot;, false);
 813 
 814         pattern = Pattern.compile(Pattern.quote(&quot;\\Qabc\\Edef&quot;));
 815         check(pattern, &quot;\\Qabc\\Edef&quot;, true);
 816         check(pattern, &quot;abcdef&quot;, false);
 817 
 818         pattern = Pattern.compile(Pattern.quote(&quot;abc\\Edef&quot;));
 819         check(pattern, &quot;abc\\Edef&quot;, true);
 820         check(pattern, &quot;abcdef&quot;, false);
 821 
 822         pattern = Pattern.compile(Pattern.quote(&quot;\\E&quot;));
 823         check(pattern, &quot;\\E&quot;, true);
 824 
 825         pattern = Pattern.compile(&quot;((((abc.+?:)&quot;, flags);
 826         check(pattern, &quot;((((abc.+?:)&quot;, true);
 827 
 828         flags |= Pattern.MULTILINE;
 829 
 830         pattern = Pattern.compile(&quot;^cat$&quot;, flags);
 831         check(pattern, &quot;abc^cat$def&quot;, true);
 832         check(pattern, &quot;cat&quot;, false);
 833 
 834         flags |= Pattern.CASE_INSENSITIVE;
 835 
 836         pattern = Pattern.compile(&quot;abcdef&quot;, flags);
 837         check(pattern, &quot;ABCDEF&quot;, true);
 838         check(pattern, &quot;AbCdEf&quot;, true);
 839 
 840         flags |= Pattern.DOTALL;
 841 
 842         pattern = Pattern.compile(&quot;a...b&quot;, flags);
 843         check(pattern, &quot;A...b&quot;, true);
 844         check(pattern, &quot;Axxxb&quot;, false);
 845 
 846         flags |= Pattern.CANON_EQ;
 847 
 848         Pattern p = Pattern.compile(&quot;testa\u030a&quot;, flags);
 849         check(pattern, &quot;testa\u030a&quot;, false);
 850         check(pattern, &quot;test\u00e5&quot;, false);
 851 
 852         // Supplementary character test
 853         flags = Pattern.LITERAL;
 854 
 855         pattern = Pattern.compile(toSupplementaries(&quot;abc\\t$^&quot;), flags);
 856         check(pattern, toSupplementaries(&quot;abc\\t$^&quot;), true);
 857 
 858         pattern = Pattern.compile(Pattern.quote(toSupplementaries(&quot;abc\\t$^&quot;)));
 859         check(pattern, toSupplementaries(&quot;abc\\t$^&quot;), true);
 860 
 861         pattern = Pattern.compile(toSupplementaries(&quot;\\Qa^$bcabc\\E&quot;), flags);
 862         check(pattern, toSupplementaries(&quot;\\Qa^$bcabc\\E&quot;), true);
 863         check(pattern, toSupplementaries(&quot;a^$bcabc&quot;), false);
 864 
 865         pattern = Pattern.compile(Pattern.quote(toSupplementaries(&quot;\\Qa^$bcabc\\E&quot;)));
 866         check(pattern, toSupplementaries(&quot;\\Qa^$bcabc\\E&quot;), true);
 867         check(pattern, toSupplementaries(&quot;a^$bcabc&quot;), false);
 868 
 869         pattern = Pattern.compile(Pattern.quote(toSupplementaries(&quot;\\Qabc\\Edef&quot;)));
 870         check(pattern, toSupplementaries(&quot;\\Qabc\\Edef&quot;), true);
 871         check(pattern, toSupplementaries(&quot;abcdef&quot;), false);
 872 
 873         pattern = Pattern.compile(Pattern.quote(toSupplementaries(&quot;abc\\Edef&quot;)));
 874         check(pattern, toSupplementaries(&quot;abc\\Edef&quot;), true);
 875         check(pattern, toSupplementaries(&quot;abcdef&quot;), false);
 876 
 877         pattern = Pattern.compile(toSupplementaries(&quot;((((abc.+?:)&quot;), flags);
 878         check(pattern, toSupplementaries(&quot;((((abc.+?:)&quot;), true);
 879 
 880         flags |= Pattern.MULTILINE;
 881 
 882         pattern = Pattern.compile(toSupplementaries(&quot;^cat$&quot;), flags);
 883         check(pattern, toSupplementaries(&quot;abc^cat$def&quot;), true);
 884         check(pattern, toSupplementaries(&quot;cat&quot;), false);
 885 
 886         flags |= Pattern.DOTALL;
 887 
 888         // note: this is case-sensitive.
 889         pattern = Pattern.compile(toSupplementaries(&quot;a...b&quot;), flags);
 890         check(pattern, toSupplementaries(&quot;a...b&quot;), true);
 891         check(pattern, toSupplementaries(&quot;axxxb&quot;), false);
 892 
 893         flags |= Pattern.CANON_EQ;
 894 
 895         String t = toSupplementaries(&quot;test&quot;);
 896         p = Pattern.compile(t + &quot;a\u030a&quot;, flags);
 897         check(pattern, t + &quot;a\u030a&quot;, false);
 898         check(pattern, t + &quot;\u00e5&quot;, false);
 899 
 900         report(&quot;Literal pattern&quot;);
 901     }
 902 
 903     // This test is for 4803179
 904     // This test is also for 4808962, replacement parts
 905     private static void literalReplacementTest() throws Exception {
 906         int flags = Pattern.LITERAL;
 907 
 908         Pattern pattern = Pattern.compile(&quot;abc&quot;, flags);
 909         Matcher matcher = pattern.matcher(&quot;zzzabczzz&quot;);
 910         String replaceTest = &quot;$0&quot;;
 911         String result = matcher.replaceAll(replaceTest);
 912         if (!result.equals(&quot;zzzabczzz&quot;))
 913             failCount++;
 914 
 915         matcher.reset();
 916         String literalReplacement = matcher.quoteReplacement(replaceTest);
 917         result = matcher.replaceAll(literalReplacement);
 918         if (!result.equals(&quot;zzz$0zzz&quot;))
 919             failCount++;
 920 
 921         matcher.reset();
 922         replaceTest = &quot;\\t$\\$&quot;;
 923         literalReplacement = matcher.quoteReplacement(replaceTest);
 924         result = matcher.replaceAll(literalReplacement);
 925         if (!result.equals(&quot;zzz\\t$\\$zzz&quot;))
 926             failCount++;
 927 
 928         // Supplementary character test
 929         pattern = Pattern.compile(toSupplementaries(&quot;abc&quot;), flags);
 930         matcher = pattern.matcher(toSupplementaries(&quot;zzzabczzz&quot;));
 931         replaceTest = &quot;$0&quot;;
 932         result = matcher.replaceAll(replaceTest);
 933         if (!result.equals(toSupplementaries(&quot;zzzabczzz&quot;)))
 934             failCount++;
 935 
 936         matcher.reset();
 937         literalReplacement = matcher.quoteReplacement(replaceTest);
 938         result = matcher.replaceAll(literalReplacement);
 939         if (!result.equals(toSupplementaries(&quot;zzz$0zzz&quot;)))
 940             failCount++;
 941 
 942         matcher.reset();
 943         replaceTest = &quot;\\t$\\$&quot;;
 944         literalReplacement = matcher.quoteReplacement(replaceTest);
 945         result = matcher.replaceAll(literalReplacement);
 946         if (!result.equals(toSupplementaries(&quot;zzz\\t$\\$zzz&quot;)))
 947             failCount++;
 948 
 949         // IAE should be thrown if backslash or &#39;$&#39; is the last character
 950         // in replacement string
 951         try {
 952             &quot;\uac00&quot;.replaceAll(&quot;\uac00&quot;, &quot;$&quot;);
 953             failCount++;
 954         } catch (IllegalArgumentException iie) {
 955         } catch (Exception e) {
 956             failCount++;
 957         }
 958         try {
 959             &quot;\uac00&quot;.replaceAll(&quot;\uac00&quot;, &quot;\\&quot;);
 960             failCount++;
 961         } catch (IllegalArgumentException iie) {
 962         } catch (Exception e) {
 963             failCount++;
 964         }
 965         report(&quot;Literal replacement&quot;);
 966     }
 967 
 968     // This test is for 4757029
 969     private static void regionTest() throws Exception {
 970         Pattern pattern = Pattern.compile(&quot;abc&quot;);
 971         Matcher matcher = pattern.matcher(&quot;abcdefabc&quot;);
 972 
 973         matcher.region(0,9);
 974         if (!matcher.find())
 975             failCount++;
 976         if (!matcher.find())
 977             failCount++;
 978         matcher.region(0,3);
 979         if (!matcher.find())
 980            failCount++;
 981         matcher.region(3,6);
 982         if (matcher.find())
 983            failCount++;
 984         matcher.region(0,2);
 985         if (matcher.find())
 986            failCount++;
 987 
 988         expectRegionFail(matcher, 1, -1);
 989         expectRegionFail(matcher, -1, -1);
 990         expectRegionFail(matcher, -1, 1);
 991         expectRegionFail(matcher, 5, 3);
 992         expectRegionFail(matcher, 5, 12);
 993         expectRegionFail(matcher, 12, 12);
 994 
 995         pattern = Pattern.compile(&quot;^abc$&quot;);
 996         matcher = pattern.matcher(&quot;zzzabczzz&quot;);
 997         matcher.region(0,9);
 998         if (matcher.find())
 999             failCount++;
1000         matcher.region(3,6);
1001         if (!matcher.find())
1002            failCount++;
1003         matcher.region(3,6);
1004         matcher.useAnchoringBounds(false);
1005         if (matcher.find())
1006            failCount++;
1007 
1008         // Supplementary character test
1009         pattern = Pattern.compile(toSupplementaries(&quot;abc&quot;));
1010         matcher = pattern.matcher(toSupplementaries(&quot;abcdefabc&quot;));
1011         matcher.region(0,9*2);
1012         if (!matcher.find())
1013             failCount++;
1014         if (!matcher.find())
1015             failCount++;
1016         matcher.region(0,3*2);
1017         if (!matcher.find())
1018            failCount++;
1019         matcher.region(1,3*2);
1020         if (matcher.find())
1021            failCount++;
1022         matcher.region(3*2,6*2);
1023         if (matcher.find())
1024            failCount++;
1025         matcher.region(0,2*2);
1026         if (matcher.find())
1027            failCount++;
1028         matcher.region(0,2*2+1);
1029         if (matcher.find())
1030            failCount++;
1031 
1032         expectRegionFail(matcher, 1*2, -1);
1033         expectRegionFail(matcher, -1, -1);
1034         expectRegionFail(matcher, -1, 1*2);
1035         expectRegionFail(matcher, 5*2, 3*2);
1036         expectRegionFail(matcher, 5*2, 12*2);
1037         expectRegionFail(matcher, 12*2, 12*2);
1038 
1039         pattern = Pattern.compile(toSupplementaries(&quot;^abc$&quot;));
1040         matcher = pattern.matcher(toSupplementaries(&quot;zzzabczzz&quot;));
1041         matcher.region(0,9*2);
1042         if (matcher.find())
1043             failCount++;
1044         matcher.region(3*2,6*2);
1045         if (!matcher.find())
1046            failCount++;
1047         matcher.region(3*2+1,6*2);
1048         if (matcher.find())
1049            failCount++;
1050         matcher.region(3*2,6*2-1);
1051         if (matcher.find())
1052            failCount++;
1053         matcher.region(3*2,6*2);
1054         matcher.useAnchoringBounds(false);
1055         if (matcher.find())
1056            failCount++;
<a name="8" id="anc8"></a>















1057         report(&quot;Regions&quot;);
1058     }
1059 
1060     private static void expectRegionFail(Matcher matcher, int index1,
1061                                          int index2)
1062     {
1063         try {
1064             matcher.region(index1, index2);
1065             failCount++;
1066         } catch (IndexOutOfBoundsException ioobe) {
1067             // Correct result
1068         } catch (IllegalStateException ise) {
1069             // Correct result
1070         }
1071     }
1072 
1073     // This test is for 4803197
1074     private static void escapedSegmentTest() throws Exception {
1075 
1076         Pattern pattern = Pattern.compile(&quot;\\Qdir1\\dir2\\E&quot;);
1077         check(pattern, &quot;dir1\\dir2&quot;, true);
1078 
1079         pattern = Pattern.compile(&quot;\\Qdir1\\dir2\\\\E&quot;);
1080         check(pattern, &quot;dir1\\dir2\\&quot;, true);
1081 
1082         pattern = Pattern.compile(&quot;(\\Qdir1\\dir2\\\\E)&quot;);
1083         check(pattern, &quot;dir1\\dir2\\&quot;, true);
1084 
1085         // Supplementary character test
1086         pattern = Pattern.compile(toSupplementaries(&quot;\\Qdir1\\dir2\\E&quot;));
1087         check(pattern, toSupplementaries(&quot;dir1\\dir2&quot;), true);
1088 
1089         pattern = Pattern.compile(toSupplementaries(&quot;\\Qdir1\\dir2&quot;)+&quot;\\\\E&quot;);
1090         check(pattern, toSupplementaries(&quot;dir1\\dir2\\&quot;), true);
1091 
1092         pattern = Pattern.compile(toSupplementaries(&quot;(\\Qdir1\\dir2&quot;)+&quot;\\\\E)&quot;);
1093         check(pattern, toSupplementaries(&quot;dir1\\dir2\\&quot;), true);
1094 
1095         report(&quot;Escaped segment&quot;);
1096     }
1097 
1098     // This test is for 4792284
1099     private static void nonCaptureRepetitionTest() throws Exception {
1100         String input = &quot;abcdefgh;&quot;;
1101 
1102         String[] patterns = new String[] {
1103             &quot;(?:\\w{4})+;&quot;,
1104             &quot;(?:\\w{8})*;&quot;,
1105             &quot;(?:\\w{2}){2,4};&quot;,
1106             &quot;(?:\\w{4}){2,};&quot;,   // only matches the
1107             &quot;.*?(?:\\w{5})+;&quot;,   //     specified minimum
1108             &quot;.*?(?:\\w{9})*;&quot;,   //     number of reps - OK
1109             &quot;(?:\\w{4})+?;&quot;,     // lazy repetition - OK
1110             &quot;(?:\\w{4})++;&quot;,     // possessive repetition - OK
1111             &quot;(?:\\w{2,}?)+;&quot;,    // non-deterministic - OK
1112             &quot;(\\w{4})+;&quot;,        // capturing group - OK
1113         };
1114 
1115         for (int i = 0; i &lt; patterns.length; i++) {
1116             // Check find()
1117             check(patterns[i], 0, input, input, true);
1118             // Check matches()
1119             Pattern p = Pattern.compile(patterns[i]);
1120             Matcher m = p.matcher(input);
1121 
1122             if (m.matches()) {
1123                 if (!m.group(0).equals(input))
1124                     failCount++;
1125             } else {
1126                 failCount++;
1127             }
1128         }
1129 
1130         report(&quot;Non capturing repetition&quot;);
1131     }
1132 
1133     // This test is for 6358731
1134     private static void notCapturedGroupCurlyMatchTest() throws Exception {
1135         Pattern pattern = Pattern.compile(&quot;(abc)+|(abcd)+&quot;);
1136         Matcher matcher = pattern.matcher(&quot;abcd&quot;);
1137         if (!matcher.matches() ||
1138              matcher.group(1) != null ||
1139              !matcher.group(2).equals(&quot;abcd&quot;)) {
1140             failCount++;
1141         }
1142         report(&quot;Not captured GroupCurly&quot;);
1143     }
1144 
1145     // This test is for 4706545
1146     private static void javaCharClassTest() throws Exception {
1147         for (int i=0; i&lt;1000; i++) {
1148             char c = (char)generator.nextInt();
1149             check(&quot;{javaLowerCase}&quot;, c, Character.isLowerCase(c));
1150             check(&quot;{javaUpperCase}&quot;, c, Character.isUpperCase(c));
1151             check(&quot;{javaUpperCase}+&quot;, c, Character.isUpperCase(c));
1152             check(&quot;{javaTitleCase}&quot;, c, Character.isTitleCase(c));
1153             check(&quot;{javaDigit}&quot;, c, Character.isDigit(c));
1154             check(&quot;{javaDefined}&quot;, c, Character.isDefined(c));
1155             check(&quot;{javaLetter}&quot;, c, Character.isLetter(c));
1156             check(&quot;{javaLetterOrDigit}&quot;, c, Character.isLetterOrDigit(c));
1157             check(&quot;{javaJavaIdentifierStart}&quot;, c,
1158                   Character.isJavaIdentifierStart(c));
1159             check(&quot;{javaJavaIdentifierPart}&quot;, c,
1160                   Character.isJavaIdentifierPart(c));
1161             check(&quot;{javaUnicodeIdentifierStart}&quot;, c,
1162                   Character.isUnicodeIdentifierStart(c));
1163             check(&quot;{javaUnicodeIdentifierPart}&quot;, c,
1164                   Character.isUnicodeIdentifierPart(c));
1165             check(&quot;{javaIdentifierIgnorable}&quot;, c,
1166                   Character.isIdentifierIgnorable(c));
1167             check(&quot;{javaSpaceChar}&quot;, c, Character.isSpaceChar(c));
1168             check(&quot;{javaWhitespace}&quot;, c, Character.isWhitespace(c));
1169             check(&quot;{javaISOControl}&quot;, c, Character.isISOControl(c));
1170             check(&quot;{javaMirrored}&quot;, c, Character.isMirrored(c));
1171 
1172         }
1173 
1174         // Supplementary character test
1175         for (int i=0; i&lt;1000; i++) {
1176             int c = generator.nextInt(Character.MAX_CODE_POINT
1177                                       - Character.MIN_SUPPLEMENTARY_CODE_POINT)
1178                         + Character.MIN_SUPPLEMENTARY_CODE_POINT;
1179             check(&quot;{javaLowerCase}&quot;, c, Character.isLowerCase(c));
1180             check(&quot;{javaUpperCase}&quot;, c, Character.isUpperCase(c));
1181             check(&quot;{javaUpperCase}+&quot;, c, Character.isUpperCase(c));
1182             check(&quot;{javaTitleCase}&quot;, c, Character.isTitleCase(c));
1183             check(&quot;{javaDigit}&quot;, c, Character.isDigit(c));
1184             check(&quot;{javaDefined}&quot;, c, Character.isDefined(c));
1185             check(&quot;{javaLetter}&quot;, c, Character.isLetter(c));
1186             check(&quot;{javaLetterOrDigit}&quot;, c, Character.isLetterOrDigit(c));
1187             check(&quot;{javaJavaIdentifierStart}&quot;, c,
1188                   Character.isJavaIdentifierStart(c));
1189             check(&quot;{javaJavaIdentifierPart}&quot;, c,
1190                   Character.isJavaIdentifierPart(c));
1191             check(&quot;{javaUnicodeIdentifierStart}&quot;, c,
1192                   Character.isUnicodeIdentifierStart(c));
1193             check(&quot;{javaUnicodeIdentifierPart}&quot;, c,
1194                   Character.isUnicodeIdentifierPart(c));
1195             check(&quot;{javaIdentifierIgnorable}&quot;, c,
1196                   Character.isIdentifierIgnorable(c));
1197             check(&quot;{javaSpaceChar}&quot;, c, Character.isSpaceChar(c));
1198             check(&quot;{javaWhitespace}&quot;, c, Character.isWhitespace(c));
1199             check(&quot;{javaISOControl}&quot;, c, Character.isISOControl(c));
1200             check(&quot;{javaMirrored}&quot;, c, Character.isMirrored(c));
1201         }
1202 
1203         report(&quot;Java character classes&quot;);
1204     }
1205 
1206     // This test is for 4523620
1207     /*
1208     private static void numOccurrencesTest() throws Exception {
1209         Pattern pattern = Pattern.compile(&quot;aaa&quot;);
1210 
1211         if (pattern.numOccurrences(&quot;aaaaaa&quot;, false) != 2)
1212             failCount++;
1213         if (pattern.numOccurrences(&quot;aaaaaa&quot;, true) != 4)
1214             failCount++;
1215 
1216         pattern = Pattern.compile(&quot;^&quot;);
1217         if (pattern.numOccurrences(&quot;aaaaaa&quot;, false) != 1)
1218             failCount++;
1219         if (pattern.numOccurrences(&quot;aaaaaa&quot;, true) != 1)
1220             failCount++;
1221 
1222         report(&quot;Number of Occurrences&quot;);
1223     }
1224     */
1225 
1226     // This test is for 4776374
1227     private static void caretBetweenTerminatorsTest() throws Exception {
1228         int flags1 = Pattern.DOTALL;
1229         int flags2 = Pattern.DOTALL | Pattern.UNIX_LINES;
1230         int flags3 = Pattern.DOTALL | Pattern.UNIX_LINES | Pattern.MULTILINE;
1231         int flags4 = Pattern.DOTALL | Pattern.MULTILINE;
1232 
1233         check(&quot;^....&quot;, flags1, &quot;test\ntest&quot;, &quot;test&quot;, true);
1234         check(&quot;.....^&quot;, flags1, &quot;test\ntest&quot;, &quot;test&quot;, false);
1235         check(&quot;.....^&quot;, flags1, &quot;test\n&quot;, &quot;test&quot;, false);
1236         check(&quot;....^&quot;, flags1, &quot;test\r\n&quot;, &quot;test&quot;, false);
1237 
1238         check(&quot;^....&quot;, flags2, &quot;test\ntest&quot;, &quot;test&quot;, true);
1239         check(&quot;....^&quot;, flags2, &quot;test\ntest&quot;, &quot;test&quot;, false);
1240         check(&quot;.....^&quot;, flags2, &quot;test\n&quot;, &quot;test&quot;, false);
1241         check(&quot;....^&quot;, flags2, &quot;test\r\n&quot;, &quot;test&quot;, false);
1242 
1243         check(&quot;^....&quot;, flags3, &quot;test\ntest&quot;, &quot;test&quot;, true);
1244         check(&quot;.....^&quot;, flags3, &quot;test\ntest&quot;, &quot;test\n&quot;, true);
1245         check(&quot;.....^&quot;, flags3, &quot;test\u0085test&quot;, &quot;test\u0085&quot;, false);
1246         check(&quot;.....^&quot;, flags3, &quot;test\n&quot;, &quot;test&quot;, false);
1247         check(&quot;.....^&quot;, flags3, &quot;test\r\n&quot;, &quot;test&quot;, false);
1248         check(&quot;......^&quot;, flags3, &quot;test\r\ntest&quot;, &quot;test\r\n&quot;, true);
1249 
1250         check(&quot;^....&quot;, flags4, &quot;test\ntest&quot;, &quot;test&quot;, true);
1251         check(&quot;.....^&quot;, flags3, &quot;test\ntest&quot;, &quot;test\n&quot;, true);
1252         check(&quot;.....^&quot;, flags4, &quot;test\u0085test&quot;, &quot;test\u0085&quot;, true);
1253         check(&quot;.....^&quot;, flags4, &quot;test\n&quot;, &quot;test\n&quot;, false);
1254         check(&quot;.....^&quot;, flags4, &quot;test\r\n&quot;, &quot;test\r&quot;, false);
1255 
1256         // Supplementary character test
1257         String t = toSupplementaries(&quot;test&quot;);
1258         check(&quot;^....&quot;, flags1, t+&quot;\n&quot;+t, t, true);
1259         check(&quot;.....^&quot;, flags1, t+&quot;\n&quot;+t, t, false);
1260         check(&quot;.....^&quot;, flags1, t+&quot;\n&quot;, t, false);
1261         check(&quot;....^&quot;, flags1, t+&quot;\r\n&quot;, t, false);
1262 
1263         check(&quot;^....&quot;, flags2, t+&quot;\n&quot;+t, t, true);
1264         check(&quot;....^&quot;, flags2, t+&quot;\n&quot;+t, t, false);
1265         check(&quot;.....^&quot;, flags2, t+&quot;\n&quot;, t, false);
1266         check(&quot;....^&quot;, flags2, t+&quot;\r\n&quot;, t, false);
1267 
1268         check(&quot;^....&quot;, flags3, t+&quot;\n&quot;+t, t, true);
1269         check(&quot;.....^&quot;, flags3, t+&quot;\n&quot;+t, t+&quot;\n&quot;, true);
1270         check(&quot;.....^&quot;, flags3, t+&quot;\u0085&quot;+t, t+&quot;\u0085&quot;, false);
1271         check(&quot;.....^&quot;, flags3, t+&quot;\n&quot;, t, false);
1272         check(&quot;.....^&quot;, flags3, t+&quot;\r\n&quot;, t, false);
1273         check(&quot;......^&quot;, flags3, t+&quot;\r\n&quot;+t, t+&quot;\r\n&quot;, true);
1274 
1275         check(&quot;^....&quot;, flags4, t+&quot;\n&quot;+t, t, true);
1276         check(&quot;.....^&quot;, flags3, t+&quot;\n&quot;+t, t+&quot;\n&quot;, true);
1277         check(&quot;.....^&quot;, flags4, t+&quot;\u0085&quot;+t, t+&quot;\u0085&quot;, true);
1278         check(&quot;.....^&quot;, flags4, t+&quot;\n&quot;, t+&quot;\n&quot;, false);
1279         check(&quot;.....^&quot;, flags4, t+&quot;\r\n&quot;, t+&quot;\r&quot;, false);
1280 
1281         report(&quot;Caret between terminators&quot;);
1282     }
1283 
1284     // This test is for 4727935
1285     private static void dollarAtEndTest() throws Exception {
1286         int flags1 = Pattern.DOTALL;
1287         int flags2 = Pattern.DOTALL | Pattern.UNIX_LINES;
1288         int flags3 = Pattern.DOTALL | Pattern.MULTILINE;
1289 
1290         check(&quot;....$&quot;, flags1, &quot;test\n&quot;, &quot;test&quot;, true);
1291         check(&quot;....$&quot;, flags1, &quot;test\r\n&quot;, &quot;test&quot;, true);
1292         check(&quot;.....$&quot;, flags1, &quot;test\n&quot;, &quot;test\n&quot;, true);
1293         check(&quot;.....$&quot;, flags1, &quot;test\u0085&quot;, &quot;test\u0085&quot;, true);
1294         check(&quot;....$&quot;, flags1, &quot;test\u0085&quot;, &quot;test&quot;, true);
1295 
1296         check(&quot;....$&quot;, flags2, &quot;test\n&quot;, &quot;test&quot;, true);
1297         check(&quot;.....$&quot;, flags2, &quot;test\n&quot;, &quot;test\n&quot;, true);
1298         check(&quot;.....$&quot;, flags2, &quot;test\u0085&quot;, &quot;test\u0085&quot;, true);
1299         check(&quot;....$&quot;, flags2, &quot;test\u0085&quot;, &quot;est\u0085&quot;, true);
1300 
1301         check(&quot;....$.blah&quot;, flags3, &quot;test\nblah&quot;, &quot;test\nblah&quot;, true);
1302         check(&quot;.....$.blah&quot;, flags3, &quot;test\n\nblah&quot;, &quot;test\n\nblah&quot;, true);
1303         check(&quot;....$blah&quot;, flags3, &quot;test\nblah&quot;, &quot;!!!!&quot;, false);
1304         check(&quot;.....$blah&quot;, flags3, &quot;test\nblah&quot;, &quot;!!!!&quot;, false);
1305 
1306         // Supplementary character test
1307         String t = toSupplementaries(&quot;test&quot;);
1308         String b = toSupplementaries(&quot;blah&quot;);
1309         check(&quot;....$&quot;, flags1, t+&quot;\n&quot;, t, true);
1310         check(&quot;....$&quot;, flags1, t+&quot;\r\n&quot;, t, true);
1311         check(&quot;.....$&quot;, flags1, t+&quot;\n&quot;, t+&quot;\n&quot;, true);
1312         check(&quot;.....$&quot;, flags1, t+&quot;\u0085&quot;, t+&quot;\u0085&quot;, true);
1313         check(&quot;....$&quot;, flags1, t+&quot;\u0085&quot;, t, true);
1314 
1315         check(&quot;....$&quot;, flags2, t+&quot;\n&quot;, t, true);
1316         check(&quot;.....$&quot;, flags2, t+&quot;\n&quot;, t+&quot;\n&quot;, true);
1317         check(&quot;.....$&quot;, flags2, t+&quot;\u0085&quot;, t+&quot;\u0085&quot;, true);
1318         check(&quot;....$&quot;, flags2, t+&quot;\u0085&quot;, toSupplementaries(&quot;est\u0085&quot;), true);
1319 
1320         check(&quot;....$.&quot;+b, flags3, t+&quot;\n&quot;+b, t+&quot;\n&quot;+b, true);
1321         check(&quot;.....$.&quot;+b, flags3, t+&quot;\n\n&quot;+b, t+&quot;\n\n&quot;+b, true);
1322         check(&quot;....$&quot;+b, flags3, t+&quot;\n&quot;+b, &quot;!!!!&quot;, false);
1323         check(&quot;.....$&quot;+b, flags3, t+&quot;\n&quot;+b, &quot;!!!!&quot;, false);
1324 
1325         report(&quot;Dollar at End&quot;);
1326     }
1327 
1328     // This test is for 4711773
1329     private static void multilineDollarTest() throws Exception {
1330         Pattern findCR = Pattern.compile(&quot;$&quot;, Pattern.MULTILINE);
1331         Matcher matcher = findCR.matcher(&quot;first bit\nsecond bit&quot;);
1332         matcher.find();
1333         if (matcher.start(0) != 9)
1334             failCount++;
1335         matcher.find();
1336         if (matcher.start(0) != 20)
1337             failCount++;
1338 
1339         // Supplementary character test
1340         matcher = findCR.matcher(toSupplementaries(&quot;first  bit\n second  bit&quot;)); // double BMP chars
1341         matcher.find();
1342         if (matcher.start(0) != 9*2)
1343             failCount++;
1344         matcher.find();
1345         if (matcher.start(0) != 20*2)
1346             failCount++;
1347 
1348         report(&quot;Multiline Dollar&quot;);
1349     }
1350 
1351     private static void reluctantRepetitionTest() throws Exception {
1352         Pattern p = Pattern.compile(&quot;1(\\s\\S+?){1,3}?[\\s,]2&quot;);
1353         check(p, &quot;1 word word word 2&quot;, true);
1354         check(p, &quot;1 wor wo w 2&quot;, true);
1355         check(p, &quot;1 word word 2&quot;, true);
1356         check(p, &quot;1 word 2&quot;, true);
1357         check(p, &quot;1 wo w w 2&quot;, true);
1358         check(p, &quot;1 wo w 2&quot;, true);
1359         check(p, &quot;1 wor w 2&quot;, true);
1360 
1361         p = Pattern.compile(&quot;([a-z])+?c&quot;);
1362         Matcher m = p.matcher(&quot;ababcdefdec&quot;);
1363         check(m, &quot;ababc&quot;);
1364 
1365         // Supplementary character test
1366         p = Pattern.compile(toSupplementaries(&quot;([a-z])+?c&quot;));
1367         m = p.matcher(toSupplementaries(&quot;ababcdefdec&quot;));
1368         check(m, toSupplementaries(&quot;ababc&quot;));
1369 
1370         report(&quot;Reluctant Repetition&quot;);
1371     }
1372 
1373     private static Pattern serializedPattern(Pattern p) throws Exception {
1374         ByteArrayOutputStream baos = new ByteArrayOutputStream();
1375         ObjectOutputStream oos = new ObjectOutputStream(baos);
1376         oos.writeObject(p);
1377         oos.close();
1378         try (ObjectInputStream ois = new ObjectInputStream(
1379                 new ByteArrayInputStream(baos.toByteArray()))) {
1380             return (Pattern)ois.readObject();
1381         }
1382     }
1383 
1384     private static void serializeTest() throws Exception {
1385         String patternStr = &quot;(b)&quot;;
1386         String matchStr = &quot;b&quot;;
1387         Pattern pattern = Pattern.compile(patternStr);
1388         Pattern serializedPattern = serializedPattern(pattern);
1389         Matcher matcher = serializedPattern.matcher(matchStr);
1390         if (!matcher.matches())
1391             failCount++;
1392         if (matcher.groupCount() != 1)
1393             failCount++;
1394 
1395         pattern = Pattern.compile(&quot;a(?-i)b&quot;, Pattern.CASE_INSENSITIVE);
1396         serializedPattern = serializedPattern(pattern);
1397         if (!serializedPattern.matcher(&quot;Ab&quot;).matches())
1398             failCount++;
1399         if (serializedPattern.matcher(&quot;AB&quot;).matches())
1400             failCount++;
1401 
1402         report(&quot;Serialization&quot;);
1403     }
1404 
1405     private static void gTest() {
1406         Pattern pattern = Pattern.compile(&quot;\\G\\w&quot;);
1407         Matcher matcher = pattern.matcher(&quot;abc#x#x&quot;);
1408         matcher.find();
1409         matcher.find();
1410         matcher.find();
1411         if (matcher.find())
1412             failCount++;
1413 
1414         pattern = Pattern.compile(&quot;\\GA*&quot;);
1415         matcher = pattern.matcher(&quot;1A2AA3&quot;);
1416         matcher.find();
1417         if (matcher.find())
1418             failCount++;
1419 
1420         pattern = Pattern.compile(&quot;\\GA*&quot;);
1421         matcher = pattern.matcher(&quot;1A2AA3&quot;);
1422         if (!matcher.find(1))
1423             failCount++;
1424         matcher.find();
1425         if (matcher.find())
1426             failCount++;
1427 
1428         report(&quot;\\G&quot;);
1429     }
1430 
1431     private static void zTest() {
1432         Pattern pattern = Pattern.compile(&quot;foo\\Z&quot;);
1433         // Positives
1434         check(pattern, &quot;foo\u0085&quot;, true);
1435         check(pattern, &quot;foo\u2028&quot;, true);
1436         check(pattern, &quot;foo\u2029&quot;, true);
1437         check(pattern, &quot;foo\n&quot;, true);
1438         check(pattern, &quot;foo\r&quot;, true);
1439         check(pattern, &quot;foo\r\n&quot;, true);
1440         // Negatives
1441         check(pattern, &quot;fooo&quot;, false);
1442         check(pattern, &quot;foo\n\r&quot;, false);
1443 
1444         pattern = Pattern.compile(&quot;foo\\Z&quot;, Pattern.UNIX_LINES);
1445         // Positives
1446         check(pattern, &quot;foo&quot;, true);
1447         check(pattern, &quot;foo\n&quot;, true);
1448         // Negatives
1449         check(pattern, &quot;foo\r&quot;, false);
1450         check(pattern, &quot;foo\u0085&quot;, false);
1451         check(pattern, &quot;foo\u2028&quot;, false);
1452         check(pattern, &quot;foo\u2029&quot;, false);
1453 
1454         report(&quot;\\Z&quot;);
1455     }
1456 
1457     private static void replaceFirstTest() {
1458         Pattern pattern = Pattern.compile(&quot;(ab)(c*)&quot;);
1459         Matcher matcher = pattern.matcher(&quot;abccczzzabcczzzabccc&quot;);
1460         if (!matcher.replaceFirst(&quot;test&quot;).equals(&quot;testzzzabcczzzabccc&quot;))
1461             failCount++;
1462 
1463         matcher.reset(&quot;zzzabccczzzabcczzzabccczzz&quot;);
1464         if (!matcher.replaceFirst(&quot;test&quot;).equals(&quot;zzztestzzzabcczzzabccczzz&quot;))
1465             failCount++;
1466 
1467         matcher.reset(&quot;zzzabccczzzabcczzzabccczzz&quot;);
1468         String result = matcher.replaceFirst(&quot;$1&quot;);
1469         if (!result.equals(&quot;zzzabzzzabcczzzabccczzz&quot;))
1470             failCount++;
1471 
1472         matcher.reset(&quot;zzzabccczzzabcczzzabccczzz&quot;);
1473         result = matcher.replaceFirst(&quot;$2&quot;);
1474         if (!result.equals(&quot;zzzccczzzabcczzzabccczzz&quot;))
1475             failCount++;
1476 
1477         pattern = Pattern.compile(&quot;a*&quot;);
1478         matcher = pattern.matcher(&quot;aaaaaaaaaa&quot;);
1479         if (!matcher.replaceFirst(&quot;test&quot;).equals(&quot;test&quot;))
1480             failCount++;
1481 
1482         pattern = Pattern.compile(&quot;a+&quot;);
1483         matcher = pattern.matcher(&quot;zzzaaaaaaaaaa&quot;);
1484         if (!matcher.replaceFirst(&quot;test&quot;).equals(&quot;zzztest&quot;))
1485             failCount++;
1486 
1487         // Supplementary character test
1488         pattern = Pattern.compile(toSupplementaries(&quot;(ab)(c*)&quot;));
1489         matcher = pattern.matcher(toSupplementaries(&quot;abccczzzabcczzzabccc&quot;));
1490         if (!matcher.replaceFirst(toSupplementaries(&quot;test&quot;))
1491                 .equals(toSupplementaries(&quot;testzzzabcczzzabccc&quot;)))
1492             failCount++;
1493 
1494         matcher.reset(toSupplementaries(&quot;zzzabccczzzabcczzzabccczzz&quot;));
1495         if (!matcher.replaceFirst(toSupplementaries(&quot;test&quot;)).
1496             equals(toSupplementaries(&quot;zzztestzzzabcczzzabccczzz&quot;)))
1497             failCount++;
1498 
1499         matcher.reset(toSupplementaries(&quot;zzzabccczzzabcczzzabccczzz&quot;));
1500         result = matcher.replaceFirst(&quot;$1&quot;);
1501         if (!result.equals(toSupplementaries(&quot;zzzabzzzabcczzzabccczzz&quot;)))
1502             failCount++;
1503 
1504         matcher.reset(toSupplementaries(&quot;zzzabccczzzabcczzzabccczzz&quot;));
1505         result = matcher.replaceFirst(&quot;$2&quot;);
1506         if (!result.equals(toSupplementaries(&quot;zzzccczzzabcczzzabccczzz&quot;)))
1507             failCount++;
1508 
1509         pattern = Pattern.compile(toSupplementaries(&quot;a*&quot;));
1510         matcher = pattern.matcher(toSupplementaries(&quot;aaaaaaaaaa&quot;));
1511         if (!matcher.replaceFirst(toSupplementaries(&quot;test&quot;)).equals(toSupplementaries(&quot;test&quot;)))
1512             failCount++;
1513 
1514         pattern = Pattern.compile(toSupplementaries(&quot;a+&quot;));
1515         matcher = pattern.matcher(toSupplementaries(&quot;zzzaaaaaaaaaa&quot;));
1516         if (!matcher.replaceFirst(toSupplementaries(&quot;test&quot;)).equals(toSupplementaries(&quot;zzztest&quot;)))
1517             failCount++;
1518 
1519         report(&quot;Replace First&quot;);
1520     }
1521 
1522     private static void unixLinesTest() {
1523         Pattern pattern = Pattern.compile(&quot;.*&quot;);
1524         Matcher matcher = pattern.matcher(&quot;aa\u2028blah&quot;);
1525         matcher.find();
1526         if (!matcher.group(0).equals(&quot;aa&quot;))
1527             failCount++;
1528 
1529         pattern = Pattern.compile(&quot;.*&quot;, Pattern.UNIX_LINES);
1530         matcher = pattern.matcher(&quot;aa\u2028blah&quot;);
1531         matcher.find();
1532         if (!matcher.group(0).equals(&quot;aa\u2028blah&quot;))
1533             failCount++;
1534 
1535         pattern = Pattern.compile(&quot;[az]$&quot;,
1536                                   Pattern.MULTILINE | Pattern.UNIX_LINES);
1537         matcher = pattern.matcher(&quot;aa\u2028zz&quot;);
1538         check(matcher, &quot;a\u2028&quot;, false);
1539 
1540         // Supplementary character test
1541         pattern = Pattern.compile(&quot;.*&quot;);
1542         matcher = pattern.matcher(toSupplementaries(&quot;aa\u2028blah&quot;));
1543         matcher.find();
1544         if (!matcher.group(0).equals(toSupplementaries(&quot;aa&quot;)))
1545             failCount++;
1546 
1547         pattern = Pattern.compile(&quot;.*&quot;, Pattern.UNIX_LINES);
1548         matcher = pattern.matcher(toSupplementaries(&quot;aa\u2028blah&quot;));
1549         matcher.find();
1550         if (!matcher.group(0).equals(toSupplementaries(&quot;aa\u2028blah&quot;)))
1551             failCount++;
1552 
1553         pattern = Pattern.compile(toSupplementaries(&quot;[az]$&quot;),
1554                                   Pattern.MULTILINE | Pattern.UNIX_LINES);
1555         matcher = pattern.matcher(toSupplementaries(&quot;aa\u2028zz&quot;));
1556         check(matcher, toSupplementaries(&quot;a\u2028&quot;), false);
1557 
1558         report(&quot;Unix Lines&quot;);
1559     }
1560 
1561     private static void commentsTest() {
1562         int flags = Pattern.COMMENTS;
1563 
1564         Pattern pattern = Pattern.compile(&quot;aa \\# aa&quot;, flags);
1565         Matcher matcher = pattern.matcher(&quot;aa#aa&quot;);
1566         if (!matcher.matches())
1567             failCount++;
1568 
1569         pattern = Pattern.compile(&quot;aa  # blah&quot;, flags);
1570         matcher = pattern.matcher(&quot;aa&quot;);
1571         if (!matcher.matches())
1572             failCount++;
1573 
1574         pattern = Pattern.compile(&quot;aa blah&quot;, flags);
1575         matcher = pattern.matcher(&quot;aablah&quot;);
1576         if (!matcher.matches())
1577              failCount++;
1578 
1579         pattern = Pattern.compile(&quot;aa  # blah blech  &quot;, flags);
1580         matcher = pattern.matcher(&quot;aa&quot;);
1581         if (!matcher.matches())
1582             failCount++;
1583 
1584         pattern = Pattern.compile(&quot;aa  # blah\n  &quot;, flags);
1585         matcher = pattern.matcher(&quot;aa&quot;);
1586         if (!matcher.matches())
1587             failCount++;
1588 
1589         pattern = Pattern.compile(&quot;aa  # blah\nbc # blech&quot;, flags);
1590         matcher = pattern.matcher(&quot;aabc&quot;);
1591         if (!matcher.matches())
1592              failCount++;
1593 
1594         pattern = Pattern.compile(&quot;aa  # blah\nbc# blech&quot;, flags);
1595         matcher = pattern.matcher(&quot;aabc&quot;);
1596         if (!matcher.matches())
1597              failCount++;
1598 
1599         pattern = Pattern.compile(&quot;aa  # blah\nbc\\# blech&quot;, flags);
1600         matcher = pattern.matcher(&quot;aabc#blech&quot;);
1601         if (!matcher.matches())
1602              failCount++;
1603 
1604         // Supplementary character test
1605         pattern = Pattern.compile(toSupplementaries(&quot;aa \\# aa&quot;), flags);
1606         matcher = pattern.matcher(toSupplementaries(&quot;aa#aa&quot;));
1607         if (!matcher.matches())
1608             failCount++;
1609 
1610         pattern = Pattern.compile(toSupplementaries(&quot;aa  # blah&quot;), flags);
1611         matcher = pattern.matcher(toSupplementaries(&quot;aa&quot;));
1612         if (!matcher.matches())
1613             failCount++;
1614 
1615         pattern = Pattern.compile(toSupplementaries(&quot;aa blah&quot;), flags);
1616         matcher = pattern.matcher(toSupplementaries(&quot;aablah&quot;));
1617         if (!matcher.matches())
1618              failCount++;
1619 
1620         pattern = Pattern.compile(toSupplementaries(&quot;aa  # blah blech  &quot;), flags);
1621         matcher = pattern.matcher(toSupplementaries(&quot;aa&quot;));
1622         if (!matcher.matches())
1623             failCount++;
1624 
1625         pattern = Pattern.compile(toSupplementaries(&quot;aa  # blah\n  &quot;), flags);
1626         matcher = pattern.matcher(toSupplementaries(&quot;aa&quot;));
1627         if (!matcher.matches())
1628             failCount++;
1629 
1630         pattern = Pattern.compile(toSupplementaries(&quot;aa  # blah\nbc # blech&quot;), flags);
1631         matcher = pattern.matcher(toSupplementaries(&quot;aabc&quot;));
1632         if (!matcher.matches())
1633              failCount++;
1634 
1635         pattern = Pattern.compile(toSupplementaries(&quot;aa  # blah\nbc# blech&quot;), flags);
1636         matcher = pattern.matcher(toSupplementaries(&quot;aabc&quot;));
1637         if (!matcher.matches())
1638              failCount++;
1639 
1640         pattern = Pattern.compile(toSupplementaries(&quot;aa  # blah\nbc\\# blech&quot;), flags);
1641         matcher = pattern.matcher(toSupplementaries(&quot;aabc#blech&quot;));
1642         if (!matcher.matches())
1643              failCount++;
1644 
1645         report(&quot;Comments&quot;);
1646     }
1647 
1648     private static void caseFoldingTest() { // bug 4504687
1649         int flags = Pattern.CASE_INSENSITIVE | Pattern.UNICODE_CASE;
1650         Pattern pattern = Pattern.compile(&quot;aa&quot;, flags);
1651         Matcher matcher = pattern.matcher(&quot;ab&quot;);
1652         if (matcher.matches())
1653             failCount++;
1654 
1655         pattern = Pattern.compile(&quot;aA&quot;, flags);
1656         matcher = pattern.matcher(&quot;ab&quot;);
1657         if (matcher.matches())
1658             failCount++;
1659 
1660         pattern = Pattern.compile(&quot;aa&quot;, flags);
1661         matcher = pattern.matcher(&quot;aB&quot;);
1662         if (matcher.matches())
1663             failCount++;
1664         matcher = pattern.matcher(&quot;Ab&quot;);
1665         if (matcher.matches())
1666             failCount++;
1667 
1668         // ASCII               &quot;a&quot;
1669         // Latin-1 Supplement  &quot;a&quot; + grave
1670         // Cyrillic            &quot;a&quot;
1671         String[] patterns = new String[] {
1672             //single
1673             &quot;a&quot;, &quot;\u00e0&quot;, &quot;\u0430&quot;,
1674             //slice
1675             &quot;ab&quot;, &quot;\u00e0\u00e1&quot;, &quot;\u0430\u0431&quot;,
1676             //class single
1677             &quot;[a]&quot;, &quot;[\u00e0]&quot;, &quot;[\u0430]&quot;,
1678             //class range
1679             &quot;[a-b]&quot;, &quot;[\u00e0-\u00e5]&quot;, &quot;[\u0430-\u0431]&quot;,
1680             //back reference
1681             &quot;(a)\\1&quot;, &quot;(\u00e0)\\1&quot;, &quot;(\u0430)\\1&quot;
1682         };
1683 
1684         String[] texts = new String[] {
1685             &quot;A&quot;, &quot;\u00c0&quot;, &quot;\u0410&quot;,
1686             &quot;AB&quot;, &quot;\u00c0\u00c1&quot;, &quot;\u0410\u0411&quot;,
1687             &quot;A&quot;, &quot;\u00c0&quot;, &quot;\u0410&quot;,
1688             &quot;B&quot;, &quot;\u00c2&quot;, &quot;\u0411&quot;,
1689             &quot;aA&quot;, &quot;\u00e0\u00c0&quot;, &quot;\u0430\u0410&quot;
1690         };
1691 
1692         boolean[] expected = new boolean[] {
1693             true, false, false,
1694             true, false, false,
1695             true, false, false,
1696             true, false, false,
1697             true, false, false
1698         };
1699 
1700         flags = Pattern.CASE_INSENSITIVE;
1701         for (int i = 0; i &lt; patterns.length; i++) {
1702             pattern = Pattern.compile(patterns[i], flags);
1703             matcher = pattern.matcher(texts[i]);
1704             if (matcher.matches() != expected[i]) {
1705                 System.out.println(&quot;&lt;1&gt; Failed at &quot; + i);
1706                 failCount++;
1707             }
1708         }
1709 
1710         flags = Pattern.CASE_INSENSITIVE | Pattern.UNICODE_CASE;
1711         for (int i = 0; i &lt; patterns.length; i++) {
1712             pattern = Pattern.compile(patterns[i], flags);
1713             matcher = pattern.matcher(texts[i]);
1714             if (!matcher.matches()) {
1715                 System.out.println(&quot;&lt;2&gt; Failed at &quot; + i);
1716                 failCount++;
1717             }
1718         }
1719         // flag unicode_case alone should do nothing
1720         flags = Pattern.UNICODE_CASE;
1721         for (int i = 0; i &lt; patterns.length; i++) {
1722             pattern = Pattern.compile(patterns[i], flags);
1723             matcher = pattern.matcher(texts[i]);
1724             if (matcher.matches()) {
1725                 System.out.println(&quot;&lt;3&gt; Failed at &quot; + i);
1726                 failCount++;
1727             }
1728         }
1729 
1730         // Special cases: i, I, u+0131 and u+0130
1731         flags = Pattern.UNICODE_CASE | Pattern.CASE_INSENSITIVE;
1732         pattern = Pattern.compile(&quot;[h-j]+&quot;, flags);
1733         if (!pattern.matcher(&quot;\u0131\u0130&quot;).matches())
1734             failCount++;
1735         report(&quot;Case Folding&quot;);
1736     }
1737 
1738     private static void appendTest() {
1739         Pattern pattern = Pattern.compile(&quot;(ab)(cd)&quot;);
1740         Matcher matcher = pattern.matcher(&quot;abcd&quot;);
1741         String result = matcher.replaceAll(&quot;$2$1&quot;);
1742         if (!result.equals(&quot;cdab&quot;))
1743             failCount++;
1744 
1745         String  s1 = &quot;Swap all: first = 123, second = 456&quot;;
1746         String  s2 = &quot;Swap one: first = 123, second = 456&quot;;
1747         String  r  = &quot;$3$2$1&quot;;
1748         pattern = Pattern.compile(&quot;([a-z]+)( *= *)([0-9]+)&quot;);
1749         matcher = pattern.matcher(s1);
1750 
1751         result = matcher.replaceAll(r);
1752         if (!result.equals(&quot;Swap all: 123 = first, 456 = second&quot;))
1753             failCount++;
1754 
1755         matcher = pattern.matcher(s2);
1756 
1757         if (matcher.find()) {
1758             StringBuffer sb = new StringBuffer();
1759             matcher.appendReplacement(sb, r);
1760             matcher.appendTail(sb);
1761             result = sb.toString();
1762             if (!result.equals(&quot;Swap one: 123 = first, second = 456&quot;))
1763                 failCount++;
1764         }
1765 
1766         // Supplementary character test
1767         pattern = Pattern.compile(toSupplementaries(&quot;(ab)(cd)&quot;));
1768         matcher = pattern.matcher(toSupplementaries(&quot;abcd&quot;));
1769         result = matcher.replaceAll(&quot;$2$1&quot;);
1770         if (!result.equals(toSupplementaries(&quot;cdab&quot;)))
1771             failCount++;
1772 
1773         s1 = toSupplementaries(&quot;Swap all: first = 123, second = 456&quot;);
1774         s2 = toSupplementaries(&quot;Swap one: first = 123, second = 456&quot;);
1775         r  = toSupplementaries(&quot;$3$2$1&quot;);
1776         pattern = Pattern.compile(toSupplementaries(&quot;([a-z]+)( *= *)([0-9]+)&quot;));
1777         matcher = pattern.matcher(s1);
1778 
1779         result = matcher.replaceAll(r);
1780         if (!result.equals(toSupplementaries(&quot;Swap all: 123 = first, 456 = second&quot;)))
1781             failCount++;
1782 
1783         matcher = pattern.matcher(s2);
1784 
1785         if (matcher.find()) {
1786             StringBuffer sb = new StringBuffer();
1787             matcher.appendReplacement(sb, r);
1788             matcher.appendTail(sb);
1789             result = sb.toString();
1790             if (!result.equals(toSupplementaries(&quot;Swap one: 123 = first, second = 456&quot;)))
1791                 failCount++;
1792         }
1793         report(&quot;Append&quot;);
1794     }
1795 
1796     private static void splitTest() {
1797         Pattern pattern = Pattern.compile(&quot;:&quot;);
1798         String[] result = pattern.split(&quot;foo:and:boo&quot;, 2);
1799         if (!result[0].equals(&quot;foo&quot;))
1800             failCount++;
1801         if (!result[1].equals(&quot;and:boo&quot;))
1802             failCount++;
1803         // Supplementary character test
1804         Pattern patternX = Pattern.compile(toSupplementaries(&quot;X&quot;));
1805         result = patternX.split(toSupplementaries(&quot;fooXandXboo&quot;), 2);
1806         if (!result[0].equals(toSupplementaries(&quot;foo&quot;)))
1807             failCount++;
1808         if (!result[1].equals(toSupplementaries(&quot;andXboo&quot;)))
1809             failCount++;
1810 
1811         CharBuffer cb = CharBuffer.allocate(100);
1812         cb.put(&quot;foo:and:boo&quot;);
1813         cb.flip();
1814         result = pattern.split(cb);
1815         if (!result[0].equals(&quot;foo&quot;))
1816             failCount++;
1817         if (!result[1].equals(&quot;and&quot;))
1818             failCount++;
1819         if (!result[2].equals(&quot;boo&quot;))
1820             failCount++;
1821 
1822         // Supplementary character test
1823         CharBuffer cbs = CharBuffer.allocate(100);
1824         cbs.put(toSupplementaries(&quot;fooXandXboo&quot;));
1825         cbs.flip();
1826         result = patternX.split(cbs);
1827         if (!result[0].equals(toSupplementaries(&quot;foo&quot;)))
1828             failCount++;
1829         if (!result[1].equals(toSupplementaries(&quot;and&quot;)))
1830             failCount++;
1831         if (!result[2].equals(toSupplementaries(&quot;boo&quot;)))
1832             failCount++;
1833 
1834         String source = &quot;0123456789&quot;;
1835         for (int limit=-2; limit&lt;3; limit++) {
1836             for (int x=0; x&lt;10; x++) {
1837                 result = source.split(Integer.toString(x), limit);
1838                 int expectedLength = limit &lt; 1 ? 2 : limit;
1839 
1840                 if ((limit == 0) &amp;&amp; (x == 9)) {
1841                     // expected dropping of &quot;&quot;
1842                     if (result.length != 1)
1843                         failCount++;
1844                     if (!result[0].equals(&quot;012345678&quot;)) {
1845                         failCount++;
1846                     }
1847                 } else {
1848                     if (result.length != expectedLength) {
1849                         failCount++;
1850                     }
1851                     if (!result[0].equals(source.substring(0,x))) {
1852                         if (limit != 1) {
1853                             failCount++;
1854                         } else {
1855                             if (!result[0].equals(source.substring(0,10))) {
1856                                 failCount++;
1857                             }
1858                         }
1859                     }
1860                     if (expectedLength &gt; 1) { // Check segment 2
1861                         if (!result[1].equals(source.substring(x+1,10)))
1862                             failCount++;
1863                     }
1864                 }
1865             }
1866         }
1867         // Check the case for no match found
1868         for (int limit=-2; limit&lt;3; limit++) {
1869             result = source.split(&quot;e&quot;, limit);
1870             if (result.length != 1)
1871                 failCount++;
1872             if (!result[0].equals(source))
1873                 failCount++;
1874         }
1875         // Check the case for limit == 0, source = &quot;&quot;;
1876         // split() now returns 0-length for empty source &quot;&quot; see #6559590
1877         source = &quot;&quot;;
1878         result = source.split(&quot;e&quot;, 0);
1879         if (result.length != 1)
1880             failCount++;
1881         if (!result[0].equals(source))
1882             failCount++;
1883 
1884         // Check both split() and splitAsStraem(), especially for zero-lenth
1885         // input and zero-lenth match cases
1886         String[][] input = new String[][] {
1887             { &quot; &quot;,           &quot;Abc Efg Hij&quot; },   // normal non-zero-match
1888             { &quot; &quot;,           &quot; Abc Efg Hij&quot; },  // leading empty str for non-zero-match
1889             { &quot; &quot;,           &quot;Abc  Efg Hij&quot; },  // non-zero-match in the middle
1890             { &quot;(?=\\p{Lu})&quot;, &quot;AbcEfgHij&quot; },     // no leading empty str for zero-match
1891             { &quot;(?=\\p{Lu})&quot;, &quot;AbcEfg&quot; },
1892             { &quot;(?=\\p{Lu})&quot;, &quot;Abc&quot; },
1893             { &quot; &quot;,           &quot;&quot; },              // zero-length input
1894             { &quot;.*&quot;,          &quot;&quot; },
1895 
1896             // some tests from PatternStreamTest.java
1897             { &quot;4&quot;,       &quot;awgqwefg1fefw4vssv1vvv1&quot; },
1898             { &quot;\u00a3a&quot;, &quot;afbfq\u00a3abgwgb\u00a3awngnwggw\u00a3a\u00a3ahjrnhneerh&quot; },
1899             { &quot;1&quot;,       &quot;awgqwefg1fefw4vssv1vvv1&quot; },
1900             { &quot;1&quot;,       &quot;a\u4ebafg1fefw\u4eba4\u9f9cvssv\u9f9c1v\u672c\u672cvv&quot; },
1901             { &quot;\u56da&quot;,  &quot;1\u56da23\u56da456\u56da7890&quot; },
1902             { &quot;\u56da&quot;,  &quot;1\u56da23\u9f9c\u672c\u672c\u56da456\u56da\u9f9c\u672c7890&quot; },
1903             { &quot;\u56da&quot;,  &quot;&quot; },
1904             { &quot;[ \t,:.]&quot;,&quot;This is,testing: with\tdifferent separators.&quot; }, //multiple septs
1905             { &quot;o&quot;,       &quot;boo:and:foo&quot; },
1906             { &quot;o&quot;,       &quot;booooo:and:fooooo&quot; },
1907             { &quot;o&quot;,       &quot;fooooo:&quot; },
1908         };
1909 
1910         String[][] expected = new String[][] {
1911             { &quot;Abc&quot;, &quot;Efg&quot;, &quot;Hij&quot; },
1912             { &quot;&quot;, &quot;Abc&quot;, &quot;Efg&quot;, &quot;Hij&quot; },
1913             { &quot;Abc&quot;, &quot;&quot;, &quot;Efg&quot;, &quot;Hij&quot; },
1914             { &quot;Abc&quot;, &quot;Efg&quot;, &quot;Hij&quot; },
1915             { &quot;Abc&quot;, &quot;Efg&quot; },
1916             { &quot;Abc&quot; },
1917             { &quot;&quot; },
1918             { &quot;&quot; },
1919 
1920             { &quot;awgqwefg1fefw&quot;, &quot;vssv1vvv1&quot; },
1921             { &quot;afbfq&quot;, &quot;bgwgb&quot;, &quot;wngnwggw&quot;, &quot;&quot;, &quot;hjrnhneerh&quot; },
1922             { &quot;awgqwefg&quot;, &quot;fefw4vssv&quot;, &quot;vvv&quot; },
1923             { &quot;a\u4ebafg&quot;, &quot;fefw\u4eba4\u9f9cvssv\u9f9c&quot;, &quot;v\u672c\u672cvv&quot; },
1924             { &quot;1&quot;, &quot;23&quot;, &quot;456&quot;, &quot;7890&quot; },
1925             { &quot;1&quot;, &quot;23\u9f9c\u672c\u672c&quot;, &quot;456&quot;, &quot;\u9f9c\u672c7890&quot; },
1926             { &quot;&quot; },
1927             { &quot;This&quot;, &quot;is&quot;, &quot;testing&quot;, &quot;&quot;, &quot;with&quot;, &quot;different&quot;, &quot;separators&quot; },
1928             { &quot;b&quot;, &quot;&quot;, &quot;:and:f&quot; },
1929             { &quot;b&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;:and:f&quot; },
1930             { &quot;f&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;:&quot; },
1931         };
1932         for (int i = 0; i &lt; input.length; i++) {
1933             pattern = Pattern.compile(input[i][0]);
1934             if (!Arrays.equals(pattern.split(input[i][1]), expected[i])) {
1935                 failCount++;
1936             }
1937             if (input[i][1].length() &gt; 0 &amp;&amp;  // splitAsStream() return empty resulting
1938                                              // array for zero-length input for now
1939                 !Arrays.equals(pattern.splitAsStream(input[i][1]).toArray(),
1940                                expected[i])) {
1941                 failCount++;
1942             }
1943         }
1944         report(&quot;Split&quot;);
1945     }
1946 
1947     private static void negationTest() {
1948         Pattern pattern = Pattern.compile(&quot;[\\[@^]+&quot;);
1949         Matcher matcher = pattern.matcher(&quot;@@@@[[[[^^^^&quot;);
1950         if (!matcher.find())
1951             failCount++;
1952         if (!matcher.group(0).equals(&quot;@@@@[[[[^^^^&quot;))
1953             failCount++;
1954         pattern = Pattern.compile(&quot;[@\\[^]+&quot;);
1955         matcher = pattern.matcher(&quot;@@@@[[[[^^^^&quot;);
1956         if (!matcher.find())
1957             failCount++;
1958         if (!matcher.group(0).equals(&quot;@@@@[[[[^^^^&quot;))
1959             failCount++;
1960         pattern = Pattern.compile(&quot;[@\\[^@]+&quot;);
1961         matcher = pattern.matcher(&quot;@@@@[[[[^^^^&quot;);
1962         if (!matcher.find())
1963             failCount++;
1964         if (!matcher.group(0).equals(&quot;@@@@[[[[^^^^&quot;))
1965             failCount++;
1966 
1967         pattern = Pattern.compile(&quot;\\)&quot;);
1968         matcher = pattern.matcher(&quot;xxx)xxx&quot;);
1969         if (!matcher.find())
1970             failCount++;
1971 
1972         report(&quot;Negation&quot;);
1973     }
1974 
1975     private static void ampersandTest() {
1976         Pattern pattern = Pattern.compile(&quot;[&amp;@]+&quot;);
1977         check(pattern, &quot;@@@@&amp;&amp;&amp;&amp;&quot;, true);
1978 
1979         pattern = Pattern.compile(&quot;[@&amp;]+&quot;);
1980         check(pattern, &quot;@@@@&amp;&amp;&amp;&amp;&quot;, true);
1981 
1982         pattern = Pattern.compile(&quot;[@\\&amp;]+&quot;);
1983         check(pattern, &quot;@@@@&amp;&amp;&amp;&amp;&quot;, true);
1984 
1985         report(&quot;Ampersand&quot;);
1986     }
1987 
1988     private static void octalTest() throws Exception {
1989         Pattern pattern = Pattern.compile(&quot;\\u0007&quot;);
1990         Matcher matcher = pattern.matcher(&quot;\u0007&quot;);
1991         if (!matcher.matches())
1992             failCount++;
1993         pattern = Pattern.compile(&quot;\\07&quot;);
1994         matcher = pattern.matcher(&quot;\u0007&quot;);
1995         if (!matcher.matches())
1996             failCount++;
1997         pattern = Pattern.compile(&quot;\\007&quot;);
1998         matcher = pattern.matcher(&quot;\u0007&quot;);
1999         if (!matcher.matches())
2000             failCount++;
2001         pattern = Pattern.compile(&quot;\\0007&quot;);
2002         matcher = pattern.matcher(&quot;\u0007&quot;);
2003         if (!matcher.matches())
2004             failCount++;
2005         pattern = Pattern.compile(&quot;\\040&quot;);
2006         matcher = pattern.matcher(&quot;\u0020&quot;);
2007         if (!matcher.matches())
2008             failCount++;
2009         pattern = Pattern.compile(&quot;\\0403&quot;);
2010         matcher = pattern.matcher(&quot;\u00203&quot;);
2011         if (!matcher.matches())
2012             failCount++;
2013         pattern = Pattern.compile(&quot;\\0103&quot;);
2014         matcher = pattern.matcher(&quot;\u0043&quot;);
2015         if (!matcher.matches())
2016             failCount++;
2017 
2018         report(&quot;Octal&quot;);
2019     }
2020 
2021     private static void longPatternTest() throws Exception {
2022         try {
2023             Pattern pattern = Pattern.compile(
2024                 &quot;a 32-character-long pattern xxxx&quot;);
2025             pattern = Pattern.compile(&quot;a 33-character-long pattern xxxxx&quot;);
2026             pattern = Pattern.compile(&quot;a thirty four character long regex&quot;);
2027             StringBuffer patternToBe = new StringBuffer(101);
2028             for (int i=0; i&lt;100; i++)
2029                 patternToBe.append((char)(97 + i%26));
2030             pattern = Pattern.compile(patternToBe.toString());
2031         } catch (PatternSyntaxException e) {
2032             failCount++;
2033         }
2034 
2035         // Supplementary character test
2036         try {
2037             Pattern pattern = Pattern.compile(
2038                 toSupplementaries(&quot;a 32-character-long pattern xxxx&quot;));
2039             pattern = Pattern.compile(toSupplementaries(&quot;a 33-character-long pattern xxxxx&quot;));
2040             pattern = Pattern.compile(toSupplementaries(&quot;a thirty four character long regex&quot;));
2041             StringBuffer patternToBe = new StringBuffer(101*2);
2042             for (int i=0; i&lt;100; i++)
2043                 patternToBe.append(Character.toChars(Character.MIN_SUPPLEMENTARY_CODE_POINT
2044                                                      + 97 + i%26));
2045             pattern = Pattern.compile(patternToBe.toString());
2046         } catch (PatternSyntaxException e) {
2047             failCount++;
2048         }
2049         report(&quot;LongPattern&quot;);
2050     }
2051 
2052     private static void group0Test() throws Exception {
2053         Pattern pattern = Pattern.compile(&quot;(tes)ting&quot;);
2054         Matcher matcher = pattern.matcher(&quot;testing&quot;);
2055         check(matcher, &quot;testing&quot;);
2056 
2057         matcher.reset(&quot;testing&quot;);
2058         if (matcher.lookingAt()) {
2059             if (!matcher.group(0).equals(&quot;testing&quot;))
2060                 failCount++;
2061         } else {
2062             failCount++;
2063         }
2064 
2065         matcher.reset(&quot;testing&quot;);
2066         if (matcher.matches()) {
2067             if (!matcher.group(0).equals(&quot;testing&quot;))
2068                 failCount++;
2069         } else {
2070             failCount++;
2071         }
2072 
2073         pattern = Pattern.compile(&quot;(tes)ting&quot;);
2074         matcher = pattern.matcher(&quot;testing&quot;);
2075         if (matcher.lookingAt()) {
2076             if (!matcher.group(0).equals(&quot;testing&quot;))
2077                 failCount++;
2078         } else {
2079             failCount++;
2080         }
2081 
2082         pattern = Pattern.compile(&quot;^(tes)ting&quot;);
2083         matcher = pattern.matcher(&quot;testing&quot;);
2084         if (matcher.matches()) {
2085             if (!matcher.group(0).equals(&quot;testing&quot;))
2086                 failCount++;
2087         } else {
2088             failCount++;
2089         }
2090 
2091         // Supplementary character test
2092         pattern = Pattern.compile(toSupplementaries(&quot;(tes)ting&quot;));
2093         matcher = pattern.matcher(toSupplementaries(&quot;testing&quot;));
2094         check(matcher, toSupplementaries(&quot;testing&quot;));
2095 
2096         matcher.reset(toSupplementaries(&quot;testing&quot;));
2097         if (matcher.lookingAt()) {
2098             if (!matcher.group(0).equals(toSupplementaries(&quot;testing&quot;)))
2099                 failCount++;
2100         } else {
2101             failCount++;
2102         }
2103 
2104         matcher.reset(toSupplementaries(&quot;testing&quot;));
2105         if (matcher.matches()) {
2106             if (!matcher.group(0).equals(toSupplementaries(&quot;testing&quot;)))
2107                 failCount++;
2108         } else {
2109             failCount++;
2110         }
2111 
2112         pattern = Pattern.compile(toSupplementaries(&quot;(tes)ting&quot;));
2113         matcher = pattern.matcher(toSupplementaries(&quot;testing&quot;));
2114         if (matcher.lookingAt()) {
2115             if (!matcher.group(0).equals(toSupplementaries(&quot;testing&quot;)))
2116                 failCount++;
2117         } else {
2118             failCount++;
2119         }
2120 
2121         pattern = Pattern.compile(toSupplementaries(&quot;^(tes)ting&quot;));
2122         matcher = pattern.matcher(toSupplementaries(&quot;testing&quot;));
2123         if (matcher.matches()) {
2124             if (!matcher.group(0).equals(toSupplementaries(&quot;testing&quot;)))
2125                 failCount++;
2126         } else {
2127             failCount++;
2128         }
2129 
2130         report(&quot;Group0&quot;);
2131     }
2132 
2133     private static void findIntTest() throws Exception {
2134         Pattern p = Pattern.compile(&quot;blah&quot;);
2135         Matcher m = p.matcher(&quot;zzzzblahzzzzzblah&quot;);
2136         boolean result = m.find(2);
2137         if (!result)
2138             failCount++;
2139 
2140         p = Pattern.compile(&quot;$&quot;);
2141         m = p.matcher(&quot;1234567890&quot;);
2142         result = m.find(10);
2143         if (!result)
2144             failCount++;
2145         try {
2146             result = m.find(11);
2147             failCount++;
2148         } catch (IndexOutOfBoundsException e) {
2149             // correct result
2150         }
2151 
2152         // Supplementary character test
2153         p = Pattern.compile(toSupplementaries(&quot;blah&quot;));
2154         m = p.matcher(toSupplementaries(&quot;zzzzblahzzzzzblah&quot;));
2155         result = m.find(2);
2156         if (!result)
2157             failCount++;
2158 
2159         report(&quot;FindInt&quot;);
2160     }
2161 
2162     private static void emptyPatternTest() throws Exception {
2163         Pattern p = Pattern.compile(&quot;&quot;);
2164         Matcher m = p.matcher(&quot;foo&quot;);
2165 
2166         // Should find empty pattern at beginning of input
2167         boolean result = m.find();
2168         if (result != true)
2169             failCount++;
2170         if (m.start() != 0)
2171             failCount++;
2172 
2173         // Should not match entire input if input is not empty
2174         m.reset();
2175         result = m.matches();
2176         if (result == true)
2177             failCount++;
2178 
2179         try {
2180             m.start(0);
2181             failCount++;
2182         } catch (IllegalStateException e) {
2183             // Correct result
2184         }
2185 
2186         // Should match entire input if input is empty
2187         m.reset(&quot;&quot;);
2188         result = m.matches();
2189         if (result != true)
2190             failCount++;
2191 
2192         result = Pattern.matches(&quot;&quot;, &quot;&quot;);
2193         if (result != true)
2194             failCount++;
2195 
2196         result = Pattern.matches(&quot;&quot;, &quot;foo&quot;);
2197         if (result == true)
2198             failCount++;
2199         report(&quot;EmptyPattern&quot;);
2200     }
2201 
2202     private static void charClassTest() throws Exception {
2203         Pattern pattern = Pattern.compile(&quot;blah[ab]]blech&quot;);
2204         check(pattern, &quot;blahb]blech&quot;, true);
2205 
2206         pattern = Pattern.compile(&quot;[abc[def]]&quot;);
2207         check(pattern, &quot;b&quot;, true);
2208 
2209         // Supplementary character tests
2210         pattern = Pattern.compile(toSupplementaries(&quot;blah[ab]]blech&quot;));
2211         check(pattern, toSupplementaries(&quot;blahb]blech&quot;), true);
2212 
2213         pattern = Pattern.compile(toSupplementaries(&quot;[abc[def]]&quot;));
2214         check(pattern, toSupplementaries(&quot;b&quot;), true);
2215 
2216         try {
2217             // u00ff when UNICODE_CASE
2218             pattern = Pattern.compile(&quot;[ab\u00ffcd]&quot;,
2219                                       Pattern.CASE_INSENSITIVE|
2220                                       Pattern.UNICODE_CASE);
2221             check(pattern, &quot;ab\u00ffcd&quot;, true);
2222             check(pattern, &quot;Ab\u0178Cd&quot;, true);
2223 
2224             // u00b5 when UNICODE_CASE
2225             pattern = Pattern.compile(&quot;[ab\u00b5cd]&quot;,
2226                                       Pattern.CASE_INSENSITIVE|
2227                                       Pattern.UNICODE_CASE);
2228             check(pattern, &quot;ab\u00b5cd&quot;, true);
2229             check(pattern, &quot;Ab\u039cCd&quot;, true);
2230         } catch (Exception e) { failCount++; }
2231 
2232         /* Special cases
2233            (1)LatinSmallLetterLongS u+017f
2234            (2)LatinSmallLetterDotlessI u+0131
2235            (3)LatineCapitalLetterIWithDotAbove u+0130
2236            (4)KelvinSign u+212a
2237            (5)AngstromSign u+212b
2238         */
2239         int flags = Pattern.UNICODE_CASE | Pattern.CASE_INSENSITIVE;
2240         pattern = Pattern.compile(&quot;[sik\u00c5]+&quot;, flags);
2241         if (!pattern.matcher(&quot;\u017f\u0130\u0131\u212a\u212b&quot;).matches())
2242             failCount++;
2243 
2244         report(&quot;CharClass&quot;);
2245     }
2246 
2247     private static void caretTest() throws Exception {
2248         Pattern pattern = Pattern.compile(&quot;\\w*&quot;);
2249         Matcher matcher = pattern.matcher(&quot;a#bc#def##g&quot;);
2250         check(matcher, &quot;a&quot;);
2251         check(matcher, &quot;&quot;);
2252         check(matcher, &quot;bc&quot;);
2253         check(matcher, &quot;&quot;);
2254         check(matcher, &quot;def&quot;);
2255         check(matcher, &quot;&quot;);
2256         check(matcher, &quot;&quot;);
2257         check(matcher, &quot;g&quot;);
2258         check(matcher, &quot;&quot;);
2259         if (matcher.find())
2260             failCount++;
2261 
2262         pattern = Pattern.compile(&quot;^\\w*&quot;);
2263         matcher = pattern.matcher(&quot;a#bc#def##g&quot;);
2264         check(matcher, &quot;a&quot;);
2265         if (matcher.find())
2266             failCount++;
2267 
2268         pattern = Pattern.compile(&quot;\\w&quot;);
2269         matcher = pattern.matcher(&quot;abc##x&quot;);
2270         check(matcher, &quot;a&quot;);
2271         check(matcher, &quot;b&quot;);
2272         check(matcher, &quot;c&quot;);
2273         check(matcher, &quot;x&quot;);
2274         if (matcher.find())
2275             failCount++;
2276 
2277         pattern = Pattern.compile(&quot;^\\w&quot;);
2278         matcher = pattern.matcher(&quot;abc##x&quot;);
2279         check(matcher, &quot;a&quot;);
2280         if (matcher.find())
2281             failCount++;
2282 
2283         pattern = Pattern.compile(&quot;\\A\\p{Alpha}{3}&quot;);
2284         matcher = pattern.matcher(&quot;abcdef-ghi\njklmno&quot;);
2285         check(matcher, &quot;abc&quot;);
2286         if (matcher.find())
2287             failCount++;
2288 
2289         pattern = Pattern.compile(&quot;^\\p{Alpha}{3}&quot;, Pattern.MULTILINE);
2290         matcher = pattern.matcher(&quot;abcdef-ghi\njklmno&quot;);
2291         check(matcher, &quot;abc&quot;);
2292         check(matcher, &quot;jkl&quot;);
2293         if (matcher.find())
2294             failCount++;
2295 
2296         pattern = Pattern.compile(&quot;^&quot;, Pattern.MULTILINE);
2297         matcher = pattern.matcher(&quot;this is some text&quot;);
2298         String result = matcher.replaceAll(&quot;X&quot;);
2299         if (!result.equals(&quot;Xthis is some text&quot;))
2300             failCount++;
2301 
2302         pattern = Pattern.compile(&quot;^&quot;);
2303         matcher = pattern.matcher(&quot;this is some text&quot;);
2304         result = matcher.replaceAll(&quot;X&quot;);
2305         if (!result.equals(&quot;Xthis is some text&quot;))
2306             failCount++;
2307 
2308         pattern = Pattern.compile(&quot;^&quot;, Pattern.MULTILINE | Pattern.UNIX_LINES);
2309         matcher = pattern.matcher(&quot;this is some text\n&quot;);
2310         result = matcher.replaceAll(&quot;X&quot;);
2311         if (!result.equals(&quot;Xthis is some text\n&quot;))
2312             failCount++;
2313 
2314         report(&quot;Caret&quot;);
2315     }
2316 
2317     private static void groupCaptureTest() throws Exception {
2318         // Independent group
2319         Pattern pattern = Pattern.compile(&quot;x+(?&gt;y+)z+&quot;);
2320         Matcher matcher = pattern.matcher(&quot;xxxyyyzzz&quot;);
2321         matcher.find();
2322         try {
2323             String blah = matcher.group(1);
2324             failCount++;
2325         } catch (IndexOutOfBoundsException ioobe) {
2326             // Good result
2327         }
2328         // Pure group
2329         pattern = Pattern.compile(&quot;x+(?:y+)z+&quot;);
2330         matcher = pattern.matcher(&quot;xxxyyyzzz&quot;);
2331         matcher.find();
2332         try {
2333             String blah = matcher.group(1);
2334             failCount++;
2335         } catch (IndexOutOfBoundsException ioobe) {
2336             // Good result
2337         }
2338 
2339         // Supplementary character tests
2340         // Independent group
2341         pattern = Pattern.compile(toSupplementaries(&quot;x+(?&gt;y+)z+&quot;));
2342         matcher = pattern.matcher(toSupplementaries(&quot;xxxyyyzzz&quot;));
2343         matcher.find();
2344         try {
2345             String blah = matcher.group(1);
2346             failCount++;
2347         } catch (IndexOutOfBoundsException ioobe) {
2348             // Good result
2349         }
2350         // Pure group
2351         pattern = Pattern.compile(toSupplementaries(&quot;x+(?:y+)z+&quot;));
2352         matcher = pattern.matcher(toSupplementaries(&quot;xxxyyyzzz&quot;));
2353         matcher.find();
2354         try {
2355             String blah = matcher.group(1);
2356             failCount++;
2357         } catch (IndexOutOfBoundsException ioobe) {
2358             // Good result
2359         }
2360 
2361         report(&quot;GroupCapture&quot;);
2362     }
2363 
2364     private static void backRefTest() throws Exception {
2365         Pattern pattern = Pattern.compile(&quot;(a*)bc\\1&quot;);
2366         check(pattern, &quot;zzzaabcazzz&quot;, true);
2367 
2368         pattern = Pattern.compile(&quot;(a*)bc\\1&quot;);
2369         check(pattern, &quot;zzzaabcaazzz&quot;, true);
2370 
2371         pattern = Pattern.compile(&quot;(abc)(def)\\1&quot;);
2372         check(pattern, &quot;abcdefabc&quot;, true);
2373 
2374         pattern = Pattern.compile(&quot;(abc)(def)\\3&quot;);
2375         check(pattern, &quot;abcdefabc&quot;, false);
2376 
2377         try {
2378             for (int i = 1; i &lt; 10; i++) {
2379                 // Make sure backref 1-9 are always accepted
2380                 pattern = Pattern.compile(&quot;abcdef\\&quot; + i);
2381                 // and fail to match if the target group does not exit
2382                 check(pattern, &quot;abcdef&quot;, false);
2383             }
2384         } catch(PatternSyntaxException e) {
2385             failCount++;
2386         }
2387 
2388         pattern = Pattern.compile(&quot;(a)(b)(c)(d)(e)(f)(g)(h)(i)(j)\\11&quot;);
2389         check(pattern, &quot;abcdefghija&quot;, false);
2390         check(pattern, &quot;abcdefghija1&quot;, true);
2391 
2392         pattern = Pattern.compile(&quot;(a)(b)(c)(d)(e)(f)(g)(h)(i)(j)(k)\\11&quot;);
2393         check(pattern, &quot;abcdefghijkk&quot;, true);
2394 
2395         pattern = Pattern.compile(&quot;(a)bcdefghij\\11&quot;);
2396         check(pattern, &quot;abcdefghija1&quot;, true);
2397 
2398         // Supplementary character tests
2399         pattern = Pattern.compile(toSupplementaries(&quot;(a*)bc\\1&quot;));
2400         check(pattern, toSupplementaries(&quot;zzzaabcazzz&quot;), true);
2401 
2402         pattern = Pattern.compile(toSupplementaries(&quot;(a*)bc\\1&quot;));
2403         check(pattern, toSupplementaries(&quot;zzzaabcaazzz&quot;), true);
2404 
2405         pattern = Pattern.compile(toSupplementaries(&quot;(abc)(def)\\1&quot;));
2406         check(pattern, toSupplementaries(&quot;abcdefabc&quot;), true);
2407 
2408         pattern = Pattern.compile(toSupplementaries(&quot;(abc)(def)\\3&quot;));
2409         check(pattern, toSupplementaries(&quot;abcdefabc&quot;), false);
2410 
2411         pattern = Pattern.compile(toSupplementaries(&quot;(a)(b)(c)(d)(e)(f)(g)(h)(i)(j)\\11&quot;));
2412         check(pattern, toSupplementaries(&quot;abcdefghija&quot;), false);
2413         check(pattern, toSupplementaries(&quot;abcdefghija1&quot;), true);
2414 
2415         pattern = Pattern.compile(toSupplementaries(&quot;(a)(b)(c)(d)(e)(f)(g)(h)(i)(j)(k)\\11&quot;));
2416         check(pattern, toSupplementaries(&quot;abcdefghijkk&quot;), true);
2417 
2418         report(&quot;BackRef&quot;);
2419     }
2420 
2421     /**
2422      * Unicode Technical Report #18, section 2.6 End of Line
2423      * There is no empty line to be matched in the sequence \u000D\u000A
2424      * but there is an empty line in the sequence \u000A\u000D.
2425      */
2426     private static void anchorTest() throws Exception {
2427         Pattern p = Pattern.compile(&quot;^.*$&quot;, Pattern.MULTILINE);
2428         Matcher m = p.matcher(&quot;blah1\r\nblah2&quot;);
2429         m.find();
2430         m.find();
2431         if (!m.group().equals(&quot;blah2&quot;))
2432             failCount++;
2433 
2434         m.reset(&quot;blah1\n\rblah2&quot;);
2435         m.find();
2436         m.find();
2437         m.find();
2438         if (!m.group().equals(&quot;blah2&quot;))
2439             failCount++;
2440 
2441         // Test behavior of $ with \r\n at end of input
2442         p = Pattern.compile(&quot;.+$&quot;);
2443         m = p.matcher(&quot;blah1\r\n&quot;);
2444         if (!m.find())
2445             failCount++;
2446        if (!m.group().equals(&quot;blah1&quot;))
2447             failCount++;
2448         if (m.find())
2449             failCount++;
2450 
2451         // Test behavior of $ with \r\n at end of input in multiline
2452         p = Pattern.compile(&quot;.+$&quot;, Pattern.MULTILINE);
2453         m = p.matcher(&quot;blah1\r\n&quot;);
2454         if (!m.find())
2455             failCount++;
2456         if (m.find())
2457             failCount++;
2458 
2459         // Test for $ recognition of \u0085 for bug 4527731
2460         p = Pattern.compile(&quot;.+$&quot;, Pattern.MULTILINE);
2461         m = p.matcher(&quot;blah1\u0085&quot;);
2462         if (!m.find())
2463             failCount++;
2464 
2465         // Supplementary character test
2466         p = Pattern.compile(&quot;^.*$&quot;, Pattern.MULTILINE);
2467         m = p.matcher(toSupplementaries(&quot;blah1\r\nblah2&quot;));
2468         m.find();
2469         m.find();
2470         if (!m.group().equals(toSupplementaries(&quot;blah2&quot;)))
2471             failCount++;
2472 
2473         m.reset(toSupplementaries(&quot;blah1\n\rblah2&quot;));
2474         m.find();
2475         m.find();
2476         m.find();
2477         if (!m.group().equals(toSupplementaries(&quot;blah2&quot;)))
2478             failCount++;
2479 
2480         // Test behavior of $ with \r\n at end of input
2481         p = Pattern.compile(&quot;.+$&quot;);
2482         m = p.matcher(toSupplementaries(&quot;blah1\r\n&quot;));
2483         if (!m.find())
2484             failCount++;
2485         if (!m.group().equals(toSupplementaries(&quot;blah1&quot;)))
2486             failCount++;
2487         if (m.find())
2488             failCount++;
2489 
2490         // Test behavior of $ with \r\n at end of input in multiline
2491         p = Pattern.compile(&quot;.+$&quot;, Pattern.MULTILINE);
2492         m = p.matcher(toSupplementaries(&quot;blah1\r\n&quot;));
2493         if (!m.find())
2494             failCount++;
2495         if (m.find())
2496             failCount++;
2497 
2498         // Test for $ recognition of \u0085 for bug 4527731
2499         p = Pattern.compile(&quot;.+$&quot;, Pattern.MULTILINE);
2500         m = p.matcher(toSupplementaries(&quot;blah1\u0085&quot;));
2501         if (!m.find())
2502             failCount++;
2503 
2504         report(&quot;Anchors&quot;);
2505     }
2506 
2507     /**
2508      * A basic sanity test of Matcher.lookingAt().
2509      */
2510     private static void lookingAtTest() throws Exception {
2511         Pattern p = Pattern.compile(&quot;(ab)(c*)&quot;);
2512         Matcher m = p.matcher(&quot;abccczzzabcczzzabccc&quot;);
2513 
2514         if (!m.lookingAt())
2515             failCount++;
2516 
2517         if (!m.group().equals(m.group(0)))
2518             failCount++;
2519 
2520         m = p.matcher(&quot;zzzabccczzzabcczzzabccczzz&quot;);
2521         if (m.lookingAt())
2522             failCount++;
2523 
2524         // Supplementary character test
2525         p = Pattern.compile(toSupplementaries(&quot;(ab)(c*)&quot;));
2526         m = p.matcher(toSupplementaries(&quot;abccczzzabcczzzabccc&quot;));
2527 
2528         if (!m.lookingAt())
2529             failCount++;
2530 
2531         if (!m.group().equals(m.group(0)))
2532             failCount++;
2533 
2534         m = p.matcher(toSupplementaries(&quot;zzzabccczzzabcczzzabccczzz&quot;));
2535         if (m.lookingAt())
2536             failCount++;
2537 
2538         report(&quot;Looking At&quot;);
2539     }
2540 
2541     /**
2542      * A basic sanity test of Matcher.matches().
2543      */
2544     private static void matchesTest() throws Exception {
2545         // matches()
2546         Pattern p = Pattern.compile(&quot;ulb(c*)&quot;);
2547         Matcher m = p.matcher(&quot;ulbcccccc&quot;);
2548         if (!m.matches())
2549             failCount++;
2550 
2551         // find() but not matches()
2552         m.reset(&quot;zzzulbcccccc&quot;);
2553         if (m.matches())
2554             failCount++;
2555 
2556         // lookingAt() but not matches()
2557         m.reset(&quot;ulbccccccdef&quot;);
2558         if (m.matches())
2559             failCount++;
2560 
2561         // matches()
2562         p = Pattern.compile(&quot;a|ad&quot;);
2563         m = p.matcher(&quot;ad&quot;);
2564         if (!m.matches())
2565             failCount++;
2566 
2567         // Supplementary character test
2568         // matches()
2569         p = Pattern.compile(toSupplementaries(&quot;ulb(c*)&quot;));
2570         m = p.matcher(toSupplementaries(&quot;ulbcccccc&quot;));
2571         if (!m.matches())
2572             failCount++;
2573 
2574         // find() but not matches()
2575         m.reset(toSupplementaries(&quot;zzzulbcccccc&quot;));
2576         if (m.matches())
2577             failCount++;
2578 
2579         // lookingAt() but not matches()
2580         m.reset(toSupplementaries(&quot;ulbccccccdef&quot;));
2581         if (m.matches())
2582             failCount++;
2583 
2584         // matches()
2585         p = Pattern.compile(toSupplementaries(&quot;a|ad&quot;));
2586         m = p.matcher(toSupplementaries(&quot;ad&quot;));
2587         if (!m.matches())
2588             failCount++;
2589 
2590         report(&quot;Matches&quot;);
2591     }
2592 
2593     /**
2594      * A basic sanity test of Pattern.matches().
2595      */
2596     private static void patternMatchesTest() throws Exception {
2597         // matches()
2598         if (!Pattern.matches(toSupplementaries(&quot;ulb(c*)&quot;),
2599                              toSupplementaries(&quot;ulbcccccc&quot;)))
2600             failCount++;
2601 
2602         // find() but not matches()
2603         if (Pattern.matches(toSupplementaries(&quot;ulb(c*)&quot;),
2604                             toSupplementaries(&quot;zzzulbcccccc&quot;)))
2605             failCount++;
2606 
2607         // lookingAt() but not matches()
2608         if (Pattern.matches(toSupplementaries(&quot;ulb(c*)&quot;),
2609                             toSupplementaries(&quot;ulbccccccdef&quot;)))
2610             failCount++;
2611 
2612         // Supplementary character test
2613         // matches()
2614         if (!Pattern.matches(toSupplementaries(&quot;ulb(c*)&quot;),
2615                              toSupplementaries(&quot;ulbcccccc&quot;)))
2616             failCount++;
2617 
2618         // find() but not matches()
2619         if (Pattern.matches(toSupplementaries(&quot;ulb(c*)&quot;),
2620                             toSupplementaries(&quot;zzzulbcccccc&quot;)))
2621             failCount++;
2622 
2623         // lookingAt() but not matches()
2624         if (Pattern.matches(toSupplementaries(&quot;ulb(c*)&quot;),
2625                             toSupplementaries(&quot;ulbccccccdef&quot;)))
2626             failCount++;
2627 
2628         report(&quot;Pattern Matches&quot;);
2629     }
2630 
2631     /**
2632      * Canonical equivalence testing. Tests the ability of the engine
2633      * to match sequences that are not explicitly specified in the
2634      * pattern when they are considered equivalent by the Unicode Standard.
2635      */
2636     private static void ceTest() throws Exception {
2637         // Decomposed char outside char classes
2638         Pattern p = Pattern.compile(&quot;testa\u030a&quot;, Pattern.CANON_EQ);
2639         Matcher m = p.matcher(&quot;test\u00e5&quot;);
2640         if (!m.matches())
2641             failCount++;
2642 
2643         m.reset(&quot;testa\u030a&quot;);
2644         if (!m.matches())
2645             failCount++;
2646 
2647         // Composed char outside char classes
2648         p = Pattern.compile(&quot;test\u00e5&quot;, Pattern.CANON_EQ);
2649         m = p.matcher(&quot;test\u00e5&quot;);
2650         if (!m.matches())
2651             failCount++;
2652 
2653         m.reset(&quot;testa\u030a&quot;);
2654         if (!m.find())
2655             failCount++;
2656 
2657         // Decomposed char inside a char class
2658         p = Pattern.compile(&quot;test[abca\u030a]&quot;, Pattern.CANON_EQ);
2659         m = p.matcher(&quot;test\u00e5&quot;);
2660         if (!m.find())
2661             failCount++;
2662 
2663         m.reset(&quot;testa\u030a&quot;);
2664         if (!m.find())
2665             failCount++;
2666 
2667         // Composed char inside a char class
2668         p = Pattern.compile(&quot;test[abc\u00e5def\u00e0]&quot;, Pattern.CANON_EQ);
2669         m = p.matcher(&quot;test\u00e5&quot;);
2670         if (!m.find())
2671             failCount++;
2672 
2673         m.reset(&quot;testa\u0300&quot;);
2674         if (!m.find())
2675             failCount++;
2676 
2677         m.reset(&quot;testa\u030a&quot;);
2678         if (!m.find())
2679             failCount++;
2680 
2681         // Marks that cannot legally change order and be equivalent
2682         p = Pattern.compile(&quot;testa\u0308\u0300&quot;, Pattern.CANON_EQ);
2683         check(p, &quot;testa\u0308\u0300&quot;, true);
2684         check(p, &quot;testa\u0300\u0308&quot;, false);
2685 
2686         // Marks that can legally change order and be equivalent
2687         p = Pattern.compile(&quot;testa\u0308\u0323&quot;, Pattern.CANON_EQ);
2688         check(p, &quot;testa\u0308\u0323&quot;, true);
2689         check(p, &quot;testa\u0323\u0308&quot;, true);
2690 
2691         // Test all equivalences of the sequence a\u0308\u0323\u0300
2692         p = Pattern.compile(&quot;testa\u0308\u0323\u0300&quot;, Pattern.CANON_EQ);
2693         check(p, &quot;testa\u0308\u0323\u0300&quot;, true);
2694         check(p, &quot;testa\u0323\u0308\u0300&quot;, true);
2695         check(p, &quot;testa\u0308\u0300\u0323&quot;, true);
2696         check(p, &quot;test\u00e4\u0323\u0300&quot;, true);
2697         check(p, &quot;test\u00e4\u0300\u0323&quot;, true);
2698 
2699         Object[][] data = new Object[][] {
2700 
2701         // JDK-4867170
2702         { &quot;[\u1f80-\u1f82]&quot;, &quot;ab\u1f80cd&quot;,             &quot;f&quot;, true },
2703         { &quot;[\u1f80-\u1f82]&quot;, &quot;ab\u1f81cd&quot;,             &quot;f&quot;, true },
2704         { &quot;[\u1f80-\u1f82]&quot;, &quot;ab\u1f82cd&quot;,             &quot;f&quot;, true },
2705         { &quot;[\u1f80-\u1f82]&quot;, &quot;ab\u03b1\u0314\u0345cd&quot;, &quot;f&quot;, true },
2706         { &quot;[\u1f80-\u1f82]&quot;, &quot;ab\u03b1\u0345\u0314cd&quot;, &quot;f&quot;, true },
2707         { &quot;[\u1f80-\u1f82]&quot;, &quot;ab\u1f01\u0345cd&quot;,       &quot;f&quot;, true },
2708         { &quot;[\u1f80-\u1f82]&quot;, &quot;ab\u1f00\u0345cd&quot;,       &quot;f&quot;, true },
2709 
2710         { &quot;\\p{IsGreek}&quot;,    &quot;ab\u1f80cd&quot;,             &quot;f&quot;, true },
2711         { &quot;\\p{IsGreek}&quot;,    &quot;ab\u1f81cd&quot;,             &quot;f&quot;, true },
2712         { &quot;\\p{IsGreek}&quot;,    &quot;ab\u1f82cd&quot;,             &quot;f&quot;, true },
2713         { &quot;\\p{IsGreek}&quot;,    &quot;ab\u03b1\u0314\u0345cd&quot;, &quot;f&quot;, true },
2714         { &quot;\\p{IsGreek}&quot;,    &quot;ab\u1f01\u0345cd&quot;,       &quot;f&quot;, true },
2715 
2716         // backtracking, force to match &quot;\u1f80&quot;, instead of \u1f82&quot;
2717         { &quot;ab\\p{IsGreek}\u0300cd&quot;, &quot;ab\u03b1\u0313\u0345\u0300cd&quot;, &quot;m&quot;, true },
2718 
2719         { &quot;[\\p{IsGreek}]&quot;,  &quot;\u03b1\u0314\u0345&quot;,     &quot;m&quot;, true },
2720         { &quot;\\p{IsGreek}&quot;,    &quot;\u03b1\u0314\u0345&quot;,     &quot;m&quot;, true },
2721 
2722         { &quot;[^\u1f80-\u1f82]&quot;,&quot;\u1f81&quot;,                 &quot;m&quot;, false },
2723         { &quot;[^\u1f80-\u1f82]&quot;,&quot;\u03b1\u0314\u0345&quot;,     &quot;m&quot;, false },
2724         { &quot;[^\u1f01\u0345]&quot;, &quot;\u1f81&quot;,                 &quot;f&quot;, false },
2725 
2726         { &quot;[^\u1f81]+&quot;,      &quot;\u1f80\u1f82&quot;,           &quot;f&quot;, true },
2727         { &quot;[\u1f80]&quot;,        &quot;ab\u1f80cd&quot;,             &quot;f&quot;, true },
2728         { &quot;\u1f80&quot;,          &quot;ab\u1f80cd&quot;,             &quot;f&quot;, true },
2729         { &quot;\u1f00\u0345\u0300&quot;,  &quot;\u1f82&quot;, &quot;m&quot;, true },
2730         { &quot;\u1f80&quot;,          &quot;-\u1f00\u0345\u0300-&quot;,   &quot;f&quot;, true },
2731         { &quot;\u1f82&quot;,          &quot;\u1f00\u0345\u0300&quot;,     &quot;m&quot;, true },
2732         { &quot;\u1f82&quot;,          &quot;\u1f80\u0300&quot;,           &quot;m&quot;, true },
2733 
2734         // JDK-7080302       # compile failed
2735         { &quot;a(\u0041\u0301\u0328)&quot;, &quot;a\u0041\u0301\u0328&quot;, &quot;m&quot;, true},
2736 
2737         // JDK-6728861, same cause as above one
2738         { &quot;\u00e9\u00e9n&quot;, &quot;e\u0301e\u0301n&quot;, &quot;m&quot;, true},
2739 
2740         // JDK-6995635
2741         { &quot;(\u00e9)&quot;, &quot;e\u0301&quot;, &quot;m&quot;, true },
2742 
2743         // JDK-6736245
2744         // intereting special case, nfc(u2add+u0338) -&gt; u2add+u0338) NOT u2adc
2745         { &quot;\u2ADC&quot;, &quot;\u2ADC&quot;, &quot;m&quot;, true},          // NFC
2746         { &quot;\u2ADC&quot;, &quot;\u2ADD\u0338&quot;, &quot;m&quot;, true},    // NFD
2747 
2748         //  4916384.
2749         // Decomposed hangul (jamos) works inside clazz
2750         { &quot;[\u1100\u1161]&quot;, &quot;\u1100\u1161&quot;, &quot;m&quot;, true},
2751         { &quot;[\u1100\u1161]&quot;, &quot;\uac00&quot;, &quot;m&quot;, true},
2752 
2753         { &quot;[\uac00]&quot;, &quot;\u1100\u1161&quot;, &quot;m&quot;, true},
2754         { &quot;[\uac00]&quot;, &quot;\uac00&quot;, &quot;m&quot;, true},
2755 
2756         // Decomposed hangul (jamos)
2757         { &quot;\u1100\u1161&quot;, &quot;\u1100\u1161&quot;, &quot;m&quot;, true},
2758         { &quot;\u1100\u1161&quot;, &quot;\uac00&quot;, &quot;m&quot;, true},
2759 
2760         // Composed hangul
2761         { &quot;\uac00&quot;,  &quot;\u1100\u1161&quot;, &quot;m&quot;, true },
2762         { &quot;\uac00&quot;,  &quot;\uac00&quot;, &quot;m&quot;, true },
2763 
2764         /* Need a NFDSlice to nfd the source to solve this issue
2765            u+1d1c0 -&gt; nfd: &lt;u+1d1ba&gt;&lt;u+1d165&gt;&lt;u+1d16f&gt;  -&gt; nfc: &lt;u+1d1ba&gt;&lt;u+1d165&gt;&lt;u+1d16f&gt;
2766            u+1d1bc -&gt; nfd: &lt;u+1d1ba&gt;&lt;u+1d165&gt;           -&gt; nfc: &lt;u+1d1ba&gt;&lt;u+1d165&gt;
2767            &lt;u+1d1bc&gt;&lt;u+1d16f&gt; -&gt; nfd: &lt;u+1d1ba&gt;&lt;u+1d165&gt;&lt;u+1d16f&gt; -&gt; nfc: &lt;u+1d1ba&gt;&lt;u+1d165&gt;&lt;u+1d16f&gt;
2768 
2769         // Decomposed supplementary outside char classes
2770         // { &quot;test\ud834\uddbc\ud834\udd6f&quot;, &quot;test\ud834\uddc0&quot;, &quot;m&quot;, true },
2771         // Composed supplementary outside char classes
2772         // { &quot;test\ud834\uddc0&quot;, &quot;test\ud834\uddbc\ud834\udd6f&quot;, &quot;m&quot;, true },
2773         */
2774         { &quot;test\ud834\uddbc\ud834\udd6f&quot;, &quot;test\ud834\uddbc\ud834\udd6f&quot;, &quot;m&quot;, true },
2775         { &quot;test\ud834\uddc0&quot;,             &quot;test\ud834\uddbc\ud834\udd6f&quot;, &quot;m&quot;, true },
2776 
2777         { &quot;test\ud834\uddc0&quot;,             &quot;test\ud834\uddc0&quot;,             &quot;m&quot;, true },
2778         { &quot;test\ud834\uddbc\ud834\udd6f&quot;, &quot;test\ud834\uddc0&quot;,             &quot;m&quot;, true },
2779         };
2780 
2781         int failCount = 0;
2782         for (Object[] d : data) {
2783             String pn = (String)d[0];
2784             String tt = (String)d[1];
2785             boolean isFind = &quot;f&quot;.equals(((String)d[2]));
2786             boolean expected = (boolean)d[3];
2787             boolean ret = isFind ? Pattern.compile(pn, Pattern.CANON_EQ).matcher(tt).find()
2788                                  : Pattern.compile(pn, Pattern.CANON_EQ).matcher(tt).matches();
2789             if (ret != expected) {
2790                 failCount++;
2791                 continue;
2792             }
2793         }
2794         report(&quot;Canonical Equivalence&quot;);
2795     }
2796 
2797     /**
2798      * A basic sanity test of Matcher.replaceAll().
2799      */
2800     private static void globalSubstitute() throws Exception {
2801         // Global substitution with a literal
2802         Pattern p = Pattern.compile(&quot;(ab)(c*)&quot;);
2803         Matcher m = p.matcher(&quot;abccczzzabcczzzabccc&quot;);
2804         if (!m.replaceAll(&quot;test&quot;).equals(&quot;testzzztestzzztest&quot;))
2805             failCount++;
2806 
2807         m.reset(&quot;zzzabccczzzabcczzzabccczzz&quot;);
2808         if (!m.replaceAll(&quot;test&quot;).equals(&quot;zzztestzzztestzzztestzzz&quot;))
2809             failCount++;
2810 
2811         // Global substitution with groups
2812         m.reset(&quot;zzzabccczzzabcczzzabccczzz&quot;);
2813         String result = m.replaceAll(&quot;$1&quot;);
2814         if (!result.equals(&quot;zzzabzzzabzzzabzzz&quot;))
2815             failCount++;
2816 
2817         // Supplementary character test
2818         // Global substitution with a literal
2819         p = Pattern.compile(toSupplementaries(&quot;(ab)(c*)&quot;));
2820         m = p.matcher(toSupplementaries(&quot;abccczzzabcczzzabccc&quot;));
2821         if (!m.replaceAll(toSupplementaries(&quot;test&quot;)).
2822             equals(toSupplementaries(&quot;testzzztestzzztest&quot;)))
2823             failCount++;
2824 
2825         m.reset(toSupplementaries(&quot;zzzabccczzzabcczzzabccczzz&quot;));
2826         if (!m.replaceAll(toSupplementaries(&quot;test&quot;)).
2827             equals(toSupplementaries(&quot;zzztestzzztestzzztestzzz&quot;)))
2828             failCount++;
2829 
2830         // Global substitution with groups
2831         m.reset(toSupplementaries(&quot;zzzabccczzzabcczzzabccczzz&quot;));
2832         result = m.replaceAll(&quot;$1&quot;);
2833         if (!result.equals(toSupplementaries(&quot;zzzabzzzabzzzabzzz&quot;)))
2834             failCount++;
2835 
2836         report(&quot;Global Substitution&quot;);
2837     }
2838 
2839     /**
2840      * Tests the usage of Matcher.appendReplacement() with literal
2841      * and group substitutions.
2842      */
2843     private static void stringbufferSubstitute() throws Exception {
2844         // SB substitution with literal
2845         String blah = &quot;zzzblahzzz&quot;;
2846         Pattern p = Pattern.compile(&quot;blah&quot;);
2847         Matcher m = p.matcher(blah);
2848         StringBuffer result = new StringBuffer();
2849         try {
2850             m.appendReplacement(result, &quot;blech&quot;);
2851             failCount++;
2852         } catch (IllegalStateException e) {
2853         }
2854         m.find();
2855         m.appendReplacement(result, &quot;blech&quot;);
2856         if (!result.toString().equals(&quot;zzzblech&quot;))
2857             failCount++;
2858 
2859         m.appendTail(result);
2860         if (!result.toString().equals(&quot;zzzblechzzz&quot;))
2861             failCount++;
2862 
2863         // SB substitution with groups
2864         blah = &quot;zzzabcdzzz&quot;;
2865         p = Pattern.compile(&quot;(ab)(cd)*&quot;);
2866         m = p.matcher(blah);
2867         result = new StringBuffer();
2868         try {
2869             m.appendReplacement(result, &quot;$1&quot;);
2870             failCount++;
2871         } catch (IllegalStateException e) {
2872         }
2873         m.find();
2874         m.appendReplacement(result, &quot;$1&quot;);
2875         if (!result.toString().equals(&quot;zzzab&quot;))
2876             failCount++;
2877 
2878         m.appendTail(result);
2879         if (!result.toString().equals(&quot;zzzabzzz&quot;))
2880             failCount++;
2881 
2882         // SB substitution with 3 groups
2883         blah = &quot;zzzabcdcdefzzz&quot;;
2884         p = Pattern.compile(&quot;(ab)(cd)*(ef)&quot;);
2885         m = p.matcher(blah);
2886         result = new StringBuffer();
2887         try {
2888             m.appendReplacement(result, &quot;$1w$2w$3&quot;);
2889             failCount++;
2890         } catch (IllegalStateException e) {
2891         }
2892         m.find();
2893         m.appendReplacement(result, &quot;$1w$2w$3&quot;);
2894         if (!result.toString().equals(&quot;zzzabwcdwef&quot;))
2895             failCount++;
2896 
2897         m.appendTail(result);
2898         if (!result.toString().equals(&quot;zzzabwcdwefzzz&quot;))
2899             failCount++;
2900 
2901         // SB substitution with groups and three matches
2902         // skipping middle match
2903         blah = &quot;zzzabcdzzzabcddzzzabcdzzz&quot;;
2904         p = Pattern.compile(&quot;(ab)(cd*)&quot;);
2905         m = p.matcher(blah);
2906         result = new StringBuffer();
2907         try {
2908             m.appendReplacement(result, &quot;$1&quot;);
2909             failCount++;
2910         } catch (IllegalStateException e) {
2911         }
2912         m.find();
2913         m.appendReplacement(result, &quot;$1&quot;);
2914         if (!result.toString().equals(&quot;zzzab&quot;))
2915             failCount++;
2916 
2917         m.find();
2918         m.find();
2919         m.appendReplacement(result, &quot;$2&quot;);
2920         if (!result.toString().equals(&quot;zzzabzzzabcddzzzcd&quot;))
2921             failCount++;
2922 
2923         m.appendTail(result);
2924         if (!result.toString().equals(&quot;zzzabzzzabcddzzzcdzzz&quot;))
2925             failCount++;
2926 
2927         // Check to make sure escaped $ is ignored
2928         blah = &quot;zzzabcdcdefzzz&quot;;
2929         p = Pattern.compile(&quot;(ab)(cd)*(ef)&quot;);
2930         m = p.matcher(blah);
2931         result = new StringBuffer();
2932         m.find();
2933         m.appendReplacement(result, &quot;$1w\\$2w$3&quot;);
2934         if (!result.toString().equals(&quot;zzzabw$2wef&quot;))
2935             failCount++;
2936 
2937         m.appendTail(result);
2938         if (!result.toString().equals(&quot;zzzabw$2wefzzz&quot;))
2939             failCount++;
2940 
2941         // Check to make sure a reference to nonexistent group causes error
2942         blah = &quot;zzzabcdcdefzzz&quot;;
2943         p = Pattern.compile(&quot;(ab)(cd)*(ef)&quot;);
2944         m = p.matcher(blah);
2945         result = new StringBuffer();
2946         m.find();
2947         try {
2948             m.appendReplacement(result, &quot;$1w$5w$3&quot;);
2949             failCount++;
2950         } catch (IndexOutOfBoundsException ioobe) {
2951             // Correct result
2952         }
2953 
2954         // Check double digit group references
2955         blah = &quot;zzz123456789101112zzz&quot;;
2956         p = Pattern.compile(&quot;(1)(2)(3)(4)(5)(6)(7)(8)(9)(10)(11)&quot;);
2957         m = p.matcher(blah);
2958         result = new StringBuffer();
2959         m.find();
2960         m.appendReplacement(result, &quot;$1w$11w$3&quot;);
2961         if (!result.toString().equals(&quot;zzz1w11w3&quot;))
2962             failCount++;
2963 
2964         // Check to make sure it backs off $15 to $1 if only three groups
2965         blah = &quot;zzzabcdcdefzzz&quot;;
2966         p = Pattern.compile(&quot;(ab)(cd)*(ef)&quot;);
2967         m = p.matcher(blah);
2968         result = new StringBuffer();
2969         m.find();
2970         m.appendReplacement(result, &quot;$1w$15w$3&quot;);
2971         if (!result.toString().equals(&quot;zzzabwab5wef&quot;))
2972             failCount++;
2973 
2974 
2975         // Supplementary character test
2976         // SB substitution with literal
2977         blah = toSupplementaries(&quot;zzzblahzzz&quot;);
2978         p = Pattern.compile(toSupplementaries(&quot;blah&quot;));
2979         m = p.matcher(blah);
2980         result = new StringBuffer();
2981         try {
2982             m.appendReplacement(result, toSupplementaries(&quot;blech&quot;));
2983             failCount++;
2984         } catch (IllegalStateException e) {
2985         }
2986         m.find();
2987         m.appendReplacement(result, toSupplementaries(&quot;blech&quot;));
2988         if (!result.toString().equals(toSupplementaries(&quot;zzzblech&quot;)))
2989             failCount++;
2990 
2991         m.appendTail(result);
2992         if (!result.toString().equals(toSupplementaries(&quot;zzzblechzzz&quot;)))
2993             failCount++;
2994 
2995         // SB substitution with groups
2996         blah = toSupplementaries(&quot;zzzabcdzzz&quot;);
2997         p = Pattern.compile(toSupplementaries(&quot;(ab)(cd)*&quot;));
2998         m = p.matcher(blah);
2999         result = new StringBuffer();
3000         try {
3001             m.appendReplacement(result, &quot;$1&quot;);
3002             failCount++;
3003         } catch (IllegalStateException e) {
3004         }
3005         m.find();
3006         m.appendReplacement(result, &quot;$1&quot;);
3007         if (!result.toString().equals(toSupplementaries(&quot;zzzab&quot;)))
3008             failCount++;
3009 
3010         m.appendTail(result);
3011         if (!result.toString().equals(toSupplementaries(&quot;zzzabzzz&quot;)))
3012             failCount++;
3013 
3014         // SB substitution with 3 groups
3015         blah = toSupplementaries(&quot;zzzabcdcdefzzz&quot;);
3016         p = Pattern.compile(toSupplementaries(&quot;(ab)(cd)*(ef)&quot;));
3017         m = p.matcher(blah);
3018         result = new StringBuffer();
3019         try {
3020             m.appendReplacement(result, toSupplementaries(&quot;$1w$2w$3&quot;));
3021             failCount++;
3022         } catch (IllegalStateException e) {
3023         }
3024         m.find();
3025         m.appendReplacement(result, toSupplementaries(&quot;$1w$2w$3&quot;));
3026         if (!result.toString().equals(toSupplementaries(&quot;zzzabwcdwef&quot;)))
3027             failCount++;
3028 
3029         m.appendTail(result);
3030         if (!result.toString().equals(toSupplementaries(&quot;zzzabwcdwefzzz&quot;)))
3031             failCount++;
3032 
3033         // SB substitution with groups and three matches
3034         // skipping middle match
3035         blah = toSupplementaries(&quot;zzzabcdzzzabcddzzzabcdzzz&quot;);
3036         p = Pattern.compile(toSupplementaries(&quot;(ab)(cd*)&quot;));
3037         m = p.matcher(blah);
3038         result = new StringBuffer();
3039         try {
3040             m.appendReplacement(result, &quot;$1&quot;);
3041             failCount++;
3042         } catch (IllegalStateException e) {
3043         }
3044         m.find();
3045         m.appendReplacement(result, &quot;$1&quot;);
3046         if (!result.toString().equals(toSupplementaries(&quot;zzzab&quot;)))
3047             failCount++;
3048 
3049         m.find();
3050         m.find();
3051         m.appendReplacement(result, &quot;$2&quot;);
3052         if (!result.toString().equals(toSupplementaries(&quot;zzzabzzzabcddzzzcd&quot;)))
3053             failCount++;
3054 
3055         m.appendTail(result);
3056         if (!result.toString().equals(toSupplementaries(&quot;zzzabzzzabcddzzzcdzzz&quot;)))
3057             failCount++;
3058 
3059         // Check to make sure escaped $ is ignored
3060         blah = toSupplementaries(&quot;zzzabcdcdefzzz&quot;);
3061         p = Pattern.compile(toSupplementaries(&quot;(ab)(cd)*(ef)&quot;));
3062         m = p.matcher(blah);
3063         result = new StringBuffer();
3064         m.find();
3065         m.appendReplacement(result, toSupplementaries(&quot;$1w\\$2w$3&quot;));
3066         if (!result.toString().equals(toSupplementaries(&quot;zzzabw$2wef&quot;)))
3067             failCount++;
3068 
3069         m.appendTail(result);
3070         if (!result.toString().equals(toSupplementaries(&quot;zzzabw$2wefzzz&quot;)))
3071             failCount++;
3072 
3073         // Check to make sure a reference to nonexistent group causes error
3074         blah = toSupplementaries(&quot;zzzabcdcdefzzz&quot;);
3075         p = Pattern.compile(toSupplementaries(&quot;(ab)(cd)*(ef)&quot;));
3076         m = p.matcher(blah);
3077         result = new StringBuffer();
3078         m.find();
3079         try {
3080             m.appendReplacement(result, toSupplementaries(&quot;$1w$5w$3&quot;));
3081             failCount++;
3082         } catch (IndexOutOfBoundsException ioobe) {
3083             // Correct result
3084         }
3085 
3086         // Check double digit group references
3087         blah = toSupplementaries(&quot;zzz123456789101112zzz&quot;);
3088         p = Pattern.compile(&quot;(1)(2)(3)(4)(5)(6)(7)(8)(9)(10)(11)&quot;);
3089         m = p.matcher(blah);
3090         result = new StringBuffer();
3091         m.find();
3092         m.appendReplacement(result, toSupplementaries(&quot;$1w$11w$3&quot;));
3093         if (!result.toString().equals(toSupplementaries(&quot;zzz1w11w3&quot;)))
3094             failCount++;
3095 
3096         // Check to make sure it backs off $15 to $1 if only three groups
3097         blah = toSupplementaries(&quot;zzzabcdcdefzzz&quot;);
3098         p = Pattern.compile(toSupplementaries(&quot;(ab)(cd)*(ef)&quot;));
3099         m = p.matcher(blah);
3100         result = new StringBuffer();
3101         m.find();
3102         m.appendReplacement(result, toSupplementaries(&quot;$1w$15w$3&quot;));
3103         if (!result.toString().equals(toSupplementaries(&quot;zzzabwab5wef&quot;)))
3104             failCount++;
3105 
3106         // Check nothing has been appended into the output buffer if
3107         // the replacement string triggers IllegalArgumentException.
3108         p = Pattern.compile(&quot;(abc)&quot;);
3109         m = p.matcher(&quot;abcd&quot;);
3110         result = new StringBuffer();
3111         m.find();
3112         try {
3113             m.appendReplacement(result, (&quot;xyz$g&quot;));
3114             failCount++;
3115         } catch (IllegalArgumentException iae) {
3116             if (result.length() != 0)
3117                 failCount++;
3118         }
3119 
3120         report(&quot;SB Substitution&quot;);
3121     }
3122 
3123     /**
3124      * Tests the usage of Matcher.appendReplacement() with literal
3125      * and group substitutions.
3126      */
3127     private static void stringbuilderSubstitute() throws Exception {
3128         // SB substitution with literal
3129         String blah = &quot;zzzblahzzz&quot;;
3130         Pattern p = Pattern.compile(&quot;blah&quot;);
3131         Matcher m = p.matcher(blah);
3132         StringBuilder result = new StringBuilder();
3133         try {
3134             m.appendReplacement(result, &quot;blech&quot;);
3135             failCount++;
3136         } catch (IllegalStateException e) {
3137         }
3138         m.find();
3139         m.appendReplacement(result, &quot;blech&quot;);
3140         if (!result.toString().equals(&quot;zzzblech&quot;))
3141             failCount++;
3142 
3143         m.appendTail(result);
3144         if (!result.toString().equals(&quot;zzzblechzzz&quot;))
3145             failCount++;
3146 
3147         // SB substitution with groups
3148         blah = &quot;zzzabcdzzz&quot;;
3149         p = Pattern.compile(&quot;(ab)(cd)*&quot;);
3150         m = p.matcher(blah);
3151         result = new StringBuilder();
3152         try {
3153             m.appendReplacement(result, &quot;$1&quot;);
3154             failCount++;
3155         } catch (IllegalStateException e) {
3156         }
3157         m.find();
3158         m.appendReplacement(result, &quot;$1&quot;);
3159         if (!result.toString().equals(&quot;zzzab&quot;))
3160             failCount++;
3161 
3162         m.appendTail(result);
3163         if (!result.toString().equals(&quot;zzzabzzz&quot;))
3164             failCount++;
3165 
3166         // SB substitution with 3 groups
3167         blah = &quot;zzzabcdcdefzzz&quot;;
3168         p = Pattern.compile(&quot;(ab)(cd)*(ef)&quot;);
3169         m = p.matcher(blah);
3170         result = new StringBuilder();
3171         try {
3172             m.appendReplacement(result, &quot;$1w$2w$3&quot;);
3173             failCount++;
3174         } catch (IllegalStateException e) {
3175         }
3176         m.find();
3177         m.appendReplacement(result, &quot;$1w$2w$3&quot;);
3178         if (!result.toString().equals(&quot;zzzabwcdwef&quot;))
3179             failCount++;
3180 
3181         m.appendTail(result);
3182         if (!result.toString().equals(&quot;zzzabwcdwefzzz&quot;))
3183             failCount++;
3184 
3185         // SB substitution with groups and three matches
3186         // skipping middle match
3187         blah = &quot;zzzabcdzzzabcddzzzabcdzzz&quot;;
3188         p = Pattern.compile(&quot;(ab)(cd*)&quot;);
3189         m = p.matcher(blah);
3190         result = new StringBuilder();
3191         try {
3192             m.appendReplacement(result, &quot;$1&quot;);
3193             failCount++;
3194         } catch (IllegalStateException e) {
3195         }
3196         m.find();
3197         m.appendReplacement(result, &quot;$1&quot;);
3198         if (!result.toString().equals(&quot;zzzab&quot;))
3199             failCount++;
3200 
3201         m.find();
3202         m.find();
3203         m.appendReplacement(result, &quot;$2&quot;);
3204         if (!result.toString().equals(&quot;zzzabzzzabcddzzzcd&quot;))
3205             failCount++;
3206 
3207         m.appendTail(result);
3208         if (!result.toString().equals(&quot;zzzabzzzabcddzzzcdzzz&quot;))
3209             failCount++;
3210 
3211         // Check to make sure escaped $ is ignored
3212         blah = &quot;zzzabcdcdefzzz&quot;;
3213         p = Pattern.compile(&quot;(ab)(cd)*(ef)&quot;);
3214         m = p.matcher(blah);
3215         result = new StringBuilder();
3216         m.find();
3217         m.appendReplacement(result, &quot;$1w\\$2w$3&quot;);
3218         if (!result.toString().equals(&quot;zzzabw$2wef&quot;))
3219             failCount++;
3220 
3221         m.appendTail(result);
3222         if (!result.toString().equals(&quot;zzzabw$2wefzzz&quot;))
3223             failCount++;
3224 
3225         // Check to make sure a reference to nonexistent group causes error
3226         blah = &quot;zzzabcdcdefzzz&quot;;
3227         p = Pattern.compile(&quot;(ab)(cd)*(ef)&quot;);
3228         m = p.matcher(blah);
3229         result = new StringBuilder();
3230         m.find();
3231         try {
3232             m.appendReplacement(result, &quot;$1w$5w$3&quot;);
3233             failCount++;
3234         } catch (IndexOutOfBoundsException ioobe) {
3235             // Correct result
3236         }
3237 
3238         // Check double digit group references
3239         blah = &quot;zzz123456789101112zzz&quot;;
3240         p = Pattern.compile(&quot;(1)(2)(3)(4)(5)(6)(7)(8)(9)(10)(11)&quot;);
3241         m = p.matcher(blah);
3242         result = new StringBuilder();
3243         m.find();
3244         m.appendReplacement(result, &quot;$1w$11w$3&quot;);
3245         if (!result.toString().equals(&quot;zzz1w11w3&quot;))
3246             failCount++;
3247 
3248         // Check to make sure it backs off $15 to $1 if only three groups
3249         blah = &quot;zzzabcdcdefzzz&quot;;
3250         p = Pattern.compile(&quot;(ab)(cd)*(ef)&quot;);
3251         m = p.matcher(blah);
3252         result = new StringBuilder();
3253         m.find();
3254         m.appendReplacement(result, &quot;$1w$15w$3&quot;);
3255         if (!result.toString().equals(&quot;zzzabwab5wef&quot;))
3256             failCount++;
3257 
3258 
3259         // Supplementary character test
3260         // SB substitution with literal
3261         blah = toSupplementaries(&quot;zzzblahzzz&quot;);
3262         p = Pattern.compile(toSupplementaries(&quot;blah&quot;));
3263         m = p.matcher(blah);
3264         result = new StringBuilder();
3265         try {
3266             m.appendReplacement(result, toSupplementaries(&quot;blech&quot;));
3267             failCount++;
3268         } catch (IllegalStateException e) {
3269         }
3270         m.find();
3271         m.appendReplacement(result, toSupplementaries(&quot;blech&quot;));
3272         if (!result.toString().equals(toSupplementaries(&quot;zzzblech&quot;)))
3273             failCount++;
3274         m.appendTail(result);
3275         if (!result.toString().equals(toSupplementaries(&quot;zzzblechzzz&quot;)))
3276             failCount++;
3277 
3278         // SB substitution with groups
3279         blah = toSupplementaries(&quot;zzzabcdzzz&quot;);
3280         p = Pattern.compile(toSupplementaries(&quot;(ab)(cd)*&quot;));
3281         m = p.matcher(blah);
3282         result = new StringBuilder();
3283         try {
3284             m.appendReplacement(result, &quot;$1&quot;);
3285             failCount++;
3286         } catch (IllegalStateException e) {
3287         }
3288         m.find();
3289         m.appendReplacement(result, &quot;$1&quot;);
3290         if (!result.toString().equals(toSupplementaries(&quot;zzzab&quot;)))
3291             failCount++;
3292 
3293         m.appendTail(result);
3294         if (!result.toString().equals(toSupplementaries(&quot;zzzabzzz&quot;)))
3295             failCount++;
3296 
3297         // SB substitution with 3 groups
3298         blah = toSupplementaries(&quot;zzzabcdcdefzzz&quot;);
3299         p = Pattern.compile(toSupplementaries(&quot;(ab)(cd)*(ef)&quot;));
3300         m = p.matcher(blah);
3301         result = new StringBuilder();
3302         try {
3303             m.appendReplacement(result, toSupplementaries(&quot;$1w$2w$3&quot;));
3304             failCount++;
3305         } catch (IllegalStateException e) {
3306         }
3307         m.find();
3308         m.appendReplacement(result, toSupplementaries(&quot;$1w$2w$3&quot;));
3309         if (!result.toString().equals(toSupplementaries(&quot;zzzabwcdwef&quot;)))
3310             failCount++;
3311 
3312         m.appendTail(result);
3313         if (!result.toString().equals(toSupplementaries(&quot;zzzabwcdwefzzz&quot;)))
3314             failCount++;
3315 
3316         // SB substitution with groups and three matches
3317         // skipping middle match
3318         blah = toSupplementaries(&quot;zzzabcdzzzabcddzzzabcdzzz&quot;);
3319         p = Pattern.compile(toSupplementaries(&quot;(ab)(cd*)&quot;));
3320         m = p.matcher(blah);
3321         result = new StringBuilder();
3322         try {
3323             m.appendReplacement(result, &quot;$1&quot;);
3324             failCount++;
3325         } catch (IllegalStateException e) {
3326         }
3327         m.find();
3328         m.appendReplacement(result, &quot;$1&quot;);
3329         if (!result.toString().equals(toSupplementaries(&quot;zzzab&quot;)))
3330             failCount++;
3331 
3332         m.find();
3333         m.find();
3334         m.appendReplacement(result, &quot;$2&quot;);
3335         if (!result.toString().equals(toSupplementaries(&quot;zzzabzzzabcddzzzcd&quot;)))
3336             failCount++;
3337 
3338         m.appendTail(result);
3339         if (!result.toString().equals(toSupplementaries(&quot;zzzabzzzabcddzzzcdzzz&quot;)))
3340             failCount++;
3341 
3342         // Check to make sure escaped $ is ignored
3343         blah = toSupplementaries(&quot;zzzabcdcdefzzz&quot;);
3344         p = Pattern.compile(toSupplementaries(&quot;(ab)(cd)*(ef)&quot;));
3345         m = p.matcher(blah);
3346         result = new StringBuilder();
3347         m.find();
3348         m.appendReplacement(result, toSupplementaries(&quot;$1w\\$2w$3&quot;));
3349         if (!result.toString().equals(toSupplementaries(&quot;zzzabw$2wef&quot;)))
3350             failCount++;
3351 
3352         m.appendTail(result);
3353         if (!result.toString().equals(toSupplementaries(&quot;zzzabw$2wefzzz&quot;)))
3354             failCount++;
3355 
3356         // Check to make sure a reference to nonexistent group causes error
3357         blah = toSupplementaries(&quot;zzzabcdcdefzzz&quot;);
3358         p = Pattern.compile(toSupplementaries(&quot;(ab)(cd)*(ef)&quot;));
3359         m = p.matcher(blah);
3360         result = new StringBuilder();
3361         m.find();
3362         try {
3363             m.appendReplacement(result, toSupplementaries(&quot;$1w$5w$3&quot;));
3364             failCount++;
3365         } catch (IndexOutOfBoundsException ioobe) {
3366             // Correct result
3367         }
3368         // Check double digit group references
3369         blah = toSupplementaries(&quot;zzz123456789101112zzz&quot;);
3370         p = Pattern.compile(&quot;(1)(2)(3)(4)(5)(6)(7)(8)(9)(10)(11)&quot;);
3371         m = p.matcher(blah);
3372         result = new StringBuilder();
3373         m.find();
3374         m.appendReplacement(result, toSupplementaries(&quot;$1w$11w$3&quot;));
3375         if (!result.toString().equals(toSupplementaries(&quot;zzz1w11w3&quot;)))
3376             failCount++;
3377 
3378         // Check to make sure it backs off $15 to $1 if only three groups
3379         blah = toSupplementaries(&quot;zzzabcdcdefzzz&quot;);
3380         p = Pattern.compile(toSupplementaries(&quot;(ab)(cd)*(ef)&quot;));
3381         m = p.matcher(blah);
3382         result = new StringBuilder();
3383         m.find();
3384         m.appendReplacement(result, toSupplementaries(&quot;$1w$15w$3&quot;));
3385         if (!result.toString().equals(toSupplementaries(&quot;zzzabwab5wef&quot;)))
3386             failCount++;
3387         // Check nothing has been appended into the output buffer if
3388         // the replacement string triggers IllegalArgumentException.
3389         p = Pattern.compile(&quot;(abc)&quot;);
3390         m = p.matcher(&quot;abcd&quot;);
3391         result = new StringBuilder();
3392         m.find();
3393         try {
3394             m.appendReplacement(result, (&quot;xyz$g&quot;));
3395             failCount++;
3396         } catch (IllegalArgumentException iae) {
3397             if (result.length() != 0)
3398                 failCount++;
3399         }
3400         report(&quot;SB Substitution 2&quot;);
3401     }
3402 
3403     /*
3404      * 5 groups of characters are created to make a substitution string.
3405      * A base string will be created including random lead chars, the
3406      * substitution string, and random trailing chars.
3407      * A pattern containing the 5 groups is searched for and replaced with:
3408      * random group + random string + random group.
3409      * The results are checked for correctness.
3410      */
3411     private static void substitutionBasher() {
3412         for (int runs = 0; runs&lt;1000; runs++) {
3413             // Create a base string to work in
3414             int leadingChars = generator.nextInt(10);
3415             StringBuffer baseBuffer = new StringBuffer(100);
3416             String leadingString = getRandomAlphaString(leadingChars);
3417             baseBuffer.append(leadingString);
3418 
3419             // Create 5 groups of random number of random chars
3420             // Create the string to substitute
3421             // Create the pattern string to search for
3422             StringBuffer bufferToSub = new StringBuffer(25);
3423             StringBuffer bufferToPat = new StringBuffer(50);
3424             String[] groups = new String[5];
3425             for(int i=0; i&lt;5; i++) {
3426                 int aGroupSize = generator.nextInt(5)+1;
3427                 groups[i] = getRandomAlphaString(aGroupSize);
3428                 bufferToSub.append(groups[i]);
3429                 bufferToPat.append(&#39;(&#39;);
3430                 bufferToPat.append(groups[i]);
3431                 bufferToPat.append(&#39;)&#39;);
3432             }
3433             String stringToSub = bufferToSub.toString();
3434             String pattern = bufferToPat.toString();
3435 
3436             // Place sub string into working string at random index
3437             baseBuffer.append(stringToSub);
3438 
3439             // Append random chars to end
3440             int trailingChars = generator.nextInt(10);
3441             String trailingString = getRandomAlphaString(trailingChars);
3442             baseBuffer.append(trailingString);
3443             String baseString = baseBuffer.toString();
3444 
3445             // Create test pattern and matcher
3446             Pattern p = Pattern.compile(pattern);
3447             Matcher m = p.matcher(baseString);
3448 
3449             // Reject candidate if pattern happens to start early
3450             m.find();
3451             if (m.start() &lt; leadingChars)
3452                 continue;
3453 
3454             // Reject candidate if more than one match
3455             if (m.find())
3456                 continue;
3457 
3458             // Construct a replacement string with :
3459             // random group + random string + random group
3460             StringBuffer bufferToRep = new StringBuffer();
3461             int groupIndex1 = generator.nextInt(5);
3462             bufferToRep.append(&quot;$&quot; + (groupIndex1 + 1));
3463             String randomMidString = getRandomAlphaString(5);
3464             bufferToRep.append(randomMidString);
3465             int groupIndex2 = generator.nextInt(5);
3466             bufferToRep.append(&quot;$&quot; + (groupIndex2 + 1));
3467             String replacement = bufferToRep.toString();
3468 
3469             // Do the replacement
3470             String result = m.replaceAll(replacement);
3471 
3472             // Construct expected result
3473             StringBuffer bufferToRes = new StringBuffer();
3474             bufferToRes.append(leadingString);
3475             bufferToRes.append(groups[groupIndex1]);
3476             bufferToRes.append(randomMidString);
3477             bufferToRes.append(groups[groupIndex2]);
3478             bufferToRes.append(trailingString);
3479             String expectedResult = bufferToRes.toString();
3480 
3481             // Check results
3482             if (!result.equals(expectedResult))
3483                 failCount++;
3484         }
3485 
3486         report(&quot;Substitution Basher&quot;);
3487     }
3488 
3489     /*
3490      * 5 groups of characters are created to make a substitution string.
3491      * A base string will be created including random lead chars, the
3492      * substitution string, and random trailing chars.
3493      * A pattern containing the 5 groups is searched for and replaced with:
3494      * random group + random string + random group.
3495      * The results are checked for correctness.
3496      */
3497     private static void substitutionBasher2() {
3498         for (int runs = 0; runs&lt;1000; runs++) {
3499             // Create a base string to work in
3500             int leadingChars = generator.nextInt(10);
3501             StringBuilder baseBuffer = new StringBuilder(100);
3502             String leadingString = getRandomAlphaString(leadingChars);
3503             baseBuffer.append(leadingString);
3504 
3505             // Create 5 groups of random number of random chars
3506             // Create the string to substitute
3507             // Create the pattern string to search for
3508             StringBuilder bufferToSub = new StringBuilder(25);
3509             StringBuilder bufferToPat = new StringBuilder(50);
3510             String[] groups = new String[5];
3511             for(int i=0; i&lt;5; i++) {
3512                 int aGroupSize = generator.nextInt(5)+1;
3513                 groups[i] = getRandomAlphaString(aGroupSize);
3514                 bufferToSub.append(groups[i]);
3515                 bufferToPat.append(&#39;(&#39;);
3516                 bufferToPat.append(groups[i]);
3517                 bufferToPat.append(&#39;)&#39;);
3518             }
3519             String stringToSub = bufferToSub.toString();
3520             String pattern = bufferToPat.toString();
3521 
3522             // Place sub string into working string at random index
3523             baseBuffer.append(stringToSub);
3524 
3525             // Append random chars to end
3526             int trailingChars = generator.nextInt(10);
3527             String trailingString = getRandomAlphaString(trailingChars);
3528             baseBuffer.append(trailingString);
3529             String baseString = baseBuffer.toString();
3530 
3531             // Create test pattern and matcher
3532             Pattern p = Pattern.compile(pattern);
3533             Matcher m = p.matcher(baseString);
3534 
3535             // Reject candidate if pattern happens to start early
3536             m.find();
3537             if (m.start() &lt; leadingChars)
3538                 continue;
3539 
3540             // Reject candidate if more than one match
3541             if (m.find())
3542                 continue;
3543 
3544             // Construct a replacement string with :
3545             // random group + random string + random group
3546             StringBuilder bufferToRep = new StringBuilder();
3547             int groupIndex1 = generator.nextInt(5);
3548             bufferToRep.append(&quot;$&quot; + (groupIndex1 + 1));
3549             String randomMidString = getRandomAlphaString(5);
3550             bufferToRep.append(randomMidString);
3551             int groupIndex2 = generator.nextInt(5);
3552             bufferToRep.append(&quot;$&quot; + (groupIndex2 + 1));
3553             String replacement = bufferToRep.toString();
3554 
3555             // Do the replacement
3556             String result = m.replaceAll(replacement);
3557 
3558             // Construct expected result
3559             StringBuilder bufferToRes = new StringBuilder();
3560             bufferToRes.append(leadingString);
3561             bufferToRes.append(groups[groupIndex1]);
3562             bufferToRes.append(randomMidString);
3563             bufferToRes.append(groups[groupIndex2]);
3564             bufferToRes.append(trailingString);
3565             String expectedResult = bufferToRes.toString();
3566 
3567             // Check results
3568             if (!result.equals(expectedResult)) {
3569                 failCount++;
3570             }
3571         }
3572 
3573         report(&quot;Substitution Basher 2&quot;);
3574     }
3575 
3576     /**
3577      * Checks the handling of some escape sequences that the Pattern
3578      * class should process instead of the java compiler. These are
3579      * not in the file because the escapes should be be processed
3580      * by the Pattern class when the regex is compiled.
3581      */
3582     private static void escapes() throws Exception {
3583         Pattern p = Pattern.compile(&quot;\\043&quot;);
3584         Matcher m = p.matcher(&quot;#&quot;);
3585         if (!m.find())
3586             failCount++;
3587 
3588         p = Pattern.compile(&quot;\\x23&quot;);
3589         m = p.matcher(&quot;#&quot;);
3590         if (!m.find())
3591             failCount++;
3592 
3593         p = Pattern.compile(&quot;\\u0023&quot;);
3594         m = p.matcher(&quot;#&quot;);
3595         if (!m.find())
3596             failCount++;
3597 
3598         report(&quot;Escape sequences&quot;);
3599     }
3600 
3601     /**
3602      * Checks the handling of blank input situations. These
3603      * tests are incompatible with my test file format.
3604      */
3605     private static void blankInput() throws Exception {
3606         Pattern p = Pattern.compile(&quot;abc&quot;, Pattern.CASE_INSENSITIVE);
3607         Matcher m = p.matcher(&quot;&quot;);
3608         if (m.find())
3609             failCount++;
3610 
3611         p = Pattern.compile(&quot;a*&quot;, Pattern.CASE_INSENSITIVE);
3612         m = p.matcher(&quot;&quot;);
3613         if (!m.find())
3614             failCount++;
3615 
3616         p = Pattern.compile(&quot;abc&quot;);
3617         m = p.matcher(&quot;&quot;);
3618         if (m.find())
3619             failCount++;
3620 
3621         p = Pattern.compile(&quot;a*&quot;);
3622         m = p.matcher(&quot;&quot;);
3623         if (!m.find())
3624             failCount++;
3625 
3626         report(&quot;Blank input&quot;);
3627     }
3628 
3629     /**
3630      * Tests the Boyer-Moore pattern matching of a character sequence
3631      * on randomly generated patterns.
3632      */
3633     private static void bm() throws Exception {
3634         doBnM(&#39;a&#39;);
3635         report(&quot;Boyer Moore (ASCII)&quot;);
3636 
3637         doBnM(Character.MIN_SUPPLEMENTARY_CODE_POINT - 10);
3638         report(&quot;Boyer Moore (Supplementary)&quot;);
3639     }
3640 
3641     private static void doBnM(int baseCharacter) throws Exception {
3642         int achar=0;
3643 
3644         for (int i=0; i&lt;100; i++) {
3645             // Create a short pattern to search for
3646             int patternLength = generator.nextInt(7) + 4;
3647             StringBuffer patternBuffer = new StringBuffer(patternLength);
3648             String pattern;
3649             retry: for (;;) {
3650                 for (int x=0; x&lt;patternLength; x++) {
3651                     int ch = baseCharacter + generator.nextInt(26);
3652                     if (Character.isSupplementaryCodePoint(ch)) {
3653                         patternBuffer.append(Character.toChars(ch));
3654                     } else {
3655                         patternBuffer.append((char)ch);
3656                     }
3657                 }
3658                 pattern = patternBuffer.toString();
3659 
3660                 // Avoid patterns that start and end with the same substring
3661                 // See JDK-6854417
3662                 for (int x=1; x &lt; pattern.length(); x++) {
3663                     if (pattern.startsWith(pattern.substring(x)))
3664                         continue retry;
3665                 }
3666                 break;
3667             }
3668             Pattern p = Pattern.compile(pattern);
3669 
3670             // Create a buffer with random ASCII chars that does
3671             // not match the sample
3672             String toSearch = null;
3673             StringBuffer s = null;
3674             Matcher m = p.matcher(&quot;&quot;);
3675             do {
3676                 s = new StringBuffer(100);
3677                 for (int x=0; x&lt;100; x++) {
3678                     int ch = baseCharacter + generator.nextInt(26);
3679                     if (Character.isSupplementaryCodePoint(ch)) {
3680                         s.append(Character.toChars(ch));
3681                     } else {
3682                         s.append((char)ch);
3683                     }
3684                 }
3685                 toSearch = s.toString();
3686                 m.reset(toSearch);
3687             } while (m.find());
3688 
3689             // Insert the pattern at a random spot
3690             int insertIndex = generator.nextInt(99);
3691             if (Character.isLowSurrogate(s.charAt(insertIndex)))
3692                 insertIndex++;
3693             s = s.insert(insertIndex, pattern);
3694             toSearch = s.toString();
3695 
3696             // Make sure that the pattern is found
3697             m.reset(toSearch);
3698             if (!m.find())
3699                 failCount++;
3700 
3701             // Make sure that the match text is the pattern
3702             if (!m.group().equals(pattern))
3703                 failCount++;
3704 
3705             // Make sure match occured at insertion point
3706             if (m.start() != insertIndex)
3707                 failCount++;
3708         }
3709     }
3710 
3711     /**
3712      * Tests the matching of slices on randomly generated patterns.
3713      * The Boyer-Moore optimization is not done on these patterns
3714      * because it uses unicode case folding.
3715      */
3716     private static void slice() throws Exception {
3717         doSlice(Character.MAX_VALUE);
3718         report(&quot;Slice&quot;);
3719 
3720         doSlice(Character.MAX_CODE_POINT);
3721         report(&quot;Slice (Supplementary)&quot;);
3722     }
3723 
3724     private static void doSlice(int maxCharacter) throws Exception {
3725         Random generator = new Random();
3726         int achar=0;
3727 
3728         for (int i=0; i&lt;100; i++) {
3729             // Create a short pattern to search for
3730             int patternLength = generator.nextInt(7) + 4;
3731             StringBuffer patternBuffer = new StringBuffer(patternLength);
3732             for (int x=0; x&lt;patternLength; x++) {
3733                 int randomChar = 0;
3734                 while (!Character.isLetterOrDigit(randomChar))
3735                     randomChar = generator.nextInt(maxCharacter);
3736                 if (Character.isSupplementaryCodePoint(randomChar)) {
3737                     patternBuffer.append(Character.toChars(randomChar));
3738                 } else {
3739                     patternBuffer.append((char) randomChar);
3740                 }
3741             }
3742             String pattern =  patternBuffer.toString();
3743             Pattern p = Pattern.compile(pattern, Pattern.UNICODE_CASE);
3744 
3745             // Create a buffer with random chars that does not match the sample
3746             String toSearch = null;
3747             StringBuffer s = null;
3748             Matcher m = p.matcher(&quot;&quot;);
3749             do {
3750                 s = new StringBuffer(100);
3751                 for (int x=0; x&lt;100; x++) {
3752                     int randomChar = 0;
3753                     while (!Character.isLetterOrDigit(randomChar))
3754                         randomChar = generator.nextInt(maxCharacter);
3755                     if (Character.isSupplementaryCodePoint(randomChar)) {
3756                         s.append(Character.toChars(randomChar));
3757                     } else {
3758                         s.append((char) randomChar);
3759                     }
3760                 }
3761                 toSearch = s.toString();
3762                 m.reset(toSearch);
3763             } while (m.find());
3764 
3765             // Insert the pattern at a random spot
3766             int insertIndex = generator.nextInt(99);
3767             if (Character.isLowSurrogate(s.charAt(insertIndex)))
3768                 insertIndex++;
3769             s = s.insert(insertIndex, pattern);
3770             toSearch = s.toString();
3771 
3772             // Make sure that the pattern is found
3773             m.reset(toSearch);
3774             if (!m.find())
3775                 failCount++;
3776 
3777             // Make sure that the match text is the pattern
3778             if (!m.group().equals(pattern))
3779                 failCount++;
3780 
3781             // Make sure match occured at insertion point
3782             if (m.start() != insertIndex)
3783                 failCount++;
3784         }
3785     }
3786 
3787     private static void explainFailure(String pattern, String data,
3788                                        String expected, String actual) {
3789         System.err.println(&quot;----------------------------------------&quot;);
3790         System.err.println(&quot;Pattern = &quot;+pattern);
3791         System.err.println(&quot;Data = &quot;+data);
3792         System.err.println(&quot;Expected = &quot; + expected);
3793         System.err.println(&quot;Actual   = &quot; + actual);
3794     }
3795 
3796     private static void explainFailure(String pattern, String data,
3797                                        Throwable t) {
3798         System.err.println(&quot;----------------------------------------&quot;);
3799         System.err.println(&quot;Pattern = &quot;+pattern);
3800         System.err.println(&quot;Data = &quot;+data);
3801         t.printStackTrace(System.err);
3802     }
3803 
3804     // Testing examples from a file
3805 
3806     /**
3807      * Goes through the file &quot;TestCases.txt&quot; and creates many patterns
3808      * described in the file, matching the patterns against input lines in
3809      * the file, and comparing the results against the correct results
3810      * also found in the file. The file format is described in comments
3811      * at the head of the file.
3812      */
3813     private static void processFile(String fileName) throws Exception {
3814         File testCases = new File(System.getProperty(&quot;test.src&quot;, &quot;.&quot;),
3815                                   fileName);
3816         FileInputStream in = new FileInputStream(testCases);
3817         BufferedReader r = new BufferedReader(new InputStreamReader(in));
3818 
3819         // Process next test case.
3820         String aLine;
3821         while((aLine = r.readLine()) != null) {
3822             // Read a line for pattern
3823             String patternString = grabLine(r);
3824             Pattern p = null;
3825             try {
3826                 p = compileTestPattern(patternString);
3827             } catch (PatternSyntaxException e) {
3828                 String dataString = grabLine(r);
3829                 String expectedResult = grabLine(r);
3830                 if (expectedResult.startsWith(&quot;error&quot;))
3831                     continue;
3832                 explainFailure(patternString, dataString, e);
3833                 failCount++;
3834                 continue;
3835             }
3836 
3837             // Read a line for input string
3838             String dataString = grabLine(r);
3839             Matcher m = p.matcher(dataString);
3840             StringBuffer result = new StringBuffer();
3841 
3842             // Check for IllegalStateExceptions before a match
3843             failCount += preMatchInvariants(m);
3844 
3845             boolean found = m.find();
3846 
3847             if (found)
3848                 failCount += postTrueMatchInvariants(m);
3849             else
3850                 failCount += postFalseMatchInvariants(m);
3851 
3852             if (found) {
3853                 result.append(&quot;true &quot;);
3854                 result.append(m.group(0) + &quot; &quot;);
3855             } else {
3856                 result.append(&quot;false &quot;);
3857             }
3858 
3859             result.append(m.groupCount());
3860 
3861             if (found) {
3862                 for (int i=1; i&lt;m.groupCount()+1; i++)
3863                     if (m.group(i) != null)
3864                         result.append(&quot; &quot; +m.group(i));
3865             }
3866 
3867             // Read a line for the expected result
3868             String expectedResult = grabLine(r);
3869 
3870             if (!result.toString().equals(expectedResult)) {
3871                 explainFailure(patternString, dataString, expectedResult, result.toString());
3872                 failCount++;
3873             }
3874         }
3875 
3876         report(fileName);
3877     }
3878 
3879     private static int preMatchInvariants(Matcher m) {
3880         int failCount = 0;
3881         try {
3882             m.start();
3883             failCount++;
3884         } catch (IllegalStateException ise) {}
3885         try {
3886             m.end();
3887             failCount++;
3888         } catch (IllegalStateException ise) {}
3889         try {
3890             m.group();
3891             failCount++;
3892         } catch (IllegalStateException ise) {}
3893         return failCount;
3894     }
3895 
3896     private static int postFalseMatchInvariants(Matcher m) {
3897         int failCount = 0;
3898         try {
3899             m.group();
3900             failCount++;
3901         } catch (IllegalStateException ise) {}
3902         try {
3903             m.start();
3904             failCount++;
3905         } catch (IllegalStateException ise) {}
3906         try {
3907             m.end();
3908             failCount++;
3909         } catch (IllegalStateException ise) {}
3910         return failCount;
3911     }
3912 
3913     private static int postTrueMatchInvariants(Matcher m) {
3914         int failCount = 0;
3915         //assert(m.start() = m.start(0);
3916         if (m.start() != m.start(0))
3917             failCount++;
3918         //assert(m.end() = m.end(0);
3919         if (m.start() != m.start(0))
3920             failCount++;
3921         //assert(m.group() = m.group(0);
3922         if (!m.group().equals(m.group(0)))
3923             failCount++;
3924         try {
3925             m.group(50);
3926             failCount++;
3927         } catch (IndexOutOfBoundsException ise) {}
3928 
3929         return failCount;
3930     }
3931 
3932     private static Pattern compileTestPattern(String patternString) {
3933         if (!patternString.startsWith(&quot;&#39;&quot;)) {
3934             return Pattern.compile(patternString);
3935         }
3936         int break1 = patternString.lastIndexOf(&quot;&#39;&quot;);
3937         String flagString = patternString.substring(
3938                                           break1+1, patternString.length());
3939         patternString = patternString.substring(1, break1);
3940 
3941         if (flagString.equals(&quot;i&quot;))
3942             return Pattern.compile(patternString, Pattern.CASE_INSENSITIVE);
3943 
3944         if (flagString.equals(&quot;m&quot;))
3945             return Pattern.compile(patternString, Pattern.MULTILINE);
3946 
3947         return Pattern.compile(patternString);
3948     }
3949 
3950     /**
3951      * Reads a line from the input file. Keeps reading lines until a non
3952      * empty non comment line is read. If the line contains a \n then
3953      * these two characters are replaced by a newline char. If a \\uxxxx
3954      * sequence is read then the sequence is replaced by the unicode char.
3955      */
3956     private static String grabLine(BufferedReader r) throws Exception {
3957         int index = 0;
3958         String line = r.readLine();
3959         while (line.startsWith(&quot;//&quot;) || line.length() &lt; 1)
3960             line = r.readLine();
3961         while ((index = line.indexOf(&quot;\\n&quot;)) != -1) {
3962             StringBuffer temp = new StringBuffer(line);
3963             temp.replace(index, index+2, &quot;\n&quot;);
3964             line = temp.toString();
3965         }
3966         while ((index = line.indexOf(&quot;\\u&quot;)) != -1) {
3967             StringBuffer temp = new StringBuffer(line);
3968             String value = temp.substring(index+2, index+6);
3969             char aChar = (char)Integer.parseInt(value, 16);
3970             String unicodeChar = &quot;&quot; + aChar;
3971             temp.replace(index, index+6, unicodeChar);
3972             line = temp.toString();
3973         }
3974 
3975         return line;
3976     }
3977 
3978     private static void check(Pattern p, String s, String g, String expected) {
3979         Matcher m = p.matcher(s);
3980         m.find();
3981         if (!m.group(g).equals(expected) ||
3982             s.charAt(m.start(g)) != expected.charAt(0) ||
3983             s.charAt(m.end(g) - 1) != expected.charAt(expected.length() - 1))
3984             failCount++;
3985     }
3986 
3987     private static void checkReplaceFirst(String p, String s, String r, String expected)
3988     {
3989         if (!expected.equals(Pattern.compile(p)
3990                                     .matcher(s)
3991                                     .replaceFirst(r)))
3992             failCount++;
3993     }
3994 
3995     private static void checkReplaceAll(String p, String s, String r, String expected)
3996     {
3997         if (!expected.equals(Pattern.compile(p)
3998                                     .matcher(s)
3999                                     .replaceAll(r)))
4000             failCount++;
4001     }
4002 
4003     private static void checkExpectedFail(String p) {
4004         try {
4005             Pattern.compile(p);
4006         } catch (PatternSyntaxException pse) {
4007             //pse.printStackTrace();
4008             return;
4009         }
4010         failCount++;
4011     }
4012 
4013     private static void checkExpectedIAE(Matcher m, String g) {
4014         m.find();
4015         try {
4016             m.group(g);
4017         } catch (IllegalArgumentException x) {
4018             //iae.printStackTrace();
4019             try {
4020                 m.start(g);
4021             } catch (IllegalArgumentException xx) {
4022                 try {
4023                     m.start(g);
4024                 } catch (IllegalArgumentException xxx) {
4025                     return;
4026                 }
4027             }
4028         }
4029         failCount++;
4030     }
4031 
4032     private static void checkExpectedNPE(Matcher m) {
4033         m.find();
4034         try {
4035             m.group(null);
4036         } catch (NullPointerException x) {
4037             try {
4038                 m.start(null);
4039             } catch (NullPointerException xx) {
4040                 try {
4041                     m.end(null);
4042                 } catch (NullPointerException xxx) {
4043                     return;
4044                 }
4045             }
4046         }
4047         failCount++;
4048     }
4049 
4050     private static void namedGroupCaptureTest() throws Exception {
4051         check(Pattern.compile(&quot;x+(?&lt;gname&gt;y+)z+&quot;),
4052               &quot;xxxyyyzzz&quot;,
4053               &quot;gname&quot;,
4054               &quot;yyy&quot;);
4055 
4056         check(Pattern.compile(&quot;x+(?&lt;gname8&gt;y+)z+&quot;),
4057               &quot;xxxyyyzzz&quot;,
4058               &quot;gname8&quot;,
4059               &quot;yyy&quot;);
4060 
4061         //backref
4062         Pattern pattern = Pattern.compile(&quot;(a*)bc\\1&quot;);
4063         check(pattern, &quot;zzzaabcazzz&quot;, true);  // found &quot;abca&quot;
4064 
4065         check(Pattern.compile(&quot;(?&lt;gname&gt;a*)bc\\k&lt;gname&gt;&quot;),
4066               &quot;zzzaabcaazzz&quot;, true);
4067 
4068         check(Pattern.compile(&quot;(?&lt;gname&gt;abc)(def)\\k&lt;gname&gt;&quot;),
4069               &quot;abcdefabc&quot;, true);
4070 
4071         check(Pattern.compile(&quot;(a)(b)(c)(d)(e)(f)(g)(h)(i)(j)(?&lt;gname&gt;k)\\k&lt;gname&gt;&quot;),
4072               &quot;abcdefghijkk&quot;, true);
4073 
4074         // Supplementary character tests
4075         check(Pattern.compile(&quot;(?&lt;gname&gt;&quot; + toSupplementaries(&quot;a*)bc&quot;) + &quot;\\k&lt;gname&gt;&quot;),
4076               toSupplementaries(&quot;zzzaabcazzz&quot;), true);
4077 
4078         check(Pattern.compile(&quot;(?&lt;gname&gt;&quot; + toSupplementaries(&quot;a*)bc&quot;) + &quot;\\k&lt;gname&gt;&quot;),
4079               toSupplementaries(&quot;zzzaabcaazzz&quot;), true);
4080 
4081         check(Pattern.compile(&quot;(?&lt;gname&gt;&quot; + toSupplementaries(&quot;abc)(def)&quot;) + &quot;\\k&lt;gname&gt;&quot;),
4082               toSupplementaries(&quot;abcdefabc&quot;), true);
4083 
4084         check(Pattern.compile(toSupplementaries(&quot;(a)(b)(c)(d)(e)(f)(g)(h)(i)(j)&quot;) +
4085                               &quot;(?&lt;gname&gt;&quot; +
4086                               toSupplementaries(&quot;k)&quot;) + &quot;\\k&lt;gname&gt;&quot;),
4087               toSupplementaries(&quot;abcdefghijkk&quot;), true);
4088 
4089         check(Pattern.compile(&quot;x+(?&lt;gname&gt;y+)z+\\k&lt;gname&gt;&quot;),
4090               &quot;xxxyyyzzzyyy&quot;,
4091               &quot;gname&quot;,
4092               &quot;yyy&quot;);
4093 
4094         //replaceFirst/All
4095         checkReplaceFirst(&quot;(?&lt;gn&gt;ab)(c*)&quot;,
4096                           &quot;abccczzzabcczzzabccc&quot;,
4097                           &quot;${gn}&quot;,
4098                           &quot;abzzzabcczzzabccc&quot;);
4099 
4100         checkReplaceAll(&quot;(?&lt;gn&gt;ab)(c*)&quot;,
4101                         &quot;abccczzzabcczzzabccc&quot;,
4102                         &quot;${gn}&quot;,
4103                         &quot;abzzzabzzzab&quot;);
4104 
4105 
4106         checkReplaceFirst(&quot;(?&lt;gn&gt;ab)(c*)&quot;,
4107                           &quot;zzzabccczzzabcczzzabccczzz&quot;,
4108                           &quot;${gn}&quot;,
4109                           &quot;zzzabzzzabcczzzabccczzz&quot;);
4110 
4111         checkReplaceAll(&quot;(?&lt;gn&gt;ab)(c*)&quot;,
4112                         &quot;zzzabccczzzabcczzzabccczzz&quot;,
4113                         &quot;${gn}&quot;,
4114                         &quot;zzzabzzzabzzzabzzz&quot;);
4115 
4116         checkReplaceFirst(&quot;(?&lt;gn1&gt;ab)(?&lt;gn2&gt;c*)&quot;,
4117                           &quot;zzzabccczzzabcczzzabccczzz&quot;,
4118                           &quot;${gn2}&quot;,
4119                           &quot;zzzccczzzabcczzzabccczzz&quot;);
4120 
4121         checkReplaceAll(&quot;(?&lt;gn1&gt;ab)(?&lt;gn2&gt;c*)&quot;,
4122                         &quot;zzzabccczzzabcczzzabccczzz&quot;,
4123                         &quot;${gn2}&quot;,
4124                         &quot;zzzccczzzcczzzccczzz&quot;);
4125 
4126         //toSupplementaries(&quot;(ab)(c*)&quot;));
4127         checkReplaceFirst(&quot;(?&lt;gn1&gt;&quot; + toSupplementaries(&quot;ab&quot;) +
4128                            &quot;)(?&lt;gn2&gt;&quot; + toSupplementaries(&quot;c&quot;) + &quot;*)&quot;,
4129                           toSupplementaries(&quot;abccczzzabcczzzabccc&quot;),
4130                           &quot;${gn1}&quot;,
4131                           toSupplementaries(&quot;abzzzabcczzzabccc&quot;));
4132 
4133 
4134         checkReplaceAll(&quot;(?&lt;gn1&gt;&quot; + toSupplementaries(&quot;ab&quot;) +
4135                         &quot;)(?&lt;gn2&gt;&quot; + toSupplementaries(&quot;c&quot;) + &quot;*)&quot;,
4136                         toSupplementaries(&quot;abccczzzabcczzzabccc&quot;),
4137                         &quot;${gn1}&quot;,
4138                         toSupplementaries(&quot;abzzzabzzzab&quot;));
4139 
4140         checkReplaceFirst(&quot;(?&lt;gn1&gt;&quot; + toSupplementaries(&quot;ab&quot;) +
4141                            &quot;)(?&lt;gn2&gt;&quot; + toSupplementaries(&quot;c&quot;) + &quot;*)&quot;,
4142                           toSupplementaries(&quot;abccczzzabcczzzabccc&quot;),
4143                           &quot;${gn2}&quot;,
4144                           toSupplementaries(&quot;ccczzzabcczzzabccc&quot;));
4145 
4146 
4147         checkReplaceAll(&quot;(?&lt;gn1&gt;&quot; + toSupplementaries(&quot;ab&quot;) +
4148                         &quot;)(?&lt;gn2&gt;&quot; + toSupplementaries(&quot;c&quot;) + &quot;*)&quot;,
4149                         toSupplementaries(&quot;abccczzzabcczzzabccc&quot;),
4150                         &quot;${gn2}&quot;,
4151                         toSupplementaries(&quot;ccczzzcczzzccc&quot;));
4152 
4153         checkReplaceFirst(&quot;(?&lt;dog&gt;Dog)AndCat&quot;,
4154                           &quot;zzzDogAndCatzzzDogAndCatzzz&quot;,
4155                           &quot;${dog}&quot;,
4156                           &quot;zzzDogzzzDogAndCatzzz&quot;);
4157 
4158 
4159         checkReplaceAll(&quot;(?&lt;dog&gt;Dog)AndCat&quot;,
4160                           &quot;zzzDogAndCatzzzDogAndCatzzz&quot;,
4161                           &quot;${dog}&quot;,
4162                           &quot;zzzDogzzzDogzzz&quot;);
4163 
4164         // backref in Matcher &amp; String
4165         if (!&quot;abcdefghij&quot;.replaceFirst(&quot;cd(?&lt;gn&gt;ef)gh&quot;, &quot;${gn}&quot;).equals(&quot;abefij&quot;) ||
4166             !&quot;abbbcbdbefgh&quot;.replaceAll(&quot;(?&lt;gn&gt;[a-e])b&quot;, &quot;${gn}&quot;).equals(&quot;abcdefgh&quot;))
4167             failCount++;
4168 
4169         // negative
4170         checkExpectedFail(&quot;(?&lt;groupnamehasnoascii.in&gt;abc)(def)&quot;);
4171         checkExpectedFail(&quot;(?&lt;groupnamehasnoascii_in&gt;abc)(def)&quot;);
4172         checkExpectedFail(&quot;(?&lt;6groupnamestartswithdigit&gt;abc)(def)&quot;);
4173         checkExpectedFail(&quot;(?&lt;gname&gt;abc)(def)\\k&lt;gnameX&gt;&quot;);
4174         checkExpectedFail(&quot;(?&lt;gname&gt;abc)(?&lt;gname&gt;def)\\k&lt;gnameX&gt;&quot;);
4175         checkExpectedIAE(Pattern.compile(&quot;(?&lt;gname&gt;abc)(def)&quot;).matcher(&quot;abcdef&quot;),
4176                          &quot;gnameX&quot;);
4177         checkExpectedNPE(Pattern.compile(&quot;(?&lt;gname&gt;abc)(def)&quot;).matcher(&quot;abcdef&quot;));
4178         report(&quot;NamedGroupCapture&quot;);
4179     }
4180 
4181     // This is for bug 6919132
4182     private static void nonBmpClassComplementTest() throws Exception {
4183         Pattern p = Pattern.compile(&quot;\\P{Lu}&quot;);
4184         Matcher m = p.matcher(new String(new int[] {0x1d400}, 0, 1));
4185 
4186         if (m.find() &amp;&amp; m.start() == 1)
4187             failCount++;
4188 
4189         // from a unicode category
4190         p = Pattern.compile(&quot;\\P{Lu}&quot;);
4191         m = p.matcher(new String(new int[] {0x1d400}, 0, 1));
4192         if (m.find())
4193             failCount++;
4194         if (!m.hitEnd())
4195             failCount++;
4196 
4197         // block
4198         p = Pattern.compile(&quot;\\P{InMathematicalAlphanumericSymbols}&quot;);
4199         m = p.matcher(new String(new int[] {0x1d400}, 0, 1));
4200         if (m.find() &amp;&amp; m.start() == 1)
4201             failCount++;
4202 
4203         p = Pattern.compile(&quot;\\P{sc=GRANTHA}&quot;);
4204         m = p.matcher(new String(new int[] {0x11350}, 0, 1));
4205         if (m.find() &amp;&amp; m.start() == 1)
4206             failCount++;
4207 
4208         report(&quot;NonBmpClassComplement&quot;);
4209     }
4210 
4211     private static void unicodePropertiesTest() throws Exception {
4212         // different forms
4213         if (!Pattern.compile(&quot;\\p{IsLu}&quot;).matcher(&quot;A&quot;).matches() ||
4214             !Pattern.compile(&quot;\\p{Lu}&quot;).matcher(&quot;A&quot;).matches() ||
4215             !Pattern.compile(&quot;\\p{gc=Lu}&quot;).matcher(&quot;A&quot;).matches() ||
4216             !Pattern.compile(&quot;\\p{general_category=Lu}&quot;).matcher(&quot;A&quot;).matches() ||
4217             !Pattern.compile(&quot;\\p{IsLatin}&quot;).matcher(&quot;B&quot;).matches() ||
4218             !Pattern.compile(&quot;\\p{sc=Latin}&quot;).matcher(&quot;B&quot;).matches() ||
4219             !Pattern.compile(&quot;\\p{script=Latin}&quot;).matcher(&quot;B&quot;).matches() ||
4220             !Pattern.compile(&quot;\\p{InBasicLatin}&quot;).matcher(&quot;c&quot;).matches() ||
4221             !Pattern.compile(&quot;\\p{blk=BasicLatin}&quot;).matcher(&quot;c&quot;).matches() ||
4222             !Pattern.compile(&quot;\\p{block=BasicLatin}&quot;).matcher(&quot;c&quot;).matches())
4223             failCount++;
4224 
4225         Matcher common  = Pattern.compile(&quot;\\p{script=Common}&quot;).matcher(&quot;&quot;);
4226         Matcher unknown = Pattern.compile(&quot;\\p{IsUnknown}&quot;).matcher(&quot;&quot;);
4227         Matcher lastSM  = common;
4228         Character.UnicodeScript lastScript = Character.UnicodeScript.of(0);
4229 
4230         Matcher latin  = Pattern.compile(&quot;\\p{block=basic_latin}&quot;).matcher(&quot;&quot;);
4231         Matcher greek  = Pattern.compile(&quot;\\p{InGreek}&quot;).matcher(&quot;&quot;);
4232         Matcher lastBM = latin;
4233         Character.UnicodeBlock lastBlock = Character.UnicodeBlock.of(0);
4234 
4235         for (int cp = 1; cp &lt; Character.MAX_CODE_POINT; cp++) {
4236             if (cp &gt;= 0x30000 &amp;&amp; (cp &amp; 0x70) == 0){
4237                 continue;  // only pick couple code points, they are the same
4238             }
4239 
4240             // Unicode Script
4241             Character.UnicodeScript script = Character.UnicodeScript.of(cp);
4242             Matcher m;
4243             String str = new String(Character.toChars(cp));
4244             if (script == lastScript) {
4245                  m = lastSM;
4246                  m.reset(str);
4247             } else {
4248                  m  = Pattern.compile(&quot;\\p{Is&quot; + script.name() + &quot;}&quot;).matcher(str);
4249             }
4250             if (!m.matches()) {
4251                 failCount++;
4252             }
4253             Matcher other = (script == Character.UnicodeScript.COMMON)? unknown : common;
4254             other.reset(str);
4255             if (other.matches()) {
4256                 failCount++;
4257             }
4258             lastSM = m;
4259             lastScript = script;
4260 
4261             // Unicode Block
4262             Character.UnicodeBlock block = Character.UnicodeBlock.of(cp);
4263             if (block == null) {
4264                 //System.out.printf(&quot;Not a Block: cp=%x%n&quot;, cp);
4265                 continue;
4266             }
4267             if (block == lastBlock) {
4268                  m = lastBM;
4269                  m.reset(str);
4270             } else {
4271                  m  = Pattern.compile(&quot;\\p{block=&quot; + block.toString() + &quot;}&quot;).matcher(str);
4272             }
4273             if (!m.matches()) {
4274                 failCount++;
4275             }
4276             other = (block == Character.UnicodeBlock.BASIC_LATIN)? greek : latin;
4277             other.reset(str);
4278             if (other.matches()) {
4279                 failCount++;
4280             }
4281             lastBM = m;
4282             lastBlock = block;
4283         }
4284         report(&quot;unicodeProperties&quot;);
4285     }
4286 
4287     private static void unicodeHexNotationTest() throws Exception {
4288 
4289         // negative
4290         checkExpectedFail(&quot;\\x{-23}&quot;);
4291         checkExpectedFail(&quot;\\x{110000}&quot;);
4292         checkExpectedFail(&quot;\\x{}&quot;);
4293         checkExpectedFail(&quot;\\x{AB[ef]&quot;);
4294 
4295         // codepoint
4296         check(&quot;^\\x{1033c}$&quot;,              &quot;\uD800\uDF3C&quot;, true);
4297         check(&quot;^\\xF0\\x90\\x8C\\xBC$&quot;,    &quot;\uD800\uDF3C&quot;, false);
4298         check(&quot;^\\x{D800}\\x{DF3c}+$&quot;,     &quot;\uD800\uDF3C&quot;, false);
4299         check(&quot;^\\xF0\\x90\\x8C\\xBC$&quot;,    &quot;\uD800\uDF3C&quot;, false);
4300 
4301         // in class
4302         check(&quot;^[\\x{D800}\\x{DF3c}]+$&quot;,   &quot;\uD800\uDF3C&quot;, false);
4303         check(&quot;^[\\xF0\\x90\\x8C\\xBC]+$&quot;, &quot;\uD800\uDF3C&quot;, false);
4304         check(&quot;^[\\x{D800}\\x{DF3C}]+$&quot;,   &quot;\uD800\uDF3C&quot;, false);
4305         check(&quot;^[\\x{DF3C}\\x{D800}]+$&quot;,   &quot;\uD800\uDF3C&quot;, false);
4306         check(&quot;^[\\x{D800}\\x{DF3C}]+$&quot;,   &quot;\uDF3C\uD800&quot;, true);
4307         check(&quot;^[\\x{DF3C}\\x{D800}]+$&quot;,   &quot;\uDF3C\uD800&quot;, true);
4308 
4309         for (int cp = 0; cp &lt;= 0x10FFFF; cp++) {
4310              String s = &quot;A&quot; + new String(Character.toChars(cp)) + &quot;B&quot;;
4311              String hexUTF16 = (cp &lt;= 0xFFFF)? String.format(&quot;\\u%04x&quot;, cp)
4312                                              : String.format(&quot;\\u%04x\\u%04x&quot;,
4313                                                (int) Character.toChars(cp)[0],
4314                                                (int) Character.toChars(cp)[1]);
4315              String hexCodePoint = &quot;\\x{&quot; + Integer.toHexString(cp) + &quot;}&quot;;
4316              if (!Pattern.matches(&quot;A&quot; + hexUTF16 + &quot;B&quot;, s))
4317                  failCount++;
4318              if (!Pattern.matches(&quot;A[&quot; + hexUTF16 + &quot;]B&quot;, s))
4319                  failCount++;
4320              if (!Pattern.matches(&quot;A&quot; + hexCodePoint + &quot;B&quot;, s))
4321                  failCount++;
4322              if (!Pattern.matches(&quot;A[&quot; + hexCodePoint + &quot;]B&quot;, s))
4323                  failCount++;
4324          }
4325          report(&quot;unicodeHexNotation&quot;);
4326     }
4327 
4328     private static void unicodeClassesTest() throws Exception {
4329 
4330         Matcher lower  = Pattern.compile(&quot;\\p{Lower}&quot;).matcher(&quot;&quot;);
4331         Matcher upper  = Pattern.compile(&quot;\\p{Upper}&quot;).matcher(&quot;&quot;);
4332         Matcher ASCII  = Pattern.compile(&quot;\\p{ASCII}&quot;).matcher(&quot;&quot;);
4333         Matcher alpha  = Pattern.compile(&quot;\\p{Alpha}&quot;).matcher(&quot;&quot;);
4334         Matcher digit  = Pattern.compile(&quot;\\p{Digit}&quot;).matcher(&quot;&quot;);
4335         Matcher alnum  = Pattern.compile(&quot;\\p{Alnum}&quot;).matcher(&quot;&quot;);
4336         Matcher punct  = Pattern.compile(&quot;\\p{Punct}&quot;).matcher(&quot;&quot;);
4337         Matcher graph  = Pattern.compile(&quot;\\p{Graph}&quot;).matcher(&quot;&quot;);
4338         Matcher print  = Pattern.compile(&quot;\\p{Print}&quot;).matcher(&quot;&quot;);
4339         Matcher blank  = Pattern.compile(&quot;\\p{Blank}&quot;).matcher(&quot;&quot;);
4340         Matcher cntrl  = Pattern.compile(&quot;\\p{Cntrl}&quot;).matcher(&quot;&quot;);
4341         Matcher xdigit = Pattern.compile(&quot;\\p{XDigit}&quot;).matcher(&quot;&quot;);
4342         Matcher space  = Pattern.compile(&quot;\\p{Space}&quot;).matcher(&quot;&quot;);
4343         Matcher bound  = Pattern.compile(&quot;\\b&quot;).matcher(&quot;&quot;);
4344         Matcher word   = Pattern.compile(&quot;\\w++&quot;).matcher(&quot;&quot;);
4345         // UNICODE_CHARACTER_CLASS
4346         Matcher lowerU  = Pattern.compile(&quot;\\p{Lower}&quot;, Pattern.UNICODE_CHARACTER_CLASS).matcher(&quot;&quot;);
4347         Matcher upperU  = Pattern.compile(&quot;\\p{Upper}&quot;, Pattern.UNICODE_CHARACTER_CLASS).matcher(&quot;&quot;);
4348         Matcher ASCIIU  = Pattern.compile(&quot;\\p{ASCII}&quot;, Pattern.UNICODE_CHARACTER_CLASS).matcher(&quot;&quot;);
4349         Matcher alphaU  = Pattern.compile(&quot;\\p{Alpha}&quot;, Pattern.UNICODE_CHARACTER_CLASS).matcher(&quot;&quot;);
4350         Matcher digitU  = Pattern.compile(&quot;\\p{Digit}&quot;, Pattern.UNICODE_CHARACTER_CLASS).matcher(&quot;&quot;);
4351         Matcher alnumU  = Pattern.compile(&quot;\\p{Alnum}&quot;, Pattern.UNICODE_CHARACTER_CLASS).matcher(&quot;&quot;);
4352         Matcher punctU  = Pattern.compile(&quot;\\p{Punct}&quot;, Pattern.UNICODE_CHARACTER_CLASS).matcher(&quot;&quot;);
4353         Matcher graphU  = Pattern.compile(&quot;\\p{Graph}&quot;, Pattern.UNICODE_CHARACTER_CLASS).matcher(&quot;&quot;);
4354         Matcher printU  = Pattern.compile(&quot;\\p{Print}&quot;, Pattern.UNICODE_CHARACTER_CLASS).matcher(&quot;&quot;);
4355         Matcher blankU  = Pattern.compile(&quot;\\p{Blank}&quot;, Pattern.UNICODE_CHARACTER_CLASS).matcher(&quot;&quot;);
4356         Matcher cntrlU  = Pattern.compile(&quot;\\p{Cntrl}&quot;, Pattern.UNICODE_CHARACTER_CLASS).matcher(&quot;&quot;);
4357         Matcher xdigitU = Pattern.compile(&quot;\\p{XDigit}&quot;, Pattern.UNICODE_CHARACTER_CLASS).matcher(&quot;&quot;);
4358         Matcher spaceU  = Pattern.compile(&quot;\\p{Space}&quot;, Pattern.UNICODE_CHARACTER_CLASS).matcher(&quot;&quot;);
4359         Matcher boundU  = Pattern.compile(&quot;\\b&quot;, Pattern.UNICODE_CHARACTER_CLASS).matcher(&quot;&quot;);
4360         Matcher wordU   = Pattern.compile(&quot;\\w&quot;, Pattern.UNICODE_CHARACTER_CLASS).matcher(&quot;&quot;);
4361         // embedded flag (?U)
4362         Matcher lowerEU  = Pattern.compile(&quot;(?U)\\p{Lower}&quot;, Pattern.UNICODE_CHARACTER_CLASS).matcher(&quot;&quot;);
4363         Matcher graphEU  = Pattern.compile(&quot;(?U)\\p{Graph}&quot;, Pattern.UNICODE_CHARACTER_CLASS).matcher(&quot;&quot;);
4364         Matcher wordEU   = Pattern.compile(&quot;(?U)\\w&quot;, Pattern.UNICODE_CHARACTER_CLASS).matcher(&quot;&quot;);
4365 
4366         Matcher bwb    = Pattern.compile(&quot;\\b\\w\\b&quot;).matcher(&quot;&quot;);
4367         Matcher bwbU   = Pattern.compile(&quot;\\b\\w++\\b&quot;, Pattern.UNICODE_CHARACTER_CLASS).matcher(&quot;&quot;);
4368         Matcher bwbEU  = Pattern.compile(&quot;(?U)\\b\\w++\\b&quot;, Pattern.UNICODE_CHARACTER_CLASS).matcher(&quot;&quot;);
4369         // properties
4370         Matcher lowerP  = Pattern.compile(&quot;\\p{IsLowerCase}&quot;).matcher(&quot;&quot;);
4371         Matcher upperP  = Pattern.compile(&quot;\\p{IsUpperCase}&quot;).matcher(&quot;&quot;);
4372         Matcher titleP  = Pattern.compile(&quot;\\p{IsTitleCase}&quot;).matcher(&quot;&quot;);
4373         Matcher letterP = Pattern.compile(&quot;\\p{IsLetter}&quot;).matcher(&quot;&quot;);
4374         Matcher alphaP  = Pattern.compile(&quot;\\p{IsAlphabetic}&quot;).matcher(&quot;&quot;);
4375         Matcher ideogP  = Pattern.compile(&quot;\\p{IsIdeographic}&quot;).matcher(&quot;&quot;);
4376         Matcher cntrlP  = Pattern.compile(&quot;\\p{IsControl}&quot;).matcher(&quot;&quot;);
4377         Matcher spaceP  = Pattern.compile(&quot;\\p{IsWhiteSpace}&quot;).matcher(&quot;&quot;);
4378         Matcher definedP = Pattern.compile(&quot;\\p{IsAssigned}&quot;).matcher(&quot;&quot;);
4379         Matcher nonCCPP = Pattern.compile(&quot;\\p{IsNoncharacterCodePoint}&quot;).matcher(&quot;&quot;);
4380         Matcher joinCrtl = Pattern.compile(&quot;\\p{IsJoinControl}&quot;).matcher(&quot;&quot;);
4381         // javaMethod
4382         Matcher lowerJ  = Pattern.compile(&quot;\\p{javaLowerCase}&quot;).matcher(&quot;&quot;);
4383         Matcher upperJ  = Pattern.compile(&quot;\\p{javaUpperCase}&quot;).matcher(&quot;&quot;);
4384         Matcher alphaJ  = Pattern.compile(&quot;\\p{javaAlphabetic}&quot;).matcher(&quot;&quot;);
4385         Matcher ideogJ  = Pattern.compile(&quot;\\p{javaIdeographic}&quot;).matcher(&quot;&quot;);
4386         // GC/C
4387         Matcher gcC  = Pattern.compile(&quot;\\p{C}&quot;).matcher(&quot;&quot;);
4388 
4389         for (int cp = 1; cp &lt; 0x30000; cp++) {
4390             String str = new String(Character.toChars(cp));
4391             int type = Character.getType(cp);
4392             if (// lower
4393                 POSIX_ASCII.isLower(cp)   != lower.reset(str).matches()  ||
4394                 Character.isLowerCase(cp) != lowerU.reset(str).matches() ||
4395                 Character.isLowerCase(cp) != lowerP.reset(str).matches() ||
4396                 Character.isLowerCase(cp) != lowerEU.reset(str).matches()||
4397                 Character.isLowerCase(cp) != lowerJ.reset(str).matches()||
4398                 // upper
4399                 POSIX_ASCII.isUpper(cp)   != upper.reset(str).matches()  ||
4400                 POSIX_Unicode.isUpper(cp) != upperU.reset(str).matches() ||
4401                 Character.isUpperCase(cp) != upperP.reset(str).matches() ||
4402                 Character.isUpperCase(cp) != upperJ.reset(str).matches() ||
4403                 // alpha
4404                 POSIX_ASCII.isAlpha(cp)   != alpha.reset(str).matches()  ||
4405                 POSIX_Unicode.isAlpha(cp) != alphaU.reset(str).matches() ||
4406                 Character.isAlphabetic(cp)!= alphaP.reset(str).matches() ||
4407                 Character.isAlphabetic(cp)!= alphaJ.reset(str).matches() ||
4408                 // digit
4409                 POSIX_ASCII.isDigit(cp)   != digit.reset(str).matches()  ||
4410                 Character.isDigit(cp)     != digitU.reset(str).matches() ||
4411                 // alnum
4412                 POSIX_ASCII.isAlnum(cp)   != alnum.reset(str).matches()  ||
4413                 POSIX_Unicode.isAlnum(cp) != alnumU.reset(str).matches() ||
4414                 // punct
4415                 POSIX_ASCII.isPunct(cp)   != punct.reset(str).matches()  ||
4416                 POSIX_Unicode.isPunct(cp) != punctU.reset(str).matches() ||
4417                 // graph
4418                 POSIX_ASCII.isGraph(cp)   != graph.reset(str).matches()  ||
4419                 POSIX_Unicode.isGraph(cp) != graphU.reset(str).matches() ||
4420                 POSIX_Unicode.isGraph(cp) != graphEU.reset(str).matches()||
4421                 // blank
4422                 POSIX_ASCII.isType(cp, POSIX_ASCII.BLANK)
4423                                           != blank.reset(str).matches()  ||
4424                 POSIX_Unicode.isBlank(cp) != blankU.reset(str).matches() ||
4425                 // print
4426                 POSIX_ASCII.isPrint(cp)   != print.reset(str).matches()  ||
4427                 POSIX_Unicode.isPrint(cp) != printU.reset(str).matches() ||
4428                 // cntrl
4429                 POSIX_ASCII.isCntrl(cp)   != cntrl.reset(str).matches()  ||
4430                 POSIX_Unicode.isCntrl(cp) != cntrlU.reset(str).matches() ||
4431                 (Character.CONTROL == type) != cntrlP.reset(str).matches() ||
4432                 // hexdigit
4433                 POSIX_ASCII.isHexDigit(cp)   != xdigit.reset(str).matches()  ||
4434                 POSIX_Unicode.isHexDigit(cp) != xdigitU.reset(str).matches() ||
4435                 // space
4436                 POSIX_ASCII.isSpace(cp)   != space.reset(str).matches()  ||
4437                 POSIX_Unicode.isSpace(cp) != spaceU.reset(str).matches() ||
4438                 POSIX_Unicode.isSpace(cp) != spaceP.reset(str).matches() ||
4439                 // word
4440                 POSIX_ASCII.isWord(cp)   != word.reset(str).matches()  ||
4441                 POSIX_Unicode.isWord(cp) != wordU.reset(str).matches() ||
4442                 POSIX_Unicode.isWord(cp) != wordEU.reset(str).matches()||
4443                 // bwordb
4444                 POSIX_ASCII.isWord(cp) != bwb.reset(str).matches() ||
4445                 POSIX_Unicode.isWord(cp) != bwbU.reset(str).matches() ||
4446                 // properties
4447                 Character.isTitleCase(cp) != titleP.reset(str).matches() ||
4448                 Character.isLetter(cp)    != letterP.reset(str).matches()||
4449                 Character.isIdeographic(cp) != ideogP.reset(str).matches() ||
4450                 Character.isIdeographic(cp) != ideogJ.reset(str).matches() ||
4451                 (Character.UNASSIGNED == type) == definedP.reset(str).matches() ||
4452                 POSIX_Unicode.isNoncharacterCodePoint(cp) != nonCCPP.reset(str).matches() ||
4453                 POSIX_Unicode.isJoinControl(cp) != joinCrtl.reset(str).matches() ||
4454                 // gc_C
4455                 (Character.CONTROL == type || Character.FORMAT == type ||
4456                  Character.PRIVATE_USE == type || Character.SURROGATE == type ||
4457                  Character.UNASSIGNED == type)
4458                 != gcC.reset(str).matches()) {
4459                 failCount++;
4460             }
4461         }
4462 
4463         // bounds/word align
4464         twoFindIndexes(&quot; \u0180sherman\u0400 &quot;, bound, 1, 10);
4465         if (!bwbU.reset(&quot;\u0180sherman\u0400&quot;).matches())
4466             failCount++;
4467         twoFindIndexes(&quot; \u0180sh\u0345erman\u0400 &quot;, bound, 1, 11);
4468         if (!bwbU.reset(&quot;\u0180sh\u0345erman\u0400&quot;).matches())
4469             failCount++;
4470         twoFindIndexes(&quot; \u0724\u0739\u0724 &quot;, bound, 1, 4);
4471         if (!bwbU.reset(&quot;\u0724\u0739\u0724&quot;).matches())
4472             failCount++;
4473         if (!bwbEU.reset(&quot;\u0724\u0739\u0724&quot;).matches())
4474             failCount++;
4475         report(&quot;unicodePredefinedClasses&quot;);
4476     }
4477 
4478     private static void unicodeCharacterNameTest() throws Exception {
4479 
4480         for (int cp = 0; cp &lt; Character.MAX_CODE_POINT; cp++) {
4481             if (!Character.isValidCodePoint(cp) ||
4482                 Character.getType(cp) == Character.UNASSIGNED)
4483                 continue;
4484             String str = new String(Character.toChars(cp));
4485             // single
4486             String p = &quot;\\N{&quot; + Character.getName(cp) + &quot;}&quot;;
4487             if (!Pattern.compile(p).matcher(str).matches()) {
4488                 failCount++;
4489             }
4490             // class[c]
4491             p = &quot;[\\N{&quot; + Character.getName(cp) + &quot;}]&quot;;
4492             if (!Pattern.compile(p).matcher(str).matches()) {
4493                 failCount++;
4494             }
4495         }
4496 
4497         // range
4498         for (int i = 0; i &lt; 10; i++) {
4499             int start = generator.nextInt(20);
4500             int end = start + generator.nextInt(200);
4501             String p = &quot;[\\N{&quot; + Character.getName(start) + &quot;}-\\N{&quot; + Character.getName(end) + &quot;}]&quot;;
4502             String str;
4503             for (int cp = start; cp &lt; end; cp++) {
4504                 str = new String(Character.toChars(cp));
4505                 if (!Pattern.compile(p).matcher(str).matches()) {
4506                     failCount++;
4507                 }
4508             }
4509             str = new String(Character.toChars(end + 10));
4510             if (Pattern.compile(p).matcher(str).matches()) {
4511                 failCount++;
4512             }
4513         }
4514 
4515         // slice
4516         for (int i = 0; i &lt; 10; i++) {
4517             int n = generator.nextInt(256);
4518             int[] buf = new int[n];
4519             StringBuffer sb = new StringBuffer(1024);
4520             for (int j = 0; j &lt; n; j++) {
4521                 int cp = generator.nextInt(1000);
4522                 if (!Character.isValidCodePoint(cp) ||
4523                     Character.getType(cp) == Character.UNASSIGNED)
4524                     cp = 0x4e00;    // just use 4e00
4525                 sb.append(&quot;\\N{&quot; + Character.getName(cp) + &quot;}&quot;);
4526                 buf[j] = cp;
4527             }
4528             String p = sb.toString();
4529             String str = new String(buf, 0, buf.length);
4530             if (!Pattern.compile(p).matcher(str).matches()) {
4531                 failCount++;
4532             }
4533         }
4534         report(&quot;unicodeCharacterName&quot;);
4535     }
4536 
4537     private static void horizontalAndVerticalWSTest() throws Exception {
4538         String hws = new String (new char[] {
4539                                      0x09, 0x20, 0xa0, 0x1680, 0x180e,
4540                                      0x2000, 0x2001, 0x2002, 0x2003, 0x2004, 0x2005,
4541                                      0x2006, 0x2007, 0x2008, 0x2009, 0x200a,
4542                                      0x202f, 0x205f, 0x3000 });
4543         String vws = new String (new char[] {
4544                                      0x0a, 0x0b, 0x0c, 0x0d, 0x85, 0x2028, 0x2029 });
4545         if (!Pattern.compile(&quot;\\h+&quot;).matcher(hws).matches() ||
4546             !Pattern.compile(&quot;[\\h]+&quot;).matcher(hws).matches())
4547             failCount++;
4548         if (Pattern.compile(&quot;\\H&quot;).matcher(hws).find() ||
4549             Pattern.compile(&quot;[\\H]&quot;).matcher(hws).find())
4550             failCount++;
4551         if (!Pattern.compile(&quot;\\v+&quot;).matcher(vws).matches() ||
4552             !Pattern.compile(&quot;[\\v]+&quot;).matcher(vws).matches())
4553             failCount++;
4554         if (Pattern.compile(&quot;\\V&quot;).matcher(vws).find() ||
4555             Pattern.compile(&quot;[\\V]&quot;).matcher(vws).find())
4556             failCount++;
4557         String prefix = &quot;abcd&quot;;
4558         String suffix = &quot;efgh&quot;;
4559         String ng = &quot;A&quot;;
4560         for (int i = 0; i &lt; hws.length(); i++) {
4561             String c = String.valueOf(hws.charAt(i));
4562             Matcher m = Pattern.compile(&quot;\\h&quot;).matcher(prefix + c + suffix);
4563             if (!m.find() || !c.equals(m.group()))
4564                 failCount++;
4565             m = Pattern.compile(&quot;[\\h]&quot;).matcher(prefix + c + suffix);
4566             if (!m.find() || !c.equals(m.group()))
4567                 failCount++;
4568 
4569             m = Pattern.compile(&quot;\\H&quot;).matcher(hws.substring(0, i) + ng + hws.substring(i));
4570             if (!m.find() || !ng.equals(m.group()))
4571                 failCount++;
4572             m = Pattern.compile(&quot;[\\H]&quot;).matcher(hws.substring(0, i) + ng + hws.substring(i));
4573             if (!m.find() || !ng.equals(m.group()))
4574                 failCount++;
4575         }
4576         for (int i = 0; i &lt; vws.length(); i++) {
4577             String c = String.valueOf(vws.charAt(i));
4578             Matcher m = Pattern.compile(&quot;\\v&quot;).matcher(prefix + c + suffix);
4579             if (!m.find() || !c.equals(m.group()))
4580                 failCount++;
4581             m = Pattern.compile(&quot;[\\v]&quot;).matcher(prefix + c + suffix);
4582             if (!m.find() || !c.equals(m.group()))
4583                 failCount++;
4584 
4585             m = Pattern.compile(&quot;\\V&quot;).matcher(vws.substring(0, i) + ng + vws.substring(i));
4586             if (!m.find() || !ng.equals(m.group()))
4587                 failCount++;
4588             m = Pattern.compile(&quot;[\\V]&quot;).matcher(vws.substring(0, i) + ng + vws.substring(i));
4589             if (!m.find() || !ng.equals(m.group()))
4590                 failCount++;
4591         }
4592         // \v in range is interpreted as 0x0B. This is the undocumented behavior
4593         if (!Pattern.compile(&quot;[\\v-\\v]&quot;).matcher(String.valueOf((char)0x0B)).matches())
4594             failCount++;
4595         report(&quot;horizontalAndVerticalWSTest&quot;);
4596     }
4597 
4598     private static void linebreakTest() throws Exception {
4599         String linebreaks = new String (new char[] {
4600             0x0A, 0x0B, 0x0C, 0x0D, 0x85, 0x2028, 0x2029 });
4601         String crnl = &quot;\r\n&quot;;
4602         if (!(Pattern.compile(&quot;\\R+&quot;).matcher(linebreaks).matches() &amp;&amp;
4603               Pattern.compile(&quot;\\R&quot;).matcher(crnl).matches() &amp;&amp;
4604               Pattern.compile(&quot;\\Rabc&quot;).matcher(crnl + &quot;abc&quot;).matches() &amp;&amp;
4605               Pattern.compile(&quot;\\Rabc&quot;).matcher(&quot;\rabc&quot;).matches() &amp;&amp;
4606               Pattern.compile(&quot;\\R\\R&quot;).matcher(crnl).matches() &amp;&amp;  // backtracking
4607               Pattern.compile(&quot;\\R\\n&quot;).matcher(crnl).matches()) &amp;&amp; // backtracking
4608               !Pattern.compile(&quot;((?&lt;!\\R)\\s)*&quot;).matcher(crnl).matches()) { // #8176029
4609             failCount++;
4610         }
4611         report(&quot;linebreakTest&quot;);
4612     }
4613 
4614     // #7189363
4615     private static void branchTest() throws Exception {
4616         if (!Pattern.compile(&quot;(a)?bc|d&quot;).matcher(&quot;d&quot;).find() ||     // greedy
4617             !Pattern.compile(&quot;(a)+bc|d&quot;).matcher(&quot;d&quot;).find() ||
4618             !Pattern.compile(&quot;(a)*bc|d&quot;).matcher(&quot;d&quot;).find() ||
4619             !Pattern.compile(&quot;(a)??bc|d&quot;).matcher(&quot;d&quot;).find() ||    // reluctant
4620             !Pattern.compile(&quot;(a)+?bc|d&quot;).matcher(&quot;d&quot;).find() ||
4621             !Pattern.compile(&quot;(a)*?bc|d&quot;).matcher(&quot;d&quot;).find() ||
4622             !Pattern.compile(&quot;(a)?+bc|d&quot;).matcher(&quot;d&quot;).find() ||    // possessive
4623             !Pattern.compile(&quot;(a)++bc|d&quot;).matcher(&quot;d&quot;).find() ||
4624             !Pattern.compile(&quot;(a)*+bc|d&quot;).matcher(&quot;d&quot;).find() ||
4625             !Pattern.compile(&quot;(a)?bc|d&quot;).matcher(&quot;d&quot;).matches() ||  // greedy
4626             !Pattern.compile(&quot;(a)+bc|d&quot;).matcher(&quot;d&quot;).matches() ||
4627             !Pattern.compile(&quot;(a)*bc|d&quot;).matcher(&quot;d&quot;).matches() ||
4628             !Pattern.compile(&quot;(a)??bc|d&quot;).matcher(&quot;d&quot;).matches() || // reluctant
4629             !Pattern.compile(&quot;(a)+?bc|d&quot;).matcher(&quot;d&quot;).matches() ||
4630             !Pattern.compile(&quot;(a)*?bc|d&quot;).matcher(&quot;d&quot;).matches() ||
4631             !Pattern.compile(&quot;(a)?+bc|d&quot;).matcher(&quot;d&quot;).matches() || // possessive
4632             !Pattern.compile(&quot;(a)++bc|d&quot;).matcher(&quot;d&quot;).matches() ||
4633             !Pattern.compile(&quot;(a)*+bc|d&quot;).matcher(&quot;d&quot;).matches() ||
4634             !Pattern.compile(&quot;(a)?bc|de&quot;).matcher(&quot;de&quot;).find() ||   // others
4635             !Pattern.compile(&quot;(a)??bc|de&quot;).matcher(&quot;de&quot;).find() ||
4636             !Pattern.compile(&quot;(a)?bc|de&quot;).matcher(&quot;de&quot;).matches() ||
4637             !Pattern.compile(&quot;(a)??bc|de&quot;).matcher(&quot;de&quot;).matches())
4638             failCount++;
4639         report(&quot;branchTest&quot;);
4640     }
4641 
4642     // This test is for 8007395
4643     private static void groupCurlyNotFoundSuppTest() throws Exception {
4644         String input = &quot;test this as \ud83d\ude0d&quot;;
4645         for (String pStr : new String[] { &quot;test(.)+(@[a-zA-Z.]+)&quot;,
4646                                           &quot;test(.)*(@[a-zA-Z.]+)&quot;,
4647                                           &quot;test([^B])+(@[a-zA-Z.]+)&quot;,
4648                                           &quot;test([^B])*(@[a-zA-Z.]+)&quot;,
4649                                           &quot;test(\\P{IsControl})+(@[a-zA-Z.]+)&quot;,
4650                                           &quot;test(\\P{IsControl})*(@[a-zA-Z.]+)&quot;,
4651                                         }) {
4652             Matcher m = Pattern.compile(pStr, Pattern.CASE_INSENSITIVE)
4653                                .matcher(input);
4654             try {
4655                 if (m.find()) {
4656                     failCount++;
4657                 }
4658             } catch (Exception x) {
4659                 failCount++;
4660             }
4661         }
4662         report(&quot;GroupCurly NotFoundSupp&quot;);
4663     }
4664 
4665     // This test is for 8023647
4666     private static void groupCurlyBackoffTest() throws Exception {
4667         if (!&quot;abc1c&quot;.matches(&quot;(\\w)+1\\1&quot;) ||
4668             &quot;abc11&quot;.matches(&quot;(\\w)+1\\1&quot;)) {
4669             failCount++;
4670         }
4671         report(&quot;GroupCurly backoff&quot;);
4672     }
4673 
4674     // This test is for 8012646
4675     private static void patternAsPredicate() throws Exception {
4676         Predicate&lt;String&gt; p = Pattern.compile(&quot;[a-z]+&quot;).asPredicate();
4677 
4678         if (p.test(&quot;&quot;)) {
4679             failCount++;
4680         }
4681         if (!p.test(&quot;word&quot;)) {
4682             failCount++;
4683         }
4684         if (p.test(&quot;1234&quot;)) {
4685             failCount++;
4686         }
4687         if (!p.test(&quot;word1234&quot;)) {
4688             failCount++;
4689         }
4690         report(&quot;Pattern.asPredicate&quot;);
4691     }
4692 
4693     // This test is for 8184692
4694     private static void patternAsMatchPredicate() throws Exception {
4695         Predicate&lt;String&gt; p = Pattern.compile(&quot;[a-z]+&quot;).asMatchPredicate();
4696 
4697         if (p.test(&quot;&quot;)) {
4698             failCount++;
4699         }
4700         if (!p.test(&quot;word&quot;)) {
4701             failCount++;
4702         }
4703         if (p.test(&quot;1234word&quot;)) {
4704             failCount++;
4705         }
4706         if (p.test(&quot;1234&quot;)) {
4707             failCount++;
4708         }
4709         report(&quot;Pattern.asMatchPredicate&quot;);
4710     }
4711 
4712 
4713     // This test is for 8035975
4714     private static void invalidFlags() throws Exception {
4715         for (int flag = 1; flag != 0; flag &lt;&lt;= 1) {
4716             switch (flag) {
4717             case Pattern.CASE_INSENSITIVE:
4718             case Pattern.MULTILINE:
4719             case Pattern.DOTALL:
4720             case Pattern.UNICODE_CASE:
4721             case Pattern.CANON_EQ:
4722             case Pattern.UNIX_LINES:
4723             case Pattern.LITERAL:
4724             case Pattern.UNICODE_CHARACTER_CLASS:
4725             case Pattern.COMMENTS:
4726                 // valid flag, continue
4727                 break;
4728             default:
4729                 try {
4730                     Pattern.compile(&quot;.&quot;, flag);
4731                     failCount++;
4732                 } catch (IllegalArgumentException expected) {
4733                 }
4734             }
4735         }
4736         report(&quot;Invalid compile flags&quot;);
4737     }
4738 
4739     // This test is for 8158482
4740     private static void embeddedFlags() throws Exception {
4741         try {
4742             Pattern.compile(&quot;(?i).(?-i).&quot;);
4743             Pattern.compile(&quot;(?m).(?-m).&quot;);
4744             Pattern.compile(&quot;(?s).(?-s).&quot;);
4745             Pattern.compile(&quot;(?d).(?-d).&quot;);
4746             Pattern.compile(&quot;(?u).(?-u).&quot;);
4747             Pattern.compile(&quot;(?c).(?-c).&quot;);
4748             Pattern.compile(&quot;(?x).(?-x).&quot;);
4749             Pattern.compile(&quot;(?U).(?-U).&quot;);
4750             Pattern.compile(&quot;(?imsducxU).(?-imsducxU).&quot;);
4751         } catch (PatternSyntaxException x) {
4752             failCount++;
4753         }
4754         report(&quot;Embedded flags&quot;);
4755     }
4756 
4757     private static void grapheme() throws Exception {
<a name="9" id="anc9"></a><span class="line-modified">4758         Files.lines(Paths.get(System.getProperty(&quot;test.src&quot;, &quot;.&quot;),</span>
<span class="line-removed">4759                               &quot;GraphemeBreakTest.txt&quot;))</span>
4760             .filter( ln -&gt; ln.length() != 0 &amp;&amp; !ln.startsWith(&quot;#&quot;) )
4761             .forEach( ln -&gt; {
4762                     ln = ln.replaceAll(&quot;\\s+|\\([a-zA-Z]+\\)|\\[[a-zA-Z]]+\\]|#.*&quot;, &quot;&quot;);
4763                     // System.out.println(str);
4764                     String[] strs = ln.split(&quot;\u00f7|\u00d7&quot;);
4765                     StringBuilder src = new StringBuilder();
4766                     ArrayList&lt;String&gt; graphemes = new ArrayList&lt;&gt;();
4767                     StringBuilder buf = new StringBuilder();
4768                     int offBk = 0;
4769                     for (String str : strs) {
4770                         if (str.length() == 0)  // first empty str
4771                             continue;
4772                         int cp = Integer.parseInt(str, 16);
4773                         src.appendCodePoint(cp);
4774                         buf.appendCodePoint(cp);
4775                         offBk += (str.length() + 1);
4776                         if (ln.charAt(offBk) == &#39;\u00f7&#39;) {    // DIV
4777                             graphemes.add(buf.toString());
4778                             buf = new StringBuilder();
4779                         }
4780                     }
4781                     Pattern p = Pattern.compile(&quot;\\X&quot;);
4782                     Matcher m = p.matcher(src.toString());
4783                     Scanner s = new Scanner(src.toString()).useDelimiter(&quot;\\b{g}&quot;);
4784                     for (String g : graphemes) {
4785                         // System.out.printf(&quot;     grapheme:=[%s]%n&quot;, g);
4786                         // (1) test \\X directly
4787                         if (!m.find() || !m.group().equals(g)) {
4788                             System.out.println(&quot;Failed \\X [&quot; + ln + &quot;] : &quot; + g);
4789                             failCount++;
4790                         }
4791                         // (2) test \\b{g} + \\X  via Scanner
4792                         boolean hasNext = s.hasNext(p);
4793                         // if (!s.hasNext() || !s.next().equals(next)) {
4794                         if (!s.hasNext(p) || !s.next(p).equals(g)) {
4795                             System.out.println(&quot;Failed b{g} [&quot; + ln + &quot;] : &quot; + g);
4796                             failCount++;
4797                         }
4798                     }
4799                 });
4800         // some sanity checks
4801         if (!Pattern.compile(&quot;\\X{10}&quot;).matcher(&quot;abcdefghij&quot;).matches() ||
4802             !Pattern.compile(&quot;\\b{g}(?:\\X\\b{g}){5}\\b{g}&quot;).matcher(&quot;abcde&quot;).matches() ||
4803             !Pattern.compile(&quot;(?:\\X\\b{g}){2}&quot;).matcher(&quot;\ud800\udc00\ud801\udc02&quot;).matches())
4804             failCount++;
4805         // make sure &quot;\b{n}&quot; still works
4806         if (!Pattern.compile(&quot;\\b{1}hello\\b{1} \\b{1}world\\b{1}&quot;).matcher(&quot;hello world&quot;).matches())
4807             failCount++;
4808         report(&quot;Unicode extended grapheme cluster&quot;);
4809     }
4810 
4811     // hangup/timeout if go into exponential backtracking
4812     private static void expoBacktracking() throws Exception {
4813 
4814         Object[][] patternMatchers = {
4815             // 6328855
4816             { &quot;(.*\n*)*&quot;,
4817               &quot;this little fine string lets\r\njava.lang.String.matches\r\ncrash\r\n(We don&#39;t know why but adding \r* to the regex makes it work again)&quot;,
4818               false },
4819             // 6192895
4820             { &quot; *([a-zA-Z0-9/\\-\\?:\\(\\)\\.,&#39;\\+\\{\\}]+ *)+&quot;,
4821               &quot;Hello World this is a test this is a test this is a test A&quot;,
4822               true },
4823             { &quot; *([a-zA-Z0-9/\\-\\?:\\(\\)\\.,&#39;\\+\\{\\}]+ *)+&quot;,
4824               &quot;Hello World this is a test this is a test this is a test \u4e00 &quot;,
4825               false },
4826             { &quot; *([a-z0-9]+ *)+&quot;,
4827               &quot;hello world this is a test this is a test this is a test A&quot;,
4828               false },
4829             // 4771934 [FIXED] #5013651?
4830             { &quot;^(\\w+([\\.-]?\\w+)*@\\w+([\\.-]?\\w+)*(\\.\\w{2,4})+[,;]?)+$&quot;,
4831               &quot;abc@efg.abc,efg@abc.abc,abc@xyz.mno;abc@sdfsd.com&quot;,
4832               true },
4833             // 4866249 [FIXED]
4834             { &quot;&lt;\\s*&quot; + &quot;(meta|META)&quot; + &quot;(\\s|[^&gt;])+&quot; + &quot;(CHARSET|charset)=&quot; + &quot;(\\s|[^&gt;])+&gt;&quot;,
4835               &quot;&lt;META http-equiv=\&quot;Content-Type\&quot; content=\&quot;text/html; charset=ISO-8859-5\&quot;&gt;&quot;,
4836               true },
4837             { &quot;^(\\w+([\\.-]?\\w+)*@\\w+([\\.-]?\\w+)*(\\.\\w{2,4})+[,;]?)+$&quot;,
4838               &quot;abc@efg.abc,efg@abc.abc,abc@xyz.mno;sdfsd.com&quot;,
4839               false },
4840             // 6345469
4841             { &quot;((&lt;[^&gt;]+&gt;)?(((\\s)?)*(\\&amp;nbsp;)?)*((\\s)?)*)+&quot;,
4842               &quot;&amp;nbsp;&amp;nbsp; &lt; br/&gt; &amp;nbsp; &lt; / p&gt; &lt;p&gt; &lt;html&gt; &lt;adfasfdasdf&gt;&amp;nbsp; &lt;/p&gt;&quot;,
4843               true }, // --&gt; matched
4844             { &quot;((&lt;[^&gt;]+&gt;)?(((\\s)?)*(\\&amp;nbsp;)?)*((\\s)?)*)+&quot;,
4845               &quot;&amp;nbsp;&amp;nbsp; &lt; br/&gt; &amp;nbsp; &lt; / p&gt; &lt;p&gt; &lt;html&gt; &lt;adfasfdasdf&gt;&amp;nbsp; p &lt;/p&gt;&quot;,
4846               false },
4847             // 5026912
4848             { &quot;^\\s*&quot; + &quot;(\\w|\\d|[\\xC0-\\xFF]|/)+&quot; + &quot;\\s+|$&quot;,
4849               &quot;156580451111112225588087755221111111566969655555555&quot;,
4850               false},
4851             // 6988218
4852             { &quot;^([+-]?((0[xX](\\p{XDigit}+))|(((\\p{Digit}+)(\\.)?((\\p{Digit}+)?)([eE][+-]?(\\p{Digit}+))?)|(\\.((\\p{Digit}+))([eE][+-]?(\\p{Digit}+))?)))|[n|N]?&#39;([^&#39;]*(?:&#39;&#39;)*[^&#39;]*)*&#39;)&quot;,
4853               &quot;&#39;%)) order by ANGEBOT.ID&quot;,
4854               false},    // find
4855             // 6693451
4856             { &quot;^(\\s*foo\\s*)*$&quot;,
4857               &quot;foo foo foo foo foo foo foo foo foo foo foo foo foo foo foo foo foo foo foo foo foo foo foo foo foo foo foo foo foo foo foo foo foo foo foo foo foo foo foo foo&quot;,
4858               true },
4859             { &quot;^(\\s*foo\\s*)*$&quot;,
4860               &quot;foo foo foo foo foo foo foo foo foo foo foo foo foo foo foo foo foo foo foo foo foo foo foo foo foo foo foo foo foo foo foo foo foo foo foo foo foo foo foo fo&quot;,
4861               false
4862             },
4863             // 7006761
4864             { &quot;(([0-9A-Z]+)([_]?+)*)*&quot;, &quot;FOOOOO_BAAAR_FOOOOOOOOO_BA_&quot;, true},
4865             { &quot;(([0-9A-Z]+)([_]?+)*)*&quot;, &quot;FOOOOO_BAAAR_FOOOOOOOOO_BA_ &quot;, false},
4866             // 8140212
4867             { &quot;(?&lt;before&gt;.*)\\{(?&lt;reflection&gt;\\w+):(?&lt;innerMethod&gt;\\w+(\\.?\\w+(\\(((?&lt;args&gt;((&#39;[^&#39;]*&#39;)|((/|\\w)+))(,((&#39;[^&#39;]*&#39;)|((/|\\w)+)))*))?\\))?)*)\\}(?&lt;after&gt;.*)&quot;,
4868               &quot;{CeGlobal:getSodCutoff.getGui.getAmqp.getSimpleModeEnabled()&quot;,
4869               false
4870             },
4871             { &quot;^(a+)+$&quot;, &quot;aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa&quot;, true},
4872             { &quot;^(a+)+$&quot;, &quot;aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa!&quot;, false},
4873 
4874             { &quot;(x+)*y&quot;,  &quot;xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxy&quot;, true },
4875             { &quot;(x+)*y&quot;,  &quot;xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxz&quot;, false},
4876 
4877             { &quot;(x+x+)+y&quot;, &quot;xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxy&quot;, true},
4878             { &quot;(x+x+)+y&quot;, &quot;xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxz&quot;, false},
4879 
4880             { &quot;(([0-9A-Z]+)([_]?+)*)*&quot;, &quot;--------------------------------------&quot;, false},
4881 
4882             /* not fixed
4883             //8132141   ---&gt;    second level exponential backtracking
4884             { &quot;(h|h|ih(((i|a|c|c|a|i|i|j|b|a|i|b|a|a|j))+h)ahbfhba|c|i)*&quot;,
4885               &quot;hchcchicihcchciiicichhcichcihcchiihichiciiiihhcchicchhcihchcihiihciichhccciccichcichiihcchcihhicchcciicchcccihiiihhihihihichicihhcciccchihhhcchichchciihiicihciihcccciciccicciiiiiiiiicihhhiiiihchccchchhhhiiihchihcccchhhiiiiiiiicicichicihcciciihichhhhchihciiihhiccccccciciihhichiccchhicchicihihccichicciihcichccihhiciccccccccichhhhihihhcchchihihiihhihihihicichihiiiihhhhihhhchhichiicihhiiiiihchccccchichci&quot; },
4886             */
4887         };
4888 
4889         for (Object[] pm : patternMatchers) {
4890             String p = (String)pm[0];
4891             String s = (String)pm[1];
4892             boolean r = (Boolean)pm[2];
4893             if (r != Pattern.compile(p).matcher(s).matches()) {
4894                 failCount++;
4895             }
4896         }
4897     }
4898 
4899     private static void invalidGroupName() {
4900         // Invalid start of a group name
4901         for (String groupName : List.of(&quot;&quot;, &quot;.&quot;, &quot;0&quot;, &quot;\u0040&quot;, &quot;\u005b&quot;,
4902                 &quot;\u0060&quot;, &quot;\u007b&quot;, &quot;\u0416&quot;)) {
4903             for (String pat : List.of(&quot;(?&lt;&quot; + groupName + &quot;&gt;)&quot;,
4904                     &quot;\\k&lt;&quot; + groupName + &quot;&gt;&quot;)) {
4905                 try {
4906                     Pattern.compile(pat);
4907                     failCount++;
4908                 } catch (PatternSyntaxException e) {
4909                     if (!e.getMessage().startsWith(
4910                             &quot;capturing group name does not start with a&quot;
4911                             + &quot; Latin letter&quot;)) {
4912                         failCount++;
4913                     }
4914                 }
4915             }
4916         }
4917         // Invalid char in a group name
4918         for (String groupName : List.of(&quot;a.&quot;, &quot;b\u0040&quot;, &quot;c\u005b&quot;,
4919                 &quot;d\u0060&quot;, &quot;e\u007b&quot;, &quot;f\u0416&quot;)) {
4920             for (String pat : List.of(&quot;(?&lt;&quot; + groupName + &quot;&gt;)&quot;,
4921                     &quot;\\k&lt;&quot; + groupName + &quot;&gt;&quot;)) {
4922                 try {
4923                     Pattern.compile(pat);
4924                     failCount++;
4925                 } catch (PatternSyntaxException e) {
4926                     if (!e.getMessage().startsWith(
4927                             &quot;named capturing group is missing trailing &#39;&gt;&#39;&quot;)) {
4928                         failCount++;
4929                     }
4930                 }
4931             }
4932         }
4933         report(&quot;Invalid capturing group names&quot;);
4934     }
<a name="10" id="anc10"></a>

















































































































4935 }
<a name="11" id="anc11"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="11" type="hidden" />
</body>
</html>
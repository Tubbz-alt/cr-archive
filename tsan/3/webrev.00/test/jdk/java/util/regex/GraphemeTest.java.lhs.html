<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames test/jdk/java/util/regex/GraphemeTest.java</title>
    <link rel="stylesheet" href="../../../../../style.css" />
    <script type="text/javascript" src="../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
<a name="1" id="anc1"></a><span class="line-modified">  2  * Copyright (c) 2016, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 /*
 25  * @test
<a name="2" id="anc2"></a><span class="line-modified"> 26  * @bug 7071819</span>
 27  * @summary tests Unicode Extended Grapheme support
<a name="3" id="anc3"></a>
 28  * @run main GraphemeTest
 29  */
 30 
 31 import java.io.IOException;
 32 import java.nio.file.Files;
 33 import java.nio.file.Path;
 34 import java.nio.file.Paths;
 35 import java.util.Arrays;
 36 import java.util.ArrayList;
 37 import java.util.Scanner;
 38 import java.util.regex.Pattern;
 39 import java.util.regex.Matcher;
 40 
 41 public class GraphemeTest {
 42 
 43     public static void main(String[] args) throws Throwable {
<a name="4" id="anc4"></a><span class="line-modified"> 44         testProps(Paths.get(System.getProperty(&quot;test.src&quot;, &quot;.&quot;),</span>
<span class="line-modified"> 45                             &quot;GraphemeBreakProperty.txt&quot;));</span>
<span class="line-removed"> 46         testBreak(Paths.get(System.getProperty(&quot;test.src&quot;, &quot;.&quot;),</span>
<span class="line-removed"> 47                             &quot;GraphemeBreakTest.txt&quot;));</span>
 48     }
 49 
 50     private static void testProps(Path path) throws IOException {
 51         Files.lines(path)
<a name="5" id="anc5"></a><span class="line-modified"> 52             .filter( ln -&gt; ln.length() != 0 &amp;&amp; !ln.startsWith(&quot;#&quot;) )</span>

 53             .forEach(ln -&gt; {
 54                     String[] strs = ln.split(&quot;\\s+&quot;);
 55                     int off = strs[0].indexOf(&quot;..&quot;);
 56                     int cp0, cp1;
 57                     String expected = strs[2];
 58                     if (off != -1) {
 59                         cp0 = Integer.parseInt(strs[0], 0, off, 16);
 60                         cp1 = Integer.parseInt(strs[0], off + 2, strs[0].length(), 16);
 61                     } else {
 62                         cp0 = cp1 = Integer.parseInt(strs[0], 16);
 63                     }
 64                     for (int cp = cp0; cp &lt;=  cp1; cp++) {
<a name="6" id="anc6"></a>




 65                         // NOTE:
 66                         // #tr29 &quot;plus a few General_Category = Spacing_Mark needed for
 67                         // canonical equivalence.&quot;
 68                         // For &quot;extended grapheme clusters&quot; support, there is no
 69                         // need actually to diff &quot;extend&quot; and &quot;spackmark&quot; given GB9, GB9a.
 70                         if (!expected.equals(types[getType(cp)])) {
 71                             if (&quot;Extend&quot;.equals(expected) &amp;&amp;
 72                                 &quot;SpacingMark&quot;.equals(types[getType(cp)]))
 73                                 System.out.printf(&quot;[%x]  [%s][%d] -&gt; [%s]%n&quot;,
 74                                     cp, expected, Character.getType(cp), types[getType(cp)]);
 75                             else
 76                                 throw new RuntimeException(String.format(
 77                                     &quot;cp=[%x], expeced:[%s] result:[%s]%n&quot;,
 78                                     cp, expected, types[getType(cp)]));
 79                         }
 80                     }
 81                 });
 82     }
 83 
<a name="7" id="anc7"></a><span class="line-removed"> 84     private static void testBreak(Path path) throws IOException {</span>
<span class="line-removed"> 85         Files.lines(path)</span>
<span class="line-removed"> 86             .filter( ln -&gt; ln.length() != 0 &amp;&amp; !ln.startsWith(&quot;#&quot;) )</span>
<span class="line-removed"> 87             .forEach(ln -&gt; {</span>
<span class="line-removed"> 88                     String str = ln.replaceAll(&quot;\\s+|\\([a-zA-Z]+\\)|\\[[a-zA-Z]]+\\]|#.*&quot;, &quot;&quot;);</span>
<span class="line-removed"> 89                     // System.out.println(str);</span>
<span class="line-removed"> 90                     String[] cstrs = str.split(&quot;\u00f7|\u00d7&quot;);</span>
<span class="line-removed"> 91                     int prevCp = -1;</span>
<span class="line-removed"> 92                     char prevBk = &#39;\u00f7&#39;;</span>
<span class="line-removed"> 93                     int offBk = 0;</span>
<span class="line-removed"> 94                     for (String cstr : cstrs) {</span>
<span class="line-removed"> 95                         if (cstr.length() == 0)  // first empty str</span>
<span class="line-removed"> 96                             continue;</span>
<span class="line-removed"> 97                         int cp = Integer.parseInt(cstr, 16);</span>
<span class="line-removed"> 98                         if (prevCp == -1) {</span>
<span class="line-removed"> 99                             prevCp = cp;</span>
<span class="line-removed">100                         } else {</span>
<span class="line-removed">101                             // test against the rules directly</span>
<span class="line-removed">102                             if (rules[getType(prevCp)][getType(cp)] != (prevBk == &#39;\u00f7&#39;)) {</span>
<span class="line-removed">103                                 throw new RuntimeException(String.format(</span>
<span class="line-removed">104                                     &quot;NG %x[%d] %x[%d] -&gt; %b  [%s]%n&quot;,</span>
<span class="line-removed">105                                     prevCp, getType(prevCp), cp, getType(cp),</span>
<span class="line-removed">106                                     rules[getType(prevCp)][getType(cp)],</span>
<span class="line-removed">107                                     ln));</span>
<span class="line-removed">108                             }</span>
<span class="line-removed">109                         }</span>
<span class="line-removed">110                         prevCp = cp;</span>
<span class="line-removed">111                         offBk += (cstr.length() + 1);</span>
<span class="line-removed">112                         prevBk = str.charAt(offBk);</span>
<span class="line-removed">113                     }</span>
<span class="line-removed">114                 });</span>
<span class="line-removed">115     }</span>
<span class="line-removed">116 </span>
117     private static final String[] types = {
<a name="8" id="anc8"></a><span class="line-modified">118         &quot;Other&quot;, &quot;CR&quot;, &quot;LF&quot;, &quot;Control&quot;, &quot;Extend&quot;, &quot;Regional_Indicator&quot;,</span>
119         &quot;Prepend&quot;, &quot;SpacingMark&quot;,
<a name="9" id="anc9"></a><span class="line-modified">120         &quot;L&quot;, &quot;V&quot;, &quot;T&quot;, &quot;LV&quot;, &quot;LVT&quot; };</span>

121 
122     ///////////////////////////////////////////////////////////////////////////////////////////////////////////////
123 
<a name="10" id="anc10"></a>
124     // types
125     private static final int OTHER = 0;
126     private static final int CR = 1;
127     private static final int LF = 2;
128     private static final int CONTROL = 3;
129     private static final int EXTEND = 4;
<a name="11" id="anc11"></a><span class="line-modified">130     private static final int RI = 5;</span>
<span class="line-modified">131     private static final int PREPEND = 6;</span>
<span class="line-modified">132     private static final int SPACINGMARK = 7;</span>
<span class="line-modified">133     private static final int L = 8;</span>
<span class="line-modified">134     private static final int V = 9;</span>
<span class="line-modified">135     private static final int T = 10;</span>
<span class="line-modified">136     private static final int LV = 11;</span>
<span class="line-modified">137     private static final int LVT = 12;</span>


138 
139     private static final int FIRST_TYPE = 0;
<a name="12" id="anc12"></a><span class="line-modified">140     private static final int LAST_TYPE = 12;</span>
141 
142     private static boolean[][] rules;
143     static {
144         rules = new boolean[LAST_TYPE + 1][LAST_TYPE + 1];
<a name="13" id="anc13"></a><span class="line-modified">145         // default, any + any</span>
146         for (int i = FIRST_TYPE; i &lt;= LAST_TYPE; i++)
147             for (int j = FIRST_TYPE; j &lt;= LAST_TYPE; j++)
148                 rules[i][j] = true;
149         // GB 6 L x (L | V | LV | VT)
150         rules[L][L] = false;
151         rules[L][V] = false;
152         rules[L][LV] = false;
153         rules[L][LVT] = false;
154         // GB 7 (LV | V) x (V | T)
155         rules[LV][V] = false;
156         rules[LV][T] = false;
157         rules[V][V] = false;
158         rules[V][T] = false;
159         // GB 8 (LVT | T) x T
160         rules[LVT][T] = false;
161         rules[T][T] = false;
<a name="14" id="anc14"></a><span class="line-modified">162         // GB 8a RI x RI</span>
<span class="line-removed">163         rules[RI][RI] = false;</span>
<span class="line-removed">164         // GB 9 x Extend</span>
165         // GB 9a x Spacing Mark
166         // GB 9b Prepend x
167         for (int i = FIRST_TYPE; i &lt;= LAST_TYPE; i++) {
168             rules[i][EXTEND] = false;
<a name="15" id="anc15"></a>
169             rules[i][SPACINGMARK] = false;
170             rules[PREPEND][i] = false;
171         }
172         // GB 4  (Control | CR | LF) +
173         // GB 5  + (Control | CR | LF)
174         for (int i = FIRST_TYPE; i &lt;= LAST_TYPE; i++)
175             for (int j = CR; j &lt;= CONTROL; j++) {
176                 rules[i][j] = true;
177                 rules[j][i] = true;
178             }
179         // GB 3 CR x LF
180         rules[CR][LF] = false;
<a name="16" id="anc16"></a><span class="line-modified">181         // GB 10 Any + Any  -&gt; default</span>


182     }
183 
184     // Hangul syllables
185     private static final int SYLLABLE_BASE = 0xAC00;
186     private static final int LCOUNT = 19;
187     private static final int VCOUNT = 21;
188     private static final int TCOUNT = 28;
189     private static final int NCOUNT = VCOUNT * TCOUNT; // 588
190     private static final int SCOUNT = LCOUNT * NCOUNT; // 11172
191 
192     // #tr29: SpacingMark exceptions: The following (which have
193     // General_Category = Spacing_Mark and would otherwise be included)
194     // are specifically excluded
195     private static boolean isExcludedSpacingMark(int cp) {
196        return  cp == 0x102B || cp == 0x102C || cp == 0x1038 ||
197                cp &gt;= 0x1062 &amp;&amp; cp &lt;= 0x1064 ||
198                cp &gt;= 0x1062 &amp;&amp; cp &lt;= 0x106D ||
199                cp == 0x1083 ||
200                cp &gt;= 0x1087 &amp;&amp; cp &lt;= 0x108C ||
201                cp == 0x108F ||
202                cp &gt;= 0x109A &amp;&amp; cp &lt;= 0x109C ||
203                cp == 0x1A61 || cp == 0x1A63 || cp == 0x1A64 ||
204                cp == 0xAA7B || cp == 0xAA7D;
205     }
206 
<a name="17" id="anc17"></a>
207     private static int getType(int cp) {
<a name="18" id="anc18"></a>



208         int type = Character.getType(cp);
209         switch(type) {
210         case Character.CONTROL:
211             if (cp == 0x000D)
212                 return CR;
213             if (cp == 0x000A)
214                 return LF;
215             return CONTROL;
<a name="19" id="anc19"></a><span class="line-modified">216          case Character.UNASSIGNED:</span>
217             // NOTE: #tr29 lists &quot;Unassigned and Default_Ignorable_Code_Point&quot; as Control
218             // but GraphemeBreakTest.txt lists u+0378/reserved-0378 as &quot;Other&quot;
219             // so type it as &quot;Other&quot; to make the test happy
<a name="20" id="anc20"></a><span class="line-modified">220              if (cp == 0x0378)</span>
<span class="line-modified">221                  return OTHER;</span>

222         case Character.LINE_SEPARATOR:
223         case Character.PARAGRAPH_SEPARATOR:
224         case Character.SURROGATE:
225             return CONTROL;
226         case Character.FORMAT:
<a name="21" id="anc21"></a><span class="line-modified">227             if (cp == 0x200C || cp == 0x200D)</span>

228                 return EXTEND;
<a name="22" id="anc22"></a>





229             return CONTROL;
230         case Character.NON_SPACING_MARK:
231         case Character.ENCLOSING_MARK:
<a name="23" id="anc23"></a><span class="line-modified">232              // NOTE:</span>
<span class="line-modified">233              // #tr29 &quot;plus a few General_Category = Spacing_Mark needed for</span>
<span class="line-modified">234              // canonical equivalence.&quot;</span>
<span class="line-modified">235              // but for &quot;extended grapheme clusters&quot; support, there is no</span>
<span class="line-modified">236              // need actually to diff &quot;extend&quot; and &quot;spackmark&quot; given GB9, GB9a</span>
<span class="line-modified">237              return EXTEND;</span>
238         case  Character.COMBINING_SPACING_MARK:
239             if (isExcludedSpacingMark(cp))
240                 return OTHER;
241             // NOTE:
242             // 0x11720 and 0x11721 are mentioned in #tr29 as
243             // OTHER_LETTER but it appears their category has been updated to
244             // COMBING_SPACING_MARK already (verified in ver.8)
245             return SPACINGMARK;
246         case Character.OTHER_SYMBOL:
247             if (cp &gt;= 0x1F1E6 &amp;&amp; cp &lt;= 0x1F1FF)
248                 return RI;
249             return OTHER;
250         case Character.MODIFIER_LETTER:
<a name="24" id="anc24"></a>
251             // WARNING:
252             // not mentioned in #tr29 but listed in GraphemeBreakProperty.txt
<a name="25" id="anc25"></a><span class="line-modified">253             if (cp == 0xFF9E || cp == 0xFF9F)</span>

254                 return EXTEND;
255             return OTHER;
256         case Character.OTHER_LETTER:
257             if (cp == 0x0E33 || cp == 0x0EB3)
258                 return SPACINGMARK;
259             // hangul jamo
260             if (cp &gt;= 0x1100 &amp;&amp; cp &lt;= 0x11FF) {
261                 if (cp &lt;= 0x115F)
262                     return L;
263                 if (cp &lt;= 0x11A7)
264                     return V;
265                 return T;
266             }
267             // hangul syllables
268             int sindex = cp - SYLLABLE_BASE;
269             if (sindex &gt;= 0 &amp;&amp; sindex &lt; SCOUNT) {
270 
271                 if (sindex % TCOUNT == 0)
272                     return LV;
273                 return LVT;
274             }
275             //  hangul jamo_extended A
276             if (cp &gt;= 0xA960 &amp;&amp; cp &lt;= 0xA97C)
277                 return L;
278             //  hangul jamo_extended B
279             if (cp &gt;= 0xD7B0 &amp;&amp; cp &lt;= 0xD7C6)
280                 return V;
281             if (cp &gt;= 0xD7CB &amp;&amp; cp &lt;= 0xD7FB)
282                 return T;
<a name="26" id="anc26"></a>















283         }
284         return OTHER;
285     }
<a name="27" id="anc27"></a>

























































































286 }
<a name="28" id="anc28"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="28" type="hidden" />
</body>
</html>
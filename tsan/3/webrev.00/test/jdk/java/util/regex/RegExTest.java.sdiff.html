<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff test/jdk/java/util/regex/RegExTest.java</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
<body>
<center><a href="GraphemeTest.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="TestCases.txt.sdiff.html" target="_top">next &gt;</a></center>    <h2>test/jdk/java/util/regex/RegExTest.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 1999, 2018, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  */
  23 
  24 /**
  25  * @test
  26  * @summary tests RegExp framework (use -Dseed=X to set PRNG seed)
  27  * @author Mike McCloskey
  28  * @bug 4481568 4482696 4495089 4504687 4527731 4599621 4631553 4619345
  29  * 4630911 4672616 4711773 4727935 4750573 4792284 4803197 4757029 4808962
  30  * 4872664 4803179 4892980 4900747 4945394 4938995 4979006 4994840 4997476
  31  * 5013885 5003322 4988891 5098443 5110268 6173522 4829857 5027748 6376940
  32  * 6358731 6178785 6284152 6231989 6497148 6486934 6233084 6504326 6635133
  33  * 6350801 6676425 6878475 6919132 6931676 6948903 6990617 7014645 7039066
  34  * 7067045 7014640 7189363 8007395 8013252 8013254 8012646 8023647 6559590
  35  * 8027645 8035076 8039124 8035975 8074678 6854417 8143854 8147531 7071819
  36  * 8151481 4867170 7080302 6728861 6995635 6736245 4916384 6328855 6192895
  37  * 6345469 6988218 6693451 7006761 8140212 8143282 8158482 8176029 8184706
<span class="line-modified">  38  * 8194667 8197462 8184692</span>
  39  *
  40  * @library /test/lib

  41  * @build jdk.test.lib.RandomFactory
  42  * @run main RegExTest
  43  * @key randomness
  44  */
  45 
<span class="line-modified">  46 import java.util.function.Function;</span>
<span class="line-modified">  47 import java.util.regex.*;</span>














  48 import java.util.Random;
  49 import java.util.Scanner;
<span class="line-modified">  50 import java.io.*;</span>
<span class="line-removed">  51 import java.nio.file.*;</span>
<span class="line-removed">  52 import java.util.*;</span>
<span class="line-removed">  53 import java.nio.CharBuffer;</span>
  54 import java.util.function.Predicate;




  55 import jdk.test.lib.RandomFactory;
  56 
  57 /**
  58  * This is a test class created to check the operation of
  59  * the Pattern and Matcher classes.
  60  */
  61 public class RegExTest {
  62 
  63     private static Random generator = RandomFactory.getRandom();
  64     private static boolean failure = false;
  65     private static int failCount = 0;
  66     private static String firstFailure = null;
  67 
  68     /**
  69      * Main to interpret arguments and run several tests.
  70      *
  71      */
  72     public static void main(String[] args) throws Exception {
  73         // Most of the tests are in a file
  74         processFile(&quot;TestCases.txt&quot;);
</pre>
<hr />
<pre>
 153         surrogatesInClassTest();
 154         removeQEQuotingTest();
 155         namedGroupCaptureTest();
 156         nonBmpClassComplementTest();
 157         unicodePropertiesTest();
 158         unicodeHexNotationTest();
 159         unicodeClassesTest();
 160         unicodeCharacterNameTest();
 161         horizontalAndVerticalWSTest();
 162         linebreakTest();
 163         branchTest();
 164         groupCurlyNotFoundSuppTest();
 165         groupCurlyBackoffTest();
 166         patternAsPredicate();
 167         patternAsMatchPredicate();
 168         invalidFlags();
 169         embeddedFlags();
 170         grapheme();
 171         expoBacktracking();
 172         invalidGroupName();



 173 
 174         if (failure) {
 175             throw new
 176                 RuntimeException(&quot;RegExTest failed, 1st failure: &quot; +
 177                                  firstFailure);
 178         } else {
 179             System.err.println(&quot;OKAY: All tests passed.&quot;);
 180         }
 181     }
 182 
 183     // Utility functions
 184 
 185     private static String getRandomAlphaString(int length) {
 186         StringBuffer buf = new StringBuffer(length);
 187         for (int i=0; i&lt;length; i++) {
 188             char randChar = (char)(97 + generator.nextInt(26));
 189             buf.append(randChar);
 190         }
 191         return buf.toString();
 192     }
</pre>
<hr />
<pre>
1037         expectRegionFail(matcher, 12*2, 12*2);
1038 
1039         pattern = Pattern.compile(toSupplementaries(&quot;^abc$&quot;));
1040         matcher = pattern.matcher(toSupplementaries(&quot;zzzabczzz&quot;));
1041         matcher.region(0,9*2);
1042         if (matcher.find())
1043             failCount++;
1044         matcher.region(3*2,6*2);
1045         if (!matcher.find())
1046            failCount++;
1047         matcher.region(3*2+1,6*2);
1048         if (matcher.find())
1049            failCount++;
1050         matcher.region(3*2,6*2-1);
1051         if (matcher.find())
1052            failCount++;
1053         matcher.region(3*2,6*2);
1054         matcher.useAnchoringBounds(false);
1055         if (matcher.find())
1056            failCount++;
















1057         report(&quot;Regions&quot;);
1058     }
1059 
1060     private static void expectRegionFail(Matcher matcher, int index1,
1061                                          int index2)
1062     {
1063         try {
1064             matcher.region(index1, index2);
1065             failCount++;
1066         } catch (IndexOutOfBoundsException ioobe) {
1067             // Correct result
1068         } catch (IllegalStateException ise) {
1069             // Correct result
1070         }
1071     }
1072 
1073     // This test is for 4803197
1074     private static void escapedSegmentTest() throws Exception {
1075 
1076         Pattern pattern = Pattern.compile(&quot;\\Qdir1\\dir2\\E&quot;);
</pre>
<hr />
<pre>
4738 
4739     // This test is for 8158482
4740     private static void embeddedFlags() throws Exception {
4741         try {
4742             Pattern.compile(&quot;(?i).(?-i).&quot;);
4743             Pattern.compile(&quot;(?m).(?-m).&quot;);
4744             Pattern.compile(&quot;(?s).(?-s).&quot;);
4745             Pattern.compile(&quot;(?d).(?-d).&quot;);
4746             Pattern.compile(&quot;(?u).(?-u).&quot;);
4747             Pattern.compile(&quot;(?c).(?-c).&quot;);
4748             Pattern.compile(&quot;(?x).(?-x).&quot;);
4749             Pattern.compile(&quot;(?U).(?-U).&quot;);
4750             Pattern.compile(&quot;(?imsducxU).(?-imsducxU).&quot;);
4751         } catch (PatternSyntaxException x) {
4752             failCount++;
4753         }
4754         report(&quot;Embedded flags&quot;);
4755     }
4756 
4757     private static void grapheme() throws Exception {
<span class="line-modified">4758         Files.lines(Paths.get(System.getProperty(&quot;test.src&quot;, &quot;.&quot;),</span>
<span class="line-removed">4759                               &quot;GraphemeBreakTest.txt&quot;))</span>
4760             .filter( ln -&gt; ln.length() != 0 &amp;&amp; !ln.startsWith(&quot;#&quot;) )
4761             .forEach( ln -&gt; {
4762                     ln = ln.replaceAll(&quot;\\s+|\\([a-zA-Z]+\\)|\\[[a-zA-Z]]+\\]|#.*&quot;, &quot;&quot;);
4763                     // System.out.println(str);
4764                     String[] strs = ln.split(&quot;\u00f7|\u00d7&quot;);
4765                     StringBuilder src = new StringBuilder();
4766                     ArrayList&lt;String&gt; graphemes = new ArrayList&lt;&gt;();
4767                     StringBuilder buf = new StringBuilder();
4768                     int offBk = 0;
4769                     for (String str : strs) {
4770                         if (str.length() == 0)  // first empty str
4771                             continue;
4772                         int cp = Integer.parseInt(str, 16);
4773                         src.appendCodePoint(cp);
4774                         buf.appendCodePoint(cp);
4775                         offBk += (str.length() + 1);
4776                         if (ln.charAt(offBk) == &#39;\u00f7&#39;) {    // DIV
4777                             graphemes.add(buf.toString());
4778                             buf = new StringBuilder();
4779                         }
</pre>
<hr />
<pre>
4915             }
4916         }
4917         // Invalid char in a group name
4918         for (String groupName : List.of(&quot;a.&quot;, &quot;b\u0040&quot;, &quot;c\u005b&quot;,
4919                 &quot;d\u0060&quot;, &quot;e\u007b&quot;, &quot;f\u0416&quot;)) {
4920             for (String pat : List.of(&quot;(?&lt;&quot; + groupName + &quot;&gt;)&quot;,
4921                     &quot;\\k&lt;&quot; + groupName + &quot;&gt;&quot;)) {
4922                 try {
4923                     Pattern.compile(pat);
4924                     failCount++;
4925                 } catch (PatternSyntaxException e) {
4926                     if (!e.getMessage().startsWith(
4927                             &quot;named capturing group is missing trailing &#39;&gt;&#39;&quot;)) {
4928                         failCount++;
4929                     }
4930                 }
4931             }
4932         }
4933         report(&quot;Invalid capturing group names&quot;);
4934     }


















































































































4935 }
</pre>
</td>
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 1999, 2020, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  */
  23 
  24 /**
  25  * @test
  26  * @summary tests RegExp framework (use -Dseed=X to set PRNG seed)
  27  * @author Mike McCloskey
  28  * @bug 4481568 4482696 4495089 4504687 4527731 4599621 4631553 4619345
  29  * 4630911 4672616 4711773 4727935 4750573 4792284 4803197 4757029 4808962
  30  * 4872664 4803179 4892980 4900747 4945394 4938995 4979006 4994840 4997476
  31  * 5013885 5003322 4988891 5098443 5110268 6173522 4829857 5027748 6376940
  32  * 6358731 6178785 6284152 6231989 6497148 6486934 6233084 6504326 6635133
  33  * 6350801 6676425 6878475 6919132 6931676 6948903 6990617 7014645 7039066
  34  * 7067045 7014640 7189363 8007395 8013252 8013254 8012646 8023647 6559590
  35  * 8027645 8035076 8039124 8035975 8074678 6854417 8143854 8147531 7071819
  36  * 8151481 4867170 7080302 6728861 6995635 6736245 4916384 6328855 6192895
  37  * 6345469 6988218 6693451 7006761 8140212 8143282 8158482 8176029 8184706
<span class="line-modified">  38  * 8194667 8197462 8184692 8221431 8224789 8228352 8230829 8236034 8235812</span>
  39  *
  40  * @library /test/lib
<span class="line-added">  41  * @library /lib/testlibrary/java/lang</span>
  42  * @build jdk.test.lib.RandomFactory
  43  * @run main RegExTest
  44  * @key randomness
  45  */
  46 
<span class="line-modified">  47 import java.io.BufferedReader;</span>
<span class="line-modified">  48 import java.io.ByteArrayInputStream;</span>
<span class="line-added">  49 import java.io.ByteArrayOutputStream;</span>
<span class="line-added">  50 import java.io.File;</span>
<span class="line-added">  51 import java.io.FileInputStream;</span>
<span class="line-added">  52 import java.io.InputStreamReader;</span>
<span class="line-added">  53 import java.io.ObjectInputStream;</span>
<span class="line-added">  54 import java.io.ObjectOutputStream;</span>
<span class="line-added">  55 import java.math.BigInteger;</span>
<span class="line-added">  56 import java.nio.CharBuffer;</span>
<span class="line-added">  57 import java.nio.file.Files;</span>
<span class="line-added">  58 import java.util.ArrayList;</span>
<span class="line-added">  59 import java.util.Arrays;</span>
<span class="line-added">  60 import java.util.HashMap;</span>
<span class="line-added">  61 import java.util.List;</span>
<span class="line-added">  62 import java.util.Map;</span>
  63 import java.util.Random;
  64 import java.util.Scanner;
<span class="line-modified">  65 import java.util.function.Function;</span>



  66 import java.util.function.Predicate;
<span class="line-added">  67 import java.util.regex.Matcher;</span>
<span class="line-added">  68 import java.util.regex.MatchResult;</span>
<span class="line-added">  69 import java.util.regex.Pattern;</span>
<span class="line-added">  70 import java.util.regex.PatternSyntaxException;</span>
  71 import jdk.test.lib.RandomFactory;
  72 
  73 /**
  74  * This is a test class created to check the operation of
  75  * the Pattern and Matcher classes.
  76  */
  77 public class RegExTest {
  78 
  79     private static Random generator = RandomFactory.getRandom();
  80     private static boolean failure = false;
  81     private static int failCount = 0;
  82     private static String firstFailure = null;
  83 
  84     /**
  85      * Main to interpret arguments and run several tests.
  86      *
  87      */
  88     public static void main(String[] args) throws Exception {
  89         // Most of the tests are in a file
  90         processFile(&quot;TestCases.txt&quot;);
</pre>
<hr />
<pre>
 169         surrogatesInClassTest();
 170         removeQEQuotingTest();
 171         namedGroupCaptureTest();
 172         nonBmpClassComplementTest();
 173         unicodePropertiesTest();
 174         unicodeHexNotationTest();
 175         unicodeClassesTest();
 176         unicodeCharacterNameTest();
 177         horizontalAndVerticalWSTest();
 178         linebreakTest();
 179         branchTest();
 180         groupCurlyNotFoundSuppTest();
 181         groupCurlyBackoffTest();
 182         patternAsPredicate();
 183         patternAsMatchPredicate();
 184         invalidFlags();
 185         embeddedFlags();
 186         grapheme();
 187         expoBacktracking();
 188         invalidGroupName();
<span class="line-added"> 189         illegalRepetitionRange();</span>
<span class="line-added"> 190         surrogatePairWithCanonEq();</span>
<span class="line-added"> 191         lineBreakWithQuantifier();</span>
 192 
 193         if (failure) {
 194             throw new
 195                 RuntimeException(&quot;RegExTest failed, 1st failure: &quot; +
 196                                  firstFailure);
 197         } else {
 198             System.err.println(&quot;OKAY: All tests passed.&quot;);
 199         }
 200     }
 201 
 202     // Utility functions
 203 
 204     private static String getRandomAlphaString(int length) {
 205         StringBuffer buf = new StringBuffer(length);
 206         for (int i=0; i&lt;length; i++) {
 207             char randChar = (char)(97 + generator.nextInt(26));
 208             buf.append(randChar);
 209         }
 210         return buf.toString();
 211     }
</pre>
<hr />
<pre>
1056         expectRegionFail(matcher, 12*2, 12*2);
1057 
1058         pattern = Pattern.compile(toSupplementaries(&quot;^abc$&quot;));
1059         matcher = pattern.matcher(toSupplementaries(&quot;zzzabczzz&quot;));
1060         matcher.region(0,9*2);
1061         if (matcher.find())
1062             failCount++;
1063         matcher.region(3*2,6*2);
1064         if (!matcher.find())
1065            failCount++;
1066         matcher.region(3*2+1,6*2);
1067         if (matcher.find())
1068            failCount++;
1069         matcher.region(3*2,6*2-1);
1070         if (matcher.find())
1071            failCount++;
1072         matcher.region(3*2,6*2);
1073         matcher.useAnchoringBounds(false);
1074         if (matcher.find())
1075            failCount++;
<span class="line-added">1076 </span>
<span class="line-added">1077         // JDK-8230829</span>
<span class="line-added">1078         pattern = Pattern.compile(&quot;\\ud800\\udc61&quot;);</span>
<span class="line-added">1079         matcher = pattern.matcher(&quot;\ud800\udc61&quot;);</span>
<span class="line-added">1080         matcher.region(0, 1);</span>
<span class="line-added">1081         if (matcher.find()) {</span>
<span class="line-added">1082             failCount++;</span>
<span class="line-added">1083             System.out.println(&quot;Matched a surrogate pair&quot; +</span>
<span class="line-added">1084                     &quot; that crosses border of region&quot;);</span>
<span class="line-added">1085         }</span>
<span class="line-added">1086         if (!matcher.hitEnd()) {</span>
<span class="line-added">1087             failCount++;</span>
<span class="line-added">1088             System.out.println(&quot;Expected to hit the end when&quot; +</span>
<span class="line-added">1089                     &quot; matching a surrogate pair crossing region&quot;);</span>
<span class="line-added">1090         }</span>
<span class="line-added">1091 </span>
1092         report(&quot;Regions&quot;);
1093     }
1094 
1095     private static void expectRegionFail(Matcher matcher, int index1,
1096                                          int index2)
1097     {
1098         try {
1099             matcher.region(index1, index2);
1100             failCount++;
1101         } catch (IndexOutOfBoundsException ioobe) {
1102             // Correct result
1103         } catch (IllegalStateException ise) {
1104             // Correct result
1105         }
1106     }
1107 
1108     // This test is for 4803197
1109     private static void escapedSegmentTest() throws Exception {
1110 
1111         Pattern pattern = Pattern.compile(&quot;\\Qdir1\\dir2\\E&quot;);
</pre>
<hr />
<pre>
4773 
4774     // This test is for 8158482
4775     private static void embeddedFlags() throws Exception {
4776         try {
4777             Pattern.compile(&quot;(?i).(?-i).&quot;);
4778             Pattern.compile(&quot;(?m).(?-m).&quot;);
4779             Pattern.compile(&quot;(?s).(?-s).&quot;);
4780             Pattern.compile(&quot;(?d).(?-d).&quot;);
4781             Pattern.compile(&quot;(?u).(?-u).&quot;);
4782             Pattern.compile(&quot;(?c).(?-c).&quot;);
4783             Pattern.compile(&quot;(?x).(?-x).&quot;);
4784             Pattern.compile(&quot;(?U).(?-U).&quot;);
4785             Pattern.compile(&quot;(?imsducxU).(?-imsducxU).&quot;);
4786         } catch (PatternSyntaxException x) {
4787             failCount++;
4788         }
4789         report(&quot;Embedded flags&quot;);
4790     }
4791 
4792     private static void grapheme() throws Exception {
<span class="line-modified">4793         Files.lines(UCDFiles.GRAPHEME_BREAK_TEST)</span>

4794             .filter( ln -&gt; ln.length() != 0 &amp;&amp; !ln.startsWith(&quot;#&quot;) )
4795             .forEach( ln -&gt; {
4796                     ln = ln.replaceAll(&quot;\\s+|\\([a-zA-Z]+\\)|\\[[a-zA-Z]]+\\]|#.*&quot;, &quot;&quot;);
4797                     // System.out.println(str);
4798                     String[] strs = ln.split(&quot;\u00f7|\u00d7&quot;);
4799                     StringBuilder src = new StringBuilder();
4800                     ArrayList&lt;String&gt; graphemes = new ArrayList&lt;&gt;();
4801                     StringBuilder buf = new StringBuilder();
4802                     int offBk = 0;
4803                     for (String str : strs) {
4804                         if (str.length() == 0)  // first empty str
4805                             continue;
4806                         int cp = Integer.parseInt(str, 16);
4807                         src.appendCodePoint(cp);
4808                         buf.appendCodePoint(cp);
4809                         offBk += (str.length() + 1);
4810                         if (ln.charAt(offBk) == &#39;\u00f7&#39;) {    // DIV
4811                             graphemes.add(buf.toString());
4812                             buf = new StringBuilder();
4813                         }
</pre>
<hr />
<pre>
4949             }
4950         }
4951         // Invalid char in a group name
4952         for (String groupName : List.of(&quot;a.&quot;, &quot;b\u0040&quot;, &quot;c\u005b&quot;,
4953                 &quot;d\u0060&quot;, &quot;e\u007b&quot;, &quot;f\u0416&quot;)) {
4954             for (String pat : List.of(&quot;(?&lt;&quot; + groupName + &quot;&gt;)&quot;,
4955                     &quot;\\k&lt;&quot; + groupName + &quot;&gt;&quot;)) {
4956                 try {
4957                     Pattern.compile(pat);
4958                     failCount++;
4959                 } catch (PatternSyntaxException e) {
4960                     if (!e.getMessage().startsWith(
4961                             &quot;named capturing group is missing trailing &#39;&gt;&#39;&quot;)) {
4962                         failCount++;
4963                     }
4964                 }
4965             }
4966         }
4967         report(&quot;Invalid capturing group names&quot;);
4968     }
<span class="line-added">4969 </span>
<span class="line-added">4970     private static void illegalRepetitionRange() {</span>
<span class="line-added">4971         // huge integers &gt; (2^31 - 1)</span>
<span class="line-added">4972         String n = BigInteger.valueOf(1L &lt;&lt; 32)</span>
<span class="line-added">4973             .toString();</span>
<span class="line-added">4974         String m = BigInteger.valueOf(1L &lt;&lt; 31)</span>
<span class="line-added">4975             .add(new BigInteger(80, generator))</span>
<span class="line-added">4976             .toString();</span>
<span class="line-added">4977         for (String rep : List.of(&quot;&quot;, &quot;x&quot;, &quot;.&quot;, &quot;,&quot;, &quot;-1&quot;, &quot;2,1&quot;,</span>
<span class="line-added">4978                 n, n + &quot;,&quot;, &quot;0,&quot; + n, n + &quot;,&quot; + m, m, m + &quot;,&quot;, &quot;0,&quot; + m)) {</span>
<span class="line-added">4979             String pat = &quot;.{&quot; + rep + &quot;}&quot;;</span>
<span class="line-added">4980             try {</span>
<span class="line-added">4981                 Pattern.compile(pat);</span>
<span class="line-added">4982                 failCount++;</span>
<span class="line-added">4983                 System.out.println(&quot;Expected to fail. Pattern: &quot; + pat);</span>
<span class="line-added">4984             } catch (PatternSyntaxException e) {</span>
<span class="line-added">4985                 if (!e.getMessage().startsWith(&quot;Illegal repetition&quot;)) {</span>
<span class="line-added">4986                     failCount++;</span>
<span class="line-added">4987                     System.out.println(&quot;Unexpected error message: &quot; + e.getMessage());</span>
<span class="line-added">4988                 }</span>
<span class="line-added">4989             } catch (Throwable t) {</span>
<span class="line-added">4990                 failCount++;</span>
<span class="line-added">4991                 System.out.println(&quot;Unexpected exception: &quot; + t);</span>
<span class="line-added">4992             }</span>
<span class="line-added">4993         }</span>
<span class="line-added">4994         report(&quot;illegalRepetitionRange&quot;);</span>
<span class="line-added">4995     }</span>
<span class="line-added">4996 </span>
<span class="line-added">4997     private static void surrogatePairWithCanonEq() {</span>
<span class="line-added">4998         try {</span>
<span class="line-added">4999             Pattern.compile(&quot;\ud834\udd21&quot;, Pattern.CANON_EQ);</span>
<span class="line-added">5000         } catch (Throwable t) {</span>
<span class="line-added">5001             failCount++;</span>
<span class="line-added">5002             System.out.println(&quot;Unexpected exception: &quot; + t);</span>
<span class="line-added">5003         }</span>
<span class="line-added">5004         report(&quot;surrogatePairWithCanonEq&quot;);</span>
<span class="line-added">5005     }</span>
<span class="line-added">5006 </span>
<span class="line-added">5007     // This test is for 8235812</span>
<span class="line-added">5008     private static void lineBreakWithQuantifier() {</span>
<span class="line-added">5009         // key:    pattern</span>
<span class="line-added">5010         // value:  lengths of input that must match the pattern</span>
<span class="line-added">5011         Map&lt;String, List&lt;Integer&gt;&gt; cases = Map.ofEntries(</span>
<span class="line-added">5012             Map.entry(&quot;\\R?&quot;,      List.of(0, 1)),</span>
<span class="line-added">5013             Map.entry(&quot;\\R*&quot;,      List.of(0, 1, 2, 3)),</span>
<span class="line-added">5014             Map.entry(&quot;\\R+&quot;,      List.of(1, 2, 3)),</span>
<span class="line-added">5015             Map.entry(&quot;\\R{0}&quot;,    List.of(0)),</span>
<span class="line-added">5016             Map.entry(&quot;\\R{1}&quot;,    List.of(1)),</span>
<span class="line-added">5017             Map.entry(&quot;\\R{2}&quot;,    List.of(2)),</span>
<span class="line-added">5018             Map.entry(&quot;\\R{3}&quot;,    List.of(3)),</span>
<span class="line-added">5019             Map.entry(&quot;\\R{0,}&quot;,   List.of(0, 1, 2, 3)),</span>
<span class="line-added">5020             Map.entry(&quot;\\R{1,}&quot;,   List.of(1, 2, 3)),</span>
<span class="line-added">5021             Map.entry(&quot;\\R{2,}&quot;,   List.of(2, 3)),</span>
<span class="line-added">5022             Map.entry(&quot;\\R{3,}&quot;,   List.of(3)),</span>
<span class="line-added">5023             Map.entry(&quot;\\R{0,0}&quot;,  List.of(0)),</span>
<span class="line-added">5024             Map.entry(&quot;\\R{0,1}&quot;,  List.of(0, 1)),</span>
<span class="line-added">5025             Map.entry(&quot;\\R{0,2}&quot;,  List.of(0, 1, 2)),</span>
<span class="line-added">5026             Map.entry(&quot;\\R{0,3}&quot;,  List.of(0, 1, 2, 3)),</span>
<span class="line-added">5027             Map.entry(&quot;\\R{1,1}&quot;,  List.of(1)),</span>
<span class="line-added">5028             Map.entry(&quot;\\R{1,2}&quot;,  List.of(1, 2)),</span>
<span class="line-added">5029             Map.entry(&quot;\\R{1,3}&quot;,  List.of(1, 2, 3)),</span>
<span class="line-added">5030             Map.entry(&quot;\\R{2,2}&quot;,  List.of(2)),</span>
<span class="line-added">5031             Map.entry(&quot;\\R{2,3}&quot;,  List.of(2, 3)),</span>
<span class="line-added">5032             Map.entry(&quot;\\R{3,3}&quot;,  List.of(3)),</span>
<span class="line-added">5033             Map.entry(&quot;\\R&quot;,       List.of(1)),</span>
<span class="line-added">5034             Map.entry(&quot;\\R\\R&quot;,    List.of(2)),</span>
<span class="line-added">5035             Map.entry(&quot;\\R\\R\\R&quot;, List.of(3))</span>
<span class="line-added">5036         );</span>
<span class="line-added">5037 </span>
<span class="line-added">5038         // key:    length of input</span>
<span class="line-added">5039         // value:  all possible inputs of given length</span>
<span class="line-added">5040         Map&lt;Integer, List&lt;String&gt;&gt; inputs = new HashMap&lt;&gt;();</span>
<span class="line-added">5041         String[] Rs = { &quot;\r\n&quot;, &quot;\r&quot;, &quot;\n&quot;,</span>
<span class="line-added">5042                         &quot;\u000B&quot;, &quot;\u000C&quot;, &quot;\u0085&quot;, &quot;\u2028&quot;, &quot;\u2029&quot; };</span>
<span class="line-added">5043         StringBuilder sb = new StringBuilder();</span>
<span class="line-added">5044         for (int len = 0; len &lt;= 3; ++len) {</span>
<span class="line-added">5045             int[] idx = new int[len + 1];</span>
<span class="line-added">5046             do {</span>
<span class="line-added">5047                 sb.setLength(0);</span>
<span class="line-added">5048                 for (int j = 0; j &lt; len; ++j)</span>
<span class="line-added">5049                     sb.append(Rs[idx[j]]);</span>
<span class="line-added">5050                 inputs.computeIfAbsent(len, ArrayList::new).add(sb.toString());</span>
<span class="line-added">5051                 idx[0]++;</span>
<span class="line-added">5052                 for (int j = 0; j &lt; len; ++j) {</span>
<span class="line-added">5053                     if (idx[j] &lt; Rs.length)</span>
<span class="line-added">5054                         break;</span>
<span class="line-added">5055                     idx[j] = 0;</span>
<span class="line-added">5056                     idx[j+1]++;</span>
<span class="line-added">5057                 }</span>
<span class="line-added">5058             } while (idx[len] == 0);</span>
<span class="line-added">5059         }</span>
<span class="line-added">5060 </span>
<span class="line-added">5061         // exhaustive testing</span>
<span class="line-added">5062         for (String patStr : cases.keySet()) {</span>
<span class="line-added">5063             Pattern[] pats = patStr.endsWith(&quot;R&quot;)</span>
<span class="line-added">5064                 ? new Pattern[] { Pattern.compile(patStr) }  // no quantifiers</span>
<span class="line-added">5065                 : new Pattern[] { Pattern.compile(patStr),          // greedy</span>
<span class="line-added">5066                                   Pattern.compile(patStr + &quot;?&quot;) };  // reluctant</span>
<span class="line-added">5067             Matcher m = pats[0].matcher(&quot;&quot;);</span>
<span class="line-added">5068             for (Pattern p : pats) {</span>
<span class="line-added">5069                 m.usePattern(p);</span>
<span class="line-added">5070                 for (int len : cases.get(patStr)) {</span>
<span class="line-added">5071                     for (String in : inputs.get(len)) {</span>
<span class="line-added">5072                         if (!m.reset(in).matches()) {</span>
<span class="line-added">5073                             failCount++;</span>
<span class="line-added">5074                             System.err.println(&quot;Expected to match &#39;&quot; +</span>
<span class="line-added">5075                                     in + &quot;&#39; =~ /&quot; + p + &quot;/&quot;);</span>
<span class="line-added">5076                         }</span>
<span class="line-added">5077                     }</span>
<span class="line-added">5078                 }</span>
<span class="line-added">5079             }</span>
<span class="line-added">5080         }</span>
<span class="line-added">5081         report(&quot;lineBreakWithQuantifier&quot;);</span>
<span class="line-added">5082     }</span>
5083 }
</pre>
</td>
</tr>
</table>
<center><a href="GraphemeTest.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="TestCases.txt.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
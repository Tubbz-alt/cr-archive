<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New test/jdk/java/util/Calendar/JapanEraNameCompatTest.java</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 /*
 25  * @test
 26  * @bug 8218781
 27  * @summary Test the localized names of Japanese era Reiwa from COMPAT provider.
 28  * @modules jdk.localedata
 29  * @run testng/othervm -Djava.locale.providers=COMPAT JapanEraNameCompatTest
 30  */
 31 
 32 import static java.util.Calendar.*;
 33 import static java.util.Locale.*;
 34 
 35 import java.time.LocalDate;
 36 import java.time.chrono.JapaneseChronology;
 37 import java.time.chrono.JapaneseEra;
 38 import java.time.format.DateTimeFormatter;
 39 import java.time.format.DateTimeParseException;
 40 import java.time.format.TextStyle;
 41 import java.util.Calendar;
 42 import java.util.Locale;
 43 
 44 import org.testng.annotations.DataProvider;
 45 import org.testng.annotations.Test;
 46 import static org.testng.Assert.assertEquals;
 47 
 48 @Test
 49 public class JapanEraNameCompatTest {
 50     static final Calendar c = new Calendar.Builder()
 51             .setCalendarType(&quot;japanese&quot;)
 52             .setFields(ERA, 5, YEAR, 1, MONTH, MAY, DAY_OF_MONTH, 1)
 53             .build();
 54     static final String EngName = &quot;Reiwa&quot;;
 55     static final String CJName = &quot;\u4ee4\u548c&quot;;
 56     static final String KoreanName = &quot;\ub808\uc774\uc640&quot;;
 57     static final String ArabicName = &quot;\u0631\u064a\u0648\u0627&quot;;
 58     static final String ThaiName = &quot;\u0e40\u0e23\u0e27\u0e30&quot;;
 59     static final String HindiName = &quot;\u0930\u0947\u0907\u0935\u093e&quot;;
 60     static final String RussianName = &quot;\u0420\u044d\u0439\u0432\u0430&quot;;
 61     static final String SerbianName = &quot;\u0420\u0435\u0438\u0432\u0430&quot;;
 62     static final String SerbLatinName = &quot;Reiva&quot;;
 63 
 64     @DataProvider(name=&quot;UtilCalendar&quot;)
 65     Object[][] dataUtilCalendar() {
 66         return new Object[][] {
 67             //locale,   long,       short
 68             { JAPAN,    CJName,     &quot;R&quot; },
 69             { KOREAN,   KoreanName, &quot;R&quot; },
 70             { CHINA,    CJName,     &quot;R&quot; },
 71             { TAIWAN,   CJName,     &quot;R&quot; }, // fallback to zh
 72             { new Locale(&quot;ar&quot;), ArabicName, ArabicName },
 73             { new Locale(&quot;th&quot;), ThaiName, &quot;R&quot; },
 74             // hi_IN fallback to root
 75             { new Locale(&quot;hi&quot;, &quot;IN&quot;), EngName, &quot;R&quot; }
 76         };
 77     }
 78 
 79     @Test(dataProvider=&quot;UtilCalendar&quot;)
 80     public void testCalendarEraDisplayName(Locale locale,
 81             String longName, String shortName) {
 82         assertEquals(c.getDisplayName(ERA, LONG, locale), longName);
 83         assertEquals(c.getDisplayName(ERA, SHORT, locale), shortName);
 84     }
 85 
 86     @DataProvider(name=&quot;JavaTime&quot;)
 87     Object[][] dataJavaTime() {
 88         return new Object[][] {
 89             // locale, full, short
 90             { JAPAN, CJName, CJName },
 91             { KOREAN, KoreanName, KoreanName },
 92             { CHINA, CJName, CJName },
 93             { TAIWAN, CJName, CJName },
 94             { new Locale(&quot;ar&quot;), ArabicName, ArabicName },
 95             { new Locale(&quot;th&quot;), ThaiName, ThaiName },
 96             { new Locale(&quot;hi&quot;, &quot;IN&quot;), HindiName, HindiName },
 97             { new Locale(&quot;ru&quot;), RussianName, RussianName },
 98             { new Locale(&quot;sr&quot;), SerbianName, SerbianName },
 99             { Locale.forLanguageTag(&quot;sr-Latn&quot;), SerbLatinName, SerbLatinName },
100             { new Locale(&quot;hr&quot;), EngName, EngName },
101             { new Locale(&quot;in&quot;), EngName, EngName },
102             { new Locale(&quot;lt&quot;), EngName, EngName },
103             { new Locale(&quot;nl&quot;), EngName, EngName },
104             { new Locale(&quot;no&quot;), EngName, &quot;R&quot; },
105             { new Locale(&quot;sv&quot;), EngName, EngName },
106             // el fallback to root
107             { new Locale(&quot;el&quot;), EngName, EngName }
108         };
109     }
110 
111     @Test(dataProvider=&quot;JavaTime&quot;)
112     public void testChronoJapanEraDisplayName(Locale locale,
113             String fullName, String shortName) {
114 
115         JapaneseEra era = JapaneseEra.valueOf(&quot;Reiwa&quot;);
116         assertEquals(era.getDisplayName(TextStyle.FULL, locale), fullName);
117         assertEquals(era.getDisplayName(TextStyle.SHORT, locale), shortName);
118         assertEquals(era.getDisplayName(TextStyle.NARROW, locale), &quot;R&quot;);
119     }
120 
121     @Test
122     public void testFormatParseEraName() {
123         LocalDate date = LocalDate.of(2019, 5, 1);
124         DateTimeFormatter formatter = DateTimeFormatter.ofPattern(&quot;yyyy MM dd GGGG&quot;);
125         formatter = formatter.withChronology(JapaneseChronology.INSTANCE);
126 
127         int num = 0;
128         for (Locale locale : Calendar.getAvailableLocales()) {
129             formatter = formatter.withLocale(locale);
130             try {
131                 LocalDate.parse(date.format(formatter), formatter);
132             } catch (DateTimeParseException e) {
133                 // If an array is defined for Japanese eras in java.time resource,
134                 // but an era entry is missing, format fallback to English name
135                 // while parse throw DateTimeParseException.
136                 num++;
137                 System.out.println(&quot;Missing java.time resource data for locale: &quot; + locale);
138             }
139         }
140         if (num &gt; 0) {
141             throw new RuntimeException(&quot;Missing java.time data for &quot; + num + &quot; locales&quot;);
142         }
143     }
144 }
    </pre>
  </body>
</html>
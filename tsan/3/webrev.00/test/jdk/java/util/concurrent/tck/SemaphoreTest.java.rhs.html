<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames test/jdk/java/util/concurrent/tck/SemaphoreTest.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  3  *
  4  * This code is free software; you can redistribute it and/or modify it
  5  * under the terms of the GNU General Public License version 2 only, as
  6  * published by the Free Software Foundation.
  7  *
  8  * This code is distributed in the hope that it will be useful, but WITHOUT
  9  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 10  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 11  * version 2 for more details (a copy is included in the LICENSE file that
 12  * accompanied this code).
 13  *
 14  * You should have received a copy of the GNU General Public License version
 15  * 2 along with this work; if not, write to the Free Software Foundation,
 16  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 17  *
 18  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 19  * or visit www.oracle.com if you need additional information or have any
 20  * questions.
 21  */
 22 
 23 /*
 24  * This file is available under and governed by the GNU General Public
 25  * License version 2 only, as published by the Free Software Foundation.
 26  * However, the following notice accompanied the original version of this
 27  * file:
 28  *
 29  * Written by Doug Lea with assistance from members of JCP JSR-166
 30  * Expert Group and released to the public domain, as explained at
 31  * http://creativecommons.org/publicdomain/zero/1.0/
 32  * Other contributors include Andrew Wright, Jeffrey Hayes,
 33  * Pat Fisher, Mike Judd.
 34  */
 35 
 36 import static java.util.concurrent.TimeUnit.MILLISECONDS;
 37 
 38 import java.util.Collection;
 39 import java.util.concurrent.CountDownLatch;
 40 import java.util.concurrent.Semaphore;
<a name="1" id="anc1"></a>
 41 
 42 import junit.framework.Test;
 43 import junit.framework.TestSuite;
 44 
 45 public class SemaphoreTest extends JSR166TestCase {
 46     public static void main(String[] args) {
 47         main(suite(), args);
 48     }
 49     public static Test suite() {
 50         return new TestSuite(SemaphoreTest.class);
 51     }
 52 
 53     /**
 54      * Subclass to expose protected methods
 55      */
 56     static class PublicSemaphore extends Semaphore {
 57         PublicSemaphore(int permits) { super(permits); }
 58         PublicSemaphore(int permits, boolean fair) { super(permits, fair); }
 59         public Collection&lt;Thread&gt; getQueuedThreads() {
 60             return super.getQueuedThreads();
 61         }
 62         public boolean hasQueuedThread(Thread t) {
 63             return super.getQueuedThreads().contains(t);
 64         }
 65         public void reducePermits(int reduction) {
 66             super.reducePermits(reduction);
 67         }
 68     }
 69 
 70     /**
 71      * A runnable calling acquire
 72      */
 73     class InterruptibleLockRunnable extends CheckedRunnable {
 74         final Semaphore lock;
 75         InterruptibleLockRunnable(Semaphore s) { lock = s; }
 76         public void realRun() {
 77             try {
 78                 lock.acquire();
 79             }
 80             catch (InterruptedException ignored) {}
 81         }
 82     }
 83 
 84     /**
 85      * A runnable calling acquire that expects to be interrupted
 86      */
 87     class InterruptedLockRunnable extends CheckedInterruptedRunnable {
 88         final Semaphore lock;
 89         InterruptedLockRunnable(Semaphore s) { lock = s; }
 90         public void realRun() throws InterruptedException {
 91             lock.acquire();
 92         }
 93     }
 94 
 95     /**
 96      * Spin-waits until s.hasQueuedThread(t) becomes true.
 97      */
 98     void waitForQueuedThread(PublicSemaphore s, Thread t) {
 99         long startTime = System.nanoTime();
100         while (!s.hasQueuedThread(t)) {
101             if (millisElapsedSince(startTime) &gt; LONG_DELAY_MS)
102                 throw new AssertionError(&quot;timed out&quot;);
103             Thread.yield();
104         }
105         assertTrue(s.hasQueuedThreads());
106         assertTrue(t.isAlive());
107     }
108 
109     /**
110      * Spin-waits until s.hasQueuedThreads() becomes true.
111      */
112     void waitForQueuedThreads(Semaphore s) {
113         long startTime = System.nanoTime();
114         while (!s.hasQueuedThreads()) {
115             if (millisElapsedSince(startTime) &gt; LONG_DELAY_MS)
116                 throw new AssertionError(&quot;timed out&quot;);
117             Thread.yield();
118         }
119     }
120 
121     enum AcquireMethod {
122         acquire() {
123             void acquire(Semaphore s) throws InterruptedException {
124                 s.acquire();
125             }
126         },
127         acquireN() {
128             void acquire(Semaphore s, int permits) throws InterruptedException {
129                 s.acquire(permits);
130             }
131         },
132         acquireUninterruptibly() {
133             void acquire(Semaphore s) {
134                 s.acquireUninterruptibly();
135             }
136         },
137         acquireUninterruptiblyN() {
138             void acquire(Semaphore s, int permits) {
139                 s.acquireUninterruptibly(permits);
140             }
141         },
142         tryAcquire() {
143             void acquire(Semaphore s) {
144                 assertTrue(s.tryAcquire());
145             }
146         },
147         tryAcquireN() {
148             void acquire(Semaphore s, int permits) {
149                 assertTrue(s.tryAcquire(permits));
150             }
151         },
152         tryAcquireTimed() {
153             void acquire(Semaphore s) throws InterruptedException {
154                 assertTrue(s.tryAcquire(2 * LONG_DELAY_MS, MILLISECONDS));
155             }
156             Thread.State parkedState() { return Thread.State.TIMED_WAITING; }
157         },
158         tryAcquireTimedN {
159             void acquire(Semaphore s, int permits) throws InterruptedException {
160                 assertTrue(s.tryAcquire(permits, 2 * LONG_DELAY_MS, MILLISECONDS));
161             }
162             Thread.State parkedState() { return Thread.State.TIMED_WAITING; }
163         };
164 
165         // Intentionally meta-circular
166 
167         /** Acquires 1 permit. */
168         void acquire(Semaphore s) throws InterruptedException {
169             acquire(s, 1);
170         }
171         /** Acquires the given number of permits. */
172         void acquire(Semaphore s, int permits) throws InterruptedException {
173             for (int i = 0; i &lt; permits; i++)
174                 acquire(s);
175         }
176         Thread.State parkedState() { return Thread.State.WAITING; }
177     }
178 
179     /**
180      * Zero, negative, and positive initial values are allowed in constructor
181      */
182     public void testConstructor()      { testConstructor(false); }
183     public void testConstructor_fair() { testConstructor(true); }
184     public void testConstructor(boolean fair) {
185         for (int permits : new int[] { -42, -1, 0, 1, 42 }) {
186             Semaphore s = new Semaphore(permits, fair);
187             assertEquals(permits, s.availablePermits());
188             assertEquals(fair, s.isFair());
189         }
190     }
191 
192     /**
193      * Constructor without fairness argument behaves as nonfair
194      */
195     public void testConstructorDefaultsToNonFair() {
196         for (int permits : new int[] { -42, -1, 0, 1, 42 }) {
197             Semaphore s = new Semaphore(permits);
198             assertEquals(permits, s.availablePermits());
199             assertFalse(s.isFair());
200         }
201     }
202 
203     /**
204      * tryAcquire succeeds when sufficient permits, else fails
205      */
206     public void testTryAcquireInSameThread()      { testTryAcquireInSameThread(false); }
207     public void testTryAcquireInSameThread_fair() { testTryAcquireInSameThread(true); }
208     public void testTryAcquireInSameThread(boolean fair) {
209         Semaphore s = new Semaphore(2, fair);
210         assertEquals(2, s.availablePermits());
211         assertTrue(s.tryAcquire());
212         assertTrue(s.tryAcquire());
213         assertEquals(0, s.availablePermits());
214         assertFalse(s.tryAcquire());
215         assertFalse(s.tryAcquire());
216         assertEquals(0, s.availablePermits());
217     }
218 
219     /**
220      * timed tryAcquire times out
221      */
<a name="2" id="anc2"></a><span class="line-modified">222     public void testTryAcquire_timeout() throws InterruptedException {</span>
<span class="line-modified">223         final boolean fair = randomBoolean();</span>
224         final Semaphore s = new Semaphore(0, fair);
225         final long startTime = System.nanoTime();
<a name="3" id="anc3"></a><span class="line-modified">226         assertFalse(s.tryAcquire(timeoutMillis(), MILLISECONDS));</span>

227         assertTrue(millisElapsedSince(startTime) &gt;= timeoutMillis());
228     }
229 
230     /**
231      * timed tryAcquire(N) times out
232      */
<a name="4" id="anc4"></a><span class="line-modified">233     public void testTryAcquireN_timeout() throws InterruptedException {</span>
<span class="line-modified">234         final boolean fair = randomBoolean();</span>
235         final Semaphore s = new Semaphore(2, fair);
236         final long startTime = System.nanoTime();
<a name="5" id="anc5"></a><span class="line-modified">237         assertFalse(s.tryAcquire(3, timeoutMillis(), MILLISECONDS));</span>

238         assertTrue(millisElapsedSince(startTime) &gt;= timeoutMillis());
239     }
240 
241     /**
242      * acquire(), acquire(N), timed tryAcquired, timed tryAcquire(N)
243      * are interruptible
244      */
245     public void testInterruptible_acquire()               { testInterruptible(false, AcquireMethod.acquire); }
246     public void testInterruptible_acquire_fair()          { testInterruptible(true,  AcquireMethod.acquire); }
247     public void testInterruptible_acquireN()              { testInterruptible(false, AcquireMethod.acquireN); }
248     public void testInterruptible_acquireN_fair()         { testInterruptible(true,  AcquireMethod.acquireN); }
249     public void testInterruptible_tryAcquireTimed()       { testInterruptible(false, AcquireMethod.tryAcquireTimed); }
250     public void testInterruptible_tryAcquireTimed_fair()  { testInterruptible(true,  AcquireMethod.tryAcquireTimed); }
251     public void testInterruptible_tryAcquireTimedN()      { testInterruptible(false, AcquireMethod.tryAcquireTimedN); }
252     public void testInterruptible_tryAcquireTimedN_fair() { testInterruptible(true,  AcquireMethod.tryAcquireTimedN); }
253     public void testInterruptible(boolean fair, final AcquireMethod acquirer) {
254         final PublicSemaphore s = new PublicSemaphore(0, fair);
255         final java.util.concurrent.CyclicBarrier pleaseInterrupt
256             = new java.util.concurrent.CyclicBarrier(2);
257         Thread t = newStartedThread(new CheckedRunnable() {
258             public void realRun() {
259                 // Interrupt before acquire
260                 Thread.currentThread().interrupt();
261                 try {
262                     acquirer.acquire(s);
263                     shouldThrow();
264                 } catch (InterruptedException success) {}
265                 assertFalse(Thread.interrupted());
266 
267                 // Interrupt before acquire(N)
268                 Thread.currentThread().interrupt();
269                 try {
270                     acquirer.acquire(s, 3);
271                     shouldThrow();
272                 } catch (InterruptedException success) {}
273                 assertFalse(Thread.interrupted());
274 
275                 // Interrupt during acquire
276                 await(pleaseInterrupt);
277                 try {
278                     acquirer.acquire(s);
279                     shouldThrow();
280                 } catch (InterruptedException success) {}
281                 assertFalse(Thread.interrupted());
282 
283                 // Interrupt during acquire(N)
284                 await(pleaseInterrupt);
285                 try {
286                     acquirer.acquire(s, 3);
287                     shouldThrow();
288                 } catch (InterruptedException success) {}
289                 assertFalse(Thread.interrupted());
290             }});
291 
292         for (int n = 2; n--&gt;0; ) {
293             await(pleaseInterrupt);
294             assertThreadBlocks(t, acquirer.parkedState());
295             t.interrupt();
296         }
297 
298         awaitTermination(t);
299     }
300 
301     /**
302      * acquireUninterruptibly(), acquireUninterruptibly(N) are
303      * uninterruptible
304      */
305     public void testUninterruptible_acquireUninterruptibly()       { testUninterruptible(false, AcquireMethod.acquireUninterruptibly); }
306     public void testUninterruptible_acquireUninterruptibly_fair()  { testUninterruptible(true,  AcquireMethod.acquireUninterruptibly); }
307     public void testUninterruptible_acquireUninterruptiblyN()      { testUninterruptible(false, AcquireMethod.acquireUninterruptiblyN); }
308     public void testUninterruptible_acquireUninterruptiblyN_fair() { testUninterruptible(true,  AcquireMethod.acquireUninterruptiblyN); }
309     public void testUninterruptible(boolean fair, final AcquireMethod acquirer) {
310         final PublicSemaphore s = new PublicSemaphore(0, fair);
311         final Semaphore pleaseInterrupt = new Semaphore(-1, fair);
312 
313         Thread t1 = newStartedThread(new CheckedRunnable() {
314             public void realRun() throws InterruptedException {
315                 // Interrupt before acquire
316                 pleaseInterrupt.release();
317                 Thread.currentThread().interrupt();
318                 acquirer.acquire(s);
319                 assertTrue(Thread.interrupted());
320             }});
321 
322         Thread t2 = newStartedThread(new CheckedRunnable() {
323             public void realRun() throws InterruptedException {
324                 // Interrupt during acquire
325                 pleaseInterrupt.release();
326                 acquirer.acquire(s);
327                 assertTrue(Thread.interrupted());
328             }});
329 
330         await(pleaseInterrupt);
331         waitForQueuedThread(s, t1);
332         waitForQueuedThread(s, t2);
333         t2.interrupt();
334 
335         assertThreadBlocks(t1, Thread.State.WAITING);
336         assertThreadBlocks(t2, Thread.State.WAITING);
337 
338         s.release(2);
339 
340         awaitTermination(t1);
341         awaitTermination(t2);
342     }
343 
344     /**
345      * hasQueuedThreads reports whether there are waiting threads
346      */
347     public void testHasQueuedThreads()      { testHasQueuedThreads(false); }
348     public void testHasQueuedThreads_fair() { testHasQueuedThreads(true); }
349     public void testHasQueuedThreads(boolean fair) {
350         final PublicSemaphore lock = new PublicSemaphore(1, fair);
351         assertFalse(lock.hasQueuedThreads());
352         lock.acquireUninterruptibly();
353         Thread t1 = newStartedThread(new InterruptedLockRunnable(lock));
354         waitForQueuedThread(lock, t1);
355         assertTrue(lock.hasQueuedThreads());
356         Thread t2 = newStartedThread(new InterruptibleLockRunnable(lock));
357         waitForQueuedThread(lock, t2);
358         assertTrue(lock.hasQueuedThreads());
359         t1.interrupt();
360         awaitTermination(t1);
361         assertTrue(lock.hasQueuedThreads());
362         lock.release();
363         awaitTermination(t2);
364         assertFalse(lock.hasQueuedThreads());
365     }
366 
367     /**
368      * getQueueLength reports number of waiting threads
369      */
370     public void testGetQueueLength()      { testGetQueueLength(false); }
371     public void testGetQueueLength_fair() { testGetQueueLength(true); }
372     public void testGetQueueLength(boolean fair) {
373         final PublicSemaphore lock = new PublicSemaphore(1, fair);
374         assertEquals(0, lock.getQueueLength());
375         lock.acquireUninterruptibly();
376         Thread t1 = newStartedThread(new InterruptedLockRunnable(lock));
377         waitForQueuedThread(lock, t1);
378         assertEquals(1, lock.getQueueLength());
379         Thread t2 = newStartedThread(new InterruptibleLockRunnable(lock));
380         waitForQueuedThread(lock, t2);
381         assertEquals(2, lock.getQueueLength());
382         t1.interrupt();
383         awaitTermination(t1);
384         assertEquals(1, lock.getQueueLength());
385         lock.release();
386         awaitTermination(t2);
387         assertEquals(0, lock.getQueueLength());
388     }
389 
390     /**
391      * getQueuedThreads includes waiting threads
392      */
393     public void testGetQueuedThreads()      { testGetQueuedThreads(false); }
394     public void testGetQueuedThreads_fair() { testGetQueuedThreads(true); }
395     public void testGetQueuedThreads(boolean fair) {
396         final PublicSemaphore lock = new PublicSemaphore(1, fair);
397         assertTrue(lock.getQueuedThreads().isEmpty());
398         lock.acquireUninterruptibly();
399         assertTrue(lock.getQueuedThreads().isEmpty());
400         Thread t1 = newStartedThread(new InterruptedLockRunnable(lock));
401         waitForQueuedThread(lock, t1);
402         assertTrue(lock.getQueuedThreads().contains(t1));
403         Thread t2 = newStartedThread(new InterruptibleLockRunnable(lock));
404         waitForQueuedThread(lock, t2);
405         assertTrue(lock.getQueuedThreads().contains(t1));
406         assertTrue(lock.getQueuedThreads().contains(t2));
407         t1.interrupt();
408         awaitTermination(t1);
409         assertFalse(lock.getQueuedThreads().contains(t1));
410         assertTrue(lock.getQueuedThreads().contains(t2));
411         lock.release();
412         awaitTermination(t2);
413         assertTrue(lock.getQueuedThreads().isEmpty());
414     }
415 
416     /**
417      * drainPermits reports and removes given number of permits
418      */
419     public void testDrainPermits()      { testDrainPermits(false); }
420     public void testDrainPermits_fair() { testDrainPermits(true); }
421     public void testDrainPermits(boolean fair) {
422         Semaphore s = new Semaphore(0, fair);
423         assertEquals(0, s.availablePermits());
424         assertEquals(0, s.drainPermits());
425         s.release(10);
426         assertEquals(10, s.availablePermits());
427         assertEquals(10, s.drainPermits());
428         assertEquals(0, s.availablePermits());
429         assertEquals(0, s.drainPermits());
430     }
431 
432     /**
433      * release(-N) throws IllegalArgumentException
434      */
435     public void testReleaseIAE()      { testReleaseIAE(false); }
436     public void testReleaseIAE_fair() { testReleaseIAE(true); }
437     public void testReleaseIAE(boolean fair) {
438         Semaphore s = new Semaphore(10, fair);
439         try {
440             s.release(-1);
441             shouldThrow();
442         } catch (IllegalArgumentException success) {}
443     }
444 
445     /**
446      * reducePermits(-N) throws IllegalArgumentException
447      */
448     public void testReducePermitsIAE()      { testReducePermitsIAE(false); }
449     public void testReducePermitsIAE_fair() { testReducePermitsIAE(true); }
450     public void testReducePermitsIAE(boolean fair) {
451         PublicSemaphore s = new PublicSemaphore(10, fair);
452         try {
453             s.reducePermits(-1);
454             shouldThrow();
455         } catch (IllegalArgumentException success) {}
456     }
457 
458     /**
459      * reducePermits reduces number of permits
460      */
461     public void testReducePermits()      { testReducePermits(false); }
462     public void testReducePermits_fair() { testReducePermits(true); }
463     public void testReducePermits(boolean fair) {
464         PublicSemaphore s = new PublicSemaphore(10, fair);
465         assertEquals(10, s.availablePermits());
466         s.reducePermits(0);
467         assertEquals(10, s.availablePermits());
468         s.reducePermits(1);
469         assertEquals(9, s.availablePermits());
470         s.reducePermits(10);
471         assertEquals(-1, s.availablePermits());
472         s.reducePermits(10);
473         assertEquals(-11, s.availablePermits());
474         s.reducePermits(0);
475         assertEquals(-11, s.availablePermits());
476     }
477 
478     /**
479      * a reserialized semaphore has same number of permits and
480      * fairness, but no queued threads
481      */
482     public void testSerialization()      { testSerialization(false); }
483     public void testSerialization_fair() { testSerialization(true); }
484     public void testSerialization(boolean fair) {
485         try {
486             Semaphore s = new Semaphore(3, fair);
487             s.acquire();
488             s.acquire();
489             s.release();
490 
491             Semaphore clone = serialClone(s);
492             assertEquals(fair, s.isFair());
493             assertEquals(fair, clone.isFair());
494             assertEquals(2, s.availablePermits());
495             assertEquals(2, clone.availablePermits());
496             clone.acquire();
497             clone.acquire();
498             clone.release();
499             assertEquals(2, s.availablePermits());
500             assertEquals(1, clone.availablePermits());
501             assertFalse(s.hasQueuedThreads());
502             assertFalse(clone.hasQueuedThreads());
503         } catch (InterruptedException e) { threadUnexpectedException(e); }
504 
505         {
506             PublicSemaphore s = new PublicSemaphore(0, fair);
507             Thread t = newStartedThread(new InterruptibleLockRunnable(s));
508             // waitForQueuedThreads(s); // suffers from &quot;flicker&quot;, so ...
509             waitForQueuedThread(s, t);  // ... we use this instead
510             PublicSemaphore clone = serialClone(s);
511             assertEquals(fair, s.isFair());
512             assertEquals(fair, clone.isFair());
513             assertEquals(0, s.availablePermits());
514             assertEquals(0, clone.availablePermits());
515             assertTrue(s.hasQueuedThreads());
516             assertFalse(clone.hasQueuedThreads());
517             s.release();
518             awaitTermination(t);
519             assertFalse(s.hasQueuedThreads());
520             assertFalse(clone.hasQueuedThreads());
521         }
522     }
523 
524     /**
525      * tryAcquire(n) succeeds when sufficient permits, else fails
526      */
527     public void testTryAcquireNInSameThread()      { testTryAcquireNInSameThread(false); }
528     public void testTryAcquireNInSameThread_fair() { testTryAcquireNInSameThread(true); }
529     public void testTryAcquireNInSameThread(boolean fair) {
530         Semaphore s = new Semaphore(2, fair);
531         assertEquals(2, s.availablePermits());
532         assertFalse(s.tryAcquire(3));
533         assertEquals(2, s.availablePermits());
534         assertTrue(s.tryAcquire(2));
535         assertEquals(0, s.availablePermits());
536         assertFalse(s.tryAcquire(1));
537         assertFalse(s.tryAcquire(2));
538         assertEquals(0, s.availablePermits());
539     }
540 
541     /**
542      * acquire succeeds if permits available
543      */
544     public void testReleaseAcquireSameThread_acquire()       { testReleaseAcquireSameThread(false, AcquireMethod.acquire); }
545     public void testReleaseAcquireSameThread_acquire_fair()  { testReleaseAcquireSameThread(true, AcquireMethod.acquire); }
546     public void testReleaseAcquireSameThread_acquireN()      { testReleaseAcquireSameThread(false, AcquireMethod.acquireN); }
547     public void testReleaseAcquireSameThread_acquireN_fair() { testReleaseAcquireSameThread(true, AcquireMethod.acquireN); }
548     public void testReleaseAcquireSameThread_acquireUninterruptibly()       { testReleaseAcquireSameThread(false, AcquireMethod.acquireUninterruptibly); }
549     public void testReleaseAcquireSameThread_acquireUninterruptibly_fair()  { testReleaseAcquireSameThread(true, AcquireMethod.acquireUninterruptibly); }
550     public void testReleaseAcquireSameThread_acquireUninterruptiblyN()      { testReleaseAcquireSameThread(false, AcquireMethod.acquireUninterruptibly); }
551     public void testReleaseAcquireSameThread_acquireUninterruptiblyN_fair() { testReleaseAcquireSameThread(true, AcquireMethod.acquireUninterruptibly); }
552     public void testReleaseAcquireSameThread_tryAcquire()       { testReleaseAcquireSameThread(false, AcquireMethod.tryAcquire); }
553     public void testReleaseAcquireSameThread_tryAcquire_fair()  { testReleaseAcquireSameThread(true, AcquireMethod.tryAcquire); }
554     public void testReleaseAcquireSameThread_tryAcquireN()      { testReleaseAcquireSameThread(false, AcquireMethod.tryAcquireN); }
555     public void testReleaseAcquireSameThread_tryAcquireN_fair() { testReleaseAcquireSameThread(true, AcquireMethod.tryAcquireN); }
556     public void testReleaseAcquireSameThread_tryAcquireTimed()       { testReleaseAcquireSameThread(false, AcquireMethod.tryAcquireTimed); }
557     public void testReleaseAcquireSameThread_tryAcquireTimed_fair()  { testReleaseAcquireSameThread(true, AcquireMethod.tryAcquireTimed); }
558     public void testReleaseAcquireSameThread_tryAcquireTimedN()      { testReleaseAcquireSameThread(false, AcquireMethod.tryAcquireTimedN); }
559     public void testReleaseAcquireSameThread_tryAcquireTimedN_fair() { testReleaseAcquireSameThread(true, AcquireMethod.tryAcquireTimedN); }
560     public void testReleaseAcquireSameThread(boolean fair,
561                                              final AcquireMethod acquirer) {
562         Semaphore s = new Semaphore(1, fair);
563         for (int i = 1; i &lt; 6; i++) {
564             s.release(i);
565             assertEquals(1 + i, s.availablePermits());
566             try {
567                 acquirer.acquire(s, i);
568             } catch (InterruptedException e) { threadUnexpectedException(e); }
569             assertEquals(1, s.availablePermits());
570         }
571     }
572 
573     /**
574      * release in one thread enables acquire in another thread
575      */
576     public void testReleaseAcquireDifferentThreads_acquire()       { testReleaseAcquireDifferentThreads(false, AcquireMethod.acquire); }
577     public void testReleaseAcquireDifferentThreads_acquire_fair()  { testReleaseAcquireDifferentThreads(true, AcquireMethod.acquire); }
578     public void testReleaseAcquireDifferentThreads_acquireN()      { testReleaseAcquireDifferentThreads(false, AcquireMethod.acquireN); }
579     public void testReleaseAcquireDifferentThreads_acquireN_fair() { testReleaseAcquireDifferentThreads(true, AcquireMethod.acquireN); }
580     public void testReleaseAcquireDifferentThreads_acquireUninterruptibly()       { testReleaseAcquireDifferentThreads(false, AcquireMethod.acquireUninterruptibly); }
581     public void testReleaseAcquireDifferentThreads_acquireUninterruptibly_fair()  { testReleaseAcquireDifferentThreads(true, AcquireMethod.acquireUninterruptibly); }
582     public void testReleaseAcquireDifferentThreads_acquireUninterruptiblyN()      { testReleaseAcquireDifferentThreads(false, AcquireMethod.acquireUninterruptibly); }
583     public void testReleaseAcquireDifferentThreads_acquireUninterruptiblyN_fair() { testReleaseAcquireDifferentThreads(true, AcquireMethod.acquireUninterruptibly); }
584     public void testReleaseAcquireDifferentThreads_tryAcquireTimed()       { testReleaseAcquireDifferentThreads(false, AcquireMethod.tryAcquireTimed); }
585     public void testReleaseAcquireDifferentThreads_tryAcquireTimed_fair()  { testReleaseAcquireDifferentThreads(true, AcquireMethod.tryAcquireTimed); }
586     public void testReleaseAcquireDifferentThreads_tryAcquireTimedN()      { testReleaseAcquireDifferentThreads(false, AcquireMethod.tryAcquireTimedN); }
587     public void testReleaseAcquireDifferentThreads_tryAcquireTimedN_fair() { testReleaseAcquireDifferentThreads(true, AcquireMethod.tryAcquireTimedN); }
588     public void testReleaseAcquireDifferentThreads(boolean fair,
589                                                    final AcquireMethod acquirer) {
590         final Semaphore s = new Semaphore(0, fair);
591         final int rounds = 4;
592         long startTime = System.nanoTime();
593         Thread t = newStartedThread(new CheckedRunnable() {
594             public void realRun() throws InterruptedException {
595                 for (int i = 0; i &lt; rounds; i++) {
596                     assertFalse(s.hasQueuedThreads());
597                     if (i % 2 == 0)
598                         acquirer.acquire(s);
599                     else
600                         acquirer.acquire(s, 3);
601                 }}});
602 
603         for (int i = 0; i &lt; rounds; i++) {
604             while (! (s.availablePermits() == 0 &amp;&amp; s.hasQueuedThreads()))
605                 Thread.yield();
606             assertTrue(t.isAlive());
607             if (i % 2 == 0)
608                 s.release();
609             else
610                 s.release(3);
611         }
612         awaitTermination(t);
613         assertEquals(0, s.availablePermits());
614         assertTrue(millisElapsedSince(startTime) &lt; LONG_DELAY_MS);
615     }
616 
617     /**
618      * fair locks are strictly FIFO
619      */
620     public void testFairLocksFifo() {
621         final PublicSemaphore s = new PublicSemaphore(1, true);
622         final CountDownLatch pleaseRelease = new CountDownLatch(1);
623         Thread t1 = newStartedThread(new CheckedRunnable() {
624             public void realRun() throws InterruptedException {
625                 // Will block; permits are available, but not three
626                 s.acquire(3);
627             }});
628 
629         waitForQueuedThread(s, t1);
630 
631         Thread t2 = newStartedThread(new CheckedRunnable() {
632             public void realRun() throws InterruptedException {
633                 // Will fail, even though 1 permit is available
634                 assertFalse(
635                     s.tryAcquire(randomExpiredTimeout(), randomTimeUnit()));
636                 assertFalse(
637                     s.tryAcquire(1, randomExpiredTimeout(), randomTimeUnit()));
638 
639                 // untimed tryAcquire will barge and succeed
640                 assertTrue(s.tryAcquire());
641                 s.release(2);
642                 assertTrue(s.tryAcquire(2));
643                 s.release();
644 
645                 pleaseRelease.countDown();
646                 // Will queue up behind t1, even though 1 permit is available
647                 s.acquire();
648             }});
649 
650         await(pleaseRelease);
651         waitForQueuedThread(s, t2);
652         s.release(2);
653         awaitTermination(t1);
654         assertTrue(t2.isAlive());
655         s.release();
656         awaitTermination(t2);
657     }
658 
659     /**
660      * toString indicates current number of permits
661      */
662     public void testToString()      { testToString(false); }
663     public void testToString_fair() { testToString(true); }
664     public void testToString(boolean fair) {
665         PublicSemaphore s = new PublicSemaphore(0, fair);
666         assertTrue(s.toString().contains(&quot;Permits = 0&quot;));
667         s.release();
668         assertTrue(s.toString().contains(&quot;Permits = 1&quot;));
669         s.release(2);
670         assertTrue(s.toString().contains(&quot;Permits = 3&quot;));
671         s.reducePermits(5);
672         assertTrue(s.toString().contains(&quot;Permits = -2&quot;));
673     }
674 
675 }
<a name="6" id="anc6"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="6" type="hidden" />
</body>
</html>
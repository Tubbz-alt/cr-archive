<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old test/jdk/java/util/concurrent/tck/JSR166TestCase.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   3  *
   4  * This code is free software; you can redistribute it and/or modify it
   5  * under the terms of the GNU General Public License version 2 only, as
   6  * published by the Free Software Foundation.
   7  *
   8  * This code is distributed in the hope that it will be useful, but WITHOUT
   9  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  10  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  11  * version 2 for more details (a copy is included in the LICENSE file that
  12  * accompanied this code).
  13  *
  14  * You should have received a copy of the GNU General Public License version
  15  * 2 along with this work; if not, write to the Free Software Foundation,
  16  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  17  *
  18  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  19  * or visit www.oracle.com if you need additional information or have any
  20  * questions.
  21  */
  22 
  23 /*
  24  * This file is available under and governed by the GNU General Public
  25  * License version 2 only, as published by the Free Software Foundation.
  26  * However, the following notice accompanied the original version of this
  27  * file:
  28  *
  29  * Written by Doug Lea and Martin Buchholz with assistance from
  30  * members of JCP JSR-166 Expert Group and released to the public
  31  * domain, as explained at
  32  * http://creativecommons.org/publicdomain/zero/1.0/
  33  * Other contributors include Andrew Wright, Jeffrey Hayes,
  34  * Pat Fisher, Mike Judd.
  35  */
  36 
  37 /*
  38  * @test
  39  * @summary JSR-166 tck tests, in a number of variations.
  40  *          The first is the conformance testing variant,
  41  *          while others also test implementation details.
  42  * @build *
  43  * @modules java.management
  44  * @run junit/othervm/timeout=1000 JSR166TestCase
  45  * @run junit/othervm/timeout=1000
  46  *      --add-opens java.base/java.util.concurrent=ALL-UNNAMED
  47  *      --add-opens java.base/java.lang=ALL-UNNAMED
  48  *      -Djsr166.testImplementationDetails=true
  49  *      JSR166TestCase
  50  * @run junit/othervm/timeout=1000
  51  *      --add-opens java.base/java.util.concurrent=ALL-UNNAMED
  52  *      --add-opens java.base/java.lang=ALL-UNNAMED
  53  *      -Djsr166.testImplementationDetails=true
  54  *      -Djava.util.concurrent.ForkJoinPool.common.parallelism=0
  55  *      JSR166TestCase
  56  * @run junit/othervm/timeout=1000
  57  *      --add-opens java.base/java.util.concurrent=ALL-UNNAMED
  58  *      --add-opens java.base/java.lang=ALL-UNNAMED
  59  *      -Djsr166.testImplementationDetails=true
  60  *      -Djava.util.concurrent.ForkJoinPool.common.parallelism=1
  61  *      -Djava.util.secureRandomSeed=true
  62  *      JSR166TestCase
  63  * @run junit/othervm/timeout=1000/policy=tck.policy
  64  *      --add-opens java.base/java.util.concurrent=ALL-UNNAMED
  65  *      --add-opens java.base/java.lang=ALL-UNNAMED
  66  *      -Djsr166.testImplementationDetails=true
  67  *      JSR166TestCase
  68  */
  69 
  70 import static java.util.concurrent.TimeUnit.MILLISECONDS;
  71 import static java.util.concurrent.TimeUnit.MINUTES;
  72 import static java.util.concurrent.TimeUnit.NANOSECONDS;
  73 
  74 import java.io.ByteArrayInputStream;
  75 import java.io.ByteArrayOutputStream;
  76 import java.io.ObjectInputStream;
  77 import java.io.ObjectOutputStream;
  78 import java.lang.management.ManagementFactory;
  79 import java.lang.management.ThreadInfo;
  80 import java.lang.management.ThreadMXBean;
  81 import java.lang.reflect.Constructor;
  82 import java.lang.reflect.Method;
  83 import java.lang.reflect.Modifier;
  84 import java.security.CodeSource;
  85 import java.security.Permission;
  86 import java.security.PermissionCollection;
  87 import java.security.Permissions;
  88 import java.security.Policy;
  89 import java.security.ProtectionDomain;
  90 import java.security.SecurityPermission;
  91 import java.util.ArrayList;
  92 import java.util.Arrays;
  93 import java.util.Collection;
  94 import java.util.Collections;
  95 import java.util.Date;
  96 import java.util.Deque;
  97 import java.util.Enumeration;
  98 import java.util.HashSet;
  99 import java.util.Iterator;
 100 import java.util.List;
 101 import java.util.NoSuchElementException;
 102 import java.util.PropertyPermission;
 103 import java.util.Set;
 104 import java.util.concurrent.BlockingQueue;
 105 import java.util.concurrent.Callable;
 106 import java.util.concurrent.CountDownLatch;
 107 import java.util.concurrent.CyclicBarrier;
 108 import java.util.concurrent.ExecutionException;
 109 import java.util.concurrent.Executor;
 110 import java.util.concurrent.Executors;
 111 import java.util.concurrent.ExecutorService;
 112 import java.util.concurrent.ForkJoinPool;
 113 import java.util.concurrent.Future;
 114 import java.util.concurrent.FutureTask;
 115 import java.util.concurrent.RecursiveAction;
 116 import java.util.concurrent.RecursiveTask;
 117 import java.util.concurrent.RejectedExecutionException;
 118 import java.util.concurrent.RejectedExecutionHandler;
 119 import java.util.concurrent.Semaphore;
 120 import java.util.concurrent.ScheduledExecutorService;
 121 import java.util.concurrent.ScheduledFuture;
 122 import java.util.concurrent.SynchronousQueue;
 123 import java.util.concurrent.ThreadFactory;
 124 import java.util.concurrent.ThreadLocalRandom;
 125 import java.util.concurrent.ThreadPoolExecutor;
 126 import java.util.concurrent.TimeUnit;
 127 import java.util.concurrent.TimeoutException;
 128 import java.util.concurrent.atomic.AtomicBoolean;
 129 import java.util.concurrent.atomic.AtomicReference;
 130 import java.util.regex.Pattern;
 131 
 132 import junit.framework.Test;
 133 import junit.framework.TestCase;
 134 import junit.framework.TestResult;
 135 import junit.framework.TestSuite;
 136 
 137 /**
 138  * Base class for JSR166 Junit TCK tests.  Defines some constants,
 139  * utility methods and classes, as well as a simple framework for
 140  * helping to make sure that assertions failing in generated threads
 141  * cause the associated test that generated them to itself fail (which
 142  * JUnit does not otherwise arrange).  The rules for creating such
 143  * tests are:
 144  *
 145  * &lt;ol&gt;
 146  *
 147  * &lt;li&gt;All code not running in the main test thread (manually spawned threads
 148  * or the common fork join pool) must be checked for failure (and completion!).
 149  * Mechanisms that can be used to ensure this are:
 150  *   &lt;ol&gt;
 151  *   &lt;li&gt;Signalling via a synchronizer like AtomicInteger or CountDownLatch
 152  *    that the task completed normally, which is checked before returning from
 153  *    the test method in the main thread.
 154  *   &lt;li&gt;Using the forms {@link #threadFail}, {@link #threadAssertTrue},
 155  *    or {@link #threadAssertNull}, (not {@code fail}, {@code assertTrue}, etc.)
 156  *    Only the most typically used JUnit assertion methods are defined
 157  *    this way, but enough to live with.
 158  *   &lt;li&gt;Recording failure explicitly using {@link #threadUnexpectedException}
 159  *    or {@link #threadRecordFailure}.
 160  *   &lt;li&gt;Using a wrapper like CheckedRunnable that uses one the mechanisms above.
 161  *   &lt;/ol&gt;
 162  *
 163  * &lt;li&gt;If you override {@link #setUp} or {@link #tearDown}, make sure
 164  * to invoke {@code super.setUp} and {@code super.tearDown} within
 165  * them. These methods are used to clear and check for thread
 166  * assertion failures.
 167  *
 168  * &lt;li&gt;All delays and timeouts must use one of the constants {@code
 169  * SHORT_DELAY_MS}, {@code SMALL_DELAY_MS}, {@code MEDIUM_DELAY_MS},
 170  * {@code LONG_DELAY_MS}. The idea here is that a SHORT is always
 171  * discriminable from zero time, and always allows enough time for the
 172  * small amounts of computation (creating a thread, calling a few
 173  * methods, etc) needed to reach a timeout point. Similarly, a SMALL
 174  * is always discriminable as larger than SHORT and smaller than
 175  * MEDIUM.  And so on. These constants are set to conservative values,
 176  * but even so, if there is ever any doubt, they can all be increased
 177  * in one spot to rerun tests on slower platforms.
 178  *
 179  * &lt;li&gt;All threads generated must be joined inside each test case
 180  * method (or {@code fail} to do so) before returning from the
 181  * method. The {@code joinPool} method can be used to do this when
 182  * using Executors.
 183  *
 184  * &lt;/ol&gt;
 185  *
 186  * &lt;p&gt;&lt;b&gt;Other notes&lt;/b&gt;
 187  * &lt;ul&gt;
 188  *
 189  * &lt;li&gt;Usually, there is one testcase method per JSR166 method
 190  * covering &quot;normal&quot; operation, and then as many exception-testing
 191  * methods as there are exceptions the method can throw. Sometimes
 192  * there are multiple tests per JSR166 method when the different
 193  * &quot;normal&quot; behaviors differ significantly. And sometimes testcases
 194  * cover multiple methods when they cannot be tested in isolation.
 195  *
 196  * &lt;li&gt;The documentation style for testcases is to provide as javadoc
 197  * a simple sentence or two describing the property that the testcase
 198  * method purports to test. The javadocs do not say anything about how
 199  * the property is tested. To find out, read the code.
 200  *
 201  * &lt;li&gt;These tests are &quot;conformance tests&quot;, and do not attempt to
 202  * test throughput, latency, scalability or other performance factors
 203  * (see the separate &quot;jtreg&quot; tests for a set intended to check these
 204  * for the most central aspects of functionality.) So, most tests use
 205  * the smallest sensible numbers of threads, collection sizes, etc
 206  * needed to check basic conformance.
 207  *
 208  * &lt;li&gt;The test classes currently do not declare inclusion in
 209  * any particular package to simplify things for people integrating
 210  * them in TCK test suites.
 211  *
 212  * &lt;li&gt;As a convenience, the {@code main} of this class (JSR166TestCase)
 213  * runs all JSR166 unit tests.
 214  *
 215  * &lt;/ul&gt;
 216  */
 217 public class JSR166TestCase extends TestCase {
 218     private static final boolean useSecurityManager =
 219         Boolean.getBoolean(&quot;jsr166.useSecurityManager&quot;);
 220 
 221     protected static final boolean expensiveTests =
 222         Boolean.getBoolean(&quot;jsr166.expensiveTests&quot;);
 223 
 224     /**
 225      * If true, also run tests that are not part of the official tck
 226      * because they test unspecified implementation details.
 227      */
 228     protected static final boolean testImplementationDetails =
 229         Boolean.getBoolean(&quot;jsr166.testImplementationDetails&quot;);
 230 
 231     /**
 232      * If true, report on stdout all &quot;slow&quot; tests, that is, ones that
 233      * take more than profileThreshold milliseconds to execute.
 234      */
 235     private static final boolean profileTests =
 236         Boolean.getBoolean(&quot;jsr166.profileTests&quot;);
 237 
 238     /**
 239      * The number of milliseconds that tests are permitted for
 240      * execution without being reported, when profileTests is set.
 241      */
 242     private static final long profileThreshold =
 243         Long.getLong(&quot;jsr166.profileThreshold&quot;, 100);
 244 
 245     /**
 246      * The number of repetitions per test (for tickling rare bugs).
 247      */
 248     private static final int runsPerTest =
 249         Integer.getInteger(&quot;jsr166.runsPerTest&quot;, 1);
 250 
 251     /**
 252      * The number of repetitions of the test suite (for finding leaks?).
 253      */
 254     private static final int suiteRuns =
 255         Integer.getInteger(&quot;jsr166.suiteRuns&quot;, 1);
 256 
 257     /**
 258      * Returns the value of the system property, or NaN if not defined.
 259      */
 260     private static float systemPropertyValue(String name) {
 261         String floatString = System.getProperty(name);
 262         if (floatString == null)
 263             return Float.NaN;
 264         try {
 265             return Float.parseFloat(floatString);
 266         } catch (NumberFormatException ex) {
 267             throw new IllegalArgumentException(
 268                 String.format(&quot;Bad float value in system property %s=%s&quot;,
 269                               name, floatString));
 270         }
 271     }
 272 
 273     /**
 274      * The scaling factor to apply to standard delays used in tests.
 275      * May be initialized from any of:
 276      * - the &quot;jsr166.delay.factor&quot; system property
 277      * - the &quot;test.timeout.factor&quot; system property (as used by jtreg)
 278      *   See: http://openjdk.java.net/jtreg/tag-spec.html
 279      * - hard-coded fuzz factor when using a known slowpoke VM
 280      */
 281     private static final float delayFactor = delayFactor();
 282 
 283     private static float delayFactor() {
 284         float x;
 285         if (!Float.isNaN(x = systemPropertyValue(&quot;jsr166.delay.factor&quot;)))
 286             return x;
 287         if (!Float.isNaN(x = systemPropertyValue(&quot;test.timeout.factor&quot;)))
 288             return x;
 289         String prop = System.getProperty(&quot;java.vm.version&quot;);
 290         if (prop != null &amp;&amp; prop.matches(&quot;.*debug.*&quot;))
 291             return 4.0f; // How much slower is fastdebug than product?!
 292         return 1.0f;
 293     }
 294 
 295     public JSR166TestCase() { super(); }
 296     public JSR166TestCase(String name) { super(name); }
 297 
 298     /**
 299      * A filter for tests to run, matching strings of the form
 300      * methodName(className), e.g. &quot;testInvokeAll5(ForkJoinPoolTest)&quot;
 301      * Usefully combined with jsr166.runsPerTest.
 302      */
 303     private static final Pattern methodFilter = methodFilter();
 304 
 305     private static Pattern methodFilter() {
 306         String regex = System.getProperty(&quot;jsr166.methodFilter&quot;);
 307         return (regex == null) ? null : Pattern.compile(regex);
 308     }
 309 
 310     // Instrumentation to debug very rare, but very annoying hung test runs.
 311     static volatile TestCase currentTestCase;
 312     // static volatile int currentRun = 0;
 313     static {
 314         Runnable checkForWedgedTest = new Runnable() { public void run() {
 315             // Avoid spurious reports with enormous runsPerTest.
 316             // A single test case run should never take more than 1 second.
 317             // But let&#39;s cap it at the high end too ...
 318             final int timeoutMinutes =
 319                 Math.min(15, Math.max(runsPerTest / 60, 1));
 320             for (TestCase lastTestCase = currentTestCase;;) {
 321                 try { MINUTES.sleep(timeoutMinutes); }
 322                 catch (InterruptedException unexpected) { break; }
 323                 if (lastTestCase == currentTestCase) {
 324                     System.err.printf(
 325                         &quot;Looks like we&#39;re stuck running test: %s%n&quot;,
 326                         lastTestCase);
 327 //                     System.err.printf(
 328 //                         &quot;Looks like we&#39;re stuck running test: %s (%d/%d)%n&quot;,
 329 //                         lastTestCase, currentRun, runsPerTest);
 330 //                     System.err.println(&quot;availableProcessors=&quot; +
 331 //                         Runtime.getRuntime().availableProcessors());
 332 //                     System.err.printf(&quot;cpu model = %s%n&quot;, cpuModel());
 333                     dumpTestThreads();
 334                     // one stack dump is probably enough; more would be spam
 335                     break;
 336                 }
 337                 lastTestCase = currentTestCase;
 338             }}};
 339         Thread thread = new Thread(checkForWedgedTest, &quot;checkForWedgedTest&quot;);
 340         thread.setDaemon(true);
 341         thread.start();
 342     }
 343 
 344 //     public static String cpuModel() {
 345 //         try {
 346 //             java.util.regex.Matcher matcher
 347 //               = Pattern.compile(&quot;model name\\s*: (.*)&quot;)
 348 //                 .matcher(new String(
 349 //                     java.nio.file.Files.readAllBytes(
 350 //                         java.nio.file.Paths.get(&quot;/proc/cpuinfo&quot;)), &quot;UTF-8&quot;));
 351 //             matcher.find();
 352 //             return matcher.group(1);
 353 //         } catch (Exception ex) { return null; }
 354 //     }
 355 
 356     public void runBare() throws Throwable {
 357         currentTestCase = this;
 358         if (methodFilter == null
 359             || methodFilter.matcher(toString()).find())
 360             super.runBare();
 361     }
 362 
 363     protected void runTest() throws Throwable {
 364         for (int i = 0; i &lt; runsPerTest; i++) {
 365             // currentRun = i;
 366             if (profileTests)
 367                 runTestProfiled();
 368             else
 369                 super.runTest();
 370         }
 371     }
 372 
 373     protected void runTestProfiled() throws Throwable {
 374         for (int i = 0; i &lt; 2; i++) {
 375             long startTime = System.nanoTime();
 376             super.runTest();
 377             long elapsedMillis = millisElapsedSince(startTime);
 378             if (elapsedMillis &lt; profileThreshold)
 379                 break;
 380             // Never report first run of any test; treat it as a
 381             // warmup run, notably to trigger all needed classloading,
 382             if (i &gt; 0)
 383                 System.out.printf(&quot;%n%s: %d%n&quot;, toString(), elapsedMillis);
 384         }
 385     }
 386 
 387     /**
 388      * Runs all JSR166 unit tests using junit.textui.TestRunner.
 389      */
 390     public static void main(String[] args) {
 391         main(suite(), args);
 392     }
 393 
 394     static class PithyResultPrinter extends junit.textui.ResultPrinter {
 395         PithyResultPrinter(java.io.PrintStream writer) { super(writer); }
 396         long runTime;
 397         public void startTest(Test test) {}
 398         protected void printHeader(long runTime) {
 399             this.runTime = runTime; // defer printing for later
 400         }
 401         protected void printFooter(TestResult result) {
 402             if (result.wasSuccessful()) {
 403                 getWriter().println(&quot;OK (&quot; + result.runCount() + &quot; tests)&quot;
 404                     + &quot;  Time: &quot; + elapsedTimeAsString(runTime));
 405             } else {
 406                 getWriter().println(&quot;Time: &quot; + elapsedTimeAsString(runTime));
 407                 super.printFooter(result);
 408             }
 409         }
 410     }
 411 
 412     /**
 413      * Returns a TestRunner that doesn&#39;t bother with unnecessary
 414      * fluff, like printing a &quot;.&quot; for each test case.
 415      */
 416     static junit.textui.TestRunner newPithyTestRunner() {
 417         junit.textui.TestRunner runner = new junit.textui.TestRunner();
 418         runner.setPrinter(new PithyResultPrinter(System.out));
 419         return runner;
 420     }
 421 
 422     /**
 423      * Runs all unit tests in the given test suite.
 424      * Actual behavior influenced by jsr166.* system properties.
 425      */
 426     static void main(Test suite, String[] args) {
 427         if (useSecurityManager) {
 428             System.err.println(&quot;Setting a permissive security manager&quot;);
 429             Policy.setPolicy(permissivePolicy());
 430             System.setSecurityManager(new SecurityManager());
 431         }
 432         for (int i = 0; i &lt; suiteRuns; i++) {
 433             TestResult result = newPithyTestRunner().doRun(suite);
 434             if (!result.wasSuccessful())
 435                 System.exit(1);
 436             System.gc();
 437             System.runFinalization();
 438         }
 439     }
 440 
 441     public static TestSuite newTestSuite(Object... suiteOrClasses) {
 442         TestSuite suite = new TestSuite();
 443         for (Object suiteOrClass : suiteOrClasses) {
 444             if (suiteOrClass instanceof TestSuite)
 445                 suite.addTest((TestSuite) suiteOrClass);
 446             else if (suiteOrClass instanceof Class)
 447                 suite.addTest(new TestSuite((Class&lt;?&gt;) suiteOrClass));
 448             else
 449                 throw new ClassCastException(&quot;not a test suite or class&quot;);
 450         }
 451         return suite;
 452     }
 453 
 454     public static void addNamedTestClasses(TestSuite suite,
 455                                            String... testClassNames) {
 456         for (String testClassName : testClassNames) {
 457             try {
 458                 Class&lt;?&gt; testClass = Class.forName(testClassName);
 459                 Method m = testClass.getDeclaredMethod(&quot;suite&quot;);
 460                 suite.addTest(newTestSuite((Test)m.invoke(null)));
 461             } catch (ReflectiveOperationException e) {
 462                 throw new AssertionError(&quot;Missing test class&quot;, e);
 463             }
 464         }
 465     }
 466 
 467     public static final double JAVA_CLASS_VERSION;
 468     public static final String JAVA_SPECIFICATION_VERSION;
 469     static {
 470         try {
 471             JAVA_CLASS_VERSION = java.security.AccessController.doPrivileged(
 472                 new java.security.PrivilegedAction&lt;Double&gt;() {
 473                 public Double run() {
 474                     return Double.valueOf(System.getProperty(&quot;java.class.version&quot;));}});
 475             JAVA_SPECIFICATION_VERSION = java.security.AccessController.doPrivileged(
 476                 new java.security.PrivilegedAction&lt;String&gt;() {
 477                 public String run() {
 478                     return System.getProperty(&quot;java.specification.version&quot;);}});
 479         } catch (Throwable t) {
 480             throw new Error(t);
 481         }
 482     }
 483 
 484     public static boolean atLeastJava6()  { return JAVA_CLASS_VERSION &gt;= 50.0; }
 485     public static boolean atLeastJava7()  { return JAVA_CLASS_VERSION &gt;= 51.0; }
 486     public static boolean atLeastJava8()  { return JAVA_CLASS_VERSION &gt;= 52.0; }
 487     public static boolean atLeastJava9()  { return JAVA_CLASS_VERSION &gt;= 53.0; }
 488     public static boolean atLeastJava10() { return JAVA_CLASS_VERSION &gt;= 54.0; }
 489     public static boolean atLeastJava11() { return JAVA_CLASS_VERSION &gt;= 55.0; }
 490     public static boolean atLeastJava12() { return JAVA_CLASS_VERSION &gt;= 56.0; }
 491     public static boolean atLeastJava13() { return JAVA_CLASS_VERSION &gt;= 57.0; }
 492     public static boolean atLeastJava14() { return JAVA_CLASS_VERSION &gt;= 58.0; }
 493     public static boolean atLeastJava15() { return JAVA_CLASS_VERSION &gt;= 59.0; }
 494     public static boolean atLeastJava16() { return JAVA_CLASS_VERSION &gt;= 60.0; }
 495     public static boolean atLeastJava17() { return JAVA_CLASS_VERSION &gt;= 61.0; }
 496 
 497     /**
 498      * Collects all JSR166 unit tests as one suite.
 499      */
 500     public static Test suite() {
 501         // Java7+ test classes
 502         TestSuite suite = newTestSuite(
 503             ForkJoinPoolTest.suite(),
 504             ForkJoinTaskTest.suite(),
 505             RecursiveActionTest.suite(),
 506             RecursiveTaskTest.suite(),
 507             LinkedTransferQueueTest.suite(),
 508             PhaserTest.suite(),
 509             ThreadLocalRandomTest.suite(),
 510             AbstractExecutorServiceTest.suite(),
 511             AbstractQueueTest.suite(),
 512             AbstractQueuedSynchronizerTest.suite(),
 513             AbstractQueuedLongSynchronizerTest.suite(),
 514             ArrayBlockingQueueTest.suite(),
 515             ArrayDequeTest.suite(),
 516             ArrayListTest.suite(),
 517             AtomicBooleanTest.suite(),
 518             AtomicIntegerArrayTest.suite(),
 519             AtomicIntegerFieldUpdaterTest.suite(),
 520             AtomicIntegerTest.suite(),
 521             AtomicLongArrayTest.suite(),
 522             AtomicLongFieldUpdaterTest.suite(),
 523             AtomicLongTest.suite(),
 524             AtomicMarkableReferenceTest.suite(),
 525             AtomicReferenceArrayTest.suite(),
 526             AtomicReferenceFieldUpdaterTest.suite(),
 527             AtomicReferenceTest.suite(),
 528             AtomicStampedReferenceTest.suite(),
 529             ConcurrentHashMapTest.suite(),
 530             ConcurrentLinkedDequeTest.suite(),
 531             ConcurrentLinkedQueueTest.suite(),
 532             ConcurrentSkipListMapTest.suite(),
 533             ConcurrentSkipListSubMapTest.suite(),
 534             ConcurrentSkipListSetTest.suite(),
 535             ConcurrentSkipListSubSetTest.suite(),
 536             CopyOnWriteArrayListTest.suite(),
 537             CopyOnWriteArraySetTest.suite(),
 538             CountDownLatchTest.suite(),
 539             CountedCompleterTest.suite(),
 540             CyclicBarrierTest.suite(),
 541             DelayQueueTest.suite(),
 542             EntryTest.suite(),
 543             ExchangerTest.suite(),
 544             ExecutorsTest.suite(),
 545             ExecutorCompletionServiceTest.suite(),
 546             FutureTaskTest.suite(),
 547             LinkedBlockingDequeTest.suite(),
 548             LinkedBlockingQueueTest.suite(),
 549             LinkedListTest.suite(),
 550             LockSupportTest.suite(),
 551             PriorityBlockingQueueTest.suite(),
 552             PriorityQueueTest.suite(),
 553             ReentrantLockTest.suite(),
 554             ReentrantReadWriteLockTest.suite(),
 555             ScheduledExecutorTest.suite(),
 556             ScheduledExecutorSubclassTest.suite(),
 557             SemaphoreTest.suite(),
 558             SynchronousQueueTest.suite(),
 559             SystemTest.suite(),
 560             ThreadLocalTest.suite(),
 561             ThreadPoolExecutorTest.suite(),
 562             ThreadPoolExecutorSubclassTest.suite(),
 563             ThreadTest.suite(),
 564             TimeUnitTest.suite(),
 565             TreeMapTest.suite(),
 566             TreeSetTest.suite(),
 567             TreeSubMapTest.suite(),
 568             TreeSubSetTest.suite(),
 569             VectorTest.suite());
 570 
 571         // Java8+ test classes
 572         if (atLeastJava8()) {
 573             String[] java8TestClassNames = {
 574                 &quot;ArrayDeque8Test&quot;,
 575                 &quot;Atomic8Test&quot;,
 576                 &quot;CompletableFutureTest&quot;,
 577                 &quot;ConcurrentHashMap8Test&quot;,
 578                 &quot;CountedCompleter8Test&quot;,
 579                 &quot;DoubleAccumulatorTest&quot;,
 580                 &quot;DoubleAdderTest&quot;,
 581                 &quot;ForkJoinPool8Test&quot;,
 582                 &quot;ForkJoinTask8Test&quot;,
 583                 &quot;HashMapTest&quot;,
 584                 &quot;LinkedBlockingDeque8Test&quot;,
 585                 &quot;LinkedBlockingQueue8Test&quot;,
 586                 &quot;LinkedHashMapTest&quot;,
 587                 &quot;LongAccumulatorTest&quot;,
 588                 &quot;LongAdderTest&quot;,
 589                 &quot;SplittableRandomTest&quot;,
 590                 &quot;StampedLockTest&quot;,
 591                 &quot;SubmissionPublisherTest&quot;,
 592                 &quot;ThreadLocalRandom8Test&quot;,
 593                 &quot;TimeUnit8Test&quot;,
 594             };
 595             addNamedTestClasses(suite, java8TestClassNames);
 596         }
 597 
 598         // Java9+ test classes
 599         if (atLeastJava9()) {
 600             String[] java9TestClassNames = {
 601                 &quot;AtomicBoolean9Test&quot;,
 602                 &quot;AtomicInteger9Test&quot;,
 603                 &quot;AtomicIntegerArray9Test&quot;,
 604                 &quot;AtomicLong9Test&quot;,
 605                 &quot;AtomicLongArray9Test&quot;,
 606                 &quot;AtomicReference9Test&quot;,
 607                 &quot;AtomicReferenceArray9Test&quot;,
 608                 &quot;ExecutorCompletionService9Test&quot;,
 609                 &quot;ForkJoinPool9Test&quot;,
 610             };
 611             addNamedTestClasses(suite, java9TestClassNames);
 612         }
 613 
 614         return suite;
 615     }
 616 
 617     /** Returns list of junit-style test method names in given class. */
 618     public static ArrayList&lt;String&gt; testMethodNames(Class&lt;?&gt; testClass) {
 619         Method[] methods = testClass.getDeclaredMethods();
 620         ArrayList&lt;String&gt; names = new ArrayList&lt;&gt;(methods.length);
 621         for (Method method : methods) {
 622             if (method.getName().startsWith(&quot;test&quot;)
 623                 &amp;&amp; Modifier.isPublic(method.getModifiers())
 624                 // method.getParameterCount() requires jdk8+
 625                 &amp;&amp; method.getParameterTypes().length == 0) {
 626                 names.add(method.getName());
 627             }
 628         }
 629         return names;
 630     }
 631 
 632     /**
 633      * Returns junit-style testSuite for the given test class, but
 634      * parameterized by passing extra data to each test.
 635      */
 636     public static &lt;ExtraData&gt; Test parameterizedTestSuite
 637         (Class&lt;? extends JSR166TestCase&gt; testClass,
 638          Class&lt;ExtraData&gt; dataClass,
 639          ExtraData data) {
 640         try {
 641             TestSuite suite = new TestSuite();
 642             Constructor c =
 643                 testClass.getDeclaredConstructor(dataClass, String.class);
 644             for (String methodName : testMethodNames(testClass))
 645                 suite.addTest((Test) c.newInstance(data, methodName));
 646             return suite;
 647         } catch (ReflectiveOperationException e) {
 648             throw new AssertionError(e);
 649         }
 650     }
 651 
 652     /**
 653      * Returns junit-style testSuite for the jdk8 extension of the
 654      * given test class, but parameterized by passing extra data to
 655      * each test.  Uses reflection to allow compilation in jdk7.
 656      */
 657     public static &lt;ExtraData&gt; Test jdk8ParameterizedTestSuite
 658         (Class&lt;? extends JSR166TestCase&gt; testClass,
 659          Class&lt;ExtraData&gt; dataClass,
 660          ExtraData data) {
 661         if (atLeastJava8()) {
 662             String name = testClass.getName();
 663             String name8 = name.replaceAll(&quot;Test$&quot;, &quot;8Test&quot;);
 664             if (name.equals(name8)) throw new AssertionError(name);
 665             try {
 666                 return (Test)
 667                     Class.forName(name8)
 668                     .getMethod(&quot;testSuite&quot;, dataClass)
 669                     .invoke(null, data);
 670             } catch (ReflectiveOperationException e) {
 671                 throw new AssertionError(e);
 672             }
 673         } else {
 674             return new TestSuite();
 675         }
 676     }
 677 
 678     // Delays for timing-dependent tests, in milliseconds.
 679 
 680     public static long SHORT_DELAY_MS;
 681     public static long SMALL_DELAY_MS;
 682     public static long MEDIUM_DELAY_MS;
 683     public static long LONG_DELAY_MS;
 684 
 685     private static final long RANDOM_TIMEOUT;
 686     private static final long RANDOM_EXPIRED_TIMEOUT;
 687     private static final TimeUnit RANDOM_TIMEUNIT;
 688     static {
 689         ThreadLocalRandom rnd = ThreadLocalRandom.current();
 690         long[] timeouts = { Long.MIN_VALUE, -1, 0, 1, Long.MAX_VALUE };
 691         RANDOM_TIMEOUT = timeouts[rnd.nextInt(timeouts.length)];
 692         RANDOM_EXPIRED_TIMEOUT = timeouts[rnd.nextInt(3)];
 693         TimeUnit[] timeUnits = TimeUnit.values();
 694         RANDOM_TIMEUNIT = timeUnits[rnd.nextInt(timeUnits.length)];
 695     }
 696 
 697     /**
 698      * Returns a timeout for use when any value at all will do.
 699      */
 700     static long randomTimeout() { return RANDOM_TIMEOUT; }
 701 
 702     /**
 703      * Returns a timeout that means &quot;no waiting&quot;, i.e. not positive.
 704      */
 705     static long randomExpiredTimeout() { return RANDOM_EXPIRED_TIMEOUT; }
 706 
 707     /**
 708      * Returns a random non-null TimeUnit.
 709      */
 710     static TimeUnit randomTimeUnit() { return RANDOM_TIMEUNIT; }
 711 
 712     /**
 713      * Returns the shortest timed delay. This can be scaled up for
 714      * slow machines using the jsr166.delay.factor system property,
 715      * or via jtreg&#39;s -timeoutFactor: flag.
 716      * http://openjdk.java.net/jtreg/command-help.html
 717      */
 718     protected long getShortDelay() {
 719         return (long) (50 * delayFactor);
 720     }
 721 
 722     /**
 723      * Sets delays as multiples of SHORT_DELAY.
 724      */
 725     protected void setDelays() {
 726         SHORT_DELAY_MS = getShortDelay();
 727         SMALL_DELAY_MS  = SHORT_DELAY_MS * 5;
 728         MEDIUM_DELAY_MS = SHORT_DELAY_MS * 10;
 729         LONG_DELAY_MS   = SHORT_DELAY_MS * 200;
 730     }
 731 
 732     private static final long TIMEOUT_DELAY_MS
 733         = (long) (12.0 * Math.cbrt(delayFactor));
 734 
 735     /**
 736      * Returns a timeout in milliseconds to be used in tests that verify
 737      * that operations block or time out.  We want this to be longer
 738      * than the OS scheduling quantum, but not too long, so don&#39;t scale
 739      * linearly with delayFactor; we use &quot;crazy&quot; cube root instead.
 740      */
 741     static long timeoutMillis() {
 742         return TIMEOUT_DELAY_MS;
 743     }
 744 
 745     /**
 746      * Returns a new Date instance representing a time at least
 747      * delayMillis milliseconds in the future.
 748      */
 749     Date delayedDate(long delayMillis) {
 750         // Add 1 because currentTimeMillis is known to round into the past.
 751         return new Date(System.currentTimeMillis() + delayMillis + 1);
 752     }
 753 
 754     /**
 755      * The first exception encountered if any threadAssertXXX method fails.
 756      */
 757     private final AtomicReference&lt;Throwable&gt; threadFailure
 758         = new AtomicReference&lt;&gt;(null);
 759 
 760     /**
 761      * Records an exception so that it can be rethrown later in the test
 762      * harness thread, triggering a test case failure.  Only the first
 763      * failure is recorded; subsequent calls to this method from within
 764      * the same test have no effect.
 765      */
 766     public void threadRecordFailure(Throwable t) {
 767         System.err.println(t);
 768         dumpTestThreads();
 769         threadFailure.compareAndSet(null, t);
 770     }
 771 
 772     public void setUp() {
 773         setDelays();
 774     }
 775 
 776     void tearDownFail(String format, Object... args) {
 777         String msg = toString() + &quot;: &quot; + String.format(format, args);
 778         System.err.println(msg);
 779         dumpTestThreads();
 780         throw new AssertionError(msg);
 781     }
 782 
 783     /**
 784      * Extra checks that get done for all test cases.
 785      *
 786      * Triggers test case failure if any thread assertions have failed,
 787      * by rethrowing, in the test harness thread, any exception recorded
 788      * earlier by threadRecordFailure.
 789      *
 790      * Triggers test case failure if interrupt status is set in the main thread.
 791      */
 792     public void tearDown() throws Exception {
 793         Throwable t = threadFailure.getAndSet(null);
 794         if (t != null) {
 795             if (t instanceof Error)
 796                 throw (Error) t;
 797             else if (t instanceof RuntimeException)
 798                 throw (RuntimeException) t;
 799             else if (t instanceof Exception)
 800                 throw (Exception) t;
 801             else
 802                 throw new AssertionError(t.toString(), t);
 803         }
 804 
 805         if (Thread.interrupted())
 806             tearDownFail(&quot;interrupt status set in main thread&quot;);
 807 
 808         checkForkJoinPoolThreadLeaks();
 809     }
 810 
 811     /**
 812      * Finds missing PoolCleaners
 813      */
 814     void checkForkJoinPoolThreadLeaks() throws InterruptedException {
 815         Thread[] survivors = new Thread[7];
 816         int count = Thread.enumerate(survivors);
 817         for (int i = 0; i &lt; count; i++) {
 818             Thread thread = survivors[i];
 819             String name = thread.getName();
 820             if (name.startsWith(&quot;ForkJoinPool-&quot;)) {
 821                 // give thread some time to terminate
 822                 thread.join(LONG_DELAY_MS);
 823                 if (thread.isAlive())
 824                     tearDownFail(&quot;Found leaked ForkJoinPool thread thread=%s&quot;,
 825                                  thread);
 826             }
 827         }
 828 
 829         if (!ForkJoinPool.commonPool()
 830             .awaitQuiescence(LONG_DELAY_MS, MILLISECONDS))
 831             tearDownFail(&quot;ForkJoin common pool thread stuck&quot;);
 832     }
 833 
 834     /**
 835      * Just like fail(reason), but additionally recording (using
 836      * threadRecordFailure) any AssertionError thrown, so that the
 837      * current testcase will fail.
 838      */
 839     public void threadFail(String reason) {
 840         try {
 841             fail(reason);
 842         } catch (AssertionError fail) {
 843             threadRecordFailure(fail);
 844             throw fail;
 845         }
 846     }
 847 
 848     /**
 849      * Just like assertTrue(b), but additionally recording (using
 850      * threadRecordFailure) any AssertionError thrown, so that the
 851      * current testcase will fail.
 852      */
 853     public void threadAssertTrue(boolean b) {
 854         try {
 855             assertTrue(b);
 856         } catch (AssertionError fail) {
 857             threadRecordFailure(fail);
 858             throw fail;
 859         }
 860     }
 861 
 862     /**
 863      * Just like assertFalse(b), but additionally recording (using
 864      * threadRecordFailure) any AssertionError thrown, so that the
 865      * current testcase will fail.
 866      */
 867     public void threadAssertFalse(boolean b) {
 868         try {
 869             assertFalse(b);
 870         } catch (AssertionError fail) {
 871             threadRecordFailure(fail);
 872             throw fail;
 873         }
 874     }
 875 
 876     /**
 877      * Just like assertNull(x), but additionally recording (using
 878      * threadRecordFailure) any AssertionError thrown, so that the
 879      * current testcase will fail.
 880      */
 881     public void threadAssertNull(Object x) {
 882         try {
 883             assertNull(x);
 884         } catch (AssertionError fail) {
 885             threadRecordFailure(fail);
 886             throw fail;
 887         }
 888     }
 889 
 890     /**
 891      * Just like assertEquals(x, y), but additionally recording (using
 892      * threadRecordFailure) any AssertionError thrown, so that the
 893      * current testcase will fail.
 894      */
 895     public void threadAssertEquals(long x, long y) {
 896         try {
 897             assertEquals(x, y);
 898         } catch (AssertionError fail) {
 899             threadRecordFailure(fail);
 900             throw fail;
 901         }
 902     }
 903 
 904     /**
 905      * Just like assertEquals(x, y), but additionally recording (using
 906      * threadRecordFailure) any AssertionError thrown, so that the
 907      * current testcase will fail.
 908      */
 909     public void threadAssertEquals(Object x, Object y) {
 910         try {
 911             assertEquals(x, y);
 912         } catch (AssertionError fail) {
 913             threadRecordFailure(fail);
 914             throw fail;
 915         } catch (Throwable fail) {
 916             threadUnexpectedException(fail);
 917         }
 918     }
 919 
 920     /**
 921      * Just like assertSame(x, y), but additionally recording (using
 922      * threadRecordFailure) any AssertionError thrown, so that the
 923      * current testcase will fail.
 924      */
 925     public void threadAssertSame(Object x, Object y) {
 926         try {
 927             assertSame(x, y);
 928         } catch (AssertionError fail) {
 929             threadRecordFailure(fail);
 930             throw fail;
 931         }
 932     }
 933 
 934     /**
 935      * Calls threadFail with message &quot;should throw exception&quot;.
 936      */
 937     public void threadShouldThrow() {
 938         threadFail(&quot;should throw exception&quot;);
 939     }
 940 
 941     /**
 942      * Calls threadFail with message &quot;should throw&quot; + exceptionName.
 943      */
 944     public void threadShouldThrow(String exceptionName) {
 945         threadFail(&quot;should throw &quot; + exceptionName);
 946     }
 947 
 948     /**
 949      * Records the given exception using {@link #threadRecordFailure},
 950      * then rethrows the exception, wrapping it in an AssertionError
 951      * if necessary.
 952      */
 953     public void threadUnexpectedException(Throwable t) {
 954         threadRecordFailure(t);
 955         t.printStackTrace();
 956         if (t instanceof RuntimeException)
 957             throw (RuntimeException) t;
 958         else if (t instanceof Error)
 959             throw (Error) t;
 960         else
 961             throw new AssertionError(&quot;unexpected exception: &quot; + t, t);
 962     }
 963 
 964     /**
 965      * Delays, via Thread.sleep, for the given millisecond delay, but
 966      * if the sleep is shorter than specified, may re-sleep or yield
 967      * until time elapses.  Ensures that the given time, as measured
 968      * by System.nanoTime(), has elapsed.
 969      */
 970     static void delay(long millis) throws InterruptedException {
 971         long nanos = millis * (1000 * 1000);
 972         final long wakeupTime = System.nanoTime() + nanos;
 973         do {
 974             if (millis &gt; 0L)
 975                 Thread.sleep(millis);
 976             else // too short to sleep
 977                 Thread.yield();
 978             nanos = wakeupTime - System.nanoTime();
 979             millis = nanos / (1000 * 1000);
 980         } while (nanos &gt;= 0L);
 981     }
 982 
 983     /**
 984      * Allows use of try-with-resources with per-test thread pools.
 985      */
 986     class PoolCleaner implements AutoCloseable {
 987         private final ExecutorService pool;
 988         public PoolCleaner(ExecutorService pool) { this.pool = pool; }
 989         public void close() { joinPool(pool); }
 990     }
 991 
 992     /**
 993      * An extension of PoolCleaner that has an action to release the pool.
 994      */
 995     class PoolCleanerWithReleaser extends PoolCleaner {
 996         private final Runnable releaser;
 997         public PoolCleanerWithReleaser(ExecutorService pool, Runnable releaser) {
 998             super(pool);
 999             this.releaser = releaser;
1000         }
1001         public void close() {
1002             try {
1003                 releaser.run();
1004             } finally {
1005                 super.close();
1006             }
1007         }
1008     }
1009 
1010     PoolCleaner cleaner(ExecutorService pool) {
1011         return new PoolCleaner(pool);
1012     }
1013 
1014     PoolCleaner cleaner(ExecutorService pool, Runnable releaser) {
1015         return new PoolCleanerWithReleaser(pool, releaser);
1016     }
1017 
1018     PoolCleaner cleaner(ExecutorService pool, CountDownLatch latch) {
1019         return new PoolCleanerWithReleaser(pool, releaser(latch));
1020     }
1021 
1022     Runnable releaser(final CountDownLatch latch) {
1023         return new Runnable() { public void run() {
1024             do { latch.countDown(); }
1025             while (latch.getCount() &gt; 0);
1026         }};
1027     }
1028 
1029     PoolCleaner cleaner(ExecutorService pool, AtomicBoolean flag) {
1030         return new PoolCleanerWithReleaser(pool, releaser(flag));
1031     }
1032 
1033     Runnable releaser(final AtomicBoolean flag) {
1034         return new Runnable() { public void run() { flag.set(true); }};
1035     }
1036 
1037     /**
1038      * Waits out termination of a thread pool or fails doing so.
1039      */
1040     void joinPool(ExecutorService pool) {
1041         try {
1042             pool.shutdown();
1043             if (!pool.awaitTermination(2 * LONG_DELAY_MS, MILLISECONDS)) {
1044                 try {
1045                     threadFail(&quot;ExecutorService &quot; + pool +
1046                                &quot; did not terminate in a timely manner&quot;);
1047                 } finally {
1048                     // last resort, for the benefit of subsequent tests
1049                     pool.shutdownNow();
1050                     pool.awaitTermination(MEDIUM_DELAY_MS, MILLISECONDS);
1051                 }
1052             }
1053         } catch (SecurityException ok) {
1054             // Allowed in case test doesn&#39;t have privs
1055         } catch (InterruptedException fail) {
1056             threadFail(&quot;Unexpected InterruptedException&quot;);
1057         }
1058     }
1059 
1060     /**
1061      * Like Runnable, but with the freedom to throw anything.
1062      * junit folks had the same idea:
1063      * http://junit.org/junit5/docs/snapshot/api/org/junit/gen5/api/Executable.html
1064      */
1065     interface Action { public void run() throws Throwable; }
1066 
1067     /**
1068      * Runs all the given actions in parallel, failing if any fail.
1069      * Useful for running multiple variants of tests that are
1070      * necessarily individually slow because they must block.
1071      */
1072     void testInParallel(Action ... actions) {
1073         ExecutorService pool = Executors.newCachedThreadPool();
1074         try (PoolCleaner cleaner = cleaner(pool)) {
1075             ArrayList&lt;Future&lt;?&gt;&gt; futures = new ArrayList&lt;&gt;(actions.length);
1076             for (final Action action : actions)
1077                 futures.add(pool.submit(new CheckedRunnable() {
1078                     public void realRun() throws Throwable { action.run();}}));
1079             for (Future&lt;?&gt; future : futures)
1080                 try {
1081                     assertNull(future.get(LONG_DELAY_MS, MILLISECONDS));
1082                 } catch (ExecutionException ex) {
1083                     threadUnexpectedException(ex.getCause());
1084                 } catch (Exception ex) {
1085                     threadUnexpectedException(ex);
1086                 }
1087         }
1088     }
1089 
1090     /**
1091      * A debugging tool to print stack traces of most threads, as jstack does.
1092      * Uninteresting threads are filtered out.
1093      */
1094     static void dumpTestThreads() {
1095         SecurityManager sm = System.getSecurityManager();
1096         if (sm != null) {
1097             try {
1098                 System.setSecurityManager(null);
1099             } catch (SecurityException giveUp) {
1100                 return;
1101             }
1102         }
1103 
1104         ThreadMXBean threadMXBean = ManagementFactory.getThreadMXBean();
1105         System.err.println(&quot;------ stacktrace dump start ------&quot;);
1106         for (ThreadInfo info : threadMXBean.dumpAllThreads(true, true)) {
1107             final String name = info.getThreadName();
1108             String lockName;
1109             if (&quot;Signal Dispatcher&quot;.equals(name))
1110                 continue;
1111             if (&quot;Reference Handler&quot;.equals(name)
1112                 &amp;&amp; (lockName = info.getLockName()) != null
1113                 &amp;&amp; lockName.startsWith(&quot;java.lang.ref.Reference$Lock&quot;))
1114                 continue;
1115             if (&quot;Finalizer&quot;.equals(name)
1116                 &amp;&amp; (lockName = info.getLockName()) != null
1117                 &amp;&amp; lockName.startsWith(&quot;java.lang.ref.ReferenceQueue$Lock&quot;))
1118                 continue;
1119             if (&quot;checkForWedgedTest&quot;.equals(name))
1120                 continue;
1121             System.err.print(info);
1122         }
1123         System.err.println(&quot;------ stacktrace dump end ------&quot;);
1124 
1125         if (sm != null) System.setSecurityManager(sm);
1126     }
1127 
1128     /**
1129      * Checks that thread eventually enters the expected blocked thread state.
1130      */
1131     void assertThreadBlocks(Thread thread, Thread.State expected) {
1132         // always sleep at least 1 ms, with high probability avoiding
1133         // transitory states
1134         for (long retries = LONG_DELAY_MS * 3 / 4; retries--&gt;0; ) {
1135             try { delay(1); }
1136             catch (InterruptedException fail) {
1137                 throw new AssertionError(&quot;Unexpected InterruptedException&quot;, fail);
1138             }
1139             Thread.State s = thread.getState();
1140             if (s == expected)
1141                 return;
1142             else if (s == Thread.State.TERMINATED)
1143                 fail(&quot;Unexpected thread termination&quot;);
1144         }
1145         fail(&quot;timed out waiting for thread to enter thread state &quot; + expected);
1146     }
1147 
1148     /**
1149      * Checks that future.get times out, with the default timeout of
1150      * {@code timeoutMillis()}.
1151      */
1152     void assertFutureTimesOut(Future future) {
1153         assertFutureTimesOut(future, timeoutMillis());
1154     }
1155 
1156     /**
1157      * Checks that future.get times out, with the given millisecond timeout.
1158      */
1159     void assertFutureTimesOut(Future future, long timeoutMillis) {
1160         long startTime = System.nanoTime();
1161         try {
1162             future.get(timeoutMillis, MILLISECONDS);
1163             shouldThrow();
1164         } catch (TimeoutException success) {
1165         } catch (Exception fail) {
1166             threadUnexpectedException(fail);
1167         } finally { future.cancel(true); }
1168         assertTrue(millisElapsedSince(startTime) &gt;= timeoutMillis);
1169     }
1170 
1171     /**
1172      * Fails with message &quot;should throw exception&quot;.
1173      */
1174     public void shouldThrow() {
1175         fail(&quot;Should throw exception&quot;);
1176     }
1177 
1178     /**
1179      * Fails with message &quot;should throw &quot; + exceptionName.
1180      */
1181     public void shouldThrow(String exceptionName) {
1182         fail(&quot;Should throw &quot; + exceptionName);
1183     }
1184 
1185     /**
1186      * The maximum number of consecutive spurious wakeups we should
1187      * tolerate (from APIs like LockSupport.park) before failing a test.
1188      */
1189     static final int MAX_SPURIOUS_WAKEUPS = 10;
1190 
1191     /**
1192      * The number of elements to place in collections, arrays, etc.
1193      */
1194     public static final int SIZE = 20;
1195 
1196     // Some convenient Integer constants
1197 
1198     public static final Integer zero  = new Integer(0);
1199     public static final Integer one   = new Integer(1);
1200     public static final Integer two   = new Integer(2);
1201     public static final Integer three = new Integer(3);
1202     public static final Integer four  = new Integer(4);
1203     public static final Integer five  = new Integer(5);
1204     public static final Integer six   = new Integer(6);
1205     public static final Integer seven = new Integer(7);
1206     public static final Integer eight = new Integer(8);
1207     public static final Integer nine  = new Integer(9);
1208     public static final Integer m1  = new Integer(-1);
1209     public static final Integer m2  = new Integer(-2);
1210     public static final Integer m3  = new Integer(-3);
1211     public static final Integer m4  = new Integer(-4);
1212     public static final Integer m5  = new Integer(-5);
1213     public static final Integer m6  = new Integer(-6);
1214     public static final Integer m10 = new Integer(-10);
1215 
1216     /**
1217      * Runs Runnable r with a security policy that permits precisely
1218      * the specified permissions.  If there is no current security
1219      * manager, the runnable is run twice, both with and without a
1220      * security manager.  We require that any security manager permit
1221      * getPolicy/setPolicy.
1222      */
1223     public void runWithPermissions(Runnable r, Permission... permissions) {
1224         SecurityManager sm = System.getSecurityManager();
1225         if (sm == null) {
1226             r.run();
1227         }
1228         runWithSecurityManagerWithPermissions(r, permissions);
1229     }
1230 
1231     /**
1232      * Runs Runnable r with a security policy that permits precisely
1233      * the specified permissions.  If there is no current security
1234      * manager, a temporary one is set for the duration of the
1235      * Runnable.  We require that any security manager permit
1236      * getPolicy/setPolicy.
1237      */
1238     public void runWithSecurityManagerWithPermissions(Runnable r,
1239                                                       Permission... permissions) {
1240         SecurityManager sm = System.getSecurityManager();
1241         if (sm == null) {
1242             Policy savedPolicy = Policy.getPolicy();
1243             try {
1244                 Policy.setPolicy(permissivePolicy());
1245                 System.setSecurityManager(new SecurityManager());
1246                 runWithSecurityManagerWithPermissions(r, permissions);
1247             } finally {
1248                 System.setSecurityManager(null);
1249                 Policy.setPolicy(savedPolicy);
1250             }
1251         } else {
1252             Policy savedPolicy = Policy.getPolicy();
1253             AdjustablePolicy policy = new AdjustablePolicy(permissions);
1254             Policy.setPolicy(policy);
1255 
1256             try {
1257                 r.run();
1258             } finally {
1259                 policy.addPermission(new SecurityPermission(&quot;setPolicy&quot;));
1260                 Policy.setPolicy(savedPolicy);
1261             }
1262         }
1263     }
1264 
1265     /**
1266      * Runs a runnable without any permissions.
1267      */
1268     public void runWithoutPermissions(Runnable r) {
1269         runWithPermissions(r);
1270     }
1271 
1272     /**
1273      * A security policy where new permissions can be dynamically added
1274      * or all cleared.
1275      */
1276     public static class AdjustablePolicy extends java.security.Policy {
1277         Permissions perms = new Permissions();
1278         AdjustablePolicy(Permission... permissions) {
1279             for (Permission permission : permissions)
1280                 perms.add(permission);
1281         }
1282         void addPermission(Permission perm) { perms.add(perm); }
1283         void clearPermissions() { perms = new Permissions(); }
1284         public PermissionCollection getPermissions(CodeSource cs) {
1285             return perms;
1286         }
1287         public PermissionCollection getPermissions(ProtectionDomain pd) {
1288             return perms;
1289         }
1290         public boolean implies(ProtectionDomain pd, Permission p) {
1291             return perms.implies(p);
1292         }
1293         public void refresh() {}
1294         public String toString() {
1295             List&lt;Permission&gt; ps = new ArrayList&lt;&gt;();
1296             for (Enumeration&lt;Permission&gt; e = perms.elements(); e.hasMoreElements();)
1297                 ps.add(e.nextElement());
1298             return &quot;AdjustablePolicy with permissions &quot; + ps;
1299         }
1300     }
1301 
1302     /**
1303      * Returns a policy containing all the permissions we ever need.
1304      */
1305     public static Policy permissivePolicy() {
1306         return new AdjustablePolicy
1307             // Permissions j.u.c. needs directly
1308             (new RuntimePermission(&quot;modifyThread&quot;),
1309              new RuntimePermission(&quot;getClassLoader&quot;),
1310              new RuntimePermission(&quot;setContextClassLoader&quot;),
1311              // Permissions needed to change permissions!
1312              new SecurityPermission(&quot;getPolicy&quot;),
1313              new SecurityPermission(&quot;setPolicy&quot;),
1314              new RuntimePermission(&quot;setSecurityManager&quot;),
1315              // Permissions needed by the junit test harness
1316              new RuntimePermission(&quot;accessDeclaredMembers&quot;),
1317              new PropertyPermission(&quot;*&quot;, &quot;read&quot;),
1318              new java.io.FilePermission(&quot;&lt;&lt;ALL FILES&gt;&gt;&quot;, &quot;read&quot;));
1319     }
1320 
1321     /**
1322      * Sleeps until the given time has elapsed.
1323      * Throws AssertionError if interrupted.
1324      */
1325     static void sleep(long millis) {
1326         try {
1327             delay(millis);
1328         } catch (InterruptedException fail) {
1329             throw new AssertionError(&quot;Unexpected InterruptedException&quot;, fail);
1330         }
1331     }
1332 
1333     /**
1334      * Spin-waits up to the specified number of milliseconds for the given
1335      * thread to enter a wait state: BLOCKED, WAITING, or TIMED_WAITING.
1336      * @param waitingForGodot if non-null, an additional condition to satisfy
1337      */
1338     void waitForThreadToEnterWaitState(Thread thread, long timeoutMillis,
1339                                        Callable&lt;Boolean&gt; waitingForGodot) {
1340         for (long startTime = 0L;;) {
1341             switch (thread.getState()) {
1342             default: break;
1343             case BLOCKED: case WAITING: case TIMED_WAITING:
1344                 try {
1345                     if (waitingForGodot == null || waitingForGodot.call())
1346                         return;
1347                 } catch (Throwable fail) { threadUnexpectedException(fail); }
1348                 break;
1349             case TERMINATED:
1350                 fail(&quot;Unexpected thread termination&quot;);
1351             }
1352 
1353             if (startTime == 0L)
1354                 startTime = System.nanoTime();
1355             else if (millisElapsedSince(startTime) &gt; timeoutMillis) {
1356                 assertTrue(thread.isAlive());
1357                 if (waitingForGodot == null
1358                     || thread.getState() == Thread.State.RUNNABLE)
1359                     fail(&quot;timed out waiting for thread to enter wait state&quot;);
1360                 else
1361                     fail(&quot;timed out waiting for condition, thread state=&quot;
1362                          + thread.getState());
1363             }
1364             Thread.yield();
1365         }
1366     }
1367 
1368     /**
1369      * Spin-waits up to the specified number of milliseconds for the given
1370      * thread to enter a wait state: BLOCKED, WAITING, or TIMED_WAITING.
1371      */
1372     void waitForThreadToEnterWaitState(Thread thread, long timeoutMillis) {
1373         waitForThreadToEnterWaitState(thread, timeoutMillis, null);
1374     }
1375 
1376     /**
1377      * Spin-waits up to LONG_DELAY_MS milliseconds for the given thread to
1378      * enter a wait state: BLOCKED, WAITING, or TIMED_WAITING.
1379      */
1380     void waitForThreadToEnterWaitState(Thread thread) {
1381         waitForThreadToEnterWaitState(thread, LONG_DELAY_MS, null);
1382     }
1383 
1384     /**
1385      * Spin-waits up to LONG_DELAY_MS milliseconds for the given thread to
1386      * enter a wait state: BLOCKED, WAITING, or TIMED_WAITING,
1387      * and additionally satisfy the given condition.
1388      */
1389     void waitForThreadToEnterWaitState(Thread thread,
1390                                        Callable&lt;Boolean&gt; waitingForGodot) {
1391         waitForThreadToEnterWaitState(thread, LONG_DELAY_MS, waitingForGodot);
1392     }
1393 
1394     /**
1395      * Returns the number of milliseconds since time given by
1396      * startNanoTime, which must have been previously returned from a
1397      * call to {@link System#nanoTime()}.
1398      */
1399     static long millisElapsedSince(long startNanoTime) {
1400         return NANOSECONDS.toMillis(System.nanoTime() - startNanoTime);
1401     }
1402 
1403 //     void assertTerminatesPromptly(long timeoutMillis, Runnable r) {
1404 //         long startTime = System.nanoTime();
1405 //         try {
1406 //             r.run();
1407 //         } catch (Throwable fail) { threadUnexpectedException(fail); }
1408 //         if (millisElapsedSince(startTime) &gt; timeoutMillis/2)
1409 //             throw new AssertionError(&quot;did not return promptly&quot;);
1410 //     }
1411 
1412 //     void assertTerminatesPromptly(Runnable r) {
1413 //         assertTerminatesPromptly(LONG_DELAY_MS/2, r);
1414 //     }
1415 
1416     /**
1417      * Checks that timed f.get() returns the expected value, and does not
1418      * wait for the timeout to elapse before returning.
1419      */
1420     &lt;T&gt; void checkTimedGet(Future&lt;T&gt; f, T expectedValue, long timeoutMillis) {
1421         long startTime = System.nanoTime();
1422         T actual = null;
1423         try {
1424             actual = f.get(timeoutMillis, MILLISECONDS);
1425         } catch (Throwable fail) { threadUnexpectedException(fail); }
1426         assertEquals(expectedValue, actual);
1427         if (millisElapsedSince(startTime) &gt; timeoutMillis/2)
1428             throw new AssertionError(&quot;timed get did not return promptly&quot;);
1429     }
1430 
1431     &lt;T&gt; void checkTimedGet(Future&lt;T&gt; f, T expectedValue) {
1432         checkTimedGet(f, expectedValue, LONG_DELAY_MS);
1433     }
1434 
1435     /**
1436      * Returns a new started daemon Thread running the given runnable.
1437      */
1438     Thread newStartedThread(Runnable runnable) {
1439         Thread t = new Thread(runnable);
1440         t.setDaemon(true);
1441         t.start();
1442         return t;
1443     }
1444 
1445     /**
1446      * Waits for the specified time (in milliseconds) for the thread
1447      * to terminate (using {@link Thread#join(long)}), else interrupts
1448      * the thread (in the hope that it may terminate later) and fails.
1449      */
1450     void awaitTermination(Thread t, long timeoutMillis) {
1451         try {
1452             t.join(timeoutMillis);
1453         } catch (InterruptedException fail) {
1454             threadUnexpectedException(fail);
1455         } finally {
1456             if (t.getState() != Thread.State.TERMINATED) {
1457                 t.interrupt();
1458                 threadFail(&quot;timed out waiting for thread to terminate&quot;);
1459             }
1460         }
1461     }
1462 
1463     /**
1464      * Waits for LONG_DELAY_MS milliseconds for the thread to
1465      * terminate (using {@link Thread#join(long)}), else interrupts
1466      * the thread (in the hope that it may terminate later) and fails.
1467      */
1468     void awaitTermination(Thread t) {
1469         awaitTermination(t, LONG_DELAY_MS);
1470     }
1471 
1472     // Some convenient Runnable classes
1473 
1474     public abstract class CheckedRunnable implements Runnable {
1475         protected abstract void realRun() throws Throwable;
1476 
1477         public final void run() {
1478             try {
1479                 realRun();
1480             } catch (Throwable fail) {
1481                 threadUnexpectedException(fail);
1482             }
1483         }
1484     }
1485 
1486     public abstract class ThreadShouldThrow extends Thread {
1487         protected abstract void realRun() throws Throwable;
1488 
1489         final Class&lt;?&gt; exceptionClass;
1490 
1491         &lt;T extends Throwable&gt; ThreadShouldThrow(Class&lt;T&gt; exceptionClass) {
1492             this.exceptionClass = exceptionClass;
1493         }
1494 
1495         public final void run() {
1496             try {
1497                 realRun();
1498             } catch (Throwable t) {
1499                 if (! exceptionClass.isInstance(t))
1500                     threadUnexpectedException(t);
1501                 return;
1502             }
1503             threadShouldThrow(exceptionClass.getSimpleName());
1504         }
1505     }
1506 
1507     public abstract class CheckedInterruptedRunnable implements Runnable {
1508         protected abstract void realRun() throws Throwable;
1509 
1510         public final void run() {
1511             try {
1512                 realRun();
1513             } catch (InterruptedException success) {
1514                 threadAssertFalse(Thread.interrupted());
1515                 return;
1516             } catch (Throwable fail) {
1517                 threadUnexpectedException(fail);
1518             }
1519             threadShouldThrow(&quot;InterruptedException&quot;);
1520         }
1521     }
1522 
1523     public abstract class CheckedCallable&lt;T&gt; implements Callable&lt;T&gt; {
1524         protected abstract T realCall() throws Throwable;
1525 
1526         public final T call() {
1527             try {
1528                 return realCall();
1529             } catch (Throwable fail) {
1530                 threadUnexpectedException(fail);
1531             }
1532             throw new AssertionError(&quot;unreached&quot;);
1533         }
1534     }
1535 
1536     public static class NoOpRunnable implements Runnable {
1537         public void run() {}
1538     }
1539 
1540     public static class NoOpCallable implements Callable {
1541         public Object call() { return Boolean.TRUE; }
1542     }
1543 
1544     public static final String TEST_STRING = &quot;a test string&quot;;
1545 
1546     public static class StringTask implements Callable&lt;String&gt; {
1547         final String value;
1548         public StringTask() { this(TEST_STRING); }
1549         public StringTask(String value) { this.value = value; }
1550         public String call() { return value; }
1551     }
1552 
1553     public Callable&lt;String&gt; latchAwaitingStringTask(final CountDownLatch latch) {
1554         return new CheckedCallable&lt;String&gt;() {
1555             protected String realCall() {
1556                 try {
1557                     latch.await();
1558                 } catch (InterruptedException quittingTime) {}
1559                 return TEST_STRING;
1560             }};
1561     }
1562 
1563     public Runnable countDowner(final CountDownLatch latch) {
1564         return new CheckedRunnable() {
1565             public void realRun() throws InterruptedException {
1566                 latch.countDown();
1567             }};
1568     }
1569 
1570     class LatchAwaiter extends CheckedRunnable {
1571         static final int NEW = 0;
1572         static final int RUNNING = 1;
1573         static final int DONE = 2;
1574         final CountDownLatch latch;
1575         int state = NEW;
1576         LatchAwaiter(CountDownLatch latch) { this.latch = latch; }
1577         public void realRun() throws InterruptedException {
1578             state = 1;
1579             await(latch);
1580             state = 2;
1581         }
1582     }
1583 
1584     public LatchAwaiter awaiter(CountDownLatch latch) {
1585         return new LatchAwaiter(latch);
1586     }
1587 
1588     public void await(CountDownLatch latch, long timeoutMillis) {
1589         boolean timedOut = false;
1590         try {
1591             timedOut = !latch.await(timeoutMillis, MILLISECONDS);
1592         } catch (Throwable fail) {
1593             threadUnexpectedException(fail);
1594         }
1595         if (timedOut)
1596             fail(&quot;timed out waiting for CountDownLatch for &quot;
1597                  + (timeoutMillis/1000) + &quot; sec&quot;);
1598     }
1599 
1600     public void await(CountDownLatch latch) {
1601         await(latch, LONG_DELAY_MS);
1602     }
1603 
1604     public void await(Semaphore semaphore) {
1605         boolean timedOut = false;
1606         try {
1607             timedOut = !semaphore.tryAcquire(LONG_DELAY_MS, MILLISECONDS);
1608         } catch (Throwable fail) {
1609             threadUnexpectedException(fail);
1610         }
1611         if (timedOut)
1612             fail(&quot;timed out waiting for Semaphore for &quot;
1613                  + (LONG_DELAY_MS/1000) + &quot; sec&quot;);
1614     }
1615 
1616     public void await(CyclicBarrier barrier) {
1617         try {
1618             barrier.await(LONG_DELAY_MS, MILLISECONDS);
1619         } catch (Throwable fail) {
1620             threadUnexpectedException(fail);
1621         }
1622     }
1623 
1624 //     /**
1625 //      * Spin-waits up to LONG_DELAY_MS until flag becomes true.
1626 //      */
1627 //     public void await(AtomicBoolean flag) {
1628 //         await(flag, LONG_DELAY_MS);
1629 //     }
1630 
1631 //     /**
1632 //      * Spin-waits up to the specified timeout until flag becomes true.
1633 //      */
1634 //     public void await(AtomicBoolean flag, long timeoutMillis) {
1635 //         long startTime = System.nanoTime();
1636 //         while (!flag.get()) {
1637 //             if (millisElapsedSince(startTime) &gt; timeoutMillis)
1638 //                 throw new AssertionError(&quot;timed out&quot;);
1639 //             Thread.yield();
1640 //         }
1641 //     }
1642 
1643     public static class NPETask implements Callable&lt;String&gt; {
1644         public String call() { throw new NullPointerException(); }
1645     }
1646 
1647     public Runnable possiblyInterruptedRunnable(final long timeoutMillis) {
1648         return new CheckedRunnable() {
1649             protected void realRun() {
1650                 try {
1651                     delay(timeoutMillis);
1652                 } catch (InterruptedException ok) {}
1653             }};
1654     }
1655 
1656     /**
1657      * For use as ThreadFactory in constructors
1658      */
1659     public static class SimpleThreadFactory implements ThreadFactory {
1660         public Thread newThread(Runnable r) {
1661             return new Thread(r);
1662         }
1663     }
1664 
1665     public interface TrackedRunnable extends Runnable {
1666         boolean isDone();
1667     }
1668 
1669     public static class TrackedNoOpRunnable implements Runnable {
1670         public volatile boolean done = false;
1671         public void run() {
1672             done = true;
1673         }
1674     }
1675 
1676     /**
1677      * Analog of CheckedRunnable for RecursiveAction
1678      */
1679     public abstract class CheckedRecursiveAction extends RecursiveAction {
1680         protected abstract void realCompute() throws Throwable;
1681 
1682         @Override protected final void compute() {
1683             try {
1684                 realCompute();
1685             } catch (Throwable fail) {
1686                 threadUnexpectedException(fail);
1687             }
1688         }
1689     }
1690 
1691     /**
1692      * Analog of CheckedCallable for RecursiveTask
1693      */
1694     public abstract class CheckedRecursiveTask&lt;T&gt; extends RecursiveTask&lt;T&gt; {
1695         protected abstract T realCompute() throws Throwable;
1696 
1697         @Override protected final T compute() {
1698             try {
1699                 return realCompute();
1700             } catch (Throwable fail) {
1701                 threadUnexpectedException(fail);
1702             }
1703             throw new AssertionError(&quot;unreached&quot;);
1704         }
1705     }
1706 
1707     /**
1708      * For use as RejectedExecutionHandler in constructors
1709      */
1710     public static class NoOpREHandler implements RejectedExecutionHandler {
1711         public void rejectedExecution(Runnable r,
1712                                       ThreadPoolExecutor executor) {}
1713     }
1714 
1715     /**
1716      * A CyclicBarrier that uses timed await and fails with
1717      * AssertionErrors instead of throwing checked exceptions.
1718      */
1719     public static class CheckedBarrier extends CyclicBarrier {
1720         public CheckedBarrier(int parties) { super(parties); }
1721 
1722         public int await() {
1723             try {
1724                 return super.await(2 * LONG_DELAY_MS, MILLISECONDS);
1725             } catch (TimeoutException timedOut) {
1726                 throw new AssertionError(&quot;timed out&quot;);
1727             } catch (Exception fail) {
1728                 throw new AssertionError(&quot;Unexpected exception: &quot; + fail, fail);
1729             }
1730         }
1731     }
1732 
1733     void checkEmpty(BlockingQueue q) {
1734         try {
1735             assertTrue(q.isEmpty());
1736             assertEquals(0, q.size());
1737             assertNull(q.peek());
1738             assertNull(q.poll());
1739             assertNull(q.poll(randomExpiredTimeout(), randomTimeUnit()));
1740             assertEquals(q.toString(), &quot;[]&quot;);
1741             assertTrue(Arrays.equals(q.toArray(), new Object[0]));
1742             assertFalse(q.iterator().hasNext());
1743             try {
1744                 q.element();
1745                 shouldThrow();
1746             } catch (NoSuchElementException success) {}
1747             try {
1748                 q.iterator().next();
1749                 shouldThrow();
1750             } catch (NoSuchElementException success) {}
1751             try {
1752                 q.remove();
1753                 shouldThrow();
1754             } catch (NoSuchElementException success) {}
1755         } catch (InterruptedException fail) { threadUnexpectedException(fail); }
1756     }
1757 
1758     void assertSerialEquals(Object x, Object y) {
1759         assertTrue(Arrays.equals(serialBytes(x), serialBytes(y)));
1760     }
1761 
1762     void assertNotSerialEquals(Object x, Object y) {
1763         assertFalse(Arrays.equals(serialBytes(x), serialBytes(y)));
1764     }
1765 
1766     byte[] serialBytes(Object o) {
1767         try {
1768             ByteArrayOutputStream bos = new ByteArrayOutputStream();
1769             ObjectOutputStream oos = new ObjectOutputStream(bos);
1770             oos.writeObject(o);
1771             oos.flush();
1772             oos.close();
1773             return bos.toByteArray();
1774         } catch (Throwable fail) {
1775             threadUnexpectedException(fail);
1776             return new byte[0];
1777         }
1778     }
1779 
1780     void assertImmutable(final Object o) {
1781         if (o instanceof Collection) {
1782             assertThrows(
1783                 UnsupportedOperationException.class,
1784                 new Runnable() { public void run() {
1785                         ((Collection) o).add(null);}});
1786         }
1787     }
1788 
1789     @SuppressWarnings(&quot;unchecked&quot;)
1790     &lt;T&gt; T serialClone(T o) {
1791         T clone = null;
1792         try {
1793             ObjectInputStream ois = new ObjectInputStream
1794                 (new ByteArrayInputStream(serialBytes(o)));
1795             clone = (T) ois.readObject();
1796         } catch (Throwable fail) {
1797             threadUnexpectedException(fail);
1798         }
1799         if (o == clone) assertImmutable(o);
1800         else assertSame(o.getClass(), clone.getClass());
1801         return clone;
1802     }
1803 
1804     /**
1805      * A version of serialClone that leaves error handling (for
1806      * e.g. NotSerializableException) up to the caller.
1807      */
1808     @SuppressWarnings(&quot;unchecked&quot;)
1809     &lt;T&gt; T serialClonePossiblyFailing(T o)
1810         throws ReflectiveOperationException, java.io.IOException {
1811         ByteArrayOutputStream bos = new ByteArrayOutputStream();
1812         ObjectOutputStream oos = new ObjectOutputStream(bos);
1813         oos.writeObject(o);
1814         oos.flush();
1815         oos.close();
1816         ObjectInputStream ois = new ObjectInputStream
1817             (new ByteArrayInputStream(bos.toByteArray()));
1818         T clone = (T) ois.readObject();
1819         if (o == clone) assertImmutable(o);
1820         else assertSame(o.getClass(), clone.getClass());
1821         return clone;
1822     }
1823 
1824     /**
1825      * If o implements Cloneable and has a public clone method,
1826      * returns a clone of o, else null.
1827      */
1828     @SuppressWarnings(&quot;unchecked&quot;)
1829     &lt;T&gt; T cloneableClone(T o) {
1830         if (!(o instanceof Cloneable)) return null;
1831         final T clone;
1832         try {
1833             clone = (T) o.getClass().getMethod(&quot;clone&quot;).invoke(o);
1834         } catch (NoSuchMethodException ok) {
1835             return null;
1836         } catch (ReflectiveOperationException unexpected) {
1837             throw new Error(unexpected);
1838         }
1839         assertNotSame(o, clone); // not 100% guaranteed by spec
1840         assertSame(o.getClass(), clone.getClass());
1841         return clone;
1842     }
1843 
1844     public void assertThrows(Class&lt;? extends Throwable&gt; expectedExceptionClass,
1845                              Runnable... throwingActions) {
1846         for (Runnable throwingAction : throwingActions) {
1847             boolean threw = false;
1848             try { throwingAction.run(); }
1849             catch (Throwable t) {
1850                 threw = true;
1851                 if (!expectedExceptionClass.isInstance(t))
1852                     throw new AssertionError(
1853                             &quot;Expected &quot; + expectedExceptionClass.getName() +
1854                             &quot;, got &quot; + t.getClass().getName(),
1855                             t);
1856             }
1857             if (!threw)
1858                 shouldThrow(expectedExceptionClass.getName());
1859         }
1860     }
1861 
1862     public void assertIteratorExhausted(Iterator&lt;?&gt; it) {
1863         try {
1864             it.next();
1865             shouldThrow();
1866         } catch (NoSuchElementException success) {}
1867         assertFalse(it.hasNext());
1868     }
1869 
1870     public &lt;T&gt; Callable&lt;T&gt; callableThrowing(final Exception ex) {
1871         return new Callable&lt;T&gt;() { public T call() throws Exception { throw ex; }};
1872     }
1873 
1874     public Runnable runnableThrowing(final RuntimeException ex) {
1875         return new Runnable() { public void run() { throw ex; }};
1876     }
1877 
1878     /** A reusable thread pool to be shared by tests. */
1879     static final ExecutorService cachedThreadPool =
1880         new ThreadPoolExecutor(0, Integer.MAX_VALUE,
1881                                1000L, MILLISECONDS,
1882                                new SynchronousQueue&lt;Runnable&gt;());
1883 
1884     static &lt;T&gt; void shuffle(T[] array) {
1885         Collections.shuffle(Arrays.asList(array), ThreadLocalRandom.current());
1886     }
1887 
1888     /**
1889      * Returns the same String as would be returned by {@link
1890      * Object#toString}, whether or not the given object&#39;s class
1891      * overrides toString().
1892      *
1893      * @see System#identityHashCode
1894      */
1895     static String identityString(Object x) {
1896         return x.getClass().getName()
1897             + &quot;@&quot; + Integer.toHexString(System.identityHashCode(x));
1898     }
1899 
1900     // --- Shared assertions for Executor tests ---
1901 
1902     /**
1903      * Returns maximum number of tasks that can be submitted to given
1904      * pool (with bounded queue) before saturation (when submission
1905      * throws RejectedExecutionException).
1906      */
1907     static final int saturatedSize(ThreadPoolExecutor pool) {
1908         BlockingQueue&lt;Runnable&gt; q = pool.getQueue();
1909         return pool.getMaximumPoolSize() + q.size() + q.remainingCapacity();
1910     }
1911 
1912     @SuppressWarnings(&quot;FutureReturnValueIgnored&quot;)
1913     void assertNullTaskSubmissionThrowsNullPointerException(Executor e) {
1914         try {
1915             e.execute((Runnable) null);
1916             shouldThrow();
1917         } catch (NullPointerException success) {}
1918 
1919         if (! (e instanceof ExecutorService)) return;
1920         ExecutorService es = (ExecutorService) e;
1921         try {
1922             es.submit((Runnable) null);
1923             shouldThrow();
1924         } catch (NullPointerException success) {}
1925         try {
1926             es.submit((Runnable) null, Boolean.TRUE);
1927             shouldThrow();
1928         } catch (NullPointerException success) {}
1929         try {
1930             es.submit((Callable) null);
1931             shouldThrow();
1932         } catch (NullPointerException success) {}
1933 
1934         if (! (e instanceof ScheduledExecutorService)) return;
1935         ScheduledExecutorService ses = (ScheduledExecutorService) e;
1936         try {
1937             ses.schedule((Runnable) null,
1938                          randomTimeout(), randomTimeUnit());
1939             shouldThrow();
1940         } catch (NullPointerException success) {}
1941         try {
1942             ses.schedule((Callable) null,
1943                          randomTimeout(), randomTimeUnit());
1944             shouldThrow();
1945         } catch (NullPointerException success) {}
1946         try {
1947             ses.scheduleAtFixedRate((Runnable) null,
1948                                     randomTimeout(), LONG_DELAY_MS, MILLISECONDS);
1949             shouldThrow();
1950         } catch (NullPointerException success) {}
1951         try {
1952             ses.scheduleWithFixedDelay((Runnable) null,
1953                                        randomTimeout(), LONG_DELAY_MS, MILLISECONDS);
1954             shouldThrow();
1955         } catch (NullPointerException success) {}
1956     }
1957 
1958     void setRejectedExecutionHandler(
1959         ThreadPoolExecutor p, RejectedExecutionHandler handler) {
1960         p.setRejectedExecutionHandler(handler);
1961         assertSame(handler, p.getRejectedExecutionHandler());
1962     }
1963 
1964     void assertTaskSubmissionsAreRejected(ThreadPoolExecutor p) {
1965         final RejectedExecutionHandler savedHandler = p.getRejectedExecutionHandler();
1966         final long savedTaskCount = p.getTaskCount();
1967         final long savedCompletedTaskCount = p.getCompletedTaskCount();
1968         final int savedQueueSize = p.getQueue().size();
1969         final boolean stock = (p.getClass().getClassLoader() == null);
1970 
1971         Runnable r = () -&gt; {};
1972         Callable&lt;Boolean&gt; c = () -&gt; Boolean.TRUE;
1973 
1974         class Recorder implements RejectedExecutionHandler {
1975             public volatile Runnable r = null;
1976             public volatile ThreadPoolExecutor p = null;
1977             public void reset() { r = null; p = null; }
1978             public void rejectedExecution(Runnable r, ThreadPoolExecutor p) {
1979                 assertNull(this.r);
1980                 assertNull(this.p);
1981                 this.r = r;
1982                 this.p = p;
1983             }
1984         }
1985 
1986         // check custom handler is invoked exactly once per task
1987         Recorder recorder = new Recorder();
1988         setRejectedExecutionHandler(p, recorder);
1989         for (int i = 2; i--&gt; 0; ) {
1990             recorder.reset();
1991             p.execute(r);
1992             if (stock &amp;&amp; p.getClass() == ThreadPoolExecutor.class)
1993                 assertSame(r, recorder.r);
1994             assertSame(p, recorder.p);
1995 
1996             recorder.reset();
1997             assertFalse(p.submit(r).isDone());
1998             if (stock) assertTrue(!((FutureTask) recorder.r).isDone());
1999             assertSame(p, recorder.p);
2000 
2001             recorder.reset();
2002             assertFalse(p.submit(r, Boolean.TRUE).isDone());
2003             if (stock) assertTrue(!((FutureTask) recorder.r).isDone());
2004             assertSame(p, recorder.p);
2005 
2006             recorder.reset();
2007             assertFalse(p.submit(c).isDone());
2008             if (stock) assertTrue(!((FutureTask) recorder.r).isDone());
2009             assertSame(p, recorder.p);
2010 
2011             if (p instanceof ScheduledExecutorService) {
2012                 ScheduledExecutorService s = (ScheduledExecutorService) p;
2013                 ScheduledFuture&lt;?&gt; future;
2014 
2015                 recorder.reset();
2016                 future = s.schedule(r, randomTimeout(), randomTimeUnit());
2017                 assertFalse(future.isDone());
2018                 if (stock) assertTrue(!((FutureTask) recorder.r).isDone());
2019                 assertSame(p, recorder.p);
2020 
2021                 recorder.reset();
2022                 future = s.schedule(c, randomTimeout(), randomTimeUnit());
2023                 assertFalse(future.isDone());
2024                 if (stock) assertTrue(!((FutureTask) recorder.r).isDone());
2025                 assertSame(p, recorder.p);
2026 
2027                 recorder.reset();
2028                 future = s.scheduleAtFixedRate(r, randomTimeout(), LONG_DELAY_MS, MILLISECONDS);
2029                 assertFalse(future.isDone());
2030                 if (stock) assertTrue(!((FutureTask) recorder.r).isDone());
2031                 assertSame(p, recorder.p);
2032 
2033                 recorder.reset();
2034                 future = s.scheduleWithFixedDelay(r, randomTimeout(), LONG_DELAY_MS, MILLISECONDS);
2035                 assertFalse(future.isDone());
2036                 if (stock) assertTrue(!((FutureTask) recorder.r).isDone());
2037                 assertSame(p, recorder.p);
2038             }
2039         }
2040 
2041         // Checking our custom handler above should be sufficient, but
2042         // we add some integration tests of standard handlers.
2043         final AtomicReference&lt;Thread&gt; thread = new AtomicReference&lt;&gt;();
2044         final Runnable setThread = () -&gt; thread.set(Thread.currentThread());
2045 
2046         setRejectedExecutionHandler(p, new ThreadPoolExecutor.AbortPolicy());
2047         try {
2048             p.execute(setThread);
2049             shouldThrow();
2050         } catch (RejectedExecutionException success) {}
2051         assertNull(thread.get());
2052 
2053         setRejectedExecutionHandler(p, new ThreadPoolExecutor.DiscardPolicy());
2054         p.execute(setThread);
2055         assertNull(thread.get());
2056 
2057         setRejectedExecutionHandler(p, new ThreadPoolExecutor.CallerRunsPolicy());
2058         p.execute(setThread);
2059         if (p.isShutdown())
2060             assertNull(thread.get());
2061         else
2062             assertSame(Thread.currentThread(), thread.get());
2063 
2064         setRejectedExecutionHandler(p, savedHandler);
2065 
2066         // check that pool was not perturbed by handlers
2067         assertEquals(savedTaskCount, p.getTaskCount());
2068         assertEquals(savedCompletedTaskCount, p.getCompletedTaskCount());
2069         assertEquals(savedQueueSize, p.getQueue().size());
2070     }
2071 
2072     void assertCollectionsEquals(Collection&lt;?&gt; x, Collection&lt;?&gt; y) {
2073         assertEquals(x, y);
2074         assertEquals(y, x);
2075         assertEquals(x.isEmpty(), y.isEmpty());
2076         assertEquals(x.size(), y.size());
2077         if (x instanceof List) {
2078             assertEquals(x.toString(), y.toString());
2079         }
2080         if (x instanceof List || x instanceof Set) {
2081             assertEquals(x.hashCode(), y.hashCode());
2082         }
2083         if (x instanceof List || x instanceof Deque) {
2084             assertTrue(Arrays.equals(x.toArray(), y.toArray()));
2085             assertTrue(Arrays.equals(x.toArray(new Object[0]),
2086                                      y.toArray(new Object[0])));
2087         }
2088     }
2089 
2090     /**
2091      * A weaker form of assertCollectionsEquals which does not insist
2092      * that the two collections satisfy Object#equals(Object), since
2093      * they may use identity semantics as Deques do.
2094      */
2095     void assertCollectionsEquivalent(Collection&lt;?&gt; x, Collection&lt;?&gt; y) {
2096         if (x instanceof List || x instanceof Set)
2097             assertCollectionsEquals(x, y);
2098         else {
2099             assertEquals(x.isEmpty(), y.isEmpty());
2100             assertEquals(x.size(), y.size());
2101             assertEquals(new HashSet(x), new HashSet(y));
2102             if (x instanceof Deque) {
2103                 assertTrue(Arrays.equals(x.toArray(), y.toArray()));
2104                 assertTrue(Arrays.equals(x.toArray(new Object[0]),
2105                                          y.toArray(new Object[0])));
2106             }
2107         }
2108     }
2109 }
    </pre>
  </body>
</html>
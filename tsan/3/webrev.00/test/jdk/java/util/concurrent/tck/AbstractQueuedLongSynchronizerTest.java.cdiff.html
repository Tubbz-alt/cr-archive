<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff test/jdk/java/util/concurrent/tck/AbstractQueuedLongSynchronizerTest.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
<body>
<center><a href="../locks/ReentrantReadWriteLock/MapLoops.java.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="AbstractQueuedSynchronizerTest.java.cdiff.html" target="_top">next &gt;</a></center>    <h2>test/jdk/java/util/concurrent/tck/AbstractQueuedLongSynchronizerTest.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 37,11 ***</span>
  import static java.util.concurrent.TimeUnit.NANOSECONDS;
  
  import java.util.Arrays;
  import java.util.Collection;
  import java.util.HashSet;
<span class="line-modified">! import java.util.concurrent.ThreadLocalRandom;</span>
  import java.util.concurrent.locks.AbstractQueuedLongSynchronizer;
  import java.util.concurrent.locks.AbstractQueuedLongSynchronizer.ConditionObject;
  
  import junit.framework.Test;
  import junit.framework.TestSuite;
<span class="line-new-header">--- 37,11 ---</span>
  import static java.util.concurrent.TimeUnit.NANOSECONDS;
  
  import java.util.Arrays;
  import java.util.Collection;
  import java.util.HashSet;
<span class="line-modified">! import java.util.concurrent.atomic.AtomicBoolean;</span>
  import java.util.concurrent.locks.AbstractQueuedLongSynchronizer;
  import java.util.concurrent.locks.AbstractQueuedLongSynchronizer.ConditionObject;
  
  import junit.framework.Test;
  import junit.framework.TestSuite;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1284,23 ***</span>
      }
  
      /**
       * Tests scenario for
       * JDK-8191937: Lost interrupt in AbstractQueuedSynchronizer when tryAcquire methods throw
       */
<span class="line-modified">!     public void testInterruptedFailingAcquire() throws InterruptedException {</span>
<span class="line-modified">!         final RuntimeException ex = new RuntimeException();</span>
  
          // A synchronizer only offering a choice of failure modes
          class Sync extends AbstractQueuedLongSynchronizer {
<span class="line-modified">!             boolean pleaseThrow;</span>
              @Override protected boolean tryAcquire(long ignored) {
<span class="line-modified">!                 if (pleaseThrow) throw ex;</span>
                  return false;
              }
              @Override protected long tryAcquireShared(long ignored) {
<span class="line-modified">!                 if (pleaseThrow) throw ex;</span>
                  return -1;
              }
              @Override protected boolean tryRelease(long ignored) {
                  return true;
              }
<span class="line-new-header">--- 1284,35 ---</span>
      }
  
      /**
       * Tests scenario for
       * JDK-8191937: Lost interrupt in AbstractQueuedSynchronizer when tryAcquire methods throw
<span class="line-added">+      * ant -Djsr166.tckTestClass=AbstractQueuedLongSynchronizerTest -Djsr166.methodFilter=testInterruptedFailingAcquire -Djsr166.runsPerTest=10000 tck</span>
       */
<span class="line-modified">!     public void testInterruptedFailingAcquire() throws Throwable {</span>
<span class="line-modified">!         class PleaseThrow extends RuntimeException {}</span>
<span class="line-added">+         final PleaseThrow ex = new PleaseThrow();</span>
<span class="line-added">+         final AtomicBoolean thrown = new AtomicBoolean();</span>
  
          // A synchronizer only offering a choice of failure modes
          class Sync extends AbstractQueuedLongSynchronizer {
<span class="line-modified">!             volatile boolean pleaseThrow;</span>
<span class="line-added">+             void maybeThrow() {</span>
<span class="line-added">+                 if (pleaseThrow) {</span>
<span class="line-added">+                     // assert: tryAcquire methods can throw at most once</span>
<span class="line-added">+                     if (! thrown.compareAndSet(false, true))</span>
<span class="line-added">+                         throw new AssertionError();</span>
<span class="line-added">+                     throw ex;</span>
<span class="line-added">+                 }</span>
<span class="line-added">+             }</span>
<span class="line-added">+ </span>
              @Override protected boolean tryAcquire(long ignored) {
<span class="line-modified">!                 maybeThrow();</span>
                  return false;
              }
              @Override protected long tryAcquireShared(long ignored) {
<span class="line-modified">!                 maybeThrow();</span>
                  return -1;
              }
              @Override protected boolean tryRelease(long ignored) {
                  return true;
              }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1308,32 ***</span>
                  return true;
              }
          }
  
          final Sync s = new Sync();
<span class="line-modified">! </span>
          final Thread thread = newStartedThread(new CheckedRunnable() {
<span class="line-modified">!             public void realRun() {</span>
                  try {
<span class="line-modified">!                     if (ThreadLocalRandom.current().nextBoolean())</span>
<span class="line-removed">-                         s.acquire(1);</span>
<span class="line-removed">-                     else</span>
<span class="line-removed">-                         s.acquireShared(1);</span>
                      shouldThrow();
<span class="line-modified">!                 } catch (Throwable t) {</span>
<span class="line-modified">!                     assertSame(ex, t);</span>
<span class="line-modified">!                     assertTrue(Thread.interrupted());</span>
                  }
              }});
<span class="line-modified">!         waitForThreadToEnterWaitState(thread);</span>
<span class="line-modified">!         assertSame(thread, s.getFirstQueuedThread());</span>
<span class="line-modified">!         assertTrue(s.hasQueuedPredecessors());</span>
<span class="line-modified">!         assertTrue(s.hasQueuedThreads());</span>
<span class="line-modified">!         assertEquals(1, s.getQueueLength());</span>
  
          s.pleaseThrow = true;
<span class="line-modified">!         thread.interrupt();</span>
<span class="line-modified">!         s.release(1);</span>
          awaitTermination(thread);
      }
  
  }
<span class="line-new-header">--- 1320,89 ---</span>
                  return true;
              }
          }
  
          final Sync s = new Sync();
<span class="line-modified">!         final boolean acquireInterruptibly = randomBoolean();</span>
<span class="line-added">+         final Action[] uninterruptibleAcquireActions = {</span>
<span class="line-added">+             () -&gt; s.acquire(1),</span>
<span class="line-added">+             () -&gt; s.acquireShared(1),</span>
<span class="line-added">+         };</span>
<span class="line-added">+         final long nanosTimeout = MILLISECONDS.toNanos(2 * LONG_DELAY_MS);</span>
<span class="line-added">+         final Action[] interruptibleAcquireActions = {</span>
<span class="line-added">+             () -&gt; s.acquireInterruptibly(1),</span>
<span class="line-added">+             () -&gt; s.acquireSharedInterruptibly(1),</span>
<span class="line-added">+             () -&gt; s.tryAcquireNanos(1, nanosTimeout),</span>
<span class="line-added">+             () -&gt; s.tryAcquireSharedNanos(1, nanosTimeout),</span>
<span class="line-added">+         };</span>
<span class="line-added">+         final Action[] releaseActions = {</span>
<span class="line-added">+             () -&gt; s.release(1),</span>
<span class="line-added">+             () -&gt; s.releaseShared(1),</span>
<span class="line-added">+         };</span>
<span class="line-added">+         final Action acquireAction = acquireInterruptibly</span>
<span class="line-added">+             ? chooseRandomly(interruptibleAcquireActions)</span>
<span class="line-added">+             : chooseRandomly(uninterruptibleAcquireActions);</span>
<span class="line-added">+         final Action releaseAction</span>
<span class="line-added">+             = chooseRandomly(releaseActions);</span>
<span class="line-added">+ </span>
<span class="line-added">+         // From os_posix.cpp:</span>
<span class="line-added">+         //</span>
<span class="line-added">+         // NOTE that since there is no &quot;lock&quot; around the interrupt and</span>
<span class="line-added">+         // is_interrupted operations, there is the possibility that the</span>
<span class="line-added">+         // interrupted flag (in osThread) will be &quot;false&quot; but that the</span>
<span class="line-added">+         // low-level events will be in the signaled state. This is</span>
<span class="line-added">+         // intentional. The effect of this is that Object.wait() and</span>
<span class="line-added">+         // LockSupport.park() will appear to have a spurious wakeup, which</span>
<span class="line-added">+         // is allowed and not harmful, and the possibility is so rare that</span>
<span class="line-added">+         // it is not worth the added complexity to add yet another lock.</span>
          final Thread thread = newStartedThread(new CheckedRunnable() {
<span class="line-modified">!             public void realRun() throws Throwable {</span>
                  try {
<span class="line-modified">!                     acquireAction.run();</span>
                      shouldThrow();
<span class="line-modified">!                 } catch (InterruptedException possible) {</span>
<span class="line-modified">!                     assertTrue(acquireInterruptibly);</span>
<span class="line-modified">!                     assertFalse(Thread.interrupted());</span>
<span class="line-added">+                 } catch (PleaseThrow possible) {</span>
<span class="line-added">+                     awaitInterrupted();</span>
                  }
              }});
<span class="line-modified">!         for (long startTime = 0L;; ) {</span>
<span class="line-modified">!             waitForThreadToEnterWaitState(thread);</span>
<span class="line-modified">!             if (s.getFirstQueuedThread() == thread</span>
<span class="line-modified">!                 &amp;&amp; s.hasQueuedPredecessors()</span>
<span class="line-modified">!                 &amp;&amp; s.hasQueuedThreads()</span>
<span class="line-added">+                 &amp;&amp; s.getQueueLength() == 1</span>
<span class="line-added">+                 &amp;&amp; s.hasContended())</span>
<span class="line-added">+                 break;</span>
<span class="line-added">+             if (startTime == 0L)</span>
<span class="line-added">+                 startTime = System.nanoTime();</span>
<span class="line-added">+             else if (millisElapsedSince(startTime) &gt; LONG_DELAY_MS)</span>
<span class="line-added">+                 fail(&quot;timed out waiting for AQS state: &quot;</span>
<span class="line-added">+                      + &quot;thread state=&quot; + thread.getState()</span>
<span class="line-added">+                      + &quot;, queued threads=&quot; + s.getQueuedThreads());</span>
<span class="line-added">+             Thread.yield();</span>
<span class="line-added">+         }</span>
  
          s.pleaseThrow = true;
<span class="line-modified">!         // release and interrupt, in random order</span>
<span class="line-modified">!         if (randomBoolean()) {</span>
<span class="line-added">+             thread.interrupt();</span>
<span class="line-added">+             releaseAction.run();</span>
<span class="line-added">+         } else {</span>
<span class="line-added">+             releaseAction.run();</span>
<span class="line-added">+             thread.interrupt();</span>
<span class="line-added">+         }</span>
          awaitTermination(thread);
<span class="line-added">+ </span>
<span class="line-added">+         if (! acquireInterruptibly)</span>
<span class="line-added">+             assertTrue(thrown.get());</span>
<span class="line-added">+ </span>
<span class="line-added">+         assertNull(s.getFirstQueuedThread());</span>
<span class="line-added">+         assertFalse(s.hasQueuedPredecessors());</span>
<span class="line-added">+         assertFalse(s.hasQueuedThreads());</span>
<span class="line-added">+         assertEquals(0, s.getQueueLength());</span>
<span class="line-added">+         assertTrue(s.getQueuedThreads().isEmpty());</span>
<span class="line-added">+         assertTrue(s.hasContended());</span>
      }
  
  }
</pre>
<center><a href="../locks/ReentrantReadWriteLock/MapLoops.java.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="AbstractQueuedSynchronizerTest.java.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
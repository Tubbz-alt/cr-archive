<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff test/jdk/java/util/concurrent/tck/JSR166TestCase.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
<body>
<center><a href="HashMapTest.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="LinkedBlockingDequeTest.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>test/jdk/java/util/concurrent/tck/JSR166TestCase.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  59  *      -Djsr166.testImplementationDetails=true
  60  *      -Djava.util.concurrent.ForkJoinPool.common.parallelism=1
  61  *      -Djava.util.secureRandomSeed=true
  62  *      JSR166TestCase
  63  * @run junit/othervm/timeout=1000/policy=tck.policy
  64  *      --add-opens java.base/java.util.concurrent=ALL-UNNAMED
  65  *      --add-opens java.base/java.lang=ALL-UNNAMED
  66  *      -Djsr166.testImplementationDetails=true
  67  *      JSR166TestCase
  68  */
  69 
  70 import static java.util.concurrent.TimeUnit.MILLISECONDS;
  71 import static java.util.concurrent.TimeUnit.MINUTES;
  72 import static java.util.concurrent.TimeUnit.NANOSECONDS;
  73 
  74 import java.io.ByteArrayInputStream;
  75 import java.io.ByteArrayOutputStream;
  76 import java.io.ObjectInputStream;
  77 import java.io.ObjectOutputStream;
  78 import java.lang.management.ManagementFactory;

  79 import java.lang.management.ThreadInfo;
  80 import java.lang.management.ThreadMXBean;
  81 import java.lang.reflect.Constructor;
  82 import java.lang.reflect.Method;
  83 import java.lang.reflect.Modifier;
  84 import java.security.CodeSource;
  85 import java.security.Permission;
  86 import java.security.PermissionCollection;
  87 import java.security.Permissions;
  88 import java.security.Policy;
  89 import java.security.ProtectionDomain;
  90 import java.security.SecurityPermission;
  91 import java.util.ArrayList;
  92 import java.util.Arrays;
  93 import java.util.Collection;
  94 import java.util.Collections;
  95 import java.util.Date;
  96 import java.util.Deque;
  97 import java.util.Enumeration;
  98 import java.util.HashSet;
</pre>
<hr />
<pre>
 253      */
 254     private static final int suiteRuns =
 255         Integer.getInteger(&quot;jsr166.suiteRuns&quot;, 1);
 256 
 257     /**
 258      * Returns the value of the system property, or NaN if not defined.
 259      */
 260     private static float systemPropertyValue(String name) {
 261         String floatString = System.getProperty(name);
 262         if (floatString == null)
 263             return Float.NaN;
 264         try {
 265             return Float.parseFloat(floatString);
 266         } catch (NumberFormatException ex) {
 267             throw new IllegalArgumentException(
 268                 String.format(&quot;Bad float value in system property %s=%s&quot;,
 269                               name, floatString));
 270         }
 271     }
 272 



 273     /**
 274      * The scaling factor to apply to standard delays used in tests.
 275      * May be initialized from any of:
 276      * - the &quot;jsr166.delay.factor&quot; system property
 277      * - the &quot;test.timeout.factor&quot; system property (as used by jtreg)
 278      *   See: http://openjdk.java.net/jtreg/tag-spec.html
 279      * - hard-coded fuzz factor when using a known slowpoke VM
 280      */
 281     private static final float delayFactor = delayFactor();
 282 
 283     private static float delayFactor() {
 284         float x;
 285         if (!Float.isNaN(x = systemPropertyValue(&quot;jsr166.delay.factor&quot;)))
 286             return x;
 287         if (!Float.isNaN(x = systemPropertyValue(&quot;test.timeout.factor&quot;)))
 288             return x;
 289         String prop = System.getProperty(&quot;java.vm.version&quot;);
 290         if (prop != null &amp;&amp; prop.matches(&quot;.*debug.*&quot;))
 291             return 4.0f; // How much slower is fastdebug than product?!
 292         return 1.0f;
</pre>
<hr />
<pre>
 294 
 295     public JSR166TestCase() { super(); }
 296     public JSR166TestCase(String name) { super(name); }
 297 
 298     /**
 299      * A filter for tests to run, matching strings of the form
 300      * methodName(className), e.g. &quot;testInvokeAll5(ForkJoinPoolTest)&quot;
 301      * Usefully combined with jsr166.runsPerTest.
 302      */
 303     private static final Pattern methodFilter = methodFilter();
 304 
 305     private static Pattern methodFilter() {
 306         String regex = System.getProperty(&quot;jsr166.methodFilter&quot;);
 307         return (regex == null) ? null : Pattern.compile(regex);
 308     }
 309 
 310     // Instrumentation to debug very rare, but very annoying hung test runs.
 311     static volatile TestCase currentTestCase;
 312     // static volatile int currentRun = 0;
 313     static {
<span class="line-modified"> 314         Runnable checkForWedgedTest = new Runnable() { public void run() {</span>
 315             // Avoid spurious reports with enormous runsPerTest.
 316             // A single test case run should never take more than 1 second.
 317             // But let&#39;s cap it at the high end too ...
<span class="line-modified"> 318             final int timeoutMinutes =</span>
<span class="line-modified"> 319                 Math.min(15, Math.max(runsPerTest / 60, 1));</span>

 320             for (TestCase lastTestCase = currentTestCase;;) {
 321                 try { MINUTES.sleep(timeoutMinutes); }
 322                 catch (InterruptedException unexpected) { break; }
 323                 if (lastTestCase == currentTestCase) {
 324                     System.err.printf(
 325                         &quot;Looks like we&#39;re stuck running test: %s%n&quot;,
 326                         lastTestCase);
 327 //                     System.err.printf(
 328 //                         &quot;Looks like we&#39;re stuck running test: %s (%d/%d)%n&quot;,
 329 //                         lastTestCase, currentRun, runsPerTest);
 330 //                     System.err.println(&quot;availableProcessors=&quot; +
 331 //                         Runtime.getRuntime().availableProcessors());
 332 //                     System.err.printf(&quot;cpu model = %s%n&quot;, cpuModel());
 333                     dumpTestThreads();
 334                     // one stack dump is probably enough; more would be spam
 335                     break;
 336                 }
 337                 lastTestCase = currentTestCase;
 338             }}};
<span class="line-modified"> 339         Thread thread = new Thread(checkForWedgedTest, &quot;checkForWedgedTest&quot;);</span>
 340         thread.setDaemon(true);
 341         thread.start();
 342     }
 343 
 344 //     public static String cpuModel() {
 345 //         try {
 346 //             java.util.regex.Matcher matcher
 347 //               = Pattern.compile(&quot;model name\\s*: (.*)&quot;)
 348 //                 .matcher(new String(
 349 //                     java.nio.file.Files.readAllBytes(
 350 //                         java.nio.file.Paths.get(&quot;/proc/cpuinfo&quot;)), &quot;UTF-8&quot;));
 351 //             matcher.find();
 352 //             return matcher.group(1);
 353 //         } catch (Exception ex) { return null; }
 354 //     }
 355 
 356     public void runBare() throws Throwable {
 357         currentTestCase = this;
 358         if (methodFilter == null
 359             || methodFilter.matcher(toString()).find())
</pre>
<hr />
<pre>
 363     protected void runTest() throws Throwable {
 364         for (int i = 0; i &lt; runsPerTest; i++) {
 365             // currentRun = i;
 366             if (profileTests)
 367                 runTestProfiled();
 368             else
 369                 super.runTest();
 370         }
 371     }
 372 
 373     protected void runTestProfiled() throws Throwable {
 374         for (int i = 0; i &lt; 2; i++) {
 375             long startTime = System.nanoTime();
 376             super.runTest();
 377             long elapsedMillis = millisElapsedSince(startTime);
 378             if (elapsedMillis &lt; profileThreshold)
 379                 break;
 380             // Never report first run of any test; treat it as a
 381             // warmup run, notably to trigger all needed classloading,
 382             if (i &gt; 0)
<span class="line-modified"> 383                 System.out.printf(&quot;%n%s: %d%n&quot;, toString(), elapsedMillis);</span>
 384         }
 385     }
 386 
 387     /**
 388      * Runs all JSR166 unit tests using junit.textui.TestRunner.
 389      */
 390     public static void main(String[] args) {
 391         main(suite(), args);
 392     }
 393 
 394     static class PithyResultPrinter extends junit.textui.ResultPrinter {
 395         PithyResultPrinter(java.io.PrintStream writer) { super(writer); }
 396         long runTime;
 397         public void startTest(Test test) {}
 398         protected void printHeader(long runTime) {
 399             this.runTime = runTime; // defer printing for later
 400         }
 401         protected void printFooter(TestResult result) {
 402             if (result.wasSuccessful()) {
 403                 getWriter().println(&quot;OK (&quot; + result.runCount() + &quot; tests)&quot;
</pre>
<hr />
<pre>
 527             AtomicReferenceTest.suite(),
 528             AtomicStampedReferenceTest.suite(),
 529             ConcurrentHashMapTest.suite(),
 530             ConcurrentLinkedDequeTest.suite(),
 531             ConcurrentLinkedQueueTest.suite(),
 532             ConcurrentSkipListMapTest.suite(),
 533             ConcurrentSkipListSubMapTest.suite(),
 534             ConcurrentSkipListSetTest.suite(),
 535             ConcurrentSkipListSubSetTest.suite(),
 536             CopyOnWriteArrayListTest.suite(),
 537             CopyOnWriteArraySetTest.suite(),
 538             CountDownLatchTest.suite(),
 539             CountedCompleterTest.suite(),
 540             CyclicBarrierTest.suite(),
 541             DelayQueueTest.suite(),
 542             EntryTest.suite(),
 543             ExchangerTest.suite(),
 544             ExecutorsTest.suite(),
 545             ExecutorCompletionServiceTest.suite(),
 546             FutureTaskTest.suite(),

 547             LinkedBlockingDequeTest.suite(),
 548             LinkedBlockingQueueTest.suite(),
 549             LinkedListTest.suite(),
 550             LockSupportTest.suite(),
 551             PriorityBlockingQueueTest.suite(),
 552             PriorityQueueTest.suite(),
 553             ReentrantLockTest.suite(),
 554             ReentrantReadWriteLockTest.suite(),
 555             ScheduledExecutorTest.suite(),
 556             ScheduledExecutorSubclassTest.suite(),
 557             SemaphoreTest.suite(),
 558             SynchronousQueueTest.suite(),
 559             SystemTest.suite(),
 560             ThreadLocalTest.suite(),
 561             ThreadPoolExecutorTest.suite(),
 562             ThreadPoolExecutorSubclassTest.suite(),
 563             ThreadTest.suite(),
 564             TimeUnitTest.suite(),
 565             TreeMapTest.suite(),
 566             TreeSetTest.suite(),
</pre>
<hr />
<pre>
 665             try {
 666                 return (Test)
 667                     Class.forName(name8)
 668                     .getMethod(&quot;testSuite&quot;, dataClass)
 669                     .invoke(null, data);
 670             } catch (ReflectiveOperationException e) {
 671                 throw new AssertionError(e);
 672             }
 673         } else {
 674             return new TestSuite();
 675         }
 676     }
 677 
 678     // Delays for timing-dependent tests, in milliseconds.
 679 
 680     public static long SHORT_DELAY_MS;
 681     public static long SMALL_DELAY_MS;
 682     public static long MEDIUM_DELAY_MS;
 683     public static long LONG_DELAY_MS;
 684 






 685     private static final long RANDOM_TIMEOUT;
 686     private static final long RANDOM_EXPIRED_TIMEOUT;
 687     private static final TimeUnit RANDOM_TIMEUNIT;
 688     static {
 689         ThreadLocalRandom rnd = ThreadLocalRandom.current();
 690         long[] timeouts = { Long.MIN_VALUE, -1, 0, 1, Long.MAX_VALUE };
 691         RANDOM_TIMEOUT = timeouts[rnd.nextInt(timeouts.length)];
 692         RANDOM_EXPIRED_TIMEOUT = timeouts[rnd.nextInt(3)];
 693         TimeUnit[] timeUnits = TimeUnit.values();
 694         RANDOM_TIMEUNIT = timeUnits[rnd.nextInt(timeUnits.length)];
 695     }
 696 
 697     /**
 698      * Returns a timeout for use when any value at all will do.
 699      */
 700     static long randomTimeout() { return RANDOM_TIMEOUT; }
 701 
 702     /**
 703      * Returns a timeout that means &quot;no waiting&quot;, i.e. not positive.
 704      */
 705     static long randomExpiredTimeout() { return RANDOM_EXPIRED_TIMEOUT; }
 706 
 707     /**
 708      * Returns a random non-null TimeUnit.
 709      */
 710     static TimeUnit randomTimeUnit() { return RANDOM_TIMEUNIT; }
 711 





















 712     /**
 713      * Returns the shortest timed delay. This can be scaled up for
 714      * slow machines using the jsr166.delay.factor system property,
 715      * or via jtreg&#39;s -timeoutFactor: flag.
 716      * http://openjdk.java.net/jtreg/command-help.html
 717      */
 718     protected long getShortDelay() {
 719         return (long) (50 * delayFactor);
 720     }
 721 
 722     /**
 723      * Sets delays as multiples of SHORT_DELAY.
 724      */
 725     protected void setDelays() {
 726         SHORT_DELAY_MS = getShortDelay();
 727         SMALL_DELAY_MS  = SHORT_DELAY_MS * 5;
 728         MEDIUM_DELAY_MS = SHORT_DELAY_MS * 10;
 729         LONG_DELAY_MS   = SHORT_DELAY_MS * 200;

 730     }
 731 
 732     private static final long TIMEOUT_DELAY_MS
 733         = (long) (12.0 * Math.cbrt(delayFactor));
 734 
 735     /**
 736      * Returns a timeout in milliseconds to be used in tests that verify
 737      * that operations block or time out.  We want this to be longer
 738      * than the OS scheduling quantum, but not too long, so don&#39;t scale
 739      * linearly with delayFactor; we use &quot;crazy&quot; cube root instead.
 740      */
 741     static long timeoutMillis() {
 742         return TIMEOUT_DELAY_MS;
 743     }
 744 
 745     /**
 746      * Returns a new Date instance representing a time at least
 747      * delayMillis milliseconds in the future.
 748      */
 749     Date delayedDate(long delayMillis) {
 750         // Add 1 because currentTimeMillis is known to round into the past.
 751         return new Date(System.currentTimeMillis() + delayMillis + 1);
 752     }
 753 
 754     /**
 755      * The first exception encountered if any threadAssertXXX method fails.
 756      */
 757     private final AtomicReference&lt;Throwable&gt; threadFailure
 758         = new AtomicReference&lt;&gt;(null);
 759 
 760     /**
 761      * Records an exception so that it can be rethrown later in the test
 762      * harness thread, triggering a test case failure.  Only the first
 763      * failure is recorded; subsequent calls to this method from within
 764      * the same test have no effect.
 765      */
 766     public void threadRecordFailure(Throwable t) {
 767         System.err.println(t);
<span class="line-modified"> 768         dumpTestThreads();</span>
<span class="line-modified"> 769         threadFailure.compareAndSet(null, t);</span>
 770     }
 771 
 772     public void setUp() {
 773         setDelays();
 774     }
 775 
 776     void tearDownFail(String format, Object... args) {
 777         String msg = toString() + &quot;: &quot; + String.format(format, args);
 778         System.err.println(msg);
 779         dumpTestThreads();
 780         throw new AssertionError(msg);
 781     }
 782 
 783     /**
 784      * Extra checks that get done for all test cases.
 785      *
 786      * Triggers test case failure if any thread assertions have failed,
 787      * by rethrowing, in the test harness thread, any exception recorded
 788      * earlier by threadRecordFailure.
 789      *
</pre>
<hr />
<pre>
1070      * necessarily individually slow because they must block.
1071      */
1072     void testInParallel(Action ... actions) {
1073         ExecutorService pool = Executors.newCachedThreadPool();
1074         try (PoolCleaner cleaner = cleaner(pool)) {
1075             ArrayList&lt;Future&lt;?&gt;&gt; futures = new ArrayList&lt;&gt;(actions.length);
1076             for (final Action action : actions)
1077                 futures.add(pool.submit(new CheckedRunnable() {
1078                     public void realRun() throws Throwable { action.run();}}));
1079             for (Future&lt;?&gt; future : futures)
1080                 try {
1081                     assertNull(future.get(LONG_DELAY_MS, MILLISECONDS));
1082                 } catch (ExecutionException ex) {
1083                     threadUnexpectedException(ex.getCause());
1084                 } catch (Exception ex) {
1085                     threadUnexpectedException(ex);
1086                 }
1087         }
1088     }
1089 

































1090     /**
1091      * A debugging tool to print stack traces of most threads, as jstack does.
1092      * Uninteresting threads are filtered out.
1093      */
1094     static void dumpTestThreads() {
1095         SecurityManager sm = System.getSecurityManager();
1096         if (sm != null) {
1097             try {
1098                 System.setSecurityManager(null);
1099             } catch (SecurityException giveUp) {
1100                 return;
1101             }
1102         }
1103 
<span class="line-removed">1104         ThreadMXBean threadMXBean = ManagementFactory.getThreadMXBean();</span>
1105         System.err.println(&quot;------ stacktrace dump start ------&quot;);
<span class="line-modified">1106         for (ThreadInfo info : threadMXBean.dumpAllThreads(true, true)) {</span>
<span class="line-modified">1107             final String name = info.getThreadName();</span>
<span class="line-modified">1108             String lockName;</span>
<span class="line-removed">1109             if (&quot;Signal Dispatcher&quot;.equals(name))</span>
<span class="line-removed">1110                 continue;</span>
<span class="line-removed">1111             if (&quot;Reference Handler&quot;.equals(name)</span>
<span class="line-removed">1112                 &amp;&amp; (lockName = info.getLockName()) != null</span>
<span class="line-removed">1113                 &amp;&amp; lockName.startsWith(&quot;java.lang.ref.Reference$Lock&quot;))</span>
<span class="line-removed">1114                 continue;</span>
<span class="line-removed">1115             if (&quot;Finalizer&quot;.equals(name)</span>
<span class="line-removed">1116                 &amp;&amp; (lockName = info.getLockName()) != null</span>
<span class="line-removed">1117                 &amp;&amp; lockName.startsWith(&quot;java.lang.ref.ReferenceQueue$Lock&quot;))</span>
<span class="line-removed">1118                 continue;</span>
<span class="line-removed">1119             if (&quot;checkForWedgedTest&quot;.equals(name))</span>
<span class="line-removed">1120                 continue;</span>
<span class="line-removed">1121             System.err.print(info);</span>
<span class="line-removed">1122         }</span>
1123         System.err.println(&quot;------ stacktrace dump end ------&quot;);
1124 
1125         if (sm != null) System.setSecurityManager(sm);
1126     }
1127 
1128     /**
1129      * Checks that thread eventually enters the expected blocked thread state.
1130      */
1131     void assertThreadBlocks(Thread thread, Thread.State expected) {
1132         // always sleep at least 1 ms, with high probability avoiding
1133         // transitory states
1134         for (long retries = LONG_DELAY_MS * 3 / 4; retries--&gt;0; ) {
1135             try { delay(1); }
1136             catch (InterruptedException fail) {
1137                 throw new AssertionError(&quot;Unexpected InterruptedException&quot;, fail);
1138             }
1139             Thread.State s = thread.getState();
1140             if (s == expected)
1141                 return;
1142             else if (s == Thread.State.TERMINATED)
1143                 fail(&quot;Unexpected thread termination&quot;);
1144         }
1145         fail(&quot;timed out waiting for thread to enter thread state &quot; + expected);
1146     }
1147 











1148     /**
1149      * Checks that future.get times out, with the default timeout of
1150      * {@code timeoutMillis()}.
1151      */
1152     void assertFutureTimesOut(Future future) {
1153         assertFutureTimesOut(future, timeoutMillis());
1154     }
1155 
1156     /**
1157      * Checks that future.get times out, with the given millisecond timeout.
1158      */
1159     void assertFutureTimesOut(Future future, long timeoutMillis) {
1160         long startTime = System.nanoTime();
1161         try {
1162             future.get(timeoutMillis, MILLISECONDS);
1163             shouldThrow();
1164         } catch (TimeoutException success) {
1165         } catch (Exception fail) {
1166             threadUnexpectedException(fail);
1167         } finally { future.cancel(true); }
</pre>
<hr />
<pre>
1374     }
1375 
1376     /**
1377      * Spin-waits up to LONG_DELAY_MS milliseconds for the given thread to
1378      * enter a wait state: BLOCKED, WAITING, or TIMED_WAITING.
1379      */
1380     void waitForThreadToEnterWaitState(Thread thread) {
1381         waitForThreadToEnterWaitState(thread, LONG_DELAY_MS, null);
1382     }
1383 
1384     /**
1385      * Spin-waits up to LONG_DELAY_MS milliseconds for the given thread to
1386      * enter a wait state: BLOCKED, WAITING, or TIMED_WAITING,
1387      * and additionally satisfy the given condition.
1388      */
1389     void waitForThreadToEnterWaitState(Thread thread,
1390                                        Callable&lt;Boolean&gt; waitingForGodot) {
1391         waitForThreadToEnterWaitState(thread, LONG_DELAY_MS, waitingForGodot);
1392     }
1393 














1394     /**
1395      * Returns the number of milliseconds since time given by
1396      * startNanoTime, which must have been previously returned from a
1397      * call to {@link System#nanoTime()}.
1398      */
1399     static long millisElapsedSince(long startNanoTime) {
1400         return NANOSECONDS.toMillis(System.nanoTime() - startNanoTime);
1401     }
1402 
<span class="line-removed">1403 //     void assertTerminatesPromptly(long timeoutMillis, Runnable r) {</span>
<span class="line-removed">1404 //         long startTime = System.nanoTime();</span>
<span class="line-removed">1405 //         try {</span>
<span class="line-removed">1406 //             r.run();</span>
<span class="line-removed">1407 //         } catch (Throwable fail) { threadUnexpectedException(fail); }</span>
<span class="line-removed">1408 //         if (millisElapsedSince(startTime) &gt; timeoutMillis/2)</span>
<span class="line-removed">1409 //             throw new AssertionError(&quot;did not return promptly&quot;);</span>
<span class="line-removed">1410 //     }</span>
<span class="line-removed">1411 </span>
<span class="line-removed">1412 //     void assertTerminatesPromptly(Runnable r) {</span>
<span class="line-removed">1413 //         assertTerminatesPromptly(LONG_DELAY_MS/2, r);</span>
<span class="line-removed">1414 //     }</span>
<span class="line-removed">1415 </span>
1416     /**
1417      * Checks that timed f.get() returns the expected value, and does not
1418      * wait for the timeout to elapse before returning.
1419      */
1420     &lt;T&gt; void checkTimedGet(Future&lt;T&gt; f, T expectedValue, long timeoutMillis) {
1421         long startTime = System.nanoTime();
1422         T actual = null;
1423         try {
1424             actual = f.get(timeoutMillis, MILLISECONDS);
1425         } catch (Throwable fail) { threadUnexpectedException(fail); }
1426         assertEquals(expectedValue, actual);
1427         if (millisElapsedSince(startTime) &gt; timeoutMillis/2)
1428             throw new AssertionError(&quot;timed get did not return promptly&quot;);
1429     }
1430 
1431     &lt;T&gt; void checkTimedGet(Future&lt;T&gt; f, T expectedValue) {
1432         checkTimedGet(f, expectedValue, LONG_DELAY_MS);
1433     }
1434 
1435     /**
1436      * Returns a new started daemon Thread running the given runnable.
1437      */
1438     Thread newStartedThread(Runnable runnable) {
1439         Thread t = new Thread(runnable);
1440         t.setDaemon(true);
1441         t.start();
1442         return t;
1443     }
1444 








1445     /**
1446      * Waits for the specified time (in milliseconds) for the thread
1447      * to terminate (using {@link Thread#join(long)}), else interrupts
1448      * the thread (in the hope that it may terminate later) and fails.
1449      */
<span class="line-modified">1450     void awaitTermination(Thread t, long timeoutMillis) {</span>
1451         try {
<span class="line-modified">1452             t.join(timeoutMillis);</span>
1453         } catch (InterruptedException fail) {
1454             threadUnexpectedException(fail);
<span class="line-modified">1455         } finally {</span>
<span class="line-modified">1456             if (t.getState() != Thread.State.TERMINATED) {</span>
<span class="line-modified">1457                 t.interrupt();</span>
<span class="line-modified">1458                 threadFail(&quot;timed out waiting for thread to terminate&quot;);</span>






1459             }
1460         }
1461     }
1462 
1463     /**
1464      * Waits for LONG_DELAY_MS milliseconds for the thread to
1465      * terminate (using {@link Thread#join(long)}), else interrupts
1466      * the thread (in the hope that it may terminate later) and fails.
1467      */
1468     void awaitTermination(Thread t) {
1469         awaitTermination(t, LONG_DELAY_MS);
1470     }
1471 
1472     // Some convenient Runnable classes
1473 
1474     public abstract class CheckedRunnable implements Runnable {
1475         protected abstract void realRun() throws Throwable;
1476 
1477         public final void run() {
1478             try {
1479                 realRun();
1480             } catch (Throwable fail) {
1481                 threadUnexpectedException(fail);
1482             }
1483         }
1484     }
1485 







1486     public abstract class ThreadShouldThrow extends Thread {
1487         protected abstract void realRun() throws Throwable;
1488 
1489         final Class&lt;?&gt; exceptionClass;
1490 
1491         &lt;T extends Throwable&gt; ThreadShouldThrow(Class&lt;T&gt; exceptionClass) {
1492             this.exceptionClass = exceptionClass;
1493         }
1494 
1495         public final void run() {
1496             try {
1497                 realRun();
1498             } catch (Throwable t) {
1499                 if (! exceptionClass.isInstance(t))
1500                     threadUnexpectedException(t);
1501                 return;
1502             }
1503             threadShouldThrow(exceptionClass.getSimpleName());
1504         }
1505     }
</pre>
<hr />
<pre>
1704         }
1705     }
1706 
1707     /**
1708      * For use as RejectedExecutionHandler in constructors
1709      */
1710     public static class NoOpREHandler implements RejectedExecutionHandler {
1711         public void rejectedExecution(Runnable r,
1712                                       ThreadPoolExecutor executor) {}
1713     }
1714 
1715     /**
1716      * A CyclicBarrier that uses timed await and fails with
1717      * AssertionErrors instead of throwing checked exceptions.
1718      */
1719     public static class CheckedBarrier extends CyclicBarrier {
1720         public CheckedBarrier(int parties) { super(parties); }
1721 
1722         public int await() {
1723             try {
<span class="line-modified">1724                 return super.await(2 * LONG_DELAY_MS, MILLISECONDS);</span>
1725             } catch (TimeoutException timedOut) {
1726                 throw new AssertionError(&quot;timed out&quot;);
1727             } catch (Exception fail) {
1728                 throw new AssertionError(&quot;Unexpected exception: &quot; + fail, fail);
1729             }
1730         }
1731     }
1732 
1733     void checkEmpty(BlockingQueue q) {
1734         try {
1735             assertTrue(q.isEmpty());
1736             assertEquals(0, q.size());
1737             assertNull(q.peek());
1738             assertNull(q.poll());
1739             assertNull(q.poll(randomExpiredTimeout(), randomTimeUnit()));
1740             assertEquals(q.toString(), &quot;[]&quot;);
1741             assertTrue(Arrays.equals(q.toArray(), new Object[0]));
1742             assertFalse(q.iterator().hasNext());
1743             try {
1744                 q.element();
</pre>
<hr />
<pre>
1760     }
1761 
1762     void assertNotSerialEquals(Object x, Object y) {
1763         assertFalse(Arrays.equals(serialBytes(x), serialBytes(y)));
1764     }
1765 
1766     byte[] serialBytes(Object o) {
1767         try {
1768             ByteArrayOutputStream bos = new ByteArrayOutputStream();
1769             ObjectOutputStream oos = new ObjectOutputStream(bos);
1770             oos.writeObject(o);
1771             oos.flush();
1772             oos.close();
1773             return bos.toByteArray();
1774         } catch (Throwable fail) {
1775             threadUnexpectedException(fail);
1776             return new byte[0];
1777         }
1778     }
1779 
<span class="line-modified">1780     void assertImmutable(final Object o) {</span>
1781         if (o instanceof Collection) {
1782             assertThrows(
1783                 UnsupportedOperationException.class,
<span class="line-modified">1784                 new Runnable() { public void run() {</span>
<span class="line-removed">1785                         ((Collection) o).add(null);}});</span>
1786         }
1787     }
1788 
1789     @SuppressWarnings(&quot;unchecked&quot;)
1790     &lt;T&gt; T serialClone(T o) {
1791         T clone = null;
1792         try {
1793             ObjectInputStream ois = new ObjectInputStream
1794                 (new ByteArrayInputStream(serialBytes(o)));
1795             clone = (T) ois.readObject();
1796         } catch (Throwable fail) {
1797             threadUnexpectedException(fail);
1798         }
1799         if (o == clone) assertImmutable(o);
1800         else assertSame(o.getClass(), clone.getClass());
1801         return clone;
1802     }
1803 
1804     /**
1805      * A version of serialClone that leaves error handling (for
</pre>
<hr />
<pre>
1825      * If o implements Cloneable and has a public clone method,
1826      * returns a clone of o, else null.
1827      */
1828     @SuppressWarnings(&quot;unchecked&quot;)
1829     &lt;T&gt; T cloneableClone(T o) {
1830         if (!(o instanceof Cloneable)) return null;
1831         final T clone;
1832         try {
1833             clone = (T) o.getClass().getMethod(&quot;clone&quot;).invoke(o);
1834         } catch (NoSuchMethodException ok) {
1835             return null;
1836         } catch (ReflectiveOperationException unexpected) {
1837             throw new Error(unexpected);
1838         }
1839         assertNotSame(o, clone); // not 100% guaranteed by spec
1840         assertSame(o.getClass(), clone.getClass());
1841         return clone;
1842     }
1843 
1844     public void assertThrows(Class&lt;? extends Throwable&gt; expectedExceptionClass,
<span class="line-modified">1845                              Runnable... throwingActions) {</span>
<span class="line-modified">1846         for (Runnable throwingAction : throwingActions) {</span>
1847             boolean threw = false;
1848             try { throwingAction.run(); }
1849             catch (Throwable t) {
1850                 threw = true;
1851                 if (!expectedExceptionClass.isInstance(t))
1852                     throw new AssertionError(
1853                             &quot;Expected &quot; + expectedExceptionClass.getName() +
1854                             &quot;, got &quot; + t.getClass().getName(),
1855                             t);
1856             }
1857             if (!threw)
1858                 shouldThrow(expectedExceptionClass.getName());
1859         }
1860     }
1861 
1862     public void assertIteratorExhausted(Iterator&lt;?&gt; it) {
1863         try {
1864             it.next();
1865             shouldThrow();
1866         } catch (NoSuchElementException success) {}
</pre>
</td>
<td>
<hr />
<pre>
  59  *      -Djsr166.testImplementationDetails=true
  60  *      -Djava.util.concurrent.ForkJoinPool.common.parallelism=1
  61  *      -Djava.util.secureRandomSeed=true
  62  *      JSR166TestCase
  63  * @run junit/othervm/timeout=1000/policy=tck.policy
  64  *      --add-opens java.base/java.util.concurrent=ALL-UNNAMED
  65  *      --add-opens java.base/java.lang=ALL-UNNAMED
  66  *      -Djsr166.testImplementationDetails=true
  67  *      JSR166TestCase
  68  */
  69 
  70 import static java.util.concurrent.TimeUnit.MILLISECONDS;
  71 import static java.util.concurrent.TimeUnit.MINUTES;
  72 import static java.util.concurrent.TimeUnit.NANOSECONDS;
  73 
  74 import java.io.ByteArrayInputStream;
  75 import java.io.ByteArrayOutputStream;
  76 import java.io.ObjectInputStream;
  77 import java.io.ObjectOutputStream;
  78 import java.lang.management.ManagementFactory;
<span class="line-added">  79 import java.lang.management.LockInfo;</span>
  80 import java.lang.management.ThreadInfo;
  81 import java.lang.management.ThreadMXBean;
  82 import java.lang.reflect.Constructor;
  83 import java.lang.reflect.Method;
  84 import java.lang.reflect.Modifier;
  85 import java.security.CodeSource;
  86 import java.security.Permission;
  87 import java.security.PermissionCollection;
  88 import java.security.Permissions;
  89 import java.security.Policy;
  90 import java.security.ProtectionDomain;
  91 import java.security.SecurityPermission;
  92 import java.util.ArrayList;
  93 import java.util.Arrays;
  94 import java.util.Collection;
  95 import java.util.Collections;
  96 import java.util.Date;
  97 import java.util.Deque;
  98 import java.util.Enumeration;
  99 import java.util.HashSet;
</pre>
<hr />
<pre>
 254      */
 255     private static final int suiteRuns =
 256         Integer.getInteger(&quot;jsr166.suiteRuns&quot;, 1);
 257 
 258     /**
 259      * Returns the value of the system property, or NaN if not defined.
 260      */
 261     private static float systemPropertyValue(String name) {
 262         String floatString = System.getProperty(name);
 263         if (floatString == null)
 264             return Float.NaN;
 265         try {
 266             return Float.parseFloat(floatString);
 267         } catch (NumberFormatException ex) {
 268             throw new IllegalArgumentException(
 269                 String.format(&quot;Bad float value in system property %s=%s&quot;,
 270                               name, floatString));
 271         }
 272     }
 273 
<span class="line-added"> 274     private static final ThreadMXBean THREAD_MXBEAN</span>
<span class="line-added"> 275         = ManagementFactory.getThreadMXBean();</span>
<span class="line-added"> 276 </span>
 277     /**
 278      * The scaling factor to apply to standard delays used in tests.
 279      * May be initialized from any of:
 280      * - the &quot;jsr166.delay.factor&quot; system property
 281      * - the &quot;test.timeout.factor&quot; system property (as used by jtreg)
 282      *   See: http://openjdk.java.net/jtreg/tag-spec.html
 283      * - hard-coded fuzz factor when using a known slowpoke VM
 284      */
 285     private static final float delayFactor = delayFactor();
 286 
 287     private static float delayFactor() {
 288         float x;
 289         if (!Float.isNaN(x = systemPropertyValue(&quot;jsr166.delay.factor&quot;)))
 290             return x;
 291         if (!Float.isNaN(x = systemPropertyValue(&quot;test.timeout.factor&quot;)))
 292             return x;
 293         String prop = System.getProperty(&quot;java.vm.version&quot;);
 294         if (prop != null &amp;&amp; prop.matches(&quot;.*debug.*&quot;))
 295             return 4.0f; // How much slower is fastdebug than product?!
 296         return 1.0f;
</pre>
<hr />
<pre>
 298 
 299     public JSR166TestCase() { super(); }
 300     public JSR166TestCase(String name) { super(name); }
 301 
 302     /**
 303      * A filter for tests to run, matching strings of the form
 304      * methodName(className), e.g. &quot;testInvokeAll5(ForkJoinPoolTest)&quot;
 305      * Usefully combined with jsr166.runsPerTest.
 306      */
 307     private static final Pattern methodFilter = methodFilter();
 308 
 309     private static Pattern methodFilter() {
 310         String regex = System.getProperty(&quot;jsr166.methodFilter&quot;);
 311         return (regex == null) ? null : Pattern.compile(regex);
 312     }
 313 
 314     // Instrumentation to debug very rare, but very annoying hung test runs.
 315     static volatile TestCase currentTestCase;
 316     // static volatile int currentRun = 0;
 317     static {
<span class="line-modified"> 318         Runnable wedgedTestDetector = new Runnable() { public void run() {</span>
 319             // Avoid spurious reports with enormous runsPerTest.
 320             // A single test case run should never take more than 1 second.
 321             // But let&#39;s cap it at the high end too ...
<span class="line-modified"> 322             final int timeoutMinutesMin = Math.max(runsPerTest / 60, 1)</span>
<span class="line-modified"> 323                 * Math.max((int) delayFactor, 1);</span>
<span class="line-added"> 324             final int timeoutMinutes = Math.min(15, timeoutMinutesMin);</span>
 325             for (TestCase lastTestCase = currentTestCase;;) {
 326                 try { MINUTES.sleep(timeoutMinutes); }
 327                 catch (InterruptedException unexpected) { break; }
 328                 if (lastTestCase == currentTestCase) {
 329                     System.err.printf(
 330                         &quot;Looks like we&#39;re stuck running test: %s%n&quot;,
 331                         lastTestCase);
 332 //                     System.err.printf(
 333 //                         &quot;Looks like we&#39;re stuck running test: %s (%d/%d)%n&quot;,
 334 //                         lastTestCase, currentRun, runsPerTest);
 335 //                     System.err.println(&quot;availableProcessors=&quot; +
 336 //                         Runtime.getRuntime().availableProcessors());
 337 //                     System.err.printf(&quot;cpu model = %s%n&quot;, cpuModel());
 338                     dumpTestThreads();
 339                     // one stack dump is probably enough; more would be spam
 340                     break;
 341                 }
 342                 lastTestCase = currentTestCase;
 343             }}};
<span class="line-modified"> 344         Thread thread = new Thread(wedgedTestDetector, &quot;WedgedTestDetector&quot;);</span>
 345         thread.setDaemon(true);
 346         thread.start();
 347     }
 348 
 349 //     public static String cpuModel() {
 350 //         try {
 351 //             java.util.regex.Matcher matcher
 352 //               = Pattern.compile(&quot;model name\\s*: (.*)&quot;)
 353 //                 .matcher(new String(
 354 //                     java.nio.file.Files.readAllBytes(
 355 //                         java.nio.file.Paths.get(&quot;/proc/cpuinfo&quot;)), &quot;UTF-8&quot;));
 356 //             matcher.find();
 357 //             return matcher.group(1);
 358 //         } catch (Exception ex) { return null; }
 359 //     }
 360 
 361     public void runBare() throws Throwable {
 362         currentTestCase = this;
 363         if (methodFilter == null
 364             || methodFilter.matcher(toString()).find())
</pre>
<hr />
<pre>
 368     protected void runTest() throws Throwable {
 369         for (int i = 0; i &lt; runsPerTest; i++) {
 370             // currentRun = i;
 371             if (profileTests)
 372                 runTestProfiled();
 373             else
 374                 super.runTest();
 375         }
 376     }
 377 
 378     protected void runTestProfiled() throws Throwable {
 379         for (int i = 0; i &lt; 2; i++) {
 380             long startTime = System.nanoTime();
 381             super.runTest();
 382             long elapsedMillis = millisElapsedSince(startTime);
 383             if (elapsedMillis &lt; profileThreshold)
 384                 break;
 385             // Never report first run of any test; treat it as a
 386             // warmup run, notably to trigger all needed classloading,
 387             if (i &gt; 0)
<span class="line-modified"> 388                 System.out.printf(&quot;%s: %d%n&quot;, toString(), elapsedMillis);</span>
 389         }
 390     }
 391 
 392     /**
 393      * Runs all JSR166 unit tests using junit.textui.TestRunner.
 394      */
 395     public static void main(String[] args) {
 396         main(suite(), args);
 397     }
 398 
 399     static class PithyResultPrinter extends junit.textui.ResultPrinter {
 400         PithyResultPrinter(java.io.PrintStream writer) { super(writer); }
 401         long runTime;
 402         public void startTest(Test test) {}
 403         protected void printHeader(long runTime) {
 404             this.runTime = runTime; // defer printing for later
 405         }
 406         protected void printFooter(TestResult result) {
 407             if (result.wasSuccessful()) {
 408                 getWriter().println(&quot;OK (&quot; + result.runCount() + &quot; tests)&quot;
</pre>
<hr />
<pre>
 532             AtomicReferenceTest.suite(),
 533             AtomicStampedReferenceTest.suite(),
 534             ConcurrentHashMapTest.suite(),
 535             ConcurrentLinkedDequeTest.suite(),
 536             ConcurrentLinkedQueueTest.suite(),
 537             ConcurrentSkipListMapTest.suite(),
 538             ConcurrentSkipListSubMapTest.suite(),
 539             ConcurrentSkipListSetTest.suite(),
 540             ConcurrentSkipListSubSetTest.suite(),
 541             CopyOnWriteArrayListTest.suite(),
 542             CopyOnWriteArraySetTest.suite(),
 543             CountDownLatchTest.suite(),
 544             CountedCompleterTest.suite(),
 545             CyclicBarrierTest.suite(),
 546             DelayQueueTest.suite(),
 547             EntryTest.suite(),
 548             ExchangerTest.suite(),
 549             ExecutorsTest.suite(),
 550             ExecutorCompletionServiceTest.suite(),
 551             FutureTaskTest.suite(),
<span class="line-added"> 552             HashtableTest.suite(),</span>
 553             LinkedBlockingDequeTest.suite(),
 554             LinkedBlockingQueueTest.suite(),
 555             LinkedListTest.suite(),
 556             LockSupportTest.suite(),
 557             PriorityBlockingQueueTest.suite(),
 558             PriorityQueueTest.suite(),
 559             ReentrantLockTest.suite(),
 560             ReentrantReadWriteLockTest.suite(),
 561             ScheduledExecutorTest.suite(),
 562             ScheduledExecutorSubclassTest.suite(),
 563             SemaphoreTest.suite(),
 564             SynchronousQueueTest.suite(),
 565             SystemTest.suite(),
 566             ThreadLocalTest.suite(),
 567             ThreadPoolExecutorTest.suite(),
 568             ThreadPoolExecutorSubclassTest.suite(),
 569             ThreadTest.suite(),
 570             TimeUnitTest.suite(),
 571             TreeMapTest.suite(),
 572             TreeSetTest.suite(),
</pre>
<hr />
<pre>
 671             try {
 672                 return (Test)
 673                     Class.forName(name8)
 674                     .getMethod(&quot;testSuite&quot;, dataClass)
 675                     .invoke(null, data);
 676             } catch (ReflectiveOperationException e) {
 677                 throw new AssertionError(e);
 678             }
 679         } else {
 680             return new TestSuite();
 681         }
 682     }
 683 
 684     // Delays for timing-dependent tests, in milliseconds.
 685 
 686     public static long SHORT_DELAY_MS;
 687     public static long SMALL_DELAY_MS;
 688     public static long MEDIUM_DELAY_MS;
 689     public static long LONG_DELAY_MS;
 690 
<span class="line-added"> 691     /**</span>
<span class="line-added"> 692      * A delay significantly longer than LONG_DELAY_MS.</span>
<span class="line-added"> 693      * Use this in a thread that is waited for via awaitTermination(Thread).</span>
<span class="line-added"> 694      */</span>
<span class="line-added"> 695     public static long LONGER_DELAY_MS;</span>
<span class="line-added"> 696 </span>
 697     private static final long RANDOM_TIMEOUT;
 698     private static final long RANDOM_EXPIRED_TIMEOUT;
 699     private static final TimeUnit RANDOM_TIMEUNIT;
 700     static {
 701         ThreadLocalRandom rnd = ThreadLocalRandom.current();
 702         long[] timeouts = { Long.MIN_VALUE, -1, 0, 1, Long.MAX_VALUE };
 703         RANDOM_TIMEOUT = timeouts[rnd.nextInt(timeouts.length)];
 704         RANDOM_EXPIRED_TIMEOUT = timeouts[rnd.nextInt(3)];
 705         TimeUnit[] timeUnits = TimeUnit.values();
 706         RANDOM_TIMEUNIT = timeUnits[rnd.nextInt(timeUnits.length)];
 707     }
 708 
 709     /**
 710      * Returns a timeout for use when any value at all will do.
 711      */
 712     static long randomTimeout() { return RANDOM_TIMEOUT; }
 713 
 714     /**
 715      * Returns a timeout that means &quot;no waiting&quot;, i.e. not positive.
 716      */
 717     static long randomExpiredTimeout() { return RANDOM_EXPIRED_TIMEOUT; }
 718 
 719     /**
 720      * Returns a random non-null TimeUnit.
 721      */
 722     static TimeUnit randomTimeUnit() { return RANDOM_TIMEUNIT; }
 723 
<span class="line-added"> 724     /**</span>
<span class="line-added"> 725      * Returns a random boolean; a &quot;coin flip&quot;.</span>
<span class="line-added"> 726      */</span>
<span class="line-added"> 727     static boolean randomBoolean() {</span>
<span class="line-added"> 728         return ThreadLocalRandom.current().nextBoolean();</span>
<span class="line-added"> 729     }</span>
<span class="line-added"> 730 </span>
<span class="line-added"> 731     /**</span>
<span class="line-added"> 732      * Returns a random element from given choices.</span>
<span class="line-added"> 733      */</span>
<span class="line-added"> 734     &lt;T&gt; T chooseRandomly(List&lt;T&gt; choices) {</span>
<span class="line-added"> 735         return choices.get(ThreadLocalRandom.current().nextInt(choices.size()));</span>
<span class="line-added"> 736     }</span>
<span class="line-added"> 737 </span>
<span class="line-added"> 738     /**</span>
<span class="line-added"> 739      * Returns a random element from given choices.</span>
<span class="line-added"> 740      */</span>
<span class="line-added"> 741     &lt;T&gt; T chooseRandomly(T... choices) {</span>
<span class="line-added"> 742         return choices[ThreadLocalRandom.current().nextInt(choices.length)];</span>
<span class="line-added"> 743     }</span>
<span class="line-added"> 744 </span>
 745     /**
 746      * Returns the shortest timed delay. This can be scaled up for
 747      * slow machines using the jsr166.delay.factor system property,
 748      * or via jtreg&#39;s -timeoutFactor: flag.
 749      * http://openjdk.java.net/jtreg/command-help.html
 750      */
 751     protected long getShortDelay() {
 752         return (long) (50 * delayFactor);
 753     }
 754 
 755     /**
 756      * Sets delays as multiples of SHORT_DELAY.
 757      */
 758     protected void setDelays() {
 759         SHORT_DELAY_MS = getShortDelay();
 760         SMALL_DELAY_MS  = SHORT_DELAY_MS * 5;
 761         MEDIUM_DELAY_MS = SHORT_DELAY_MS * 10;
 762         LONG_DELAY_MS   = SHORT_DELAY_MS * 200;
<span class="line-added"> 763         LONGER_DELAY_MS = 2 * LONG_DELAY_MS;</span>
 764     }
 765 
 766     private static final long TIMEOUT_DELAY_MS
 767         = (long) (12.0 * Math.cbrt(delayFactor));
 768 
 769     /**
 770      * Returns a timeout in milliseconds to be used in tests that verify
 771      * that operations block or time out.  We want this to be longer
 772      * than the OS scheduling quantum, but not too long, so don&#39;t scale
 773      * linearly with delayFactor; we use &quot;crazy&quot; cube root instead.
 774      */
 775     static long timeoutMillis() {
 776         return TIMEOUT_DELAY_MS;
 777     }
 778 
 779     /**
 780      * Returns a new Date instance representing a time at least
 781      * delayMillis milliseconds in the future.
 782      */
 783     Date delayedDate(long delayMillis) {
 784         // Add 1 because currentTimeMillis is known to round into the past.
 785         return new Date(System.currentTimeMillis() + delayMillis + 1);
 786     }
 787 
 788     /**
 789      * The first exception encountered if any threadAssertXXX method fails.
 790      */
 791     private final AtomicReference&lt;Throwable&gt; threadFailure
 792         = new AtomicReference&lt;&gt;(null);
 793 
 794     /**
 795      * Records an exception so that it can be rethrown later in the test
 796      * harness thread, triggering a test case failure.  Only the first
 797      * failure is recorded; subsequent calls to this method from within
 798      * the same test have no effect.
 799      */
 800     public void threadRecordFailure(Throwable t) {
 801         System.err.println(t);
<span class="line-modified"> 802         if (threadFailure.compareAndSet(null, t))</span>
<span class="line-modified"> 803             dumpTestThreads();</span>
 804     }
 805 
 806     public void setUp() {
 807         setDelays();
 808     }
 809 
 810     void tearDownFail(String format, Object... args) {
 811         String msg = toString() + &quot;: &quot; + String.format(format, args);
 812         System.err.println(msg);
 813         dumpTestThreads();
 814         throw new AssertionError(msg);
 815     }
 816 
 817     /**
 818      * Extra checks that get done for all test cases.
 819      *
 820      * Triggers test case failure if any thread assertions have failed,
 821      * by rethrowing, in the test harness thread, any exception recorded
 822      * earlier by threadRecordFailure.
 823      *
</pre>
<hr />
<pre>
1104      * necessarily individually slow because they must block.
1105      */
1106     void testInParallel(Action ... actions) {
1107         ExecutorService pool = Executors.newCachedThreadPool();
1108         try (PoolCleaner cleaner = cleaner(pool)) {
1109             ArrayList&lt;Future&lt;?&gt;&gt; futures = new ArrayList&lt;&gt;(actions.length);
1110             for (final Action action : actions)
1111                 futures.add(pool.submit(new CheckedRunnable() {
1112                     public void realRun() throws Throwable { action.run();}}));
1113             for (Future&lt;?&gt; future : futures)
1114                 try {
1115                     assertNull(future.get(LONG_DELAY_MS, MILLISECONDS));
1116                 } catch (ExecutionException ex) {
1117                     threadUnexpectedException(ex.getCause());
1118                 } catch (Exception ex) {
1119                     threadUnexpectedException(ex);
1120                 }
1121         }
1122     }
1123 
<span class="line-added">1124     /** Returns true if thread info might be useful in a thread dump. */</span>
<span class="line-added">1125     static boolean threadOfInterest(ThreadInfo info) {</span>
<span class="line-added">1126         final String name = info.getThreadName();</span>
<span class="line-added">1127         String lockName;</span>
<span class="line-added">1128         if (name == null)</span>
<span class="line-added">1129             return true;</span>
<span class="line-added">1130         if (name.equals(&quot;Signal Dispatcher&quot;)</span>
<span class="line-added">1131             || name.equals(&quot;WedgedTestDetector&quot;))</span>
<span class="line-added">1132             return false;</span>
<span class="line-added">1133         if (name.equals(&quot;Reference Handler&quot;)) {</span>
<span class="line-added">1134             // Reference Handler stacktrace changed in JDK-8156500</span>
<span class="line-added">1135             StackTraceElement[] stackTrace; String methodName;</span>
<span class="line-added">1136             if ((stackTrace = info.getStackTrace()) != null</span>
<span class="line-added">1137                 &amp;&amp; stackTrace.length &gt; 0</span>
<span class="line-added">1138                 &amp;&amp; (methodName = stackTrace[0].getMethodName()) != null</span>
<span class="line-added">1139                 &amp;&amp; methodName.equals(&quot;waitForReferencePendingList&quot;))</span>
<span class="line-added">1140                 return false;</span>
<span class="line-added">1141             // jdk8 Reference Handler stacktrace</span>
<span class="line-added">1142             if ((lockName = info.getLockName()) != null</span>
<span class="line-added">1143                 &amp;&amp; lockName.startsWith(&quot;java.lang.ref&quot;))</span>
<span class="line-added">1144                 return false;</span>
<span class="line-added">1145         }</span>
<span class="line-added">1146         if ((name.equals(&quot;Finalizer&quot;) || name.equals(&quot;Common-Cleaner&quot;))</span>
<span class="line-added">1147             &amp;&amp; (lockName = info.getLockName()) != null</span>
<span class="line-added">1148             &amp;&amp; lockName.startsWith(&quot;java.lang.ref&quot;))</span>
<span class="line-added">1149             return false;</span>
<span class="line-added">1150         if (name.startsWith(&quot;ForkJoinPool.commonPool-worker&quot;)</span>
<span class="line-added">1151             &amp;&amp; (lockName = info.getLockName()) != null</span>
<span class="line-added">1152             &amp;&amp; lockName.startsWith(&quot;java.util.concurrent.ForkJoinPool&quot;))</span>
<span class="line-added">1153             return false;</span>
<span class="line-added">1154         return true;</span>
<span class="line-added">1155     }</span>
<span class="line-added">1156 </span>
1157     /**
1158      * A debugging tool to print stack traces of most threads, as jstack does.
1159      * Uninteresting threads are filtered out.
1160      */
1161     static void dumpTestThreads() {
1162         SecurityManager sm = System.getSecurityManager();
1163         if (sm != null) {
1164             try {
1165                 System.setSecurityManager(null);
1166             } catch (SecurityException giveUp) {
1167                 return;
1168             }
1169         }
1170 

1171         System.err.println(&quot;------ stacktrace dump start ------&quot;);
<span class="line-modified">1172         for (ThreadInfo info : THREAD_MXBEAN.dumpAllThreads(true, true))</span>
<span class="line-modified">1173             if (threadOfInterest(info))</span>
<span class="line-modified">1174                 System.err.print(info);</span>














1175         System.err.println(&quot;------ stacktrace dump end ------&quot;);
1176 
1177         if (sm != null) System.setSecurityManager(sm);
1178     }
1179 
1180     /**
1181      * Checks that thread eventually enters the expected blocked thread state.
1182      */
1183     void assertThreadBlocks(Thread thread, Thread.State expected) {
1184         // always sleep at least 1 ms, with high probability avoiding
1185         // transitory states
1186         for (long retries = LONG_DELAY_MS * 3 / 4; retries--&gt;0; ) {
1187             try { delay(1); }
1188             catch (InterruptedException fail) {
1189                 throw new AssertionError(&quot;Unexpected InterruptedException&quot;, fail);
1190             }
1191             Thread.State s = thread.getState();
1192             if (s == expected)
1193                 return;
1194             else if (s == Thread.State.TERMINATED)
1195                 fail(&quot;Unexpected thread termination&quot;);
1196         }
1197         fail(&quot;timed out waiting for thread to enter thread state &quot; + expected);
1198     }
1199 
<span class="line-added">1200     /**</span>
<span class="line-added">1201      * Returns the thread&#39;s blocker&#39;s class name, if any, else null.</span>
<span class="line-added">1202      */</span>
<span class="line-added">1203     String blockerClassName(Thread thread) {</span>
<span class="line-added">1204         ThreadInfo threadInfo; LockInfo lockInfo;</span>
<span class="line-added">1205         if ((threadInfo = THREAD_MXBEAN.getThreadInfo(thread.getId(), 0)) != null</span>
<span class="line-added">1206             &amp;&amp; (lockInfo = threadInfo.getLockInfo()) != null)</span>
<span class="line-added">1207             return lockInfo.getClassName();</span>
<span class="line-added">1208         return null;</span>
<span class="line-added">1209     }</span>
<span class="line-added">1210 </span>
1211     /**
1212      * Checks that future.get times out, with the default timeout of
1213      * {@code timeoutMillis()}.
1214      */
1215     void assertFutureTimesOut(Future future) {
1216         assertFutureTimesOut(future, timeoutMillis());
1217     }
1218 
1219     /**
1220      * Checks that future.get times out, with the given millisecond timeout.
1221      */
1222     void assertFutureTimesOut(Future future, long timeoutMillis) {
1223         long startTime = System.nanoTime();
1224         try {
1225             future.get(timeoutMillis, MILLISECONDS);
1226             shouldThrow();
1227         } catch (TimeoutException success) {
1228         } catch (Exception fail) {
1229             threadUnexpectedException(fail);
1230         } finally { future.cancel(true); }
</pre>
<hr />
<pre>
1437     }
1438 
1439     /**
1440      * Spin-waits up to LONG_DELAY_MS milliseconds for the given thread to
1441      * enter a wait state: BLOCKED, WAITING, or TIMED_WAITING.
1442      */
1443     void waitForThreadToEnterWaitState(Thread thread) {
1444         waitForThreadToEnterWaitState(thread, LONG_DELAY_MS, null);
1445     }
1446 
1447     /**
1448      * Spin-waits up to LONG_DELAY_MS milliseconds for the given thread to
1449      * enter a wait state: BLOCKED, WAITING, or TIMED_WAITING,
1450      * and additionally satisfy the given condition.
1451      */
1452     void waitForThreadToEnterWaitState(Thread thread,
1453                                        Callable&lt;Boolean&gt; waitingForGodot) {
1454         waitForThreadToEnterWaitState(thread, LONG_DELAY_MS, waitingForGodot);
1455     }
1456 
<span class="line-added">1457     /**</span>
<span class="line-added">1458      * Spin-waits up to LONG_DELAY_MS milliseconds for the current thread to</span>
<span class="line-added">1459      * be interrupted.  Clears the interrupt status before returning.</span>
<span class="line-added">1460      */</span>
<span class="line-added">1461     void awaitInterrupted() {</span>
<span class="line-added">1462         for (long startTime = 0L; !Thread.interrupted(); ) {</span>
<span class="line-added">1463             if (startTime == 0L)</span>
<span class="line-added">1464                 startTime = System.nanoTime();</span>
<span class="line-added">1465             else if (millisElapsedSince(startTime) &gt; LONG_DELAY_MS)</span>
<span class="line-added">1466                 fail(&quot;timed out waiting for thread interrupt&quot;);</span>
<span class="line-added">1467             Thread.yield();</span>
<span class="line-added">1468         }</span>
<span class="line-added">1469     }</span>
<span class="line-added">1470 </span>
1471     /**
1472      * Returns the number of milliseconds since time given by
1473      * startNanoTime, which must have been previously returned from a
1474      * call to {@link System#nanoTime()}.
1475      */
1476     static long millisElapsedSince(long startNanoTime) {
1477         return NANOSECONDS.toMillis(System.nanoTime() - startNanoTime);
1478     }
1479 













1480     /**
1481      * Checks that timed f.get() returns the expected value, and does not
1482      * wait for the timeout to elapse before returning.
1483      */
1484     &lt;T&gt; void checkTimedGet(Future&lt;T&gt; f, T expectedValue, long timeoutMillis) {
1485         long startTime = System.nanoTime();
1486         T actual = null;
1487         try {
1488             actual = f.get(timeoutMillis, MILLISECONDS);
1489         } catch (Throwable fail) { threadUnexpectedException(fail); }
1490         assertEquals(expectedValue, actual);
1491         if (millisElapsedSince(startTime) &gt; timeoutMillis/2)
1492             throw new AssertionError(&quot;timed get did not return promptly&quot;);
1493     }
1494 
1495     &lt;T&gt; void checkTimedGet(Future&lt;T&gt; f, T expectedValue) {
1496         checkTimedGet(f, expectedValue, LONG_DELAY_MS);
1497     }
1498 
1499     /**
1500      * Returns a new started daemon Thread running the given runnable.
1501      */
1502     Thread newStartedThread(Runnable runnable) {
1503         Thread t = new Thread(runnable);
1504         t.setDaemon(true);
1505         t.start();
1506         return t;
1507     }
1508 
<span class="line-added">1509     /**</span>
<span class="line-added">1510      * Returns a new started daemon Thread running the given action,</span>
<span class="line-added">1511      * wrapped in a CheckedRunnable.</span>
<span class="line-added">1512      */</span>
<span class="line-added">1513     Thread newStartedThread(Action action) {</span>
<span class="line-added">1514         return newStartedThread(checkedRunnable(action));</span>
<span class="line-added">1515     }</span>
<span class="line-added">1516 </span>
1517     /**
1518      * Waits for the specified time (in milliseconds) for the thread
1519      * to terminate (using {@link Thread#join(long)}), else interrupts
1520      * the thread (in the hope that it may terminate later) and fails.
1521      */
<span class="line-modified">1522     void awaitTermination(Thread thread, long timeoutMillis) {</span>
1523         try {
<span class="line-modified">1524             thread.join(timeoutMillis);</span>
1525         } catch (InterruptedException fail) {
1526             threadUnexpectedException(fail);
<span class="line-modified">1527         }</span>
<span class="line-modified">1528         if (thread.getState() != Thread.State.TERMINATED) {</span>
<span class="line-modified">1529             String detail = String.format(</span>
<span class="line-modified">1530                     &quot;timed out waiting for thread to terminate, thread=%s, state=%s&quot; ,</span>
<span class="line-added">1531                     thread, thread.getState());</span>
<span class="line-added">1532             try {</span>
<span class="line-added">1533                 threadFail(detail);</span>
<span class="line-added">1534             } finally {</span>
<span class="line-added">1535                 // Interrupt thread __after__ having reported its stack trace</span>
<span class="line-added">1536                 thread.interrupt();</span>
1537             }
1538         }
1539     }
1540 
1541     /**
1542      * Waits for LONG_DELAY_MS milliseconds for the thread to
1543      * terminate (using {@link Thread#join(long)}), else interrupts
1544      * the thread (in the hope that it may terminate later) and fails.
1545      */
1546     void awaitTermination(Thread t) {
1547         awaitTermination(t, LONG_DELAY_MS);
1548     }
1549 
1550     // Some convenient Runnable classes
1551 
1552     public abstract class CheckedRunnable implements Runnable {
1553         protected abstract void realRun() throws Throwable;
1554 
1555         public final void run() {
1556             try {
1557                 realRun();
1558             } catch (Throwable fail) {
1559                 threadUnexpectedException(fail);
1560             }
1561         }
1562     }
1563 
<span class="line-added">1564     Runnable checkedRunnable(Action action) {</span>
<span class="line-added">1565         return new CheckedRunnable() {</span>
<span class="line-added">1566             public void realRun() throws Throwable {</span>
<span class="line-added">1567                 action.run();</span>
<span class="line-added">1568             }};</span>
<span class="line-added">1569     }</span>
<span class="line-added">1570 </span>
1571     public abstract class ThreadShouldThrow extends Thread {
1572         protected abstract void realRun() throws Throwable;
1573 
1574         final Class&lt;?&gt; exceptionClass;
1575 
1576         &lt;T extends Throwable&gt; ThreadShouldThrow(Class&lt;T&gt; exceptionClass) {
1577             this.exceptionClass = exceptionClass;
1578         }
1579 
1580         public final void run() {
1581             try {
1582                 realRun();
1583             } catch (Throwable t) {
1584                 if (! exceptionClass.isInstance(t))
1585                     threadUnexpectedException(t);
1586                 return;
1587             }
1588             threadShouldThrow(exceptionClass.getSimpleName());
1589         }
1590     }
</pre>
<hr />
<pre>
1789         }
1790     }
1791 
1792     /**
1793      * For use as RejectedExecutionHandler in constructors
1794      */
1795     public static class NoOpREHandler implements RejectedExecutionHandler {
1796         public void rejectedExecution(Runnable r,
1797                                       ThreadPoolExecutor executor) {}
1798     }
1799 
1800     /**
1801      * A CyclicBarrier that uses timed await and fails with
1802      * AssertionErrors instead of throwing checked exceptions.
1803      */
1804     public static class CheckedBarrier extends CyclicBarrier {
1805         public CheckedBarrier(int parties) { super(parties); }
1806 
1807         public int await() {
1808             try {
<span class="line-modified">1809                 return super.await(LONGER_DELAY_MS, MILLISECONDS);</span>
1810             } catch (TimeoutException timedOut) {
1811                 throw new AssertionError(&quot;timed out&quot;);
1812             } catch (Exception fail) {
1813                 throw new AssertionError(&quot;Unexpected exception: &quot; + fail, fail);
1814             }
1815         }
1816     }
1817 
1818     void checkEmpty(BlockingQueue q) {
1819         try {
1820             assertTrue(q.isEmpty());
1821             assertEquals(0, q.size());
1822             assertNull(q.peek());
1823             assertNull(q.poll());
1824             assertNull(q.poll(randomExpiredTimeout(), randomTimeUnit()));
1825             assertEquals(q.toString(), &quot;[]&quot;);
1826             assertTrue(Arrays.equals(q.toArray(), new Object[0]));
1827             assertFalse(q.iterator().hasNext());
1828             try {
1829                 q.element();
</pre>
<hr />
<pre>
1845     }
1846 
1847     void assertNotSerialEquals(Object x, Object y) {
1848         assertFalse(Arrays.equals(serialBytes(x), serialBytes(y)));
1849     }
1850 
1851     byte[] serialBytes(Object o) {
1852         try {
1853             ByteArrayOutputStream bos = new ByteArrayOutputStream();
1854             ObjectOutputStream oos = new ObjectOutputStream(bos);
1855             oos.writeObject(o);
1856             oos.flush();
1857             oos.close();
1858             return bos.toByteArray();
1859         } catch (Throwable fail) {
1860             threadUnexpectedException(fail);
1861             return new byte[0];
1862         }
1863     }
1864 
<span class="line-modified">1865     void assertImmutable(Object o) {</span>
1866         if (o instanceof Collection) {
1867             assertThrows(
1868                 UnsupportedOperationException.class,
<span class="line-modified">1869                 () -&gt; ((Collection) o).add(null));</span>

1870         }
1871     }
1872 
1873     @SuppressWarnings(&quot;unchecked&quot;)
1874     &lt;T&gt; T serialClone(T o) {
1875         T clone = null;
1876         try {
1877             ObjectInputStream ois = new ObjectInputStream
1878                 (new ByteArrayInputStream(serialBytes(o)));
1879             clone = (T) ois.readObject();
1880         } catch (Throwable fail) {
1881             threadUnexpectedException(fail);
1882         }
1883         if (o == clone) assertImmutable(o);
1884         else assertSame(o.getClass(), clone.getClass());
1885         return clone;
1886     }
1887 
1888     /**
1889      * A version of serialClone that leaves error handling (for
</pre>
<hr />
<pre>
1909      * If o implements Cloneable and has a public clone method,
1910      * returns a clone of o, else null.
1911      */
1912     @SuppressWarnings(&quot;unchecked&quot;)
1913     &lt;T&gt; T cloneableClone(T o) {
1914         if (!(o instanceof Cloneable)) return null;
1915         final T clone;
1916         try {
1917             clone = (T) o.getClass().getMethod(&quot;clone&quot;).invoke(o);
1918         } catch (NoSuchMethodException ok) {
1919             return null;
1920         } catch (ReflectiveOperationException unexpected) {
1921             throw new Error(unexpected);
1922         }
1923         assertNotSame(o, clone); // not 100% guaranteed by spec
1924         assertSame(o.getClass(), clone.getClass());
1925         return clone;
1926     }
1927 
1928     public void assertThrows(Class&lt;? extends Throwable&gt; expectedExceptionClass,
<span class="line-modified">1929                              Action... throwingActions) {</span>
<span class="line-modified">1930         for (Action throwingAction : throwingActions) {</span>
1931             boolean threw = false;
1932             try { throwingAction.run(); }
1933             catch (Throwable t) {
1934                 threw = true;
1935                 if (!expectedExceptionClass.isInstance(t))
1936                     throw new AssertionError(
1937                             &quot;Expected &quot; + expectedExceptionClass.getName() +
1938                             &quot;, got &quot; + t.getClass().getName(),
1939                             t);
1940             }
1941             if (!threw)
1942                 shouldThrow(expectedExceptionClass.getName());
1943         }
1944     }
1945 
1946     public void assertIteratorExhausted(Iterator&lt;?&gt; it) {
1947         try {
1948             it.next();
1949             shouldThrow();
1950         } catch (NoSuchElementException success) {}
</pre>
</td>
</tr>
</table>
<center><a href="HashMapTest.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="LinkedBlockingDequeTest.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
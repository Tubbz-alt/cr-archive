<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff test/jdk/java/util/concurrent/tck/ThreadPoolExecutorTest.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
<body>
<center><a href="ThreadPoolExecutorSubclassTest.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="TimeUnitTest.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>test/jdk/java/util/concurrent/tck/ThreadPoolExecutorTest.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 682             assertEquals(tasks.length - 2, p.getTaskCount());
 683         }
 684     }
 685 
 686     /**
 687      * shutdownNow returns a list containing tasks that were not run,
 688      * and those tasks are drained from the queue
 689      */
 690     public void testShutdownNow() throws InterruptedException {
 691         final int poolSize = 2;
 692         final int count = 5;
 693         final AtomicInteger ran = new AtomicInteger(0);
 694         final ThreadPoolExecutor p =
 695             new ThreadPoolExecutor(poolSize, poolSize,
 696                                    LONG_DELAY_MS, MILLISECONDS,
 697                                    new ArrayBlockingQueue&lt;Runnable&gt;(10));
 698         final CountDownLatch threadsStarted = new CountDownLatch(poolSize);
 699         Runnable waiter = new CheckedRunnable() { public void realRun() {
 700             threadsStarted.countDown();
 701             try {
<span class="line-modified"> 702                 MILLISECONDS.sleep(2 * LONG_DELAY_MS);</span>
 703             } catch (InterruptedException success) {}
 704             ran.getAndIncrement();
 705         }};
 706         for (int i = 0; i &lt; count; i++)
 707             p.execute(waiter);
 708         await(threadsStarted);
 709         assertEquals(poolSize, p.getActiveCount());
 710         assertEquals(0, p.getCompletedTaskCount());
 711         final List&lt;Runnable&gt; queuedTasks;
 712         try {
 713             queuedTasks = p.shutdownNow();
 714         } catch (SecurityException ok) {
 715             return; // Allowed in case test doesn&#39;t have privs
 716         }
 717         assertTrue(p.isShutdown());
 718         assertTrue(p.getQueue().isEmpty());
 719         assertEquals(count - poolSize, queuedTasks.size());
 720         assertTrue(p.awaitTermination(LONG_DELAY_MS, MILLISECONDS));
 721         assertTrue(p.isTerminated());
 722         assertEquals(poolSize, ran.get());
</pre>
<hr />
<pre>
1994             thread.set(Thread.currentThread()); }};
1995 
1996         try {
1997             new AbortPolicy().rejectedExecution(r, p);
1998             shouldThrow();
1999         } catch (RejectedExecutionException success) {}
2000         assertNull(thread.get());
2001 
2002         new DiscardPolicy().rejectedExecution(r, p);
2003         assertNull(thread.get());
2004 
2005         new CallerRunsPolicy().rejectedExecution(r, p);
2006         assertSame(Thread.currentThread(), thread.get());
2007 
2008         // check that pool was not perturbed by handlers
2009         assertTrue(p.getRejectedExecutionHandler() instanceof AbortPolicy);
2010         assertEquals(0, p.getTaskCount());
2011         assertTrue(p.getQueue().isEmpty());
2012     }
2013 













































2014 }
</pre>
</td>
<td>
<hr />
<pre>
 682             assertEquals(tasks.length - 2, p.getTaskCount());
 683         }
 684     }
 685 
 686     /**
 687      * shutdownNow returns a list containing tasks that were not run,
 688      * and those tasks are drained from the queue
 689      */
 690     public void testShutdownNow() throws InterruptedException {
 691         final int poolSize = 2;
 692         final int count = 5;
 693         final AtomicInteger ran = new AtomicInteger(0);
 694         final ThreadPoolExecutor p =
 695             new ThreadPoolExecutor(poolSize, poolSize,
 696                                    LONG_DELAY_MS, MILLISECONDS,
 697                                    new ArrayBlockingQueue&lt;Runnable&gt;(10));
 698         final CountDownLatch threadsStarted = new CountDownLatch(poolSize);
 699         Runnable waiter = new CheckedRunnable() { public void realRun() {
 700             threadsStarted.countDown();
 701             try {
<span class="line-modified"> 702                 MILLISECONDS.sleep(LONGER_DELAY_MS);</span>
 703             } catch (InterruptedException success) {}
 704             ran.getAndIncrement();
 705         }};
 706         for (int i = 0; i &lt; count; i++)
 707             p.execute(waiter);
 708         await(threadsStarted);
 709         assertEquals(poolSize, p.getActiveCount());
 710         assertEquals(0, p.getCompletedTaskCount());
 711         final List&lt;Runnable&gt; queuedTasks;
 712         try {
 713             queuedTasks = p.shutdownNow();
 714         } catch (SecurityException ok) {
 715             return; // Allowed in case test doesn&#39;t have privs
 716         }
 717         assertTrue(p.isShutdown());
 718         assertTrue(p.getQueue().isEmpty());
 719         assertEquals(count - poolSize, queuedTasks.size());
 720         assertTrue(p.awaitTermination(LONG_DELAY_MS, MILLISECONDS));
 721         assertTrue(p.isTerminated());
 722         assertEquals(poolSize, ran.get());
</pre>
<hr />
<pre>
1994             thread.set(Thread.currentThread()); }};
1995 
1996         try {
1997             new AbortPolicy().rejectedExecution(r, p);
1998             shouldThrow();
1999         } catch (RejectedExecutionException success) {}
2000         assertNull(thread.get());
2001 
2002         new DiscardPolicy().rejectedExecution(r, p);
2003         assertNull(thread.get());
2004 
2005         new CallerRunsPolicy().rejectedExecution(r, p);
2006         assertSame(Thread.currentThread(), thread.get());
2007 
2008         // check that pool was not perturbed by handlers
2009         assertTrue(p.getRejectedExecutionHandler() instanceof AbortPolicy);
2010         assertEquals(0, p.getTaskCount());
2011         assertTrue(p.getQueue().isEmpty());
2012     }
2013 
<span class="line-added">2014     public void testThreadFactoryReturnsTerminatedThread_shouldThrow() {</span>
<span class="line-added">2015         if (!testImplementationDetails)</span>
<span class="line-added">2016             return;</span>
<span class="line-added">2017 </span>
<span class="line-added">2018         ThreadFactory returnsTerminatedThread = runnableIgnored -&gt; {</span>
<span class="line-added">2019             Thread thread = new Thread(() -&gt; {});</span>
<span class="line-added">2020             thread.start();</span>
<span class="line-added">2021             try { thread.join(); }</span>
<span class="line-added">2022             catch (InterruptedException ex) { throw new Error(ex); }</span>
<span class="line-added">2023             return thread;</span>
<span class="line-added">2024         };</span>
<span class="line-added">2025         ThreadPoolExecutor p =</span>
<span class="line-added">2026             new ThreadPoolExecutor(1, 1, 1, SECONDS,</span>
<span class="line-added">2027                                    new ArrayBlockingQueue&lt;Runnable&gt;(1),</span>
<span class="line-added">2028                                    returnsTerminatedThread);</span>
<span class="line-added">2029         try (PoolCleaner cleaner = cleaner(p)) {</span>
<span class="line-added">2030             assertThrows(IllegalThreadStateException.class,</span>
<span class="line-added">2031                          () -&gt; p.execute(() -&gt; {}));</span>
<span class="line-added">2032         }</span>
<span class="line-added">2033     }</span>
<span class="line-added">2034 </span>
<span class="line-added">2035     public void testThreadFactoryReturnsStartedThread_shouldThrow() {</span>
<span class="line-added">2036         if (!testImplementationDetails)</span>
<span class="line-added">2037             return;</span>
<span class="line-added">2038 </span>
<span class="line-added">2039         CountDownLatch latch = new CountDownLatch(1);</span>
<span class="line-added">2040         Runnable awaitLatch = () -&gt; {</span>
<span class="line-added">2041             try { latch.await(); }</span>
<span class="line-added">2042             catch (InterruptedException ex) { throw new Error(ex); }};</span>
<span class="line-added">2043         ThreadFactory returnsStartedThread = runnable -&gt; {</span>
<span class="line-added">2044             Thread thread = new Thread(awaitLatch);</span>
<span class="line-added">2045             thread.start();</span>
<span class="line-added">2046             return thread;</span>
<span class="line-added">2047         };</span>
<span class="line-added">2048         ThreadPoolExecutor p =</span>
<span class="line-added">2049             new ThreadPoolExecutor(1, 1, 1, SECONDS,</span>
<span class="line-added">2050                                    new ArrayBlockingQueue&lt;Runnable&gt;(1),</span>
<span class="line-added">2051                                    returnsStartedThread);</span>
<span class="line-added">2052         try (PoolCleaner cleaner = cleaner(p)) {</span>
<span class="line-added">2053             assertThrows(IllegalThreadStateException.class,</span>
<span class="line-added">2054                          () -&gt; p.execute(() -&gt; {}));</span>
<span class="line-added">2055             latch.countDown();</span>
<span class="line-added">2056         }</span>
<span class="line-added">2057     }</span>
<span class="line-added">2058 </span>
2059 }
</pre>
</td>
</tr>
</table>
<center><a href="ThreadPoolExecutorSubclassTest.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="TimeUnitTest.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
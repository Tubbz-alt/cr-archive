<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff test/jdk/java/util/concurrent/tck/ReentrantReadWriteLockTest.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
<body>
<center><a href="ReentrantLockTest.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="ScheduledExecutorSubclassTest.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>test/jdk/java/util/concurrent/tck/ReentrantReadWriteLockTest.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  21  */
  22 
  23 /*
  24  * This file is available under and governed by the GNU General Public
  25  * License version 2 only, as published by the Free Software Foundation.
  26  * However, the following notice accompanied the original version of this
  27  * file:
  28  *
  29  * Written by Doug Lea with assistance from members of JCP JSR-166
  30  * Expert Group and released to the public domain, as explained at
  31  * http://creativecommons.org/publicdomain/zero/1.0/
  32  * Other contributors include Andrew Wright, Jeffrey Hayes,
  33  * Pat Fisher, Mike Judd.
  34  */
  35 
  36 import static java.util.concurrent.TimeUnit.MILLISECONDS;
  37 
  38 import java.util.Arrays;
  39 import java.util.Collection;
  40 import java.util.HashSet;

  41 import java.util.concurrent.CountDownLatch;
  42 import java.util.concurrent.atomic.AtomicBoolean;
  43 import java.util.concurrent.locks.Condition;
  44 import java.util.concurrent.locks.Lock;
  45 import java.util.concurrent.locks.ReentrantReadWriteLock;
  46 
  47 import junit.framework.Test;
  48 import junit.framework.TestSuite;
  49 
  50 @SuppressWarnings(&quot;WaitNotInLoop&quot;) // we implement spurious-wakeup freedom
  51 public class ReentrantReadWriteLockTest extends JSR166TestCase {
  52     public static void main(String[] args) {
  53         main(suite(), args);
  54     }
  55     public static Test suite() {
  56         return new TestSuite(ReentrantReadWriteLockTest.class);
  57     }
  58 
  59     /**
  60      * A runnable calling lockInterruptibly
</pre>
<hr />
<pre>
1690         lock.readLock().unlock();
1691         assertTrue(lock.readLock().toString().contains(&quot;Read locks = 1&quot;));
1692         lock.readLock().unlock();
1693         assertTrue(lock.readLock().toString().contains(&quot;Read locks = 0&quot;));
1694     }
1695 
1696     /**
1697      * writeLock.toString indicates current lock state
1698      */
1699     public void testWriteLockToString()      { testWriteLockToString(false); }
1700     public void testWriteLockToString_fair() { testWriteLockToString(true); }
1701     public void testWriteLockToString(boolean fair) {
1702         final ReentrantReadWriteLock lock = new ReentrantReadWriteLock(fair);
1703         assertTrue(lock.writeLock().toString().contains(&quot;Unlocked&quot;));
1704         lock.writeLock().lock();
1705         assertTrue(lock.writeLock().toString().contains(&quot;Locked by&quot;));
1706         lock.writeLock().unlock();
1707         assertTrue(lock.writeLock().toString().contains(&quot;Unlocked&quot;));
1708     }
1709 




























































1710 }
</pre>
</td>
<td>
<hr />
<pre>
  21  */
  22 
  23 /*
  24  * This file is available under and governed by the GNU General Public
  25  * License version 2 only, as published by the Free Software Foundation.
  26  * However, the following notice accompanied the original version of this
  27  * file:
  28  *
  29  * Written by Doug Lea with assistance from members of JCP JSR-166
  30  * Expert Group and released to the public domain, as explained at
  31  * http://creativecommons.org/publicdomain/zero/1.0/
  32  * Other contributors include Andrew Wright, Jeffrey Hayes,
  33  * Pat Fisher, Mike Judd.
  34  */
  35 
  36 import static java.util.concurrent.TimeUnit.MILLISECONDS;
  37 
  38 import java.util.Arrays;
  39 import java.util.Collection;
  40 import java.util.HashSet;
<span class="line-added">  41 import java.util.concurrent.Callable;</span>
  42 import java.util.concurrent.CountDownLatch;
  43 import java.util.concurrent.atomic.AtomicBoolean;
  44 import java.util.concurrent.locks.Condition;
  45 import java.util.concurrent.locks.Lock;
  46 import java.util.concurrent.locks.ReentrantReadWriteLock;
  47 
  48 import junit.framework.Test;
  49 import junit.framework.TestSuite;
  50 
  51 @SuppressWarnings(&quot;WaitNotInLoop&quot;) // we implement spurious-wakeup freedom
  52 public class ReentrantReadWriteLockTest extends JSR166TestCase {
  53     public static void main(String[] args) {
  54         main(suite(), args);
  55     }
  56     public static Test suite() {
  57         return new TestSuite(ReentrantReadWriteLockTest.class);
  58     }
  59 
  60     /**
  61      * A runnable calling lockInterruptibly
</pre>
<hr />
<pre>
1691         lock.readLock().unlock();
1692         assertTrue(lock.readLock().toString().contains(&quot;Read locks = 1&quot;));
1693         lock.readLock().unlock();
1694         assertTrue(lock.readLock().toString().contains(&quot;Read locks = 0&quot;));
1695     }
1696 
1697     /**
1698      * writeLock.toString indicates current lock state
1699      */
1700     public void testWriteLockToString()      { testWriteLockToString(false); }
1701     public void testWriteLockToString_fair() { testWriteLockToString(true); }
1702     public void testWriteLockToString(boolean fair) {
1703         final ReentrantReadWriteLock lock = new ReentrantReadWriteLock(fair);
1704         assertTrue(lock.writeLock().toString().contains(&quot;Unlocked&quot;));
1705         lock.writeLock().lock();
1706         assertTrue(lock.writeLock().toString().contains(&quot;Locked by&quot;));
1707         lock.writeLock().unlock();
1708         assertTrue(lock.writeLock().toString().contains(&quot;Unlocked&quot;));
1709     }
1710 
<span class="line-added">1711     /**</span>
<span class="line-added">1712      * ThreadMXBean reports the blockers that we expect.</span>
<span class="line-added">1713      */</span>
<span class="line-added">1714     public void testBlockers() {</span>
<span class="line-added">1715         if (!testImplementationDetails) return;</span>
<span class="line-added">1716         final boolean fair = randomBoolean();</span>
<span class="line-added">1717         final boolean timedAcquire = randomBoolean();</span>
<span class="line-added">1718         final boolean timedAwait = randomBoolean();</span>
<span class="line-added">1719         final String syncClassName = fair</span>
<span class="line-added">1720             ? &quot;ReentrantReadWriteLock$FairSync&quot;</span>
<span class="line-added">1721             : &quot;ReentrantReadWriteLock$NonfairSync&quot;;</span>
<span class="line-added">1722         final String conditionClassName</span>
<span class="line-added">1723             = &quot;AbstractQueuedSynchronizer$ConditionObject&quot;;</span>
<span class="line-added">1724         final Thread.State expectedAcquireState = timedAcquire</span>
<span class="line-added">1725             ? Thread.State.TIMED_WAITING</span>
<span class="line-added">1726             : Thread.State.WAITING;</span>
<span class="line-added">1727         final Thread.State expectedAwaitState = timedAwait</span>
<span class="line-added">1728             ? Thread.State.TIMED_WAITING</span>
<span class="line-added">1729             : Thread.State.WAITING;</span>
<span class="line-added">1730         final Lock lock = new ReentrantReadWriteLock(fair).writeLock();</span>
<span class="line-added">1731         final Condition condition = lock.newCondition();</span>
<span class="line-added">1732         final AtomicBoolean conditionSatisfied = new AtomicBoolean(false);</span>
<span class="line-added">1733         lock.lock();</span>
<span class="line-added">1734         final Thread thread = newStartedThread((Action) () -&gt; {</span>
<span class="line-added">1735             if (timedAcquire)</span>
<span class="line-added">1736                 lock.tryLock(LONGER_DELAY_MS, MILLISECONDS);</span>
<span class="line-added">1737             else</span>
<span class="line-added">1738                 lock.lock();</span>
<span class="line-added">1739             while (!conditionSatisfied.get())</span>
<span class="line-added">1740                 if (timedAwait)</span>
<span class="line-added">1741                     condition.await(LONGER_DELAY_MS, MILLISECONDS);</span>
<span class="line-added">1742                 else</span>
<span class="line-added">1743                     condition.await();</span>
<span class="line-added">1744         });</span>
<span class="line-added">1745         Callable&lt;Boolean&gt; waitingForLock = () -&gt; {</span>
<span class="line-added">1746             String className;</span>
<span class="line-added">1747             return thread.getState() == expectedAcquireState</span>
<span class="line-added">1748             &amp;&amp; (className = blockerClassName(thread)) != null</span>
<span class="line-added">1749             &amp;&amp; className.endsWith(syncClassName);</span>
<span class="line-added">1750         };</span>
<span class="line-added">1751         waitForThreadToEnterWaitState(thread, waitingForLock);</span>
<span class="line-added">1752 </span>
<span class="line-added">1753         lock.unlock();</span>
<span class="line-added">1754         Callable&lt;Boolean&gt; waitingForCondition = () -&gt; {</span>
<span class="line-added">1755             String className;</span>
<span class="line-added">1756             return thread.getState() == expectedAwaitState</span>
<span class="line-added">1757             &amp;&amp; (className = blockerClassName(thread)) != null</span>
<span class="line-added">1758             &amp;&amp; className.endsWith(conditionClassName);</span>
<span class="line-added">1759         };</span>
<span class="line-added">1760         waitForThreadToEnterWaitState(thread, waitingForCondition);</span>
<span class="line-added">1761 </span>
<span class="line-added">1762         // politely release the waiter</span>
<span class="line-added">1763         conditionSatisfied.set(true);</span>
<span class="line-added">1764         lock.lock();</span>
<span class="line-added">1765         try {</span>
<span class="line-added">1766             condition.signal();</span>
<span class="line-added">1767         } finally { lock.unlock(); }</span>
<span class="line-added">1768 </span>
<span class="line-added">1769         awaitTermination(thread);</span>
<span class="line-added">1770     }</span>
1771 }
</pre>
</td>
</tr>
</table>
<center><a href="ReentrantLockTest.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="ScheduledExecutorSubclassTest.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
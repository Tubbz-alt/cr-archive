<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New test/jdk/java/util/concurrent/tck/LinkedTransferQueueTest.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   3  *
   4  * This code is free software; you can redistribute it and/or modify it
   5  * under the terms of the GNU General Public License version 2 only, as
   6  * published by the Free Software Foundation.
   7  *
   8  * This code is distributed in the hope that it will be useful, but WITHOUT
   9  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  10  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  11  * version 2 for more details (a copy is included in the LICENSE file that
  12  * accompanied this code).
  13  *
  14  * You should have received a copy of the GNU General Public License version
  15  * 2 along with this work; if not, write to the Free Software Foundation,
  16  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  17  *
  18  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  19  * or visit www.oracle.com if you need additional information or have any
  20  * questions.
  21  */
  22 
  23 /*
  24  * This file is available under and governed by the GNU General Public
  25  * License version 2 only, as published by the Free Software Foundation.
  26  * However, the following notice accompanied the original version of this
  27  * file:
  28  *
  29  * Written by Doug Lea with assistance from members of JCP JSR-166
  30  * Expert Group and released to the public domain, as explained at
  31  * http://creativecommons.org/publicdomain/zero/1.0/
  32  * Other contributors include John Vint
  33  */
  34 
  35 import static java.util.concurrent.TimeUnit.MILLISECONDS;
  36 
  37 import java.util.ArrayList;
  38 import java.util.Arrays;
  39 import java.util.Collection;
  40 import java.util.Iterator;
  41 import java.util.List;
  42 import java.util.NoSuchElementException;
  43 import java.util.Queue;
  44 import java.util.concurrent.BlockingQueue;
  45 import java.util.concurrent.Callable;
  46 import java.util.concurrent.CountDownLatch;
  47 import java.util.concurrent.Executors;
  48 import java.util.concurrent.ExecutorService;
  49 import java.util.concurrent.LinkedTransferQueue;
  50 
  51 import junit.framework.Test;
  52 
  53 @SuppressWarnings({&quot;unchecked&quot;, &quot;rawtypes&quot;})
  54 public class LinkedTransferQueueTest extends JSR166TestCase {
  55     public static class Generic extends BlockingQueueTest {
  56         protected BlockingQueue emptyCollection() {
  57             return new LinkedTransferQueue();
  58         }
  59     }
  60 
  61     public static void main(String[] args) {
  62         main(suite(), args);
  63     }
  64 
  65     public static Test suite() {
  66         class Implementation implements CollectionImplementation {
  67             public Class&lt;?&gt; klazz() { return LinkedTransferQueue.class; }
  68             public Collection emptyCollection() { return new LinkedTransferQueue(); }
  69             public Object makeElement(int i) { return i; }
  70             public boolean isConcurrent() { return true; }
  71             public boolean permitsNulls() { return false; }
  72         }
  73         return newTestSuite(LinkedTransferQueueTest.class,
  74                             new Generic().testSuite(),
  75                             CollectionTest.testSuite(new Implementation()));
  76     }
  77 
  78     /**
  79      * Constructor builds new queue with size being zero and empty
  80      * being true
  81      */
  82     public void testConstructor1() {
  83         assertEquals(0, new LinkedTransferQueue().size());
  84         assertTrue(new LinkedTransferQueue().isEmpty());
  85     }
  86 
  87     /**
  88      * Initializing constructor with null collection throws
  89      * NullPointerException
  90      */
  91     public void testConstructor2() {
  92         try {
  93             new LinkedTransferQueue(null);
  94             shouldThrow();
  95         } catch (NullPointerException success) {}
  96     }
  97 
  98     /**
  99      * Initializing from Collection of null elements throws
 100      * NullPointerException
 101      */
 102     public void testConstructor3() {
 103         Collection&lt;Integer&gt; elements = Arrays.asList(new Integer[SIZE]);
 104         try {
 105             new LinkedTransferQueue(elements);
 106             shouldThrow();
 107         } catch (NullPointerException success) {}
 108     }
 109 
 110     /**
 111      * Initializing constructor with a collection containing some null elements
 112      * throws NullPointerException
 113      */
 114     public void testConstructor4() {
 115         Integer[] ints = new Integer[SIZE];
 116         for (int i = 0; i &lt; SIZE - 1; ++i)
 117             ints[i] = i;
 118         Collection&lt;Integer&gt; elements = Arrays.asList(ints);
 119         try {
 120             new LinkedTransferQueue(elements);
 121             shouldThrow();
 122         } catch (NullPointerException success) {}
 123     }
 124 
 125     /**
 126      * Queue contains all elements of the collection it is initialized by
 127      */
 128     public void testConstructor5() {
 129         Integer[] ints = new Integer[SIZE];
 130         for (int i = 0; i &lt; SIZE; ++i) {
 131             ints[i] = i;
 132         }
 133         List intList = Arrays.asList(ints);
 134         LinkedTransferQueue q
 135             = new LinkedTransferQueue(intList);
 136         assertEquals(q.size(), intList.size());
 137         assertEquals(q.toString(), intList.toString());
 138         assertTrue(Arrays.equals(q.toArray(),
 139                                      intList.toArray()));
 140         assertTrue(Arrays.equals(q.toArray(new Object[0]),
 141                                  intList.toArray(new Object[0])));
 142         assertTrue(Arrays.equals(q.toArray(new Object[SIZE]),
 143                                  intList.toArray(new Object[SIZE])));
 144         for (int i = 0; i &lt; SIZE; ++i) {
 145             assertEquals(ints[i], q.poll());
 146         }
 147     }
 148 
 149     /**
 150      * remainingCapacity() always returns Integer.MAX_VALUE
 151      */
 152     public void testRemainingCapacity() {
 153         BlockingQueue q = populatedQueue(SIZE);
 154         for (int i = 0; i &lt; SIZE; ++i) {
 155             assertEquals(Integer.MAX_VALUE, q.remainingCapacity());
 156             assertEquals(SIZE - i, q.size());
 157             assertEquals(i, q.remove());
 158         }
 159         for (int i = 0; i &lt; SIZE; ++i) {
 160             assertEquals(Integer.MAX_VALUE, q.remainingCapacity());
 161             assertEquals(i, q.size());
 162             assertTrue(q.add(i));
 163         }
 164     }
 165 
 166     /**
 167      * addAll(this) throws IllegalArgumentException
 168      */
 169     public void testAddAllSelf() {
 170         LinkedTransferQueue q = populatedQueue(SIZE);
 171         try {
 172             q.addAll(q);
 173             shouldThrow();
 174         } catch (IllegalArgumentException success) {}
 175     }
 176 
 177     /**
 178      * addAll of a collection with any null elements throws
 179      * NullPointerException after possibly adding some elements
 180      */
 181     public void testAddAll3() {
 182         LinkedTransferQueue q = new LinkedTransferQueue();
 183         Integer[] ints = new Integer[SIZE];
 184         for (int i = 0; i &lt; SIZE - 1; ++i)
 185             ints[i] = i;
 186         try {
 187             q.addAll(Arrays.asList(ints));
 188             shouldThrow();
 189         } catch (NullPointerException success) {}
 190     }
 191 
 192     /**
 193      * Queue contains all elements, in traversal order, of successful addAll
 194      */
 195     public void testAddAll5() {
 196         Integer[] empty = new Integer[0];
 197         Integer[] ints = new Integer[SIZE];
 198         for (int i = 0; i &lt; SIZE; ++i) {
 199             ints[i] = i;
 200         }
 201         LinkedTransferQueue q = new LinkedTransferQueue();
 202         assertFalse(q.addAll(Arrays.asList(empty)));
 203         assertTrue(q.addAll(Arrays.asList(ints)));
 204         for (int i = 0; i &lt; SIZE; ++i) {
 205             assertEquals(ints[i], q.poll());
 206         }
 207     }
 208 
 209     /**
 210      * all elements successfully put are contained
 211      */
 212     public void testPut() {
 213         LinkedTransferQueue&lt;Integer&gt; q = new LinkedTransferQueue&lt;&gt;();
 214         for (int i = 0; i &lt; SIZE; ++i) {
 215             assertEquals(i, q.size());
 216             q.put(i);
 217             assertTrue(q.contains(i));
 218         }
 219     }
 220 
 221     /**
 222      * take retrieves elements in FIFO order
 223      */
 224     public void testTake() throws InterruptedException {
 225         LinkedTransferQueue&lt;Integer&gt; q = populatedQueue(SIZE);
 226         for (int i = 0; i &lt; SIZE; ++i) {
 227             assertEquals(i, (int) q.take());
 228         }
 229     }
 230 
 231     /**
 232      * take removes existing elements until empty, then blocks interruptibly
 233      */
 234     public void testBlockingTake() throws InterruptedException {
 235         final BlockingQueue q = populatedQueue(SIZE);
 236         final CountDownLatch pleaseInterrupt = new CountDownLatch(1);
 237         Thread t = newStartedThread(new CheckedRunnable() {
 238             public void realRun() throws InterruptedException {
 239                 for (int i = 0; i &lt; SIZE; i++) assertEquals(i, q.take());
 240 
 241                 Thread.currentThread().interrupt();
 242                 try {
 243                     q.take();
 244                     shouldThrow();
 245                 } catch (InterruptedException success) {}
 246                 assertFalse(Thread.interrupted());
 247 
 248                 pleaseInterrupt.countDown();
 249                 try {
 250                     q.take();
 251                     shouldThrow();
 252                 } catch (InterruptedException success) {}
 253                 assertFalse(Thread.interrupted());
 254             }});
 255 
 256         await(pleaseInterrupt);
 257         if (randomBoolean()) assertThreadBlocks(t, Thread.State.WAITING);
 258         t.interrupt();
 259         awaitTermination(t);
 260     }
 261 
 262     /**
 263      * poll succeeds unless empty
 264      */
 265     public void testPoll() throws InterruptedException {
 266         LinkedTransferQueue&lt;Integer&gt; q = populatedQueue(SIZE);
 267         for (int i = 0; i &lt; SIZE; ++i) {
 268             assertEquals(i, (int) q.poll());
 269         }
 270         assertNull(q.poll());
 271         checkEmpty(q);
 272     }
 273 
 274     /**
 275      * timed poll with zero timeout succeeds when non-empty, else times out
 276      */
 277     public void testTimedPoll0() throws InterruptedException {
 278         LinkedTransferQueue&lt;Integer&gt; q = populatedQueue(SIZE);
 279         for (int i = 0; i &lt; SIZE; ++i) {
 280             assertEquals(i, (int) q.poll(0, MILLISECONDS));
 281         }
 282         assertNull(q.poll(0, MILLISECONDS));
 283         checkEmpty(q);
 284     }
 285 
 286     /**
 287      * timed poll with nonzero timeout succeeds when non-empty, else times out
 288      */
 289     public void testTimedPoll() throws InterruptedException {
 290         LinkedTransferQueue&lt;Integer&gt; q = populatedQueue(SIZE);
 291         long startTime = System.nanoTime();
 292         for (int i = 0; i &lt; SIZE; ++i)
 293             assertEquals(i, (int) q.poll(LONG_DELAY_MS, MILLISECONDS));
 294         assertTrue(millisElapsedSince(startTime) &lt; LONG_DELAY_MS);
 295 
 296         startTime = System.nanoTime();
 297         assertNull(q.poll(timeoutMillis(), MILLISECONDS));
 298         assertTrue(millisElapsedSince(startTime) &gt;= timeoutMillis());
 299         checkEmpty(q);
 300     }
 301 
 302     /**
 303      * Interrupted timed poll throws InterruptedException instead of
 304      * returning timeout status
 305      */
 306     public void testInterruptedTimedPoll() throws InterruptedException {
 307         final BlockingQueue&lt;Integer&gt; q = populatedQueue(SIZE);
 308         final CountDownLatch pleaseInterrupt = new CountDownLatch(1);
 309         Thread t = newStartedThread(new CheckedRunnable() {
 310             public void realRun() throws InterruptedException {
 311                 for (int i = 0; i &lt; SIZE; i++)
 312                     assertEquals(i, (int) q.poll(LONG_DELAY_MS, MILLISECONDS));
 313 
 314                 Thread.currentThread().interrupt();
 315                 try {
 316                     q.poll(randomTimeout(), randomTimeUnit());
 317                     shouldThrow();
 318                 } catch (InterruptedException success) {}
 319                 assertFalse(Thread.interrupted());
 320 
 321                 pleaseInterrupt.countDown();
 322                 try {
 323                     q.poll(LONGER_DELAY_MS, MILLISECONDS);
 324                     shouldThrow();
 325                 } catch (InterruptedException success) {}
 326                 assertFalse(Thread.interrupted());
 327             }});
 328 
 329         await(pleaseInterrupt);
 330         if (randomBoolean()) assertThreadBlocks(t, Thread.State.TIMED_WAITING);
 331         t.interrupt();
 332         awaitTermination(t);
 333         checkEmpty(q);
 334     }
 335 
 336     /**
 337      * timed poll after thread interrupted throws InterruptedException
 338      * instead of returning timeout status
 339      */
 340     public void testTimedPollAfterInterrupt() throws InterruptedException {
 341         final BlockingQueue&lt;Integer&gt; q = populatedQueue(SIZE);
 342         Thread t = newStartedThread(new CheckedRunnable() {
 343             public void realRun() throws InterruptedException {
 344                 Thread.currentThread().interrupt();
 345                 for (int i = 0; i &lt; SIZE; ++i)
 346                     assertEquals(i, (int) q.poll(randomTimeout(), randomTimeUnit()));
 347                 try {
 348                     q.poll(randomTimeout(), randomTimeUnit());
 349                     shouldThrow();
 350                 } catch (InterruptedException success) {}
 351                 assertFalse(Thread.interrupted());
 352             }});
 353 
 354         awaitTermination(t);
 355         checkEmpty(q);
 356     }
 357 
 358     /**
 359      * peek returns next element, or null if empty
 360      */
 361     public void testPeek() throws InterruptedException {
 362         LinkedTransferQueue&lt;Integer&gt; q = populatedQueue(SIZE);
 363         for (int i = 0; i &lt; SIZE; ++i) {
 364             assertEquals(i, (int) q.peek());
 365             assertEquals(i, (int) q.poll());
 366             assertTrue(q.peek() == null ||
 367                        i != (int) q.peek());
 368         }
 369         assertNull(q.peek());
 370         checkEmpty(q);
 371     }
 372 
 373     /**
 374      * element returns next element, or throws NoSuchElementException if empty
 375      */
 376     public void testElement() throws InterruptedException {
 377         LinkedTransferQueue&lt;Integer&gt; q = populatedQueue(SIZE);
 378         for (int i = 0; i &lt; SIZE; ++i) {
 379             assertEquals(i, (int) q.element());
 380             assertEquals(i, (int) q.poll());
 381         }
 382         try {
 383             q.element();
 384             shouldThrow();
 385         } catch (NoSuchElementException success) {}
 386         checkEmpty(q);
 387     }
 388 
 389     /**
 390      * remove removes next element, or throws NoSuchElementException if empty
 391      */
 392     public void testRemove() throws InterruptedException {
 393         LinkedTransferQueue&lt;Integer&gt; q = populatedQueue(SIZE);
 394         for (int i = 0; i &lt; SIZE; ++i) {
 395             assertEquals(i, (int) q.remove());
 396         }
 397         try {
 398             q.remove();
 399             shouldThrow();
 400         } catch (NoSuchElementException success) {}
 401         checkEmpty(q);
 402     }
 403 
 404     /**
 405      * An add following remove(x) succeeds
 406      */
 407     public void testRemoveElementAndAdd() throws InterruptedException {
 408         LinkedTransferQueue q = new LinkedTransferQueue();
 409         assertTrue(q.add(one));
 410         assertTrue(q.add(two));
 411         assertTrue(q.remove(one));
 412         assertTrue(q.remove(two));
 413         assertTrue(q.add(three));
 414         assertSame(q.take(), three);
 415     }
 416 
 417     /**
 418      * contains(x) reports true when elements added but not yet removed
 419      */
 420     public void testContains() {
 421         LinkedTransferQueue&lt;Integer&gt; q = populatedQueue(SIZE);
 422         for (int i = 0; i &lt; SIZE; ++i) {
 423             assertTrue(q.contains(i));
 424             assertEquals(i, (int) q.poll());
 425             assertFalse(q.contains(i));
 426         }
 427     }
 428 
 429     /**
 430      * clear removes all elements
 431      */
 432     public void testClear() throws InterruptedException {
 433         LinkedTransferQueue q = populatedQueue(SIZE);
 434         q.clear();
 435         checkEmpty(q);
 436         assertEquals(Integer.MAX_VALUE, q.remainingCapacity());
 437         q.add(one);
 438         assertFalse(q.isEmpty());
 439         assertEquals(1, q.size());
 440         assertTrue(q.contains(one));
 441         q.clear();
 442         checkEmpty(q);
 443     }
 444 
 445     /**
 446      * containsAll(c) is true when c contains a subset of elements
 447      */
 448     public void testContainsAll() {
 449         LinkedTransferQueue&lt;Integer&gt; q = populatedQueue(SIZE);
 450         LinkedTransferQueue&lt;Integer&gt; p = new LinkedTransferQueue&lt;&gt;();
 451         for (int i = 0; i &lt; SIZE; ++i) {
 452             assertTrue(q.containsAll(p));
 453             assertFalse(p.containsAll(q));
 454             p.add(i);
 455         }
 456         assertTrue(p.containsAll(q));
 457     }
 458 
 459     /**
 460      * retainAll(c) retains only those elements of c and reports true
 461      * if changed
 462      */
 463     public void testRetainAll() {
 464         LinkedTransferQueue q = populatedQueue(SIZE);
 465         LinkedTransferQueue p = populatedQueue(SIZE);
 466         for (int i = 0; i &lt; SIZE; ++i) {
 467             boolean changed = q.retainAll(p);
 468             if (i == 0) {
 469                 assertFalse(changed);
 470             } else {
 471                 assertTrue(changed);
 472             }
 473             assertTrue(q.containsAll(p));
 474             assertEquals(SIZE - i, q.size());
 475             p.remove();
 476         }
 477     }
 478 
 479     /**
 480      * removeAll(c) removes only those elements of c and reports true
 481      * if changed
 482      */
 483     public void testRemoveAll() {
 484         for (int i = 1; i &lt; SIZE; ++i) {
 485             LinkedTransferQueue q = populatedQueue(SIZE);
 486             LinkedTransferQueue p = populatedQueue(i);
 487             assertTrue(q.removeAll(p));
 488             assertEquals(SIZE - i, q.size());
 489             for (int j = 0; j &lt; i; ++j) {
 490                 assertFalse(q.contains(p.remove()));
 491             }
 492         }
 493     }
 494 
 495     /**
 496      * toArray() contains all elements in FIFO order
 497      */
 498     public void testToArray() {
 499         LinkedTransferQueue q = populatedQueue(SIZE);
 500         Object[] a = q.toArray();
 501         assertSame(Object[].class, a.getClass());
 502         for (Object o : a)
 503             assertSame(o, q.poll());
 504         assertTrue(q.isEmpty());
 505     }
 506 
 507     /**
 508      * toArray(a) contains all elements in FIFO order
 509      */
 510     public void testToArray2() {
 511         LinkedTransferQueue&lt;Integer&gt; q = populatedQueue(SIZE);
 512         Integer[] ints = new Integer[SIZE];
 513         Integer[] array = q.toArray(ints);
 514         assertSame(ints, array);
 515         for (Integer o : ints)
 516             assertSame(o, q.poll());
 517         assertTrue(q.isEmpty());
 518     }
 519 
 520     /**
 521      * toArray(incompatible array type) throws ArrayStoreException
 522      */
 523     public void testToArray1_BadArg() {
 524         LinkedTransferQueue q = populatedQueue(SIZE);
 525         try {
 526             q.toArray(new String[10]);
 527             shouldThrow();
 528         } catch (ArrayStoreException success) {}
 529     }
 530 
 531     /**
 532      * iterator iterates through all elements
 533      */
 534     public void testIterator() throws InterruptedException {
 535         LinkedTransferQueue q = populatedQueue(SIZE);
 536         Iterator it = q.iterator();
 537         int i;
 538         for (i = 0; it.hasNext(); i++)
 539             assertTrue(q.contains(it.next()));
 540         assertEquals(i, SIZE);
 541         assertIteratorExhausted(it);
 542 
 543         it = q.iterator();
 544         for (i = 0; it.hasNext(); i++)
 545             assertEquals(it.next(), q.take());
 546         assertEquals(i, SIZE);
 547         assertIteratorExhausted(it);
 548     }
 549 
 550     /**
 551      * iterator of empty collection has no elements
 552      */
 553     public void testEmptyIterator() {
 554         assertIteratorExhausted(new LinkedTransferQueue().iterator());
 555     }
 556 
 557     /**
 558      * iterator.remove() removes current element
 559      */
 560     public void testIteratorRemove() {
 561         final LinkedTransferQueue q = new LinkedTransferQueue();
 562         q.add(two);
 563         q.add(one);
 564         q.add(three);
 565 
 566         Iterator it = q.iterator();
 567         it.next();
 568         it.remove();
 569 
 570         it = q.iterator();
 571         assertSame(it.next(), one);
 572         assertSame(it.next(), three);
 573         assertFalse(it.hasNext());
 574     }
 575 
 576     /**
 577      * iterator ordering is FIFO
 578      */
 579     public void testIteratorOrdering() {
 580         final LinkedTransferQueue&lt;Integer&gt; q = new LinkedTransferQueue&lt;&gt;();
 581         assertEquals(Integer.MAX_VALUE, q.remainingCapacity());
 582         q.add(one);
 583         q.add(two);
 584         q.add(three);
 585         assertEquals(Integer.MAX_VALUE, q.remainingCapacity());
 586         int k = 0;
 587         for (Integer n : q) {
 588             assertEquals(++k, (int) n);
 589         }
 590         assertEquals(3, k);
 591     }
 592 
 593     /**
 594      * Modifications do not cause iterators to fail
 595      */
 596     public void testWeaklyConsistentIteration() {
 597         final LinkedTransferQueue q = new LinkedTransferQueue();
 598         q.add(one);
 599         q.add(two);
 600         q.add(three);
 601         for (Iterator it = q.iterator(); it.hasNext();) {
 602             q.remove();
 603             it.next();
 604         }
 605         assertEquals(0, q.size());
 606     }
 607 
 608     /**
 609      * toString contains toStrings of elements
 610      */
 611     public void testToString() {
 612         LinkedTransferQueue q = populatedQueue(SIZE);
 613         String s = q.toString();
 614         for (int i = 0; i &lt; SIZE; ++i) {
 615             assertTrue(s.contains(String.valueOf(i)));
 616         }
 617     }
 618 
 619     /**
 620      * offer transfers elements across Executor tasks
 621      */
 622     public void testOfferInExecutor() {
 623         final LinkedTransferQueue q = new LinkedTransferQueue();
 624         final CheckedBarrier threadsStarted = new CheckedBarrier(2);
 625         final ExecutorService executor = Executors.newFixedThreadPool(2);
 626         try (PoolCleaner cleaner = cleaner(executor)) {
 627 
 628             executor.execute(new CheckedRunnable() {
 629                 public void realRun() throws InterruptedException {
 630                     threadsStarted.await();
 631                     long startTime = System.nanoTime();
 632                     assertTrue(q.offer(one, LONG_DELAY_MS, MILLISECONDS));
 633                     assertTrue(millisElapsedSince(startTime) &lt; LONG_DELAY_MS);
 634                 }});
 635 
 636             executor.execute(new CheckedRunnable() {
 637                 public void realRun() throws InterruptedException {
 638                     threadsStarted.await();
 639                     assertSame(one, q.take());
 640                     checkEmpty(q);
 641                 }});
 642         }
 643     }
 644 
 645     /**
 646      * timed poll retrieves elements across Executor threads
 647      */
 648     public void testPollInExecutor() {
 649         final LinkedTransferQueue q = new LinkedTransferQueue();
 650         final CheckedBarrier threadsStarted = new CheckedBarrier(2);
 651         final ExecutorService executor = Executors.newFixedThreadPool(2);
 652         try (PoolCleaner cleaner = cleaner(executor)) {
 653 
 654             executor.execute(new CheckedRunnable() {
 655                 public void realRun() throws InterruptedException {
 656                     assertNull(q.poll());
 657                     threadsStarted.await();
 658                     long startTime = System.nanoTime();
 659                     assertSame(one, q.poll(LONG_DELAY_MS, MILLISECONDS));
 660                     assertTrue(millisElapsedSince(startTime) &lt; LONG_DELAY_MS);
 661                     checkEmpty(q);
 662                 }});
 663 
 664             executor.execute(new CheckedRunnable() {
 665                 public void realRun() throws InterruptedException {
 666                     threadsStarted.await();
 667                     q.put(one);
 668                 }});
 669         }
 670     }
 671 
 672     /**
 673      * A deserialized/reserialized queue has same elements in same order
 674      */
 675     public void testSerialization() throws Exception {
 676         Queue x = populatedQueue(SIZE);
 677         Queue y = serialClone(x);
 678 
 679         assertNotSame(y, x);
 680         assertEquals(x.size(), y.size());
 681         assertEquals(x.toString(), y.toString());
 682         assertTrue(Arrays.equals(x.toArray(), y.toArray()));
 683         while (!x.isEmpty()) {
 684             assertFalse(y.isEmpty());
 685             assertEquals(x.remove(), y.remove());
 686         }
 687         assertTrue(y.isEmpty());
 688     }
 689 
 690     /**
 691      * drainTo(c) empties queue into another collection c
 692      */
 693     public void testDrainTo() {
 694         LinkedTransferQueue q = populatedQueue(SIZE);
 695         ArrayList l = new ArrayList();
 696         q.drainTo(l);
 697         assertEquals(0, q.size());
 698         assertEquals(SIZE, l.size());
 699         for (int i = 0; i &lt; SIZE; ++i) {
 700             assertEquals(i, l.get(i));
 701         }
 702         q.add(zero);
 703         q.add(one);
 704         assertFalse(q.isEmpty());
 705         assertTrue(q.contains(zero));
 706         assertTrue(q.contains(one));
 707         l.clear();
 708         q.drainTo(l);
 709         assertEquals(0, q.size());
 710         assertEquals(2, l.size());
 711         for (int i = 0; i &lt; 2; ++i) {
 712             assertEquals(i, l.get(i));
 713         }
 714     }
 715 
 716     /**
 717      * drainTo(c) empties full queue, unblocking a waiting put.
 718      */
 719     public void testDrainToWithActivePut() throws InterruptedException {
 720         final LinkedTransferQueue q = populatedQueue(SIZE);
 721         Thread t = newStartedThread(new CheckedRunnable() {
 722             public void realRun() {
 723                 q.put(SIZE + 1);
 724             }});
 725         ArrayList l = new ArrayList();
 726         q.drainTo(l);
 727         assertTrue(l.size() &gt;= SIZE);
 728         for (int i = 0; i &lt; SIZE; ++i)
 729             assertEquals(i, l.get(i));
 730         awaitTermination(t);
 731         assertTrue(q.size() + l.size() &gt;= SIZE);
 732     }
 733 
 734     /**
 735      * drainTo(c, n) empties first min(n, size) elements of queue into c
 736      */
 737     public void testDrainToN() {
 738         LinkedTransferQueue q = new LinkedTransferQueue();
 739         for (int i = 0; i &lt; SIZE + 2; ++i) {
 740             for (int j = 0; j &lt; SIZE; j++) {
 741                 assertTrue(q.offer(j));
 742             }
 743             ArrayList l = new ArrayList();
 744             q.drainTo(l, i);
 745             int k = (i &lt; SIZE) ? i : SIZE;
 746             assertEquals(k, l.size());
 747             assertEquals(SIZE - k, q.size());
 748             for (int j = 0; j &lt; k; ++j)
 749                 assertEquals(j, l.get(j));
 750             do {} while (q.poll() != null);
 751         }
 752     }
 753 
 754     /**
 755      * timed poll() or take() increments the waiting consumer count;
 756      * offer(e) decrements the waiting consumer count
 757      */
 758     public void testWaitingConsumer() throws InterruptedException {
 759         final LinkedTransferQueue q = new LinkedTransferQueue();
 760         assertEquals(0, q.getWaitingConsumerCount());
 761         assertFalse(q.hasWaitingConsumer());
 762         final CountDownLatch threadStarted = new CountDownLatch(1);
 763 
 764         Thread t = newStartedThread(new CheckedRunnable() {
 765             public void realRun() throws InterruptedException {
 766                 threadStarted.countDown();
 767                 long startTime = System.nanoTime();
 768                 assertSame(one, q.poll(LONG_DELAY_MS, MILLISECONDS));
 769                 assertEquals(0, q.getWaitingConsumerCount());
 770                 assertFalse(q.hasWaitingConsumer());
 771                 assertTrue(millisElapsedSince(startTime) &lt; LONG_DELAY_MS);
 772             }});
 773 
 774         threadStarted.await();
 775         Callable&lt;Boolean&gt; oneConsumer
 776             = new Callable&lt;Boolean&gt;() { public Boolean call() {
 777                 return q.hasWaitingConsumer()
 778                 &amp;&amp; q.getWaitingConsumerCount() == 1; }};
 779         waitForThreadToEnterWaitState(t, oneConsumer);
 780 
 781         assertTrue(q.offer(one));
 782         assertEquals(0, q.getWaitingConsumerCount());
 783         assertFalse(q.hasWaitingConsumer());
 784 
 785         awaitTermination(t);
 786     }
 787 
 788     /**
 789      * transfer(null) throws NullPointerException
 790      */
 791     public void testTransfer1() throws InterruptedException {
 792         try {
 793             LinkedTransferQueue q = new LinkedTransferQueue();
 794             q.transfer(null);
 795             shouldThrow();
 796         } catch (NullPointerException success) {}
 797     }
 798 
 799     /**
 800      * transfer waits until a poll occurs. The transferred element
 801      * is returned by the associated poll.
 802      */
 803     public void testTransfer2() throws InterruptedException {
 804         final LinkedTransferQueue&lt;Integer&gt; q = new LinkedTransferQueue&lt;&gt;();
 805         final CountDownLatch threadStarted = new CountDownLatch(1);
 806 
 807         Thread t = newStartedThread(new CheckedRunnable() {
 808             public void realRun() throws InterruptedException {
 809                 threadStarted.countDown();
 810                 q.transfer(five);
 811                 checkEmpty(q);
 812             }});
 813 
 814         threadStarted.await();
 815         Callable&lt;Boolean&gt; oneElement
 816             = new Callable&lt;Boolean&gt;() { public Boolean call() {
 817                 return !q.isEmpty() &amp;&amp; q.size() == 1; }};
 818         waitForThreadToEnterWaitState(t, oneElement);
 819 
 820         assertSame(five, q.poll());
 821         checkEmpty(q);
 822         awaitTermination(t);
 823     }
 824 
 825     /**
 826      * transfer waits until a poll occurs, and then transfers in fifo order
 827      */
 828     public void testTransfer3() throws InterruptedException {
 829         final LinkedTransferQueue&lt;Integer&gt; q = new LinkedTransferQueue&lt;&gt;();
 830 
 831         Thread first = newStartedThread(new CheckedRunnable() {
 832             public void realRun() throws InterruptedException {
 833                 q.transfer(four);
 834                 assertFalse(q.contains(four));
 835                 assertEquals(1, q.size());
 836             }});
 837 
 838         Thread interruptedThread = newStartedThread(
 839             new CheckedInterruptedRunnable() {
 840                 public void realRun() throws InterruptedException {
 841                     while (q.isEmpty())
 842                         Thread.yield();
 843                     q.transfer(five);
 844                 }});
 845 
 846         while (q.size() &lt; 2)
 847             Thread.yield();
 848         assertEquals(2, q.size());
 849         assertSame(four, q.poll());
 850         first.join();
 851         assertEquals(1, q.size());
 852         interruptedThread.interrupt();
 853         interruptedThread.join();
 854         checkEmpty(q);
 855     }
 856 
 857     /**
 858      * transfer waits until a poll occurs, at which point the polling
 859      * thread returns the element
 860      */
 861     public void testTransfer4() throws InterruptedException {
 862         final LinkedTransferQueue q = new LinkedTransferQueue();
 863 
 864         Thread t = newStartedThread(new CheckedRunnable() {
 865             public void realRun() throws InterruptedException {
 866                 q.transfer(four);
 867                 assertFalse(q.contains(four));
 868                 assertSame(three, q.poll());
 869             }});
 870 
 871         while (q.isEmpty())
 872             Thread.yield();
 873         assertFalse(q.isEmpty());
 874         assertEquals(1, q.size());
 875         assertTrue(q.offer(three));
 876         assertSame(four, q.poll());
 877         awaitTermination(t);
 878     }
 879 
 880     /**
 881      * transfer waits until a take occurs. The transferred element
 882      * is returned by the associated take.
 883      */
 884     public void testTransfer5() throws InterruptedException {
 885         final LinkedTransferQueue&lt;Integer&gt; q = new LinkedTransferQueue&lt;&gt;();
 886 
 887         Thread t = newStartedThread(new CheckedRunnable() {
 888             public void realRun() throws InterruptedException {
 889                 q.transfer(four);
 890                 checkEmpty(q);
 891             }});
 892 
 893         while (q.isEmpty())
 894             Thread.yield();
 895         assertFalse(q.isEmpty());
 896         assertEquals(1, q.size());
 897         assertSame(four, q.take());
 898         checkEmpty(q);
 899         awaitTermination(t);
 900     }
 901 
 902     /**
 903      * tryTransfer(null) throws NullPointerException
 904      */
 905     public void testTryTransfer1() {
 906         final LinkedTransferQueue q = new LinkedTransferQueue();
 907         try {
 908             q.tryTransfer(null);
 909             shouldThrow();
 910         } catch (NullPointerException success) {}
 911     }
 912 
 913     /**
 914      * tryTransfer returns false and does not enqueue if there are no
 915      * consumers waiting to poll or take.
 916      */
 917     public void testTryTransfer2() throws InterruptedException {
 918         final LinkedTransferQueue q = new LinkedTransferQueue();
 919         assertFalse(q.tryTransfer(new Object()));
 920         assertFalse(q.hasWaitingConsumer());
 921         checkEmpty(q);
 922     }
 923 
 924     /**
 925      * If there is a consumer waiting in timed poll, tryTransfer
 926      * returns true while successfully transfering object.
 927      */
 928     public void testTryTransfer3() throws InterruptedException {
 929         final Object hotPotato = new Object();
 930         final LinkedTransferQueue q = new LinkedTransferQueue();
 931 
 932         Thread t = newStartedThread(new CheckedRunnable() {
 933             public void realRun() {
 934                 while (! q.hasWaitingConsumer())
 935                     Thread.yield();
 936                 assertTrue(q.hasWaitingConsumer());
 937                 checkEmpty(q);
 938                 assertTrue(q.tryTransfer(hotPotato));
 939             }});
 940 
 941         long startTime = System.nanoTime();
 942         assertSame(hotPotato, q.poll(LONG_DELAY_MS, MILLISECONDS));
 943         assertTrue(millisElapsedSince(startTime) &lt; LONG_DELAY_MS);
 944         checkEmpty(q);
 945         awaitTermination(t);
 946     }
 947 
 948     /**
 949      * If there is a consumer waiting in take, tryTransfer returns
 950      * true while successfully transfering object.
 951      */
 952     public void testTryTransfer4() throws InterruptedException {
 953         final Object hotPotato = new Object();
 954         final LinkedTransferQueue q = new LinkedTransferQueue();
 955 
 956         Thread t = newStartedThread(new CheckedRunnable() {
 957             public void realRun() {
 958                 while (! q.hasWaitingConsumer())
 959                     Thread.yield();
 960                 assertTrue(q.hasWaitingConsumer());
 961                 checkEmpty(q);
 962                 assertTrue(q.tryTransfer(hotPotato));
 963             }});
 964 
 965         assertSame(q.take(), hotPotato);
 966         checkEmpty(q);
 967         awaitTermination(t);
 968     }
 969 
 970     /**
 971      * tryTransfer blocks interruptibly if no takers
 972      */
 973     public void testTryTransfer5() throws InterruptedException {
 974         final LinkedTransferQueue q = new LinkedTransferQueue();
 975         final CountDownLatch pleaseInterrupt = new CountDownLatch(1);
 976         assertTrue(q.isEmpty());
 977 
 978         Thread t = newStartedThread(new CheckedRunnable() {
 979             public void realRun() throws InterruptedException {
 980                 Thread.currentThread().interrupt();
 981                 try {
 982                     q.tryTransfer(new Object(), randomTimeout(), randomTimeUnit());
 983                     shouldThrow();
 984                 } catch (InterruptedException success) {}
 985                 assertFalse(Thread.interrupted());
 986 
 987                 pleaseInterrupt.countDown();
 988                 try {
 989                     q.tryTransfer(new Object(), LONGER_DELAY_MS, MILLISECONDS);
 990                     shouldThrow();
 991                 } catch (InterruptedException success) {}
 992                 assertFalse(Thread.interrupted());
 993             }});
 994 
 995         await(pleaseInterrupt);
 996         if (randomBoolean()) assertThreadBlocks(t, Thread.State.TIMED_WAITING);
 997         t.interrupt();
 998         awaitTermination(t);
 999         checkEmpty(q);
1000     }
1001 
1002     /**
1003      * tryTransfer gives up after the timeout and returns false
1004      */
1005     public void testTryTransfer6() throws InterruptedException {
1006         final LinkedTransferQueue q = new LinkedTransferQueue();
1007 
1008         Thread t = newStartedThread(new CheckedRunnable() {
1009             public void realRun() throws InterruptedException {
1010                 long startTime = System.nanoTime();
1011                 assertFalse(q.tryTransfer(new Object(),
1012                                           timeoutMillis(), MILLISECONDS));
1013                 assertTrue(millisElapsedSince(startTime) &gt;= timeoutMillis());
1014                 checkEmpty(q);
1015             }});
1016 
1017         awaitTermination(t);
1018         checkEmpty(q);
1019     }
1020 
1021     /**
1022      * tryTransfer waits for any elements previously in to be removed
1023      * before transfering to a poll or take
1024      */
1025     public void testTryTransfer7() throws InterruptedException {
1026         final LinkedTransferQueue q = new LinkedTransferQueue();
1027         assertTrue(q.offer(four));
1028 
1029         Thread t = newStartedThread(new CheckedRunnable() {
1030             public void realRun() throws InterruptedException {
1031                 long startTime = System.nanoTime();
1032                 assertTrue(q.tryTransfer(five, LONG_DELAY_MS, MILLISECONDS));
1033                 assertTrue(millisElapsedSince(startTime) &lt; LONG_DELAY_MS);
1034                 checkEmpty(q);
1035             }});
1036 
1037         while (q.size() != 2)
1038             Thread.yield();
1039         assertEquals(2, q.size());
1040         assertSame(four, q.poll());
1041         assertSame(five, q.poll());
1042         checkEmpty(q);
1043         awaitTermination(t);
1044     }
1045 
1046     /**
1047      * tryTransfer attempts to enqueue into the queue and fails
1048      * returning false not enqueueing and the successive poll is null
1049      */
1050     public void testTryTransfer8() throws InterruptedException {
1051         final LinkedTransferQueue q = new LinkedTransferQueue();
1052         assertTrue(q.offer(four));
1053         assertEquals(1, q.size());
1054         long startTime = System.nanoTime();
1055         assertFalse(q.tryTransfer(five, timeoutMillis(), MILLISECONDS));
1056         assertTrue(millisElapsedSince(startTime) &gt;= timeoutMillis());
1057         assertEquals(1, q.size());
1058         assertSame(four, q.poll());
1059         assertNull(q.poll());
1060         checkEmpty(q);
1061     }
1062 
1063     private LinkedTransferQueue&lt;Integer&gt; populatedQueue(int n) {
1064         LinkedTransferQueue&lt;Integer&gt; q = new LinkedTransferQueue&lt;&gt;();
1065         checkEmpty(q);
1066         for (int i = 0; i &lt; n; i++) {
1067             assertEquals(i, q.size());
1068             assertTrue(q.offer(i));
1069             assertEquals(Integer.MAX_VALUE, q.remainingCapacity());
1070         }
1071         assertFalse(q.isEmpty());
1072         return q;
1073     }
1074 
1075     /**
1076      * remove(null), contains(null) always return false
1077      */
1078     public void testNeverContainsNull() {
1079         Collection&lt;?&gt;[] qs = {
1080             new LinkedTransferQueue&lt;Object&gt;(),
1081             populatedQueue(2),
1082         };
1083 
1084         for (Collection&lt;?&gt; q : qs) {
1085             assertFalse(q.contains(null));
1086             assertFalse(q.remove(null));
1087         }
1088     }
1089 }
    </pre>
  </body>
</html>
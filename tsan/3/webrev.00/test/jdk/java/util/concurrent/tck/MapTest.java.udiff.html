<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Udiff test/jdk/java/util/concurrent/tck/MapTest.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
<body>
<center><a href="MapImplementation.java.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="PhaserTest.java.udiff.html" target="_top">next &gt;</a></center>    <h2>test/jdk/java/util/concurrent/tck/MapTest.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-new-header">@@ -30,17 +30,21 @@</span>
   * members of JCP JSR-166 Expert Group and released to the public
   * domain, as explained at
   * http://creativecommons.org/publicdomain/zero/1.0/
   */
  
<span class="udiff-line-removed">- import junit.framework.Test;</span>
<span class="udiff-line-removed">- </span>
  import java.util.ArrayList;
  import java.util.Iterator;
  import java.util.List;
  import java.util.Map;
<span class="udiff-line-added">+ import java.util.concurrent.CompletableFuture;</span>
  import java.util.concurrent.ThreadLocalRandom;
<span class="udiff-line-added">+ import java.util.concurrent.atomic.AtomicBoolean;</span>
<span class="udiff-line-added">+ import java.util.concurrent.atomic.AtomicLong;</span>
<span class="udiff-line-added">+ import java.util.function.BiFunction;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ import junit.framework.Test;</span>
  
  /**
   * Contains tests applicable to all Map implementations.
   */
  public class MapTest extends JSR166TestCase {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -120,10 +124,11 @@</span>
       * HashMap: Entry.setValue may not work after Iterator.remove() called for previous entries
       * ant -Djsr166.tckTestClass=HashMapTest -Djsr166.methodFilter=testBug8186171 -Djsr166.runsPerTest=1000 tck
       */
      public void testBug8186171() {
          if (!impl.supportsSetValue()) return;
<span class="udiff-line-added">+         if (!atLeastJava10()) return; // jdk9 is no longer maintained</span>
          final ThreadLocalRandom rnd = ThreadLocalRandom.current();
          final boolean permitsNullValues = impl.permitsNullValues();
          final Object v1 = (permitsNullValues &amp;&amp; rnd.nextBoolean())
              ? null : impl.makeValue(1);
          final Object v2 = (permitsNullValues &amp;&amp; rnd.nextBoolean() &amp;&amp; v1 != null)
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -198,9 +203,100 @@</span>
          for (Object elt : m1Copy.keySet())
              assertSame(m1Copy.get(elt), m1.get(elt));
          assertEquals(size1 + size2, m1.size());
      }
  
<span class="udiff-line-added">+     /**</span>
<span class="udiff-line-added">+      * 8222930: ConcurrentSkipListMap.clone() shares size variable between original and clone</span>
<span class="udiff-line-added">+      */</span>
<span class="udiff-line-added">+     public void testClone() {</span>
<span class="udiff-line-added">+         final ThreadLocalRandom rnd = ThreadLocalRandom.current();</span>
<span class="udiff-line-added">+         final int size = rnd.nextInt(4);</span>
<span class="udiff-line-added">+         final Map map = impl.emptyMap();</span>
<span class="udiff-line-added">+         for (int i = 0; i &lt; size; i++)</span>
<span class="udiff-line-added">+             map.put(impl.makeKey(i), impl.makeValue(i));</span>
<span class="udiff-line-added">+         final Map clone = cloneableClone(map);</span>
<span class="udiff-line-added">+         if (clone == null) return;      // not cloneable?</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+         assertEquals(size, map.size());</span>
<span class="udiff-line-added">+         assertEquals(size, clone.size());</span>
<span class="udiff-line-added">+         assertEquals(map.isEmpty(), clone.isEmpty());</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+         clone.put(impl.makeKey(-1), impl.makeValue(-1));</span>
<span class="udiff-line-added">+         assertEquals(size, map.size());</span>
<span class="udiff-line-added">+         assertEquals(size + 1, clone.size());</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+         clone.clear();</span>
<span class="udiff-line-added">+         assertEquals(size, map.size());</span>
<span class="udiff-line-added">+         assertEquals(0, clone.size());</span>
<span class="udiff-line-added">+         assertTrue(clone.isEmpty());</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     /**</span>
<span class="udiff-line-added">+      * Concurrent access by compute methods behaves as expected</span>
<span class="udiff-line-added">+      */</span>
<span class="udiff-line-added">+     public void testConcurrentAccess() throws Throwable {</span>
<span class="udiff-line-added">+         final Map map = impl.emptyMap();</span>
<span class="udiff-line-added">+         final long testDurationMillis = expensiveTests ? 1000 : 2;</span>
<span class="udiff-line-added">+         final int nTasks = impl.isConcurrent()</span>
<span class="udiff-line-added">+             ? ThreadLocalRandom.current().nextInt(1, 10)</span>
<span class="udiff-line-added">+             : 1;</span>
<span class="udiff-line-added">+         final AtomicBoolean done = new AtomicBoolean(false);</span>
<span class="udiff-line-added">+         final boolean remappingFunctionCalledAtMostOnce</span>
<span class="udiff-line-added">+             = impl.remappingFunctionCalledAtMostOnce();</span>
<span class="udiff-line-added">+         final List&lt;CompletableFuture&gt; futures = new ArrayList&lt;&gt;();</span>
<span class="udiff-line-added">+         final AtomicLong expectedSum = new AtomicLong(0);</span>
<span class="udiff-line-added">+         final Action[] tasks = {</span>
<span class="udiff-line-added">+             // repeatedly increment values using compute()</span>
<span class="udiff-line-added">+             () -&gt; {</span>
<span class="udiff-line-added">+                 long[] invocations = new long[2];</span>
<span class="udiff-line-added">+                 ThreadLocalRandom rnd = ThreadLocalRandom.current();</span>
<span class="udiff-line-added">+                 BiFunction&lt;Object, Object, Object&gt; incValue = (k, v) -&gt; {</span>
<span class="udiff-line-added">+                     invocations[1]++;</span>
<span class="udiff-line-added">+                     int vi = (v == null) ? 1 : impl.valueToInt(v) + 1;</span>
<span class="udiff-line-added">+                     return impl.makeValue(vi);</span>
<span class="udiff-line-added">+                 };</span>
<span class="udiff-line-added">+                 while (!done.getAcquire()) {</span>
<span class="udiff-line-added">+                     invocations[0]++;</span>
<span class="udiff-line-added">+                     Object key = impl.makeKey(3 * rnd.nextInt(10));</span>
<span class="udiff-line-added">+                     map.compute(key, incValue);</span>
<span class="udiff-line-added">+                 }</span>
<span class="udiff-line-added">+                 if (remappingFunctionCalledAtMostOnce)</span>
<span class="udiff-line-added">+                     assertEquals(invocations[0], invocations[1]);</span>
<span class="udiff-line-added">+                 expectedSum.getAndAdd(invocations[0]);</span>
<span class="udiff-line-added">+             },</span>
<span class="udiff-line-added">+             // repeatedly increment values using computeIfPresent()</span>
<span class="udiff-line-added">+             () -&gt; {</span>
<span class="udiff-line-added">+                 long[] invocations = new long[2];</span>
<span class="udiff-line-added">+                 ThreadLocalRandom rnd = ThreadLocalRandom.current();</span>
<span class="udiff-line-added">+                 BiFunction&lt;Object, Object, Object&gt; incValue = (k, v) -&gt; {</span>
<span class="udiff-line-added">+                     invocations[1]++;</span>
<span class="udiff-line-added">+                     int vi = impl.valueToInt(v) + 1;</span>
<span class="udiff-line-added">+                     return impl.makeValue(vi);</span>
<span class="udiff-line-added">+                 };</span>
<span class="udiff-line-added">+                 while (!done.getAcquire()) {</span>
<span class="udiff-line-added">+                     Object key = impl.makeKey(3 * rnd.nextInt(10));</span>
<span class="udiff-line-added">+                     if (map.computeIfPresent(key, incValue) != null)</span>
<span class="udiff-line-added">+                         invocations[0]++;</span>
<span class="udiff-line-added">+                 }</span>
<span class="udiff-line-added">+                 if (remappingFunctionCalledAtMostOnce)</span>
<span class="udiff-line-added">+                     assertEquals(invocations[0], invocations[1]);</span>
<span class="udiff-line-added">+                 expectedSum.getAndAdd(invocations[0]);</span>
<span class="udiff-line-added">+             },</span>
<span class="udiff-line-added">+         };</span>
<span class="udiff-line-added">+         for (int i = nTasks; i--&gt; 0; ) {</span>
<span class="udiff-line-added">+             Action task = chooseRandomly(tasks);</span>
<span class="udiff-line-added">+             futures.add(CompletableFuture.runAsync(checkedRunnable(task)));</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+         Thread.sleep(testDurationMillis);</span>
<span class="udiff-line-added">+         done.setRelease(true);</span>
<span class="udiff-line-added">+         for (var future : futures)</span>
<span class="udiff-line-added">+             checkTimedGet(future, null);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+         long sum = map.values().stream().mapToLong(x -&gt; (int) x).sum();</span>
<span class="udiff-line-added">+         assertEquals(expectedSum.get(), sum);</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ </span>
  //     public void testFailsIntentionallyForDebugging() {
  //         fail(impl.klazz().getSimpleName());
  //     }
  }
</pre>
<center><a href="MapImplementation.java.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="PhaserTest.java.udiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames test/jdk/java/util/concurrent/tck/ThreadLocalRandom8Test.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  3  *
  4  * This code is free software; you can redistribute it and/or modify it
  5  * under the terms of the GNU General Public License version 2 only, as
  6  * published by the Free Software Foundation.
  7  *
  8  * This code is distributed in the hope that it will be useful, but WITHOUT
  9  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 10  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 11  * version 2 for more details (a copy is included in the LICENSE file that
 12  * accompanied this code).
 13  *
 14  * You should have received a copy of the GNU General Public License version
 15  * 2 along with this work; if not, write to the Free Software Foundation,
 16  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 17  *
 18  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 19  * or visit www.oracle.com if you need additional information or have any
 20  * questions.
 21  */
 22 
 23 /*
 24  * This file is available under and governed by the GNU General Public
 25  * License version 2 only, as published by the Free Software Foundation.
 26  * However, the following notice accompanied the original version of this
 27  * file:
 28  *
 29  * Written by Doug Lea with assistance from members of JCP JSR-166
 30  * Expert Group and released to the public domain, as explained at
 31  * http://creativecommons.org/publicdomain/zero/1.0/
 32  */
 33 
 34 import java.util.concurrent.ThreadLocalRandom;
 35 import java.util.concurrent.atomic.AtomicInteger;
 36 import java.util.concurrent.atomic.LongAdder;
 37 
 38 import junit.framework.Test;
 39 import junit.framework.TestSuite;
 40 
 41 public class ThreadLocalRandom8Test extends JSR166TestCase {
 42 
 43     public static void main(String[] args) {
 44         main(suite(), args);
 45     }
 46     public static Test suite() {
 47         return new TestSuite(ThreadLocalRandom8Test.class);
 48     }
 49 
 50     // max sampled int bound
 51     static final int MAX_INT_BOUND = (1 &lt;&lt; 26);
 52 
 53     // max sampled long bound
 54     static final long MAX_LONG_BOUND = (1L &lt;&lt; 42);
 55 
 56     // Number of replications for other checks
 57     static final int REPS =
 58         Integer.getInteger(&quot;ThreadLocalRandom8Test.reps&quot;, 4);
 59 
 60     /**
 61      * Invoking sized ints, long, doubles, with negative sizes throws
 62      * IllegalArgumentException
 63      */
 64     public void testBadStreamSize() {
 65         ThreadLocalRandom r = ThreadLocalRandom.current();
<a name="1" id="anc1"></a><span class="line-modified"> 66         assertThrows(</span>
<span class="line-added"> 67             IllegalArgumentException.class,</span>
 68             () -&gt; r.ints(-1L),
 69             () -&gt; r.ints(-1L, 2, 3),
 70             () -&gt; r.longs(-1L),
 71             () -&gt; r.longs(-1L, -1L, 1L),
 72             () -&gt; r.doubles(-1L),
<a name="2" id="anc2"></a><span class="line-modified"> 73             () -&gt; r.doubles(-1L, .5, .6));</span>


 74     }
 75 
 76     /**
 77      * Invoking bounded ints, long, doubles, with illegal bounds throws
 78      * IllegalArgumentException
 79      */
 80     public void testBadStreamBounds() {
 81         ThreadLocalRandom r = ThreadLocalRandom.current();
<a name="3" id="anc3"></a><span class="line-modified"> 82         assertThrows(</span>
<span class="line-added"> 83             IllegalArgumentException.class,</span>
 84             () -&gt; r.ints(2, 1),
 85             () -&gt; r.ints(10, 42, 42),
 86             () -&gt; r.longs(-1L, -1L),
 87             () -&gt; r.longs(10, 1L, -2L),
 88             () -&gt; r.doubles(0.0, 0.0),
<a name="4" id="anc4"></a><span class="line-modified"> 89             () -&gt; r.doubles(10, .5, .4));</span>


 90     }
 91 
 92     /**
 93      * A parallel sized stream of ints generates the given number of values
 94      */
 95     public void testIntsCount() {
 96         LongAdder counter = new LongAdder();
 97         ThreadLocalRandom r = ThreadLocalRandom.current();
 98         long size = 0;
 99         for (int reps = 0; reps &lt; REPS; ++reps) {
100             counter.reset();
101             r.ints(size).parallel().forEach(x -&gt; counter.increment());
102             assertEquals(size, counter.sum());
103             size += 524959;
104         }
105     }
106 
107     /**
108      * A parallel sized stream of longs generates the given number of values
109      */
110     public void testLongsCount() {
111         LongAdder counter = new LongAdder();
112         ThreadLocalRandom r = ThreadLocalRandom.current();
113         long size = 0;
114         for (int reps = 0; reps &lt; REPS; ++reps) {
115             counter.reset();
116             r.longs(size).parallel().forEach(x -&gt; counter.increment());
117             assertEquals(size, counter.sum());
118             size += 524959;
119         }
120     }
121 
122     /**
123      * A parallel sized stream of doubles generates the given number of values
124      */
125     public void testDoublesCount() {
126         LongAdder counter = new LongAdder();
127         ThreadLocalRandom r = ThreadLocalRandom.current();
128         long size = 0;
129         for (int reps = 0; reps &lt; REPS; ++reps) {
130             counter.reset();
131             r.doubles(size).parallel().forEach(x -&gt; counter.increment());
132             assertEquals(size, counter.sum());
133             size += 524959;
134         }
135     }
136 
137     /**
138      * Each of a parallel sized stream of bounded ints is within bounds
139      */
140     public void testBoundedInts() {
141         AtomicInteger fails = new AtomicInteger(0);
142         ThreadLocalRandom r = ThreadLocalRandom.current();
143         long size = 12345L;
144         for (int least = -15485867; least &lt; MAX_INT_BOUND; least += 524959) {
145             for (int bound = least + 2; bound &gt; least &amp;&amp; bound &lt; MAX_INT_BOUND; bound += 67867967) {
146                 final int lo = least, hi = bound;
147                 r.ints(size, lo, hi).parallel().forEach(
148                     x -&gt; {
149                         if (x &lt; lo || x &gt;= hi)
150                             fails.getAndIncrement(); });
151             }
152         }
153         assertEquals(0, fails.get());
154     }
155 
156     /**
157      * Each of a parallel sized stream of bounded longs is within bounds
158      */
159     public void testBoundedLongs() {
160         AtomicInteger fails = new AtomicInteger(0);
161         ThreadLocalRandom r = ThreadLocalRandom.current();
162         long size = 123L;
163         for (long least = -86028121; least &lt; MAX_LONG_BOUND; least += 1982451653L) {
164             for (long bound = least + 2; bound &gt; least &amp;&amp; bound &lt; MAX_LONG_BOUND; bound += Math.abs(bound * 7919)) {
165                 final long lo = least, hi = bound;
166                 r.longs(size, lo, hi).parallel().forEach(
167                     x -&gt; {
168                         if (x &lt; lo || x &gt;= hi)
169                             fails.getAndIncrement(); });
170             }
171         }
172         assertEquals(0, fails.get());
173     }
174 
175     /**
176      * Each of a parallel sized stream of bounded doubles is within bounds
177      */
178     public void testBoundedDoubles() {
179         AtomicInteger fails = new AtomicInteger(0);
180         ThreadLocalRandom r = ThreadLocalRandom.current();
181         long size = 456;
182         for (double least = 0.00011; least &lt; 1.0e20; least *= 9) {
183             for (double bound = least * 1.0011; bound &lt; 1.0e20; bound *= 17) {
184                 final double lo = least, hi = bound;
185                 r.doubles(size, lo, hi).parallel().forEach(
186                     x -&gt; {
187                         if (x &lt; lo || x &gt;= hi)
188                             fails.getAndIncrement(); });
189             }
190         }
191         assertEquals(0, fails.get());
192     }
193 
194     /**
195      * A parallel unsized stream of ints generates at least 100 values
196      */
197     public void testUnsizedIntsCount() {
198         LongAdder counter = new LongAdder();
199         ThreadLocalRandom r = ThreadLocalRandom.current();
200         long size = 100;
201         r.ints().limit(size).parallel().forEach(x -&gt; counter.increment());
202         assertEquals(size, counter.sum());
203     }
204 
205     /**
206      * A parallel unsized stream of longs generates at least 100 values
207      */
208     public void testUnsizedLongsCount() {
209         LongAdder counter = new LongAdder();
210         ThreadLocalRandom r = ThreadLocalRandom.current();
211         long size = 100;
212         r.longs().limit(size).parallel().forEach(x -&gt; counter.increment());
213         assertEquals(size, counter.sum());
214     }
215 
216     /**
217      * A parallel unsized stream of doubles generates at least 100 values
218      */
219     public void testUnsizedDoublesCount() {
220         LongAdder counter = new LongAdder();
221         ThreadLocalRandom r = ThreadLocalRandom.current();
222         long size = 100;
223         r.doubles().limit(size).parallel().forEach(x -&gt; counter.increment());
224         assertEquals(size, counter.sum());
225     }
226 
227     /**
228      * A sequential unsized stream of ints generates at least 100 values
229      */
230     public void testUnsizedIntsCountSeq() {
231         LongAdder counter = new LongAdder();
232         ThreadLocalRandom r = ThreadLocalRandom.current();
233         long size = 100;
234         r.ints().limit(size).forEach(x -&gt; counter.increment());
235         assertEquals(size, counter.sum());
236     }
237 
238     /**
239      * A sequential unsized stream of longs generates at least 100 values
240      */
241     public void testUnsizedLongsCountSeq() {
242         LongAdder counter = new LongAdder();
243         ThreadLocalRandom r = ThreadLocalRandom.current();
244         long size = 100;
245         r.longs().limit(size).forEach(x -&gt; counter.increment());
246         assertEquals(size, counter.sum());
247     }
248 
249     /**
250      * A sequential unsized stream of doubles generates at least 100 values
251      */
252     public void testUnsizedDoublesCountSeq() {
253         LongAdder counter = new LongAdder();
254         ThreadLocalRandom r = ThreadLocalRandom.current();
255         long size = 100;
256         r.doubles().limit(size).forEach(x -&gt; counter.increment());
257         assertEquals(size, counter.sum());
258     }
259 
260     /**
261      * A deserialized/reserialized ThreadLocalRandom is always
262      * identical to ThreadLocalRandom.current()
263      */
264     public void testSerialization() {
265         assertSame(
266             ThreadLocalRandom.current(),
267             serialClone(ThreadLocalRandom.current()));
268         // In the current implementation, there is exactly one shared instance
269         if (testImplementationDetails)
270             assertSame(
271                 ThreadLocalRandom.current(),
272                 java.util.concurrent.CompletableFuture.supplyAsync(
273                     () -&gt; serialClone(ThreadLocalRandom.current())).join());
274     }
275 
276 }
<a name="5" id="anc5"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="5" type="hidden" />
</body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff test/jdk/java/util/concurrent/tck/CyclicBarrierTest.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
<body>
<center><a href="CountDownLatchTest.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="DelayQueueTest.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>test/jdk/java/util/concurrent/tck/CyclicBarrierTest.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 25  * License version 2 only, as published by the Free Software Foundation.
 26  * However, the following notice accompanied the original version of this
 27  * file:
 28  *
 29  * Written by Doug Lea with assistance from members of JCP JSR-166
 30  * Expert Group and released to the public domain, as explained at
 31  * http://creativecommons.org/publicdomain/zero/1.0/
 32  * Other contributors include Andrew Wright, Jeffrey Hayes,
 33  * Pat Fisher, Mike Judd.
 34  */
 35 
 36 import static java.util.concurrent.TimeUnit.MILLISECONDS;
 37 
 38 import java.util.concurrent.BrokenBarrierException;
 39 import java.util.concurrent.CountDownLatch;
 40 import java.util.concurrent.CyclicBarrier;
 41 import java.util.concurrent.ExecutorService;
 42 import java.util.concurrent.Executors;
 43 import java.util.concurrent.ThreadLocalRandom;
 44 import java.util.concurrent.TimeoutException;
<span class="line-removed"> 45 import java.util.concurrent.atomic.AtomicBoolean;</span>
 46 import java.util.concurrent.atomic.AtomicInteger;
 47 
 48 import junit.framework.Test;
 49 import junit.framework.TestSuite;
 50 
 51 public class CyclicBarrierTest extends JSR166TestCase {
 52     public static void main(String[] args) {
 53         main(suite(), args);
 54     }
 55     public static Test suite() {
 56         return new TestSuite(CyclicBarrierTest.class);
 57     }
 58 
 59     /**
 60      * Spin-waits till the number of waiters == numberOfWaiters.
 61      */
 62     void awaitNumberWaiting(CyclicBarrier barrier, int numberOfWaiters) {
 63         long startTime = System.nanoTime();
 64         while (barrier.getNumberWaiting() != numberOfWaiters) {
 65             if (millisElapsedSince(startTime) &gt; LONG_DELAY_MS)
</pre>
<hr />
<pre>
305      * BrokenBarrierException
306      */
307     public void testReset_NoBrokenBarrier() throws Exception {
308         final CyclicBarrier c = new CyclicBarrier(3);
309         c.reset();
310 
311         Thread t1 = newStartedThread(new CheckedRunnable() {
312             public void realRun() throws Exception {
313                 c.await();
314             }});
315         Thread t2 = newStartedThread(new CheckedRunnable() {
316             public void realRun() throws Exception {
317                 c.await();
318             }});
319 
320         c.await();
321         awaitTermination(t1);
322         awaitTermination(t2);
323     }
324 
<span class="line-removed">325     /**</span>
<span class="line-removed">326      * All threads block while a barrier is broken.</span>
<span class="line-removed">327      */</span>
<span class="line-removed">328     public void testReset_Leakage() throws InterruptedException {</span>
<span class="line-removed">329         final CyclicBarrier c = new CyclicBarrier(2);</span>
<span class="line-removed">330         final AtomicBoolean done = new AtomicBoolean();</span>
<span class="line-removed">331         Thread t = newStartedThread(new CheckedRunnable() {</span>
<span class="line-removed">332             public void realRun() {</span>
<span class="line-removed">333                 while (!done.get()) {</span>
<span class="line-removed">334                     try {</span>
<span class="line-removed">335                         while (c.isBroken())</span>
<span class="line-removed">336                             c.reset();</span>
<span class="line-removed">337 </span>
<span class="line-removed">338                         c.await();</span>
<span class="line-removed">339                         shouldThrow();</span>
<span class="line-removed">340                     }</span>
<span class="line-removed">341                     catch (BrokenBarrierException | InterruptedException ok) {}</span>
<span class="line-removed">342                 }}});</span>
<span class="line-removed">343 </span>
<span class="line-removed">344         for (int i = 0; i &lt; 4; i++) {</span>
<span class="line-removed">345             delay(timeoutMillis());</span>
<span class="line-removed">346             t.interrupt();</span>
<span class="line-removed">347         }</span>
<span class="line-removed">348         done.set(true);</span>
<span class="line-removed">349         t.interrupt();</span>
<span class="line-removed">350         awaitTermination(t);</span>
<span class="line-removed">351     }</span>
<span class="line-removed">352 </span>
353     /**
354      * Reset of a non-broken barrier does not break barrier
355      */
356     public void testResetWithoutBreakage() throws Exception {
357         final CyclicBarrier barrier = new CyclicBarrier(3);
358         for (int i = 0; i &lt; 3; i++) {
359             final CyclicBarrier start = new CyclicBarrier(3);
360             Thread t1 = newStartedThread(new CheckedRunnable() {
361                 public void realRun() throws Exception {
362                     start.await();
363                     barrier.await();
364                 }});
365 
366             Thread t2 = newStartedThread(new CheckedRunnable() {
367                 public void realRun() throws Exception {
368                     start.await();
369                     barrier.await();
370                 }});
371 
372             start.await();
</pre>
<hr />
<pre>
488             assertFalse(barrier.isBroken());
489             assertEquals(0, barrier.getNumberWaiting());
490         }
491     }
492 
493     /**
494      * There can be more threads calling await() than parties, as long as each
495      * task only calls await once and the task count is a multiple of parties.
496      */
497     public void testMoreTasksThanParties() throws Exception {
498         final ThreadLocalRandom rnd = ThreadLocalRandom.current();
499         final int parties = rnd.nextInt(1, 5);
500         final int nTasks = rnd.nextInt(1, 5) * parties;
501         final AtomicInteger tripCount = new AtomicInteger(0);
502         final AtomicInteger awaitCount = new AtomicInteger(0);
503         final CyclicBarrier barrier =
504             new CyclicBarrier(parties, () -&gt; tripCount.getAndIncrement());
505         final ExecutorService e = Executors.newFixedThreadPool(nTasks);
506         final Runnable awaiter = () -&gt; {
507             try {
<span class="line-modified">508                 if (ThreadLocalRandom.current().nextBoolean())</span>
509                     barrier.await();
510                 else
511                     barrier.await(LONG_DELAY_MS, MILLISECONDS);
512                 awaitCount.getAndIncrement();
513             } catch (Throwable fail) { threadUnexpectedException(fail); }};
514         try (PoolCleaner cleaner = cleaner(e)) {
515             for (int i = nTasks; i--&gt; 0; )
516                 e.execute(awaiter);
517         }
518         assertEquals(nTasks / parties, tripCount.get());
519         assertEquals(nTasks, awaitCount.get());
520         assertEquals(0, barrier.getNumberWaiting());
521     }
522 }
</pre>
</td>
<td>
<hr />
<pre>
 25  * License version 2 only, as published by the Free Software Foundation.
 26  * However, the following notice accompanied the original version of this
 27  * file:
 28  *
 29  * Written by Doug Lea with assistance from members of JCP JSR-166
 30  * Expert Group and released to the public domain, as explained at
 31  * http://creativecommons.org/publicdomain/zero/1.0/
 32  * Other contributors include Andrew Wright, Jeffrey Hayes,
 33  * Pat Fisher, Mike Judd.
 34  */
 35 
 36 import static java.util.concurrent.TimeUnit.MILLISECONDS;
 37 
 38 import java.util.concurrent.BrokenBarrierException;
 39 import java.util.concurrent.CountDownLatch;
 40 import java.util.concurrent.CyclicBarrier;
 41 import java.util.concurrent.ExecutorService;
 42 import java.util.concurrent.Executors;
 43 import java.util.concurrent.ThreadLocalRandom;
 44 import java.util.concurrent.TimeoutException;

 45 import java.util.concurrent.atomic.AtomicInteger;
 46 
 47 import junit.framework.Test;
 48 import junit.framework.TestSuite;
 49 
 50 public class CyclicBarrierTest extends JSR166TestCase {
 51     public static void main(String[] args) {
 52         main(suite(), args);
 53     }
 54     public static Test suite() {
 55         return new TestSuite(CyclicBarrierTest.class);
 56     }
 57 
 58     /**
 59      * Spin-waits till the number of waiters == numberOfWaiters.
 60      */
 61     void awaitNumberWaiting(CyclicBarrier barrier, int numberOfWaiters) {
 62         long startTime = System.nanoTime();
 63         while (barrier.getNumberWaiting() != numberOfWaiters) {
 64             if (millisElapsedSince(startTime) &gt; LONG_DELAY_MS)
</pre>
<hr />
<pre>
304      * BrokenBarrierException
305      */
306     public void testReset_NoBrokenBarrier() throws Exception {
307         final CyclicBarrier c = new CyclicBarrier(3);
308         c.reset();
309 
310         Thread t1 = newStartedThread(new CheckedRunnable() {
311             public void realRun() throws Exception {
312                 c.await();
313             }});
314         Thread t2 = newStartedThread(new CheckedRunnable() {
315             public void realRun() throws Exception {
316                 c.await();
317             }});
318 
319         c.await();
320         awaitTermination(t1);
321         awaitTermination(t2);
322     }
323 




























324     /**
325      * Reset of a non-broken barrier does not break barrier
326      */
327     public void testResetWithoutBreakage() throws Exception {
328         final CyclicBarrier barrier = new CyclicBarrier(3);
329         for (int i = 0; i &lt; 3; i++) {
330             final CyclicBarrier start = new CyclicBarrier(3);
331             Thread t1 = newStartedThread(new CheckedRunnable() {
332                 public void realRun() throws Exception {
333                     start.await();
334                     barrier.await();
335                 }});
336 
337             Thread t2 = newStartedThread(new CheckedRunnable() {
338                 public void realRun() throws Exception {
339                     start.await();
340                     barrier.await();
341                 }});
342 
343             start.await();
</pre>
<hr />
<pre>
459             assertFalse(barrier.isBroken());
460             assertEquals(0, barrier.getNumberWaiting());
461         }
462     }
463 
464     /**
465      * There can be more threads calling await() than parties, as long as each
466      * task only calls await once and the task count is a multiple of parties.
467      */
468     public void testMoreTasksThanParties() throws Exception {
469         final ThreadLocalRandom rnd = ThreadLocalRandom.current();
470         final int parties = rnd.nextInt(1, 5);
471         final int nTasks = rnd.nextInt(1, 5) * parties;
472         final AtomicInteger tripCount = new AtomicInteger(0);
473         final AtomicInteger awaitCount = new AtomicInteger(0);
474         final CyclicBarrier barrier =
475             new CyclicBarrier(parties, () -&gt; tripCount.getAndIncrement());
476         final ExecutorService e = Executors.newFixedThreadPool(nTasks);
477         final Runnable awaiter = () -&gt; {
478             try {
<span class="line-modified">479                 if (randomBoolean())</span>
480                     barrier.await();
481                 else
482                     barrier.await(LONG_DELAY_MS, MILLISECONDS);
483                 awaitCount.getAndIncrement();
484             } catch (Throwable fail) { threadUnexpectedException(fail); }};
485         try (PoolCleaner cleaner = cleaner(e)) {
486             for (int i = nTasks; i--&gt; 0; )
487                 e.execute(awaiter);
488         }
489         assertEquals(nTasks / parties, tripCount.get());
490         assertEquals(nTasks, awaitCount.get());
491         assertEquals(0, barrier.getNumberWaiting());
492     }
493 }
</pre>
</td>
</tr>
</table>
<center><a href="CountDownLatchTest.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="DelayQueueTest.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
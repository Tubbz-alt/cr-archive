<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames test/jdk/java/util/concurrent/tck/LinkedTransferQueueTest.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   3  *
   4  * This code is free software; you can redistribute it and/or modify it
   5  * under the terms of the GNU General Public License version 2 only, as
   6  * published by the Free Software Foundation.
   7  *
   8  * This code is distributed in the hope that it will be useful, but WITHOUT
   9  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  10  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  11  * version 2 for more details (a copy is included in the LICENSE file that
  12  * accompanied this code).
  13  *
  14  * You should have received a copy of the GNU General Public License version
  15  * 2 along with this work; if not, write to the Free Software Foundation,
  16  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  17  *
  18  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  19  * or visit www.oracle.com if you need additional information or have any
  20  * questions.
  21  */
  22 
  23 /*
  24  * This file is available under and governed by the GNU General Public
  25  * License version 2 only, as published by the Free Software Foundation.
  26  * However, the following notice accompanied the original version of this
  27  * file:
  28  *
  29  * Written by Doug Lea with assistance from members of JCP JSR-166
  30  * Expert Group and released to the public domain, as explained at
  31  * http://creativecommons.org/publicdomain/zero/1.0/
  32  * Other contributors include John Vint
  33  */
  34 
  35 import static java.util.concurrent.TimeUnit.MILLISECONDS;
  36 
  37 import java.util.ArrayList;
  38 import java.util.Arrays;
  39 import java.util.Collection;
  40 import java.util.Iterator;
  41 import java.util.List;
  42 import java.util.NoSuchElementException;
  43 import java.util.Queue;
  44 import java.util.concurrent.BlockingQueue;
  45 import java.util.concurrent.Callable;
  46 import java.util.concurrent.CountDownLatch;
  47 import java.util.concurrent.Executors;
  48 import java.util.concurrent.ExecutorService;
  49 import java.util.concurrent.LinkedTransferQueue;
  50 
  51 import junit.framework.Test;
  52 
  53 @SuppressWarnings({&quot;unchecked&quot;, &quot;rawtypes&quot;})
  54 public class LinkedTransferQueueTest extends JSR166TestCase {
  55     public static class Generic extends BlockingQueueTest {
  56         protected BlockingQueue emptyCollection() {
  57             return new LinkedTransferQueue();
  58         }
  59     }
  60 
  61     public static void main(String[] args) {
  62         main(suite(), args);
  63     }
  64 
  65     public static Test suite() {
  66         class Implementation implements CollectionImplementation {
  67             public Class&lt;?&gt; klazz() { return LinkedTransferQueue.class; }
  68             public Collection emptyCollection() { return new LinkedTransferQueue(); }
  69             public Object makeElement(int i) { return i; }
  70             public boolean isConcurrent() { return true; }
  71             public boolean permitsNulls() { return false; }
  72         }
  73         return newTestSuite(LinkedTransferQueueTest.class,
  74                             new Generic().testSuite(),
  75                             CollectionTest.testSuite(new Implementation()));
  76     }
  77 
  78     /**
  79      * Constructor builds new queue with size being zero and empty
  80      * being true
  81      */
  82     public void testConstructor1() {
  83         assertEquals(0, new LinkedTransferQueue().size());
  84         assertTrue(new LinkedTransferQueue().isEmpty());
  85     }
  86 
  87     /**
  88      * Initializing constructor with null collection throws
  89      * NullPointerException
  90      */
  91     public void testConstructor2() {
  92         try {
  93             new LinkedTransferQueue(null);
  94             shouldThrow();
  95         } catch (NullPointerException success) {}
  96     }
  97 
  98     /**
  99      * Initializing from Collection of null elements throws
 100      * NullPointerException
 101      */
 102     public void testConstructor3() {
 103         Collection&lt;Integer&gt; elements = Arrays.asList(new Integer[SIZE]);
 104         try {
 105             new LinkedTransferQueue(elements);
 106             shouldThrow();
 107         } catch (NullPointerException success) {}
 108     }
 109 
 110     /**
 111      * Initializing constructor with a collection containing some null elements
 112      * throws NullPointerException
 113      */
 114     public void testConstructor4() {
 115         Integer[] ints = new Integer[SIZE];
 116         for (int i = 0; i &lt; SIZE - 1; ++i)
 117             ints[i] = i;
 118         Collection&lt;Integer&gt; elements = Arrays.asList(ints);
 119         try {
 120             new LinkedTransferQueue(elements);
 121             shouldThrow();
 122         } catch (NullPointerException success) {}
 123     }
 124 
 125     /**
 126      * Queue contains all elements of the collection it is initialized by
 127      */
 128     public void testConstructor5() {
 129         Integer[] ints = new Integer[SIZE];
 130         for (int i = 0; i &lt; SIZE; ++i) {
 131             ints[i] = i;
 132         }
 133         List intList = Arrays.asList(ints);
 134         LinkedTransferQueue q
 135             = new LinkedTransferQueue(intList);
 136         assertEquals(q.size(), intList.size());
 137         assertEquals(q.toString(), intList.toString());
 138         assertTrue(Arrays.equals(q.toArray(),
 139                                      intList.toArray()));
 140         assertTrue(Arrays.equals(q.toArray(new Object[0]),
 141                                  intList.toArray(new Object[0])));
 142         assertTrue(Arrays.equals(q.toArray(new Object[SIZE]),
 143                                  intList.toArray(new Object[SIZE])));
 144         for (int i = 0; i &lt; SIZE; ++i) {
 145             assertEquals(ints[i], q.poll());
 146         }
 147     }
 148 
 149     /**
 150      * remainingCapacity() always returns Integer.MAX_VALUE
 151      */
 152     public void testRemainingCapacity() {
 153         BlockingQueue q = populatedQueue(SIZE);
 154         for (int i = 0; i &lt; SIZE; ++i) {
 155             assertEquals(Integer.MAX_VALUE, q.remainingCapacity());
 156             assertEquals(SIZE - i, q.size());
 157             assertEquals(i, q.remove());
 158         }
 159         for (int i = 0; i &lt; SIZE; ++i) {
 160             assertEquals(Integer.MAX_VALUE, q.remainingCapacity());
 161             assertEquals(i, q.size());
 162             assertTrue(q.add(i));
 163         }
 164     }
 165 
 166     /**
 167      * addAll(this) throws IllegalArgumentException
 168      */
 169     public void testAddAllSelf() {
 170         LinkedTransferQueue q = populatedQueue(SIZE);
 171         try {
 172             q.addAll(q);
 173             shouldThrow();
 174         } catch (IllegalArgumentException success) {}
 175     }
 176 
 177     /**
 178      * addAll of a collection with any null elements throws
 179      * NullPointerException after possibly adding some elements
 180      */
 181     public void testAddAll3() {
 182         LinkedTransferQueue q = new LinkedTransferQueue();
 183         Integer[] ints = new Integer[SIZE];
 184         for (int i = 0; i &lt; SIZE - 1; ++i)
 185             ints[i] = i;
 186         try {
 187             q.addAll(Arrays.asList(ints));
 188             shouldThrow();
 189         } catch (NullPointerException success) {}
 190     }
 191 
 192     /**
 193      * Queue contains all elements, in traversal order, of successful addAll
 194      */
 195     public void testAddAll5() {
 196         Integer[] empty = new Integer[0];
 197         Integer[] ints = new Integer[SIZE];
 198         for (int i = 0; i &lt; SIZE; ++i) {
 199             ints[i] = i;
 200         }
 201         LinkedTransferQueue q = new LinkedTransferQueue();
 202         assertFalse(q.addAll(Arrays.asList(empty)));
 203         assertTrue(q.addAll(Arrays.asList(ints)));
 204         for (int i = 0; i &lt; SIZE; ++i) {
 205             assertEquals(ints[i], q.poll());
 206         }
 207     }
 208 
 209     /**
 210      * all elements successfully put are contained
 211      */
 212     public void testPut() {
 213         LinkedTransferQueue&lt;Integer&gt; q = new LinkedTransferQueue&lt;&gt;();
 214         for (int i = 0; i &lt; SIZE; ++i) {
 215             assertEquals(i, q.size());
 216             q.put(i);
 217             assertTrue(q.contains(i));
 218         }
 219     }
 220 
 221     /**
 222      * take retrieves elements in FIFO order
 223      */
 224     public void testTake() throws InterruptedException {
 225         LinkedTransferQueue&lt;Integer&gt; q = populatedQueue(SIZE);
 226         for (int i = 0; i &lt; SIZE; ++i) {
 227             assertEquals(i, (int) q.take());
 228         }
 229     }
 230 
 231     /**
 232      * take removes existing elements until empty, then blocks interruptibly
 233      */
 234     public void testBlockingTake() throws InterruptedException {
 235         final BlockingQueue q = populatedQueue(SIZE);
 236         final CountDownLatch pleaseInterrupt = new CountDownLatch(1);
 237         Thread t = newStartedThread(new CheckedRunnable() {
 238             public void realRun() throws InterruptedException {
 239                 for (int i = 0; i &lt; SIZE; i++) assertEquals(i, q.take());
 240 
 241                 Thread.currentThread().interrupt();
 242                 try {
 243                     q.take();
 244                     shouldThrow();
 245                 } catch (InterruptedException success) {}
 246                 assertFalse(Thread.interrupted());
 247 
 248                 pleaseInterrupt.countDown();
 249                 try {
 250                     q.take();
 251                     shouldThrow();
 252                 } catch (InterruptedException success) {}
 253                 assertFalse(Thread.interrupted());
 254             }});
 255 
 256         await(pleaseInterrupt);
<a name="1" id="anc1"></a><span class="line-modified"> 257         assertThreadBlocks(t, Thread.State.WAITING);</span>
 258         t.interrupt();
 259         awaitTermination(t);
 260     }
 261 
 262     /**
 263      * poll succeeds unless empty
 264      */
 265     public void testPoll() throws InterruptedException {
 266         LinkedTransferQueue&lt;Integer&gt; q = populatedQueue(SIZE);
 267         for (int i = 0; i &lt; SIZE; ++i) {
 268             assertEquals(i, (int) q.poll());
 269         }
 270         assertNull(q.poll());
 271         checkEmpty(q);
 272     }
 273 
 274     /**
 275      * timed poll with zero timeout succeeds when non-empty, else times out
 276      */
 277     public void testTimedPoll0() throws InterruptedException {
 278         LinkedTransferQueue&lt;Integer&gt; q = populatedQueue(SIZE);
 279         for (int i = 0; i &lt; SIZE; ++i) {
 280             assertEquals(i, (int) q.poll(0, MILLISECONDS));
 281         }
 282         assertNull(q.poll(0, MILLISECONDS));
 283         checkEmpty(q);
 284     }
 285 
 286     /**
 287      * timed poll with nonzero timeout succeeds when non-empty, else times out
 288      */
 289     public void testTimedPoll() throws InterruptedException {
 290         LinkedTransferQueue&lt;Integer&gt; q = populatedQueue(SIZE);
 291         long startTime = System.nanoTime();
 292         for (int i = 0; i &lt; SIZE; ++i)
 293             assertEquals(i, (int) q.poll(LONG_DELAY_MS, MILLISECONDS));
 294         assertTrue(millisElapsedSince(startTime) &lt; LONG_DELAY_MS);
 295 
 296         startTime = System.nanoTime();
 297         assertNull(q.poll(timeoutMillis(), MILLISECONDS));
 298         assertTrue(millisElapsedSince(startTime) &gt;= timeoutMillis());
 299         checkEmpty(q);
 300     }
 301 
 302     /**
 303      * Interrupted timed poll throws InterruptedException instead of
 304      * returning timeout status
 305      */
 306     public void testInterruptedTimedPoll() throws InterruptedException {
 307         final BlockingQueue&lt;Integer&gt; q = populatedQueue(SIZE);
 308         final CountDownLatch pleaseInterrupt = new CountDownLatch(1);
 309         Thread t = newStartedThread(new CheckedRunnable() {
 310             public void realRun() throws InterruptedException {
<a name="2" id="anc2"></a><span class="line-removed"> 311                 long startTime = System.nanoTime();</span>
 312                 for (int i = 0; i &lt; SIZE; i++)
 313                     assertEquals(i, (int) q.poll(LONG_DELAY_MS, MILLISECONDS));
 314 
 315                 Thread.currentThread().interrupt();
 316                 try {
<a name="3" id="anc3"></a><span class="line-modified"> 317                     q.poll(LONG_DELAY_MS, MILLISECONDS);</span>
 318                     shouldThrow();
 319                 } catch (InterruptedException success) {}
 320                 assertFalse(Thread.interrupted());
 321 
 322                 pleaseInterrupt.countDown();
 323                 try {
<a name="4" id="anc4"></a><span class="line-modified"> 324                     q.poll(LONG_DELAY_MS, MILLISECONDS);</span>
 325                     shouldThrow();
 326                 } catch (InterruptedException success) {}
 327                 assertFalse(Thread.interrupted());
<a name="5" id="anc5"></a><span class="line-removed"> 328 </span>
<span class="line-removed"> 329                 assertTrue(millisElapsedSince(startTime) &lt; LONG_DELAY_MS);</span>
 330             }});
 331 
 332         await(pleaseInterrupt);
<a name="6" id="anc6"></a><span class="line-modified"> 333         assertThreadBlocks(t, Thread.State.TIMED_WAITING);</span>
 334         t.interrupt();
 335         awaitTermination(t);
 336         checkEmpty(q);
 337     }
 338 
 339     /**
 340      * timed poll after thread interrupted throws InterruptedException
 341      * instead of returning timeout status
 342      */
 343     public void testTimedPollAfterInterrupt() throws InterruptedException {
 344         final BlockingQueue&lt;Integer&gt; q = populatedQueue(SIZE);
 345         Thread t = newStartedThread(new CheckedRunnable() {
 346             public void realRun() throws InterruptedException {
<a name="7" id="anc7"></a><span class="line-removed"> 347                 long startTime = System.nanoTime();</span>
 348                 Thread.currentThread().interrupt();
 349                 for (int i = 0; i &lt; SIZE; ++i)
<a name="8" id="anc8"></a><span class="line-modified"> 350                     assertEquals(i, (int) q.poll(LONG_DELAY_MS, MILLISECONDS));</span>
 351                 try {
<a name="9" id="anc9"></a><span class="line-modified"> 352                     q.poll(LONG_DELAY_MS, MILLISECONDS);</span>
 353                     shouldThrow();
 354                 } catch (InterruptedException success) {}
 355                 assertFalse(Thread.interrupted());
<a name="10" id="anc10"></a><span class="line-removed"> 356                 assertTrue(millisElapsedSince(startTime) &lt; LONG_DELAY_MS);</span>
 357             }});
 358 
 359         awaitTermination(t);
 360         checkEmpty(q);
 361     }
 362 
 363     /**
 364      * peek returns next element, or null if empty
 365      */
 366     public void testPeek() throws InterruptedException {
 367         LinkedTransferQueue&lt;Integer&gt; q = populatedQueue(SIZE);
 368         for (int i = 0; i &lt; SIZE; ++i) {
 369             assertEquals(i, (int) q.peek());
 370             assertEquals(i, (int) q.poll());
 371             assertTrue(q.peek() == null ||
 372                        i != (int) q.peek());
 373         }
 374         assertNull(q.peek());
 375         checkEmpty(q);
 376     }
 377 
 378     /**
 379      * element returns next element, or throws NoSuchElementException if empty
 380      */
 381     public void testElement() throws InterruptedException {
 382         LinkedTransferQueue&lt;Integer&gt; q = populatedQueue(SIZE);
 383         for (int i = 0; i &lt; SIZE; ++i) {
 384             assertEquals(i, (int) q.element());
 385             assertEquals(i, (int) q.poll());
 386         }
 387         try {
 388             q.element();
 389             shouldThrow();
 390         } catch (NoSuchElementException success) {}
 391         checkEmpty(q);
 392     }
 393 
 394     /**
 395      * remove removes next element, or throws NoSuchElementException if empty
 396      */
 397     public void testRemove() throws InterruptedException {
 398         LinkedTransferQueue&lt;Integer&gt; q = populatedQueue(SIZE);
 399         for (int i = 0; i &lt; SIZE; ++i) {
 400             assertEquals(i, (int) q.remove());
 401         }
 402         try {
 403             q.remove();
 404             shouldThrow();
 405         } catch (NoSuchElementException success) {}
 406         checkEmpty(q);
 407     }
 408 
 409     /**
 410      * An add following remove(x) succeeds
 411      */
 412     public void testRemoveElementAndAdd() throws InterruptedException {
 413         LinkedTransferQueue q = new LinkedTransferQueue();
 414         assertTrue(q.add(one));
 415         assertTrue(q.add(two));
 416         assertTrue(q.remove(one));
 417         assertTrue(q.remove(two));
 418         assertTrue(q.add(three));
 419         assertSame(q.take(), three);
 420     }
 421 
 422     /**
 423      * contains(x) reports true when elements added but not yet removed
 424      */
 425     public void testContains() {
 426         LinkedTransferQueue&lt;Integer&gt; q = populatedQueue(SIZE);
 427         for (int i = 0; i &lt; SIZE; ++i) {
 428             assertTrue(q.contains(i));
 429             assertEquals(i, (int) q.poll());
 430             assertFalse(q.contains(i));
 431         }
 432     }
 433 
 434     /**
 435      * clear removes all elements
 436      */
 437     public void testClear() throws InterruptedException {
 438         LinkedTransferQueue q = populatedQueue(SIZE);
 439         q.clear();
 440         checkEmpty(q);
 441         assertEquals(Integer.MAX_VALUE, q.remainingCapacity());
 442         q.add(one);
 443         assertFalse(q.isEmpty());
 444         assertEquals(1, q.size());
 445         assertTrue(q.contains(one));
 446         q.clear();
 447         checkEmpty(q);
 448     }
 449 
 450     /**
 451      * containsAll(c) is true when c contains a subset of elements
 452      */
 453     public void testContainsAll() {
 454         LinkedTransferQueue&lt;Integer&gt; q = populatedQueue(SIZE);
 455         LinkedTransferQueue&lt;Integer&gt; p = new LinkedTransferQueue&lt;&gt;();
 456         for (int i = 0; i &lt; SIZE; ++i) {
 457             assertTrue(q.containsAll(p));
 458             assertFalse(p.containsAll(q));
 459             p.add(i);
 460         }
 461         assertTrue(p.containsAll(q));
 462     }
 463 
 464     /**
 465      * retainAll(c) retains only those elements of c and reports true
 466      * if changed
 467      */
 468     public void testRetainAll() {
 469         LinkedTransferQueue q = populatedQueue(SIZE);
 470         LinkedTransferQueue p = populatedQueue(SIZE);
 471         for (int i = 0; i &lt; SIZE; ++i) {
 472             boolean changed = q.retainAll(p);
 473             if (i == 0) {
 474                 assertFalse(changed);
 475             } else {
 476                 assertTrue(changed);
 477             }
 478             assertTrue(q.containsAll(p));
 479             assertEquals(SIZE - i, q.size());
 480             p.remove();
 481         }
 482     }
 483 
 484     /**
 485      * removeAll(c) removes only those elements of c and reports true
 486      * if changed
 487      */
 488     public void testRemoveAll() {
 489         for (int i = 1; i &lt; SIZE; ++i) {
 490             LinkedTransferQueue q = populatedQueue(SIZE);
 491             LinkedTransferQueue p = populatedQueue(i);
 492             assertTrue(q.removeAll(p));
 493             assertEquals(SIZE - i, q.size());
 494             for (int j = 0; j &lt; i; ++j) {
 495                 assertFalse(q.contains(p.remove()));
 496             }
 497         }
 498     }
 499 
 500     /**
 501      * toArray() contains all elements in FIFO order
 502      */
 503     public void testToArray() {
 504         LinkedTransferQueue q = populatedQueue(SIZE);
 505         Object[] a = q.toArray();
 506         assertSame(Object[].class, a.getClass());
 507         for (Object o : a)
 508             assertSame(o, q.poll());
 509         assertTrue(q.isEmpty());
 510     }
 511 
 512     /**
 513      * toArray(a) contains all elements in FIFO order
 514      */
 515     public void testToArray2() {
 516         LinkedTransferQueue&lt;Integer&gt; q = populatedQueue(SIZE);
 517         Integer[] ints = new Integer[SIZE];
 518         Integer[] array = q.toArray(ints);
 519         assertSame(ints, array);
 520         for (Integer o : ints)
 521             assertSame(o, q.poll());
 522         assertTrue(q.isEmpty());
 523     }
 524 
 525     /**
 526      * toArray(incompatible array type) throws ArrayStoreException
 527      */
 528     public void testToArray1_BadArg() {
 529         LinkedTransferQueue q = populatedQueue(SIZE);
 530         try {
 531             q.toArray(new String[10]);
 532             shouldThrow();
 533         } catch (ArrayStoreException success) {}
 534     }
 535 
 536     /**
 537      * iterator iterates through all elements
 538      */
 539     public void testIterator() throws InterruptedException {
 540         LinkedTransferQueue q = populatedQueue(SIZE);
 541         Iterator it = q.iterator();
 542         int i;
 543         for (i = 0; it.hasNext(); i++)
 544             assertTrue(q.contains(it.next()));
 545         assertEquals(i, SIZE);
 546         assertIteratorExhausted(it);
 547 
 548         it = q.iterator();
 549         for (i = 0; it.hasNext(); i++)
 550             assertEquals(it.next(), q.take());
 551         assertEquals(i, SIZE);
 552         assertIteratorExhausted(it);
 553     }
 554 
 555     /**
 556      * iterator of empty collection has no elements
 557      */
 558     public void testEmptyIterator() {
 559         assertIteratorExhausted(new LinkedTransferQueue().iterator());
 560     }
 561 
 562     /**
 563      * iterator.remove() removes current element
 564      */
 565     public void testIteratorRemove() {
 566         final LinkedTransferQueue q = new LinkedTransferQueue();
 567         q.add(two);
 568         q.add(one);
 569         q.add(three);
 570 
 571         Iterator it = q.iterator();
 572         it.next();
 573         it.remove();
 574 
 575         it = q.iterator();
 576         assertSame(it.next(), one);
 577         assertSame(it.next(), three);
 578         assertFalse(it.hasNext());
 579     }
 580 
 581     /**
 582      * iterator ordering is FIFO
 583      */
 584     public void testIteratorOrdering() {
 585         final LinkedTransferQueue&lt;Integer&gt; q = new LinkedTransferQueue&lt;&gt;();
 586         assertEquals(Integer.MAX_VALUE, q.remainingCapacity());
 587         q.add(one);
 588         q.add(two);
 589         q.add(three);
 590         assertEquals(Integer.MAX_VALUE, q.remainingCapacity());
 591         int k = 0;
 592         for (Integer n : q) {
 593             assertEquals(++k, (int) n);
 594         }
 595         assertEquals(3, k);
 596     }
 597 
 598     /**
 599      * Modifications do not cause iterators to fail
 600      */
 601     public void testWeaklyConsistentIteration() {
 602         final LinkedTransferQueue q = new LinkedTransferQueue();
 603         q.add(one);
 604         q.add(two);
 605         q.add(three);
 606         for (Iterator it = q.iterator(); it.hasNext();) {
 607             q.remove();
 608             it.next();
 609         }
 610         assertEquals(0, q.size());
 611     }
 612 
 613     /**
 614      * toString contains toStrings of elements
 615      */
 616     public void testToString() {
 617         LinkedTransferQueue q = populatedQueue(SIZE);
 618         String s = q.toString();
 619         for (int i = 0; i &lt; SIZE; ++i) {
 620             assertTrue(s.contains(String.valueOf(i)));
 621         }
 622     }
 623 
 624     /**
 625      * offer transfers elements across Executor tasks
 626      */
 627     public void testOfferInExecutor() {
 628         final LinkedTransferQueue q = new LinkedTransferQueue();
 629         final CheckedBarrier threadsStarted = new CheckedBarrier(2);
 630         final ExecutorService executor = Executors.newFixedThreadPool(2);
 631         try (PoolCleaner cleaner = cleaner(executor)) {
 632 
 633             executor.execute(new CheckedRunnable() {
 634                 public void realRun() throws InterruptedException {
 635                     threadsStarted.await();
 636                     long startTime = System.nanoTime();
 637                     assertTrue(q.offer(one, LONG_DELAY_MS, MILLISECONDS));
 638                     assertTrue(millisElapsedSince(startTime) &lt; LONG_DELAY_MS);
 639                 }});
 640 
 641             executor.execute(new CheckedRunnable() {
 642                 public void realRun() throws InterruptedException {
 643                     threadsStarted.await();
 644                     assertSame(one, q.take());
 645                     checkEmpty(q);
 646                 }});
 647         }
 648     }
 649 
 650     /**
 651      * timed poll retrieves elements across Executor threads
 652      */
 653     public void testPollInExecutor() {
 654         final LinkedTransferQueue q = new LinkedTransferQueue();
 655         final CheckedBarrier threadsStarted = new CheckedBarrier(2);
 656         final ExecutorService executor = Executors.newFixedThreadPool(2);
 657         try (PoolCleaner cleaner = cleaner(executor)) {
 658 
 659             executor.execute(new CheckedRunnable() {
 660                 public void realRun() throws InterruptedException {
 661                     assertNull(q.poll());
 662                     threadsStarted.await();
 663                     long startTime = System.nanoTime();
 664                     assertSame(one, q.poll(LONG_DELAY_MS, MILLISECONDS));
 665                     assertTrue(millisElapsedSince(startTime) &lt; LONG_DELAY_MS);
 666                     checkEmpty(q);
 667                 }});
 668 
 669             executor.execute(new CheckedRunnable() {
 670                 public void realRun() throws InterruptedException {
 671                     threadsStarted.await();
 672                     q.put(one);
 673                 }});
 674         }
 675     }
 676 
 677     /**
 678      * A deserialized/reserialized queue has same elements in same order
 679      */
 680     public void testSerialization() throws Exception {
 681         Queue x = populatedQueue(SIZE);
 682         Queue y = serialClone(x);
 683 
 684         assertNotSame(y, x);
 685         assertEquals(x.size(), y.size());
 686         assertEquals(x.toString(), y.toString());
 687         assertTrue(Arrays.equals(x.toArray(), y.toArray()));
 688         while (!x.isEmpty()) {
 689             assertFalse(y.isEmpty());
 690             assertEquals(x.remove(), y.remove());
 691         }
 692         assertTrue(y.isEmpty());
 693     }
 694 
 695     /**
 696      * drainTo(c) empties queue into another collection c
 697      */
 698     public void testDrainTo() {
 699         LinkedTransferQueue q = populatedQueue(SIZE);
 700         ArrayList l = new ArrayList();
 701         q.drainTo(l);
 702         assertEquals(0, q.size());
 703         assertEquals(SIZE, l.size());
 704         for (int i = 0; i &lt; SIZE; ++i) {
 705             assertEquals(i, l.get(i));
 706         }
 707         q.add(zero);
 708         q.add(one);
 709         assertFalse(q.isEmpty());
 710         assertTrue(q.contains(zero));
 711         assertTrue(q.contains(one));
 712         l.clear();
 713         q.drainTo(l);
 714         assertEquals(0, q.size());
 715         assertEquals(2, l.size());
 716         for (int i = 0; i &lt; 2; ++i) {
 717             assertEquals(i, l.get(i));
 718         }
 719     }
 720 
 721     /**
 722      * drainTo(c) empties full queue, unblocking a waiting put.
 723      */
 724     public void testDrainToWithActivePut() throws InterruptedException {
 725         final LinkedTransferQueue q = populatedQueue(SIZE);
 726         Thread t = newStartedThread(new CheckedRunnable() {
 727             public void realRun() {
 728                 q.put(SIZE + 1);
 729             }});
 730         ArrayList l = new ArrayList();
 731         q.drainTo(l);
 732         assertTrue(l.size() &gt;= SIZE);
 733         for (int i = 0; i &lt; SIZE; ++i)
 734             assertEquals(i, l.get(i));
 735         awaitTermination(t);
 736         assertTrue(q.size() + l.size() &gt;= SIZE);
 737     }
 738 
 739     /**
 740      * drainTo(c, n) empties first min(n, size) elements of queue into c
 741      */
 742     public void testDrainToN() {
 743         LinkedTransferQueue q = new LinkedTransferQueue();
 744         for (int i = 0; i &lt; SIZE + 2; ++i) {
 745             for (int j = 0; j &lt; SIZE; j++) {
 746                 assertTrue(q.offer(j));
 747             }
 748             ArrayList l = new ArrayList();
 749             q.drainTo(l, i);
 750             int k = (i &lt; SIZE) ? i : SIZE;
 751             assertEquals(k, l.size());
 752             assertEquals(SIZE - k, q.size());
 753             for (int j = 0; j &lt; k; ++j)
 754                 assertEquals(j, l.get(j));
 755             do {} while (q.poll() != null);
 756         }
 757     }
 758 
 759     /**
 760      * timed poll() or take() increments the waiting consumer count;
 761      * offer(e) decrements the waiting consumer count
 762      */
 763     public void testWaitingConsumer() throws InterruptedException {
 764         final LinkedTransferQueue q = new LinkedTransferQueue();
 765         assertEquals(0, q.getWaitingConsumerCount());
 766         assertFalse(q.hasWaitingConsumer());
 767         final CountDownLatch threadStarted = new CountDownLatch(1);
 768 
 769         Thread t = newStartedThread(new CheckedRunnable() {
 770             public void realRun() throws InterruptedException {
 771                 threadStarted.countDown();
 772                 long startTime = System.nanoTime();
 773                 assertSame(one, q.poll(LONG_DELAY_MS, MILLISECONDS));
 774                 assertEquals(0, q.getWaitingConsumerCount());
 775                 assertFalse(q.hasWaitingConsumer());
 776                 assertTrue(millisElapsedSince(startTime) &lt; LONG_DELAY_MS);
 777             }});
 778 
 779         threadStarted.await();
 780         Callable&lt;Boolean&gt; oneConsumer
 781             = new Callable&lt;Boolean&gt;() { public Boolean call() {
 782                 return q.hasWaitingConsumer()
 783                 &amp;&amp; q.getWaitingConsumerCount() == 1; }};
 784         waitForThreadToEnterWaitState(t, oneConsumer);
 785 
 786         assertTrue(q.offer(one));
 787         assertEquals(0, q.getWaitingConsumerCount());
 788         assertFalse(q.hasWaitingConsumer());
 789 
 790         awaitTermination(t);
 791     }
 792 
 793     /**
 794      * transfer(null) throws NullPointerException
 795      */
 796     public void testTransfer1() throws InterruptedException {
 797         try {
 798             LinkedTransferQueue q = new LinkedTransferQueue();
 799             q.transfer(null);
 800             shouldThrow();
 801         } catch (NullPointerException success) {}
 802     }
 803 
 804     /**
 805      * transfer waits until a poll occurs. The transferred element
 806      * is returned by the associated poll.
 807      */
 808     public void testTransfer2() throws InterruptedException {
 809         final LinkedTransferQueue&lt;Integer&gt; q = new LinkedTransferQueue&lt;&gt;();
 810         final CountDownLatch threadStarted = new CountDownLatch(1);
 811 
 812         Thread t = newStartedThread(new CheckedRunnable() {
 813             public void realRun() throws InterruptedException {
 814                 threadStarted.countDown();
 815                 q.transfer(five);
 816                 checkEmpty(q);
 817             }});
 818 
 819         threadStarted.await();
 820         Callable&lt;Boolean&gt; oneElement
 821             = new Callable&lt;Boolean&gt;() { public Boolean call() {
 822                 return !q.isEmpty() &amp;&amp; q.size() == 1; }};
 823         waitForThreadToEnterWaitState(t, oneElement);
 824 
 825         assertSame(five, q.poll());
 826         checkEmpty(q);
 827         awaitTermination(t);
 828     }
 829 
 830     /**
 831      * transfer waits until a poll occurs, and then transfers in fifo order
 832      */
 833     public void testTransfer3() throws InterruptedException {
 834         final LinkedTransferQueue&lt;Integer&gt; q = new LinkedTransferQueue&lt;&gt;();
 835 
 836         Thread first = newStartedThread(new CheckedRunnable() {
 837             public void realRun() throws InterruptedException {
 838                 q.transfer(four);
 839                 assertFalse(q.contains(four));
 840                 assertEquals(1, q.size());
 841             }});
 842 
 843         Thread interruptedThread = newStartedThread(
 844             new CheckedInterruptedRunnable() {
 845                 public void realRun() throws InterruptedException {
 846                     while (q.isEmpty())
 847                         Thread.yield();
 848                     q.transfer(five);
 849                 }});
 850 
 851         while (q.size() &lt; 2)
 852             Thread.yield();
 853         assertEquals(2, q.size());
 854         assertSame(four, q.poll());
 855         first.join();
 856         assertEquals(1, q.size());
 857         interruptedThread.interrupt();
 858         interruptedThread.join();
 859         checkEmpty(q);
 860     }
 861 
 862     /**
 863      * transfer waits until a poll occurs, at which point the polling
 864      * thread returns the element
 865      */
 866     public void testTransfer4() throws InterruptedException {
 867         final LinkedTransferQueue q = new LinkedTransferQueue();
 868 
 869         Thread t = newStartedThread(new CheckedRunnable() {
 870             public void realRun() throws InterruptedException {
 871                 q.transfer(four);
 872                 assertFalse(q.contains(four));
 873                 assertSame(three, q.poll());
 874             }});
 875 
 876         while (q.isEmpty())
 877             Thread.yield();
 878         assertFalse(q.isEmpty());
 879         assertEquals(1, q.size());
 880         assertTrue(q.offer(three));
 881         assertSame(four, q.poll());
 882         awaitTermination(t);
 883     }
 884 
 885     /**
 886      * transfer waits until a take occurs. The transferred element
 887      * is returned by the associated take.
 888      */
 889     public void testTransfer5() throws InterruptedException {
 890         final LinkedTransferQueue&lt;Integer&gt; q = new LinkedTransferQueue&lt;&gt;();
 891 
 892         Thread t = newStartedThread(new CheckedRunnable() {
 893             public void realRun() throws InterruptedException {
 894                 q.transfer(four);
 895                 checkEmpty(q);
 896             }});
 897 
 898         while (q.isEmpty())
 899             Thread.yield();
 900         assertFalse(q.isEmpty());
 901         assertEquals(1, q.size());
 902         assertSame(four, q.take());
 903         checkEmpty(q);
 904         awaitTermination(t);
 905     }
 906 
 907     /**
 908      * tryTransfer(null) throws NullPointerException
 909      */
 910     public void testTryTransfer1() {
 911         final LinkedTransferQueue q = new LinkedTransferQueue();
 912         try {
 913             q.tryTransfer(null);
 914             shouldThrow();
 915         } catch (NullPointerException success) {}
 916     }
 917 
 918     /**
 919      * tryTransfer returns false and does not enqueue if there are no
 920      * consumers waiting to poll or take.
 921      */
 922     public void testTryTransfer2() throws InterruptedException {
 923         final LinkedTransferQueue q = new LinkedTransferQueue();
 924         assertFalse(q.tryTransfer(new Object()));
 925         assertFalse(q.hasWaitingConsumer());
 926         checkEmpty(q);
 927     }
 928 
 929     /**
 930      * If there is a consumer waiting in timed poll, tryTransfer
 931      * returns true while successfully transfering object.
 932      */
 933     public void testTryTransfer3() throws InterruptedException {
 934         final Object hotPotato = new Object();
 935         final LinkedTransferQueue q = new LinkedTransferQueue();
 936 
 937         Thread t = newStartedThread(new CheckedRunnable() {
 938             public void realRun() {
 939                 while (! q.hasWaitingConsumer())
 940                     Thread.yield();
 941                 assertTrue(q.hasWaitingConsumer());
 942                 checkEmpty(q);
 943                 assertTrue(q.tryTransfer(hotPotato));
 944             }});
 945 
 946         long startTime = System.nanoTime();
 947         assertSame(hotPotato, q.poll(LONG_DELAY_MS, MILLISECONDS));
 948         assertTrue(millisElapsedSince(startTime) &lt; LONG_DELAY_MS);
 949         checkEmpty(q);
 950         awaitTermination(t);
 951     }
 952 
 953     /**
 954      * If there is a consumer waiting in take, tryTransfer returns
 955      * true while successfully transfering object.
 956      */
 957     public void testTryTransfer4() throws InterruptedException {
 958         final Object hotPotato = new Object();
 959         final LinkedTransferQueue q = new LinkedTransferQueue();
 960 
 961         Thread t = newStartedThread(new CheckedRunnable() {
 962             public void realRun() {
 963                 while (! q.hasWaitingConsumer())
 964                     Thread.yield();
 965                 assertTrue(q.hasWaitingConsumer());
 966                 checkEmpty(q);
 967                 assertTrue(q.tryTransfer(hotPotato));
 968             }});
 969 
 970         assertSame(q.take(), hotPotato);
 971         checkEmpty(q);
 972         awaitTermination(t);
 973     }
 974 
 975     /**
 976      * tryTransfer blocks interruptibly if no takers
 977      */
 978     public void testTryTransfer5() throws InterruptedException {
 979         final LinkedTransferQueue q = new LinkedTransferQueue();
 980         final CountDownLatch pleaseInterrupt = new CountDownLatch(1);
 981         assertTrue(q.isEmpty());
 982 
 983         Thread t = newStartedThread(new CheckedRunnable() {
 984             public void realRun() throws InterruptedException {
<a name="11" id="anc11"></a><span class="line-removed"> 985                 long startTime = System.nanoTime();</span>
 986                 Thread.currentThread().interrupt();
 987                 try {
<a name="12" id="anc12"></a><span class="line-modified"> 988                     q.tryTransfer(new Object(), LONG_DELAY_MS, MILLISECONDS);</span>
 989                     shouldThrow();
 990                 } catch (InterruptedException success) {}
 991                 assertFalse(Thread.interrupted());
 992 
 993                 pleaseInterrupt.countDown();
 994                 try {
<a name="13" id="anc13"></a><span class="line-modified"> 995                     q.tryTransfer(new Object(), LONG_DELAY_MS, MILLISECONDS);</span>
 996                     shouldThrow();
 997                 } catch (InterruptedException success) {}
 998                 assertFalse(Thread.interrupted());
<a name="14" id="anc14"></a><span class="line-removed"> 999                 assertTrue(millisElapsedSince(startTime) &lt; LONG_DELAY_MS);</span>
1000             }});
1001 
1002         await(pleaseInterrupt);
<a name="15" id="anc15"></a><span class="line-modified">1003         assertThreadBlocks(t, Thread.State.TIMED_WAITING);</span>
1004         t.interrupt();
1005         awaitTermination(t);
1006         checkEmpty(q);
1007     }
1008 
1009     /**
1010      * tryTransfer gives up after the timeout and returns false
1011      */
1012     public void testTryTransfer6() throws InterruptedException {
1013         final LinkedTransferQueue q = new LinkedTransferQueue();
1014 
1015         Thread t = newStartedThread(new CheckedRunnable() {
1016             public void realRun() throws InterruptedException {
1017                 long startTime = System.nanoTime();
1018                 assertFalse(q.tryTransfer(new Object(),
1019                                           timeoutMillis(), MILLISECONDS));
1020                 assertTrue(millisElapsedSince(startTime) &gt;= timeoutMillis());
1021                 checkEmpty(q);
1022             }});
1023 
1024         awaitTermination(t);
1025         checkEmpty(q);
1026     }
1027 
1028     /**
1029      * tryTransfer waits for any elements previously in to be removed
1030      * before transfering to a poll or take
1031      */
1032     public void testTryTransfer7() throws InterruptedException {
1033         final LinkedTransferQueue q = new LinkedTransferQueue();
1034         assertTrue(q.offer(four));
1035 
1036         Thread t = newStartedThread(new CheckedRunnable() {
1037             public void realRun() throws InterruptedException {
1038                 long startTime = System.nanoTime();
1039                 assertTrue(q.tryTransfer(five, LONG_DELAY_MS, MILLISECONDS));
1040                 assertTrue(millisElapsedSince(startTime) &lt; LONG_DELAY_MS);
1041                 checkEmpty(q);
1042             }});
1043 
1044         while (q.size() != 2)
1045             Thread.yield();
1046         assertEquals(2, q.size());
1047         assertSame(four, q.poll());
1048         assertSame(five, q.poll());
1049         checkEmpty(q);
1050         awaitTermination(t);
1051     }
1052 
1053     /**
1054      * tryTransfer attempts to enqueue into the queue and fails
1055      * returning false not enqueueing and the successive poll is null
1056      */
1057     public void testTryTransfer8() throws InterruptedException {
1058         final LinkedTransferQueue q = new LinkedTransferQueue();
1059         assertTrue(q.offer(four));
1060         assertEquals(1, q.size());
1061         long startTime = System.nanoTime();
1062         assertFalse(q.tryTransfer(five, timeoutMillis(), MILLISECONDS));
1063         assertTrue(millisElapsedSince(startTime) &gt;= timeoutMillis());
1064         assertEquals(1, q.size());
1065         assertSame(four, q.poll());
1066         assertNull(q.poll());
1067         checkEmpty(q);
1068     }
1069 
1070     private LinkedTransferQueue&lt;Integer&gt; populatedQueue(int n) {
1071         LinkedTransferQueue&lt;Integer&gt; q = new LinkedTransferQueue&lt;&gt;();
1072         checkEmpty(q);
1073         for (int i = 0; i &lt; n; i++) {
1074             assertEquals(i, q.size());
1075             assertTrue(q.offer(i));
1076             assertEquals(Integer.MAX_VALUE, q.remainingCapacity());
1077         }
1078         assertFalse(q.isEmpty());
1079         return q;
1080     }
1081 
1082     /**
1083      * remove(null), contains(null) always return false
1084      */
1085     public void testNeverContainsNull() {
1086         Collection&lt;?&gt;[] qs = {
1087             new LinkedTransferQueue&lt;Object&gt;(),
1088             populatedQueue(2),
1089         };
1090 
1091         for (Collection&lt;?&gt; q : qs) {
1092             assertFalse(q.contains(null));
1093             assertFalse(q.remove(null));
1094         }
1095     }
1096 }
<a name="16" id="anc16"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="16" type="hidden" />
</body>
</html>
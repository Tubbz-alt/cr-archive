<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames test/jdk/java/util/concurrent/tck/JSR166TestCase.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   3  *
   4  * This code is free software; you can redistribute it and/or modify it
   5  * under the terms of the GNU General Public License version 2 only, as
   6  * published by the Free Software Foundation.
   7  *
   8  * This code is distributed in the hope that it will be useful, but WITHOUT
   9  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  10  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  11  * version 2 for more details (a copy is included in the LICENSE file that
  12  * accompanied this code).
  13  *
  14  * You should have received a copy of the GNU General Public License version
  15  * 2 along with this work; if not, write to the Free Software Foundation,
  16  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  17  *
  18  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  19  * or visit www.oracle.com if you need additional information or have any
  20  * questions.
  21  */
  22 
  23 /*
  24  * This file is available under and governed by the GNU General Public
  25  * License version 2 only, as published by the Free Software Foundation.
  26  * However, the following notice accompanied the original version of this
  27  * file:
  28  *
  29  * Written by Doug Lea and Martin Buchholz with assistance from
  30  * members of JCP JSR-166 Expert Group and released to the public
  31  * domain, as explained at
  32  * http://creativecommons.org/publicdomain/zero/1.0/
  33  * Other contributors include Andrew Wright, Jeffrey Hayes,
  34  * Pat Fisher, Mike Judd.
  35  */
  36 
  37 /*
  38  * @test
  39  * @summary JSR-166 tck tests, in a number of variations.
  40  *          The first is the conformance testing variant,
  41  *          while others also test implementation details.
  42  * @build *
  43  * @modules java.management
  44  * @run junit/othervm/timeout=1000 JSR166TestCase
  45  * @run junit/othervm/timeout=1000
  46  *      --add-opens java.base/java.util.concurrent=ALL-UNNAMED
  47  *      --add-opens java.base/java.lang=ALL-UNNAMED
  48  *      -Djsr166.testImplementationDetails=true
  49  *      JSR166TestCase
  50  * @run junit/othervm/timeout=1000
  51  *      --add-opens java.base/java.util.concurrent=ALL-UNNAMED
  52  *      --add-opens java.base/java.lang=ALL-UNNAMED
  53  *      -Djsr166.testImplementationDetails=true
  54  *      -Djava.util.concurrent.ForkJoinPool.common.parallelism=0
  55  *      JSR166TestCase
  56  * @run junit/othervm/timeout=1000
  57  *      --add-opens java.base/java.util.concurrent=ALL-UNNAMED
  58  *      --add-opens java.base/java.lang=ALL-UNNAMED
  59  *      -Djsr166.testImplementationDetails=true
  60  *      -Djava.util.concurrent.ForkJoinPool.common.parallelism=1
  61  *      -Djava.util.secureRandomSeed=true
  62  *      JSR166TestCase
  63  * @run junit/othervm/timeout=1000/policy=tck.policy
  64  *      --add-opens java.base/java.util.concurrent=ALL-UNNAMED
  65  *      --add-opens java.base/java.lang=ALL-UNNAMED
  66  *      -Djsr166.testImplementationDetails=true
  67  *      JSR166TestCase
  68  */
  69 
  70 import static java.util.concurrent.TimeUnit.MILLISECONDS;
  71 import static java.util.concurrent.TimeUnit.MINUTES;
  72 import static java.util.concurrent.TimeUnit.NANOSECONDS;
  73 
  74 import java.io.ByteArrayInputStream;
  75 import java.io.ByteArrayOutputStream;
  76 import java.io.ObjectInputStream;
  77 import java.io.ObjectOutputStream;
  78 import java.lang.management.ManagementFactory;
<a name="1" id="anc1"></a><span class="line-added">  79 import java.lang.management.LockInfo;</span>
  80 import java.lang.management.ThreadInfo;
  81 import java.lang.management.ThreadMXBean;
  82 import java.lang.reflect.Constructor;
  83 import java.lang.reflect.Method;
  84 import java.lang.reflect.Modifier;
  85 import java.security.CodeSource;
  86 import java.security.Permission;
  87 import java.security.PermissionCollection;
  88 import java.security.Permissions;
  89 import java.security.Policy;
  90 import java.security.ProtectionDomain;
  91 import java.security.SecurityPermission;
  92 import java.util.ArrayList;
  93 import java.util.Arrays;
  94 import java.util.Collection;
  95 import java.util.Collections;
  96 import java.util.Date;
  97 import java.util.Deque;
  98 import java.util.Enumeration;
  99 import java.util.HashSet;
 100 import java.util.Iterator;
 101 import java.util.List;
 102 import java.util.NoSuchElementException;
 103 import java.util.PropertyPermission;
 104 import java.util.Set;
 105 import java.util.concurrent.BlockingQueue;
 106 import java.util.concurrent.Callable;
 107 import java.util.concurrent.CountDownLatch;
 108 import java.util.concurrent.CyclicBarrier;
 109 import java.util.concurrent.ExecutionException;
 110 import java.util.concurrent.Executor;
 111 import java.util.concurrent.Executors;
 112 import java.util.concurrent.ExecutorService;
 113 import java.util.concurrent.ForkJoinPool;
 114 import java.util.concurrent.Future;
 115 import java.util.concurrent.FutureTask;
 116 import java.util.concurrent.RecursiveAction;
 117 import java.util.concurrent.RecursiveTask;
 118 import java.util.concurrent.RejectedExecutionException;
 119 import java.util.concurrent.RejectedExecutionHandler;
 120 import java.util.concurrent.Semaphore;
 121 import java.util.concurrent.ScheduledExecutorService;
 122 import java.util.concurrent.ScheduledFuture;
 123 import java.util.concurrent.SynchronousQueue;
 124 import java.util.concurrent.ThreadFactory;
 125 import java.util.concurrent.ThreadLocalRandom;
 126 import java.util.concurrent.ThreadPoolExecutor;
 127 import java.util.concurrent.TimeUnit;
 128 import java.util.concurrent.TimeoutException;
 129 import java.util.concurrent.atomic.AtomicBoolean;
 130 import java.util.concurrent.atomic.AtomicReference;
 131 import java.util.regex.Pattern;
 132 
 133 import junit.framework.Test;
 134 import junit.framework.TestCase;
 135 import junit.framework.TestResult;
 136 import junit.framework.TestSuite;
 137 
 138 /**
 139  * Base class for JSR166 Junit TCK tests.  Defines some constants,
 140  * utility methods and classes, as well as a simple framework for
 141  * helping to make sure that assertions failing in generated threads
 142  * cause the associated test that generated them to itself fail (which
 143  * JUnit does not otherwise arrange).  The rules for creating such
 144  * tests are:
 145  *
 146  * &lt;ol&gt;
 147  *
 148  * &lt;li&gt;All code not running in the main test thread (manually spawned threads
 149  * or the common fork join pool) must be checked for failure (and completion!).
 150  * Mechanisms that can be used to ensure this are:
 151  *   &lt;ol&gt;
 152  *   &lt;li&gt;Signalling via a synchronizer like AtomicInteger or CountDownLatch
 153  *    that the task completed normally, which is checked before returning from
 154  *    the test method in the main thread.
 155  *   &lt;li&gt;Using the forms {@link #threadFail}, {@link #threadAssertTrue},
 156  *    or {@link #threadAssertNull}, (not {@code fail}, {@code assertTrue}, etc.)
 157  *    Only the most typically used JUnit assertion methods are defined
 158  *    this way, but enough to live with.
 159  *   &lt;li&gt;Recording failure explicitly using {@link #threadUnexpectedException}
 160  *    or {@link #threadRecordFailure}.
 161  *   &lt;li&gt;Using a wrapper like CheckedRunnable that uses one the mechanisms above.
 162  *   &lt;/ol&gt;
 163  *
 164  * &lt;li&gt;If you override {@link #setUp} or {@link #tearDown}, make sure
 165  * to invoke {@code super.setUp} and {@code super.tearDown} within
 166  * them. These methods are used to clear and check for thread
 167  * assertion failures.
 168  *
 169  * &lt;li&gt;All delays and timeouts must use one of the constants {@code
 170  * SHORT_DELAY_MS}, {@code SMALL_DELAY_MS}, {@code MEDIUM_DELAY_MS},
 171  * {@code LONG_DELAY_MS}. The idea here is that a SHORT is always
 172  * discriminable from zero time, and always allows enough time for the
 173  * small amounts of computation (creating a thread, calling a few
 174  * methods, etc) needed to reach a timeout point. Similarly, a SMALL
 175  * is always discriminable as larger than SHORT and smaller than
 176  * MEDIUM.  And so on. These constants are set to conservative values,
 177  * but even so, if there is ever any doubt, they can all be increased
 178  * in one spot to rerun tests on slower platforms.
 179  *
 180  * &lt;li&gt;All threads generated must be joined inside each test case
 181  * method (or {@code fail} to do so) before returning from the
 182  * method. The {@code joinPool} method can be used to do this when
 183  * using Executors.
 184  *
 185  * &lt;/ol&gt;
 186  *
 187  * &lt;p&gt;&lt;b&gt;Other notes&lt;/b&gt;
 188  * &lt;ul&gt;
 189  *
 190  * &lt;li&gt;Usually, there is one testcase method per JSR166 method
 191  * covering &quot;normal&quot; operation, and then as many exception-testing
 192  * methods as there are exceptions the method can throw. Sometimes
 193  * there are multiple tests per JSR166 method when the different
 194  * &quot;normal&quot; behaviors differ significantly. And sometimes testcases
 195  * cover multiple methods when they cannot be tested in isolation.
 196  *
 197  * &lt;li&gt;The documentation style for testcases is to provide as javadoc
 198  * a simple sentence or two describing the property that the testcase
 199  * method purports to test. The javadocs do not say anything about how
 200  * the property is tested. To find out, read the code.
 201  *
 202  * &lt;li&gt;These tests are &quot;conformance tests&quot;, and do not attempt to
 203  * test throughput, latency, scalability or other performance factors
 204  * (see the separate &quot;jtreg&quot; tests for a set intended to check these
 205  * for the most central aspects of functionality.) So, most tests use
 206  * the smallest sensible numbers of threads, collection sizes, etc
 207  * needed to check basic conformance.
 208  *
 209  * &lt;li&gt;The test classes currently do not declare inclusion in
 210  * any particular package to simplify things for people integrating
 211  * them in TCK test suites.
 212  *
 213  * &lt;li&gt;As a convenience, the {@code main} of this class (JSR166TestCase)
 214  * runs all JSR166 unit tests.
 215  *
 216  * &lt;/ul&gt;
 217  */
 218 public class JSR166TestCase extends TestCase {
 219     private static final boolean useSecurityManager =
 220         Boolean.getBoolean(&quot;jsr166.useSecurityManager&quot;);
 221 
 222     protected static final boolean expensiveTests =
 223         Boolean.getBoolean(&quot;jsr166.expensiveTests&quot;);
 224 
 225     /**
 226      * If true, also run tests that are not part of the official tck
 227      * because they test unspecified implementation details.
 228      */
 229     protected static final boolean testImplementationDetails =
 230         Boolean.getBoolean(&quot;jsr166.testImplementationDetails&quot;);
 231 
 232     /**
 233      * If true, report on stdout all &quot;slow&quot; tests, that is, ones that
 234      * take more than profileThreshold milliseconds to execute.
 235      */
 236     private static final boolean profileTests =
 237         Boolean.getBoolean(&quot;jsr166.profileTests&quot;);
 238 
 239     /**
 240      * The number of milliseconds that tests are permitted for
 241      * execution without being reported, when profileTests is set.
 242      */
 243     private static final long profileThreshold =
 244         Long.getLong(&quot;jsr166.profileThreshold&quot;, 100);
 245 
 246     /**
 247      * The number of repetitions per test (for tickling rare bugs).
 248      */
 249     private static final int runsPerTest =
 250         Integer.getInteger(&quot;jsr166.runsPerTest&quot;, 1);
 251 
 252     /**
 253      * The number of repetitions of the test suite (for finding leaks?).
 254      */
 255     private static final int suiteRuns =
 256         Integer.getInteger(&quot;jsr166.suiteRuns&quot;, 1);
 257 
 258     /**
 259      * Returns the value of the system property, or NaN if not defined.
 260      */
 261     private static float systemPropertyValue(String name) {
 262         String floatString = System.getProperty(name);
 263         if (floatString == null)
 264             return Float.NaN;
 265         try {
 266             return Float.parseFloat(floatString);
 267         } catch (NumberFormatException ex) {
 268             throw new IllegalArgumentException(
 269                 String.format(&quot;Bad float value in system property %s=%s&quot;,
 270                               name, floatString));
 271         }
 272     }
 273 
<a name="2" id="anc2"></a><span class="line-added"> 274     private static final ThreadMXBean THREAD_MXBEAN</span>
<span class="line-added"> 275         = ManagementFactory.getThreadMXBean();</span>
<span class="line-added"> 276 </span>
 277     /**
 278      * The scaling factor to apply to standard delays used in tests.
 279      * May be initialized from any of:
 280      * - the &quot;jsr166.delay.factor&quot; system property
 281      * - the &quot;test.timeout.factor&quot; system property (as used by jtreg)
 282      *   See: http://openjdk.java.net/jtreg/tag-spec.html
 283      * - hard-coded fuzz factor when using a known slowpoke VM
 284      */
 285     private static final float delayFactor = delayFactor();
 286 
 287     private static float delayFactor() {
 288         float x;
 289         if (!Float.isNaN(x = systemPropertyValue(&quot;jsr166.delay.factor&quot;)))
 290             return x;
 291         if (!Float.isNaN(x = systemPropertyValue(&quot;test.timeout.factor&quot;)))
 292             return x;
 293         String prop = System.getProperty(&quot;java.vm.version&quot;);
 294         if (prop != null &amp;&amp; prop.matches(&quot;.*debug.*&quot;))
 295             return 4.0f; // How much slower is fastdebug than product?!
 296         return 1.0f;
 297     }
 298 
 299     public JSR166TestCase() { super(); }
 300     public JSR166TestCase(String name) { super(name); }
 301 
 302     /**
 303      * A filter for tests to run, matching strings of the form
 304      * methodName(className), e.g. &quot;testInvokeAll5(ForkJoinPoolTest)&quot;
 305      * Usefully combined with jsr166.runsPerTest.
 306      */
 307     private static final Pattern methodFilter = methodFilter();
 308 
 309     private static Pattern methodFilter() {
 310         String regex = System.getProperty(&quot;jsr166.methodFilter&quot;);
 311         return (regex == null) ? null : Pattern.compile(regex);
 312     }
 313 
 314     // Instrumentation to debug very rare, but very annoying hung test runs.
 315     static volatile TestCase currentTestCase;
 316     // static volatile int currentRun = 0;
 317     static {
<a name="3" id="anc3"></a><span class="line-modified"> 318         Runnable wedgedTestDetector = new Runnable() { public void run() {</span>
 319             // Avoid spurious reports with enormous runsPerTest.
 320             // A single test case run should never take more than 1 second.
 321             // But let&#39;s cap it at the high end too ...
<a name="4" id="anc4"></a><span class="line-modified"> 322             final int timeoutMinutesMin = Math.max(runsPerTest / 60, 1)</span>
<span class="line-modified"> 323                 * Math.max((int) delayFactor, 1);</span>
<span class="line-added"> 324             final int timeoutMinutes = Math.min(15, timeoutMinutesMin);</span>
 325             for (TestCase lastTestCase = currentTestCase;;) {
 326                 try { MINUTES.sleep(timeoutMinutes); }
 327                 catch (InterruptedException unexpected) { break; }
 328                 if (lastTestCase == currentTestCase) {
 329                     System.err.printf(
 330                         &quot;Looks like we&#39;re stuck running test: %s%n&quot;,
 331                         lastTestCase);
 332 //                     System.err.printf(
 333 //                         &quot;Looks like we&#39;re stuck running test: %s (%d/%d)%n&quot;,
 334 //                         lastTestCase, currentRun, runsPerTest);
 335 //                     System.err.println(&quot;availableProcessors=&quot; +
 336 //                         Runtime.getRuntime().availableProcessors());
 337 //                     System.err.printf(&quot;cpu model = %s%n&quot;, cpuModel());
 338                     dumpTestThreads();
 339                     // one stack dump is probably enough; more would be spam
 340                     break;
 341                 }
 342                 lastTestCase = currentTestCase;
 343             }}};
<a name="5" id="anc5"></a><span class="line-modified"> 344         Thread thread = new Thread(wedgedTestDetector, &quot;WedgedTestDetector&quot;);</span>
 345         thread.setDaemon(true);
 346         thread.start();
 347     }
 348 
 349 //     public static String cpuModel() {
 350 //         try {
 351 //             java.util.regex.Matcher matcher
 352 //               = Pattern.compile(&quot;model name\\s*: (.*)&quot;)
 353 //                 .matcher(new String(
 354 //                     java.nio.file.Files.readAllBytes(
 355 //                         java.nio.file.Paths.get(&quot;/proc/cpuinfo&quot;)), &quot;UTF-8&quot;));
 356 //             matcher.find();
 357 //             return matcher.group(1);
 358 //         } catch (Exception ex) { return null; }
 359 //     }
 360 
 361     public void runBare() throws Throwable {
 362         currentTestCase = this;
 363         if (methodFilter == null
 364             || methodFilter.matcher(toString()).find())
 365             super.runBare();
 366     }
 367 
 368     protected void runTest() throws Throwable {
 369         for (int i = 0; i &lt; runsPerTest; i++) {
 370             // currentRun = i;
 371             if (profileTests)
 372                 runTestProfiled();
 373             else
 374                 super.runTest();
 375         }
 376     }
 377 
 378     protected void runTestProfiled() throws Throwable {
 379         for (int i = 0; i &lt; 2; i++) {
 380             long startTime = System.nanoTime();
 381             super.runTest();
 382             long elapsedMillis = millisElapsedSince(startTime);
 383             if (elapsedMillis &lt; profileThreshold)
 384                 break;
 385             // Never report first run of any test; treat it as a
 386             // warmup run, notably to trigger all needed classloading,
 387             if (i &gt; 0)
<a name="6" id="anc6"></a><span class="line-modified"> 388                 System.out.printf(&quot;%s: %d%n&quot;, toString(), elapsedMillis);</span>
 389         }
 390     }
 391 
 392     /**
 393      * Runs all JSR166 unit tests using junit.textui.TestRunner.
 394      */
 395     public static void main(String[] args) {
 396         main(suite(), args);
 397     }
 398 
 399     static class PithyResultPrinter extends junit.textui.ResultPrinter {
 400         PithyResultPrinter(java.io.PrintStream writer) { super(writer); }
 401         long runTime;
 402         public void startTest(Test test) {}
 403         protected void printHeader(long runTime) {
 404             this.runTime = runTime; // defer printing for later
 405         }
 406         protected void printFooter(TestResult result) {
 407             if (result.wasSuccessful()) {
 408                 getWriter().println(&quot;OK (&quot; + result.runCount() + &quot; tests)&quot;
 409                     + &quot;  Time: &quot; + elapsedTimeAsString(runTime));
 410             } else {
 411                 getWriter().println(&quot;Time: &quot; + elapsedTimeAsString(runTime));
 412                 super.printFooter(result);
 413             }
 414         }
 415     }
 416 
 417     /**
 418      * Returns a TestRunner that doesn&#39;t bother with unnecessary
 419      * fluff, like printing a &quot;.&quot; for each test case.
 420      */
 421     static junit.textui.TestRunner newPithyTestRunner() {
 422         junit.textui.TestRunner runner = new junit.textui.TestRunner();
 423         runner.setPrinter(new PithyResultPrinter(System.out));
 424         return runner;
 425     }
 426 
 427     /**
 428      * Runs all unit tests in the given test suite.
 429      * Actual behavior influenced by jsr166.* system properties.
 430      */
 431     static void main(Test suite, String[] args) {
 432         if (useSecurityManager) {
 433             System.err.println(&quot;Setting a permissive security manager&quot;);
 434             Policy.setPolicy(permissivePolicy());
 435             System.setSecurityManager(new SecurityManager());
 436         }
 437         for (int i = 0; i &lt; suiteRuns; i++) {
 438             TestResult result = newPithyTestRunner().doRun(suite);
 439             if (!result.wasSuccessful())
 440                 System.exit(1);
 441             System.gc();
 442             System.runFinalization();
 443         }
 444     }
 445 
 446     public static TestSuite newTestSuite(Object... suiteOrClasses) {
 447         TestSuite suite = new TestSuite();
 448         for (Object suiteOrClass : suiteOrClasses) {
 449             if (suiteOrClass instanceof TestSuite)
 450                 suite.addTest((TestSuite) suiteOrClass);
 451             else if (suiteOrClass instanceof Class)
 452                 suite.addTest(new TestSuite((Class&lt;?&gt;) suiteOrClass));
 453             else
 454                 throw new ClassCastException(&quot;not a test suite or class&quot;);
 455         }
 456         return suite;
 457     }
 458 
 459     public static void addNamedTestClasses(TestSuite suite,
 460                                            String... testClassNames) {
 461         for (String testClassName : testClassNames) {
 462             try {
 463                 Class&lt;?&gt; testClass = Class.forName(testClassName);
 464                 Method m = testClass.getDeclaredMethod(&quot;suite&quot;);
 465                 suite.addTest(newTestSuite((Test)m.invoke(null)));
 466             } catch (ReflectiveOperationException e) {
 467                 throw new AssertionError(&quot;Missing test class&quot;, e);
 468             }
 469         }
 470     }
 471 
 472     public static final double JAVA_CLASS_VERSION;
 473     public static final String JAVA_SPECIFICATION_VERSION;
 474     static {
 475         try {
 476             JAVA_CLASS_VERSION = java.security.AccessController.doPrivileged(
 477                 new java.security.PrivilegedAction&lt;Double&gt;() {
 478                 public Double run() {
 479                     return Double.valueOf(System.getProperty(&quot;java.class.version&quot;));}});
 480             JAVA_SPECIFICATION_VERSION = java.security.AccessController.doPrivileged(
 481                 new java.security.PrivilegedAction&lt;String&gt;() {
 482                 public String run() {
 483                     return System.getProperty(&quot;java.specification.version&quot;);}});
 484         } catch (Throwable t) {
 485             throw new Error(t);
 486         }
 487     }
 488 
 489     public static boolean atLeastJava6()  { return JAVA_CLASS_VERSION &gt;= 50.0; }
 490     public static boolean atLeastJava7()  { return JAVA_CLASS_VERSION &gt;= 51.0; }
 491     public static boolean atLeastJava8()  { return JAVA_CLASS_VERSION &gt;= 52.0; }
 492     public static boolean atLeastJava9()  { return JAVA_CLASS_VERSION &gt;= 53.0; }
 493     public static boolean atLeastJava10() { return JAVA_CLASS_VERSION &gt;= 54.0; }
 494     public static boolean atLeastJava11() { return JAVA_CLASS_VERSION &gt;= 55.0; }
 495     public static boolean atLeastJava12() { return JAVA_CLASS_VERSION &gt;= 56.0; }
 496     public static boolean atLeastJava13() { return JAVA_CLASS_VERSION &gt;= 57.0; }
 497     public static boolean atLeastJava14() { return JAVA_CLASS_VERSION &gt;= 58.0; }
 498     public static boolean atLeastJava15() { return JAVA_CLASS_VERSION &gt;= 59.0; }
 499     public static boolean atLeastJava16() { return JAVA_CLASS_VERSION &gt;= 60.0; }
 500     public static boolean atLeastJava17() { return JAVA_CLASS_VERSION &gt;= 61.0; }
 501 
 502     /**
 503      * Collects all JSR166 unit tests as one suite.
 504      */
 505     public static Test suite() {
 506         // Java7+ test classes
 507         TestSuite suite = newTestSuite(
 508             ForkJoinPoolTest.suite(),
 509             ForkJoinTaskTest.suite(),
 510             RecursiveActionTest.suite(),
 511             RecursiveTaskTest.suite(),
 512             LinkedTransferQueueTest.suite(),
 513             PhaserTest.suite(),
 514             ThreadLocalRandomTest.suite(),
 515             AbstractExecutorServiceTest.suite(),
 516             AbstractQueueTest.suite(),
 517             AbstractQueuedSynchronizerTest.suite(),
 518             AbstractQueuedLongSynchronizerTest.suite(),
 519             ArrayBlockingQueueTest.suite(),
 520             ArrayDequeTest.suite(),
 521             ArrayListTest.suite(),
 522             AtomicBooleanTest.suite(),
 523             AtomicIntegerArrayTest.suite(),
 524             AtomicIntegerFieldUpdaterTest.suite(),
 525             AtomicIntegerTest.suite(),
 526             AtomicLongArrayTest.suite(),
 527             AtomicLongFieldUpdaterTest.suite(),
 528             AtomicLongTest.suite(),
 529             AtomicMarkableReferenceTest.suite(),
 530             AtomicReferenceArrayTest.suite(),
 531             AtomicReferenceFieldUpdaterTest.suite(),
 532             AtomicReferenceTest.suite(),
 533             AtomicStampedReferenceTest.suite(),
 534             ConcurrentHashMapTest.suite(),
 535             ConcurrentLinkedDequeTest.suite(),
 536             ConcurrentLinkedQueueTest.suite(),
 537             ConcurrentSkipListMapTest.suite(),
 538             ConcurrentSkipListSubMapTest.suite(),
 539             ConcurrentSkipListSetTest.suite(),
 540             ConcurrentSkipListSubSetTest.suite(),
 541             CopyOnWriteArrayListTest.suite(),
 542             CopyOnWriteArraySetTest.suite(),
 543             CountDownLatchTest.suite(),
 544             CountedCompleterTest.suite(),
 545             CyclicBarrierTest.suite(),
 546             DelayQueueTest.suite(),
 547             EntryTest.suite(),
 548             ExchangerTest.suite(),
 549             ExecutorsTest.suite(),
 550             ExecutorCompletionServiceTest.suite(),
 551             FutureTaskTest.suite(),
<a name="7" id="anc7"></a><span class="line-added"> 552             HashtableTest.suite(),</span>
 553             LinkedBlockingDequeTest.suite(),
 554             LinkedBlockingQueueTest.suite(),
 555             LinkedListTest.suite(),
 556             LockSupportTest.suite(),
 557             PriorityBlockingQueueTest.suite(),
 558             PriorityQueueTest.suite(),
 559             ReentrantLockTest.suite(),
 560             ReentrantReadWriteLockTest.suite(),
 561             ScheduledExecutorTest.suite(),
 562             ScheduledExecutorSubclassTest.suite(),
 563             SemaphoreTest.suite(),
 564             SynchronousQueueTest.suite(),
 565             SystemTest.suite(),
 566             ThreadLocalTest.suite(),
 567             ThreadPoolExecutorTest.suite(),
 568             ThreadPoolExecutorSubclassTest.suite(),
 569             ThreadTest.suite(),
 570             TimeUnitTest.suite(),
 571             TreeMapTest.suite(),
 572             TreeSetTest.suite(),
 573             TreeSubMapTest.suite(),
 574             TreeSubSetTest.suite(),
 575             VectorTest.suite());
 576 
 577         // Java8+ test classes
 578         if (atLeastJava8()) {
 579             String[] java8TestClassNames = {
 580                 &quot;ArrayDeque8Test&quot;,
 581                 &quot;Atomic8Test&quot;,
 582                 &quot;CompletableFutureTest&quot;,
 583                 &quot;ConcurrentHashMap8Test&quot;,
 584                 &quot;CountedCompleter8Test&quot;,
 585                 &quot;DoubleAccumulatorTest&quot;,
 586                 &quot;DoubleAdderTest&quot;,
 587                 &quot;ForkJoinPool8Test&quot;,
 588                 &quot;ForkJoinTask8Test&quot;,
 589                 &quot;HashMapTest&quot;,
 590                 &quot;LinkedBlockingDeque8Test&quot;,
 591                 &quot;LinkedBlockingQueue8Test&quot;,
 592                 &quot;LinkedHashMapTest&quot;,
 593                 &quot;LongAccumulatorTest&quot;,
 594                 &quot;LongAdderTest&quot;,
 595                 &quot;SplittableRandomTest&quot;,
 596                 &quot;StampedLockTest&quot;,
 597                 &quot;SubmissionPublisherTest&quot;,
 598                 &quot;ThreadLocalRandom8Test&quot;,
 599                 &quot;TimeUnit8Test&quot;,
 600             };
 601             addNamedTestClasses(suite, java8TestClassNames);
 602         }
 603 
 604         // Java9+ test classes
 605         if (atLeastJava9()) {
 606             String[] java9TestClassNames = {
 607                 &quot;AtomicBoolean9Test&quot;,
 608                 &quot;AtomicInteger9Test&quot;,
 609                 &quot;AtomicIntegerArray9Test&quot;,
 610                 &quot;AtomicLong9Test&quot;,
 611                 &quot;AtomicLongArray9Test&quot;,
 612                 &quot;AtomicReference9Test&quot;,
 613                 &quot;AtomicReferenceArray9Test&quot;,
 614                 &quot;ExecutorCompletionService9Test&quot;,
 615                 &quot;ForkJoinPool9Test&quot;,
 616             };
 617             addNamedTestClasses(suite, java9TestClassNames);
 618         }
 619 
 620         return suite;
 621     }
 622 
 623     /** Returns list of junit-style test method names in given class. */
 624     public static ArrayList&lt;String&gt; testMethodNames(Class&lt;?&gt; testClass) {
 625         Method[] methods = testClass.getDeclaredMethods();
 626         ArrayList&lt;String&gt; names = new ArrayList&lt;&gt;(methods.length);
 627         for (Method method : methods) {
 628             if (method.getName().startsWith(&quot;test&quot;)
 629                 &amp;&amp; Modifier.isPublic(method.getModifiers())
 630                 // method.getParameterCount() requires jdk8+
 631                 &amp;&amp; method.getParameterTypes().length == 0) {
 632                 names.add(method.getName());
 633             }
 634         }
 635         return names;
 636     }
 637 
 638     /**
 639      * Returns junit-style testSuite for the given test class, but
 640      * parameterized by passing extra data to each test.
 641      */
 642     public static &lt;ExtraData&gt; Test parameterizedTestSuite
 643         (Class&lt;? extends JSR166TestCase&gt; testClass,
 644          Class&lt;ExtraData&gt; dataClass,
 645          ExtraData data) {
 646         try {
 647             TestSuite suite = new TestSuite();
 648             Constructor c =
 649                 testClass.getDeclaredConstructor(dataClass, String.class);
 650             for (String methodName : testMethodNames(testClass))
 651                 suite.addTest((Test) c.newInstance(data, methodName));
 652             return suite;
 653         } catch (ReflectiveOperationException e) {
 654             throw new AssertionError(e);
 655         }
 656     }
 657 
 658     /**
 659      * Returns junit-style testSuite for the jdk8 extension of the
 660      * given test class, but parameterized by passing extra data to
 661      * each test.  Uses reflection to allow compilation in jdk7.
 662      */
 663     public static &lt;ExtraData&gt; Test jdk8ParameterizedTestSuite
 664         (Class&lt;? extends JSR166TestCase&gt; testClass,
 665          Class&lt;ExtraData&gt; dataClass,
 666          ExtraData data) {
 667         if (atLeastJava8()) {
 668             String name = testClass.getName();
 669             String name8 = name.replaceAll(&quot;Test$&quot;, &quot;8Test&quot;);
 670             if (name.equals(name8)) throw new AssertionError(name);
 671             try {
 672                 return (Test)
 673                     Class.forName(name8)
 674                     .getMethod(&quot;testSuite&quot;, dataClass)
 675                     .invoke(null, data);
 676             } catch (ReflectiveOperationException e) {
 677                 throw new AssertionError(e);
 678             }
 679         } else {
 680             return new TestSuite();
 681         }
 682     }
 683 
 684     // Delays for timing-dependent tests, in milliseconds.
 685 
 686     public static long SHORT_DELAY_MS;
 687     public static long SMALL_DELAY_MS;
 688     public static long MEDIUM_DELAY_MS;
 689     public static long LONG_DELAY_MS;
 690 
<a name="8" id="anc8"></a><span class="line-added"> 691     /**</span>
<span class="line-added"> 692      * A delay significantly longer than LONG_DELAY_MS.</span>
<span class="line-added"> 693      * Use this in a thread that is waited for via awaitTermination(Thread).</span>
<span class="line-added"> 694      */</span>
<span class="line-added"> 695     public static long LONGER_DELAY_MS;</span>
<span class="line-added"> 696 </span>
 697     private static final long RANDOM_TIMEOUT;
 698     private static final long RANDOM_EXPIRED_TIMEOUT;
 699     private static final TimeUnit RANDOM_TIMEUNIT;
 700     static {
 701         ThreadLocalRandom rnd = ThreadLocalRandom.current();
 702         long[] timeouts = { Long.MIN_VALUE, -1, 0, 1, Long.MAX_VALUE };
 703         RANDOM_TIMEOUT = timeouts[rnd.nextInt(timeouts.length)];
 704         RANDOM_EXPIRED_TIMEOUT = timeouts[rnd.nextInt(3)];
 705         TimeUnit[] timeUnits = TimeUnit.values();
 706         RANDOM_TIMEUNIT = timeUnits[rnd.nextInt(timeUnits.length)];
 707     }
 708 
 709     /**
 710      * Returns a timeout for use when any value at all will do.
 711      */
 712     static long randomTimeout() { return RANDOM_TIMEOUT; }
 713 
 714     /**
 715      * Returns a timeout that means &quot;no waiting&quot;, i.e. not positive.
 716      */
 717     static long randomExpiredTimeout() { return RANDOM_EXPIRED_TIMEOUT; }
 718 
 719     /**
 720      * Returns a random non-null TimeUnit.
 721      */
 722     static TimeUnit randomTimeUnit() { return RANDOM_TIMEUNIT; }
 723 
<a name="9" id="anc9"></a><span class="line-added"> 724     /**</span>
<span class="line-added"> 725      * Returns a random boolean; a &quot;coin flip&quot;.</span>
<span class="line-added"> 726      */</span>
<span class="line-added"> 727     static boolean randomBoolean() {</span>
<span class="line-added"> 728         return ThreadLocalRandom.current().nextBoolean();</span>
<span class="line-added"> 729     }</span>
<span class="line-added"> 730 </span>
<span class="line-added"> 731     /**</span>
<span class="line-added"> 732      * Returns a random element from given choices.</span>
<span class="line-added"> 733      */</span>
<span class="line-added"> 734     &lt;T&gt; T chooseRandomly(List&lt;T&gt; choices) {</span>
<span class="line-added"> 735         return choices.get(ThreadLocalRandom.current().nextInt(choices.size()));</span>
<span class="line-added"> 736     }</span>
<span class="line-added"> 737 </span>
<span class="line-added"> 738     /**</span>
<span class="line-added"> 739      * Returns a random element from given choices.</span>
<span class="line-added"> 740      */</span>
<span class="line-added"> 741     &lt;T&gt; T chooseRandomly(T... choices) {</span>
<span class="line-added"> 742         return choices[ThreadLocalRandom.current().nextInt(choices.length)];</span>
<span class="line-added"> 743     }</span>
<span class="line-added"> 744 </span>
 745     /**
 746      * Returns the shortest timed delay. This can be scaled up for
 747      * slow machines using the jsr166.delay.factor system property,
 748      * or via jtreg&#39;s -timeoutFactor: flag.
 749      * http://openjdk.java.net/jtreg/command-help.html
 750      */
 751     protected long getShortDelay() {
 752         return (long) (50 * delayFactor);
 753     }
 754 
 755     /**
 756      * Sets delays as multiples of SHORT_DELAY.
 757      */
 758     protected void setDelays() {
 759         SHORT_DELAY_MS = getShortDelay();
 760         SMALL_DELAY_MS  = SHORT_DELAY_MS * 5;
 761         MEDIUM_DELAY_MS = SHORT_DELAY_MS * 10;
 762         LONG_DELAY_MS   = SHORT_DELAY_MS * 200;
<a name="10" id="anc10"></a><span class="line-added"> 763         LONGER_DELAY_MS = 2 * LONG_DELAY_MS;</span>
 764     }
 765 
 766     private static final long TIMEOUT_DELAY_MS
 767         = (long) (12.0 * Math.cbrt(delayFactor));
 768 
 769     /**
 770      * Returns a timeout in milliseconds to be used in tests that verify
 771      * that operations block or time out.  We want this to be longer
 772      * than the OS scheduling quantum, but not too long, so don&#39;t scale
 773      * linearly with delayFactor; we use &quot;crazy&quot; cube root instead.
 774      */
 775     static long timeoutMillis() {
 776         return TIMEOUT_DELAY_MS;
 777     }
 778 
 779     /**
 780      * Returns a new Date instance representing a time at least
 781      * delayMillis milliseconds in the future.
 782      */
 783     Date delayedDate(long delayMillis) {
 784         // Add 1 because currentTimeMillis is known to round into the past.
 785         return new Date(System.currentTimeMillis() + delayMillis + 1);
 786     }
 787 
 788     /**
 789      * The first exception encountered if any threadAssertXXX method fails.
 790      */
 791     private final AtomicReference&lt;Throwable&gt; threadFailure
 792         = new AtomicReference&lt;&gt;(null);
 793 
 794     /**
 795      * Records an exception so that it can be rethrown later in the test
 796      * harness thread, triggering a test case failure.  Only the first
 797      * failure is recorded; subsequent calls to this method from within
 798      * the same test have no effect.
 799      */
 800     public void threadRecordFailure(Throwable t) {
 801         System.err.println(t);
<a name="11" id="anc11"></a><span class="line-modified"> 802         if (threadFailure.compareAndSet(null, t))</span>
<span class="line-modified"> 803             dumpTestThreads();</span>
 804     }
 805 
 806     public void setUp() {
 807         setDelays();
 808     }
 809 
 810     void tearDownFail(String format, Object... args) {
 811         String msg = toString() + &quot;: &quot; + String.format(format, args);
 812         System.err.println(msg);
 813         dumpTestThreads();
 814         throw new AssertionError(msg);
 815     }
 816 
 817     /**
 818      * Extra checks that get done for all test cases.
 819      *
 820      * Triggers test case failure if any thread assertions have failed,
 821      * by rethrowing, in the test harness thread, any exception recorded
 822      * earlier by threadRecordFailure.
 823      *
 824      * Triggers test case failure if interrupt status is set in the main thread.
 825      */
 826     public void tearDown() throws Exception {
 827         Throwable t = threadFailure.getAndSet(null);
 828         if (t != null) {
 829             if (t instanceof Error)
 830                 throw (Error) t;
 831             else if (t instanceof RuntimeException)
 832                 throw (RuntimeException) t;
 833             else if (t instanceof Exception)
 834                 throw (Exception) t;
 835             else
 836                 throw new AssertionError(t.toString(), t);
 837         }
 838 
 839         if (Thread.interrupted())
 840             tearDownFail(&quot;interrupt status set in main thread&quot;);
 841 
 842         checkForkJoinPoolThreadLeaks();
 843     }
 844 
 845     /**
 846      * Finds missing PoolCleaners
 847      */
 848     void checkForkJoinPoolThreadLeaks() throws InterruptedException {
 849         Thread[] survivors = new Thread[7];
 850         int count = Thread.enumerate(survivors);
 851         for (int i = 0; i &lt; count; i++) {
 852             Thread thread = survivors[i];
 853             String name = thread.getName();
 854             if (name.startsWith(&quot;ForkJoinPool-&quot;)) {
 855                 // give thread some time to terminate
 856                 thread.join(LONG_DELAY_MS);
 857                 if (thread.isAlive())
 858                     tearDownFail(&quot;Found leaked ForkJoinPool thread thread=%s&quot;,
 859                                  thread);
 860             }
 861         }
 862 
 863         if (!ForkJoinPool.commonPool()
 864             .awaitQuiescence(LONG_DELAY_MS, MILLISECONDS))
 865             tearDownFail(&quot;ForkJoin common pool thread stuck&quot;);
 866     }
 867 
 868     /**
 869      * Just like fail(reason), but additionally recording (using
 870      * threadRecordFailure) any AssertionError thrown, so that the
 871      * current testcase will fail.
 872      */
 873     public void threadFail(String reason) {
 874         try {
 875             fail(reason);
 876         } catch (AssertionError fail) {
 877             threadRecordFailure(fail);
 878             throw fail;
 879         }
 880     }
 881 
 882     /**
 883      * Just like assertTrue(b), but additionally recording (using
 884      * threadRecordFailure) any AssertionError thrown, so that the
 885      * current testcase will fail.
 886      */
 887     public void threadAssertTrue(boolean b) {
 888         try {
 889             assertTrue(b);
 890         } catch (AssertionError fail) {
 891             threadRecordFailure(fail);
 892             throw fail;
 893         }
 894     }
 895 
 896     /**
 897      * Just like assertFalse(b), but additionally recording (using
 898      * threadRecordFailure) any AssertionError thrown, so that the
 899      * current testcase will fail.
 900      */
 901     public void threadAssertFalse(boolean b) {
 902         try {
 903             assertFalse(b);
 904         } catch (AssertionError fail) {
 905             threadRecordFailure(fail);
 906             throw fail;
 907         }
 908     }
 909 
 910     /**
 911      * Just like assertNull(x), but additionally recording (using
 912      * threadRecordFailure) any AssertionError thrown, so that the
 913      * current testcase will fail.
 914      */
 915     public void threadAssertNull(Object x) {
 916         try {
 917             assertNull(x);
 918         } catch (AssertionError fail) {
 919             threadRecordFailure(fail);
 920             throw fail;
 921         }
 922     }
 923 
 924     /**
 925      * Just like assertEquals(x, y), but additionally recording (using
 926      * threadRecordFailure) any AssertionError thrown, so that the
 927      * current testcase will fail.
 928      */
 929     public void threadAssertEquals(long x, long y) {
 930         try {
 931             assertEquals(x, y);
 932         } catch (AssertionError fail) {
 933             threadRecordFailure(fail);
 934             throw fail;
 935         }
 936     }
 937 
 938     /**
 939      * Just like assertEquals(x, y), but additionally recording (using
 940      * threadRecordFailure) any AssertionError thrown, so that the
 941      * current testcase will fail.
 942      */
 943     public void threadAssertEquals(Object x, Object y) {
 944         try {
 945             assertEquals(x, y);
 946         } catch (AssertionError fail) {
 947             threadRecordFailure(fail);
 948             throw fail;
 949         } catch (Throwable fail) {
 950             threadUnexpectedException(fail);
 951         }
 952     }
 953 
 954     /**
 955      * Just like assertSame(x, y), but additionally recording (using
 956      * threadRecordFailure) any AssertionError thrown, so that the
 957      * current testcase will fail.
 958      */
 959     public void threadAssertSame(Object x, Object y) {
 960         try {
 961             assertSame(x, y);
 962         } catch (AssertionError fail) {
 963             threadRecordFailure(fail);
 964             throw fail;
 965         }
 966     }
 967 
 968     /**
 969      * Calls threadFail with message &quot;should throw exception&quot;.
 970      */
 971     public void threadShouldThrow() {
 972         threadFail(&quot;should throw exception&quot;);
 973     }
 974 
 975     /**
 976      * Calls threadFail with message &quot;should throw&quot; + exceptionName.
 977      */
 978     public void threadShouldThrow(String exceptionName) {
 979         threadFail(&quot;should throw &quot; + exceptionName);
 980     }
 981 
 982     /**
 983      * Records the given exception using {@link #threadRecordFailure},
 984      * then rethrows the exception, wrapping it in an AssertionError
 985      * if necessary.
 986      */
 987     public void threadUnexpectedException(Throwable t) {
 988         threadRecordFailure(t);
 989         t.printStackTrace();
 990         if (t instanceof RuntimeException)
 991             throw (RuntimeException) t;
 992         else if (t instanceof Error)
 993             throw (Error) t;
 994         else
 995             throw new AssertionError(&quot;unexpected exception: &quot; + t, t);
 996     }
 997 
 998     /**
 999      * Delays, via Thread.sleep, for the given millisecond delay, but
1000      * if the sleep is shorter than specified, may re-sleep or yield
1001      * until time elapses.  Ensures that the given time, as measured
1002      * by System.nanoTime(), has elapsed.
1003      */
1004     static void delay(long millis) throws InterruptedException {
1005         long nanos = millis * (1000 * 1000);
1006         final long wakeupTime = System.nanoTime() + nanos;
1007         do {
1008             if (millis &gt; 0L)
1009                 Thread.sleep(millis);
1010             else // too short to sleep
1011                 Thread.yield();
1012             nanos = wakeupTime - System.nanoTime();
1013             millis = nanos / (1000 * 1000);
1014         } while (nanos &gt;= 0L);
1015     }
1016 
1017     /**
1018      * Allows use of try-with-resources with per-test thread pools.
1019      */
1020     class PoolCleaner implements AutoCloseable {
1021         private final ExecutorService pool;
1022         public PoolCleaner(ExecutorService pool) { this.pool = pool; }
1023         public void close() { joinPool(pool); }
1024     }
1025 
1026     /**
1027      * An extension of PoolCleaner that has an action to release the pool.
1028      */
1029     class PoolCleanerWithReleaser extends PoolCleaner {
1030         private final Runnable releaser;
1031         public PoolCleanerWithReleaser(ExecutorService pool, Runnable releaser) {
1032             super(pool);
1033             this.releaser = releaser;
1034         }
1035         public void close() {
1036             try {
1037                 releaser.run();
1038             } finally {
1039                 super.close();
1040             }
1041         }
1042     }
1043 
1044     PoolCleaner cleaner(ExecutorService pool) {
1045         return new PoolCleaner(pool);
1046     }
1047 
1048     PoolCleaner cleaner(ExecutorService pool, Runnable releaser) {
1049         return new PoolCleanerWithReleaser(pool, releaser);
1050     }
1051 
1052     PoolCleaner cleaner(ExecutorService pool, CountDownLatch latch) {
1053         return new PoolCleanerWithReleaser(pool, releaser(latch));
1054     }
1055 
1056     Runnable releaser(final CountDownLatch latch) {
1057         return new Runnable() { public void run() {
1058             do { latch.countDown(); }
1059             while (latch.getCount() &gt; 0);
1060         }};
1061     }
1062 
1063     PoolCleaner cleaner(ExecutorService pool, AtomicBoolean flag) {
1064         return new PoolCleanerWithReleaser(pool, releaser(flag));
1065     }
1066 
1067     Runnable releaser(final AtomicBoolean flag) {
1068         return new Runnable() { public void run() { flag.set(true); }};
1069     }
1070 
1071     /**
1072      * Waits out termination of a thread pool or fails doing so.
1073      */
1074     void joinPool(ExecutorService pool) {
1075         try {
1076             pool.shutdown();
1077             if (!pool.awaitTermination(2 * LONG_DELAY_MS, MILLISECONDS)) {
1078                 try {
1079                     threadFail(&quot;ExecutorService &quot; + pool +
1080                                &quot; did not terminate in a timely manner&quot;);
1081                 } finally {
1082                     // last resort, for the benefit of subsequent tests
1083                     pool.shutdownNow();
1084                     pool.awaitTermination(MEDIUM_DELAY_MS, MILLISECONDS);
1085                 }
1086             }
1087         } catch (SecurityException ok) {
1088             // Allowed in case test doesn&#39;t have privs
1089         } catch (InterruptedException fail) {
1090             threadFail(&quot;Unexpected InterruptedException&quot;);
1091         }
1092     }
1093 
1094     /**
1095      * Like Runnable, but with the freedom to throw anything.
1096      * junit folks had the same idea:
1097      * http://junit.org/junit5/docs/snapshot/api/org/junit/gen5/api/Executable.html
1098      */
1099     interface Action { public void run() throws Throwable; }
1100 
1101     /**
1102      * Runs all the given actions in parallel, failing if any fail.
1103      * Useful for running multiple variants of tests that are
1104      * necessarily individually slow because they must block.
1105      */
1106     void testInParallel(Action ... actions) {
1107         ExecutorService pool = Executors.newCachedThreadPool();
1108         try (PoolCleaner cleaner = cleaner(pool)) {
1109             ArrayList&lt;Future&lt;?&gt;&gt; futures = new ArrayList&lt;&gt;(actions.length);
1110             for (final Action action : actions)
1111                 futures.add(pool.submit(new CheckedRunnable() {
1112                     public void realRun() throws Throwable { action.run();}}));
1113             for (Future&lt;?&gt; future : futures)
1114                 try {
1115                     assertNull(future.get(LONG_DELAY_MS, MILLISECONDS));
1116                 } catch (ExecutionException ex) {
1117                     threadUnexpectedException(ex.getCause());
1118                 } catch (Exception ex) {
1119                     threadUnexpectedException(ex);
1120                 }
1121         }
1122     }
1123 
<a name="12" id="anc12"></a><span class="line-added">1124     /** Returns true if thread info might be useful in a thread dump. */</span>
<span class="line-added">1125     static boolean threadOfInterest(ThreadInfo info) {</span>
<span class="line-added">1126         final String name = info.getThreadName();</span>
<span class="line-added">1127         String lockName;</span>
<span class="line-added">1128         if (name == null)</span>
<span class="line-added">1129             return true;</span>
<span class="line-added">1130         if (name.equals(&quot;Signal Dispatcher&quot;)</span>
<span class="line-added">1131             || name.equals(&quot;WedgedTestDetector&quot;))</span>
<span class="line-added">1132             return false;</span>
<span class="line-added">1133         if (name.equals(&quot;Reference Handler&quot;)) {</span>
<span class="line-added">1134             // Reference Handler stacktrace changed in JDK-8156500</span>
<span class="line-added">1135             StackTraceElement[] stackTrace; String methodName;</span>
<span class="line-added">1136             if ((stackTrace = info.getStackTrace()) != null</span>
<span class="line-added">1137                 &amp;&amp; stackTrace.length &gt; 0</span>
<span class="line-added">1138                 &amp;&amp; (methodName = stackTrace[0].getMethodName()) != null</span>
<span class="line-added">1139                 &amp;&amp; methodName.equals(&quot;waitForReferencePendingList&quot;))</span>
<span class="line-added">1140                 return false;</span>
<span class="line-added">1141             // jdk8 Reference Handler stacktrace</span>
<span class="line-added">1142             if ((lockName = info.getLockName()) != null</span>
<span class="line-added">1143                 &amp;&amp; lockName.startsWith(&quot;java.lang.ref&quot;))</span>
<span class="line-added">1144                 return false;</span>
<span class="line-added">1145         }</span>
<span class="line-added">1146         if ((name.equals(&quot;Finalizer&quot;) || name.equals(&quot;Common-Cleaner&quot;))</span>
<span class="line-added">1147             &amp;&amp; (lockName = info.getLockName()) != null</span>
<span class="line-added">1148             &amp;&amp; lockName.startsWith(&quot;java.lang.ref&quot;))</span>
<span class="line-added">1149             return false;</span>
<span class="line-added">1150         if (name.startsWith(&quot;ForkJoinPool.commonPool-worker&quot;)</span>
<span class="line-added">1151             &amp;&amp; (lockName = info.getLockName()) != null</span>
<span class="line-added">1152             &amp;&amp; lockName.startsWith(&quot;java.util.concurrent.ForkJoinPool&quot;))</span>
<span class="line-added">1153             return false;</span>
<span class="line-added">1154         return true;</span>
<span class="line-added">1155     }</span>
<span class="line-added">1156 </span>
1157     /**
1158      * A debugging tool to print stack traces of most threads, as jstack does.
1159      * Uninteresting threads are filtered out.
1160      */
1161     static void dumpTestThreads() {
1162         SecurityManager sm = System.getSecurityManager();
1163         if (sm != null) {
1164             try {
1165                 System.setSecurityManager(null);
1166             } catch (SecurityException giveUp) {
1167                 return;
1168             }
1169         }
1170 
<a name="13" id="anc13"></a>
1171         System.err.println(&quot;------ stacktrace dump start ------&quot;);
<a name="14" id="anc14"></a><span class="line-modified">1172         for (ThreadInfo info : THREAD_MXBEAN.dumpAllThreads(true, true))</span>
<span class="line-modified">1173             if (threadOfInterest(info))</span>
<span class="line-modified">1174                 System.err.print(info);</span>














1175         System.err.println(&quot;------ stacktrace dump end ------&quot;);
1176 
1177         if (sm != null) System.setSecurityManager(sm);
1178     }
1179 
1180     /**
1181      * Checks that thread eventually enters the expected blocked thread state.
1182      */
1183     void assertThreadBlocks(Thread thread, Thread.State expected) {
1184         // always sleep at least 1 ms, with high probability avoiding
1185         // transitory states
1186         for (long retries = LONG_DELAY_MS * 3 / 4; retries--&gt;0; ) {
1187             try { delay(1); }
1188             catch (InterruptedException fail) {
1189                 throw new AssertionError(&quot;Unexpected InterruptedException&quot;, fail);
1190             }
1191             Thread.State s = thread.getState();
1192             if (s == expected)
1193                 return;
1194             else if (s == Thread.State.TERMINATED)
1195                 fail(&quot;Unexpected thread termination&quot;);
1196         }
1197         fail(&quot;timed out waiting for thread to enter thread state &quot; + expected);
1198     }
1199 
<a name="15" id="anc15"></a><span class="line-added">1200     /**</span>
<span class="line-added">1201      * Returns the thread&#39;s blocker&#39;s class name, if any, else null.</span>
<span class="line-added">1202      */</span>
<span class="line-added">1203     String blockerClassName(Thread thread) {</span>
<span class="line-added">1204         ThreadInfo threadInfo; LockInfo lockInfo;</span>
<span class="line-added">1205         if ((threadInfo = THREAD_MXBEAN.getThreadInfo(thread.getId(), 0)) != null</span>
<span class="line-added">1206             &amp;&amp; (lockInfo = threadInfo.getLockInfo()) != null)</span>
<span class="line-added">1207             return lockInfo.getClassName();</span>
<span class="line-added">1208         return null;</span>
<span class="line-added">1209     }</span>
<span class="line-added">1210 </span>
1211     /**
1212      * Checks that future.get times out, with the default timeout of
1213      * {@code timeoutMillis()}.
1214      */
1215     void assertFutureTimesOut(Future future) {
1216         assertFutureTimesOut(future, timeoutMillis());
1217     }
1218 
1219     /**
1220      * Checks that future.get times out, with the given millisecond timeout.
1221      */
1222     void assertFutureTimesOut(Future future, long timeoutMillis) {
1223         long startTime = System.nanoTime();
1224         try {
1225             future.get(timeoutMillis, MILLISECONDS);
1226             shouldThrow();
1227         } catch (TimeoutException success) {
1228         } catch (Exception fail) {
1229             threadUnexpectedException(fail);
1230         } finally { future.cancel(true); }
1231         assertTrue(millisElapsedSince(startTime) &gt;= timeoutMillis);
1232     }
1233 
1234     /**
1235      * Fails with message &quot;should throw exception&quot;.
1236      */
1237     public void shouldThrow() {
1238         fail(&quot;Should throw exception&quot;);
1239     }
1240 
1241     /**
1242      * Fails with message &quot;should throw &quot; + exceptionName.
1243      */
1244     public void shouldThrow(String exceptionName) {
1245         fail(&quot;Should throw &quot; + exceptionName);
1246     }
1247 
1248     /**
1249      * The maximum number of consecutive spurious wakeups we should
1250      * tolerate (from APIs like LockSupport.park) before failing a test.
1251      */
1252     static final int MAX_SPURIOUS_WAKEUPS = 10;
1253 
1254     /**
1255      * The number of elements to place in collections, arrays, etc.
1256      */
1257     public static final int SIZE = 20;
1258 
1259     // Some convenient Integer constants
1260 
1261     public static final Integer zero  = new Integer(0);
1262     public static final Integer one   = new Integer(1);
1263     public static final Integer two   = new Integer(2);
1264     public static final Integer three = new Integer(3);
1265     public static final Integer four  = new Integer(4);
1266     public static final Integer five  = new Integer(5);
1267     public static final Integer six   = new Integer(6);
1268     public static final Integer seven = new Integer(7);
1269     public static final Integer eight = new Integer(8);
1270     public static final Integer nine  = new Integer(9);
1271     public static final Integer m1  = new Integer(-1);
1272     public static final Integer m2  = new Integer(-2);
1273     public static final Integer m3  = new Integer(-3);
1274     public static final Integer m4  = new Integer(-4);
1275     public static final Integer m5  = new Integer(-5);
1276     public static final Integer m6  = new Integer(-6);
1277     public static final Integer m10 = new Integer(-10);
1278 
1279     /**
1280      * Runs Runnable r with a security policy that permits precisely
1281      * the specified permissions.  If there is no current security
1282      * manager, the runnable is run twice, both with and without a
1283      * security manager.  We require that any security manager permit
1284      * getPolicy/setPolicy.
1285      */
1286     public void runWithPermissions(Runnable r, Permission... permissions) {
1287         SecurityManager sm = System.getSecurityManager();
1288         if (sm == null) {
1289             r.run();
1290         }
1291         runWithSecurityManagerWithPermissions(r, permissions);
1292     }
1293 
1294     /**
1295      * Runs Runnable r with a security policy that permits precisely
1296      * the specified permissions.  If there is no current security
1297      * manager, a temporary one is set for the duration of the
1298      * Runnable.  We require that any security manager permit
1299      * getPolicy/setPolicy.
1300      */
1301     public void runWithSecurityManagerWithPermissions(Runnable r,
1302                                                       Permission... permissions) {
1303         SecurityManager sm = System.getSecurityManager();
1304         if (sm == null) {
1305             Policy savedPolicy = Policy.getPolicy();
1306             try {
1307                 Policy.setPolicy(permissivePolicy());
1308                 System.setSecurityManager(new SecurityManager());
1309                 runWithSecurityManagerWithPermissions(r, permissions);
1310             } finally {
1311                 System.setSecurityManager(null);
1312                 Policy.setPolicy(savedPolicy);
1313             }
1314         } else {
1315             Policy savedPolicy = Policy.getPolicy();
1316             AdjustablePolicy policy = new AdjustablePolicy(permissions);
1317             Policy.setPolicy(policy);
1318 
1319             try {
1320                 r.run();
1321             } finally {
1322                 policy.addPermission(new SecurityPermission(&quot;setPolicy&quot;));
1323                 Policy.setPolicy(savedPolicy);
1324             }
1325         }
1326     }
1327 
1328     /**
1329      * Runs a runnable without any permissions.
1330      */
1331     public void runWithoutPermissions(Runnable r) {
1332         runWithPermissions(r);
1333     }
1334 
1335     /**
1336      * A security policy where new permissions can be dynamically added
1337      * or all cleared.
1338      */
1339     public static class AdjustablePolicy extends java.security.Policy {
1340         Permissions perms = new Permissions();
1341         AdjustablePolicy(Permission... permissions) {
1342             for (Permission permission : permissions)
1343                 perms.add(permission);
1344         }
1345         void addPermission(Permission perm) { perms.add(perm); }
1346         void clearPermissions() { perms = new Permissions(); }
1347         public PermissionCollection getPermissions(CodeSource cs) {
1348             return perms;
1349         }
1350         public PermissionCollection getPermissions(ProtectionDomain pd) {
1351             return perms;
1352         }
1353         public boolean implies(ProtectionDomain pd, Permission p) {
1354             return perms.implies(p);
1355         }
1356         public void refresh() {}
1357         public String toString() {
1358             List&lt;Permission&gt; ps = new ArrayList&lt;&gt;();
1359             for (Enumeration&lt;Permission&gt; e = perms.elements(); e.hasMoreElements();)
1360                 ps.add(e.nextElement());
1361             return &quot;AdjustablePolicy with permissions &quot; + ps;
1362         }
1363     }
1364 
1365     /**
1366      * Returns a policy containing all the permissions we ever need.
1367      */
1368     public static Policy permissivePolicy() {
1369         return new AdjustablePolicy
1370             // Permissions j.u.c. needs directly
1371             (new RuntimePermission(&quot;modifyThread&quot;),
1372              new RuntimePermission(&quot;getClassLoader&quot;),
1373              new RuntimePermission(&quot;setContextClassLoader&quot;),
1374              // Permissions needed to change permissions!
1375              new SecurityPermission(&quot;getPolicy&quot;),
1376              new SecurityPermission(&quot;setPolicy&quot;),
1377              new RuntimePermission(&quot;setSecurityManager&quot;),
1378              // Permissions needed by the junit test harness
1379              new RuntimePermission(&quot;accessDeclaredMembers&quot;),
1380              new PropertyPermission(&quot;*&quot;, &quot;read&quot;),
1381              new java.io.FilePermission(&quot;&lt;&lt;ALL FILES&gt;&gt;&quot;, &quot;read&quot;));
1382     }
1383 
1384     /**
1385      * Sleeps until the given time has elapsed.
1386      * Throws AssertionError if interrupted.
1387      */
1388     static void sleep(long millis) {
1389         try {
1390             delay(millis);
1391         } catch (InterruptedException fail) {
1392             throw new AssertionError(&quot;Unexpected InterruptedException&quot;, fail);
1393         }
1394     }
1395 
1396     /**
1397      * Spin-waits up to the specified number of milliseconds for the given
1398      * thread to enter a wait state: BLOCKED, WAITING, or TIMED_WAITING.
1399      * @param waitingForGodot if non-null, an additional condition to satisfy
1400      */
1401     void waitForThreadToEnterWaitState(Thread thread, long timeoutMillis,
1402                                        Callable&lt;Boolean&gt; waitingForGodot) {
1403         for (long startTime = 0L;;) {
1404             switch (thread.getState()) {
1405             default: break;
1406             case BLOCKED: case WAITING: case TIMED_WAITING:
1407                 try {
1408                     if (waitingForGodot == null || waitingForGodot.call())
1409                         return;
1410                 } catch (Throwable fail) { threadUnexpectedException(fail); }
1411                 break;
1412             case TERMINATED:
1413                 fail(&quot;Unexpected thread termination&quot;);
1414             }
1415 
1416             if (startTime == 0L)
1417                 startTime = System.nanoTime();
1418             else if (millisElapsedSince(startTime) &gt; timeoutMillis) {
1419                 assertTrue(thread.isAlive());
1420                 if (waitingForGodot == null
1421                     || thread.getState() == Thread.State.RUNNABLE)
1422                     fail(&quot;timed out waiting for thread to enter wait state&quot;);
1423                 else
1424                     fail(&quot;timed out waiting for condition, thread state=&quot;
1425                          + thread.getState());
1426             }
1427             Thread.yield();
1428         }
1429     }
1430 
1431     /**
1432      * Spin-waits up to the specified number of milliseconds for the given
1433      * thread to enter a wait state: BLOCKED, WAITING, or TIMED_WAITING.
1434      */
1435     void waitForThreadToEnterWaitState(Thread thread, long timeoutMillis) {
1436         waitForThreadToEnterWaitState(thread, timeoutMillis, null);
1437     }
1438 
1439     /**
1440      * Spin-waits up to LONG_DELAY_MS milliseconds for the given thread to
1441      * enter a wait state: BLOCKED, WAITING, or TIMED_WAITING.
1442      */
1443     void waitForThreadToEnterWaitState(Thread thread) {
1444         waitForThreadToEnterWaitState(thread, LONG_DELAY_MS, null);
1445     }
1446 
1447     /**
1448      * Spin-waits up to LONG_DELAY_MS milliseconds for the given thread to
1449      * enter a wait state: BLOCKED, WAITING, or TIMED_WAITING,
1450      * and additionally satisfy the given condition.
1451      */
1452     void waitForThreadToEnterWaitState(Thread thread,
1453                                        Callable&lt;Boolean&gt; waitingForGodot) {
1454         waitForThreadToEnterWaitState(thread, LONG_DELAY_MS, waitingForGodot);
1455     }
1456 
<a name="16" id="anc16"></a><span class="line-added">1457     /**</span>
<span class="line-added">1458      * Spin-waits up to LONG_DELAY_MS milliseconds for the current thread to</span>
<span class="line-added">1459      * be interrupted.  Clears the interrupt status before returning.</span>
<span class="line-added">1460      */</span>
<span class="line-added">1461     void awaitInterrupted() {</span>
<span class="line-added">1462         for (long startTime = 0L; !Thread.interrupted(); ) {</span>
<span class="line-added">1463             if (startTime == 0L)</span>
<span class="line-added">1464                 startTime = System.nanoTime();</span>
<span class="line-added">1465             else if (millisElapsedSince(startTime) &gt; LONG_DELAY_MS)</span>
<span class="line-added">1466                 fail(&quot;timed out waiting for thread interrupt&quot;);</span>
<span class="line-added">1467             Thread.yield();</span>
<span class="line-added">1468         }</span>
<span class="line-added">1469     }</span>
<span class="line-added">1470 </span>
1471     /**
1472      * Returns the number of milliseconds since time given by
1473      * startNanoTime, which must have been previously returned from a
1474      * call to {@link System#nanoTime()}.
1475      */
1476     static long millisElapsedSince(long startNanoTime) {
1477         return NANOSECONDS.toMillis(System.nanoTime() - startNanoTime);
1478     }
1479 
<a name="17" id="anc17"></a>












1480     /**
1481      * Checks that timed f.get() returns the expected value, and does not
1482      * wait for the timeout to elapse before returning.
1483      */
1484     &lt;T&gt; void checkTimedGet(Future&lt;T&gt; f, T expectedValue, long timeoutMillis) {
1485         long startTime = System.nanoTime();
1486         T actual = null;
1487         try {
1488             actual = f.get(timeoutMillis, MILLISECONDS);
1489         } catch (Throwable fail) { threadUnexpectedException(fail); }
1490         assertEquals(expectedValue, actual);
1491         if (millisElapsedSince(startTime) &gt; timeoutMillis/2)
1492             throw new AssertionError(&quot;timed get did not return promptly&quot;);
1493     }
1494 
1495     &lt;T&gt; void checkTimedGet(Future&lt;T&gt; f, T expectedValue) {
1496         checkTimedGet(f, expectedValue, LONG_DELAY_MS);
1497     }
1498 
1499     /**
1500      * Returns a new started daemon Thread running the given runnable.
1501      */
1502     Thread newStartedThread(Runnable runnable) {
1503         Thread t = new Thread(runnable);
1504         t.setDaemon(true);
1505         t.start();
1506         return t;
1507     }
1508 
<a name="18" id="anc18"></a><span class="line-added">1509     /**</span>
<span class="line-added">1510      * Returns a new started daemon Thread running the given action,</span>
<span class="line-added">1511      * wrapped in a CheckedRunnable.</span>
<span class="line-added">1512      */</span>
<span class="line-added">1513     Thread newStartedThread(Action action) {</span>
<span class="line-added">1514         return newStartedThread(checkedRunnable(action));</span>
<span class="line-added">1515     }</span>
<span class="line-added">1516 </span>
1517     /**
1518      * Waits for the specified time (in milliseconds) for the thread
1519      * to terminate (using {@link Thread#join(long)}), else interrupts
1520      * the thread (in the hope that it may terminate later) and fails.
1521      */
<a name="19" id="anc19"></a><span class="line-modified">1522     void awaitTermination(Thread thread, long timeoutMillis) {</span>
1523         try {
<a name="20" id="anc20"></a><span class="line-modified">1524             thread.join(timeoutMillis);</span>
1525         } catch (InterruptedException fail) {
1526             threadUnexpectedException(fail);
<a name="21" id="anc21"></a><span class="line-modified">1527         }</span>
<span class="line-modified">1528         if (thread.getState() != Thread.State.TERMINATED) {</span>
<span class="line-modified">1529             String detail = String.format(</span>
<span class="line-modified">1530                     &quot;timed out waiting for thread to terminate, thread=%s, state=%s&quot; ,</span>
<span class="line-added">1531                     thread, thread.getState());</span>
<span class="line-added">1532             try {</span>
<span class="line-added">1533                 threadFail(detail);</span>
<span class="line-added">1534             } finally {</span>
<span class="line-added">1535                 // Interrupt thread __after__ having reported its stack trace</span>
<span class="line-added">1536                 thread.interrupt();</span>
1537             }
1538         }
1539     }
1540 
1541     /**
1542      * Waits for LONG_DELAY_MS milliseconds for the thread to
1543      * terminate (using {@link Thread#join(long)}), else interrupts
1544      * the thread (in the hope that it may terminate later) and fails.
1545      */
1546     void awaitTermination(Thread t) {
1547         awaitTermination(t, LONG_DELAY_MS);
1548     }
1549 
1550     // Some convenient Runnable classes
1551 
1552     public abstract class CheckedRunnable implements Runnable {
1553         protected abstract void realRun() throws Throwable;
1554 
1555         public final void run() {
1556             try {
1557                 realRun();
1558             } catch (Throwable fail) {
1559                 threadUnexpectedException(fail);
1560             }
1561         }
1562     }
1563 
<a name="22" id="anc22"></a><span class="line-added">1564     Runnable checkedRunnable(Action action) {</span>
<span class="line-added">1565         return new CheckedRunnable() {</span>
<span class="line-added">1566             public void realRun() throws Throwable {</span>
<span class="line-added">1567                 action.run();</span>
<span class="line-added">1568             }};</span>
<span class="line-added">1569     }</span>
<span class="line-added">1570 </span>
1571     public abstract class ThreadShouldThrow extends Thread {
1572         protected abstract void realRun() throws Throwable;
1573 
1574         final Class&lt;?&gt; exceptionClass;
1575 
1576         &lt;T extends Throwable&gt; ThreadShouldThrow(Class&lt;T&gt; exceptionClass) {
1577             this.exceptionClass = exceptionClass;
1578         }
1579 
1580         public final void run() {
1581             try {
1582                 realRun();
1583             } catch (Throwable t) {
1584                 if (! exceptionClass.isInstance(t))
1585                     threadUnexpectedException(t);
1586                 return;
1587             }
1588             threadShouldThrow(exceptionClass.getSimpleName());
1589         }
1590     }
1591 
1592     public abstract class CheckedInterruptedRunnable implements Runnable {
1593         protected abstract void realRun() throws Throwable;
1594 
1595         public final void run() {
1596             try {
1597                 realRun();
1598             } catch (InterruptedException success) {
1599                 threadAssertFalse(Thread.interrupted());
1600                 return;
1601             } catch (Throwable fail) {
1602                 threadUnexpectedException(fail);
1603             }
1604             threadShouldThrow(&quot;InterruptedException&quot;);
1605         }
1606     }
1607 
1608     public abstract class CheckedCallable&lt;T&gt; implements Callable&lt;T&gt; {
1609         protected abstract T realCall() throws Throwable;
1610 
1611         public final T call() {
1612             try {
1613                 return realCall();
1614             } catch (Throwable fail) {
1615                 threadUnexpectedException(fail);
1616             }
1617             throw new AssertionError(&quot;unreached&quot;);
1618         }
1619     }
1620 
1621     public static class NoOpRunnable implements Runnable {
1622         public void run() {}
1623     }
1624 
1625     public static class NoOpCallable implements Callable {
1626         public Object call() { return Boolean.TRUE; }
1627     }
1628 
1629     public static final String TEST_STRING = &quot;a test string&quot;;
1630 
1631     public static class StringTask implements Callable&lt;String&gt; {
1632         final String value;
1633         public StringTask() { this(TEST_STRING); }
1634         public StringTask(String value) { this.value = value; }
1635         public String call() { return value; }
1636     }
1637 
1638     public Callable&lt;String&gt; latchAwaitingStringTask(final CountDownLatch latch) {
1639         return new CheckedCallable&lt;String&gt;() {
1640             protected String realCall() {
1641                 try {
1642                     latch.await();
1643                 } catch (InterruptedException quittingTime) {}
1644                 return TEST_STRING;
1645             }};
1646     }
1647 
1648     public Runnable countDowner(final CountDownLatch latch) {
1649         return new CheckedRunnable() {
1650             public void realRun() throws InterruptedException {
1651                 latch.countDown();
1652             }};
1653     }
1654 
1655     class LatchAwaiter extends CheckedRunnable {
1656         static final int NEW = 0;
1657         static final int RUNNING = 1;
1658         static final int DONE = 2;
1659         final CountDownLatch latch;
1660         int state = NEW;
1661         LatchAwaiter(CountDownLatch latch) { this.latch = latch; }
1662         public void realRun() throws InterruptedException {
1663             state = 1;
1664             await(latch);
1665             state = 2;
1666         }
1667     }
1668 
1669     public LatchAwaiter awaiter(CountDownLatch latch) {
1670         return new LatchAwaiter(latch);
1671     }
1672 
1673     public void await(CountDownLatch latch, long timeoutMillis) {
1674         boolean timedOut = false;
1675         try {
1676             timedOut = !latch.await(timeoutMillis, MILLISECONDS);
1677         } catch (Throwable fail) {
1678             threadUnexpectedException(fail);
1679         }
1680         if (timedOut)
1681             fail(&quot;timed out waiting for CountDownLatch for &quot;
1682                  + (timeoutMillis/1000) + &quot; sec&quot;);
1683     }
1684 
1685     public void await(CountDownLatch latch) {
1686         await(latch, LONG_DELAY_MS);
1687     }
1688 
1689     public void await(Semaphore semaphore) {
1690         boolean timedOut = false;
1691         try {
1692             timedOut = !semaphore.tryAcquire(LONG_DELAY_MS, MILLISECONDS);
1693         } catch (Throwable fail) {
1694             threadUnexpectedException(fail);
1695         }
1696         if (timedOut)
1697             fail(&quot;timed out waiting for Semaphore for &quot;
1698                  + (LONG_DELAY_MS/1000) + &quot; sec&quot;);
1699     }
1700 
1701     public void await(CyclicBarrier barrier) {
1702         try {
1703             barrier.await(LONG_DELAY_MS, MILLISECONDS);
1704         } catch (Throwable fail) {
1705             threadUnexpectedException(fail);
1706         }
1707     }
1708 
1709 //     /**
1710 //      * Spin-waits up to LONG_DELAY_MS until flag becomes true.
1711 //      */
1712 //     public void await(AtomicBoolean flag) {
1713 //         await(flag, LONG_DELAY_MS);
1714 //     }
1715 
1716 //     /**
1717 //      * Spin-waits up to the specified timeout until flag becomes true.
1718 //      */
1719 //     public void await(AtomicBoolean flag, long timeoutMillis) {
1720 //         long startTime = System.nanoTime();
1721 //         while (!flag.get()) {
1722 //             if (millisElapsedSince(startTime) &gt; timeoutMillis)
1723 //                 throw new AssertionError(&quot;timed out&quot;);
1724 //             Thread.yield();
1725 //         }
1726 //     }
1727 
1728     public static class NPETask implements Callable&lt;String&gt; {
1729         public String call() { throw new NullPointerException(); }
1730     }
1731 
1732     public Runnable possiblyInterruptedRunnable(final long timeoutMillis) {
1733         return new CheckedRunnable() {
1734             protected void realRun() {
1735                 try {
1736                     delay(timeoutMillis);
1737                 } catch (InterruptedException ok) {}
1738             }};
1739     }
1740 
1741     /**
1742      * For use as ThreadFactory in constructors
1743      */
1744     public static class SimpleThreadFactory implements ThreadFactory {
1745         public Thread newThread(Runnable r) {
1746             return new Thread(r);
1747         }
1748     }
1749 
1750     public interface TrackedRunnable extends Runnable {
1751         boolean isDone();
1752     }
1753 
1754     public static class TrackedNoOpRunnable implements Runnable {
1755         public volatile boolean done = false;
1756         public void run() {
1757             done = true;
1758         }
1759     }
1760 
1761     /**
1762      * Analog of CheckedRunnable for RecursiveAction
1763      */
1764     public abstract class CheckedRecursiveAction extends RecursiveAction {
1765         protected abstract void realCompute() throws Throwable;
1766 
1767         @Override protected final void compute() {
1768             try {
1769                 realCompute();
1770             } catch (Throwable fail) {
1771                 threadUnexpectedException(fail);
1772             }
1773         }
1774     }
1775 
1776     /**
1777      * Analog of CheckedCallable for RecursiveTask
1778      */
1779     public abstract class CheckedRecursiveTask&lt;T&gt; extends RecursiveTask&lt;T&gt; {
1780         protected abstract T realCompute() throws Throwable;
1781 
1782         @Override protected final T compute() {
1783             try {
1784                 return realCompute();
1785             } catch (Throwable fail) {
1786                 threadUnexpectedException(fail);
1787             }
1788             throw new AssertionError(&quot;unreached&quot;);
1789         }
1790     }
1791 
1792     /**
1793      * For use as RejectedExecutionHandler in constructors
1794      */
1795     public static class NoOpREHandler implements RejectedExecutionHandler {
1796         public void rejectedExecution(Runnable r,
1797                                       ThreadPoolExecutor executor) {}
1798     }
1799 
1800     /**
1801      * A CyclicBarrier that uses timed await and fails with
1802      * AssertionErrors instead of throwing checked exceptions.
1803      */
1804     public static class CheckedBarrier extends CyclicBarrier {
1805         public CheckedBarrier(int parties) { super(parties); }
1806 
1807         public int await() {
1808             try {
<a name="23" id="anc23"></a><span class="line-modified">1809                 return super.await(LONGER_DELAY_MS, MILLISECONDS);</span>
1810             } catch (TimeoutException timedOut) {
1811                 throw new AssertionError(&quot;timed out&quot;);
1812             } catch (Exception fail) {
1813                 throw new AssertionError(&quot;Unexpected exception: &quot; + fail, fail);
1814             }
1815         }
1816     }
1817 
1818     void checkEmpty(BlockingQueue q) {
1819         try {
1820             assertTrue(q.isEmpty());
1821             assertEquals(0, q.size());
1822             assertNull(q.peek());
1823             assertNull(q.poll());
1824             assertNull(q.poll(randomExpiredTimeout(), randomTimeUnit()));
1825             assertEquals(q.toString(), &quot;[]&quot;);
1826             assertTrue(Arrays.equals(q.toArray(), new Object[0]));
1827             assertFalse(q.iterator().hasNext());
1828             try {
1829                 q.element();
1830                 shouldThrow();
1831             } catch (NoSuchElementException success) {}
1832             try {
1833                 q.iterator().next();
1834                 shouldThrow();
1835             } catch (NoSuchElementException success) {}
1836             try {
1837                 q.remove();
1838                 shouldThrow();
1839             } catch (NoSuchElementException success) {}
1840         } catch (InterruptedException fail) { threadUnexpectedException(fail); }
1841     }
1842 
1843     void assertSerialEquals(Object x, Object y) {
1844         assertTrue(Arrays.equals(serialBytes(x), serialBytes(y)));
1845     }
1846 
1847     void assertNotSerialEquals(Object x, Object y) {
1848         assertFalse(Arrays.equals(serialBytes(x), serialBytes(y)));
1849     }
1850 
1851     byte[] serialBytes(Object o) {
1852         try {
1853             ByteArrayOutputStream bos = new ByteArrayOutputStream();
1854             ObjectOutputStream oos = new ObjectOutputStream(bos);
1855             oos.writeObject(o);
1856             oos.flush();
1857             oos.close();
1858             return bos.toByteArray();
1859         } catch (Throwable fail) {
1860             threadUnexpectedException(fail);
1861             return new byte[0];
1862         }
1863     }
1864 
<a name="24" id="anc24"></a><span class="line-modified">1865     void assertImmutable(Object o) {</span>
1866         if (o instanceof Collection) {
1867             assertThrows(
1868                 UnsupportedOperationException.class,
<a name="25" id="anc25"></a><span class="line-modified">1869                 () -&gt; ((Collection) o).add(null));</span>

1870         }
1871     }
1872 
1873     @SuppressWarnings(&quot;unchecked&quot;)
1874     &lt;T&gt; T serialClone(T o) {
1875         T clone = null;
1876         try {
1877             ObjectInputStream ois = new ObjectInputStream
1878                 (new ByteArrayInputStream(serialBytes(o)));
1879             clone = (T) ois.readObject();
1880         } catch (Throwable fail) {
1881             threadUnexpectedException(fail);
1882         }
1883         if (o == clone) assertImmutable(o);
1884         else assertSame(o.getClass(), clone.getClass());
1885         return clone;
1886     }
1887 
1888     /**
1889      * A version of serialClone that leaves error handling (for
1890      * e.g. NotSerializableException) up to the caller.
1891      */
1892     @SuppressWarnings(&quot;unchecked&quot;)
1893     &lt;T&gt; T serialClonePossiblyFailing(T o)
1894         throws ReflectiveOperationException, java.io.IOException {
1895         ByteArrayOutputStream bos = new ByteArrayOutputStream();
1896         ObjectOutputStream oos = new ObjectOutputStream(bos);
1897         oos.writeObject(o);
1898         oos.flush();
1899         oos.close();
1900         ObjectInputStream ois = new ObjectInputStream
1901             (new ByteArrayInputStream(bos.toByteArray()));
1902         T clone = (T) ois.readObject();
1903         if (o == clone) assertImmutable(o);
1904         else assertSame(o.getClass(), clone.getClass());
1905         return clone;
1906     }
1907 
1908     /**
1909      * If o implements Cloneable and has a public clone method,
1910      * returns a clone of o, else null.
1911      */
1912     @SuppressWarnings(&quot;unchecked&quot;)
1913     &lt;T&gt; T cloneableClone(T o) {
1914         if (!(o instanceof Cloneable)) return null;
1915         final T clone;
1916         try {
1917             clone = (T) o.getClass().getMethod(&quot;clone&quot;).invoke(o);
1918         } catch (NoSuchMethodException ok) {
1919             return null;
1920         } catch (ReflectiveOperationException unexpected) {
1921             throw new Error(unexpected);
1922         }
1923         assertNotSame(o, clone); // not 100% guaranteed by spec
1924         assertSame(o.getClass(), clone.getClass());
1925         return clone;
1926     }
1927 
1928     public void assertThrows(Class&lt;? extends Throwable&gt; expectedExceptionClass,
<a name="26" id="anc26"></a><span class="line-modified">1929                              Action... throwingActions) {</span>
<span class="line-modified">1930         for (Action throwingAction : throwingActions) {</span>
1931             boolean threw = false;
1932             try { throwingAction.run(); }
1933             catch (Throwable t) {
1934                 threw = true;
1935                 if (!expectedExceptionClass.isInstance(t))
1936                     throw new AssertionError(
1937                             &quot;Expected &quot; + expectedExceptionClass.getName() +
1938                             &quot;, got &quot; + t.getClass().getName(),
1939                             t);
1940             }
1941             if (!threw)
1942                 shouldThrow(expectedExceptionClass.getName());
1943         }
1944     }
1945 
1946     public void assertIteratorExhausted(Iterator&lt;?&gt; it) {
1947         try {
1948             it.next();
1949             shouldThrow();
1950         } catch (NoSuchElementException success) {}
1951         assertFalse(it.hasNext());
1952     }
1953 
1954     public &lt;T&gt; Callable&lt;T&gt; callableThrowing(final Exception ex) {
1955         return new Callable&lt;T&gt;() { public T call() throws Exception { throw ex; }};
1956     }
1957 
1958     public Runnable runnableThrowing(final RuntimeException ex) {
1959         return new Runnable() { public void run() { throw ex; }};
1960     }
1961 
1962     /** A reusable thread pool to be shared by tests. */
1963     static final ExecutorService cachedThreadPool =
1964         new ThreadPoolExecutor(0, Integer.MAX_VALUE,
1965                                1000L, MILLISECONDS,
1966                                new SynchronousQueue&lt;Runnable&gt;());
1967 
1968     static &lt;T&gt; void shuffle(T[] array) {
1969         Collections.shuffle(Arrays.asList(array), ThreadLocalRandom.current());
1970     }
1971 
1972     /**
1973      * Returns the same String as would be returned by {@link
1974      * Object#toString}, whether or not the given object&#39;s class
1975      * overrides toString().
1976      *
1977      * @see System#identityHashCode
1978      */
1979     static String identityString(Object x) {
1980         return x.getClass().getName()
1981             + &quot;@&quot; + Integer.toHexString(System.identityHashCode(x));
1982     }
1983 
1984     // --- Shared assertions for Executor tests ---
1985 
1986     /**
1987      * Returns maximum number of tasks that can be submitted to given
1988      * pool (with bounded queue) before saturation (when submission
1989      * throws RejectedExecutionException).
1990      */
1991     static final int saturatedSize(ThreadPoolExecutor pool) {
1992         BlockingQueue&lt;Runnable&gt; q = pool.getQueue();
1993         return pool.getMaximumPoolSize() + q.size() + q.remainingCapacity();
1994     }
1995 
1996     @SuppressWarnings(&quot;FutureReturnValueIgnored&quot;)
1997     void assertNullTaskSubmissionThrowsNullPointerException(Executor e) {
1998         try {
1999             e.execute((Runnable) null);
2000             shouldThrow();
2001         } catch (NullPointerException success) {}
2002 
2003         if (! (e instanceof ExecutorService)) return;
2004         ExecutorService es = (ExecutorService) e;
2005         try {
2006             es.submit((Runnable) null);
2007             shouldThrow();
2008         } catch (NullPointerException success) {}
2009         try {
2010             es.submit((Runnable) null, Boolean.TRUE);
2011             shouldThrow();
2012         } catch (NullPointerException success) {}
2013         try {
2014             es.submit((Callable) null);
2015             shouldThrow();
2016         } catch (NullPointerException success) {}
2017 
2018         if (! (e instanceof ScheduledExecutorService)) return;
2019         ScheduledExecutorService ses = (ScheduledExecutorService) e;
2020         try {
2021             ses.schedule((Runnable) null,
2022                          randomTimeout(), randomTimeUnit());
2023             shouldThrow();
2024         } catch (NullPointerException success) {}
2025         try {
2026             ses.schedule((Callable) null,
2027                          randomTimeout(), randomTimeUnit());
2028             shouldThrow();
2029         } catch (NullPointerException success) {}
2030         try {
2031             ses.scheduleAtFixedRate((Runnable) null,
2032                                     randomTimeout(), LONG_DELAY_MS, MILLISECONDS);
2033             shouldThrow();
2034         } catch (NullPointerException success) {}
2035         try {
2036             ses.scheduleWithFixedDelay((Runnable) null,
2037                                        randomTimeout(), LONG_DELAY_MS, MILLISECONDS);
2038             shouldThrow();
2039         } catch (NullPointerException success) {}
2040     }
2041 
2042     void setRejectedExecutionHandler(
2043         ThreadPoolExecutor p, RejectedExecutionHandler handler) {
2044         p.setRejectedExecutionHandler(handler);
2045         assertSame(handler, p.getRejectedExecutionHandler());
2046     }
2047 
2048     void assertTaskSubmissionsAreRejected(ThreadPoolExecutor p) {
2049         final RejectedExecutionHandler savedHandler = p.getRejectedExecutionHandler();
2050         final long savedTaskCount = p.getTaskCount();
2051         final long savedCompletedTaskCount = p.getCompletedTaskCount();
2052         final int savedQueueSize = p.getQueue().size();
2053         final boolean stock = (p.getClass().getClassLoader() == null);
2054 
2055         Runnable r = () -&gt; {};
2056         Callable&lt;Boolean&gt; c = () -&gt; Boolean.TRUE;
2057 
2058         class Recorder implements RejectedExecutionHandler {
2059             public volatile Runnable r = null;
2060             public volatile ThreadPoolExecutor p = null;
2061             public void reset() { r = null; p = null; }
2062             public void rejectedExecution(Runnable r, ThreadPoolExecutor p) {
2063                 assertNull(this.r);
2064                 assertNull(this.p);
2065                 this.r = r;
2066                 this.p = p;
2067             }
2068         }
2069 
2070         // check custom handler is invoked exactly once per task
2071         Recorder recorder = new Recorder();
2072         setRejectedExecutionHandler(p, recorder);
2073         for (int i = 2; i--&gt; 0; ) {
2074             recorder.reset();
2075             p.execute(r);
2076             if (stock &amp;&amp; p.getClass() == ThreadPoolExecutor.class)
2077                 assertSame(r, recorder.r);
2078             assertSame(p, recorder.p);
2079 
2080             recorder.reset();
2081             assertFalse(p.submit(r).isDone());
2082             if (stock) assertTrue(!((FutureTask) recorder.r).isDone());
2083             assertSame(p, recorder.p);
2084 
2085             recorder.reset();
2086             assertFalse(p.submit(r, Boolean.TRUE).isDone());
2087             if (stock) assertTrue(!((FutureTask) recorder.r).isDone());
2088             assertSame(p, recorder.p);
2089 
2090             recorder.reset();
2091             assertFalse(p.submit(c).isDone());
2092             if (stock) assertTrue(!((FutureTask) recorder.r).isDone());
2093             assertSame(p, recorder.p);
2094 
2095             if (p instanceof ScheduledExecutorService) {
2096                 ScheduledExecutorService s = (ScheduledExecutorService) p;
2097                 ScheduledFuture&lt;?&gt; future;
2098 
2099                 recorder.reset();
2100                 future = s.schedule(r, randomTimeout(), randomTimeUnit());
2101                 assertFalse(future.isDone());
2102                 if (stock) assertTrue(!((FutureTask) recorder.r).isDone());
2103                 assertSame(p, recorder.p);
2104 
2105                 recorder.reset();
2106                 future = s.schedule(c, randomTimeout(), randomTimeUnit());
2107                 assertFalse(future.isDone());
2108                 if (stock) assertTrue(!((FutureTask) recorder.r).isDone());
2109                 assertSame(p, recorder.p);
2110 
2111                 recorder.reset();
2112                 future = s.scheduleAtFixedRate(r, randomTimeout(), LONG_DELAY_MS, MILLISECONDS);
2113                 assertFalse(future.isDone());
2114                 if (stock) assertTrue(!((FutureTask) recorder.r).isDone());
2115                 assertSame(p, recorder.p);
2116 
2117                 recorder.reset();
2118                 future = s.scheduleWithFixedDelay(r, randomTimeout(), LONG_DELAY_MS, MILLISECONDS);
2119                 assertFalse(future.isDone());
2120                 if (stock) assertTrue(!((FutureTask) recorder.r).isDone());
2121                 assertSame(p, recorder.p);
2122             }
2123         }
2124 
2125         // Checking our custom handler above should be sufficient, but
2126         // we add some integration tests of standard handlers.
2127         final AtomicReference&lt;Thread&gt; thread = new AtomicReference&lt;&gt;();
2128         final Runnable setThread = () -&gt; thread.set(Thread.currentThread());
2129 
2130         setRejectedExecutionHandler(p, new ThreadPoolExecutor.AbortPolicy());
2131         try {
2132             p.execute(setThread);
2133             shouldThrow();
2134         } catch (RejectedExecutionException success) {}
2135         assertNull(thread.get());
2136 
2137         setRejectedExecutionHandler(p, new ThreadPoolExecutor.DiscardPolicy());
2138         p.execute(setThread);
2139         assertNull(thread.get());
2140 
2141         setRejectedExecutionHandler(p, new ThreadPoolExecutor.CallerRunsPolicy());
2142         p.execute(setThread);
2143         if (p.isShutdown())
2144             assertNull(thread.get());
2145         else
2146             assertSame(Thread.currentThread(), thread.get());
2147 
2148         setRejectedExecutionHandler(p, savedHandler);
2149 
2150         // check that pool was not perturbed by handlers
2151         assertEquals(savedTaskCount, p.getTaskCount());
2152         assertEquals(savedCompletedTaskCount, p.getCompletedTaskCount());
2153         assertEquals(savedQueueSize, p.getQueue().size());
2154     }
2155 
2156     void assertCollectionsEquals(Collection&lt;?&gt; x, Collection&lt;?&gt; y) {
2157         assertEquals(x, y);
2158         assertEquals(y, x);
2159         assertEquals(x.isEmpty(), y.isEmpty());
2160         assertEquals(x.size(), y.size());
2161         if (x instanceof List) {
2162             assertEquals(x.toString(), y.toString());
2163         }
2164         if (x instanceof List || x instanceof Set) {
2165             assertEquals(x.hashCode(), y.hashCode());
2166         }
2167         if (x instanceof List || x instanceof Deque) {
2168             assertTrue(Arrays.equals(x.toArray(), y.toArray()));
2169             assertTrue(Arrays.equals(x.toArray(new Object[0]),
2170                                      y.toArray(new Object[0])));
2171         }
2172     }
2173 
2174     /**
2175      * A weaker form of assertCollectionsEquals which does not insist
2176      * that the two collections satisfy Object#equals(Object), since
2177      * they may use identity semantics as Deques do.
2178      */
2179     void assertCollectionsEquivalent(Collection&lt;?&gt; x, Collection&lt;?&gt; y) {
2180         if (x instanceof List || x instanceof Set)
2181             assertCollectionsEquals(x, y);
2182         else {
2183             assertEquals(x.isEmpty(), y.isEmpty());
2184             assertEquals(x.size(), y.size());
2185             assertEquals(new HashSet(x), new HashSet(y));
2186             if (x instanceof Deque) {
2187                 assertTrue(Arrays.equals(x.toArray(), y.toArray()));
2188                 assertTrue(Arrays.equals(x.toArray(new Object[0]),
2189                                          y.toArray(new Object[0])));
2190             }
2191         }
2192     }
2193 }
<a name="27" id="anc27"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="27" type="hidden" />
</body>
</html>
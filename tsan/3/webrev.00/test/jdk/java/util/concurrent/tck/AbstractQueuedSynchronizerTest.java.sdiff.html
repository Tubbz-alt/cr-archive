<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff test/jdk/java/util/concurrent/tck/AbstractQueuedSynchronizerTest.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
<body>
<center><a href="AbstractQueuedLongSynchronizerTest.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="ArrayBlockingQueueTest.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>test/jdk/java/util/concurrent/tck/AbstractQueuedSynchronizerTest.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  23 /*
  24  * This file is available under and governed by the GNU General Public
  25  * License version 2 only, as published by the Free Software Foundation.
  26  * However, the following notice accompanied the original version of this
  27  * file:
  28  *
  29  * Written by Doug Lea with assistance from members of JCP JSR-166
  30  * Expert Group and released to the public domain, as explained at
  31  * http://creativecommons.org/publicdomain/zero/1.0/
  32  * Other contributors include Andrew Wright, Jeffrey Hayes,
  33  * Pat Fisher, Mike Judd.
  34  */
  35 
  36 import static java.util.concurrent.TimeUnit.MILLISECONDS;
  37 import static java.util.concurrent.TimeUnit.NANOSECONDS;
  38 
  39 import java.util.ArrayList;
  40 import java.util.Arrays;
  41 import java.util.Collection;
  42 import java.util.HashSet;
<span class="line-modified">  43 import java.util.concurrent.ThreadLocalRandom;</span>
  44 import java.util.concurrent.locks.AbstractQueuedSynchronizer;
  45 import java.util.concurrent.locks.AbstractQueuedSynchronizer.ConditionObject;
  46 
  47 import junit.framework.Test;
  48 import junit.framework.TestSuite;
  49 
  50 @SuppressWarnings(&quot;WaitNotInLoop&quot;) // we implement spurious-wakeup freedom
  51 public class AbstractQueuedSynchronizerTest extends JSR166TestCase {
  52     public static void main(String[] args) {
  53         main(suite(), args);
  54     }
  55     public static Test suite() {
  56         return new TestSuite(AbstractQueuedSynchronizerTest.class);
  57     }
  58 
  59     /**
  60      * A simple mutex class, adapted from the class javadoc.  Exclusive
  61      * acquire tests exercise this as a sample user extension.  Other
  62      * methods/features of AbstractQueuedSynchronizer are tested via
  63      * other test classes, including those for ReentrantLock,
</pre>
<hr />
<pre>
1320         Thread.sleep(100);
1321         for (Thread thread : threads) thread.interrupt();
1322         for (Thread thread : threads) awaitTermination(thread);
1323 
1324         s.release(1);
1325 
1326         // no one holds lock now, we should be able to acquire
1327         if (!s.tryAcquire(1))
1328             throw new RuntimeException(
1329                 String.format(
1330                     &quot;Broken: hasQueuedPredecessors=%s hasQueuedThreads=%s queueLength=%d firstQueuedThread=%s&quot;,
1331                     s.hasQueuedPredecessors(),
1332                     s.hasQueuedThreads(),
1333                     s.getQueueLength(),
1334                     s.getFirstQueuedThread()));
1335     }
1336 
1337     /**
1338      * Tests scenario for
1339      * JDK-8191937: Lost interrupt in AbstractQueuedSynchronizer when tryAcquire methods throw

1340      */
<span class="line-modified">1341     public void testInterruptedFailingAcquire() throws InterruptedException {</span>
<span class="line-modified">1342         final RuntimeException ex = new RuntimeException();</span>


1343 
1344         // A synchronizer only offering a choice of failure modes
1345         class Sync extends AbstractQueuedSynchronizer {
<span class="line-modified">1346             boolean pleaseThrow;</span>









1347             @Override protected boolean tryAcquire(int ignored) {
<span class="line-modified">1348                 if (pleaseThrow) throw ex;</span>
1349                 return false;
1350             }
1351             @Override protected int tryAcquireShared(int ignored) {
<span class="line-modified">1352                 if (pleaseThrow) throw ex;</span>
1353                 return -1;
1354             }
1355             @Override protected boolean tryRelease(int ignored) {
1356                 return true;
1357             }
1358             @Override protected boolean tryReleaseShared(int ignored) {
1359                 return true;
1360             }
1361         }
1362 
1363         final Sync s = new Sync();
<span class="line-modified">1364 </span>































1365         final Thread thread = newStartedThread(new CheckedRunnable() {
<span class="line-modified">1366             public void realRun() {</span>
1367                 try {
<span class="line-modified">1368                     if (ThreadLocalRandom.current().nextBoolean())</span>
<span class="line-removed">1369                         s.acquire(1);</span>
<span class="line-removed">1370                     else</span>
<span class="line-removed">1371                         s.acquireShared(1);</span>
1372                     shouldThrow();
<span class="line-modified">1373                 } catch (Throwable t) {</span>
<span class="line-modified">1374                     assertSame(ex, t);</span>
<span class="line-modified">1375                     assertTrue(Thread.interrupted());</span>


1376                 }
1377             }});
<span class="line-modified">1378         waitForThreadToEnterWaitState(thread);</span>
<span class="line-modified">1379         assertSame(thread, s.getFirstQueuedThread());</span>
<span class="line-modified">1380         assertTrue(s.hasQueuedPredecessors());</span>
<span class="line-modified">1381         assertTrue(s.hasQueuedThreads());</span>
<span class="line-modified">1382         assertEquals(1, s.getQueueLength());</span>











1383 
1384         s.pleaseThrow = true;
<span class="line-modified">1385         thread.interrupt();</span>
<span class="line-modified">1386         s.release(1);</span>






1387         awaitTermination(thread);










1388     }
1389 
1390 }
</pre>
</td>
<td>
<hr />
<pre>
  23 /*
  24  * This file is available under and governed by the GNU General Public
  25  * License version 2 only, as published by the Free Software Foundation.
  26  * However, the following notice accompanied the original version of this
  27  * file:
  28  *
  29  * Written by Doug Lea with assistance from members of JCP JSR-166
  30  * Expert Group and released to the public domain, as explained at
  31  * http://creativecommons.org/publicdomain/zero/1.0/
  32  * Other contributors include Andrew Wright, Jeffrey Hayes,
  33  * Pat Fisher, Mike Judd.
  34  */
  35 
  36 import static java.util.concurrent.TimeUnit.MILLISECONDS;
  37 import static java.util.concurrent.TimeUnit.NANOSECONDS;
  38 
  39 import java.util.ArrayList;
  40 import java.util.Arrays;
  41 import java.util.Collection;
  42 import java.util.HashSet;
<span class="line-modified">  43 import java.util.concurrent.atomic.AtomicBoolean;</span>
  44 import java.util.concurrent.locks.AbstractQueuedSynchronizer;
  45 import java.util.concurrent.locks.AbstractQueuedSynchronizer.ConditionObject;
  46 
  47 import junit.framework.Test;
  48 import junit.framework.TestSuite;
  49 
  50 @SuppressWarnings(&quot;WaitNotInLoop&quot;) // we implement spurious-wakeup freedom
  51 public class AbstractQueuedSynchronizerTest extends JSR166TestCase {
  52     public static void main(String[] args) {
  53         main(suite(), args);
  54     }
  55     public static Test suite() {
  56         return new TestSuite(AbstractQueuedSynchronizerTest.class);
  57     }
  58 
  59     /**
  60      * A simple mutex class, adapted from the class javadoc.  Exclusive
  61      * acquire tests exercise this as a sample user extension.  Other
  62      * methods/features of AbstractQueuedSynchronizer are tested via
  63      * other test classes, including those for ReentrantLock,
</pre>
<hr />
<pre>
1320         Thread.sleep(100);
1321         for (Thread thread : threads) thread.interrupt();
1322         for (Thread thread : threads) awaitTermination(thread);
1323 
1324         s.release(1);
1325 
1326         // no one holds lock now, we should be able to acquire
1327         if (!s.tryAcquire(1))
1328             throw new RuntimeException(
1329                 String.format(
1330                     &quot;Broken: hasQueuedPredecessors=%s hasQueuedThreads=%s queueLength=%d firstQueuedThread=%s&quot;,
1331                     s.hasQueuedPredecessors(),
1332                     s.hasQueuedThreads(),
1333                     s.getQueueLength(),
1334                     s.getFirstQueuedThread()));
1335     }
1336 
1337     /**
1338      * Tests scenario for
1339      * JDK-8191937: Lost interrupt in AbstractQueuedSynchronizer when tryAcquire methods throw
<span class="line-added">1340      * ant -Djsr166.tckTestClass=AbstractQueuedSynchronizerTest -Djsr166.methodFilter=testInterruptedFailingAcquire -Djsr166.runsPerTest=10000 tck</span>
1341      */
<span class="line-modified">1342     public void testInterruptedFailingAcquire() throws Throwable {</span>
<span class="line-modified">1343         class PleaseThrow extends RuntimeException {}</span>
<span class="line-added">1344         final PleaseThrow ex = new PleaseThrow();</span>
<span class="line-added">1345         final AtomicBoolean thrown = new AtomicBoolean();</span>
1346 
1347         // A synchronizer only offering a choice of failure modes
1348         class Sync extends AbstractQueuedSynchronizer {
<span class="line-modified">1349             volatile boolean pleaseThrow;</span>
<span class="line-added">1350             void maybeThrow() {</span>
<span class="line-added">1351                 if (pleaseThrow) {</span>
<span class="line-added">1352                     // assert: tryAcquire methods can throw at most once</span>
<span class="line-added">1353                     if (! thrown.compareAndSet(false, true))</span>
<span class="line-added">1354                         throw new AssertionError();</span>
<span class="line-added">1355                     throw ex;</span>
<span class="line-added">1356                 }</span>
<span class="line-added">1357             }</span>
<span class="line-added">1358 </span>
1359             @Override protected boolean tryAcquire(int ignored) {
<span class="line-modified">1360                 maybeThrow();</span>
1361                 return false;
1362             }
1363             @Override protected int tryAcquireShared(int ignored) {
<span class="line-modified">1364                 maybeThrow();</span>
1365                 return -1;
1366             }
1367             @Override protected boolean tryRelease(int ignored) {
1368                 return true;
1369             }
1370             @Override protected boolean tryReleaseShared(int ignored) {
1371                 return true;
1372             }
1373         }
1374 
1375         final Sync s = new Sync();
<span class="line-modified">1376         final boolean acquireInterruptibly = randomBoolean();</span>
<span class="line-added">1377         final Action[] uninterruptibleAcquireActions = {</span>
<span class="line-added">1378             () -&gt; s.acquire(1),</span>
<span class="line-added">1379             () -&gt; s.acquireShared(1),</span>
<span class="line-added">1380         };</span>
<span class="line-added">1381         final long nanosTimeout = MILLISECONDS.toNanos(2 * LONG_DELAY_MS);</span>
<span class="line-added">1382         final Action[] interruptibleAcquireActions = {</span>
<span class="line-added">1383             () -&gt; s.acquireInterruptibly(1),</span>
<span class="line-added">1384             () -&gt; s.acquireSharedInterruptibly(1),</span>
<span class="line-added">1385             () -&gt; s.tryAcquireNanos(1, nanosTimeout),</span>
<span class="line-added">1386             () -&gt; s.tryAcquireSharedNanos(1, nanosTimeout),</span>
<span class="line-added">1387         };</span>
<span class="line-added">1388         final Action[] releaseActions = {</span>
<span class="line-added">1389             () -&gt; s.release(1),</span>
<span class="line-added">1390             () -&gt; s.releaseShared(1),</span>
<span class="line-added">1391         };</span>
<span class="line-added">1392         final Action acquireAction = acquireInterruptibly</span>
<span class="line-added">1393             ? chooseRandomly(interruptibleAcquireActions)</span>
<span class="line-added">1394             : chooseRandomly(uninterruptibleAcquireActions);</span>
<span class="line-added">1395         final Action releaseAction</span>
<span class="line-added">1396             = chooseRandomly(releaseActions);</span>
<span class="line-added">1397 </span>
<span class="line-added">1398         // From os_posix.cpp:</span>
<span class="line-added">1399         //</span>
<span class="line-added">1400         // NOTE that since there is no &quot;lock&quot; around the interrupt and</span>
<span class="line-added">1401         // is_interrupted operations, there is the possibility that the</span>
<span class="line-added">1402         // interrupted flag (in osThread) will be &quot;false&quot; but that the</span>
<span class="line-added">1403         // low-level events will be in the signaled state. This is</span>
<span class="line-added">1404         // intentional. The effect of this is that Object.wait() and</span>
<span class="line-added">1405         // LockSupport.park() will appear to have a spurious wakeup, which</span>
<span class="line-added">1406         // is allowed and not harmful, and the possibility is so rare that</span>
<span class="line-added">1407         // it is not worth the added complexity to add yet another lock.</span>
1408         final Thread thread = newStartedThread(new CheckedRunnable() {
<span class="line-modified">1409             public void realRun() throws Throwable {</span>
1410                 try {
<span class="line-modified">1411                     acquireAction.run();</span>



1412                     shouldThrow();
<span class="line-modified">1413                 } catch (InterruptedException possible) {</span>
<span class="line-modified">1414                     assertTrue(acquireInterruptibly);</span>
<span class="line-modified">1415                     assertFalse(Thread.interrupted());</span>
<span class="line-added">1416                 } catch (PleaseThrow possible) {</span>
<span class="line-added">1417                     awaitInterrupted();</span>
1418                 }
1419             }});
<span class="line-modified">1420         for (long startTime = 0L;; ) {</span>
<span class="line-modified">1421             waitForThreadToEnterWaitState(thread);</span>
<span class="line-modified">1422             if (s.getFirstQueuedThread() == thread</span>
<span class="line-modified">1423                 &amp;&amp; s.hasQueuedPredecessors()</span>
<span class="line-modified">1424                 &amp;&amp; s.hasQueuedThreads()</span>
<span class="line-added">1425                 &amp;&amp; s.getQueueLength() == 1</span>
<span class="line-added">1426                 &amp;&amp; s.hasContended())</span>
<span class="line-added">1427                 break;</span>
<span class="line-added">1428             if (startTime == 0L)</span>
<span class="line-added">1429                 startTime = System.nanoTime();</span>
<span class="line-added">1430             else if (millisElapsedSince(startTime) &gt; LONG_DELAY_MS)</span>
<span class="line-added">1431                 fail(&quot;timed out waiting for AQS state: &quot;</span>
<span class="line-added">1432                      + &quot;thread state=&quot; + thread.getState()</span>
<span class="line-added">1433                      + &quot;, queued threads=&quot; + s.getQueuedThreads());</span>
<span class="line-added">1434             Thread.yield();</span>
<span class="line-added">1435         }</span>
1436 
1437         s.pleaseThrow = true;
<span class="line-modified">1438         // release and interrupt, in random order</span>
<span class="line-modified">1439         if (randomBoolean()) {</span>
<span class="line-added">1440             thread.interrupt();</span>
<span class="line-added">1441             releaseAction.run();</span>
<span class="line-added">1442         } else {</span>
<span class="line-added">1443             releaseAction.run();</span>
<span class="line-added">1444             thread.interrupt();</span>
<span class="line-added">1445         }</span>
1446         awaitTermination(thread);
<span class="line-added">1447 </span>
<span class="line-added">1448         if (! acquireInterruptibly)</span>
<span class="line-added">1449             assertTrue(thrown.get());</span>
<span class="line-added">1450 </span>
<span class="line-added">1451         assertNull(s.getFirstQueuedThread());</span>
<span class="line-added">1452         assertFalse(s.hasQueuedPredecessors());</span>
<span class="line-added">1453         assertFalse(s.hasQueuedThreads());</span>
<span class="line-added">1454         assertEquals(0, s.getQueueLength());</span>
<span class="line-added">1455         assertTrue(s.getQueuedThreads().isEmpty());</span>
<span class="line-added">1456         assertTrue(s.hasContended());</span>
1457     }
1458 
1459 }
</pre>
</td>
</tr>
</table>
<center><a href="AbstractQueuedLongSynchronizerTest.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="ArrayBlockingQueueTest.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
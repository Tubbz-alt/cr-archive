<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff test/jdk/java/util/concurrent/tck/JSR166TestCase.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
<body>
<center><a href="HashMapTest.java.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="LinkedBlockingDequeTest.java.cdiff.html" target="_top">next &gt;</a></center>    <h2>test/jdk/java/util/concurrent/tck/JSR166TestCase.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 74,10 ***</span>
<span class="line-new-header">--- 74,11 ---</span>
  import java.io.ByteArrayInputStream;
  import java.io.ByteArrayOutputStream;
  import java.io.ObjectInputStream;
  import java.io.ObjectOutputStream;
  import java.lang.management.ManagementFactory;
<span class="line-added">+ import java.lang.management.LockInfo;</span>
  import java.lang.management.ThreadInfo;
  import java.lang.management.ThreadMXBean;
  import java.lang.reflect.Constructor;
  import java.lang.reflect.Method;
  import java.lang.reflect.Modifier;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 268,10 ***</span>
<span class="line-new-header">--- 269,13 ---</span>
                  String.format(&quot;Bad float value in system property %s=%s&quot;,
                                name, floatString));
          }
      }
  
<span class="line-added">+     private static final ThreadMXBean THREAD_MXBEAN</span>
<span class="line-added">+         = ManagementFactory.getThreadMXBean();</span>
<span class="line-added">+ </span>
      /**
       * The scaling factor to apply to standard delays used in tests.
       * May be initialized from any of:
       * - the &quot;jsr166.delay.factor&quot; system property
       * - the &quot;test.timeout.factor&quot; system property (as used by jtreg)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 309,16 ***</span>
  
      // Instrumentation to debug very rare, but very annoying hung test runs.
      static volatile TestCase currentTestCase;
      // static volatile int currentRun = 0;
      static {
<span class="line-modified">!         Runnable checkForWedgedTest = new Runnable() { public void run() {</span>
              // Avoid spurious reports with enormous runsPerTest.
              // A single test case run should never take more than 1 second.
              // But let&#39;s cap it at the high end too ...
<span class="line-modified">!             final int timeoutMinutes =</span>
<span class="line-modified">!                 Math.min(15, Math.max(runsPerTest / 60, 1));</span>
              for (TestCase lastTestCase = currentTestCase;;) {
                  try { MINUTES.sleep(timeoutMinutes); }
                  catch (InterruptedException unexpected) { break; }
                  if (lastTestCase == currentTestCase) {
                      System.err.printf(
<span class="line-new-header">--- 313,17 ---</span>
  
      // Instrumentation to debug very rare, but very annoying hung test runs.
      static volatile TestCase currentTestCase;
      // static volatile int currentRun = 0;
      static {
<span class="line-modified">!         Runnable wedgedTestDetector = new Runnable() { public void run() {</span>
              // Avoid spurious reports with enormous runsPerTest.
              // A single test case run should never take more than 1 second.
              // But let&#39;s cap it at the high end too ...
<span class="line-modified">!             final int timeoutMinutesMin = Math.max(runsPerTest / 60, 1)</span>
<span class="line-modified">!                 * Math.max((int) delayFactor, 1);</span>
<span class="line-added">+             final int timeoutMinutes = Math.min(15, timeoutMinutesMin);</span>
              for (TestCase lastTestCase = currentTestCase;;) {
                  try { MINUTES.sleep(timeoutMinutes); }
                  catch (InterruptedException unexpected) { break; }
                  if (lastTestCase == currentTestCase) {
                      System.err.printf(
</pre>
<hr />
<pre>
<span class="line-old-header">*** 334,11 ***</span>
                      // one stack dump is probably enough; more would be spam
                      break;
                  }
                  lastTestCase = currentTestCase;
              }}};
<span class="line-modified">!         Thread thread = new Thread(checkForWedgedTest, &quot;checkForWedgedTest&quot;);</span>
          thread.setDaemon(true);
          thread.start();
      }
  
  //     public static String cpuModel() {
<span class="line-new-header">--- 339,11 ---</span>
                      // one stack dump is probably enough; more would be spam
                      break;
                  }
                  lastTestCase = currentTestCase;
              }}};
<span class="line-modified">!         Thread thread = new Thread(wedgedTestDetector, &quot;WedgedTestDetector&quot;);</span>
          thread.setDaemon(true);
          thread.start();
      }
  
  //     public static String cpuModel() {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 378,11 ***</span>
              if (elapsedMillis &lt; profileThreshold)
                  break;
              // Never report first run of any test; treat it as a
              // warmup run, notably to trigger all needed classloading,
              if (i &gt; 0)
<span class="line-modified">!                 System.out.printf(&quot;%n%s: %d%n&quot;, toString(), elapsedMillis);</span>
          }
      }
  
      /**
       * Runs all JSR166 unit tests using junit.textui.TestRunner.
<span class="line-new-header">--- 383,11 ---</span>
              if (elapsedMillis &lt; profileThreshold)
                  break;
              // Never report first run of any test; treat it as a
              // warmup run, notably to trigger all needed classloading,
              if (i &gt; 0)
<span class="line-modified">!                 System.out.printf(&quot;%s: %d%n&quot;, toString(), elapsedMillis);</span>
          }
      }
  
      /**
       * Runs all JSR166 unit tests using junit.textui.TestRunner.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 542,10 ***</span>
<span class="line-new-header">--- 547,11 ---</span>
              EntryTest.suite(),
              ExchangerTest.suite(),
              ExecutorsTest.suite(),
              ExecutorCompletionServiceTest.suite(),
              FutureTaskTest.suite(),
<span class="line-added">+             HashtableTest.suite(),</span>
              LinkedBlockingDequeTest.suite(),
              LinkedBlockingQueueTest.suite(),
              LinkedListTest.suite(),
              LockSupportTest.suite(),
              PriorityBlockingQueueTest.suite(),
</pre>
<hr />
<pre>
<span class="line-old-header">*** 680,10 ***</span>
<span class="line-new-header">--- 686,16 ---</span>
      public static long SHORT_DELAY_MS;
      public static long SMALL_DELAY_MS;
      public static long MEDIUM_DELAY_MS;
      public static long LONG_DELAY_MS;
  
<span class="line-added">+     /**</span>
<span class="line-added">+      * A delay significantly longer than LONG_DELAY_MS.</span>
<span class="line-added">+      * Use this in a thread that is waited for via awaitTermination(Thread).</span>
<span class="line-added">+      */</span>
<span class="line-added">+     public static long LONGER_DELAY_MS;</span>
<span class="line-added">+ </span>
      private static final long RANDOM_TIMEOUT;
      private static final long RANDOM_EXPIRED_TIMEOUT;
      private static final TimeUnit RANDOM_TIMEUNIT;
      static {
          ThreadLocalRandom rnd = ThreadLocalRandom.current();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 707,10 ***</span>
<span class="line-new-header">--- 719,31 ---</span>
      /**
       * Returns a random non-null TimeUnit.
       */
      static TimeUnit randomTimeUnit() { return RANDOM_TIMEUNIT; }
  
<span class="line-added">+     /**</span>
<span class="line-added">+      * Returns a random boolean; a &quot;coin flip&quot;.</span>
<span class="line-added">+      */</span>
<span class="line-added">+     static boolean randomBoolean() {</span>
<span class="line-added">+         return ThreadLocalRandom.current().nextBoolean();</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     /**</span>
<span class="line-added">+      * Returns a random element from given choices.</span>
<span class="line-added">+      */</span>
<span class="line-added">+     &lt;T&gt; T chooseRandomly(List&lt;T&gt; choices) {</span>
<span class="line-added">+         return choices.get(ThreadLocalRandom.current().nextInt(choices.size()));</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     /**</span>
<span class="line-added">+      * Returns a random element from given choices.</span>
<span class="line-added">+      */</span>
<span class="line-added">+     &lt;T&gt; T chooseRandomly(T... choices) {</span>
<span class="line-added">+         return choices[ThreadLocalRandom.current().nextInt(choices.length)];</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
      /**
       * Returns the shortest timed delay. This can be scaled up for
       * slow machines using the jsr166.delay.factor system property,
       * or via jtreg&#39;s -timeoutFactor: flag.
       * http://openjdk.java.net/jtreg/command-help.html
</pre>
<hr />
<pre>
<span class="line-old-header">*** 725,10 ***</span>
<span class="line-new-header">--- 758,11 ---</span>
      protected void setDelays() {
          SHORT_DELAY_MS = getShortDelay();
          SMALL_DELAY_MS  = SHORT_DELAY_MS * 5;
          MEDIUM_DELAY_MS = SHORT_DELAY_MS * 10;
          LONG_DELAY_MS   = SHORT_DELAY_MS * 200;
<span class="line-added">+         LONGER_DELAY_MS = 2 * LONG_DELAY_MS;</span>
      }
  
      private static final long TIMEOUT_DELAY_MS
          = (long) (12.0 * Math.cbrt(delayFactor));
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 763,12 ***</span>
       * failure is recorded; subsequent calls to this method from within
       * the same test have no effect.
       */
      public void threadRecordFailure(Throwable t) {
          System.err.println(t);
<span class="line-modified">!         dumpTestThreads();</span>
<span class="line-modified">!         threadFailure.compareAndSet(null, t);</span>
      }
  
      public void setUp() {
          setDelays();
      }
<span class="line-new-header">--- 797,12 ---</span>
       * failure is recorded; subsequent calls to this method from within
       * the same test have no effect.
       */
      public void threadRecordFailure(Throwable t) {
          System.err.println(t);
<span class="line-modified">!         if (threadFailure.compareAndSet(null, t))</span>
<span class="line-modified">!             dumpTestThreads();</span>
      }
  
      public void setUp() {
          setDelays();
      }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1085,10 ***</span>
<span class="line-new-header">--- 1119,43 ---</span>
                      threadUnexpectedException(ex);
                  }
          }
      }
  
<span class="line-added">+     /** Returns true if thread info might be useful in a thread dump. */</span>
<span class="line-added">+     static boolean threadOfInterest(ThreadInfo info) {</span>
<span class="line-added">+         final String name = info.getThreadName();</span>
<span class="line-added">+         String lockName;</span>
<span class="line-added">+         if (name == null)</span>
<span class="line-added">+             return true;</span>
<span class="line-added">+         if (name.equals(&quot;Signal Dispatcher&quot;)</span>
<span class="line-added">+             || name.equals(&quot;WedgedTestDetector&quot;))</span>
<span class="line-added">+             return false;</span>
<span class="line-added">+         if (name.equals(&quot;Reference Handler&quot;)) {</span>
<span class="line-added">+             // Reference Handler stacktrace changed in JDK-8156500</span>
<span class="line-added">+             StackTraceElement[] stackTrace; String methodName;</span>
<span class="line-added">+             if ((stackTrace = info.getStackTrace()) != null</span>
<span class="line-added">+                 &amp;&amp; stackTrace.length &gt; 0</span>
<span class="line-added">+                 &amp;&amp; (methodName = stackTrace[0].getMethodName()) != null</span>
<span class="line-added">+                 &amp;&amp; methodName.equals(&quot;waitForReferencePendingList&quot;))</span>
<span class="line-added">+                 return false;</span>
<span class="line-added">+             // jdk8 Reference Handler stacktrace</span>
<span class="line-added">+             if ((lockName = info.getLockName()) != null</span>
<span class="line-added">+                 &amp;&amp; lockName.startsWith(&quot;java.lang.ref&quot;))</span>
<span class="line-added">+                 return false;</span>
<span class="line-added">+         }</span>
<span class="line-added">+         if ((name.equals(&quot;Finalizer&quot;) || name.equals(&quot;Common-Cleaner&quot;))</span>
<span class="line-added">+             &amp;&amp; (lockName = info.getLockName()) != null</span>
<span class="line-added">+             &amp;&amp; lockName.startsWith(&quot;java.lang.ref&quot;))</span>
<span class="line-added">+             return false;</span>
<span class="line-added">+         if (name.startsWith(&quot;ForkJoinPool.commonPool-worker&quot;)</span>
<span class="line-added">+             &amp;&amp; (lockName = info.getLockName()) != null</span>
<span class="line-added">+             &amp;&amp; lockName.startsWith(&quot;java.util.concurrent.ForkJoinPool&quot;))</span>
<span class="line-added">+             return false;</span>
<span class="line-added">+         return true;</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
      /**
       * A debugging tool to print stack traces of most threads, as jstack does.
       * Uninteresting threads are filtered out.
       */
      static void dumpTestThreads() {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1099,29 ***</span>
              } catch (SecurityException giveUp) {
                  return;
              }
          }
  
<span class="line-removed">-         ThreadMXBean threadMXBean = ManagementFactory.getThreadMXBean();</span>
          System.err.println(&quot;------ stacktrace dump start ------&quot;);
<span class="line-modified">!         for (ThreadInfo info : threadMXBean.dumpAllThreads(true, true)) {</span>
<span class="line-modified">!             final String name = info.getThreadName();</span>
<span class="line-modified">!             String lockName;</span>
<span class="line-removed">-             if (&quot;Signal Dispatcher&quot;.equals(name))</span>
<span class="line-removed">-                 continue;</span>
<span class="line-removed">-             if (&quot;Reference Handler&quot;.equals(name)</span>
<span class="line-removed">-                 &amp;&amp; (lockName = info.getLockName()) != null</span>
<span class="line-removed">-                 &amp;&amp; lockName.startsWith(&quot;java.lang.ref.Reference$Lock&quot;))</span>
<span class="line-removed">-                 continue;</span>
<span class="line-removed">-             if (&quot;Finalizer&quot;.equals(name)</span>
<span class="line-removed">-                 &amp;&amp; (lockName = info.getLockName()) != null</span>
<span class="line-removed">-                 &amp;&amp; lockName.startsWith(&quot;java.lang.ref.ReferenceQueue$Lock&quot;))</span>
<span class="line-removed">-                 continue;</span>
<span class="line-removed">-             if (&quot;checkForWedgedTest&quot;.equals(name))</span>
<span class="line-removed">-                 continue;</span>
<span class="line-removed">-             System.err.print(info);</span>
<span class="line-removed">-         }</span>
          System.err.println(&quot;------ stacktrace dump end ------&quot;);
  
          if (sm != null) System.setSecurityManager(sm);
      }
  
<span class="line-new-header">--- 1166,14 ---</span>
              } catch (SecurityException giveUp) {
                  return;
              }
          }
  
          System.err.println(&quot;------ stacktrace dump start ------&quot;);
<span class="line-modified">!         for (ThreadInfo info : THREAD_MXBEAN.dumpAllThreads(true, true))</span>
<span class="line-modified">!             if (threadOfInterest(info))</span>
<span class="line-modified">!                 System.err.print(info);</span>
          System.err.println(&quot;------ stacktrace dump end ------&quot;);
  
          if (sm != null) System.setSecurityManager(sm);
      }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1143,10 ***</span>
<span class="line-new-header">--- 1195,21 ---</span>
                  fail(&quot;Unexpected thread termination&quot;);
          }
          fail(&quot;timed out waiting for thread to enter thread state &quot; + expected);
      }
  
<span class="line-added">+     /**</span>
<span class="line-added">+      * Returns the thread&#39;s blocker&#39;s class name, if any, else null.</span>
<span class="line-added">+      */</span>
<span class="line-added">+     String blockerClassName(Thread thread) {</span>
<span class="line-added">+         ThreadInfo threadInfo; LockInfo lockInfo;</span>
<span class="line-added">+         if ((threadInfo = THREAD_MXBEAN.getThreadInfo(thread.getId(), 0)) != null</span>
<span class="line-added">+             &amp;&amp; (lockInfo = threadInfo.getLockInfo()) != null)</span>
<span class="line-added">+             return lockInfo.getClassName();</span>
<span class="line-added">+         return null;</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
      /**
       * Checks that future.get times out, with the default timeout of
       * {@code timeoutMillis()}.
       */
      void assertFutureTimesOut(Future future) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1389,32 ***</span>
      void waitForThreadToEnterWaitState(Thread thread,
                                         Callable&lt;Boolean&gt; waitingForGodot) {
          waitForThreadToEnterWaitState(thread, LONG_DELAY_MS, waitingForGodot);
      }
  
      /**
       * Returns the number of milliseconds since time given by
       * startNanoTime, which must have been previously returned from a
       * call to {@link System#nanoTime()}.
       */
      static long millisElapsedSince(long startNanoTime) {
          return NANOSECONDS.toMillis(System.nanoTime() - startNanoTime);
      }
  
<span class="line-removed">- //     void assertTerminatesPromptly(long timeoutMillis, Runnable r) {</span>
<span class="line-removed">- //         long startTime = System.nanoTime();</span>
<span class="line-removed">- //         try {</span>
<span class="line-removed">- //             r.run();</span>
<span class="line-removed">- //         } catch (Throwable fail) { threadUnexpectedException(fail); }</span>
<span class="line-removed">- //         if (millisElapsedSince(startTime) &gt; timeoutMillis/2)</span>
<span class="line-removed">- //             throw new AssertionError(&quot;did not return promptly&quot;);</span>
<span class="line-removed">- //     }</span>
<span class="line-removed">- </span>
<span class="line-removed">- //     void assertTerminatesPromptly(Runnable r) {</span>
<span class="line-removed">- //         assertTerminatesPromptly(LONG_DELAY_MS/2, r);</span>
<span class="line-removed">- //     }</span>
<span class="line-removed">- </span>
      /**
       * Checks that timed f.get() returns the expected value, and does not
       * wait for the timeout to elapse before returning.
       */
      &lt;T&gt; void checkTimedGet(Future&lt;T&gt; f, T expectedValue, long timeoutMillis) {
<span class="line-new-header">--- 1452,33 ---</span>
      void waitForThreadToEnterWaitState(Thread thread,
                                         Callable&lt;Boolean&gt; waitingForGodot) {
          waitForThreadToEnterWaitState(thread, LONG_DELAY_MS, waitingForGodot);
      }
  
<span class="line-added">+     /**</span>
<span class="line-added">+      * Spin-waits up to LONG_DELAY_MS milliseconds for the current thread to</span>
<span class="line-added">+      * be interrupted.  Clears the interrupt status before returning.</span>
<span class="line-added">+      */</span>
<span class="line-added">+     void awaitInterrupted() {</span>
<span class="line-added">+         for (long startTime = 0L; !Thread.interrupted(); ) {</span>
<span class="line-added">+             if (startTime == 0L)</span>
<span class="line-added">+                 startTime = System.nanoTime();</span>
<span class="line-added">+             else if (millisElapsedSince(startTime) &gt; LONG_DELAY_MS)</span>
<span class="line-added">+                 fail(&quot;timed out waiting for thread interrupt&quot;);</span>
<span class="line-added">+             Thread.yield();</span>
<span class="line-added">+         }</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
      /**
       * Returns the number of milliseconds since time given by
       * startNanoTime, which must have been previously returned from a
       * call to {@link System#nanoTime()}.
       */
      static long millisElapsedSince(long startNanoTime) {
          return NANOSECONDS.toMillis(System.nanoTime() - startNanoTime);
      }
  
      /**
       * Checks that timed f.get() returns the expected value, and does not
       * wait for the timeout to elapse before returning.
       */
      &lt;T&gt; void checkTimedGet(Future&lt;T&gt; f, T expectedValue, long timeoutMillis) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1440,24 ***</span>
          t.setDaemon(true);
          t.start();
          return t;
      }
  
      /**
       * Waits for the specified time (in milliseconds) for the thread
       * to terminate (using {@link Thread#join(long)}), else interrupts
       * the thread (in the hope that it may terminate later) and fails.
       */
<span class="line-modified">!     void awaitTermination(Thread t, long timeoutMillis) {</span>
          try {
<span class="line-modified">!             t.join(timeoutMillis);</span>
          } catch (InterruptedException fail) {
              threadUnexpectedException(fail);
<span class="line-modified">!         } finally {</span>
<span class="line-modified">!             if (t.getState() != Thread.State.TERMINATED) {</span>
<span class="line-modified">!                 t.interrupt();</span>
<span class="line-modified">!                 threadFail(&quot;timed out waiting for thread to terminate&quot;);</span>
              }
          }
      }
  
      /**
<span class="line-new-header">--- 1504,38 ---</span>
          t.setDaemon(true);
          t.start();
          return t;
      }
  
<span class="line-added">+     /**</span>
<span class="line-added">+      * Returns a new started daemon Thread running the given action,</span>
<span class="line-added">+      * wrapped in a CheckedRunnable.</span>
<span class="line-added">+      */</span>
<span class="line-added">+     Thread newStartedThread(Action action) {</span>
<span class="line-added">+         return newStartedThread(checkedRunnable(action));</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
      /**
       * Waits for the specified time (in milliseconds) for the thread
       * to terminate (using {@link Thread#join(long)}), else interrupts
       * the thread (in the hope that it may terminate later) and fails.
       */
<span class="line-modified">!     void awaitTermination(Thread thread, long timeoutMillis) {</span>
          try {
<span class="line-modified">!             thread.join(timeoutMillis);</span>
          } catch (InterruptedException fail) {
              threadUnexpectedException(fail);
<span class="line-modified">!         }</span>
<span class="line-modified">!         if (thread.getState() != Thread.State.TERMINATED) {</span>
<span class="line-modified">!             String detail = String.format(</span>
<span class="line-modified">!                     &quot;timed out waiting for thread to terminate, thread=%s, state=%s&quot; ,</span>
<span class="line-added">+                     thread, thread.getState());</span>
<span class="line-added">+             try {</span>
<span class="line-added">+                 threadFail(detail);</span>
<span class="line-added">+             } finally {</span>
<span class="line-added">+                 // Interrupt thread __after__ having reported its stack trace</span>
<span class="line-added">+                 thread.interrupt();</span>
              }
          }
      }
  
      /**
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1481,10 ***</span>
<span class="line-new-header">--- 1559,17 ---</span>
                  threadUnexpectedException(fail);
              }
          }
      }
  
<span class="line-added">+     Runnable checkedRunnable(Action action) {</span>
<span class="line-added">+         return new CheckedRunnable() {</span>
<span class="line-added">+             public void realRun() throws Throwable {</span>
<span class="line-added">+                 action.run();</span>
<span class="line-added">+             }};</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
      public abstract class ThreadShouldThrow extends Thread {
          protected abstract void realRun() throws Throwable;
  
          final Class&lt;?&gt; exceptionClass;
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1719,11 ***</span>
      public static class CheckedBarrier extends CyclicBarrier {
          public CheckedBarrier(int parties) { super(parties); }
  
          public int await() {
              try {
<span class="line-modified">!                 return super.await(2 * LONG_DELAY_MS, MILLISECONDS);</span>
              } catch (TimeoutException timedOut) {
                  throw new AssertionError(&quot;timed out&quot;);
              } catch (Exception fail) {
                  throw new AssertionError(&quot;Unexpected exception: &quot; + fail, fail);
              }
<span class="line-new-header">--- 1804,11 ---</span>
      public static class CheckedBarrier extends CyclicBarrier {
          public CheckedBarrier(int parties) { super(parties); }
  
          public int await() {
              try {
<span class="line-modified">!                 return super.await(LONGER_DELAY_MS, MILLISECONDS);</span>
              } catch (TimeoutException timedOut) {
                  throw new AssertionError(&quot;timed out&quot;);
              } catch (Exception fail) {
                  throw new AssertionError(&quot;Unexpected exception: &quot; + fail, fail);
              }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1775,16 ***</span>
              threadUnexpectedException(fail);
              return new byte[0];
          }
      }
  
<span class="line-modified">!     void assertImmutable(final Object o) {</span>
          if (o instanceof Collection) {
              assertThrows(
                  UnsupportedOperationException.class,
<span class="line-modified">!                 new Runnable() { public void run() {</span>
<span class="line-removed">-                         ((Collection) o).add(null);}});</span>
          }
      }
  
      @SuppressWarnings(&quot;unchecked&quot;)
      &lt;T&gt; T serialClone(T o) {
<span class="line-new-header">--- 1860,15 ---</span>
              threadUnexpectedException(fail);
              return new byte[0];
          }
      }
  
<span class="line-modified">!     void assertImmutable(Object o) {</span>
          if (o instanceof Collection) {
              assertThrows(
                  UnsupportedOperationException.class,
<span class="line-modified">!                 () -&gt; ((Collection) o).add(null));</span>
          }
      }
  
      @SuppressWarnings(&quot;unchecked&quot;)
      &lt;T&gt; T serialClone(T o) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1840,12 ***</span>
          assertSame(o.getClass(), clone.getClass());
          return clone;
      }
  
      public void assertThrows(Class&lt;? extends Throwable&gt; expectedExceptionClass,
<span class="line-modified">!                              Runnable... throwingActions) {</span>
<span class="line-modified">!         for (Runnable throwingAction : throwingActions) {</span>
              boolean threw = false;
              try { throwingAction.run(); }
              catch (Throwable t) {
                  threw = true;
                  if (!expectedExceptionClass.isInstance(t))
<span class="line-new-header">--- 1924,12 ---</span>
          assertSame(o.getClass(), clone.getClass());
          return clone;
      }
  
      public void assertThrows(Class&lt;? extends Throwable&gt; expectedExceptionClass,
<span class="line-modified">!                              Action... throwingActions) {</span>
<span class="line-modified">!         for (Action throwingAction : throwingActions) {</span>
              boolean threw = false;
              try { throwingAction.run(); }
              catch (Throwable t) {
                  threw = true;
                  if (!expectedExceptionClass.isInstance(t))
</pre>
<center><a href="HashMapTest.java.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="LinkedBlockingDequeTest.java.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
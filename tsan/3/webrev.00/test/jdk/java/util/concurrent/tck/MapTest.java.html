<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New test/jdk/java/util/concurrent/tck/MapTest.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  3  *
  4  * This code is free software; you can redistribute it and/or modify it
  5  * under the terms of the GNU General Public License version 2 only, as
  6  * published by the Free Software Foundation.
  7  *
  8  * This code is distributed in the hope that it will be useful, but WITHOUT
  9  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 10  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 11  * version 2 for more details (a copy is included in the LICENSE file that
 12  * accompanied this code).
 13  *
 14  * You should have received a copy of the GNU General Public License version
 15  * 2 along with this work; if not, write to the Free Software Foundation,
 16  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 17  *
 18  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 19  * or visit www.oracle.com if you need additional information or have any
 20  * questions.
 21  */
 22 
 23 /*
 24  * This file is available under and governed by the GNU General Public
 25  * License version 2 only, as published by the Free Software Foundation.
 26  * However, the following notice accompanied the original version of this
 27  * file:
 28  *
 29  * Written by Doug Lea and Martin Buchholz with assistance from
 30  * members of JCP JSR-166 Expert Group and released to the public
 31  * domain, as explained at
 32  * http://creativecommons.org/publicdomain/zero/1.0/
 33  */
 34 
 35 import java.util.ArrayList;
 36 import java.util.Iterator;
 37 import java.util.List;
 38 import java.util.Map;
 39 import java.util.concurrent.CompletableFuture;
 40 import java.util.concurrent.ThreadLocalRandom;
 41 import java.util.concurrent.atomic.AtomicBoolean;
 42 import java.util.concurrent.atomic.AtomicLong;
 43 import java.util.function.BiFunction;
 44 
 45 import junit.framework.Test;
 46 
 47 /**
 48  * Contains tests applicable to all Map implementations.
 49  */
 50 public class MapTest extends JSR166TestCase {
 51     final MapImplementation impl;
 52 
 53     /** Tests are parameterized by a Map implementation. */
 54     MapTest(MapImplementation impl, String methodName) {
 55         super(methodName);
 56         this.impl = impl;
 57     }
 58 
 59     public static Test testSuite(MapImplementation impl) {
 60         return newTestSuite(
 61             parameterizedTestSuite(MapTest.class,
 62                                    MapImplementation.class,
 63                                    impl));
 64     }
 65 
 66     public void testImplSanity() {
 67         final ThreadLocalRandom rnd = ThreadLocalRandom.current();
 68         {
 69             Map m = impl.emptyMap();
 70             assertTrue(m.isEmpty());
 71             assertEquals(0, m.size());
 72             Object k = impl.makeKey(rnd.nextInt());
 73             Object v = impl.makeValue(rnd.nextInt());
 74             m.put(k, v);
 75             assertFalse(m.isEmpty());
 76             assertEquals(1, m.size());
 77             assertTrue(m.containsKey(k));
 78             assertTrue(m.containsValue(v));
 79         }
 80         {
 81             Map m = impl.emptyMap();
 82             Object v = impl.makeValue(rnd.nextInt());
 83             if (impl.permitsNullKeys()) {
 84                 m.put(null, v);
 85                 assertTrue(m.containsKey(null));
 86                 assertTrue(m.containsValue(v));
 87             } else {
 88                 assertThrows(NullPointerException.class, () -&gt; m.put(null, v));
 89             }
 90         }
 91         {
 92             Map m = impl.emptyMap();
 93             Object k = impl.makeKey(rnd.nextInt());
 94             if (impl.permitsNullValues()) {
 95                 m.put(k, null);
 96                 assertTrue(m.containsKey(k));
 97                 assertTrue(m.containsValue(null));
 98             } else {
 99                 assertThrows(NullPointerException.class, () -&gt; m.put(k, null));
100             }
101         }
102         {
103             Map m = impl.emptyMap();
104             Object k = impl.makeKey(rnd.nextInt());
105             Object v1 = impl.makeValue(rnd.nextInt());
106             Object v2 = impl.makeValue(rnd.nextInt());
107             m.put(k, v1);
108             if (impl.supportsSetValue()) {
109                 ((Map.Entry)(m.entrySet().iterator().next())).setValue(v2);
110                 assertSame(v2, m.get(k));
111                 assertTrue(m.containsKey(k));
112                 assertTrue(m.containsValue(v2));
113                 assertFalse(m.containsValue(v1));
114             } else {
115                 assertThrows(UnsupportedOperationException.class,
116                              () -&gt; ((Map.Entry)(m.entrySet().iterator().next())).setValue(v2));
117             }
118         }
119     }
120 
121     /**
122      * Tests and extends the scenario reported in
123      * https://bugs.openjdk.java.net/browse/JDK-8186171
124      * HashMap: Entry.setValue may not work after Iterator.remove() called for previous entries
125      * ant -Djsr166.tckTestClass=HashMapTest -Djsr166.methodFilter=testBug8186171 -Djsr166.runsPerTest=1000 tck
126      */
127     public void testBug8186171() {
128         if (!impl.supportsSetValue()) return;
129         if (!atLeastJava10()) return; // jdk9 is no longer maintained
130         final ThreadLocalRandom rnd = ThreadLocalRandom.current();
131         final boolean permitsNullValues = impl.permitsNullValues();
132         final Object v1 = (permitsNullValues &amp;&amp; rnd.nextBoolean())
133             ? null : impl.makeValue(1);
134         final Object v2 = (permitsNullValues &amp;&amp; rnd.nextBoolean() &amp;&amp; v1 != null)
135             ? null : impl.makeValue(2);
136 
137         // If true, always lands in first bucket in hash tables.
138         final boolean poorHash = rnd.nextBoolean();
139         class Key implements Comparable&lt;Key&gt; {
140             final int i;
141             Key(int i) { this.i = i; }
142             public int hashCode() { return poorHash ? 0 : super.hashCode(); }
143             public int compareTo(Key x) {
144                 return Integer.compare(this.i, x.i);
145             }
146         }
147 
148         // Both HashMap and ConcurrentHashMap have:
149         // TREEIFY_THRESHOLD = 8; UNTREEIFY_THRESHOLD = 6;
150         final int size = rnd.nextInt(1, 25);
151 
152         List&lt;Key&gt; keys = new ArrayList&lt;&gt;();
153         for (int i = size; i--&gt;0; ) keys.add(new Key(i));
154         Key keyToFrob = keys.get(rnd.nextInt(keys.size()));
155 
156         Map&lt;Key, Object&gt; m = impl.emptyMap();
157         for (Key key : keys) m.put(key, v1);
158 
159         for (Iterator&lt;Map.Entry&lt;Key, Object&gt;&gt; it = m.entrySet().iterator();
160              it.hasNext(); ) {
161             Map.Entry&lt;Key, Object&gt; entry = it.next();
162             if (entry.getKey() == keyToFrob)
163                 entry.setValue(v2); // does this have the expected effect?
164             else
165                 it.remove();
166         }
167 
168         assertFalse(m.containsValue(v1));
169         assertTrue(m.containsValue(v2));
170         assertTrue(m.containsKey(keyToFrob));
171         assertEquals(1, m.size());
172     }
173 
174     /**
175      * &quot;Missing&quot; test found while investigating JDK-8210280.
176      * ant -Djsr166.tckTestClass=HashMapTest -Djsr166.methodFilter=testBug8210280 -Djsr166.runsPerTest=1000000 tck
177      */
178     public void testBug8210280() {
179         final ThreadLocalRandom rnd = ThreadLocalRandom.current();
180         final int size1 = rnd.nextInt(32);
181         final int size2 = rnd.nextInt(128);
182 
183         final Map m1 = impl.emptyMap();
184         for (int i = 0; i &lt; size1; i++) {
185             int elt = rnd.nextInt(1024 * i, 1024 * (i + 1));
186             assertNull(m1.put(impl.makeKey(elt), impl.makeValue(elt)));
187         }
188 
189         final Map m2 = impl.emptyMap();
190         for (int i = 0; i &lt; size2; i++) {
191             int elt = rnd.nextInt(Integer.MIN_VALUE + 1024 * i,
192                                   Integer.MIN_VALUE + 1024 * (i + 1));
193             assertNull(m2.put(impl.makeKey(elt), impl.makeValue(-elt)));
194         }
195 
196         final Map m1Copy = impl.emptyMap();
197         m1Copy.putAll(m1);
198 
199         m1.putAll(m2);
200 
201         for (Object elt : m2.keySet())
202             assertEquals(m2.get(elt), m1.get(elt));
203         for (Object elt : m1Copy.keySet())
204             assertSame(m1Copy.get(elt), m1.get(elt));
205         assertEquals(size1 + size2, m1.size());
206     }
207 
208     /**
209      * 8222930: ConcurrentSkipListMap.clone() shares size variable between original and clone
210      */
211     public void testClone() {
212         final ThreadLocalRandom rnd = ThreadLocalRandom.current();
213         final int size = rnd.nextInt(4);
214         final Map map = impl.emptyMap();
215         for (int i = 0; i &lt; size; i++)
216             map.put(impl.makeKey(i), impl.makeValue(i));
217         final Map clone = cloneableClone(map);
218         if (clone == null) return;      // not cloneable?
219 
220         assertEquals(size, map.size());
221         assertEquals(size, clone.size());
222         assertEquals(map.isEmpty(), clone.isEmpty());
223 
224         clone.put(impl.makeKey(-1), impl.makeValue(-1));
225         assertEquals(size, map.size());
226         assertEquals(size + 1, clone.size());
227 
228         clone.clear();
229         assertEquals(size, map.size());
230         assertEquals(0, clone.size());
231         assertTrue(clone.isEmpty());
232     }
233 
234     /**
235      * Concurrent access by compute methods behaves as expected
236      */
237     public void testConcurrentAccess() throws Throwable {
238         final Map map = impl.emptyMap();
239         final long testDurationMillis = expensiveTests ? 1000 : 2;
240         final int nTasks = impl.isConcurrent()
241             ? ThreadLocalRandom.current().nextInt(1, 10)
242             : 1;
243         final AtomicBoolean done = new AtomicBoolean(false);
244         final boolean remappingFunctionCalledAtMostOnce
245             = impl.remappingFunctionCalledAtMostOnce();
246         final List&lt;CompletableFuture&gt; futures = new ArrayList&lt;&gt;();
247         final AtomicLong expectedSum = new AtomicLong(0);
248         final Action[] tasks = {
249             // repeatedly increment values using compute()
250             () -&gt; {
251                 long[] invocations = new long[2];
252                 ThreadLocalRandom rnd = ThreadLocalRandom.current();
253                 BiFunction&lt;Object, Object, Object&gt; incValue = (k, v) -&gt; {
254                     invocations[1]++;
255                     int vi = (v == null) ? 1 : impl.valueToInt(v) + 1;
256                     return impl.makeValue(vi);
257                 };
258                 while (!done.getAcquire()) {
259                     invocations[0]++;
260                     Object key = impl.makeKey(3 * rnd.nextInt(10));
261                     map.compute(key, incValue);
262                 }
263                 if (remappingFunctionCalledAtMostOnce)
264                     assertEquals(invocations[0], invocations[1]);
265                 expectedSum.getAndAdd(invocations[0]);
266             },
267             // repeatedly increment values using computeIfPresent()
268             () -&gt; {
269                 long[] invocations = new long[2];
270                 ThreadLocalRandom rnd = ThreadLocalRandom.current();
271                 BiFunction&lt;Object, Object, Object&gt; incValue = (k, v) -&gt; {
272                     invocations[1]++;
273                     int vi = impl.valueToInt(v) + 1;
274                     return impl.makeValue(vi);
275                 };
276                 while (!done.getAcquire()) {
277                     Object key = impl.makeKey(3 * rnd.nextInt(10));
278                     if (map.computeIfPresent(key, incValue) != null)
279                         invocations[0]++;
280                 }
281                 if (remappingFunctionCalledAtMostOnce)
282                     assertEquals(invocations[0], invocations[1]);
283                 expectedSum.getAndAdd(invocations[0]);
284             },
285         };
286         for (int i = nTasks; i--&gt; 0; ) {
287             Action task = chooseRandomly(tasks);
288             futures.add(CompletableFuture.runAsync(checkedRunnable(task)));
289         }
290         Thread.sleep(testDurationMillis);
291         done.setRelease(true);
292         for (var future : futures)
293             checkTimedGet(future, null);
294 
295         long sum = map.values().stream().mapToLong(x -&gt; (int) x).sum();
296         assertEquals(expectedSum.get(), sum);
297     }
298 
299 //     public void testFailsIntentionallyForDebugging() {
300 //         fail(impl.klazz().getSimpleName());
301 //     }
302 }
    </pre>
  </body>
</html>
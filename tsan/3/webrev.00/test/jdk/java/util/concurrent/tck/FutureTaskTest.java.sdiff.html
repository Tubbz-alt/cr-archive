<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff test/jdk/java/util/concurrent/tck/FutureTaskTest.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
<body>
<center><a href="ForkJoinTaskTest.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="HashMapTest.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>test/jdk/java/util/concurrent/tck/FutureTaskTest.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
730         final ArithmeticException e = new ArithmeticException();
731         final PublicFutureTask task = new PublicFutureTask(new Callable() {
732             public Object call() {
733                 throw e;
734             }});
735 
736         task.run();
737         try {
738             task.get(LONG_DELAY_MS, MILLISECONDS);
739             shouldThrow();
740         } catch (ExecutionException success) {
741             assertSame(e, success.getCause());
742             tryToConfuseDoneTask(task);
743             checkCompletedAbnormally(task, success.getCause());
744         }
745     }
746 
747     /**
748      * get is interruptible
749      */
<span class="line-modified">750     public void testGet_interruptible() {</span>
751         final CountDownLatch pleaseInterrupt = new CountDownLatch(1);
752         final FutureTask task = new FutureTask(new NoOpCallable());
753         Thread t = newStartedThread(new CheckedRunnable() {
754             public void realRun() throws Exception {
755                 Thread.currentThread().interrupt();
756                 try {
757                     task.get();
758                     shouldThrow();
759                 } catch (InterruptedException success) {}
760                 assertFalse(Thread.interrupted());
761 
762                 pleaseInterrupt.countDown();
763                 try {
764                     task.get();
765                     shouldThrow();
766                 } catch (InterruptedException success) {}
767                 assertFalse(Thread.interrupted());
768             }});
769 
770         await(pleaseInterrupt);
771         t.interrupt();
772         awaitTermination(t);
773         checkNotDone(task);
774     }
775 
776     /**
777      * timed get is interruptible
778      */
<span class="line-modified">779     public void testTimedGet_interruptible() {</span>
780         final CountDownLatch pleaseInterrupt = new CountDownLatch(1);
781         final FutureTask task = new FutureTask(new NoOpCallable());
782         Thread t = newStartedThread(new CheckedRunnable() {
783             public void realRun() throws Exception {
784                 Thread.currentThread().interrupt();
785                 try {
<span class="line-modified">786                     task.get(2*LONG_DELAY_MS, MILLISECONDS);</span>
787                     shouldThrow();
788                 } catch (InterruptedException success) {}
789                 assertFalse(Thread.interrupted());
790 
791                 pleaseInterrupt.countDown();
792                 try {
<span class="line-modified">793                     task.get(2*LONG_DELAY_MS, MILLISECONDS);</span>
794                     shouldThrow();
795                 } catch (InterruptedException success) {}
796                 assertFalse(Thread.interrupted());
797             }});
798 
799         await(pleaseInterrupt);

800         t.interrupt();
801         awaitTermination(t);
802         checkNotDone(task);
803     }
804 
805     /**
806      * A timed out timed get throws TimeoutException
807      */
808     public void testGet_TimeoutException() throws Exception {
809         FutureTask task = new FutureTask(new NoOpCallable());
810         long startTime = System.nanoTime();
811         try {
812             task.get(timeoutMillis(), MILLISECONDS);
813             shouldThrow();
814         } catch (TimeoutException success) {
815             assertTrue(millisElapsedSince(startTime) &gt;= timeoutMillis());
816         }
817     }
818 
819     /**
</pre>
</td>
<td>
<hr />
<pre>
730         final ArithmeticException e = new ArithmeticException();
731         final PublicFutureTask task = new PublicFutureTask(new Callable() {
732             public Object call() {
733                 throw e;
734             }});
735 
736         task.run();
737         try {
738             task.get(LONG_DELAY_MS, MILLISECONDS);
739             shouldThrow();
740         } catch (ExecutionException success) {
741             assertSame(e, success.getCause());
742             tryToConfuseDoneTask(task);
743             checkCompletedAbnormally(task, success.getCause());
744         }
745     }
746 
747     /**
748      * get is interruptible
749      */
<span class="line-modified">750     public void testGet_Interruptible() {</span>
751         final CountDownLatch pleaseInterrupt = new CountDownLatch(1);
752         final FutureTask task = new FutureTask(new NoOpCallable());
753         Thread t = newStartedThread(new CheckedRunnable() {
754             public void realRun() throws Exception {
755                 Thread.currentThread().interrupt();
756                 try {
757                     task.get();
758                     shouldThrow();
759                 } catch (InterruptedException success) {}
760                 assertFalse(Thread.interrupted());
761 
762                 pleaseInterrupt.countDown();
763                 try {
764                     task.get();
765                     shouldThrow();
766                 } catch (InterruptedException success) {}
767                 assertFalse(Thread.interrupted());
768             }});
769 
770         await(pleaseInterrupt);
771         t.interrupt();
772         awaitTermination(t);
773         checkNotDone(task);
774     }
775 
776     /**
777      * timed get is interruptible
778      */
<span class="line-modified">779     public void testTimedGet_Interruptible() {</span>
780         final CountDownLatch pleaseInterrupt = new CountDownLatch(1);
781         final FutureTask task = new FutureTask(new NoOpCallable());
782         Thread t = newStartedThread(new CheckedRunnable() {
783             public void realRun() throws Exception {
784                 Thread.currentThread().interrupt();
785                 try {
<span class="line-modified">786                     task.get(randomTimeout(), randomTimeUnit());</span>
787                     shouldThrow();
788                 } catch (InterruptedException success) {}
789                 assertFalse(Thread.interrupted());
790 
791                 pleaseInterrupt.countDown();
792                 try {
<span class="line-modified">793                     task.get(LONGER_DELAY_MS, MILLISECONDS);</span>
794                     shouldThrow();
795                 } catch (InterruptedException success) {}
796                 assertFalse(Thread.interrupted());
797             }});
798 
799         await(pleaseInterrupt);
<span class="line-added">800         if (randomBoolean()) assertThreadBlocks(t, Thread.State.TIMED_WAITING);</span>
801         t.interrupt();
802         awaitTermination(t);
803         checkNotDone(task);
804     }
805 
806     /**
807      * A timed out timed get throws TimeoutException
808      */
809     public void testGet_TimeoutException() throws Exception {
810         FutureTask task = new FutureTask(new NoOpCallable());
811         long startTime = System.nanoTime();
812         try {
813             task.get(timeoutMillis(), MILLISECONDS);
814             shouldThrow();
815         } catch (TimeoutException success) {
816             assertTrue(millisElapsedSince(startTime) &gt;= timeoutMillis());
817         }
818     }
819 
820     /**
</pre>
</td>
</tr>
</table>
<center><a href="ForkJoinTaskTest.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="HashMapTest.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames test/jdk/java/util/concurrent/CyclicBarrier/Basic.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (c) 2005, 2018, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 /*
 25  * @test
 26  * @bug 6253848 6366811
 27  * @summary Basic tests for CyclicBarrier
 28  * @library /test/lib
 29  * @author Martin Buchholz, David Holmes
 30  */
 31 
 32 import static java.util.concurrent.TimeUnit.MILLISECONDS;
 33 
 34 import java.util.ArrayList;
 35 import java.util.Iterator;
 36 import java.util.List;
 37 import java.util.concurrent.BrokenBarrierException;
 38 import java.util.concurrent.CountDownLatch;
 39 import java.util.concurrent.CyclicBarrier;
<a name="1" id="anc1"></a><span class="line-added"> 40 import java.util.concurrent.ThreadLocalRandom;</span>
 41 import java.util.concurrent.TimeoutException;
 42 import java.util.concurrent.atomic.AtomicInteger;
 43 import jdk.test.lib.Utils;
 44 
 45 public class Basic {
 46     static final long LONG_DELAY_MS = Utils.adjustTimeout(10_000);
 47 
 48     private static void checkBroken(final CyclicBarrier barrier) {
 49         check(barrier.isBroken());
 50         equal(barrier.getNumberWaiting(), 0);
 51 
 52         THROWS(BrokenBarrierException.class,
 53                () -&gt; barrier.await(),
 54                () -&gt; barrier.await(100, MILLISECONDS));
 55     }
 56 
 57     private static void reset(CyclicBarrier barrier) {
 58         barrier.reset();
 59         check(! barrier.isBroken());
 60         equal(barrier.getNumberWaiting(), 0);
 61     }
 62 
 63     private static void checkResult(Awaiter a, Class&lt;? extends Throwable&gt; c) {
 64         Throwable t = a.result();
 65         if (! ((t == null &amp;&amp; c == null) || (c != null &amp;&amp; c.isInstance(t)))) {
 66             //      t.printStackTrace();
 67             fail(&quot;Mismatch in thread &quot; +
 68                  a.getName() + &quot;: &quot; +
 69                  t + &quot;, &quot; +
 70                  (c == null ? &quot;&lt;null&gt;&quot; : c.getName()));
 71         } else {
 72             pass();
 73         }
 74     }
 75 
 76     //----------------------------------------------------------------
 77     // Mechanism to get all victim threads into &quot;running&quot; mode.
 78     // The fact that this also uses CyclicBarrier is entirely coincidental.
 79     //----------------------------------------------------------------
 80     private static final CyclicBarrier atTheStartingGate = new CyclicBarrier(3);
 81 
 82     private static void toTheStartingGate() {
 83         try { atTheStartingGate.await(LONG_DELAY_MS, MILLISECONDS); pass(); }
 84         catch (Throwable t) {
 85             unexpected(t);
 86             reset(atTheStartingGate);
 87             throw new Error(t);
 88         }
 89     }
 90 
 91     //----------------------------------------------------------------
 92     // Convenience methods for creating threads that call CyclicBarrier.await
 93     //----------------------------------------------------------------
 94     private abstract static class Awaiter extends Thread {
 95         static AtomicInteger count = new AtomicInteger(1);
 96 
 97         {
 98             this.setName(&quot;Awaiter:&quot;+count.getAndIncrement());
 99             this.setDaemon(true);
100         }
101 
102         private volatile Throwable result = null;
103         protected void result(Throwable result) { this.result = result; }
104         public Throwable result() { return this.result; }
105     }
106 
107     private static Awaiter awaiter(final CyclicBarrier barrier) {
108         return new Awaiter() { public void run() {
109             toTheStartingGate();
110 
111             try { barrier.await(); }
112             catch (Throwable result) { result(result); }}};
113     }
114 
115     private static Awaiter awaiter(final CyclicBarrier barrier,
116                                    final long millis) {
117         return new Awaiter() { public void run() {
118             toTheStartingGate();
119 
120             try { barrier.await(millis, MILLISECONDS); }
121             catch (Throwable result) { result(result); }}};
122     }
123 
124     // Returns an infinite lazy list of all possible awaiter pair combinations.
125     private static Iterator&lt;Awaiter&gt; awaiterIterator(final CyclicBarrier barrier) {
126         return new Iterator&lt;Awaiter&gt;() {
127             int i = 0;
128             public boolean hasNext() { return true; }
129             public Awaiter next() {
130                 switch ((i++)&amp;7) {
131                 case 0: case 2: case 4: case 5:
132                     return awaiter(barrier);
133                 default:
134                     return awaiter(barrier, 10 * 1000); }}
135             public void remove() {throw new UnsupportedOperationException();}};
136     }
137 
138     private static void realMain(String[] args) throws Throwable {
139 
140         Thread.currentThread().setName(&quot;mainThread&quot;);
141 
142         //----------------------------------------------------------------
143         // Normal use
144         //----------------------------------------------------------------
145         try {
146             CyclicBarrier barrier = new CyclicBarrier(3);
147             equal(barrier.getParties(), 3);
148             Iterator&lt;Awaiter&gt; awaiters = awaiterIterator(barrier);
149             for (boolean doReset : new boolean[] {false, true})
150                 for (int i = 0; i &lt; 4; i++) {
151                     Awaiter a1 = awaiters.next(); a1.start();
152                     Awaiter a2 = awaiters.next(); a2.start();
153                     toTheStartingGate();
154                     barrier.await();
155                     a1.join();
156                     a2.join();
157                     checkResult(a1, null);
158                     checkResult(a2, null);
159                     check(! barrier.isBroken());
160                     equal(barrier.getParties(), 3);
161                     equal(barrier.getNumberWaiting(), 0);
162                     if (doReset) reset(barrier);
163                 }
164         } catch (Throwable t) { unexpected(t); }
165 
166         //----------------------------------------------------------------
167         // One thread interrupted
168         //----------------------------------------------------------------
169         try {
170             CyclicBarrier barrier = new CyclicBarrier(3);
171             Iterator&lt;Awaiter&gt; awaiters = awaiterIterator(barrier);
172             for (int i = 0; i &lt; 4; i++) {
173                 Awaiter a1 = awaiters.next(); a1.start();
174                 Awaiter a2 = awaiters.next(); a2.start();
175                 toTheStartingGate();
176                 a1.interrupt();
177                 a1.join();
178                 a2.join();
179                 checkResult(a1, InterruptedException.class);
180                 checkResult(a2, BrokenBarrierException.class);
181                 checkBroken(barrier);
182                 reset(barrier);
183             }
184         } catch (Throwable t) { unexpected(t); }
185 
186         //----------------------------------------------------------------
187         // Barrier is reset while threads are waiting
188         //----------------------------------------------------------------
189         try {
190             CyclicBarrier barrier = new CyclicBarrier(3);
191             Iterator&lt;Awaiter&gt; awaiters = awaiterIterator(barrier);
192             for (int i = 0; i &lt; 4; i++) {
193                 Awaiter a1 = awaiters.next(); a1.start();
194                 Awaiter a2 = awaiters.next(); a2.start();
195                 toTheStartingGate();
196                 while (barrier.getNumberWaiting() &lt; 2) Thread.yield();
197                 barrier.reset();
198                 a1.join();
199                 a2.join();
200                 checkResult(a1, BrokenBarrierException.class);
201                 checkResult(a2, BrokenBarrierException.class);
202                 check(! barrier.isBroken());
203                 equal(barrier.getParties(), 3);
204                 equal(barrier.getNumberWaiting(), 0);
205             }
206         } catch (Throwable t) { unexpected(t); }
207 
208         //----------------------------------------------------------------
209         // One thread timed out
210         //----------------------------------------------------------------
211         try {
212             CyclicBarrier barrier = new CyclicBarrier(3);
213             Iterator&lt;Awaiter&gt; awaiters = awaiterIterator(barrier);
214             for (long timeout : new long[] { 0L, 10L }) {
215                 for (int i = 0; i &lt; 2; i++) {
216                     Awaiter a1 = awaiter(barrier, timeout); a1.start();
217                     Awaiter a2 = awaiters.next();           a2.start();
218                     toTheStartingGate();
219                     a1.join();
220                     a2.join();
221                     checkResult(a1, TimeoutException.class);
222                     checkResult(a2, BrokenBarrierException.class);
223                     checkBroken(barrier);
224                     equal(barrier.getParties(), 3);
225                     reset(barrier);
226                 }
227             }
228         } catch (Throwable t) { unexpected(t); }
229 
230         //----------------------------------------------------------------
231         // Barrier action completed normally
232         //----------------------------------------------------------------
233         try {
234             final AtomicInteger count = new AtomicInteger(0);
235             final CyclicBarrier[] kludge = new CyclicBarrier[1];
236             Runnable action = new Runnable() { public void run() {
237                 count.incrementAndGet();
238                 equal(kludge[0].getNumberWaiting(),
239                       kludge[0].getParties());
240                 System.out.println(&quot;OK!&quot;); }};
241             CyclicBarrier barrier = new CyclicBarrier(3, action);
242             kludge[0] = barrier;
243             equal(barrier.getParties(), 3);
244             Iterator&lt;Awaiter&gt; awaiters = awaiterIterator(barrier);
245             for (int i = 0; i &lt; 4; i++) {
246                 Awaiter a1 = awaiters.next(); a1.start();
247                 Awaiter a2 = awaiters.next(); a2.start();
248                 toTheStartingGate();
249                 while (barrier.getNumberWaiting() &lt; 2) Thread.yield();
250                 try { barrier.await(); }
251                 catch (Throwable t) { unexpected(t); }
252                 a1.join();
253                 a2.join();
254                 checkResult(a1, null);
255                 checkResult(a2, null);
256                 check(! barrier.isBroken());
257                 equal(barrier.getNumberWaiting(), 0);
258                 reset(barrier);
259                 equal(count.get(), i+1);
260             }
261         } catch (Throwable t) { unexpected(t); }
262 
263         //----------------------------------------------------------------
264         // Barrier action threw exception
265         //----------------------------------------------------------------
266         try {
267             Runnable action = new Runnable() {
268                     public void run() { throw new Error(); }};
269             CyclicBarrier barrier = new CyclicBarrier(3, action);
270             Iterator&lt;Awaiter&gt; awaiters = awaiterIterator(barrier);
271             for (int i = 0; i &lt; 4; i++) {
272                 Awaiter a1 = awaiters.next(); a1.start();
273                 Awaiter a2 = awaiters.next(); a2.start();
274                 toTheStartingGate();
275                 while (barrier.getNumberWaiting() &lt; 2) Thread.yield();
276                 try {
277                     barrier.await();
278                     fail(&quot;Expected Error not thrown&quot;); }
279                 catch (Error e) { pass(); }
280                 catch (Throwable t) { unexpected(t); }
281                 a1.join();
282                 a2.join();
283                 checkResult(a1, BrokenBarrierException.class);
284                 checkResult(a2, BrokenBarrierException.class);
285                 checkBroken(barrier);
286                 reset(barrier);
287             }
288         } catch (Throwable t) { unexpected(t); }
289 
290         testInterrupts();
291     }
292 
293     /**
294      * Handling of extra interrupts while waiting - tests for bug 6366811
295      */
296     private static void testInterrupts() {
<a name="2" id="anc2"></a><span class="line-modified">297         final int N = ThreadLocalRandom.current().nextInt(2, 10);</span>
298         final CyclicBarrier startingGate = new CyclicBarrier(N+1);
299 
300         /**
301          * A version of Awaiter that also records interrupted state.
302          */
303         class Waiter extends CheckedThread {
<a name="3" id="anc3"></a><span class="line-modified">304             private final boolean timed;</span>
<span class="line-modified">305             private final CyclicBarrier barrier;</span>
<span class="line-modified">306             private final CountDownLatch doneSignal;</span>
<span class="line-modified">307             volatile Throwable throwable;</span>
<span class="line-modified">308             volatile boolean interruptStatusSetAfterAwait;</span>
<span class="line-modified">309 </span>
<span class="line-modified">310             public Waiter(CountDownLatch doneSignal, CyclicBarrier barrier) {</span>
<span class="line-modified">311                 this.timed = ThreadLocalRandom.current().nextBoolean();</span>


312                 this.doneSignal = doneSignal;
313                 this.barrier = barrier;
314             }
<a name="4" id="anc4"></a><span class="line-modified">315 </span>

316             void realRun() throws Throwable {
317                 startingGate.await(LONG_DELAY_MS, MILLISECONDS);
<a name="5" id="anc5"></a><span class="line-added">318 </span>
319                 try {
320                     if (timed) barrier.await(LONG_DELAY_MS, MILLISECONDS);
<a name="6" id="anc6"></a><span class="line-modified">321                     else barrier.await();</span>
<span class="line-modified">322                 } catch (Throwable throwable) {</span>
<span class="line-added">323                     this.throwable = throwable;</span>
<span class="line-added">324                 }</span>
325 
<a name="7" id="anc7"></a><span class="line-modified">326                 try {</span>
<span class="line-modified">327                     check(doneSignal.await(LONG_DELAY_MS, MILLISECONDS));</span>
<span class="line-added">328                     if (Thread.interrupted())</span>
<span class="line-added">329                         interruptStatusSetAfterAwait = true;</span>
<span class="line-added">330                 } catch (InterruptedException e) {</span>
<span class="line-added">331                     interruptStatusSetAfterAwait = true;</span>
<span class="line-added">332                 }</span>
333             }
334         }
335 
336         //----------------------------------------------------------------
337         // Interrupt occurs during barrier trip
338         //----------------------------------------------------------------
339         try {
340             final CountDownLatch doneSignal = new CountDownLatch(1);
341             final List&lt;Waiter&gt; waiters = new ArrayList&lt;&gt;(N);
342 
343             // work around finality of closed-over variables
344             final Runnable[] realAction = new Runnable[1];
345             final Runnable delegateAction =
346                 new Runnable() {public void run() {realAction[0].run();}};
347             final CyclicBarrier barrier = new CyclicBarrier(N+1, delegateAction);
348 
349             realAction[0] = new Runnable() { public void run() {
350                 try {
351                     for (int i = 0; i &lt; N/2; i++)
352                         waiters.get(i).interrupt();
353                     // we need to try and ensure that the waiters get
354                     // to process their interruption before we do the
355                     // signalAll that trips the barrier. Using sleep
356                     // seems to work reliably while yield does not.
357                     Thread.sleep(100);
358                 } catch (Throwable t) { unexpected(t); }
359             }};
360             for (int i = 0; i &lt; N; i++) {
<a name="8" id="anc8"></a><span class="line-modified">361                 Waiter waiter = new Waiter(doneSignal, barrier);</span>
362                 waiter.start();
363                 waiters.add(waiter);
364             }
365             startingGate.await(LONG_DELAY_MS, MILLISECONDS);
366             while (barrier.getNumberWaiting() &lt; N) Thread.yield();
367             barrier.await();
368             doneSignal.countDown();
<a name="9" id="anc9"></a><span class="line-modified">369             int countInterruptStatusSetAfterAwait = 0;</span>


370             for (Waiter waiter : waiters) {
371                 waiter.join();
<a name="10" id="anc10"></a><span class="line-modified">372                 equal(waiter.throwable, null);</span>
<span class="line-modified">373                 if (waiter.interruptStatusSetAfterAwait)</span>
<span class="line-modified">374                     countInterruptStatusSetAfterAwait++;</span>
375             }
<a name="11" id="anc11"></a><span class="line-modified">376             equal(countInterruptStatusSetAfterAwait, N/2);</span>
377             check(! barrier.isBroken());
378         } catch (Throwable t) { unexpected(t); }
379 
380         //----------------------------------------------------------------
381         // Multiple interrupts occur during barrier await
382         //----------------------------------------------------------------
383         try {
384             final CountDownLatch doneSignal = new CountDownLatch(1);
385             final CyclicBarrier barrier = new CyclicBarrier(N+1);
386             final List&lt;Waiter&gt; waiters = new ArrayList&lt;&gt;(N);
387             for (int i = 0; i &lt; N; i++) {
<a name="12" id="anc12"></a><span class="line-modified">388                 Waiter waiter = new Waiter(doneSignal, barrier);</span>
389                 waiter.start();
390                 waiters.add(waiter);
391             }
392             startingGate.await(LONG_DELAY_MS, MILLISECONDS);
393             while (barrier.getNumberWaiting() &lt; N) Thread.yield();
<a name="13" id="anc13"></a><span class="line-modified">394             for (int i = 0; i &lt; N/2; i++) {</span>
<span class="line-modified">395                 Thread waiter = waiters.get(i);</span>
<span class="line-added">396                 waiter.interrupt();</span>
<span class="line-added">397             }</span>
398             doneSignal.countDown();
<a name="14" id="anc14"></a>
399             int countInterruptedException = 0;
400             int countBrokenBarrierException = 0;
<a name="15" id="anc15"></a><span class="line-added">401             int countInterruptStatusSetAfterAwait = 0;</span>
402             for (Waiter waiter : waiters) {
403                 waiter.join();
<a name="16" id="anc16"></a><span class="line-modified">404                 if (waiter.throwable instanceof InterruptedException)</span>
405                     countInterruptedException++;
<a name="17" id="anc17"></a><span class="line-modified">406                 if (waiter.throwable instanceof BrokenBarrierException)</span>
407                     countBrokenBarrierException++;
<a name="18" id="anc18"></a><span class="line-modified">408                 if (waiter.interruptStatusSetAfterAwait)</span>
<span class="line-modified">409                     countInterruptStatusSetAfterAwait++;</span>
410             }
<a name="19" id="anc19"></a>
411             equal(countInterruptedException, 1);
412             equal(countBrokenBarrierException, N-1);
413             checkBroken(barrier);
<a name="20" id="anc20"></a><span class="line-added">414             equal(countInterruptStatusSetAfterAwait, N/2-1);</span>
415             reset(barrier);
416         } catch (Throwable t) { unexpected(t); }
417     }
418 
419     //--------------------- Infrastructure ---------------------------
420     static volatile int passed = 0, failed = 0;
421     static void pass() {passed++;}
422     static void fail() {failed++; Thread.dumpStack();}
423     static void fail(String msg) {System.out.println(msg); fail();}
424     static void unexpected(Throwable t) {failed++; t.printStackTrace();}
425     static void check(boolean cond) {if (cond) pass(); else fail();}
426     static void equal(Object x, Object y) {
427         if (x == null ? y == null : x.equals(y)) pass();
428         else fail(x + &quot; not equal to &quot; + y);}
429     public static void main(String[] args) throws Throwable {
430         try {realMain(args);} catch (Throwable t) {unexpected(t);}
431         System.out.printf(&quot;%nPassed = %d, failed = %d%n%n&quot;, passed, failed);
432         if (failed &gt; 0) throw new AssertionError(&quot;Some tests failed&quot;);}
433     interface Fun {void f() throws Throwable;}
434     private static void THROWS(Class&lt;? extends Throwable&gt; k, Fun... fs) {
435         for (Fun f : fs)
436             try { f.f(); fail(&quot;Expected &quot; + k.getName() + &quot; not thrown&quot;); }
437             catch (Throwable t) {
438                 if (k.isAssignableFrom(t.getClass())) pass();
439                 else unexpected(t);}}
440     private abstract static class CheckedThread extends Thread {
441         abstract void realRun() throws Throwable;
442         public void run() {
443             try {realRun();} catch (Throwable t) {unexpected(t);}}}
444 }
<a name="21" id="anc21"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="21" type="hidden" />
</body>
</html>
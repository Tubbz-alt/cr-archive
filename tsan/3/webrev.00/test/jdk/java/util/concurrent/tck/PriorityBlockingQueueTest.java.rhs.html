<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames test/jdk/java/util/concurrent/tck/PriorityBlockingQueueTest.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  3  *
  4  * This code is free software; you can redistribute it and/or modify it
  5  * under the terms of the GNU General Public License version 2 only, as
  6  * published by the Free Software Foundation.
  7  *
  8  * This code is distributed in the hope that it will be useful, but WITHOUT
  9  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 10  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 11  * version 2 for more details (a copy is included in the LICENSE file that
 12  * accompanied this code).
 13  *
 14  * You should have received a copy of the GNU General Public License version
 15  * 2 along with this work; if not, write to the Free Software Foundation,
 16  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 17  *
 18  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 19  * or visit www.oracle.com if you need additional information or have any
 20  * questions.
 21  */
 22 
 23 /*
 24  * This file is available under and governed by the GNU General Public
 25  * License version 2 only, as published by the Free Software Foundation.
 26  * However, the following notice accompanied the original version of this
 27  * file:
 28  *
 29  * Written by Doug Lea with assistance from members of JCP JSR-166
 30  * Expert Group and released to the public domain, as explained at
 31  * http://creativecommons.org/publicdomain/zero/1.0/
 32  * Other contributors include Andrew Wright, Jeffrey Hayes,
 33  * Pat Fisher, Mike Judd.
 34  */
 35 
 36 import static java.util.concurrent.TimeUnit.MILLISECONDS;
 37 
 38 import java.util.ArrayList;
 39 import java.util.Arrays;
 40 import java.util.Collection;
 41 import java.util.Comparator;
 42 import java.util.Iterator;
 43 import java.util.NoSuchElementException;
 44 import java.util.Queue;
 45 import java.util.concurrent.BlockingQueue;
 46 import java.util.concurrent.CountDownLatch;
 47 import java.util.concurrent.Executors;
 48 import java.util.concurrent.ExecutorService;
 49 import java.util.concurrent.PriorityBlockingQueue;
 50 import java.util.concurrent.ThreadLocalRandom;
 51 
 52 import junit.framework.Test;
 53 
 54 public class PriorityBlockingQueueTest extends JSR166TestCase {
 55 
 56     public static class Generic extends BlockingQueueTest {
 57         protected BlockingQueue emptyCollection() {
 58             return new PriorityBlockingQueue();
 59         }
 60     }
 61 
 62     public static class InitialCapacity extends BlockingQueueTest {
 63         protected BlockingQueue emptyCollection() {
 64             ThreadLocalRandom rnd = ThreadLocalRandom.current();
 65             int initialCapacity = rnd.nextInt(1, SIZE);
 66             return new PriorityBlockingQueue(initialCapacity);
 67         }
 68     }
 69 
 70     public static void main(String[] args) {
 71         main(suite(), args);
 72     }
 73 
 74     public static Test suite() {
 75         class Implementation implements CollectionImplementation {
 76             public Class&lt;?&gt; klazz() { return PriorityBlockingQueue.class; }
 77             public Collection emptyCollection() {
 78                 return new PriorityBlockingQueue();
 79             }
 80             public Object makeElement(int i) { return i; }
 81             public boolean isConcurrent() { return true; }
 82             public boolean permitsNulls() { return false; }
 83         }
 84         class ComparatorImplementation implements CollectionImplementation {
 85             public Class&lt;?&gt; klazz() { return PriorityBlockingQueue.class; }
 86             public Collection emptyCollection() {
 87                 ThreadLocalRandom rnd = ThreadLocalRandom.current();
 88                 int initialCapacity = rnd.nextInt(1, 10);
 89                 return new PriorityBlockingQueue(
 90                     initialCapacity, new MyReverseComparator());
 91             }
 92             public Object makeElement(int i) { return i; }
 93             public boolean isConcurrent() { return true; }
 94             public boolean permitsNulls() { return false; }
 95         }
 96         return newTestSuite(
 97             PriorityBlockingQueueTest.class,
 98             new Generic().testSuite(),
 99             new InitialCapacity().testSuite(),
100             CollectionTest.testSuite(new Implementation()),
101             CollectionTest.testSuite(new ComparatorImplementation()));
102     }
103 
104     /** Sample Comparator */
105     static class MyReverseComparator implements Comparator, java.io.Serializable {
106         public int compare(Object x, Object y) {
107             return ((Comparable)y).compareTo(x);
108         }
109     }
110 
111     /**
112      * Returns a new queue of given size containing consecutive
113      * Integers 0 ... n - 1.
114      */
115     private static PriorityBlockingQueue&lt;Integer&gt; populatedQueue(int n) {
116         PriorityBlockingQueue&lt;Integer&gt; q =
117             new PriorityBlockingQueue&lt;Integer&gt;(n);
118         assertTrue(q.isEmpty());
119         for (int i = n - 1; i &gt;= 0; i -= 2)
120             assertTrue(q.offer(new Integer(i)));
121         for (int i = (n &amp; 1); i &lt; n; i += 2)
122             assertTrue(q.offer(new Integer(i)));
123         assertFalse(q.isEmpty());
124         assertEquals(Integer.MAX_VALUE, q.remainingCapacity());
125         assertEquals(n, q.size());
126         assertEquals((Integer) 0, q.peek());
127         return q;
128     }
129 
130     /**
131      * A new queue has unbounded capacity
132      */
133     public void testConstructor1() {
134         assertEquals(Integer.MAX_VALUE,
135                      new PriorityBlockingQueue(SIZE).remainingCapacity());
136     }
137 
138     /**
139      * Constructor throws IllegalArgumentException if capacity argument nonpositive
140      */
141     public void testConstructor2() {
142         try {
143             new PriorityBlockingQueue(0);
144             shouldThrow();
145         } catch (IllegalArgumentException success) {}
146     }
147 
148     /**
149      * Initializing from null Collection throws NPE
150      */
151     public void testConstructor3() {
152         try {
153             new PriorityBlockingQueue(null);
154             shouldThrow();
155         } catch (NullPointerException success) {}
156     }
157 
158     /**
159      * Initializing from Collection of null elements throws NPE
160      */
161     public void testConstructor4() {
162         Collection&lt;Integer&gt; elements = Arrays.asList(new Integer[SIZE]);
163         try {
164             new PriorityBlockingQueue(elements);
165             shouldThrow();
166         } catch (NullPointerException success) {}
167     }
168 
169     /**
170      * Initializing from Collection with some null elements throws NPE
171      */
172     public void testConstructor5() {
173         Integer[] ints = new Integer[SIZE];
174         for (int i = 0; i &lt; SIZE - 1; ++i)
175             ints[i] = i;
176         Collection&lt;Integer&gt; elements = Arrays.asList(ints);
177         try {
178             new PriorityBlockingQueue(elements);
179             shouldThrow();
180         } catch (NullPointerException success) {}
181     }
182 
183     /**
184      * Queue contains all elements of collection used to initialize
185      */
186     public void testConstructor6() {
187         Integer[] ints = new Integer[SIZE];
188         for (int i = 0; i &lt; SIZE; ++i)
189             ints[i] = i;
190         PriorityBlockingQueue q = new PriorityBlockingQueue(Arrays.asList(ints));
191         for (int i = 0; i &lt; SIZE; ++i)
192             assertEquals(ints[i], q.poll());
193     }
194 
195     /**
196      * The comparator used in constructor is used
197      */
198     public void testConstructor7() {
199         MyReverseComparator cmp = new MyReverseComparator();
200         PriorityBlockingQueue q = new PriorityBlockingQueue(SIZE, cmp);
201         assertEquals(cmp, q.comparator());
202         Integer[] ints = new Integer[SIZE];
203         for (int i = 0; i &lt; SIZE; ++i)
204             ints[i] = new Integer(i);
205         q.addAll(Arrays.asList(ints));
206         for (int i = SIZE - 1; i &gt;= 0; --i)
207             assertEquals(ints[i], q.poll());
208     }
209 
210     /**
211      * isEmpty is true before add, false after
212      */
213     public void testEmpty() {
214         PriorityBlockingQueue q = new PriorityBlockingQueue(2);
215         assertTrue(q.isEmpty());
216         assertEquals(Integer.MAX_VALUE, q.remainingCapacity());
217         q.add(one);
218         assertFalse(q.isEmpty());
219         q.add(two);
220         q.remove();
221         q.remove();
222         assertTrue(q.isEmpty());
223     }
224 
225     /**
226      * remainingCapacity() always returns Integer.MAX_VALUE
227      */
228     public void testRemainingCapacity() {
229         BlockingQueue q = populatedQueue(SIZE);
230         for (int i = 0; i &lt; SIZE; ++i) {
231             assertEquals(Integer.MAX_VALUE, q.remainingCapacity());
232             assertEquals(SIZE - i, q.size());
233             assertEquals(i, q.remove());
234         }
235         for (int i = 0; i &lt; SIZE; ++i) {
236             assertEquals(Integer.MAX_VALUE, q.remainingCapacity());
237             assertEquals(i, q.size());
238             assertTrue(q.add(i));
239         }
240     }
241 
242     /**
243      * Offer of comparable element succeeds
244      */
245     public void testOffer() {
246         PriorityBlockingQueue q = new PriorityBlockingQueue(1);
247         assertTrue(q.offer(zero));
248         assertTrue(q.offer(one));
249     }
250 
251     /**
252      * Offer of non-Comparable throws CCE
253      */
254     public void testOfferNonComparable() {
255         PriorityBlockingQueue q = new PriorityBlockingQueue(1);
256         try {
257             q.offer(new Object());
258             shouldThrow();
259         } catch (ClassCastException success) {
260             assertTrue(q.isEmpty());
261             assertEquals(0, q.size());
262             assertNull(q.poll());
263         }
264     }
265 
266     /**
267      * add of comparable succeeds
268      */
269     public void testAdd() {
270         PriorityBlockingQueue q = new PriorityBlockingQueue(SIZE);
271         for (int i = 0; i &lt; SIZE; ++i) {
272             assertEquals(i, q.size());
273             assertTrue(q.add(new Integer(i)));
274         }
275     }
276 
277     /**
278      * addAll(this) throws IllegalArgumentException
279      */
280     public void testAddAllSelf() {
281         PriorityBlockingQueue q = populatedQueue(SIZE);
282         try {
283             q.addAll(q);
284             shouldThrow();
285         } catch (IllegalArgumentException success) {}
286     }
287 
288     /**
289      * addAll of a collection with any null elements throws NPE after
290      * possibly adding some elements
291      */
292     public void testAddAll3() {
293         PriorityBlockingQueue q = new PriorityBlockingQueue(SIZE);
294         Integer[] ints = new Integer[SIZE];
295         for (int i = 0; i &lt; SIZE - 1; ++i)
296             ints[i] = new Integer(i);
297         try {
298             q.addAll(Arrays.asList(ints));
299             shouldThrow();
300         } catch (NullPointerException success) {}
301     }
302 
303     /**
304      * Queue contains all elements of successful addAll
305      */
306     public void testAddAll5() {
307         Integer[] empty = new Integer[0];
308         Integer[] ints = new Integer[SIZE];
309         for (int i = SIZE - 1; i &gt;= 0; --i)
310             ints[i] = new Integer(i);
311         PriorityBlockingQueue q = new PriorityBlockingQueue(SIZE);
312         assertFalse(q.addAll(Arrays.asList(empty)));
313         assertTrue(q.addAll(Arrays.asList(ints)));
314         for (int i = 0; i &lt; SIZE; ++i)
315             assertEquals(ints[i], q.poll());
316     }
317 
318     /**
319      * all elements successfully put are contained
320      */
321     public void testPut() {
322         PriorityBlockingQueue q = new PriorityBlockingQueue(SIZE);
323         for (int i = 0; i &lt; SIZE; ++i) {
324             Integer x = new Integer(i);
325             q.put(x);
326             assertTrue(q.contains(x));
327         }
328         assertEquals(SIZE, q.size());
329     }
330 
331     /**
332      * put doesn&#39;t block waiting for take
333      */
334     public void testPutWithTake() throws InterruptedException {
335         final PriorityBlockingQueue q = new PriorityBlockingQueue(2);
336         final int size = 4;
337         Thread t = newStartedThread(new CheckedRunnable() {
338             public void realRun() {
339                 for (int i = 0; i &lt; size; i++)
340                     q.put(new Integer(0));
341             }});
342 
343         awaitTermination(t);
344         assertEquals(size, q.size());
345         q.take();
346     }
347 
348     /**
<a name="1" id="anc1"></a><span class="line-modified">349      * Queue is unbounded, so timed offer never times out</span>
350      */
351     public void testTimedOffer() {
352         final PriorityBlockingQueue q = new PriorityBlockingQueue(2);
353         Thread t = newStartedThread(new CheckedRunnable() {
354             public void realRun() {
355                 q.put(new Integer(0));
356                 q.put(new Integer(0));
357                 assertTrue(q.offer(new Integer(0), SHORT_DELAY_MS, MILLISECONDS));
358                 assertTrue(q.offer(new Integer(0), LONG_DELAY_MS, MILLISECONDS));
359             }});
360 
361         awaitTermination(t);
362     }
363 
364     /**
365      * take retrieves elements in priority order
366      */
367     public void testTake() throws InterruptedException {
368         PriorityBlockingQueue q = populatedQueue(SIZE);
369         for (int i = 0; i &lt; SIZE; ++i) {
370             assertEquals(i, q.take());
371         }
372     }
373 
374     /**
375      * Take removes existing elements until empty, then blocks interruptibly
376      */
377     public void testBlockingTake() throws InterruptedException {
378         final PriorityBlockingQueue q = populatedQueue(SIZE);
379         final CountDownLatch pleaseInterrupt = new CountDownLatch(1);
380         Thread t = newStartedThread(new CheckedRunnable() {
381             public void realRun() throws InterruptedException {
382                 for (int i = 0; i &lt; SIZE; i++) assertEquals(i, q.take());
383 
384                 Thread.currentThread().interrupt();
385                 try {
386                     q.take();
387                     shouldThrow();
388                 } catch (InterruptedException success) {}
389                 assertFalse(Thread.interrupted());
390 
391                 pleaseInterrupt.countDown();
392                 try {
393                     q.take();
394                     shouldThrow();
395                 } catch (InterruptedException success) {}
396                 assertFalse(Thread.interrupted());
397             }});
398 
399         await(pleaseInterrupt);
<a name="2" id="anc2"></a><span class="line-modified">400         if (randomBoolean()) assertThreadBlocks(t, Thread.State.WAITING);</span>
401         t.interrupt();
402         awaitTermination(t);
403     }
404 
405     /**
406      * poll succeeds unless empty
407      */
408     public void testPoll() {
409         PriorityBlockingQueue q = populatedQueue(SIZE);
410         for (int i = 0; i &lt; SIZE; ++i) {
411             assertEquals(i, q.poll());
412         }
413         assertNull(q.poll());
414     }
415 
416     /**
417      * timed poll with zero timeout succeeds when non-empty, else times out
418      */
419     public void testTimedPoll0() throws InterruptedException {
420         PriorityBlockingQueue q = populatedQueue(SIZE);
421         for (int i = 0; i &lt; SIZE; ++i) {
422             assertEquals(i, q.poll(0, MILLISECONDS));
423         }
424         assertNull(q.poll(0, MILLISECONDS));
425     }
426 
427     /**
428      * timed poll with nonzero timeout succeeds when non-empty, else times out
429      */
430     public void testTimedPoll() throws InterruptedException {
431         PriorityBlockingQueue&lt;Integer&gt; q = populatedQueue(SIZE);
432         for (int i = 0; i &lt; SIZE; ++i) {
433             long startTime = System.nanoTime();
434             assertEquals(i, (int) q.poll(LONG_DELAY_MS, MILLISECONDS));
435             assertTrue(millisElapsedSince(startTime) &lt; LONG_DELAY_MS);
436         }
437         long startTime = System.nanoTime();
438         assertNull(q.poll(timeoutMillis(), MILLISECONDS));
439         assertTrue(millisElapsedSince(startTime) &gt;= timeoutMillis());
440         checkEmpty(q);
441     }
442 
443     /**
444      * Interrupted timed poll throws InterruptedException instead of
445      * returning timeout status
446      */
447     public void testInterruptedTimedPoll() throws InterruptedException {
448         final BlockingQueue&lt;Integer&gt; q = populatedQueue(SIZE);
449         final CountDownLatch pleaseInterrupt = new CountDownLatch(1);
450         Thread t = newStartedThread(new CheckedRunnable() {
451             public void realRun() throws InterruptedException {
<a name="3" id="anc3"></a>
452                 for (int i = 0; i &lt; SIZE; i++)
453                     assertEquals(i, (int) q.poll(LONG_DELAY_MS, MILLISECONDS));
454 
455                 Thread.currentThread().interrupt();
456                 try {
<a name="4" id="anc4"></a><span class="line-modified">457                     q.poll(randomTimeout(), randomTimeUnit());</span>
458                     shouldThrow();
459                 } catch (InterruptedException success) {}
460                 assertFalse(Thread.interrupted());
461 
462                 pleaseInterrupt.countDown();
463                 try {
<a name="5" id="anc5"></a><span class="line-modified">464                     q.poll(LONGER_DELAY_MS, MILLISECONDS);</span>
465                     shouldThrow();
466                 } catch (InterruptedException success) {}
467                 assertFalse(Thread.interrupted());
<a name="6" id="anc6"></a>

468             }});
469 
470         await(pleaseInterrupt);
<a name="7" id="anc7"></a><span class="line-modified">471         if (randomBoolean()) assertThreadBlocks(t, Thread.State.TIMED_WAITING);</span>
472         t.interrupt();
473         awaitTermination(t);
474     }
475 
476     /**
477      * peek returns next element, or null if empty
478      */
479     public void testPeek() {
480         PriorityBlockingQueue q = populatedQueue(SIZE);
481         for (int i = 0; i &lt; SIZE; ++i) {
482             assertEquals(i, q.peek());
483             assertEquals(i, q.poll());
484             assertTrue(q.peek() == null ||
485                        !q.peek().equals(i));
486         }
487         assertNull(q.peek());
488     }
489 
490     /**
491      * element returns next element, or throws NSEE if empty
492      */
493     public void testElement() {
494         PriorityBlockingQueue q = populatedQueue(SIZE);
495         for (int i = 0; i &lt; SIZE; ++i) {
496             assertEquals(i, q.element());
497             assertEquals(i, q.poll());
498         }
499         try {
500             q.element();
501             shouldThrow();
502         } catch (NoSuchElementException success) {}
503     }
504 
505     /**
506      * remove removes next element, or throws NSEE if empty
507      */
508     public void testRemove() {
509         PriorityBlockingQueue q = populatedQueue(SIZE);
510         for (int i = 0; i &lt; SIZE; ++i) {
511             assertEquals(i, q.remove());
512         }
513         try {
514             q.remove();
515             shouldThrow();
516         } catch (NoSuchElementException success) {}
517     }
518 
519     /**
520      * contains(x) reports true when elements added but not yet removed
521      */
522     public void testContains() {
523         PriorityBlockingQueue q = populatedQueue(SIZE);
524         for (int i = 0; i &lt; SIZE; ++i) {
525             assertTrue(q.contains(new Integer(i)));
526             q.poll();
527             assertFalse(q.contains(new Integer(i)));
528         }
529     }
530 
531     /**
532      * clear removes all elements
533      */
534     public void testClear() {
535         PriorityBlockingQueue q = populatedQueue(SIZE);
536         q.clear();
537         assertTrue(q.isEmpty());
538         assertEquals(0, q.size());
539         q.add(one);
540         assertFalse(q.isEmpty());
541         assertTrue(q.contains(one));
542         q.clear();
543         assertTrue(q.isEmpty());
544     }
545 
546     /**
547      * containsAll(c) is true when c contains a subset of elements
548      */
549     public void testContainsAll() {
550         PriorityBlockingQueue q = populatedQueue(SIZE);
551         PriorityBlockingQueue p = new PriorityBlockingQueue(SIZE);
552         for (int i = 0; i &lt; SIZE; ++i) {
553             assertTrue(q.containsAll(p));
554             assertFalse(p.containsAll(q));
555             p.add(new Integer(i));
556         }
557         assertTrue(p.containsAll(q));
558     }
559 
560     /**
561      * retainAll(c) retains only those elements of c and reports true if changed
562      */
563     public void testRetainAll() {
564         PriorityBlockingQueue q = populatedQueue(SIZE);
565         PriorityBlockingQueue p = populatedQueue(SIZE);
566         for (int i = 0; i &lt; SIZE; ++i) {
567             boolean changed = q.retainAll(p);
568             if (i == 0)
569                 assertFalse(changed);
570             else
571                 assertTrue(changed);
572 
573             assertTrue(q.containsAll(p));
574             assertEquals(SIZE - i, q.size());
575             p.remove();
576         }
577     }
578 
579     /**
580      * removeAll(c) removes only those elements of c and reports true if changed
581      */
582     public void testRemoveAll() {
583         for (int i = 1; i &lt; SIZE; ++i) {
584             PriorityBlockingQueue q = populatedQueue(SIZE);
585             PriorityBlockingQueue p = populatedQueue(i);
586             assertTrue(q.removeAll(p));
587             assertEquals(SIZE - i, q.size());
588             for (int j = 0; j &lt; i; ++j) {
589                 Integer x = (Integer)(p.remove());
590                 assertFalse(q.contains(x));
591             }
592         }
593     }
594 
595     /**
596      * toArray contains all elements
597      */
598     public void testToArray() throws InterruptedException {
599         PriorityBlockingQueue q = populatedQueue(SIZE);
600         Object[] a = q.toArray();
601         assertSame(Object[].class, a.getClass());
602         Arrays.sort(a);
603         for (Object o : a)
604             assertSame(o, q.take());
605         assertTrue(q.isEmpty());
606     }
607 
608     /**
609      * toArray(a) contains all elements
610      */
611     public void testToArray2() throws InterruptedException {
612         PriorityBlockingQueue&lt;Integer&gt; q = populatedQueue(SIZE);
613         Integer[] ints = new Integer[SIZE];
614         Integer[] array = q.toArray(ints);
615         assertSame(ints, array);
616         Arrays.sort(ints);
617         for (Integer o : ints)
618             assertSame(o, q.take());
619         assertTrue(q.isEmpty());
620     }
621 
622     /**
623      * toArray(incompatible array type) throws ArrayStoreException
624      */
625     public void testToArray1_BadArg() {
626         PriorityBlockingQueue q = populatedQueue(SIZE);
627         try {
628             q.toArray(new String[10]);
629             shouldThrow();
630         } catch (ArrayStoreException success) {}
631     }
632 
633     /**
634      * iterator iterates through all elements
635      */
636     public void testIterator() {
637         PriorityBlockingQueue q = populatedQueue(SIZE);
638         Iterator it = q.iterator();
639         int i;
640         for (i = 0; it.hasNext(); i++)
641             assertTrue(q.contains(it.next()));
642         assertEquals(i, SIZE);
643         assertIteratorExhausted(it);
644     }
645 
646     /**
647      * iterator of empty collection has no elements
648      */
649     public void testEmptyIterator() {
650         assertIteratorExhausted(new PriorityBlockingQueue().iterator());
651     }
652 
653     /**
654      * iterator.remove removes current element
655      */
656     public void testIteratorRemove() {
657         final PriorityBlockingQueue q = new PriorityBlockingQueue(3);
658         q.add(new Integer(2));
659         q.add(new Integer(1));
660         q.add(new Integer(3));
661 
662         Iterator it = q.iterator();
663         it.next();
664         it.remove();
665 
666         it = q.iterator();
667         assertEquals(it.next(), new Integer(2));
668         assertEquals(it.next(), new Integer(3));
669         assertFalse(it.hasNext());
670     }
671 
672     /**
673      * toString contains toStrings of elements
674      */
675     public void testToString() {
676         PriorityBlockingQueue q = populatedQueue(SIZE);
677         String s = q.toString();
678         for (int i = 0; i &lt; SIZE; ++i) {
679             assertTrue(s.contains(String.valueOf(i)));
680         }
681     }
682 
683     /**
684      * timed poll transfers elements across Executor tasks
685      */
686     public void testPollInExecutor() {
687         final PriorityBlockingQueue q = new PriorityBlockingQueue(2);
688         final CheckedBarrier threadsStarted = new CheckedBarrier(2);
689         final ExecutorService executor = Executors.newFixedThreadPool(2);
690         try (PoolCleaner cleaner = cleaner(executor)) {
691             executor.execute(new CheckedRunnable() {
692                 public void realRun() throws InterruptedException {
693                     assertNull(q.poll());
694                     threadsStarted.await();
695                     assertSame(one, q.poll(LONG_DELAY_MS, MILLISECONDS));
696                     checkEmpty(q);
697                 }});
698 
699             executor.execute(new CheckedRunnable() {
700                 public void realRun() throws InterruptedException {
701                     threadsStarted.await();
702                     q.put(one);
703                 }});
704         }
705     }
706 
707     /**
708      * A deserialized/reserialized queue has same elements
709      */
710     public void testSerialization() throws Exception {
711         Queue x = populatedQueue(SIZE);
712         Queue y = serialClone(x);
713 
714         assertNotSame(x, y);
715         assertEquals(x.size(), y.size());
716         while (!x.isEmpty()) {
717             assertFalse(y.isEmpty());
718             assertEquals(x.remove(), y.remove());
719         }
720         assertTrue(y.isEmpty());
721     }
722 
723     /**
724      * drainTo(c) empties queue into another collection c
725      */
726     public void testDrainTo() {
727         PriorityBlockingQueue q = populatedQueue(SIZE);
728         ArrayList l = new ArrayList();
729         q.drainTo(l);
730         assertEquals(0, q.size());
731         assertEquals(SIZE, l.size());
732         for (int i = 0; i &lt; SIZE; ++i)
733             assertEquals(l.get(i), new Integer(i));
734         q.add(zero);
735         q.add(one);
736         assertFalse(q.isEmpty());
737         assertTrue(q.contains(zero));
738         assertTrue(q.contains(one));
739         l.clear();
740         q.drainTo(l);
741         assertEquals(0, q.size());
742         assertEquals(2, l.size());
743         for (int i = 0; i &lt; 2; ++i)
744             assertEquals(l.get(i), new Integer(i));
745     }
746 
747     /**
748      * drainTo empties queue
749      */
750     public void testDrainToWithActivePut() throws InterruptedException {
751         final PriorityBlockingQueue q = populatedQueue(SIZE);
752         Thread t = new Thread(new CheckedRunnable() {
753             public void realRun() {
754                 q.put(new Integer(SIZE + 1));
755             }});
756 
757         t.start();
758         ArrayList l = new ArrayList();
759         q.drainTo(l);
760         assertTrue(l.size() &gt;= SIZE);
761         for (int i = 0; i &lt; SIZE; ++i)
762             assertEquals(l.get(i), new Integer(i));
763         t.join();
764         assertTrue(q.size() + l.size() &gt;= SIZE);
765     }
766 
767     /**
768      * drainTo(c, n) empties first min(n, size) elements of queue into c
769      */
770     public void testDrainToN() {
771         PriorityBlockingQueue q = new PriorityBlockingQueue(SIZE * 2);
772         for (int i = 0; i &lt; SIZE + 2; ++i) {
773             for (int j = 0; j &lt; SIZE; j++)
774                 assertTrue(q.offer(new Integer(j)));
775             ArrayList l = new ArrayList();
776             q.drainTo(l, i);
777             int k = (i &lt; SIZE) ? i : SIZE;
778             assertEquals(k, l.size());
779             assertEquals(SIZE - k, q.size());
780             for (int j = 0; j &lt; k; ++j)
781                 assertEquals(l.get(j), new Integer(j));
782             do {} while (q.poll() != null);
783         }
784     }
785 
786     /**
787      * remove(null), contains(null) always return false
788      */
789     public void testNeverContainsNull() {
790         Collection&lt;?&gt;[] qs = {
791             new PriorityBlockingQueue&lt;Object&gt;(),
792             populatedQueue(2),
793         };
794 
795         for (Collection&lt;?&gt; q : qs) {
796             assertFalse(q.contains(null));
797             assertFalse(q.remove(null));
798         }
799     }
800 
801 }
<a name="8" id="anc8"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="8" type="hidden" />
</body>
</html>
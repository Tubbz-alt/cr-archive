diff a/test/jdk/java/util/concurrent/BlockingQueue/OfferDrainToLoops.java b/test/jdk/java/util/concurrent/BlockingQueue/OfferDrainToLoops.java
--- a/test/jdk/java/util/concurrent/BlockingQueue/OfferDrainToLoops.java
+++ b/test/jdk/java/util/concurrent/BlockingQueue/OfferDrainToLoops.java
@@ -32,10 +32,11 @@
  */
 
 /*
  * @test
  * @bug 6805775 6815766
+ * @library /test/lib
  * @run main OfferDrainToLoops 100
  * @summary Test concurrent offer vs. drainTo
  */
 
 import java.util.ArrayList;
@@ -45,14 +46,16 @@
 import java.util.concurrent.BlockingQueue;
 import java.util.concurrent.LinkedBlockingDeque;
 import java.util.concurrent.LinkedBlockingQueue;
 import java.util.concurrent.LinkedTransferQueue;
 import java.util.concurrent.atomic.AtomicLong;
+import jdk.test.lib.Utils;
 
 @SuppressWarnings({"unchecked", "rawtypes", "deprecation"})
 public class OfferDrainToLoops {
-    final long testDurationMillisDefault = 10L * 1000L;
+    static final long LONG_DELAY_MS = Utils.adjustTimeout(10_000);
+    final long testDurationMillisDefault = 10_000L;
     final long testDurationMillis;
 
     OfferDrainToLoops(String[] args) {
         testDurationMillis = (args.length > 0) ?
             Long.valueOf(args[0]) : testDurationMillisDefault;
@@ -74,11 +77,10 @@
 
     void test(final BlockingQueue q) throws Throwable {
         System.out.println(q.getClass().getSimpleName());
         final long testDurationNanos = testDurationMillis * 1000L * 1000L;
         final long quittingTimeNanos = System.nanoTime() + testDurationNanos;
-        final long timeoutMillis = 10L * 1000L;
         final SplittableRandom rnd = new SplittableRandom();
 
         // Poor man's bounded buffer.
         final AtomicLong approximateCount = new AtomicLong(0L);
 
@@ -153,17 +155,17 @@
                     }
                     Thread.yield();
                 }}};
 
         for (Thread thread : new Thread[] { offerer, drainer, scanner }) {
-            thread.join(timeoutMillis + testDurationMillis);
+            thread.join(LONG_DELAY_MS + testDurationMillis);
             if (thread.isAlive()) {
                 System.err.printf("Hung thread: %s%n", thread.getName());
                 failed++;
                 for (StackTraceElement e : thread.getStackTrace())
                     System.err.println(e);
-                thread.join(timeoutMillis);
+                thread.join(LONG_DELAY_MS);
             }
         }
     }
 
     //--------------------- Infrastructure ---------------------------

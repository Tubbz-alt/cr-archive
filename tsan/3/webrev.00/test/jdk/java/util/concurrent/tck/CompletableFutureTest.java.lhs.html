<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames test/jdk/java/util/concurrent/tck/CompletableFutureTest.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   3  *
   4  * This code is free software; you can redistribute it and/or modify it
   5  * under the terms of the GNU General Public License version 2 only, as
   6  * published by the Free Software Foundation.
   7  *
   8  * This code is distributed in the hope that it will be useful, but WITHOUT
   9  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  10  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  11  * version 2 for more details (a copy is included in the LICENSE file that
  12  * accompanied this code).
  13  *
  14  * You should have received a copy of the GNU General Public License version
  15  * 2 along with this work; if not, write to the Free Software Foundation,
  16  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  17  *
  18  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  19  * or visit www.oracle.com if you need additional information or have any
  20  * questions.
  21  */
  22 
  23 /*
  24  * This file is available under and governed by the GNU General Public
  25  * License version 2 only, as published by the Free Software Foundation.
  26  * However, the following notice accompanied the original version of this
  27  * file:
  28  *
  29  * Written by Doug Lea and Martin Buchholz with assistance from
  30  * members of JCP JSR-166 Expert Group and released to the public
  31  * domain, as explained at
  32  * http://creativecommons.org/publicdomain/zero/1.0/
  33  */
  34 
  35 import static java.util.concurrent.TimeUnit.MILLISECONDS;
  36 import static java.util.concurrent.TimeUnit.SECONDS;
  37 import static java.util.concurrent.CompletableFuture.completedFuture;
  38 import static java.util.concurrent.CompletableFuture.failedFuture;
  39 
  40 import java.lang.reflect.Method;
  41 import java.lang.reflect.Modifier;
  42 
  43 import java.util.stream.Collectors;
  44 import java.util.stream.Stream;
  45 
  46 import java.util.ArrayList;
  47 import java.util.Arrays;
  48 import java.util.List;
  49 import java.util.Objects;
  50 import java.util.Set;
  51 import java.util.concurrent.Callable;
  52 import java.util.concurrent.CancellationException;
  53 import java.util.concurrent.CompletableFuture;
  54 import java.util.concurrent.CompletionException;
  55 import java.util.concurrent.CompletionStage;
  56 import java.util.concurrent.ExecutionException;
  57 import java.util.concurrent.Executor;
  58 import java.util.concurrent.ForkJoinPool;
  59 import java.util.concurrent.ForkJoinTask;
  60 import java.util.concurrent.RejectedExecutionException;
  61 import java.util.concurrent.TimeoutException;
  62 import java.util.concurrent.atomic.AtomicInteger;
  63 import java.util.concurrent.atomic.AtomicReference;
  64 import java.util.function.BiConsumer;
  65 import java.util.function.BiFunction;
  66 import java.util.function.Consumer;
  67 import java.util.function.Function;
  68 import java.util.function.Predicate;
  69 import java.util.function.Supplier;
  70 
  71 import junit.framework.Test;
  72 import junit.framework.TestSuite;
  73 
  74 public class CompletableFutureTest extends JSR166TestCase {
  75 
  76     public static void main(String[] args) {
  77         main(suite(), args);
  78     }
  79     public static Test suite() {
  80         return new TestSuite(CompletableFutureTest.class);
  81     }
  82 
  83     static class CFException extends RuntimeException {}
  84 
  85     void checkIncomplete(CompletableFuture&lt;?&gt; f) {
  86         assertFalse(f.isDone());
  87         assertFalse(f.isCancelled());
  88         assertTrue(f.toString().matches(&quot;.*\\[.*Not completed.*\\]&quot;));
  89 
  90         Object result = null;
  91         try {
  92             result = f.getNow(null);
  93         } catch (Throwable fail) { threadUnexpectedException(fail); }
  94         assertNull(result);
  95 
  96         try {
  97             f.get(randomExpiredTimeout(), randomTimeUnit());
  98             shouldThrow();
  99         }
 100         catch (TimeoutException success) {}
 101         catch (Throwable fail) { threadUnexpectedException(fail); }
 102     }
 103 
 104     &lt;T&gt; void checkCompletedNormally(CompletableFuture&lt;T&gt; f, T expectedValue) {
 105         checkTimedGet(f, expectedValue);
 106 
 107         assertEquals(expectedValue, f.join());
 108         assertEquals(expectedValue, f.getNow(null));
 109 
 110         T result = null;
 111         try {
 112             result = f.get();
 113         } catch (Throwable fail) { threadUnexpectedException(fail); }
 114         assertEquals(expectedValue, result);
 115 
 116         assertTrue(f.isDone());
 117         assertFalse(f.isCancelled());
 118         assertFalse(f.isCompletedExceptionally());
 119         assertTrue(f.toString().matches(&quot;.*\\[.*Completed normally.*\\]&quot;));
 120     }
 121 
 122     /**
 123      * Returns the &quot;raw&quot; internal exceptional completion of f,
 124      * without any additional wrapping with CompletionException.
 125      */
 126     Throwable exceptionalCompletion(CompletableFuture&lt;?&gt; f) {
 127         // handle (and whenComplete and exceptionally) can distinguish
 128         // between &quot;direct&quot; and &quot;wrapped&quot; exceptional completion
 129         return f.handle((u, t) -&gt; t).join();
 130     }
 131 
 132     void checkCompletedExceptionally(CompletableFuture&lt;?&gt; f,
 133                                      boolean wrapped,
 134                                      Consumer&lt;Throwable&gt; checker) {
 135         Throwable cause = exceptionalCompletion(f);
 136         if (wrapped) {
 137             assertTrue(cause instanceof CompletionException);
 138             cause = cause.getCause();
 139         }
 140         checker.accept(cause);
 141 
 142         long startTime = System.nanoTime();
 143         try {
 144             f.get(LONG_DELAY_MS, MILLISECONDS);
 145             shouldThrow();
 146         } catch (ExecutionException success) {
 147             assertSame(cause, success.getCause());
 148         } catch (Throwable fail) { threadUnexpectedException(fail); }
 149         assertTrue(millisElapsedSince(startTime) &lt; LONG_DELAY_MS / 2);
 150 
 151         try {
 152             f.join();
 153             shouldThrow();
 154         } catch (CompletionException success) {
 155             assertSame(cause, success.getCause());
 156         } catch (Throwable fail) { threadUnexpectedException(fail); }
 157 
 158         try {
 159             f.getNow(null);
 160             shouldThrow();
 161         } catch (CompletionException success) {
 162             assertSame(cause, success.getCause());
 163         } catch (Throwable fail) { threadUnexpectedException(fail); }
 164 
 165         try {
 166             f.get();
 167             shouldThrow();
 168         } catch (ExecutionException success) {
 169             assertSame(cause, success.getCause());
 170         } catch (Throwable fail) { threadUnexpectedException(fail); }
 171 
 172         assertFalse(f.isCancelled());
 173         assertTrue(f.isDone());
 174         assertTrue(f.isCompletedExceptionally());
 175         assertTrue(f.toString().matches(&quot;.*\\[.*Completed exceptionally.*\\]&quot;));
 176     }
 177 
 178     void checkCompletedWithWrappedCFException(CompletableFuture&lt;?&gt; f) {
 179         checkCompletedExceptionally(f, true,
 180             t -&gt; assertTrue(t instanceof CFException));
 181     }
 182 
 183     void checkCompletedWithWrappedCancellationException(CompletableFuture&lt;?&gt; f) {
 184         checkCompletedExceptionally(f, true,
 185             t -&gt; assertTrue(t instanceof CancellationException));
 186     }
 187 
 188     void checkCompletedWithTimeoutException(CompletableFuture&lt;?&gt; f) {
 189         checkCompletedExceptionally(f, false,
 190             t -&gt; assertTrue(t instanceof TimeoutException));
 191     }
 192 
 193     void checkCompletedWithWrappedException(CompletableFuture&lt;?&gt; f,
 194                                             Throwable ex) {
 195         checkCompletedExceptionally(f, true, t -&gt; assertSame(t, ex));
 196     }
 197 
 198     void checkCompletedExceptionally(CompletableFuture&lt;?&gt; f, Throwable ex) {
 199         checkCompletedExceptionally(f, false, t -&gt; assertSame(t, ex));
 200     }
 201 
 202     void checkCancelled(CompletableFuture&lt;?&gt; f) {
 203         long startTime = System.nanoTime();
 204         try {
 205             f.get(LONG_DELAY_MS, MILLISECONDS);
 206             shouldThrow();
 207         } catch (CancellationException success) {
 208         } catch (Throwable fail) { threadUnexpectedException(fail); }
 209         assertTrue(millisElapsedSince(startTime) &lt; LONG_DELAY_MS / 2);
 210 
 211         try {
 212             f.join();
 213             shouldThrow();
 214         } catch (CancellationException success) {}
 215         try {
 216             f.getNow(null);
 217             shouldThrow();
 218         } catch (CancellationException success) {}
 219         try {
 220             f.get();
 221             shouldThrow();
 222         } catch (CancellationException success) {
 223         } catch (Throwable fail) { threadUnexpectedException(fail); }
 224 
 225         assertTrue(exceptionalCompletion(f) instanceof CancellationException);
 226 
 227         assertTrue(f.isDone());
 228         assertTrue(f.isCompletedExceptionally());
 229         assertTrue(f.isCancelled());
 230         assertTrue(f.toString().matches(&quot;.*\\[.*Completed exceptionally.*\\]&quot;));
 231     }
 232 
 233     /**
 234      * A newly constructed CompletableFuture is incomplete, as indicated
 235      * by methods isDone, isCancelled, and getNow
 236      */
 237     public void testConstructor() {
 238         CompletableFuture&lt;Integer&gt; f = new CompletableFuture&lt;&gt;();
 239         checkIncomplete(f);
 240     }
 241 
 242     /**
 243      * complete completes normally, as indicated by methods isDone,
 244      * isCancelled, join, get, and getNow
 245      */
 246     public void testComplete() {
 247         for (Integer v1 : new Integer[] { 1, null })
 248     {
 249         CompletableFuture&lt;Integer&gt; f = new CompletableFuture&lt;&gt;();
 250         checkIncomplete(f);
 251         assertTrue(f.complete(v1));
 252         assertFalse(f.complete(v1));
 253         checkCompletedNormally(f, v1);
 254     }}
 255 
 256     /**
 257      * completeExceptionally completes exceptionally, as indicated by
 258      * methods isDone, isCancelled, join, get, and getNow
 259      */
 260     public void testCompleteExceptionally() {
 261         CompletableFuture&lt;Integer&gt; f = new CompletableFuture&lt;&gt;();
 262         CFException ex = new CFException();
 263         checkIncomplete(f);
 264         f.completeExceptionally(ex);
 265         checkCompletedExceptionally(f, ex);
 266     }
 267 
 268     /**
 269      * cancel completes exceptionally and reports cancelled, as indicated by
 270      * methods isDone, isCancelled, join, get, and getNow
 271      */
 272     public void testCancel() {
 273         for (boolean mayInterruptIfRunning : new boolean[] { true, false })
 274     {
 275         CompletableFuture&lt;Integer&gt; f = new CompletableFuture&lt;&gt;();
 276         checkIncomplete(f);
 277         assertTrue(f.cancel(mayInterruptIfRunning));
 278         assertTrue(f.cancel(mayInterruptIfRunning));
 279         assertTrue(f.cancel(!mayInterruptIfRunning));
 280         checkCancelled(f);
 281     }}
 282 
 283     /**
 284      * obtrudeValue forces completion with given value
 285      */
 286     public void testObtrudeValue() {
 287         CompletableFuture&lt;Integer&gt; f = new CompletableFuture&lt;&gt;();
 288         checkIncomplete(f);
 289         assertTrue(f.complete(one));
 290         checkCompletedNormally(f, one);
 291         f.obtrudeValue(three);
 292         checkCompletedNormally(f, three);
 293         f.obtrudeValue(two);
 294         checkCompletedNormally(f, two);
 295         f = new CompletableFuture&lt;&gt;();
 296         f.obtrudeValue(three);
 297         checkCompletedNormally(f, three);
 298         f.obtrudeValue(null);
 299         checkCompletedNormally(f, null);
 300         f = new CompletableFuture&lt;&gt;();
 301         f.completeExceptionally(new CFException());
 302         f.obtrudeValue(four);
 303         checkCompletedNormally(f, four);
 304     }
 305 
 306     /**
 307      * obtrudeException forces completion with given exception
 308      */
 309     public void testObtrudeException() {
 310         for (Integer v1 : new Integer[] { 1, null })
 311     {
 312         CFException ex;
 313         CompletableFuture&lt;Integer&gt; f;
 314 
 315         f = new CompletableFuture&lt;&gt;();
 316         assertTrue(f.complete(v1));
 317         for (int i = 0; i &lt; 2; i++) {
 318             f.obtrudeException(ex = new CFException());
 319             checkCompletedExceptionally(f, ex);
 320         }
 321 
 322         f = new CompletableFuture&lt;&gt;();
 323         for (int i = 0; i &lt; 2; i++) {
 324             f.obtrudeException(ex = new CFException());
 325             checkCompletedExceptionally(f, ex);
 326         }
 327 
 328         f = new CompletableFuture&lt;&gt;();
 329         f.completeExceptionally(new CFException());
 330         f.obtrudeValue(v1);
 331         checkCompletedNormally(f, v1);
 332         f.obtrudeException(ex = new CFException());
 333         checkCompletedExceptionally(f, ex);
 334         f.completeExceptionally(new CFException());
 335         checkCompletedExceptionally(f, ex);
 336         assertFalse(f.complete(v1));
 337         checkCompletedExceptionally(f, ex);
 338     }}
 339 
 340     /**
 341      * getNumberOfDependents returns number of dependent tasks
 342      */
 343     public void testGetNumberOfDependents() {
 344         for (ExecutionMode m : ExecutionMode.values())
 345         for (Integer v1 : new Integer[] { 1, null })
 346     {
 347         CompletableFuture&lt;Integer&gt; f = new CompletableFuture&lt;&gt;();
 348         assertEquals(0, f.getNumberOfDependents());
 349         final CompletableFuture&lt;Void&gt; g = m.thenRun(f, new Noop(m));
 350         assertEquals(1, f.getNumberOfDependents());
 351         assertEquals(0, g.getNumberOfDependents());
 352         final CompletableFuture&lt;Void&gt; h = m.thenRun(f, new Noop(m));
 353         assertEquals(2, f.getNumberOfDependents());
 354         assertEquals(0, h.getNumberOfDependents());
 355         assertTrue(f.complete(v1));
 356         checkCompletedNormally(g, null);
 357         checkCompletedNormally(h, null);
 358         assertEquals(0, f.getNumberOfDependents());
 359         assertEquals(0, g.getNumberOfDependents());
 360         assertEquals(0, h.getNumberOfDependents());
 361     }}
 362 
 363     /**
 364      * toString indicates current completion state
 365      */
 366     public void testToString_incomplete() {
 367         CompletableFuture&lt;String&gt; f = new CompletableFuture&lt;&gt;();
 368         assertTrue(f.toString().matches(&quot;.*\\[.*Not completed.*\\]&quot;));
 369         if (testImplementationDetails)
 370             assertEquals(identityString(f) + &quot;[Not completed]&quot;,
 371                          f.toString());
 372     }
 373 
 374     public void testToString_normal() {
 375         CompletableFuture&lt;String&gt; f = new CompletableFuture&lt;&gt;();
 376         assertTrue(f.complete(&quot;foo&quot;));
 377         assertTrue(f.toString().matches(&quot;.*\\[.*Completed normally.*\\]&quot;));
 378         if (testImplementationDetails)
 379             assertEquals(identityString(f) + &quot;[Completed normally]&quot;,
 380                          f.toString());
 381     }
 382 
 383     public void testToString_exception() {
 384         CompletableFuture&lt;String&gt; f = new CompletableFuture&lt;&gt;();
 385         assertTrue(f.completeExceptionally(new IndexOutOfBoundsException()));
 386         assertTrue(f.toString().matches(&quot;.*\\[.*Completed exceptionally.*\\]&quot;));
 387         if (testImplementationDetails)
 388             assertTrue(f.toString().startsWith(
 389                                identityString(f) + &quot;[Completed exceptionally: &quot;));
 390     }
 391 
 392     public void testToString_cancelled() {
 393         for (boolean mayInterruptIfRunning : new boolean[] { true, false }) {
 394             CompletableFuture&lt;String&gt; f = new CompletableFuture&lt;&gt;();
 395             assertTrue(f.cancel(mayInterruptIfRunning));
 396             assertTrue(f.toString().matches(&quot;.*\\[.*Completed exceptionally.*\\]&quot;));
 397             if (testImplementationDetails)
 398                 assertTrue(f.toString().startsWith(
 399                                    identityString(f) + &quot;[Completed exceptionally: &quot;));
 400         }
 401     }
 402 
 403     /**
 404      * completedFuture returns a completed CompletableFuture with given value
 405      */
 406     public void testCompletedFuture() {
 407         CompletableFuture&lt;String&gt; f = CompletableFuture.completedFuture(&quot;test&quot;);
 408         checkCompletedNormally(f, &quot;test&quot;);
 409     }
 410 
 411     abstract static class CheckedAction {
 412         int invocationCount = 0;
 413         final ExecutionMode m;
 414         CheckedAction(ExecutionMode m) { this.m = m; }
 415         void invoked() {
 416             m.checkExecutionMode();
 417             assertEquals(0, invocationCount++);
 418         }
 419         void assertNotInvoked() { assertEquals(0, invocationCount); }
 420         void assertInvoked() { assertEquals(1, invocationCount); }
 421     }
 422 
 423     abstract static class CheckedIntegerAction extends CheckedAction {
 424         Integer value;
 425         CheckedIntegerAction(ExecutionMode m) { super(m); }
 426         void assertValue(Integer expected) {
 427             assertInvoked();
 428             assertEquals(expected, value);
 429         }
 430     }
 431 
 432     static class IntegerSupplier extends CheckedAction
 433         implements Supplier&lt;Integer&gt;
 434     {
 435         final Integer value;
 436         IntegerSupplier(ExecutionMode m, Integer value) {
 437             super(m);
 438             this.value = value;
 439         }
 440         public Integer get() {
 441             invoked();
 442             return value;
 443         }
 444     }
 445 
 446     // A function that handles and produces null values as well.
 447     static Integer inc(Integer x) {
 448         return (x == null) ? null : x + 1;
 449     }
 450 
 451     static class NoopConsumer extends CheckedIntegerAction
 452         implements Consumer&lt;Integer&gt;
 453     {
 454         NoopConsumer(ExecutionMode m) { super(m); }
 455         public void accept(Integer x) {
 456             invoked();
 457             value = x;
 458         }
 459     }
 460 
 461     static class IncFunction extends CheckedIntegerAction
 462         implements Function&lt;Integer,Integer&gt;
 463     {
 464         IncFunction(ExecutionMode m) { super(m); }
 465         public Integer apply(Integer x) {
 466             invoked();
 467             return value = inc(x);
 468         }
 469     }
 470 
 471     // Choose non-commutative actions for better coverage
 472     // A non-commutative function that handles and produces null values as well.
 473     static Integer subtract(Integer x, Integer y) {
 474         return (x == null &amp;&amp; y == null) ? null :
 475             ((x == null) ? 42 : x.intValue())
 476             - ((y == null) ? 99 : y.intValue());
 477     }
 478 
 479     static class SubtractAction extends CheckedIntegerAction
 480         implements BiConsumer&lt;Integer, Integer&gt;
 481     {
 482         SubtractAction(ExecutionMode m) { super(m); }
 483         public void accept(Integer x, Integer y) {
 484             invoked();
 485             value = subtract(x, y);
 486         }
 487     }
 488 
 489     static class SubtractFunction extends CheckedIntegerAction
 490         implements BiFunction&lt;Integer, Integer, Integer&gt;
 491     {
 492         SubtractFunction(ExecutionMode m) { super(m); }
 493         public Integer apply(Integer x, Integer y) {
 494             invoked();
 495             return value = subtract(x, y);
 496         }
 497     }
 498 
 499     static class Noop extends CheckedAction implements Runnable {
 500         Noop(ExecutionMode m) { super(m); }
 501         public void run() {
 502             invoked();
 503         }
 504     }
 505 
 506     static class FailingSupplier extends CheckedAction
 507         implements Supplier&lt;Integer&gt;
 508     {
 509         final CFException ex;
 510         FailingSupplier(ExecutionMode m) { super(m); ex = new CFException(); }
 511         public Integer get() {
 512             invoked();
 513             throw ex;
 514         }
 515     }
 516 
 517     static class FailingConsumer extends CheckedIntegerAction
 518         implements Consumer&lt;Integer&gt;
 519     {
 520         final CFException ex;
 521         FailingConsumer(ExecutionMode m) { super(m); ex = new CFException(); }
 522         public void accept(Integer x) {
 523             invoked();
 524             value = x;
 525             throw ex;
 526         }
 527     }
 528 
 529     static class FailingBiConsumer extends CheckedIntegerAction
 530         implements BiConsumer&lt;Integer, Integer&gt;
 531     {
 532         final CFException ex;
 533         FailingBiConsumer(ExecutionMode m) { super(m); ex = new CFException(); }
 534         public void accept(Integer x, Integer y) {
 535             invoked();
 536             value = subtract(x, y);
 537             throw ex;
 538         }
 539     }
 540 
 541     static class FailingFunction extends CheckedIntegerAction
 542         implements Function&lt;Integer, Integer&gt;
 543     {
 544         final CFException ex;
 545         FailingFunction(ExecutionMode m) { super(m); ex = new CFException(); }
 546         public Integer apply(Integer x) {
 547             invoked();
 548             value = x;
 549             throw ex;
 550         }
 551     }
 552 
 553     static class FailingBiFunction extends CheckedIntegerAction
 554         implements BiFunction&lt;Integer, Integer, Integer&gt;
 555     {
 556         final CFException ex;
 557         FailingBiFunction(ExecutionMode m) { super(m); ex = new CFException(); }
 558         public Integer apply(Integer x, Integer y) {
 559             invoked();
 560             value = subtract(x, y);
 561             throw ex;
 562         }
 563     }
 564 
 565     static class FailingRunnable extends CheckedAction implements Runnable {
 566         final CFException ex;
 567         FailingRunnable(ExecutionMode m) { super(m); ex = new CFException(); }
 568         public void run() {
 569             invoked();
 570             throw ex;
 571         }
 572     }
 573 
 574     static class CompletableFutureInc extends CheckedIntegerAction
 575         implements Function&lt;Integer, CompletableFuture&lt;Integer&gt;&gt;
 576     {
 577         CompletableFutureInc(ExecutionMode m) { super(m); }
 578         public CompletableFuture&lt;Integer&gt; apply(Integer x) {
 579             invoked();
 580             value = x;
 581             return CompletableFuture.completedFuture(inc(x));
 582         }
 583     }
 584 
 585     static class FailingExceptionalCompletableFutureFunction extends CheckedAction
 586         implements Function&lt;Throwable, CompletableFuture&lt;Integer&gt;&gt;
 587     {
 588         final CFException ex;
 589         FailingExceptionalCompletableFutureFunction(ExecutionMode m) { super(m); ex = new CFException(); }
 590         public CompletableFuture&lt;Integer&gt; apply(Throwable x) {
 591             invoked();
 592             throw ex;
 593         }
 594     }
 595 
 596     static class ExceptionalCompletableFutureFunction extends CheckedAction
 597         implements Function&lt;Throwable, CompletionStage&lt;Integer&gt;&gt; {
 598         final Integer value = 3;
 599         ExceptionalCompletableFutureFunction(ExecutionMode m) { super(m); }
 600         public CompletionStage&lt;Integer&gt; apply(Throwable x) {
 601             invoked();
 602             return CompletableFuture.completedFuture(value);
 603         }
 604     }
 605 
 606     static class FailingCompletableFutureFunction extends CheckedIntegerAction
 607         implements Function&lt;Integer, CompletableFuture&lt;Integer&gt;&gt;
 608     {
 609         final CFException ex;
 610         FailingCompletableFutureFunction(ExecutionMode m) { super(m); ex = new CFException(); }
 611         public CompletableFuture&lt;Integer&gt; apply(Integer x) {
 612             invoked();
 613             value = x;
 614             throw ex;
 615         }
 616     }
 617 
 618     static class CountingRejectingExecutor implements Executor {
 619         final RejectedExecutionException ex = new RejectedExecutionException();
 620         final AtomicInteger count = new AtomicInteger(0);
 621         public void execute(Runnable r) {
 622             count.getAndIncrement();
 623             throw ex;
 624         }
 625     }
 626 
 627     // Used for explicit executor tests
 628     static final class ThreadExecutor implements Executor {
 629         final AtomicInteger count = new AtomicInteger(0);
 630         static final ThreadGroup tg = new ThreadGroup(&quot;ThreadExecutor&quot;);
 631         static boolean startedCurrentThread() {
 632             return Thread.currentThread().getThreadGroup() == tg;
 633         }
 634 
 635         public void execute(Runnable r) {
 636             count.getAndIncrement();
 637             new Thread(tg, r).start();
 638         }
 639     }
 640 
 641     static final boolean defaultExecutorIsCommonPool
 642         = ForkJoinPool.getCommonPoolParallelism() &gt; 1;
 643 
 644     /**
 645      * Permits the testing of parallel code for the 3 different
 646      * execution modes without copy/pasting all the test methods.
 647      */
 648     enum ExecutionMode {
 649         SYNC {
 650             public void checkExecutionMode() {
 651                 assertFalse(ThreadExecutor.startedCurrentThread());
 652                 assertNull(ForkJoinTask.getPool());
 653             }
 654             public CompletableFuture&lt;Void&gt; runAsync(Runnable a) {
 655                 throw new UnsupportedOperationException();
 656             }
 657             public &lt;U&gt; CompletableFuture&lt;U&gt; supplyAsync(Supplier&lt;U&gt; a) {
 658                 throw new UnsupportedOperationException();
 659             }
 660             public &lt;T&gt; CompletableFuture&lt;Void&gt; thenRun
 661                 (CompletableFuture&lt;T&gt; f, Runnable a) {
 662                 return f.thenRun(a);
 663             }
 664             public &lt;T&gt; CompletableFuture&lt;Void&gt; thenAccept
 665                 (CompletableFuture&lt;T&gt; f, Consumer&lt;? super T&gt; a) {
 666                 return f.thenAccept(a);
 667             }
 668             public &lt;T,U&gt; CompletableFuture&lt;U&gt; thenApply
 669                 (CompletableFuture&lt;T&gt; f, Function&lt;? super T,U&gt; a) {
 670                 return f.thenApply(a);
 671             }
 672             public &lt;T,U&gt; CompletableFuture&lt;U&gt; thenCompose
 673                 (CompletableFuture&lt;T&gt; f,
 674                  Function&lt;? super T,? extends CompletionStage&lt;U&gt;&gt; a) {
 675                 return f.thenCompose(a);
 676             }
 677             public &lt;T,U&gt; CompletableFuture&lt;U&gt; handle
 678                 (CompletableFuture&lt;T&gt; f,
 679                  BiFunction&lt;? super T,Throwable,? extends U&gt; a) {
 680                 return f.handle(a);
 681             }
 682             public &lt;T&gt; CompletableFuture&lt;T&gt; whenComplete
 683                 (CompletableFuture&lt;T&gt; f,
 684                  BiConsumer&lt;? super T,? super Throwable&gt; a) {
 685                 return f.whenComplete(a);
 686             }
 687             public &lt;T,U&gt; CompletableFuture&lt;Void&gt; runAfterBoth
 688                 (CompletableFuture&lt;T&gt; f, CompletableFuture&lt;U&gt; g, Runnable a) {
 689                 return f.runAfterBoth(g, a);
 690             }
 691             public &lt;T,U&gt; CompletableFuture&lt;Void&gt; thenAcceptBoth
 692                 (CompletableFuture&lt;T&gt; f,
 693                  CompletionStage&lt;? extends U&gt; g,
 694                  BiConsumer&lt;? super T,? super U&gt; a) {
 695                 return f.thenAcceptBoth(g, a);
 696             }
 697             public &lt;T,U,V&gt; CompletableFuture&lt;V&gt; thenCombine
 698                 (CompletableFuture&lt;T&gt; f,
 699                  CompletionStage&lt;? extends U&gt; g,
 700                  BiFunction&lt;? super T,? super U,? extends V&gt; a) {
 701                 return f.thenCombine(g, a);
 702             }
 703             public &lt;T&gt; CompletableFuture&lt;Void&gt; runAfterEither
 704                 (CompletableFuture&lt;T&gt; f,
 705                  CompletionStage&lt;?&gt; g,
 706                  java.lang.Runnable a) {
 707                 return f.runAfterEither(g, a);
 708             }
 709             public &lt;T&gt; CompletableFuture&lt;Void&gt; acceptEither
 710                 (CompletableFuture&lt;T&gt; f,
 711                  CompletionStage&lt;? extends T&gt; g,
 712                  Consumer&lt;? super T&gt; a) {
 713                 return f.acceptEither(g, a);
 714             }
 715             public &lt;T,U&gt; CompletableFuture&lt;U&gt; applyToEither
 716                 (CompletableFuture&lt;T&gt; f,
 717                  CompletionStage&lt;? extends T&gt; g,
 718                  Function&lt;? super T,U&gt; a) {
 719                 return f.applyToEither(g, a);
 720             }
 721             public &lt;T&gt; CompletableFuture&lt;T&gt; exceptionally
 722                 (CompletableFuture&lt;T&gt; f,
 723                  Function&lt;Throwable, ? extends T&gt; fn) {
 724                 return f.exceptionally(fn);
 725             }
 726             public &lt;T&gt; CompletableFuture&lt;T&gt; exceptionallyCompose
 727                 (CompletableFuture&lt;T&gt; f, Function&lt;Throwable, ? extends CompletionStage&lt;T&gt;&gt; fn) {
 728                 return f.exceptionallyCompose(fn);
 729             }
 730         },
 731         ASYNC {
 732             public void checkExecutionMode() {
 733                 assertEquals(defaultExecutorIsCommonPool,
 734                              (ForkJoinPool.commonPool() == ForkJoinTask.getPool()));
 735             }
 736             public CompletableFuture&lt;Void&gt; runAsync(Runnable a) {
 737                 return CompletableFuture.runAsync(a);
 738             }
 739             public &lt;U&gt; CompletableFuture&lt;U&gt; supplyAsync(Supplier&lt;U&gt; a) {
 740                 return CompletableFuture.supplyAsync(a);
 741             }
 742             public &lt;T&gt; CompletableFuture&lt;Void&gt; thenRun
 743                 (CompletableFuture&lt;T&gt; f, Runnable a) {
 744                 return f.thenRunAsync(a);
 745             }
 746             public &lt;T&gt; CompletableFuture&lt;Void&gt; thenAccept
 747                 (CompletableFuture&lt;T&gt; f, Consumer&lt;? super T&gt; a) {
 748                 return f.thenAcceptAsync(a);
 749             }
 750             public &lt;T,U&gt; CompletableFuture&lt;U&gt; thenApply
 751                 (CompletableFuture&lt;T&gt; f, Function&lt;? super T,U&gt; a) {
 752                 return f.thenApplyAsync(a);
 753             }
 754             public &lt;T,U&gt; CompletableFuture&lt;U&gt; thenCompose
 755                 (CompletableFuture&lt;T&gt; f,
 756                  Function&lt;? super T,? extends CompletionStage&lt;U&gt;&gt; a) {
 757                 return f.thenComposeAsync(a);
 758             }
 759             public &lt;T,U&gt; CompletableFuture&lt;U&gt; handle
 760                 (CompletableFuture&lt;T&gt; f,
 761                  BiFunction&lt;? super T,Throwable,? extends U&gt; a) {
 762                 return f.handleAsync(a);
 763             }
 764             public &lt;T&gt; CompletableFuture&lt;T&gt; whenComplete
 765                 (CompletableFuture&lt;T&gt; f,
 766                  BiConsumer&lt;? super T,? super Throwable&gt; a) {
 767                 return f.whenCompleteAsync(a);
 768             }
 769             public &lt;T,U&gt; CompletableFuture&lt;Void&gt; runAfterBoth
 770                 (CompletableFuture&lt;T&gt; f, CompletableFuture&lt;U&gt; g, Runnable a) {
 771                 return f.runAfterBothAsync(g, a);
 772             }
 773             public &lt;T,U&gt; CompletableFuture&lt;Void&gt; thenAcceptBoth
 774                 (CompletableFuture&lt;T&gt; f,
 775                  CompletionStage&lt;? extends U&gt; g,
 776                  BiConsumer&lt;? super T,? super U&gt; a) {
 777                 return f.thenAcceptBothAsync(g, a);
 778             }
 779             public &lt;T,U,V&gt; CompletableFuture&lt;V&gt; thenCombine
 780                 (CompletableFuture&lt;T&gt; f,
 781                  CompletionStage&lt;? extends U&gt; g,
 782                  BiFunction&lt;? super T,? super U,? extends V&gt; a) {
 783                 return f.thenCombineAsync(g, a);
 784             }
 785             public &lt;T&gt; CompletableFuture&lt;Void&gt; runAfterEither
 786                 (CompletableFuture&lt;T&gt; f,
 787                  CompletionStage&lt;?&gt; g,
 788                  java.lang.Runnable a) {
 789                 return f.runAfterEitherAsync(g, a);
 790             }
 791             public &lt;T&gt; CompletableFuture&lt;Void&gt; acceptEither
 792                 (CompletableFuture&lt;T&gt; f,
 793                  CompletionStage&lt;? extends T&gt; g,
 794                  Consumer&lt;? super T&gt; a) {
 795                 return f.acceptEitherAsync(g, a);
 796             }
 797             public &lt;T,U&gt; CompletableFuture&lt;U&gt; applyToEither
 798                 (CompletableFuture&lt;T&gt; f,
 799                  CompletionStage&lt;? extends T&gt; g,
 800                  Function&lt;? super T,U&gt; a) {
 801                 return f.applyToEitherAsync(g, a);
 802             }
 803             public &lt;T&gt; CompletableFuture&lt;T&gt; exceptionally
 804                 (CompletableFuture&lt;T&gt; f,
 805                  Function&lt;Throwable, ? extends T&gt; fn) {
 806                 return f.exceptionallyAsync(fn);
 807             }
 808 
 809             public &lt;T&gt; CompletableFuture&lt;T&gt; exceptionallyCompose
 810                 (CompletableFuture&lt;T&gt; f, Function&lt;Throwable, ? extends CompletionStage&lt;T&gt;&gt; fn) {
 811                 return f.exceptionallyComposeAsync(fn);
 812             }
 813 
 814         },
 815 
 816         EXECUTOR {
 817             public void checkExecutionMode() {
 818                 assertTrue(ThreadExecutor.startedCurrentThread());
 819             }
 820             public CompletableFuture&lt;Void&gt; runAsync(Runnable a) {
 821                 return CompletableFuture.runAsync(a, new ThreadExecutor());
 822             }
 823             public &lt;U&gt; CompletableFuture&lt;U&gt; supplyAsync(Supplier&lt;U&gt; a) {
 824                 return CompletableFuture.supplyAsync(a, new ThreadExecutor());
 825             }
 826             public &lt;T&gt; CompletableFuture&lt;Void&gt; thenRun
 827                 (CompletableFuture&lt;T&gt; f, Runnable a) {
 828                 return f.thenRunAsync(a, new ThreadExecutor());
 829             }
 830             public &lt;T&gt; CompletableFuture&lt;Void&gt; thenAccept
 831                 (CompletableFuture&lt;T&gt; f, Consumer&lt;? super T&gt; a) {
 832                 return f.thenAcceptAsync(a, new ThreadExecutor());
 833             }
 834             public &lt;T,U&gt; CompletableFuture&lt;U&gt; thenApply
 835                 (CompletableFuture&lt;T&gt; f, Function&lt;? super T,U&gt; a) {
 836                 return f.thenApplyAsync(a, new ThreadExecutor());
 837             }
 838             public &lt;T,U&gt; CompletableFuture&lt;U&gt; thenCompose
 839                 (CompletableFuture&lt;T&gt; f,
 840                  Function&lt;? super T,? extends CompletionStage&lt;U&gt;&gt; a) {
 841                 return f.thenComposeAsync(a, new ThreadExecutor());
 842             }
 843             public &lt;T,U&gt; CompletableFuture&lt;U&gt; handle
 844                 (CompletableFuture&lt;T&gt; f,
 845                  BiFunction&lt;? super T,Throwable,? extends U&gt; a) {
 846                 return f.handleAsync(a, new ThreadExecutor());
 847             }
 848             public &lt;T&gt; CompletableFuture&lt;T&gt; whenComplete
 849                 (CompletableFuture&lt;T&gt; f,
 850                  BiConsumer&lt;? super T,? super Throwable&gt; a) {
 851                 return f.whenCompleteAsync(a, new ThreadExecutor());
 852             }
 853             public &lt;T,U&gt; CompletableFuture&lt;Void&gt; runAfterBoth
 854                 (CompletableFuture&lt;T&gt; f, CompletableFuture&lt;U&gt; g, Runnable a) {
 855                 return f.runAfterBothAsync(g, a, new ThreadExecutor());
 856             }
 857             public &lt;T,U&gt; CompletableFuture&lt;Void&gt; thenAcceptBoth
 858                 (CompletableFuture&lt;T&gt; f,
 859                  CompletionStage&lt;? extends U&gt; g,
 860                  BiConsumer&lt;? super T,? super U&gt; a) {
 861                 return f.thenAcceptBothAsync(g, a, new ThreadExecutor());
 862             }
 863             public &lt;T,U,V&gt; CompletableFuture&lt;V&gt; thenCombine
 864                 (CompletableFuture&lt;T&gt; f,
 865                  CompletionStage&lt;? extends U&gt; g,
 866                  BiFunction&lt;? super T,? super U,? extends V&gt; a) {
 867                 return f.thenCombineAsync(g, a, new ThreadExecutor());
 868             }
 869             public &lt;T&gt; CompletableFuture&lt;Void&gt; runAfterEither
 870                 (CompletableFuture&lt;T&gt; f,
 871                  CompletionStage&lt;?&gt; g,
 872                  java.lang.Runnable a) {
 873                 return f.runAfterEitherAsync(g, a, new ThreadExecutor());
 874             }
 875             public &lt;T&gt; CompletableFuture&lt;Void&gt; acceptEither
 876                 (CompletableFuture&lt;T&gt; f,
 877                  CompletionStage&lt;? extends T&gt; g,
 878                  Consumer&lt;? super T&gt; a) {
 879                 return f.acceptEitherAsync(g, a, new ThreadExecutor());
 880             }
 881             public &lt;T,U&gt; CompletableFuture&lt;U&gt; applyToEither
 882                 (CompletableFuture&lt;T&gt; f,
 883                  CompletionStage&lt;? extends T&gt; g,
 884                  Function&lt;? super T,U&gt; a) {
 885                 return f.applyToEitherAsync(g, a, new ThreadExecutor());
 886             }
 887             public &lt;T&gt; CompletableFuture&lt;T&gt; exceptionally
 888                 (CompletableFuture&lt;T&gt; f,
 889                  Function&lt;Throwable, ? extends T&gt; fn) {
 890                 return f.exceptionallyAsync(fn, new ThreadExecutor());
 891             }
 892             public &lt;T&gt; CompletableFuture&lt;T&gt; exceptionallyCompose
 893                 (CompletableFuture&lt;T&gt; f, Function&lt;Throwable, ? extends CompletionStage&lt;T&gt;&gt; fn) {
 894                 return f.exceptionallyComposeAsync(fn, new ThreadExecutor());
 895             }
 896 
 897         };
 898 
 899         public abstract void checkExecutionMode();
 900         public abstract CompletableFuture&lt;Void&gt; runAsync(Runnable a);
 901         public abstract &lt;U&gt; CompletableFuture&lt;U&gt; supplyAsync(Supplier&lt;U&gt; a);
 902         public abstract &lt;T&gt; CompletableFuture&lt;Void&gt; thenRun
 903             (CompletableFuture&lt;T&gt; f, Runnable a);
 904         public abstract &lt;T&gt; CompletableFuture&lt;Void&gt; thenAccept
 905             (CompletableFuture&lt;T&gt; f, Consumer&lt;? super T&gt; a);
 906         public abstract &lt;T,U&gt; CompletableFuture&lt;U&gt; thenApply
 907             (CompletableFuture&lt;T&gt; f, Function&lt;? super T,U&gt; a);
 908         public abstract &lt;T,U&gt; CompletableFuture&lt;U&gt; thenCompose
 909             (CompletableFuture&lt;T&gt; f,
 910              Function&lt;? super T,? extends CompletionStage&lt;U&gt;&gt; a);
 911         public abstract &lt;T,U&gt; CompletableFuture&lt;U&gt; handle
 912             (CompletableFuture&lt;T&gt; f,
 913              BiFunction&lt;? super T,Throwable,? extends U&gt; a);
 914         public abstract &lt;T&gt; CompletableFuture&lt;T&gt; whenComplete
 915             (CompletableFuture&lt;T&gt; f,
 916              BiConsumer&lt;? super T,? super Throwable&gt; a);
 917         public abstract &lt;T,U&gt; CompletableFuture&lt;Void&gt; runAfterBoth
 918             (CompletableFuture&lt;T&gt; f, CompletableFuture&lt;U&gt; g, Runnable a);
 919         public abstract &lt;T,U&gt; CompletableFuture&lt;Void&gt; thenAcceptBoth
 920             (CompletableFuture&lt;T&gt; f,
 921              CompletionStage&lt;? extends U&gt; g,
 922              BiConsumer&lt;? super T,? super U&gt; a);
 923         public abstract &lt;T,U,V&gt; CompletableFuture&lt;V&gt; thenCombine
 924             (CompletableFuture&lt;T&gt; f,
 925              CompletionStage&lt;? extends U&gt; g,
 926              BiFunction&lt;? super T,? super U,? extends V&gt; a);
 927         public abstract &lt;T&gt; CompletableFuture&lt;Void&gt; runAfterEither
 928             (CompletableFuture&lt;T&gt; f,
 929              CompletionStage&lt;?&gt; g,
 930              java.lang.Runnable a);
 931         public abstract &lt;T&gt; CompletableFuture&lt;Void&gt; acceptEither
 932             (CompletableFuture&lt;T&gt; f,
 933              CompletionStage&lt;? extends T&gt; g,
 934              Consumer&lt;? super T&gt; a);
 935         public abstract &lt;T,U&gt; CompletableFuture&lt;U&gt; applyToEither
 936             (CompletableFuture&lt;T&gt; f,
 937              CompletionStage&lt;? extends T&gt; g,
 938              Function&lt;? super T,U&gt; a);
 939         public abstract &lt;T&gt; CompletableFuture&lt;T&gt; exceptionally
 940             (CompletableFuture&lt;T&gt; f,
 941              Function&lt;Throwable, ? extends T&gt; fn);
 942         public abstract &lt;T&gt; CompletableFuture&lt;T&gt; exceptionallyCompose
 943             (CompletableFuture&lt;T&gt; f,
 944              Function&lt;Throwable, ? extends CompletionStage&lt;T&gt;&gt; fn);
 945     }
 946 
 947     /**
 948      * exceptionally action is not invoked when source completes
 949      * normally, and source result is propagated
 950      */
 951     public void testExceptionally_normalCompletion() {
 952         for (ExecutionMode m : ExecutionMode.values())
 953         for (boolean createIncomplete : new boolean[] { true, false })
 954         for (Integer v1 : new Integer[] { 1, null })
 955     {
 956         final AtomicInteger ran = new AtomicInteger(0);
 957         final CompletableFuture&lt;Integer&gt; f = new CompletableFuture&lt;&gt;();
 958         if (!createIncomplete) assertTrue(f.complete(v1));
 959         final CompletableFuture&lt;Integer&gt; g = m.exceptionally
 960             (f, (Throwable t) -&gt; {
 961                 ran.getAndIncrement();
 962                 throw new AssertionError(&quot;should not be called&quot;);
 963             });
 964         if (createIncomplete) assertTrue(f.complete(v1));
 965 
 966         checkCompletedNormally(g, v1);
 967         checkCompletedNormally(f, v1);
 968         assertEquals(0, ran.get());
 969     }}
 970 
 971     /**
 972      * exceptionally action completes with function value on source
 973      * exception
 974      */
 975     public void testExceptionally_exceptionalCompletion() {
 976         for (ExecutionMode m : ExecutionMode.values())
 977         for (boolean createIncomplete : new boolean[] { true, false })
 978         for (Integer v1 : new Integer[] { 1, null })
 979     {
 980         final AtomicInteger ran = new AtomicInteger(0);
 981         final CFException ex = new CFException();
 982         final CompletableFuture&lt;Integer&gt; f = new CompletableFuture&lt;&gt;();
 983         if (!createIncomplete) f.completeExceptionally(ex);
 984         final CompletableFuture&lt;Integer&gt; g = m.exceptionally
 985             (f, (Throwable t) -&gt; {
 986                 m.checkExecutionMode();
 987                 assertSame(t, ex);
 988                 ran.getAndIncrement();
 989                 return v1;
 990             });
 991         if (createIncomplete) f.completeExceptionally(ex);
 992 
 993         checkCompletedNormally(g, v1);
 994         assertEquals(1, ran.get());
 995     }}
 996 
 997     /**
 998      * If an &quot;exceptionally action&quot; throws an exception, it completes
 999      * exceptionally with that exception
1000      */
1001     public void testExceptionally_exceptionalCompletionActionFailed() {
1002         for (ExecutionMode m : ExecutionMode.values())
1003         for (boolean createIncomplete : new boolean[] { true, false })
1004     {
1005         final AtomicInteger ran = new AtomicInteger(0);
1006         final CFException ex1 = new CFException();
1007         final CFException ex2 = new CFException();
1008         final CompletableFuture&lt;Integer&gt; f = new CompletableFuture&lt;&gt;();
1009         if (!createIncomplete) f.completeExceptionally(ex1);
1010         final CompletableFuture&lt;Integer&gt; g = m.exceptionally
1011             (f, (Throwable t) -&gt; {
1012                 m.checkExecutionMode();
1013                 assertSame(t, ex1);
1014                 ran.getAndIncrement();
1015                 throw ex2;
1016             });
1017         if (createIncomplete) f.completeExceptionally(ex1);
1018 
1019         checkCompletedWithWrappedException(g, ex2);
1020         checkCompletedExceptionally(f, ex1);
1021         assertEquals(1, ran.get());
1022     }}
1023 
1024     /**
1025      * whenComplete action executes on normal completion, propagating
1026      * source result.
1027      */
1028     public void testWhenComplete_normalCompletion() {
1029         for (ExecutionMode m : ExecutionMode.values())
1030         for (boolean createIncomplete : new boolean[] { true, false })
1031         for (Integer v1 : new Integer[] { 1, null })
1032     {
1033         final AtomicInteger ran = new AtomicInteger(0);
1034         final CompletableFuture&lt;Integer&gt; f = new CompletableFuture&lt;&gt;();
1035         if (!createIncomplete) assertTrue(f.complete(v1));
1036         final CompletableFuture&lt;Integer&gt; g = m.whenComplete
1037             (f,
1038              (Integer result, Throwable t) -&gt; {
1039                 m.checkExecutionMode();
1040                 assertSame(result, v1);
1041                 assertNull(t);
1042                 ran.getAndIncrement();
1043             });
1044         if (createIncomplete) assertTrue(f.complete(v1));
1045 
1046         checkCompletedNormally(g, v1);
1047         checkCompletedNormally(f, v1);
1048         assertEquals(1, ran.get());
1049     }}
1050 
1051     /**
1052      * whenComplete action executes on exceptional completion, propagating
1053      * source result.
1054      */
1055     public void testWhenComplete_exceptionalCompletion() {
1056         for (ExecutionMode m : ExecutionMode.values())
1057         for (boolean createIncomplete : new boolean[] { true, false })
1058     {
1059         final AtomicInteger ran = new AtomicInteger(0);
1060         final CFException ex = new CFException();
1061         final CompletableFuture&lt;Integer&gt; f = new CompletableFuture&lt;&gt;();
1062         if (!createIncomplete) f.completeExceptionally(ex);
1063         final CompletableFuture&lt;Integer&gt; g = m.whenComplete
1064             (f,
1065              (Integer result, Throwable t) -&gt; {
1066                 m.checkExecutionMode();
1067                 assertNull(result);
1068                 assertSame(t, ex);
1069                 ran.getAndIncrement();
1070             });
1071         if (createIncomplete) f.completeExceptionally(ex);
1072 
1073         checkCompletedWithWrappedException(g, ex);
1074         checkCompletedExceptionally(f, ex);
1075         assertEquals(1, ran.get());
1076     }}
1077 
1078     /**
1079      * whenComplete action executes on cancelled source, propagating
1080      * CancellationException.
1081      */
1082     public void testWhenComplete_sourceCancelled() {
1083         for (ExecutionMode m : ExecutionMode.values())
1084         for (boolean mayInterruptIfRunning : new boolean[] { true, false })
1085         for (boolean createIncomplete : new boolean[] { true, false })
1086     {
1087         final AtomicInteger ran = new AtomicInteger(0);
1088         final CompletableFuture&lt;Integer&gt; f = new CompletableFuture&lt;&gt;();
1089         if (!createIncomplete) assertTrue(f.cancel(mayInterruptIfRunning));
1090         final CompletableFuture&lt;Integer&gt; g = m.whenComplete
1091             (f,
1092              (Integer result, Throwable t) -&gt; {
1093                 m.checkExecutionMode();
1094                 assertNull(result);
1095                 assertTrue(t instanceof CancellationException);
1096                 ran.getAndIncrement();
1097             });
1098         if (createIncomplete) assertTrue(f.cancel(mayInterruptIfRunning));
1099 
1100         checkCompletedWithWrappedCancellationException(g);
1101         checkCancelled(f);
1102         assertEquals(1, ran.get());
1103     }}
1104 
1105     /**
1106      * If a whenComplete action throws an exception when triggered by
1107      * a normal completion, it completes exceptionally
1108      */
1109     public void testWhenComplete_sourceCompletedNormallyActionFailed() {
1110         for (boolean createIncomplete : new boolean[] { true, false })
1111         for (ExecutionMode m : ExecutionMode.values())
1112         for (Integer v1 : new Integer[] { 1, null })
1113     {
1114         final AtomicInteger ran = new AtomicInteger(0);
1115         final CFException ex = new CFException();
1116         final CompletableFuture&lt;Integer&gt; f = new CompletableFuture&lt;&gt;();
1117         if (!createIncomplete) assertTrue(f.complete(v1));
1118         final CompletableFuture&lt;Integer&gt; g = m.whenComplete
1119             (f,
1120              (Integer result, Throwable t) -&gt; {
1121                 m.checkExecutionMode();
1122                 assertSame(result, v1);
1123                 assertNull(t);
1124                 ran.getAndIncrement();
1125                 throw ex;
1126             });
1127         if (createIncomplete) assertTrue(f.complete(v1));
1128 
1129         checkCompletedWithWrappedException(g, ex);
1130         checkCompletedNormally(f, v1);
1131         assertEquals(1, ran.get());
1132     }}
1133 
1134     /**
1135      * If a whenComplete action throws an exception when triggered by
1136      * a source completion that also throws an exception, the source
1137      * exception takes precedence (unlike handle)
1138      */
1139     public void testWhenComplete_sourceFailedActionFailed() {
1140         for (boolean createIncomplete : new boolean[] { true, false })
1141         for (ExecutionMode m : ExecutionMode.values())
1142     {
1143         final AtomicInteger ran = new AtomicInteger(0);
1144         final CFException ex1 = new CFException();
1145         final CFException ex2 = new CFException();
1146         final CompletableFuture&lt;Integer&gt; f = new CompletableFuture&lt;&gt;();
1147 
1148         if (!createIncomplete) f.completeExceptionally(ex1);
1149         final CompletableFuture&lt;Integer&gt; g = m.whenComplete
1150             (f,
1151              (Integer result, Throwable t) -&gt; {
1152                 m.checkExecutionMode();
1153                 assertSame(t, ex1);
1154                 assertNull(result);
1155                 ran.getAndIncrement();
1156                 throw ex2;
1157             });
1158         if (createIncomplete) f.completeExceptionally(ex1);
1159 
1160         checkCompletedWithWrappedException(g, ex1);
1161         checkCompletedExceptionally(f, ex1);
1162         if (testImplementationDetails) {
1163             assertEquals(1, ex1.getSuppressed().length);
1164             assertSame(ex2, ex1.getSuppressed()[0]);
1165         }
1166         assertEquals(1, ran.get());
1167     }}
1168 
1169     /**
1170      * handle action completes normally with function value on normal
1171      * completion of source
1172      */
1173     public void testHandle_normalCompletion() {
1174         for (ExecutionMode m : ExecutionMode.values())
1175         for (boolean createIncomplete : new boolean[] { true, false })
1176         for (Integer v1 : new Integer[] { 1, null })
1177     {
1178         final CompletableFuture&lt;Integer&gt; f = new CompletableFuture&lt;&gt;();
1179         final AtomicInteger ran = new AtomicInteger(0);
1180         if (!createIncomplete) assertTrue(f.complete(v1));
1181         final CompletableFuture&lt;Integer&gt; g = m.handle
1182             (f,
1183              (Integer result, Throwable t) -&gt; {
1184                 m.checkExecutionMode();
1185                 assertSame(result, v1);
1186                 assertNull(t);
1187                 ran.getAndIncrement();
1188                 return inc(v1);
1189             });
1190         if (createIncomplete) assertTrue(f.complete(v1));
1191 
1192         checkCompletedNormally(g, inc(v1));
1193         checkCompletedNormally(f, v1);
1194         assertEquals(1, ran.get());
1195     }}
1196 
1197     /**
1198      * handle action completes normally with function value on
1199      * exceptional completion of source
1200      */
1201     public void testHandle_exceptionalCompletion() {
1202         for (ExecutionMode m : ExecutionMode.values())
1203         for (boolean createIncomplete : new boolean[] { true, false })
1204         for (Integer v1 : new Integer[] { 1, null })
1205     {
1206         final CompletableFuture&lt;Integer&gt; f = new CompletableFuture&lt;&gt;();
1207         final AtomicInteger ran = new AtomicInteger(0);
1208         final CFException ex = new CFException();
1209         if (!createIncomplete) f.completeExceptionally(ex);
1210         final CompletableFuture&lt;Integer&gt; g = m.handle
1211             (f,
1212              (Integer result, Throwable t) -&gt; {
1213                 m.checkExecutionMode();
1214                 assertNull(result);
1215                 assertSame(t, ex);
1216                 ran.getAndIncrement();
1217                 return v1;
1218             });
1219         if (createIncomplete) f.completeExceptionally(ex);
1220 
1221         checkCompletedNormally(g, v1);
1222         checkCompletedExceptionally(f, ex);
1223         assertEquals(1, ran.get());
1224     }}
1225 
1226     /**
1227      * handle action completes normally with function value on
1228      * cancelled source
1229      */
1230     public void testHandle_sourceCancelled() {
1231         for (ExecutionMode m : ExecutionMode.values())
1232         for (boolean mayInterruptIfRunning : new boolean[] { true, false })
1233         for (boolean createIncomplete : new boolean[] { true, false })
1234         for (Integer v1 : new Integer[] { 1, null })
1235     {
1236         final CompletableFuture&lt;Integer&gt; f = new CompletableFuture&lt;&gt;();
1237         final AtomicInteger ran = new AtomicInteger(0);
1238         if (!createIncomplete) assertTrue(f.cancel(mayInterruptIfRunning));
1239         final CompletableFuture&lt;Integer&gt; g = m.handle
1240             (f,
1241              (Integer result, Throwable t) -&gt; {
1242                 m.checkExecutionMode();
1243                 assertNull(result);
1244                 assertTrue(t instanceof CancellationException);
1245                 ran.getAndIncrement();
1246                 return v1;
1247             });
1248         if (createIncomplete) assertTrue(f.cancel(mayInterruptIfRunning));
1249 
1250         checkCompletedNormally(g, v1);
1251         checkCancelled(f);
1252         assertEquals(1, ran.get());
1253     }}
1254 
1255     /**
1256      * If a &quot;handle action&quot; throws an exception when triggered by
1257      * a normal completion, it completes exceptionally
1258      */
1259     public void testHandle_sourceCompletedNormallyActionFailed() {
1260         for (ExecutionMode m : ExecutionMode.values())
1261         for (boolean createIncomplete : new boolean[] { true, false })
1262         for (Integer v1 : new Integer[] { 1, null })
1263     {
1264         final CompletableFuture&lt;Integer&gt; f = new CompletableFuture&lt;&gt;();
1265         final AtomicInteger ran = new AtomicInteger(0);
1266         final CFException ex = new CFException();
1267         if (!createIncomplete) assertTrue(f.complete(v1));
1268         final CompletableFuture&lt;Integer&gt; g = m.handle
1269             (f,
1270              (Integer result, Throwable t) -&gt; {
1271                 m.checkExecutionMode();
1272                 assertSame(result, v1);
1273                 assertNull(t);
1274                 ran.getAndIncrement();
1275                 throw ex;
1276             });
1277         if (createIncomplete) assertTrue(f.complete(v1));
1278 
1279         checkCompletedWithWrappedException(g, ex);
1280         checkCompletedNormally(f, v1);
1281         assertEquals(1, ran.get());
1282     }}
1283 
1284     /**
1285      * If a &quot;handle action&quot; throws an exception when triggered by
1286      * a source completion that also throws an exception, the action
1287      * exception takes precedence (unlike whenComplete)
1288      */
1289     public void testHandle_sourceFailedActionFailed() {
1290         for (boolean createIncomplete : new boolean[] { true, false })
1291         for (ExecutionMode m : ExecutionMode.values())
1292     {
1293         final AtomicInteger ran = new AtomicInteger(0);
1294         final CFException ex1 = new CFException();
1295         final CFException ex2 = new CFException();
1296         final CompletableFuture&lt;Integer&gt; f = new CompletableFuture&lt;&gt;();
1297 
1298         if (!createIncomplete) f.completeExceptionally(ex1);
1299         final CompletableFuture&lt;Integer&gt; g = m.handle
1300             (f,
1301              (Integer result, Throwable t) -&gt; {
1302                 m.checkExecutionMode();
1303                 assertNull(result);
1304                 assertSame(ex1, t);
1305                 ran.getAndIncrement();
1306                 throw ex2;
1307             });
1308         if (createIncomplete) f.completeExceptionally(ex1);
1309 
1310         checkCompletedWithWrappedException(g, ex2);
1311         checkCompletedExceptionally(f, ex1);
1312         assertEquals(1, ran.get());
1313     }}
1314 
1315     /**
1316      * runAsync completes after running Runnable
1317      */
1318     public void testRunAsync_normalCompletion() {
1319         ExecutionMode[] executionModes = {
1320             ExecutionMode.ASYNC,
1321             ExecutionMode.EXECUTOR,
1322         };
1323         for (ExecutionMode m : executionModes)
1324     {
1325         final Noop r = new Noop(m);
1326         final CompletableFuture&lt;Void&gt; f = m.runAsync(r);
1327         assertNull(f.join());
1328         checkCompletedNormally(f, null);
1329         r.assertInvoked();
1330     }}
1331 
1332     /**
1333      * failing runAsync completes exceptionally after running Runnable
1334      */
1335     public void testRunAsync_exceptionalCompletion() {
1336         ExecutionMode[] executionModes = {
1337             ExecutionMode.ASYNC,
1338             ExecutionMode.EXECUTOR,
1339         };
1340         for (ExecutionMode m : executionModes)
1341     {
1342         final FailingRunnable r = new FailingRunnable(m);
1343         final CompletableFuture&lt;Void&gt; f = m.runAsync(r);
1344         checkCompletedWithWrappedException(f, r.ex);
1345         r.assertInvoked();
1346     }}
1347 
1348     @SuppressWarnings(&quot;FutureReturnValueIgnored&quot;)
1349     public void testRunAsync_rejectingExecutor() {
1350         CountingRejectingExecutor e = new CountingRejectingExecutor();
1351         try {
1352             CompletableFuture.runAsync(() -&gt; {}, e);
1353             shouldThrow();
1354         } catch (Throwable t) {
1355             assertSame(e.ex, t);
1356         }
1357 
1358         assertEquals(1, e.count.get());
1359     }
1360 
1361     /**
1362      * supplyAsync completes with result of supplier
1363      */
1364     public void testSupplyAsync_normalCompletion() {
1365         ExecutionMode[] executionModes = {
1366             ExecutionMode.ASYNC,
1367             ExecutionMode.EXECUTOR,
1368         };
1369         for (ExecutionMode m : executionModes)
1370         for (Integer v1 : new Integer[] { 1, null })
1371     {
1372         final IntegerSupplier r = new IntegerSupplier(m, v1);
1373         final CompletableFuture&lt;Integer&gt; f = m.supplyAsync(r);
1374         assertSame(v1, f.join());
1375         checkCompletedNormally(f, v1);
1376         r.assertInvoked();
1377     }}
1378 
1379     /**
1380      * Failing supplyAsync completes exceptionally
1381      */
1382     public void testSupplyAsync_exceptionalCompletion() {
1383         ExecutionMode[] executionModes = {
1384             ExecutionMode.ASYNC,
1385             ExecutionMode.EXECUTOR,
1386         };
1387         for (ExecutionMode m : executionModes)
1388     {
1389         FailingSupplier r = new FailingSupplier(m);
1390         CompletableFuture&lt;Integer&gt; f = m.supplyAsync(r);
1391         checkCompletedWithWrappedException(f, r.ex);
1392         r.assertInvoked();
1393     }}
1394 
1395     @SuppressWarnings(&quot;FutureReturnValueIgnored&quot;)
1396     public void testSupplyAsync_rejectingExecutor() {
1397         CountingRejectingExecutor e = new CountingRejectingExecutor();
1398         try {
1399             CompletableFuture.supplyAsync(() -&gt; null, e);
1400             shouldThrow();
1401         } catch (Throwable t) {
1402             assertSame(e.ex, t);
1403         }
1404 
1405         assertEquals(1, e.count.get());
1406     }
1407 
1408     // seq completion methods
1409 
1410     /**
1411      * thenRun result completes normally after normal completion of source
1412      */
1413     public void testThenRun_normalCompletion() {
1414         for (ExecutionMode m : ExecutionMode.values())
1415         for (Integer v1 : new Integer[] { 1, null })
1416     {
1417         final CompletableFuture&lt;Integer&gt; f = new CompletableFuture&lt;&gt;();
1418         final Noop[] rs = new Noop[6];
1419         for (int i = 0; i &lt; rs.length; i++) rs[i] = new Noop(m);
1420 
1421         final CompletableFuture&lt;Void&gt; h0 = m.thenRun(f, rs[0]);
1422         final CompletableFuture&lt;Void&gt; h1 = m.runAfterBoth(f, f, rs[1]);
1423         final CompletableFuture&lt;Void&gt; h2 = m.runAfterEither(f, f, rs[2]);
1424         checkIncomplete(h0);
1425         checkIncomplete(h1);
1426         checkIncomplete(h2);
1427         assertTrue(f.complete(v1));
1428         final CompletableFuture&lt;Void&gt; h3 = m.thenRun(f, rs[3]);
1429         final CompletableFuture&lt;Void&gt; h4 = m.runAfterBoth(f, f, rs[4]);
1430         final CompletableFuture&lt;Void&gt; h5 = m.runAfterEither(f, f, rs[5]);
1431 
1432         checkCompletedNormally(h0, null);
1433         checkCompletedNormally(h1, null);
1434         checkCompletedNormally(h2, null);
1435         checkCompletedNormally(h3, null);
1436         checkCompletedNormally(h4, null);
1437         checkCompletedNormally(h5, null);
1438         checkCompletedNormally(f, v1);
1439         for (Noop r : rs) r.assertInvoked();
1440     }}
1441 
1442     /**
1443      * thenRun result completes exceptionally after exceptional
1444      * completion of source
1445      */
1446     public void testThenRun_exceptionalCompletion() {
1447         for (ExecutionMode m : ExecutionMode.values())
1448     {
1449         final CFException ex = new CFException();
1450         final CompletableFuture&lt;Integer&gt; f = new CompletableFuture&lt;&gt;();
1451         final Noop[] rs = new Noop[6];
1452         for (int i = 0; i &lt; rs.length; i++) rs[i] = new Noop(m);
1453 
1454         final CompletableFuture&lt;Void&gt; h0 = m.thenRun(f, rs[0]);
1455         final CompletableFuture&lt;Void&gt; h1 = m.runAfterBoth(f, f, rs[1]);
1456         final CompletableFuture&lt;Void&gt; h2 = m.runAfterEither(f, f, rs[2]);
1457         checkIncomplete(h0);
1458         checkIncomplete(h1);
1459         checkIncomplete(h2);
1460         assertTrue(f.completeExceptionally(ex));
1461         final CompletableFuture&lt;Void&gt; h3 = m.thenRun(f, rs[3]);
1462         final CompletableFuture&lt;Void&gt; h4 = m.runAfterBoth(f, f, rs[4]);
1463         final CompletableFuture&lt;Void&gt; h5 = m.runAfterEither(f, f, rs[5]);
1464 
1465         checkCompletedWithWrappedException(h0, ex);
1466         checkCompletedWithWrappedException(h1, ex);
1467         checkCompletedWithWrappedException(h2, ex);
1468         checkCompletedWithWrappedException(h3, ex);
1469         checkCompletedWithWrappedException(h4, ex);
1470         checkCompletedWithWrappedException(h5, ex);
1471         checkCompletedExceptionally(f, ex);
1472         for (Noop r : rs) r.assertNotInvoked();
1473     }}
1474 
1475     /**
1476      * thenRun result completes exceptionally if source cancelled
1477      */
1478     public void testThenRun_sourceCancelled() {
1479         for (ExecutionMode m : ExecutionMode.values())
1480         for (boolean mayInterruptIfRunning : new boolean[] { true, false })
1481     {
1482         final CompletableFuture&lt;Integer&gt; f = new CompletableFuture&lt;&gt;();
1483         final Noop[] rs = new Noop[6];
1484         for (int i = 0; i &lt; rs.length; i++) rs[i] = new Noop(m);
1485 
1486         final CompletableFuture&lt;Void&gt; h0 = m.thenRun(f, rs[0]);
1487         final CompletableFuture&lt;Void&gt; h1 = m.runAfterBoth(f, f, rs[1]);
1488         final CompletableFuture&lt;Void&gt; h2 = m.runAfterEither(f, f, rs[2]);
1489         checkIncomplete(h0);
1490         checkIncomplete(h1);
1491         checkIncomplete(h2);
1492         assertTrue(f.cancel(mayInterruptIfRunning));
1493         final CompletableFuture&lt;Void&gt; h3 = m.thenRun(f, rs[3]);
1494         final CompletableFuture&lt;Void&gt; h4 = m.runAfterBoth(f, f, rs[4]);
1495         final CompletableFuture&lt;Void&gt; h5 = m.runAfterEither(f, f, rs[5]);
1496 
1497         checkCompletedWithWrappedCancellationException(h0);
1498         checkCompletedWithWrappedCancellationException(h1);
1499         checkCompletedWithWrappedCancellationException(h2);
1500         checkCompletedWithWrappedCancellationException(h3);
1501         checkCompletedWithWrappedCancellationException(h4);
1502         checkCompletedWithWrappedCancellationException(h5);
1503         checkCancelled(f);
1504         for (Noop r : rs) r.assertNotInvoked();
1505     }}
1506 
1507     /**
1508      * thenRun result completes exceptionally if action does
1509      */
1510     public void testThenRun_actionFailed() {
1511         for (ExecutionMode m : ExecutionMode.values())
1512         for (Integer v1 : new Integer[] { 1, null })
1513     {
1514         final CompletableFuture&lt;Integer&gt; f = new CompletableFuture&lt;&gt;();
1515         final FailingRunnable[] rs = new FailingRunnable[6];
1516         for (int i = 0; i &lt; rs.length; i++) rs[i] = new FailingRunnable(m);
1517 
1518         final CompletableFuture&lt;Void&gt; h0 = m.thenRun(f, rs[0]);
1519         final CompletableFuture&lt;Void&gt; h1 = m.runAfterBoth(f, f, rs[1]);
1520         final CompletableFuture&lt;Void&gt; h2 = m.runAfterEither(f, f, rs[2]);
1521         assertTrue(f.complete(v1));
1522         final CompletableFuture&lt;Void&gt; h3 = m.thenRun(f, rs[3]);
1523         final CompletableFuture&lt;Void&gt; h4 = m.runAfterBoth(f, f, rs[4]);
1524         final CompletableFuture&lt;Void&gt; h5 = m.runAfterEither(f, f, rs[5]);
1525 
1526         checkCompletedWithWrappedException(h0, rs[0].ex);
1527         checkCompletedWithWrappedException(h1, rs[1].ex);
1528         checkCompletedWithWrappedException(h2, rs[2].ex);
1529         checkCompletedWithWrappedException(h3, rs[3].ex);
1530         checkCompletedWithWrappedException(h4, rs[4].ex);
1531         checkCompletedWithWrappedException(h5, rs[5].ex);
1532         checkCompletedNormally(f, v1);
1533     }}
1534 
1535     /**
1536      * thenApply result completes normally after normal completion of source
1537      */
1538     public void testThenApply_normalCompletion() {
1539         for (ExecutionMode m : ExecutionMode.values())
1540         for (Integer v1 : new Integer[] { 1, null })
1541     {
1542         final CompletableFuture&lt;Integer&gt; f = new CompletableFuture&lt;&gt;();
1543         final IncFunction[] rs = new IncFunction[4];
1544         for (int i = 0; i &lt; rs.length; i++) rs[i] = new IncFunction(m);
1545 
1546         final CompletableFuture&lt;Integer&gt; h0 = m.thenApply(f, rs[0]);
1547         final CompletableFuture&lt;Integer&gt; h1 = m.applyToEither(f, f, rs[1]);
1548         checkIncomplete(h0);
1549         checkIncomplete(h1);
1550         assertTrue(f.complete(v1));
1551         final CompletableFuture&lt;Integer&gt; h2 = m.thenApply(f, rs[2]);
1552         final CompletableFuture&lt;Integer&gt; h3 = m.applyToEither(f, f, rs[3]);
1553 
1554         checkCompletedNormally(h0, inc(v1));
1555         checkCompletedNormally(h1, inc(v1));
1556         checkCompletedNormally(h2, inc(v1));
1557         checkCompletedNormally(h3, inc(v1));
1558         checkCompletedNormally(f, v1);
1559         for (IncFunction r : rs) r.assertValue(inc(v1));
1560     }}
1561 
1562     /**
1563      * thenApply result completes exceptionally after exceptional
1564      * completion of source
1565      */
1566     public void testThenApply_exceptionalCompletion() {
1567         for (ExecutionMode m : ExecutionMode.values())
1568     {
1569         final CFException ex = new CFException();
1570         final CompletableFuture&lt;Integer&gt; f = new CompletableFuture&lt;&gt;();
1571         final IncFunction[] rs = new IncFunction[4];
1572         for (int i = 0; i &lt; rs.length; i++) rs[i] = new IncFunction(m);
1573 
1574         final CompletableFuture&lt;Integer&gt; h0 = m.thenApply(f, rs[0]);
1575         final CompletableFuture&lt;Integer&gt; h1 = m.applyToEither(f, f, rs[1]);
1576         assertTrue(f.completeExceptionally(ex));
1577         final CompletableFuture&lt;Integer&gt; h2 = m.thenApply(f, rs[2]);
1578         final CompletableFuture&lt;Integer&gt; h3 = m.applyToEither(f, f, rs[3]);
1579 
1580         checkCompletedWithWrappedException(h0, ex);
1581         checkCompletedWithWrappedException(h1, ex);
1582         checkCompletedWithWrappedException(h2, ex);
1583         checkCompletedWithWrappedException(h3, ex);
1584         checkCompletedExceptionally(f, ex);
1585         for (IncFunction r : rs) r.assertNotInvoked();
1586     }}
1587 
1588     /**
1589      * thenApply result completes exceptionally if source cancelled
1590      */
1591     public void testThenApply_sourceCancelled() {
1592         for (ExecutionMode m : ExecutionMode.values())
1593         for (boolean mayInterruptIfRunning : new boolean[] { true, false })
1594     {
1595         final CompletableFuture&lt;Integer&gt; f = new CompletableFuture&lt;&gt;();
1596         final IncFunction[] rs = new IncFunction[4];
1597         for (int i = 0; i &lt; rs.length; i++) rs[i] = new IncFunction(m);
1598 
1599         final CompletableFuture&lt;Integer&gt; h0 = m.thenApply(f, rs[0]);
1600         final CompletableFuture&lt;Integer&gt; h1 = m.applyToEither(f, f, rs[1]);
1601         assertTrue(f.cancel(mayInterruptIfRunning));
1602         final CompletableFuture&lt;Integer&gt; h2 = m.thenApply(f, rs[2]);
1603         final CompletableFuture&lt;Integer&gt; h3 = m.applyToEither(f, f, rs[3]);
1604 
1605         checkCompletedWithWrappedCancellationException(h0);
1606         checkCompletedWithWrappedCancellationException(h1);
1607         checkCompletedWithWrappedCancellationException(h2);
1608         checkCompletedWithWrappedCancellationException(h3);
1609         checkCancelled(f);
1610         for (IncFunction r : rs) r.assertNotInvoked();
1611     }}
1612 
1613     /**
1614      * thenApply result completes exceptionally if action does
1615      */
1616     public void testThenApply_actionFailed() {
1617         for (ExecutionMode m : ExecutionMode.values())
1618         for (Integer v1 : new Integer[] { 1, null })
1619     {
1620         final CompletableFuture&lt;Integer&gt; f = new CompletableFuture&lt;&gt;();
1621         final FailingFunction[] rs = new FailingFunction[4];
1622         for (int i = 0; i &lt; rs.length; i++) rs[i] = new FailingFunction(m);
1623 
1624         final CompletableFuture&lt;Integer&gt; h0 = m.thenApply(f, rs[0]);
1625         final CompletableFuture&lt;Integer&gt; h1 = m.applyToEither(f, f, rs[1]);
1626         assertTrue(f.complete(v1));
1627         final CompletableFuture&lt;Integer&gt; h2 = m.thenApply(f, rs[2]);
1628         final CompletableFuture&lt;Integer&gt; h3 = m.applyToEither(f, f, rs[3]);
1629 
1630         checkCompletedWithWrappedException(h0, rs[0].ex);
1631         checkCompletedWithWrappedException(h1, rs[1].ex);
1632         checkCompletedWithWrappedException(h2, rs[2].ex);
1633         checkCompletedWithWrappedException(h3, rs[3].ex);
1634         checkCompletedNormally(f, v1);
1635     }}
1636 
1637     /**
1638      * thenAccept result completes normally after normal completion of source
1639      */
1640     public void testThenAccept_normalCompletion() {
1641         for (ExecutionMode m : ExecutionMode.values())
1642         for (Integer v1 : new Integer[] { 1, null })
1643     {
1644         final CompletableFuture&lt;Integer&gt; f = new CompletableFuture&lt;&gt;();
1645         final NoopConsumer[] rs = new NoopConsumer[4];
1646         for (int i = 0; i &lt; rs.length; i++) rs[i] = new NoopConsumer(m);
1647 
1648         final CompletableFuture&lt;Void&gt; h0 = m.thenAccept(f, rs[0]);
1649         final CompletableFuture&lt;Void&gt; h1 = m.acceptEither(f, f, rs[1]);
1650         checkIncomplete(h0);
1651         checkIncomplete(h1);
1652         assertTrue(f.complete(v1));
1653         final CompletableFuture&lt;Void&gt; h2 = m.thenAccept(f, rs[2]);
1654         final CompletableFuture&lt;Void&gt; h3 = m.acceptEither(f, f, rs[3]);
1655 
1656         checkCompletedNormally(h0, null);
1657         checkCompletedNormally(h1, null);
1658         checkCompletedNormally(h2, null);
1659         checkCompletedNormally(h3, null);
1660         checkCompletedNormally(f, v1);
1661         for (NoopConsumer r : rs) r.assertValue(v1);
1662     }}
1663 
1664     /**
1665      * thenAccept result completes exceptionally after exceptional
1666      * completion of source
1667      */
1668     public void testThenAccept_exceptionalCompletion() {
1669         for (ExecutionMode m : ExecutionMode.values())
1670     {
1671         final CFException ex = new CFException();
1672         final CompletableFuture&lt;Integer&gt; f = new CompletableFuture&lt;&gt;();
1673         final NoopConsumer[] rs = new NoopConsumer[4];
1674         for (int i = 0; i &lt; rs.length; i++) rs[i] = new NoopConsumer(m);
1675 
1676         final CompletableFuture&lt;Void&gt; h0 = m.thenAccept(f, rs[0]);
1677         final CompletableFuture&lt;Void&gt; h1 = m.acceptEither(f, f, rs[1]);
1678         assertTrue(f.completeExceptionally(ex));
1679         final CompletableFuture&lt;Void&gt; h2 = m.thenAccept(f, rs[2]);
1680         final CompletableFuture&lt;Void&gt; h3 = m.acceptEither(f, f, rs[3]);
1681 
1682         checkCompletedWithWrappedException(h0, ex);
1683         checkCompletedWithWrappedException(h1, ex);
1684         checkCompletedWithWrappedException(h2, ex);
1685         checkCompletedWithWrappedException(h3, ex);
1686         checkCompletedExceptionally(f, ex);
1687         for (NoopConsumer r : rs) r.assertNotInvoked();
1688     }}
1689 
1690     /**
1691      * thenAccept result completes exceptionally if source cancelled
1692      */
1693     public void testThenAccept_sourceCancelled() {
1694         for (ExecutionMode m : ExecutionMode.values())
1695         for (boolean mayInterruptIfRunning : new boolean[] { true, false })
1696     {
1697         final CompletableFuture&lt;Integer&gt; f = new CompletableFuture&lt;&gt;();
1698         final NoopConsumer[] rs = new NoopConsumer[4];
1699         for (int i = 0; i &lt; rs.length; i++) rs[i] = new NoopConsumer(m);
1700 
1701         final CompletableFuture&lt;Void&gt; h0 = m.thenAccept(f, rs[0]);
1702         final CompletableFuture&lt;Void&gt; h1 = m.acceptEither(f, f, rs[1]);
1703         assertTrue(f.cancel(mayInterruptIfRunning));
1704         final CompletableFuture&lt;Void&gt; h2 = m.thenAccept(f, rs[2]);
1705         final CompletableFuture&lt;Void&gt; h3 = m.acceptEither(f, f, rs[3]);
1706 
1707         checkCompletedWithWrappedCancellationException(h0);
1708         checkCompletedWithWrappedCancellationException(h1);
1709         checkCompletedWithWrappedCancellationException(h2);
1710         checkCompletedWithWrappedCancellationException(h3);
1711         checkCancelled(f);
1712         for (NoopConsumer r : rs) r.assertNotInvoked();
1713     }}
1714 
1715     /**
1716      * thenAccept result completes exceptionally if action does
1717      */
1718     public void testThenAccept_actionFailed() {
1719         for (ExecutionMode m : ExecutionMode.values())
1720         for (Integer v1 : new Integer[] { 1, null })
1721     {
1722         final CompletableFuture&lt;Integer&gt; f = new CompletableFuture&lt;&gt;();
1723         final FailingConsumer[] rs = new FailingConsumer[4];
1724         for (int i = 0; i &lt; rs.length; i++) rs[i] = new FailingConsumer(m);
1725 
1726         final CompletableFuture&lt;Void&gt; h0 = m.thenAccept(f, rs[0]);
1727         final CompletableFuture&lt;Void&gt; h1 = m.acceptEither(f, f, rs[1]);
1728         assertTrue(f.complete(v1));
1729         final CompletableFuture&lt;Void&gt; h2 = m.thenAccept(f, rs[2]);
1730         final CompletableFuture&lt;Void&gt; h3 = m.acceptEither(f, f, rs[3]);
1731 
1732         checkCompletedWithWrappedException(h0, rs[0].ex);
1733         checkCompletedWithWrappedException(h1, rs[1].ex);
1734         checkCompletedWithWrappedException(h2, rs[2].ex);
1735         checkCompletedWithWrappedException(h3, rs[3].ex);
1736         checkCompletedNormally(f, v1);
1737     }}
1738 
1739     /**
1740      * thenCombine result completes normally after normal completion
1741      * of sources
1742      */
1743     public void testThenCombine_normalCompletion() {
1744         for (ExecutionMode m : ExecutionMode.values())
1745         for (boolean fFirst : new boolean[] { true, false })
1746         for (Integer v1 : new Integer[] { 1, null })
1747         for (Integer v2 : new Integer[] { 2, null })
1748     {
1749         final CompletableFuture&lt;Integer&gt; f = new CompletableFuture&lt;&gt;();
1750         final CompletableFuture&lt;Integer&gt; g = new CompletableFuture&lt;&gt;();
1751         final SubtractFunction[] rs = new SubtractFunction[6];
1752         for (int i = 0; i &lt; rs.length; i++) rs[i] = new SubtractFunction(m);
1753 
1754         final CompletableFuture&lt;Integer&gt; fst =  fFirst ? f : g;
1755         final CompletableFuture&lt;Integer&gt; snd = !fFirst ? f : g;
1756         final Integer w1 =  fFirst ? v1 : v2;
1757         final Integer w2 = !fFirst ? v1 : v2;
1758 
1759         final CompletableFuture&lt;Integer&gt; h0 = m.thenCombine(f, g, rs[0]);
1760         final CompletableFuture&lt;Integer&gt; h1 = m.thenCombine(fst, fst, rs[1]);
1761         assertTrue(fst.complete(w1));
1762         final CompletableFuture&lt;Integer&gt; h2 = m.thenCombine(f, g, rs[2]);
1763         final CompletableFuture&lt;Integer&gt; h3 = m.thenCombine(fst, fst, rs[3]);
1764         checkIncomplete(h0); rs[0].assertNotInvoked();
1765         checkIncomplete(h2); rs[2].assertNotInvoked();
1766         checkCompletedNormally(h1, subtract(w1, w1));
1767         checkCompletedNormally(h3, subtract(w1, w1));
1768         rs[1].assertValue(subtract(w1, w1));
1769         rs[3].assertValue(subtract(w1, w1));
1770         assertTrue(snd.complete(w2));
1771         final CompletableFuture&lt;Integer&gt; h4 = m.thenCombine(f, g, rs[4]);
1772 
1773         checkCompletedNormally(h0, subtract(v1, v2));
1774         checkCompletedNormally(h2, subtract(v1, v2));
1775         checkCompletedNormally(h4, subtract(v1, v2));
1776         rs[0].assertValue(subtract(v1, v2));
1777         rs[2].assertValue(subtract(v1, v2));
1778         rs[4].assertValue(subtract(v1, v2));
1779 
1780         checkCompletedNormally(f, v1);
1781         checkCompletedNormally(g, v2);
1782     }}
1783 
1784     /**
1785      * thenCombine result completes exceptionally after exceptional
1786      * completion of either source
1787      */
1788     public void testThenCombine_exceptionalCompletion() throws Throwable {
1789         for (ExecutionMode m : ExecutionMode.values())
1790         for (boolean fFirst : new boolean[] { true, false })
1791         for (boolean failFirst : new boolean[] { true, false })
1792         for (Integer v1 : new Integer[] { 1, null })
1793     {
1794         final CompletableFuture&lt;Integer&gt; f = new CompletableFuture&lt;&gt;();
1795         final CompletableFuture&lt;Integer&gt; g = new CompletableFuture&lt;&gt;();
1796         final CFException ex = new CFException();
1797         final SubtractFunction r1 = new SubtractFunction(m);
1798         final SubtractFunction r2 = new SubtractFunction(m);
1799         final SubtractFunction r3 = new SubtractFunction(m);
1800 
1801         final CompletableFuture&lt;Integer&gt; fst =  fFirst ? f : g;
1802         final CompletableFuture&lt;Integer&gt; snd = !fFirst ? f : g;
1803         final Callable&lt;Boolean&gt; complete1 = failFirst ?
1804             () -&gt; fst.completeExceptionally(ex) :
1805             () -&gt; fst.complete(v1);
1806         final Callable&lt;Boolean&gt; complete2 = failFirst ?
1807             () -&gt; snd.complete(v1) :
1808             () -&gt; snd.completeExceptionally(ex);
1809 
1810         final CompletableFuture&lt;Integer&gt; h1 = m.thenCombine(f, g, r1);
1811         assertTrue(complete1.call());
1812         final CompletableFuture&lt;Integer&gt; h2 = m.thenCombine(f, g, r2);
1813         checkIncomplete(h1);
1814         checkIncomplete(h2);
1815         assertTrue(complete2.call());
1816         final CompletableFuture&lt;Integer&gt; h3 = m.thenCombine(f, g, r3);
1817 
1818         checkCompletedWithWrappedException(h1, ex);
1819         checkCompletedWithWrappedException(h2, ex);
1820         checkCompletedWithWrappedException(h3, ex);
1821         r1.assertNotInvoked();
1822         r2.assertNotInvoked();
1823         r3.assertNotInvoked();
1824         checkCompletedNormally(failFirst ? snd : fst, v1);
1825         checkCompletedExceptionally(failFirst ? fst : snd, ex);
1826     }}
1827 
1828     /**
1829      * thenCombine result completes exceptionally if either source cancelled
1830      */
1831     public void testThenCombine_sourceCancelled() throws Throwable {
1832         for (ExecutionMode m : ExecutionMode.values())
1833         for (boolean mayInterruptIfRunning : new boolean[] { true, false })
1834         for (boolean fFirst : new boolean[] { true, false })
1835         for (boolean failFirst : new boolean[] { true, false })
1836         for (Integer v1 : new Integer[] { 1, null })
1837     {
1838         final CompletableFuture&lt;Integer&gt; f = new CompletableFuture&lt;&gt;();
1839         final CompletableFuture&lt;Integer&gt; g = new CompletableFuture&lt;&gt;();
1840         final SubtractFunction r1 = new SubtractFunction(m);
1841         final SubtractFunction r2 = new SubtractFunction(m);
1842         final SubtractFunction r3 = new SubtractFunction(m);
1843 
1844         final CompletableFuture&lt;Integer&gt; fst =  fFirst ? f : g;
1845         final CompletableFuture&lt;Integer&gt; snd = !fFirst ? f : g;
1846         final Callable&lt;Boolean&gt; complete1 = failFirst ?
1847             () -&gt; fst.cancel(mayInterruptIfRunning) :
1848             () -&gt; fst.complete(v1);
1849         final Callable&lt;Boolean&gt; complete2 = failFirst ?
1850             () -&gt; snd.complete(v1) :
1851             () -&gt; snd.cancel(mayInterruptIfRunning);
1852 
1853         final CompletableFuture&lt;Integer&gt; h1 = m.thenCombine(f, g, r1);
1854         assertTrue(complete1.call());
1855         final CompletableFuture&lt;Integer&gt; h2 = m.thenCombine(f, g, r2);
1856         checkIncomplete(h1);
1857         checkIncomplete(h2);
1858         assertTrue(complete2.call());
1859         final CompletableFuture&lt;Integer&gt; h3 = m.thenCombine(f, g, r3);
1860 
1861         checkCompletedWithWrappedCancellationException(h1);
1862         checkCompletedWithWrappedCancellationException(h2);
1863         checkCompletedWithWrappedCancellationException(h3);
1864         r1.assertNotInvoked();
1865         r2.assertNotInvoked();
1866         r3.assertNotInvoked();
1867         checkCompletedNormally(failFirst ? snd : fst, v1);
1868         checkCancelled(failFirst ? fst : snd);
1869     }}
1870 
1871     /**
1872      * thenCombine result completes exceptionally if action does
1873      */
1874     public void testThenCombine_actionFailed() {
1875         for (ExecutionMode m : ExecutionMode.values())
1876         for (boolean fFirst : new boolean[] { true, false })
1877         for (Integer v1 : new Integer[] { 1, null })
1878         for (Integer v2 : new Integer[] { 2, null })
1879     {
1880         final CompletableFuture&lt;Integer&gt; f = new CompletableFuture&lt;&gt;();
1881         final CompletableFuture&lt;Integer&gt; g = new CompletableFuture&lt;&gt;();
1882         final FailingBiFunction r1 = new FailingBiFunction(m);
1883         final FailingBiFunction r2 = new FailingBiFunction(m);
1884         final FailingBiFunction r3 = new FailingBiFunction(m);
1885 
1886         final CompletableFuture&lt;Integer&gt; fst =  fFirst ? f : g;
1887         final CompletableFuture&lt;Integer&gt; snd = !fFirst ? f : g;
1888         final Integer w1 =  fFirst ? v1 : v2;
1889         final Integer w2 = !fFirst ? v1 : v2;
1890 
1891         final CompletableFuture&lt;Integer&gt; h1 = m.thenCombine(f, g, r1);
1892         assertTrue(fst.complete(w1));
1893         final CompletableFuture&lt;Integer&gt; h2 = m.thenCombine(f, g, r2);
1894         assertTrue(snd.complete(w2));
1895         final CompletableFuture&lt;Integer&gt; h3 = m.thenCombine(f, g, r3);
1896 
1897         checkCompletedWithWrappedException(h1, r1.ex);
1898         checkCompletedWithWrappedException(h2, r2.ex);
1899         checkCompletedWithWrappedException(h3, r3.ex);
1900         r1.assertInvoked();
1901         r2.assertInvoked();
1902         r3.assertInvoked();
1903         checkCompletedNormally(f, v1);
1904         checkCompletedNormally(g, v2);
1905     }}
1906 
1907     /**
1908      * thenAcceptBoth result completes normally after normal
1909      * completion of sources
1910      */
1911     public void testThenAcceptBoth_normalCompletion() {
1912         for (ExecutionMode m : ExecutionMode.values())
1913         for (boolean fFirst : new boolean[] { true, false })
1914         for (Integer v1 : new Integer[] { 1, null })
1915         for (Integer v2 : new Integer[] { 2, null })
1916     {
1917         final CompletableFuture&lt;Integer&gt; f = new CompletableFuture&lt;&gt;();
1918         final CompletableFuture&lt;Integer&gt; g = new CompletableFuture&lt;&gt;();
1919         final SubtractAction r1 = new SubtractAction(m);
1920         final SubtractAction r2 = new SubtractAction(m);
1921         final SubtractAction r3 = new SubtractAction(m);
1922 
1923         final CompletableFuture&lt;Integer&gt; fst =  fFirst ? f : g;
1924         final CompletableFuture&lt;Integer&gt; snd = !fFirst ? f : g;
1925         final Integer w1 =  fFirst ? v1 : v2;
1926         final Integer w2 = !fFirst ? v1 : v2;
1927 
1928         final CompletableFuture&lt;Void&gt; h1 = m.thenAcceptBoth(f, g, r1);
1929         assertTrue(fst.complete(w1));
1930         final CompletableFuture&lt;Void&gt; h2 = m.thenAcceptBoth(f, g, r2);
1931         checkIncomplete(h1);
1932         checkIncomplete(h2);
1933         r1.assertNotInvoked();
1934         r2.assertNotInvoked();
1935         assertTrue(snd.complete(w2));
1936         final CompletableFuture&lt;Void&gt; h3 = m.thenAcceptBoth(f, g, r3);
1937 
1938         checkCompletedNormally(h1, null);
1939         checkCompletedNormally(h2, null);
1940         checkCompletedNormally(h3, null);
1941         r1.assertValue(subtract(v1, v2));
1942         r2.assertValue(subtract(v1, v2));
1943         r3.assertValue(subtract(v1, v2));
1944         checkCompletedNormally(f, v1);
1945         checkCompletedNormally(g, v2);
1946     }}
1947 
1948     /**
1949      * thenAcceptBoth result completes exceptionally after exceptional
1950      * completion of either source
1951      */
1952     public void testThenAcceptBoth_exceptionalCompletion() throws Throwable {
1953         for (ExecutionMode m : ExecutionMode.values())
1954         for (boolean fFirst : new boolean[] { true, false })
1955         for (boolean failFirst : new boolean[] { true, false })
1956         for (Integer v1 : new Integer[] { 1, null })
1957     {
1958         final CompletableFuture&lt;Integer&gt; f = new CompletableFuture&lt;&gt;();
1959         final CompletableFuture&lt;Integer&gt; g = new CompletableFuture&lt;&gt;();
1960         final CFException ex = new CFException();
1961         final SubtractAction r1 = new SubtractAction(m);
1962         final SubtractAction r2 = new SubtractAction(m);
1963         final SubtractAction r3 = new SubtractAction(m);
1964 
1965         final CompletableFuture&lt;Integer&gt; fst =  fFirst ? f : g;
1966         final CompletableFuture&lt;Integer&gt; snd = !fFirst ? f : g;
1967         final Callable&lt;Boolean&gt; complete1 = failFirst ?
1968             () -&gt; fst.completeExceptionally(ex) :
1969             () -&gt; fst.complete(v1);
1970         final Callable&lt;Boolean&gt; complete2 = failFirst ?
1971             () -&gt; snd.complete(v1) :
1972             () -&gt; snd.completeExceptionally(ex);
1973 
1974         final CompletableFuture&lt;Void&gt; h1 = m.thenAcceptBoth(f, g, r1);
1975         assertTrue(complete1.call());
1976         final CompletableFuture&lt;Void&gt; h2 = m.thenAcceptBoth(f, g, r2);
1977         checkIncomplete(h1);
1978         checkIncomplete(h2);
1979         assertTrue(complete2.call());
1980         final CompletableFuture&lt;Void&gt; h3 = m.thenAcceptBoth(f, g, r3);
1981 
1982         checkCompletedWithWrappedException(h1, ex);
1983         checkCompletedWithWrappedException(h2, ex);
1984         checkCompletedWithWrappedException(h3, ex);
1985         r1.assertNotInvoked();
1986         r2.assertNotInvoked();
1987         r3.assertNotInvoked();
1988         checkCompletedNormally(failFirst ? snd : fst, v1);
1989         checkCompletedExceptionally(failFirst ? fst : snd, ex);
1990     }}
1991 
1992     /**
1993      * thenAcceptBoth result completes exceptionally if either source cancelled
1994      */
1995     public void testThenAcceptBoth_sourceCancelled() throws Throwable {
1996         for (ExecutionMode m : ExecutionMode.values())
1997         for (boolean mayInterruptIfRunning : new boolean[] { true, false })
1998         for (boolean fFirst : new boolean[] { true, false })
1999         for (boolean failFirst : new boolean[] { true, false })
2000         for (Integer v1 : new Integer[] { 1, null })
2001     {
2002         final CompletableFuture&lt;Integer&gt; f = new CompletableFuture&lt;&gt;();
2003         final CompletableFuture&lt;Integer&gt; g = new CompletableFuture&lt;&gt;();
2004         final SubtractAction r1 = new SubtractAction(m);
2005         final SubtractAction r2 = new SubtractAction(m);
2006         final SubtractAction r3 = new SubtractAction(m);
2007 
2008         final CompletableFuture&lt;Integer&gt; fst =  fFirst ? f : g;
2009         final CompletableFuture&lt;Integer&gt; snd = !fFirst ? f : g;
2010         final Callable&lt;Boolean&gt; complete1 = failFirst ?
2011             () -&gt; fst.cancel(mayInterruptIfRunning) :
2012             () -&gt; fst.complete(v1);
2013         final Callable&lt;Boolean&gt; complete2 = failFirst ?
2014             () -&gt; snd.complete(v1) :
2015             () -&gt; snd.cancel(mayInterruptIfRunning);
2016 
2017         final CompletableFuture&lt;Void&gt; h1 = m.thenAcceptBoth(f, g, r1);
2018         assertTrue(complete1.call());
2019         final CompletableFuture&lt;Void&gt; h2 = m.thenAcceptBoth(f, g, r2);
2020         checkIncomplete(h1);
2021         checkIncomplete(h2);
2022         assertTrue(complete2.call());
2023         final CompletableFuture&lt;Void&gt; h3 = m.thenAcceptBoth(f, g, r3);
2024 
2025         checkCompletedWithWrappedCancellationException(h1);
2026         checkCompletedWithWrappedCancellationException(h2);
2027         checkCompletedWithWrappedCancellationException(h3);
2028         r1.assertNotInvoked();
2029         r2.assertNotInvoked();
2030         r3.assertNotInvoked();
2031         checkCompletedNormally(failFirst ? snd : fst, v1);
2032         checkCancelled(failFirst ? fst : snd);
2033     }}
2034 
2035     /**
2036      * thenAcceptBoth result completes exceptionally if action does
2037      */
2038     public void testThenAcceptBoth_actionFailed() {
2039         for (ExecutionMode m : ExecutionMode.values())
2040         for (boolean fFirst : new boolean[] { true, false })
2041         for (Integer v1 : new Integer[] { 1, null })
2042         for (Integer v2 : new Integer[] { 2, null })
2043     {
2044         final CompletableFuture&lt;Integer&gt; f = new CompletableFuture&lt;&gt;();
2045         final CompletableFuture&lt;Integer&gt; g = new CompletableFuture&lt;&gt;();
2046         final FailingBiConsumer r1 = new FailingBiConsumer(m);
2047         final FailingBiConsumer r2 = new FailingBiConsumer(m);
2048         final FailingBiConsumer r3 = new FailingBiConsumer(m);
2049 
2050         final CompletableFuture&lt;Integer&gt; fst =  fFirst ? f : g;
2051         final CompletableFuture&lt;Integer&gt; snd = !fFirst ? f : g;
2052         final Integer w1 =  fFirst ? v1 : v2;
2053         final Integer w2 = !fFirst ? v1 : v2;
2054 
2055         final CompletableFuture&lt;Void&gt; h1 = m.thenAcceptBoth(f, g, r1);
2056         assertTrue(fst.complete(w1));
2057         final CompletableFuture&lt;Void&gt; h2 = m.thenAcceptBoth(f, g, r2);
2058         assertTrue(snd.complete(w2));
2059         final CompletableFuture&lt;Void&gt; h3 = m.thenAcceptBoth(f, g, r3);
2060 
2061         checkCompletedWithWrappedException(h1, r1.ex);
2062         checkCompletedWithWrappedException(h2, r2.ex);
2063         checkCompletedWithWrappedException(h3, r3.ex);
2064         r1.assertInvoked();
2065         r2.assertInvoked();
2066         r3.assertInvoked();
2067         checkCompletedNormally(f, v1);
2068         checkCompletedNormally(g, v2);
2069     }}
2070 
2071     /**
2072      * runAfterBoth result completes normally after normal
2073      * completion of sources
2074      */
2075     public void testRunAfterBoth_normalCompletion() {
2076         for (ExecutionMode m : ExecutionMode.values())
2077         for (boolean fFirst : new boolean[] { true, false })
2078         for (Integer v1 : new Integer[] { 1, null })
2079         for (Integer v2 : new Integer[] { 2, null })
2080     {
2081         final CompletableFuture&lt;Integer&gt; f = new CompletableFuture&lt;&gt;();
2082         final CompletableFuture&lt;Integer&gt; g = new CompletableFuture&lt;&gt;();
2083         final Noop r1 = new Noop(m);
2084         final Noop r2 = new Noop(m);
2085         final Noop r3 = new Noop(m);
2086 
2087         final CompletableFuture&lt;Integer&gt; fst =  fFirst ? f : g;
2088         final CompletableFuture&lt;Integer&gt; snd = !fFirst ? f : g;
2089         final Integer w1 =  fFirst ? v1 : v2;
2090         final Integer w2 = !fFirst ? v1 : v2;
2091 
2092         final CompletableFuture&lt;Void&gt; h1 = m.runAfterBoth(f, g, r1);
2093         assertTrue(fst.complete(w1));
2094         final CompletableFuture&lt;Void&gt; h2 = m.runAfterBoth(f, g, r2);
2095         checkIncomplete(h1);
2096         checkIncomplete(h2);
2097         r1.assertNotInvoked();
2098         r2.assertNotInvoked();
2099         assertTrue(snd.complete(w2));
2100         final CompletableFuture&lt;Void&gt; h3 = m.runAfterBoth(f, g, r3);
2101 
2102         checkCompletedNormally(h1, null);
2103         checkCompletedNormally(h2, null);
2104         checkCompletedNormally(h3, null);
2105         r1.assertInvoked();
2106         r2.assertInvoked();
2107         r3.assertInvoked();
2108         checkCompletedNormally(f, v1);
2109         checkCompletedNormally(g, v2);
2110     }}
2111 
2112     /**
2113      * runAfterBoth result completes exceptionally after exceptional
2114      * completion of either source
2115      */
2116     public void testRunAfterBoth_exceptionalCompletion() throws Throwable {
2117         for (ExecutionMode m : ExecutionMode.values())
2118         for (boolean fFirst : new boolean[] { true, false })
2119         for (boolean failFirst : new boolean[] { true, false })
2120         for (Integer v1 : new Integer[] { 1, null })
2121     {
2122         final CompletableFuture&lt;Integer&gt; f = new CompletableFuture&lt;&gt;();
2123         final CompletableFuture&lt;Integer&gt; g = new CompletableFuture&lt;&gt;();
2124         final CFException ex = new CFException();
2125         final Noop r1 = new Noop(m);
2126         final Noop r2 = new Noop(m);
2127         final Noop r3 = new Noop(m);
2128 
2129         final CompletableFuture&lt;Integer&gt; fst =  fFirst ? f : g;
2130         final CompletableFuture&lt;Integer&gt; snd = !fFirst ? f : g;
2131         final Callable&lt;Boolean&gt; complete1 = failFirst ?
2132             () -&gt; fst.completeExceptionally(ex) :
2133             () -&gt; fst.complete(v1);
2134         final Callable&lt;Boolean&gt; complete2 = failFirst ?
2135             () -&gt; snd.complete(v1) :
2136             () -&gt; snd.completeExceptionally(ex);
2137 
2138         final CompletableFuture&lt;Void&gt; h1 = m.runAfterBoth(f, g, r1);
2139         assertTrue(complete1.call());
2140         final CompletableFuture&lt;Void&gt; h2 = m.runAfterBoth(f, g, r2);
2141         checkIncomplete(h1);
2142         checkIncomplete(h2);
2143         assertTrue(complete2.call());
2144         final CompletableFuture&lt;Void&gt; h3 = m.runAfterBoth(f, g, r3);
2145 
2146         checkCompletedWithWrappedException(h1, ex);
2147         checkCompletedWithWrappedException(h2, ex);
2148         checkCompletedWithWrappedException(h3, ex);
2149         r1.assertNotInvoked();
2150         r2.assertNotInvoked();
2151         r3.assertNotInvoked();
2152         checkCompletedNormally(failFirst ? snd : fst, v1);
2153         checkCompletedExceptionally(failFirst ? fst : snd, ex);
2154     }}
2155 
2156     /**
2157      * runAfterBoth result completes exceptionally if either source cancelled
2158      */
2159     public void testRunAfterBoth_sourceCancelled() throws Throwable {
2160         for (ExecutionMode m : ExecutionMode.values())
2161         for (boolean mayInterruptIfRunning : new boolean[] { true, false })
2162         for (boolean fFirst : new boolean[] { true, false })
2163         for (boolean failFirst : new boolean[] { true, false })
2164         for (Integer v1 : new Integer[] { 1, null })
2165     {
2166         final CompletableFuture&lt;Integer&gt; f = new CompletableFuture&lt;&gt;();
2167         final CompletableFuture&lt;Integer&gt; g = new CompletableFuture&lt;&gt;();
2168         final Noop r1 = new Noop(m);
2169         final Noop r2 = new Noop(m);
2170         final Noop r3 = new Noop(m);
2171 
2172         final CompletableFuture&lt;Integer&gt; fst =  fFirst ? f : g;
2173         final CompletableFuture&lt;Integer&gt; snd = !fFirst ? f : g;
2174         final Callable&lt;Boolean&gt; complete1 = failFirst ?
2175             () -&gt; fst.cancel(mayInterruptIfRunning) :
2176             () -&gt; fst.complete(v1);
2177         final Callable&lt;Boolean&gt; complete2 = failFirst ?
2178             () -&gt; snd.complete(v1) :
2179             () -&gt; snd.cancel(mayInterruptIfRunning);
2180 
2181         final CompletableFuture&lt;Void&gt; h1 = m.runAfterBoth(f, g, r1);
2182         assertTrue(complete1.call());
2183         final CompletableFuture&lt;Void&gt; h2 = m.runAfterBoth(f, g, r2);
2184         checkIncomplete(h1);
2185         checkIncomplete(h2);
2186         assertTrue(complete2.call());
2187         final CompletableFuture&lt;Void&gt; h3 = m.runAfterBoth(f, g, r3);
2188 
2189         checkCompletedWithWrappedCancellationException(h1);
2190         checkCompletedWithWrappedCancellationException(h2);
2191         checkCompletedWithWrappedCancellationException(h3);
2192         r1.assertNotInvoked();
2193         r2.assertNotInvoked();
2194         r3.assertNotInvoked();
2195         checkCompletedNormally(failFirst ? snd : fst, v1);
2196         checkCancelled(failFirst ? fst : snd);
2197     }}
2198 
2199     /**
2200      * runAfterBoth result completes exceptionally if action does
2201      */
2202     public void testRunAfterBoth_actionFailed() {
2203         for (ExecutionMode m : ExecutionMode.values())
2204         for (boolean fFirst : new boolean[] { true, false })
2205         for (Integer v1 : new Integer[] { 1, null })
2206         for (Integer v2 : new Integer[] { 2, null })
2207     {
2208         final CompletableFuture&lt;Integer&gt; f = new CompletableFuture&lt;&gt;();
2209         final CompletableFuture&lt;Integer&gt; g = new CompletableFuture&lt;&gt;();
2210         final FailingRunnable r1 = new FailingRunnable(m);
2211         final FailingRunnable r2 = new FailingRunnable(m);
2212         final FailingRunnable r3 = new FailingRunnable(m);
2213 
2214         final CompletableFuture&lt;Integer&gt; fst =  fFirst ? f : g;
2215         final CompletableFuture&lt;Integer&gt; snd = !fFirst ? f : g;
2216         final Integer w1 =  fFirst ? v1 : v2;
2217         final Integer w2 = !fFirst ? v1 : v2;
2218 
2219         final CompletableFuture&lt;Void&gt; h1 = m.runAfterBoth(f, g, r1);
2220         assertTrue(fst.complete(w1));
2221         final CompletableFuture&lt;Void&gt; h2 = m.runAfterBoth(f, g, r2);
2222         assertTrue(snd.complete(w2));
2223         final CompletableFuture&lt;Void&gt; h3 = m.runAfterBoth(f, g, r3);
2224 
2225         checkCompletedWithWrappedException(h1, r1.ex);
2226         checkCompletedWithWrappedException(h2, r2.ex);
2227         checkCompletedWithWrappedException(h3, r3.ex);
2228         r1.assertInvoked();
2229         r2.assertInvoked();
2230         r3.assertInvoked();
2231         checkCompletedNormally(f, v1);
2232         checkCompletedNormally(g, v2);
2233     }}
2234 
2235     /**
2236      * applyToEither result completes normally after normal completion
2237      * of either source
2238      */
2239     public void testApplyToEither_normalCompletion() {
2240         for (ExecutionMode m : ExecutionMode.values())
2241         for (Integer v1 : new Integer[] { 1, null })
2242         for (Integer v2 : new Integer[] { 2, null })
2243     {
2244         final CompletableFuture&lt;Integer&gt; f = new CompletableFuture&lt;&gt;();
2245         final CompletableFuture&lt;Integer&gt; g = new CompletableFuture&lt;&gt;();
2246         final IncFunction[] rs = new IncFunction[6];
2247         for (int i = 0; i &lt; rs.length; i++) rs[i] = new IncFunction(m);
2248 
2249         final CompletableFuture&lt;Integer&gt; h0 = m.applyToEither(f, g, rs[0]);
2250         final CompletableFuture&lt;Integer&gt; h1 = m.applyToEither(g, f, rs[1]);
2251         checkIncomplete(h0);
2252         checkIncomplete(h1);
2253         rs[0].assertNotInvoked();
2254         rs[1].assertNotInvoked();
2255         f.complete(v1);
2256         checkCompletedNormally(h0, inc(v1));
2257         checkCompletedNormally(h1, inc(v1));
2258         final CompletableFuture&lt;Integer&gt; h2 = m.applyToEither(f, g, rs[2]);
2259         final CompletableFuture&lt;Integer&gt; h3 = m.applyToEither(g, f, rs[3]);
2260         checkCompletedNormally(h2, inc(v1));
2261         checkCompletedNormally(h3, inc(v1));
2262         g.complete(v2);
2263 
2264         // unspecified behavior - both source completions available
2265         final CompletableFuture&lt;Integer&gt; h4 = m.applyToEither(f, g, rs[4]);
2266         final CompletableFuture&lt;Integer&gt; h5 = m.applyToEither(g, f, rs[5]);
2267         rs[4].assertValue(h4.join());
2268         rs[5].assertValue(h5.join());
2269         assertTrue(Objects.equals(inc(v1), h4.join()) ||
2270                    Objects.equals(inc(v2), h4.join()));
2271         assertTrue(Objects.equals(inc(v1), h5.join()) ||
2272                    Objects.equals(inc(v2), h5.join()));
2273 
2274         checkCompletedNormally(f, v1);
2275         checkCompletedNormally(g, v2);
2276         checkCompletedNormally(h0, inc(v1));
2277         checkCompletedNormally(h1, inc(v1));
2278         checkCompletedNormally(h2, inc(v1));
2279         checkCompletedNormally(h3, inc(v1));
2280         for (int i = 0; i &lt; 4; i++) rs[i].assertValue(inc(v1));
2281     }}
2282 
2283     /**
2284      * applyToEither result completes exceptionally after exceptional
2285      * completion of either source
2286      */
2287     public void testApplyToEither_exceptionalCompletion() {
2288         for (ExecutionMode m : ExecutionMode.values())
2289         for (Integer v1 : new Integer[] { 1, null })
2290     {
2291         final CompletableFuture&lt;Integer&gt; f = new CompletableFuture&lt;&gt;();
2292         final CompletableFuture&lt;Integer&gt; g = new CompletableFuture&lt;&gt;();
2293         final CFException ex = new CFException();
2294         final IncFunction[] rs = new IncFunction[6];
2295         for (int i = 0; i &lt; rs.length; i++) rs[i] = new IncFunction(m);
2296 
2297         final CompletableFuture&lt;Integer&gt; h0 = m.applyToEither(f, g, rs[0]);
2298         final CompletableFuture&lt;Integer&gt; h1 = m.applyToEither(g, f, rs[1]);
2299         checkIncomplete(h0);
2300         checkIncomplete(h1);
2301         rs[0].assertNotInvoked();
2302         rs[1].assertNotInvoked();
2303         f.completeExceptionally(ex);
2304         checkCompletedWithWrappedException(h0, ex);
2305         checkCompletedWithWrappedException(h1, ex);
2306         final CompletableFuture&lt;Integer&gt; h2 = m.applyToEither(f, g, rs[2]);
2307         final CompletableFuture&lt;Integer&gt; h3 = m.applyToEither(g, f, rs[3]);
2308         checkCompletedWithWrappedException(h2, ex);
2309         checkCompletedWithWrappedException(h3, ex);
2310         g.complete(v1);
2311 
2312         // unspecified behavior - both source completions available
2313         final CompletableFuture&lt;Integer&gt; h4 = m.applyToEither(f, g, rs[4]);
2314         final CompletableFuture&lt;Integer&gt; h5 = m.applyToEither(g, f, rs[5]);
2315         try {
2316             assertEquals(inc(v1), h4.join());
2317             rs[4].assertValue(inc(v1));
2318         } catch (CompletionException ok) {
2319             checkCompletedWithWrappedException(h4, ex);
2320             rs[4].assertNotInvoked();
2321         }
2322         try {
2323             assertEquals(inc(v1), h5.join());
2324             rs[5].assertValue(inc(v1));
2325         } catch (CompletionException ok) {
2326             checkCompletedWithWrappedException(h5, ex);
2327             rs[5].assertNotInvoked();
2328         }
2329 
2330         checkCompletedExceptionally(f, ex);
2331         checkCompletedNormally(g, v1);
2332         checkCompletedWithWrappedException(h0, ex);
2333         checkCompletedWithWrappedException(h1, ex);
2334         checkCompletedWithWrappedException(h2, ex);
2335         checkCompletedWithWrappedException(h3, ex);
2336         checkCompletedWithWrappedException(h4, ex);
2337         for (int i = 0; i &lt; 4; i++) rs[i].assertNotInvoked();
2338     }}
2339 
2340     public void testApplyToEither_exceptionalCompletion2() {
2341         for (ExecutionMode m : ExecutionMode.values())
2342         for (boolean fFirst : new boolean[] { true, false })
2343         for (Integer v1 : new Integer[] { 1, null })
2344     {
2345         final CompletableFuture&lt;Integer&gt; f = new CompletableFuture&lt;&gt;();
2346         final CompletableFuture&lt;Integer&gt; g = new CompletableFuture&lt;&gt;();
2347         final CFException ex = new CFException();
2348         final IncFunction[] rs = new IncFunction[6];
2349         for (int i = 0; i &lt; rs.length; i++) rs[i] = new IncFunction(m);
2350 
2351         final CompletableFuture&lt;Integer&gt; h0 = m.applyToEither(f, g, rs[0]);
2352         final CompletableFuture&lt;Integer&gt; h1 = m.applyToEither(g, f, rs[1]);
2353         assertTrue(fFirst ? f.complete(v1) : g.completeExceptionally(ex));
2354         assertTrue(!fFirst ? f.complete(v1) : g.completeExceptionally(ex));
2355         final CompletableFuture&lt;Integer&gt; h2 = m.applyToEither(f, g, rs[2]);
2356         final CompletableFuture&lt;Integer&gt; h3 = m.applyToEither(g, f, rs[3]);
2357 
2358         // unspecified behavior - both source completions available
2359         try {
2360             assertEquals(inc(v1), h0.join());
2361             rs[0].assertValue(inc(v1));
2362         } catch (CompletionException ok) {
2363             checkCompletedWithWrappedException(h0, ex);
2364             rs[0].assertNotInvoked();
2365         }
2366         try {
2367             assertEquals(inc(v1), h1.join());
2368             rs[1].assertValue(inc(v1));
2369         } catch (CompletionException ok) {
2370             checkCompletedWithWrappedException(h1, ex);
2371             rs[1].assertNotInvoked();
2372         }
2373         try {
2374             assertEquals(inc(v1), h2.join());
2375             rs[2].assertValue(inc(v1));
2376         } catch (CompletionException ok) {
2377             checkCompletedWithWrappedException(h2, ex);
2378             rs[2].assertNotInvoked();
2379         }
2380         try {
2381             assertEquals(inc(v1), h3.join());
2382             rs[3].assertValue(inc(v1));
2383         } catch (CompletionException ok) {
2384             checkCompletedWithWrappedException(h3, ex);
2385             rs[3].assertNotInvoked();
2386         }
2387 
2388         checkCompletedNormally(f, v1);
2389         checkCompletedExceptionally(g, ex);
2390     }}
2391 
2392     /**
2393      * applyToEither result completes exceptionally if either source cancelled
2394      */
2395     public void testApplyToEither_sourceCancelled() {
2396         for (ExecutionMode m : ExecutionMode.values())
2397         for (boolean mayInterruptIfRunning : new boolean[] { true, false })
2398         for (Integer v1 : new Integer[] { 1, null })
2399     {
2400         final CompletableFuture&lt;Integer&gt; f = new CompletableFuture&lt;&gt;();
2401         final CompletableFuture&lt;Integer&gt; g = new CompletableFuture&lt;&gt;();
2402         final IncFunction[] rs = new IncFunction[6];
2403         for (int i = 0; i &lt; rs.length; i++) rs[i] = new IncFunction(m);
2404 
2405         final CompletableFuture&lt;Integer&gt; h0 = m.applyToEither(f, g, rs[0]);
2406         final CompletableFuture&lt;Integer&gt; h1 = m.applyToEither(g, f, rs[1]);
2407         checkIncomplete(h0);
2408         checkIncomplete(h1);
2409         rs[0].assertNotInvoked();
2410         rs[1].assertNotInvoked();
2411         f.cancel(mayInterruptIfRunning);
2412         checkCompletedWithWrappedCancellationException(h0);
2413         checkCompletedWithWrappedCancellationException(h1);
2414         final CompletableFuture&lt;Integer&gt; h2 = m.applyToEither(f, g, rs[2]);
2415         final CompletableFuture&lt;Integer&gt; h3 = m.applyToEither(g, f, rs[3]);
2416         checkCompletedWithWrappedCancellationException(h2);
2417         checkCompletedWithWrappedCancellationException(h3);
2418         g.complete(v1);
2419 
2420         // unspecified behavior - both source completions available
2421         final CompletableFuture&lt;Integer&gt; h4 = m.applyToEither(f, g, rs[4]);
2422         final CompletableFuture&lt;Integer&gt; h5 = m.applyToEither(g, f, rs[5]);
2423         try {
2424             assertEquals(inc(v1), h4.join());
2425             rs[4].assertValue(inc(v1));
2426         } catch (CompletionException ok) {
2427             checkCompletedWithWrappedCancellationException(h4);
2428             rs[4].assertNotInvoked();
2429         }
2430         try {
2431             assertEquals(inc(v1), h5.join());
2432             rs[5].assertValue(inc(v1));
2433         } catch (CompletionException ok) {
2434             checkCompletedWithWrappedCancellationException(h5);
2435             rs[5].assertNotInvoked();
2436         }
2437 
2438         checkCancelled(f);
2439         checkCompletedNormally(g, v1);
2440         checkCompletedWithWrappedCancellationException(h0);
2441         checkCompletedWithWrappedCancellationException(h1);
2442         checkCompletedWithWrappedCancellationException(h2);
2443         checkCompletedWithWrappedCancellationException(h3);
2444         for (int i = 0; i &lt; 4; i++) rs[i].assertNotInvoked();
2445     }}
2446 
2447     public void testApplyToEither_sourceCancelled2() {
2448         for (ExecutionMode m : ExecutionMode.values())
2449         for (boolean mayInterruptIfRunning : new boolean[] { true, false })
2450         for (boolean fFirst : new boolean[] { true, false })
2451         for (Integer v1 : new Integer[] { 1, null })
2452     {
2453         final CompletableFuture&lt;Integer&gt; f = new CompletableFuture&lt;&gt;();
2454         final CompletableFuture&lt;Integer&gt; g = new CompletableFuture&lt;&gt;();
2455         final IncFunction[] rs = new IncFunction[6];
2456         for (int i = 0; i &lt; rs.length; i++) rs[i] = new IncFunction(m);
2457 
2458         final CompletableFuture&lt;Integer&gt; h0 = m.applyToEither(f, g, rs[0]);
2459         final CompletableFuture&lt;Integer&gt; h1 = m.applyToEither(g, f, rs[1]);
2460         assertTrue(fFirst ? f.complete(v1) : g.cancel(mayInterruptIfRunning));
2461         assertTrue(!fFirst ? f.complete(v1) : g.cancel(mayInterruptIfRunning));
2462         final CompletableFuture&lt;Integer&gt; h2 = m.applyToEither(f, g, rs[2]);
2463         final CompletableFuture&lt;Integer&gt; h3 = m.applyToEither(g, f, rs[3]);
2464 
2465         // unspecified behavior - both source completions available
2466         try {
2467             assertEquals(inc(v1), h0.join());
2468             rs[0].assertValue(inc(v1));
2469         } catch (CompletionException ok) {
2470             checkCompletedWithWrappedCancellationException(h0);
2471             rs[0].assertNotInvoked();
2472         }
2473         try {
2474             assertEquals(inc(v1), h1.join());
2475             rs[1].assertValue(inc(v1));
2476         } catch (CompletionException ok) {
2477             checkCompletedWithWrappedCancellationException(h1);
2478             rs[1].assertNotInvoked();
2479         }
2480         try {
2481             assertEquals(inc(v1), h2.join());
2482             rs[2].assertValue(inc(v1));
2483         } catch (CompletionException ok) {
2484             checkCompletedWithWrappedCancellationException(h2);
2485             rs[2].assertNotInvoked();
2486         }
2487         try {
2488             assertEquals(inc(v1), h3.join());
2489             rs[3].assertValue(inc(v1));
2490         } catch (CompletionException ok) {
2491             checkCompletedWithWrappedCancellationException(h3);
2492             rs[3].assertNotInvoked();
2493         }
2494 
2495         checkCompletedNormally(f, v1);
2496         checkCancelled(g);
2497     }}
2498 
2499     /**
2500      * applyToEither result completes exceptionally if action does
2501      */
2502     public void testApplyToEither_actionFailed() {
2503         for (ExecutionMode m : ExecutionMode.values())
2504         for (Integer v1 : new Integer[] { 1, null })
2505         for (Integer v2 : new Integer[] { 2, null })
2506     {
2507         final CompletableFuture&lt;Integer&gt; f = new CompletableFuture&lt;&gt;();
2508         final CompletableFuture&lt;Integer&gt; g = new CompletableFuture&lt;&gt;();
2509         final FailingFunction[] rs = new FailingFunction[6];
2510         for (int i = 0; i &lt; rs.length; i++) rs[i] = new FailingFunction(m);
2511 
2512         final CompletableFuture&lt;Integer&gt; h0 = m.applyToEither(f, g, rs[0]);
2513         final CompletableFuture&lt;Integer&gt; h1 = m.applyToEither(g, f, rs[1]);
2514         f.complete(v1);
2515         final CompletableFuture&lt;Integer&gt; h2 = m.applyToEither(f, g, rs[2]);
2516         final CompletableFuture&lt;Integer&gt; h3 = m.applyToEither(g, f, rs[3]);
2517         checkCompletedWithWrappedException(h0, rs[0].ex);
2518         checkCompletedWithWrappedException(h1, rs[1].ex);
2519         checkCompletedWithWrappedException(h2, rs[2].ex);
2520         checkCompletedWithWrappedException(h3, rs[3].ex);
2521         for (int i = 0; i &lt; 4; i++) rs[i].assertValue(v1);
2522 
2523         g.complete(v2);
2524 
2525         // unspecified behavior - both source completions available
2526         final CompletableFuture&lt;Integer&gt; h4 = m.applyToEither(f, g, rs[4]);
2527         final CompletableFuture&lt;Integer&gt; h5 = m.applyToEither(g, f, rs[5]);
2528 
2529         checkCompletedWithWrappedException(h4, rs[4].ex);
2530         assertTrue(Objects.equals(v1, rs[4].value) ||
2531                    Objects.equals(v2, rs[4].value));
2532         checkCompletedWithWrappedException(h5, rs[5].ex);
2533         assertTrue(Objects.equals(v1, rs[5].value) ||
2534                    Objects.equals(v2, rs[5].value));
2535 
2536         checkCompletedNormally(f, v1);
2537         checkCompletedNormally(g, v2);
2538     }}
2539 
2540     /**
2541      * acceptEither result completes normally after normal completion
2542      * of either source
2543      */
2544     public void testAcceptEither_normalCompletion() {
2545         for (ExecutionMode m : ExecutionMode.values())
2546         for (Integer v1 : new Integer[] { 1, null })
2547         for (Integer v2 : new Integer[] { 2, null })
2548     {
2549         final CompletableFuture&lt;Integer&gt; f = new CompletableFuture&lt;&gt;();
2550         final CompletableFuture&lt;Integer&gt; g = new CompletableFuture&lt;&gt;();
2551         final NoopConsumer[] rs = new NoopConsumer[6];
2552         for (int i = 0; i &lt; rs.length; i++) rs[i] = new NoopConsumer(m);
2553 
2554         final CompletableFuture&lt;Void&gt; h0 = m.acceptEither(f, g, rs[0]);
2555         final CompletableFuture&lt;Void&gt; h1 = m.acceptEither(g, f, rs[1]);
2556         checkIncomplete(h0);
2557         checkIncomplete(h1);
2558         rs[0].assertNotInvoked();
2559         rs[1].assertNotInvoked();
2560         f.complete(v1);
2561         checkCompletedNormally(h0, null);
2562         checkCompletedNormally(h1, null);
2563         rs[0].assertValue(v1);
2564         rs[1].assertValue(v1);
2565         final CompletableFuture&lt;Void&gt; h2 = m.acceptEither(f, g, rs[2]);
2566         final CompletableFuture&lt;Void&gt; h3 = m.acceptEither(g, f, rs[3]);
2567         checkCompletedNormally(h2, null);
2568         checkCompletedNormally(h3, null);
2569         rs[2].assertValue(v1);
2570         rs[3].assertValue(v1);
2571         g.complete(v2);
2572 
2573         // unspecified behavior - both source completions available
2574         final CompletableFuture&lt;Void&gt; h4 = m.acceptEither(f, g, rs[4]);
2575         final CompletableFuture&lt;Void&gt; h5 = m.acceptEither(g, f, rs[5]);
2576         checkCompletedNormally(h4, null);
2577         checkCompletedNormally(h5, null);
2578         assertTrue(Objects.equals(v1, rs[4].value) ||
2579                    Objects.equals(v2, rs[4].value));
2580         assertTrue(Objects.equals(v1, rs[5].value) ||
2581                    Objects.equals(v2, rs[5].value));
2582 
2583         checkCompletedNormally(f, v1);
2584         checkCompletedNormally(g, v2);
2585         checkCompletedNormally(h0, null);
2586         checkCompletedNormally(h1, null);
2587         checkCompletedNormally(h2, null);
2588         checkCompletedNormally(h3, null);
2589         for (int i = 0; i &lt; 4; i++) rs[i].assertValue(v1);
2590     }}
2591 
2592     /**
2593      * acceptEither result completes exceptionally after exceptional
2594      * completion of either source
2595      */
2596     public void testAcceptEither_exceptionalCompletion() {
2597         for (ExecutionMode m : ExecutionMode.values())
2598         for (Integer v1 : new Integer[] { 1, null })
2599     {
2600         final CompletableFuture&lt;Integer&gt; f = new CompletableFuture&lt;&gt;();
2601         final CompletableFuture&lt;Integer&gt; g = new CompletableFuture&lt;&gt;();
2602         final CFException ex = new CFException();
2603         final NoopConsumer[] rs = new NoopConsumer[6];
2604         for (int i = 0; i &lt; rs.length; i++) rs[i] = new NoopConsumer(m);
2605 
2606         final CompletableFuture&lt;Void&gt; h0 = m.acceptEither(f, g, rs[0]);
2607         final CompletableFuture&lt;Void&gt; h1 = m.acceptEither(g, f, rs[1]);
2608         checkIncomplete(h0);
2609         checkIncomplete(h1);
2610         rs[0].assertNotInvoked();
2611         rs[1].assertNotInvoked();
2612         f.completeExceptionally(ex);
2613         checkCompletedWithWrappedException(h0, ex);
2614         checkCompletedWithWrappedException(h1, ex);
2615         final CompletableFuture&lt;Void&gt; h2 = m.acceptEither(f, g, rs[2]);
2616         final CompletableFuture&lt;Void&gt; h3 = m.acceptEither(g, f, rs[3]);
2617         checkCompletedWithWrappedException(h2, ex);
2618         checkCompletedWithWrappedException(h3, ex);
2619 
2620         g.complete(v1);
2621 
2622         // unspecified behavior - both source completions available
2623         final CompletableFuture&lt;Void&gt; h4 = m.acceptEither(f, g, rs[4]);
2624         final CompletableFuture&lt;Void&gt; h5 = m.acceptEither(g, f, rs[5]);
2625         try {
2626             assertNull(h4.join());
2627             rs[4].assertValue(v1);
2628         } catch (CompletionException ok) {
2629             checkCompletedWithWrappedException(h4, ex);
2630             rs[4].assertNotInvoked();
2631         }
2632         try {
2633             assertNull(h5.join());
2634             rs[5].assertValue(v1);
2635         } catch (CompletionException ok) {
2636             checkCompletedWithWrappedException(h5, ex);
2637             rs[5].assertNotInvoked();
2638         }
2639 
2640         checkCompletedExceptionally(f, ex);
2641         checkCompletedNormally(g, v1);
2642         checkCompletedWithWrappedException(h0, ex);
2643         checkCompletedWithWrappedException(h1, ex);
2644         checkCompletedWithWrappedException(h2, ex);
2645         checkCompletedWithWrappedException(h3, ex);
2646         checkCompletedWithWrappedException(h4, ex);
2647         for (int i = 0; i &lt; 4; i++) rs[i].assertNotInvoked();
2648     }}
2649 
2650     public void testAcceptEither_exceptionalCompletion2() {
2651         for (ExecutionMode m : ExecutionMode.values())
2652         for (boolean fFirst : new boolean[] { true, false })
2653         for (Integer v1 : new Integer[] { 1, null })
2654     {
2655         final CompletableFuture&lt;Integer&gt; f = new CompletableFuture&lt;&gt;();
2656         final CompletableFuture&lt;Integer&gt; g = new CompletableFuture&lt;&gt;();
2657         final CFException ex = new CFException();
2658         final NoopConsumer[] rs = new NoopConsumer[6];
2659         for (int i = 0; i &lt; rs.length; i++) rs[i] = new NoopConsumer(m);
2660 
2661         final CompletableFuture&lt;Void&gt; h0 = m.acceptEither(f, g, rs[0]);
2662         final CompletableFuture&lt;Void&gt; h1 = m.acceptEither(g, f, rs[1]);
2663         assertTrue(fFirst ? f.complete(v1) : g.completeExceptionally(ex));
2664         assertTrue(!fFirst ? f.complete(v1) : g.completeExceptionally(ex));
2665         final CompletableFuture&lt;Void&gt; h2 = m.acceptEither(f, g, rs[2]);
2666         final CompletableFuture&lt;Void&gt; h3 = m.acceptEither(g, f, rs[3]);
2667 
2668         // unspecified behavior - both source completions available
2669         try {
2670             assertNull(h0.join());
2671             rs[0].assertValue(v1);
2672         } catch (CompletionException ok) {
2673             checkCompletedWithWrappedException(h0, ex);
2674             rs[0].assertNotInvoked();
2675         }
2676         try {
2677             assertNull(h1.join());
2678             rs[1].assertValue(v1);
2679         } catch (CompletionException ok) {
2680             checkCompletedWithWrappedException(h1, ex);
2681             rs[1].assertNotInvoked();
2682         }
2683         try {
2684             assertNull(h2.join());
2685             rs[2].assertValue(v1);
2686         } catch (CompletionException ok) {
2687             checkCompletedWithWrappedException(h2, ex);
2688             rs[2].assertNotInvoked();
2689         }
2690         try {
2691             assertNull(h3.join());
2692             rs[3].assertValue(v1);
2693         } catch (CompletionException ok) {
2694             checkCompletedWithWrappedException(h3, ex);
2695             rs[3].assertNotInvoked();
2696         }
2697 
2698         checkCompletedNormally(f, v1);
2699         checkCompletedExceptionally(g, ex);
2700     }}
2701 
2702     /**
2703      * acceptEither result completes exceptionally if either source cancelled
2704      */
2705     public void testAcceptEither_sourceCancelled() {
2706         for (ExecutionMode m : ExecutionMode.values())
2707         for (boolean mayInterruptIfRunning : new boolean[] { true, false })
2708         for (Integer v1 : new Integer[] { 1, null })
2709     {
2710         final CompletableFuture&lt;Integer&gt; f = new CompletableFuture&lt;&gt;();
2711         final CompletableFuture&lt;Integer&gt; g = new CompletableFuture&lt;&gt;();
2712         final NoopConsumer[] rs = new NoopConsumer[6];
2713         for (int i = 0; i &lt; rs.length; i++) rs[i] = new NoopConsumer(m);
2714 
2715         final CompletableFuture&lt;Void&gt; h0 = m.acceptEither(f, g, rs[0]);
2716         final CompletableFuture&lt;Void&gt; h1 = m.acceptEither(g, f, rs[1]);
2717         checkIncomplete(h0);
2718         checkIncomplete(h1);
2719         rs[0].assertNotInvoked();
2720         rs[1].assertNotInvoked();
2721         f.cancel(mayInterruptIfRunning);
2722         checkCompletedWithWrappedCancellationException(h0);
2723         checkCompletedWithWrappedCancellationException(h1);
2724         final CompletableFuture&lt;Void&gt; h2 = m.acceptEither(f, g, rs[2]);
2725         final CompletableFuture&lt;Void&gt; h3 = m.acceptEither(g, f, rs[3]);
2726         checkCompletedWithWrappedCancellationException(h2);
2727         checkCompletedWithWrappedCancellationException(h3);
2728 
2729         g.complete(v1);
2730 
2731         // unspecified behavior - both source completions available
2732         final CompletableFuture&lt;Void&gt; h4 = m.acceptEither(f, g, rs[4]);
2733         final CompletableFuture&lt;Void&gt; h5 = m.acceptEither(g, f, rs[5]);
2734         try {
2735             assertNull(h4.join());
2736             rs[4].assertValue(v1);
2737         } catch (CompletionException ok) {
2738             checkCompletedWithWrappedCancellationException(h4);
2739             rs[4].assertNotInvoked();
2740         }
2741         try {
2742             assertNull(h5.join());
2743             rs[5].assertValue(v1);
2744         } catch (CompletionException ok) {
2745             checkCompletedWithWrappedCancellationException(h5);
2746             rs[5].assertNotInvoked();
2747         }
2748 
2749         checkCancelled(f);
2750         checkCompletedNormally(g, v1);
2751         checkCompletedWithWrappedCancellationException(h0);
2752         checkCompletedWithWrappedCancellationException(h1);
2753         checkCompletedWithWrappedCancellationException(h2);
2754         checkCompletedWithWrappedCancellationException(h3);
2755         for (int i = 0; i &lt; 4; i++) rs[i].assertNotInvoked();
2756     }}
2757 
2758     /**
2759      * acceptEither result completes exceptionally if action does
2760      */
2761     public void testAcceptEither_actionFailed() {
2762         for (ExecutionMode m : ExecutionMode.values())
2763         for (Integer v1 : new Integer[] { 1, null })
2764         for (Integer v2 : new Integer[] { 2, null })
2765     {
2766         final CompletableFuture&lt;Integer&gt; f = new CompletableFuture&lt;&gt;();
2767         final CompletableFuture&lt;Integer&gt; g = new CompletableFuture&lt;&gt;();
2768         final FailingConsumer[] rs = new FailingConsumer[6];
2769         for (int i = 0; i &lt; rs.length; i++) rs[i] = new FailingConsumer(m);
2770 
2771         final CompletableFuture&lt;Void&gt; h0 = m.acceptEither(f, g, rs[0]);
2772         final CompletableFuture&lt;Void&gt; h1 = m.acceptEither(g, f, rs[1]);
2773         f.complete(v1);
2774         final CompletableFuture&lt;Void&gt; h2 = m.acceptEither(f, g, rs[2]);
2775         final CompletableFuture&lt;Void&gt; h3 = m.acceptEither(g, f, rs[3]);
2776         checkCompletedWithWrappedException(h0, rs[0].ex);
2777         checkCompletedWithWrappedException(h1, rs[1].ex);
2778         checkCompletedWithWrappedException(h2, rs[2].ex);
2779         checkCompletedWithWrappedException(h3, rs[3].ex);
2780         for (int i = 0; i &lt; 4; i++) rs[i].assertValue(v1);
2781 
2782         g.complete(v2);
2783 
2784         // unspecified behavior - both source completions available
2785         final CompletableFuture&lt;Void&gt; h4 = m.acceptEither(f, g, rs[4]);
2786         final CompletableFuture&lt;Void&gt; h5 = m.acceptEither(g, f, rs[5]);
2787 
2788         checkCompletedWithWrappedException(h4, rs[4].ex);
2789         assertTrue(Objects.equals(v1, rs[4].value) ||
2790                    Objects.equals(v2, rs[4].value));
2791         checkCompletedWithWrappedException(h5, rs[5].ex);
2792         assertTrue(Objects.equals(v1, rs[5].value) ||
2793                    Objects.equals(v2, rs[5].value));
2794 
2795         checkCompletedNormally(f, v1);
2796         checkCompletedNormally(g, v2);
2797     }}
2798 
2799     /**
2800      * runAfterEither result completes normally after normal completion
2801      * of either source
2802      */
2803     public void testRunAfterEither_normalCompletion() {
2804         for (ExecutionMode m : ExecutionMode.values())
2805         for (Integer v1 : new Integer[] { 1, null })
2806         for (Integer v2 : new Integer[] { 2, null })
2807         for (boolean pushNop : new boolean[] { true, false })
2808     {
2809         final CompletableFuture&lt;Integer&gt; f = new CompletableFuture&lt;&gt;();
2810         final CompletableFuture&lt;Integer&gt; g = new CompletableFuture&lt;&gt;();
2811         final Noop[] rs = new Noop[6];
2812         for (int i = 0; i &lt; rs.length; i++) rs[i] = new Noop(m);
2813 
2814         final CompletableFuture&lt;Void&gt; h0 = m.runAfterEither(f, g, rs[0]);
2815         final CompletableFuture&lt;Void&gt; h1 = m.runAfterEither(g, f, rs[1]);
2816         checkIncomplete(h0);
2817         checkIncomplete(h1);
2818         rs[0].assertNotInvoked();
2819         rs[1].assertNotInvoked();
2820         if (pushNop) {          // ad hoc test of intra-completion interference
2821             m.thenRun(f, () -&gt; {});
2822             m.thenRun(g, () -&gt; {});
2823         }
2824         f.complete(v1);
2825         checkCompletedNormally(h0, null);
2826         checkCompletedNormally(h1, null);
2827         rs[0].assertInvoked();
2828         rs[1].assertInvoked();
2829         final CompletableFuture&lt;Void&gt; h2 = m.runAfterEither(f, g, rs[2]);
2830         final CompletableFuture&lt;Void&gt; h3 = m.runAfterEither(g, f, rs[3]);
2831         checkCompletedNormally(h2, null);
2832         checkCompletedNormally(h3, null);
2833         rs[2].assertInvoked();
2834         rs[3].assertInvoked();
2835 
2836         g.complete(v2);
2837 
2838         final CompletableFuture&lt;Void&gt; h4 = m.runAfterEither(f, g, rs[4]);
2839         final CompletableFuture&lt;Void&gt; h5 = m.runAfterEither(g, f, rs[5]);
2840 
2841         checkCompletedNormally(f, v1);
2842         checkCompletedNormally(g, v2);
2843         checkCompletedNormally(h0, null);
2844         checkCompletedNormally(h1, null);
2845         checkCompletedNormally(h2, null);
2846         checkCompletedNormally(h3, null);
2847         checkCompletedNormally(h4, null);
2848         checkCompletedNormally(h5, null);
2849         for (int i = 0; i &lt; 6; i++) rs[i].assertInvoked();
2850     }}
2851 
2852     /**
2853      * runAfterEither result completes exceptionally after exceptional
2854      * completion of either source
2855      */
2856     public void testRunAfterEither_exceptionalCompletion() {
2857         for (ExecutionMode m : ExecutionMode.values())
2858         for (Integer v1 : new Integer[] { 1, null })
2859     {
2860         final CompletableFuture&lt;Integer&gt; f = new CompletableFuture&lt;&gt;();
2861         final CompletableFuture&lt;Integer&gt; g = new CompletableFuture&lt;&gt;();
2862         final CFException ex = new CFException();
2863         final Noop[] rs = new Noop[6];
2864         for (int i = 0; i &lt; rs.length; i++) rs[i] = new Noop(m);
2865 
2866         final CompletableFuture&lt;Void&gt; h0 = m.runAfterEither(f, g, rs[0]);
2867         final CompletableFuture&lt;Void&gt; h1 = m.runAfterEither(g, f, rs[1]);
2868         checkIncomplete(h0);
2869         checkIncomplete(h1);
2870         rs[0].assertNotInvoked();
2871         rs[1].assertNotInvoked();
2872         assertTrue(f.completeExceptionally(ex));
2873         checkCompletedWithWrappedException(h0, ex);
2874         checkCompletedWithWrappedException(h1, ex);
2875         final CompletableFuture&lt;Void&gt; h2 = m.runAfterEither(f, g, rs[2]);
2876         final CompletableFuture&lt;Void&gt; h3 = m.runAfterEither(g, f, rs[3]);
2877         checkCompletedWithWrappedException(h2, ex);
2878         checkCompletedWithWrappedException(h3, ex);
2879 
2880         assertTrue(g.complete(v1));
2881 
2882         // unspecified behavior - both source completions available
2883         final CompletableFuture&lt;Void&gt; h4 = m.runAfterEither(f, g, rs[4]);
2884         final CompletableFuture&lt;Void&gt; h5 = m.runAfterEither(g, f, rs[5]);
2885         try {
2886             assertNull(h4.join());
2887             rs[4].assertInvoked();
2888         } catch (CompletionException ok) {
2889             checkCompletedWithWrappedException(h4, ex);
2890             rs[4].assertNotInvoked();
2891         }
2892         try {
2893             assertNull(h5.join());
2894             rs[5].assertInvoked();
2895         } catch (CompletionException ok) {
2896             checkCompletedWithWrappedException(h5, ex);
2897             rs[5].assertNotInvoked();
2898         }
2899 
2900         checkCompletedExceptionally(f, ex);
2901         checkCompletedNormally(g, v1);
2902         checkCompletedWithWrappedException(h0, ex);
2903         checkCompletedWithWrappedException(h1, ex);
2904         checkCompletedWithWrappedException(h2, ex);
2905         checkCompletedWithWrappedException(h3, ex);
2906         checkCompletedWithWrappedException(h4, ex);
2907         for (int i = 0; i &lt; 4; i++) rs[i].assertNotInvoked();
2908     }}
2909 
2910     public void testRunAfterEither_exceptionalCompletion2() {
2911         for (ExecutionMode m : ExecutionMode.values())
2912         for (boolean fFirst : new boolean[] { true, false })
2913         for (Integer v1 : new Integer[] { 1, null })
2914     {
2915         final CompletableFuture&lt;Integer&gt; f = new CompletableFuture&lt;&gt;();
2916         final CompletableFuture&lt;Integer&gt; g = new CompletableFuture&lt;&gt;();
2917         final CFException ex = new CFException();
2918         final Noop[] rs = new Noop[6];
2919         for (int i = 0; i &lt; rs.length; i++) rs[i] = new Noop(m);
2920 
2921         final CompletableFuture&lt;Void&gt; h0 = m.runAfterEither(f, g, rs[0]);
2922         final CompletableFuture&lt;Void&gt; h1 = m.runAfterEither(g, f, rs[1]);
2923         assertTrue( fFirst ? f.complete(v1) : g.completeExceptionally(ex));
2924         assertTrue(!fFirst ? f.complete(v1) : g.completeExceptionally(ex));
2925         final CompletableFuture&lt;Void&gt; h2 = m.runAfterEither(f, g, rs[2]);
2926         final CompletableFuture&lt;Void&gt; h3 = m.runAfterEither(g, f, rs[3]);
2927 
2928         // unspecified behavior - both source completions available
2929         try {
2930             assertNull(h0.join());
2931             rs[0].assertInvoked();
2932         } catch (CompletionException ok) {
2933             checkCompletedWithWrappedException(h0, ex);
2934             rs[0].assertNotInvoked();
2935         }
2936         try {
2937             assertNull(h1.join());
2938             rs[1].assertInvoked();
2939         } catch (CompletionException ok) {
2940             checkCompletedWithWrappedException(h1, ex);
2941             rs[1].assertNotInvoked();
2942         }
2943         try {
2944             assertNull(h2.join());
2945             rs[2].assertInvoked();
2946         } catch (CompletionException ok) {
2947             checkCompletedWithWrappedException(h2, ex);
2948             rs[2].assertNotInvoked();
2949         }
2950         try {
2951             assertNull(h3.join());
2952             rs[3].assertInvoked();
2953         } catch (CompletionException ok) {
2954             checkCompletedWithWrappedException(h3, ex);
2955             rs[3].assertNotInvoked();
2956         }
2957 
2958         checkCompletedNormally(f, v1);
2959         checkCompletedExceptionally(g, ex);
2960     }}
2961 
2962     /**
2963      * runAfterEither result completes exceptionally if either source cancelled
2964      */
2965     public void testRunAfterEither_sourceCancelled() {
2966         for (ExecutionMode m : ExecutionMode.values())
2967         for (boolean mayInterruptIfRunning : new boolean[] { true, false })
2968         for (Integer v1 : new Integer[] { 1, null })
2969     {
2970         final CompletableFuture&lt;Integer&gt; f = new CompletableFuture&lt;&gt;();
2971         final CompletableFuture&lt;Integer&gt; g = new CompletableFuture&lt;&gt;();
2972         final Noop[] rs = new Noop[6];
2973         for (int i = 0; i &lt; rs.length; i++) rs[i] = new Noop(m);
2974 
2975         final CompletableFuture&lt;Void&gt; h0 = m.runAfterEither(f, g, rs[0]);
2976         final CompletableFuture&lt;Void&gt; h1 = m.runAfterEither(g, f, rs[1]);
2977         checkIncomplete(h0);
2978         checkIncomplete(h1);
2979         rs[0].assertNotInvoked();
2980         rs[1].assertNotInvoked();
2981         f.cancel(mayInterruptIfRunning);
2982         checkCompletedWithWrappedCancellationException(h0);
2983         checkCompletedWithWrappedCancellationException(h1);
2984         final CompletableFuture&lt;Void&gt; h2 = m.runAfterEither(f, g, rs[2]);
2985         final CompletableFuture&lt;Void&gt; h3 = m.runAfterEither(g, f, rs[3]);
2986         checkCompletedWithWrappedCancellationException(h2);
2987         checkCompletedWithWrappedCancellationException(h3);
2988 
2989         assertTrue(g.complete(v1));
2990 
2991         // unspecified behavior - both source completions available
2992         final CompletableFuture&lt;Void&gt; h4 = m.runAfterEither(f, g, rs[4]);
2993         final CompletableFuture&lt;Void&gt; h5 = m.runAfterEither(g, f, rs[5]);
2994         try {
2995             assertNull(h4.join());
2996             rs[4].assertInvoked();
2997         } catch (CompletionException ok) {
2998             checkCompletedWithWrappedCancellationException(h4);
2999             rs[4].assertNotInvoked();
3000         }
3001         try {
3002             assertNull(h5.join());
3003             rs[5].assertInvoked();
3004         } catch (CompletionException ok) {
3005             checkCompletedWithWrappedCancellationException(h5);
3006             rs[5].assertNotInvoked();
3007         }
3008 
3009         checkCancelled(f);
3010         checkCompletedNormally(g, v1);
3011         checkCompletedWithWrappedCancellationException(h0);
3012         checkCompletedWithWrappedCancellationException(h1);
3013         checkCompletedWithWrappedCancellationException(h2);
3014         checkCompletedWithWrappedCancellationException(h3);
3015         for (int i = 0; i &lt; 4; i++) rs[i].assertNotInvoked();
3016     }}
3017 
3018     /**
3019      * runAfterEither result completes exceptionally if action does
3020      */
3021     public void testRunAfterEither_actionFailed() {
3022         for (ExecutionMode m : ExecutionMode.values())
3023         for (Integer v1 : new Integer[] { 1, null })
3024         for (Integer v2 : new Integer[] { 2, null })
3025     {
3026         final CompletableFuture&lt;Integer&gt; f = new CompletableFuture&lt;&gt;();
3027         final CompletableFuture&lt;Integer&gt; g = new CompletableFuture&lt;&gt;();
3028         final FailingRunnable[] rs = new FailingRunnable[6];
3029         for (int i = 0; i &lt; rs.length; i++) rs[i] = new FailingRunnable(m);
3030 
3031         final CompletableFuture&lt;Void&gt; h0 = m.runAfterEither(f, g, rs[0]);
3032         final CompletableFuture&lt;Void&gt; h1 = m.runAfterEither(g, f, rs[1]);
3033         assertTrue(f.complete(v1));
3034         final CompletableFuture&lt;Void&gt; h2 = m.runAfterEither(f, g, rs[2]);
3035         final CompletableFuture&lt;Void&gt; h3 = m.runAfterEither(g, f, rs[3]);
3036         checkCompletedWithWrappedException(h0, rs[0].ex);
3037         checkCompletedWithWrappedException(h1, rs[1].ex);
3038         checkCompletedWithWrappedException(h2, rs[2].ex);
3039         checkCompletedWithWrappedException(h3, rs[3].ex);
3040         for (int i = 0; i &lt; 4; i++) rs[i].assertInvoked();
3041         assertTrue(g.complete(v2));
3042         final CompletableFuture&lt;Void&gt; h4 = m.runAfterEither(f, g, rs[4]);
3043         final CompletableFuture&lt;Void&gt; h5 = m.runAfterEither(g, f, rs[5]);
3044         checkCompletedWithWrappedException(h4, rs[4].ex);
3045         checkCompletedWithWrappedException(h5, rs[5].ex);
3046 
3047         checkCompletedNormally(f, v1);
3048         checkCompletedNormally(g, v2);
3049         for (int i = 0; i &lt; 6; i++) rs[i].assertInvoked();
3050     }}
3051 
3052     /**
3053      * thenCompose result completes normally after normal completion of source
3054      */
3055     public void testThenCompose_normalCompletion() {
3056         for (ExecutionMode m : ExecutionMode.values())
3057         for (boolean createIncomplete : new boolean[] { true, false })
3058         for (Integer v1 : new Integer[] { 1, null })
3059     {
3060         final CompletableFuture&lt;Integer&gt; f = new CompletableFuture&lt;&gt;();
3061         final CompletableFutureInc r = new CompletableFutureInc(m);
3062         if (!createIncomplete) assertTrue(f.complete(v1));
3063         final CompletableFuture&lt;Integer&gt; g = m.thenCompose(f, r);
3064         if (createIncomplete) assertTrue(f.complete(v1));
3065 
3066         checkCompletedNormally(g, inc(v1));
3067         checkCompletedNormally(f, v1);
3068         r.assertValue(v1);
3069     }}
3070 
3071     /**
3072      * thenCompose result completes exceptionally after exceptional
3073      * completion of source
3074      */
3075     public void testThenCompose_exceptionalCompletion() {
3076         for (ExecutionMode m : ExecutionMode.values())
3077         for (boolean createIncomplete : new boolean[] { true, false })
3078     {
3079         final CFException ex = new CFException();
3080         final CompletableFutureInc r = new CompletableFutureInc(m);
3081         final CompletableFuture&lt;Integer&gt; f = new CompletableFuture&lt;&gt;();
3082         if (!createIncomplete) f.completeExceptionally(ex);
3083         final CompletableFuture&lt;Integer&gt; g = m.thenCompose(f, r);
3084         if (createIncomplete) f.completeExceptionally(ex);
3085 
3086         checkCompletedWithWrappedException(g, ex);
3087         checkCompletedExceptionally(f, ex);
3088         r.assertNotInvoked();
3089     }}
3090 
3091     /**
3092      * thenCompose result completes exceptionally if action does
3093      */
3094     public void testThenCompose_actionFailed() {
3095         for (ExecutionMode m : ExecutionMode.values())
3096         for (boolean createIncomplete : new boolean[] { true, false })
3097         for (Integer v1 : new Integer[] { 1, null })
3098     {
3099         final CompletableFuture&lt;Integer&gt; f = new CompletableFuture&lt;&gt;();
3100         final FailingCompletableFutureFunction r
3101             = new FailingCompletableFutureFunction(m);
3102         if (!createIncomplete) assertTrue(f.complete(v1));
3103         final CompletableFuture&lt;Integer&gt; g = m.thenCompose(f, r);
3104         if (createIncomplete) assertTrue(f.complete(v1));
3105 
3106         checkCompletedWithWrappedException(g, r.ex);
3107         checkCompletedNormally(f, v1);
3108     }}
3109 
3110     /**
3111      * thenCompose result completes exceptionally if source cancelled
3112      */
3113     public void testThenCompose_sourceCancelled() {
3114         for (ExecutionMode m : ExecutionMode.values())
3115         for (boolean createIncomplete : new boolean[] { true, false })
3116         for (boolean mayInterruptIfRunning : new boolean[] { true, false })
3117     {
3118         final CompletableFuture&lt;Integer&gt; f = new CompletableFuture&lt;&gt;();
3119         final CompletableFutureInc r = new CompletableFutureInc(m);
3120         if (!createIncomplete) assertTrue(f.cancel(mayInterruptIfRunning));
3121         final CompletableFuture&lt;Integer&gt; g = m.thenCompose(f, r);
3122         if (createIncomplete) {
3123             checkIncomplete(g);
3124             assertTrue(f.cancel(mayInterruptIfRunning));
3125         }
3126 
3127         checkCompletedWithWrappedCancellationException(g);
3128         checkCancelled(f);
3129     }}
3130 
3131     /**
3132      * thenCompose result completes exceptionally if the result of the action does
3133      */
3134     public void testThenCompose_actionReturnsFailingFuture() {
3135         for (ExecutionMode m : ExecutionMode.values())
3136         for (int order = 0; order &lt; 6; order++)
3137         for (Integer v1 : new Integer[] { 1, null })
3138     {
3139         final CFException ex = new CFException();
3140         final CompletableFuture&lt;Integer&gt; f = new CompletableFuture&lt;&gt;();
3141         final CompletableFuture&lt;Integer&gt; g = new CompletableFuture&lt;&gt;();
3142         final CompletableFuture&lt;Integer&gt; h;
3143         // Test all permutations of orders
3144         switch (order) {
3145         case 0:
3146             assertTrue(f.complete(v1));
3147             assertTrue(g.completeExceptionally(ex));
3148             h = m.thenCompose(f, x -&gt; g);
3149             break;
3150         case 1:
3151             assertTrue(f.complete(v1));
3152             h = m.thenCompose(f, x -&gt; g);
3153             assertTrue(g.completeExceptionally(ex));
3154             break;
3155         case 2:
3156             assertTrue(g.completeExceptionally(ex));
3157             assertTrue(f.complete(v1));
3158             h = m.thenCompose(f, x -&gt; g);
3159             break;
3160         case 3:
3161             assertTrue(g.completeExceptionally(ex));
3162             h = m.thenCompose(f, x -&gt; g);
3163             assertTrue(f.complete(v1));
3164             break;
3165         case 4:
3166             h = m.thenCompose(f, x -&gt; g);
3167             assertTrue(f.complete(v1));
3168             assertTrue(g.completeExceptionally(ex));
3169             break;
3170         case 5:
3171             h = m.thenCompose(f, x -&gt; g);
3172             assertTrue(f.complete(v1));
3173             assertTrue(g.completeExceptionally(ex));
3174             break;
3175         default: throw new AssertionError();
3176         }
3177 
3178         checkCompletedExceptionally(g, ex);
3179         checkCompletedWithWrappedException(h, ex);
3180         checkCompletedNormally(f, v1);
3181     }}
3182 
3183     /**
3184      * exceptionallyCompose result completes normally after normal
3185      * completion of source
3186      */
3187     public void testExceptionallyCompose_normalCompletion() {
3188         for (ExecutionMode m : ExecutionMode.values())
3189         for (boolean createIncomplete : new boolean[] { true, false })
3190         for (Integer v1 : new Integer[] { 1, null })
3191     {
3192         final CompletableFuture&lt;Integer&gt; f = new CompletableFuture&lt;&gt;();
3193         final ExceptionalCompletableFutureFunction r =
3194             new ExceptionalCompletableFutureFunction(m);
3195         if (!createIncomplete) assertTrue(f.complete(v1));
3196         final CompletableFuture&lt;Integer&gt; g = m.exceptionallyCompose(f, r);
3197         if (createIncomplete) assertTrue(f.complete(v1));
3198 
3199         checkCompletedNormally(f, v1);
3200         checkCompletedNormally(g, v1);
3201         r.assertNotInvoked();
3202     }}
3203 
3204     /**
3205      * exceptionallyCompose result completes normally after exceptional
3206      * completion of source
3207      */
3208     public void testExceptionallyCompose_exceptionalCompletion() {
3209         for (ExecutionMode m : ExecutionMode.values())
3210         for (boolean createIncomplete : new boolean[] { true, false })
3211     {
3212         final CFException ex = new CFException();
3213         final ExceptionalCompletableFutureFunction r =
3214             new ExceptionalCompletableFutureFunction(m);
3215         final CompletableFuture&lt;Integer&gt; f = new CompletableFuture&lt;&gt;();
3216         if (!createIncomplete) f.completeExceptionally(ex);
3217         final CompletableFuture&lt;Integer&gt; g = m.exceptionallyCompose(f, r);
3218         if (createIncomplete) f.completeExceptionally(ex);
3219 
3220         checkCompletedExceptionally(f, ex);
3221         checkCompletedNormally(g, r.value);
3222         r.assertInvoked();
3223     }}
3224 
3225     /**
3226      * exceptionallyCompose completes exceptionally on exception if action does
3227      */
3228     public void testExceptionallyCompose_actionFailed() {
3229         for (ExecutionMode m : ExecutionMode.values())
3230         for (boolean createIncomplete : new boolean[] { true, false })
3231     {
3232         final CFException ex = new CFException();
3233         final CompletableFuture&lt;Integer&gt; f = new CompletableFuture&lt;&gt;();
3234         final FailingExceptionalCompletableFutureFunction r
3235             = new FailingExceptionalCompletableFutureFunction(m);
3236         if (!createIncomplete) f.completeExceptionally(ex);
3237         final CompletableFuture&lt;Integer&gt; g = m.exceptionallyCompose(f, r);
3238         if (createIncomplete) f.completeExceptionally(ex);
3239 
3240         checkCompletedExceptionally(f, ex);
3241         checkCompletedWithWrappedException(g, r.ex);
3242         r.assertInvoked();
3243     }}
3244 
3245     /**
3246      * exceptionallyCompose result completes exceptionally if the
3247      * result of the action does
3248      */
3249     public void testExceptionallyCompose_actionReturnsFailingFuture() {
3250         for (ExecutionMode m : ExecutionMode.values())
3251         for (int order = 0; order &lt; 6; order++)
3252     {
3253         final CFException ex0 = new CFException();
3254         final CFException ex = new CFException();
3255         final CompletableFuture&lt;Integer&gt; f = new CompletableFuture&lt;&gt;();
3256         final CompletableFuture&lt;Integer&gt; g = new CompletableFuture&lt;&gt;();
3257         final CompletableFuture&lt;Integer&gt; h;
3258         // Test all permutations of orders
3259         switch (order) {
3260         case 0:
3261             assertTrue(f.completeExceptionally(ex0));
3262             assertTrue(g.completeExceptionally(ex));
3263             h = m.exceptionallyCompose(f, x -&gt; g);
3264             break;
3265         case 1:
3266             assertTrue(f.completeExceptionally(ex0));
3267             h = m.exceptionallyCompose(f, x -&gt; g);
3268             assertTrue(g.completeExceptionally(ex));
3269             break;
3270         case 2:
3271             assertTrue(g.completeExceptionally(ex));
3272             assertTrue(f.completeExceptionally(ex0));
3273             h = m.exceptionallyCompose(f, x -&gt; g);
3274             break;
3275         case 3:
3276             assertTrue(g.completeExceptionally(ex));
3277             h = m.exceptionallyCompose(f, x -&gt; g);
3278             assertTrue(f.completeExceptionally(ex0));
3279             break;
3280         case 4:
3281             h = m.exceptionallyCompose(f, x -&gt; g);
3282             assertTrue(f.completeExceptionally(ex0));
3283             assertTrue(g.completeExceptionally(ex));
3284             break;
3285         case 5:
3286             h = m.exceptionallyCompose(f, x -&gt; g);
3287             assertTrue(f.completeExceptionally(ex0));
3288             assertTrue(g.completeExceptionally(ex));
3289             break;
3290         default: throw new AssertionError();
3291         }
3292 
3293         checkCompletedExceptionally(g, ex);
3294         checkCompletedWithWrappedException(h, ex);
3295         checkCompletedExceptionally(f, ex0);
3296     }}
3297 
3298     // other static methods
3299 
3300     /**
3301      * allOf(no component futures) returns a future completed normally
3302      * with the value null
3303      */
3304     public void testAllOf_empty() throws Exception {
3305         CompletableFuture&lt;Void&gt; f = CompletableFuture.allOf();
3306         checkCompletedNormally(f, null);
3307     }
3308 
3309     /**
3310      * allOf returns a future completed normally with the value null
3311      * when all components complete normally
3312      */
3313     public void testAllOf_normal() throws Exception {
3314         for (int k = 1; k &lt; 10; k++) {
3315             CompletableFuture&lt;Integer&gt;[] fs
3316                 = (CompletableFuture&lt;Integer&gt;[]) new CompletableFuture[k];
3317             for (int i = 0; i &lt; k; i++)
3318                 fs[i] = new CompletableFuture&lt;&gt;();
3319             CompletableFuture&lt;Void&gt; f = CompletableFuture.allOf(fs);
3320             for (int i = 0; i &lt; k; i++) {
3321                 checkIncomplete(f);
3322                 checkIncomplete(CompletableFuture.allOf(fs));
3323                 fs[i].complete(one);
3324             }
3325             checkCompletedNormally(f, null);
3326             checkCompletedNormally(CompletableFuture.allOf(fs), null);
3327         }
3328     }
3329 
3330     public void testAllOf_normal_backwards() throws Exception {
3331         for (int k = 1; k &lt; 10; k++) {
3332             CompletableFuture&lt;Integer&gt;[] fs
3333                 = (CompletableFuture&lt;Integer&gt;[]) new CompletableFuture[k];
3334             for (int i = 0; i &lt; k; i++)
3335                 fs[i] = new CompletableFuture&lt;&gt;();
3336             CompletableFuture&lt;Void&gt; f = CompletableFuture.allOf(fs);
3337             for (int i = k - 1; i &gt;= 0; i--) {
3338                 checkIncomplete(f);
3339                 checkIncomplete(CompletableFuture.allOf(fs));
3340                 fs[i].complete(one);
3341             }
3342             checkCompletedNormally(f, null);
3343             checkCompletedNormally(CompletableFuture.allOf(fs), null);
3344         }
3345     }
3346 
3347     public void testAllOf_exceptional() throws Exception {
3348         for (int k = 1; k &lt; 10; k++) {
3349             CompletableFuture&lt;Integer&gt;[] fs
3350                 = (CompletableFuture&lt;Integer&gt;[]) new CompletableFuture[k];
3351             CFException ex = new CFException();
3352             for (int i = 0; i &lt; k; i++)
3353                 fs[i] = new CompletableFuture&lt;&gt;();
3354             CompletableFuture&lt;Void&gt; f = CompletableFuture.allOf(fs);
3355             for (int i = 0; i &lt; k; i++) {
3356                 checkIncomplete(f);
3357                 checkIncomplete(CompletableFuture.allOf(fs));
3358                 if (i != k / 2) {
3359                     fs[i].complete(i);
3360                     checkCompletedNormally(fs[i], i);
3361                 } else {
3362                     fs[i].completeExceptionally(ex);
3363                     checkCompletedExceptionally(fs[i], ex);
3364                 }
3365             }
3366             checkCompletedWithWrappedException(f, ex);
3367             checkCompletedWithWrappedException(CompletableFuture.allOf(fs), ex);
3368         }
3369     }
3370 
3371     /**
3372      * anyOf(no component futures) returns an incomplete future
3373      */
3374     public void testAnyOf_empty() throws Exception {
3375         for (Integer v1 : new Integer[] { 1, null })
3376     {
3377         CompletableFuture&lt;Object&gt; f = CompletableFuture.anyOf();
3378         checkIncomplete(f);
3379 
3380         f.complete(v1);
3381         checkCompletedNormally(f, v1);
3382     }}
3383 
3384     /**
3385      * anyOf returns a future completed normally with a value when
3386      * a component future does
3387      */
3388     public void testAnyOf_normal() throws Exception {
3389         for (int k = 0; k &lt; 10; k++) {
3390             CompletableFuture[] fs = new CompletableFuture[k];
3391             for (int i = 0; i &lt; k; i++)
3392                 fs[i] = new CompletableFuture&lt;&gt;();
3393             CompletableFuture&lt;Object&gt; f = CompletableFuture.anyOf(fs);
3394             checkIncomplete(f);
3395             for (int i = 0; i &lt; k; i++) {
3396                 fs[i].complete(i);
3397                 checkCompletedNormally(f, 0);
3398                 int x = (int) CompletableFuture.anyOf(fs).join();
3399                 assertTrue(0 &lt;= x &amp;&amp; x &lt;= i);
3400             }
3401         }
3402     }
3403     public void testAnyOf_normal_backwards() throws Exception {
3404         for (int k = 0; k &lt; 10; k++) {
3405             CompletableFuture[] fs = new CompletableFuture[k];
3406             for (int i = 0; i &lt; k; i++)
3407                 fs[i] = new CompletableFuture&lt;&gt;();
3408             CompletableFuture&lt;Object&gt; f = CompletableFuture.anyOf(fs);
3409             checkIncomplete(f);
3410             for (int i = k - 1; i &gt;= 0; i--) {
3411                 fs[i].complete(i);
3412                 checkCompletedNormally(f, k - 1);
3413                 int x = (int) CompletableFuture.anyOf(fs).join();
3414                 assertTrue(i &lt;= x &amp;&amp; x &lt;= k - 1);
3415             }
3416         }
3417     }
3418 
3419     /**
3420      * anyOf result completes exceptionally when any component does.
3421      */
3422     public void testAnyOf_exceptional() throws Exception {
3423         for (int k = 0; k &lt; 10; k++) {
3424             CompletableFuture[] fs = new CompletableFuture[k];
3425             CFException[] exs = new CFException[k];
3426             for (int i = 0; i &lt; k; i++) {
3427                 fs[i] = new CompletableFuture&lt;&gt;();
3428                 exs[i] = new CFException();
3429             }
3430             CompletableFuture&lt;Object&gt; f = CompletableFuture.anyOf(fs);
3431             checkIncomplete(f);
3432             for (int i = 0; i &lt; k; i++) {
3433                 fs[i].completeExceptionally(exs[i]);
3434                 checkCompletedWithWrappedException(f, exs[0]);
3435                 checkCompletedWithWrappedCFException(CompletableFuture.anyOf(fs));
3436             }
3437         }
3438     }
3439 
3440     public void testAnyOf_exceptional_backwards() throws Exception {
3441         for (int k = 0; k &lt; 10; k++) {
3442             CompletableFuture[] fs = new CompletableFuture[k];
3443             CFException[] exs = new CFException[k];
3444             for (int i = 0; i &lt; k; i++) {
3445                 fs[i] = new CompletableFuture&lt;&gt;();
3446                 exs[i] = new CFException();
3447             }
3448             CompletableFuture&lt;Object&gt; f = CompletableFuture.anyOf(fs);
3449             checkIncomplete(f);
3450             for (int i = k - 1; i &gt;= 0; i--) {
3451                 fs[i].completeExceptionally(exs[i]);
3452                 checkCompletedWithWrappedException(f, exs[k - 1]);
3453                 checkCompletedWithWrappedCFException(CompletableFuture.anyOf(fs));
3454             }
3455         }
3456     }
3457 
3458     /**
3459      * Completion methods throw NullPointerException with null arguments
3460      */
3461     @SuppressWarnings(&quot;FutureReturnValueIgnored&quot;)
3462     public void testNPE() {
3463         CompletableFuture&lt;Integer&gt; f = new CompletableFuture&lt;&gt;();
3464         CompletableFuture&lt;Integer&gt; g = new CompletableFuture&lt;&gt;();
3465         CompletableFuture&lt;Integer&gt; nullFuture = (CompletableFuture&lt;Integer&gt;)null;
3466         ThreadExecutor exec = new ThreadExecutor();
3467 
<a name="1" id="anc1"></a><span class="line-modified">3468         Runnable[] throwingActions = {</span>


3469             () -&gt; CompletableFuture.supplyAsync(null),
3470             () -&gt; CompletableFuture.supplyAsync(null, exec),
3471             () -&gt; CompletableFuture.supplyAsync(new IntegerSupplier(ExecutionMode.SYNC, 42), null),
3472 
3473             () -&gt; CompletableFuture.runAsync(null),
3474             () -&gt; CompletableFuture.runAsync(null, exec),
3475             () -&gt; CompletableFuture.runAsync(() -&gt; {}, null),
3476 
3477             () -&gt; f.completeExceptionally(null),
3478 
3479             () -&gt; f.thenApply(null),
3480             () -&gt; f.thenApplyAsync(null),
3481             () -&gt; f.thenApplyAsync(x -&gt; x, null),
3482             () -&gt; f.thenApplyAsync(null, exec),
3483 
3484             () -&gt; f.thenAccept(null),
3485             () -&gt; f.thenAcceptAsync(null),
3486             () -&gt; f.thenAcceptAsync(x -&gt; {} , null),
3487             () -&gt; f.thenAcceptAsync(null, exec),
3488 
3489             () -&gt; f.thenRun(null),
3490             () -&gt; f.thenRunAsync(null),
3491             () -&gt; f.thenRunAsync(() -&gt; {} , null),
3492             () -&gt; f.thenRunAsync(null, exec),
3493 
3494             () -&gt; f.thenCombine(g, null),
3495             () -&gt; f.thenCombineAsync(g, null),
3496             () -&gt; f.thenCombineAsync(g, null, exec),
3497             () -&gt; f.thenCombine(nullFuture, (x, y) -&gt; x),
3498             () -&gt; f.thenCombineAsync(nullFuture, (x, y) -&gt; x),
3499             () -&gt; f.thenCombineAsync(nullFuture, (x, y) -&gt; x, exec),
3500             () -&gt; f.thenCombineAsync(g, (x, y) -&gt; x, null),
3501 
3502             () -&gt; f.thenAcceptBoth(g, null),
3503             () -&gt; f.thenAcceptBothAsync(g, null),
3504             () -&gt; f.thenAcceptBothAsync(g, null, exec),
3505             () -&gt; f.thenAcceptBoth(nullFuture, (x, y) -&gt; {}),
3506             () -&gt; f.thenAcceptBothAsync(nullFuture, (x, y) -&gt; {}),
3507             () -&gt; f.thenAcceptBothAsync(nullFuture, (x, y) -&gt; {}, exec),
3508             () -&gt; f.thenAcceptBothAsync(g, (x, y) -&gt; {}, null),
3509 
3510             () -&gt; f.runAfterBoth(g, null),
3511             () -&gt; f.runAfterBothAsync(g, null),
3512             () -&gt; f.runAfterBothAsync(g, null, exec),
3513             () -&gt; f.runAfterBoth(nullFuture, () -&gt; {}),
3514             () -&gt; f.runAfterBothAsync(nullFuture, () -&gt; {}),
3515             () -&gt; f.runAfterBothAsync(nullFuture, () -&gt; {}, exec),
3516             () -&gt; f.runAfterBothAsync(g, () -&gt; {}, null),
3517 
3518             () -&gt; f.applyToEither(g, null),
3519             () -&gt; f.applyToEitherAsync(g, null),
3520             () -&gt; f.applyToEitherAsync(g, null, exec),
3521             () -&gt; f.applyToEither(nullFuture, x -&gt; x),
3522             () -&gt; f.applyToEitherAsync(nullFuture, x -&gt; x),
3523             () -&gt; f.applyToEitherAsync(nullFuture, x -&gt; x, exec),
3524             () -&gt; f.applyToEitherAsync(g, x -&gt; x, null),
3525 
3526             () -&gt; f.acceptEither(g, null),
3527             () -&gt; f.acceptEitherAsync(g, null),
3528             () -&gt; f.acceptEitherAsync(g, null, exec),
3529             () -&gt; f.acceptEither(nullFuture, x -&gt; {}),
3530             () -&gt; f.acceptEitherAsync(nullFuture, x -&gt; {}),
3531             () -&gt; f.acceptEitherAsync(nullFuture, x -&gt; {}, exec),
3532             () -&gt; f.acceptEitherAsync(g, x -&gt; {}, null),
3533 
3534             () -&gt; f.runAfterEither(g, null),
3535             () -&gt; f.runAfterEitherAsync(g, null),
3536             () -&gt; f.runAfterEitherAsync(g, null, exec),
3537             () -&gt; f.runAfterEither(nullFuture, () -&gt; {}),
3538             () -&gt; f.runAfterEitherAsync(nullFuture, () -&gt; {}),
3539             () -&gt; f.runAfterEitherAsync(nullFuture, () -&gt; {}, exec),
3540             () -&gt; f.runAfterEitherAsync(g, () -&gt; {}, null),
3541 
3542             () -&gt; f.thenCompose(null),
3543             () -&gt; f.thenComposeAsync(null),
3544             () -&gt; f.thenComposeAsync(new CompletableFutureInc(ExecutionMode.EXECUTOR), null),
3545             () -&gt; f.thenComposeAsync(null, exec),
3546 
3547             () -&gt; f.exceptionally(null),
3548 
3549             () -&gt; f.handle(null),
3550 
3551             () -&gt; CompletableFuture.allOf((CompletableFuture&lt;?&gt;)null),
3552             () -&gt; CompletableFuture.allOf((CompletableFuture&lt;?&gt;[])null),
3553             () -&gt; CompletableFuture.allOf(f, null),
3554             () -&gt; CompletableFuture.allOf(null, f),
3555 
3556             () -&gt; CompletableFuture.anyOf((CompletableFuture&lt;?&gt;)null),
3557             () -&gt; CompletableFuture.anyOf((CompletableFuture&lt;?&gt;[])null),
3558             () -&gt; CompletableFuture.anyOf(f, null),
3559             () -&gt; CompletableFuture.anyOf(null, f),
3560 
3561             () -&gt; f.obtrudeException(null),
3562 
3563             () -&gt; CompletableFuture.delayedExecutor(1L, SECONDS, null),
3564             () -&gt; CompletableFuture.delayedExecutor(1L, null, exec),
3565             () -&gt; CompletableFuture.delayedExecutor(1L, null),
3566 
3567             () -&gt; f.orTimeout(1L, null),
3568             () -&gt; f.completeOnTimeout(42, 1L, null),
3569 
3570             () -&gt; CompletableFuture.failedFuture(null),
<a name="2" id="anc2"></a><span class="line-modified">3571             () -&gt; CompletableFuture.failedStage(null),</span>
<span class="line-removed">3572         };</span>
3573 
<a name="3" id="anc3"></a><span class="line-removed">3574         assertThrows(NullPointerException.class, throwingActions);</span>
3575         assertEquals(0, exec.count.get());
3576     }
3577 
3578     /**
3579      * Test submissions to an executor that rejects all tasks.
3580      */
3581     public void testRejectingExecutor() {
3582         for (Integer v : new Integer[] { 1, null })
3583     {
3584         final CountingRejectingExecutor e = new CountingRejectingExecutor();
3585 
3586         final CompletableFuture&lt;Integer&gt; complete = CompletableFuture.completedFuture(v);
3587         final CompletableFuture&lt;Integer&gt; incomplete = new CompletableFuture&lt;&gt;();
3588 
3589         List&lt;CompletableFuture&lt;?&gt;&gt; futures = new ArrayList&lt;&gt;();
3590 
3591         List&lt;CompletableFuture&lt;Integer&gt;&gt; srcs = new ArrayList&lt;&gt;();
3592         srcs.add(complete);
3593         srcs.add(incomplete);
3594 
3595         for (CompletableFuture&lt;Integer&gt; src : srcs) {
3596             List&lt;CompletableFuture&lt;?&gt;&gt; fs = new ArrayList&lt;&gt;();
3597             fs.add(src.thenRunAsync(() -&gt; {}, e));
3598             fs.add(src.thenAcceptAsync(z -&gt; {}, e));
3599             fs.add(src.thenApplyAsync(z -&gt; z, e));
3600 
3601             fs.add(src.thenCombineAsync(src, (x, y) -&gt; x, e));
3602             fs.add(src.thenAcceptBothAsync(src, (x, y) -&gt; {}, e));
3603             fs.add(src.runAfterBothAsync(src, () -&gt; {}, e));
3604 
3605             fs.add(src.applyToEitherAsync(src, z -&gt; z, e));
3606             fs.add(src.acceptEitherAsync(src, z -&gt; {}, e));
3607             fs.add(src.runAfterEitherAsync(src, () -&gt; {}, e));
3608 
3609             fs.add(src.thenComposeAsync(z -&gt; null, e));
3610             fs.add(src.whenCompleteAsync((z, t) -&gt; {}, e));
3611             fs.add(src.handleAsync((z, t) -&gt; null, e));
3612 
3613             for (CompletableFuture&lt;?&gt; future : fs) {
3614                 if (src.isDone())
3615                     checkCompletedWithWrappedException(future, e.ex);
3616                 else
3617                     checkIncomplete(future);
3618             }
3619             futures.addAll(fs);
3620         }
3621 
3622         {
3623             List&lt;CompletableFuture&lt;?&gt;&gt; fs = new ArrayList&lt;&gt;();
3624 
3625             fs.add(complete.thenCombineAsync(incomplete, (x, y) -&gt; x, e));
3626             fs.add(incomplete.thenCombineAsync(complete, (x, y) -&gt; x, e));
3627 
3628             fs.add(complete.thenAcceptBothAsync(incomplete, (x, y) -&gt; {}, e));
3629             fs.add(incomplete.thenAcceptBothAsync(complete, (x, y) -&gt; {}, e));
3630 
3631             fs.add(complete.runAfterBothAsync(incomplete, () -&gt; {}, e));
3632             fs.add(incomplete.runAfterBothAsync(complete, () -&gt; {}, e));
3633 
3634             for (CompletableFuture&lt;?&gt; future : fs)
3635                 checkIncomplete(future);
3636             futures.addAll(fs);
3637         }
3638 
3639         {
3640             List&lt;CompletableFuture&lt;?&gt;&gt; fs = new ArrayList&lt;&gt;();
3641 
3642             fs.add(complete.applyToEitherAsync(incomplete, z -&gt; z, e));
3643             fs.add(incomplete.applyToEitherAsync(complete, z -&gt; z, e));
3644 
3645             fs.add(complete.acceptEitherAsync(incomplete, z -&gt; {}, e));
3646             fs.add(incomplete.acceptEitherAsync(complete, z -&gt; {}, e));
3647 
3648             fs.add(complete.runAfterEitherAsync(incomplete, () -&gt; {}, e));
3649             fs.add(incomplete.runAfterEitherAsync(complete, () -&gt; {}, e));
3650 
3651             for (CompletableFuture&lt;?&gt; future : fs)
3652                 checkCompletedWithWrappedException(future, e.ex);
3653             futures.addAll(fs);
3654         }
3655 
3656         incomplete.complete(v);
3657 
3658         for (CompletableFuture&lt;?&gt; future : futures)
3659             checkCompletedWithWrappedException(future, e.ex);
3660 
3661         assertEquals(futures.size(), e.count.get());
3662     }}
3663 
3664     /**
3665      * Test submissions to an executor that rejects all tasks, but
3666      * should never be invoked because the dependent future is
3667      * explicitly completed.
3668      */
3669     public void testRejectingExecutorNeverInvoked() {
3670         for (Integer v : new Integer[] { 1, null })
3671     {
3672         final CountingRejectingExecutor e = new CountingRejectingExecutor();
3673 
3674         final CompletableFuture&lt;Integer&gt; complete = CompletableFuture.completedFuture(v);
3675         final CompletableFuture&lt;Integer&gt; incomplete = new CompletableFuture&lt;&gt;();
3676 
3677         List&lt;CompletableFuture&lt;?&gt;&gt; fs = new ArrayList&lt;&gt;();
3678         fs.add(incomplete.thenRunAsync(() -&gt; {}, e));
3679         fs.add(incomplete.thenAcceptAsync(z -&gt; {}, e));
3680         fs.add(incomplete.thenApplyAsync(z -&gt; z, e));
3681 
3682         fs.add(incomplete.thenCombineAsync(incomplete, (x, y) -&gt; x, e));
3683         fs.add(incomplete.thenAcceptBothAsync(incomplete, (x, y) -&gt; {}, e));
3684         fs.add(incomplete.runAfterBothAsync(incomplete, () -&gt; {}, e));
3685 
3686         fs.add(incomplete.applyToEitherAsync(incomplete, z -&gt; z, e));
3687         fs.add(incomplete.acceptEitherAsync(incomplete, z -&gt; {}, e));
3688         fs.add(incomplete.runAfterEitherAsync(incomplete, () -&gt; {}, e));
3689 
3690         fs.add(incomplete.thenComposeAsync(z -&gt; null, e));
3691         fs.add(incomplete.whenCompleteAsync((z, t) -&gt; {}, e));
3692         fs.add(incomplete.handleAsync((z, t) -&gt; null, e));
3693 
3694         fs.add(complete.thenCombineAsync(incomplete, (x, y) -&gt; x, e));
3695         fs.add(incomplete.thenCombineAsync(complete, (x, y) -&gt; x, e));
3696 
3697         fs.add(complete.thenAcceptBothAsync(incomplete, (x, y) -&gt; {}, e));
3698         fs.add(incomplete.thenAcceptBothAsync(complete, (x, y) -&gt; {}, e));
3699 
3700         fs.add(complete.runAfterBothAsync(incomplete, () -&gt; {}, e));
3701         fs.add(incomplete.runAfterBothAsync(complete, () -&gt; {}, e));
3702 
3703         for (CompletableFuture&lt;?&gt; future : fs)
3704             checkIncomplete(future);
3705 
3706         for (CompletableFuture&lt;?&gt; future : fs)
3707             future.complete(null);
3708 
3709         incomplete.complete(v);
3710 
3711         for (CompletableFuture&lt;?&gt; future : fs)
3712             checkCompletedNormally(future, null);
3713 
3714         assertEquals(0, e.count.get());
3715     }}
3716 
3717     /**
3718      * toCompletableFuture returns this CompletableFuture.
3719      */
3720     public void testToCompletableFuture() {
3721         CompletableFuture&lt;Integer&gt; f = new CompletableFuture&lt;&gt;();
3722         assertSame(f, f.toCompletableFuture());
3723     }
3724 
3725     // jdk9
3726 
3727     /**
3728      * newIncompleteFuture returns an incomplete CompletableFuture
3729      */
3730     public void testNewIncompleteFuture() {
3731         for (Integer v1 : new Integer[] { 1, null })
3732     {
3733         CompletableFuture&lt;Integer&gt; f = new CompletableFuture&lt;&gt;();
3734         CompletableFuture&lt;Integer&gt; g = f.newIncompleteFuture();
3735         checkIncomplete(f);
3736         checkIncomplete(g);
3737         f.complete(v1);
3738         checkCompletedNormally(f, v1);
3739         checkIncomplete(g);
3740         g.complete(v1);
3741         checkCompletedNormally(g, v1);
3742         assertSame(g.getClass(), CompletableFuture.class);
3743     }}
3744 
3745     /**
3746      * completedStage returns a completed CompletionStage
3747      */
3748     public void testCompletedStage() {
3749         AtomicInteger x = new AtomicInteger(0);
3750         AtomicReference&lt;Throwable&gt; r = new AtomicReference&lt;&gt;();
3751         CompletionStage&lt;Integer&gt; f = CompletableFuture.completedStage(1);
3752         f.whenComplete((v, e) -&gt; {if (e != null) r.set(e); else x.set(v);});
3753         assertEquals(x.get(), 1);
3754         assertNull(r.get());
3755     }
3756 
3757     /**
3758      * defaultExecutor by default returns the commonPool if
3759      * it supports more than one thread.
3760      */
3761     public void testDefaultExecutor() {
3762         CompletableFuture&lt;Integer&gt; f = new CompletableFuture&lt;&gt;();
3763         Executor e = f.defaultExecutor();
3764         Executor c = ForkJoinPool.commonPool();
3765         if (ForkJoinPool.getCommonPoolParallelism() &gt; 1)
3766             assertSame(e, c);
3767         else
3768             assertNotSame(e, c);
3769     }
3770 
3771     /**
3772      * failedFuture returns a CompletableFuture completed
3773      * exceptionally with the given Exception
3774      */
3775     public void testFailedFuture() {
3776         CFException ex = new CFException();
3777         CompletableFuture&lt;Integer&gt; f = CompletableFuture.failedFuture(ex);
3778         checkCompletedExceptionally(f, ex);
3779     }
3780 
3781     /**
3782      * failedFuture(null) throws NPE
3783      */
3784     public void testFailedFuture_null() {
3785         try {
3786             CompletableFuture&lt;Integer&gt; f = CompletableFuture.failedFuture(null);
3787             shouldThrow();
3788         } catch (NullPointerException success) {}
3789     }
3790 
3791     /**
3792      * copy returns a CompletableFuture that is completed normally,
3793      * with the same value, when source is.
3794      */
3795     public void testCopy_normalCompletion() {
3796         for (boolean createIncomplete : new boolean[] { true, false })
3797         for (Integer v1 : new Integer[] { 1, null })
3798     {
3799         CompletableFuture&lt;Integer&gt; f = new CompletableFuture&lt;&gt;();
3800         if (!createIncomplete) assertTrue(f.complete(v1));
3801         CompletableFuture&lt;Integer&gt; g = f.copy();
3802         if (createIncomplete) {
3803             checkIncomplete(f);
3804             checkIncomplete(g);
3805             assertTrue(f.complete(v1));
3806         }
3807         checkCompletedNormally(f, v1);
3808         checkCompletedNormally(g, v1);
3809     }}
3810 
3811     /**
3812      * copy returns a CompletableFuture that is completed exceptionally
3813      * when source is.
3814      */
3815     public void testCopy_exceptionalCompletion() {
3816         for (boolean createIncomplete : new boolean[] { true, false })
3817     {
3818         CFException ex = new CFException();
3819         CompletableFuture&lt;Integer&gt; f = new CompletableFuture&lt;&gt;();
3820         if (!createIncomplete) f.completeExceptionally(ex);
3821         CompletableFuture&lt;Integer&gt; g = f.copy();
3822         if (createIncomplete) {
3823             checkIncomplete(f);
3824             checkIncomplete(g);
3825             f.completeExceptionally(ex);
3826         }
3827         checkCompletedExceptionally(f, ex);
3828         checkCompletedWithWrappedException(g, ex);
3829     }}
3830 
3831     /**
3832      * Completion of a copy does not complete its source.
3833      */
3834     public void testCopy_oneWayPropagation() {
3835         CompletableFuture&lt;Integer&gt; f = new CompletableFuture&lt;&gt;();
3836         assertTrue(f.copy().complete(1));
3837         assertTrue(f.copy().complete(null));
3838         assertTrue(f.copy().cancel(true));
3839         assertTrue(f.copy().cancel(false));
3840         assertTrue(f.copy().completeExceptionally(new CFException()));
3841         checkIncomplete(f);
3842     }
3843 
3844     /**
3845      * minimalCompletionStage returns a CompletableFuture that is
3846      * completed normally, with the same value, when source is.
3847      */
3848     public void testMinimalCompletionStage() {
3849         CompletableFuture&lt;Integer&gt; f = new CompletableFuture&lt;&gt;();
3850         CompletionStage&lt;Integer&gt; g = f.minimalCompletionStage();
3851         AtomicInteger x = new AtomicInteger(0);
3852         AtomicReference&lt;Throwable&gt; r = new AtomicReference&lt;&gt;();
3853         checkIncomplete(f);
3854         g.whenComplete((v, e) -&gt; {if (e != null) r.set(e); else x.set(v);});
3855         f.complete(1);
3856         checkCompletedNormally(f, 1);
3857         assertEquals(x.get(), 1);
3858         assertNull(r.get());
3859     }
3860 
3861     /**
3862      * minimalCompletionStage returns a CompletableFuture that is
3863      * completed exceptionally when source is.
3864      */
3865     public void testMinimalCompletionStage2() {
3866         CompletableFuture&lt;Integer&gt; f = new CompletableFuture&lt;&gt;();
3867         CompletionStage&lt;Integer&gt; g = f.minimalCompletionStage();
3868         AtomicInteger x = new AtomicInteger(0);
3869         AtomicReference&lt;Throwable&gt; r = new AtomicReference&lt;&gt;();
3870         g.whenComplete((v, e) -&gt; {if (e != null) r.set(e); else x.set(v);});
3871         checkIncomplete(f);
3872         CFException ex = new CFException();
3873         f.completeExceptionally(ex);
3874         checkCompletedExceptionally(f, ex);
3875         assertEquals(x.get(), 0);
3876         assertEquals(r.get().getCause(), ex);
3877     }
3878 
3879     /**
3880      * failedStage returns a CompletionStage completed
3881      * exceptionally with the given Exception
3882      */
3883     public void testFailedStage() {
3884         CFException ex = new CFException();
3885         CompletionStage&lt;Integer&gt; f = CompletableFuture.failedStage(ex);
3886         AtomicInteger x = new AtomicInteger(0);
3887         AtomicReference&lt;Throwable&gt; r = new AtomicReference&lt;&gt;();
3888         f.whenComplete((v, e) -&gt; {if (e != null) r.set(e); else x.set(v);});
3889         assertEquals(x.get(), 0);
3890         assertEquals(r.get(), ex);
3891     }
3892 
3893     /**
3894      * completeAsync completes with value of given supplier
3895      */
3896     public void testCompleteAsync() {
3897         for (Integer v1 : new Integer[] { 1, null })
3898     {
3899         CompletableFuture&lt;Integer&gt; f = new CompletableFuture&lt;&gt;();
3900         f.completeAsync(() -&gt; v1);
3901         f.join();
3902         checkCompletedNormally(f, v1);
3903     }}
3904 
3905     /**
3906      * completeAsync completes exceptionally if given supplier throws
3907      */
3908     public void testCompleteAsync2() {
3909         CompletableFuture&lt;Integer&gt; f = new CompletableFuture&lt;&gt;();
3910         CFException ex = new CFException();
3911         f.completeAsync(() -&gt; { throw ex; });
3912         try {
3913             f.join();
3914             shouldThrow();
3915         } catch (CompletionException success) {}
3916         checkCompletedWithWrappedException(f, ex);
3917     }
3918 
3919     /**
3920      * completeAsync with given executor completes with value of given supplier
3921      */
3922     public void testCompleteAsync3() {
3923         for (Integer v1 : new Integer[] { 1, null })
3924     {
3925         CompletableFuture&lt;Integer&gt; f = new CompletableFuture&lt;&gt;();
3926         ThreadExecutor executor = new ThreadExecutor();
3927         f.completeAsync(() -&gt; v1, executor);
3928         assertSame(v1, f.join());
3929         checkCompletedNormally(f, v1);
3930         assertEquals(1, executor.count.get());
3931     }}
3932 
3933     /**
3934      * completeAsync with given executor completes exceptionally if
3935      * given supplier throws
3936      */
3937     public void testCompleteAsync4() {
3938         CompletableFuture&lt;Integer&gt; f = new CompletableFuture&lt;&gt;();
3939         CFException ex = new CFException();
3940         ThreadExecutor executor = new ThreadExecutor();
3941         f.completeAsync(() -&gt; { throw ex; }, executor);
3942         try {
3943             f.join();
3944             shouldThrow();
3945         } catch (CompletionException success) {}
3946         checkCompletedWithWrappedException(f, ex);
3947         assertEquals(1, executor.count.get());
3948     }
3949 
3950     /**
3951      * orTimeout completes with TimeoutException if not complete
3952      */
3953     public void testOrTimeout_timesOut() {
3954         long timeoutMillis = timeoutMillis();
3955         CompletableFuture&lt;Integer&gt; f = new CompletableFuture&lt;&gt;();
3956         long startTime = System.nanoTime();
3957         assertSame(f, f.orTimeout(timeoutMillis, MILLISECONDS));
3958         checkCompletedWithTimeoutException(f);
3959         assertTrue(millisElapsedSince(startTime) &gt;= timeoutMillis);
3960     }
3961 
3962     /**
3963      * orTimeout completes normally if completed before timeout
3964      */
3965     public void testOrTimeout_completed() {
3966         for (Integer v1 : new Integer[] { 1, null })
3967     {
3968         CompletableFuture&lt;Integer&gt; f = new CompletableFuture&lt;&gt;();
3969         CompletableFuture&lt;Integer&gt; g = new CompletableFuture&lt;&gt;();
3970         long startTime = System.nanoTime();
3971         f.complete(v1);
3972         assertSame(f, f.orTimeout(LONG_DELAY_MS, MILLISECONDS));
3973         assertSame(g, g.orTimeout(LONG_DELAY_MS, MILLISECONDS));
3974         g.complete(v1);
3975         checkCompletedNormally(f, v1);
3976         checkCompletedNormally(g, v1);
3977         assertTrue(millisElapsedSince(startTime) &lt; LONG_DELAY_MS / 2);
3978     }}
3979 
3980     /**
3981      * completeOnTimeout completes with given value if not complete
3982      */
3983     public void testCompleteOnTimeout_timesOut() {
3984         testInParallel(() -&gt; testCompleteOnTimeout_timesOut(42),
3985                        () -&gt; testCompleteOnTimeout_timesOut(null));
3986     }
3987 
3988     /**
3989      * completeOnTimeout completes with given value if not complete
3990      */
3991     public void testCompleteOnTimeout_timesOut(Integer v) {
3992         long timeoutMillis = timeoutMillis();
3993         CompletableFuture&lt;Integer&gt; f = new CompletableFuture&lt;&gt;();
3994         long startTime = System.nanoTime();
3995         assertSame(f, f.completeOnTimeout(v, timeoutMillis, MILLISECONDS));
3996         assertSame(v, f.join());
3997         assertTrue(millisElapsedSince(startTime) &gt;= timeoutMillis);
3998         f.complete(99);         // should have no effect
3999         checkCompletedNormally(f, v);
4000     }
4001 
4002     /**
4003      * completeOnTimeout has no effect if completed within timeout
4004      */
4005     public void testCompleteOnTimeout_completed() {
4006         for (Integer v1 : new Integer[] { 1, null })
4007     {
4008         CompletableFuture&lt;Integer&gt; f = new CompletableFuture&lt;&gt;();
4009         CompletableFuture&lt;Integer&gt; g = new CompletableFuture&lt;&gt;();
4010         long startTime = System.nanoTime();
4011         f.complete(v1);
4012         assertSame(f, f.completeOnTimeout(-1, LONG_DELAY_MS, MILLISECONDS));
4013         assertSame(g, g.completeOnTimeout(-1, LONG_DELAY_MS, MILLISECONDS));
4014         g.complete(v1);
4015         checkCompletedNormally(f, v1);
4016         checkCompletedNormally(g, v1);
4017         assertTrue(millisElapsedSince(startTime) &lt; LONG_DELAY_MS / 2);
4018     }}
4019 
4020     /**
4021      * delayedExecutor returns an executor that delays submission
4022      */
4023     public void testDelayedExecutor() {
4024         testInParallel(() -&gt; testDelayedExecutor(null, null),
4025                        () -&gt; testDelayedExecutor(null, 1),
4026                        () -&gt; testDelayedExecutor(new ThreadExecutor(), 1),
4027                        () -&gt; testDelayedExecutor(new ThreadExecutor(), 1));
4028     }
4029 
4030     public void testDelayedExecutor(Executor executor, Integer v) throws Exception {
4031         long timeoutMillis = timeoutMillis();
4032         // Use an &quot;unreasonably long&quot; long timeout to catch lingering threads
4033         long longTimeoutMillis = 1000 * 60 * 60 * 24;
4034         final Executor delayer, longDelayer;
4035         if (executor == null) {
4036             delayer = CompletableFuture.delayedExecutor(timeoutMillis, MILLISECONDS);
4037             longDelayer = CompletableFuture.delayedExecutor(longTimeoutMillis, MILLISECONDS);
4038         } else {
4039             delayer = CompletableFuture.delayedExecutor(timeoutMillis, MILLISECONDS, executor);
4040             longDelayer = CompletableFuture.delayedExecutor(longTimeoutMillis, MILLISECONDS, executor);
4041         }
4042         long startTime = System.nanoTime();
4043         CompletableFuture&lt;Integer&gt; f =
4044             CompletableFuture.supplyAsync(() -&gt; v, delayer);
4045         CompletableFuture&lt;Integer&gt; g =
4046             CompletableFuture.supplyAsync(() -&gt; v, longDelayer);
4047 
4048         assertNull(g.getNow(null));
4049 
4050         assertSame(v, f.get(LONG_DELAY_MS, MILLISECONDS));
4051         long millisElapsed = millisElapsedSince(startTime);
4052         assertTrue(millisElapsed &gt;= timeoutMillis);
4053         assertTrue(millisElapsed &lt; LONG_DELAY_MS / 2);
4054 
4055         checkCompletedNormally(f, v);
4056 
4057         checkIncomplete(g);
4058         assertTrue(g.cancel(true));
4059     }
4060 
4061     //--- tests of implementation details; not part of official tck ---
4062 
4063     Object resultOf(CompletableFuture&lt;?&gt; f) {
4064         SecurityManager sm = System.getSecurityManager();
4065         if (sm != null) {
4066             try {
4067                 System.setSecurityManager(null);
4068             } catch (SecurityException giveUp) {
4069                 return &quot;Reflection not available&quot;;
4070             }
4071         }
4072 
4073         try {
4074             java.lang.reflect.Field resultField
4075                 = CompletableFuture.class.getDeclaredField(&quot;result&quot;);
4076             resultField.setAccessible(true);
4077             return resultField.get(f);
4078         } catch (Throwable t) {
4079             throw new AssertionError(t);
4080         } finally {
4081             if (sm != null) System.setSecurityManager(sm);
4082         }
4083     }
4084 
4085     public void testExceptionPropagationReusesResultObject() {
4086         if (!testImplementationDetails) return;
4087         for (ExecutionMode m : ExecutionMode.values())
4088     {
4089         final CFException ex = new CFException();
4090         final CompletableFuture&lt;Integer&gt; v42 = CompletableFuture.completedFuture(42);
4091         final CompletableFuture&lt;Integer&gt; incomplete = new CompletableFuture&lt;&gt;();
4092 
4093         final Runnable noopRunnable = new Noop(m);
4094         final Consumer&lt;Integer&gt; noopConsumer = new NoopConsumer(m);
4095         final Function&lt;Integer, Integer&gt; incFunction = new IncFunction(m);
4096 
4097         List&lt;Function&lt;CompletableFuture&lt;Integer&gt;, CompletableFuture&lt;?&gt;&gt;&gt; funs
4098             = new ArrayList&lt;&gt;();
4099 
4100         funs.add(y -&gt; m.thenRun(y, noopRunnable));
4101         funs.add(y -&gt; m.thenAccept(y, noopConsumer));
4102         funs.add(y -&gt; m.thenApply(y, incFunction));
4103 
4104         funs.add(y -&gt; m.runAfterEither(y, incomplete, noopRunnable));
4105         funs.add(y -&gt; m.acceptEither(y, incomplete, noopConsumer));
4106         funs.add(y -&gt; m.applyToEither(y, incomplete, incFunction));
4107 
4108         funs.add(y -&gt; m.runAfterBoth(y, v42, noopRunnable));
4109         funs.add(y -&gt; m.runAfterBoth(v42, y, noopRunnable));
4110         funs.add(y -&gt; m.thenAcceptBoth(y, v42, new SubtractAction(m)));
4111         funs.add(y -&gt; m.thenAcceptBoth(v42, y, new SubtractAction(m)));
4112         funs.add(y -&gt; m.thenCombine(y, v42, new SubtractFunction(m)));
4113         funs.add(y -&gt; m.thenCombine(v42, y, new SubtractFunction(m)));
4114 
4115         funs.add(y -&gt; m.whenComplete(y, (Integer r, Throwable t) -&gt; {}));
4116 
4117         funs.add(y -&gt; m.thenCompose(y, new CompletableFutureInc(m)));
4118 
4119         funs.add(y -&gt; CompletableFuture.allOf(y));
4120         funs.add(y -&gt; CompletableFuture.allOf(y, v42));
4121         funs.add(y -&gt; CompletableFuture.allOf(v42, y));
4122         funs.add(y -&gt; CompletableFuture.anyOf(y));
4123         funs.add(y -&gt; CompletableFuture.anyOf(y, incomplete));
4124         funs.add(y -&gt; CompletableFuture.anyOf(incomplete, y));
4125 
4126         for (Function&lt;CompletableFuture&lt;Integer&gt;, CompletableFuture&lt;?&gt;&gt;
4127                  fun : funs) {
4128             CompletableFuture&lt;Integer&gt; f = new CompletableFuture&lt;&gt;();
4129             f.completeExceptionally(ex);
4130             CompletableFuture&lt;Integer&gt; src = m.thenApply(f, incFunction);
4131             checkCompletedWithWrappedException(src, ex);
4132             CompletableFuture&lt;?&gt; dep = fun.apply(src);
4133             checkCompletedWithWrappedException(dep, ex);
4134             assertSame(resultOf(src), resultOf(dep));
4135         }
4136 
4137         for (Function&lt;CompletableFuture&lt;Integer&gt;, CompletableFuture&lt;?&gt;&gt;
4138                  fun : funs) {
4139             CompletableFuture&lt;Integer&gt; f = new CompletableFuture&lt;&gt;();
4140             CompletableFuture&lt;Integer&gt; src = m.thenApply(f, incFunction);
4141             CompletableFuture&lt;?&gt; dep = fun.apply(src);
4142             f.completeExceptionally(ex);
4143             checkCompletedWithWrappedException(src, ex);
4144             checkCompletedWithWrappedException(dep, ex);
4145             assertSame(resultOf(src), resultOf(dep));
4146         }
4147 
4148         for (boolean mayInterruptIfRunning : new boolean[] { true, false })
4149         for (Function&lt;CompletableFuture&lt;Integer&gt;, CompletableFuture&lt;?&gt;&gt;
4150                  fun : funs) {
4151             CompletableFuture&lt;Integer&gt; f = new CompletableFuture&lt;&gt;();
4152             f.cancel(mayInterruptIfRunning);
4153             checkCancelled(f);
4154             CompletableFuture&lt;Integer&gt; src = m.thenApply(f, incFunction);
4155             checkCompletedWithWrappedCancellationException(src);
4156             CompletableFuture&lt;?&gt; dep = fun.apply(src);
4157             checkCompletedWithWrappedCancellationException(dep);
4158             assertSame(resultOf(src), resultOf(dep));
4159         }
4160 
4161         for (boolean mayInterruptIfRunning : new boolean[] { true, false })
4162         for (Function&lt;CompletableFuture&lt;Integer&gt;, CompletableFuture&lt;?&gt;&gt;
4163                  fun : funs) {
4164             CompletableFuture&lt;Integer&gt; f = new CompletableFuture&lt;&gt;();
4165             CompletableFuture&lt;Integer&gt; src = m.thenApply(f, incFunction);
4166             CompletableFuture&lt;?&gt; dep = fun.apply(src);
4167             f.cancel(mayInterruptIfRunning);
4168             checkCancelled(f);
4169             checkCompletedWithWrappedCancellationException(src);
4170             checkCompletedWithWrappedCancellationException(dep);
4171             assertSame(resultOf(src), resultOf(dep));
4172         }
4173     }}
4174 
4175     /**
4176      * Minimal completion stages throw UOE for most non-CompletionStage methods
4177      */
4178     public void testMinimalCompletionStage_minimality() {
4179         if (!testImplementationDetails) return;
4180         Function&lt;Method, String&gt; toSignature =
4181             method -&gt; method.getName() + Arrays.toString(method.getParameterTypes());
4182         Predicate&lt;Method&gt; isNotStatic =
4183             method -&gt; (method.getModifiers() &amp; Modifier.STATIC) == 0;
4184         List&lt;Method&gt; minimalMethods =
4185             Stream.of(Object.class, CompletionStage.class)
4186             .flatMap(klazz -&gt; Stream.of(klazz.getMethods()))
4187             .filter(isNotStatic)
4188             .collect(Collectors.toList());
4189         // Methods from CompletableFuture permitted NOT to throw UOE
4190         String[] signatureWhitelist = {
4191             &quot;newIncompleteFuture[]&quot;,
4192             &quot;defaultExecutor[]&quot;,
4193             &quot;minimalCompletionStage[]&quot;,
4194             &quot;copy[]&quot;,
4195         };
4196         Set&lt;String&gt; permittedMethodSignatures =
4197             Stream.concat(minimalMethods.stream().map(toSignature),
4198                           Stream.of(signatureWhitelist))
4199             .collect(Collectors.toSet());
4200         List&lt;Method&gt; allMethods = Stream.of(CompletableFuture.class.getMethods())
4201             .filter(isNotStatic)
4202             .filter(method -&gt; !permittedMethodSignatures.contains(toSignature.apply(method)))
4203             .collect(Collectors.toList());
4204 
4205         List&lt;CompletionStage&lt;Integer&gt;&gt; stages = new ArrayList&lt;&gt;();
4206         CompletionStage&lt;Integer&gt; min =
4207             new CompletableFuture&lt;Integer&gt;().minimalCompletionStage();
4208         stages.add(min);
4209         stages.add(min.thenApply(x -&gt; x));
4210         stages.add(CompletableFuture.completedStage(1));
4211         stages.add(CompletableFuture.failedStage(new CFException()));
4212 
4213         List&lt;Method&gt; bugs = new ArrayList&lt;&gt;();
4214         for (Method method : allMethods) {
4215             Class&lt;?&gt;[] parameterTypes = method.getParameterTypes();
4216             Object[] args = new Object[parameterTypes.length];
4217             // Manufacture boxed primitives for primitive params
4218             for (int i = 0; i &lt; args.length; i++) {
4219                 Class&lt;?&gt; type = parameterTypes[i];
4220                 if (parameterTypes[i] == boolean.class)
4221                     args[i] = false;
4222                 else if (parameterTypes[i] == int.class)
4223                     args[i] = 0;
4224                 else if (parameterTypes[i] == long.class)
4225                     args[i] = 0L;
4226             }
4227             for (CompletionStage&lt;Integer&gt; stage : stages) {
4228                 try {
4229                     method.invoke(stage, args);
4230                     bugs.add(method);
4231                 }
4232                 catch (java.lang.reflect.InvocationTargetException expected) {
4233                     if (! (expected.getCause() instanceof UnsupportedOperationException)) {
4234                         bugs.add(method);
4235                         // expected.getCause().printStackTrace();
4236                     }
4237                 }
4238                 catch (ReflectiveOperationException bad) { throw new Error(bad); }
4239             }
4240         }
4241         if (!bugs.isEmpty())
4242             throw new Error(&quot;Methods did not throw UOE: &quot; + bugs);
4243     }
4244 
4245     /**
4246      * minimalStage.toCompletableFuture() returns a CompletableFuture that
4247      * is completed normally, with the same value, when source is.
4248      */
4249     public void testMinimalCompletionStage_toCompletableFuture_normalCompletion() {
4250         for (boolean createIncomplete : new boolean[] { true, false })
4251         for (Integer v1 : new Integer[] { 1, null })
4252     {
4253         CompletableFuture&lt;Integer&gt; f = new CompletableFuture&lt;&gt;();
4254         CompletionStage&lt;Integer&gt; minimal = f.minimalCompletionStage();
4255         if (!createIncomplete) assertTrue(f.complete(v1));
4256         CompletableFuture&lt;Integer&gt; g = minimal.toCompletableFuture();
4257         if (createIncomplete) {
4258             checkIncomplete(f);
4259             checkIncomplete(g);
4260             assertTrue(f.complete(v1));
4261         }
4262         checkCompletedNormally(f, v1);
4263         checkCompletedNormally(g, v1);
4264     }}
4265 
4266     /**
4267      * minimalStage.toCompletableFuture() returns a CompletableFuture that
4268      * is completed exceptionally when source is.
4269      */
4270     public void testMinimalCompletionStage_toCompletableFuture_exceptionalCompletion() {
4271         for (boolean createIncomplete : new boolean[] { true, false })
4272     {
4273         CFException ex = new CFException();
4274         CompletableFuture&lt;Integer&gt; f = new CompletableFuture&lt;&gt;();
4275         CompletionStage&lt;Integer&gt; minimal = f.minimalCompletionStage();
4276         if (!createIncomplete) f.completeExceptionally(ex);
4277         CompletableFuture&lt;Integer&gt; g = minimal.toCompletableFuture();
4278         if (createIncomplete) {
4279             checkIncomplete(f);
4280             checkIncomplete(g);
4281             f.completeExceptionally(ex);
4282         }
4283         checkCompletedExceptionally(f, ex);
4284         checkCompletedWithWrappedException(g, ex);
4285     }}
4286 
4287     /**
4288      * minimalStage.toCompletableFuture() gives mutable CompletableFuture
4289      */
4290     public void testMinimalCompletionStage_toCompletableFuture_mutable() {
4291         for (Integer v1 : new Integer[] { 1, null })
4292     {
4293         CompletableFuture&lt;Integer&gt; f = new CompletableFuture&lt;&gt;();
4294         CompletionStage minimal = f.minimalCompletionStage();
4295         CompletableFuture&lt;Integer&gt; g = minimal.toCompletableFuture();
4296         assertTrue(g.complete(v1));
4297         checkCompletedNormally(g, v1);
4298         checkIncomplete(f);
4299         checkIncomplete(minimal.toCompletableFuture());
4300     }}
4301 
4302     /**
4303      * minimalStage.toCompletableFuture().join() awaits completion
4304      */
4305     public void testMinimalCompletionStage_toCompletableFuture_join() throws Exception {
4306         for (boolean createIncomplete : new boolean[] { true, false })
4307         for (Integer v1 : new Integer[] { 1, null })
4308     {
4309         CompletableFuture&lt;Integer&gt; f = new CompletableFuture&lt;&gt;();
4310         if (!createIncomplete) assertTrue(f.complete(v1));
4311         CompletionStage&lt;Integer&gt; minimal = f.minimalCompletionStage();
4312         if (createIncomplete) assertTrue(f.complete(v1));
4313         assertEquals(v1, minimal.toCompletableFuture().join());
4314         assertEquals(v1, minimal.toCompletableFuture().get());
4315         checkCompletedNormally(minimal.toCompletableFuture(), v1);
4316     }}
4317 
4318     /**
4319      * Completion of a toCompletableFuture copy of a minimal stage
4320      * does not complete its source.
4321      */
4322     public void testMinimalCompletionStage_toCompletableFuture_oneWayPropagation() {
4323         CompletableFuture&lt;Integer&gt; f = new CompletableFuture&lt;&gt;();
4324         CompletionStage&lt;Integer&gt; g = f.minimalCompletionStage();
4325         assertTrue(g.toCompletableFuture().complete(1));
4326         assertTrue(g.toCompletableFuture().complete(null));
4327         assertTrue(g.toCompletableFuture().cancel(true));
4328         assertTrue(g.toCompletableFuture().cancel(false));
4329         assertTrue(g.toCompletableFuture().completeExceptionally(new CFException()));
4330         checkIncomplete(g.toCompletableFuture());
4331         f.complete(1);
4332         checkCompletedNormally(g.toCompletableFuture(), 1);
4333     }
4334 
4335     /** Demo utility method for external reliable toCompletableFuture */
4336     static &lt;T&gt; CompletableFuture&lt;T&gt; toCompletableFuture(CompletionStage&lt;T&gt; stage) {
4337         CompletableFuture&lt;T&gt; f = new CompletableFuture&lt;&gt;();
4338         stage.handle((T t, Throwable ex) -&gt; {
4339                          if (ex != null) f.completeExceptionally(ex);
4340                          else f.complete(t);
4341                          return null;
4342                      });
4343         return f;
4344     }
4345 
4346     /** Demo utility method to join a CompletionStage */
4347     static &lt;T&gt; T join(CompletionStage&lt;T&gt; stage) {
4348         return toCompletableFuture(stage).join();
4349     }
4350 
4351     /**
4352      * Joining a minimal stage &quot;by hand&quot; works
4353      */
4354     public void testMinimalCompletionStage_join_by_hand() {
4355         for (boolean createIncomplete : new boolean[] { true, false })
4356         for (Integer v1 : new Integer[] { 1, null })
4357     {
4358         CompletableFuture&lt;Integer&gt; f = new CompletableFuture&lt;&gt;();
4359         CompletionStage&lt;Integer&gt; minimal = f.minimalCompletionStage();
4360         CompletableFuture&lt;Integer&gt; g = new CompletableFuture&lt;&gt;();
4361         if (!createIncomplete) assertTrue(f.complete(v1));
4362         minimal.thenAccept(x -&gt; g.complete(x));
4363         if (createIncomplete) assertTrue(f.complete(v1));
4364         g.join();
4365         checkCompletedNormally(g, v1);
4366         checkCompletedNormally(f, v1);
4367         assertEquals(v1, join(minimal));
4368     }}
4369 
4370     static class Monad {
4371         static class ZeroException extends RuntimeException {
4372             public ZeroException() { super(&quot;monadic zero&quot;); }
4373         }
4374         // &quot;return&quot;, &quot;unit&quot;
4375         static &lt;T&gt; CompletableFuture&lt;T&gt; unit(T value) {
4376             return completedFuture(value);
4377         }
4378         // monadic zero ?
4379         static &lt;T&gt; CompletableFuture&lt;T&gt; zero() {
4380             return failedFuture(new ZeroException());
4381         }
4382         // &gt;=&gt;
4383         static &lt;T,U,V&gt; Function&lt;T, CompletableFuture&lt;V&gt;&gt; compose
4384             (Function&lt;T, CompletableFuture&lt;U&gt;&gt; f,
4385              Function&lt;U, CompletableFuture&lt;V&gt;&gt; g) {
4386             return x -&gt; f.apply(x).thenCompose(g);
4387         }
4388 
4389         static void assertZero(CompletableFuture&lt;?&gt; f) {
4390             try {
4391                 f.getNow(null);
4392                 throw new AssertionError(&quot;should throw&quot;);
4393             } catch (CompletionException success) {
4394                 assertTrue(success.getCause() instanceof ZeroException);
4395             }
4396         }
4397 
4398         static &lt;T&gt; void assertFutureEquals(CompletableFuture&lt;T&gt; f,
4399                                            CompletableFuture&lt;T&gt; g) {
4400             T fval = null, gval = null;
4401             Throwable fex = null, gex = null;
4402 
4403             try { fval = f.get(); }
4404             catch (ExecutionException ex) { fex = ex.getCause(); }
4405             catch (Throwable ex) { fex = ex; }
4406 
4407             try { gval = g.get(); }
4408             catch (ExecutionException ex) { gex = ex.getCause(); }
4409             catch (Throwable ex) { gex = ex; }
4410 
4411             if (fex != null || gex != null)
4412                 assertSame(fex.getClass(), gex.getClass());
4413             else
4414                 assertEquals(fval, gval);
4415         }
4416 
4417         static class PlusFuture&lt;T&gt; extends CompletableFuture&lt;T&gt; {
4418             AtomicReference&lt;Throwable&gt; firstFailure = new AtomicReference&lt;&gt;(null);
4419         }
4420 
4421         /** Implements &quot;monadic plus&quot;. */
4422         static &lt;T&gt; CompletableFuture&lt;T&gt; plus(CompletableFuture&lt;? extends T&gt; f,
4423                                              CompletableFuture&lt;? extends T&gt; g) {
4424             PlusFuture&lt;T&gt; plus = new PlusFuture&lt;T&gt;();
4425             BiConsumer&lt;T, Throwable&gt; action = (T result, Throwable ex) -&gt; {
4426                 try {
4427                     if (ex == null) {
4428                         if (plus.complete(result))
4429                             if (plus.firstFailure.get() != null)
4430                                 plus.firstFailure.set(null);
4431                     }
4432                     else if (plus.firstFailure.compareAndSet(null, ex)) {
4433                         if (plus.isDone())
4434                             plus.firstFailure.set(null);
4435                     }
4436                     else {
4437                         // first failure has precedence
4438                         Throwable first = plus.firstFailure.getAndSet(null);
4439 
4440                         // may fail with &quot;Self-suppression not permitted&quot;
4441                         try { first.addSuppressed(ex); }
4442                         catch (Exception ignored) {}
4443 
4444                         plus.completeExceptionally(first);
4445                     }
4446                 } catch (Throwable unexpected) {
4447                     plus.completeExceptionally(unexpected);
4448                 }
4449             };
4450             f.whenComplete(action);
4451             g.whenComplete(action);
4452             return plus;
4453         }
4454     }
4455 
4456     /**
4457      * CompletableFuture is an additive monad - sort of.
4458      * https://en.wikipedia.org/wiki/Monad_(functional_programming)#Additive_monads
4459      */
4460     public void testAdditiveMonad() throws Throwable {
4461         Function&lt;Long, CompletableFuture&lt;Long&gt;&gt; unit = Monad::unit;
4462         CompletableFuture&lt;Long&gt; zero = Monad.zero();
4463 
4464         // Some mutually non-commutative functions
4465         Function&lt;Long, CompletableFuture&lt;Long&gt;&gt; triple
4466             = x -&gt; Monad.unit(3 * x);
4467         Function&lt;Long, CompletableFuture&lt;Long&gt;&gt; inc
4468             = x -&gt; Monad.unit(x + 1);
4469 
4470         // unit is a right identity: m &gt;&gt;= unit === m
4471         Monad.assertFutureEquals(inc.apply(5L).thenCompose(unit),
4472                                  inc.apply(5L));
4473         // unit is a left identity: (unit x) &gt;&gt;= f === f x
4474         Monad.assertFutureEquals(unit.apply(5L).thenCompose(inc),
4475                                  inc.apply(5L));
4476 
4477         // associativity: (m &gt;&gt;= f) &gt;&gt;= g === m &gt;&gt;= ( \x -&gt; (f x &gt;&gt;= g) )
4478         Monad.assertFutureEquals(
4479             unit.apply(5L).thenCompose(inc).thenCompose(triple),
4480             unit.apply(5L).thenCompose(x -&gt; inc.apply(x).thenCompose(triple)));
4481 
4482         // The case for CompletableFuture as an additive monad is weaker...
4483 
4484         // zero is a monadic zero
4485         Monad.assertZero(zero);
4486 
4487         // left zero: zero &gt;&gt;= f === zero
4488         Monad.assertZero(zero.thenCompose(inc));
4489         // right zero: f &gt;&gt;= (\x -&gt; zero) === zero
4490         Monad.assertZero(inc.apply(5L).thenCompose(x -&gt; zero));
4491 
4492         // f plus zero === f
4493         Monad.assertFutureEquals(Monad.unit(5L),
4494                                  Monad.plus(Monad.unit(5L), zero));
4495         // zero plus f === f
4496         Monad.assertFutureEquals(Monad.unit(5L),
4497                                  Monad.plus(zero, Monad.unit(5L)));
4498         // zero plus zero === zero
4499         Monad.assertZero(Monad.plus(zero, zero));
4500         {
4501             CompletableFuture&lt;Long&gt; f = Monad.plus(Monad.unit(5L),
4502                                                    Monad.unit(8L));
4503             // non-determinism
4504             assertTrue(f.get() == 5L || f.get() == 8L);
4505         }
4506 
4507         CompletableFuture&lt;Long&gt; godot = new CompletableFuture&lt;&gt;();
4508         // f plus godot === f (doesn&#39;t wait for godot)
4509         Monad.assertFutureEquals(Monad.unit(5L),
4510                                  Monad.plus(Monad.unit(5L), godot));
4511         // godot plus f === f (doesn&#39;t wait for godot)
4512         Monad.assertFutureEquals(Monad.unit(5L),
4513                                  Monad.plus(godot, Monad.unit(5L)));
4514     }
4515 
4516     /** Test long recursive chains of CompletableFutures with cascading completions */
4517     @SuppressWarnings(&quot;FutureReturnValueIgnored&quot;)
4518     public void testRecursiveChains() throws Throwable {
4519         for (ExecutionMode m : ExecutionMode.values())
4520         for (boolean addDeadEnds : new boolean[] { true, false })
4521     {
4522         final int val = 42;
4523         final int n = expensiveTests ? 1_000 : 2;
4524         CompletableFuture&lt;Integer&gt; head = new CompletableFuture&lt;&gt;();
4525         CompletableFuture&lt;Integer&gt; tail = head;
4526         for (int i = 0; i &lt; n; i++) {
4527             if (addDeadEnds) m.thenApply(tail, v -&gt; v + 1);
4528             tail = m.thenApply(tail, v -&gt; v + 1);
4529             if (addDeadEnds) m.applyToEither(tail, tail, v -&gt; v + 1);
4530             tail = m.applyToEither(tail, tail, v -&gt; v + 1);
4531             if (addDeadEnds) m.thenCombine(tail, tail, (v, w) -&gt; v + 1);
4532             tail = m.thenCombine(tail, tail, (v, w) -&gt; v + 1);
4533         }
4534         head.complete(val);
4535         assertEquals(val + 3 * n, (int) tail.join());
4536     }}
4537 
4538     /**
4539      * A single CompletableFuture with many dependents.
4540      * A demo of scalability - runtime is O(n).
4541      */
4542     @SuppressWarnings(&quot;FutureReturnValueIgnored&quot;)
4543     public void testManyDependents() throws Throwable {
4544         final int n = expensiveTests ? 1_000_000 : 10;
4545         final CompletableFuture&lt;Void&gt; head = new CompletableFuture&lt;&gt;();
4546         final CompletableFuture&lt;Void&gt; complete = CompletableFuture.completedFuture((Void)null);
4547         final AtomicInteger count = new AtomicInteger(0);
4548         for (int i = 0; i &lt; n; i++) {
4549             head.thenRun(() -&gt; count.getAndIncrement());
4550             head.thenAccept(x -&gt; count.getAndIncrement());
4551             head.thenApply(x -&gt; count.getAndIncrement());
4552 
4553             head.runAfterBoth(complete, () -&gt; count.getAndIncrement());
4554             head.thenAcceptBoth(complete, (x, y) -&gt; count.getAndIncrement());
4555             head.thenCombine(complete, (x, y) -&gt; count.getAndIncrement());
4556             complete.runAfterBoth(head, () -&gt; count.getAndIncrement());
4557             complete.thenAcceptBoth(head, (x, y) -&gt; count.getAndIncrement());
4558             complete.thenCombine(head, (x, y) -&gt; count.getAndIncrement());
4559 
4560             head.runAfterEither(new CompletableFuture&lt;Void&gt;(), () -&gt; count.getAndIncrement());
4561             head.acceptEither(new CompletableFuture&lt;Void&gt;(), x -&gt; count.getAndIncrement());
4562             head.applyToEither(new CompletableFuture&lt;Void&gt;(), x -&gt; count.getAndIncrement());
4563             new CompletableFuture&lt;Void&gt;().runAfterEither(head, () -&gt; count.getAndIncrement());
4564             new CompletableFuture&lt;Void&gt;().acceptEither(head, x -&gt; count.getAndIncrement());
4565             new CompletableFuture&lt;Void&gt;().applyToEither(head, x -&gt; count.getAndIncrement());
4566         }
4567         head.complete(null);
4568         assertEquals(5 * 3 * n, count.get());
4569     }
4570 
4571     /** ant -Dvmoptions=-Xmx8m -Djsr166.expensiveTests=true -Djsr166.tckTestClass=CompletableFutureTest tck */
4572     @SuppressWarnings(&quot;FutureReturnValueIgnored&quot;)
4573     public void testCoCompletionGarbageRetention() throws Throwable {
4574         final int n = expensiveTests ? 1_000_000 : 10;
4575         final CompletableFuture&lt;Integer&gt; incomplete = new CompletableFuture&lt;&gt;();
4576         CompletableFuture&lt;Integer&gt; f;
4577         for (int i = 0; i &lt; n; i++) {
4578             f = new CompletableFuture&lt;&gt;();
4579             f.runAfterEither(incomplete, () -&gt; {});
4580             f.complete(null);
4581 
4582             f = new CompletableFuture&lt;&gt;();
4583             f.acceptEither(incomplete, x -&gt; {});
4584             f.complete(null);
4585 
4586             f = new CompletableFuture&lt;&gt;();
4587             f.applyToEither(incomplete, x -&gt; x);
4588             f.complete(null);
4589 
4590             f = new CompletableFuture&lt;&gt;();
4591             CompletableFuture.anyOf(f, incomplete);
4592             f.complete(null);
4593         }
4594 
4595         for (int i = 0; i &lt; n; i++) {
4596             f = new CompletableFuture&lt;&gt;();
4597             incomplete.runAfterEither(f, () -&gt; {});
4598             f.complete(null);
4599 
4600             f = new CompletableFuture&lt;&gt;();
4601             incomplete.acceptEither(f, x -&gt; {});
4602             f.complete(null);
4603 
4604             f = new CompletableFuture&lt;&gt;();
4605             incomplete.applyToEither(f, x -&gt; x);
4606             f.complete(null);
4607 
4608             f = new CompletableFuture&lt;&gt;();
4609             CompletableFuture.anyOf(incomplete, f);
4610             f.complete(null);
4611         }
4612     }
4613 
4614     /**
4615      * Reproduction recipe for:
4616      * 8160402: Garbage retention with CompletableFuture.anyOf
4617      * cvs update -D &#39;2016-05-01&#39; ./src/main/java/util/concurrent/CompletableFuture.java &amp;&amp; ant -Dvmoptions=-Xmx8m -Djsr166.expensiveTests=true -Djsr166.tckTestClass=CompletableFutureTest -Djsr166.methodFilter=testAnyOfGarbageRetention tck; cvs update -A
4618      */
4619     public void testAnyOfGarbageRetention() throws Throwable {
4620         for (Integer v : new Integer[] { 1, null })
4621     {
4622         final int n = expensiveTests ? 100_000 : 10;
4623         CompletableFuture&lt;Integer&gt;[] fs
4624             = (CompletableFuture&lt;Integer&gt;[]) new CompletableFuture&lt;?&gt;[100];
4625         for (int i = 0; i &lt; fs.length; i++)
4626             fs[i] = new CompletableFuture&lt;&gt;();
4627         fs[fs.length - 1].complete(v);
4628         for (int i = 0; i &lt; n; i++)
4629             checkCompletedNormally(CompletableFuture.anyOf(fs), v);
4630     }}
4631 
4632     /**
4633      * Checks for garbage retention with allOf.
4634      *
4635      * As of 2016-07, fails with OOME:
4636      * ant -Dvmoptions=-Xmx8m -Djsr166.expensiveTests=true -Djsr166.tckTestClass=CompletableFutureTest -Djsr166.methodFilter=testCancelledAllOfGarbageRetention tck
4637      */
4638     public void testCancelledAllOfGarbageRetention() throws Throwable {
4639         final int n = expensiveTests ? 100_000 : 10;
4640         CompletableFuture&lt;Integer&gt;[] fs
4641             = (CompletableFuture&lt;Integer&gt;[]) new CompletableFuture&lt;?&gt;[100];
4642         for (int i = 0; i &lt; fs.length; i++)
4643             fs[i] = new CompletableFuture&lt;&gt;();
4644         for (int i = 0; i &lt; n; i++)
4645             assertTrue(CompletableFuture.allOf(fs).cancel(false));
4646     }
4647 
4648     /**
4649      * Checks for garbage retention when a dependent future is
4650      * cancelled and garbage-collected.
4651      * 8161600: Garbage retention when source CompletableFutures are never completed
4652      *
4653      * As of 2016-07, fails with OOME:
4654      * ant -Dvmoptions=-Xmx8m -Djsr166.expensiveTests=true -Djsr166.tckTestClass=CompletableFutureTest -Djsr166.methodFilter=testCancelledGarbageRetention tck
4655      */
4656     public void testCancelledGarbageRetention() throws Throwable {
4657         final int n = expensiveTests ? 100_000 : 10;
4658         CompletableFuture&lt;Integer&gt; neverCompleted = new CompletableFuture&lt;&gt;();
4659         for (int i = 0; i &lt; n; i++)
4660             assertTrue(neverCompleted.thenRun(() -&gt; {}).cancel(true));
4661     }
4662 
4663     /**
4664      * Checks for garbage retention when MinimalStage.toCompletableFuture()
4665      * is invoked many times.
4666      * 8161600: Garbage retention when source CompletableFutures are never completed
4667      *
4668      * As of 2016-07, fails with OOME:
4669      * ant -Dvmoptions=-Xmx8m -Djsr166.expensiveTests=true -Djsr166.tckTestClass=CompletableFutureTest -Djsr166.methodFilter=testToCompletableFutureGarbageRetention tck
4670      */
4671     public void testToCompletableFutureGarbageRetention() throws Throwable {
4672         final int n = expensiveTests ? 900_000 : 10;
4673         CompletableFuture&lt;Integer&gt; neverCompleted = new CompletableFuture&lt;&gt;();
4674         CompletionStage minimal = neverCompleted.minimalCompletionStage();
4675         for (int i = 0; i &lt; n; i++)
4676             assertTrue(minimal.toCompletableFuture().cancel(true));
4677     }
4678 
4679 //     static &lt;U&gt; U join(CompletionStage&lt;U&gt; stage) {
4680 //         CompletableFuture&lt;U&gt; f = new CompletableFuture&lt;&gt;();
4681 //         stage.whenComplete((v, ex) -&gt; {
4682 //             if (ex != null) f.completeExceptionally(ex); else f.complete(v);
4683 //         });
4684 //         return f.join();
4685 //     }
4686 
4687 //     static &lt;U&gt; boolean isDone(CompletionStage&lt;U&gt; stage) {
4688 //         CompletableFuture&lt;U&gt; f = new CompletableFuture&lt;&gt;();
4689 //         stage.whenComplete((v, ex) -&gt; {
4690 //             if (ex != null) f.completeExceptionally(ex); else f.complete(v);
4691 //         });
4692 //         return f.isDone();
4693 //     }
4694 
4695 //     static &lt;U&gt; U join2(CompletionStage&lt;U&gt; stage) {
4696 //         return stage.toCompletableFuture().copy().join();
4697 //     }
4698 
4699 //     static &lt;U&gt; boolean isDone2(CompletionStage&lt;U&gt; stage) {
4700 //         return stage.toCompletableFuture().copy().isDone();
4701 //     }
4702 
4703     // For testing default implementations
4704     // Only non-default interface methods defined.
4705     static final class DelegatedCompletionStage&lt;T&gt; implements CompletionStage&lt;T&gt; {
4706         final CompletableFuture&lt;T&gt; cf;
4707         DelegatedCompletionStage(CompletableFuture&lt;T&gt; cf) { this.cf = cf; }
4708         public CompletableFuture&lt;T&gt; toCompletableFuture() {
4709             return cf; }
4710         public CompletionStage&lt;Void&gt; thenRun
4711             (Runnable action) {
4712             return cf.thenRun(action); }
4713         public CompletionStage&lt;Void&gt; thenRunAsync
4714             (Runnable action) {
4715             return cf.thenRunAsync(action); }
4716         public CompletionStage&lt;Void&gt; thenRunAsync
4717             (Runnable action,
4718              Executor executor) {
4719             return cf.thenRunAsync(action, executor); }
4720         public CompletionStage&lt;Void&gt; thenAccept
4721             (Consumer&lt;? super T&gt; action) {
4722             return cf.thenAccept(action); }
4723         public CompletionStage&lt;Void&gt; thenAcceptAsync
4724             (Consumer&lt;? super T&gt; action) {
4725             return cf.thenAcceptAsync(action); }
4726         public CompletionStage&lt;Void&gt; thenAcceptAsync
4727             (Consumer&lt;? super T&gt; action,
4728              Executor executor) {
4729             return cf.thenAcceptAsync(action, executor); }
4730         public &lt;U&gt; CompletionStage&lt;U&gt; thenApply
4731             (Function&lt;? super T,? extends U&gt; a) {
4732             return cf.thenApply(a); }
4733         public &lt;U&gt; CompletionStage&lt;U&gt; thenApplyAsync
4734             (Function&lt;? super T,? extends U&gt; fn) {
4735             return cf.thenApplyAsync(fn); }
4736         public &lt;U&gt; CompletionStage&lt;U&gt; thenApplyAsync
4737             (Function&lt;? super T,? extends U&gt; fn,
4738              Executor executor) {
4739             return cf.thenApplyAsync(fn, executor); }
4740         public &lt;U,V&gt; CompletionStage&lt;V&gt; thenCombine
4741             (CompletionStage&lt;? extends U&gt; other,
4742              BiFunction&lt;? super T,? super U,? extends V&gt; fn) {
4743             return cf.thenCombine(other, fn); }
4744         public &lt;U,V&gt; CompletionStage&lt;V&gt; thenCombineAsync
4745             (CompletionStage&lt;? extends U&gt; other,
4746              BiFunction&lt;? super T,? super U,? extends V&gt; fn) {
4747             return cf.thenCombineAsync(other, fn); }
4748         public &lt;U,V&gt; CompletionStage&lt;V&gt; thenCombineAsync
4749             (CompletionStage&lt;? extends U&gt; other,
4750              BiFunction&lt;? super T,? super U,? extends V&gt; fn,
4751              Executor executor) {
4752             return cf.thenCombineAsync(other, fn, executor); }
4753         public &lt;U&gt; CompletionStage&lt;Void&gt; thenAcceptBoth
4754             (CompletionStage&lt;? extends U&gt; other,
4755              BiConsumer&lt;? super T, ? super U&gt; action) {
4756             return cf.thenAcceptBoth(other, action); }
4757         public &lt;U&gt; CompletionStage&lt;Void&gt; thenAcceptBothAsync
4758             (CompletionStage&lt;? extends U&gt; other,
4759              BiConsumer&lt;? super T, ? super U&gt; action) {
4760             return cf.thenAcceptBothAsync(other, action); }
4761         public &lt;U&gt; CompletionStage&lt;Void&gt; thenAcceptBothAsync
4762             (CompletionStage&lt;? extends U&gt; other,
4763              BiConsumer&lt;? super T, ? super U&gt; action,
4764              Executor executor) {
4765             return cf.thenAcceptBothAsync(other, action, executor); }
4766         public CompletionStage&lt;Void&gt; runAfterBoth
4767             (CompletionStage&lt;?&gt; other,
4768              Runnable action) {
4769             return cf.runAfterBoth(other, action); }
4770         public CompletionStage&lt;Void&gt; runAfterBothAsync
4771             (CompletionStage&lt;?&gt; other,
4772              Runnable action) {
4773             return cf.runAfterBothAsync(other, action); }
4774         public CompletionStage&lt;Void&gt; runAfterBothAsync
4775             (CompletionStage&lt;?&gt; other,
4776              Runnable action,
4777              Executor executor) {
4778             return cf.runAfterBothAsync(other, action, executor); }
4779         public &lt;U&gt; CompletionStage&lt;U&gt; applyToEither
4780             (CompletionStage&lt;? extends T&gt; other,
4781              Function&lt;? super T, U&gt; fn) {
4782             return cf.applyToEither(other, fn); }
4783         public &lt;U&gt; CompletionStage&lt;U&gt; applyToEitherAsync
4784             (CompletionStage&lt;? extends T&gt; other,
4785              Function&lt;? super T, U&gt; fn) {
4786             return cf.applyToEitherAsync(other, fn); }
4787         public &lt;U&gt; CompletionStage&lt;U&gt; applyToEitherAsync
4788             (CompletionStage&lt;? extends T&gt; other,
4789              Function&lt;? super T, U&gt; fn,
4790              Executor executor) {
4791             return cf.applyToEitherAsync(other, fn, executor); }
4792         public CompletionStage&lt;Void&gt; acceptEither
4793             (CompletionStage&lt;? extends T&gt; other,
4794              Consumer&lt;? super T&gt; action) {
4795             return cf.acceptEither(other, action); }
4796         public CompletionStage&lt;Void&gt; acceptEitherAsync
4797             (CompletionStage&lt;? extends T&gt; other,
4798              Consumer&lt;? super T&gt; action) {
4799             return cf.acceptEitherAsync(other, action); }
4800         public CompletionStage&lt;Void&gt; acceptEitherAsync
4801             (CompletionStage&lt;? extends T&gt; other,
4802              Consumer&lt;? super T&gt; action,
4803              Executor executor) {
4804             return cf.acceptEitherAsync(other, action, executor); }
4805         public CompletionStage&lt;Void&gt; runAfterEither
4806             (CompletionStage&lt;?&gt; other,
4807              Runnable action) {
4808             return cf.runAfterEither(other, action); }
4809         public CompletionStage&lt;Void&gt; runAfterEitherAsync
4810             (CompletionStage&lt;?&gt; other,
4811              Runnable action) {
4812             return cf.runAfterEitherAsync(other, action); }
4813         public CompletionStage&lt;Void&gt; runAfterEitherAsync
4814             (CompletionStage&lt;?&gt; other,
4815              Runnable action,
4816              Executor executor) {
4817             return cf.runAfterEitherAsync(other, action, executor); }
4818         public &lt;U&gt; CompletionStage&lt;U&gt; thenCompose
4819             (Function&lt;? super T, ? extends CompletionStage&lt;U&gt;&gt; fn) {
4820             return cf.thenCompose(fn); }
4821         public &lt;U&gt; CompletionStage&lt;U&gt; thenComposeAsync
4822             (Function&lt;? super T, ? extends CompletionStage&lt;U&gt;&gt; fn) {
4823             return cf.thenComposeAsync(fn); }
4824         public &lt;U&gt; CompletionStage&lt;U&gt; thenComposeAsync
4825             (Function&lt;? super T, ? extends CompletionStage&lt;U&gt;&gt; fn,
4826              Executor executor) {
4827             return cf.thenComposeAsync(fn, executor); }
4828         public &lt;U&gt; CompletionStage&lt;U&gt; handle
4829             (BiFunction&lt;? super T, Throwable, ? extends U&gt; fn) {
4830             return cf.handle(fn); }
4831         public &lt;U&gt; CompletionStage&lt;U&gt; handleAsync
4832             (BiFunction&lt;? super T, Throwable, ? extends U&gt; fn) {
4833             return cf.handleAsync(fn); }
4834         public &lt;U&gt; CompletionStage&lt;U&gt; handleAsync
4835             (BiFunction&lt;? super T, Throwable, ? extends U&gt; fn,
4836              Executor executor) {
4837             return cf.handleAsync(fn, executor); }
4838         public CompletionStage&lt;T&gt; whenComplete
4839             (BiConsumer&lt;? super T, ? super Throwable&gt; action) {
4840             return cf.whenComplete(action); }
4841         public CompletionStage&lt;T&gt; whenCompleteAsync
4842             (BiConsumer&lt;? super T, ? super Throwable&gt; action) {
4843             return cf.whenCompleteAsync(action); }
4844         public CompletionStage&lt;T&gt; whenCompleteAsync
4845             (BiConsumer&lt;? super T, ? super Throwable&gt; action,
4846              Executor executor) {
4847             return cf.whenCompleteAsync(action, executor); }
4848         public CompletionStage&lt;T&gt; exceptionally
4849             (Function&lt;Throwable, ? extends T&gt; fn) {
4850             return cf.exceptionally(fn); }
4851     }
4852 
4853     /**
4854      * default-implemented exceptionallyAsync action is not invoked when
4855      * source completes normally, and source result is propagated
4856      */
4857     public void testDefaultExceptionallyAsync_normalCompletion() {
4858         for (boolean createIncomplete : new boolean[] { true, false })
4859         for (Integer v1 : new Integer[] { 1, null })
4860     {
4861         final AtomicInteger ran = new AtomicInteger(0);
4862         final CompletableFuture&lt;Integer&gt; f = new CompletableFuture&lt;&gt;();
4863         final DelegatedCompletionStage&lt;Integer&gt; d =
4864             new DelegatedCompletionStage&lt;Integer&gt;(f);
4865         if (!createIncomplete) assertTrue(f.complete(v1));
4866         final CompletionStage&lt;Integer&gt; g = d.exceptionallyAsync
4867             ((Throwable t) -&gt; {
4868                 ran.getAndIncrement();
4869                 throw new AssertionError(&quot;should not be called&quot;);
4870             });
4871         if (createIncomplete) assertTrue(f.complete(v1));
4872 
4873         checkCompletedNormally(g.toCompletableFuture(), v1);
4874         checkCompletedNormally(f, v1);
4875         assertEquals(0, ran.get());
4876     }}
4877 
4878     /**
4879      * default-implemented exceptionallyAsync action completes with
4880      * function value on source exception
4881      */
4882     public void testDefaultExceptionallyAsync_exceptionalCompletion() {
4883         for (boolean createIncomplete : new boolean[] { true, false })
4884         for (Integer v1 : new Integer[] { 1, null })
4885     {
4886         final AtomicInteger ran = new AtomicInteger(0);
4887         final CFException ex = new CFException();
4888         final CompletableFuture&lt;Integer&gt; f = new CompletableFuture&lt;&gt;();
4889         final DelegatedCompletionStage&lt;Integer&gt; d =
4890             new DelegatedCompletionStage&lt;Integer&gt;(f);
4891         if (!createIncomplete) f.completeExceptionally(ex);
4892         final CompletionStage&lt;Integer&gt; g = d.exceptionallyAsync
4893             ((Throwable t) -&gt; {
4894                 assertSame(t, ex);
4895                 ran.getAndIncrement();
4896                 return v1;
4897             });
4898         if (createIncomplete) f.completeExceptionally(ex);
4899 
4900         checkCompletedNormally(g.toCompletableFuture(), v1);
4901         checkCompletedExceptionally(f, ex);
4902         assertEquals(1, ran.get());
4903     }}
4904 
4905     /**
4906      * Under default implementation, if an &quot;exceptionally action&quot;
4907      * throws an exception, it completes exceptionally with that
4908      * exception
4909      */
4910     public void testDefaultExceptionallyAsync_exceptionalCompletionActionFailed() {
4911         for (boolean createIncomplete : new boolean[] { true, false })
4912     {
4913         final AtomicInteger ran = new AtomicInteger(0);
4914         final CFException ex1 = new CFException();
4915         final CFException ex2 = new CFException();
4916         final CompletableFuture&lt;Integer&gt; f = new CompletableFuture&lt;&gt;();
4917         final DelegatedCompletionStage&lt;Integer&gt; d =
4918             new DelegatedCompletionStage&lt;Integer&gt;(f);
4919         if (!createIncomplete) f.completeExceptionally(ex1);
4920         final CompletionStage&lt;Integer&gt; g = d.exceptionallyAsync
4921             ((Throwable t) -&gt; {
4922                 assertSame(t, ex1);
4923                 ran.getAndIncrement();
4924                 throw ex2;
4925             });
4926         if (createIncomplete) f.completeExceptionally(ex1);
4927 
4928         checkCompletedWithWrappedException(g.toCompletableFuture(), ex2);
4929         checkCompletedExceptionally(f, ex1);
4930         checkCompletedExceptionally(d.toCompletableFuture(), ex1);
4931         assertEquals(1, ran.get());
4932     }}
4933 
4934     /**
4935      * default-implemented exceptionallyCompose result completes
4936      * normally after normal completion of source
4937      */
4938     public void testDefaultExceptionallyCompose_normalCompletion() {
4939         for (boolean createIncomplete : new boolean[] { true, false })
4940         for (Integer v1 : new Integer[] { 1, null })
4941     {
4942         final CompletableFuture&lt;Integer&gt; f = new CompletableFuture&lt;&gt;();
4943         final ExceptionalCompletableFutureFunction r =
4944             new ExceptionalCompletableFutureFunction(ExecutionMode.SYNC);
4945         final DelegatedCompletionStage&lt;Integer&gt; d =
4946             new DelegatedCompletionStage&lt;Integer&gt;(f);
4947         if (!createIncomplete) assertTrue(f.complete(v1));
4948         final CompletionStage&lt;Integer&gt; g = d.exceptionallyCompose(r);
4949         if (createIncomplete) assertTrue(f.complete(v1));
4950 
4951         checkCompletedNormally(f, v1);
4952         checkCompletedNormally(g.toCompletableFuture(), v1);
4953         r.assertNotInvoked();
4954     }}
4955 
4956     /**
4957      * default-implemented exceptionallyCompose result completes
4958      * normally after exceptional completion of source
4959      */
4960     public void testDefaultExceptionallyCompose_exceptionalCompletion() {
4961         for (boolean createIncomplete : new boolean[] { true, false })
4962     {
4963         final CFException ex = new CFException();
4964         final ExceptionalCompletableFutureFunction r =
4965             new ExceptionalCompletableFutureFunction(ExecutionMode.SYNC);
4966         final CompletableFuture&lt;Integer&gt; f = new CompletableFuture&lt;&gt;();
4967         final DelegatedCompletionStage&lt;Integer&gt; d =
4968             new DelegatedCompletionStage&lt;Integer&gt;(f);
4969         if (!createIncomplete) f.completeExceptionally(ex);
4970         final CompletionStage&lt;Integer&gt; g = d.exceptionallyCompose(r);
4971         if (createIncomplete) f.completeExceptionally(ex);
4972 
4973         checkCompletedExceptionally(f, ex);
4974         checkCompletedNormally(g.toCompletableFuture(), r.value);
4975         r.assertInvoked();
4976     }}
4977 
4978     /**
4979      * default-implemented exceptionallyCompose completes
4980      * exceptionally on exception if action does
4981      */
4982     public void testDefaultExceptionallyCompose_actionFailed() {
4983         for (boolean createIncomplete : new boolean[] { true, false })
4984     {
4985         final CFException ex = new CFException();
4986         final CompletableFuture&lt;Integer&gt; f = new CompletableFuture&lt;&gt;();
4987         final FailingExceptionalCompletableFutureFunction r
4988             = new FailingExceptionalCompletableFutureFunction(ExecutionMode.SYNC);
4989         final DelegatedCompletionStage&lt;Integer&gt; d =
4990             new DelegatedCompletionStage&lt;Integer&gt;(f);
4991         if (!createIncomplete) f.completeExceptionally(ex);
4992         final CompletionStage&lt;Integer&gt; g = d.exceptionallyCompose(r);
4993         if (createIncomplete) f.completeExceptionally(ex);
4994 
4995         checkCompletedExceptionally(f, ex);
4996         checkCompletedWithWrappedException(g.toCompletableFuture(), r.ex);
4997         r.assertInvoked();
4998     }}
4999 
5000     /**
5001      * default-implemented exceptionallyComposeAsync result completes
5002      * normally after normal completion of source
5003      */
5004     public void testDefaultExceptionallyComposeAsync_normalCompletion() {
5005         for (boolean createIncomplete : new boolean[] { true, false })
5006         for (Integer v1 : new Integer[] { 1, null })
5007     {
5008         final CompletableFuture&lt;Integer&gt; f = new CompletableFuture&lt;&gt;();
5009         final ExceptionalCompletableFutureFunction r =
5010             new ExceptionalCompletableFutureFunction(ExecutionMode.ASYNC);
5011         final DelegatedCompletionStage&lt;Integer&gt; d =
5012             new DelegatedCompletionStage&lt;Integer&gt;(f);
5013         if (!createIncomplete) assertTrue(f.complete(v1));
5014         final CompletionStage&lt;Integer&gt; g = d.exceptionallyComposeAsync(r);
5015         if (createIncomplete) assertTrue(f.complete(v1));
5016 
5017         checkCompletedNormally(f, v1);
5018         checkCompletedNormally(g.toCompletableFuture(), v1);
5019         r.assertNotInvoked();
5020     }}
5021 
5022     /**
5023      * default-implemented exceptionallyComposeAsync result completes
5024      * normally after exceptional completion of source
5025      */
5026     public void testDefaultExceptionallyComposeAsync_exceptionalCompletion() {
5027         for (boolean createIncomplete : new boolean[] { true, false })
5028     {
5029         final CFException ex = new CFException();
5030         final ExceptionalCompletableFutureFunction r =
5031             new ExceptionalCompletableFutureFunction(ExecutionMode.ASYNC);
5032         final CompletableFuture&lt;Integer&gt; f = new CompletableFuture&lt;&gt;();
5033         final DelegatedCompletionStage&lt;Integer&gt; d =
5034             new DelegatedCompletionStage&lt;Integer&gt;(f);
5035         if (!createIncomplete) f.completeExceptionally(ex);
5036         final CompletionStage&lt;Integer&gt; g = d.exceptionallyComposeAsync(r);
5037         if (createIncomplete) f.completeExceptionally(ex);
5038 
5039         checkCompletedExceptionally(f, ex);
5040         checkCompletedNormally(g.toCompletableFuture(), r.value);
5041         r.assertInvoked();
5042     }}
5043 
5044     /**
5045      * default-implemented exceptionallyComposeAsync completes
5046      * exceptionally on exception if action does
5047      */
5048     public void testDefaultExceptionallyComposeAsync_actionFailed() {
5049         for (boolean createIncomplete : new boolean[] { true, false })
5050     {
5051         final CFException ex = new CFException();
5052         final CompletableFuture&lt;Integer&gt; f = new CompletableFuture&lt;&gt;();
5053         final FailingExceptionalCompletableFutureFunction r
5054             = new FailingExceptionalCompletableFutureFunction(ExecutionMode.ASYNC);
5055         final DelegatedCompletionStage&lt;Integer&gt; d =
5056             new DelegatedCompletionStage&lt;Integer&gt;(f);
5057         if (!createIncomplete) f.completeExceptionally(ex);
5058         final CompletionStage&lt;Integer&gt; g = d.exceptionallyComposeAsync(r);
5059         if (createIncomplete) f.completeExceptionally(ex);
5060 
5061         checkCompletedExceptionally(f, ex);
5062         checkCompletedWithWrappedException(g.toCompletableFuture(), r.ex);
5063         r.assertInvoked();
5064     }}
5065 
5066     /**
5067      * default-implemented exceptionallyComposeAsync result completes
5068      * normally after normal completion of source
5069      */
5070     public void testDefaultExceptionallyComposeAsyncExecutor_normalCompletion() {
5071         for (boolean createIncomplete : new boolean[] { true, false })
5072         for (Integer v1 : new Integer[] { 1, null })
5073     {
5074         final CompletableFuture&lt;Integer&gt; f = new CompletableFuture&lt;&gt;();
5075         final ExceptionalCompletableFutureFunction r =
5076             new ExceptionalCompletableFutureFunction(ExecutionMode.EXECUTOR);
5077         final DelegatedCompletionStage&lt;Integer&gt; d =
5078             new DelegatedCompletionStage&lt;Integer&gt;(f);
5079         if (!createIncomplete) assertTrue(f.complete(v1));
5080         final CompletionStage&lt;Integer&gt; g = d.exceptionallyComposeAsync(r, new ThreadExecutor());
5081         if (createIncomplete) assertTrue(f.complete(v1));
5082 
5083         checkCompletedNormally(f, v1);
5084         checkCompletedNormally(g.toCompletableFuture(), v1);
5085         r.assertNotInvoked();
5086     }}
5087 
5088     /**
5089      * default-implemented exceptionallyComposeAsync result completes
5090      * normally after exceptional completion of source
5091      */
5092     public void testDefaultExceptionallyComposeAsyncExecutor_exceptionalCompletion() {
5093         for (boolean createIncomplete : new boolean[] { true, false })
5094     {
5095         final CFException ex = new CFException();
5096         final ExceptionalCompletableFutureFunction r =
5097             new ExceptionalCompletableFutureFunction(ExecutionMode.EXECUTOR);
5098         final CompletableFuture&lt;Integer&gt; f = new CompletableFuture&lt;&gt;();
5099         final DelegatedCompletionStage&lt;Integer&gt; d =
5100             new DelegatedCompletionStage&lt;Integer&gt;(f);
5101         if (!createIncomplete) f.completeExceptionally(ex);
5102         final CompletionStage&lt;Integer&gt; g = d.exceptionallyComposeAsync(r, new ThreadExecutor());
5103         if (createIncomplete) f.completeExceptionally(ex);
5104 
5105         checkCompletedExceptionally(f, ex);
5106         checkCompletedNormally(g.toCompletableFuture(), r.value);
5107         r.assertInvoked();
5108     }}
5109 
5110     /**
5111      * default-implemented exceptionallyComposeAsync completes
5112      * exceptionally on exception if action does
5113      */
5114     public void testDefaultExceptionallyComposeAsyncExecutor_actionFailed() {
5115         for (boolean createIncomplete : new boolean[] { true, false })
5116     {
5117         final CFException ex = new CFException();
5118         final CompletableFuture&lt;Integer&gt; f = new CompletableFuture&lt;&gt;();
5119         final FailingExceptionalCompletableFutureFunction r
5120             = new FailingExceptionalCompletableFutureFunction(ExecutionMode.EXECUTOR);
5121         final DelegatedCompletionStage&lt;Integer&gt; d =
5122             new DelegatedCompletionStage&lt;Integer&gt;(f);
5123         if (!createIncomplete) f.completeExceptionally(ex);
5124         final CompletionStage&lt;Integer&gt; g = d.exceptionallyComposeAsync(r, new ThreadExecutor());
5125         if (createIncomplete) f.completeExceptionally(ex);
5126 
5127         checkCompletedExceptionally(f, ex);
5128         checkCompletedWithWrappedException(g.toCompletableFuture(), r.ex);
5129         r.assertInvoked();
5130     }}
5131 
5132 }
<a name="4" id="anc4"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="4" type="hidden" />
</body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff test/jdk/java/util/concurrent/tck/ReentrantLockTest.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
<body>
<center><a href="PriorityBlockingQueueTest.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="ReentrantReadWriteLockTest.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>test/jdk/java/util/concurrent/tck/ReentrantLockTest.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  22 
  23 /*
  24  * This file is available under and governed by the GNU General Public
  25  * License version 2 only, as published by the Free Software Foundation.
  26  * However, the following notice accompanied the original version of this
  27  * file:
  28  *
  29  * Written by Doug Lea with assistance from members of JCP JSR-166
  30  * Expert Group and released to the public domain, as explained at
  31  * http://creativecommons.org/publicdomain/zero/1.0/
  32  * Other contributors include Andrew Wright, Jeffrey Hayes,
  33  * Pat Fisher, Mike Judd.
  34  */
  35 
  36 import static java.util.concurrent.TimeUnit.MILLISECONDS;
  37 
  38 import java.util.ArrayList;
  39 import java.util.Arrays;
  40 import java.util.Collection;
  41 import java.util.HashSet;

  42 import java.util.concurrent.CountDownLatch;
  43 import java.util.concurrent.CyclicBarrier;
  44 import java.util.concurrent.ThreadLocalRandom;

  45 import java.util.concurrent.locks.Condition;

  46 import java.util.concurrent.locks.ReentrantLock;
  47 
  48 import junit.framework.Test;
  49 import junit.framework.TestSuite;
  50 
  51 @SuppressWarnings(&quot;WaitNotInLoop&quot;) // we implement spurious-wakeup freedom
  52 public class ReentrantLockTest extends JSR166TestCase {
  53     public static void main(String[] args) {
  54         main(suite(), args);
  55     }
  56     public static Test suite() {
  57         return new TestSuite(ReentrantLockTest.class);
  58     }
  59 
  60     /**
  61      * A checked runnable calling lockInterruptibly
  62      */
  63     class InterruptibleLockRunnable extends CheckedRunnable {
  64         final ReentrantLock lock;
  65         InterruptibleLockRunnable(ReentrantLock lock) { this.lock = lock; }
</pre>
<hr />
<pre>
1205             }};
1206         for (int i = 0; i &lt; nThreads; i++) {
1207             Thread thread = new Thread(waiter, &quot;waiter&quot;);
1208             threads.add(thread);
1209             thread.start();
1210         }
1211 
1212         assertTrue(done.await(LONG_DELAY_MS, MILLISECONDS));
1213         lock.lock();
1214         try {
1215             assertEquals(nThreads, lock.getWaitQueueLength(cond));
1216         } finally {
1217             cond.signalAll();
1218             lock.unlock();
1219         }
1220         for (Thread thread : threads) {
1221             thread.join(LONG_DELAY_MS);
1222             assertFalse(thread.isAlive());
1223         }
1224     }





























































1225 }
</pre>
</td>
<td>
<hr />
<pre>
  22 
  23 /*
  24  * This file is available under and governed by the GNU General Public
  25  * License version 2 only, as published by the Free Software Foundation.
  26  * However, the following notice accompanied the original version of this
  27  * file:
  28  *
  29  * Written by Doug Lea with assistance from members of JCP JSR-166
  30  * Expert Group and released to the public domain, as explained at
  31  * http://creativecommons.org/publicdomain/zero/1.0/
  32  * Other contributors include Andrew Wright, Jeffrey Hayes,
  33  * Pat Fisher, Mike Judd.
  34  */
  35 
  36 import static java.util.concurrent.TimeUnit.MILLISECONDS;
  37 
  38 import java.util.ArrayList;
  39 import java.util.Arrays;
  40 import java.util.Collection;
  41 import java.util.HashSet;
<span class="line-added">  42 import java.util.concurrent.Callable;</span>
  43 import java.util.concurrent.CountDownLatch;
  44 import java.util.concurrent.CyclicBarrier;
  45 import java.util.concurrent.ThreadLocalRandom;
<span class="line-added">  46 import java.util.concurrent.atomic.AtomicBoolean;</span>
  47 import java.util.concurrent.locks.Condition;
<span class="line-added">  48 import java.util.concurrent.locks.Lock;</span>
  49 import java.util.concurrent.locks.ReentrantLock;
  50 
  51 import junit.framework.Test;
  52 import junit.framework.TestSuite;
  53 
  54 @SuppressWarnings(&quot;WaitNotInLoop&quot;) // we implement spurious-wakeup freedom
  55 public class ReentrantLockTest extends JSR166TestCase {
  56     public static void main(String[] args) {
  57         main(suite(), args);
  58     }
  59     public static Test suite() {
  60         return new TestSuite(ReentrantLockTest.class);
  61     }
  62 
  63     /**
  64      * A checked runnable calling lockInterruptibly
  65      */
  66     class InterruptibleLockRunnable extends CheckedRunnable {
  67         final ReentrantLock lock;
  68         InterruptibleLockRunnable(ReentrantLock lock) { this.lock = lock; }
</pre>
<hr />
<pre>
1208             }};
1209         for (int i = 0; i &lt; nThreads; i++) {
1210             Thread thread = new Thread(waiter, &quot;waiter&quot;);
1211             threads.add(thread);
1212             thread.start();
1213         }
1214 
1215         assertTrue(done.await(LONG_DELAY_MS, MILLISECONDS));
1216         lock.lock();
1217         try {
1218             assertEquals(nThreads, lock.getWaitQueueLength(cond));
1219         } finally {
1220             cond.signalAll();
1221             lock.unlock();
1222         }
1223         for (Thread thread : threads) {
1224             thread.join(LONG_DELAY_MS);
1225             assertFalse(thread.isAlive());
1226         }
1227     }
<span class="line-added">1228 </span>
<span class="line-added">1229     /**</span>
<span class="line-added">1230      * ThreadMXBean reports the blockers that we expect.</span>
<span class="line-added">1231      */</span>
<span class="line-added">1232     public void testBlockers() {</span>
<span class="line-added">1233         if (!testImplementationDetails) return;</span>
<span class="line-added">1234         final boolean fair = randomBoolean();</span>
<span class="line-added">1235         final boolean timedAcquire = randomBoolean();</span>
<span class="line-added">1236         final boolean timedAwait = randomBoolean();</span>
<span class="line-added">1237         final String syncClassName = fair</span>
<span class="line-added">1238             ? &quot;ReentrantLock$FairSync&quot;</span>
<span class="line-added">1239             : &quot;ReentrantLock$NonfairSync&quot;;</span>
<span class="line-added">1240         final String conditionClassName</span>
<span class="line-added">1241             = &quot;AbstractQueuedSynchronizer$ConditionObject&quot;;</span>
<span class="line-added">1242         final Thread.State expectedAcquireState = timedAcquire</span>
<span class="line-added">1243             ? Thread.State.TIMED_WAITING</span>
<span class="line-added">1244             : Thread.State.WAITING;</span>
<span class="line-added">1245         final Thread.State expectedAwaitState = timedAwait</span>
<span class="line-added">1246             ? Thread.State.TIMED_WAITING</span>
<span class="line-added">1247             : Thread.State.WAITING;</span>
<span class="line-added">1248         final Lock lock = new ReentrantLock(fair);</span>
<span class="line-added">1249         final Condition condition = lock.newCondition();</span>
<span class="line-added">1250         final AtomicBoolean conditionSatisfied = new AtomicBoolean(false);</span>
<span class="line-added">1251         lock.lock();</span>
<span class="line-added">1252         final Thread thread = newStartedThread((Action) () -&gt; {</span>
<span class="line-added">1253             if (timedAcquire)</span>
<span class="line-added">1254                 lock.tryLock(LONGER_DELAY_MS, MILLISECONDS);</span>
<span class="line-added">1255             else</span>
<span class="line-added">1256                 lock.lock();</span>
<span class="line-added">1257             while (!conditionSatisfied.get())</span>
<span class="line-added">1258                 if (timedAwait)</span>
<span class="line-added">1259                     condition.await(LONGER_DELAY_MS, MILLISECONDS);</span>
<span class="line-added">1260                 else</span>
<span class="line-added">1261                     condition.await();</span>
<span class="line-added">1262         });</span>
<span class="line-added">1263         Callable&lt;Boolean&gt; waitingForLock = () -&gt; {</span>
<span class="line-added">1264             String className;</span>
<span class="line-added">1265             return thread.getState() == expectedAcquireState</span>
<span class="line-added">1266             &amp;&amp; (className = blockerClassName(thread)) != null</span>
<span class="line-added">1267             &amp;&amp; className.endsWith(syncClassName);</span>
<span class="line-added">1268         };</span>
<span class="line-added">1269         waitForThreadToEnterWaitState(thread, waitingForLock);</span>
<span class="line-added">1270 </span>
<span class="line-added">1271         lock.unlock();</span>
<span class="line-added">1272         Callable&lt;Boolean&gt; waitingForCondition = () -&gt; {</span>
<span class="line-added">1273             String className;</span>
<span class="line-added">1274             return thread.getState() == expectedAwaitState</span>
<span class="line-added">1275             &amp;&amp; (className = blockerClassName(thread)) != null</span>
<span class="line-added">1276             &amp;&amp; className.endsWith(conditionClassName);</span>
<span class="line-added">1277         };</span>
<span class="line-added">1278         waitForThreadToEnterWaitState(thread, waitingForCondition);</span>
<span class="line-added">1279 </span>
<span class="line-added">1280         // politely release the waiter</span>
<span class="line-added">1281         conditionSatisfied.set(true);</span>
<span class="line-added">1282         lock.lock();</span>
<span class="line-added">1283         try {</span>
<span class="line-added">1284             condition.signal();</span>
<span class="line-added">1285         } finally { lock.unlock(); }</span>
<span class="line-added">1286 </span>
<span class="line-added">1287         awaitTermination(thread);</span>
<span class="line-added">1288     }</span>
1289 }
</pre>
</td>
</tr>
</table>
<center><a href="PriorityBlockingQueueTest.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="ReentrantReadWriteLockTest.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
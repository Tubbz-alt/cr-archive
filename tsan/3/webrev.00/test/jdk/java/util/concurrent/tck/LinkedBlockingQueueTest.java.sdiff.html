<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff test/jdk/java/util/concurrent/tck/LinkedBlockingQueueTest.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
<body>
<center><a href="LinkedBlockingDequeTest.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="LinkedHashMapTest.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>test/jdk/java/util/concurrent/tck/LinkedBlockingQueueTest.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
301                     q.put(i);
302                 assertEquals(SIZE, q.size());
303                 assertEquals(0, q.remainingCapacity());
304 
305                 Thread.currentThread().interrupt();
306                 try {
307                     q.put(99);
308                     shouldThrow();
309                 } catch (InterruptedException success) {}
310                 assertFalse(Thread.interrupted());
311 
312                 pleaseInterrupt.countDown();
313                 try {
314                     q.put(99);
315                     shouldThrow();
316                 } catch (InterruptedException success) {}
317                 assertFalse(Thread.interrupted());
318             }});
319 
320         await(pleaseInterrupt);
<span class="line-modified">321         assertThreadBlocks(t, Thread.State.WAITING);</span>
322         t.interrupt();
323         awaitTermination(t);
324         assertEquals(SIZE, q.size());
325         assertEquals(0, q.remainingCapacity());
326     }
327 
328     /**
329      * put blocks interruptibly waiting for take when full
330      */
331     public void testPutWithTake() throws InterruptedException {
332         final int capacity = 2;
333         final LinkedBlockingQueue q = new LinkedBlockingQueue(2);
334         final CountDownLatch pleaseTake = new CountDownLatch(1);
335         final CountDownLatch pleaseInterrupt = new CountDownLatch(1);
336         Thread t = newStartedThread(new CheckedRunnable() {
337             public void realRun() throws InterruptedException {
338                 for (int i = 0; i &lt; capacity; i++)
339                     q.put(i);
340                 pleaseTake.countDown();
341                 q.put(86);
</pre>
<hr />
<pre>
343                 Thread.currentThread().interrupt();
344                 try {
345                     q.put(99);
346                     shouldThrow();
347                 } catch (InterruptedException success) {}
348                 assertFalse(Thread.interrupted());
349 
350                 pleaseInterrupt.countDown();
351                 try {
352                     q.put(99);
353                     shouldThrow();
354                 } catch (InterruptedException success) {}
355                 assertFalse(Thread.interrupted());
356             }});
357 
358         await(pleaseTake);
359         assertEquals(0, q.remainingCapacity());
360         assertEquals(0, q.take());
361 
362         await(pleaseInterrupt);
<span class="line-modified">363         assertThreadBlocks(t, Thread.State.WAITING);</span>
364         t.interrupt();
365         awaitTermination(t);
366         assertEquals(0, q.remainingCapacity());
367     }
368 
369     /**
370      * timed offer times out if full and elements not taken
371      */
372     public void testTimedOffer() {
373         final LinkedBlockingQueue q = new LinkedBlockingQueue(2);
374         final CountDownLatch pleaseInterrupt = new CountDownLatch(1);
375         Thread t = newStartedThread(new CheckedRunnable() {
376             public void realRun() throws InterruptedException {
377                 q.put(new Object());
378                 q.put(new Object());
<span class="line-removed">379 </span>
380                 long startTime = System.nanoTime();

381                 assertFalse(q.offer(new Object(), timeoutMillis(), MILLISECONDS));
382                 assertTrue(millisElapsedSince(startTime) &gt;= timeoutMillis());
383 
384                 Thread.currentThread().interrupt();
385                 try {
<span class="line-modified">386                     q.offer(new Object(), 2 * LONG_DELAY_MS, MILLISECONDS);</span>
387                     shouldThrow();
388                 } catch (InterruptedException success) {}
389                 assertFalse(Thread.interrupted());
390 
391                 pleaseInterrupt.countDown();
392                 try {
<span class="line-modified">393                     q.offer(new Object(), 2 * LONG_DELAY_MS, MILLISECONDS);</span>
394                     shouldThrow();
395                 } catch (InterruptedException success) {}
396                 assertFalse(Thread.interrupted());
397             }});
398 
399         await(pleaseInterrupt);
<span class="line-modified">400         assertThreadBlocks(t, Thread.State.TIMED_WAITING);</span>
401         t.interrupt();
402         awaitTermination(t);
403     }
404 
405     /**
406      * take retrieves elements in FIFO order
407      */
408     public void testTake() throws InterruptedException {
409         LinkedBlockingQueue q = populatedQueue(SIZE);
410         for (int i = 0; i &lt; SIZE; ++i) {
411             assertEquals(i, q.take());
412         }
413     }
414 
415     /**
416      * Take removes existing elements until empty, then blocks interruptibly
417      */
418     public void testBlockingTake() throws InterruptedException {
419         final BlockingQueue q = populatedQueue(SIZE);
420         final CountDownLatch pleaseInterrupt = new CountDownLatch(1);
421         Thread t = newStartedThread(new CheckedRunnable() {
422             public void realRun() throws InterruptedException {
423                 for (int i = 0; i &lt; SIZE; i++) assertEquals(i, q.take());
424 
425                 Thread.currentThread().interrupt();
426                 try {
427                     q.take();
428                     shouldThrow();
429                 } catch (InterruptedException success) {}
430                 assertFalse(Thread.interrupted());
431 
432                 pleaseInterrupt.countDown();
433                 try {
434                     q.take();
435                     shouldThrow();
436                 } catch (InterruptedException success) {}
437                 assertFalse(Thread.interrupted());
438             }});
439 
440         await(pleaseInterrupt);
<span class="line-modified">441         assertThreadBlocks(t, Thread.State.WAITING);</span>
442         t.interrupt();
443         awaitTermination(t);
444     }
445 
446     /**
447      * poll succeeds unless empty
448      */
449     public void testPoll() {
450         LinkedBlockingQueue q = populatedQueue(SIZE);
451         for (int i = 0; i &lt; SIZE; ++i) {
452             assertEquals(i, q.poll());
453         }
454         assertNull(q.poll());
455     }
456 
457     /**
458      * timed poll with zero timeout succeeds when non-empty, else times out
459      */
460     public void testTimedPoll0() throws InterruptedException {
461         LinkedBlockingQueue q = populatedQueue(SIZE);
</pre>
<hr />
<pre>
473         for (int i = 0; i &lt; SIZE; ++i) {
474             long startTime = System.nanoTime();
475             assertEquals(i, (int) q.poll(LONG_DELAY_MS, MILLISECONDS));
476             assertTrue(millisElapsedSince(startTime) &lt; LONG_DELAY_MS);
477         }
478         long startTime = System.nanoTime();
479         assertNull(q.poll(timeoutMillis(), MILLISECONDS));
480         assertTrue(millisElapsedSince(startTime) &gt;= timeoutMillis());
481         checkEmpty(q);
482     }
483 
484     /**
485      * Interrupted timed poll throws InterruptedException instead of
486      * returning timeout status
487      */
488     public void testInterruptedTimedPoll() throws InterruptedException {
489         final BlockingQueue&lt;Integer&gt; q = populatedQueue(SIZE);
490         final CountDownLatch pleaseInterrupt = new CountDownLatch(1);
491         Thread t = newStartedThread(new CheckedRunnable() {
492             public void realRun() throws InterruptedException {
<span class="line-removed">493                 long startTime = System.nanoTime();</span>
494                 for (int i = 0; i &lt; SIZE; i++)
495                     assertEquals(i, (int) q.poll(LONG_DELAY_MS, MILLISECONDS));
496 
497                 Thread.currentThread().interrupt();
498                 try {
<span class="line-modified">499                     q.poll(LONG_DELAY_MS, MILLISECONDS);</span>
500                     shouldThrow();
501                 } catch (InterruptedException success) {}
502                 assertFalse(Thread.interrupted());
503 
504                 pleaseInterrupt.countDown();
505                 try {
<span class="line-modified">506                     q.poll(LONG_DELAY_MS, MILLISECONDS);</span>
507                     shouldThrow();
508                 } catch (InterruptedException success) {}
509                 assertFalse(Thread.interrupted());
<span class="line-removed">510 </span>
<span class="line-removed">511                 assertTrue(millisElapsedSince(startTime) &lt; LONG_DELAY_MS);</span>
512             }});
513 
514         await(pleaseInterrupt);
<span class="line-modified">515         assertThreadBlocks(t, Thread.State.TIMED_WAITING);</span>
516         t.interrupt();
517         awaitTermination(t);
518         checkEmpty(q);
519     }
520 
521     /**
522      * peek returns next element, or null if empty
523      */
524     public void testPeek() {
525         LinkedBlockingQueue q = populatedQueue(SIZE);
526         for (int i = 0; i &lt; SIZE; ++i) {
527             assertEquals(i, q.peek());
528             assertEquals(i, q.poll());
529             assertTrue(q.peek() == null ||
530                        !q.peek().equals(i));
531         }
532         assertNull(q.peek());
533     }
534 
535     /**
</pre>
</td>
<td>
<hr />
<pre>
301                     q.put(i);
302                 assertEquals(SIZE, q.size());
303                 assertEquals(0, q.remainingCapacity());
304 
305                 Thread.currentThread().interrupt();
306                 try {
307                     q.put(99);
308                     shouldThrow();
309                 } catch (InterruptedException success) {}
310                 assertFalse(Thread.interrupted());
311 
312                 pleaseInterrupt.countDown();
313                 try {
314                     q.put(99);
315                     shouldThrow();
316                 } catch (InterruptedException success) {}
317                 assertFalse(Thread.interrupted());
318             }});
319 
320         await(pleaseInterrupt);
<span class="line-modified">321         if (randomBoolean()) assertThreadBlocks(t, Thread.State.WAITING);</span>
322         t.interrupt();
323         awaitTermination(t);
324         assertEquals(SIZE, q.size());
325         assertEquals(0, q.remainingCapacity());
326     }
327 
328     /**
329      * put blocks interruptibly waiting for take when full
330      */
331     public void testPutWithTake() throws InterruptedException {
332         final int capacity = 2;
333         final LinkedBlockingQueue q = new LinkedBlockingQueue(2);
334         final CountDownLatch pleaseTake = new CountDownLatch(1);
335         final CountDownLatch pleaseInterrupt = new CountDownLatch(1);
336         Thread t = newStartedThread(new CheckedRunnable() {
337             public void realRun() throws InterruptedException {
338                 for (int i = 0; i &lt; capacity; i++)
339                     q.put(i);
340                 pleaseTake.countDown();
341                 q.put(86);
</pre>
<hr />
<pre>
343                 Thread.currentThread().interrupt();
344                 try {
345                     q.put(99);
346                     shouldThrow();
347                 } catch (InterruptedException success) {}
348                 assertFalse(Thread.interrupted());
349 
350                 pleaseInterrupt.countDown();
351                 try {
352                     q.put(99);
353                     shouldThrow();
354                 } catch (InterruptedException success) {}
355                 assertFalse(Thread.interrupted());
356             }});
357 
358         await(pleaseTake);
359         assertEquals(0, q.remainingCapacity());
360         assertEquals(0, q.take());
361 
362         await(pleaseInterrupt);
<span class="line-modified">363         if (randomBoolean()) assertThreadBlocks(t, Thread.State.WAITING);</span>
364         t.interrupt();
365         awaitTermination(t);
366         assertEquals(0, q.remainingCapacity());
367     }
368 
369     /**
370      * timed offer times out if full and elements not taken
371      */
372     public void testTimedOffer() {
373         final LinkedBlockingQueue q = new LinkedBlockingQueue(2);
374         final CountDownLatch pleaseInterrupt = new CountDownLatch(1);
375         Thread t = newStartedThread(new CheckedRunnable() {
376             public void realRun() throws InterruptedException {
377                 q.put(new Object());
378                 q.put(new Object());

379                 long startTime = System.nanoTime();
<span class="line-added">380 </span>
381                 assertFalse(q.offer(new Object(), timeoutMillis(), MILLISECONDS));
382                 assertTrue(millisElapsedSince(startTime) &gt;= timeoutMillis());
383 
384                 Thread.currentThread().interrupt();
385                 try {
<span class="line-modified">386                     q.offer(new Object(), randomTimeout(), randomTimeUnit());</span>
387                     shouldThrow();
388                 } catch (InterruptedException success) {}
389                 assertFalse(Thread.interrupted());
390 
391                 pleaseInterrupt.countDown();
392                 try {
<span class="line-modified">393                     q.offer(new Object(), LONGER_DELAY_MS, MILLISECONDS);</span>
394                     shouldThrow();
395                 } catch (InterruptedException success) {}
396                 assertFalse(Thread.interrupted());
397             }});
398 
399         await(pleaseInterrupt);
<span class="line-modified">400         if (randomBoolean()) assertThreadBlocks(t, Thread.State.TIMED_WAITING);</span>
401         t.interrupt();
402         awaitTermination(t);
403     }
404 
405     /**
406      * take retrieves elements in FIFO order
407      */
408     public void testTake() throws InterruptedException {
409         LinkedBlockingQueue q = populatedQueue(SIZE);
410         for (int i = 0; i &lt; SIZE; ++i) {
411             assertEquals(i, q.take());
412         }
413     }
414 
415     /**
416      * Take removes existing elements until empty, then blocks interruptibly
417      */
418     public void testBlockingTake() throws InterruptedException {
419         final BlockingQueue q = populatedQueue(SIZE);
420         final CountDownLatch pleaseInterrupt = new CountDownLatch(1);
421         Thread t = newStartedThread(new CheckedRunnable() {
422             public void realRun() throws InterruptedException {
423                 for (int i = 0; i &lt; SIZE; i++) assertEquals(i, q.take());
424 
425                 Thread.currentThread().interrupt();
426                 try {
427                     q.take();
428                     shouldThrow();
429                 } catch (InterruptedException success) {}
430                 assertFalse(Thread.interrupted());
431 
432                 pleaseInterrupt.countDown();
433                 try {
434                     q.take();
435                     shouldThrow();
436                 } catch (InterruptedException success) {}
437                 assertFalse(Thread.interrupted());
438             }});
439 
440         await(pleaseInterrupt);
<span class="line-modified">441         if (randomBoolean()) assertThreadBlocks(t, Thread.State.WAITING);</span>
442         t.interrupt();
443         awaitTermination(t);
444     }
445 
446     /**
447      * poll succeeds unless empty
448      */
449     public void testPoll() {
450         LinkedBlockingQueue q = populatedQueue(SIZE);
451         for (int i = 0; i &lt; SIZE; ++i) {
452             assertEquals(i, q.poll());
453         }
454         assertNull(q.poll());
455     }
456 
457     /**
458      * timed poll with zero timeout succeeds when non-empty, else times out
459      */
460     public void testTimedPoll0() throws InterruptedException {
461         LinkedBlockingQueue q = populatedQueue(SIZE);
</pre>
<hr />
<pre>
473         for (int i = 0; i &lt; SIZE; ++i) {
474             long startTime = System.nanoTime();
475             assertEquals(i, (int) q.poll(LONG_DELAY_MS, MILLISECONDS));
476             assertTrue(millisElapsedSince(startTime) &lt; LONG_DELAY_MS);
477         }
478         long startTime = System.nanoTime();
479         assertNull(q.poll(timeoutMillis(), MILLISECONDS));
480         assertTrue(millisElapsedSince(startTime) &gt;= timeoutMillis());
481         checkEmpty(q);
482     }
483 
484     /**
485      * Interrupted timed poll throws InterruptedException instead of
486      * returning timeout status
487      */
488     public void testInterruptedTimedPoll() throws InterruptedException {
489         final BlockingQueue&lt;Integer&gt; q = populatedQueue(SIZE);
490         final CountDownLatch pleaseInterrupt = new CountDownLatch(1);
491         Thread t = newStartedThread(new CheckedRunnable() {
492             public void realRun() throws InterruptedException {

493                 for (int i = 0; i &lt; SIZE; i++)
494                     assertEquals(i, (int) q.poll(LONG_DELAY_MS, MILLISECONDS));
495 
496                 Thread.currentThread().interrupt();
497                 try {
<span class="line-modified">498                     q.poll(randomTimeout(), randomTimeUnit());</span>
499                     shouldThrow();
500                 } catch (InterruptedException success) {}
501                 assertFalse(Thread.interrupted());
502 
503                 pleaseInterrupt.countDown();
504                 try {
<span class="line-modified">505                     q.poll(LONGER_DELAY_MS, MILLISECONDS);</span>
506                     shouldThrow();
507                 } catch (InterruptedException success) {}
508                 assertFalse(Thread.interrupted());


509             }});
510 
511         await(pleaseInterrupt);
<span class="line-modified">512         if (randomBoolean()) assertThreadBlocks(t, Thread.State.TIMED_WAITING);</span>
513         t.interrupt();
514         awaitTermination(t);
515         checkEmpty(q);
516     }
517 
518     /**
519      * peek returns next element, or null if empty
520      */
521     public void testPeek() {
522         LinkedBlockingQueue q = populatedQueue(SIZE);
523         for (int i = 0; i &lt; SIZE; ++i) {
524             assertEquals(i, q.peek());
525             assertEquals(i, q.poll());
526             assertTrue(q.peek() == null ||
527                        !q.peek().equals(i));
528         }
529         assertNull(q.peek());
530     }
531 
532     /**
</pre>
</td>
</tr>
</table>
<center><a href="LinkedBlockingDequeTest.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="LinkedHashMapTest.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
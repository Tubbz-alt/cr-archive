<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames test/jdk/java/util/concurrent/CyclicBarrier/Basic.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (c) 2005, 2018, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 /*
 25  * @test
 26  * @bug 6253848 6366811
 27  * @summary Basic tests for CyclicBarrier
 28  * @library /test/lib
 29  * @author Martin Buchholz, David Holmes
 30  */
 31 
 32 import static java.util.concurrent.TimeUnit.MILLISECONDS;
 33 
 34 import java.util.ArrayList;
 35 import java.util.Iterator;
 36 import java.util.List;
 37 import java.util.concurrent.BrokenBarrierException;
 38 import java.util.concurrent.CountDownLatch;
 39 import java.util.concurrent.CyclicBarrier;
<a name="1" id="anc1"></a>
 40 import java.util.concurrent.TimeoutException;
 41 import java.util.concurrent.atomic.AtomicInteger;
 42 import jdk.test.lib.Utils;
 43 
 44 public class Basic {
 45     static final long LONG_DELAY_MS = Utils.adjustTimeout(10_000);
 46 
 47     private static void checkBroken(final CyclicBarrier barrier) {
 48         check(barrier.isBroken());
 49         equal(barrier.getNumberWaiting(), 0);
 50 
 51         THROWS(BrokenBarrierException.class,
 52                () -&gt; barrier.await(),
 53                () -&gt; barrier.await(100, MILLISECONDS));
 54     }
 55 
 56     private static void reset(CyclicBarrier barrier) {
 57         barrier.reset();
 58         check(! barrier.isBroken());
 59         equal(barrier.getNumberWaiting(), 0);
 60     }
 61 
 62     private static void checkResult(Awaiter a, Class&lt;? extends Throwable&gt; c) {
 63         Throwable t = a.result();
 64         if (! ((t == null &amp;&amp; c == null) || (c != null &amp;&amp; c.isInstance(t)))) {
 65             //      t.printStackTrace();
 66             fail(&quot;Mismatch in thread &quot; +
 67                  a.getName() + &quot;: &quot; +
 68                  t + &quot;, &quot; +
 69                  (c == null ? &quot;&lt;null&gt;&quot; : c.getName()));
 70         } else {
 71             pass();
 72         }
 73     }
 74 
 75     //----------------------------------------------------------------
 76     // Mechanism to get all victim threads into &quot;running&quot; mode.
 77     // The fact that this also uses CyclicBarrier is entirely coincidental.
 78     //----------------------------------------------------------------
 79     private static final CyclicBarrier atTheStartingGate = new CyclicBarrier(3);
 80 
 81     private static void toTheStartingGate() {
 82         try { atTheStartingGate.await(LONG_DELAY_MS, MILLISECONDS); pass(); }
 83         catch (Throwable t) {
 84             unexpected(t);
 85             reset(atTheStartingGate);
 86             throw new Error(t);
 87         }
 88     }
 89 
 90     //----------------------------------------------------------------
 91     // Convenience methods for creating threads that call CyclicBarrier.await
 92     //----------------------------------------------------------------
 93     private abstract static class Awaiter extends Thread {
 94         static AtomicInteger count = new AtomicInteger(1);
 95 
 96         {
 97             this.setName(&quot;Awaiter:&quot;+count.getAndIncrement());
 98             this.setDaemon(true);
 99         }
100 
101         private volatile Throwable result = null;
102         protected void result(Throwable result) { this.result = result; }
103         public Throwable result() { return this.result; }
104     }
105 
106     private static Awaiter awaiter(final CyclicBarrier barrier) {
107         return new Awaiter() { public void run() {
108             toTheStartingGate();
109 
110             try { barrier.await(); }
111             catch (Throwable result) { result(result); }}};
112     }
113 
114     private static Awaiter awaiter(final CyclicBarrier barrier,
115                                    final long millis) {
116         return new Awaiter() { public void run() {
117             toTheStartingGate();
118 
119             try { barrier.await(millis, MILLISECONDS); }
120             catch (Throwable result) { result(result); }}};
121     }
122 
123     // Returns an infinite lazy list of all possible awaiter pair combinations.
124     private static Iterator&lt;Awaiter&gt; awaiterIterator(final CyclicBarrier barrier) {
125         return new Iterator&lt;Awaiter&gt;() {
126             int i = 0;
127             public boolean hasNext() { return true; }
128             public Awaiter next() {
129                 switch ((i++)&amp;7) {
130                 case 0: case 2: case 4: case 5:
131                     return awaiter(barrier);
132                 default:
133                     return awaiter(barrier, 10 * 1000); }}
134             public void remove() {throw new UnsupportedOperationException();}};
135     }
136 
137     private static void realMain(String[] args) throws Throwable {
138 
139         Thread.currentThread().setName(&quot;mainThread&quot;);
140 
141         //----------------------------------------------------------------
142         // Normal use
143         //----------------------------------------------------------------
144         try {
145             CyclicBarrier barrier = new CyclicBarrier(3);
146             equal(barrier.getParties(), 3);
147             Iterator&lt;Awaiter&gt; awaiters = awaiterIterator(barrier);
148             for (boolean doReset : new boolean[] {false, true})
149                 for (int i = 0; i &lt; 4; i++) {
150                     Awaiter a1 = awaiters.next(); a1.start();
151                     Awaiter a2 = awaiters.next(); a2.start();
152                     toTheStartingGate();
153                     barrier.await();
154                     a1.join();
155                     a2.join();
156                     checkResult(a1, null);
157                     checkResult(a2, null);
158                     check(! barrier.isBroken());
159                     equal(barrier.getParties(), 3);
160                     equal(barrier.getNumberWaiting(), 0);
161                     if (doReset) reset(barrier);
162                 }
163         } catch (Throwable t) { unexpected(t); }
164 
165         //----------------------------------------------------------------
166         // One thread interrupted
167         //----------------------------------------------------------------
168         try {
169             CyclicBarrier barrier = new CyclicBarrier(3);
170             Iterator&lt;Awaiter&gt; awaiters = awaiterIterator(barrier);
171             for (int i = 0; i &lt; 4; i++) {
172                 Awaiter a1 = awaiters.next(); a1.start();
173                 Awaiter a2 = awaiters.next(); a2.start();
174                 toTheStartingGate();
175                 a1.interrupt();
176                 a1.join();
177                 a2.join();
178                 checkResult(a1, InterruptedException.class);
179                 checkResult(a2, BrokenBarrierException.class);
180                 checkBroken(barrier);
181                 reset(barrier);
182             }
183         } catch (Throwable t) { unexpected(t); }
184 
185         //----------------------------------------------------------------
186         // Barrier is reset while threads are waiting
187         //----------------------------------------------------------------
188         try {
189             CyclicBarrier barrier = new CyclicBarrier(3);
190             Iterator&lt;Awaiter&gt; awaiters = awaiterIterator(barrier);
191             for (int i = 0; i &lt; 4; i++) {
192                 Awaiter a1 = awaiters.next(); a1.start();
193                 Awaiter a2 = awaiters.next(); a2.start();
194                 toTheStartingGate();
195                 while (barrier.getNumberWaiting() &lt; 2) Thread.yield();
196                 barrier.reset();
197                 a1.join();
198                 a2.join();
199                 checkResult(a1, BrokenBarrierException.class);
200                 checkResult(a2, BrokenBarrierException.class);
201                 check(! barrier.isBroken());
202                 equal(barrier.getParties(), 3);
203                 equal(barrier.getNumberWaiting(), 0);
204             }
205         } catch (Throwable t) { unexpected(t); }
206 
207         //----------------------------------------------------------------
208         // One thread timed out
209         //----------------------------------------------------------------
210         try {
211             CyclicBarrier barrier = new CyclicBarrier(3);
212             Iterator&lt;Awaiter&gt; awaiters = awaiterIterator(barrier);
213             for (long timeout : new long[] { 0L, 10L }) {
214                 for (int i = 0; i &lt; 2; i++) {
215                     Awaiter a1 = awaiter(barrier, timeout); a1.start();
216                     Awaiter a2 = awaiters.next();           a2.start();
217                     toTheStartingGate();
218                     a1.join();
219                     a2.join();
220                     checkResult(a1, TimeoutException.class);
221                     checkResult(a2, BrokenBarrierException.class);
222                     checkBroken(barrier);
223                     equal(barrier.getParties(), 3);
224                     reset(barrier);
225                 }
226             }
227         } catch (Throwable t) { unexpected(t); }
228 
229         //----------------------------------------------------------------
230         // Barrier action completed normally
231         //----------------------------------------------------------------
232         try {
233             final AtomicInteger count = new AtomicInteger(0);
234             final CyclicBarrier[] kludge = new CyclicBarrier[1];
235             Runnable action = new Runnable() { public void run() {
236                 count.incrementAndGet();
237                 equal(kludge[0].getNumberWaiting(),
238                       kludge[0].getParties());
239                 System.out.println(&quot;OK!&quot;); }};
240             CyclicBarrier barrier = new CyclicBarrier(3, action);
241             kludge[0] = barrier;
242             equal(barrier.getParties(), 3);
243             Iterator&lt;Awaiter&gt; awaiters = awaiterIterator(barrier);
244             for (int i = 0; i &lt; 4; i++) {
245                 Awaiter a1 = awaiters.next(); a1.start();
246                 Awaiter a2 = awaiters.next(); a2.start();
247                 toTheStartingGate();
248                 while (barrier.getNumberWaiting() &lt; 2) Thread.yield();
249                 try { barrier.await(); }
250                 catch (Throwable t) { unexpected(t); }
251                 a1.join();
252                 a2.join();
253                 checkResult(a1, null);
254                 checkResult(a2, null);
255                 check(! barrier.isBroken());
256                 equal(barrier.getNumberWaiting(), 0);
257                 reset(barrier);
258                 equal(count.get(), i+1);
259             }
260         } catch (Throwable t) { unexpected(t); }
261 
262         //----------------------------------------------------------------
263         // Barrier action threw exception
264         //----------------------------------------------------------------
265         try {
266             Runnable action = new Runnable() {
267                     public void run() { throw new Error(); }};
268             CyclicBarrier barrier = new CyclicBarrier(3, action);
269             Iterator&lt;Awaiter&gt; awaiters = awaiterIterator(barrier);
270             for (int i = 0; i &lt; 4; i++) {
271                 Awaiter a1 = awaiters.next(); a1.start();
272                 Awaiter a2 = awaiters.next(); a2.start();
273                 toTheStartingGate();
274                 while (barrier.getNumberWaiting() &lt; 2) Thread.yield();
275                 try {
276                     barrier.await();
277                     fail(&quot;Expected Error not thrown&quot;); }
278                 catch (Error e) { pass(); }
279                 catch (Throwable t) { unexpected(t); }
280                 a1.join();
281                 a2.join();
282                 checkResult(a1, BrokenBarrierException.class);
283                 checkResult(a2, BrokenBarrierException.class);
284                 checkBroken(barrier);
285                 reset(barrier);
286             }
287         } catch (Throwable t) { unexpected(t); }
288 
289         testInterrupts();
290     }
291 
292     /**
293      * Handling of extra interrupts while waiting - tests for bug 6366811
294      */
295     private static void testInterrupts() {
<a name="2" id="anc2"></a><span class="line-modified">296         final int N = 10;</span>
297         final CyclicBarrier startingGate = new CyclicBarrier(N+1);
298 
299         /**
300          * A version of Awaiter that also records interrupted state.
301          */
302         class Waiter extends CheckedThread {
<a name="3" id="anc3"></a><span class="line-modified">303             private boolean timed;</span>
<span class="line-modified">304             private CyclicBarrier barrier;</span>
<span class="line-modified">305             private CountDownLatch doneSignal;</span>
<span class="line-modified">306             private Throwable throwable;</span>
<span class="line-modified">307             private boolean interrupted;</span>
<span class="line-modified">308 </span>
<span class="line-modified">309             public Waiter(boolean timed,</span>
<span class="line-modified">310                           CountDownLatch doneSignal,</span>
<span class="line-removed">311                           CyclicBarrier barrier) {</span>
<span class="line-removed">312                 this.timed = timed;</span>
313                 this.doneSignal = doneSignal;
314                 this.barrier = barrier;
315             }
<a name="4" id="anc4"></a><span class="line-modified">316             Throwable throwable() { return this.throwable; }</span>
<span class="line-removed">317             boolean interruptBit() { return this.interrupted; }</span>
318             void realRun() throws Throwable {
319                 startingGate.await(LONG_DELAY_MS, MILLISECONDS);
<a name="5" id="anc5"></a>
320                 try {
321                     if (timed) barrier.await(LONG_DELAY_MS, MILLISECONDS);
<a name="6" id="anc6"></a><span class="line-modified">322                     else barrier.await(); }</span>
<span class="line-modified">323                 catch (Throwable throwable) { this.throwable = throwable; }</span>


324 
<a name="7" id="anc7"></a><span class="line-modified">325                 try { doneSignal.await(LONG_DELAY_MS, MILLISECONDS); }</span>
<span class="line-modified">326                 catch (InterruptedException e) { interrupted = true; }</span>





327             }
328         }
329 
330         //----------------------------------------------------------------
331         // Interrupt occurs during barrier trip
332         //----------------------------------------------------------------
333         try {
334             final CountDownLatch doneSignal = new CountDownLatch(1);
335             final List&lt;Waiter&gt; waiters = new ArrayList&lt;&gt;(N);
336 
337             // work around finality of closed-over variables
338             final Runnable[] realAction = new Runnable[1];
339             final Runnable delegateAction =
340                 new Runnable() {public void run() {realAction[0].run();}};
341             final CyclicBarrier barrier = new CyclicBarrier(N+1, delegateAction);
342 
343             realAction[0] = new Runnable() { public void run() {
344                 try {
345                     for (int i = 0; i &lt; N/2; i++)
346                         waiters.get(i).interrupt();
347                     // we need to try and ensure that the waiters get
348                     // to process their interruption before we do the
349                     // signalAll that trips the barrier. Using sleep
350                     // seems to work reliably while yield does not.
351                     Thread.sleep(100);
352                 } catch (Throwable t) { unexpected(t); }
353             }};
354             for (int i = 0; i &lt; N; i++) {
<a name="8" id="anc8"></a><span class="line-modified">355                 Waiter waiter = new Waiter(i &lt; N/2, doneSignal, barrier);</span>
356                 waiter.start();
357                 waiters.add(waiter);
358             }
359             startingGate.await(LONG_DELAY_MS, MILLISECONDS);
360             while (barrier.getNumberWaiting() &lt; N) Thread.yield();
361             barrier.await();
362             doneSignal.countDown();
<a name="9" id="anc9"></a><span class="line-modified">363             int countInterrupted = 0;</span>
<span class="line-removed">364             int countInterruptedException = 0;</span>
<span class="line-removed">365             int countBrokenBarrierException = 0;</span>
366             for (Waiter waiter : waiters) {
367                 waiter.join();
<a name="10" id="anc10"></a><span class="line-modified">368                 equal(waiter.throwable(), null);</span>
<span class="line-modified">369                 if (waiter.interruptBit())</span>
<span class="line-modified">370                     countInterrupted++;</span>
371             }
<a name="11" id="anc11"></a><span class="line-modified">372             equal(countInterrupted, N/2);</span>
373             check(! barrier.isBroken());
374         } catch (Throwable t) { unexpected(t); }
375 
376         //----------------------------------------------------------------
377         // Multiple interrupts occur during barrier await
378         //----------------------------------------------------------------
379         try {
380             final CountDownLatch doneSignal = new CountDownLatch(1);
381             final CyclicBarrier barrier = new CyclicBarrier(N+1);
382             final List&lt;Waiter&gt; waiters = new ArrayList&lt;&gt;(N);
383             for (int i = 0; i &lt; N; i++) {
<a name="12" id="anc12"></a><span class="line-modified">384                 Waiter waiter = new Waiter(i &lt; N/2, doneSignal, barrier);</span>
385                 waiter.start();
386                 waiters.add(waiter);
387             }
388             startingGate.await(LONG_DELAY_MS, MILLISECONDS);
389             while (barrier.getNumberWaiting() &lt; N) Thread.yield();
<a name="13" id="anc13"></a><span class="line-modified">390             for (int i = 0; i &lt; N/2; i++)</span>
<span class="line-modified">391                 waiters.get(i).interrupt();</span>


392             doneSignal.countDown();
<a name="14" id="anc14"></a><span class="line-removed">393             int countInterrupted = 0;</span>
394             int countInterruptedException = 0;
395             int countBrokenBarrierException = 0;
<a name="15" id="anc15"></a>
396             for (Waiter waiter : waiters) {
397                 waiter.join();
<a name="16" id="anc16"></a><span class="line-modified">398                 if (waiter.throwable() instanceof InterruptedException)</span>
399                     countInterruptedException++;
<a name="17" id="anc17"></a><span class="line-modified">400                 if (waiter.throwable() instanceof BrokenBarrierException)</span>
401                     countBrokenBarrierException++;
<a name="18" id="anc18"></a><span class="line-modified">402                 if (waiter.interruptBit())</span>
<span class="line-modified">403                     countInterrupted++;</span>
404             }
<a name="19" id="anc19"></a><span class="line-removed">405             equal(countInterrupted, N/2-1);</span>
406             equal(countInterruptedException, 1);
407             equal(countBrokenBarrierException, N-1);
408             checkBroken(barrier);
<a name="20" id="anc20"></a>
409             reset(barrier);
410         } catch (Throwable t) { unexpected(t); }
411     }
412 
413     //--------------------- Infrastructure ---------------------------
414     static volatile int passed = 0, failed = 0;
415     static void pass() {passed++;}
416     static void fail() {failed++; Thread.dumpStack();}
417     static void fail(String msg) {System.out.println(msg); fail();}
418     static void unexpected(Throwable t) {failed++; t.printStackTrace();}
419     static void check(boolean cond) {if (cond) pass(); else fail();}
420     static void equal(Object x, Object y) {
421         if (x == null ? y == null : x.equals(y)) pass();
422         else fail(x + &quot; not equal to &quot; + y);}
423     public static void main(String[] args) throws Throwable {
424         try {realMain(args);} catch (Throwable t) {unexpected(t);}
425         System.out.printf(&quot;%nPassed = %d, failed = %d%n%n&quot;, passed, failed);
426         if (failed &gt; 0) throw new AssertionError(&quot;Some tests failed&quot;);}
427     interface Fun {void f() throws Throwable;}
428     private static void THROWS(Class&lt;? extends Throwable&gt; k, Fun... fs) {
429         for (Fun f : fs)
430             try { f.f(); fail(&quot;Expected &quot; + k.getName() + &quot; not thrown&quot;); }
431             catch (Throwable t) {
432                 if (k.isAssignableFrom(t.getClass())) pass();
433                 else unexpected(t);}}
434     private abstract static class CheckedThread extends Thread {
435         abstract void realRun() throws Throwable;
436         public void run() {
437             try {realRun();} catch (Throwable t) {unexpected(t);}}}
438 }
<a name="21" id="anc21"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="21" type="hidden" />
</body>
</html>
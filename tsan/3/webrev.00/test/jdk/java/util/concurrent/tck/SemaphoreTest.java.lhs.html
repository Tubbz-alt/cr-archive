<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames test/jdk/java/util/concurrent/tck/SemaphoreTest.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  3  *
  4  * This code is free software; you can redistribute it and/or modify it
  5  * under the terms of the GNU General Public License version 2 only, as
  6  * published by the Free Software Foundation.
  7  *
  8  * This code is distributed in the hope that it will be useful, but WITHOUT
  9  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 10  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 11  * version 2 for more details (a copy is included in the LICENSE file that
 12  * accompanied this code).
 13  *
 14  * You should have received a copy of the GNU General Public License version
 15  * 2 along with this work; if not, write to the Free Software Foundation,
 16  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 17  *
 18  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 19  * or visit www.oracle.com if you need additional information or have any
 20  * questions.
 21  */
 22 
 23 /*
 24  * This file is available under and governed by the GNU General Public
 25  * License version 2 only, as published by the Free Software Foundation.
 26  * However, the following notice accompanied the original version of this
 27  * file:
 28  *
 29  * Written by Doug Lea with assistance from members of JCP JSR-166
 30  * Expert Group and released to the public domain, as explained at
 31  * http://creativecommons.org/publicdomain/zero/1.0/
 32  * Other contributors include Andrew Wright, Jeffrey Hayes,
 33  * Pat Fisher, Mike Judd.
 34  */
 35 
 36 import static java.util.concurrent.TimeUnit.MILLISECONDS;
 37 
 38 import java.util.Collection;
 39 import java.util.concurrent.CountDownLatch;
 40 import java.util.concurrent.Semaphore;
<a name="1" id="anc1"></a><span class="line-removed"> 41 import java.util.concurrent.ThreadLocalRandom;</span>
 42 
 43 import junit.framework.Test;
 44 import junit.framework.TestSuite;
 45 
 46 public class SemaphoreTest extends JSR166TestCase {
 47     public static void main(String[] args) {
 48         main(suite(), args);
 49     }
 50     public static Test suite() {
 51         return new TestSuite(SemaphoreTest.class);
 52     }
 53 
 54     /**
 55      * Subclass to expose protected methods
 56      */
 57     static class PublicSemaphore extends Semaphore {
 58         PublicSemaphore(int permits) { super(permits); }
 59         PublicSemaphore(int permits, boolean fair) { super(permits, fair); }
 60         public Collection&lt;Thread&gt; getQueuedThreads() {
 61             return super.getQueuedThreads();
 62         }
 63         public boolean hasQueuedThread(Thread t) {
 64             return super.getQueuedThreads().contains(t);
 65         }
 66         public void reducePermits(int reduction) {
 67             super.reducePermits(reduction);
 68         }
 69     }
 70 
 71     /**
 72      * A runnable calling acquire
 73      */
 74     class InterruptibleLockRunnable extends CheckedRunnable {
 75         final Semaphore lock;
 76         InterruptibleLockRunnable(Semaphore s) { lock = s; }
 77         public void realRun() {
 78             try {
 79                 lock.acquire();
 80             }
 81             catch (InterruptedException ignored) {}
 82         }
 83     }
 84 
 85     /**
 86      * A runnable calling acquire that expects to be interrupted
 87      */
 88     class InterruptedLockRunnable extends CheckedInterruptedRunnable {
 89         final Semaphore lock;
 90         InterruptedLockRunnable(Semaphore s) { lock = s; }
 91         public void realRun() throws InterruptedException {
 92             lock.acquire();
 93         }
 94     }
 95 
 96     /**
 97      * Spin-waits until s.hasQueuedThread(t) becomes true.
 98      */
 99     void waitForQueuedThread(PublicSemaphore s, Thread t) {
100         long startTime = System.nanoTime();
101         while (!s.hasQueuedThread(t)) {
102             if (millisElapsedSince(startTime) &gt; LONG_DELAY_MS)
103                 throw new AssertionError(&quot;timed out&quot;);
104             Thread.yield();
105         }
106         assertTrue(s.hasQueuedThreads());
107         assertTrue(t.isAlive());
108     }
109 
110     /**
111      * Spin-waits until s.hasQueuedThreads() becomes true.
112      */
113     void waitForQueuedThreads(Semaphore s) {
114         long startTime = System.nanoTime();
115         while (!s.hasQueuedThreads()) {
116             if (millisElapsedSince(startTime) &gt; LONG_DELAY_MS)
117                 throw new AssertionError(&quot;timed out&quot;);
118             Thread.yield();
119         }
120     }
121 
122     enum AcquireMethod {
123         acquire() {
124             void acquire(Semaphore s) throws InterruptedException {
125                 s.acquire();
126             }
127         },
128         acquireN() {
129             void acquire(Semaphore s, int permits) throws InterruptedException {
130                 s.acquire(permits);
131             }
132         },
133         acquireUninterruptibly() {
134             void acquire(Semaphore s) {
135                 s.acquireUninterruptibly();
136             }
137         },
138         acquireUninterruptiblyN() {
139             void acquire(Semaphore s, int permits) {
140                 s.acquireUninterruptibly(permits);
141             }
142         },
143         tryAcquire() {
144             void acquire(Semaphore s) {
145                 assertTrue(s.tryAcquire());
146             }
147         },
148         tryAcquireN() {
149             void acquire(Semaphore s, int permits) {
150                 assertTrue(s.tryAcquire(permits));
151             }
152         },
153         tryAcquireTimed() {
154             void acquire(Semaphore s) throws InterruptedException {
155                 assertTrue(s.tryAcquire(2 * LONG_DELAY_MS, MILLISECONDS));
156             }
157             Thread.State parkedState() { return Thread.State.TIMED_WAITING; }
158         },
159         tryAcquireTimedN {
160             void acquire(Semaphore s, int permits) throws InterruptedException {
161                 assertTrue(s.tryAcquire(permits, 2 * LONG_DELAY_MS, MILLISECONDS));
162             }
163             Thread.State parkedState() { return Thread.State.TIMED_WAITING; }
164         };
165 
166         // Intentionally meta-circular
167 
168         /** Acquires 1 permit. */
169         void acquire(Semaphore s) throws InterruptedException {
170             acquire(s, 1);
171         }
172         /** Acquires the given number of permits. */
173         void acquire(Semaphore s, int permits) throws InterruptedException {
174             for (int i = 0; i &lt; permits; i++)
175                 acquire(s);
176         }
177         Thread.State parkedState() { return Thread.State.WAITING; }
178     }
179 
180     /**
181      * Zero, negative, and positive initial values are allowed in constructor
182      */
183     public void testConstructor()      { testConstructor(false); }
184     public void testConstructor_fair() { testConstructor(true); }
185     public void testConstructor(boolean fair) {
186         for (int permits : new int[] { -42, -1, 0, 1, 42 }) {
187             Semaphore s = new Semaphore(permits, fair);
188             assertEquals(permits, s.availablePermits());
189             assertEquals(fair, s.isFair());
190         }
191     }
192 
193     /**
194      * Constructor without fairness argument behaves as nonfair
195      */
196     public void testConstructorDefaultsToNonFair() {
197         for (int permits : new int[] { -42, -1, 0, 1, 42 }) {
198             Semaphore s = new Semaphore(permits);
199             assertEquals(permits, s.availablePermits());
200             assertFalse(s.isFair());
201         }
202     }
203 
204     /**
205      * tryAcquire succeeds when sufficient permits, else fails
206      */
207     public void testTryAcquireInSameThread()      { testTryAcquireInSameThread(false); }
208     public void testTryAcquireInSameThread_fair() { testTryAcquireInSameThread(true); }
209     public void testTryAcquireInSameThread(boolean fair) {
210         Semaphore s = new Semaphore(2, fair);
211         assertEquals(2, s.availablePermits());
212         assertTrue(s.tryAcquire());
213         assertTrue(s.tryAcquire());
214         assertEquals(0, s.availablePermits());
215         assertFalse(s.tryAcquire());
216         assertFalse(s.tryAcquire());
217         assertEquals(0, s.availablePermits());
218     }
219 
220     /**
221      * timed tryAcquire times out
222      */
<a name="2" id="anc2"></a><span class="line-modified">223     public void testTryAcquire_timeout() {</span>
<span class="line-modified">224         final boolean fair = ThreadLocalRandom.current().nextBoolean();</span>
225         final Semaphore s = new Semaphore(0, fair);
226         final long startTime = System.nanoTime();
<a name="3" id="anc3"></a><span class="line-modified">227         try { assertFalse(s.tryAcquire(timeoutMillis(), MILLISECONDS)); }</span>
<span class="line-removed">228         catch (InterruptedException e) { threadUnexpectedException(e); }</span>
229         assertTrue(millisElapsedSince(startTime) &gt;= timeoutMillis());
230     }
231 
232     /**
233      * timed tryAcquire(N) times out
234      */
<a name="4" id="anc4"></a><span class="line-modified">235     public void testTryAcquireN_timeout() {</span>
<span class="line-modified">236         final boolean fair = ThreadLocalRandom.current().nextBoolean();</span>
237         final Semaphore s = new Semaphore(2, fair);
238         final long startTime = System.nanoTime();
<a name="5" id="anc5"></a><span class="line-modified">239         try { assertFalse(s.tryAcquire(3, timeoutMillis(), MILLISECONDS)); }</span>
<span class="line-removed">240         catch (InterruptedException e) { threadUnexpectedException(e); }</span>
241         assertTrue(millisElapsedSince(startTime) &gt;= timeoutMillis());
242     }
243 
244     /**
245      * acquire(), acquire(N), timed tryAcquired, timed tryAcquire(N)
246      * are interruptible
247      */
248     public void testInterruptible_acquire()               { testInterruptible(false, AcquireMethod.acquire); }
249     public void testInterruptible_acquire_fair()          { testInterruptible(true,  AcquireMethod.acquire); }
250     public void testInterruptible_acquireN()              { testInterruptible(false, AcquireMethod.acquireN); }
251     public void testInterruptible_acquireN_fair()         { testInterruptible(true,  AcquireMethod.acquireN); }
252     public void testInterruptible_tryAcquireTimed()       { testInterruptible(false, AcquireMethod.tryAcquireTimed); }
253     public void testInterruptible_tryAcquireTimed_fair()  { testInterruptible(true,  AcquireMethod.tryAcquireTimed); }
254     public void testInterruptible_tryAcquireTimedN()      { testInterruptible(false, AcquireMethod.tryAcquireTimedN); }
255     public void testInterruptible_tryAcquireTimedN_fair() { testInterruptible(true,  AcquireMethod.tryAcquireTimedN); }
256     public void testInterruptible(boolean fair, final AcquireMethod acquirer) {
257         final PublicSemaphore s = new PublicSemaphore(0, fair);
258         final java.util.concurrent.CyclicBarrier pleaseInterrupt
259             = new java.util.concurrent.CyclicBarrier(2);
260         Thread t = newStartedThread(new CheckedRunnable() {
261             public void realRun() {
262                 // Interrupt before acquire
263                 Thread.currentThread().interrupt();
264                 try {
265                     acquirer.acquire(s);
266                     shouldThrow();
267                 } catch (InterruptedException success) {}
268                 assertFalse(Thread.interrupted());
269 
270                 // Interrupt before acquire(N)
271                 Thread.currentThread().interrupt();
272                 try {
273                     acquirer.acquire(s, 3);
274                     shouldThrow();
275                 } catch (InterruptedException success) {}
276                 assertFalse(Thread.interrupted());
277 
278                 // Interrupt during acquire
279                 await(pleaseInterrupt);
280                 try {
281                     acquirer.acquire(s);
282                     shouldThrow();
283                 } catch (InterruptedException success) {}
284                 assertFalse(Thread.interrupted());
285 
286                 // Interrupt during acquire(N)
287                 await(pleaseInterrupt);
288                 try {
289                     acquirer.acquire(s, 3);
290                     shouldThrow();
291                 } catch (InterruptedException success) {}
292                 assertFalse(Thread.interrupted());
293             }});
294 
295         for (int n = 2; n--&gt;0; ) {
296             await(pleaseInterrupt);
297             assertThreadBlocks(t, acquirer.parkedState());
298             t.interrupt();
299         }
300 
301         awaitTermination(t);
302     }
303 
304     /**
305      * acquireUninterruptibly(), acquireUninterruptibly(N) are
306      * uninterruptible
307      */
308     public void testUninterruptible_acquireUninterruptibly()       { testUninterruptible(false, AcquireMethod.acquireUninterruptibly); }
309     public void testUninterruptible_acquireUninterruptibly_fair()  { testUninterruptible(true,  AcquireMethod.acquireUninterruptibly); }
310     public void testUninterruptible_acquireUninterruptiblyN()      { testUninterruptible(false, AcquireMethod.acquireUninterruptiblyN); }
311     public void testUninterruptible_acquireUninterruptiblyN_fair() { testUninterruptible(true,  AcquireMethod.acquireUninterruptiblyN); }
312     public void testUninterruptible(boolean fair, final AcquireMethod acquirer) {
313         final PublicSemaphore s = new PublicSemaphore(0, fair);
314         final Semaphore pleaseInterrupt = new Semaphore(-1, fair);
315 
316         Thread t1 = newStartedThread(new CheckedRunnable() {
317             public void realRun() throws InterruptedException {
318                 // Interrupt before acquire
319                 pleaseInterrupt.release();
320                 Thread.currentThread().interrupt();
321                 acquirer.acquire(s);
322                 assertTrue(Thread.interrupted());
323             }});
324 
325         Thread t2 = newStartedThread(new CheckedRunnable() {
326             public void realRun() throws InterruptedException {
327                 // Interrupt during acquire
328                 pleaseInterrupt.release();
329                 acquirer.acquire(s);
330                 assertTrue(Thread.interrupted());
331             }});
332 
333         await(pleaseInterrupt);
334         waitForQueuedThread(s, t1);
335         waitForQueuedThread(s, t2);
336         t2.interrupt();
337 
338         assertThreadBlocks(t1, Thread.State.WAITING);
339         assertThreadBlocks(t2, Thread.State.WAITING);
340 
341         s.release(2);
342 
343         awaitTermination(t1);
344         awaitTermination(t2);
345     }
346 
347     /**
348      * hasQueuedThreads reports whether there are waiting threads
349      */
350     public void testHasQueuedThreads()      { testHasQueuedThreads(false); }
351     public void testHasQueuedThreads_fair() { testHasQueuedThreads(true); }
352     public void testHasQueuedThreads(boolean fair) {
353         final PublicSemaphore lock = new PublicSemaphore(1, fair);
354         assertFalse(lock.hasQueuedThreads());
355         lock.acquireUninterruptibly();
356         Thread t1 = newStartedThread(new InterruptedLockRunnable(lock));
357         waitForQueuedThread(lock, t1);
358         assertTrue(lock.hasQueuedThreads());
359         Thread t2 = newStartedThread(new InterruptibleLockRunnable(lock));
360         waitForQueuedThread(lock, t2);
361         assertTrue(lock.hasQueuedThreads());
362         t1.interrupt();
363         awaitTermination(t1);
364         assertTrue(lock.hasQueuedThreads());
365         lock.release();
366         awaitTermination(t2);
367         assertFalse(lock.hasQueuedThreads());
368     }
369 
370     /**
371      * getQueueLength reports number of waiting threads
372      */
373     public void testGetQueueLength()      { testGetQueueLength(false); }
374     public void testGetQueueLength_fair() { testGetQueueLength(true); }
375     public void testGetQueueLength(boolean fair) {
376         final PublicSemaphore lock = new PublicSemaphore(1, fair);
377         assertEquals(0, lock.getQueueLength());
378         lock.acquireUninterruptibly();
379         Thread t1 = newStartedThread(new InterruptedLockRunnable(lock));
380         waitForQueuedThread(lock, t1);
381         assertEquals(1, lock.getQueueLength());
382         Thread t2 = newStartedThread(new InterruptibleLockRunnable(lock));
383         waitForQueuedThread(lock, t2);
384         assertEquals(2, lock.getQueueLength());
385         t1.interrupt();
386         awaitTermination(t1);
387         assertEquals(1, lock.getQueueLength());
388         lock.release();
389         awaitTermination(t2);
390         assertEquals(0, lock.getQueueLength());
391     }
392 
393     /**
394      * getQueuedThreads includes waiting threads
395      */
396     public void testGetQueuedThreads()      { testGetQueuedThreads(false); }
397     public void testGetQueuedThreads_fair() { testGetQueuedThreads(true); }
398     public void testGetQueuedThreads(boolean fair) {
399         final PublicSemaphore lock = new PublicSemaphore(1, fair);
400         assertTrue(lock.getQueuedThreads().isEmpty());
401         lock.acquireUninterruptibly();
402         assertTrue(lock.getQueuedThreads().isEmpty());
403         Thread t1 = newStartedThread(new InterruptedLockRunnable(lock));
404         waitForQueuedThread(lock, t1);
405         assertTrue(lock.getQueuedThreads().contains(t1));
406         Thread t2 = newStartedThread(new InterruptibleLockRunnable(lock));
407         waitForQueuedThread(lock, t2);
408         assertTrue(lock.getQueuedThreads().contains(t1));
409         assertTrue(lock.getQueuedThreads().contains(t2));
410         t1.interrupt();
411         awaitTermination(t1);
412         assertFalse(lock.getQueuedThreads().contains(t1));
413         assertTrue(lock.getQueuedThreads().contains(t2));
414         lock.release();
415         awaitTermination(t2);
416         assertTrue(lock.getQueuedThreads().isEmpty());
417     }
418 
419     /**
420      * drainPermits reports and removes given number of permits
421      */
422     public void testDrainPermits()      { testDrainPermits(false); }
423     public void testDrainPermits_fair() { testDrainPermits(true); }
424     public void testDrainPermits(boolean fair) {
425         Semaphore s = new Semaphore(0, fair);
426         assertEquals(0, s.availablePermits());
427         assertEquals(0, s.drainPermits());
428         s.release(10);
429         assertEquals(10, s.availablePermits());
430         assertEquals(10, s.drainPermits());
431         assertEquals(0, s.availablePermits());
432         assertEquals(0, s.drainPermits());
433     }
434 
435     /**
436      * release(-N) throws IllegalArgumentException
437      */
438     public void testReleaseIAE()      { testReleaseIAE(false); }
439     public void testReleaseIAE_fair() { testReleaseIAE(true); }
440     public void testReleaseIAE(boolean fair) {
441         Semaphore s = new Semaphore(10, fair);
442         try {
443             s.release(-1);
444             shouldThrow();
445         } catch (IllegalArgumentException success) {}
446     }
447 
448     /**
449      * reducePermits(-N) throws IllegalArgumentException
450      */
451     public void testReducePermitsIAE()      { testReducePermitsIAE(false); }
452     public void testReducePermitsIAE_fair() { testReducePermitsIAE(true); }
453     public void testReducePermitsIAE(boolean fair) {
454         PublicSemaphore s = new PublicSemaphore(10, fair);
455         try {
456             s.reducePermits(-1);
457             shouldThrow();
458         } catch (IllegalArgumentException success) {}
459     }
460 
461     /**
462      * reducePermits reduces number of permits
463      */
464     public void testReducePermits()      { testReducePermits(false); }
465     public void testReducePermits_fair() { testReducePermits(true); }
466     public void testReducePermits(boolean fair) {
467         PublicSemaphore s = new PublicSemaphore(10, fair);
468         assertEquals(10, s.availablePermits());
469         s.reducePermits(0);
470         assertEquals(10, s.availablePermits());
471         s.reducePermits(1);
472         assertEquals(9, s.availablePermits());
473         s.reducePermits(10);
474         assertEquals(-1, s.availablePermits());
475         s.reducePermits(10);
476         assertEquals(-11, s.availablePermits());
477         s.reducePermits(0);
478         assertEquals(-11, s.availablePermits());
479     }
480 
481     /**
482      * a reserialized semaphore has same number of permits and
483      * fairness, but no queued threads
484      */
485     public void testSerialization()      { testSerialization(false); }
486     public void testSerialization_fair() { testSerialization(true); }
487     public void testSerialization(boolean fair) {
488         try {
489             Semaphore s = new Semaphore(3, fair);
490             s.acquire();
491             s.acquire();
492             s.release();
493 
494             Semaphore clone = serialClone(s);
495             assertEquals(fair, s.isFair());
496             assertEquals(fair, clone.isFair());
497             assertEquals(2, s.availablePermits());
498             assertEquals(2, clone.availablePermits());
499             clone.acquire();
500             clone.acquire();
501             clone.release();
502             assertEquals(2, s.availablePermits());
503             assertEquals(1, clone.availablePermits());
504             assertFalse(s.hasQueuedThreads());
505             assertFalse(clone.hasQueuedThreads());
506         } catch (InterruptedException e) { threadUnexpectedException(e); }
507 
508         {
509             PublicSemaphore s = new PublicSemaphore(0, fair);
510             Thread t = newStartedThread(new InterruptibleLockRunnable(s));
511             // waitForQueuedThreads(s); // suffers from &quot;flicker&quot;, so ...
512             waitForQueuedThread(s, t);  // ... we use this instead
513             PublicSemaphore clone = serialClone(s);
514             assertEquals(fair, s.isFair());
515             assertEquals(fair, clone.isFair());
516             assertEquals(0, s.availablePermits());
517             assertEquals(0, clone.availablePermits());
518             assertTrue(s.hasQueuedThreads());
519             assertFalse(clone.hasQueuedThreads());
520             s.release();
521             awaitTermination(t);
522             assertFalse(s.hasQueuedThreads());
523             assertFalse(clone.hasQueuedThreads());
524         }
525     }
526 
527     /**
528      * tryAcquire(n) succeeds when sufficient permits, else fails
529      */
530     public void testTryAcquireNInSameThread()      { testTryAcquireNInSameThread(false); }
531     public void testTryAcquireNInSameThread_fair() { testTryAcquireNInSameThread(true); }
532     public void testTryAcquireNInSameThread(boolean fair) {
533         Semaphore s = new Semaphore(2, fair);
534         assertEquals(2, s.availablePermits());
535         assertFalse(s.tryAcquire(3));
536         assertEquals(2, s.availablePermits());
537         assertTrue(s.tryAcquire(2));
538         assertEquals(0, s.availablePermits());
539         assertFalse(s.tryAcquire(1));
540         assertFalse(s.tryAcquire(2));
541         assertEquals(0, s.availablePermits());
542     }
543 
544     /**
545      * acquire succeeds if permits available
546      */
547     public void testReleaseAcquireSameThread_acquire()       { testReleaseAcquireSameThread(false, AcquireMethod.acquire); }
548     public void testReleaseAcquireSameThread_acquire_fair()  { testReleaseAcquireSameThread(true, AcquireMethod.acquire); }
549     public void testReleaseAcquireSameThread_acquireN()      { testReleaseAcquireSameThread(false, AcquireMethod.acquireN); }
550     public void testReleaseAcquireSameThread_acquireN_fair() { testReleaseAcquireSameThread(true, AcquireMethod.acquireN); }
551     public void testReleaseAcquireSameThread_acquireUninterruptibly()       { testReleaseAcquireSameThread(false, AcquireMethod.acquireUninterruptibly); }
552     public void testReleaseAcquireSameThread_acquireUninterruptibly_fair()  { testReleaseAcquireSameThread(true, AcquireMethod.acquireUninterruptibly); }
553     public void testReleaseAcquireSameThread_acquireUninterruptiblyN()      { testReleaseAcquireSameThread(false, AcquireMethod.acquireUninterruptibly); }
554     public void testReleaseAcquireSameThread_acquireUninterruptiblyN_fair() { testReleaseAcquireSameThread(true, AcquireMethod.acquireUninterruptibly); }
555     public void testReleaseAcquireSameThread_tryAcquire()       { testReleaseAcquireSameThread(false, AcquireMethod.tryAcquire); }
556     public void testReleaseAcquireSameThread_tryAcquire_fair()  { testReleaseAcquireSameThread(true, AcquireMethod.tryAcquire); }
557     public void testReleaseAcquireSameThread_tryAcquireN()      { testReleaseAcquireSameThread(false, AcquireMethod.tryAcquireN); }
558     public void testReleaseAcquireSameThread_tryAcquireN_fair() { testReleaseAcquireSameThread(true, AcquireMethod.tryAcquireN); }
559     public void testReleaseAcquireSameThread_tryAcquireTimed()       { testReleaseAcquireSameThread(false, AcquireMethod.tryAcquireTimed); }
560     public void testReleaseAcquireSameThread_tryAcquireTimed_fair()  { testReleaseAcquireSameThread(true, AcquireMethod.tryAcquireTimed); }
561     public void testReleaseAcquireSameThread_tryAcquireTimedN()      { testReleaseAcquireSameThread(false, AcquireMethod.tryAcquireTimedN); }
562     public void testReleaseAcquireSameThread_tryAcquireTimedN_fair() { testReleaseAcquireSameThread(true, AcquireMethod.tryAcquireTimedN); }
563     public void testReleaseAcquireSameThread(boolean fair,
564                                              final AcquireMethod acquirer) {
565         Semaphore s = new Semaphore(1, fair);
566         for (int i = 1; i &lt; 6; i++) {
567             s.release(i);
568             assertEquals(1 + i, s.availablePermits());
569             try {
570                 acquirer.acquire(s, i);
571             } catch (InterruptedException e) { threadUnexpectedException(e); }
572             assertEquals(1, s.availablePermits());
573         }
574     }
575 
576     /**
577      * release in one thread enables acquire in another thread
578      */
579     public void testReleaseAcquireDifferentThreads_acquire()       { testReleaseAcquireDifferentThreads(false, AcquireMethod.acquire); }
580     public void testReleaseAcquireDifferentThreads_acquire_fair()  { testReleaseAcquireDifferentThreads(true, AcquireMethod.acquire); }
581     public void testReleaseAcquireDifferentThreads_acquireN()      { testReleaseAcquireDifferentThreads(false, AcquireMethod.acquireN); }
582     public void testReleaseAcquireDifferentThreads_acquireN_fair() { testReleaseAcquireDifferentThreads(true, AcquireMethod.acquireN); }
583     public void testReleaseAcquireDifferentThreads_acquireUninterruptibly()       { testReleaseAcquireDifferentThreads(false, AcquireMethod.acquireUninterruptibly); }
584     public void testReleaseAcquireDifferentThreads_acquireUninterruptibly_fair()  { testReleaseAcquireDifferentThreads(true, AcquireMethod.acquireUninterruptibly); }
585     public void testReleaseAcquireDifferentThreads_acquireUninterruptiblyN()      { testReleaseAcquireDifferentThreads(false, AcquireMethod.acquireUninterruptibly); }
586     public void testReleaseAcquireDifferentThreads_acquireUninterruptiblyN_fair() { testReleaseAcquireDifferentThreads(true, AcquireMethod.acquireUninterruptibly); }
587     public void testReleaseAcquireDifferentThreads_tryAcquireTimed()       { testReleaseAcquireDifferentThreads(false, AcquireMethod.tryAcquireTimed); }
588     public void testReleaseAcquireDifferentThreads_tryAcquireTimed_fair()  { testReleaseAcquireDifferentThreads(true, AcquireMethod.tryAcquireTimed); }
589     public void testReleaseAcquireDifferentThreads_tryAcquireTimedN()      { testReleaseAcquireDifferentThreads(false, AcquireMethod.tryAcquireTimedN); }
590     public void testReleaseAcquireDifferentThreads_tryAcquireTimedN_fair() { testReleaseAcquireDifferentThreads(true, AcquireMethod.tryAcquireTimedN); }
591     public void testReleaseAcquireDifferentThreads(boolean fair,
592                                                    final AcquireMethod acquirer) {
593         final Semaphore s = new Semaphore(0, fair);
594         final int rounds = 4;
595         long startTime = System.nanoTime();
596         Thread t = newStartedThread(new CheckedRunnable() {
597             public void realRun() throws InterruptedException {
598                 for (int i = 0; i &lt; rounds; i++) {
599                     assertFalse(s.hasQueuedThreads());
600                     if (i % 2 == 0)
601                         acquirer.acquire(s);
602                     else
603                         acquirer.acquire(s, 3);
604                 }}});
605 
606         for (int i = 0; i &lt; rounds; i++) {
607             while (! (s.availablePermits() == 0 &amp;&amp; s.hasQueuedThreads()))
608                 Thread.yield();
609             assertTrue(t.isAlive());
610             if (i % 2 == 0)
611                 s.release();
612             else
613                 s.release(3);
614         }
615         awaitTermination(t);
616         assertEquals(0, s.availablePermits());
617         assertTrue(millisElapsedSince(startTime) &lt; LONG_DELAY_MS);
618     }
619 
620     /**
621      * fair locks are strictly FIFO
622      */
623     public void testFairLocksFifo() {
624         final PublicSemaphore s = new PublicSemaphore(1, true);
625         final CountDownLatch pleaseRelease = new CountDownLatch(1);
626         Thread t1 = newStartedThread(new CheckedRunnable() {
627             public void realRun() throws InterruptedException {
628                 // Will block; permits are available, but not three
629                 s.acquire(3);
630             }});
631 
632         waitForQueuedThread(s, t1);
633 
634         Thread t2 = newStartedThread(new CheckedRunnable() {
635             public void realRun() throws InterruptedException {
636                 // Will fail, even though 1 permit is available
637                 assertFalse(
638                     s.tryAcquire(randomExpiredTimeout(), randomTimeUnit()));
639                 assertFalse(
640                     s.tryAcquire(1, randomExpiredTimeout(), randomTimeUnit()));
641 
642                 // untimed tryAcquire will barge and succeed
643                 assertTrue(s.tryAcquire());
644                 s.release(2);
645                 assertTrue(s.tryAcquire(2));
646                 s.release();
647 
648                 pleaseRelease.countDown();
649                 // Will queue up behind t1, even though 1 permit is available
650                 s.acquire();
651             }});
652 
653         await(pleaseRelease);
654         waitForQueuedThread(s, t2);
655         s.release(2);
656         awaitTermination(t1);
657         assertTrue(t2.isAlive());
658         s.release();
659         awaitTermination(t2);
660     }
661 
662     /**
663      * toString indicates current number of permits
664      */
665     public void testToString()      { testToString(false); }
666     public void testToString_fair() { testToString(true); }
667     public void testToString(boolean fair) {
668         PublicSemaphore s = new PublicSemaphore(0, fair);
669         assertTrue(s.toString().contains(&quot;Permits = 0&quot;));
670         s.release();
671         assertTrue(s.toString().contains(&quot;Permits = 1&quot;));
672         s.release(2);
673         assertTrue(s.toString().contains(&quot;Permits = 3&quot;));
674         s.reducePermits(5);
675         assertTrue(s.toString().contains(&quot;Permits = -2&quot;));
676     }
677 
678 }
<a name="6" id="anc6"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="6" type="hidden" />
</body>
</html>
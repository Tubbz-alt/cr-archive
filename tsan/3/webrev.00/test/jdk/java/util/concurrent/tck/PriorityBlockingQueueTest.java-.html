<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old test/jdk/java/util/concurrent/tck/PriorityBlockingQueueTest.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  3  *
  4  * This code is free software; you can redistribute it and/or modify it
  5  * under the terms of the GNU General Public License version 2 only, as
  6  * published by the Free Software Foundation.
  7  *
  8  * This code is distributed in the hope that it will be useful, but WITHOUT
  9  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 10  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 11  * version 2 for more details (a copy is included in the LICENSE file that
 12  * accompanied this code).
 13  *
 14  * You should have received a copy of the GNU General Public License version
 15  * 2 along with this work; if not, write to the Free Software Foundation,
 16  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 17  *
 18  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 19  * or visit www.oracle.com if you need additional information or have any
 20  * questions.
 21  */
 22 
 23 /*
 24  * This file is available under and governed by the GNU General Public
 25  * License version 2 only, as published by the Free Software Foundation.
 26  * However, the following notice accompanied the original version of this
 27  * file:
 28  *
 29  * Written by Doug Lea with assistance from members of JCP JSR-166
 30  * Expert Group and released to the public domain, as explained at
 31  * http://creativecommons.org/publicdomain/zero/1.0/
 32  * Other contributors include Andrew Wright, Jeffrey Hayes,
 33  * Pat Fisher, Mike Judd.
 34  */
 35 
 36 import static java.util.concurrent.TimeUnit.MILLISECONDS;
 37 
 38 import java.util.ArrayList;
 39 import java.util.Arrays;
 40 import java.util.Collection;
 41 import java.util.Comparator;
 42 import java.util.Iterator;
 43 import java.util.NoSuchElementException;
 44 import java.util.Queue;
 45 import java.util.concurrent.BlockingQueue;
 46 import java.util.concurrent.CountDownLatch;
 47 import java.util.concurrent.Executors;
 48 import java.util.concurrent.ExecutorService;
 49 import java.util.concurrent.PriorityBlockingQueue;
 50 import java.util.concurrent.ThreadLocalRandom;
 51 
 52 import junit.framework.Test;
 53 
 54 public class PriorityBlockingQueueTest extends JSR166TestCase {
 55 
 56     public static class Generic extends BlockingQueueTest {
 57         protected BlockingQueue emptyCollection() {
 58             return new PriorityBlockingQueue();
 59         }
 60     }
 61 
 62     public static class InitialCapacity extends BlockingQueueTest {
 63         protected BlockingQueue emptyCollection() {
 64             ThreadLocalRandom rnd = ThreadLocalRandom.current();
 65             int initialCapacity = rnd.nextInt(1, SIZE);
 66             return new PriorityBlockingQueue(initialCapacity);
 67         }
 68     }
 69 
 70     public static void main(String[] args) {
 71         main(suite(), args);
 72     }
 73 
 74     public static Test suite() {
 75         class Implementation implements CollectionImplementation {
 76             public Class&lt;?&gt; klazz() { return PriorityBlockingQueue.class; }
 77             public Collection emptyCollection() {
 78                 return new PriorityBlockingQueue();
 79             }
 80             public Object makeElement(int i) { return i; }
 81             public boolean isConcurrent() { return true; }
 82             public boolean permitsNulls() { return false; }
 83         }
 84         class ComparatorImplementation implements CollectionImplementation {
 85             public Class&lt;?&gt; klazz() { return PriorityBlockingQueue.class; }
 86             public Collection emptyCollection() {
 87                 ThreadLocalRandom rnd = ThreadLocalRandom.current();
 88                 int initialCapacity = rnd.nextInt(1, 10);
 89                 return new PriorityBlockingQueue(
 90                     initialCapacity, new MyReverseComparator());
 91             }
 92             public Object makeElement(int i) { return i; }
 93             public boolean isConcurrent() { return true; }
 94             public boolean permitsNulls() { return false; }
 95         }
 96         return newTestSuite(
 97             PriorityBlockingQueueTest.class,
 98             new Generic().testSuite(),
 99             new InitialCapacity().testSuite(),
100             CollectionTest.testSuite(new Implementation()),
101             CollectionTest.testSuite(new ComparatorImplementation()));
102     }
103 
104     /** Sample Comparator */
105     static class MyReverseComparator implements Comparator, java.io.Serializable {
106         public int compare(Object x, Object y) {
107             return ((Comparable)y).compareTo(x);
108         }
109     }
110 
111     /**
112      * Returns a new queue of given size containing consecutive
113      * Integers 0 ... n - 1.
114      */
115     private static PriorityBlockingQueue&lt;Integer&gt; populatedQueue(int n) {
116         PriorityBlockingQueue&lt;Integer&gt; q =
117             new PriorityBlockingQueue&lt;Integer&gt;(n);
118         assertTrue(q.isEmpty());
119         for (int i = n - 1; i &gt;= 0; i -= 2)
120             assertTrue(q.offer(new Integer(i)));
121         for (int i = (n &amp; 1); i &lt; n; i += 2)
122             assertTrue(q.offer(new Integer(i)));
123         assertFalse(q.isEmpty());
124         assertEquals(Integer.MAX_VALUE, q.remainingCapacity());
125         assertEquals(n, q.size());
126         assertEquals((Integer) 0, q.peek());
127         return q;
128     }
129 
130     /**
131      * A new queue has unbounded capacity
132      */
133     public void testConstructor1() {
134         assertEquals(Integer.MAX_VALUE,
135                      new PriorityBlockingQueue(SIZE).remainingCapacity());
136     }
137 
138     /**
139      * Constructor throws IllegalArgumentException if capacity argument nonpositive
140      */
141     public void testConstructor2() {
142         try {
143             new PriorityBlockingQueue(0);
144             shouldThrow();
145         } catch (IllegalArgumentException success) {}
146     }
147 
148     /**
149      * Initializing from null Collection throws NPE
150      */
151     public void testConstructor3() {
152         try {
153             new PriorityBlockingQueue(null);
154             shouldThrow();
155         } catch (NullPointerException success) {}
156     }
157 
158     /**
159      * Initializing from Collection of null elements throws NPE
160      */
161     public void testConstructor4() {
162         Collection&lt;Integer&gt; elements = Arrays.asList(new Integer[SIZE]);
163         try {
164             new PriorityBlockingQueue(elements);
165             shouldThrow();
166         } catch (NullPointerException success) {}
167     }
168 
169     /**
170      * Initializing from Collection with some null elements throws NPE
171      */
172     public void testConstructor5() {
173         Integer[] ints = new Integer[SIZE];
174         for (int i = 0; i &lt; SIZE - 1; ++i)
175             ints[i] = i;
176         Collection&lt;Integer&gt; elements = Arrays.asList(ints);
177         try {
178             new PriorityBlockingQueue(elements);
179             shouldThrow();
180         } catch (NullPointerException success) {}
181     }
182 
183     /**
184      * Queue contains all elements of collection used to initialize
185      */
186     public void testConstructor6() {
187         Integer[] ints = new Integer[SIZE];
188         for (int i = 0; i &lt; SIZE; ++i)
189             ints[i] = i;
190         PriorityBlockingQueue q = new PriorityBlockingQueue(Arrays.asList(ints));
191         for (int i = 0; i &lt; SIZE; ++i)
192             assertEquals(ints[i], q.poll());
193     }
194 
195     /**
196      * The comparator used in constructor is used
197      */
198     public void testConstructor7() {
199         MyReverseComparator cmp = new MyReverseComparator();
200         PriorityBlockingQueue q = new PriorityBlockingQueue(SIZE, cmp);
201         assertEquals(cmp, q.comparator());
202         Integer[] ints = new Integer[SIZE];
203         for (int i = 0; i &lt; SIZE; ++i)
204             ints[i] = new Integer(i);
205         q.addAll(Arrays.asList(ints));
206         for (int i = SIZE - 1; i &gt;= 0; --i)
207             assertEquals(ints[i], q.poll());
208     }
209 
210     /**
211      * isEmpty is true before add, false after
212      */
213     public void testEmpty() {
214         PriorityBlockingQueue q = new PriorityBlockingQueue(2);
215         assertTrue(q.isEmpty());
216         assertEquals(Integer.MAX_VALUE, q.remainingCapacity());
217         q.add(one);
218         assertFalse(q.isEmpty());
219         q.add(two);
220         q.remove();
221         q.remove();
222         assertTrue(q.isEmpty());
223     }
224 
225     /**
226      * remainingCapacity() always returns Integer.MAX_VALUE
227      */
228     public void testRemainingCapacity() {
229         BlockingQueue q = populatedQueue(SIZE);
230         for (int i = 0; i &lt; SIZE; ++i) {
231             assertEquals(Integer.MAX_VALUE, q.remainingCapacity());
232             assertEquals(SIZE - i, q.size());
233             assertEquals(i, q.remove());
234         }
235         for (int i = 0; i &lt; SIZE; ++i) {
236             assertEquals(Integer.MAX_VALUE, q.remainingCapacity());
237             assertEquals(i, q.size());
238             assertTrue(q.add(i));
239         }
240     }
241 
242     /**
243      * Offer of comparable element succeeds
244      */
245     public void testOffer() {
246         PriorityBlockingQueue q = new PriorityBlockingQueue(1);
247         assertTrue(q.offer(zero));
248         assertTrue(q.offer(one));
249     }
250 
251     /**
252      * Offer of non-Comparable throws CCE
253      */
254     public void testOfferNonComparable() {
255         PriorityBlockingQueue q = new PriorityBlockingQueue(1);
256         try {
257             q.offer(new Object());
258             shouldThrow();
259         } catch (ClassCastException success) {
260             assertTrue(q.isEmpty());
261             assertEquals(0, q.size());
262             assertNull(q.poll());
263         }
264     }
265 
266     /**
267      * add of comparable succeeds
268      */
269     public void testAdd() {
270         PriorityBlockingQueue q = new PriorityBlockingQueue(SIZE);
271         for (int i = 0; i &lt; SIZE; ++i) {
272             assertEquals(i, q.size());
273             assertTrue(q.add(new Integer(i)));
274         }
275     }
276 
277     /**
278      * addAll(this) throws IllegalArgumentException
279      */
280     public void testAddAllSelf() {
281         PriorityBlockingQueue q = populatedQueue(SIZE);
282         try {
283             q.addAll(q);
284             shouldThrow();
285         } catch (IllegalArgumentException success) {}
286     }
287 
288     /**
289      * addAll of a collection with any null elements throws NPE after
290      * possibly adding some elements
291      */
292     public void testAddAll3() {
293         PriorityBlockingQueue q = new PriorityBlockingQueue(SIZE);
294         Integer[] ints = new Integer[SIZE];
295         for (int i = 0; i &lt; SIZE - 1; ++i)
296             ints[i] = new Integer(i);
297         try {
298             q.addAll(Arrays.asList(ints));
299             shouldThrow();
300         } catch (NullPointerException success) {}
301     }
302 
303     /**
304      * Queue contains all elements of successful addAll
305      */
306     public void testAddAll5() {
307         Integer[] empty = new Integer[0];
308         Integer[] ints = new Integer[SIZE];
309         for (int i = SIZE - 1; i &gt;= 0; --i)
310             ints[i] = new Integer(i);
311         PriorityBlockingQueue q = new PriorityBlockingQueue(SIZE);
312         assertFalse(q.addAll(Arrays.asList(empty)));
313         assertTrue(q.addAll(Arrays.asList(ints)));
314         for (int i = 0; i &lt; SIZE; ++i)
315             assertEquals(ints[i], q.poll());
316     }
317 
318     /**
319      * all elements successfully put are contained
320      */
321     public void testPut() {
322         PriorityBlockingQueue q = new PriorityBlockingQueue(SIZE);
323         for (int i = 0; i &lt; SIZE; ++i) {
324             Integer x = new Integer(i);
325             q.put(x);
326             assertTrue(q.contains(x));
327         }
328         assertEquals(SIZE, q.size());
329     }
330 
331     /**
332      * put doesn&#39;t block waiting for take
333      */
334     public void testPutWithTake() throws InterruptedException {
335         final PriorityBlockingQueue q = new PriorityBlockingQueue(2);
336         final int size = 4;
337         Thread t = newStartedThread(new CheckedRunnable() {
338             public void realRun() {
339                 for (int i = 0; i &lt; size; i++)
340                     q.put(new Integer(0));
341             }});
342 
343         awaitTermination(t);
344         assertEquals(size, q.size());
345         q.take();
346     }
347 
348     /**
349      * timed offer does not time out
350      */
351     public void testTimedOffer() {
352         final PriorityBlockingQueue q = new PriorityBlockingQueue(2);
353         Thread t = newStartedThread(new CheckedRunnable() {
354             public void realRun() {
355                 q.put(new Integer(0));
356                 q.put(new Integer(0));
357                 assertTrue(q.offer(new Integer(0), SHORT_DELAY_MS, MILLISECONDS));
358                 assertTrue(q.offer(new Integer(0), LONG_DELAY_MS, MILLISECONDS));
359             }});
360 
361         awaitTermination(t);
362     }
363 
364     /**
365      * take retrieves elements in priority order
366      */
367     public void testTake() throws InterruptedException {
368         PriorityBlockingQueue q = populatedQueue(SIZE);
369         for (int i = 0; i &lt; SIZE; ++i) {
370             assertEquals(i, q.take());
371         }
372     }
373 
374     /**
375      * Take removes existing elements until empty, then blocks interruptibly
376      */
377     public void testBlockingTake() throws InterruptedException {
378         final PriorityBlockingQueue q = populatedQueue(SIZE);
379         final CountDownLatch pleaseInterrupt = new CountDownLatch(1);
380         Thread t = newStartedThread(new CheckedRunnable() {
381             public void realRun() throws InterruptedException {
382                 for (int i = 0; i &lt; SIZE; i++) assertEquals(i, q.take());
383 
384                 Thread.currentThread().interrupt();
385                 try {
386                     q.take();
387                     shouldThrow();
388                 } catch (InterruptedException success) {}
389                 assertFalse(Thread.interrupted());
390 
391                 pleaseInterrupt.countDown();
392                 try {
393                     q.take();
394                     shouldThrow();
395                 } catch (InterruptedException success) {}
396                 assertFalse(Thread.interrupted());
397             }});
398 
399         await(pleaseInterrupt);
400         assertThreadBlocks(t, Thread.State.WAITING);
401         t.interrupt();
402         awaitTermination(t);
403     }
404 
405     /**
406      * poll succeeds unless empty
407      */
408     public void testPoll() {
409         PriorityBlockingQueue q = populatedQueue(SIZE);
410         for (int i = 0; i &lt; SIZE; ++i) {
411             assertEquals(i, q.poll());
412         }
413         assertNull(q.poll());
414     }
415 
416     /**
417      * timed poll with zero timeout succeeds when non-empty, else times out
418      */
419     public void testTimedPoll0() throws InterruptedException {
420         PriorityBlockingQueue q = populatedQueue(SIZE);
421         for (int i = 0; i &lt; SIZE; ++i) {
422             assertEquals(i, q.poll(0, MILLISECONDS));
423         }
424         assertNull(q.poll(0, MILLISECONDS));
425     }
426 
427     /**
428      * timed poll with nonzero timeout succeeds when non-empty, else times out
429      */
430     public void testTimedPoll() throws InterruptedException {
431         PriorityBlockingQueue&lt;Integer&gt; q = populatedQueue(SIZE);
432         for (int i = 0; i &lt; SIZE; ++i) {
433             long startTime = System.nanoTime();
434             assertEquals(i, (int) q.poll(LONG_DELAY_MS, MILLISECONDS));
435             assertTrue(millisElapsedSince(startTime) &lt; LONG_DELAY_MS);
436         }
437         long startTime = System.nanoTime();
438         assertNull(q.poll(timeoutMillis(), MILLISECONDS));
439         assertTrue(millisElapsedSince(startTime) &gt;= timeoutMillis());
440         checkEmpty(q);
441     }
442 
443     /**
444      * Interrupted timed poll throws InterruptedException instead of
445      * returning timeout status
446      */
447     public void testInterruptedTimedPoll() throws InterruptedException {
448         final BlockingQueue&lt;Integer&gt; q = populatedQueue(SIZE);
449         final CountDownLatch pleaseInterrupt = new CountDownLatch(1);
450         Thread t = newStartedThread(new CheckedRunnable() {
451             public void realRun() throws InterruptedException {
452                 long startTime = System.nanoTime();
453                 for (int i = 0; i &lt; SIZE; i++)
454                     assertEquals(i, (int) q.poll(LONG_DELAY_MS, MILLISECONDS));
455 
456                 Thread.currentThread().interrupt();
457                 try {
458                     q.poll(LONG_DELAY_MS, MILLISECONDS);
459                     shouldThrow();
460                 } catch (InterruptedException success) {}
461                 assertFalse(Thread.interrupted());
462 
463                 pleaseInterrupt.countDown();
464                 try {
465                     q.poll(LONG_DELAY_MS, MILLISECONDS);
466                     shouldThrow();
467                 } catch (InterruptedException success) {}
468                 assertFalse(Thread.interrupted());
469 
470                 assertTrue(millisElapsedSince(startTime) &lt; LONG_DELAY_MS);
471             }});
472 
473         await(pleaseInterrupt);
474         assertThreadBlocks(t, Thread.State.TIMED_WAITING);
475         t.interrupt();
476         awaitTermination(t);
477     }
478 
479     /**
480      * peek returns next element, or null if empty
481      */
482     public void testPeek() {
483         PriorityBlockingQueue q = populatedQueue(SIZE);
484         for (int i = 0; i &lt; SIZE; ++i) {
485             assertEquals(i, q.peek());
486             assertEquals(i, q.poll());
487             assertTrue(q.peek() == null ||
488                        !q.peek().equals(i));
489         }
490         assertNull(q.peek());
491     }
492 
493     /**
494      * element returns next element, or throws NSEE if empty
495      */
496     public void testElement() {
497         PriorityBlockingQueue q = populatedQueue(SIZE);
498         for (int i = 0; i &lt; SIZE; ++i) {
499             assertEquals(i, q.element());
500             assertEquals(i, q.poll());
501         }
502         try {
503             q.element();
504             shouldThrow();
505         } catch (NoSuchElementException success) {}
506     }
507 
508     /**
509      * remove removes next element, or throws NSEE if empty
510      */
511     public void testRemove() {
512         PriorityBlockingQueue q = populatedQueue(SIZE);
513         for (int i = 0; i &lt; SIZE; ++i) {
514             assertEquals(i, q.remove());
515         }
516         try {
517             q.remove();
518             shouldThrow();
519         } catch (NoSuchElementException success) {}
520     }
521 
522     /**
523      * contains(x) reports true when elements added but not yet removed
524      */
525     public void testContains() {
526         PriorityBlockingQueue q = populatedQueue(SIZE);
527         for (int i = 0; i &lt; SIZE; ++i) {
528             assertTrue(q.contains(new Integer(i)));
529             q.poll();
530             assertFalse(q.contains(new Integer(i)));
531         }
532     }
533 
534     /**
535      * clear removes all elements
536      */
537     public void testClear() {
538         PriorityBlockingQueue q = populatedQueue(SIZE);
539         q.clear();
540         assertTrue(q.isEmpty());
541         assertEquals(0, q.size());
542         q.add(one);
543         assertFalse(q.isEmpty());
544         assertTrue(q.contains(one));
545         q.clear();
546         assertTrue(q.isEmpty());
547     }
548 
549     /**
550      * containsAll(c) is true when c contains a subset of elements
551      */
552     public void testContainsAll() {
553         PriorityBlockingQueue q = populatedQueue(SIZE);
554         PriorityBlockingQueue p = new PriorityBlockingQueue(SIZE);
555         for (int i = 0; i &lt; SIZE; ++i) {
556             assertTrue(q.containsAll(p));
557             assertFalse(p.containsAll(q));
558             p.add(new Integer(i));
559         }
560         assertTrue(p.containsAll(q));
561     }
562 
563     /**
564      * retainAll(c) retains only those elements of c and reports true if changed
565      */
566     public void testRetainAll() {
567         PriorityBlockingQueue q = populatedQueue(SIZE);
568         PriorityBlockingQueue p = populatedQueue(SIZE);
569         for (int i = 0; i &lt; SIZE; ++i) {
570             boolean changed = q.retainAll(p);
571             if (i == 0)
572                 assertFalse(changed);
573             else
574                 assertTrue(changed);
575 
576             assertTrue(q.containsAll(p));
577             assertEquals(SIZE - i, q.size());
578             p.remove();
579         }
580     }
581 
582     /**
583      * removeAll(c) removes only those elements of c and reports true if changed
584      */
585     public void testRemoveAll() {
586         for (int i = 1; i &lt; SIZE; ++i) {
587             PriorityBlockingQueue q = populatedQueue(SIZE);
588             PriorityBlockingQueue p = populatedQueue(i);
589             assertTrue(q.removeAll(p));
590             assertEquals(SIZE - i, q.size());
591             for (int j = 0; j &lt; i; ++j) {
592                 Integer x = (Integer)(p.remove());
593                 assertFalse(q.contains(x));
594             }
595         }
596     }
597 
598     /**
599      * toArray contains all elements
600      */
601     public void testToArray() throws InterruptedException {
602         PriorityBlockingQueue q = populatedQueue(SIZE);
603         Object[] a = q.toArray();
604         assertSame(Object[].class, a.getClass());
605         Arrays.sort(a);
606         for (Object o : a)
607             assertSame(o, q.take());
608         assertTrue(q.isEmpty());
609     }
610 
611     /**
612      * toArray(a) contains all elements
613      */
614     public void testToArray2() throws InterruptedException {
615         PriorityBlockingQueue&lt;Integer&gt; q = populatedQueue(SIZE);
616         Integer[] ints = new Integer[SIZE];
617         Integer[] array = q.toArray(ints);
618         assertSame(ints, array);
619         Arrays.sort(ints);
620         for (Integer o : ints)
621             assertSame(o, q.take());
622         assertTrue(q.isEmpty());
623     }
624 
625     /**
626      * toArray(incompatible array type) throws ArrayStoreException
627      */
628     public void testToArray1_BadArg() {
629         PriorityBlockingQueue q = populatedQueue(SIZE);
630         try {
631             q.toArray(new String[10]);
632             shouldThrow();
633         } catch (ArrayStoreException success) {}
634     }
635 
636     /**
637      * iterator iterates through all elements
638      */
639     public void testIterator() {
640         PriorityBlockingQueue q = populatedQueue(SIZE);
641         Iterator it = q.iterator();
642         int i;
643         for (i = 0; it.hasNext(); i++)
644             assertTrue(q.contains(it.next()));
645         assertEquals(i, SIZE);
646         assertIteratorExhausted(it);
647     }
648 
649     /**
650      * iterator of empty collection has no elements
651      */
652     public void testEmptyIterator() {
653         assertIteratorExhausted(new PriorityBlockingQueue().iterator());
654     }
655 
656     /**
657      * iterator.remove removes current element
658      */
659     public void testIteratorRemove() {
660         final PriorityBlockingQueue q = new PriorityBlockingQueue(3);
661         q.add(new Integer(2));
662         q.add(new Integer(1));
663         q.add(new Integer(3));
664 
665         Iterator it = q.iterator();
666         it.next();
667         it.remove();
668 
669         it = q.iterator();
670         assertEquals(it.next(), new Integer(2));
671         assertEquals(it.next(), new Integer(3));
672         assertFalse(it.hasNext());
673     }
674 
675     /**
676      * toString contains toStrings of elements
677      */
678     public void testToString() {
679         PriorityBlockingQueue q = populatedQueue(SIZE);
680         String s = q.toString();
681         for (int i = 0; i &lt; SIZE; ++i) {
682             assertTrue(s.contains(String.valueOf(i)));
683         }
684     }
685 
686     /**
687      * timed poll transfers elements across Executor tasks
688      */
689     public void testPollInExecutor() {
690         final PriorityBlockingQueue q = new PriorityBlockingQueue(2);
691         final CheckedBarrier threadsStarted = new CheckedBarrier(2);
692         final ExecutorService executor = Executors.newFixedThreadPool(2);
693         try (PoolCleaner cleaner = cleaner(executor)) {
694             executor.execute(new CheckedRunnable() {
695                 public void realRun() throws InterruptedException {
696                     assertNull(q.poll());
697                     threadsStarted.await();
698                     assertSame(one, q.poll(LONG_DELAY_MS, MILLISECONDS));
699                     checkEmpty(q);
700                 }});
701 
702             executor.execute(new CheckedRunnable() {
703                 public void realRun() throws InterruptedException {
704                     threadsStarted.await();
705                     q.put(one);
706                 }});
707         }
708     }
709 
710     /**
711      * A deserialized/reserialized queue has same elements
712      */
713     public void testSerialization() throws Exception {
714         Queue x = populatedQueue(SIZE);
715         Queue y = serialClone(x);
716 
717         assertNotSame(x, y);
718         assertEquals(x.size(), y.size());
719         while (!x.isEmpty()) {
720             assertFalse(y.isEmpty());
721             assertEquals(x.remove(), y.remove());
722         }
723         assertTrue(y.isEmpty());
724     }
725 
726     /**
727      * drainTo(c) empties queue into another collection c
728      */
729     public void testDrainTo() {
730         PriorityBlockingQueue q = populatedQueue(SIZE);
731         ArrayList l = new ArrayList();
732         q.drainTo(l);
733         assertEquals(0, q.size());
734         assertEquals(SIZE, l.size());
735         for (int i = 0; i &lt; SIZE; ++i)
736             assertEquals(l.get(i), new Integer(i));
737         q.add(zero);
738         q.add(one);
739         assertFalse(q.isEmpty());
740         assertTrue(q.contains(zero));
741         assertTrue(q.contains(one));
742         l.clear();
743         q.drainTo(l);
744         assertEquals(0, q.size());
745         assertEquals(2, l.size());
746         for (int i = 0; i &lt; 2; ++i)
747             assertEquals(l.get(i), new Integer(i));
748     }
749 
750     /**
751      * drainTo empties queue
752      */
753     public void testDrainToWithActivePut() throws InterruptedException {
754         final PriorityBlockingQueue q = populatedQueue(SIZE);
755         Thread t = new Thread(new CheckedRunnable() {
756             public void realRun() {
757                 q.put(new Integer(SIZE + 1));
758             }});
759 
760         t.start();
761         ArrayList l = new ArrayList();
762         q.drainTo(l);
763         assertTrue(l.size() &gt;= SIZE);
764         for (int i = 0; i &lt; SIZE; ++i)
765             assertEquals(l.get(i), new Integer(i));
766         t.join();
767         assertTrue(q.size() + l.size() &gt;= SIZE);
768     }
769 
770     /**
771      * drainTo(c, n) empties first min(n, size) elements of queue into c
772      */
773     public void testDrainToN() {
774         PriorityBlockingQueue q = new PriorityBlockingQueue(SIZE * 2);
775         for (int i = 0; i &lt; SIZE + 2; ++i) {
776             for (int j = 0; j &lt; SIZE; j++)
777                 assertTrue(q.offer(new Integer(j)));
778             ArrayList l = new ArrayList();
779             q.drainTo(l, i);
780             int k = (i &lt; SIZE) ? i : SIZE;
781             assertEquals(k, l.size());
782             assertEquals(SIZE - k, q.size());
783             for (int j = 0; j &lt; k; ++j)
784                 assertEquals(l.get(j), new Integer(j));
785             do {} while (q.poll() != null);
786         }
787     }
788 
789     /**
790      * remove(null), contains(null) always return false
791      */
792     public void testNeverContainsNull() {
793         Collection&lt;?&gt;[] qs = {
794             new PriorityBlockingQueue&lt;Object&gt;(),
795             populatedQueue(2),
796         };
797 
798         for (Collection&lt;?&gt; q : qs) {
799             assertFalse(q.contains(null));
800             assertFalse(q.remove(null));
801         }
802     }
803 
804 }
    </pre>
  </body>
</html>
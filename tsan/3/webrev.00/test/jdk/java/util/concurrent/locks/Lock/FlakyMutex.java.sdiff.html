<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff test/jdk/java/util/concurrent/locks/Lock/FlakyMutex.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
<body>
<center><a href="CheckedLockLoops.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="TimedAcquireLeak.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>test/jdk/java/util/concurrent/locks/Lock/FlakyMutex.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 32 import java.util.concurrent.CyclicBarrier;
 33 import java.util.concurrent.ExecutorService;
 34 import java.util.concurrent.Executors;
 35 import java.util.concurrent.TimeUnit;
 36 import java.util.concurrent.locks.AbstractQueuedLongSynchronizer;
 37 import java.util.concurrent.locks.Condition;
 38 import java.util.concurrent.locks.Lock;
 39 
 40 /**
 41  * This uses a variant of the standard Mutex demo, except with a
 42  * tryAcquire method that randomly throws various Throwable
 43  * subclasses.
 44  */
 45 @SuppressWarnings(&quot;serial&quot;)
 46 public class FlakyMutex implements Lock {
 47     static class MyError extends Error {}
 48     static class MyException extends Exception {}
 49     static class MyRuntimeException extends RuntimeException {}
 50 
 51     static void checkThrowable(Throwable t) {
<span class="line-modified"> 52         check((t instanceof MyError) ||</span>
 53               (t instanceof MyException) ||
<span class="line-modified"> 54               (t instanceof MyRuntimeException));</span>

 55     }
 56 
 57     static void realMain(String[] args) throws Throwable {
<span class="line-modified"> 58         final int nThreads = 3;</span>



 59         final int iterations = 10_000;
 60         final CyclicBarrier startingGate = new CyclicBarrier(nThreads);
<span class="line-removed"> 61         final FlakyMutex mutex = new FlakyMutex();</span>
 62         final ExecutorService es = Executors.newFixedThreadPool(nThreads);

 63         final Runnable task = () -&gt; {
 64             try {

 65                 startingGate.await();
 66                 for (int i = 0; i &lt; iterations; i++) {
 67                     for (;;) {
<span class="line-modified"> 68                         try { mutex.lock(); break; }</span>
<span class="line-modified"> 69                         catch (Throwable t) { checkThrowable(t); }</span>











 70                     }
 71 
<span class="line-modified"> 72                     try { check(! mutex.tryLock()); }</span>
<span class="line-modified"> 73                     catch (Throwable t) { checkThrowable(t); }</span>



 74 
<span class="line-modified"> 75                     try { check(! mutex.tryLock(1, TimeUnit.MICROSECONDS)); }</span>
<span class="line-modified"> 76                     catch (Throwable t) { checkThrowable(t); }</span>

 77 
 78                     mutex.unlock();
 79                 }
 80             } catch (Throwable t) { unexpected(t); }
 81         };
 82 
 83         for (int i = 0; i &lt; nThreads; i++)
 84             es.submit(task);
 85         es.shutdown();
 86         // Let test harness handle timeout
 87         check(es.awaitTermination(Long.MAX_VALUE, TimeUnit.DAYS));
 88     }
 89 
 90     private static class FlakySync extends AbstractQueuedLongSynchronizer {
 91         private static final long serialVersionUID = -1L;
 92 
 93         public boolean isHeldExclusively() { return getState() == 1; }
 94 
 95         public boolean tryAcquire(long acquires) {
 96             // Sneak in some tests for queue state
</pre>
<hr />
<pre>
129     }
130     public boolean tryLock(long timeout, TimeUnit unit) throws InterruptedException {
131         return sync.tryAcquireNanos(1, unit.toNanos(timeout));
132     }
133     public void unlock() { sync.release(1); }
134     public Condition newCondition()   { return sync.newCondition(); }
135     public boolean isLocked()         { return sync.isHeldExclusively(); }
136     public boolean hasQueuedThreads() { return sync.hasQueuedThreads(); }
137 
138     //--------------------- Infrastructure ---------------------------
139     static volatile int passed = 0, failed = 0;
140     static void pass() {passed++;}
141     static void fail() {failed++; Thread.dumpStack();}
142     static void fail(String msg) {System.out.println(msg); fail();}
143     static void unexpected(Throwable t) {failed++; t.printStackTrace();}
144     static void check(boolean cond) {if (cond) pass(); else fail();}
145     static void equal(Object x, Object y) {
146         if (x == null ? y == null : x.equals(y)) pass();
147         else fail(x + &quot; not equal to &quot; + y);}
148     public static void main(String[] args) throws Throwable {
<span class="line-modified">149         try {realMain(args);} catch (Throwable t) {unexpected(t);}</span>




150         System.out.printf(&quot;%nPassed = %d, failed = %d%n%n&quot;, passed, failed);
151         if (failed &gt; 0) throw new AssertionError(&quot;Some tests failed&quot;);}
152     @SuppressWarnings(&quot;unchecked&quot;)
153     static &lt;T extends Throwable&gt; void uncheckedThrow(Throwable t) throws T {
154         throw (T)t; // rely on vacuous cast
155     }
156 }
</pre>
</td>
<td>
<hr />
<pre>
 32 import java.util.concurrent.CyclicBarrier;
 33 import java.util.concurrent.ExecutorService;
 34 import java.util.concurrent.Executors;
 35 import java.util.concurrent.TimeUnit;
 36 import java.util.concurrent.locks.AbstractQueuedLongSynchronizer;
 37 import java.util.concurrent.locks.Condition;
 38 import java.util.concurrent.locks.Lock;
 39 
 40 /**
 41  * This uses a variant of the standard Mutex demo, except with a
 42  * tryAcquire method that randomly throws various Throwable
 43  * subclasses.
 44  */
 45 @SuppressWarnings(&quot;serial&quot;)
 46 public class FlakyMutex implements Lock {
 47     static class MyError extends Error {}
 48     static class MyException extends Exception {}
 49     static class MyRuntimeException extends RuntimeException {}
 50 
 51     static void checkThrowable(Throwable t) {
<span class="line-modified"> 52         if (!((t instanceof MyError) ||</span>
 53               (t instanceof MyException) ||
<span class="line-modified"> 54               (t instanceof MyRuntimeException)))</span>
<span class="line-added"> 55             unexpected(t);</span>
 56     }
 57 
 58     static void realMain(String[] args) throws Throwable {
<span class="line-modified"> 59         final ThreadLocalRandom rndMain = ThreadLocalRandom.current();</span>
<span class="line-added"> 60         final int nCpus = Runtime.getRuntime().availableProcessors();</span>
<span class="line-added"> 61         final int maxThreads = Math.min(4, nCpus);</span>
<span class="line-added"> 62         final int nThreads = rndMain.nextInt(1, maxThreads + 1);</span>
 63         final int iterations = 10_000;
 64         final CyclicBarrier startingGate = new CyclicBarrier(nThreads);

 65         final ExecutorService es = Executors.newFixedThreadPool(nThreads);
<span class="line-added"> 66         final FlakyMutex mutex = new FlakyMutex();</span>
 67         final Runnable task = () -&gt; {
 68             try {
<span class="line-added"> 69                 ThreadLocalRandom rnd = ThreadLocalRandom.current();</span>
 70                 startingGate.await();
 71                 for (int i = 0; i &lt; iterations; i++) {
 72                     for (;;) {
<span class="line-modified"> 73                         try {</span>
<span class="line-modified"> 74                             if (rnd.nextBoolean())</span>
<span class="line-added"> 75                                 mutex.lock();</span>
<span class="line-added"> 76                             else</span>
<span class="line-added"> 77                                 mutex.lockInterruptibly();</span>
<span class="line-added"> 78                             break;</span>
<span class="line-added"> 79                         } catch (Throwable t) { checkThrowable(t); }</span>
<span class="line-added"> 80                     }</span>
<span class="line-added"> 81 </span>
<span class="line-added"> 82                     if (rnd.nextBoolean()) {</span>
<span class="line-added"> 83                         try {</span>
<span class="line-added"> 84                             check(! mutex.tryLock());</span>
<span class="line-added"> 85                         } catch (Throwable t) { checkThrowable(t); }</span>
 86                     }
 87 
<span class="line-modified"> 88                     if (rnd.nextInt(10) == 0) {</span>
<span class="line-modified"> 89                         try {</span>
<span class="line-added"> 90                             check(! mutex.tryLock(1, TimeUnit.MICROSECONDS));</span>
<span class="line-added"> 91                         } catch (Throwable t) { checkThrowable(t); }</span>
<span class="line-added"> 92                     }</span>
 93 
<span class="line-modified"> 94                     if (rnd.nextBoolean()) {</span>
<span class="line-modified"> 95                         check(mutex.isLocked());</span>
<span class="line-added"> 96                     }</span>
 97 
 98                     mutex.unlock();
 99                 }
100             } catch (Throwable t) { unexpected(t); }
101         };
102 
103         for (int i = 0; i &lt; nThreads; i++)
104             es.submit(task);
105         es.shutdown();
106         // Let test harness handle timeout
107         check(es.awaitTermination(Long.MAX_VALUE, TimeUnit.DAYS));
108     }
109 
110     private static class FlakySync extends AbstractQueuedLongSynchronizer {
111         private static final long serialVersionUID = -1L;
112 
113         public boolean isHeldExclusively() { return getState() == 1; }
114 
115         public boolean tryAcquire(long acquires) {
116             // Sneak in some tests for queue state
</pre>
<hr />
<pre>
149     }
150     public boolean tryLock(long timeout, TimeUnit unit) throws InterruptedException {
151         return sync.tryAcquireNanos(1, unit.toNanos(timeout));
152     }
153     public void unlock() { sync.release(1); }
154     public Condition newCondition()   { return sync.newCondition(); }
155     public boolean isLocked()         { return sync.isHeldExclusively(); }
156     public boolean hasQueuedThreads() { return sync.hasQueuedThreads(); }
157 
158     //--------------------- Infrastructure ---------------------------
159     static volatile int passed = 0, failed = 0;
160     static void pass() {passed++;}
161     static void fail() {failed++; Thread.dumpStack();}
162     static void fail(String msg) {System.out.println(msg); fail();}
163     static void unexpected(Throwable t) {failed++; t.printStackTrace();}
164     static void check(boolean cond) {if (cond) pass(); else fail();}
165     static void equal(Object x, Object y) {
166         if (x == null ? y == null : x.equals(y)) pass();
167         else fail(x + &quot; not equal to &quot; + y);}
168     public static void main(String[] args) throws Throwable {
<span class="line-modified">169         int runsPerTest = Integer.getInteger(&quot;jsr166.runsPerTest&quot;, 1);</span>
<span class="line-added">170         try {</span>
<span class="line-added">171             for (int i = runsPerTest; i--&gt; 0; )</span>
<span class="line-added">172                 realMain(args);</span>
<span class="line-added">173         } catch (Throwable t) { unexpected(t); }</span>
174         System.out.printf(&quot;%nPassed = %d, failed = %d%n%n&quot;, passed, failed);
175         if (failed &gt; 0) throw new AssertionError(&quot;Some tests failed&quot;);}
176     @SuppressWarnings(&quot;unchecked&quot;)
177     static &lt;T extends Throwable&gt; void uncheckedThrow(Throwable t) throws T {
178         throw (T)t; // rely on vacuous cast
179     }
180 }
</pre>
</td>
</tr>
</table>
<center><a href="CheckedLockLoops.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="TimedAcquireLeak.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
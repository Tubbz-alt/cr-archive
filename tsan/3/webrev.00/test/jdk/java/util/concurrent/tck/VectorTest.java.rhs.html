<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames test/jdk/java/util/concurrent/tck/VectorTest.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  3  *
  4  * This code is free software; you can redistribute it and/or modify it
  5  * under the terms of the GNU General Public License version 2 only, as
  6  * published by the Free Software Foundation.
  7  *
  8  * This code is distributed in the hope that it will be useful, but WITHOUT
  9  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 10  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 11  * version 2 for more details (a copy is included in the LICENSE file that
 12  * accompanied this code).
 13  *
 14  * You should have received a copy of the GNU General Public License version
 15  * 2 along with this work; if not, write to the Free Software Foundation,
 16  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 17  *
 18  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 19  * or visit www.oracle.com if you need additional information or have any
 20  * questions.
 21  */
 22 
 23 /*
 24  * This file is available under and governed by the GNU General Public
 25  * License version 2 only, as published by the Free Software Foundation.
 26  * However, the following notice accompanied the original version of this
 27  * file:
 28  *
 29  * Written by Doug Lea and Martin Buchholz with assistance from
 30  * members of JCP JSR-166 Expert Group and released to the public
 31  * domain, as explained at
 32  * http://creativecommons.org/publicdomain/zero/1.0/
 33  */
 34 
 35 import java.util.Arrays;
 36 import java.util.Collection;
 37 import java.util.Collections;
 38 import java.util.List;
 39 import java.util.Vector;
 40 import java.util.concurrent.ThreadLocalRandom;
 41 
 42 import junit.framework.Test;
 43 
 44 public class VectorTest extends JSR166TestCase {
 45     public static void main(String[] args) {
 46         main(suite(), args);
 47     }
 48 
 49     public static Test suite() {
 50         class Implementation implements CollectionImplementation {
 51             public Class&lt;?&gt; klazz() { return Vector.class; }
 52             public List emptyCollection() { return new Vector(); }
 53             public Object makeElement(int i) { return i; }
 54             public boolean isConcurrent() { return false; }
 55             public boolean permitsNulls() { return true; }
 56         }
 57         class SubListImplementation extends Implementation {
 58             public List emptyCollection() {
 59                 List list = super.emptyCollection();
 60                 ThreadLocalRandom rnd = ThreadLocalRandom.current();
 61                 if (rnd.nextBoolean())
 62                     list.add(makeElement(rnd.nextInt()));
 63                 int i = rnd.nextInt(list.size() + 1);
 64                 return list.subList(i, i);
 65             }
 66         }
 67         return newTestSuite(
 68                 VectorTest.class,
 69                 CollectionTest.testSuite(new Implementation()),
 70                 CollectionTest.testSuite(new SubListImplementation()));
 71     }
 72 
 73     static Vector&lt;Integer&gt; populatedList(int n) {
 74         Vector&lt;Integer&gt; list = new Vector&lt;&gt;();
 75         assertTrue(list.isEmpty());
 76         for (int i = 0; i &lt; n; i++)
 77             list.add(i);
 78         assertEquals(n &lt;= 0, list.isEmpty());
 79         assertEquals(n, list.size());
 80         return list;
 81     }
 82 
 83     /**
 84      * addAll adds each element from the given collection, including duplicates
 85      */
 86     public void testAddAll() {
 87         List list = populatedList(3);
 88         assertTrue(list.addAll(Arrays.asList(three, four, five)));
 89         assertEquals(6, list.size());
 90         assertTrue(list.addAll(Arrays.asList(three, four, five)));
 91         assertEquals(9, list.size());
 92     }
 93 
 94     /**
 95      * clear removes all elements from the list
 96      */
 97     public void testClear() {
 98         List list = populatedList(SIZE);
 99         list.clear();
100         assertEquals(0, list.size());
101     }
102 
103     /**
104      * Cloned list is equal
105      */
106     public void testClone() {
107         Vector l1 = populatedList(SIZE);
108         Vector l2 = (Vector)(l1.clone());
109         assertEquals(l1, l2);
110         l1.clear();
111         assertFalse(l1.equals(l2));
112     }
113 
114     /**
115      * contains is true for added elements
116      */
117     public void testContains() {
118         List list = populatedList(3);
119         assertTrue(list.contains(one));
120         assertFalse(list.contains(five));
121     }
122 
123     /**
124      * adding at an index places it in the indicated index
125      */
126     public void testAddIndex() {
127         List list = populatedList(3);
128         list.add(0, m1);
129         assertEquals(4, list.size());
130         assertEquals(m1, list.get(0));
131         assertEquals(zero, list.get(1));
132 
133         list.add(2, m2);
134         assertEquals(5, list.size());
135         assertEquals(m2, list.get(2));
136         assertEquals(two, list.get(4));
137     }
138 
139     /**
140      * lists with same elements are equal and have same hashCode
141      */
142     public void testEquals() {
143         List a = populatedList(3);
144         List b = populatedList(3);
145         assertTrue(a.equals(b));
146         assertTrue(b.equals(a));
147         assertTrue(a.containsAll(b));
148         assertTrue(b.containsAll(a));
149         assertEquals(a.hashCode(), b.hashCode());
150         a.add(m1);
151         assertFalse(a.equals(b));
152         assertFalse(b.equals(a));
153         assertTrue(a.containsAll(b));
154         assertFalse(b.containsAll(a));
155         b.add(m1);
156         assertTrue(a.equals(b));
157         assertTrue(b.equals(a));
158         assertTrue(a.containsAll(b));
159         assertTrue(b.containsAll(a));
160         assertEquals(a.hashCode(), b.hashCode());
161 
162         assertFalse(a.equals(null));
163     }
164 
165     /**
166      * containsAll returns true for collections with subset of elements
167      */
168     public void testContainsAll() {
169         List list = populatedList(3);
170         assertTrue(list.containsAll(Arrays.asList()));
171         assertTrue(list.containsAll(Arrays.asList(one)));
172         assertTrue(list.containsAll(Arrays.asList(one, two)));
173         assertFalse(list.containsAll(Arrays.asList(one, two, six)));
174         assertFalse(list.containsAll(Arrays.asList(six)));
175 
176         try {
177             list.containsAll(null);
178             shouldThrow();
179         } catch (NullPointerException success) {}
180     }
181 
182     /**
183      * get returns the value at the given index
184      */
185     public void testGet() {
186         List list = populatedList(3);
187         assertEquals(0, list.get(0));
188     }
189 
190     /**
191      * indexOf(Object) returns the index of the first occurrence of the
192      * specified element in this list, or -1 if this list does not
193      * contain the element
194      */
195     public void testIndexOf() {
196         List list = populatedList(3);
197         assertEquals(-1, list.indexOf(-42));
198         int size = list.size();
199         for (int i = 0; i &lt; size; i++) {
200             assertEquals(i, list.indexOf(i));
201             assertEquals(i, list.subList(0, size).indexOf(i));
202             assertEquals(i, list.subList(0, i + 1).indexOf(i));
203             assertEquals(-1, list.subList(0, i).indexOf(i));
204             assertEquals(0, list.subList(i, size).indexOf(i));
205             assertEquals(-1, list.subList(i + 1, size).indexOf(i));
206         }
207 
208         list.add(1);
209         assertEquals(1, list.indexOf(1));
210         assertEquals(1, list.subList(0, size + 1).indexOf(1));
211         assertEquals(0, list.subList(1, size + 1).indexOf(1));
212         assertEquals(size - 2, list.subList(2, size + 1).indexOf(1));
213         assertEquals(0, list.subList(size, size + 1).indexOf(1));
214         assertEquals(-1, list.subList(size + 1, size + 1).indexOf(1));
215     }
216 
217     /**
218      * indexOf(E, int) returns the index of the first occurrence of the
219      * specified element in this list, searching forwards from index,
220      * or returns -1 if the element is not found
221      */
222     public void testIndexOf2() {
223         Vector list = populatedList(3);
224         int size = list.size();
225         assertEquals(-1, list.indexOf(-42, 0));
226 
227         // we might expect IOOBE, but spec says otherwise
228         assertEquals(-1, list.indexOf(0, size));
229         assertEquals(-1, list.indexOf(0, Integer.MAX_VALUE));
230 
231         assertThrows(
232             IndexOutOfBoundsException.class,
233             () -&gt; list.indexOf(0, -1),
234             () -&gt; list.indexOf(0, Integer.MIN_VALUE));
235 
236         for (int i = 0; i &lt; size; i++) {
237             assertEquals(i, list.indexOf(i, 0));
238             assertEquals(i, list.indexOf(i, i));
239             assertEquals(-1, list.indexOf(i, i + 1));
240         }
241 
242         list.add(1);
243         assertEquals(1, list.indexOf(1, 0));
244         assertEquals(1, list.indexOf(1, 1));
245         assertEquals(size, list.indexOf(1, 2));
246         assertEquals(size, list.indexOf(1, size));
247     }
248 
249     /**
250      * isEmpty returns true when empty, else false
251      */
252     public void testIsEmpty() {
253         List empty = new Vector();
254         assertTrue(empty.isEmpty());
255         assertTrue(empty.subList(0, 0).isEmpty());
256 
257         List full = populatedList(SIZE);
258         assertFalse(full.isEmpty());
259         assertTrue(full.subList(0, 0).isEmpty());
260         assertTrue(full.subList(SIZE, SIZE).isEmpty());
261     }
262 
263     /**
264      * iterator of empty collection has no elements
265      */
266     public void testEmptyIterator() {
267         Collection c = new Vector();
268         assertIteratorExhausted(c.iterator());
269     }
270 
271     /**
272      * lastIndexOf(Object) returns the index of the last occurrence of
273      * the specified element in this list, or -1 if this list does not
274      * contain the element
275      */
276     public void testLastIndexOf1() {
277         List list = populatedList(3);
278         assertEquals(-1, list.lastIndexOf(-42));
279         int size = list.size();
280         for (int i = 0; i &lt; size; i++) {
281             assertEquals(i, list.lastIndexOf(i));
282             assertEquals(i, list.subList(0, size).lastIndexOf(i));
283             assertEquals(i, list.subList(0, i + 1).lastIndexOf(i));
284             assertEquals(-1, list.subList(0, i).lastIndexOf(i));
285             assertEquals(0, list.subList(i, size).lastIndexOf(i));
286             assertEquals(-1, list.subList(i + 1, size).lastIndexOf(i));
287         }
288 
289         list.add(1);
290         assertEquals(size, list.lastIndexOf(1));
291         assertEquals(size, list.subList(0, size + 1).lastIndexOf(1));
292         assertEquals(1, list.subList(0, size).lastIndexOf(1));
293         assertEquals(0, list.subList(1, 2).lastIndexOf(1));
294         assertEquals(-1, list.subList(0, 1).indexOf(1));
295     }
296 
297     /**
298      * lastIndexOf(E, int) returns the index of the last occurrence of the
299      * specified element in this list, searching backwards from index, or
300      * returns -1 if the element is not found
301      */
302     public void testLastIndexOf2() {
303         Vector list = populatedList(3);
304 
305         // we might expect IOOBE, but spec says otherwise
306         assertEquals(-1, list.lastIndexOf(0, -1));
307 
308         int size = list.size();
309         assertThrows(
310             IndexOutOfBoundsException.class,
311             () -&gt; list.lastIndexOf(0, size),
312             () -&gt; list.lastIndexOf(0, Integer.MAX_VALUE));
313 
314         for (int i = 0; i &lt; size; i++) {
315             assertEquals(i, list.lastIndexOf(i, i));
316             assertEquals(list.indexOf(i), list.lastIndexOf(i, i));
317             if (i &gt; 0)
318                 assertEquals(-1, list.lastIndexOf(i, i - 1));
319         }
320         list.add(one);
321         list.add(three);
322         assertEquals(1, list.lastIndexOf(one, 1));
323         assertEquals(1, list.lastIndexOf(one, 2));
324         assertEquals(3, list.lastIndexOf(one, 3));
325         assertEquals(3, list.lastIndexOf(one, 4));
326         assertEquals(-1, list.lastIndexOf(three, 3));
327     }
328 
329     /**
330      * size returns the number of elements
331      */
332     public void testSize() {
333         List empty = new Vector();
334         assertEquals(0, empty.size());
335         assertEquals(0, empty.subList(0, 0).size());
336 
337         List full = populatedList(SIZE);
338         assertEquals(SIZE, full.size());
339         assertEquals(0, full.subList(0, 0).size());
340         assertEquals(0, full.subList(SIZE, SIZE).size());
341     }
342 
343     /**
344      * sublists contains elements at indexes offset from their base
345      */
346     public void testSubList() {
347         List a = populatedList(10);
348         assertTrue(a.subList(1,1).isEmpty());
349         for (int j = 0; j &lt; 9; ++j) {
350             for (int i = j ; i &lt; 10; ++i) {
351                 List b = a.subList(j,i);
352                 for (int k = j; k &lt; i; ++k) {
353                     assertEquals(new Integer(k), b.get(k-j));
354                 }
355             }
356         }
357 
358         List s = a.subList(2, 5);
359         assertEquals(3, s.size());
360         s.set(2, m1);
361         assertEquals(a.get(4), m1);
362         s.clear();
363         assertEquals(7, a.size());
364 
365         assertThrows(
366             IndexOutOfBoundsException.class,
367             () -&gt; s.get(0),
368             () -&gt; s.set(0, 42));
369     }
370 
371     /**
372      * toArray throws an ArrayStoreException when the given array
373      * can not store the objects inside the list
374      */
375     public void testToArray_ArrayStoreException() {
376         List list = new Vector();
377         // Integers are not auto-converted to Longs
378         list.add(86);
379         list.add(99);
380         assertThrows(
381             ArrayStoreException.class,
382             () -&gt; list.toArray(new Long[0]),
383             () -&gt; list.toArray(new Long[5]));
384     }
385 
386     void testIndexOutOfBoundsException(List list) {
387         int size = list.size();
388         assertThrows(
389             IndexOutOfBoundsException.class,
390             () -&gt; list.get(-1),
391             () -&gt; list.get(size),
392             () -&gt; list.set(-1, &quot;qwerty&quot;),
393             () -&gt; list.set(size, &quot;qwerty&quot;),
394             () -&gt; list.add(-1, &quot;qwerty&quot;),
395             () -&gt; list.add(size + 1, &quot;qwerty&quot;),
396             () -&gt; list.remove(-1),
397             () -&gt; list.remove(size),
398             () -&gt; list.addAll(-1, Collections.emptyList()),
399             () -&gt; list.addAll(size + 1, Collections.emptyList()),
400             () -&gt; list.listIterator(-1),
401             () -&gt; list.listIterator(size + 1),
402             () -&gt; list.subList(-1, size),
403             () -&gt; list.subList(0, size + 1));
404 
405         // Conversely, operations that must not throw
406         list.addAll(0, Collections.emptyList());
407         list.addAll(size, Collections.emptyList());
408         list.add(0, &quot;qwerty&quot;);
409         list.add(list.size(), &quot;qwerty&quot;);
410         list.get(0);
411         list.get(list.size() - 1);
412         list.set(0, &quot;azerty&quot;);
413         list.set(list.size() - 1, &quot;azerty&quot;);
414         list.listIterator(0);
415         list.listIterator(list.size());
416         list.subList(0, list.size());
417         list.remove(list.size() - 1);
418     }
419 
420     /**
421      * IndexOutOfBoundsException is thrown when specified
422      */
423     public void testIndexOutOfBoundsException() {
424         ThreadLocalRandom rnd = ThreadLocalRandom.current();
425         List x = populatedList(rnd.nextInt(5));
426         testIndexOutOfBoundsException(x);
427 
428         int start = rnd.nextInt(x.size() + 1);
429         int end = rnd.nextInt(start, x.size() + 1);
430 
431         // Vector#subList spec deviates slightly from List#subList spec
432         assertThrows(
433             IllegalArgumentException.class,
434             () -&gt; x.subList(start, start - 1));
435 
436         List subList = x.subList(start, end);
437         testIndexOutOfBoundsException(x);
438     }
439 
440     /**
441      * a deserialized/reserialized list equals original
442      */
443     public void testSerialization() throws Exception {
444         List x = populatedList(SIZE);
445         List y = serialClone(x);
446 
447         assertNotSame(x, y);
448         assertEquals(x.size(), y.size());
449         assertEquals(x.toString(), y.toString());
450         assertTrue(Arrays.equals(x.toArray(), y.toArray()));
451         assertEquals(x, y);
452         assertEquals(y, x);
453         while (!x.isEmpty()) {
454             assertFalse(y.isEmpty());
455             assertEquals(x.remove(0), y.remove(0));
456         }
457         assertTrue(y.isEmpty());
458     }
459 
460     /**
461      * tests for setSize()
462      */
463     public void testSetSize() {
464         final Vector v = new Vector();
465         for (int n : new int[] { 100, 5, 50 }) {
466             v.setSize(n);
467             assertEquals(n, v.size());
468             assertNull(v.get(0));
469             assertNull(v.get(n - 1));
<a name="1" id="anc1"></a><span class="line-modified">470             assertThrows(ArrayIndexOutOfBoundsException.class,</span>
<span class="line-modified">471                 () -&gt; v.setSize(-1));</span>

472             assertEquals(n, v.size());
473             assertNull(v.get(0));
474             assertNull(v.get(n - 1));
475         }
476     }
477 
478 }
<a name="2" id="anc2"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="2" type="hidden" />
</body>
</html>
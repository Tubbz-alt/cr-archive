<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames test/jdk/java/util/concurrent/tck/Collection8Test.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  3  *
  4  * This code is free software; you can redistribute it and/or modify it
  5  * under the terms of the GNU General Public License version 2 only, as
  6  * published by the Free Software Foundation.
  7  *
  8  * This code is distributed in the hope that it will be useful, but WITHOUT
  9  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 10  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 11  * version 2 for more details (a copy is included in the LICENSE file that
 12  * accompanied this code).
 13  *
 14  * You should have received a copy of the GNU General Public License version
 15  * 2 along with this work; if not, write to the Free Software Foundation,
 16  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 17  *
 18  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 19  * or visit www.oracle.com if you need additional information or have any
 20  * questions.
 21  */
 22 
 23 /*
 24  * This file is available under and governed by the GNU General Public
 25  * License version 2 only, as published by the Free Software Foundation.
 26  * However, the following notice accompanied the original version of this
 27  * file:
 28  *
 29  * Written by Doug Lea and Martin Buchholz with assistance from
 30  * members of JCP JSR-166 Expert Group and released to the public
 31  * domain, as explained at
 32  * http://creativecommons.org/publicdomain/zero/1.0/
 33  */
 34 
 35 import static java.util.concurrent.TimeUnit.HOURS;
 36 import static java.util.concurrent.TimeUnit.MILLISECONDS;
 37 
 38 import java.util.ArrayDeque;
 39 import java.util.ArrayList;
 40 import java.util.Arrays;
 41 import java.util.Collection;
 42 import java.util.Collections;
 43 import java.util.ConcurrentModificationException;
 44 import java.util.Deque;
 45 import java.util.HashSet;
 46 import java.util.Iterator;
 47 import java.util.List;
 48 import java.util.NoSuchElementException;
 49 import java.util.Queue;
 50 import java.util.Set;
 51 import java.util.Spliterator;
 52 import java.util.concurrent.BlockingDeque;
 53 import java.util.concurrent.BlockingQueue;
 54 import java.util.concurrent.ConcurrentLinkedQueue;
 55 import java.util.concurrent.CountDownLatch;
 56 import java.util.concurrent.Executors;
 57 import java.util.concurrent.ExecutorService;
 58 import java.util.concurrent.Future;
 59 import java.util.concurrent.Phaser;
 60 import java.util.concurrent.ThreadLocalRandom;
 61 import java.util.concurrent.atomic.AtomicBoolean;
 62 import java.util.concurrent.atomic.AtomicLong;
 63 import java.util.concurrent.atomic.AtomicReference;
 64 import java.util.function.Consumer;
 65 import java.util.function.Predicate;
 66 import java.util.stream.Collectors;
 67 
 68 import junit.framework.Test;
 69 
 70 /**
 71  * Contains tests applicable to all jdk8+ Collection implementations.
 72  * An extension of CollectionTest.
 73  */
 74 public class Collection8Test extends JSR166TestCase {
 75     final CollectionImplementation impl;
 76 
 77     /** Tests are parameterized by a Collection implementation. */
 78     Collection8Test(CollectionImplementation impl, String methodName) {
 79         super(methodName);
 80         this.impl = impl;
 81     }
 82 
 83     public static Test testSuite(CollectionImplementation impl) {
 84         return parameterizedTestSuite(Collection8Test.class,
 85                                       CollectionImplementation.class,
 86                                       impl);
 87     }
 88 
 89     Object bomb() {
 90         return new Object() {
 91             @Override public boolean equals(Object x) { throw new AssertionError(); }
 92             @Override public int hashCode() { throw new AssertionError(); }
 93             @Override public String toString() { throw new AssertionError(); }
 94         };
 95     }
 96 
 97     /** Checks properties of empty collections. */
 98     public void testEmptyMeansEmpty() throws Throwable {
 99         Collection c = impl.emptyCollection();
100         emptyMeansEmpty(c);
101 
102         if (c instanceof java.io.Serializable) {
103             try {
104                 emptyMeansEmpty(serialClonePossiblyFailing(c));
105             } catch (java.io.NotSerializableException ex) {
106                 // excusable when we have a serializable wrapper around
107                 // a non-serializable collection, as can happen with:
108                 // Vector.subList() =&gt; wrapped AbstractList$RandomAccessSubList
109                 if (testImplementationDetails
110                     &amp;&amp; (! c.getClass().getName().matches(
111                                 &quot;java.util.Collections.*&quot;)))
112                     throw ex;
113             }
114         }
115 
116         Collection clone = cloneableClone(c);
117         if (clone != null)
118             emptyMeansEmpty(clone);
119     }
120 
121     void emptyMeansEmpty(Collection c) throws InterruptedException {
122         assertTrue(c.isEmpty());
123         assertEquals(0, c.size());
124         assertEquals(&quot;[]&quot;, c.toString());
125         if (c instanceof List&lt;?&gt;) {
126             List x = (List) c;
127             assertEquals(1, x.hashCode());
128             assertEquals(x, Collections.emptyList());
129             assertEquals(Collections.emptyList(), x);
130             assertEquals(-1, x.indexOf(impl.makeElement(86)));
131             assertEquals(-1, x.lastIndexOf(impl.makeElement(99)));
132             assertThrows(
133                 IndexOutOfBoundsException.class,
134                 () -&gt; x.get(0),
135                 () -&gt; x.set(0, impl.makeElement(42)));
136         }
137         else if (c instanceof Set&lt;?&gt;) {
138             assertEquals(0, c.hashCode());
139             assertEquals(c, Collections.emptySet());
140             assertEquals(Collections.emptySet(), c);
141         }
142         {
143             Object[] a = c.toArray();
144             assertEquals(0, a.length);
145             assertSame(Object[].class, a.getClass());
146         }
147         {
148             Object[] a = new Object[0];
149             assertSame(a, c.toArray(a));
150         }
151         {
152             Integer[] a = new Integer[0];
153             assertSame(a, c.toArray(a));
154         }
155         {
156             Integer[] a = { 1, 2, 3};
157             assertSame(a, c.toArray(a));
158             assertNull(a[0]);
159             assertSame(2, a[1]);
160             assertSame(3, a[2]);
161         }
162         assertIteratorExhausted(c.iterator());
163         Consumer alwaysThrows = e -&gt; { throw new AssertionError(); };
164         c.forEach(alwaysThrows);
165         c.iterator().forEachRemaining(alwaysThrows);
166         c.spliterator().forEachRemaining(alwaysThrows);
167         assertFalse(c.spliterator().tryAdvance(alwaysThrows));
168         if (c.spliterator().hasCharacteristics(Spliterator.SIZED))
169             assertEquals(0, c.spliterator().estimateSize());
170         assertFalse(c.contains(bomb()));
171         assertFalse(c.remove(bomb()));
172         if (c instanceof Queue) {
173             Queue q = (Queue) c;
174             assertNull(q.peek());
175             assertNull(q.poll());
176         }
177         if (c instanceof Deque) {
178             Deque d = (Deque) c;
179             assertNull(d.peekFirst());
180             assertNull(d.peekLast());
181             assertNull(d.pollFirst());
182             assertNull(d.pollLast());
183             assertIteratorExhausted(d.descendingIterator());
184             d.descendingIterator().forEachRemaining(alwaysThrows);
185             assertFalse(d.removeFirstOccurrence(bomb()));
186             assertFalse(d.removeLastOccurrence(bomb()));
187         }
188         if (c instanceof BlockingQueue) {
189             BlockingQueue q = (BlockingQueue) c;
190             assertNull(q.poll(randomExpiredTimeout(), randomTimeUnit()));
191         }
192         if (c instanceof BlockingDeque) {
193             BlockingDeque q = (BlockingDeque) c;
194             assertNull(q.pollFirst(randomExpiredTimeout(), randomTimeUnit()));
195             assertNull(q.pollLast(randomExpiredTimeout(), randomTimeUnit()));
196         }
197     }
198 
199     public void testNullPointerExceptions() throws InterruptedException {
200         Collection c = impl.emptyCollection();
201         assertThrows(
202             NullPointerException.class,
203             () -&gt; c.addAll(null),
204             () -&gt; c.containsAll(null),
205             () -&gt; c.retainAll(null),
206             () -&gt; c.removeAll(null),
207             () -&gt; c.removeIf(null),
208             () -&gt; c.forEach(null),
209             () -&gt; c.iterator().forEachRemaining(null),
210             () -&gt; c.spliterator().forEachRemaining(null),
211             () -&gt; c.spliterator().tryAdvance(null),
212             () -&gt; c.toArray((Object[])null));
213 
214         if (!impl.permitsNulls()) {
215             assertThrows(
216                 NullPointerException.class,
217                 () -&gt; c.add(null));
218         }
219         if (!impl.permitsNulls() &amp;&amp; c instanceof Queue) {
220             Queue q = (Queue) c;
221             assertThrows(
222                 NullPointerException.class,
223                 () -&gt; q.offer(null));
224         }
225         if (!impl.permitsNulls() &amp;&amp; c instanceof Deque) {
226             Deque d = (Deque) c;
227             assertThrows(
228                 NullPointerException.class,
229                 () -&gt; d.addFirst(null),
230                 () -&gt; d.addLast(null),
231                 () -&gt; d.offerFirst(null),
232                 () -&gt; d.offerLast(null),
233                 () -&gt; d.push(null),
234                 () -&gt; d.descendingIterator().forEachRemaining(null));
235         }
236         if (c instanceof BlockingQueue) {
237             BlockingQueue q = (BlockingQueue) c;
238             assertThrows(
239                 NullPointerException.class,
<a name="1" id="anc1"></a><span class="line-modified">240                 () -&gt; q.offer(null, 1L, HOURS),</span>
<span class="line-modified">241                 () -&gt; q.put(null));</span>








242         }
243         if (c instanceof BlockingDeque) {
244             BlockingDeque q = (BlockingDeque) c;
245             assertThrows(
246                 NullPointerException.class,
<a name="2" id="anc2"></a><span class="line-modified">247                 () -&gt; q.offerFirst(null, 1L, HOURS),</span>
<span class="line-modified">248                 () -&gt; q.offerLast(null, 1L, HOURS),</span>
<span class="line-modified">249                 () -&gt; q.putFirst(null),</span>
<span class="line-modified">250                 () -&gt; q.putLast(null));</span>
















251         }
252     }
253 
254     public void testNoSuchElementExceptions() {
255         Collection c = impl.emptyCollection();
256         assertThrows(
257             NoSuchElementException.class,
258             () -&gt; c.iterator().next());
259 
260         if (c instanceof Queue) {
261             Queue q = (Queue) c;
262             assertThrows(
263                 NoSuchElementException.class,
264                 () -&gt; q.element(),
265                 () -&gt; q.remove());
266         }
267         if (c instanceof Deque) {
268             Deque d = (Deque) c;
269             assertThrows(
270                 NoSuchElementException.class,
271                 () -&gt; d.getFirst(),
272                 () -&gt; d.getLast(),
273                 () -&gt; d.removeFirst(),
274                 () -&gt; d.removeLast(),
275                 () -&gt; d.pop(),
276                 () -&gt; d.descendingIterator().next());
277         }
278         if (c instanceof List) {
279             List x = (List) c;
280             assertThrows(
281                 NoSuchElementException.class,
282                 () -&gt; x.iterator().next(),
283                 () -&gt; x.listIterator().next(),
284                 () -&gt; x.listIterator(0).next(),
285                 () -&gt; x.listIterator().previous(),
286                 () -&gt; x.listIterator(0).previous());
287         }
288     }
289 
290     public void testRemoveIf() {
291         Collection c = impl.emptyCollection();
292         boolean ordered =
293             c.spliterator().hasCharacteristics(Spliterator.ORDERED);
294         ThreadLocalRandom rnd = ThreadLocalRandom.current();
295         int n = rnd.nextInt(6);
296         for (int i = 0; i &lt; n; i++) c.add(impl.makeElement(i));
297         AtomicReference threwAt = new AtomicReference(null);
298         List orig = rnd.nextBoolean()
299             ? new ArrayList(c)
300             : Arrays.asList(c.toArray());
301 
302         // Merely creating an iterator can change ArrayBlockingQueue behavior
303         Iterator it = rnd.nextBoolean() ? c.iterator() : null;
304 
305         ArrayList survivors = new ArrayList();
306         ArrayList accepts = new ArrayList();
307         ArrayList rejects = new ArrayList();
308 
309         Predicate randomPredicate = e -&gt; {
310             assertNull(threwAt.get());
311             switch (rnd.nextInt(3)) {
312             case 0: accepts.add(e); return true;
313             case 1: rejects.add(e); return false;
314             case 2: threwAt.set(e); throw new ArithmeticException();
315             default: throw new AssertionError();
316             }
317         };
318         try {
319             try {
320                 boolean modified = c.removeIf(randomPredicate);
321                 assertNull(threwAt.get());
322                 assertEquals(modified, accepts.size() &gt; 0);
323                 assertEquals(modified, rejects.size() != n);
324                 assertEquals(accepts.size() + rejects.size(), n);
325                 if (ordered) {
326                     assertEquals(rejects,
327                                  Arrays.asList(c.toArray()));
328                 } else {
329                     assertEquals(new HashSet(rejects),
330                                  new HashSet(Arrays.asList(c.toArray())));
331                 }
332             } catch (ArithmeticException ok) {
333                 assertNotNull(threwAt.get());
334                 assertTrue(c.contains(threwAt.get()));
335             }
336             if (it != null &amp;&amp; impl.isConcurrent())
337                 // check for weakly consistent iterator
338                 while (it.hasNext()) assertTrue(orig.contains(it.next()));
339             switch (rnd.nextInt(4)) {
340             case 0: survivors.addAll(c); break;
341             case 1: survivors.addAll(Arrays.asList(c.toArray())); break;
342             case 2: c.forEach(survivors::add); break;
343             case 3: for (Object e : c) survivors.add(e); break;
344             }
345             assertTrue(orig.containsAll(accepts));
346             assertTrue(orig.containsAll(rejects));
347             assertTrue(orig.containsAll(survivors));
348             assertTrue(orig.containsAll(c));
349             assertTrue(c.containsAll(rejects));
350             assertTrue(c.containsAll(survivors));
351             assertTrue(survivors.containsAll(rejects));
352             if (threwAt.get() == null) {
353                 assertEquals(n - accepts.size(), c.size());
354                 for (Object x : accepts) assertFalse(c.contains(x));
355             } else {
356                 // Two acceptable behaviors: entire removeIf call is one
357                 // transaction, or each element processed is one transaction.
358                 assertTrue(n == c.size() || n == c.size() + accepts.size());
359                 int k = 0;
360                 for (Object x : accepts) if (c.contains(x)) k++;
361                 assertTrue(k == accepts.size() || k == 0);
362             }
363         } catch (Throwable ex) {
364             System.err.println(impl.klazz());
365             // c is at risk of corruption if we got here, so be lenient
366             try { System.err.printf(&quot;c=%s%n&quot;, c); }
367             catch (Throwable t) { t.printStackTrace(); }
368             System.err.printf(&quot;n=%d%n&quot;, n);
369             System.err.printf(&quot;orig=%s%n&quot;, orig);
370             System.err.printf(&quot;accepts=%s%n&quot;, accepts);
371             System.err.printf(&quot;rejects=%s%n&quot;, rejects);
372             System.err.printf(&quot;survivors=%s%n&quot;, survivors);
373             System.err.printf(&quot;threwAt=%s%n&quot;, threwAt.get());
374             throw ex;
375         }
376     }
377 
378     /**
379      * All elements removed in the middle of CONCURRENT traversal.
380      */
381     public void testElementRemovalDuringTraversal() {
382         Collection c = impl.emptyCollection();
383         ThreadLocalRandom rnd = ThreadLocalRandom.current();
384         int n = rnd.nextInt(6);
385         ArrayList copy = new ArrayList();
386         for (int i = 0; i &lt; n; i++) {
387             Object x = impl.makeElement(i);
388             copy.add(x);
389             c.add(x);
390         }
391         ArrayList iterated = new ArrayList();
392         ArrayList spliterated = new ArrayList();
393         Spliterator s = c.spliterator();
394         Iterator it = c.iterator();
395         for (int i = rnd.nextInt(n + 1); --i &gt;= 0; ) {
396             assertTrue(s.tryAdvance(spliterated::add));
397             if (rnd.nextBoolean()) assertTrue(it.hasNext());
398             iterated.add(it.next());
399         }
400         Consumer alwaysThrows = e -&gt; { throw new AssertionError(); };
401         if (s.hasCharacteristics(Spliterator.CONCURRENT)) {
402             c.clear();          // TODO: many more removal methods
403             if (testImplementationDetails
404                 &amp;&amp; !(c instanceof java.util.concurrent.ArrayBlockingQueue)) {
405                 if (rnd.nextBoolean())
406                     assertFalse(s.tryAdvance(alwaysThrows));
407                 else
408                     s.forEachRemaining(alwaysThrows);
409             }
410             if (it.hasNext()) iterated.add(it.next());
411             if (rnd.nextBoolean()) assertIteratorExhausted(it);
412         }
413         assertTrue(copy.containsAll(iterated));
414         assertTrue(copy.containsAll(spliterated));
415     }
416 
417     /**
418      * Some elements randomly disappear in the middle of traversal.
419      */
420     public void testRandomElementRemovalDuringTraversal() {
421         Collection c = impl.emptyCollection();
422         ThreadLocalRandom rnd = ThreadLocalRandom.current();
423         int n = rnd.nextInt(6);
424         ArrayList copy = new ArrayList();
425         for (int i = 0; i &lt; n; i++) {
426             Object x = impl.makeElement(i);
427             copy.add(x);
428             c.add(x);
429         }
430         ArrayList iterated = new ArrayList();
431         ArrayList spliterated = new ArrayList();
432         ArrayList removed = new ArrayList();
433         Spliterator s = c.spliterator();
434         Iterator it = c.iterator();
435         if (! (s.hasCharacteristics(Spliterator.CONCURRENT) ||
436                s.hasCharacteristics(Spliterator.IMMUTABLE)))
437             return;
438         for (int i = rnd.nextInt(n + 1); --i &gt;= 0; ) {
439             assertTrue(s.tryAdvance(e -&gt; {}));
440             if (rnd.nextBoolean()) assertTrue(it.hasNext());
441             it.next();
442         }
443         Consumer alwaysThrows = e -&gt; { throw new AssertionError(); };
444         // TODO: many more removal methods
445         if (rnd.nextBoolean()) {
446             for (Iterator z = c.iterator(); z.hasNext(); ) {
447                 Object e = z.next();
448                 if (rnd.nextBoolean()) {
449                     try {
450                         z.remove();
451                     } catch (UnsupportedOperationException ok) { return; }
452                     removed.add(e);
453                 }
454             }
455         } else {
456             Predicate randomlyRemove = e -&gt; {
457                 if (rnd.nextBoolean()) { removed.add(e); return true; }
458                 else return false;
459             };
460             c.removeIf(randomlyRemove);
461         }
462         s.forEachRemaining(spliterated::add);
463         while (it.hasNext())
464             iterated.add(it.next());
465         assertTrue(copy.containsAll(iterated));
466         assertTrue(copy.containsAll(spliterated));
467         assertTrue(copy.containsAll(removed));
468         if (s.hasCharacteristics(Spliterator.CONCURRENT)) {
469             ArrayList iteratedAndRemoved = new ArrayList(iterated);
470             ArrayList spliteratedAndRemoved = new ArrayList(spliterated);
471             iteratedAndRemoved.retainAll(removed);
472             spliteratedAndRemoved.retainAll(removed);
473             assertTrue(iteratedAndRemoved.size() &lt;= 1);
474             assertTrue(spliteratedAndRemoved.size() &lt;= 1);
475             if (testImplementationDetails
476                 &amp;&amp; !(c instanceof java.util.concurrent.ArrayBlockingQueue))
477                 assertTrue(spliteratedAndRemoved.isEmpty());
478         }
479     }
480 
481     /**
482      * Various ways of traversing a collection yield same elements
483      */
484     public void testTraversalEquivalence() {
485         Collection c = impl.emptyCollection();
486         ThreadLocalRandom rnd = ThreadLocalRandom.current();
487         int n = rnd.nextInt(6);
488         for (int i = 0; i &lt; n; i++) c.add(impl.makeElement(i));
489         ArrayList iterated = new ArrayList();
490         ArrayList iteratedForEachRemaining = new ArrayList();
491         ArrayList tryAdvanced = new ArrayList();
492         ArrayList spliterated = new ArrayList();
493         ArrayList splitonced = new ArrayList();
494         ArrayList forEached = new ArrayList();
495         ArrayList streamForEached = new ArrayList();
496         ConcurrentLinkedQueue parallelStreamForEached = new ConcurrentLinkedQueue();
497         ArrayList removeIfed = new ArrayList();
498         for (Object x : c) iterated.add(x);
499         c.iterator().forEachRemaining(iteratedForEachRemaining::add);
500         for (Spliterator s = c.spliterator();
501              s.tryAdvance(tryAdvanced::add); ) {}
502         c.spliterator().forEachRemaining(spliterated::add);
503         {                       // trySplit returns &quot;strict prefix&quot;
504             Spliterator s1 = c.spliterator(), s2 = s1.trySplit();
505             if (s2 != null) s2.forEachRemaining(splitonced::add);
506             s1.forEachRemaining(splitonced::add);
507         }
508         c.forEach(forEached::add);
509         c.stream().forEach(streamForEached::add);
510         c.parallelStream().forEach(parallelStreamForEached::add);
511         c.removeIf(e -&gt; { removeIfed.add(e); return false; });
512         boolean ordered =
513             c.spliterator().hasCharacteristics(Spliterator.ORDERED);
514         if (c instanceof List || c instanceof Deque)
515             assertTrue(ordered);
516         HashSet cset = new HashSet(c);
517         assertEquals(cset, new HashSet(parallelStreamForEached));
518         if (ordered) {
519             assertEquals(iterated, iteratedForEachRemaining);
520             assertEquals(iterated, tryAdvanced);
521             assertEquals(iterated, spliterated);
522             assertEquals(iterated, splitonced);
523             assertEquals(iterated, forEached);
524             assertEquals(iterated, streamForEached);
525             assertEquals(iterated, removeIfed);
526         } else {
527             assertEquals(cset, new HashSet(iterated));
528             assertEquals(cset, new HashSet(iteratedForEachRemaining));
529             assertEquals(cset, new HashSet(tryAdvanced));
530             assertEquals(cset, new HashSet(spliterated));
531             assertEquals(cset, new HashSet(splitonced));
532             assertEquals(cset, new HashSet(forEached));
533             assertEquals(cset, new HashSet(streamForEached));
534             assertEquals(cset, new HashSet(removeIfed));
535         }
536         if (c instanceof Deque) {
537             Deque d = (Deque) c;
538             ArrayList descending = new ArrayList();
539             ArrayList descendingForEachRemaining = new ArrayList();
540             for (Iterator it = d.descendingIterator(); it.hasNext(); )
541                 descending.add(it.next());
542             d.descendingIterator().forEachRemaining(
543                 e -&gt; descendingForEachRemaining.add(e));
544             Collections.reverse(descending);
545             Collections.reverse(descendingForEachRemaining);
546             assertEquals(iterated, descending);
547             assertEquals(iterated, descendingForEachRemaining);
548         }
549     }
550 
551     /**
552      * Iterator.forEachRemaining has same behavior as Iterator&#39;s
553      * default implementation.
554      */
555     public void testForEachRemainingConsistentWithDefaultImplementation() {
556         Collection c = impl.emptyCollection();
557         if (!testImplementationDetails
558             || c.getClass() == java.util.LinkedList.class)
559             return;
560         ThreadLocalRandom rnd = ThreadLocalRandom.current();
561         int n = 1 + rnd.nextInt(3);
562         for (int i = 0; i &lt; n; i++) c.add(impl.makeElement(i));
563         ArrayList iterated = new ArrayList();
564         ArrayList iteratedForEachRemaining = new ArrayList();
565         Iterator it1 = c.iterator();
566         Iterator it2 = c.iterator();
567         assertTrue(it1.hasNext());
568         assertTrue(it2.hasNext());
569         c.clear();
570         Object r1, r2;
571         try {
572             while (it1.hasNext()) iterated.add(it1.next());
573             r1 = iterated;
574         } catch (ConcurrentModificationException ex) {
575             r1 = ConcurrentModificationException.class;
576             assertFalse(impl.isConcurrent());
577         }
578         try {
579             it2.forEachRemaining(iteratedForEachRemaining::add);
580             r2 = iteratedForEachRemaining;
581         } catch (ConcurrentModificationException ex) {
582             r2 = ConcurrentModificationException.class;
583             assertFalse(impl.isConcurrent());
584         }
585         assertEquals(r1, r2);
586     }
587 
588     /**
589      * Calling Iterator#remove() after Iterator#forEachRemaining
590      * should (maybe) remove last element
591      */
592     public void testRemoveAfterForEachRemaining() {
593         Collection c = impl.emptyCollection();
594         ThreadLocalRandom rnd = ThreadLocalRandom.current();
595         ArrayList copy = new ArrayList();
596         boolean ordered = c.spliterator().hasCharacteristics(Spliterator.ORDERED);
597         testCollection: {
598             int n = 3 + rnd.nextInt(2);
599             for (int i = 0; i &lt; n; i++) {
600                 Object x = impl.makeElement(i);
601                 c.add(x);
602                 copy.add(x);
603             }
604             Iterator it = c.iterator();
605             if (ordered) {
606                 if (rnd.nextBoolean()) assertTrue(it.hasNext());
607                 assertEquals(impl.makeElement(0), it.next());
608                 if (rnd.nextBoolean()) assertTrue(it.hasNext());
609                 assertEquals(impl.makeElement(1), it.next());
610             } else {
611                 if (rnd.nextBoolean()) assertTrue(it.hasNext());
612                 assertTrue(copy.contains(it.next()));
613                 if (rnd.nextBoolean()) assertTrue(it.hasNext());
614                 assertTrue(copy.contains(it.next()));
615             }
616             if (rnd.nextBoolean()) assertTrue(it.hasNext());
617             it.forEachRemaining(
618                 e -&gt; {
619                     assertTrue(c.contains(e));
620                     assertTrue(copy.contains(e));});
621             if (testImplementationDetails) {
622                 if (c instanceof java.util.concurrent.ArrayBlockingQueue) {
623                     assertIteratorExhausted(it);
624                 } else {
625                     try { it.remove(); }
626                     catch (UnsupportedOperationException ok) {
627                         break testCollection;
628                     }
629                     assertEquals(n - 1, c.size());
630                     if (ordered) {
631                         for (int i = 0; i &lt; n - 1; i++)
632                             assertTrue(c.contains(impl.makeElement(i)));
633                         assertFalse(c.contains(impl.makeElement(n - 1)));
634                     }
635                 }
636             }
637         }
638         if (c instanceof Deque) {
639             Deque d = (Deque) impl.emptyCollection();
640             assertTrue(ordered);
641             int n = 3 + rnd.nextInt(2);
642             for (int i = 0; i &lt; n; i++) d.add(impl.makeElement(i));
643             Iterator it = d.descendingIterator();
644             assertTrue(it.hasNext());
645             assertEquals(impl.makeElement(n - 1), it.next());
646             assertTrue(it.hasNext());
647             assertEquals(impl.makeElement(n - 2), it.next());
648             it.forEachRemaining(e -&gt; assertTrue(c.contains(e)));
649             if (testImplementationDetails) {
650                 it.remove();
651                 assertEquals(n - 1, d.size());
652                 for (int i = 1; i &lt; n; i++)
653                     assertTrue(d.contains(impl.makeElement(i)));
654                 assertFalse(d.contains(impl.makeElement(0)));
655             }
656         }
657     }
658 
659     /**
660      * stream().forEach returns elements in the collection
661      */
662     public void testStreamForEach() throws Throwable {
663         final Collection c = impl.emptyCollection();
664         final AtomicLong count = new AtomicLong(0L);
665         final Object x = impl.makeElement(1);
666         final Object y = impl.makeElement(2);
667         final ArrayList found = new ArrayList();
668         Consumer&lt;Object&gt; spy = o -&gt; found.add(o);
669         c.stream().forEach(spy);
670         assertTrue(found.isEmpty());
671 
672         assertTrue(c.add(x));
673         c.stream().forEach(spy);
674         assertEquals(Collections.singletonList(x), found);
675         found.clear();
676 
677         assertTrue(c.add(y));
678         c.stream().forEach(spy);
679         assertEquals(2, found.size());
680         assertTrue(found.contains(x));
681         assertTrue(found.contains(y));
682         found.clear();
683 
684         c.clear();
685         c.stream().forEach(spy);
686         assertTrue(found.isEmpty());
687     }
688 
689     public void testStreamForEachConcurrentStressTest() throws Throwable {
690         if (!impl.isConcurrent()) return;
691         final Collection c = impl.emptyCollection();
692         final long testDurationMillis = timeoutMillis();
693         final AtomicBoolean done = new AtomicBoolean(false);
694         final Object elt = impl.makeElement(1);
695         final Future&lt;?&gt; f1, f2;
696         final ExecutorService pool = Executors.newCachedThreadPool();
697         try (PoolCleaner cleaner = cleaner(pool, done)) {
698             final CountDownLatch threadsStarted = new CountDownLatch(2);
699             Runnable checkElt = () -&gt; {
700                 threadsStarted.countDown();
701                 while (!done.get())
702                     c.stream().forEach(x -&gt; assertSame(x, elt)); };
703             Runnable addRemove = () -&gt; {
704                 threadsStarted.countDown();
705                 while (!done.get()) {
706                     assertTrue(c.add(elt));
707                     assertTrue(c.remove(elt));
708                 }};
709             f1 = pool.submit(checkElt);
710             f2 = pool.submit(addRemove);
711             Thread.sleep(testDurationMillis);
712         }
713         assertNull(f1.get(0L, MILLISECONDS));
714         assertNull(f2.get(0L, MILLISECONDS));
715     }
716 
717     /**
718      * collection.forEach returns elements in the collection
719      */
720     public void testForEach() throws Throwable {
721         final Collection c = impl.emptyCollection();
722         final AtomicLong count = new AtomicLong(0L);
723         final Object x = impl.makeElement(1);
724         final Object y = impl.makeElement(2);
725         final ArrayList found = new ArrayList();
726         Consumer&lt;Object&gt; spy = o -&gt; found.add(o);
727         c.forEach(spy);
728         assertTrue(found.isEmpty());
729 
730         assertTrue(c.add(x));
731         c.forEach(spy);
732         assertEquals(Collections.singletonList(x), found);
733         found.clear();
734 
735         assertTrue(c.add(y));
736         c.forEach(spy);
737         assertEquals(2, found.size());
738         assertTrue(found.contains(x));
739         assertTrue(found.contains(y));
740         found.clear();
741 
742         c.clear();
743         c.forEach(spy);
744         assertTrue(found.isEmpty());
745     }
746 
747     /** TODO: promote to a common utility */
748     static &lt;T&gt; T chooseOne(T ... ts) {
749         return ts[ThreadLocalRandom.current().nextInt(ts.length)];
750     }
751 
752     /** TODO: more random adders and removers */
753     static &lt;E&gt; Runnable adderRemover(Collection&lt;E&gt; c, E e) {
754         return chooseOne(
755             () -&gt; {
756                 assertTrue(c.add(e));
757                 assertTrue(c.contains(e));
758                 assertTrue(c.remove(e));
759                 assertFalse(c.contains(e));
760             },
761             () -&gt; {
762                 assertTrue(c.add(e));
763                 assertTrue(c.contains(e));
764                 assertTrue(c.removeIf(x -&gt; x == e));
765                 assertFalse(c.contains(e));
766             },
767             () -&gt; {
768                 assertTrue(c.add(e));
769                 assertTrue(c.contains(e));
770                 for (Iterator it = c.iterator();; )
771                     if (it.next() == e) {
772                         try { it.remove(); }
773                         catch (UnsupportedOperationException ok) {
774                             c.remove(e);
775                         }
776                         break;
777                     }
778                 assertFalse(c.contains(e));
779             });
780     }
781 
782     /**
783      * Concurrent Spliterators, once exhausted, stay exhausted.
784      */
785     public void testStickySpliteratorExhaustion() throws Throwable {
786         if (!impl.isConcurrent()) return;
787         if (!testImplementationDetails) return;
788         final ThreadLocalRandom rnd = ThreadLocalRandom.current();
789         final Consumer alwaysThrows = e -&gt; { throw new AssertionError(); };
790         final Collection c = impl.emptyCollection();
791         final Spliterator s = c.spliterator();
792         if (rnd.nextBoolean()) {
793             assertFalse(s.tryAdvance(alwaysThrows));
794         } else {
795             s.forEachRemaining(alwaysThrows);
796         }
797         final Object one = impl.makeElement(1);
798         // Spliterator should not notice added element
799         c.add(one);
800         if (rnd.nextBoolean()) {
801             assertFalse(s.tryAdvance(alwaysThrows));
802         } else {
803             s.forEachRemaining(alwaysThrows);
804         }
805     }
806 
807     /**
808      * Motley crew of threads concurrently randomly hammer the collection.
809      */
810     public void testDetectRaces() throws Throwable {
811         if (!impl.isConcurrent()) return;
812         final ThreadLocalRandom rnd = ThreadLocalRandom.current();
813         final Collection c = impl.emptyCollection();
814         final long testDurationMillis
815             = expensiveTests ? LONG_DELAY_MS : timeoutMillis();
816         final AtomicBoolean done = new AtomicBoolean(false);
817         final Object one = impl.makeElement(1);
818         final Object two = impl.makeElement(2);
819         final Consumer checkSanity = x -&gt; assertTrue(x == one || x == two);
820         final Consumer&lt;Object[]&gt; checkArraySanity = array -&gt; {
821             // assertTrue(array.length &lt;= 2); // duplicates are permitted
822             for (Object x : array) assertTrue(x == one || x == two);
823         };
824         final Object[] emptyArray =
825             (Object[]) java.lang.reflect.Array.newInstance(one.getClass(), 0);
826         final List&lt;Future&lt;?&gt;&gt; futures;
827         final Phaser threadsStarted = new Phaser(1); // register this thread
828         final Runnable[] frobbers = {
829             () -&gt; c.forEach(checkSanity),
830             () -&gt; c.stream().forEach(checkSanity),
831             () -&gt; c.parallelStream().forEach(checkSanity),
832             () -&gt; c.spliterator().trySplit(),
833             () -&gt; {
834                 Spliterator s = c.spliterator();
835                 s.tryAdvance(checkSanity);
836                 s.trySplit();
837             },
838             () -&gt; {
839                 Spliterator s = c.spliterator();
840                 do {} while (s.tryAdvance(checkSanity));
841             },
842             () -&gt; { for (Object x : c) checkSanity.accept(x); },
843             () -&gt; checkArraySanity.accept(c.toArray()),
844             () -&gt; checkArraySanity.accept(c.toArray(emptyArray)),
845             () -&gt; {
846                 Object[] a = new Object[5];
847                 Object three = impl.makeElement(3);
848                 Arrays.fill(a, 0, a.length, three);
849                 Object[] x = c.toArray(a);
850                 if (x == a)
851                     for (int i = 0; i &lt; a.length &amp;&amp; a[i] != null; i++)
852                         checkSanity.accept(a[i]);
853                     // A careful reading of the spec does not support:
854                     // for (i++; i &lt; a.length; i++) assertSame(three, a[i]);
855                 else
856                     checkArraySanity.accept(x);
857                 },
858             adderRemover(c, one),
859             adderRemover(c, two),
860         };
861         final List&lt;Runnable&gt; tasks =
862             Arrays.stream(frobbers)
863             .filter(task -&gt; rnd.nextBoolean()) // random subset
864             .map(task -&gt; (Runnable) () -&gt; {
865                      threadsStarted.arriveAndAwaitAdvance();
866                      while (!done.get())
867                          task.run();
868                  })
869             .collect(Collectors.toList());
870         final ExecutorService pool = Executors.newCachedThreadPool();
871         try (PoolCleaner cleaner = cleaner(pool, done)) {
872             threadsStarted.bulkRegister(tasks.size());
873             futures = tasks.stream()
874                 .map(pool::submit)
875                 .collect(Collectors.toList());
876             threadsStarted.arriveAndDeregister();
877             Thread.sleep(testDurationMillis);
878         }
879         for (Future future : futures)
880             assertNull(future.get(0L, MILLISECONDS));
881     }
882 
883     /**
884      * Spliterators are either IMMUTABLE or truly late-binding or, if
885      * concurrent, use the same &quot;late-binding style&quot; of returning
886      * elements added between creation and first use.
887      */
888     public void testLateBindingStyle() {
889         if (!testImplementationDetails) return;
890         if (impl.klazz() == ArrayList.class) return; // for jdk8
891         // Immutable (snapshot) spliterators are exempt
892         if (impl.emptyCollection().spliterator()
893             .hasCharacteristics(Spliterator.IMMUTABLE))
894             return;
895         final Object one = impl.makeElement(1);
896         {
897             final Collection c = impl.emptyCollection();
898             final Spliterator split = c.spliterator();
899             c.add(one);
900             assertTrue(split.tryAdvance(e -&gt; { assertSame(e, one); }));
901             assertFalse(split.tryAdvance(e -&gt; { throw new AssertionError(); }));
902             assertTrue(c.contains(one));
903         }
904         {
905             final AtomicLong count = new AtomicLong(0);
906             final Collection c = impl.emptyCollection();
907             final Spliterator split = c.spliterator();
908             c.add(one);
909             split.forEachRemaining(
910                 e -&gt; { assertSame(e, one); count.getAndIncrement(); });
911             assertEquals(1L, count.get());
912             assertFalse(split.tryAdvance(e -&gt; { throw new AssertionError(); }));
913             assertTrue(c.contains(one));
914         }
915     }
916 
917     /**
918      * Spliterator.getComparator throws IllegalStateException iff the
919      * spliterator does not report SORTED.
920      */
921     public void testGetComparator_IllegalStateException() {
922         Collection c = impl.emptyCollection();
923         Spliterator s = c.spliterator();
924         boolean reportsSorted = s.hasCharacteristics(Spliterator.SORTED);
925         try {
926             s.getComparator();
927             assertTrue(reportsSorted);
928         } catch (IllegalStateException ex) {
929             assertFalse(reportsSorted);
930         }
931     }
932 
933     public void testCollectionCopies() throws Exception {
934         ThreadLocalRandom rnd = ThreadLocalRandom.current();
935         Collection c = impl.emptyCollection();
936         for (int n = rnd.nextInt(4); n--&gt; 0; )
937             c.add(impl.makeElement(rnd.nextInt()));
938         assertEquals(c, c);
939         if (c instanceof List)
940             assertCollectionsEquals(c, new ArrayList(c));
941         else if (c instanceof Set)
942             assertCollectionsEquals(c, new HashSet(c));
943         else if (c instanceof Deque)
944             assertCollectionsEquivalent(c, new ArrayDeque(c));
945 
946         Collection clone = cloneableClone(c);
947         if (clone != null) {
948             assertSame(c.getClass(), clone.getClass());
949             assertCollectionsEquivalent(c, clone);
950         }
951         try {
952             Collection serialClone = serialClonePossiblyFailing(c);
953             assertSame(c.getClass(), serialClone.getClass());
954             assertCollectionsEquivalent(c, serialClone);
955         } catch (java.io.NotSerializableException acceptable) {}
956     }
957 
<a name="3" id="anc3"></a><span class="line-added">958     /**</span>
<span class="line-added">959      * TODO: move out of limbo</span>
<span class="line-added">960      * 8203662: remove increment of modCount from ArrayList and Vector replaceAll()</span>
<span class="line-added">961      */</span>
962     public void DISABLED_testReplaceAllIsNotStructuralModification() {
963         Collection c = impl.emptyCollection();
964         if (!(c instanceof List))
965             return;
966         List list = (List) c;
967         ThreadLocalRandom rnd = ThreadLocalRandom.current();
968         for (int n = rnd.nextInt(2, 10); n--&gt; 0; )
969             list.add(impl.makeElement(rnd.nextInt()));
970         ArrayList copy = new ArrayList(list);
971         int size = list.size(), half = size / 2;
972         Iterator it = list.iterator();
973         for (int i = 0; i &lt; half; i++)
974             assertEquals(it.next(), copy.get(i));
975         list.replaceAll(n -&gt; n);
976         // ConcurrentModificationException must not be thrown here.
977         for (int i = half; i &lt; size; i++)
978             assertEquals(it.next(), copy.get(i));
979     }
980 
981 //     public void testCollection8DebugFail() {
982 //         fail(impl.klazz().getSimpleName());
983 //     }
984 }
<a name="4" id="anc4"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="4" type="hidden" />
</body>
</html>
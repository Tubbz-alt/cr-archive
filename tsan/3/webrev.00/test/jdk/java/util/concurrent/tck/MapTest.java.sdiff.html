<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff test/jdk/java/util/concurrent/tck/MapTest.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
<body>
<center><a href="MapImplementation.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="PhaserTest.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>test/jdk/java/util/concurrent/tck/MapTest.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 15  * 2 along with this work; if not, write to the Free Software Foundation,
 16  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 17  *
 18  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 19  * or visit www.oracle.com if you need additional information or have any
 20  * questions.
 21  */
 22 
 23 /*
 24  * This file is available under and governed by the GNU General Public
 25  * License version 2 only, as published by the Free Software Foundation.
 26  * However, the following notice accompanied the original version of this
 27  * file:
 28  *
 29  * Written by Doug Lea and Martin Buchholz with assistance from
 30  * members of JCP JSR-166 Expert Group and released to the public
 31  * domain, as explained at
 32  * http://creativecommons.org/publicdomain/zero/1.0/
 33  */
 34 
<span class="line-removed"> 35 import junit.framework.Test;</span>
<span class="line-removed"> 36 </span>
 37 import java.util.ArrayList;
 38 import java.util.Iterator;
 39 import java.util.List;
 40 import java.util.Map;

 41 import java.util.concurrent.ThreadLocalRandom;





 42 
 43 /**
 44  * Contains tests applicable to all Map implementations.
 45  */
 46 public class MapTest extends JSR166TestCase {
 47     final MapImplementation impl;
 48 
 49     /** Tests are parameterized by a Map implementation. */
 50     MapTest(MapImplementation impl, String methodName) {
 51         super(methodName);
 52         this.impl = impl;
 53     }
 54 
 55     public static Test testSuite(MapImplementation impl) {
 56         return newTestSuite(
 57             parameterizedTestSuite(MapTest.class,
 58                                    MapImplementation.class,
 59                                    impl));
 60     }
 61 
</pre>
<hr />
<pre>
105                 ((Map.Entry)(m.entrySet().iterator().next())).setValue(v2);
106                 assertSame(v2, m.get(k));
107                 assertTrue(m.containsKey(k));
108                 assertTrue(m.containsValue(v2));
109                 assertFalse(m.containsValue(v1));
110             } else {
111                 assertThrows(UnsupportedOperationException.class,
112                              () -&gt; ((Map.Entry)(m.entrySet().iterator().next())).setValue(v2));
113             }
114         }
115     }
116 
117     /**
118      * Tests and extends the scenario reported in
119      * https://bugs.openjdk.java.net/browse/JDK-8186171
120      * HashMap: Entry.setValue may not work after Iterator.remove() called for previous entries
121      * ant -Djsr166.tckTestClass=HashMapTest -Djsr166.methodFilter=testBug8186171 -Djsr166.runsPerTest=1000 tck
122      */
123     public void testBug8186171() {
124         if (!impl.supportsSetValue()) return;

125         final ThreadLocalRandom rnd = ThreadLocalRandom.current();
126         final boolean permitsNullValues = impl.permitsNullValues();
127         final Object v1 = (permitsNullValues &amp;&amp; rnd.nextBoolean())
128             ? null : impl.makeValue(1);
129         final Object v2 = (permitsNullValues &amp;&amp; rnd.nextBoolean() &amp;&amp; v1 != null)
130             ? null : impl.makeValue(2);
131 
132         // If true, always lands in first bucket in hash tables.
133         final boolean poorHash = rnd.nextBoolean();
134         class Key implements Comparable&lt;Key&gt; {
135             final int i;
136             Key(int i) { this.i = i; }
137             public int hashCode() { return poorHash ? 0 : super.hashCode(); }
138             public int compareTo(Key x) {
139                 return Integer.compare(this.i, x.i);
140             }
141         }
142 
143         // Both HashMap and ConcurrentHashMap have:
144         // TREEIFY_THRESHOLD = 8; UNTREEIFY_THRESHOLD = 6;
</pre>
<hr />
<pre>
183 
184         final Map m2 = impl.emptyMap();
185         for (int i = 0; i &lt; size2; i++) {
186             int elt = rnd.nextInt(Integer.MIN_VALUE + 1024 * i,
187                                   Integer.MIN_VALUE + 1024 * (i + 1));
188             assertNull(m2.put(impl.makeKey(elt), impl.makeValue(-elt)));
189         }
190 
191         final Map m1Copy = impl.emptyMap();
192         m1Copy.putAll(m1);
193 
194         m1.putAll(m2);
195 
196         for (Object elt : m2.keySet())
197             assertEquals(m2.get(elt), m1.get(elt));
198         for (Object elt : m1Copy.keySet())
199             assertSame(m1Copy.get(elt), m1.get(elt));
200         assertEquals(size1 + size2, m1.size());
201     }
202 



























































































203 //     public void testFailsIntentionallyForDebugging() {
204 //         fail(impl.klazz().getSimpleName());
205 //     }
206 }
</pre>
</td>
<td>
<hr />
<pre>
 15  * 2 along with this work; if not, write to the Free Software Foundation,
 16  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 17  *
 18  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 19  * or visit www.oracle.com if you need additional information or have any
 20  * questions.
 21  */
 22 
 23 /*
 24  * This file is available under and governed by the GNU General Public
 25  * License version 2 only, as published by the Free Software Foundation.
 26  * However, the following notice accompanied the original version of this
 27  * file:
 28  *
 29  * Written by Doug Lea and Martin Buchholz with assistance from
 30  * members of JCP JSR-166 Expert Group and released to the public
 31  * domain, as explained at
 32  * http://creativecommons.org/publicdomain/zero/1.0/
 33  */
 34 


 35 import java.util.ArrayList;
 36 import java.util.Iterator;
 37 import java.util.List;
 38 import java.util.Map;
<span class="line-added"> 39 import java.util.concurrent.CompletableFuture;</span>
 40 import java.util.concurrent.ThreadLocalRandom;
<span class="line-added"> 41 import java.util.concurrent.atomic.AtomicBoolean;</span>
<span class="line-added"> 42 import java.util.concurrent.atomic.AtomicLong;</span>
<span class="line-added"> 43 import java.util.function.BiFunction;</span>
<span class="line-added"> 44 </span>
<span class="line-added"> 45 import junit.framework.Test;</span>
 46 
 47 /**
 48  * Contains tests applicable to all Map implementations.
 49  */
 50 public class MapTest extends JSR166TestCase {
 51     final MapImplementation impl;
 52 
 53     /** Tests are parameterized by a Map implementation. */
 54     MapTest(MapImplementation impl, String methodName) {
 55         super(methodName);
 56         this.impl = impl;
 57     }
 58 
 59     public static Test testSuite(MapImplementation impl) {
 60         return newTestSuite(
 61             parameterizedTestSuite(MapTest.class,
 62                                    MapImplementation.class,
 63                                    impl));
 64     }
 65 
</pre>
<hr />
<pre>
109                 ((Map.Entry)(m.entrySet().iterator().next())).setValue(v2);
110                 assertSame(v2, m.get(k));
111                 assertTrue(m.containsKey(k));
112                 assertTrue(m.containsValue(v2));
113                 assertFalse(m.containsValue(v1));
114             } else {
115                 assertThrows(UnsupportedOperationException.class,
116                              () -&gt; ((Map.Entry)(m.entrySet().iterator().next())).setValue(v2));
117             }
118         }
119     }
120 
121     /**
122      * Tests and extends the scenario reported in
123      * https://bugs.openjdk.java.net/browse/JDK-8186171
124      * HashMap: Entry.setValue may not work after Iterator.remove() called for previous entries
125      * ant -Djsr166.tckTestClass=HashMapTest -Djsr166.methodFilter=testBug8186171 -Djsr166.runsPerTest=1000 tck
126      */
127     public void testBug8186171() {
128         if (!impl.supportsSetValue()) return;
<span class="line-added">129         if (!atLeastJava10()) return; // jdk9 is no longer maintained</span>
130         final ThreadLocalRandom rnd = ThreadLocalRandom.current();
131         final boolean permitsNullValues = impl.permitsNullValues();
132         final Object v1 = (permitsNullValues &amp;&amp; rnd.nextBoolean())
133             ? null : impl.makeValue(1);
134         final Object v2 = (permitsNullValues &amp;&amp; rnd.nextBoolean() &amp;&amp; v1 != null)
135             ? null : impl.makeValue(2);
136 
137         // If true, always lands in first bucket in hash tables.
138         final boolean poorHash = rnd.nextBoolean();
139         class Key implements Comparable&lt;Key&gt; {
140             final int i;
141             Key(int i) { this.i = i; }
142             public int hashCode() { return poorHash ? 0 : super.hashCode(); }
143             public int compareTo(Key x) {
144                 return Integer.compare(this.i, x.i);
145             }
146         }
147 
148         // Both HashMap and ConcurrentHashMap have:
149         // TREEIFY_THRESHOLD = 8; UNTREEIFY_THRESHOLD = 6;
</pre>
<hr />
<pre>
188 
189         final Map m2 = impl.emptyMap();
190         for (int i = 0; i &lt; size2; i++) {
191             int elt = rnd.nextInt(Integer.MIN_VALUE + 1024 * i,
192                                   Integer.MIN_VALUE + 1024 * (i + 1));
193             assertNull(m2.put(impl.makeKey(elt), impl.makeValue(-elt)));
194         }
195 
196         final Map m1Copy = impl.emptyMap();
197         m1Copy.putAll(m1);
198 
199         m1.putAll(m2);
200 
201         for (Object elt : m2.keySet())
202             assertEquals(m2.get(elt), m1.get(elt));
203         for (Object elt : m1Copy.keySet())
204             assertSame(m1Copy.get(elt), m1.get(elt));
205         assertEquals(size1 + size2, m1.size());
206     }
207 
<span class="line-added">208     /**</span>
<span class="line-added">209      * 8222930: ConcurrentSkipListMap.clone() shares size variable between original and clone</span>
<span class="line-added">210      */</span>
<span class="line-added">211     public void testClone() {</span>
<span class="line-added">212         final ThreadLocalRandom rnd = ThreadLocalRandom.current();</span>
<span class="line-added">213         final int size = rnd.nextInt(4);</span>
<span class="line-added">214         final Map map = impl.emptyMap();</span>
<span class="line-added">215         for (int i = 0; i &lt; size; i++)</span>
<span class="line-added">216             map.put(impl.makeKey(i), impl.makeValue(i));</span>
<span class="line-added">217         final Map clone = cloneableClone(map);</span>
<span class="line-added">218         if (clone == null) return;      // not cloneable?</span>
<span class="line-added">219 </span>
<span class="line-added">220         assertEquals(size, map.size());</span>
<span class="line-added">221         assertEquals(size, clone.size());</span>
<span class="line-added">222         assertEquals(map.isEmpty(), clone.isEmpty());</span>
<span class="line-added">223 </span>
<span class="line-added">224         clone.put(impl.makeKey(-1), impl.makeValue(-1));</span>
<span class="line-added">225         assertEquals(size, map.size());</span>
<span class="line-added">226         assertEquals(size + 1, clone.size());</span>
<span class="line-added">227 </span>
<span class="line-added">228         clone.clear();</span>
<span class="line-added">229         assertEquals(size, map.size());</span>
<span class="line-added">230         assertEquals(0, clone.size());</span>
<span class="line-added">231         assertTrue(clone.isEmpty());</span>
<span class="line-added">232     }</span>
<span class="line-added">233 </span>
<span class="line-added">234     /**</span>
<span class="line-added">235      * Concurrent access by compute methods behaves as expected</span>
<span class="line-added">236      */</span>
<span class="line-added">237     public void testConcurrentAccess() throws Throwable {</span>
<span class="line-added">238         final Map map = impl.emptyMap();</span>
<span class="line-added">239         final long testDurationMillis = expensiveTests ? 1000 : 2;</span>
<span class="line-added">240         final int nTasks = impl.isConcurrent()</span>
<span class="line-added">241             ? ThreadLocalRandom.current().nextInt(1, 10)</span>
<span class="line-added">242             : 1;</span>
<span class="line-added">243         final AtomicBoolean done = new AtomicBoolean(false);</span>
<span class="line-added">244         final boolean remappingFunctionCalledAtMostOnce</span>
<span class="line-added">245             = impl.remappingFunctionCalledAtMostOnce();</span>
<span class="line-added">246         final List&lt;CompletableFuture&gt; futures = new ArrayList&lt;&gt;();</span>
<span class="line-added">247         final AtomicLong expectedSum = new AtomicLong(0);</span>
<span class="line-added">248         final Action[] tasks = {</span>
<span class="line-added">249             // repeatedly increment values using compute()</span>
<span class="line-added">250             () -&gt; {</span>
<span class="line-added">251                 long[] invocations = new long[2];</span>
<span class="line-added">252                 ThreadLocalRandom rnd = ThreadLocalRandom.current();</span>
<span class="line-added">253                 BiFunction&lt;Object, Object, Object&gt; incValue = (k, v) -&gt; {</span>
<span class="line-added">254                     invocations[1]++;</span>
<span class="line-added">255                     int vi = (v == null) ? 1 : impl.valueToInt(v) + 1;</span>
<span class="line-added">256                     return impl.makeValue(vi);</span>
<span class="line-added">257                 };</span>
<span class="line-added">258                 while (!done.getAcquire()) {</span>
<span class="line-added">259                     invocations[0]++;</span>
<span class="line-added">260                     Object key = impl.makeKey(3 * rnd.nextInt(10));</span>
<span class="line-added">261                     map.compute(key, incValue);</span>
<span class="line-added">262                 }</span>
<span class="line-added">263                 if (remappingFunctionCalledAtMostOnce)</span>
<span class="line-added">264                     assertEquals(invocations[0], invocations[1]);</span>
<span class="line-added">265                 expectedSum.getAndAdd(invocations[0]);</span>
<span class="line-added">266             },</span>
<span class="line-added">267             // repeatedly increment values using computeIfPresent()</span>
<span class="line-added">268             () -&gt; {</span>
<span class="line-added">269                 long[] invocations = new long[2];</span>
<span class="line-added">270                 ThreadLocalRandom rnd = ThreadLocalRandom.current();</span>
<span class="line-added">271                 BiFunction&lt;Object, Object, Object&gt; incValue = (k, v) -&gt; {</span>
<span class="line-added">272                     invocations[1]++;</span>
<span class="line-added">273                     int vi = impl.valueToInt(v) + 1;</span>
<span class="line-added">274                     return impl.makeValue(vi);</span>
<span class="line-added">275                 };</span>
<span class="line-added">276                 while (!done.getAcquire()) {</span>
<span class="line-added">277                     Object key = impl.makeKey(3 * rnd.nextInt(10));</span>
<span class="line-added">278                     if (map.computeIfPresent(key, incValue) != null)</span>
<span class="line-added">279                         invocations[0]++;</span>
<span class="line-added">280                 }</span>
<span class="line-added">281                 if (remappingFunctionCalledAtMostOnce)</span>
<span class="line-added">282                     assertEquals(invocations[0], invocations[1]);</span>
<span class="line-added">283                 expectedSum.getAndAdd(invocations[0]);</span>
<span class="line-added">284             },</span>
<span class="line-added">285         };</span>
<span class="line-added">286         for (int i = nTasks; i--&gt; 0; ) {</span>
<span class="line-added">287             Action task = chooseRandomly(tasks);</span>
<span class="line-added">288             futures.add(CompletableFuture.runAsync(checkedRunnable(task)));</span>
<span class="line-added">289         }</span>
<span class="line-added">290         Thread.sleep(testDurationMillis);</span>
<span class="line-added">291         done.setRelease(true);</span>
<span class="line-added">292         for (var future : futures)</span>
<span class="line-added">293             checkTimedGet(future, null);</span>
<span class="line-added">294 </span>
<span class="line-added">295         long sum = map.values().stream().mapToLong(x -&gt; (int) x).sum();</span>
<span class="line-added">296         assertEquals(expectedSum.get(), sum);</span>
<span class="line-added">297     }</span>
<span class="line-added">298 </span>
299 //     public void testFailsIntentionallyForDebugging() {
300 //         fail(impl.klazz().getSimpleName());
301 //     }
302 }
</pre>
</td>
</tr>
</table>
<center><a href="MapImplementation.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="PhaserTest.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
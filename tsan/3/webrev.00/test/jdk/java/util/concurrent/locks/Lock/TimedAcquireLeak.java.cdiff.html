<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff test/jdk/java/util/concurrent/locks/Lock/TimedAcquireLeak.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
<body>
<center><a href="FlakyMutex.java.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="../ReentrantLock/CancelledLockLoops.java.cdiff.html" target="_top">next &gt;</a></center>    <h2>test/jdk/java/util/concurrent/locks/Lock/TimedAcquireLeak.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 40,10 ***</span>
<span class="line-new-header">--- 40,12 ---</span>
  import java.io.OutputStream;
  import java.io.PrintStream;
  import java.io.Reader;
  import java.lang.ref.ReferenceQueue;
  import java.lang.ref.WeakReference;
<span class="line-added">+ import java.util.ArrayList;</span>
<span class="line-added">+ import java.util.Collections;</span>
  import java.util.concurrent.BlockingQueue;
  import java.util.concurrent.Callable;
  import java.util.concurrent.CountDownLatch;
  import java.util.concurrent.CyclicBarrier;
  import java.util.concurrent.ExecutorService;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 70,13 ***</span>
  
      static String javaProgramPath(String programName) {
          return new File(bin, programName).getPath();
      }
  
<span class="line-modified">!     static final String java = javaProgramPath(&quot;java&quot;);</span>
<span class="line-modified">!     static final String jmap = javaProgramPath(&quot;jmap&quot;);</span>
<span class="line-modified">!     static final String jps  = javaProgramPath(&quot;jps&quot;);</span>
  
      static String outputOf(Reader r) throws IOException {
          final StringBuilder sb = new StringBuilder();
          final char[] buf = new char[1024];
          int n;
<span class="line-new-header">--- 72,13 ---</span>
  
      static String javaProgramPath(String programName) {
          return new File(bin, programName).getPath();
      }
  
<span class="line-modified">!     static final String javaPath = javaProgramPath(&quot;java&quot;);</span>
<span class="line-modified">!     static final String jmapPath = javaProgramPath(&quot;jmap&quot;);</span>
<span class="line-modified">!     static final String jpsPath  = javaProgramPath(&quot;jps&quot;);</span>
  
      static String outputOf(Reader r) throws IOException {
          final StringBuilder sb = new StringBuilder();
          final char[] buf = new char[1024];
          int n;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 157,11 ***</span>
          } catch (Throwable t) { throw new Error(t); }
      }
  
      static String match(String s, String regex, int group) {
          Matcher matcher = Pattern.compile(regex).matcher(s);
<span class="line-modified">!         matcher.find();</span>
          return matcher.group(group);
      }
  
      /** It&#39;s all about sending a message! */
      static void sendByte(OutputStream s) throws IOException {
<span class="line-new-header">--- 159,15 ---</span>
          } catch (Throwable t) { throw new Error(t); }
      }
  
      static String match(String s, String regex, int group) {
          Matcher matcher = Pattern.compile(regex).matcher(s);
<span class="line-modified">!         if (! matcher.find()) {</span>
<span class="line-added">+             String msg = String.format(</span>
<span class="line-added">+                 &quot;match failed: s=%s regex=%s&quot;, s, regex);</span>
<span class="line-added">+             throw new AssertionError(msg);</span>
<span class="line-added">+         }</span>
          return matcher.group(group);
      }
  
      /** It&#39;s all about sending a message! */
      static void sendByte(OutputStream s) throws IOException {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 169,66 ***</span>
          s.flush();
      }
  
      static int objectsInUse(final Process child,
                              final String childPid,
<span class="line-modified">!                             final String className) {</span>
<span class="line-modified">!         final String regex =</span>
<span class="line-modified">!             &quot;(?m)^ *[0-9]+: +([0-9]+) +[0-9]+ +\\Q&quot;+className+&quot;\\E(?:$| )&quot;;</span>
<span class="line-modified">!         final Callable&lt;Integer&gt; objectsInUse =</span>
<span class="line-modified">!             new Callable&lt;Integer&gt;() { public Integer call() {</span>
<span class="line-modified">!                 Integer i = Integer.parseInt(</span>
<span class="line-modified">!                     match(commandOutputOf(jmap, &quot;-histo:live&quot;, childPid),</span>
<span class="line-modified">!                           regex, 1));</span>
<span class="line-modified">!                 if (i &gt; 100)</span>
<span class="line-modified">!                     System.out.print(</span>
<span class="line-modified">!                         commandOutputOf(jmap,</span>
<span class="line-modified">!                                         &quot;-dump:file=dump,format=b&quot;,</span>
<span class="line-modified">!                                         childPid));</span>
<span class="line-modified">!                 return i;</span>
<span class="line-removed">-             }};</span>
          try { return rendezvousParent(child, objectsInUse); }
          catch (Throwable t) { unexpected(t); return -1; }
      }
  
      static void realMain(String[] args) throws Throwable {
          // jmap doesn&#39;t work on Windows
          if (System.getProperty(&quot;os.name&quot;).startsWith(&quot;Windows&quot;))
              return;
  
          final String childClassName = Job.class.getName();
<span class="line-modified">!         final String classToCheckForLeaks = Job.classToCheckForLeaks();</span>
<span class="line-modified">!         final String uniqueID =</span>
<span class="line-modified">!             String.valueOf(ThreadLocalRandom.current().nextInt(Integer.MAX_VALUE));</span>
<span class="line-modified">! </span>
<span class="line-modified">!         final String[] jobCmd = {</span>
<span class="line-modified">!             java, &quot;-Xmx8m&quot;, &quot;-XX:+UsePerfData&quot;,</span>
<span class="line-modified">!             &quot;-classpath&quot;, System.getProperty(&quot;test.class.path&quot;),</span>
<span class="line-modified">!             childClassName, uniqueID</span>
<span class="line-modified">!         };</span>
          final Process p = new ProcessBuilder(jobCmd).start();
          // Ensure subprocess jvm has started, so that jps can find it
          p.getInputStream().read();
          sendByte(p.getOutputStream());
  
          final String childPid =
<span class="line-modified">!             match(commandOutputOf(jps, &quot;-m&quot;),</span>
                    &quot;(?m)^ *([0-9]+) +\\Q&quot;+childClassName+&quot;\\E *&quot;+uniqueID+&quot;$&quot;, 1);
  
<span class="line-modified">!         final int n0 = objectsInUse(p, childPid, classToCheckForLeaks);</span>
<span class="line-modified">!         final int n1 = objectsInUse(p, childPid, classToCheckForLeaks);</span>
          equal(p.waitFor(), 0);
          equal(p.exitValue(), 0);
          failed += p.exitValue();
  
          // Check that no objects were leaked.
          //
          // TODO: This test is very brittle, depending on current JDK
          // implementation, and needing occasional adjustment.
          System.out.printf(&quot;%d -&gt; %d%n&quot;, n0, n1);
          // Almost always n0 == n1
<span class="line-modified">!         // Maximum jitter observed in practice is 10 -&gt; 17</span>
          check(Math.abs(n1 - n0) &lt; 10);
          check(n1 &lt; 25);
          drainers.shutdown();
          if (!drainers.awaitTermination(LONG_DELAY_MS, MILLISECONDS)) {
              drainers.shutdownNow(); // last resort
<span class="line-new-header">--- 175,66 ---</span>
          s.flush();
      }
  
      static int objectsInUse(final Process child,
                              final String childPid,
<span class="line-modified">!                             final String classNameRegex) {</span>
<span class="line-modified">!         String regex =</span>
<span class="line-modified">!             &quot;(?m)^ *[0-9]+: +([0-9]+) +[0-9]+ +&quot;+classNameRegex+&quot;(?:$| )&quot;;</span>
<span class="line-modified">!         Callable&lt;Integer&gt; objectsInUse = () -&gt; {</span>
<span class="line-modified">!             int i = Integer.parseInt(</span>
<span class="line-modified">!                 match(commandOutputOf(jmapPath, &quot;-histo:live&quot;, childPid),</span>
<span class="line-modified">!                       regex, 1));</span>
<span class="line-modified">!             if (i &gt; 100)</span>
<span class="line-modified">!                 System.out.print(</span>
<span class="line-modified">!                     commandOutputOf(jmapPath,</span>
<span class="line-modified">!                                     &quot;-dump:file=dump,format=b&quot;,</span>
<span class="line-modified">!                                     childPid));</span>
<span class="line-modified">!             return i;</span>
<span class="line-modified">!         };</span>
          try { return rendezvousParent(child, objectsInUse); }
          catch (Throwable t) { unexpected(t); return -1; }
      }
  
      static void realMain(String[] args) throws Throwable {
          // jmap doesn&#39;t work on Windows
          if (System.getProperty(&quot;os.name&quot;).startsWith(&quot;Windows&quot;))
              return;
  
          final String childClassName = Job.class.getName();
<span class="line-modified">!         final String classNameRegex = Job.classNameRegexToCheckForLeaks();</span>
<span class="line-modified">!         final String uniqueID = String.valueOf(</span>
<span class="line-modified">!             ThreadLocalRandom.current().nextInt(Integer.MAX_VALUE));</span>
<span class="line-modified">! </span>
<span class="line-modified">!         final ArrayList&lt;String&gt; jobCmd = new ArrayList&lt;&gt;();</span>
<span class="line-modified">!         Collections.addAll(</span>
<span class="line-modified">!             jobCmd, javaPath, &quot;-Xmx8m&quot;, &quot;-XX:+UsePerfData&quot;,</span>
<span class="line-modified">!             &quot;-classpath&quot;, System.getProperty(&quot;test.class.path&quot;));</span>
<span class="line-modified">!         Collections.addAll(jobCmd, Utils.getTestJavaOpts());</span>
<span class="line-added">+         Collections.addAll(jobCmd, childClassName, uniqueID);</span>
          final Process p = new ProcessBuilder(jobCmd).start();
          // Ensure subprocess jvm has started, so that jps can find it
          p.getInputStream().read();
          sendByte(p.getOutputStream());
  
          final String childPid =
<span class="line-modified">!             match(commandOutputOf(jpsPath, &quot;-m&quot;),</span>
                    &quot;(?m)^ *([0-9]+) +\\Q&quot;+childClassName+&quot;\\E *&quot;+uniqueID+&quot;$&quot;, 1);
  
<span class="line-modified">!         final int n0 = objectsInUse(p, childPid, classNameRegex);</span>
<span class="line-modified">!         final int n1 = objectsInUse(p, childPid, classNameRegex);</span>
          equal(p.waitFor(), 0);
          equal(p.exitValue(), 0);
          failed += p.exitValue();
  
          // Check that no objects were leaked.
          //
          // TODO: This test is very brittle, depending on current JDK
          // implementation, and needing occasional adjustment.
          System.out.printf(&quot;%d -&gt; %d%n&quot;, n0, n1);
          // Almost always n0 == n1
<span class="line-modified">!         // Maximum jitter observed in practice is 7</span>
          check(Math.abs(n1 - n0) &lt; 10);
          check(n1 &lt; 25);
          drainers.shutdown();
          if (!drainers.awaitTermination(LONG_DELAY_MS, MILLISECONDS)) {
              drainers.shutdownNow(); // last resort
</pre>
<hr />
<pre>
<span class="line-old-header">*** 242,13 ***</span>
      // - provide the name of a class to check for leaks.
      // - call rendezvousChild exactly twice, while quiescent.
      // - in between calls to rendezvousChild, run code that may leak.
      //----------------------------------------------------------------
      public static class Job {
<span class="line-modified">!         static String classToCheckForLeaks() {</span>
              return
<span class="line-modified">!                 &quot;java.util.concurrent.locks.AbstractQueuedSynchronizer$Node&quot;;</span>
          }
  
          public static void main(String[] args) throws Throwable {
              // Synchronize with parent process, so that jps can find us
              sendByte(System.out);
<span class="line-new-header">--- 248,13 ---</span>
      // - provide the name of a class to check for leaks.
      // - call rendezvousChild exactly twice, while quiescent.
      // - in between calls to rendezvousChild, run code that may leak.
      //----------------------------------------------------------------
      public static class Job {
<span class="line-modified">!         static String classNameRegexToCheckForLeaks() {</span>
              return
<span class="line-modified">!                 &quot;\\Qjava.util.concurrent.locks.AbstractQueuedSynchronizer$\\E[A-Za-z]+&quot;;</span>
          }
  
          public static void main(String[] args) throws Throwable {
              // Synchronize with parent process, so that jps can find us
              sendByte(System.out);
</pre>
<center><a href="FlakyMutex.java.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="../ReentrantLock/CancelledLockLoops.java.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
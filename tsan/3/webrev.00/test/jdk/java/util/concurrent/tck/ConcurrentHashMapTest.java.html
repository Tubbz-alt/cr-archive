<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New test/jdk/java/util/concurrent/tck/ConcurrentHashMapTest.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  3  *
  4  * This code is free software; you can redistribute it and/or modify it
  5  * under the terms of the GNU General Public License version 2 only, as
  6  * published by the Free Software Foundation.
  7  *
  8  * This code is distributed in the hope that it will be useful, but WITHOUT
  9  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 10  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 11  * version 2 for more details (a copy is included in the LICENSE file that
 12  * accompanied this code).
 13  *
 14  * You should have received a copy of the GNU General Public License version
 15  * 2 along with this work; if not, write to the Free Software Foundation,
 16  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 17  *
 18  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 19  * or visit www.oracle.com if you need additional information or have any
 20  * questions.
 21  */
 22 
 23 /*
 24  * This file is available under and governed by the GNU General Public
 25  * License version 2 only, as published by the Free Software Foundation.
 26  * However, the following notice accompanied the original version of this
 27  * file:
 28  *
 29  * Written by Doug Lea and Martin Buchholz with assistance from
 30  * members of JCP JSR-166 Expert Group and released to the public
 31  * domain, as explained at
 32  * http://creativecommons.org/publicdomain/zero/1.0/
 33  * Other contributors include Andrew Wright, Jeffrey Hayes,
 34  * Pat Fisher, Mike Judd.
 35  */
 36 
 37 import java.util.ArrayList;
 38 import java.util.Arrays;
 39 import java.util.Collection;
 40 import java.util.Collections;
 41 import java.util.Enumeration;
 42 import java.util.Iterator;
 43 import java.util.Map;
 44 import java.util.Random;
 45 import java.util.Set;
 46 import java.util.concurrent.ConcurrentHashMap;
 47 
 48 import junit.framework.Test;
 49 
 50 public class ConcurrentHashMapTest extends JSR166TestCase {
 51     public static void main(String[] args) {
 52         main(suite(), args);
 53     }
 54     public static Test suite() {
 55         class Implementation implements MapImplementation {
 56             public Class&lt;?&gt; klazz() { return ConcurrentHashMap.class; }
 57             public Map emptyMap() { return new ConcurrentHashMap(); }
 58             public boolean isConcurrent() { return true; }
 59             public boolean permitsNullKeys() { return false; }
 60             public boolean permitsNullValues() { return false; }
 61             public boolean supportsSetValue() { return true; }
 62         }
 63         return newTestSuite(
 64             ConcurrentHashMapTest.class,
 65             MapTest.testSuite(new Implementation()));
 66     }
 67 
 68     /**
 69      * Returns a new map from Integers 1-5 to Strings &quot;A&quot;-&quot;E&quot;.
 70      */
 71     private static ConcurrentHashMap&lt;Integer, String&gt; map5() {
 72         ConcurrentHashMap&lt;Integer, String&gt; map = new ConcurrentHashMap&lt;&gt;(5);
 73         assertTrue(map.isEmpty());
 74         map.put(one, &quot;A&quot;);
 75         map.put(two, &quot;B&quot;);
 76         map.put(three, &quot;C&quot;);
 77         map.put(four, &quot;D&quot;);
 78         map.put(five, &quot;E&quot;);
 79         assertFalse(map.isEmpty());
 80         assertEquals(5, map.size());
 81         return map;
 82     }
 83 
 84     // classes for testing Comparable fallbacks
 85     static class BI implements Comparable&lt;BI&gt; {
 86         private final int value;
 87         BI(int value) { this.value = value; }
 88         public int compareTo(BI other) {
 89             return Integer.compare(value, other.value);
 90         }
 91         public boolean equals(Object x) {
 92             return (x instanceof BI) &amp;&amp; ((BI)x).value == value;
 93         }
 94         public int hashCode() { return 42; }
 95     }
 96     static class CI extends BI { CI(int value) { super(value); } }
 97     static class DI extends BI { DI(int value) { super(value); } }
 98 
 99     static class BS implements Comparable&lt;BS&gt; {
100         private final String value;
101         BS(String value) { this.value = value; }
102         public int compareTo(BS other) {
103             return value.compareTo(other.value);
104         }
105         public boolean equals(Object x) {
106             return (x instanceof BS) &amp;&amp; value.equals(((BS)x).value);
107         }
108         public int hashCode() { return 42; }
109     }
110 
111     static class LexicographicList&lt;E extends Comparable&lt;E&gt;&gt; extends ArrayList&lt;E&gt;
112         implements Comparable&lt;LexicographicList&lt;E&gt;&gt; {
113         LexicographicList(Collection&lt;E&gt; c) { super(c); }
114         LexicographicList(E e) { super(Collections.singleton(e)); }
115         public int compareTo(LexicographicList&lt;E&gt; other) {
116             int common = Math.min(size(), other.size());
117             int r = 0;
118             for (int i = 0; i &lt; common; i++) {
119                 if ((r = get(i).compareTo(other.get(i))) != 0)
120                     break;
121             }
122             if (r == 0)
123                 r = Integer.compare(size(), other.size());
124             return r;
125         }
126         private static final long serialVersionUID = 0;
127     }
128 
129     static class CollidingObject {
130         final String value;
131         CollidingObject(final String value) { this.value = value; }
132         public int hashCode() { return this.value.hashCode() &amp; 1; }
133         public boolean equals(final Object obj) {
134             return (obj instanceof CollidingObject) &amp;&amp; ((CollidingObject)obj).value.equals(value);
135         }
136     }
137 
138     static class ComparableCollidingObject extends CollidingObject implements Comparable&lt;ComparableCollidingObject&gt; {
139         ComparableCollidingObject(final String value) { super(value); }
140         public int compareTo(final ComparableCollidingObject o) {
141             return value.compareTo(o.value);
142         }
143     }
144 
145     /**
146      * Inserted elements that are subclasses of the same Comparable
147      * class are found.
148      */
149     public void testComparableFamily() {
150         int size = 500;         // makes measured test run time -&gt; 60ms
151         ConcurrentHashMap&lt;BI, Boolean&gt; m = new ConcurrentHashMap&lt;&gt;();
152         for (int i = 0; i &lt; size; i++) {
153             assertNull(m.put(new CI(i), true));
154         }
155         for (int i = 0; i &lt; size; i++) {
156             assertTrue(m.containsKey(new CI(i)));
157             assertTrue(m.containsKey(new DI(i)));
158         }
159     }
160 
161     /**
162      * Elements of classes with erased generic type parameters based
163      * on Comparable can be inserted and found.
164      */
165     public void testGenericComparable() {
166         int size = 120;         // makes measured test run time -&gt; 60ms
167         ConcurrentHashMap&lt;Object, Boolean&gt; m = new ConcurrentHashMap&lt;&gt;();
168         for (int i = 0; i &lt; size; i++) {
169             BI bi = new BI(i);
170             BS bs = new BS(String.valueOf(i));
171             LexicographicList&lt;BI&gt; bis = new LexicographicList&lt;&gt;(bi);
172             LexicographicList&lt;BS&gt; bss = new LexicographicList&lt;&gt;(bs);
173             assertNull(m.putIfAbsent(bis, true));
174             assertTrue(m.containsKey(bis));
175             if (m.putIfAbsent(bss, true) == null)
176                 assertTrue(m.containsKey(bss));
177             assertTrue(m.containsKey(bis));
178         }
179         for (int i = 0; i &lt; size; i++) {
180             assertTrue(m.containsKey(Collections.singletonList(new BI(i))));
181         }
182     }
183 
184     /**
185      * Elements of non-comparable classes equal to those of classes
186      * with erased generic type parameters based on Comparable can be
187      * inserted and found.
188      */
189     public void testGenericComparable2() {
190         int size = 500;         // makes measured test run time -&gt; 60ms
191         ConcurrentHashMap&lt;Object, Boolean&gt; m = new ConcurrentHashMap&lt;&gt;();
192         for (int i = 0; i &lt; size; i++) {
193             m.put(Collections.singletonList(new BI(i)), true);
194         }
195 
196         for (int i = 0; i &lt; size; i++) {
197             LexicographicList&lt;BI&gt; bis = new LexicographicList&lt;&gt;(new BI(i));
198             assertTrue(m.containsKey(bis));
199         }
200     }
201 
202     /**
203      * Mixtures of instances of comparable and non-comparable classes
204      * can be inserted and found.
205      */
206     public void testMixedComparable() {
207         int size = 1200;        // makes measured test run time -&gt; 35ms
208         ConcurrentHashMap&lt;Object, Object&gt; map = new ConcurrentHashMap&lt;&gt;();
209         Random rng = new Random();
210         for (int i = 0; i &lt; size; i++) {
211             Object x;
212             switch (rng.nextInt(4)) {
213             case 0:
214                 x = new Object();
215                 break;
216             case 1:
217                 x = new CollidingObject(Integer.toString(i));
218                 break;
219             default:
220                 x = new ComparableCollidingObject(Integer.toString(i));
221             }
222             assertNull(map.put(x, x));
223         }
224         int count = 0;
225         for (Object k : map.keySet()) {
226             assertEquals(map.get(k), k);
227             ++count;
228         }
229         assertEquals(count, size);
230         assertEquals(map.size(), size);
231         for (Object k : map.keySet()) {
232             assertEquals(map.put(k, k), k);
233         }
234     }
235 
236     /**
237      * clear removes all pairs
238      */
239     public void testClear() {
240         ConcurrentHashMap map = map5();
241         map.clear();
242         assertEquals(0, map.size());
243     }
244 
245     /**
246      * Maps with same contents are equal
247      */
248     public void testEquals() {
249         ConcurrentHashMap map1 = map5();
250         ConcurrentHashMap map2 = map5();
251         assertEquals(map1, map2);
252         assertEquals(map2, map1);
253         map1.clear();
254         assertFalse(map1.equals(map2));
255         assertFalse(map2.equals(map1));
256     }
257 
258     /**
259      * hashCode() equals sum of each key.hashCode ^ value.hashCode
260      */
261     public void testHashCode() {
262         ConcurrentHashMap&lt;Integer,String&gt; map = map5();
263         int sum = 0;
264         for (Map.Entry&lt;Integer,String&gt; e : map.entrySet())
265             sum += e.getKey().hashCode() ^ e.getValue().hashCode();
266         assertEquals(sum, map.hashCode());
267     }
268 
269     /**
270      * contains returns true for contained value
271      */
272     public void testContains() {
273         ConcurrentHashMap map = map5();
274         assertTrue(map.contains(&quot;A&quot;));
275         assertFalse(map.contains(&quot;Z&quot;));
276     }
277 
278     /**
279      * containsKey returns true for contained key
280      */
281     public void testContainsKey() {
282         ConcurrentHashMap map = map5();
283         assertTrue(map.containsKey(one));
284         assertFalse(map.containsKey(zero));
285     }
286 
287     /**
288      * containsValue returns true for held values
289      */
290     public void testContainsValue() {
291         ConcurrentHashMap map = map5();
292         assertTrue(map.containsValue(&quot;A&quot;));
293         assertFalse(map.containsValue(&quot;Z&quot;));
294     }
295 
296     /**
297      * enumeration returns an enumeration containing the correct
298      * elements
299      */
300     public void testEnumeration() {
301         ConcurrentHashMap map = map5();
302         Enumeration e = map.elements();
303         int count = 0;
304         while (e.hasMoreElements()) {
305             count++;
306             e.nextElement();
307         }
308         assertEquals(5, count);
309     }
310 
311     /**
312      * get returns the correct element at the given key,
313      * or null if not present
314      */
315     public void testGet() {
316         ConcurrentHashMap map = map5();
317         assertEquals(&quot;A&quot;, (String)map.get(one));
318         ConcurrentHashMap empty = new ConcurrentHashMap();
319         assertNull(map.get(&quot;anything&quot;));
320         assertNull(empty.get(&quot;anything&quot;));
321     }
322 
323     /**
324      * isEmpty is true of empty map and false for non-empty
325      */
326     public void testIsEmpty() {
327         ConcurrentHashMap empty = new ConcurrentHashMap();
328         ConcurrentHashMap map = map5();
329         assertTrue(empty.isEmpty());
330         assertFalse(map.isEmpty());
331     }
332 
333     /**
334      * keys returns an enumeration containing all the keys from the map
335      */
336     public void testKeys() {
337         ConcurrentHashMap map = map5();
338         Enumeration e = map.keys();
339         int count = 0;
340         while (e.hasMoreElements()) {
341             count++;
342             e.nextElement();
343         }
344         assertEquals(5, count);
345     }
346 
347     /**
348      * keySet returns a Set containing all the keys
349      */
350     public void testKeySet() {
351         ConcurrentHashMap map = map5();
352         Set s = map.keySet();
353         assertEquals(5, s.size());
354         assertTrue(s.contains(one));
355         assertTrue(s.contains(two));
356         assertTrue(s.contains(three));
357         assertTrue(s.contains(four));
358         assertTrue(s.contains(five));
359     }
360 
361     /**
362      * Test keySet().removeAll on empty map
363      */
364     public void testKeySet_empty_removeAll() {
365         ConcurrentHashMap&lt;Integer, String&gt; map = new ConcurrentHashMap&lt;&gt;();
366         Set&lt;Integer&gt; set = map.keySet();
367         set.removeAll(Collections.emptyList());
368         assertTrue(map.isEmpty());
369         assertTrue(set.isEmpty());
370         // following is test for JDK-8163353
371         set.removeAll(Collections.emptySet());
372         assertTrue(map.isEmpty());
373         assertTrue(set.isEmpty());
374     }
375 
376     /**
377      * keySet.toArray returns contains all keys
378      */
379     public void testKeySetToArray() {
380         ConcurrentHashMap map = map5();
381         Set s = map.keySet();
382         Object[] ar = s.toArray();
383         assertTrue(s.containsAll(Arrays.asList(ar)));
384         assertEquals(5, ar.length);
385         ar[0] = m10;
386         assertFalse(s.containsAll(Arrays.asList(ar)));
387     }
388 
389     /**
390      * Values.toArray contains all values
391      */
392     public void testValuesToArray() {
393         ConcurrentHashMap map = map5();
394         Collection v = map.values();
395         Object[] ar = v.toArray();
396         ArrayList s = new ArrayList(Arrays.asList(ar));
397         assertEquals(5, ar.length);
398         assertTrue(s.contains(&quot;A&quot;));
399         assertTrue(s.contains(&quot;B&quot;));
400         assertTrue(s.contains(&quot;C&quot;));
401         assertTrue(s.contains(&quot;D&quot;));
402         assertTrue(s.contains(&quot;E&quot;));
403     }
404 
405     /**
406      * entrySet.toArray contains all entries
407      */
408     public void testEntrySetToArray() {
409         ConcurrentHashMap map = map5();
410         Set s = map.entrySet();
411         Object[] ar = s.toArray();
412         assertEquals(5, ar.length);
413         for (int i = 0; i &lt; 5; ++i) {
414             assertTrue(map.containsKey(((Map.Entry)(ar[i])).getKey()));
415             assertTrue(map.containsValue(((Map.Entry)(ar[i])).getValue()));
416         }
417     }
418 
419     /**
420      * values collection contains all values
421      */
422     public void testValues() {
423         ConcurrentHashMap map = map5();
424         Collection s = map.values();
425         assertEquals(5, s.size());
426         assertTrue(s.contains(&quot;A&quot;));
427         assertTrue(s.contains(&quot;B&quot;));
428         assertTrue(s.contains(&quot;C&quot;));
429         assertTrue(s.contains(&quot;D&quot;));
430         assertTrue(s.contains(&quot;E&quot;));
431     }
432 
433     /**
434      * entrySet contains all pairs
435      */
436     public void testEntrySet() {
437         ConcurrentHashMap map = map5();
438         Set s = map.entrySet();
439         assertEquals(5, s.size());
440         Iterator it = s.iterator();
441         while (it.hasNext()) {
442             Map.Entry e = (Map.Entry) it.next();
443             assertTrue(
444                        (e.getKey().equals(one) &amp;&amp; e.getValue().equals(&quot;A&quot;)) ||
445                        (e.getKey().equals(two) &amp;&amp; e.getValue().equals(&quot;B&quot;)) ||
446                        (e.getKey().equals(three) &amp;&amp; e.getValue().equals(&quot;C&quot;)) ||
447                        (e.getKey().equals(four) &amp;&amp; e.getValue().equals(&quot;D&quot;)) ||
448                        (e.getKey().equals(five) &amp;&amp; e.getValue().equals(&quot;E&quot;)));
449         }
450     }
451 
452     /**
453      * putAll adds all key-value pairs from the given map
454      */
455     public void testPutAll() {
456         ConcurrentHashMap empty = new ConcurrentHashMap();
457         ConcurrentHashMap map = map5();
458         empty.putAll(map);
459         assertEquals(5, empty.size());
460         assertTrue(empty.containsKey(one));
461         assertTrue(empty.containsKey(two));
462         assertTrue(empty.containsKey(three));
463         assertTrue(empty.containsKey(four));
464         assertTrue(empty.containsKey(five));
465     }
466 
467     /**
468      * putIfAbsent works when the given key is not present
469      */
470     public void testPutIfAbsent() {
471         ConcurrentHashMap map = map5();
472         map.putIfAbsent(six, &quot;Z&quot;);
473         assertTrue(map.containsKey(six));
474     }
475 
476     /**
477      * putIfAbsent does not add the pair if the key is already present
478      */
479     public void testPutIfAbsent2() {
480         ConcurrentHashMap map = map5();
481         assertEquals(&quot;A&quot;, map.putIfAbsent(one, &quot;Z&quot;));
482     }
483 
484     /**
485      * replace fails when the given key is not present
486      */
487     public void testReplace() {
488         ConcurrentHashMap map = map5();
489         assertNull(map.replace(six, &quot;Z&quot;));
490         assertFalse(map.containsKey(six));
491     }
492 
493     /**
494      * replace succeeds if the key is already present
495      */
496     public void testReplace2() {
497         ConcurrentHashMap map = map5();
498         assertNotNull(map.replace(one, &quot;Z&quot;));
499         assertEquals(&quot;Z&quot;, map.get(one));
500     }
501 
502     /**
503      * replace value fails when the given key not mapped to expected value
504      */
505     public void testReplaceValue() {
506         ConcurrentHashMap map = map5();
507         assertEquals(&quot;A&quot;, map.get(one));
508         assertFalse(map.replace(one, &quot;Z&quot;, &quot;Z&quot;));
509         assertEquals(&quot;A&quot;, map.get(one));
510     }
511 
512     /**
513      * replace value succeeds when the given key mapped to expected value
514      */
515     public void testReplaceValue2() {
516         ConcurrentHashMap map = map5();
517         assertEquals(&quot;A&quot;, map.get(one));
518         assertTrue(map.replace(one, &quot;A&quot;, &quot;Z&quot;));
519         assertEquals(&quot;Z&quot;, map.get(one));
520     }
521 
522     /**
523      * remove removes the correct key-value pair from the map
524      */
525     public void testRemove() {
526         ConcurrentHashMap map = map5();
527         map.remove(five);
528         assertEquals(4, map.size());
529         assertFalse(map.containsKey(five));
530     }
531 
532     /**
533      * remove(key,value) removes only if pair present
534      */
535     public void testRemove2() {
536         ConcurrentHashMap map = map5();
537         map.remove(five, &quot;E&quot;);
538         assertEquals(4, map.size());
539         assertFalse(map.containsKey(five));
540         map.remove(four, &quot;A&quot;);
541         assertEquals(4, map.size());
542         assertTrue(map.containsKey(four));
543     }
544 
545     /**
546      * size returns the correct values
547      */
548     public void testSize() {
549         ConcurrentHashMap map = map5();
550         ConcurrentHashMap empty = new ConcurrentHashMap();
551         assertEquals(0, empty.size());
552         assertEquals(5, map.size());
553     }
554 
555     /**
556      * toString contains toString of elements
557      */
558     public void testToString() {
559         ConcurrentHashMap map = map5();
560         String s = map.toString();
561         for (int i = 1; i &lt;= 5; ++i) {
562             assertTrue(s.contains(String.valueOf(i)));
563         }
564     }
565 
566     // Exception tests
567 
568     /**
569      * Cannot create with only negative capacity
570      */
571     public void testConstructor1() {
572         try {
573             new ConcurrentHashMap(-1);
574             shouldThrow();
575         } catch (IllegalArgumentException success) {}
576     }
577 
578     /**
579      * Constructor (initialCapacity, loadFactor) throws
580      * IllegalArgumentException if either argument is negative
581      */
582     public void testConstructor2() {
583         try {
584             new ConcurrentHashMap(-1, .75f);
585             shouldThrow();
586         } catch (IllegalArgumentException success) {}
587 
588         try {
589             new ConcurrentHashMap(16, -1);
590             shouldThrow();
591         } catch (IllegalArgumentException success) {}
592     }
593 
594     /**
595      * Constructor (initialCapacity, loadFactor, concurrencyLevel)
596      * throws IllegalArgumentException if any argument is negative
597      */
598     public void testConstructor3() {
599         try {
600             new ConcurrentHashMap(-1, .75f, 1);
601             shouldThrow();
602         } catch (IllegalArgumentException success) {}
603 
604         try {
605             new ConcurrentHashMap(16, -1, 1);
606             shouldThrow();
607         } catch (IllegalArgumentException success) {}
608 
609         try {
610             new ConcurrentHashMap(16, .75f, -1);
611             shouldThrow();
612         } catch (IllegalArgumentException success) {}
613     }
614 
615     /**
616      * ConcurrentHashMap(map) throws NullPointerException if the given
617      * map is null
618      */
619     public void testConstructor4() {
620         try {
621             new ConcurrentHashMap(null);
622             shouldThrow();
623         } catch (NullPointerException success) {}
624     }
625 
626     /**
627      * ConcurrentHashMap(map) creates a new map with the same mappings
628      * as the given map
629      */
630     public void testConstructor5() {
631         ConcurrentHashMap map1 = map5();
632         ConcurrentHashMap map2 = new ConcurrentHashMap(map5());
633         assertTrue(map2.equals(map1));
634         map2.put(one, &quot;F&quot;);
635         assertFalse(map2.equals(map1));
636     }
637 
638     /**
639      * get(null) throws NPE
640      */
641     public void testGet_NullPointerException() {
642         ConcurrentHashMap c = new ConcurrentHashMap(5);
643         try {
644             c.get(null);
645             shouldThrow();
646         } catch (NullPointerException success) {}
647     }
648 
649     /**
650      * containsKey(null) throws NPE
651      */
652     public void testContainsKey_NullPointerException() {
653         ConcurrentHashMap c = new ConcurrentHashMap(5);
654         try {
655             c.containsKey(null);
656             shouldThrow();
657         } catch (NullPointerException success) {}
658     }
659 
660     /**
661      * containsValue(null) throws NPE
662      */
663     public void testContainsValue_NullPointerException() {
664         ConcurrentHashMap c = new ConcurrentHashMap(5);
665         try {
666             c.containsValue(null);
667             shouldThrow();
668         } catch (NullPointerException success) {}
669     }
670 
671     /**
672      * contains(null) throws NPE
673      */
674     public void testContains_NullPointerException() {
675         ConcurrentHashMap c = new ConcurrentHashMap(5);
676         try {
677             c.contains(null);
678             shouldThrow();
679         } catch (NullPointerException success) {}
680     }
681 
682     /**
683      * put(null,x) throws NPE
684      */
685     public void testPut1_NullPointerException() {
686         ConcurrentHashMap c = new ConcurrentHashMap(5);
687         try {
688             c.put(null, &quot;whatever&quot;);
689             shouldThrow();
690         } catch (NullPointerException success) {}
691     }
692 
693     /**
694      * put(x, null) throws NPE
695      */
696     public void testPut2_NullPointerException() {
697         ConcurrentHashMap c = new ConcurrentHashMap(5);
698         try {
699             c.put(&quot;whatever&quot;, null);
700             shouldThrow();
701         } catch (NullPointerException success) {}
702     }
703 
704     /**
705      * putIfAbsent(null, x) throws NPE
706      */
707     public void testPutIfAbsent1_NullPointerException() {
708         ConcurrentHashMap c = new ConcurrentHashMap(5);
709         try {
710             c.putIfAbsent(null, &quot;whatever&quot;);
711             shouldThrow();
712         } catch (NullPointerException success) {}
713     }
714 
715     /**
716      * replace(null, x) throws NPE
717      */
718     public void testReplace_NullPointerException() {
719         ConcurrentHashMap c = new ConcurrentHashMap(5);
720         try {
721             c.replace(null, &quot;whatever&quot;);
722             shouldThrow();
723         } catch (NullPointerException success) {}
724     }
725 
726     /**
727      * replace(null, x, y) throws NPE
728      */
729     public void testReplaceValue_NullPointerException() {
730         ConcurrentHashMap c = new ConcurrentHashMap(5);
731         try {
732             c.replace(null, one, &quot;whatever&quot;);
733             shouldThrow();
734         } catch (NullPointerException success) {}
735     }
736 
737     /**
738      * putIfAbsent(x, null) throws NPE
739      */
740     public void testPutIfAbsent2_NullPointerException() {
741         ConcurrentHashMap c = new ConcurrentHashMap(5);
742         try {
743             c.putIfAbsent(&quot;whatever&quot;, null);
744             shouldThrow();
745         } catch (NullPointerException success) {}
746     }
747 
748     /**
749      * replace(x, null) throws NPE
750      */
751     public void testReplace2_NullPointerException() {
752         ConcurrentHashMap c = new ConcurrentHashMap(5);
753         try {
754             c.replace(&quot;whatever&quot;, null);
755             shouldThrow();
756         } catch (NullPointerException success) {}
757     }
758 
759     /**
760      * replace(x, null, y) throws NPE
761      */
762     public void testReplaceValue2_NullPointerException() {
763         ConcurrentHashMap c = new ConcurrentHashMap(5);
764         try {
765             c.replace(&quot;whatever&quot;, null, &quot;A&quot;);
766             shouldThrow();
767         } catch (NullPointerException success) {}
768     }
769 
770     /**
771      * replace(x, y, null) throws NPE
772      */
773     public void testReplaceValue3_NullPointerException() {
774         ConcurrentHashMap c = new ConcurrentHashMap(5);
775         try {
776             c.replace(&quot;whatever&quot;, one, null);
777             shouldThrow();
778         } catch (NullPointerException success) {}
779     }
780 
781     /**
782      * remove(null) throws NPE
783      */
784     public void testRemove1_NullPointerException() {
785         ConcurrentHashMap c = new ConcurrentHashMap(5);
786         c.put(&quot;sadsdf&quot;, &quot;asdads&quot;);
787         try {
788             c.remove(null);
789             shouldThrow();
790         } catch (NullPointerException success) {}
791     }
792 
793     /**
794      * remove(null, x) throws NPE
795      */
796     public void testRemove2_NullPointerException() {
797         ConcurrentHashMap c = new ConcurrentHashMap(5);
798         c.put(&quot;sadsdf&quot;, &quot;asdads&quot;);
799         try {
800             c.remove(null, &quot;whatever&quot;);
801             shouldThrow();
802         } catch (NullPointerException success) {}
803     }
804 
805     /**
806      * remove(x, null) returns false
807      */
808     public void testRemove3() {
809         ConcurrentHashMap c = new ConcurrentHashMap(5);
810         c.put(&quot;sadsdf&quot;, &quot;asdads&quot;);
811         assertFalse(c.remove(&quot;sadsdf&quot;, null));
812     }
813 
814     /**
815      * A deserialized/reserialized map equals original
816      */
817     public void testSerialization() throws Exception {
818         Map x = map5();
819         Map y = serialClone(x);
820 
821         assertNotSame(x, y);
822         assertEquals(x.size(), y.size());
823         assertEquals(x, y);
824         assertEquals(y, x);
825     }
826 
827     /**
828      * SetValue of an EntrySet entry sets value in the map.
829      */
830     public void testSetValueWriteThrough() {
831         // Adapted from a bug report by Eric Zoerner
832         ConcurrentHashMap map = new ConcurrentHashMap(2, 5.0f, 1);
833         assertTrue(map.isEmpty());
834         for (int i = 0; i &lt; 20; i++)
835             map.put(new Integer(i), new Integer(i));
836         assertFalse(map.isEmpty());
837         Map.Entry entry1 = (Map.Entry)map.entrySet().iterator().next();
838         // Unless it happens to be first (in which case remainder of
839         // test is skipped), remove a possibly-colliding key from map
840         // which, under some implementations, may cause entry1 to be
841         // cloned in map
842         if (!entry1.getKey().equals(new Integer(16))) {
843             map.remove(new Integer(16));
844             entry1.setValue(&quot;XYZ&quot;);
845             assertTrue(map.containsValue(&quot;XYZ&quot;)); // fails if write-through broken
846         }
847     }
848 
849     /**
850      * Tests performance of removeAll when the other collection is much smaller.
851      * ant -Djsr166.tckTestClass=ConcurrentHashMapTest -Djsr166.methodFilter=testRemoveAll_performance -Djsr166.expensiveTests=true tck
852      */
853     public void testRemoveAll_performance() {
854         final int mapSize = expensiveTests ? 1_000_000 : 100;
855         final int iterations = expensiveTests ? 500 : 2;
856         final ConcurrentHashMap&lt;Integer, Integer&gt; map = new ConcurrentHashMap&lt;&gt;();
857         for (int i = 0; i &lt; mapSize; i++)
858             map.put(i, i);
859         Set&lt;Integer&gt; keySet = map.keySet();
860         Collection&lt;Integer&gt; removeMe = Arrays.asList(new Integer[] { -99, -86 });
861         for (int i = 0; i &lt; iterations; i++)
862             assertFalse(keySet.removeAll(removeMe));
863         assertEquals(mapSize, map.size());
864     }
865 
866     public void testReentrantComputeIfAbsent() {
867         ConcurrentHashMap&lt;Integer, Integer&gt; map = new ConcurrentHashMap&lt;&gt;(16);
868         try {
869             for (int i = 0; i &lt; 100; i++) { // force a resize
870                 map.computeIfAbsent(i, key -&gt; findValue(map, key));
871             }
872             fail(&quot;recursive computeIfAbsent should throw IllegalStateException&quot;);
873         } catch (IllegalStateException success) {}
874     }
875 
876     private Integer findValue(ConcurrentHashMap&lt;Integer, Integer&gt; map,
877                               Integer key) {
878         return (key % 5 == 0) ?  key :
879             map.computeIfAbsent(key + 1, k -&gt; findValue(map, k));
880     }
881 
882 }
    </pre>
  </body>
</html>
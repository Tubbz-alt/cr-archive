<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames test/jdk/java/util/concurrent/tck/MapTest.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  3  *
  4  * This code is free software; you can redistribute it and/or modify it
  5  * under the terms of the GNU General Public License version 2 only, as
  6  * published by the Free Software Foundation.
  7  *
  8  * This code is distributed in the hope that it will be useful, but WITHOUT
  9  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 10  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 11  * version 2 for more details (a copy is included in the LICENSE file that
 12  * accompanied this code).
 13  *
 14  * You should have received a copy of the GNU General Public License version
 15  * 2 along with this work; if not, write to the Free Software Foundation,
 16  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 17  *
 18  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 19  * or visit www.oracle.com if you need additional information or have any
 20  * questions.
 21  */
 22 
 23 /*
 24  * This file is available under and governed by the GNU General Public
 25  * License version 2 only, as published by the Free Software Foundation.
 26  * However, the following notice accompanied the original version of this
 27  * file:
 28  *
 29  * Written by Doug Lea and Martin Buchholz with assistance from
 30  * members of JCP JSR-166 Expert Group and released to the public
 31  * domain, as explained at
 32  * http://creativecommons.org/publicdomain/zero/1.0/
 33  */
 34 
<a name="1" id="anc1"></a>

 35 import java.util.ArrayList;
 36 import java.util.Iterator;
 37 import java.util.List;
 38 import java.util.Map;
<a name="2" id="anc2"></a><span class="line-added"> 39 import java.util.concurrent.CompletableFuture;</span>
 40 import java.util.concurrent.ThreadLocalRandom;
<a name="3" id="anc3"></a><span class="line-added"> 41 import java.util.concurrent.atomic.AtomicBoolean;</span>
<span class="line-added"> 42 import java.util.concurrent.atomic.AtomicLong;</span>
<span class="line-added"> 43 import java.util.function.BiFunction;</span>
<span class="line-added"> 44 </span>
<span class="line-added"> 45 import junit.framework.Test;</span>
 46 
 47 /**
 48  * Contains tests applicable to all Map implementations.
 49  */
 50 public class MapTest extends JSR166TestCase {
 51     final MapImplementation impl;
 52 
 53     /** Tests are parameterized by a Map implementation. */
 54     MapTest(MapImplementation impl, String methodName) {
 55         super(methodName);
 56         this.impl = impl;
 57     }
 58 
 59     public static Test testSuite(MapImplementation impl) {
 60         return newTestSuite(
 61             parameterizedTestSuite(MapTest.class,
 62                                    MapImplementation.class,
 63                                    impl));
 64     }
 65 
 66     public void testImplSanity() {
 67         final ThreadLocalRandom rnd = ThreadLocalRandom.current();
 68         {
 69             Map m = impl.emptyMap();
 70             assertTrue(m.isEmpty());
 71             assertEquals(0, m.size());
 72             Object k = impl.makeKey(rnd.nextInt());
 73             Object v = impl.makeValue(rnd.nextInt());
 74             m.put(k, v);
 75             assertFalse(m.isEmpty());
 76             assertEquals(1, m.size());
 77             assertTrue(m.containsKey(k));
 78             assertTrue(m.containsValue(v));
 79         }
 80         {
 81             Map m = impl.emptyMap();
 82             Object v = impl.makeValue(rnd.nextInt());
 83             if (impl.permitsNullKeys()) {
 84                 m.put(null, v);
 85                 assertTrue(m.containsKey(null));
 86                 assertTrue(m.containsValue(v));
 87             } else {
 88                 assertThrows(NullPointerException.class, () -&gt; m.put(null, v));
 89             }
 90         }
 91         {
 92             Map m = impl.emptyMap();
 93             Object k = impl.makeKey(rnd.nextInt());
 94             if (impl.permitsNullValues()) {
 95                 m.put(k, null);
 96                 assertTrue(m.containsKey(k));
 97                 assertTrue(m.containsValue(null));
 98             } else {
 99                 assertThrows(NullPointerException.class, () -&gt; m.put(k, null));
100             }
101         }
102         {
103             Map m = impl.emptyMap();
104             Object k = impl.makeKey(rnd.nextInt());
105             Object v1 = impl.makeValue(rnd.nextInt());
106             Object v2 = impl.makeValue(rnd.nextInt());
107             m.put(k, v1);
108             if (impl.supportsSetValue()) {
109                 ((Map.Entry)(m.entrySet().iterator().next())).setValue(v2);
110                 assertSame(v2, m.get(k));
111                 assertTrue(m.containsKey(k));
112                 assertTrue(m.containsValue(v2));
113                 assertFalse(m.containsValue(v1));
114             } else {
115                 assertThrows(UnsupportedOperationException.class,
116                              () -&gt; ((Map.Entry)(m.entrySet().iterator().next())).setValue(v2));
117             }
118         }
119     }
120 
121     /**
122      * Tests and extends the scenario reported in
123      * https://bugs.openjdk.java.net/browse/JDK-8186171
124      * HashMap: Entry.setValue may not work after Iterator.remove() called for previous entries
125      * ant -Djsr166.tckTestClass=HashMapTest -Djsr166.methodFilter=testBug8186171 -Djsr166.runsPerTest=1000 tck
126      */
127     public void testBug8186171() {
128         if (!impl.supportsSetValue()) return;
<a name="4" id="anc4"></a><span class="line-added">129         if (!atLeastJava10()) return; // jdk9 is no longer maintained</span>
130         final ThreadLocalRandom rnd = ThreadLocalRandom.current();
131         final boolean permitsNullValues = impl.permitsNullValues();
132         final Object v1 = (permitsNullValues &amp;&amp; rnd.nextBoolean())
133             ? null : impl.makeValue(1);
134         final Object v2 = (permitsNullValues &amp;&amp; rnd.nextBoolean() &amp;&amp; v1 != null)
135             ? null : impl.makeValue(2);
136 
137         // If true, always lands in first bucket in hash tables.
138         final boolean poorHash = rnd.nextBoolean();
139         class Key implements Comparable&lt;Key&gt; {
140             final int i;
141             Key(int i) { this.i = i; }
142             public int hashCode() { return poorHash ? 0 : super.hashCode(); }
143             public int compareTo(Key x) {
144                 return Integer.compare(this.i, x.i);
145             }
146         }
147 
148         // Both HashMap and ConcurrentHashMap have:
149         // TREEIFY_THRESHOLD = 8; UNTREEIFY_THRESHOLD = 6;
150         final int size = rnd.nextInt(1, 25);
151 
152         List&lt;Key&gt; keys = new ArrayList&lt;&gt;();
153         for (int i = size; i--&gt;0; ) keys.add(new Key(i));
154         Key keyToFrob = keys.get(rnd.nextInt(keys.size()));
155 
156         Map&lt;Key, Object&gt; m = impl.emptyMap();
157         for (Key key : keys) m.put(key, v1);
158 
159         for (Iterator&lt;Map.Entry&lt;Key, Object&gt;&gt; it = m.entrySet().iterator();
160              it.hasNext(); ) {
161             Map.Entry&lt;Key, Object&gt; entry = it.next();
162             if (entry.getKey() == keyToFrob)
163                 entry.setValue(v2); // does this have the expected effect?
164             else
165                 it.remove();
166         }
167 
168         assertFalse(m.containsValue(v1));
169         assertTrue(m.containsValue(v2));
170         assertTrue(m.containsKey(keyToFrob));
171         assertEquals(1, m.size());
172     }
173 
174     /**
175      * &quot;Missing&quot; test found while investigating JDK-8210280.
176      * ant -Djsr166.tckTestClass=HashMapTest -Djsr166.methodFilter=testBug8210280 -Djsr166.runsPerTest=1000000 tck
177      */
178     public void testBug8210280() {
179         final ThreadLocalRandom rnd = ThreadLocalRandom.current();
180         final int size1 = rnd.nextInt(32);
181         final int size2 = rnd.nextInt(128);
182 
183         final Map m1 = impl.emptyMap();
184         for (int i = 0; i &lt; size1; i++) {
185             int elt = rnd.nextInt(1024 * i, 1024 * (i + 1));
186             assertNull(m1.put(impl.makeKey(elt), impl.makeValue(elt)));
187         }
188 
189         final Map m2 = impl.emptyMap();
190         for (int i = 0; i &lt; size2; i++) {
191             int elt = rnd.nextInt(Integer.MIN_VALUE + 1024 * i,
192                                   Integer.MIN_VALUE + 1024 * (i + 1));
193             assertNull(m2.put(impl.makeKey(elt), impl.makeValue(-elt)));
194         }
195 
196         final Map m1Copy = impl.emptyMap();
197         m1Copy.putAll(m1);
198 
199         m1.putAll(m2);
200 
201         for (Object elt : m2.keySet())
202             assertEquals(m2.get(elt), m1.get(elt));
203         for (Object elt : m1Copy.keySet())
204             assertSame(m1Copy.get(elt), m1.get(elt));
205         assertEquals(size1 + size2, m1.size());
206     }
207 
<a name="5" id="anc5"></a><span class="line-added">208     /**</span>
<span class="line-added">209      * 8222930: ConcurrentSkipListMap.clone() shares size variable between original and clone</span>
<span class="line-added">210      */</span>
<span class="line-added">211     public void testClone() {</span>
<span class="line-added">212         final ThreadLocalRandom rnd = ThreadLocalRandom.current();</span>
<span class="line-added">213         final int size = rnd.nextInt(4);</span>
<span class="line-added">214         final Map map = impl.emptyMap();</span>
<span class="line-added">215         for (int i = 0; i &lt; size; i++)</span>
<span class="line-added">216             map.put(impl.makeKey(i), impl.makeValue(i));</span>
<span class="line-added">217         final Map clone = cloneableClone(map);</span>
<span class="line-added">218         if (clone == null) return;      // not cloneable?</span>
<span class="line-added">219 </span>
<span class="line-added">220         assertEquals(size, map.size());</span>
<span class="line-added">221         assertEquals(size, clone.size());</span>
<span class="line-added">222         assertEquals(map.isEmpty(), clone.isEmpty());</span>
<span class="line-added">223 </span>
<span class="line-added">224         clone.put(impl.makeKey(-1), impl.makeValue(-1));</span>
<span class="line-added">225         assertEquals(size, map.size());</span>
<span class="line-added">226         assertEquals(size + 1, clone.size());</span>
<span class="line-added">227 </span>
<span class="line-added">228         clone.clear();</span>
<span class="line-added">229         assertEquals(size, map.size());</span>
<span class="line-added">230         assertEquals(0, clone.size());</span>
<span class="line-added">231         assertTrue(clone.isEmpty());</span>
<span class="line-added">232     }</span>
<span class="line-added">233 </span>
<span class="line-added">234     /**</span>
<span class="line-added">235      * Concurrent access by compute methods behaves as expected</span>
<span class="line-added">236      */</span>
<span class="line-added">237     public void testConcurrentAccess() throws Throwable {</span>
<span class="line-added">238         final Map map = impl.emptyMap();</span>
<span class="line-added">239         final long testDurationMillis = expensiveTests ? 1000 : 2;</span>
<span class="line-added">240         final int nTasks = impl.isConcurrent()</span>
<span class="line-added">241             ? ThreadLocalRandom.current().nextInt(1, 10)</span>
<span class="line-added">242             : 1;</span>
<span class="line-added">243         final AtomicBoolean done = new AtomicBoolean(false);</span>
<span class="line-added">244         final boolean remappingFunctionCalledAtMostOnce</span>
<span class="line-added">245             = impl.remappingFunctionCalledAtMostOnce();</span>
<span class="line-added">246         final List&lt;CompletableFuture&gt; futures = new ArrayList&lt;&gt;();</span>
<span class="line-added">247         final AtomicLong expectedSum = new AtomicLong(0);</span>
<span class="line-added">248         final Action[] tasks = {</span>
<span class="line-added">249             // repeatedly increment values using compute()</span>
<span class="line-added">250             () -&gt; {</span>
<span class="line-added">251                 long[] invocations = new long[2];</span>
<span class="line-added">252                 ThreadLocalRandom rnd = ThreadLocalRandom.current();</span>
<span class="line-added">253                 BiFunction&lt;Object, Object, Object&gt; incValue = (k, v) -&gt; {</span>
<span class="line-added">254                     invocations[1]++;</span>
<span class="line-added">255                     int vi = (v == null) ? 1 : impl.valueToInt(v) + 1;</span>
<span class="line-added">256                     return impl.makeValue(vi);</span>
<span class="line-added">257                 };</span>
<span class="line-added">258                 while (!done.getAcquire()) {</span>
<span class="line-added">259                     invocations[0]++;</span>
<span class="line-added">260                     Object key = impl.makeKey(3 * rnd.nextInt(10));</span>
<span class="line-added">261                     map.compute(key, incValue);</span>
<span class="line-added">262                 }</span>
<span class="line-added">263                 if (remappingFunctionCalledAtMostOnce)</span>
<span class="line-added">264                     assertEquals(invocations[0], invocations[1]);</span>
<span class="line-added">265                 expectedSum.getAndAdd(invocations[0]);</span>
<span class="line-added">266             },</span>
<span class="line-added">267             // repeatedly increment values using computeIfPresent()</span>
<span class="line-added">268             () -&gt; {</span>
<span class="line-added">269                 long[] invocations = new long[2];</span>
<span class="line-added">270                 ThreadLocalRandom rnd = ThreadLocalRandom.current();</span>
<span class="line-added">271                 BiFunction&lt;Object, Object, Object&gt; incValue = (k, v) -&gt; {</span>
<span class="line-added">272                     invocations[1]++;</span>
<span class="line-added">273                     int vi = impl.valueToInt(v) + 1;</span>
<span class="line-added">274                     return impl.makeValue(vi);</span>
<span class="line-added">275                 };</span>
<span class="line-added">276                 while (!done.getAcquire()) {</span>
<span class="line-added">277                     Object key = impl.makeKey(3 * rnd.nextInt(10));</span>
<span class="line-added">278                     if (map.computeIfPresent(key, incValue) != null)</span>
<span class="line-added">279                         invocations[0]++;</span>
<span class="line-added">280                 }</span>
<span class="line-added">281                 if (remappingFunctionCalledAtMostOnce)</span>
<span class="line-added">282                     assertEquals(invocations[0], invocations[1]);</span>
<span class="line-added">283                 expectedSum.getAndAdd(invocations[0]);</span>
<span class="line-added">284             },</span>
<span class="line-added">285         };</span>
<span class="line-added">286         for (int i = nTasks; i--&gt; 0; ) {</span>
<span class="line-added">287             Action task = chooseRandomly(tasks);</span>
<span class="line-added">288             futures.add(CompletableFuture.runAsync(checkedRunnable(task)));</span>
<span class="line-added">289         }</span>
<span class="line-added">290         Thread.sleep(testDurationMillis);</span>
<span class="line-added">291         done.setRelease(true);</span>
<span class="line-added">292         for (var future : futures)</span>
<span class="line-added">293             checkTimedGet(future, null);</span>
<span class="line-added">294 </span>
<span class="line-added">295         long sum = map.values().stream().mapToLong(x -&gt; (int) x).sum();</span>
<span class="line-added">296         assertEquals(expectedSum.get(), sum);</span>
<span class="line-added">297     }</span>
<span class="line-added">298 </span>
299 //     public void testFailsIntentionallyForDebugging() {
300 //         fail(impl.klazz().getSimpleName());
301 //     }
302 }
<a name="6" id="anc6"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="6" type="hidden" />
</body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff test/jdk/java/util/concurrent/Executors/PrivilegedCallables.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
<body>
<center><a href="../CyclicBarrier/Basic.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="../FutureTask/BlockingTaskExecutor.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>test/jdk/java/util/concurrent/Executors/PrivilegedCallables.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 53 
 54     @SuppressWarnings(&quot;serial&quot;)
 55     final Throwable[] throwables = {
 56         new Exception() {},
 57         new RuntimeException() {},
 58         new Error() {}
 59     };
 60     Throwable randomThrowable() {
 61         return throwables[rnd.nextInt(throwables.length)];
 62     }
 63     void throwThrowable(Throwable t) throws Exception {
 64         if (t instanceof Error) throw (Error) t;
 65         if (t instanceof RuntimeException) throw (RuntimeException) t;
 66         throw (Exception) t;
 67     }
 68 
 69     //----------------------------------------------------------------
 70     // A Policy class designed to make permissions fiddling very easy.
 71     //----------------------------------------------------------------
 72     static class Policy extends java.security.Policy {


 73         private Permissions perms;
 74 
 75         public void setPermissions(Permission...permissions) {
 76             perms = new Permissions();
 77             for (Permission permission : permissions)
 78                 perms.add(permission);
 79         }
 80 
 81         public Policy() { setPermissions(/* Nothing */); }
 82 
 83         public PermissionCollection getPermissions(CodeSource cs) {
 84             return perms;
 85         }
 86 
 87         public PermissionCollection getPermissions(ProtectionDomain pd) {
 88             return perms;
 89         }
 90 
 91         public boolean implies(ProtectionDomain pd, Permission p) {
<span class="line-modified"> 92             return perms.implies(p);</span>
 93         }
 94 
 95         public void refresh() {}
 96     }
 97 
 98     void test(String[] args) {
 99         testPrivileged();
100 
101         final Policy policy = new Policy();
102         Policy.setPolicy(policy);
103         policy.setPermissions(new RuntimePermission(&quot;getClassLoader&quot;),
104                               new RuntimePermission(&quot;setContextClassLoader&quot;));
105         System.setSecurityManager(new SecurityManager());
106 
107         testPrivileged();
108 
109         policy.setPermissions(/* Nothing */);
110 
111         THROWS(AccessControlException.class,
112                new F() {void f(){ privilegedCallableUsingCurrentClassLoader(realCaller); }},
</pre>
</td>
<td>
<hr />
<pre>
 53 
 54     @SuppressWarnings(&quot;serial&quot;)
 55     final Throwable[] throwables = {
 56         new Exception() {},
 57         new RuntimeException() {},
 58         new Error() {}
 59     };
 60     Throwable randomThrowable() {
 61         return throwables[rnd.nextInt(throwables.length)];
 62     }
 63     void throwThrowable(Throwable t) throws Exception {
 64         if (t instanceof Error) throw (Error) t;
 65         if (t instanceof RuntimeException) throw (RuntimeException) t;
 66         throw (Exception) t;
 67     }
 68 
 69     //----------------------------------------------------------------
 70     // A Policy class designed to make permissions fiddling very easy.
 71     //----------------------------------------------------------------
 72     static class Policy extends java.security.Policy {
<span class="line-added"> 73         static final java.security.Policy DEFAULT_POLICY = java.security.Policy.getPolicy();</span>
<span class="line-added"> 74 </span>
 75         private Permissions perms;
 76 
 77         public void setPermissions(Permission...permissions) {
 78             perms = new Permissions();
 79             for (Permission permission : permissions)
 80                 perms.add(permission);
 81         }
 82 
 83         public Policy() { setPermissions(/* Nothing */); }
 84 
 85         public PermissionCollection getPermissions(CodeSource cs) {
 86             return perms;
 87         }
 88 
 89         public PermissionCollection getPermissions(ProtectionDomain pd) {
 90             return perms;
 91         }
 92 
 93         public boolean implies(ProtectionDomain pd, Permission p) {
<span class="line-modified"> 94             return perms.implies(p) || DEFAULT_POLICY.implies(pd, p);</span>
 95         }
 96 
 97         public void refresh() {}
 98     }
 99 
100     void test(String[] args) {
101         testPrivileged();
102 
103         final Policy policy = new Policy();
104         Policy.setPolicy(policy);
105         policy.setPermissions(new RuntimePermission(&quot;getClassLoader&quot;),
106                               new RuntimePermission(&quot;setContextClassLoader&quot;));
107         System.setSecurityManager(new SecurityManager());
108 
109         testPrivileged();
110 
111         policy.setPermissions(/* Nothing */);
112 
113         THROWS(AccessControlException.class,
114                new F() {void f(){ privilegedCallableUsingCurrentClassLoader(realCaller); }},
</pre>
</td>
</tr>
</table>
<center><a href="../CyclicBarrier/Basic.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="../FutureTask/BlockingTaskExecutor.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old test/jdk/java/util/concurrent/locks/Lock/FlakyMutex.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2006, 2013, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 /*
 25  * @test
 26  * @bug 6503247 6574123
 27  * @summary Test resilience to tryAcquire methods that throw
 28  * @author Martin Buchholz
 29  */
 30 
 31 import java.util.concurrent.ThreadLocalRandom;
 32 import java.util.concurrent.CyclicBarrier;
 33 import java.util.concurrent.ExecutorService;
 34 import java.util.concurrent.Executors;
 35 import java.util.concurrent.TimeUnit;
 36 import java.util.concurrent.locks.AbstractQueuedLongSynchronizer;
 37 import java.util.concurrent.locks.Condition;
 38 import java.util.concurrent.locks.Lock;
 39 
 40 /**
 41  * This uses a variant of the standard Mutex demo, except with a
 42  * tryAcquire method that randomly throws various Throwable
 43  * subclasses.
 44  */
 45 @SuppressWarnings(&quot;serial&quot;)
 46 public class FlakyMutex implements Lock {
 47     static class MyError extends Error {}
 48     static class MyException extends Exception {}
 49     static class MyRuntimeException extends RuntimeException {}
 50 
 51     static void checkThrowable(Throwable t) {
 52         check((t instanceof MyError) ||
 53               (t instanceof MyException) ||
 54               (t instanceof MyRuntimeException));
 55     }
 56 
 57     static void realMain(String[] args) throws Throwable {
 58         final int nThreads = 3;
 59         final int iterations = 10_000;
 60         final CyclicBarrier startingGate = new CyclicBarrier(nThreads);
 61         final FlakyMutex mutex = new FlakyMutex();
 62         final ExecutorService es = Executors.newFixedThreadPool(nThreads);
 63         final Runnable task = () -&gt; {
 64             try {
 65                 startingGate.await();
 66                 for (int i = 0; i &lt; iterations; i++) {
 67                     for (;;) {
 68                         try { mutex.lock(); break; }
 69                         catch (Throwable t) { checkThrowable(t); }
 70                     }
 71 
 72                     try { check(! mutex.tryLock()); }
 73                     catch (Throwable t) { checkThrowable(t); }
 74 
 75                     try { check(! mutex.tryLock(1, TimeUnit.MICROSECONDS)); }
 76                     catch (Throwable t) { checkThrowable(t); }
 77 
 78                     mutex.unlock();
 79                 }
 80             } catch (Throwable t) { unexpected(t); }
 81         };
 82 
 83         for (int i = 0; i &lt; nThreads; i++)
 84             es.submit(task);
 85         es.shutdown();
 86         // Let test harness handle timeout
 87         check(es.awaitTermination(Long.MAX_VALUE, TimeUnit.DAYS));
 88     }
 89 
 90     private static class FlakySync extends AbstractQueuedLongSynchronizer {
 91         private static final long serialVersionUID = -1L;
 92 
 93         public boolean isHeldExclusively() { return getState() == 1; }
 94 
 95         public boolean tryAcquire(long acquires) {
 96             // Sneak in some tests for queue state
 97             if (hasQueuedPredecessors())
 98                 check(getFirstQueuedThread() != Thread.currentThread());
 99             if (getFirstQueuedThread() == Thread.currentThread()) {
100                 check(hasQueuedThreads());
101                 check(!hasQueuedPredecessors());
102             } else {
103                 // Might be true, but only transiently
104                 do {} while (hasQueuedPredecessors() != hasQueuedThreads());
105             }
106 
107             switch (ThreadLocalRandom.current().nextInt(10)) {
108             case 0: throw new MyError();
109             case 1: throw new MyRuntimeException();
110             case 2: FlakyMutex.&lt;RuntimeException&gt;uncheckedThrow(new MyException());
111                 // fall through ... NOT!
112             default: return compareAndSetState(0, 1);
113             }
114         }
115 
116         public boolean tryRelease(long releases) {
117             setState(0);
118             return true;
119         }
120 
121         Condition newCondition() { return new ConditionObject(); }
122     }
123 
124     private final FlakySync sync = new FlakySync();
125     public void lock() { sync.acquire(1); }
126     public boolean tryLock() { return sync.tryAcquire(1); }
127     public void lockInterruptibly() throws InterruptedException {
128         sync.acquireInterruptibly(1);
129     }
130     public boolean tryLock(long timeout, TimeUnit unit) throws InterruptedException {
131         return sync.tryAcquireNanos(1, unit.toNanos(timeout));
132     }
133     public void unlock() { sync.release(1); }
134     public Condition newCondition()   { return sync.newCondition(); }
135     public boolean isLocked()         { return sync.isHeldExclusively(); }
136     public boolean hasQueuedThreads() { return sync.hasQueuedThreads(); }
137 
138     //--------------------- Infrastructure ---------------------------
139     static volatile int passed = 0, failed = 0;
140     static void pass() {passed++;}
141     static void fail() {failed++; Thread.dumpStack();}
142     static void fail(String msg) {System.out.println(msg); fail();}
143     static void unexpected(Throwable t) {failed++; t.printStackTrace();}
144     static void check(boolean cond) {if (cond) pass(); else fail();}
145     static void equal(Object x, Object y) {
146         if (x == null ? y == null : x.equals(y)) pass();
147         else fail(x + &quot; not equal to &quot; + y);}
148     public static void main(String[] args) throws Throwable {
149         try {realMain(args);} catch (Throwable t) {unexpected(t);}
150         System.out.printf(&quot;%nPassed = %d, failed = %d%n%n&quot;, passed, failed);
151         if (failed &gt; 0) throw new AssertionError(&quot;Some tests failed&quot;);}
152     @SuppressWarnings(&quot;unchecked&quot;)
153     static &lt;T extends Throwable&gt; void uncheckedThrow(Throwable t) throws T {
154         throw (T)t; // rely on vacuous cast
155     }
156 }
    </pre>
  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New test/jdk/java/util/concurrent/tck/DelayQueueTest.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  3  *
  4  * This code is free software; you can redistribute it and/or modify it
  5  * under the terms of the GNU General Public License version 2 only, as
  6  * published by the Free Software Foundation.
  7  *
  8  * This code is distributed in the hope that it will be useful, but WITHOUT
  9  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 10  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 11  * version 2 for more details (a copy is included in the LICENSE file that
 12  * accompanied this code).
 13  *
 14  * You should have received a copy of the GNU General Public License version
 15  * 2 along with this work; if not, write to the Free Software Foundation,
 16  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 17  *
 18  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 19  * or visit www.oracle.com if you need additional information or have any
 20  * questions.
 21  */
 22 
 23 /*
 24  * This file is available under and governed by the GNU General Public
 25  * License version 2 only, as published by the Free Software Foundation.
 26  * However, the following notice accompanied the original version of this
 27  * file:
 28  *
 29  * Written by Doug Lea with assistance from members of JCP JSR-166
 30  * Expert Group and released to the public domain, as explained at
 31  * http://creativecommons.org/publicdomain/zero/1.0/
 32  * Other contributors include Andrew Wright, Jeffrey Hayes,
 33  * Pat Fisher, Mike Judd.
 34  */
 35 
 36 import static java.util.concurrent.TimeUnit.MILLISECONDS;
 37 
 38 import java.util.ArrayList;
 39 import java.util.Arrays;
 40 import java.util.Collection;
 41 import java.util.Iterator;
 42 import java.util.NoSuchElementException;
 43 import java.util.concurrent.BlockingQueue;
 44 import java.util.concurrent.CountDownLatch;
 45 import java.util.concurrent.Delayed;
 46 import java.util.concurrent.DelayQueue;
 47 import java.util.concurrent.Executors;
 48 import java.util.concurrent.ExecutorService;
 49 import java.util.concurrent.TimeUnit;
 50 
 51 import junit.framework.Test;
 52 
 53 public class DelayQueueTest extends JSR166TestCase {
 54 
 55     public static class Generic extends BlockingQueueTest {
 56         protected BlockingQueue emptyCollection() {
 57             return new DelayQueue();
 58         }
 59         protected PDelay makeElement(int i) {
 60             return new PDelay(i);
 61         }
 62     }
 63 
 64     public static void main(String[] args) {
 65         main(suite(), args);
 66     }
 67 
 68     public static Test suite() {
 69         class Implementation implements CollectionImplementation {
 70             public Class&lt;?&gt; klazz() { return DelayQueue.class; }
 71             public Collection emptyCollection() { return new DelayQueue(); }
 72             public Object makeElement(int i) { return new PDelay(i); }
 73             public boolean isConcurrent() { return true; }
 74             public boolean permitsNulls() { return false; }
 75         }
 76         return newTestSuite(DelayQueueTest.class,
 77                             new Generic().testSuite(),
 78                             CollectionTest.testSuite(new Implementation()));
 79     }
 80 
 81     /**
 82      * A fake Delayed implementation for testing.
 83      * Most tests use PDelays, where delays are all elapsed
 84      * (so, no blocking solely for delays) but are still ordered
 85      */
 86     static class PDelay implements Delayed {
 87         final int pseudodelay;
 88         PDelay(int pseudodelay) { this.pseudodelay = pseudodelay; }
 89         public int compareTo(Delayed y) {
 90             return Integer.compare(this.pseudodelay, ((PDelay)y).pseudodelay);
 91         }
 92         public boolean equals(Object other) {
 93             return (other instanceof PDelay) &amp;&amp;
 94                 this.pseudodelay == ((PDelay)other).pseudodelay;
 95         }
 96         // suppress [overrides] javac warning
 97         public int hashCode() { return pseudodelay; }
 98         public long getDelay(TimeUnit ignore) {
 99             return (long) Integer.MIN_VALUE + pseudodelay;
100         }
101         public String toString() {
102             return String.valueOf(pseudodelay);
103         }
104     }
105 
106     /**
107      * Delayed implementation that actually delays
108      */
109     static class NanoDelay implements Delayed {
110         final long trigger;
111         NanoDelay(long i) {
112             trigger = System.nanoTime() + i;
113         }
114 
115         public int compareTo(Delayed y) {
116             return Long.compare(trigger, ((NanoDelay)y).trigger);
117         }
118 
119         public boolean equals(Object other) {
120             return (other instanceof NanoDelay) &amp;&amp;
121                 this.trigger == ((NanoDelay)other).trigger;
122         }
123 
124         // suppress [overrides] javac warning
125         public int hashCode() { return (int) trigger; }
126 
127         public long getDelay(TimeUnit unit) {
128             long n = trigger - System.nanoTime();
129             return unit.convert(n, TimeUnit.NANOSECONDS);
130         }
131 
132         public long getTriggerTime() {
133             return trigger;
134         }
135 
136         public String toString() {
137             return String.valueOf(trigger);
138         }
139     }
140 
141     /**
142      * Returns a new queue of given size containing consecutive
143      * PDelays 0 ... n - 1.
144      */
145     private static DelayQueue&lt;PDelay&gt; populatedQueue(int n) {
146         DelayQueue&lt;PDelay&gt; q = new DelayQueue&lt;&gt;();
147         assertTrue(q.isEmpty());
148         for (int i = n - 1; i &gt;= 0; i -= 2)
149             assertTrue(q.offer(new PDelay(i)));
150         for (int i = (n &amp; 1); i &lt; n; i += 2)
151             assertTrue(q.offer(new PDelay(i)));
152         assertFalse(q.isEmpty());
153         assertEquals(Integer.MAX_VALUE, q.remainingCapacity());
154         assertEquals(n, q.size());
155         assertEquals(new PDelay(0), q.peek());
156         return q;
157     }
158 
159     /**
160      * A new queue has unbounded capacity
161      */
162     public void testConstructor1() {
163         assertEquals(Integer.MAX_VALUE, new DelayQueue().remainingCapacity());
164     }
165 
166     /**
167      * Initializing from null Collection throws NPE
168      */
169     public void testConstructor3() {
170         try {
171             new DelayQueue(null);
172             shouldThrow();
173         } catch (NullPointerException success) {}
174     }
175 
176     /**
177      * Initializing from Collection of null elements throws NPE
178      */
179     public void testConstructor4() {
180         try {
181             new DelayQueue(Arrays.asList(new PDelay[SIZE]));
182             shouldThrow();
183         } catch (NullPointerException success) {}
184     }
185 
186     /**
187      * Initializing from Collection with some null elements throws NPE
188      */
189     public void testConstructor5() {
190         PDelay[] a = new PDelay[SIZE];
191         for (int i = 0; i &lt; SIZE - 1; ++i)
192             a[i] = new PDelay(i);
193         try {
194             new DelayQueue(Arrays.asList(a));
195             shouldThrow();
196         } catch (NullPointerException success) {}
197     }
198 
199     /**
200      * Queue contains all elements of collection used to initialize
201      */
202     public void testConstructor6() {
203         PDelay[] ints = new PDelay[SIZE];
204         for (int i = 0; i &lt; SIZE; ++i)
205             ints[i] = new PDelay(i);
206         DelayQueue q = new DelayQueue(Arrays.asList(ints));
207         for (int i = 0; i &lt; SIZE; ++i)
208             assertEquals(ints[i], q.poll());
209     }
210 
211     /**
212      * isEmpty is true before add, false after
213      */
214     public void testEmpty() {
215         DelayQueue q = new DelayQueue();
216         assertTrue(q.isEmpty());
217         assertEquals(Integer.MAX_VALUE, q.remainingCapacity());
218         q.add(new PDelay(1));
219         assertFalse(q.isEmpty());
220         q.add(new PDelay(2));
221         q.remove();
222         q.remove();
223         assertTrue(q.isEmpty());
224     }
225 
226     /**
227      * remainingCapacity() always returns Integer.MAX_VALUE
228      */
229     public void testRemainingCapacity() {
230         BlockingQueue q = populatedQueue(SIZE);
231         for (int i = 0; i &lt; SIZE; ++i) {
232             assertEquals(Integer.MAX_VALUE, q.remainingCapacity());
233             assertEquals(SIZE - i, q.size());
234             assertTrue(q.remove() instanceof PDelay);
235         }
236         for (int i = 0; i &lt; SIZE; ++i) {
237             assertEquals(Integer.MAX_VALUE, q.remainingCapacity());
238             assertEquals(i, q.size());
239             assertTrue(q.add(new PDelay(i)));
240         }
241     }
242 
243     /**
244      * offer non-null succeeds
245      */
246     public void testOffer() {
247         DelayQueue q = new DelayQueue();
248         assertTrue(q.offer(new PDelay(0)));
249         assertTrue(q.offer(new PDelay(1)));
250     }
251 
252     /**
253      * add succeeds
254      */
255     public void testAdd() {
256         DelayQueue q = new DelayQueue();
257         for (int i = 0; i &lt; SIZE; ++i) {
258             assertEquals(i, q.size());
259             assertTrue(q.add(new PDelay(i)));
260         }
261     }
262 
263     /**
264      * addAll(this) throws IllegalArgumentException
265      */
266     public void testAddAllSelf() {
267         DelayQueue q = populatedQueue(SIZE);
268         try {
269             q.addAll(q);
270             shouldThrow();
271         } catch (IllegalArgumentException success) {}
272     }
273 
274     /**
275      * addAll of a collection with any null elements throws NPE after
276      * possibly adding some elements
277      */
278     public void testAddAll3() {
279         DelayQueue q = new DelayQueue();
280         PDelay[] a = new PDelay[SIZE];
281         for (int i = 0; i &lt; SIZE - 1; ++i)
282             a[i] = new PDelay(i);
283         try {
284             q.addAll(Arrays.asList(a));
285             shouldThrow();
286         } catch (NullPointerException success) {}
287     }
288 
289     /**
290      * Queue contains all elements of successful addAll
291      */
292     public void testAddAll5() {
293         PDelay[] empty = new PDelay[0];
294         PDelay[] ints = new PDelay[SIZE];
295         for (int i = SIZE - 1; i &gt;= 0; --i)
296             ints[i] = new PDelay(i);
297         DelayQueue q = new DelayQueue();
298         assertFalse(q.addAll(Arrays.asList(empty)));
299         assertTrue(q.addAll(Arrays.asList(ints)));
300         for (int i = 0; i &lt; SIZE; ++i)
301             assertEquals(ints[i], q.poll());
302     }
303 
304     /**
305      * all elements successfully put are contained
306      */
307     public void testPut() {
308         DelayQueue q = new DelayQueue();
309         for (int i = 0; i &lt; SIZE; ++i) {
310             PDelay x = new PDelay(i);
311             q.put(x);
312             assertTrue(q.contains(x));
313         }
314         assertEquals(SIZE, q.size());
315     }
316 
317     /**
318      * put doesn&#39;t block waiting for take
319      */
320     public void testPutWithTake() throws InterruptedException {
321         final DelayQueue q = new DelayQueue();
322         Thread t = newStartedThread(new CheckedRunnable() {
323             public void realRun() {
324                 q.put(new PDelay(0));
325                 q.put(new PDelay(0));
326                 q.put(new PDelay(0));
327                 q.put(new PDelay(0));
328             }});
329 
330         awaitTermination(t);
331         assertEquals(4, q.size());
332     }
333 
334     /**
335      * Queue is unbounded, so timed offer never times out
336      */
337     public void testTimedOffer() throws InterruptedException {
338         final DelayQueue q = new DelayQueue();
339         Thread t = newStartedThread(new CheckedRunnable() {
340             public void realRun() throws InterruptedException {
341                 q.put(new PDelay(0));
342                 q.put(new PDelay(0));
343                 assertTrue(q.offer(new PDelay(0), SHORT_DELAY_MS, MILLISECONDS));
344                 assertTrue(q.offer(new PDelay(0), LONG_DELAY_MS, MILLISECONDS));
345             }});
346 
347         awaitTermination(t);
348     }
349 
350     /**
351      * take retrieves elements in priority order
352      */
353     public void testTake() throws InterruptedException {
354         DelayQueue q = populatedQueue(SIZE);
355         for (int i = 0; i &lt; SIZE; ++i) {
356             assertEquals(new PDelay(i), q.take());
357         }
358     }
359 
360     /**
361      * Take removes existing elements until empty, then blocks interruptibly
362      */
363     public void testBlockingTake() throws InterruptedException {
364         final DelayQueue q = populatedQueue(SIZE);
365         final CountDownLatch pleaseInterrupt = new CountDownLatch(1);
366         Thread t = newStartedThread(new CheckedRunnable() {
367             public void realRun() throws InterruptedException {
368                 for (int i = 0; i &lt; SIZE; i++)
369                     assertEquals(new PDelay(i), ((PDelay)q.take()));
370 
371                 Thread.currentThread().interrupt();
372                 try {
373                     q.take();
374                     shouldThrow();
375                 } catch (InterruptedException success) {}
376                 assertFalse(Thread.interrupted());
377 
378                 pleaseInterrupt.countDown();
379                 try {
380                     q.take();
381                     shouldThrow();
382                 } catch (InterruptedException success) {}
383                 assertFalse(Thread.interrupted());
384             }});
385 
386         await(pleaseInterrupt);
387         if (randomBoolean()) assertThreadBlocks(t, Thread.State.WAITING);
388         t.interrupt();
389         awaitTermination(t);
390     }
391 
392     /**
393      * poll succeeds unless empty
394      */
395     public void testPoll() {
396         DelayQueue q = populatedQueue(SIZE);
397         for (int i = 0; i &lt; SIZE; ++i) {
398             assertEquals(new PDelay(i), q.poll());
399         }
400         assertNull(q.poll());
401     }
402 
403     /**
404      * timed poll with zero timeout succeeds when non-empty, else times out
405      */
406     public void testTimedPoll0() throws InterruptedException {
407         DelayQueue q = populatedQueue(SIZE);
408         for (int i = 0; i &lt; SIZE; ++i) {
409             assertEquals(new PDelay(i), q.poll(0, MILLISECONDS));
410         }
411         assertNull(q.poll(0, MILLISECONDS));
412     }
413 
414     /**
415      * timed poll with nonzero timeout succeeds when non-empty, else times out
416      */
417     public void testTimedPoll() throws InterruptedException {
418         DelayQueue q = populatedQueue(SIZE);
419         for (int i = 0; i &lt; SIZE; ++i) {
420             long startTime = System.nanoTime();
421             assertEquals(new PDelay(i), q.poll(LONG_DELAY_MS, MILLISECONDS));
422             assertTrue(millisElapsedSince(startTime) &lt; LONG_DELAY_MS);
423         }
424         long startTime = System.nanoTime();
425         assertNull(q.poll(timeoutMillis(), MILLISECONDS));
426         assertTrue(millisElapsedSince(startTime) &gt;= timeoutMillis());
427         checkEmpty(q);
428     }
429 
430     /**
431      * Interrupted timed poll throws InterruptedException instead of
432      * returning timeout status
433      */
434     public void testInterruptedTimedPoll() throws InterruptedException {
435         final CountDownLatch pleaseInterrupt = new CountDownLatch(1);
436         final DelayQueue q = populatedQueue(SIZE);
437         Thread t = newStartedThread(new CheckedRunnable() {
438             public void realRun() throws InterruptedException {
439                 for (int i = 0; i &lt; SIZE; i++)
440                     assertEquals(new PDelay(i),
441                                  ((PDelay)q.poll(LONG_DELAY_MS, MILLISECONDS)));
442 
443                 Thread.currentThread().interrupt();
444                 try {
445                     q.poll(randomTimeout(), randomTimeUnit());
446                     shouldThrow();
447                 } catch (InterruptedException success) {}
448                 assertFalse(Thread.interrupted());
449 
450                 pleaseInterrupt.countDown();
451                 try {
452                     q.poll(LONGER_DELAY_MS, MILLISECONDS);
453                     shouldThrow();
454                 } catch (InterruptedException success) {}
455                 assertFalse(Thread.interrupted());
456             }});
457 
458         await(pleaseInterrupt);
459         if (randomBoolean()) assertThreadBlocks(t, Thread.State.TIMED_WAITING);
460         t.interrupt();
461         awaitTermination(t);
462         checkEmpty(q);
463     }
464 
465     /**
466      * peek returns next element, or null if empty
467      */
468     public void testPeek() {
469         DelayQueue q = populatedQueue(SIZE);
470         for (int i = 0; i &lt; SIZE; ++i) {
471             assertEquals(new PDelay(i), q.peek());
472             assertEquals(new PDelay(i), q.poll());
473             if (q.isEmpty())
474                 assertNull(q.peek());
475             else
476                 assertFalse(new PDelay(i).equals(q.peek()));
477         }
478         assertNull(q.peek());
479     }
480 
481     /**
482      * element returns next element, or throws NSEE if empty
483      */
484     public void testElement() {
485         DelayQueue q = populatedQueue(SIZE);
486         for (int i = 0; i &lt; SIZE; ++i) {
487             assertEquals(new PDelay(i), q.element());
488             q.poll();
489         }
490         try {
491             q.element();
492             shouldThrow();
493         } catch (NoSuchElementException success) {}
494     }
495 
496     /**
497      * remove removes next element, or throws NSEE if empty
498      */
499     public void testRemove() {
500         DelayQueue q = populatedQueue(SIZE);
501         for (int i = 0; i &lt; SIZE; ++i) {
502             assertEquals(new PDelay(i), q.remove());
503         }
504         try {
505             q.remove();
506             shouldThrow();
507         } catch (NoSuchElementException success) {}
508     }
509 
510     /**
511      * contains(x) reports true when elements added but not yet removed
512      */
513     public void testContains() {
514         DelayQueue q = populatedQueue(SIZE);
515         for (int i = 0; i &lt; SIZE; ++i) {
516             assertTrue(q.contains(new PDelay(i)));
517             q.poll();
518             assertFalse(q.contains(new PDelay(i)));
519         }
520     }
521 
522     /**
523      * clear removes all elements
524      */
525     public void testClear() {
526         DelayQueue q = populatedQueue(SIZE);
527         q.clear();
528         assertTrue(q.isEmpty());
529         assertEquals(0, q.size());
530         assertEquals(Integer.MAX_VALUE, q.remainingCapacity());
531         PDelay x = new PDelay(1);
532         q.add(x);
533         assertFalse(q.isEmpty());
534         assertTrue(q.contains(x));
535         q.clear();
536         assertTrue(q.isEmpty());
537     }
538 
539     /**
540      * containsAll(c) is true when c contains a subset of elements
541      */
542     public void testContainsAll() {
543         DelayQueue q = populatedQueue(SIZE);
544         DelayQueue p = new DelayQueue();
545         for (int i = 0; i &lt; SIZE; ++i) {
546             assertTrue(q.containsAll(p));
547             assertFalse(p.containsAll(q));
548             p.add(new PDelay(i));
549         }
550         assertTrue(p.containsAll(q));
551     }
552 
553     /**
554      * retainAll(c) retains only those elements of c and reports true if changed
555      */
556     public void testRetainAll() {
557         DelayQueue q = populatedQueue(SIZE);
558         DelayQueue p = populatedQueue(SIZE);
559         for (int i = 0; i &lt; SIZE; ++i) {
560             boolean changed = q.retainAll(p);
561             if (i == 0)
562                 assertFalse(changed);
563             else
564                 assertTrue(changed);
565 
566             assertTrue(q.containsAll(p));
567             assertEquals(SIZE - i, q.size());
568             p.remove();
569         }
570     }
571 
572     /**
573      * removeAll(c) removes only those elements of c and reports true if changed
574      */
575     public void testRemoveAll() {
576         for (int i = 1; i &lt; SIZE; ++i) {
577             DelayQueue q = populatedQueue(SIZE);
578             DelayQueue p = populatedQueue(i);
579             assertTrue(q.removeAll(p));
580             assertEquals(SIZE - i, q.size());
581             for (int j = 0; j &lt; i; ++j) {
582                 PDelay x = (PDelay)(p.remove());
583                 assertFalse(q.contains(x));
584             }
585         }
586     }
587 
588     /**
589      * toArray contains all elements
590      */
591     public void testToArray() throws InterruptedException {
592         DelayQueue q = populatedQueue(SIZE);
593         Object[] a = q.toArray();
594         assertSame(Object[].class, a.getClass());
595         Arrays.sort(a);
596         for (Object o : a)
597             assertSame(o, q.take());
598         assertTrue(q.isEmpty());
599     }
600 
601     /**
602      * toArray(a) contains all elements
603      */
604     public void testToArray2() {
605         DelayQueue&lt;PDelay&gt; q = populatedQueue(SIZE);
606         PDelay[] ints = new PDelay[SIZE];
607         PDelay[] array = q.toArray(ints);
608         assertSame(ints, array);
609         Arrays.sort(ints);
610         for (PDelay o : ints)
611             assertSame(o, q.remove());
612         assertTrue(q.isEmpty());
613     }
614 
615     /**
616      * toArray(incompatible array type) throws ArrayStoreException
617      */
618     public void testToArray1_BadArg() {
619         DelayQueue q = populatedQueue(SIZE);
620         try {
621             q.toArray(new String[10]);
622             shouldThrow();
623         } catch (ArrayStoreException success) {}
624     }
625 
626     /**
627      * iterator iterates through all elements
628      */
629     public void testIterator() {
630         DelayQueue q = populatedQueue(SIZE);
631         int i = 0;
632         Iterator it = q.iterator();
633         while (it.hasNext()) {
634             assertTrue(q.contains(it.next()));
635             ++i;
636         }
637         assertEquals(i, SIZE);
638         assertIteratorExhausted(it);
639     }
640 
641     /**
642      * iterator of empty collection has no elements
643      */
644     public void testEmptyIterator() {
645         assertIteratorExhausted(new DelayQueue().iterator());
646     }
647 
648     /**
649      * iterator.remove removes current element
650      */
651     public void testIteratorRemove() {
652         final DelayQueue q = new DelayQueue();
653         q.add(new PDelay(2));
654         q.add(new PDelay(1));
655         q.add(new PDelay(3));
656         Iterator it = q.iterator();
657         it.next();
658         it.remove();
659         it = q.iterator();
660         assertEquals(new PDelay(2), it.next());
661         assertEquals(new PDelay(3), it.next());
662         assertFalse(it.hasNext());
663     }
664 
665     /**
666      * toString contains toStrings of elements
667      */
668     public void testToString() {
669         DelayQueue q = populatedQueue(SIZE);
670         String s = q.toString();
671         for (Object e : q)
672             assertTrue(s.contains(e.toString()));
673     }
674 
675     /**
676      * timed poll transfers elements across Executor tasks
677      */
678     public void testPollInExecutor() {
679         final DelayQueue q = new DelayQueue();
680         final CheckedBarrier threadsStarted = new CheckedBarrier(2);
681         final ExecutorService executor = Executors.newFixedThreadPool(2);
682         try (PoolCleaner cleaner = cleaner(executor)) {
683             executor.execute(new CheckedRunnable() {
684                 public void realRun() throws InterruptedException {
685                     assertNull(q.poll());
686                     threadsStarted.await();
687                     assertNotNull(q.poll(LONG_DELAY_MS, MILLISECONDS));
688                     checkEmpty(q);
689                 }});
690 
691             executor.execute(new CheckedRunnable() {
692                 public void realRun() throws InterruptedException {
693                     threadsStarted.await();
694                     q.put(new PDelay(1));
695                 }});
696         }
697     }
698 
699     /**
700      * Delayed actions do not occur until their delay elapses
701      */
702     public void testDelay() throws InterruptedException {
703         DelayQueue&lt;NanoDelay&gt; q = new DelayQueue&lt;&gt;();
704         for (int i = 0; i &lt; SIZE; ++i)
705             q.add(new NanoDelay(1000000L * (SIZE - i)));
706 
707         long last = 0;
708         for (int i = 0; i &lt; SIZE; ++i) {
709             NanoDelay e = q.take();
710             long tt = e.getTriggerTime();
711             assertTrue(System.nanoTime() - tt &gt;= 0);
712             if (i != 0)
713                 assertTrue(tt &gt;= last);
714             last = tt;
715         }
716         assertTrue(q.isEmpty());
717     }
718 
719     /**
720      * peek of a non-empty queue returns non-null even if not expired
721      */
722     public void testPeekDelayed() {
723         DelayQueue q = new DelayQueue();
724         q.add(new NanoDelay(Long.MAX_VALUE));
725         assertNotNull(q.peek());
726     }
727 
728     /**
729      * poll of a non-empty queue returns null if no expired elements.
730      */
731     public void testPollDelayed() {
732         DelayQueue q = new DelayQueue();
733         q.add(new NanoDelay(Long.MAX_VALUE));
734         assertNull(q.poll());
735     }
736 
737     /**
738      * timed poll of a non-empty queue returns null if no expired elements.
739      */
740     public void testTimedPollDelayed() throws InterruptedException {
741         DelayQueue q = new DelayQueue();
742         q.add(new NanoDelay(LONG_DELAY_MS * 1000000L));
743         long startTime = System.nanoTime();
744         assertNull(q.poll(timeoutMillis(), MILLISECONDS));
745         assertTrue(millisElapsedSince(startTime) &gt;= timeoutMillis());
746     }
747 
748     /**
749      * drainTo(c) empties queue into another collection c
750      */
751     public void testDrainTo() {
752         DelayQueue q = new DelayQueue();
753         PDelay[] elems = new PDelay[SIZE];
754         for (int i = 0; i &lt; SIZE; ++i) {
755             elems[i] = new PDelay(i);
756             q.add(elems[i]);
757         }
758         ArrayList l = new ArrayList();
759         q.drainTo(l);
760         assertEquals(0, q.size());
761         for (int i = 0; i &lt; SIZE; ++i)
762             assertEquals(elems[i], l.get(i));
763         q.add(elems[0]);
764         q.add(elems[1]);
765         assertFalse(q.isEmpty());
766         assertTrue(q.contains(elems[0]));
767         assertTrue(q.contains(elems[1]));
768         l.clear();
769         q.drainTo(l);
770         assertEquals(0, q.size());
771         assertEquals(2, l.size());
772         for (int i = 0; i &lt; 2; ++i)
773             assertEquals(elems[i], l.get(i));
774     }
775 
776     /**
777      * drainTo empties queue
778      */
779     public void testDrainToWithActivePut() throws InterruptedException {
780         final DelayQueue q = populatedQueue(SIZE);
781         Thread t = new Thread(new CheckedRunnable() {
782             public void realRun() {
783                 q.put(new PDelay(SIZE + 1));
784             }});
785 
786         t.start();
787         ArrayList l = new ArrayList();
788         q.drainTo(l);
789         assertTrue(l.size() &gt;= SIZE);
790         t.join();
791         assertTrue(q.size() + l.size() &gt;= SIZE);
792     }
793 
794     /**
795      * drainTo(c, n) empties first min(n, size) elements of queue into c
796      */
797     public void testDrainToN() {
798         for (int i = 0; i &lt; SIZE + 2; ++i) {
799             DelayQueue q = populatedQueue(SIZE);
800             ArrayList l = new ArrayList();
801             q.drainTo(l, i);
802             int k = (i &lt; SIZE) ? i : SIZE;
803             assertEquals(SIZE - k, q.size());
804             assertEquals(k, l.size());
805         }
806     }
807 
808     /**
809      * remove(null), contains(null) always return false
810      */
811     public void testNeverContainsNull() {
812         Collection&lt;?&gt; q = populatedQueue(SIZE);
813         assertFalse(q.contains(null));
814         assertFalse(q.remove(null));
815     }
816 }
    </pre>
  </body>
</html>
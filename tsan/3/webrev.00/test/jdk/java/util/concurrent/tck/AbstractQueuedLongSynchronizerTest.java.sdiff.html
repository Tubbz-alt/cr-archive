<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff test/jdk/java/util/concurrent/tck/AbstractQueuedLongSynchronizerTest.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
<body>
<center><a href="../locks/ReentrantReadWriteLock/MapLoops.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="AbstractQueuedSynchronizerTest.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>test/jdk/java/util/concurrent/tck/AbstractQueuedLongSynchronizerTest.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  22 
  23 /*
  24  * This file is available under and governed by the GNU General Public
  25  * License version 2 only, as published by the Free Software Foundation.
  26  * However, the following notice accompanied the original version of this
  27  * file:
  28  *
  29  * Written by Doug Lea with assistance from members of JCP JSR-166
  30  * Expert Group and released to the public domain, as explained at
  31  * http://creativecommons.org/publicdomain/zero/1.0/
  32  * Other contributors include Andrew Wright, Jeffrey Hayes,
  33  * Pat Fisher, Mike Judd.
  34  */
  35 
  36 import static java.util.concurrent.TimeUnit.MILLISECONDS;
  37 import static java.util.concurrent.TimeUnit.NANOSECONDS;
  38 
  39 import java.util.Arrays;
  40 import java.util.Collection;
  41 import java.util.HashSet;
<span class="line-modified">  42 import java.util.concurrent.ThreadLocalRandom;</span>
  43 import java.util.concurrent.locks.AbstractQueuedLongSynchronizer;
  44 import java.util.concurrent.locks.AbstractQueuedLongSynchronizer.ConditionObject;
  45 
  46 import junit.framework.Test;
  47 import junit.framework.TestSuite;
  48 
  49 @SuppressWarnings(&quot;WaitNotInLoop&quot;) // we implement spurious-wakeup freedom
  50 public class AbstractQueuedLongSynchronizerTest extends JSR166TestCase {
  51     public static void main(String[] args) {
  52         main(suite(), args);
  53     }
  54     public static Test suite() {
  55         return new TestSuite(AbstractQueuedLongSynchronizerTest.class);
  56     }
  57 
  58     /**
  59      * A simple mutex class, adapted from the class javadoc.  Exclusive
  60      * acquire tests exercise this as a sample user extension.
  61      *
  62      * Unlike the javadoc sample, we don&#39;t track owner thread via
</pre>
<hr />
<pre>
1269         assertTrue(c.awaitNanos(0L) &lt;= 0);
1270         assertFalse(c.await(0L, NANOSECONDS));
1271         sync.release();
1272     }
1273 
1274     /**
1275      * awaitNanos/timed await with maximum negative wait times does not underflow
1276      */
1277     public void testAwait_NegativeInfinity() throws InterruptedException {
1278         final Mutex sync = new Mutex();
1279         final ConditionObject c = sync.newCondition();
1280         sync.acquire();
1281         assertTrue(c.awaitNanos(Long.MIN_VALUE) &lt;= 0);
1282         assertFalse(c.await(Long.MIN_VALUE, NANOSECONDS));
1283         sync.release();
1284     }
1285 
1286     /**
1287      * Tests scenario for
1288      * JDK-8191937: Lost interrupt in AbstractQueuedSynchronizer when tryAcquire methods throw

1289      */
<span class="line-modified">1290     public void testInterruptedFailingAcquire() throws InterruptedException {</span>
<span class="line-modified">1291         final RuntimeException ex = new RuntimeException();</span>


1292 
1293         // A synchronizer only offering a choice of failure modes
1294         class Sync extends AbstractQueuedLongSynchronizer {
<span class="line-modified">1295             boolean pleaseThrow;</span>









1296             @Override protected boolean tryAcquire(long ignored) {
<span class="line-modified">1297                 if (pleaseThrow) throw ex;</span>
1298                 return false;
1299             }
1300             @Override protected long tryAcquireShared(long ignored) {
<span class="line-modified">1301                 if (pleaseThrow) throw ex;</span>
1302                 return -1;
1303             }
1304             @Override protected boolean tryRelease(long ignored) {
1305                 return true;
1306             }
1307             @Override protected boolean tryReleaseShared(long ignored) {
1308                 return true;
1309             }
1310         }
1311 
1312         final Sync s = new Sync();
<span class="line-modified">1313 </span>































1314         final Thread thread = newStartedThread(new CheckedRunnable() {
<span class="line-modified">1315             public void realRun() {</span>
1316                 try {
<span class="line-modified">1317                     if (ThreadLocalRandom.current().nextBoolean())</span>
<span class="line-removed">1318                         s.acquire(1);</span>
<span class="line-removed">1319                     else</span>
<span class="line-removed">1320                         s.acquireShared(1);</span>
1321                     shouldThrow();
<span class="line-modified">1322                 } catch (Throwable t) {</span>
<span class="line-modified">1323                     assertSame(ex, t);</span>
<span class="line-modified">1324                     assertTrue(Thread.interrupted());</span>


1325                 }
1326             }});
<span class="line-modified">1327         waitForThreadToEnterWaitState(thread);</span>
<span class="line-modified">1328         assertSame(thread, s.getFirstQueuedThread());</span>
<span class="line-modified">1329         assertTrue(s.hasQueuedPredecessors());</span>
<span class="line-modified">1330         assertTrue(s.hasQueuedThreads());</span>
<span class="line-modified">1331         assertEquals(1, s.getQueueLength());</span>











1332 
1333         s.pleaseThrow = true;
<span class="line-modified">1334         thread.interrupt();</span>
<span class="line-modified">1335         s.release(1);</span>






1336         awaitTermination(thread);










1337     }
1338 
1339 }
</pre>
</td>
<td>
<hr />
<pre>
  22 
  23 /*
  24  * This file is available under and governed by the GNU General Public
  25  * License version 2 only, as published by the Free Software Foundation.
  26  * However, the following notice accompanied the original version of this
  27  * file:
  28  *
  29  * Written by Doug Lea with assistance from members of JCP JSR-166
  30  * Expert Group and released to the public domain, as explained at
  31  * http://creativecommons.org/publicdomain/zero/1.0/
  32  * Other contributors include Andrew Wright, Jeffrey Hayes,
  33  * Pat Fisher, Mike Judd.
  34  */
  35 
  36 import static java.util.concurrent.TimeUnit.MILLISECONDS;
  37 import static java.util.concurrent.TimeUnit.NANOSECONDS;
  38 
  39 import java.util.Arrays;
  40 import java.util.Collection;
  41 import java.util.HashSet;
<span class="line-modified">  42 import java.util.concurrent.atomic.AtomicBoolean;</span>
  43 import java.util.concurrent.locks.AbstractQueuedLongSynchronizer;
  44 import java.util.concurrent.locks.AbstractQueuedLongSynchronizer.ConditionObject;
  45 
  46 import junit.framework.Test;
  47 import junit.framework.TestSuite;
  48 
  49 @SuppressWarnings(&quot;WaitNotInLoop&quot;) // we implement spurious-wakeup freedom
  50 public class AbstractQueuedLongSynchronizerTest extends JSR166TestCase {
  51     public static void main(String[] args) {
  52         main(suite(), args);
  53     }
  54     public static Test suite() {
  55         return new TestSuite(AbstractQueuedLongSynchronizerTest.class);
  56     }
  57 
  58     /**
  59      * A simple mutex class, adapted from the class javadoc.  Exclusive
  60      * acquire tests exercise this as a sample user extension.
  61      *
  62      * Unlike the javadoc sample, we don&#39;t track owner thread via
</pre>
<hr />
<pre>
1269         assertTrue(c.awaitNanos(0L) &lt;= 0);
1270         assertFalse(c.await(0L, NANOSECONDS));
1271         sync.release();
1272     }
1273 
1274     /**
1275      * awaitNanos/timed await with maximum negative wait times does not underflow
1276      */
1277     public void testAwait_NegativeInfinity() throws InterruptedException {
1278         final Mutex sync = new Mutex();
1279         final ConditionObject c = sync.newCondition();
1280         sync.acquire();
1281         assertTrue(c.awaitNanos(Long.MIN_VALUE) &lt;= 0);
1282         assertFalse(c.await(Long.MIN_VALUE, NANOSECONDS));
1283         sync.release();
1284     }
1285 
1286     /**
1287      * Tests scenario for
1288      * JDK-8191937: Lost interrupt in AbstractQueuedSynchronizer when tryAcquire methods throw
<span class="line-added">1289      * ant -Djsr166.tckTestClass=AbstractQueuedLongSynchronizerTest -Djsr166.methodFilter=testInterruptedFailingAcquire -Djsr166.runsPerTest=10000 tck</span>
1290      */
<span class="line-modified">1291     public void testInterruptedFailingAcquire() throws Throwable {</span>
<span class="line-modified">1292         class PleaseThrow extends RuntimeException {}</span>
<span class="line-added">1293         final PleaseThrow ex = new PleaseThrow();</span>
<span class="line-added">1294         final AtomicBoolean thrown = new AtomicBoolean();</span>
1295 
1296         // A synchronizer only offering a choice of failure modes
1297         class Sync extends AbstractQueuedLongSynchronizer {
<span class="line-modified">1298             volatile boolean pleaseThrow;</span>
<span class="line-added">1299             void maybeThrow() {</span>
<span class="line-added">1300                 if (pleaseThrow) {</span>
<span class="line-added">1301                     // assert: tryAcquire methods can throw at most once</span>
<span class="line-added">1302                     if (! thrown.compareAndSet(false, true))</span>
<span class="line-added">1303                         throw new AssertionError();</span>
<span class="line-added">1304                     throw ex;</span>
<span class="line-added">1305                 }</span>
<span class="line-added">1306             }</span>
<span class="line-added">1307 </span>
1308             @Override protected boolean tryAcquire(long ignored) {
<span class="line-modified">1309                 maybeThrow();</span>
1310                 return false;
1311             }
1312             @Override protected long tryAcquireShared(long ignored) {
<span class="line-modified">1313                 maybeThrow();</span>
1314                 return -1;
1315             }
1316             @Override protected boolean tryRelease(long ignored) {
1317                 return true;
1318             }
1319             @Override protected boolean tryReleaseShared(long ignored) {
1320                 return true;
1321             }
1322         }
1323 
1324         final Sync s = new Sync();
<span class="line-modified">1325         final boolean acquireInterruptibly = randomBoolean();</span>
<span class="line-added">1326         final Action[] uninterruptibleAcquireActions = {</span>
<span class="line-added">1327             () -&gt; s.acquire(1),</span>
<span class="line-added">1328             () -&gt; s.acquireShared(1),</span>
<span class="line-added">1329         };</span>
<span class="line-added">1330         final long nanosTimeout = MILLISECONDS.toNanos(2 * LONG_DELAY_MS);</span>
<span class="line-added">1331         final Action[] interruptibleAcquireActions = {</span>
<span class="line-added">1332             () -&gt; s.acquireInterruptibly(1),</span>
<span class="line-added">1333             () -&gt; s.acquireSharedInterruptibly(1),</span>
<span class="line-added">1334             () -&gt; s.tryAcquireNanos(1, nanosTimeout),</span>
<span class="line-added">1335             () -&gt; s.tryAcquireSharedNanos(1, nanosTimeout),</span>
<span class="line-added">1336         };</span>
<span class="line-added">1337         final Action[] releaseActions = {</span>
<span class="line-added">1338             () -&gt; s.release(1),</span>
<span class="line-added">1339             () -&gt; s.releaseShared(1),</span>
<span class="line-added">1340         };</span>
<span class="line-added">1341         final Action acquireAction = acquireInterruptibly</span>
<span class="line-added">1342             ? chooseRandomly(interruptibleAcquireActions)</span>
<span class="line-added">1343             : chooseRandomly(uninterruptibleAcquireActions);</span>
<span class="line-added">1344         final Action releaseAction</span>
<span class="line-added">1345             = chooseRandomly(releaseActions);</span>
<span class="line-added">1346 </span>
<span class="line-added">1347         // From os_posix.cpp:</span>
<span class="line-added">1348         //</span>
<span class="line-added">1349         // NOTE that since there is no &quot;lock&quot; around the interrupt and</span>
<span class="line-added">1350         // is_interrupted operations, there is the possibility that the</span>
<span class="line-added">1351         // interrupted flag (in osThread) will be &quot;false&quot; but that the</span>
<span class="line-added">1352         // low-level events will be in the signaled state. This is</span>
<span class="line-added">1353         // intentional. The effect of this is that Object.wait() and</span>
<span class="line-added">1354         // LockSupport.park() will appear to have a spurious wakeup, which</span>
<span class="line-added">1355         // is allowed and not harmful, and the possibility is so rare that</span>
<span class="line-added">1356         // it is not worth the added complexity to add yet another lock.</span>
1357         final Thread thread = newStartedThread(new CheckedRunnable() {
<span class="line-modified">1358             public void realRun() throws Throwable {</span>
1359                 try {
<span class="line-modified">1360                     acquireAction.run();</span>



1361                     shouldThrow();
<span class="line-modified">1362                 } catch (InterruptedException possible) {</span>
<span class="line-modified">1363                     assertTrue(acquireInterruptibly);</span>
<span class="line-modified">1364                     assertFalse(Thread.interrupted());</span>
<span class="line-added">1365                 } catch (PleaseThrow possible) {</span>
<span class="line-added">1366                     awaitInterrupted();</span>
1367                 }
1368             }});
<span class="line-modified">1369         for (long startTime = 0L;; ) {</span>
<span class="line-modified">1370             waitForThreadToEnterWaitState(thread);</span>
<span class="line-modified">1371             if (s.getFirstQueuedThread() == thread</span>
<span class="line-modified">1372                 &amp;&amp; s.hasQueuedPredecessors()</span>
<span class="line-modified">1373                 &amp;&amp; s.hasQueuedThreads()</span>
<span class="line-added">1374                 &amp;&amp; s.getQueueLength() == 1</span>
<span class="line-added">1375                 &amp;&amp; s.hasContended())</span>
<span class="line-added">1376                 break;</span>
<span class="line-added">1377             if (startTime == 0L)</span>
<span class="line-added">1378                 startTime = System.nanoTime();</span>
<span class="line-added">1379             else if (millisElapsedSince(startTime) &gt; LONG_DELAY_MS)</span>
<span class="line-added">1380                 fail(&quot;timed out waiting for AQS state: &quot;</span>
<span class="line-added">1381                      + &quot;thread state=&quot; + thread.getState()</span>
<span class="line-added">1382                      + &quot;, queued threads=&quot; + s.getQueuedThreads());</span>
<span class="line-added">1383             Thread.yield();</span>
<span class="line-added">1384         }</span>
1385 
1386         s.pleaseThrow = true;
<span class="line-modified">1387         // release and interrupt, in random order</span>
<span class="line-modified">1388         if (randomBoolean()) {</span>
<span class="line-added">1389             thread.interrupt();</span>
<span class="line-added">1390             releaseAction.run();</span>
<span class="line-added">1391         } else {</span>
<span class="line-added">1392             releaseAction.run();</span>
<span class="line-added">1393             thread.interrupt();</span>
<span class="line-added">1394         }</span>
1395         awaitTermination(thread);
<span class="line-added">1396 </span>
<span class="line-added">1397         if (! acquireInterruptibly)</span>
<span class="line-added">1398             assertTrue(thrown.get());</span>
<span class="line-added">1399 </span>
<span class="line-added">1400         assertNull(s.getFirstQueuedThread());</span>
<span class="line-added">1401         assertFalse(s.hasQueuedPredecessors());</span>
<span class="line-added">1402         assertFalse(s.hasQueuedThreads());</span>
<span class="line-added">1403         assertEquals(0, s.getQueueLength());</span>
<span class="line-added">1404         assertTrue(s.getQueuedThreads().isEmpty());</span>
<span class="line-added">1405         assertTrue(s.hasContended());</span>
1406     }
1407 
1408 }
</pre>
</td>
</tr>
</table>
<center><a href="../locks/ReentrantReadWriteLock/MapLoops.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="AbstractQueuedSynchronizerTest.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
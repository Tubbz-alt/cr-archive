<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New test/jdk/java/util/concurrent/locks/Lock/TimedAcquireLeak.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2007, 2018, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 /*
 25  * @test
 26  * @bug 6460501 6236036 6500694 6490770
 27  * @summary Repeated failed timed waits shouldn&#39;t leak memory
 28  * @library /test/lib
 29  * @author Martin Buchholz
 30  */
 31 
 32 import static java.util.concurrent.TimeUnit.MILLISECONDS;
 33 import static java.util.concurrent.TimeUnit.NANOSECONDS;
 34 
 35 import java.io.File;
 36 import java.io.FileOutputStream;
 37 import java.io.IOException;
 38 import java.io.InputStream;
 39 import java.io.InputStreamReader;
 40 import java.io.OutputStream;
 41 import java.io.PrintStream;
 42 import java.io.Reader;
 43 import java.lang.ref.ReferenceQueue;
 44 import java.lang.ref.WeakReference;
 45 import java.util.ArrayList;
 46 import java.util.Collections;
 47 import java.util.concurrent.BlockingQueue;
 48 import java.util.concurrent.Callable;
 49 import java.util.concurrent.CountDownLatch;
 50 import java.util.concurrent.CyclicBarrier;
 51 import java.util.concurrent.ExecutorService;
 52 import java.util.concurrent.Executors;
 53 import java.util.concurrent.Future;
 54 import java.util.concurrent.LinkedBlockingQueue;
 55 import java.util.concurrent.Semaphore;
 56 import java.util.concurrent.ThreadLocalRandom;
 57 import java.util.concurrent.locks.ReentrantLock;
 58 import java.util.concurrent.locks.ReentrantReadWriteLock;
 59 import java.util.regex.Matcher;
 60 import java.util.regex.Pattern;
 61 import jdk.test.lib.Utils;
 62 
 63 public class TimedAcquireLeak {
 64     static final long LONG_DELAY_MS = Utils.adjustTimeout(10_000);
 65 
 66     static String javahome() {
 67         String jh = System.getProperty(&quot;java.home&quot;);
 68         return (jh.endsWith(&quot;jre&quot;)) ? jh.substring(0, jh.length() - 4) : jh;
 69     }
 70 
 71     static final File bin = new File(javahome(), &quot;bin&quot;);
 72 
 73     static String javaProgramPath(String programName) {
 74         return new File(bin, programName).getPath();
 75     }
 76 
 77     static final String javaPath = javaProgramPath(&quot;java&quot;);
 78     static final String jmapPath = javaProgramPath(&quot;jmap&quot;);
 79     static final String jpsPath  = javaProgramPath(&quot;jps&quot;);
 80 
 81     static String outputOf(Reader r) throws IOException {
 82         final StringBuilder sb = new StringBuilder();
 83         final char[] buf = new char[1024];
 84         int n;
 85         while ((n = r.read(buf)) &gt; 0)
 86             sb.append(buf, 0, n);
 87         return sb.toString();
 88     }
 89 
 90     static String outputOf(InputStream is) throws IOException {
 91         return outputOf(new InputStreamReader(is, &quot;UTF-8&quot;));
 92     }
 93 
 94     static final ExecutorService drainers = Executors.newFixedThreadPool(12);
 95     static Future&lt;String&gt; futureOutputOf(final InputStream is) {
 96         return drainers.submit(
 97             new Callable&lt;String&gt;() { public String call() throws IOException {
 98                     return outputOf(is); }});}
 99 
100     static String outputOf(final Process p) {
101         try {
102             Future&lt;String&gt; outputFuture = futureOutputOf(p.getInputStream());
103             Future&lt;String&gt; errorFuture = futureOutputOf(p.getErrorStream());
104             final String output = outputFuture.get();
105             final String error = errorFuture.get();
106             // Check for successful process completion
107             equal(error, &quot;&quot;);
108             equal(p.waitFor(), 0);
109             equal(p.exitValue(), 0);
110             return output;
111         } catch (Throwable t) { unexpected(t); throw new Error(t); }
112     }
113 
114     static String commandOutputOf(String... cmd) {
115         try { return outputOf(new ProcessBuilder(cmd).start()); }
116         catch (Throwable t) { unexpected(t); throw new Error(t); }
117     }
118 
119     // To be called exactly twice by the parent process
120     static &lt;T&gt; T rendezvousParent(Process p,
121                                   Callable&lt;T&gt; callable) throws Throwable {
122         p.getInputStream().read();
123         T result = callable.call();
124         sendByte(p.getOutputStream());
125         return result;
126     }
127 
128     /** No guarantees, but effective in practice. */
129     private static void forceFullGc() {
130         long timeoutMillis = 1000L;
131         CountDownLatch finalized = new CountDownLatch(1);
132         ReferenceQueue&lt;Object&gt; queue = new ReferenceQueue&lt;&gt;();
133         WeakReference&lt;Object&gt; ref = new WeakReference&lt;&gt;(
134             new Object() { protected void finalize() { finalized.countDown(); }},
135             queue);
136         try {
137             for (int tries = 3; tries--&gt; 0; ) {
138                 System.gc();
139                 if (finalized.await(timeoutMillis, MILLISECONDS)
140                     &amp;&amp; queue.remove(timeoutMillis) != null
141                     &amp;&amp; ref.get() == null) {
142                     System.runFinalization(); // try to pick up stragglers
143                     return;
144                 }
145                 timeoutMillis *= 4;
146             }
147         } catch (InterruptedException unexpected) {
148             throw new AssertionError(&quot;unexpected InterruptedException&quot;);
149         }
150         throw new AssertionError(&quot;failed to do a \&quot;full\&quot; gc&quot;);
151     }
152 
153     // To be called exactly twice by the child process
154     public static void rendezvousChild() {
155         try {
156             forceFullGc();
157             sendByte(System.out);
158             System.in.read();
159         } catch (Throwable t) { throw new Error(t); }
160     }
161 
162     static String match(String s, String regex, int group) {
163         Matcher matcher = Pattern.compile(regex).matcher(s);
164         if (! matcher.find()) {
165             String msg = String.format(
166                 &quot;match failed: s=%s regex=%s&quot;, s, regex);
167             throw new AssertionError(msg);
168         }
169         return matcher.group(group);
170     }
171 
172     /** It&#39;s all about sending a message! */
173     static void sendByte(OutputStream s) throws IOException {
174         s.write(&#39;!&#39;);
175         s.flush();
176     }
177 
178     static int objectsInUse(final Process child,
179                             final String childPid,
180                             final String classNameRegex) {
181         String regex =
182             &quot;(?m)^ *[0-9]+: +([0-9]+) +[0-9]+ +&quot;+classNameRegex+&quot;(?:$| )&quot;;
183         Callable&lt;Integer&gt; objectsInUse = () -&gt; {
184             int i = Integer.parseInt(
185                 match(commandOutputOf(jmapPath, &quot;-histo:live&quot;, childPid),
186                       regex, 1));
187             if (i &gt; 100)
188                 System.out.print(
189                     commandOutputOf(jmapPath,
190                                     &quot;-dump:file=dump,format=b&quot;,
191                                     childPid));
192             return i;
193         };
194         try { return rendezvousParent(child, objectsInUse); }
195         catch (Throwable t) { unexpected(t); return -1; }
196     }
197 
198     static void realMain(String[] args) throws Throwable {
199         // jmap doesn&#39;t work on Windows
200         if (System.getProperty(&quot;os.name&quot;).startsWith(&quot;Windows&quot;))
201             return;
202 
203         final String childClassName = Job.class.getName();
204         final String classNameRegex = Job.classNameRegexToCheckForLeaks();
205         final String uniqueID = String.valueOf(
206             ThreadLocalRandom.current().nextInt(Integer.MAX_VALUE));
207 
208         final ArrayList&lt;String&gt; jobCmd = new ArrayList&lt;&gt;();
209         Collections.addAll(
210             jobCmd, javaPath, &quot;-Xmx8m&quot;, &quot;-XX:+UsePerfData&quot;,
211             &quot;-classpath&quot;, System.getProperty(&quot;test.class.path&quot;));
212         Collections.addAll(jobCmd, Utils.getTestJavaOpts());
213         Collections.addAll(jobCmd, childClassName, uniqueID);
214         final Process p = new ProcessBuilder(jobCmd).start();
215         // Ensure subprocess jvm has started, so that jps can find it
216         p.getInputStream().read();
217         sendByte(p.getOutputStream());
218 
219         final String childPid =
220             match(commandOutputOf(jpsPath, &quot;-m&quot;),
221                   &quot;(?m)^ *([0-9]+) +\\Q&quot;+childClassName+&quot;\\E *&quot;+uniqueID+&quot;$&quot;, 1);
222 
223         final int n0 = objectsInUse(p, childPid, classNameRegex);
224         final int n1 = objectsInUse(p, childPid, classNameRegex);
225         equal(p.waitFor(), 0);
226         equal(p.exitValue(), 0);
227         failed += p.exitValue();
228 
229         // Check that no objects were leaked.
230         //
231         // TODO: This test is very brittle, depending on current JDK
232         // implementation, and needing occasional adjustment.
233         System.out.printf(&quot;%d -&gt; %d%n&quot;, n0, n1);
234         // Almost always n0 == n1
235         // Maximum jitter observed in practice is 7
236         check(Math.abs(n1 - n0) &lt; 10);
237         check(n1 &lt; 25);
238         drainers.shutdown();
239         if (!drainers.awaitTermination(LONG_DELAY_MS, MILLISECONDS)) {
240             drainers.shutdownNow(); // last resort
241             throw new AssertionError(&quot;thread pool did not terminate&quot;);
242         }
243     }
244 
245     //----------------------------------------------------------------
246     // The main class of the child process.
247     // Job&#39;s job is to:
248     // - provide the name of a class to check for leaks.
249     // - call rendezvousChild exactly twice, while quiescent.
250     // - in between calls to rendezvousChild, run code that may leak.
251     //----------------------------------------------------------------
252     public static class Job {
253         static String classNameRegexToCheckForLeaks() {
254             return
255                 &quot;\\Qjava.util.concurrent.locks.AbstractQueuedSynchronizer$\\E[A-Za-z]+&quot;;
256         }
257 
258         public static void main(String[] args) throws Throwable {
259             // Synchronize with parent process, so that jps can find us
260             sendByte(System.out);
261             System.in.read();
262 
263             final ReentrantLock lock = new ReentrantLock();
264             lock.lock();
265 
266             final ReentrantReadWriteLock rwlock
267                 = new ReentrantReadWriteLock();
268             final ReentrantReadWriteLock.ReadLock readLock
269                 = rwlock.readLock();
270             final ReentrantReadWriteLock.WriteLock writeLock
271                 = rwlock.writeLock();
272             rwlock.writeLock().lock();
273 
274             final BlockingQueue&lt;Object&gt; q = new LinkedBlockingQueue&lt;&gt;();
275             final Semaphore fairSem = new Semaphore(0, true);
276             final Semaphore unfairSem = new Semaphore(0, false);
277             //final int threads =
278             //rnd.nextInt(Runtime.getRuntime().availableProcessors() + 1) + 1;
279             final int threads = 3;
280             // On Linux, this test runs very slowly for some reason,
281             // so use a smaller number of iterations.
282             // Solaris can handle 1 &lt;&lt; 18.
283             // On the other hand, jmap is much slower on Solaris...
284             final int iterations = 1 &lt;&lt; 8;
285             final CyclicBarrier cb = new CyclicBarrier(threads+1);
286 
287             for (int i = 0; i &lt; threads; i++)
288                 new Thread() { public void run() {
289                     try {
290                         final ThreadLocalRandom rnd = ThreadLocalRandom.current();
291                         for (int j = 0; j &lt; iterations; j++) {
292                             if (j == iterations/10 || j == iterations - 1) {
293                                 cb.await(); // Quiesce
294                                 cb.await(); // Resume
295                             }
296                             //int t = rnd.nextInt(2000);
297                             int t = rnd.nextInt(900);
298                             check(! lock.tryLock(t, NANOSECONDS));
299                             check(! readLock.tryLock(t, NANOSECONDS));
300                             check(! writeLock.tryLock(t, NANOSECONDS));
301                             equal(null, q.poll(t, NANOSECONDS));
302                             check(! fairSem.tryAcquire(t, NANOSECONDS));
303                             check(! unfairSem.tryAcquire(t, NANOSECONDS));
304                         }
305                     } catch (Throwable t) { unexpected(t); }
306                 }}.start();
307 
308             cb.await();         // Quiesce
309             rendezvousChild();  // Measure
310             cb.await();         // Resume
311 
312             cb.await();         // Quiesce
313             rendezvousChild();  // Measure
314             cb.await();         // Resume
315 
316             System.exit(failed);
317         }
318 
319         // If something goes wrong, we might never see it, since IO
320         // streams are connected to the parent.  So we need a special
321         // purpose print method to debug Jobs.
322         static void debugPrintf(String format, Object... args) {
323             try {
324                 new PrintStream(new FileOutputStream(&quot;/dev/tty&quot;))
325                     .printf(format, args);
326             } catch (Throwable t) { throw new Error(t); }
327         }
328     }
329 
330     //--------------------- Infrastructure ---------------------------
331     static volatile int passed = 0, failed = 0;
332     static void pass() {passed++;}
333     static void fail() {failed++; Thread.dumpStack();}
334     static void fail(String msg) {System.out.println(msg); fail();}
335     static void unexpected(Throwable t) {failed++; t.printStackTrace();}
336     static void check(boolean cond) {if (cond) pass(); else fail();}
337     static void check(boolean cond, String m) {if (cond) pass(); else fail(m);}
338     static void equal(Object x, Object y) {
339         if (x == null ? y == null : x.equals(y)) pass();
340         else fail(x + &quot; not equal to &quot; + y);}
341     public static void main(String[] args) throws Throwable {
342         try {realMain(args);} catch (Throwable t) {unexpected(t);}
343         System.out.printf(&quot;%nPassed = %d, failed = %d%n%n&quot;, passed, failed);
344         if (failed &gt; 0) throw new AssertionError(&quot;Some tests failed&quot;);}
345 }
    </pre>
  </body>
</html>
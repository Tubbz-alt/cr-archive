<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames test/jdk/java/util/concurrent/Executors/PrivilegedCallables.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (c) 2007, 2013, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 /*
 25  * @test
 26  * @bug 6552961 6558429
 27  * @summary Test privilegedCallable, privilegedCallableUsingCurrentClassLoader
 28  * @run main/othervm PrivilegedCallables
 29  * @author Martin Buchholz
 30  */
 31 
 32 import static java.util.concurrent.Executors.privilegedCallable;
 33 import static java.util.concurrent.Executors.privilegedCallableUsingCurrentClassLoader;
 34 import static java.util.concurrent.Executors.privilegedThreadFactory;
 35 
 36 import java.security.AccessControlException;
 37 import java.security.CodeSource;
 38 import java.security.Permission;
 39 import java.security.PermissionCollection;
 40 import java.security.Permissions;
 41 import java.security.ProtectionDomain;
 42 import java.util.Random;
 43 import java.util.concurrent.Callable;
 44 
 45 public class PrivilegedCallables {
 46     Callable&lt;Integer&gt; real;
 47 
 48     final Callable&lt;Integer&gt; realCaller = new Callable&lt;&gt;() {
 49         public Integer call() throws Exception {
 50             return real.call(); }};
 51 
 52     final Random rnd = new Random();
 53 
 54     @SuppressWarnings(&quot;serial&quot;)
 55     final Throwable[] throwables = {
 56         new Exception() {},
 57         new RuntimeException() {},
 58         new Error() {}
 59     };
 60     Throwable randomThrowable() {
 61         return throwables[rnd.nextInt(throwables.length)];
 62     }
 63     void throwThrowable(Throwable t) throws Exception {
 64         if (t instanceof Error) throw (Error) t;
 65         if (t instanceof RuntimeException) throw (RuntimeException) t;
 66         throw (Exception) t;
 67     }
 68 
 69     //----------------------------------------------------------------
 70     // A Policy class designed to make permissions fiddling very easy.
 71     //----------------------------------------------------------------
 72     static class Policy extends java.security.Policy {
<a name="1" id="anc1"></a>

 73         private Permissions perms;
 74 
 75         public void setPermissions(Permission...permissions) {
 76             perms = new Permissions();
 77             for (Permission permission : permissions)
 78                 perms.add(permission);
 79         }
 80 
 81         public Policy() { setPermissions(/* Nothing */); }
 82 
 83         public PermissionCollection getPermissions(CodeSource cs) {
 84             return perms;
 85         }
 86 
 87         public PermissionCollection getPermissions(ProtectionDomain pd) {
 88             return perms;
 89         }
 90 
 91         public boolean implies(ProtectionDomain pd, Permission p) {
<a name="2" id="anc2"></a><span class="line-modified"> 92             return perms.implies(p);</span>
 93         }
 94 
 95         public void refresh() {}
 96     }
 97 
 98     void test(String[] args) {
 99         testPrivileged();
100 
101         final Policy policy = new Policy();
102         Policy.setPolicy(policy);
103         policy.setPermissions(new RuntimePermission(&quot;getClassLoader&quot;),
104                               new RuntimePermission(&quot;setContextClassLoader&quot;));
105         System.setSecurityManager(new SecurityManager());
106 
107         testPrivileged();
108 
109         policy.setPermissions(/* Nothing */);
110 
111         THROWS(AccessControlException.class,
112                new F() {void f(){ privilegedCallableUsingCurrentClassLoader(realCaller); }},
113                new F() {void f(){ privilegedThreadFactory(); }});
114 
115         policy.setPermissions(new RuntimePermission(&quot;setSecurityManager&quot;));
116         System.setSecurityManager(null);
117     }
118 
119     void testPrivileged() {
120         try { test(privilegedCallable(realCaller)); }
121         catch (Throwable t) { unexpected(t); }
122 
123         try { test(privilegedCallableUsingCurrentClassLoader(realCaller)); }
124         catch (Throwable t) { unexpected(t); }
125 
126         try { privilegedThreadFactory(); }
127         catch (Throwable t) { unexpected(t); }
128     }
129 
130     void test(final Callable&lt;Integer&gt; c) throws Throwable {
131         for (int i = 0; i &lt; 20; i++)
132             if (rnd.nextBoolean()) {
133                 final Throwable t = randomThrowable();
134                 real = new Callable&lt;&gt;() {
135                     public Integer call() throws Exception {
136                         throwThrowable(t);
137                         return null; }};
138                 try {
139                     c.call();
140                     fail(&quot;Expected exception not thrown&quot;);
141                 } catch (Throwable tt) { check(t == tt); }
142             } else {
143                 final int n = rnd.nextInt();
144                 real = new Callable&lt;&gt;() {
145                     public Integer call() { return n; }};
146                 equal(c.call(), n);
147             }
148     }
149 
150     //--------------------- Infrastructure ---------------------------
151     volatile int passed = 0, failed = 0;
152     void pass() {passed++;}
153     void fail() {failed++; Thread.dumpStack();}
154     void fail(String msg) {System.err.println(msg); fail();}
155     void unexpected(Throwable t) {failed++; t.printStackTrace();}
156     void check(boolean cond) {if (cond) pass(); else fail();}
157     void equal(Object x, Object y) {
158         if (x == null ? y == null : x.equals(y)) pass();
159         else fail(x + &quot; not equal to &quot; + y);}
160     public static void main(String[] args) throws Throwable {
161         new PrivilegedCallables().instanceMain(args);}
162     void instanceMain(String[] args) throws Throwable {
163         try {test(args);} catch (Throwable t) {unexpected(t);}
164         System.out.printf(&quot;%nPassed = %d, failed = %d%n%n&quot;, passed, failed);
165         if (failed &gt; 0) throw new AssertionError(&quot;Some tests failed&quot;);}
166     abstract class F {abstract void f() throws Throwable;}
167     void THROWS(Class&lt;? extends Throwable&gt; k, F... fs) {
168         for (F f : fs)
169             try {f.f(); fail(&quot;Expected &quot; + k.getName() + &quot; not thrown&quot;);}
170             catch (Throwable t) {
171                 if (k.isAssignableFrom(t.getClass())) pass();
172                 else unexpected(t);}}
173 }
<a name="3" id="anc3"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="3" type="hidden" />
</body>
</html>